{"ver":"0.1","info":{"id":"lt23WV","date":"1432820839","viewed":1700,"name":"ZoomTest","username":"dila","description":"http://www.fractalforums.com/new-theories-and-research/exact-de-formulas-and-fractal-types/","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["fractal","test","zoom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nvec3 paxis(vec3 p)\n{\n    vec3 a=abs(p),r = vec3(1.0,0.0,0.0);\n    if(a.z>=max(a.x,a.y))r=r.yzx;\n    else if(a.y>=a.x)r=r.zxy;\n    return r*sign(p);\n}\n\nvec3 ddt(vec3 s)\n{\n\tvec3 r;\n    vec3 as = abs(s);\n\tr.x = s.x * min((1.0 - as.y),(1.0 - as.z));\n    r.y = s.y * min((1.0 - as.x),(1.0 - as.z));\n    r.z = s.z * min((1.0 - as.x),(1.0 - as.y));\n    return r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBoxInfinite( vec3 p, vec3 b )\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 map(vec3 p)\n{\n    float k = 12.0;\n\n    p.z = (fract(p.z/k) * 2.0 - 1.0) * k * 0.5;\n    \n    vec3 op = p;\n    \n    float d = 1000.0;\n    \n    vec3 ip = p;\n    \n    float bs = 1.0;\n    float r = 0.0;\n    \n    const int it = 6;\n    for (int i = 0; i < it; ++i) {\n\n        float nbs = bs;\n        bs = nbs * 0.5;\n\n        vec3 pn = paxis(ip);\n        \n        vec3 apn = abs(pn);\n        \n        pn += sign(pn) * max(apn.x,max(apn.y,apn.z));\n        \n        vec3 disp = ddt(normalize(ip));\n        \n        pn += disp * 3.0;\n\n\t\tip -= pn * nbs;\n\n        float fd = length(ip) - nbs;\n        \n        if (fd < d) {\n            d = fd;\n            r = float(i);\n        }\n        \n        float nm = float(i) / float(it-1);\n        float rd = mix(1.5, 0.5, nm);\n        //d = max(d, rd-length(op.xy));\n        d = max(d, -sdBoxInfinite(op,vec3(rd)));\n\t}\n    \n    return vec2(d,r);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 0.25 - dot(uv,uv) * 0.33));\n    r *= zrot(iTime);\n\tvec3 o = vec3(0.0, 0.0, -10.0);\n    o.z += iTime;\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 mp = map(w);\n    float fd = mp.x;\n    float it = mp.y;\n    vec3 sn = normal(w);\n    float prod = max(dot(sn,-r),0.0);\n    \n    vec3 lpos = o + vec3(0.0, 0.0, 4.0);\n    vec3 ldir = normalize(lpos - w);\n    float lprod = max(dot(sn,ldir), 0.0);\n    vec3 ref = reflect(sn, ldir);\n    float rprod = max(dot(r, ref), 0.0);\n    rprod = pow(rprod, 4.0);\n\n\tfloat fog = 1.0 / (1.0 + t * t * 0.001);\n    float edge = 1.0 / (1.0 + fd * 100.0);\n    \n\tvec3 diff = 0.5 + 0.5 * vec3(1.0-cos(it), cos(it), sin(w.z));\n    \n    diff *= prod * 4.0;\n    \n    diff += rprod;\n    \n    diff *= fog * edge;\n        \n\tfragColor = vec4(diff,1.0);\n}","name":"","description":"","type":"image"}]}