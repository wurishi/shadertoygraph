{"ver":"0.1","info":{"id":"WslBz7","date":"1587935602","viewed":456,"name":"Pixel-art water reflections","username":"jaszunio15","description":"Just experimenting with pixel-art style.\n\nWater inspired by Kingdom Classic scene:\nhttps://i.pinimg.com/originals/1c/26/01/1c260197bd43c01d8d9f8f19135cff07.gif\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["2d","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n#define WATER_HEIGHT 0.34\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv must be pixelized same as in BufferA image\n    \n    //buffer A UV\n    vec2 imageUV = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 pixelatedUV = imageUV; \n    PIXELIZE_UV(pixelatedUV);\n    \n    //calculating pixelization vector in actual UV\n    vec2 pixelizeVector = pixelatedUV - imageUV;\n   \tpixelizeVector /= 2.0;\n    pixelizeVector.x /= iResolution.x / iResolution.y;\n    \n    //Apply pixelization vector with bias\n    uv += pixelizeVector + 0.002;\n    \n    \n    \n   \tfloat water = step(WATER_HEIGHT, uv.y);\n    \n    if (uv.y < WATER_HEIGHT)\n    {\n        uv.y = abs(uv.y - WATER_HEIGHT) + WATER_HEIGHT;\n        \n        float waves = texture(iChannel1, uv * vec2(0.1, 1.0) + vec2(TIME * 0.001 + uv.y * 10.0, 0.0)).r;\n        waves = pow(waves, 10.0) * 0.1;\n        \n        float distortion = texture(iChannel1, uv * vec2(0.3, 0.3) + vec2(TIME * 0.01 + uv.y * 10.0, 0.32)).r;\n        distortion = step(0.5, distortion);\n        \n        float distortionAngle = texture(iChannel1, uv * vec2(0.1, 1.0) + vec2(TIME * 0.01 + uv.y * 10.0, 0.75)).r;\n        distortionAngle *= 97.0721;\n        vec2 distortionVec = vec2(sin(distortionAngle), cos(distortionAngle));\n        \n        fragColor = texture(iChannel0, uv + distortionVec * distortion * 0.01) * 0.7; \n        fragColor += waves;\n     \tfragColor = mix(vec4(0.0), fragColor, clamp((-uv.y + 0.7) * 3.0, 0.0, 1.0));\n    }\n    else\n    {\n       \tfragColor = texture(iChannel0, uv); \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SKY_COLOR vec4(0.04, 0.04, 0.2, 1.0)\n#define GRASS_COLOR vec4(0.04, 0.5, 0.04, 1.0) * 0.8\n#define GROUND_COLOR vec4(0.4, 0.2, 0.04, 1.0)\n#define TERRAIN_HEIGHT -0.24\n#define MOON_POS vec2(0.91, 0.2)\n#define MOON_SIZE 0.2\n#define MOON_BLOOM_SIZE 1.0\n#define MOON_BLOOM_STRENGTH 0.3\n#define SNOW_COLOR vec4(0.2)\n#define MOUNTAIN_COLOR vec4(0.4, 0.3, 0.15, 1.0) * 0.3\n\n\n\n//source: https://iquilezles.org/articles/distfunctions2d\nfloat boxSDF( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 colorRect(vec2 uv, vec2 center, vec2 size, vec4 firstColor, vec4 secondColor)\n{\n    float rect = 1.0 - step(0.0, boxSDF(uv - center, size));\n    float noise = texture(iChannel0, uv).r;\n    vec4 color = mix(firstColor, secondColor, noise);\n    color.a = rect;\n    return color;\n}\n\nvoid applyColor(inout vec4 image, inout vec4 color)\n{\n \timage = mix(image, color, color.a);   \n}\n\nvec4 moon(vec2 uv, vec2 pos, float radius)\n{\n    vec4 color = texture(iChannel0, uv).rrrr;\n    color.rgb = mix(vec3(0.7), vec3(0.9), color.a);\n    color.a = 1.0 - step(radius, distance(uv, pos));\n    color.a *= step(radius, distance(uv, pos + vec2(0.5, 0.0) * radius));\n    return color;\n}\n\n\nvec4 mountains(vec2 uv, vec2 scale, vec2 offset)\n{\n    vec2 baseUV = uv;\n    uv = uv * scale + offset;\n    \n    float triangle = 0.0;\n    for (float i = 1.0; i <= 8.0; i *= 1.613)\n    {\n     \ttriangle += triangleWave(uv.x * i + i * 0.231) / pow(i, 0.7);\n    }\n    \n    vec4 color = vec4(1.0 - step(triangle * 0.3, uv.y));\n    \n    float snow = step(0.35 + sin(uv.x * 20.0) * 0.03, uv.y);\n    color.rgb = mix(MOUNTAIN_COLOR, SNOW_COLOR * (uv.y + 0.7), snow).rgb;\n    color.rgb *= 1.0 + (texture(iChannel0, baseUV).r - 0.5) * (0.1 + snow * 0.1);\n    \n    return color;\n}\n\nvec4 clouds(vec2 uv, float height)\n{\n    uv.x += TIME_10FPS * 0.1;\n    uv.y += sin(uv.x * 5.0) * 0.01;\n    uv.x += sin(uv.y * 60.0) * 1.0;\n \tfloat cloud = 1.0 - step(0.5, texture(iChannel0, uv * vec2(0.01, 0.2)).r);\n    cloud *= 1.0 - step(0.5, texture(iChannel0, uv * vec2(0.02, 0.4) + 0.4).r);\n    cloud = clamp(cloud, 0.0, 1.0);\n    \n    vec4 color = vec4(0.5);\n    color.a *= 0.5 * cloud * texture(iChannel0, uv).r;\n    color.a *= 1.0 - step(height, abs(uv.y));\n    \n    return color;\n}\n\n\nvec4 moonBloom(vec2 uv, vec2 pos, float radius)\n{\n    float bloom = smoothstep(radius, 0.0, distance(uv, pos));\n    return vec4(1.0) * bloom * bloom * MOON_BLOOM_STRENGTH;  \n}\n\nvec4 shrub(vec2 uv, vec2 pos, float radius, vec4 firstColor, vec4 secondColor)\n{\n    vec4 color = mix(firstColor, secondColor, texture(iChannel0, uv).r);\n    \n\tuv.x += sin(uv.y * 10.0 + TIME * 0.1) * 0.1;\n    uv.y += cos(uv.x * 7.0) * 0.13;\n    \n    uv.x += sin(uv.y * 102.0) * 0.1;\n    uv.y += cos(uv.x * 72.0) * 0.13;\n    \n    color.a = 1.0 - step(radius, distance(uv, pos));\n    \n    return color;\n}\n\nvec4 grass(vec2 uv, vec2 pos, float radius, vec4 firstColor, vec4 secondColor)\n{\n    vec4 color = mix(firstColor, secondColor, texture(iChannel0, uv).r);\n    \n\tuv.x += sin(uv.y * 10.0 + TIME * 0.51) * 0.1;\n    uv.y += cos(uv.x * 7.0) * 0.13;\n    \n    uv.x += sin(uv.y * 102.0) * 0.01;\n    uv.y += cos(uv.x * 72.0) * 0.13;\n    \n    color.a = 1.0 - step(radius, distance(uv, pos));\n    \n    return color;\n}\n\nvec4 tripSign(vec2 uv)\n{\n    vec4 color = vec4(0.3, 0.2, 0.1, 0.0) * 0.7;\n\tfloat poleSDF = boxSDF(uv, vec2(0.03, 0.2));\n    \n    color.rgb *= smoothstep(0.1, -0.1, poleSDF) * 1.4;\n    \n    color.a = 1.0 - step(0.0, poleSDF);\n    \n    uv *= mat2(cos(-0.18 + vec4(0, 11, 33, 0)));\n    float signSDF = boxSDF(uv + vec2(0.0, -0.1), vec2(0.13, 0.06));\n    float signAlpha = 1.0 - step(0.0, signSDF);\n    vec3 signCol = vec3(0.3, 0.2, 0.1) * smoothstep(0.1, -0.1, signSDF) * 1.4;\n    color = mix(color, vec4(signCol, 1.0), signAlpha);\n    \n    color.rgb *= 1.0 + (texture(iChannel0, uv).r - 0.5) * 0.2;\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n  \tPIXELIZE_UV(uv);\n    uv -= vec2(0.0, 0.1);\n    \n    vec4 image = vec4(0.0);\n    vec4 colorToApply;\n    \n    //sky as background\n    colorToApply = colorRect(uv, vec2(0.0), vec2(10.0), SKY_COLOR * 0.5, SKY_COLOR);\n    colorToApply.rgb *= (uv.y * 0.5 + 0.5);\n    applyColor(image, colorToApply);\n    \n    \n    //moon with bloom    \n    colorToApply = moon(uv, MOON_POS, MOON_SIZE);\n    applyColor(image, colorToApply);\n    image += moonBloom(uv, MOON_POS, MOON_BLOOM_SIZE);\n    \n    //clouds\n    colorToApply = clouds(uv - 0.5, 0.3);\n    applyColor(image, colorToApply);\n    \n    //mountains\n    colorToApply = mountains(uv, vec2(0.5, 1.0), vec2(0.5, 0.4));\n    applyColor(image, colorToApply);\n    \n    //sign\n    colorToApply = tripSign(uv + vec2(0.2, 0.0));\n    applyColor(image, colorToApply);\n    \n    //plant1\n    colorToApply = shrub(uv, vec2(-1.0, 0.0), 0.2, GRASS_COLOR * 0.4, GRASS_COLOR * 0.8);\n    applyColor(image, colorToApply);\n    \n    //plant1\n    colorToApply = grass(uv, vec2(0.5, -0.4), 0.1, GRASS_COLOR * 0.4, GRASS_COLOR * 0.8);\n    applyColor(image, colorToApply);\n    \n    //plant1\n    colorToApply = grass(uv, vec2(0.9, -0.4), 0.15, GRASS_COLOR * 0.4, GRASS_COLOR * 0.8);\n    applyColor(image, colorToApply);\n    \n    \n    float terrainHeight = clamp(sin(uv.x * 2.0 * exp(uv.x * 0.2)), -0.5, 0.9);\n    colorToApply = colorRect(uv, vec2(0.0, -0.13 * terrainHeight - 1.0 + TERRAIN_HEIGHT), vec2(10.0, 0.03+1.0), GROUND_COLOR * 0.5, GROUND_COLOR);\n    colorToApply.rgb *= (uv.y + 1.0);\n    applyColor(image, colorToApply);\n    \n    colorToApply = colorRect(uv, vec2(0.0, -0.13 * terrainHeight + TERRAIN_HEIGHT), vec2(10.0, 0.03), GROUND_COLOR * 0.5, GRASS_COLOR);\n    applyColor(image, colorToApply);  \n\n    \n    fragColor = vec4(image);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PIXELIZE_UV(uv) uv = uv - mod(uv, 0.02)\n\n#define TIME_10FPS (iTime - mod(iTime, 0.5))\n#define TIME (iTime)\n\nfloat triangleWave(float x)\n{\n \tx += 1000.0;\n    if (mod(x, 2.0) < 1.0) return 1.0 - fract(x);\n    else return fract(x);\n}","name":"Common","description":"","type":"common"}]}