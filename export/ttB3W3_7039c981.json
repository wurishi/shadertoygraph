{"ver":"0.1","info":{"id":"ttB3W3","date":"1561320446","viewed":622,"name":"darkcore","username":"gpfault","description":"deforming sdf with texture","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float nearPlaneDist() {\n const float fovDegrees = 45.0;\n return 1.0 / tan(radians(fovDegrees/2.0));\n}\n\nvec3 ray(vec2 pixel) {\n  vec2 uv = pixel / iResolution.xy;\n  vec2 xy = 2.0 * uv - vec2(1.0);\n  xy.x *= iResolution.x/iResolution.y;\n  return normalize(vec3(xy, nearPlaneDist()));\n}\n\nvec3 skyColor(vec3 ray) {\n  vec3 nearpt = ray * nearPlaneDist();\n  const vec3 top    = vec3(0.118, 0.118, 0.257);\n  const vec3 bottom = vec3(0.646, 0.337, 0.148);\n  return mix(bottom, top, clamp(nearpt.y, 0.0, 1.0));\n}\n\nfloat sphere(vec3 point, vec3 center, float radius) {\n  return length(point-center) - radius;\n}\n\nfloat noisySphere(vec3 point, vec3 center, float radius) {\n  vec3 dir = point - center;\n  dir.x += sin(iTime + cos(iTime/15.0));\n  dir.y += cos(iTime + sin(iTime/15.0));\n  dir *= 1.5+sin(iTime/2.0 + cos(iTime/18.0) * 3.0);\n  float displacement = length(texture(iChannel0, (dir.xy * 0.5 + 0.5))) * (0.3);\n  return sphere(point, center, radius + displacement);\n}\n\nvoid scene(vec3 point, out vec3 color, out float distance) {\n  color = vec3(0.005, 0.00, 0.03);\n  distance = noisySphere(point, vec3(0.0, 0.0, 2.8), 0.5);\n}\n\nfloat scenePartDeriv(vec3 x, int i) {\n  vec3 delta = vec3(0.0);\n  delta[i] = 0.001;\n  float d1, d2;\n  vec3 _1, _2;\n  scene(x + delta, _1, d1);\n  scene(x - delta, _2, d2);\n  return d1 - d2;\n}\n\nvec3 sceneNorm(vec3 p) {\n  return normalize(vec3(scenePartDeriv(p, 0),\n                        scenePartDeriv(p, 1),\n                        scenePartDeriv(p, 2)));\n}\n\nvec3 marchRay(vec3 r) {\n  float t = 1.0;\n  const int max_raymarch_steps = 100;\n  const float epsilon = 0.001;\n  const vec3 lightDir = vec3(0.0, 0.0, -1.0);\n  for (int steps = 0; steps < max_raymarch_steps; ++steps) {\n    vec3 point = r * t;\n    float dist;\n    vec3 albedo;\n    scene(point, albedo, dist);\n    if (dist < epsilon) {\n      vec3 n = sceneNorm(point);\n      vec3 l = vec3(0.0, 0.0, -1.0);\n      vec3 v = -r;\n      float lambert = dot(n, lightDir);\n      vec3 sky = skyColor(n);\n      float fresnel = pow(1.0 - dot(n, v), 5.0);\n      return albedo * lambert + sky * clamp(fresnel, 0.0, 1.0);\n    }\n    t += dist;\n  }\n  return skyColor(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 r = ray(fragCoord);\n  fragColor = vec4(pow(marchRay(r), vec3(0.4545)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}