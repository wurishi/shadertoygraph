{"ver":"0.1","info":{"id":"DdX3W7","date":"1666207503","viewed":74,"name":"Operators for SDF","username":"Envy24","description":"Hold LMB to see distance fields.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","intersection","difference","union","operator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )\n#define UNIT                      (  5.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n//#define SMAA(x)                   ( smoothstep(UNIT, 0., abs(x)) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 ndc_offset)\n{\n    /**\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - ndc_offset;          // apply \"static\" offset in ndc space\n}\n#define STD_MAP(SC) ( map_to_centered_ndc(SC, 1., vec2(0)) )\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved curves.\n\tcolor *= 0.7 + 0.2 * cos(50.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\n// Source: https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat intersect_sdf(float dl, float dr) { return max(dl, dr); }\nfloat union_sdf(float dl, float dr) { return min(dl, dr); }\nfloat difference_sdf(float dl, float dr) { return max(dl, -dr); }\n\nvec2 scene_sdf(vec2 NDC)\n{\n    float offs = sinOSC(-4.*UNIT, 4.*UNIT, iTime);\n    vec2 diskA = vec2(0., offs),\n         diskB = vec2(6.*offs, 0.);\n    return \n        vec2(\n            diskSDF_L2(NDC, diskA, 15.*UNIT),\n            diskSDF_L2(NDC, diskB, 15.*UNIT));\n}\n\n#define H ( 0.53/2. )\n\nvoid right_sub_scene0(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,0.8));\n    vec2 sdf = scene_sdf(NDC);\n    if (LMB_IS_HOLD == true && SC.x > R.x/2. && abs(NDC.y) < H)\n    {\n        color = colorize_field( intersect_sdf(sdf.x, sdf.y), vec3(0.1, 0.4, 0.7) );\n    }\n    else { color = mix( color, vec3(1,0,0), SMAA(intersect_sdf(sdf.x, sdf.y)) ); }\n}\n\nvoid right_sub_scene1(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,0.8-0.53));\n    vec2 sdf = scene_sdf(NDC);\n    if (LMB_IS_HOLD == true && SC.x > R.x/2. && abs(NDC.y) < H)\n    {\n        color = colorize_field( union_sdf(sdf.x, sdf.y), vec3(0.1, 0.4, 0.7) );\n    }\n    else { color = mix( color, vec3(1,0,0), SMAA(union_sdf(sdf.x, sdf.y)) ); }\n}\n\nvoid right_sub_scene2(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,-0.8+0.53));\n    vec2 sdf = scene_sdf(NDC);\n    if (LMB_IS_HOLD == true && SC.x > R.x/2. && abs(NDC.y) < H)\n    {\n        color = colorize_field( difference_sdf(sdf.x, sdf.y), vec3(0.1, 0.4, 0.7) );\n    }\n    else { color = mix( color, vec3(1,0,0), SMAA(difference_sdf(sdf.x, sdf.y)) ); }\n}\n\nvoid right_sub_scene3(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(1,-0.8));\n    vec2 sdf = scene_sdf(NDC);\n    if (LMB_IS_HOLD == true && SC.x > R.x/2. && abs(NDC.y) < H)\n    {\n        color = colorize_field( difference_sdf(sdf.y, sdf.x), vec3(0.1, 0.4, 0.7) );\n    }\n    else { color = mix( color, vec3(1,0,0), SMAA(difference_sdf(sdf.y, sdf.x)) ); }\n}\n\nvoid left_sub_scene(in vec2 SC, inout vec3 color)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(-AR+AR/2.,0));\n    float offs = sinOSC(-12.*UNIT, 12.*UNIT, iTime);\n    vec2 diskA = vec2(0., offs),\n         diskB = vec2(6.*offs, 0.);\n    /*Coloring*/\n    color = mix( color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, diskA, 45.*UNIT)) );\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, diskB, 45.*UNIT)) );  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec3 color = vec3(1);\n       \n    right_sub_scene0(SC, color);\n    right_sub_scene1(SC, color);\n    right_sub_scene2(SC, color);\n    right_sub_scene3(SC, color);\n    \n    vec2 NDC = STD_MAP(SC);\n    color -= vertical_line(NDC, 0.);\n    \n    if (NDC.x > 0.)\n    {\n        color -= horizontal_line(NDC, 0.);\n        color -= horizontal_line(abs(NDC), 0.53);\n    }\n    else { left_sub_scene(SC, color); }\n    \n    O = vec4(color, 1); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\n","name":"Common","description":"","type":"common"}]}