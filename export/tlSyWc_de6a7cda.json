{"ver":"0.1","info":{"id":"tlSyWc","date":"1595536844","viewed":895,"name":"Voxel Wireworld 3D","username":"spalmer","description":"3d wireworld implementation.\nfor controls, see Buffer A tab.\nforked kastorp's voxel game toy  - thanks, kastorp!\nso it's basically minecraft creative mode\nbut with wireworld instead of redstone.","likes":27,"published":1,"flags":48,"usePreview":0,"tags":["automata","cellular","logic","wireworld","circuits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D implementation of Wireworld cellular automata\n// by Brian Silverman https://wikipedia.org/wiki/Wireworld\n\n// fork of \"Voxel Game\" by kastorp https://shadertoy.com/view/WdffRn\n// fork of \"[SH16C] Voxel Game\" by fb39ca4 https://shadertoy.com/view/MtcGDH\n// I chopped most of the features out and\n// just barely got the actual CA evolution working\n\n// see also 2D \"Wireworld CA\" by bergi https://shadertoy.com/view/XstSzj\n// code-wise unrelated but kindred intent.\n\n/*\nCONTROLS:\n\tsee Buffer A tab\n\nTABS:\n\t- \"Common\":   shared #define settings, constants, colors, code for voxel access\n\t- \"Buffer A\": actions, controls, collision, settings\n\t- \"Buffer B\": voxel cache, world state\n\t- \"Buffer D\": rendering\n\t- \"Image\":    gui, debugging, post processing\n*/\n\nvec4 load(vec2 coord)\n{\n\treturn textureLod(iChannel0, vec2((floor(coord) + .5) / iChannelResolution[0].xy), 0.);\n}\n\nvec4 drawSelectionBox(vec2 c)\n{\n\tvec4 o = vec4(0.);\n\tfloat d = max(abs(c.x), abs(c.y));\n\tif (d > 6. && d < 9.) {\n\t\to.a = 1.;\n\t\to.rgb = vec3(0.9);\n\t\tif (d < 7.) o.rgb -= .3;\n\t\tif (d > 8.) o.rgb -= .1;\n\t}\n\treturn o;\n}\n\nmat2 inv2(mat2 m)\n{\n\treturn mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / (m[0][0] * m[1][1] - m[0][1] * m[1][0]);\n}\n\nvec4 drawInventory(vec2 c)\n{\n\tfloat scale = floor(iResolution.y / 128.);\n\tc /= scale;\n\tvec2 r = iResolution.xy / scale;\n\tvec4 o = vec4(0);\n\tfloat xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n\tc.x -= xStart;\n\tfloat selected = load(_selectedInventory).r;\n\tvec2 p = (fract(c / 16.) - .5) * 3.;\n\tvec2 u = vec2(sqrt(3.) / 2., .5);\n\tvec2 v = vec2(-sqrt(3.) / 2., .5);\n\tvec2 w = vec2(0, -1);\n\tif (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.) {\n\t\tfloat slot = floor(c.x / 16.);\n\t\to = vec4(.05,.05,.05,1); //getTexture(bBase, fract(c / 16.));\n\t\tvec3 b = vec3(dot(p, u), dot(p, v), dot(p, w));\n\t\tvec2 texCoord;\n\t\t//if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n\t\tfloat top = 0.;\n\t\tfloat right = 0.;\n\t\tif (b.z < b.x && b.z < b.y) {\n\t\t\ttexCoord = inv2(mat2(u, v)) * p.xy;\n\t\t\ttop = 1.;\n\t\t} else if (b.x < b.y) {\n\t\t\ttexCoord = 1. - inv2(mat2(v, w)) * p.xy;\n\t\t\tright = 1.;\n\t\t} else {\n\t\t\ttexCoord = inv2(mat2(u, w)) * p.xy;\n\t\t\ttexCoord.y = 1. - texCoord.y;\n\t\t}\n\t\tif (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n\t\t\tint id = getInventory(int(slot));\n\t\t\to.rgb = getTexture(int(id), texCoord).rgb\n                * (.5 + .25 * right + .5 * top)\n                ;\n\t\t\to.a = 1.;\n\t\t}\n\t}\n\tvec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));\n\to = mix(o, selection, selection.a);\n\treturn o;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tfloat pixelSize = pixSize(iResolution.xy); //load(_pixelSize).r;\n\tvec2 renderResolution = ceil(iResolution.xy / pixelSize);\n\tfragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n\tvec4 gui = drawInventory(fragCoord);\n\tfragColor = mix(fragColor, gui, gui.a);\n\tfragColor.rgb = pow(fragColor.rgb, vec3(1./2.2)); // to srgb gamut\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\tOPTIONS\n\tMAX_PICK_DISTANCE: distance for block selection with mouse (default = 10)\n\tFAST_COMPILE: use cheaper noise function (default = defined)\n\tSHADOW: renders shadows  (default = not defined, I kind of broke them somewhat)\n*/\n\n//CONFIGURABLE SETTINGS\n\n#define MAX_PICK_DISTANCE 15\n#define FAST_COMPILE\n//#define SHADOW\n\nconst float PICK_MINE_DELAY = .7;\n\n// block voxel types\nconst int\n  bVoid = 0 //bAir //bEmpty\n, bHead = 1 // electron - red\n, bTail = 2 // hole - green\n, bWire = 3 // semiconductor wire - blue\n, bBase = 4 // resistor - inert gray solid block - \n//, bButton = 5 // button generates a 1-tick pulse when pressed with mouse\n//, bSwitchOff = 6 // TODO semi-permanent switches with state, when interact w mouse should toggle state\n//, bSwitchOn = 7\n;\nconst float NUM_ITEMS = 4.; //12.;\n// TODO it has become obvious I need some sort of\n// switch and/or button type blocks that can be\n// interacted with, so I don't have to constantly\n// break and re-place blocks to generate pulses.\n// for now I just made an Interact key\n// that pulses the wire the mouse is picking\n\n// TODO ivec2\n// STATE\n#define var(name, x, y) const vec2 name = vec2(x, y)\nconst float varRow = 0.;\nvar(_pos, 0, varRow);\nvar(_oldPos, 1, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_oldLoadRange, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_loadDistLimit, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\n\nconst int nStatePixels = 16; // we assume the state fits into 16 pixels at most\n\nconst vec2 packedChunkSize = vec2(13, 7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord)\n{\n\tvec2 s = floor(storageCoord);\n\tfloat dist = max(s.x, s.y);\n\tfloat offset = floor(dist / 2.);\n\tfloat neg = step(.5, mod(dist, 2.)) * 2. - 1.;\n\treturn neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord)\n{\n\tvec2 c = chunkCoord;\n\tfloat dist = max(abs(c.x), abs(c.y));\n\tvec2 c2 = floor(abs(c - .5));\n\tfloat offset = max(c2.x, c2.y);\n\tfloat neg = step(c.x + c.y, 0.) * -2. + 1.;\n\treturn (neg * c) + offset;\n}\n\nfloat calcLoadDist(vec2 iResolutionxy, float limit)\n{\n\n\tvec2 chunks = floor(iResolutionxy / packedChunkSize);\n\tfloat gridSize = min(chunks.x, chunks.y);\n\treturn min(floor((gridSize - 1.) / 2.), limit);\n}\n\nvec4 calcLoadRange(vec2 pos, vec2 iResolutionxy, float border, float limit)\n{\n\tvec2 d = (calcLoadDist(iResolutionxy, limit) - border) * vec2(-1, 1);\n\treturn floor(pos).xxyy + d.xyxy;\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset)\n{\n\tvec3 voxelCoord = offset;\n\tvoxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n\tvoxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n\treturn voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord)\n{\n\tvec3 p = floor(voxCoord);\n\treturn swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nstruct voxel\n{\n\tint id;\n};\n\nvoxel decodeVoxel(vec4 textel)\n{\n\tvoxel o;\n\to.id = int(textel.r * 255. + 1e-7);\n\treturn o;\n}\n// use 8-bit/channel unorm colors instead of relying on float buffer type\nvec4 encodeVoxel(voxel v) \n{\n\tvec4 t = vec4(0);\n\tt.r = float(v.id) / 255.;\n\tt.a = 1.;\n\treturn t;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel, vec3 resolution)\n{\n\treturn textureLod(iChannel, (floor(pos) + .5) / (floor(resolution.xy)), 0.);\n}\n\nvoxel getCachedVoxel(vec3 p, sampler2D iChannel, vec3 resolution)\n{\n\treturn decodeVoxel(readMapTex(voxToTexCoord(p), iChannel, resolution));\n}\n\nbool isOpaque(int id)\n{\n\treturn id != 0;\n}\n\nbool isSolidVoxel(vec3 p, sampler2D iChannel, vec3 resolution) \n{\n\tvoxel vox = decodeVoxel(readMapTex(voxToTexCoord(p), iChannel, resolution));\n\treturn isOpaque(vox.id);\n}\n\n// main and image tabs share it\nvec4 getTexture(int id, vec2 uv, float d)\n{\n    vec4 r = vec4(0,0,0,1);\n    // gridlines, FIXME needs antialiasing\n\tfloat g = 1.-dot(vec2(1), step(vec2(.5-exp2(-6.)), abs(fract(uv)-.5)));\n    g = mix(1., g, exp2(-.2*d)); // fade gridlines in distance or they alias like mad!\n    switch (id) {\n        case bVoid: r = vec4(0); break;\n        case bHead: r.rg = vec2(g); break; // negatron or electron or whatever - bright yellow\n        case bTail: r.rg = vec2(.5*g); break; // positron or hole or whatever it's called, dimmer\n        case bWire: r.b = .3*g; break; // dim blue wire\n        case bBase: r.rgb = vec3(.1*g); break; // dim gray\n    }\n    return r;\n}\n\nvec4 getTexture(int id, vec2 uv)\n{\n    return getTexture(id, uv, 64.);\n}\n\nint getInventory(int slot)\n{\n\treturn slot + 1;\n}\n\nconst float PI = acos(-1.); //3.14159265359;\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nvoxel getGeneratedVoxel(vec3 voxelCoord)\n{\n\tvoxel vox;\n    vox.id = bVoid; // empty\n    ivec3 c = ivec3(voxelCoord);\n    ivec3 d = c & 3;\n\tif (c.z <= 1)\n\t\tvox.id = bBase;\t//'BEDROCK' layer of gray blocks to build on\n\telse if (c.z == 2\n\t\t&& (((c.x|c.y)>>2)&3)==0 // 4x4 sub-chunks\n\t\t//|| mod(max(abs(c.x),abs(c.y)), 32.) < 1.\n            ) {\n\t\t//vox.id = float(((c.x+c.y) & 3) + 1);\n        //vox.id = float(1 -\n        //      (((d.x + 1)>>1) & 1)\n        //    * (((d.y + 1)>>1) & 1)\n        //    )* 3.;\n        if (d.x != d.y && d.x != 3-d.y)\n            vox.id = bWire; // loops\n        if (vox.id == bWire && d.y == 0)\n            vox.id = d.x; // start a pulse\n    }\n\n\t//vox.light.s = lightDefault(voxelCoord.z);\n\treturn vox;\n}\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r)\n{\n\treturn p.x > r.x && p.x < r.y&& p.y > r.z && p.y < r.w;\n}\n\nvoxel getVoxelData(vec3 voxelCoord, sampler2D iChannel, vec3 resolution, int mode, vec4 range, vec3 offset)\n{\n\tif (mode == 0 || (mode == 1 && !inRange(voxelCoord.xy, range)))\n\t\treturn getGeneratedVoxel(voxelCoord);\n\treturn getCachedVoxel(voxelCoord - offset, iChannel, resolution);\n}\n\n// RENDERING\n\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 res)\n{\n    float sx = sin(angle.x), sy = sin(angle.y), cx = cos(angle.x), cy = cos(angle.y);\n\tvec3 d = vec3(sy * cx, sy * sx, cy)\n\t, u = vec3(normalize(vec2(d.y, -d.x)), 0)\n\t, v = cross(u, d) * res.y / res.x;\n\treturn normalize(d + uv.x * u + uv.y * v);\n}\n\nfloat pixSize(vec2 res)\n{\n    return 1.; //res.y < 640. ? 1. : res.y < 960. ? 2. : 4.; //clamp(floor(sqrt(res.y) / 24.), 1., 8.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tACTIONS \n\tClick and drag mouse to look, select blocks\n\tWASD to move (or arrows)\n    double-tap space/pgup = FLY MODE TOGGLE\n \twhen flying, use space and shift (pgup/dn) to go up and down.\n\totherwise space to jump (pgup)\n\tmouse click on inventory to select a block type\n\tQ + mouse button to place block\n\tE + mouse button to destroy blocks\n\tF + mouse button to generate a signal on wire\n\tT to pause time\n    double-tap forward = SPRINT\n*/\n\nconst int\n  KEY_JUMP = 32 // space - ascend or jump\n, KEY_SNEAK = 16 // shift - descend\n, KEY_FORWARDS = 87 // w\n, KEY_BACKWARD = 83 // s\n, KEY_LEFT  = 65 // a\n, KEY_RIGHT = 68 // d\n, KEY_PLACE = 81 // q - create block by current inventory selection\n, KEY_DESTROY = 69 // e - mine block\n, KEY_INTERACT = 70 // f - pulses picked wire\n, KEY_PAUSE = 84 // t - freeze time\n, KEY_ARROWFW = 38\n, KEY_ARROWBW = 40\n, KEY_ARROWLF = 37\n, KEY_ARROWRT = 39\n, KEY_PGUP = 33\n, KEY_PGDN = 34\n;\n\nvec4 load(vec2 coord)\n{\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy), 0.0);\n}\n\nbool inBox(vec2 coord, vec4 bounds)\n{\n\treturn coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\n// GLOBALS - HACK!!!\nvec2 currentCoord;\nvec4 outValue;\n\nbool store4(vec2 coord, vec4 value)\n{\n\tif (inBox(currentCoord, vec4(coord, 1., 1.))) {\n\t\toutValue = value;\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool store3(vec2 coord, vec3 value)\n{\n\treturn store4(coord, vec4(value, 1));\n}\nbool store2(vec2 coord, vec2 value)\n{\n\treturn store4(coord, vec4(value, 0, 1));\n}\nbool store1(vec2 coord, float value)\n{\n\treturn store4(coord, vec4(value, 0, 0, 1));\n}\n\nfloat keyDown(int keyCode)\n{\n\treturn textureLod(iChannel2, vec2((float(keyCode) + .5) / 256., .5 / 3.), .0).r;\n}\n\nfloat keyPress(int keyCode)\n{\n\treturn textureLod(iChannel2, vec2((float(keyCode) + .5) / 256., 1.5 / 3.), .0).r;\n}\n/*\nfloat keySinglePress(int keycode)\n{\n\tbool now = bool(keyDown(keycode));\n\tbool previous = bool(textureLod(iChannel0, vec2(256. + float(keycode) + .5, .5) / iResolution.xy, .0).r);\n\treturn float(now && !previous);\n}\n*/\nfloat keyToggled(int keyCode)\n{\n\treturn textureLod(iChannel2, vec2((float(keyCode) + .5) / 256., 2.5 / 3.), .0).r;\n}\n\nbool rectangleCollide(vec2 p1, vec2 p2, vec2 s)\n{\n\treturn all(lessThan(abs(p1 - p2), s));\n}\n\nbool horizontalPlayerCollide(vec2 p1, vec2 p2, float h)\n{\n\tvec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n\tp2.y += h / 2.;\n\treturn rectangleCollide(p1, p2, s);\n}\n// for collision purposes - TODO refactor vs. rendering\nvoxel getCachedVoxel(vec3 p)\n{\n\treturn getCachedVoxel(p, iChannel1, iChannelResolution[1]);\n}\n\nbool isSolidVoxel(vec3 p)\n{\n\treturn isSolidVoxel(p, iChannel1, iChannelResolution[1]);\n}\n\nstruct rayCastResults\n{\n\tbool hit;\n\tvec3 rayPos;\n\tvec3 mapPos;\n\tvec3 normal;\n\tfloat dist;\n};\n\nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset)\n{\n\tvec3 mapPos = floor(rayPos)\n\t, deltaDist = abs(vec3(length(rayDir)) / rayDir)\n\t, rayStep = sign(rayDir)\n\t, sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * .5) + .5) * deltaDist\n\t, mask;\n\tbool hit = false;\n\tfor (int i = 0; i <= MAX_PICK_DISTANCE * 3; ++i) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\tif (mapPos.z < 0. || mapPos.z >= heightLimit) break;\n\t\tvoxel vox = getCachedVoxel(mapPos - offset);\n        if (vox.id != bVoid) { //isOpaque(vox.id)) { //\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n\n\trayCastResults res;\n\tres.hit = hit;\n\tres.mapPos = mapPos;\n\tres.rayPos = endRayPos;\n\tres.normal = -rayStep * mask;\n\tres.dist = length(rayPos - endRayPos);\n\treturn res;\n}\n// FIXME duplicates some of the UI code in Image tab; refactor to Common\nfloat mouseSelect(vec2 c)\n{\n\tfloat scale = floor(iResolution.y / 128.);\n\tc /= scale;\n\tvec2 r = iResolution.xy / scale;\n\tfloat xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n\tc.x -= xStart;\n\tif (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.) {\n\t\tfloat slot = floor(c.x / 16.);\n\t\treturn slot;\n\t}\n\treturn -1.;\n}\n\n// TODO could really use refactoring\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tcurrentCoord = fragCoord;\n\tvec2 texCoord = floor(fragCoord);\n\tif (texCoord.x < float(nStatePixels)) {\n\t\tif (texCoord.y == varRow) {\n\t\t\tvec3 pos = load(_pos).xyz\n\t\t\t, oldPos = pos\n\t\t\t, offset = vec3(floor(pos.xy), 0.)\n\t\t\t, vel = load(_vel).xyz;\n\t\t\tvec4 oldMouse = load(_mouse)\n\t\t\t, mouse = iMouse / length(iResolution.xy)\n\t\t\t, priorLoadRange = load(_loadRange);\n\t\t\tvec2 angle = load(_angle).xy\n\t\t\t, time = load(_time).rg\n\t\t\t, flightMode = load(_flightMode).rg\n\t\t\t, sprintMode = load(_sprintMode).rg;\n\t\t\tfloat selected = load(_selectedInventory).r\n\t\t\t, dt = min(iTimeDelta, .05)\n\t\t\t, pixelSize = 2.; //load(_pixelSize).r;\n\t\t\tif (iFrame == 0) { // initialize state\n\t\t\t\tpos = vec3(50.5, 50.5, 5.);\n\t\t\t\tangle = vec2(-2., 1.6);\n\t\t\t\toldMouse = vec4(-1);\n\t\t\t\tvel = vec3(0);\n\t\t\t\ttime = vec2(400., 0.);\n\t\t\t\tselected = 0.;\n\t\t\t\tflightMode = vec2(1.); // defaulting to flight mode\n\t\t\t}\n\t\t\tif (oldMouse.z > 0. && iMouse.z > 0.) {\n\t\t\t\tfloat zoom = .5; //pow(10., load(_renderScale).r / 10.);\n\t\t\t\tangle += 5. * (mouse.xy - oldMouse.xy) * vec2(-1, -1) / zoom;\n\t\t\t\tangle.y = clamp(angle.y, 0.1, PI - 0.1);\n\t\t\t}\n\t\t\t// FIXME duplicates a whole lot of camera code from Common rayDirection\n\t\t\tvec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y))\n\t\t\t, dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0)\n\t\t\t, dirV = cross(dirU, dir)\n\t\t\t, move = vec3(0)\n\t\t\t, dirFwd = vec3(cos(angle.x), sin(angle.x), 0)\n\t\t\t, dirRight = vec3(dirFwd.y, -dirFwd.x, 0)\n\t\t\t, dirUp = vec3(0, 0, 1);\n\t\t\tif (isSolidVoxel(pos - offset)) pos.z += 1.;\n\n\t\t\tfloat inBlock = 0.;\n\t\t\tfloat minHeight = 0.;\n\t\t\tvec3 vColPos, hColPos;\n\t\t\t// FIXME FIXME I do believe it's calling isSolidVoxel very redundantly\n\t\t\t// FIXME this drove me nuts converting it all to boolean btw\n\t\t\t// I can't deal with this much wasted logic, it really needs help\n\t\t\t// but no time right now, working on important stuff lol like getting the automata working\n\t\t\tfor (float i = 0.; i < 4.; ++i) {\n\t\t\t\tvColPos = vec3(floor(pos.xy - .5), floor(pos.z - 1. - i));\n\t\t\t\tif (   (isSolidVoxel(vColPos - offset + vec3(0, 0, 0)) && rectangleCollide(vColPos.xy + vec2(0.5, 0.5), pos.xy, vec2(.8)))\n\t\t\t\t\t|| (isSolidVoxel(vColPos - offset + vec3(0, 1, 0)) && rectangleCollide(vColPos.xy + vec2(0.5, 1.5), pos.xy, vec2(.8)))\n\t\t\t\t\t|| (isSolidVoxel(vColPos - offset + vec3(1, 0, 0)) && rectangleCollide(vColPos.xy + vec2(1.5, 0.5), pos.xy, vec2(.8)))\n\t\t\t\t\t|| (isSolidVoxel(vColPos - offset + vec3(1, 1, 0)) && rectangleCollide(vColPos.xy + vec2(1.5, 1.5), pos.xy, vec2(.8)))\n\t\t\t\t) {\n\t\t\t\t\tminHeight = vColPos.z + 1.001;\n\t\t\t\t\tinBlock = 1.;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat maxHeight = heightLimit - 1.8;\n\t\t\tvColPos = vec3(floor(pos.xy - .5), floor(pos.z + 1.8 + 1.));\n\t\t\tif (   (isSolidVoxel(vColPos - offset + vec3(0, 0, 0)) && rectangleCollide(vColPos.xy + vec2(0.5, 0.5), pos.xy, vec2(.8)))\n\t\t\t\t|| (isSolidVoxel(vColPos - offset + vec3(0, 1, 0)) && rectangleCollide(vColPos.xy + vec2(0.5, 1.5), pos.xy, vec2(.8)))\n\t\t\t\t|| (isSolidVoxel(vColPos - offset + vec3(1, 0, 0)) && rectangleCollide(vColPos.xy + vec2(1.5, 0.5), pos.xy, vec2(.8)))\n\t\t\t\t|| (isSolidVoxel(vColPos - offset + vec3(1, 1, 0)) && rectangleCollide(vColPos.xy + vec2(1.5, 1.5), pos.xy, vec2(.8)))\n\t\t\t\t) {\n\t\t\t\tmaxHeight = vColPos.z - 1.8 - .001;\n\t\t\t\tinBlock = 1.;\n\t\t\t}\n\t\t\tfloat minX = pos.x - 1000.;\n\t\t\thColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1, 0), floor(pos.z));\n\t\t\tif (   (isSolidVoxel(hColPos - offset + vec3(0, 0, 0)) && horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 1, 0)) && horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 1)) && horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 1, 1)) && horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 2)) && horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 1, 2)) && horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8))\n\t\t\t\t) {\n\t\t\t\tminX = hColPos.x + 1.301;\n\t\t\t}\n\t\t\tfloat maxX = pos.x + 1000.;\n\t\t\thColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1, 0), floor(pos.z));\n\t\t\tif (   (isSolidVoxel(hColPos - offset + vec3(0, 0, 0)) && horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 1, 0)) && horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 1)) && horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 1, 1)) && horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 2)) && horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 1, 2)) && horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8))\n\t\t\t\t) {\n\t\t\t\tmaxX = hColPos.x - .301;\n\t\t\t}\n\t\t\tfloat minY = pos.y - 1000.;\n\t\t\thColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0, -1), floor(pos.z));\n\t\t\tif (   (isSolidVoxel(hColPos - offset + vec3(0, 0, 0)) && horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(1, 0, 0)) && horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 1)) && horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(1, 0, 1)) && horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 2)) && horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(1, 0, 2)) && horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8))\n\t\t\t\t) {\n\t\t\t\tminY = hColPos.y + 1.301;\n\t\t\t}\n\t\t\tfloat maxY = pos.y + 1000.;\n\t\t\thColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0, 1), floor(pos.z));\n\t\t\tif (   (isSolidVoxel(hColPos - offset + vec3(0, 0, 0)) && horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(1, 0, 0)) && horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 1)) && horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(1, 0, 1)) && horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(0, 0, 2)) && horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8))\n\t\t\t\t|| (isSolidVoxel(hColPos - offset + vec3(1, 0, 2)) && horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8))\n\t\t\t\t) {\n\t\t\t\tmaxY = hColPos.y - .301;\n\t\t\t}\n\t\t\tif (abs(pos.z - minHeight) < .01) flightMode.r = 0.;\n\t\t\tif (bool(keyPress(KEY_JUMP))) {\n\t\t\t\tif (flightMode.g > 0.) {\n\t\t\t\t\tflightMode.r = 1. - flightMode.r;\n\t\t\t\t\tsprintMode.r = 0.;\n\t\t\t\t}\n\t\t\t\tflightMode.g = .3;\n\t\t\t}\n\t\t\tflightMode.g = max(flightMode.g - dt, 0.);\n\n\t\t\tif (bool(keyPress(KEY_FORWARDS))) {\n\t\t\t\tif (sprintMode.g > 0.) sprintMode.r = 1.;\n\t\t\t\tsprintMode.g = .3;\n\t\t\t} \n\t\t\tif (!bool(keyDown(KEY_FORWARDS))) {\n\t\t\t\tif (sprintMode.g <= 0.) sprintMode.r = 0.;\n\t\t\t}\n\t\t\tsprintMode.g = max(sprintMode.g - dt, 0.);\n\n\t\t\tfloat loadDistLimit = 80.;\n\t\t\tfloat rayLimit = 400.;\n\n\t\t\tif (bool(flightMode.r)) {\n\t\t\t\tif (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n\t\t\t\tvel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS) - keyDown(KEY_BACKWARD) + keyDown(KEY_ARROWFW) - keyDown(KEY_ARROWBW));\n\t\t\t\tvel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT) - keyDown(KEY_LEFT) + keyDown(KEY_ARROWRT) - keyDown(KEY_ARROWLF));\n\t\t\t\tvel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK) + keyDown(KEY_PGUP) - keyDown(KEY_PGDN));\n\t\t\t\tif (length(vel) > 20.) vel = normalize(vel) * 20.;\n\t\t\t} else {\n\t\t\t\tvel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n\t\t\t\tvel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS) - keyDown(KEY_BACKWARD) + keyDown(KEY_ARROWFW) - keyDown(KEY_ARROWBW));\n\t\t\t\tvel += 50. * dt * dirFwd * .4 * sprintMode.r;\n\t\t\t\tvel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT) - keyDown(KEY_LEFT) + keyDown(KEY_ARROWRT) - keyDown(KEY_ARROWLF));\n\t\t\t\tif (abs(pos.z - minHeight) < 0.01) {\n\t\t\t\t\tvel.z = 9. * max(keyDown(KEY_PGUP), keyDown(KEY_JUMP));\n\t\t\t\t} else {\n\t\t\t\t\tbool isWater = false; //(getCachedVoxel(pos - offset).id == bWater);\n\t\t\t\t\tvel.z -= (isWater ? 1. : 32.) * dt;\n\t\t\t\t\tvel.z = clamp(vel.z, isWater ? -20. : -80., isWater ? 20. : 30.);\n\t\t\t\t}\n\t\t\t\tif (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n\t\t\t}\n\n\t\t\tpos += dt * vel;\n\t\t\tif (pos.z < minHeight) {\n\t\t\t\tpos.z = minHeight;\n\t\t\t\tvel.z = 0.;\n\t\t\t}\n\t\t\tif (pos.z > maxHeight) {\n\t\t\t\tpos.z = maxHeight;\n\t\t\t\tvel.z = 0.;\n\t\t\t}\n\t\t\tif (pos.x < minX) {\n\t\t\t\tpos.x = minX;\n\t\t\t\tvel.x = 0.;\n\t\t\t}\n\t\t\tif (pos.x > maxX) {\n\t\t\t\tpos.x = maxX;\n\t\t\t\tvel.x = 0.;\n\t\t\t}\n\t\t\tif (pos.y < minY) {\n\t\t\t\tpos.y = minY;\n\t\t\t\tvel.y = 0.;\n\t\t\t}\n\t\t\tif (pos.y > maxY) {\n\t\t\t\tpos.y = maxY;\n\t\t\t\tvel.y = 0.;\n\t\t\t}\n\n\t\t\tfloat timer = load(/*_old +*/ _pickTimer).r;\n\t\t\tvec4 oldPick = load(/*_old +*/ _pick);\n\t\t\tvec4 pick;\n\t\t\tfloat pickAction;\n\t\t\tif (iMouse.z > 0.) {\n\t\t\t\tfloat slot = mouseSelect(iMouse.xy);\n\t\t\t\tif (slot >= 0.) {\n\t\t\t\t\tselected = slot;\n\t\t\t\t} else {\n\t\t\t\t\tfloat zoom = .5; //pow(10., load(_renderScale).r / 10.);// /pixelSize;\n\t\t\t\t\tvec2 renderResolution = iResolution.xy * zoom;\n\t\t\t\t\tvec2 renderCenter = vec2(.5);\n\t\t\t\t\tvec2 uv = (iMouse.xy - renderCenter) / renderResolution - (renderCenter / zoom);//  /pixelSize;\n\t\t\t\t\tvec3 pointerPos = load(_pos).xyz + vec3(0, 0, 1.6);\n\t\t\t\t\tvec3 pointerDir = rayDirection(load(_angle).xy, uv, renderResolution);\n\n\t\t\t\t\trayCastResults res = rayCast(pointerPos, pointerDir, offset);\n\t\t\t\t\tif (res.dist <= float(MAX_PICK_DISTANCE) && res.dist >= .1) {\n\t\t\t\t\t\tpick.xyz = res.mapPos;\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n\t\t\t\t\t\t\tpick.a = 1.;\n\t\t\t\t\t\t\tstore1(vec2(0, 9), pick.a);\n\t\t\t\t\t\t\ttimer += dt;\n\t\t\t\t\t\t} else if (bool(keyPress(KEY_PLACE))) {\n\t\t\t\t\t\t\tpick.a = 2.;\n\t\t\t\t\t\t\tpick.xyz += res.normal;\n\t\t\t\t\t\t} else if (bool(keyPress(KEY_INTERACT))) {\n\t\t\t\t\t\t\tpick.a = 3.;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (oldPick != pick) timer = 0.;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimer = 0.;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (bool(keyDown(KEY_DESTROY))) {\n\t\t\t\t// NO MOUSE KEY PRESSED  \n\t\t\t\tpick.a = 1.;\n\t\t\t\tstore1(vec2(0, 9), pick.a);\n\t\t\t\t//timer += dt;\n\t\t\t} else if (bool(keyPress(KEY_PLACE)))\n\t\t\t\tpick.a = 2.;\n\t\t\telse\n\t\t\t\ttimer = 0.;\n\n\t\t\ttime.g = 1.-keyToggled(KEY_PAUSE);\n\t\t\ttime.r = mod(time.r + dt * time.g, 1200.);\n\n\t\t\tbool still = length(pos - oldPos) < .01 && length(angle - load(_angle).xy) < 0.01 && iMouse.z < 1.;\n\n\t\t\tstore3(_pos, pos);\n\t\t\tstore3(_oldPos, oldPos);\n\t\t\tstore2(_angle, angle);\n\t\t\tstore4(_loadRange, calcLoadRange(pos.xy, iResolution.xy, 0., loadDistLimit));\n\t\t\tstore4(_oldLoadRange, priorLoadRange);\n\t\t\tstore4(_mouse, mouse);\n\t\t\tstore3(_vel, vel);\n\t\t\tstore4(_pick, pick);\n\t\t\tstore1(_pickTimer, timer);\n\t\t\tstore1(_selectedInventory, selected);\n\t\t\tstore2(_flightMode, flightMode);\n\t\t\tstore2(_sprintMode, sprintMode);\n\t\t\tstore2(_time, time);\n\t\t\tstore1(_loadDistLimit, loadDistLimit);\n\n\t\t\tfragColor = outValue;\n\t\t}\n\t}\n\telse fragColor.rgb = vec3(0, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// VOXEL MEMORY\n\nvec4 load(vec2 coord)\n{\n\treturn texture(iChannel0, vec2((floor(coord) + .5) / iChannelResolution[1].xy));\n}\n\nvoxel getCachedVoxel(vec3 p)\n{\n\treturn getCachedVoxel(p, iChannel1, iChannelResolution[1]);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 textelCoord = floor(fragCoord);\n\tvec3 offset = floor(vec3(load(_pos).xy, 0.));\n\tvec3 voxelCoord = texToVoxCoord(textelCoord, offset);\n\tvec4 range = load(/*_old +*/ _oldLoadRange);\n\n\tvec4 memoryRange = calcLoadRange(offset.xy, iChannelResolution[0].xy, 0., load(_loadDistLimit).r);\n\tif (!inRange(voxelCoord.xy, memoryRange)) {\n\t\tfragColor = vec4(1.);\n\t\treturn;\n\t}\n\tvec3 oldOffset = floor(vec3(load(/*_old +*/ _oldPos).xy, 0.));\n\tvec4 pick = load(_pick);\n\t // 0 = initialize, 1 = edit/evolve\n\tint mode = iFrame == 0 ? 0 : 1;\n\tvoxel vox = getVoxelData(voxelCoord, iChannel1, iChannelResolution[1], mode, range, oldOffset);\n\tif (voxelCoord == pick.xyz) {\n        if (pick.a == 3. && vox.id == bWire) {\n            vox.id = bHead; // pulse on interact w mouse\n        }\n\t\telse if (pick.a == 1.\n            && pick.z > 0. /* && vox.id != 16. */ // don't mine bedrock layer\n            && load(_pickTimer).r > PICK_MINE_DELAY) {\n\t\t\tvox.id = bVoid;\n\t\t} else if (pick.a == 2.) // place block\n\t\t\tvox.id = getInventory(int(load(_selectedInventory).r));\n\t}\n    if (mode == 0) { // initialization\n        vox = getGeneratedVoxel(voxelCoord);\n    } else if ((iFrame & 31) == 0 && load(_time).g > .5) {\n\t\t// evolve the cellular automata only occasionally, or it's too fast to observe\n\t\t// from wwtransition of bergi's https://shadertoy.com/view/XstSzj\n\t\t// but completely redone  :)\n\t\t// TODO switch\n\t\tif (vox.id == bHead) {\n\t\t\tvox.id = bTail;\n\t\t} else if (vox.id == bTail) {\n\t\t\tvox.id = bWire;\n\t\t} else if (vox.id == bWire) {\n\t\t\tint num = 0;\n\t\t\t// 3D moor neighbourhood\n\t\t\tfor (int k=-1; k <= 1 && num < 2; ++k)\n\t\t\tfor (int j=-1; j <= 1 && num < 2; ++j)\n\t\t\tfor (int i=-1; i <= 1 && num < 2; ++i)\n                if (i != 0 || j != 0 || k != 0) // exclude center, won't matter\n\t\t\t\tif (getCachedVoxel(voxelCoord + vec3(i,j,k) - oldOffset).id == bHead)\n\t\t\t\t\t++num;\n\t\t\tif (num == 1 || num == 2)\n\t\t\t\tvox.id = bHead;\n\t\t}    \n\t}\t\n\tfragColor = encodeVoxel(vox);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// RAYTRACING, main rendering\n\nvec4 load(vec2 coord) \n{\n\treturn textureLod(iChannel0, vec2((floor(coord) + .5) / iChannelResolution[0].xy), 0.);\n}\n\nvoxel getCachedVoxel(vec3 p)\n{\n\tvec3 offset = floor(vec3(load(_pos).xy, 0.));\n\treturn getCachedVoxel(p - offset, iChannel1, iChannelResolution[1]);\n}\n\nvoxel getVoxel(vec3 p)\n{\n\t//return getVoxel(p,iChannel1,iChannelResolution[1]);\n\tvec3 offset = floor(vec3(load(_pos).xy, 0.));\n\tvec4 range = load(_loadRange);\n\tvec3 oldOffset = floor(vec3(load(/*_old*/ + _pos).xy, 0.));\n\n\tint mode = (iFrame == 0) ? 0 : 1;\n\treturn getVoxelData(p, iChannel1, iChannelResolution[1], mode, range, offset);\n}\n\nstruct rayCastResults \n{\n\tbool hit;\n\tvec3 rayPos;\n\tvec3 mapPos;\n\tvec3 normal; // no lighting lol\n\tvec2 uv; // currently no textures\n\tfloat dist;\n\tvoxel vox;\n};\n\nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, int maxRayDist, vec4 range) \n{\n\tbool hit = false;\n\tvoxel vox;\n\tvox.id = bVoid;\n\tfloat waterDist = 0.;\n\tfloat fog = 0.;\n\trayCastResults subRes;\n\tsubRes.hit = false;\n\n\tvec3 raySign = sign(rayDir);\n\tvec3 rayInv = 1. / rayDir;\n\tvec3 mapPos = floor(rayPos + raySign * .001);\n\tvec3 sideDist = (mapPos - rayPos + .5 + sign(rayDir) * .5) * rayInv;\n\tvec3 mask = vec3(0.);\n\tfloat t = 0.;\n\tint raylim = maxRayDist + min(0, iFrame); //256; //int(load(_rayLimit).r)\n\tfor (int i = 0; i < raylim; ++i) {\n\t\tif (i > 0) {\n\t\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\t\tvec3 mini = (mapPos - rayPos + 0.5 - 0.5 * vec3(raySign)) * rayInv;\n\t\t\tt = max(mini.x, max(mini.y, mini.z));\n\t\t}\n\t\tsideDist += mask * raySign * rayInv;\n\t\tmapPos += mask * raySign;\n\n\t\tif (mapPos.z < 0.) break;\n\t\tif (mapPos.z >= heightLimit) {\n\t\t\tif (rayDir.z > 0.)  break;\n\t\t\t//MAP RAY FROM ABOVE\n\t\t\tfloat nstep = -((mapPos.z - heightLimit) * rayInv.z);\n\t\t\tmapPos += rayDir * nstep;\n\t\t\tsideDist = (mapPos - rayPos + 0.5 + raySign * 0.5) * rayInv;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvox = getVoxel(mapPos);\n\n        if (isOpaque(vox.id)) { //vox.id != bVoid) {\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t//NO HIT\n\t\tif (!inRange(mapPos.xy, range) && i > maxRayDist) break;\n\n\t}\n\n\tvec3 mini = (mapPos - rayPos + .5 - .5 * raySign) * rayInv;\n\tt = max(mini.x, max(mini.y, mini.z));\n\n\trayCastResults res;\n\tres.hit = hit;\n\n\tres.mapPos = mapPos;\n\tres.normal = -raySign * mask;\n\tres.rayPos = rayDir * t + rayPos;\n\tres.dist = length(rayPos - res.rayPos);\n\tres.vox = vox;\n\n\tvec2 uv;\n\tif (abs(mask.x) > 0.) \n\t\tuv = fract(res.rayPos.yz);\n\telse if (abs(mask.y) > 0.) \n\t\tuv = fract(res.rayPos.xz);\n\telse\n\t\tuv = fract(res.rayPos.yx);\n\n\tres.uv = uv;\n\n\tres.rayPos -= rayDir * t / 100.; //trick to avoid wrong shadow if hitpoint inside cube\n\treturn res;\n}\n\nvec4 sun()\n{\n    return vec4(normalize(vec3(.1,.3,.8)),1); // HACK freeze at high noon or something\n/*\tfloat t = load(_time).r;\n\tfloat sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n\tconst float risingAngle = PI / 6.;\n\treturn vec4(cos(sunAngle) * sin(risingAngle), cos(sunAngle) * cos(risingAngle), sin(sunAngle), lightLevelCurve(t)); */\n}\n\nvec3 skyColor(vec3 rayDir) \n{\n\tvec4 s = sun();\n\tfloat lightLevel = s.w;\n\n\tvec3 sunDir = s.xyz;\n\tvec3 daySkyColor = vec3(.5, .75, 1);\n\tvec3 dayHorizonColor = vec3(.8, .8, .9);\n\tvec3 nightSkyColor = vec3(.1, .1, .2) / 2.;\n\n\tvec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n\tvec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n\tfloat sunVis = smoothstep(.99, .995, dot(sunDir, rayDir));\n\tfloat moonVis = smoothstep(.999, .9995, dot(-sunDir, rayDir));\n\treturn mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0, 0, 1)), 0., 1.)), vec3(1, 1, 0.95), sunVis), vec3(0.8), moonVis);\n}\n\nvoid applyFog(inout vec3 rgb,  // original color of the pixel\n\tfloat distance) // camera to point distance\n{\n\tfloat fogAmount = 1. - exp(-distance * .015);\n\tvec3  fogColor = vec3(.5, .6, .7) * clamp(sun().w, .3, 1.);\n\trgb = mix(rgb, fogColor, fogAmount);\n}\n\nvec4 render(vec3 rayPos, vec3 rayDir, int maxRayDist) \n{\n\tvec4 range = load(/*_old +*/ _loadRange);\n\trayCastResults res = rayCast(rayPos, rayDir, maxRayDist, range);\n\tvec3 color = vec3(0.);\n\tif (res.hit) {\n\t\tint textureId = res.vox.id;\n\t\tbool odd = ((int(res.mapPos.x)^int(res.mapPos.y))&1) != 0;\n\t\tcolor = getTexture(textureId, res.uv, res.dist).rgb;\n        if (ivec3(load(_pick)) == ivec3(res.mapPos))\n\t\t\tcolor += .02 * sin(iTime*21.);\n    \tif (odd) color *= .9; // checkerboard dimming\n\t\tfloat shadow = 0.;\n\t\tcolor *= max(0., mix(dot(res.normal, sun().xyz), 1., .5));\n\t  #ifdef SHADOW\n\t\tvec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n\t\tint shadowlength = inRange(res.rayPos.xy, range) ? 25 : 5;\n\t\tshadow = rayCast(res.rayPos, sunDir, shadowlength, range).hit ? 1. : 0.;\n\t\tcolor *= 1.-.2*shadow;\n\t  #endif\n\t}\n\telse color = skyColor(rayDir);\n\treturn vec4(color, 1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) \n{\n\tfloat pixelSize = pixSize(iResolution.xy); //2.; //load(_pixelSize).r;\n\tvec2 renderResolution = ceil(iResolution.xy / pixelSize);\n\tif (any(greaterThan(fragCoord, renderResolution))) {\n\t\tfragColor = vec4(0);\n\t\treturn;\n\t}\n\t// MAIN CAMERA\n\tfloat zoom = .5; //pow(10., load(_renderScale).r / 10.) / pixelSize;\n\trenderResolution = iResolution.xy * zoom;\n\tvec2 renderCenter = vec2(.5);\n\tvec2 uv = (fragCoord.xy - renderCenter) / renderResolution - (renderCenter / zoom / pixelSize);\n\tvec3 cameraPos = load(_pos).xyz + vec3(0, 0, 1.6);\n\tvec3 cameraDir = rayDirection(load(_angle).xy, uv, renderResolution);\n\tfragColor = render(cameraPos, cameraDir, 128); //512);\n} //pow(color, vec3(1./2.2)) // may as well gamma correct here","name":"Buffer D","description":"","type":"buffer"}]}