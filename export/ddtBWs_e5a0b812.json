{"ver":"0.1","info":{"id":"ddtBWs","date":"1708409109","viewed":46,"name":"ooo scary eye","username":"eissa","description":"very simple raymarching implementation with distortions (sin of the x and y of the sphere with a high multiplier).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float _maxDistance;\nvec4 _sphere1, _box1, _sphere2;\nvec3 _lightDir;\nvec4 _mainColor, _secColor;\n\n\nstruct Camera\n            {\n                vec2 uv;\n                vec3 ro;\n                vec3 rd;\n            };\n            \nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n#define BUMP_FACTOR .03\n#define TEX_SCALE_FACTOR .4\n#define PI 3.14159265\n//sdfs\n\n\n// Sphere\n// s: radius\nfloat sdSphere(vec3 p, float s)\n{\n    \n\treturn length(p) - s;\n}\n\n// Box\n// b: size of box in x/y/z\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\n\t\tlength(max(d, 0.0));\n}\n\n// BOOLEAN OPERATORS //\n\n// Union\nfloat opU(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n// Subtraction\nfloat opS(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n// Intersection\nfloat opI(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n// Mod Position Axis\nfloat pMod1 (inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p+halfsize)/size);\n\tp = mod(p+halfsize,size)-halfsize;\n\tp = mod(-p+halfsize,size)-halfsize;\n\treturn c;\n}\n\nfloat distanceField(vec3 p) \n{\n\n    float modx = pMod1(p.z, 20.0);\n\n\n\n    vec3 bp = p - _box1.xyz;\n    vec3 sp = p - _sphere1.xyz;\n    vec3 b2p = p - _sphere2.xyz;\n    \n    //adding distortions\n    \n    //sp.x += sin(bp.y*3.0)*.07;\n\n    float Sphere1 = sdSphere(sp, _sphere1.w+sin(sp.y*200.0+iTime*3.0)*.07-sin(sp.x*200.0+iTime*3.0)*.07);\n    float Box1 = sdBox(bp, _box1.www);\n    float d = opS(Sphere1, Box1);\n\n    \n    return d;\n    \n    \n    \n}\n\n\n\nvec3 getNormal(vec3 p)\n{\n    const vec2 offset = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        distanceField(p + offset.xyy) - distanceField(p - offset.xyy),\n        distanceField(p + offset.yxy) - distanceField(p - offset.yxy),\n        distanceField(p + offset.yyx) - distanceField(p - offset.yyx));\n    return normalize(n);\n}\n\nfloat getLight(vec3 p) \n{\n    // Directional light\n    vec3 lightPos = vec3(5.0,5.0,5.0); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = getNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n    \n    float d = distanceField(p);\n    if(d<length(lightPos-p)) dif *= .004;\n    \n    return dif;\n}\n\n// returns color\nvec4 raymarching(vec3 ro, vec3 rd) \n{\n    vec4 result = vec4(1, 1, 1, 1);\n    const int max_iteration = 164;\n    float t = 0.0; // distance traveled along ray direction\n\n    // move forward along the ray until you hit something\n    for (int i = 0; i < max_iteration; i++) \n    {\n        if (t > _maxDistance)\n        {\n            result = vec4(0, 0, 0, 1.0);\n            break;\n        }\n\n        vec3 p = ro + rd * t;\n        // check for hit in distance field\n        float d = distanceField(p);\n        // hit if statement\n        if (d < 0.01) \n        {\n            // shading\n            \n            float light = getLight(p);\n            d*= .2;\n            result = vec4(_mainColor.rgb * light, 1);\n            break;\n        }\n\n        t += d;\n    }\n\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n     vec2 mo = iMouse.xy/iResolution.xy;\n     \n    _maxDistance = 400.0;\n    _sphere1 = vec4(0.0, 0.0, 0.0, 12.0 + smoothstep( 0.0,1.0, sin(iTime*3.0+.5*PI)));\n    _box1 = vec4(0.0, 0.0, 0.0, 20.0);\n    _sphere2 = vec4(0.0, 1.0, 0.0, 0.5);\n    _lightDir = vec3(1.0, 1.0, 1.0);\n    _mainColor = vec4(255.0, 255.0, 255.0, 1);\n    _secColor = vec4(0.0,255,0.0,1.0);\n    \n    vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y*0.7;\n    \n    Camera camera;\n    camera.ro = vec3(0.0, 0.0 , 0.0); \n    camera.rd = normalize(vec3(uv.x, uv.y, 1));\n    camera.rd = vec3((camera.rd.x*cos(7.0*mo.x) + camera.rd.z*sin(7.0*mo.x)), camera.rd.y, (-camera.rd.x*sin(7.0 *mo.x) + camera.rd.z*cos(7.0*mo.x))); \n    \n    vec4 result = raymarching(camera.ro, camera.rd);\n    float opacity = 1.0;\n    if (length(uv) > 0.28) {\n        result = vec4(0.0,0.0,0.0,1.0);\n    }\n    fragColor = vec4((1.0 - result.w) + result.xyz * result.w, opacity);\n}\n\n\n","name":"Image","description":"","type":"image"}]}