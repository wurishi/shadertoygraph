{"ver":"0.1","info":{"id":"MsdGRS","date":"1450575281","viewed":1753,"name":"first mapping test","username":"RenoM","description":"when i posted this texture https://www.shadertoy.com/view/4sdGzn, Shane suggested i map it onto a cylinder, learning 3d stuff now so here... :)\nalso implementd shadows into raymarching","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingmappingshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define NB_OBJ 8\n#define T iTime\n#define PI 3.14159265\n#define EPS .01\n#define MAX 50.\n\nvec3 lp;\n\nvec2 rot(vec2 p, float t)\n{\n    vec2 s = vec2(cos(t), sin(t));\n    return p * mat2(s, -s.y, s.x);\n}\n\nfloat map(vec3 p, int id)\n{\n    if(id == 0) return length(p.xz) - 1.;\n    if(id == 1) return abs(p.y + 1.2);\n    if(id == 2) return abs(p.y - 2.2);\n    if(id == 3) return length(p-lp) - .1;\n    if(id == 4) return abs(p.z - 5.);\n    if(id == 5) return abs(p.z + 5.);\n    if(id == 6) return abs(p.x - 5.);\n    if(id == 7) return abs(p.x + 5.);\n    return MAX;\n}\n\nfloat march(vec3 ro, vec3 rd, out float d, int id)\n{\n    float t = .0;\n    for(int i = 0; i < 64; i++)\n    {\n        d = map(ro+t*rd, id);\n        if(d < EPS || t > MAX) break;\n        t += d;\n    }\n    return t;\n}\n\nint inter(vec3 ro, vec3 rd, out float t)\n{\n    int id = -1;\n    float d,l;\n    t = MAX;\n    for(int i = 0; i < NB_OBJ; i++)\n    {\n        l = march(ro, rd, d, i);\n        if(d < EPS && l < t)\n        {\n            t = l;\n            id = i;\n        }\n    }\n    return id;\n}\n\nvec3 normal(vec3 p, int id)\n{\n    vec2 q = vec2(0,EPS);\n    return normalize(vec3(map(p+q.yxx, id) - map(p-q.yxx, id),\n                          map(p+q.xyx, id) - map(p-q.xyx, id),\n                          map(p+q.xxy, id) - map(p-q.xxy, id)));\n}\n\nfloat hash12(vec2 p)\n{\n    return  fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat isInSuperellipse(vec2 uv, vec2 o, float r, float n)\n{\n    float res = pow(abs((uv.x - o.x) / r), n) + pow(abs((uv.y - o.y) / r), n);\n    return (res <= 1. ? sqrt(1. - res) : .0);\n}\n\nvec3 segrid(vec2 p)\n{\n    vec2 frac = fract(p);\n    p = floor(p);\n    float time = ceil(T);\n    float res = isInSuperellipse(frac, vec2(.5), .5, 4. * hash12(p));\n    vec3 hash = hash32(p);\n\tvec3 col = .7 * hash * res;\n    float h = floor(200. - hash12(p) * 200.);\n    if(floor(mod(T * 2.,50.)) == h) col *= 3.;\n    return col;\n}\n\nvec3 col(vec3 p, int id)\n{\n    if(id == 0) return segrid(60. * vec2(atan(p.z,p.x), p.y) / PI);\n    if(id == 1 || id == 2) return segrid(p.xz*15.);\n    if(id == 4 || id == 5) return segrid(p.xy*15.);\n    if(id == 6 || id == 7) return segrid(p.yz*15.);\n    return vec3(0);\n}\n\nvec3 shade(vec3 p, int id)\n{\n    if(id == 3) return vec3(1);\n    vec3 rd = normalize(p-lp);\n    float f;\n    f = inter(lp+rd, rd, f) != id ? .2 : 1.;\n    vec3 n = normal(p,id);\n    f *= max(.1,dot(n,-rd));\n    return f * col(p,id);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    lp = vec3(3.*cos(.8*T),.5,3.*sin(.8*T));\n\n    \n    vec2 R = iResolution.xy,\n         p = tan(.5236) * (U+U-R) / R.y;\n    vec3 ro = vec3(0,0,-4.9),\n         rd = normalize(vec3(p,1));\n    \n    ro.xz = rot(ro.xz, .8*T);\n    rd.xz = rot(rd.xz, .8*T);\n    \n    float t;\n    int id = inter(ro, rd, t);\n    \n    vec3 c = id == -1 ? vec3(0) : shade(ro+t*rd, id);\n    c *= 9. / (1.+t);\n    \n    O.xyz = clamp(c, .0, 1.);\n}","name":"Image","description":"","type":"image"}]}