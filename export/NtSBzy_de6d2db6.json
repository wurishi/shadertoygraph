{"ver":"0.1","info":{"id":"NtSBzy","date":"1652357659","viewed":171,"name":"Tecoma Pulsar","username":"thepinkpanzer","description":"A pulsar, since 'pulsar' was used I've named it after the neutron star in The Expanse","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["pulsar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noisySine(float angle)\n{\n    float total = 0.0;\n    for (int i = 3; i < 10; i++)\n    {\n        float randomValue = fract(tan(100.0*float(i) + 10.2));\n        total += pow(1.14,-float(i))*sin(angle*float(i) + 6.28*randomValue + iTime*0.6);\n        total += pow(1.14,-float(i))*sin(angle*float(i) - 6.28*randomValue - iTime*0.6);\n    }\n    total = pow(total, 2.0);\n    return total;\n}\n\nvec3 dither(vec2 p)\n{\n    p += vec2(10.0*iTime, 25.0*iTime);\n    p += vec2(14.23245, 6.876543);\n    p *= vec2(2.43563,  2.786543);\n    vec2 s  = vec2(p.y, p.x);\n    vec2 r  = p * p;\n    r += s;\n    r  = fract(100.43*sin(r));\n    r += sin(s*3.245);\n    r += cos(p*1.24532);\n    r  = fract(r);\n    vec3 q = vec3(1.0) + 0.1*(2.0*vec3(r.r, (r.g + r.r)/2.0, r.g) - vec3(1));\n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float m = 10.0;\n    \n    vec3 position      = vec3(0,0,-5);\n    vec3 viewDirection = vec3(0,0,1) + vec3(fragCoord.x - iResolution.x/2.0, fragCoord.y - iResolution.y/2.0, 0)/iResolution.x * m;\n    viewDirection      = normalize(viewDirection);\n    \n    vec3 directionRealSpace = normalize(vec3(sin(3.0*iTime), 1.0, cos(3.0*iTime)));\n    \n    vec3 cameraRightRealSpace = vec3(1,0,0);\n    vec3 cameraUpRealSpace    = -normalize(vec3(0,1,1));\n    vec3 cameraFwdRealSpace   = normalize(vec3(0,1,-1));\n    \n    vec3 direction = vec3(dot(cameraRightRealSpace, directionRealSpace), dot(cameraUpRealSpace, directionRealSpace), dot(cameraFwdRealSpace, directionRealSpace));\n    \n    // Star\n    vec3 col = vec3(0,0,0);\n    col += vec3(1.0,1.0,1)  * exp((-1.0-dot(viewDirection, normalize(position)))*1000.0) * 10.0;\n    col += vec3(0.6,0.75,1) * exp((-1.0-dot(viewDirection, normalize(position)))*110.0) * (1.0 + 0.9*pow(dot(direction, -normalize(position)),6.0));\n    col += vec3(0.3,0.5,1)  * exp((-1.0-dot(viewDirection, normalize(position)))*16.0 ) * (1.0 + 1.3*pow(dot(direction, -normalize(position)),6.0)) * 0.8 * (1.0 + 0.03*noisySine(atan(viewDirection.y,viewDirection.x)));\n    col += vec3(0.1,0.3,1)  * exp((-1.0-dot(viewDirection, normalize(position)))*1.0  ) * (1.0 + 1.5*pow(dot(direction, -normalize(position)),6.0)) * 0.1;\n    \n    // Jets\n    vec3 jetColor = vec3(0.4, 0.6, 1.0) * 0.1;\n    \n    float[] radii = float[](0.880,0.900,0.910,0.915,0.920,0.925,0.930,0.935,0.940,0.945,0.960,0.970);\n    \n    float vd = dot(viewDirection, direction);\n    float vr = dot(viewDirection, position);\n    float vv = dot(viewDirection, viewDirection);\n    float rd = dot(position, direction);\n    float rr = dot(position, position);\n    \n    for (int i = 0; i < radii.length(); i++)\n    {\n        float a = radii[i];\n        float intensity = 1.0;\n        \n        float inSqrt = (2.0*(vd*rd - vr*a*a))*(2.0*(vd*rd - vr*a*a))-4.0*(vd*vd-a*a*vv)*(rd*rd-a*a*rr);\n        if (inSqrt > 0.0)\n        {\n            float distA = (-(2.0*(vd*rd - vr*a*a))-sqrt(inSqrt))/(2.0*(vd*vd-a*a*vv));\n            float distB = (-(2.0*(vd*rd - vr*a*a))+sqrt(inSqrt))/(2.0*(vd*vd-a*a*vv));\n            bool amInsideJet = rd*rd/rr > a*a;\n            bool lookingAlongJet = vd*vd > a*a;\n            bool jetIsBackwards = distA < 0.0;\n\n            if (!amInsideJet && !lookingAlongJet && !jetIsBackwards)\n            {\n                float pos1 = pow(dot(distA*viewDirection + position, direction),2.0);\n                float pos2 = pow(dot(distB*viewDirection + position, direction),2.0);\n                \n                intensity = -dot(normalize((distA + distB)*viewDirection/2.0 + position), viewDirection)+1.3;\n\n                col += abs((1.0/pos1 - 1.0/pos2)/vd)*jetColor*intensity;\n            }\n            if (amInsideJet && !lookingAlongJet)\n            {\n                distB = 0.0;\n\n                float pos1 = pow(dot(distA*viewDirection + position, direction),2.0);\n                float pos2 = pow(dot(distB*viewDirection + position, direction),2.0);\n                \n                intensity = -dot(normalize((distA + distB)*viewDirection/2.0 + position), viewDirection)+1.3;\n\n                col += abs((1.0/pos1 - 1.0/pos2)/vd)*jetColor*intensity;\n            }\n            if (!amInsideJet && lookingAlongJet)\n            {\n                float pos1 = pow(dot(distB*viewDirection + position, direction),2.0);\n                \n                intensity = -dot(normalize((1000.0 + distB)*viewDirection/2.0 + position), viewDirection)+1.3;\n\n                col += abs((1.0/pos1)/vd)*jetColor*intensity;\n            }\n            if (amInsideJet && lookingAlongJet)\n            {            \n                float pos1 = pow(dot(distA*viewDirection + position, direction),2.0);\n                float pos2 = pow(dot(  0.0*viewDirection + position, direction),2.0);\n                \n                intensity = -dot(normalize((distA + 0.0)*viewDirection/2.0 + position), viewDirection)+1.3;\n\n\n                col += abs((1.0/pos1 - 1.0/pos2)/vd)*jetColor*intensity;\n\n                if (vr < 0.0)\n                {\n                    float pos1 = pow(dot(distB*viewDirection + position, direction),2.0);\n                    intensity = -dot(normalize((1000.0 + distB)*viewDirection/2.0 + position), viewDirection)+1.3;\n\n\n                    col += abs((1.0/pos1)/vd)*jetColor*intensity;\n                }\n            }\n        }\n    }\n    \n    col*= dither(fragCoord);\n    \n    col = tanh(2.5*col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}