{"ver":"0.1","info":{"id":"wlKSRD","date":"1582326671","viewed":445,"name":"Sinusoid particles 1","username":"saidwho12","description":"Just some particles","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["2d","light","sinus","particle","hackerman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, in vec2 u)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = u/R;\n    O.rgb = texture(iChannel0, uv).rgb;// * float(int(u.y)%2);\n    O.rgb = pow(O.rgb, vec3(1.0/1.8));\n    //O.rgb *= .2 + .8 * pow( clamp(16.0 * uv.x * uv.y * (1.0-uv.x) * (1.0-uv.y),0.,1.), 0.8 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n// Almost a direct copy of most of \"Simplest Fastest 2D Hash\" with additional hash types.\n// https://www.shadertoy.com/view/MdcfDj\n\n// For use in WebGL 2 shaders.\n// The float versions should still be in integer steps, but they can be negetive.\n\n\n// The defines don't need to change for scaling purposes,\n// but I'll keep them in for any future needs.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float RadicalInverse_VdC(in uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\n// ----------------------------------------------------------------------------\nvec2 HammersleySeq(in uint i, in uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\n#define N 64u\n#define M 16u\n#define MIN_LENGTH 0.1\n#define MAX_LENGTH 0.8\n#define MIN_SINUSOID_FREQ 1.0\n#define MAX_SINUSOID_FREQ 5.0\n#define GLOBAL_SPEED 0.8\n#define PI 3.14159\n\nvoid blendOver(out vec4 Co, in vec3 Ca, in vec3 Cb, in float alpha_a, in float alpha_b)\n{\n\tCo.a = alpha_a + alpha_b * (1.0 - alpha_a);\n    Co.rgb = /*Ca + Cb * (1.0 - alpha_a);*/(Ca * alpha_a + Cb * alpha_b * (1.0 - alpha_a)) / Co.a;\n}\n\n// Smooth HSV to RGB conversion by IQ\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat brightness( in vec3 c )\n{\n    return (c.x + c.y + c.z) / 3.;\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy, p = (u+u - R) / R.y;\n    //O -= O;\n    O = texture(iChannel0, u/R) * 0.93;\n    float tm = iTime * GLOBAL_SPEED;\n     \n    /*\n    for (uint i = 0u; i < M; ++i)\n    {\n    \t//vec2  //HammersleySeq(i, M);\n        vec2 pp= hash21(i) *2.-1.;\n        \n        uint rchr = uint(hash11(i) * 255.0);\n        uint rchrx = rchr & 16u;\n        uint rchry = rchr / 16u;\n        vec2 rchruv = vec2(rchrx, rchry) / vec2(16);\n        \n        \n        if (all(greaterThanEqual(off, vec2(0))) && all(lessThanEqual(off, vec2(1)) ))\n        {\n            float alpha = texture(iChannel1, rchruv - off).r;\n\n            vec3 col = vec3(.4,.9,.2);//V1;//vec3(0.86,0.75,1);\n            O.rgb = mix(O.rgb, col, alpha);\n        }\n            /*\n        float U1 = hash11(i*8u+0u);\n        float U2 = hash11(i*8u+1u);\n        float U3 = hash11(i*8u+2u);\n        float U4 = hash11(i*8u+3u);\n        float U5 = hash11(i*8u+4u);\n        float U6 = hash11(i*8u+5u);\n        float U7 = hash11(i*8u+6u);\n        float U8 = hash11(i*8u+7u);\n        vec3 V1 = hash31(i*8u+7u);\n        vec2 pp = (Xi*2.-1.) * 0.05; // Position\n        vec2 bsd = normalize( pp ); // Base Direction\n        vec2 dr = bsd; // Direction;\n        \n        float spd = pow(.05 + .95 * U1, 0.3) * 2.2; // Speed\n        float rdl = MIN_LENGTH + (MAX_LENGTH - MIN_LENGTH) * U2;// Random Length\n        \n        float st = U3; // Start Time\n        \n        float mnr = .0004 + .001 * U4; // Min Radius\n        float mxr = .0015 + .05 * U5; // Max Radius\n        \n        float rt = fract((tm - st) * spd * rdl); // Relative Time over ray\n        \n        //float amw = pow(clamp(sin(rt * PI), 0.0, 1.0), 0.9); // Alpha Modifier Wave\n        \n        float r = mix(mnr, mxr, 1.0-rt);\n        \n        //float freq = MIN_SINUSOID_FREQ + (MAX_SINUSOID_FREQ - MIN_SINUSOID_FREQ) * U6;\n        \n        \n        // Modifiers for sinusoid\n        float ampl = 0.025;\n        float freq = mix(MAX_SINUSOID_FREQ, MIN_SINUSOID_FREQ, 1.0-rt);\n            \n        pp += dr * pow(rt, 1.5) + vec2(-bsd.y, bsd.x) * ampl*sin(rt * PI * freq);\n        \n        float t = distance(p, pp)-r;\n        //float alpha = smoothstep(3./R.y, 0., t);\n        float alpha = 1.5 * pow(min(1.0 / max(t*R.y,0.0)*.3 ,1.0), 1.2) * pow(1.0-rt, 0.8);//smoothstep(3./R.y, 0., t);\n        //float alpha = pow(min(6.0 / max(t*R.y,0.0),1.0),1.4);\n        \n        vec3 c1 = hsv2rgb_smooth(vec3(0.15 + 0.02*U7, 0.2, 1.0));\n        vec3 c2 = hsv2rgb_smooth(vec3(0.25 + 0.05 * U8, 1.0, 1.0));\n        \n        vec3 col = mix(c1, c2, pow(rt,1.5));//V1;//vec3(0.86,0.75,1);\n        O.rgb = mix(O.rgb, col, alpha);\n        //blendOver(O, O.rgb, col, O.a, alpha);\n    }*/\n    \n            // Hackerman matrix\n    \n    vec2 uv = fract(u/R.x * 3.);\n    vec2 cell = uv * 16.;\n    vec2 off = floor(hash23(vec3(cell, tm * 12.)) * 16.);\n    //float matrix_alpha = (1.0 - exp(-0.2 * max(length(p)-0.6, 0.0) ) );\n    //float matrix_alpha = (1.0 - min(1.0 / clamp(length(p)-0.6, 0.0, 1.0), 1.0) );\n    //float matrix_alpha = (1.0 - min(1.0 / clamp(length(p)-0.6, 0.0, 1.0), 1.0) );\n    //O.rgb = mix(O.rgb, vec3(0.4,1,0.2), matrix_alpha * texture(iChannel1, uv - off / 16.).r);\n    \n    float chra = (texture(iChannel1, uv - off / 16.).a * 2. - 1.);\n    //float chr = smoothstep(2., 0., (chra*R.y)/2./16. );\n    float chr = min(exp( -2.6 * max((chra*R.y)/(3.*16.),0.0)), 1.0);\n    \n    float brt = clamp(brightness(O.rgb),0.0,1.0);\n\n    if (hash13(vec3(cell, tm * 12.)) < 0.4)\n    {\n    O.rgb = mix(O.rgb, hsv2rgb_smooth(vec3(0.25, 0.6, 1.0)),\n                pow(brt,2.6) * chr );\n    }\n    \n    \n        // Hackerman sinus waves\n    for (uint i = 0u; i < N; ++i)\n    {\n    \tvec2 Xi = HammersleySeq(i, N);\n        \n        float U1 = hash11(i*8u+0u);\n        float U2 = hash11(i*8u+1u);\n        float U3 = hash11(i*8u+2u);\n        float U4 = hash11(i*8u+3u);\n        float U5 = hash11(i*8u+4u);\n        float U6 = hash11(i*8u+5u);\n        float U7 = hash11(i*8u+6u);\n        float U8 = hash11(i*8u+7u);\n        vec3 V1 = hash31(i*8u+7u);\n        \n        vec2 pp = (Xi*2.-1.) * 0.36; // Position\n        vec2 bsd = normalize( pp ); // Base Direction\n        vec2 dr = bsd; // Direction;\n        \n        float spd = pow(.05 + .95 * U1, 0.3) * 2.2; // Speed\n        float rdl = MIN_LENGTH + (MAX_LENGTH - MIN_LENGTH) * U2;// Random Length\n        \n        float st = U3; // Start Time\n        \n        float mnr = .0004 + .0185 * U4; // Min Radius\n        float mxr = .0015 + .0025 * U5; // Max Radius\n        \n        float rt = fract((tm - st) * spd * rdl); // Relative Time over ray\n        \n        //float amw = pow(clamp(sin(rt * PI), 0.0, 1.0), 0.9); // Alpha Modifier Wave\n        \n        float r = mix(mnr, mxr, pow(1.0-rt,0.8));\n        \n        //float freq = MIN_SINUSOID_FREQ + (MAX_SINUSOID_FREQ - MIN_SINUSOID_FREQ) * U6;\n        \n        \n        // Modifiers for sinusoid\n        float ampl = 0.008 + (1.0-rt) * 0.025;\n        float freq = mix(MAX_SINUSOID_FREQ, MIN_SINUSOID_FREQ, 1.0-rt);\n            \n        pp += dr * pow(rt, 1.5) + vec2(-bsd.y, bsd.x) * ampl*sin(rt * PI * freq);\n        \n        float t = distance(p, pp)-r;\n        //float alpha = smoothstep(3./R.y, 0., t);\n        float alpha = 1.5 * pow(min(1.0 / max(t*250.0,0.0)*.3 ,1.0), 1.3) * pow(1.0-rt, 4.8);//smoothstep(3./R.y, 0., t);\n        //float alpha = pow(min(6.0 / max(t*R.y,0.0),1.0),1.4);\n        \n        vec3 c1 = hsv2rgb_smooth(vec3(0.15 + 0.02*U7, 0.2, 1.0));\n        vec3 c2 = hsv2rgb_smooth(vec3(0.25 + 0.05*U8, 1.0, 1.0));\n        \n        vec3 col = mix(c1, c2, pow(rt,6.5));//V1;//vec3(0.86,0.75,1);\n        \n        O.rgb = mix(O.rgb, col, alpha);\n        //blendOver(O, O.rgb, col, O.a, alpha);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}