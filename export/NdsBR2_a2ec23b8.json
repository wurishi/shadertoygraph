{"ver":"0.1","info":{"id":"NdsBR2","date":"1645103177","viewed":64,"name":"Squares.","username":"Gretsok","description":"Trying things","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Projet #2 : les fragments\n// Production R&D\n// Romain Lopez-Rostain\n\n\n// ======= Méthodes usuelles =======\n// vec3.x / vec3.xz / vec3.zxy (on peu prendre le nombre d'attribut qu'on veut et dans l'ordre qu'on veut)\n// 5. <- un flottant\n// length(vec_) \n// dot(vec_)\n// normalize(vec_)\n// pow(n, exp)\n\n\n// Dans un shader standard, on définit les paramètres en entrée (in) \n// et ceux en sortie pour les fonctions GL seulement (out).\nbool inside_circle(in vec2 frag, in vec2 center, in float radius)\n{\n    return length(frag - center) < radius;\n}\n\nbool inside_square(in vec2 frag, in vec2 botLeft, in vec2 topRight)\n{\n    return (frag.x > botLeft.x && frag.x < topRight.x) && (frag.y > botLeft.y && frag.y < topRight.y);\n}\n\n// Boite noire\n// On peut utiliser cette fonction de bruit continu pour l'effet de secousse\nfloat noise2D(in float val, in float amplitude, in int granularite)\n{\n    float res = 0.;\n    for (int i = 0; i < granularite; i++)\n    {\n        res += sin(val * 158. + 79.) * amplitude;\n        amplitude = amplitude / 2.;\n    }\n    \n    return res;\n}\n\nvec3 reverse_color(vec3 color)\n{\n    return vec3(1. - color.x, 1. - color.y, 1. - color.z);\n}\n\n\nbool reverse_to_draw_damier(float maxSize, vec2 uv)\n{\n    float maxIteration = (1. / maxSize) * 8.;\n    bool reverse1Diag = false;\n    for(float i = 0.; i < maxIteration; i = i + 2.)\n    {\n        \n        if(uv.y < uv.x + sin((i * maxSize) - (maxSize * maxIteration / 2.) + sin(uv.x*10. * iTime)*0.02) * 1.2\n        && uv.y > uv.x + sin(((i - 1.) * maxSize) - (maxSize * maxIteration / 2.) + sin(uv.x*10. * iTime)*0.02) * 1.2)\n        {\n            reverse1Diag = true;\n            break;\n        }\n    }\n    \n    bool reverse2Diag = false;\n    for(float i = 0.; i < maxIteration; i = i + 2.)\n    {\n        if(uv.y < -uv.x + (i * maxSize)  + sin(uv.x*10. * iTime)*0.02\n        && uv.y > -uv.x + ((i - 1.) * maxSize)  + sin(uv.x*10. * iTime)*0.02)\n        {\n            reverse2Diag = true;\n            break;\n        }\n    }\n    \n    \n    return (reverse1Diag && !reverse2Diag) || (!reverse1Diag && reverse2Diag);\n}\n\nfloat remap(float val, vec2 oldRange, vec2 newRange)\n{\n    return newRange.x + (val - oldRange.x) * (newRange.y - newRange.x) / (oldRange.y - oldRange.x);\n}\n\n// La fonction principale\n// fragColor : la couleur (vec4) que doit prendre le fragment\n// fragCoord : les coordonnées (xy) du fragment dont on doit déterminer la couleur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position normalisée du pixel [0, 1]\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Fond noir\n    vec3 col = cos(0.5*iTime  + vec3(1. - cos(iTime * 50.), sin(iTime * 5.) - 0.5, cos((1. - iTime) * 25.) - 0.5) + cos(1. - uv.yxy / 2.)); \n    \n    \n    \n    if(reverse_to_draw_damier(remap(abs(cos(iTime * 1.5)), vec2(0., 1.), vec2(0.3, 0.8)) * 0.5, uv))\n    {\n        col = reverse_color(col);\n    }\n    \n    \n    vec3 col1 = cos(0.5*iTime  + vec3(2, 0, 4) + uv.xyx);\n    vec3 col2= cos(1.5*iTime  + vec3(0, 2, 3) + uv.yxy);\n    vec3 col3= cos(5.*iTime  + vec3(1, 2, 8) + uv.xyx);\n    \n    //float someValue = abs(sin(iTime)) * 0.5;\n    float maxStartWidth = 0.5f;\n    float maxStartHeight = 1.1f;\n    \n    float startX = abs(sin(iTime * 2.)) * 0.5;//abs(noise2D(iTime * 0.005, 0.15, 5));;\n    float startY = abs(sin(iTime * 3.)) * 0.5;//abs(noise2D(iTime * 0.008, 0.5, 5));;\n    float startZ = startX + abs(noise2D(iTime * 0.011, (1. - startX) * (maxStartWidth / 2.), 5));\n    float startW = startY + abs(noise2D(iTime * 0.017, (1. - startY) * (maxStartHeight / 2.), 5));\n   \n    vec4 square1 = vec4(startX, startY, startZ, startW);\n    vec4 square2 = vec4(square1.z, square1.y, square1.z + (square1.z - square1.x) * 0.5, square1.y + (square1.w - square1.y) / 2.);\n    vec4 square3 = vec4(square2.z, square2.y, square2.z + (square2.z - square1.z) * 0.5, square2.y + (square2.w - square2.y) / 2.);\n    vec4 square4 = vec4(square3.z, square3.y, square3.z + (square3.z - square2.z) * 0.5, square3.y + (square3.w - square3.y) / 2.);\n    vec4 square5 = vec4(square4.z, square4.y, square4.z + (square4.z - square3.z) * 1., square4.y + (square4.w - square4.y) / 2.);\n    vec4 square6 = vec4(square3.x, square3.w, square5.z, square2.w);\n    vec4 square7 = vec4(square5.x, square5.w, square5.z, square4.w);\n    \n    \n    \n    if(inside_square(uv, square1.xy, square1.zw))\n    {\n        col = col1;\n    }\n    else if(inside_square(uv, square2.xy, square2.zw))\n    {\n        col = col2;\n    }\n    else if(inside_square(uv, square3.xy, square3.zw))\n    {\n        col = col1;\n    }\n    else if(inside_square(uv, square4.xy, square4.zw))\n    {\n        col = col2;\n    }\n    else if(inside_square(uv, square5.xy, square5.zw))\n    {\n        col = col1;\n    }\n    \n    else if(inside_square(uv, square6.xy, square6.zw))\n    {\n        col = col3;\n    }\n    if(inside_square(uv, square7.xy, square7.zw))\n    {\n        col = col3;\n    }\n    \n    \n    if(inside_circle(fragCoord, iMouse.xy, length(iResolution.x) * 0.05))\n    {\n        col = reverse_color(col);\n    }\n    \n            \n        //col = cos(0.5*iTime  + vec3(0, 2, 4) + uv.yxy);\n    \n    col.x = remap(col.x, vec2(0., 1.), vec2(0.1, 0.9));\n    col.y = remap(col.y, vec2(0., 1.), vec2(0.1, 0.9));\n    col.z = remap(col.z, vec2(0., 1.), vec2(0.1, 0.9));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}