{"ver":"0.1","info":{"id":"4cKSWz","date":"1715555852","viewed":92,"name":"Bad voxel renderer","username":"Teluri","description":"voxel raycast renderer based on intersection with octahedral layers\n\nits terrible but i was curious about drawing cubes based on the distance of a point to the 3 closest cubes center.\n\nno clue how to do smooth movement lol","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat rounduloBy1(float ted){\n    float qty=round(ted);\n    return ted-qty;\n}\n\nvec3 rounduloBy1(vec3 ted){\n    return vec3(rounduloBy1(ted.x),rounduloBy1(ted.y),rounduloBy1(ted.z));\n}\n\nmat3 getXRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( 1, 0, 0,\n                 0, c, s,\n                 0,-s, c);\n}\n\nmat3 getYRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( c, 0,-s,\n                 0, 1, 0,\n                 s, 0, c);\n}\n\nmat3 getZRotMat(float angle){\n    float c=cos(angle);\n    float s=sin(angle);\n    return mat3( c, s, 0,\n                -s, c, 0,\n                 0, 0, 1);\n}\n\nstruct VoxelData{bool exist;};\n\nVoxelData getVoxel(ivec3 pos){\n    //mock data\n    bool e=abs(pos.x-7)<3 && abs(pos.y+4)<2;\n    bool ee=(abs(pos.x)>5 || abs(pos.y)>5)&& pos.z<-1;\n    bool eee=pos.x+pos.y+pos.z==10;\n    return VoxelData(pos.z<-3||e||ee||eee);\n}\n\n// z is upward\n// x is the view horizontal rotation axis\n// y is the vertical cam rotation axis and view rotation axis\n// z is the horizontal cam rotation axis\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //consts\n    float render_distance= 64.0; //max amount of iteration\n    float angoffset= 1.0; //camera angle from -0.5 to 0.5 uv\n    \n    //normalizing screen size to -0.5 to 0.5 being the biggest centered square that fit on screen\n    float screenratio=min(iResolution.x,iResolution.y);\n    vec2 uv = fragCoord-vec2(iResolution*0.5);\n    uv = uv/screenratio;\n    \n    //input\n    vec3 camrot=vec3(0.0,clamp(-iMouse.y/screenratio,-1.0,1.0),2.0*-iMouse.x/iResolution.x)*PI;\n    vec3 campos= vec3(sin(iTime)*1.0-1.0,cos(iTime)*0.0-1.0,0.0);\n    \n    //output\n    vec3 col=vec3(0,0,0);\n    \n    //disconstructing campos\n    vec3 cposfract=rounduloBy1(campos);\n    ivec3 icampos= ivec3(round(campos));\n    \n    //getting ray from cam angle\n    vec3 rayrot=camrot+vec3(uv.x*angoffset,uv.y*angoffset,0);\n    vec3 ray= vec3(0,0,1);\n    ray= getXRotMat(rayrot.x)*ray;\n    ray= getYRotMat(rayrot.y)*ray;\n    ray= getZRotMat(rayrot.z)*ray;\n    \n    \n    //part of doing smooth movement ig\n    //ray=ray-cposfract*0.5;\n    \n    //save ray sign aside\n    vec3 raysign= sign(ray);\n    \n    //resize ray to end on octahedron layer\n    ray= abs(ray);\n    float raytotal= ray.x+ray.y+ray.z;\n    vec3 stepvec=(ray/raytotal);\n    \n    //setting up the last cube pos for tracking face orientation\n    vec3 laspos= vec3(0.0,0.0,0.0);\n    \n    //iterating until fragment is opaque\n    for(float layer = 1.0; layer < render_distance; layer++){\n        vec3 layray= stepvec*layer;\n    \n        //getting the distances from closests cubes\n        vec3 b=fract(layray);\n        \n        //check if dealing with a downward or upward pointed triangle zone\n        // which is crucial because the math isnt the same\n        // could be done with 4 centers rather than 3 to avoid it but its less fun\n        //(and more processing)\n        bool istp=(b.x+b.y<1.0);\n    \n        //getting the 3 closest centers\n        vec3 base=floor(layray);\n        vec3 ct1= base+ vec3(1,0,(istp)?0:1);\n        vec3 ct2= base+ vec3(0,1,(istp)?0:1);\n        vec3 ct3= base+ ((istp)?vec3(0,0,1):vec3(1,1,0));\n        \n        //get the ratio between the grid thing and the x+y+z=layer vector\n        vec3 dimratios=(base+0.5)/layray;\n        \n        //get the float to mutiply the vector with to have it end on the wanted grid thing\n        // depending on istp it either require to find the smallest or the biggest ratio\n        // as the correct grid thing is either in front or behind the x+y+z=layer plane\n        float dimratio=(istp)?min(dimratios.x,min(dimratios.y,dimratios.z)):\n         max(dimratios.x,max(dimratios.y,dimratios.z));\n        \n        vec3 stairray= layray*dimratio; \n        \n        //check who's the closest from sray\n        float d1= distance(stairray,ct1);\n        float d2= distance(stairray,ct2);\n        float d3= distance(stairray,ct3);\n        \n        vec3 lbpos=(d2<d1)?ct2:ct1;\n        lbpos=(d3<d1 && d3<d2)?ct3:lbpos;\n        \n        //translating to position in world and getting voxel data\n        ivec3 blockpos=ivec3(lbpos*raysign)-icampos;\n        VoxelData data=getVoxel(blockpos);\n        \n        //rendering voxel if existing\n        if(data.exist){\n            //applying cube test color\n            col=1.0-abs(vec3(blockpos))*0.05;\n            //applying test face direction color\n            vec3 facevec= abs(lbpos-laspos);\n            //technically with wrong shapes you can have non normal vector from this method,\n            //hence the need for normalizing\n            facevec= normalize(facevec); \n            col= col-facevec*0.05;\n            \n            //a bunch of test stuff\n            //col= col+vec3(d1,d2,d3)*0.03;\n            //col=col+dimratio*0.1;\n            //col=col-laspos*0.05;\n            //col=moduloBy1(col);\n            break;\n        }\n        laspos=lbpos;\n    }\n    \n    // output to screen\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}