{"ver":"0.1","info":{"id":"wdyBzc","date":"1607621976","viewed":75,"name":"Trying Raymarching things","username":"Carbonarah","description":"Raymarching tests","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS   = 100;\n\nconst float MIN_DIS  = 0.f;\nconst float MAX_DIS  = 100.f;\n\nconst float EPSILON  = 0.0001f;\n\nconst vec3 SUN = vec3(100.f, -100, 100);\n\nstruct structSurfaceInfos\n{\n    vec4  albedo;\n    vec4  color;\n    vec3  normal;\n    vec3  point;\n};\n\n\nfloat SDFIntersect(float disA, float disB)\n{\n    return max(disA, disB);\n}\n\nfloat SDFUnion(float disA, float disB)\n{\n    return min(disA, disB);\n}\n\nfloat SDFDifference(float disA, float disB)\n{\n    return max(disA, -disB);\n}\n\nfloat SDFCube(vec3 point, float sideSize)\n{\n    vec3 dis = abs(point) - vec3(sideSize);\n    \n    float insideDis = min(max(dis.x, max(dis.y, dis.z)), 0.0);\n    \n    float outsideDis = length(max(dis, 0.0));\n    \n    return insideDis + outsideDis;\n}\n\nfloat SDFsphere(vec3 point, float r)\n{\n    return length(point) - r;\n}\n\nbool  offsetDir = true;\nfloat xOffset   = 0.f;\n\nfloat SDFscene(vec3 wsPoint, inout vec4 albedo)\n{\n    float currentDis = MAX_DIS;\n    float finalDis   = MAX_DIS;\n    \n    albedo = BLACK;\n    \n    // Cubes\n    if ((currentDis = min(SDFCube(wsPoint + vec3(-1.0, 0.0, 0.0), 0.8f), finalDis)) < finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    if ((currentDis = min(SDFCube(wsPoint + vec3(1.0,  0.0, 0.0), 0.8f), finalDis)) < finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    \n    // Sphere Difference\n    \n    // Midd\n    if ((currentDis = min(SDFsphere(wsPoint + vec3(xOffset,  0.0, 0.0), 0.5f), finalDis)) < finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    \n    // Sides\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(2.0,  0.0, 0.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = YELLOW;\n    }\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(-2.0,  0.0, 0.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = YELLOW;\n    }\n    \n    // Up\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(1.0,  0.0, -1.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(-1.0,  0.0, -1.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    \n    // Fw\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(1.0, 1.0, 0.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(-1.0, 1.0, 0.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = GREEN;\n    }\n    \n    // Back\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(1.0, -1.0, 0.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = YELLOW;\n    }\n    if ((currentDis = SDFDifference(finalDis, SDFsphere(wsPoint + vec3(-1.0, -1.0, 0.0), 0.5f))) != finalDis)\n    {\n        finalDis = currentDis;\n        albedo = YELLOW;\n    }\n    \n    return finalDis;\n}\n\nvec3 getSurfaceNormal(vec3 point)\n{\n    vec4 tmpAlbedo = BLACK;\n    return normalize(vec3(\n        \n        SDFscene(vec3(point.x + EPSILON, point.y, point.z), tmpAlbedo) -\n        SDFscene(vec3(point.x - EPSILON, point.y, point.z), tmpAlbedo),\n        \n        SDFscene(vec3(point.x, point.y + EPSILON, point.z), tmpAlbedo) -\n        SDFscene(vec3(point.x, point.y - EPSILON, point.z), tmpAlbedo),\n        \n        SDFscene(vec3(point.x, point.y, point.z + EPSILON), tmpAlbedo) -\n        SDFscene(vec3(point.x, point.y, point.z - EPSILON), tmpAlbedo)\n    ));\n}\n\nstructSurfaceInfos getSurfaceInfos(vec3 eye, vec3 dir)\n{\n    structSurfaceInfos surfaceInfos;\n    surfaceInfos.albedo  = BLACK;\n    surfaceInfos.normal = vec3(0, 0, 0);\n    surfaceInfos.point  = vec3(0, 0, 0);\n    \n    float depth = MIN_DIS;\n    vec4 albedo = BLACK;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        vec3 point       = vec3(eye + dir * depth);\n        float deltaDepth = SDFscene(point, albedo);\n        \n        if (deltaDepth < EPSILON)\n        {\n            surfaceInfos.point  = point;\n            surfaceInfos.albedo  = albedo;\n            surfaceInfos.normal = getSurfaceNormal(point);\n            return surfaceInfos;\n        }\n        \n        if (deltaDepth >= MAX_DIS)\n        {\n            return surfaceInfos;\n        }\n        depth += deltaDepth;\n    }\n    return surfaceInfos;\n}\n\n// z up\nvec3 rayDirection(float fov, vec2 resolution, vec2 fragCoord)\n{\n    vec2 xz = fragCoord - resolution / 2.f;\n    float y = resolution.y / tan(radians(fov) / 2.f);\n    return normalize(vec3(xz.x, y, -xz.y));\n}\n\nvoid ComputeLight(inout structSurfaceInfos surfaceInfos, const vec3 eye)\n{\n    if (surfaceInfos.albedo == BLACK)\n        return;\n        \n    vec3 surfaceToEye             = eye - surfaceInfos.point;\n    vec3 surfaceToSun             = SUN - surfaceInfos.point;\n    vec3 halfAngleVecBetSunAndEye = normalize(surfaceToEye + surfaceToSun);\n    \n    surfaceToEye = normalize(surfaceToEye);\n    surfaceToSun = normalize(surfaceToSun);\n    \n    float dotLambert  = max(dot(surfaceInfos.normal, surfaceToSun), 0.f);\n    //const float dotPhong    = max(dot(surfaceToEye, surfaceToSun), 0.f);\n    float dotBlinn    = max(dot(surfaceInfos.normal, halfAngleVecBetSunAndEye), 0.f);\n  \n    const float shininess = 60.f;\n    const float ambient   = 0.15f;\n    \n    surfaceInfos.color = surfaceInfos.albedo * dotLambert + pow(dotBlinn, shininess) + ambient * surfaceInfos.albedo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 eye = vec3(0.f, -10.f, 3.0f);\n    \n    vec3 dir = rayDirection(45.f, iResolution.xy, fragCoord);\n    \n    mat4 viewMat = lookAt(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    \n    dir = (vec4(dir, 0.f) * viewMat).xyz;\n\n    RotateVecAroundAxis(eye, eUP, iTime);\n    RotateVecAroundAxis(dir, eUP, iTime);\n    \n    // Move Shapes\n    \n    \n    if (xOffset >= 2.f)\n    {\n        offsetDir = false;\n    }\n    if (xOffset <= 2.f)\n    {\n        offsetDir = true;\n    }\n    \n    xOffset += offsetDir ? iTime : -iTime;\n    \n    structSurfaceInfos surfaceInfos = getSurfaceInfos(eye, dir);\n    ComputeLight(surfaceInfos, eye);\n    \n    fragColor = surfaceInfos.color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst int eUP      = 0x00000001;\nconst int eRIGHT   = 0x00000002;\nconst int eFORWARD = 0x00000003;\n\nconst vec4 BLACK  = vec4(0.f,   0.f,   0.f,   1.f);\nconst vec4 BLUE   = vec4(0.2f,  0.7f,  1.f,   1.f);\nconst vec4 RED    = vec4(0.95f, 0.4f,  0.26f, 1.f);\nconst vec4 GREEN  = vec4(0.4f,  0.83f, 0.41f, 1.f);\nconst vec4 YELLOW = vec4(0.83f, 0.78f, 0.12f, 1.f);\nconst vec4 WHITE  = vec4(1.f,   1.f,   1.f,   1.f);\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 upCam)\n{\n    // Based on gluLookAt man page\n    vec3 forward = normalize(center - eye);\n    vec3 right   = normalize(cross(forward, upCam));\n    vec3 up      = normalize(cross(right, forward));\n    return mat4(\n        vec4(right, 0.0),\n        vec4(forward, 0.0),\n        vec4(-up, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid RotateVecAroundAxis(inout vec3 vec, int Axis /* UP || RIGHT || FORWARD */, float theta)\n{\n\n    switch (Axis)\n    {\n        case eUP:\n        {\n            mat3 z = mat3(\n            vec3(cos(theta), -sin(theta), 0.f),\n            vec3(sin(theta), cos(theta), 0.f),\n            vec3(0.f, 0.f, 1.f));\n            \n            vec *= z;\n    \n            break;\n        }\n        \n        case eRIGHT:\n        {\n            mat3 x = mat3(\n            vec3(1.f, 0.f, 0.f),\n            vec3(0.f, cos(theta), -sin(theta)),\n            vec3(0.f, sin(theta), cos(theta)));\n            \n            vec *= x;\n    \n            break;\n        }\n        \n        case eFORWARD:\n        {\n            mat3 y = mat3(\n            vec3(cos(theta), 0.f, sin(theta)),\n            vec3(0.f, 1.f, 0.f),\n            vec3(-sin(theta), 0.f, cos(theta)));\n    \n            vec *= y;\n    \n            break;\n        }\n        \n        default:\n            break;\n    }\n}\n","name":"Common","description":"","type":"common"}]}