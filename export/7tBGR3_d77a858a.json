{"ver":"0.1","info":{"id":"7tBGR3","date":"1624367837","viewed":280,"name":"ball_bounce_variation","username":"skaplun","description":"Easings cheatsheet: https://www.shadertoy.com/view/7tf3Ws\nText rendering by @P_Malin\n\nText can be enabled by uncommenting #define RENDER_FORMULA_TEXT (line 1)","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","animation","easing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define RENDER_FORMULA_TEXT\n#define AA2 4./iResolution\nvec2 ASPECT;\n\n//Text-related stuff\n#define FONT_EFFECTS\n#define AUTO_FONT_SPACING\n#define FONT_SAMPLER iChannel0\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n// SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n    {\n        return 0.1f;\n    }\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )\n    {     \n        return 0.8f;\n    }\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n    \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n#ifdef FONT_EFFECTS    \n    float fShadowDistance;\n    vec2 vNormal;    \n#endif\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n#ifdef FONT_EFFECTS        \n    state.fShadowDistance = 1000000.0;\n    state.vNormal = vec2(0.0);    \n#endif    \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold;\n#ifdef FONT_EFFECTS        \n    bool bShadow;\n    vec2 vShadowOffset;\n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(16.0f, 16.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n#ifdef FONT_EFFECTS        \n    style.vShadowOffset = vec2(0);\n    style.bShadow = false;\n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n#ifdef FONT_EFFECTS            \n    vec3 vOutlineColor;\n    vec3 vHighlightColor;\n    float fOutlineWeight;\n    float fBevelWeight;\n    float fShadowSpread;\n    float fShadowStrength;\n    vec2 vLightDir;\n#endif    \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;\n#ifdef FONT_EFFECTS            \n    style.vOutlineColor = vec3(1);\n    style.vHighlightColor = vec3(0);\n    style.fOutlineWeight = 0.0f;\n    style.fBevelWeight = 0.0f;\n    style.fShadowSpread = 0.0f;\n    style.fShadowStrength = 0.0f;\n    style.vLightDir = vec2(-1.0f, -0.5f );\n#endif    \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;\n#ifdef FONT_EFFECTS            \n        state.vNormal = v.yz;\n#endif        \n    }\n\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fShadowDistance = SampleCharacter( iChar, vUV - style.vShadowOffset ).a;\n        if ( style.bBold )\n        {\n            fShadowDistance -= 0.025f;\n        }\n        \n        if ( fShadowDistance < state.fShadowDistance )\n        {\n            state.fShadowDistance = fShadowDistance;\n        }        \n    }\n#endif\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fSize = renderStyle.fFontWeight + renderStyle.fOutlineWeight;\n        float fBlendShadow = clamp( (state.fShadowDistance - fSize - renderStyle.fShadowSpread * 0.5) / -renderStyle.fShadowSpread, 0.0, 1.0);\n        color.rgb = mix( color.rgb, vec3(0.0), fBlendShadow * renderStyle.fShadowStrength);    \n    }\n\n    if ( renderStyle.fOutlineWeight > 0.0f )\n    {        \n        float fBlendOutline = GetFontBlend( state, style, renderStyle.fFontWeight + renderStyle.fOutlineWeight );\n        color.rgb = mix( color.rgb, renderStyle.vOutlineColor, fBlendOutline);\n    }\n#endif\n    \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n\t\n#ifdef FONT_EFFECTS            \n    if ( renderStyle.fBevelWeight > 0.0f )\n    {    \n        float fBlendBevel = GetFontBlend( state, style, renderStyle.fFontWeight - renderStyle.fBevelWeight );    \n        float NdotL = dot( state.vNormal, normalize(renderStyle.vLightDir ) );\n        float shadow = 1.0 - clamp(-NdotL, 0.0, 1.0f);\n        float highlight = clamp(NdotL, 0.0, 1.0f);\n        highlight = pow( highlight, 10.0f);\n        vCol = mix( vCol, vCol * shadow + renderStyle.vHighlightColor * highlight, 1.0 - fBlendBevel);\n    }\n#endif\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n\nvoid PrintMessage( inout PrintState state, LayoutStyle style )\n{\n    uint strA[] = uint[] ( _H, _e, _l, _l, _o, _COMMA, _SP, _w, _o, _r, _l, _d, _PERIOD, _EOL );\n    ARRAY_PRINT( state, style, strA );\n\n    uint strB[] = uint[] ( _ITALON, _A, _B, _C, _1, _2, _3, _ITALOFF, _EOL );\n    ARRAY_PRINT( state, style, strB );\n    \n    uint strC[] = uint[] ( _BOLDON, _A, _B, _C, _1, _2, _3, _BOLDOFF, _SP );\n    ARRAY_PRINT( state, style, strC );\n}\n\nconst vec2 GRAD_OFFS = vec2(0.001, 0);\n#define DISP_SCALE 3.\n#define LINE_SIZE 3.\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.xx)\n#define PLOT(f, p) smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f,p))))\n\nfloat easeIn_bounceOut(vec2 uv){\n    uv.x *= 2.;\n    if(uv.x < .9){\n        uv.x -= .0;\n        return PLOT(easeInBack, uv);\n    }else{\n        uv.x -= 1.133;\n        uv.y = 1. - uv.y;\n        return PLOT(easeOutBounce, uv);\n    }\n}\n\nfloat easeIn_bounceOut(float x){\n    x *= 2.;\n    if(x < .9){\n        return easeInBack(x);\n    }else{\n        x -= 1.133;\n        return 1. - easeOutBounce(x);\n    }\n}\n\nfloat absSin(vec2 uv){\n    uv.x *= PI;\n    uv.x -= .1;\n    return PLOT(abssin, uv);\n}\n\nfloat absSinPow(vec2 uv){\n    uv.x *= PI;\n    return PLOT(abssinpow, uv);\n}\n\nconst vec3 BALL_COLORS[] = vec3[](vec3(0.161,0.424,0.439), vec3(0.580,0.584,0.314), vec3(0.937,0.349,0.204));\nconst vec3 BG = vec3(0.255,0.322,0.365);\nvec3 plot(vec2 uv, int id, float time){\n    uv.y = uv.y * 2. - 1.1;\n    \n    vec3 res = BG;\n    float p = max(smoothstep(AA2.y, 0., distance(uv.y, 0.)) * smoothstep(.5 + AA2.x, .5, distance(uv.x, .5)),\n                  smoothstep(AA2.x, 0., distance(uv.x, 0.)) * smoothstep(.5 + AA2.y, .5, distance(uv.y, .5)));\n    res = mix(res, vec3(.8), p);\n    res = mix(res, vec3(1.000,0.580,0.588), smoothstep(AA2.t, 0., distance(uv.x, uv.y)) * smoothstep(.5 + AA2.x, .5, distance(uv.x, .5)) * .5);\n\n    vec3 pltClr = mix(BALL_COLORS[id], vec3(.8), smoothstep(uv.x, uv.x + AA2.x, time));\n    float plot = 0.;\n    switch(id){\n        case 0: plot = absSin(uv * vec2(1.07, 1.));break;\n        case 1: plot = absSinPow(uv * vec2(1.07, 1.));break;\n        case 2: plot = easeIn_bounceOut(uv * vec2(1.07, 1.));break;\n        default: break;\n    }\n    res = mix(pltClr, res, plot);\n    res = mix(res, BG, smoothstep(.5, .5 + AA2.x, distance(uv.x, .5)));\n    return res;\n}\n\nfloat ball(vec2 uv, float h, float ground){\n    float b = length(uv - vec2(ASPECT.x, h)) - .25;\n    b = smax(b, -uv.y + ground, 50.);\n    return b;\n}\n\nvoid text(vec2 uv, out vec3 res, uint str[57]){\n    vec2 vCanvasCoord = vec2(iResolution.x * uv.x, iResolution.y - 1.0f - iResolution.y * uv.y);\n    LayoutStyle style = LayoutStyle_Default();\n    vec2 vCanvasPixelSize = vec2(1.0);\n    PrintState state = PrintState_InitCanvas(vCanvasCoord, vCanvasPixelSize );\n\n    ARRAY_PRINT( state, style, str );\n\n    RenderStyle renderStyle = RenderStyle_Default( vec3(.8) );\n\n    RenderFont( state, style, renderStyle, res );\n}\n\nconst vec3 outline_color = vec3(.15);\nconst float outline_width = .001;\nvec3 cell(vec2 uv, int id, float time){\n    vec3 res = plot(uv, id, time);\n\n#ifdef RENDER_FORMULA_TEXT\n    {//text\n        switch(id){\n            case 0:\n                text(uv * vec2(.2, .6) + vec2(-.008, .735), res, uint[57] (_c, _l, _a, _m, _p, _LPAR, _s, _i, _n, _LPAR, _x, _RPAR, _COMMA, _SP, _0, _PERIOD, _COMMA, _SP, _1, _PERIOD, _RPAR, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL));\n                break;\n            case 1:\n                text(uv * vec2(.21, .6) + vec2(.025, .735), res, uint[57] (_p, _o, _w, _LPAR, _c, _l, _a, _m, _p, _LPAR, _s, _i, _n, _LPAR, _x, _RPAR, _COMMA, _SP, _0, _PERIOD, _COMMA, _SP, _1, _PERIOD, _RPAR, _COMMA, _SP, _6, _PERIOD, _RPAR, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL, _EOL));\n                break;\n            case 2:\n                text(uv * vec2(.21, .6) + vec2(0., .735), res, uint[57] (_m, _i, _x, _LPAR, _e, _a, _s, _e, _I, _n, _B, _a, _c, _k,_LPAR, _x, _RPAR, _COMMA, _EOL, _SP, _SP, _SP, _SP, _e, _a, _s, _e, _O, _u, _t, _B, _o, _u, _n, _c, _e, _LPAR, _x, _RPAR, _COMMA, _EOL, _SP, _SP, _SP, _SP, _s, _t, _e, _p, _LPAR, _x, _COMMA, _SP, _PERIOD, _4, _RPAR, _RPAR));\n                break;\n            default:\n                break;\n        }\n        \n    }\n#endif\n    {//ball\n        float h = 0.;\n        switch(id){\n            case 0: h = abssin(time * PI);break;\n            case 1: h = abssinpow(time * PI);break;\n            case 2: h = easeIn_bounceOut(time);break;\n            default: break;\n        }\n        \n        uv.y = uv.y * 2.5;\n        uv /= ASPECT;\n        float b = ball(uv, h, -.2);\n        res = mix(res, BALL_COLORS[id], step(b, 0.));\n        res = mix(res, outline_color, smoothstep(outline_width + AA2.y, outline_width, abs(b)));\n        \n        res = mix(res, vec3(.8), smoothstep(.025 + AA2.x, .025, length(uv - vec2(ASPECT.x, h) - vec2(.1 + .025 * h))));\n    }\n    \n    return res;\n}\n\nconst vec2 ITEMS_COUNT = vec2(3., 1.);\nconst vec2 GRID_SIZE = vec2(1.)/ITEMS_COUNT;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 gs = GRID_SIZE;\n    \n    vec2 c = floor(uv/gs);\n    int id = int(ITEMS_COUNT.x) * int(c.y) + int(c.x);\n    \n    ASPECT = iResolution.xy/min(iResolution.x, iResolution.y) * GRID_SIZE/GRID_SIZE.y;\n    vec2 muv = mod(uv, gs)/gs;\n    \n    float time = clamp(mod(iTime, 2.)/1.5, 0., 1.);\n    vec2 offset = vec2(.25);\n    ASPECT *= vec2(1.2, 1.);\n    fragColor = vec4(cell(muv * (1. + offset) - offset * .5, id, time), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\n\nfloat smax(float a, float b, float k){\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat easeInBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeInBack(vec2 uv) {\n    return uv.y - easeInBack(uv.x);\n}\n\nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n\nfloat easeOutBounce(vec2 uv) {\n    return uv.y - easeOutBounce(uv.x);\n}\n\nfloat abssin(float x) {\n    return clamp(sin(x), 0., 1.);\n}\n\nfloat abssin(vec2 uv) {\n    return uv.y - clamp(sin(uv.x), 0., 1.);\n}\n\nfloat abssinpow(float x) {\n    return pow(clamp(sin(x), 0., 1.), 6.);\n}\n\nfloat abssinpow(vec2 uv) {\n    return uv.y - pow(clamp(sin(uv.x), 0., 1.), 6.);\n}","name":"Common","description":"","type":"common"}]}