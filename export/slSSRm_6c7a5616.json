{"ver":"0.1","info":{"id":"slSSRm","date":"1627313026","viewed":81,"name":"rgb semi-transparent cube","username":"CyanMARgh","description":"A semi-transparent colored cube that counts as O (1) color due to a previously solved differential equation.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube","rgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 camPos = vec3(0., 0., -2.2);\n\nvec2 intSphere(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\nvec2 intBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.) return vec2(-1.);\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tN, tF);\n}\n\nvec3 getDir(vec2 fc) {\n    vec2 r = iResolution.xy;\n    fc /= r;\n    fc -= .5;\n    fc.x *= r.x / r.y;\n    return normalize(vec3(fc.xy, 1.2));\n}\nvec3 calcG(vec3 G_l, vec3 p0, vec3 p1, vec3 color, float alpha) {\n    float beta = 1. - alpha; \n    float leng = length(p1 - p0);\n    vec3 a = log(beta) * color;\n    float b = -log(beta);\n    vec3 c = (a + b * G_l) * exp(-leng * b);\n    vec3 G_0 = (c - a) / b;\n    return G_0;\n}\nvec3 calcG_(vec3 G_l, vec3 p0, vec3 p1, vec3 pivot, vec3 size, float alpha) {\n    float beta = 1. - alpha; \n    vec3 dir = normalize(p1 - p0);\n    float leng = length(p1 - p0);\n    vec3 K = dir / size;\n    vec3 B = (p0 - pivot) / size;\n    vec3 a = log(beta) * K;\n    vec3 b = log(beta) * B;\n    vec3 c = vec3(-log(beta));\n    vec3 d = (a + c * (a * leng + b + c * G_l)) / exp(leng * c);\n    vec3 G_0 = ((d - a) / c - b) / c;\n    return G_0;\n}\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nfloat part(vec2 z) {\n    float l = z.x + z.y;\n    return l < .5 ? 0. : l < 1. ? 1. : l < 1.5 ? 0. : 1.;\n}\nvec3 houndstooth(vec2 z) {\n    z /= iResolution.y;\n    z = mod(z * 10., 2.);\n    return vec3(z.x < 1. ? (z.y < 1. ? part(z) : (0.)) : (z.y < 1. ? (1.) : 1.-part(z-1.)));\n}\n\nvoid mainImage(out vec4 col, in vec2 fc) {\n    vec3 background = houndstooth(fc);\n    float angle = .2 * iTime;\n    vec3 camPos_ = camPos;\n    camPos_.zy *= rot(.57);\n    camPos_.xz *= rot(angle);\n\n    vec3 dir = getDir(fc);    \n    dir.zy *= rot(.6);\n    dir.xz *= rot(angle);\n    \n    vec3 norm;\n    vec2 i0 = intBox(camPos_, dir, vec3(.5, .5, .5), norm);\n    if(i0.x < 0.) {\n        col = vec4(background, 1.);\n    } else {\n        vec3 p0 = camPos_ + dir * i0.x;\n        vec3 p1 = camPos_ + dir * i0.y;\n        \n        //col = vec4(calcG(background, p0, p1, vec3(1., 0., 0.), .9), 1.);\n        vec3 col_ = calcG_(background, p0, p1, vec3(-.5), vec3(1.), .6 + sin(iTime * 2.) * .399);\n        col = vec4(col_, 1.);\n    }\n}\n","name":"Image","description":"","type":"image"}]}