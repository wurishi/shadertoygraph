{"ver":"0.1","info":{"id":"WtVGDD","date":"1580251503","viewed":65,"name":"Ray Marching Shapes","username":"sbrown2","description":"Me attempting to implement a simple raymarcher. Very messy, will probably come back to it regularly.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxsteps 100\n#define maxdist 100.\n#define surf_d .001\n\nstruct Sphere{\n\tvec3 center;\n    float radius;\n};\nstruct Camera{\n\tvec3 camPos;\n    vec3 direction;\n};\nvec3 getCameraRayDirection(vec2 uv,vec3 camPos,float zoom,vec3 lookat){\n\n\tvec3 world_up = vec3(0.,1.,0.);\n    vec3 forward = normalize(lookat-camPos);\n    vec3 right   = cross(world_up,forward);\n    vec3 up      = cross(forward,right);\n    vec3 screen_c= camPos+forward*zoom;\n    vec3 i       = screen_c + right*uv.x + up*uv.y;\n    vec3 direction = i-camPos;\n    return normalize(direction);\n    \n}\n\n\nCamera createCamera(vec2 uv,vec3 camPos,float zoom,vec3 lookat){\n\t//find relative directions\n   \n    vec3 d = getCameraRayDirection(uv,camPos,zoom,lookat);\n    return Camera(camPos,d);\n}\nfloat capsuledist(vec3 p,vec3 a,vec3 b,float radius){\n\t//distance to line segment-radius\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    float d = 0.;\n    float h = clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    vec3 closestp = a + h*ab;\n    return length(p-closestp)-radius;\n}\nfloat torusdist(vec3 p, float bigr, float smallr){\n\t//find dist on xz plane\n    float x = length(p.xz)-bigr;\n    float y = p.y;\n    float d = length(vec2(x,y));\n    d-=smallr;\n    return d;\n}\n\nfloat boxdist(vec3 p, float size){\n\treturn length(max(vec3(0.),abs(p)-size));\n}\n\nfloat cylinderdist(vec3 p,vec3 a,vec3 b,float radius){\n\t//distance to line segment-radius\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    float d = 0.;\n    float h = dot(ap,ab)/dot(ab,ab);\n    vec3 closestp = a + h*ab;\n    d = length(p-closestp)-radius;\n    float y = (abs(h-.5)-.5)*length(ab);\n    float e = length(max(vec2(d,y),vec2(0.)));\n    float i = min(max(d,y),0.);\n    d=e+i;\n    return d;\n}\n\nfloat distToScene(vec3 p){\n\t//create scene\n    float d;\n    Sphere s = Sphere(vec3(0.,1.,0.),1.);\n    vec3 cap_center = vec3(-2.,1.,6.);\n    cap_center.y+=cos(iTime)+.5;\n    s.center.y+=sin(iTime)+.5;\n    \n    float s_dist = length(p - s.center) - s.radius;\n    float p_dist = p.y;\n    float caps_dist = capsuledist(p,cap_center,\n                                  cap_center+vec3(-0.,0.,-2.),.5);\n    float torus_dist = torusdist(p+vec3(0.,-2.*(sin(iTime)+1.1),0.),2.,.2);\n    float box_dist  = boxdist(p-vec3(4.,cos(iTime)+2.,-1.),1.);\n    float cylinder_dist = cylinderdist(p-2.*sin(iTime),vec3(1.),vec3(2.),1.);\n    d = min(s_dist,min(caps_dist,p_dist));\n    \n    d = min(d,torus_dist);\n    d = min(d,box_dist);\n    d = min(d,cylinder_dist);\n    return d;\n    \n}\n\nfloat RayMarch(Camera c){\n\tfloat t = 0.;\n    for(int i = 0; i < (maxsteps); i++){\n    \tvec3 p = c.camPos + c.direction*t;\n        float d = distToScene(p);\n        t+=d;\n        if(t > maxdist || d < surf_d ){break;}\n        \n    }\n    return t;\n\n}\nfloat RayMarch2(vec3 pos, vec3 dir){\n\tfloat t = 0.;\n    for(int i = 0; i < (maxsteps); i++){\n    \tvec3 p = pos + dir*t;\n        float d = distToScene(p);\n        t+=d;\n        if(t > maxdist || d < surf_d ){break;}\n        \n    }\n    return t;\n\n}\nvec3 GetNormal(vec3 p){\n    float d = distToScene(p);\n    vec2 e = vec2(.01,0.);\n    vec3 n = d - vec3(\n    distToScene(p - e.xyy),\n    distToScene(p - e.yxy),\n    distToScene(p - e.yyx)\n    );\n    return normalize(n);\n}\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(10., 10., -10.);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), .0, 1.);\n    Camera c = Camera(p+n*surf_d*2., l);\n    float d = RayMarch(c);\n    if(d<length(lightPos-p)) dif *= .2;\n    \n    return dif;\n}\nfloat getLight(vec3 lightPos, vec3 p, Camera c){\n\tfloat diff;\n    float spec;\n    \n    vec3 lightv = normalize(lightPos-p);\n    vec3 normalv = GetNormal(p);\n    if(dot(lightv,normalv)<0.){\n    \treturn 0.;\n    }else{diff = dot(lightv,normalv);}\n    \n    vec3 reflectv = reflect(-lightv,normalv);\n    vec3 eyev=-c.direction;\n    float rdeye = dot(reflectv,eyev);\n    if(rdeye < 0.){spec = 0.;}\n    else{spec = clamp(rdeye,0.,1.);\n    }\n    return diff+(spec*pow(rdeye,150.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\t\n    \n    //create camera need uv, camPos, zoom, lookat\n    \n\t\tvec3 camPos = vec3(0.,5.,-8.);\n    \tcamPos.y+=2.*cos(iTime);\n\t\tfloat zoom = 1.;\n\t\tvec3 lookat = vec3(0.,1.,6.);\n\t\tvec3 lightPos = vec3(10.,10.,-10.);\n    \tCamera c = createCamera(uv,camPos,zoom,lookat);\n    \t\n\t\n    //place sphere at (0,0,1) radius = 1\n    \n    //raymarch to return parameter t where we hit obj\n\tfloat t = RayMarch(c);\n   \tvec3 p = c.camPos + c.direction*t;\n    float light = getLight(lightPos,p,c);\n    vec3 col = vec3(light);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}