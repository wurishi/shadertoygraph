{"ver":"0.1","info":{"id":"csyXDy","date":"1681507452","viewed":54,"name":"Polar coordinates, wrap ","username":"Anilcan","description":"sample textures, with polar coordinates\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["polarcoordinates","wrap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// converted from here: https://gist.github.com/KeyMaster-/2bb5e20f824241f3caef\n\n//x: width of the texture divided by the radius that represents the top of the image (normally screen width / radius)\n//y: height of the texture divided by the radius representing the top of the image (normally screen height / radius)\nuniform vec2 sizeOverRadius;\n\n//This is a constant to determine how far left/right on the source image we look for additional samples \n//to counteract thin lines disappearing towards the center (a somewhat adjusted texel width in uv-coordinates)\n//This value is 1 / (texture width * 2 PI)\nfloat sampleOffset = 1.0 / (1024.0 * 3.14159265);\n\n//Linear blend factor that swaps the direction the y-axis of the source is mapped onto the radius\n//if the value is 1, y = 0 is at the outer edge of the circle, \n//if the value is 0, y = 0 is the center of the circle\nfloat polarFactor = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Make relative to center\n\tvec2 relPos = uv - vec2(0.5,0.5);\n\t\n\t//Adjust for screen ratio\n\t//relPos *= sizeOverRadius;\n\t\n\t//Normalised polar coordinates.\n\t//y: radius from center\n\t//x: angle\n\tvec2 polar;\n\t\n\tpolar.y = sqrt(relPos.x * relPos.x + relPos.y * relPos.y);\n\t\n\t//Any radius over 1 would go beyond the source texture size, this simply outputs black for those fragments\n\tif(polar.y > 1.0){\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\t\n\tpolar.x = atan(relPos.y, relPos.x);\n\t\n\t//Normally, the angle starts from the axis going right and is counter-clockwise\n\t//I want the left edge of the screen image to be the line upwards,\n\t//so I rotate the angle half pi clockwise\n\tpolar.x -= 1.57079632679;\n\t\n\t//Normalise from angle to 0-1 range\n\tpolar.x /= 6.28318530718;\n\t\n\t//Make clockwise\n\tpolar.x = -polar.x;\n\t\n\tpolar.x = mod(polar.x + (iTime * 0.1), 1.0);\n\t\n\t//The xOffset fixes lines disappearing towards the center of the coordinate system\n\t//This happens because there's only a few pixels trying to display the whole width of the source image\n\t//so they 'miss' the lines. To fix this, we sample at the transformed position\n\t//and a bit to the left and right of it to catch anything we might miss.\n\t//Using 1 / radius gives us minimal offset far out from the circle, \n\t//and a wide offset for pixels close to the center\n\t\n\tfloat xOffset = 0.0;\n\tif(polar.y != 0.0){\n\t\txOffset = 1.0 / polar.y;\n\t}\n\t\n\t//Adjusts for texture resolution\n\txOffset *= sampleOffset;\n\t\n\t//This inverts the radius variable depending on the polarFactor\n\tpolar.y = polar.y * polarFactor + (1.0 - polar.y) * (1.0 - polarFactor);\n\t\n\t//Sample at positions with a slight offset\n\tvec4 one = texture(iChannel0, vec2(polar.x - xOffset, polar.y));\n\t\n\tvec4 two = texture(iChannel0, polar);\n\t\n\tvec4 three = texture(iChannel0, vec2(polar.x + xOffset, polar.y));\n\t\n\t//Take the maximum of the three samples. This is not ideal, but the quickest way to choose a coloured sample over the background colour.\n\tfragColor = max(max(one, two), three);\n}","name":"Image","description":"","type":"image"}]}