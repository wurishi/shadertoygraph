{"ver":"0.1","info":{"id":"tsySR3","date":"1574566237","viewed":74,"name":" sphere tracing test-mod2","username":"jorge2017a1","description":" sphere tracing test-mod2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spheretracingtestmod2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Created by neur0sys in 2019-11-22\n//modificado por jorge 23-11-2019\n\nconst int NONE = 0;\nconst int SPHERE = 1;\nconst int PLANE = 2;\nconst int TORUS = 3;\nconst int BOX = 4;\nconst int LIGHT = 5;\n\nconst vec3 sphere_pos = vec3(2.0, -2.0, -5.0);\nconst vec3 box_pos = vec3(-2.0, -2.0, -5.0);\nconst vec3 torus_pos = vec3(0.0, 2.0, -5.0);\nconst vec3 plane_pos = vec3(0.0, -2.0, 0.0);\n\nstruct Obj {\n    int type;\n    float d;\n};\n\n\n// sdf primitives https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  float t = iTime;\n  //p.xz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  //p.yz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  //p.xy *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float t0 = iTime;\n  p.xz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.yz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.xy *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 traceAmbient()\n{\n    // ambient\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * vec3(1.0);\n    return ambient;\n}\n\nvec3 traceDiffuse(vec3 lightDir, vec3 n)\n{\n    // diffuse\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0);\n    \n    vec3 c = vec3(1.0);\n    \n    return diffuse * c;\n}\n\nvec3 traceSpecular(vec3 lightDir, vec3 hit, vec3 l0, vec3 n)\n{\n    // specular\n    vec3 viewDir = normalize(hit - l0);\n    vec3 reflectDir = reflect(lightDir, n); \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);\n    return vec3(spec);\n}\n\nvec3 getLightPos()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 2.0, -15.0);\n    lightPos.z += cos(t0) * 8.0;\n    lightPos.x += sin(t0) * 8.0;\n    return lightPos;\n}\n\n\nvec3 getLightPosv2()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 1.0, -2.0);\n    lightPos.x += sin(t0) * 4.0;\n    \n    return lightPos;\n}\n\n\nvec3 traceLight(vec3 n, vec3 hit, vec3 l0)\n{\n    vec3 lightDir = normalize(getLightPos() - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n   \n    return ambient + diffuse + spec;\n    \n    \n    \n}\n\n\n\n\n\n\nvec3 traceLightLuz(vec3 n, vec3 hit, vec3 l0, vec3 luz)\n{\n    vec3 lightDir = normalize(luz - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n    \n  \n   \n    return ambient + diffuse + spec;\n}\n\n\n\n\n#define EPSILON 1e-3\nconst vec3 e = vec3(0.01, 0, 0);\n\nvec3 nBox(vec3 p, vec3 b) {\n    float d = sdBox(p, b);\n\tvec3 n = d - vec3(\n    \tsdBox(p - e.xyy, b),\n        sdBox(p - e.yxy, b),\n        sdBox(p - e.yyx, b)\n    );\n    return normalize(n);\n}\n\nvec3 nSphere(vec3 p, float s) {\n    float d = sdSphere(p, s);\n\tvec3 n = d - vec3(\n    \tsdSphere(p - e.xyy, s),\n        sdSphere(p - e.yxy, s),\n        sdSphere(p - e.yyx, s)\n    );\n    return normalize(n);\n}\n\nvec3 nTorus(vec3 p, vec2 t) {\n    float d = sdTorus(p, t);\n\tvec3 n = d - vec3(\n    \tsdTorus(p - e.xyy, t),\n        sdTorus(p - e.yxy, t),\n        sdTorus(p - e.yyx, t)\n    );\n    return normalize(n);\n}\n\nvec3 mapLight(Obj obj, vec3 hit, vec3 l0)\n{\n    vec3 col;\n    vec3 n = vec3(0.0);\n    \n    if (obj.type == PLANE) {\n        n = vec3(0.0, 1.0, 0.0);\n        col=vec3(1,0,0);\n    } else if (obj.type == SPHERE) {\n    \tn = nSphere(hit - sphere_pos, 1.0);\n        col=vec3(1,1,0);\n        \n    } else if (obj.type == BOX) {\n    \tn = nBox(hit - box_pos, vec3(1.0));\n        col=vec3(1,0,1);\n            \n        \n    } else if (obj.type == TORUS) {\n    \tn = nTorus(hit - torus_pos, vec2(1.5, 0.5));\n        col=vec3(0,1,1);\n        \n    } else if (obj.type == LIGHT) {\n    \treturn vec3(1.0);\n    }\n\n    return (traceLight(n, hit, l0)*col+traceLightLuz(n, hit, l0,getLightPosv2())*col)/1.5;\n    //return traceLightLuz(n, hit, l0,vec3(0.0, 1.0, 1.0))*col;\n}\n\nObj map(vec3 p)\n{\n\n   \n    float d = 1e6;\n    float t = 0.0;\n    int type = NONE;\n    \n    t = sdSphere(sphere_pos - p, 1.0);\n    if (t < d) { type = SPHERE; d = t; }\n    \n    t = sdSphere(getLightPos() - p, 0.25);\n    if (t < d) { type = LIGHT; d = t; }\n    \n    //t = sdSphere(getLightPosv2() - p, 0.5);\n    //if (t < d) { type = LIGHT; d = t; }\n    \n    \n    t = sdBox(box_pos - p, vec3(1.0));\n    if (t < d) { type = BOX; d = t; }\n    \n    t = sdTorus(torus_pos - p, vec2(1.5, 0.5));\n    if (t < d) { type = TORUS; d = t; }\n    \n    t = sdPlane(plane_pos - p, normalize(vec4(0.0, -1.0, 0.0, 5.0)));\n\tif (t < d) { type = PLANE; d = t; }\n    \n    return Obj(type, d);\n}\n\nObj trace(vec3 o, vec3 r)\n{\n    Obj obj = Obj(NONE, 1e6);\n    \n    float t = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p = o + r * t;\n        obj = map(p);\n        t += obj.d;\n        if (obj.d < 1e-3) {\n        \tbreak;\n        }\n    }\n    \n    obj.d = t;\n    \n    return obj;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // [-1, 1]\n    uv = uv * 2.0 - 1.0;\n    \n    // aspect corrected\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(uv, -1.0);\n    \n    Obj obj = trace(o, r);\n    \n    vec3 hit = o + obj.d * r;\n    \n    vec3 light = mapLight(obj, hit, o);\n    \n    float fog = 1.0 / (1.0 + obj.d * obj.d * 0.01);\n    \n\tvec3 c = vec3(1.0);\n\n    c = vec3(c * fog * light);\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}