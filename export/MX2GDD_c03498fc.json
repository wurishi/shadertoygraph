{"ver":"0.1","info":{"id":"MX2GDD","date":"1708484391","viewed":67,"name":"abare hamon (Raging Ripple)","username":"tono","description":"After I adjusted the water droplets and ripples in my previously written shader, 'hamon', and refined the rendering of the raindrops... it became so fun that the raindrops began to rage!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n#define ID_FLOOR 1.\n#define ID_RAIN 2.\n\nfloat pi = acos(-1.);\n\nfloat rainFrequency = 1.;\nfloat rainRandomWidth = .4 ;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy,vec2(32.31254,35.1354))) * 542525.3242 );\n}\n\n\nvec3 rainInfo(vec2 id , vec2 grid){\n\tfloat localRandomValue = rand(vec2(rand(id) * 100.,floor((iTime + rand(id) * 3. + pi)/ (pi * 2.) )) ) ; \n\n    float rainTime =  iTime + rand(id) * 360.;\n\n    float waveSeed = floor(rainTime / (pi * 2.) );\n    float waveToggle = step(rand(vec2(waveSeed)) , rainFrequency);\n\treturn vec3(waveToggle , rainTime,localRandomValue );\n}\n\nfloat span = 1.;\nvec2 sdRain(vec3 p){\n    \n    vec2 o = vec2(10.,ID_RAIN);\n    \n    vec2 id = floor(p.xz / span);\n    vec2 grid = mod(p.xz , span) - span/2.;\n    \n    vec3 raindata = rainInfo(id,grid);\n    float waveToggle = raindata.x;\n    float rainTime = raindata.y;\n    float localRandomValue = raindata.z;\n    grid += (localRandomValue-0.5) * rainRandomWidth;\n    float len = length(grid);\n    \n    if(waveToggle< 1.){return o;}\n    \n    vec2 rainDir = vec2(.1,0.);\n    p.yz *= rot(rainDir.x);\n    p.xy *= rot(rainDir.y);\n   // p.xz += rainDir * mix(0.,10.,mod(-rainTime,pi)/pi ) * 1.;\n    p.y += mix(0.,-26.,mod(-rainTime,pi)/pi ) * 1.;\n    \n    p.y -= 1.;\n    p.y -= clamp(p.y , 0.,.3 );\n    float w = .001 ;\n    grid -= clamp(grid , vec2(-w),vec2(w));\n    o.x = length(vec3(grid,p.y));\n    \n    return o;\n}\n\n/*\nvec2 currentID = id + vec2(x,y);\n            vec2 currentGrid = grid - vec2(x,y) * span;\n            \n            float localRandomValue = rand(vec2(floor((gtime + rand(currentID) * 360. + pi)/ (pi * 2.) )) ) ; \n            currentGrid += (localRandomValue-0.5) * 3.;\n            \n            float rainTime =  gtime + rand(currentID) * 360.;\n            \n            float waveSeed = floor(rainTime / (pi * 2.) );\n            float waveToggle = step(rand(vec2(waveSeed)) , 0.5);\n*/\n\nvec2 sdFloor(vec3 p){\n\tvec2 o = vec2(10.,ID_FLOOR);\n    vec3 s = vec3(1.);\n    //s += sin(p.x * 3. + time + sin(p.z/10.))/330.;\n    //s += sin(p.z*4. + time/3.)/36.;\n    \n    //p.y += 5.;\n    p.xz = mod(p.xz , span) - span/2.;\n    p -= clamp(p,-s,s);\n    o.x = length(p);\n    return o;\n}\n\nvec2 map(vec3 p){\n\tvec2 o = vec2(10.,0.);\n    \n    //o.x = length(p) - 1.;\n    //p.xz *= rot(time);\n    o = sdFloor(p);\n    vec2 rain = sdRain(p);\n    o = mix(rain,o,step(o.x,rain.x));\n    o.x = o.x;\n    return o;\n}\n\n//https://neort.io/art/brj60ac3p9f9ke956c20に解説を追加\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize){\n\t//箱の中心からの距離\n    vec3 diff = rayPos - boxPos;\n    //レイの逆数を取る　どの成分が大きいか小さいかによって、箱のどの面が一番近いのかを取得\n\tvec3 m = 1.0 / rayDir;\n    //逆向きのレイのベクトルを出す\n    vec3 n = m * diff;\n    //各面との距離を出す\n    vec3 k = abs(m) * boxSize;\n    //レイが抜けてるかこれから入るかの判定　どっちが近いのか出す\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    //レイが最初に侵入するまでの距離、脱出するまでの時間\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    //最後に、レイがボックスに入る時間(tN)と出る時間(tF)をベクトルとして返します。このベクトルは、レイがボックスと交差しているかどうか、また、どの範囲で交差しているかを示します。\n    return vec2(tN, tF);\n}\n\n//はしら\nvec2 GetIntersectPiller(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize){\n\t//箱の中心からの距離\n    vec2 diff = rayPos.xz - boxPos.xz;\n    //レイの逆数を取る　どの成分が大きいか小さいかによって、箱のどの面が一番近いのかを取得\n\tvec2 m = 1.0 / rayDir.xz;\n    //逆向きのレイのベクトルを出す\n    vec2 n = m * diff;\n    //各面との距離を出す\n    vec2 k = abs(m) * boxSize.xz;\n    //レイが抜けてるかこれから入るかの判定　どっちが近いのか出す\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    //レイが最初に侵入するまでの距離、脱出するまでの時間\n    float tN = max(t1.x, t1.y);\n    float tF = min(t2.x, t2.y);\n    //最後に、レイがボックスに入る時間(tN)と出る時間(tF)をベクトルとして返します。このベクトルは、レイがボックスと交差しているかどうか、また、どの範囲で交差しているかを示します。\n    return vec2(tN, tF);\n}\n\nvec2 march(vec3 cp , vec3 rd){\n\tfloat depth = 0.;\n    for(int i = 0 ; i < 256; i++){\n        vec3 pos = cp + rd * depth;\n    \tvec2 d = map(pos);\n        if(abs(d.x) < 0.01){\n        \treturn vec2(depth , d.y);\n        }\n        \n        //Grid 光飛ばし過ぎない\n    \tvec2 iBox = GetIntersectPiller(pos, rd, floor(pos + span/2.), vec3(span/2.));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d.x) {\n            d = vec2(iBox.y + 0.01, 0); \n        }\n        if(depth > 100.)break;\n        depth += d.x;\n    }\n    return vec2(-depth);\n}\n\nvec3 wave(vec3 pos){\n\tvec2 id = floor(pos.xz / span);\n    vec2 grid = mod(pos.xz , span) - span/2.;\n    \n    vec3 color = vec3(0.);\n    //grid += (rand(id)-0.5) * 0.5;\n    for(int x = -2 ; x < 3 ; x++)\n    {\n        for(int y = -2 ; y < 3 ; y++){\n            vec2 currentID = id + vec2(x,y);\n            vec2 currentGrid = grid - vec2(x,y) * span;\n            vec3 raindata = rainInfo(currentID,currentGrid);\n            float waveToggle = raindata.x;\n            float rainTime = raindata.y;\n            float localRandomValue = raindata.z;\n            \n            currentGrid += (localRandomValue-0.5) * rainRandomWidth;\n            float len = length(currentGrid);\n            \n        \tcolor += waveToggle * vec3(1.) \n                \t* step(0.9999,cos(-len + rainTime) )\n                * mix(1.,0.,min(1.,len * 1. * (1. + 3.*localRandomValue) )) ;\n        }\n    }\n    \n    return color;\n}\n#define TT(x,y) floor(x) + pow(fract(x),y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp = vec3(0.,14.,.1);\n    cp.x = tan(TT((iTime/17.),8.) * 0.1) * 10.;\n    cp.y = cos(TT((iTime/13.),1.)/4. )* 36.;\n    cp.z = tan(TT((iTime/11.),16.) * .3);\n    //cp.xz *= rot(0.3 + time / 100.);\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cu = normalize(vec3(0.,1.,0.) );\n    vec3 cs = normalize(cross(cu,cd));\n    \n    float fov = 2.5;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov);\n    vec3 color = vec3(0.);\n    \n    vec2 d = march(cp, rd);\n    if(d.x > 0.){\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.001);\n        vec3 n = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x ));\n        \n        vec3 sun = normalize(vec3(2.,4.,8.));\n\t\tfloat diff = max(0.3,dot(n , sun));\n        float sp = max(0.,dot(rd , reflect(n,sun)));\n        \n        float rim = clamp(1.-dot(n,-rd),0.,1.);\n        //rim = 1. - rim;\n        // rim = pow(rim , 3.) ;\n        sp = pow(sp , 6.6);\n    \tvec3 mat = vec3(1.);\n        if(d.y == ID_RAIN){\n        \tcolor = vec3(.3);\n        }else{\n        \tcolor = vec3(1.,0.,0.);\n        }\n        //fog\n        float t = exp(-.00003 * d.x * d.x * d.x);\n    \tcolor = mix(vec3(0.),color ,t);\n        if(d.y == ID_FLOOR){\n        \tmat = wave(pos);\n        \tcolor = mat * diff + vec3(1.,1.,0.9) * sp * 1.;\n        }\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}