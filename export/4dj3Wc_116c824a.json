{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct traceResult {\n\tfloat d;\n\tvec3 intersection;\n\tvec3 normal;\n\tvec3 color;\n};\n\t\ntraceResult trace( vec3 orig, vec3 delta ) {\n\tvec3 spherea = vec3(-200, 10, 2000);\n\tfloat spherea_r = 500.0;\n\tvec3 sphereb = vec3(400, 250, 1500);\n\tfloat sphereb_r = 300.0;\n\tvec3 spherec = vec3(200, -300, 1400);\n\tfloat spherec_r = 300.0;\n\t\n\tfloat plane_y = -300.0;\n\t\n\tfloat bar, foo, d=100000.0, d2;\n\tvec3 intersection, norm, color;\n\tcolor = vec3(0.5,0.5,0.5);\n    \n\tbar = dot(delta,orig-spherea);\n\tfoo = ( bar*bar - dot(orig-spherea,orig-spherea) + spherea_r*spherea_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(spherea-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.8,0.2,0.3);\n\t}\n\t\n\tbar = dot(delta,orig-sphereb);\n\tfoo = ( bar*bar - dot(orig-sphereb,orig-sphereb) + sphereb_r*sphereb_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(sphereb-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.3,0.2,0.8);\n\t}\n\t\n\tbar = dot(delta,orig-spherec);\n\tfoo = ( bar*bar - dot(orig-spherec,orig-spherec) + spherec_r*spherec_r );\n\td2 = - bar - sqrt(foo);\n\tif( foo>0.0 && d2 > 0.01 && d2<d ) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = normalize(spherec-intersection);\n\t\td=d2;\n\t\tcolor=vec3(0.3,0.2,0.8);\n\t}\n\t\n\td2 = (plane_y-orig.y)/delta.y;\n\tif( d2<d && d2 > 0.01) {\n\t\tintersection = orig + delta*d2;\n\t\tnorm = vec3(0.0,-1.0,0.0);\n\t\td=d2;\n\t\tcolor=vec3(0.1,0.3,0.2);\n\t}\n\t\n\treturn traceResult( d, intersection, norm, color );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat st = sin(iTime);\n\tfloat ct = cos(iTime);\n\tvec3 delta = normalize( vec3(fragCoord.xy-0.5*iResolution.xy, iResolution.x*0.5) );\n\tdelta = vec3(delta.x*ct-delta.z*st,delta.y,delta.z*ct+delta.x*st);\n    vec3 orig = vec3( 1200.0*st, 0.0, 1600.0-1400.0*ct );\n\tvec3 lighta = vec3(1000, 1000, 1000);\n\tvec3 lightb = vec3(-1000, 2000, -1000);\n\t\n\ttraceResult r = trace(orig, delta);\n\t\n\tvec3 delta2 = normalize(lighta-r.intersection);\n\tvec3 orig2 = r.intersection + 0.01*delta2;\n\ttraceResult r2 = trace(orig2,delta2);\n\t\n\tvec3 delta3 = normalize(lightb-r.intersection);\n\tvec3 orig3 = r.intersection + 0.01*delta3;\n\ttraceResult r3 = trace(orig3,delta3);\n\t\n\tif( ! (r.d > 0.001) ) {\n\t\tfragColor = vec4(1.0,0,0,0);\n\t}\n\telse {\n\t\tvec3 el = normalize(r.intersection-lighta);\n\t\tfloat e = dot( r.normal, el );\n\t\tfloat es = pow( dot( delta ,normalize(2.0*dot(el,r.normal)*r.normal-el) ), 100.0);\n\t\t//if(r2.d < distance(r2.intersection,lighta)-0.1 || e < 0.0){ e=0.0; es=0.0;} ;\n\t\t\n\t\tvec3 fl = normalize(r.intersection-lightb);\n\t\tfloat f = dot( r.normal, normalize(r.intersection-lightb) );\n\t\tfloat fs = pow( dot( delta ,normalize(2.0*dot(fl,r.normal)*r.normal-fl) ), 100.0);\n\t\tif(r3.d < distance(r3.intersection,lightb)-0.1 || f < 0.0) {f=0.0; fs=0.0;};\n\t\t//fragColor = vec4( sqrt(e*e+f*f)*r.color + (es+fs)*vec3(1.0,1.0,1.0), 1.0 );\n        fragColor = vec4( sqrt(e*e+f*f)*r.color + (es+fs)*vec3(1.0,1.0,1.0), 1.0 );\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dj3Wc","date":"1394479035","viewed":215,"name":"TrivialRaytracer3","username":"Tivi","description":"Tried out some raytracing to see how it works. Three spheres, two point lights, diffuse and specular lighting. There's probably something wrong with the horizon.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}