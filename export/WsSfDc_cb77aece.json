{"ver":"0.1","info":{"id":"WsSfDc","date":"1591050480","viewed":155,"name":"RayMarching Learning","username":"Kaeylos","description":"small shader to learn the basics of ray marching and do tests","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","learnig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Render options ----- //\n#define USE_SHADOW\n#define USE_SPECULAR\n#define AA 1 // anti Aliasing\n#define VIGNETTING\n#define VIGNETTAGE_STRENGHT 0.2\n#define REFLEXION_STRENGHT 0.1\n#define REFLEXION_COUNT 3\n// ----- LIGHT options ----- //\n\n#define SPECULAR_FACTOR 16.0\n#define SPECULAR_STRENGTH .6\n#define BLINN_PHONG\n#define SOFT_SHADOWS_FACTOR 7.0\n// Sebastian Aaltonen's soft shadow improvement\n#define IMPROVED_SOFT_SHADOWS\n#define SHADOWS_ATTENUATION 0.7\n\n// ----- normal calculation options ----- //\n// source : https://iquilezles.org/articles/normalsSDF\n#define TETRAHEDRON_TECHNIQUE 2\n#define CENTRAL_DIFFERENCES_TECHNIQUE 1\n#define FORWARD_DIFFERENCES_TECHNIQUE 0\n#define NORMAL_CALCULATION_TECHNIQUE 2\n#define NORMAL_DELTA 0.0001\n\n// ----- Ray marching options ----- //\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 150\n#endif\n\n#define MAX_DIST 200.\n#define SURF_DIST 0.0001\n\n// ----- Buffer Camera input index ----- // \n#define VALUE_POSITION 1\n#define VALUE_ROTATION 2\n\n// Retrieve a saved value on the iChannel1 buffer\nvec4 getValue(int a) { return texelFetch(iChannel1, ivec2(a, 0), 0); }\n\n// ----- Useful constants ----- //\n\n#define PI     3.14159265358979323846264338327\n#define TWO_PI 6.28318530717958647692528676655\n\n// ----- Matrix functions ----- // (column major)\n\nmat2 Rot2(float a) { \n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c, -s, s, c );\n}\n\n// Returns the 3D rotation matrix on the X axis.\nmat4 Rot4X(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4( 1, 0, 0, 0,\n                 0, c,-s, 0,\n                 0, s, c, 0,\n                 0, 0, 0, 1 );\n}\n\nmat4 Rot4Y(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4( c, 0, s, 0,\n                 0, 1, 0, 0,\n                 -s, 0, c, 0,\n                 0, 0, 0, 1 );\n}\n\nmat4 Rot4Z(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4( c,-s, 0, 0,\n        \t\t s, c, 0, 0,\n       \t\t  \t 0, 0, 1, 0,\n       \t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Translate4(vec3 p) {\n    p *= -1.;\n    return mat4(\n        1,  0,  0,  p.x,\n        0,  1,  0,  p.y,\n        0,  0,  1,  p.z,\n        0,  0,  0,  1 );\n}\n\nvec3 vRotateX(vec3 v, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(v.x, c*v.y + s*v.z, -s*v.y + c*v.z);\n}\n\nvec3 vRotateY(vec3 v, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(c*v.x - s*v.z, v.y, s*v.x + c*v.z);\n}\n\nvec3 vRotateZ(vec3 v, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(c*v.x + s*v.y, -s*v.x + c*v.y, v.z);\n}\n\n// ----- useful functions ----- //\n\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(v.x ,max(v.y, v.z)); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float a, float b, float c, float d) { \n    return c + (t - a) * (d - c) / (b - a);\n}\nfloat map(float t, float c, float d) {  return c + t * (d - c);} // considering that t is in [0-1]\n\n// HSV to RGB conversion\n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n// ----- interpolations functions ----- //\nfloat q01If(float x) { return 1.-(1.-x)*(1.-x); }\nvec3 q01If(vec3 x) { return 1.-(1.-x)*(1.-x); }\n\nfloat q02If(float x, float k) { return (1.- (1.-x) * (1.-x)) * k; }\n    \n// ----- distance functions modifiers ----- //\n\n// source https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*0.25;\n}\n\nfloat smax( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return max(a, b) + h*h*0.25;\n}\n\nfloat sminCubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smaxCubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0)/k;\n    return max(a, b) + h*h*h*k*(1.0/6.0);\n}\nfloat sminExp(float a, float b, float k) {\n    return -log( exp(-k * a) + exp(-k * b) ) / k;\n}\nfloat sminExp2(float a, float b, float k) {\n    return -log2( exp2(-k * a) + exp2(-k * b) ) / k;\n}\n\nfloat roundOp (float d, float r) { return d - r; }\n\nfloat onionOp(float d,float h) { return abs(d)-h; }\n// sources : https://iquilezles.org/articles/distfunctions\n//\t\t\t https://www.shadertoy.com/view/Ml3fWj\nvec4 elongateOp(vec3 p, vec3 h) {\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    vec3 q = abs(p)-h;\n    return vec4( max(q, 0.0), min(maxComp(q), 0.0) );\n}\n\nvec3 arrayOp(vec3 p, vec3 offset) {\n    return mod(p + 0.5 * offset, offset) - 0.5 * offset;\n}\n\nvec3 arrayOp(vec3 p, vec3 offset, vec3 count) {\n    return p - offset * clamp(round(p/offset),vec3(0.0), count);\n}\n\nfloat unionOp( float d1, float d2, float k ) { return min(d1, d2);}\nfloat subOp( float d1, float d2, float k ) { return max(-d1, d2); }\nfloat interOp( float d1, float d2, float k ) { return max(d1,d2); }\n\nfloat sUnionOp( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sSubOp( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sInterOp( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 scaleOp (vec3 p, float s) { return p/s; }\n\n// special thanks to https://iquilezles.org/articles/distfunctions\n// ------------ (Signed Field Distance) ------------ //\n// ----- distance functions for 2D primitives ----- //\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// uneven capsule\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb ) {\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//----- 2D SDF modifier -----//\nvec2 simX(vec2 p) { return vec2(abs(p.x), p.y); }\n\nvec2 revolutionOp(vec3 p, float w) { return vec2( length(p.xz) - w, p.y );}\n\n// ----- distance functions for 3D primitives ----- // \nfloat sphereSDF(vec3 p, float radius) { return length(p) - radius; }\n\n// float planeSDF(vec3 p, vec3 n, float h) { return dot(p,n) - h;  }\nfloat planeSDF(vec3 p, vec4 plane) { return dot(p - plane.w, plane.xyz); }\n\nfloat verticalCapsuleSDF( vec3 p, float h, float radius) {\n  p.y -= clamp( p.y, 0.0, h );\n  return roundOp(length(p), radius);\n}\n\nfloat capsuleSDF( vec3 p, vec3 a, vec3 b, float radius ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n  return roundOp(length(pa - ba*h), radius);\n}\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\nfloat roundBoxSDF(vec3 p, vec3 boxDim, float radius) {\n  return roundOp(boxSDF(p, boxDim), radius);\n}\n\nfloat torusSDF( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n// special thanks to iq : https://www.shadertoy.com/view/ldj3Wh\n#if 1\nvec2 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 ) {\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n\n    vec3 b01 = cross(b0,b1);\n    vec3 b12 = cross(b1,b2);\n    vec3 b20 = cross(b2,b0);\n\n    vec3 n =  b01+b12+b20;\n\n    float a = -dot(b20,n);\n    float b = -dot(b01,n);\n    float d = -dot(b12,n);\n\n    float m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*0.5)*b2 + (-d-a*0.5)*b0;\n    float f = a*a*0.25-b*d;\n    vec3  k = b0-2.0*b1+b2;\n    float t = clamp((a*0.5+b-0.5*f*dot(g,k)/dot(g,g))/m, 0.0, 1.0 );\n\t\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t) ;\n}\n#else\nvec2 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n    {\n      vec3 w = normalize( cross( vc-vb, va-vb ) );\n      vec3 u = normalize( vc-vb );\n      vec3 v =          ( cross( w, u ) );\n\n      vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n      vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n      vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n            \n      float mq = cro(m,q.xy);\n      float nq = cro(n,q.xy);\n      float mn = cro(m,n);\n      float k1 = mq + nq;\n        \n      vec2  g = (k1+mn)*n + (k1-mn)*m;\n    //float f = -4.0*mq*nq - (mn-mq+nq)*(mn-mq+nq);\n      float f = -(mn*mn + 2.0*mn*(nq-mq)) - k1*k1;\n      vec2  z = 0.5*f*vec2(g.y,-g.x)/dot(g,g);\n    //float t = clamp( 0.5 + 0.5*cro(z-q.xy,m+n)/mn, 0.0 ,1.0 );\n      float t = clamp( 0.5 + 0.5*(cro(z,m+n)+k1)/mn, 0.0 ,1.0 );\n        \n      vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n\n      return vec2(sqrt(dot(cp,cp)+q.z*q.z), t );\n    }\n#endif\n\nfloat teaPotBody2D_SDF(in vec2 p) {\n    float d = 1e10;\n    d = min (d, sdUnevenCapsule( simX(p), vec2(0.7, -0.3), vec2(0.6, 0.35), 0.3, 0.26 ));\n    d = min(d, sdBox(p, vec2(0.6, 0.5) ) - 0.1);\n    d = min(d, sdSegment(p, vec2(-0.5,0.55), vec2(0.5, 0.55)) - 0.08);\n    d = sminCubic(d, sdUnevenCapsule( p, vec2(-0.12, 0.72), vec2(0.12, 0.70), 0.10, 0.10 ), 0.01);\n    return d; \n}\n\nfloat teaPotSDF(vec3 p) {\n    \n    vec2 handleB = sdBezier( scaleOp(p - vec3(1.4, -0.3, 0.0), 1.2), vec3(0.0), vec3(1.2, 0.9, 0.0), vec3(-0.2, 0.8, 0.0));\n    // float kh = (0.0 + handleB.y)/2.0;\n    // float ra = 0.3 - 0.28*kh + 0.2*exp(-15.0*kh);\n    float radiusHandle = 0.1 * ( cos(PI * (handleB.y + 0.5)) / 2.0 + 1.0);\n    float handle = handleB.x - radiusHandle;\n  \n    float body = teaPotBody2D_SDF(revolutionOp(scaleOp(p, 1.5), 0.0));\n    \n    vec2 frontB = sdBezier( p - vec3(-1.3, 0.0, 0.0), vec3(0.0), vec3(-0.5, 0.0, 0.0), vec3(-0.5, 0.6, 0.0));\n    float radiusFront = 0.3 - 0.2*frontB.y; //  + 0.2*exp(-15.0*frontB.y);\n    float frontbezier = frontB.x - radiusFront;\n    \n    float frontCaps = capsuleSDF(p, vec3(-1.8, 0.5, 0.0), vec3(-2.0, 0.65, 0.0), 0.11);\n    \n    vec3 planeN = normalize(vec3(-0.2, -1.0, 0.0));\n    float frontPlane = planeSDF(p, vec4(planeN, 0.25));\n    \n    float front = sminCubic(frontbezier, frontCaps, 0.4);\n    \n    front = onionOp(front, 0.02);\n    front = sSubOp(frontPlane, front, 0.01);\n    // divide by 1.5 to increase precision and fix bezier curves glitch\n    return sminCubic(sminCubic(handle, body, 0.01), front, 0.4) /1.5;\n}\n\n// ----- SDF functions ----- //\n\nfloat getDistance01(vec3 p) {\n    float d = 1e10;\n    vec4 sphere01 = vec4(0., 2., 6., 1.);\n    vec4 planeN01 = vec4(0., 1., 0., - 1.);\n    d = min( d, sphereSDF( arrayOp(p - sphere01.xyz, vec3(4.0, 4.0, 4.0), vec3(2.0, 0.0, 3.0)), sphere01.w));\n    d = min(d, planeSDF(p, planeN01));\n    \n    return d;\n}\n\nfloat getDistance(vec3 p) {\n    \n    float sinT = (sin(iTime *0.9) +1.) / 2.; // value used to periodically change objects for test purposes\n    \n    float d = 1e10;\n    vec3 boxDim = vec3(0.5, 0.5, 1.);\n    vec4 planeN01 = vec4(0., 1., 0., - 1.);\n    d = min(d, planeSDF(p, planeN01));\n    d = min(d, roundBoxSDF( p - vec3(-1.5, 0.5, 2.), boxDim, 0.05));\n    d = min(d, sphereSDF( p - vec3(0., 3., 5.), 1.));\n    d = min(d, teaPotSDF(scaleOp(p, 0.8) - vec3(0., 1., 8.)));\n    d = sminExp(d, roundBoxSDF( p - vec3(1.5, map(sinT, -0.5, 1.), 2.), boxDim, .1), 3.);\n   \n    return d;\n}\n\n// ----- RayMarching ----- //\n\nfloat rayMarching(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        float dScene = getDistance(ro + rd * d);\n        if( d > MAX_DIST || dScene < SURF_DIST*0.99) break;\n        d += dScene;\n    }\n    return d;\n}\n\n// special thanks to inigo quilez : https://www.shadertoy.com/view/lsKcDD\n// https://iquilezles.org/articles/rmshadows\nfloat softShadowsMarching(vec3 ro, vec3 rd, float dmin, float dmax) {\n    float shadowsCoeff = 1.0;\n    float d = dmin;\n    #ifdef IMPROVED_SOFT_SHADOWS\n    float previousdScene = 1e20;\n    #endif\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        float dScene = getDistance(ro + rd * d);\n        // if we are in shadows (blocked by objects) keep it in dark instead of using softShadows (help fix glitches)\n        if(dScene < SURF_DIST*0.99) return 0.0;\n\n        #ifdef IMPROVED_SOFT_SHADOWS\n        \tfloat y = (i==0) ? 0.0 : dScene*dScene/(2.0 * previousdScene);\n            float t = sqrt(dScene * dScene - y * y);\n            shadowsCoeff = min( shadowsCoeff, SOFT_SHADOWS_FACTOR*t/max(0.0, d-y) );\n        \tpreviousdScene = dScene;\n        #else\n        \tshadowsCoeff = min( shadowsCoeff, SOFT_SHADOWS_FACTOR*dScene/d);\n        #endif\n        d += dScene;\n        // if we reach max est distance of our shadowsCoeff is already dark enought break here\n        if( d > dmax || shadowsCoeff < 0.001) break;\n    }\n    \n    if( d < dmax) { shadowsCoeff = 0.0; }\n    return shadowsCoeff;\n}\n\n\n// ----- get normal using ray marching ----- //\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_DELTA, 0);\t\n    if (NORMAL_CALCULATION_TECHNIQUE == TETRAHEDRON_TECHNIQUE) {\n        const float h = NORMAL_DELTA;\n    \tconst vec2 k = vec2(1., -1.);\n        return normalize( k.xyy * getDistance( p + k.xyy*h ) + \n                          k.yyx * getDistance( p + k.yyx*h ) + \n                          k.yxy * getDistance( p + k.yxy*h ) + \n                          k.xxx * getDistance( p + k.xxx*h ) );\n    }else if (NORMAL_CALCULATION_TECHNIQUE == CENTRAL_DIFFERENCES_TECHNIQUE) {\n        return normalize(vec3( getDistance(p + e.xyy) - getDistance(p - e.xyy),\n                       \t\t   getDistance(p + e.yxy) - getDistance(p - e.yxy),\n                       \t       getDistance(p + e.yyx) - getDistance(p - e.yyx)));\n    }else {\n        float d = getDistance(p);\n        return normalize(d - vec3( getDistance(p - e.xyy),\n        \t\t\t\t\t\t   getDistance(p - e.yxy),\n        \t\t\t\t\t\t   getDistance(p - e.yyx)));\t\n\t}\n}\n\n// ----- light function ----- //\nvec3 getLight(vec3 lookPos, vec3 dir, int reflexionsCount) {\n    \n    float sinT = (sin(iTime *0.9) +1.) / 2.; // value used to periodically change objects for test purposes\n    \n    vec3 finalCol = vec3(0.0);\n    bool skyReached = false;\n    \n    vec3 p, normal, ref;\n    for(float i = 0.0; i < float(reflexionsCount) ; ++i) {// reflexion loop\n\t\t\n        vec3 col = vec3(0.0);\n    \tfloat d = rayMarching(lookPos, dir);\n\t\n        if( d < MAX_DIST) {\n            // intersected point position\n            p = lookPos + dir * d;\n            normal = getNormal(p);\n            ref = normalize(reflect(dir, normal));\n\n            // ----- sun ----- //\n            vec3 sunDir = normalize(vec3(0.8, 0.4, 0.2));\n            vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));\n            float sunIntensity = 6.; \n\n            // ----- sky ----- //\n            vec3 skyDir = vec3(0., 1., 0.);\n            vec3 skyColor = normalize(vec3(0., .1, .3));\n            float skyIntensity = 1.;\n\n            // ----- light ----- //\n            vec3 lightPos = vec3(0, 4, 6);\n            lightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.; // move light \n            vec3 lightDir = normalize(lightPos - p);\n            vec3 lightColor = vec3(0., 1., 1.);\n\n            // ----- compute diffuse ----- //\n\n            float sunDiffuse = clamp(dot(normal, sunDir), 0., 1.);\n            float skyDiffuse = clamp( 0.5 + 0.5*dot(normal, skyDir), 0., 1.);\n            float lightDiffuse = clamp(dot(normal, lightDir), 0., 1.);\n            float lightIntensity = 1. / pow(length(lightPos - p), 2.);\n\n            // ----- compute specular ----- //\n            float sunSpecular = 0.;\n            float skySpecular = 0.;\n            float lightSpecular = 0.;\n\n            #ifdef USE_SPECULAR\n                #ifdef BLINN_PHONG\n                    // Blinn-Phong\n                    // -dir = viewDir\n                    sunSpecular = pow(max(0., dot(normal, normalize(sunDir - dir))), SPECULAR_FACTOR);\n                    skySpecular = pow(max(0., dot(normal, normalize(skyDir - dir))), SPECULAR_FACTOR); \n                    lightSpecular = pow(max(0., dot(normal, normalize(lightDir - dir))), SPECULAR_FACTOR);\n                #else\n                    // Phong\n                    sunSpecular = pow(max(0., dot(sunDir, ref)), SPECULAR_FACTOR);\n                    skySpecular = pow(max(0., dot(skyDir, ref)), SPECULAR_FACTOR); \n                    lightSpecular = pow(max(0., dot(lightDir, ref)), SPECULAR_FACTOR);\n                #endif\n\n            #endif\n\n            // ----- compute shadows ----- //\n            #ifdef USE_SHADOW\n                // sun \n                sunDiffuse *= map(softShadowsMarching(p + normal*SURF_DIST, sunDir, 0., MAX_DIST), 0., 1., 1.-SHADOWS_ATTENUATION, 1.);\n                // sky\n                skyDiffuse *= map(softShadowsMarching(p + normal*SURF_DIST, skyDir, 0., MAX_DIST), 0., 1., 1.-SHADOWS_ATTENUATION, 1.);\n                // light\n                lightDiffuse *= map(softShadowsMarching(p + normal*SURF_DIST, lightDir, 0., length(lightPos - p)), 0., 1., 1.-SHADOWS_ATTENUATION, 1.);\n            #endif\n\n            vec3 mate = vec3(0.2);\n\n            col += sunIntensity*sunColor*sunDiffuse + SPECULAR_STRENGTH*sunSpecular*sunColor;\n            col += skyIntensity*skyColor*skyDiffuse + SPECULAR_STRENGTH*skySpecular*skyColor;\n            col += lightIntensity*lightColor*lightDiffuse + SPECULAR_STRENGTH*lightSpecular*lightColor;\n\n            col *= mate;\n        }else {\n            // sky\n            col += vec3(.4, .7, 1.) - 0.35 * dir.y;\n            col *= 0.9; // darken\n            col = mix(col, q01If(col), exp(-8.*dir.y)); // lighten horizon using quadratic cuve 1-(1-x)^2\n            \n            skyReached = true;   \n        }\n\t\t\n        // define new position and look direction for reflexion\n        lookPos = p + normal*SURF_DIST;\n        dir = ref;\n        // mix reflexions colors\n        if( i == 0.0) {\n            finalCol = col;\n        }else {\n            finalCol = mix(finalCol, col, REFLEXION_STRENGHT);\n        }\n        \n        if( skyReached) {\n        \tbreak; // no reflexions calculation for sky\n        }\n        \n        \n    }\n    return finalCol; // / (reflexionsCount - 1.0);\n}\n\n                                  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y; // get centered & normalized \n    \n    \n    // camera\n    vec3 cameraPosition = getValue(VALUE_POSITION).xyz + vec3(0., 1., 0.);\n    vec3 cameraRotation = getValue(VALUE_ROTATION).xyz + vec3(0., 0., 0.);\n    \n    vec3 col = vec3(0.0);\n    \n    // anti aliasing\n    #if AA > 1\n    for(float i=0.; i < float(AA); i++) {\n        for(float j=0.; j < float(AA); j++) {\n\t\t\n        vec2 deltaUV = (vec2(i, j) / float(AA) - 0.5) / iResolution.y;\n        uv.xy += deltaUV / 2.0;\n    #endif\n        \n\n    vec3 rayDirection = normalize(vec3(uv.xy, 1));\n    rayDirection = vRotateX(rayDirection, cameraRotation.x);\n    rayDirection = vRotateY(rayDirection, cameraRotation.y);\n    col += getLight(cameraPosition, rayDirection, REFLEXION_COUNT);\n            \n    #if AA > 1\n    \t}\n    }\n    col /= float(AA*AA); // anti aliasing by taking average of multiple color\n\t#endif\n\t\n    // color grading\n    col = col * vec3(1.0 ,0.9, 1.0);\n    \n    // compress \n\t// TODO\n    \n    // gamma corection\n    col = pow( col, vec3(0.4545));\n    \n    // vignetting \n    #ifdef VIGNETTING\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), VIGNETTAGE_STRENGHT);\n    #endif\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// special thanks to FabriceNeyret2 with https://www.shadertoy.com/view/llySRh\n\n// trick use channel texture in order to save camera variables throught vec4\n\n// is IS_AZERTY isn't define control are setup for QWERTY keayboards\n#define IS_AZERTY\n#define PI     3.14159265358979323846264338327\n\n// ----- Movement parameters ----- //\n#define ACCELERATION      16.0\n#define MAX_VELOCITY      8.0\n#define FRICTION          6.0\n#define MOUSE_SENSITIVITY 1.25\n\n#define REVERSE_Y_AXIS\n#define ALIGN_MOVEMENT_TO_CAMERA\n\n// define index \n#define VALUE_VELOCITY     0\n#define VALUE_POSITION     1\n#define VALUE_ROTATION     2\n#define VALUE_OLD_ROTATION 3\n\n// Retrieve a saved value on the iChannel1 buffer\nvec4 getValue(int a) { return texelFetch(iChannel1, ivec2(a, 0), 0); }\n\n// key toggles \n#define keyToggle(ascii) ( texelFetch(isqChannel0, ivec2(ascii, 2),0).x > 0.)\n#define keyDown(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1),0).x > 0.)\n#define keyClick(ascii)  ( texelFetch(iChannel0, ivec2(ascii, 0),0).x > 0.)\n\n// define used input keyCodes\nconst int ARROW_LEFT  = 37;\nconst int ARROW_UP    = 38;\nconst int ARROW_RIGHT = 39;\nconst int ARROW_DOWN  = 40;\nconst int SPACE       = 32;\nconst int SHIFT       = 16;\n\n#ifndef IS_AZERTY\n\tconst int KEY_UP    = 87;\n\tconst int KEY_LEFT  = 65;\n\tconst int KEY_DOWN  = 83;\n    const int KEY_RIGHT = 70;\n#else\n\tconst int KEY_UP    = 90;\n\tconst int KEY_LEFT  = 81;\n    const int KEY_DOWN  = 83;\n    const int KEY_RIGHT = 68;\n#endif\n\nvec3 vRotateX(vec3 v, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(v.x, c*v.y + s*v.z, -s*v.y + c*v.z);\n}\n\nvec3 vRotateY(vec3 v, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(c*v.x - s*v.z, v.y, s*v.x + c*v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // get current value on texture buffer (iChannel1)\n    int id = int(fragCoord.x - 0.5);\n    vec4 value = texelFetch(iChannel1, ivec2(id, 0), 0);\n    \n    switch(id) {\n    \tcase VALUE_VELOCITY:\n\t\t\t\n        \t// compute direction acceleration from keyboard\n            vec3 accelerationDir = vec3(0.0, 0.0, 0.0);\n\t\t\t\n            if (keyClick(ARROW_UP) || keyClick(KEY_UP)) { accelerationDir.z += 1.0; }\n        \tif (keyClick(ARROW_DOWN) || keyClick(KEY_DOWN)) { accelerationDir.z -= 1.0; }\n\n            if (keyClick(ARROW_LEFT) || keyClick(KEY_LEFT)) { accelerationDir.x -= 1.0; }\n        \tif (keyClick(ARROW_RIGHT) || keyClick(KEY_RIGHT)) { accelerationDir.x += 1.0; }\n\n            if (keyClick(SPACE)) { accelerationDir.y += 1.0; }\n        \tif (keyClick(SHIFT)) { accelerationDir.y -= 1.0; }\n\t\t\t\n        \t// normalize if needed\n        \tif (length(accelerationDir) > 0.) { accelerationDir = normalize(accelerationDir); }\n        \t\n        \t#ifdef ALIGN_MOVEMENT_TO_CAMERA\n                // align accelerationDir to camera\n                vec3 cameraRotation = getValue(VALUE_ROTATION).xyz;\n                accelerationDir = vRotateX(accelerationDir, cameraRotation.x);\n                accelerationDir = vRotateY(accelerationDir, cameraRotation.y);\n        \t#endif\n            \n        \t// apply acceleration\n        \tvalue.xyz += accelerationDir * ACCELERATION * iTimeDelta;\n        \t\n        \tfloat velocityMag = length(value.xyz);\n\t\t\t\n            if ( velocityMag > 0.0) { // if i can normalize apply friction ( velocityMag != 0)\n                value.xyz = normalize(value.xyz) * max(0.0, velocityMag - FRICTION * iTimeDelta);\n            }\n        \n        \tvelocityMag = length(value.xyz);\n            if (velocityMag > MAX_VELOCITY) { value.xyz = normalize(value.xyz) * MAX_VELOCITY; }\n\n        \tbreak;\n        \n        case VALUE_ROTATION:\n         \tif(iMouse.z > 0.) { // mouse actually move\n        \t\tvec2 dMouse = iMouse.xy - iMouse.zw;\n\t\t\t\tdMouse /= iResolution.yx; // normalize\n                #ifdef REVERSE_Y_AXIS\n                \tdMouse.y *= -1.; // reverse Y axis\n                #endif\n                vec4 oldRot = getValue(VALUE_OLD_ROTATION); // get current rotation\n                \n                value.xy = oldRot.xy - dMouse.yx * MOUSE_SENSITIVITY;\n                value.x = clamp(value.x, -PI / 2., PI / 2.);\n         \t}\n         \n        \tbreak;\n        case VALUE_POSITION:\n        \n            vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n            value.xyz += velocity * iTimeDelta;\n         \n        \tbreak;\n        case VALUE_OLD_ROTATION: \n        \tif(iMouse.z < 0.) { // mouse released\n                value = getValue(VALUE_ROTATION); // save current rotation when mouse release\n            }\n        \tbreak;\n    }\n        \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer A","description":"","type":"buffer"}]}