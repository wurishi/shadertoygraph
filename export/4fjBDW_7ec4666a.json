{"ver":"0.1","info":{"id":"4fjBDW","date":"1724936802","viewed":15,"name":"Rotating square test","username":"Papasito","description":"based on this shader:\nhttps://www.shadertoy.com/view/4fV3RD\n\nfeeding chat gpt based on the initial code, changed to get a square with centered perspective to test how much can i evolve/change a shader from an original one","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test","noob","perspective","ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to calculate the distance from a ray to a plane\nfloat DistToPlane(vec3 ro, vec3 rd, vec3 p0, vec3 n)\n{\n    // Calculate the distance from the ray origin to the plane\n    // ro: Ray origin, rd: Ray direction, p0: Point on the plane, n: Plane normal\n    return dot(p0 - ro, n) / dot(rd, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates to range [-0.5, 0.5] and adjust for aspect ratio\n    vec2 uv = fragCoord / iResolution.xy;  // Convert to normalized coordinates [0, 1]\n    uv -= .5;  // Shift to range [-0.5, 0.5]\n    uv.x *= iResolution.x / iResolution.y;  // Maintain the correct aspect ratio\n    \n    // Time variable for animation\n    float t = iTime;\n\n    // Define the camera's position, rotating around the Y-axis\n    vec3 ro = vec3(3. * sin(t), 0.0, -3. * cos(t));  // Camera rotates around the square\n    \n    // The point that the camera is looking at (the center of the square)\n    vec3 lookat = vec3(0.);  // Centered at the origin\n    \n    // Calculate the forward, right, and up vectors for the camera\n    vec3 f = normalize(lookat - ro);  // Forward direction (from the camera to the lookat point)\n    vec3 r = cross(vec3(0., 1., 0.), f);  // Right direction (perpendicular to forward and up)\n    vec3 u = cross(f, r);  // Up direction (perpendicular to forward and right)\n    \n    // Calculate the intersection point of the ray with the view plane\n    float zoom = 0.5;  // Zoom factor\n    vec3 c = ro + f * zoom;  // Position of the view plane\n    vec3 i = c + uv.x * r + uv.y * u;  // Intersection point on the view plane\n    \n    // Calculate the direction of the ray from the camera through the pixel\n    vec3 rd = normalize(i - ro);  // Ray direction\n    \n    // Define the square's plane in 3D space\n    vec3 p0 = vec3(0.0, 0.0, 0.0);  // Center of the square at the origin\n    vec3 n = vec3(0.0, 0.0, 1.0);  // Normal of the plane (facing the camera)\n    \n    // Find the intersection of the ray with the plane\n    float t_plane = DistToPlane(ro, rd, p0, n);  // Distance to the plane\n    vec3 p = ro + t_plane * rd;  // Intersection point on the plane\n    \n    // Check if the intersection point is within the square boundaries\n    // Square is defined from [-1, -1] to [1, 1] on the X and Y axes\n    float inSquare = step(-1.0, p.x) * step(p.x, 1.0) * step(-1.0, p.y) * step(p.y, 1.0);\n\n    // Set the color: white for the square, black for the background\n    fragColor = vec4(vec3(inSquare), 1.0);  // If inSquare is 1, color is white, else black\n}\n","name":"Image","description":"","type":"image"}]}