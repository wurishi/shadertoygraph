{"ver":"0.1","info":{"id":"l323z3","date":"1708708513","viewed":529,"name":"Caustics from vector map","username":"Oneleven","description":"Sample vector map in the neighborhood of each pixel, then pretend that you move these neighboring pixels according to vector map, then calculate how many of them lands in the current pixel, then normalize that value. Boom - caustics","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["caustics","vectormap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspired by this tweet by Gavin Finley aka @Velksy\n//https://twitter.com/Velksy/status/1426295504518803459\n//Substance Designer caustics setup\n\nvec4 getTexel(vec2 cord)\n{\n    return texelFetch(iChannel0, ivec2(cord), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n\n    float n = 9.;     //size of \"the neighborhood\"\n    float amp = 1.0;  //vector map multiplier  \n    \n    float p = 0.;\n    for (float i = -n; i<=n; i++)\n        for (float j = -n; j<=n; j++)\n        {\n            vec2 ofs = vec2(i,j);\n            vec2 dir = getTexel(fragCoord + ofs).xy * amp;\n            \n            float d = length(ofs + dir);\n            p += .15 / max(d*d , 1e-1); //thanks Fabrice\n        }\n    p=p/(n*n)*3.0;       \n    \n    vec3 col = vec3(p);\n    //col = getTexel(fragCoord).rgb; //debug bufferA view. rg - vector map, b - noise\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float ZOOM = 10.;\n\n//(very slighlty modified for animation)\n//3d simplex noise by nikat \n//https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat simplex3d(vec2 uv, float offset) {\n     \n     vec3 p = vec3(uv, offset); \n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/675.;  \n    float t = iTime * 1.4;\n    float f = simplex3d(uv * ZOOM, t);\n\n    //hacky derivatives because i'm lazy\n    vec2 d;\n    float eps = 1e-3;\n    d.x = simplex3d((uv + vec2(eps,0)) * ZOOM, t) - f;\n    d.y = simplex3d((uv + vec2(0,eps)) * ZOOM, t) - f;        \n    //d = vec2(dFdx(f), dFdy(f)); //hardware derivatives\n    \n    fragColor = vec4(d*675.,f, 1.0);            \n}","name":"Buffer A","description":"","type":"buffer"}]}