{"ver":"0.1","info":{"id":"NslSD7","date":"1618707395","viewed":59,"name":"KaliFractalBall","username":"bignobody","description":"Just having more fun with a previous shader.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// Remix of my previous shader: https://www.shadertoy.com/view/tsSyzW\n\n\nmat2 rotate2(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Found the original de function here: https://www.reddit.com/r/fractals/comments/5kzv7w/raymarching_a_3d_clamped_kaliset_fractal/\nfloat de(vec3 p, int it, float m, float n, float s, float c) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), m, n);\n        q *= s; //1.15;\n    }\n    return (length(q.zy) - c)/q.w;\n}\n\n// made two variations\nfloat ee(vec3 p, int it, float m, float n, float s, float c) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.zxy + 1.0) - 1.0;\n        q /= clamp(dot(q.zxy, q.zxy), m, n);\n        q *= s;\n    }\n    return (length(q.zy) - c)/q.w;\n}\n\nfloat fe(vec3 p, int it, float m, float n, float s, float c) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.yzx + 1.0) - 1.0;\n        q /= clamp(dot(q.yzx, q.yzx), m, n);\n        q *= s;\n    }\n    return (length(q.zx) - c)/q.w;\n}\n\n\n// blend of all 3 fractals\nfloat sceneDistance(vec3 p)\n{\n    \n    return max(de(p,19, 0.005, 1.0, 1.05, abs(sin(iTime))+0.2), ee(p,19, 0.005, 1.0, 1.05, abs(sin(iTime))+0.2) );\n    \n  \n}\n\nfloat n21(vec2 p)\n{\n    \n    p = fract(p * vec2(3433.321,12.123));\n    p += (dot(p,p*442.1));\n    return (fract(p.x*p.y));\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tfloat dist=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = rayOrigin + rayDirection*dist;\n        float d = sceneDistance(p);\n        dist += d;\n        if(dist>MAX_DIST || abs(d)<SURF_DIST) break;\n    }\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = sceneDistance(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        sceneDistance(p-e.xyy),\n        sceneDistance(p-e.yxy),\n        sceneDistance(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 rayCast(vec2 uv, vec3 pos, vec3 lookAt, float zoom) \n{\n    vec3 forward = normalize(lookAt-pos),\n    ray = normalize(cross(vec3(0,1,0), forward)),\n    up = cross(forward,ray),\n    center = pos+forward*zoom,\n    intersect = center + uv.x*ray + uv.y*up,\n    r = normalize(intersect-pos);\n    return r;\n}\n\nvec3 recolourNormal(vec3 n)\n{\n    return vec3(sin(n.x*n.y) * 0.18, sin(n.y*n.z) * 0.08, sin(n.z) * 0.18);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    float ambientLight = 0.7;\n\tfloat t = (iTime+0.1) * 0.04;\n \tvec3 rayOrigin = vec3(0.0, (2.2+sin(t))*cos(t), (2.2+sin(t)) * sin(t));\n    rayOrigin.yz *= rotate2(mouse.y*3.14+1.);\n    rayOrigin.xz *= rotate2(-mouse.x*6.2831);\n\n    vec3 rayDirection = rayCast(uv, rayOrigin, vec3(0,0.1,0), 0.66);\n\n    float dist = rayMarch(rayOrigin, rayDirection);\n    \n  \n\tif(dist<MAX_DIST) \n    {\n    \tvec3 p = rayOrigin + rayDirection * dist;\n    \tfloat at = smoothstep(dist, 1.0, 0.008);\n    \tvec3 dif = (recolourNormal(getNormal(p))*at);\n        dif += n21(p.xy) * (0.015 * at);\n    \tcol = dif;\n    }\n    else\n    {\n     \tcol = vec3(0.0002,0.0003,0.0006);   \n    }\n    \n\tcol = pow(col * ambientLight,vec3(0.3535));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}