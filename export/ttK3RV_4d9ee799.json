{"ver":"0.1","info":{"id":"ttK3RV","date":"1579423444","viewed":79,"name":"TempleTest","username":"antoinefortin","description":"Tempalter","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdElipsoid(vec3 pos, vec3 rad)\n{\n\tfloat k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    \n    return k0 *(k0 - 1.0) / k1;\n    \n    \n}   \n\nvec2 rotate(vec2 pos, float angle)\n{\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c) * pos;\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n    \nfloat sdSphere(vec3 pos, vec3 r)\n{\n\treturn 1.0;\n}\n\nfloat sdGuy(vec3 pos)\n{\n    float t = fract(iTime);\n\tfloat y = 4.0 * t*(1.0-t);\n    \n    vec3 cen = vec3(.0,y, .0);\n\t\n    float sy = 0.5 + 0.5 * y;\n    vec3 rad = vec3(.25,.25 * sy, .25);\n    \n    \n    return sdElipsoid(pos-cen, rad);\n    \n\n}\n\n\nfloat sdBuilding(vec3 pos)\n{\n\t// Simple building \n    vec3 qs = pos;\n    \n    vec3 buildingSize = vec3(0.25,0.55,0.25);\n    vec3 roof = vec3(0.35,0.02,0.35);\n    float cornerSide = 0.02;\n    \n    // Place the space changement to left\n    qs.x += .75;\n    \n    // Building one\n    float b1 = sdRoundBox(qs, buildingSize, cornerSide );\n    // Roof \n    qs.y -= .55;\n    float rD = sdRoundBox(qs, roof, cornerSide);\n    float res = min(b1, rD); \n    \n    return res;\n}\n    \n\nfloat temple(vec3 p)\n{\n\n    vec3 res = vec3(1.0,-1., -1.);\n\tvec3 q = p; \n    \n    q.xz = mod(q.xz + 2., 4.0) - 2.0;\n\t\n    \n    \n    \n    float rad = 0.9; // base\n    rad -= 0.05 * q.y; // thiner at top\n  \t\n    \n    \n    float verticalCurves = \n          pow((0.5 + 0.5* \n               sin(8.0 * \n               atan(q.x,q.z))), \n              2.0 /*Power*/);\n\n    float horizontalCurves =\n        pow(\n            (0.5 + 0.5 * sin(q.y * 3.0))\n            , .12) - 0.15;\n    \n    // Add vertical & horizoton curving\n    rad -= 0.1 * verticalCurves;\n\trad += 0.15 * horizontalCurves;\n        \n  \n  \n    float d = length(q.xz) - rad;\n    \n    d = min(d, sdRoundBox(q, vec3(1.5, 0.2, 1.5),0.0));\n    \n    d = max(d, p.y - 9.0);\n    \n    d = max(d, -p.y - .5);\n    \n    d *= 0.5;\n    \n    res = vec3(d, 1.0, res.z);\n    \n    return res.x; // the distance;\n    \n}\n\n\n\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n\tfloat d = temple(q);\n    \n    float building = sdBuilding(q);\n    \n    // Floor\n    float d2 = pos.y - (-0.95);\n    float ret = min(d, d2);\n    \n        \n    \n    return ret;\n}\n\n\n\n    \n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3(0.0 + iTime * 3.,4.5 + sin(iTime),12.5 + iTime * 5.);\n    vec3 rd = normalize(vec3(p, -1.5));\n\t\n    \n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 sunPosition = vec3(sin(iTime), 0.5,0.9);\n       \tvec3 sundir = normalize(sunPosition);\n     \tvec3 mate = vec3(0.18);\n        \n\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n        \n        col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n        col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n        col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}