{"ver":"0.1","info":{"id":"sdjyWc","date":"1644304803","viewed":352,"name":"sea_ground_2","username":"kinakomoti","description":"sea\n\n2/13\nby using Noise, reduce the iteration of godray\n\ngodray reference\nhttps://www.shadertoy.com/view/tt2fR3\nhttps://www.shadertoy.com/view/WsfBDf","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCHING_ITERATION 100\n#define MAX_DEPTH 100.0\n#define GODRAY_ITERATION 40\n#define VORONOI_TIME 0.5\n#define PI 3.141592\nconst vec3 LIGHT = normalize(vec3(0.2,1.0,0.0));\nconst float GODRAY_DENTISITY = 0.05;\n\n// Functions\nfloat Hash1D(vec2 uv){\n    return fract(sin(dot(uv,vec2(12.98823,85.19235)))*84252.01313);\n}\n\nvec2 Hash2D(vec2 uv){\n    vec2 st = vec2(dot(uv,vec2(134.4,314.0)),dot(uv,vec2(932.9,141.301)));\n    return -1.0 + 2.0 * fract(sin(st)*39145.295039);\n}\n\nvec2 rot2D(vec2 p,float theta){\n    mat2 rot = mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    return rot * p;\n}\n\n// Voronoi Texture -----------\n// https://thebookofshaders.com/12/\nfloat voronoi(vec2 uv,float offset){\n    vec2 i_ = floor(uv);\n    vec2 f_ = fract(uv);\n    float d = 1.0;\n    float m_dist = 100.0;\n    for(int i = -1; i <= 1; i++){\n        for(int j = -1; j <=1; j++){\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = Hash2D(i_ + neighbor);\n            point = 0.5 + 0.5 * sin(6.423 * point + offset);\n            // point = 0.5 + 0.5 *sin(6.323 * point);\n            vec2 diff = neighbor + point - f_;\n\n            float dist = length(diff);\n            m_dist = min(m_dist,dist);\n        }\n    }\n\n    return m_dist;\n}\n\n//refer to https://thebookofshaders.com/11/\nfloat value_noise(vec2 uv){\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float a = Hash1D(i);\n    float b = Hash1D(i + vec2(1.0,0.0));\n    float c = Hash1D(i + vec2(0.0,1.0));\n    float d = Hash1D(i + vec2(1.0,1.0));\n\n    //smooth Interpolate\n\n    //Cubic Hermine Curve. \n    //エルミート補完でsmoothstepの二次元版と思われる。エルミート補完はエルミート多項式も関係するらしい https://qiita.com/Pctg-x8/items/47127a770b23b8934fff \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a,b,u.x)+ (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlin_noise(vec2 uv){\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 a = Hash2D(i);\n    vec2 b = Hash2D(i + vec2(1.,0.));\n    vec2 c = Hash2D(i+ vec2(0.,1.));\n    vec2 d = Hash2D(i + vec2(1.,1.));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    //補完をグラディエントを考えて行うらしい\n    return mix(\n        mix(dot(a,f),dot(b,f-vec2(1.,0.)),u.x),\n        mix(dot(c,f-vec2(0.,1.)),dot(d,f-vec2(1.,1.)),u.x),\n        u.y\n    ) * 0.5 + 0.5;\n}\n\n#define OCTAVES 6\nfloat fbm(vec2 uv){\n    float value = 0.0;\n    //振幅\n    float amplitude = 0.5;\n    float frequency = 0.0;\n\n    for(int i = 0; i < OCTAVES; i++){\n        value += amplitude * value_noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    return value;\n}\n\nvec3 texture2d(vec2 uv){\n   return voronoi(uv,iTime * VORONOI_TIME) * vec3(1.0); \n}\n\n// Ray struct-----------------\nstruct IntersectInfo{\n    float d;\n    vec3 normal;\n    bool hit;\n    vec3 diffuse;\n    float iteration;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\n// BSDF------------\nvec3 diffuse(vec3 color,vec3 l,vec3 n){\n    return dot(l,n) * color;\n}\n\n// SDF-------------\nfloat sd_sphere(vec3 p){\n    return length(p) - 1.0;\n}\nfloat sd_Box(vec3 p,vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat map(vec3 p){\n    // p.xz = mod(p.xz,4.0) - 2.0;\n    // return sd_sphere(p);\n    float d = p.y - 0.5 * fbm(p.xz);\n    vec3 p1 = p;\n    p.xz = mod(p.xz,4.0) - 2.0;\n    float index = Hash1D(floor(p1.xz / 4.0));\n    if(Hash1D(vec2(index)) > 0.8){\n    p.xz = rot2D(p.xz, index * PI);\n    p.xy = rot2D(p.xy,index * PI);\n    d = min(d,sd_Box(p,vec3(1.0,1.0,1.0)));\n    }\n    return d - 0.001;\n}\n\nvec3 getNormal(vec3 pos){\n    float ep = 0.0001;\n    return normalize(\n        vec3(\n            map(pos) - map(pos - vec3(ep,0.0,0.0)),\n            map(pos) - map(pos - vec3(0.0,ep,0.0)),\n            map(pos) - map(pos - vec3(0.0,0.0,ep))\n        )\n    );\n}\n\nIntersectInfo ray_Marching(Ray ray){\n    IntersectInfo info;\n    info.d = MAX_DEPTH; \n    info.hit = false;\n    float d;\n    float totald;\n    for(int i = 0; i < MARCHING_ITERATION; i++){\n        d = map(ray.origin + totald * ray.direction);\n        if(d < 0.001){\n            info.d = totald;\n            info.normal = getNormal(ray.origin + totald * ray.direction);\n            info.hit = true;\n            info.diffuse = vec3(1.0);\n            info.iteration = float(i);\n            return info;\n        }\n        totald += d;\n    }\n    info.iteration = float(MARCHING_ITERATION);\n    return info;\n}\n\nvec3 scene_Color(vec3 rayPos,vec3 rayDir,inout float dist){\n    Ray ray;\n    ray.origin = rayPos;\n    ray.direction = rayDir;\n    IntersectInfo info = ray_Marching(ray);\n    if(info.hit){\n        dist = info.d;\n        vec3 n = info.normal;\n        vec3 position = rayPos + dist * rayDir;\n        vec3 voro = texture2d(position.xz * 0.5);\n        vec3 diff = diffuse(info.diffuse,LIGHT,n);  \n        float fog1 = min(1.0,(1.0 / float(MARCHING_ITERATION))) * info.iteration * 3.0;\n        return vec3(0.3) * diff + pow(voro,vec3(5.0)) * vec3(0.8,0.8,1.0) + vec3(0.15,0.15,0.2) * fog1 *fog1 * 0.6;    \n    }\n    dist = info.d;\n    return vec3(0.0);\n}\n\n// God Ray ----------------\n// refer to https://www.shadertoy.com/view/tt2fR3\n// refer to https://qiita.com/edo_m18/items/14f62a89c50a64b62891\n#define GODRAY_LIMIT 10.0\nIntersectInfo causticsHit(Ray ray){\n    IntersectInfo info;\n    ray.direction *= -1.0;\n    vec3 n = vec3(0.0,1.0,0.0);\n    float t = - dot(ray.origin,n) / dot(ray.direction,n);\n    vec3 pos = ray.origin + t * ray.direction;\n    vec3 voro = texture2d(pos.xz);\n    info.hit = voro.x * voro.x < 0.6;\n    return info;\n}\n\nvec3 godRay(vec3 rayPos,vec3 rayDir,vec2 uv,float dist,vec3 sceneColor){\n    float fogLitPercent = 0.0;\n    if(dist > GODRAY_LIMIT) dist = GODRAY_LIMIT; \n    //From Shane's comment. I appeciate Shane.\n    //初期位置にノイズを加えることでゴッドレイのアーティファクトがノイズに従ってぼかしのような効果が出る（多分）\n    //rayPos += Hash1D(uv) * rayDir;\n    rayPos += rayDir * Hash1D(vec2(dot(rayPos,vec3(1.0)),dot(rayDir,vec3(1.0))));\n    \n    // using BlueNoise https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n    // refer to https://www.shadertoy.com/view/WsfBDf\n    //rayPos += fract(texture(iChannel0,uv).r + float(iFrame)) * rayDir;\n    for(int i = 0; i < GODRAY_ITERATION; i++){\n        vec3 testPos = rayPos + rayDir * dist * (float(i) / float(GODRAY_ITERATION));\n        Ray shadowRay;\n        shadowRay.origin = testPos;\n        shadowRay.direction = LIGHT;\n        IntersectInfo info = causticsHit(shadowRay); \n        fogLitPercent = mix(fogLitPercent,(!info.hit)? 1.0 : 0.0,1.0 / float(i+1)) ;\n    }\n    // if(dist == 10.0) dist = MAX_DEPTH;\n    vec3 fogColor = mix(vec3(0.2,0.2,0.4),vec3(0.8,0.8,1.4) * 2.0,fogLitPercent);\n    float absorb = exp(-dist * GODRAY_DENTISITY);\n    return mix(fogColor,sceneColor,absorb);\n}\n\n// Fog----------\n#define FOG_DENTISITY 0.05\nconst vec3 FOG_COLOR = vec3(0.1,0.1,0.3);\nvec3 fog(vec3 color,float dist){\n    return mix(FOG_COLOR,color,exp(-dist * FOG_DENTISITY));\n}\n// Camera Direction -----------------\nvec3 camera_Direction(vec3 camDir,vec2 uv,float f){\n    vec3 camSide = cross(camDir,vec3(0,1,0));\n    vec3 camUp = cross(camSide,camDir);\n    vec3 imageDir = normalize(camUp * uv.y + camSide * uv.x + camDir * f);\n    return imageDir;\n}\n\nvec3 RGBconvert(vec3 col){\n    return pow(col,vec3(1.2)) -vec3(0.2,0.0,0.0);\n}\n// Main Function ---------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n\n   vec3 camPos = vec3(0,2.0,3.0 + iTime);\n    // vec3 camPos = vec3(0,2.0,3.0);\n    vec3 camDir = vec3(sin(iTime * 0.1),0,cos(iTime * 0.1));\n\n    vec3 rayPos = camPos;\n    vec3 rayDir = camera_Direction(camDir,uv,2.0);\n    float dist = 0.0;\n    color = scene_Color(rayPos,rayDir,dist);\n    color = fog(color,dist);\n    color = godRay(rayPos,rayDir,uv,dist,color);\n    color = RGBconvert(color);\n    fragColor = vec4(color,0.0);\n}\n\n","name":"Image","description":"","type":"image"}]}