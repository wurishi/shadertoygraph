{"ver":"0.1","info":{"id":"lt3BRs","date":"1540822600","viewed":135,"name":"Cemetery ","username":"tqle","description":"Environment, halls of Vahalla. Tribute to Vikings","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n//construct Shape class\nstruct Shape {\n  float dist;\n  vec4 color;\n};\n//repeating variables, coordinates, shapes. Replaces repeat()\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}       \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}       \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n//rotating shapes using matrix/linear algebra\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n//creates a pole\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n//creates a sphere\nfloat sphere(vec3 v, float r){\n  return length(v) - r;\n}\n//creates a box\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//creats a ring\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n//unionizes shapes, making stairs from intersection\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b - r;\n\treturn min(min(a,b), 0.5*(u + a + abs((mod(u - a + s, 2.*s)) - s)));\n}\n//\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat mixColors(float r, float v, float z) {\n  return clamp(0.5 + 0.5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n  float z = mixColors(v, f, r);\n  return mix(f, v, z) - r*z*(1. - z);\n}\nfloat pModPolar(inout vec2 v, float r) {\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x) + f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f) - f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nfloat opTwist(vec3 p) {\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return float(q);\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec3 mod289(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }\nvec2 mod289(vec2 x) { return x - floor(x*(1.0 / 289.0))*289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0) + 1.0)*x); }\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0*fract(p*C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314*(a0*a0 + h*h);\n    vec3 g;\n    g.x  = a0.x*x0.x + h.x*x0.y;\n    g.yz = a0.yz*x12.xz + h.yz*x12.yw;\n    return 130.0*dot(m, g);\n}\nShape animation(vec3 c){\n  Shape shape; \n  vec4 color = vec4(1.134, .25, .25, 1.);  \n  //INSTANTIATING, MODDING VECS\n  vec3 lan = c;\n    lan.z = repeat(lan.z, 5.);\n    lan.x = repeat(lan.x, 4.);\n    lan.x = abs(lan.x) - .75;\n  //EVALUATING VECS\n  vec3 hal = c;\n\tpMod1(hal.z, 10.);\n  vec3 bod = c;\n    pMod1(bod.z, 10.);\n  vec3 or = c;\n    pMod1(or.z, 10.);\n  vec3 ortwo = c;\n    pMod1(ortwo.z, 10.);\n  vec3 fr = c;\n    pMod1(fr.z, 15.);\n  vec3 doo = c;\n    pMod1(doo.z, 15.);\n  vec3 dootwo = c;\n    pMod1(dootwo.z, 15.);\n  float lantern = sdCappedCylinder(lan - vec3(.5*cos(iTime)*sin(iTime), .5*sin(iTime), 0.), vec2(.1, .09));\n  float halo = sdTorus(hal - vec3(0., 2., 0.), vec2(.25, .01));\n  float body = fCone(bod - vec3(0., -.5, 0.), .1, 3.);\n  float orb = sphere(or - vec3(.025 + sin(iTime), 2.75 - cos(iTime), 0. + sin(iTime)*2.), .1);\n  float orbtwo = sphere(or - vec3(-0.025 + cos(iTime), 0. - sin(iTime), 0. + sin(iTime)*2.), .1);\n  float frame = fBox(fr - vec3(1., 0., 0.), vec3(.25, .5, .1));\n  float door = fBox(doo - vec3(1., 0., 0.), vec3(.2, .45, .1));\n  float doortwo = fBox(doo - vec3(1., 0., 0.), vec3(.15, .4, .1));\n  \t\n  \n  //MIXING SHAPES\n  shape.dist = lantern;\n  shape.dist = min(shape.dist, halo); \n  shape.dist = min(shape.dist, body);\n  //shape.dist = fOpUnionStairs(shape.dist, orb, .1, 3.);\n  shape.dist = min(shape.dist, orb);\n  //shape.dist = fOpDifferenceStairs(shape.dist, orbtwo, .1, 5.);\n  shape.dist = min(shape.dist, orbtwo);\n  shape.dist = fOpUnionStairs(shape.dist, frame, .1, 2.);\n  shape.dist = fOpDifferenceStairs(shape.dist, door, .1, 2.);\n  shape.dist = fOpDifferenceStairs(shape.dist, doortwo, .1, 2.);\n  //INSTANTIATING, MODDING COLORS\n  vec4 lanCol = vec4(sin(iTime), 10.*lan.x*cos(iTime), 0., 1.);\n    \n  vec4 bodCol = vec4(1., 1., 1. + cos(iTime)*.5, 1.);\n  vec4 halCol = bodCol;\n  vec4 orCol = vec4(1. * cos(iTime)*10., 24./255., 1./255., 1.);\n  vec4 orTwoCol = orCol;\n  vec4 frCol = vec4(fr.x + sin(iTime) + 244./255., fr.y*cos(iTime) - 10./255., cos(fr.y*fr.x*iTime) + 1./255., 1.);\n  //shape.color = lanCol;\n  shape.color = mix(lanCol, bodCol, mixColors(body, lantern, 0.));\n  shape.color = mix(shape.color, orCol, mixColors(orb, shape.dist, 1.));\n  shape.color = mix(shape.color, orTwoCol, mixColors(orbtwo, shape.dist, 1.));\n  shape.color = mix(shape.color, frCol, mixColors(frame, shape.dist, 1.));\n    lanCol.rg += snoise(lan.xy*.1) + .5*sin(iTime);\n    lanCol.gb -= snoise(lan.yz*.25) + cos(iTime);\n  //MIXING COLORS\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape anim = animation(c);\n  return anim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 cam = vec3(1., .75, iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); \n    if(c.dist < 0.001){\n      fragColor = c.color*(1. - z); \n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}