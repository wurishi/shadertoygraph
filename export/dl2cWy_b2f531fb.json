{"ver":"0.1","info":{"id":"dl2cWy","date":"1692253990","viewed":92,"name":"chrome-plated  cube","username":"Efim","description":"this solution calculate reflection from plane. solution  using standard function GLSL reflect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n\nstruct HIT\n{\n    float dist;\n    vec3 col;\n    vec3 pos;\n};\n\nconst float dist_infin = 1000.0;\n\nvec3 culccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    //nor *= -sign(d); sign(d)*\n    nor *= -sign(d);\n    float difu = dot(nor, light);\n    col *= clamp(difu, 0.05, 1.0);\n    return col;   \n}\n\nHIT planeX(vec3 ro, vec3 rd, float h, float w)\n{\n    vec3 col = vec3(0.0);\n    vec3 p = vec3(0.0);\n\n    float dist = dist_infin;\n    float t = -(ro.x)/rd.x;\n    if (t >= 0.0)\n\t\treturn HIT(dist, col, p);\n\n    p = ro + rd*t;\n    if (p.z < -w || p.y < -h || p.z > w  || p.y > h)\n        return HIT(dist, col, p);  \n\n    dist = length(p - ro);\n    return HIT(dist, col, p);      \n}\n\n\nHIT planeY(vec3 ro, vec3 rd, float h, float w)\n{\n    vec3 col = vec3(0.0);\n    vec3 p = vec3(0.0);\n\n    float dist = dist_infin;\n    float t = -(ro.y)/rd.y;\n    if (t >= 0.0)\n\t\treturn HIT(dist, col, p);\n\n    p = ro + rd*t;\n    if (p.x < -w || p.z < -h || p.x > w  || p.z > h)\n        return HIT(dist, col, p);  \n\n    dist = length(p - ro);\n    return HIT(dist, col, p);      \n}\n\n\n\n\n\nHIT planeW(vec3 ro, vec3 rd, float h, float w)\n{\n    vec3 col = vec3(0.0);\n    vec3 p = vec3(0.0);\n\n    float dist = dist_infin;\n    float t = -(ro.z)/rd.z;\n    if (t >= 0.0)\n\t\treturn HIT(dist, col, p);\n\n    p = ro + rd*t;\n    if (p.x < -w || p.y < -h || p.x > w  || p.y > h)\n        return HIT(dist, col, p);  \n\n    dist = length(p - ro);\n    return HIT(dist, col, p);      \n}\n\nHIT cube3D(vec3 ro, vec3 rd)\n{\n    \n    vec3 rnor = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    vec3 p = vec3(0.0);\n    float dist = dist_infin;\n    float h = 4.0;\n    \n\n    nor = vec3(0.0, 0.0, -1.0);\n    HIT plan = planeW(ro - nor*h, rd,  h, h);\n    if (plan.dist < dist)\n    {\n        dist = plan.dist;\n        p = plan.pos;\n        rnor = nor;\n    }\n    \n    nor = vec3(0.0, 0.0, 1.0);\n    plan = planeW(ro - nor*h, rd, h, h);\n    if (plan.dist < dist)\n    {\n        dist = plan.dist;\n        p = plan.pos;\n        rnor = nor;\n    }\n\n    nor = vec3(-1.0, 0.0, 0.0);\n    plan = planeX(ro - nor*h, rd, h, h);\n    if (plan.dist < dist)\n    {\n        dist = plan.dist;\n        p = plan.pos;\n        rnor = nor;\n    }\n\n    nor = vec3(1.0, 0.0, 0.0);\n    plan = planeX(ro - nor*h, rd, h, h);\n    if (plan.dist < dist)\n    {\n        dist = plan.dist;\n        p = plan.pos;\n        rnor = nor;\n    }\n\n    nor = vec3(0.0, -1.0, 0.0);\n    plan = planeY(ro - nor*h, rd,  h, h);\n    if (plan.dist < dist)\n    {\n        dist = plan.dist;\n        p = plan.pos;\n        rnor = nor;\n    }\n    \n    \n    nor = vec3(0.0, 1.0, 0.0);\n    plan = planeY(ro - nor*h, rd,  h, h);\n    if (plan.dist < dist)\n    {\n        dist = plan.dist;\n        p = plan.pos;\n        rnor = nor;\n    }\n    \n    return HIT(dist, rnor, p);      \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime*0.2;\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, 25.0); // camera\t\n    const float fl = 2.5; // focal length\n\n    vec3 rd = normalize( vec3(p,fl) ); // ray direction\n    mat3 sky = rotateY(t);\n    \n    vec3 col = texture(iChannel0, (sky*rd)).rgb;  //get color from texture\n    //vec3 col = vec3(0.7, 0.7, 0.9); // background\n    \n    float dist = dist_infin;\n\n    \n    mat3 rotaCub  = rotateZ(PI/3.0+t)*rotateX(PI/2.0*3.0/4.0+t)*rotateY(t);\n    mat3 rotaCub_1  = rotateY(-t)*rotateX(-PI/2.0*3.0/4.0-t)*rotateZ(-PI/3.0-t);\n    \n    HIT cube = cube3D(rotaCub*(ro), rotaCub*rd);\n    if (cube.dist < dist)\n    {\n        dist = cube.dist;\n        vec3 nor = cube.col;\n        nor = rotaCub_1*nor;\n        vec3 rd_r = reflect(rd, nor);\n        col = texture(iChannel0, rd_r).rgb;  //get color from texture\n    }\n    \n       \n    fragColor = vec4(col,1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}