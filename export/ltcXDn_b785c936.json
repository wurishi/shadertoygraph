{"ver":"0.1","info":{"id":"ltcXDn","date":"1478943792","viewed":254,"name":"GlowPipe","username":"Unix","description":"Glowing pipe","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["glow","pipe","unix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Unix 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n\nfloat marchCount;\n\nfloat cylinder( vec3 p )\n{\n    return length( p.xy ) - 0.9;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float a = -0.1 * sin(iTime) - 0.03 * p.z * sin(p.x+iTime/100.);\n    float b = -0.1 * iTime - 0.02 * p.z;\n    float c = cos( a );\n    float s = sin( a );\n    mat2 m = mat2( c, -s, s, c );\n    return vec3( m * p.xy, p.z );\n}\n\nvec2 opRep( vec2 p, float size, float start, float stop )\n{\n    float halfSize = size * 0.5;\n    vec2 c = floor( p / size );\n    p = mod( p, size ) - halfSize;    \n    return p;\n}\n\nfloat map( vec3 p )\n{\n    p = opTwist( p );\n    //p.xy = opRep( p.xy, 10.0, -7.0, 7.0 );\n    p.xy = opRep( p.xy, 3.0, -7.0, 7.0 );\n    float d = cylinder( p );\n    return d;\n}\n\nfloat scene( vec3 ro, vec3 rd )\n{\n    float t = 0.01;\n    marchCount = 0.0;\n    for ( int i = 0; i < 150; i++ )\n    {\n        vec3 p = ro + t * rd;\n        float d = map( p );\n        if ( d < 0.001 )\n        {\n            return t;\n        }\n        t += d;\n        marchCount+= 1.0/d*0.1;\n    }\n    return -1.0;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    float pd = map( pos );\n    vec3 n = vec3(\n            pd - map( pos - eps.xyy ),\n            pd - map( pos - eps.yxy ),\n            pd - map( pos - eps.yyx ) );\n    return normalize( n );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float occ = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float hp = 0.1 + 2.0 * float( i );\n        float dp = map( pos + n * hp );\n        occ += ( hp - dp );\n    }\n    return clamp( 1.0 - 0.04 * occ, 0.0, 1.0 );\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    float d = scene( ro, rd );\n    vec3 col = vec3( 0 );\n    if ( d > 0.0 )\n    {\n        vec3 pos = ro + d * rd;\n        vec3 twistPos = opTwist( pos );\n        float t = -5.0 * iTime;\n        col = vec3( floor( 0.2 * mod( twistPos.z + t, 6.0 ) ) );\n        vec3 nor = calcNormal( pos );\n        float ao = calcAo( pos, nor );\n        col *= vec3( ao );\n        float fog = ( 400.0 + pos.z ) / 300.0;\n        col *= fog;\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3( 0.0, 0.0, 20.0 );\n    vec3 target = vec3( 0.0 );\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n\n    vec3 col = vec3( 0.0 );\n    \n    for ( int i = 0; i < 10; i++ )\n    {\n        vec2 off = vec2( mod( float( i ), 2.0 ), mod( float( i / 2 ), 2.0 ) ) / 2.0;\n        vec2 uv = ( fragCoord.xy + off - 0.5 * iResolution.xy ) / iResolution.y;\n        vec3 rd = cm * normalize( vec3( uv, 2.5 ) );\n        col += render( eye, rd );\n    }\n    col *= 0.15;\n\t// This is the glow\n    col += marchCount * vec3(0.2, 1.0, 0.41) * 0.0005;\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}