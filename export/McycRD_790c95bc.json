{"ver":"0.1","info":{"id":"McycRD","date":"1731659335","viewed":163,"name":"Hex moire 3d","username":"ChunderFPV","description":"You'll have to wait or advance the time a bit to start seeing the moire effects.","likes":15,"published":1,"flags":32,"usePreview":1,"tags":["raymarch","moire","psychedelic","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Xor's FXAA implementation: https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n// does a better job with the jaggies than the cheap TAA I was using previously\n\n#define R iResolution\n\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz)\n{\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 q = U/R.xy;\n    C = fxaa(iChannel0, q, sqrt(2.)/R.xy);\n    //C = texture(iChannel0, q);  // no AA\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T (.0 + iTime/60.)  // start time & speed\n#define H(v) (cos(((v)+.5)*6.2832 + radians(vec3(0, 60, 120)))*.5+.5)  // hue\n\nfloat pattern(vec2 p)\n{\n    float x = p.x, y = p.y;\n    return sqrt(x*x + y*y);\n    // for another cool pattern: try removing the sqrt from this, set time/1e3\n}\n\nmat2 A(float v)  // rotate\n{\n    float c = cos(v*3.1416),\n          s = sin(v*3.1416);\n    return mat2(c, s, -s, c);\n}\n\n// from iq: https://www.shadertoy.com/view/Mt3BDj\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 k = vec3(-.866, .5, .577);\n    p.xy = abs(p.yx);\n    p.xy -= 2.*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n        length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y-h.x), \n        max(-p.z-h.y, 0.));\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// used below\n#define Q(id, s) g = id + vec2(i%2, i/2)*s; \\\n                 z = cos(pattern(g*o)*t)*.5+.5; \\\n                 w = dot(g*o, g*o)*.003; \\\n                 d = min(d, sdHexPrism(p - vec3(o*g, -z -w), vec2(.43, 0))-.05); \\\n                 d = min(d, length(p - vec3(o*g, -z -w))-.15);\n\n// domain repetition: https://iquilezles.org/articles/sdfrepetition/\n// modified for hex tiles\nfloat map(vec3 p)\n{\n    float t = T*6.2832,\n          d = 1e20, z, w;\n    \n    vec2 o = vec2(1, 1.732),\n         id1 = round(p.xy/o),\n         id2 = round(p.xy/o+.5)-.5,\n         s1 = sign(p.xy-id1*o),\n         s2 = sign(p.xy-id2*o),\n         id, s, g;\n    \n    for (int i=0; i<4; i++)\n    {\n        Q(id1, s1)\n        Q(id2, s2)\n    }\n    return d;\n}\n\nvec3 norm(vec3 p)\n{\n    float h = 0.002;\n    vec2 k = vec2(1, -1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\n// quick 2d hex coords by Fabrice\nvec2 hex(vec2 u)\n{\n    vec2 o = vec2(.5, .866),\n         a = mod(u,   o+o)-o,\n         b = mod(u-o, o+o)-o;\n    return dot(a,a) < dot(b,b) ? a : b;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float i = 0., d = i, s, z, l, n;\n    \n    vec2 R = iResolution.xy,\n         m = iMouse.z > 0. ?  // clicking\n               (iMouse.xy - R/2.)/R.y:              // coords from mouse\n               cos(1.5 + iTime/5.-vec2(0, 1.5708))*.4-.1,  // from time\n               h;\n    \n    vec3 o = vec3(0, 0, -35./(m.y+1.5)),      // camera\n         u = normalize(vec3(U - R/2., R.y)),  // coords\n         c = vec3(0), p, t, b, k;\n    \n    mat2 rh = A(m.x/2.),  // rotate horizontal\n         rv = A((m.y+.5)/2.);    // vertical\n    \n    for (; i++<50.;)  // raymarch\n    {\n        p = u*d + o;\n        p.yz *= rv;\n        p.xy *= rh;\n        s = map(p);  // sdf\n        c += min(s, .02/s);  // object mask\n        if (s < 1e-2 || d > 1e3) break;\n        d += s*.7;\n    }\n    \n    b = exp(log(1.-c)*.99) * (cos(log(c)*6.3-1.)-.5); // metallic sheen\n    b = clamp(b*b, .001, 1e3/dot(p.xy, p.xy));        // clamp\n    l = dot(norm(p), normalize(vec3(0, 0, -1e2)-p));  // light\n    h = hex(p.xy);                                    // 2d hex coords\n    n = pattern(p.xy-h);                              // movement pattern\n    z = cos(n*T*6.2832)*.5+.5;                        // used for color & shading\n    k = H(.5-n*T);                                    // color gradient\n    t = texture(iChannel0, p.xy*A(n)).rgb;            // texture\n    \n    c *= 0.;                                // reset c\n    c += max(l * t * z, .05);               // light, texture, shade\n    c += c * pow(max(l, 0.), 1e2) * 1.5;    // bright spot\n    c -= b * (z+.2);                        // sheen\n    c -= k.bgr * .4 * c;                    // color\n    c = max( c*c,                           // contrast & flip -\n             round(min(.1/length(h), 1.)*z  // 2d lights\n             * (k*.5+.5) * .9));            // color\n    \n    C = vec4(exp(log(c)/2.2), 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}