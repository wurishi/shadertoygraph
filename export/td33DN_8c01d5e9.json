{"ver":"0.1","info":{"id":"td33DN","date":"1568567038","viewed":108,"name":"Hyperboloid SDf (bound)","username":"Blake447","description":"Demonstration for a hyperboloid SDF. Uses a combination of a chord technique on the outside, and a tangent on the inside. Unfortunately not exact, but converges pretty quickly and is relatively cheap.  Comments are left over from julia set raymarcher.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","hyperboloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Convert degrees to radians\nfloat Radians(float deg)\n{\n \treturn deg / 360.0 * 2.0 * 3.14159; \n}\n\n// Do a safe absolute value function for edge cases\nfloat safeAbs(float x)\n{\n\tif (x == 0.0)\n\t{\n\t\treturn 0.0;\n\t}\n\treturn abs(x);\n\n}\n\n// Write a float4 function for some of the HLSL Code conversion\nvec4 float4(float x, float y, float z, float w)\n{\n \treturn vec4(x,y,z,w);   \n}\n\n// Write a float3 function for the same purpose\nvec3 float3(float x, float y, float z)\n{\n \treturn vec3(x,y,z);   \n}\n\n// And a float2\nvec2 float2(float x, float y)\n{\n \treturn vec2(x, y);   \n}\n\n// A method for the intersection of two lines (in 2 dimensions)\nvec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb)\n{\n\tfloat buffer = (sa*A.x - A.y - sb * B.x + B.y) / (sa - sb);\n\tvec2 intersection = float2(buffer, sa*(buffer - A.x) + A.y);\n\treturn intersection;\n}\n\n// Exact intersection of a sphere. Resolves a quatratic equation. Returns the \n// min distance, max distance, and discriminant to determine if the intersections\n// actually exist.\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)\n{\n\t// Derivation for formula:\n\t//\t\tLet the ray be represented as a point P plus a scalar multiple t of the direction vector v,\n\t//\t\tThe ray can then be expressed as P + vt\n\t//\n\t//\t\tThe point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r\n\t//\t\tfrom the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r\n\t//\n\t//\t\tIt therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,\n\t//\t\t(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of\n\t//\t\tintersection\n\n\t// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.\n\tfloat a = dot(dir_vector, dir_vector);\n\tfloat b = 2.0 * dot(pos_vector, dir_vector);\n\tfloat c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;\n\n\t// to avoid imaginary number, we will find the absolute value of the discriminant.\n\tfloat discriminant = b * b - 4.0 * a*c;\n\tfloat abs_discriminant = abs(discriminant);\n\tfloat min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);\n\tfloat max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);\n\n    // return the two intersections, along with the discriminant to determine if\n    // the intersections actually exist.\n\treturn float3(min_dist, max_dist, discriminant);\n\n}\n\n// Exact SDF for a sphere\nfloat dSphere(vec3 pos, vec3 center, float radius)\n{\n    // find the distance to the center\n    vec3 v = pos - center;\n    \n    // return that, minus the radius\n    return length(v) - radius;\n}\n\n// Bound SDF (not just DE) for the hyperboloid as a rotation of a 2D hyperbola.\n// When outside the hyperbola, it constructs a chord from the  point on the hyperbola\n// with the raymarched point's x coordinate, the point sharing its y coordinate,\n// and finds the minimum distance to that line.\n\n// When inside the hyperboloid, it evaluates the tangent line at the raymarched points x\n// coordinate (clamped at a lower bound of 1) and calculates the minimum distance to that\nfloat hyperboloid(vec3 Point, vec3 Center)\n{\n\t\t\t\t// Transform into polar coordinates\n\t\t\t\tfloat k = sqrt(dot(Point.xz - Center.xz, Point.xz - Center.xz));\n\t\t\t\tfloat h = safeAbs((Point.y-Center.y));\n\n\t\t\t\t// Calculate point A\n\t\t\t\tvec2 A = float2(h, k);\n\n\t\t\t\t// Calculate the point on the curve at h\n\t\t\t\tvec2 r_of_h = float2(h, sqrt(h*h+1.0));\n\n\t\t\t\t// Calculate the slope of the curve at h. differentiating y = sqrt(x^2 + 1) gives x / sqrt((x^2 + 1))\n\t\t\t\tfloat t_of_h = h / r_of_h.y;\n\n\t\t\t\t// Calculate the slope of the normal of tangent line through (h,k)\n\t\t\t\tfloat n_of_h = -1.0 / t_of_h;\n\n\t\t\t\t// Calculate the intersection of the line normal to the tangent through (h,k) and the tangent line itself through (h, f(h))\n\t\t\t\tvec2 t_int_n = intersectionOfTwoLines(r_of_h, t_of_h, A, n_of_h);\n\n\t\t\t\t// Calculate the points for the chord line\n\t\t\t\tvec2 P = r_of_h;\n\t\t\t\tvec2 Q = float2(sqrt(k*k-1.0), k);\n\n\t\t\t\t// Calculate the slope oof the chord line and its normal\n\t\t\t\tfloat s_of_P2Q = (P.y - Q.y) / (P.x - Q.x);\n\t\t\t\tfloat n_of_P2Q = -1.0 / s_of_P2Q;\n\n\t\t\t\t\n\t\t\t\t// intersect the chord line with the normal line that goes through our point in question\n\t\t\t\tvec2 R = intersectionOfTwoLines(P, s_of_P2Q, A, n_of_P2Q);\n\n\t\t\t\t// calculate the distance from the point in question to the tangent line\n\t\t\t\tfloat dist = distance(A, t_int_n);\n\n\t\t\t\t// If we are above the paraboloid\n\t\t\t\tif (k > r_of_h.y)\n\t\t\t\t{\n\t\t\t\t\t// calculate the minimum distance to the chord line instead\n\t\t\t\t\tdist = -distance(A, R);\n\t\t\t\t}\n\n\t\t\t\t// Return the distance\n\t\t\t\treturn -dist;\n}\n\n// Distance estimation for the scene\nfloat DE(vec3 p, vec3 c)\n{\n\tfloat d1 = hyperboloid(p * vec3(1.0, -1.0, 1.0), c);   \n\tfloat d2 = (-abs(p.y)-c.y) + 1.0;\n    \n    float d = max(d1, -d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the iterations for the marcher.\n    const int ITERATIONS = 60;\n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the start angle for the rotation (in degrees)\n    const float START_ANGLE = 0.0;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 4.0;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.001;\n    \n    // Define if we should invert the color at the end\n    const bool HIDE_BACKGROUND = true;\n\n    // Define the center of the SDF\n    vec3 sdf_center = vec3(0.0, 0.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    float phi = Radians(START_ANGLE);\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    // Initialize the ray marched point p\n    vec3 p = cam_pos;\n\n\n\t// Initialize the distance\n    float dist = 1.0;\n    \n    // Calculate the exact distance from a sphere of radius 2 using a raytracing function\n    vec3 init_distance = intersections_of_sphere(p - sdf_center, ray, 4.0);\n    \n    // If we are outside a bubble around the raymarched fractal\n    if (init_distance.z > 0.0)\n    {\n        // Step onto the sphere so we start off a bit closer.\n    \tp += ray * clamp(init_distance.x, 0.0, init_distance.x);\n    }\n\n    // declare a dummy variable to store the number of iterations into.\n    // I'm doing it this way because on my phone it didnt let me use an\n    // already declared variable as the loop iterator.\n    int j;\n    \n    \n\t// Begin the raymarch\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // Estimate the distance to the julia set\n        dist = DE(p, sdf_center);\n        \n        // Move forward that distance\n        p += ray*dist;\n        \n        // Record the number of iterations we are on\n        j = i;\n        \n        // If we hit the julia set, or get too far away form it\n        if (dist < EPSILON || dot(p - sdf_center, p-sdf_center) > 16.1)\n        {\n            // Break the loop.\n        \tbreak;   \n        }\n        \n    }\n   \n    // determine if we hit the SDF\n    float hit = step(dist, EPSILON);\n    \n    // calculate the brightness based on iterations used\n\tfloat di = (float(j) + (dist / EPSILON)*hit) / float(ITERATIONS);\n    di = 1.0 - di;   \n    \n    if (HIDE_BACKGROUND)\n    {\n     \tdi = di*hit;   \n    }\n    \n    // define some phase angle\n    float psi = Radians(70.0);\n    \n    // Time varying pixel color (included in default shadertoy project)\n    //vec3 col = 0.8 + 0.2*cos(iTime*0.5+uv.xyx+vec3(0,2,4) + psi*hit);\n\t\n    // Boring old white instead of the above commented code. Will tweak rendering later\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    \n    // Output to screen. Modifiy the color with the brightness calculated as di.\n    fragColor = vec4(col*di,1.0);\n}","name":"Image","description":"","type":"image"}]}