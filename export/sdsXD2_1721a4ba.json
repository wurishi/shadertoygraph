{"ver":"0.1","info":{"id":"sdsXD2","date":"1619297051","viewed":253,"name":"Neon Wires","username":"ninjapretzel","description":"Experiment from a while ago.\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define PI 3.14159265359\n\nfloat _seed;\nfloat _scale;\nfloat _persistence;\n\n//1d Hash\nfloat hash(float n) { return fract(sin(n)*_seed); }\n//3d hash (uses 1d hash at prime scale offsets for y/z)\nfloat hash3(vec3 v) { return hash(v.x + v.y * 113.0 + v.z * 157.0); }\n//Quick 3d smooth noise\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\treturn mix(mix(\tmix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\tmix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n\t\t   mix(\tmix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\tmix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat nnoise(vec3 pos, float factor) {\t\n\tfloat total = 0.0\n\t\t, frequency = _scale\n\t\t, amplitude = 1.0\n\t\t, maxAmplitude = 0.0;\n\t\n\t//Accumulation\n\tfor (int i = 0; i < 6; i++) {\n\t\ttotal += noise(pos * frequency) * amplitude;\n\t\tfrequency *= 2.0, maxAmplitude += amplitude;\n\t\tamplitude *= _persistence;\n\t}\n\t\n\t//Normalization\n\tfloat avg = maxAmplitude * .5;\n\tif (factor != 0.0) {\n\t\tfloat range = avg * clamp(factor, 0.0, 1.0);\n\t\tfloat mmin = avg - range;\n\t\tfloat mmax = avg + range;\n\t\t\n\t\tfloat val = clamp(total, mmin, mmax);\n\t\treturn val = (val - mmin) / (mmax - mmin);\n\t} \n\t\n\tif (total > avg) { return 1.0; }\n\treturn 0.0;\n}\n//Default normalization factor of .5\n//This maps the range (.25,.75) to (0, 1)\nfloat nnoise(vec3 pos) { return nnoise(pos, .5); }\n\nfloat saturate(float v) { return clamp(v, 0., 1.); }\n#define ADD 1\n#define IGNORE 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y -= .9;\n    //uv.y *= .50;\n    uv.x -= .5;\n    uv.x *= .10;\n    \n    \n    float rate = 1.1;\n    float scale = 10.1;\n    \n\t_seed = 1333.0;\n\t_scale = 2.0;\n\t_persistence = .95;\n    \n    float dscale = 1.90;\n    \n\tfloat amp = 1.60 + .20 * nnoise(vec3(time*rate + uv.x*scale, time*.05, 0));\n\tint num = 9;\n\tvec4 cc = vec4(0,0,0,1);\n    float occ = 0.0; // near occludes far\n\tfor (int i = 0; i < num; i++) {\n\t\t\n        vec2 pos = uv;\n\t\tpos *= 5.0;\n        pos.y /= amp * 3.0;\n        pos.y += float(num-i) * .05;\n\t\tpos.x *= .10 * dscale;\n\t\tpos.x -= 35.0;\n\t\t\n\t    // wire position \n\t\tfloat v = noise(vec3(time*rate + pos.x * scale, pos.x * .05, 0.0)) - .5;\n        \n        _seed = 1337.0;\n        _scale = .65;\n        _persistence = .8 ;\n        v *= 3.0 * nnoise(vec3(time*rate + pos.x * scale, 0.0, 0.0)) - .5;\n        \n        float off = pos.y - v;\n        if (i == 0) { occ = off; }\n        \n        // Occlusion is incorrect, but the artifacts kinda look cool.\n        int mode = ADD;\n        if (off > occ) { mode = IGNORE; }\n        else { occ = off; }\n\n        float d = length(pos.y - v);\n\n        //d *= (16.0 + 14.50 * sin(-2. * time + float(i)/9.0*2.0*PI));\n        float elec = nnoise(vec3(time * -6. + pos.x * 16.50, .01 * pos.x, 1.0));\n        d *= .1 + 20.0 * elec * elec;\n\n        float r = .04 + .05 * sin(time + 2.0 * PI * ((float(i)+0.0)/9.0));\n        float g = .04 + .05 * sin(time + 2.0 * PI * ((float(i)+3.0)/9.0));\n        float b = .04 + .05 * sin(time + 2.0 * PI * ((float(i)+6.0)/9.0));\n        r = saturate(r); g = saturate(g); b = saturate(b);\n        if (mode == ADD) {\n            cc.r += r/d;\n            cc.g += g/d;\n            cc.b += b/d;\n        }\n        \n\t\tdscale *= 1.75;\n\t\t\n\t\tamp *= .62;\n\t}\n\tvec4 c = cc;//vec4(r/d, g/d, b/d, 1);\n\tfragColor = c;\n}\n","name":"Image","description":"","type":"image"}]}