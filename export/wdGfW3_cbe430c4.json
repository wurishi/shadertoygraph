{"ver":"0.1","info":{"id":"wdGfW3","date":"1612189287","viewed":90,"name":"2d-022_shake_shack.frag","username":"jorge2017a1","description":"2d-022_shake_shack.frag","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d022shakeshackfrag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    daily: 022\n    author: Will Stallwood\n    insta: https://www.instagram.com/willstall/\n    \n*/\n\n\n#define SECONDS 5.0\n#define SAMPLES 20\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n\n\nfloat sinc( float x, float k )\n{\n    float a = PI * ((float(k)*x-1.0));\n    return sin(a)/a;\n}\n\nfloat easeInCubic(float t) {\n    return t * t * t;\n}\n\nfloat easeOutCubic(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 debug_sdf(float sdf, bool full)\n{\n   vec3 color = vec3(1.0) - sign(sdf)*vec3(0.1,0.4,0.7);\n   if(full)\n   {\n\tcolor *= 1.0 - exp(-2.0*abs(sdf));\n\tcolor *= 0.89 + .5*cos(400.0*sdf);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(sdf)) );\n   }\n\n    return color;\n}\n\nfloat random(float x)\n{\n    return fract(sin(x*100.00)*10000.0);\n}\n\nfloat random( in vec2 st )\n{\n\treturn fract( sin( dot(st.xy, vec2(-30.950,-10.810) )) * 43758.5453123  );\t    \n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y < 0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nfloat round_border(float shape1, float shape2, float radius){\n    vec2 position = vec2(shape1, shape2);\n    float distanceFromBorderIntersection = length(position);\n    return distanceFromBorderIntersection - radius;\n}\n\nfloat stepUpDown(float begin, float end, float t) {\n  return step(begin, t) - step(end, t);\n}\n\nvec3 scene(vec2 st, float t)\n{\n    float slide = 0.5+0.5*sin(TWO_PI*t);\n    slide = 1.0-exp(slide);\n    slide = cubicPulse(slide,1.0,0.0);\n    // slide = sinc(slide,.3);\n\n    float period = mod(iTime,SECONDS);\n        st.x += 3.0 * easeInCubic((1.0-fract(period))) * stepUpDown( 0.0, 1.0, period );\n        st.x -= 3.0 * easeOutCubic(fract(period)) * stepUpDown( 4.0, 5.0, period );\n        // st.x += 3.0 * period * stepUpDown( 0.0, 3.0, period );\n        // st.x += 3.0 * (1.0-period) * stepUpDown( 4.0, 5.0, period );\n\n    // st.x += mix(1.0,-1.0,slide);\n\n    // sdf\n    float a = (0.5+0.5*sin(TWO_PI*t*2.0));\n        a = pow(a,3.9);\n        a = .24 * a;\n\n    float size = .5;\n\t    size = size - size * 2.5 * a;\n    \n    float spacing = .14;\n        spacing += a;\n\n    float rounding = 0.025;\n    \trounding = rounding + rounding * 2.5 * a;\n\n    vec2 offset = vec2(0.0,-0.15);\n\n    st *= rotate(-TWO_PI * 2.0 * easeInCubic((1.0-fract(period))) * stepUpDown( 2.0, 3.0, period ));\n\n    // offset.y *= 3.0 * pow(cos(TWO_PI*t),1.1);\n    offset.y -= a * 1.5;\n    st += offset;\n    \n    vec3 sdf = vec3(1.0);        \n        // top bun\n        sdf.x = length(st-vec2(0.0,-0.22))-size-0.025;\n        sdf.y = sdBox(st-vec2(0.,size*.5),vec2(size*1.,size*.5))+0.025;\n        sdf.x = max(sdf.x,sdf.y)-rounding;\n\n        // bottom bun\n        sdf.y = sdTrapezoid(st+vec2(0.0,spacing*3.0),size-0.0,size,.05);\n        sdf.x = min(sdf.x,sdf.y);\n\n        // patty\n        sdf.z = sdLine(st,vec2(-size,-spacing*2.0),vec2(size,-spacing*2.0));\n        // sdf.z = min(sdf.x,sdf.y);\n        \n        // scquiggle\n    float y = .015 * sin(.1*st.x*300.0+TWO_PI*t) - spacing;   \n        sdf.y = sdLine(st,vec2(-size,y),vec2(size,y));\n        // sdf.y = min(sdf.x,sdf.y);\n    \n    \t// rounding\n        sdf -= rounding;\n    // morph\n        st -= offset;\n        st *= rotate(TWO_PI*t*10.0);\n\n        float d1 = length(st)-size*.75;        \n        float d2 = max(d1,sdBox(st,vec2(size,size*.5)));\n\n        \n        float d = mix(d1,d2,0.5+0.5*sin(TWO_PI*t*1.0)) - rounding;\n\n        float m = 0.5+0.5*cos(TWO_PI*t*2.0);\n        m = pow(m,5.9);\n\n        sdf = mix(sdf,vec3(d),m);\n\n        return sdf;\n}\n\nfloat traceShadows(vec2 position, vec2 lightPosition,float t){\n    vec2 direction = normalize(lightPosition - position);\n    float lightDistance = length(lightPosition - position);\n\n    float rayProgress =  0.0001;\n    float nearest = 9999.0;\n    float hardness = 8.50 + random(position) * .50;\n\n    for(int i=0 ;i<SAMPLES; i++){\n        vec3 scene = scene(position + direction * rayProgress,t);\n        float sceneDist = min(min(scene.x,scene.y),scene.z);\n        // sceneDist = scene.x;\n\n        if(sceneDist <= 0.0){\n            return 0.0;\n        }\n        if(rayProgress > lightDistance){\n            return clamp(nearest,0.0,1.0);\n            //return 1.0;\n        }\n\n        nearest = min(nearest, hardness * sceneDist / rayProgress);\n        rayProgress = rayProgress + sceneDist;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // timing, if using cos+sin times are doubled    \n    float t = fract(iTime/SECONDS);\n\n    // space\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st = center( st );\n    st = st * 2.0 - 1.0;\n\n    st *= 1.0;\n\n    // sdf\n    vec3 sdf = scene(st,t);\n\n    // light\n    vec2 light = vec2(1.0,1.0);\n        // light.x += 1.0 * cos(TWO_PI*t*1.0);\n\n    float shadows = traceShadows(st,light,t);\n\n    // color\n    // vec3 c_bun = vec3(0.845,0.758,0.708);\n    // vec3 c_patty = vec3(00.800,0.312,0.396);\n    // vec3 c_lettuce = vec3(0.478,0.800,0.564);\n    // vec3 c_bg = vec3(0.910,0.906,0.915);\n    // vec3 c_shadow = vec3(0.875,0.871,0.880);\n\n    // alt color\n    vec3 c_bun = vec3(0.970,0.828,0.723);\n    vec3 c_patty = vec3(0.930,0.293,0.419);\n    vec3 c_lettuce = vec3(0.548,0.990,0.353);\n    vec3 c_bg = vec3(0.820,0.446,0.625);\n    vec3 c_shadow = vec3(0.710,0.361,0.515);\n\n    vec3 color = vec3(c_bg);\n        color = mix(color,c_shadow,1.0-smoothstep(0.0,0.005,shadows));    \n        color = mix(color,c_patty,1.0-smoothstep(0.0,0.005,sdf.z));\n        color = mix(color,c_lettuce,1.0-smoothstep(0.0,0.005,sdf.y));\n        color = mix(color,c_bun,1.0-smoothstep(0.0,0.005,sdf.x));\n        \n\n\n        color += color * 0.1;\n\n    // vignette\n        // color += 1.0-(length(st)-0.07) *.01;\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}