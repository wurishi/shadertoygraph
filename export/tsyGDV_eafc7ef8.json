{"ver":"0.1","info":{"id":"tsyGDV","date":"1634588158","viewed":183,"name":"ðŸŽ¹ QR Code Danceful ðŸŽ¶","username":"rmmcal","description":"Meditating and relaxing...","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["qr","dance","qrcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//         ...  ðŸŽ¹ QR Code Danceful ðŸŽ¶  ...             ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/10\n// - https://www.shadertoy.com/view/tsyGDV\n/////////////////////////////////////////////////////////////\n\nint modi(int a, int n){\n    return a - (n * int(a/n));\n}\n\nbool checkin(int x, int y, int w, int h){\n    return x>=0&&x<w && y>=0&&y<h; \n}\n\nint pow2(int x){\n    return int(pow(2.,float(x)));\n}\n\nconst int QR_LEN = 29;\nint QR[QR_LEN];\n\nvoid qrLoad(){\n    QR[0] = 0x09936D7F;QR[1] = 0x091F7541;QR[2] = 0x170A145D;QR[3] = 0x0F4B195D;QR[4] = 0x19F3945D;QR[5] = 0x07154641;QR[6] = 0x0955077F;QR[7] = 0x1D114D00;QR[8] = 0x05F004F5;QR[9] = 0x184AD634;QR[10] = 0x18D35BC1;QR[11] = 0x12E57006;QR[12] = 0x08AB3552;QR[13] = 0x0A3E0928;QR[14] = 0x1E006B54;QR[15] = 0x00B86ABF;QR[16] = 0x1A7ECDE1;QR[17] = 0x0DC4BFB3;QR[18] = 0x0E0978FB;QR[19] = 0x1251BA87;QR[20] = 0x0DD958CB;QR[21] = 0x00062D00;QR[22] = 0x1FD5557F;QR[23] = 0x104F9541;QR[24] = 0x1757575D;QR[25] = 0x1744B25D;QR[26] = 0x175A015D;QR[27] = 0x1041E741;QR[28] = 0x1FCC047F;\n}\n\nint qr(const int x,const int y){\n    int r = 1;\n    if (checkin(x,y, QR_LEN,QR_LEN)){\n        for (int i = 0 ; i < QR_LEN ; i++) if (y == i) r = modi( QR[i] / pow2(x) + 1, 2 );\n            return 1-r;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    qrLoad();\n    ivec2 ir  = ivec2(iResolution.xy); \n    ivec2 ip  = ivec2(fragCoord.xy);\n    ivec2 it  = ip*ir.x*1024/ivec2(ir.y)/(ir.y) ;\n\n    vec2 uv   = fragCoord/iResolution.xy;\n    vec2 ar   = vec2( iResolution.x/iResolution.y,1.);\n    vec2 p    = uv*ar;\n\n    vec4 bg = vec4(abs(cos(iTime*.5+p.y)),\n                   abs(cos(iTime*.7+p.x)),\n                   abs(cos(iTime*.3+p.x*p.x+p.y)),\n                   1.);\n    bg = normalize(bg);\n    bg = bg/(1.-bg);\n\n    float t = iTime;\n    float t1 = clamp((t-0.)*.2,0.,1.);\n    float t2 = clamp((t-3.)*.1,0.,1.);\n    float t3 = clamp((t-10.)*.05,0.,1.);\n    float t4 = clamp((t-20.)*.01,0.,1.);\n    float t5 = clamp((t-20.)*.2,0.,1.);\n    t3 = t3*t3;\n    t5 = t5*t5;\n    t4 = t4*t4;\n\n\n    vec4 canvas = normalize(bg)*.4+.6;\n    float grid = 1.;\n    vec2 pq;\n    pq.x = cos(iTime*5.+p.y*9.)*13. -t3*200.*cos(iTime*1.+p.y*2.);\n    pq.y = cos(iTime*9.+p.x*9.)*13. -t4*200.*cos(iTime*3.+p.y*2.);\n    it.x += (int(pq.x)-100);\n\n    it.y += (int(pq.y));\n\n    it/=44;\n    int c = (qr(it.x, it.y));\n    int xp = modi(it.x,2);\n    int yp = modi(it.y,2);\n    it -= 5;\n    float qrf = float(1-qr(it.x+1, it.y+1));\n    canvas *= qrf;\n\n    vec3 lights;\n    for (float i = 1.; i < 10.; i++)\n    {\n        float tx = abs(fract(iTime*.01*i+i)*2.-1.);\n        float ty = abs(fract(iTime*.2/i+i)*2.-1.);\n        vec2 pt = vec2(tx,ty)*ar; \n        lights += float(smoothstep(0.,.6, .4*((i+10.)*.05)-length(p-pt)));\n    }\n\n    canvas.xyz += t2*smoothstep(0.,1., lights);\n    canvas.xyz *= (qrf*.5+.5)*smoothstep(0.,.8, t1*2.-length(p-.5));\n    \n   \n    float time = mod(iTime,28.); // \"repeat\" 28 secs\n    canvas.xyz *= (qrf*.5+.5)*smoothstep(0.,.8, max(0.0, 27.-time)*2.0 -length(p-.5));\n    \n    canvas.xyz *= (qrf*.5+.5)*smoothstep(0.,.8,  1.25-length(uv-.5));\n   \n    fragColor = vec4(canvas.rgb,1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst int NOTES_LEN = 101;\nvec2 NOTES[NOTES_LEN];\n\nvoid notesLoad(){\n    NOTES[0] = vec2(523.25,0.25);NOTES[1] = vec2(659.26,0.5);NOTES[2] = vec2(783.99,0.75);NOTES[3] = vec2(1046.5,1.0);NOTES[4] = vec2(1318.51,1.25);NOTES[5] = vec2(783.99,1.5);NOTES[6] = vec2(1046.5,1.75);NOTES[7] = vec2(1318.51,2.0);NOTES[8] = vec2(523.25,2.25);NOTES[9] = vec2(659.26,2.5);NOTES[10] = vec2(783.99,2.75);NOTES[11] = vec2(1046.5,3.0);NOTES[12] = vec2(1318.51,3.25);NOTES[13] = vec2(783.99,3.5);NOTES[14] = vec2(1046.5,3.75);NOTES[15] = vec2(1318.51,4.0);NOTES[16] = vec2(523.25,4.25);NOTES[17] = vec2(587.33,4.5);NOTES[18] = vec2(880.0,4.75);NOTES[19] = vec2(1174.66,5.0);NOTES[20] = vec2(1396.91,5.25);NOTES[21] = vec2(880.0,5.5);NOTES[22] = vec2(1174.66,5.75);NOTES[23] = vec2(1396.91,6.0);NOTES[24] = vec2(523.25,6.25);NOTES[25] = vec2(587.33,6.5);NOTES[26] = vec2(880.0,6.75);NOTES[27] = vec2(1174.66,7.0);NOTES[28] = vec2(1396.91,7.25);NOTES[29] = vec2(880.0,7.5);NOTES[30] = vec2(1174.66,7.75);NOTES[31] = vec2(1396.91,8.0);NOTES[32] = vec2(493.88,8.25);NOTES[33] = vec2(587.33,8.5);NOTES[34] = vec2(783.99,8.75);NOTES[35] = vec2(1174.66,9.0);NOTES[36] = vec2(1396.91,9.25);NOTES[37] = vec2(783.99,9.5);NOTES[38] = vec2(1174.66,9.75);NOTES[39] = vec2(1396.91,10.0);NOTES[40] = vec2(493.88,10.25);NOTES[41] = vec2(587.33,10.5);NOTES[42] = vec2(783.99,10.75);NOTES[43] = vec2(1174.66,11.0);NOTES[44] = vec2(1396.91,11.25);NOTES[45] = vec2(783.99,11.5);NOTES[46] = vec2(1174.66,11.75);NOTES[47] = vec2(1396.91,12.0);NOTES[48] = vec2(523.25,12.25);NOTES[49] = vec2(659.26,12.5);NOTES[50] = vec2(783.99,12.75);NOTES[51] = vec2(1046.5,13.0);NOTES[52] = vec2(1318.51,13.25);NOTES[53] = vec2(783.99,13.5);NOTES[54] = vec2(1046.5,13.75);NOTES[55] = vec2(1318.51,14.0);NOTES[56] = vec2(523.25,14.25);NOTES[57] = vec2(659.26,14.5);NOTES[58] = vec2(783.99,14.75);NOTES[59] = vec2(1046.5,15.0);NOTES[60] = vec2(1318.51,15.25);NOTES[61] = vec2(783.99,15.5);NOTES[62] = vec2(1046.5,15.75);NOTES[63] = vec2(1318.51,16.0);NOTES[64] = vec2(523.25,16.25);NOTES[65] = vec2(659.26,16.5);NOTES[66] = vec2(880.0,16.75);NOTES[67] = vec2(1318.51,17.0);NOTES[68] = vec2(1760.0,17.25);NOTES[69] = vec2(880.0,17.5);NOTES[70] = vec2(1318.51,17.75);NOTES[71] = vec2(1760.0,18.0);NOTES[72] = vec2(523.25,18.25);NOTES[73] = vec2(659.26,18.5);NOTES[74] = vec2(880.0,18.75);NOTES[75] = vec2(1318.51,19.0);NOTES[76] = vec2(1760.0,19.25);NOTES[77] = vec2(880.0,19.5);NOTES[78] = vec2(1318.51,19.75);NOTES[79] = vec2(1760.0,20.0);NOTES[80] = vec2(523.25,20.25);NOTES[81] = vec2(587.33,20.5);NOTES[82] = vec2(739.99,20.75);NOTES[83] = vec2(880.0,21.0);NOTES[84] = vec2(1174.66,21.25);NOTES[85] = vec2(739.99,21.5);NOTES[86] = vec2(880.0,21.75);NOTES[87] = vec2(1174.66,22.0);NOTES[88] = vec2(523.25,22.25);NOTES[89] = vec2(587.33,22.5);NOTES[90] = vec2(739.99,22.75);NOTES[91] = vec2(880.0,23.0);NOTES[92] = vec2(1174.66,23.25);NOTES[93] = vec2(739.99,23.5);NOTES[94] = vec2(880.0,23.75);NOTES[95] = vec2(1174.66,24.0);NOTES[96] = vec2(493.88,24.25);NOTES[97] = vec2(587.33,24.5);NOTES[98] = vec2(783.99,24.75);NOTES[99] = vec2(1174.66,25.0);NOTES[100] = vec2(1567.98,25.25);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    notesLoad();\n    vec2 r;\n    \n    //time = mod(time,28.);         // repeat 28 secs\n    time = fract(time/28.0)*28.0;   // repeat 28 secs\n    \n    for (int i = 0; i < NOTES_LEN; i++)\n    {\n        float t = max(.0,time-NOTES[i].y); // time\n        float f = NOTES[i].x;              // tone\n        \n        // A 440 Hz wave that attenuates quickly overt time\n        r += vec2( sin(6.2831*f*t)*exp(-3.0*t) );\n    }\n    r /= 4.;\n    \n    return r;\n}","name":"Sound","description":"","type":"sound"}]}