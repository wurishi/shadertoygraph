{"ver":"0.1","info":{"id":"DsK3Wz","date":"1678477532","viewed":304,"name":"Double Vortex Experiment","username":"incre_ment","description":"An evolution of the previous shader.  Still experimenting with repetition and rotation in 2D.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["learning","vortex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circleSDF(vec2 coords, float rad, vec2 offset){\n  return (length(coords-offset) - rad);\n}\n\nfloat circleSDF2(vec2 coords, float rad, vec2 offset){\n  return abs(length(coords-offset) - rad)-.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   \n  // Translate, rotate, translate back\n  uv += vec2(-0.4,0.0) ; \n  uv *= rotation(PI/2.*pow((1.42-pow(length(uv),.5)),15.));\n  uv += vec2(0.4,0.0);\n  \n  // Translate, rotate, translate back\n  uv += vec2(0.4,0.0);\n  uv *= rotation(PI/2.*pow((1.42-pow(length(uv),.5)),15.)); \n  uv += vec2(-0.4,0.0);\n  \n  // Determine which vortex the point is closer to\n  float d = pow(min(distance(uv, vec2(-0.4, 0.)),distance(uv,vec2(0.4, 0.))),1.5); \n\n  // Motion and repetition\n  float modVal = .1;\n  uv += vec2(-iTime*modVal, 0.);\n  uv = mod(uv,modVal);\n   \n  vec3 col = vec3(0.);\n   \n  float dd = map(d, 0., 1.25, .015, 0.);  \n  \n  // Draw the circles\n  float cSDF = circleSDF(uv, .035-pow(dd,1.20), vec2(modVal/2.0,modVal/2.0));\n  col += 3.5*d*smoothstep(.006,-.006,cSDF);  \n   \n  float cSDF2 = circleSDF2(uv, .06-pow(dd,1.20), vec2(modVal/2.0,modVal/2.0));\n  col += 3.5*d*smoothstep(.006,-.006,cSDF2); \n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat PI = 3.14159256;\nfloat TAU = 2.0*3.14159256;\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}","name":"Common","description":"","type":"common"}]}