{"ver":"0.1","info":{"id":"ssyXR3","date":"1635000956","viewed":90,"name":"CALayer with Gradient Border","username":"barton","description":"Example of border with gradient.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradient","border","layer","calayer","cagradientlayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// CALayer with Gradient Border\n//\n\n#define kTopLeftCorner      0x1\n#define kTopRightCorner     0x2\n#define kBottomLeftCorner   0x4\n#define kBottomRightCorner  0x8\n\nstruct LayerUniform {\n    vec2 size;\n    float cornerRadius;\n    int maskedCorners;\n    float borderWidth;\n    vec4 borderColor;\n    float opacity;\n};\n\nstruct GradientUniform {\n    vec2 startPoint;\n    vec2 endPoint;\n    int stops;\n};\n\n// In real situation these constants will come in fragment shader as reference to corresponding\n// buffers and it will not exist such way. Just example for ShaderToy.\nconst vec4 colors[3] = vec4[](vec4(0, 0, 1, 1), vec4(1, 0, 0, 1), vec4(0, 1, 0, 1));\nconst float locations[3] = float[](0.0, 0.5, 1.0);\n\n// Calculate SDF for rect by size.\nfloat sdfRect(vec2 point, vec2 size) {\n    vec2 q = abs(point) - size/2.0;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\n// Calculate SDF for rect by size with corner radius.\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius) {\n    vec2 q = abs(point) - size/2.0 + cornerRadius;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - cornerRadius;\n}\n\n// Calculate SDF for rect with corner radius and masked corners;\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius, int maskedCorners) {\n    if (maskedCorners == 0) {\n        return sdfRect(point, size);  \n    } else if ((point.x < 0.0 && point.y > 0.0) && (maskedCorners & kTopLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y > 0.0 && (maskedCorners & kTopRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x < 0.0 && point.y < 0.0 && (maskedCorners & kBottomLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y < 0.0 && (maskedCorners & kBottomRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    }\n    \n    float d1 = sdfRect(vec2(point.x, 0), size, cornerRadius);\n    float d2 = sdfRect(vec2(0, point.y), size, cornerRadius);\n    \n    return max(d1, d2);\n}\n\nfloat getRoundedRectBackgroundMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    \n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask = smoothstep(0.8, -0.8, d + 0.16);\n    \n    return mask;\n}\n\nfloat makeBackgroundMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    \n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask = smoothstep(0.8, -0.8, d + 0.16);\n    \n    return mask;\n}\n\nfloat makeBorderdMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    float borderWidth = layerUniform.borderWidth;\n\n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask1 = smoothstep(d - 0.45, d + 0.45, 0.1);\n    float mask2 = smoothstep(abs(d) - 0.45, abs(d) + 0.45, borderWidth - 0.1);\n    \n    return mask1 * mask2;\n}\n\n// Under Metal the interpolate fuction will use pointers for colors and locations.\nvec4 makeInterpolateColor(vec4[3] colors, float[3] locations, int count, float location) {\n    int lower = 0;\n    int upper;\n    \n    for (upper = 0; upper < count; upper++) {\n        if (locations[upper] > location) {\n            break;\n        }\n\n        lower = upper;\n    }\n    \n    float numerator = location - locations[lower];\n    float denominator = locations[upper] - locations[lower];\n    float fraction = denominator != 0.0 ? clamp(numerator / denominator, 0.0, 1.0) : 0.0;\n    \n    return mix(colors[lower], colors[upper], fraction);\n}\n\n// Under Metal the gradient_axial fuction will use pointers for colors and locations.\nvec4 makeAxialGradientColor(vec2 uv, GradientUniform gradientUniform, vec4[3] colors, float[3] locations) {\n    uv.y = 1.0 - uv.y; // For CoreAnimation 0.0, 0.0 will be at the top left corner. \n    \n    vec2 startPoint = gradientUniform.startPoint;\n    vec2 endPoint = gradientUniform.endPoint;\n    \n    vec2 dt = endPoint - startPoint;\n    vec2 pt = uv - startPoint;\n    float t = dot(pt, dt)/ dot(dt, dt);\n    \n    return makeInterpolateColor(colors, locations, gradientUniform.stops, t);\n}\n\n// Some extra function for extra code addition.\nfloat normalizeInRange(float value, float minValue, float maxValue) {\n    return (value - minValue)/(maxValue - minValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float initialRadius = 500.0;\n    float upadtedRadius = abs(initialRadius * sin(iTime * 0.5));\n\n    // Input uniform for fragment shader.\n    LayerUniform layerUniform;\n    layerUniform.size = vec2(700, 700);\n    layerUniform.cornerRadius = upadtedRadius;\n    layerUniform.maskedCorners = kTopLeftCorner | kBottomRightCorner;\n    //layerUniform.maskedCorners = kTopLeftCorner | kTopRightCorner | kBottomLeftCorner | kBottomRightCorner;\n    layerUniform.borderWidth = 30.0;\n    layerUniform.borderColor = vec4(1, 1, 1, 1);\n    layerUniform.opacity = 1.0;\n    \n    // Input uniform for fragment shader.\n    GradientUniform gradientUniform;\n    gradientUniform.startPoint = vec2(0.0, 0.0);\n    gradientUniform.endPoint = vec2(1.0, 1.0);\n    gradientUniform.stops = 3;\n    \n    vec2 uv = (fragCoord/iResolution.xy) - 0.5;\n    \n    float backgroundMask = makeBackgroundMask(uv, layerUniform);\n    float borderMask = makeBorderdMask(uv, layerUniform);\n    \n    // Some extra code to make gradient inside current layer. In real situation such extra code\n    // will not exist at all.\n    vec2 center = vec2(0.5) * iResolution.xy;\n    float startX = center.x - layerUniform.size.x/2.0;\n    float endX = center.x + layerUniform.size.x/2.0;\n    float normalX = normalizeInRange(fragCoord.x, startX, endX);\n    \n    float startY = center.y - layerUniform.size.y/2.0;\n    float endY = center.y + layerUniform.size.y/2.0;\n    float normalY = normalizeInRange(fragCoord.y, startY, endY);\n    \n    if ((normalX >= 0.0) && (normalX <= 1.0) && (normalY >= 0.0) && (normalY <= 1.0)) {\n        vec2 uvUpdated = vec2(normalX, normalY) - 0.5;\n        \n        vec4 gradientColor = makeAxialGradientColor(uvUpdated, gradientUniform, colors, locations);\n        vec4 c1 = mix(vec4(0), gradientColor, backgroundMask);\n        vec4 c2 = mix(vec4(0), layerUniform.borderColor, borderMask);\n        fragColor = c1 * c2;\n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}