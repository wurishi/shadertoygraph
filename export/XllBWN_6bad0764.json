{"ver":"0.1","info":{"id":"XllBWN","date":"1517236683","viewed":408,"name":"Bokeh Traffic Tutorial","username":"Skrillcon","description":"https://www.youtube.com/watch?v=eKtsY7hYTPg\n\nFollowing his tutorial series and then change the effect to make it mine.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\nfloat Noise(float t){\n\treturn fract(sin(t * 3496.) * 6542.);\n}\n\nvec4 Noise14(float t){\n\treturn fract(sin(t * vec4(3496., 143., 1809., 7893.)) * vec4(6542., 2012., 290., 3943.));\n}\n\nstruct ray{\n\tvec3 o, d; // origin and direction\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n\n    vec3 forward = normalize(lookat-camPos);\n    vec3 right = cross(vec3(0,1,0), forward);\n    vec3 up = cross(forward, right);\n    vec3 center = a.o + forward * zoom;\n    vec3 intersect = center + uv.x * right + uv.y * up;\n\n    a.d = normalize(intersect - a.o);\n\n    return a;\n}\n\nvec3 ClosestPoint(ray r, vec3 p){\n\treturn r.o + max(0., dot(p-r.o, r.d)) * r.d;\n}\n\nfloat DistRay(ray r, vec3 p){\n\treturn length(p-ClosestPoint(r, p));   \n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur){\n\tfloat d = DistRay(r, p);\n    \n    size *= length(p);\n    float c = S(size, size*(1.-blur), d);\n    // Make the outside brighter again\n    c *= mix(.6, 1., S(size*.8, size, d));\n    return c;\n    \n}\n\nvec3 StreetLights(ray r, float t){\n    // Offset both sides\n    float side = step(r.d.x, 0.);\n    \n    \n    // Make it be both sides, free calculations for doubles\n    r.d.x = abs(r.d.x);\n    \n    // Number of streetlights\n    float s = 1./8.; // 8 streetlights\n    float m = 0.;\n    for(float i = 0.; i < 1.; i += s){\n        // ti is used to calculate the position according to time, also has offset for sides\n        float ti = fract(t + i + side * s * .5);\n        vec3 p = vec3(1.7,2.9,100. - ti * 100.);\n    \tm += Bokeh(r, p, .05, .15) * ti * ti * ti;\n    }\n    \n    return vec3(1., .7, .3) * m;\n}\n\nvec3 EnvLights(ray r, float t){\n    // Offset both sides\n    float side = step(r.d.x, 0.);\n    \n    \n    // Make it be both sides, free calculations for doubles\n    r.d.x = abs(r.d.x);\n    \n    // Number of envlights\n    float s = 1./20.; // 20 envlights\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < 1.; i += s){\n        // ti is used to calculate the position according to time, also has offset for sides\n        float ti = fract(t + i + side * s * .5);\n        // Position of environment lights, want them to appear off road\n        vec4 n = Noise14(i + side * 100.);\n        float fade = ti * ti * ti;\n        \n        // Sometimes make lights get obstructed\n        float occlusion = sin(ti * 6.28 * 6. * n.w) * .5 + .5;\n        \n        fade *= occlusion;\n        \n        float x = mix(2.5, 10., n.x);\n        float y = mix(.1, 1.6, n.y);\n        \n        vec3 p = vec3(x,y,50. - ti * 50.);\n        \n        vec3 randCol = n.wzy;\n        \n    \tcol += Bokeh(r, p, .05, .15) * fade * randCol * .8;\n    }\n    \n    return col;\n}\n\nvec3 HeadLights(ray r, float t){  \n    \n    // Double speed to simulate that those cars are going same speed as you\n    t *= 2.;\n    // Half width of car\n    float w1 = .3;\n    // Used to make headlights look more headlight shaped\n    float w2 = w1 * 1.2;\n    // Number of cars\n    float s = 1./35.; // 35 cars\n    float m = 0.;\n    for(float i = 0.; i < 1.; i += s){\n        \n        // Use noise to cancel out random cars\n        float n = Noise(i);\n        \n        // Skip about 90% of the cars\n        if(n > .1) continue;\n        \n        // ti is used to calculate the position according to time, also has offset for sides\n        float ti = fract(t + i);\n        float z = 100.-ti*100.;\n        float fade =  ti * ti * ti * ti * ti;\n        float focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        \n    \tm += Bokeh(r, vec3(-1.-w1,.15,z), size, .15) * fade;\n        m += Bokeh(r, vec3(-1.+w1,.15,z), size, .15) * fade;\n        \n        m += Bokeh(r, vec3(-1.-w2,.15,z), size, .15) * fade;\n        m += Bokeh(r, vec3(-1.+w2,.15,z), size, .15) * fade;\n        \n        // Add reflection on the road\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(-1.-w2,-.15,z), size*3., 1.) * fade;\n        ref += Bokeh(r, vec3(-1.+w2,-.15,z), size*3., 1.) * fade;\n        \n        m += ref * focus;\n    }\n    \n    return vec3(.9, .9, 1.) * m;\n}\n\nvec3 TailLights(ray r, float t){  \n    // Taillights moving slower because you're driving up to these cars\n    t *= .15;\n    // Half width of car\n    float w1 = .3;\n    // Used to make headlights look more headlight shaped\n    float w2 = w1 * 1.;\n    // Number of cars\n    float s = 1./10.; // 15 cars\n    // Help give everything a beautiful purple tint\n    float m = .1;\n    for(float i = 0.; i < 1.; i += s){\n        \n        // Use noise to cancel out random cars\n        float n = Noise(i);\n        \n        // Skip about half the cars\n        if(n > .5) continue;\n        \n        float lane = step(.25, n); // either 0 or 1 since n is guaranteed to be between 0 and .5\n        // ti is used to calculate the position according to time, also has offset for sides\n        float ti = fract(t + i);\n        float z = 100.-ti*100.;\n        float fade =  ti * ti * ti * ti * ti;\n        float focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        // Used for when car in our lane needs to move over\n        float laneChangeStart = .95;\n        float laneChangeEnd = .99;\n        float signalStartOffset = .02;\n        float laneShift = S(laneChangeEnd, laneChangeStart, ti);\n        float x = 1.5 - lane * laneShift;\n        float blink = step(0., sin(t *  440.)) * 7. \n            \t\t\t\t\t* lane * step(laneChangeStart - signalStartOffset, ti);\n        \n    \tm += Bokeh(r, vec3(x-w1,.15,z), size, .15) * fade;\n        m += Bokeh(r, vec3(x+w1,.15,z), size, .15) * fade;\n        \n        m += Bokeh(r, vec3(x-w2,.15,z), size, .15) * fade;\n        m += Bokeh(r, vec3(x+w2,.15,z), size, .15) * fade * (1. + blink);\n        \n        // Add reflection on the road\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(x-w2,-.15,z), size*3., 1.) * fade;\n        ref += Bokeh(r, vec3(x+w2,-.15,z), size*3., 1.) * fade * (1. + blink * .1);\n        \n        m += ref * focus;\n    }\n    \n    return vec3(1., .1, .03) * m;\n}\n\n// Improvements, make sure drop isn't middle of box\nvec2 Rain(vec2 uv, float t){\n    \n    t*=40.;\n    \n\tvec2 aspectRatio = vec2(3., 1.);\n    vec2 st = uv * aspectRatio;\n    \n    // Keep track of each raindrop to offset them\n    vec2 id = floor(st);\n    \n    // The speed of which everything is moving down always\n    st.y += t * .23;\n    // Calculate noise\n    float n = fract(sin(id.x * 76.44 * sin(id.x * 2196.1)) * 3184.2);\n    \n    // Offset y using id\n    st.y += n;\n    uv.y += n;\n    //st.x += n * .2;\n    //uv.x += n * .2;\n    \n    // Recalculate since shifted the boxes\n    id = floor(st);\n    \n    // Change coordinates from -.5-.5\n    st = fract(st)-.5;\n    \n    // Each box should be a different speed, multiply by 2pi for entire length of phase\n    t += fract(sin(id.x * 76.44 + id.y *  891.21) * 3184.2) * 6.283;\n    \n    // For position\n    // Use sawtooth wave to go down quick and go up slow\n    float y = -sin(t + sin(t + sin(t)*.5)) * .43;\n    vec2 p1 = vec2(0., y);\n    \n    // offset for where the uv is in relation to where the drop is.\n    vec2 o1 = (st-p1)/aspectRatio;\n    \n    // Divide to make dot the right shape\n    float d = length(o1);\n    \n    float m1 = S(.07, .00, d);\n    \n    // Make trail of drops that are stationary\n    // Change the number of dots in vertical and horizontal locations\n    vec2 numDots = vec2(1., 2.);\n    \n    // offset for where the uv is in relation to where the drop trail is.\n    // -.5 to move the dots away from the center to get full circle\n    // Must divide by numdots to keep aspect ratio\n    vec2 o2 = (fract(uv * aspectRatio.x * numDots) - .5)/numDots;\n    d = length(o2);\n    \n    // Smoothstep masks all small dots under big drop\n    // .5-st.y is to scale the size of trail drops as big drop lowers\n    float m2 = S(.28 * (.5-st.y), .0, d) * S(-.1, .1, st.y -  p1.y);\n    \n    // Just for debugging\n    //if(st.x > .46 ||st.y>.49) m1 = 1.;\n    return vec2(m1 * o1 * 30. + m2 * o2 * 12.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Allows for mouse scrobble\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // How fast it plays out\n    float timeScale = .07;\n    float t = iTime * timeScale + m.x;\n\n    vec3 camPos = vec3(.5, .2, 0);\n    vec3 lookat = vec3(.5, .2, 1.);\n    \n    vec2 rainDistort = Rain(uv*3.2, t) * .5;\n    // Add another layer of rain\n    rainDistort += Rain(uv * 5., t) *.5;\n    \n    // Add a bit of wateryness/wavyness to the drops\n    uv.x += sin(uv.y*4053.) * .002;\n    uv.y += sin(uv.x*296.) * .001;\n\n    ray r = GetRay(uv - rainDistort * .5, camPos, lookat, 2.);\n    \n\tvec3 col = StreetLights(r, t);\n    col += HeadLights(r, t);\n    col += TailLights(r, t);\n    col += EnvLights(r, t);\n    \n    // Add the sky light\n    col += (r.d.y + .6) * vec3(.2, .1, .5);    \n    \n    // For now just view distortion\n    //col = vec3(rainDistort, 0.);\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}