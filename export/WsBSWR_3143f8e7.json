{"ver":"0.1","info":{"id":"WsBSWR","date":"1553317288","viewed":73,"name":"raymarching: sphere","username":"takumifukasawa","description":"raymarch: sphere\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPS 0.0001\n#define PI 3.14159265359\n\nprecision highp float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005; \n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat scene(vec3 p) {\n  return sphere(p, .9);\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}  \n  \nfloat rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  float sceneDist = 0.;\n  float rayDepth = start;\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist = scene(origin + dir * rayDepth);\n    if((sceneDist < stopThreshold) || (rayDepth >= end)) {\n      break;\n    }\n    rayDepth += sceneDist * stepScale;\n  }\n  if (sceneDist >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist;\n  }\n  return rayDepth;\n}\n\nvec3 lighting(vec3 position, vec3 cameraPos, vec3 lookAt) {\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.3);\n\n  vec3 lightPos = vec3(1., 1., 1.);\n\n  // directional light\n  float diffuse = max(0., dot(normal, normalize(lightPos)));\n\n  // ambient\n  vec3 ambient = vec3(0., .08, .1);\n  \n  return diffuse + ambient;\n}  \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n\n  // -1 ~ 1  \n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n    \n  // camera settings\n  vec3 lookAt = vec3(0.); \n  vec3 cameraPos = vec3(vec2(2. * iMouse.xy / iResolution.xy - 1.) * 3., 2.);\n  float nearClip = 0.;\n  float farClip = 80.;\n  float fov = 0.5;\n\n  // // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));\n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  float dist = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  \n  if(dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(bgColor, 1.);\n    return;\n  }\n\n  vec3 position = rayOrigin + rayDirection * dist;\n  vec3 normal = getNormal(position);\n\n  vec3 sceneColor = lighting(position, cameraPos, lookAt);\n  \n  fragColor = vec4(sceneColor, 1.); \n}\n","name":"Image","description":"","type":"image"}]}