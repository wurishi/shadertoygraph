{"ver":"0.1","info":{"id":"wdfSWf","date":"1552345884","viewed":986,"name":"[twitch] Attack Flower","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/AttackFlower.glsl","likes":49,"published":1,"flags":0,"usePreview":0,"tags":["3d","voxel","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/AttackFlower.glsl\n\nThis is a voxel rendering technique (3D DDA I think), mainly found from IQ's https://www.shadertoy.com/view/4dfGzs\n*/\n\n#define MARCH_STEPS 300\n#define STOP_MOTION 0\n#define TEST_RAYMARCH 0\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a,float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k * (1.0-k) * h;\n}\n\nfloat noise(vec3 p) {\n  vec3 ip = floor(p);\n  p=fract(p);\n  //p=smoothstep(0,1,p);\n  vec3 st = vec3(7,193,385);\n  vec4 val = dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*7845.558), fract(sin(val+st.x)*7845.558), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y, p.z);\n}\n\n\nfloat rnd(float t) {\n  return fract(sin(t*784.535)*5384.669);\n}\n\nfloat rnd(vec3 p) {\n  return fract(dot(sin(p*vec3(784.535,584.653,387.627)),vec3(5384.669)));\n}\n\nvec2 moda(vec2 p, float rep, float off) {\n  vec2 inter = vec2(atan(p.y,p.x), length(p.xy));\n  inter.x /= (2.0*PI);\n  //inter.x = (fract(inter.x*rep+0.5)-0.5)/rep;\n  inter.x = (fract(inter.x*rep+0.5)-0.5)/rep;\n  inter.x *= 2.0*PI;\n  return vec2(cos(inter.x),sin(inter.x))*inter.y;\n}\n\nfloat mapid = 0.0;\nfloat map(vec3 p) {\n\n#if STOP_MOTION\n  float framy = 0.15;\n  float t2 = floor(time/framy)*framy;\n#else\n  float t2 = time;\n#endif\n\n  vec3 pe = p;\n  pe.xz = moda(pe.xz, 12.0, 0.0);\n  //\n  pe.x -= 20.0;\n  float ps =6.0+clamp(pe.x*10.0,0.0,10.0);\n  float tmp = pe.x;\n  float anim = clamp((sin(t2*0.2)-0.5)*2.0,0.0,1.0);\n  pe.xy *= rot(0.5 + (tmp*0.1*(1.0+sin(t2*0.1)) + fract(t2*0.2)*2.0*PI)*anim);\n  pe.x = (fract(pe.x/ps+0.1)-0.5)*ps;\n  pe.y += tmp*0.2;\n  //pe.xy *= rot(0.5 + tmp*0.5);\n  float s = length((pe)*vec3(5,0.5,1))-5.0;\n  s = smin(s, length(p)-60.0, -30.0);\n  s = min(s, length((p-vec3(0,8,0))*vec3(0.3,1,0.3))-8.0);\n\n  float f = noise(p*0.1)-0.5;\n  float f2 = (noise(p*0.2)-0.4);\n  f += f2;\n  f = max(f, -5.0-p.y + 30.0 - min(30.0,length(p.xz)*0.7));\n\n  vec3 rp = p;\n  float dur = 0.1;\n  float stime = floor(t2/dur)*dur;\n  rp.xz *= rot(sin(rp.y*0.1 + t2*0.5)*0.5);\n  rp.zy *= rot(sin(rp.x*0.3)*0.3);\n  float size = 60.0-clamp(length(p.xz)*0.8-30.0,0.0,50.0);\n  rp.xz = (fract(rp.xz/size)-0.5)*size;\n  float c = length(rp.xz)-3.0;\n  c = smin(c, -30.0-p.y, -20.0);\n\n  float first = min(f,c);\n  float f3 = (noise(p*vec3(0.1,0.8,0.1)*0.5)-0.4);\n  float clouds = max(f3+0.2, +30.0+p.y);\n  first = min(first, clouds);\n\n  mapid = (s<first)?1.0:0.0;\n\n  return min(s, first);\n}\n\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 5.0));\n}\n\nvoid cam(inout vec3 p) {\n\n  p.yz *= rot(0.3 + sin(time*0.3)*0.17);\n  p.xz *= rot(time*0.2 + curve(time, 5.2)*2.0);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(0,0,-50.0 - curve(time, 2.3)*10.0);\n  vec3 r = normalize(vec3(-uv, 0.5+0.3*curve(time, 1.3)));\n\n  cam(s);\n  cam(r);\n\n#if TEST_RAYMARCH\n  // Classic raymarching for test\n  vec3 p = s;\n  for(int i=0; i<150; ++i) {\n    float d = map(p);\n    if(d<0.001) break;\n    p+=r*d*0.5;\n    //p+=r*1;\n  }\n  vec2 off=vec2(0.01,0.0);\n  vec3 n = normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  vec3 id = vec3(1);\n  float t = length(p-s);\n  float fog = 1.0-pow(clamp(t/200.0,0.0,1.0), 2.0);\n#else\n\n  // Voxel stepping: 3D DDA\n\n  vec3 p = floor(s);\n  vec3 ri = 1.0/r;\n  vec3 rs = sign(r);\n  // find next 3 inner plane\n  vec3 offset = 0.5 + rs * 0.5;\n  // position of the next voxel\n  vec3 nextplane = p + offset;\n  // intersect with it\n  // this is the distance to the next voxel plane of the 3 axis\n  vec3 dist = (nextplane - s) * ri;\n\n  vec3 nearestaxis = vec3(0.0);\n  const int steps = MARCH_STEPS;\n  for(int i=0; i<steps; ++i) {\n\n    // break if the voxel is inside the surface\n    float curdist = map(p);\n    if(curdist<0.0) break;\n\n    // this will select an axis as the next one (1,0,0) or (0,1,0) or (0,0,1)\n    // it's depending on the smallest distance to the next plane\n    nearestaxis = step(dist.xyz, dist.yzx) * step(dist.xyz, dist.zxy);\n\n    // compute distance to the next voxel\n    dist += nearestaxis * rs * ri;\n\n    // step one around the selected axis\n    p += nearestaxis * rs;\n  }\n\n  // the center of the intersected voxel\n  vec3 id = p;\n  \n  // Get the 3 outer planes of the voxel\n  vec3 voxelpos = p + 1.0 - offset;\n  // Get the distance to the 3 planes\n  vec3 intersection = (voxelpos - s) * ri;\n  // Get the final distance, the biggest of the 3 planes\n  float t = max(intersection.x, max(intersection.y, intersection.z));\n\n  float maxdist = float(steps) / sqrt(3.0);\n\n  t = min(t, maxdist);\n\n  // final pixel intersection position\n  p = s + t*r;\n\n  float fog = 1.0-pow(clamp(t/maxdist,0.0,1.0), 2.0);\n  \n  // Compute the normal\n  vec3 n = (p-id-0.5)*2.0;\n  n = pow(abs(n),vec3(8.0)) * sign(n);\n  n = normalize(n);\n\n#endif\n\n  vec3 l = normalize(vec3(-1,-3,-2));\n  float f = pow(1.0-abs(dot(n,r)), 5.0);\n\n  vec3 base = mix(vec3(0.3), vec3(1,1,0.5), step(noise(id*0.3),0.5));\n  base = mix(base, vec3(0.5,1.0,0.5), step(id.y,-4.0));\n  base = mix(base, vec3(1.0,0.2,0.2)*1.0, mapid);\n  float clselect = step(id.y,-29.0) * (1.0-mapid);\n  if(clselect>0.5) n=-n;\n  base = mix(base, vec3(0.5,0.5,1.0)*100.0, clselect);\n\n  vec3 diff = base*(rnd(id) * 0.5+0.5);\n\n  vec3 col = vec3(0);\n  //col += (dot(n,l)*0.5+0.5);\n  \n  float ao = (getao(p,n,10.0) * 0.9+0.1) * (getao(p,n,3.0)*0.5+0.5);\n\n  col += diff * (dot(n,l)*0.5+0.5)*min(1.0,30.0*fog/t);\n  col += diff * f * fog;\n\n  col *= vec3(5.0*ao);\n  \n  col += exp(t*0.06) * 0.0005 * vec3(0.5,0.6,1.0);\n\n\n  col *= pow(max(0.0,1.1-length(uv*vec2(0.8,1.7))),1.5);\n\n  col = pow(col, vec3(0.4545));\n\n  //col = vec3(noise(vec3(uv*50,time)));\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}