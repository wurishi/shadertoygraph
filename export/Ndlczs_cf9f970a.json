{"ver":"0.1","info":{"id":"Ndlczs","date":"1642541108","viewed":598,"name":"sparkle commented","username":"wnu","description":"basically I just added floor(pos*layers)/layers to the glints from https://www.shadertoy.com/view/ll2fzt so that they stay a little longer to be more glitter-like\n\ncan make the individual glitter bigger and smaller on line 154","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["glints"],"hasliked":0,"parentid":"7dlyzX","parentname":"sparkle ball"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Credit to https://www.shadertoy.com/view/XdlXDn xwize for the raymarching\n//Credit to https://www.shadertoy.com/view/ll2fzt tachyonflux for the glints\n//gold color function derived from https://www.shadertoy.com/view/WlSGWw nabr\n\n//basically i just added floor(pos*layers)/layers to the glints so that they stay a little longer\n\n///RAYMARCHING UTILS\nhighp float Time;\n\nconst highp float PI = 3.1415926;\nconst highp float INV_PI = 1.0/PI;\nconst highp float PI_2 = PI * 2.0;\n\nconst highp float MARCH_EPS = 0.065;\nconst highp float GRAD_EPS = 0.005;\n\nstruct sdv\n{\n    highp float d;\n    highp int idx;\n};\n\nstruct rayHit\n{\n    highp vec3 p;\n    highp int idx;\n};\n\nsdv combine(sdv a, sdv b)\n{\n    if(a.d < b.d)\n    {  \n        return a;\n    }\n    return b;\n}\n\nconst int IDX_ROOM = 1;\nconst int IDX_ROOM_BOTTOM = 2;\nconst int IDX_SPHERE = 3;\n\nsdv scene(highp vec3 p)\n{\n    sdv sphere;\n    sphere.idx = IDX_SPHERE;\n\n\tvec3 c = vec3(0.0,0.0,0.0);\n\tfloat r = 24.0 + 0.5*(sin(0.05*p.x*p.y+iTime*1.0));\n\tsphere.d = length(p-c) - r;\n\t\n    return sphere;\n}\n\nhighp vec3 sceneGrad(highp vec3 p)\n{\n    const highp float h = GRAD_EPS;\n    highp vec3 g;\n    g.x = scene(p+vec3(h,0.0,0.0)).d - scene(p-vec3(h,0.0,0.0)).d;\n    g.y = scene(p+vec3(0.0,h,0.0)).d - scene(p-vec3(0.0,h,0.0)).d;\n    g.z = scene(p+vec3(0.0,0.0,h)).d - scene(p-vec3(0.0,0.0,h)).d;\n    return g / (2.0*h);\n}\n\nrayHit rayQuery(highp vec3 start, highp vec3 dir)\n{\n    highp float d = 0.0;\n    const highp float eps = MARCH_EPS;\n    const int numIter = 76;\n    \n    for(int i = 0; i < numIter; ++i)\n    {\n        highp vec3 p = start + dir * d;\n        sdv v = scene(p);\n        if(v.d < eps)\n        {\n            rayHit ret;\n            ret.idx = v.idx;\n            ret.p = p;\n            return ret;\n        }\n        \n        d += v.d;\n    }\n    \n    rayHit ret;\n    ret.idx = -1;\n    ret.p = vec3(0.0);\n    return ret;\n}\n\nhighp mat4 lookAtInv(highp vec3 eyePos, highp vec3 targetPos, highp vec3 upVector)\n{\n    highp vec3 forward = normalize(targetPos - eyePos);\n    highp vec3 right = normalize(cross(forward,upVector));\n    upVector = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(upVector,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\n// COLORING THE OBJECT\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel1, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\nhighp vec3 computeColor(highp vec3 camPos, highp vec3 camDir)\n{\n    rayHit q = rayQuery(camPos,camDir);\n    if(q.idx >= 0)\n    {\n        highp vec3 normal = normalize(sceneGrad(q.p));\n        float t = iTime;\n        vec3 n = normal;\n        \n        /////BASE COLOR\n        \n        //FRESNEL \n        \n        float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n        float edge = sqrt(1.2-pow(fre,1./4.2));\n        \n        \n        //PICK YOUR COLOR\n        \n        vec3 colorPick = vec3(.65, .45, 0.);\n        \n        //COLOR FROM NORMALS AND FRESNEL\n        \n        vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.y + t*0.+  colorPick);\n        float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n        c *= ss;\n        \n        ///////GLINTS/GLITTER COMPUTATION\n        \n        #define PRIMARY_INTENSITY 0.3\n        #define PRIMARY_CONCENTRATION 6.\n        #define SECONDARY_INTENSITY 5.\n        #define SECONDARY_CONCENTRATION 0.9\n\n        // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n        // (7 is probably the smallest I would go)\n        \n        float scale = 10.;\n        q.p = floor(q.p*scale)/scale;\n        \n        vec3 ligt = vec3(1.);\n        vec3 h = normalize(ligt-camDir);\n        float nl = dot(n,ligt);\n        \n        vec3 coord = q.p*.5;\n        coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n        coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n        vec3 coord2 = coord;\n        \n        //first layer (inner glints)\n        float pw = .5*((iResolution.x));\n        vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n        aniso -= n*dot(aniso,n);\n        float anisotropy = min(1.,length(aniso));\n        aniso /= anisotropy;\n        anisotropy = .55;\n        float ah = abs(dot(h,aniso));\n        float nh = abs(dot(n,h));\n        float qa = exp2((1.1-anisotropy)*3.5);\n        nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n        nh *= pow( 1.-ah*anisotropy, 10.0 );\n        vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n        //second layer (outer glints)\n        pw = .145*((iResolution.x));\n        vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n        anisotropy = .6;\n        float ah2 = abs(dot(h,aniso2));\n        float nh2 = abs(dot(n,h));\n        float q2 = exp2((.1-anisotropy)*3.5);\n        nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n        nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n        vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n           \n        ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n           \n        vec3 col;\n        col = vec3(c)/2.;\n        col += (glints+glints2);\n\n        return col;\n    }\n\t\n    return texture(iChannel0,camDir).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tTime = iTime;\n\t\n\thighp vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n    \n    //RAYMARCHING STUFF\n\n\tfloat r = 120.0;\n\tfloat s = 0.;\n    float a = 1.2;\n\thighp mat4 m = lookAtInv(vec3(r*cos(Time*s + a),sin(Time*s + a)*50.0,r*sin(Time*s+a)),vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n\thighp float sw = 0.0;\n\t\n\tconst highp float aspect = 2.0;\n\thighp vec3 camPos = vec3((uv.x-0.5)*aspect,uv.y-0.5,-30.);\n\thighp vec3 camDir = normalize(vec3(aspect*(uv.x-0.5),uv.y-0.5,-1.5-sw));\n\n    camPos = ( m * vec4(camPos,1.0) ).xyz;\n    camDir = ( m * vec4(camDir,0.0) ).xyz;\n    \n    //RESULTING COLOR\n    \n    vec3 col = computeColor(camPos,camDir);\n    fragColor = vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}