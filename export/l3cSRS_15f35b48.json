{"ver":"0.1","info":{"id":"l3cSRS","date":"1719207336","viewed":55,"name":"Seascape with Eclipse","username":"mashquapp","description":"original by TDM: https://www.shadertoy.com/view/Ms2SD1\nadded a sun with a moon to eclipse it based on https://www.shadertoy.com/view/l33Xzn\ntotal eclipse from 15.25 - 20.75 seconds (peak at 18)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","waves","sea","water","sky","eclipse","subsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Seascape with Eclipse\" by mashquapp - 2024\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Original by TDM: https://www.shadertoy.com/view/Ms2SD1\n * Changes made: Modified to include sun and eclipse simulation\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n//#define AA\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n//sky\nconst float r1 = 20.0;\nconst float r2 = 23.0;\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s, float brightness) {    \n    float nrm = brightness * (s - 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\n\nvec2 skyCoord(vec2 xy) {\n    return xy - 0.5 * iResolution.xy;\n}\nvec2 denormalize(vec2 xy) {\n    return xy * iResolution.xy;\n}\nfloat rmod(float rad) {\n    return mod(rad, 2.0 * PI);\n}\n\nvec3 getSeaSkyColor(vec3 e, vec2 xy, out float brightness) {\n    vec2 uvSky = skyCoord(xy);\n    \n    float dist = length(denormalize(vec2(0.0004 * (iTime - 18.0 - uvSky.x / iResolution.x), 0.0004 * (iTime - 18.0 - uvSky.x / iResolution.x))));\n    float perimeter = sqrt((dist+r1+r2)*(-dist+r1+r2)*(dist-r1+r2)*(dist+r1-r2));\n    float rDiff = r1*r1 - r2*r2;\n    float sunTheta = acos((dist*dist + rDiff)/(2.0*dist*r1));\n    float moonTheta = acos((dist*dist - rDiff)/(2.0*dist*r2));\n    \n    brightness = (dist + r1 <= r2)?\n                           0.0 : \n                           (r2 + r1 <= dist)?\n                               1.0 : \n                               (dist + r2 <= r1)? \n                                   1.0 - (r2 * r2) / (r1 * r1) : \n1.0 - (r1*r1*sunTheta + r2*r2*moonTheta - 0.5*perimeter) / (PI*r1*r1);\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * (brightness + 0.1);\n}\n\nvec3 getSeaSkyColor(vec3 e, vec2 xy) {\n    vec2 uvSky = skyCoord(xy);\n    \n    float dist = length(denormalize(vec2(0.0004 * (iTime - 18.0 - 4.0 * uvSky.x / iResolution.x), 0.0004 * (iTime - 18.0 - 4.0 * uvSky.x / iResolution.x))));\n    float perimeter = sqrt((dist+r1+r2)*(-dist+r1+r2)*(dist-r1+r2)*(dist+r1-r2));\n    float rDiff = r1*r1 - r2*r2;\n    float sunTheta = acos((dist*dist + rDiff)/(2.0*dist*r1));\n    float moonTheta = acos((dist*dist - rDiff)/(2.0*dist*r2));\n    \n    float brightness = (dist + r1 <= r2)?\n                           0.0 : \n                           (r2 + r1 <= dist)?\n                               1.0 : \n                               (dist + r2 <= r1)? \n                                   1.0 - (r2 * r2) / (r1 * r1) : \n1.0 - (r1*r1*sunTheta + r2*r2*moonTheta - 0.5*perimeter) / (PI*r1*r1);\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * (brightness + 0.1);\n}\n\nvec3 getSkyColor(vec3 e, vec2 xy) {\n    vec2 uvSky = skyCoord(xy);\n    \n    vec2 sunPos = denormalize(vec2(0.0016 * (iTime - 18.0), 0.3 + 0.0016 * (iTime - 18.0)));\n    vec2 moonPos = denormalize(vec2(0.002 * (iTime - 18.0), 0.3 + 0.002 * (iTime - 18.0)));\n    vec2 sunPosDelay = denormalize(vec2(0.0016 * (iTime - 18.0 - 4.0 * uvSky.x / iResolution.x), 0.3 + 0.0016 * (iTime - 18.0 - 4.0 * uvSky.x / iResolution.x)));\n    vec2 moonPosDelay = denormalize(vec2(0.002 * (iTime - 18.0 - 4.0 * uvSky.x / iResolution.x), 0.3 + 0.002 * (iTime - 18.0 - 4.0 * uvSky.x / iResolution.x)));\n    float uvSunDist = length(uvSky - sunPos); // distance from pixel to sun\n    float uvMoonDist = length(uvSky - moonPos); // distance from pixel to moon\n    float dist = length(moonPos - sunPos); // distance from sun to moon\n    float distDelay = length(moonPosDelay - sunPosDelay);\n    \n    float perimeter = sqrt((dist+r1+r2)*(-dist+r1+r2)*(dist-r1+r2)*(dist+r1-r2)); // perimeter of any triangle formed with side lengths dist, r1, and r2\n    float perimeterDelay = sqrt((distDelay+r1+r2)*(-distDelay+r1+r2)*(distDelay-r1+r2)*(distDelay+r1-r2));\n    float rDiff = r1*r1 - r2*r2;\n    float theta = atan(moonPos.y - sunPos.y, moonPos.x - sunPos.x); // direction of vector sunPos -> moonPos\n    float sunTheta = acos((dist*dist + rDiff)/(2.0*dist*r1)); // if sun is a crescent, this is the angle between vector theta and the vector sunPos -> either corner of the crescent\n    float moonTheta = acos((dist*dist - rDiff)/(2.0*dist*r2)); // if sun is a crescent, this is the angle between vector -theta and the vector moonPos -> either corner of the crescent\n    float sunThetaDelay = acos((distDelay*distDelay + rDiff)/(2.0*distDelay*r1));\n    float moonThetaDelay = acos((distDelay*distDelay - rDiff)/(2.0*distDelay*r2));\n    \n    float brightness = (dist + r1 <= r2)? //percent of sun exposed\n                           0.0 : \n                           (r2 + r1 <= dist)?\n                               1.0 : \n                               (dist + r2 <= r1)? \n                                   1.0 - (r2 * r2) / (r1 * r1) : \n1.0 - (r1*r1*sunTheta + r2*r2*moonTheta - 0.5*perimeter) / (PI*r1*r1); // if sun is a crescent, this is finding the area of that crescent\n\n    float brightnessDelay = (distDelay + r1 <= r2)? //percent of sun exposed\n                           0.0 : \n                           (r2 + r1 <= distDelay)?\n                               1.0 : \n                               (distDelay + r2 <= r1)? \n                                   1.0 - (r2 * r2) / (r1 * r1) : \n1.0 - (r1*r1*sunThetaDelay + r2*r2*moonThetaDelay - 0.5*perimeterDelay) / (PI*r1*r1);\n    \n    vec2 rPoint = sunPos + r1 * vec2(cos(theta - sunTheta), sin(theta - sunTheta)); // if sun is a crescent, this is calculating the right-most (relative to the sun) corner of the crescent\n    vec2 lPoint = sunPos + r1 * vec2(cos(theta + sunTheta), sin(theta + sunTheta)); // if sun is a crescent, this is calculating the left-most (relative to the sun) corner of the crescent\n    \n    float crescentDist;\n    if (r2 + r1 <= dist) {                              // crescentDist represents a signed distance function to the sun for each of its shapes\n        crescentDist = uvSunDist - r1;\n    }\n    else {\n        if (dist + r2 <= r1) {\n            if (uvSunDist + uvMoonDist <= r1 + r2) {\n                crescentDist = r2 - uvMoonDist;\n            } else {\n                crescentDist = uvSunDist - r1;\n            }\n        }\n        else {\n            if (dist + r1 <= r2) {\n                crescentDist = 1.0;\n            }\n            else {\n                if (uvMoonDist < r2 && abs(rmod(rmod(atan(uvSky.y - moonPos.y, uvSky.x - moonPos.x) - PI) - theta - PI) - PI) < moonTheta) {\n                    crescentDist = r2 - uvMoonDist;\n                }\n                else {\n                    if (uvSunDist > r1 && abs(rmod(rmod(atan(uvSky.y - sunPos.y, uvSky.x - sunPos.x) - PI) - theta) - PI) > sunTheta) {\n                        crescentDist = uvSunDist - r1;\n                    }\n                    else {\n                        crescentDist = min(length(uvSky - rPoint), length(uvSky - lPoint));\n                    }\n                }\n            }\n        }\n    }\n    \n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    \n    vec3 col = (uvSunDist <= r1 && uvMoonDist > r2)? \n                   vec3(1.0) : \n                   vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * brightnessDelay +\n                   vec3(0.25, 0.2, 0.0) * (0.5 - 1.5 * e.y) +\n                   vec3(0.25, 0.1, 0.0) * max((1.0 - 3.5 * e.y) * (1.0 - 3.5 * e.y), 0.0) +\n                   vec3(0.06, 0.09, 0.1) + \n                   pow(brightness, 0.02) * min(1.0, pow(0.5, 0.03 * (0.3 + 0.5 * brightness) * crescentDist));\n    \n    if (uvMoonDist > r2 && uvSunDist > r1) {\n        col += pow(max(0.0, 5.0 / (uvSunDist - r1) - 0.05), 1.5) + vec3(max(0.25 - brightness, 0.0)) * step(0.93, noise(7.45 * uvSky));\n    }\n\n    return col;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist, vec2 coord) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = min(pow(fresnel,3.0), 0.5);\n    float brightness;\n        \n    vec3 reflected = getSeaSkyColor(reflect(eye,n), coord, brightness);    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel) * (0.2 + 0.8 * brightness);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten * brightness;\n    \n    color += vec3(specular(n,l,eye,60.0, brightness));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;   \n    }\n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time + 1.0);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(cos(time - 0.6 + 0.003 * (iTime - 18.0)),0.3,sin(time - 0.6 + 0.003 * (iTime - 18.0)))); \n             \n    // color\n    return (dir.y > 0.0)? getSkyColor(dir, coord) : mix(\n        getSeaSkyColor(dir, coord),\n        getSeaColor(p,n,light,dir,dist, coord),\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = 17.8;\n\t\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\n    \t\tcolor += getPixel(uv, time);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\n}","name":"Image","description":"","type":"image"}]}