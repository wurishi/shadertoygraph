{"ver":"0.1","info":{"id":"4t3XzS","date":"1480120675","viewed":232,"name":"Simplistic Sea","username":"VoidChicken","description":"The simplistic sea with clouds. Basically that's it. Relatively laggy for average gpus.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","clouds","volumetric","vignette","hdr","reinhard","chicken","tonemap","simplistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R vec3(iResolution.xy,1)\n#define MIN1(a,b) (a.x<b.x?a:b)\nvec3 vignette( vec2 uv, vec3 color )\n{\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\n\t\n\tfloat dst = dot(offset,offset);\n\t\n\tconst float str = 0.95;\n\tconst float powr = 1.5;\n\n\treturn color * ((1.0 - str) +  str * pow(1.0 - dst, powr));\n}\nvec2 map ( vec3 p ) {\n    float t = 1.,t2=5.;\n    float h = sin(p.x+iTime*t)+sin(p.z+iTime*t);\n       h*=sin(iTime*t2+p.x+p.y);\n    h/=10.;\n    vec2 f = \n        vec2(\n            p.y+h,\n            0);\n    return f;\n}\nvec3 normal( in vec3 x)\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,\n                            map(x+e.yxy).x - map(x-e.yxy).x,\n                            map(x+e.yyx).x - map(x-e.yyx).x ) );\n}\nfloat noise1( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat noise (vec3 pos) {\n    float f = 0.;\n    vec3 q = pos;\n            f  = 0.5000*noise1( q ); q = q*2.01;\n            f += 0.2500*noise1( q ); q = q*2.02;\n            f += 0.1250*noise1( q ); q = q*2.03;\n            f += 0.0625*noise1( q ); q = q*2.01;\n    return f;\n}\n\nvec3 camera = vec3(0,2,-6.);\nvec3 sky (vec3 u) {\n\tvec3 skyC = mix( vec3(0.01, 0.1, 0.4), vec3(0.2, 0.5, 0.6) * 5.0, u.y/2.+.5);    \n    vec3 skyC2 = skyC;\n    \n    float d = 8./u.y;\n    if (u.y>.0){\n        for (int i = 0; i < 32; i++) {\n            float diff = .25/u.y;\n            d+=diff;\n            vec3 v = u;\n            v.y*=2.;\n            float f = noise(camera+v/5.*d+iTime/5.);\n            f+=noise(camera+v/5.*d-iTime/5.);\n            f=pow(f,5./diff);\n            skyC2+=(sqrt(float(i))*f*(1./d));\n        }\n    }\n    return mix(skyC, skyC2, 1.1-clamp(d/75.,.1,1.));\n}\nfloat trace (vec3 o, vec3 d) {\n    float t = 0.;\n    for (int i = 0; i < 100; ++i) {\n        if(t>30.)break;\n   \t\tt+=map(o+d*t).x; \n    }\n    return t;\n}\nconst float pi = acos(-1.);\nvec3 shade(vec3 i, vec3 dr) {\n    vec2 d = map(i);\n    vec3 c = vec3(1);\n    vec3 n = normal(i);\n    if (d.y==0.) {\n        vec3 r = reflect(dr,n);\n        float fres = dot(n,-dr);\n        c=mix((sky(r)/7.+1.)*vec3(1,1.2,4),vec3(0,.5,8),fres/2.);\n    }\n   \n    return c;\n}\nvec3 render (vec2 u)     \n{\n    camera.z+=iTime;\n    vec3 o = camera;\n    vec3 d = normalize(vec3((u*2.-1.)*(R.xz/R.yz),1));\n    vec3 c = sky(d);\n    \n    \n    float t = trace(o,d);\n    \n    vec3 i = o+d*t;\n    if (map(i).x<.02) {\n     \tc = mix(shade(i,d),c,t/30.);   \n       \t\n    }\n    \n    //vignetting\n    c=vignette( u, c );\n    \n    \n    //Reinhard Exposure & gamma correction\n   \tc/=c+1.;\n    c=pow(c,vec3(1./2.2));\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/R.xy;\n\tfragColor = vec4(render(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}