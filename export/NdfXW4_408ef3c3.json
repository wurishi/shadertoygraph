{"ver":"0.1","info":{"id":"NdfXW4","date":"1618607534","viewed":540,"name":"Lone Buoy","username":"MatthieuJacquemet","description":"simple ocean scene with yellow buoy","likes":30,"published":1,"flags":0,"usePreview":1,"tags":["waves","sea","water","ocean","sky","buoy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jacquemet Matthieu\n\n// Contants --------------------------------------------------------------------------------------------\nconst float PI   = 3.141592653589793238462643383279502884197169;\nconst float PI_2 = 1.570796326794896619231321691639751442098585;\nconst float PI_4 = 0.785398163397448309615660845819875721049292;\n\nconst int MAX_STEPS = 100;      // Number of steps\nconst int WAVE_OCTAVES = 12;\nconst int WAVE_NORMAL_OCTAVES = 32;\nconst float EPSILON = 0.001; // Marching epsilon\nconst float K = 1.0;\nconst float WATER_LEVEL = 0.0;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct TraceData {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float metallic;\n};\n\n\n#define TONEMAP_LINEAR 0 \n#define TONEMAP_FILMIC 1\n#define TONEMAP_REINHARD 2\n#define TONEMAP_FILMIC_REINHARD 3\n#define TONEMAP_UNCHARTED2 4\n#define TONEMAP_ACES 5\n\n#define MATERIAL_PLASTIC 0\n#define MATERIAL_BUOY 1\n#define MATERIAL_WATER 2\n#define MATERIAL_BEACON 3\n#define MATERIAL_METAL 4\n#define MATERIAL_BLACK_PLASTIC 5\n\n\n#define SPECULAR_GGX 0\n#define SPECULAR_BLINN 1\n#define SPECULAR_BECKMANN 2\n\n#define SPECULAR_MODE SPECULAR_GGX\n#define TONEMAP_MODE TONEMAP_ACES // Tone mapping mode\n#define _DEBUG 0               // set 1 to enable debuging\n\n\n\n#if _DEBUG\n    vec3 _debug_color;\n    bool _is_debug = false;\n    #define DEBUG(color) if (_is_debug) _debug_color = color; // use this to debug a color\n    #define CATCH_DEBUG(expr) _is_debug = true; expr ; _is_debug = false;\n#else\n    #define DEBUG(color)\n    #define CATCH_DEBUG(expr) expr // any call to DEBUG(color) in this macro will output de color\n#endif\n\nbool _trace_ocean = true;\nmat4 buoy_trans;\n\n#define NO_TRACE_OCEAN(expr) _trace_ocean = false; expr ; _trace_ocean = true;\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u)* vec2(cos(a), sin(a)), u) );\n}\n\n\n// saturate\nfloat sat(float x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// saturate\nvec3 sat(vec3 x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// Map value from [Imin, Imax] to [Omin, Omax]\nfloat map(float value, float Imin, float Imax, float Omin, float Omax) {\n  \n  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);\n}\n\nfloat dot2(in vec2 v) {\n    \n    return dot(v,v);\n}\n\nfloat dot2(in vec3 v) {\n    \n    return dot(v,v);\n}\n\n// Tranforms --------------------------------------------------------------------\n\n// Translate point p\nvec3 Translate(vec3 pos, vec3 p) {\n\n    return p - pos;\n}\n\n// Scale point p\nvec3 Scale(vec3 scale, vec3 p) {\n\n    return vec3(p.x/scale.x, p.y/scale.y, p.z/scale.z);\n}\n\n// Rotate point p around X axis (radians)\nvec3 RotateX(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Y axis (radians)\nvec3 RotateY(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3( _cos,    0,  -_sin,\n                    0,      1,      0,\n                   _sin,    0,   _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Z axis (radians)\nvec3 RotateZ(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  _cos,  -_sin,   0,\n                    _sin,   _cos,   0,\n                    0,      0,      1);\n\n    return M*p;\n}\n\n// Rotate point p\nvec3 Rotate(vec3 rot, vec3 p)\n{\n    p = RotateX(rot.x, p);\n    p = RotateY(rot.y, p);\n    p = RotateZ(rot.z, p);\n\n    return p;\n}\n\n\n// Create scaling matrix\nmat3 Scaling(vec3 scale) {\n\n    return mat3(1.0/scale.x,0,          0,\n                0,          1.0/scale.y,0,\n                0,          0,          1.0/scale.z);\n}\n\n// Create rotation matrix for theta angle around X axis (radians)\nmat3 RotationX(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(    1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n}\n\n// Create rotation matrix for theta angle around Y axis (radians)\nmat3 RotationY(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3( _cos,     0, -_sin,\n                    0,     1,     0,\n                 _sin,     0,  _cos);\n}\n\n// Create rotation matrix for theta angle around Z axis (radians)\nmat3 RotationZ(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(_cos, -_sin,  0,\n                _sin,  _cos,  0,\n                0,     0,     1);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(float x, float y, float z) \n{\n    return RotationZ(z) * RotationY(y) * RotationX(x);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(vec3 rot)\n{\n    return Rotation(rot.x, rot.y, rot.y);\n}\n\n// Create translation matrix\nmat4 Translation(vec3 trans) {\n\n    mat4 M = mat4(1.0);\n    M[3] = vec4(-trans, 1.0);\n\n    return M;\n}\n\n// Create transform matrix \nmat4 Transform(vec3 scale, vec3 rot, vec3 trans) \n{\n    return mat4(Scaling(scale) * Rotation(rot)) * Translation(trans);\n}\n\n// Transform of point p\nvec3 Transform(vec3 scale, vec3 rot, vec3 trans, vec3 p)\n{\n    p = Scale(scale, p);\n    p = Rotate(rot, p);\n    p = Translate(trans, p);\n\n    return p;\n}\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// adated from https://iquilezles.org/articles/smoothvoronoi\nfloat SmoothVoronoi( in vec2 x )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2  r = vec2( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        res += 1.0/pow( d, 8.0 );\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n// based on https://www.shadertoy.com/view/llG3zy\nvec3 VoronoiE( in vec3 x )\n{\n    vec3 n = floor(x);\n    vec3 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec3 mr;\n\n    float md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n        vec3 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n\t\tvec3 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n\n// Fractal brownian motion\nfloat Fbm(vec3 p, int octaves) {\n\n    float v = 0.0,  a = 0.5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octaves; ++i, p*=2.0, a/=2.0) { \n        p *= R;\n        v += a * Noise(p);\n    }\n\n    return v;\n}\n\n// Voronoi fractal brownian motion\nvec3 FbmVoronoi(vec3 p, int octave) {\n\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octave; ++i, p*=2.0, a/=2.0) {\n        p *= R;\n        v += a * Voronoi(p);\n    }\n\n    return v;\n}\n\n\n// Camera -----------------------------------------------------------------------\n\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nmat3 Camera(in vec2 m, out vec3 ro)\n{\n    // position camera\n    ro=vec3(-3.0,0.0,0.0);\n    \n    // reset camera position\n    // shadertoy initialize mouse position at (0,0)\n    if (m == vec2(0))\n        m = vec2(0.9, -0.3);\n    else\n        m = (m*2.0 - vec2(1.0))*3.0;\n\n    m.y = clamp(-m.y, -0.05, PI_2 - 0.1); // clamp camera's y rotation\n\n    ro = RotateY(m.y, ro);\n    ro = RotateZ(m.x, ro);\n\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\treturn mat3(uu, vv, ww);\n}\n\n\n\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nTraceData Sphere(vec3 p, vec3 c,float r,int index)\n{\n    return TraceData(length(p-c)-r,index);\n}\n\n\nTraceData Box(vec3 point, vec3 box, int tex) {\n\n  vec3 q = abs(point) - box;\n  float v = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return TraceData(v, tex);\n}\n\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nTraceData Plane(vec3 p, vec3 n, vec3 o, int index)\n{\n    return TraceData(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nTraceData Union(TraceData a,TraceData b)\n{\n    if (a.v < b.v)\n        return a;\n    else \n        return b;\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nTraceData Inter(TraceData a,TraceData b)\n{\n    if (a.v > b.v)\n        return a;\n    else \n        return b;\n}\n\n\n// Difference, preserve the index of first object\n// a, b : field function of left and right sub-trees\nTraceData Diff(TraceData a, TraceData b) {\n\n    return Inter(a, TraceData(-b.v, b.i));\n}\n\n\n\n// https://iquilezles.org/articles/distfunctionsl\n\n// Union with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothUnion( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b.v-a.v)/k, 0.0, 1.0 );\n    return TraceData(mix( b.v, a.v, h ) - k*h*(1.0-h), a.i);\n}\n\n// Difference with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothDiff( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(a.v+b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, -b.v, h ) + k*h*(1.0-h), a.i); \n}\n\n// Intersection with smoothing\n// a : field function of left sub-tree, \n// b : field function of right sub-tree\nTraceData SmoothInter( TraceData a, TraceData b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a.v-b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, b.v, h ) + k*h*(1.0-h), a.i);\n}\n\n\nfloat almostIdentity( float x, float n )\n{\n    return sqrt(x*x+n);\n}\n\nfloat Overlay(in float a, in float b) {\n\n    if (a  < 0.5)\n        return 2.0*a*b;\n    else\n        return 1.0 - 2.0*(1.0-a)*(1.0-b);\n}\n\n\n\nTraceData Segment(vec3 point, vec3 a, vec3 b, int tex) {\n\n    vec3 ba = b-a;\n    vec3 pa = point-a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    vec3 c = ba*clamp(t, 0.0, 1.0);\n    \n    return TraceData(length(pa - c), tex);\n}\n\n\nTraceData Capsule(vec3 point, vec3 a, vec3 b, float radius, int tex) {\n\n    return TraceData(Segment(point, a, b, tex).v - radius, tex);\n}\n\n\nTraceData Cylinder(vec3 point, vec3 a, vec3 b, float radius, int tex) {\n\n    TraceData caps = Capsule(point, a, b, radius, tex);\n    TraceData plane = Plane(point, normalize(a-b), b, tex);\n\n    TraceData d = Diff(caps, plane);\n    \n    return Diff(d, Plane(point, normalize(b-a), a, tex));\n}\n\n\n// based on https://iquilezles.org/articles/distfunctions/distfunctions.html\nTraceData RoundedCylinder(vec3 point, float radius, float k, float h, int tex)\n{\n    vec2 d = vec2( length(point.xy) - 2.0 * radius + k, abs(point.z) - h);\n    float v = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - k;\n\n    return TraceData(v, tex);\n}\n\n\n// based on https://iquilezles.org/articles/distfunctions/distfunctions.html\nTraceData CappedCone(vec3 p, float h, float r1, float r2, int tex)\n{\n    vec2 q = vec2( length(p.xy), p.z );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    s *= sqrt(min(dot2(ca),dot2(cb)));\n\n    return TraceData(s, tex);\n}\n\nTraceData Circle(vec3 point, float radius, int tex)\n{\n    vec2 p;\n    p.x = length(point.xy) - radius;\n    p.y = point.z;\n\n    return TraceData(length(p), tex);\n}\n\n\nTraceData Torus(vec3 point, float radius, float r, int tex)\n{\n    TraceData vp = Circle(point, radius, tex);\n    vp.v -= r;\n    return vp;\n}\n\n\n// based on https://iquilezles.org/articles/distfunctions/distfunctions.html\nTraceData TriPrism(vec3 p, vec2 h, int tex)\n{\n    vec3 q = abs(p);\n    float v = max(q.x-h.y,max(q.z*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    return TraceData(v, tex);\n}\n\n\n// based on https://iquilezles.org/articles/distfunctions/distfunctions.html\nTraceData Ellipsoid(vec3 p, vec3 r, int tex)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    float v = k0*(k0-1.0)/k1;\n    return TraceData(v, tex);\n}\n\n\nfloat Troichoid(in float x, in float t) {\n\n    float A = 0.5 + 0.4 * sin(0.1 * t * 2.0 * PI);\n    return A - 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(x), A + 1.0), 1.0 / (A + 1.0));\n}\n\n\n\nvec2 Wave(vec2 p, vec2 d, float speed, float frequency, float phase) {\n\n    float x = dot(d, p) * frequency + phase * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\n\nfloat Ocean(in vec2 p, in int octaves) {\n    \n    p *= 0.7;\n    \n    mat2 R = mat2(RotationZ(12.0));\n    vec2 dir = vec2(0,1);\n\n    float freq = 6.0;\n    float speed = 2.0;\n    float w = 1.0;\n    float s = 0.0;\n    float h = 0.0;\n\n    for(int i=0; i<octaves; i++){\n        vec2 res = Wave(p, dir, speed, freq, iTime);\n        p += dir * w * res.y * 0.038;\n        h += res.x * w;\n        s += w;\n        w = mix(w, 0.0, 0.2);\n        freq *= 1.18;\n        speed *= 1.07;\n        dir *= R;\n    }\n    return h / s * 0.2;\n}\n\n\nTraceData ImplicitOcean(in vec3 p)\n{\n    float z = Ocean(p.xy, WAVE_OCTAVES);\n    float h = p.z - z;\n\n    return TraceData(h, MATERIAL_WATER);\n}\n\n\nTraceData RoundCone(vec3 p, float r1, float r2, float h, int tex)\n{\n    vec2 q = vec2( length(p.xy), p.z );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    float v;\n\n    if( k < 0.0 ) \n        v = length(q) - r1;\n    else if( k > a*h )\n        v = length(q-vec2(0.0,h)) - r2;\n    else\n        v = dot(q, vec2(a,b)) - r1;\n        \n    return TraceData(v, tex);\n}\n\n\nTraceData SolidAngle(vec3 p, vec2 c, float ra, int tex)\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xy), p.z );\n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    float v = max(l,m*sign(c.y*q.x-c.x*q.y));\n    return TraceData(v, tex);\n}\n\n\nTraceData Frame(in vec3 p, in vec2 size) {\n\n    TraceData frame = Box(p, vec3(vec2(size),0.02), MATERIAL_BUOY);\n    return Diff(frame, Box(p, vec3(vec2(size)-vec2(0.02),0.03), MATERIAL_BUOY));\n}\n\n\nTraceData Propeller(in vec3 p, in int tex) {\n\n    p = RotateY(iTime*10.0, p);\n    vec3 pp = p;\n    pp.y -= 0.02;\n    pp.xz = abs(p.xz);\n    pp = RotateY(-PI_4, pp);\n    pp = RotateZ(0.4, pp);\n    TraceData d = SolidAngle(pp, vec2(0.2955, 0.9553), 0.07, tex);\n    d = Inter(d, Box(pp, vec3(0.1,0.002,0.1), tex));\n\n    TraceData tip = Ellipsoid(p+vec3(0,0.05,0.0), vec3(0.02,0.1,0.02), tex);\n    tip = Inter(tip, Plane(p, vec3(0,-1,0), vec3(0,-0.005,0), tex));\n    d = Union(d, tip);\n\n    return d;  \n}\n\n\nTraceData Anemometer(in vec3 p) {\n\n    TraceData d = Capsule(p, vec3(0,0.05,0), vec3(0,0.05,-0.1), 0.01, MATERIAL_METAL);\n    d = Union(d, Ellipsoid(p, vec3(0.02,0.15,0.02), MATERIAL_METAL));\n    d = Inter(d, Plane(p, vec3(0,1,0), vec3(0,0.07,0), MATERIAL_METAL));\n    d = Union(d, Propeller(p-vec3(0,0.08,0), MATERIAL_BLACK_PLASTIC));\n\n    vec3 tail_p = (p+vec3(0,0.11,0))*vec3(1,2.0,1);\n    TraceData tail = TriPrism(tail_p, vec2(0.1,0.002), MATERIAL_METAL);\n    tail = Inter(tail, Box(p, vec3(0.1,0.3,0.05), MATERIAL_METAL));\n\n    d = Union(d, tail);\n\n    return d;\n}\n\n\nTraceData Buoy(in vec3 p) {\n\n    p = (buoy_trans * vec4(p,1.0)).xyz;\n\n    // base;\n    TraceData base = RoundedCylinder(p, 0.3, 0.05, 0.3, MATERIAL_BUOY);\n    base = Union(base, Cylinder(p, vec3(0), vec3(0,0,0.45), 0.17, MATERIAL_BUOY));\n    base = Union(base, Cylinder(p, vec3(0,0,0.45), vec3(0,0,0.48), 0.2, MATERIAL_BUOY));\n\n    // rig\n    vec3 rig_p = p;\n    rig_p.xy = abs(rig_p.xy);\n    rig_p = RotateZ(PI_4, rig_p);\n    rig_p -= vec3(0.25,0,0.9);\n    rig_p = RotateY(0.15, rig_p);\n    rig_p = RotateZ(PI_4, rig_p);\n\n    TraceData rig = Box(rig_p, vec3(0.02,0.02,0.6), MATERIAL_BUOY);\n    rig = Union(rig, Box(p-vec3(0,0,1.47), vec3(0.13,0.13,0.02), MATERIAL_BUOY));\n    rig = Union(rig, Frame(p-vec3(0,0,0.38), vec2(0.3)));\n    rig = Union(rig, Frame(p-vec3(0,0,1.1), vec2(0.16)));\n    rig.v -= 0.005;\n\n    // beacon\n    TraceData beacon = CappedCone(p-vec3(0,0,1.6), 0.05, 0.040, 0.02, MATERIAL_BEACON);\n    beacon.v -= 0.02;\n    beacon = Union(beacon, Cylinder(p, vec3(0,0,1.45), vec3(0,0,1.55), 0.067, MATERIAL_BLACK_PLASTIC));\n\n    // top part\n    vec3 top_part_p = p;\n    top_part_p.xy = abs(top_part_p.xy);\n    TraceData top_part = Torus(p-vec3(0,0,1.65), 0.25, 0.007, MATERIAL_METAL);\n    \n    top_part = Union(top_part, Capsule(top_part_p, vec3(0.11,0.13,1.45), \n                            vec3(0.11,0.22,1.65), 0.007, MATERIAL_METAL));\n\n    top_part = Union(top_part, Capsule(top_part_p, vec3(0.13,0.11,1.45), \n                            vec3(0.22,0.11,1.65), 0.007, MATERIAL_METAL));\n    \n    top_part = Union(top_part, Anemometer(p-vec3(0.25,-0.05,1.75)));\n    \n    top_part = Union(top_part, Capsule(p, vec3(0.05,0.05,1.2), \n                        vec3(0.05,0.05,1.37), 0.07, MATERIAL_PLASTIC));\n\n    return Union(Union(Union(base, rig), beacon), top_part);\n}\n\n\n// Potential field of the object\n// p : point\nTraceData Object(vec3 p)\n{\n    // p.xy += vec2(-2,12);\n    // p.xy += vec2(0,5);\n    TraceData d = Buoy(p);\n\n    if (_trace_ocean)\n        d = Union(d, ImplicitOcean(p));\n\n    return d;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\nvec3 OceanNormal(in vec2 p, in int octaves, out float h) {\n\n    // vec2 ex = vec2(e, 0);\n    const float epsilon = 0.01;\n\n    h = Ocean(p, octaves);\n\n    float dx = h - Ocean(p + vec2(epsilon, 0), octaves);\n    float dy = h - Ocean(p + vec2(0, epsilon), octaves);\n\n    return normalize(vec3(dx, dy, epsilon));\n}\n\n\n\n// Calculate object normal\nvec3 ComputeNormal(in vec3 p, inout int matID) {\n\n    float h;\n    TraceData vp;\n    \n    if (matID == 0) {\n        vp = Object(p);\n        matID = vp.i;\n    }\n\n    if (matID == MATERIAL_WATER)\n        return OceanNormal(p.xy, WAVE_NORMAL_OCTAVES, h);\n    \n    float eps = 0.001;\n    vec3 n;\n\n    NO_TRACE_OCEAN(\n\n    float v = vp.v;\n    n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n    n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n    n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n\n    )\n\n    return normalize(n);\n}\n\n\nfloat DistToPlane(in vec3 ro, in vec3 rd, in float h) {\n\n    return -(ro.z-h) / rd.z;\n}\n\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n    h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        s=i;\n        vec3 p = o+t*u;\n        float v = Object(p).v;\n        // Hit object\n        if (v < 0.0)\n        {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON, v / K);\n        // Escape marched too far away\n        if (t>e)\n        {\n            break;\n        }\n    }\n\n    return t;\n}\n\n// Lighting ----------------------------------------------------------------------------------------------\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    float energy;\n    float shadow_dist;\n};\n\nDirectionalLight sun;\n\n// Compute ambient occlusion based on https://www.shadertoy.com/view/3lXyWs\n// p : Point\n// n : Normal at point\nfloat AmbientOcclusion(vec3 p,vec3 n) {\n\n    const int AO_STEPS = 4;\n    const float AO_MAX_DIST = 3.0;\n\n    const float SCALE = AO_MAX_DIST / pow(2.0, float(AO_STEPS))*2.0;\n    float ocl = 0.0;\n\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2.0, float(i)) * SCALE;\n        ocl += 1.0 - (max(0.0, Object(p + n * dist).v) / dist);\n    }\n    \n    return min(1.0-(ocl / float(AO_STEPS)),1.0);\n    // return pow(abs(Object(p + 2.0 * n)),0.9);\n}\n\n\n// Cast soft shadow based on https://www.shadertoy.com/view/tlBcDK\n// p : Point\n// l : Point to light vector\n// d : Max tracing distance\n// r : Softness radius\nfloat Shadow(vec3 p,vec3 l, float d, float r)\n{\n\n    float res = 1.0;\n    float t = 0.1;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\n        if (res < 0.0 || t > d)\n            break;\n    \n        float h = Object(p+t*l).v;\n\n        res = min(res, r * h / t);\n        t += h;    \n    }    \n\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n\nMaterial MixMaterial(Material a, Material b, float t) {\n\n    Material mat;\n\n    mat.albedo = mix(a.albedo, b.albedo, t);\n    mat.roughness = mix(a.roughness, b.roughness, t);\n    mat.emissive = mix(a.emissive, b.emissive, t);\n    mat.metallic = mix(a.metallic, b.metallic, t);\n\n    return mat;\n}\n\n\nMaterial MatWater(in vec3 p, in vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n\n    const vec3 underwater = vec3(0.1745, 0.3537, 0.7254);\n    const vec3 deepwater = vec3(0.0135, 0.0451, 0.1294);\n    const vec3 sss_color = vec3(0.0, 0.6, 0.3) * 5.0; // vec3(0.01, 0.33, 0.55);\n\n    vec3 rd = normalize(ro - p);\n    float fac = dot(rd, n);\n\n    float sss_fact = max(0.0, acos(dot(rd, sun.direction)));\n    sss_fact = smoothstep(1.5, PI, sss_fact);\n    sss_fact = pow(sss_fact*fac, 3.0);\n\n    vec3 sss = sss_color * p.z * sss_fact * 100.0;\n    vec3 water = mix(underwater, deepwater, sat(fac));\n\n    mat.albedo = vec3(0);\n    mat.metallic = 1.0;\n    mat.roughness = 0.0;\n    mat.emissive = (water + sss*v) * sun.energy * 0.002;\n\n    return mat;\n}\n\n\nMaterial MatPlastic(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    mat.albedo = vec3(1);\n    mat.metallic = 0.0;\n    mat.roughness = 0.2;\n    return mat;\n}\n\n\nMaterial MatBlackPlastic(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    mat.albedo = vec3(0.01);\n    mat.metallic = 0.0;\n    mat.roughness = 0.7;\n    return mat;\n}\n\n\nMaterial MatBeacon(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    vec3 flare_pos = vec3(0,0,1.6);\n    flare_pos = (inverse(buoy_trans) * vec4(flare_pos, 1.0)).xyz;\n\n    vec3 rd = normalize(p-ro);\n    float flare_fact = acos(dot(normalize(flare_pos-ro), rd));\n    flare_fact = smoothstep(0.038,0.0, flare_fact) * 20.0;\n    flare_fact *= mod(ceil(iTime*0.5), 2.0);\n    Material mat;\n    mat.albedo = vec3(1,0.3,0);\n    mat.metallic = 0.0;\n    mat.roughness = 0.5;\n    mat.emissive = vec3(1,0,0)*flare_fact;\n    return mat;\n}\n\n\nMaterial MatMetal(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    mat.albedo = vec3(1.0);\n    mat.metallic = 1.0;\n    mat.roughness = 0.3;\n    return mat;\n}\n\n\nMaterial MatBuoy(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    \n    float var = Fbm(p*8.0, 3)*0.5 + 0.2;\n    DEBUG(vec3(var))\n    mat.albedo = vec3(1,1,0);\n    mat.metallic = 0.0;\n    mat.roughness = var;\n    return mat;\n}\n\n\n// Compute texture \n// p : Point\n// ro : Ray origin\n// v : visibility\n// n : Normal\nMaterial ComputeMaterial(vec3 p, vec3 n, int matID, vec3 ro, float v)\n{\n    switch (matID) {\n        case MATERIAL_WATER: return MatWater(p, n, ro, v);\n        case MATERIAL_BUOY: return MatBuoy(p, n, ro, v);\n        case MATERIAL_BEACON: return MatBeacon(p, n, ro, v);\n        case MATERIAL_METAL: return MatMetal(p, n, ro, v);\n        case MATERIAL_BLACK_PLASTIC: return MatBlackPlastic(p, n, ro, v);\n        case MATERIAL_PLASTIC:\n        default: return MatPlastic(p, n, ro, v);\n    }\n}\n\n// Sky --------------------------------------------------------------------------------\n\n// Atmospheric scattering based on preetham's analytical model\n// https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-sky/index.glsl\n\n\nconst float turbidity = 10.0;\nconst float reileighCoefficient = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.65;\n\n// constants for atmospheric scattering\n\nconst float n = 1.0003; // refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n// 288.15K and 1013mb (sea level -45 celsius)\nconst float pn = 0.035; // depolatization factor for standard air\n\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n// mie stuff\n// K coefficient for the primaries\nconst vec3 K2 = vec3(0.686, 0.678, 0.666);\nconst float V = 4.0;\n\n// optical length at zenith for molecules\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\n\nconst float EE = 1000.0;\nconst float AngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n// 66 arc seconds -> degrees, and the cosine of that\n\n// earth shadow hack\nconst float cutoffAngle = PI/1.95;\nconst float steepness = 1.5;\n\n\nvec3 totalRayleigh(vec3 lambda)\n{\n    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n    float c = (0.2 * T ) * 10E-18;\n    return 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(V - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g)\n{\n    return (1.0 / (4.0*PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n    return max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\n\n\nvoid AtmosphericScattering(DirectionalLight light, vec3 worldNormal, \n    out float cosTheta, out vec3 Lin, out vec3 Fex) \n{\n\n    vec3 lightDirection = light.direction;\n    float lightEnergy = light.energy;\n\n    float sunfade = 1.0-clamp(1.0- exp(light.direction.z / 450000.0) ,0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // extinction (absorbtion + out scattering)\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K2, turbidity) * mieCoefficient;\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    //float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n    float zenithAngle = acos(max(0.0, dot(up, worldNormal)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n\n    // combined extinction factor\n    Fex = exp(-(betaR * sR + betaM * sM));\n\n    // in scattering\n    cosTheta = dot(worldNormal, lightDirection);\n\n    float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n    vec3 betaRTheta = betaR * rPhase;\n\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\n    vec3 betaMTheta = betaM * mPhase;\n\n\n    Lin = pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n    Lin *= mix(vec3(1.0),pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, lightDirection),5.0),0.0,1.0));\n}\n\n\nvec3 AtmosphericScattering(DirectionalLight sun, vec3 viewDir) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, cosTheta, Lin, Fex);\n\n    vec3 texColor = Lin*0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\n// Get sky color\nvec3 Sky(DirectionalLight sun, vec3 viewDir) {\n\n    float CosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, CosTheta, Lin, Fex);\n\n    float sundisk = smoothstep(AngularDiameterCos,AngularDiameterCos+0.00002,CosTheta);\n    vec3 L0 = sun.energy * 19000.0 * sundisk * Fex;\n\n    vec3 texColor = (Lin + L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\nvec3 SkyExtinxion(DirectionalLight light) \n{\n\n    float sunfade = 1.0-clamp(1.0-exp(light.direction.z),0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K2, turbidity) * mieCoefficient;\n\n    // sun optical length\n    float zenithAngle = acos(max(0.0, dot(up, light.direction)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n    // combined extinction factor\n    return exp(-(betaR * sR + betaM * sM));\n}\n\n\n\nvec3 Env(vec3 view, DirectionalLight sun) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, view, cosTheta, Lin, Fex);\n\n    vec3 L0 = Fex * 0.1;\n\n    vec3 texColor = (Lin+L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n// PBR -------------------------------------------------------------------------\n\n//https://gist.github.com/galek/53557375251e1a942dfa\n\n// Get sky ambient color\n// sunDirection : Sun direction\n// worldNormal : Ray direction\nvec3 SkyAmbient(DirectionalLight sun) {\n\n    return Env(normalize(sun.direction*1.8 + vec3(0,0,1)), sun);\n}\n\n\n// phong (lambertian) diffuse term\nfloat phong_diffuse()\n{\n    return (1.0 / PI);\n}\n\n\n// compute fresnel specular factor for given base specular and product\n// product could be NdV or VdH depending on used technique\nvec3 fresnel_factor(in vec3 f0, in float product)\n{\n    return mix(f0, vec3(1.0), pow(1.01 - product, 5.0));\n}\n\n\n// following functions are copies of UE4\n// for computing cook-torrance specular lighting terms\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * PI) * pow(NdH, n);\n}\n\nfloat D_beckmann(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    return exp((NdH2 - 1.0) / (m2 * NdH2)) / (PI * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NdH * m2 - NdH) * NdH + 1.0;\n    return m2 / (PI * d * d);\n}\n\nfloat G_schlick(in float roughness, in float NdV, in float NdL)\n{\n    float k = roughness * roughness * 0.5;\n    float V = NdV * (1.0 - k) + k;\n    float L = NdL * (1.0 - k) + k;\n    return 0.25 / (V * L);\n}\n\n\n// cook-torrance specular calculation                      \nvec3 cooktorrance_specular(in float NdL, in float NdV, in float NdH, in vec3 specular, in float roughness)\n{\n#if SPECULAR_MODE == SPECULAR_BLINN\n    float D = D_blinn(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_BECKMANN\n    float D = D_beckmann(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_GGX\n    float D = D_GGX(roughness, NdH);\n#endif\n\n    float G = G_schlick(roughness, NdV, NdL);\n\n    float rim = mix(1.0 - roughness * 0.9, 1.0, NdV);\n\n    return max((1.0 / rim) * specular * G * D, 0.0);\n}\n\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(MAX_STEPS-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n// Background color\nvec3 background(vec3 r, DirectionalLight sun)\n{\n    return Sky(sun, r);\n    // return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Tone mappin -------------------------------------------------------------------\n\n// based on https://www.shadertoy.com/view/ldcSRN\n\nconst float W =11.2; // white scale\n\n// filmic (John Hable)\n\n\nconst float A = 0.22; // shoulder strength\nconst float B = 0.3; // linear strength\nconst float C = 0.1; // linear angle\nconst float D = 0.20; // toe strength\nconst float E = 0.01; // toe numerator\nconst float F = 0.30; // toe denominator\n\nvec3 LinearToSRGB(vec3 x) \n{\n    vec3 t = step(x,vec3(0.0031308));\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);\n}\n\n\nvec3 Gamma(vec3 color, float gamma) \n{\n    return pow(color, vec3(gamma));\n}\n\n\nvec3 Uncharted2Curve(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2(vec3 color)\n{\n    vec3 white_scale = Uncharted2Curve(vec3(W));\n    return Uncharted2Curve(color) / white_scale;\n}\n\n\nvec3 ReinhardCurve (vec3 x)\n{\n\treturn x / (1.0 + x);\n}\n\nvec3 Reinhard(vec3 color) \n{\n    vec3 white_scale = ReinhardCurve(vec3(W));\n    return ReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicReinhardCurve (vec3 x) \n{\n    const float T = 0.01;\n    vec3 q = (T + 1.0)*x*x;\n\treturn q / (q + x + T);\n}\n\n\nvec3 FilmicReinhard(vec3 color) \n{\n    vec3 white_scale = FilmicReinhardCurve(vec3(W));\n    return FilmicReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicCurve(vec3 x)\n{\n\treturn ((x*(0.22*x+0.1*0.3)+0.2*0.01)/(x*(0.22*x+0.3)+0.2*0.3))-0.01/0.3;\n}\n\nvec3 Filmic(vec3 color)\n{\n    vec3 white_scale = FilmicCurve(vec3(W));\n    return FilmicCurve(color) / white_scale;\n}\n\n\nvec3 ACESFitted(vec3 color) {\n\n    color = pow(color, vec3(0.833));\n    color *= 1.07;\n\n    const mat3 ACESInput = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n\n    const mat3 ACESOutput = mat3(\n        1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n\n\n    color = color * ACESInput;\n\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.38081;\n    color = a/b;\n\n    return color * ACESOutput;\n}\n\n\nvec3 ToneMapping(vec3 color) {\n\n    color = color*0.2;\n\n    #if TONEMAP_MODE == TONEMAP_FILMIC\n        color = Filmic(color);\n    #elif TONEMAP_MODE == TONEMAP_REINHARD\n        color = Reinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD\n        color = FilmicReinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2\n        color = Uncharted2(color);\n    #elif TONEMAP_MODE == TONEMAP_ACES\n        color = ACESFitted(color);\n    #endif\n\n    color = clamp(LinearToSRGB(color), 0.0, 1.0);\n\n    return color;\n}\n\n// Compute Blinn-Phong specular\n// l : Vector to light\n// n : Normal at point\n// r : View ray direction\n// k : glossyness\nfloat Specular(vec3 l, vec3 n, vec3 r, float k)\n{\n    vec3 half_dir = normalize(l + r);\n    float spec_angle = max(dot(half_dir, n), 0.0);\n    return pow(spec_angle, k);\n\n    // Phong\n//     vec3 ref = reflect(r, n);\n//     float c = max(dot(ref, r), 0.0);\n//     return pow(c, k/4.0);\n}\n\n\n// Compute lighting\n// sun : Sun data\n// mat : Material data\n// p : Point on surface\n// rd : View ray direction\n// n : Normal at Point\n// reflection : Computed reflection\n// clearcoat : Computed clearcoat reflection\n vec3 Shade(DirectionalLight sun, Material mat, vec3 p, vec3 rd, vec3 n, \n    vec3 reflection, float v) \n{\n\n    // Ambient color\n    vec3 ambient = SkyAmbient(sun) * 0.7;\n\n    // Ambient occlusion\n    NO_TRACE_OCEAN(ambient *= AmbientOcclusion(p, n))\n\n    // vec3 diffuse = ambient;\n    vec3 specular = mix(vec3(0.02), mat.albedo, mat.metallic);\n\n\n    vec3 L = sun.direction;\n    vec3 N = n;\n    vec3 V = -rd;\n    vec3 H = normalize(V+L);\n\n    float NdL = max(0.001, dot(N, L));\n    float NdV = max(0.001, dot(N, V));\n    float NdH = max(0.001, dot(N, H));\n    float HdV = max(0.001, dot(H, V));\n\n\n    // specular reflectance with COOK-TORRANCE\n    vec3 specfresnel = fresnel_factor(specular, HdV);\n    vec3 specref = cooktorrance_specular(NdL, NdV, NdH, specfresnel, mat.roughness);\n\n    specref *= vec3(NdL) * 10.0;\n\n    // diffuse is common for any model\n    vec3 diffref = (vec3(1.0) - specfresnel) * phong_diffuse() * NdL;\n    \n    // compute lighting\n    vec3 reflected_light = vec3(0);\n    vec3 diffuse_light = vec3(0);\n\n    // point light\n    vec3 light_color = sun.color * sun.energy * 0.01;\n    reflected_light += specref * light_color * v;\n    diffuse_light += diffref * light_color * v;\n\n    reflected_light += min(vec3(0.99), fresnel_factor(specular, NdV)) * reflection;\n\n    diffuse_light += ambient * (1.0 / PI);\n\n    // final result\n    vec3 result = diffuse_light * mix(mat.albedo, vec3(0.0), mat.metallic);\n    result += reflected_light;\n    result += mat.emissive;\n\n    return result;\n}\n\n\n// Sample color from ray\n// sun : Sun light\n// ro : Ray origin\n// rd : Ray direction\n// steps : Number of trace steps\nvec3 Render(DirectionalLight sun, vec3 ro, vec3 rd, out int steps) {\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n    \n    // primary ray\n    CATCH_DEBUG(float t = SphereTrace(ro, rd, 1000.0, hit, s));\n    steps += s;\n\n    if (!hit && rd.z > 0.0)\n        return background(rd, sun);\n    \n    vec3 pt, n;\n    int matID = 0;\n    Material mat;\n    float h;\n    \n    if (!hit && rd.z < 0.0) {\n        t = DistToPlane(ro, rd, WATER_LEVEL);\n        matID = MATERIAL_WATER;\n    }\n    \n    pt = ro + t * rd;\n    n = ComputeNormal(pt, matID);\n    \n    NO_TRACE_OCEAN(float v = Shadow(pt+n*0.001, sun.direction, \n                                    sun.shadow_dist, 20.0))\n\n    CATCH_DEBUG(mat = ComputeMaterial(pt, n, matID, ro, v));\n\n    vec3 reflect_dir = reflect(rd, n);\n    vec3 reflection = vec3(0);\n\n    // reflection\n    if (mat.roughness == 0.0) {\n\n        // secondary ray\n        vec3 start = pt+n*0.01;\n        bool hit;\n        NO_TRACE_OCEAN(float t = SphereTrace(start, reflect_dir, 1000.0, hit, s))\n        steps += s;\n\n        if (hit) {\n            vec3 rpt = pt + t * reflect_dir;\n            \n            int matID;\n            vec3 rn = ComputeNormal(rpt, matID);\n\n            Material rmat = ComputeMaterial(rpt, rn, matID, pt, 1.0);\n\n            vec3 sec_reflection = Env(reflect(reflect_dir, rn), sun);\n            \n            reflection = Shade(sun, rmat, rpt, reflect_dir, \n                                rn, sec_reflection, 1.0);\n        }\n        else\n            reflection = Env(reflect_dir, sun);\n    }\n    else if (hit) {\n        float r = 1.0/max(mat.roughness, 0.00001);\n        NO_TRACE_OCEAN(float v = Shadow(pt+n*0.01, reflect_dir, 1000.0, r));\n        reflection = mix(SkyAmbient(sun)*0.01, Env(reflect_dir, sun), v);\n    } else \n        reflection = Env(reflect_dir, sun);\n\n\n    vec3 color = Shade(sun, mat, pt, rd, n, reflection, v);\n\n    color = mix(color, Env(rd, sun), sat(t*t*0.0002));\n\n    return color;\n}\n\n\nvec2 RayDirection(in vec2 pixel, inout bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {\n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Picture in picture on\n    bool pip=false;\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro;\n    mat3 cam = Camera(m, ro);\n\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,1.0));\n\n\n    // Shade background\n    sun.direction = normalize(vec3(0.2, -0.5, 0.1));\n    sun.color = SkyExtinxion(sun)* 19.0;\n    sun.energy = sunIntensity(sun.direction.z) * EE;\n    sun.shadow_dist = 100.0;\n\n    \n    // compute buoy transform\n    float h;\n    vec3 buoy_nor = OceanNormal(vec2(0), 4, h);\n    buoy_nor.xy *= -0.2;\n\n    buoy_nor = normalize(buoy_nor);\n\n    vec3 buoy_tan = cross(buoy_nor, vec3(1,0,0));\n    vec3 buoy_bit = cross(buoy_tan, buoy_nor);\n\n    buoy_trans = mat4(mat3(buoy_bit, buoy_tan, buoy_nor));\n    buoy_trans[3].z = h * -0.4 + 0.1;\n\n    int s;\n\n    vec3 rgb = Render(sun, ro, rd, s);\n\n    rgb = ToneMapping(rgb);\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n        rgb = ShadeSteps(s); \n\n\n#if _DEBUG\n    rgb = _debug_color;\n#endif\n    fragColor = vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}