{"ver":"0.1","info":{"id":"3tKfDt","date":"1643272920","viewed":124,"name":"Test for Spherical Grid System","username":"postcar999","description":"Test for grid system on sphere using tetrahedron, octahedron, and icosahedron","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["planet","sphericalgridsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nbool Intersect(Ray ray, vec4 sphere, out vec2 tLength)\n{    \n    vec3 oc = ray.origin - sphere.xyz;\n    \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float det = b * b - 4.0 * a * c;\n    \n    float sqrtDet = sqrt(det);\n    float denom = 2.0 * a;\n    \n    float len0 = (-b - sqrtDet) / denom;\n    float len1 = (-b + sqrtDet) / denom;\n    \n    tLength = vec2(len0, len1);\n\n    return det > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 toward = fragCoord.xy;// + iMouse.xy;\n    vec2 uv = toward / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 forward = vec3(0.0, 0.0, 1.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 eye = vec3(0.0, 0.0, 0.0);\n    vec3 origin = vec3(0.0, 0.0, 11.5);\n    \n    float phi = -iMouse.y * 0.01;\n    float theta = -iMouse.x * 0.01;\n    \n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    \n    forward = normalize(eye - origin);\n    right = cross(forward, up);\n    up = cross(right, forward);\n    \n    vec3 dir = forward + right * uv.x + up * uv.y;\n    dir = normalize(dir);\n    \n    Ray ray;\n    ray.origin = origin;\n    ray.direction = dir;\n    \n    vec4 sphere = vec4(0.0, 0.0, 0.0, 5.0);\n    \n    vec2 tLength;\n    bool hit = Intersect(ray, sphere, tLength);\n    \n    vec3 position = ray.origin + ray.direction * tLength.x;\n    vec3 P = normalize(position - sphere.xyz);\n    vec3 p;\n    \n    p.x = cosTheta * P.x + sinTheta * P.z;\n    p.y = P.y;\n    p.z = -sinTheta * P.x + cosTheta * P.z;\n    \n    // tetrahedron\n    vec4 w = TransformPointToGlobalSACsInSphericalTetra(p);\n    w = TransformPointToGlobalSACsInSphericalOcta(p);\n    w = TransformPointToGlobalSACsInSphericalIcos(p);\n    \n    int index = int(w.w);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (index ==  0) color = vec3(0.2, 0.0, 0.0);\n    if (index ==  1) color = vec3(0.0, 0.2, 0.0);\n    if (index ==  2) color = vec3(0.0, 0.0, 0.2);\n    if (index ==  3) color = vec3(0.2, 0.2, 0.0);\n    if (index ==  4) color = vec3(0.2, 0.0, 0.2);\n    if (index ==  5) color = vec3(0.0, 0.2, 0.2);\n    if (index ==  6) color = vec3(0.5, 0.5, 0.5);\n    if (index ==  7) color = vec3(0.5, 0.0, 0.0);\n    if (index ==  8) color = vec3(0.0, 0.5, 0.0);\n    if (index ==  9) color = vec3(0.0, 0.0, 0.5);\n    if (index == 10) color = vec3(0.5, 0.5, 0.0);\n    if (index == 11) color = vec3(0.5, 0.0, 0.5);\n    if (index == 12) color = vec3(0.0, 0.5, 0.5);\n    if (index == 13) color = vec3(1.0, 1.0, 1.0);\n    if (index == 14) color = vec3(1.0, 0.0, 0.0);\n    if (index == 15) color = vec3(0.0, 1.0, 0.0);\n    if (index == 16) color = vec3(0.0, 0.0, 1.0);\n    if (index == 17) color = vec3(1.0, 1.0, 0.0);\n    if (index == 18) color = vec3(1.0, 0.0, 1.0);\n    if (index == 19) color = vec3(0.0, 1.0, 1.0);\n    \n    int level = 4;\n    int numSubdivisions = 1 << level;\n    \n    float levelMag = float(numSubdivisions);\n    vec4 localSac = TransformGlobalSACsToLocalSACs(w, levelMag);\n    \n    int f = int(localSac.w);\n    int counter = iFrame / 2;\n    int clipper = numSubdivisions * numSubdivisions;\n    \n    float weight = 1.0;\n    \n    if (f == (counter % clipper)) weight = 0.5;\n    else weight = 0.0;\n    \n    if (hit == false) color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 col = vec3(1.0 - dot(localSac.xyz, vec3(1.0)));\n    \n    color = mix(localSac.xyz, vec3(1.0), weight);\n    //color = col;\n    \n    // gamma correction\n    //color = max(vec3(0), color - 0.004);\n    //color = (color * (6.2 * color + 0.5)) / (color *(6.2 *color + 1.7) + 0.06);\n    \n    fragColor = vec4(color, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ENABLE_FIX_CORRECT_BARYCOORDS\n\nconst float Pi = 3.141592653;\nconst float InvPi = 1.0 / Pi;\n\nvec3 TransformPointToSACs(vec3 p, vec3 p0, vec3 p1, vec3 p2)\n{\n    float p0p1 = dot(p0, p1);\n    float p1p2 = dot(p1, p2);\n    float p2p0 = dot(p2, p0);\n\n    float p_p0 = dot(p, p0);\n    float p_p1 = dot(p, p1);\n    float p_p2 = dot(p, p2);\n\n    vec3 cross_p1p2 = cross(p1, p2);\n\n    float numer = dot(p0, cross_p1p2);\n    float denom = 1.0 + p0p1 + p1p2 + p2p0;\n\n    float S = atan(numer, denom);\n    float invS = 1.0 / S;\n\n    vec3 numer3 = vec3(dot(p, cross_p1p2), dot(p, cross(p2, p0)), dot(p, cross(p0, p1)));\n    vec3 denom3 = vec3(p_p1 + p1p2 + p_p2, p_p2 + p2p0 + p_p0, p_p0 + p0p1 + p_p1) + 1.0;\n\n    return invS * atan(numer3, denom3);\n}\n\nvec3 FixBarycentricCoords(vec3 lambdas)\n{\n#ifdef ENABLE_FIX_CORRECT_BARYCOORDS\n    float len = dot(lambdas, vec3(1.0));\n    \n    return lambdas / len;\n#else\n    return lambdas;\n#endif\n}\n\nbool VerifyValidLambdas(vec3 lambdas)\n{\n    if (lambdas.x < 0.0 || lambdas.x > 1.0)\n        return false;\n    if (lambdas.y < 0.0 || lambdas.y > 1.0)\n        return false;\n    if (lambdas.z < 0.0 || lambdas.z > 1.0)\n        return false;\n    \n    float sigma = dot(lambdas, vec3(1.0));\n    float det = abs(sigma - 1.0);\n    if (det > 0.1)\n        return false;\n        \n    return true;\n}\n\n// tetrahedron\nconst float TetraC = 2.0 / Pi;\nconst float Root3 = sqrt(3.0);\nconst float InvRoot3 = 1.0 / Root3;\n\nfloat CalculateWhichSideInTetrahedron(vec3 p)\n{\n    vec4 dets = vec4(\n        -p.x - p.y + p.z,\n        -p.x + p.y - p.z,\n         p.x + p.y + p.z,\n         p.x - p.y - p.z);\n    \n    float det;\n    det = dets.w < dets.x ? dets.w : dets.x;\n    det = det    < dets.y ? det    : dets.y;\n    det = det    < dets.z ? det    : dets.z;\n    \n    vec3 side = step(dets.xyz, vec3(det)) * vec3(1.0, 2.0, 3.0);\n    float which = dot(side, vec3(1.0));\n\n    return which;;\n}\n\nfloat CalculateWhichSideInOctahedron(vec3 p)\n{\n    vec3 side = step(p, vec3(0.0)) * vec3(1.0, 2.0, 4.0);\n    float which = dot(side, vec3(1.0));\n\n    return which;\n}\n\nvec4 TransformPointToGlobalSACsInSphericalTetra(vec3 p)\n{\n    vec4 numer1 = vec4(p.yxx, -p.x) + vec4(p.zyz, -p.z);\n    vec4 numer2 = vec4(p.yyz, -p.x) - p.xzyy;\n    vec4 numer3 = vec4(p.zxx, -p.y) - p.xzyz;\n    \n    vec4 denom1 = 1.0 - vec4(Root3, Root3, Root3,  Root3) * p.xzyy;\n    vec4 denom2 = 1.0 + vec4(Root3, Root3, Root3, -Root3) * p.zxxz;\n    vec4 denom3 = 1.0 + vec4(Root3, Root3, Root3, -Root3) * p.yyzx;\n    \n    vec4 lambda1 = TetraC * atan(numer1, denom1);\n    vec4 lambda2 = TetraC * atan(numer2, denom2);\n    vec4 lambda3 = vec4(1.0) - lambda1 - lambda2;\n    float which = CalculateWhichSideInTetrahedron(p);\n    \n    vec3 w[4];\n    w[0] = vec3(lambda1.x, lambda2.x, lambda3.x);\n    w[1] = vec3(lambda1.y, lambda2.y, lambda3.y);\n    w[2] = vec3(lambda1.z, lambda2.z, lambda3.z);\n    w[3] = vec3(lambda1.w, lambda2.w, lambda3.w);\n    \n    uint index = uint(which);\n\n    return vec4(w[index].x, w[index].y, w[index].z, which);\n}\n\n// octahedron\nconst float OctaC = 4.0 / Pi;\n\nvec4 TransformPointToGlobalSACsInSphericalOcta(vec3 p)\n{\n    vec3 a = abs(p);\n    \n    vec3 numer = a;\n    vec3 denom = 1.0 + a.yxx + a.zzy;\n    \n    vec3 lambdas = OctaC * atan(numer, denom);\n    float which = CalculateWhichSideInOctahedron(p);\n    \n    lambdas = FixBarycentricCoords(lambdas);\n    \n    return vec4(lambdas.x, lambdas.y, lambdas.z, which);\n}\n\n// icosahedron\nconst float IcosaC = 10.0 / Pi;\n\nvec3 CalculateLamdas0OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.276393 + p.y * 0.380423 - p.z * 0.760845), (1.0 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214)),\n         atan((p.x * 0.894427 + p.y * 0.000000 + p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000)),\n        -atan((p.x * 0.276393 - p.y * 0.850651 - p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000 + 0.447214 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas1OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.447214 - p.y * 0.145309 - p.z * 0.760845), (1.0 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214)),\n         atan((p.x * 0.276393 - p.y * 0.850651 + p.z * 0.000000), (1.0 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000)),\n         atan((p.x * 0.723607 + p.y * 0.525731 + p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000 + 0.447214 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas2OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.000000 + p.y * 0.470228 + p.z * 0.760845), (1.0 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214)),\n        -atan((p.x * 0.723607 + p.y * 0.525731 - p.z * 0.000000), (1.0 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000)),\n         atan((p.x * 0.723607 - p.y * 0.525731 + p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000 + 0.447214 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas3OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.447214 + p.y * 0.145309 + p.z * 0.760845), (1.0 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214)),\n        -atan((p.x * 0.723607 - p.y * 0.525731 - p.z * 0.000000), (1.0 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000)),\n        -atan((p.x * 0.276393 + p.y * 0.850651 - p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000 + 0.447214 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas4OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.276393 - p.y * 0.380423 + p.z * 0.760845), (1.0 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214 + 0.447214 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214)),\n         atan((p.x * 0.276393 + p.y * 0.850651 + p.z * 0.000000), (1.0 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000)),\n        -atan((p.x * 0.894427 - p.y * 0.000000 - p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 + p.z * 1.000000 + 0.447214 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\n\nvec3 CalculateLamdas5OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.276393 + p.y * 0.380423 - p.z * 0.760845), (1.0 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214 + 0.447214 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214)),\n        -atan((p.x * 0.447214 - p.y * 0.615537 - p.z * 0.470228), (1.0 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214)),\n         atan((p.x * 0.723607 - p.y * 0.235114 + p.z * 0.470228), (1.0 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas6OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.447214 - p.y * 0.145309 - p.z * 0.760845), (1.0 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214)),\n         atan((p.x * 0.447214 + p.y * 0.615537 + p.z * 0.470228), (1.0 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214)),\n         atan((p.x * 0.000000 - p.y * 0.760845 + p.z * 0.470228), (1.0 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas7OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.000000 - p.y * 0.470228 - p.z * 0.760845), (1.0 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214)),\n         atan((p.x * 0.723607 - p.y * 0.235114 + p.z * 0.470228), (1.0 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214)),\n        -atan((p.x * 0.723607 + p.y * 0.235114 - p.z * 0.470228), (1.0 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214 + 0.447214 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas8OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.447214 + p.y * 0.145309 + p.z * 0.760845), (1.0 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214)),\n         atan((p.x * 0.000000 - p.y * 0.760845 + p.z * 0.470228), (1.0 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214)),\n        -atan((p.x * 0.447214 - p.y * 0.615537 - p.z * 0.470228), (1.0 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas9OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.276393 - p.y * 0.380423 + p.z * 0.760845), (1.0 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214)),\n        -atan((p.x * 0.723607 + p.y * 0.235114 - p.z * 0.470228), (1.0 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214 + 0.447214 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214)),\n         atan((p.x * 0.447214 + p.y * 0.615537 + p.z * 0.470228), (1.0 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\n\nvec3 CalculateLamdas10OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.447214 + p.y * 0.145309 + p.z * 0.760845), (1.0 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214)),\n         atan((p.x * 0.447214 - p.y * 0.615537 - p.z * 0.470228), (1.0 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214)),\n         atan((p.x * 0.000000 + p.y * 0.760845 - p.z * 0.470228), (1.0 + p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas11OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.276393 - p.y * 0.380423 + p.z * 0.760845), (1.0 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214 + 0.447214 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214)),\n        -atan((p.x * 0.447214 + p.y * 0.615537 + p.z * 0.470228), (1.0 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214)),\n         atan((p.x * 0.723607 + p.y * 0.235114 - p.z * 0.470228), (1.0 + p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas12OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.276393 + p.y * 0.380423 - p.z * 0.760845), (1.0 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214)),\n        -atan((p.x * 0.723607 - p.y * 0.235114 + p.z * 0.470228), (1.0 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214 + 0.447214 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214)),\n         atan((p.x * 0.447214 - p.y * 0.615537 - p.z * 0.470228), (1.0 - p.x * 0.525731 - p.y * 0.723607 + p.z * 0.447214 + 0.447214 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas13OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.447214 - p.y * 0.145309 - p.z * 0.760845), (1.0 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214)),\n         atan((p.x * 0.000000 + p.y * 0.760845 - p.z * 0.470228), (1.0 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214)),\n        -atan((p.x * 0.447214 + p.y * 0.615537 + p.z * 0.470228), (1.0 - p.x * 0.850651 + p.y * 0.276393 + p.z * 0.447214 + 0.447214 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas14OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.000000 + p.y * 0.470228 + p.z * 0.760845), (1.0 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214)),\n         atan((p.x * 0.723607 + p.y * 0.235114 - p.z * 0.470228), (1.0 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214)),\n        -atan((p.x * 0.723607 - p.y * 0.235114 + p.z * 0.470228), (1.0 + p.x * 0.000000 + p.y * 0.894427 + p.z * 0.447214 + 0.447214 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\n\nvec3 CalculateLamdas15OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.447214 + p.y * 0.145309 + p.z * 0.760845), (1.0 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214)),\n         atan((p.x * 0.276393 + p.y * 0.850651 + p.z * 0.000000), (1.0 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000)),\n         atan((p.x * 0.723607 - p.y * 0.525731 + p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000 + 0.447214 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas16OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n        -atan((p.x * 0.276393 - p.y * 0.380423 + p.z * 0.760845), (1.0 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214)),\n         atan((p.x * 0.894427 + p.y * 0.000000 + p.z * 0.000000), (1.0 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000)),\n        -atan((p.x * 0.276393 + p.y * 0.850651 - p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000 + 0.447214 + p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas17OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.276393 + p.y * 0.380423 - p.z * 0.760845), (1.0 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214 + 0.447214 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214)),\n         atan((p.x * 0.276393 - p.y * 0.850651 + p.z * 0.000000), (1.0 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000)),\n        -atan((p.x * 0.894427 - p.y * 0.000000 - p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000 + 0.447214 + p.x * 0.000000 - p.y * 0.894427 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas18OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.447214 - p.y * 0.145309 - p.z * 0.760845), (1.0 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214 + 0.447214 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214)),\n        -atan((p.x * 0.723607 + p.y * 0.525731 - p.z * 0.000000), (1.0 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000)),\n        -atan((p.x * 0.276393 - p.y * 0.850651 - p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000 + 0.447214 - p.x * 0.850651 - p.y * 0.276393 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec3 CalculateLamdas19OfIcosahedron(vec3 p)\n{\n    vec3 numer = vec3(\n         atan((p.x * 0.000000 - p.y * 0.470228 - p.z * 0.760845), (1.0 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214)),\n        -atan((p.x * 0.723607 - p.y * 0.525731 - p.z * 0.000000), (1.0 + p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214 + 0.447214 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000)),\n         atan((p.x * 0.723607 + p.y * 0.525731 + p.z * 0.000000), (1.0 + p.x * 0.000000 + p.y * 0.000000 - p.z * 1.000000 + 0.447214 - p.x * 0.525731 + p.y * 0.723607 - p.z * 0.447214))\n    );\n\n    return IcosaC * numer;\n}\n\nvec4 TransformPointToGlobalSACsInSphericalIcos(vec3 p)\n{\n    vec3 lambdasList[20];\n    \n    lambdasList[ 0] = CalculateLamdas0OfIcosahedron(p);\n    lambdasList[ 1] = CalculateLamdas1OfIcosahedron(p);\n    lambdasList[ 2] = CalculateLamdas2OfIcosahedron(p);\n    lambdasList[ 3] = CalculateLamdas3OfIcosahedron(p);\n    lambdasList[ 4] = CalculateLamdas4OfIcosahedron(p);\n    lambdasList[ 5] = CalculateLamdas5OfIcosahedron(p);\n    lambdasList[ 6] = CalculateLamdas6OfIcosahedron(p);\n    lambdasList[ 7] = CalculateLamdas7OfIcosahedron(p);\n    lambdasList[ 8] = CalculateLamdas8OfIcosahedron(p);\n    lambdasList[ 9] = CalculateLamdas9OfIcosahedron(p);\n    \n    lambdasList[10] = CalculateLamdas10OfIcosahedron(p);\n    lambdasList[11] = CalculateLamdas11OfIcosahedron(p);\n    lambdasList[12] = CalculateLamdas12OfIcosahedron(p);\n    lambdasList[13] = CalculateLamdas13OfIcosahedron(p);\n    lambdasList[14] = CalculateLamdas14OfIcosahedron(p);\n    lambdasList[15] = CalculateLamdas15OfIcosahedron(p);\n    lambdasList[16] = CalculateLamdas16OfIcosahedron(p);\n    lambdasList[17] = CalculateLamdas17OfIcosahedron(p);\n    lambdasList[18] = CalculateLamdas18OfIcosahedron(p);\n    lambdasList[19] = CalculateLamdas19OfIcosahedron(p);\n    \n    float which = 20.0;\n    \n    int begin = 0;\n    int end = 20;\n\n    vec3 lambdas = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = begin; i < end; ++i)\n    {\n        if (VerifyValidLambdas(lambdasList[i]))\n        {\n            which = float(i);\n            lambdas = lambdasList[i];\n        }\n    }\n    \n    lambdas = FixBarycentricCoords(lambdas);\n    \n    return vec4(lambdas.x, lambdas.y, lambdas.z, which);\n}\n\nvec4 TransformGlobalSACsToLocalSACs(vec4 sac, float resolution)\n{\n    vec3 w = sac.xyz;\n    vec3 t = w * resolution;\n    \n    vec2 ceiled = ceil(t.xz);\n    float top = resolution - ceiled.x;\n    float horizontal = 2.0 * ceiled.y - 2.0;\n    \n    w = fract(t);\n    \n    float sum = dot(w, vec3(1.0));\n    bool reverse = sum > 1.5;\n    \n    if (reverse)\n    {\n        w = 1.0 - w;\n        horizontal = horizontal + 1.0;\n    }\n    \n    w = w + floor(t);\n    w /= resolution;\n    w = FixBarycentricCoords(w);\n    \n    float index = (top * top) + horizontal;\n    \n    return vec4(w.x, w.y, w.z, index);\n}","name":"Common","description":"","type":"common"}]}