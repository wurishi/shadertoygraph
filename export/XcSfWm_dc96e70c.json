{"ver":"0.1","info":{"id":"XcSfWm","date":"1725000726","viewed":42,"name":"Mountains at Dawn","username":"triggthediscovery","description":"Simple terrain shader using raymarching. I tried to strike a good balance between performance and stability.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","mountains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a simple terrain shader. It's\n// very simple, but it looks nice enough.\n//\n// Provided under CC0.\n\nstruct NormAndCol {\n    vec3 col;\n    vec3 norm;\n    float dist;\n};\n\nstruct Layer {\n    float scale;\n    float ang;\n    vec2 offset;\n    float height;\n};\n\nLayer layers[8];\nint layer_num = 8;\n\nconst float heightmap_top = 0.0;\nconst float heightmap_bot = -4.0;\nconst float heightmap_height = heightmap_top - heightmap_bot;\nconst float tiling = 5.0;\nconst float max_dist = 1000.0;\nconst float ambient_light = 0.3;\n\nvec3 light_dir;\n\nNormAndCol n_a_c(vec3 col, vec3 norm, float dist) {\n    NormAndCol ret;\n    \n    ret.col = col;\n    ret.norm = norm;\n    ret.dist = dist;\n    \n    return ret;\n}\n\nLayer m_l(float scale, float ang, vec2 offset, float height) {\n    Layer ret;\n    \n    ret.scale = scale;\n    ret.ang = ang;\n    ret.offset = offset;\n    ret.height = height;\n    \n    return ret;\n}\n\nfloat height_help(vec3 point, float scale, float ang, vec2 offset, float height) {\n    vec2 new_pt = vec2((point.z*sin(ang))+(point.x*cos(ang)), (-point.x*sin(ang))+(point.z*cos(ang)));\n    new_pt *= scale;\n    new_pt += offset;\n\n    return (cos(new_pt.x) + cos(new_pt.y) + 2.0) / 4.0 * height;\n}\n\n// Norm has to be rotation-adjusted. This might not work\n// properly, but it looks alright.\nvec3 norm_help(vec3 point, float scale, float ang, vec2 offset, float height) {\n    vec2 new_pt = vec2((point.z*sin(ang))+(point.x*cos(ang)), (-point.x*sin(ang))+(point.z*cos(ang))); // (z,-x)\n    new_pt *= scale;\n    new_pt += offset;\n\n    vec3 rnorm = vec3(sin(new_pt.x),0.0,sin(new_pt.y))*scale;\n    vec3 norm = vec3((rnorm.z*sin(-ang))+(rnorm.x*cos(-ang)), 0, (-rnorm.x*sin(-ang))+(rnorm.z*cos(-ang))); // (x, z)\n    \n    norm.y += scale/height/10.0;\n    \n    return normalize(norm);\n}\n\nfloat height_at(vec3 point) {\n    float base = 0.0;\n    \n    for (int i=0; i<layer_num; i++) {\n        base += height_help(point, layers[i].scale, layers[i].ang, layers[i].offset, layers[i].height)/3.0;\n    }\n\n    return (base * heightmap_height) + heightmap_bot;\n}\n\nvec3 norm_at(vec3 point) {\n    vec3 norm;\n    \n    for (int i=0; i<layer_num; i++) {\n        norm += norm_help(point, layers[i].scale, layers[i].ang, layers[i].offset, layers[i].height);\n    }\n    \n    return normalize(norm);\n}\n\nNormAndCol heightmap_check(vec3 in_vec, vec3 in_pos) {\n    vec3 tracking_point = in_pos;\n    vec3 tracking_point_p = tracking_point;\n    float height_d_p;\n    bool found = false;\n    float track_dist = 0.08;\n    float total_dist = 0.0;\n\n    // This moves rays faster when the ground is further,\n    // slower when it's near. This is so larg gaps can\n    // be effectively skipped over.\n    for (int i=0; i<150 && total_dist<50.0; i++) {\n        tracking_point += in_vec * track_dist;\n        total_dist += track_dist;\n\n        float heightat = height_at(tracking_point);\n\n        // If you find a collision, perform a binary search\n        // to find the surface. This can cause issues since\n        // there may be multiple intersections, but it should\n        // work well enough.\n        if (tracking_point.y <= heightat) {\n            for (int j=0; j<10; j++) {\n                vec3 midpoint = (tracking_point_p + tracking_point)/2.0;\n                \n                float n_height = height_at(midpoint);\n                \n                if (midpoint.y <= n_height) {\n                    tracking_point = midpoint;\n                } else {\n                    tracking_point_p = midpoint;\n                }\n            }\n            found = true;\n            break;\n        } else {\n            float height_o = tracking_point.y - heightat;\n            float rate = (height_d_p-height_o)/track_dist;\n            \n            // This uses the assumption that a slope down is less likely\n            // to contain a collison than a slope up, and can be marched\n            // over quickly.\n            if (rate > 0.15) {\n                track_dist = clamp((height_o)*log(total_dist+2.0)/10.0, \n                                   clamp((total_dist)/80.0, 0.01, 1.0), \n                                   1.0);\n            } else {\n                track_dist = clamp((height_o)*log(total_dist+2.0)/4.0, \n                                   clamp((total_dist)/35.0, 0.015, 1.0), \n                                   1.0);\n            }\n        \n            tracking_point_p = tracking_point;\n            height_d_p = height_o;\n        }\n    }\n\n    if (found) {\n        tracking_point.y = height_at(tracking_point);\n    \n        float height = (tracking_point.y - heightmap_bot) / heightmap_height;\n        vec3 norm = norm_at(tracking_point);\n\n        float ny = pow(norm.y-0.03, 5.0);\n        \n        // Green on top, grey on sides. \n        vec3 col = mix(vec3(0.8), vec3(0.4, 0.7, 0.5), ny);\n    \n        return n_a_c(col, norm, distance(in_pos, tracking_point));\n    } else {\n        return n_a_c(vec3(1), vec3(0,1,0), max_dist+1.0);\n    }\n}\n\nconst float gm_p = 1.5;\nconst float ch_p = 0.2;\n\nfloat gamma(float inp) {\n    return inp < ch_p ? inp * pow(ch_p, gm_p-1.0) : pow(inp, gm_p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    layers[0] = m_l(0.5, 0.7, vec2(0), 1.0);\n    layers[1] = m_l(2.0, 0.0, vec2(0), 1.0);\n    layers[2] = m_l(1.5, 0.6, vec2(0,1), 0.5);\n    layers[3] = m_l(5.0, 1.0, vec2(0.1, 0.5), 0.5);\n    layers[4] = m_l(12.0, 2.0, vec2(0.3, 0.15), 0.25);\n    layers[5] = m_l(40.0, 3.0, vec2(0.234, 0.654), 0.025);\n    layers[6] = m_l(150.0, 2.5, vec2(0.568, 0.357), 0.01);\n    layers[7] = m_l(80.0, 0.8, vec2(0.354, 0.246), 0.01);\n    layer_num = 8;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord-(iResolution.xy/2.0);\n\n    uv /= iResolution.y;\n\n    float ang = 0.3;//+(iTime/-10.0);\n    float dist = 2.0;\n\n    vec3 in_vec_p = vec3(sin(ang)*dist, -cos(iTime/3.0), -(cos(ang)*dist));\n    vec3 in_vec_d = normalize(-in_vec_p);\n    light_dir = normalize(vec3(0.5,-0.3, 0.2));\n    \n    float fov = 2.8;\n    vec3 in_vec_d_hold = in_vec_d;\n\n    in_vec_d.x += (in_vec_d_hold.z*(uv.x*fov));\n    in_vec_d.z -= (in_vec_d_hold.x*(uv.x*fov));\n    in_vec_d.y += uv.y*fov;\n    \n    in_vec_d = normalize(in_vec_d);\n    \n    vec3 col = mix(vec3(0.9,0.8,1), vec3(0.3,0.5,1), uv.y+(uv.x/4.0));\n\n    NormAndCol mfloor = heightmap_check(in_vec_d, in_vec_p);\n\n    // This is lighting, both shading and shadow\n    if (mfloor.dist < max_dist) {\n        vec3 hit_point = in_vec_p+(in_vec_d*mfloor.dist);\n        hit_point.y += 0.02;\n        hit_point -= light_dir*0.005;\n    \n        NormAndCol sun = heightmap_check(-light_dir, hit_point);\n    \n        float light = dot(-light_dir, mfloor.norm);\n        \n        light = clamp(light, ambient_light, 1.0);\n    \n        col = mfloor.col * light;\n\n        if (sun.dist < 100.0) {\n            col /= 1.5;\n        }\n        \n        float fog = (-hit_point.y/40.0)*mfloor.dist;\n        fog += log(mfloor.dist)/8.0;\n        fog = clamp(fog, 0.0, 1.0);\n        \n        col = mix(col, vec3(0.7), fog);\n    }\n    \n    col.x = gamma(col.x);\n    col.y = gamma(col.y);\n    col.z = gamma(col.z);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}