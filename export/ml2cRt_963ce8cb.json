{"ver":"0.1","info":{"id":"ml2cRt","date":"1692197190","viewed":27,"name":"Laguerre's method","username":"Envy24","description":"https://en.wikipedia.org/wiki/Laguerre%27s_method\nDrag blue point to change initial guess.\nWhite regions - function find valid root,\nLight grey regions - no valid root (or method converge to complex root).\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["solver","polynomial","root","method","finder","laluerre"],"hasliked":0,"parentid":"ct2czd","parentname":"Polynomials evaluation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3.0 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat explicitSDF(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return abs(sdf) / sqrt(1.0 + dfdx * dfdx);\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat explicit(float x) { return eval_poly(x, pcs, degree); }\nfloat dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return (explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    init_poly_coeffs(iTime);\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    float x = LaguerreMethod(NDC.x, pcs, dcs, ddcs, degree);\n    float y = eval_poly(x, pcs, degree);\n   \n    vec3 color = abs(y) < TOLERANCE ? vec3(1) : vec3(.95);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n        \n    color = mix(color, vec3(1,0,0), SMAA(explicitSDF(NDC, explicit(NDC.x), dydx(NDC.x))));\n    \n\n    x = LaguerreMethod(MP.x, pcs, dcs, ddcs, degree);\n    y = eval_poly(x, pcs, degree);\n       \n    color = mix(color, vec3(1,0,1), SMAA(diskSDF(NDC, vec2(x, y), 0.05)));\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF(NDC, MP, 0.05)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Min degree 2.\nconst int degree = 10;\nfloat roots[degree];\nfloat pcs[degree + 1];  // Polynomial coeffitients\nfloat dcs[degree];      // First derivative coeffitients\nfloat ddcs[degree - 1]; // Second derivative coeffitients\n#define TOLERANCE ( 1e-4 )\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvoid calculate_first_derivative_coeffs(\n    in float pcs[degree + 1],\n    out float dcs[degree])\n{\n    for (int d = 0; d < degree; ++d)\n    {\n        dcs[d] = float(degree - d) * pcs[d];\n    }   \n}\nvoid calculate_second_derivative_coeffs(\n    in float dcs[degree],\n    out float ddcs[degree - 1])\n{\n    for (int d = 0; d < degree - 1; ++d)\n    {\n        ddcs[d] = float(degree - d - 1) * dcs[d];\n    }\n}\n\nvoid init_poly_coeffs(float iTime)\n{\n    float T = iTime;\n    pcs[0] = sinOSC(-1.25, 1.25, T * 0.15);  // a   \n    pcs[1] = sinOSC( -2.0,  2.0, T * 0.6);   // b\n    pcs[2] = sinOSC( -1.0,  1.0, T * 0.45);  // c    \n    pcs[3] = sinOSC( -1.0,  1.0, T * 0.25);  // d\n    pcs[4] = sinOSC( -1.0,  1.0, T * 0.17);  // e\n    pcs[5] = sinOSC( -1.0,  1.0, T * 0.07);  // f    \n    pcs[6] = sinOSC( -1.0,  1.0, T * -0.17); // g\n    pcs[7] = sinOSC( -1.0,  1.0, T * -0.3);  // h\n    pcs[8] = sinOSC( -1.0,  1.0, T * 0.3);   // k\n    pcs[9] = sinOSC( -1.0,  1.0, T * 0.12);  // l\n    pcs[10] = sinOSC( -1.0,  1.0, T * 0.77); // n\n\n    calculate_first_derivative_coeffs(pcs, dcs);\n    calculate_second_derivative_coeffs(dcs, ddcs);\n}\n\nfloat eval_poly(\n    float x,\n    float pcs[degree+1],\n    int degree)\n{\n    float power = x, p_sum = pcs[degree];\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d];\n        power *= x;\n    }\n\n    return p_sum;\n}\nvec3 eval_poly_and_fs_deriv(\n    float x,\n    float pcs[degree + 1],\n    float dcs[degree],\n    float ddcs[degree - 1],\n    int degree)\n{\n    float power = 1., p_sum = 0., d_sum = 0., dd_sum = 0.;\n\n    for (int d = 2; d <= degree; ++d)\n    {\n        p_sum  += power * pcs[degree - d + 2];\n        d_sum  += power * dcs[degree - d + 1];\n        dd_sum += power * ddcs[degree - d];\n        power *= x;\n    }\n    d_sum += power * dcs[0];\n    p_sum += power * pcs[1]; power *= x;\n    p_sum += power * pcs[0];\n\n    return vec3(p_sum, d_sum, dd_sum);\n}\nfloat LaguerreMethod(\n    float x,\n    float pcs[degree + 1],\n    float dcs[degree],\n    float ddcs[degree - 1],\n    int degree)\n{\n    const float tolerance = TOLERANCE;\n    float n = float(degree), G, H, a = 9e5, t;\n    \n    for (int i = 0; i < 32 && abs(a) >= tolerance; ++i)\n    {\n        vec3 v = eval_poly_and_fs_deriv(x, pcs, dcs, ddcs, degree);\n    \n        G = v.y/v.x;\n        H = G*G - v.z/v.x;    \n        t = sqrt( (n-1.) * (n*H - G*G) );\n\n        a = abs(G + t) >  abs(G - t) ?\n                n / (G + t) :\n                n / (G - t);\n        \n        x -= a;      \n    }\n    \n    return x;\n}","name":"Common","description":"","type":"common"}]}