{"ver":"0.1","info":{"id":"MljyRt","date":"1509840878","viewed":354,"name":"Space Glowing 3","username":"tholzer","description":"A variant of 'Space Glowing 2' seen through a koleidoscope.\nSymmetry defined by Mouse.y position.\nAgain ... switch to full screen and lean back!","likes":15,"published":1,"flags":64,"usePreview":0,"tags":["3d","antialiasing","space","raytrace","glowing","satiny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sBSRz","filepath":"https://soundcloud.com/patrik-cybercom-detter/jarre-mix-jean-michel-jarre","previewfilepath":"https://soundcloud.com/patrik-cybercom-detter/jarre-mix-jean-michel-jarre","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------------------\n// SpaceGlowing3.glsl  by Antony Holzer \n//\n// A variant of 'Space Glowing 2' seen through a koleidoscope.\n// Symmetry defined by Mouse.y position.\n// Again ... switch to full screen and lean back!\n//\n//   v1.0  2017-11-05  initial release\n//   v2.0  2017-11-22  variable symmetry \n//\n// variantOf: https://www.shadertoy.com/view/ldjBRW\n// see also:  https://www.shadertoy.com/view/Mlj3zW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// tags:      3d, antialiasing, space, raytrace, glowing, satiny\n//----------------------------------------------------------------\n\nvec3 rotateY(vec3 p, float angle)\n{\n  float sa = sin(angle),   ca = cos(angle);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n//----------------------------------------------------------------\nfloat map (in vec3 p) \n{\n\tvec3 c = p; \n    float res = 0.0;\n\tfor (int i=0; i < 4; i++) \n\t{\n\t\tp = abs(p) / dot(p,p) -0.7;\n\t\tp.yz = vec2(p.y*p.y-p.z*p.z, 2.*p.y*p.z);\n\t\tres += exp(-20.0 * abs(dot(p,c)));\n\t}\n\treturn res * 0.4;\n}\n\n//----------------------------------------------------------------\nvec3 raymarch (vec3 ro, vec3 rd)\n{\n\tfloat t = 5.0;\n    float c = 0.0;\n\tvec3 col = vec3(0.0); \n\tfor (int i=0; i < 6; i++)\n\t{\n\t\tt += exp(c * -2.0) * 0.02;\n\t\tc = map(t * rd + ro);               \n\t\tcol= vec3(22.0*c*c, 2.0*c, 6.0*c*c*c) *0.16 + col *0.6;\n\t\tc = map(t*0.99 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c, 22.0*c*c, c) *0.16 + col *0.6;\n\t\tc = map(t*1.01 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c, 8.0*c*c, 11.*c)*0.16 + col *0.6;\n         // blue\n//\t\tcol= vec3(c*c, c, 6.0*c*c*c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c*c*c, 2.0*c*c, 8.0*c) *0.16 + col *0.96;\n\t\tcol= vec3(c, 18.0*c*c*c, 8.0*c*c)*0.16 + col *0.96;\n\t\t\n\t}\n\treturn col*0.2;\n}\n\n//----------------------------------------------------------------\n\nconst float PI = 3.14159265359;\n\n//float sideCount = 1.0;  // min. number of sides\n\n//----------------------------------------------------------------\n// equal to koleidoscope, but more compact \n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n\n//----------------------------------------------------------------\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = 2.0*(fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec2 mp = iMouse.xy / iResolution.xy;\n        \n    float sideCount = 1.0 + round(mp.y * 11.0);\n    \n    smallKoleidoscope(p, PI / sideCount);    \n    \n    vec3 ro = rotateY(vec3(3.), iTime*0.2 + iMouse.x / iResolution.x);\n    vec3 uu = normalize(cross(ro, vec3(1.0, 0.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ro));\n    vec3 rd = normalize(p.x*uu + p.y*vv - ro*0.5);\n    fragColor.rgb = log(raymarch(ro,rd) + 1.0)*0.5;\n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}]}