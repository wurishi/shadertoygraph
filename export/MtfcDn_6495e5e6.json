{"ver":"0.1","info":{"id":"MtfcDn","date":"1504303322","viewed":347,"name":"The sky is the limit","username":"rory618","description":"A deep zoom using normal 32 bit floating points with the help of one reference orbit pre-computed with high precision.\nhttp://www.superfractalthing.co.nf/sft_maths.pdf\nI'll save iteration skipping for the next one.\nyou have 200 frames to enter fs","likes":11,"published":1,"flags":96,"usePreview":0,"tags":["mandelbrot","zoom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tB3z3","filepath":"https://soundcloud.com/user-868203169/neil-cicierega-300mb","previewfilepath":"https://soundcloud.com/user-868203169/neil-cicierega-300mb","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    o = texture(iChannel2, i/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//highp int;\n//highp float;\n\n#define frame (iFrame-200)-((iFrame-200)/7820)*7820\n//#define get(xx) texelFetch(iChannel0,(ivec2(mod(floor(i.x-1.),iResolution.x),float(xx)+floor(i.y/float(l)-(int(i.x)==0?1.:0.) )*float(l))),0)\n#define get(xx) texture(iChannel0,(.5+floor(vec2(mod(floor(i.x-1.),iResolution.x),float(xx)+floor(i.y/float(l)-(int(i.x)==0?1.:0.) )*float(l))))/iResolution.xy)\n\nconst int i = 32768;\nconst int l = 16;\n/*const ivec2[] c = ivec2[](\n            ivec2(-2,-1),\n            ivec2(29,32767),\n            ivec2(20822,32747),\n            ivec2(3074,23479),\n            ivec2(6550,10373),\n            ivec2(4763,15934),\n            ivec2(20356,29524),\n            ivec2(30909,1129),\n            ivec2(9312,1010),\n            ivec2(289,20829),\n            ivec2(9227,3027),\n            ivec2(6104,27016),\n            ivec2(9270,4372),\n            ivec2(21943,6823),\n            ivec2(22676,19925),\n            ivec2(0,0));*/\nconst ivec2[] c = ivec2[](\n            ivec2(-2,0),\n            ivec2(24565,1025),\n            ivec2(26201,18633),\n            ivec2(25682,19700),\n            ivec2(21793,8204),\n            ivec2(10229,29796),\n            ivec2(1816,24779),\n            ivec2(4545,17780),\n            ivec2(22202,27783),\n            ivec2(30401,2374),\n            ivec2(22824,23216),\n            ivec2(5569,25379),\n            ivec2(32603,21391),\n            ivec2(8817,4731),\n            ivec2(9636,29056),\n            ivec2(0,0));\n\n\n\nvoid iterate(inout ivec2[l] z, ivec2[l] c){\n    ivec2 sum = ivec2(0);\n\n    ivec2[l] z2;\n    for(int x = 0; x < l; x++){\n        z2[x] = ivec2(0);\n    }\n    \n    for(int h = 15; h >= 0; h--){\n        ivec2 carry = ivec2(0);\n        \n        //loop along the diagonal and sum the partial products\n        ivec2 ts = sum;\n        for(int t = 0; t < (h+1)/2; t++){\n            ivec2 a = z[t];\n            ivec2 b = z[h-t];\n            sum += ivec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n\n            //compute overflow and carry\n            carry += sum/i;\n            sum -= (sum/i)* i;\n        }\n        \n        carry *= 2;\n        sum = 2*sum-ts;\n        \n        \n        sum += ((h+1)-((h+1)/2)*2)*ivec2(z[h/2].x*z[h/2].x-z[h/2].y*z[h/2].y,z[h/2].x*z[h/2].y*2);\n        \n        \n        carry += sum/i;\n        sum -=(sum/i)*i;\n        \n        \n        z2[h] = sum+c[h];\n        sum = carry;\n    }\n    \n    \n    \n    ivec2 carry = ivec2(0);\n    for(int h = 15; h >= 0; h--){\n        z2[h]+=carry;\n        carry = z2[h]/i;\n        z[h]=z2[h]-carry*i;\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    \n    \n    if(int(i.x)==0 && int(i.y) < l){\n        ivec2 d = c[int(mod(i.y,float(l)))];\n        o = vec4(intBitsToFloat(d.x),intBitsToFloat(d.y),0,0);\n    } else {\n        if(frame==int(i.x+iResolution.x*floor(i.y/float(l)))){\n            ivec2[l] z;\n            for(int x = 0; x < l; x++){\n                vec4 g = get(x);\n                z[x] = ivec2(floatBitsToInt(g.x),floatBitsToInt(g.y));\n            }\n            iterate(z,c);\n            ivec2 d = z[int(mod(i.y,float(l)))];\n            o = vec4(intBitsToFloat(d.x),intBitsToFloat(d.y),0,0);\n        } else {\n            if(frame==0){\n                o = vec4(0);\n            } else {\n                o = texture(iChannel0,vec2(i)/iResolution.xy);\n            }\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//highp int;\n//highp float;\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncf( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\n//alternative Gaussian,\n//thanks to @self_shadow\n//see http://www.dspguide.com/ch2/6.htm\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n\n\n\n\n#define frame (iFrame-200)-((iFrame-200)/7820)*7820\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 cprod(vec2 a, vec2 b){\n    return mat2(a,-a.y,a.x) * b;\n}\n\n//#define get(xx, it) texelFetch(iChannel0,ivec2(it%int(iResolution.x),float(xx)+floor(float(it)/iResolution.x)*float(l)),0)\n\n#define get(xx, it) texture(iChannel0,(.5+vec2(mod(float(it),iResolution.x),float(xx)+floor(float(it)/iResolution.x)*float(l)))/iResolution.xy)\n\n\nconst int l = 16;\nconst int i = 32768;\nconst float zs = 86.;\n\nvec2 zoom(vec2 d0, int a) {\n    d0 *= exp(-float(a)/zs);\n    return d0;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    o.w = 0.;\n    float e=0.;\n    vec3 r = hash33(vec3(iResolution.xy,frame));\n    vec2 jitter = vec2(n4rand_ss(r.xy),n4rand_ss(r.yz));\n\tvec2 d0 = zoom((fragCoord - iResolution.xy/2.+jitter ),frame);\n    float ds = exp(-.5*float(frame)/zs);;\n    vec2 d = d0;\n    int it;\n    for(it = 0; it < 1800; it++){\n        \n        vec2 z_ = vec2(0.);\n        float div = 1.;\n        for(int x = 2; x >= 0; x--){\n            vec2 g =  get(x,it).xy;\n            z_ /= float(i);\n            z_ += vec2(floatBitsToInt(g.x),floatBitsToInt(g.y));\n        }\n        \n        d = 2.*cprod(z_,d)+cprod(d,d)*ds + d0;\n        float m = length(z_+d*ds);\n        if(m>24.){\n\t        e = m;\n            break;\n        }\n    }\n        \n    float mu = 10.+log(log(24.))/log(2.) - log(abs(log(e)))/log(2.);\n    vec3 c = .5+.5*cos(.8*sqrt(mu+float(it))*vec3(1.2,1.3,1.4));\n    \n    \n    vec3 op = texture(iChannel2, ((fragCoord - iResolution.xy/2.)*exp(-1./zs) + iResolution.xy/2.)/iResolution.xy).xyz;\n    if(e!=0.){\n        o.xyz = mix(c,op,.8);\n        o.xyz = max(vec3(0),o.xyz);\n    } else {\n        o.xyz = op;\n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}