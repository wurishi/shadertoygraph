{"ver":"0.1","info":{"id":"M3SBDc","date":"1730008820","viewed":24,"name":"Simple 3D Vert/Cam Template ","username":"8InfinityTaco8","description":"This is a Template for vertices and a camera system based on The Art Of Code's tutorial on youtube\nhere: https://www.youtube.com/watch?v=dKA5ZVALOhs&ab_channel=TheArtofCode\nand here:https://www.youtube.com/watch?v=PBxuVlp7nuM&ab_channel=TheArtofCode\n ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["camera","primitives","template","shapes","vertices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Main shader function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get current time\n    float time = iTime;\n    \n    // Convert pixel coordinates to UV space (-0.5 to 0.5)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    // Correct for aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Initialize all possible shapes\n    Shape cube = createCube();\n    Shape triangle = createTriangle();\n    Shape pyramid = createPyramid();\n    \n    // Set up timing for shape transitions\n    float shapeDuration = 3.0;  // Each shape displays for 3 seconds\n    float totalDuration = shapeDuration * 3.0;  // Complete cycle time\n    float currentTimeInLoop = mod(time, totalDuration);  // Current position in cycle\n    \n    // Select current shape based on time\n    Shape currentShape;\n    if(currentTimeInLoop < shapeDuration) {\n        currentShape = cube;\n    }\n    else if(currentTimeInLoop < shapeDuration * 2.0) {\n        currentShape = triangle;\n    }\n    else {\n        currentShape = pyramid;\n    }\n    \n    // Calculate camera position (orbiting around shape)\n    vec3 rayOrigin = vec3(3. * sin(time), 4., -3. * cos(time));\n    vec3 lookAt = currentShape.center;  // Camera always looks at shape's center\n    float zoom = .5;  // Controls how close the virtual screen is to camera\n    \n    // Set up camera ray direction for this pixel\n    vec3 rayDirection = setupCamera(uv, rayOrigin, lookAt, zoom);\n    \n    // Render the current shape\n    float dist = drawVertices(rayOrigin, rayDirection, currentShape);\n    \n    // Output final color (white points on black background)\n    fragColor = vec4(vec3(dist), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Calculate the shortest distance from a point to a line defined by ray origin and direction\nfloat DistanceLine(vec3 rayOrigin, vec3 rayDirection, vec3 point) {\n    // Use cross product to find perpendicular vector, then get its length\n    // Divide by rayDirection length to normalize the distance\n    return length(cross(point - rayOrigin, rayDirection))/length(rayDirection);\n}\n\n// Renders a point in 3D space with smooth edges\nfloat DrawPoint(vec3 rayOrigin, vec3 rayDirection, vec3 point) {\n    // Calculate distance from ray to point\n    float dist = DistanceLine(rayOrigin, rayDirection, point);\n    // Create smooth transition from 0.06 to 0.05 for anti-aliasing\n    dist = smoothstep(.06, .05, dist);\n    return dist;\n}\n\n// Define a structure to store 3D shape data\nstruct Shape {\n    vec3 vertices[8];  // Array to store vertex positions (up to 8 vertices)\n    int vertexCount;   // Keep track of how many vertices are actually used\n    vec3 center;       // Store the center point of the shape\n};\n\n// Function to create a unit cube centered at origin\nShape createCube() {\n    Shape cube;\n    cube.vertexCount = 8;\n    \n    // Define all 8 vertices of the cube\n    // Starting with front face (0,0,0) to (1,1,1)\n    cube.vertices[0] = vec3(0.,0.,0.);  // Front bottom left\n    cube.vertices[1] = vec3(0.,0.,1.);  // Back bottom left\n    cube.vertices[2] = vec3(0.,1.,0.);  // Front top left\n    cube.vertices[3] = vec3(0.,1.,1.);  // Back top left\n    cube.vertices[4] = vec3(1.,0.,0.);  // Front bottom right\n    cube.vertices[5] = vec3(1.,0.,1.);  // Back bottom right\n    cube.vertices[6] = vec3(1.,1.,0.);  // Front top right\n    cube.vertices[7] = vec3(1.,1.,1.);  // Back top right\n    \n    // Calculate center by averaging all vertex positions\n    cube.center = vec3(0.);\n    for(int i = 0; i < cube.vertexCount; i++) {\n        cube.center += cube.vertices[i];\n    }\n    cube.center /= float(cube.vertexCount);\n    \n    return cube;\n}\n\n// Function to create a triangle in the XY plane\nShape createTriangle() {\n    Shape triangle;\n    triangle.vertexCount = 3;\n    \n    // Define three vertices of the triangle\n    triangle.vertices[0] = vec3(-1.0, -1.0, 0.0);  // Bottom left\n    triangle.vertices[1] = vec3(1.0, -1.0, 0.0);   // Bottom right\n    triangle.vertices[2] = vec3(0.0, 1.0, 0.0);    // Top center\n    \n    // Calculate center by averaging vertex positions\n    triangle.center = vec3(0.);\n    for(int i = 0; i < triangle.vertexCount; i++) {\n        triangle.center += triangle.vertices[i];\n    }\n    triangle.center /= float(triangle.vertexCount);\n    \n    return triangle;\n}\n\n// Function to create a square-based pyramid\nShape createPyramid() {\n    Shape pyramid;\n    pyramid.vertexCount = 5;\n    \n    // Define the base vertices (square base)\n    pyramid.vertices[0] = vec3(-1.0, 0.0, -1.0);  // Back left\n    pyramid.vertices[1] = vec3(1.0, 0.0, -1.0);   // Back right\n    pyramid.vertices[2] = vec3(1.0, 0.0, 1.0);    // Front right\n    pyramid.vertices[3] = vec3(-1.0, 0.0, 1.0);   // Front left\n    // Define apex (top point)\n    pyramid.vertices[4] = vec3(0.0, 2.0, 0.0);    // Top center point\n    \n    // Calculate center by averaging all vertices\n    pyramid.center = vec3(0.);\n    for(int i = 0; i < pyramid.vertexCount; i++) {\n        pyramid.center += pyramid.vertices[i];\n    }\n    pyramid.center /= float(pyramid.vertexCount);\n    \n    return pyramid;\n}\n\n// Generic function to render any shape's vertices\nfloat drawVertices(vec3 rayOrigin, vec3 rayDirection, Shape shape) {\n    float dist = 0.;\n    // Loop through all vertices and draw each point\n    for(int i = 0; i < shape.vertexCount; i++) {\n        dist += DrawPoint(rayOrigin, rayDirection, shape.vertices[i]);\n    }\n    return dist;\n}\n\n// Set up a virtual camera in 3D space\nvec3 setupCamera(vec2 uv, vec3 rayOrigin, vec3 lookAt, float zoom) {\n    // Calculate forward vector (direction camera is pointing)\n    vec3 foreward = normalize(lookAt - rayOrigin);\n    // Calculate right vector (perpendicular to up and forward)\n    vec3 right = cross(vec3(0.,1.,0.), foreward);\n    // Calculate up vector (perpendicular to forward and right)\n    vec3 up = cross(foreward, right);\n    \n    // Calculate center of virtual screen\n    vec3 center = rayOrigin + foreward * zoom;\n    // Calculate actual intersection point on virtual screen using UV coordinates\n    vec3 intersection = center + uv.x * right + uv.y * up;\n    // Return ray direction from origin to intersection point\n    return intersection - rayOrigin;\n}","name":"Common","description":"","type":"common"}]}