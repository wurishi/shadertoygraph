{"ver":"0.1","info":{"id":"Ds3fDX","date":"1697676048","viewed":324,"name":"Sacred geometries","username":"felipetovarhenao","description":" Fragment shader based on techniques from @kishimisu's YouTube tutorial: https://youtu.be/f4s1h2YETNY\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["patterns","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\nTitle: Sacred Geometries\n*/\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define MAX_ITER 3\n\nvec3 gradient(in float t,in vec3 a,in vec3 b,in vec3 c,in vec3 d){\n\treturn a+b*cos(TWO_PI*(c*t+d));\n}\n\nmat2 rot2(in float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat scale(in float x,in float a,in float b,in float c,in float d){\n\treturn(x-a)/(b-a)*(d-c)+c;\n}\n\nvec2 scale(in vec2 p,in float a,in float b,in float c,in float d){\n\treturn vec2(scale(p.x,a,b,c,d),scale(p.y,a,b,c,d));\n}\n\nvec3 scale(in vec3 p,in float a,in float b,in float c,in float d){\n\treturn vec3(scale(p.xy,a,b,c,d),scale(p.z,a,b,c,d));\n}\n\nvec4 scale(in vec4 p,in float a,in float b,in float c,in float d){\n\treturn vec4(scale(p.xy,a,b,c,d),scale(p.zw,a,b,c,d));\n}\n\nfloat fold(in float x){\n\treturn abs(mod(x+1.,2.)-1.);\n}\n\nvec2 fold(in vec2 p){\n\treturn vec2(fold(p.x),fold(p.y));\n}\n\nvec3 fold(in vec3 p){\n\treturn vec3(fold(p.xy),fold(p.z));\n}\n\nvec4 fold(in vec4 p){\n\treturn vec4(fold(p.xy),fold(p.zw));\n}\n\nfloat cosine(in float x,in float s){\n\tfloat y=cos(fract(x)*PI);\n\treturn floor(x)+.5-(.5*pow(abs(y),1./s)*sign(y));\n}\n\nvec2 cosine(in vec2 p,in float s){\n\treturn vec2(cosine(p.x,s),cosine(p.y,s));\n}\n\nvec3 cosine(in vec3 p,in float s){\n\treturn vec3(cosine(p.xy,s),cosine(p.z,s));\n}\n\nvec4 cosine(in vec4 p,in float s){\n\treturn vec4(cosine(p.xy,s),cosine(p.zw,s));\n}\n\nvec2 adjustViewport(in vec2 uv,in vec2 r){\n\treturn(uv*2.-r)/(r.x<r.y?r.x:r.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\t// reference time\n\tfloat t=iTime*.125;\n\t\n\tconst vec3 c1=vec3(.5);\n\tconst vec3 c2=vec3(.5);\n\tconst vec3 c3=vec3(1.);\n\tvec3 c4a=vec3(.7647,.8784,.9451);\n\tvec3 c4b=vec3(.4667,.549,.6);\n\tvec3 c4=mix(c4a,c4b,cosine(fold(t*2.5),1.));\n\t\n\tvec2 uv=adjustViewport(fragCoord.xy,iResolution.xy)*.75;\n\t\n\t// angle of rotation for each fractal layer;\n\tfloat theta=TWO_PI/scale(sin(t*.1),-1.,1.,1.,12.);\n\t\n\t// mirror-repetition of space\n\tuv=fold(uv);\n\t\n\t// get mirrored distance from origin\n\tfloat mag=length(uv);\n\t\n\t// copy global uv coordinates\n\tvec2 loc=uv;\n\t\n\t// initialize alpha\n\tfloat a=0.;\n\t\n\t// fractal zoom\n\tfloat base=2.+sin(t)*.5;\n\t\n\t// frequency of rings\n\tfloat fq=7.5+sin(mag-t*.5)*3.;\n\t\n\t// stroke edge\n\tfloat edge=cosine(fold(t*.1),2.5)*.008+.01;\n\t\n\t// stroke color\n\tvec3 col=vec3(0.);\n\t\n\tfloat blur=exp(-length(uv*mag));\n\t// generate fractal layers\n\tfor(float i=0.;i<float(MAX_ITER);i+=1.){\n\t\t// rotate current layer\n\t\tloc*=rot2(pow(base,i)*theta);\n\t\t\n\t\t// fractalize\n\t\tloc=fract(loc*base)-.5;\n\t\t\n\t\t// fold layer\n\t\tloc=fold(loc);\n\t\t\n\t\t// get layer's distance from origin\n\t\tfloat d=length(loc)*blur;\n\t\t\n\t\t// distance to stroke\n\t\td=sin(d*fq+t)/fq;\n\t\td=abs(d);\n\t\td=edge/d;\n\t\td=cosine(d,1.5);\n\t\td=pow(d,.5);\n\t\t\n\t\tcol+=gradient(mag+i*.25-t*.5,c1,c2,c3,c4)*d;\n\t}\n\t\n\tfragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}