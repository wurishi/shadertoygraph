{"ver":"0.1","info":{"id":"ddXczl","date":"1687098634","viewed":363,"name":"Textureless Black Hole","username":"ZaOniRinku","description":"A simple black hole ray marcher without any texture nor random (the random function is used for the background stars).","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ref: https://medium.com/dotcrossdot/raymarching-simulating-a-black-hole-53624a3684d3\n\nmat3 camera(vec3 direction) {\n\tvec3 forward = normalize(direction);\n\tvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n\tvec3 realUp = cross(forward, right);\n\n\treturn mat3(right, -realUp, forward);\n}\n\nfloat shRoundedCylinder(vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n\n  return min(max(d.x,d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n\n    return mix(d2, -d1, h) + k * h * (1.0 - h); \n}\n\nvec2 rotate(vec2 p, float angle) {\n\treturn cos(angle) * p + sin(angle) * vec2(p.y, -p.x);\n}\n\nfloat random(vec2 uv) {\n\treturn fract(sin(dot(uv,vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat dot2(vec3 v) {\n    return dot(v, v);\n}\n\nvec3 blackHolePosition = vec3(0.0, 0.0, 0.5);\nconst vec3 blackHoleColor = vec3(0.0, 0.0, 0.0);\nconst vec3 accretionDiskColor = vec3(0.05, 0.01, 0.001);\n\nconst float schwarzschildRadius = 0.5;\nconst float spaceDistorsion = 4.5;\n\nconst uint maxSteps = 500u;\nconst float stepSize = 0.05;\nconst float epsilon = 0.001;\n\nvec3 background(vec3 p) {\n\tfloat a = random(p.xz);\n\ta = pow(a, 500.0);\n\n\treturn vec3(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n\n\tvec2 centeredUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\tfloat pitch = ((iMouse.y / iResolution.y) + 0.1) * 3.1415 * 2.0;\n\tfloat yaw = ((iMouse.x / iResolution.x) - 0.1) * 3.1415 * 2.0;\n\tvec3 o = vec3(cos(pitch) * cos(yaw), -sin(pitch), cos(pitch) * sin(yaw)) * 15.0;\n\tvec3 d = camera(blackHolePosition - o) * vec3(centeredUv, 2.0);\n\n\tvec3 oldP = o;\n\tvec3 oldD = d;\n\tfloat blackHoleInfluence = 0.0;\n\tfor (uint i = 0u; i < maxSteps; i++) {\n\t\tvec3 unaffectedDir = d * stepSize;\n\t\tvec3 affectedDir = (blackHolePosition - oldP) * stepSize;\n\t\tfloat distToBlackHole = distance(blackHolePosition, oldP);\n\n\t\tfloat influence = pow(schwarzschildRadius, spaceDistorsion) / pow(distToBlackHole, spaceDistorsion);\n\n\t\td = normalize(mix(unaffectedDir, affectedDir, influence));\n\n\t\tvec3 p = oldP + (d * stepSize);\n\n\t\tvec3 pAccretionDisk = vec3(rotate((p - blackHolePosition).xy, -0.48), p.z);\n\t\tif (opSmoothSubtraction(length(pAccretionDisk) - 3.5, shRoundedCylinder(pAccretionDisk, 3.5, 0.02, 0.01), 0.5) < epsilon) {\n\t\t\tfloat accretionDiskU = cos(iTime / 2.0 - distToBlackHole);\n\t\t\tfloat accretionDiskV = sin(iTime / 2.0 - distToBlackHole);\n\t\t\tmat2 accretionDiskRotation = mat2(accretionDiskU, accretionDiskV, -accretionDiskV, accretionDiskU);\n\t\t\tfloat accretionDiskValue = mod(accretionDiskRotation * pAccretionDisk.xz, 1.0).x * mod(accretionDiskRotation * pAccretionDisk.xz, 1.0).y;\n\t\t\taccretionDiskValue = 0.2 / accretionDiskValue;\n\t\t\taccretionDiskValue = pow(accretionDiskValue, 2.0);\n\t\t\tfinalColor += accretionDiskColor * accretionDiskValue;\n\t\t}\n        \n        // https://www.shadertoy.com/view/llSGRG\n        finalColor += (vec3(1.0) - blackHoleColor) * (4.5 / dot2(blackHolePosition - p)) * 0.0033 * smoothstep(0.0, 0.66, length(p - blackHolePosition) - schwarzschildRadius);\n\n\t\toldP = p;\n\t\toldD = d;\n\n\t\tblackHoleInfluence = step(distToBlackHole, schwarzschildRadius);\n\t}\n\n\tfinalColor += mix(background(oldP), blackHoleColor, blackHoleInfluence);\n\n\tfragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}