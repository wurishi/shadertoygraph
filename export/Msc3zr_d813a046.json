{"ver":"0.1","info":{"id":"Msc3zr","date":"1447708081","viewed":370,"name":"Sierpinski Pyramid 1","username":"Densen90","description":"Rendering a Sierpinski Pyramid with Raymarching.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sierpinski","pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define MAXSTEPS 256\n#define EPSILON 0.001\n#define AMBIENT 0.2\n#define MAXDEPTH 100.0\n#define SHADOWDEPTH 32.0\n#define SOFTSHADOWFAC 32.0\n#define FRACTALITERATIONS 16\n#define AOSAMPLES 5.0\n\nconst vec3 lightCol = vec3(0.7, 0.5, 0.8);\nconst vec3 diffuse = vec3(1, 1, 1);\n\nvec3 lightDir;\n\nstruct Camera\n{\n\tvec3 pos;\n\tvec3 dir;\n} cam;\n\n// Rotation / Translation of a point p with rotation r\nvec3 rotate( vec3 p, vec3 r )\n{\n\tr.x *= PI/180.0;\n\tr.y *= PI/180.0;\n\tr.z *= PI/180.0;\n\n\tmat3 xRot = mat3 (\t1,\t0,\t\t\t\t0,\n\t\t\t\t\t\t0,\tcos(r.x),\t-sin(r.x),\n\t\t\t\t\t\t0,\tsin(r.x),\tcos(r.x) );\n\tmat3 yRot = mat3 ( \tcos(r.y),\t\t0,\tsin(r.y),\n\t\t\t\t\t\t0,\t\t\t\t\t1,\t0,\n\t\t\t\t\t\t-sin(r.y),\t\t0,\tcos(r.y) );\n\tmat3 zRot = mat3 (\tcos(r.z),\t-sin(r.z),\t0,\n\t\t\t\t\t\tsin(r.z),\tcos(r.z),\t0,\n\t\t\t\t\t\t0,\t\t\t\t0,\t\t\t\t1 );\n\treturn xRot * yRot * zRot * p;\n}\n\n// give the distance to a plane from a point p and normal n, shifted by y\nfloat distPlane( vec3 p, vec3 n, float y )\n{\n\treturn dot(p-vec3(0,y,0),n);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat distFrac(vec3 p)\n{\n\tconst float scale = 1.8;\n\tconst float offset = 2.0;\n\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n\t\tp.xy = (p.x+p.y < 0.0) ? -p.yx : p.xy;\n\t\tp.xz = (p.x+p.z < 0.0) ? -p.zx : p.xz;\n\t\tp.zy = (p.z+p.y < 0.0) ? -p.yz : p.zy;\n\n\t\tp = scale*p-offset*(scale-1.0);\n\t}\n \n\treturn length(p) * pow(scale, -float(FRACTALITERATIONS));\n}\n\n// return positive values when outside and negative values inside,\n// --> distance of the nearest surface.\nfloat distanceField(vec3 p)\n{\n\t//Rotate scene around y-axis\n\tvec3 rotP = rotate(p, vec3(0, mod(iTime*20.0, 360.0),0));\n\trotP = rotate(rotP-vec3(0,-0.6,0), vec3(0, 45,55));\n\t\n\n\tfloat dPlane = distPlane(p, vec3(0,1,0), -2.0);\n\tfloat dFrac = distFrac(rotP);\n\treturn min(dFrac, dPlane);\n}\n\n// marching along the ray at step sizes, \n// and checking whether or not the surface is within a given threshold\nvec4 raymarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat totalDist = 0.0;\n\tfor(int j=0; j<MAXSTEPS; j++)\n\t{\n\t\tvec3 p = rayOrigin + totalDist*rayDir;\n\t\tfloat dist = distanceField(p);\n\t\tif(abs(dist)<EPSILON)\t//if it is near the surface, return an intersection\n\t\t{\n\t\t\treturn vec4(p, 1.0);\n\t\t}\n\t\ttotalDist += dist;\n\t\tif(totalDist>=MAXDEPTH) break;\n\t}\n\treturn vec4(0);\n}\n\n// Approximates the (normalized) gradient of the distance function at the given point.\n// If p is near a surface, the function will approximate the surface normal.\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\n// calculate shadow, ro=origin, rd=dir\n// look for nearest point when raymarching, factor k gives smoothnes, 2=smooth, 128=hard\n// dl is distance to light, so only return if distance is smaller\nfloat shadow(vec3 ro, vec3 rd, float k)\n{\n\tfloat res = 1.0;\n    float t = EPSILON;\n    for( int i=0; i<1000; i++)\n    {\n        float h = distanceField(ro + rd*t);\n        if( h<EPSILON )\n            return AMBIENT;\n        res = min( res, k*h/t );\n        t += h;\n        if(t>=SHADOWDEPTH) break;\n    }\n    return res;\n}\n\n//calculate ambient occlusion\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat res = 0.0;\n\tfloat fac = 1.0;\n\tfor(float i=0.0; i<AOSAMPLES; i++)\n\t{\n\t\tfloat distOut = i*0.3;\t//go on normal ray AOSAMPLES times with factor 0.3\n\t\tres += fac * (distOut - distanceField(p + n*distOut));\t//look for every step, how far the nearest object is\n\t\tfac *= 0.5;\t//for every step taken on the normal ray, the fac decreases, so the shadow gets brighter\n\t}\n\treturn 1.0 - clamp(res, 0.0, 1.0);\n}\n\n//calculate the color, the shadow, the lighting for a position\nvec3 shading(vec3 pos, vec3 rd, vec3 n)\n{\n\tvec3 light = max(AMBIENT, dot(n, lightDir)) * lightCol;\t//lambert light with light Color\n\tlight *= diffuse;\t//diffuse lighting, area lit lighting\n\tlight *= shadow(pos, lightDir, SOFTSHADOWFAC);\t//add shadow\n\tlight += ambientOcclusion(pos, n) * AMBIENT;\n\treturn light;\n}\n\nvec4 renderImage()\n{\n\tfloat fov = 60.0;\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / iResolution.x;\n\tvec2 p = tanFov * (gl_FragCoord.xy * 2.0 - iResolution.xy);\n\n\tcam.pos = vec3(0,0,-8);\n\tcam.dir = normalize(vec3( p.x, p.y, 1 ));\n    \n    lightDir = normalize(vec3(-1,0.8,-1));\n\n\tvec4 res;\n\n\tres = raymarch(cam.pos, cam.dir);\n\tres.xyz = (res.a==1.0) ? clamp(shading(res.xyz, cam.dir, getNormal(res.xyz)), 0.0, 1.0) : vec3(0);\n\n\treturn vec4(res.xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = renderImage();\n}","name":"","description":"","type":"image"}]}