{"ver":"0.1","info":{"id":"sscyW8","date":"1653366444","viewed":137,"name":"Ray-cut disk intersection","username":"LucasR","description":"Analytic intersection between a ray and a cut disk, useful for ray tracing. You can move the ray origin with the mouse.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCutDisk( in vec2 p, in float r, in float h ){\n// source: https://www.shadertoy.com/view/ftVXRc\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    p.x = abs(p.x);\n    \n    // select circle or segment\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n\n    return (s<0.0) ? length(p)-r :        // circle\n           (p.x<w) ? h - p.y     :        // segment line\n                     length(p-vec2(w,h)); // segment corner\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n// source: https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat sdCircle( vec2 p, float r ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nvec2 intCutDisk(vec2 ro, vec2 rd, float r, float h){ // rd must be of length 1.\n// modified version based on iq's intEllipse function -- still needs work though\n    vec2 ocn = ro / r;\n    vec2 rdn = rd / r;\n    float m = rd.y/rd.x; // line equation: y = m*x + k\n    float k = ro.y - m*ro.x;\n    float a = dot( rdn, rdn );\n    float b = dot( ocn, rdn );\n    float c = dot( ocn, ocn );\n    float h0 = b*b - a*(c-1.0);\n    if( h0<0.0 ) return vec2(0.0); // there's no intersection\n    // intersections with circle\n    h0 = sqrt(h0);\n    float t1 = (-b-h0)/a;\n    float t2 = (-b+h0)/a;\n    vec2 Q1 = ro+t1*rd;\n    vec2 Q2 = ro+t2*rd;\n    \n    // intersection with line segment\n    vec2 Q0;\n    Q0 = vec2((h-k)/m, h);\n    //float P1x = sqrt(r*r - h*h);\n    float P1x = r*r - h*h;\n    float P2x = -P1x;\n    //if((P2x > Q0.x) || (Q0.x > P1x)) Q0 = ro - rd; // not a valid intersection\n    if((P2x > Q0.x*Q0.x) || (Q0.x*Q0.x > P1x)) Q0 = ro - rd; // not a valid intersection\n    \n    // choose smallest valid distance\n    // this should be faster than the sort\n    /*float L0 = length(Q0-ro);\n    float L1 = length(Q1-ro);\n    float L2 = length(Q2-ro);*/\n    float d0 = dot(rd, Q0-ro);\n    float d1 = dot(rd, Q1-ro);\n    float d2 = dot(rd, Q2-ro);\n    float d0o = d0 + 10000.*float(d0<0.);\n    float d1o = d1 + 10000.*float((d1<0.) || (Q1.y < h));\n    float d2o = d2 + 10000.*float((d2<0.) || (Q2.y < h));\n    return vec2(min(min(d0o, d1o), d2o), float((d0>0.) || ((d1>0.) && (Q1.y>h)) || ((d2>0.) && (Q2.y>h))));\n\n    // sort the solutions and choose the nearest one that's also valid\n    /*vec2 solutions[3];\n    float L0 = length(Q0-ro);\n    float L1 = length(Q1-ro);\n    float L2 = length(Q2-ro);\n    if((L0 < L1) && (L0 < L2)){\n        solutions[0] = Q0;\n        if(L1 < L2){\n            solutions[1] = Q1;\n            solutions[2] = Q2;\n        }else{\n            solutions[1] = Q2;\n            solutions[2] = Q1;\n        }\n    }else if((L1 < L0) && (L1 < L2)){\n        solutions[0] = Q1;\n        if(L0 < L2){\n            solutions[1] = Q0;\n            solutions[2] = Q2;\n        }else{\n            solutions[1] = Q2;\n            solutions[2] = Q0;\n        }\n    }else{\n        solutions[0] = Q2;\n        if(L0 < L1){\n            solutions[1] = Q0;\n            solutions[2] = Q1;\n        }else{\n            solutions[1] = Q1;\n            solutions[2] = Q0;\n        }\n    }\n\n    if((dot(rd, solutions[0]-ro) > 0.) && (solutions[0].y >= h)) return vec2(length(solutions[0]-ro), 1.);\n    if((dot(rd, solutions[1]-ro) > 0.) && (solutions[1].y >= h)) return vec2(length(solutions[1]-ro), 1.);\n    if((dot(rd, solutions[2]-ro) > 0.) && (solutions[2].y >= h)) return vec2(length(solutions[2]-ro), 1.);\n    \n    return vec2(0.);*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (-iResolution.xy + 2.*(fragCoord))/iResolution.y;\n    float LTh = 3./iResolution.y; // line thickness\n    float t = iTime/3.;\n    vec2 ro = (-iResolution.xy + 2.*(iMouse.xy))/iResolution.y;\n    vec2 rd = vec2(cos(t), sin(t));\n    if(iMouse.z > 0.){ // move ro to mouse position if the LMB is being presssed\n        ro = (-iResolution.xy + 2.*(iMouse.xy))/iResolution.y;\n    }else{\n        float t = iTime/3.;\n        ro = vec2(0.);\n    }\n    float r = .5;\n    float h = -.2;\n    \n    vec3 col = vec3(0.);\n    float d = sdCutDisk(uv, r, h);\n    col = vec3(smoothstep(1.-LTh, 1., 1.-abs(d)));\n    vec2 inter = intCutDisk(ro, rd, r, h);\n    \n    col = mix(col, vec3(.2), .2*smoothstep(1.-LTh, 1., 1.-sdCircle(uv, r)));\n    \n    col = mix(col, vec3(1., 1., 0.), smoothstep(1.-LTh, 1., 1.-sdSegment(uv, ro, ro+rd*10.))); // line\n    col = mix(col, vec3(1., 0., 0.), smoothstep(1.-LTh, 1., 1.-sdCircle(uv-ro, .015))); // ro\n    if(inter.y == 0.){ // no valid intersection\n        col = mix(col, vec3(1., 0., 0.), 0.1);\n    }else{\n        col = mix(col, vec3(0., 1., 0.), smoothstep(1.-LTh, 1., 1.-sdCircle(uv-(ro+inter.x*rd), .015)));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}