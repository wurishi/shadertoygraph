{"ver":"0.1","info":{"id":"4dc3zN","date":"1454373022","viewed":191,"name":"Raytracer Klems 2","username":"Klems","description":"testy","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415\n#define EXP 100.0\n\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nbool traceSphere(in vec3 solidOrigin, in float radius, in vec3 origin, in vec3 direction,\n                 out float dist, out vec3 normal) { \n    vec3 d = origin - solidOrigin;\n    float b = dot(direction, d);\n    float c = dot(d, d)-radius*radius;\n    float t = b*b-c;\n    if (t > 0.0) {\n        dist = -b-sqrt(t);\n        normal = origin+direction*dist-solidOrigin;\n        normal /= radius;\n        return true;\n    }\n    return false;\n}\n\nvec3 getBackground(vec3 normal) {\n    return texture(iChannel0, normal).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv.x*0.8, uv.y*0.8, 1.0));\n    vec3 from = vec3(0.0, 0.0, -2.0);\n    vec3 solidOrigin = vec3(0.0, 0.0, 0.0);\n    \n    dir.xz *= rot(iTime*0.1);\n    from.xz *= rot(iTime*0.1);\n    \n    float dist;\n    vec3 normal;\n    \n    fragColor.a = 1.0;\n    \n    float radius = 1.0;\n    \n    if ( traceSphere(solidOrigin, radius, from, dir, dist, normal) ) {\n        \n        // trace to the outside of the sphere\n        from = from+dir*dist+normal*0.001;\n        \n        vec3 refl = reflect(dir, normal);\n        \n        vec3 color = vec3(0.0);\n        float acc = 0.0;\n        \n        float randA = noise(from.xyy*147.1248);\n        float randB = noise(from.yxx*123.0134);\n        \n        for (int i = 0 ; i < 100 ; i++) {\n            vec3 right = normalize(cross(refl, vec3(0, 0, 1)));\n            vec3 left = cross(right, refl);\n            float theta = hash(float(i)*randA) * 2.0 * PI;\n            float alpha = acos(pow(hash(float(i)*randB), 1.0/(EXP+1.0)));\n            vec3 ddir = right*cos(theta)*sin(alpha) + left*sin(theta)*sin(alpha) + refl*cos(alpha);\n            color += getBackground(ddir);\n        }\n        \n        color /= 100.0;\n        fragColor.rgb = color;\n        \n    } else {\n        \n        // looking at background\n        fragColor.rgb = getBackground(dir);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}