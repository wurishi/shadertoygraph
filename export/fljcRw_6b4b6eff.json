{"ver":"0.1","info":{"id":"fljcRw","date":"1649374402","viewed":82,"name":"HelloWorldRayMarching","username":"NtFreX","description":"Hello world ray marching, a lot of strange things","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","helloworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_STEPS 10000\n#define MAX_DIST 15.\n#define SURFACE_DIST 0.001\n#define EPSILON 0.000001\n#define UNDERSTEP 0.7\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n\tvec3 z = normalize(eye - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    mat4 translation = mat4(\n        vec4(1.0, 0.0, 0.0, eye.x),\n    \tvec4(0.0, 1.0, 0.0, eye.y),\n        vec4(0.0, 0.0, 1.0, eye.z),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 rotation = transpose(\n        mat4(\n            vec4(x, 0.0),\n            vec4(y, 0.0),\n            vec4(z, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0)\n        )\n    );\n    return translation * rotation;\n}\n\nvec3 getRayDir(mat4 camera, float fov, vec2 pixel) {\n    vec2 p = 2.0 * ((pixel / iResolution.xy) - vec2(0.5, 0.5));\n    vec2 h = vec2(\n        tan(fov / 2.0) * (iResolution.x / iResolution.y), \n        tan(fov / 2.0)\n    );\n    vec3 pCam = vec3(p * h, -1.0);\n\treturn normalize((inverse(camera) * vec4(pCam, 0.0)).xyz);\n}\n\nfloat sdPyramid(vec3 p, float h) {\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat smoothSubtractionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smoothUnionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec4 cp(vec4 sd1, vec4 sd2) {\n    return (sd1.x < sd2.x) ? sd1 : sd2;\n}\n\nvec4 getDist(vec3 p) {\n    float dPlane = /*sin(p.x) * .1 + */sdPlane(p, 0.);\n    float dSphere = sdSphere(p - vec3(0, 1, 0), clamp(abs(sin(iTime)), .1, 1.) * clamp(abs(sin(p.x)), .4, 1.) * 2.);\n    float dBox = sdBox(p - vec3(3, 1, 0), vec3(1.0, 1.0, 2.0));\n    float dSmallBox = sdBox(p - vec3(3, 2, 0), vec3(abs(sin(iTime * 2.)) * .8, .8, 1.8));\n    float dPhyramid = sin(p.y*10.) * .1 + sdPyramid(p - vec3(-2, 0, 0), abs(sin(iTime) * 4.0));\n    \n    float dF = sdCappedCylinder(p - vec3(sin(p.y*10.) * .1, 0., cos(p.y*10.) * .1 - 2.), .2, abs(sin(iTime*.2)) *  3.);\n    dF = smoothUnionSDF(dF, sdSphere(p - vec3(0, 3.*abs(sin(iTime*.2)), -2), .5) + sin(p.y*5.)*.2, .04);\n    \n    vec4 d = vec4(dPlane, .2, .2, .2);\n    d = cp(vec4(dSphere, 1, 0, 0), d); \n    d = cp(vec4(smoothSubtractionSDF(dSmallBox, dBox, .25), 0, 1, 0), d);\n    d = cp(vec4(dPhyramid, 0, 0, 1), d);\n    d = cp(vec4(dF, .1, .5, .5), d);\n            \n    return d;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n float dO = 0.;\n vec4 dS = vec4(0);\n for(int i = 0; i < MAX_STEPS; i++) {\n     vec3 p = ro + dO * rd;\n     dS = getDist(p);\n     dO += dS.x * UNDERSTEP;\n     if(dS.x < SURFACE_DIST || dO > MAX_DIST) break;\n }\n return vec4(dO, dS.y, dS.z, dS.w);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p).x;\n    vec2 e = vec2(EPSILON, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 0);\n    lightPos.xz += vec2(sin(iTime) * 2. - 1., cos(iTime) * 2. - 1.);\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = rayMarch(p + n * SURFACE_DIST, l).x;\n    if(d < length(lightPos-p)) dif *= 0.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 ro = vec3(0., 2.5, 10.);\n    vec3 ro = vec3(sin(iTime) * 10., 4.5, cos(iTime) * 10.);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float fov = radians(45.0);\n    \n    mat4 camera = lookAt(ro, target, up); \n    vec3 rd = getRayDir(camera, fov, fragCoord);\n    vec4 d = rayMarch(ro, rd);\n    if(d.x <= MAX_DIST) {//sqrt(pow(MAX_DIST, 2.) + pow(length(ro - target - rd), 2.))) {\n        vec3 p = ro + rd * d.x;\n        float dif = getLight(p);\n        fragColor = vec4(dif * d.yzw, 1.0);\n        //fragColor = vec4(vec3(d.x * .05), 1.);\n    } else {\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        vec3 col =  -vec3(.5, .5, 0.) * uv.y + 0.5;\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}