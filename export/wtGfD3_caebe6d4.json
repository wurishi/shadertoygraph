{"ver":"0.1","info":{"id":"wtGfD3","date":"1615168510","viewed":87,"name":"ifs strobo2 (epilepsy warning)","username":"sus1357","description":"you can adjust speed of morphing (float speed)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ifs","stroboscopic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    // ekrannaya konstanta - RAZMER OBLASTI CHISEL(a chto esli NE konstanta?...)\nvec2 DOMAIN_XY = vec2(16., 9.);\nfloat speed = 6.;\n\n    // KIFS-konstanti\nconst int N = 2;// N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 2; // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 10;// WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n    //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n    //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n    //1d gauss\n    // ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n    //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n \n \n \n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n    // initialization\n    float scale = 2.;\n    \n    vec2 symm[N];// // = (, );\n    //symm[0] = a2v(60.); symm[1] = a2v(-60.);\n    symm[0] = a2v(60. + iTime*speed); symm[1] = a2v(-60.);\n    //symm[0] = a2v(-60. + iMouse.x); symm[1] = a2v(60. + iMouse.y);\n    \n    //vec2 offset = vec2(-1.+2.*iMouse.x/iResolution.x, -1.+2.*iMouse.y/iResolution.y);\n    vec2 offset = vec2(.0,.0);\n    float dist[N]; dist[0] = -1.; dist[1] = -1.;\n    \n    \n    \n    // algoritm\n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n];\n                //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n        }\n        uv*=scale;\n            uv -= (scale - 1.) * offset;\n        if(float(i) > mod(30.*iTime, float(ITER))) break; // stroboscope\n    }\n // Output to screen\n \n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue);\n    vec3 col_g = gauss(uv, .1)*white;\n   \n\n\n    vec2 norm = fragCoord/iResolution.xy;\n   vec3 col_ex = 0.5 + 0.5*cos(2.35+norm.xyx+vec3(0,2,4));\n   float mod_const = pow(scale, float(ITER));\n   col_ex *= step( max( mod(uv.x, mod_const), mod(uv.y, mod_const) ), 0.9*mod_const );\n   \n\n    float w = 0.05 * mod_const;\n    \n    vec3 x_positive = float(int((uv.x>0.0)&&(uv.y<w)&&(uv.y>-w)))*red;\n    vec3 x_negative = float(int((uv.x<0.0)&&(uv.y<w)&&(uv.y>-w)))*0.2*red; \n    vec3 y_positive = float(int((uv.y>0.0)&&(uv.x<w)&&(uv.x>-w)))*(red+green);\n    vec3 y_negative = float(int((uv.y<0.0)&&(uv.x<w)&&(uv.x>-w)))*0.2*(red+green);\n    vec3 osi = x_positive + x_negative + y_positive + y_negative;\n\n   vec2 xy_examp = fragCoord/iResolution.xy;\n    vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n   // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n    fragColor = vec4(col_g+koltso+koltso2 + .5*(osi*col_examp + osi + col_examp),1.0);\n}","name":"Image","description":"","type":"image"}]}