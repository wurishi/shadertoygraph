{"ver":"0.1","info":{"id":"fsKfDG","date":"1659031453","viewed":339,"name":"GalaxyEye_625a","username":"harry7557558","description":"Rendering an eyeball inside a witch ball, with galaxy/stars around it.\nThe volume is precomputed and stored in Cube A. Crashes for some reason.\nMouse-able.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["volume","star","galaxy","universe","emission","scatter","eyeball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Volume rendering\n\n// precomputed volume in Cube A\n// rendering in Buffer A\n\n// Crashed in Chrome/ANGLE and occationally FireFox (Windows+Android)\n// EDIT: Thanks @Envy24 for pointing out the bug in the comment!\n\n// Auto-generated Shader preview:\n// https://www.shadertoy.com/media/shaders/fsKfDG.jpg\n\n// If the image appears too dim, try to rewind it.\n\n\n\nvoid mainImage(out vec4 c, in vec2 g) {\n    vec3 col = texelFetch(iChannel0, ivec2(g), 0).xyz;\n    col *= 1.1;\n    c = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// path tracing\n\nuint rand_seed = 0u;\nuint randu() { return rand_seed = rand_seed * 1664525u + 1013904223u; }\nfloat randf() {\n    //return 0.5;\n    return float(randu()) * (1./4294967296.);\n}\n\n\n// sphere intersection function\nbool intersectSphere(vec3 o, float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    ro -= o;\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\n\n// scattering / importance sampling functions\n\n// Lambert\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = randf();\n    float an = 2.0*PI*randf();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\n\n// refractive\nvec3 sampleFresnelDielectric(vec3 rd, vec3 n, float n1, float n2) {\n    float eta = n1 / n2;\n    float ci = -dot(n, rd);\n    if (ci < 0.) ci = -ci, n = -n;\n    float ct = 1. - eta * eta * (1. - ci * ci);\n    if (ct < 0.) return rd + 2.*ci*n;\n    ct = sqrt(ct);\n    float Rs = (n1 * ci - n2 * ct) / (n1 * ci + n2 * ct);\n    float Rp = (n1 * ct - n2 * ci) / (n1 * ct + n2 * ci);\n    float R = 0.5 * (Rs * Rs + Rp * Rp);\n    return randf() > R ?\n        rd * eta + n * (eta * ci - ct)  // refraction\n        : rd + 2.*ci*n;  // reflection\n}\n\n// phase functions\nvec3 sampleUniformSphere() {\n    float u = 2.*PI*randf();\n    float v = 2.*randf()-1.;\n    return vec3(vec2(cos(u), sin(u))*sqrt(1.-v*v), v);\n}\nvec3 sampleHenyeyGreenstein(vec3 wi, float g) {\n    if (g == 0.) return sampleUniformSphere();\n    if (g >= 1.) return wi;\n    if (g <= -1.) return -wi;\n    float us = randf();\n    float vs = 2.*PI*randf();\n    float z = (1.+g*g-pow((1.-g*g)/(2.*g*(us+(1.-g)/(2.*g))),2.))/(2.*g);\n    vec2 xy = vec2(cos(vs), sin(vs)) * sqrt(1.-z*z);\n    vec3 u = normalize(cross(wi, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, wi);\n    vec3 wo = normalize(xy.x*u + xy.y*v + z*wi);\n    return wo;\n}\n\n\n// Cook-Torrance BRDF - https://www.shadertoy.com/view/sddXWj\n\nfloat sampleGgxImportance(vec3 wi, float alpha, out vec3 wo) {\n    float su = 2.*PI*randf();\n    float sv = randf();\n    //sv = acos(sqrt((1.0-sv)/((alpha*alpha-1.)*sv+1.)));\n    sv = atan(alpha*sqrt(sv/(1.-sv)));\n    vec3 h = vec3(sin(sv)*vec2(cos(su),sin(su)), cos(sv));\n    wo = -(wi-2.*dot(wi,h)*h);\n    return wo.z<0. ? 0. : 4.*dot(wi, h);\n}\n\nvec3 sampleCookTorrance(\n    vec3 wi, vec3 n,\n    float alpha,  // roughness\n    float f0,  // ratio of reflection along the normal\n    float lambertian,  // ratio of lambertian coefficient\n    vec3 albedo,\n    inout vec3 m_col\n    ) {\n\n    if (randf() < lambertian) {\n        vec3 wo = sampleCosWeighted(n);\n        m_col *= albedo;\n        return wo;\n    }\n\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    wi = vec3(dot(wi, u), dot(wi, v), dot(wi, n));\n    vec3 wo, m;  // out and half vector\n\n    // GGX divided by PDF\n    float D = sampleGgxImportance(wi, alpha, wo);\n    m = normalize(wi+wo);\n\n    // Geometry\n    float tan2_theta_i = (1.-wi.z*wi.z)/(wi.z*wi.z);\n    float tan2_theta_o = (1.-wo.z*wo.z)/(wo.z*wo.z);\n    float lambda_i = .5*(sqrt(1.+alpha*alpha*tan2_theta_i)-1.);\n    float lambda_o = .5*(sqrt(1.+alpha*alpha*tan2_theta_o)-1.);\n    float G = 1./(1.+lambda_i+lambda_o);\n\n    // Fresnel\n    float F = f0 + (1.-f0)*pow(1.-dot(wi, m), 5.);\n\n    // Put all together\n    float Fr = D*G*F / (4.*wi.z*wo.z+1e-4);\n    float Fr_cos = Fr * wo.z;  // wo is the direction of light in path tracing\n    m_col *= Fr_cos * albedo;\n    return wo.x * u + wo.y * v + wo.z * n;\n}\n\n\n\n// materials\nconst int mat_none = -1;\nconst int mat_background = 0;\nconst int mat_ground = 1;\nconst int mat_refractive = 2;\n\n\n// volume rendering template\nvoid calcAbsorb(vec3 p, out vec3 emi, out vec3 tabs, out vec3 sabs, out float k, out float g) {\n    p -= vec3(0, 0, 1);  // center of sphere\n    vec4 emik = texture(iChannel1, xyz2raydir(.5+.5*p));\n    emik.xyz = max(emik.xyz, 0.);\n    emik.w = clamp(emik.w, 0., 200.);\n    emi = 100.*tanh(.01*emik.xyz) / pow(1.6*emik.w+1.,1.);\n    k = emik.w;\n    tabs = vec3(0.0*k);\n    sabs = clamp(.001*emik.xyz, 0., 1.);\n    g = -0.5;\n}\nvoid calcScatter(vec3 ro, inout vec3 rd,\n        inout float mt, inout vec3 m_col, out vec3 m_emi, out int material, inout vec3 min_n) {\n    float p = 1., hit_p = randf();\n    float t = 1e-4, dt = max(2.0/float(CSIZE),0.02);\n    m_emi = vec3(0);\n    for (int i=0, i1=int(2.0/dt); i<=i1 && t<mt-dt; i++, t+=dt) {\n        vec3 emi, tabs, sabs; float k, g;\n        calcAbsorb(ro + rd * (t+.5*dt), emi, tabs, sabs, k, g);\n        float dp = exp(-k*dt);\n        if (p * dp < hit_p) {\n            dt *= log(p/hit_p)/k;\n            mt = t + dt;\n            rd = sampleHenyeyGreenstein(rd, g);\n            m_col *= sabs * exp(-tabs*dt);\n            material = mat_none;\n            min_n = vec3(0);\n            return;\n        }\n        p *= dp;\n        m_col *= exp(-tabs*dt);\n        m_emi += m_col * emi * dt;\n    }\n    material = mat_refractive;\n}\n\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1), t_col = vec3(0), col;\n    bool is_inside = false;\n\n    for (int iter = int(ZERO); iter < 128; iter++) {\n        ro += 1e-4f*rd;\n\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        vec3 min_ro = ro, min_rd = rd;\n        vec3 min_emi = vec3(0);\n        int material = mat_background;\n\n        // plane\n        t = -ro.z / rd.z;\n        if (t > 0.) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            min_ro = ro + rd * t, min_rd = rd;\n            col = 0.5*vec3(0.9, 0.95, 0.98);\n            //if (min_ro.x>0. && abs(min_ro.y)<0.1) col=vec3(1,0.3,0.3);\n            //if (min_ro.y>0. && abs(min_ro.x)<0.1) col=vec3(0.3,0.5,0.3);\n            col /= (0.1*dot(min_ro.xy,min_ro.xy)+1.0);\n            material = mat_ground;\n        }\n\n        // object\n        t = min_t;\n        if (intersectSphere(vec3(0,0,1), 1., ro, rd, t, n)) {\n            min_t = t, min_n = n;\n            if (is_inside) {\n                col = vec3(1);\n                min_rd = rd;\n                calcScatter(ro, min_rd, min_t, col, min_emi, material, min_n);\n                min_ro = ro + rd * min_t;\n            }\n            else {\n                min_ro = ro + rd * t, min_rd = rd;\n                col = vec3(1);\n                material = mat_refractive;\n            }\n        }\n\n        // update ray\n        if (material == mat_background) {\n            if (iter==0) return vec3(0);\n            col = 1.0*texture(iChannel2, rd.yzx).xyz;\n            //col = vec3(0.6);\n            col *= max(rd.z,0.);\n            return m_col * col + t_col;\n        }\n        ro = min_ro, rd = min_rd;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;  // ray hits into the surface\n        if (material == mat_ground) {  // diffuse\n            rd = sampleCookTorrance(-rd, min_n, .05, .8, .1, 2.*col, col);\n        }\n        else if (material == mat_refractive) {  // ball\n            vec2 eta = is_inside ? vec2(1.5, 1.0) : vec2(1.0, 1.5);\n            rd = sampleFresnelDielectric(rd, min_n, eta.x, eta.y);\n        }\n        m_col = m_col * col;\n        t_col += min_emi;\n        if (dot(rd, min_n) < 0.) {\n            is_inside = !is_inside;\n        }\n    }\n    return m_col + t_col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // random number seed\n    vec3 p3 = fract(fragCoord.xyx*1.1031);\n    p3 += dot(p3, p3.zxy + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    rand_seed = uint(1048576.*h)+uint(iFrame);\n\n    // camera\n    float rx = iMouse.z==0.?0.1:1.8*(iMouse.y/iResolution.y)-0.1;\n    float rz = iMouse.z==0.?0.3:-iMouse.x/iResolution.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(randf(),randf())-0.5)/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 3.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    // calculate pixel color\n#if 0\n    // debug\n    vec3 col=vec3(0.);\n    for(float i=0.;i<2.;i++)\n        col += texture(iChannel1, rd+sin(i)).xyz;\n#else\n    vec3 col = mainRender(ro, rd);\n#endif\n    col = dot(col,vec3(1))>0. ? col : vec3(0);  // kill NAN\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0. || iFrame<4*CUBEBUF) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// Volume\n\n// hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((vec3(p3.x, p3.x, p3.y) + vec3(p3.y, p3.z, p3.z))*p3.zyx);\n}\n\n// 2D/3D noise functions\nfloat GradientNoise2D(vec2 xy) {\n    float i0=floor(xy.x), i1=i0+1.;\n    float j0=floor(xy.y), j1=j0+1.;\n    float v00=dot(2.*hash22(vec2(i0, j0))-1.,xy - vec2(i0, j0));\n    float v01=dot(2.*hash22(vec2(i0, j1))-1.,xy - vec2(i0, j1));\n    float v10=dot(2.*hash22(vec2(i1, j0))-1.,xy - vec2(i1, j0));\n    float v11=dot(2.*hash22(vec2(i1, j1))-1.,xy - vec2(i1, j1));\n    float xf=xy.x-i0; xf=xf*xf*xf*(10.+xf*(-15.+xf*6.));\n    float yf=xy.y-j0; yf=yf*yf*yf*(10.+yf*(-15.+yf*6.));\n    return v00 + (v10-v00)*xf + (v01-v00)*yf + (v00+v11-v01-v10)*xf*yf;\n}\nfloat SimplexNoise3D(vec3 xyz) {\n    const float K1 = .3333333333;\n    const float K2 = .1666666667;\n    vec3 p = xyz + dot(xyz,vec3(1))*K1;\n    vec3 i = floor(p);\n    vec3 f0 = xyz - (i - dot(i,vec3(1))*K2);\n    vec3 e = vec3(f0.y>f0.x?0.:1., f0.z>=f0.y?0.:1., f0.x>f0.z?0.:1.);\n    vec3 i1 = e * (vec3(1)-e.zxy);\n    vec3 i2 = vec3(1) - e.zxy*(1.-e);\n    vec3 f1 = f0-i1+K2;\n    vec3 f2 = f0-i2+2.*K2;\n    vec3 f3 = f0-1.+3.*K2;\n    vec3 n0 = 2.*hash33(i)-1.;\n    vec3 n1 = 2.*hash33(i+i1)-1.;\n    vec3 n2 = 2.*hash33(i+i2)-1.;\n    vec3 n3 = 2.*hash33(i+1.)-1.;\n    vec4 v = vec4(dot(f0,n0),dot(f1,n1),dot(f2,n2),dot(f3,n3));\n    vec4 w = max(-vec4(dot(f0,f0),dot(f1,f1),dot(f2,f2),dot(f3,f3))+.5, vec4(0));\n    return dot((w*w*w*w)*v, vec4(32.));\n}\n\n// no NAN for tanh(big_number)\n#define stanh(x) tanh(clamp(x,-10.,10.))\n\n// main\nvec4 calcEmissionScattering(vec3 p) {\n    vec3 emi = vec3(0);\n    float k = 0.0;\n\n    // star dust\n    // emi: on a scale of 10\n    // k: zero\n    vec3 dust = vec3(0);\n    dust += 0.6*vec3(0.5,0.,0.8) * (SimplexNoise3D(1.*p)+0.5) / (6.*dot(p,p)+1.);  // purple cloud\n    //emi += 1.*vec3(0.2,1.,0.2) * pow(SimplexNoise3D(2.*p)+0.3,2.) / (6.*dot(p,p)+1.);  // green cloud\n    dust += 10.*vec3(0.,0.5,0.8) * pow(SimplexNoise3D(4.*p)+0.3,4.) / (6.*dot(p,p)+1.);  // blue cloud\n    dust += 40.*vec3(1.,0.7,0.3) * pow(SimplexNoise3D(-5.*p)*1.2+0.4,15.) / (pow(4.*dot(p,p),4.)+1.);  // big golden stars\n    dust += 70.*vec3(1.,0.5,1.) * pow(SimplexNoise3D(10.*p)*1.2+0.4,15.) / (pow(3.*dot(p,p),3.)+1.);  // small pink stars\n    dust += 90.*vec3(1.,1.,1.) * pow(SimplexNoise3D(20.*p)*1.2+0.4,18.) / (pow(1.5*dot(p,p),2.)+1.);  // white small/bright stars\n    dust += 60.*vec3(0.8,1.0,0.) * pow(SimplexNoise3D(20.*p)*1.2+0.4,12.) / (pow(3.*dot(p,p),2.)+1.);  // green/yellow star cloud\n    dust /= pow(1.*length(p/vec3(0.8,1.2,0.8)),4.)+1.;\n    emi += max(dust, 0.0);\n\n#if 1\n    // eye\n    // emi: on a scale of 1000\n    // k: on a scale of 100\n    // multiply emi by .001 for scattering absorption\n    vec4 eye;\n    vec3 q = p-vec3(0,0,0.1*cos(2.*p.y)-0.1); // distort the eye\n    eye.w = length( q/vec3(1.,2.,0.2+1.0*exp(-1.5*p.y*p.y)-0.2*sin(p.y)) )-0.2;  // eyeball sdf\n    if (eye.w<0.1) {\n        vec2 uv_iris = vec2(length(q.yz), atan(q.z,q.y));\n        eye.xyz = 1.5*mix(vec3(0.),\n            mix(vec3(0.2,1.0,0.5),vec3(0.2,0.8,1.0),0.5+0.7*SimplexNoise3D(4.*q)),\n            clamp(0.6+0.8*GradientNoise2D(6.*uv_iris),0.,1.));  // iris color\n        eye.xyz = 1.2*pow(eye.xyz, vec3(2.0));\n        eye.xyz *= 0.4+0.6*stanh(400.*(length(q-vec3(0.2,0,0.02))-0.08));  // pupil\n        float d_iris = length(q-vec3(0.2,0,0))-0.2;  // iris sdf\n        eye.xyz *= pow(0.5-0.5*tanh(40.*d_iris), 6.);  // fade at boundary of iris\n        eye.xyz = mix(eye.xyz, vec3(1.), 0.5+0.5*stanh(400.*d_iris));  // eyewhite\n    }\n    eye.xyz *= 1000., eye.w = 0.5-0.5*stanh(100.*eye.w);\n    k = max(k, 100.0*eye.w);\n    emi += eye.xyz*eye.w;\n#endif\n    \n    return vec4(emi, k);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame >= 4*CUBEBUF) discard;\n    fragColor = max(texture(iChannel0, rayDir), 0.);\n    int i = raydir2i(rayDir);\n    if (i >= CSIZE*CSIZE*CSIZE) return;\n    if (i%CUBEBUF != iFrame%CUBEBUF) return;\n    vec3 xyz = i2xyz(i);\n    fragColor = calcEmissionScattering(-1.0+2.0*xyz);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define ZERO min(iTime, 0.)\n\n\n/* Store the volume in Cube A */\n\n// xyz between 0 and 1\n\nconst int CUBEBUF = 4; // progressively compute the volume in this number of passes\nconst int CSIZE = 184; // dimension of the volume, less than 1024x1024x6\n\n// cube to xyz\nint raydir2i(vec3 rd) {\n    // get plane and uv\n    int plane = -1;\n    vec2 uv;\n    vec3 rb = abs(rd);\n    if (rb.x>=rb.y && rb.x>=rb.z)\n        plane=rd.x<0.?1:0, uv=rd.yz/rd.x;\n    else if (rb.y>=rb.x && rb.y>=rb.z)\n        plane=rd.y<0.?3:2, uv=rd.xz/rd.y;\n    else\n        plane=rd.z<0.?5:4, uv=rd.xy/rd.z;\n    uv = 0.5+0.5*uv;\n    // get index\n    ivec2 iuv = ivec2(1024.*uv);\n    int i = iuv.x + 1024*(iuv.y + 1024*plane);\n    return i;\n}\nvec3 i2xyz(int i) {\n    // to xyz\n    int x = i%CSIZE; i/=CSIZE;\n    int y = i%CSIZE; i/=CSIZE;\n    int z = i;\n    return (vec3(x,y,z)+0.5) / float(CSIZE);\n}\n\n// xyz to cube\nvec3 xyz2raydir(vec3 xyz) {\n    // get index\n    ivec3 ixyz = ivec3(xyz*float(CSIZE));\n    ixyz = clamp(ixyz, ivec3(0), ivec3(CSIZE-1));\n    int i = ixyz.x + CSIZE*(ixyz.y + CSIZE*ixyz.z);\n    // get plane and uv\n    int u = i%1024; i/=1024;\n    int v = i%1024; i/=1024;\n    int plane = i;\n    vec2 uv = (vec2(u,v)+0.5)/1024.;\n    uv = -1.0+2.0*uv;\n    // to raydir\n    vec3 rd;\n    if (plane==0||plane==1)\n        rd = (plane==1?-1.0:1.0)*vec3(1,uv);\n    if (plane==2||plane==3)\n        rd = (plane==3?-1.0:1.0)*vec3(1,uv).yxz;\n    if (plane==4||plane==5)\n        rd = (plane==5?-1.0:1.0)*vec3(uv,1);\n    return normalize(rd);\n}\n\n","name":"Common","description":"","type":"common"}]}