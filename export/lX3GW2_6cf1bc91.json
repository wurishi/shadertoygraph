{"ver":"0.1","info":{"id":"lX3GW2","date":"1717151435","viewed":71,"name":"WOAH! A simple design","username":"Joshy20XX","description":"A simple nice design I came up with. My first public shader. I'm a newbie to this so it's not the prettiest out there. But it's a start.\n\nReferences are in the code comments. :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["beginner","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur, vec2 offset) {\n    p -= offset;\n    float dist = length(uv-p);\n    float color = smoothstep(r, r-blur, dist);\n    \n    return color;\n}\n\nfloat moddedCircle(vec2 uv, vec2 p, float r, float blur, vec2 offset) {\n    p -= offset;\n    float dist = length(uv-p);\n    float color = smoothstep(r, r-blur, dist);\n    \n    return color;\n}\n\nmat2 scale(vec2 scale) {\n    return mat2(scale.x, 0.0, 0.0, scale.y);\n             \n}\n\n// Box and cross functions from the The Book of Shaders: https://thebookofshaders.com/08/\nfloat box(in vec2 _uv, in vec2 _size, bool animate){\n    _size = vec2(0.5) - _size * 0.5;\n    vec2 uv = smoothstep(_size, _size + vec2(0.016), _uv);\n    \n    if (animate == true)\n        uv *= smoothstep(_size, cos(iTime + 1.6)*sin(iTime + 3.)/25. + _size + vec2(0.016), vec2(1.0)- _uv);\n    else\n        uv *= smoothstep(_size, /*cos(iTime + 5.6)*sin(iTime + 1.)/25. +*/ _size + vec2(0.016), vec2(1.0)- _uv);\n    return uv.x * uv.y;\n}\n\nfloat scross(in vec2 _uv, float _size, vec2 offset, bool animate) {\n    _uv -= offset;\n    return box(_uv, vec2(_size,_size/2.), animate) + box(_uv, vec2(_size/2.,_size), animate);\n}\n\nfloat scross2(in vec2 _uv, float _size, vec2 offset, bool animate) {\n    _uv -= offset;\n    return box(_uv, vec2(_size,_size/2.), animate) + box(_uv, vec2(_size/3.4,_size), animate);\n}\n\nfloat controllerButtons(vec2 uv, vec2 p, float r, float blur, vec2 offset) {\n    p = abs(p);\n    return moddedCircle(uv, p, r, blur, offset);\n}\n\nfloat controller(vec2 uv, vec2 p, float r, float blur) {\n\n    float controllerLeft = Circle(uv, p, r, blur, vec2(-0.2, 0.02));\n    float controllerRight = Circle(uv, p, r, blur, vec2(-0.05, 0.02));\n    \n    float dpad = scross(uv, 0.1, vec2(-.055, -0.22), false);\n    float button_one = controllerButtons(uv, p, 0.025, 0.02, vec2(-.205, -0.012));\n    float button_two = controllerButtons(uv, p, 0.025, 0.02, vec2(-.17, 0.025));\n    float button_three = controllerButtons(uv, p, 0.025, 0.02, vec2(-.205, 0.06));\n    float button_four = controllerButtons(uv, p, 0.025, 0.02, vec2(-.24, 0.025));\n    \n    float buttons = button_one + button_two + button_three + button_four;\n    float controllerBase = (controllerLeft + controllerRight) - dpad - buttons;\n    return controllerBase;\n}\n\n// 2D rotation matrix code also from the Book of Shaders: https://thebookofshaders.com/08/\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fragCoord/iResolution.xy; //Add cross to its own space\n\n    uv.x -= 0.5; //Normalized the screen to (-0.5, 0.5) <||>\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 translate = vec2(0.34, -0.28); //Moving the cross\n    uv2 += translate;\n    \n    //Rotate the cross\n    uv2 = rotate2d(sin(5.35)) * uv2;\n    \n    uv2 += translate;\n    \n    //Circle's pixels (uv), (x,y), Circle's radius (r), blur\n    float color = Circle(uv, vec2(0.25, 0.7), 0.15, 0.06, vec2(0));\n    color += Circle(uv, vec2(0.0, 0.4), cos(iTime)/10. + sin(0.15), 0.02, vec2(0));\n    \n    //Cross shape's pixels and coordinates\n    color += scross2(uv2, 0.18, vec2(0.0, -.01), true); //Cross shape pixels\n    color += controller(uv * scale(vec2(sin(iTime/.8)/1.2) + 2.), vec2(0.4, 0.3), 0.1, 0.02);\n    \n   \n    // Output to screen\n    if (uv2.y < 0.0) {\n        fragColor = vec4(3.,0.,0.,1.5);\n    } else if (uv2.y < 0.2) {\n        fragColor = vec4(4.,0.,1.,0.2);\n    } else if (uv2.y < 0.2) {\n        fragColor = vec4(4.,0.,1.,0.2);\n    } else if (uv2.y > 1.0) {\n        fragColor = vec4(2.,1.,6.,0.1);\n    } else if (uv2.y > 0.85) {\n        fragColor = vec4(6.,.2,6.,0.1);\n    } else {   \n        fragColor = vec4(vec3(color), 15.0);\n    }\n} ","name":"Image","description":"","type":"image"}]}