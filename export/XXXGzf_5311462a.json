{"ver":"0.1","info":{"id":"XXXGzf","date":"1710273728","viewed":81,"name":"ColorWave v1","username":"jcarrano","description":"Try to generate color waves from the image. The problem is that we would need 6 texture components for the wave sim and we only have 4.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","simple","mouse","wave","refraction","equation","differential"],"hasliked":0,"parentid":"43l3zj","parentname":"Autowave with Refraction"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Taking the 2d wave as the surface of a liquid, simulate refraction.\n\n#define REFRACTION_INDEX 1.5\n#define POND_DEPTH 300.0\n#define WAVE_HEIGHT 100.0\n#define VH 100.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //versors in uv space\n    vec2 nu = vec2(1.0/iResolution.x, 0.0);\n    vec2 nv = vec2(0.0, 1.0/iResolution.y);\n    \n    float h = texture(iChannel1, uv).x;\n    \n    vec2 surface_gradient = vec2(\n        dFdx(h),dFdy(h)\n    // \t    texture(iChannel1, uv + nu).x - texture(iChannel1, uv - nu).x, // dh/dx\n    //        texture(iChannel1, uv + nv).x - texture(iChannel1, uv - nv).x // dh/dy\n    );\n    \n    // hand made refraction\n    /*\n    vec2 angle_of_incidence = atan(surface_gradient);\n    vec2 angle_of_refraction = asin(sin(angle_of_incidence)*(1.0/REFRACTION_INDEX));\n    vec2 exit_angle = angle_of_refraction - angle_of_incidence;\n\t\n\tvec2 exit_displacement = tan(exit_angle)*((POND_DEPTH + h*WAVE_HEIGHT)/iResolution.xy);    \n\t*/\n    \n    // GLSL refraction\n    // first we need to compute the surface normal\n    vec3 normal = normalize(vec3(surface_gradient, 1.0));\n    vec3 incident = normalize(vec3(fragCoord-iResolution.xy/2.0, -iResolution.x*VH));\n    vec2 exit_vector = refract(incident, normal, 1.0/REFRACTION_INDEX).xy;\n    \n    vec2 exit_displacement = exit_vector*((POND_DEPTH + h*WAVE_HEIGHT)/iResolution.xy);\n    \n    \n    //fragColor.rgb = texture(iChannel0, uv + exit_displacement).rgb;\n    //fragColor.rgb = vec3(h);\n    fragColor = texture(iChannel1, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Image improvement and masking\n// Remove the green screen and transform it to an alpha channel (premultiplied).\n\nvec4 improve(vec4 col)\n{\n    return (col - 0.3)*1.4;\n}\n\nvec4 removeGreenScreen(vec4 col)\n{\n    float greenness = col.g - max(col.r, col.b);\n    float mask = (1.0 - smoothstep(0.0, 0.1, greenness));\n    \n    return vec4(col.rgb * mask, mask*col.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = removeGreenScreen(improve(color));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Simulate a 2d wave\n\n#define C 10.0\n#define DT 0.1\n#define DAMPING 0.95\n#define MOUSE_RADIUS 10.0\n#define PRESS_FORCE 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float hit_by_mouse = clamp(\n        sqrt(1.0/(distance(iMouse.xy, fragCoord) + 1.0)-1.0/MOUSE_RADIUS),\n        0.0, 1.0)*PRESS_FORCE;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 exc = texture(iChannel0, uv);\n    vec3 edgX = dFdx(exc.rgb);\n    vec3 edgY = dFdy(exc.rgb);\n    float edge3 = length(sqrt(edgX*edgX + edgY*edgY))*(iResolution.x*0.005);\n    vec3 edge = exc.rgb * edge3 * exc.a;\n    \n    //versors in uv space\n    vec2 nu = vec2(1.0/iResolution.x, 0.0);\n    vec2 nv = vec2(0.0, 1.0/iResolution.y);\n    \n    // in this texture, x is the quantity, y the firtst derivarive, z the previous edge\n   \tvec3 top = texture(iChannel1, uv-nv).xyz;\n    vec3 topleft = texture(iChannel1, uv-nv-nu).xyz;\n    \n    vec3 left = texture(iChannel1, uv-nu).xyz;\n    vec3 leftbottom = texture(iChannel1, uv-nu+nv).xyz;\n    \n    vec3 bottom = texture(iChannel1, uv+nv).xyz;\n    vec3 bottomright = texture(iChannel1, uv+nv+nu).xyz;\n    \n    vec3 right = texture(iChannel1, uv+nu).xyz;\n    vec3 righttop = texture(iChannel1, uv+nu-nv).xyz;\n    \n    vec4 center = texture(iChannel1, uv);\n    \n    vec3 du3dt = vec3(center.w) + \n        \t(\n                (\n                    (topleft + leftbottom + bottomright + righttop)*0.5\n                    + top + left + right + bottom\n                )*0.5 \n             - 3.0*center.xyz)*C*DT;\n    \n    fragColor.xyz = center.xyz*DAMPING + du3dt*DT + hit_by_mouse + edge*0.7;\n    \n    fragColor.w = 0.3333*(du3dt.x + du3dt.y + du3dt.z);\n}","name":"Buffer C","description":"","type":"buffer"}]}