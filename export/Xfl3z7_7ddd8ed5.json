{"ver":"0.1","info":{"id":"Xfl3z7","date":"1702909301","viewed":25,"name":"Smooth Parity","username":"vichoeq","description":"Divides the screen into a continous, checkered grid.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359 \n\nvec2 rotate(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nfloat smooth_parity(vec2 uv, float mult, float sharpness)\n{\n    sharpness = 1.0 - sharpness;\n    sharpness *= 2.0;\n\n    // Convert to parity space \n    uv = rotate(uv, PI/4.0);    \n        \n    // Scale the plane            \n    uv *= mult;  \n    \n    // Center cells to the center of the screen\n    uv -= PI/2.0;\n    \n    float cell = sin(uv.y) - sin(uv.x);\n    \n    // 1 = Even cell, 0 = Odd cell, with values in between.\n    return smoothstep(-sharpness, sharpness, cell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        \n    // How compressed the space is. The higher this number, the smaller the cells in \n    // comparison with the screen. Use PI*sqrt(2) to make it match with the integers.\n    float mult = PI * sqrt(2.0);\n    \n    // How sharp the transition is from one cell to another (between 0 and 1)\n    float sharpness = sin(iTime)/2.0 + 0.5;\n    \n    \n    //float parity = smooth_parity(uv, mult, sharpness);\n    float parity = smooth_parity(uv, sqrt(iTime) * mult, sharpness);\n    \n    \n    // Draw a small circle at the center of the screen\n    float d = length(uv)-0.01;        \n    float center = 1.0 - step(0.0, d);\n    \n        \n    fragColor = vec4(center + parity, parity, parity, 1.0);\n}","name":"Image","description":"","type":"image"}]}