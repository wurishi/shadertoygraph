{"ver":"0.1","info":{"id":"ftySD1","date":"1640575564","viewed":505,"name":"DODECAHEDRAL-MICROORGANISM","username":"ENDESGA","description":"use the mouse to observe\n:::.","likes":25,"published":3,"flags":32,"usePreview":0,"tags":["fractal","volume","mandelbulb","volumetric","pathtracing","tracing","rayleigh","path","spectral"],"hasliked":0,"parentid":"NlGXzz","parentname":"Path traced Rayleigh scattering"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x + ((x*(a*x+b))/(x*(c*x+d)+e))) * .5;\n}\n\nconst mat3 xyz2rgb = mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n);\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    //vec3 x = max(texelFetch(iChannel0, ivec2(u), 0).xyz, 0.0);\n    \n    vec3 x = (((ACESFilm(xyz2rgb * (texture( iChannel0, ((I + vec2(-1.,0.)))/iResolution.xy ).rgb)) +\n                ACESFilm(xyz2rgb * (texture( iChannel0, ((I + vec2(1.,0.)))/iResolution.xy ).rgb)) +\n                ACESFilm(xyz2rgb * (texture( iChannel0, ((I + vec2(0.,-1.)))/iResolution.xy ).rgb)) +\n                ACESFilm(xyz2rgb * (texture( iChannel0, ((I + vec2(0.,1.)))/iResolution.xy ).rgb))) * .25) +\n                ACESFilm(xyz2rgb * (texture( iChannel0, (I)/iResolution.xy ).rgb))) * .5;\n    \n    O = vec4(x*(7./9.),1.);//vec4(ACESFilm(pow(xyz2rgb * sqrt(x*(7./9.)) * (7./9.),vec3(2.))*(1.+(7./9.))), 1.);\n    O = ((O*O)+O)*.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.141592653589793;\n\n// Spectrum with its integral\nconst vec3 cie[48] = vec3[48](\n    vec3( 0.000000f, 0.000000f, 0.000001f ),    // 360 nm\n    vec3( 0.000006f, 0.000001f, 0.000026f ),    // 370 nm\n    vec3( 0.000160f, 0.000017f, 0.000705f ),    // 380 nm\n    vec3( 0.002362f, 0.000253f, 0.010482f ),    // 390 nm\n    vec3( 0.019110f, 0.002004f, 0.086011f ),    // 400 nm\n    vec3( 0.084736f, 0.008756f, 0.389366f ),    // 410 nm\n    vec3( 0.204492f, 0.021391f, 0.972542f ),    // 420 nm\n    vec3( 0.314679f, 0.038676f, 1.553480f ),    // 430 nm\n    vec3( 0.383734f, 0.062077f, 1.967280f ),    // 440 nm\n    vec3( 0.370702f, 0.089456f, 1.994800f ),    // 450 nm\n    vec3( 0.302273f, 0.128201f, 1.745370f ),    // 460 nm\n    vec3( 0.195618f, 0.185190f, 1.317560f ),    // 470 nm\n    vec3( 0.080507f, 0.253589f, 0.772125f ),    // 480 nm\n    vec3( 0.016172f, 0.339133f, 0.415254f ),    // 490 nm\n    vec3( 0.003816f, 0.460777f, 0.218502f ),    // 500 nm\n    vec3( 0.037465f, 0.606741f, 0.112044f ),    // 510 nm\n    vec3( 0.117749f, 0.761757f, 0.060709f ),    // 520 nm\n    vec3( 0.236491f, 0.875211f, 0.030451f ),    // 530 nm\n    vec3( 0.376772f, 0.961988f, 0.013676f ),    // 540 nm\n    vec3( 0.529826f, 0.991761f, 0.003988f ),    // 550 nm\n    vec3( 0.705224f, 0.997340f, 0.000000f ),    // 560 nm\n    vec3( 0.878655f, 0.955552f, 0.000000f ),    // 570 nm\n    vec3( 1.014160f, 0.868934f, 0.000000f ),    // 580 nm\n    vec3( 1.118520f, 0.777405f, 0.000000f ),    // 590 nm\n    vec3( 1.123990f, 0.658341f, 0.000000f ),    // 600 nm\n    vec3( 1.030480f, 0.527963f, 0.000000f ),    // 610 nm\n    vec3( 0.856297f, 0.398057f, 0.000000f ),    // 620 nm\n    vec3( 0.647467f, 0.283493f, 0.000000f ),    // 630 nm\n    vec3( 0.431567f, 0.179828f, 0.000000f ),    // 640 nm\n    vec3( 0.268329f, 0.107633f, 0.000000f ),    // 650 nm\n    vec3( 0.152568f, 0.060281f, 0.000000f ),    // 660 nm\n    vec3( 0.081261f, 0.031800f, 0.000000f ),    // 670 nm\n    vec3( 0.040851f, 0.015905f, 0.000000f ),    // 680 nm\n    vec3( 0.019941f, 0.007749f, 0.000000f ),    // 690 nm\n    vec3( 0.009577f, 0.003718f, 0.000000f ),    // 700 nm\n    vec3( 0.004553f, 0.001768f, 0.000000f ),    // 710 nm\n    vec3( 0.002175f, 0.000846f, 0.000000f ),    // 720 nm\n    vec3( 0.001045f, 0.000407f, 0.000000f ),    // 730 nm\n    vec3( 0.000508f, 0.000199f, 0.000000f ),    // 740 nm\n    vec3( 0.000251f, 0.000098f, 0.000000f ),    // 750 nm\n    vec3( 0.000126f, 0.000050f, 0.000000f ),    // 760 nm\n    vec3( 0.000065f, 0.000025f, 0.000000f ),    // 770 nm\n    vec3( 0.000033f, 0.000013f, 0.000000f ),    // 780 nm\n    vec3( 0.000018f, 0.000007f, 0.000000f ),    // 790 nm\n    vec3( 0.000009f, 0.000004f, 0.000000f ),    // 800 nm\n    vec3( 0.000005f, 0.000002f, 0.000000f ),    // 810 nm\n    vec3( 0.000003f, 0.000001f, 0.000000f ),    // 820 nm\n    vec3( 0.000002f, 0.000001f, 0.000000f )     // 830 nm\n);\n\nconst vec3 invSpecIntegral = 1.0 / vec3(116.64352, 116.64398, 116.643715);\n\n\nfloat uintRangeToFloat(uint i)\n{\n    return float(i) / float(0xFFFFFFFFu);\n}\n\n// low-ish discrepency sequences\n\nconst uint LAMBDA = 0u;\nconst uint DOF_U = 1u;\nconst uint DOF_V = 2u;\nconst uint AA_U = 3u;\nconst uint AA_V = 5u;\nconst uint BASE = 6u;\n\nconst uint BRDF_U = 0u;\nconst uint BRDF_V = 1u;\nconst uint BOUNCE = 2u;\n\nuint bounce;\nuint frame;\nuint pixel;\n\nfloat prng(uint dimension)\n{\n    // 64 dimensional noise\n    const int pLength = 64;\n    \n    // additive recurrence, using square roots of primes (some have been modified to not be too small)\n    const uint sqPrimes[pLength] = uint[pLength](\n        0x6a09e667u, 0xbb67ae84u, 0x3c6ef372u, 0xa54ff539u, 0x510e527fu, 0x9b05688au, 0x1f83d9abu, 0x5be0cd18u,\n        0xcbbb9d5cu, 0x629a2929u, 0x91590159u, 0x452fecd8u, 0x67332667u, 0x8eb44a86u, 0xdb0c2e0bu, 0x47b5481du,\n        0xae5f9155u, 0xcf6c85d1u, 0x2f73477du, 0x6d1826cau, 0x8b43d455u, 0xe360b595u, 0x1c456002u, 0x6f196330u,\n        0xd94ebeafu, 0x9cc4a611u, 0x261dc1f2u, 0x5815a7bdu, 0x70b7ed67u, 0xa1513c68u, 0x44f93634u, 0x720dcdfcu,\n        0xb467369cu, 0xca320b74u, 0x34e0d42du, 0x49c7d9bdu, 0x87abb9f0u, 0xc463a2fau, 0xec3fc3f1u, 0x27277f6cu,\n        0x610bebf1u, 0x7420b49du, 0xd1fd8a31u, 0xe4773592u, 0x592197f5u, 0x3b530c95u, 0x669d6341u, 0x5ee52e4du,\n        0x31076689u, 0x61fba37bu, 0x43ab9fb5u, 0x75a9f91cu, 0x86305018u, 0xd7cd8172u, 0x67fe00ffu, 0x379f513fu,\n        0x66b651a7u, 0x764ab841u, 0xa4b06be0u, 0xc3578c13u, 0xd2962a52u, 0x3e039f40u, 0x857b7bedu, 0xa29bf2ddu\n    );\n    \n    return uintRangeToFloat((frame + 0x171fda75u) * sqPrimes[(dimension + pixel) % uint(pLength)]); \n}\n\n\nuint hash(uint i)\n{\n\ti ^= i >> 12u;\n\ti *= 0xB5297A4Du;\n\ti ^= i >> 12u;\n\ti += 0x68E31DA4u;\n\ti ^= i >> 12u;\n\ti *= 0x1B56C4E9u;\n\treturn i;\n}\n\n\nuint seed;\n\nfloat random()\n{\n    return uintRangeToFloat(hash(seed++));\n}\n\n// implicit volume\n\n//\nconst float PHI = (1.+sqrt(5.))/2.;\nconst float A = PHI / sqrt( 1. + PHI*PHI );\nconst float B = 1. / sqrt( 1. + PHI*PHI );\nconst float J = 0.309016994375;\nconst float K = J+.5;\n\nconst mat3 R0 = mat3(0.5,-K,J        ,K,J,-0.5                       ,J,0.5,K                          );\nconst mat3 R1 = mat3(K,J,-0.5        ,J,0.5,K                        ,0.5,-K,J                         );\nconst mat3 R2 = mat3(-J,-0.5,K       ,0.5,-K,-J                      ,K,J,0.5                          );      \nconst mat3 R4 = mat3(0.587785252292,-K,0.,-0.425325404176,-J,0.850650808352,0.688190960236,0.5,0.525731112119);\nconst vec3 O4 = vec3(A/3./tan(PI/5.),A/3.,0.63147573033330584);\n\nfloat sphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\nvec3 op_icoso( vec3 p )\n{    \n    p = R0 * abs( p );\n    p = R1 * abs( p );\n    p = R2 * abs( p );\n    return abs( p );  \n} \n\nvec3 op_dodeca( vec3 p, float r )\n{         \n    return R4 * op_icoso( p ) - O4 * r;\n}  \n\nfloat dodeca( vec3 p, float r, float w )\n{         \n    p = R4 * op_icoso( p ) - O4 * r;\n    return sphere( vec3( p.x, max(p.y, 0.), p.z ), w );\n}\n//\n\nmat3 rotXY( vec2 angle ) \n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\t\n\treturn mat3(c.y      ,  0.0, -s.y,\n\t\t\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\t\t\ts.y * c.x, -s.x,  c.y * c.x\t);\n}\n\nfloat density( vec3 p ) \n{\n    float d = dodeca(p,1.,.2);\n\treturn pow(sqrt(float(d <= 0.) * d * d * d * d * 77.777) * 3.,3.)* 3.; //pow(float(d <= 0.) * sqrt(abs(d * .1)) * 4.,2.) * 2.;\n}\n\n\n// volume tracing using detla tracking\n\nfloat trace(vec3 ro, vec3 rd, float l)\n{\n   \n    float b = -dot(ro, rd);\n    float d = b * b - dot(ro, ro) + 1.3;\n    \n    if(d < 0.0) return -1.0;\n    \n    float s = sqrt(d);\n    \n    float t = max(b - s, 0.0);\n    float mt = b + s;\n    \n    float invMaxDensity = l*l*l*l * 2.0e-13;\n    bool hit = false;\n    for (int i = 0; i < 7777 && !hit && t < mt; i++)\n    {\n        t -= log(random()) * invMaxDensity;\n        hit = fract(random()) < density(ro + rd * t);\n    }\n     \n    return hit && t < mt ? t : -1.0;\n}\n\n// brdf importance sampling\n\nvec3 brdfSample()\n{\n    vec2 r = vec2(2.0 * PI * prng(BASE + bounce * BOUNCE + BRDF_U),\n                  acos(2.0 * prng(BASE + bounce * BOUNCE + BRDF_V) - 1.0));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(s.y * s.x, s.y * c.x, c.y);\n}\n\nfloat brdfPdf(vec3 wi)\n{\n    return 0.25 / PI;\n}\n\n\nfloat brdf(vec3 wi)\n{\n    return (1.0 + wi.z * wi.z) / (PI * 6.0);\n}\n\n// wavelength importance sampling\n\nfloat lambdaSample()\n{\n    float r = prng(LAMBDA), g;\n    int i;\n    for (i = 0; i < 47 && r >= 0.0; i++)\n    {\n        g = dot(cie[i], 1.0 / vec3(116.64347, 116.643974, 116.64372)) / 3.0;\n        r -= g * 10.0;\n    }\n    \n    return float(355 + i * 10) + r / g;\n}\n\n\nfloat lambdaPdf(float l)\n{\n    int index = int(l * 0.1 - 35.5);\n    if(index < 0 || index > 47) \n    {\n        return 0.0;\n    }\n    return dot(cie[index], 1.0 / vec3(116.64352, 116.64398, 116.643715)) / 3.0;\n}\n\n\nvec3 wavelength2xyz(float l)\n{\n\tfloat x = l * 0.1 - 36.0;\n    int index = int(x);\n    if(index < 0 || index >= 47) \n    {\n        return vec3(0.0);\n    }\n    return mix(cie[index], cie[index + 1], fract(x)) * invSpecIntegral;\n}\n\n\n// TODO: make this continuous somehow, to help with discrepency\nvec3 ortho(vec3 v)\n{\n    return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y,v.x,0.) : vec3(0.,-v.z,v.y));\n}\n\n\nfloat blackbody(float l, float t)\n{\n    const float h = 6.62607004e-16;\n    const float k = 1.38064852e-5;\n    const float c = 299792458e9;\n    \n    float a = 2.0 * h * c * c;\n    float b = h * c / (l * k * t);\n    return a / (l*l*l*l*l  * (exp(b) - 1.0));\n}\n\n\nfloat background(vec3 rd, float l)\n{\n    return 0.0;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    pixel = hash(uint(gl_FragCoord.x) + uint(gl_FragCoord.y) * 0x452fecd8u);\n    frame = iFrame == 0  || iMouse.z > 0.0 ? 0u : uint(texelFetch(iChannel0, ivec2(u), 0).a);\n    seed = pixel ^ hash(frame);\n    \n    float a = prng(DOF_U) * PI * 2.0;\n    vec2 aperture = 0.01 * sqrt(prng(DOF_V) * .5) * vec2(cos(a), sin(a));\n    vec2 uv = (floor(u) + vec2(prng(AA_U), prng(AA_V)) - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro = vec3(aperture, -14.0);\n    vec3 rd = normalize(vec3(uv * 3.9 / 6.0 - aperture, 3.9));\n    \n    vec2 rot = PI * (iMouse.yx - iResolution.yx * 0.5) / iResolution.y;\n    vec2 c = cos(rot), s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.x, -s.x, 0, s.x, c.x);\n    mat3 ry = mat3(c.y, 0, -s.y, 0, 1, 0, s.y, 0, c.y);\n    mat3 r = ry * rx;\n    ro = r * ro;\n    rd = r * rd;\n    \n    //ro += vec3(4,0,0);\n    \n    float li = 0.0;\n    float att = 1.0;\n    \n    float l = lambdaSample();\n    \n    for (bounce = 0u; bounce < 777u; bounce++)\n    {\n        float t = trace(ro, rd, l);\n        \n        if (t < 0.0)\n        {\n            li += att * background(rd, l);\n            break;\n        }\n        \n        ro += rd * t;\n        \n\t\tvec3 b = ortho(rd);\n\t\tmat3 brdf2World = mat3(cross(b, rd), b, rd);\n\t\tmat3 world2Brdf = transpose(brdf2World);\n        \n        const vec3 lDir = normalize(vec3(1.0));\n        \n        if (trace(ro, lDir, l) < 0.0)\n        {\n            li += att * brdf(world2Brdf * lDir) * blackbody(l, 6400.0) * 0.0004;\n        }\n        \n        rd = brdfSample();\n        att *= brdf(rd) / brdfPdf(rd);\n        \n        rd = brdf2World * rd;\n    }\n    \n    vec3 col = li / lambdaPdf(l) * wavelength2xyz(l);\n    vec3 pCol = iFrame == 0 ? vec3(0) : texelFetch(iChannel0, ivec2(u), 0).rgb;\n    \n    frame++;\n    \n    o = vec4(mix(pCol, col, 1.0 / (float(frame))), frame);\n}","name":"Buffer A","description":"","type":"buffer"}]}