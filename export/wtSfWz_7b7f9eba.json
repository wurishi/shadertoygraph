{"ver":"0.1","info":{"id":"wtSfWz","date":"1598703760","viewed":574,"name":"Astral Train","username":"sukupaper","description":"A trippy train ~\n\n(sorry about the not readable code)","likes":44,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","rainbow","starfield","train","rayway","catenary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4lBGDK","filepath":"https://soundcloud.com/teetow/gazela-astral-train-edit","previewfilepath":"https://soundcloud.com/teetow/gazela-astral-train-edit","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: sukupaperu\n// Title: Astral Train\n// Music: \"Gazela\" by Teetow - https://soundcloud.com/teetow/gazela\n// Big thanks to Teetow for this special edit : https://soundcloud.com/teetow/gazela-astral-train-edit\n\n#define P 6.283185307\n\n// global variables\nint wagonId = -1, railsId = -1;\nvec3 mapTravel, mapGlobal;\nfloat t, isMagicalWorld;\n\n// other functions\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nfloat cord(in float x, in float h, in float d) { x = abs(x) - d*.5; return (x*x)*h - (d*d*.25)*h; }\nfloat anim1(float x, float sm){ float xmd = mod(x,2.) - .5; return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - 1.); }\n\n// color functions\nvec3 SpectrumPoly(in float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\nvec3 hsv2rgb(in vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0); return c.z*mix(vec3(1.0),rgb,c.y); }\n\n// coordinate transformation functions\nvec2 fold(vec2 p, float a){ vec2 n = vec2(cos(-a),sin(-a)); return p - 2.*min(0.,dot(p,n))*n; }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// 3d sdf functions\nfloat box(in vec3 p, in vec3 s, in float r) { return length(max(abs(p) - s,0.)) - r; }\nfloat rcyl(in vec3 p, in float ra, in float rb, in float h) { vec2 d = vec2(length(p.xz) - 2.*ra+rb, abs(p.y) - h); return min(max(d.x,d.y),0.) + length(max(d,0.)) - rb; }\nfloat cyl(in vec3 p, in float h, in float r) { vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r); return max(length(max(abs(p.y) - h,0.)) - .01, length(p.xz) - r) - .01;}\n\nfloat wagon(in vec3 p, in float hadPanto) {\n    vec3 cabineS = vec3(2.5,.66,.5);\n    vec3 cabineP = p+ vec3(0.,cos(t*40.)*.002,0.);// + vec3(0.,cos(t*40.)*.00,0.)\n    float cabine = max(box(cabineP, cabineS, .07), -cabineP.y - .32);\n    float cabineInner = -max(box(cabineP, cabineS*0.95, .07),-p.y - .3);\n    \n    float window = -min(\n        box(vec3(mod(cabineP.x,.628) - .314,cabineP.yz) - vec3(0.,.275,0.), vec3(.2,.15,1.), .03),\n        box(cabineP.zyx - vec3(0.,.275,0.), vec3(.2,.15,3.), .03)\n    );\n    cabine = max(cabine, window);\n    \n    float cabinePart2 = max(rcyl(cabineP.yxz,.45,.07,2.5), -cabineP.y + .69);\n    cabinePart2 = min(cabinePart2, max(box(cabineP, cabineS, .085), abs(cabineP.y) - .02));\n    \n    vec3 wheelsP = vec3(p.y + .525,abs(p.z) - .35,abs(abs(p.x) - 2.) - .25);\n    float wheels = max(cyl(wheelsP, 0.05, .15),-cyl(wheelsP - vec3(0.,0.1,0.), 0.06, .13));\n    wheels = min(wheels,box(wheelsP - vec3(.1,.1,.0),vec3(.08,.04,.25),.001));\n    wheels = min(wheels,cyl(wheelsP + vec3(0.,.05,0.), -0.002, .175));\n    vec3 attachesP = wheelsP.yzx - vec3(0.,0.,0.1);\n    float attaches = min(cyl(attachesP,.5,.04),cyl(attachesP - vec3(0.,.5,0.),.001,.08));\n    attaches = min(attaches,box(p + vec3(0.,.4,0.), vec3(1.35,0.075,0.45), 0.05));\n    wheels = min(wheels,attaches);\n    \n    vec3 pantoP = p + vec3(0.,-.92,0.);\n    float panto = box(pantoP,vec3(.2,.05,.2),.01);\n    vec3 pantoArmP = vec3(abs(pantoP.x) - .15,abs(pantoP.y - .22) - .1,abs(pantoP.z) - .1);\n    vec3 pantoArm2P = vec3(abs(pantoP.x) - .05,pantoP.y - .4125,pantoP.z);\n    pantoArmP.xy *= rot(-P*.1);\n    panto = min(panto,box(pantoArmP,vec3(.17,.001,.001),.01));\n    panto = min(panto,max(max(max(box(pantoArm2P,vec3(.5,.01,.2),.02),abs(pantoArm2P.x) -.03),-box(pantoArm2P + vec3(0.,0.01,0.),vec3(.5,.01,.2),.02)),-pantoArm2P.y + .008));\n    \n    wheels = min(wheels,mix(panto,10e9,hadPanto));\n    \n    float d = min(min(cabine,wheels),cabinePart2);\n    d = max(d, cabineInner);\n    \n    wagonId = d == window ? 2\n        : d == cabineInner ? 4\n        : d == cabine ? 1\n        : d == wheels ? 2\n        : 3\n    ;\n    return d;\n}\n\nfloat rails(in vec3 p) {\n    vec3 railsP = vec3(0.,p.y,abs(p.z) - .37) + vec3(0.,0.745,0.);\n    float rails = min(box(railsP,vec3(.1,.04,.02),.01),box(vec3(railsP.x,abs(railsP.y) - .04,railsP.z),vec3(.1,.01,.04),.005));\n    float traverses = box(vec3(mod(p.x,.5) - .25,p.y + .846,p.z),vec3(.08,.04,.5),.001);\n    \n    float sol = (p.y + mix(.86,10e2,isMagicalWorld));\n    \n    float piloneEcart = 15.;\n    vec3 pilonesP = vec3(mod(p.x,piloneEcart) - piloneEcart*.5,p.yz) - vec3(0.,0.5,.8);\n    float pilones = box(vec3(abs(pilonesP.x) - .05,pilonesP.y,abs(pilonesP.z) - .05),vec3(.0015,1.5,.0015),.01);\n    vec3 pilonesMeshP = vec3(pilonesP.x,abs(mod(pilonesP.y,.25) - .125) - .06,pilonesP.z);\n    vec3 pilonesMeshP2 = pilonesMeshP.zyx;\n        pilonesMeshP.x = pilonesMeshP.x*sign(pilonesMeshP.z); pilonesMeshP2.x = pilonesMeshP2.x*sign(pilonesMeshP2.z);\n        pilonesMeshP.xy *= rot(P*.15); pilonesMeshP2.xy *= rot(P*.15);\n        pilonesMeshP.z = abs(pilonesMeshP.z) - .05; pilonesMeshP2.z = abs(pilonesMeshP2.z) - .05;\n    pilones = min(pilones,max(\n        min(box(pilonesMeshP,vec3(.15,.002,.002),.001),box(pilonesMeshP2,vec3(.15,.002,.002),.001)),\n        abs(-pilonesP.y) - 1.5)\n    );\n    vec3 catP = pilonesP + vec3(0.,-1.2,.8);\n    vec3 cat2P = catP + vec3(0.,0.3,-.28);\n    catP.yz = fold(catP.yz,-.25); catP.z -= .25;\n    pilones = min(pilones,box(catP,vec3(.001,.001,.6),.005));\n    pilones = min(pilones,cyl(vec3(catP.y,abs(catP.z - .45) - .02,catP.x),-.01,.02));\n    pilones = min(pilones,box(cat2P,vec3(.001,.001,.26),.005));\n    pilones = min(pilones,box(cat2P + vec3(0.,0.025,0.25),vec3(piloneEcart,0.001,0.001),.005));\n    float cableCurve = cord(pilonesP.x, 0.002, piloneEcart);\n    pilones = min(pilones,box(cat2P + vec3(0.,-.25 - cableCurve,0.25),vec3(piloneEcart,0.001,0.001),.001));\n    float vertPos = .125 + cableCurve*.4;\n    pilones = min(pilones,box(vec3(mod(cat2P.x,1.) - .5,cat2P.y - vertPos*.5 - .02,cat2P.z + .25),vec3(.0,vertPos,.0),.005));\n    rails = min(rails,pilones);\n    \n    float d = min(min(rails,traverses),sol);\n    railsId = d == rails ? 1 : d == traverses ? 2 : 3;\n    return d;\n}\n\n// function for hills heightmap\nfloat deniv(in vec2 p) {\n    vec2 pp;\n    p *= rot(P*.125);\n    return cos(p.x*.1)*1.2 + sin(pp.x*.81)*.05 + cos(p.y*0.2);\n}\n\n// main sdf function\nfloat df(in vec3 p) {\n    p.yz *= rot(P*-0.030);\n    p.xz *= rot(P*0.418);\n    p = p.zyx;\n    p.x -= t*10.;\n    mapGlobal = p;\n    p.yz *= rot((P*.125 + P*cos(p.x*.025))*isMagicalWorld);\n    \n    float aaaa= p.y;\n    float dBtwWagons = 5.56, dBtwWagonsH = dBtwWagons*.5;\n    float tSpeed = t*15. + cos(t*.55)*10.;\n    \n    float pxWagon = p.x + tSpeed;\n    float wagonNo = floor(pxWagon/dBtwWagons);\n    float pxDeniv = wagonNo*dBtwWagons + dBtwWagonsH - tSpeed;\n    vec3 wagonP = vec3(mod(pxWagon,dBtwWagons) - dBtwWagonsH,p.y + deniv(vec2(pxDeniv,p.z)),p.z);\n    \n    float pyWshifted = deniv(vec2(pxDeniv - dBtwWagonsH,p.z)) - deniv(vec2(pxDeniv + dBtwWagonsH,p.z));\n    wagonP.xy *= rot(atan(pyWshifted/dBtwWagons));\n    \n    p.y += deniv(p.xz);\n    \n    float wagon = wagon(wagonP,mod(wagonNo,3.));\n    float rails = rails(p);\n    \n    float d = min(rails,wagon);\n    \n    if(d == wagon) railsId = 0;\n    mapTravel = vec3(pxWagon,wagonP.yz);\n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,mix(.001,.1,isMagicalWorld)); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n// raymarching loop\n#define MAX_D 150.\n#define LIM .001\n#define MAX_IT 80\nstruct rmRes { vec3 pos; int it; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    vec3 p = c;\n    int it;\n    bool hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < LIM) { hit = true; break; }\n        if(distance(c,p) > MAX_D) break;\n        p += d*r;\n        it = i;\n    }\n    rmRes res; res.pos = p; res.it = it; res.hit = hit;\n    return res;\n}\n\n\n// 2d (cheap) starfield functions\nfloat sq(in vec2 st, in vec2 s) { return length(max(abs(st) - s, 0.)) - .001; }\nfloat star1(in vec2 st) { return max(abs(st.x)*abs(st.y) - .001,length(abs(st)) - .5); }\nfloat star2(in vec2 st) { return length(max(abs(st.y) + .02,0.)*max(abs(st.x) + .02,0.)) - .01; }\nfloat star3(in vec2 st) { return abs(length(st) - .4) - .03; }\nfloat star4(in vec2 st) { return min(sq(st,vec2(.5,.05)),sq(st,vec2(.05,.5))); }\nfloat star5(in vec2 st) { return abs(st.x) + abs(st.y) - .125; }\nfloat starSel(in vec2 st, in float sel) { st.x -= sel; return max(min(star1(st),min(star2(st + vec2(1.,0.)),min(star3(st + vec2(2.,0.)),min(star4(st + vec2(3.,0.)),star5(st + vec2(4.,0.)))))),(length(vec2(st.x + sel,st.y)) - .5)); }\nvec3 starField(in vec2 st) {\n    st *= 80.;\n    float d = starSel((fract(st) - .5)*1.5,floor(rand(floor(st))*100.));\n    return mix(vec3(1.),vec3(0.122,0.056,0.305),step(0.02,d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy - .5;\n    t = mod(iTime,240.)*-1.;\n    \n    isMagicalWorld = anim1(t*.025 + (st.x + .5)*.015,.1);\n    \n    vec3 c = vec3(2.,1.,-5.);\n    vec3 r = normalize(vec3(st,.65));\n    r.xz *= rot(.5*(m.x));\n    r.yz *= rot(.5*(m.y));\n    rmRes res = rm(c,r);\n    \n    vec3 skyColor = mix(vec3(.529,.807,.98),vec3(6.),isMagicalWorld);\n    vec2 bgMapPos = vec2(atan(r.x,r.z),r.y);\n    vec3 color = mix(skyColor,starField(bgMapPos + .015*t),isMagicalWorld);\n    color = mix(vec3(0.980,0.724,0.969)*1.2,color,clamp(bgMapPos.y*2.2 + 1.5,0.,1.));\n    \n    if(res.hit) {\n        vec3 n = normal(res.pos);\n        vec3 l = normalize(vec3(-0.387,0.666,0.087));\n        \n        float wagonColSel = mod(floor(mapTravel.x/5.56),5.)/5.;\n        color = wagonId == 1 ? hsv2rgb(vec3(.3 + wagonColSel,.8,1.))\n            : wagonId == 2 ? vec3(.2)\n            : wagonId == 4 ? vec3(0.109,0.271,0.500)\n            : wagonId == 3 ? vec3(.95)\n            : color;\n        color = railsId == 1 ? vec3(.5)\n            : railsId == 2 ? vec3(0.635,0.324,0.169)\n            : railsId == 3 ? vec3(0.498,.9,0.1)\n            : color;\n        \n        rmRes resShadow = rm(res.pos - r*.004,l);\n        if(resShadow.hit) color = mix(color*clamp(step(.4,-skyColor),0.4,1.),color,isMagicalWorld);\n        \n        color = mix(color,SpectrumPoly(clamp(.5+.5*cos(dot(n,-r)*8. + t),0.,1.)),isMagicalWorld);\n    \tskyColor = SpectrumPoly(fract(mapGlobal.x*.015))*mix(3.,30.,isMagicalWorld);\n        color += distance(res.pos,c)*.025;\n    }\n    color += pow(float(res.it)/float(MAX_IT),2.)*skyColor;\n\n    fragColor = vec4(color - pow(length(st)*.75,2.),1.0);\n}","name":"Image","description":"","type":"image"}]}