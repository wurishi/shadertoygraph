{"ver":"0.1","info":{"id":"lXVXR3","date":"1720304847","viewed":47,"name":"3D Rotations of Tesseract","username":"NoahSchrr","description":"with cube as reference","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERATIONS = 1000;\nconst float SURFACE_THRESHOLD = 0.00001;\nconst float MAX_DISTANCE = 100.0;\n\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Function to generate a random vec3\nvec4 randomVec4(vec2 seed)\n{\n    return vec4(rand(seed), rand(seed + 1.0), rand(seed + 2.0), rand(seed + 3.0));\n}\n\nfloat distanceToBox( vec3 currentPos,vec3 boxPos, vec3 boxDimensions ){\n  vec3 q = abs(currentPos - boxPos) - boxDimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distanceToTesseract( vec4 highPos,vec4 boxPos, vec4 boxDimensions ){\n  vec4 q = abs(highPos - boxPos) - boxDimensions;\n  return length(max(q,0.0)) + min(max(max(q.x,q.y),max(q.z,q.w)),0.0);\n}\n\n\n\nmat4 rotationMatrix(float angle, vec3 axis) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat4(\n        oc * x * x + c, oc * x * y - z * s, oc * x * z + y * s, 0.0,\n        oc * x * y + z * s, oc * y * y + c, oc * y * z - x * s, 0.0,\n        oc * x * z - y * s, oc * y * z + x * s, oc * z * z + c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n\nfloat sceneDistances3D(vec3 currentPos) {\n    vec3 cubeSize = 0.25 * vec3(1.0, 1.0, 1.0);\n    \n    mat4 rotMatY = rotationMatrix(-iMouse.x / iResolution.x * 6.0, vec3(0.0,1.0,0.0));\n    mat4 rotMatZ = rotationMatrix(-iMouse.y / iResolution.y * 6.0, vec3(0.0,0.0,1.0));\n    \n    vec4 currentPos4D = rotMatZ * rotMatY * vec4(currentPos, 0.0);\n    \n    float thingA = distanceToBox( currentPos4D.xyz, vec3(0.0, 1.5, 0.0), cubeSize);\n    \n    float result = thingA;\n    return result;\n}\n\n\n\nfloat sceneDistances4D(vec4 currentPos) {\n    mat4 rotMatY = rotationMatrix(-iMouse.x / iResolution.x * 6.0, vec3(0.0,1.0,0.0));\n    mat4 rotMatZ = rotationMatrix(-iMouse.y / iResolution.y * 6.0, vec3(0.0,0.0,1.0));\n    \n    vec4 currentPosRotated = rotMatZ * rotMatY * currentPos;\n                                    \n    float thingA = distanceToTesseract( currentPosRotated, vec4(0.0, 0.0, 0.0, 0.0), vec4(0.25, 0.25, 0.25, 0.25));\n    \n    float result = thingA;\n    return result;\n}\n\n\nfloat performRayMarching3D(vec3 rayOrigin, vec3 rayDirection) {\n    float totalDistance = 0.0;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        vec3 currentPosition = rayOrigin + rayDirection * totalDistance;\n        float distanceToScene = sceneDistances3D(currentPosition);\n        \n        if (distanceToScene < SURFACE_THRESHOLD) {\n            break;\n        }\n        \n        totalDistance += distanceToScene;\n        \n        if (totalDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    return totalDistance;\n}\n\nfloat performRayMarching4D(vec4 rayOrigin, vec4 rayDirection) {\n    float totalDistance = 0.0;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        vec4 currentPosition = rayOrigin + rayDirection * totalDistance;\n        float distanceToScene = sceneDistances4D(currentPosition);\n        \n        if (distanceToScene < SURFACE_THRESHOLD) {\n            break;\n        }\n        \n        totalDistance += distanceToScene;\n        \n        if (totalDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    return totalDistance;\n}\n\n\n\nvec3 computeRayDirection(vec2 uv) {\n    vec3 direction = vec3(uv - vec2(0.5), 1.0); \n    direction.x *= iResolution.x / iResolution.y; \n    return normalize(direction);\n}\n\nvec4 computeRayDirection4D(vec2 uv) {\n    vec4 direction = vec4(uv - vec2(0.5), 0.0, 1.0); \n    direction.x *= iResolution.x / iResolution.y; \n    return normalize(direction);\n}\n\n\n\nvec3 estimateNormal3D(vec3 p) {\n    const float epsilon = 0.001; \n\n    float centerDistance = sceneDistances3D(p);\n\n    float xDistance = sceneDistances3D(p + vec3(epsilon, 0.0, 0.0));\n    float yDistance = sceneDistances3D(p + vec3(0.0, epsilon, 0.0));\n    float zDistance = sceneDistances3D(p + vec3(0.0, 0.0, epsilon));\n\n    vec3 normal = normalize(vec3(xDistance, yDistance, zDistance) - centerDistance);\n\n    return normal;\n}\n\nvec4 estimateNormal4D(vec4 p) {\n    float epsilon = 0.8 ; \n\n    float centerDistance = sceneDistances4D(p);\n\n    float xDistance = sceneDistances4D(p + vec4(epsilon, 0.0, 0.0, 0.0));\n    float yDistance = sceneDistances4D(p + vec4(0.0, epsilon, 0.0, 0.0));\n    float zDistance = sceneDistances4D(p + vec4(0.0, 0.0, epsilon, 0.0));\n    float wDistance = sceneDistances4D(p + vec4(0.0, 0.0, 0.0, 0.33));\n\n    vec4 color = vec4(xDistance, yDistance, zDistance, wDistance) - centerDistance;\n\n    return normalize(color);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 rayOrigin3D = vec3(0.0, 0.0, -2.5);\n    vec4 rayOrigin4D = vec4(0.0, 0.0, 0.0, -2.5);\n    vec3 rayDirection3D = computeRayDirection(uv);\n    vec4 rayDirection4D = computeRayDirection4D(uv);\n    \n    float dist3D = performRayMarching3D(rayOrigin3D, rayDirection3D);\n    float dist4D = performRayMarching4D(rayOrigin4D, rayDirection4D);\n\n    vec3 col3D;\n    vec4 col4D;\n    if (dist4D < MAX_DISTANCE) {\n        col4D = estimateNormal4D(rayOrigin4D  + rayDirection4D * dist4D);\n        vec4 highArea = vec4(-col4D.w);\n        col4D *= tanh(highArea * 1.3);\n        col4D *= 3.7;\n        col4D *= tanh(col4D * 5.4);\n    } else {\n        col4D = vec4(0.01, 0.11, 0.17, 1.0);\n    }\n    \n    if (dist3D <= MAX_DISTANCE) {\n        col3D = vec3(0.3) + estimateNormal3D(rayOrigin3D + rayDirection3D * dist3D);\n    } else {\n        col3D = vec3(0.01, 0.11, 0.17);\n    }\n\n    fragColor = col4D + vec4(col3D, 1.0)  ;\n}","name":"Image","description":"","type":"image"}]}