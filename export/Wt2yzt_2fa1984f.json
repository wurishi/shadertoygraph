{"ver":"0.1","info":{"id":"Wt2yzt","date":"1595771429","viewed":290,"name":"We must perform a Quirkafleeg ","username":"shau","description":"rehash of old shader using truchet marble logic from Mattz","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/**\n * rehash of old shader\n * Truchet & Marble logic from Mattz\n * https://www.shadertoy.com/view/MtSyRz\n * More truchet logic from Shane\n * https://www.shadertoy.com/view/4lfcRl\n * Another nice Truchet from Shane\n * https://www.shadertoy.com/view/4lSBzm\n **/\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .001\n#define FAR 60.\n#define T iTime\n#define PI 3.141592\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nmat2 rot2(float x){return mat2(cos(x), -sin(x), sin(x), cos(x));}\n\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 PT(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1) * t + vec3(0, .33, .67)));}\n\n//Dave Hoskins hash without sin\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//IQ - SDFs & sphere functions\n//https://iquilezles.org/www/index.htm\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nfloat sdTorus2(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//IQ - sphere functions\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.;\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return tN;\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec4 near(vec4 a, vec4 b) \n{\n    return a.w < b.w ? a : b;\n}\n\nvec2 near(vec2 a, vec2 b) \n{\n    return a.x < b.x ? a : b;\n}\n\nvec3 dfScene(vec3 p, vec3 pg)\n{\n    vec2 v = vec2(abs(abs(length(p.xy) - .5) - 0.043), \n                  abs(p.z) - 0.043);\n    float frame = length(v) - 0.005;        \n    vec3 q = p;\n    q.xy *= rot(PI/24.);\n    float rep = 24.; \n    float ia = floor(atan(q.y, q.x)/6.283*rep) + .5;\n    q.xy = rot2(ia*6.283/rep)*q.xy;\n    q.x -= .5;\n    q = abs(q);\n    frame = min(frame, sdTorus2(q, vec2(0.06,0.005)));\n    \n    q = p;\n\tfloat cy = sdCappedCylinder(p,0.5,0.5);\n    float bx = sdBox(p - vec3(0.,0.,-0.1), vec3(1.0,1.0,0.11));\n    float bxo = sdBox(p - vec3(0.,0.,0.1), vec3(1.0,1.0,0.11));\n    float shell = sdTorus(p,vec2(0.5,0.06));\n    shell = max(shell, -sdTorus(p,vec2(0.5,0.058)));\n\n    ia = floor(atan(q.y,q.x)/6.283*rep);\n    vec2 h2 = hash21(ia);\n    float  h11 = hash11(ia);\n    float  h13 = hash13(floor(pg));\n    \n    if (h2.x<0.5)\n    {\n        shell = max(shell, -bx);\n    } \n    if (h2.x>0.7)\n    {\n        shell = max(shell, -bxo);\n    }\n    if (h2.y<0.5)\n    {\n        shell = max(shell, cy);\n    }\n    if (h2.y>0.7)\n    {\n        shell = max(shell, -cy);\n    }\n\n    return vec3(frame,\n                shell,\n                step(.8,h13)*step(.7,h11) + step(h13,.8)*step(h11,.6));\n}\n\n//Truchet and logic to keep balls moving in same direction\n//Mattz\n//https://www.shadertoy.com/view/MtSyRz\nvec4 checkTorus(vec3 p, vec3 src, vec3 dst) {\n    vec3 n = cross(dst, src);\n    p -= 0.5*(src+dst);    \n    vec3 u = p * mat3(src, dst, n);\n    return vec4(u, sdTorus(u, vec2(.5,0.06)));\n}\n\nfloat sdBall(vec3 u) \n{\n    float theta = 1.570796 * fract(0.2*iTime);\n    vec2 sc = 0.5*sin(vec2(theta, theta+1.570796));\n    float d = length(u + vec3(sc.x, sc.y, 0));\n    d = min(d, length(u + vec3(sc.y, -sc.x, 0)));\n    d = min(d, length(u + vec3(-sc.y, sc.x, 0)));\n    return d - 0.05;\n}\n\nvec4 truchet(vec3 p) \n{    \n    vec3 id = floor(p); \n    float h1 = hash13(id);\n    p = fract(p) - 0.5;\n   \n    vec3 s = sign(mod(id, 2.0) - 0.5);\n    if (s.y*s.z > 0.0) { p.yz = p.zy; }\n    p.x *= -s.y;\n    mat3 dst = mat3( 0, 0,-1, \n                    -1, 0, 0, \n                     0, 0, 1);                \n    \n    if (h1<.25) \n    {\n        dst = mat3(dst[2], dst[1], dst[0]); \n    } \n    else if (h1<.5)\n    {\n        dst = mat3(dst[0], dst[2], dst[1]); \n    }\n\telse if (h1<.75)\n    {\n        dst = mat3(dst[2], dst[0], dst[1]); \n    }\n    \n    vec4 t = checkTorus(p, vec3(1, 0, 0), dst[0]);\n    t = near(t, checkTorus(p, vec3(0, 1, 0), dst[1]));\n    return near(t, checkTorus(p, vec3(0, -1, 0), dst[2]));\n}\n\nvec4 map(vec3 p) \n{   \n\tvec4 t = truchet(p);     \n    float b = sdBall(t.xyz);\n    vec3 scene = dfScene(t.xyz,p);\n    \n    vec2 n = near(vec2(scene.x,1.), vec2(scene.y,2.));\n    n = near(n, vec2(b,3.0));\n\treturn vec4(n,b,scene.z);\n}\n\nvec3 normal(vec3 p) \n{\n    vec2 e = vec2(EPS, 0);\n    float d1 = map(p + e.xyy).x, d2 = map(p - e.xyy).x;\n    float d3 = map(p + e.yxy).x, d4 = map(p - e.yxy).x;\n    float d5 = map(p + e.yyx).x, d6 = map(p - e.yyx).x;\n    float d = map(p).x * 2.0;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//soft shadow variation - IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<48; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break; \n    }\n    return clamp( res, 0.03, 1.0 );\n}\n\nvec4 march(vec3 ro, vec3 rd) \n{\n    float t = 0.0, id = 0.0, pl = 0.0, gc;   \n    for (int i=ZERO; i<140; i++)\n    {\n        vec4 ns = map(ro + rd*t);\n        if (abs(ns.x)<EPS)\n        {\n            id = ns.y;\n            pl = ns.w;\n            break;\n        }\n        gc += 0.01/(1. + ns.z*ns.z*24000.);\n        t += ns.x*1.;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        } \n    }\n    return vec4(t,id,pl,gc);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float AT = T * 0.09;\n    \n    vec3 pc = vec3(0),\n         gc = vec3(0),\n         la = vec3(0.,0,0.1+AT),\n         ro = vec3(0.,0,AT);    \n    ro.x += sin(0.5*ro.z*PI*1.0);\n    la.x += sin(T*0.2)*1.4;\n    la.y += sin(3.+T*0.27)*1.4;\n    la.z += cos(T*0.13)*1.4;\n    \n    mat3 cam = camera(la,ro,0.);  \n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,1.4)); \n    \n    vec3 sc = PT(T*0.03);\n    vec4 s = march(ro,rd);\n    float mint = FAR;\n    if (s.x>0.0)\n    {\n        mint = s.x;\n        vec3 p = ro + rd*s.x;\n        vec3 n = normal(p);\n        vec3 ld = normalize(la - p);\n        float lt = length(la - p);\n        float attn = 1. / (1. + lt*lt*0.7);\n        float ao = AO(p,n);\n        float df = max(0.001,dot(ld,n));\n        float sh = shadow(p + n*0.001, ld, EPS, lt);\n        vec3 specc = mix(sc,vec3(1),0.7)*pow(max(dot(reflect(-ld,n),-rd),0.0),32.0);\n        vec3 nc = vec3(1.0,0.8,0.5)*max(0.,n.y)*0.04;\n        vec3 rc = texture(iChannel0,reflect(rd,n)).xyz;\n        \n        if (s.y==1.)\n        {\n            pc += rc*mix(sc,vec3(1),0.5);\n            pc *= df*attn;\n            pc += nc+specc;\n            pc *= ao*sh/(1. + s.x*s.x);\n        }\n        else if (s.y==2.)\n        {\n            vec3 psc = s.z>0. ? vec3(1,0.8,0.6)*0.02 : vec3(1,0.8,0.6);\n            pc = psc*mix(sc,vec3(1),0.5)+rc*0.4;\n            pc *= df*attn;\n            pc += nc+specc;\n            pc *= ao*sh/(1. + s.x*s.x);\n        }\n        else if (s.y==3.)\n        {\n            pc = sc*ao; \n            pc += nc;\n            pc += specc;\n            pc /= (1. + s.x*s.x*0.2);\n        }\n    }\n\n    float si = sphIntersect(ro,rd,vec4(la,0.1));\n    float sw = sphDensity(ro,rd,vec4(la,0.1),FAR);\n    if (si>0. && si<mint)\n    {\n        pc += sc *sw*sw*sw; \n        pc += vec3(1) *sw*sw*sw*sw*sw;\n    }\n    \n    //pc += sc*s.w*0.5;\n    pc = pow(pc*3.,vec3(.3545));\n    pc *= 1. / (1. + length(uv)*length(uv)*0.2);\n    \n    C = vec4(pc,1.0);\n}","name":"Image","description":"","type":"image"}]}