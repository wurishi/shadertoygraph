{"ver":"0.1","info":{"id":"XXVGRm","date":"1717438970","viewed":132,"name":"LiveArchive #01","username":"Flopine","description":"I'm digging up old shaders made during VJ sessions to archive them here! \n\nAlgorave Nogozon 2019","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","rainbow","vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n//Algorave Nogozon 2019\n\n\n#define PI 3.141592\n#define time iTime\n\n#define anim(o) (exp(-fract(time+o)*.7)*1.5) \n// CCs parameters were originally interface variables for a leap motion \n// through MIDI inputs in Kodelife\n#define CC1 anim(0.)\n#define CC2 anim(0.25)\n#define CC3 anim(0.5)\n#define CC4 anim(0.75)\n\n\nfloat hash1d (vec2 x)\n{return fract(sin(dot(x,vec2(1.45,8.151)))*45.489);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a, per) - per*.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id) >= rep/2.)id = abs(id);\n    return id;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat od (vec3 p, float r)\n{return dot(p, normalize(sign(p)))-r;}\n\nfloat box (vec3 p , vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat prim1 (vec3 p )\n{\n    float d = smin(od(p,.2), box(p, vec3(.5)), 0.5); \n    p.xz*= rot(time);\n    p.xz *= rot(p.y);   \n    float id = moda(p.xz, 3.);\n    p.x -= 1.;\n    d = min(d, cyl(p.xzy, 0.1, 4.));\n    return d;\n}\n\nfloat fractal (vec3 p, float count)\n{\n    float d = prim1(p);\n    for (float i=count; i>0.; i--)\n    {\n        float ratio = i/count;\n        p.xz = abs(p.xz) - CC3;\n\n        p.xz *= rot(PI/4.);\n        p.yz *= rot(time+ratio);\n        p.xz -= 1.8;\n        d = stmin(d, prim1(p),2., 5.);\n    }\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    p.y -= CC1;\n    p.xz *= rot(CC2);\n    return fractal(p, 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    float dither = hash1d(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-24.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            hit = true;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        col = palette (p.z, vec3(0.5), vec3(0.5), vec3(0.2), vec3(0.,0.4,0.7));\n        col *= (1.-shad);\n    }\n    \n    fragColor = vec4(pow(col, vec3(0.4545)), 1.);\n}","name":"Image","description":"","type":"image"}]}