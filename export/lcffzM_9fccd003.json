{"ver":"0.1","info":{"id":"lcffzM","date":"1723504152","viewed":7,"name":"Hyperbolic_Dodecahedron_6","username":"afoksha","description":"Renders tesselation of the hyperbolic space by dodecahedron with dihedral angle 2π/6. This dodecahedron is ideal, e.g. has vertices at ∞.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron","hyperbolicspace","lorentzspace","hyperboloidmodel"],"hasliked":0,"parentid":"MfXfzM","parentname":"Hyperbolic_Dodecahedron_5"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==========================================================================================================================\n//  Created by Alexander Foksha\n//\n//  Do with this or without this code whatever you wish at your own risk.\n//  You have been warned !!\n//==========================================================================================================================\n\nfloat hyp_dot(vec4 u, vec4 v)\n    { return dot(u.xyz, v.xyz) - u.w * v.w; }\n    \nvec4 normalize_t(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(-hyp_dot(v, v));\n    return inv_l * v;\n}\n\nfloat arccosh(float q)\n{\n    q = max(q, 1.0f);\n    float s = q + sqrt(q * q - 1.0f);\n    return log(s);\n}\n\nfloat arccosh_sqrt(float q)\n{\n    q = max(q, 1.0f);\n    float s = sqrt(q) + sqrt(q - 1.0f);\n    return log(s);\n}\n\n/* space-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = +1. Tangent directions to H^3 are space-like 4-vectors */\nvec4 normalize_s(vec4 v)\n{\n    float norm = dot(v.xyz, v.xyz) - v.w * v.w;\n    float inv_l = 1.0f / sqrt(norm);\n    return inv_l * v;\n}\n\nconst float alpha = 2.2672839422285122f;        /* sqrt(3) * (3 + sqrt(5)) / 4 */\nconst float beta  = 3.6685424806725857f;        /* sqrt(27 + 12 * sqrt(5)) / 2 */\nconst float gamma = 4.4270509831248423f;        /* (11 + 3 * sqrt(5)) / 4 */\nconst float mu    = 0.8660254037844386f;        /* sqrt(3) / 2 */\nconst float nu    = 1.4012585384440735f;        /* (1 + sqrt(5)) * sqrt(3) / 4 */\nconst float delta = 1.2247448713915890f;        /* sqrt(3) / sqrt(2) */\nconst float sigma = 1.9816788294587098f;        /* (1 + sqrt(5)) * sqrt(3) / (2 * sqrt(2)) */\nconst float omega = 1.8512295868219161f;        /* sqrt(7 + 3 * sqrt(5)) / 2 */\n\nconst float rho   = 2.8025170768881471f;        /* sqrt(3) * (sqrt(5) + 1) / 2 */\nconst float chi   = 2.6180339887498948f;        /* (3 + sqrt(5)) / 2 */\nconst float phi   = 2.1180339887498948f;        /* (2 + sqrt(5)) / 2 */\nconst float tau   = 1.3090169943749474f;        /* (3 + sqrt(5)) / 4 */\nconst float eta   = 0.8090169943749474f;        /* (1 + sqrt(5)) / 4 */\nconst float kappa = 0.8090169943749474f;        /* (1 + sqrt(5)) / 4 */\nconst float theta = 0.3090169943749474f;        /* (sqrt(5) - 1) / 4 */\n\n//==========================================================================================================================\n//      The main function: finds the point in the orbit of p under the action of hyperbolic reflections\n// group closest to the origin, or, the same, finds point equivalent to p in the main fundamental dodecahedron\n//==========================================================================================================================\n/* Reflection directions ::\n\n    { ±mu, ±nu, 0.0, tau }\n    { 0.0, ±mu, ±nu, tau }\n    { ±nu, 0.0, ±mu, tau }\n*/\nvec4 bounce(vec4 P)\n{\n    int k = 0;\n\n    /* sqrt(2) * vec3(mu, nu, tau) */\n    const vec3 K = vec3(delta, sigma, omega);\n\n    while (k < 12)\n    {\n        vec3 q = abs(P.xyz);\n        q = K.x * q + K.y * q.yzx;\n        float M = max(q.x, max(q.y, q.z));\n\n        /* dp is maximal hyperbolic dot product of P with reflection vectors (scaled by sqrt(2)) */\n        float dp = M - K.z * P.w;\n\n        if (dp <= 0.0f) break;\n\n        if (q.x >= M)           /* q.x = mu * |p.x| + nu * |p.y| is maximal */\n            P.xy -= dp * K.xy * sign(P.xy);\n        else if (q.y >= M)      /* q.y = mu * |p.y| + nu * |p.z| is maximal */\n            P.yz -= dp * K.xy * sign(P.yz);\n        else                    /* q.z = mu * |p.z| + nu * |p.x| is maximal */\n            P.zx -= dp * K.xy * sign(P.zx);\n\n        P.w -= dp * K.z;\n        ++k;\n    }\n\n    return P;\n}\n\nfloat spheric_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d = arccosh(p.w);\n    float sdf0 = d - 0.27f;\n    float sdf1 = 1.47f - d;\n    return min(sdf0, sdf1);\n}\n\n/*  Centers of the neighbouring fundamental domains ::\n\n    { ±alpha,  ±beta,    0.0, gamma }\n    {    0.0, ±alpha,  ±beta, gamma }\n    {  ±beta,    0.0, ±alpha, gamma }\n*/\nfloat face_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    vec3 q = alpha * a + beta * a.yzx;\n    float dp = gamma * p.w - max(max(q.x, q.y), q.z);\n    float d0 = arccosh(p.w);\n    float d1 = arccosh(dp);\n    float b_sdf = 1.37f - d0;\n    float f_sdf = 0.5f * (d1 - d0 - 0.048f);\n    return max(b_sdf, f_sdf);\n}\n\n/*  Centers of edges and rays tangent to edges at center ::\n\n    {  chi,  0.0,  0.0, rho },      {   0.0f,   1.0f,   0.0f }\n    { -chi,  0.0,  0.0, rho },      {   0.0f,   1.0f,   0.0f }\n    {  0.0,  chi,  0.0, rho },      {   0.0f,   0.0f,   1.0f }\n    {  0.0, -chi,  0.0, rho },      {   0.0f,   0.0f,   1.0f }\n    {  0.0,  0.0, -chi, rho },      {   1.0f,   0.0f,   0.0f }\n    {  0.0,  0.0,  chi, rho },      {   1.0f,   0.0f,   0.0f }\n\n    {  phi,  tau,  eta, rho },      {   0.5f, -theta, -kappa }\n    {  phi,  tau, -eta, rho },      {   0.5f, -theta,  kappa }\n    {  phi, -tau,  eta, rho },      {   0.5f,  theta, -kappa }\n    {  phi, -tau, -eta, rho },      {   0.5f,  theta,  kappa }\n    { -phi,  tau,  eta, rho },      {  -0.5f, -theta, -kappa }\n    { -phi,  tau, -eta, rho },      {  -0.5f, -theta,  kappa }\n    { -phi, -tau,  eta, rho },      {  -0.5f,  theta, -kappa }\n    { -phi, -tau, -eta, rho },      {  -0.5f,  theta,  kappa }\n\n    {  eta,  phi,  tau, rho },      { -kappa,   0.5f, -theta }\n    { -eta,  phi,  tau, rho },      {  kappa,   0.5f, -theta }\n    {  eta,  phi, -tau, rho },      { -kappa,   0.5f,  theta }\n    { -eta,  phi, -tau, rho },      {  kappa,   0.5f,  theta }\n    {  eta, -phi,  tau, rho },      { -kappa,  -0.5f, -theta }\n    { -eta, -phi,  tau, rho },      {  kappa,  -0.5f, -theta }\n    {  eta, -phi, -tau, rho },      { -kappa,  -0.5f,  theta }\n    { -eta, -phi, -tau, rho },      {  kappa,  -0.5f,  theta }\n\n    {  tau,  eta,  phi, rho },      { -theta, -kappa,   0.5f }\n    {  tau, -eta,  phi, rho },      { -theta,  kappa,   0.5f }\n    { -tau,  eta,  phi, rho },      {  theta, -kappa,   0.5f }\n    { -tau, -eta,  phi, rho },      {  theta,  kappa,   0.5f }\n    {  tau,  eta, -phi, rho },      { -theta, -kappa,  -0.5f }\n    {  tau, -eta, -phi, rho },      { -theta,  kappa,  -0.5f }\n    { -tau,  eta, -phi, rho },      {  theta, -kappa,  -0.5f }\n    { -tau, -eta, -phi, rho },      {  theta,  kappa,  -0.5f }\n*/\nfloat edge_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    const vec4 S0 = vec4(tau, -tau, eta, -eta);\n    const vec4 S1 = vec4(theta, -theta, kappa, -kappa);\n\n    vec3 q = rho * p.w - chi * a;\n    vec3 A = q * q - a.yzx * a.yzx;\n\n    vec4 b0 = rho * p.w - abs(phi * p.x + p.y * S0.xxyy + p.z * S0.zwzw);\n    vec4 b1 = 0.5f * p.x - p.y * S1.xxyy - p.z * S1.zwzw;\n    vec4 B = b0 * b0 - b1 * b1;\n\n    vec4 c0 = rho * p.w - abs(phi * p.y + p.z * S0.xxyy + p.x * S0.zwzw);\n    vec4 c1 = 0.5f * p.y - p.z * S1.xxyy - p.x * S1.zwzw;\n    vec4 C = c0 * c0 - c1 * c1;\n\n    vec4 d0 = rho * p.w - abs(phi * p.z + p.x * S0.xxyy + p.y * S0.zwzw);\n    vec4 d1 = 0.5f * p.z - p.x * S1.xxyy - p.y * S1.zwzw;\n    vec4 D = d0 * d0 - d1 * d1;\n\n    B = min(B, min(C, D));\n    B.xyz = min(B.xyz, A);\n    B.xy = min(B.xy, B.zw);\n\n    float Q = min(B.x, B.y);\n    float e_sdf = arccosh_sqrt(Q) - 0.19105f;\n\n    q = alpha * a + beta * a.yzx;\n    float dp = gamma * p.w - max(max(q.x, q.y), q.z);\n    float dist0 = arccosh(p.w);\n    float dist1 = arccosh(dp);\n    float b_sdf = 1.37f - dist0;\n    float f_sdf = 0.5f * (dist1 - dist0 - 0.048f);\n    f_sdf = max(b_sdf, f_sdf);\n\n    return min(e_sdf, f_sdf);\n}\n\nfloat edge_face_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 a = abs(p.xyz);\n\n    /* edge sdf */\n    const vec4 S0 = vec4(tau, -tau, eta, -eta);\n    const vec4 S1 = vec4(theta, -theta, kappa, -kappa);\n\n    vec3 q = rho * p.w - chi * a;\n    vec3 A = q * q - a.yzx * a.yzx;\n\n    vec4 b0 = rho * p.w - abs(phi * p.x + p.y * S0.xxyy + p.z * S0.zwzw);\n    vec4 b1 = 0.5f * p.x - p.y * S1.xxyy - p.z * S1.zwzw;\n    vec4 B = b0 * b0 - b1 * b1;\n\n    vec4 c0 = rho * p.w - abs(phi * p.y + p.z * S0.xxyy + p.x * S0.zwzw);\n    vec4 c1 = 0.5f * p.y - p.z * S1.xxyy - p.x * S1.zwzw;\n    vec4 C = c0 * c0 - c1 * c1;\n\n    vec4 d0 = rho * p.w - abs(phi * p.z + p.x * S0.xxyy + p.y * S0.zwzw);\n    vec4 d1 = 0.5f * p.z - p.x * S1.xxyy - p.y * S1.zwzw;\n    vec4 D = d0 * d0 - d1 * d1;\n\n\n    B = min(B, min(C, D));\n    B.xyz = min(B.xyz, A);\n    B.xy = min(B.xy, B.zw);\n\n    float Q = min(B.x, B.y);\n    float e_sdf = arccosh_sqrt(Q) - 0.19105f;\n\n    q = alpha * a + beta * a.yzx;\n    float dp = gamma * p.w - max(max(q.x, q.y), q.z);\n    float dist0 = arccosh(p.w);\n    float dist1 = arccosh(dp);\n    float b_sdf = 1.37f - dist0;\n    float f_sdf = 0.5f * (dist1 - dist0 - 0.048f);\n    f_sdf = max(b_sdf, f_sdf);\n\n    return min(e_sdf, f_sdf);\n}\n\nfloat sdf(vec4 p)\n{\n    //return spheric_sdf(p);\n    //return face_sdf(p);\n    //return edge_sdf(p);\n\n    return edge_face_sdf(p);\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.0005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    const int MAX_ITERATIONS = 64;\n\n    int i = 0;\n    while ((i < MAX_ITERATIONS) && (d > eps) && (t < 32.0))\n    {\n        t += d;\n        float s = sinh(t);\n        float c = cosh(t);\n        p = c * origin + s * ray;\n        d = sdf(p);\n        ++i;\n    }\n\n    if (d < 0.05f)\n        dist = t;\n\n    p.w = sqrt(1.0 + dot(p.xyz, p.xyz));\n    return p;\n}\n\n//==============================================================================================================================================================\n//      SDF gradient :: standard 6-point evaluation\n//      Standard orthonormal basis at origin parallel translated along the geodesic into a generic point P = { x, y, z, w }\n//  looks like:\n//\n//       X = { 1.0f + (x * x) / (w + 1),        (x * y) / (w + 1),        (x * z) / (w + 1), x },\n//       Y = {        (y * x) / (w + 1), 1.0f + (y * y) / (w + 1),        (y * z) / (w + 1), y },\n//       Z = {        (z * x) / (w + 1),        (z * y) / (w + 1), 1.0f + (z * z) / (w + 1), z },\n//\n//      They are normalized, orthogonal among themselves and orthogonal to P.\n//==============================================================================================================================================================\nvec4 hyperbolic_gradient6(vec4 p)\n{\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float inv_w = 1.0f / (1.0f + p.w);\n\n    vec4 X = vec4(1.0f + inv_w * x * x,        inv_w * x * y,        inv_w * x * z, x);\n    vec4 Y = vec4(       inv_w * y * x, 1.0f + inv_w * y * y,        inv_w * y * z, y);\n    vec4 Z = vec4(       inv_w * z * x,        inv_w * z * y, 1.0f + inv_w * z * z, z);\n\n    const float eps = 0.00625f;\n\n    float di = sdf(normalize_t(p + eps * X)) - sdf(normalize_t(p - eps * X));\n    float dj = sdf(normalize_t(p + eps * Y)) - sdf(normalize_t(p - eps * Y));\n    float dk = sdf(normalize_t(p + eps * Z)) - sdf(normalize_t(p - eps * Z));\n\n    vec4 g = di * X + dj * Y + dk * Z;\n    return normalize_s(g);\n}\n\n/* distance to origin :: arccosh(2) = 1.316958 */\nconst vec4 light_ws[8] = vec4[]\n(\n    vec4(+1, +1, +1, 2),\n    vec4(+1, +1, -1, 2),\n    vec4(+1, -1, +1, 2),\n    vec4(+1, -1, -1, 2),\n    vec4(-1, +1, +1, 2),\n    vec4(-1, +1, -1, 2),\n    vec4(-1, -1, +1, 2),\n    vec4(-1, -1, -1, 2)\n);\n\n//==============================================================================================================================================================\n//   Computes direction in 4-space hyperbolic-orthogonal to P, A, and B\n//   Note: if P is time-like (e.g. represents a point), and A, B are \n// space-like (e.g. represent directions) then cross-product is also space-like, \n// so is space-like normalizable\n//==============================================================================================================================================================\nvec4 hyp_cross(vec4 P, vec4 A, vec4 B)\n{\n    /* six 2x2 minors constructed from the rows A and B */\n    vec4 det2x2_1 = A * B.yzwx - B * A.yzwx;       /* xy, yz, zw, wx */\n    vec2 det2x2_2 = A.xy * B.zw - B.xy * A.zw;     /* xz, yw */\n\n    return vec4( \n        +P.y * det2x2_1.z - P.z * det2x2_2.y + P.w * det2x2_1.y,\n        -P.z * det2x2_1.w - P.w * det2x2_2.x - P.x * det2x2_1.z,\n        +P.w * det2x2_1.x + P.x * det2x2_2.y + P.y * det2x2_1.w,\n        +P.x * det2x2_1.y - P.y * det2x2_2.x + P.z * det2x2_1.x\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.77f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 0.97f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n    \n    float R = 1.32f + 0.32f * c1 + 0.371f * s0;\n    float W = sqrt(1.0f + R * R);\n    vec3 camera_xyz = R * normalize(vec3(-c1 * s0, s1 *  c0 * s2, s0 * c2));\n    vec4 camera_ws = vec4(camera_xyz, W);\n\n    /* compute some random directions in 3 space, lift them to hyperboloid and \n       apply Gram-Schmidt orthogonalization process on the fly */\n\n    float r = 0.75f;                                 /* look at close to origin */\n    vec3 z = camera_xyz + r * vec3(s1 * c0, -s0 * c2, s3 *  c1 * s2); \n    vec4 Z = vec4(z, dot(camera_xyz, z) / W);        /* lift it up to hyperboloid tangent space, Z is orthogonal to camera_ws */\n    Z = normalize_s(Z);                              /* normalize */\n    \n    vec3 x = vec3(s2 * c0, -s1 * c1, c2);            /* generate some random direction */\n    vec4 X = vec4(x, dot(camera_xyz, x) / W);        /* lift it up to hyperboloid tangent space, X is orthogonal to camera_ws */\n    X = X - hyp_dot(X, Z) * Z;                       /* make it hyperbolic-orthogonal to Z, it should remain orthogonal to camera_ws */\n    X = normalize_s(X);                              /* normalize */\n\n    vec4 Y = hyp_cross(camera_ws, Z, X);             /* compute the last basis vector as a cross product */\n    Y = normalize_s(Y);                              /* normalize, should not be needed */\n\n    vec4 view_ray = uv.x * X + uv.y * Y - Z;\n    view_ray = normalize_s(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f && dist < 7.2f)\n    {\n        float W = position.w;\n        vec4 n = hyperbolic_gradient6(position);\n        \n        const vec3 hue = vec3(1.41f, 1.73f, 2.72f);\n        float c = 1.0 / (1.0f + 0.175f * sqrt(position.w));\n        vec3 rgb = pow(vec3(c), 4.0f * hue);\n\n        vec3 view = camera_ws.xyz - position.xyz;\n        vec4 v = vec4(view, dot(view, position.xyz) / W);\n        v = normalize_s(v);                                     /* unit view vector at tangent space at position */\n\n        color = 0.225f * rgb;                                   /* ambient */\n\n        for (int i = 0; i < 8; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light.xyz, position.xyz);\n            float hyp_dp = W * light.w - dp;                    /* ch(distance), can be used directly for attenuation */\n\n            /* lift of the light direction to the hyperboloid */\n            vec4 l = vec4(light.xyz - position.xyz, -W + ((dp + 1.0f) / W));\n            l = normalize_s(l);                                 /* unit light vector at tangent space at position */\n\n            float a = 0.75f / (1.0f + 0.025f * hyp_dp);\n\n            float cos_theta = max(hyp_dot(l, n), 0.0f);\n            vec4 h = normalize_s(l + v);\n\n            float cos_alpha = max(hyp_dot(h, n), 0.0f);\n            vec3 diffuse  = (0.475f * cos_theta) * rgb;\n            vec3 specular = vec3(0.562f) * pow(cos_alpha, 88.0f);\n\n            color += a * (diffuse + specular);\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}