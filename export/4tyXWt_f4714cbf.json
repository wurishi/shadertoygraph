{"ver":"0.1","info":{"id":"4tyXWt","date":"1486339982","viewed":482,"name":"Rocket In The Sky","username":"TheSodOfGod","description":"Rocket smoke trail I made on a lazy Sunday afternoon. I've taken the distance functions from IQ https://www.shadertoy.com/view/Xds3zN . The trail looks a bit artificial but I'll work on it. The rocket DF is from https://www.shadertoy.com/view/ltjGD1","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","scattering","smoke","rocket"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\n#define PI 3.1415\n#define MOD2 vec2(3.07965, 7.4235)\n\n// Time Scaling\n#define time iTime*0.1\n\n// Raymarching\nfloat minPrimStepSize = 0.1 ;\nconst int primNumSamples = 100 ;\n\n// Colours\nconst vec3 smokeCol = vec3(30./255., 31./255., 30./255.) ;\nconst vec3 sunCol = vec3(1.0,1.0,1.0) ;\nconst vec3 backCol = vec3(206./255., 146./255., 14./255.) ;\nconst vec3 skyCol = vec3(135.,206.,250.)/255. ;\nconst vec3 rocketCol = vec3(230.,10.,10.)/255. ;\nconst vec3 ambientCol = vec3(0.4) ;\n\n// SmokeVals\nconst int octavesSmoke =  12 ;\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);  \n}\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 smokeStart = vec3(5.0,-5.0,5.0) ;\nvec3 smokeEnd = vec3(5.0,5.0,5.0) ;\nfloat smokeThickness = 1.0 ;\nfloat offset = 0.1 ;\n\nfloat sampleSmoke(vec3 position) {\n  float noiseVal = 0.0 ;\n  float amplitude = 1.0 ;\n  float freq = 4.5 ;\n  float lac = 2.0 ;\n  float scaling = 2.0 ;\n  for (int i = 0 ; i < octavesSmoke ; ++i) {\n    noiseVal += amplitude * noise(freq*position+vec3(0.0,time*200.0,3.0*time)) ;\n    amplitude /= lac ;\n    freq *= lac ;\n  }\n    \n  vec3 smokeDir = normalize(smokeEnd-smokeStart) ;\n  float dist = length((smokeStart - position) - (dot((smokeStart - position),smokeDir))*smokeDir) ;\n  noiseVal *= exp(-2.5*dist) ;\n  noiseVal -= offset ;\n  noiseVal *= (1.0 - exp(-0.05 * length(smokeStart-position))) ;\n  noiseVal = clamp(noiseVal,0.0,1.0) ;\n\n  return scaling * noiseVal ;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid rotate(const float a, inout vec2 v) {\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat pi = 3.1415 ;\n\nfloat mBox(vec3 p, vec3 b) {\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nvec2 frot(const float a, in vec2 v) {\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n    return v;\n}\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\n\nfloat dfRocketBody(vec3 p) {\n    float rocketRotation = 1.5*sin(0.9*time) ;\n    rotate(rocketRotation,p.xz);\n    vec3 p2 = p;\n    vec3 pWindow = p;\n\n    angularRepeat(pi*.25,p2.zx);\n    float d = p2.z;\n    d = max(d, frot(pi*-.125, p2.yz+vec2(-.7,0)).y);\n    d = max(d, frot(pi*-.25*.75, p2.yz+vec2(-0.95,0)).y);\n    d = max(d, frot(pi*-.125*.5, p2.yz+vec2(-0.4,0)).y);\n    d = max(d, frot(pi*.125*.25, p2.yz+vec2(+0.2,0)).y);\n    d = max(d, frot(pi*.125*.8, p2.yz+vec2(.55,0)).y);\n    d = max(d,-.8-p.x);\n    d -= .5;\n    \n    vec3 pThruster = p2;\n    pThruster -= vec3(-1.46,.0,.0);\n    rotate(pi*-.2,pThruster.yz);\n    d = min(d,mBox(pThruster,vec3(.1,.4,.27)));\n    d = min(d,mBox(pThruster-vec3(-.09,.0,.0),vec3(.1,.3,.07)));\n    \n    \n    pWindow -= vec3(.1,.0,.0);\n    angularRepeat(pi*.25,pWindow.xy);\n    pWindow -= vec3(.17,.0,.0);\n    d = min(d,mBox(pWindow,vec3(.03,.2,.55)));\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p) {       \n    float rocketRotation = 1.5*sin(0.9*time) ;\n    rotate(rocketRotation,p.xz);\n    \n    vec3 pFins = p;\n    angularRepeat(pi*.5,pFins.zx);\n    pFins -= vec3(0.0,-1.0+cos(p.y+.2)*.5,.0);\n    rotate(pi*.25,pFins.yz);\n    float scale = 1.0-pFins.y*.5;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat dfRocket(vec3 p) {\n    float proxy = mBox(p,vec3(2.5,.8,.8));\n    if (proxy>1.0)\n    \treturn proxy;\n    return min(dfRocketBody(p),dfRocketFins(p));\n}\n\n\nfloat sampleSmokeCap(vec3 position) {\n\treturn sdCapsule(position,smokeStart,smokeEnd,smokeThickness) ;  \n}\n\nfloat sampleRocketCCy(vec3 position) {\n    return dfRocket(position-(smokeEnd+vec3(0.0,2.3,0.0))) ;\n}\n\nbool isIntersectingSmokeShape(vec3 position, float precis, out float dist) {\n    dist = sampleSmokeCap(position) ;\n    return dist < precis ;\n}\n\nbool isIntersectingRocket(vec3 position, float precis, out float dist) {\n    dist = sampleRocketCCy(position) ;\n    return dist < precis ;\n}\n                          \nbool rayMarchTrans(vec3 startPos, vec3 direction, out float rayDist) {\n    vec3 position = startPos ;\n    bool intersected = false ;\n    rayDist = 0.0 ;\n    float delta = minPrimStepSize ;\n    float precis = 0.0005 ;\n    \n    for (int i = 0 ; i < primNumSamples ; ++i) {\n\t\tif (isIntersectingSmokeShape(position,precis,delta)) {\n            return true ;\n        } else {\n            precis = 0.00005 * rayDist ;\n\t\t    rayDist += delta ;\n            position = (rayDist)*direction + startPos ;\n        }\n    }\n    \n    return false ;\n}\n\nbool rayMarchSolids(vec3 startPos, vec3 direction, out float rayDist) {\n    vec3 position = startPos ;\n    bool intersected = false ;\n    rayDist = 0.0 ;\n    float delta = minPrimStepSize ;\n    float precis = 0.0005 ;\n    \n    for (int i = 0 ; i < primNumSamples ; ++i) {\n\t\tif (isIntersectingRocket(position,precis,delta)) {\n            return true ;\n        } else {\n            precis = 0.0005 * rayDist ;\n\t\t    rayDist += delta ;\n            position = (rayDist)*direction + startPos ;\n        }\n    }\n    \n    return false ;\n}\n\n\nconst float extinctionCoeff = 13.0 ;\nconst float scatteringCoeff = 12.5 ;\nconst float secSmokeSampleSize = 0.2 ;\nconst int secSmokeNumSamples = 5 ;\n\nfloat getIncidentSunlight(vec3 startPos, vec3 lightDir) {\n    vec3 position = startPos ;\n    vec3 stepVector = lightDir * secSmokeSampleSize ;\n    float extinction = 1.0 ;\n    float dist = 0.0 ;\n    for (int i = 0 ; i < secSmokeNumSamples ; ++i) {\n        if (!isIntersectingSmokeShape(position,0.005,dist))\n            break ;\n\t    float density = sampleSmoke(position) ;\n        extinction *= exp(-extinctionCoeff*density*secSmokeSampleSize) ;\n        position += stepVector ;\n    }\n    return extinction ;\n}\n\nconst float primSmokeSampleSize = 0.1 ;\nconst int primSmokeNumSamples = 50 ;\n\nvec4 primaryRayMarchSmoke(vec3 startPos, vec3 direction, vec3 lightDir) {\n    vec3 position = startPos ;\n    vec3 stepVector = direction * primSmokeSampleSize ;\n    float dist ;\n    float extinction = 1.0 ;\n    vec3 colour = vec3(0.0) ;\n    for (int i = 0 ; i < primSmokeNumSamples ; ++i) {\n        if (extinction < 0.05 || !isIntersectingSmokeShape(position,0.005,dist))\n            break ;\n     \tfloat vertDistFromRocket = abs(position.y - smokeEnd.y) ;\n        float deltaYDensityMod = (1.f-(vertDistFromRocket)/(smokeEnd.y-smokeStart.y));\n\t\tfloat density = sampleSmoke(position) * deltaYDensityMod * deltaYDensityMod;\n        extinction *= exp(-extinctionCoeff*density*primSmokeSampleSize);\n        vec3 scattering = primSmokeSampleSize * density * scatteringCoeff * (ambientCol +  sunCol * getIncidentSunlight(position, lightDir)) ;\n        colour += scattering * extinction ;\n        position += stepVector ;\n    }\n    \n    return vec4(colour,extinction) ;    \n}\n\nvec3 calcSkyCol(in vec3 direction, in vec3 lightDir) {\t\n    float sunAmount = max( dot(direction, lightDir), 0.0 );\n\tfloat v = pow(1.0-max(direction.y,0.0),5.)*.5;\n\tvec3  sky = vec3(v*sunCol.x*0.4+skyCol.x, v*sunCol.y*0.4+skyCol.y, v*sunCol.z*0.4+skyCol.z);\n\tsky = sky + sunCol * pow(sunAmount, 6.5)*.12;\n\tsky = sky+ sunCol * min(pow(sunAmount, 1200.), .3)*.65;\n\treturn sky;\n}\n\n// Taken from IQ : https://www.shadertoy.com/view/Xds3zN\nvec3 calcRocketNormal( in vec3 pos ) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sampleRocketCCy( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sampleRocketCCy( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sampleRocketCCy( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sampleRocketCCy( pos + e.xxx ));\n}\n\nvec4 calcRocketColour(in vec3 position,in vec3 direction, in vec3 lightDir) {\t\n\tvec3 nor = calcRocketNormal(position) ;\n    vec3 ref = reflect( direction, nor);\n    vec3 col = vec3(0.0) ;\n    // lighting        \n\tvec3  lig = lightDir ;\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n    if (dfRocketBody(position)>dfRocketFins(position)) {\n    \tif (position.y<smokeEnd.y-0.85 || position.y>smokeEnd.y+1.34)\n        \tif (position.y>smokeEnd.y+3.41)\n            \tcol = vec3(.1,.1,.1);\n            else\n                col = vec3(.9,.9,.9);\n        else {\n        \tcol = vec3(.1,.1,.1);\n        }\n    }\n    \n\tvec3 lin = vec3(0.0);\n    lin += 4.30*dif*vec3(1.00,0.80,0.55);\n\tlin += 7.00*spe*vec3(1.00,0.90,0.70)*dif;\n    lin += 1.00*amb ;\n\tcol = col*lin;\n    \n    return vec4(col,0.0) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    vec2  m = 2.*((iMouse.xy / iResolution.xy) - 0.5);\n    \n    if (iMouse.xy == vec2(0)) {\n       m.y = 0.0 ;   \n    }\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n    dir.xz = rot2D(dir.xz, 45.);\n    dir = normalize(dir) ;\n    \n    vec3 cameraPos = vec3(0.0,7.0,3.0*offset) ;\n    \n\n   float lightElev = 10. * 3.14/180. ;\n   float lightAzi = 90. * 3.14/180. + time * 20. ;\n   vec3 lightDir = vec3(cos(lightAzi)*cos(lightElev),sin(lightElev),sin(lightAzi)*cos(lightElev));\n\n    \n    float rayDistTrans = 0.0 ;\n    float rayDistSolid = 0.0 ;\n    vec4 colour = vec4(vec3(0.0),1.0) ;\n    bool isTransPresent = rayMarchTrans(cameraPos,dir,rayDistTrans) ;\n    bool isSolidPresent = rayMarchSolids(cameraPos,dir,rayDistSolid) ;\n    \n    if (isTransPresent && isSolidPresent) {\n        if (rayDistSolid < rayDistTrans) {\n            colour = calcRocketColour(cameraPos+dir*rayDistSolid,dir,lightDir) ; \n        } else {\n        \tcolour = primaryRayMarchSmoke(cameraPos+dir*rayDistTrans,dir,lightDir) ; \n            colour = vec4(mix(colour.rgb,calcRocketColour(cameraPos+dir*rayDistSolid,dir,lightDir).rgb,colour.a),0.0) ;\n        }\n    } else if (isTransPresent) {\n        colour = primaryRayMarchSmoke(cameraPos+dir*rayDistTrans,dir,lightDir) ;\n    } else if (isSolidPresent) {\n        colour = calcRocketColour(cameraPos+dir*rayDistSolid,dir,lightDir) ;    \n    }\n    vec3 skyCol = calcSkyCol(dir,lightDir) ;\n    colour.rgb = mix(colour.rgb,skyCol,colour.a) ;\n    fragColor = vec4(colour.rgb,1.0) ;\n}","name":"Image","description":"","type":"image"}]}