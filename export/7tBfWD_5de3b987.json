{"ver":"0.1","info":{"id":"7tBfWD","date":"1652203948","viewed":118,"name":"Alt. 2.5D HSV Color Picker","username":"hero_dev","description":"needed a color picker, thought i would think of something less traditional and with limitations.\nthe animation is mostly the bottleneck with all the 'sin' calls (mostly ANIM_WAVE), but will be optimized in the application by pre-calculating on the CPU.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cube","color","25d","hsv","isometric","orthographic","picker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITER = 1000;\nconst float MAX_DIST = 9.0;\nconst float EPSILON = 0.001;\n\nconst float pi = 3.14159;\nconst float inf = 1.f / 0.f;\n\n#define CUBE_AXIS_COUNT       4\n#define CUBE_HALF_SIZE        (CUBE_SIZE / 2.f)\n#define CUBE_BORDER_HALF_SIZE (0.1f / float(CUBE_AXIS_COUNT * CUBE_AXIS_COUNT + 1))\n#define CUBE_SIZE             ((2.f - CUBE_BORDER_HALF_SIZE) / float(CUBE_AXIS_COUNT * CUBE_AXIS_COUNT + 1))\n#define CUBE_AXIS_OFFSET      (CUBE_SIZE * float(CUBE_AXIS_COUNT) + CUBE_BORDER_HALF_SIZE)\n#define SELECTED_SPEED        4.0\n#define SELECTED_MAX_OFFSET   (CUBE_HALF_SIZE * 2.f)\n\n//\n// these sin functions (mostly ANIM_WAVE) is slowing down the shader.\n// in a real application these will be passed in to the shader.\n#define ANIM_ROTATION_Y       (is_at_timeline_range(TIMELINE_SPIN_START, TIMELINE_SPIN_END) ? sin(iTime * 1.5) * pi * 2.f : 0.f)\n#define ANIM_AXIS             (is_at_timeline_range(TIMELINE_OPEN_START, TIMELINE_OPEN_END) ? (sin(iTime * 2.0 - pi / 2.f) * 0.5 + 0.5) : 1.f)\n#define ANIM_WAVE             (is_at_timeline_range(TIMELINE_WAVE_START, TIMELINE_WAVE_END) ? sin(iTime * 8.f + mul(hsv_indices_to_unorm(ivec3(h,s,v), h_count, s_count) * 8.f)) * (sin(smoothstep(TIMELINE_WAVE_START, TIMELINE_WAVE_END, iTime) * (pi * 1.5f)) * 0.5 + 0.5) * 0.04 : 0.f)\n#define ANIM_SELECTED         (is_at_timeline_range(TIMELINE_SELECT_START, TIMELINE_SELECT_END) ? 1.f : 0.f)\n\n#define TIMELINE_SPIN_START   0.f\n#define TIMELINE_SPIN_END     1.1f\n#define TIMELINE_OPEN_START   0.f\n#define TIMELINE_OPEN_END     1.5f\n#define TIMELINE_WAVE_START   0.75f\n#define TIMELINE_WAVE_END     1.6f\n#define TIMELINE_SELECT_START 1.3f\n#define TIMELINE_SELECT_END   inf\n\nconst float cube_half_size = CUBE_HALF_SIZE;\nconst float cube_size = CUBE_SIZE;\nconst float cube_border_half_size = CUBE_BORDER_HALF_SIZE;\nconst float cube_axis_offset = CUBE_AXIS_OFFSET;\nconst float selected_max_offset = SELECTED_MAX_OFFSET;\n\nfloat length_sq(vec3 v) { return dot(v, v); }\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\nfloat mul(vec3 v) { return v.x * v.y * v.z; }\n\nfloat distance_sq_cube(vec3 pos, float size) {\n    return length_sq(max(abs(pos) - size, 0.0));\n}\n\nfloat distance_sq_cube_frame(vec3 pos, float size, float width) {\n    pos = abs(pos) - size;\n    vec3 q = abs(pos + width) - width;\n\n    return min(\n        min(\n            length_sq(max(vec3(q.x, q.y, pos.z), 0.0)),\n            length_sq(max(vec3(q.x, pos.y, q.z), 0.0))\n        ),\n        length_sq(max(vec3(pos.x, q.y, q.z), 0.0))\n    );   \n}\n\nmat2 mat2_identity_rotation(float angle)\n{\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    );\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool is_at_timeline_range(float start, float end) {\n    float time = iTime;\n    return start <= time && time <= end;\n}\n\nvec3 hsv_indices_to_unorm(ivec3 hsv, int h_count, int s_count) {\n    return vec3(hsv) / vec3(max(h_count - 1, 1), max(s_count - 1, 1), CUBE_AXIS_COUNT - 1);\n}\n\nfloat scale = 1.0;\nvec4 distance_cubes(\n    vec3 ray_sample_pos,\n    vec3 is_split_axis_v3,\n    ivec3 selected_color_idx,\n    float offset_ratio\n) {\n    //\n    // rotate the sample position towards local space of the cube\n    ray_sample_pos.yz *= mat2_identity_rotation(pi / 5.0);\n    ray_sample_pos.xz *= mat2_identity_rotation(pi / 4.f + ANIM_ROTATION_Y);\n    \n    vec4 last_dist_sq = vec4(vec3(0.f), 99999.f);\n    vec3 pos;\n    \n    for (int v = 0; v < CUBE_AXIS_COUNT; v += 1) {\n        int s_count = v + 1;\n        vec3 split_axis_offset = is_split_axis_v3 * (float(s_count) * cube_size) + cube_size;\n    \n        for (int s = 0; s < s_count; s += 1) {\n            \n            int h_count = max(s * 6, 1);\n            float h_step = 2.f * pi / float(h_count);\n            for (int h = 0; h < h_count; h += 1) {\n                pos.xz = vec2(s) * mat2_identity_rotation(float(h) * h_step);\n                pos.y = float(v);\n\n                //\n                // 0.f or 1.f if this cube is selected\n                float is_selected_f = float(all(equal(selected_color_idx, ivec3(h, s, v))));\n                \n                //\n                // calculate the selected offset if the cube is selected\n                vec3 selected_offset = is_selected_f * is_split_axis_v3 * selected_max_offset * offset_ratio * ANIM_SELECTED;\n                \n                //\n                // the offset of the cube on the split axis\n                vec3 cube_split_axis_offset = pos * split_axis_offset;\n                \n                //\n                // apply the wave and slow the demo down :/\n                cube_split_axis_offset.y += ANIM_WAVE;\n                cube_split_axis_offset.y -= (float(CUBE_AXIS_COUNT) * 0.01) + ANIM_AXIS * 0.5 + 0.5;\n                \n                //\n                // bring the sample position in to local space of this cube\n                vec3 local_sample_pos = ray_sample_pos + cube_split_axis_offset + selected_offset;\n        \t\t\n                float next_dist_sq = distance_sq_cube(local_sample_pos, cube_half_size) * scale;\n                if (next_dist_sq < last_dist_sq.w) {\n                    vec3 color = hsv2rgb(hsv_indices_to_unorm(ivec3(h, s, v), h_count, s_count));\n                    float frame_dist_sq = distance_sq_cube_frame(local_sample_pos, cube_half_size, cube_border_half_size) * scale;\n                    if (frame_dist_sq < next_dist_sq) {\n                        //\n                        // we hit the frame of the cube\n                        float grey = sum((1.f - color) / 3.f);\n                        grey += is_selected_f * sin(iTime * SELECTED_SPEED) * ANIM_SELECTED;\n                        last_dist_sq = vec4(vec3(grey), next_dist_sq);\n                     } else {\n                        //\n                        // we hit the cube\n                        last_dist_sq = vec4(color, next_dist_sq);\n                    }\n                }\n            }\n        }\n    }\n    \n    last_dist_sq.w = sqrt(last_dist_sq.w);\n    return last_dist_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // a value from -1.f to 1.f\n    vec2 screen_pos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 world_up = vec3(0.0, -1.0, 0.0);\n    \n\tvec3 camera_pos = vec3(0.0, 0.0, 1.0);\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    vec3 camera_dir = normalize(camera_target - camera_pos);\n    vec3 camera_right = cross(camera_dir, world_up);\n    vec3 camera_up = cross(camera_right, camera_dir);\n    \n    vec3 ray_sample_pos\n        = camera_pos\n        + (screen_pos.x * camera_right)\n        + (screen_pos.y * camera_up)\n        ;\n    vec3 ray_dir = normalize(camera_dir);\n    \n    float total_dist = 0.0;\n    vec4 dist = vec4(0.0, 0.0, 0.0, EPSILON);  \n    \n    ivec3 selected_color_idx = ivec3(0, 0, 2);\n    \n    vec3 axis = vec3(0.0, 1.0, 0.0) * ANIM_AXIS;\n    \n    float offset_ratio = sin(iTime * SELECTED_SPEED) * 0.5 + 0.5;\n    \n    for (int i = 0; i < MAX_ITER; i += 1) {\n        if (dist.w < EPSILON || total_dist > MAX_DIST) {\n            break;\n        }\n        \n        dist = distance_cubes(\n            ray_sample_pos,\n            axis,\n            selected_color_idx,\n            offset_ratio\n        );\n        total_dist += dist.w;\n        ray_sample_pos += dist.w * ray_dir;\n    }\n \n    vec3 color = vec3(0.f);\n    if (dist.w < EPSILON) {   \n        color = dist.rgb;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}