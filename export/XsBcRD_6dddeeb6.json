{"ver":"0.1","info":{"id":"XsBcRD","date":"1491381819","viewed":204,"name":"Light Test","username":"MartinRGB","description":"光照测试 add environment,my article about this effect:https://martinrgb.github.io/blog/#/Namedrop_Animation","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["lightenvironment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Nikos Papadopoulos, 4rknova / 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ENABLE_LIGHTING\n#define ENABLE_SPECULAR\n\n#define OFFSET_X 1\n#define OFFSET_Y 1\n#define DEPTH\t 3.\n\n#define PI 3.14159265359\n\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nvec3 envMap(vec3 rd, vec3 sn,vec2 fragCoord){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iMouse.xy/iResolution.xy*.25;\n    rd *= 1.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    vec3 mTex = texture(iChannel1,(fragCoord.xy+iMouse.xy)/iResolution.xy/40.).xyz;\n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    //return texture(iChannel1,(fragCoord.xy+iMouse.xy)/iResolution.xy).xyz;\n    \n\t//return mix(mTex, mTex.yzx, sRd*.25+.25);\n} \n\nvec3 texsample(const int x, const int y, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy;\n\tuv = (uv + vec2(x, y)) / iResolution.xx;\n\treturn texture(iChannel0, uv).xyz;\n}\n\nfloat luminance(vec3 c)\n{\n\treturn dot(c, vec3(.2126, .7152, .0722));\n}\n\n\n\n\n\nvec3 normal(in vec2 fragCoord)\n{\n\tfloat R = abs(luminance(texsample( OFFSET_X,0, fragCoord)));\n\tfloat L = abs(luminance(texsample(-OFFSET_X,0, fragCoord)));\n\tfloat D = abs(luminance(texsample(0, OFFSET_Y, fragCoord)));\n\tfloat U = abs(luminance(texsample(0,-OFFSET_Y, fragCoord)));\n\t\t\t\t \n\tfloat X = (L-R) * .5;\n\tfloat Y = (U-D) * .5;\n\n\treturn normalize(vec3(X, Y, 1. / DEPTH));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 n = normal(fragCoord);\n    \n    float mPositionX,mPositionY;\n    float prevX,timeClock;\n    \n    ;\n    if(iMouse.z >=0.5 ){;\n        mPositionX = sin(iMouse.x/iResolution.x*2.*PI)*1. + 0.5 ;\n        mPositionY = cos(iMouse.x/iResolution.x*2.*PI)*1. + 0.5 ;\n     }\n\n    else{\n        \n         mPositionX = sin(iMouse.x/iResolution.x*2.*PI)*1. + 0.5 - 10.*sin(((iMouse.x))/iResolution.x*2.*PI)*fract(iTime);\n    \t mPositionY = cos(iMouse.x/iResolution.x*2.*PI)*1. + 0.5 - 10.*cos(((iMouse.x))/iResolution.x*2.*PI)*fract(iTime);\n\n    };\n        \n    \n\n\n\tvec3 lp = vec3(vec2(mPositionX,mPositionY) * iChannelResolution[0].xy, 200.);\n\tvec3 sp = vec3(fragCoord.xy / iResolution.xy * iChannelResolution[0].xy, 0.);\n\tvec3 c = texsample(0, 0, fragCoord) * dot(n, normalize(lp - sp));\n\n    float e = 64.;\n    vec3 ep = vec3(vec2(0.5,0.5) * iChannelResolution[0].xy, 1000.);\n\tc += pow(clamp(dot(normalize(reflect(lp - sp, n)), \n\t\t\t\t\t   normalize(sp - ep)), 0., 1.), e);\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //Fake Mapping Environment\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.x));\n    vec3 sn = texsample(0,0,fragCoord).xyz;\n    vec3 mColorMapping = vec3(.5,.5,.5)*envMap(reflect(rd+iMouse.x/iResolution.x, sn+iMouse.y/iResolution.y), sn,fragCoord)*0.15;;\n\t\n\tfragColor = vec4(c*vec3(uv.x,uv.y,0.) + texsample(0,0,fragCoord)*0. + mColorMapping, 1);\n}","name":"Image","description":"","type":"image"}]}