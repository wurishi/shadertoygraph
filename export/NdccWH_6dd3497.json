{"ver":"0.1","info":{"id":"NdccWH","date":"1653359551","viewed":223,"name":"Ray-ellipse intersection","username":"LucasR","description":"Analytic intersection between a ray and an ellipse, useful for ray tracing. You can move the ray origin with the mouse.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdEllipse( vec2 p, vec2 ab ){\n// source: https://www.shadertoy.com/view/4lsXDN\n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n// source: https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat sdCircle( vec2 p, float r ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\n// My crappy solution\n/*vec3 intEllipse(vec2 ro, vec2 rd, vec2 ab){ // ray-ellipse intersection\n    vec3 inter = vec3(0.); // if inter.z == 0., there's no intersection\n    if(rd.x == 0.) rd.x = 0.01;\n    float m = rd.y/rd.x; // line equation: y = m*x + k\n    float k = ro.y - m*ro.x;\n    if(k*k > ab.x*ab.x * m*m + ab.y*ab.y){ // there's no intersection\n        return inter;\n    }else{\n        // applying Bhaskara's formula for second degree polynomials:\n        float xx_term = ab.x*ab.x * m*m + ab.y*ab.y; // x^2 term of the polynomial\n        float x_term = 2.*ab.x*ab.x*m*k; // linear term\n        float ind_term = ab.x*ab.x * (k*k - ab.y*ab.y); // independent term\n        float sq = sqrt( x_term*x_term - 4. * xx_term * ind_term ); // square root of discriminant\n        vec2 Q1, Q2; // possible solutions\n        Q1.x = (-x_term + sq)/(2.*xx_term);\n        Q2.x = (-x_term - sq)/(2.*xx_term);\n        Q1.y = m*Q1.x + k;\n        Q2.y = m*Q2.x + k;\n        // determine which (if any) of the solutions is the correct one\n        if(dot(rd, Q1-ro) > 0.){ // it's in the right half of the line\n            if(dot(rd, Q2-ro) > 0.){ // both solutions are on the right side\n                if(length(Q1-ro) < length(Q2-ro)){ // Q1 is closer, therefore the right solution\n                    return vec3(Q1, 1.);\n                }\n                return vec3(Q2, 1.);\n            }\n            return vec3(Q1, 1.);\n        }\n        if(dot(rd, Q2-ro) > 0.){ // Q2 is in the right side\n            inter = vec3(Q2, 1.);\n        }\n    }\n    return inter;\n}*/\n\n// iq's awesome solution\nvec2 intEllipse( in vec2 ro, in vec2 rd, in vec2 ab )\n{\n    vec2 ocn = ro / ab;\n    vec2 rdn = rd / ab;\n    float a = dot( rdn, rdn );\n    float b = dot( ocn, rdn );\n    float c = dot( ocn, ocn );\n    float h = b*b - a*(c-1.0);\n    if( h<0.0 ) return vec2(0.0); // there's no intersection\n    h = sqrt(h);\n    float t1 = (-b-h)/a;\n    float t2 = (-b+h)/a;\n    // determine which (if any) of the solutions is the correct one\n    if( max(t1,t2)<0.0 ) return vec2(0.0); // none is\n    float t = (t1>0.0)?t1:t2;\n    return vec2( t, 1.0 ); // modified it to output the distance instead of the point\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (-iResolution.xy + 2.*(fragCoord))/iResolution.y;\n    float LTh = 3./iResolution.y; // line thickness\n    float t = iTime/3.;\n    vec2 ro;\n    vec2 rd = vec2(cos(t), sin(t));\n    if(iMouse.z > 0.){ // move ro to mouse position if the LMB is being presssed\n        ro = (-iResolution.xy + 2.*(iMouse.xy))/iResolution.y;\n    }else{\n        float t = iTime/3.;\n        ro = vec2(0.);\n    }\n    vec2 ab = vec2(1.3, .8); // ellipse axes\n    \n    vec3 col = vec3(0.);\n    float d = sdEllipse(uv, ab);\n    col = vec3(smoothstep(1.-LTh, 1., 1.-abs(d)));\n    vec2 inter = intEllipse(ro, rd, ab);\n    \n    col = mix(col, vec3(1., 1., 0.), smoothstep(1.-LTh, 1., 1.-sdSegment(uv, ro, ro+rd*10.))); // line\n    col = mix(col, vec3(1., 0., 0.), smoothstep(1.-LTh, 1., 1.-sdCircle(uv-ro, .015))); // ro\n    if(inter.y == 0.){ // no valid intersection\n        col = mix(col, vec3(1., 0., 0.), 0.1);\n    }else{\n        col = mix(col, vec3(0., 1., 0.), smoothstep(1.-LTh, 1., 1.-sdCircle(uv-(ro+inter.x*rd), .015)));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}