{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// MIT License\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    \n    vec4 color = vec4(0.0);\n    \n    float blurRadius = 2.0;\n    float samples = 0.0;\n    for(float y = -blurRadius; y <= blurRadius; y++) {\n        vec2 offset = vec2(0.0, y + 0.5) * texelSize;\n        color += texture(iChannel0, uv + offset);\n        samples += 1.0;\n    }\n    \n    fragColor = color / samples;\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// MIT License\n\n// ==================== Camera Stuff ==================== \n\nmat3 getCameraMatrix(vec3 ro, vec3 lookAt) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\nvoid getRoRd(vec2 fragCoord, vec2 resolution, vec4 imouse, float time, out vec3 ro, out vec3 rd)\n{    \n    vec2 uv = fragCoord/resolution.xy;\n    vec2 p = (2.0*fragCoord-resolution.xy)/resolution.y;\n    \n    // Orbit camera controls\n    vec2 mouse = imouse.xy/resolution.xy;\n    float camDist = 0.00001f;\n    \n    if (imouse.xy == vec2(0.0)) {\n        mouse = vec2(0.0, 0.6);\n    }\n    \n    mouse.y = 1.0 - mouse.y;\n    \n    // Convert mouse position to spherical coordinates\n    float azimuth = (mouse.x * 2.0 - 1.0) * 3.141592;\n    float elevation = (mouse.y - 0.5) * 3.141592;\n    \n    // Calculate camera position\n    ro = vec3(\n        camDist * cos(elevation) * cos(azimuth),\n        camDist * sin(elevation),\n        camDist * cos(elevation) * sin(azimuth)\n    );\n    \n    // Look at origin\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    mat3 camMat = getCameraMatrix(ro, lookAt);\n    rd = camMat * normalize(vec3(p, 2.0));\n\n}\n\n// ==================== End Of Camera Stuff ==================== ","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"volume","id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// MIT License\n\n// Still a lot of room for improvement in performance\n// Having two ray->plane intersections to find the start/end of the ray would be a big one\n\n//#define HIGH_PERFORMANCE\n\n#ifdef HIGH_PERFORMANCE\n    #define MAX_OCTAVES 2.0\n    #define FAKE_OCTAVES \n#else\n    #define MAX_OCTAVES 5.0\n#endif\n\n// just a bunch of random cos/sin's to try to make a natural looking \"noise\" from most angles\nfloat synthOctave(vec3 p) {\n    return (sin(p.x * 10.0 + p.y) * cos(p.z + p.y * 10.0) * 0.5 + 0.5) * \n           (cos(p.y * 10.0 + p.z) * sin(p.x + p.z * 10.0) * 0.5 + 0.5) * 0.5;\n}\n\nfloat fbm(int octaves, vec3 x) {\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * textureLod(iChannel1, (s * x)/32.0, 0.0).x;\n    }\n    \n#ifdef FAKE_OCTAVES\n    float synthWeight = 0.08 * (5.0 - float(octaves)); // More synthetic detail for fewer octaves\n    \n    float detail1 = synthOctave(x * 2.0);\n    r += detail1 * synthWeight;\n    \n    float detail2 = synthOctave(x * 4.0) * 0.5;\n    r += detail2 * synthWeight;\n#endif\n    \n    return r;\n}\n\nfloat sampleDensity(int octaves, vec3 p) {\n    p.x += iTime * 0.1;\n    \n    float density = fbm(octaves, p * 0.25);\n    \n    // Height falloff\n    float height = smoothstep(1.0, 3.0, p.y) * smoothstep(5.0, 3.0, p.y);\n    density *= height;\n    \n#ifdef HIGH_PERFORMANCE\n    density = smoothstep(0.3,0.6, density);\n#else\n    density = smoothstep(0.45,0.6, density);\n#endif\n    \n    return density;\n}\n\nvec3 getSkyColor(vec3 rd, vec3 sunDir) {\n    // Base sky colors\n    vec3 zenithColor = vec3(0.2, 0.4, 0.8);\n    vec3 horizonColor = vec3(0.8, 0.9, 1.0);\n    \n    float horizon = pow(1.0 - max(rd.y, 0.0), 2.0);\n    \n    float sunSpot = max(dot(rd, sunDir), 0.0);\n    float sunMask = pow(sunSpot, 32.0);\n    vec3 sun = vec3(1.0, 0.9, 0.7) * sunMask;\n    \n    return (mix(zenithColor, horizonColor, horizon) + sun) * 0.5;\n}\n\n// Turns out 1 cheap step towards the light produces reasonable results\nfloat sampleLight(int octaves, vec3 pos, vec3 sunDir, float blueNoise) {\n    vec3 lightPos = pos + sunDir; // Step size of 1\n    return sampleDensity(octaves, lightPos) * 2.0; // Step size of 1\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro;\n    vec3 rd;\n    getRoRd(fragCoord, iResolution.xy, iMouse, iTime, ro, rd);\n    \n    // Sun direction and color\n    vec3 sunDir = normalize(vec3(0.5, 0.2, -0.3));\n    \n    if(rd.y < 0.0) // Rays going down cant possibly hit the clouds\n    {\n        vec3 col = getSkyColor(rd, sunDir);\n        col.rgb = (col.rgb * (2.51 * col.rgb + 0.03)) / (col.rgb * (2.43 * col.rgb + 0.59) + 0.14);\n        col = pow(col, vec3(0.4545));\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    \n    // Raymarch parameters\n    const int MAX_STEPS = 64;\n    const float MAX_DIST = 128.0;\n    float stepSize = MAX_DIST/float(MAX_STEPS);\n    \n    vec3 acc = vec3(0.0);\n    float totalDensity = 0.0;\n    \n    // Jitter start position with blue noise - https://www.shadertoy.com/view/tlySzR\n    ivec2 p = ivec2(fragCoord);\n    p = (p+iFrame*ivec2(113,127)) & 1023;\n    float blueNoise = texelFetch(iChannel0,p,0).x;\n    vec3 pos = ro + (rd * stepSize * blueNoise);\n    \n    // Main raymarch loop\n    for(int i = 0; i < MAX_STEPS; i++) {\n        // lod\n        float dist = (length(pos - ro) / MAX_DIST);\n        int octaves = int(ceil((1.0 - dist) * MAX_OCTAVES));\n        \n        float density = sampleDensity(octaves, pos) * stepSize;\n        \n        if(density > 0.025) {\n            totalDensity += density;\n            \n            float sunRayDensity = sampleLight(octaves, pos, sunDir, blueNoise);\n            vec3 inscatter = exp(-sunRayDensity) * density * vec3(1.0);\n            \n            acc += inscatter * exp(-totalDensity);\n        }\n        \n        pos += rd * (stepSize + (0.4 * (MAX_OCTAVES - float(octaves))));\n    }\n    \n    vec3 col = getSkyColor(rd, sunDir) + acc;\n    \n    // Tonemapping and gamma correction\n    col.rgb = (col.rgb * (2.51 * col.rgb + 0.03)) / (col.rgb * (2.43 * col.rgb + 0.59) + 0.14);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// MIT License\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    \n    vec4 color = vec4(0.0);\n    \n    float blurRadius = 2.0;\n    float samples = 0.0;\n    for(float x = -blurRadius; x <= blurRadius; x++) {\n        vec2 offset = vec2(x + 0.5, 0.0) * texelSize;\n        color += texture(iChannel0, uv + offset);\n        samples += 1.0;\n    }\n    \n    fragColor = color / samples;\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfyBWK","date":"1734449519","viewed":112,"name":"Simple Fast Clouds","username":"TheNuclearWolf","description":"Just playing around.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","noise","clouds","volumetric","blue"],"hasliked":0,"parentid":"","parentname":""}}