{"ver":"0.1","info":{"id":"WdjBW1","date":"1590316414","viewed":96,"name":"Old Clock","username":"karexy","description":"a simple clock","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","clock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define SEC_L .5\n#define SEC_W .005\n#define MIN_L .4\n#define MIN_W .007\n#define HR_L .25\n#define HR_W .01\n#define SCALE_D .45\n#define SCALE_W .01\n\n#define FLOAT_MAX 3.402823E+38\n#define HASHSCALE1 .1031\n\n#define AA 0.002\n\nvec3 backCol = vec3(.8, .9, .9);\nvec3 centerCol = vec3(0.4);\nvec3 secondCol = vec3(1., .5, .5);\nvec3 minuteCol = vec3(.5, .5, 1.);\nvec3 hourCol = vec3(.4, .8, .4);\nvec3 scaleCol = vec3(.4, .3, .1);\n\n// https://www.shadertoy.com/view/llGSzw\nfloat hash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nbool center(vec2 uv)\n{\n    return length(uv) < .02;\n}\n\nfloat dist(vec2 p, vec2 dir)\n{\n    dir = normalize(dir);\n    float proj = dot(p, dir);\n    float d = sqrt(dot(p, p) - proj * proj);\n    return proj < -0.05 ? FLOAT_MAX : d;\n}\n\nvec2 rad2dir(float rad)\n{\n    return vec2(sin(rad), cos(rad));\n}\n\nbool secondhand(vec2 uv, float rad)\n{\n    float delta = (floor(mod(iDate.w, 60.)) + pow(fract(mod(iDate.w, 60.)), 20.0)) / 30. * PI;\n    return length(uv) < SEC_L && dist(uv, rad2dir(delta)) < SEC_W;\n}\n\nbool minutehand(vec2 uv, float rad)\n{\n    float delta = mod(iDate.w, 3600.) / 1800. * PI;\n    return (length(uv) < MIN_L) && dist(uv, rad2dir(delta)) < MIN_W;\n}\n\nbool hourhand(vec2 uv, float rad)\n{\n    float delta = mod(iDate.w, 43200.) / 21600. * PI;\n    return (length(uv) < HR_L) && dist(uv, rad2dir(delta)) < HR_W;\n}\n\nvec3 backColor(vec2 fragCoord)\n{\n    uvec2 p = uvec2(fragCoord);\n    float hash = hash1( p.x + 1920U*p.y + (1920U*1080U));\n    \n    vec3 c = hash > .002 ? backCol : vec3(.5);\n    return c;\n}\n\nbool scale(vec2 uv, float rad)\n{\n    float rad01 = rad / 2. / PI;\n    float f = floor(rad01 * 12.) / 12.;\n    vec2 dir = rad2dir(f * 2. * PI);\n    float d = dist(uv, dir);\n    return d < SCALE_W && d < FLOAT_MAX && length(uv) > (SCALE_D + .5 * (.5 - abs(uv.y)));\n}\n\nvec3 clock(vec2 uv, vec2 fragCoord)\n{\n    vec2 up = vec2(0., 1.);\n    float rad = acos(dot(normalize(uv), up));\n    rad = (uv.x <= 0. ? (2. * PI - rad) : rad);\n    \n\tif (center(uv))\n    {\n        return centerCol;\n    }\n    else if (secondhand(uv, rad))\n    {\n        return secondCol;\n    }\n    else if (minutehand(uv, rad))\n    {\n        return minuteCol;\n    }\n    else if (hourhand(uv, rad))\n    {\n        return hourCol;\n    }\n    else if (scale(uv, rad))\n    {\n        return scaleCol;\n    }\n    \n\treturn backColor(fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y - vec2(.5 * iResolution.x / iResolution.y, .5);\n    vec3 right = clock(uv + vec2(AA, 0), fragCoord);\n    vec3 left = clock(uv + vec2(-AA, 0), fragCoord);\n    vec3 up = clock(uv + vec2(0, AA), fragCoord);\n    vec3 down = clock(uv + vec2(0, -AA), fragCoord);\n    vec3 clockCol = 0.5 * clock(uv, fragCoord) + 0.125 * (right + left + up + down);\n    \n    fragColor = vec4(clockCol, 1.);\n}","name":"Image","description":"","type":"image"}]}