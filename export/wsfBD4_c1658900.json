{"ver":"0.1","info":{"id":"wsfBD4","date":"1592661461","viewed":258,"name":"Tile Map Shapes","username":"spalmer","description":"A simple scrolling tile map, maybe some sprites, from font texture atlas sdf, basically a 2D version of [url]https://shadertoy.com/view/wdsfWn[/url]\ncan scroll with arrows","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["2d","retro","text","console"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D-ified version of Alphabet Blocks https://shadertoy.com/view/WslBWH\n// but is also similar in nature to a 2D variant of Voxel Cube Shapes\n\n// now has SDF shapes in the square cells,\n// as tile instances.  The shapes are all\n// simply font glyphs, since that is\n// about all I had to work with.\n// So they won't look like squares at all, probably.\n// Looks like an old-school text console!\n// Replace Font texture with some other tileset.\n\n// TODO stress test the antialiasing under different scalings\n\n// TODO should be able to extract particular glyphs\n// for use as scaled, rotated sprites\n\n// TODO should offer option to reduce apparent\n// resolution of the font glyphs, convert to\n// a more stylized 8-bit look.  For certain\n// usage scenarios.  Idk if I personally need it rn.\n\n#define Font iChannel3\n\nconst float border = .02;\n\nconst float tiling = 12.;\n\n// uses the sdf encoded in font alpha channel\nfloat tex(vec2 uv, vec2 subuv)\n{\n    float fd = texture(Font, uv).a - .5; // 'texture' unorm sdf in w\n   #if 0 \n    // border\n     float bd = .5 - border - max(abs(.5-subuv.x), abs(.5-subuv.y));\n     fd = min(fd, bd);\n   #endif\n    return fd;\n}\n\n// deconstruction of hit point to obtain uvs for the \n// letters of font texture in iChannel3 which are \n// 16x16 layout glyphs, 64x64 texel cells\nfloat alphatex(vec2 subuv, ivec2 cell)\n{\n    vec2 atlas = subuv;\n   #if 0 \n    // inset\n    atlas = mix(atlas, vec2(.5), -border);\n    atlas = clamp(atlas, 0., 1.); // can help certain cases but if it clamps into the shape, does weird stuff!\n   #endif\n    atlas += vec2(cell);\n    atlas /= 16.; // because Font texture is 16x16 grid of cells\n    return tex(atlas, subuv);\n}\n\nfloat textureAtlas(vec2 uv, int hitid)\n{\n    return alphatex(uv, ivec2(hitid, hitid >> 4) & 15);\n    // TODO various symmetry modes to extend the available shapes\n    // simple extrusions, lathes on various axes, vary orientation, etc.\n    // kind of limited in 2D though.\n}\n\nfloat shape(vec2 q, int id)\n{\n    int i15 = id & 15, i255 = id & 255, i3 = (id >> 8) & 3;\n    if (i255 == 0)\n    return max(abs(q.x),abs(q.y)) - .485; //.475; // filled with boxes lol\n    if (i255 == 32)\n\treturn (length(q) - .488) * 1.; // every cell has a sphere inscribed\n    //float flite;\n    vec2 uvw = q + .5;\n    // TODO refactor all these into different styles that may be applied to any glyph\n    // using the high bits as style bits? somehow?\n//    if (i3 == 1) uvw = uvw.yx;\n    //if (i15 == 9)\n    //uvw = vec3(uvw.x, .5, .5 - min(.5, length(uvw.zy-.5))); // lathe lower half horizontally?\n    if ((i3 & 1) != 0) uvw.x = 1.-uvw.x;\n    if ((i3 & 2) != 0) uvw.y = 1.-uvw.y;\n    // all of the lathes must clamp the resulting length\n    float d = textureAtlas(uvw.xy, id);\n    return d;\n}\n// for helping combine lod's, probably broken atm, not used anyhow\n/*\nfloat dlod(ivec2 i, vec2 o)\n{\n    return isVoxel(i)\n        ? max(abs(o.x),abs(o.y)) - .5\n        : 1.5;\n}\n*/\n\nfloat Scene(vec2 p)\n{\n    vec2 f;\n    ivec2 i = voxid(p);\n    if (!isVoxel(i)) {\n        return 3.4e38; // HACK simply ignore neighbors in 2D\n        //float dmin = 3.4e38;\n        // basic 3x3 kerning, inefficient\n        // allows shapes to butt right up\n        // against the edge of their cells\n        // without causing neighboring cell\n        // signed distance artifacts.\n        // the per-tile coloration isn't\n        // considered here though FIXME\n        // so we couldn't get away with poofing\n        // them much anyway.  And without\n        // any other need for it, in 2D, this\n        // loop is really just unnecessary.\n        //for (int y = -1; y <= 1; ++y)\n        //    for (int x = -1; x <= 1; ++x)\n        //        dmin = min(dmin, dlod(i+ivec2(x,y), p-vec2(x,y)));\n        //return dmin;\n    }\n\tf = p - voxpos(i); // relative to closest cell\n    int id = ComputeHitId(i);\n    return shape(f, id);\n}\n\n/* // not lit yet\nvec2 SceneNormal(vec2 p, float h, out float d)\n{\n    vec2 n = vec2(\n          Scene(p + vec2(h,0))\n        , Scene(p + vec2(0,h))\n      ) - (d = Scene(p));\n    if (dot(n,n) < 1e-7) n = vec2(0,1);\n    else n = normalize(n);\n    return n;\n} */\n\nvec3 hue(float x)\n{\n    return cos(vec3(0,2,4) + x * phi * tau) * .5 + .5;\n}\n\nvec3 Render(vec2 p)\n{\n    State state;\n    vec2 r = iResolution.xy;\n    //ivec2 i = ivec2(p);\n    LoadState(state, BufA, ivec2(r));\n    vec2 q = (2. * p - r) / r.y; // center in window\n    q += state.eyepos;\n    q *= tiling;\n\tfloat d = Scene(q);\n    ivec2 qi = voxid(q);\n    vec3 bg = vec3(0);\n    // add round boxes\n    if (isVoxel(qi)) {\n        vec2 qf = q - vec2(qi);\n        const float gap = .04;\n        vec2 s = abs(qf - .5) - .5;\n        const float poof = .125;\n        vec2 a = s + poof + gap;\n        float bd = any(lessThan(a, vec2(0))) ? max(a.x, a.y) : length(a);\n        bd -= poof;\n        //bd = length(qf - .5) - .5 + gap; // disc\n        float bc = clamp(.5 - .5*r.y*bd/tiling, 0., 1.);\n        bg = mix(bg, vec3(.05), bc);\n    }\n    int id = qi.x * 6 + qi.y * 31;\n    float cov = clamp(.5 - .5*r.y*d/tiling, 0., 1.);\n    return mix(bg, hue(float(id) * phi), cov);\n}\n\n#define BluNoiz iChannel1\n#define BNzRes iChannelResolution[1]\n\nfloat bluenoise(vec2 p)\n{\n\treturn fetch(BluNoiz, ivec2(p) & ivec2(BNzRes-1.)).x;\n}\n\nfloat Dither(vec2 p)\n{\n    // use blue noise texture in iChannel1\n    return bluenoise(p);\n    // lame white noise\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec3 c = Render(p);\n    c = pow(c, vec3(.4545)); // sRGB gamut\n    c += .6 / 256. * Dither(p);\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define IZERO min(iFrame, 0)\n\nconst float \n  tau = 2. * acos(-1.) //6.28318531 //\n, phi = (sqrt(5.)+1.)*.5\n, voxtile = 8.\n;\n\n// TODO should be a stored tile map somehow\nfloat overallShape(vec2 q)\n{\n    q -= .5; // centers these shapes on the voxel grid cell centers\n    float dplane = q.y + 10.;\n    float dwaves = dplane + 5. * sin(.1*q.x);\n    vec2 pt = q - vec2(24,0);\n    float dtorus = abs(length(pt)-6.) - 1.5; // circle/ring\n    q = abs(q);\n    q.x = max(0., q.x-6.); // rod \n    float dcapsule = length(q) - 2.5; // poof to capsule\n    return min(dwaves, min(dtorus, dcapsule));\n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec2 eyepos;\n};\n\nconst int\n  slotResolution = 0\n, slotEyePos     = 1\n, slotCount      = 2\n;\n\n// measure offsets *backward* from R = ivec2(iResolution), \n// so slotResolution actually goes at R-1\n// slotCamPos goes at R - 1 - ivec2(1,0) etc.\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePos].xy;\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePos:\n        c.xy = state.eyepos;\n        break;\n      default:\n        break;\n    }\n}\n\nvec2 voxpos(ivec2 i)\n{\n    return vec2(i) + .5;\n}\n     \nbool isVoxel(ivec2 i)\n{\n\treturn overallShape(voxpos(i)) < 0.;\n}\n\nivec2 voxid(vec2 p)\n{\n    return ivec2(floor(p));\n}\n\nint ComputeHitId(ivec2 qi)\n{\n\treturn ((qi.x^(qi.y*3))*123) % 65536 ^ 0xaaaa;\n}\n\nint ComputeHitId(vec2 q)\n{\n\treturn ComputeHitId(voxid(q));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from Fly Camera at https://shadertoy.com/view/tdsfR4\n// a simple 2D panning, scrolling camera\n\n// TODO put a console text buffer in BufferA somewhere\n\n#define Kbd  iChannel3\n\nconst float \n  eyeradius = .25\n, eyespeed = 10.\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n;\n\nstruct Inputs\n{\n    vec2 move;\n    vec2 mouse;\n    bool button;\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n// key bindings to local directions\n#if 1 \n    // arrows\n, KEY_LF    = KEY_LEFT\n, KEY_RT    = KEY_RIGHT\n, KEY_FW    = KEY_UP\n, KEY_BW    = KEY_DOWN\n#else \n    // QWERTY WASD\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    if (iMouse.xyz == vec3(0)) // icon?\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    inp.move = vec2(key(KEY_RT) - key(KEY_LF)\n                  , key(KEY_FW) - key(KEY_BW));\n    inp.dt = iTimeDelta;\n}\n\n\nvec2 MoveCamera(State state, Inputs inp) \n{\n    vec2 op = state.eyepos;\n    float d, spd = eyespeed;\n    vec2 move = inp.move * inp.dt * spd \n    , p = op + move\n    ;\n    return p;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec2(0,0);\n    } else { // update state\n\t    state.eyepos = MoveCamera(state, inp);\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n\n// unfortunately I cannot reset iMouse, \n// so when one resets the toy, \n// it will still be where last clicked!\n// luckily this 2D toy doesn't use the mouse at all\n\n","name":"Buffer A","description":"","type":"buffer"}]}