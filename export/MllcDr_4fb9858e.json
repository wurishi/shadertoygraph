{"ver":"0.1","info":{"id":"MllcDr","date":"1516285409","viewed":383,"name":"RayTracinginOneWeekend","username":"neog","description":"Ray Tracing in One Weekend ( https://www.amazon.co.jp/Tracing-Weekend-Minibooks-Book-English-ebook/dp/B01B5AODD8 )\nGLSL implementation","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere{\n    vec3 center;\n    vec3 albedo;\n    float radius;\n    float fuzz;\n    int kind;\n};\n    \nstruct HitRecord {\n    vec3 p;\n    vec3 normal;\n    vec3 albedo;\n    float t;\n    float fuzz;\n    int kind;\n};\n\nstruct Camera {\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    float lensRadius;\n};\n\n#define M_PI 3.1415926535897932384626433832795\n#define DEFOCUS 0\n#define BOUNCES 10\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat schlick(float cosine, float refractiveIndex) {\n    float r0 = (1.0 - refractiveIndex) / (1.0 + refractiveIndex);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0)*pow(1.0 - cosine, 5.0);\n}\n\nvec3 randomInUnitSphere(vec2 uv) {\n    vec3 p;\n    float l = rand(uv);\n    float radianA = 2.0*M_PI*rand(uv + vec2(1.0/iResolution.x, 0.0));\n    float radianB = M_PI*(rand(uv + vec2(0.0, 1.0/iResolution.y)) - 0.5);\n    return l*vec3(cos(radianA)*cos(radianB), sin(radianA)*cos(radianB), sin(radianB));\n}\n\nvec3 randomInUnitDisk(vec2 uv) {\n    float l = rand(uv);\n    float radian = 2.0*M_PI*rand(uv + vec2(1.0/iResolution.x, 1.0/iResolution.y));\n    return l * vec3(cos(radian), sin(radian), 0.0);\n}\n\n// https://github.com/LWJGL/lwjgl3-demos/blob/master/res/org/lwjgl/demo/opengl/raytracing/randomCommon.glsl\nvec3 randomCosineWeightedHemispherePoint(vec3 rand, vec3 n) {\n  float r = rand.x * 0.5 + 0.5; // [-1..1) -> [0..1)\n  float angle = (rand.y + 1.0) * M_PI; // [-1..1] -> [0..2*PI)\n  float sr = sqrt(r);\n  vec2 p = vec2(sr * cos(angle), sr * sin(angle));\n  /*\n   * Unproject disk point up onto hemisphere:\n   * 1.0 == sqrt(x*x + y*y + z*z) -> z = sqrt(1.0 - x*x - y*y)\n   */\n  vec3 ph = vec3(p.xy, sqrt(1.0 - p*p));\n  /*\n   * Compute some arbitrary tangent space for orienting\n   * our hemisphere 'ph' around the normal. We use the camera's up vector\n   * to have some fix reference vector over the whole screen.\n   */\n  vec3 tangent = normalize(rand);\n  vec3 bitangent = cross(tangent, n);\n  tangent = cross(bitangent, n);\n  \n  /* Make our hemisphere orient around the normal. */\n  return tangent * ph.x + bitangent * ph.y + n * ph.z;\n}\n\nCamera createCamera(vec3 lookFrom, vec3 lookAt, vec3 vUp, float vFov, float aspect) {\n    float theta = vFov * M_PI / 180.0;\n    float halfHeight = tan(theta/2.0);\n    float halfWidth = aspect * halfHeight;\n    Camera camera;\n    camera.w = normalize(lookFrom - lookAt);\n    camera.u = normalize(cross(vUp, camera.w));\n    camera.v = cross(camera.w, camera.u);\n  \tcamera.origin = lookFrom;\n  \tcamera.lowerLeftCorner = camera.origin - halfWidth*camera.u - halfHeight*camera.v - camera.w;\n    camera.horizontal = 2.0*halfWidth*camera.u;\n  \tcamera.vertical = 2.0*halfHeight*camera.v;\n    camera.lensRadius = 1.0;\n  \treturn camera;\n}\n\nCamera createCamera(vec3 lookFrom, vec3 lookAt, vec3 vUp, float vFov, float aspect, float aperture, float focusDistance) {\n    float theta = vFov * M_PI / 180.0;\n    float halfHeight = tan(theta/2.0);\n    float halfWidth = aspect * halfHeight;\n    Camera camera;\n    camera.lensRadius = aperture / 2.0;\n    camera.w = normalize(lookFrom - lookAt);\n    camera.u = normalize(cross(vUp, camera.w));\n    camera.v = cross(camera.w, camera.u);\n  \tcamera.origin = lookFrom;\n  \tcamera.lowerLeftCorner = camera.origin - halfWidth*focusDistance*camera.u - halfHeight*focusDistance*camera.v - focusDistance*camera.w;\n    camera.horizontal = 2.0*halfWidth*focusDistance*camera.u;\n  \tcamera.vertical = 2.0*halfHeight*focusDistance*camera.v;\n  \treturn camera;\n}\n\nRay getRay(Camera camera, vec2 uv) {\n  \tRay ray;\n  \tray.origin = camera.origin;\n  \tray.direction = camera.lowerLeftCorner + uv.x*camera.horizontal + uv.y*camera.vertical - camera.origin;\n    return ray;\n}\n\nRay getRayDefocusBlur(Camera camera, vec2 uv) {\n    vec3 randomVec = camera.lensRadius*randomInUnitDisk(uv);\n    vec3 offset = camera.u * randomVec.x + camera.v * randomVec.y;\n  \tRay ray;\n  \tray.origin = camera.origin + offset;\n  \tray.direction = camera.lowerLeftCorner + uv.x*camera.horizontal + uv.y*camera.vertical - camera.origin - offset;\n    return ray;\n}\n\nconst int numberOfSpheres = 4;\n\nvec3 positionOfRay(in Ray ray, in float t) {\n    return ray.origin + ray.direction*t;\n}\n\nvec3 reflectRayDirection(vec3 direction, vec3 normal) {\n    return direction - 2.0*dot(direction, normal)*normal;\n}\n\nbool refractRayDirection(vec3 direction, vec3 normal, float niOverNt, out vec3 refractDirection) {\n    float dt = dot(direction, normal);\n    float discriminant = 1.0 - niOverNt*niOverNt*(1.0 - dt*dt);\n    if (discriminant > 0.0) {\n        refractDirection = niOverNt*(direction - normal*dt) - normal*sqrt(discriminant);\n\t    return true;\n    }\n    else {\n        return false;\n    }\n}\n\nbool hit(in Sphere sphere, in Ray ray, in float tMin, in float tMax, out HitRecord record) {\n    vec3 originToCenter = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(originToCenter, ray.direction);\n    float c = dot(originToCenter, originToCenter) - sphere.radius*sphere.radius;\n    float discriminant = b*b - 4.0*a*c;\n    \n    if ( discriminant > 0.0 ) {\n        float temp = (-b -sqrt(discriminant) ) / (2.0*a);\n        if ( temp < tMax && temp > tMin ) {\n            record.t = temp;\n            record.p = positionOfRay(ray, record.t);\n            record.normal = (record.p - sphere.center) / sphere.radius;\n            record.kind = sphere.kind;\n            record.albedo = sphere.albedo;\n            record.fuzz = sphere.fuzz;\n            return true;\n        }\n        temp = (-b + sqrt(discriminant) ) / (2.0*a);\n        if ( temp < tMax && temp > tMin ) {\n            record.t = temp;\n            record.p = positionOfRay(ray, record.t);\n            record.normal = (record.p - sphere.center) / sphere.radius;\n            record.kind = sphere.kind;\n            record.albedo = sphere.albedo;\n            record.fuzz = sphere.fuzz;\n\t        return true;\n        }\n    }\n    \n    return false;\n}\n\nbool checkSpheres(in Ray ray, out HitRecord record, in Sphere spheres[numberOfSpheres]) {\n    bool bHit = false;\n    float tMax = 1000.0;\n    for ( int i = 0; i < numberOfSpheres; i++ ) {\n        if ( hit(spheres[i], ray, 0.001, tMax, record) ) {\n            tMax = record.t;\n            bHit = true;\n        }\n    }\n    return bHit;\n}\n\nbool calculateRay(in HitRecord record, in Ray rayIn, in float randomSeed, in vec2 uv, out Ray rayOut, out vec3 attenuation) {\n    float r = rand(uv + vec2(0.0, 1.0/iResolution.y)*randomSeed);\n    vec3 inputDirection = normalize(rayIn.direction);\n   \tvec3 reflected = reflectRayDirection(inputDirection, record.normal );\n    rayOut.origin = record.p;\n    if ( record.kind == 0 ) {\n        // Lambertian\n    \tfloat r0 = 2.0*rand(uv + vec2(1.0/iResolution.x, 0.0)) - 1.0;\n    \tfloat r1 = 2.0*rand(uv + vec2(0.0, 1.0/iResolution.y)) - 1.0;\n    \tfloat r2 = 2.0*rand(uv) - 1.0;\n\t    vec3 randomVec = vec3(r0, r1, r2);\n        rayOut.direction = normalize(randomCosineWeightedHemispherePoint(randomVec, normalize(record.normal)));\n        attenuation = record.albedo;\n        return true;\n    } else if ( record.kind == 1 ) {\n        // metal\n\t    vec3 randomVec = randomInUnitSphere(uv + vec2(0.0, 1.0/iResolution.y)*randomSeed);\n        rayOut.direction = normalize(reflected + record.fuzz*randomVec);\n        attenuation = record.albedo;\n        return dot(rayOut.direction, record.normal) > 0.0;\n    } else {\n        // dielectric\n        float niOverNt = 1.0;\n        vec3 outwardNormal = vec3(0.0, 0.0, 0.0);\n        float reflectionProbability = 0.0;\n        float cosine = 0.0;\n        if ( dot ( inputDirection, record.normal ) > 0.0 ) {\n            outwardNormal = -record.normal;\n            niOverNt = record.fuzz;\n            cosine = record.fuzz * dot(inputDirection, record.normal);\n        }\n        else {\n            outwardNormal = record.normal;\n            niOverNt = 1.0 / record.fuzz;\n            cosine = -dot(inputDirection, record.normal);\n        }\n        \n        vec3 refracted;\n        if (refractRayDirection(inputDirection, outwardNormal, niOverNt, refracted)) {\n            reflectionProbability = schlick(cosine, record.fuzz);\n        \tif (r > reflectionProbability) {\n        \t\trayOut.direction = refracted;\n            } else {\n                rayOut.direction = reflected;\n            }\n        } else {\n\t        rayOut.direction = reflected;\n        }\n        \n        attenuation = vec3(1.0, 1.0, 1.0);\n        return true;\n    }\n}\n\nvec3 calculateColorMultipleBounces(in Ray firstRay, in vec2 uv, in Sphere spheres[numberOfSpheres]) {\n    HitRecord record;\n    bool bHit = true;\n    vec3 result = vec3(1.0, 1.0, 1.0);\n    Ray rayIn = firstRay;\n    Ray rayOut = firstRay;\n    int counter = 0;\n    for ( int b = 0; b < BOUNCES; b++) {\n        rayIn = rayOut;\n        if ( checkSpheres(rayIn, record, spheres) ) {\n            float randomSeed = float(b) / float(BOUNCES);\n            vec3 attenuation = vec3(1.0, 1.0, 1.0);\n            if ( !calculateRay(record, rayIn, randomSeed, uv, rayOut, attenuation) ) {\n                result = vec3(0.0, 0.0, 0.0);\n                break;\n            }\n           \tresult *= attenuation;\n        } else {\n            vec3 normalizedDirection = normalize(rayIn.direction);\n            float t = 0.5*(normalizedDirection.y + 1.0);\n            vec3 attenuation = (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n\t        result *= attenuation;\n            break;\n        }\n        counter++;\n    }\n    \n    if ( counter == BOUNCES ) {\n        result = vec3(0.0, 0.0, 0.0);\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  \tvec2 uv = fragCoord.xy/iResolution.xy;\n#if DEFOCUS\n    float radius = 5.0;\n    vec3 lookAt = vec3(0.0, 0.0, -1.0);\n    vec3 lookFrom = lookAt + vec3(radius*cos(1.0), 2.0, radius*sin(1.0));    \n    float distanceToFocus = length(lookAt - lookFrom);\n    float aperture = 8.0;\n    Camera camera = createCamera(lookFrom, lookAt, vec3(0.0, 1.0, 0.0), 20.0, float(iResolution.x)/float(iResolution.y), aperture, distanceToFocus);\n#else\n    float radius = 5.0 + 2.0*sin(iTime);\n    vec3 lookAt = vec3(0.0, 0.0, -1.0);\n    vec3 lookFrom = lookAt + vec3(radius*cos(iTime), 2.0, radius*sin(iTime));\n    Camera camera = createCamera(lookFrom, lookAt, vec3(0.0, 1.0, 0.0), 25.0, float(iResolution.x)/float(iResolution.y));\n#endif\n    const int sampleCount = 60;\n    vec3 color = vec3(0.0);\n    \n    Sphere spheres[numberOfSpheres];\n    spheres[0].center = vec3(0.0, 0.0, -1.0);\n    spheres[0].radius = 0.5;\n    spheres[0].albedo = vec3(0.1, 0.2, 0.5);\n    spheres[0].fuzz = 1.0;\n    spheres[0].kind = 0;\n    spheres[1].center = vec3(0.0, -100.5, -1.0);\n    spheres[1].radius= 100.0;\n    spheres[1].albedo = vec3(0.8, 0.8, 0.0);\n    spheres[1].fuzz = 1.0;\n    spheres[1].kind = 0;\n    spheres[2].center = vec3(1.0, 0.0, -1.0);\n    spheres[2].radius = 0.5;\n    spheres[2].albedo = vec3(0.8, 0.6, 0.2);\n    spheres[2].kind = 1;\n    spheres[2].fuzz = 1.0;\n    spheres[3].center = vec3(-1.0, 0.0, -1.0);\n    spheres[3].radius = 0.5;\n    spheres[3].albedo = vec3(0.8, 0.8, 0.8);\n    spheres[3].fuzz = 1.5;\n    spheres[3].kind = 2;\n#if 0\n    spheres[4].center = vec3(-1.0, 0.0, -1.0);\n    spheres[4].radius= -0.45;\n    spheres[4].albedo = vec3(0.8, 0.8, 0.0);\n    spheres[4].fuzz = 1.5;\n    spheres[4].kind = 2;\n#endif\n    \n    for ( int s = 0; s < sampleCount; s++) {\n        float randomSeed = float(s) / float(sampleCount);\n        vec3 randomVec = randomInUnitDisk(uv + vec2(1.0/iResolution.x, 0.0)*randomSeed);\n        float u = uv.x + randomVec.x / iResolution.x;\n        float v = uv.y + randomVec.y / iResolution.y;\n#if DEFOCUS\n    \tRay ray = getRayDefocusBlur(camera, vec2(u,v));\n#else\n    \tRay ray = getRay(camera, vec2(u,v));\n#endif\n        HitRecord record;\n\t  \tcolor += calculateColorMultipleBounces(ray, vec2(u,v), spheres);\n    }\n    color /= float(sampleCount);\n    color = sqrt(color);\n  \tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}