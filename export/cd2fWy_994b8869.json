{"ver":"0.1","info":{"id":"cd2fWy","date":"1690092346","viewed":103,"name":"Monte-carlo raytracing","username":"lucasQAQ","description":"none","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","raymarching","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: SWS3005_12\n//\n// GROUP NUMBER: 12\n//\n// STUDENT NAME: HU ZHANPENG\n// NUS User ID.: t0930152\n//\n// STUDENT NAME: NING JUNTING\n// NUS User ID.: t0930085\n//\n// STUDENT NAME: LUO TANGWEN\n// NUS User ID.: t0930258\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\nconst int SAMPLES_PER_PIXEL = 1;// add spp to reduce noise\nconst float PI = 3.1415926536;\nconst int BOUNCES = 3;\nconst float P_TERMINATE = 0.75;\nconst float EPSILON = 0.01;\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n// sRGB, linear space conversions\n#define stol1(x) (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4))\n#define stol3(x, y, z) vec3(stol1(x), stol1(y), stol1(z))\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\nfloat seed = 1.0; //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 3;\nconst int NUM_MATERIALS = 16;\nconst int NUM_SPHERES = 22;\nconst int NUM_CUBES = 17;\nconst int NUM_PLANES = 5;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n    float t; // Length of Ray.\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookat;\n    vec3 axis[3]; // x,y,z\n};\n\nstruct Material_t {\n    vec3 albedo;\n    float roughness;\n    float metalness;\n    vec3 emission;\n};\n\nstruct Hit {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    int MaterialID;\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\n\nstruct Cube_t {\n    vec3 center;\n    int materialID;\n    vec3 size;\n};\n\n\nstruct Light_t {\n    mat4 worldMat;\n    vec2 size;\n    vec3 E;\n    vec3 normal;\n};\n//============================================================================\n// Global scene data.\n//============================================================================\n\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCube_t Cube[NUM_CUBES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nCamera camera;\n\nvoid InitPlane() {\n    \n    // Bottom Plane\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 9.65;\n    Plane[0].materialID = 12;\n    \n    // Left Plane\n    Plane[1].A = -1.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 0.0;\n    Plane[1].D = 30.0;\n    Plane[1].materialID = 10;\n    \n    // Right Plane\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 30.0;\n    Plane[2].materialID = 10;\n    \n    // Front Plane\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = -1.0;\n    Plane[3].D = 25.0;\n    Plane[3].materialID = 10;\n    \n    // Back Plane\n    Plane[4].A = 0.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 1.0;\n    Plane[4].D = 25.0;\n    Plane[4].materialID = 10;\n}\n\nvoid InitBall() {\n    float timeBias = 0.06;\n    \n    // Black Ball\n    Sphere[0].center = vec3(-15.0, 0.5 + 2.0 * abs(cos(5.0 * iTime)), 0.0);\n    Sphere[0].radius = 0.5;\n    Sphere[0].materialID = 0;\n    \n\n    // Red Ball * 15\n    for (int i = 1; i <= 15; i++) {\n        Sphere[i].radius = 0.5;\n        Sphere[i].materialID = 1;\n    }\n    float time = iTime;\n    Sphere[1].center = vec3(-12.0, 0.5 + 2.0 * abs(cos(5.0 * (iTime + timeBias))), 2.0);\n    \n    Sphere[2].center = vec3(-12.0, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 2.0 * timeBias))), 1.0);\n    \n    Sphere[3].center = vec3(-12.0, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 3.0 * timeBias))), 0.0);\n    \n    Sphere[4].center = vec3(-12.0, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 4.0 * timeBias))), -1.0);\n    \n    Sphere[5].center = vec3(-12.0, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 5.0 * timeBias))), -2.0);\n    \n    Sphere[6].center = vec3(-11.13, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 6.0 * timeBias))), 1.5);\n    \n    Sphere[7].center = vec3(-11.14, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 7.0 * timeBias))), 0.5);\n    \n    Sphere[8].center = vec3(-11.14, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 8.0 * timeBias))), -0.5);\n    \n    Sphere[9].center = vec3(-11.14, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 9.0 * timeBias))), -1.5);\n    \n    Sphere[10].center = vec3(-10.26, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 10.0 * timeBias))), 1.0);\n    \n    Sphere[11].center = vec3(-10.28, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 11.0 * timeBias))), 0.0);\n    \n    Sphere[12].center = vec3(-10.28, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 12.0 * timeBias))), -1.0);\n    \n    Sphere[13].center = vec3(-9.39, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 13.0 * timeBias))), 0.5);\n    \n    Sphere[14].center = vec3(-9.39, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 14.0 * timeBias))), -0.5);\n    \n    Sphere[15].center = vec3(-8.52, 0.5 + 2.0 * abs(cos(5.0 * (iTime + 15.0 * timeBias))), 0.0);\n    \n\n    // Purple Ball\n    Sphere[16].center = vec3(-7.52, 0.5 + 2.0 * abs(sin(5.0 * iTime)), 0.0);\n    Sphere[16].radius = 0.5;\n    Sphere[16].materialID = 2;\n    \n    \n    // Blue Ball\n    Sphere[17].center = vec3(0.0, 0.5, 0.0);\n    Sphere[17].radius = 0.5;\n    Sphere[17].materialID = 3;\n    \n\n    // Green Ball\n    Sphere[18].center = vec3(11.0, 0.5, 2.5);\n    Sphere[18].radius = 0.5;\n    Sphere[18].materialID = 4;\n    \n    \n    // Brown Ball\n    Sphere[19].center = vec3(11.0, 0.5, 0.0);\n    Sphere[19].radius = 0.5;\n    Sphere[19].materialID = 5;\n    \n\n    // Yellow Ball\n    Sphere[20].center = vec3(11.0, 0.5, -2.5);\n    Sphere[20].radius = 0.5;\n    Sphere[20].materialID = 6;\n    \n\n    // White Ball\n    Sphere[21].center = vec3(-4.0, 0.5, 6.0);\n    Sphere[21].radius = 0.5;\n    Sphere[21].materialID = 7;\n\n}\n\nvoid InitCube() {\n    // Back Left Baffle\n    Cube[0].center = vec3(-8.75, 0.38, -9.6);\n    Cube[0].size = vec3(16.3, 0.76, 1.2);\n    Cube[0].materialID = 9;\n    \n    // Back Right Baffle\n    Cube[1].center = vec3(8.75, 0.38, -9.6);\n    Cube[1].size = vec3(16.3, 0.76, 1.2);\n    Cube[1].materialID = 9;\n    \n    // Front Left Baffle\n    Cube[2].center = vec3(-8.75, 0.38, 9.6);\n    Cube[2].size = vec3(16.3, 0.76, 1.2);\n    Cube[2].materialID = 9;\n    \n    // Front Right Baffle\n    Cube[3].center = vec3(8.75, 0.38, 9.6);\n    Cube[3].size = vec3(16.3, 0.76, 1.2);\n    Cube[3].materialID = 9;\n    \n    // Left Baffle\n    Cube[4].center = vec3(-18.6, 0.38, 0.0);\n    Cube[4].size = vec3(1.2, 0.76, 15.8);\n    Cube[4].materialID = 9;\n    \n    // Right Baffle\n    Cube[5].center = vec3(18.6, 0.38, 0.0);\n    Cube[5].size = vec3(1.2, 0.76, 15.8);\n    Cube[5].materialID = 9;\n    \n    // Table Plane\n    Cube[6].center = vec3(0.0, -0.05, 0.0);\n    Cube[6].size = vec3(36.0, 0.1, 18.0);\n    Cube[6].materialID = 8;\n    \n    // Hole Plane\n    Cube[7].center = vec3(0.0, -0.15, 0.0);\n    Cube[7].size = vec3(38.4, 0.1, 20.4);\n    Cube[7].materialID = 13;\n    \n    // Second Plane\n    Cube[8].center = vec3(0.0, -1.7, 0.0);\n    Cube[8].size = vec3(39.2, 3.0, 21.2);\n    Cube[8].materialID = 14;\n    \n    // Front Fence\n    Cube[9].center = vec3(0.0, 0.28, 10.4);\n    Cube[9].size = vec3(39.2, 0.96, 0.4);\n    Cube[9].materialID = 9;\n    \n    // Back Fence\n    Cube[10].center = vec3(0.0, 0.28, -10.4);\n    Cube[10].size = vec3(39.2, 0.96, 0.4);\n    Cube[10].materialID = 9;\n    \n    // Left Fence\n    Cube[11].center = vec3(-19.4, 0.28, 0.0);\n    Cube[11].size = vec3(0.4, 0.96, 20.4);\n    Cube[11].materialID = 9;\n    \n    // Right Fence\n    Cube[12].center = vec3(19.4, 0.28, 0.0);\n    Cube[12].size = vec3(0.4, 0.96, 20.4);\n    Cube[12].materialID = 9;\n    \n    // First Leg\n    Cube[13].center = vec3(-18.15, -6.4, 9.15);\n    Cube[13].size = vec3(2.5, 6.4, 2.5);\n    Cube[13].materialID = 15;\n    \n    // Second Leg\n    Cube[14].center = vec3(18.15, -6.4, 9.15);\n    Cube[14].size = vec3(2.5, 6.4, 2.5);\n    Cube[14].materialID = 15;\n    \n    // Third Leg\n    Cube[15].center = vec3(-18.15, -6.4, -9.15);\n    Cube[15].size = vec3(2.5, 6.4, 2.5);\n    Cube[15].materialID = 15;\n    \n    // Fourth Leg\n    Cube[16].center = vec3(18.15, -6.4, -9.15);\n    Cube[16].size = vec3(2.5, 6.4, 2.5);\n    Cube[16].materialID = 15;\n}\n\n\nvoid InitLight() {\n    // Light 0\n    Light[0].worldMat = mat4(1, 0, 0, 0,\n                             0, 1, 0, 0,\n                             0, 0, 1, 0,\n                             0, 5, 0, 1);\n    Light[0].size = vec2(20);\n    Light[0].E = vec3(1, 1, 1) * vec3(3);\n    Light[0].normal = vec3(0, -1 ,0);\n    \n    // Light 1\n    Light[1].worldMat = mat4(1, 0, 0, 0,\n                             0, 1, 0, 0,\n                             0, 0, 1, 0,\n                             0, 100, 0, 1);\n    Light[1].size = vec2(20);\n    Light[1].E = vec3(1, 1, 1) * vec3(5);\n    Light[1].normal = normalize(vec3(0, -1, -1));\n    // Light 2\n    Light[2].worldMat = mat4(1, 0, 0, 0,\n                             0, 1, 0, 0,\n                             0, 0, 1, 0,\n                             0, 20, -20, 1);\n    Light[2].size = vec2(2);\n    Light[2].E = vec3(1, 1, 1) * vec3(100);\n    Light[2].normal = normalize(vec3(0, -1, 1));\n\n\n}\nconst vec2 s = vec2(1, 1.7320508);\n\nfloat hex(in vec2 p){\n    p = abs(p);\n    return max(dot(p, s*.5), p.x);\n}\n\nvec4 getHex(vec2 p){\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1)); \n}\n\nfloat aafract(float x) {\n    float v = fract(x),\n          w = fwidth(x);\n    return v < 1.-w ? v/(1.-w) : (1.-v)/w;\n}\nvoid InitMaterial() {\n    \n    // Black Plastic Material\n    Material[0].albedo = vec3(0, 0, 0);\n    Material[0].roughness = 0.8;\n    Material[0].metalness = 0.2;\n    Material[0].emission = vec3(0.0);\n    // Red Plastic Material\n    Material[1].albedo = vec3(0.89, 0.09, 0.05);\n    Material[1].roughness = 0.8;\n    Material[1].metalness = 0.2;\n    Material[1].emission = vec3(0.0);\n    // Purple Plastic Material\n    Material[2].albedo = vec3(0.86, 0.44, 0.84);\n    Material[2].roughness = 0.8;\n    Material[2].metalness = 0.2;\n    Material[2].emission = vec3(0.0);\n    // Blue Plastic Material\n    Material[3].albedo = vec3(0.0, 0.0, 1.0);\n    Material[3].roughness = 0.8;\n    Material[3].metalness = 0.2;\n    Material[3].emission = vec3(0.0);\n    // Green Plastic Material\n    Material[4].albedo = vec3(0.13, 0.55, 0.13);\n    Material[4].roughness = 0.8;\n    Material[4].metalness = 0.2;\n    Material[4].emission = vec3(0.0);\n    // Brown Plastic Material\n    Material[5].albedo = vec3(0.78, 0.38, 0.08);\n    Material[5].roughness = 0.8;\n    Material[5].metalness = 0.2;\n    Material[5].emission = vec3(0.0);\n    // Yellow Plastic Material\n    Material[6].albedo = vec3(1.0, 1.0, 0.0);\n    Material[6].roughness = 0.4;\n    Material[6].metalness = 1.0;\n    Material[6].emission = vec3(0.0);\n    // White Plastic Material\n    Material[7].albedo = vec3(1.0, 1.0, 1.0);\n    Material[7].roughness = 0.8;\n    Material[7].metalness = 0.2;\n    Material[7].emission = vec3(0.0);\n    // Table Material\n    Material[8].albedo = vec3(0.02, 0.36, 0.04);\n    Material[8].roughness = 0.8;\n    Material[8].metalness = 0.5;\n    Material[8].emission = vec3(0.0);\n    // Baffle Material\n    Material[9].albedo = vec3(0.2, 0.05, 0.04);\n    Material[9].roughness = 0.8;\n    Material[9].metalness = 0.2;\n    Material[9].emission = vec3(0.0);\n    // Room Material\n    Material[10].albedo = vec3(1, 1, 1);\n    Material[10].roughness = 1.0;\n    Material[10].metalness = 0.2;\n    Material[10].emission = vec3(0.0);\n    // NUS Material\n    Material[11].albedo = vec3(0.0, 0.0, 0.6);\n    Material[11].roughness = 0.8;\n    Material[11].metalness = 0.2;\n    Material[11].emission = vec3(0.4);\n    // Floor Material\n    Material[12].albedo = vec3(1, 1, 1);\n    Material[12].roughness = 1.0;\n    Material[12].metalness = 0.2;\n    Material[12].emission = vec3(0.0);\n    // Hole Material\n    Material[13].albedo = vec3(0.02, 0.02, 0.02);\n    Material[13].roughness = 1.0;\n    Material[13].metalness = 0.0;\n    Material[13].emission = vec3(0.0);\n    // Second Plane Material\n    Material[14].albedo = vec3(0.95, 0.90, 0.2);\n    Material[14].roughness = 0.5;\n    Material[14].metalness = 0.6;\n    Material[14].emission = vec3(0.0);\n    // Leg Material\n    Material[15].albedo = vec3(0.46, 0.63, 0.69);\n    Material[15].roughness = 0.5;\n    Material[15].metalness = 0.5;\n    Material[15].emission = vec3(0.0);\n}\n\nfloat smin(float a,float b,float k){\n    float h = clamp(0.5+0.5*(a-b)/k,0.0,1.0);\n    return mix(a,b,h)-k*h*(1.0-h);\n}\nfloat smax(float a,float b,float k){\n    return -smin(-a,-b,k);\n}\n//Signed Distance Function of segment shape\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-h*ba);\n}\n\n//Signed Distance Function of horsehoe shape\nfloat sdHorseshoe(in vec2 p, in vec2 c, in float r, in vec2 w) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l);\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n//Signed Distance Function of Letter 'N'\nfloat N_sdf(in vec2 p) {\n    vec2 offset = vec2(-2.0, 0.0);\n    float d = udSegment(p-offset, vec2(-0.6, 2.0), vec2(-0.6, 4.0)) - 0.2;\n    float d1 = udSegment(p-offset, vec2(-0.6, 4.0), vec2(0.6, 2.0)) - 0.2;\n    float d2 = udSegment(p-offset, vec2(0.6, 2.0), vec2(0.6, 4.0)) - 0.2;\n    return smin(d2,smin(d, d1, 0.04), 0.04); \n}\n\n//Signed Distance Function of Letter 'U'\nfloat U_sdf(in vec2 p) {\n    float d = udSegment(p, vec2(-0.6, 2.6), vec2(-0.6, 4.0)) - 0.2;\n    float d1 = sdHorseshoe(p-vec2(0.0, 2.6),vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.2,0.2));\n    float d2 = udSegment(p, vec2(0.6, 2.6), vec2(0.6, 4.0)) - 0.2;\n    return smin(d2,smin(d, d1, 0.04), 0.04);\n}\n\n////Signed Distance Function of Letter 'S'\nfloat S_sdf(in vec2 p) {\n    vec2 offset = vec2(2.0, 0.0);\n    float d1 = udSegment(p-offset, vec2(-0.6, 2.0), vec2(0.2, 2.0)) - 0.2;\n    float d2 = udSegment(p-offset, vec2(-0.2, 4.0), vec2(0.6, 4.0)) - 0.2;\n    float d3 = udSegment(p-offset, vec2(-0.2, 3.0), vec2(0.2, 3.0)) - 0.2;\n    float d4 = sdHorseshoe(p.yx-offset.yx-vec2(3.5, -0.2),vec2(cos(1.6),sin(1.6)), 0.5, vec2(0.2,0.2));\n    float d5 = sdHorseshoe(-p.yx+offset.yx-vec2(-2.5, -0.2),vec2(cos(1.6),sin(1.6)), 0.5, vec2(0.2,0.2));\n    \n    return smin(d1,smin(d2,smin(d3,smin(d4,d5, 0.04), 0.04), 0.04), 0.04);\n}\nvoid getFloorMaterial(vec2 xz) {\n    // Floor Material\n    xz = vec2((xz.x+30.0)/60.0, (xz.y+25.0)/50.0);\n    vec2 uv = 20.* xz / s;\n    vec4 h1 = getHex(uv);\n    vec4 h2 = getHex(uv - 1./s);\n    vec4 h3 = getHex(uv + 1./s);\n    \n    float v1 = aafract(hex(h1.xy)/.2);\n    float v2 = aafract(hex(1.5*h2.xy)/0.45);\n    float v3 = aafract(hex(2.*h3.xy)/0.3);\n    \n    Material[12].albedo = vec3(vec3(v1+v2+v3).r/8., 0, 0);\n    \n    Material[12].roughness = 0.8;\n    Material[12].metalness = 0.0;\n    Material[12].emission = vec3(0.0);\n}\n\nbool IntersectNUS(in vec2 p) {\n    return N_sdf(p)<0.0||U_sdf(p)<0.0||S_sdf(p)<0.0;\n}\nvoid InitScene() {\n    seed = iTime + gl_FragCoord.y * gl_FragCoord.x / iResolution.x + gl_FragCoord.y / iResolution.y;\n    InitPlane();\n    InitBall();\n    InitCube();\n    InitLight();\n    InitMaterial();\n}\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\n\n\n// Generate basis matrix for given normal\nmat3 formBasis(vec3 n) {\n    // Make vector q that is non-parallel to n\n    vec3 q = n;\n    vec3 aq = abs(q);\n    if (aq.x <= aq.y && aq.x <= aq.z) {\n        q.x = 1.f;\n    } else if (aq.y <= aq.x && aq.y <= aq.z) {\n        q.y = 1.f;\n    } else {\n        q.z = 1.f;\n    }\n\n    // Generate two vectors perpendicular to n\n    vec3 t = normalize(cross(q, n));\n    vec3 b = normalize(cross(n, t));\n\n    // Construct the rotation matrix\n    mat3 m;\n    m[0] = t;\n    m[1] = b;\n    m[2] = n;\n    return m;\n}\n\n// --SAMPLING------------------------------------------------------------------\nvec4 sampleLight(int i) {\n    Light_t light = Light[i];\n    float pdf = 1.0 / (4.0 * light.size.x * light.size.y);\n    mat4 S = mat4(light.size.x, 0, 0, 0,\n                  0, light.size.y, 0, 0,\n                  0,            0, 1, 0,\n                  0,            0, 0, 1);\n    mat4 M = light.worldMat * S;\n    return vec4((M * vec4(vec2(rnd(), rnd()) * 2.0 - 1.0, 0, 1)).xyz, pdf);\n}\n\n// From http://www.rorydriscoll.com/2009/01/07/better-sampling/\nvec3 cosineSampleHemisphere() {\n    vec2 u = vec2(rnd(), rnd());\n    float r = sqrt(u.x);\n    float theta = 2.0 * PI * u.y;\n    return vec3(r * cos(theta), r * sin(theta), sqrt(saturate(1.0 - u.x)));\n}\n\nfloat cosineHemispherePDF(float NoL) {\n    return NoL / PI;\n}\n\n// --SHADING-------------------------------------------------------------------\n// Lambert diffuse term\nvec3 lambertBRFD(vec3 albedo) {\n    return albedo / PI;\n}\n\n// GGX distribution function\nfloat ggx(float NoH, float roughness) {\n    float a2 = roughness * roughness;\n    a2 *= a2;\n    float denom = NoH * NoH * (a2 - 1.0) + 1.0;\n    return a2 / (PI * denom * denom);\n}\n\n// Schlick fresnel function\nvec3 schlickFresnel(float VoH, vec3 f0) {\n    return f0 + (1.0 - f0) * pow(1.0 - VoH, 5.0);\n}\n\n// Schlick-GGX geometry function\nfloat schlick_ggx(float NoL, float NoV, float roughness) {\n    float k = roughness + 1.0;\n    k *= k * 0.125;\n    float gl = NoL / (NoL * (1.0 - k) + k);\n    float gv = NoV / (NoV * (1.0 - k) + k);\n    return gl * gv;\n}\n\n// Evaluate the Cook-Torrance specular BRDF\nvec3 cookTorranceBRDF(float NoL, float NoV, float NoH, float VoH, vec3 F, float roughness) {\n    vec3 DFG = ggx(NoH, roughness) * F * schlick_ggx(NoL, NoV, roughness);\n    float denom = 4.0 * NoL * NoV + 0.0001;\n    return DFG / denom;\n}\n\n// Evaluate combined diffuse and specular BRDF\nvec3 evalBRDF(vec3 n, vec3 v, vec3 l, Material_t m) {\n    // Common dot products\n    float NoV = saturate(dot(n, v));\n    float NoL = saturate(dot(n, l));\n    vec3 h = normalize(v + l);\n    float NoH = saturate(dot(n, h));\n    float VoH = saturate(dot(v, h));\n\n    // Use standard approximation of default fresnel\n    vec3 f0 = mix(vec3(0.04), m.albedo, m.metalness);\n    vec3 F = schlickFresnel(VoH, f0);\n\n    // Diffuse amount\n    vec3 Kd = (1.0 - F) * (1.0 - m.metalness);\n\n    return (Kd * lambertBRFD(m.albedo) + cookTorranceBRDF(NoL, NoV, NoH, VoH, F, m.roughness)) * NoL;\n}\n//-------------------------------------------------------------------------\n\n//---Intersection-----------------------------------------------------------\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal) {\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.o - sph.center, ray.d);\n    float c = dot(ray.o - sph.center, ray.o - sph.center) - sph.radius * sph.radius;\n    float det_square = b * b - 4.0 * a * c;\n    if (det_square < 0.0) return false;\n    float det = sqrt(det_square);\n    float t1 = (-b - det) / (2.0 * a);\n    float t2 = (-b + det) / (2.0 * a);\n    \n    if (tmin <= t1 && t1 <= tmax) t = t1;\n    else if (tmin <= t2 && t2 <= tmax) t = t2;\n    else return false;\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(hitPos - sph.center);\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(ray.o - sph.center, ray.d);\n    float c = dot(ray.o - sph.center, ray.o - sph.center) - sph.radius * sph.radius;\n    float det_square = b * b - 4.0 * a * c;\n    if (det_square < 0.0) return false;\n    float det = sqrt(det_square);\n    float t1 = (-b - det) / (2.0 * a);\n    float t2 = (-b + det) / (2.0 * a);\n    if (tmin <= t1 && t1 <= tmax) return true;\n    else if (tmin <= t2 && t2 <= tmax) return true;\n    else return false;\n\n}\n\nbool IntersectCube(in Cube_t cube, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 minBound = cube.center - (cube.size / 2.0); // Compute the minimum boundaries of the cube.\n    vec3 maxBound = cube.center + (cube.size / 2.0); // Compute the maximum boundaries of the cube.\n    // Compute the intersection of ray and planes of cube\n    vec3 t1 = (minBound - ray.o) / ray.d;\n    vec3 t2 = (maxBound - ray.o) / ray.d;\n    // Compute the smallest and largest t that intersects the cube\n    vec3 t3 = min(t1, t2);\n    vec3 t4 = max(t1, t2);\n    // Compute entry and exit points.\n    float tstart = max(max(t3.x, t3.y), max(t3.y, t3.z));\n    float tend = min(min(t4.x, t4.y), min(t4.y, t4.z));\n    if(tend < tstart || tstart > tmax || tend < tmin)\n        return false;\n        \n    t = tstart < tmin ? tend : tstart;\n    // Compute the hit position\n    hitPos = ray.o + ray.d * t;\n    // Compute the length between the cube center and the hit position.\n    vec3 d = abs(hitPos - cube.center) / (cube.size / 2.0);\n    float maxD = max(max(d.x, d.y), d.z); // Maximum dimension\n\n    if(maxD == d.x)\n        hitNormal = vec3(sign(hitPos.x - cube.center.x), 0.0, 0.0);\n    else if(maxD == d.y)\n        hitNormal = vec3(0.0, sign(hitPos.y - cube.center.y), 0.0);\n    else\n        hitNormal = vec3(0.0, 0.0, sign(hitPos.z - cube.center.z));\n    hitNormal = normalize(hitNormal);\n\n    return true;\n}\n\n\nbool IntersectCube( in Cube_t cube, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 minBound = cube.center - (cube.size / 2.0);\n    vec3 maxBound = cube.center + (cube.size / 2.0);\n\n    vec3 t1 = (minBound - ray.o) / ray.d;\n    vec3 t2 = (maxBound - ray.o) / ray.d;\n    \n    vec3 t3 = min(t1, t2);\n    vec3 t4 = max(t1, t2);\n    \n    float tstart = max(max(t3.x, t3.y), max(t3.y, t3.z));\n    float tend = min(min(t4.x, t4.y), min(t4.y, t4.z));\n    \n    if(tend < tstart || tstart > tmax || tend < tmin)\n        return false;\n\n    return true;\n}\nHit IntersectScene(Ray_t ray) { \n    bool hasHitSomething = false;\n    float nearest_t = ray.t;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    for (int i = 0; i < NUM_PLANES; i++) {\n        if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal) == true) {\n            temp_hasHit = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n                hasHitSomething = temp_hasHit;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal) == true) {\n            temp_hasHit = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n                hasHitSomething = temp_hasHit;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_CUBES; i++) {\n        if(IntersectCube(Cube[i], ray, DEFAULT_TMIN, nearest_t,\n                      temp_t, temp_hitPos, temp_hitNormal)) {\n                         hasHitSomething = true;\n                         nearest_t = temp_t;\n                         nearest_hitPos = temp_hitPos;\n                         nearest_hitNormal = temp_hitNormal;\n                         nearest_hitMatID = Cube[i].materialID;\n                      }\n    }\n    if(nearest_hitMatID==10 && IntersectNUS(nearest_hitPos.zy))nearest_hitMatID = 11;\n    if(nearest_hitMatID==12) getFloorMaterial(nearest_hitPos.xz);\n    return Hit(hasHitSomething, nearest_hitPos, nearest_hitNormal, nearest_hitMatID);\n}\n\n//----------------------------------------------------------------------\n//---Random------------------------------------------------------\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat randomInt(float seed) {\n    vec2 temp = vec2(seed, 0.0);\n    float rand = random(temp);\n    rand = rand * 6.0; \n    rand = ceil(rand);\n    return rand;\n}\n\nvec3 mapHolePos(in float num) {\n    if (num == 1.0) {\n        return vec3(18.0, 0.5, -9.0);\n    }else if(num == 2.0) {\n        return vec3(18.0, 0.5, 9.0);\n    }else if(num == 3.0) {\n        return vec3(0.0, 0.5, -9.0);\n    }else if(num == 4.0) {\n        return vec3(0.0, 0.5, 9.0);\n    }else if(num == 5.0) {\n        return vec3(-18.0, 0.5, -9.0);\n    }else if(num == 6.0) {\n        return vec3(-18.0, 0.5, 9.0);\n    }\n}\nvec3 mapWhiteBall(in float num) {\n    if (num == 1.0) {\n        return vec3(-5.0, 0.5, 4.0);\n    }else if(num == 2.0) {\n        return vec3(-5.0, 0.5, -4.0);\n    }else if(num == 3.0) {\n        return vec3(15.0, 0.5, 6.0);\n    }else if(num == 4.0) {\n        return vec3(15.0, 0.5, -6.0);\n    }else if(num == 5.0) {\n        return vec3(15.0, 0.5, 2.0);\n    }else if(num == 6.0) {\n        return vec3(15.0, 0.5, -2.0);\n    }\n}\n\n//---Movement-----------------------------------------------------------\nvoid CalcMove(in int sph, in float rand) {\n    vec3 holePos = mapHolePos(rand);\n    Sphere[21].center = mapWhiteBall(rand);\n    vec3 centerPos = Sphere[sph].center;\n    vec3 TargetMove = holePos - centerPos;\n    float TargetMovex = TargetMove.x;\n    float TargetMovez = TargetMove.z;\n    float TargetMoveLength = sqrt(TargetMovex * TargetMovex + TargetMovez * TargetMovez);\n    float S = TargetMovez / TargetMoveLength;\n    float C = TargetMovex / TargetMoveLength;\n    vec3 arrivePos = vec3(centerPos.x - 1.0 * C, 0.5, centerPos.z - 1.0 * S);\n    vec3 HitMove = arrivePos - Sphere[21].center;\n    float HitMovex = abs(HitMove.x);\n    float HitMovez = abs(HitMove.z);\n    float HitMoveLength = sqrt(HitMovex * HitMovex + HitMovez * HitMovez);\n    float s = HitMovez / HitMoveLength;\n    float c = HitMovex / HitMoveLength;\n    float T = 3.0;\n    float t = mod(iTime, T);\n    float Speed = (HitMoveLength + 2.0 * TargetMoveLength) / T;\n    float DownSpeed = 1.0 / 0.15;\n    float t1 = HitMoveLength / Speed;\n    float xDir = 1.0;\n    if (Sphere[sph].center.x < Sphere[21].center.x) {\n        xDir = -1.0;\n    }\n    float zDir = 1.0;\n    if (Sphere[sph].center.z < Sphere[21].center.z) {\n        zDir = -1.0;\n    }\n    if (t <= t1) {\n        \n        Sphere[21].center.x += xDir * Speed * t * c;\n        Sphere[21].center.z += zDir * Speed * t * s;\n    }\n    else {\n        Sphere[21].center = arrivePos;\n        float delta = t - t1;\n        Sphere[sph].center.x += Speed * 0.5 * delta * C;\n        Sphere[sph].center.z += Speed * 0.5 * delta * S;\n        if (t >= 2.85) {\n            float downDelta = t - 2.85;\n            Sphere[sph].center.y -= DownSpeed * downDelta;\n        }\n        vec3 dir = HitMove - 0.5 * TargetMove;\n        float dirLength = sqrt(dir.x * dir.x + dir.z * dir.z);\n        float ss = dir.z / dirLength;\n        float cc = dir.x / dirLength;\n        Sphere[21].center.x += Speed * 0.13 * delta * cc;\n        Sphere[21].center.z += Speed * 0.13 * delta * ss;\n    }\n}\n\nint Movement() {\n    float T = 3.0;\n    int turn = int(mod(iTime / T, 4.0));\n    float t = floor((iTime + 3.0) / T);\n    float rand = randomInt(t);\n    \n    CalcMove(17 + turn, rand);\n    return 17 + turn;\n}\n//----------------------------------------------------------------------\n\n\n\nvec3 Monte_Carlo_Raytracing() {\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec3 result = vec3(0);\n    for (int j = 0; j < SAMPLES_PER_PIXEL; j++) {\n        // Generate ray\n        vec2 sample_px = gl_FragCoord.xy + vec2(rnd(), rnd());\n        vec3 pixel_pos = vec3((2.0 * sample_px.xy - iResolution.xy) / iResolution.y, -1.0 / tan(FOVY / 2.0));\n        Ray_t pRay;\n        pRay.o = camera.pos;\n        pRay.d = normalize(pixel_pos.x * camera.axis[0]  +  pixel_pos.y * camera.axis[1]  +  pixel_pos.z * camera.axis[2]);\n        pRay.t = DEFAULT_TMAX;\n        \n        int bounce = 1;\n        vec3 throughput = vec3(1);\n\n        while (true) {\n            Hit hit = IntersectScene(pRay);\n            if(!hit.hit)break;\n            Material_t m = Material[hit.MaterialID];\n            vec3 n = hit.normal;\n            vec3 p = hit.position + hit.normal * EPSILON;\n\n            // Add hacky emission on first hit to draw lights\n            if (bounce == 1)\n                result += throughput * m.emission;\n\n            // Sample lights\n            for (int i = 0; i < NUM_LIGHTS; i++) {\n                // Generate point on light surface\n                vec4 ls = sampleLight(i);\n                vec3 lightPos = ls.xyz;\n                float pdf = ls.w;\n\n                // Generate shadow ray\n                Ray_t sray;\n                sray.o = p;\n                sray.t = length(lightPos - p);\n                sray.d = (lightPos - p) / sray.t;\n\n                // Test visibility\n                Hit sHit = IntersectScene(sray);\n                if (!sHit.hit) {\n                    // Add light contribution when visible\n                    float rSquare = sray.t * sray.t;\n                    if (dot(Light[i].normal, -sray.d) > 0.0) {\n                    \tvec3 E = Light[i].E;\n                    \tresult += throughput * evalBRDF(hit.normal, -pRay.d, sray.d, m) * E / (rSquare * pdf);\n                    }\n                }\n            }\n\n            // Russian roulette for termination\n            if (bounce >= BOUNCES && rnd() < P_TERMINATE)\n                break;\n\n            // Get random direction for reflection ray\n            vec3 randomDir = cosineSampleHemisphere();\n            // Rotate by normal frame\n            randomDir = normalize(formBasis(n) * randomDir);\n            float pdf = cosineHemispherePDF(dot(n, randomDir));\n            // TODO: Multiple importance sampling on diffuse and specular?\n            throughput *= evalBRDF(hit.normal, -pRay.d, randomDir, m) / pdf;\n            pRay.d = randomDir;\n            pRay.o = p;\n            bounce++;\n        }\n    }\n    return result / float(SAMPLES_PER_PIXEL);\n}\n\nvoid SetCamera(in int num) {\n    \n    // Position the camera.\n    vec3 OriginPos = vec3(-4.0, 0.5, 6.0);\n    camera.pos = vec3( OriginPos.x + (Sphere[21].center.x - OriginPos.x) * 0.6 - 23.0, 12.5, OriginPos.z + (Sphere[21].center.z - OriginPos.z) * 0.6 + 15.0 );\n    camera.lookat = Sphere[num].center;\n    vec3 cam_up_vec = vec3(0.0, 1.0, 0.0);\n\n    // Set up camera coordinate frame in world space.\n    camera.axis[2] = normalize(camera.pos - camera.lookat);\n    camera.axis[0] = normalize(cross(cam_up_vec, camera.axis[2]));\n    camera.axis[1] = normalize(cross(camera.axis[2], camera.axis[0]));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    InitScene();\n    int ballNo = Movement();\n    SetCamera(ballNo);\n    vec3 result = Monte_Carlo_Raytracing();\n    fragColor = vec4(ltos3(result.x, result.y, result.z), 1.0); // Gamma correct\n}\n","name":"Image","description":"","type":"image"}]}