{"ver":"0.1","info":{"id":"3lBfDz","date":"1598689938","viewed":274,"name":"Basic : Atmosphere","username":"Gijs","description":"Saw this video and recreated its effect.  Move camera with WASD+QE+Shift+Space+Mouse.\n\nhttps://www.youtube.com/watch?v=DxfEbulyFcY","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["3d","atmosphere","volumetrics","scatteringa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    //gamma correction\n    col = pow(col, vec3(1./GAMMA));\n    \n    //vignette\n    vec2 s = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    col *= smoothstep(VIGNETTE_END, VIGNETTE_START, length(s));\n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//constants\n#define PI  3.14159\n#define TAU 6.28318\n\n//Lighting\nconst vec3  SUN_VECTOR    = vec3(0.57735026919);\nconst vec3  SUN_COLOR     = vec3(1.);\nconst float SUN_SIZE      = 0.0002;\nconst float SUN_INTENSITY = 1.;\n\n//Camera\nconst float ZOOM            = .5;\nconst float MOVEMENT_SPEED  = 3.;\nconst vec3  CAMERA_LOOK     = vec3(0,1,0);\nconst vec3  CAMERA_POSITION = vec3(3,2,-2)*2.;\nconst float CAMERA_SENSITIVITY      = 0.003;\nconst float CAMERA_ROLL_SENSITIVITY = 1.;\n\n//Post\nconst float GAMMA          = 2.2;\nconst float VIGNETTE_START = 1.1;\nconst float VIGNETTE_END   = 4.;\n\n//Atmosphere\nconst int   DEPTH_SAMPLES = 5;\nconst int   ATMOS_SAMPLES = 10;\nconst vec3  planetPosition = vec3(0);\nconst float planetRadius = 1.;\nconst float atmosphereFalloff = 30.;\nconst float atmosphereBase = 2.;\nconst float atmosphereCutoff = planetRadius + -log(0.00001)/atmosphereFalloff;\nconst vec3  scattering = vec3(0.1, 0.3, 0.7)*10.;\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\n//Palette Creator\nvec3 getPaletteColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(TAU*(c*t+d) );\n}\n\n//hashing\nvoid hash( inout uint n ) {\n    \n    n += ( n << 10u );\n    n ^= ( n >>  6u );\n    n += ( n <<  3u );\n    n ^= ( n >> 11u );\n    n += ( n << 15u );\n}\n\n//gives a random float in range [0,1]\nfloat rand( inout uint n ){\n    hash(n);\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool raySphere(vec3 o, vec3 d, vec3 c, float r, inout float t1, inout float t2){\n    o -= c, d -= c;\n    float C = dot(o,o)-r*r;\n    float B = 2.*dot(o,d);\n    float A = dot(d,d);\n    float D2 = B*B - 4.*A*C;\n    if(D2<0.) return false;\n    float D = sqrt(D2);\n    t1 = (-B - D)/(2.*A);\n    t2 = (-B + D)/(2.*A);\n    return true;\n}\n\nfloat atmosphereDensity(vec3 x){\n    float h = distance(x, planetPosition) - planetRadius;\n    return exp(-h*atmosphereFalloff)*atmosphereBase;\n}\n\nfloat atmosphereDepth(vec3 ori, vec3 dir, float t1, float t2){\n    //midpoint riemann integration\n    float density = 0.;\n    float dt = (t2-t1)/float(DEPTH_SAMPLES);\n    float t = t1 + dt*.5;//+dt*.5 so we are taking midpoints\n    for(int i=0; i<DEPTH_SAMPLES; i++){\n        vec3 x = ori + dir*t;\n    \tdensity += atmosphereDensity(x)*abs(dt);\n        t += dt;\n    }\n    return density;\n}\n\n\n\nvec3 bla(vec3 ori, vec3 dir){\n    float pt1, pt2, at1, at2;\n    bool  ph = raySphere(ori, dir, planetPosition, planetRadius    , pt1, pt2);\n    bool  ah = raySphere(ori, dir, planetPosition, atmosphereCutoff, at1, at2);\n   \n    vec3 col = vec3(0);\n    \n    //base color of scene\n    if(pt1>0.){\n        //black planet\n        col = vec3(0);\n    }else{\n        //simply \"sky\" \n        vec3 del = dir-SUN_VECTOR;\n\t\tcol += SUN_COLOR*min(SUN_SIZE/dot(del,del),SUN_INTENSITY);\n    }\n     \n    //atmosphere\n    if(ah &&(at1>0.||at2>0.)){ //if atmosphere is hit at all, and if it is hit in view\n        \n        vec3 scatterlight = vec3(0);\n        \n        //calculate the actual place where the ray travels through the atmosphere\n        float t1 = max(0., at1);  //start of atmosphere keeping in mind the ray starts at 0\n        float t2 = at2;\n        if(ph && pt1>0.) t2 = pt1;//atmosphere interupted by planet\n        \n        //midpoint riemann integration\n        float dt = (t2-t1)/float(ATMOS_SAMPLES);\n        float t = t1 + dt*.5; //+dt*.5 so we are taking midpoints\n        for(int i = 0; i<ATMOS_SAMPLES; i++){\n            vec3 x = ori + dir*t;\n            float p2t1, p2t2, st1, st2;\n            bool sh  = raySphere(x, SUN_VECTOR, planetPosition, atmosphereCutoff,  st1, st2 );\n            bool p2h = raySphere(x, SUN_VECTOR, planetPosition, planetRadius    , p2t1, p2t2);\n            \n            //the planet can be in the way of the sun\n            //but when I implement this, although the result becomes lot more accurate, \n            //it comes at the cost that I need to increase the ATMOS_SAMPLES by alot to get rid the banding\n            if(true || !p2h || p2t1<0.){ \n            \n                float sunDepth  = atmosphereDepth(x, SUN_VECTOR, 0., st2);\n                float viewDepth = atmosphereDepth(ori, dir, t1, t);\n                float density   = atmosphereDensity(x);\n\n                vec3 transmittance = exp(-(sunDepth + viewDepth) * scattering);\n\n                scatterlight += SUN_INTENSITY*SUN_COLOR*transmittance*density*scattering*dt;\n            }\n            \n            t += dt;\n        }\n        \n        col = col*exp(-atmosphereDepth(ori, dir, t1, t2) * scattering) + scatterlight;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float minResolution = min(iResolution.x,iResolution.y);\n    \n    //camera\n    vec3 cameraPosition = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n\n    //Scaling\n    vec2 sp  = (fragCoord*2.-iResolution.xy)/minResolution*ZOOM;\n     \n   \t//Pixel Ray\n\tvec3 direction = normalize(cameraForward+sp.x*cameraRight+sp.y*cameraUpward);\n\n    fragColor = vec4(bla(cameraPosition, direction), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\n//makes sure that three 3 dimensional vectors are orthonormal\nvoid GramSchmidt33(inout vec3 a, inout vec3 b, inout vec3 c){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    a =  c*a + s*b;\n    b = -s*a + c*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>4 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    vec3 mouseOld       = texelFetch(iChannel0,ivec2(4,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraPosition  = CAMERA_POSITION;\n        cameraForward   = normalize(CAMERA_LOOK-cameraPosition);\n        cameraRight     = normalize(cross(vec3( 0, 1, 0),cameraForward));\n        cameraUpward    = normalize(cross(cameraForward,cameraRight));\n        mouseOld        = vec3(iMouse.xy, 0);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = (distance(cameraPosition, planetPosition)-planetRadius)*MOVEMENT_SPEED*iTimeDelta*ZOOM;\n    \n    //Translation\n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    //Roll\n    float r = (float(rollleft)-float(rollright))*iTimeDelta*CAMERA_ROLL_SENSITIVITY;\n    rot(cameraRight, cameraUpward , r);\n    \n    //Pitch & Yaw\n    if(mouseLeft){\n        if(mouseOld.z==0.){\n            mouseOld.xy = iMouse.zw;\n            mouseOld.z = 1.;\n        }\n\t\tvec2 s = iMouse.xy-mouseOld.xy;\n        rot(cameraForward, cameraUpward, s.y*CAMERA_SENSITIVITY);\n        rot(cameraForward, cameraRight , s.x*CAMERA_SENSITIVITY);\n    }else{\n    \tmouseOld.z = 0.;   \n    }\n    \n    GramSchmidt33(cameraForward, cameraUpward, cameraRight);\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }else if(p.x==4){\n        fragColor.rgb = vec3(iMouse.xy, mouseOld.z);\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"}]}