{"ver":"0.1","info":{"id":"flGfRy","date":"1664700548","viewed":272,"name":"Thomas Rotation 2","username":"Amirk","description":"Four non-collinear boosts will result in an additional rotation of frame/coordinates, called Thomas rotation, a non trivial effect of special relativity.  Adjust the boost strength with slider.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["rotation","relativity","lorentz","acceleration","retardation"],"hasliked":0,"parentid":"7sKBzz","parentname":"Relativistic Space Drive"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe first boost is along positive x-axis, second along positive y-axis\n(in the frame of the rocket), third along negative x-axis,\nand last along negative y-axis brings the rocket back to rest.\n\nThe strengths of the boosts are NOT equal. The second and third need to be\nscaled with respect to the first boost to bring the rocket to rest. \n*/\n\n#define MAX_ITER 1000.\n#define MAX_DIST 20.\n#define SURF .0001\n\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\n\n\nvec3 SIZE= vec3(.1); \n\n//retardation effect ON/OFF:\nbool RETARD = true;\n//ray origin in the moving coords.\nvec4 RO, rd;\nvec2 m;\nmat4 TransformMatrix;\n\nvec3 col = vec3(0);\nfloat vv;\n\nfloat halo=0.;\n\nvec3 color( float s){\n    return vec3(1) - vec3(1.,1.,0)*smoothstep(.0,1., s)-\n            vec3(0.,.6,.6)*smoothstep(0.,1., -s);\n}\n\nvoid updateVel(){\n    // Fetch the offset from the Buffer A\n    boost= texelFetch( iChannel0, ivec2(5,5), 0);\n    orientation=texelFetch( iChannel0, ivec2(6,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the offset from the Buffer B\n    \n    position =texelFetch( iChannel1, ivec2(0,0), 0 );\n   \n}\n\n\n\nfloat sdAxes(vec4 p , float rad){\n    p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes\n    \n    return  min(length(p.yz)-rad,length(p.xy)-rad);// length(p.xyz)-rad;  \n}\n\nvoid getMaterial(vec3 p){\n    p.xyz=fract(p.xyz)-.5; //this creates the grid of reference cubes\n\n    if(length(p.yz)<length(p.xy)) col= vec3(1.,.3,.3);\n    else col= vec3(.3,.3,1.);\n}\n\n\n\nfloat getDist(vec4 q){\n    float dist=sdAxes(q,.05);\n\n    if(RETARD){\n        return dist/(1.+.23*vv);\n    }else{\n        return dist/(1.+.2*vv);\n    }\n     //step size could probably be further optimized\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n    //the w-component determines how we look into past/future/present.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\nmat4 getTransform(){\n    mat4 M; \n\n        for(int i=1; i<=4; i++)\n           for(int j=1; j<=4; j++)\n              M[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n    \n    return M;\n}\n\n\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\n\n\nfloat dfRocketBody(vec3 p)\n{\n        \n    vec3 p2 = p;\n   \n    angularRepeat(PI*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, (rot(PI*-.125)*( p2.xz+vec2(-.7,0))).y);\n    d = max(d, (rot(PI*-.25*.75)*(p2.xz+vec2(-0.95,0))).y);\n    d = max(d, (rot(PI*-.125*.5)*( p2.xz+vec2(-0.4,0))).y);\n    d = max(d, (rot(PI*.125*.25)*( p2.xz+vec2(+0.2,0))).y);\n    d = max(d, (rot(PI*.125*.8)*( p2.xz+vec2(.5,0))).y);\n    \n    d = max(d,-.8-p.x);\n    \n    d -= .5;\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    \n    p.yz*=rot(t*(1.+10.*boost.w));\n    vec3 pFins = p;\n    angularRepeat(PI*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.2)*.5,.0,.0);\n    pFins.xz*=rot(-PI*.25);\n    float scale = 1.0-pFins.z*.6;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat Jet(vec3 p)\n{\n    float d= length(p.yz);\n    if(p.x>0.2)d=20.;\n    \n    return d-p.x*.05;\n}\n\nfloat df(vec3 p)\n{           \n    p.xz*=rot(-atan(orientation.z,orientation.x));\n        \n        \n    float proxy = mBox(p,vec3(4.5,.8,.8));\n    if (proxy>1.)\n    \treturn proxy;\n    float dRocketBody=   dfRocketBody(p);\n    float dRocketFins=   dfRocketFins(p);\n    float dJet=  Jet(p);\n    if(boost.w==1.&&dJet<dRocketFins*5.&&dJet<.4){\n    halo+=.7;\n    }\n    \n    return min(dRocketBody,dRocketFins);\n}\n\nvec3 nf(vec3 p)\n{\n    \n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\n\nvoid rocket (inout vec3 color, in vec3 pos, in vec3 dir) {\n    \n        \n    float dist,tdist = .0;\n    \n    for (int i=0; i<100; i++)\n    {\n     \tdist  = df(pos);\n       \tpos  += dist*dir;\n        tdist+=dist;\n        if (dist<0.00001||dist>7.0)break;\n    }\n    \n    vec3 normal = nf(pos);\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    \n    pos.xz*=rot(-atan(orientation.z,orientation.x));\n       \n        \n    vec3 materialColor = vec3(0);\n    vec3 blueColor = vec3(.1,.4,.9);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n       \n    \n    float r = dot(pos.yz,pos.yz);\n   \n    \n    if (dRocketBody<dRocketFins)\n    {\n    \n        if (pos.x<-.85)\n            if (pos.x<-1.2)\n                materialColor = blueColor + vec3(0.03 / r);\n            else\n                materialColor = vec3(.7,.1,.7);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.7,.1,.7) ;\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.7,.1,.7);\n        if (length (pos - 0.1 * vec3(0.0, normal.yz)) > length (pos)) { \n\n            materialColor -= vec3(.9,.3,1.5) * min(0.2, pos.x + 1.3) / r;\n        }\n    }   \n    \n    if (dist<.1){\n    float dif=dot(normal, vec3(-4,4,4))*.3;\n    color =  ao*materialColor*dif;\n    }\n}\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 position = vec2(.0,.9);\n    float FontSize = 6.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n   \n   C(32);C(32);C(32);C(32);\n   float beta= length(fourvel.xyz)/c;\n   float gamma = pow(1.-beta*beta,-.5);\n   C(115);C(112);C(101);C(101);C(100);C(32)\n   ;C(46);C(48+int(floor(10.*length(fourvel.xyz)/fourvel.w/c))); C(99);\n   C(32);C(32); C(32);C(32);C(32);C(32);\n   C(66);C(111);C(111);C(115);C(116);C(32);\n   if(boost.w==1.){\n       \n       if(boost.x-1.>-.01){\n           C(70);C(79);C(82);C(87);C(65);C(82);C(68);  \n       }\n       else if(boost.x+1.<.01){\n           C(66);C(65);C(67);C(75);   \n       }\n       else if(boost.z-1.>-.01){\n           C(76);C(69);C(70);C(84);\n       }\n       else if(boost.z+1.<.01){\n           C(82);C(73);C(71);C(72);C(84);  \n       }\n   }\n   \n   return O.xxxx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     \n    \n    updateVel();\n    //coordinate transform:  \n    TransformMatrix=getTransform();\n    updatePos();\n    \n    //ray origin in lab coordinates:\n    RO=position;\n    float zoom= 1.;\n    \n    //lookat in our moving coords:\n    vec4 lookAt;\n    if(RETARD) //what we actually see as light reaches our eyes:\n        lookAt = vec4(c, 0, 0, -1);\n    else //the instantaneous geometry of spacetime/coordinates: \n        lookAt = vec4(c, 0, 0, 0);\n            \n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n    \n    \n    \n    //adding the rocket on top\n    vec3 r_color = vec3 (0);\n    vec3 cam=vec3(-7,1.5,0);    \n        \n    rocket (r_color, cam, ray.xyz);\n    \n    if (length (r_color) > 0.0) {\n        fragColor.xyz = r_color;\n    }else{ \n    \n\n        //ray direction from  moving coords to lab coords:\n        rd= TransformMatrix*ray; \n\n        if(RETARD){\n             vv= max(0., -dot(fourvel.xyzw, rd.xyzw));\n        }else{\n             vv= abs(dot(fourvel.xyzw, rd.xyzw));\n        }\n\n        vec4 p=RO;        \n\n        //the usual raymarch in lab coords:\n        float d= RayMarch(p, rd, 1.);\n\n\n         if(d<MAX_DIST){ //if we hit an object:\n              p= p+ d*rd;\n\n            //  col=color(dot(normalize(rd.xyz), fourvel.xyz));\n              getMaterial(p.xyz);\n\n              vec3 n= getNormal(p);\n\n              float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n              col/=length(d*rd)*.2;\n              col*=dif*dif;            \n\n        }else{\n\n            col.rgb=pal( atan(rd.x,rd.z)*2./6.28318, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );   \n        }\n        col.xyz+=text(fragColor, fragCoord).xyz;\n\n\n\n        float v1=.6;\n        if(iMouse.w!=0.) v1=iMouse.x/iResolution.x;\n\n        col+=3.*DrawSlider((fragCoord-.5*iResolution.xy)/iResolution.x, .4,.01,v1);\n\n        fragColor = vec4(col,1.0)+halo*halo*vec4(.4,.2,1,1);\n    \n   }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n//t represents the proper time in rocket's moving frame (counted in frames so\n//fps would not affect the physics)\n#define t fract(float(iFrame)/frames/11.)*11.\n#define PI 3.14159265359\n\n\nconst float c=1.;\n\n/////////////////////////////////////////////////////////////\n//CHOOSE INITIAL VELOCITY (less than speed of light):\nconst vec2 initVelocity=vec2(.0,.0)*c;\n\n///////////////////////////////////////////////////////////////\n\nmat4 Lorentz(vec3 v){\n     float beta= length(v)/c;\n     float gamma = pow(1.-beta*beta,-.5);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, 0., (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 0., 1., 0., 0.,\n                 (gamma-1.)*v.z*v.x/v2, 0., 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, 0., -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec3 pal( in float x, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*x+d) );\n}\n\nvec3 DrawSlider(vec2 uv,float w,float h,float v)\n{\n   uv -=vec2(.0,.22);\n   \n    //Remap value by slider width\n    v-=0.5;\n    v *= 1. / (w * 2.);\n    v+= .5;\n    v = clamp(v,0.,1.);\n    \n    vec2 a = abs( uv /= vec2(w,h) );\n    return max(a.x,a.y) < 1.\n                ? uv.x +1. < v*2. \n                   ? vec3(v,1.-v,0)\n                   : vec3(.1)\n                   : vec3(0);\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float v1=.6;\n\n\nmat4 TransformMat;\nmat4 Transform1,Transform2,Transform3,Transform4;\n\nfloat scaledVelocity(float v){\n    float beta= v1/c;\n    float gamma = pow(1.-beta*beta,-.5);\n    //scale factor for second and third boost.\n    float factor= gamma/sqrt(2.*gamma*gamma-1.);\n    \n    //the speed for second and thrd boost.\n    float scaledV = factor*v1;\n    return scaledV;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.w!=0.) v1=clamp((iMouse.x/iResolution.x-.1)/.8,0.,1.);\n    \n    vec3 initialv=vec3(initVelocity.x,0,-initVelocity.y);\n    \n    float beta= length(initialv)/c;\n    float gamma = pow(1.-beta*beta,-.5);\n    float v2= scaledVelocity(v1);\n    \n    vec4 initial4v=vec4(0,0,0,1)*Lorentz(-initialv);    \n    \n   vec4  boost=vec4(0);\n   if(fract(t*.5)<.9)  boost=vec4(1,0,0,1);\n   \n   if(t<2.||t>9.9) boost.w*=0.;\n    \n   int T= int(floor(t));  \n   \n       TransformMat = mat4(1,0,0,0,\n                        0,1,0,0,\n                        0,0,1,0,\n                        0,0,0,1);\n   \n   if(T>=2){ \n       TransformMat= Lorentz(-v1*vec3(c,0,0));\n   }\n   if(T>=4){\n       TransformMat*=Lorentz(-v2*vec3(0,0,-c));\n       boost.xz*=rot(-PI/2.);\n   }\n   if(T>=6){\n       TransformMat*= Lorentz(-v2*vec3(-c,0,0));\n       boost.xz*=rot(-PI/2.);\n   }\n   if(T>=8){\n       TransformMat*= Lorentz(-v1*vec3(0,0,c));\n       boost.xz*=rot(-PI/2.);\n   }\n   \n   //fourvelocity represented in the coordinates of our stationary frame\n   vec4 fourvel = initial4v*TransformMat; \n  \n  \n   vec3 orientation =texelFetch( iChannel0, ivec2(6, 6), 0).rgb;    \n   orientation +=(boost.xyz-orientation)*.05;\n   if(t<2.||length(boost.xz-orientation.xz)<.1) boost.w*=0.;\n   \n   \n   \n   if(ivec2(fragCoord)==ivec2(6,6))\n         fragColor= vec4(orientation,0);                          \n   else if(ivec2(fragCoord)==ivec2(0,0)){\n         //4velocity is stored as our stationary coordinates:\n         fragColor= fourvel;          \n    }else if(ivec2(fragCoord)==ivec2(5,5)){\n         fragColor=boost;\n    }else{\n        //Store Matrix:       \n        for(int i=1; i<=4; i++)\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(i,j)){\n                    float oldValue=texelFetch( iChannel0, ivec2(i,j), 0).r;\n                    //interpolate for visual smoothness:\n                    TransformMat[i-1][j-1]-=(TransformMat[i-1][j-1]-oldValue)*.9;\n                    fragColor.r=TransformMat[i-1][j-1];\n                    }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//proper-time step:\nconst float dt=.05;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     // four position represented in stationary coords:\n    vec4 pos = texelFetch( iChannel1, ivec2(0, 0), 0);\n   \n    // fourvel represented in stationary coords:\n    vec4 fourvel = texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n    //float gamma=fourvel.w;\n  \n    \n    //four position represented in stationary coordinates:\n    pos += fourvel*dt;\n    \n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = pos;\n}","name":"Buffer B","description":"","type":"buffer"}]}