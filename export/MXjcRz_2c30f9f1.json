{"ver":"0.1","info":{"id":"MXjcRz","date":"1726875178","viewed":24,"name":"Wos with SD lines","username":"alpers_shadertoy","description":"Alternates between two non-water-tight polygons. Shades the pixels plasma colormap if the points are inside. The process is designed as a Monte Carlo process. Shows signed distance field-driven lines.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","pointcontainment"],"hasliked":0,"parentid":"MclBzX","parentname":"Walk on circles Sampling"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col=texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n  \n     \n  \n\tfragColor = vec4(tanh(2.0*col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265359;\nconst float EPS = 1e-3;\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec3 plasma(float t) {\n    t = clamp(t, 0.0, 1.0);\n\n    const vec3 c[10] = vec3[10](\n        vec3(0.050383, 0.029803, 0.527975),\n        vec3(0.274191, 0.012109, 0.622722),\n        vec3(0.447714, 0.002080, 0.660240),\n        vec3(0.610667, 0.090204, 0.619951),\n        vec3(0.740143, 0.213864, 0.524216),\n        vec3(0.846788, 0.342551, 0.420579),\n        vec3(0.928329, 0.472975, 0.326067),\n        vec3(0.983041, 0.624131, 0.227937),\n        vec3(0.991209, 0.790537, 0.149377),\n        vec3(0.940015, 0.975158, 0.131326)\n    );\n\n    // Scale t to the range [0, 9]\n    float scaledT = t * 9.0;\n    \n    // Find the indices of the two colors to interpolate between\n    int idx = int(floor(scaledT));\n    float frac = fract(scaledT);\n    \n    // Interpolate between the two colors\n    return pow(mix(c[idx], c[idx + 1], frac), vec3(2.2));\n}\n\n\nvec2 sampleUniformCircle(vec2 uv) {\n    // sample a point on a unit circle\n    float theta = 2.0 * PI * rand(vec3(uv.xy, iTime));\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 pointToLineSegmentDist(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab = b - a;\n    \n    // Vector from a to p\n    vec2 ap = p - a;\n    \n    // Project vector ap onto ab and clamp the result to the segment [0, 1]\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    \n    // Closest point on the line segment to p\n    vec2 closestPoint = a + t * ab;\n    \n    // Distance from p to the closest point\n    return vec2(length(p - closestPoint), t);\n}\n\nvec2 calculateNormal(vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    return normalize(vec2(-ab.y, ab.x));\n}\n\n\nvec2 rayIntersectsSegment(vec2 o, vec2 d, vec2 a, vec2 b) {\n    vec2 ao = o - a;// v1\n    vec2 ab = b - a;// v2 and d is v3\n    float denom = dot(ab, d);\n    if (abs(denom) < 1e-6) return vec2(-1.0);\n    float t = (ab.x * ao.y - ab.y * ao.x) / denom;// v2 X v1\n    float u = dot(ao, d) / denom;// v1 . v3\n    if(t >= 0.0 && u >= 0.0 && u <= 1.0) return vec2(t,u);\n    else return vec2(-1.0);\n}\n\nconst int NUM_VERT_A = 8;\nconst int NUM_VERT_B = 10;\nbool renderingFirst = true;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the vertices of the non-convex polygon\n    vec2 verticesA[NUM_VERT_A];\n    verticesA[0] = vec2(0.3, 0.24);\n    verticesA[1] = vec2(0.1, 0.1);\n    verticesA[2] = vec2(0.9, 0.1);\n    verticesA[3] = vec2(0.46, 0.5);\n    verticesA[4] = vec2(0.54, 0.5);\n    verticesA[5] = vec2(0.9, 0.9);\n    verticesA[6] = vec2(0.1, 0.9);\n    verticesA[7] = vec2(0.28, 0.32);\n    \n    vec2 verticesB[NUM_VERT_B];\n    verticesB[0] = vec2(0.15, 0.1);\n    verticesB[1] = vec2(0.95, 0.1);\n    verticesB[2] = vec2(0.75, 0.95);\n    verticesB[3] = vec2(0.56, 0.95);\n    verticesB[4] = vec2(0.80, 0.25);\n    verticesB[5] = vec2(0.52, 0.22);\n    verticesB[6] = vec2(0.5, 0.24);\n    verticesB[7] = vec2(0.3, 0.2);\n    verticesB[8] = vec2(0.53, 0.95);\n    verticesB[9] = vec2(0.35, 0.95);\n   \n    \n    int numVertices;\n    float timeElapsed = mod(iTime, 40.0);\n    // Toggle the polygons every 20 seconds\n    renderingFirst = timeElapsed < 20.0;\n    if(renderingFirst)\n    {\n        numVertices = NUM_VERT_A;\n    }\n    else\n    {\n        numVertices = NUM_VERT_B;\n    }\n    \n    //allocate for the max size since its just a colormap\n    vec3 colors[max(NUM_VERT_A,NUM_VERT_B)]; \n    //create a color for each vertex\n    for (int i = 0; i < numVertices; i++) {\n        float t = float(i) / float(numVertices-1);\n        colors[i] = plasma(t);\n    }\n    \n    // Normalize fragCoord to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos =uv;\n    \n    \n    //Kinda obvious...\n    vec3 col = vec3(0.0);\n    bool contains = false;\n    \n    //Used for sampling (not containment)\n    vec2 closestEdgeHit = vec2(1e20 -1.0);\n    \n    vec2 v0, v1;\n    \n    //==================\n    //Containment query\n    //==================\n    float SDDistance =  1e20;\n    for(int stop = 4; stop >=0; stop--)\n    {\n        //sample a random direction\n        vec2 rayDir = sampleUniformCircle(uv*float(stop));\n        float minRayT=1e20; //Used to find closest intersection\n        vec2 hit; //Records hit data: ray's t param as x and line's u param as y\n        for (int i = 0; i < numVertices; i++) {\n            if((!renderingFirst && (i==5)) \n                || (renderingFirst && (i==3 || i == 7)) )//Break polygons intentionally\n                continue;\n            v0 = renderingFirst ? verticesA[i] : verticesB[i];\n            v1 = renderingFirst ? verticesA[(i+1)%numVertices] : verticesB[(i+1)%numVertices];\n\n            //If we are contained irrespective of the ray direction we should hit an edge.\n            hit = rayIntersectsSegment(pos, rayDir, v1, v0);\n\n            if (hit.x > 0.0 && hit.x < minRayT) {//However we want the closest hit for next step\n                minRayT = hit.x;\n                if(dot(v1-v0, rayDir) > 0.0)\n                {\n                    contains = true;\n                    closestEdgeHit = pointToLineSegmentDist(pos,v1,v0);\n                    if(closestEdgeHit.x < EPS){//sample color in-case we are closer than EPS (Edge)\n                        //Can be used as a edge contour (observe the thin green line)\n                        col = vec3(0.0,1.0,0.0);//mix(colors[i], colors[(i+1)%numVertices], hit.y);\n                        //contains = false; //Do not go into sampling loop\n                    }\n                }\n                else\n                    contains = false;\n            }\n        }\n        if(contains)\n            SDDistance = min(SDDistance, closestEdgeHit.x);\n    }\n    \n    if(contains)\n    {\n        //===================\n        //Walk on circles Sampling\n        //===================\n        vec2 curDist;\n        vec2 walkDir;\n        for (int stop = 5; stop > 0; stop--)//Lets not break your GPU\n        {   \n            //sample a random direction\n            walkDir = sampleUniformCircle(pos);\n            //walk towards random direction\n            pos += closestEdgeHit.x * walkDir;\n            \n            \n            for (int i = 0; i < numVertices; i++) { //Check against all edges\n                if((!renderingFirst && (i==5)) \n                    || (renderingFirst && (i==3 || i == 7)) )//intentionally break polygon\n                    continue;\n                v0 = renderingFirst ? verticesA[i] : verticesB[i];\n                v1 = renderingFirst ? verticesA[(i+1)%numVertices] : verticesB[(i+1)%numVertices];\n        \n                //get point's distance and interpolant over cur line segment\n                curDist = pointToLineSegmentDist(pos,v0,v1);\n                \n                if (curDist.x < closestEdgeHit.x) //closer edge exists?\n                {\n                    col = mix(colors[i], colors[(i+1)%numVertices], curDist.y);\n                    col = col * (cos(SDDistance * 50. * 6.28318530718) * 0.5 + 0.5); \n                    closestEdgeHit = curDist;\n                }\n            }\n            if(closestEdgeHit.x < EPS)\n                break;\n        }\n    }\n    \n        \n    vec4 prev=texture(iChannel0, uv);\n    prev.w*=0.985;\n    \n    vec4 finalColor = vec4(prev.xyz*prev.w, prev.w) + vec4(col,0.9);\n    fragColor = vec4(finalColor.xyz/finalColor.w, finalColor.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}