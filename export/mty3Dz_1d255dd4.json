{"ver":"0.1","info":{"id":"mty3Dz","date":"1694801898","viewed":91,"name":"Screensaver Ray-Tracer","username":"etlopez","description":"A simple ray tracer","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dir = 1.;\nfloat str = .001;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec4 tex;\n    for(float i = 0.; i < dir; i += 1.){\n        vec2 uv = fragCoord.xy/iResolution.xy;\n        uv += Random2DUnitOffset(rngState) * str;\n        tex += texture(iChannel0,uv);\n    }\n    tex /= dir;\n    \n    vec3 avgRGB = tex.rgb;\n    vec3 avgCorrected = avgRGB/tex.w;\n    vec3 avg = LinearToSRGB(avgCorrected);\n    avg = ACESFilm(avg);\n    fragColor = vec4(avg, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAYS_PER_PX 2\n#define NUM_OF_TRIS 12\n//#define NUM_OF_BOXES 77\n#define NUM_OF_SPHERES 9\n#define BOUNCE_MAX 6\n#define INF 100000000000.\n#define DEPTH 2.5\n#define PI 3.1415\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n    vec3 lightColor;\n    vec3 color;\n    vec3 specularColor;\n    float specularChance;\n    float smoothness;\n    float luminocity;\n    float refractiveIndex;\n};\n\nstruct HitInfo {\n    bool hits;\n    vec3 normal;\n    vec3 hitPoint;\n    float dist;\n    Material mat;\n};\n\nstruct Triangle {\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    Material mat;\n};\n\nstruct Box {\n    vec3 position;\n    vec3 rotation;\n    vec3 boxSize;\n    Material mat;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material mat;\n};\n\nstruct SceneInfo {\n    Triangle tris[NUM_OF_TRIS];\n    Sphere spheres[NUM_OF_SPHERES];\n    //Box boxes[NUM_OF_BOXES];\n};\n\n\nHitInfo rayTri(Ray ray, Triangle tri)\n{\n    vec3 edgeAB = tri.B - tri.A;\n\tvec3 edgeAC = tri.C - tri.A;\n\tvec3 normalVector = cross(edgeAB, edgeAC);\n\tvec3 ao = ray.origin - tri.A;\n\tvec3 dao = cross(ao, ray.direction);\n\tfloat determinant = -dot(ray.direction, normalVector);\n\tfloat invDet = 1./ determinant;\n\tfloat dst = dot(ao, normalVector) * invDet;\n\tfloat u = dot(edgeAC, dao) * invDet;\n\tfloat v = -dot(edgeAB, dao) * invDet;\n\tfloat w = 1. - u - v;\n\tHitInfo hitInfo;\n\thitInfo.hits = determinant >= 1E-6 && dst >= 0. && u >= 0. && v >= 0. && w >= 0.;\n\thitInfo.hitPoint = ray.origin + ray.direction * dst;\n\thitInfo.normal = normalize(normalVector);\n    hitInfo.mat = tri.mat;\n\thitInfo.dist = dst;\n\treturn hitInfo;\n}\n\nHitInfo rayBox(Ray ray, Box obj)\n{\n    HitInfo hit;\n    vec3 FromToTarget = ray.origin - obj.position;\n    FromToTarget *= rotateX(obj.rotation.x);\n    FromToTarget *= rotateY(obj.rotation.y);\n    FromToTarget *= rotateZ(obj.rotation.z);\n    vec3 ro = FromToTarget;\n    \n    \n    vec3 rd = ray.direction;\n    rd *= rotateX(obj.rotation.x);\n    rd *= rotateY(obj.rotation.y);\n    rd *= rotateZ(obj.rotation.z);\n    \n    \n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*obj.boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        hit.hits = false;\n        return hit;\n    } else {\n        if (tN >= 0.00001) {\n            hit.hits = true;\n        \thit.normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            hit.normal *= rotateX(obj.rotation.x);\n            hit.normal *= rotateY(obj.rotation.y);\n            hit.normal *= rotateZ(obj.rotation.z);\n            hit.dist = tN;\n            hit.hitPoint = ray.origin + ray.direction*hit.dist;\n            hit.mat = obj.mat;\n            return hit;\n        } else if (tF >= 0.00001) {\n            hit.hits = true;\n        \thit.normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            hit.normal *= rotateX(obj.rotation.x);\n            hit.normal *= rotateY(obj.rotation.y);\n            hit.normal *= rotateZ(obj.rotation.z);\n            hit.dist = tF;\n            hit.hitPoint = ray.origin + ray.direction*hit.dist;\n            hit.mat = obj.mat;\n            return hit;\n        } else {\n            hit.hits = false;\n            return hit;\n        }\n    }\n}\n\n\nHitInfo raySphere(Ray ray, Sphere obj)\n{\n    HitInfo hit;\n    hit.hits = false;\n    vec3 offset = ray.origin - obj.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2. * dot(offset, ray.direction);\n    float c = dot(offset, offset) - obj.radius * obj.radius;\n    float discrim = b * b - 4. * a * c;\n    if(discrim >= 0.){\n        float dist = (-b - sqrt(discrim))/(2.*a);\n        if(dist >= 0.){\n            hit.hits = true;\n            hit.dist = dist;\n            hit.hitPoint = ray.origin + (ray.direction * hit.dist);\n            hit.normal = normalize(hit.hitPoint - obj.position);\n            hit.mat = obj.mat;\n            \n            vec3 n = normalize(hit.hitPoint - obj.position);\n            float u = atan2(n.x, n.z) / (2.*PI) + 0.5;\n            float v = n.y * 0.5 + 0.5;\n            vec2 uv = vec2(u, v);\n            hit.mat.luminocity = hit.mat.luminocity;\n            \n        }\n    }\n    return hit;\n    \n}\n\n\n\n    \n\nHitInfo CalculateHit(Ray ray, SceneInfo scene)\n{\n    HitInfo closestHit;\n    closestHit.dist = INF;\n    \n    for(int i = 0; i < NUM_OF_SPHERES; i ++){\n        HitInfo hit = raySphere(ray, scene.spheres[i]);\n        if(hit.hits && closestHit.dist > hit.dist){\n            closestHit = hit;\n        }\n    }\n    \n    for(int t = 0; t < NUM_OF_TRIS; t ++){\n        HitInfo hit = rayTri(ray, scene.tris[t]);\n        if(hit.hits && closestHit.dist > hit.dist){\n            closestHit = hit;\n        }\n    }\n    \n    //for(int b = 0; b < NUM_OF_BOXES; b ++){\n    //    HitInfo hit = rayBox(ray, scene.boxes[b]);\n    //    if(hit.hits && closestHit.dist > hit.dist){\n    //        closestHit = hit;\n    //    }\n    //}\n    \n    \n    \n    \n    return closestHit;\n}\n\n\n \n\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 6.28318530718;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 lerp(vec3 color1, vec3 color2, float value)\n{\n\treturn (color1 + value*(color2-color1));\n}\n\nvec3 Trace(Ray ray, SceneInfo objs, inout uint rngState)\n{\n    vec3 color = vec3(1);\n    vec3 light = vec3(0);\n    for(int i = 0; i < BOUNCE_MAX; i ++){\n        HitInfo hit = CalculateHit(ray, objs);\n        if(hit.hits){\n            ray.origin = hit.hitPoint;\n            vec3 diffuseDir = normalize(hit.normal + RandomUnitVector(rngState));\n            vec3 specularDir = reflect(ray.direction, hit.normal);\n\n            float isSpecularChance = RandomFloat01(rngState);\n            float specularChance = hit.mat.specularChance;\n            if (hit.mat.specularChance > 0.0)\n            {\n                specularChance = FresnelReflectAmount(\n                    1.0,\n                    hit.mat.refractiveIndex,\n                    ray.direction, hit.normal, hit.mat.specularChance, 1.0f);  \n            }\n            float isSpecular = (isSpecularChance < specularChance) ? 1.0 : 0.0;\n            specularDir = lerp(diffuseDir, specularDir, hit.mat.smoothness);\n            ray.direction = lerp(diffuseDir, specularDir, isSpecular);\n            \n            \n\n            vec3 emittedLight = hit.mat.luminocity * hit.mat.lightColor;\n            light += emittedLight * color;\n            color *= lerp(hit.mat.color.rgb, hit.mat.specularColor.rgb, isSpecular);\n            \n        }else{\n            break;\n        }\n    }\n    return light;\n}\n\nSceneInfo scene = SceneInfo(\n    Triangle[NUM_OF_TRIS](\n        Triangle(\n        vec3(-1, 1, 0), \n        vec3(-1, 1, DEPTH), \n        vec3(-1, -1, DEPTH),\n        Material(vec3(0.), vec3(1), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, 1, 0), \n        vec3(-1, -1, DEPTH), \n        vec3(-1, -1, 0),\n        Material(vec3(0.), vec3(1), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, 1, DEPTH), \n        vec3(1, -1, DEPTH), \n        vec3(-1, -1, DEPTH),\n        Material(vec3(0.), vec3(0, 0, .8), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, 1, DEPTH), \n        vec3(1, 1, DEPTH), \n        vec3(1, -1, DEPTH),\n        Material(vec3(0.), vec3(0, 0, .8), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(1, 1, 0), \n        vec3(1, -1, DEPTH),\n        vec3(1, 1, DEPTH),\n        Material(vec3(0.), vec3(1), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(1, -1, 0), \n        vec3(1, -1, DEPTH),\n        vec3(1, 1, 0),\n        Material(vec3(0.), vec3(1), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, -1, 0),\n        vec3(1, -1, DEPTH), \n        vec3(1, -1, 0),\n        Material(vec3(0.), vec3(1), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, -1, DEPTH),\n        vec3(1, -1, DEPTH), \n        vec3(-1, -1, 0),\n        Material(vec3(0.), vec3(1), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(1, 1, DEPTH), \n        vec3(-1, 1, 0),\n        vec3(1, 1, 0),\n        Material(vec3(0.), vec3(0, .8, 0), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, 1, DEPTH),\n        vec3(-1, 1, 0),\n        vec3(1, 1, DEPTH), \n        Material(vec3(0.), vec3(0, .8, 0), vec3(1), 0., 0., 0., 1.)),\n        \n        \n        Triangle(\n        vec3(-1, 1, 0), \n        vec3(-1, -1, 0),\n        vec3(1, -1, 0),\n        Material(vec3(0.), vec3(.8, 0, 0), vec3(1), 0., 0., 0., 1.)),\n        \n        Triangle(\n        vec3(-1, 1, 0), \n        vec3(1, -1, 0),\n        vec3(1, 1, 0),\n        Material(vec3(0.), vec3(.8, 0, 0), vec3(1), 0., 0., 0., 1.))\n    ), \n    Sphere[NUM_OF_SPHERES](\n        Sphere(\n        vec3(0, 1, 1.25),\n        .1,\n        Material(vec3(1), vec3(0), vec3(1), 0., 1., 20., 1.)),\n        \n        Sphere(\n        vec3(0, 0, .5),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), 1., 1., 0., 1.)),\n        \n        Sphere(\n        vec3(0, 0, 1),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), 1., 0.6, 0., 1.)),\n        \n        Sphere(\n        vec3(0, 0, 1.5),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), 1., 0.3, 0., 1.)),\n        \n        Sphere(\n        vec3(0, 0, 2),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), 1., 0., 0., 1.)),\n        \n        Sphere(\n        vec3(0, -.5, .5),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), 1., 1., 0., 1.)),\n        \n        Sphere(\n        vec3(0, -.5, 1),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), .6, 1., 0., 1.)),\n        \n        Sphere(\n        vec3(0, -.5, 1.5),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), .3, 1., 0., 1.)),\n        \n        Sphere(\n        vec3(0, -.5, 2),\n        .2,\n        Material(vec3(0), vec3(1), vec3(1), 0., 1., 0., 1.))\n    )\n        \n    //Box[NUM_OF_BOXES](\n        \n        \n    //)\n);\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    bool reset = iFrame == 0;\n    vec4 m = iMouse / iResolution.x;\n    if (iMouse.z > 0.) {\n        reset = true;\n    }\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    const uint raysPerPixel = uint(RAYS_PER_PX);\n    \n    vec2 uv;\n    vec3 totalLight = vec3(0);\n    for(uint i = 0u; i <= raysPerPixel; i ++){\n        float blurStrength = 0.;\n        float FOVPlaneDist = (DEPTH);\n        \n        \n        uv = (fragCoord.xy) / (iResolution.xy);\n        uv -= 0.5;\n        uv.x *= iResolution.x / iResolution.y;\n        vec3 blurOffset = vec3(Random2DUnitOffset(rngState)*blurStrength, 0);\n        vec3 rayOrigin = vec3(0, 0, -1);\n        vec3 target = vec3(0, 0, DEPTH/2.);\n        vec3 rayDirection = vec3(uv, 0) - (rayOrigin);\n        float rotX = (iResolution.y/2. - iMouse.y)/iResolution.y * 2.;\n        float rotY = (iMouse.x - iResolution.x/2.)/iResolution.y * 4.;\n        \n        \n        vec3 FOVPlane = rayOrigin + rayDirection * FOVPlaneDist;\n        rayOrigin += blurOffset;\n        rayDirection = normalize(FOVPlane - rayOrigin);\n        \n        vec3 FromToTarget = rayOrigin - target;\n        FromToTarget *= rotateX(rotX);\n        FromToTarget *= rotateY(rotY);\n        rayOrigin = FromToTarget + target;\n        \n        rayDirection *= rotateX(rotX);\n        rayDirection *= rotateY(rotY);\n        \n        Ray currentRay = Ray(rayOrigin, rayDirection);\n        totalLight += Trace(currentRay, scene, rngState);\n    }\n    \n    \n    vec3 newRender = totalLight/float(RAYS_PER_PX);\n    uv = fragCoord.xy / iResolution.xy;\n    vec4 oldRender = texture(iChannel0,uv);\n    vec4 avg; \n    if (reset) {\n        fragColor = vec4(newRender, 1.);\n    } else {\n        fragColor = oldRender+vec4(newRender, 1.);\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"uint rngState;\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 Random2DUnitOffset(inout uint state)\n{\n    return vec2((RandomFloat01(state)*2.) - 1., (RandomFloat01(state)*2.) - 1.);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        \n        return mix(f0, f90, ret);\n}\n\nfloat frame;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat casin(float x) {\n\tfloat negate = float(x < 0.0);\n\tx = abs(x);\n\tfloat ret = -0.0187293;\n\tret *= x;\n\tret += 0.0742610;\n\tret *= x;\n\tret -= 0.2121144;\n\tret *= x;\n\tret += 1.5707288;\n\tret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\n\treturn ret - 2.0 * negate * ret;\n}\n\nfloat atan2(float y, float x) {\n \tfloat absx, absy, val;\n \n     if (x == 0.0 && y == 0.0) {\n \t\treturn 0.0;\n \t}\n \tabsy = y < 0.0 ? -y : y;\n \tabsx = x < 0.0 ? -x : x;\n \tif (absy - absx == absy) {\n \t\treturn y < 0.0 ? -3.1415*2.0 : 3.1415*2.0;\n \t}\n    \n    if (absx - absy == absx) {\n\t\tval = 0.0;\n    } else {\n        val = casin((y/x)/sqrt(1.0+((y/x)*(y/x))));\n    }\n \tif (x > 0.0) {\n \t\treturn val;\n \t}\n \tif (y < 0.0) {\n\t\treturn val - 3.1415;\n \t}\n \treturn val + 3.1415;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n}","name":"Buffer B","description":"","type":"buffer"}]}