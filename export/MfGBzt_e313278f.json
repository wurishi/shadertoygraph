{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float PI=3.14159265358979323846;\n\n// 模拟获取图像纹理\nvec4 source_texture(vec2 uv){\n    uv = uv * 2.0 - 1.0;\n    // 计算当前点到原点的距离\n    float dist = length(uv);\n    // 圆环的内径和外径\n    float outerRadius = 0.5;\n    // 圆环的颜色\n    vec3 ringColor = vec3(.6, 0.0, 0.0); \n    // 背景颜色\n    vec3 backgroundColor = vec3(0.2, 0.2, 0.2); \n\n    // 判断当前点是否在圆环内\n    if (dist <= outerRadius) {\n        return vec4(ringColor, 1.0);\n    } else {\n        return vec4(backgroundColor, 1.0);\n    }\n}\n// 计算绿幕边缘梯度\nfloat gradient(vec2 uv, vec2 delta, vec4 filterCol){\n    vec2 dir[8] = vec2[8](vec2(0,1),vec2(0,-1),vec2(1,1),vec2(1,-1),vec2(1,0),vec2(-1,-1),vec2(-1,0),vec2(-1,1));\n    float grad = -8. * distance(source_texture(uv), filterCol);\n    for(int i = 0; i < 8; i++){\n        grad += distance(source_texture(uv+dir[i]*delta), filterCol);\n    }\n    return grad;\n}\n// 将弧度值按照周期2 * Pi映射回[0, 2 * Pi)区间的函数\nfloat mapTo2PiRange(float angleInRadians) {\n    float twoPi = 2.0 * PI;  // 定义2 * Pi的值，也可以使用内置的常量如TAU（如果GLSL版本支持）\n    angleInRadians = mod(angleInRadians, twoPi);  // 使用取模运算，将角度对2 * Pi取模\n    if (angleInRadians < 0.0) {\n        angleInRadians += twoPi;  // 如果取模后结果为负，加上2 * Pi使其回到[0, 2 * Pi)区间\n    }\n    return angleInRadians;\n}\n// 遮罩\nfloat rotate_shadow_mask(vec2 uv, float start,float len){\n    uv -= vec2(0.5,0.5);\n    float theta = atan(uv.y, uv.x);\n    if (theta < 0.0) {\n        theta += 2.0 * 3.14159265358979323846;\n    }\n    start = mapTo2PiRange(start);\n    if(start + len > 2. * PI){\n        if(start < theta) return 1.;\n        if(theta < start + len - 2.*PI) return 1.;\n        return 0.;\n    }\n    if(start < theta && theta < start + len) return 1.;\n    return 0.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;;\n    \n    // 参数\n    vec4 outline_color = vec4(\n        sin(uv.x+iTime) / 2.0 + 0.5,\n        sin(uv.y+iTime) / 2.0 + 0.5,1.,1.0);\n    float width = 10.0;\n    \n    // 计算梯度\n    const vec4 GREEN = vec4(0,1,0,1);\n    float grad = gradient(uv,width/iResolution.xy, GREEN);\n    grad = step(grad,0.3);\n    \n    // 绘制边缘, 增加遮罩\n    vec3 edge_color = mix(outline_color.rgb, vec3(0.),clamp(grad,0.3,1.));\n    edge_color = edge_color * rotate_shadow_mask(uv, iTime*3., radians(270.0));\n    \n    // 绘制原图像\n    vec3 source_color = source_texture(uv).rgb;\n    \n    // 直接叠加\n    fragColor = vec4(edge_color + source_color, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MfGBzt","date":"1735129052","viewed":19,"name":"边缘 + 圆周遮罩","username":"esuala","description":"绿幕边缘梯度 + 遮罩","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""}}