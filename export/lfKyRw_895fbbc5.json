{"ver":"0.1","info":{"id":"lfKyRw","date":"1731645964","viewed":37,"name":"colors#1","username":"yohei_gnr","description":"Shaders with colorful fluid mixing.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["colorfulfluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    \n    float dropInterval = 3.0;\n    float dropTime = mod(iTime, dropInterval);\n    vec2 dropPos = random2(floor(vec2(iTime / dropInterval)));\n    \n    if (dropTime < 1.5) { \n        float dist = length(pos - dropPos);\n        float ripple = sin(dist * 30.0 - dropTime * 5.0) * exp(-dist * 10.0);\n        float fade = smoothstep(1.5, 0.0, dropTime); \n        pos += vec2(ripple, ripple) * 0.5 * fade;\n    }\n    \n    vec4 color = texture(iChannel0, pos);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\n\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * (pnoise21(p * frequency) - 0.5);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    pos -= 0.5;\n    \n    float noise = fbm(pos * 5.0 + iTime * 0.1);\n    pos += vec2(noise, noise) * 0.5;\n    \n    float angle = iTime * 0.5;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    \n    float centerFactor = 1.0 - 0.5 * sin(iTime * 0.5);\n    \n    mat2 rotation = mat2(cosA, -sinA, sinA, cosA);\n    \n    vec2 posA = rotation * vec2(0.5, 0.0) * centerFactor; // Red\n    vec2 posB = rotation * vec2(0.35, 0.35) * centerFactor + 0.1; // Orange\n    vec2 posC = rotation * vec2(0.0, 0.5) * centerFactor - 0.1; // Yellow\n    vec2 posD = rotation * vec2(-0.35, 0.35) * centerFactor + 0.05; // Green\n    vec2 posE = rotation * vec2(-0.5, 0.0) * centerFactor - 0.05; // Blue\n    vec2 posF = rotation * vec2(-0.35, -0.35) * centerFactor + 0.2; // Purple\n    vec2 posG = rotation * vec2(0.0, -0.5) * centerFactor - 0.2; // Pink\n    \n    float distA = length(pos - posA);\n    float distB = length(pos - posB);\n    float distC = length(pos - posC);\n    float distD = length(pos - posD);\n    float distE = length(pos - posE);\n    float distF = length(pos - posF);\n    float distG = length(pos - posG);\n    \n    float weightA = 1.0 / pow(distA, 3.0);\n    float weightB = 1.0 / pow(distB, 3.0);\n    float weightC = 1.0 / pow(distC, 3.0);\n    float weightD = 1.0 / pow(distD, 3.0);\n    float weightE = 1.0 / pow(distE, 3.0);\n    float weightF = 1.0 / pow(distF, 3.0);\n    float weightG = 1.0 / pow(distG, 3.0);\n    float totalWeight = weightA + weightB + weightC + weightD + weightE + weightF + weightG;\n    \n    vec3 colorA = vec3(1.0, 0.2, 0.2); // Red\n    vec3 colorB = vec3(0.93, 0.47, 0.0); // Orange\n    vec3 colorC = vec3(1.0, 0.87, 0.0); // Yellow\n    vec3 colorD = vec3(0.0, 0.66, 0.37); // Green\n    vec3 colorE = vec3(0.2, 0.6, 1.0); // Blue\n    vec3 colorF = vec3(0.61, 0.45, 0.7); // Purple\n    vec3 colorG = vec3(0.87, 0.52, 0.64); // Pink\n    \n    vec3 col = (colorA * weightA + colorB * weightB + colorC * weightC +\n                colorD * weightD + colorE * weightE + colorF * weightF +\n                colorG * weightG) / totalWeight;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}