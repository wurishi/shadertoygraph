{"ver":"0.1","info":{"id":"NstyRj","date":"1653755867","viewed":75,"name":"Mandelbrot fractal zoom hue anim","username":"elidoz","description":"The Mandelbrot fractal, It zooms to a chosen position and other parameters, you can change the parameters if you want, I left them all there.\n(you can remove the hue animation if you want by making hueSpeed be zero and changing the other hue parameters)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I made this Mandebrot fractal zoom, it works but it reaches the 32bit limit pretty fast\n// (about 1 minute with the settings I put), and I have no idea how to make it 64bit if it's possible\n\n// I left here a series of parameters for you to play with it\n\nfloat zoomSpeed = 0.3; // The camera doesn't move if this is 0, else it moves to the zoom position\nvec2 zoomPosition = vec2(0.38910015, 0.38910015); // Complex position where the zoom happens\nint iterationLimit = 500; // The more this is the more the fractal is precise, but slower\nfloat hueStart = 0.66; // Starting hue (hue goes from 0 to 1)\nfloat hueSpeed = 0.03; // Speed hue changes with (can be negative)\nfloat hueDiversity = 0.02; // How much hue changes between consecutive bands (can also be negative)\n\n\n\nvec3 Hsv2Rgb(vec3 c) // Used to convert my hsv color choice to rgb (I copy-pasted this because I know\n                     // too little about how colors and the different formats work)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 Iteration2Color(int i) // Used to give colors to pixel based on the number of iterations before\n                            // exiting the fractal\n{\n    float I = float(i);\n    \n    vec3 colHsv = vec3((I-1.0)*hueDiversity+iTime*hueSpeed+hueStart, 1.0, I/(I+0.5));\n    vec3 col = Hsv2Rgb(colHsv);\n    \n    return(col);\n}\n\nvec2 MandelbrotIterate(vec2 Z, vec2 C) // Z^2 + C where Z and C are complex numbers: the heart of the\n                                       // fractal calculations\n{\n    vec2 M = vec2 (Z.x*Z.x - Z.y*Z.y + C.x,\n                   2.0*Z.x*Z.y + C.y);\n    return(M);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    \n    // Trasformed pixel coordinates (from -2 to 2 in the shortest coordinate, the other one is chosen\n    // accordingly to make proportions hold)\n    p = p * 4.0;\n    p = p - vec2(2.0, 2.0);\n    p = vec2(p.x*max(iResolution.x/iResolution.y,iResolution.y/iResolution.x), p.y);\n    \n    // Moving the camera\n    float ts = iTime * zoomSpeed;            // Here I'm transitiong from a smoothstep zoom speed to a\n    float zoom = max(-4.0/27.0 * ts*ts*ts*ts // linear speed in the first seconds (I had to use\n                     +4.0/9.0 * ts*ts*ts,    // calculus to not slip any deceleration through, so I\n                     ts - 0.75);             // had to write the expanded version of the calculations)\n    \n    p /= exp(zoom);\n    p += zoomPosition*(1.0-exp(-2.0*zoom));\n    \n    // Background and Mandelbrot color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // Calculate number of iteration before exiting the fractal, up to a limit (at the top of the code)\n    int iteration = 0;\n    vec2 iterationP = p;\n    for(int i = 0; i < iterationLimit; i++)\n    {\n        iteration = i;\n        if(length(iterationP) <= 2.0)\n        {\n            iterationP = MandelbrotIterate(iterationP, p);\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    // Color the fractal\n    if(iteration < iterationLimit-1)\n    {\n        col = Iteration2Color(iteration);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}