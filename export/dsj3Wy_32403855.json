{"ver":"0.1","info":{"id":"dsj3Wy","date":"1668343341","viewed":119,"name":"Bezier Quadric Approx","username":"spalmer","description":"demonstrating how to compute approximate bezier closest point, distance in one of the most efficient ways.\nspecial thanks to Hughes Hoppe and iq and iapafoto!  And Loop & Blinn.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier","approximation","spline","curve","quadratic","parabola","subdivide"],"hasliked":0,"parentid":"3tsczH","parentname":"Bezier Quadric"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// can try approximations if you think you can get away with it!\n\n// FIXME method breaks when all points totally colinear, such as at iTime==0.0\n\n// the goal here is to analyze Hughes Hoppe's quadratic bezier spline approximation\n// and those derived from it (iq's)\n// also a place to put my older subdividing schemes\n// and possibly use as an initial estimate for Newton-Raphson refinement.\n// also a place to experiment with affine transformation to the standard y=x*x parabola\n// Most code is in Common tab.\n\n// copy of indexApproxIq, so far is the best I've got\n// iq http://shadertoy.com/view/MlKcDD\nfloat indexApproxWIP(vec2 v0, vec2 v1, vec2 v2)\n{\n    float x = det(v0, v2), y = det(v1, v0), z = det(v2, v1);\n    vec2 i = v0 - v2, j = v2 - v1, k = v1 - v0, s = 2.*(y*j + z*k) - x*i;\n    return (.5*x + y + dot(s, j - k) * (y*z - x*x*.25) / dot(s, s)) / (x + y + z);\n}\n// sorry about the wrapper nesting, I have wrappers that bypass or shunt to other wrappers, \n// which cluster my tests in various ways that made sense to me at one point or another.\nfloat indexApproxWrap1(vec2 p, QuadricBezier q)\n{\n    return indexApproxWrap2(p, q); // stuff in Common\n    // shift p to origin and use loose points for all these\n    // which all implement the same approximator slightly differently\n    return\n        indexApproxWIP\n        (q.a - p, q.b - p, q.c - p);\n}\n\n// this and most called index wrappers return unclamped index of closest point on spline q to p\nfloat indexApprox(vec2 p, QuadricBezier q)\n{\n    return indexApproxWrap1(p, q);\n}\n// return index of closest point on q to p\n// t useful with Eval(t, q) or EvalTangent(t, q)\nfloat indexApproxClamp(vec2 p, QuadricBezier q)\n{\n    return clamp(indexApprox(p, q), 0., 1.);\n}\n\nvec2 Snap(vec2 p, QuadricBezier q)\n{\n    return Eval(indexApproxClamp(p, q), q);\n}\n\nvec2 Normal(vec2 p, QuadricBezier q) \n{\n    float t = indexApprox(p, q);\n    vec2 v = p - Eval(t, q);\n    float dd = dot(v, v);\n    if (dd > 1e-8) // if p not exactly on curve q\n        v *= -inversesqrt(abs(dd)); // v = normalize(-v);\n    else // must obtain using derivative of curve instead\n        v = EvalNormal(t, q);\n    return v;\n\t//return normalize(p - Snap(p, q));\n}\n\n// returns (possibly signed) squared distance\nfloat DistanceSquared(vec2 p, QuadricBezier q) \n{\n    vec2 v = p - Snap(p, q); \n    return dot(v, v); // sqr(v)\n}\n\nfloat Distance(vec2 p, QuadricBezier q) \n{\n//    return sqrt(DistanceSquared(p, q));\n    // expect and handle signed squared distance and propagate the sign to the result\n    float dd = DistanceSquared(p, q);\n    return sqrt(abs(dd)) * sign(dd);\n}\t\t\n\nfloat signBezier(vec2 p, QuadricBezier q, float t)\n{\n     return det(EvalTangent(t, q), p - Eval(t, q));\n} \n\nfloat d2cage(vec2 p, QuadricBezier q)\n{\n    vec2 mp = Mid(q);\n    float d1 = d2seg(p, q.a, q.b)\n        , d2 = d2seg(p, q.b, q.c)\n    //, d3 = d2seg(p, q.b, mp)\n    //, d3 = d2seg(p, q.a, mp)\n    //, d4 = d2seg(p, mp, q.c)\n    //, d5 = d2approx1(p, q)\n    ;\n    return min(d1, d2);\n}\n\n// \"standard\"-ish sdf gradient debugging    \nvec3 DebugSDF(float d)\n{\n    vec3 c = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tc *= 1. - exp2(-3. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n    return c;\n}\n\n#define R  iResolution.xy\n\nvec2 viewport(vec2 s)\n{\n    return (2.*s-R)*.6/R.y;\n}\n\nfloat aa(float d)\n{\n    return clamp(.5 + .4*R.y*d, 0., 1.);\n}\n\nconst vec2 spin = vec2(0,11); //0,.5*acos(-1.));\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 q = viewport(p)\n    , m = viewport(iMouse.xy);\n    float anim = .2 * (iTime + 0.);\n    vec2 p0 = vec2(-.5, .5),\n      p1 = vec2(sin(anim), -.5),\n      p2 = vec2(1, 0);\n    p0 = .95 * sin(spin + 1.1*anim) * vec2(1,.5);\n    p1 = .97 * sin(spin + 3. *anim) * vec2(1,.5);\n    p2 = .99 * sin(spin - 2.2*anim) * vec2(1,.5);\n    QuadricBezier bez = QuadricBezier( //From3Points( //\n        p0, p1, p2);\n    \n\tvec2 cm = Snap(m, bez)\n       , cq = Snap(q, bez)\n       , nq = Normal(q, bez);\n    float curve = Distance(q, bez)\n    , dmq = d2seg(q, m, cm)\n    , dcage = d2cage(q, bez)\n    , d = sqrt(min(dcage, dmq))\n    //, d = sqrt(dcage)\n    ;\n    float qs = sign(signBezier(q, bez, indexApprox(q, bez)));\n    curve *= -qs;\n    \n    // visualize this point - why is it way over there?!\n    vec2 i = p0 - p2,\n         j = p2 - p1,\n         k = p1 - p0;\n    float x = det(p0, p2),\n          y = det(p1, p0),\n          z = det(p2, p1);\n    //vec2 s = 2.*(y*j + z*k) - x*i;\n    vec2 s = 4.*y*j + 4.*z*k - 2.*x*i; // term that arises in the approximation formulation, that I don't fully yet understand, something to do with the inversion of implicit form using cramer's rule\n    \n    float at = ApexIndex(bez);\n    at = clamp(at, 0., 1.);\n    vec2 ap = Eval(at, bez); // apex of parabola, because it's important\n\n    vec2 pp = bez.a - 2.*bez.b + bez.c; // quadratic term of polynomial form\n    float ppl = length(pp);\n    pp /= ppl; //pp = normalize(pp);\n\n    // some redundant computations here on pp\n    float pz = FocalLength(bez) * 4.; // compute eccentricity // that actually seems right, or almost right most of the time\n    float px = det(q - ap, pp);\n    float py = dot(q - ap, pp);\n    py *= pz; // scale by eccentricity or the quadratic factor of the parabola\n    \n    vec3 c = DebugSDF(curve * 3.);\n    //c *= vec3(sqrt(nq * .5 + .5), 1); // show normal, brightened - with these inaccuracies, it tends to just add visual confusion\n    c = mix(vec3(.5,1,.5), c, aa(d)); // debug lines green\n    c *= clamp(abs(py - px*px)*.25*R.y/pz, 0., 1.); // show a parabola\n    \n    c = mix(vec3(1), c, aa(abs(curve) - 2./R.y)); //smoothstep(.0,.00666,abs(curve))); // stroke curve white\n    c = mix(vec3(.5,0,0), c, aa(.4*abs(distance(q, m)-distance(m, cm)))); // show circle red\n//    c = mix(vec3(.9,0,.9), c, aa(length(q - s) - 4./R.y)); // debug dot magenta - I can't understand what it means this way\n    c = mix(vec3(0,0,.8), c, aa(length(q - ap) - 4./R.y)); // debug dot blue\n    o = vec4(sqrt(c), 1); // approximately sRGB gamut output\n}\n    //vec2 m = Mid(bez); //Eval(.5, bez); //\n    //m = mix(mix(bez.a, bez.b,.5),mix(bez.b,bez.c,.5),.5); // same point\n    //m = mix(mix(bez.a, bez.c,.5),bez.b,.5); // also same point\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sqr(float x) { return x * x; }\nfloat sqr(vec2  x) { return dot(x, x); }\n\nfloat sgn(float x) { return x < 0. ? -1. : 1.; } // signum\n\nvec2 perp(vec2 q)\n{\n    return vec2(q.y, -q.x);\n}\n\n// antisymmetric product\nfloat det(vec2 a, vec2 b) // aka cross2 or det 2x2\n{\n    //return determinant(mat2(a, b)); // is glsl intrinsic!\n    //return dot(a, perp(b));\n    return a.x*b.y - a.y*b.x;\n    //return dot(a, vec2(1,-1)*b.yx);\n}\n// 2x2 determinant = 2d cross product = perpendicular 2d dot product\n//#define pdot det\n// Hoppe called it det as it's the determinant of the 2x2 matrix\n// iq called it cro\n// iapafoto called it U\n// det(r1, r2) := determinant(matrix(r1, r2)); // in Maxima\n\n/*\n// branchless by spalmer\nvec2 Quadratic(vec3 k)\n{\n    float c = k.x, b = k.y, a = k.z;\n    return .5 / a * (sign(a) * sqrt(b * b - 4. * a * c) * vec2(-1, 1) - b);\n}\n*/\n// a quadratic bezier struct\nstruct QuadricBezier\n{\n\tvec2 a, b, c;\n};\n\n// support 'methods'\n// compute polynomial p[1]*t + p[0]\nvec2 eval(float t, in vec2 p[2])\n{\n    return p[1] * t + p[0];\n}\n\nvec2 eval(float t, in vec2 p[3])\n{\n    return (p[2] * t + p[1]) * t + p[0];\n}\n\nvec2 eval(float t, in vec2 p[4])\n{\n    return ((p[3] * t + p[2]) * t + p[1]) * t + p[0];\n}\n\nvec2 eval2(float t, in vec2 p[3])\n{\n    //return eval(t*t, p); // NO\n    vec2 r = eval(t, p); return r*r;\n    //return sqr(eval(t, p)); // NO\n}\n\n// t from 0 to 1\nvec2 Eval(float t, QuadricBezier q)\n{\n    float mt = 1.-t;\n\treturn q.a * mt * mt + q.b * (2. * t * mt) + q.c * t * t;\n}\n// same as\n// ((c-2.*b+a)*t + 2.*(b-a))*t + a\n// returns polynomial suitable for use by eval2\n\nvec2[3] AsPolynomial(QuadricBezier q)\n{\n    return vec2[3](\n        q.a,\n        2.*(q.b - q.a),\n        q.c - 2.*q.b + q.a\n    );\n}\n\n// according to wikipedia,\n// the t^2 part of that should be a vector\n// parallel to one from the vertex that divides the parabola in equal halves.\n\n// but once you get it in polynomial form,\n// can then convert to canonical parabola y = x*x\n// by determining the appropriate scaling factors\n\n// find the central point on curve\nvec2 Mid(QuadricBezier q)\n{\n\treturn .25 * (q.a + 2.*q.b + q.c);\n}\n\n// seems to me like the first problem is determining\n// the t index of the apex of the parabola it's an arc of\n// Wikipedia to the rescue!  tyvm  http://en.wikipedia.org/wiki/Parabola#As_the_affine_image_of_the_unit_parabola, vertex\n    //return -1. / 2. * dot(2. * (q.b - q.a), v) / dot(v, v);\n// not clamped to the 0..1 index range btw\nfloat ApexIndex(QuadricBezier q)\n{\n    vec2 v = q.a - 2.*q.b + q.c;\n    return dot(q.a - q.b, v) / dot(v, v);\n}\n// can easily test which half a point is in by sign of dot of\n// difference vs. apex point with the tangent at the apex index\n// at that point can decompose the entire problem relative to the apex\n// http://en.wikipedia.org/wiki/Parabola#As_the_affine_image_of_the_unit_parabola, focal length and focus\nfloat FocalLength(QuadricBezier q)\n{    \n    vec2 f1 = 2.*(q.b - q.a), f2 = q.a - 2.*q.b + q.c;\n    float s1 = dot(f1, f1), s2 = dot(f2, f2), sd = dot(f1, f2);\n    return (s1*s2 - sd*sd) / (4.*sqrt(s2)*s2);\n}\n/*\nSolving parametric representation for t, t^2 by Cramer's rule and using tâ‹…t âˆ’ t^2 = 0, get implicit representation\n    det(x âˆ’ f0, f2)^2 âˆ’ det(f1, x âˆ’ f0) * det(f1, f2) = 0\nWell heck that must be how Loop & Blinn did what Hoppe based from!\n*/\n\nvec2 EvalTangent(float t, QuadricBezier q) \n{\n    return 2. * mix(q.b - q.a, q.c - q.b, t);\n}\n\n// in 2d I could either do the perp to the tangent (easy)\n// or compute the 2nd derivative of the curve (harder but doable)\n// not clamped to the 0..1 index range btw\nvec2 EvalGradient(float t, QuadricBezier q)\n{\n    return -perp(EvalTangent(t, q));\n}\n// TODO probably a more direct way to compute it\nvec2 EvalNormal(float t, QuadricBezier q)\n{\n    return normalize(EvalGradient(t, q));\n//    return normalize(-perp(EvalTangent(t, q)));\n}\n\n// convert 3 consecutive points on curve to a quadratic bezier control points\nQuadricBezier From3Points(vec2 a, vec2 b, vec2 c)\n{\n    return QuadricBezier(a, 2.*b - a - c, c);\n}\n\n// FIXME why my subdivision scheme fails, very inaccurate;\n// TODO would work better if I could find the apex of the parabola instead of the Mid of the bezier\n// but then would have remapping problems and it wouldn't break the curve in half anymore.\nbool WhichHalf(vec2 p, QuadricBezier q)\n{   \n    vec2 mp = Mid(q)\n    , pv = EvalTangent(.5, q);\n\treturn dot(p - mp, pv) > 0.;\n}\n\n// from 0 to .5\nQuadricBezier LowerHalf(QuadricBezier q)\n{\n    return QuadricBezier(q.a, (q.a + q.b) * .5, Mid(q));\n}\n// from .5 to 1\nQuadricBezier UpperHalf(QuadricBezier q)\n{\n    return QuadricBezier(Mid(q), (q.b + q.c) * .5, q.c);\n}\n\nfloat indexApproxLinear(vec2 a, vec2 b)\n{\n    b -= a;\n    return -dot(a, b) / dot(b, b);\n}\n\nfloat indexApproxSeg(vec2 a, vec2 b)\n{\n    return clamp(indexApproxLinear(a, b), 0., 1.);\n}\n\n// index of q along the segment from origin to d\nfloat iseg(vec2 q, vec2 d)\n{\n    return clamp(dot(q,d) / dot(d,d), 0., 1.);\n}\n\n// squared distance from q to segment ab\nfloat d2seg(vec2 q, vec2 a, vec2 b)\n{\n    q -= a; b -= a;\n    float si = iseg(q, b);\n    q -= b * si;\n    return dot(q,q);\n}\n\n\n// cheap cheap linear haxx\nfloat indexApproxWrap5(vec2 a, vec2 b)\n{\n    float t = .5;\n    //t = indexApproxLinear(a, b); // seems unclamped goes badly\n    t = indexApproxSeg(a, b); // no\n    //t = iseg(-a, b - a);\n    return t;\n}\n\n    //t = WhichHalf(q, p) ? .55 : .45; // WhichHalf seems really bad at guessing\n// especially the very first subdivision would probably be better off using ApexIndex instead\n\n// My old subdivision scheme is nowhere near as good.\n// pseudo-recursive isn't the best way,\n// but can be illustrative and is fairly simple\n// glsl doesn't support true recursion,\n// so cap at some depth.\nfloat IndexApproxSubdivOld(vec2 p, QuadricBezier q, int subdiv)\n{\n    float r0 = 0., r1 = 1.;\n    for (; subdiv-- > 0;) {\n        float rm = (r0 + r1) * .5;\n        // FIXME should instead compute both halves (if curvy enough) and take the nearest\n\t\tif (WhichHalf(p, q))\n            r0 = rm, q = UpperHalf(q);\n        else\n            r1 = rm, q = LowerHalf(q);\n    }\n    float t = indexApproxWrap5(p - q.a, p - q.c); //iseg(p - q.a, q.c - q.a)); //\n    return mix(r0, r1, t);\n}\n// My linear approximation errors tend to\n// cause small bunchings near the subdivisions.\n// in any case there's a limit to how curvy\n// a quadratic spline can get!\n// TODO just stop subdividing as soon as it\n// gets flat enough, and just linear estimate.\n// Maybe I could compute the iteration count\n// from the curvature.\n\n// computes both halves and tracks nearest\nfloat IndexApproxSubdiv0(vec2 p, QuadricBezier q)\n{\n    vec2 mid = Mid(q);\n    float t0 = indexApproxSeg(q.a - p, mid - p),\n          t1 = indexApproxSeg(mid - p, q.c - p);\n    vec2 r0 = p - mix(q.a, mid, t0), \n         r1 = p - mix(mid, q.c, t1);\n    float d0 = dot(r0, r0),\n          d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n// pseudo-recursive\nfloat IndexApproxSubdiv1(vec2 p, QuadricBezier q)\n{\n    QuadricBezier q0 = LowerHalf(q),\n                  q1 = UpperHalf(q);\n    float t0 = IndexApproxSubdiv0(p, q0),\n          t1 = IndexApproxSubdiv0(p, q1);\n    vec2 r0 = p - Eval(t0, q0), r1 = p - Eval(t1, q1);\n    float d0 = dot(r0, r0), d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n\nfloat IndexApproxSubdiv2(vec2 p, QuadricBezier q)\n{\n    QuadricBezier q0 = LowerHalf(q),\n                  q1 = UpperHalf(q);\n    float t0 = IndexApproxSubdiv1(p, q0),\n          t1 = IndexApproxSubdiv1(p, q1);\n    vec2 r0 = p - Eval(t0, q0), r1 = p - Eval(t1, q1);\n    float d0 = dot(r0, r0), d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n\n// same but use Apex instead of Mid\nfloat IndexApproxSubdivApex0(vec2 p, QuadricBezier q)\n{\n    float i = ApexIndex(q); \n    i = clamp(i, .42, .58);\n    vec2 m = Eval(i, q);\n    float t0 = indexApproxSeg(q.a - p, m - p),\n          t1 = indexApproxSeg(m - p, q.c - p);\n    float d0 = sqr(p - mix(q.a, m, t0)),\n          d1 = sqr(p - mix(m, q.c, t1));\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n\nfloat IndexApproxSubdivApex1(vec2 p, QuadricBezier q)\n{\n    float i = ApexIndex(q); \n    i = clamp(i, .02, .98);\n    vec2 m = Eval(i, q);\n    QuadricBezier q0 = QuadricBezier(q.a, Eval(.5*i, q), m), //mix(i, 0., .5)\n                  q1 = QuadricBezier(m, Eval(mix(i, 1., .5), q), q.c);\n    //float t0 = IndexApproxSubdivApex0(p, q0),\n    //      t1 = IndexApproxSubdivApex0(p, q1); // using the apex to locate subdivision point only works/helps once\n    float t0 = IndexApproxSubdiv0(p, q0),\n          t1 = IndexApproxSubdiv0(p, q1); // now approx each side linearly subdivided once\n    vec2 r0 = p - Eval(t0, q0), r1 = p - Eval(t1, q1);\n    float d0 = dot(r0, r0), d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n\nfloat IndexApproxSubdivApex2(vec2 p, QuadricBezier q)\n{\n    float i = ApexIndex(q); \n    i = clamp(i, .2, .8);\n    vec2 m = Eval(i, q);\n    QuadricBezier q0 = QuadricBezier(q.a, Eval(.5*i, q), m), //mix(i, 0., .5)\n                  q1 = QuadricBezier(m, Eval(mix(i, 1., .5), q), q.c);\n    float t0 = IndexApproxSubdiv1(p, q0),\n          t1 = IndexApproxSubdiv1(p, q1); // now approx each side linearly subdivided twice\n    vec2 r0 = p - Eval(t0, q0), r1 = p - Eval(t1, q1);\n    float d0 = dot(r0, r0), d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n\n// but if you think about it, what IndexApproxSubdiv<n> winds up doing\n// is simply breaking the curve into 1<<n segments\n// which we may as well do consecutively since that\n// allows us to not waste any computations, and also allows \n// setting up as forward differences in polynomial form which, to my knowledge,\n// is the fastest way to evaluate a strip of points on the curve\nfloat IndexApproxSubdivN(vec2 p, QuadricBezier q, int n)\n{\n    q.a -= p; q.b -= p; q.c -= p;\n    vec2 a = q.a; \n    float s = exp2(-float(n)); // step size\n    float t = .5, d = 3.4e38;\n    for (float i = s, oi = 0.; oi < 1.; oi = i, i += s) {\n        vec2 b = Eval(min(1.,i), q);\n        float f = indexApproxSeg(a, b);\n        f = clamp(f, 0., 1.);\n        float e = sqr(mix(a, b, f));\n        if (e < d) {\n            d = e; t = mix(oi, i, f);\n        }\n        a = b;\n    }\n    return t;\n}\n\nfloat IndexApproxFwdDiffN(vec2 p, QuadricBezier q, int n)\n{\n    q.a -= p; q.b -= p; q.c -= p;\n    vec2 a = q.a; \n    float s = exp2(-float(n)); // step size\n    vec2 poly[3] = AsPolynomial(q); \n    // polynomial forward difference to cheapen eval()\n    //vec2 polyd[2] = vec2[2]( poly[1] * s, 2.*poly[2] * s );\n    // TODO inline properly doh\n    vec2 vel = EvalTangent(.5*s, q) * s; //(2.*poly[2] * s + poly[1]) * s;\n    vec2 acc = 2.*poly[2] * s * s;\n    float t = .5, d = 3.4e38;\n    for (float i = s, oi = 0.; oi < 1.; oi = i, i += s) {\n        vec2 b = a + vel; vel += acc; //eval(min(1.,i), poly); //Eval(min(1.,i), q); //a + 2.*eval(i + .5*s, polyd); //\n        float f = indexApproxSeg(a, b);\n        f = clamp(f, 0., 1.);\n        float e = sqr(mix(a, b, f));\n        if (e < d) {\n            d = e; t = mix(oi, i, f);\n        }\n        a = b;\n    }\n    return t;\n}\n\nfloat IndexApproxSubdivision(vec2 p, QuadricBezier q)\n{\n    vec2 a = q.a - p, b = Mid(q) - p, c = q.c - p;\n    float t = .5;\n    t = ApexIndex(q);\n    // fast but terribly inaccurate guesswork\n    //t = mix(indexApproxSeg(a, b), indexApproxSeg(b, c), .5); // bad\n    //t = mix(indexApproxLinear(a, b), indexApproxLinear(b, c), indexApproxLinear(a, c)); // terrible\n    //t = mix(indexApproxSeg(a, b), indexApproxSeg(b, c), indexApproxSeg(a, c)); // real bad\n    // slower, but more reliable, check both halves at every step, keeping the closest overall.\n    //t = IndexApproxSubdiv0(p, q); // really poor quality\n    //t = IndexApproxSubdiv1(p, q); // not very good quality\n    //t = IndexApproxSubdivApex0(p, q);\n    //t = IndexApproxSubdivApex1(p, q); // better? not by much.\n    //t = IndexApproxSubdivApex2(p, q);\n    //t = IndexApproxSubdiv2(p, q); // surprisingly decent for a cheap linear approx\n    //t = IndexApproxSubdivN(p, q, 4); // pretty good actually\n    //t = IndexApproxSubdivN(p, q, 6); // nice enough for most purposes\n    t = IndexApproxFwdDiffN(p, q, 5); // more efficient\n    return t;\n}\n\n\n/*\ndet(r1,r2) := determinant(matrix(r1, r2));\na : [a_x,a_y];\nb : [b_x,b_y];\nc : [c_x,c_y];\ni : a - c;\nj : c - b;\nk : b - a;\nx : det(a, c);\ny : det(b, a);\nz : det(c, b);\ns : 2*(y*j + z*k) - x*i;\nx/2 + y + (s .(j - k)) * (y*z - x*x/4)\n*/\n\n/// WIP - these are all so very close to each other\nfloat indexApproxMashup(vec2 v0, vec2 v1, vec2 v2)\n{\n    float x = det(v0, v2),\n          y = det(v1, v0),\n          z = det(v2, v1);\n\tvec2 i = v0 - v2,\n         j = v2 - v1,\n         k = v1 - v0;\n#if 1\n    // iq is the only one so far to eliminate the other two det ops\n    // iq http://shadertoy.com/view/MlKcDD\n    vec2 s = 2.*(y*j + z*k) - x*i;\n    float n = .5*x + y + dot(s, j - k) * (y*z - x*x*.25) / dot(s, s);\n#elif 0\n    // iapafoto http://shadertoy.com/view/MslSDN\n\tvec2 s = 2. * (x * -i + 2. * y * j + 2. * z * k),\n\t\t r = v0 + (4. * y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat n = (det(r, -i) + 2. * det(k, r)) * .5;\n#elif 0\n    // Hoppe http://hhoppe.com/ravg.pdf\n    vec2 s = 4.*y*j + 4.*z*k - 2.*x*i,\n         r = (4.*y*z-x*x) / dot(s,s) * vec2(s.y,-s.x) + v0;\n    float n = det(k,r) - .5*det(r,i);\n#endif\n    float d = x + y + z;\n    return n / d;\n}\n/// WIP\n\n// just had to get some unused code out of the way\n\n/*\n// using Maxima to help clean up iq's approx:\ndet(r1,r2) := determinant(matrix(r1, r2));\na : [a_x,a_y];\nb : [b_x,b_y];\nc : [c_x,c_y];\ni : a - c;\nj : c - b;\nk : b - a;\nw : j - k;\nx : det(a, c);\ny : det(b, a);\nz : det(c, b);\ns : 2*(y*j + z*k) - x*i;\nr : (y*z - x*x/4) / (s . s);\n(x/2 + y + r * (s . w)) / (x+y+z);\n// winds up with the same proliferation of terms explosion\n// s : [2*((b_x-a_x)*(b_y*c_x-b_x*c_y)+(a_y*b_x-a_x*b_y)*(c_x-b_x))-(a_x-c_x)*(a_x*c_y-a_y*c_x),\n        2*((b_y-a_y)*(b_y*c_x-b_x*c_y)+(a_y*b_x-a_x*b_y)*(c_y-b_y))-(a_y-c_y)*(a_x*c_y-a_y*c_x)]\n// s : [(a_x*c_x-2*b_x^2+2*a_x*b_x-a_x^2)*c_y-a_y*c_x^2+((2*b_x-4*a_x)*b_y+2*a_y*b_x+a_x*a_y)*c_x+2*a_x*b_x*b_y-2*a_y*b_x^2,\n         a_x*c_y^2+(-a_y*c_x+(-2*b_x-2*a_x)*b_y+4*a_y*b_x-a_x*a_y)*c_y+(2*b_y^2-2*a_y*b_y+a_y^2)*c_x+2*a_x*b_y^2-2*a_y*b_x*b_y]\n// s : [a_x*c_x*c_y-2*b_x^2*c_y+2*a_x*b_x*c_y-a_x^2*c_y-a_y*c_x^2+2*b_x*b_y*c_x-4*a_x*b_y*c_x+2*a_y*b_x*c_x+a_x*a_y*c_x+2*a_x*b_x*b_y-2*a_y*b_x^2,\n        a_x*c_y^2-a_y*c_x*c_y-2*b_x*b_y*c_y-2*a_x*b_y*c_y+4*a_y*b_x*c_y-a_x*a_y*c_y+2*b_y^2*c_x-2*a_y*b_y*c_x+a_y^2*c_x+2*a_x*b_y^2-2*a_y*b_x*b_y]\n*/\n/*\n// Maxima/Macsyma stuff\ndet(r1,r2) := determinant(matrix(r1, r2));\nb0 : [b0_x, b0_y]; b1 : [b1_x, b1_y]; b2 : [b2_x, b2_y];\na : det(b0, b2); b : det(b1, b0); d : 2*det(b2, b1); \nf : b*d-a*a;\nd10 : b1-b0; d20 : b2-b0;\ngf : 2*(b*(b2-b1) + d*d10 + a*d20);\ngg : [gf[2], -gf[1]];\nd0p : b0 + f * gg / (gf.gf);\nap : det(d0p,d20); bp : 2*det(d10,d0p);\nt : (ap+bp) / (2*a+b+d);\n// be careful, though, you'll crash wxMaxima!\n// it gets really ugly.\n// the denominator of t simplifies to:\nt_denom = (2*b0_x-2*b1_x)*b2_y+(2*b1_y-2*b0_y)*b2_x-b0_x*b1_y+b0_y*b1_x\n// which isn't too bad... ok how about the numerator?\n// yuck.\n\n// why do I get the feeling iq already did a bunch of this cleanup?\n// let's go try seeing what he did.\n*/\n// spalmer cleanup of iq from http://shadertoy.com/view/MlKcDD based on http://hhoppe.com/ravg.pdf\nfloat indexApproxIq(vec2 v0, vec2 v1, vec2 v2)\n{\n\tfloat x = det(v0, v2),\n          y = det(v1, v0),\n          z = det(v2, v1);\n\tvec2 i = v0 - v2,\n         j = v2 - v1,\n         k = v1 - v0,\n         w = j - k;\n\tvec2 s = 2.*(y*j + z*k) - x*i;\n    float r = (y*z - x*x*.25) / dot(s,s),\n      n = .5*x + y + r * dot(s,w),\n      d = x + y + z;\n    return n / d;\n    // denom x+y+z seems to match hoppe 2*a+b+d but may be off by a factor of 2 \n}\n\n/*\n// iq from http://shadertoy.com/view/MlKcDD\n// This method provides just an approximation, and is only usable in\n// the very close neighborhood of the curve. Taken and adapted from\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// The MIT License\n// Copyright Â© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat sdBezierApproxiq(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n\tvec2 i = v0 - v2,\n         j = v2 - v1,\n         k = v1 - v0,\n         w = j - k;\n\tv0 -= p; v1 -= p; v2 -= p;    \n\tfloat x = det(v0, v2),\n          y = det(v1, v0),\n          z = det(v2, v1);\n\tvec2 s = 2.*(y*j + z*k) - x*i;\n    float r = (y*z - x*x*.25) / dot(s,s),\n          t = (.5*x + y + r * dot(s,w)) / (x+y+z);\n    //t = clamp(t, 0., 1.);    \n\treturn length(v0 + t*(k+k+t*w));\n}\n*/\n\n#if 1\nfloat indexApproxIapafotowIqNames(vec2 v0, vec2 v1, vec2 v2)\n{\n    vec2 i = v2 - v0, j = v2 - v1, k = v1 - v0;\n\tfloat x = det(v0, v2), y = det(v1, v0), z = det(v2, v1);\n\tvec2 s = 2. * (x * i + 2. * y * j + 2. * z * k),\n\t\t r = v0 + (4. * y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\treturn (det(r, i) + 2. * det(k, r)) * .5 / (x + y + z); // parametric position on curve\n}\n// iq apparently inspired iapafoto at http://shadertoy.com/view/MslSDN\n// converted back to 2d and extracted index approximator by spalmer\n// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Distance to Bezier\n// inspired by iq http://shadertoy.com/view/ldj3Wh\nfloat indexApproxIapafoto(vec2 a, vec2 b, vec2 c)\n{\n    vec2 m = a, n = b, o = c;\n\tfloat x = det(m, o), y = 2. * det(n, m), z = 2. * det(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\treturn (det(r, i) + 2. * det(k, r)) / (x + x + y + z); // parametric position on curve\n}\n#endif\n\n\n// I simply want to put these on the same page\nfloat indexApproxHoppewIqNames(vec2 v0, vec2 v1, vec2 v2) // hoppe was b0, b1, b2\n{\n    float x = det(v0, v2), // hoppe called these a, .5*b, .5*d\n          y = det(v1, v0),\n          z = det(v2, v1);\n    vec2 i = v0 - v2, // flipped sign of i to match iq\n         j = v2 - v1,\n         k = v1 - v0, // hoppe called these -d20, d21, and d10\n         s = 4.*y*j + 4.*z*k - 2.*x*i; // gf\n    vec2 r = (4.*y*z-x*x) / dot(s,s) * vec2(s.y,-s.x) + v0; // d0p\n    float n = det(k,r) - .5*det(r,i),\n        d = x + y + z;\n    return n / d;\n}\n// TODO cleanup by spalmer with some help by Maxima\n// refactored to return unclamped guess of nearest t index of spline w knots b0, b1, b2 to origin\n// based on http://hhoppe.com/ravg.pdf\nfloat indexApproxHoppe(vec2 b0, vec2 b1, vec2 b2)\n{\n    float a = det(b0,b2), b = 2.*det(b1,b0), d = 2.*det(b2,b1),\n      f = b*d-a*a;\n    vec2 d21 = b2-b1, d10 = b1-b0, d20 = b2-b0,\n        gf = 2.*(b*d21+d*d10+a*d20);\n        gf = vec2(gf.y,-gf.x);\n    vec2 d0p = b0 + f*gf / dot(gf,gf);\n    float ap = det(d0p,d20), bp = 2.*det(d10,d0p);\n    return (ap+bp) / (2.*a+b+d);\n}\n\n/*\n// clever inversion Hughes Hoppe approximation\n// from http://hhoppe.com/ravg.pdf  ported from hlsl by spalmer\n// Find vector ð‘£ð‘– given pixel ð‘=(0,0) and BÃ©zier points ð‘0,ð‘1,ð‘2.\nvec2 get_distance_vector_hoppe(vec2 b0, vec2 b1, vec2 b2)\n{\n    float a = det(b0,b2), b = 2.*det(b1,b0), d = 2.*det(b2,b1), // ð›¼,ð›½,ð›¿(ð‘)\n      f = b*d-a*a; // ð‘“(ð‘)\n    vec2 d21 = b2-b1, d10 = b1-b0, d20 = b2-b0,\n        gf = 2.*(b*d21+d*d10+a*d20);\n        gf = vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n    vec2 pp = -f*gf / dot(gf,gf), // ð‘ â€²\n        d0p = b0-pp; // ð‘â€² to origin\n    float ap = det(d0p,d20), bp = 2.*det(d10,d0p), // ð›¼,ð›½(ð‘ â€²)\n    // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n       t = (ap+bp) / (2.*a+b+d); // ð‘¡Ì…\n    //t = clamp(t, 0., 1.);\n    return mix(mix(b0,b1,t), mix(b1,b2,t), t); // ð‘£ð‘– = ð‘(ð‘¡Ì… )\n}\n// near the curve, the approximation is quite good\n// main difference is this one is unclamped\n\n// Hughes Hoppe's original code approximation\n// from http://hhoppe.com/ravg.pdf  ported from hlsl by spalmer\n// Find vector ð‘£ð‘– given pixel ð‘=(0,0) and BÃ©zier points ð‘0,ð‘1,ð‘2.\nvec2 get_distance_vector_hoppe(vec2 b0, vec2 b1, vec2 b2)\n{\n    float a = pdot(b0,b2), b = 2.*pdot(b1,b0), d = 2.*pdot(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n    float f = b*d-a*a; // ð‘“(ð‘)\n    vec2 d21 = b2-b1, d10 = b1-b0, d20 = b2-b0;\n    vec2 gf = 2.*(b*d21+d*d10+a*d20);\n        gf = vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n    vec2 pp = -f*gf / dot(gf,gf); // ð‘ â€²\n    vec2 d0p = b0-pp; // ð‘â€² to origin\n    float ap = pdot(d0p,d20), bp = 2.*pdot(d10,d0p); // ð›¼,ð›½(ð‘ â€²)\n    // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n    float t = clamp((ap+bp) / (2.*a+b+d), 0., 1.); // ð‘¡Ì…\n    return mix(mix(b0,b1,t), mix(b1,b2,t), t); // ð‘£ð‘– = ð‘(ð‘¡Ì… )\n}\n*/\n\nfloat indexApproxFromPoints(vec2 p, QuadricBezier q)\n{\n    return\n        indexApproxMashup\n//        indexApproxIq\n//        indexApproxIapafotowIqNames\n//        indexApproxIapafoto\n//        indexApproxHoppewIqNames\n//        indexApproxHoppe\n    (q.a - p, q.b - p, q.c - p);\n}\n\nfloat IndexApproxSubdivQ(vec2 p, QuadricBezier q)\n{\n    QuadricBezier q0 = LowerHalf(q),\n                  q1 = UpperHalf(q);\n    float t0 = indexApproxHoppe(q0.a - p, q0.b - p, q0.c - p),\n          t1 = indexApproxHoppe(q1.a - p, q1.b - p, q1.c - p);\n    t0 = clamp(t0, 0., 1.);\n    t1 = clamp(t1, 0., 1.);\n    vec2 r0 = p - Eval(t0, q0), r1 = p - Eval(t1, q1);\n    float d0 = dot(r0, r0), d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n\nfloat IndexApproxSubdivQ2(vec2 p, QuadricBezier q)\n{\n    QuadricBezier q0 = LowerHalf(q),\n                  q1 = UpperHalf(q);\n    float t0 = IndexApproxSubdivQ(p, q0),\n          t1 = IndexApproxSubdivQ(p, q1);\n    vec2 r0 = p - Eval(t0, q0), r1 = p - Eval(t1, q1);\n    float d0 = dot(r0, r0), d1 = dot(r1, r1);\n    return (d0 < d1 ? t0 : t1 + 1.) * .5;\n}\n// idk if it's bugged or what, but it performs terribly compared to IndexApproxSubdivN linear segment approximator!\nfloat IndexApproxSubdivQN(vec2 p, QuadricBezier q, int n)\n{\n    q.a -= p; q.b -= p; q.c -= p;\n    float s = exp2(-float(n)); // step size\n    float t = .5, d = 3.4e38;\n    vec2 a = q.a;\n    for (float oi = 0., i = s; oi < 1.; oi = i, i += s) {\n        i = min(1., i);\n        vec2 b = Eval(mix(oi, i, .5), q), c = Eval(i, q),\n        b2 = 2. * b - .5 * (a + c);         // middle control point\n        float f = indexApproxIq(a, b2, c);\n        f = clamp(f, 0., 1.);\n        float g = mix(oi, i, f),\n          e = sqr(Eval(g, q));\n        if (e < d) {\n            d = e; t = g;\n        }\n        a = c;\n    }\n    return t;\n}\n\nfloat indexApproxSubdivisionQ(vec2 p, QuadricBezier q)\n{\n    float t;\n    t = IndexApproxSubdivQ(p, q); // good quality/cost ratio, fixes many of the base approximator's problems\n    //t = IndexApproxSubdivQ2(p, q); // can hardly tell the difference, not worth the cost, still imperfect\n    //t = IndexApproxSubdivQN(p, q, 5); // why so poor quality? FIXME\n    return t;\n}\n\n// anyway once you have the polynomial form of the curve\n// you can easily compute the derivative of the polynomial\n// then can use those two functions to easily solve\n// for the t which minimizes the perp with the derivative\n// using whatever minimizer.\n// in fact can be recursively subdivided\n// using the derivative at each step \n// to help find the zeroes. TODO\n\n// Someone else I saw recently was just scanning\n// the nearby range for closer points.\n\nfloat indexApproxWrap4(vec2 p, QuadricBezier q)\n{\n    float t;\n    //t = indexApproxWrap5(q.a - p, q.c - p);\n    t = IndexApproxSubdivision(p, q);\n    //t = indexApproxHoppe(q.a - p, q.b - p, q.c - p); // hopefully will at least select the correct half\n    //t = IndexApproxSubdivisionQ(p, q);\n    return t;\n}\n// it's wrappers all the way down!\nfloat indexApproxWrap3(vec2 p, QuadricBezier q)\n{\n    return indexApproxWrap4(p, q);\n// my old binary subdividing linear approximation method works ok if given enough iterations\n// but it apparently gets the SDF field wrong on the inside due to the initial guesswork\n// the inside spine of the gradient isn't a line, it's a curve itself, so any\n// guess as to which half based on a line thru the midpoint will always be flawed.\n// Thus I believe this algorithm to be not particularly usable, after plenty of analysis.\n//\treturn IndexApproxSubdivOld(p, q, 5); // closest index very jerky but resulting distances are still visually pretty decent\n\treturn IndexApproxSubdivOld(p, q, 7); // starts to appear a bit jerky due to imprecision; can't tell from looking at the field\n//\treturn IndexApproxSubdivOld(p, q, 9);\n}\n\n#if 0\n// WIP TODO probably doesn't work at all yet\nfloat IndexOnStandardParabola(vec2 p)\n{\n// since y = x*x, and we know x, we can guess y\n    p.x = abs(p.x);\n    return pow(abs(p\n    return sqrt(abs(p.y*p.y-p.x*p.x*p.x));\n}\n// hell I can barely decompose the bezier into a parabola so far -\n// see Image tab where I seem to have done the curve itself somewhat successfully,\n// now I just need to obtain the closest index using the same technique\nfloat IndexViaStandardParabola(vec2 p, QuadricBezier q)\n{\n    float at = ApexIndex(q);\n    at = clamp(at, 0., 1.);\n    vec2 ap = Eval(at, q); // apex of parabola, because it's important\n\n    vec2 pp = q.a - 2.*q.b + q.c; // quadratic term of polynomial form\n    float ppl = length(pp);\n    pp /= ppl; //pp = normalize(pp);\n\n    // some redundant computations here on pp\n    float pz = FocalLength(q) * 4.; // compute eccentricity // that actually seems right, or almost right most of the time\n    float px = det(p - ap, pp);\n    float py = dot(p - ap, pp);\n    py *= pz; // scale by eccentricity or the quadratic factor of the parabola\n    // convert point to the standard parabola coord sys\n    // now find closest index to point in standard parabola setup\n    float t = IndexOnStandardParabola(vec2(px, py));\n    //t *= pz; // FIXME\n    return t + at; // FIXME\n}\n#endif\n    \n#if 0\n// try Newton's method first, WIP\n// http://wikipedia.org/wiki/Newton%27s_method\n// my initial guess isn't good, and my implementation is broken\n// once you get close enough,\n// the precise solution may be found by Newton-Raphson refinement.\n// these guys used a hybrid bisection / NR scheme successfully:\n\n// TODO see paper \n// Robust and Efficient Computation of the Closest Point on a Spline Curve\n// by Hongling Wang, Joseph Kearney, and Kendall Atkinson\n    \nfloat IndexNewton(vec2 p, QuadricBezier q, int iter)\n{\n    const float tol = 1e-8;\n    // TODO take initial guess as argument\n    float t = .5; // first iteration will select appropriate half \n    // (could probably come up with a better initial guess though it absolutely must be in the correct half)\n    t = indexApproxWrap3(p, q); // hopefully will at least select the correct half\n\n    vec2 vpoly0[3] = vec2[3]( q.a - p, 2.*(q.b - q.a), q.c - 2.*q.b + q.a ); // this quadric polynomial still needs squared afterwards\n    vec2 C = q.c, B = q.b, A = q.a\n    , AA = A * A //dot(A,A)\n    ;\n    vec2 vpoly1[4] = vec2[4]( (4.*A-4.*B)*p+4.*A*B-4.*AA, (-4.*C+8.*B-4.*A)*p+4.*A*C+B*(8.*B-24.*A)+12.*AA, (12.*B-12.*A)*C+(36.*A-24.*B)*B-12.*AA, C*(4.*C-16.*B+8.*A)+B*(16.*B-16.*A)+4.*AA );\n    while (iter-- > 0) {\n        vec2 vp0 = eval2(t, vpoly0);\n        vec2 vp1 = eval(t, vpoly1);\n        // FIXME not even close yet\n        float denom = vp1.x; //dot(vp1, vp1);\n        if (abs(denom) < tol) break;\n        float num = vp0.x; //dot(vp0, vp0);\n        t -= num / denom;\n        denom = vp1.y;\n        if (abs(denom) < tol) break;\n        num = vp0.y;\n        t -= num / denom;\n    }\n    return t;\n}\n    //t = mix(t, .5, .5); // don't trust it too much\n    //vec2 vpoly0[5] = vec2[5]( q.c - 2.*q.b + q.a, vec2(0), 2.*(q.b - q.a), vec2(0), q.a - p );\n    //vec2 vpoly0[5] = vec2[5]( q.c - 2.*q.b + q.a, vec2(0), 2.*(q.b - q.a), vec2(0), q.a - p );\n    // 2*(((C-2*B+A)*t^2 + 2*(B-A)*t + A-p) . 2*((C-2*B+A)*t + (B-A)))\n    //vec2[3] vpoly1 = vec2[3]( 2.*(q.c - 2.*q.b + q.a), 4.*(q.b - q.a), 2.*(q.a - p) ); // 1st derivative of poly0 TODO translate vector polynomial\n    //vec2 vpoly1[2] = vec2[2]( 2.*(q.c - 2.*q.b + q.a), 2.*(q.b - q.a) ); // hand derivative, I probably screwed up; need derivative of squared eqn not unsquared\n\n    // minimize F(t) := ((C-2*B+A)*t^2+(2*B-2*A)*t-p+A)^2\n// expanded F:\n/*\n(\n\t(\n\t\t(\n\t\t\t(\n\t\t\t\tC*(C-4.*B+2.*A)+B*(4.*B-4.*A)+AA\n\t\t\t)*t\n\t\t\t+(4.*B-4.*A)*C+(12.*A-8.*B)*B-4.*AA\n\t\t)*t\n\t\t+(-2.*C+4.*B-2.*A)*p+2.*A*C+B*(4.*B-12.*A)+6.*AA\n\t)*t\n\t+(4.*A-4.*B)*p + 4.*A*B-4.*AA\n)*t\n+p*(p-2.*A)+AA\n*/\n// seems pointless to expand squared equation into a regular polynomial, just proliferates all the terms and complicates it all greatly!\n// I believe even the derivative will remain much simpler if we keep everything squared here..\n// but Maxima expands everything, horner doesn't quite fix it, needs factored again, or do the derivative by hand while squared, correctly, somehow...\n// the derivative of F is only a cubic but is complicated here\n/*\n(\n\t(\n\t\t(\n\t\t\tC*(4.*C-16.*B+8.*A)+B*(16.*B-16.*A)+4.*AA\n\t\t)*t\n\t\t+(12.*B-12.*A)*C+(36.*A-24.*B)*B-12.*AA\n\t)*t\n\t+(-4.*C+8.*B-4.*A)*p+4.*A*C+B*(8.*B-24.*A)+12.*AA\n)*t\n+(4.*A-4.*B)*p+4.*A*B-4.*AA\n*/\n#endif \n// Newton // FIXME busted as heck, wth\n// would it be beneficial to arrange to store the spline equations as matrices?\n\n// TODO give Halley's method a try next!\n// http://wikipedia.org/wiki/Halley%27s_method\n\n// extract/generalize mla's Newton refinement step\n// http://shadertoy.com/view/mdsGDX\n// quick polishing for the root x of depressed cubic (t*t+p)*t+q=0, helps when nearly linear.\nfloat mlaRootPolish(float p, float q, float x, int iter)\n{\n    while (iter-- > 0) {\n        float fx = q+x*(p+x*x); // f(x) I suppose\n        float dx = p+3.0*x*x;   // must be derivative of f(x)\n        x -= fx/dx;\n    }\n    return x;\n}\n// compute the depressed cubic coeffs from the quadric bezier control points\nfloat mlaRootPolish(vec2 p, QuadricBezier q, float t, int j)\n{\n    // stuff from bezierSpalmer http://shadertoy.com/view/3tsczH\n    vec2 u = q.b - q.a, v = q.c - q.b,\n\t b = v - u, d = q.a - p;\n    vec2 s[3] = vec2[3] ( d, 2.*u, b );\n    vec3 k = vec3(\n        dot(d,u),\n        2.*dot(u,u) + dot(d,b),\n        3.*dot(b,u)\n        ) / dot(b,b);\n    float i = k.z/-3., // inflection point\n        P = k.y + k.z*i,\n        Q = (k.y - 2.*i*i)*i + k.x;\n    t -= i;\n    t = mlaRootPolish(P, Q, t, j);\n    t += i;\n    return t;\n}\n\nfloat IndexNewtonMla(vec2 p, QuadricBezier q, int j)\n{\n    float est = .5;\n    est = ApexIndex(q);\n    est = indexApproxWrap3(p, q);\n    return mlaRootPolish(p, q, est, j);\n}\n\n// apply mla Newton refinement to other methods\n// so far it usually just makes things worse\nfloat indexApproxWrapNewton(vec2 p, QuadricBezier q)\n{\n    //float a = ApexIndex(q);\n    //float t = a;\n    //float t = IndexApproxSubdiv2(p, q);\n    //float t = IndexApproxSubdiv1(p, q);\n    float t = IndexApproxSubdivN(p, q, 4);\n    //float t = indexApproxWrap4(p, q);\n    //float t = indexApproxWrap3(p, q);\n    //return t; // bypass Newton refinement\n    //t = mix(t, a, .5); // definitely doesn't help\n    return mlaRootPolish(p, q, t, 1);\n}\n\nfloat indexApproxWrap2(vec2 p, QuadricBezier q)\n{\n    return indexApproxWrap3(p, q);\n//    return IndexViaStandardParabola(p, q); // WIP - not there yet\n//    return indexApproxFromPoints(p, q);\n//    return indexApproxWrapNewton(p, q);\n//    return IndexNewtonMla(p, q, 14);\n//    return IndexNewton(p, q, 14);\n//    return IndexHalley(p, q, 2);\n}\n\n\n/*\n// not currently using any of these query-relative formulations.\n// in fact not even really wrapping distance except in Image tab.\n\n// get vector to origin from closest point to origin\nvec2 DistanceVectorApprox(QuadricBezier q)\n{\n    vec2 c;\n  #if 1\n    c = get_distance_vector_hoppe(q.a, q.b, q.c); // Hoppe's inversion approximation\n  #endif\n    return c;\n}\n\nfloat DistanceSquaredApprox(QuadricBezier q)\n{\n    return sqr(DistanceVectorApprox(q));\n    //vec2 c = DistanceVectorApprox(q); return dot(c, c);\n}\n\nfloat DistanceApprox(QuadricBezier q)\n{\n    return sqrt(DistanceSquaredApprox(q));\n}\n\nfloat DistanceSquaredApprox(vec2 p, QuadricBezier q)\n{\n    //return sdBezierApprox(p, q.a, q.b, q.c); // iq's seems exactly same as hoppe's\n    q.a -= p; q.b -= p; q.c -= p;\n    return sqrt(DistanceSquaredApprox(q));\n}\n\nfloat DistanceSquared(QuadricBezier q) \n{\n    vec2 c;\n  #if 0\n    float dd = DistanceSquaredApprox(q);\n    //if (dd < .008)\n        return dd;\n  #endif\n  #if 0\n    return d2iq(q.a, q.b, q.c);\n  #endif\n    // route through Index via Snap as full-quality fallback if no other shortcut activated\n    const vec2 p = vec2(0);\n    c = p - Snap(q, p);\n    return dot(c, c);\n}\n// nothing here would take advantage of such formulation\nfloat Distance(QuadricBezier q) \n{\n    return sqrt(DistanceSquared(q));\n}\t\n// I've tried it; it works out ok, but pretty sure isn't optimal as it reduces precision unnecessarily.\n// one thing that it does do well is that then evaluating points on the polynomial\n// are automatically relative to the query point, so can just square to obtain distance.\n// some of approximators are formulated this way though.\n  // but note that not all solvers benefit from this since it impacts precision on the measurements of the spline itself independent of query point\n//    return DistanceSquared(QuadricBezier(q.a - p, q.b - p, q.c - p)); //    q.a -= p; q.b -= p; q.c -= p; return DistanceSquared(q); //\n*/\n\n\n// see http://shadertoy.com/view/3llcR8","name":"Common","description":"","type":"common"}]}