{"ver":"0.1","info":{"id":"fl3cDr","date":"1660578316","viewed":212,"name":"Hex Voxel City","username":"EisernSchild","description":" \"Hex Voxel City\"\n https://github.com/EisernSchild/D3D12-Tech-Demo\n    \nHere we jump the ray from hex triangle edge to edge to render these triangle towers. ","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hex Voxel City\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// \n// SPDX-License-Identifier: MIT\n\n/*\n\n    This is a WebGL conversion of my D3D12 tech demo\n    \"Hex Voxel City\".\n    \n    You find the original (c++/hlsl) code on:\n    https://github.com/EisernSchild/D3D12-Tech-Demo\n    \n    Here we jump the ray from hex triangle edge to \n    edge to render these triangle towers.\n    \n*/\n\n/// smoothing\nvec3 smoothing(vec2 vUv, vec2 sKernel, float fStrength)\n{\n\tvec3 sAvarage = vec3(0., 0., 0.);\n\tvec2 sHalfK = sKernel * 0.5;\n\tfor (float fX = 0.0 - sHalfK.x; fX < sHalfK.x; fX += 1.0)\n\t{\n\t\tfor (float fY = 0.0 - sHalfK.y; fY < sHalfK.y; fY += 1.0)\n        {\n            vec2 vUv1 = vUv + vec2(fX, fY) * fStrength;\n            sAvarage += textureLod(iChannel0, vUv1, 0.).xyz;\n        }\n\t}\n\treturn max(textureLod(iChannel0,vUv,0.).xyz, sAvarage / (sKernel.x * sKernel.y));\n}\n\nvoid mainImage( out vec4 cOut, in vec2 vXY )\n{\n    \n    vec2 vUv = vXY.xy / iResolution.xy;\n    vec2 vK = vec2(1.) / iResolution.xy;\n    cOut = vec4(smoothing(vUv, vec2(3., 3.), 0.0015f), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// EisernSchild 3D library\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// Math Library #####################################################\n\n#define PI 3.141592654f\n\n// Orthographic projection : ba = (b.an)an\nvec2 ortho_proj(vec2 vA, vec2 vB)\n{\n    vec2 vAn = normalize(vA);\n    return dot(vB, vAn) * vAn;\n}\n\n// rotate 2D\nvec2 rotate(vec2 vV, float fA) \n{\n\tfloat fS = sin(fA);\n\tfloat fC = cos(fA);\n\tmat2 mR = mat2(fC, -fS, fS, fC);\n\treturn mR * vV;\n}\n\n// Hex Grid Library #####################################################\n\nconst vec2 vNext = vec2( 1.5f / sqrt(3.f), 1.5f );\nconst float fTD = length(vNext);\n\n/// Cartesian to hex coordinates\nvec2 HexUV(vec2 vXy)\n{\n\t// hex coords       (u, v) = (          .5 * x + .5 * y,        y ) \n\t// hex coord scaled (u, v) = ((sqrt(3.f) * x + y) / 3.f, y / 1.5f )\n\treturn vec2( (sqrt(3.f) * vXy.x + vXy.y) / 3.f, vXy.y / 1.5f );\n}\n\n/// Hex to cartesian coordinates\nvec2 HexXY(vec2 vUv)\n{\n\t// get cartesian coords\n\treturn vec2( (vUv.x * 3.f - vUv.y * 1.5f) / sqrt(3.f), vUv.y * 1.5f );\n}\n\n// provide hex grid\nfloat HexGrid(vec2 vPt)\n{\n    // get approx. hexagonal center coords\n    vec2 vUvC = round(HexUV(vPt));\n        \n    // get approx. cartesian hex center\n    vec2 vPtC = HexXY(vUvC);\n    \n    // get local coords absolut, adjust x\n    vec2 vPtLc = abs(vPt - vPtC);\n    if (vPtLc.x > (fTD * .5)) vPtLc.x = fTD - vPtLc.x;\n    \n    // project point on constant tile vector\n    vec2 vPtN = ortho_proj(vNext, vPtLc);\n    \n    // get distance, adjust again\n    float fD = max(vPtLc.x, length(vPtN));\n    if (fD > (fTD * .5)) fD = fTD - fD;\n    \n    return fD;\n}\n\n// cartesian to hex triangle index\nivec2 HexTriangle(vec2 vXy)\n{\n    // get hex uv global + local\n    vec2 vHUv = HexUV(vXy);\n    vec2 vHUvL = mod(vHUv, 1.);\n    int nIx = int(floor(vHUv.x)) * 2;\n    nIx += (vHUvL.x > vHUvL.y) ? 0 : 1;\n    return ivec2(nIx, int(floor(vHUv.y)));\n}\n\n// cartesian to hex triangle index (float)\nvec2 HexTriangleF(vec2 vXy)\n{\n    // get hex uv global + local\n    vec2 vHUv = HexUV(vXy);\n    vec2 vHUvL = mod(vHUv, 1.);\n    float fIx = floor(vHUv.x) * 2.;\n    fIx += (vHUvL.x > vHUvL.y) ? 1. : 0.;\n    return vec2(fIx, floor(vHUv.y));\n}\n\n// hex triangle index to cartesian triangle center\nvec2 HexCenterF(vec2 vIx)\n{\n    vec2 vHUv = floor(vIx * vec2(.5, 1.));\n    vHUv += (mod(vIx.x, 2.) < 1.) ? vec2(.33333, .66666) : vec2(.66666, .33333);\n    vec2 vXy = HexXY(vHUv);\n    return vXy;\n}\n\n// provides the intersection point of the next triangle in a direction\nvec2 iHexNextTriangle(vec2 vXy, vec2 vDir)\n{\n    // get hex uv global + local\n    vec2 vHUv = HexUV(vXy);\n    vec2 vHUvL = fract(vHUv);\n        \n    // get direction in hex space, normalized\n    vec2 vHDir = normalize(HexUV(vDir));\n    \n    // get angles\n    float fA = atan(.0 - vHUvL.y, .0 - vHUvL.x);\n    float fB = atan(1. - vHUvL.y, 1. - vHUvL.x);\n    float fC = atan(1. - vHUvL.y, .0 - vHUvL.x);\n    float fD = atan(.0 - vHUvL.y, 1. - vHUvL.x);\n    float fE = atan(vHDir.y, vHDir.x);\n    \n    // get next intersection\n    if (vHUvL.x < vHUvL.y)\n    {\n        if ((fA < fE) && (fB >= fE))\n        {\n            vec2 vA = ortho_proj(vec2(1.f, 1.f), vHUvL);\n            vec2 vB = ortho_proj(vA - vHUvL, vHDir); \n            vHUv += vHDir * (length(vHUvL - vA) / length(vB));\n        }\n        else if ((fB < fE) && (fC >= fE))\n            vHUv += vHDir * abs((1.f - vHUvL.y) / vHDir.y);\n        else\n            vHUv += vHDir * abs(vHUvL.x / vHDir.x);\n    }\n    else\n    {\n        if ((fA < fE) && (fD >= fE))\n            vHUv += vHDir * abs(vHUvL.y / vHDir.y);\n        else if ((fD < fE) && (fB >= fE))\n            vHUv += vHDir * abs((1.f - vHUvL.x) / vHDir.x);\n        else\n        {\n            vec2 vA = ortho_proj(vec2(1.f, 1.f), vHUvL);\n            vec2 vB = ortho_proj(vA - vHUvL, vHDir); \n            vHUv += vHDir * (length(vHUvL - vA) / length(vB));\n        }\n    }\n    \n    return HexXY(vHUv);    \n}\n\n// Transform Library #####################################################\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hex Voxel City\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// \n// SPDX-License-Identifier: MIT\n\n/*\n\n    This is a WebGL conversion of my D3D12 tech demo\n    \"Hex Voxel City\".\n    \n    You find the original (c++/hlsl) code on:\n    https://github.com/EisernSchild/D3D12-Tech-Demo\n    \n    Here we jump the ray from hex triangle edge to \n    edge to render these triangle towers.\n    \n*/\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n    vec2 vIndex;\n};\n\n// max ray steps\nconst uint uMaxSteps = uint(64);\n// ray min/max distance\nconst float fTMin = 0.f, fTMax = 50.f;\n// adjust raysteps to avoid flaws\nconst float fStepAdjust = 0.005f;\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// preliminary heightmap function\nfloat heightmap(vec2 vUv)\n{\n    // return (sin(vUv.x) + cos(vUv.y)) * sin(iTime);\n    return hash12(vUv) * 6.f + hash12(vUv * .2) * sin(iTime);\n}\n\n// hexagonal volume ray cast\nbool vrc_hex(in vec3 vOri, in vec3 vDir, out float fThit, out PosNorm sAttr)\n{\n\tvec3 vPos = vOri;\n    fThit = 0.f;\n    vec2 vPrev = HexTriangleF(vPos.xz);\n    float fPrev = heightmap(vPrev);\n    float fAlpha = 0.f;\n        \n\t// march through the space\n\tuint uI = uint(0);\n\twhile ((uI++ < uMaxSteps) && (fThit < fTMax))\n\t{           \n        // perform step\n        vec2 vStep = iHexNextTriangle(vPos.xz, vDir.xz);\n        float fStep = (length(vStep - vPos.xz) / length(vDir.xz)) + fStepAdjust;\n        fThit += fStep;\n\t\tvPos = vOri + fThit * vDir;\n        vec2 vNext = HexTriangleF(vPos.xz);\n\t\tfloat fNext = heightmap(vNext);\n             \n\t\t// top intersection ?\n\t\tif (vPos.y - fPrev <= 0.f)\n\t\t{            \n            // get back to barycentric coords\n            fThit -= (abs(vPos.y - fPrev) / abs(vDir.y));\n            vPos = vOri + fThit * vDir;\n\n            // set attributes\n            sAttr.vIndex = vPrev;\n            sAttr.vPosition = vPos;\n            sAttr.vNormal = vec3(0., 1., 0.);\n                \n            return true;\n\t\t}\n        else\n        // lateral intersection\n        if (vPos.y - fNext <= 0.f)\n        {\n            // set hit attributes\n            sAttr.vIndex = vNext;\n            sAttr.vPosition = vPos;\n            \n            // handle edges\n            vec2 vCnt = HexCenterF(vNext);\n            vec2 vLc = vec2(vPos.x - vCnt.x, vPos.z - vCnt.y); \n                       \n            float fA = atan(vLc.y, vLc.x);\n\n            // set normal by center->intersection angle\n            sAttr.vNormal = (mod(vNext.x, 2.f) >= 1.) ?\n                ((fA >= radians(-150.)) && (fA <= radians(-30.))) ? \n                    vec3(0., 0., -1) :\n                    normalize(vec3(sign(vLc.x), 0., 2./3.) ) :\n                ((fA <= radians(150.)) && (fA >= radians(30.))) ? \n                    vec3(0., 0., 1.) : \n                    normalize(vec3(sign(vLc.x), 0., -2./3.));\n\n            return true;\n        }\n        \n        fPrev = fNext;\n        vPrev = vNext;\n \t\t\n\t}\n\treturn false;\n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid transform_ray(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// lighting \nvec3 SceneLighting(in vec3 vPos, in vec3 vRayDir, in vec3 vLitPos,\n\tin vec3 vNorm,\n\tin vec3 cMaterial,\n\tin bool bTranslucent,\n\tin float fAmbient,\n\tin float fSpecularPow,\n\tin float fSpecularAdj,\n\tin vec3 cLight,\n\tin vec3 vLight)\n{\n\t// get distance, reflection\n\tfloat fDist = length(vLitPos - vPos);\n\tvec3 vRef = normalize(reflect(vRayDir, vNorm));\n\n\t// calculate fresnel, specular factors\n\tfloat fFresnel = max(dot(vNorm, -vRayDir), 0.0);\n\tfFresnel = pow(fFresnel, .3) * 1.1;\n\tfloat fSpecular = max(dot(vRef, vLight), 0.0);\n\n\t// do lighting.. inverse normal for translucent primitives\n\tvec3 cLit = cMaterial * 0.5f;\n\tcLit = mix(cLit, cMaterial * max(dot(vNorm, vLight), fAmbient), min(fFresnel, 1.0));\n\tif (bTranslucent)\n\t\tcLit = mix(cLit, cMaterial * max(dot(-vNorm, vLight), fAmbient), .2f);\n\tcLit += cLight * pow(fSpecular, fSpecularPow) * fSpecularAdj;\n\tcLit = clamp(cLit, 0.f, 1.f);\n\t\n\treturn cLit;\n}\n\n// get position on ground plane\nvec3 GroundLitPos(in vec3 vPos, in vec3 vRayDir)\n{\n\t// get lit position\n\tfloat fD = -vPos.y / vRayDir.y;\n\treturn vec3(vPos.x + vRayDir.x * fD, 0.0, vPos.z + vRayDir.z * fD);\n}\n\n// get horizon by ray direction\nvec4 Horizon(in vec3 vDir)\n{\n    if (vDir.y > 0.f)\n        return min(vec4(mix(vec3(.8, .8, 1.), vec3(0), exp2(-1./vDir.y) * vec3(3.f, 1.f, 0.3f)), 1.), vec4(1.));\n    else\n        return min(vec4(mix(vec3(.8, .8, 1.), vec3(0), -vDir.y * 2.), 1.), vec4(1.));\n}\n\n// trace the ray\nbool Trace(in vec3 vOri, in vec3 vDir, out float fThit, out PosNorm sAttr, out vec4 cOut)\n{\n    // trace the ray\n    if (vrc_hex(vOri, vDir, fThit, sAttr))\n    {\n        vec2 vCnt = HexCenterF(sAttr.vIndex);\n        vec2 vLc = vCnt - sAttr.vPosition.xz;\n        cOut = mix(vec4(.6, .7, .9, 1.), vec4(.9, .8, .7, 1.), hash12(sAttr.vIndex * .1));\n        \n        // fake occlusion\n        float fH = heightmap(sAttr.vIndex);\n        cOut *= 1. - length(vLc) * (1. - (sAttr.vPosition.y / fH));\n        \n        return true;\n    }\n    else\n    {\n        cOut = Horizon(vDir);\n    }\n    return false;\n}\n\n// simple camera helper\nvec3 cam(float fTime, vec2 fXZ_Off, float fY_Min, float fY_Max)\n{\n    return vec3(sin(fTime * .3f) * fXZ_Off.x, \n        min(fY_Min + sin(fTime * .5f) * 2.f, fY_Max), \n        cos(fTime * .3f) * fXZ_Off.y) +\n        vec3(10.f, 0.f, -20.f);\n}\n\nvoid mainImage( out vec4 cOut, in vec2 vXY )\n{\n    // get current camera position and lookat matrix\n    vec4 vCamPos = vec4(cam(iTime * .4, vec2(30.f, 10.f), 10.f, 18.f), 0.f);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, cam(iTime * .4 + .7f, vec2(20.f, 8.f), 7.5f, 9.f), vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    // get ray\n    vec3 vOri, vDir;\n    transform_ray(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // do raytracing\n    float fThit = 0.f;\n    PosNorm sAttr;\n    bool bHit = Trace(vOri, vDir, fThit, sAttr, cOut);\n        \n    if (bHit)\n    {\n        bool bShadow = false;\n               \n        // get shadow\n        float fThisSh = 0.f;\n        PosNorm sAttrSh;\n        vec4 cRef;\n        vec3 vDirSh = normalize(vec3(-.4f, .2f, -.3f));\n\n        if (Trace(sAttr.vPosition + sAttr.vNormal * .01, vDirSh, fThisSh, sAttrSh, cRef))\n        {\n            bShadow = true;\n            cOut *= .9f;\n        }\n\n        // get reflection ray\n        vec3 vRef = normalize(reflect(vDir, sAttr.vNormal));\n        float fThisRf = 0.f;\n        PosNorm sAttrRf;\n        Trace(sAttr.vPosition + sAttr.vNormal * .01, vRef, fThisRf, sAttrRf, cRef);\n        cOut = mix(cOut, cRef * .2, bShadow ? 0.4f : 0.2f);\n        \n        // do actual lighting\n        cOut = vec4(SceneLighting(\n                    vCamPos.xyz,\n                    vDir,\n                    sAttr.vPosition,\n                    sAttr.vNormal,\n                    cOut.xyz,\n                    false, \n                    .8f,\n                    220.f,\n                    1.f, \n                    bShadow ? vec3(.0f, .0f, .0f) : vec3(.9f, .8f, .9f),\n                    normalize(vec3(-.4f, .2f, -.3f))\n                    ), 1.f);\n                    \n        // fade out...            \n        if (fThit > fTMax * .8)\n        {\n            cOut = mix(cOut, Horizon(vDir), clamp((fThit -  fTMax * .8) * .3, 0., 1.));\n        \n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}