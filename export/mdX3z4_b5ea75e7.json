{"ver":"0.1","info":{"id":"mdX3z4","date":"1665911380","viewed":236,"name":"IBL with Cook Torrance ","username":"H2ongzh","description":" cite:\nhttps://www.shadertoy.com/view/MsXBzl\nhttps://www.shadertoy.com/view/ld3SRr\nhttps://www.shadertoy.com/view/3tlBW7","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["importancesampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------\n// Monte Carlo GGX Sampling for IBL\n// Author: Hong Zhang\n// Date: 10/15/2022\n//-----------------------------------------------------------\n\n\n#define IS_ROUGHNESS_MAP\n\n// Sample the GGX normal distribution function\n// Get the sample direction in the world coordinates\nvec3 getGGXSampleDir(vec2 p, vec3 norm, float r){\n    float phi = 2. * PI * p.x;\n    float cos_theta = sqrt((1.0 - p.y) / (1.0 + (r * r - 1.0) * p.y));\n    float sin_theta = sqrt(1.0 - (cos_theta * cos_theta));\n    \n    float x = sin_theta * cos(phi);\n    float y = sin_theta * sin(phi);\n    float z = cos_theta;\n    \n    //  refers to the function in the 'Common' tab, which I found is good to reach a smooth result\n    // cite: https://www.shadertoy.com/view/MsXBzl\n    vec3 up = stepValue3(0.999, norm.z, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    vec3 tangent = normalize(cross(up, norm));\n    vec3 bitangent = cross(norm, tangent);\n\n    return tangent * x + bitangent * y + norm * z;\n}\n\n\n\n// Monte Carlo Sampling \nvec3 GGXImportanceSampling(vec3 norm, vec3 view, Material m){\n    vec3 col;\n    // More rough the object is, More samples you need.\n    float numSamples = 50.; // number of samples. \n    \n    // remap the material\n    // follow the Google filament remapping method\n    vec3 diff_color = (1. - m.metallic) * m.albedo;\n    vec3 fresnel0 = 0.16 * m.reflectance * m.reflectance * (1.0 - m.metallic) \n                + m.albedo * m.metallic;                   \n    float r = m.roughness * m.roughness;\n    \n    vec3 ks, kd; // fresnel to balance the diffuse and spec term\n    \n    // IBL Specular\n    vec3 spec = vec3(0.);\n    for(float i = 0.; i < numSamples; i += 1.){\n       // generate random variable by Hammersley \n       vec2 p_i = hammersley(i, numSamples);\n       // transform to sample normal direction, sample GGX distribution\n       vec3 h = getGGXSampleDir(p_i, norm, r);\n       // get the reflection \n       vec3 l_i = (2. * h * dot(view, h)) - view;\n       // light \n       \n       vec3 light = texture(iChannel0, l_i).rgb;\n       light = LinearSpace(light);\n       \n       // Importance Sampling\n       // PDF: GGX * cos<norm, half> / 4. / cos<view, half>\n       // BRDF/PDF: F * G * cos<v, h> / cos<n, v> / cos<n, h>\n       float vdoth = saturate(dot(view, h));\n       float ndoth = saturate(dot(norm, h));\n       float ndotl = saturate(dot(norm, l_i));\n       float ndotv = saturate(dot(norm, view));\n       \n       vec3 fr = FSchlick(fresnel0, vdoth);\n       float ge = HeightCorrectedSmith(ndotv, ndotl, r);\n       \n       // spec\n       vec3 col = light * fr * ge * vdoth / ndotv / ndoth;\n      \n       spec += col;\n       ks += fr;\n\n    }\n    spec /= numSamples;\n    ks /= numSamples; // I am still working on finding better way to get the Fresnel term here.\n    \n    // diffuse \n    vec3 dir = (2. * norm * dot(view, norm)) - view;\n    vec3 irradiance = texture(iChannel1, dir).rgb;\n    vec3 diff = diff_color / PI * irradiance;\n    kd = 1. - ks;\n    diff *= kd;\n    \n    return spec + diff;\n}\n\n\n// get the rougness from Roughness Map (IChannel2)\nfloat queryRougnessMap(vec3 p){\n    vec2 pt;\n    pt.y = acos(p.y) / PI;\n    float sin_theta = sqrt(1. - p.y * p.y);\n    p.z > 0. ? pt.x = acos(p.x/sin_theta): (pt.x = acos(p.x/sin_theta) + PI);\n    pt.x /= PI;\n    return texture(iChannel2, pt).r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the uv\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // set the position of camera\n    vec3 cam_pos = vec3(0., 0., 3.);\n    cam_pos = rotateY(cam_pos, iTime);\n    \n    // get the camera view \n    vec3 view = getCameraView(uv, iResolution.xy);\n    view = rotateY(view, iTime);\n    \n    // compute the intersections\n    vec3 p = getIntersection(cam_pos, view);\n    vec3 norm = queryNormal(p);\n    \n    // define the material\n    Material material = Material(\n          vec3(1., 0.782, 0.344),  // albedo vec3[0., 1.] // gold \n          1., // reflectance [0., 1.] // when the metallic is 1., it doesn't matter\n          1.0,  // metallic [0., 1.]\n          0.25 // roughness [0., 1.]\n    );\n    \n    #ifdef IS_ROUGHNESS_MAP \n        material.roughness = queryRougnessMap(p);\n    #endif\n    \n    // get the intersection\n    if(p == vec3(MaxV)){\n        fragColor = texture(iChannel0, view);\n        return;\n    }\n    else{\n        vec3 col = GGXImportanceSampling(norm, -view, material);\n        col = ACESFilm(col);\n        fragColor = vec4(Gramma(col), 1.); // Gramma Correclation\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------\n// Some common functions and data structure\n// Author: Hong Zhang\n//-----------------------------------------------------------\n\n#define PI 3.141592653\n#define FOV 60.\n#define Rad(x) x * PI / 180.\n#define MaxV 1e10\n#define Thre 1e-4\n#define Gramma(x) pow(x, vec3(1./2.2))\n#define LinearSpace(x) pow(x, vec3(2.2))\n\n//-----------------------------------------------------------\n// define the Object information and the Camera\n//-----------------------------------------------------------\n// object information \n#define sphereR 1.\n\n// define the material\nstruct Material {\n    vec3 albedo;\n    float reflectance;\n    float metallic;\n    float roughness;\n};\n\n// compute the camera view\nvec3 getCameraView(vec2 uv, vec2 resolution){\n    uv = (uv - 0.5) * 2.;\n    float h = tan(Rad(FOV)/2.);\n    float w = h * (resolution.x / resolution.y);\n    return normalize(vec3(w * uv.x, h * uv.y, -1.));\n} \n\n//-----------------------------------------------------------\n// Math \n//-----------------------------------------------------------\n// clamp the float value to [0., 1.]\nfloat saturate(float x){\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x){\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// rotate the dir \nvec3 rotateY(vec3 dir, float time){\n    float rate = time/2.;\n    mat3 rot = mat3(\n        cos(rate), 0., sin(rate),\n        0.       , 1., 0,\n        -sin(rate), 0., cos(rate)\n    );\n    return rot * dir;\n}\n\n// cite: https://www.shadertoy.com/view/MsXBzl\nvec3 stepValue3(float a, float b, vec3 ra, vec3 rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n//-----------------------------------------------------------\n// Signed Distance Field for constructing the object\n//-----------------------------------------------------------\n\n// define the SDF for sphere\nfloat sphereSDF(vec3 p, float radius){\n    return length(p) - radius;\n}\n\n// query the distance \nfloat querySDF(vec3 p){\n    return sphereSDF(p, sphereR);\n}\n\n// query the normal\nvec3 queryNormal(vec3 p){\n    vec3 norm = vec3(querySDF(p + vec3(Thre, 0., 0.)) - querySDF(p - vec3(Thre, 0., 0.)),\n                querySDF(p + vec3(0., Thre, 0.)) - querySDF(p - vec3(0., Thre, 0.)),\n                querySDF(p + vec3(0., 0., Thre)) - querySDF(p - vec3(0., 0., Thre)));\n    return normalize(norm);\n}\n\n// compute the intersection by Ray Marching\nvec3 getIntersection(vec3 o, vec3 dir){\n    int maxIteration = 50;\n    vec3 p = o;\n    float dist = 0.;\n    for(int i = 0; i < maxIteration; i+=1){\n        dist = querySDF(p);\n        if(dist < Thre) \n            return p;\n        p += dir * dist;\n    }\n    return vec3(MaxV);\n}\n\n\n\n//-----------------------------------------------------------\n// Random Variable Generator\n//-----------------------------------------------------------\n\n// Hammersley Sequences\nvec2 hammersley(float n, float N){\n    uint temp = uint(n);\n    temp = ((temp & 0xFFFF0000u) >> 16u) | ((temp & 0x0000FFFFu) << 16u);\n    temp = ((temp & 0xFF00FF00u) >> 8u) | ((temp & 0x00FF00FFu) << 8u);\n    temp = ((temp & 0xF0F0F0F0u) >> 4u) | ((temp & 0x0F0F0F0Fu) << 4u);\n    temp = ((temp & 0xCCCCCCCCu) >> 2u) | ((temp & 0x33333333u) << 2u);\n    temp = ((temp & 0xAAAAAAAAu) >> 1u) | ((temp & 0x55555555u) << 1u);\n    float y = float(temp) * 2.3283064365386963e-10; \n    return vec2(n/N, y);\n}\n\n//-----------------------------------------------------------\n// Physically Based Shading Functions\n//-----------------------------------------------------------\n\n// Fresnel Schlick Approximation\nvec3 FSchlick(vec3 f0, float vdoth){\n    return f0 + (1. - f0) * pow((1. - vdoth), 5.);\n}\n\n// GGX Normal Distribution\n// inputs: ndoth: cos<normal, half-normal>\n//         r: roughness\n//                       r ^ 2\n// GGX = ----------------------------------------\n//        PI * (<n, h> ^ 2 * (r ^ 2 - 1) + 1) ^ 2  \nfloat GGX(float ndoth, float r){\n    float r2 = r * r;\n    float denom = ndoth * ndoth * (r2 - 1.) + 1.;\n    return r2 / (PI * denom * denom);\n}\n\n// Height Corrected Smith Mask/Shadowing Function\nfloat HeightCorrectedSmith(float ndotv, float ndotl, float r){\n    float r2 = r * r;     \n    float GGX_L = ndotv * sqrt((-ndotl * r2 + ndotl) * ndotl + r2);     \n    float GGX_V = ndotl * sqrt((-ndotv * r2 + ndotv) * ndotv + r2);    \n    return 2. * ndotv * ndotl / (GGX_L + GGX_V);\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}