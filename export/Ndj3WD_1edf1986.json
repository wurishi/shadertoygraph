{"ver":"0.1","info":{"id":"Ndj3WD","date":"1617458868","viewed":131,"name":"Meta Boze 2.0","username":"kaiware007","description":"Happy Anniversary Meta Boze","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","boze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n#define RAD90 (M_PI * 0.5)\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    float specular;\n    int count;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \t0.0, 0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \t0.001, 0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \t0.00001, 0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \t0.0, 0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \t0.02, 0, true))\n#define SURF_SPHERE(d) \t(surface(d, vec4(0.1,0.1,0.1,1),0.9, 0, true))\n    \n#define AA 1\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n// easing function\nfloat QuadraticEaseOut(float p)\n{\n\treturn -(p * (p - 2.));\n}\n\nfloat QuadraticEaseInOut(float p)\n{\n\tif(p < 0.5)\n\t{\n\t\treturn 2. * p * p;\n\t}\n\telse\n\t{\n\t\treturn (-2. * p * p) + (4. * p) - 1.;\n\t}\n}\n\nfloat CubicEaseIn(float p)\n{\n\treturn p * p * p;\n}\n\nfloat CubicEaseInOut(float p)\n{\n\tif(p < 0.5)\n\t{\n\t\treturn 4. * p * p * p;\n\t}\n\telse\n\t{\n\t\tfloat f = ((2. * p) - 2.);\n\t\treturn 0.5 * f * f * f + 1.;\n\t}\n}\n\nfloat QuarticEaseOut(float p)\n{\n\tfloat f = (p - 1.);\n\treturn f * f * f * (1. - p) + 1.;\n}\n\nfloat BackEaseIn(float p)\n{\n\treturn p * p * p - p * sin(p * M_PI);\n}\n\n// random\n//float rand3d(vec3 st)\n//{\n//    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n//}\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(hash13(ip+vec3(0.)),hash13(ip+vec3(1.,0.,0.)),hash13(ip+vec3(0.,1.,0.)),hash13(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(hash13(ip+vec3(0.,0.,1.)),hash13(ip+vec3(1.,0.,1.)),hash13(ip+vec3(0.,1.,1.)),hash13(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Basic Distance function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nsurface opS( surface d1, surface d2 )\n{\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    float sp = mix(d2.specular, d1.specular, h);\n    return surface(d, albedo, sp, d1.count, true);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nsurface opLerp(surface d1, surface d2, float t) {\n    surface d;\n    d.dist = mix(d1.dist, d2.dist, t);\n    d.albedo = mix(d1.albedo, d2.albedo, t);\n    d.specular = mix(d1.specular, d2.specular, t);\n    d.count = int(mix(float(d1.count), float(d2.count), t));\n    d.isHit = t > 0.5 ? d1.isHit : d2.isHit;\n    return d;\n}\n\n//https://www.shadertoy.com/view/NdS3Dh\n//SmoothSymmetricPolarMod aka smoothRot\n//\n//s repetitions\n//m smoothness (0-1)\n//c correction (0-1)\n//d object displace from center\n//\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n// 球体\n#define SEQ_0 (1.5)\n// モーフィング坊主\n#define SEQ_1 (SEQ_0 + 0.5)\n// ねじれ坊主\n#define SEQ_2 (SEQ_1 + 3.0)\n// 分裂坊主\n#define SEQ_3 (SEQ_2 + 5.0)\n// ズームエンド\n#define SEQ_4 (SEQ_3 + 3.)\n\n#define SEQ_0_D(t) (t / SEQ_0)\n#define SEQ_1_D(t) ((t - SEQ_0) / (SEQ_1 - SEQ_0))\n#define SEQ_2_D(t) ((t - SEQ_1) / (SEQ_2 - SEQ_1))\n#define SEQ_3_D(t) ((t - SEQ_2) / (SEQ_3 - SEQ_2))\n#define SEQ_4_D(t) ((t - SEQ_3) / (SEQ_4 - SEQ_3))\n\n#define LOOP (mod(iTime, SEQ_4+0.1))\n\nint getSeq(){\n    float t = LOOP;\n    //float t = iTime;\n    \n    if(t < SEQ_0){\n    \treturn 0;\n    }else if(t < SEQ_1){\n        return 1;\n    } else if(t < SEQ_2){\n        return 2;\n    } else if(t < SEQ_3){\n        return 3;\n    }\n    //else if(t < SEQ_4){\n        return 4;\n    //} \n    \n    return 0;\n}\n\nsurface bioBoze(vec3 p, float t)\n{\n    surface result = SURF_NOHIT(1e5);\n    \n    float ms = sin(iTime*3.0) * 0.5 + 0.75;\n\n    float t2 = t * 5.32;\n    float repetitions=6.0;\n    float smoothness=0.0125;\n    float correction=0.0;\n    float displace=t*0.1;\n    \n    float s = 1.0;\n    for(int i = 0; i < 3; i++)\n    {\n        p.yz=rot(p.yz,-cos(t2*1.3+iTime*0.1)*0.378 * (1.0-t));\n        p.xy=smoothRot(p.xy,repetitions,smoothness,correction,displace);\n        p.xz=rot(p.xz,sin(-t2*0.25+RAD90)*0.362*t2);\n\n        // boze\n        surface boze = sdBoze(p, vec3(s), ms);\n        s *= 0.78;\n        p.y -= 0.5*s*t;\n        p.xz-=0.175*s*t;\n\n        result = opSU(result, boze, smoothness);\n    }\n    return result;\n}\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n \tfloat ti = LOOP;\n    int seq = getSeq();\n    if(seq == 0) {\n        vec3 bp = vec3(0, -1.75 + QuarticEaseOut(SEQ_0_D(ti)) * 1.75, 0);\n\t\t// 球体\n        result = SURF_SPHERE(sdCapsule(p + bp, vec3(0,0.0,0), vec3(0, 0., 0), 0.125));\n \t} else if(seq == 1) {\n        // モーフィング坊主\n        float t = QuadraticEaseInOut(saturate(SEQ_1_D(ti)));\n        result = SURF_SPHERE(sdCapsule(p, vec3(0,0.0,0), vec3(0, 0., 0), 0.125));\n        surface boze = sdBoze(p, vec3(1), 1.0);\n\n        result = opLerp(result, boze, t);\n        \n    } else if(seq == 2) {\n        // ねじれ坊主\n        float d = saturate(SEQ_2_D(ti));\n        float t = QuadraticEaseInOut(d);\n        p = TwistY(p, sin(d * M_PI2) * 5.);\n        float s = noise(normalize(-p)*2.0+vec3(0,ti*(t*1.5+2.0),0)) * 0.5 * t + 1.0;\n        \n        result = sdBoze(p, vec3(s), 1.0);\n    } else if(seq == 3) {        \n         // 通常のBoze\n        float s2 = noise(normalize(-p)*2.0+vec3(0,ti*3.5,0)) * 0.5 + 1.0;\n        surface b2 = sdBoze(p, vec3(s2), 1.0);\n        \n\t\tfloat t = QuarticEaseOut(SEQ_3_D(ti));\n        float t2 = t * 5.32;\n\n        // 分裂坊主と合成\t\t\n        result = opLerp(b2, bioBoze(p, t), saturate(t2));\n    } else if(seq == 4) {\n    \t// ズームエンド\n        float t = BackEaseIn(SEQ_4_D(ti));\n        float t2 = QuadraticEaseInOut(SEQ_4_D(ti));\n        p.z -= t;\n        //p.z -= t2*0.5;\n        p.y -= t2*0.2;\n        result = bioBoze(p, 1.0);\n    }\n    \n    \n    return result;\n}\n\nvec3 norm(in vec3 position) {\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist * 0.5;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n\n        t += d;\n        pos = origin + direction * t;\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    \n    if(d <= EPS){\n        hit.isHit = true;\n        return hit;\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n    }\n}\n    \nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    vec3 col = vec3(0,0,0);\n\n    vec3 sky = sinebow(fbm(vec3(ray+iTime*0.2))*5.5)*0.5+0.25;\n    if(mat.isHit)\n    {\n        // Lighting\n        vec3 normal = norm(pos);\n\n        vec3 lightDir = normalize(vec3(0.5, 1, 1));\n\t\tvec3 lightColor = vec3(1.);\n        \n        vec3 halfLE = normalize(lightDir - ray);\n        float NoL = saturate(pow(dot(normal, lightDir)*0.5+0.5,2.0));\n        \n        float spec = pow(clamp(dot(normal, halfLE), 0.0, 1.0), (1.-mat.specular)*500.);\n            \n        vec3 ref = reflect(ray, normal);\n        \n        vec3 ambientColor = sinebow(fbm(vec3(ref + iTime*0.2))*5.5)*0.05;\n        \n        mat.albedo.rgb *= NoL * lightColor;\n        mat.albedo.rgb +=  ambientColor + spec*lightColor;\n    }\n    \n    col = mat.isHit ? mat.albedo.rgb : sky;\n    \n    return col;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    \n        vec3 ro = vec3(0, 0.2, 1.0);\n        //vec3 ro = vec3(cos(iTime)*2.5, 0.0, sin(iTime)*2.5);\n        vec3 ta = vec3(0, 0.05, 0);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 1.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}