{"ver":"0.1","info":{"id":"fs33DM","date":"1629915410","viewed":279,"name":"Geometric Factory","username":"Flopine","description":"Inspiration is still heeeeeeere )0) ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cubes","animation","isometric","pipes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p-=c*clamp(round(p/c),-l,l)\n#define cyl(p,r,h) max(length(p.xy)-r,abs(p.z)-h)\n\n#define frt(sp,off) fract((iTime+off)*sp)\n#define flt(sp,off) floor((iTime+off)*sp)\n\nstruct obj{\n    float d;\n    vec3 sha;\n    vec3 li;\n};\n\nobj minobj (obj a, obj b)\n{if(a.d<b.d)return a; else return b;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nobj grid (vec3 p)\n{\n    crep(p.xz,8.,2.);\n    float per=1.;\n    crep(p,per,2.);\n    float d = max(-sc(p,per*0.34),box(p,vec3(per*0.4)));\n    obj scene = obj(d,vec3(0.),vec3(1.));\n    \n    return scene;  \n}\n\nfloat pipe (vec3 p, float pid)\n{\n    float d = cyl(p,0.15,20.);\n    \n    float per = 1.5, id = round(p.z/per), speed=1., off=id*0.1,\n    anim=(TAU/4.)*(flt(speed,off)+pow(frt(speed,off),6.));\n    crep(p.z,per,6.);\n    p.xy *= (mod(pid,2.)<0.5)?rot(anim):rot(-anim);\n    d = min(d,cyl(p,0.2, 0.15));\n    d = min(d, cyl(p.xzy,0.065,0.4));\n    d = min(d, cyl(p.yzx,0.065,0.4));\n    \n    return d; \n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    vec3 pp = p;\n    obj scene = grid(p);\n    \n    p.y -= 1.;\n    float p1id = round(p.x/2.);\n    crep(p.x, 2., 5.);\n    scene = minobj(scene,obj(pipe(p,p1id),vec3(0.2,0.,0.),vec3(1.,0.5,0.9)));\n    \n    p=pp;\n    p.y += 1.;\n    float p2id = round(p.z/2.);\n    crep(p.z,2.,5.);\n    scene = minobj(scene,obj(pipe(p.yzx,p2id),vec3(0.,0.,0.1),vec3(0.,1.,0.5)));\n    \n    return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n).d/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro=vec3(uv*5.,-30.),rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.),l=normalize(vec3(2.,3.,-3.));\n    \n    bool hit=false; obj O;\n    for(float i=0.;i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {hit=true; break;}\n        p += O.d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.);\n        float ao = AO(0.1,p,n)+AO(0.3,p,n)+AO(0.5,p,n);\n        col = mix(O.sha,O.li,light)*ao/3.;\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}