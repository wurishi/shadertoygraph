{"ver":"0.1","info":{"id":"DtfBz4","date":"1692706597","viewed":179,"name":"LTC Ring Arealight (WIP)","username":"panna_pudi","description":"I still need to get proper shape/view factor for ring.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["ring","brdf","arealight","ltc","polygonlight"],"hasliked":0,"parentid":"4tBBDK","parentname":"linearly transformed cosines"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/4tBBDK by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original Article: https://blog.unity.com/technology/real-time-polygonal-light-shading-with-linearly-transformed-cosines\n//\n// It's a derivation of a techique described in their another talk:\n// https://blog.selfshadow.com/publications/s2017-shading-course/heitz/s2017_pbs_ltc_lines_disks.pdf\n//\n// Unlike polygonal lights shading for disk lights involves cubic polinomial\n// for eigenvalues and sampling distribution texture. Ring lights should be\n// the same, but with different shape factor. I tried to derive the formula \n// myself and find elsewhere, but formula looks gargantuan and approximations\n// like infinitely thin ring don't yield good result.\n// http://www.thermalradiation.net/sectionb/B-18.html\n//\n// Right now I just compute disk lighting twice and substract one from the other.\n// Making it twice as expensive. \n\nconst float PI = acos(-1.);\n\nconst float roughness = 0.2;\nconst float intensity = 1.5;\nconst float light_width = 0.5;\nconst float light_height = 0.5;\nconst float light_radius = 0.35;\nconst float light_thicc = 0.045;\n\nconst vec3 diff_col = vec3(1.);\nconst vec3 spec_col = vec3(1.);\n\nconst vec3 light_col = vec3(1.0)*intensity;\nconst vec3 light_pos = vec3(0., 0.2, 0.);\nconst vec3 light_normal = vec3(0., 0., 1.);\n\nconst float LUTSIZE  = 8.0;\nconst float MATRIX_PARAM_OFFSET = 8.0;\n\nfloat sqr(float x) { return x * x; }\n\nstruct Disk {\n    vec3 center;\n    vec3 dirx;\n    vec3 diry;\n    float halfx;\n    float halfy;\n\n    vec4 plane;\n};\n\nDisk init_disk(vec3 center, vec3 dirx, vec3 diry, float halfx, float halfy) {\n    Disk disk;\n\n    disk.center = center;\n    disk.dirx = dirx;\n    disk.diry = diry;\n    disk.halfx = halfx;\n    disk.halfy = halfy;\n\n    vec3 diskNormal = cross(disk.dirx, disk.diry);\n    disk.plane = vec4(diskNormal, -dot(diskNormal, disk.center));\n\n    return disk;\n}\n\nvoid init_disk_points(float width, float height, out vec3 points[4]) {\n    vec3 right = normalize(cross(light_normal, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, light_normal));\n    \n    vec3 ex = width * right;\n    vec3 ey = height * up;\n\n    points[0] = light_pos - ex - ey;\n    points[1] = light_pos + ex - ey;\n    points[2] = light_pos + ex + ey;\n    points[3] = light_pos - ex + ey;\n}\n\n// Linearly Transformed Cosines \n\n// An extended version of the implementation from\n// \"How to solve a cubic equation, revisited\"\n// http://momentsingraphics.de/?p=105\nvec3 SolveCubic(vec4 Coefficient) {\n    // Normalize the polynomial\n    Coefficient.xyz /= Coefficient.w;\n    // Divide middle coefficients by three\n    Coefficient.yz /= 3.0;\n  \n    float A = Coefficient.w;\n    float B = Coefficient.z;\n    float C = Coefficient.y;\n    float D = Coefficient.x;\n  \n    // Compute the Hessian and the discriminant\n    vec3 Delta = vec3(-Coefficient.z * Coefficient.z + Coefficient.y,\n                      -Coefficient.y * Coefficient.z + Coefficient.x,\n                      dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy));\n\n    float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n  \n    vec3 RootsA, RootsD;\n  \n    vec2 xlc, xsc;\n  \n    // Algorithm A\n    {\n        float A_a = 1.0;\n        float C_a = Delta.x;\n        float D_a = -2.0 * B * Delta.x + Delta.y;\n    \n        // Take the cubic root of a normalized complex number\n        float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n    \n        float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n        float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * PI);\n    \n        float xl;\n        if ((x_1a + x_3a) > 2.0 * B)\n          xl = x_1a;\n        else\n          xl = x_3a;\n    \n        xlc = vec2(xl - B, A);\n    }\n\n    // Algorithm D\n    {\n        float A_d = D;\n        float C_d = Delta.z;\n        float D_d = -D * Delta.y + 2.0 * C * Delta.z;\n    \n        // Take the cubic root of a normalized complex number\n        float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n    \n        float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n        float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * PI);\n    \n        float xs;\n        if (x_1d + x_3d < 2.0 * C)\n          xs = x_1d;\n        else\n          xs = x_3d;\n    \n        xsc = vec2(-D, xs + C);\n    }\n\n    float E = xlc.y * xsc.y;\n    float F = -xlc.x * xsc.y - xlc.y * xsc.x;\n    float G = xlc.x * xsc.x;\n  \n    vec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n  \n    vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n  \n    if (Root.x < Root.y && Root.x < Root.z)\n      Root.xyz = Root.yxz;\n    else if (Root.z < Root.x && Root.z < Root.y)\n      Root.xyz = Root.xzy;\n  \n    return Root;\n}\n\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4],\n                  bool twoSided) {\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N * dot(V, N));\n    T2 = cross(N, T1);\n  \n    // rotate area light in (T1, T2, N) basis\n    mat3 R = transpose(mat3(T1, T2, N));\n  \n    // polygon (allocate 5 vertices for clipping)\n    vec3 L_[3];\n    L_[0] = R * (points[0] - P);\n    L_[1] = R * (points[1] - P);\n    L_[2] = R * (points[2] - P);\n  \n    vec3 Lo_i = vec3(0);\n  \n    // init ellipse\n    vec3 C = 0.5 * (L_[0] + L_[2]);\n    vec3 V1 = 0.5 * (L_[1] - L_[2]);\n    vec3 V2 = 0.5 * (L_[1] - L_[0]);\n  \n    C = Minv * C;\n    V1 = Minv * V1;\n    V2 = Minv * V2;\n  \n    if (!twoSided && dot(cross(V1, V2), C) < 0.0)\n      return vec3(0.0);\n\n    // compute eigenvectors of ellipse\n    float a, b;\n    float d11 = dot(V1, V1);\n    float d22 = dot(V2, V2);\n    float d12 = dot(V1, V2);\n    if (abs(d12) / sqrt(d11 * d22) > 0.0001) {\n        float tr = d11 + d22;\n        float det = -d12 * d12 + d11 * d22;\n    \n        // use sqrt matrix to solve for eigenvalues\n        det = sqrt(det);\n        float u = 0.5 * sqrt(tr - 2.0 * det);\n        float v = 0.5 * sqrt(tr + 2.0 * det);\n        float e_max = sqr(u + v);\n        float e_min = sqr(u - v);\n    \n        vec3 V1_, V2_;\n    \n        if (d11 > d22) {\n            V1_ = d12 * V1 + (e_max - d11) * V2;\n            V2_ = d12 * V1 + (e_min - d11) * V2;\n        } else {\n            V1_ = d12 * V2 + (e_max - d22) * V1;\n            V2_ = d12 * V2 + (e_min - d22) * V1;\n        }\n\n        a = 1.0 / e_max;\n        b = 1.0 / e_min;\n        V1 = normalize(V1_);\n        V2 = normalize(V2_);\n    } else {\n        a = 1.0 / dot(V1, V1);\n        b = 1.0 / dot(V2, V2);\n        V1 *= sqrt(a);\n        V2 *= sqrt(b);\n    }\n\n    vec3 V3 = cross(V1, V2);\n    if (dot(C, V3) < 0.0)\n      V3 *= -1.0;\n  \n    float L = dot(V3, C);\n    float x0 = dot(V1, C) / L;\n    float y0 = dot(V2, C) / L;\n  \n    float E1 = inversesqrt(a);\n    float E2 = inversesqrt(b);\n  \n    a *= L * L;\n    b *= L * L;\n  \n    float c0 = a * b;\n    float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n    float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n    float c3 = 1.0;\n  \n    vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n    float e1 = roots.x;\n    float e2 = roots.y;\n    float e3 = roots.z;\n  \n    vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n  \n    mat3 rotate = mat3(V1, V2, V3);\n\n    avgDir = rotate * avgDir;\n    avgDir = normalize(avgDir);\n  \n    float L1 = sqrt(-e2 / e3);\n    float L2 = sqrt(-e2 / e1);\n  \n    float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\n  \n    // use tabulated horizon-clipped sphere\n    vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n    // uv = uv * LUT_SCALE + LUT_BIAS;\n    // uv += vec2(0.5, 0.5);\n    float scale = texture(iChannel0, uv / iChannelResolution[0].xy).w;\n    \n    float spec = formFactor * scale;\n  \n    Lo_i = vec3(spec, spec, spec);\n  \n    return vec3(Lo_i);\n}\n\nvec3 LTC_evaluate_ring(vec3 N, vec3 V, vec3 P, mat3 Minv, bool twoSided) {\n    vec3 points[4];\n    init_disk_points(light_width, light_height, points);\n    vec3 l1 = LTC_Evaluate(N, V, P, Minv, points, false);\n    \n    init_disk_points(light_width * 0.6, light_height * 0.6, points);\n    vec3 l2 = LTC_Evaluate(N, V, P, Minv, points, false);\n    \n    return l1 - l2;\n}\n\n//////////////////////////////////////////////////////////\n\n#define LIGHT 0.\n#define SCENE 1.\n\nfloat object_id = 0.;\n\nfloat sphere(vec3 p, float r) {\n   \treturn length(p) - r;\n}\n\nfloat ring(vec2 p, float r, float width) {\n    return abs(length(p) - r) - width;\n}\n\nfloat map(vec3 p) {\n    float d0 = ring(p.xy - light_pos.xy, light_radius, light_thicc);\n    d0 = max(d0, abs(p.z) - 0.001);\n    float d1 = abs(p.y + 0.5);\n    float d2 = sphere(p - vec3(-0.4, -0.2, 1.2), 0.3);\n    \n   \tfloat d = d0;\n    object_id = LIGHT;\n    \n    if (d > d1) {\n        d = d1;\n        object_id=SCENE;\n    }\n    \n    if (d > d2) {\n        d = d2;\n        object_id=SCENE;\n    }\n    \n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    float t = 0.01;\n    for(int i=0; i < 100; ++i) {\n        float d = map(ro + rd * t);\n        if (abs(d) < 0.005) { break; }\n        t += d;\n        if (t > 100.0) { return -1.0; }\n    }\n    return t;\n}\n\n/////////////////////////////////////////////\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k ) {\n    float res = 1.0;\n    float t = 0.001;\n\tfloat h = 1.0;\n    for( int i = 0; i < 32; i++ ) {\n        h = map(ro + rd*t);\n        if (object_id == LIGHT) break;\n        res = min(res, k * h / t);\n        if (res < 0.001) break;\n        t += h;\n    }\n    return clamp(res,0.1,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n  \n    vec3 lookat = vec3(0.0, -0.8 * light_height, 0.);\n\tvec3 ro = vec3(1.8, light_height, 2.2);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    \n    vec3 rd = normalize(p.x * right + p.y * up + 2. * forward);\n    \n    vec3 points[4];\n    \n    // setup the four vertices for the rect light\n    init_disk_points(light_width, light_height, points);\n\n    float t = trace(ro,rd);\n    vec3 col=vec3(0.);\n    if (t > -0.5) {\n        col = vec3(1.0);\n        \n     \tif (object_id == SCENE) {            \n            vec3 pos = ro + rd * t;\n\n            vec3 N = get_normal(pos);\n            vec3 V = -rd;\n\n            float theta = acos(dot(N, V));\n            vec2 uv = vec2(roughness, theta / (0.5*PI)) * float(LUTSIZE - 1.);        \n            \n            // The offset to get correct interpolation\n            uv += vec2(0.5, 0.5);\n            \n            vec4 params = texture(iChannel0, (uv + vec2(MATRIX_PARAM_OFFSET, 0.0)) / iChannelResolution[0].xy);\n           \n            // The inverse transformation matrix, so we \n            // can integrate cosine distribution over the polygon \n            // transformed by this matrix, instead of integrating the\n            // complicated brdf over the untransformed polygon.\n            mat3 Minv = mat3(\n                vec3(  1,        0,      params.y),\n                vec3(  0,     params.z,   0),\n                vec3(params.w,   0,      params.x)\n            );\n\n            vec3 spec = LTC_evaluate_ring(N, V, pos, Minv, false);\n\n            spec *= texture(iChannel0, uv / iChannelResolution[0].xy).x;\n            \n            if (N.z > 0.3) {\n                spec *= 0.;\n            }\n            \n            vec3 diff = LTC_evaluate_ring(N, V, pos, mat3(1), false); \n                        \n            // shadow is not area light based here.\n            float sha = softshadow(pos + 0.01 * N, normalize(light_pos - pos), 2.0);\n\n            col  = light_col * (spec_col * spec + diff_col * diff) * sha;\n            col /= 2.0 * PI;\n        }\n\n    }\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.45));\n    col *= pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);\n    fragColor.xyz = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid store_buf(vec2 pos,vec4 val,vec2 fragCoord,inout vec4 fragColor)\n{\n    if(abs(fragCoord.x-pos.x)<0.01&&abs(fragCoord.y-pos.y)<0.01)\n        fragColor=val;\n}\n\n// The first 8x8 stores the normalization\n// The second 8x8 stores the matrix parameters\n\nvoid setLUT(vec2 fragCoord, inout vec4 fragColor)\n{\n    store_buf(vec2(0.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(2.5, 0.5), vec4(0.999138), fragCoord, fragColor);\n    store_buf(vec2(3.5, 0.5), vec4(0.953919), fragCoord, fragColor);\n    store_buf(vec2(4.5, 0.5), vec4(0.855017), fragCoord, fragColor);\n    store_buf(vec2(5.5, 0.5), vec4(0.677721), fragCoord, fragColor);\n    store_buf(vec2(6.5, 0.5), vec4(0.475624), fragCoord, fragColor);\n    store_buf(vec2(7.5, 0.5), vec4(0.306905), fragCoord, fragColor);\n    store_buf(vec2(0.5, 1.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 1.5), vec4(0.999990), fragCoord, fragColor);\n    store_buf(vec2(2.5, 1.5), vec4(0.995492), fragCoord, fragColor);\n    store_buf(vec2(3.5, 1.5), vec4(0.955938), fragCoord, fragColor);\n    store_buf(vec2(4.5, 1.5), vec4(0.852346), fragCoord, fragColor);\n    store_buf(vec2(5.5, 1.5), vec4(0.676815), fragCoord, fragColor);\n    store_buf(vec2(6.5, 1.5), vec4(0.478562), fragCoord, fragColor);\n    store_buf(vec2(7.5, 1.5), vec4(0.311751), fragCoord, fragColor);\n    store_buf(vec2(0.5, 2.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 2.5), vec4(0.999952), fragCoord, fragColor);\n    store_buf(vec2(2.5, 2.5), vec4(0.993337), fragCoord, fragColor);\n    store_buf(vec2(3.5, 2.5), vec4(0.950365), fragCoord, fragColor);\n    store_buf(vec2(4.5, 2.5), vec4(0.844905), fragCoord, fragColor);\n    store_buf(vec2(5.5, 2.5), vec4(0.674537), fragCoord, fragColor);\n    store_buf(vec2(6.5, 2.5), vec4(0.487632), fragCoord, fragColor);\n    store_buf(vec2(7.5, 2.5), vec4(0.327273), fragCoord, fragColor);\n    store_buf(vec2(0.5, 3.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 3.5), vec4(0.999865), fragCoord, fragColor);\n    store_buf(vec2(2.5, 3.5), vec4(0.991766), fragCoord, fragColor);\n    store_buf(vec2(3.5, 3.5), vec4(0.942684), fragCoord, fragColor);\n    store_buf(vec2(4.5, 3.5), vec4(0.831852), fragCoord, fragColor);\n    store_buf(vec2(5.5, 3.5), vec4(0.673589), fragCoord, fragColor);\n    store_buf(vec2(6.5, 3.5), vec4(0.505564), fragCoord, fragColor);\n    store_buf(vec2(7.5, 3.5), vec4(0.355949), fragCoord, fragColor);\n    store_buf(vec2(0.5, 4.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 4.5), vec4(0.999665), fragCoord, fragColor);\n    store_buf(vec2(2.5, 4.5), vec4(0.986371), fragCoord, fragColor);\n    store_buf(vec2(3.5, 4.5), vec4(0.930421), fragCoord, fragColor);\n    store_buf(vec2(4.5, 4.5), vec4(0.813602), fragCoord, fragColor);\n    store_buf(vec2(5.5, 4.5), vec4(0.678975), fragCoord, fragColor);\n    store_buf(vec2(6.5, 4.5), vec4(0.537882), fragCoord, fragColor);\n    store_buf(vec2(7.5, 4.5), vec4(0.403271), fragCoord, fragColor);\n    store_buf(vec2(0.5, 5.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 5.5), vec4(0.999025), fragCoord, fragColor);\n    store_buf(vec2(2.5, 5.5), vec4(0.973317), fragCoord, fragColor);\n    store_buf(vec2(3.5, 5.5), vec4(0.900245), fragCoord, fragColor);\n    store_buf(vec2(4.5, 5.5), vec4(0.804126), fragCoord, fragColor);\n    store_buf(vec2(5.5, 5.5), vec4(0.703751), fragCoord, fragColor);\n    store_buf(vec2(6.5, 5.5), vec4(0.594890), fragCoord, fragColor);\n    store_buf(vec2(7.5, 5.5), vec4(0.481143), fragCoord, fragColor);\n    store_buf(vec2(0.5, 6.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 6.5), vec4(0.992850), fragCoord, fragColor);\n    store_buf(vec2(2.5, 6.5), vec4(0.926124), fragCoord, fragColor);\n    store_buf(vec2(3.5, 6.5), vec4(0.860745), fragCoord, fragColor);\n    store_buf(vec2(4.5, 6.5), vec4(0.833379), fragCoord, fragColor);\n    store_buf(vec2(5.5, 6.5), vec4(0.782873), fragCoord, fragColor);\n    store_buf(vec2(6.5, 6.5), vec4(0.703637), fragCoord, fragColor);\n    store_buf(vec2(7.5, 6.5), vec4(0.620129), fragCoord, fragColor);\n    store_buf(vec2(0.5, 7.5), vec4(0.987461), fragCoord, fragColor);\n    store_buf(vec2(1.5, 7.5), vec4(0.938899), fragCoord, fragColor);\n    store_buf(vec2(2.5, 7.5), vec4(0.942983), fragCoord, fragColor);\n    store_buf(vec2(3.5, 7.5), vec4(0.943682), fragCoord, fragColor);\n    store_buf(vec2(4.5, 7.5), vec4(0.943818), fragCoord, fragColor);\n    store_buf(vec2(5.5, 7.5), vec4(0.943681), fragCoord, fragColor);\n    store_buf(vec2(6.5, 7.5), vec4(0.943351), fragCoord, fragColor);\n    store_buf(vec2(7.5, 7.5), vec4(0.942877), fragCoord, fragColor);\n\n    float BIAS = 8.;\n    \n    store_buf(vec2(BIAS+0.5, 0.5), vec4(0.000200, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 0.5), vec4(0.040821, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 0.5), vec4(0.163499, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 0.5), vec4(0.359810, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 0.5), vec4(0.608219, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 0.5), vec4(0.849327, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 0.5), vec4(1.026876, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 0.5), vec4(1.127918, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 1.5), vec4(0.000200, -0.000046, 1.052217, 0.228243), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 1.5), vec4(0.040821, -0.009316, 1.052066, 0.228242), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 1.5), vec4(0.163218, -0.036566, 1.051517, 0.228141), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 1.5), vec4(0.360871, -0.077435, 1.049110, 0.226851), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 1.5), vec4(0.608870, -0.112986, 1.040456, 0.216178), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 1.5), vec4(0.850681, -0.110371, 1.022363, 0.171798), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 1.5), vec4(1.033758, -0.063836, 1.011022, 0.089896), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 1.5), vec4(1.130218, 0.000062, 1.000010, -0.000080), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 2.5), vec4(0.000200, -0.000096, 1.232269, 0.481573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 2.5), vec4(0.040829, -0.019653, 1.232083, 0.481559), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 2.5), vec4(0.163323, -0.077152, 1.229494, 0.481157), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 2.5), vec4(0.361362, -0.161748, 1.215935, 0.476966), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 2.5), vec4(0.602530, -0.224893, 1.149731, 0.444834), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 2.5), vec4(0.832866, -0.211716, 1.066321, 0.339254), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 2.5), vec4(1.033638, -0.123274, 1.025543, 0.170803), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 2.5), vec4(1.137644, 0.000154, 0.999953, -0.000082), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 3.5), vec4(0.000199, -0.000159, 1.627474, 0.797472), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 3.5), vec4(0.040836, -0.032524, 1.635685, 0.797401), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 3.5), vec4(0.164108, -0.127318, 1.628042, 0.795956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 3.5), vec4(0.365844, -0.258932, 1.575327, 0.783120), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 3.5), vec4(0.602895, -0.339455, 1.372632, 0.710306), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 3.5), vec4(0.825683, -0.302224, 1.158343, 0.512880), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 3.5), vec4(1.030563, -0.173519, 1.049980, 0.243539), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 3.5), vec4(1.151713, 0.000105, 0.999957, -0.000055), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 4.5), vec4(0.000198, -0.000248, 2.529443, 1.253956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 4.5), vec4(0.040880, -0.051100, 2.570697, 1.253684), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 4.5), vec4(0.166706, -0.198049, 2.542881, 1.248409), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 4.5), vec4(0.380361, -0.384441, 2.334701, 1.206127), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 4.5), vec4(0.617299, -0.459699, 1.772357, 1.025249), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 4.5), vec4(0.835445, -0.380695, 1.304201, 0.680722), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 4.5), vec4(1.040850, -0.213042, 1.089431, 0.306573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 4.5), vec4(1.176060, 0.000010, 1.000023, -0.000021), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 5.5), vec4(0.000187, -0.000388, 4.301116, 2.076506), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 5.5), vec4(0.041070, -0.084546, 5.305590, 2.075270), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 5.5), vec4(0.175521, -0.321638, 5.161014, 2.051541), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 5.5), vec4(0.413187, -0.560077, 4.055352, 1.869406), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 5.5), vec4(0.665130, -0.580464, 2.432246, 1.376237), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 5.5), vec4(0.870094, -0.441204, 1.506300, 0.819691), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 5.5), vec4(1.068578, -0.241436, 1.137736, 0.354430), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 5.5), vec4(1.219174, -0.000534, 1.000063, 0.000162), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 6.5), vec4(0.000144, -0.000631, 6.468958, 4.381222), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 6.5), vec4(0.042200, -0.177353, 20.085962, 4.369584), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 6.5), vec4(0.209979, -0.606367, 16.868328, 4.106197), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 6.5), vec4(0.500901, -0.795643, 8.099620, 2.893355), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 6.5), vec4(0.769693, -0.688227, 3.439625, 1.659662), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 6.5), vec4(0.955036, -0.470746, 1.760819, 0.883184), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 6.5), vec4(1.134532, -0.254869, 1.190455, 0.377490), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 6.5), vec4(1.308330, -0.002944, 0.999844, 0.001275), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 7.5), vec4(0.000102, -0.118482, 1184.816772, 1184.816284), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 7.5), vec4(0.319603, -3.097308, 7133.888672, 23.645655), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 7.5), vec4(0.546638, -1.442077, 133.966263, 8.593670), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 7.5), vec4(0.837342, -1.129903, 20.226521, 3.658263), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 7.5), vec4(1.004258, -0.809128, 5.700182, 1.768790), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 7.5), vec4(1.117055, -0.531464, 2.269246, 0.923613), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 7.5), vec4(1.336692, -0.312752, 1.241618, 0.414403), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 7.5), vec4(1.670654, -0.056394, 0.998759, 0.033416), fragCoord, fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x > 16. || fragCoord.y > 8. ) discard;\n\tsetLUT(fragCoord, fragColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}