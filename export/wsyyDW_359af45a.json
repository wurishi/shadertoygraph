{"ver":"0.1","info":{"id":"wsyyDW","date":"1603428272","viewed":151,"name":"Atmospheric - 1","username":"Rugged","description":"Using raycasting to do atmospheric refraction. I'm not close to finishing it so this is only a work in progress. Use mouse (click and drag) to change atmosphere color. \n\nupdate: yeah I'm just abandoning it, going to do new projects.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//all written by me (Rugged)\n\n\nfloat wS = 0.0f;\n\nvec3 sunCenter = vec3(0.0f, 0.0f, 0.0f);\nfloat sunRadius = 500.0f;\nvec3 sunColor = vec3(1.0f, 1.0f, 1.0f);\n\nvec3 planetCenter = vec3(0.0f, 10000.0f, 0.0f);\nfloat planetRadius = 150.0f;\nfloat atmoRadius = 160.0f;\nfloat turnRadius = 2.0f;\n\n//camera position and angles\nvec3 camCenter = vec3(0.0f, 0.0f, 0.0f);\nfloat camToPlanD = 400.0f;\n\nfloat PI = radians(180.0f);\n\n\nvec3 dvCP = vec3(0.0f, 0.0f, 0.0f);\n\nfloat turnAng = radians(400.0f);\nfloat turnSpeed = 1.0f;\n\n\n//these are the camera view angles\n//not being used currently as the camera is set to look at the planet\nfloat phi = 0.0f;\nfloat theta = 0.0f;\n\n\n\nfloat phiFOV = 45.0f;\nfloat thetaFOV = 45.0f;\n\n\n\n\n//direction vector of the camera angles\nvec3 dV = vec3(0.0f, 0.001f, 0.001f);\n\nfloat discrm = 0.0f;\n\nfloat scatP = 2.0f;\n\nvec3 raySphere(bool pn, vec3 origin, vec3 center, float radius, vec3 dir){\n    \n    float a = pow(dir.x, 2.0f) + pow(dir.y, 2.0f) + pow(dir.z, 2.0f);\n    float b = 2.0f * ((dir.x * origin.x) - (center.x * dir.x) + (dir.y * origin.y) - (center.y * dir.y) + (dir.z * origin.z) - (center.z * dir.z));\n    float c = pow(origin.x, 2.0f) + pow(origin.y, 2.0f) + pow(origin.z, 2.0f) + pow(center.x, 2.0f) + pow(center.y, 2.0f) + pow(center.z, 2.0f) - 2.0f * ((center.x * origin.x) + (center.y * origin.y) + (center.z * origin.z)) - pow(radius, 2.0f);\n    \n    discrm = pow(b, 2.0f) - (4.0f * a * c);\n    \n    if (pn && discrm >= 0.0f){\n        float tP = (-b + sqrt(pow(b, 2.0f) - (4.0f * a * c)))/(2.0f * a);\n        vec3 iP = vec3((tP * dir.x) + origin.x, (tP * dir.y) + origin.y, (tP * dir.z) + origin.z);\n        return iP;\n    }\n    else if (discrm >= 0.0f){\n        float tN = (-b - sqrt(pow(b, 2.0f) - (4.0f * a * c)))/(2.0f * a);\n        vec3 iN = vec3((tN * dir.x) + origin.x, (tN * dir.y) + origin.y, (tN * dir.z) + origin.z);\n        return iN;\n    }\n    else{\n        return vec3(1.0f, 0.0f, 0.0f);\n    }\n    \n}\n\n\nbool checkInCircle(vec2 coords, float r, float d, float w){\n    r+=2000.0f;\n    coords -= vec2(0.5f, 0.5f);\n    float r2 = pow((r * w)/(d*2.0f), 2.0f);\n    float a1 = sqrt(r2 - pow(coords.x, 2.0f));\n    float a2 = -sqrt(r2 - pow(coords.x, 2.0f));\n    bool c = (a1 >= coords.y && a2 <= coords.y);\n    return c;\n}\n\nvec3 getDirecVec(vec3 p1, vec3 p2){\n    return (p2 - p1)/distance(p1, p2);\n    \n}\n\nvec2 getAng(vec3 direc){\n    //see desmos graph for explanation on calculations\n    float t = direc.y/abs(direc.y);\n    float ad = -(t * PI) + PI;\n    \n    //r is the hight for the z plane. \n    float r = distance(direc.x, direc.y);\n    float t2 = r/abs(r);\n    float ad2 = -(t2 * PI) + PI;\n    \n    return vec2(-atan(direc.y/direc.x), -atan(r/direc.z)); //vec2(ad + (t * acos(direc.x/r)), ad2 + (t2 * acos(direc.z/distance(direc.r, direc.z))));\n}\n\nvec3 getDirecVecAng(float phiA, float thetaA){\n    \n    return vec3(sin(thetaA) * cos(phiA), sin(thetaA)* sin(phiA), cos(thetaA));\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camCenter = planetCenter;\n    camCenter.x += camToPlanD;\n    \n    \n    \n    \n    //gets texture resolution\n    vec2 texRes = iChannelResolution[0].xy;\n    \n    \n    //distance from the camera to the planet center\n    float dP = distance(planetCenter, camCenter);\n    \n    \n    \n    //turns the camera around the planet\n    vec4 mouse = iMouse/iResolution.xxxx;\n    vec2 look = iMouse.xy/iResolution.xy;\n    float time = (iTime * 0.1f) - .2;\n    float turn = turnSpeed * turnAng * time;\n    float click = mouse.z;\n    \n    \n    //replace time with look.x to get mouse control\n    //do this also on the line where phi gets changed\n    camCenter = planetCenter + (dP * getDirecVecAng(turn, radians(90.0f)));\n    //phi += (radians((look.x * 90.0f) - 45.0f));\n    //theta += (radians((look.y * 90.0f) - 45.0f));\n    \n    \n    \n    \n    //initialize angles to pointing at sphere\n    dvCP = getDirecVec(camCenter, planetCenter);\n    \n    //float t1 = dvCP.y/abs(dvCP.y);\n    //float t2 = dvCP.x/abs(dvCP.x);\n    \n    \n    phi = ((turn)- radians(180.0f));//t1 * acos(dvCP.y/distance(dvCP.y, dvCP.x));\n    \n    theta = radians(90.0f);\n    \n    \n    \n    \n    \n    \n    \n    //updates the current window size for the current resolution\n    wS = min(iResolution.x, iResolution.y);\n    float wR = iResolution.y/iResolution.x;\n    \n    phiFOV /= wR;\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    \n    \n    \n    \n    float angP = phi - radians((uv.x * phiFOV) - (phiFOV / 2.0f));\n    float angT = theta - radians((uv.y * thetaFOV) - (thetaFOV / 2.0f));\n        \n    \n    \n    \n    //sets the direction vector for the camera angles\n    vec3 dvCam = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    //sets direction vector for ray\n    dV = getDirecVec(camCenter, camCenter + (dP * vec3(cos(angP) * sin(angT), sin(angP) * sin(angT), cos(angT))));\n    \n    \n    \n    \n    \n    \n    \n\n    //checks to see if the pixel is inside the view circle (this can be used to cut of extra calculations)\n    //bool check = checkInCircle(fragCoord - (iResolution.xy/2.0f), atmoRadius, dP, wS);\n    vec4 col = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    \n    \n    \n    if (true){\n        \n        //cast the rays for the planet\n        vec3 interPpl = raySphere(true, camCenter, planetCenter, planetRadius, dV);\n        vec3 interNpl = raySphere(false, camCenter, planetCenter, planetRadius, dV);\n        \n        vec3 nearPpl = (distance(camCenter, interNpl) > distance(camCenter, interPpl)) ? interPpl : interNpl;\n        \n        //set the color of the planet\n        vec3 colPlanet = vec3(0.2f, 0.1f, 0.0f);\n       \t\n        bool hitPlan = false;\n        \n        //checks to see that the ray hits the sphere and that its in front of the camera\n        //this one is for the planet\n        if (discrm >= 0.0f && dot(dvCam, getDirecVec(camCenter, planetCenter)) >= 0.0f){\n            //col = colPlanet;\n            \n            hitPlan = true;\n            \n            \n            \n            \n            \n            //gets the angles for the interesect point on the planet\n            vec3 dvIP = getDirecVec(planetCenter, nearPpl);\n            vec2 angs = getAng(dvIP);\n            \n            float sha = dot(dvIP, getDirecVec(nearPpl, sunCenter));\n            \n            float shadow = pow(sha, 3.0f) + (0.5f * sha) + 0.55f;\n            \n            //if (dot(dvIP, getDirecVec(nearPpl, sunCenter)) < 0.0f){\n            col = texture(iChannel0, angs/3.2f) * pow(shadow, 3.0f);\n            //}\n            //else{\n                \n            \t//col = texture(iChannel0, angs/3.2f);\n            //}\n                    \n                    \n            \n            \n            \n            \n            \n            \n        }\n        //does the suns ray casting\n        else{\n            vec3 interSP = raySphere(true, camCenter, sunCenter, sunRadius, dV);\n            vec3 interSN = raySphere(false, camCenter, sunCenter, sunRadius, dV);\n            \n            vec3 nearPS = (distance(camCenter, interSN) > distance(camCenter, interSP)) ? interSP : interSN;\n            \n            vec3 dvS = getDirecVec(camCenter, sunCenter);\n            \n            if (discrm >= 0.0f && dot(dvCam, dvS) >= 0.0f){\n                float dtS = distance(interSP, interSN);\n                \n                float dpS = dot(dV, getDirecVec(nearPS, sunCenter));\n                \n                float dS = distance(nearPS, sunCenter);\n\t\t\t\t\n                float tS =  pow(dpS, 2.0f);\n\t\t\t\t                \n                col = vec4(sunColor, 1.0f);// * texture(iChannel1, dpS*iChannelResolution[1].xy, 1.0f).x;\n                \n                col.rgb *= tS;\n                \n            }\n            \n            \n        }\n        \n        //cast the rays for the atmosphere\n        vec3 interP = raySphere(true, camCenter, planetCenter, atmoRadius * (1.5f - (1.0f / scatP)), dV);\n    \tvec3 interN = raySphere(false, camCenter, planetCenter, atmoRadius * (1.5f - (1.0f / scatP)), dV);\n        \n        \n        //closest intersect point to camera\n        vec3 nearPAtm = (distance(camCenter, interN) > distance(camCenter, interP)) ? interP : interN; //vec3(0.0f, 0.0f, 0.0f);\n        \n        \n        \n        //if the ray hit the planet then the distance of atmosphere traversed is from intersect to surface, else it's from intersect to intersect\n        float dAtm = hitPlan ? distance(nearPAtm, nearPpl) : distance(interP, interN);\n       \n        \n        if (discrm >= 0.0f && dot(dvCam, getDirecVec(camCenter, nearPAtm)) >= 0.0f){\n            vec3 colAtm = click <= 0.0f ? vec3(0.25f, 0.6f, 1.0f) : vec3(look.x * 2.0f, look.y * 2.0f, 1.0f);\n            \n     \n            \n            \n            //absolute vector between the intersect points\n            vec3 v1 = abs(interP - interN);\n            \n            \n            \n            \n            \n            float scatter = dot(getDirecVec(planetCenter, nearPAtm), getDirecVec(nearPAtm, sunCenter));\n            \n            colAtm *= scatter;//vec3(pow(scatter, .5f), pow(scatter, 1.0f), pow(scatter, 1.0f));\n           \n            \n            \n            \n            \n           \n            \n            \n            //adjust color\n            colAtm *= pow(dAtm / 70.0f, 2.0f);\n            \n            col.rgb = mix(col.rgb, colAtm, 0.8f) * sunColor;\n            \n            //col.rgb = vec3(1.0f, 1.0f, 1.0f);\n            \n        }\n        //if (!hitPlan){\n        //((col.rbg + (colAtm * 1.0f))/ 2.0f);\n        //}\n            \n        \n        \n       \n    }\n        \n    \n    \n    \n    \n    \n    //checks to see if the rays need to be calculated\n    \n    \n    \n    // Output to screen\n    fragColor = col;\n}\n\n","name":"Image","description":"","type":"image"}]}