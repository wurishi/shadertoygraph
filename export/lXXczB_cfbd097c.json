{"ver":"0.1","info":{"id":"lXXczB","date":"1726734011","viewed":30,"name":"Learn SH","username":"w450468524","description":"learn about spherical harmonics\nhttps://www.ppsloan.org/publications/StupidSH36.pdf\nhttps://www.activision.com/cdn/research/ZH3-Publication.pdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphereharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sperical Harmonics\n//\n// P_l^m cos(theta)cos(m * phi) m >= 0\n//\n// P_l^m cos(theta)sin(|m|*phi) m < 0\n//\n// P_l^m is Legendre Polynomial\n//\n\n// 1/sqrt(pi)/2\n#define SH0_0 0.282094791773878\n// sqrt(3/4pi)\n#define SH1_1 0.48860251190292\n// sqrt(15/4pi)\n#define SH2_2 1.092548430592079\n// sqrt(5/16pi)\n#define SH2_0 0.31539156525252\n// sqrt(15/16pi)\n#define SH2_N2 0.54627421529604\n\nvec2 SDFSphere(vec3 pos, vec4 sphereDesc, int type)\n{\n    vec3 dir = (pos - sphereDesc.xyz).zxy;\n    float d = length(dir);\n    dir = dir / d;\n \n    float shValue = 0.0;\n    float s = 0.0;\n    \n    switch (type)\n    {\n        case 0: // SH0_0\n        shValue = 1.0 * SH0_0;\n        break;\n        \n        case 1: // SH1_1\n        shValue = -dir.y * SH1_1;\n        break;\n        \n        case 2: // SH1_0\n        shValue = dir.z * SH1_1;\n        break;\n        \n        case 3: // SH1_-1\n        shValue = -dir.x * SH1_1;\n        break;\n        \n        case 4: // SH2_2\n        shValue = dir.x*dir.y * SH2_2;\n        break;\n        \n        case 5: // SH2_1 \n        shValue = -dir.y*dir.z  * SH2_2;\n        break;\n        \n        case 6: // SH2_0\n        shValue = (3.0*dir.z*dir.z - 1.0) * SH2_0;\n        break;\n        \n        case 7: // SH2_-1\n        shValue = -dir.x * dir.z * SH2_2;\n        break;\n        \n        case 8: // SH2_-2\n        shValue = (dir.x * dir.x - dir.y * dir.y) * SH2_N2;\n        break;\n    }\n    \n    s = sign(shValue);\n    shValue = abs(shValue);\n    \n    // We apply SH function values to sphere radius\n    return vec2(d - sphereDesc.w * shValue, s);\n}\n\nvec3 camRay(vec3 forward, vec3 up, vec2 uv, float aspect)\n{\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    vec3 screenVec = vec3(uv -0.5, 0);\n    screenVec.x *= aspect;\n    return normalize(forward + screenVec.x * right + screenVec.y * up);\n}\nconst float step = 0.1;\n#define STEP_COUNT 500\n#define HIT_THRESHOLD 0.001\n\nvec2 SceneDist(vec3 pos, int type)\n{\n    vec2 dist = SDFSphere(pos, vec4(0.0, 0.0, 0.0, 2.0), type);\n    // dist = min(dist, SDFSphere(pos, vec4(2.0, 1.0, - 8, 2)));\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float rotateRadius = 4.0;\n    float rotateSpeed = 2.0;\n    \n    vec3 camPos = vec3(rotateRadius * sin(iTime * rotateSpeed), 3.0, rotateRadius * cos(iTime * rotateSpeed));\n    vec3 camLookAt = vec3(0);\n    \n    vec3 dir = camRay(normalize(camLookAt - camPos), vec3(0, 1, 0), uv, iResolution.x / iResolution.y);\n    vec2 dist = vec2(1.0);\n    \n    vec3 pos = camPos;\n    float d = 0.0;\n    int type = int(mod(iTime/2.0, 9.0));\n    // int type =4;\n    for (int i = 0; i < STEP_COUNT; ++i)\n    {\n        dist = SceneDist(pos, type);\n        d += dist.x * 0.2;\n        pos = dir * d + camPos;\n        \n        if (dist.x <= HIT_THRESHOLD)\n        {\n            if (dist.y > 0.0)\n                fragColor = vec4(1.0, 0, 0, 1);\n            else\n                fragColor = vec4(0, 1.0, 0, 1);\n            return;\n        }\n    }\n    \n    fragColor = vec4(abs(dir), 0.0);\n}","name":"Image","description":"","type":"image"}]}