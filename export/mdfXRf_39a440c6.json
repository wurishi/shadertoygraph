{"ver":"0.1","info":{"id":"mdfXRf","date":"1669297000","viewed":71,"name":"circles_danb","username":"danbshading","description":"circles","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 circle(vec2 uv, vec2 pos, float radius, vec3 colour)\n{\n\n    vec3 circ = vec3(step(length(uv - pos),radius));\n    circ *= colour;\n    \n    return circ;\n}\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 0.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI);\n    }\n    \n    else if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI*-0.5);\n    } \n    \n    else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,PI*0.5);\n    } \n    \n    else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        //_st = rotate2D(_st,PI);\n    }\n\n    return _st;\n}\n\nfloat oscillator(vec2 iPos, float phase)\n{\n    return sin((iTime/2.0) + 3.0*random(iPos) + phase);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //uv = 2.0*(uv - vec2(0.5));\n    uv += vec2(0.09*iTime,0.13*iTime);\n    uv *= 8.0;\n    vec2 iPos = floor(uv);\n    uv = fract(uv);\n    //int iPos = floor(uv);\n    //float fPos = fract(uv);\n    uv = rotateTilePattern(uv);\n\n    uv = uv*1.0;\n    \n    \n    \n    vec3 col1 = vec3(1.0,0.5,0.0);\n    //vec2 pos1 = vec2(0.25*((sin(iTime)) + 1.0));\n    vec2 pos1 = vec2(abs(oscillator(vec2(0.0),0.0)));\n    float scale1 = 0.5*abs(sin(iTime) + 0.1);\n    scale1 = 0.5*abs(sin(iTime) + 0.1);\n    //scale1 *= scale1;\n    vec3 circ1 = circle(uv, pos1, scale1 ,col1);\n    \n    vec3 col2 = vec3(-abs(oscillator(iPos,PI/2.0) + 1.0)/2.0,-abs(oscillator(iPos,PI) + 1.0)/2.0,-abs(oscillator(iPos,0.0) + 1.0)/2.0);\n    vec3 circ2 = circle(uv, vec2(0.5), 0.3,col2);\n    \n    vec3 col3 = col2.yxz;\n    vec2 pos3 = vec2(0.5) + 0.3*vec2(sin(iTime),cos(iTime));\n    vec3 circ3 = circle(uv, pos3, 0.1, col3);\n    \n    vec3 col4 = col2.zxy;\n    vec2 pos4 = vec2(0.5) + 0.3*vec2(sin(iTime + PI),cos(iTime + PI));\n    vec3 circ4 = circle(uv, pos4, 0.1, col4);\n    \n    // Output to screen\n    fragColor = vec4(circ1 - circ2 - circ3 - circ4,1.0);\n    //fragColor = vec4(circ1 * circ2 * circ3 * circ4,1.0);\n}","name":"Image","description":"","type":"image"}]}