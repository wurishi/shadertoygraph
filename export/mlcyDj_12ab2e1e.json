{"ver":"0.1","info":{"id":"mlcyDj","date":"1699659850","viewed":122,"name":"Hamster Mega Scroll","username":"starmole2","description":"mega scroller\nfriday fun project! \nlighting could be much improved, as well as the background - neither should need textures to look 90s! ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["text","scroll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 texChar(int char, vec2 uv) {\n    vec2 uvc = clamp(uv, vec2(0.0), vec2(1.0));\n    uvc.x += float(char&15);\n    uvc.y += float(15-(char>>4));\n    return textureLod(iChannel0, uvc * 1.0/16.0, 0.0);\n}\n\nconst int[] text = int[](_SP,_SP,_H,_E,_L,_L,_O,_SP,_S,_P,_A,_C,_E,_EX,_SP,\n    _T,_H,_I,_S,_SP,_I,_S,_SP,_M,_Y,_SP,_F,_R,_I,_D,_A,_Y,_SP,_M,_E,_G,_A,_S,_C,_R,_O,_L,_L,_E,_R,_EX,_SP,\n    _H,_A,_M,_S,_T,_E,_R,_S,_SP,_R,_U,_L,_E,_DO,_DO,_DO,_SP); \n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTextBox ( vec3 p, vec3 b, int char ) {\n    float l = sdBox(p,b);\n    if ( abs(l) > .5 ) return l;\n    vec2 pn = (p.xy / b.xy) * .5 + .5;\n    float lt = (texChar(char, pn*vec2(0.5,0.75)+vec2(0.25,0.125)).w - .5)*.35;\n    return max(lt,l); \n}\n\nfloat sd ( vec3 p ) {\n    float pnx = p.x *.5 + .5;\n    p.x = fract(pnx)*2.0 - 1.0;\n    int ch = text[int(abs(pnx)) % text.length()];\n    \n    return sdTextBox(p, vec3(.95,.95,.5), ch);\n}\n\nvec3 normal ( vec3 p ) {\n    float eps = 0.04;\n    vec3 n;\n    n.x = sd(vec3(p.x-eps, p.y, p.z)) - sd(vec3(p.x+eps, p.y, p.z));\n    n.y = sd(vec3(p.x, p.y-eps, p.z)) - sd(vec3(p.x, p.y+eps, p.z));\n    n.z = sd(vec3(p.x, p.y, p.z-eps)) - sd(vec3(p.x, p.y, p.z+eps));\n    return normalize(n);\n}\n\nfloat raymarch ( vec3 org, vec3 dir, float tmax ) {\n    int maxsteps = 300;\n    float eps = 0.005;\n    float t = eps;\n    for ( int i=0; i<maxsteps; i++ ) {\n        float d = sd(org+dir*t);\n        if ( abs(d) < eps )\n            return t;\n        t += d;\n        if ( t < 0.0 || t > tmax) \n            break;\n    }\n    return -1.0;\n}\n\nvec2 mirror(vec2 p) {\n    return abs(fract(p*.5)*2.0-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvbase = fragCoord.xy/iResolution.xy;\n    vec2 uv = uvbase * 2.0 - vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 org = vec3(0.0, 0.0, -2.0);\n    vec3 dir = normalize(vec3(uv.x,uv.y,2.0));\n    org.x += iTime * 1.6;\n\n    vec4 col = vec4(0.0);\n    \n    // phoning it in for the background...\n    col.xyz = pow(texture(iChannel1, mirror(uvbase + vec2(-iTime*.05,0.0))).xyz,vec3(4.2)) *.6;\n    \n    \n    mat3 cammat = rotmat(vec3(1.0,0.0,0.0), sin(iTime)*.4);\n    org *= cammat;\n    dir *= cammat;    \n\n    // add some noise... always nice to do\n    org += dir * pcg3dfn(vec3(fragCoord.xy, iTime*1000.0)).x * 0.5;\n\n\n    float t = raymarch(org, dir, 10.0);\n    if ( t > 0.0 ) {\n        vec3 n = normal(org+dir*t);\n        vec3 r = reflect(dir, n);\n        // should do something more artistic... \n        vec3 spec = pow(texture(iChannel2, r).xyz,vec3(2.2)).zyx * 1.2;\n        vec3 diff = pow(texture(iChannel3, -n).xyz,vec3(2.2)).zyx * .3;\n        \n        col.xyz = spec + diff;\n        //col.xyz = n*.5 + vec3(.5);\n        col.w = 1.0;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(pow(col.xyz,vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n#define _SP 32\n#define _EX 33\n#define _QS 63\n#define _DO 46\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n\nmat3 rotmat(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nuvec3 pcg3d(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return v;\n}\n\nuvec3 uround(vec3 pos) {\n   return uvec3(abs(ivec3(floor(pos))+64000));\n}\n\nvec3 fround(uvec3 x) {\n    return fract(vec3(x)*(1.0/64000.0)) * 2.0 - 1.0;\n}\n\nvec3 pcg3dfn(vec3 pos) {\n    return fround(pcg3d(uround(pos)));\n}\n\nvec3 smix(vec3 a, vec3 b, float f) {\n    return mix(a,b,f);\n    //return mix(a,b,smoothstep(0.0, 1.0, f));\n}\n\nvec3 pcg3dfl(vec3 pos) {\n    uvec3 pu = uround(pos);\n    vec3 p000 = fround(pcg3d(pu + uvec3(0,0,0)));\n    vec3 p100 = fround(pcg3d(pu + uvec3(1,0,0)));\n    vec3 p010 = fround(pcg3d(pu + uvec3(0,1,0)));\n    vec3 p110 = fround(pcg3d(pu + uvec3(1,1,0)));\n    vec3 p001 = fround(pcg3d(pu + uvec3(0,0,1)));\n    vec3 p101 = fround(pcg3d(pu + uvec3(1,0,1)));\n    vec3 p011 = fround(pcg3d(pu + uvec3(0,1,1)));\n    vec3 p111 = fround(pcg3d(pu + uvec3(1,1,1)));\n    vec3 f = fract(pos);\n    vec3 p00 = smix(p000, p100, f.x);\n    vec3 p10 = smix(p010, p110, f.x);\n    vec3 p01 = smix(p001, p101, f.x);\n    vec3 p11 = smix(p011, p111, f.x);\n    vec3 p0 = smix(p00, p10, f.y);\n    vec3 p1 = smix(p01, p11, f.y);\n    return mix(p0,p1,f.z);\n}\n\nvec3 perlin(vec3 pos, int n) {\n     vec3 r = vec3(0.0);\n     float s = 1.0;\n     for ( int i=0; i<n; i++ ) {\n         vec3 rp = pcg3dfl(pos); \n         r += rp * s;\n         //pos += rp * s;\n         pos *= 2.0;\n         s *= .5;\n     }\n     return r;\n}","name":"Common","description":"","type":"common"}]}