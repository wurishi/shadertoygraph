{"ver":"0.1","info":{"id":"WltXDn","date":"1580950937","viewed":345,"name":"veyerus","username":"monsterkodi","description":"my take on the virus theme,\nit is quite contagious :)","likes":22,"published":1,"flags":16,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define keys(x,y)  texelFetch(iChannel0, ivec2(x,y), 0)\n#define load(x)    texelFetch(iChannel1, ivec2(x,0), 0)\n#define load3(x,y) texelFetch(iChannel3, ivec2(x,y), 0)\n#define font(x,y)  texelFetch(iChannel2, ivec2(x,y), 0)\n\nbool keyState(int key) { return keys(key, 2).x < 0.5; }\nbool keyDown(int key)  { return keys(key, 0).x > 0.5; }\n\n#define ZERO min(iFrame,0)\n#define MAX_STEPS  128\n#define MIN_DIST   0.01\n#define MAX_DIST   60.0\n#define SHADOW     0.2\n\n#define NONE 0\n#define SKIN 1\n#define BULB 2\n#define PUPL 3\n\n#define CORE_RADIUS 1.2\n#define CAM_DIST    30.0\n\nvec3 BG_COLOR;\n\nfloat EYE_RADIUS = 0.8;\nfloat heartBeat;\nfloat bgH, bgS, bgL;\n\nbool anim, soft, occl, light, dither, rotate, normal, depthb;\n\nvec3 camPos;\nvec3 camTgt;\nvec3 camDir;\n\nint  AA = 2;\nint  shape;\nfloat[5] eyeRadii = float[5](0.8, 1.2, 0.9, 0.7, 0.7);\nfloat[5] stalkLen = float[5](1.0, 0.8, 0.9, 1.0, 1.0);\n\n//  0000000   000   000  000  00     00  \n// 000   000  0000  000  000  000   000  \n// 000000000  000 0 000  000  000000000  \n// 000   000  000  0000  000  000 0 000  \n// 000   000  000   000  000  000   000  \n\nfloat iFade(float a, float b, float s)\n{\n    return a + (b-a) * (1.0 - (sin(iTime*s) * 0.5 + 0.5));\n}\n\nvoid calcAnim()\n{\n    if (anim)\n    {\n        heartBeat = smoothstep(1.0, 0.8, sin(1.5*iTime*TAU)*0.5+0.5);\n        bgH = iFade(0.66,0.67,0.1);\n        bgS = iFade(0.75,0.8,0.1);\n        bgL = iFade(0.15,0.05,0.1);\n    }\n    else\n    {\n        heartBeat = 0.0;\n        bgH = 2./3.;\n        bgS = 0.75;\n        bgL = 0.15;\n    }\n    \n    shape = int(mod(iTime*0.08,5.0));\n    EYE_RADIUS = eyeRadii[shape];\n\n    BG_COLOR = hsl(bgH, bgS, bgL);\n    \n    if (light) BG_COLOR = gray(BG_COLOR);\n}\n\n//  0000000  000000000   0000000   000      000   000  \n// 000          000     000   000  000      000  000   \n// 0000000      000     000000000  000      0000000    \n//      000     000     000   000  000      000  000   \n// 0000000      000     000   000  0000000  000   000  \n\nfloat stalk(float open, vec3 pos)\n{    \n    float d = sdCapsule(v0, pos, 0.3);\n    d = opUnion(d, sdSphere(pos, EYE_RADIUS*1.25));    \n    d = opInter(d, sdPlane(pos*(2.0-open), normalize(pos)), 0.2);\n    return d;\n}\n\n// 00000000  000   000  00000000  \n// 000        000 000   000       \n// 0000000     00000    0000000   \n// 000          000     000       \n// 00000000     000     00000000  \n\nvoid eye(float id, vec3 pos)\n{\n    vec3  n   = normalize(pos);\n    float r   = EYE_RADIUS;\n    float d   = sdSphere(pos, r);\n    \n    if (d > gl.sdf.dist) return;\n        \n    if (d < gl.sdf.dist) { gl.sdf.mat = BULB; gl.sdf.dist = d; }\n\n    vec3 hsh1 = hash31(id+floor(iTime*id/(id-0.5)*0.2));\n    vec3 hsh2 = hash31(id+floor(iTime*id/(id-0.5)*0.3));\n    n  = normalize(n+(hsh1 + hsh2 - 1.0)*(dot(n,vz)-0.5));\n    vec3 lens = pos + 0.67 * r * n;\n    d = sdPill(lens,  0.6*r, n*0.2);\n    \n    if (d < gl.sdf.dist) { gl.sdf.mat = PUPL; gl.sdf.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    vec4 m = chooseMap(p, shape);\n    \n    p  = m.xyz;\n    float id = m.w;\n    float time = anim ? iTime : 0.0;\n    \n    gl.sdf = SDF(MAX_DIST, p, NONE);\n    \n    float d = sdSphere(v0, CORE_RADIUS*(1.2-0.4*heartBeat));\n\n    float blink = smoothstep(0.9999, 0.9980, sin(id+time*1.1)*0.5+0.5);\n    bool  actve = fract(id/12.0+time/30.0) < 0.5;\n    float open  = actve ? blink : 0.0;\n    \n    float jmp = actve ?\n        0.15*smoothstep(0.5, 0.6, sin(id+time*1.3)) : \n        0.15*sin(id+time*3.0);\n    float len = 4.0 - jmp + 0.7*sin(time*0.5);\n        \n    vec3 pos = vy * len * stalkLen[shape];\n    \n    d = opUnion(d, stalk(open, pos), 0.05+0.3*heartBeat);\n    \n    if (d < gl.sdf.dist) { gl.sdf.mat = SKIN; gl.sdf.dist = d; }\n\n    if (open > 0.8f)\n    {\n        eye(id, pos);\n    }\n\n    return gl.sdf.dist;\n}\n\n// 000   000   0000000   00000000   00     00   0000000   000      \n// 0000  000  000   000  000   000  000   000  000   000  000      \n// 000 0 000  000   000  0000000    000000000  000000000  000      \n// 000  0000  000   000  000   000  000 0 000  000   000  000      \n// 000   000   0000000   000   000  000   000  000   000  0000000  \n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\nvec3 getNormal2(vec3 p)\n{\n    vec3 eps=vec3(0.001,0,0);\n    \n    return normalize(vec3(map(p+eps.xyz)-map(p-eps.xyz),\n                          map(p+eps.yxz)-map(p-eps.yxz),\n                          map(p+eps.yzx)-map(p-eps.yzx)));\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    gl.sdf.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    float shade = 1.;\n    float dist = MIN_DIST;    \n    vec3 rd = (lp-ro);\n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/25.0;\n    rd /= end;\n    for (int i=0; i<25; i++)\n    {\n        float h = map(ro+rd*dist);\n        shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n//  0000000    0000000   0000000  000      000   000   0000000  000   0000000   000   000  \n// 000   000  000       000       000      000   000  000       000  000   000  0000  000  \n// 000   000  000       000       000      000   000  0000000   000  000   000  000 0 000  \n// 000   000  000       000       000      000   000       000  000  000   000  000  0000  \n//  0000000    0000000   0000000  0000000   0000000   0000000   000   0000000   000   000  \n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n    if (!occl) return 1.0;\n    float a = 0.0;\n    float weight = 1.0;\n    for (int i = ZERO; i <= 6; i++)\n    {\n        float d = (float(i) / 6.0) * 0.3;\n        a += weight * (d - map(p + n*d));\n        weight *= 0.8;\n    }\n    float f = clamp01(1.0-a);\n    return f*f;\n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nvec3 getLight(vec3 p, vec3 n, int mat)\n{\n    vec3 col;\n    switch (mat)\n    {\n        case SKIN: col = vec3(0.4, 0.0, 0.0);  break;\n        case PUPL: col = vec3(0.1, 0.1, 0.5);  break;\n        case BULB: col = vec3(0.95);           break;\n        case NONE: col = BG_COLOR;             break;\n    }\n    \n    if (mat == NONE) \n    {\n        return col;\n    }\n    \n    vec3 l = normalize(gl.light-p);\n \n    float ambient = 0.05;\n    float dif = clamp(dot(n,l), 0.0, 1.0);\n    \n    if (mat == PUPL)\n    {\n        dif = clamp(dot(n,normalize(mix(camPos,gl.light,0.1)-p)), 0.0, 1.0);\n        dif = mix(pow(dif, 16.0), dif, 0.2);\n        dif += 1.0 - smoothstep(0.0, 0.2, dif);\n        if (mat == PUPL) ambient = 0.1;\n    }\n    else if (mat == BULB)\n    {\n        dif = mix(pow(dif, 32.0), 3.0*dif+1.0, 0.2);\n        ambient = 0.12;\n    }\n    else if (mat == SKIN)\n    {\n        dif = mix(pow(dif, 2.0), dif, 0.2);\n        \n        float df = smoothstep(3.0*CORE_RADIUS, CORE_RADIUS*1.5, length(p));\n        col = mix(col, vec3(0.8,0.4,0), df*(1.0-heartBeat));\n    }\n    \n    if (mat == SKIN || mat == BULB)\n    {\n        dif *= softShadow(p, gl.light, 6.0);        \n    }\n        \n    if (light) col = gray(col);\n    \n    col *= clamp(dif, ambient, 1.0);\n    col *= getOcclusion(p, n);\n    \n    if (mat == PUPL || mat == BULB)\n    {\n        col += vec3(pow(clamp01(smoothstep(0.9,1.0,dot(n, l))), 0.8));\n    }\n    else if (mat == SKIN)\n    {\n        col += col*vec3(pow(clamp01(smoothstep(0.25,1.0,dot(n, l))), 2.0));\n        col += 0.5*col*vec3(pow(clamp01(smoothstep(0.5,0.55,dot(n, l))), 11.8));\n        col += vec3(pow(clamp01(smoothstep(0.989,1.0,dot(n, l))), 0.5));\n    }\n    \n    if (light) col = clamp(col, 0.0, 1.0);\n    return col;\n}\n\n// 00     00   0000000   000  000   000\n// 000   000  000   000  000  0000  000\n// 000000000  000000000  000  000 0 000\n// 000 0 000  000   000  000  000  0000\n// 000   000  000   000  000  000   000\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initGlobal(fragCoord, iResolution, iMouse, iTime);\n    gl.zero = ZERO;\n    for (int i = KEY_1; i <= KEY_9; i++) { if (keyDown(i)) { gl.option = i-KEY_1+1; break; } }\n    \n    rotate =  keyState(KEY_R);\n    anim   =  keyState(KEY_RIGHT);\n    occl   =  keyState(KEY_UP);\n    dither =  keyState(KEY_D);\n    normal = !keyState(KEY_N);\n    depthb = !keyState(KEY_Z);\n    light  = !keyState(KEY_LEFT);\n    soft   = !keyState(KEY_DOWN);\n    \n    calcAnim();\n    \n    vec3 cols = v0, col = v0;\n    \n    if (!soft) AA = 1; \n    \n    vec2 ao = vec2(0);\n    \n    float md = CAM_DIST;\n    \n    float mx = -gl.mp.x*2.0;\n    float my = -gl.mp.y*2.0;\n    \n    if (rotate) \n    {\n        mx += 0.15*iTime;\n        my += 0.15*sin(iTime*0.6);\n    }\n        \n    camTgt = v0; \n    camPos = rotAxisAngle(rotAxisAngle(vec3(0,0,md), vx, 89.0*my), vy, -90.0*mx);\n    camDir = normalize(camTgt-camPos);\n        \n    vec3 cr = cross(camDir, vec3(0,1,0));\n    vec3 up = normalize(cross(cr,camDir));\n    gl.light = (-0.2*cr + 0.5*up -camDir)*md; \n    \n    vec3 uu = normalize(cross(camDir, vy));\n    vec3 vv = normalize(cross(uu, camDir));\n    \n    float fov = 4.0;\n    if (gl.option > 3) fov += float(gl.option);\n    \n    for (int am=ZERO; am<AA; am++)\n    for (int an=ZERO; an<AA; an++)\n    {\n        if (AA > 1) ao = vec2(float(am),float(an))/float(AA)-0.5;\n\n        gl.uv = (2.0*(fragCoord+ao)-iResolution.xy)/iResolution.y;\n    \n        if (length(gl.uv) < 1.0)\n        {\n            vec3 rd = normalize(gl.uv.x*uu + gl.uv.y*vv + fov*camDir);\n            float d = rayMarch(camPos, rd);\n            int mat = gl.sdf.mat;\n            float dst = d;\n            vec3  p = camPos + d * rd;\n            vec3  n = getNormal(p);\n            \n            if (normal || depthb)\n            {\n                vec3 nc = normal ? mat == NONE ? black : n : white;\n                vec3 zc = depthb ? vec3(1.0-clamp01(0.5+(dst-CAM_DIST)/6.0)) : white;\n                col = nc*zc;\n            }\n            else\n                col = getLight(p, n, mat);\n        }\n        else\n        {\n            col = BG_COLOR;\n        }\n        cols += col;\n    }\n    col = cols/float(AA*AA);\n    \n    #ifndef TOY\n    col += vec3(print(0, 0, vec4(iFrameRate, bgH, bgS, bgL)));\n    \n    // col += vec3(print(0, 3, iv26(vx)));\n    // col += vec3(print(0, 2, iv26(vy)));\n    // col += vec3(print(0, 1, iv26(vz)));\n    // col += vec3(print(0, 6, iv26(-vx-vy+vz)));\n    // col += vec3(print(0, 5, iv26(-vz-vx)));\n    // col += vec3(print(0, 4, iv26(-vy-vz)));\n    \n    // col += vec3(print(0, 8, id26(-vx+vy+vz)));\n    // col += vec3(print(0, 7, id26(-vx+vy-vz)));\n    // col += vec3(print(0, 6, id26(-vx-vy+vz)));\n    // col += vec3(print(0, 5, id26(-vx-vy-vz)));\n    // col += vec3(print(0, 4, id26(vx+vy+vz)));\n    // col += vec3(print(0, 3, id26(vx+vy-vz)));\n    // col += vec3(print(0, 2, id26(vx-vy+vz)));\n    // col += vec3(print(0, 1, id26(vx-vy-vz)));\n    \n    // col += vec3(print(0, 12, id26(-vy+vz)));\n    // col += vec3(print(0, 11, id26(-vy-vz)));\n    // col += vec3(print(0, 10, id26( vy+vz)));\n    // col += vec3(print(0,  9, id26( vy-vz)));\n    // col += vec3(print(0, 8, id26(-vx+vy)));\n    // col += vec3(print(0, 7, id26(-vx-vy)));\n    // col += vec3(print(0, 6, id26(-vx+vz)));\n    // col += vec3(print(0, 5, id26(-vx-vz)));\n    // col += vec3(print(0, 4, id26( vx+vy)));\n    // col += vec3(print(0, 3, id26( vx-vy)));\n    // col += vec3(print(0, 2, id26( vx+vz)));\n    // col += vec3(print(0, 1, id26( vx-vz)));\n    #endif\n    \n    if (dither)\n    {\n        float dit = gradientNoise(fragCoord.xy);\n        col -= vec3(dit/256.0);\n    }\n    \n    col  = pow(col, vec3(1.0/2.2));\n    \n    col *= vec3(smoothstep(1.8, 0.5, length(gl.uv)/max(gl.aspect,1.0)));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TOY\n#define PI  3.141592653589\n#define TAU 6.283185307178\n#define E   2.718281828459\n#define EPS 0.000000000001\n#define PHI 1.618033988750\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n#define KEY_SPACE 32\n#define KEY_1     49\n#define KEY_9     57\n#define KEY_A     65\n#define KEY_C     67\n#define KEY_D     68\n#define KEY_E     69\n#define KEY_N     78\n#define KEY_Q     81\n#define KEY_R     82\n#define KEY_S     83\n#define KEY_W     87\n#define KEY_X     88\n#define KEY_Z     90\n\nconst vec3 v0 = vec3(0,0,0);\nconst vec3 vx = vec3(1,0,0);\nconst vec3 vy = vec3(0,1,0);\nconst vec3 vz = vec3(0,0,1);\n\nconst vec3 red   = vec3(0.8,0.0,0.0);\nconst vec3 green = vec3(0.0,0.5,0.0);\nconst vec3 blue  = vec3(0.2,0.2,1.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\nconst vec3 black = vec3(0.0,0.0,0.0);\n    \n//  0000000   000       0000000   0000000     0000000   000      \n// 000        000      000   000  000   000  000   000  000      \n// 000  0000  000      000   000  0000000    000000000  000      \n// 000   000  000      000   000  000   000  000   000  000      \n//  0000000   0000000   0000000   0000000    000   000  0000000  \n\nstruct Text {\n    ivec2 size;\n    ivec2 adv;\n} text;\n\nstruct SDF {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nstruct _gl {\n    vec2  uv;\n    vec2  frag;\n    vec2  mouse;\n    vec2  mp;\n    ivec2 ifrag;\n    float aspect;\n    vec4  color;\n    int   option;\n    float time;\n    vec3  light;\n    int   zero;\n    SDF   sdf;\n} gl;\n\nuniform sampler2D fontChannel;\n\nvoid initGlobal(vec2 fragCoord, vec3 resolution, vec4 mouse, float time)\n{\n    text.size = ivec2(16,32)*2;\n    text.adv  = ivec2(text.size.x,0);\n    \n    mouse.xy = min(mouse.xy,resolution.xy);\n    if (mouse.z < 1.0)\n    {\n        if (mouse.z > -1.0)\n            gl.mouse = resolution.xy*0.5;\n        else\n            gl.mouse = mouse.xy;\n    }\n    else gl.mouse = mouse.xy;\n    \n    gl.mp = (2.0*abs(gl.mouse)-vec2(resolution.xy))/resolution.y;    \n\n    gl.aspect = resolution.x / resolution.y;\n    gl.frag   = fragCoord;\n    gl.ifrag  = ivec2(fragCoord);\n    gl.uv     = (fragCoord+fragCoord-resolution.xy)/resolution.y;\n}\n\nfloat powi(int a, int b) { return pow(float(a), float(b)); }\nfloat log10(float a) { return log(a)/log(10.0); }\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\n// 00000000   00000000   000  000   000  000000000  \n// 000   000  000   000  000  0000  000     000     \n// 00000000   0000000    000  000 0 000     000     \n// 000        000   000  000  000  0000     000     \n// 000        000   000  000  000   000     000     \n\n#ifndef TOY\nfloat print(ivec2 pos, int ch)\n{\n    ivec2 r = gl.ifrag-pos; bool i = r.y>0 && r.x>0 && r.x<=text.size.y && r.y<=text.size.y;\n    return i ? texelFetch(iChannel2,ivec2((ch%16)*64,(1024-64-64*(ch/16)))+r*64/text.size.y,0).r : 0.0;\n}\n\nfloat print(ivec2 pos, float v)\n{\n    float c = 0.0; ivec2 a = text.adv; \n    float fv = fract(v);\n    v = (fv > 0.995 || fv < 0.005) ? floor(v) : v;\n    float f = abs(v);\n    int i = (fv == 0.0) ? 1 : fract(v*10.0) == 0.0 ? -1 : -2;\n    int ch, u = max(1,int(log10(f))+1);\n    ivec2 p = pos+6*a;\n    for (; i <= u; i++) {\n        if (i == 0)     ch = 46;\n        else if (i > 0) ch = 48+int(mod(f, powi(10,i))/powi(10,i-1));\n        else            ch = 48+int(mod(f+0.005, powi(10,i+1))/powi(10,i));\n        c = max(c, print(p-i*a, ch)*float(i+3)/30.0); }\n    if (v < 0.0) c = max(c, print(p-i*a, 45)*float(i)/30.0);\n    return c;\n}\n\nfloat print(ivec2 pos, vec4 v)\n{\n    float c = 0.0;\n    for (int i = 0; i < 4; i++) {\n        c = max(c, print(pos, v[i]));\n        pos += text.adv*8; }\n    return c;\n}\n\nfloat print(ivec2 pos, vec3 v)\n{\n    float c = 0.0;\n    for (int i = 0; i < 3; i++) {\n        c = max(c, print(pos, v[i]));\n        pos += text.adv*8; }\n    return c;\n}\n\nfloat print(ivec2 pos, vec2 v)\n{\n    float c = 0.0;\n    for (int i = 0; i < 2; i++) {\n        c = max(c, print(pos, v[i]));\n        pos += text.adv*8; }\n    return c;\n}\n\nfloat print(int x, int y, int v)   { return print(ivec2(text.size.x*x,text.size.y*y), float(v)); }\nfloat print(int x, int y, float v) { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, vec4 v)  { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, vec3 v)  { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, vec2 v)  { return print(ivec2(text.size.x*x,text.size.y*y), v); }\nfloat print(int x, int y, ivec3 v) { return print(ivec2(text.size.x*x,text.size.y*y), vec3(v)); }\n#endif\n\n// 000   000   0000000    0000000  000   000  \n// 000   000  000   000  000       000   000  \n// 000000000  000000000  0000000   000000000  \n// 000   000  000   000       000  000   000  \n// 000   000  000   000  0000000   000   000  \n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(12.3,456.7,8912.3));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   return hash33(vec3(p));\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gradientNoise(vec2 v)\n{\n    return fract(52.9829189 * fract(dot(v, vec2(0.06711056, 0.00583715))));\n}\n\n// 000   000   0000000  000      \n// 000   000  000       000      \n// 000000000  0000000   000      \n// 000   000       000  000      \n// 000   000  0000000   0000000  \n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsl(float h, float s, float l) { return hsl2rgb(vec3(h,s,l)); }\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + EPS)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              \n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + EPS),  \n                 (minc+maxc)*0.5);\n}\n\nvec3 colsat(vec3 col, float sat)\n{\n    vec3 h = rgb2hsl(col);\n    return hsl(h.x,sat,h.z);\n}\n\nvec3 gray(vec3 col)\n{\n    return colsat(col, 0.0);\n}\n\n// 00     00   0000000   000000000  00000000   000  000   000  \n// 000   000  000   000     000     000   000  000   000 000   \n// 000000000  000000000     000     0000000    000    00000    \n// 000 0 000  000   000     000     000   000  000   000 000   \n// 000   000  000   000     000     000   000  000  000   000  \n\nmat3 alignMatrix(vec3 dir) \n{\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3 rad2deg(vec3 v) { return 180.0 * v / PI; }\nvec3 deg2rad(vec3 v) { return PI * v / 180.0; }\n\nmat3 rotMat(vec3 u, float angle)\n{\n    float s = sin(deg2rad(angle));\n    float c = cos(deg2rad(angle));\n    float i = 1.0-c;\n    \n    return mat3(\n        c+u.x*u.x*i, u.x*u.y*i-u.z*s, u.x*u.z*i+u.y*s,\n        u.y*u.x*i+u.z*s, c+u.y*u.y*i, u.y*u.z*i-u.x*s,\n        u.z*u.x*i-u.y*s, u.z*u.y*i+u.x*s, c+u.z*u.z*i\n        );\n}\n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{\n    mat3 m = rotMat(axis, angle);\n    return m * position;\n}\n\n// 00000000    0000000   000       0000000   00000000   \n// 000   000  000   000  000      000   000  000   000  \n// 00000000   000   000  000      000000000  0000000    \n// 000        000   000  000      000   000  000   000  \n// 000         0000000   0000000  000   000  000   000  \n\nvec3 polar(vec3 v)\n{\n    float radius = length(v);\n    float phi    = atan(v.y, v.x);\n    float rho    = acos(v.z/radius);\n    return vec3(phi, rho, radius);\n}\n\nvec3 unpolar(vec3 v)\n{\n    float s = sin(v.y);\n    float x = s * cos(v.x);\n    float y = s * sin(v.x);\n    float z =     cos(v.y);\n    return vec3(x, y, z)*v.z;\n}\n\nvec3 polar2(vec3 v)\n{\n    float radius = length(v);\n    float phi    = atan(v.z, v.x);\n    float rho    = acos(v.y/radius);\n    return vec3(phi, rho, radius);\n}\n\nvec3 unpolar2(vec3 v)\n{\n    float s = sin(v.y);\n    float x = s * cos(v.x);\n    float z = s * sin(v.x);\n    float y =     cos(v.y);\n    return vec3(x, y, z)*v.z;\n}\n\n//  0000000   000   000   0000000   000000000  \n// 000   000  000   000  000   000     000     \n// 000 00 00  000   000  000000000     000     \n// 000 0000   000   000  000   000     000     \n//  00000 00   0000000   000   000     000     \n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    float half_angle = deg2rad(angle*0.5);\n    return vec4(axis*sin(half_angle), cos(half_angle));\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotAxisAngleQuat(vec3 p, vec3 axis, float angle)\n{ \n    vec4 qr = quatAxisAngle(axis, angle);\n    return quatMul(quatMul(qr, vec4(p, 0)), quatConj(qr)).xyz;\n}\n\nvec3 rotRayAngle(vec3 p, vec3 ro, vec3 rd, float angle)\n{ \n    return rotAxisAngle(p-ro, rd-ro, angle)+ro;\n}\n\nvec3 rotY(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x*c+v.z*s, v.y, v.z*c+v.x*s);\n}\n\nvec3 rotX(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x, v.y*c+v.z*s, v.z*c+v.y*s);\n}\n\nvec3 rotZ(vec3 v, float d)\n{\n    float r = deg2rad(d);\n    float c = cos(r);\n    float s = sin(r);\n    return vec3(v.x*c+v.y*s, v.y*c+v.x*s, v.z);\n}\n\n//  0000000   00000000   0000000   00     00    \n// 000        000       000   000  000   000    \n// 000  0000  0000000   000   000  000000000    \n// 000   000  000       000   000  000 0 000    \n//  0000000   00000000   0000000   000   000    \n\nvec3 posOnPlane(vec3 p, vec3 a, vec3 n)\n{\n    return p-dot(p-a,n)*n;\n}\n\nvec3 posOnRay(vec3 ro, vec3 rd, vec3 p)\n{\n    return ro + max(0.0, dot(p - ro, rd) / dot(rd, rd)) * rd;\n}\n\nbool rayIntersectsSphere(vec3 ro, vec3 rd, vec3 ctr, float r)\n{\n    return length(posOnRay(ro, rd, ctr) - ctr) < r;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2, float k) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) - k*h*(1.0-h);\n}\n\nfloat opInter(float d1, float d2, float k) \n{\n    \n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\nfloat opDiff (float d1, float d2) { return opDiff (d1, d2, 0.0); }\nfloat opUnion(float d1, float d2) { return opUnion(d1, d2, 0.5); }\nfloat opInter(float d1, float d2) { return opInter(d1, d2, 0.2); }\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\n\nfloat sdSphere(vec3 a, float r)\n{\n    return length(gl.sdf.pos-a)-r;\n}\n\nfloat sdPill(vec3 a, float r, vec3 n)\n{\n    vec3 p = gl.sdf.pos-a;\n    float d = abs(dot(normalize(n),normalize(p)));\n    float f = smoothstep(0.0, 1.3, d);\n    return length(p) - r + f * length(n);\n}\n\nfloat sdPlane(vec3 a, vec3 n)\n{   \n    return dot(n, gl.sdf.pos-a);\n}\n\nfloat sdPlane(vec3 n)\n{   \n    return dot(n, gl.sdf.pos);\n}\n\nfloat sdEllipsoid(vec3 a, vec3 r)\n{\n    vec3 p = gl.sdf.pos-a;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCone(vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a;\n    vec3 ap = gl.sdf.pos-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(gl.sdf.pos-c)-(t*r2+(1.0-t)*r1);      \n}\n\n\nfloat sdCapsule(vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = gl.sdf.pos-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(gl.sdf.pos-c)-r;        \n}\n\nfloat sdCylinder(vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = gl.sdf.pos - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, float rl, float rs)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-rl,abs(dot(n, q))))-rs;\n}\n\n// 0000000     0000000    0000000  000   0000000  \n// 000   000  000   000  000       000  000       \n// 0000000    000000000  0000000   000  0000000   \n// 000   000  000   000       000  000       000  \n// 0000000    000   000  0000000   000  0000000   \n\nvoid basis(vec3 n, out vec3 right, out vec3 front) \n{\n    if (n.y < -0.999999)\n    {\n        right = -vz;\n        front = -vx;\n    } \n    else \n    {\n        float a = 1.0/(1.0+n.y);\n        float b = -n.x*n.z*a;\n        right = vec3(1.0-n.x*n.x*a,-n.x,b);\n        front = vec3(b,-n.z,1.0-n.z*n.z*a);\n    }\n}\n// 00     00   0000000   00000000     \n// 000   000  000   000  000   000    \n// 000000000  000000000  00000000     \n// 000 0 000  000   000  000          \n// 000   000  000   000  000          \n\nconst vec3 cubo[32] = vec3[32](\n    normalize(vec3( 0, 0, 1)),\n    normalize(vec3( 0, 0,-1)),\n    normalize(vec3( 0, 1, 0)),\n    normalize(vec3( 0,-1, 0)),\n    normalize(vec3( 1, 0, 0)),\n\n    normalize(vec3(-1, 0, 0)),\n    normalize(vec3( 1, 1, 0)),\n    normalize(vec3( 1,-1, 0)),\n    normalize(vec3(-1, 1, 0)),\n    normalize(vec3(-1,-1, 0)),\n    normalize(vec3( 1, 0, 1)),\n    normalize(vec3( 1, 0,-1)),\n    normalize(vec3(-1, 0, 1)),\n    normalize(vec3(-1, 0,-1)),\n    normalize(vec3( 0, 1, 1)),\n    normalize(vec3( 0, 1,-1)),\n    normalize(vec3( 0,-1, 1)),\n    normalize(vec3( 0,-1,-1)),\n    \n    normalize(vec3( 1, 1, 1)),\n    normalize(vec3( 1, 1,-1)),\n    normalize(vec3( 1,-1, 1)),\n    normalize(vec3(-1, 1, 1)),\n    normalize(vec3( 1,-1,-1)),\n    normalize(vec3(-1, 1,-1)),\n    normalize(vec3(-1,-1, 1)),\n    normalize(vec3(-1,-1,-1)),\n    v0, v0, v0, v0, v0, v0\n);\n\nconst vec3 dodeca[32] = vec3[32](\n    normalize(vec3(0, 1, PHI)),\n    normalize(vec3(0,-1, PHI)),\n    normalize(vec3(0,-1,-PHI)),\n    normalize(vec3(0, 1,-PHI)),\n    normalize(vec3( 1, PHI,0)),\n    normalize(vec3(-1, PHI,0)),\n    normalize(vec3(-1,-PHI,0)),\n    normalize(vec3( 1,-PHI,0)),\n    normalize(vec3( PHI, 0,  1)),\n    normalize(vec3( PHI, 0, -1)),\n    normalize(vec3(-PHI, 0, -1)),\n    normalize(vec3(-PHI, 0,  1)),\n    v0, v0, v0, v0, v0, v0, v0,\n    v0, v0, v0, v0, v0, v0, v0,\n    v0, v0, v0, v0, v0, v0\n);\n\nconst vec3 icosa[32] = vec3[32](\n    normalize(vec3( 1, 1,-1)),\n    normalize(vec3( 1, 1, 1)),\n    normalize(vec3( 1,-1,-1)),\n    normalize(vec3( 1,-1, 1)),\n    normalize(vec3(-1, 1,-1)),\n    normalize(vec3(-1, 1, 1)),\n    normalize(vec3(-1,-1,-1)),\n    normalize(vec3(-1,-1, 1)),\n    normalize(vec3(0, PHI,  1.0/PHI)),\n    normalize(vec3(0, PHI, -1.0/PHI)),\n    normalize(vec3(0,-PHI, -1.0/PHI)),\n    normalize(vec3(0,-PHI,  1.0/PHI)),\n    normalize(vec3( PHI,  1.0/PHI, 0)),\n    normalize(vec3( PHI, -1.0/PHI, 0)),\n    normalize(vec3(-PHI, -1.0/PHI, 0)),\n    normalize(vec3(-PHI,  1.0/PHI, 0)),\n    normalize(vec3( 1.0/PHI, 0, PHI)),\n    normalize(vec3(-1.0/PHI, 0, PHI)),\n    normalize(vec3(-1.0/PHI, 0,-PHI)),\n    normalize(vec3( 1.0/PHI, 0,-PHI)),\n    v0, v0, v0, v0, v0, v0,\n    v0, v0, v0, v0, v0, v0\n);\n\nconst vec3 dodecaicosa[32] = vec3[32](\n    normalize(vec3(0, 1, PHI)),\n    normalize(vec3(0,-1, PHI)),\n    normalize(vec3(0,-1,-PHI)),\n    normalize(vec3(0, 1,-PHI)),\n    normalize(vec3( 1, PHI,0)),\n    normalize(vec3(-1, PHI,0)),\n    normalize(vec3(-1,-PHI,0)),\n    normalize(vec3( 1,-PHI,0)),\n    normalize(vec3( PHI, 0,  1)),\n    normalize(vec3( PHI, 0, -1)),\n    normalize(vec3(-PHI, 0, -1)),\n    normalize(vec3(-PHI, 0,  1)),\n    normalize(vec3( 1, 1,-1)),\n    normalize(vec3( 1, 1, 1)),\n    normalize(vec3( 1,-1,-1)),\n    normalize(vec3( 1,-1, 1)),\n    normalize(vec3(-1, 1,-1)),\n    normalize(vec3(-1, 1, 1)),\n    normalize(vec3(-1,-1,-1)),\n    normalize(vec3(-1,-1, 1)),\n    normalize(vec3(0, PHI,  1.0/PHI)),\n    normalize(vec3(0, PHI, -1.0/PHI)),\n    normalize(vec3(0,-PHI, -1.0/PHI)),\n    normalize(vec3(0,-PHI,  1.0/PHI)),\n    normalize(vec3( PHI,  1.0/PHI, 0)),\n    normalize(vec3( PHI, -1.0/PHI, 0)),\n    normalize(vec3(-PHI, -1.0/PHI, 0)),\n    normalize(vec3(-PHI,  1.0/PHI, 0)),\n    normalize(vec3( 1.0/PHI, 0, PHI)),\n    normalize(vec3(-1.0/PHI, 0, PHI)),\n    normalize(vec3(-1.0/PHI, 0,-PHI)),\n    normalize(vec3( 1.0/PHI, 0,-PHI))\n);\n\nconst vec3 weirdo[32] = vec3[32](\n    normalize(vec3( 0,  1, 0)),\n    normalize(vec3( 1, -1, 0.5)),\n    normalize(vec3(-1, -1, 0.5)),\n    normalize(vec3( 0, -1, -1)),\n    normalize(vec3( 0, -0.9, 1)),\n    normalize(vec3( 1, -0.9, -0.5)),\n    normalize(vec3(-1, -0.9, -0.5)),\n    normalize(vec3(-0.4, 0.5, 1)),\n    normalize(vec3( 0.4, 0.5, 1)),\n    normalize(vec3( 0,  0.2, -1)),\n    normalize(vec3( 0.5,  0.5, -0.7)),\n    normalize(vec3(-0.5,  0.5, -0.7)),\n    v0, v0, v0, v0, v0, v0, v0,\n    v0, v0, v0, v0, v0, v0, v0,\n    v0, v0, v0, v0, v0, v0\n);\n\nstruct VecMap {\n    vec3[32] vecs;\n    int num;\n};\n\nVecMap[5] vecMap = VecMap[5](\n    VecMap(cubo,   26),\n    VecMap(dodeca, 12),\n    VecMap(icosa,  20),\n    VecMap(weirdo, 12),\n    VecMap(dodecaicosa, 32)\n);\n\nvec4 choose(vec3 p, int mapIndex)\n{\n    float d = 0.0;\n    int id = -1;\n    vec3 n = normalize(p);\n    for (int i = gl.zero; i < vecMap[mapIndex].num; i++)\n    {\n        float dt = dot(n,vecMap[mapIndex].vecs[i]);\n        if (dt > d)\n        {\n            d = dt;\n            id = i;\n        }\n    }\n    return vec4(vecMap[mapIndex].vecs[id], float(id));\n}\n\nvec4 chooseMap(vec3 p, int mapIndex)\n{\n    vec4 m = choose(p, mapIndex);\n    vec3 q = p-m.xyz;\n    vec3 r, f;\n    basis(m.xyz,r,f);\n    return vec4(dot(r,q),dot(m.xyz,q),dot(f,q), m.w);\n}\n\n// 00000000  000  0000000    \n// 000       000  000   000  \n// 000000    000  0000000    \n// 000       000  000   000  \n// 000       000  0000000    \n\nvec4 sphericalFibonacci(vec3 p, float num)\n{\n    float m   = 1.0-1.0/num;\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(2.0, floor(log(num*PI*sqrt(5.0)*(1.0-p.z*p.z))/log(PHI+1.0)));\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk), round(Fk*PHI));\n    vec2  ka  = 2.0*F/num;\n    vec2  kb  = 2.0*PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    mat2  iB  = mat2(ka.y,-ka.x, kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2  c   = floor(iB*vec2(phi, p.z-m));\n    float d   = 0.0;\n    vec4  res = vec4(0);\n    \n    for (int s=0; s<4; s++)\n    {\n        vec2  uv  = vec2(s&1,s>>1);\n        float i   = dot(F,uv+c); \n        float phi = 2.0*PI*fract(i*PHI);\n        float cot = m-2.0*i/num; \n        float sit = sqrt(1.0-cot*cot); \n        vec3  q   = vec3(cos(phi)*sit, sin(phi)*sit, cot);\n        float d1  = dot(p,q);\n        if (d1 > d)\n        {\n            d   = d1;\n            res = vec4(q,i);\n        }\n    }\n    return res;\n}\n\nvec4 mapFib(vec3 p, int num)\n{\n    vec4 fib = sphericalFibonacci(normalize(p),float(num));\n    vec3 q = p-fib.xyz;\n    vec3 n = normalize(fib.xyz);\n    vec3 r,f;\n    basis(n,r,f);\n    return vec4(dot(r,q),dot(n,q),dot(f,q), fib.w);\n}\n","name":"Common","description":"","type":"common"}]}