{"ver":"0.1","info":{"id":"mssXD8","date":"1668831101","viewed":128,"name":"oklab->sRGB gamut in 3D","username":"jmuhlich","description":"Keyboard/mouse controls listed in Buffer A. \n\nCredits\nRendering code: iq\noklab conversions: hatchling\n","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","interactive","color","space","plotter","arithmetic","interval"],"hasliked":0,"parentid":"7tKfz1","parentname":"Implicit Surface Renderer"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO:\n// * Change initial camera position for better framing\n// * Improve performance\n\n//-------------------------Implicit Surface Renderer--------------------------//\n\n// How It Works:\n// This shader raytraces implicit surfaces by recursively subdividing the ray,\n// calculating bounding boxes for sections of the ray and using interval\n// arithmetic to test for the possible presence of solutions to f(x,y,z)=0\n// within the bounding boxes.\n\n// Implicit Surface Equation:\n// This function uses interval types (defined in the Common tab).\niFloat f(iFloat x, iFloat y, iFloat z) {\n    //// oklab gamut\n    iVec3 c = Srgb3(oklab_to_rgb(y, x, z));\n    iVec3 d = iSub(c, iClamp(c, ifloat(0.0), ifloat(1.0)));\n    iFloat ll = iAdd(iAdd(iMul(d.x, d.x), iMul(d.y, d.y)), iMul(d.z, d.z));\n    return ll;\n}\n\n// Ray Domain:\nconst float tMin = 0.001;\nconst float tMax = 100.0;\n\n// Precision:\n// The amount of times to recursively subdivide the ray. \nconst int maxDepth = 24;\n\n// Discontinuity Tolerance:\n// If the interval returned by the implicit function over a section of the ray\n// has a width bigger than or equal to discontinuityTolerance, that section is\n// counted as containing a discontinuity and is not counted as an intersection.\n// It can be set to INFINITY if the surface is known to be continous.\n//const float discontinuityTolerance = 1000.0 * (tMax - tMin) / pow(2.0, float(maxDepth - 1));\nconst float discontinuityTolerance = INFINITY;\n\n// Display Settings:\nconst float fovY = 50.0;\n\n//============================================================================//\n\n\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct iRet {\n    float t;\n    vec3 p;\n};\n\n// Main Intersection Function:\n// Performs a depth-first search of the ray's t domain, descending if the\n// current segment possibly contains an intersection. Once the max depth is\n// reached, if there's still an intersection in the segment and it is also \n// considered continous, then it is counted as an intersection and returned.\niRet intersect(Ray r) {\n    if (maxDepth < 1) {\n        return iRet(-1.0, vec3(0, 0, 0));\n    }\n    \n    float tRange = tMax - tMin;\n    int depth = 0;\n    int pos = 0;\n\n    while (true) {\n        // Calculate the current t domain at this location in the tree\n        float size = float(1 << depth);\n        iFloat ti = iFloat(\n            tMin + tRange * float(pos) / size,\n            tMin + tRange * float(pos + 1) / size\n        );\n        // Find the bounding box of the ray segment and use it to calculate an\n        // interval of possible values for f\n        iFloat px = iAdd(r.o.x, iMul(r.d.x, ti));\n        iFloat py = iAdd(r.o.y, iMul(r.d.y, ti));\n        iFloat pz = iAdd(r.o.z, iMul(r.d.z, ti));\n        iFloat fi = f(px, py, pz);\n        \n        if (fi.u < 0.0 || 0.0 <= fi.l || depth == maxDepth - 1) {\n            if (fi.l <= 0.0 && 0.0 <= fi.u && fi.u - fi.l < discontinuityTolerance) {\n                // We are at a leaf of the tree and there appears to be an\n                // intersection, so return it\n                return iRet(\n                    (ti.l + ti.u) / 2.0,\n                    vec3((px.l + px.u) / 2.0, (py.l + py.u) / 2.0, (pz.l + pz.u) / 2.0)  \n                );\n            }\n\n            // The segment of the ray this node of the tree represents\n            // definitely does not contain any intersections, so don't descend\n            // into its children and instead move onto the next node in the DFS\n            while (pos % 2 == 1) {\n                --depth;\n                pos /= 2;\n            }\n            \n            ++pos;\n            \n            if (depth == 0 && pos == 1) {\n                // We are back at the root of the tree after having searched the\n                // entire tree, so break out of the loop\n                break;\n            }\n\n            continue;\n        }\n        \n        // Descend the tree to look for possible intersections\n        ++depth;\n        pos *= 2;\n    }\n    \n    // There were no intersections\n    return iRet(-1.0, vec3(0, 0, 0));\n}\n\nvec3 normal(vec3 p) {\n    const float e = 1e-3;\n    return normalize(vec3(\n        f(ifloat(p.x + e), ifloat(p.y), ifloat(p.z)).l - f(ifloat(p.x - e), ifloat(p.y), ifloat(p.z)).l,\n        f(ifloat(p.x), ifloat(p.y + e), ifloat(p.z)).l - f(ifloat(p.x), ifloat(p.y - e), ifloat(p.z)).l,\n        f(ifloat(p.x), ifloat(p.y), ifloat(p.z + e)).l - f(ifloat(p.x), ifloat(p.y), ifloat(p.z - e)).l\n    ));\n}\n\nvec3 normal(vec3 rd, vec3 p) {\n    vec3 n = normal(p);\n    return faceforward(n, rd, n);\n    return n;\n}\n\nvec3 calculateColor(Ray r) {\n    iRet i = intersect(r);\n    \n    if (i.t > 0.0) {\n        return Srgb3(oklab_to_rgb(i.p.yxz));\n    } else {\n        return vec3(0.2);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate camera configuration from keyboard & mouse input buffer\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 1.0) * camPosD.w; \n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n    vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n    vec3 wDir = v2wRotMat * vDir;\n    Ray r = Ray(camPos, wDir);\n    \n    // Calculate color\n    fragColor = vec4(calculateColor(r), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//------------\n// Credit: iq\n\n//------------------------Interval Arithmetic Library-------------------------//\n\n// Interval Types:\n// These types keep track of a lower and upper bound throughout computation, \n// giving definitive bounds for the end result.\n\nstruct iFloat {\n    float l;\n    float u;\n};\n\nstruct iVec3 {\n    iFloat x;\n    iFloat y;\n    iFloat z;\n};\n\nstruct iBool {\n    bool l;\n    bool u;\n};\n\n// Functions: \n// Most of these functions have the same domains as the native GLSL equivalents. \n// If the arguments are outside of the domain, an empty set is returned. To be \n// correct, these should be propagated like NaNs, however, it slows down the\n// shader a lot and isn't necessary most of the time so propagation is optional.\n// These functions are overloaded so they can be called without having to\n// convert floats to iFloats or bools to iBools when mixing them with non-\n// interval types.\n\n#define PROPAGATE_EMPTY_SETS 0\n\niFloat iAdd(iFloat x, iFloat y);\niFloat iSub(iFloat x, iFloat y);\niFloat iMul(iFloat x, iFloat y);\niFloat iDiv(iFloat x, iFloat y);\n\niFloat iNeg(iFloat x); // -x\niFloat iInv(iFloat x); // 1 / x\n\niFloat iSin(iFloat x);\niFloat iCos(iFloat x);\niFloat iTan(iFloat x);\n\niFloat iAsin(iFloat x);\niFloat iAcos(iFloat x);\niFloat iAtan(iFloat x);\niFloat iAtan(iFloat y, iFloat x); // never undefined\n\niFloat iSinh(iFloat x);\niFloat iCosh(iFloat x);\niFloat iTanh(iFloat x);\n\niFloat iAsinh(iFloat x);\niFloat iAcosh(iFloat x);\niFloat iAtanh(iFloat x);\n\niFloat iExp(iFloat x);\niFloat iExp2(iFloat x);\n\niFloat iLog(iFloat x);\niFloat iLog2(iFloat x);\n                                                                                \niFloat iPow(iFloat x, iFloat y); // defined for x >= 0.0 or when y is an integer\n\niFloat iSqrt(iFloat x);\niFloat iCbrt(iFloat x);\niFloat iSquare(iFloat x);\n\niFloat iSign(iFloat x);\niFloat iAbs(iFloat x);\niFloat iFloor(iFloat x);\niFloat iCeil(iFloat x);\niFloat iRound(iFloat x);\niFloat iTrunc(iFloat x);\niFloat iMod(iFloat x, iFloat y);\niFloat iFract(iFloat x);\n\niFloat iMin(iFloat x, iFloat y);\niFloat iMax(iFloat x, iFloat y);\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal);\n\niFloat iMix(iFloat x, iFloat y, iFloat a);\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x);\niFloat iStep(iFloat edge, iFloat x);\n\niFloat iIf(iBool P, iFloat x, iFloat y); // use this as the ternary operator\n\niBool iEqual(iFloat x, iFloat y);\niBool iGreaterThan(iFloat x, iFloat y);\niBool iGreaterThanEqual(iFloat x, iFloat y);\niBool iLessThan(iFloat x, iFloat y);\niBool iLessThanEqual(iFloat x, iFloat y);\n\niBool iNOT(iBool x);\niBool iAND(iBool x, iBool y);\niBool iOR(iBool x, iBool y);\niBool iXOR(iBool x, iBool y);\n\n// Constructors:\n// Aren't necessary most of the time since the functions are already overloaded.\niFloat ifloat(float x);\niBool ibool(bool x);\n\n// Constants:\nconst float INFINITY = uintBitsToFloat(0x7F800000u);\nconst float PI = 3.14159265;\n\n\n\n//============================================================================//\n\n\n\n// Overloads:\n#define MAKE_OVERLOADSB(fn) iBool fn(bool x,iBool y){return fn(ibool(x),y);}iBool fn(iBool x,bool y){return fn(x,ibool(y));}\n#define MAKE_OVERLOADSBF(fn) iBool fn(float x,iFloat y){return fn(ifloat(x),y);}iBool fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS2(fn) iFloat fn(float x,iFloat y){return fn(ifloat(x),y);}iFloat fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS3(fn) iFloat fn(float x,iFloat y,iFloat z){return fn(ifloat(x),y,z);}iFloat fn(iFloat x,float y,iFloat z){return fn(x,ifloat(y),z);}iFloat fn(iFloat x,iFloat y,float z){return fn(x,y,ifloat(z));}iFloat fn(float x,float y,iFloat z){return fn(ifloat(x),ifloat(y),z);}iFloat fn(float x,iFloat y,float z){return fn(ifloat(x),y,ifloat(z));}iFloat fn(iFloat x,float y,float z){return fn(x,ifloat(y),ifloat(z));}\n\nMAKE_OVERLOADS2(iAdd)\nMAKE_OVERLOADS2(iSub)\nMAKE_OVERLOADS2(iMul)\nMAKE_OVERLOADS2(iDiv)\nMAKE_OVERLOADS2(iPow)\n\nMAKE_OVERLOADS2(iMod)\n\nMAKE_OVERLOADS2(iMin)\nMAKE_OVERLOADS2(iMax)\nMAKE_OVERLOADS3(iClamp)\n\nMAKE_OVERLOADS3(iMix)\nMAKE_OVERLOADS3(iSmoothstep)\nMAKE_OVERLOADS2(iStep)\n\nMAKE_OVERLOADSBF(iEqual)\nMAKE_OVERLOADSBF(iGreaterThan)\nMAKE_OVERLOADSBF(iGreaterThanEqual)\nMAKE_OVERLOADSBF(iLessThan)\nMAKE_OVERLOADSBF(iLessThanEqual)\n\nMAKE_OVERLOADSB(iAND)\nMAKE_OVERLOADSB(iOR)\nMAKE_OVERLOADSB(iXOR)\n\n// Empty Sets:\nconst iFloat EMPTY_SET = iFloat(-INFINITY, -INFINITY);\nconst iBool EMPTY_BSET = iBool(true, false);\n\n#if PROPAGATE_EMPTY_SETS\n    #define CHECK_IF_EMPTY_SET_F(x) if ((x) == EMPTY_SET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_SET_B(x) if ((x) == EMPTY_SET) return EMPTY_BSET\n    #define CHECK_IF_EMPTY_BSET_F(x) if ((x) == EMPTY_BSET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_BSET_B(x) if ((x) == EMPTY_BSET) return EMPTY_BSET\n#else\n    #define CHECK_IF_EMPTY_SET_F(x)\n    #define CHECK_IF_EMPTY_SET_B(x)\n    #define CHECK_IF_EMPTY_BSET_F(x)\n    #define CHECK_IF_EMPTY_BSET_B(x)\n#endif\n\n// Constructors:\niFloat ifloat(float x) {\n    return iFloat(x, x);\n}\n\n\niBool ibool(bool x) {\n    return iBool(x, x);\n}\n\n// Helper Functions:\niFloat iMinMax(float x, float y, float z, float w) {\n    return iFloat(\n        min(x, min(y, min(z, w))),\n        max(x, max(y, max(z, w)))\n    );\n}\n\niBool iMinMax(bool x, bool y, bool z, bool w) {\n    return iBool(\n        x || y || z || w,\n        x && y && z && w\n    );\n}\n\n\n// Function Implementations:\n\niFloat iAdd(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l + y.l, x.u + y.u);\n}\n\niFloat iSub(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l - y.u, x.u - y.l);\n}\n\niFloat iMul(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iMinMax(x.l * y.l, x.l * y.u, x.u * y.l, x.u * y.u);\n}\n\niFloat iDiv(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iMul(x, iInv(y));\n}\n\n\niFloat iNeg(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(-x.u, -x.l);\n}\n\niFloat iInv(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x); \n    \n    if (x.l > 0.0 || x.u < 0.0) {\n        return iFloat(1.0 / x.u, 1.0 / x.l);\n    } else if (x.l < 0.0 && x.u > 0.0) {\n        return iFloat(-INFINITY, INFINITY);\n    } else if (x.u == 0.0) {\n        return iFloat(-INFINITY, 1.0 / x.l);\n    } else {\n        return iFloat(1.0 / x.u, INFINITY);\n    }\n}\n\n\niFloat iSin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    float u = PI * round(x.l / PI) + PI * 1.5;\n    \n    if (u < x.u) {\n        return iFloat(-1.0, 1.0);\n    }\n    \n    u -= PI;\n    vec2 s = vec2(sin(x.l), sin(x.u));\n    vec2 r = vec2(min(s.x, s.y), max(s.x, s.y));\n    \n    if (u < x.u) {\n        float s = sin(u);\n        return iFloat(min(r.x, s), max(r.y, s));\n    }\n    \n    return iFloat(r.x, r.y);\n}\n\niFloat iCos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSin(iAdd(x, ifloat(PI / 2.0)));\n}\n\niFloat iTan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iDiv(iSin(x), iCos(x));\n}\n\n\niFloat iAsin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-PI / 2.0, asin(x.u));\n        }\n        \n        return iFloat(-PI / 2.0, PI / 2.0);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(asin(x.l), asin(x.u));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(asin(x.l), PI / 2.0);\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(PI / 2.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAcos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(acos(x.u), PI);\n        }\n        \n        return iFloat(0.0, PI);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(acos(x.u), acos(x.l));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(0.0, acos(x.l));\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAtan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(atan(x.l), atan(x.u));\n}\n\niFloat iAtan(iFloat y, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.l, x.u));\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        return iFloat(atan(y.u, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.u == 0.0) {\n        if (x.l < 0.0) {\n            if (y.u < 0.0) {\n                return iFloat(atan(y.u, x.l), -PI / 2.0);\n            }\n            \n            if (y.l < 0.0) {\n                return iFloat(-PI, PI);\n            }\n            \n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return (iFloat(PI / 2.0, atan(y.l, x.l)));\n        }\n        \n        if (y.u < 0.0) {\n            return ifloat(-PI / 2.0);\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l < 0.0) {\n                return iFloat(-PI / 2.0, 0.0);\n            }\n            \n            return ifloat(0.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return ifloat(PI / 2.0);\n    }\n    \n    if (x.l < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.u, x.u));\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI);\n        }\n        \n        return iFloat(atan(y.l, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            return iFloat(atan(y.u, x.u), -PI / 2.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return iFloat(atan(y.l, x.u), PI / 2.0);\n    }\n    \n    return iAtan(iDiv(y, x));\n}\n\n\niFloat iSinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sinh(x.l), sinh(x.u));\n}\n\niFloat iCosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= 0.0) {\n        return iFloat(cosh(x.u), cosh(x.l));\n    }\n    \n    if (x.l <= 0.0 && 0.0 < x.u) {\n        return iFloat(1.0, cosh(max(-x.l, x.u)));\n    }\n    \n    return iFloat(cosh(x.l), cosh(x.u));\n}\n\niFloat iTanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(tanh(x.l), tanh(x.u));\n}\n\n\niFloat iAsinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(asinh(x.l), asinh(x.u));\n}\n\niFloat iAcosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    if (x.l <= 1.0) {\n        return iFloat(0.0, acosh(x.u));\n    }\n    \n    return iFloat(acosh(x.l), acosh(x.u));\n}\n\niFloat iAtanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-INFINITY, atanh(x.u));\n        }\n        \n        return iFloat(-INFINITY, INFINITY);\n    }\n    \n    if (x.l < 1.0) {\n        if (x.u < 1.0) {\n            return iFloat(atanh(x.l), atanh(x.u));\n        }\n        \n        return iFloat(atanh(x.l), INFINITY);\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iExp(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp(x.l), exp(x.u));\n}\n\niFloat iExp2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp2(x.l), exp2(x.u));\n}\n\n\niFloat iLog(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log(x.l), log(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iLog2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log2(x.l), log2(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log2(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iPow(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    \n    if (x.l < 0.0 && y.l == y.u && fract(y.l) == 0.0) {\n        float y = y.l;\n        \n        if (y == 0.0) {\n            return ifloat(1.0);\n        }\n\n        if (y > 0.0) {\n            if (mod(y, 2.0) == 1.0) {\n                return iFloat(-pow(-x.l, y), pow(abs(x.u), y) * sign(x.u));\n            }\n\n            if (x.u > 0.0) {\n                return iFloat(0.0, pow(max(-x.l, x.u), y));\n            }        \n\n            return iFloat(pow(-x.u, y), pow(-x.l, y));;\n        }\n\n        if (mod(y, 2.0) == 1.0) {\n            if (x.u > 0.0) {\n                return iFloat(-INFINITY, INFINITY);\n            }\n\n            if (x.u == 0.0) {\n                return iFloat(-INFINITY, -pow(-x.l, y));\n            }\n\n            return iFloat(-pow(-x.u, y), -pow(-x.l, y));\n        }\n\n        if (x.u > 0.0) {\n            return iFloat(min(pow(-x.l, y), pow(x.u, y)), INFINITY);\n        }\n\n        if (x.u == 0.0) {\n            return iFloat(pow(-x.l, y), INFINITY);\n        }\n\n        return iFloat(pow(-x.l, y), pow(-x.u, y));\n    }\n    \n    if (x.u < 0.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 0.0) {\n        if (y.l == 0.0 && y.u == 0.0) {\n            return EMPTY_SET;\n        }\n        \n        return ifloat(0.0);\n    }\n    \n    x.l = max(x.l, 0.0);\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            if (y.l == 0.0) {\n                return ifloat(1.0);\n            }\n            \n            if (x.u < 1.0) {\n                return iFloat(pow(x.u, y.u), INFINITY);\n            }\n            \n            return iFloat(pow(x.u, y.l), INFINITY);\n        }else\n        \n        if (y.l < 0.0) {\n            return iFloat(0.0, INFINITY);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, max(1.0, pow(x.u, y.u)));\n        }\n    }\n    \n    return iMinMax(pow(x.l, y.l), pow(x.l, y.u), pow(x.u, y.l), pow(x.u, y.u));\n}\n\n\niFloat iSqrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(sqrt(x.l), sqrt(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(0.0, sqrt(x.u));\n    }\n    \n    if (x.u == 0.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iCbrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(pow(abs(x.l), 1.0 / 3.0) * sign(x.l), pow(abs(x.u), 1.0 / 3.0) * sign(x.u));\n}\n\niFloat iSquare(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l <= 0.0 && 0.0 <= x.u) {\n        float t = max(-x.l, x.u);\n        return iFloat(0.0, t * t);\n    }\n    \n    if (x.u <= 0.0) {\n        return iFloat(x.u * x.u, x.l * x.l);\n    }\n    \n    return iFloat(x.l * x.l, x.u * x.u);\n}\n\n\niFloat iSign(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sign(x.l), sign(x.u));\n}\n\niFloat iAbs(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l >= 0.0) {\n        return x;\n    }\n    \n    if (x.u <= 0.0) {\n        return iNeg(x);\n    }\n    \n    return iFloat(0.0, max(-x.l, x.u));\n}\n\niFloat iFloor(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(floor(x.l), floor(x.u));\n}\n\niFloat iCeil(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(ceil(x.l), ceil(x.u));\n}\n\niFloat iRound(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(round(x.l), round(x.u));\n}\n\niFloat iTrunc(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(trunc(x.l), trunc(x.u));\n}\n\niFloat iMod(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iSub(x, iMul(y, iFloor(iDiv(x, y))));\n}\n\niFloat iFract(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSub(x, iFloor(x));\n}\n\n\niFloat iMin(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(min(x.l, y.l), min(x.u, y.u));\n}\n\niFloat iMax(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(max(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(minVal);\n    CHECK_IF_EMPTY_SET_F(maxVal);\n    return iFloat(clamp(x.l, minVal.l, maxVal.l), clamp(x.u, minVal.u, maxVal.u));\n}\n\n\niFloat iMix(iFloat x, iFloat y, iFloat a) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(a);\n    return iAdd(x, iMul(iSub(y, x), a));\n}\n\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge0);\n    CHECK_IF_EMPTY_SET_F(edge1);\n    CHECK_IF_EMPTY_SET_F(x);\n    iFloat t = iClamp(iDiv(iSub(x, edge0), iSub(edge1, edge0)), 0.0, 1.0);\n    return iMul(iSquare(t), iSub(3.0, iMul(2.0, t)));\n}\n\niFloat iStep(iFloat edge, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (edge.u <= x.l) {\n        return ifloat(1.0);\n    }\n    \n    if (x.u < edge.l) {\n        return ifloat(0.0);\n    }\n    \n    return iFloat(0.0, 1.0);\n}\n\n\niFloat iIf(iBool P, iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_BSET_F(P);\n    \n    if (P.l) {\n        return x;\n    }\n    \n    if (!P.u) {\n        return y;\n    }\n    \n    if (x == EMPTY_SET) {\n        return y;\n    }\n    \n    if (y == EMPTY_SET) {\n        return x;\n    }\n    \n    return iFloat(min(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iIf(bool P, iFloat x, iFloat y) {\n    return iIf(ibool(P), x, y);\n}\niFloat iIf(bool P, float x, iFloat y) {\n    return iIf(ibool(P), ifloat(x), y);\n}\niFloat iIf(bool P, iFloat x, float y) {\n    return iIf(ibool(P), x, ifloat(y));\n}\niFloat iIf(iBool P, float x, iFloat y) {\n    return iIf(P, ifloat(x), y);\n}\niFloat iIf(iBool P, float x, float y) {\n    return iIf(P, ifloat(x), ifloat(y));\n}\niFloat iIf(iBool P, iFloat x, float y) {\n    return iIf(P, x, ifloat(y));\n}\n\niBool iEqual(iFloat x, iFloat y) {\n    if (x == y) {\n        return ibool(true);\n    }\n    \n    if (x.l <= y.u && y.l <= x.l) {\n        return iBool(false, true);\n    }\n    \n    return ibool(false);\n}\n\niBool iGreaterThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l > y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u <= y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iGreaterThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l >= y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u < y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u < y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l >= y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u <= y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l > y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\n\niBool iNOT(iBool x) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    \n    if (x.l && x.u) {\n        return ibool(false);\n    }\n    \n    if (!x.l && !x.u) {\n        return ibool(true);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iAND(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l && y.l, x.l && y.u, x.u && y.l, x.u && y.u);\n}\n\niBool iOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l || y.l, x.l || y.u, x.u || y.l, x.u || y.u);\n}\n\niBool iXOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l ^^ y.l, x.l ^^ y.u, x.u ^^ y.l, x.u ^^ y.u);\n}\n\n\n\n//------------\n// Credit: hatchling\n// (original glsl implementation of rgb-oklab and sRGB-linear conversions)\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\niFloat Linear1(iFloat c) {\n  return(\n    iIf(\n      iLessThanEqual(c, 0.04045),\n      iDiv(c, 12.92),\n      iPow(iDiv(iAdd(c, 0.055), 1.055), 2.4)\n    )\n  );\n}\niVec3 Linear3(iVec3 c) {\n  c.x = Linear1(c.x);\n  c.y = Linear1(c.y);\n  c.z = Linear1(c.z);\n  return c;\n}\niFloat Srgb1(iFloat c) {\n  return(\n    iIf(\n      iLessThan(c, 0.0031308),\n      iMul(c, 12.92),\n      iSub(iMul(1.055, iPow(c, 0.41666)), 0.055)\n    )\n  );\n}\niVec3 Srgb3(iVec3 c) {\n  c.x = Srgb1(c.x);\n  c.y = Srgb1(c.y);\n  c.z = Srgb1(c.z);\n  return c;\n}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}\n\niVec3 oklab_to_rgb(iFloat x, iFloat y, iFloat z)\n{\n    iFloat l_ = iAdd(iAdd(x, iMul(+0.3963377774f, y)), iMul(+0.2158037573f, z));\n    iFloat m_ = iAdd(iAdd(x, iMul(-0.1055613458f, y)), iMul(-0.0638541728f, z));\n    iFloat s_ = iAdd(iAdd(x, iMul(-0.0894841775f, y)), iMul(-1.2914855480f, z));\n\n    iFloat l = iMul(iSquare(l_), l_);\n    iFloat m = iMul(iSquare(m_), m_);\n    iFloat s = iMul(iSquare(s_), s_);\n\n    iVec3 rgbResult;\n    rgbResult.x = iAdd(iAdd(iMul(+4.0767245293f, l), iMul(-3.3072168827f, m)), iMul(+0.2307590544f, s));\n    rgbResult.y = iAdd(iAdd(iMul(-1.2681437731f, l), iMul(+2.6093323231f, m)), iMul(-0.3411344290f, s));\n    rgbResult.z = iAdd(iAdd(iMul(-0.0041119885f, l), iMul(-0.7034763098f, m)), iMul(+1.7068625689f, s));\n    return rgbResult;\n}\n\n\n//////\n\niVec3 ivec3_(vec3 a) {\n    return iVec3(ifloat(a.x), ifloat(a.y), ifloat(a.z));\n}\n\niVec3 iClamp(iVec3 a, iFloat minVal, iFloat maxVal) {\n  a.x = iClamp(a.x, minVal, maxVal);\n  a.y = iClamp(a.y, minVal, maxVal);\n  a.z = iClamp(a.z, minVal, maxVal);\n  return a;\n}\n\niVec3 iSub(iVec3 a, iVec3 b) {\n  a.x = iSub(a.x, b.x);\n  a.y = iSub(a.y, b.y);\n  a.z = iSub(a.z, b.z);\n  return a;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 4.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = 16.0; // down\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(-0.3, 0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -0.5 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 4.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}