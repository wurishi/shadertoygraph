{"ver":"0.1","info":{"id":"MX2SDw","date":"1711581379","viewed":105,"name":"Happy Mandala Accident","username":"ekicam2","description":"I was just goofing around and something cool showed up.\nFeels good :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141593\n\n// special thanks to Fabrice Neyret\n\n// credits: IQ\nfloat sdRegularPolygon(in vec2 p, in float r, in int n ) {\n    // these 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    vec2  acs = vec2(cos(an),sin(an));\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p.y += clamp( -p.y, 0.0, r*acs.y);\n    return length(p)*sign(p.x);\n}\n// credits: 4rknova | https://www.shadertoy.com/view/Mt2GWd\nfloat line2p_dst(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nstruct Config\n{\n    float animator;\n    float rotation;\n    int   prim_vert_count;\n    float prim_radius;\n   \n    float step_rate;\n\n    float vert_radius_min;\n    float vert_radius_max;\n    \n    int   lines_levels;\n    float lines_step;\n};\n\nmat2 rot(Config cfg) {\n    return mat2(\n         cos(radians(cfg.rotation)), sin(radians(cfg.rotation)), \n        -sin(radians(cfg.rotation)), cos(radians(cfg.rotation)));\n}\n\nvec3 inner_color(Config cfg, vec2 uv, vec3 col_out, vec3 graph_color) {\n    float ww = fwidth(uv).x;\n    col_out = graph_color * 0.8;\n        \n    float lines_mask = 0.0;\n    // debug points\n    for(int j = 1; j <= cfg.lines_levels; ++j)\n    for(int i = 0; i < cfg.prim_vert_count; ++i) {\n        //index_cyclic_mutliplier\n        float icm  = float((i) % cfg.prim_vert_count);\n        float nicm = float((i+1) % cfg.prim_vert_count);\n\n        vec2 cdir = vec2(cos(cfg.step_rate * icm), sin(cfg.step_rate * icm));\n        vec2 ndir = vec2(cos(cfg.step_rate * nicm), sin(cfg.step_rate * nicm));\n\n        vec2 cvert = mix(\n            cdir * cfg.vert_radius_min * (cfg.lines_step*float(j)), \n            cdir * cfg.vert_radius_max * (cfg.lines_step*float(j)), \n            cos(cfg.animator + icm * 3.) * 0.5 + 0.5\n        );\n        vec2 nvert = mix(\n            ndir * cfg.vert_radius_min * (cfg.lines_step*float(j)), \n            ndir * cfg.vert_radius_max * (cfg.lines_step*float(j)), \n            cos(cfg.animator + nicm * 3.) * 0.5 + 0.5\n        );\n        // points\n        col_out = mix(col_out, vec3(1.0,1.0,1.0), smoothstep(ww + ww*0.5, ww - ww*0.5, distance(cvert, uv)));\n\n        // lines\n        {\n            // distored\n            mat2 tex_rot = mat2(\n                 cos(iTime* 0.4), sin((iTime* 0.4)), \n                -sin((iTime* 0.4)), cos((iTime* 0.4)));\n            vec3 distort1 = texture(iChannel0, (uv - vec2(0.15) * iTime) * tex_rot).rgb;\n            distort1 *= 0.14f; // adjust based on texture input\n            distort1 *= min(distance(cvert, uv), distance(nvert, uv));\n\n            mat2 tex_rot2 = mat2(\n                 cos(iTime* -0.4), sin((iTime* -0.4)), \n                -sin((iTime* -0.4)), cos((iTime* -0.4)));\n            vec3 distort2 = texture(iChannel0, (uv + vec2(0.025) * iTime) * tex_rot2).rgb;\n            distort2 *= 0.14f; // adjust based on texture input\n            distort2 *= min(distance(cvert, uv), distance(nvert, uv));\n            vec3 distort = max(distort1, distort2);\n            //col = distort;\n\n            // no distort\n            distort = vec3(0);\n\n            float d = smoothstep(ww + ww*0.5, ww - ww*0.5, line2p_dst(cvert, nvert, uv + distort.rg));\n            lines_mask = max(lines_mask, d);\n        }\n    }\n    col_out *= mix(col_out, vec3(1.0, 1.0, 1.0), lines_mask);\n    return col_out;\n}\nvec3 bg_color(Config cfg, vec2 uv, vec3 col_out, vec3 graph_color) {\n    mat2 rotation = rot(cfg);\n        \n    // honestly don't know what happened here \n    float d = sdRegularPolygon(uv*rotation*1.5*0.09, 0.57, cfg.prim_vert_count); // don't ask about magic numbers, I'm a sorcerer\n    col_out = mix(col_out, graph_color, -d); \n    return col_out;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    // util\n    float ww = fwidth(uv).x;\n    const vec3 dbg_col = vec3(1.0, 0.0, 1.0);\n\n    // wtf\n    float multiplier = 0.7;\n   \n    Config cfg;\n    //*/ if you want to turn animation off simply remove first '/'\n    cfg.animator = iTime;/*/\n    cfg.animator = 17.;//*/\n    cfg.rotation = -90.;\n    \n    cfg.prim_vert_count = 157;\n    cfg.prim_radius     = 0.39; \n   \n    cfg.step_rate = (2.*PI) / float(cfg.prim_vert_count);\n\n    cfg.vert_radius_min = 0.1;\n    cfg.vert_radius_max = cfg.prim_radius - 0.01;\n    \n    cfg.lines_levels = 4;\n    cfg.lines_step   = 1. / float(cfg.lines_levels);\n    \n    vec3 col_out = dbg_col;\n    vec3 bg_col = vec3(0.2, 0.2, 0.23) * multiplier;\n    vec3 graph_color = 0.5 + 0.5 * cos(cfg.animator+uv.xyx+vec3(0,2,4)) * multiplier;\n    col_out = bg_col;\n\n    mat2 rotation = rot(cfg);\n    float d = sdRegularPolygon(uv*rotation, cfg.prim_radius, cfg.prim_vert_count);\n#if 0\n    if (d < 0.0) {\n        col_out = inner_color(cfg, uv, col_out, graph_color);\n    } else {\n        col_out = bg_color(cfg, uv, col_out, graph_color);\n    }\n#else\n    vec3 ic = inner_color(cfg, uv, col_out, graph_color);\n    vec3 bgc = bg_color(cfg, uv, col_out, graph_color);\n    col_out = mix(bgc, ic, smoothstep(ww+ww*0.5, ww-ww*0.5, d));\n#endif\n\n    // Output to screen\n    float gamma = 2.2; // I failed here and colors are tuned for that setting ¯\\_(ツ)_/¯\n    col_out = pow(col_out, vec3(gamma));\n    fragColor = vec4(col_out, 1.0);\n}","name":"Image","description":"","type":"image"}]}