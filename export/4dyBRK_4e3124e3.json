{"ver":"0.1","info":{"id":"4dyBRK","date":"1529450290","viewed":1457,"name":"simple global illumination","username":"MonterMan","description":"A simple scene, with global illumination in a simple Monte Carlo integrator. \nBy no means a perfect pathtracer, since the random part of the pathtracer is totally bad.\nIf anyone knows a better way to generate random rays on the GPU, please let me know!","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col = 1.0-exp(-5.0*col); // hand-tuned exposure rate\n    col = pow(col, vec3(1.0 / 2.2)); // gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T_MAX 10e31\n#define TOLERANCE 0.00001\n#define BOUNCE_COUNT 8\n#define SPP 1\n\nstruct material\n{\n    vec3 albedo;\n    vec3 emission;\n};\n    \nstruct sphere\n{\n    vec3 p;\n    float r;\n    material mat;\n};\n\nstruct plane\n{\n    vec3 p;\n    vec3 n;\n    material mat;\n};\n\nfloat hash(float x)\n{\n    return fract(sin(51.5*x)*981.7);\n}\n\nvec3 lambert_distrib(in vec3 n, in vec2 uv)\n{\n    //tangent coordinate system\n    vec3 x, y; \n    if (dot(n, vec3(0,1,0)) > 0.99)\n    {\n        y = normalize(cross(n, vec3(1, 0, 0)));\n        x = cross(y, n);\n    }\telse\n    {\n        x = normalize(cross(vec3(0, 1, 0), n));\n        y = cross(n, x);\n    }\n    \n    float theta = 3.1415926 * 2.0 * uv.x;\n    float r = sqrt(uv.y); // uniform distribution in area instead of distance, \n    \t\t\t\t\t  // hence the square root (a = pi*r^2)\n    \n    vec2 disk_p = vec2(cos(theta), sin(theta)) * r;\n    vec3 p = disk_p.x * x + disk_p.y * y + n * sqrt(1.0 - r*r);\n    return normalize(p);\n}\n\n\n// NOTE(chen): I know this is horrible ... If you have any better ways, let me know\nvec3 random_ray(vec3 n, vec4 seed)\n{\n    vec2 uv = vec2(hash(51.5*seed.x + 15.6*seed.y + 37.1*seed.z + 13.1*seed.w + 15.1*iTime), \n                   hash(19.6*seed.x + 91.1*seed.y + 15.1*seed.z + 21.5*seed.w + 7.8*iTime));\n    return lambert_distrib(n, uv);\n}\n\n#define SPHERE_COUNT 2\n#define PLANE_COUNT 1\n\nsphere spheres[SPHERE_COUNT];\nplane planes[PLANE_COUNT];\nvec3 sky_col = vec3(0);\n\nvoid init_scene()\n{\n    spheres[0] = sphere(vec3(0, 0.5, 0), 0.5, \n                    material(vec3(0.95), vec3(0)));\n\tspheres[1] = sphere(vec3(3.5, 2.8, -0.5), 1.0, \n                    material(vec3(0.95), vec3(2)));\n    planes[0] = plane(vec3(0), vec3(0,1,0), \n                      material(vec3(0.95, 0.55, 0.2), vec3(0)));\n}\n\nvec3 pathtrace(in vec3 ro, in vec3 rd, in int sample_i)\n{\n    vec3 col = vec3(0);\n    \n    vec3 atten = vec3(1);\n    vec3 next_n;\n    for (int bounce_i = 0; bounce_i < BOUNCE_COUNT; ++bounce_i)\n    {\n        float min_t = T_MAX;\n        material mat;\n\n        for (int sphere_i = 0; sphere_i < SPHERE_COUNT; ++sphere_i)\n        {\n            vec3 p = spheres[sphere_i].p;\n            float r = spheres[sphere_i].r;\n\n            float a = dot(rd, rd);\n            float b = 2.0 * dot(ro - p, rd);\n            float c = dot(ro - p, ro - p) - r*r;\n            float denom = 2.0 * a;\n            float sqrt_term = b*b - 4.0*a*c;\n\n            if (denom != 0.0 && sqrt_term >= 0.0)\n            {\n                float t1 = (-b + sqrt(sqrt_term)) / denom;\n                float t2 = (-b - sqrt(sqrt_term)) / denom;\n\n                float t = min(t1, t2);\n                if (t > TOLERANCE && min_t > t)\n                {\n                    min_t = t;\n                    next_n = normalize(ro + t*rd - p);\n                    mat = spheres[sphere_i].mat;\n                }\n            }\n        }\n\n        for (int plane_i = 0; plane_i < PLANE_COUNT; ++plane_i)\n        {\n            vec3 p = planes[plane_i].p;\n            vec3 n = planes[plane_i].n;\n\n            float t = dot(p - ro, n) / dot(rd, n);\n            if (t > TOLERANCE && min_t > t)\n            {\n                min_t = t;\n                next_n = n;\n                mat = planes[plane_i].mat;\n            }\n        }\n        \n        if (min_t > TOLERANCE && min_t != T_MAX)\n    \t{\n            col = col + atten * mat.emission;\n            atten *= mat.albedo;\n            \n            ro = ro + min_t*rd;\n            rd = random_ray(next_n, vec4(ro, sample_i * BOUNCE_COUNT + bounce_i));\n    \t}\n        else\n        {\n            col += atten * sky_col;\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 prev_col = texture(iChannel0, uv).rgb;\n\n    uv = 2.0 * uv - 1.0;\n    uv.x /= iResolution.y / iResolution.x;\n        \n    //jitter the sampler each time to do poor man's multisample\n    vec2 pixel_size = (1.0 / iResolution.xy);\n    pixel_size.x /= iResolution.y / iResolution.x; //conform to the scaled ar\n    vec2 uv_jitter = pixel_size * (-1.0 + 2.0 * vec2(hash(91.5*uv.x + 15.6*uv.y + 15.1*iTime), hash(11.6*uv.x + 91.1*uv.y + 17.8*iTime)));\n    uv += uv_jitter;\n    \n    vec3 at = vec3(0, 0.5, 0);\n    vec3 ro = vec3(0, 0.9, -2.5);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 2.0 * cam_z);\n\t\n    init_scene();\n    \n    vec3 col = pathtrace(ro, rd, 0);\n        \n    int frame_count = iFrame + 1;\n    float prev_weight = float(iFrame) / float(frame_count);\n    float curr_weight = 1.0 - prev_weight;\n    \n    fragColor = vec4(prev_weight * prev_col + curr_weight * col, 1);\n}","name":"Buf A","description":"","type":"buffer"}]}