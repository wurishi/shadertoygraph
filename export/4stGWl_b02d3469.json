{"ver":"0.1","info":{"id":"4stGWl","date":"1452801224","viewed":236,"name":"Ringys","username":"lucastakejame","description":"gif inspired shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circles","spin","strips"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define THICKNESS 5.0\n#define SPACE_BETWEEN .0\n\n#define ALTERNATE_DIRECTION false\n\nfloat pi = 3.1415;\n\n/*\n    More efficient way:\n        check if pixel is in strip domain or spacebetween domain\n        check if pixel is inside current angle window\n\n        working with the angle interval [0, 2pi]\n*/\nbool checkDonut(vec2 polarCoord, float speed, float ringFrac, float thickness, float space){\n    float pixDistance = polarCoord.x;\n    float pixAngle = polarCoord.y;\n\n    // this mod get the pixel relative position to the strip origin\n    // then checks if this position is on a strip or a space\n    if(mod(pixDistance, thickness + space) < thickness)\n    {\n        // num of the strip counting from the center\n        int stripN = int(pixDistance/(thickness + space));\n        float angleBegin;\n\n        \n        if(mod(float(stripN), 2.) == 0. && ALTERNATE_DIRECTION)\n        {\n            angleBegin = mod((speed)*(float(1+stripN)/3.)*iTime, 2.*pi);\n\n            // going in this direction causes negative beginning angles\n            // this deals with it\n            if(angleBegin < 0.)\n            {\n                angleBegin += 2.*pi;\n            }\n        }\n        else\n        {\n            angleBegin = mod((-speed)*(float(1+stripN)/3.)*iTime, 2.*pi);\n        }\n        \n        // defines which angle ( counter-clock wise) the strip starts\n        float angleEnd = mod(angleBegin + 2.0*pi*ringFrac, 2.*pi);\n\n        // when it passes 2*pi and the ending angle is smaller than the beginning\n        if(angleEnd < angleBegin)\n        {\n            if(pixAngle <= angleEnd || pixAngle >= angleBegin)\n            {\n                return true;\n            }\n        }\n        else\n        {\n            if(angleBegin <= pixAngle && pixAngle <= angleEnd)\n            {\n                return true;\n            }\n        }\n\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    float thickness = THICKNESS;\n    float space = SPACE_BETWEEN;\n    float speed = (iMouse.x != 0.) ? 5.0*iMouse.x/iResolution.x : .5;\n    float ringFrac = (iMouse.y != 0.)? iMouse.y/iResolution.y : .5;\n\n    \n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 center = iResolution.xy/2.0;\n       \n    float dist = distance(fragCoord, center);\n\n    float arc;\n\n    // get angle of pixel in plane with\n    // origin in the middle of the screen\n    // angle 0 points to east\n    // grows Counter clock wise\n    if((fragCoord.x - center.x) != 0.0)\n    {\n        // Gets arc from arc tangent and position\n        // transforms arc so its 0 starts on east direction, going CCW\n        arc = atan(-(fragCoord.y - center.y), (fragCoord.x - center.x));\n        arc += 2.*pi;\n        arc = mod(arc, 2.*pi);\n    }\n    else\n    {\n        if((fragCoord.y - center.y) >= 0.0)\n        {\n            arc = pi/2.;\n        }\n        else\n        {\n            arc = 3.*pi/2.;\n        }\n    }\n\n    vec2 polarCoord = vec2(dist, arc);\n    \n    // Background Color\n    fragColor = vec4(0., 0., 0., 1.0);\n        \n    // is pixel inside a ring\n    if(checkDonut(polarCoord, speed, ringFrac, thickness, space))\n    {\n        fragColor = vec4(uv.x*2., uv.y*3., 0.5+0.5*sin(iTime), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}