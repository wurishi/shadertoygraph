{"ver":"0.1","info":{"id":"wd3fRX","date":"1605645730","viewed":72,"name":"voxel example","username":"stb","description":"Basic voxel renderer.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// glslsandbox implementation: http://glslsandbox.com/e#58331.0\n\nconst float maxDist = 70.;\n\n// somebody else's rotation matrix, but I shortened it\nmat3 rotMat(vec3 ax, float a) {\n    ax = normalize(ax);\n    float s = sin(a), c = cos(a), oc = 1. - c;\n    vec2 j = oc * ax.x * ax.xy, k = oc * ax.y * ax.yz, l = oc * ax.z * ax.zx;\n    return mat3(j.x+c,j.y-s*ax.z,l.y+s*ax.y,j.y+s*ax.z,k.x+c,k.y-s*ax.x,l.y-s*ax.y,k.y+s*ax.x,l.x+c);\n}\n\n// the landscape\nfloat map(in vec3 p, vec3 camPos) {\n    float f, c = length(p-camPos+.5)-3.;\n    \n    p = mod(p, 16.)-8.;\n    \n    f = length(p)-5.;\n    f = min(f, length(p.xy)-2.);\n    f = min(f, length(p.yz)-2.);\n    f = min(f, length(p.zx)-2.);\n    return max(f, -c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / res.y;\n\tvec2 mPos\t= 3.5 * (iMouse.xy-.5*res) / res.y;\n    \n    // matrix for for rotating the camera\n    mat3 dirRot = rotMat(vec3(0., 1., 0.), mPos.x);\n    dirRot *= rotMat(vec3(1., 0., 0.), -mPos.y);\n    \n    // setting up caera and ray direction\n    vec3 camPos\t= vec3(.5);\n    vec3 rayDir\t= normalize(vec3(uv, .5));\n    \n    rayDir\t\t*= dirRot;\n    camPos.z\t+= iTime;\n    \n    vec3 adj, xV, yV, zV, V_;\n    vec3 po\t= sign(rayDir);\n    vec3 V\t= camPos, LV;\n    float dist = -1.;\n    bool didHit = false;\n    \n    // finding the intersection\n    for(int i=0; i<100; i++) {\n        dist = length(V-camPos);\n        \n        LV = V;\n        \n        adj = mix(floor(V+po), ceil(V+po), .5-.5*po) - V;\n        \n        xV = adj.x * vec3(1., rayDir.yz/rayDir.x);\n        yV = adj.y * vec3(rayDir.xz/rayDir.y, 1.);\n        zV = adj.z * vec3(rayDir.xy/rayDir.z, 1.);\n\n        V_ = vec3(length(xV)<length(yV) ? xV : yV.xzy);\n    \tV_ = vec3(length(V_)<length(zV) ? V_ : zV);\n        \n        V += V_;\n        \n        if(map(floor((V+LV)/2.), camPos)<0.){didHit=true; break;}\n        if(dist>maxDist) break;\n    }\n    \n    // final output with fog effect\n    fragColor = vec4(vec3(1., 1.2, 1.5)*float(didHit ? dist/maxDist : 1.), 1.0);\n}","name":"Image","description":"","type":"image"}]}