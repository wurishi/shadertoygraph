{"ver":"0.1","info":{"id":"XtlBRf","date":"1512728616","viewed":361,"name":"click to make waves","username":"harrisonvanderbyl","description":"splishy splashy\nthe resetting is to avoid feedback","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["waves","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCLICK AND DRAG TO LOOK AROUND\n\n\n\nSETTINGS ARE BELOW\n\n\n\n\n*/\n\n#define ATMOSPHEREHEIGHT 2400\n#define time -1.62/20.0+0.5\n#define FOV 0.5\n#define AURORORHEIGHT 100.0\n#define AURORORBRIGHTNESS 1.5\n\nvec3 cam = vec3(0,10.0,0);\n\n#define sunpos vec3(0,sin(time),cos(time))\nvec3 CENTER = vec3(0.0,-63710.0,0.0);\nfloat dts( vec3 camm,vec3 poss,vec3 center, float radius,float sig){\nfloat a =\n       pow((dot(normalize(poss-camm),camm-center)),2.0)\n       -pow(length(camm-center),2.0)+pow(radius,2.0);\nif (a<0.0){return -1.0;}\nfloat dd = -(dot(normalize(poss-camm),(camm-center)))\n       +sig*sqrt(a);\n//if (dd < 0.0){return -1.0;}\nreturn dd;\n\n}\n\nfloat random (in vec3 _st) {\n    return fract(sin(dot(_st.xyz,\n                         vec3(12.9898,78.233,82.19)))*\n        43758.5453123);\n}\n\nfloat starnoise (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float starthreshhold = 0.99;\n    float a = float(random(i)>starthreshhold);\n    float b = float(random(i + vec3(1.0, 0.0,0.0))>starthreshhold);\n    float c = float(random(i + vec3(0.0, 1.0,0.0))>starthreshhold);\n    float d = float(random(i + vec3(1.0, 1.0,0.0))>starthreshhold);\n\n    float e = float(random(i + vec3(0.0, 0.0,1.0))>starthreshhold);\n    float g = float(random(i + vec3(1.0, 0.0,1.0))>starthreshhold);\n    float h = float(random(i + vec3(0.0, 1.0,1.0))>starthreshhold);\n    float j = float(random(i + vec3(1.0, 1.0,1.0))>starthreshhold);\n\n    f = (1.0-cos(f*3.1415))/2.0;\n   // f = 0.5+sign(f-0.5)*0.5*pow(abs(f-0.5)*2.0,vec3(3.0));\n   // float a1 = mix(a, b, u.x) +\n     //       (c - a)* u.y * (1.0 - u.x) +\n     //(d - b) * u.x * u.y;\n     float a1 = mix(a,b,f.x);\n     float a2 = mix(c,d,f.x);\n     float a3 = mix(e,g,f.x);\n     float a4 = mix(h,j,f.x);\n\n     float a5 = mix(a1,a2,f.y);\n     float a6 = mix(a3,a4,f.y);\n\n\n    return mix(a5,a6,f.z);\n}\n\nfloat noise (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0,0.0));\n    float c = random(i + vec3(0.0, 1.0,0.0));\n    float d = random(i + vec3(1.0, 1.0,0.0));\n\n    float e = random(i + vec3(0.0, 0.0,1.0));\n    float g = random(i + vec3(1.0, 0.0,1.0));\n    float h = random(i + vec3(0.0, 1.0,1.0));\n    float j = random(i + vec3(1.0, 1.0,1.0));\n\n    f = (1.0-cos(f*3.1415))/2.0;\n   // float a1 = mix(a, b, u.x) +\n     //       (c - a)* u.y * (1.0 - u.x) +\n     //(d - b) * u.x * u.y;\n     float a1 = mix(a,b,f.x);\n     float a2 = mix(c,d,f.x);\n     float a3 = mix(e,g,f.x);\n     float a4 = mix(h,j,f.x);\n\n     float a5 = mix(a1,a2,f.y);\n     float a6 = mix(a3,a4,f.y);\n\n\n    return mix(a5,a6,f.z);\n}\n\nfloat fbm ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0,22.5,44.0);\n    float r = 1.0;\n    for (int i = 0; i < 4; ++i){\n        v += a * noise(_st);\n        r += a;\n        _st =  shift + _st*2.0;\n        _st = (sin(r)*_st+cos(r)*_st);\n        a *= 0.5;\n    }\n    return v;\n}\nfloat edis(vec3 from,vec3 to){\nvec3 plac = CENTER;\nfloat rad = -CENTER.y - 6.0;\n\nfloat a = dts(from,to,plac,rad,-1.0);\nfloat b = dts(from,to,plac,rad, 1.0);\n\nif(a<0.0&&b<0.0)\n{\nreturn -1.0;\n}\nif(a < 0.0){return b;}\nif(b < 0.0){return a;}\n\nreturn min(a,b);\n\n}\nfloat sdis(vec3 from,vec3 to){\nvec3 plac = CENTER;\nfloat rad = -CENTER.y + float(ATMOSPHEREHEIGHT);\n\nfloat a = dts(from,to,plac,rad,-1.0);\nfloat b = dts(from,to,plac,rad, 1.0);\n\nif(a<0.0&&b<0.0)\n{\nreturn -1.0;\n}\nif(a < 0.0){return b;}\nif(b < 0.0){return a;}\n\nreturn min(a,b);\n}\nvec3 outscatter(float r){\n\n\nvec3 a =  vec3(1.02651);\nvec3 b = vec3(620.0,540.0,460.0)*1.0f;\nvec3 os = (2.0*3.1415*4079.660796735571*a*a*r)/(b*b*b*b);\nreturn 1.0 - os;\n\n\n\n\n}\nvec3 scatter(float intensity,vec3 lightdir,vec3 from, vec3 to){\n\n\nvec3 l = lightdir;\nfloat d = intensity;\n\nfloat r = distance(from,to);\nfloat c = acos(dot(normalize(to-from),normalize(l)));\nvec3 a =  vec3(1.02651);\nvec3 b = vec3(620.0,540.0,460.0)*1.0f;\n\n\n\n\nfloat si = sdis(mix(to,from,0.5)+l*0.5, mix(to,from,0.5)+l);\nfloat ai = sdis(mix(to,from,0.99)+l*0.5, mix(to,from,0.99)+l);;\nfloat fi = 0.5*(si+ai);\n//float si = edis(from-l*0.5, from+l);\n//if(si<ai){return vec3(0.0);};\nfloat mol = 215443.469003;\nfloat area = sin(c)*r*(si+ai)*0.5;\nvec3 is = d * 100.0*r * (779.180801368*a*a*(1.5+0.5*cos(2.0*c))/(pow(b,vec3(4.0))));\n\n//vec3 os = 2.0*25214649.0*a*a*d*8.0*pow(3.1415,5.0)*r/(16053091.0*b*b*b*b);\nreturn (is*outscatter(((si+ai)/2.0)*300.0));//(0.5*(r+distance(from+l*si,pos+l*fi)))) ;\n\n\n\n\n\n\n}\nfloat getcloud(in vec3 a)\n{\n    float r = fbm( a / 20.0 + vec3(time*3.0, time*2.0, 0.0) );\n       float th = 0.55;//sin(210.11);\nreturn max(1.0-r/th,0.0);\n}\nvec3 getwatnorm(in vec2 uv)\n{\n\nreturn (texture(iChannel2,uv).xyz);\n\n}\nfloat afbm(in vec3 a){\n\nreturn fbm(a)*max(1.0-a.y,0.0);\n}\nvec3 getaurora(in vec3 a){\n    float av = AURORORHEIGHT;//200.0;\n    vec3 acc = vec3(0.0);\n    for(float i = 0.0;i < av;i++){\n        vec3 z = a;\n        z.xz = z.xz/((float(i)/(50.0))+1.0) ;\nfloat r = fbm(z/800.0+vec3(0.0,time,0.0));\n    float th = sin(210.11);\n       acc+=float(r>th&&r<(th+0.05*sin(distance(a.xz,cam.xz)/5000.0)))*vec3(0.0025*pow(max(1.0-abs(i/av),0.0),2.0),0.025*pow(abs(i/av-0.5)*2.0,1.0),0.0125*pow((i/av),1.0/2.0)).xzy*AURORORBRIGHTNESS*i/av;\n    }\n\n    return acc;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam.y=fbm(cam+vec3(0.0,0.0,time*5.0))*10.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    \n    vec2 look = vec2(0.0,0.2)*3.1415*2.0+3.1415;\n    look=look;\n    look.y=look.y*0.5+3.1415/2.0+3.1415;\n    look.x = -look.x + 3.1415;\n    \n    //xy = mouse when clickdown\n    //zw = mouse when clickfirst\n    vec3 screen = vec3(0.0);//\n    screen.x = uv.x;\n    screen.y = -sin(look.y)*FOV+cos(look.y)*uv.y*(iResolution.y/iResolution.x);\n    screen.z = cos(look.y)*FOV+sin(look.y)*uv.y*(iResolution.y/iResolution.x);\n   float temp = screen.x;\n    screen.x = cos(look.x)*screen.x+sin(look.x)*screen.z;\n    \n    screen.z = -sin(look.x)*temp+cos(look.x)*screen.z;\n    \n    \n   \n    vec3 pos = cam+screen;\nvec3 virtualPos = pos;\nvec3 directionToFragmentPosition = normalize(pos-cam);\nvec3 lightDir = sunpos;\nfloat distanceToGround = edis(cam,pos);\n    vec3 groundPosition = cam+directionToFragmentPosition*distanceToGround;\nfloat preReflectionDistance = 0.0;\n    vec3 preReflectionDirection = vec3(0.1);\n   if(distanceToGround>0.0){\n       preReflectionDistance = distanceToGround;\n       cam = groundPosition;\n       preReflectionDirection = directionToFragmentPosition;\n       directionToFragmentPosition = reflect(directionToFragmentPosition,getwatnorm(uv+0.5));\n       \n       //  fragmentColor = scatter(50.0,-lightDir,cam,groundPosition)*-dot(groundDirection,lightDir)*vec3(getcloud(groundPosition+vec3(10.1)),getcloud(groundPosition),getcloud(-groundPosition));\n     //max(outscatter((distance(cam,groundPosition))*30.0),vec3(0.0))*scatter(50.0,lightDir,cam,groundPosition)*mix(vec3(0.40,0.20,0.2),vec3(0.45,0.33,0.2),getcloud(groundPosition))*-dot(normalize(groundPosition-CENTER),lightDir);\n    }\n    \n   float distanceToSky = sdis(cam,cam+directionToFragmentPosition);\n    vec3 skyPosition = cam+directionToFragmentPosition*distanceToSky;\n   \n    virtualPos = skyPosition;\n    vec3 skyColor = scatter(50.0,lightDir,cam,virtualPos)+scatter(50.0,lightDir,vec3(0.0),preReflectionDirection)*preReflectionDistance;\n    //if(distance(cam,CENTER)>CENTER.y){distanceToSky = distanceToGround - distanceToSky;}\n\n    float sunColor = pow(max(dot(directionToFragmentPosition,vec3(lightDir)),0.0),200.0);\n    skyColor += 2.0 * sunColor * max(outscatter(150.0 * (distance(cam, virtualPos)+preReflectionDistance)),0.0);\n    vec3 skyDirection = normalize(virtualPos - CENTER);\n    vec2 cloudColor =  vec2(( pow(getcloud(skyPosition/50.0),3.0)),( pow(getcloud(skyPosition/50.0+lightDir*3.0*vec3(0.0,0.0,1.0)),2.0))) ;\n vec3 groundDirection = normalize(groundPosition - CENTER);\n    vec2 skyPolarCoords = vec2(atan(skyDirection.y,skyDirection.z),asin(skyDirection.x)+3.1415/2.0);\n    float star = (starnoise(virtualPos/30.0));\n    vec3 starCol = vec3(pow(star,1.0));\n    //starCol += getaurora(virtualPos);\n    float a = sdis(virtualPos+lightDir*0.5,virtualPos+lightDir);\n    float b = edis(virtualPos+lightDir*0.5,virtualPos+lightDir);\n    float distanceToNight = float(a>b)*a;\n    skyColor *= max(outscatter((distanceToNight)*300.0),vec3(0.0));\n    skyColor = mix(skyColor,vec3(1.0),cloudColor.x*1.0);\n    skyColor = mix(skyColor,vec3(0.9),cloudColor.y*1.0);\n    vec3 fragmentColor = mix(clamp(skyColor,vec3(0.0),vec3(1.0)),starCol,1.0-max(outscatter((distanceToNight)*300.0),vec3(0.0)));\n  //  if(distanceToGround>0.0){\n  //  fragmentColor = scatter(50.0,-lightDir,cam,groundPosition)*-dot(groundDirection,lightDir)*vec3(getcloud(groundPosition+vec3(10.1)),getcloud(groundPosition),getcloud(-groundPosition));\n     //max(outscatter((distance(cam,groundPosition))*30.0),vec3(0.0))*scatter(50.0,lightDir,cam,groundPosition)*mix(vec3(0.40,0.20,0.2),vec3(0.45,0.33,0.2),getcloud(groundPosition))*-dot(normalize(groundPosition-CENTER),lightDir);\n  //  }\n fragColor = vec4(fragmentColor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ism = float(iMouse.z>0.0);\n    float intens = ism*(pow(1.0-distance(fragCoord,iMouse.xy)/10.0,1.0));\n    vec4 buf = vec4(texture(iChannel0,uv));\n    //vec4(texture(iChannel2,vec2(0.99,0.99))).xy;\n    buf.xy = mix(buf.xy,vec2(iTime+0.0),float(intens>0.5));\n    if(distance(uv,vec2(0.99,0.99))<0.01){buf.xy = iMouse.xy/iResolution.xy;}\n    if(distance(texture(iChannel0,vec2(0.5)),vec4(0.0,0.0,0.0,0.5))<0.001){\n    buf = vec4(0.0);\n    }\nfragColor = buf;\n    \n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 CENTER = vec3(0.0,-63710.0,0.0);\nvec3 cam = vec3(0,10.0,0);\n#define FOV 0.5\nfloat dts( vec3 camm,vec3 poss,vec3 center, float radius,float sig){\nfloat a =\n       pow((dot(normalize(poss-camm),camm-center)),2.0)\n       -pow(length(camm-center),2.0)+pow(radius,2.0);\nif (a<0.0){return -1.0;}\nfloat dd = -(dot(normalize(poss-camm),(camm-center)))\n       +sig*sqrt(a);\n//if (dd < 0.0){return -1.0;}\nreturn dd;\n\n}\n\nfloat edis(vec3 from,vec3 to){\nvec3 plac = CENTER;\nfloat rad = -CENTER.y - 6.0;\n\nfloat a = dts(from,to,plac,rad,-1.0);\nfloat b = dts(from,to,plac,rad, 1.0);\n\nif(a<0.0&&b<0.0)\n{\nreturn -1.0;\n}\nif(a < 0.0){return b;}\nif(b < 0.0){return a;}\n\nreturn min(a,b);\n\n}\n\nvec3 getpo(vec2 uva){\n     vec2 uv = uva-0.5;\n    vec2 look = vec2(0.0,0.2)*3.1415*2.0+3.1415;\n    look=look;\n    look.y=look.y*0.5+3.1415/2.0+3.1415;\n    look.x = -look.x + 3.1415;\n    \n    //xy = mouse when clickdown\n    //zw = mouse when clickfirst\n    vec3 screen = vec3(0.0);//\n    screen.x = uv.x;\n    screen.y = -sin(look.y)*FOV+cos(look.y)*uv.y*(iResolution.y/iResolution.x);\n    screen.z = cos(look.y)*FOV+sin(look.y)*uv.y*(iResolution.y/iResolution.x);\n   float temp = screen.x;\n    screen.x = cos(look.x)*screen.x+sin(look.x)*screen.z;\n    \n    screen.z = -sin(look.x)*temp+cos(look.x)*screen.z;\n    \n    \n vec3 pos = cam+screen;\nvec3 virtualPos = pos;\nvec3 directionToFragmentPosition = normalize(pos-cam);\n\nfloat distanceToGround = edis(cam,pos);\n   return cam+directionToFragmentPosition*distanceToGround;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    \n     vec2 uv = fragCoord.xy / iResolution.xy;\n    \n     vec4 mem = (vec4(texture(iChannel1,uv)));\n    mem.z = 0.0;\n   mem.w = 0.5;\n    if(length(mem)==0.5){mem.xy = uv;}\n     \n     vec2 ste = vec2(0.01,0.01);\n     vec2 preste = vec2(0.01,0.01);\n    vec4 apas = (vec4(texture(iChannel0,vec2(0.99,0.99))));\n    for(int i = 0; i < 1000 ; i++)\n    {\n    \tvec4 me = (vec4(texture(iChannel1,ste)));\n        float retime = (texture(iChannel0,ste)).x;\n        float xvar = 1.0/(1.0+pow((iTime-retime)*5.0,2.0))*cos(min(-(iTime-retime)*10.0+distance(getpo(uv),getpo(ste))*3.0-1.0,0.0));\n           mem.z+=xvar;\n        if (retime>2.0)\n        {\n        \t   if(distance(uv,preste)<0.005){\n                // mem.xy = texture(iChannel0,texture(iChannel0,me.xy).xy).xy; \n             \n             }    \n                  \n        }\n        preste = ste;\n        if(me.xy==ste){me.xy = apas.xy;\n                       \n             if(distance(uv,ste)<0.005){\n                 mem.xy = apas.xy; \n             \n             }    \n                       break;\n                      }\n        \n       \n ste = me.xy;\n        if(i==999)\n        {\n          mem = vec4(0.0,0.0,0.0,0.5);\n        }\n}\n     fragColor = mem;\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord.xy / iResolution.xy;\n    float base = 0.0015*(texture(iChannel1,uv).z);\n    float abase = 0.0015*(texture(iChannel1,uv+vec2(0.01,0.0)).z);\n    float bbase = 0.0015*(texture(iChannel1,uv+vec2(0.00,0.01)).z);\n    fragColor = vec4(normalize(cross(normalize(vec3(0.0,base,0.0)-vec3(0.01,abase,0.0)),normalize((vec3(0.0,base,0.0))-(vec3(0.0,bbase,0.01))))),1.0);;\n}","name":"Buf C","description":"","type":"buffer"}]}