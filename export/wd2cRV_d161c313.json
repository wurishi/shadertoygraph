{"ver":"0.1","info":{"id":"wd2cRV","date":"1587014738","viewed":297,"name":"Day2: Heart Monitor","username":"fluxatron","description":"Had a crack at writing a pulse monitor. Has some issues but was fun anyways.\n\nIdeally I'd have an even width pulse line. Multipass rendering with glow effect. And a more accurate pulse shape.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["noob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 gamma = vec3(2.2);\n\n// Palette (RGB 2.2 color space)\nvec3 green = vec3(81.0/255.0, 201.0/255.0, 150.0/255.0);\nvec3 darkGreen = vec3(0.0/255.0, 40.0/255.0, 19.0/255.0);\nvec3 headGreen = vec3(223.0/255.0, 252.0/255.0, 226.0/255.0);\n\nfloat aspectRatio;\nvec2 uv;\nvec2 uvAspect;\n\n\nvec3 ACESFitted(vec3 color);\n\nvec3 circle(vec2 samplePoint, vec2 center, float radius)\n{\n    vec2 sampleDisp = samplePoint - center;\n    float sampleLen2 = sampleDisp.x*sampleDisp.x + sampleDisp.y*sampleDisp.y;\n    float ratio = sampleLen2 / (radius*radius);\n\n    return vec3(1.0 - min(ratio,1.0));\n}\nvec3 background()\n{\n    // Flat shade\n    vec3 col = darkGreen;\n    float intensity = 2.0;\n    \n    // Grid lines\n    {\n        float thickness = 0.003;\n        float spacing = 0.065;\n        \n        // Compute first line pos\n        float leftBound = 0.0;\n    \tfloat firstX = leftBound - fract(iTime*0.4)*spacing;\n        \n        // Vertical Grid Lines\n        for (float x = firstX; x < aspectRatio; x += spacing)\n        {\n            if (uvAspect.x > (x-thickness) && uvAspect.x < (x+thickness))\n            {\n                col += darkGreen;\n            }\n        }\n        \n\t\t// Horizontal Grid Lines\n        for (float y = 0.0; y < 1.0; y += spacing)\n        {\n            if (uvAspect.y > (y-thickness) && uvAspect.y < (y+thickness))\n            {\n                col += darkGreen;\n            }\n        }\n    }\n    \n    return col * intensity;\n}\nfloat shape(float x, float offset) // x:[0,1]\n{\n    x += offset;\n    if (x > 1.0) x -= floor(x);\n    \n    float s1 = 0.15;         // flat\n    float s2 = s1 + 0.2;     // b1\n    float s3 = s2 + 0.34;     // flat\n    float s4 = s3 + 0.1;     // b2\n    float s5 = s4 + 0.03;    // flat\n    float s6 = s5 + 0.2;     // b3\n    \n    float y = 0.0;\n    \n    if (x < s1) { return 0.0; }\n    \n    if (x < s2)\n    {\n    \treturn 0.05 - 0.05*cos((x-s1)*30.0);\n    }\n    \n    if (x < s3) { return 0.0; }\n    \n    if (x < s4)\n    {\n    \treturn 0.02 - 0.02*cos((x-s3)*60.0);\n    }\n    \n    if (x < s5) { return 0.0; }\n    \n    if (x < s6)\n    {\n    \treturn 0.3*sin((x-s5)*35.0);\n    }\n    \n    if (x > 1.0) return -.4;\n}\nfloat wrapIntensity(float sampleX, float xMax, float h)\n{\n    float v = sampleX + xMax - h; // wrap\n    if (v > xMax) v -= xMax; // clamp to [0,xMax]\n    return v/xMax; // normalize\n}\nvec3 line()\n{   \n    float repeats = 3.0;\n    float scanRate = 0.18;\n\tfloat intensity = 1.5;\n    float offset = iTime*0.1;\n    \n    vec3 col = vec3(0,0,0);\n    \n    // Calc head position\n    float x =  aspectRatio * (scanRate*iTime - floor(scanRate*iTime)); // x:[0,aspectRatio)\n\tfloat yOffset = 0.5;\n    \n    vec2 headPos = vec2(x, yOffset + shape(x * repeats/aspectRatio, offset));\n    vec2 linePos = vec2(uvAspect.x, yOffset + shape(uvAspect.x * repeats/aspectRatio, offset));\n    \n    // Line\n    float thickness = 0.015/2.0;\n    if (uv.y > linePos.y - thickness && uv.y < linePos.y + thickness)\n    {\n        col = green * pow(wrapIntensity(linePos.x, aspectRatio, headPos.x), 2.0);\n    }\n    \n    // Glowing Head\n    vec3 mask = pow(circle(uvAspect, headPos, 0.2), vec3(200.0));\n    col += 2.0 * headGreen * mask;\n    \n    return col * intensity;\n}\n\nvec3 vignette()\n{\n    float darkest = 0.00;\n    vec3 shade = circle(uvAspect, vec2(aspectRatio/2.0, 0.5), 0.85);\n    return darkest + (1.0-darkest)*shade;\n}\nvoid linearizePallete()\n{\n    green = pow(green, gamma);\n    darkGreen = pow(darkGreen, gamma);\n    headGreen = pow(headGreen, gamma);\n}\n\nvec3 flicker(vec3 col)\n{\n    return col * (1.0 + 0.03*sin(iTime*50.0) + 0.04*sin(iTime*29.0) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Globals\n    linearizePallete();\n    aspectRatio = iResolution.x / iResolution.y;\n    uv = fragCoord / iResolution.xy;       // w:[0,1], h:[0,1]\n    uvAspect = fragCoord / iResolution.yy; // w:[0,apsect], h:[0,1]\n    \n    // Set color\n    vec3 col = vec3(0,0,0);\n    col += background();\n    col += line();\n    col = flicker(col);\n    col *= vignette();\n    \n    // Post\n\tcol *= 1.5; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n    col = pow(col, 1.0/gamma); // gamma\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.07600, 0.02840, \n\t0.35458, 0.90834, 0.13383,\n\t0.04823, 0.01566, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.10208, -0.00327,\n\t-0.53108,  1.10813, -0.07276,\n\t-0.07367, -0.00605,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v)\n{\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFitted(vec3 color)\n{\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit(color);\n\tcolor = ACESOutputMat * color;\n\tcolor = clamp(color,0.0,1.0);\n\treturn color;\n}\n","name":"Image","description":"","type":"image"}]}