{"ver":"0.1","info":{"id":"4sGBDt","date":"1530967347","viewed":91,"name":"hypnotic snake","username":"JohanFlod","description":"Some practice on creating patterns in shader code. \n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","stylee"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nVariation of another shader I made\n\nNot optimised code in any way. \n\n*/\n\n#define TWO_PI 6.28318530718\n\nvec2 uv; //2D plane\nvec3 col; //Color palette\nfloat radius;\nfloat amplitude = 0.3; \nconst int NUM_BALLS = 16;\nvec2 ball_positions[NUM_BALLS];\n\n\n// unescessary with elipse when only drawing circles :P\n\nbool isellipse(float x_center, float y_center, float radius1)\n{\n    bool result = false;\n    \n    \n    if (sqrt( radius1*pow(uv.x - x_center,2.0) \n             + radius1*pow(uv.y - y_center,2.0)\n            ) < radius1 * radius1\n        )result = true;\n        \n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    float high_Limit = 1.2;\n    float low_Limit = -1.2;\n    float color;\n        \n    // draw background gradient\n    \n    if (uv.y < high_Limit && uv.y > low_Limit){\n        color = distance(uv.y,high_Limit)/abs(high_Limit-low_Limit);\n        color = fract ( 5.*color*3.);\n        col = vec3(0.0,0.0,.5*fract(color-iTime));      \n    }\n    \n    float lowerLimit = 0.5*sin(iTime);\n    float upperLimit = 0.5*sin(iTime+1.);\n    \n   \t\n  \n    vec2 position1,position2,position3;\n    for(int j = 0; j < NUM_BALLS; j++)\n    {\n    \tfloat t = 1.0f * iTime  + ( float(j)/ float(NUM_BALLS)) * (2.0f * 3.14159f);\n        ball_positions[j].x = cos(t)+0.4*cos(t*1.4);\n        ball_positions[j].y = 0.2*sin(2.4*t-.3)+0.3*sin(t-.5);\n        \n    }\n  \n    float radius = 0.3+.2*cos(uv.y);\n    \n\t// loop through balls and draw them \n    \n    for(int j = 0; j < NUM_BALLS; j++)\n    {\n        \n        if(isellipse(ball_positions[j].x, ball_positions[j].y , radius))    \n        {\n            float colour3 = (distance(uv,ball_positions[j]))/radius;\n            float colour2 = 1.0-colour3;\n           \n           \tfloat colour = (float(j)/ float(NUM_BALLS))*colour2;\n            col = vec3(fract(colour), 0.f , fract(colour3*10.f-.5*iTime));\n        }\n    }\n\tfragColor = vec4(col,0.1);\n}","name":"Image","description":"","type":"image"}]}