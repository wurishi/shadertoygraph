{"ver":"0.1","info":{"id":"NdsyRr","date":"1641906327","viewed":44,"name":"BasicRT","username":"uwe_silver","description":"atomosphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rayleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\nconst float NAPIER = 2.71828;\n\nstruct Ray\n{\n    vec3 dir;\n    vec3 pos;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 target;\n    vec3 side;\n    vec3 up;\n    float targetDepth;\n};\n\nbool InterSectionSphere( in Sphere sphere, in Ray ray, out vec3 outP, out vec3 outN)\n{   \n\n\n    vec3  a = ray.pos - sphere.pos;\n    \n    \n    \n    float b = dot(ray.dir, a);\n    float c = dot(a, a);\n    float d = ( b * b - c + (sphere.r * sphere.r) );\n    \n    if(d > 0.0) \n    {\n        //hit\n        if(length(a) <= sphere.r)\n        {\n            //ray origin is inside of sphere\n            float t = -b + sqrt(d);\n            outP = ray.pos + t * ray.dir;\n            outN = normalize(outP - sphere.pos);\n            \n            return t > 0.;\n        }\n        \n        //ray origin is outside of sphere\n        float t = -b - sqrt(d);\n        outP = ray.pos + t * ray.dir;\n        outN = normalize(outP - sphere.pos);\n        \n        return t > 0.0;\n    }\n    \n    return false;\n}\n\nfloat h(in float s, in Ray ray, in Sphere earth)\n{\n    return length(normalize(ray.dir) * s + ray.pos - earth.pos) - earth.r;\n}\n\nfloat RayleighK (in float wavelength)\n{\n    return 1. / pow(wavelength, 4.) / 100000000000000000000000000000000000000. ;\n}\n\nfloat t(in vec3 Pa, in vec3 Pb, in Sphere earth, in float wavelength)\n{\n    Ray ray;\n    ray.pos = Pa;\n    ray.dir= Pb - Pa;\n    \n    float result = 0.;\n    \n    float sampleNum = 5.;\n    for(float i = 0.; i < sampleNum; i ++)\n    {\n        float len = length(ray.dir) / sampleNum * i;\n        float h = h( len, ray, earth );\n        result += 4. * PI * RayleighK(wavelength) * pow(NAPIER, h) * len;\n        \n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = ( -iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    \n    Camera cam;\n    cam.pos = vec3(10. * sin(iTime * .2), 3. + 6371. * 1000., 5. * cos(iTime * .2));\n    cam.target = vec3(0., 5. + 6371. * 1000., .1);\n    cam.dir = normalize(cam.target - cam.pos);\n    cam.side = cross(cam.dir, vec3(0., 1., 0.));\n    cam.up = cross(cam.side, cam.dir);\n    cam.targetDepth = 1.3;\n    \n    Ray ray;\n    ray.pos = cam.pos;\n    ray.dir = normalize(cam.side * px.x + cam.up * px.y + cam.dir * cam.targetDepth);\n    \n    Sphere sphere;\n    sphere.pos = vec3(0., 5. + 6371. * 1000., -0.);\n    //sphere.pos = cam.pos;\n    sphere.r = 1.;\n    sphere.col = vec3(1., 0., 0.);\n    \n    Sphere earth;\n    earth.pos = vec3(0.);\n    earth.col = vec3(1., 1., 0.);\n    earth.r = 6371. * 1000.;\n    \n    float AtomosphereHeight = 100. * 1000.;\n    \n    Sphere outer;\n    outer.pos = vec3(0.);\n    outer.r = earth.r + AtomosphereHeight;\n    \n    Sphere sun;\n    vec3 sundir = vec3(sin(iTime), cos(iTime), 0.);\n    sun.pos = sundir * pow( 10., 50.);\n    sun.r = pow(10. , 5.);\n    \n    vec3 col = vec3(0.);\n    vec3 hitN = vec3(0.);\n    vec3 hitPos = vec3(0.);\n    \n    float smplWidth = 100000.;\n    if(InterSectionSphere(outer, ray, hitPos, hitN))\n    {\n        float dist = length(hitPos - ray.pos);\n        \n        vec3 sunhitn;\n        vec3 sunhitp;\n        float brightness;\n        if(InterSectionSphere(sun, ray, sunhitp, sunhitn))\n        {\n            brightness = 1.;\n        }\n        else\n        {\n            brightness = dot(normalize(sundir) , normalize(ray.dir));\n            //brightness = 0.;\n        }\n        float R = brightness;\n        float G = brightness;\n        float B = brightness;\n        \n        float sum = 0.;\n        while(sum < dist)\n        {\n            /*\n            float minus = smplWidth * 4. * PI * pow( NAPIER, - h(sum, ray, earth) / AtomosphereHeight);\n            \n            \n            R -= RayleighK(700. * pow(10. , -9.)) * minus;\n            G -= RayleighK(500. * pow(10. , -9.)) * minus;\n            B -= RayleighK(450. * pow(10. , -9.)) * minus;\n            */\n            R -= t(ray.pos, hitPos, earth, 700. * pow(10. , -9.));\n            sum += smplWidth;\n        }\n        \n        //col = vec3(0., 0., 1. / (outer.r - earth.r) * dist / 10.);\n        //col = vec3(R, G, B);\n        col = vec3(R, 0., 0.);\n    }\n    \n    if(InterSectionSphere(earth, ray, hitPos, hitN))\n    {\n        col = earth.col;\n    }\n    if(InterSectionSphere(sphere, ray, hitPos, hitN))\n    {\n        col = sphere.col;\n    }\n    \n    if(InterSectionSphere(sun ,ray, hitPos, hitN)){\n    col = vec3(1., 1., 1.);}\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}