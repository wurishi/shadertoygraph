{"ver":"0.1","info":{"id":"tdXfD7","date":"1588359041","viewed":378,"name":"Preetham Skylight Model 1999","username":"pajunen","description":"A simple implementation of Preetham Skylight Model introduced in the paper \"A Practical Analytic Model for Daylight\" in 1999 by A.J Preetham, Peter Shirley and Brian Smits.\n\nMove the sun by dragging mouse.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sky","preetham"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of 1999 preetham skylight model\n\n#define T 2.3\n#define M_PI 3.1415926535897932384626433832795\n\n// Radiance distribution parameters\nfloat A_x = -0.0193 * T - 0.2592;\nfloat B_x = -0.0665 * T + 0.0008;\nfloat C_x = -0.0004 * T + 0.2125;\nfloat D_x = -0.0641 * T - 0.8989;\nfloat E_x = -0.0033 * T + 0.0452;\n\nfloat A_y = -0.0167 * T - 0.2608;\nfloat B_y = -0.0950 * T + 0.0092;\nfloat C_y = -0.0079 * T + 0.2102;\nfloat D_y = -0.0441 * T - 1.6537;\nfloat E_y = -0.0109 * T + 0.0529;\n\nfloat A_Y =  0.1787 * T - 1.4630;\nfloat B_Y = -0.3554 * T + 0.4275;\nfloat C_Y = -0.0227 * T + 5.3251;\nfloat D_Y =  0.1206 * T - 2.5771;\nfloat E_Y = -0.0670 * T + 0.3703;\n\n// Matrices for chromaticity calculations\nmat4x3 x_chromaticity = mat4x3(\n    0.0017, -0.0290, 0.1169,\n   -0.0037,  0.0638,-0.2120,\n    0.0021, -0.0320, 0.0605,\n    0.0000,  0.0039, 0.2589\n);\n\nmat4x3 y_chromaticity = mat4x3(\n    0.0028, -0.0421,  0.1535,\n   -0.0061,  0.0897, -0.2676,\n    0.0032, -0.0415,  0.0667,\n    0.0000,  0.0052,  0.2669\n);\n\nfloat angle(float z1, float a1, float z2, float a2) {\n\treturn acos(\n        sin(z1) * cos(a1) * sin(z2) * cos(a2) +\n        sin(z1) * sin(a1) * sin(z2) * sin(a2) +\n        cos(z1) * cos(z2));\n}\n\nfloat zenith_chromaticity(float sun_z, mat4x3 coefficients) {\n    vec3 T_vec = vec3(T * T, T, 1);\n    vec4 Z_vec = vec4(sun_z*sun_z*sun_z, sun_z*sun_z, sun_z, 1.0);\n    return dot(T_vec, coefficients * Z_vec);\n}\n\nfloat zenith_luminance(float sun_z) {\n \tfloat chi = (4.0 / 9.0 - T / 120.0) * (M_PI - 2.0 * sun_z);\n    return (4.0453 * T - 4.9710) * tan(chi) - 0.2155 * T + 2.4192;\n}\n\nfloat F(float theta, float gamma, float A, float B, float C, float D, float E) {\n\treturn (1.0 + A * exp(B / cos(theta))) * (1.0 + C * exp(D * gamma) + E * pow(cos(gamma), 2.0));\n}\n\n// CIE-xyY to CIE-XYZ\nvec3 xyY_to_XYZ(float x, float y, float Y) {\n\treturn vec3(x * Y / y, Y, (1.0 - x - y) * Y / y);\n}\n\n// CIE-XYZ to linear RGB\nvec3 XYZ_to_RGB(vec3 XYZ) {\n    mat3 XYZ_to_linear = mat3(\n  \t\t 3.24096994, -0.96924364, 0.55630080,\n        -1.53738318,  1.8759675, -0.20397696,\n        -0.49861076,  0.04155506, 1.05697151\n    );\n    return XYZ_to_linear * XYZ;\n}\n\n// CIE-xyY to RGB\nvec3 xyY_to_RGB(float x, float y, float Y) {\n \tvec3 XYZ = xyY_to_XYZ(x, y, Y);\n   \tvec3 sRGB = XYZ_to_RGB(XYZ);\n    return sRGB;\n}\n\n// Clamps color between 0 and 1 smoothly\nvec3 expose(vec3 color, float exposure) {\n    return vec3(2.0) / (vec3(1.0) + exp(-exposure * color)) - vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv    = (fragCoord -0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy -0.5 * iResolution.xy) / iResolution.y;\n    \n    float mouse_angle = atan(mouse.x, mouse.y);\n    float mouse_distance = clamp(length(mouse) * M_PI, 0.0, M_PI / 2.0);\n    \n    float pixel_angle = atan(uv.x,uv.y);\n    float pixel_distance =  length(uv) * M_PI;\n    \n    if (pixel_distance > M_PI / 2.0) {\n    \tfragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    float sun_zenith = mouse_distance;\n    float sun_azimuth = mouse_angle;\n    \n    float zenith = pixel_distance;\n    float azimuth = pixel_angle;\n    \n    float gamma = angle(zenith, azimuth, sun_zenith, sun_azimuth);\n    float theta = zenith;\n    \n    float x_z = zenith_chromaticity(sun_zenith, x_chromaticity);\n    float y_z = zenith_chromaticity(sun_zenith, y_chromaticity);\n    float Y_z = zenith_luminance(sun_zenith);\n    \n    float x = x_z * F(theta, gamma, A_x, B_x, C_x, D_x, E_x) / F(0.0, sun_zenith, A_x, B_x, C_x, D_x, E_x);\n    float y = y_z * F(theta, gamma, A_y, B_y, C_y, D_y, E_y) / F(0.0, sun_zenith, A_y, B_y, C_y, D_y, E_y);\n  \tfloat Y = Y_z * F(theta, gamma, A_Y, B_Y, C_Y, D_Y, E_Y) / F(0.0, sun_zenith, A_Y, B_Y, C_Y, D_Y, E_Y);\n\n    vec3 col = expose(xyY_to_RGB(x, y, Y), 0.1);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}