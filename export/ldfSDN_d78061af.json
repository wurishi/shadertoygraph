{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Sort of a cross between https://www.shadertoy.com/view/MdXSD8 and\n//https://www.shadertoy.com/view/4dfSD4\n\n#define M_PI 3.1415926535\n#define ambientAmount 0.5\n#define specularAmount 0.5\n#define refractionIn 0.2\n#define refractionOut 1.0\n#define shininess 300.0\n\n//Light setup\nvec3 light = vec3(5.0, 5.0, 20.0);\n\n//Object setup\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0);\n//Functions \n\nvec2 iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t//sphere at origin has equation |xyz| = r\n\t//sp |xyz|^2 = r^2.\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tvec2 t;\n\tif(h < 0.0) \n\t\tt = vec2(-1.0);\n\telse  {\n\t\tfloat sqrtH = sqrt(h);\n\t\tt.x = (-b - sqrtH); //Again a = 1.\n\t\tt.y = (-b + sqrtH);\n\t}\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph )\n{\n\treturn (pos - sph.xyz)/sph.w;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec2 resT)\n{\n\tresT = vec2(1000.0);\n\tfloat id = -1.0;\n\tvec2 tsph = iSphere(ro, rd, sph1); //Intersect with a sphere.\n\t\n\tif(tsph.x > 0.0 || tsph.y > 0.0)\n\t{\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\treturn id;\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec4 getFragColor(float noiseValue) {\n\tvec4 fragColor;\n\tfragColor.r = fract(noiseValue);\n\tfragColor.g = fract(2. * fragColor.r);\n\tfragColor.b = fract(3. * fragColor.g);\n\tfragColor.a = 1.0;\n\treturn fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//generate a ray with origin ro and direction rd\n\tvec4 ro = vec4(0.0, 0.0, 1.5, 1.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0));\n\t\n\t//intersect the ray with scene\n\tvec2 t;\n\tfloat id = intersect(ro.xyz, rd, t);\n\t\n\tvec3 col;\n\t//If we hit the sphere...\n\tif(id > 0.5 && id < 1.5)\n\t{\n\t\t//1) do Schlick approx of Fresnel lighting\n\t\tvec3 E = normalize(ro.xyz + t.x*rd);\n\t\tvec3 N = normalize(nSphere(E, sph1));\n\t\tvec3 L = normalize(light);\n\t\t\n\t\tvec3 reflectColor = vec3(ambientAmount);\n\t\tfloat lambertTerm = dot(N, L);\n\t\tif (lambertTerm > 0.0) {\n\t\t\tfloat w = pow(1.0 - max(0.0, dot(normalize(L+E), E)), 5.0);\n\t\t\t\n\t\t\treflectColor += (1.0-w)*pow(max(0.0, dot(reflect(-L, E), E)), shininess);\n\t\t}\n\t\t\n\t\t//2) do Fresnel refraction to look up the appropriate Perlin noise color\n\t\t//light goes in\n\t\tvec3 refractionVec = refract(rd, N, refractionIn);\n\t\t\n\t\t//light comes out\n\t\tfloat id2 = intersect(E, refractionVec, t);\n\t\tif (id2 > 0.5 && id2 < 1.5) {\n\t\t\tE += refractionVec * t.y;\n\t\t\tE = normalize(E);\n\t\t\tN = normalize(nSphere(E, sph1));\n\t\t\trefractionVec = refract(refractionVec, N, refractionOut);\n\t\t}\n\t\t\n\t\tvec3 noiseColor = getFragColor(cnoise(vec2(iTime + refractionVec.x + uv.x, refractionVec.y + uv.y))).rgb;\n\t\tcol = mix(noiseColor, reflectColor, reflectColor);\n\t}\n\telse\n\t\tcol = getFragColor(cnoise(vec2(iTime + uv.x, uv.y))).rgb;\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldfSDN","date":"1401154784","viewed":2011,"name":"Magnifying Lens","username":"slade","description":"A shiny (spherical) lens which is magnifying a moving backdrop of Perlin noise.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["noise","refraction","lens","perlin","fresnel","magnifying"],"hasliked":0,"parentid":"","parentname":""}}