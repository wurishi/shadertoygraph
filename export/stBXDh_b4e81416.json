{"ver":"0.1","info":{"id":"stBXDh","date":"1627570157","viewed":94,"name":"Wavy polka dot background","username":"Yeguarr","description":"Wavy polka dot background for my game.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["background"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on https://www.shadertoy.com/view/Xltfzj Gaussian Blur\n\nconst float Pi = 6.28318530718; // Pi*2\nconst float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\nconst float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\nconst float Size = 8.0; // BLUR SIZE (Radius)\n    \nvec4 Gauss(in vec4 color,in vec2 uv, in vec2 Radius) {\n\n    vec4 blur = color;\n    \n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n            blur += texture(iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\n        }\n    }\n    return blur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 Radius = vec2(Size)/iResolution.xy*cos(uv.x*Pi/2.0);\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    // Blur calculations\n    Color = Gauss(Color, uv, Radius);\n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    fragColor =  Color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on thebookofshaders.com content. \n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(65.235,12.3485)))*8023.32421);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 3\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    st.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 100.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.0;  // minimum distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n            vec2 point = vec2(0.5,0.5);\n            \n            float m = sin(fbm((i_st +neighbor+point)/400.0+iTime/60.0)*80.0);\n            //m = max(m,smoothstep(0.9,1.0, sin(uv.x*3.1415+fbm(uv+iTime/5.0)))*(fbm(iTime/5.0+uv*2.0)));\n\t\t\t// Animate the point\n            //point.x += m*cos(iTime/60.0);\n            //point.y += m*sin(iTime/60.0);\n            point+=m;\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff)*5.*(0.75+m/5.0);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist*(0.6+sin(uv.x*3.141592)/2.));\n        }\n    }\n    \n    //vec3 color1 = vec3(0.97255, 0.28235, 0.36863);\n    //vec3 color1 = vec3(1.0, 1.0, 1.0);\n    //vec3 color2 = vec3(0.20392, 0.22745, 0.25098)/5.;\n    \n    // Draw the min distance (distance field)\n    color += (1.0-m_dist)*2.;\n    color *= 1.0-sin(uv.x*3.141592)*.2;\n    //color = max(vec3(1.0-sin(uv.x*2.)*.2),color);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}