{"ver":"0.1","info":{"id":"WlcyDs","date":"1610139699","viewed":57,"name":"Genuary2021 8 - Curve Only","username":"qw","description":"Entry for Day 8 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: Curve Only\n\nKinda just went crazy with Fractal Brown Motion waves to add noise ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","wave","curve","sinewave","genuary2021","genuary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define PI2 6.2830\n\nfloat Draw(vec2 uv, float rad){\n\n    float thick = .01;\n    float l = length(uv) - abs(rad);\n    return smoothstep( l*0.9,l, thick) ;\n}\n\nfloat Wave(float size, float frequency, float progress){\n\n    return size * ( (sin((progress*PI2)*frequency)+ 1. ) * .5 );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;\n\n    vec3 col = vec3(0);\n    float angle = atan(uv.y,uv.x);\n    float progress = (angle+PI)/(PI2); // 0-1 scale around circle\n    float rotationSpeed = 0.1;\n    float size = .15;\n    float freq = 1.;\n    //Fractal Brownian Motion...? I think\n    float noise = Wave(size*.5, freq, progress  + mod(iTime * rotationSpeed,1.));\n    noise += Wave(size*.4, freq * 4., progress  + mod(-iTime * rotationSpeed,1.));\n    noise += Wave(size*.3, freq * 11., progress + mod(iTime * 1.8 * rotationSpeed,1.));\n    noise += Wave(size*.15, freq * 20., progress + mod(-iTime * .8 * rotationSpeed,1.));\n    noise += Wave(size*.3, freq , progress + mod(-iTime * .8 * rotationSpeed,1.));\n    \n    float radius = 0.15 + noise;\n    \n    //... Meh!\n    col.xyz += vec3(1) * Draw(uv, radius*4.8);\n    col.xyz += vec3(1) * Draw(uv, radius*4.4);\n    col.xyz += vec3(1) * Draw(uv, radius*4.0);\n    col.xyz += vec3(1) * Draw(uv, radius*3.6);\n    col.xyz += vec3(1) * Draw(uv*0.34, radius*3.4);\n    col.xyz += vec3(1) * Draw(uv, radius*3.2);\n    col.xyz += vec3(1) * Draw(uv, radius*3.0);\n    col.xyz += vec3(1) * Draw(uv, radius*2.6);\n    col.xyz += vec3(1) * Draw(uv, radius*2.4);\n    col.xyz += vec3(1) * Draw(uv*uv.y, radius*2.0);\n    col.xyz += vec3(1) * Draw(uv, radius*1.8);\n    col.xyz += vec3(1) * Draw(uv*uv.x*2., radius*1.4);\n    col.xyz += vec3(1) * Draw(uv, radius*1.2);\n    col.xyz += vec3(1) * Draw(uv*uv.x, radius);\n    col.xyz += vec3(1) * Draw(uv, radius*0.9);\n    col.xyz += vec3(1) * Draw(uv*uv.x*2., radius*0.8);\n    col.xyz += vec3(1) * Draw(uv, radius*0.6);\n    col.xyz += vec3(1) * Draw(uv*1.3, radius*5.5*uv.x);\n    col.xyz += vec3(1) * Draw( uv * (cos(uv.x)+1.), radius*0.7);\n    col.xyz += vec3(1) * Draw(uv, radius*0.15);\n    col= clamp(col,0.,1.);\n    \n    //why not use some\n    vec3 col1 = vec3(.8,.5,1.7+sin(iTime));\n    vec3 col2 = vec3(0.5+sin(iTime),.9,.8);\n    col = mix( col1, col2, col.r);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}