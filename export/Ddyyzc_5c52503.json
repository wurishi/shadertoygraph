{"ver":"0.1","info":{"id":"Ddyyzc","date":"1696507323","viewed":109,"name":"2.16 Million Stars Skysphere","username":"sdfgeoff","description":"An interesting thing about stars is that the light from this is parallel because they are so far away. This means that if you zoom in on them ... they stay the same angular size. This makes it hard to generate skyboxes of stars where the camera can zoom.","likes":19,"published":1,"flags":0,"usePreview":1,"tags":["basic","sky"],"hasliked":0,"parentid":"msyyzV","parentname":"Zoomable Stars Skysphere"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\nCLICK AND DRAG TO LOOK AT ANOTHER PART OF THE SKY\n\nI'm building a semi-realistic space game and discovered that a skybox looks terrible\nwhen you are using a telescope with a lens angle of 1 degree. Why? Well, stars are\nreally really far away and the light is parallel. This means that (almost) no matter \nhow far you zoom in on them ... they stay the same angular size.\nThis means that any sort of normal skybox falls apart when you zoom because ... the\nstars will get bigger (or when you zoom out the stars will alias).\n\nMy aims are:\n - Render a sky full of stars\n - Handle dynamic zooming - stars should stay small as you zoom\n - Have enough stars that at high zoom levels (ie a telescope) it is still\n   interesting enough.\n - Flicker free when moving the viewport (ie no obvious aliasing)\n - Artistic control (\"paint stars here\")\n\n\nThere are two interesting effects I noticed:\n - As you zoom out you see more stars at the same brightness, so the scene\n   gets visually lighter. This is the opposite to \"normal\" where a bright object\n   occupies more of the scene as you zoom in. I correct for this by tweaking\n   the camera's exposure which has the nice property of seeing\n   more stars as you zoom in. \n   The same applies to higher resolution screens. A higher resolution screen\n   has more pixels with fewer lit.\n - Mostly you don't have to worry about the stars aliasing as they stay the same size\n   on screen.\n \nPlacing stars randomly on a sphere is somewhat hard. This is my second attempt, and I divide\nup the world into a using a cubmap (distorting it to keep more equal areas).\nThis is then divided into cells and a star placed in each cell. Rather than voroni the\ncells I went for multiple layers - It doesn't require that many more calculations to do a full\nstar render vs sampling a bunch of cells, so why not render 8 times more stars rather\nthan doing 8 voroni samples?\n\nHow many stars are there in this scene? If you disable the density map there are:\n200 * 200 * 6 * 9 = 2,160,000\n\nThere is definitely still room to improve this:\n - if you disable the density map you can see regular lines in certain places in the\n   skybox. I think this is due to limiting how far each cell can offset the star, and\n   that all the cells are about the same size.\n - MOR STARZ. I want clouds of them. Ther eare 100 billion stars in the milky way.\n   I'm still an order of magnitude off them in terms of count, and probably even\n   more so in terms of density in some areas of the sky.\n   One possible solution here is that zooming in could inveil another layer of stars\n   with a much higher cell count (this would cause aliasing if visible when zoomed out).\n   If a layer can be done at 1000 cells, this is the same as a couple billion stars\n   on a single layer\n - It may be worth revising voroni. \n - Can the number of density map samples be reduced?\n\n\n\nI also tried dual paraboloid maps as a star placement, but when looking at the UV coords,\nI think it would have a fairly obvious seam.\n - sdfgeoff\n*/\n\nconst float PI = 3.14159;\n\nconst float MAJOR_LINES = 6.0;\nconst float MAJOR_LINE_WIDTH = MAJOR_LINES * 0.002;\nconst float MINOR_LINES = MAJOR_LINES * 5.0;\nconst float MINOR_LINE_WIDTH = MINOR_LINES * 0.001;\nconst float MAJOR_LINE_INTENSITY = 0.2;\nconst float MINOR_LINE_INTENSITY = 0.1;\n\n// How large should a star be?\nconst float STAR_RADIUS = 10.0;\n\n// Higher = fewer bright stars\nconst float STAR_GAMMA = 20.0;\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n\nfloat sphere_lines(float angle, float elevation) {\n    float lines = 0.0;\n    lines += clamp((abs(fract(elevation / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) /  MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MAJOR_LINES) - 0.5) * 2.0 - 1.0 + MAJOR_LINE_WIDTH) / MAJOR_LINE_WIDTH, 0.0, 1.0) * MAJOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(elevation / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) /  MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    lines += clamp((abs(fract(angle / PI * MINOR_LINES) - 0.5) * 2.0 - 1.0 + MINOR_LINE_WIDTH) / MINOR_LINE_WIDTH, 0.0, 1.0) * MINOR_LINE_INTENSITY;\n    return lines;\n}\n\n\n\n\n// Converts from a 3D direction vector into a 2D UV map with equal(ish) area\n// The UV is not constrained to the 0-1 range\nvec2 to_cells(vec3 rayDirection) {\n\n\n    // Cubemap\n    vec3 norm = normalize(rayDirection);\n    vec3 absnorm = abs(norm);\n\n    vec2 uv = vec2(0,0);\n    float face = 0.0;\n    if (absnorm.x / absnorm.z < 1.0 && absnorm.y / absnorm.z < 1.0) {\n        uv = norm.xy / absnorm.z;\n        face = step(0.0, norm.z);\n    }\n    if (absnorm.x / absnorm.y < 1.0 && absnorm.z / absnorm.y < 1.0) {\n        uv = norm.xz / absnorm.y;\n        face = step(0.0, norm.y) + 2.0;\n    }\n    if (absnorm.y / absnorm.x < 1.0 && absnorm.z / absnorm.x < 1.0) {\n        uv = norm.yz / absnorm.x;\n        face = step(0.0, norm.x) + 4.0;\n    }\n    \n    // Inflate the cube to reduce distortion due to corners.\n    // I kinda stubled over this one experimentally, no idea if it has a name, but\n    // it works quite well at making the cells closer to equal area.\n    // It's probably got a name.\n    float d_edge = 2.0 - max(abs(uv.x), abs(uv.y));\n    uv *= sqrt(d_edge);\n    \n    return uv * 0.5 + 0.5 + vec2(face, 0.0); \n}\n\n\nvec3 stars(vec2 uv, float lens, float seed, float numCells) {\n    vec2 rawCells = uv * numCells;\n    vec2 cellId = floor(rawCells);\n    \n    float starDensity = pow(textureLod(iChannel0, cellId / numCells, 0.0).r + 0.2, 4.0);\n    vec2 innerCoords = fract(rawCells);\n\n    vec3 offsets = hash33(vec3(cellId, seed));\n    innerCoords += (offsets.xy - 0.5) * 0.5;\n    innerCoords = abs(innerCoords - 0.5) * 2.0;\n    \n    vec4 data = vec4(\n        length(innerCoords),\n        offsets\n    );\n    float dist = data.x * iResolution.y;\n    float radius = max(1.0 - dist / (numCells * lens * STAR_RADIUS), 0.0);\n    float intensity = pow(radius, 4.0); // Falloff - bright in center\n    intensity *= pow(data.y, STAR_GAMMA); // more dim stars than bright ones\n    intensity *= step(data.w, starDensity);\n    \n    return intensity * mix(\n        vec3(0.8, 0.5, 0.4),\n        vec3(0.7, 0.6, 0.8),\n        pow(data.z, 2.0) // more red stars than blue ones\n    ) * 4.0; \n}\n\n\n\nvec3 world_background(vec3 rayDirection, float lens) {\n    vec3 col = vec3(0.0);\n    vec2 cells = to_cells(rayDirection);\n    col += stars(cells, lens, 1.0, 200.0) * 4.0;\n    col += stars(cells, lens, 2.0, 199.0) * 0.8;\n    col += stars(cells, lens, 3.0, 198.0) * 0.7;\n    col += stars(cells, lens, 4.0, 197.0) * 0.6;\n    col += stars(cells, lens, 5.0, 196.0) * 0.5;\n    col += stars(cells, lens, 6.0, 201.0) * 0.4;\n    col += stars(cells, lens, 7.0, 202.0) * 0.3;\n    col += stars(cells, lens, 8.0, 203.0) * 0.2;\n    col += stars(cells, lens, 9.0, 190.0);\n    \n    \n    // Increase Exposure as zoom in\n    col *= (0.3 / lens);\n\n    float r2 = dot(rayDirection.xy, rayDirection.xy);\n    float elevation = acos(rayDirection.z / sqrt(r2 + rayDirection.z * rayDirection.z));\n    float angle = atan(rayDirection.y, rayDirection.x);\n    \n    float lines = sphere_lines(angle, elevation);\n\n    return col + lines;\n}\n\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n\tfloat hA = angle * 0.5;\n\tfloat s = sin(hA);\n\tfloat c = cos(hA);\n\treturn vec4(axis*s, c);\n}\n\nvec4 QuatMul(vec4 q, vec4 r)\n{\n\tvec4 nq;\n\tnq.x = q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y;\n\tnq.y = q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x;\n\tnq.z = q.w * r.z + q.z * r.w - q.y * r.x + q.x * r.y;\n\tnq.w = q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z;\n\treturn nq;\n}\n\nmat4 QuatToMat(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat4(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),0.,2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),0.,2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy),0.,0.,0.,0.,1.);\n}\n\nmat3 QuatToMat3(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat3(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy));\n}\n\nmat4 createCameraRotationMatrix(vec2 vSUV)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 0., 1.), vSUV.x);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), vSUV.y);\n\treturn QuatToMat(QuatMul(u,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Render our geometry\n    vec2 vSphericalUV = (iMouse.xy / iResolution.xy) * 4.0;\n    vSphericalUV.y = clamp(vSphericalUV.y,0.,PI);              //Clamp to avoid upside down camera.\n    mat4 camera_transform = createCameraRotationMatrix(vSphericalUV);\n    \n    vec3 start_point = camera_transform[3].xyz;\n    \n    float LENS = sin(iTime) * 0.3 + 0.305;\n\n    vec3 direction = normalize(vec3(uv * LENS, 1.0));\n    direction = (camera_transform * vec4(direction, 0.0)).xyz;\n\n    // Output to screen\n    fragColor = vec4(world_background(direction, LENS),1.0);\n}","name":"Image","description":"","type":"image"}]}