{"ver":"0.1","info":{"id":"WdXBz2","date":"1706892524","viewed":67,"name":"Glitching Cube and Canvas","username":"mathieu_h","description":"abstract, cube, ray marching, noise, gltich","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","retro","cube","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 10.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nfloat wav(float x)\n{\n    float mod_polynomial = 4.0*pow(mod(x,1.0),3.0) - 6.0*pow(mod(x,1.0),2.0) + 1.0;\n    float mod_symetry = sign(abs(mod(x,2.0)-floor(mod(x,1.0))-2.0)-1.0);\n    \n    return mod_polynomial * mod_symetry;\n}\n\n\nfloat cubeSDF(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n\nfloat customSDF(vec3 p)\n{\n    float t = iTime;\n    float d = 1.00;    \n    float thr = 0.1;\n    \n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    \n    float sphere, noise;\n    float draw;\n    \n    \n    //TileDistortion\n    x = floor(x * d)/d;    \n    y = floor(y * d)/d*2.;\n    z = floor(z * d)/d;    \n \n    \n    float radius = wav(iTime);\n\n    noise = sqrt(pow(x - floor(sin(x*iTime)* thr)/thr,2.0)+pow(y,2.0)+pow(z,2.0)) - 1.0;\n    sphere = sqrt(pow(x + 0.1,2.0)+pow(y,2.0)+pow(z,2.0)) - 0.2;\n    \n    \n    draw = 0.0;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        float dt = (float(i)/31.0);\n        vec3 offset = vec3(wav(dt),wav(dt+0.5),0.0);\n        \n            x = cos(t) * x - sin(t) * y;\n    \t\ty = sin(t) * x + cos(t) * y;\n    \t\tz = z;\n        \n        draw = (draw,cubeSDF(p + radius * vec3(x,y,z)));\n    }\n    \n    return draw ;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    return customSDF(samplePoint);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) \n    {        \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) \n    {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) \n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    \n    vec3 color = ambientLight * k_a; \n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime), 2.0, 4.0 * cos(iTime));    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime), 2.0 * cos(0.37 * iTime), 2.0);\n    \n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    \n    color += floor(phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity)*10.0)/10.0;    \n    return color;\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nfloat randomize(float x, vec2 uv)\n{\n    return  fract(sin(uv.x * .9)+ uv.y*iTime*.1);\n}\n\n\nbool rect(float x, float y, float w, float h, vec2 uv)\n{\n    bool hor = uv.x - (x - 0.5 * w) > 0.0 && uv.x - (x + 0.5 * w) < 0.0;\n    bool ver = uv.y - (y - 0.5 * h) > 0.0 && uv.y - (y + 0.5 * h) < 0.0;\n\treturn ver && hor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    bool boxA = rect(0.5,0.5, 0.5,0.1, vec2(mod(uv.x*10.0, 1.0),mod(uv.y * 10.0, 1.0)));\n\n    \n    float k = 1.0;\n    float fk = 4.;\n    bool pattern = true;\n    for(int i = 0; i < 3; i++)\n    {\n        k *= fk;\n        pattern = pattern && sign(sin(uv.x * k) + sin(uv.y * k)) > 0.0;\n    }\n    \n    \n    if(pattern)\n    {\n        fragCoord += vec2(0.05)* iResolution.xy * 0.5 * (sin(iTime * 0.5) + 1.0); \n        \n        //fragColor = vec4(0.8,0.8,0.8,1.0);\n        //return;\n    }\n    \n    \n    \n    float noise = randomize(wav(iTime * 0.01), fragCoord);\n    vec2 noiseFilter = floor(fragCoord *noise)/noise;\n    vec2 image = floor(noiseFilter*100.10)/100.0;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy * 0.2, image - iResolution.xy * 0.5);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n\n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.8, 0.7, 0.9);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;   \n    \n    \n    \n    vec3 color = vec3(0.3) * (uv.y + 1.0)*0.5 + fract(phongIllumination(K_a, K_d, K_s, shininess, p, eye)*6.0);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}