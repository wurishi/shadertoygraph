{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t{\n    vec3 origin;\n    float radius;   \n};\n\nstruct ray_t{\n    vec3 origin;\n    vec3 direction;   \n};\n\t\n\nstruct plane_t{\n    vec3 normal;\n\tvec3 orientation;\n    float offset;   \n};\n\t\nstruct light_t{\n\tvec3 direction;\n\tfloat contribution;\t\n};\n\nstruct surface_t{\n\tint identifier;\n\tvec3 position;\n\tvec3 normal;\t\n};\n\t\nstruct material_t{\n\tvec3  color;\n\tfloat roughness;\n};\n\t\nconst int NONE   = 0;\nconst int PLANE  = 1;\nconst int SPHERE = 2;\n\t\nconst float PI = 3.14;\nconst float max_distance = 1e5;\n\n\nfloat intersect_sphere(const in ray_t ray,const in sphere_t sphere, out surface_t surface){\n   \n    float a = (ray.direction.x * ray.direction.x)\n            +(ray.direction.y * ray.direction.y)\n            +(ray.direction.z* ray.direction.z);\n   \n    float b = ((ray.origin.x-sphere.origin.x)*ray.direction.x)\n            +((ray.origin.y-sphere.origin.y)*ray.direction.y)\n            +((ray.origin.z-sphere.origin.z)*ray.direction.z);\n   \n    b *= 2.0;\n\n    float c = ((ray.origin.x-sphere.origin.x) * (ray.origin.x-sphere.origin.x))\n            +((ray.origin.y-sphere.origin.y) * (ray.origin.y-sphere.origin.y))\n            +((ray.origin.z-sphere.origin.z) * (ray.origin.z-sphere.origin.z)) - (sphere.radius*sphere.radius);\n   \n    float delta = b*b - (4.0*a*c);\n   \tif(delta < 0.0) return max_distance;\n\t\t\n\tfloat dist = (- b + sqrt( delta )) / ( 2.0 * a );\n\tfloat dist2 = (- b - sqrt( delta )) / ( 2.0 * a );\n\t\n\tif(dist > dist2) surface.position = ray.origin + dist2 * ray.direction;\n\telse surface.position = ray.origin + dist * ray.direction;\n\tsurface.normal = normalize( (surface.position - sphere.origin) / sphere.radius );\n\tsurface.identifier = SPHERE;\n\t\n\treturn min(dist,dist2);\n}\n\nfloat intersect_plane(const in ray_t ray,const in plane_t plane, out surface_t surface){\t\n\tfloat a = plane.normal.x;\n\tfloat b = plane.normal.y;\n\tfloat c = plane.normal.z;\n    float distance_from_origin = -(plane.offset +\n\t\t\t\t\t a * ray.origin.x + \n\t\t\t\t\t b * ray.origin.y + \n\t\t\t\t\t c * ray.origin.z) / (a * ray.direction. x + b * ray.direction.y + c * ray.direction.z);\n    \n\tsurface.position = ray.origin + ray.direction * distance_from_origin;\n\tsurface.normal = plane.normal;\n\tsurface.identifier = PLANE;\n\t\n\treturn distance_from_origin > 0.0 ? distance_from_origin : max_distance;\t   \n}\n\nfloat intersect(const in ray_t ray, out surface_t surface, out material_t material, const in int avoid ){\n\t\n\tmaterial.color = vec3( 0.0, 1.0, 0.0 );\n\tmaterial.roughness = 0.0;\n\t\n\tsphere_t sphere;\n    sphere.origin = vec3( mix(-8.0, 8.0, 0.5 + 0.5 * sin(iTime)), mix(-5.0, 4.0, 0.5 + 0.5 * cos(iTime)), -5.0);\n    sphere.radius = 1.0;  \n\t\n\tplane_t plane;\n\tplane.normal =vec3(0.0, 0.9, 0.04);\n\tplane.offset= 0.1;\n\t\n\tsurface_t surface_sphere;\n\tsurface_t surface_plane;\n\t\n\tfloat distance_from_sphere = intersect_sphere(ray, sphere, surface_sphere);\n\tfloat distance_from_plane = intersect_plane(ray, plane, surface_plane);\n\t\t\n\tif( ( distance_from_sphere < distance_from_plane ) && ( avoid != SPHERE ) ){\n\t\tsurface = surface_sphere;\n\t}\n\telse if(( distance_from_plane < max_distance ) && ( avoid != PLANE )){\n\t\tsurface = surface_plane;\n\t}\n\telse{\n\t\tsurface.identifier = NONE;\n\t\tsurface.position = vec3(0.0);\n\t\tsurface.normal = vec3(0.0);\n\t}\t \n\treturn min( distance_from_sphere, distance_from_plane );\n\t\t\n}\n\nvoid light_information(out light_t light){\n\tlight.direction = vec3(2.0,1.0, 0.0);\n\tlight.contribution = 1.0;\t\n}\n\nfloat illumination(ray_t ray, const in surface_t surface, const in light_t light){\n\tfloat diffuse = max(0.0, dot(surface.normal, light.direction));\n\tvec3 reflected =normalize(reflect(ray.direction, surface.normal));\n\tfloat specular = max(0.0, dot(reflected,surface.normal)); \n\treturn\tdiffuse*light.contribution + pow(specular, 0.9);\n}\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coordinate = fragCoord.xy /iResolution.xy;\n    vec2 screen_coordinate_centered = 2.0 * screen_coordinate -1.0;\n\t\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tvec2  screen_coordinate_cor = vec2(aspect_ratio, 1.0) * screen_coordinate_centered;\n   \n    ray_t primary_ray;\n    primary_ray.origin = vec3(0.0, 0.0, 3.0);\n    primary_ray.direction = normalize(vec3(screen_coordinate_cor,-1.5));\n   \n   \n    surface_t surface;\n\tmaterial_t material;\n    float distance_from_origin = intersect(primary_ray, surface, material, NONE);\n   \t\n\tconst vec3 background_color = vec3( 0.0, 0.8, 0.8 );\n\tif( ( distance_from_origin < max_distance ) && surface.identifier != NONE )\n\t{\n\t\tlight_t light;\n\t\tlight_information(light);\n\t\tfloat res =  illumination(primary_ray, surface, light);\n\t\t\n        vec3 illumination_from_light =vec3( 0.5*res, res, 0.5*res );\n\t\tfragColor = vec4(illumination_from_light, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( vec3( background_color ), 1.0 );\n\t}\n   //*/\n       \n       \n       \n   \n    //fragColor = vec4( abs(primary_ray.direction),1.0);\n   \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2Gzc","date":"1391985562","viewed":738,"name":"soleil vert","username":"bobpool","description":"soleil vert","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["soleilvert"],"hasliked":0,"parentid":"","parentname":""}}