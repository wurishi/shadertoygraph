{"ver":"0.1","info":{"id":"MsG3Dh","date":"1454199265","viewed":818,"name":"Feedback World","username":"stb","description":"Video feedback fractals, in the form of a navigable landscape.\nControls:\n  mouse: drag & hold to move about\n  spacebar: clear buffer","likes":41,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractals","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\tFeedback World\n\t2016 stb\n\n\tSettings in Buf A.\n\n\tIf grid lines appear, there's a line in Buf A, \"uv = floor((uv+.001)*res)/res;\", that\n\tyou can try uncommenting. Tell me if it works!\n\n\tAlso, for better quality I enabled linear filtering for iChannel0 in Buf A. Let\tme\n\tknow if it breaks the controls.\n*/\n\nfloat s, c;\n#define rotateTo(p, v) mat2(c=v.y, s=v.x, -s, c) * p\n\nfloat line(in vec2 p, vec2 p0, vec2 p1, float thk) {\n    p -= p0;\n    p = rotateTo(p, normalize(p1-p0));\n    return float(p.y<0. || p.y>length(p1-p0) ? 0. : max(0., 1.-length(p.x)/thk));\n}\n\n#define dataAt(x) texture(iChannel0, vec2(float(x)+.5, .5)/res).a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 p = fragCoord / res.y;\n    \n    vec2 scrollPos = vec2(dataAt(0), dataAt(1)) / res;\n    vec2 mPosOld   = vec2(dataAt(2), dataAt(3));\n    float mIsHeld  = dataAt(4);\n    \n    // line\n    float l = 0.;\n    if(mIsHeld>0.)\n        l = line(p, mPosOld/res.y, iMouse.xy/res.y, 2./res.x);\n    \n    vec3 RGB = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(RGB+l, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float ScrollSpeed  = 0.025; // scrolling sensitivity\nconst float ScrollDrift  = 16.0;  // amount of coasting after mouse is released\nconst float GridScale    = 0.5;   // size of grid (not really a zoom param)\nconst float ScaleBase    = 1.0;   // base scale for each cell\nconst float ScaleAdd     = 3.0;   // amount of added random scaling for each cell\nconst float Darkness     = 0.5;  // amount subtracted from random colors\nconst float Hardness     = .5;   // sort of like contrast\n\nconst float KEY_SPACE = 32.5 / 256.;\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\n#define dataAt(x) texture(iChannel0, vec2(float(x)+.5, .5)/res).a\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * MOD4);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n// UVs with randomized rotation, scaling & translation, within discrete cells\nvec2 rndCell(in vec2 p, vec2 o, vec2 res) {\n    vec4 rnd4 = hash42(floor(p+o));\n    \n    p = fract(p) - o;\n    \n    //p -= .5;\n    \n    //p /= dot(p, p);\n    \n    // random rotation\n    p = rotate(p, 6.2831853*rnd4.x);\n    \n    // random scaling\n    p /= (ScaleBase+ScaleAdd*rnd4.y)*vec2(res.x/res.y, 1.) / GridScale / 4.;\n    \n    // flip x or not\n    if(fract(3.141592*rnd4.z)<.5) p.x = -p.x;\n    \n    // centering\n    p += .5;\n    \n    // random translation\n    //p += rnd4.zw;\n    \n    // result is repeated and mirrored @ edges\n    return abs(fract(p/2.-.0)*2.-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 res = iResolution.xy;\n    vec2 uv  = fragCoord / res;\n    \n    vec2 scrollPos, mPosOld;\n    float mIsHeld;\n    \n    vec3 RGB;\n    float A;\n    \n    // initial state\n    if(iFrame==0) {\n        scrollPos = vec2(0.);\n        mIsHeld   = 0.;\n        mPosOld   = iMouse.xy;\n    }\n    // running state\n    else {\n        // get stored variables\n        scrollPos = vec2(dataAt(0), dataAt(1));\n        mPosOld   = vec2(dataAt(2), dataAt(3));\n        mIsHeld   = dataAt(4);\n        \n        // new time-based variables (to make them frame-based, set td to 1.0)\n        float td = 60. * iTimeDelta;\n        float scrollSpeed = ScrollSpeed * td;\n        float scrollDrift = ScrollDrift * td;\n        \n        // mouse handling\n        if(iMouse.z>0.) {\n            if(mIsHeld==0.)\n                mPosOld = iMouse.xy;\n            \n            mIsHeld = 1.;\n        }\n        else {\n            // scroll drifting\n            mPosOld = mix(mPosOld, iMouse.xy, min(1., 1./scrollDrift));\n            \n            mIsHeld = 0.;\n        }\n        \n        // update scroll position\n    \tscrollPos -= scrollSpeed * (iMouse.xy-mPosOld) / res.y * pow(10.*length(iMouse.xy-mPosOld)/res.y, 1.5);\n    }\n    \n    // uncomment this line if grid lines appear\n    //uv = floor((uv+.001)*res)/res;\n    \n    vec2 p = (uv-.5) / GridScale * vec2(res.x/res.y, 1.) - scrollPos;\n    \n    vec2 dirs[4];\n    dirs[0] = vec2(0., 0.);\n    dirs[1] = vec2(1., 0.);\n    dirs[2] = vec2(0., 1.);\n    dirs[3] = vec2(1., 1.);\n    \n    // cells for blending\n    vec3 cells[4];\n    for(int i=0; i<4; i++)\n        cells[i] =\n        \ttexture(iChannel0, rndCell(p, dirs[i], res)).rgb\n        \t+ Hardness * (hash42(floor(p+dirs[i])-.8).rgb-Darkness);\n    \n    // blend the cells\n    vec2 fp = smoothstep(0., 1., fract(p));\n    RGB =\n        mix(\n            mix(\n                cells[0],\n                cells[1],\n                fp.x\n\t\t\t),\n            mix(\n                cells[2],\n                cells[3],\n                fp.x\n\t\t\t),\n            fp.y\n\t\t);\n    \n    // so the screen doesn't go all black or all white\n    RGB = clamp(RGB, vec3(0.), vec3(1.));\n    \n    // save data\n    if(floor(fragCoord.x)<1.)\n    \tA = scrollPos.x;\n    else\n\tif(floor(fragCoord.x)<2.)\n    \tA = scrollPos.y;\n    else\n\tif(floor(fragCoord.x)<3.)\n    \tA = mPosOld.x;\n    else\n\tif(floor(fragCoord.x)<4.)\n    \tA = mPosOld.y;\n    else\n\tif(floor(fragCoord.x)<5.)\n    \tA = mIsHeld;\n    else\n        A = 0.;\n\t\n\t//refresh buffer\n\tif(texture(iChannel3, vec2(KEY_SPACE, 0.)).r>0.)\n        RGB = vec3(0.);\n    \n    fragColor = vec4(RGB, A);\n}","name":"Buffer A","description":"","type":"buffer"}]}