{"ver":"0.1","info":{"id":"ct23Wz","date":"1673274788","viewed":115,"name":"Plexus Light and Mirror (lines)","username":"trasnodalua","description":"Lots of particles\n\nCredits to @The_ArtOfCode for the idea!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["particles","universe","plexus"],"hasliked":0,"parentid":"Dtj3Wz","parentname":"Fork Plexus Particles Grid"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 ap = p - a;\n    vec2 ab = b - a;\n    float aDotB = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 8.5);\n    return length(ap - ab * aDotB);\n}\n\nfloat drawLine(vec2 uv, vec2 a, vec2 b) {\n    float line = smoothstep(0.014, 0.01, distLine(uv, a, b));\n    float dist = length(b-a);\n    //return line * (smoothstep(1.3, 0.8, dist) * 0.5 + smoothstep(0.04, 0.03, abs(dist - 0.75)));\n    return line * (smoothstep(1.3, 0.5, dist) * 0.5 + smoothstep(0.04, 0.03, abs(dist - 0.85)));\n}\n\nfloat n21(vec2 i) {\n    i += fract(i * vec2(0.0001, 0.001));\n    //i += dot(i, i + 23.14);\n    i += dot(i, i+150.);\n    return fract(i.x * i.y);\n}\n\nvec2 n22(vec2 i) {\n    float x = n21(i);\n    //return vec2(x, n21(i+x));\n    return vec2(x, n21(i+x));\n}\n\nvec2 getPoint (vec2 id, vec2 offset) {\n    //return offset + sin(n22(id + offset) * iTime * 1.0) * 0.4;\n\treturn offset/2. + sin(n22(id + offset/500.) * iTime * 0.5) * 1.5;\n}\n\nfloat layer (vec2 uv) {\n    float m = 0.0;\n    float t = iTime * 2.0;\n   \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv) - 0.5;\n    \n    vec2 p[9];\n    int i = 0;\n    for (float y = -1.0; y <= 1.0; y++) {\n        for (float x = -1.0; x <= 1.0; x++) {\n        \tp[i++] = getPoint(id, vec2(x,y));\n        }\n    }\n    \n    for (int i = 0; i < 9; i++) {\n    \tm += drawLine(gv, p[4], p[i]);\n        float sparkle = 5.0 / pow(length(gv - p[i]), 1.5) * 0.005;\n        // m += sparkle * (sin(t + fract(p[i].x) * 12.23) * 0.4 + 0.6);\n        m += sparkle * (cos(t + fract(p[i].x) * 12.23) * 0.1 + 1.0);\n    }\n    \n    //m += drawLine(gv, p[1], p[3]);\n    //m += drawLine(gv, p[1], p[5]);\n    //m += drawLine(gv, p[7], p[3]);\n    //m += drawLine(gv, p[7], p[5]);\n     \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 c = sin(iTime * 2.0 * vec3(.234, .324,.768)) * 0.4 + 0.6;\n    vec3 col = vec3(0);\n    float fft = texelFetch(iChannel0, ivec2(76.0, 0.), 0).x / 2.0 + 0.5;\n    //c.x += (uv.x + 0.5);\n    //col += pow(-uv.y + 0.5, 5.0) * fft * c;\n    //col = pow(-uv.y, 5.0) * fft * c;\n    \n    float m = 0.0;\n    float x = sin(iTime * 0.1);\n    float y = cos(iTime * 0.2);\n    \n    //mat2 rotMat = mat2(x, y, -y, x);\n    //uv *= rotMat;\n    \n    for (float i = 0.0; i <= 1.0; i+= 1.0/4.0) {\n        float z = fract(i + iTime * 0.05);\n        float size = mix(15.0, .1, z) * 1.50;\n        float fade = smoothstep(0.5, 1.0,  z) * smoothstep(1.0, 0.9, z);\n        m += layer((size * uv) + i * 1.5 ) * fade;\n    }\n    //col += m* c;\n    col += m*c ;\n    // Debug\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}