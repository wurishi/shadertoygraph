{"ver":"0.1","info":{"id":"ldBcRD","date":"1491112065","viewed":577,"name":"Volume Mandelbulb","username":"soma_arc","description":"Volume Rendered Mandelbulb.\nReference: http://graphicsrunner.blogspot.jp/2009/01/volume-rendering-101.html","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nconst float MAX_MANDEL_ITERATION = 4.;\nbool mandelbulb(vec3 pos, \n                out float iterationCount,\n               out float minDist, out float maxDist) {\n    vec3 z = pos;\n    float r = 0.;\n    iterationCount = 0.;\n    float power = 8.;\n    minDist = 99999.;\n    maxDist = -1.;\n    for (float i = 0.; i < MAX_MANDEL_ITERATION; i++) {\n\t\titerationCount = i;\n        r = length(z);\n        minDist = min(minDist, r);\n        maxDist = max(maxDist, r);\n        if( r > 2. ) return false;\n        \n        float zr = pow( r,power);\n        float theta = acos(z.y / r);\n\t\tfloat phi = atan(z.z, z.x);\n        theta *= power;\n        phi *= power;\n        z = zr*vec3(sin(theta)*cos(phi),\n                    cos(theta),\n                    sin(phi)*sin(theta));\n        z += pos;\n    }\n    \n    return true;\n}\n\nvec4 sampleVolume(vec3 p) {\n    float itCount, minDist, maxDist;\n    bool mandel = mandelbulb(p, itCount, minDist, maxDist);\n\tif (!mandel) return vec4(0);\n\treturn vec4(hsv2rgb(vec3(minDist, 1., 1.)), 0.1);\n}\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec4 l = vec4(0);\n\n\tfloat t0, t1;\n   \tbool hit = intersectBox(eye, ray, \n                    \t\tvec3(-1.5), vec3(1.5),\n                    \t\tt0, t1);\n    \n    if(!hit) return l.rgb;\n    \n    const float MAX_SAMPLES = 150.;\n    float t = t0;\n    float tStep = (t1 - t0) / MAX_SAMPLES;\n    \n    vec3 p0 = eye + t0 * ray;\n    vec3 p1 = eye + t1 * ray;\n    vec3 distP = p0 - p1;\n    float dist = abs(dot(vec3(1, 0, 0), distP));\n    dist = max(dist, abs(dot(vec3(0, 1, 0), distP)));\n    dist = max(dist, abs(dot(vec3(0, 0, 1), distP)));\n    float sliceWidth = .05;\n    float samples = floor(dist / sliceWidth) + 1.;\n    //tStep = (t1 - t0) / samples;\n    samples = MAX_SAMPLES;\n    for (float i = 0.; i < MAX_SAMPLES; i++){\n    \tif((min(min(l.x, l.y), l.z)) > 1.0 ||\n           l.w > 0.999 ||\n           t >= t1 ||\n          samples < i) break;\n        \n        vec3 p = eye + t * ray;\n        \n        vec4 volCol = sampleVolume(p);\n        volCol.a *= 1.;\n        volCol.rgb *= volCol.a;\n        l = (1. - l.a) * volCol + l;\n        \n        t += tStep; \n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 eye = vec3(1.9 * sin(iTime) , 2. * sin(iTime), \n                    1.9 * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}