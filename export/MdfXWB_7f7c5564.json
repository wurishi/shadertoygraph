{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// @acaudwell\n// 2014\n\n#define MAX_RAY_STEPS 48\n#define KIFS_ITERATIONS 16\n\n// uncomment to see how it works ...\n//#define DEBUG\n\n// enable ray sphere intersection test\n#define INTERSECTION_TEST\n\n#define COLOUR vec3(0.75, 1.0, 1.75)\n\n#ifdef DEBUG\nvec3 col1 = vec3(1.0, 0.0, 0.0);\nvec3 col2 = vec3(0.0, 1.0, 0.0);\nvec3 col3 = vec3(0.0, 0.0, 1.0);\nvec3 col4 = vec3(1.0, 0.0, 1.0);\nvec3 col5 = vec3(0.0, 1.0, 1.0);\n#else\nvec3 col  = COLOUR;\nvec3 col1 = COLOUR;\nvec3 col2 = COLOUR;\nvec3 col3 = COLOUR;\nvec3 col4 = COLOUR;\nvec3 col5 = COLOUR;\n#endif\n\nmat4 calc_transform(vec3 offset, vec3 axis, float angle, float scale) {\n\n    angle *= radians(1.0);\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * axis;\n\n    return mat4(\n        vec4(c + t.x * axis.x, t.y * axis.x - s * axis.z, t.z * axis.x + s * axis.y, 0.0) * scale,\n        vec4(t.x * axis.y + s * axis.z, (c + t.y * axis.y), t.z * axis.y - s * axis.x, 0.0) * scale,\n        vec4(t.x * axis.z - s * axis.y, t.y * axis.z + s * axis.x, c + t.z * axis.z, 0.0) * scale,\n        vec4(offset, 1.0)\n    );\n}\n\nmat4 M;\n\nfloat KIFS(vec3 p, float s) {\n        \n        p /= s;\n        \n        for(int i=0;i<KIFS_ITERATIONS;i++) {\n                \n                p = abs(p);\n                \n                // apply transform\n                p = (M * vec4(p, 1.0)).xyz;\n        }\n        \n        // divide by scale preserve correct distance\n        return ((length(p)-1.0) * (pow(1.5, -float(KIFS_ITERATIONS))))*s;\n}\n\nvec3 dir;\n\nbool intersect(vec3 p, float r) {\n\n    float b = 2.0 * dot(dir, p);\n    float c = dot(p, p) - r*r;\n\n    float sq = sqrt(b*b - 4.0*c);\n\n    float t1 = (-b + sq) * 0.5;\n    float t2 = (-b - sq) * 0.5;\n\n    float near = min(t1, t2);\n    float far  = max(t1, t2);\n\n    return near < far && far > 0.0;\n}\n\n\nvoid combineKIFS(vec3 p, float s, vec3 c, inout vec4 o) {\n\n#ifdef INTERSECTION_TEST\n    if(intersect(p, s*1.75)) {\n#endif\n                float d = KIFS(p,s);\n                if(d<o.x) o = vec4(d,c);\n#ifdef INTERSECTION_TEST\n        }\n#endif\n}\n\n#define SF 0.2\n\nvec3 sp = normalize(vec3(-0.5,0.55,-0.5));\n\nvec4 scene(vec3 p) {\n\n        vec3 p1 = p - (sp + sp*SF);\n        vec3 p2 = p - (sp + sp*SF*2.0 + sp*SF*SF);\n        vec3 p3 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF);\n        vec3 p4 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF*2.0 + sp*SF*SF*SF*SF);\n        vec3 p5 = p - (sp + sp*SF*2.0 + sp*SF*SF*2.0 + sp*SF*SF*SF*2.0 + sp*SF*SF*SF*SF*2.0 + sp*SF*SF*SF*SF*SF);\n\n        vec4 o = vec4(10000.0,vec3(0.0));\n\n        combineKIFS(p1,SF,             col1, o);\n        combineKIFS(p2,SF*SF,          col2, o);\n        combineKIFS(p3,SF*SF*SF,       col3, o);\n        combineKIFS(p4,SF*SF*SF*SF,    col4, o);\n        combineKIFS(p5,SF*SF*SF*SF*SF, col5, o);\n        \n        return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    M = calc_transform(vec3(-0.4,-0.4,-0.4),normalize(vec3(1.0, 1.0, 1.0)), 40.0, 1.5);\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n        uv.x = -uv.x;\n        \n        dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 0.8));\n        \n        \n        float t = log(1.0 + 4.0*fract(iTime/2.0)) / log(5.0);\n        \n        float ratio = iResolution.y/iResolution.x;\n        \n        vec3 start = vec3(-0.01,0.175*ratio,-SF*1.5);\n        //start.y += sin(fract(iTime/2.0)*radians(360.0)) * SF * 0.01;\n        //start.x -= cos(fract(iTime/2.0)*radians(360.0)) * SF* 0.01;\n        \n        vec3 t1 = sp + sp*SF + start;\n        vec3 t2 = sp + sp*SF*2.0 + sp*SF*SF + start * SF;\n        \n        vec3 cam = t1 + (t2-t1) * t;\n        \n        float d = 1.0;\n        float ray_length = 0.0;\n        \n        int steps = 0;\n        \n        vec3 bg = vec3(0.0,2.0,2.0);\n        \n        vec3 c = bg * pow(length(vec2(uv.x,uv.y)*0.45),3.0);\n        \n        vec4 s = vec4(0.0);\n        \n        float lod = 0.56 /max(iResolution.x,iResolution.y);\n        \n        for(int i=0; i<MAX_RAY_STEPS; i++) {\n                if(d<ray_length*lod) continue;\n                s = scene(cam);\n                d = s.x;\n                cam += d * dir;\n                ray_length += d;\n                steps++;\n        }\n        \n        if(ray_length<1.0) {\n                c = s.yzw;\n                \n                float cost = float(steps)/float(MAX_RAY_STEPS+1);\n                \n                // cost based shading\n                \n                c *= pow(1.0 - cost,3.0);\n                \n                c /= 1.0- pow(1.0 - cost,27.0);\n                \n                c = clamp(c,0.0,1.0);\n                \n                c *= c;\n                \n                c += cost*0.05 * bg;\n        }\n        \n        c *= 1.0+min(0.0,uv.y);\n        \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdfXWB","date":"1406239564","viewed":1386,"name":"Infinite KIFS Zoom 2","username":"andyalias","description":"Another simulated zoom into a Kaleidoscopic IFS fractal. The original: https://www.shadertoy.com/view/4sS3WV","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["zoom","kifs"],"hasliked":0,"parentid":"","parentname":""}}