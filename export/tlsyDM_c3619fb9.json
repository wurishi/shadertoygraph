{"ver":"0.1","info":{"id":"tlsyDM","date":"1592254335","viewed":326,"name":"PX Kaleidoscope 2.0","username":"ptaczek","description":"Simple n-symetry kaleidoscope with sine-wave propagation","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// configuration\n#define MIRRORS (5.0)\n#define ZOOM (1.5)\n\n// possible values: MSAA2X, MSAA4X, MSAA8X, MSAA16X\n// if no MSAAnX defined, msaa is disabled\n#define MSAA2X\n\n// helpers\n#define PI 3.14159265\n#define degPerRad 57.2957795130823\n#define deg(a) ((a) * degPerRad)\n#define rad(a) ((a) / degPerRad)\n\nconst vec2 base = vec2(1.0, 0.0);\n\nmat2 rotate(float aDeg){\n  float aRad = rad(aDeg);\n  return mat2(\n    cos(aRad), -sin(aRad),\n    sin(aRad), cos(aRad)\n  );\n}\n\nvec3 compute(vec2 xy, sampler2D Texture, float mirrors, float density, vec2 repeat) {\n  float my_time = iTime / 4.00;\n  vec2 my_mouse = iMouse.xy; //vec2(643.0,815.0);// iMouse;\n  vec2 coord = xy / iResolution.xy;\n  coord = fract(coord * repeat);\n  coord -= 0.5; // place at center\n  // coord -= my_mouse/iResolution-0.5; // follow mouse\n  coord *= density;\n  coord.x *= iResolution.x/iResolution.y;\n  coord.x /= repeat.x/repeat.y;\n  // coord *= rotate(60.0);\n  float lfo1 = sin(2.0*iTime/3.14)*0.20+0.25;\n  float lfo2 = sin(2.0*iTime/2.44)*0.20+0.25;\n  float lfo3 = sin(2.0*iTime/5.16)*0.20+0.25;\n  float lfo = (lfo1/1.13+lfo2+lfo3)/4.0;\n  coord *= rotate(180.0 * lfo);\n  coord *= rotate(deg(sin((length(coord)-iTime/5.0)*6.0)*(sin((length(coord)))*0.5+0.5)*0.2));\n\n\n  float dp = dot(base, coord);\n  float cosa = dp / (length(base) * length(coord));\n  float a = deg(acos(cosa));\n  if (coord.y < 0.0) {\n    a = 360.0 - a;\n  }\n\n  float segmentAngle = 360.0/mirrors;\n\n  float b = mod(a, segmentAngle);\n\n  vec2 texOffset = vec2(0.0, 0.0);\n  \n  texOffset += vec2(0.5, 0.5);\n\n  // texture follows mouse\n  texOffset += vec2(-1.0, 1.0)*(my_mouse/iResolution.xy*iChannelResolution[0].xy)/iChannelResolution[0].xy;//vec2(-0.05, 0.0);\n\n  // texture slides\n  texOffset += (texOffset/2.0) * vec2(sin(my_time/2.05)*density, -cos(my_time/2.00)*density/5.0) + (texOffset/2.0);\n\n  mat2 rotationMatrix;\n\n  if (b < segmentAngle/2.0) {\n    rotationMatrix = rotate(-b);\n  } else {\n    rotationMatrix = rotate(b-segmentAngle);\n  }\n\n  vec2 coordTex = vec2(length(coord), 0.0);\n  //coordTex = (coordTex+texOffset) * rotationMatrix;\n  coordTex = coordTex * rotationMatrix + texOffset;\n  coordTex *= vec2(0.5, 0.5);\n\n  vec2 rotCenter = vec2(-0.0, -0.2);//0.1 * sin(my_time/1.0)/2.0;\n\n  // texture wiggles\n  coordTex = (coordTex-rotCenter) * rotate(deg(cos(my_time*0.05*sin(my_time*0.152)/2.0)/5.0)/10.0) + rotCenter;\n  \n  // texture rotates\n  coordTex = (coordTex-rotCenter) * rotate(mod(my_time*2.5, 360.0)) + rotCenter;\n\n  return texture(\n    Texture,\n    coordTex\n  ).rgb;\n}\n\n// MSAA offsets\n#if defined(MSAA2X)\nvec2[] msaaOffsets = vec2[] (vec2(0.0, 0.0), vec2(-4.0, -4.0), vec2( 4.0,  4.0));\n#elif defined(MSAA4X)\nvec2[] msaaOffsets = vec2[] (vec2(0.0, 0.0), vec2(-2.0, -6.0), vec2( 6.0, -2.0), vec2(-6.0,  2.0), vec2( 2.0,  6.0));\n#elif defined(MSAA8X)\nvec2[] msaaOffsets = vec2[] (vec2(0.0, 0.0), vec2( 1.0, -3.0), vec2(-1.0,  3.0), vec2( 5.0,  1.0), vec2(-3.0, -5.0), vec2(-5.0,  5.0), vec2(-7.0, -1.0), vec2( 3.0,  7.0), vec2( 7.0, -7.0));\n#elif defined MSAA16X\nvec2[] msaaOffsets = vec2[] (vec2(0.0, 0.0), vec2( 1.0,  1.0), vec2(-1.0, -3.0), vec2(-3.0,  2.0), vec2( 4.0, -1.0), vec2(-5.0, -2.0), vec2( 2.0,  5.0), vec2( 5.0,  3.0), vec2( 3.0, -5.0), vec2(-2.0,  6.0), vec2( 0.0, -7.0), vec2(-4.0, -6.0), vec2(-6.0,  4.0), vec2(-8.0,  0.0), vec2( 7.0, -4.0), vec2( 6.0,  7.0), vec2(-7.0, -8.0));\n#else\nvec2[] msaaOffsets = vec2[] (vec2(0.0, 0.0));\n#endif\n\nint msaaSamplesCount = msaaOffsets.length();\nfloat msaaOffsetSize = 1.0/8.0;\n\nvec3 computeWithMsaa(vec2 coord, sampler2D Texture, float mirrors, float density, vec2 repeat) {\n    vec3 accum = vec3(0.0);\n\n\n    for (int i=0; i<msaaSamplesCount; i++) {\n        accum += (compute(coord + msaaOffsetSize*msaaOffsets[i], Texture, mirrors, density, repeat));\n    }\n\n    accum /= float(msaaSamplesCount);\n\n    return vec3(accum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tfloat lfo1 = sin(2.0*iTime/2.88)*0.20+0.25;\n  \tfloat lfo2 = sin(2.0*iTime/2.06)*0.20+0.25;\n  \tfloat lfo3 = sin(2.0*iTime/3.33)*0.20+0.25;\n  \tfloat lfoA = (lfo1-lfo2*lfo3)/3.0+0.5;\n    float lfoB = (lfo1+lfo2+lfo3)/3.0+0.5;\n\n    vec3 color1 = computeWithMsaa(fragCoord.xy, iChannel0, MIRRORS*1.0, ZOOM*3.0*lfoA, vec2(1.0, 1.0)).brr/2.5;\n    vec3 color2 = computeWithMsaa(fragCoord.xy, iChannel1, MIRRORS*2.0, ZOOM*2.0*lfoB, vec2(1.0, 1.0)).gbr;\n    //vec3 color = mix(color1, color2, sin(iTime)/4.0+0.25);\n    vec3 color = mix(dot(color1, vec3(1.0)) > dot(color2, vec3(1.0)) ? color1 : color2, color2/(color1*5.0), lfo1+lfo3);\n    //vec3 color = dot(color1, vec3(1.0)) > dot(color2, vec3(1.0)) ? color1 : color2;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}