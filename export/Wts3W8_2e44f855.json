{"ver":"0.1","info":{"id":"Wts3W8","date":"1556207709","viewed":208,"name":"psychedelic box","username":"ankd","description":"rotated box and gray2hue coloring","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","psychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\n#define AA 2\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate(in float r){\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\nfloat usin(in float x){\n    return 0.5+0.5*sin(x);\n}\nfloat gray(in vec3 color){\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat sdSphere(in vec3 p, in float r){\n    return length(p) - r;\n}\nfloat sdBox(in vec3 p, in vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec3 opRep(in vec3 p, in vec3 c){\n    return mod(p, c) - 0.5*c;\n}\n\nfloat sdObj(in vec3 p){\n    vec3 q = p;\n    q.xy *= rotate(q.z*PI*0.05+iTime*0.1);\n    q = opRep(q, vec3(5.0));\n    // q.z\n    q.xy *= rotate(q.z*PI+iTime);\n    return sdBox(q, vec3(2.5, 0.1, 2.5));\n}\n\nvec2 map(in vec3 p){\n    vec2 res = vec2(0.0);\n    vec3 q = p;\n\n    res = vec2(sdObj(q), 1.);\n    return res;\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.00001;\n    return normalize(vec3(\n            e.xyy*map(p+e.xyy).x +\n            e.yxy*map(p+e.yxy).x +\n            e.yyx*map(p+e.yyx).x +\n            e.xxx*map(p+e.xxx).x\n        ));\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cp, cw));\n    vec3 cv = normalize(cross(cw, cu));\n    return mat3(cu,cv,cw);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD=0.0, maxD = 30.0;\n    float d=minD, m=0.0;\n\n    for(int i=0;i<32;i++){\n        vec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<0.0000001 || maxD<tmp.x) break;\n        d += tmp.x*0.6;\n        m = tmp.y;\n    }\n    if(maxD<d) m = -1.0;\n\n    return vec2(d, m);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n\n    vec3 pos = ro + rd * d;\n    vec3 nor = calcNormal(pos);\n\n    vec3 lightDir = normalize(vec3(cos(iTime), 1., sin(iTime)));\n\n    vec3 color = vec3(0.);\n    if(m==1.){\n        color += clamp(dot(lightDir, nor), 0., 1.);\n        float g = gray(color);\n        color = hsv(0.5+0.1*sin(iTime*0.5)+g*(0.4+usin(iTime*0.001)), 1.0, 1.0);\n        color += usin(d+iTime*20.0);\n        color *= exp(-0.03*d);\n    }else {\n        color = vec3(0.0);\n    }\n\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = vec3(0., 0., iTime);\n    vec3 tar = eye-vec3(0.1*sin(iTime*1.2+sin(iTime*0.5)), 0.1*sin(iTime*.9+sin(iTime*1.3)), 1.0);\n\n    vec3 color = vec3(0.);\n    for(int i=0;i<AA;i++){\n        for(int j=0;j<AA;j++){\n            vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n            p += vec2(float(i), float(j))/iResolution.xy;\n            vec3 dir = normalize(lookAt(eye, tar, iTime*0.4+0.2*sin(iTime*0.8)) * vec3(p, 1.0));\n            dir = normalize(vec3(dir.xy, sqrt(max(dir.z*dir.z - dot(dir.xy, dir.xy)*0.2, 0.))));\n\n            color += render(eye, dir);\n        }\n    }\n    color /= float(AA*AA);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}