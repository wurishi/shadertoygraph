{"ver":"0.1","info":{"id":"NdXyzn","date":"1641561479","viewed":79,"name":"Barnsley's game of chaos 3","username":"Envy24","description":"Speed up this shader: https://www.shadertoy.com/view/7tt3Wf","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","game","chaos","of","tirangle","serpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) { O = texture(iChannel0, SC/iResolution.xy); }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R iResolution\n#define center(SC) ( ((SC)+(SC)-R.xy)/R.y )       // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define TEX0(x) (texture(iChannel0, x))\n#define LMB_IS_HOLD  ( iMouse.z > 0.0 )\n\nfloat scene(in vec2 UV)\n{\n    float scale = 1.2;\n    vec2 triangle[3];\n    \n    /* Equaliteral triangle. */\n    triangle[0] = vec2(0.0, 0.75) * scale;\n    triangle[1] = vec2(-0.866025, -0.75)* scale;\n    triangle[2] = vec2(0.866025, -0.75)* scale;\n    /**/\n    \n    /* Right triangle. *\n    triangle[0] = vec2(-0.866025, 0.75) * scale;\n    triangle[1] = vec2(-0.866025, -0.75)* scale;\n    triangle[2] = vec2(0.866025, -0.75)* scale;\n    /**/\n    \n    /* Also works with other triangles. */\n    \n    /* First toss. */\n    uint rand = uint(golderRatioHash(iTime) * 9.0);\n    \n    /* Seed vertex. */\n    vec2 C = triangle[0];\n    vec2 _C = triangle[0];\n    \n    float minDist = 999999.9;\n    int points_per_frame = 30;\n    \n    for (int point = 0; point < points_per_frame; ++point)\n    {    \n        for (int toss = 0; toss < 15; ++toss)\n        {\n            // Update coordinates.\n            C += (triangle[rand % 3u] - C) * 0.5;\n            //C = (C + triangle[rand % 3u]) * 0.5;\n\n            /* Other tosses with feedback. */\n            rand = uint(golderRatioHash(iTime*C.x) * 9.0);\n        }\n        \n        float curDist = distance(C,UV);\n        minDist = min(minDist, curDist);\n        \n        _C = \n            minDist == curDist ? // Find better candidate?\n                C :\n                _C;\n    }\n\n    float radius = 4.0 / R.x;\n    float smoothness = 3.0 / R.y;\n    \n    /* Sample size remains same for different resolutions. */\n    return circleSDFSD(UV, _C, radius, smoothness);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    /* White screen initialization. */\n    if (iFrame == 0             // Initialization at launch.\n        || LMB_IS_HOLD == true) // Reinitialization (for fullscreen mode).\n    { O = vec4(1.0); return; }\n\n    O = vec4(\n            min(\n                scene(center(SC)),\n                TEX0(SC/R.xy).r)\n            );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Hash with uniform distribution.\n    Works fine for range [0.1; 1e6].\n    Not always look good.\n \n    For 8388608 tested samples in range [0.0; 1.0] shows this statistics:\n        Histogram with 0.1 column width:\n            854844 825298 823153 824903 829215 834342 840773 844517 846493 865070\n            \n\n        Shannon enthropy                  =3.321747\n        Area of unit circle (Monte-Carlo) =3.119030\n        Mathematical expectation          =0.502320\n        Dispersion                        =0.084333\n        Standart deviation                =0.290402\n    \n    return value in range [0.0; 1.0].\n*/\nfloat golderRatioHash(float x)\n{\n    float y = (100. + x);\n    float m = mod(1e3 * y, 11.67115450f);\n    float f = fract(m * (m * y));\n    float a = (f - m) * 6.18034029f;\n\n    return fract(a * fract(a * fract(a)));\n}\n\nfloat golderRatioHash2(vec2 p, float w)\n{ \n    return golderRatioHash(clamp(p.y * w + p.x, 0.1, 1e6));\n}\n\n/* Signed distance of squared distances. \n   Should work faster without calculation square root. */\nfloat circleSDFSD(vec2 S, vec2 C,float r, float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of squares.\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}","name":"Common","description":"","type":"common"}]}