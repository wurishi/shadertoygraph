{"ver":"0.1","info":{"id":"4lKcWV","date":"1538170225","viewed":429,"name":"Star 210","username":"nr4","description":"Stars with logo. ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Star 210\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Edit 1: Remove Polygon SDF, as there are no polygons in the scene.\n// Edit 2: Optimized to <=300 raymarching iterations\n// Edit 3: Added abs(.) to dot(re,v) to fix lighting\n\nfloat iScale;\nfloat iNBeats;\nfloat iHighScale;\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\nvec2 ind;\n\n// hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// value noise\nfloat vnoise(vec2 x)\n{\n    vec2 y = floor(x);\n    x = fract(x);\n    float r00 = -1.+2.*rand(y),\n        r10 = -1.+2.*rand(y+c.xy),\n        r01 = -1.+2.*rand(y+c.yx),\n        r11 = -1.+2.*rand(y+c.xx);\n    return mix(\n        mix(r00, r10, x.x),\n        mix(r01, r11, x.x),\n        x.y\n    );\n}\n\nfloat mfvnoise(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*vnoise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\n// compute distance to regular star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d),\n        i = mod(round((p-p0)/d),2.);\n    x = length(x)*vec2(cos(p),sin(p));\n    vec2 a = mix(R,R.yx,i),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n   \tff = ff.yx*c.zx;\n    return dot(x-p1,ff)/length(ff);\n}\n\nfloat zextrude(float z, float d2d, float h)\n{\n    vec2 d = abs(vec2(min(d2d, 0.),z))-h*c.yx;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat cr(vec2 x, float r, float w)\n{\n    return abs(length(x)-r)-w;\n}\n\nfloat cs(vec2 x, float r0, float w, float p0, float p1)\n{\n    float r = length(x), p = acos(x.x/r)*step(0.,x.y)-acos(x.x/r)*step(x.y,0.);\n    p = clamp(p, p0, p1);\n    vec2 y = r0*vec2(cos(p), sin(p));\n    return length(x-y)-w;\n}\n\nfloat b(vec2 x, vec2 a, vec2 b, float w)\n{\n    vec2 d = b-a;\n    return length(x-mix(a, b, clamp(dot(x-a, d)/dot(d,d), 0., 1.)))-w;\n}\n\nvec2 rot(vec2 x, float p)\n{\n    return mat2(cos(p), sin(p), -sin(p), cos(p))*x;\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nvec2 scene(vec3 x)\n{\n    \n    float dr = .03, d, dh, h;\n    vec3 y = vec3(mod(x.xy, dr)-.5*dr, x.z), index = x-y;\n    \n    vec2 z = (index.xy-c.yx)*(.5);\n    float sd = min(cr(z-.125*c.xy, .125, .04), cs(z+.125*c.xy, .125, .04, -pi/2., pi/2.));\n    sd = min(sd, b(z, -.125*c.yx, .125*c.yx, .04));\n    \n    dh = .05*mfvnoise(index.xy-.5*iTime, 8., 100., .45)+.1*iScale*rand(index.xy);\n    h = .1+dh+(.1+iScale*.1)*step(sd,0.);\n    d = zextrude(y.z, dstar(rot(y.xy, 5.*iTime), 5.+5.*round(rand(3.*index.xy)), vec2(.2+.1*rand(2.*index.xy),.4+.1*rand(index.xy))*dr), h)-.001;\n    \n    ind = index.xy;\n    \n    if((sd < 0.) || (x.z < .5))\n    {\n    \tfloat guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .45),0.));\n        guard = abs(guard)+dr*.1;\n        d = min(d, guard);\n    }\n    \n    vec2 sdf = vec2(d, 1.+step(sd, 0.)), sda = vec2(x.z, 1.);\n    return mix(sdf, sda, step(sda.x, sdf.x));\n}\n\nconst float dx = 1.e-3;\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(scene(x+dx*c.xyy).x-s, scene(x+dx*c.yxy).x-s, scene(x+dx*c.yyx).x-s));\n}\n\nvec3 background(vec2 x)\n{\n    return c.yyy;\n}\n\nvec3 synthcol(float scale, float phase)\n{\n    vec3 c2 = .5*vec3(rand(phase*c.xx), rand(phase*c.xx+1.), rand(phase*c.xx+2.))+.5;\n    mat3 r1 = rot((5.e-1*phase)*vec3(1.1,1.3,1.5));\n    float sc = rand(phase*c.xx);\n    if(abs(sc) < .2)\n        sc = sign(sc)*.2;\n    return \n        (\n            sc*1.1*mix\n            (\n                mix(-(cross(c2, r1*c2)),c.yyy, .5*scale),\n                mix(c.yyy, -(r1*c2), .5*scale), \n                scale\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tiScale = mod(iTime, .5)/.5;\n \tiNBeats = floor(iTime*2.);\n \tiHighScale = mod(iTime, .5)/.5;\n    \n    vec2 uv = fragCoord/iResolution.yy-.5, s;\n    uv.x += .1*vnoise(uv+iTime);\n    vec3 or = rot(c.yyx*iTime)*(c.yyx-.2*c.yxy)+.5*c.yxy, ta = c.yxy, r = c.xyy, u = cross(r, normalize(ta-or)),\n        rt = ta+uv.x*r+uv.y*u, rd = normalize(rt-or), x, col;\n    \n    //Initialize rays with intersection distance of ray and plane above scene\n    float d = -(or.z-.45)/rd.z;\n    \n   \t//Interval approximation root solving\n   \tfloat D = -(or.z+.1)/rd.z, dm;\n\n    for(int i=0; i<300; ++i)\n    {\n        x = or + d * rd;\n        s = scene(x);\n        \n        if(s.x < 1.e-4) break;\n        if(i==299)\n        {\n            fragColor = vec4(background(uv), 1.);\n            return;\n        }\n        \n        d += s.x;\n    }\n\n    vec3 n = normal(x), l = 2.*c.yyx, re = normalize(reflect(-l, n)), v = normalize(or-x);\n    \n    if(s.y == 1.)\n    {\n        vec3 c1 = abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+1.1*ind.x*ind.y)), c2 = .1*abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+ind.x*ind.y));\n        col = .3*c1+.3*c1*abs(dot(l, n))+c2*abs(dot(re,v));\n    }\n    else if(s.y == 2.)\n    {\n        l = c.xxx;\n        vec3 c1 = abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+1.1*ind.x*ind.y+20.)), c2 = .2*abs(synthcol(1.5+.5*vnoise(2.*(x.xy)), iNBeats+ind.x*ind.y+20.));\n        c1 += .1*mfvnoise(x.xz, 1., 100., .45);\n        col = .3*c1+.3*c1*abs(dot(l, n))+c2*abs(dot(re,v));\n    }\n    \n    fragColor = vec4(col, 1.);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}