{"ver":"0.1","info":{"id":"cdlczX","date":"1687049693","viewed":75,"name":"Raymarched WeeWee","username":"sspanky","description":"mm yes raymarched wee wee","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 128\n#define MAX_DISTANCE 100.0\n#define EPSILION 0.001\n\n#define SUN_DIRECTION -0.333, -0.666, 0.333\n\nfloat SDF_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    return length(p-c) - r;\n}\n\nfloat SDF_sphere( in vec3 p1, in vec3 p2, in float s )\n{\n    return distance(p1, p2) - s;\n}\n\nfloat de( in vec3 p )\n{\n    float d = MAX_DISTANCE;\n    \n    vec3 v = vec3(0.0, 2, 5.0);\n    \n    d = min(d,\n        SDF_sphere(p, v + vec3(-1.0, 0.0, 0.0), 1.0)\n    );\n    \n    d = min(d,\n        SDF_sphere(p, v + vec3(1.0, 0.0, 0.0), 1.0)\n    );\n    \n    d = min(d,\n        SDF_capsule(p, v + vec3(0.0, 0.0, 0.0), v + vec3(0.0, 5.0, 0.0), 1.0)\n    );\n    \n    \n    d = min(d,\n        p.y\n    );\n    \n    return d;\n}\n\nfloat march( in vec3 ro, in vec3 rd )\n{\n    float d = 0.0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        vec3 p = ro + rd * d;\n        \n        float m = de(p);\n        \n        d += m;\n        if (d < EPSILION) break;\n    }\n    return d;\n}\n\nvec3 normal( in vec3 p )\n{\n    vec2 e = vec2(EPSILION, 0.0);\n    \n    vec3 n = vec3(\n        de(p - e.xyy),\n        de(p - e.yxy),\n        de(p - e.yyx)\n    );\n    \n    return normalize(de(p) - n);\n}\n\nconst vec3 skyCol = vec3(0.5, 0.8, 1.0);\nconst vec3 ambientCol = vec3(0.5, 0.8, 1.0);\nconst vec3 sunCol = vec3(1.0, 0.9, 0.8);\nconst vec3 white = vec3(1.0, 1.0, 1.0);\nconst vec3 sunDirection = vec3(SUN_DIRECTION);\nconst float exposure = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 4.0, 0.0);\n    vec3 rd = vec3(uv.x, uv.y, 0.5);\n\n    float m = march(ro, rd);\n\n    vec3 norm = normal(ro + rd * m);\n    bool hit = m < MAX_DISTANCE;\n    \n    vec3 c = vec3(0.0);\n    if(hit)\n    {\n        c = ambientCol;\n        float cosTheta = dot(norm, vec3(0.0, 1, 0.0));\n        float cosThetaClamped = (cosTheta + 1.0) * 0.5;\n        \n        c *= cosThetaClamped;\n        \n        \n        cosTheta = dot(norm, sunDirection);\n        float sunStrength = 4.0;\n        \n        float lambert = max(0.0, -cosTheta);\n        c += sunCol * lambert * sunStrength;\n    }\n    else\n    {\n        float cosTheta = dot(rd, vec3(0.0, 1, 0.0));\n        float cosThetaClamped = max(0.0, (cosTheta + 1.0) * 0.5);\n        c = mix(skyCol* 1.0, white * 0.0, 1.0 - cosThetaClamped);\n    }\n    c *= exposure;\n    c /= (1.0 + c);\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}