{"ver":"0.1","info":{"id":"wdtGD7","date":"1569328062","viewed":174,"name":"Complex Joukowski map","username":"Ultraviolet","description":"GLSL implementation of [url = https://sciencetonnante.wordpress.com/2019/09/03/comment-les-avions-volent-ils/] this [/url] idea.\n\nClick for changing the Joukowsky transform parameters.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["map","complex","conformal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 10.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderUnitSquare(vec2 pos, inout vec3 fragColor)\n{\n#if 0\n    // Put a texture in there\n    if (pos.x >= 0.0 && pos.y >= 0.0 && pos.x <= 1.0 && pos.y <= 1.0)\n    {\n        fragColor.rgb = texture(iChannel0, pos).rgb;\n    }\n#endif\n\n    float dist = sdistQuadConvex(vec2(0, 0),\n                                 vec2(1, 0),\n                                 vec2(1, 1),\n                                 vec2(0, 1), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.007, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvec2 Jouk(vec2 z)\n{\n    return cmul(cexp(-_alpha), (z+z0) + cdiv(vec2(_c*_c, 0.), (z+z0)));\n}\n\nvec2 invJouk(vec2 z)\n{\n    z = cmul(cexp(_alpha), z);\n    \n    vec2 r1 = z/2. + csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n    vec2 r2 = z/2. - csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n\n    if (cnorm(r1) > cnorm(r2))\n        return r1;\n    else\n        return r2;\n}\n\nfloat coord(vec2 z)\n{\n    z = cmul(cexp(_alpha), z);\n    \n    vec2 r1 = z/2. + csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n    vec2 r2 = z/2. - csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n\n    return length(r1-r2);\n}\n\nvec2 screenToWorld(vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return 4.*((fragCoord / iResolution.y) * 2. - vec2(aspect, 1.));\n}\n\nvec2 worldToScreen(vec2 pos)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return (pos/4. - vec2(aspect, 1.))/2.*iResolution.y;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 X = SCREEN2WORLD(fragCoord);\n    \n    //X = Jouk(X);\n    vec2 Z = invJouk(X);\n    //X = Jouk(X);\n    \n    vec3 col = vec3(1.);\n    \n    DRAW_C(Grid(1.), Z, vec3(.1), .5, col);\n    DRAW_C(Grid(.2), Z, vec3(.1), .2, col);\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), Z, vec3(.0), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n    \n    DRAW_A(Circle(vec2(0.), a), Z, vec4(.8, .8, 1., .6), col);\n    DRAW_C(Circle(vec2(0.), a), Z, vec3(.4, .4, 8.), 2., col);\n    \n    //*\n    if(length(fwidth(Z-X)) > .1)\n        col = vec3(1., 0., 0.);\n\t//*/\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 csqrt( vec2 z )         { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 cconj( vec2 z )         { return vec2(z.x,-z.y); }\nvec2 cexp( float b )         { return vec2(cos(b), sin(b)); }\nvec2 cexp( vec2 z )          { return exp(length(z))*cexp(atan(z.y, z.x)); }\nfloat cnorm( vec2 z )        { return length(z); }\nvec2 clog(vec2 z)            { return vec2(log(length(z)),atan(z.y, z.x)); }\n\nconst float a = 1.;               // Radius\n\n#define _c  (iMouse.z>0.5 ? iMouse.x/iResolution.x : 0.9)\n#define _alpha  0.\n//#define _alpha  (iMouse.z>0.5 ? iMouse.y/iResolution.y : (20./180.*PI))\n//#define b1 0.05\n#define b2 0.2\n#define b1 (iMouse.z>0.5 ? iMouse.y/iResolution.y : 0.05)\n//#define b2 (iMouse.z>0.5 ? iMouse.y/iResolution.y : 0.2)\n\n\n#define gamma ( -4.*PI*U0*((a+b1) * sin(_alpha) + b2*cos(_alpha)))\n#define z0  vec2(-b1,b2)\n\n\n#define SCREEN2WORLD(X)  ((X -iResolution.xy*.5)/iResolution.y*3.)\n\n\n////////////////////////////////////////////////////////////////////////////\n//      ___  ____  __   _  _  ____  ____  ____  _  _      __    __  ____ \n//     / __)(  __)/  \\ ( \\/ )(  __)(_  _)(  _ \\( \\/ )    (  )  (  )(  _ \\\n//    ( (_ \\ ) _)(  O )/ \\/ \\ ) _)   )(   )   / )  /     / (_/\\ )(  ) _ (\n//     \\___/(____)\\__/ \\_)(_/(____) (__) (__\\_)(__/      \\____/(__)(____/\n//\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n\n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n\n// Trick for drawing anti-aliased vectorial geometry in transformed space\n#define EPSILON\t(1e-4)\n#define GRAD_DIST(O,P) ((vec2(dist(O,Jouk(P+vec2(EPSILON,0.))) - dist(O,Jouk(P-vec2(EPSILON,0.))), dist(O,Jouk(P+vec2(0.,EPSILON)))-dist(O,Jouk(P-vec2(0.,EPSILON)))))/EPSILON*.5)\n#define DIST(O,P)\t(dist(O,P)*length(GRAD_DIST(O,P)))\n\n\n// draw the inside of the shape\n// O = object, P = point, C = drawing color, CC = original color\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(DIST(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the inside of the shape, with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(DIST(O,P)*iResolution.y/2., -1., 1.)*.5+.5))*C.a)\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(DIST(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n//#define DRAW_C(O,P,C,W,CC)\tCC=vec3(length(GRAD_DIST(O,P)*0.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(DIST(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*(1.-C.a))\n\n\n","name":"Common","description":"","type":"common"}]}