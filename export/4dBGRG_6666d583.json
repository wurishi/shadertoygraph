{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/*\n * fernLightning (BabyRabbit)\n * - attempt to do 2d global illumination (assumes reflective objects)\n * - move the mouse to move the light\n * - caustics!\n * - .. crude...\n */\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define PI2 6.28318530718\n\n\n// samples radiating from point\n#define SAMPLES360 30\n// max steps along ray\n#define MAXSTEPS 30\n\n#define MAXBOUNCES 2\n\n#define MINDISTANCE 0.001\n\n// angle each sample covers\n#define DA (PI2/float(SAMPLES360))\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat box(vec2 p, vec2 o, vec2 b) {\n    return length(max(abs(p-o)-b,0.0));\n}\n\nfloat ucircle(vec2 p, vec2 o, float r) {\n    return abs(length(p-o)-r);\n}\n\nfloat scircle(vec2 p, vec2 o, float r) {\n    return length(p-o)-r;\n}\n\n\n\n\nvec2 l_pos;\n\nvec2 c_pos;\n\nvec2 s_pos;\n\n\n\n// use distance functions!\nfloat scene(vec2 p) {\n    float d1 = scircle(p, c_pos, 0.04);\n    float d2 = box(p, vec2(0.2, 0.2), vec2(0.2, 0.04));\n    float d3 = ucircle(p, s_pos, 0.5);\n    \n    return min(d1,min(d2, d3));\n}\n\nvec3 ambientColor(vec2 p) {\n    float d = scene(p);\n    if(d <= MINDISTANCE) return vec3(0.3, 0.4, 0.5); // objects\n    return vec3(0.1); // floor\n}\n\n\n\nvec2 sceneNormal(vec2 p) {\n    float e = 0.00001;\n    float dx = scene(p-vec2(e,0.0)) - scene(p+vec2(e,0.0));\n    float dy = scene(p-vec2(0.0, e)) - scene(p+vec2(0.0,e));\n    return normalize(vec2(dx,dy));\n}\n\n\n// get light from light source if within sample cone\n// assume the cone size resets to zero at every bounce - wrong!\nfloat getLight(vec2 p ,vec2 v, float t, float ts) {\n    float d = length(l_pos-p);\n    float a = dot(v, (l_pos-p)/d);\n    if(d < t && a > cos(DA*0.5)) {\n        return float(SAMPLES360)/(d+ts);\n    }\n    return 0.0;\n}\n\n// intersect with scene, everything is perfectly reflective\nfloat traceRay(vec2 p, vec2 v) {\n    float ts = 0.0;\n    float light = 0.0;\n    int bounces = 0;\n    float t = 0.0;\n    for (int i = 0 ; i < MAXSTEPS ; i++) {\n        float dt = scene(p + v*t);\n        if(dt < MINDISTANCE) { // hit object\n            \n            // check if passed light source\n            light += getLight(p, v, t, ts);\n            \n            // reflect the ray\n            p += v*t;\n            v = reflect(v, sceneNormal(p));\n            ts = t;\n            t = MINDISTANCE; // reset distance along ray, but ensure donâ€™t collide with surface\n            \n            bounces++;\n            if(bounces >= MAXBOUNCES) break;\n        }\n        t += dt;\n    }\n    if(bounces == 0) {\n        // might still have passed light source\n        light += getLight(p, v, t, ts);\n    }\n    return light;\n}\n\nfloat castRays(vec2 p){\n    // cast rays in all directions out from point\n    float c = 0.0;\n    float a = rand(p)*DA;\n    for (int i = 0 ; i < SAMPLES360 ; i++) {\n        a += DA;\n        vec2 v = vec2(sin(a), cos(a));\n        c += traceRay(p, v);\n    }\n    c /= float(SAMPLES360);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tif(iMouse.z > 0.) {\n\t\tl_pos = iMouse.xy/iResolution.x; // mouse down to move light\n\t}\n    \n    l_pos = vec2(0.8, 0.7*iResolution.y/iResolution.x);\n    c_pos = vec2(0.5,0.5*iResolution.y/iResolution.x);\n    s_pos  = vec2(0.5,0.5*iResolution.y/iResolution.x);\n\t\n    vec2 p = fragCoord.xy/iResolution.xy;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 color = ambientColor(p) + castRays(p) * 0.04 * vec3(1.0,1.0,0.6);\n    color = pow(color, vec3(1./2.2)); // gamma correct\n    \n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBGRG","date":"1389673968","viewed":669,"name":"Illumination 2D","username":"fernlightning","description":"Use mouse drag to move the light.\nAssumes all surfaces are reflective.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","caustics"],"hasliked":0,"parentid":"","parentname":""}}