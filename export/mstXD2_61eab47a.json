{"ver":"0.1","info":{"id":"mstXD2","date":"1680471646","viewed":211,"name":"Fastest Bijective 128-Bit Hash","username":"myth0genesis","description":"This is the fastest single-round 128-bit hash that I know of that fully mixes every bit and is also collision-free: 12 int ops. It relies on the bijective nature of a double XOR-rotate, but uses swizzles which act as zero-cost multiple-of-32-bit rotates.","likes":8,"published":1,"flags":16,"usePreview":0,"tags":["fast","bit","hash","128","fastest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n\n// In my search for bijective integer operations that allow\n// bits to propagate between multiple channels, I came across\n// a method to invert the double XOR-rotate: http://marc-b-reynolds.github.io/math/2017/10/13/XorRotate.html\n// When experimenting with this, I realized that a swizzle is just\n// a rotation in multiples of 32 bits, but with zero cost.\n// Adapting this for use in a double XOR-rotate means that\n// only two XOR operators are needed to perform this operation.\n// I was surprised to find how well this mixes bits between channels\n// and came up with a hash that only requires 12 integer operations.\n// To ensure a uniform mixture within individual channels,\n// I made full use of the separate 32-bit channels to shift\n// each one by a different number of bits in parallel,\n// which dramatically reduced the number of operations required\n// to mix the lowest bits.\n// Included below is the hash, as well as its inverse,\n// with a way to test the function near the bottom.\n\n// Key legend:\n// 1: View xy plane (default; does nothing, but included here for clarity)\n// 2: View xz plane\n// 3: View xw plane\n// 4: View yz plane\n// 5: View yw plane\n// 6: View zw plane\n// 7: View xy-zw diagonal plane\n// 8: View xz-yw diagonal plane\n// 9: View xw-yz diagonal plane\n// B: Toggle bit view (change #define BITCHECK to pick a bit to look at)\n// D: Toggle distribution view (will cycle through every 1% range by default)\n// X: View x channel (default)\n// Y: View y channel\n// Z: View z channel\n// W: View w channel\n\n#define KEY_B texture(iChannel0, vec2((98.5 - 32.0) / 256.0, 2.5 / 3.0)).x == 1.0\n#define KEY_D texture(iChannel0, vec2((100.5 - 32.0) / 256.0, 2.5 / 3.0)).x == 1.0\n#define KEY_X texture(iChannel0, vec2((120.5 - 32.0) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_Y texture(iChannel0, vec2((121.5 - 32.0) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_Z texture(iChannel0, vec2((122.5 - 32.0) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_W texture(iChannel0, vec2((119.5 - 32.0) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_1 texture(iChannel0, vec2((49.5) / 256.0, 0.5 / 3.0)).x != 0.0\n#define KEY_2 texture(iChannel0, vec2((50.5) / 256.0, 0.5 / 3.0)).x != 0.0\n#define KEY_3 texture(iChannel0, vec2((51.5) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_4 texture(iChannel0, vec2((52.5) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_5 texture(iChannel0, vec2((53.5) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_6 texture(iChannel0, vec2((54.5) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_7 texture(iChannel0, vec2((55.5) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_8 texture(iChannel0, vec2((56.5) / 256.0, 0.5 / 3.0)).x == 1.0\n#define KEY_9 texture(iChannel0, vec2((57.5) / 256.0, 0.5 / 3.0)).x == 1.0\n\n// Change BITCHECK to view the values of different bits when the B key is toggled on.\n// 1U is the lowest bit, 32U is the highest bit.\n// Anything higher than 32U will wrap.\n#define BITCHECK 1U\n\n// Change ivl to look at bigger or smaller distribution chunks.\n// Must be a value between 0.0 and 1.0 and evenly divisible into 1.0\n// or the distribution of the final chunk will be smaller than it should be.\nconst float ivl = 0.01;\n\n// Various constants for mixing and converting bits.\nconst uvec4 shft = uvec4(14U, 15U, 16U, 17U);\nconst float imf = 1.0 / float(0xFFFFFFFFU);\n\n// Edit: Simplifying the cyclic permutations of the inversion function\n// I used earlier reduces to this:\nuvec4 dblxoro128_inv(uvec4 x) {\n    return x ^ x.zwxy ^ x.wxyz;\n}\n\n// Explicit float to uint conversion with non-discrete control over scale and offset\nuvec4 cnvrtFloatToUint(vec4 crds, float scale, vec4 offst) {\n    return floatBitsToUint(floor(crds * scale + offst));\n}\n\n// Isolates bits\nuint isltBit(uint x, uint b) {\n    return (x << (32U - b)) >> 31U;\n}\n\n// bjhash128 hash at 12 int ops\nuvec4 bjhash128(uvec4 p) {\n    p ^= p >> shft;\n    p *= uvec4(0xEAF649A9U, 0x6AF649A9U, 0x050C2D35U, 0xAAF649A9U);\n    p ^= p.yzwx ^ p.zwxy;\n    p ^= p >> shft.yzwx;\n    p *= uvec4(0x21F0AAADU, 0x0D0C2D35U, 0xE8F649A9U, 0xD30332D3U);\n    p ^= p.yzwx ^ p.zwxy;\n    return p ^ p >> shft.wxyz;\n}\n\nuvec4 bjhash128_inv(uvec4 p) {\n    p ^= p >> shft.wxyz;\n    p.yz ^= p.yz >> (shft.xy << 1U);\n    p = dblxoro128_inv(p);\n    p *= uvec4(0x333C4925U, 0x12DC7D1DU, 0x349E6A99U, 0x3B43F55BU);\n    p ^= p >> shft.yzwx;\n    p.xw ^= p.xw >> (shft.yx << 1U);\n    p = dblxoro128_inv(p);\n    p *= uvec4(0x529E6A99U, 0xD29E6A99U, 0x5ADC7D1DU, 0x929E6A99U);\n    p ^= p >> shft;\n    p.xy ^= p.xy >> (shft.xy << 1U);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float tm = -iTime * 30.0;\n    uint modTime = uint(mod(iTime, 4.0));\n    float ffTime0 = fract(floor(iTime * 2.0) * ivl);\n    float ffTime1 = ffTime0 + ivl;\n    \n    vec4 plane = vec4(fragCoord, 0.0, 0.0);\n    vec4 offs = vec4(tm, tm, 0.0, 0.0);\n    \n    if (KEY_1) {\n        plane = vec4(fragCoord, 0.0, 0.0);\n        offs = vec4(tm, tm, 0.0, 0.0);\n    }\n    if (KEY_2) {\n        plane = vec4(fragCoord.x, 0.0, fragCoord.y, 0.0);\n        offs = vec4(tm, 0.0, tm, 0.0);\n    }\n    if (KEY_3) {\n        plane = vec4(fragCoord.x, 0.0, 0.0, fragCoord.y);\n        offs = vec4(tm, 0.0, 0.0, tm);\n    }\n    if (KEY_4) {\n        plane = vec4(0.0, fragCoord, 0.0);\n        offs = vec4(0.0, tm, tm, 0.0);\n    }\n    if (KEY_5) {\n        plane = vec4(0.0, fragCoord.x, 0.0, fragCoord.y);\n        offs = vec4(0.0, tm, 0.0, tm);\n    }\n    if (KEY_6) {\n        plane = vec4(0.0, 0.0, fragCoord);\n        offs = vec4(0.0, 0.0, tm, tm);\n    }\n    if (KEY_7) {\n        plane = vec4(fragCoord, fragCoord);\n        offs = vec4(tm);\n    }\n    if (KEY_8) {\n        plane = vec4(fragCoord.xx, fragCoord.yy);\n        offs = vec4(tm);\n    }\n    if (KEY_9) {\n        plane = vec4(fragCoord.x, fragCoord.yy, fragCoord.x);\n        offs = vec4(tm);\n    }\n    \n// This allows for non-discrete panning and scaling of float fields explicitly converted to uints\n// cnvrtFloatToUint(vec4 field, float scale, vec4 offset)\n// Scaling is also a convenient way to visually check for periodicity over arbitrary intervals\n    uvec4 crds128 = cnvrtFloatToUint(plane, 1.0, offs);\n\n    uvec4 p128 = bjhash128(crds128);\n    \n    vec4 res = vec4(p128) * imf;\n    \n    if (KEY_B) {\n        uint tval = p128.x;\n        if (KEY_X) tval = p128.x;\n        if (KEY_Y) tval = p128.y;\n        if (KEY_Z) tval = p128.z;\n        if (KEY_W) tval = p128.w;\n        \n        uint pval = isltBit(tval, BITCHECK);\n        if (pval == 0U) col = vec3(1.0);\n    } else {\n        if (KEY_D) {\n            float tstval = res.x;\n            if (KEY_X) tstval = res.x;\n            if (KEY_Y) tstval = res.y;\n            if (KEY_Z) tstval = res.z;\n            if (KEY_W) tstval = res.w;\n            if ((tstval > ffTime0) && (tstval < ffTime1)) {\n                col = vec3(1.0);\n            }\n        }\n        else {\n// Here I've mixed four channels into three.\n// Probably not the proper way to do it, \n// but it's still easy to see the contribution\n// of each channel to the output using this method.\n            col = (vec3(0.66, 0.66, 1.0) * res.xyz) + (vec3(0.33, 0.33, 0.0) *  vec3(res.ww, 0.0));\n            \n            if (KEY_X) col = res.xxx;\n            if (KEY_Y) col = res.yyy;\n            if (KEY_Z) col = res.zzz;\n            if (KEY_W) col = res.www;\n        }\n    }\n\n// Change this to 1 to invert the output of the hash.\n// If the hash successfully inverted, all the pixels will be green,\n// otherwise they will be red.\n#if 0\n    uvec4 ivrtres = bjhash128_inv(p128);\n    if (all(equal(ivrtres, crds128))) col = vec3(0.0, 1.0, 0.0);\n    else col = vec3(1.0, 0.0, 0.0);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}