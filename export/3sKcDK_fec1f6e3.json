{"ver":"0.1","info":{"id":"3sKcDK","date":"1603793905","viewed":602,"name":"Multi-Stop Linear Gradient","username":"liammartens","description":"This is a multi-stop linear gradient shader with relative start and end positions. It normalizes the GL coordinates to be top-left coordinated - meaning the gradient start position of 0,0 is top left and 1,1 is bottom right.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // these should be uniforms\n    vec2 gradient_start_pos = vec2(0.0, 0.0); // top-left\n    vec2 gradient_end_pos = vec2(1.0, 1.0); // bottom-right\n    \n    // define colors and stops\n    const int num_stops = 4;\n    float stops[32];\n    vec4 colors[32];\n    stops[0] = 0.0;\n    stops[1] = 0.2;\n    stops[2] = 0.6;\n    stops[3] = 1.0;\n    colors[0] = vec4(1.0, 0.0, 0.0, 1.0);\n    colors[1] = vec4(0.0, 0.0, 0.0, 1.0);\n    colors[2] = vec4(1.0, 1.0, 0.0, 1.0);\n    colors[3] = vec4(0.0, 1.0, 1.0, 1.0);\n    \n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.y = (uv.y - 1.0) * -1.0;\n    \n    \n    float alpha = atan(\n        gradient_end_pos.y - gradient_start_pos.y,\n        gradient_end_pos.x - gradient_start_pos.x\n\t); // this is the angle of the gradient in rad\n    \n    float gradient_startpos_rotated_x = gradient_start_pos.x * cos(-alpha) - gradient_start_pos.y * sin(-alpha);\n    float gradient_endpos_rotated_x = gradient_end_pos.x * cos(-alpha) - gradient_end_pos.y * sin(-alpha);\n    float len = gradient_endpos_rotated_x - gradient_startpos_rotated_x;\n    float x_loc_rotated = uv.x * cos(-alpha) - uv.y * sin(-alpha);\n    \n    if (num_stops == 1) {\n        fragColor = colors[0];\n    } else if (num_stops > 1) {    \n        fragColor = mix(colors[0], colors[1], smoothstep(\n            gradient_startpos_rotated_x + stops[0] * len,\n            gradient_startpos_rotated_x + stops[1] * len,\n            x_loc_rotated\n        ));\n        for (int i = 1; i < 32 - 1; i++) {\n            if (i < num_stops - 1) {\n                fragColor = mix(fragColor, colors[i + 1], smoothstep(\n                    gradient_startpos_rotated_x + stops[i] * len,\n                    gradient_startpos_rotated_x + stops[i + 1] * len,\n                    x_loc_rotated\n                ));\n            } else { break; }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}