{"ver":"0.1","info":{"id":"tlGfDz","date":"1614173200","viewed":57,"name":"Weekly_21","username":"Defonsia","description":"Weekly_21 ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks FranciscoGarcia, IQ\n\n#define rot(a) mat2(cos(a),sin(a), -sin(a), cos(a))\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    return mod(p+0.5 * c, c) -0.5*c;\n    \n}\n\nfloat circulo(in vec3 p, float rad, vec3 pos){\n    \n    p -=pos;\n    p = p-vec3(0.0,4.0,0.0);\n\tp.y -= 0.6*abs(cos(cos(p.x*1.4) + 4.2*iTime));\n    float bouing = sdSphere(p, 1.);\n    return 1.-step(rad, length(p));\n}\n\n\n\n\n\n\n//################MAP##################\n\nfloat map(vec3 pos)// position 3d de la marche\n{   \n    \n    pos = opRep(pos, vec3(6.0,6.0,6.0));\n\n    pos.y -= 0.6*abs(cos(cos(pos.x*1.4) + 4.2*iTime));\n    \n    \n\n    \n    float bouing = sdSphere(pos, 1.);\n\n        \n    return bouing;\n    \n     \n}\n\n//#########################################\n\n\n\nfloat CastRay(vec3 ro, vec3 rd) \n{\n    float c = 0.0; //contact par defaut\n    \n    for (int i=0; i<64; i++) // 64 =nombre de arches max\n    {         \n        float ray = map(ro + rd * c); //nous changeronscette ligne apres\n        \n        if(ray<(0.0001*c))// distance min contact\n        { \n            return float (i)/32.;\n        }        \n        c += ray;    \n    }\n    return -1.0;\n}\n\nvec3 render (vec3 ro, vec3 rd) \n{    \n    float contact = CastRay(ro,rd); //appeldu raycast\n    \n    vec3 col =vec3 (0.0); //couleur par defaut du pixel\n    \n    if (contact == -1.0)//s'il ny a pas de contact en raymarch\n    {\n        col = vec3(0.0);//couleur du fond\n    }\n    else //s'il y a contact\n    {\n        col = vec3(1.0-contact);//couleur du volume\n    }\n    return col;    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center les uvs et l'echelle x=y\n    vec2 uv =-1.+2.* fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //definir les parametres denotre camera\n    vec3 cameraPos = vec3 (iTime*5.,1.,4.0);\n    vec3 cameraTar = vec3 (2.0,1.,0.0);\n    \n    //definir le vecteur de direction depuis la camera\n    vec3 forward = normalize (cameraTar- cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0,0.0), forward));\n    vec3 up = normalize (cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up +2. * forward);\n    \n    vec3 col= vec3(uv.x, uv.y,0.0);\n    \n    //la couleur de chaque pixel interroge la fonction render\n    col = render(cameraPos,viewDir);    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}