{"ver":"0.1","info":{"id":"wttSzf","date":"1581479110","viewed":159,"name":"Just Like, a rock... yeah.","username":"JackSolace","description":"physically based raytrace of a rock, procedural geometry seems to heck with the rendering alg that expects a sphere or other relatively flat surfaces.\n\nEnable AA at your own risk","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","ray","march","learn","pbr","rock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Feb 2020\n//Physically Based Raytrace of a rock? meatball? my brain? whos to say?\n\n#define PI 3.14159265359\n#define AA 1\n#define NUM_OCTAVES 8\n\n//Ray hit struct\nstruct Hit {\n\tvec3 pos;\n    vec3 normal;\n    float mat;\n};\n   \n//ray struct\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\n\n\n//fractal noise\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;//play with this\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * texture(iChannel0,x).x;\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n//geometric attenuation (or shadow factor)\nfloat geometric_attenuation(float roughness, float normal_look_angle, float normal_light_angle)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = normal_light_angle * sqrt(normal_look_angle * (normal_look_angle - normal_look_angle * r2) + r2);\n\tfloat gl = normal_look_angle * sqrt(normal_light_angle* (normal_light_angle - normal_light_angle * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\n//microfacets (minute roghness in the surface)\nfloat microfacet_distribution(float roughness, float normal_half_angle){\n\tfloat r2 = roughness * roughness;\n\tfloat d = (normal_half_angle * r2 - normal_half_angle) * normal_half_angle + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\n//Fresnel Reflection coefficient (vector)\nvec3 fresnel_vec(vec3 specular_color,float look_light_angle) {\n\treturn specular_color + (1.0 - specular_color) * pow((1.0 - look_light_angle),5.0);\n}\n\n//Fresnel Reflection coefficient (scalar)\nfloat fresnel_scalar(float f0, float f90, float look_half_angle) {\n    return f0 + (f90 - f0) * pow(1.0 - look_half_angle, 5.0);\n}\n\nfloat Burley(float linearRoughness, float normal_look_vector, float normal_light_angle, float light_half_angle) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * light_half_angle * light_half_angle;\n    float lightScatter = fresnel_scalar(1.0, f90, normal_light_angle);\n    float viewScatter  = fresnel_scalar(1.0, f90, normal_look_vector);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 spherical_harmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 dfg_karis(float roughness, float normal_look_angle) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * normal_look_angle)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//Cubic smooth minimum union function from user TinyTexel\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdSphere(vec3 pos, vec3 c, float r) {\n\treturn length(pos - c) - r;\n}\n\n//distance to plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\n//x  index is distance, y index is material type (sometimes other meta info)\nvec2 map_the_world(in vec3 p)\n{\n    //perturb the surface of the sphere using fractal noise\n    float perturbation = fbm(p/8.0)/5.0;\n\t//Plane is represented as a vec4 using ax+by+cz+w = 0 formulation\n    float to_sphere = sdSphere(p, vec3(0.0), 0.4);\n    to_sphere -= perturbation;\n\treturn vec2(to_sphere,1.0);\n\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ).x );  \n}\n\nHit march_ray(Ray ray, float tmax) {\n\tfloat t = 0.0;//current depth\n    float m = 0.0;\n    vec3 pos = vec3(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        pos = ray.origin + t*ray.direction;\n        //get dist to nearest surface\n        vec2 h = map_the_world(pos);\n        m = h.y;\n        //if we hit something break\n        if( h.x<0.0001) break;\n        if( t > tmax){m = 0.0; break;}\n        //step forward\n        t += h.x*0.9;\n    }\n    return Hit(pos, calculate_normal(pos), m);\n}\n\nvec3 render_ray(Ray ray) {\n\t// init \"sky\" color\n    vec3 color = vec3(0.1, 0.1, 0.1) * (1.0 + ray.direction.y) * 0.8;\n\n    // raytrace\n    Hit result = march_ray(ray,8.0);\n\n    vec3 light_pos = vec3(10.0);\n    vec3 light_dir = normalize(result.pos - light_pos);\n    vec3 look = -ray.direction;//vector to camera\n    \n    if (result.mat > 0.999){//hit someting\n       \n        vec3 half_vec = normalize(look - light_dir);\n        \n        //important angles\n        float normal_look_angle = clamp(dot(result.normal, look),0.0,1.0);\n        float normal_light_angle = clamp(dot(result.normal, normalize(light_pos)), 0.0,1.0);\n        float look_light_angle = clamp(dot(look, normalize(light_pos)), 0.0,1.0);\n        float normal_half_angle = clamp(dot(result.normal, half_vec), 0.0,1.0);\n        float look_half_angle = clamp(dot(look,half_vec), 0.0,1.0);\n        float light_half_angle = clamp(dot(normalize(light_pos),half_vec), 0.0,1.0);\n        \n        //material constants (play with these)\n        float metallic = 0.0; \n        float reflect_intensity = 1.0;\n        float specular_intensity = 2.5;\n        float roughness = 0.0;\n   \t\t\n        vec3 base_color = vec3(0.0);\n        //shadow check ray\n        Ray shadow_ray = Ray(result.pos+0.01*light_pos, normalize(light_pos));\n       \t//Ray Trace shadow\n        Hit shadow = march_ray(shadow_ray, 8.0);\n            \n        if (result.mat > 1.999) {//plane (play with theses values)\n            //checkerboard\n            base_color = 0.4 + mod(floor(6.0 * result.pos.z) + floor(6.0 * result.pos.x), 2.0)*vec3(0.5);\n            roughness = 0.1;//play with this\n        }else{//sphere (play with these values)\n        \tbase_color = vec3(0.2,0.2,0.2);//sphere color\n            roughness = 0.3;//play with this\n        }\n        \n        \n        float linear_roughness = roughness*roughness;\n        //init specular color\n        vec3 specular_initial = 0.04 * (1.0 - metallic) + base_color*metallic;\n        //init diffuse color\n        vec3 diffuse_initial = (1.0 - metallic) * base_color;\n        // Cook-Torrance\n        vec3 specular = (microfacet_distribution(linear_roughness,normal_half_angle) \n            \t\t* geometric_attenuation(linear_roughness, normal_look_angle, normal_light_angle))\n            \t\t* fresnel_vec(specular_initial,light_half_angle); \n       \t//This is the wierd one (lots of different solutions dpending on what you read)\n        vec3 diffuse = diffuse_initial * Burley(linear_roughness, normal_look_angle, normal_light_angle, light_half_angle);\n        \n        //combine\n        color = diffuse + specular;\n\n        //alter combo by shadows and light angle\n        color *= (specular_intensity * clamp( 1.0 - shadow.mat, 0.0, 1.0) * normal_light_angle);\n        //Reflection Check\n        vec3 ref_dir = reflect(ray.direction, result.normal);\n       \tRay reflected_ray = Ray(result.pos + 0.03*ref_dir,ref_dir);\n        Hit reflected = march_ray(reflected_ray,8.0);\n        \n        \n        //reflected Diffuse calculation\n        vec3 reflected_diffuse = spherical_harmonics(result.normal) * (1.0/PI);\n        //reflected Specular initial\n        vec3 reflected_specular = vec3(0.65, 0.85, 1.0) + reflected_ray.direction.y * 0.8;\n        //what did the reflect hit?\n        if (reflected.mat > 0.999) {\n            if (reflected.mat > 1.999) {\n                //reflected onto the gorund\n            \treflected_specular = 0.4 + mod(floor(6.0 * reflected.pos.z) + floor(6.0 * reflected.pos.x), 2.0)*vec3(0.5);\n            }else{\n                //reflected onto the sphere\n            \treflected_specular = vec3(0.2,0.2,0.2);\n            }\n        }\n        \n        //how to combine the diffuse and specular reflections\n        vec2 dfg = dfg_karis(roughness, normal_look_angle);\n        vec3 spec_color = specular_initial * dfg.x + dfg.y;\n        vec3 reflected_combo = diffuse_initial * reflected_diffuse + reflected_specular * spec_color; \n        //combine 1st and second bounces\n        color += reflected_combo*reflect_intensity;\n        \n    }\n\n    // gamma color calculation    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n//Camera + Ray Setup\n//----------------------------------------------------------------------\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.25*cos(an), 0.4, 1.25*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize total color\n    vec3 total = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    #else  \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    Ray ray = Ray(ray_origin, ray_direction);\n    \n//Render Fragment\n//----------------------------------------------------------------------\n    \n\ttotal += render_ray(ray);\n        \n    #if AA>1\n    }\n    total /= float(AA*AA);\n    #endif\n\n    total = pow(total, vec3(1.0/2.2));\n    \n\tfragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}