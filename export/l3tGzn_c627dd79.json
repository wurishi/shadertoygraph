{"ver":"0.1","info":{"id":"l3tGzn","date":"1718198466","viewed":222,"name":"gears ball  3 ","username":"shadertoyjiang","description":"Use the mouse\n\ngears ball 2 :[url=https://www.shadertoy.com/view/McKSD3]https://www.shadertoy.com/view/McKSD3[/url]","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["mouse","gears","ball","icosahedron","dodecahedron","gear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 2024年5月18日09时\n// 齿轮球\n\n\n\nconst float speed=min(24., 1.);\n\nconst bool far = false;\n\n//#define time (iTime -2.8)\n#define time (iTime - 5.25 + 0.)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI    3.14159265358979\n#define TU    6.28318530717957\n#define df    1.61803398874989  // (sqrt(5.)*.5+.5)\n#define xf    0.61803398874989  // (sqrt(5.)*.5-.5)\n#define RS iResolution.xy\n#define MS iMouse.xy\n#define IMS ivec2(MS/RS*2.)\n#define SID (IMS.y*2+IMS.x)\n#define SZ  \n\nint obj;\nmat3 gmtr;\n\nvec4 fclr[7];\nfloat mindist;\nfloat txtchi;\nbool xijie;\n\n\nfloat smin(float a, float b, float k){float h = clamp(.5+.5*(a-b)/k, 0., 1.);return mix(a, b, h) - k * h*(1.-h);}\nfloat smax(float a, float b, float k){return smin(a, b, -k);}\n\n\nmat3 rot3(vec3 n, float a)\n{\n        //n = normalize(n);\n        float s = sin(a), c=cos(a), e=1.-c,\n              x = n.x, y = n.y, z = n.z;\n        return mat3( e*x*x+c,   e*y*x-z*s, e*z*x+y*s,\n                     e*x*y+z*s, e*y*y+c,   e*z*y-x*s,\n                     e*x*z-y*s, e*y*z+x*s, e*z*z+c );\n}\n\n\nfloat cube2(vec2 p, vec2 a){return length(  max(abs(p)-a, 0.) );}\n\n\nfloat txtm(vec3 p, int N, float d0)\n{\n        if(d0>.2)return 0.; // 影响速度与距离场，如果有黑点加大这个\n        float a=1., b=1.,s;\n        for(int i;i<N;i++)\n                s+=a*length(p*b*20.-round(p*b*20.))/20./9.,\n                a*=.3,\n                b*=2.;\n        return s;\n}\n\n\nfloat gyd(vec3 p, float r){return dot(cos(p),sin(p.yxz))+r;}\n\n\nfloat nisp(float alf, float rd, float num, vec3 pos, int ob)\n{\n        //if(xijie==false)return 0.;\n        vec3 p = vec3(cos(-alf+vec2(0,33))*rd, .5),q = normalize(pos);\n        vec4 w = normalize(vec4(alf,rd,.5,1));\n        p = normalize(p);\n                \n        float i,s,a=1. ,n=3.;\n        // 12\n        for(;i<22.;i++,pos=pos.yzx,w=w.yzwx)\n        {\n                s += a*( cos (dot(p.xyzz,w)*.1+ abs(sin(n*p).x+w.x))+gyd(p*n, p.x+w.x));\n                a = a*.75;\n                n = n* (ob==1? 2.5 : 2. ); // 1.5 2. 3. 5. 8. 2.5  2.1\n        }\n        //s=s/19.;\n        return clamp((.5-.5*cos(s*1.5) )  - .3  ,0.,1.); //-.3\n}\n\n\nfloat rkug=.9;\nfloat shl(vec3 p, vec3 a)\n{// 第一个支架：框形支架\n        vec3 q = p, e = vec3(1. SZ), n ;\n        float mx, v, x,y, d1,d2,d3, r = rkug;\n        \n        \n        float rk=abs(length(p)-rkug);if(rk>.25){mindist= min(mindist,rk-.23);return mindist;}\n        \n        for(int i;i++<3;q=q.yzx)\n        {\n                v = dot(q, a);\n                if(v>mx)mx=v, p=q;\n        }\n        // 方梁距离 d1\n        n = normalize(cross(e,a));\n        y = dot(p, n);\n        x = length(p-y*n)-r;//*size;\n        d1 = cube2(vec2(x,y), vec2(.06, .03) )-.01;\n        \n        // 求轴孔距离 d2\n        n = normalize(e);\n        y = dot(p, n);\n        x = length(p-y*n)-.1;\n        d3 = abs(length(p)-r-.02)-.05; // 不连接球心\n        d2 = smax(x, d3, .01);\n        \n        // 粘合方梁与轴孔\n        d1 = smin(d1,d2, .05);\n        \n        d1-=txtm(p,1,d1);\n        \n        if(d1<mindist)mindist=d1, obj = 1;\n        return d1;\n}\n\n\nfloat knr(vec3 p, vec3 n)\n{\n        float h = dot(p, n),\n              r = length(p);\n        \n       // if(r>.8){mindist= min(mindist,r-.75); return mindist;};\n        \n        float d1 = r-.7,  // 高\n              d2 = r-.25, // 小球\n              d3 = length(p - h*n)-.06, // 孔外径\n              d  = smin(max(d1,d3), d2, .4);;\n        d-=txtm(p,2,d);\n        if(d<mindist)mindist=d, obj=2;\n        return d;\n}\n\n\nfloat axi(vec3 p, vec3 n, float isfv)\n{\n        float suo = clamp(1.6+1.*cos(time*.3),(isfv<.5?.95:0.68),1.);//,0.25,1.);\n        \n        float h = dot(p, n),\n              r = length(p),\n              d = length(p - h*n)-.04 SZ; // 轴径，略小于孔外径\n        d = max(r-suo-.05  SZ, d);\n        if(isfv<.5)d= max(d, rkug SZ-r);        // 对应于框架一的 框半径\n        if(d<mindist)mindist=d, obj=(r<suo?6:3);\n        return d;\n}\n\n\nfloat ptn(vec3 p)\n{\n        //if(xijie==false)return 0.;\n        vec3 a=vec3(60,60,30), \n             b=vec3(20,60,30),\n             q=p*rot3(a,dot(p,b)),\n             c=sin(p*3.567*a),\n             d=p*b+.1*cos(q*a);\n        return length(c*d-round(c*d))/length(d+a)/29.;\n}\n\n\nfloat flr(vec3 p)\n{// 地面\n\n        float d =dot(p, normalize(vec3(0, 1,(far==true? -1.5: -2. ))) )- -1. ;\n        if(d<mindist)mindist=d, obj = 0;\n        return d;\n}\n\n\nfloat ger(vec3 p, vec3 nv, vec3 nf,float numfld, float isfv)\n{\n        float rotspeed=1.;\n        float aa;\n        vec3  y = nv,\n              z = normalize(cross(nf-nv,y)),\n              x = normalize(cross(y,z)),\n              q = vec3(dot(p,x),dot(p,y),dot(p,z));\n        \n        float suo = clamp(.7+2.*cos(time*.3),0.,1.);//,0.25,1.);\n        if(suo<.01)return mindist;\n        //if(   abs(q.y-1.)>.13)return abs(q.y-1.)-.12;\n        q.xz/=suo;\n        float d, d1, d2,d3,d4,h,\n              a = atan(q.z, q.x), \n              r = length(q.xz),\n              rp = 1. SZ,\n              rc = rp * tan(acos(dot(nv,nf))/2.),\n              hvf = q.y - rp,\n              rvf  = r-rc+.08;\n              \n        int ob;\n        if(mod(numfld+.5, 2.)>1.)a=-a;\n        if(isfv>.5)a+=PI/2.,ob=1-ob; // 是面心\n                \n        {\n                // 公共求距离\n                vec2 dd=vec2(r, length(p-dot(p, nf)*nf)/suo)-rc+.03\n                       -.05*(.5+vec2(-.5,.5)*sin(30.*(a+  (suo<.9?0.: time* rotspeed ))));\n                //\n                if(dd.x<dd.y)ob=1-ob; d1 = min(dd.x, dd.y);\n                //if(d1<d2)ob=1-ob; d1 = min(d1, d2);\n                d1 = max(d1, abs(hvf)-.02); // 压扁\n                d1 = max(d1, max(-rvf, 0.)-.03); // 挖空齿心\n                d1 = max(d1, length(p)-1.06);// 倒角        \n                //if(d1<mindist)mindist=d1, obj = 4;\n        }\n        \n        {\n                d2 = max(abs(hvf)-.04, rvf+.2); // 轴套。这里用加是因为前面减了\n                //if(d2<mindist)mindist=d2, obj = 4;\n        }\n        \n        {\n                // 辐条\n                vec2 ag = vec2(5,6)*(a-numfld*TU/vec2(5,3)+(suo<.9?0.:time* rotspeed ));\n                float ra = r-rc+.08;//rvf\n                \n                if(isfv<.5)\n                        aa=ag.y,\n                        d = length(vec2(hvf, (.5+.5*cos(ag.y))*(.1-abs(rvf)) ))-.008;\n                else\n                        aa=ag.x,\n                        d = length(vec2(hvf, (.5+.5*sin(ag.x))*(.2+rvf     ) ))-.04;\n                d3 = max(d, rvf-.01);\n                d3 = max(d3, length(p)-1.06);// 倒角        \n                \n                //if(d3<mindist)mindist=smin(mindist,d3,.03), obj = 4;\n       \n        }\n        d = smin(min(d1,d2),d3, .01);\n        if(ob==1)d-=.006 *(txtm(q-q+aa+sin(d+aa*rvf*345.)*123.,12, d)-txtm(q+rvf+cos(aa*198.+rvf)*456.,12, d));// 微表面，粉 05291042\n        if(d<mindist)mindist=d, obj = 4+ob;\n        //                              \n        if(iMouse.y/iResolution.y>.75)\n        {     if(xijie==true)txtchi=nisp(aa/5.,rvf * 6. + 55.,numfld,q,ob); }// 固定    \n        else\n        {     if(xijie==true)txtchi=nisp(a    ,rvf   ,numfld,q,ob);}\n        //{     if(xijie==true)txtchi=nisp(aa  *5.   ,rvf *12.   ,numfld,q,ob);}\n        //{     if(xijie==true)txtchi=nisp(aa   ,rvf  ,numfld,q,ob);}\n        \n        return d;\n        \n}\n\n\nfloat gearsball(vec3 pos)\n{// 齿轮组\n        obj=0;\n        mindist = 1e9;\n        float drd = length(pos)-0. SZ;\n        if(drd>1.15 SZ)return drd-1.1;\n        \n        float numfld, isfv, mx, d;\n        \n        vec3 p = pos *gmtr,\n             q, pvf,\n             e = vec3(1),\n             a = vec3(0, xf, df), \n             b = a.yzx,\n             nv = normalize(e),               // 点心\n           //ne = normalize(a+e),             // 线心\n             nf = normalize(cross(e-b, e-a)), // 面心\n             nea = normalize(e-a),            // 十二面体折叠\n             nvf = normalize(nv-nf),          // 面心向点心折叠\n             nx = nf-nv,                      // 投影 (nx,ny,nz)\n             ny = nv,\n             nz = normalize(cross(nx, ny));\n             nx = normalize(cross(ny, nz));\n             \n\n        // 折叠\n        for(int i;i++<9;nea=nea.yzx)\n                if(dot(p, nea)<0.)p=reflect(p, nea), numfld++;\n        // 三面折叠        \n        q=p;mx=0.;\n        for(int i;i++<3;q=q.zxy)\n        {\n                d=dot(q, nf);\n                if(mx<d)mx=d,p=q;\n        }\n        // 面心向点心折叠\n        pvf=p;if(dot(p, nvf)<0.)pvf=reflect(p, nvf), isfv++;     \n        \n        \n        ////float flr=flr(pos);   // 地面   \n        float shl=shl(p, a);  // 框架\n        float knr=knr(p, nf); // 中心\n        float axi=axi(pvf, nv, isfv); // 转轴\n        \n        drd=abs(drd-1.)-.14;  if(drd>0.)mindist=min(mindist, drd+.02);else        \n                ger(pvf, nv, nf, numfld, isfv);\n        \n        return mindist;\n}\n\n\nfloat map(vec3 p)\n{\n        float d= flr(p);if(d<.085)  d-=ptn(p);\n        //return min(gearsball(p*gmtr), d);\n        return min(gearsball(p), d);\n}\n\n//  2024年5月21日\n// www.shadertoy.com/view/4ssGzS\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n        float stp=.3,\n              ao = 0.,\n              dist,i;\n        for(i=.1;i <=6.1;i++)\n        {\n                dist = stp*i;\n                ao += max(0., (dist - map(p + n * dist))/dist);\n        }\n        return clamp(1. -  .1 * ao/i,0.,1.);\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd, float k)\n{\n   float res = 1.;\n   float t=.05;//, k=2e2;\n   for(int i =0;i<256 && t<2.;i++)\n   {\n               float h = map(ro + rd * t);\n               if(h<.001)return 0.;\n               res = min(res, k*h/t);\n               t += h;\n   }\n   return res;\n}\n\n\nvoid init()\n{\n        gmtr=mat3(1);\n        \n        gmtr*=rot3(vec3(1,0,0),-3.5*(length(MS)<2.?.2:MS.y/RS.y-.5));  //3.5* 相球于动作正负 PI/2\n        gmtr*=rot3(vec3(0,1,0), 3.5*(MS.x/RS.x-.5));\n        gmtr*=rot3(vec3(0,1,0),time*.2);\n        gmtr*=rot3(vec3(1,0,0),PI/4.);\n        gmtr*=rot3(vec3(0,1,0),PI/4.);\n        \n        \n        fclr = vec4[](\n                        vec4(1.6,.4,0,1) , // 0 也相当于背景色\n                        vec4(0,.5,1,1),   // 1 框架\n                        vec4(.15,.6,.1,1),// 2 心刺\n                        vec4(.4,.6,.9,1), // 3 暗蓝 地面\n                        \n                      //vec4(1.5,1.15,.15,1)*.5, // 4 黄夕金\n                      //vec4(1,.5,.5,1).yxxx,//暗紫\n                      //vec4(4.,.5,.15,1)*.4, // 橙\n                      //vec4(2.,.15,.15,1)*.5 ,// 4 暗红\n                      //vec4(1,.5,1,1),//紫\n                        vec4(4.,.15,.15,1)*.5 + .0,// 4 红\n                        \n                     \n                     vec4(2,.8,0,1)*.8+.2,    // 4 金第一齿轮 .yxzw\n                     // vec4(1), // vec4(0, 2 , .5,1).zyzz,// 5 绿\n                        //vec4(2,.5,0,1).zwww*.8+.2,   // 5 第二齿轮 .xyzw  .zyyw  .xyyw .zxxw .zwww\n                        vec4(2)           // 6 银色\n                     );\n        // 另一种\n        //fclr[5]=pow(fclr[5],vec4(2.)), fclr[0]=fclr[0].yyzw;\n        \n        if(MS.x>RS.x*3./4.)\n                 //fclr[1]=fclr[2]=vec4(1.5),\n                 fclr[4]=fclr[5]=vec4(1.5);\n                 \n}\n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n        init();\n        O = vec4(.5);\n        vec2 R = iResolution.xy,\n             u = (U+U - R) / R.y;\n        vec3 eye = vec3(0, 0, -2 ),\n             dir = normalize(vec3(u, (far==true?1.3:1.5))),\n             sun = 5. * ( .2*cos(time+vec3(7,11,13)) + vec3(-1,2,-3)/3.74 ),\n             eps = vec3(0, .0001, 0),\n             nor, p;\n        float d , t;\n        for(int i; i++<168 && t<30.;)\n        {\n                p = eye + dir * t;\n                d = map(p);\n                if( d<.001*speed )\n                {       // phong 光照模型\n                        int objct=obj;\n                        \n                        xijie=true;\n                           \n                        float dx=map(p+eps.yxx);\n                        xijie=false;\n                        \n                        nor = normalize(vec3(dx, map(p+eps), map(p+eps.xxy))-d); \n                        vec3  sp = normalize(sun-p), ep=normalize(eye-p);\n                        float ln = max(0., dot(nor,sp)),               // light norm\n                              er = max(0., dot(ep, reflect(-sp,nor))), // eye ray\n                              sh = .1+.9*softshadow(p-dir*d*5., normalize(sun-p), 2e2),\n                              ao = 1.;//ambientOcclusion(p, dir);\n                        \n                        vec4  lightClr;// = vec4(1,.5,0,1);\n                        if(objct<fclr.length())lightClr=fclr[objct];                                                \n                        \n                        float ambt=.015, difu=.3, spec=1., spw=4.;\n                        if(objct==4 || objct==5)\n                        {\n                              ambt=.08,difu=.2, spec=3., spw=5.;  //8.    //1304\n                              //lightClr += clamp((texture(iChannel0, reflect(sp,nor))-.5)*8.+.5,0.,1.);//*pow(er, 2.);\n                              lightClr += clamp(.02+txtchi,0.,1.);//*pow(er, 2.);\n                              \n                        }\n                        if(objct==6)difu=0.,ambt=.02,spw=10.,spec=30.;\n                        //ambt=.02;\n                        \n                        //if((objct==1) || (objct==2))   lightClr*= clamp( 1.*(vec4(.8,.3,.1,1)+.2+ 2.*softshadow(p-dir*d*5., normalize(sun-p), 3.))   ,0.,1.);\n                        \n                        //O = lightClr * (ambt + difu*ln) +  spec*pow(er, spw)+ 20. * pow(er, 80.);// O *= vec4(1,.8,.7 ,0);\n                        \n                        \n                        O = lightClr * (ambt + difu*ln + spec*pow(er, spw)+ 200. * pow(er, 80.));\n                        \n                        //if(objct==0)ao = ambientOcclusion(p, dir);\n                        //O *= ao;\n                        \n                        //O.z+=.05;// 冷色\n                        //O *= sh;\n                        O=clamp(O,0.,1.);\n                        O *= sh;\n                        //O = sqrt(O);\n                        O = pow(O, vec4( max(3.-iTime*.5, .65)));//(iDate.w/3600.>6.&&iDate.w/3600.<20.?.6:.7) )));// .6+.3*fract(iTime*2.)) )); // .5 .6 .7 1. 2.5\n                        O*=1.3;\n                        break;\n                }\n                t += d * .7;\n        }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}