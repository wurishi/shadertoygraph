{"ver":"0.1","info":{"id":"wt3cRX","date":"1609601443","viewed":44,"name":"Sphere_deformed","username":"regis","description":"sphere deformed","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 70.\n#define SURF_DIST .01\n#define EPSILON 0.01\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat forme(vec3 p, vec3 s){\n    return min(length(max(abs(p)-s, 0.)), 0.01);\n\n}\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a+=dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\n\nfloat GetDist2(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    \n    \n    /***********************************/\n    float m = 0.;//N22(uv).x;\n    float t = iTime;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    float py = p.y;\n     vec2 uv = p.xy;\n     uv*= 2.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0);\n    for (float y=-1.; y <= 1.;y++){\n        for (float x=-1.; x <= 1.;x++){\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            vec2 q = offset+sin(n*t)*.5;\n            q -= gv;\n            float ed = length(q);\n            float md= abs(q.x) + abs(q.y);\n            float d = mix(ed, md, sin(iTime)*.5+.5);\n            if(d < minDist){\n                minDist = d;\n                cid = id+offset;\n            }\n        }\n    }\n    //col = vec3(minDist);\n    //col.rg = cid*.1;\n    \n   /*  for(float i=0.;i < 50.;i++){\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n*t);\n\n            float d = length(uv-p);\n            m += smoothstep(.05, .01, d);\n\n            if(d < minDist){\n                minDist = d;\n                cellIndex = i;\n            }\n\n        }*/\n    \n    \n    \n    /*************************************/\n    \n    float planeDist = dot(p, vec3(0.0, 1.0, 0.0)) ;\n    //planeDist *= minDist;\n    float d = max(planeDist/minDist*0.01, py);\n    d  = min(d, sphereDist/minDist*0.01);\n    \n    return d;\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,1.5, 5, 1);\n    \n    float planeDist = p.y;\n    float sphereDist = length(p-s.xyz)-s.w;\n    //float sphereDist = CubeApproxSDF(p, 2.0);\n    \n    float d = min(sphereDist, planeDist);\n    \n    return d;\n\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++){\n\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n          if(dO >MAX_DIST || dS < SURF_DIST)break;\n    }\n    \n    return dO;\n\n\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    //float cubeDist = cubeSDF(samplePoint) * 1.2;\n    return unionSDF(samplePoint.y, sphereDist);\n}\n\nfloat RayMarch2(vec3 eye, vec3 viewRayDirection){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = GetDist2(eye + depth * viewRayDirection);\n        if (dist < SURF_DIST) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= MAX_DIST) {\n            // Gone too far; give up\n            return MAX_DIST;\n        }\n    }\n    return end;\n\n\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist2(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist2(p-e.xyy),\n        GetDist2(p-e.yxy),\n        GetDist2(p-e.yyx));\n        \n    return normalize(n);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch2(p+n*SURF_DIST, l);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    uv -= 0.5;\n     uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 col = vec3(1.0);\n    \n    vec3 ro = vec3(0, 2.0, -1.0);\n    ro.xy *= Rot(6.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch2(ro, rd);\n    vec3 p = ro +rd * d;\n    \n    float dif =GetLight(p);\n    col = vec3(dif)+ vec3(0.5, 0.0, 0.2);\n    \n    float m = 0.;//N22(uv).x;\n    float t = iTime;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n     //vec2 uv = p.xy;\n     uv*= 10.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0);\n    for (float y=-1.; y <= 1.;y++){\n        for (float x=-1.; x <= 1.;x++){\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            vec2 p = offset+sin(n*t)*.5;\n            p -= gv;\n            float ed = length(p);\n            float md= abs(p.x) + abs(p.y);\n            float d = mix(ed, md, sin(iTime)*.5+.5);\n            if(d < minDist){\n                minDist = d;\n                cid = id+offset;\n            }\n        }\n    }\n    if(uv.y < minDist-4.0){\n    //mix(1., 3., smoothstep(-1., 1., bp.y))\n    col *= mix(1.,3., minDist);\n    col.rg *= cid*.1;\n    }\n    \n    \n    /*float c = 0.5 * sin(uv.x * 10.0) * cos(sin(iTime + uv.y)*20.0);\n    //col = vec3(1.0);\n    if(length(uv) < 0.5){\n    \n     col *= vec3(sin(c * 0.2 * cos(iTime)), c*0.75, cos(c * 0.1*iTime / 0.4) *0.1);\n    //col = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    else\n    {\n        col *= vec3(sin(c * 0.2 * cos(iTime)), c*0.5, sin(c * 0.5*iTime / 0.4) *0.1);\n    \n    }*/\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n} ","name":"Image","description":"","type":"image"}]}