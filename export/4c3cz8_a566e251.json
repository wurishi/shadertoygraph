{"ver":"0.1","info":{"id":"4c3cz8","date":"1730210000","viewed":78,"name":"galaxy in ellipsoid","username":"nayk","description":"source https://www.shadertoy.com/view/MdXSzS","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fractal","galaxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec3 inp) {\n    vec3 i = floor(inp);\n    vec3 f = fract(inp);\n\n    f = f * f * (3.0 - 2.0 * f); // Smootherstep interpolation\n\n    float n = dot(i, vec3(1.0, 57.0, 113.0)); // New, smoother hash basis\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat perlin_part(vec3 inp)\n{\n    vec3 fl = floor(inp);\n    vec3 fr = fract(inp);\n   \n    fr = smoothstep(0.0, 1.0, fr);\n   \n    float L = fl.x;\n    float R = fl.x + 1.0;\n    float T = fl.y;\n    float B = fl.y + 1.0;\n    float T0 = fl.z;\n    float T1 = fl.z + 1.0;\n   \n    float LT0 = noise(vec3(L, T, T0));\n    float LT1 = noise(vec3(L, T, T1));\n    float LB0 = noise(vec3(L, B, T0));\n    float LB1 = noise(vec3(L, B, T1));\n    float RT0 = noise(vec3(R, T, T0));\n    float RT1 = noise(vec3(R, T, T1));\n    float RB0 = noise(vec3(R, B, T0));\n    float RB1 = noise(vec3(R, B, T1));\n   \n    float LT = LT0*(1.0-fr.z) + LT1*fr.z;\n    float LB = LB0*(1.0-fr.z) + LB1*fr.z;\n    float RT = RT0*(1.0-fr.z) + RT1*fr.z;\n    float RB = RB0*(1.0-fr.z) + RB1*fr.z;\n   \n    float l = LT*(1.0-fr.y) + LB*fr.y;\n    float r = RT*(1.0-fr.y) + RB*fr.y;\n   \n    float final = l*(1.0-fr.x) + r*fr.x;\n   \n    return final;\n}\n\nvec3 colors0[10] = vec3[10](\n    vec3(0.1, 0.4, 0.7), // Deep blue\n    vec3(0.2, 0.5, 0.8), // Soft sky blue\n    vec3(0.15, 0.45, 0.65), // Muted ocean blue\n    vec3(0.1, 0.45, 0.6), // Teal blue\n    vec3(0.08, 0.35, 0.55), // Dark cyan\n    vec3(0.12, 0.48, 0.7), // Sea blue\n    vec3(0.1, 0.4, 0.5), // Slate teal\n    vec3(0.18, 0.42, 0.7), // Cornflower blue\n    vec3(0.1, 0.35, 0.65), // Stormy blue\n    vec3(0.12, 0.4, 0.6)); // Aqua marine\n   \nvec3 colors1[3] = vec3[3](\n    vec3(0.48, 0.09, 0.15), // Deep Ruby\n    vec3(0.69, 0.19, 0.66), // Amethyst Purple\n    vec3(0.85, 0.50, 0.54));  // Olive Green\n   \nvec3 colors2[3] = vec3[3](\n    vec3(1.0, 0.78, 0.86),  // Light Pink\n    vec3(1.0, 0.56, 0.71),  // Hot Pink\n    vec3(1.0, 0.88, 0.0));    // Sunset Yellow\n   \nvec3 colors3[3] = vec3[3](\n    vec3(0.18, 0.1, 0.32),  // Dark Cosmic Blue\n    vec3(0.52, 0.33, 0.75), // Purple Nebula\n    vec3(0.9, 0.8, 0.18));   // Pastel Aqua);    // Sunset Yellow\n\nfloat perlin(vec3 inp)\n{\n    int layers = 15;\n    float mult = 0.85;\n\n   \n    inp += 3.0;\n\n    float f = 0.0;\n    float m = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < layers; i++)\n    {\n        f += perlin_part(inp/m) * m;\n        s += m;\n        m *= mult;\n    }\n    f /= s;\n    return 0.5+0.5*sin(f*6.28318530718);\n}\n#define R(p,a,r) mix(a*dot(p,a),p,cos(r)) + sin(r)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+5.*cos(iTime)+.5)\n\nvec3 color3(float t) {\n  vec3 c1 = vec3(1.0, 0.0, 0.0);\n  vec3 c2 = vec3(0.0, 1.0, 0.0);\n  vec3 c3 = vec3(0.0, 0.0, 1.0);\n  vec3 c4 = vec3(1.0, 1.0, 0.0);\n  vec3 c5 = vec3(1.0, 0.0, 1.0);\n  vec3 c6 = vec3(0.0, 1.0, 1.0);\n\n  float r = sin(t) * 0.5 + 0.5;\n  if (r < 0.2) return mix(c1, c2, r * 5.0);\n  if (r < 0.4) return mix(c2, c3, (r - 0.2) * 5.0);\n  if (r < 0.6) return mix(c3, c4, (r - 0.4) * 5.0);\n  if (r < 0.8) return mix(c4, c5, (r - 0.6) * 5.0);\n  return mix(c5, c6, (r - 0.8) * 5.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n \n\nvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n\nfloat v1, v2, v3;\nv1 = v2 = v3 = 0.0;\nvec2 uv2 = fragCoord/iResolution.y;\n   \n    uv2 += iTime*0.04;\n      // Sphere properties\n    vec3 sphereCenter = vec3(0.0, 0.0, 5.0);\n    float sphereRadius = 1.0;\n\n    // Light properties\n    vec3 lightPos = vec3(1.5, 2.0, 2.0);\n    vec3 lightColor = vec3(1.0, 0.8, 0.6);\n\n    // Camera properties\n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv, 1.5));\n\n    // Calculate intersection with the sphere\n    vec3 oc = cameraPos - sphereCenter;\n    float b3 = dot(oc, rayDir);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float h = b3 * b3 - c;\n\n    vec3 color = vec3(0.0); // Initial color\n\n    if (h > 0.0) {\n        float t = -b3 - sqrt(h);\n        vec3 hitPoint = cameraPos + t * rayDir;\n        vec3 normal = normalize(hitPoint - sphereCenter);\n\n        // Ambient Effect\n        vec3 ambient = vec3(0.05, 0.05, 0.1); // Soft ambient light\n        color += ambient;\n\n        // Diffuse Effect\n        vec3 lightDir = normalize(lightPos - hitPoint);\n        float diff = max(dot(normal, lightDir), 0.0);\n        vec3 diffuse = diff * lightColor * vec3(0.4, 0.5, 0.9);\n        color += diffuse;\n\n        // Specular Effect\n        vec3 viewDir = normalize(cameraPos - hitPoint);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 15.0);\n        vec3 specular = spec * lightColor * vec3(1.0);\n        color += specular;\n\n        // Fresnel Effect\n        float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);\n        vec3 fresnelColor = mix(color, vec3(1.0, 1.0, 1.0), fresnel);\n        color = mix(color, fresnelColor, 0.5);\n\n        // Random Effect (subtle noise)\n        float noise = fract(sin(dot(hitPoint.xy, vec2(12.9898, 78.233))) * 43758.5453);\n        color += noise * 0.05 * color;\n    }\n\n\n\n\n\n   \n   \n    bool PLUS_SHADING = true;\n    vec4 fragColor2 = vec4(0);\n    vec3 p3, r3 = iResolution, d3 = normalize(vec3((fragCoord-.50*r3.xy)/r3.y,0.5));  \n       \n    for(float i = 0., g = 0., e, s; i < 99.; ++i)\n    {\n        p3 = g * d3;\n        p3.z -= 0.6;\n    p3.xz*=mat2(cos(iTime*20.),sin(iTime*20.),-sin(iTime*20.), cos(iTime*20.));\n  \n        s = 4.;\n\n        for(int j = 0; j++ < 13;)\n        {\n            p3 = abs(p3);\n               \n            p3 = p3.x < p3.y ? p3.zxy : p3.zyx;\n            s *= e = 1.8 / min(dot(p3, p3), 1.7);\n            p3 = p3 * e - vec3(15,3,2);\n        }\n\n        g += e = length(p3.xz) / s;\n        fragColor2.rgb += color3(iTime * 0.01 + i) * mix(r3 / r3, H(log(s)), 0.7) * 0.08 * exp(-i * i * e);\n    }\n   \n    fragColor = pow(fragColor, vec4(3));\n   \n    float r = perlin(vec3(uv2*0.7, iTime*0.05));\n    float g = perlin(vec3(1.0+uv2*0.7, iTime*0.05));\n    float b = perlin(vec3(2.0+uv2*0.7, iTime*0.05));\n    float d = PLUS_SHADING ? perlin(vec3(3.0+uv2*2.0, iTime*0.07))*3.0 : 1.0;\n   \n    float v = 5.0;\n   \n   vec4 fC = vec4(round(vec3(r, 0.5*g, b)/d*v)/v, 1.0);\nfloat s = 0.0;\nfor (int i = 0; i < 90; i++)\n{\nvec3 p = s * vec3(uv, 0.0);\n\np += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)*fragColor2.rgb*color;\nfor (int i = 0; i < 8; i++) p = abs(p) / dot(p,p) - 0.659;\nv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\nv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\nv3 += length(p.xy*10.) * .0003;\ns  += .035;\n}\n\nfloat len = length(uv);\nv1 *= smoothstep(1.2, .2, len);\nv2 *= smoothstep(.2, 1.0, len);\nv3 *= smoothstep(.5, .5, len);\n\nvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n(v1 + v3) * .3,\nv2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\nfragColor=vec4(min(pow(abs(col*fragColor2.rgb*2.), vec3(1.2)), 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}