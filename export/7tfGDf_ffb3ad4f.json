{"ver":"0.1","info":{"id":"7tfGDf","date":"1622989368","viewed":67,"name":"Fork Fork IOR r kithy 506","username":"kithy","description":"based on this tutorial.\nhttps://www.shadertoy.com/view/sls3WN","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","ior"],"hasliked":0,"parentid":"stlGDj","parentname":"Fork IOR reflec kithy 559"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define MAX_DIST 10.0\n#define SURF_DIST 0.001\n\n\nmat2 Rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash(vec2 n){\n\treturn fract(sin(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\n\nvec3 hash3(vec2 p){\n\tvec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat sphere(vec3 p){\n\treturn length(p)-2.0;\n}\n\nfloat octahedron(vec3 p,float s){\n    \n\tp=abs(p);\n\tfloat m=p.x+p.y+p.z-s;\n\tvec3 r=3.0*p-m;\n\t\n\tvec3 q;\n\tif(r.x<0.0)q=p.xyz;\n\telse if(r.y<0.0)q=p.yzx;\n\telse if(r.z<0.0)q=p.zxy;\n\telse return m*0.57735027;\n\n\tfloat k=clamp(0.5*(q.z-q.y+s),0.0,s);\n\treturn length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat GetDist(vec3 p){\n    p.xz*=Rot(iTime);\n    p.xy*=Rot(iTime);\n    float d=octahedron(p,1.5);\n    float s=sphere(p);\n    float a=sin(iTime*2.0)*0.5+0.5;\n    return mix(d,s,a);\n}\n\n\n\nfloat RayMarch(vec3 ro,vec3 rd,float side){\n    float dO=0.0;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*dO;\n        float dS=GetDist(p)*side;\n        dO+=dS;\n        if(dO>MAX_DIST||abs(dS)<SURF_DIST)break;\n      }\n      return dO;\n}\n\nvec3 GetNormal(vec3 p){\n        float d=GetDist(p);\n        vec2 e=vec2(0.001,0.0);\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx));\n \n        return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv,vec3 p,vec3 l,float z){\n    vec3 f=normalize(l-p),\n    r=normalize(cross(vec3(0.0,1.0,0.0),f)),\n    u=cross(f,r),\n    c=f*z,\n    i=c+uv.x*r+uv.y*u,\n    d=normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m=iMouse.xy/iResolution.xy;\n    \n    vec3 ro=vec3(0.0,0.0,-5.0);\n    ro.yz*=Rot(-m.y*3.14+1.0);\n    ro.xz*=Rot(-m.x*6.2831);\n   \n    \n    vec3 rd=GetRayDir(uv,ro,vec3(0.0),1.0);\n    vec3 col=texture(iChannel0,rd).rgb;\n    \n    \n    float d=RayMarch(ro,rd,1.0);\n    \n    float IOR=1.45;\n    \n    if(d<MAX_DIST){\n        vec3 p=ro+rd*d;\n        vec3 n=GetNormal(p);\n        vec3 r=reflect(rd,n);\n        \n        vec3 rdIn=refract(rd,n,1.0/IOR);\n        \n        vec3 pEnter=p-n*SURF_DIST*3.0;\n        float dIn=RayMarch(pEnter,rdIn,-1.0);\n        \n        vec3 pExit=pEnter+rdIn*dIn;\n        vec3 nExit=-GetNormal(pExit);\n        \n        vec3 rdOut=refract(rdIn,nExit,IOR);\n        if(dot(rdOut,rdOut)==0.0)rdOut=reflect(rdIn,nExit);\n        \n        vec3 refTex=texture(iChannel0,rdOut).rgb;\n        col=vec3(refTex);\n    }\n    \n    col=pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define hue(v) (0.6+0.6*cos(6.3*(v)+vec4(0.0,23.0,21.0,0.0)))\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 A=abs(rayDir);\n    int i=0;\n    float M=A.x;\n    if(A.y>M)M=A.y,i=1;\n    if(A.z>M)M=A.z,i=2;\n    int faceID=i+3*int(rayDir[i]<0.0);\n    \n    fragColor=hue(float(faceID)/6.);\n   \n    fragCoord=(fragCoord+fragCoord-iResolution.xy)/iResolution.y;\n    fragColor*=vec4(0.2*1.0/length(fragCoord));\n}\n\n\n\n","name":"Cube A","description":"","type":"cubemap"}]}