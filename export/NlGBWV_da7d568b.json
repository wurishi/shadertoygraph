{"ver":"0.1","info":{"id":"NlGBWV","date":"1665233589","viewed":66,"name":"Repetition (Raymarching 2.0)","username":"azeem","description":"Trying repetition through mod.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"NlKBzt","parentname":"Basic RayMarching using SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 128\n#define MAX_DIST 100\n#define PI 3.14159265359\n#define move 1   //set it to 0 for no movement\nvec2 distanceToScene(vec3 p){\n    //sphere 1\n    float r1=.125;\n    vec3 c1=vec3(.0,0.,0.);\n    float b=1.0;\n    #if move==1\n    p.z-=iTime;\n    #endif\n    p=mod(p,b)-b/2.;\n    //p.z=mod(p.z+b/2.,b)-b/2.;\n    //float d1=sphSDF(vec3(mod(p.x,b)-b/2.0,p.y,mod(p.z,b)-b/2.),c1,r1);\n    float d1=cubeSDF(p+0.006*simplex3d(p*40.+iTime),c1,r1);\n    return vec2(d1,2.);\n\n    //plane\n    float p1=p.y+.25;\n    return p1<d1?vec2(p1,1.):vec2(d1,2.);//returning with ids for coloring\n\n    //for some grainy texture\n    //return  vec2( min(d1,p1)+0.006*simplex3d(p*30.+iTime),p1<d1?1.:2.);\n\n    //cube1 or sphere 2\n    float r2=.24;\n    vec3 c2=vec3(sin(iTime+20.),0.,0.);\n    float d2=cubeSDF(p,c2,r2);\n    d2=smin(d2,d1,.5);//smooth sdf of cube and sphere\n    return d2<p1?vec2(d2,2.):vec2(p1,1.);\n    return  vec2( min(d2,p1)+0.006*simplex3d(p*30.+iTime),p1<d2?1.:2.);\n\n}\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(distanceToScene(p+h.xyy).x - distanceToScene(p-h.xyy).x,\n                           distanceToScene(p+h.yxy).x - distanceToScene(p-h.yxy).x,\n                           distanceToScene(p+h.yyx).x - distanceToScene(p-h.yyx).x ) );\n}\nvec2 marchRay(vec3 rayO, vec3 rayD,float nearClip){\n    float dis=0.;\n    float id;\n    vec2 d;\n    vec3 p=rayO+rayD*dis;\n    for(int i=0;i<STEPS;i++){\n        p = rayO+rayD*dis;\n        d=distanceToScene(p);\n        if(d.x<.001){\n            if(length(rayO-p)>nearClip)return vec2(dis,d.y);\n            dis+=1.;\n        }\n        dis+=d.x;\n        if( int(dis)> MAX_DIST)break;\n    }\n    return vec2(MAX_DIST+5,d.y);\n}\nfloat checkShadow(vec3 rayO,vec3 rayD){\n    float dis=0.;\n    float closestDist=1e4;//for soft shadows\n    vec3 p=rayO+rayD*dis;\n    for(int i=0;i<STEPS;i++){\n        p = rayO+rayD*dis;\n        float d=distanceToScene(p).x;\n        closestDist=min(closestDist,5.*d/dis);\n        if(d<.001)break;\n        dis+=d;\n        if( int(dis)> MAX_DIST)break;\n    }\n    return int(dis)>MAX_DIST?smoothstep(0.00001,1.,closestDist):0.0;\n    //return int(dis)> MAX_DIST?1.:0.0; //normal shadow\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 rayO;\n    #if move==1 \n    rayO = vec3(0.2, .5+.5*sin(iTime), 2.0);//camera pos\n    #else\n    rayO = vec3(0.2, .5, 2.0);//camera pos\n    #endif\n    vec3 lookPoint = vec3(0);//where to look\n    float zoom=1.;\n    float nearClippingPlane=.25;\n    //mouse camera binding//copied\n    vec2 mouseUV = iMouse.xy/iResolution.xy;if (mouseUV == vec2(0.0)||iFrame<1) mouseUV = vec2(0.5);float cameraRadius = 1.;rayO.yz = rayO.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));rayO.xz = rayO.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lookPoint.x, lookPoint.z);\n    vec3 rayD= camera(rayO, lookPoint) * normalize(vec3(uv, -zoom)); // ray direction\n\n    //starting col for the background sky\n    vec3 col=mix(vec3(.0,.5,.8) ,vec3(.6), pow(smoothstep(0.5,0.,uv.y),2.) ) ;\n    col*=0.0;\n    vec2 dis=marchRay(rayO,rayD,nearClippingPlane);\n    vec3 p=rayO+dis.x*rayD;\n    if(int(dis.x)<MAX_DIST){\n    vec3 mate;\n        if(dis.y<1.5)mate=vec3(0.9,.2,0.3);// plane color\n        else mate=vec3(0.3,0.3,.3); //objects color\n        vec3 normal=calcNormal(p);\n        vec3 light_dir = normalize(vec3(.6, .3, .8));       \n        //orbiting sun\n        //light_dir = normalize(vec3(sin(iTime), .4, cos(iTime)));\n        vec3 light_col=.4*vec3(7.,7.,7.);\n        float light_dif = clamp(dot(normal, light_dir),0.,1.);\n        float isShadow=1.0;//checkShadow(p+normal*0.01,light_dir);\n        col= mate*light_dif*light_col*isShadow;\n\n        vec3 sky_col=vec3(0.5,0.8,0.9);//sky light, is everywhere from above\n        float sky_dif=clamp((.5+.5*dot(normal,vec3(0.,1.,0.))),0.,1.0);\n        //col+=mate*sky_col*sky_dif;\n\n        vec3 bou_col=vec3(.7,.3,.2);//bouncing light against the plane\n        float bou_dif=clamp( (.5+.5*dot(normal,vec3(0.,-1.,0.)) ),0.,1.0);\n        //col+= mate*bou_dif*bou_col;\n    }\n    col = pow( col, vec3(1.0/2.2) );//gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}const float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = max( k-abs(a-b), 0.0 )/k;\nreturn min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nfloat smin2( float a, float b, float k )\n{\nfloat res = exp2( -k*a ) + exp2( -k*b );\nreturn -log2( res )/k;\n}\nvec2 hash( vec2 p ) // replace this by something better\n{\np = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\nreturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\nconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\nconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\nvec2  i = floor( p + (p.x+p.y)*K1 );\nvec2  a = p - i + (i.x+i.y)*K2;\nfloat m = step(a.y,a.x); \nvec2  o = vec2(m,1.0-m);\nvec2  b = a - o + K2;\nvec2  c = a - 1.0 + 2.0*K2;\nvec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\nvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\nreturn dot( n, vec3(70.0) );\n}\nfloat interPlane(vec3 n, float s, vec3 rayO, vec3 rayD) \n{ \nreturn (s-dot(rayO,n))/dot(rayD,n);\n}\nfloat smax(float a, float b, float k){\nreturn -smin(-a,-b,k);\n}\nfloat planeSDF( vec3 p, vec3 n, float h )\n{\nvec3 m=normalize(n);\nreturn dot(p,m) + h;\n}\nfloat cubeSDF(vec3 p, vec3 c, float s){\nvec3 q = abs(p-c) - s;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sphSDF(vec3 p,vec3 c, float r){\n//float cc=0.003;\n//p+=  cc*simplex3d(p*50.);\nreturn length(p-c)-r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}