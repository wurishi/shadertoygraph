{"ver":"0.1","info":{"id":"cl3SWn","date":"1685224623","viewed":87,"name":"(im)pulses","username":"boytoy","description":"the kind of stuff i see when i stop and close my eyes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["psychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// colors for a palette\n#define color_1 vec3(0.145,0.847,0.494)\n#define color_2 vec3(0.902,0.808,1.000)\n#define color_3 vec3(0.376,0.000,1.000)\n#define color_4 vec3(0.549,1.000,0.796)\n\n#define x1 vec2(1.,0.)\n#define x2 vec2(0.,1.)\n#define x3 vec2(-1.,0.)\n#define x4 vec2(0.,-1.)\n\n// palette returns an interpolation between four sequential colors...\nvec3 palette(float t){\n    // explanation: color is continuously interpolated by how near \n    // the vector (cos(t),sin(t)) is to each the four points x1,x2,x3,x4\n    // when nearest to point xi, the color returned is closest to color_i\n    vec2 xy = vec2(cos(t),sin(t));\n    // uses convex combinations:\n    float l1 = 2. - length(xy-x1);\n    float l2 = 2. - length(xy-x2);\n    float l3 = 2. - length(xy-x3);\n    float l4 = 2. - length(xy-x4);\n    l1*=l1;l2*=l2;l3*=l3;l4*=l4;\n    float sum = l1+l2+l3+l4;\n    l1/=sum;l2/=sum;l3/=sum;l4/=sum;\n    // the result is a convex combination of the colors:\n    vec3 combination = l1*color_1 + l2*color_2 + l3*color_3 + l4*color_4;\n    return combination;\n}\n\nconst float M_PI = 3.141592;\n\n// indicator function (yes or no depending if |x-target| < width * 0.5)\nfloat enter(float target,float width, float x){\n    float d = width;\n    float t = target;\n    return smoothstep(t-d*0.5,t,x) - smoothstep(t,t+d*0.5,x);\n}\n\n// classic rotation based on rotation matrix\nvec2 rotate(vec2 uv,float t){\n    return vec2(uv.x * cos(t) - uv.y*sin(t),uv.x * sin(t) + uv.y*cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.* uv - 1.; uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 uv0 = uv;\n    vec3 final_color = vec3(0.);\n    \n    // each pass of the four adds a new ring\n    const float s = 1.5;\n    for(float i = 1.; i<= 5.; i++){\n        float d = s*length(uv) - iTime;\n        float lum = enter(1.,1./s,sin(d)); // ring luminosity is given by this\n        \n        vec3 pattern = palette(10.*iTime+length(10.*cos(uv-uv0))); // color pattern\n        \n        final_color += lum * pattern; // color = luminosity + palette\n        \n        // note that multiplying uv will make the rings smaller or greater,\n        // and that since luminosity is given by sin( $ )\n        // where $ is proportional to ||uv||, there will be\n        // \"constructive interference\" on the ring waves with some periods of sin(d).\n        uv *= 2.;\n        uv = rotate(uv,M_PI*1.25+ M_PI*iTime*0.001);\n    }\n    \n    \n    final_color*= .777*dot(final_color,vec3(1.)); // extra contrast\n\n    // Output to screen\n    fragColor = vec4(final_color,1.0);\n}","name":"Image","description":"","type":"image"}]}