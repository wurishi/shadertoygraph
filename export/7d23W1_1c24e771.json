{"ver":"0.1","info":{"id":"7d23W1","date":"1621425233","viewed":71,"name":"quatre raymarching","username":"quatreb","description":"razmarching tests","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","rays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_MARCHING_STEPS 300\n#define MIN_DIST 0.0\n#define MAX_DIST 200.0\n#define EPSILON 0.00001\n#define GRAD_STEP 0.02\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat planeSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat sphereSDF(in vec3 p, vec4 c) {\n    return length(p - c.xyz) - c.w;\n}\n\nfloat cubeSDF(in vec3 p, vec4 c) {\n    vec3 q = abs(p - c.xyz) - c.w;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat cappedCylinderSDF(in vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 rotationX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nmat3 rotationY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c, 0, s,\n        0, 1, 0,\n       -s, 0, c\n    );\n}\n\nmat3 rotationZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n\n// get distance in the world\nfloat dist_field(vec3 p) {\n    float sphereDist = sphereSDF(p, vec4(0.0, 0.0, 0.0, 1.0));\n    float cubeDist = cubeSDF(p, vec4(0.0, 0.0, 0.0, 0.75));\n    \n    float cappedCylinderDistX = cappedCylinderSDF(p * rotationX(90.0 * DEG_TO_RAD), 0.5, 1.0);\n    float cappedCylinderDistY = cappedCylinderSDF(p, 0.5, 1.0);\n    float cappedCylinderDistZ = cappedCylinderSDF(p * rotationZ(90.0 * DEG_TO_RAD), 0.5, 1.0);\n\n    float cappedCylinders = unionSDF(cappedCylinderDistX, unionSDF(cappedCylinderDistY,cappedCylinderDistZ));\n\n    float smallSpherePX = sphereSDF(p, vec4(0.75, 0.0, 0.0, 0.25));\n    float smallSphereMX = sphereSDF(p, vec4(-0.75, 0.0, 0.0, 0.25));\n    float smallSpherePY = sphereSDF(p, vec4(0.0, 0.75, 0.0, 0.25));\n    float smallSphereMY = sphereSDF(p, vec4(0.0, -0.75, 0.0, 0.25));\n    float smallSpherePZ = sphereSDF(p, vec4(0.0, 0.0, 0.75, 0.25));\n    float smallSphereMZ = sphereSDF(p, vec4(0.0, 0.0, -0.75, 0.25));\n    \n    float smallSpheresX = unionSDF(smallSpherePX, smallSphereMX);\n    float smallSpheresY = unionSDF(smallSpherePY, smallSphereMY);\n    float smallSpheresZ = unionSDF(smallSpherePZ, smallSphereMZ);\n\n    float smallSpheres = unionSDF(smallSpheresX, unionSDF(smallSpheresY, smallSpheresZ));\n    \n    float figure = unionSDF(smallSpheres, differenceSDF(intersectSDF(sphereDist, cubeDist), cappedCylinders));\n    float plane = planeSDF(vec3(0.1, 0.0, 0.1) * rotationZ(45.0 * DEG_TO_RAD));\n    return unionSDF(figure, plane);\n}\n\nfloat shortestDistanceToSurface(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = dist_field(ro + depth * rd);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( GRAD_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRAD_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRAD_STEP );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ref = reflect( dir, n );\n    \n    vec3 Ks = vec3( 0.5 );\n    vec3 Kd = vec3( 1.0 );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n\t\t\n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -30.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        \n        vec3 F = fresnel( Ks, normalize( vl - dir ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F );\n\t}\n\n    final += fresnel( Ks, n, -dir );\n    \n\treturn final;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - vec2(1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    vec3 pixelPos = vec3(uv, 2.0); // Image plane at (0,0,2)\n    vec3 eyePos = vec3(0.0, 0.0, 5.0); // Camera position at (0,0,5)\n    vec3 rayDir = normalize(pixelPos - eyePos);\n    \n    // rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\trayDir *= rot;\n\teyePos *= rot;\n    \n    float dist = shortestDistanceToSurface(eyePos, rayDir, MIN_DIST, MAX_DIST);\n    \n    // Didn't hit anything\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n\n    // Hit on the surface\n    // shading\n\tvec3 pos = eyePos + rayDir * dist;\n    vec3 n = normalize(gradient(eyePos + rayDir * dist));\n    vec3 color = shading( pos, n, rayDir, eyePos );\n\tfragColor = vec4( pow( color, vec3(1.0/1.2) ), 1.0 );;\n}","name":"Image","description":"","type":"image"}]}