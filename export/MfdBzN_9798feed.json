{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// To use this change functions at the end of Buffer A\n// Green button -> Zoom Out,\n// Red button   -> Zoom In,\n// Blue button  -> Go to origin\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define DRAW_FUNCTIONS 3\nfloat func0(float x);\nfloat func1(float x);\nfloat func2(float x);\n\nbool isAt(float x, float where, float pixelSize) {\n    return abs(x - where) <= pixelSize;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fetch from texture\n    const ivec2 mouseTexel = ivec2(0, 0);\n    const ivec2 zoomTexel  = ivec2(1, 0);\n    ivec2 currentTexel     = ivec2(fragCoord.xy);\n    \n    vec2 uv = fragCoord / iResolution.xy;    // 0 ... 1.\n    vec3 col = vec3(fragCoord / iResolution.xy / 7.0, 0.0);\n    \n    float unitsInAxis = texelFetch(iChannel0, zoomTexel, 0).x;\n    \n    vec2 scaleFactor = iResolution.xy / unitsInAxis;\n    // Since originally every pixel is 1 unit, if we zoom in every pixel is less than 1 unit.\n    vec2 pixelSize = 1.0 / scaleFactor;      \n   \n    vec2 currentCenter = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 xy = (fragCoord / scaleFactor) + currentCenter;\n    \n    // Periodic dots\n    vec2 interval = vec2(1.0);\n    vec2 dotsSpacing = vec2(10.0, 10.0) / scaleFactor;\n    if (mod(xy.y, interval.y) <= pixelSize.y && mod(xy.x, dotsSpacing.x) <= pixelSize.x\n    ||  mod(xy.x, interval.x) <= pixelSize.x && mod(xy.y, dotsSpacing.y) <= pixelSize.y)\n        col = vec3(0.6, 0.0, 0.0);\n    \n    // Guide segments\n    if (mod(xy.y, interval.y) <= pixelSize.y && fragCoord.x <= 10.0\n    ||  mod(xy.x, interval.x) <= pixelSize.x && fragCoord.y <= 10.0)\n        col = vec3(1.0, 1.0, 0.0);\n        \n    if (isAt(xy.x, 0.0, pixelSize.x) || isAt(xy.y, 0.0, pixelSize.y))\n        col = vec3(0.0, 1.0, 1.0);\n        \n    // Draw function(s)\n    if (DRAW_FUNCTIONS >= 0 && isAt(func0(xy.x), xy.y, pixelSize.y))    col += vec3(0.953,0.545,0.780);\n    if (DRAW_FUNCTIONS >= 1 && isAt(func1(xy.x), xy.y, pixelSize.y))    col += vec3(1.000,0.502,0.251);\n    if (DRAW_FUNCTIONS >= 2 && isAt(func2(xy.x), xy.y, pixelSize.y))    col += vec3(0.502,0.000,1.000);\n    \n    \n    // Zoom in/out, back to (0,0) buttons\n    // -------------------\n    vec4 buttonZoomIn     = vec4(iResolution.x - vec2(100.0, 0.0), iResolution.y - vec2(50.0, 0.0));\n    vec4 buttonZoomOut    = vec4(0.0, 100.0, iResolution.y - vec2(50.0, 0.0));\n    vec4 buttonBackOrigin = vec4(0.0, 100.0, 0.0, 50.0);\n    \n    // Draw buttons\n    if (isInsideRect(fragCoord, buttonZoomIn))\n        col = vec3(0.0, 1.0, 0.0);\n    else if (isInsideRect(fragCoord, buttonZoomOut))\n        col = vec3(1.0, 0.0, 0.0);\n    else if (isInsideRect(fragCoord, buttonBackOrigin))\n        col = vec3(0.0, 0.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nfloat func0(float x) {\n    return pow(3.0, 1.0 / 12.0);\n}\n\nfloat func1(float x) {\n    return x*x;\n}\n\nfloat func2(float x) {\n    return sin(abs(x*x) - 1.0/x);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const ivec2 mouseTexel = ivec2(0, 0);\n    const ivec2 zoomTexel  = ivec2(1, 0);\n    ivec2 currentTexel     = ivec2(fragCoord.xy);\n    \n    vec2 currentCenter      = texelFetch(iChannel0, mouseTexel, 0).xy;\n    vec2 previousMousePos   = texelFetch(iChannel0, mouseTexel, 0).zw;\n    float previousZoomLevel = iFrame == 0 ? 10.0 : texelFetch(iChannel0, zoomTexel , 0).x;\n\n    vec4 toWrite = vec4(0.0);\n\n    // Mouse input logic\n    // -----------------\n    vec2 mouseClickPos    = abs(iMouse.zw);\n    bool onClick          = iMouse.w > 0.0;\n    \n    // Pan camera\n    if (currentTexel == mouseTexel) {\n        if (iFrame <= 1) {\n            currentCenter    = vec2(0.0);\n            previousMousePos = vec2(0.0);\n        }\n        vec4 buttonBackOrigin = vec4(0.0, 100.0, 0.0, 50.0);\n        if (isInsideRect(mouseClickPos, buttonBackOrigin) && onClick)\n            currentCenter = vec2(0.0);\n        else {\n            float sensitivity     = previousZoomLevel;\n            vec2 mouseClickPosRes = mouseClickPos / iResolution.xy;\n            vec2 currentMousePos  = iMouse.xy / iResolution.xy;\n            vec2 mouseOffset      = sensitivity * (currentMousePos - (onClick ? mouseClickPosRes : previousMousePos));\n            toWrite = vec4(currentCenter-mouseOffset, currentMousePos);\n        }\n    } \n    // Zoom In/Out, back to (0,0) buttons\n    else if (currentTexel == zoomTexel) {\n        vec4 buttonZoomIn  = vec4(iResolution.x - vec2(100.0, 0.0), iResolution.y - vec2(50.0, 0.0));\n        vec4 buttonZoomOut = vec4(0.0, 100.0, iResolution.y - vec2(50.0, 0.0));\n\n        float newZoomLevel = previousZoomLevel;\n        \n        if (onClick) {\n            if (isInsideRect(mouseClickPos, buttonZoomIn))\n                newZoomLevel *= 2.0;\n            else if (isInsideRect(mouseClickPos, buttonZoomOut))\n                newZoomLevel /= 2.0;\n        }\n\n        toWrite = vec4(newZoomLevel, 0.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(toWrite); \n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"//                          Left, Right, Down, Up bounds\nbool isInsideRect(vec2 pos, vec4 rect) {\n    return\n        pos.x >= rect.x && pos.x <= rect.y &&\n        pos.y >= rect.z && pos.y <= rect.w;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfdBzN","date":"1734790710","viewed":115,"name":"Simple function grapher","username":"Furetto126","description":"A simple graphing calculator shader!\nDrag to move, Green button -> Zoom out, Red button -> Zoom in, Blue button -> Go to origin.\nTo change functions just edit func0, func1, func2 at the end of Buffer A, change DRAW_FUNCTION to select which to display. ;)\n","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["functions","graphs"],"hasliked":0,"parentid":"","parentname":""}}