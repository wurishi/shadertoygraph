{"ver":"0.1","info":{"id":"M3dSRS","date":"1719236241","viewed":33,"name":"Bezier Inflection with Seiler's","username":"Reynolds","description":"More info in forked shader. The point of inflection is given by the intersection of Seiler line (s1,s2) with Bezier base line (B0,B3).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","spline","segment"],"hasliked":0,"parentid":"lXcSzM","parentname":"Seiler Interpolation Curve"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float node(vec2 uv, vec2 pos, float size, float inner) \n{\n   float d0 = length(uv - pos) - size,\n         d1 = length(uv - pos) - inner;\n   return max(d0, -d1);\n}\n\nfloat lineline( vec2 A, vec2 B, vec2 C, vec2 D )\n{\n    vec2 b = B-A; vec2 d = D-C;\n    float dotperp = b.x*d.y - b.y*d.x;\n    if (dotperp == 0.) \n        return -1.0;\n    vec2 c = C-A;\n    return (c.x*d.y - c.y*d.x) / dotperp;\n}\n    \n\n//from iq.\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation\n    if( abs(k2)<0.001 )\n    {\n        res = vec2( (h.x*k1+f.x*k0)/(e.x*k1-g.x*k0), -k0/k1 );\n    }\n    // otherwise, it's a quadratic\n\telse\n    {\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        \n        if( u<0.0 || u>1.0 || v<0.0 || v>1.0 )\n        {\n           v = (-k1 + w)*ik2;\n           u = (h.x - f.x*v)/(e.x + g.x*v);\n        }\n        res = vec2( u, v );\n    }\n    \n    return res;\n}\n\n//from: https://www.shadertoy.com/view/X3V3Rt \nvoid calculateSeilerPoints(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, inout vec2 s1, inout vec2 s2)\n{\n    vec2 d1 = 3.0 * (p1 - p0) - p3 + p0;\n    vec2 d2 = 3.0 * (p2 - p3) - p0 + p3;\n    s1 = d1 + p0;\n    s2 = d2 + p3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.35, 0.0);\n    vec3 col = vec3(1.0);\n    \n    //Bezier control points.\n    vec2 B0 = vec2(0.05, 0.5) + vec2(0.1*sin(iTime/0.7), 0.1*cos(iTime/0.7));\n    vec2 B1 = vec2(0.2, 0.5 + 0.75*sin(iTime)) +  vec2(0.25*cos(iTime/0.5), 0.0);\n    vec2 B2 = vec2(0.7, 0.5 + 0.75*cos(iTime/2.0)) + vec2(0.25*sin(iTime/0.7), 0.0);\n    vec2 B3 = vec2(0.95, 0.5) + vec2(0.1*cos(iTime/0.5), 0.1*sin(iTime/0.5));\n    \n    vec2 s1, s2;\n    calculateSeilerPoints(B0, B1, B2, B3, s1, s2);\n    \n    //calculate line intersection of Seiler line with Bezier base.\n    float intersection_t = lineline(s1, s2, B0, B3); \n    \n    //calculate point of inflection.\n    vec2 inflection = vec2(0.0);\n    if(intersection_t > 0.0 && intersection_t < 1.0) {\n        //calculate position on Bezier curve.\n        vec2 s12 = mix(s1, s2, intersection_t);\n        vec2 B03 = mix(B0, B3, intersection_t);\n        \n        inflection = mix(B03, s12, (1.0 - intersection_t)*intersection_t);\n    }\n    \n    /* first calculate the bilinear coordinates of the two base Bezier curve points and the two Seiler points. */\n    vec2 curveCoords = invBilinear(uv, B0, B3, s2, s1);\n    \n    //constrain drawing of curve withing in the Seiler quad.\n    if(curveCoords.x > 0.0 && curveCoords.x < 1.0 && curveCoords.y > 0.0 && curveCoords.y < 1.0) {\n        \n        if(((1.0-curveCoords.x)*curveCoords.x) > curveCoords.y) {\n            //you can show the area under the curve by uncommenting this line but it is slightly buggy for inflected curves.\n            //col = vec3(0.0, 1.0, 0.0);\n        }\n\n        //this seems to work somewhat well for non-inflected curves but the thickness is not uniform\n        float thickness = 0.002;\n        \n        /* this is the main property that is used. Seiler interpolation uses three interpolations:\n        *  s12 = mix(s1, s2, t)\n        *  B03 = mix(B0, B3, t)\n        *  c = mix(B03, s12, (1-t)t)\n        *  Since the two bezier points and the seiler points form a quad we can use the bilinear coordinates (u, v)\n        *  of the quad to check whether we are evaluating on the curve since u = (1-t) and v = (1-t)t so we can\n        *  check whether (1-v)*v == u to see if we are on the curve. Offsetting this gives some thickness to the curve\n        *  and checking if the are < or > will give areas under and above the curve.\n        */\n        float curveDistance = abs(((1.0-curveCoords.x)*curveCoords.x) - curveCoords.y);\n        \n        col = mix(col, vec3(0.0), smoothstep(2.0/iResolution.y, 0.0, curveDistance - thickness));\n    }\n      \n    //show control points.\n    vec3 cp = vec3(1.0) - col;\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, B0, 0.015, 0.01)));\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, B1, 0.015, 0.01)));\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, B2, 0.015, 0.01)));\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, B3, 0.015, 0.01)));\n    \n    //show point of inflection\n    col = mix(col, vec3(1.0, 0.0, 0.0), smoothstep(2./iResolution.y, 0., node(uv, inflection, 0.015, 0.01)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}