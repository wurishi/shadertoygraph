{"ver":"0.1","info":{"id":"DdKcWw","date":"1696200521","viewed":67,"name":"Harmonic Sphere","username":"chronos","description":"Essentially a 3D version of my previous shader: https://www.shadertoy.com/view/dsVcRW\nShows a degree 2, homogeneous and harmonic (laplacian is zero) polynomial evaluated at the surface of a sphere.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere","aa","spherical","harmonic","harmonic","homogeneous","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nfloat spheresdf(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat rand(vec3 p)\n{\n    return fract(2.3467 * dot(p, vec3(285.345, 84598.92566, 289342.298)));\n}\n\nvec3 get_sphere_color(vec3 p, vec3 spherepos, float sphereradius)\n{\n    vec3 pos = p - spherepos;\n    \n    vec3 color = vec3(0);\n    \n    // Homogeneous: Equal degree in all terms:    f(a * x_1, ..., a * x_n) = a^d * f(x_1, ..., x_n)\n    // Harmonic: Laplacian (Sum of all second partial derivaties) is zero: sum_i d^2 f / dx_i^2 = 0\n    \n    // Degree 0:\n    // f(x, y, z) = a\n    \n    // Degree 1:\n    // f(x, y, z) = a * x + b * y + c * z\n    \n    // Degree 2:\n    // f(x, y, z) = a * x^2 + b * y^2 + c * z^2 + d * xy + e * yz + f * zx\n    // Δf(x, y, z) = 2 * ( a + b + c) = 0\n    // Δf(x, y, z) = a + b + c = 0\n    // c = -(a + b)\n    \n    // f(x, y, z) = a * (x^2-z^2) + b * (y^2-z^2) + c * xy + d * yz + e * zx\n    \n    // General method:\n    // Write an expression for the general homogeneous polynomial of a given degree\n    // Compute the Laplacian (using e.g Wolfram Alpha: https://www.wolframalpha.com/input?i=laplacian+of+a+*+x%5E3+%2B+b+*+y%5E3+-+3+*+b+*+x+*+x+*+y+-+3+*+a+*+x+*+y+*+y\n    // Distribute all terms (such that you have an independent basis of polynomials with coefficient expression)\n    // Constrain the coefficients of the polynomial such that the Laplacian is identially zero\n    // Substitute the expression of the coefficients back into the original polynomial.\n        \n    float x = pos.x;\n    float y = pos.y;\n    float z = pos.z;\n    \n    float a = cos(iTime * 2.1) + cos(iTime / 6.);\n    float b = sin(iTime);\n    float c = sin(iTime * 7. / 13.) * cos(iTime * 3. / 11.);\n    float d = sin(iTime * 5. / 11.) * cos(iTime * 7. / 13.) * sin(iTime * 11. / 23.);\n    float e = sin(iTime * 2. / 7.) * cos(iTime * 13. / 7.) * sin(iTime * 13. / 31.);\n    \n    vec3 pos2 = pos  * pos;\n    vec3 pos3 = pos2 * pos;\n    vec3 pos4 = pos2 * pos2;\n    \n    float x2 = pos2.x;\n    float y2 = pos2.y;\n    float z2 = pos2.z;\n    float x3 = pos3.x;\n    float y3 = pos3.y;\n    float z3 = pos3.z;\n    float x4 = pos4.x;\n    float y4 = pos4.y;\n    float z4 = pos4.z;\n    \n    // A selection of Harmonic Homogeneous Polynomials\n    float deg1 = a * x + b * y + c * z;\n    float deg2 = a * (x2-z2) + b * (y2-z2) + c * x*y + d * y*z + e * z*x;\n    \n    // Choose which degree polynomial to display\n    float f = mix(deg1, deg2, mod(floor(iTime / 20.), 2.));\n    \n    f = deg2; // Uncomment this to see degree 1 as well :)\n    \n    // Choose a colormap: [-inf, inf] -> [0,1]^3  (RGB)\n    //color = tanh(f)*.5 + .5;\n    //color = clamp(tanh(f) * vec3(0, 1, -1), 0., 1.);\n    \n    // Since we are 'tonemapping' later, we just choose an unlimited upper range\n    color = max(f * vec3(0, 1, -1), 0.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float time = iTime * .75;\n    \n    float c = cos(time);\n    float s = sin(time);\n    vec3 ro = 3. * vec3(c, 0., s) + vec3(0,0,0);\n    float focal = 2.;\n    \n    vec3 finalcolor = vec3(0);\n    \n    \n    // 1: No AA\n    // 2: Ok\n    // 3: Good Quality\n    // 4: Pixel Connoisseur\n    const int NUM_AA = 2;\n    \n    for(int AA = 0; AA < NUM_AA * NUM_AA; AA++)\n    {\n        vec2 uv_offset =\n            (vec2(AA % NUM_AA, AA / NUM_AA)\n            +\n            (NUM_AA > 1 ?\n            .3 + .4*texture(iChannel2, (fragCoord.xy/1024.) + vec2(1.1, .7) *float(iFrame + AA * 11) / 64.).rg\n            :\n            vec2(.5))\n        )/float(NUM_AA);\n        \n        vec2 uv = (2.*(floor(fragCoord)+uv_offset)-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize(vec3(uv, -focal));\n        rd.xz = mat2(s, -c, c, s) * rd.xz;\n    \n        vec3 color = sRGBdecode(texture(iChannel0, rd).rgb);\n\n        vec3 spherepos = vec3(0, 0., 0.);\n        float sphereradius = 1.;\n\n        float t = 0.;\n        for(int i = 0; i < 300; i++)\n        {\n            vec3 p = rd * t + ro;\n\n            float d = spheresdf(p - spherepos, sphereradius);\n\n            if(d < 1e-3)\n            {\n                color = get_sphere_color(p, spherepos, sphereradius);\n\n                // Add some basic light /////////////////\n                vec3 N = normalize(p - spherepos);\n                vec3 L = normalize(vec3(0,1,0));\n                vec3 R = reflect(rd, N);\n\n                float ao = mix(1., sqrt((R.y/sphereradius + 1.) * .5), .75);\n                color += .01*sRGBdecode(texture(iChannel0, R).rgb) * ao;\n                color += .18*sRGBdecode(texture(iChannel1, R).rgb) * ao;\n                color += .025 * max(dot(N, L), 0.);\n                color += .15 * max(dot(N,L), 0.) * pow(max(dot(R, L), 0.), 5.);\n                color += 2.0*pow(1.-dot(N, -rd), 8.) * sRGBdecode(texture(iChannel1, R).rgb);\n                /////////////////////////////////////////\n\n                break;\n            }\n\n            t += d;\n        }\n        \n        finalcolor += color;\n    }\n    \n    finalcolor /= float(NUM_AA * NUM_AA);\n\n    finalcolor = clamp(tanh(finalcolor), 0., 1.);\n\n    #if 0\n    fragColor = vec4(pow(finalcolor, vec3(1)/2.2),1.0);\n    #else\n    fragColor = vec4(sRGBencode(finalcolor),1.0);\n    #endif\n}","name":"Image","description":"","type":"image"}]}