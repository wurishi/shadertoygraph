{"ver":"0.1","info":{"id":"XcGyDc","date":"1732487004","viewed":16,"name":"Eyeball track","username":"Wotan","description":"Simple eye that follows mouse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mouse","eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Xor(float a, float b){\n    return a*(1.-b)+b*(1.-a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Flip Y coordinate (Shadertoy's coordinate system)\n    uv.y = 1.0 - uv.y;\n\n    // Eye center position (stationary at center of screen)\n    vec2 eyeCenter = vec2(0.5, 0.5);\n\n    // Normalized mouse coordinates (from 0 to 1)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.y = 1.0 - mouse.y; // Flip Y coordinate to match fragCoord\n\n    // If the mouse hasn't moved, default to looking straight ahead\n    if (iMouse.xy == vec2(0.0)) {\n        mouse = eyeCenter;\n    }\n\n    // Vector from eye center to mouse position\n    vec2 toMouse = mouse - eyeCenter;\n\n    // Limit the pupil movement to within the iris\n    float maxOffset = 0.05; // Maximum offset for pupil and iris movement\n    vec2 toMouseNorm = normalize(toMouse + 1e-6); // Avoid division by zero\n    float offsetMagnitude = min(length(toMouse), maxOffset);\n    vec2 pupilOffset = toMouseNorm * offsetMagnitude;\n\n    // Compute vector from adjusted iris center to current fragment\n    vec2 delta = uv - (eyeCenter + pupilOffset);\n\n    // Distance from the adjusted center of the iris/pupil\n    float dist = length(delta);\n\n    // Angle for swirling effect\n    float angle = atan(delta.y, delta.x) + sin(dist * 10.0 - iTime * 5.0) * 0.5;\n\n    // Coordinates after applying swirl\n    vec2 swirlPos = vec2(cos(angle), sin(angle)) * dist;\n\n    // Recompute distance after swirl\n    float swirlDist = length(swirlPos);\n\n    // Compute vector from eye center to current fragment for sclera\n    vec2 deltaSclera = uv - eyeCenter;\n    float distSclera = length(deltaSclera);\n\n    // Define radii for different parts of the eye\n    float pupilRadius = 0.05;\n    float irisRadius = 0.15;\n    float scleraRadius = 0.3;\n\n    // Initialize color\n    vec3 color = vec3(0.0);\n\n    if (distSclera < scleraRadius) {\n        // Inside the eye\n\n        if (swirlDist < pupilRadius) {\n            // Pupil color (black)\n            color = vec3(0.0, 0.0, 0.0);\n        } else if (swirlDist < irisRadius) {\n            // Incorporate the pattern into the iris\n\n            // Scale and translate coordinates for the pattern\n            vec2 patternUV = (fragCoord - (eyeCenter + pupilOffset) * iResolution.xy) / iResolution.y * 8.0;\n            float t = iTime;\n            float m = 0.0;\n\n            // Nested loops to create the pattern\n            for(float y = -1.0; y <= 1.0; y++) {\n                for(float x = -1.0; x <= 1.0; x++) {\n                    vec2 offs = vec2(x, y);\n                    float d = length(patternUV + offs);\n                    float dist = length(patternUV - offs) * 2.0;\n                    float r = mix(0.2, 2.0, sin(dist - t) * 0.5 + 0.5);\n                    m = Xor(m, smoothstep(r, r * 0.8, d * abs(sin(t * 0.5))));\n                }\n            }\n\n            // Adjust color based on pattern\n            color = mix(vec3(0.0, 0.0, 0.5), vec3(0.2, 0.4, 0.8), m);\n\n        } else {\n            // Sclera color (white)\n            color = vec3(1.0, 1.0, 1.0);\n        }\n\n    } else {\n        // Background color (dark)\n        color = vec3(0.0, 0.0, 0.0);\n    }\n\n    // Output color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}