{"ver":"0.1","info":{"id":"l3GXDt","date":"1720624023","viewed":91,"name":"Escargot","username":"Chriscamplin","description":"// This scene is adapted from a tutorial about shader coding by kishimisu & includes sdf functions and lighting calculations from iq.\nMouse interactive!\nVideo URL: https://youtu.be/khblXafu7iA\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","repetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n// This scene is adapted from a tutorial about shader coding,\n// which introduces the concept of raymarching as well as some useful\n// transforms and space-bending techniques.\n// \n//     Mouse interactive!\n//    Video URL: https://youtu.be/khblXafu7iA\n\n// 2D rotation function\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    return .5+.5*cos(6.28318*(t+vec3(.3,.416,.557)));\n}\n\n// Custom gradient - https://iquilezles.org/articles/palettes/\nvec3 paletteMouse(float t, vec2 m) {\n    return .5+.5*cos(6.28318*(t+vec3(.3*m.y,.416*m.y,1.557*m.x)));\n}\n\n// Rhombus SDF - https://iquilezles.org/articles/distfunctions/\nfloat sdRhombus( vec3 p, float la, float lb, float h, float ra )\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (dot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\n// Octahedron SDF - https://iquilezles.org/articles/distfunctions/\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//Round Box - exact https://iquilezles.org/articles/distfunctions/\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// Scene distance\nfloat map(vec3 p) {\n    p.z += iTime * .4; // Forward movement\n    p.x-=.5;\n    p.y+=.125;\n    p.xy*=rot2D((PI)*(iTime*.125));\n    //p.yz*=rot2D((PI)*(iTime*.25));\n\n    // Space repetition\n    if(p.y<.25 && p.y >1.) {\n        p.y = fract(p.y) - .25;     // spacing: 1\n    }\n    p.z =  mod(p.z, .25) - .125; // spacing: .5\n    float roundedBox = sdRoundBox(p, vec3(.25, .125, .125), .05);\n    float octahedron = sdOctahedron(p, .025);\n    float hexPrism = sdHexPrism(p, vec2(.333, .0345));\n    float triPrism = sdTriPrism( p, vec2(.333, .0345) );\n\n    return roundedBox; // roundedBox\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    vec3 tex = texture(iChannel0, uv).rgb;\n    // Default circular motion if mouse not clicked\n    //if (iMouse.z <= 0.) m = vec2(cos(iTime*.2), sin(iTime*.2));\n\n    // Initialization\n    vec3 ro = vec3(0, 0, 0);         // ray origin\n    vec3 rd = normalize(vec3(uv, -20)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n\n    float t = 0.; // total distance travelled\n\n    int i; // Raymarching\n    for (i = 0; i < 256; i++) {\n        vec3 p = ro + rd * t; // position along the ray\n        \n        p.xy *= rot2D(t*.5 * m.x);     // rotate ray around z-axis\n\n        p.y += sin(t*.125)*.5;  // wiggle ray\n\n        float d = map(p);     // current distance to the scene\n\n        t += d;               // \"march\" the ray\n\n        if (d < .0001 || t > 100.) break; // early stop\n    }\n        const float tmax = 100.0;\n\n        // Coloring\n        // shading/lighting\t\n        if( t<tmax )\n        {\n        vec3 pos = ro + t*rd;\n        pos.xy *= rot2D(t*.5 * m.x);     // rotate ray around z-axis\n\n        pos.y += sin(t*.125)*.5;  // wiggle ray\n\n        vec3 nor = calcNormal(pos);\n        vec3 lig = normalize(vec3(pos.xy,-0.4));\n        vec3 hal = normalize(lig-rd);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float occ = calcOcclusion( pos, nor );\n        if( dif>0.0001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n        float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n        col +=  paletteMouse(t*.01 + float(i)*.0125, m)*amb*occ;\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}