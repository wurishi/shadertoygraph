{"ver":"0.1","info":{"id":"Nd2yWG","date":"1644046314","viewed":273,"name":"Polygon Bridge","username":"kastorp","description":"Someone please repair that bridge!\nspace bar to toggle simulation on/off\nA=add/remove node, S=add/remove segment, D=pin","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["game","bridge"],"hasliked":0,"parentid":"7dScRd","parentname":"Reusable graph editor"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"  //Polygon Bridge by Kastorp\n//-------------------\n// SPACE BAR=  toggle simulation on/off\n// mouse=  select/move nodes\n// A= node mode (hold and click to add/remove) -Only unconnected nodes can be removed\n// S= segment mode (hold and click to add/remove) - to add a segment click between the two nodes\n// D= pin/unpin a node\n// R= reset\n//-------------\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U=U/R.y -R.xy/R.y/2.;\n    int N =int(A(0).x); \n    int M =int(B(0).x);\n    \n    //background\n    O=vec4(0,0.5,.8,0)* (!editMode?1.+U.y*.8: .9+ .1*smoothstep(0.,.001,sin(U.x*62.8)*sin(U.y*62.8 )));\n    O=mix(O,vec4(0,.8,0.,0) - texture(iChannel2,U*2.), smoothstep(-0.001,.001,min(-U.y,-U.y*.1+abs(U.x)-.498)));    \n    O=mix(O,vec4(0,.2,1.,0)*(.7+.03*sin(U.y*500.+sin(U.x*50.)*5.)), smoothstep(-0.001,.001,min(-.35-U.y-sin(U.x*50.)*.01,.5+U.y*.1-abs(U.x))));\n    O=mix(O,vec4(0,.8,0.,0) - texture(iChannel2,U*3.), smoothstep(-0.001,.001,min(-U.y-.3,-U.y*.1-abs(U.x)+.02)));\n    \n    //segments\n    for(int i =1;i<= M;i++){\n          vec2 l = B(i).xy;\n          vec4 s =vec4(V(l.x).xy,V(l.y).xy);\n          float dm = line(Mouse.xy,s.xy,s.zw),\n                d = line(U,s.xy,s.zw),\n                t = 1.- length(s.xy-s.zw)/length(A(l.x).xy-A(l.y).xy);          \n          O=mix(O,editMode?vec4(1,1,0,0): mix(vec4(0,1,0,0),vec4(10.,0,0,0),abs(t)*2000./STIFF),smoothstep(.001,-.001,d-.005));\n    }\n    \n    //nodes\n    if(editMode) for(int i =1;i<=N;i++){\n        vec4 p=V(i);\n         O=mix(O, A(i).z>0.?vec4(0,0,0,0):vec4(1,0,0,0),smoothstep(.001,-.001,length(p.xy -U)-.01));\n    }    \n    if(editMode) drawChars(iChannel3, O.xyz, vec3(1), U, vec2(-.1,-.45), vec2(.05), int[] (80,82,69,83,83,32,83,80,65,67,69));\n   \n}         ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// y=0: nodes on editor\n// y=1: segments\n// y=2: nodes on simulation\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n   \n   ivec2 c =ivec2(U);\n   if(c.y>2) discard;\n   O= texelFetch(iChannel0,ivec2(U),0);\n   \n    if(iFrame<1){\n        //init\n        vec3 V[] = vec3[] (vec3(-.5,0,1),vec3(-.3,0,0),vec3(-.1,0,0),vec3(.1,0,0),vec3(.3,0,0), vec3(.5,0,1),\n                                vec3(-.4,.2,0),vec3(-.2,.2,0),vec3(0,.2,0),vec3(.2,.2,0),vec3(.4,.2,0),\n                                                            vec3(0.,-.3,1)\n                          );\n        vec2 E[] = vec2[] (vec2(1,2),vec2(2,3),vec2(3,4), vec2(4,5),vec2(5,6),\n                            vec2(7,1),vec2(8,2),/*vec2(9,3),*/vec2(10,4), vec2(11,5) ,\n                            vec2(7,2),vec2(8,3),vec2(9,4),vec2(10,5), vec2(11,6) ,\n                            vec2(7,8),vec2(8,9),vec2(9,10),vec2(10,11)                            \n                          );\n        if(c.y==0 || c.y==2){\n           if(c.x==0) O=vec4(V.length(),0,0,0);\n           else if(c.x<=V.length()+1)  if(c.y==0) O.xyz= V[c.x-1]; else O= V[c.x-1].xyxy; \n\n        }\n        else if(c.y==1){\n           if(c.x==0) O=vec4(E.length(),0,0,0);\n           else if(c.x<=E.length()+1)  O.xy= E[c.x-1];\n            \n        } \n    } else if ( c.y==2){       \n        if(!editMode){\n           //simulation\n           vec4[100] a;\n           int N = int(A(0).x);\n           int M = int(B(0).x); \n           float G=.003,SS=20.,DT=1./SS;\n           \n            //init\n            for(int i =0;i<N +min(iFrame,0);i++) a[i] = V(i+1);\n            \n            //substeps \n            for(float s=0.;s<SS;s++){\n            \n                //verlet + gravity\n                for(int i =0;i<N +min(iFrame,0);i++){\n                    vec2 po=a[i].zw, p = a[i].xy;\n                    vec2 pn= 2.* p - po + .5*DT*DT *vec2(0,-G);  \n                   if(A(i+1).z<1.) a[i]=vec4(pn,p);          \n                }\n               \n               //skicks\n               for(int k =1;k<=M  +min(iFrame,0);k++){\n                    ivec2 v=ivec2(B(k).xy);\n                    int i=v.x-1, j=v.y-1;\n                    float L = length(A(v.x).xy-A(v.y).xy);          \n                    float d = length(a[i].xy -a[j].xy);\n                    vec2 m=(a[i].xy+ a[j].xy)*.5,\n                         d0= (1.- d/L)*(m-a[i].xy)/STIFF,\n                         d1= (1.- d/L)*(m-a[j].xy)/STIFF;\n\n                   if(A(v.x).z<1.) a[i].xy-= d0.xy;\n                   if(A(v.y).z<1.) a[j].xy-= d1.xy;\n               }\n               \n               //todo: collisions abd breaking\n           } \n           \n           //set current node\n           O=a[c.x-1];                      \n           \n        } else O=A(c.x).xyxy; //copy from editor\n    } else if(editMode){\n       \n        int N = int(A(0).x); \n        int M = int(B(0).x); \n        int LA =int(max(A(0).y,B(0).y)); //last action\n        vec2 d =Mouse.xy-A(c.x).xy;\n        \n        //closest node\n        vec2 m =vec2(0,1e8);\n        for(int i =1;i<=N;i++) {\n            float d = length(Mouse.xy-A(i).xy);\n            if(m.y>d) m=vec2(i,d);\n         } \n \n         //closest existing segment\n        int  id=0;\n        for(int j =1;j<= M;j++) {\n            float d = line(Mouse.xy, A(B(j).x).xy, A(B(j).y).xy);\n            if( d<.02) id=j;\n        }\n\n        //closest potential segment\n         vec3 ms =vec3(0,0,.3);                   \n        for(int i =1;i<= N;i++) for(int j =i+1;j<= N;j++){\n            float d =    line(Mouse.xy, A(i).xy, A(j).xy),\n                  l = length(A(i).xy -A(j).xy);\n            if(d<.02 && l<ms.z) ms=vec3(i,j,l);\n        }\n         if( keyDown(RESET)) {\n             O=vec4(0);\n             return;\n         \n         }  \n         \n        //drag node \n        if(c.y==0 && length(d)<.03 && int(m.x)==c.x && !keyDown(EDGE_MODE) && !keyDown(VERTEX_MODE) && !keyDown(PIN_MODE)) O.xy += d;\n        \n        if( keyDown(VERTEX_MODE)  && iMouse.z>0. && m.y> .05 && (iFrame - LA)>WAIT) { \n            //add node      \n            if(c.y==0 && c.x==N+1)  O=vec4(Mouse.xy,0,0); \n            if(c.y==0 && c.x==0) O.xy=vec2(N+1,iFrame); \n            if(id>0 && c.y==1){\n                if( c.x==id) O.x=float(N+1);\n                if( c.x==M+1) O.xy =vec2(B(id).x, N+1);\n                if( c.x==0) O.xy=vec2(M+1,iFrame); \n                \n            }\n        }       \n        \n        if( keyDown(VERTEX_MODE)  && iMouse.z>0. && m.y<.05  && (iFrame - LA)>WAIT ) { \n           int  id=0;\n            for(int j =1;j<= M;j++) {\n                if( B(j).x==m.x || B(j).y==m.x ) id=j;\n            }\n            if(id==0){\n                //remove node if unconnected\n                if(c.y==0 && c.x>= int(m.x) ) O= A(c.x+1);\n                if(c.y==0 && c.x==0) O.xy=vec2(N-1,iFrame);\n                if(c.y==1 && c.x>0 ){\n                    if(O.x>m.x) O.x-=1.;\n                    if(O.y>m.x) O.y-=1.;\n                }\n            }\n        } \n        if(c.y==0 && keyDown(PIN_MODE) && iMouse.z>0. && m.y< .1  && (iFrame - LA)>WAIT ) { \n            //pin/unpin\n            if(c.x== int(m.x)) O.z=1.-O.z;\n            if(c.x==0) O.y=float(iFrame);\n        }\n \n        \n        if(keyDown(EDGE_MODE)  && iMouse.z>0. && (iFrame - LA)>WAIT ) {           \n            //remove segment\n            if(id>0 && (iFrame - LA)>WAIT){                           \n                if(c.y==1  && c.x>= id ) O.xy= B(c.x+1).xy;\n                if(c.y==1  && c.x==0) O.xy=vec2(M-1,iFrame);\n            }\n            //add segment\n            else if(id==0 && ms.x!=0.  && (iFrame - LA)>WAIT){\n                if(c.y==1  && c.x==M+1)  O.xy = ms.xy;\n                if(c.y==1  && c.x==0) O.xy=vec2(M+1,iFrame); \n            }\n            //add segment and node\n            else if(m.y> .05 &&N>0 ){           \n                if(c.y==0 && c.x==N+1) O =vec4(Mouse.xy,0,0); \n                if(c.y==0 && c.x==0) O.xy=vec2(N+1,iFrame); \n                if(c.y==1 && c.x==M+1) O.xy = vec2(N+1,m.x);\n                if(c.y==1 && c.x==0) O.xy=vec2(M+1,iFrame); \n            }\n        }\n        \n        \n        \n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define VERTEX_MODE 65\n#define EDGE_MODE 83\n#define PIN_MODE 68\n#define RESET 82\n#define WAIT 30\n#define STIFF 100. //1=rigid 1000=soft\n#define Mouse (iMouse.xy/R.y-R.xy/R.y/2.)\n#define R iResolution\n#define A(x) texelFetch(iChannel0,ivec2(x,0),0)\n#define B(y) texelFetch(iChannel0,ivec2(y,1),0)  \n#define V(y) texelFetch(iChannel0,ivec2(y,2),0)  \n#define keyDown(k) (texelFetch(iChannel1, ivec2(k,0),0).x>.5)\n#define editMode (texelFetch(iChannel1,ivec2(32,2),0).x<=0.)\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;   \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid drawChar(sampler2D ch, inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(ch, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n#define drawChars( ch, color,  charColor,p,  pos,  size, chars){for(int i_=0;i_<chars.length();i_++) drawChar( ch, color,  charColor,p,  pos +vec2(i_,0)*size.x*.5,  size , chars[i_]);}\n","name":"Common","description":"","type":"common"}]}