{"ver":"0.1","info":{"id":"wsK3DD","date":"1570224927","viewed":423,"name":"Shadertober 04 Freezer","username":"GreenChicken","description":"Was trying to create something cute","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["cute","ice","character","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SHADERTOBER 04 Freeze\n// Poulet vert 04/10/2019\n// thanks to flafla2, iq, Leon and certainly everyone else <3\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nfloat Vignette(vec2 uv, float force)\n{\n    return force - length(uv);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdIce(vec3 pos)\n{\n    float t = 0.0;\n    \n    vec3 icePos = pos * vec3(1.5, 1.0, 1.5);\n    t = sdOctahedron(icePos, 1.0);\n    icePos = pos * vec3(1.5, .7, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(0.3, 0.0, 0.0), 1.0));\n    icePos = pos * vec3(1.6, .6, 1.3);\n    t = uSDF(t, sdOctahedron(icePos+vec3(-0.4, 0.0, 0.1), .9));\n    icePos = pos * vec3(1.2, 1.1, 1.7);\n    t = uSDF(t, sdOctahedron(icePos+vec3(-0.1, 0.0, -0.7), .9));\n    icePos = pos * vec3(1.5, 1.5, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(1.0, 0.0, 0.0), 1.0));\n    icePos = pos * vec3(1.5, 1.0, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(-1.0, 0.0, 0.0), 1.0));\n    icePos = pos * vec3(1.5, 1.2, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(0.0, 0.0, 1.0), 1.0));\n    icePos = pos * vec3(1.5, 1.3, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(0.0, 0.0, -1.0), 1.0));\n    icePos = pos * vec3(1.5, 2.1, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(1.0, 0.0, -1.0), 1.0));\n    icePos = pos * vec3(1.5, 1.2, 1.5);\n    t = uSDF(t, sdOctahedron(icePos+vec3(-1.0, 0.0, -1.0), 1.0));\n    icePos = pos * vec3(1.5, 0.8, 1.3);\n    t = uSDF(t, sdOctahedron(icePos+vec3(-1.0, 0.0, 1.0), 1.0));\n    icePos = pos * vec3(1.4, 0.9, 1.7);\n    t = uSDF(t, sdOctahedron(icePos+vec3(1.0, 0.0, 1.0), 1.0)); \n    \n    return t;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    p.zy *= rot(PI/2.0);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvec2 map(vec3 pos)\n{\n    float t = 0.0;\n    \n    pos.xz *= rot(PI/-14.0);\n    pos.xy *= rot(PI/8.0+sin(iTime*1.)*.3-0.3);\n    \n    t = pos.y, 0.0;\n    \n    t = uSDF(t, sdIce(pos));\n    \n    vec3 sPos = pos + vec3(0.0, 0.0, 0.0);\n    float sp = sdVerticalCapsule(sPos, 1.0, 1.0);\n    \n    t = opIntersection(t, sp);\n    \n    vec2 tm = vec2(0.0);\n    \n    tm = vec2(t, 0.0);\n    \n    vec3 eyeP = pos + vec3(-0.3, 0.0, -1.0);\n    vec2 eyeL = vec2(sdSphere(eyeP, .05), 1.0);\n    vec3 brightP = eyeP + vec3(0.02, -0.03, -0.03);\n    vec2 brightL = vec2(sdSphere(brightP, .02), 2.0);\n    \n    eyeP = pos + vec3(0.3, 0.0, -1.0);\n    vec2 eyeR = vec2(sdSphere(eyeP, .05), 1.0);\n    brightP = eyeP + vec3(0.02, -0.03, -0.03);\n    vec2 brightR = vec2(sdSphere(brightP, .02), 2.0);\n    \n    \n    vec3 smileP = pos + vec3(0.0, 0.2, -1.0);\n    float circle = sdTorus(smileP, vec2(0.1, 0.03));\n    float circleSub = sdSphere(smileP+vec3(0.0, -0.1, 0.0), .12);\n    vec2 smile = vec2(sSDF(circleSub, circle), 1.0);\n    \n    vec3 patteP = pos + vec3(0.2, 0.5, -1.0);\n    patteP.zy *= rot(PI/2.0);\n    patteP.xy *= rot(PI/-8.0);\n    vec2 patteL = vec2(sdVerticalCapsule(patteP, .8, .05), 1.0);\n    \n    vec3 papatteP = patteP + vec3(0.0, -.8, .3);\n    papatteP.zy *= rot(PI/2.0);\n    vec2 papatteL = vec2(sdVerticalCapsule(papatteP, .3, .05), 1.0);\n    \n    patteP = pos + vec3(-0.2, 0.5, -1.0);\n    patteP.zy *= rot(PI/2.0);\n    patteP.xy *= rot(PI/8.0);\n    vec2 patteR = vec2(sdVerticalCapsule(patteP, .8, .05), 1.0);\n    \n    papatteP = patteP + vec3(0.0, -.8, .3);\n    papatteP.zy *= rot(PI/2.0);\n    vec2 papatteR = vec2(sdVerticalCapsule(papatteP, .3, .05), 1.0);\n    \n    \n    \n    tm = opU(tm, eyeL);\n    tm = opU(tm, brightL);\n    tm = opU(tm, eyeR);\n    tm = opU(tm, brightR);\n    tm = opU(tm, smile);\n    tm = opU(tm, patteL);\n    tm = opU(tm, patteR);\n    tm = opU(tm, papatteL);\n    tm = opU(tm, papatteR);\n    \n    return tm;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p)\n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x - map(p-e.xyy).x,\n        map(p+e.yxy).x - map(p-e.yxy).x,\n        map(p+e.yyx).x - map(p-e.yyx).x\n        ));\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro + rd * t.x;\n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        vec2 vignetteUV = uv;\n        vignetteUV.y -= 0.2;\n        col = vec3(1.0 - length(vignetteUV))*.3;\n        \n        \n    }\n    else\n    {\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(-1.0, 1.0, -0.5);\n        float light = dot(N,L);\n        vec3 dir = pos - rd;\n        float rim = dot(N, dir) * (.1 + sin(iTime*5.)*.02);\n        float shade = GetShadow(pos, L, 4.0);\n        \n        if(t.y == 0.0) // ice\n        {\n            col = vec3(0.0, .5, .5+sin(iTime*10.)*0.01) + vec3(light)*.2;\n            col += vec3(rim);\n            col = mix(col, vec3(0.0, 0.0, .5), -uv.y) * .7;\n        }\n        else if(t.y == 1.0) // cute black things\n        {\n            col = vec3(0.0);\n        }\n        else if(t.y == 2.0)\n        {\n            col = vec3(1.0);\n        }\n        \n        \n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime * .2;\n    \n    vec3 cp = vec3(sin(iTime)*.5, 1.0+sin(iTime)*.3, 5.0+sin(iTime)*.4);\n    vec3 ct = vec3(-0.2, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    \n    // compo\n    col *= Vignette(uv, 2.0);\n    col.b -= screenUV.y*.2;\n    \n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}