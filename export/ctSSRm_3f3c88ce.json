{"ver":"0.1","info":{"id":"ctSSRm","date":"1676003484","viewed":146,"name":"Voxel Fluid v1","username":"Rugged","description":"Voxel fluids in 3D.\nUse WASD to move, Arrow Keys to turn -- Sorry AZERTY users I'm on a laptop so no keypad.  \n\nThere's an issue with my to2D and to3D functions in Common that make them all advect upwards. I'm working on solving that.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["fluid","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nprecision highp float;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = 2. * (uv - .5);\n\n    vec4 col = texture(iChannel0, uv);\n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n        \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi = radians(360. * (muv.x - 1.));\n    float theta = radians(180. * (1. - muv.y));\n    \n    phi = texelFetch(iChannel1, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel1, ivec2(1, 0), 0).y;\n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    \n    \n    \n    \n    vec3 p = texelFetch(iChannel1, ivec2(0), 0).xyz;\n\n    \n    \n    //rayD efficient\n    vec3 up = vec3(0., 0., 1.);\n    \n    vec3 U = normalize(cross(up, camD.yzw));\n    vec3 V = normalize(cross(camD.yzw, U));\n    \n    vec3 rayD = normalize(camD.yzw + uvc.x*U + uvc.y*V);\n    \n    \n    //###############################\n    \n    \n    \n  \n    \n    \n    col = vec4(0.);//texture(iChannel0, uv);\n    \n    // / float(iterations);\n    \n    vec2 blockSize = floor(iResolution.xy / 6.);\n    \n    vec3 p1 = p;\n    ivec2 add;\n    vec4 holdCol;\n    \n    //float mixA = 1.;\n    \n    for(int i = 0; i < 200; i++){\n    \n        add = ivec2(vec2(floor(mod(p1.z, 6.)), floor(p1.z / 6.)) * blockSize);\n        \n        //holdCol = texture(iChannel2, vec2(ivec2(p1.xy) + add) / iResolution.xy);\n        \n        //holdCol = length(holdCol) > 0. ? holdCol : .01 * normalize(holdCol);\n        \n        float l = .5;//length(holdCol);\n        if(p1.z > 42.){\n            l = 1.;\n        }\n        p1 += (rayD * (l * (hash3(p1.xy) + .5)));// * (length(p1 - p) + .001));\n      \n      \n      \n      \n        add = ivec2(vec2(floor(mod(p1.z, 6.)), floor(p1.z / 6.)) * blockSize);\n        \n        holdCol = texelFetch(iChannel0, ivec2(p1.xy) + add, 0);\n        \n        \n        if(p1.x < 0. || p1.x > blockSize.x || p1.y < 0. || p1.y > blockSize.y){\n            //draw edges and exit trace\n            col += vec4(10. / (distance(p, p1) + .0001));\n            break;\n        }\n        \n        if(length(holdCol) > .0){\n            col += (.00001 * vec4(pow(1. - abs(holdCol.a), 8.))) * abs(holdCol);//20. * vec4(holdCol) * holdCol.a;\n            \n        }\n        \n        //to see the ray jump through block layers\n        /*\n        if(distance(floor(vec2(p1.x + float(add.x), p1.y + float(add.y))), floor(fragCoord)) < 3.){\n            col = vec4(1., 0., 0., 1.);\n        }\n        */\n        \n    }\n    \n    \n    //to see block layers\n    /*\n    if(floor(mod(fragCoord.x, blockSize.x)) == 0. || floor(mod(fragCoord.y, blockSize.y)) == 0. ){\n        col += vec4(1.);\n    }\n    */\n    \n    \n    \n    //toggle to see each layer's fluid and next line is each layers pressure\n    //col = 50. *  abs(texture(iChannel0, uv));\n    //col = .000001 *  vec4(pow(texture(iChannel0, uv).a, 8.));\n\n    fragColor = col;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    \n    \n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 uvc = uv - vec2(0.5);\n    \n    vec4 col = vec4(0.);\n    \n    \n    ivec2 fragI = ivec2(fragCoord);\n    \n    vec3 up = vec3(0., 0., 1.);\n    vec3 left = vec3(0., 1., 0.);\n    vec3 forward = vec3(1. , 0., 0.);\n    \n    vec3 coords3d = to3D(fragCoord, iResolution);\n    \n    vec3 cfx = coords3d + forward;\n    vec3 cbx = coords3d - forward;\n    vec3 cfy = coords3d + left;\n    vec3 cby = coords3d - left;\n    vec3 cfz = coords3d + up;\n    vec3 cbz = coords3d - up;\n    \n    \n    \n    if(iFrame == 0){\n        col = vec4(0.);\n    }\n    else if(distance(uvc, vec2(0.)) < 1.) {\n        \n        //advect to new spot\n        vec4 u = texture(iChannel0, vec2(fragCoord / iResolution.xy));\n        \n        vec4 ufx = texture(iChannel0, vec2(to2D(cfx, iResolution) / iResolution.xy));\n        vec4 ubx = texture(iChannel0, vec2(to2D(cbx, iResolution) / iResolution.xy));\n        vec4 ufy = texture(iChannel0, vec2(to2D(cfy, iResolution) / iResolution.xy));\n        vec4 uby = texture(iChannel0, vec2(to2D(cby, iResolution) / iResolution.xy));\n        vec4 ufz = texture(iChannel0, vec2(to2D(cfz, iResolution) / iResolution.xy));\n        vec4 ubz = texture(iChannel0, vec2(to2D(cbz, iResolution) / iResolution.xy));\n        \n        \n        \n        for (int i = 0; i < 1; i++){\n            float dpx = ufx.w - ubx.w;\n            float dpy = ufy.w - uby.w;\n            float dpz = ufz.w - ubz.w;\n        \n        \n            cfx -= ufx.xyz;\n            cbx -= ubx.xyz;\n            cfy -= ufy.xyz;\n            cby -= uby.xyz;\n            cfz -= ufz.xyz;\n            cbz -= ubz.xyz;\n            \n            \n            coords3d -= u.xyz;\n            \n            \n            float densX = distance(coords3d, cfx) + distance(coords3d, cbx) - 3.;\n            float densY = distance(coords3d, cfy) + distance(coords3d, cby) - 3.;\n            float densZ = distance(coords3d, cfz) + distance(coords3d, cbz) - 3.;\n            \n            float density = densX + densY + densZ;\n            \n    \n            //apply changes\n            col = texture(iChannel0, vec2(to2D(coords3d, iResolution) / iResolution.xy));\n            \n            \n            col.x -= dpx / 12.;\n            col.y -= dpy / 12.;\n            col.z -= dpz / 12.;\n            \n            \n            \n            \n            \n            \n            //get data at new spot\n            ufx = texture(iChannel0, vec2(to2D(cfx, iResolution) / iResolution.xy));\n            ubx = texture(iChannel0, vec2(to2D(cbx, iResolution) / iResolution.xy));\n            ufy = texture(iChannel0, vec2(to2D(cfy, iResolution) / iResolution.xy));\n            uby = texture(iChannel0, vec2(to2D(cby, iResolution) / iResolution.xy));\n            ufz = texture(iChannel0, vec2(to2D(cfz, iResolution) / iResolution.xy));\n            ubz = texture(iChannel0, vec2(to2D(cbz, iResolution) / iResolution.xy));\n            \n            vec4 uAvg = (ufx + ubx + ufy + uby + ufz + ubz) / 6.;\n            \n            col.w = uAvg.w + (density / 12.); \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        //col.z = .1 * col.w;\n        //col.xy+= vec2(0., -.02) * iTimeDelta;\n        \n        \n        \n        if(iMouse.z > 0.){\n            vec2 muvc = (iMouse.xy / iResolution.xy) - vec2(.5);\n            \n            col += vec4(-muvc, 0., 1.) * iTimeDelta * (.1 / (0.001 + distance(uvc, muvc))) * .05;\n        }\n        \n        vec2 blockSize = floor(iResolution.xy / 6.);\n        \n        //if(abs(coords3d.x - blockSize.x * .5) >= blockSize.x * .9 || abs(coords3d.y - blockSize.y * .5) >= blockSize.y * .9){\n        //    col = vec4(0.); \n        //}\n        \n        //\n        if (distance(fragCoord, iResolution.xy * vec2(.38, .05)) < 1.){\n            col += vec4(1., 0., 0., .01);\n\n        }\n        \n        if (distance(fragCoord, iResolution.xy * vec2(.38, .08)) < 1.){\n            col += vec4(0., 1., 0., .01);\n        }\n        \n        if (distance(fragCoord, iResolution.xy * vec2(.38, .125)) < 1.){\n            col += vec4(0., 0., 1., .01);\n        }\n        \n        if (distance(fragCoord, iResolution.xy * vec2(.45, .05)) < 1.){\n            col += vec4(cos(iTime), sin(iTime), .1, .01);\n        }\n        \n        \n        \n        //col = vec4(to2D(coords3d, iResolution), 0., 1.);\n        //col = vec4(fragCoord, 0., 1.)/ 100.;\n        //dye will dissipate over time\n        col *= .95;\n        \n    }\n    \n    \n    \n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define iterations 10.\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\n\n\n\n\nvec2 to2D(vec3 p, vec3 res){\n    vec2 blockSize = floor(res.xy / 6.);\n    \n    vec2 add = vec2(floor(mod(p.z, 6.)), floor(p.z / 6.)) * blockSize;\n    \n    \n    \n    if(abs(p.x - blockSize.x * .5) >= .4 * blockSize.x || abs(p.y - blockSize.y * .5) >= .4 * blockSize.y){\n        add = vec2(-p.xy) - vec2(10);\n    }\n    \n    \n    return p.xy + vec2(add);\n}\n\nvec3 to3D(vec2 p, vec3 res){\n    vec2 blockSize = floor(res.xy / 6.);\n    \n    \n    return vec3(mod(p, blockSize), floor(p.x / blockSize.x) + (floor(p.y / blockSize.y) * 6.));\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define turnSpeed 2.\n#define moveSpeed 30.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    if(iFrame == 0){\n        if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n            col = vec4(iResolution.xy * (1. / 6.) * vec2(0.1, 0.5), 10., 0.);\n        }\n        else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n            col = vec4(0., 1.5, 0., 0.);\n        }\n    }\n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.xy / iResolution.xy;//iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    float phi = radians(360. * (1. - muv.x));\n    float theta = radians(180. * (1. - muv.y));\n    \n    \n    phi = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel0, ivec2(1, 0), 0).y;\n\n    \n    \n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta), 0.);\n    \n    \n    \n    if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n        vec4 camPerp = vec4(0.);\n        if(iFrame > 0){\n            vec3 tem = cross(normalize(vec3(camD.xy, 0.)), vec3(0., 0., 1.));\n            camPerp = vec4(tem, 0.);\n        }\n    \n        //if W is pressed go forwards\n        col += camD * texelFetch(iChannel1, ivec2(87, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if S is pressed go backwards\n        col -= camD * texelFetch(iChannel1, ivec2(83, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if A is pressed go forwards\n        col += camPerp * texelFetch(iChannel1, ivec2(65, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if D is pressed go backwards\n        col -= camPerp * texelFetch(iChannel1, ivec2(68, 0), 0).x * iTimeDelta * moveSpeed;\n        \n    }\n    else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n        \n       \n        //if UP is pressed turn up\n        col.y -= texelFetch(iChannel1, ivec2(38, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if DOWN is pressed turn down\n        col.y += texelFetch(iChannel1, ivec2(40, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if LEFT is pressed turn up\n        col.x -= texelFetch(iChannel1, ivec2(37, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if RIGHT is pressed turn down\n        col.x += texelFetch(iChannel1, ivec2(39, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        col.y = min(max(col.y, 0.01), 3.14);\n        \n        \n    }\n    \n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"}]}