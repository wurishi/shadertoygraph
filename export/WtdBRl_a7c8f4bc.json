{"ver":"0.1","info":{"id":"WtdBRl","date":"1613263971","viewed":149,"name":"Half tone rastering","username":"JeanArthurDeda","description":"A bit of half-tone rastering.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["postprocess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A bit of half-tone rastering.\n// The color version reminds me somehow of Jam and Spoon - Right in the night\n// All the half-tone processing, even for the color version is done by rendering\n// a black circle on top of a color (paper white for the black and white version)\n// The radius of the black circle is not computed properly based on the circle area\n// clamped by the unit square. It's a bit hackish and it \"kinda\" works.\n\n#define BLACK_AND_WHITE 0\n#define BLACK_AND_WHITE_ANGLE 45.0\n#define RED_ANGLE 15.0\n#define GREEN_ANGLE 45.0\n#define BLUE_ANGLE 75.0\n\n#define PI 3.141592653589793238f\n\nvec4 halfTone (vec2 p, float i, vec4 c)\n{\n    float r = sqrt ((1.0 - i) / PI);// works pretty well for values of black between 0..0.78\n    r *= 1.3; // compensation\n    float l = length (p-vec2(0.5));\n    return mix (vec4(0), c, clamp (pow (l/r,5.0),0.0,1.0));\n}\n\nvec2 rotate(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat saw(float v)\n{\n    return 1.0 - abs (1.0 - fract(v) * 2.0);\n}\n\nfloat sinsaw (float v)\n{\n    return sin (saw(v) * PI * 0.5f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    \n    float factor = pow (sinsaw (0.5 + iTime * 0.2), 6.0);\n    vec2 center = vec2 (0.5 + cos (iTime * 2.0) * 0.25, 0.5 + sin (iTime * 0.7) * 0.5);\n    float stops[3] = float[](0.2, 0.5, 1.0);\n    float stopsSize[3] = float[](0.1, 0.2, 0.1);\n    for (int i =0; i < 3; ++i)\n        if (abs(factor - stops[i]) < stopsSize[i])\n            factor = stops[i];\n    factor = iMouse.z > 0.0f ? iMouse.y / iResolution.y : factor;\n    center = iMouse.z > 0.0f ? iMouse.xy / iResolution.xy : center;\n    p -= center; p *= 1.0f - factor * 0.8;p += center;\n\n    float num = 200.0;\n    float dotsize = 1.0 / num;\n    vec2 hs = vec2(dotsize, dotsize * iResolution.x / iResolution.y);\n\n    #if BLACK_AND_WHITE\n    float ha = BLACK_AND_WHITE_ANGLE * PI / 180.0;\n    vec2 hl = p / hs;\n    hl = rotate (hl, ha);\n    vec2 l = rotate(floor(hl), -ha) * hs;\n    vec4 c = texture(iChannel0, l);\n    float i = dot (c.xyz, vec3(0.33));\n    fragColor = halfTone (fract(hl), i, vec4(1.0));\n    c = texture(iChannel0, p);\n    i = dot (c.xyz, vec3(0.33));\n    c = vec4 (i);\n    #else\n    // red\n    float ha = RED_ANGLE * PI / 180.0;\n    vec2 hl = rotate (p / hs, ha);\n    vec2 l = rotate(floor(hl), -ha) * hs;\n    fragColor = halfTone (fract(hl), texture(iChannel0, l).r, vec4 (1, 0, 0, 0));\n    \n    // green\n    ha = GREEN_ANGLE * PI / 180.0;\n    hl = rotate (p / hs, ha);\n    l = rotate(floor(hl), -ha) * hs;\n    fragColor += halfTone (fract(hl), texture(iChannel0, l).g, vec4 (0, 1, 0, 0));\n    \n    // blue\n    ha = BLUE_ANGLE * PI / 180.0;\n    hl = rotate (p / hs, ha);\n    l = rotate(floor(hl), -ha) * hs;\n    fragColor += halfTone (fract(hl), texture(iChannel0, l).b, vec4 (0, 0, 1, 0));\n    \n    vec4 c = texture(iChannel0, p);\n    #endif\n    float r = (factor - 0.05) / 0.2;\n    fragColor = mix (c, fragColor, clamp (r, 0.0, 1.0));\n}","name":"Image","description":"","type":"image"}]}