{"ver":"0.1","info":{"id":"cdVcRD","date":"1711232246","viewed":74,"name":"Black Grid Shooting Stars","username":"elifront","description":"A black noise grid with random colored shooting stars","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec3 random_color(in float y) {\n    return vec3(sin(y)+1., sin(y*2.)+1., sin(y*3.)+1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    // expanded\n    vec2 expanded = st*10.;\n\n    // create a noise grid\n    vec2 grid = floor(expanded);\n\n    vec2 edge = fract(expanded);\n\n    // animate the noise\n    grid.x += iTime * 0.3;\n\n    // create a noise value\n    float n = noise(grid);\n\n    // squash the noise\n    n = n * 0.08 + 0.08;\n\n    // create border color\n    float width = 5.;\n    float gap = 50.;\n    float speed = 0.05 + 0.05*random(vec2(grid.y));\n    float iteration = floor(iTime*speed)*gap;\n\n    vec3 border_color = random_color(grid.y + iteration); \n\n    // create a border mask\n    float mask = smoothstep(0.01, 0.02, edge.y);\n\n    // border animation cadence\n    float cadence =  1.-fract(st.x/width + iTime*speed + random(vec2(grid.y)))*gap; \n\n    // apply the mask with the border color\n    vec3 color = mix(border_color*cadence, vec3(n), mask); \n    \n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}