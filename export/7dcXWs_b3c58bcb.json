{"ver":"0.1","info":{"id":"7dcXWs","date":"1634157938","viewed":129,"name":"Platonic circle packings","username":"DrHow","description":"Circle packings from platonic solids","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","circlepacking"],"hasliked":0,"parentid":"Nd3XzN","parentname":"Extended Bianchi 31"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Disclaimer:\nI know nothing about lighting and coloring (I'm colorblind).\nI copied the visual effect from Zhao Liang (twitter @neozhaoliang).\nAnd I count on the community to make these things nicer.\n*/\n\n//#define config      init(float[2](3., 3.)) //tetrahedron\n\n//#define config      init(float[2](4., 3.)) //cube\n\n//#define config      init(float[2](3., 4.)) //octahedron\n\n#define config      init(float[2](5., 3.)) //dodecahedron\n\n//#define config      init(float[2](3., 5.)) //icosahedron\n\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n    return DE(p, index) * strong_factor;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    config;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / iResolution.y;\n    \n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n    float hue = fract(0.25*l) + .45;\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf              -1.\n#define MAX_ITER         50\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define L2XY(x, y)       dot(x - y, x - y)\n\nfloat ZOOM;\nbvec2 displayRealBalls = bvec2(1, 1);\n\n\nconst float s2 = 1.41421356; // sqrt(2)\nconst float s3 = 1.73205081; // sqrt(3)\nconst float s31 = 5.56776436283; // sqrt(31)\n\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec2 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[1] clusters;\n\nBall defaultBall() {\n    return Ball(false, vec2(0, 0), 1., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.n) - B.r;\n        return k;\n    }\n}\n\nBall from_plane(vec2 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvoid init(in float[2] diagram) {\n    Ball B0, B1, B2, B3;\n    float c0 = dihedral(diagram[0]);\n    float c1 = dihedral(diagram[1]);\n    \n    ZOOM = 1.618*c0;\n        \n    // The two virtuak balls B2, B3 are lines through the origin\n    B0 = from_plane(vec2(0, -1), c0);\n    B1 = defaultBall();\n    B2 = from_plane(vec2( 1, 0), c1);\n    B3 = from_plane(vec2(-1, 0), 0.);\n    \n    invertBall(B1);\n    \n    coclusters = Ball[4] (B0, B1, B2, B3);\n    \n    clusters[0] = from_plane(vec2(0, 1), 0.);\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        if (k > 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec2 cen = B.n;\n        float r = B.r;\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1. && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = q * k + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n \n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec2 p, inout int index) {\n    Ball Bxy;\n\n    p += vec2(-coclusters[2].r, coclusters[0].r);\n    \n    float scale = .5;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 4; k++)\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n        if (cond) break;\n    }\n    \n    index = 0;\n\n    float d = -sdistanceToBall(p, clusters[0]);\n    d=abs(d);\n    return d / scale;\n}","name":"Common","description":"","type":"common"}]}