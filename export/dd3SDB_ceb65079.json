{"ver":"0.1","info":{"id":"dd3SDB","date":"1681905707","viewed":43,"name":"CG 1st assignment","username":"cgnrr","description":"computer graphic course first assignment\n","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["reflection","raycast","camera","postprocess","buffer","lesson","cooktoorance"],"hasliked":0,"parentid":"msdXDn","parentname":"CG2023 04"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int k = 1;\n    ivec2 pix = ivec2(fragCoord);\n    fragColor = vec4(0);\n    for(int i = -k; i <= k; ++i)\n    {\n        for(int j = -k; j <= k; ++j)\n        {\n            fragColor += texelFetch(iChannel0,pix+ivec2(i,j),0);\n        }\n    }\n    fragColor /= float((2*k+1)*(2*k+1));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spheresNo = 2;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int triangleNo = 12;\nTriangle triangles[triangleNo];\n\nconst int materialNo = 4;\nMaterial materials[materialNo];\n\nconst int lightNo = 3;\nvec3 lightPos[lightNo];\n\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-30.0,7.5,-5.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, s.mat); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.mat);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t, plane.mat);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n    vec3 ab = triangle.b - triangle.a;\n    vec3 ac = triangle.c - triangle.a;\n    vec3 ap = ray.p0 - triangle.a;\n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap, ab);\n    \n    float det = dot(f, ab);\n    \n    \n    float invdet = 1.0 /det;\n    \n    float t = invdet * dot(g, ac);\n    float u = invdet * dot(f, ap);\n    float v = invdet * dot(g, ray.v);\n    \n    \n    if (t >= 0.0 && u >= 0.0 && v >= 0.0 && 1.0 - u - v >= 0.0) {\n        vec3 intersectionPoint = ray.p0 + t * ray.v;\n        return TraceResult(intersectionPoint, t, triangle.mat);\n    } else {\n        return TraceResult(vec3(0), 0., triangle.mat);\n    }\n       \n}\n\nTraceResult raycast(Ray ray)\n{\n    Material material = Material(\n        vec3(0.0), \n        0.0,        \n        vec3(0.0),           \n        0.0                  \n    );\n    \n    TraceResult res = TraceResult(vec3(0), ray.tmax, material);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n     for (int i = 0; i < triangleNo; i++)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n// Fresnel Function\nvec3 FresnelSchlick(float cosTheta, vec3 F0)\n{\n    // F0 reflected light at zero incident angle\n    // using material metalness as F0\n    \n    return F0 + (1.0 - F0) * pow(1.0-cosTheta,5.0);\n}\n\n// Microfacet Distribution Function using Beckmann's Distribution\nfloat BeckmanDist(vec3 h, vec3 n, vec3 l, float m)\n{\n    /* h = halfway vector\n       n = normal vector\n       l = light direction\n       m = material roughness\n    */\n    \n    float hn = max(0.001, dot(h,n));\n    float hn2 = hn*hn;\n    float m2 = m * m;\n    float num = exp((hn2 - 1.0) / (m2 * hn2));\n    float denom = pi * m2 * hn2 * hn2;\n    \n    return num / denom ;\n}\n\n\n// Geometric Attenuation\nfloat Geom(vec3 n, vec3 h, vec3 v, vec3 l)\n{\n    float hn = max(0.001, dot(h,n));\n    float vn = max(0.001, dot(v,n));\n    float vh = max(0.001, dot(v,h));\n    float ln = max(0.001, dot(l,n));\n\n    return min(1.0, min(((2.0 * hn * vn)/vh), ((2.0 * hn * ln)/vh))); \n}\n\n\nvec3 getColor()\n{\n    return vec3(0);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    vec3 v = ray.v;\n    \n    Material material = tr.mat; \n       \n    // Light \n    lightPos[0] = vec3(20.,15.,2.);\n    lightPos[1] = vec3(-12.,15.,-9.);\n    lightPos[2] = vec3(20.,15.,-14.);\n\n    vec3 col = vec3(0); // remains 0 if in shadow\n    \n    for (int i = 0; i < lightNo; i++)\n    {\n        vec3 l = lightPos[i]-p;\n        float lightDist = length(l);\n        l /= lightDist; // normalized direction to the light\n\n        Ray shadowray = Ray(p+0.001*n, 0.001, l, lightDist);\n                          /*     p0  , tmin , v,    tmax  */\n                          \n        \n        TraceResult res = raycast(shadowray);\n\n        if(res.t==shadowray.tmax)\n        {\n\n            //diffuse\n            float costheta = max(dot(n,l),0.);\n            vec3 k_d = material.color;\n\n            //specular\n            vec3 toLight = normalize(lightPos[i] - p);\n            vec3 toEye = -ray.v;\n            vec3 k_s = material.metalness * vec3(0.4);\n\n            vec3 h = normalize(toLight+toEye);\n            float si = pow(clamp(dot(h,n),0.,1.),10.);\n\n            // Applying cook-torrance model\n            float D = BeckmanDist(h, toEye, l, material.roughness);\n            float G = Geom(h, n, toEye, l);\n            vec3 F = FresnelSchlick(costheta, vec3(material.metalness));\n            vec3 CT_spec = (F * D * G) / (4.0 * dot(n,toEye) * dot(n,l));\n\n            // ambient\n            vec3 k_m = material.emission * material.color;\n\n            //sum\n            // col += (k_m + k_d + si*k_s)*costheta;\n            col += (k_d*0.1 + CT_spec) * costheta;\n        }\n    }    \n    return vec4(col,1.);\n}\n\n// Reflection\nRay reflection(Ray ray)\n{\n    \n    TraceResult tr = raycast(ray);\n    vec3 refDir = reflect(ray.v, tr.n);\n    refDir = normalize(refDir);\n    \n    vec3 p = ray.p0 + ray.v*tr.t;\n    Ray reflection = Ray(p, 0.001, refDir, tr.t);    \n    \n    return reflection;\n}\n\nvec3 recursiveReflection(Ray ray)\n{\n    vec3 col = vec3(0);\n    \n    \n    for (int depth = 0; depth < 2; ++depth)\n    { \n        Ray ref = reflection(ray);\n        TraceResult refRes = raycast(ref);\n\n        if(ref.tmax<=refRes.t)\n            col = missColor(ref).xyz;\n        else\n            col += hitColor(ref, refRes).xyz;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of 4 materials\n    materials[0] = Material(vec3(0.0, 0.3, 0.95), 0.1, vec3(0.5), 0.02);\n    materials[1] = Material(vec3(0.0, 0.75, 0.2), 0.1, vec3(1.0), 0.02);\n    materials[2] = Material(vec3(0.0, 0.9, 0.15), 0.1, vec3(0.6), 0.05);\n    materials[3] = Material(vec3(0.45,0.45,0.45), 0.1, vec3(0.65,0.5,0.4), 0.9);\n    \n    // Description of sphere\n    spheres[0] = Sphere(vec3(-12.f*sin(iTime*1.0f),18, 21.f*cos(iTime*1.f)), 3.5f, materials[3]);\n    \n    // Description of plane\n    planes[0] = Plane(vec3(-1.0), normalize(vec3(0.0,1.0,0.0)), materials[0]);    \n    \n    // Description of triangles\n    // Mountain 1\n    triangles[0] = Triangle(vec3(-0.2,-1,-3), vec3(-0.2,-1,3), vec3(5,-1,0), materials[0]);\n    triangles[1] = Triangle(vec3(5,-1,0), vec3(-0.2,-1,-3), vec3(1.5,4.2,0), materials[1]);\n    triangles[2] = Triangle(vec3(-0.2,-1,3), vec3(5,-1,0), vec3(1.5,4.2,0), materials[1]);\n    triangles[3] = Triangle(vec3(-0.2,-1,-3), vec3(-0.2,-1,3), vec3(1.5,4.2,0), materials[1]);\n\t\n    \n\t// Mountain 2\n\ttriangles[4] = Triangle(vec3(-1.5,-1,-10), vec3(-1.5,-1,0), vec3(10.2,-1,0), materials[0]);\n    triangles[5] = Triangle(vec3(10.2,-1,0), vec3(-1.5,-1,-10), vec3(4.4,7.7,-5), materials[2]);\n    triangles[6] = Triangle(vec3(-1.5,-1,0), vec3(10.2,-1,0), vec3(4.4,7.7,-5), materials[2]);\n    triangles[7] = Triangle(vec3(-1.5,-1,-10), vec3(-1.5,-1,0), vec3(4.4,7.7,-5), materials[2]);\n\n    // Mountain 3\n    triangles[8] = Triangle(vec3(-1,-1,-6), vec3(7,-1,-6), vec3(-1.3,-1,-12.9), materials[0]);\n    triangles[9] = Triangle(vec3(-1.3,-1,-12.9), vec3(-1,-1,-6),  vec3(3,5.9,-8.3), materials[1]);\n    triangles[10] = Triangle(vec3(7,-1,-6), vec3(-1.3,-12,9), vec3(3,5.9,-8.3), materials[1]);\n    triangles[11] = Triangle(vec3(-1,-1,-6), vec3(7,-1,-6), vec3(3,5.9,-8.3), materials[1]);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n        \n    \n    // Reflection\n    fragColor.xyz += recursiveReflection(ray);\n    \n        \n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.2*prev + 0.8*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Material {\n    vec3 color;       // [0,1/pi]\n    float roughness;  // [0, ~7]\n    vec3 emission;    // [0, inf] ambient color\n    float metalness;  // 0.02 - 0.05 for non-metals, 0.6 - 0.9 for metals\n};\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    Material mat; // material of object\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    Material mat; // material of object\n};\n\nstruct Triangle\n{\n    vec3 a,b,c;\n    Material mat; // material of object\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    Material mat; // material of object\n};","name":"Common","description":"","type":"common"}]}