{"ver":"0.1","info":{"id":"ctB3DR","date":"1673693602","viewed":93,"name":"Audio Visualization: Rainbow","username":"ZhuElly","description":"Audio training","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, ouv);\n    col.xyz *= col.w;\n    //col = col + texture(iChannel1, ouv);\n    \n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\n#define DISTANCE .3\n#define SCALE .1\n#define WIDTH 2.1\n#define LOOP .5\n#define HUESPEED .2\n#define SPIKE 1.\n#define SATURATION 1.3\n#define GAP .01\n#define DECAY .9\n\nfloat AngleMap(in vec2 ncuv, float loop){\n    float dir = atan(ncuv.y, ncuv.x);\n    vec2 range = vec2(-1. * PI, 1. * PI);\n    dir = smoothstep(range.x, range.y, dir * loop);\n    return dir;\n}\n\nfloat HueValue(in vec2 cuv){\n    float dir = atan(cuv.y, cuv.x);\n    float hue = sin(dir * LOOP);\n    hue = (hue + 1.) / 2.;\n    return hue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 ouv = fragCoord / iResolution.xy;\n    vec2 uv = (fragCoord - vec2((iResolution.x - iResolution.y) / 2., 0.))/vec2(iResolution.y, iResolution.y);\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - vec2(.5, .5);\n    vec2 ncuv = normalize(cuv);\n    vec2 acuv = abs(cuv);\n    \n\n    // Audio amp\n    vec2 a_uv = ouv - vec2(.5, .5);\n    float dir = AngleMap(a_uv, SPIKE);\n    if(dir > .5) dir = 1. - dir;\n    float audio_amp = texture(iChannel0, vec2(dir, 0)).x;\n    \n    // distance to center\n    float c = distance(acuv, vec2(.0));\n    float dis = SCALE + (audio_amp * .2);\n    // draw an smooth circle\n    float c2 = smoothstep(0., dis, c);\n    // Invert color\n    c2 = 1. - c2;\n    if(c2 > .1) c2 = 0.;\n    // smooth the curve\n    c2 = sin(c2 * (100. /max(1.6, WIDTH)));\n    // Get rid of inner ring\n    float hue_value = HueValue(cuv);\n    \n    vec3 col = (HueShift(vec3(1., 0., 0.), hue_value + (iTime * HUESPEED)) * c2).xyz;\n    col *= SATURATION;\n    vec3 lcol = texture(iChannel1, ouv + vec2(cos(iTime * .5) * GAP, sin(iTime * .5)* GAP)).xyz;\n    col += lcol.xyz * DECAY;\n   \n    //fragColor = vec4(vec3(audio_amp),1.0);\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define ALPHA .2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord / iResolution.xy;\n    fragColor = vec4(HueShift(vec3(1.0, 0.0, 0.0), ouv.x + iTime) * ALPHA,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    vec3 U = Color-P;\n    vec3 V = cross(vec3(0.55735),U);    \n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    return vec3(Color);\n}","name":"Common","description":"","type":"common"}]}