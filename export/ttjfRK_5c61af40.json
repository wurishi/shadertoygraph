{"ver":"0.1","info":{"id":"ttjfRK","date":"1599390090","viewed":197,"name":"blackhole-v5","username":"feefi","description":"blackhole withe star background and x ray glow.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 black_hole_pos = vec3(0.0,0,1.5); \t\t//黑洞的位置\nfloat event_horizon_radius = 0.3;\t\t//黑洞的事件视界半径\nfloat HitTest(vec3 p){\n\treturn length(p) - event_horizon_radius;\n}\n\n\n\nvec2 N22(vec2 id)\n{\n    id = id*vec2(123.1,456.2);\n    id += dot(id,id);\n    return fract(sin(id)*vec2(5.123,123.3));\n}\nfloat N21(vec2 id)\n{\n    id = id*vec2(227.1,125.2);\n    return fract(sin(dot(id,id))*215.3);\n}\nvec2 rPos(vec2 id)\n{\n    return  N22(id) -.5;\n}\nvec3 star(vec2 uv,vec2 id)\n{\n    float l = length(uv);\n    //float l = max(abs(uv.x),abs(uv.y));\n    float center = 0.035/l;\n    float st = center  ;\n\n    float N = N21(id);\n    float Size = N*2.;\n    vec3 color = sin(vec3(0.2,0.5,0.7)*fract(N*73.1)*15.)*0.5+0.5;\n    return st * N * smoothstep(1.,0.,l) * color*vec3(1.0,0.7,Size);\n}\nvec3 starLayer(vec2 uv,float i)\n{\n    vec2 id = floor(uv);\n    uv = fract(uv)-0.5;\n\n    vec3 col = vec3(0.);\n    \n    for(float x = -1.;x<=1.;++x){\n        for(float y = -1.;y<=1.;++y){\n            vec2 nid = id + vec2(x,y);\n            vec2 rpos = rPos(nid+i+1.);   \n            vec2 nuv = uv + rpos - vec2(x,y);         \n            vec3 st = star(nuv,nid);           \n            col += st*fract(cos((i+1.)*100.)*23.1)*3.5;\n        }\n    }\n\n    return col;\n}\nvec3 GetBg(vec3 p)\n{\n    //vec2 uv = fract(p.xy*vec2(0.1,0.15)+0.5).xy;//to [0,1]\n    //return texture(iChannel0,uv).xyz;\n    return starLayer(p.xy+vec2(4.8,0.),8.)*0.3;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //映射到0~1之间\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.  - 1.;\t\n    uv.x *= iResolution.x / iResolution.y;\t\n\tvec3 eye = vec3(0.,0.,-2);    //eye or camera postion 相机位置\n    vec3 sd = vec3(uv.x,uv.y,-1); //screen coord 屏幕坐标\n    vec3 ray_dir = normalize( sd - eye);//ray direction 射线方向\n    \n    vec3 col = vec3(0.);\n    \n\tfloat hitbh = 0.;\n    \n    const int maxStep = 400;//光线最大步进数\n    float st = 0.;      \n    vec3 p = sd;\n    vec3 v = ray_dir;\n    float dt = 0.01;\n    float GM = 0.8;   \n    vec3 cp = black_hole_pos ;//+ 2.*vec3(1.5*sin(iTime),sin(1.31*iTime),0.);\n    float bc = 0.0;\n    float hitbhglow = 0.;\n    for(int i = 0;i<maxStep;++i)\n    {\n       \t//F = G * M * m / r^2;\n    \t//a = F/m\n    \t//v = v + a * dt;\n    \t//p = p + v * dt;\n        p += v * dt;\n        vec3 relP = p - cp; //黑洞相对原点的位置       \n        float r2 = dot(relP,relP);\n        vec3 a = GM/r2 * normalize(-relP); //加速度的方向朝向黑洞，为-relP\n        v += a * dt;   \n\n        float hit = HitTest(relP); //hit表示距物体的最小距离\n\t\thitbh = max(hitbh,smoothstep(0.02,-0.02,hit));  \n        hitbhglow = max(hitbhglow,smoothstep(0.02,-0.05,hit));\n        \n        float glow = 0.013/r2;//0.01*(exp(0.2/r2)-0.5);\n        \n        bc += glow * (1.-hitbh) ;\n        //float bb = (smoothstep(0.2,-0.2,hit));\n        //if(bb > 0.5)break;\n    }\n    //float dis = dot(p-cp,p-cp);\n    //\n    col = 0.13*bc*vec3(0.9,0.8,0.8) + GetBg(p)*(1.-hitbh);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}