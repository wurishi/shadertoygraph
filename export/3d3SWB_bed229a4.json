{"ver":"0.1","info":{"id":"3d3SWB","date":"1572722940","viewed":199,"name":"VOLONOI","username":"ankd","description":"volumetric and voronoi3d","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 transform(in vec3 p) {\n    //p = abs(p);\n    //p = rotate(p, vec3(iTime*0.04));\n    return p;\n}\n\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat object(in vec3 p) {\n    p = transform(p);\n    float s = sphere(p, 5.);\n    return s;\n}\n\n#define OMARCH_ITR 64\n#define OMARCH_THR 1e-4\nvec2 oMarch(in vec3 ro, in vec3 rd, in vec2 tmm) {\n    vec2 res = vec2(-1.);\n\n\t// first marching loop until hit\n    float t = tmm.x;\n    for(int i=0;i<OMARCH_ITR;i++) {\n    \tfloat d = object(ro + rd*t);\n        if(d<OMARCH_THR || tmm.y<t) break;\n        t += d;\n    }\n    if(tmm.y<t) return res;\n    res.x = t;\n    \n\t// second marching loop until escape\n    t += 0.05;\n    for(int i=0;i<OMARCH_ITR;i++) {\n    \tfloat d = object(ro + rd*t);\n        d *= -1.;\n        if(d<OMARCH_THR || tmm.y<t) break;\n        t += d;\n    }\n    res.y = t;\n    if(tmm.y<t) res.y = tmm.y;\n    \n    return res;\n}\n\n\nfloat volumetric(in vec3 p) {\n    float res = 1e5;\n    p = transform(p);\n    p *= 1.4;\n    \n    //float res1 = .95-voronoi3d(p).r;\n    float res2 = pow(voronoi3d(p).g, 3.);\n\t//res = mix(res2, res2, smoothstep(-0.1, 0.1, sin(iTime)));\n    res = res2;\n    res = 1./res;\n    return res;\n}\n\n#define VMARCH_ITR 24\n#define VMARCH_COLOR vec3(0.8,0.8,0.8)\nvec3 vMarch(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tvec3 col = vec3(0.);\n    \n    float t = tmm.x;\n    float dt = (tmm.y-tmm.x) / float(VMARCH_ITR);\n    //dt = 0.1;\n    for(int i=0;i<VMARCH_ITR;i++) {\n        float c = volumetric(ro + rd*t);\n        col = mix(c*VMARCH_COLOR, col, 0.988+0.003*sin(iTime*0.4));\n    \tt += dt;\n    }\n    \n    return pow(col, vec3(3.));\n}\n\n#define BG_COLOR vec3(.06, .07, .08)\nvec3 bg(in vec3 p) {\n    p *= 8.0;\n    float v = clamp(voronoi3d(p).g, 0., 1.);\n    v = pow(v, 6.);\n    return v * BG_COLOR;\n}\n\nmat3 lookat(in vec3 eye, in vec3 target, in float r) {\n    vec3 cz = normalize(target - eye);\n    vec3 cx = normalize(cross(cz, vec3(sin(r), cos(r), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n\treturn mat3(cx, cy, cz);\n}\n\n\nvec3 getRO() {\n\tvec3 ro1 = 2. * rotate(vec3(cos(iTime*PI*0.3), 0., sin(iTime*PI*0.3)), vec3(0., 0., PI/6.0));\n    vec3 ro2 = vec3(0., 0., 5. - sin(iTime*0.37));\n    return mix(ro1, ro2, step(0.5, fract(iTime*0.1)));\n}\nvec3 getTA() {\n\tvec3 ta1 = 0.4*sin(iTime * vec3(0.17, 0.11, 0.13));\n    vec3 ta2 = vec3(0.0, 0.5, 0.0);\n    return mix(ta1, ta2, step(0.5, fract(iTime*0.1)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 pix = 1./ iResolution.xy;\n    vec3 col = vec3(0.);\n\n    vec3 ro = getRO();\n    vec3 ta = getTA();\n    float cr = 0.;\n    vec3 rd = normalize(lookat(ro, ta, cr) * vec3(p, 2.));\n    \n    vec2 tmm = oMarch(ro, rd, vec2(0., 10.));\n    if(tmm.x<0.) {\n        col = bg(rd);\n    }\n    else {\n        col = vMarch(ro, rd, tmm);\n\t    //col = mix(vMarch(ro, rd, tmm), bg(rd), 0.0);\n    }\n\n    // Output to screen\n    col = clamp(col, 0., 1.);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nfloat hash(in float v) { return fract(sin(v)*43237.5324); }\nfloat hash(in vec2 v) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*43237.5324); }\n\nmat2 rotate(in float r) { float c=cos(r),s=sin(r); return mat2(c,-s,s,c); }\nvec2 rotate(in vec2 p, in float r) { return p * rotate(r); }\nvec3 rotate(in vec3 p, in vec3 r) {\n\tp.xy = rotate(p.xy, r.z);\n\tp.yz = rotate(p.yz, r.x);\n\tp.zx = rotate(p.zx, r.y);\n    return p;\n}\n\n/*\n\tMaxBittker/glsl-voronoi-noise\n\thttps://github.com/MaxBittker/glsl-voronoi-noise/blob/master/3d.glsl\t\n*/\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\nvec3 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n  return vec3(sqrt(res), abs(id));\n}\n","name":"Common","description":"","type":"common"}]}