{"ver":"0.1","info":{"id":"WlfGRN","date":"1555920671","viewed":1824,"name":"Study - Paintbrush Stroke","username":"trevorleake","description":"A first study in making paintbrush like strokes procedurally. Definitely room for progress. :) My first attempt at making an actually pretty thing. \n\nInspired entirely by user 104's Brush Experiments found here: https://www.shadertoy.com/view/ltj3Wc","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","brush"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415;\n\n\n//////////////////////\n// Helper Functions //\n//////////////////////\n\n// Returns 1 if the components of v are within [0, 1], 0 otherwise. \nfloat zeroToOne(vec2 v) { return v.x>=0. && v.x<=1. && v.y>=0. && v.y<=1. ? 1. : 0.; }\nfloat inRange(vec2 v, vec2 bl, vec2 tr) { return v.x>=bl.x && v.x<=tr.x && v.y>=bl.y && v.y<=tr.y ? 1. : 0.; }\n\n// Returns a rotation matrix which will rotate a vector clockwise by angle randians. \nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat ellipse(vec2 uv, vec2 center, float semimajor, float semiminor)\n{\n    float theta = acos((uv.x-center.x)/semimajor);\n\tif(uv.y < center.y)\n        theta = 2.*pi - theta;\n\n    float x = center.x + semimajor*cos(theta);\n    float y = center.y + semiminor*sin(theta);\n\n    float val = pow(uv.x-center.x, 2.)/pow(semimajor, 2.) + pow(uv.y-center.y, 2.) / pow(semiminor, 2.);\n    return step(0., 1.-val);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius) { return distance(uv, center) <= radius ? 1. : 0.;} \n\n\n/////////////////////\n// Noise Functions //\n/////////////////////\n\n// Simplex noise implemented by Inigo Quilez \n// https://www.shadertoy.com/view/Msf3WH\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat simplexNoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat positiveSimplexNoise(vec2 uv) {return abs(simplexNoise(uv));}\n\n\n\n// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\n\n\n\n\n///////////////////////\n// Drawing Functions //\n///////////////////////\n\n\n// Returns the position of UV relative to the drawn line. Interval [0,1] is in the line.\nvec2 lineGeometry(vec2 uv, vec2 p1, vec2 p2, float lineWidth) \n{\n    // We'll grab the angle & length of the line\n    float lineAngle = atan(p1.x-p2.x, p1.y-p2.y);\n    float lineLength = distance(p1, p2);\n\n    // And find the rotation matrix which flattens it to the y-axis \n    mat2 rotMat = rotate2d(pi-lineAngle);\n\n    // Next, we'll describe a new line which lives on the y-axis & has the same length\n    vec2 pa = vec2(0);\t\t\t\t// Point A\n    vec2 pb = vec2(0, lineLength);\t// Point B\n\n    // Transform our uv the same as we have transformed the line\n\tuv -= p1;\n    uv = rotMat * uv;\n    \n    // Check if the point is in the line (rectangle)\n  \tfloat inWidthRange = abs(uv.x) < lineWidth/2. ? 1. : 0.;\n    float inHeightRange = (1.-step(max(pa.y, pb.y), uv.y)) * (step(min(pa.y, pb.y), uv.y));\n\n    vec2 bl = vec2(-lineWidth/2., 0);\n    vec2 tr = vec2(lineWidth/2., lineLength);\n\tvec2 uvLinePosition = vec2(uv/(tr-bl));\n        \n    return uvLinePosition;\n}\n\n\nfloat brushLine(vec2 uv, vec2 p1, vec2 p2, float lineWidth)\n{\n    // Find our position in the line as a vec2 in (0,0) to (1, 1) or beyond if out of line\n    vec2 uvLine = lineGeometry(uv, p1, p2, lineWidth);\n\n    // inStroke is in (0, 1] if the pixel is in, 0 if not\n    float inStroke = zeroToOne(uvLine);\n\t\n    // Source a coordinate we can use in all noise functions as a sampling point\n    vec2 source = uvLine + vec2(0, iTime);\n\n    // We'll add texture that looks like bristles by squishing and stretching our simplex noise in nice ways.\n\tfloat tex = 0.;\n    \n    \n    /* \tLittle Thin Bristles */\n    float strokeFade =  smoothstep(0., .5, uvLine.y) - smoothstep(.9, 1., uvLine.y);\n    float lilBristlesTexture = clamp(\n      \tsimplexNoise(source * vec2(10., .1))\t// Simplex noise being squished vertically and stretch horizontally\n     \t+ simplexNoise(source * vec2(15., 1.))  // Simplex noise being squished a bit more, and moving faster horizontally\n    , 0., 1.);\n    tex += inStroke * strokeFade * lilBristlesTexture;\n\n    \n    /* Spackle */\n    /*\n    float spackleFade = smoothstep(.2, .4, uvLine.y) - smoothstep(.95, 1., uvLine.y);    \n\tspackleFade *= (smoothstep(-.2, 0., uvLine.x) - smoothstep(1., 1.2, uvLine.x));\n    float spackleTexture = clamp(\n        smoothstep(43., 45., magicBox(source))\n\t,0.,1.);\n  \ttex +=  spackleFade * spackleTexture;   \n\t*/    \n    \n    \n    /* Thick Bristles */\n    float thickBristlesTexture = clamp(\n      \t1.3*smoothstep(.3, 1., uvLine.y) // This creates a full stroke between 30% and 100% through the line\n        - 0.3 * positiveSimplexNoise(source * vec2(10., .2)) // Partially scrape away a few streaks. \n    , 0., 1.);    \n    float thickBristleFade = smoothstep(0., 1., uvLine.y) - smoothstep(.97, 1., uvLine.y);\n    tex += inStroke * thickBristleFade * thickBristlesTexture;\n\n    \n    tex = clamp(tex, 0., 1.);\n    return tex;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    \n    // Centering\n    uv -= vec2(.5);\n\n    // Add wibbliness to the line for +1 to beauty.\n    uv.y += sin(simplexNoise(uv+vec2(iTime,0)))*.02;\n    \n    // Points for the line to go between\n    vec2 p1 = vec2(-.6, .0);\n    vec2 p2 = vec2(.6, .0);\n\n    // The return value is 0 if the pixel is not in the brush texture and up to 1 if it is.\n    float tex = brushLine(uv, p1, p2, .1);    \n    \n    // Have a little fun with the brush color\n    float t = iTime/6.;\n    vec3 brushColor = normalize(vec3(.3+sin(2.*t)*.3, .1+sin(t)*.1, .1+cos(t)*.1));\n    \n    // Output to screen\n    fragColor = vec4(tex * brushColor, 1.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}