{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float PI = 3.14159;\nconst float MAX_ITS = 10.0;\nvec2 samples[4];\n\nvec2 Zsqr(vec2 Z)\n{\n\t//(a+ib)^2 = (a^2 - b^2) + i*(2ab)\n\treturn vec2(Z.x*Z.x - Z.y*Z.y, 2.0*Z.x*Z.y);\n}\n\nvec2 Zmul(vec2 P, vec2 Q)\n{\n\t//(a+ib)*(c+id) = (ac - bd) + i*(ad+bc)\n\treturn vec2(P.x*Q.x - P.y*Q.y, P.x*Q.y + P.y*Q.x);\n}\n\nvec2 Zexp(vec2 Z)\n{\n\t//e^(a+ib) = e^a*e^(ib) = e^a*cos(b) + i*e^a*sin(b)\n\tfloat etoa = exp(Z.x);\n\treturn vec2(etoa*cos(Z.y), etoa*sin(Z.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 offset = vec2(cos(float(i)/2.0*PI), sin(float(i)/2.0*PI))/1.5;\n\t\t\n\t\t//Get coordinates in the range [-1.0, 1.0]\n\t\tvec2 uv = (fragCoord.xy+offset) / iResolution.xy;\n\t\tvec2 aspect_uv = (uv - 0.5) * 2.0; \n\t\t\n\t\t//Adjust for aspect ratio\n\t\tsamples[i] = aspect_uv * (iResolution.xy / iResolution.y);\n\t}\n\t//Setup complex parameters for the Julia set\n\t//Here we animate C to give an interesting morphing effect\n\tvec2 C = vec2(cos(iTime/17.0), sin(iTime/47.0));\n\tfloat alpha = (1.0 + cos(iTime/91.0)) * 0.5;\n\t\n\tfragColor = vec4(0.0);\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 Z = 1.3*(samples[i]);\n\t\t\n\t\tfloat iter = 0.0;\n\t\tvec3 orbit = vec3(1e30);\n\t\tbool exited = false;\n\t\t\n\t\t//Iterate through MAX_ITS iterations\n\t\tfor(float n = 1.0; n <= MAX_ITS; n++)\n\t\t{\n            //We are using Z_{n+1} = a*e^{Z_n^3} + (1-a)*e^{Z_n^4} + C as our update function\n\t\t\tZ = alpha*Zexp(Zmul(Zsqr(Z),Z)) + (1.0-alpha)*Zexp(Zsqr(Zsqr(Z)))/7.0 + C;\n\t\t\tfloat r = length(Z);\n\t\t\t//We are keeping track of the closest the point Z comes to:\n\t\t\t//  the origin\n\t\t\t//\tthe real axis\n\t\t\t//\tthe imaginary axis\n\t\t\torbit = min(vec3(r,abs(Z)), orbit);\n\t\t\t//We assume that if |Z_n| > 2.0 then Z_inf diverges\n\t\t\tif(r > 2.0)\n\t\t\t{\n\t\t\t\titer = n;\n\t\t\t\texited = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Plot those orbit trap calculations\n\t\tvec3 color = exp(-orbit*vec3(0.3,1.3,1.0));\n        \n        vec3 A0 =       smoothstep(0.96, 1.0, color);\n        \n        vec3 A1 =       smoothstep(0.78, 0.8, color);\n        vec3 A2 = 1.0 - smoothstep(0.8, 0.82, color);\n\n        fragColor += vec4(color * 0.8 + (A1 * A2 + A0), 1.0) * 0.25;\n\t}\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dj3zD","date":"1384653932","viewed":257,"name":"Julia Set Example","username":"liamboone","description":"Example of the Julia set in 2D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}