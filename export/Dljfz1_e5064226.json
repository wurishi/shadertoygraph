{"ver":"0.1","info":{"id":"Dljfz1","date":"1695294143","viewed":63,"name":"Anatomy Textures","username":"Luggen","description":"An experiment in using Shadertoy as a tool for making procedural tiled textures, for use in regular modeling.\nThe Buffer A program generates height maps while the main program displays them or turn them into normal maps.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["texture","muscle","fibers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Generate normal map from height map\n//\n\n// Settings\n//\n#define DISPLAY_HEIGHT 0\n#define INTENSITY      10\n\n// Main\n//\nvoid mainImage(out v4 fragColor, in v2 fragCoord)\n{\n#if DISPLAY_HEIGHT\n    fragColor = Load(iChannel0, i2(fragCoord), 0);\n#else\n    s32 dim = OUTPUT_SIZE;\n\ti2  cP  = i2(fragCoord) % dim;;\n\t// Height map gradient\n\t//     t\n\t//     |\n\t// l---c---r\n\t//     |\n\t//     b\n\ti2 rP  = i2(ModIncrement(cP.x, dim), cP.y);\n\ti2 lP  = i2(ModDecrement(cP.x, dim), cP.y);\n\ti2 tP  = i2(cP.x,                    ModIncrement(cP.y, dim));\n\ti2 bP  = i2(cP.x,                    ModDecrement(cP.y, dim));\n\t\n\tf32 ch = Load(iChannel0, cP, 0).x;\n\tf32 rh = Load(iChannel0, rP, 0).x;\n\tf32 lh = Load(iChannel0, lP, 0).x;\n\tf32 th = Load(iChannel0, tP, 0).x;\n\tf32 bh = Load(iChannel0, bP, 0).x;\n\t\n\trh = (rh + ch) * 0.5f;\n\tlh = (lh + ch) * 0.5f;\n\tth = (th + ch) * 0.5f;\n\tbh = (bh + ch) * 0.5f;\n\t\n\tv2  G  = v2(rh - lh, th - bh) * f32(INTENSITY);\n\tv2  T  = Normalize(v2(1.0f, G.x));\n\tv2  B  = Normalize(v2(1.0f, G.y));\n\tv3  N  = Cross(v3(T.x, 0.0f, T.y), v3(0.0f, B.x, B.y));\n\t\n\tfragColor = v4(MulAdd(N, 0.5f, 0.5f), 1.0f);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Settings\n//\n#define OUTPUT_SIZE 1024\n\n// API override\n//\n#define u32 uint\n#define s32 int\n#define f32 float\n#define v2  vec2\n#define v3  vec3\n#define v4  vec4\n#define m2  mat2\n#define m3  mat3\n#define m4  mat4\n#define i2  ivec2\n#define i3  ivec3\n\n#define Cos        cos\n#define Sin        sin\n#define ATan       atan\n#define Abs        abs\n#define Sign       sign\n#define Min        min\n#define Max        max\n#define Clamp      clamp\n#define Frac       fract\n#define Floor      floor\n#define Ceil       ceil\n#define Exp        exp\n#define Lerp       mix\n#define SmoothStep smoothstep\n#define Dot        dot\n#define Cross      cross\n#define Normalize  normalize\n#define Length     length\n#define SquareRoot sqrt\n#define Distance   distance\n#define Reflect    reflect\n#define Power      pow\n#define Sample     texture\n#define Load       texelFetch\n\n// Math utility\n//\n#define TAU 6.28318530718f\n#define PI  3.14159265359f\n#define INF 1000000.0f\n\n#define Clamp01(value) clamp(value, 0.0f, 1.0f)\n\n#define MulAdd(value, mul, add) (((value) * (mul)) + (add))\n\nf32 SmoothT(f32 t)\n{\n\treturn t * t * (3.0f - (2.0f * t));\n}\n\nv2 SmoothT(v2 t)\n{\n\treturn t * t * (3.0f - (2.0f * t));\n}\n\nf32 MapLinear(f32 fromMin, f32 fromMax, f32 toMin, f32 toMax, f32 value)\n{\n    f32 fromRange = fromMax - fromMin;\n    f32 t         = (value - fromMin) / fromRange;\n    return toMin + ((toMax - toMin) * t);\n}\n\nf32 InvSquared(f32 t)\n{\n\tt = 1.0f - t;\n\treturn 1.0f - (t * t);\n}\n\ns32 ModIncrement(s32 i, s32 m)\n{\n\t++i;\n\treturn (i >= m) ? 0 : i;\n}\n\ni2 ModIncrement(i2 i, i2 m)\n{\n\t++i;\n\treturn i2((i.x >= m.x) ? 0 : i.x, (i.y >= m.y) ? 0 : i.y);\n}\n\ns32 ModDecrement(s32 i, s32 m)\n{\n\t--i;\n    --m;\n\treturn (i < 0) ? m : i;\n}\n\ni2 ModDecrement(i2 i, i2 m)\n{\n\t--i;\n    --m;\n\treturn i2((i.x < 0) ? m.x : i.x, (i.y < 0) ? m.y : i.y);\n}\n\ni2 SMod(i2 i, i2 m)\n{\n    i2 d = i / m;\n    i   += (1 - d) * m;\n    d    = i / m;\n    return i - (d * m);\n}\n\n// RNG\n//\nf32 Random(f32 id)\n{\n\treturn Frac(Sin(id) * 475830.0f);\n}\n\nf32 Random(s32 id)\n{\n\treturn Random(f32(id));\n}\n\nf32 Random(v2 id)\n{\n\treturn Frac(Sin(Dot(id, v2(145.246634f, 207.0234f))) * 4824.0f);\n}\n\nf32 SRandom(v2 id)\n{\n\treturn MulAdd(Random(id), 2.0f, -1.0f);\n}\n\nf32 SRandom(i2 id)\n{\n\treturn MulAdd(Random(v2(id)), 2.0f, -1.0f);\n}\n\nv2 Random2(v2 id)\n{\n\treturn Frac(v2(Sin(Dot(id, v2(198.39802f, 302.9475f))) * 4824.0f,\n\t\t\t\t   Cos(Dot(id, v2(-236.346f, 729.8347f))) * 4824.0f));\n}\n\nv2 Random2(i2 id)\n{\n\treturn Random2(v2(id));\n}\n\nv2 SRandom2(v2 id)\n{\n\treturn MulAdd(Random2(id), 2.0f, -1.0f);\n}\n\nv2 SRandom2(i2 id)\n{\n\treturn SRandom2(v2(id));\n}\n\n// Noise\n//\nf32 Noise(f32 P, f32 cellWidth)\n{\n\tf32 gridP = P / cellWidth;\n\tf32 id0   = Floor(gridP);\n\tf32 id1   = id0 + 1.0f;\n\tf32 t     = SmoothT(gridP - id0);\n\t// d---c\n\t// |   |\n\t// a---b\n\tf32 a = Random(id0);\n\tf32 b = Random(id1);\n\t\n\treturn Lerp(a, b, t);\n}\n\nf32 Noise(v2 P, f32 cellWidth)\n{\n\tv2 gridP = P / cellWidth;\n\tv2 id0   = Floor(gridP);\n\tv2 id1   = id0 + 1.0f;\n\tv2 T     = SmoothT(gridP - id0);\n\t// d---c\n\t// |   |\n\t// a---b\n\tf32 a = Random(id0);\n\tf32 b = Random(v2(id1.x, id0.y));\n\tf32 c = Random(id1);\n\tf32 d = Random(v2(id0.x, id1.y));\n\t\n\treturn Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\nf32 TiledNoise(v2 P, f32 cellWidth, s32 seed)\n{\n\ts32 gridDim = s32(1.0f / cellWidth);\n\tv2  gridP   = P * f32(gridDim);\n\ti2  cellID  = i2(Floor(gridP));\n\ti2  id0     = cellID    % gridDim;\n    i2  id1     = (id0 + 1) % gridDim;\n\tv2  T       = SmoothT(gridP - v2(cellID));\n\t// d---c\n\t// |   |\n\t// a---b\n\tid0 += seed;\n\tid1 += seed;\n\tf32 a = Random(v2(id0));\n\tf32 b = Random(v2(id1.x, id0.y));\n\tf32 c = Random(v2(id1));\n\tf32 d = Random(v2(id0.x, id1.y));\n\t\n\treturn Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\nf32 TiledNoise(v2 P, v2 cellWidth, s32 seed)\n{\n\ti2  gridDim = i2(1.0f / cellWidth);\n\tv2  gridP   = P * v2(gridDim);\n\ti2  cellID  = i2(Floor(gridP));\n\ti2  id0     = cellID    % gridDim;\n    i2  id1     = (id0 + 1) % gridDim;\n\tv2  T       = SmoothT(gridP - v2(cellID));\n\t// d---c\n\t// |   |\n\t// a---b\n\tid0 += seed;\n\tid1 += seed;\n\tf32 a = Random(v2(id0));\n\tf32 b = Random(v2(id1.x, id0.y));\n\tf32 c = Random(v2(id1));\n\tf32 d = Random(v2(id0.x, id1.y));\n\t\n\treturn Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\nf32 WarpedScale(f32 P, f32 cellWidth, f32 dist, s32 seed, out s32 outID)\n{\n\ts32 gridDim   = s32(1.0f / cellWidth);\n\tf32 gridP     = P * f32(gridDim);\n\ts32 cellID    = s32(Floor(gridP + 0.5f));\n\toutID         = cellID;\n\ts32 sampID    = outID + seed;\n\t\n\t//  a-----b-P---c\n\tf32 aOffset = Lerp(-dist, dist, Random(f32(sampID - 1)));\n\tf32 bOffset = Lerp(-dist, dist, Random(f32(sampID)));\n\tf32 cOffset = Lerp(-dist, dist, Random(f32(sampID + 1)));\n\t\n\tf32 aP = gridP - f32(cellID - 1) - aOffset;\n\tf32 bP = gridP - f32(cellID)     - bOffset;\n\t\n\tbool behindB = bP < 0.0f;\n\tf32  range   = (behindB) ? (1.0f + bOffset - aOffset) : (1.0f + cOffset - bOffset);\n\tf32  cellP   = (behindB) ? aP : bP;\n\toutID        = (behindB) ? cellID - 1 : cellID;\n\t\n\tcellP /= range;\n\t\n\treturn Frac(cellP);\n}\n\nf32 TiledWarpedScale(f32 P, f32 cellWidth, f32 dist, s32 seed, out s32 outID)\n{\n\ts32 gridDim   = s32(1.0f / cellWidth);\n\tf32 gridP     = P * f32(gridDim);\n\ts32 cellID    = s32(Floor(gridP + 0.5f));\n\t\n\ts32 bID = cellID % gridDim;\n\ts32 aID = ModDecrement(bID, gridDim);\n\ts32 cID = ModIncrement(bID, gridDim);\n\t\n\t//  a-----b-P---c\n\tf32 aOffset = Lerp(-dist, dist, Random(f32(aID + seed)));\n\tf32 bOffset = Lerp(-dist, dist, Random(f32(bID + seed)));\n\tf32 cOffset = Lerp(-dist, dist, Random(f32(cID + seed)));\n\t\n\tf32 aP = gridP - f32(cellID - 1) - aOffset;\n\tf32 bP = gridP - f32(cellID)     - bOffset;\n\t\n\tbool behindB = bP < 0.0f;\n\tf32  range   = (behindB) ? (1.0f + bOffset - aOffset) : (1.0f + cOffset - bOffset);\n\tf32  cellP   = (behindB) ? aP : bP;\n\toutID        = (behindB) ? aID : bID;\n\t\n\tcellP /= range;\n\t\n\treturn Frac(cellP);\n}\n\nf32 GradNoise(v2 P, f32 cellWidth)\n{\n\tv2 gridP = P / cellWidth;\n\tv2 id0   = Floor(gridP);\n\tv2 id1   = id0 + 1.0f;\n\tv2 T     = gridP - id0;\n\t// d---c\n\t// |   |\n\t// a---b\n\tv2 A = SRandom2(id0);\n\tv2 B = SRandom2(v2(id1.x, id0.y));\n\tv2 C = SRandom2(id1);\n\tv2 D = SRandom2(v2(id0.x, id1.y));\n\t\n\tf32 a = Dot(A, T);\n\tf32 b = Dot(B, T - v2(1.0f, 0.0f));\n\tf32 c = Dot(C, T - 1.0f);\n\tf32 d = Dot(D, T - v2(0.0f, 1.0f));\n    \n\tT = SmoothT(T);\n    return Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\nf32 TiledGradNoise(v2 P, v2 cellWidth, s32 seed)\n{\n\tv2  fDim   = 1.0f / cellWidth;\n\ti2  iDim   = i2(fDim);\n\tv2  gridP  = P * fDim;\n\tv2  cellID = Floor(gridP);\n\ti2  id0    = i2(cellID) % iDim;\n\ti2  id1    = ModIncrement(id0, i2(iDim));\n\tv2  T      = gridP - cellID;\n\t// d---c\n\t// |   |\n\t// a---b\n\tid0 += seed;\n\tid1 += seed;\n\t\n\tv2 A = SRandom2(id0);\n\tv2 B = SRandom2(i2(id1.x, id0.y));\n\tv2 C = SRandom2(id1);\n\tv2 D = SRandom2(i2(id0.x, id1.y));\n\t\n\tf32 a = Dot(A, T);\n\tf32 b = Dot(B, T - v2(1.0f, 0.0f));\n\tf32 c = Dot(C, T - 1.0f);\n\tf32 d = Dot(D, T - v2(0.0f, 1.0f));\n    \n    T = SmoothT(T);\n\treturn Lerp(Lerp(a, b, T.x), Lerp(d, c, T.x), T.y);\n}\n\nf32 TiledVoronoi(v2 P, v2 cellWidth, f32 dist, s32 seed)\n{\n\tv2  fDim   = 1.0f / cellWidth;\n\ti2  iDim   = i2(fDim);\n\tv2  gridP  = P * fDim;\n\tv2  cellID = Floor(gridP);\n\ti2  id0    = i2(cellID);\n    i2  minID  = id0 - 1;\n    i2  maxID  = id0 + 1;\n\t\n\tf32 minDistance = 2.0f;\n    i2  curID;\n\tfor (curID.y = minID.y; curID.y <= maxID.y; ++curID.y)\n\t{\n\t\tfor (curID.x = minID.x; curID.x <= maxID.x; ++curID.x)\n\t\t{\n            v2  curCellP = v2(curID);\n            i2  randID   = SMod(curID, iDim);\n            v2  T        = MulAdd(Random2(v2(randID + seed)), 2.0f, -1.0f) * dist;\n\t\t\tv2  pointP   = curCellP + 0.5f + T;\n\t\t\tminDistance  = Min(minDistance, Distance(gridP, pointP));\n\t\t}\n\t}\n\treturn minDistance;\n}\n\n// Drawing\n//\nf32 Grid(v2 P, f32 cellWidth, f32 lineExtent)\n{\n\tv2 gridP = P / cellWidth;\n\tv2 cellP = Abs(MulAdd(Frac(gridP), 2.0f, -1.0f));\n\t\n\treturn SmoothStep(lineExtent, 0.0f, 1.0f - Max(cellP.x, cellP.y));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Generate height map\n//\n\n// Settings\n//\n#define GRID 0\n\n#define MUSCLE 1\n#define SINEW  0\n#define FAT    0\n\n// Main\n//\nvoid mainImage(out v4 fragColor, in v2 fragCoord)\n{\n\tv2  P      = fragCoord / f32(OUTPUT_SIZE);\n\t\n    f32 result = 0.0f;\n#if MUSCLE\n\ts32 curID     = 0;\n    s32 seed      = 891;\n\t\n\tf32 w0 = 0.02f;\n\tf32 P0 = TiledWarpedScale(P.x, w0, 0.1f, seed, curID);\n\tf32 h0 = Abs(MulAdd(P0, 3.0f, -1.5f)) - 0.5f;\n\th0     = InvSquared(1.0f - Clamp01(h0));\n\t\n\tf32 h1 = TiledNoise(P, v2(0.01f, 0.2f), 132);\n\t\n\tf32 h2 = TiledNoise(v2(P.x + 0.01f, P.y), v2(0.005f, 0.1f), 513);\n\t\n    f32 h3 = MulAdd((h1 + h2) * 0.5f, 0.5f, 0.5f);\n    \n    f32 h4 = Lerp(TiledNoise(P, v2(0.005f, 0.1f), 5489), 1.0f, 0.4f);\n    \n    result = h0 + ((h4 * (1.0f - h0)) * 0.8f);\n    result = result * h3;\n\t\n#elif SINEW\n\tf32 h0 = TiledVoronoi(P, v2(0.01f, 0.2f), 0.5f, 26);\n\tf32 h1 = TiledVoronoi(P + 0.01f, v2(0.0025f, 0.1f), 0.5f, 847);\n\t\n    result = Lerp(h0, h1, 0.4f);\n    result = InvSquared(result);\n    \n#elif FAT\n    f32 h0 = TiledGradNoise(P, v2(0.05f), 897);\n\tf32 h1 = TiledGradNoise(P, v2(0.02f), 86);\n\n    f32 h2 = InvSquared(InvSquared(MulAdd(h0, 0.5f, 0.5f)));\n    f32 h3 = InvSquared(MulAdd(h1, 0.5f, 0.5f));\n    \n    f32 h4 = SmoothT(1.0f - TiledVoronoi(P, v2(0.01f), 0.5f, 156));\n    \n    result = Lerp((h2 + h3) * 0.5f, h4, 0.1f);\n    \n#endif\n\tfragColor = v4(v3(result), 1.0f);\n#if GRID\n\tfragColor.xyz = Lerp(fragColor.xyz, v3(0.0f, 1.0f, 1.0f), Grid(P, 1.0f, 0.005f) * 0.5f);\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}