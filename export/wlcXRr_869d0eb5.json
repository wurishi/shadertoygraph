{"ver":"0.1","info":{"id":"wlcXRr","date":"1580280668","viewed":141,"name":"3d ray-shape intersections","username":"16807","description":"Click the screen to rotate. Shapes are determined analytically as opposed to using ray marching. This shader demonstrates a way to build any shape made using unions, intersections, and negations using ray-line intersections.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["csg","distance","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define SMALL 1e-10\n#define PI 3.1415926\n\n\nbool is_3d_point_in_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n\nstruct maybe_vec2\n{\n    vec2 value; \n    bool  exists; \n};\nstruct maybe_float\n{\n    float value;  \n    bool  exists; \n};\n\nmaybe_float get_distance_along_line_to_union(\n    in maybe_float shape1,\n    in maybe_float shape2\n) {\n    return maybe_float(\n        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),\n        shape1.exists || shape2.exists\n    );\n}\n\nmaybe_vec2 get_distances_along_line_to_union(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),\n             !shape1.exists ? shape2.value.y  : !shape2.exists ? shape1.value.y  : max(shape1.value.y,  shape2.value.y )),\n        shape1.exists || shape2.exists\n    );\n}\n\n\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape2.exists ? shape1.value.x : min(shape2.value.y, shape1.value.x),\n             !shape2.exists ? shape1.value.y : min(shape2.value.x, shape1.value.y)),\n        shape1.exists && (!shape2.exists || shape1.value.x < shape2.value.x || shape2.value.y < shape1.value.y)\n    );\n}\n\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.f;\n    float y  = shape1.exists && shape2.exists ? min(shape1.value.y,  shape2.value.y ) : 0.f;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\n\nfloat get_distance_along_2d_line_nearest_to_point(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0\n){\n    return dot(B0 - A0, A);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\n\nmaybe_float get_distance_along_2d_line_to_line(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    return maybe_float(\n        length(R) / dot(B, normalize(-R)), \n        abs(abs(dot(A, B)) - 1.f) > 0.f\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\n\nmaybe_float get_distance_along_2d_line_to_ray(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 line segment endpoint 1\nB1 line segment endpoint 2\n*/\n\nmaybe_float get_distance_along_2d_line_to_line_segment(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|\n    vec2 B = normalize(B2 - B1);\n    vec2 D = B1 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B2 - B1));\n}\n\nmaybe_vec2 get_distances_along_2d_line_to_circle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in float r\n){\n    vec2 D = B0 - A0;\n    float xz = dot(D, A);\n    float z2 = dot(D, D) - xz * xz;\n    float y2 = r * r - z2;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\n*/\n\nmaybe_vec2 get_distances_along_2d_line_to_triangle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2,\n    in vec2 B3\n){\n    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);\n    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);\n    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);\n    return maybe_vec2(\n        vec2(min(line1.value, min(line2.value, line3.value)), \n             max(line1.value, max(line2.value, line3.value))), \n        line1.exists || line2.exists || line3.exists\n    );\n}\n\nfloat get_distance_along_3d_line_nearest_to_point(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0\n){\n    return dot(B0 - A0, A);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_nearest_to_line(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 C = normalize(cross(B, A));\n    // cross\n    vec3 R = D - dot(D, A) * A - dot(D, C) * C;\n    // rejection\n    return maybe_float(\n        length(R) / -dot(B, normalize(R)), \n        abs(abs(dot(A, B)) - 1.f) > 0.f\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_nearest_to_ray(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 line segment endpoint 1\nB2 line segment endpoint 2\n*/\n\nmaybe_float get_distance_along_3d_line_nearest_to_line_segment(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B1\n){\n    vec3 B = normalize(B1 - B0);\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B1 - B0));\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 circle origin\nN  circle surface normal, normalized\nr  circle radius\n*/\n\nmaybe_float get_distance_along_3d_line_to_circle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N,\n    in float r\n){\n    // intersection(plane, sphere)\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\n\nmaybe_float get_distance_along_3d_line_to_triangle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3\n){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3 B0 = (B1 + B2 + B3) / 3.;\n    vec3 N = normalize(cross(B1 - B2, B2 - B3));\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3 At = A0 + A * t.value;\n    vec3 B2B1hat = normalize(B2 - B1);\n    vec3 B3B2hat = normalize(B3 - B2);\n    vec3 B1B3hat = normalize(B1 - B3);\n    return maybe_float(t.value, \n        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) && \n        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) && \n        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float xz = dot(B0 - A0, A);\n    float z = length(A0 + A * xz - B0);\n    float y2 = r * r - z * z;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(\n        vec2(xz - dxr, xz + dxr), \n        y2 > 0.\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\n\nmaybe_float get_distance_along_3d_line_to_ellipsoid(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 R\n){\n    // NOTE: shamelessly copy pasted, all credit goes to Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 Or = (A0 - B0) / R;\n    vec3 Ar = A / R;\n    float ArAr = dot(Ar, Ar);\n    float OrAr = dot(Or, Ar);\n    float OrOr = dot(Or, Or);\n    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);\n    return maybe_float(\n        (-OrAr - sqrt(h)) / ArAr, \n        h >= 0.0\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\n\nmaybe_float get_distance_along_3d_line_to_tetrahedron(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3,\n    in vec3 B4\n){\n    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);\n    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);\n    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);\n    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);\n    maybe_float hit;\n    hit = get_distance_along_line_to_union(hit1, hit2);\n    hit = get_distance_along_line_to_union(hit,  hit3);\n    hit = get_distance_along_line_to_union(hit,  hit4);\n    return hit;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.f));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a), \n        h > 0.0\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y,  a_in);\n    float exit     = min(tube.value.x, a_out);\n    return maybe_vec2( \n        vec2(entrance, exit), \n        tube.exists && entrance < exit\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 capsule endpoint 1\nB2 capsule endpoing 2\nr  capsule radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_capsule(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);\n    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);\n    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);\n    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);\n    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);\n    return capsule;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 ring endpoint 1\nB2 ring endpoing 2\nro ring outer radius\nri ring inner radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_ring(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float ro,\n    in float ri\n){\n    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);\n    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);\n    maybe_vec2 ring  = get_distances_along_line_to_negation(outer, inner);\n    return ring;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\ncosb cosine of cone half angle\n*/\n\nmaybe_float get_distance_along_3d_line_to_infinite_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float cosb\n){\n    vec3 D = A0 - B0;\n    float a = dot(A, B) * dot(A, B) - cosb * cosb;\n    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);\n    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;\n    float det = b * b - 4. * a * c;\n    if (det < 0.)\n    {\n        return maybe_float(0.f, false);\n    }\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t)\n    {\n        t = t2;\n    }\n    else {\n        t = t1;\n    }\n\n    vec3 cp = A0 + t * A - B0;\n    float h = dot(cp, B);\n    return maybe_float(t, t > 0. && h > 0.);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\nr  cone radius\nh  cone height\n*/\n\nmaybe_float get_distance_along_3d_line_to_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r,\n    in float h\n){\n    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));\n    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;\n    cone = get_distance_along_line_to_union(end, cone);\n    return cone;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 cone endpoint 1\nB2 cone endpoint 2\nr1 cone endpoint 1 radius\nr2 cone endpoint 2 radius\n*/\n\nmaybe_float get_distance_along_3d_line_to_capped_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r1,\n    in float r2\n){\n    float dh = length(B2 - B1);\n    float dr = r2 - r1;\n    float rmax = max(r2, r1);\n    float rmin = min(r2, r1);\n    float hmax = rmax * dr / dh;\n    float hmin = rmin * dr / dh;\n    vec3 B = sign(dr) * normalize(B2 - B1);\n    vec3 Bmax = (r2 > r1? B2 : B1);\n    vec3 B0 = Bmax - B * hmax;\n    vec3 Bmin = Bmax - B * hmin;\n    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);\n    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));\n    float c_h = dot(A0 + cone.value * A - B0, B);\n    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;\n    cone = get_distance_along_line_to_union(cone, end1);\n    cone = get_distance_along_line_to_union(cone, end2);\n    return cone;\n}\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.3+ iMouse.x * -0.01 + 0.3*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    \n    maybe_vec2 shapes;\n    maybe_vec2 shape;\n    maybe_float shapes2;\n    maybe_float shape2;\n    float scale = 0.23;\n    float separation = 0.25;\n    vec3 center;\n    \n    center = separation * vec3(-1,-1,0);\n    shapes = get_distances_along_3d_line_to_sphere(A0, A, center, scale);\n    \n    center = separation * vec3(-1, 1,0);\n    shape  = get_distances_along_3d_line_to_cylinder(A0, A, center+scale*vec3(0,0,-1), center+scale*vec3(0,0,1), scale);\n    shapes = get_distances_along_line_to_union(shapes, shape);\n    \n    center = separation * vec3(1,-1,0);\n    shape  = get_distances_along_3d_line_to_capsule(A0, A, center+scale*vec3(0,0,-1), center+scale*vec3(0,0,1), scale);\n    shapes = get_distances_along_line_to_union(shapes, shape);\n     \n    center = separation * vec3(1,1,0);\n    shape  = get_distances_along_3d_line_to_ring(A0, A, center+scale*vec3(0,0,-0.5), center+scale*vec3(0,0,0.5), scale, 0.7*scale);\n    shapes = get_distances_along_line_to_union(shapes, shape);\n     \n    // some line intersection functions only solve for entrance distance\n    // so we do those functions next\n    \n    shapes2 = maybe_float(shapes.value.x, shapes.exists);\n    \n    center = separation * vec3(-3,-1,0);\n    shape2 = get_distance_along_3d_line_to_tetrahedron(A0, A, center+scale*vec3(1,0,0), center+scale*vec3(0,1,0), center+scale*vec3(0,0,1), center+scale*vec3(-1,-1,-1) );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n     \n    center = separation * vec3(-4,1,0);\n    shape2 = get_distance_along_3d_line_to_ellipsoid(A0, A, center+scale*vec3(1,0,0), scale*vec3(1,2,3)/2.f );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n     \n    center = separation * vec3(3,-1,0);\n    shape2 = get_distance_along_3d_line_to_circle(A0, A, center, vec3(0,0,1), scale );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n     \n    center = separation * vec3(3,1,0);\n    shape2 = get_distance_along_3d_line_to_triangle(A0, A, center+scale*vec3(1,0,0), center+scale*vec3(0,1,0), center+scale*vec3(0,0,1) );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n    \n    center = separation * vec3(5,-1,0);\n    shape2 = get_distance_along_3d_line_to_cone(A0, A, center, vec3(0,0,1), scale, 2.f*scale );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n    \n    vec3  color = vec3(0);\n    if (shapes2.exists)\n    {\n        color = vec3(shapes2.value, shapes.value.y, 0);\n    }\n    \n    fragColor = vec4(color/4.f, 1.0);\n}","name":"Image","description":"","type":"image"}]}