{"ver":"0.1","info":{"id":"4sscDr","date":"1488055709","viewed":260,"name":"Ray tracing - reflection","username":"MulattoKid","description":"My first attempt at a ray tracer - nothing groundbreaking, but I enjoyed learning this!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAY_T_MIN 0.0001\n#define RAY_T_MAX 1000.0\n#define ASPECT_RATIO iResolution.x / iResolution.y\n#define FOV 70.0\n\n//Camera\nvec3 origin = vec3(0.0, 0.5, 1.2);\nvec3 at = vec3(0.0, 0.0, 0.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\n\n//Ray\nvec3 direction = normalize(vec3(0.0, -0.3, -1.0));\nbool intersected = false;\n\n//Sphere\nvec3 center = vec3(0.0, 0.0, 0.0);\nfloat radius = 0.5;\n\n//Light\nvec3 lightPos = vec3(2.5, 2.5, 1.5);\nfloat lightIntensity = 1.0;\nfloat diffuseCoefficient = 0.45;\nfloat specularCoefficient = 0.45;\nfloat ambientLight = 0.8;\n\nfloat t = RAY_T_MAX;\n\nvec3 intersectionPoint(vec3 rayOrigin, float t)\n{\n\treturn rayOrigin + (direction * t);\n}\n\nvec4 colorPixel(vec3 rayDirection)\n{\n    return texture(iChannel0, rayDirection * vec3(1.0, -1.0, 1.0));\n}\n\nvec4 colorSphere(vec3 rayOrigin)\n{\n    vec3 point = intersectionPoint(rayOrigin, t);\n    vec3 normal = normalize((point - center) / radius);\n\n    vec3 incidentLight = normalize(lightPos - point);\n    vec3 reflectiveVector = normalize(reflect(-incidentLight, normal));\n\n    vec3 diffuse = vec3(dot(normal, incidentLight));\n    vec3 specular = vec3(dot(origin, reflectiveVector));\n\n    vec3 color = ((diffuse * diffuseCoefficient) + (specular * specularCoefficient)) + ambientLight;\n    return vec4(color, 1.0);\n}\n\nvec4 intersectSphere()\n{\n\t//Transform the ray so we can consider origin-centered sphere\n\tvec3 localOrigin = origin - center;\n\n\t//Calculate quadratic coeff\ticients\n\tfloat a = pow(abs(length(direction)), 2.0);\n\tfloat b = 2.0 * dot(direction, localOrigin);\n\tfloat c = pow(abs(length(localOrigin)), 2.0) - pow(radius, 2.0);\n\n\t//Check whether we intersect\n\tfloat discriminant = pow(abs(b), 2.0) - (4.0 * a * c);\n\tif (discriminant < 0.0)\n\t\treturn colorPixel(direction);\n\n\t//Find the two points of intersection, t1 = close, t2 = far, t1 might be equal to t2 if there is only one solution\n\tfloat t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n\n\t//Check that the close intersection is within the distances we've specified\n\tif (t1 > RAY_T_MIN && t1 < RAY_T_MAX)\n\t\tt = t1;\n\n    //Calculate necessary elements for reflection ray\n    vec3 reflectionPoint = intersectionPoint(localOrigin, t);\n    vec3 normalAtPoint = normalize((reflectionPoint - center) / radius);\n\tvec3 reflectionRayDirection = normalize(reflect(direction, normalAtPoint));\n    intersected = true;\n    return colorPixel(reflectionRayDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = vec2(fragCoord.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    float h = tan(FOV);\n    float w = h * ASPECT_RATIO;\n    float d = 0.5;\n\n\tdirection = normalize((direction * d) + (screenCoord.x * w * normalize(cross(direction, up))) + (screenCoord.y * h * up));\n    \n    vec4 reflectColor = intersectSphere();\n    //light\n    //if (intersected)\n    \t//reflectColor = reflectColor * colorSphere(origin);   \n\tfragColor = reflectColor;\n}\n","name":"Image","description":"","type":"image"}]}