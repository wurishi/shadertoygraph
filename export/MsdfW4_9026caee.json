{"ver":"0.1","info":{"id":"MsdfW4","date":"1525233591","viewed":1010,"name":"Particle fluid","username":"rory618","description":"Particle simulation done by florian berger (flockaroo), and taken straight from https://shaderoo.org/?shader=YmbWSa","likes":35,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","particle","stochastic","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = vec4(0,0,0,1e9);\n    for(int j = 0; j < iters*5; j++){\n        \n        vec4 r = hash44(vec4(F,i,j));        \n        r.z = sqrt(-2.*log(r.z));\n        r.w *= 6.28318;\n        r.zw = r.z*vec2(cos(r.w),sin(r.w));\n        float id = texture(iChannel1,(i+r.zw*1.2)/R.xy).w;\n        if(id >= 0.){\n            \n            particle t = getParticle(id, iChannel0, iTime, iMouse, R); \n        \tfloat d = max(0.,length(i-t.P))-t.r;\n        \tfloat z = t.d;\n\n            \n             if(z<=o.w && d <0.0){\n           \t\to.xyz = min(vec3(1.),t.color*exp(-0.2-d))*(pow(.6-max(z,-.6)/1.6,2.));\n                o.w=z;\n             }\n        }\n    }\n    //o += texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = texture(iChannel1,i/R.xy);\n    \n    float d = 1e9;\n    float z = 1e9;\n    for(int j = 0; j < iters; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = floor(mod(r.x * 1e3+r.y*1e5+r.z,particles));\n        particle t = getParticle(id, iChannel0, iTime, iMouse, R); \n        float dp = length(i-t.P)-t.r;\n        float zp = t.d;\n        if(max(0.,dp)<=max(0.,d)){\n            if(dp<10.){\n                if(zp*.99<z){\n                    d = dp;\n                    z = zp;\n                    o.x = id;\n                }\n            } else {\n                d = dp;\n                z = zp;\n                o.x = id;\n            }\n        }\n    }\n    d=1e9;\n    for(int j = 0; j < iters; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*30.)/R.xy)[j==0?1:0];\n        particle t = getParticle(id, iChannel0, iTime, iMouse, R); \n        float dp = length(i-t.P)-t.r;\n        float zp = t.d;\n        if(max(0.,dp)<=max(0.,d)){\n            if(dp<5.){\n                if(zp*.99<z){\n                    d = dp;\n                    z = zp;\n                    o.y = id;\n                }\n            } else {\n                d = dp;\n                z = zp;\n                o.y = id;\n            }\n        }\n    }\n    \n    d=1e9;\n    for(int j = 0; j < iters; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*20.)/R.xy)[j==0?2:1];\n        particle t = getParticle(id, iChannel0, iTime, iMouse, R); \n        float dp = length(i-t.P)-t.r;\n        float zp = t.d;\n        if(max(0.,dp)<=max(0.,d)){\n            if(dp<2.){\n                if(zp*.99<z){\n                    d = dp;\n                    z = zp;\n                    o.z = id;\n                }\n            } else {\n                d = dp;\n                z = zp;\n                o.z = id;\n            }\n        }\n    }\n    d=1e9;\n    \n    for(int j = 0; j < iters; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*5.)/R.xy)[j>15?3:2];\n        particle t = getParticle(id, iChannel0, iTime, iMouse, R); \n        float dp = length(i-t.P)-t.r;\n        float zp = t.d;\n        if(max(0.,dp)<=max(0.,d)){\n            if(dp<-5.){\n                if(zp*.99<z){\n                    d = dp;\n                    z = zp;\n                    o.w = id;\n                }\n            } else {\n                d = dp;\n                z = zp;\n                o.w = id;\n            }\n        }\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n#define T(x) mat2(  cos(x+vec4(0,-pi,pi,0)) )\n#define pi 1.570796\n#define cam vec3(0)\n#define theta (iMouse.x>0.?(iMouse.yx/iResolution.yx-.5)*vec2(4.,-4):vec2(.5,-.251))\n#define view (mat3(cos(theta.y),0,-sin(theta.y),0,1,0,sin(theta.y),0,cos(theta.y))*mat3(1,0,0,0,cos(theta.x),sin(theta.x),0,-sin(theta.x),cos(theta.x)))\n#define transform (mat4(1,0,-cam.x/cam.z,0,0,1,-cam.y/cam.z,0,0,0,1,0,0,0,-1./cam.z,1)))\n#define iters 20\n#define particles  float(0x2000)\n\nstruct particle {\n    vec2 P;\n    float d;\n    float r;\n    vec3 color;\n}; \n\nparticle getParticle(float index, sampler2D ch, float iTime, vec4 iMouse, vec3 iResolution){\n    \n    vec3 p = .03*texture(ch,(.5+vec2(mod(index*3.,R.x),floor(index*3./R.x)))/R.xy).xyz;\n    p = p.yzx;\n    float r = 5.3;\n    vec3 proj = ((p-cam)*view);\n    return particle(proj.xy*R.y+R.xy/2.,proj.z,r,vec3(1));\n    \n}\n    \nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(r.x));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// particle fluid\n\n// some quaternion functions\n\n#define ParticleTex iChannel0\n#define PI2 (3.141592653*2.)\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n\n\n// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// particle fluid\n\n// particle related functions\n\n#define NumParticles 0x2000\n\nstruct Particle {\n    vec3 pos;\n    vec3 vel;\n    int nn[4];\n    int idx;\n    int sidx;\n};\n\nint particleIdx(vec2 coord)\n{\n    ivec2 res=textureSize(ParticleTex,0);\n    return (int(coord.y)*res.x+int(coord.x))/3;\n}\n\nvec4 getPixel(int idx)\n{\n    ivec2 res=textureSize(ParticleTex,0);\n    return texelFetch(ParticleTex,ivec2(idx%res.x,idx/res.x),0);\n}\n\nParticle readParticle(int pIdx)\n{\n    Particle p;\n    vec4 p0=getPixel(pIdx*3+0);\n    vec4 p1=getPixel(pIdx*3+1);\n    vec4 p2=getPixel(pIdx*3+2);\n    p.pos=p0.xyz;\n    p.idx=int(p0.w);\n    p.sidx=int(p1.w);\n    p.vel=p1.xyz;\n    p.nn[0]=int(p2.x);\n    p.nn[1]=int(p2.y);\n    p.nn[2]=int(p2.z);\n    p.nn[3]=int(p2.w);\n    return p;\n}\n\nvoid writeParticle(Particle p, inout vec4 color, vec2 coord)\n{\n    ivec2 res=textureSize(ParticleTex,0);\n    //if(particleIdx(coord)!=p.idx) return;\n    color=((int(coord.y)*res.x+int(coord.x))%3==0)?vec4(p.pos,p.idx):color;\n    color=((int(coord.y)*res.x+int(coord.x))%3==1)?vec4(p.vel,p.sidx):color;\n    color=((int(coord.y)*res.x+int(coord.x))%3==2)?vec4(p.nn[0],p.nn[1],p.nn[2],p.nn[3]):color;\n    if(particleIdx(coord)>NumParticles) color=vec4(0,1,0,1);\n}\n\nvoid initParticle(inout Particle p, int idx)\n{\n    int numXY=int(pow(float(NumParticles),.3333)*.95);\n    p.pos=vec3(idx%numXY,(idx/numXY)%numXY,idx/numXY/numXY);\n    p.pos-=vec3(numXY/2,numXY/2,0*numXY/2);\n    p.vel=vec3(0);\n    p.idx=idx;\n    p.sidx=(idx*7)%NumParticles;\n    // init all neighbours to empty\n    p.nn[0]=-1;\n    p.nn[1]=-1;\n    p.nn[2]=-1;\n    p.nn[3]=-1;\n}\n\n// add neighbour to list\nvoid addNb(inout int nb[16], int n)\n{\n    if (n<0) return;\n    for(int i=0;i<16;i++)\n    {\n        // add it only if its not already in the list\n        if (nb[i]==n) return;\n        // add it on first free place (<0 marks free slot)\n        if (nb[i]<0) { nb[i]=n; break; }\n    }\n}\n\n// gather neighbours from own neighbours and neighbour's neighbours\nvoid gatherNeighbours(Particle p, inout int nb[16])\n{\n    // init to empty list\n    for(int i=0;i<16;i++)nb[i]=-1;\n\n    // add own neighbours\n    for(int i=0;i<4;i++)\n    {\n        if(p.nn[i]<0) continue;\n        if(p.nn[i]==p.idx) continue;  // FIXME - this shouldnt happen anyway\n        addNb(nb,p.nn[i]);\n    }\n    \n    // add neighbour's neighbours\n    for(int i=0;i<4;i++)\n    {\n        if(p.nn[i]<0) continue;\n        if(p.nn[i]==p.idx) continue;  // FIXME - this shouldnt happen anyway\n        Particle pn = readParticle(p.nn[i]);\n        for(int j=0;j<4;j++)\n        {\n            if(pn.nn[j]<0) continue;\n            if(pn.nn[j]==p.nn[i]) continue;\n            if(pn.nn[j]==p.idx) continue;\n            addNb(nb,pn.nn[j]);\n        }\n    }\n}\n\n// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// particle fluid\n\n// the actual fluid-simulation\n\n// each particle remembers 4 nearest neighbours\n// on each step nearer neigbours are searched in neighbour's neighbours\n// interaction forces are then only applied from those neighbours\n// this way we get a time complexity of O(n) for n particles in the bulk.\n// for surface effects, though, there has to be random nearest neighbour search\n// so that e.g. drops or breaking waves also find new neighbours not in vicinity \n// of their actual neighbours\n\n//#ShaderooNumPasses 1\n\n\n// force between 2 particles\nvec3 p2pForce(vec3 d) \n{\n    float dd=dot(d,d);\n    float d6=dd*dd*dd;  // lennard jones\n    // d<1 repulsive  d>1 attractive\n    // varies between -rep and ~+att\n    float att=5.;\n    float rep=180.;\n    return 4.*att*d/sqrt(dd)*(dd-1.)/(dd*dd+4.*att/rep);\n    // more lennard-jones-ish\n    //return .2*8.*att*d/sqrt(dd)*(d6-1.)/(d6*d6*sqrt(dd)+8.*att/rep);\n}\n\nvoid forceIA(inout Particle p, int nb[16])\n{\n    vec3 acc=vec3(0.0);\n    \n    // gravity\n    acc+=vec3(0,0,-5);\n    \n    // neighbour ia\n    vec3 nvel=vec3(0);\n    float cnt=0.;\n    for(int i=0;i<16;i++)\n    {\n        if(nb[i]<0) break;\n        if(nb[i]>=NumParticles || nb[i]==p.idx) continue;\n        Particle pn=readParticle(nb[i]);\n        float weight=1.;\n        weight/=(1.+length(pn.pos-p.pos));\n        nvel+=pn.vel*weight;\n        acc+=p2pForce(pn.pos-p.pos);\n        cnt+=weight;\n    }\n    // average velocity of all neighbours\n    nvel/=cnt;\n    \n    // velocity damping\n    //acc-=p.vel*.5;\n    //acc-=p.vel*dot(p.vel,p.vel)*.1;\n    \n    float dt=.01;\n    \n    //neighbour damping\n    acc-=(p.vel-nvel)/dt/10.;\n    //acc-=(p.vel-nvel)*length(p.vel-nvel)/dt/100.;\n    //p.vel=mix(p.vel,nvel,.1*cnt/6.);\n    //p.vel=(p.vel*70.+nvel*cnt)/(cnt+70.);\n    \n    // proceed timestep dt\n    p.vel+=acc*dt*.5;\n    p.pos+=p.vel*dt;\n    p.vel+=acc*dt*.5;\n}\n\nvoid impulseIA(inout Particle p, int nb[16])\n{\n    #define BOX_S 20.*pow(float(NumParticles),.3333)/35.\n    #define BOX_SIZE_X BOX_S\n    #define BOX_SIZE_Y BOX_S\n    #define BOX_SIZE_Z BOX_S*.3\n    \n    // reflect particles on boundinf box\n    vec3 damp=vec3(-.9,.97,1);\n    if(p.pos.z<-BOX_SIZE_Z) { p.pos.z=-BOX_SIZE_Z; if(p.vel.z<0.) p.vel*=damp.yyx; }\n    //if(p.pos.z> BOX_SIZE_Z) { p.pos.z= BOX_SIZE_Z; if(p.vel.z>0.) p.vel.z*=-1.; }\n    if(p.pos.x<-BOX_SIZE_X) { p.pos.x=-BOX_SIZE_X; if(p.vel.x<0.) p.vel*=damp.xyy; }\n    if(p.pos.x> BOX_SIZE_X) { p.pos.x= BOX_SIZE_X; if(p.vel.x>0.) p.vel*=damp.xyy; }\n    if(p.pos.y<-BOX_SIZE_Y) { p.pos.y=-BOX_SIZE_Y; if(p.vel.y<0.) p.vel*=damp.yxy; }\n    if(p.pos.y> BOX_SIZE_Y) { p.pos.y= BOX_SIZE_Y; if(p.vel.y>0.) p.vel*=damp.yxy; }\n    \n    // add some motor on the floor from time to time\n    #if 1\n    if(mod(iTime,40.)>25.)\n    if(abs(p.pos.x)<BOX_SIZE_X*1. && p.pos.z<-BOX_SIZE_Z+1.) { \n        p.vel.y=4./**.25*p.pos.x*/; \n    }\n    #endif\n    \n    // particle collision (impulse transfer)\n    for(int i=0;i<16;i++)\n    {\n        if(nb[i]<0) break;\n        if(nb[i]>=NumParticles || nb[i]==p.idx) continue;\n        Particle pn=readParticle(nb[i]);\n        vec3 d=pn.pos-p.pos;\n        float dl2=dot(d,d);\n        //if (dl2<1.&&dl2>0.00001) {\n            float dvp=dot(p.vel-pn.vel,d);\n            p.vel-=(1.-step(1.,dl2))*step(0.,dvp)*dvp*d/dl2;\n        //}\n    }\n}\n\nvoid allIA(inout Particle p)\n{\n    // gather neighbours\n    int nb[16];\n    gatherNeighbours(p,nb);\n    \n    impulseIA(p,nb);\n    forceIA(p,nb);\n    \n    // FIXME: why do i get nan's here\n    if(isnan(p.vel.x)||isnan(p.vel.y)||isnan(p.vel.z)) p.vel=vec3(0);\n    if(isnan(p.pos.x)||isnan(p.pos.y)||isnan(p.pos.z)) p.pos=vec3(0);\n    \n    //limit vel\n    //float vl=length(p.vel); p.vel=(vl>10.)?p.vel/vl*10.:p.vel;\n}\n\nvoid sortIn(vec3 pos, inout int nn[4], int idx)\n{\n    // dont sort in existing indices\n    if ( idx==nn[0] || idx==nn[1] || idx==nn[2] || idx==nn[3] ) return;\n                \n    float d=length(pos-readParticle(idx).pos);\n    int sidx=4;\n\n    for(int i=0;i<4;i++)\n    {\n        if(nn[i]<0 || d<length(pos-readParticle(nn[i]).pos))\n        {\n            sidx=i; break;\n        }\n    }\n    \n    if(sidx<4)\n    {\n        for(int i=sidx+1;i<4;i++) nn[i]=nn[i-1];\n        nn[sidx]=idx;\n    }\n}\n\nvoid nnFind(inout Particle p)\n{\n    int nn[4]; nn[0]=-1; nn[1]=-1; nn[2]=-1; nn[3]=-1;\n    \n    // sort in own neighbours\n    for(int i=0;i<4;i++) sortIn(p.pos,nn,p.nn[i]);\n    \n    // sort in neighbours-neighbours and more\n    for(int i=0;i<4;i++)\n    {\n        Particle pn = readParticle(p.nn[i]);\n        // sort in neighbours-neighbours\n        for(int j=0;j<4;j++)\n        {\n            if(pn.nn[j]!=p.idx)\n            {\n                sortIn(p.pos,nn,pn.nn[j]);\n                #if 1\n                Particle pn2 = readParticle(pn.nn[j]);\n                // sort in neighbours-neighbours-nieghbours\n                for(int k=0;k<4;k++)\n                {\n                    if(pn2.nn[k]!=p.idx)\n                    {\n                        sortIn(p.pos,nn,pn2.nn[k]);\n                    }\n                }\n                #endif\n            }\n        }\n    }\n    \n    // checking neighbours-neighbours for nearer ones works only in the bulk\n    // for drops falling on the surface or a breaking wave we need some random neighbour checking\n    int nidx=p.sidx;\n    #define RND_NB_NUM 48\n    for(int i=0;i<RND_NB_NUM;i++)\n    {\n        if(nidx!=p.idx)\n           sortIn(p.pos,nn,nidx);\n        nidx++;\n        nidx%=NumParticles;\n    }\n    p.sidx=nidx;\n    p.nn=nn;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    Particle p;\n    int pIdx=particleIdx(fragCoord);\n    if (pIdx>NumParticles) discard;\n    p = readParticle(pIdx);\n    nnFind(p);\n    allIA(p);\n    if(iFrame<100)\n    {\n        initParticle(p,pIdx);\n        ivec2 res = textureSize(iChannel1,0);\n        vec4 rnd = texelFetch(iChannel1,ivec2(pIdx%res.x,pIdx/res.x),0);\n        p.pos+=.3*(rnd.xyz-.5);\n    }\n    writeParticle(p,fragColor,fragCoord);\n}\n\n","name":"Buf B","description":"","type":"buffer"}]}