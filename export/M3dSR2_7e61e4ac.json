{"ver":"0.1","info":{"id":"M3dSR2","date":"1719308588","viewed":52,"name":"Colorful infinit Rule 110","username":"Dalmador","description":"Implementaion of Rule 110 (https://en.wikipedia.org/wiki/Rule_110)\nPress r to reset with random start values.\nplease leave a comment :)","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["colorful","gameoflife","cellularautomata","automaton","rule110","110","turingcomplete"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 addr = fragCoord/ iResolution.xy;\n    // default shader colors\n    vec3 col = vec3(0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4)));\n    float dim = texture(iChannel0, addr).x;\n    fragColor =  vec4(col * dim, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// credit: https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * .1031);p *= p + 33.33;p *= p + p;\n    return fract(p);\n}\n\n// reset with r\n#define RESET_KEY 82\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get filled cells from previous frame\n    // im using a 3x3 area because i reused this code for Conway's Game of Life and other experiments\n    float prev [9];\n    for (float i = 0.; i < 9.; i++)\n    {\n        vec2 addr = uv + vec2(mod(i, 3.) - 2., floor(i / 3.) - 1.) / iResolution.xy;\n        prev[int(i)] = fragCoord.y < iResolution.y - 1.?texture (iChannel0, addr).x:0.;\n    }\n    \n    // date of the direction is stored in y value\n    float up = texture(iChannel0, vec2(1., 1.)).y;\n    int o = up == 1.? 6: 0;\n    \n    // Check if the cell should be alife, depending on three Rules\n    // 1. 101\n    bool filled = (prev[6-o] == 1. && prev[7-o] != 1. && prev[8-o] == 1.);\n    // 2. 001 or 011\n    filled = filled || (prev[6-o] != 1. && prev[8-o] == 1.);\n    // 3. 010 or 110\n    filled = filled || (prev[7-o] == 1. && prev[8-o] != 1.);\n    \n    // i am counting the row in z value to know when to switch directions\n    float row =  texture(iChannel0, vec2(1., 1.)).z + 1./ iResolution.y;\n    // change direction if the end of the screen is reached\n    float nextDir = (row >= 1.)? mod(up + 1., 2.) : up;\n    // reset row if the direction changed\n    row = up == nextDir? row : 4./ iResolution.y;\n    \n    // reset mechanic\n    if (texelFetch(iChannel1, ivec2(RESET_KEY, 0), 0).r > 0. || iFrame  < 1)\n    {\n        filled = fragCoord.y >= iResolution.y - 1. && rnd(uv.x * length(iDate)) < 0.4;\n        row = 2./ iResolution.y;\n        nextDir = 0.;\n    }\n    \n    // store value, direction and row in each pixel\n    fragColor = vec4(filled? 1.: prev[4] - 1. / iResolution.y, nextDir, row, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}