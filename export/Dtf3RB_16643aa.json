{"ver":"0.1","info":{"id":"Dtf3RB","date":"1671899965","viewed":75,"name":"Shader ray marching","username":"lucasHelio","description":"Trabalho final de computação gráfica","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["christmasshadderraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100\n\n\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n#define MAX_OCTAVES 8\n\n#define MIN_DIST = 0.0\n#define MAX_DIST 100.0\nconst int MAX_MARCHING_STEPS = 255;\nconst float EPSILON = 0.0001;\n\nconst float fieldOfView = radians(45.0); \n\nfloat hash(vec3 p)  \n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec4 noised( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    \n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(i+vec3(0.0,0.0,0.0));\n    float b = hash(i+vec3(1.0,0.0,0.0));\n    float c = hash(i+vec3(0.0,1.0,0.0));\n    float d = hash(i+vec3(1.0,1.0,0.0));\n    float e = hash(i+vec3(0.0,0.0,1.0));\n\tfloat f = hash(i+vec3(1.0,0.0,1.0));\n    float g = hash(i+vec3(0.0,1.0,1.0));\n    float h = hash(i+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n\nfloat noise3(vec3 p) {\n  vec4 v = noised(p);\n  return v.x; \n}\n\n\nfloat octaveNoise (vec3 p) {\n  float total = 0.;\n  float octaves = 1.0;\n  float frequency = 1.;\n  float amplitude = 1.;\n  float persistence = 0.5;\n  float lacunarity = 1.0;\n  float value = 0.;\n  \n\n  for (int i = 0; i < MAX_OCTAVES; ++i) {\n    if (float(i) >= octaves) break;\n    value += noise3(p * frequency) * amplitude;\n    total += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n  return value / total;\n}\n\nfloat getNoiseColor( vec3 p ) {\n    float offset = 0.;\n    float multiplier = 1.0;\n    float scale = 10.0;\n    float speed = 0.5;\n  return offset + multiplier * octaveNoise(vec3 (scale*p + speed*iTime));\n}\nvec3 noiseNormal(vec3 p) {\n  return normalize (vec3 (getNoiseColor(p+vec3(EPSILON,0.0,0.0))-getNoiseColor(p-vec3(EPSILON,0.0,0.0)),\n                          getNoiseColor(p+vec3(0.0,EPSILON,0.0))-getNoiseColor(p-vec3(0.0,EPSILON,0.0)),\n                          getNoiseColor(p+vec3(0.0,0.0,EPSILON))-getNoiseColor(p-vec3(0.0,0.0,EPSILON))));\n}\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat cubeSDF(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat largeSphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.2;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    return max(cubeSDF(samplePoint),-largeSphereSDF(samplePoint));\n}\n\nfloat shortestDistanceToSurface(vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    vec3 eye = 10.0*normalize(vec3(0.5-iMouse.xy/iResolution.xy,0.5)); // Position of the eye\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n      float dist = sceneSDF(eye + depth * marchingDirection);\n      if (dist < EPSILON) {\n        return depth;\n      }\n      depth += dist;\n      if (depth >= end) {\n        return end;\n      }\n    }\n    return end;\n  }\n\n  \n\n  vec3 normal(vec3 p) {\n    return normalize (vec3 (sceneSDF(p+vec3(EPSILON,0.0,0.0))-sceneSDF(p-vec3(EPSILON,0.0,0.0)),\n                            sceneSDF(p+vec3(0.0,EPSILON,0.0))-sceneSDF(p-vec3(0.0,EPSILON,0.0)),\n                            sceneSDF(p+vec3(0.0,0.0,EPSILON))-sceneSDF(p-vec3(0.0,0.0,EPSILON))));\n  }\n\n  vec3 phong (vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 N,\n    \n    vec3 lightPos, vec3 lightIntensity) {\nvec3 L = normalize(lightPos - p);\nvec3 eye = 10.0*normalize(vec3(0.5-iMouse.xy/iResolution.xy,0.5)); // Position of the eye\nvec3 V = normalize(eye - p);\nvec3 R = normalize(reflect(-L, N));\n\nfloat dotLN = dot(L, N);\nfloat dotRV = dot(R, V);\n\nif (dotLN < 0.0) {\n// Light not visible from this point on the surface\nreturn k_a * lightIntensity;\n} \n\nif (dotRV < 0.0) {\n// Light reflection in opposite direction as viewer, apply only diffuse\n// component\nreturn lightIntensity * (k_a + k_d * dotLN);\n}\nreturn lightIntensity * (k_a + k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// SDF of a torus at the origin given its two radius.\nfloat dTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    \n    return length(vec2(x, p.y)) - r.y;\n}\n\n// SDF of a box at the origin given its size (width, height and depth).\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\n// SDF of a sphere, given its center and radius.\nfloat dSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// SDF of a cylinder given a segment and a radius.\nfloat dCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\n// B + A\nfloat unionSDF (float sda, float sdb) {\n    return min(sda, sdb);\n}\n\n// B * A\nfloat intersectionSDF (float sda, float sdb) {\n    return max(sda, sdb);\n}\n\n// B - A\nfloat differenceSDF (float sda, float sdb) {\n    return max(-sda, sdb);\n}\n\n// Blend A and B\nfloat blendSDF(float sda, float sdb, float k) {\n    float h = clamp(0.5 + 0.5 * (sdb - sda) / k, 0.0, 1.0);\n    return mix(sdb, sda, h) - k * h * (1.0 - h);\n}\n\n// Scene SDF: signed distance function.\nfloat getDist(vec3 p) {\n    float planeDist = p.y;\n    \n    float s = sin(iTime);\n    float f = sin(iTime)/sin(iTime);\n    \n    vec3 bp = p - vec3(3, 0.75, 7);\n    //bp.xz *= Rot(iTime);\n    \n    vec3 tp = (p - vec3(0, 3, 6));\n    tp.y += s;\n    \n    vec3 bp2 = p - vec3(-3, 1.25, 6);\n    bp2.y -= f;\n    \n    float cx = -3.0;\n    cx -= s;\n    \n    vec3 a = vec3(0, 0.3, 3);\n    vec3 b = vec3(3, 0.3, 5);\n    vec3 c = vec3(0.5, 2, 5);\n    vec3 ab = normalize(b - a).zyx;\n    ab.x = -ab.x;\n    a -= s * ab;\n    b -= s * ab;\n    \n    \n    float td  = dTorus (tp, vec2(1.5, 0.3)); // donut\n    \n    \n\n    float bd2 = dBox(bp2, vec3(0.75)); //caixa com esfera dentro\n    float sd2 = dSphere(p+vec3(0,-1.75,0), vec4(-3, 0.5, 6, 1.0)); // esfera dentro do cubo\n\n    \n    \n    \n    float sd3 = dSphere(p+vec3(0,-2,0), vec4(0, 1, 6 , 1)); //esfera que se mexia em cima\n    float sd4 = dSphere(p+vec3(-2,0.5,2), vec4(-2, 3, 8, 1)); //esfera parada em cima\n    \n    \n\n    float d = min(planeDist, planeDist);\n\n    d = min(td, d); //\n    \n    \n    d = min(differenceSDF(sd2, bd2), d);\n    d = min(blendSDF(sd3, sd4, 0.2), d);\n    \n    return d;\n}\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 4.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary — should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)) - \n        vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l,n);\n    \n    // ambient component\n    float amb = 0.1;\n    // ambient reflection coefficient\n    float ka = 1.0;\n    \n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    // diffuse reflection coefficient\n    float kd = 0.8;\n    \n    // specular component\n    float shininess = 100.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n    \n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    float d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    // cast a ray to the light\n    if (d < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.3;\n        spec *= 0.5;\n    }\n    \n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera position\n    vec3 ro = vec3(0, 2, 0);\n    \n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Rotate camera down about the x-axis\n    //rd.yz *= Rot(PI * 10. / 180.); \n    \n    float d = rayMarch(ro, rd);\n    \n    // point hit by the ray\n    vec3 p = ro + rd * d;\n    \n    // illumination at point p\n    float light_intensity = getLight(p, ro);\n    \n    // dark grey\n    // vec3 background_color = vec3(.2, .2, .2);\n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb;\n    \n    \n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(250, 235, 215) / 155.;\n    \n    // pixel color\n    vec3 color;\n    \n\n   // mat4 view = lookAt(ro,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0)); //ro?\n  //vec3 dir = (view*(vec4(rayDirection(gl_FragCoord.xy),1.0))).xyz; //p?\n  //float dist = shortestDistanceToSurface(p, MIN_DIST, MAX_DIST);\n  //if (shortestDistanceToSurface(p, MIN_DIST, MAX_DIST) > MAX_DIST - EPSILON) {\n    fragColor = vec4( 0.0, 0.8, 0.8, 1.0); // light gray\n  //}\n  //else {\n    \n\n    float color2 = getNoiseColor(p);\n\n    vec3 N = normal(p);\n    //float color = 1.0;\n    const float bumpmapNoise =1.0;\n    \n    if( bumpmapNoise == 1.0 ) {\n      vec3 noise_normal = noiseNormal( p );\n      if ( dot( N, noise_normal ) < 0.0 ) noise_normal = reflect( noise_normal, N);\n      N = normalize( N + noise_normal );\n    }\n    \n    fragColor = vec4(phong (vec3 (0.3), // ambient                                \n    vec3 (0.8) * color2, // diffuse                                \n    vec3 (0.7) * color2, // specular                                \n    50.0, // shininess                                \n    p, // point                                \n    N, // normal at point                                \n    vec3(5.0,5.0,10.0), // light position                                \n    vec3(1.0,1.0,1.0)), // light color/intensity                         \n    1.0);\n\n\n    if (d < MAX_DIST) \n        // modulate surface color by the light intensity\n        color = surface_color * vec3(light_intensity);\n    else \n        color = background_color;\n\n    // output to screen\n    //fragColor = vec4(color,9.0);\n    fragColor = vec4(phong (vec3 (0.2), // ambient                                \n    vec3 (2.0) * color, // diffuse                                \n    vec3 (2.7) * color2, // specular                                \n    50.0, // shininess                                \n    p, // point                                \n    N, // normal at point                                \n    vec3(5.0,50.0,50.0), // light position                                \n    vec3(1.0,1.0,1.0)), // light color/intensity                         \n    9.0);\n}","name":"Image","description":"","type":"image"}]}