{"ver":"0.1","info":{"id":"DdfXWM","date":"1668984654","viewed":90,"name":"RM Metaballs","username":"carl_vbn","description":"Metaballs using ray marching and smooth minima for blending","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nSphere spheres[3];\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat getDist(vec3 p) {\n    return smin(smin(length(p-spheres[0].position)-spheres[0].radius, length(p-spheres[1].position)-spheres[1].radius, 1.0), length(p-spheres[2].position)-spheres[2].radius, 1.0);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d0 = getDist(p);\n    const vec2 epsilon = vec2(.0001,0);\n    vec3 d1 = vec3(\n        getDist(p-epsilon.xyy),\n        getDist(p-epsilon.yxy),\n        getDist(p-epsilon.yyx));\n    return normalize(d0 - d1);\n}\n\nvec3 getCol(vec3 p) {\n    float distSum = 0.0;\n    float dists[3];\n    for (int i = 0; i<3; i++) {\n        float d = max(0.0, length(p-spheres[i].position)-spheres[i].radius);\n        dists[i] = d;\n        distSum += d;\n    }\n    \n    float weights[3];\n    for (int i = 0; i<3; i++) weights[i] = 1.0 - dists[i]/distSum;\n    \n    return spheres[0].color * weights[0] + spheres[1].color * weights[1] + spheres[2].color * weights[2];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0] = Sphere(vec3(sin(iTime),-1, 0), 1.0, vec3(1.0, 0.0, 0.0));\n    spheres[1] = Sphere(vec3(1,sin(0.5*iTime), 0), 1.0, vec3(0.0, 1.0, 0.0));\n    spheres[2] = Sphere(vec3(cos(iTime)*2.0, sin(iTime)*2.0, 0), 1.0, vec3(0.0, 0.0, 1.0));\n\n    vec2 uv = (fragCoord/iResolution.xy-vec2(0.5))*vec2(iResolution.x/iResolution.y, 1.0);\n\n\n    vec3 rayDir = normalize(vec3(uv, 1));\n    vec3 lightDir = normalize(vec3(1, -0.5, 1));\n\n    vec3 p = vec3(cos(iTime)*2.0,sin(0.2*iTime)*2.0,-10.0);\n    vec3 col = vec3(0);\n    \n    int steps = 0;\n    \n    while (steps < 100) {\n        float d = getDist(p);\n        p = p+rayDir*d;\n        if (d<0.0001) {\n            col = getCol(p) * (vec3(0.3)+dot(getNormal(p), -lightDir));\n            break;\n        }\n        steps++;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}