{"ver":"0.1","info":{"id":"XsKcW3","date":"1523554148","viewed":291,"name":"Simple debanding","username":"DarkZeros","description":"Add 1/2 pixel normal noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["debanding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nvec3 nrand3( vec2 n )\n{\n  return vec3(nrand(n),nrand(n+vec2(0.15f)),nrand(n+vec2(0.3f)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 its = vec3(uv.y * uv.y/16.0f+5.0/64.0f); //Reduce space to produce banding\n\tfloat nrnd = (nrand( uv )-0.5f)/256.0f; //normalised noise of 1 pixel 1/256 power, mean 0\n    vec3 nrnd3 = (nrand3( uv )-vec3(0.5f))/256.0f; //normalised noise of 1 pixel 1/256 power, mean 0\n\n\t//display values\n\tvec4 outcol= vec4(0);\n\tif ( uv.x < 1.0/4.0 )\n\t\toutcol.rgb = its;\n\telse if( uv.x < 2.0/4.0)\n        //Best\n\t\toutcol.rgb = its+nrnd; //RGB are the same gaussian noise\n    else if ( uv.x < 3.0 / 4.0 )\n        //Does not solve the issue, noise has to be uniform\n\t\toutcol.rgb = its+(nrnd > 0.0f ? vec3(0.5f/256.0f) : vec3(-0.5f/256.0f)); //RGB are the same uniform noise\n\telse if ( uv.x < 4.0 / 4.0 )\n        //Ok, but not needed, and more complex\n\t\toutcol.rgb = its+nrnd3; //RGB are independent\n\t\t\n\t//display lines\n\tif ( abs(uv.x - 1.0/2.0) < 0.001 ) outcol = vec4(1);\n    if ( abs(uv.x - 1.0/4.0) < 0.001 ) outcol = vec4(1);\n\tif ( abs(uv.x - 2.0/4.0) < 0.001 ) outcol = vec4(1);\n\tif ( abs(uv.x - 3.0/4.0) < 0.001 ) outcol = vec4(1);\n        \n    fragColor = outcol;\n}\n","name":"Image","description":"","type":"image"}]}