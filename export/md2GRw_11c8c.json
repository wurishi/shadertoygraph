{"ver":"0.1","info":{"id":"md2GRw","date":"1667646201","viewed":161,"name":"Sliced world","username":"Alpaga","description":"Change view with the mouse","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","slices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0,uv).rgb;\n/*\n    for(float i=0.; i<30.; i++) {\n        vec2 p = mix(uv, vec2(.5), i/30.);\n        vec3 tex = texture(iChannel0,p).rgb;\n        color += dot(tex,vec3(1)) > .5 ? .01*tex : vec3(0);\n    }\n    */\n    // Vignette\n    // Taken from https://www.shadertoy.com/view/XsGyDh\n    color = mix(color, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)));\n    \n    // Gamma\n    color = pow(color,vec3(.44));\n    \n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SLICES\n#define HOLLOW\n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.2;\nvec3 cam, forward;\n\nvec3 fogColor(vec3 dir) {\n    return 1.5*mix(vec3(1,.3,.6),vec3(.3,.6,1),2.*dir+1.);\n}\nfloat gyroid(vec3 p) {\n    return dot(sin(p),cos(p.yzx));\n}\nfloat fbm(vec3 p) {\n    float h = 0.;\n    float f = 1.;\n    float a = 1.;\n    for(int i=0; i<3; i++) {\n        h += a*gyroid(a*p);\n        f *= 2.;\n        a *= .5;\n    }\n    return h;\n}\nfloat sdShape(vec3 p) {\n    #ifdef HOLLOW\n    return abs(.3+.2*fbm(3.*p));\n    #else\n    return .3+.2*fbm(3.*p);\n    #endif\n}\n\n// Cuts the scene into slices of given thickness and space between them\nfloat sdSlices(vec3 p, float space, float thickness) {\n \tfloat c = space*(floor(p.x/space)+.5);\n    float d = 1e6;\n    for(float i=-1.; i<=1.; i++) {\n        d = min(d, length(max(vec2(\n            sdShape(vec3(c+i*space,p.y,p.z)),\n            abs(p.x-(c+i*space))-.5*thickness),0.)));\n    }\n    return d;\n}\n\nfloat sd(vec3 p) {\n    #ifdef SLICES\n    float d = sdSlices(p,.06,.021);\n    #else\n    float d = sdShape(p);\n    #endif\n    float n = .01*texture(iChannel0,p.yz+.1*iTime).r;\n    return d - n;\n}\n\nconst vec2 delta = vec2(0.0,0.001);\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p);\n    return normalize(vec3(\n        sd(p+delta.yxx),\n        sd(p+delta.xyx),\n        sd(p+delta.xxy)) - d);\n}\n\n\n// Returns (distance, object id)\nfloat march(vec3 start, vec3 dir, out int id, out int steps) {\n\tfloat total = 0.0, d;\n    vec3 p;\n    float epsilon = 0.5/iResolution.y;\n    steps = 0;\n    id = 0;\n    for(; steps<200; steps++) {\n        p = start + total * dir;\n        d = sd(p);\n        if(d<epsilon || total>30.) break;\n        total += d;\n    }\n    if(total>30. || steps==200) id = -1;\n    return total;\n}\n\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 color;\n    vec3 coef = vec3(1);\n    \n    int id;\n    int steps;\n    float d;\n\n    d = march(start, dir, id, steps);\n    if(id == -1) {//No ray intersection\n        return fogColor(dir);\n    } else {\n        vec3 p = start + d * dir;\n\n        // Color\n        color = .6+.4*cos(.3*vec3(4,5,6)*p.x);\n        \n        // AO\n        vec3 normal = normal(p);\n        float nx = clamp(abs(normal.x),0.,1.);\n        color = mix(color, color/(1.+.01*float(steps*steps)),nx);\n        \n        // Fog\n        color = mix(fogColor(dir),color,1./(.01*d*d+1.));//exp(-.012*d*d));\n        \n        return color;\n    }\n}\n\nmat3 viewMatrix(vec3 forward, vec3 up) {\n \tvec3 w = -normalize(forward);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    forward = normalize(vec3(-1,-.5,.0));\n    cam = vec3(0,1.57,.1)+1.*forward*iTime;\n    \n    mat3 m = viewMatrix(forward, vec3(0,1,0));\n    \n    vec3 f = m*vec3(sin(.2*iTime),0,cos(.2*iTime));//)vec3(.9*sin(iTime),0,-1);\n    if(iMouse.z>0.) {\n        f = m*vec3((2.*iMouse.x/iResolution.x)-1.,(2.*iMouse.y/iResolution.y)-1.,-1);\n    }\n    m = viewMatrix(f, vec3(0,1,0));\n    \n    vec2 uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1);\n    vec3 dir = normalize(m*pix);\n\n    vec3 color = rayColor(cam, dir);\n\n    if(iFrame > 0) {\n        vec3 old = texelFetch(iChannel1,ivec2(fragCoord),0).rgb;\n        color = mix(old,color,.7);\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}