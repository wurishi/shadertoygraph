{"ver":"0.1","info":{"id":"MllSWS","date":"1439467781","viewed":261,"name":"toruslighttest publicinti","username":"public_int_i","description":"A torus in BeyondTheStatics light shape scene","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["toruslighttest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\nShapeLight\n2015 BeyondTheStatic\n\nRaymarching demo showing how to produce low cost, shape-based lighting.\n\nThis scheme is definitely not a physical model, and to get smooth results great care\nmust be taken when designing L()... but maybe some of you will expand on the idea.\n\nMy apologies if this has been done before!\n\n\n\n*/\n\nconst int\tMaxRaySteps\t= 64;\t\t// maximum # of ray steps\nconst float\tMaxDist\t\t= 15.0;\t\t// maximum distance a ray travels before giving up\nconst float\tFudgeFactor\t= 1.0;\t\t// lower this if artifacts appear\nconst float\tAccuracy\t= 0.005;\t// minimum ray step\nconst float\tNormAcc\t\t= 0.005;\t// surface normal accuracy\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// object struct; contains a distance estimate and a type flag (light or not)\nstruct object {\n    float form;\n    bool isALight;\n};\n    \n    float sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// light shape\nobject L(in vec3 p)\n{\n   /* mat3 rot = rotationMatrix(vec3(0., 1., 0.), iTime);\n    if(iMouse.z>0.)\n    {\n        p.xz -= 10.*(iMouse.xy/iResolution.xy-.5);\n    }\n    else\n    {\n    \tp.z -= 2.;\n    \tp *= rot;\n    \tp.yz -= vec2(.25, 2.);\n        p *= rot;\n    }\n    p.xz = max(vec2(0.), abs(p.zx)-vec2(.25, 3.));\n    \n*/\n    return object(sdTorus(p-vec3( 10.*(iMouse.xy/iResolution.xy-.5), -.6).xzy,vec2(4,.2)), true);\n}\n\n// non-light shape\nobject DE(in vec3 p)\n{\n\tfloat f;\n    f = 1.;\n    p.xz = fract(p.xz) - .5;\n    p.y += 1.;\n    f = length(p-vec3(0., .225, 0.)) - .1;\n    f = min(f, length(max(vec3(0.), abs(p)-.075))-.05);\n    f = min(f, p.y+.125);\n    return object(f, false);\n}\n\n// L() & DE() functions, merged\nobject LDE(in vec3 p){\n\tobject A = L(p), B = DE(p);\n    return object(min(A.form, B.form), (A.form<B.form ? A.isALight : B.isALight));\n}\n\n// retrieve normal from DE() function\nvec3 getNorm(vec3 p)\n{\n\treturn\n\t\tnormalize(\n\t\t\tvec3(\n\t\t\t\tDE(p+vec3(NormAcc, 0., 0.)).form - DE(p+vec3(-NormAcc, 0., 0.)).form,\n\t\t\t\tDE(p+vec3(0., NormAcc, 0.)).form - DE(p+vec3(0., -NormAcc, 0.)).form,\n\t\t\t\tDE(p+vec3(0., 0., NormAcc)).form - DE(p+vec3(0., 0., -NormAcc)).form\n\t\t\t)\n\t\t);\n}\n\n// retrieve normal from L() function\nvec3 getNormL(vec3 p)\n{\n\tfloat lna = L(p).form;\n    //float lna = NormAcc;\n    return\n\t\tnormalize(\n\t\t\tvec3(\n\t\t\t\tL(p+vec3(lna, 0., 0.)).form - L(p+vec3(-lna, 0., 0.)).form,\n\t\t\t\tL(p+vec3(0., lna, 0.)).form - L(p+vec3(0., -lna, 0.)).form,\n\t\t\t\tL(p+vec3(0., 0., lna)).form - L(p+vec3(0., 0., -lna)).form\n\t\t\t)\n\t\t);\n}\n\n// known by most as ambient occlusion, but I'm pretty sure it's a proximity pattern :)\nfloat getProx(vec3 p, float dist)\n{\n\treturn\n    \t(\n            DE(p+vec3(dist, 0., 0.)).form + DE(p+vec3(-dist, 0., 0.)).form +\n\t\t\tDE(p+vec3(0., dist, 0.)).form + DE(p+vec3(0., -dist, 0.)).form +\n\t\t\tDE(p+vec3(0., 0., dist)).form + DE(p+vec3(0., 0., -dist)).form  \n\t\t)/dist;\n}\n\n// Shadow function, modified from Fragmentarium examples to handle nearby light sources.\n// - thanks to iq for the soft shadows!\nfloat getShadow(vec3 hit, vec3 lightDir, float lightDist)\n{\n\tfloat dist;\n\tfloat k = 16.; // shadow hardness\n\tfloat totalDist = 1. / k; // starting distance based on shadow hardness\n\tfloat res = 1.;\n\tfor(int steps=0; steps<MaxRaySteps; steps++)\n\t{\n\t\tvec3 P = hit + totalDist * lightDir;\n\t\tdist = DE(P).form;\n\t\tif(dist < Accuracy) return 0.;\n        if(totalDist >= min(MaxDist, lightDist)) break;\n\t\tres = min(res, k*dist/float(steps));\n\t\ttotalDist += dist;\n\t}\n\treturn res;\n}\n\n// get last and total distances from a ray traced from camPos to rayDir\nvec2 intersect(vec3 camPos, vec3 rayDir)\n{\n\tfloat dist;\n\tfloat totalDist = 0.;\n\tvec3 p;\n\tfor(int steps=0; steps<MaxRaySteps; steps++)\n\t{\t\n\t\tp = camPos + totalDist * rayDir;\n\t\tdist = LDE(p).form * FudgeFactor;\n\t\ttotalDist += dist;\n\t\tif(dist<Accuracy || totalDist>MaxDist) break;\n\t}\n    return vec2(dist, totalDist);\n}\n\n// get shading\nvec3 getColor(vec3 hit, vec3 rayDir, vec2 dists)\n{\n    vec3 lightCol\t= 2. * vec3(2., 1., .5);\n    vec3 fogCol\t\t= .75 * vec3(1., 1.25, 1.5);\n    float fogDist\t= 40.;\n    vec3 visible;\n\tif(dists.x < Accuracy) // a surface was hit, do some shading\n\t{\n\t\t// test object to see if it's a light or not\n        if(LDE(hit).isALight) // surface is a light\n        {\n            visible = lightCol;\n        }\n        else // surface is not a light\n        {\n            // surface normal\n            vec3 norm = getNorm(hit);\n\n            // light direction and position\n            vec3 lightDir = -getNormL(hit);\n            vec3 lightPos = hit + L(hit).form * lightDir;\n            \n            float shadow = getShadow(hit, lightDir, distance(hit, lightPos));\n            float brilliance = .5;\n            float diffuse = .75 * pow(max(0.0, dot(norm, lightDir)), brilliance);\n\t\t\t\n            float lightFade = 0.;\n\n            // apply distance fading for light\n            if(true)\n            {\n                float fadeDistance = 4.;\n                lightFade =\n                    1./(\n                        1. +\n                        pow(\n                            distance(hit, lightPos) / fadeDistance,\n                            2. // fade_power\n                        )\n                    );\n                diffuse *= lightFade;\n            }\n            \n            // apply lighting\n            visible = lightCol * vec3(diffuse);\n            \n            // apply specular highlight\n            if(true)\n\t\t\t{\n\t\t\t\tvec3 ref = reflect(lightDir, norm);\n\t\t\t\tfloat spec = max(0., dot(rayDir, ref));\n\t\t\t\tfloat rough = .1;\n                visible +=\n\t\t\t\t\tlightCol *\n                    (lightFade>0. ? lightFade : 1.) *\n\t\t\t\t\tmax(0., pow(spec, max(0., 1./rough)));\n\t\t\t}\n            \n            // apply shadows\n            visible *= shadow;\n            \n            // apply prox\n            visible += .025 * fogCol *vec3(getProx(hit, .035));\n            \n            // apply fog\n            visible = mix(fogCol, visible, exp(-dists.y/fogDist));\n        }\n\t\t\n\t}\n\telse // no surface hit, return bg color\n\t{\n\t\tvisible = fogCol;\n\t}\n\t\n\treturn visible;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / iResolution.y;\n    \n    mat3 camRotate\t= rotationMatrix(vec3(1., 0., 0.), radians(40.));\n\tvec3 camPos\t\t= vec3(0., 0., -2.);\n    vec3 rayDir\t\t= normalize(vec3(uv, 1.));\n    camPos *= camRotate;\n    rayDir *= camRotate;\n    \n    vec2 dists\t= intersect(camPos, rayDir);\n    vec3 hit\t= camPos + dists.y * rayDir;\n    vec3 RGB\t= getColor(hit, rayDir, dists);\n    \n    fragColor = vec4(RGB, 1.);\n}","name":"","description":"","type":"image"}]}