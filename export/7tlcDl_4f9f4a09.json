{"ver":"0.1","info":{"id":"7tlcDl","date":"1648951227","viewed":113,"name":"rustdrops","username":"LoganOracio","description":"rusty droplets","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["rust"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////// BORROWED FROM \"JAYBIRD\" /////////////////\n// taken from Simple Water Caustic Pattern : https://www.shadertoy.com/view/3d3yRj\n// 3D simplex noise adapted from https://www.shadertoy.com/view/Ws23RD \nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, vec3(C.y)));\n    vec3 x0 = v   - i + dot(i, vec3(C.x));\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.x;\n    vec3 x2 = x0 - i2 + C.y;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Compute noise and gradient at P\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * dot(m4, px);\n}\n///////////////// END OF BORROWED CODE /////////////////\nvec3 s3(vec3 co)\n{\n    return vec3(snoise(co),snoise(co+vec3(213.151,12.486,95.15)),snoise(co+vec3(35.16,45.1332,86.123)));\n}\n\nfloat cell(vec3 co)\n{\n    float m_dist = 1.8;\n    \n    vec3 fr = fract(co);\n    vec3 fl = floor(co);\n    \n    \n    for (int x = 0; x < 2; x++)\n    {\n        for (int y = 0; y < 2; y++)\n        {\n            for (int z = 0; z < 2; z++)\n            {\n                vec3 cell = fl + vec3(x,y,z);\n                float d = length(cell + (s3(cell)*.6) - co);\n                m_dist = m_dist > d ? d : m_dist;\n            }\n        }\n    }\n    \n    return m_dist;\n}\nfloat cloud(vec3 v, int oct)\n{\n    float outp = 0.0;\n    for (int i = 1; i < 64; i++)\n    {\n        if(i >= oct+1) {break;}\n        outp += snoise(vec3(-143*i,842*i,0)+v*pow(float(i),1.7))*(1.0/pow(float(i),1.3));\n    }\n    return outp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_l = 1.0/iResolution.xy;\n    vec2 uv = pix_l*gl_FragCoord.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 gold = vec3(0.968, 0.741, 0.290)*(1.0+.1*cloud(vec3(uv*5.0,iTime*0.8),4));\n    vec3 rust = vec3(0.313, 0.207, 0.149)*(1.0+.1*cloud(vec3(uv*3.5,iTime*0.2),4));\n    \n    float d = texture(iChannel0,gl_FragCoord.xy/iResolution.xy).x;\n    \n    float r = texture(iChannel0,pix_l*vec2(1.0,0.0)+gl_FragCoord.xy/iResolution.xy).x;\n    float l = texture(iChannel0,pix_l*vec2(-1.0,0.0)+gl_FragCoord.xy/iResolution.xy).x;\n    float t = texture(iChannel0,pix_l*vec2(0.0,1.0)+gl_FragCoord.xy/iResolution.xy).x;\n    float b = texture(iChannel0,pix_l*vec2(0.0,-1.0)+gl_FragCoord.xy/iResolution.xy).x;\n    r = smoothstep(.5,1.0,sin((r-iTime*.2)*60.0))/pow(r+1.3,10.0);\n    l = smoothstep(.5,1.0,sin((l-iTime*.2)*60.0))/pow(l+1.3,10.0);\n    t = smoothstep(.5,1.0,sin((t-iTime*.2)*60.0))/pow(t+1.3,10.0);\n    b = smoothstep(.5,1.0,sin((b-iTime*.2)*60.0))/pow(b+1.3,10.0);\n    \n    \n    vec2 gradient = vec2(r-l,t-b);\n    \n    vec2 light_pos = vec2(4.0);\n    \n    float light = clamp(dot(gradient,uv-light_pos),0.0,1.0);\n    \n    d = smoothstep(.8,1.0,sin((d-iTime*.2)*60.0))/pow(d+0.9,10.0);\n    vec3 col = mix(rust,gold,d);\n    \n    fragColor = vec4(col*(light*20.0*vec3(0.654, 0.862, 0.831))+col*.4*vec3(0.725, 0.427, 0.215),1.0);\n    //fragColor = vec4(light);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///////////////// BORROWED FROM \"JAYBIRD\" /////////////////\n// taken from Simple Water Caustic Pattern : https://www.shadertoy.com/view/3d3yRj\n// 3D simplex noise adapted from https://www.shadertoy.com/view/Ws23RD \nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, vec3(C.y)));\n    vec3 x0 = v   - i + dot(i, vec3(C.x));\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.x;\n    vec3 x2 = x0 - i2 + C.y;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Compute noise and gradient at P\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * dot(m4, px);\n}\n///////////////// END OF BORROWED CODE /////////////////\nvec3 s3(vec3 co)\n{\n    return vec3(snoise(co),snoise(co+vec3(213.151,12.486,95.15)),snoise(co+vec3(35.16,45.1332,86.123)));\n}\n\nfloat cell(vec3 co)\n{\n    float m_dist = 1.8;\n    \n    vec3 fr = fract(co);\n    vec3 fl = floor(co);\n    \n    \n    for (int x = 0; x < 2; x++)\n    {\n        for (int y = 0; y < 2; y++)\n        {\n            for (int z = 0; z < 2; z++)\n            {\n                vec3 cell = fl + vec3(x,y,z);\n                float d = length(cell + (s3(cell)*.6) - co);\n                m_dist = m_dist > d ? d : m_dist;\n            }\n        }\n    }\n    \n    return m_dist;\n}\nfloat cloud(vec3 v, int oct)\n{\n    float outp = 0.0;\n    for (int i = 1; i < 64; i++)\n    {\n        if(i >= oct+1) {break;}\n        outp += snoise(vec3(-143*i,842*i,0)+v*pow(float(i),1.7))*(1.0/pow(float(i),1.3));\n    }\n    return outp;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_l = 1.0/iResolution.xy;\n    vec2 uv = pix_l*gl_FragCoord.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 coo = vec3(uv*1.6,iTime*.06);\n    coo += s3(coo*2.0)*.08+s3(coo*42.0)*.002;\n    float d = cell(coo);\n    \n    \n    \n    fragColor = vec4(vec3(d),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}