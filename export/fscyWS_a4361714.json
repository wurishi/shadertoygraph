{"ver":"0.1","info":{"id":"fscyWS","date":"1654429897","viewed":97,"name":"Lifelike Cellular Automata","username":"AlephNull","description":"Configurable Lifelike Cellular Automata simulation with a generations parameter.\n\nParameters can be found at the top of the Common tab, change them and recompile to try different things.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","cellularautomata","lifelike"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" /*\nCopyright (c) 2022 AlephNull\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - vec2((iResolution.x - iResolution.y) / 2.0, 0.0)) / iResolution.yy;\n    ivec2 cellPos = ivec2(uv * float(CELL_COUNT));\n    \n    if (uv.x < 0.0 || uv.x > 1.0) {\n        float t = clamp((uv.x > 1.0 ? uv.x - 1.0 : -uv.x) * 5.0, 0.0, 1.0);\n        fragColor = vec4(vec3(mix(0.1, 0.6, t)), 1.0);\n    } else {\n        int cell = fetchCell(cellPos);\n        if (cell == 0) {\n            fragColor = vec4(vec3(0.0), 1.0);\n        } else if (cell == 1) {\n            fragColor = vec4(1.0);\n        } else {\n// Gradient\n#if   (RENDER_TYPE == 0)\n            fragColor = vec4(mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), float(cell) / float(GENERATIONS)), 1.0);\n// Live & Cooldown\n#elif (RENDER_TYPE == 1)\n            fragColor = vec4(vec3(0.3), 1.0);\n// Live Only\n#elif (RENDER_TYPE == 2)\n            fragColor = vec4(vec3(0.0), 1.0);\n// None\n#else\n            fragColor = vec4(vec3(0.0), 1.0);\n#endif\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":" /*\nCopyright (c) 2022 AlephNull\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 cellPos = ivec2(fragCoord);\n    if (iFrame <= START_DELAY) { // Initialize\n// Random\n#if   (START_CONDITION == 0)\n                fragColor = vec4(hash12(fragCoord) < 0.5 ? 1.0 : 0.0, vec3(0.0));\n// Single\n#elif (START_CONDITION == 1)\n                fragColor = vec4(cellPos == ivec2(CELL_COUNT) / 2, vec3(0.0));\n// Cross\n#elif (START_CONDITION == 2)\n                fragColor = vec4(cellPos.x == CELL_COUNT / 2 || cellPos.y == CELL_COUNT / 2, vec3(0.0));\n// V-Line\n#elif (START_CONDITION == 3)\n                fragColor = vec4(cellPos.x == CELL_COUNT / 2, vec3(0.0));\n// H-Line\n#elif (START_CONDITION == 4)\n                fragColor = vec4(cellPos.y == CELL_COUNT / 2, vec3(0.0));\n// None\n#else\n                fragColor = vec4(0.0);\n#endif\n    } else if (iFrame % SPEED == 0) { // Update the current cell based on CA rules\n        if (validCell(cellPos)) {\n            int cell = fetchCell(cellPos);\n            if (cell <= 1) { // Not on cooldown\n                int neighbours =\n                    (fetchCell(cellPos + ivec2(-1, -1)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2(-1,  0)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2(-1,  1)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2( 0, -1)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2( 0,  1)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2( 1, -1)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2( 1,  0)) == 1 ? 1 : 0) +\n                    (fetchCell(cellPos + ivec2( 1,  1)) == 1 ? 1 : 0);\n\n                float cellValue;\n                if (cell == 0) { // Cell is dead\n                    if (birthRules[neighbours]) {\n                        cellValue = 1.0;\n                    } else {\n                        cellValue = 0.0;\n                    }\n                } else { // Cell is alive\n                    if (survivalRules[neighbours]) {\n                        cellValue = 1.0;\n                    } else {\n#if (GENERATIONS > 2)\n                        cellValue = 2.0;\n#else\n                        cellValue = 0.0;\n#endif\n                    }\n                }\n                fragColor = vec4(cellValue, vec3(0.0));\n            } else if (cell >= GENERATIONS - 1) { // End of cooldown\n                fragColor = vec4(0.0);\n            } else { // On cooldown\n                fragColor = vec4(cell + 1, vec3(0.0));\n            }\n        }\n    } else { // Don't change the cell\n        fragColor = vec4(fetchCell(cellPos) == 1 ? 1.0 : 0.0, vec3(0.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":" /*\nCopyright (c) 2022 AlephNull\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ \n\n// --- Parameters ---\n\n// Shouldn't be set larger than the image height\n#define CELL_COUNT int(iResolution.y)\n//#define CELL_COUNT 100\n// Speed at which to iterate (1 is fastest)\n#define SPEED 1\n\n// Number of frames to delay before first iteration\n// Use this if you want to view at max resolution in fullscreen\n#define START_DELAY 0\n\n// Method for rendering cells on cooldown (GENERATIONS should be greater than 2)\n// 0 - Render cooldown cells based on remaining cooldown duration\n// 1 - Render cooldown cells as a constant gray\n// 2 - Render cooldown cells as dead cells\n#define RENDER_TYPE 0\n\n// Method for determining the initial layout of cells\n// 0 - Random (all cells have 50% chance of being live)\n// 1 - Single live cell in the center\n// 2 - Centered vertical and horizontal lines\n// 3 - Centered vertical line\n// 4 - Centered horizontal line\n#define START_CONDITION 1\n\n// --- Lifelike CA rules ---\n\n// Birth rules: For each index (i), a dead cell with i\n//              neighbours will become alive\n// Array should always contain 9 values\nconst bool birthRules[]    = bool[9](false, true, false, true, false, false, false, false, false);\n// Survival rules: For each index (i), a live cell with i\n//                 neighbours will stay alive\n// Array should always contain 9 values\nconst bool survivalRules[] = bool[9](false, true, true, false, true, true, false, false, false);\n// Complex CA rule, cooldown (in iterations) before a new dead cell\n// can become alive again\n// Minimum 2\n#define GENERATIONS 100\n\n// --- Other rule-sets to try ---\n\n/// Conway's Game of Life\n//const bool birthRules[]    = bool[9](false, false, false, true, false, false, false, false, false);\n//const bool survivalRules[] = bool[9](false, false, true, true, false, false, false, false, false);\n//#define GENERATIONS 3\n\n/// Star Wars\n//const bool birthRules[]    = bool[9](false, false, true, false, false, false, false, false, false);\n//const bool survivalRules[] = bool[9](false, false, false, true, true, true, false, false, false);\n//#define GENERATIONS 4\n\n/// Some wacky nonsense I don't know if this has a name\n//const bool birthRules[]    = bool[9](false, true, false, false, false, false, false, false, false);\n//const bool survivalRules[] = bool[9](false, false, false, true, true, true, false, false, false);\n//#define GENERATIONS 100\n\n/// Some more wacky nonsense. Try with different starting conditions\n//const bool birthRules[]    = bool[9](false, true, true, true, true, true, false, false, false);\n//const bool survivalRules[] = bool[9](false, false, false, false, true, true, false, false, false);\n//#define GENERATIONS 200\n\n// --- Global Macros ---\n\n#define wrapPos(pos) ivec2(mod(float(pos.x), float(CELL_COUNT)), mod(float(pos.y), float(CELL_COUNT)))\n#define fetchCell(addr) int(texelFetch(iChannel0, (wrapPos((addr))), 0).x)\n#define validCell(pos) pos.x < CELL_COUNT && pos.y < CELL_COUNT\n\n// --- Global Functions ---\n\n// Source: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"}]}