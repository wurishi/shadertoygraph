{"ver":"0.1","info":{"id":"MdjcDh","date":"1491958510","viewed":253,"name":"Bottle","username":"mmerchante","description":"Raymarched bottle with fake rough specular (not even microfacet :P) for fun!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","specular","bottle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR_CLIP 100.0\n#define MAX_ITERATIONS 64\n#define EPSILON .005\n#define NORMAL_ESTIMATION_EPSILON .0175\n#define SPECULAR_SAMPLES 35\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 hash3(vec3 p)\n{\n \treturn vec3(hash(p.xyz), hash(p * p), hash(sqrt(abs(p))));   \n}\n\n// Reference: https://github.com/stackgl/glsl-smooth-min\nfloat smin(float a, float b, float k) \n{\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat sdCappedCone( in vec3 p)\n{\n\tp.y -= .25;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2(0.5773502691896258, -0.95773502691896258);\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0) * qv / vv;\n    return sqrt(max(dot(w,w) - max(d.x,d.y), .000000001) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n// All SDFS from iq, https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat bottleBase(in vec3 p)\n{\n    vec3 bottleP = p;\n  \n    float r = 1.25 - pow(saturate(p.y * .34 - .0145), 2.5) * .9;\n    float d = sdCappedCylinder(bottleP, vec2(r, 3.0));\n    \n    d = smin(d, sdCappedCylinder(p - vec3(0.0, .5, 0.0), vec2(.5, 3.0)), 5.00);\n    \n    float angle = atan(p.z, p.x) * 12.;\n    d = smin(d, sdCappedCylinder(bottleP + vec3(0.0, 3.0, 0.0), vec2(mix(1.25, 1.25, saturate(p.y + 3.0)) + (sin(angle) * .025) * smoothstep(p.y, p.y + .1, -3.3), .5 * (1.0 + sin(angle) * .075))), 10.0);\n    \n    return d;\n}\n\nfloat bottleCap(in vec3 p)\n{\n    vec3 bottleP = p - vec3(0.0, 3.75, 0.0);\n\n    float r = saturate(.6 - pow(saturate(bottleP.y), 2.0) * 1.5);\n    \n    float angle = atan(p.z, p.x);\n    \n    r = mix(r, r * (1.0 + sin(angle* 12.0) * .15), saturate(bottleP.y + .1));\n    \n    float d = sdCappedCylinder(bottleP, vec2(r, .4)) * .9;\n    \n    return d;\n}\n\nfloat evaluateSceneSDFSimple(in vec3 p)\n{\n    float d = bottleBase(p);\n    d = min(d, bottleCap(p));\n\treturn d;\n}\n\nvoid evaluateSceneSDF(in vec3 p, out float d, out float hitMaterial)\n{\n    float bottle = bottleBase(p);\n    d = min(d, bottle);\n    hitMaterial = mix(hitMaterial, 0.0, step(abs(bottle - d), .001));    \n    \n    float cap = bottleCap(p);\n    d = min(d, cap);\n    hitMaterial = mix(hitMaterial, 1.0, step(abs(cap - d), .001));    \n}\n\nvec3 estimateSceneGradient(vec3 point, float epsilon)\n{\n    \n\tfloat x = evaluateSceneSDFSimple(vec3(point.x + epsilon, point.y, point.z));\n\tx -= evaluateSceneSDFSimple(vec3(point.x - epsilon, point.y, point.z));\n\n\tfloat y = evaluateSceneSDFSimple(vec3(point.x, point.y + epsilon, point.z));\n\ty -= evaluateSceneSDFSimple(vec3(point.x, point.y - epsilon, point.z));\n\n\tfloat z = evaluateSceneSDFSimple(vec3(point.x, point.y, point.z + epsilon));\n\tz -= evaluateSceneSDFSimple(vec3(point.x, point.y, point.z - epsilon));\n\n\treturn normalize(vec3(x,y,z));\n}\n\nvec3 shade(vec3 point, vec3 rayDir, float t, float material)\n{\n\tvec3 normal = estimateSceneGradient(point, NORMAL_ESTIMATION_EPSILON );\n\n    vec3 refl = reflect(-rayDir, normal);    \n    vec3 specular = vec3(0.0);//pow(texture(iChannel0, refl).rgb, vec3(3.0));\n    \n    vec3 p = hash3(refl);\n    \n    float angle = atan(point.z, point.x);\n    vec2 uv = vec2(angle * .5 + .5, point.y) * .5;//point.xz + point.yx;\n    float roughnessMap = pow(texture(iChannel1, uv).r, 4.0) *1.5;\n    \n    //vec2 uv = point.xz + point.yx;\n    //float roughnessMap = pow(texture(iChannel1, uv).r, 4.0);\n    \n    float roughness = mix(saturate(roughnessMap * 4.0), .25, material);\n  \n    float cosThetaO = saturate(dot(-normal, rayDir));\n    \n    for(int i = 0; i < SPECULAR_SAMPLES; i++)\n    {\n        p = hash3(p);\n        \n        // Fake fake fake\n        vec3 wh = normalize(refl + (p * roughness - vec3(roughness * .5)));\n        \n    \t// Inverse gamma for cubemap\n        specular += pow(texture(iChannel0, wh).rgb, vec3(2.2)) / (float(SPECULAR_SAMPLES));\n\t}\n    \n    specular *= mix(0.15, 1.0, material);\n    \n    float fresnel = pow(1.0 - cosThetaO, 3.5) * 10.915;\n    \n    return vec3(specular * (.95 + fresnel));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    \n    vec3 p = vec3(cos(iTime) * 7.0, 3.0 * (1.0 + iMouse.y / iResolution.y), sin(iTime)* 7.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n    \n    vec3 rayOrigin = p;\n    vec3 rayDirection = normalize( forward + left * uv.x - up * uv.y);\n    \n    vec3 color;\n    vec3 current = p;\n\n    float t = 0.0;\n\tfloat d = FAR_CLIP;\n    float iterationCount = 0.0;\n    float hitMaterial = 0.0;    \n    int hit = 0;\n   \n\tfor(int j = 0; j < MAX_ITERATIONS; j++)\n\t{\n\t\tevaluateSceneSDF(current, d, hitMaterial);\n\n\t\tif(d < EPSILON)\n        {\n            hit = 1;\n            break;            \n        }\n\n\t\tt += d;\n\t\tcurrent += rayDirection * d;\n\t\titerationCount += 1.0;\n\n\t\tif(t >= FAR_CLIP)\n\t\t\tbreak;\n\t}\n    \n    if(hit == 1)\n    {\n        color = shade(current, rayDirection, t, hitMaterial);\n    }\n    \n\t// Gamma correction\n\tcolor = pow(color, vec3(.45454));\n    \n    if(hit == 0)\n    {\n    \tcolor = texture(iChannel0, -rayDirection).rgb;   \n    }\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}