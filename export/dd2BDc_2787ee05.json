{"ver":"0.1","info":{"id":"dd2BDc","date":"1690682503","viewed":160,"name":"2D GI test 3","username":"krisp","description":"Added a second light bounce, switched to the simpler UE3 tonemapping, and just generally tweaked stuff.\ni probably did a bunch of the light transport rules wrong but hey it looks pretty and thats what counts :p","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","raytracing","gi","globalillumination","bidirectional","interleavedgradientnoise","ign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define samples 8\n#define sampleMult 4\n#define secondBounce true\n// Samples for the first light bounce\n\n// Second light bounce needs more samples to converge cleanly, I'm just using a multiplier here bc it makes more even distribution things easier\n// Default is 4 and 4 respectively. aka 16 samples for first bounce and 16 samples for second bounce\n\n#define pi 3.141592564\n\n// Scene definition is kinda inspired by .obj file formatting but idk if I'll keep it\n\nvec3 materials[] = vec3[](\nvec3(1.000,1.000,1.000),    // white\nvec3(1.000,0.067,0.157),    // red\nvec3(0.027,0.945,0.259),    // green\nvec3(0.118,0.253,0.992));   // blue\n\nvec2 points[] = vec2[](\nvec2(.1,-.25), \nvec2(.3,-.25), \nvec2(.1,-.05),\nvec2(.3,-.05), \nvec2(-.9,-.4), \nvec2(.8,-.4),  \nvec2(-.9,-1.), \nvec2(.8,1.),   \nvec2(-.4,-.3), \nvec2(-.2,-.3), \nvec2(-.4,-.1), \nvec2(-.2,-.1),\nvec2(-.05,-.05),\nvec2(-.05,-.15),\nvec2(0,-.1),\nvec2(-.1,-.1));\n\nint segmentCount = 15;\nivec3 segments[] = ivec3[](\nivec3(0,1,1),   // ivec3(a,b,c)\nivec3(0,2,1),   // a = endpoint a index\nivec3(1,3,1),   // b = endpoint b index\nivec3(2,3,1),   // c = material index\nivec3(4,5,0),\nivec3(4,6,0),\nivec3(5,7,0),\nivec3(8,9,3),\nivec3(8,10,3),\nivec3(9,11,3),\nivec3(10,11,3),\nivec3(12,14,2),\nivec3(14,13,2),\nivec3(13,15,2),\nivec3(15,12,2));\n\nfloat IGN(ivec2 p, int frame) {\n    frame = frame % 64; // need to periodically reset frame to avoid numerical issues\n    float x = float(p.x) + 5.588238 * float(frame);\n    float y = float(p.y) + 5.588238 * float(frame);\n    //return .5;\n    return mod(52.9829189 * mod(0.06711056*float(x) + 0.00583715*float(y), 1.0), 1.0);\n}\n\n// Ray intersection with line segment\nfloat segmentIntersect(vec2 ro, vec2 rd, vec2 a, vec2 b) {\n        vec2 v1 = ro - a;\n        vec2 v2 = b - a;\n        vec2 v3 = vec2(-rd.y, rd.x);\n\n        float d = dot(v2, v3);\n        float t1 = cross(vec3(v2,0), vec3(v1,0)).z / d;\n        float t2 = dot(v1, v3) / d;\n\n        if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0)) {\n            return t1;\n        }\n        return 1000.;\n}\n\n//ray intersection with scene\n//sceneIntersect.w is the distance, sceneIntersect.xyz is the color\nvec4 sceneIntersect(vec2 ro, vec2 rd) {\n    float v0 = 1000.;\n    vec3 col;\n\n    for(int i=0; i<segmentCount; i++) {\n\n        vec2 a = points[segments[i].x];\n        vec2 b = points[segments[i].y];\n        \n        float v1 = segmentIntersect(ro, rd, a, b);\n        if(v1<v0) {\n            col = materials[segments[i].z];\n            v0 = v1;\n        }\n    }\n    return vec4(col,v0);\n}\n\n//line segment SDF\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n//scene SDF\n//sceneDist.w is the distance, sceneDist.xyz is the color\nvec4 sceneDist(vec2 p) {\n    float v0 = 1000.;\n    vec3 col;\n\n    for(int i=0; i<segmentCount; i++) {\n\n        vec2 a = points[segments[i].x];\n        vec2 b = points[segments[i].y];\n        \n        float v1 = line(p, a, b);\n        if(v1<v0) {       \n            col = materials[segments[i].z];\n            v0 = v1;\n        }\n    }\n    return vec4(col,v0);\n}\n\nvec2 sceneNormal(vec2 p) {\n    vec2 epsilon = vec2(.00005, -.00005);\n    return normalize(vec2(sceneDist(p+epsilon.xx).w) - vec2(sceneDist(p-epsilon.xy).w,sceneDist(p-epsilon.yx).w));\n}\n\nvec2 cosineWeightedSample(vec2 dir, float fac) {\n    float t = 2.0 * fac - 1.0;\n    vec2 a = t * dir.yx * vec2(-1, 1);\n    vec2 b = sqrt(1.0-t*t) * dir;\n    return a + b;\n}\n\nfloat inverseFalloff(float x) {\n    float const1 = 10.0;\n    float xSq = x*x;\n    return (1.0-xSq)/(const1*xSq+1.0);\n}\n\n/*\nvec3 Tonemap_Unreal(vec3 x) {\n    // Unreal 3, Documentation: \"Color Grading\"\n    // Adapted to be close to Tonemap_ACES, with similar range\n    // Gamma 2.2 correction is baked in, don't use with sRGB conversion!\n    return x / (x + 0.155) * 1.019;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col;\n    vec2 p = (2.*fragCoord-iResolution.xy-.5)/iResolution.x;\n    \n    vec3 spot;\n    vec3 gi;\n    \n    vec2 lightPos = vec2(sin(iTime*.5)*.75,cos(iTime*.25)*.25+.25);\n\n    vec2 lightDir = normalize(vec2(sin(iTime*1.5),-1));\n    if (iMouse.z > 0.){\n        lightPos = vec2(2,-2)*iMouse.zw/iResolution.x-vec2(1.,.56);\n        lightDir = normalize(2.*iMouse.xy/iResolution.x-vec2(1.,.561)-lightPos);\n    }\n    float lightRad = .005;\n    \n    vec2 ro = p;\n    vec2 rd = normalize(lightPos-p);\n    if (sceneIntersect(ro, rd).w > distance(p,lightPos)) {\n        spot = vec3(max((.5*float(dot(normalize(p-lightPos),lightDir))-.5)/lightRad+1.,0. ));\n    }\n    \n    for (int i=0; i<samples; i++) {\n        ro = lightPos;\n        float rot = .085*pi*((float(i)+(IGN(ivec2(fragCoord.xy), 0)))/float(samples)-.5) + atan(lightDir.y,lightDir.x);\n        vec2 lightRayDir = vec2(cos(rot),sin(rot));\n        rd = lightRayDir;\n        vec4 lightRay0 = sceneIntersect(ro,rd);\n        if (lightRay0.w < 10.) {\n            vec2 hit = ro + rd * (lightRay0.w - .0001);\n            vec2 hitNor = sceneNormal(hit);\n            ro = p;\n            rd = normalize(hit-p);\n            if (dot(rd, hitNor) < 1.0) {\n                vec4 pixelRay0 = sceneIntersect(ro,rd);\n                if (pixelRay0.w > distance(hit,p)) {\n                    float rad = 1.0;\n                    rad *= max(-dot(rd,hitNor),0.0);\n                    rad *= max(-dot(lightRayDir,hitNor),0.0);\n                    rad *= inverseFalloff(pixelRay0.w * 0.5);\n                    gi += rad * lightRay0.rgb / float(samples);        \n                    \n                   \n                }\n            }\n            if(secondBounce) {\n                for (int j=0; j<sampleMult; j++) {\n\n                    ro = hit;\n                    rd = cosineWeightedSample(hitNor,(float(j)+(IGN(ivec2(fragCoord.xy), i+1)))/float(sampleMult));\n                    vec4 lightRay1 = sceneIntersect(ro,rd);\n                    if (lightRay1.w < 10.) {\n                        vec2 hit = ro + rd * (lightRay1.w - .0001);\n                        vec2 hitNor = sceneNormal(hit);\n                        ro = p;\n                        rd = normalize(hit-p);\n                        if (dot(rd, hitNor) < 1.0) { \n                            vec4 pixelRay1 = sceneIntersect(ro,rd);\n                            if (pixelRay1.w > distance(hit,p)) { \n                                float rad = 2.0; // Artificially brightened second bounce bc it looks better\n                                rad *= max(-dot(rd,hitNor),0.0);\n                                rad *= inverseFalloff(pixelRay1.w * 0.5);\n                                rad *= inverseFalloff(lightRay1.w * 0.5);\n                                gi += rad * lightRay0.rgb * lightRay1.rgb / (float(samples)*float(sampleMult));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    vec4 scene = sceneDist(p);\n    col = spot*0.5 + gi*1.0;\n    col *= scene.w > .005 ? vec3(.25) : 2.*scene.rgb;\n    \n    // Tonemapping\n    //col = Tonemap_Unreal(col);\n    col = 1.-exp(-col * 4.);\n    // Suggested by @ENDESGA\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}