{"ver":"0.1","info":{"id":"M333zf","date":"1716819624","viewed":166,"name":"{Orange Blossom}","username":"inverse_transpose","description":"Ray marching a sphere and using swirly noise to mutate space and mix colours.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","swirlynoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return (fract((p3.x + p3.y) * p3.z)-.5)*1.5;\n}\n\n\n#define iterations 1\n#define flowintensity 1.25\n#define numOctaves 5\n#define flowoffset 0.25\n\nvec4 noised( in vec3 x )\n{\n    vec3 i = vec3(floor(x));\n    vec3 w = fract(x);\n    \n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w); \n    \n    float a = hash(i+vec3(0,0,0));\n    float b = hash(i+vec3(1,0,0));\n    float c = hash(i+vec3(0,1,0));\n    float d = hash(i+vec3(1,1,0));\n    float e = hash(i+vec3(0,0,1));\n\tfloat f = hash(i+vec3(1,0,1));\n    float g = hash(i+vec3(0,1,1));\n    float h = hash(i+vec3(1,1,1));\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( vec3 x )\n{    \n    float G = exp2(-1.);\n    float f = 1.0;\n    float a = 1.0;\n    vec4 t;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(x * f);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\n//@CollinInMySternum function to make swirly noise using fbm\nfloat curl(vec3 p, vec3 n)\n{\n    for(int i=0; i<iterations; i++)\n    {\n        vec3 x = p + flowoffset;\n        vec3 g = cross(fbm(x).yzw, n);\n        p -= (flowintensity / float(iterations)) * g;\n    }\n    \n    return (fbm(p).x + 1.0) / 2.0;\n}\n\n\nfloat sdSphere(in vec3 p, in float r)\n{\n    vec3 q = normalize(p);\n    float k = curl(p+iTime*.15, q);\n    return length(p)-r-k*.17;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n    vec3 ro = vec3(.0, .0, 1.95);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));\n  \n    vec3 col = vec3(1.,.7,.4);\n    float td = .0;\n    for (int i = 0; i < 30; ++i)\n    {\n        vec3 p = ro + td*rd;\n        float d = sdSphere(p, .5)*.9;\n        td += d;\n        if (d < .01)\n        {\n            vec3 q = normalize(p);\n            vec2 tuv = vec2(atan(q.z, q.x), acos(q.y));\n            col = mix(vec3(1.,.6,.2),vec3(1), curl(p+iTime*.15, q));\n            break;\n        }\n        \n        if (td > 10.0)\n            break;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}