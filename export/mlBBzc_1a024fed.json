{"ver":"0.1","info":{"id":"mlBBzc","date":"1694304632","viewed":37,"name":"Circle Playground","username":"samansepehri","description":"I am playing with ideas around a circle.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["sdf","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cirlceSdf(vec2 uv, vec2 center, float radius );\nfloat ellipseSdf(vec2 uv, vec2 center, vec2 ab);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 screenRatio = iResolution.xy / minRes;\n    \n    // Normalized pixel coordinates (from 0 to max(iResolution.xy)/min(iResolution.xy) )\n    vec2 uv = fragCoord/minRes;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float r = .1;\n    vec2 centerInitial = .5 * screenRatio;\n    \n    vec4 timeUpdate = texelFetch(iChannel0, ivec2(0), 0);\n    \n    vec2 centerUpdated = centerInitial + timeUpdate.xy;\n        \n    vec2 ab = vec2(r);\n    ab.x = mix(r/2., r, clamp(abs(timeUpdate.z + 1.), 0., 1.));\n    ab.y = mix(r/2., r, clamp(abs(timeUpdate.w + 1.), 0., 1.));\n\n    \n    float circle = ellipseSdf(uv, centerUpdated, ab); //cirlceSdf(uv, centerUpdated, r);\n    \n    \n    // Output to screen\n    fragColor = vec4(col*mix(1., 0., circle), 1);\n    \n}\n\nfloat cirlceSdf(vec2 uv, vec2 center, float radius )\n{\n    return ellipseSdf(uv, center, vec2(radius));\n}\n\nfloat ellipseSdf(vec2 uv, vec2 center, vec2 ab)\n{\n    return pow(uv.x-center.x, 2.)/pow(ab.x, 2.)+pow(uv.y-center.y, 2.)/pow(ab.y, 2.)-1. > 0. ? 1. : 0.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 screenRatio = iResolution.xy / minRes;\n    vec4 mouseN = iMouse / minRes;\n    \n    float r = .1;\n    vec2 centerInitial = .5 * screenRatio;\n    vec2 speedV2 = vec2(.02);\n    vec2 difVec = vec2(0.);\n    \n    vec4 fetchedTime = texelFetch(iChannel0, ivec2(0), 0);\n\n    \n    if(iMouse.z > 0.)\n    {\n        bool isInside  = length(mouseN.xy - (centerInitial+fetchedTime.xy)) < r;\n        {\n            difVec = mouseN.xy - abs(mouseN.zw);\n            speedV2 = vec2(0.);\n        }\n    }\n    if(iMouse.w > 0.) // Mouse clicked\n    {\n        vec2 dragVec = mouseN.xy - abs(mouseN.zw);\n        float speedMultiplier = length(dragVec);\n        // Init the speed\n        speedV2 = speedMultiplier == 0.0 ? vec2(.0) : dragVec / 10. ;\n    }\n    else\n    {\n        // Load from memory\n        speedV2 = texelFetch(iChannel0, ivec2(0, 1), 0).xy;\n    }\n    speedV2 = clamp(speedV2 - vec2(iTimeDelta/200.), 0., 1.);\n    \n    vec2 uv = fragCoord;\n    \n    if(uv.x > 2. || uv.y > 2.) {discard;}\n\n    \n    vec2 dragChange = abs(mouseN.zw) - centerInitial + difVec;\n    vec4 timeUpdate = difVec == vec2(0.) ? fetchedTime : vec4(dragChange, vec2(0.));\n    \n    // fetchedTime.zw represents directions for xy; 0 means positive and 1 means negative.\n    \n    // Computing direction based on collisions\n    vec2 tempTime = timeUpdate.xy + speedV2*(fetchedTime.zw+1.);\n    vec2 centerPreUpdate = centerInitial + tempTime; \n        \n    if (centerPreUpdate.x < r || centerPreUpdate.x > screenRatio.x-r)\n    {\n        timeUpdate.z = -2. - timeUpdate.z;\n    }\n    if (centerPreUpdate.y < r || centerPreUpdate.y > screenRatio.y-r)\n    {\n        timeUpdate.w = -2. - timeUpdate.w;\n    }\n    \n    timeUpdate.xy += speedV2*(timeUpdate.zw+1.);\n\n    \n    \n    // Output to screen\n    fragColor = vec4(0.);\n    \n    if(ivec2(uv) == ivec2(0))\n    {\n        fragColor = timeUpdate;\n    }\n    if(ivec2(uv) == ivec2(0, 1))\n    {\n        fragColor = speedV2.xyxy;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}