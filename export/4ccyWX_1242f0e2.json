{"ver":"0.1","info":{"id":"4ccyWX","date":"1731223765","viewed":50,"name":"hyperfrac 2","username":"maxiie","description":"3d mandelbrot/julia fractal now with structs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nconst float iDist=10.;\n\nconst float iPowerZ1=2.;\nconst float iPowerC1=0.;\nconst float iQuot1=1.;\n\nconst float iPowerZ2=0.;\nconst float iPowerC2=1.;\nconst float iQuot2=1.;\n\nconst float iPowerZ3=0.;\nconst float iPowerC3=0.;\nconst float iQuot3=0.;\n\nconst float iVoxRes=3.0;\nconst int iMaxTrace=500;\nconst bool isJulia=false;\nconst bool isAnti=false;\nconst float iAlpha=1.;\n\nconst bool intermode=true;\nconst float intervoidstepsize=5.0;\nconst float interhitstepsize=0.05;\nconst int interhitbreakval=100;\n\nconst float huefactor=3.0;\nconst float hueshift=0.0;\nconst float saturation=1.0;\nconst float colval=2.0;\nconst int colormode=0;\nconst float cm1base=0.1;\n\nconst int alphamode=0;\nconst float hitfactor=0.1;\n\nconst bool mixmul=false;\n\nconst float pi = 3.141592;\nconst float tau = 2.0*pi;\nconst float ee=2.71828182846 ;\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\nstruct HON{\n    vec3 val;\n    vec3 ori;\n};\n\n\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nHON cAdd(HON a,HON b){\n    HON c=HON(vec3(0),vec3(0));\n    \n    c.val=vec3(a.val.x+b.val.x,a.val.y+b.val.y,a.val.z+b.val.z);\n\n\n    if(length(a.val)==0.0){c.ori=b.ori;return c;}\n    if(length(b.val)==0.0){c.ori=a.ori;return c;}\n\n\n    if(length(b.ori.x)+length(a.ori.x)==0.0){c.ori.x=0.;}\n    else{\n      c.ori.x=atan(sin(a.ori.x)/length(c.val.xy)*length(a.val.xy)+sin(b.ori.x)/length(c.val.xy)*length(b.val.xy),cos(a.ori.x)/length(c.val.xy)*length(a.val.xy)+cos(b.ori.x)/length(c.val.xy)*length(b.val.xy));\n      }\n\n    if(length(b.ori.y)+length(a.ori.y)==0.0){c.ori.y=0.;}\n    else{\n      c.ori.y=atan(sin(a.ori.y)/length(c.val.yz)*length(a.val)+sin(b.ori.y)/length(c.val.yz)*length(b.val),cos(a.ori.y)/length(c.val.yz)*length(a.val)+cos(b.ori.y)/length(c.val.yz)*length(b.val));\n    }\n    if(length(b.ori.z)+length(a.ori.z)==0.0){c.ori.z=0.;}\n    else{\n      c.ori.z=atan(sin(a.ori.z)/length(c.val.xz)*length(a.val)+sin(b.ori.z)/length(c.val.xz)*length(b.val),cos(a.ori.z)/length(c.val.xz)*length(a.val)+cos(b.ori.z)/length(c.val.xz)*length(b.val));\n    }\n    return c;\n\n}\n\n\nHON cLogT(HON a) {\n    HON c=HON(vec3(0),vec3(0));\n    c.val=log(length(a.val))*normalize(a.val);\n    c.ori.x=atan(a.val.y, a.val.x);\n    c.ori.y=atan(a.val.z, a.val.y);\n    c.ori.z=atan(a.val.x, a.val.z);\n    return c;\n}\n\n\n\n\n\n\n\n\n\n\nHON cExpT1(HON a) {\n    HON c=HON(vec3(0),vec3(0));\n    c.val=exp(length(a.val))*normalize(a.val);\n    c.ori=a.ori;\n    return c;\n}\n\nHON cMulMix(HON a,HON b){\n    \n    HON c;\n\n    vec3 n;\n    vec3 nd;\n    vec3 p;\n    vec3 q;\n    vec3 r;\n    \n    n=normalize(a.val);\n    nd=b.ori;\n    \n    p.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    p.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=p;\n    p.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    p.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=p;\n    p.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    p.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    \n    n=normalize(b.val);\n    nd=a.ori;\n    \n    q.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    q.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=q;\n    q.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    q.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=q;\n    q.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    q.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n\n    n=vec3(1,0,0);\n    nd=a.ori+b.ori;\n    \n    r.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    r.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=r;\n    r.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    r.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=r;\n    r.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    r.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n\n    c.val=(p+q+2.*r)/4.;\n    c.ori=a.ori+b.ori;\n    if(length(a.val)==0.){c.val=vec3(0),c.ori=vec3(0);}\n    if(length(b.val)==0.){c.val=vec3(0),c.ori=vec3(0);}\n   \n    c.val*=length(a.val)*length(b.val);\n    \n    \n    return c;\n}\n\n\n\nHON cMul(HON a,HON b){\n    if(mixmul)return cMulMix(a,b);\n    HON c=HON(vec3(1,0,0),a.ori+b.ori);\n\n    vec3 n=c.val;\n    vec3 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    c.val.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    c.val*=length(a.val)*length(b.val);\n    return c;\n}\n\nHON cDiv(HON a,HON b){\n    HON c=HON(vec3(1,0,0),a.ori-b.ori);\n\n    vec3 n=c.val;\n    vec3 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    c.val.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    c.val*=length(a.val)/length(b.val);\n    return c;\n}\n\nHON cPowf(HON a,float npow){\n    HON c=HON(vec3(1,0,0),a.ori*npow);\n    if(npow==0.)return c;\n\n    vec3 n=c.val;\n    vec3 nd=c.ori;\n\n    c.val.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.val.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c.val;\n    c.val.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    c.val.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=c.val;\n    c.val.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    c.val.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    c.val*=pow(length(a.val),npow);\n    return c;\n\n}\n\nHON cInit(float a, float b, float c,float q){\n    HON d=HON(vec3(0),vec3(0));\n    d=cAdd(HON(vec3(a,0.0,0.0),vec3(((a<0.)?PI:0.),0.0,0.0)),HON(vec3(0.0,b,0.0),vec3(PI/2.+((b<0.)?PI:0.),0.0,0.0)));\n    d=cAdd(d,HON(vec3(0.0,0.0,c),vec3(0.0,0.0,PI/2.+((c<0.)?PI:0.))));\n    d=cAdd(d,HON(vec3(0.0,0.0,q),vec3(0.0,PI/2.+((q<0.)?PI:0.),0.0)));\n    return d;\n}\n\nHON cLog(HON a) {\n    HON c = HON(vec3(0), vec3(0));\n    float magnitude = length(a.val);\n\n    if (magnitude==0.) {\n        return HON(vec3(0), vec3(0));\n    }\n\n    float m = log(magnitude);\n\n    c=cInit(m,a.ori.x,a.ori.z,a.ori.y);\n    return c;\n}\n\n\n\n\n\nHON cExp(HON a) {\n    HON c=HON(vec3(0),vec3(0));\n    \n    HON expN = cInit(ee,0.0,0.0,0.0);\n    HON expI = cInit(cos(a.val.y), sin(a.val.y), 0.0, 0.0); \n    HON expJ = cInit(cos(a.val.z), 0.0, sin(a.val.z), 0.0);\n    \n    \n    expN=cPowf(expN,a.val.x);\n\n    vec3 o=vec3(length(a.val.xy)*sin(a.ori.x),length(a.val.yz)*sin(a.ori.y),length(a.val.xz)*sin(a.ori.z));\n    \n\n    c=cMul(cMul(expJ,expI),expN);\n    c.ori=o;\n    return c;\n}\nHON cfPow(float f,HON a) {\n    HON c=HON(vec3(0),vec3(0));\n    if(f==0.)return cInit(0.,0.,0.,0.);\n    \n    HON expN = cInit(f,0.0,0.0,0.0);\n    HON expI = cInit(cos(a.val.y*log(f)), sin(a.val.y*log(f)), 0.0, 0.0); \n    HON expJ = cInit(cos(a.val.z*log(f)), 0.0, sin(a.val.z*log(f)), 0.0); \n    \n    \n    expN=cPowf(expN,a.val.x);\n    vec3 o=vec3(length(a.val.xy)*log(f)*sin(a.ori.x),length(a.val.yz)*log(f)*sin(a.ori.y),length(a.val.xz)*log(f)*sin(a.ori.z));\n    \n    c=cMul(cMul(expJ,expI),expN);\n    c.ori=o;\n    return c;\n}\n\nHON cPow(HON a,HON b){\n    HON c=HON(vec3(0),vec3(0));\n\n    if(length(b.val)==0.)return cInit(1.,0.,0.,0.);\n    if(length(a.val)==0.)return c;\n    \n    \n    HON t1=cPowf(a,length(b.val));\n    HON t2=cExp(cMul(b,cLog(a)));\n    HON v=cLog(cPowf(a,-length(b.val)));\n    //v.val/=log(length(b.val));\n    \n    v=cDiv(v,cLog(cInit(length(b.val),0.,0.,0.)));\n    HON t3=cfPow(length(b.val),v);\n    c=cMul(t1,cMul(t2,t3));\n    return c;\n}\n\n\n\nvec3 mandi(in vec3 p ) {\n\n    HON z=HON(vec3(0),vec3(0));\n    HON q;\n    HON k;\n    HON m;\n    HON g;\n    HON c=cInit(p.x,p.y,p.z,.0);\n    HON wo1=cInit(iQuot1,0.,0.,0.);\n    HON wo2=cInit(iQuot2,0.,0.,0.);\n    HON wo3=cInit(iQuot3,0.,0.,0.);\n\n    bool inMandelbrotSet = true;\n\n    for (int i=0; i<100; i++) {\n\n\tm=HON(vec3(0),vec3(0));\n\tif(iQuot1==0.){\n\t\tg=HON(vec3(0),vec3(0));\n\t}\n\telse{\n\t  q=cPowf(z,iPowerZ1);\n      k=cPowf(c,iPowerC1);\n      g=cMul(q,k);\n      m=cMul(g,wo1);\n \n\t}\n\tm=cAdd(m,g);\n\tif(iQuot2==0.){\n\t\tg=HON(vec3(0),vec3(0));\n\t}\n\telse{\n        q=cPowf(z,iPowerZ2);\n        k=cPowf(c,iPowerC2);\n\t\tg=cMul(q,k);\n\t\tg=cMul(g,wo2);\n\t}\n\n\n    m=cAdd(m,g);\n\tif(iQuot3==0.){\n\t\tg=HON(vec3(0),vec3(0));\n\t}\n\telse{\n\t\tq=cPowf(z,iPowerZ3);\n        k=cPowf(c,iPowerC3);\n\t\tg=cMul(q,k);\n\t\tg=cMul(g,wo3);\n\t}\n        m=cAdd(m,g);\n\n\tz=m;\n    //z=cExp(cLog(m));\n    //HON mlog=cLog(m);\n    //mlog.val/=log(2.);\n    //z=cfPow(2.,mlog);\n\n        if (length(z.val) > 2.) {\n            inMandelbrotSet = false;\n            break;\n        }\n    }\n    if (inMandelbrotSet^^isAnti) {\n        return(z.val);\n    } else {\n        return(vec3(0.));\n    }\n}\n\nvec3 julia(in vec3 p ) {\n\n    HON z=HON(vec3(0),vec3(0));\n\n    HON c;\n    HON q;\n    z=cInit(p.x,p.y,p.z,0.0);\n    c=cInit(0.3,0.5,0.4,0.6);\n    int j=0;\n\n    for (int i=0; i<100; i++) {\n\n        q=cPowf(z,iPowerZ1);\n\n        z=cAdd(q,c);\n\n        if (length(z.val) > 100.) {\n            break;\n        }\n        j++;\n    }\n\tif((float(j)/100.<0.1)^^isAnti){return vec3(0.0);}\n\telse return(z.val);\n}\n\n\n\n#define TIME iTime/2.0\n\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n\nhit getVoxel(vec3 p) {\n        vec3 c;\n        if(isJulia){c=julia(vec3(p)*.05/iVoxRes);}\n        else{c=mandi(vec3(p)*.05/iVoxRes);}\n    if (length(c)!=0.) {\n        vec3 color=vec3(1);\n        if(colormode==0){\n            color=hsv2rgb(vec3(length(c)*huefactor+hueshift,saturation,colval));}\n        if(colormode==1){\n            color=rgb2hsv(vec3(pow(cm1base,c.x),pow(cm1base,c.y),pow(cm1base,c.z)));\n            color.y=saturation;\n            color.z=colval;\n            color=hsv2rgb(color);\n            }\n            \n        return hit(true, color);}\n    else\n        return hit(false, vec3(0,0,0));\n\n}\n\nvec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {\n    vec3 lightDir = normalize(vec3(-1.0, 3.0, -1.0));\n    float diffuseAttn = max(dot(norm, lightDir), 0.0);\n    vec3 light = vec3(1.0,0.9,0.9);\n\n    vec3 ambient = vec3(0.2, 0.2, 0.3);\n\n    vec3 reflected = reflect(rd, norm);\n    float specularAttn = max(dot(reflected, lightDir), 0.0);\n\n    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);\n}\n\n// Voxel ray casting algorithm from \"A Fast Voxel Traversal Algorithm for Ray Tracing\"\n// by John Amanatides and Andrew Woo\n// http://www.cse.yorku.ca/~amana/research/grid.pdf\nhit intersect(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = (ro*iVoxRes);\n\n    vec3 step = sign(rd);\n\n    vec3 tDelta = step / rd;\n\n\n    float tMaxX, tMaxY, tMaxZ;\n\n    vec3 fr = fract(ro*iVoxRes);\n\n    tMaxX = tDelta.x * ((rd.x>0.0) ? (1.0 - fr.x) : fr.x);\n    tMaxY = tDelta.y * ((rd.y>0.0) ? (1.0 - fr.y) : fr.y);\n    tMaxZ = tDelta.z * ((rd.z>0.0) ? (1.0 - fr.z) : fr.z);\n\n    vec3 norm;\n    int maxTrace = iMaxTrace;\n    int hits=0;\n    hit q=hit(false,vec3(0,0,0));\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(vec3(pos));\n        if (h.didHit) {\n          if(iAlpha==1.){\n            return hit(true, (lighting(norm, pos, rd, h.col)+h.col)/2.);\n            }\n            else{\n              hits+=1;\n              if(alphamode==0){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)));\n              }\n              if(alphamode==1){\n                  q=hit(true,(h.col*(iAlpha)*float(hits)*hitfactor+q.col*(1.0-iAlpha))/(float(hits)*hitfactor));}\n              if(alphamode==2){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)*float(hits)*hitfactor)/(float(hits)*hitfactor));}\n              \n            }\n        }\n\n        if (tMaxX < tMaxY) {\n            if (tMaxZ < tMaxX) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0,-step.z);\n            } else {\n                tMaxX += tDelta.x;\n            \tpos.x += step.x;\n                norm = vec3(-step.x, 0, 0);\n            }\n        } else {\n            if (tMaxZ < tMaxY) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0, -step.z);\n            } else {\n            \ttMaxY += tDelta.y;\n            \tpos.y += step.y;\n                norm = vec3(0, -step.y, 0);\n            }\n        }\n    }\n\n \treturn q;\n}\n\nhit intersect2(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = (ro*iVoxRes);\n\n    vec3 step = normalize(rd)/iVoxRes;\n\n    vec3 tDelta = step / rd;\n    int hits=0;\n\n    vec3 norm=vec3(1.);\n    int maxTrace = iMaxTrace;\n    hit q=hit(false,vec3(0,0,0));\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(vec3(pos));\n        if (h.didHit) {\n          if(iAlpha==1.){\n            return hit(true, (lighting(norm, pos, rd, h.col)+h.col)/2.);\n            }\n            else{\n              hits+=1;\n              if(alphamode==0){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)));\n              }\n              if(alphamode==1){\n                  q=hit(true,(h.col*(iAlpha)*float(hits)*hitfactor+q.col*(1.0-iAlpha))/(float(hits)*hitfactor));}\n              if(alphamode==2){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)*float(hits)*hitfactor)/(float(hits)*hitfactor));}\n              \n              \n              pos+=step*interhitstepsize;\n              \n              i=0;\n              if(hits==interhitbreakval)return q;\n            }\n        }else pos+=step*intervoidstepsize;\n\n    }\n\n \treturn q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv =fragCoord.xy / iResolution.xy - 0.5;\n    vec3 worldUp = vec3(0,1,0);\n    vec3 camPos = vec3(iDist*sin(TIME), 10, 1.0*iDist*cos(TIME));\n    vec3 lookAt = vec3(0,0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp = cross(camRight, camDir);\n\n    vec3 filmCentre = camPos + camDir*0.3;\n    vec2 filmSize = vec2(1,iResolution.y / iResolution.x);\n\n    vec3 filmPos = filmCentre + uv.x*filmSize.x*camRight + uv.y*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos - camPos);\n    hit h;\n    if(intermode){h = intersect2(ro, rd);}\n    else{h = intersect(ro, rd);}\n    if(h.didHit) {\n        fragColor = vec4(h.col,1);\n    } else{\n       fragColor = vec4(0,0,0,0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}