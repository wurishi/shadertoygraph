{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Helices by nimitz (twitter: @stormoid)\n\n/*\n\tStarted as an experiment to improve performance of volumetric raymarching of deformed\n\tgeometry, turned out to be better than expected.\n\n\tThe first optimization is \"dual raymarching\", the first raymarching loop is very coarse\n\tand lets the volumetric function be ran for only the needed portion of the image and\n\twith a better starting position (on the surface of the volumetric ray).\n\n\tThen the same distance field is used for volumetric drawing but instead of simply using\n\ta fixed step, the function is also incremented with dynamic step provided the ray is\n\toutside the geometry. This allows for stepping through long volumetric spaces\n\twith a relatively small computational cost.\n\n\tAlso includes an experiment on spherically projected backgrounds, which allows to fake geometry\n\twithout any intersection checking.\n\n*/\n\n//RANGE 0...1\n#define RAY_THICKNESS 0.7\n#define RAY_BRIGHTNESS .86\n#define RAY_FUZZYNESS 0.09\n\n#define POSTPROCESS\n\n#define MAX_ITER 35\n#define FAR 20.\n#define time iTime\n\n//const friendly mix()\n#define MIX(X, Y, A) ((X) + (A)*((Y) - (X)))\n\nconst float tk = MIX(0.04, 0.05, RAY_THICKNESS);\nconst float fz = MIX(0.04, 0.005, RAY_FUZZYNESS);\nconst float ints = MIX(0.005, 0.0014, RAY_BRIGHTNESS);\nconst float intsfz = ints/fz;\n\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\nfloat noise( in vec2 x ){return textureLod(iChannel0, x*.01,0.0).x;}\nvec2 opU( vec2 d1, vec2 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\n//l.x = amplitude | l.y = frequency | l.z = speed | l.w = offset\n//(Tried using a proper helix sdf, but it wasnt as deformable)\nfloat helix( vec3 p, vec3 a, vec3 b, vec4 l)\n{\n  \tp.x += sin(p.z*l.y+time*5.*l.z+l.w)*l.x;\n    p.y += cos(p.z*l.y+time*5.*l.z+l.w)*l.x;\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h )*.6;\n}\n\nvec3 path(float x)\n{   \n    return vec3(cos(time+x*0.5)*0.4, sin(time+x)*0.2,0.);\n}\n\n//the map is used for both marching loops\nvec2 map(vec3 p)\n{\n    p -= path(p.z);\n    vec2 rz = vec2(0);\n    vec3 bg = vec3(0.,0.,-15.);\n    vec3 en = vec3(0.,0.,1.);\n    \n    const float pw = 0.15;\n    \n    rz.xy = \t\t vec2(helix(p, bg, en, vec4(pw,    4.,   1., 3.1415))-tk, 1.05);\n    rz.xy = opU(rz, vec2(helix(p, bg, en, vec4(pw,    4.,   1., 0.))-tk, 3.2) );\n    rz = opU(rz, vec2(helix(p, bg, en, vec4(0.003, 100., 20.,1.))-tk, 2.) );\n    rz = opU(rz, vec2(helix(p, bg, en, vec4(0.07,  2., 1.,  0.))-tk, 5.) );\n    \n    return rz;\n}\n\n//first raymarching pass (very coarse)\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd)\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h;\n\t    float res = map(ro+rd*d).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float tot = 0.;\n    for( int i=0; i<200; i++ )\n    {\n        r = map(p);\n        if (r.x > .5)break;\n        vec3 col = sin(vec3(1.5,2.,1.8)*r.y*1.3+0.4)*.9+0.15;\n        col.rgb *= smoothstep(fz,intsfz,-r.x);\n        sum += abs(col) * (1.8-noise(p.x*1.+p.z*10.+time*16.)*1.3);\n        //\"hybrid\" step\n        p += rd*max(.015, max(r.x,0.)*3.);\n    }\n    return clamp(sum,0.,1.);\n}\n\n//-------------------------------------------------------\n//-------------------background--------------------------\n//-------------------------------------------------------\nfloat f(vec3 p)\n{\n    //any metric can be used (using chebyshev here)\n    float r = max(abs(p.x),abs(p.y));\n    vec3 z = vec3(p)/(.8+r);\n    \n    const float frq = 10.;\n    float rz = abs(fract(z.x*frq)-0.5);\n    rz = min(abs(fract(z.y*frq)-0.5),rz);\n    rz = max(abs(fract(z.z*frq)-0.5),rz)-0.04;\n    \n    return rz;\n}\n\nvec3 normal(const in vec3 p)\n{  \n\tvec2 e = vec2(-1.0, 1.0)*0.001;   \n\treturn normalize(e.yxx*f(p + e.yxx) + e.xxy*f(p + e.xxy) +\n\t\t\t\t\t e.xyx*f(p + e.xyx) + e.yyy*f(p + e.yyy));\n}\n\n//ao from iq (for the background)\nfloat calcAO(in vec3 p, in vec3 nor)\n{\n    float tot = 1.0;\n    float sca = 20.0;\n    for(int i=0; i<5; i++)\n    {\n        float hr = 0.001 + 0.005*float(i*i);\n        vec3 pos =  nor * hr + p;\n        float d = f(pos)*0.025;\n        tot += (d-hr)*sca;\n        sca *= .5;\n    }\n    return clamp( tot, 0.0, 1.0 );\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//vector wheel (for camera switches)\nvec3 wheel(in vec3 a, in vec3 b, in vec3 c, in float delta)\n{\n\treturn mix(mix(mix( a,b,clamp((delta-0.0000)*3., 0., 1.)),\n\t\t\t\t\t\t  c,clamp((delta-0.3333)*3., 0., 1.)),\n\t\t\t\t\t\t  a,clamp((delta-0.6666)*3., 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy*2.-1.;\n    vec2 bp = p;\n\tp.x*=iResolution.x/iResolution.y;\n    p*= .15+(sin(time*0.25)*0.5+0.5)*0.25;\n\tvec2 um = iMouse.xy/iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    \n\t//cameras\n    const float ptx = 0.9;\n\tvec3 ro1 = vec3(1.,sin(time*0.2),3.)+path(ptx);\n\tvec3 ta1 = vec3(0,0.,sin(time))+path(ptx);\n    vec3 ro2 = vec3(sin(-time*1.2)*0.3,cos(-time*1.1)*0.3,-17.5)+path(ptx);\n\tvec3 ta2 = vec3(0,0.,-14.)+path(ptx);\n    vec3 ro3 = vec3(5.,2.,sin(time*.4)*10.-9.)+path(ptx);\n\tvec3 ta3 = vec3(0,0.,sin(time*.4)*3.-9.)+path(ptx);\n    \n    #if 1\n    float m = fract( (floor(time*.12)+smoothstep(0.4,.6,fract(time*.12)))*.3333 );\n    vec3 ro = wheel(ro1,ro2,ro3,m);\n    vec3 ta = wheel(ta1,ta2,ta3,m);\n    #else\n    vec3 ro = ro1; \n    vec3 ta = ta1;\n    #endif\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n    \n\tfloat rz = march(ro,rd,0.,FAR);\n    vec3 col = vec3(0);\n    vec3 pos = ro+rz*rd;\n    if (rz < FAR)\n    {\n    \tcol = vmarch(pos,rd);\n    }\n    \n    //background\n    vec3 nor = normal(rd);\n    vec3 ligt = normalize(vec3(cos(time*0.4),sin(time*0.42),.5));\n    float ao = calcAO(rd, nor);\n    ao*= ao;\n    \n    float mat = f(rd);\n    float dif = abs(dot(nor,ligt))*ao;\n    float bac = ao*clamp( dot( nor, normalize(vec3(-ligt.x,0.0,-ligt.z))), 0., 1. )*clamp( 1.0-rd.y,0.0,1.0);\n    float fre = pow( clamp(1.+dot(nor,rd), 0., 1.), 2. )*ao;\n    float spe = pow(abs(dot(reflect(rd,nor),ligt)),10.)*ao;\n    col += 2.2*(0.1*vec3(0.5,0.7,.9)*bac + 0.2*vec3(1.)*spe + 0.2*vec3(0.3,0.3,.4)*fre +\n           \t\t0.1*vec3(0.2,0.5,0.9)*dif + 0.2*vec3(0.5,0.5,.7)*mat);\n    \n    col = pow(col,vec3(1.5))*1.1;\n    \n    #ifdef POSTPROCESS\n    col *= 1.-pow(length(bp*bp*bp*bp)*1.09,10.);\n    col += (smoothstep(.0,.2,abs(fract(time*10.+p.y*iResolution.y*0.3)-0.5))*.03-0.04);\n    #endif\n    \n    //col = vec3(pow(ao,1.)); //shows the background AO only\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfXDs","date":"1408993307","viewed":2441,"name":"Volumetric Helices","username":"nimitz","description":"Optimizations of volumetric raymaching.","likes":54,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","volumetric","dualmarching","hybridmarching"],"hasliked":0,"parentid":"","parentname":""}}