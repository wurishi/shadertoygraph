{"ver":"0.1","info":{"id":"WtfSRs","date":"1584047955","viewed":90,"name":"Simple raymarch shader","username":"KappnKrunch","description":"this is a test of a raymarching algorithm.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdCapsule(vec3 p,vec3 a, vec3 b, float r)\n{\n    vec3 ab = b- a;\n    vec3 ap = p- a;\n    \n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t , 0. , 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(-3.5,-1,12,0.5);    \n    \n    float planeDist = p.y + 3.0;\n    \n    \n    float d = planeDist;\n    \n    \n    \n    float sphereDist = length(p -s.xyz) - s.w;\n    for(int i = 1; i < 12; i++)\n    {\n        float aroundPiX = ((float(i)/12.0) * 2.0 * 3.14) + (iTime/2.);\n        float aroundPiY = ((float(i)/12.0) * 2.0 * 3.14) + (iTime/3.);\n        float aroundPiZ = ((float(i)/12.0) * 2.0 * 3.14) + (iTime/5.) + aroundPiX + aroundPiY;\n        \n        s += vec4(2.0*sin(aroundPiX),.5*sin(aroundPiZ),2.0*cos(aroundPiY),0);\n        \n\t\tsphereDist = min(length(p -s.xyz) - s.w,sphereDist);\n    }\n    \n   \n    d = min(d,sphereDist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    int MAX_STEPS = 100;\n\tfloat MAX_DIST = 10000.;\n\tfloat SURF_DIST = 0.0001;\n    \n    float dO = 0.0;\n    \n    //raymarching loop\n    for(int i = 0; i < MAX_STEPS; i ++)\n    {\n        //current marching position\n        vec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        \n        if( dO > MAX_DIST || dS < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n        );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,3,0);\n    lightPos.xz = vec2(sin( (17.0*iTime)/100.0 ),cos( (19.0*iTime)/100.0 ))*10.;\n    vec3 l = normalize(\tlightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p + n * 0.05,l);\n    \n    if( d < length(lightPos - p))\n    {\n        diff *= 0.1;\n    }\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n        \n    vec3 ro = vec3(0,1,0);        \n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    \n    vec3 col = vec3(dif);\n   \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}