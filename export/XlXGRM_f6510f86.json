{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Yet Another Christmas Tree by Ruslan Shestopalyuk, 2014/15\n// Many thanks to iq, eiffie and paolofalcao for the insight and the code\n\n#define PI                      3.14159265\n\n#define NORMAL_EPS              0.001\n\n#define NEAR_CLIP_PLANE         1.0\n#define FAR_CLIP_PLANE          100.0\n#define MAX_RAYCAST_STEPS       200\n#define STEP_DAMPING            0.7\n#define DIST_EPSILON            0.001\n#define MAX_RAY_BOUNCES         3.0\n\n#define MAX_SHADOW_DIST         10.0\n\n#define AMBIENT_COLOR           vec3(0.03, 0.03, 0.03)\n#define LIGHT_COLOR             vec3(0.8, 1.0, 0.9)\n#define SPEC_COLOR              vec3(0.8, 0.90, 0.60)\n\n#define SPEC_POWER              16.0\n\n#define FOG_DENSITY             0.001\n\n#define CAM_DIST                18.0\n#define CAM_H                   1.0\n#define CAM_FOV_FACTOR 4.0\n#define LOOK_AT_H               4.0\n#define LOOK_AT                 vec3(0.0, LOOK_AT_H, 0.0)\n\n#define MTL_BACKGROUND          -1.0\n#define MTL_GROUND              1.0\n#define MTL_NEEDLE              2.0\n#define MTL_STEM                3.0\n#define MTL_TOPPER              4.0\n#define MTL_CAP                 5.0\n#define MTL_BAUBLE              6.0\n\n#define CLR_BACKGROUND          vec3(0.3, 0.342, 0.5)\n#define CLR_GROUND              vec3(3.3, 3.3, 4.5)\n#define CLR_NEEDLE              vec3(0.152,0.36,0.18)\n#define CLR_STEM                vec3(0.79,0.51,0.066)\n#define CLR_TOPPER              vec3(1.6,1.0,0.6)\n#define CLR_CAP                 vec3(1.2,1.0,0.8)\n\n#define BAUBLE_REFLECTIVITY     0.7\n\n#define TREE_H                  4.0\n#define TREE_R                  3.0\n#define TREE_CURVATURE          1.0\n#define TRUNK_WIDTH             0.025\n#define TREE2_ANGLE             0.4\n#define TREE2_OFFSET            0.4\n#define TREE2_SCALE             0.9\n\n\n#define NEEDLE_LENGTH           0.5\n#define NEEDLE_SPACING          0.15\n#define NEEDLE_THICKNESS        0.05\n#define NEEDLES_RADIAL_NUM      17.0\n#define NEEDLE_BEND             0.99\n#define NEEDLE_TWIST            1.0\n#define NEEDLE_GAIN             0.7\n#define STEM_THICKNESS          0.02\n#define BRANCH_ANGLE            0.38\n#define BRANCH_SPACING          1.2\n#define BRANCH_NUM_MAX          9.0\n#define BRANCH_NUM_FADE         2.0\n\n#define BAUBLE_SIZE             0.5\n#define BAUBLE_SPACING          1.9\n#define BAUBLE_COUNT_FADE1      1.2\n#define BAUBLE_COUNT_FADE2      0.3\n#define BAUBLE_JITTER           0.05\n#define BAUBLE_SPREAD           0.6\n#define BAUBLE_MTL_SEED         131.0\n#define BAUBLE_YIQ_MUL          vec3(0.8, 1.1, 0.6)\n#define BAUBLE_CLR_Y            0.7\n#define BAUBLE_CLR_I            1.3\n#define BAUBLE_CLR_Q            0.9\n#define TOPPER_SCALE            2.0\n\n// Primitives\nfloat plane(vec3 p, vec3 n, float offs) {\n  return dot(p, n) + offs;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cone(in vec3 p, float r, float h) {\n    return max(abs(p.y) - h, length(p.xz)) - r*clamp(h - abs(p.y), 0.0, h);\n}\n\nfloat cylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat torus(vec3 p, float ri, float ro) {\n    vec2 q = vec2(length(p.xz) - ri, p.y);\n    return length(q) - ro;\n}\n\n\n// Boolean operations\nfloat diff(float d1, float d2) {\n    return max(-d2, d1);\n}\n\nfloat add(float d1, float d2) {\n    return min(d2, d1);\n}\n\nfloat intersect(float d1, float d2) {\n    return max(d2, d1);\n}\n\n\n// Boolean operations (with material ID in second component)\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\nvoid intersect(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\n\n// Affine transformations\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\n\n//  Repetition\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\nvec3 repeatAngS(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, mod(sector, n));\n}\n\n//  Complex primitives\nfloat star(vec3 p) {\n    p.xy = repeatAng(p.xy, 5.0);\n    p.xz = abs(p.xz);\n    return plane(p, vec3(0.5, 0.25, 0.8), -0.09);\n}\n\n//  Scene elements\nvec2 ground(in vec3 p) {\n    p.y += (sin(sin(p.z*0.1253) - p.x*0.371)*0.31 + cos(p.z*0.553 + sin(p.x*0.127))*0.12)*1.7 + 0.2;\n    return vec2(p.y, MTL_GROUND);\n}\n\nvec2 bauble(in vec3 pos, float matID) {\n    float type = mod(matID, 5.0);\n    float d = sphere(pos, BAUBLE_SIZE);\n    if (type <= 1.0) {\n        // bumped sphere\n        d += cos(atan(pos.x, pos.z)*30.0)*0.01*(0.5 - pos.y) + sin(pos.y*60.0)*0.01;\n    } else if (type <= 2.0) {\n        // dented sphere\n        d = diff(d, sphere(pos + vec3(0.0, 0.0, -0.9), 0.7));\n    } else if (type <= 3.0) {\n        // horisontally distorted sphere\n        d  += cos(pos.y*28.0)*0.01;\n    } else if (type <= 4.0) {\n        // vertically distorted sphere\n        d += cos(atan(pos.x, pos.z)*20.0)*0.01*(0.5 - pos.y);\n    }\n\n    vec2 res = vec2(d, matID);\n    //  the cap \n    pos = translate(pos, vec3(0.0, BAUBLE_SIZE, 0.0));\n    float cap = cylinder(pos, vec2(BAUBLE_SIZE*0.2, 0.1));\n    //  the hook\n    cap = add(cap, torus(pos.xzy - vec3(0.0, 0.0, 0.12), BAUBLE_SIZE*0.1, 0.015));\n    vec2 b = vec2(cap, MTL_CAP);\n    add(res, b);\n    return res;\n}\n\n\nvec2 baubles(in vec3 p) {\n    vec3 pos = p;\n    float h = abs(-floor(pos.y/BAUBLE_SPACING)/TREE_H + 1.0)*TREE_R;\n    float nb = max(1.0, floor(BAUBLE_COUNT_FADE1*(h + BAUBLE_COUNT_FADE2)*h));\n    vec3 rp = repeatAngS(pos.xz, nb);\n    float matID = (h + rp.z + BAUBLE_MTL_SEED)*117.0;\n    pos.xz = rp.xy;\n    pos.y = repeat(pos.y, BAUBLE_SPACING);\n    pos.y += mod(matID, 11.0)*BAUBLE_JITTER;\n    pos.z += -h + BAUBLE_SPREAD;\n    vec2 res = bauble(pos, matID);\n    res.x = intersect(res.x, sphere(p - vec3(0.0, TREE_H*0.5 + 0.5, 0.0), TREE_H + 0.5));\n    return res;\n}\n\nvec2 topper(vec3 pos) {\n    pos.y -= TREE_H*2.0;\n    pos /= TOPPER_SCALE;\n    float d = add(star(pos), cylinder(pos - vec3(0.0, -0.2, 0.0), vec2(0.04, 0.1)))*TOPPER_SCALE;\n    return vec2(d, MTL_TOPPER);\n}\n\nfloat needles(in vec3 p) {\n    p.xy = rotate(p.xy, -length(p.xz)*NEEDLE_TWIST);\n    p.xy = repeatAng(p.xy, NEEDLES_RADIAL_NUM);\n    p.yz = rotate(p.yz, -NEEDLE_BEND);\n    p.y -= p.z*NEEDLE_GAIN;\n    p.z = min(p.z, 0.0);\n    p.z = repeat(p.z, NEEDLE_SPACING);\n    return cone(p, NEEDLE_THICKNESS, NEEDLE_LENGTH);\n}\n\nvec2 branch(in vec3 p) {\n    vec2 res = vec2(needles(p), MTL_NEEDLE);\n    float s = cylinder(p.xzy + vec3(0.0, 100.0, 0.0), vec2(STEM_THICKNESS, 100.0));\n    vec2 stem = vec2(s, MTL_STEM);\n    add(res, stem);\n    return res;\n}\n\nvec2 halfTree(vec3 p) {\n    float section = floor(p.y/BRANCH_SPACING);\n    float numBranches =  max(2.0, BRANCH_NUM_MAX - section*BRANCH_NUM_FADE);\n    p.xz = repeatAng(p.xz, numBranches);\n    p.z -= TREE_R*TREE_CURVATURE;\n    p.yz = rotate(p.yz, BRANCH_ANGLE);\n    p.y = repeat(p.y, BRANCH_SPACING);\n    return branch(p);\n}\n\n\nvec2 tree(vec3 p) {\n    //  the first bunch of branches\n    vec2 res = halfTree(p); \n    \n    // the second bunch of branches (to hide the regularity)\n    p.xz = rotate(p.xz, TREE2_ANGLE);\n    p.y -= BRANCH_SPACING*TREE2_OFFSET;\n    p /= TREE2_SCALE;\n    vec2 t2 = halfTree(p);\n    t2.x *= TREE2_SCALE;\n    add(res, t2);\n\n    // trunk    \n    vec2 tr = vec2(cone(p.xyz, TRUNK_WIDTH, TREE_H*2.0), MTL_STEM);\n    add(res, tr);\n\n    res.x = intersect(res.x, sphere(p - vec3(0.0, TREE_H*0.5 + 1.0, 0.0), TREE_H + 1.0));    \n    return res;\n}\n\nvec2 distf(in vec3 pos) {\n    vec2 res = ground(pos);\n    \n    vec2 tr = tree(pos);\n    add(res, tr);\n    \n    vec2 top = topper(pos);\n    add(res, top);\n    \n    vec2 b = baubles(pos);\n    add(res, b);\n    return res;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 d = vec2(NORMAL_EPS, 0.0);\n    return normalize(vec3(\n        distf(p + d.xyy).x - distf(p - d.xyy).x,\n        distf(p + d.yxy).x - distf(p - d.yxy).x,\n        distf(p + d.yyx).x - distf(p - d.yyx).x));\n}\n\n\nvec2 rayMarch(in vec3 rayOrig, in vec3 rayDir) {\n    float t = NEAR_CLIP_PLANE;\n    float mtlID = MTL_BACKGROUND;\n    for (int i = 0; i < MAX_RAYCAST_STEPS; i++) {\n        vec2 d = distf(rayOrig + rayDir*t);\n        if (d.x < DIST_EPSILON || t > FAR_CLIP_PLANE) break;\n        t += d.x*STEP_DAMPING;\n        mtlID = d.y;\n    }\n\n    if (t > FAR_CLIP_PLANE) mtlID = MTL_BACKGROUND;\n    return vec2(t, mtlID);\n}\n\n\nvec3 applyFog(vec3 col, float dist) {\n    return mix(col, CLR_BACKGROUND, 1.0 - exp(-FOG_DENSITY*dist*dist));\n}\n\n\nconst mat3 YIQ_TO_RGB = mat3(\n    1.0,  0.956,  0.620, \n    1.0, -0.272, -0.647, \n    1.0, -1.108,  1.705);\n\nvec3 jollyColor(float matID) {\n    vec3 clr = cos(matID*BAUBLE_YIQ_MUL);\n    clr= clr*vec3(0.1, BAUBLE_CLR_I, BAUBLE_CLR_Q) + vec3(BAUBLE_CLR_Y, 0.0, 0.0);\n    return clamp(clr*YIQ_TO_RGB, 0.0, 1.0);\n}\n\nvec3 getMaterialColor(float matID) {\n    vec3 col = CLR_BACKGROUND;\n         if (matID <= MTL_GROUND) col = vec3(3.3, 3.3, 4.5);\n    else if (matID <= MTL_NEEDLE) col = vec3(0.152,0.36,0.18);\n    else if (matID <= MTL_STEM)   col = vec3(0.79,0.51,0.066);\n    else if (matID <= MTL_TOPPER) col = vec3(1.6,1.0,0.6);\n    else if (matID <= MTL_CAP)    col = vec3(1.2,1.0,0.8);\n    else                          col = jollyColor(matID);\n    return col;\n}\n\n\nfloat shadow(in vec3 rayOrig, in vec3 rayDir, in float tmin, in float tmax) {\n    float shadowAmt = 1.0;\n    float t = tmin;\n    for (int i = 0; i < MAX_RAYCAST_STEPS; i++) {\n        float d = distf(rayOrig + rayDir*t).x*STEP_DAMPING;\n        shadowAmt = min(shadowAmt, 16.0*d/t);\n        t += clamp(d, 0.01, 0.25);\n        if (d < DIST_EPSILON || t > tmax) break;\n    }\n\n    return clamp(shadowAmt, 0.0, 1.0);\n}\n\n\nvec3 render(in vec3 rayOrig, in vec3 rayDir) {\n    vec3  lightDir = -rayDir; // miner's lamp\n    vec3 resCol = vec3(0.0);\n    float alpha = 1.0;\n    for (float i = 0.0; i < MAX_RAY_BOUNCES; i++) {\n        vec2 d = rayMarch(rayOrig, rayDir);\n        float t = d.x;\n        float mtlID = d.y;\n        vec3 pos = rayOrig + t*rayDir;\n        vec3 nrm = normal(pos);\n        vec3 ref = reflect(rayDir, nrm);\n        vec3 mtlDiffuse = getMaterialColor(mtlID);\n        float diffuse = clamp(dot(nrm, lightDir), 0.0, 1.0);\n        float specular = pow(clamp(dot(ref, lightDir), 0.0, 1.0), SPEC_POWER);\n        diffuse *= shadow(pos, lightDir, DIST_EPSILON, MAX_SHADOW_DIST);\n        vec3 col = mtlDiffuse*(AMBIENT_COLOR + LIGHT_COLOR*(diffuse + specular*SPEC_COLOR));\n        col = applyFog(col, t);\n        resCol += col*alpha; //  blend in (a possibly reflected) new color \n        if (mtlID <= MTL_BAUBLE || abs(dot(nrm, rayDir)) < 0.1) break;\n        rayOrig = pos + ref*DIST_EPSILON;\n        alpha *= BAUBLE_REFLECTIVITY;\n        rayDir = ref;\n    }\n    return vec3(clamp(resCol, 0.0, 1.0));\n}\n\nvec3 getRayDir(vec3 camPos, vec3 viewDir, vec2 pixelPos) {\n    vec3 camRight = normalize(cross(viewDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, viewDir));\n    return normalize(pixelPos.x*camRight + pixelPos.y*camUp + CAM_FOV_FACTOR*viewDir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ang = 0.1*(40.0 + iTime);\n    vec3 camPos = vec3(CAM_DIST*cos(ang), CAM_H, CAM_DIST*sin(ang));\n    vec3 rayDir = getRayDir(camPos,normalize(LOOK_AT - camPos), p);\n    vec3 color = render(camPos, rayDir);\n    fragColor=vec4(color, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlXGRM","date":"1419639607","viewed":1870,"name":"Yet Another Christmas Tree","username":"digital_cucumber","description":"Did this as a newbie learning experience. \nWas a lot of fun, even though the result still has many annoying uglities.\nMerry Christmas and Happy New Year!","likes":24,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","christmas"],"hasliked":0,"parentid":"","parentname":""}}