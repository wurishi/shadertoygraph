{"ver":"0.1","info":{"id":"XfdfWS","date":"1733438478","viewed":39,"name":"3D Fract Wave 125","username":"kukovisuals","description":"3D julia set + waves ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","juliaset","3djuliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Convert HSB (Hue, Saturation, Brightness) to RGB\nvec3 hsb2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.z * 2.0 + vec3(0.0, 1.0, 2.0), 5.0) - 3.0) - 0.2, 0.1, 1.6);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 7.0;\nconst int MAX_ITERATIONS = 10;\nconst float BAILOUT = 4.0;\n\n// Distance estimation without beam calculations (for normal)\nfloat DE_JuliaNoBeam(vec3 pos, mat3 rotY) {\n    vec3 z = rotY * pos;\n    float dr = 1.0;\n    float r = 0.0;\n    vec3 c = vec3(\n        -sin(0.4) * 1.8,\n        -cos(iTime * 0.003) * 0.5,\n        0.0\n    );\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n        float r_power = pow(r, 8.0);\n        float r_power_7 = r_power / r;\n        float theta8 = 6.0 * acos(z.y / r);\n        float phi8 = 6.0 * atan(z.z, z.x);\n        float sinTheta = cos(phi8);\n        float cosTheta = sin(phi8);\n        float sinPhi = cos(theta8);\n        float cosPhi = sin(theta8);\n        z = r_power * vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta) + c;\n        dr = r_power_7 * 8.0 * dr + 1.0;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Distance estimation with beam calculations\nfloat DE_Julia(vec3 pos, mat3 rotY, out vec4 trap, out vec3 beamColor) {\n    vec3 z = rotY * pos;\n    float dr = 1.0;\n    float r = 0.0;\n    trap = vec4(abs(z), dot(z, z));\n    vec3 c = vec3(\n        -sin(0.4) * 1.8,\n        -cos(iTime * 0.03) * 0.5,\n        0.0\n    );\n\n    float minBeamValue = 1.0;\n    float a = 0.1 + sin(iTime * 0.05);\n    float b = 0.4 + cos(iTime * 0.01);\n    float delta = sin(iTime * 0.001) * 3.14159;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n        float r_power = pow(r, 8.0);\n        float r_power_7 = r_power / r;\n\n        float theta8 = 8.0 * acos(z.y / r);\n        float phi8 = 8.0 * atan(z.z, z.x);\n\n        float sinTheta = cos(phi8);\n        float cosTheta = sin(phi8);\n        float sinPhi = cos(theta8);\n        float cosPhi = sin(theta8);\n\n        z = r_power * vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta) + c;\n        trap = min(trap, vec4(abs(z), dot(z, z)));\n\n        float lissajousFactor = abs(sin(a * phi8 + iTime * 0.01) * cos(b * theta8 + delta) + 0.1);\n        \n\n        float fractValue = fract(dot(vec2(phi8, theta8), vec2(0.4)) + iTime * 0.03 + float(i)*30.02);\n        float beamValue = lissajousFactor + 0.03 * fractValue;\n        minBeamValue = min(minBeamValue, beamValue);\n\n        dr = r_power_7 * 8.0 * dr + 1.0;\n    }\n\n    trap.w = minBeamValue;\n    float beamIntensity = exp(-40.0 * minBeamValue) * 0.9;\n    float beamID = floor(beamIntensity * 1.0);\n    float hue = mod(beamID * 0.2, 1.0);\n    float saturation = 2.0;\n    float brightness = beamIntensity;\n    beamColor = hsb2rgb(vec3(hue, saturation, brightness));\n\n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 getNormal(vec3 p, mat3 rotY) {\n    float eps = 0.001;\n    float nx = DE_JuliaNoBeam(p + vec3(eps, -eps, -eps), rotY) - DE_JuliaNoBeam(p - vec3(eps, -eps, -eps), rotY);\n    float ny = DE_JuliaNoBeam(p + vec3(-eps, eps, -eps), rotY) - DE_JuliaNoBeam(p - vec3(-eps, eps, -eps), rotY);\n    float nz = DE_JuliaNoBeam(p + vec3(-eps, -eps, eps), rotY) - DE_JuliaNoBeam(p - vec3(-eps, -eps, eps), rotY);\n    return normalize(vec3(nx, ny, nz));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p, mat3 rotY, out vec4 trap, out vec3 beamColor) {\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        p = ro + rd * totalDist;\n        float dist = DE_Julia(p, rotY, trap, beamColor);\n        if (dist < MIN_DIST || totalDist > MAX_DIST) break;\n        totalDist += dist;\n    }\n    return totalDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 5.5));\n    float angle = iTime * 0.05;\n    mat3 rotY = mat3(\n        cos(angle), 0.0, sin(angle),\n        0.0,        1.0,        0.0,\n        -sin(angle),0.0, cos(angle)\n    );\n\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 3.7));\n    vec3 p;\n    vec4 trap;\n    vec3 beamColor;\n    float totalDist = rayMarch(ro, rd, p, rotY, trap, beamColor);\n\n    vec3 color = vec3(0.0);\n    if (totalDist < MAX_DIST) {\n        vec3 normal = getNormal(p, rotY);\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        color = vec3(0.05);\n        color = mix(color, vec3(0.702,0.667,0.671), clamp(trap.y, 0.0, 1.0));\n        color = mix(color, vec3(0.906,0.898,0.902), clamp(trap.z * trap.z, 0.0, 1.0));\n        color = mix(color, vec3(0.631,0.184,0.173), clamp(pow(trap.w, 6.0), 0.0, 1.0));\n        color *= 1.5;\n        color *= diff * 0.8 + 0.4;\n\n        vec3 glow = beamColor * 0.5;\n        color = mix(vec3(0.1), beamColor, 0.1) + glow;\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}