{"ver":"0.1","info":{"id":"4tBSzm","date":"1442811226","viewed":467,"name":"Simple tracing","username":"Neper","description":"This is a simple ray tracer. The scene has a sphere and a plane. In addition, there is a sky dome and some fog. The reflection model is also kept simple Lambert law plus Phong for specular reflection. The code is written for clarity, not for speed.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple ray tracer.\n\n// Sun\nconst vec3 SunDir \t\t= vec3(0.577, 0.577, -0.577);\nconst vec3 SunColor \t= 10.0 * vec3(1.0, 1.0, 0.8);\n\n// Sphere\nconst vec4 Sphere \t\t= vec4(0.0, 0.0, 5.0, 1.0);\nconst vec3 SphereColor \t= vec3(0.9, 0.2, 0.1);\n\n// Plane\nconst vec4 Plane \t\t= vec4(0.0, 1.0, 0.0, -1.0);\nconst vec3 PlaneColor \t= vec3(0.0, 0.0, 0.0);\n\n// Sky\nconst vec4 SkyDome \t\t= vec4(0.0, 0.0, 0.0, 1.0e5);\nconst vec3 SkyColor \t= vec3(0.05, 0.05, 0.95);\n\n// Fog in the horixon\nconst vec3 HorizonColor = vec3(0.7, 0.7, 0.9);\n\n// Ray tracing constants\nconst float VeryFar \t= 1.0e6;\nconst float VeryNear \t= 1.0e-3;\nconst int MaxBounces \t= 10;\n\n// Material - Approximates glass\nconst float R0 \t\t\t= 0.2 * 0.2;\n\n// Animation\nconst float CamR \t\t= 2.0;\n\n// Luminance factor for tone mapping\nconst vec3 Luminance \t= vec3(0.2126, 0.7152, 0.0722);\n\n// Intersection functions\nfloat plane_intersect(vec3 pos, vec3 dir, vec4 plane)\n{\n    return (plane.w - dot(pos, plane.xyz)) / dot(dir, plane.xyz);\n}\n\nfloat sphere_intersect(vec3 pos, vec3 dir, vec4 sphere)\n{\n    vec3 s \t= sphere.xyz - pos;\n    float b = dot(dir, s);\n    float D = b * b - dot(s, s) + sphere.w * sphere.w;\n    if (D < 0.0) return -1.0;\n    float t = b - sqrt(D);\n    return (t > 0.0) ? t : b + sqrt(D);\n}\n\n// Shadow ray intersection - return true or false\nbool shadow_intersect(vec3 pos, vec3 dir)\n{\n    if (sphere_intersect(pos, dir, Sphere) > 0.0) return true;\n    if (plane_intersect(pos, dir, Plane) > 0.0) return true;\n    return false;\n}\n\n// Other ray intersections - returns true or false, and in addition \n// hit position, normal, color, and whether the object is should be shaded or not\nbool any_intersect(vec3 pos, vec3 dir, \n                   out vec3 hit_pos, out vec3 hit_normal,\n                   out vec3 hit_color, out bool shaded)\n{\n    float t, t_min = VeryFar;\n    \n    for (int z = -10; z <= 10; z += 5)\n    {\n        for (int x = -10; x <= 10; x += 5)\n        {        \n            vec3 pos_s = pos + vec3(x, -1.0 + sin(float(x + z) + iTime), z);\n            t = sphere_intersect(pos_s, dir, Sphere);\n            if ((t > 0.0) && (t < t_min))\n            {\n                hit_pos \t= pos_s + t * dir;\n                hit_normal \t= normalize(hit_pos - Sphere.xyz);\n                hit_color \t= SphereColor;\n                shaded\t\t= true;\n                t_min \t\t= t;\n            }\n    \t}\n    }\n    \n    t = plane_intersect(pos, dir, Plane);\n    if ((t > 0.0) && (t < t_min))\n    {\n       \thit_pos \t= pos + t * dir;\n    \thit_normal \t= Plane.xyz;\n    \thit_color \t= PlaneColor;\n        shaded\t\t= true;\n        t_min \t\t= t;\n   \t}\n    \n            \n    t = sphere_intersect(pos, dir, SkyDome);\n    if ((t > 0.0) && (t < t_min))\n    {\n        hit_pos \t= pos + t * dir;\n        hit_normal \t= normalize(hit_pos - Sphere.xyz);\n        float f \t= hit_pos.y / SkyDome.w;\n        hit_color \t= f * SkyColor + (1.0 - f) * HorizonColor;\n        shaded \t\t= false;\t// Special handling for sky\n        t_min \t\t= t;\n    }\n    \n    \n    // TODO: Add other objects here if you want a more complicated scene\n    \n    if (t_min < VeryFar) return true;\n    \n    return false;\n}\n\n// Shading models\nfloat shadeLambert(vec3 normal, vec3 light)\n{\n    return clamp(dot(normal, light), 0.0, 1.0);\n}\n\nfloat shadePhong(vec3 normal, vec3 light, vec3 view)\n{\n    return pow(clamp(dot(reflect(view, normal), light), 0.0, 1.0), 80.0);\n}\n\nfloat shadeFog(vec3 pos)\n{\n    return clamp(0.1 * log2(length(pos)), 0.0, 1.0);\n}\n\n// Main ray tracing code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Calculate ray direction based on the screen coordinate\n    vec2 uv\t\t\t\t= -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 aspect_ratio\t= vec2(1.0, iResolution.y / iResolution.x);    \n    vec3 dir \t\t\t= normalize(vec3(uv * aspect_ratio, 1.0));       \n    \n    // Animate camera position - the position goes in a circle, but the direction stays the same\n    vec3 pos \t\t\t= vec3(CamR * cos(iTime), 0.5, CamR * sin(iTime));\n    \n    // Initialize color and ray contribution factor\n    vec3 color \t\t\t= vec3(0.0, 0.0, 0.0);\n    float factor \t\t= 1.0;\n    \n    // Initialize hit properties\n    vec3 hit_pos \t\t= vec3(0.0, 0.0, 0.0);\n    vec3 hit_normal \t= vec3(0.0, 0.0, 0.0);\n    vec3 hit_color \t\t= vec3(0.0, 0.0, 0.0);\n    bool shaded \t\t= false;\n    \n    // Bounce the ray\n    for (int k = 0; k < MaxBounces; k++)\n    {\n        // Check any intersections\n    \tif (any_intersect(pos, dir, hit_pos, hit_normal, hit_color, shaded))\n    \t{\n            // For intersection, calculate shading factors, if the object must be shaded\n            float diffuse_factor \t= shaded ? shadeLambert(hit_normal, SunDir) \t: 1.0;\n            float specular_factor \t= shaded ? shadePhong(hit_normal, SunDir, dir) \t: 0.0;\n       \t\tfloat fog_factor \t\t= shaded ? shadeFog(hit_pos) \t\t\t\t\t: 0.0;\n        \n            // To get the next ray start position, add a small offset to the hit position\n            // along the surface normal to avoid hitting the same surface again due to\n            // numerical inaccuracy\n        \tpos = hit_pos + VeryNear * hit_normal;\n        \n            // Cast a shadow ray\n       \t\tif (shaded && shadow_intersect(pos, SunDir))\n        \t{\n                // In shadow, specular reflection is zero, but use a small factor for\n                // diffuse reflection to approximate indirect (ambient) lighting\n            \tdiffuse_factor *= 0.2;\n                specular_factor = 0.0;\n        \t}\n              \n            // Calculate color based on this ray only\n            vec3 lit_color = hit_color * diffuse_factor + SunColor * specular_factor;\n        \tvec3 this_color = (1.0 - fog_factor) * lit_color + fog_factor * HorizonColor;\n        \n            // If no further rays are required, update color and exit\n            if (!shaded)\n            {\n                color += this_color * factor;\n                break;\n            }\n            \n            // Schlick's approximation to Fresnel equations\n            float R = R0 + (1.0 - R0) * pow(1.0 - clamp(dot(hit_normal, -dir), 0.0, 1.0), 5.0);\n            \n            // Add contribution of this ray to color weighted with the reflection factor\n        \tcolor += (1.0 - R) * this_color * factor;\n        \tfactor *= R;\n            \n            // Get the direction of the next ray\n        \tdir = reflect(dir, hit_normal);\n            \n            // TODO: Refracted ray - requires rearranging the tracing code\n            /*\n            vec3 pos2 = hit_pos - VeryNear * hit_normal;\n            vec3 dir2 = refract(dir, hit_normal, 1.5);\n            float T = 1.0 - R;\n            if (any_intersect(pos2, dir2, hit_pos, hit_normal, hit_color, shaded))\n            {\n                \n            }\n\t\t\t*/\n    \t}\n        else\n        {\n            // No hit - exit\n            break;\n        }\n    }\n    \n    // Simple Reinhard tonemapping and transformation to linear color space\n    vec3 tone_mapped = pow(color * 1.0 / (1.0 + dot(color, Luminance)), vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(tone_mapped, 1.0);\n}","name":"Image","description":"","type":"image"}]}