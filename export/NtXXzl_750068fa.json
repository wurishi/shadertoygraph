{"ver":"0.1","info":{"id":"NtXXzl","date":"1626268383","viewed":850,"name":"Basic ReSTIR","username":"chazbg","description":"Basic proof of concept implementation of the ReSTIR algorithm from the paper:\nSpatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting\n\nCurrently supports only spatial reservoir reuse and there's no support for MIS","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ASPECT_RATIO (iResolution.x / iResolution.y)\n\nfloat intensity(vec3 c) {\n\treturn (c.r + c.g + c.b) / 3.0;\n}\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs) {\n\treturn uvs * 2.0 - 1.0;\n}\n\nvec3 getCameraPos(float time) {\n\tmat3 rot = mat3(\n\t\tvec3(cos(time), 0.0, -sin(time)),\n\t\tvec3(0.0,       1.0,  0.0),\n\t\tvec3(sin(time), 0.0,  cos(time)));\n\treturn rot * vec3(0.0, 100.0, 1000.0);\n}\n\nvec3 getViewDirection(vec3 cameraPos) {\n\treturn normalize(vec3(0.0) - cameraPos);\n}\n\nvec3 getLightDir(float time) {\n\treturn normalize(vec3(1.0));\n}\n\nbool intersectPlane(vec3 n, vec3 p0, vec3 l0, vec3 l, out float t) { \n\t// assuming vectors are all normalized\n\tfloat denom = dot(n, l); \n\tif (denom < 0.0) {\n\t\tdenom = -denom;\n\t\tn = -n;\n\t}\n\tif (denom > 1e-6) { \n\t\tvec3 p0l0 = p0 - l0; \n\t\tt = dot(p0l0, n) / denom; \n\t\treturn (t >= 0.0); \n\t}\n\treturn false; \n} \n\nstruct Rect {\n\tvec3 center;\n\tmat3 basis;\n\tvec2 scale;\n};\n\nbool intersectRect(vec3 rayOrigin, vec3 rayDir, Rect r, out vec3 p, out vec3 n) {\n\tfloat t;\n\tif (!intersectPlane(r.basis[2], r.center, rayOrigin, rayDir, t))\n\t\treturn false;\n\t\n\tif (dot(rayDir, r.basis[2]) < 0.0) {\n\t\tn = r.basis[2];\n\t} else {\n\t\tn = -r.basis[2];\n\t}\n\tp = rayOrigin + t * rayDir;\n\tvec3 centerToIntersection = p - r.center;\n\treturn \n\t\t(abs(dot(centerToIntersection, r.basis[0])) < r.scale.x) && \n\t\t(abs(dot(centerToIntersection, r.basis[1])) < r.scale.y);\n}\n\nstruct Scene {\n\tRect ground;\n\tRect light;\n};\n\nvoid initScene(out Scene scene) {\n\tscene.ground.center = vec3(0.0, -100, 0);\n\tscene.ground.basis = mat3(\n\t\tvec3(1, 0, 0),\n\t\tvec3(0, 0, 1),\n\t\tvec3(0, 1, 0)\n\t);\n\tscene.ground.scale = vec2(1000.0, 1000.0);\n\n\tscene.light.center = vec3(0.0, 200, 0);\n\tscene.light.basis = mat3(\n\t\tvec3(1, 0, 0),\n\t\tvec3(0, 0, 1),\n\t\tvec3(0, -1, 0)\n\t);\n\tscene.light.scale = vec2(100.0, 100.0);\n}\n\nbool intersectScene(Scene scene, vec3 rayOrigin, vec3 rayDir, out vec3 p, out vec3 n, out int material) {\n\tif (intersectRect(rayOrigin, rayDir, scene.ground, p, n)) {\n\t\tmaterial = 0;\n\t\treturn true;\n\t}\n\n\tif (intersectRect(rayOrigin, rayDir, scene.light, p, n)) {\n\t\tmaterial = 1;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// return random number in [0, 1)\nfloat hashRand(vec2 co) {\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid sampleRectLight(\n\tRect r,\n\tvec3 shadowPoint,\n\tvec2 uv,\n\tout vec3 color,\n\tout vec3 lightPos,\n\tout vec3 lightDir\n) {\n\tuv = (uv - 0.5) * 2.0 * r.scale;\n\tlightPos = r.center + r.basis[0] * uv.x + r.basis[1] * uv.y;\n\tlightDir = lightPos - shadowPoint;\n\tfloat dist = length(lightDir);\n\tlightDir /= dist;\n\tcolor = vec3(300000.0) / (dist * dist);\n}\n\nstruct Reservoir {\n\tvec2 y;\n\tfloat sumw;\n\tint m;\n};\n\nvoid initReservoir(inout Reservoir r) {\n\tr.y = vec2(0.0);\n\tr.sumw = 0.0;\n\tr.m = 0;\n}\n\nvoid updateReservoir(inout Reservoir r, vec2 x, float w, int seed) {\n\tr.sumw += w;\n\tr.m++;\n\tfloat u = hashRand(gl_FragCoord.xy + vec2(0.01, 0.023) + float(seed));\n\tif (u < (w / r.sumw)) {\n\t\tr.y = x;\n\t}\n}\n\nvec4 encodeReservoir(Reservoir r) {\n\treturn vec4(r.y, r.sumw, float(r.m));\n}\n\nReservoir decodeReservoir(vec4 v) {\n\tReservoir r;\n\tr.y = v.xy;\n\tr.sumw = v.z;\n\tr.m = int(v.w);\n\treturn r;\n}\n\nvec3 unshadowedContribution(Scene scene, vec3 shadowPoint, vec3 n, vec2 uv) {\n\tvec3 lightColor, lightPos, lightDir;\n\tsampleRectLight(scene.light, shadowPoint, uv, lightColor, lightPos, lightDir);\n\tfloat NoL = max(0.0, dot(n, lightDir));\n\treturn vec3(0.5) * NoL * lightColor;\n}\n\nfloat risTarget(Scene scene, vec3 shadowPoint, vec3 n, vec2 uv) {\n\treturn intensity(unshadowedContribution(scene, shadowPoint, n, uv));\n}\n\nReservoir resampledImportanceSampling(Scene scene, vec3 shadowPoint, vec3 n, int sampleIdx) {\n\tconst int M = 4;\n\n\tReservoir r;\n\tinitReservoir(r);\n\n\tconst float risProb = 1.0; // uniform sampling\n\tfloat u = hashRand(shadowPoint.xy + vec2(0.01, 0.023) + vec2(sampleIdx));\n\tfloat v = hashRand(shadowPoint.xy + vec2(0.04, 0.056) + vec2(sampleIdx));\n\tfloat delta = 1.0 / float(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tvec2 uv = vec2(u + float(i), v + float(j)) * delta;\n\t\t\tfloat w = risTarget(scene, shadowPoint, n, uv) / risProb;\n\t\t\tupdateReservoir(r, uv, w, j * M + i);\t\n\t\t}\n\t}\n\n\treturn r;\n}\n\n#define NUM_SPATIAL_RESERVOIRS 5\nReservoir combineReservoirs(Reservoir r[NUM_SPATIAL_RESERVOIRS]) {\n\tReservoir s;\n\tinitReservoir(s);\n\n\tint m = 0;\n\tfor (int i = 0; i < NUM_SPATIAL_RESERVOIRS; i++) {\n\t\tupdateReservoir(s, r[i].y, r[i].sumw, i);\n\t\tm += r[i].m;\n\t}\n\ts.m = m;\n\n\treturn s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2  uv          = fragCoord.xy / iResolution.xy;\n\tvec2  deltaUV     = 1.0 / iResolution.xy;\n\tvec2  offset      = normalizeUVs(uv);\n\tvec3  cameraPos   = getCameraPos(0.0);\n\tvec3  cameraView  = getViewDirection(cameraPos);\n\tvec3  cameraUp    = vec3(0.0, 1.0, 0.0);\n\tvec3  cameraRight = cross(cameraView, cameraUp);\n\tfloat cameraNear  = 4.0;\n\t\n\tvec3 ray = normalize(cameraRight * offset.x * ASPECT_RATIO + cameraUp * offset.y + cameraView * cameraNear);\n\n\tif (abs(0.33 - uv.x) < 0.001 || abs(0.66 - uv.x) < 0.001 ) {\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\n\tScene scene;\n\tinitScene(scene);\n\tvec3 p, n;\n\tint material;\n    fragColor.rgb = vec3(0.0);\n\tif (intersectScene(scene, cameraPos, ray, p, n, material)) {\n\t\tif (material == 0) {\n\t\t\tif (uv.x < 0.32) {\n\t\t\t\tconst int NUM_DIRECT_LIGHT_SAMPLES = 16;\n\t\t\t\tfor (int i = 0; i < NUM_DIRECT_LIGHT_SAMPLES; i++) {\n\t\t\t\t\tfloat u = hashRand(p.xy + vec2(0.01, 0.023) + vec2(i));\n\t\t\t\t\tfloat v = hashRand(p.xy + vec2(0.04, 0.056) + vec2(i));\n\t\t\t\t\tfragColor.rgb += unshadowedContribution(scene, p, n, vec2(u, v));\n\t\t\t\t}\n\t\t\t\tfragColor.rgb /= float(NUM_DIRECT_LIGHT_SAMPLES);\n\t\t\t} else if (uv.x < 0.66) {\n\t\t\t\tReservoir r = resampledImportanceSampling(scene, p, n, 0);\n\t\t\t\tfloat weight = r.sumw / (float(r.m) * risTarget(scene, p, n, r.y));\n\t\t\t\tfragColor.rgb += unshadowedContribution(scene, p, n, r.y) * weight;\n\t\t\t} else {\n                // TODO: This spatial sampling pattern is probably incorrect but I\n                // don't think it's fully described in the paper\n\t\t\t\tReservoir spatialSamples[NUM_SPATIAL_RESERVOIRS] = Reservoir[NUM_SPATIAL_RESERVOIRS](\n\t\t\t\t\tdecodeReservoir(texture(iChannel0, uv + vec2(-2,  0) * deltaUV)),\n\t\t\t\t\tdecodeReservoir(texture(iChannel0, uv + vec2( 0, -2) * deltaUV)),\n\t\t\t\t\tdecodeReservoir(texture(iChannel0, uv + vec2( 0,  0) * deltaUV)),\n\t\t\t\t\tdecodeReservoir(texture(iChannel0, uv + vec2( 2,  0) * deltaUV)),\n\t\t\t\t\tdecodeReservoir(texture(iChannel0, uv + vec2( 0,  2) * deltaUV))\n\t\t\t\t);\n\t\t\t\tReservoir r = combineReservoirs(spatialSamples);\n\t\t\t\tfloat weight = r.sumw / (float(r.m) * risTarget(scene, p, n, r.y));\n\t\t\t\tfragColor.rgb += unshadowedContribution(scene, p, n, r.y) * weight;\n\t\t\t}\n\n\t\t\tfragColor.a = 1.0;\n\t\t} else {\n\t\t\tfragColor = vec4(1.0);\n\t\t}\t\t\n\t} else {\n\t\tfragColor = vec4(0.0, 0.0, 0.25, 1.0);\n\t}\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n#define STRATEGY 1\n\nfloat intensity(vec3 c) {\n\treturn (c.r + c.g + c.b) / 3.0;\n}\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs) {\n\treturn uvs * 2.0 - 1.0;\n}\n\nvec3 getCameraPos(float time) {\n\tmat3 rot = mat3(\n\t\tvec3(cos(time), 0.0, -sin(time)),\n\t\tvec3(0.0,       1.0,  0.0),\n\t\tvec3(sin(time), 0.0,  cos(time)));\n\treturn rot * vec3(0.0, 100.0, 1000.0);\n}\n\nvec3 getViewDirection(vec3 cameraPos) {\n\treturn normalize(vec3(0.0) - cameraPos);\n}\n\nvec3 getLightDir(float time) {\n\treturn normalize(vec3(1.0));\n}\n\nbool intersectPlane(vec3 n, vec3 p0, vec3 l0, vec3 l, out float t) { \n\t// assuming vectors are all normalized\n\tfloat denom = dot(n, l); \n\tif (denom < 0.0) {\n\t\tdenom = -denom;\n\t\tn = -n;\n\t}\n\tif (denom > 1e-6) { \n\t\tvec3 p0l0 = p0 - l0; \n\t\tt = dot(p0l0, n) / denom; \n\t\treturn (t >= 0.0); \n\t}\n\treturn false; \n} \n\nstruct Rect {\n\tvec3 center;\n\tmat3 basis;\n\tvec2 scale;\n};\n\nbool intersectRect(vec3 rayOrigin, vec3 rayDir, Rect r, out vec3 p, out vec3 n) {\n\tfloat t;\n\tif (!intersectPlane(r.basis[2], r.center, rayOrigin, rayDir, t))\n\t\treturn false;\n\t\n\tif (dot(rayDir, r.basis[2]) < 0.0) {\n\t\tn = r.basis[2];\n\t} else {\n\t\tn = -r.basis[2];\n\t}\n\tp = rayOrigin + t * rayDir;\n\tvec3 centerToIntersection = p - r.center;\n\treturn \n\t\t(abs(dot(centerToIntersection, r.basis[0])) < r.scale.x) && \n\t\t(abs(dot(centerToIntersection, r.basis[1])) < r.scale.y);\n}\n\nstruct Scene {\n\tRect ground;\n\tRect light;\n};\n\nvoid initScene(out Scene scene) {\n\tscene.ground.center = vec3(0.0, -100, 0);\n\tscene.ground.basis = mat3(\n\t\tvec3(1, 0, 0),\n\t\tvec3(0, 0, 1),\n\t\tvec3(0, 1, 0)\n\t);\n\tscene.ground.scale = vec2(1000.0, 1000.0);\n\n\tscene.light.center = vec3(0.0, 200, 0);\n\tscene.light.basis = mat3(\n\t\tvec3(1, 0, 0),\n\t\tvec3(0, 0, 1),\n\t\tvec3(0, -1, 0)\n\t);\n\tscene.light.scale = vec2(100.0, 100.0);\n}\n\nbool intersectScene(Scene scene, vec3 rayOrigin, vec3 rayDir, out vec3 p, out vec3 n, out int material) {\n\tif (intersectRect(rayOrigin, rayDir, scene.ground, p, n)) {\n\t\tmaterial = 0;\n\t\treturn true;\n\t}\n\n\tif (intersectRect(rayOrigin, rayDir, scene.light, p, n)) {\n\t\tmaterial = 1;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// return random number in [0, 1)\nfloat hashRand(vec2 co) {\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid sampleRectLight(\n\tRect r,\n\tvec3 shadowPoint,\n\tvec2 uv,\n\tout vec3 color,\n\tout vec3 lightPos,\n\tout vec3 lightDir\n) {\n\tuv = (uv - 0.5) * 2.0 * r.scale;\n\tlightPos = r.center + r.basis[0] * uv.x + r.basis[1] * uv.y;\n\tlightDir = lightPos - shadowPoint;\n\tfloat dist = length(lightDir);\n\tlightDir /= dist;\n\tcolor = vec3(300000.0) / (dist * dist);\n}\n\nstruct Reservoir {\n\tvec2 y;\n\tfloat sumw;\n\tint m;\n};\n\nvoid initReservoir(inout Reservoir r) {\n\tr.y = vec2(0.0);\n\tr.sumw = 0.0;\n\tr.m = 0;\n}\n\nvoid updateReservoir(inout Reservoir r, vec2 x, float w, int seed) {\n\tr.sumw += w;\n\tr.m++;\n\tfloat u = hashRand(gl_FragCoord.xy + vec2(0.01, 0.023) + float(seed));\n\tif (u < (w / r.sumw)) {\n\t\tr.y = x;\n\t}\n}\n\nvec4 encodeReservoir(Reservoir r) {\n\treturn vec4(r.y, r.sumw, float(r.m));\n}\n\nvec3 unshadowedContribution(Scene scene, vec3 shadowPoint, vec3 n, vec2 uv) {\n\tvec3 lightColor, lightPos, lightDir;\n\tsampleRectLight(scene.light, shadowPoint, uv, lightColor, lightPos, lightDir);\n\tfloat NoL = max(0.0, dot(n, lightDir));\n\treturn vec3(0.5) * NoL * lightColor;\n}\n\nfloat risTarget(Scene scene, vec3 shadowPoint, vec3 n, vec2 uv) {\n\treturn intensity(unshadowedContribution(scene, shadowPoint, n, uv));\n}\n\nReservoir resampledImportanceSampling(Scene scene, vec3 shadowPoint, vec3 n, int sampleIdx) {\n\tconst int M = 4;\n\n\tReservoir r;\n\tinitReservoir(r);\n\n\tconst float risProb = 1.0; // uniform sampling\n\tfloat u = hashRand(shadowPoint.xy + vec2(0.01, 0.023) + vec2(sampleIdx));\n\tfloat v = hashRand(shadowPoint.xy + vec2(0.04, 0.056) + vec2(sampleIdx));\n\tfloat delta = 1.0 / float(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tvec2 uv = vec2(u + float(i), v + float(j)) * delta;\n\t\t\tfloat w = risTarget(scene, shadowPoint, n, uv) / risProb;\n\t\t\tupdateReservoir(r, uv, w, j * M + i);\t\n\t\t}\n\t}\n\n\treturn r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2  offset      = normalizeUVs(fragCoord.xy / iResolution.xy);\n\tvec3  cameraPos   = getCameraPos(0.0);\n\tvec3  cameraView  = getViewDirection(cameraPos);\n\tvec3  cameraUp    = vec3(0.0, 1.0, 0.0);\n\tvec3  cameraRight = cross(cameraView, cameraUp);\n\tfloat cameraNear  = 4.0;\n\t\n\tvec3 ray = normalize(cameraRight * offset.x * ASPECT_RATIO + cameraUp * offset.y + cameraView * cameraNear);\n\n\tScene scene;\n\tinitScene(scene);\n\tvec3 p, n;\n\tint material;\n\tif (intersectScene(scene, cameraPos, ray, p, n, material)) {\n\t\tif (material == 0) {\n\t\t\tReservoir r = resampledImportanceSampling(scene, p, n, 0);\n\t\t\tfragColor = encodeReservoir(r);\n\t\t} else {\n\t\t\tfragColor = vec4(0.0);\n\t\t}\t\t\n\t} else {\n\t\tfragColor = vec4(0.0);\n\t}\n}\n","name":"Buffer A","description":"","type":"buffer"}]}