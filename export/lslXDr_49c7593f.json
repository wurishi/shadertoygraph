{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Written by GLtracy\n\n// math const\nconst float PI = 3.14159265359;\nconst float MAX = 10000.0;\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8pi * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\n// scatter const\nconst float R_INNER = 1.0;\nconst float R = R_INNER + 0.5;\n\nconst int NUM_OUT_SCATTER = 8;\nconst int NUM_IN_SCATTER = 80;\n\nfloat density( vec3 p, float ph ) {\n\treturn exp( -max( length( p ) - R_INNER, 0.0 ) / ph );\n}\n\nfloat optic( vec3 p, vec3 q, float ph ) {\n\tvec3 s = ( q - p ) / float( NUM_OUT_SCATTER );\n\tvec3 v = p + s * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v, ph );\n\t\tv += s;\n\t}\n\tsum *= length( s );\n\t\n\treturn sum;\n}\n\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tconst float ph_ray = 0.05;\n    const float ph_mie = 0.02;\n    \n    const vec3 k_ray = vec3( 3.8, 13.5, 33.1 );\n    const vec3 k_mie = vec3( 21.0 );\n    const float k_mie_ex = 1.1;\n    \n\tvec3 sum_ray = vec3( 0.0 );\n    vec3 sum_mie = vec3( 0.0 );\n    \n    float n_ray0 = 0.0;\n    float n_mie0 = 0.0;\n    \n\tfloat len = ( e.y - e.x ) / float( NUM_IN_SCATTER );\n    vec3 s = dir * len;\n\tvec3 v = o + dir * ( e.x + len * 0.5 );\n    \n    for ( int i = 0; i < NUM_IN_SCATTER; i++, v += s ) {   \n\t\tfloat d_ray = density( v, ph_ray ) * len;\n        float d_mie = density( v, ph_mie ) * len;\n        \n        n_ray0 += d_ray;\n        n_mie0 += d_mie;\n        \n#if 0\n        vec2 e = ray_vs_sphere( v, l, R_INNER );\n        e.x = max( e.x, 0.0 );\n        if ( e.x < e.y ) {\n           continue;\n        }\n#endif\n        \n        vec2 f = ray_vs_sphere( v, l, R );\n\t\tvec3 u = v + l * f.y;\n        \n        float n_ray1 = optic( v, u, ph_ray );\n        float n_mie1 = optic( v, u, ph_mie );\n\t\t\n        vec3 att = exp( - ( n_ray0 + n_ray1 ) * k_ray - ( n_mie0 + n_mie1 ) * k_mie * k_mie_ex );\n        \n\t\tsum_ray += d_ray * att;\n        sum_mie += d_mie * att;\n\t}\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n    vec3 scatter =\n        sum_ray * k_ray * phase_ray( cc ) +\n     \tsum_mie * k_mie * phase_mie( -0.78, c, cc );\n    \n\t\n\treturn 10.0 * scatter;\n}\n\n// angle : pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( radians( 90.0 - fov * 0.5 ) );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.0 );\n\n\t// rotate camera\n\tmat3 rot = rot3xy( vec2( 0.0, iTime * 0.5 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// sun light dir\n\tvec3 l = vec3( 0.0, 0.0, 1.0 );\n\t\t\t  \n\tvec2 e = ray_vs_sphere( eye, dir, R );\n\tif ( e.x > e.y ) {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\tvec2 f = ray_vs_sphere( eye, dir, R_INNER );\n\te.y = min( e.y, f.x );\n\n\tvec3 I = in_scatter( eye, dir, e, l );\n\t\n\tfragColor = vec4( pow( I, vec3( 1.0 / 2.2 ) ), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslXDr","date":"1399715752","viewed":27186,"name":"Atmospheric Scattering Sample","username":"gltracy","description":"sample codes of atmosphere scattering based on the article in GPU Gems2 : https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html","likes":364,"published":1,"flags":0,"usePreview":0,"tags":["scatter"],"hasliked":0,"parentid":"","parentname":""}}