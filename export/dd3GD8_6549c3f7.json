{"ver":"0.1","info":{"id":"dd3GD8","date":"1677184335","viewed":141,"name":"Castle on a hill","username":"ianertson","description":"Look around with the mouse :)","likes":14,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","raymarch","sdf","castle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 getAvg(vec2 uv) {\n    vec2 tex = 1.0 / R.xy;\n    vec3 center = getColor(uv);\n    vec3 right = getColor(uv + (vec2(1, 0)*tex));\n    vec3 left = getColor(uv + (vec2(-1, 0)*tex));\n    vec3 up = getColor(uv + (vec2(0, 1)*tex));\n    vec3 down = getColor(uv + (vec2(0, -1)*tex));\n    \n    return (center + right + left + up + down) / 5.0;\n}\n\nvec3 getBloom(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.5) * 3.;\n    vec2 dy = dFdy(uv) * (f+0.5) * 3.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return max(a+(luma(a)*0.3), max(b+(luma(b)*0.3), c+(luma(c)*0.1)));\n}\n\nvec3 getSmooth(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv) * (f+0.2) * 16.;\n    vec2 dy = dFdy(uv) * (f+0.2) * 16.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    vec3 c = getAvg(uv);\n    \n    return mix(mix(a, b, 0.5), c, 0.5);\n}\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    col = mix(col, getSmooth(uv, noiseEst), noiseEst*0.9);\n    col = mix(col, getSmooth(uv, depth*1.6), depth);\n    \n    float lm = luma(col);\n    \n    col = mix(col, getBloom(uv, lm), lm*0.5);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (var < dist) { data.id = id_; dist = var; }\n#define TEXTURE_SIGNATURE in vec2 uv, inout Material m\n#define max3(a) max(a.x, max(a.y, a.z))\n\n#define EST_NORM_FOR(TEXFUNC, UV, N, M, COMPFUNC, RADI, Z, CLR, MIX, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = RADI;\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        Z\\\n    )), MIX);\\\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.1, dot(wn, n))));\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nstruct Material {\n    float rough;\n    float spec;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            return light.c * light.s * smoothstep(\n                0.8,\n                1.0,\n                dot(normalize(light.p - p), L)\n            );\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(adot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(adot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, round(adot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nvec2 sphereUv(in vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.y = acos(p.y);\n    uv.x = atan(p.x, p.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    return uv;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nvec3 lookDir(vec2 uv, vec3 dir, vec3 ro) {\n    vec3 camForward = normalize(dir);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(float v, float mi, float ma, float k) {\n    return smax(mi, smin(ma, v, k), k);\n}\n\nfloat sabs(float a, float k) {\n    return smax(-a, a, k);\n}\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,-3.);\n    \n    float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n    speed *= 3.0;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define GROUND_LEVEL 8.0\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_WALL 2\n#define ID_TOWER 3\n#define ID_TOWER_ROOF 4\n#define ID_BRIDGE 5\n#define ID_BARREL 6\n\n\n#define DEBUG 0\n#define WALK 0\n#define AUTO_CAM 1\n\nvec3 noise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p + (seed * 256.0))/256.0, 0.0).xyz;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV \n    return n / div;\n}\n\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV \n    return n / div;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);   \n    return e + i;\n}\n\n\nfloat coneSDF(in vec3 p, in vec3 a, in vec3 b, in float t) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float l = length(pa - ba * h) - t;\n    \n    l += (cdot(p, b)/2.);\n    \n    return l;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n\n    float area = clamp(smoothstep(14., 24.0, distance(p.xz, vec2(0.0))), 0.0, 1.0);\n    float outer = clamp(smoothstep(16., 30.0, distance(p.xz, vec2(0.0))), 0.0, 1.0);\n    \n    float h = 0.0;\n    \n    h -= max(0.0, area - outer)*10.;\n    \n    vec3 lf = noise6(p.xz, 0.39281, 0.06);\n    vec3 hf = noise6(p.xz, 1.11333, 0.9);\n    \n    h += lf.x*8. * outer;\n    \n    h += lf.y*0.004*max(0.0, 1.0-area);\n    h += hf.x*2.*smoothstep(6.0, 24.0, distance(p.xz, vec2(0.0)))*max(0.2, 1.0-area);\n    \n    float amp = abs(h);//max(max3(lf), max3(hf));\n    \n    float d = p.y - h;\n    \n    return d / 2.2;\n}\n\nfloat castleSDF(in vec3 p, inout int id) {\n    float dist = FAR;\n    \n    float w = 6.0;\n    float h = 3.0;\n    float towerR = w / 2.;\n    float wall = boxSDF(p - vec3(0, 3.0, 0), vec3(w, h, w));\n    float inside = boxSDF(p - vec3(0, 3.1, 0), vec3(w*0.9, h, w*0.9));\n    wall = max(wall, -inside);\n    \n    float entranceH = h / 2.5;\n    float entranceW = w / 5.0;\n    float entrance = boxSDF(p - vec3(0.0, entranceH+0.1, -w), vec3(entranceW, entranceH, 1.));\n    wall = max(wall, -entrance);\n    \n    float upperLevel = boxSDF(p - vec3(0, 3.5, 0), vec3(w*0.9, h/6., w*0.9));\n    float upperMiddle = boxSDF(p - vec3(0, 3.5, 0), vec3(w*0.9*0.5, h/5.6, w*0.9*0.5));\n    upperLevel = max(upperLevel, -upperMiddle);\n    \n    float towerHeight = h*3.;\n    float tower = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-(w+(towerR/2.))), 0., w+(towerR/2.)), vec3(0, 0, 0), vec3(0, towerHeight, 0), towerR);\n    float shr = 0.79;\n    float towerInside = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-(w+((towerR*shr)/2.))), 0., w+((towerR*shr)/2.)), vec3(0, 0, 0), vec3(0, towerHeight*shr, 0), towerR*shr);\n\n    tower = max(tower, -towerInside);\n    \n    float towerRoof = coneSDF(\n        vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-(w+(towerR/2.))), towerHeight, w+(towerR/2.)),\n        vec3(0, 0, 0),\n        vec3(0, 2, 0),\n        towerR*1.1\n    );\n    \n    towerRoof = max(towerRoof, -towerInside);\n    \n    float window = boxSDF(\n        vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-(w+(towerR/2.))), towerHeight-3., w+(towerR+1.4)),\n        vec3(0.5, 0.5, 1.0)\n    );\n    \n    tower = max(tower, -window);\n    \n    \n    if (wall < dist) { dist = wall; id = ID_WALL; }\n    if (tower < dist) { dist = tower; id = ID_TOWER; }\n    if (towerRoof < dist) { dist = towerRoof; id = ID_TOWER_ROOF; }\n    if (upperLevel < dist) { dist = upperLevel; id = ID_WALL; }\n    \n    return dist;;\n}\n\nfloat bridgeSDF(in vec3 p) {\n    float dist = FAR;\n    float w = 6.0 / 5.0;\n    float len = 8.0;\n    float h = 0.5;\n    float taper = max(0.0, -p.z)/10.;//1.0-max(0.0, 0.5+(0.5*sin(p.z/(len/3.))));\n    float y = 1.0;\n    \n  //  y *= smoothstep(0., 200.0, max(0.0, p.z+15.));\n    float down = smoothstep(0.0, 6., max(0.0, p.z+15.));\n\n    y -= down;\n    taper -= down;\n    //max(0.5, 1.0 - float((p.z+15.) > 0.0));\n    \n    float walk = boxSDF(p - vec3(0,  ((0.0 + (taper/2.))*y)-1.19, -(12.+len)), vec3(w, (h+(taper*max(0.0, -p.z*0.04)))-max(0.0, -(((p.y-0.1)*10.))), len));\n    dist = walk;\n    return dist;\n}\n\nfloat barrelSDF(in vec3 p) {\n    float taper = smoothstep(0.0, 2.0, max(0.0, p.y)+(2.0*max(0.0, -p.y+0.3)));\n    float d = cylSDF(p, vec3(0, 0, 0), vec3(0, 0.5, 0), 0.2*max(0.001, 1.0-taper));\n    \n    vec3 a = vec3(0.0, 0.4, 0.0);\n    vec3 b = vec3(0.0, 0.5, 0.0);\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float l = length(pa - ba * h)-0.13;\n    \n    d = smax(d, -l, 0.03);\n    \n    \n    return d-0.005;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    p.y -= GROUND_LEVEL;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    int castleId = 0;\n    float castle = castleSDF(p, castleId);\n    float bridge = bridgeSDF(p);\n    float barrel1 = barrelSDF(p - vec3(2.5, 0, -7.));\n    float barrel2 = barrelSDF(p - vec3(3.1, 0, -7.5));\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(castle, castleId);\n    SAMPLE(bridge, ID_BRIDGE);\n    SAMPLE(barrel1, ID_BARREL);\n    SAMPLE(barrel2, ID_BARREL);\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = dist;\n    \n    float f = data.id == ID_GROUND ? (\n        mix(0.001, 0.16, smoothstep(4.0, 16.0, distance(p.xz, vec2(0.0))))\n    ) : 0.001;\n    \n    \n    \n    vec2 e = vec2(f, 0.0);\n    \n    data.n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    \n    data.uv = boxUv(data.p, data.n);\n    \n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= min(near, FAR)) return 1.0;\n    }\n    \n    return clamp(abs(dist) / (0.09+abs(near)), 0.0, 0.78);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    vec2 uv = rd.xz / rd.y;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    col = mix(vec3(0.2, 0.59, 0.9), pow(vec3(0.2, 0.59, 0.9), vec3(3.0)), clamp(dotup*1.6, 0.0, 1.0));\n    \n    float time = T * 0.1;\n    \n    vec3 reg = noise6(uv + vec2(sin(time), cos(time)), 0.029831, 0.6);\n    \n    \n    vec2 shift = vec2(cos(time + (0.8*pow(reg.x, 2.0))), sin(time + (0.8*pow(reg.z, 2.0))));\n    \n    vec3 lf = noise6(uv + (shift*3.), 0.98721, 1.);\n    \n    shift += vec2(cos((lf.x*6.) - (time*0.2)), sin(lf.y*6.))*0.01;\n    \n    vec3 hf = noise6(uv - (shift*0.5), 1.11123, 16.0);\n    \n    shift += (0.5 - hf.xy) * 2.;\n    \n    vec3 mixer = noise6(uv + (0.5 - shift), 0.182719, 0.5);\n    \n    \n    float clouds = mix(lf.x, hf.x, mixer.x);\n    clouds = mix(clouds, reg.y, mixer.z * (0.5+(0.5*cos(time*3.))));\n    \n    clouds = pow(clouds, 2.0);\n    clouds = mix(clouds, 0.0, clamp(pow(reg.y, 2.5)*2., 0.0, 1.0));\n    \n    col += clouds;\n    \n    col += (light.c * light.s * pow(VdotL, 16.0)) / 2.;\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE plankTexture\n\nvec3 plankTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(151, 134, 110);\n    vec3 c2 = rgb(129, 97, 74);\n    vec3 c3 = rgb(114, 87, 60);\n    vec3 c4 = rgb(35, 25, 16);\n    \n    vec3 hf = noise6(uv, 1.298112, 40.0);\n    vec3 lf = noise6(uv, 0.349185, 5.0);\n    vec3 r = abs(reflect(hf, lf));\n    \n    col += c1 * hf.x;\n    col += c2 * hf.y;\n    col += c3 * hf.z;\n    col /= 3.0;\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    \n    float t = 0.05 + (hf.x*0.03+hf.y*0.03);\n    float g1 = max(0.0, 1.0 - ceil((lv.y)-t));\n    float g2 = max(0.0, 1.0 - ceil((1.0-lv.y)-t));\n    \n    float gg = max(0.0, 1.0 - ceil((lv.y)-0.04));\n    \n    float g = max(g1, g2);\n    g *= (hf.x+lf.z)/1.2;\n    \n    col = mix(col, (c4*(0.1+c4))+(pow(hf.x, 2.0)/8.), g);\n    col = mix(col, c4*c4, clamp(gg*hf.y*1.6, 0.0, 1.0));\n    \n    float stripes = (sin((TAU-cos(2.*uv.y*(TAU-sin(uv.x*(TAU-tan((uv.x-uv.y)*0.5))))))*TAU*((uv.x+uv.y)*2.)) * 0.5) + 0.5;\n    stripes *= max(0.0, 1.0 - (gg+g*2.));\n    col = mix(col, c4, stripes*clamp((r.y+r.z+r.x)/2.2, hf.x, 1.0));\n    \n    m.spec = clamp(stripes + g, 0.0, 1.0);\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 brickTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    \n    vec3 hf = noise6(uv, 3.281139, 32.0);\n    vec3 lf = noise6(uv, 2.000123, 5.0);\n    vec3 tf = noise6(id, 0.029181, 16.);\n    \n    vec3 c1 = rgb(142, 91, 67);\n    vec3 c2 = rgb(71, 41, 42);\n    vec3 c3 = rgb(107, 59, 48);\n    \n    vec3 c4 = rgb(156, 146, 125); // grid\n   \n    float t = max(hf.x*0.3*hf.y, 0.04 + (0.5 - (lf.x+lf.y)/2.));\n    float g = max(0.0, 1.0 - ceil(min(lv.x + hf.y*0.04, lv.y+hf.x*0.04)-t));\n    float g2 = max(0.0, 1.0 - round(min(lv.x + hf.y*0.04, lv.y+hf.x*0.04)+t*6.));\n    \n   \n    g *= clamp(2.0*((pow(lf.y, 4.0)+pow(hf.x, 4.0))), 0.0, 1.0);\n    g = max(0.0, g - hf.z*0.2);\n    \n    g2 *= clamp(2.0*((pow(lf.z, 4.0)+pow(hf.y, 4.0))), 0.0, 1.0);\n    g2 = max(0.0, g2 - hf.x*0.2);\n    \n    col += c4*(g2*(tf.x+lf.x))/2.;\n    \n    col += (c1*c1) * tf.x;\n    col += (c2*c2) * tf.y;\n    col += (c3*c3) * tf.z;\n    \n    col += c4 * g;\n    \n    col += c1 * hf.x*hf.y*hf.z;\n    col += (c2*c2) * lf.y;\n    col += (c3*c3) * lf.z;\n    \n    col *= (hf.x+hf.y+hf.z+lf.y)/3.5;\n    \n    vec3 grit = textureLod(iChannel3, uv*5., 0.0).rgb;\n    \n    float gritf = pow(grit.x, 4.0);\n    col += (c1 * gritf) * max(0.0, 1.0 -(lf.z*0.6));\n    \n    m.spec = (gritf+g2+g)/2.;\n    \n    return col;\n}\n\nvec3 cobbleTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    \n    vec3 hf = noise6(uv, 1.92815, 32.0);\n    vec3 lf = noise6(uv, 0.11122, 5.0);\n    \n    vec3 c1 = rgb(145, 142, 132);\n    vec3 c2 = rgb(171, 167, 162);\n    vec3 c3 = rgb(91, 91, 91);\n    vec3 c4 = rgb(28, 28, 30);\n    \n    col += c1 * hf.x;\n    col += c2 * hf.y;\n    col = mix(col, c3, hf.z);\n    \n    float cracks1 = abs(lf.y - lf.z);\n    cracks1 = smoothstep(0.05, 0.002, cracks1);\n    \n    float t = 0.04*0.9+(0.2*((cracks1-hf.y*0.3)+hf.z*0.6));\n    float g = max(0.0, 1.0 - ceil(min(lv.x+0.01, lv.y)-t));\n    g *= (pow(hf.z, 3.0) * (0.5 + (pow(lf.z, 3.)*0.5)));\n\n    \n    float cracks2 = abs(lf.x - lf.y);\n    cracks2 = smoothstep(0.05, 0.002, cracks2);\n    \n    \n    col = mix(col, c4, cracks2);\n    col = mix(col, c4, clamp(g*6., 0.0, 1.0));\n    \n    lv = lv * 2.0 - 1.0;\n    \n    col += max(0.0, 1.0-length(lv-(g+cracks2*2.)))*((hf.y+lf.y)/2.);\n    \n    col += pow(abs(cracks1 - cracks2), 8.0) * hf.z;\n    \n    return col;\n}\n\nvec3 grassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n\n    vec3 vary = noise6(uv, 2.2928152, 0.5);\n\n\n    vec3 regions = noise6(uv, 0.39881, 8.0);\n    vec3 alt = noise6(uv, 1.0092813, 32.0);\n    vec3 alt2 = noise(uv, 0.9827156, 32.0);\n    vec3 alt3 = abs(cross(alt, alt2));\n    \n    float grassReg = regions.x;\n    float rockReg = regions.y;\n    \n    grassReg = pow(grassReg, 2.0);\n    rockReg = pow(rockReg, 2.0);\n    \n    rockReg *= max(0.0, 1.0 - (grassReg*0.7));\n    \n    rockReg = mix(rockReg, vary.y, 0.49);\n    \n    float isect = abs(grassReg - rockReg);\n    \n    isect = max(0.0, 0.3-smoothstep(0.09, 0.3, isect));\n    \n    \n    vec3 grass1 = rgb(100, 89, 36);\n    vec3 grass2 = rgb(95, 91, 31);\n    vec3 grass3 = rgb(105, 104, 47);\n    \n    vec3 grassCol = (grass1 * alt2.x) + (grass2 * alt2.y) + (grass3 * alt2.x);\n    \n    vec3 rock1 = rgb(140, 125, 103);\n    vec3 rock2 = rgb(176, 170, 176);\n    vec3 rock3 = rgb(113, 105, 100);\n    \n    vec3 rockCol = (rock1 * alt3.x) + (rock2 * alt.y) + (rock3 * alt3.z);\n    \n    col = mix(col, grassCol, grassReg);\n    col = mix(col, rockCol, rockReg);\n    \n    vec3 muddy = rgb(85, 67, 26);\n    \n    col = mix(col, muddy*muddy, 0.5*clamp((isect*3.)*((alt.x+alt2.y)/2.), 0.0, 1.0));\n    \n    m.spec = max(alt.x*((alt2.y*grassReg)/1.3), (pow(rockReg,6.0))*10.);\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.p.xz;//data.uv;\n    vec3 col = vec3(0.0);\n    \n    col = grassTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(grassTexture, uv, data.n, data.m, luma, 0.02, 0.5, col, 0.9, bump)\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoWall(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n    \n    uv *= 0.8;\n    col = cobbleTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(cobbleTexture, uv, data.n, data.m, luma, 0.02, 0.5, col, 0.9, bump)\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoTower(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n    \n    uv *= 0.8;\n    col = cobbleTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(cobbleTexture, uv, data.n, data.m, luma, 0.02, 0.5, col, 0.9, bump)\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoTowerRoof(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n    \n    col = brickTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(brickTexture, uv, data.n, data.m, luma, 0.02, 0.5, col, 0.9, bump);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBridge(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n    \n    col = plankTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(plankTexture, uv, data.n, data.m, luma, 0.02, 0.5, col, 0.9, bump);\n    data.n = bump;\n    \n    return col;\n}\n\n\nvec3 getAlbedoBarrel(inout Data data) {\n    vec2 uv = data.uv*4.;\n    uv = sphereUv(data.n);\n    uv = vec2(uv.y, uv.x);\n    vec3 col = vec3(0.0);\n    \n    uv = mix(uv, data.uv*4., pow(adot(data.n, vec3(0, 1, 0)), 16.0));\n    \n    col = plankTexture(uv, data.m);\n    \n    vec3 bump = vec3(0.0);\n    EST_NORM_FOR(plankTexture, uv, data.n, data.m, luma, 0.03, 0.5, col, 1.0, bump);\n    data.n = bump;\n    data.m.spec *= 0.3;\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_WALL: return getAlbedoWall(data); break;\n        case ID_TOWER: return getAlbedoTower(data); break;\n        case ID_TOWER_ROOF: return getAlbedoTowerRoof(data); break;\n        case ID_BRIDGE: return getAlbedoBridge(data); break;\n        case ID_BARREL: return getAlbedoBarrel(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    \n    vec3 att = getLightAtt(light, p, n);\n    \n    float shadow = getShadow(p + (n*NEAR*2.0), L, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p));\n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 2\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float dist) {\n    vec3 col = vec3(0.0);\n    dist = FAR;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.66), 0.5, LIGHT_AMBIENT);\n    lights[1] = Light(vec3(0, GROUND_LEVEL+4., 0), vec3(0.0), vec3(0.98, 0.49, 0.25), 16.0, LIGHT_POINT);\n    \n    \n    if (march(data, ro, rd)) {\n        dist = data.d;\n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd);\n        }\n    } else {\n        col += getSky(ro, rd, lights[0]);\n    }\n    \n    float depth = dist / FAR;\n    \n    col += (smoothstep(0.2, 1.0, depth) * max(0.0, 1.0 - (dotup*2.)))/1.3;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 4., -23.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n   \n\n\n    \n    #if WALK\n    vec3 walk = texture(iChannel0, vec2(0.0)).xyz;\n    ro += walk;\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    \n    #if DEBUG\n    ro = vec3(8, 4, -20);\n    rd = look(uv, vec3(0, 1., -20.), ro);\n    #else\n    \n    if ((abs(m.x) > 0.0001 || abs(m.y) > 0.0001) && m.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float time = T*0.5;\n        //ro.yz *= rot(T);\n        ro.xz *= rot(time);\n\n       // rd.yz *= rot(T);\n        rd.xz *= rot(time);\n    }\n    \n    #endif\n    #endif\n\n    ro.y = max(4., ro.y);\n    \n    ro.y += GROUND_LEVEL;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float dist = FAR;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ma);\n    #else\n    col += render(data, ro, rd, dist);\n    col += (col*col*luma(col));\n    #endif\n    \n    \n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, dist / FAR);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}