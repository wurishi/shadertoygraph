{"ver":"0.1","info":{"id":"Wdlfz7","date":"1587945716","viewed":210,"name":"16K Sorting network","username":"rory618","description":"Pipelined sorting of 16k items in a list stored in the cubemap","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sort","pipeline","bitonic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    vec3 rayDir;\n    if(iMouse.z>0.){\n        float size = 1024./R.x/2.;\n        I += iMouse.xy*4.;\n        ivec3 XYFace = ivec3(I.y*size, mod(I.x*size,1024.),I.x*size/1024.);\n        rayDir = XYFaceToRayDir(XYFace);\n        if(XYFace.x >= 1024)\n            rayDir=vec3(0);\n        if(XYFace.y >= 1024)\n            rayDir=vec3(0);\n    } else {\n        float size = max(1024./R.y,(105.*16.)/R.x);\n        ivec3 XYFace = ivec3(I.y*size, mod(I.x*size,1024.),I.x*size/1024.);\n        rayDir = XYFaceToRayDir(XYFace);\n    }\n    \n    if(rayDir==vec3(0)){\n        O = vec4(0);\n    } else {\n    \tO = texture(iChannel0, rayDir);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"vec4 sampleXYTall(ivec2 XYTall){\n    ivec3 XYFace = ivec3(XYTall.x, XYTall.y%1024, XYTall.y/1024);\n    return texture(iChannel0, XYFaceToRayDir(XYFace));\n}\nvec4 sampleIDStage(int ID, int stage){\n    ivec2 XYTall = ivec2(ID/16, ID%16+stage*16);\n    return sampleXYTall(XYTall);\n}\n\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return x ^ (int(b)-1);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        return x ^ int(b/2.);\n    }\n}\n\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);\n    if(XYTall.y < 16){\n        int seed = XYFace.x + XYFace.y*16 + iFrame*1024*16;\n        seed = IHash(seed);\n        O.x = Hash(seed);\n    } else  {\n        int stage = XYTall.y/16;\n        int sortStage = stage-1;\n        int ID = XYTall.x*16 + (XYTall.y%16);\n        if(stage<106){\n            int partner = getPartner(ID,sortStage);\n            vec4 A = sampleIDStage(ID, stage-1);\n            vec4 B = sampleIDStage(partner, stage-1);\n            if(ID > partner){\n                if(A.x>B.x){\n                    O=A;\n                } else {\n                    O=B;\n                }\n            } else {\n                if(A.x>B.x){\n                    O=B;\n                } else {\n                    O=A;\n                }\n            }\n        } else if(stage<110){\n            //Keep shifting the result down so that JFA pipeline always can find the particles\n            O = sampleIDStage(ID, stage-1);\n        } else {\n            //Detect glitches\n            O = vec4(0);\n            vec4 A = sampleIDStage(ID-1, stage-1);\n            vec4 B = sampleIDStage(ID, stage-1);\n            vec4 C = sampleIDStage(ID+1, stage-1);\n            if(A.x>B.x || B.x>C.x){\n                O += 1.;\n            }\n            \n        }\n        \n    }\n    \n    \n}\n    \n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define R iResolution\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\nvec3 NetXYToRayDir(vec2 p){\n    vec2 major = floor(p/1024.);\n    vec2 minor = 1024.-mod(p,vec2(1024.));\n    \n    int face=-1;\n    if(major==vec2(0,1)){         face = 0;    \n    } else if(major==vec2(1,1)){  face = 2;    \n    } else if(major==vec2(2,1)){  face = 3;    \n    } else if(major==vec2(3,1)){  face = 5;    \n    } else if(major==vec2(1,0)){  face = 4;    \n    } else if(major==vec2(1,2)){  face = 1;\n    }\n    vec2 xy = minor - .5;\n    return XYFaceToRayDir(ivec3(xy,face));\n}\nvec2 RayDirToNetXY(vec3 rayDir){\n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    if(XYFace.z==0){         return 1024.-vec2(XYFace.xy) + vec2(0,1)*1024.;\n    } else if(XYFace.z==1){  return 1024.-vec2(XYFace.xy) + vec2(1,2)*1024.;\n    } else if(XYFace.z==2){  return 1024.-vec2(XYFace.xy) + vec2(1,1)*1024.;\n    } else if(XYFace.z==3){  return 1024.-vec2(XYFace.xy) + vec2(2,1)*1024.;\n    } else if(XYFace.z==4){  return 1024.-vec2(XYFace.xy) + vec2(1,0)*1024.;\n    } else if(XYFace.z==5){  return 1024.-vec2(XYFace.xy) + vec2(3,1)*1024.;\n    } else return vec2(0);\n}","name":"Common","description":"","type":"common"}]}