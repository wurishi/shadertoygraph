{"ver":"0.1","info":{"id":"XtXcDr","date":"1504312626","viewed":113,"name":"Quadratic Xpolation","username":"casty","description":"Use the mouse to move the middle point. The method only works for equidistant points bc that's what I needed for my job.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["function","plot","polynomialinterpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Eduardo Castineyra - casty/2015\n// Creative Commons Attribution 4.0 International License\n\n#define DISP_SCALE 10.0 \n//Grid from  Flyguy: https://www.shadertoy.com/view/4tB3WV\nfloat grid(vec2 p){\n\tvec2 uv = mod(p,1.0);\n\t\n\tfloat halfScale = .5;\n\t\n\tfloat gridRad = (1.0 / iResolution.y) * DISP_SCALE;\n\tfloat grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\treturn smoothstep(0.0, gridRad, grid);\n\t}\n\nfloat p1, p2, p3;\n\nvec2 interp(float t){  ///This method only works if the 3 points are in X = -1, 0, 1 respectively!!\n    float Y1 = p1 - p2;\n    float Y3 = p3 - p2;\n    float a0 = p2;\n    float a2 = (Y3 + Y1)/2.0;\n    float a1 = Y3 - a2;\n    float fx = a0 + a1 * t + a2 * t * t;\n    float dx = a1 + 2.0 * a2 * t;\n    return vec2(fx,dx);\n\t}\n\nvec2 sdf(vec2 p){\n    float doy = 0.0;\n\tvec2 vx = interp(p.x);\n    vec2 v1 = interp(1.0);    \n    vx.y = p3 + v1.y * (p.x - 1.0);\n    \n    vec2 d = vec2(dFdx(vec2(vx.xy))) * iResolution.y / DISP_SCALE;\n    return abs(vx - p.y) / sqrt(1.+d*d);\n\t}\n\nvec4 printf(vec2 uv){\n    vec2 s = sdf(uv);\n    return step(s.x, 0.05) * vec4(1,0,0,1) + step(s.y, 0.05) * vec4(0,1,0,1);\n\t}\n\nvoid move(inout float p){\n    p = iMouse.y / iResolution.y * DISP_SCALE - DISP_SCALE * .5;\n\t}\n\nvec4 printP(vec2 uv, vec2 p){\n    return step(length(uv-p),.1) * vec4(0,0,0,1);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    p1 = 1.0; p2 = 0.0; p3 = 0.0;    \n    move(p2);\n    \n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= DISP_SCALE;\n    \n    vec4 col = vec4( vec3(grid(uv) * 0.25 + 0.75), 1.0 );\n    vec4 v = printf(uv);\n    vec4 ps = printP(uv,vec2(-1,p1)) + printP(uv,vec2(0,p2)) + printP(uv,vec2(1,p3));\n    col = mix(col, v, v.a);\n    fragColor = mix(col, ps, ps.a);\n\t}\n\n\n","name":"Image","description":"","type":"image"}]}