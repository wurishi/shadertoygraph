{"ver":"0.1","info":{"id":"Nt3fWS","date":"1665883991","viewed":94,"name":"ray marching moment","username":"Verlio_H","description":"a little bit of ray marching","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define EMISSIVE 1\n#define REFLECTIVE 2\n\nstruct object {\n    int type;\n    vec3 pos;\n    float r;\n    vec3 albedo;\n    int properties;\n    float fuzz;\n};\n\n#define NUM_OBJ 5\n\nconst object[NUM_OBJ] tbl = object[](\n    object(0, vec3(0), 0., vec3(0.77, 0.87, 1), 0, 0.),\n    object(2, vec3(0, 0.01, 2), .5, vec3(0.7, 0.3, 0.3), 0, 0.),\n    object(2, vec3(-1.01, 0.01, 2), .5, vec3(0.8), REFLECTIVE, 0.01),\n    object(2, vec3(1.01, 0.01, 2), .5, vec3(0.8, 0.6, 0.2), REFLECTIVE, 1.),\n    object(1, vec3(0, -.5, 0), 0., vec3(0.8, 0.8, 0.), 0, 0.)\n);\n\n\n#define MAX_ITER 128\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define MAX_REFLECT 5\n#define PI 3.1415926535897932384626433832795\n#define APERTURE 0.05\n#define FOCUS 2.\n\nvec2 seed;\n\nfloat random () {\n    seed += vec2(iTime);\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt= dot(seed.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nvec3 random_in_unit_sphere() {\n    vec3 result;\n    result.x = random()*2.-1.;\n    result.y = random()*2.-1.;\n    result.z = random()*2.-1.;\n    while (length(result) > 1.) {\n        result.x = random()*2.-1.;\n        result.y = random()*2.-1.;\n        result.z = random()*2.-1.;\n    }\n    return result;\n}\n\nvec2 random_in_unit_disk() {\n    vec2 result;\n    result.x = random()*2.-1.;\n    result.y = random()*2.-1.;\n    while (length(result) > 1.) {\n        result.x = random()*2.-1.;\n        result.y = random()*2.-1.;\n    }\n    return result;\n}\n\nfloat GetDist(vec3 p, out int o) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    float dist, dist2;\n    dist = 100000000.0;\n    for (int i = 0; i < NUM_OBJ; ++i) {\n        object thing = tbl[i];\n        if (thing.type == 1) {\n            dist2 = p.y - thing.pos.y;\n        } else if (thing.type == 2) {\n            dist2 = length(p-thing.pos) - thing.r;\n        } else {\n            dist2 = 100000000.0;\n        }\n        if (dist2 < dist) {\n            dist = dist2;\n            o = i;\n        }\n    }\n    return dist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out int o) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_ITER; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, o);\n        dO += dS;\n        if(dS<SURF_DIST) break;\n        if(dO>MAX_DIST) {\n            o = 0;\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    int o;\n\tfloat d = GetDist(p, o);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, o),\n        GetDist(p-e.yxy, o),\n        GetDist(p-e.yyx, o));\n    \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p, int o, vec3 dir) {\n    int refCnt = 0;\n    vec3 colMlt = vec3(1.);\n    while (refCnt < MAX_REFLECT) {\n        object obj = tbl[o];\n        if (obj.type == 0) {\n            return obj.albedo*colMlt;\n        } else if ((obj.properties & EMISSIVE) != 0) {\n            return obj.albedo*colMlt;\n        }\n        ++refCnt;\n        vec3 norm = GetNormal(p);\n        p += norm * 2. * SURF_DIST;\n        if ((obj.properties & REFLECTIVE) != 0) {\n            norm = normalize(reflect(dir, norm) + random_in_unit_sphere() * obj.fuzz);\n        } else {\n            norm = normalize(norm + random_in_unit_sphere());\n        }\n        colMlt *= obj.albedo;\n        dir = norm;\n        p += norm * RayMarch(p, norm, o);\n        \n    }\n    return colMlt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n        vec3 prevFrame = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0).rgb;\n        seed = fragCoord.xy / iResolution.xy;\n        fragCoord.x += random()-.5;\n        fragCoord.y += random()-.5;\n        vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n        vec3 ro = vec3(0, 0, 0);\n        vec2 offset = APERTURE*random_in_unit_disk();\n        vec3 dpos = vec3(uv.xy*FOCUS+ro.xy, FOCUS+ro.z);\n        ro.xy += offset;\n        vec3 rd = normalize(dpos - ro);\n        int o;\n        \n        float d = RayMarch(ro, rd, o);\n    \n        vec3 p = ro + rd * d;\n        \n\n        col = GetLight(p, o, rd);\n        float mixture = clamp(1./float(iFrame/2), 0.01, 1.);\n        col = mix(prevFrame, col, mixture);\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}