{"ver":"0.1","info":{"id":"XtlcRM","date":"1504049855","viewed":331,"name":"Antialiased simple arrow","username":"etale_cohomology","description":"The simplest way I can think of for drawing an arrow / vector: join a line segment and a triangle...\n\nStill, this can't be the \"right\" way: the arrow looks crappy when SCALE is too big...!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","tutorial","antialias","vector","arrow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// An arrow is given by a position vector (its base), an angle (its direction), and a positive number (its norm).\n// If the arrow has norm 0, it degenerates to a point, which has undefined direction!\n\n#define ARROW_STEM_THICKNESS .01\n#define ARROW_STEM_ANTIALIAS 6.\n\n#define ARROW_HEAD_WIDTH     .08\n#define ARROW_HEAD_HEIGHT    .16\n#define ARROW_HEAD_ANTIALIAS 64.\n\n#define SCALE 2.  // Arrow looks crappy when SCALE is too big...!\n\n// ------------------------------------------------------------------------------------------------\n// Compute the vector projection scalar of vec_a to vec_b!\nfloat vector_projection_scalar(vec2 vec_a, vec2 vec_b){\n    return dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\nfloat df_line_segment(vec2 vec_p, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ap = vec_p - vec_a;  // Displacement vector from vec_a to vec_p\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 vproj_ap_ab = dvec_ab * clamp(vector_projection_scalar(dvec_ap, dvec_ab), .0, 1.);  // Vector projection from ap to ab\n    return distance(dvec_ap, vproj_ap_ab) - ARROW_STEM_THICKNESS;  // Distance field! This is IT!\n}\n\n// ------------------------------------------------------------------------------------------------\nfloat sdf_triangle(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement-vector\n    vec2 dvec_ac = vec_c - vec_a;  // Displacement-vector\n    vec2 dvec_ap = vec_p - vec_a;  // Displacement-vector\n\n    float det_dvec_ab_dvec_ac = dvec_ab.x * dvec_ac.y - dvec_ac.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ac\n\tfloat det_dvec_ap_dvec_ac = dvec_ap.x * dvec_ac.y - dvec_ac.x * dvec_ap.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ap and dvec_ac\n    float det_dvec_ab_dvec_ap = dvec_ab.x * dvec_ap.y - dvec_ap.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ap\n    float inv_det_dvec_ab_dvec_ac = 1. / det_dvec_ab_dvec_ac;  // Multiplicative-inverse of a determinant\n\n    float bary_x = det_dvec_ap_dvec_ac * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_y = det_dvec_ab_dvec_ap * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_z = 1. - bary_x - bary_y;  // The last barycentric coordinate is easy!\n\n    return min(min(bary_x, bary_y), bary_z);\n}\n\n\n// ------------------------------------------------------------------------------------------------\n// An arrow is given by a position vector (its base), an angle (its direction), and a positive number (its norm)\nstruct Arrow{\n    vec2  base;  // Position vector!\n    float dir;   // Angle!\n    float norm;  // Positive number!\n};\n\n// We draw the arrow in LOCAL coordinates!\n// If the arrow has norm 0, it degenerates to a point, which has undefined direction!\nfloat draw_arrow(vec2 uv, Arrow arrow){\n\tvec2  base = arrow.base;\n    float dir  = arrow.dir;\n    float norm = arrow.norm;\n    \n    uv = mat2(cos(dir), -sin(dir), sin(dir), cos(dir)) * uv;  // Rotate local coordinates by complex left-multiplication\n\n    float stem_len = max(.0, norm - ARROW_HEAD_HEIGHT);\n    float stem = df_line_segment(uv, base, base + vec2(stem_len, .0));\n\n    vec2  head_a = base + vec2(norm, .0);\n    vec2  head_b = base + vec2(stem_len, .0 + ARROW_HEAD_WIDTH);\n    vec2  head_c = base + vec2(stem_len, .0 - ARROW_HEAD_WIDTH);\n    float head   = sdf_triangle(uv, head_a, head_b, head_c);\n\n    stem = smoothstep(ARROW_STEM_ANTIALIAS / iResolution.y, .0, stem);\n    head = smoothstep(0., ARROW_HEAD_ANTIALIAS / iResolution.y, head);\n\n    return max(stem, head);\n}\n\n// ------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    Arrow arrow;\n    arrow.base = vec2(2.*cos(iTime), .5*sin(4.*iTime));  // A simple parametric path!\n    arrow.dir  = iTime;\n    arrow.norm = (1. + sin(iTime)) * .5;\n    float arrow_df = draw_arrow(uv, arrow);\n\n    fragColor.rgb = vec3(arrow_df);\n}\n","name":"Image","description":"","type":"image"}]}