{"ver":"0.1","info":{"id":"dlfGz8","date":"1671268298","viewed":80,"name":"easy soft shadow","username":"lambwww","description":"简单的软阴影，待更新","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray{vec3 start;vec3 dir;};\nstruct material{float d;float id;vec3 color;};\n\nfloat diffuse(vec3 light,vec3 normal)\n{\n    float k=0.2;\n    float halfLamb=dot(light,normal)*0.5+0.5;\n    return halfLamb;\n}\nfloat sphere(vec3 p,vec3 center,float radius)\n{\n    return length(p-center)-radius;\n}\nfloat plane(vec3 p)\n{\n    return p.y+1.5;\n}\n//场景图，并且根据不同的id赋不同的颜色值\nmaterial map(vec3 p){\n    material mat;\n    mat.color=vec3(1,1,1);\n    vec3 center=vec3(0,0, 4); \n    float sphere1=sphere(p,vec3(-2,0,4),1.);\n    float sphere2=sphere(p,vec3(2,0,4),1.);\n    float plane1=plane(p);\n    if(sphere1<=0.001)\n    {\n        mat.id=0.;\n        mat.color=vec3(1,0.5,0.5);\n    }\n    if(sphere2<=0.001)\n    {\n        mat.id=1.;\n    }\n    if(plane1<=0.001)\n    {\n        mat.id=2.;\n        mat.color= vec3(1,1,0);\n    }\n    mat.d=min(sphere1,min(sphere2,plane1));\n    return mat;\n}\n//利用曲面的梯度求法线，就是对xyz分量求偏导\nvec3 GetNormal(vec3 p){\n    float d = map(p).d;\n    vec2 e = vec2(0.001,0.0);\n    float  fdx = d-map(p-e.xyy).d;\n    float fdy = d-map(p-e.yxy).d;\n    float fdz = d-map(p-e.yyx).d;\n    return normalize(vec3(fdx,fdy,fdz));\n}\n//求光线到球表面的距离，使用光线无限接近\nmaterial rayMatch(vec3 rayS,vec3 rayD)\n{\n    material mat;\n    float d=0.;\n    for(int i=0;i<250;i++)//之前循环次数少了，有的地方没找到\n    {\n        vec3 p=rayS+rayD*d;\n        mat=map(p);\n        float tempD=mat.d;\n        if(tempD<=0.001 || tempD>=40.) //太近代表找到了，太远代表看不见\n            break;\n        d+=tempD;\n    }\n    mat.d=d;\n    return mat;\n}\n//从物体的点沿着光线方向继续寻找物体，找到了那就是阴影点，赋颜色值黑色\nfloat shadow(vec3 ro,vec3 rd)\n{\n    \n    for(float i=0.;i<40.;)\n    {\n        vec3 p=ro+rd*i;\n        float h=map(p).d;\n        if(h<0.001) return 0.;\n        i+=h;\n    }\n    return 1.;\n}\n//0代表硬阴影，res代表软阴影，1代表没有阴影。因为越接近0越靠近黑色\nfloat softshadow(vec3 ro,vec3 rd,float k)\n{\n    float res=1.0;\n    float t=0.;\n    for(int i=0;i<100;i++)\n    {\n        float h=map(ro+rd*t).d;\n        if(h<0.001) return 0.;\n        //这里h是sdf的距离值，t表示从起点到点现在所在位置走过路程的长度，二者比值代表了安全角度的大小\n        //k是控制角度对应的阴影取值，k越大角度和阴影关系越敏感\n        res=min(res,k*h/t); \n        \n        t+=h;\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv初始化\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    //生成视线\n    ray viewRay;\n    viewRay.start=vec3(0,0,-3);\n    viewRay.dir=normalize(vec3(uv,1));//光线向量，要限制在【0，1】中间\n    //求眼睛到球体的距离，如果在距离内代表可以被看见，就进行着色\n    material mat=rayMatch(viewRay.start,viewRay.dir);\n    if(mat.d<=40.)\n    {\n        //视线起点到球表面的最小距离\n        float d=rayMatch(viewRay.start,viewRay.dir).d;\n        //球表面的点\n        vec3 p=viewRay.start+viewRay.dir*d;\n        //生成光线，光线射向当前看到的物体表面点\n        ray light;\n        light.start=vec3(-5,8,2);\n        light.dir=normalize(light.start-p-5.*sin(iTime*0.4));\n        //表面那个点对应的法线\n        vec3 normal = GetNormal(p);\n        //diffuse\n        float diffuse = dot(normal,light.dir);\n        vec3 color = vec3(1,1,1);\n        //shadow\n        p=p+normal*0.002;\n        diffuse*=softshadow(p,light.dir,8.);\n        \n        color=diffuse*color;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n        fragColor = vec4(0.1, 0.2, 0.4, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}