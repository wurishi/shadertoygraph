{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float dMax = 28.0;\n\n// Simple 2d noise algorithm contributed by Trisomie21 (Thanks!)\nfloat snoise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat terrain( vec2 p, int octaves ) {\t\n\tfloat h = 0.0; // height\n\tfloat w = 0.5; // octave weight\n\tfloat m = 0.4; // octave multiplier\n\tfor (int i=0; i<12; i++) {\n\t\tif (i<octaves) {\n\t\t\th += w * snoise((p * m));\n\t\t}\n\t\telse break;\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\nvec2 map( vec3 p, int octaves ) {\n\t\n\tfloat dMin = dMax; // nearest intersection\n\tfloat d; // depth\n\tfloat mID = -1.0; // material ID\n\t\n\t// mountains\n\tfloat h = terrain(p.xz, octaves);\n\th += smoothstep(-0.6, 1.2, h); // exaggerate the higher terrain\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\t// sand dunes\n\tif (h<0.5) {\n\t\tfloat s = 0.5 * terrain(p.xz*0.9, 3); // minimal detail needed for sand\n\t\td = p.y - s;\t\n\t\tif (d<dMin) { \n\t\t\tdMin = d;\n\t\t\tmID = 1.0;\n\t\t}\n\t}\n\treturn vec2(dMin, mID);\n}\n\nvec2 castRay( vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001; // precision\n\tfloat t = 0.0; // distance\n\tfloat h = p * 2.0; // step\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)>p || t<dMax ) {\n\t\t\tt += h; // next step\n\t\t\tvec2 res = map(ro + rd*t, octaves); // next intersection\n\t\t\th = res.x; // distance\n\t\t\tm = res.y; // material\n\t\t} \n\t\telse break;\n\t}\n\tif (t>dMax) m = -1.0; // if no intersection, material ID is -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal( vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows( vec3 ro, vec3 rd, float tMax, float k, int octaves ) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t<tMax) {\n\t\t\tfloat h = map(ro + rd*t, octaves).x;\n        \tres = min( res, k*h/t );\n        \tt += h;\n\t\t}\n\t\telse break;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render( vec3 ro, vec3 rd ) {\n\tconst int geoLOD = 4;\n\t\n\tvec3 color = vec3(0.3,0.4,0.6); // base color is sky color\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize( vec3(1.0, 0.5, 0.0) ); // light position\n\tvec3 lCol = vec3(1.0, 0.9, 0.7); // yellowish light\n\t\n\tvec3 pos = ro + rd*res.x; // world position\n\t\n\t// mat -1 = background/sky\n\tif (res.y < -0.5) {\n\t\tfloat sun = clamp(dot(rd,lPos),0.0,1.0); // sun orb\n\t\tcolor += 0.8 * lCol * sun*sun;\n\t\t// cheap clouds (hopefully, no one will notice)\n\t\tfloat c = snoise(pos.xz * 0.05); \n\t\tcolor = mix( color, vec3(1.0, 1.0, 0.8), smoothstep(0.0, 1.5, c) );\n\t\treturn color;\n\t}\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/dMax)); // normal LOD decreases with distance\n\tvec3 nor = calcNormal(pos, norLOD); // terrain normals\n\t\n\t// mat 0 = terrain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t\n\t\t// base rock formation colors\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// layer noise (to produdce lighter color bands of rock)\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\t// rock layers should show through where nomals are NOT straight up\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, nor.y) ); \n\t\t\n\t\t// add in lighting and shadows\n\t\tfloat lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0); // ambient\n\t\tfloat lDif = clamp( dot( nor, lPos ), 0.0, 2.0); // diffuse\n\t\t\n\t\t// shadow octaves should match geometry octaves used in initial ray cast\n\t\tif (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\t\t\n\t\tcolor += (0.4*lAmb) * lCol;\n\t\tcolor *= (1.8*lDif) * lCol;\t\n\t}\n\t// mat 1 = sand\n\tif (res.y>0.5) {\n\t\t// base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t\t\t\n\t\t// add in lighting and shadows\n\t\tfloat lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0); // ambient\n\t\tfloat lDif = clamp( dot( nor, lPos ), 0.0, 2.0); // diffuse\n\t\t\n\t\t// shadow octaves should match geometry octaves used in initial ray cast\n\t\tif (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\t\t\n\t\tcolor += (0.4*lAmb) * lCol;\n\t\tcolor *= (1.8*lDif) * lCol;\n\t}\n\t\n\t// fog\n\tfloat fog = exp(-0.005 * res.x*res.x); // exponentioal fog equation\n\tcolor = mix(vec3(0.3,0.3,0.35), color, fog); // add fog in distance\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0; // bound screen coords to [0, 1]\n\tpos.x *= iResolution.x / iResolution.y; // correct for aspect ratio\n\n\t// camera\n\tfloat x = 0.0 + (0.5*iTime);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*iTime);\n\tvec3 cPos = vec3(x, y, z); // position\n\tcPos.y = terrain(cPos.xz, 1) + 1.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.); // up \n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.7, 0.0); // lookAt\n\t\n\t// camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsf3zB","date":"1373319576","viewed":4164,"name":"Desert Morning","username":"ESpitz","description":"A second attempt at procedural terrain generation - based on techniques developed by Inigo Quilez.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","distancefield","terrain","raymarch"],"hasliked":0,"parentid":"","parentname":""}}