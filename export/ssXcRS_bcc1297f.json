{"ver":"0.1","info":{"id":"ssXcRS","date":"1642256340","viewed":182,"name":"SDF box iterations","username":"beyond","description":"Simple study for SDF and ray marching.\nPress mouse to see how many ray marching steps for each pixel.\nGreen is the object iterations, blue is background iterations.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","box","iterations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1.0\n#define rm_max_steps 75\n\nconst vec3 bgColor = vec3(0.005,0,0.0005);\nconst float sunSize = 0.5;\n\nmat3 rotationMatrix(vec3 a, float angle)\n{\n//    a = normalize(a);\n    float x=a.x, y=a.y, z=a.z;\n    float s=sin(angle), c=cos(angle), ic = 1. - c;\n    float icx = ic*x, icy = ic*y, icz = ic*z;\n    return mat3(icx*x+c,   icx*y-z*s, icz*x+y*s,\n                icx*y+z*s, icy*y+c,   icy*z-x*s,\n                icz*x-y*s, icy*z+x*s, icz*z+c);        \n}\n\n// sdf for a box\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfBox(vec3 p, vec3 box)\n{\n    p = mod(abs(p+25.), 50.)-25.;\n\n    float b =  sdBox(p, box);\n    return b;\n}\n\nfloat sdfSphere(vec3 p, vec3 pos, float r)\n{\n    p = p-pos;\n    return length(p)-r;\n}\n\nvec3 sunRayMarch(vec3 o, vec3 dir, vec3 pos, float r)\n{\n    vec3 AB = dir, AP = pos-o;\n    float f = dot(AP,AB)/dot(AB,AB);\n    vec3 pm = o + f*AB;\n    float dist = length(pos-pm);\n    bool hit = r-dist < 0.;\n    return vec3(f, float(rm_max_steps), dist);\n}\n\nvec3 rayMarch(vec3 o, vec3 dir, vec3 b)\n{\n    vec3 rmp = o;\n    float dist = 0.;\n    for(int i=0; i<rm_max_steps; i++)\n    {\n        float d = sdfBox(rmp, b);\n        if (d<0.01f)\n            return vec3(dist, float(i), 0);\n        dist += d;\n        rmp = o + dir*dist;\n    }\n    return vec3(-1., float(rm_max_steps), 0);\n}\n\nvec3 calcNormal( vec3 p, vec3 b) \n{\n    float d = sdfBox(p, b);\n    vec2 e = vec2(0.05, 0);\n    vec3 n = d - vec3(\n        sdfBox(p-e.xyy, b),\n        sdfBox(p-e.yxy, b),\n        sdfBox(p-e.yyx, b));\n    return normalize(n);    \n}\n\nfloat calcShadow(vec3 light, vec3 hp, vec3 box)\n{\n    vec3 lightdir = normalize(hp-light);\n    vec3 lightd = rayMarch(light, lightdir, box);\n    float maxd = length(hp-light);\n    float shadow = 1.;\n    if (lightd.x<maxd*0.999)\n        shadow = 0.3f;\n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 box = vec3(\n        8.1 + sin(iTime*1.23)*3.,\n        8.1 + sin(iTime*1.71)*3.,\n        8.1 + sin(iTime*1.52)*3.);\n\n    // old school camera\n    vec3 from =vec3(cos(iTime*0.4), cos(iTime*0.9),sin(iTime*0.4))*30.0;\n    vec3 to = vec3(0.,1.,0.);\n\n    float dist = distance(to,from);\n    float FOV = 75./360.*2.*3.1415926;\n    \n\tvec3 vup = vec3(0.0,1.0,0.0);\n    vec3 d = normalize(from-to);\n\n    mat3 rot = rotationMatrix(d, 3.141*sin(iTime*0.2+0.7) + 3.141*sin(iTime*0.3+0.1));\n    vup = rot * vup;\n\n    vec3 u = cross(vup,d);\n    vec3 v = cross(d,u);\n\n    // width and height\n    float height = 2.0*tan((FOV/2.0))*dist;\n\tfloat aspect = iResolution.x/iResolution.y;\n    float width = height*aspect;\n    float h = height/2.0;\n    float w = width/2.0;\n\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec3 light = vec3(sin(iTime*0.3),cos(iTime*0.7),sin(iTime*0.5))*25.;\n    for(float m=0.0; m<AA; m++)\n    {\n        for(float n=0.0; n<AA; n++)\n        {\n            vec2 sp = fragCoord + vec2(n/AA,m/AA); // cater for AA\n            sp = sp/iResolution.xy;                // normalized\n           \tsp = 2.0*sp-vec2(1.0,1.0);             // (-1..1,-1..1)\n            vec3 pTo = to + w*sp.x*u + h*sp.y*v; \n\n            vec3 ray_d = normalize(pTo-from);\n            vec3 rm = rayMarch(from, ray_d, box);\n            if (iMouse.z<=0.) // mouse up\n            {\n                if (rm.x>0.) // if we hit something\n                {\n                    // calc normal and shade\n                    vec3 hp = from + ray_d*rm.x;\n                    vec3 n = calcNormal(hp, box);\n                    vec3 surface = abs(n);\n                    vec3 lhp = light-hp, nhlp = normalize(lhp);\n\n                    float gradient = max(0.1,dot(nhlp,n));\n\n                    float attenuation = 2500./(1.+dot(lhp,lhp));\n\n                    float shadow = calcShadow(light, hp + n*0.01, box);\n                    vec3 color = surface * gradient * attenuation * shadow;\n                    \n                    vec3 R = 2.*dot(nhlp, n)*n-nhlp;\n                    float r = max(0.,dot(ray_d, -R));\n                    color += surface*pow(r,225.) * attenuation * shadow;\n                    \n                    // add visible light source\n                    vec3 s = sunRayMarch(from, ray_d, light, sunSize);\n                    if (s.x<rm.x)\n                        color += vec3(1,1,1) / (1.+s.z*s.z);\n                        \n                    col += color;\n                }\n                else\n                {\n                    vec3 s = sunRayMarch(from, ray_d, light, sunSize);\n                    col += vec3(1,1,1) / (1.+s.z*s.z);\n                    col += vec3(bgColor);\n                }\n            }\n            else\n            {\n                // mouse down, show iterations\n                float tmp = rm.y/float(rm_max_steps);\n                if (rm.x>0.)\n                    col += vec3(0, tmp, 0);\n                else\n                    col += vec3(0, 0, tmp);\n            }\n        }\n    }\n    col  = col/(AA*AA);\n\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0); // gamma\n}","name":"Image","description":"","type":"image"}]}