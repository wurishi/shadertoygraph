{"ver":"0.1","info":{"id":"lcs3Wr","date":"1702986787","viewed":29,"name":"3D Ripple Test (RS)","username":"roey_shap","description":"UV Mapping!!\nAnyone have any tips on fixing the tearing that the large wave offsets give the quad?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_MAX_STEPS 200\n#define MARCH_MAX_DISTANCE 1000.0\n\n#define EPSILON 0.01\n#define LIGHT_EPSILON 0.00001\n\n#define PI 3.1415926535\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n\nfloat SDF_K = 8.0;\nfloat rippleDistortion;\n\n// Math Aux\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nvec3 map(float min1, float max1, vec3 value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nvec3 roundTo(vec3 v, vec3 snap)\n{\n    return round(v / snap) * snap;\n}\n\nfloat floorTo(float v, float snap)\n{\n    return floor(v / snap) * snap;\n}\n\nvec3 floorTo(vec3 v, vec3 snap)\n{\n    return round(v / snap) * snap;\n}\n\nmat3 rotateX(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cosAngle, -sinAngle),\n        vec3(0.0, sinAngle, cosAngle)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(cosAngle, 0.0, sinAngle),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sinAngle, 0.0, cosAngle)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(cosAngle, -sinAngle, 0.0),\n        vec3(sinAngle, cosAngle, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat mapPercentClamp(float value, float min2, float max2)\n{\n    return clamp(map(0.0, 1.0, value, min2, max2), min2, max2);\n}\n\nfloat getAmplitude(vec3 p)\n{\n    vec2 rippleCenter = vec2(0.0, 0.0);\n    float rippleDurationBase = 0.7;\n    float rippleDurationWait = 1.5;\n    float rippleTotalDuration = rippleDurationBase + rippleDurationWait;\n    float frequency = 0.95;\n    float waveOutputFreq = 1.2;\n    \n    vec2 deltaFromCenter = p.xz - rippleCenter;\n    vec2 dirFromCenter = normalize(deltaFromCenter);\n    \n    float currentRippleTime = iTime - floorTo(iTime, rippleTotalDuration);\n    float remainingRippleTime = rippleTotalDuration - currentRippleTime;\n    float lengthInfluence = map(rippleDurationBase, 0.0, currentRippleTime, 0.7, 0.5) * 1.0;\n    float amplitude = sin(frequency * (((-length(deltaFromCenter) * lengthInfluence) + (currentRippleTime)) * (2.0 * PI * waveOutputFreq) / rippleDurationBase));\n    amplitude *= (0.3 * remainingRippleTime) / (1.0 + (10.0 * lengthInfluence) + (length(deltaFromCenter)));\n    \n    return amplitude * 0.8; \n}\n\n// SDF Aux\nvec4 intersectSDF(vec4 infoA, vec4 infoB) \n{\n    return infoA.w > infoB.w ? infoA : infoB;\n}\n\nvec4 unionSDF(vec4 infoA, vec4 infoB) \n{\n    return infoA.w < infoB.w ? infoA : infoB;\n}\n\nvec4 differenceSDF(vec4 infoA, vec4 infoB)\n{\n    return infoA.w > -infoB.w ? infoA : vec4(infoB.rgb, -infoB.w);\n}\n\nvec4 xorSDF(vec4 infoA, vec4 infoB)\n{\n    \n    return intersectSDF(unionSDF(infoA, infoB), -intersectSDF(infoA, infoB));\n}\n\n// https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\nvec4 smoothUnionSDF(vec4 a, vec4 b, float k) \n{\n    // squaring k here gives a weird lip to combinations\n  float h = clamp(0.5 + 0.5*(a.w-b.w) / k, 0., 1.);\n  vec3 c = mix(a.rgb,b.rgb, clamp(0.5 + 0.5*(a.w-b.w) / sqrt(k), 0., 1.));\n  float d = mix(a.w, b.w, h) - k*h*(1.-h); \n   \n  return vec4(c, d);\n}\n\nvec4 smoothIntersectSDF(vec4 a, vec4 b, float k) \n{\n  float h = clamp(0.5 - 0.5*(a.w-b.w) / k, 0., 1.);\n  vec3 c = mix(a.rgb,b.rgb, clamp(0.5 + 0.5*(a.w-b.w) / sqrt(k), 0., 1.));\n  float d = mix(a.w, b.w, h) + k*h*(1.-h); \n   \n  return vec4(c, d);\n}\n\nvec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n{\n  float h = clamp(0.5 - 0.5*(a.w+b.w) / k, 0., 1.);\n  vec3 c = mix(a.rgb,b.rgb, clamp(0.5 + 0.5*(a.w-b.w) / sqrt(k), 0., 1.));\n  float d = mix(a.w, -b.w, h) + k*h*(1.-h); \n   \n  return vec4(c, d);\n}\n\nfloat rounded(float d, float radiusJump)\n{\n    return d - radiusJump;\n}\n\nvec3 repeatSpace(vec3 position, vec3 snap)\n{\n    return position - roundTo(position, snap);\n}\n\nvec3 warpSpace(vec3 position, vec3 snap)\n{\n    return position + roundTo(position, snap);\n}\n\n// Shape SDFs\nfloat sphereSDF(vec3 position, vec3 center, float radius)\n{\n    return length(position - center) - radius;\n}\n\n// from https://iquilezles.org/articles/distfunctions/\nfloat cubeSDF(vec3 p, vec3 center, mat3 rotations, float b)\n{\n    p = ((p - center) * rotations) + center;\n    vec3 d = abs(p - center) - (b * 0.75);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat planeSDF(vec3 p, vec3 planeNormal, float h)\n{\n    float amplitude = getAmplitude(p);\n    \n    p += planeNormal * amplitude;\n    \n    return dot(p, planeNormal) + h;\n}\n\n// base of this function straight from iq (legend.)\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a;\n    vec3 cb = c - b;\n    vec3 dc = d - c;\n    vec3 ad = a - d;\n    vec3 nor = cross( ba, ad );\n    float amplitude = getAmplitude(p);\n    p += normalize(nor) * amplitude;\n    \n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    vec3 pc = p - c;\n    vec3 pd = p - d;\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd)) < 3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec4 sceneSDF(in vec3 samplePoint) \n{   \n    vec4 finalDist = vec4(BLACK, MARCH_MAX_DISTANCE);\n    \n    /*\n    vec3 sphere1Pos = vec3(0.0, 0.0, 0.0);\n    float sphere1Radius = 0.75;\n    vec3 sphere1Col = RED;\n    finalDist = vec4(sphere1Col, sphereSDF(samplePoint, sphere1Pos, sphere1Radius));\n    */\n    \n    vec3 quadCenter = vec3(0.0, -1.0, 0.0);\n    float scale = 2.0;\n    float sqScale = scale * scale;\n    vec3 quadSideLength = vec3(1.0, 0.0, -1.0) * scale * 0.5;\n    mat3 rotation = rotateX(-0.4);\n    vec3 p1 = quadCenter + (rotation * quadSideLength.zyz);\n    vec3 p2 = quadCenter + (rotation * quadSideLength.xyz);\n    vec3 p3 = quadCenter + (rotation * quadSideLength.xyx);\n    vec3 p4 = quadCenter + (rotation * quadSideLength.zyx);\n    vec3 dir1 = normalize(p2 - p1);\n    vec3 dir2 = normalize(p4 - p1);\n    float quadDis = quadSDF(samplePoint,\n                             p1,\n                             p2,\n                             p3,\n                             p4);\n    // project point onto plane represented by quad\n    // then clamp the x/z values relative to the quad center and get uv\n    vec3 quadNormal = normalize(cross(dir1, dir2));\n    vec3 pointOnPlane = samplePoint - (quadNormal * dot(samplePoint, quadNormal));\n    vec2 quadUV = vec2(       dot(pointOnPlane - p1, p2 - p1) / sqScale,\n                        1.0 - dot(pointOnPlane - p1, p4 - p1) / sqScale\n                      );\n    vec3 quadCol = texture(iChannel0, quadUV.xy).rgb;\n    finalDist = unionSDF(finalDist, vec4(quadCol, quadDis));\n    \n    // form walls via cube subtracting cube\n    vec3 roomCenter = quadCenter;\n    vec3 roomDimensions = vec3(5.0, 5.0, 5.0);\n    mat3 roomRotation = rotateX(0.0);           //!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    \n    \n    return finalDist;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    vec2 eps = vec2(LIGHT_EPSILON, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + eps.xyy).w - sceneSDF(p - eps.xyy).w,\n        sceneSDF(p + eps.yxy).w - sceneSDF(p - eps.yxy).w,\n        sceneSDF(p + eps.yyx).w - sceneSDF(p - eps.yyx).w\n    ));\n}\n\n\nfloat getObjectIntersectionDistance(vec3 camPos, vec3 viewRayDir, inout vec4 color)\n{\n    color.a = 1.0;\n    float distanceMarched = 0.0;\n    float smallestDistanceToObj = MARCH_MAX_DISTANCE * 0.999;\n    vec4 safeStepDistanceInfo = vec4(vec3(0.0), MARCH_MAX_DISTANCE);\n    for (int i = 0; \n         i < MARCH_MAX_STEPS && smallestDistanceToObj >= EPSILON && distanceMarched < MARCH_MAX_DISTANCE;\n         i++)\n    {\n        safeStepDistanceInfo = sceneSDF(camPos + (distanceMarched * viewRayDir));\n        smallestDistanceToObj = safeStepDistanceInfo.w;\n        distanceMarched += smallestDistanceToObj;\n    }\n    \n    color.rgb = safeStepDistanceInfo.rgb;\n    return distanceMarched;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float smallerDim = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / smallerDim;\n    \n    float focalDistance = 1.0;\n    vec3 camPos = vec3(0.0, 0.0, focalDistance + 3.0);\n    \n    vec3 pixelPos = vec3(uv, camPos.z - focalDistance);\n    vec3 pixelCamDelta = pixelPos - camPos;\n    vec3 viewRayDir = normalize(pixelPos - camPos);\n    \n    vec4 hitColor;\n    float objDistance = getObjectIntersectionDistance(camPos, viewRayDir, hitColor);\n    \n    vec3 hitPoint = camPos + (objDistance * viewRayDir);\n    \n    vec3 skyColor = vec3(0.0, length(uv), length(uv));\n    vec3 col = vec3(0.0);\n    float shadowStrength = 0.0;\n    \n    // assume we have a single point light\n    float lx = 1.0;\n    float ly = 2.0; \n    float lz = -2.0; \n    vec3 lightPosition = vec3(lx, ly, lz);\n    \n    if (objDistance < MARCH_MAX_DISTANCE)\n    {\n        vec3 directionToLight = normalize(lightPosition - hitPoint);\n        \n        vec3 surfaceNormal = estimateNormal(hitPoint);\n        \n        // check if it's in shadow\n        vec3 shadowRayOrigin = hitPoint + (6.5 * EPSILON * surfaceNormal);\n        vec3 shadowRayDir = directionToLight;\n        vec4 shadowColor;\n        float shadowCheckDis = getObjectIntersectionDistance(shadowRayOrigin, shadowRayDir, shadowColor);\n        if (shadowCheckDis < MARCH_MAX_DISTANCE)\n        {\n            vec3 shadowHitPoint = shadowRayOrigin + (shadowRayDir * (shadowCheckDis + (3.0 * EPSILON)));\n            vec3 shadowHitNormal = estimateNormal(shadowHitPoint);\n            shadowStrength = map(-1.0, 1.0, dot(shadowHitNormal, shadowRayDir), 1.0, 0.6);\n        }\n        \n        vec3 ambient = hitColor.rgb;\n        float ks = 0.45;\n        float kd = 0.2;\n        float shineSharpness = 10.0;\n        vec3 specularColor = vec3(1.0, 1.0, 1.0);\n        vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n        vec3 reflectedLightDir = reflect(-directionToLight, surfaceNormal);\n        vec3 surfaceToCameraDir = -viewRayDir;\n        float cosShineAmount = dot(reflectedLightDir, surfaceToCameraDir);\n        float specularAngleIntensity = cosShineAmount > 0.0 ? pow(cosShineAmount, shineSharpness) : 0.0;\n\n        vec3 specular = ks * specularAngleIntensity * specularColor;\n        float diffusionFactor = dot(directionToLight, surfaceNormal);\n        vec3 diffuse = kd * diffusionFactor * diffuseColor;\n        \n        col += ambient + specular + diffuse;\n        \n        col = mix(col, BLACK, shadowStrength);\n    }\n    else\n    {\n        col = skyColor;\n    }\n        \n    //vec3 col = texture(iChannel0, offsetUV).rgb;\n    //col = mix(col, vec3(0.0), clamp(amplitude * 8.0, 0.0, 1.0));  //1.0 - currentRippleTime / rippleTotalDuration\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}