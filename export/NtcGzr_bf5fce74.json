{"ver":"0.1","info":{"id":"NtcGzr","date":"1635563272","viewed":236,"name":"composite filter","username":"NueSB","description":"it's not much but its mine; made for me to understand how these work a little better. hope this helps someone!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["analog","ntsc","composite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// here we split the channels again by getting the average of the \"function\" of I/Q.\n// artifacts come in because the averaging isn't perfect. to make the look cleaner we need a window function or something\n// to filter out some of the high frequency bits\n\nconst mat3 YIQ2RGB = mat3(1.000, 1.000, 1.000,\n                          0.956,-0.272,-1.106,\n                          0.621,-0.647, 1.703);\n#define SIZE 17\n#define CAVG 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    vec3 YIQ;\n    \n    int i;\n    for(i = -CAVG; i < CAVG; i++)\n    {\n        float signal = texture(iChannel0, (fragCoord + vec2(float(i))) / iResolution.xy).r;\n        YIQ.x += signal;\n    }\n    \n    for(i = -SIZE; i < SIZE; i++)\n    {\n        float signal = texture(iChannel0, (fragCoord + vec2(float(i))) / iResolution.xy).r;\n        float pos = float(fragCoord.y) + float(i);\n        YIQ.yz += signal * vec2(sin(pos), cos(pos));\n    }\n    \n    YIQ /= vec3(float(CAVG)*2.0, float(SIZE)*2.0, float(SIZE)*2.0);\n    YIQ *= vec3(1.0, 4.0, 4.0);\n    \n    color = YIQ * YIQ2RGB;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// input shader, anything can work here\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += iTime * 0.01;\n    fragColor = texture(iChannel0, uv).rrrr * texture(iChannel1, uv).r;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// modulates the signal. Y is its own whatever, I and Q have their own carrier waves added (sin and cos) to distinguish the two\nmat3 RGB2YIQ = mat3(0.299, 0.596, 0.211,\n                    0.587,-0.274,-0.523,\n                    0.114,-0.322, 0.312);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv * vec2(1.0, 1.0)).rgb;\n    color *= RGB2YIQ; \n    \n    float signal = color.r + (color.g * sin(fragCoord.y)) / 2.0 + (color.b * cos(fragCoord.y)) / 2.0;\n    \n    fragColor = vec4(vec3(signal),1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}