{"ver":"0.1","info":{"id":"Ws2XWR","date":"1553441921","viewed":116,"name":"test: menga sponge","username":"takumifukasawa","description":"menga sponge\nref: https://iquilezles.org/articles/menger/menger.htm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------------\n// ref\n// https://iquilezles.org/articles/menger\n//---------------------------------------------------------------\n\n#define EPS 0.0001\n#define PI 3.14159265359\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec3 map(vec3 p) {\n  float d = box(p, vec3(1.));\n  float s = 1.;\n  for(int m = 0; m < 3; m++) {\n    vec3 a = mod(p * s, 2.) - 1.;\n    s *= 3.;\n    vec3 r = abs(1. - 3. * abs(a));\n    float da = max(r.x, r.y);\n    float db = max(r.y, r.z);\n    float dc = max(r.z, r.x);\n    float c = (min(da, min(db, dc)) - 1.) / s;\n    d = max(d, c);\n  }\n  return vec3(d, 0., 0.);\n}\n\nfloat scene(vec3 p) {\n  vec3 d = map(p);\n  return d.x;\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nfloat rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  vec3 sceneDist = vec3(0.);\n  float rayDepth = start;\n\n  vec3 res = vec3(-1.);\n  vec3 h = vec3(1.);\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist.x = scene(origin + dir * rayDepth);\n    if((sceneDist.x < stopThreshold) || (rayDepth >= end)) {\n      break;\n    }\n    res = vec3(rayDepth, sceneDist.yz);\n    rayDepth += sceneDist.x * stepScale;\n  }\n  if (sceneDist.x >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist.x;\n  }\n  return rayDepth;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower) * light.intensity;\n  }\n  return specular;\n}\n\nvec3 lighting(vec3 position, vec3 cameraPos) {\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.6, .8, .8);\n  vec3 specularColor = vec3(.8, 1., 1.);\n\n  Light directionalLight;\n  directionalLight.position = vec3(0., 2., 2.);\n  directionalLight.intensity = .4;\n  directionalLight.color = vec3(0., 0., .5);\n\n  Light pointLight;\n  pointLight.position = vec3(0., 0., 0.);\n  pointLight.intensity = .8;\n  pointLight.color = vec3(.5, .5, .9);\n\n  Light ambientLight;\n  ambientLight.color = vec3(0., 0., 1.);\n  ambientLight.intensity = .2;\n\n  // directional light\n  float dDiffuse = max(0., dot(normal, normalize(directionalLight.position)));\n  dDiffuse *= directionalLight.intensity;\n  vec3 dDiffuseColor = dDiffuse * directionalLight.color * objColor;\n  float dSpecular = getSpecular(position, normal, directionalLight, dDiffuse, cameraPos);\n  vec3 dSpecularColor = dSpecular * specularColor;\n\n  // point light\n  vec3 pLightDir = pointLight.position - position;\n  float pDiffuse = max(0., dot(normal, normalize(pLightDir)));\n  vec3 pDiffuseColor = pDiffuse * pointLight.color * objColor;\n  float d = distance(pointLight.position, position);\n  vec3 k = vec3(.05, .9, .06);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n  pDiffuse *= pointLight.intensity;\n  pDiffuse *= attenuation;\n  float pSpecular = getSpecular(position, normal, pointLight, pDiffuse, cameraPos);\n  pSpecular *= attenuation;\n  vec3 pSpecularColor = pSpecular * specularColor;\n\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n\n  vec3 diffuse = dDiffuseColor + pDiffuseColor;\n  vec3 specular = dSpecularColor + pSpecularColor;\n  vec3 ambient = ambientColor;\n\n  return objColor * diffuse + specular + ambient;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n\n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  vec3 cameraPos = vec3(cos(iTime / 3.) * 3., sin(iTime / 3.) * 3., 2.);\n  float fov = .9;\n  float nearClip = 0.;\n  float farClip = 80.;\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));\n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  float dist = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n\n  if(dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(bgColor, 1.);\n    return;\n  }\n\n  vec3 position = rayOrigin + rayDirection * dist;\n  vec3 normal = getNormal(position);\n\n  vec3 sceneColor = lighting(position, cameraPos);\n\n  // sceneColor = fog(sceneColor, dist, vec3(0.), .04);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}