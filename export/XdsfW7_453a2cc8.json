{"ver":"0.1","info":{"id":"XdsfW7","date":"1496456692","viewed":760,"name":"3 bits colors(dithering)","username":"stduhpf","description":"Ordered dithering allows to make images looking not too bad but with only 3 bits of data per pixel( one per channel)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["compression","dithering","bayermatrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float bayer2(vec2 v)\n{\n    v=floor(v);\n return fract(v.y*v.y*.75+v.x*.5);   \n}\nfloat bayer4(vec2 v)\n{\n    return bayer2(.5*v)*.25+bayer2(v);\n}\nfloat bayer8(vec2 v)\n{\n    return bayer4(.5*v)*.25+bayer2(v);\n}\nfloat bayer16(vec2 v)\n{\n    return bayer8(.5*v)*.25+bayer2(v);\n}\nfloat bayer32(vec2 v)\n{\n    return bayer16(.5*v)*.25+bayer2(v);\n}\nfloat bayer64(vec2 v)\n{\n    return bayer32(.5*v)*.25+bayer2(v);\n}\nfloat bayer128(vec2 v)\n{\n    return bayer64(.5*v)*.25+bayer2(v);\n}\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    const float pixelsize = 1.;\n    I=floor(I/pixelsize)+.5;\n\tvec2 uv = pixelsize*I.xy / iResolution.xy;\n    float d = bayer128(I) +0.00003051757;\n    #define s floor(pow(2.,1.)-1.)\n    O.rgb = srgb_to_rgb(texture(iChannel0,uv).rgb);\n\tO.rgb = rgb_to_srgb(floor(O.rgb*s+d)/s);\n    //the final image can be stored with: int final = dot(O.xyz,vec3(1,2,4)); wich can be contained in only 3 bits of data per pixel\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float SRGB_GAMMA = 1.0 / 2.4;\nconst float SRGB_INVERSE_GAMMA = 2.4;\nconst float SRGB_ALPHA = 0.055;\n\n\n// Converts a single linear channel to srgb\nfloat linear_to_srgb(float channel) {\n    if(channel <= 0.0031308)\n        return 12.92 * channel;\n    else\n        return (1.0 + SRGB_ALPHA) * pow(channel, 1.0/2.4) - SRGB_ALPHA;\n}\n\n// Converts a single srgb channel to rgb\nfloat srgb_to_linear(float channel) {\n    if (channel <= 0.04045)\n        return channel / 12.92;\n    else\n        return pow((channel + SRGB_ALPHA) / (1.0 + SRGB_ALPHA), 2.4);\n}\n\n// Converts a linear rgb color to a srgb color (exact, not approximated)\nvec3 rgb_to_srgb(vec3 rgb) {\n    return vec3(\n        linear_to_srgb(rgb.r),\n        linear_to_srgb(rgb.g),\n        linear_to_srgb(rgb.b)\n    );\n}\n\n// Converts a srgb color to a linear rgb color (exact, not approximated)\nvec3 srgb_to_rgb(vec3 srgb) {\n    return vec3(\n        srgb_to_linear(srgb.r),\n        srgb_to_linear(srgb.g),\n        srgb_to_linear(srgb.b)\n    );\n}\n","name":"Common","description":"","type":"common"}]}