{"ver":"0.1","info":{"id":"llcBDB","date":"1541175668","viewed":110,"name":"Ray March 1st","username":"jpechevarria","description":"Learning \"ray marching\", \"volumetric rendering\" + \"signed distance function\".\nPracticing diffuse + specular lighting.\nAntialiasing (subsampling or miltusample, don't remember de name ;) ).\nOclussion.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","shadow","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 200\n#define EPSILON 0.001\n//#define AXIS_RADIUS 0.01;\n#define AMBIENT_LIGHT 0.01\n\n#define ROTATE_EYE 0\n#define ANIMATE_FIGURE 0\n#define ROTATE_LIGHT 1\n#define VIEW_AXIS 0\n\n#define EYE_DIST 18.0\n#define WALL_DIST 20.0\n\nfloat AXIS_RADIUS = (2.0) * EYE_DIST / 1000.0;\n\nmat2 cubeRot;\nvec3 cubeTra;\n\nvec3 light1Pos_base = vec3(0.0,2.0,3.0);\nvec3 light1Pos;\n\nint lightInScene = 1;\n\nmat2 rot2d( float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2( \n        \t\tc, -s,\n                s,  c\n               );\n}\n\nfloat unionSDF(float sdf1, float sdf2) {\n    return min(sdf1,sdf2);\n}\n\nfloat intersectSDF(float sdf1, float sdf2) {\n    return max(sdf1,sdf2);\n}\n\nfloat excludeSDF(float sdf1, float sdf2) {\n    return intersectSDF(sdf1, -sdf2);\n}\n\nfloat sphereSDF(vec3 p, float radio) {\n    // SPHERE\n    return length(p) - radio;\n}\nfloat leftHSpaceSDF(float coord, float limit) {\n    return coord - limit;\n}\nfloat rightHSpaceSDF(float coord, float limit) {\n    return limit - coord;\n}\nfloat cubeSDF(vec3 p, float lado)\n{\n    lado *= 0.5;\n    // CUBE\n    float dx = max( leftHSpaceSDF(p.x,lado) , rightHSpaceSDF(p.x,-lado) );\n    float dy = max( leftHSpaceSDF(p.y,lado) , rightHSpaceSDF(p.y,-lado) );\n    float dz = max( leftHSpaceSDF(p.z,lado) , rightHSpaceSDF(p.z,-lado) );\n\n    float ret;\n    ret = max(max(dx,dy),dz);\n    \n    return ret;\n}\n\nfloat ejeXSDF(vec3 p) { return length(p.yz) - AXIS_RADIUS; }\nfloat ejeYSDF(vec3 p) { return length(p.xz) - AXIS_RADIUS; }\nfloat ejeZSDF(vec3 p) { return length(p.xy) - AXIS_RADIUS; }\n\nfloat sceneSDF(vec3 p, out int mat) {\n    \n    mat = 1;\n    \n    float ret;\n    float sphere1, sphere2, sphere3, sphere4;\n    float cube;\n    \n    float commonRadius = 1.3;\n    \n    vec3 sphereCentre1 = vec3(0.0,0.0,0.0);\n    float sphereRadius1 = commonRadius; //(1.0 + sin(iTime)) * 0.5;\n\n\tvec3 sphereCentre2 = vec3(0.0,0.0,0.0);\n    float sphereRadius2 = 0.5; // (1.0 + sin(iTime)) * 0.5;\n\t/*\n    vec3 sphereCentre3 = vec3(0.0,1.0,0.0);\n    float sphereRadius3 = commonRadius; // (1.0 + sin(iTime)) * 0.5;\n\t\n    vec3 sphereCentre4 = vec3(0.0,-1.0,0.0);\n    float sphereRadius4 = commonRadius; // (1.0 + sin(iTime)) * 0.5;\n\t*/\n    \n    // CUBE TRANSFORMATIONS\n    vec3 pp = p;\n    pp.xyz += cubeTra;\n    //pp.yz = cubeRot * pp.yz;\n    //pp.xz = cubeRot * pp.xz;\n    pp.xy = cubeRot * pp.xy;\n    \n    sphere1 = sphereSDF(pp - sphereCentre1, sphereRadius1);\n    sphere2 = sphereSDF(p - sphereCentre2, sphereRadius2);\n    //sphere3 = sphereSDF(pp - sphereCentre3, sphereRadius3);\n    //sphere4 = sphereSDF(pp - sphereCentre4, sphereRadius4);\n    \n    cube = cubeSDF(pp , 2.0);\n\n    ret = 999.0;\n    \n    ret = unionSDF(ret,cube);\n\n    // INTERSECTION\n    //ret = intersectSDF(ret,sphere);\n\n    /* UNION \n    ret = unionSDF(ret, sphere1);\n    ret = unionSDF(ret, sphere2);\n    ret = unionSDF(ret, sphere3);\n    ret = unionSDF(ret, sphere4);\n    //*/\n\n    ///* EXCLUSION\n\tret = excludeSDF(ret,sphere1);\n    //ret = excludeSDF(ret,sphere2);\n    //ret = excludeSDF(ret,sphere3);\n    //ret = excludeSDF(ret,sphere4);\n\t//*/\n\n\tret = unionSDF(ret, sphere2);\n\n    /* INTERSECTION\n\tfloat fig2;\n    fig2 = 999.0;\n\tfig2 = unionSDF(fig2,sphere1);\n    fig2 = unionSDF(fig2,sphere2);\n    fig2 = unionSDF(fig2,sphere3);\n    fig2 = unionSDF(fig2,sphere4);\n    \n    ret = intersectSDF(ret,fig2);\n\t//*/\n\n    \n    // UNION CON LOS EJES\n    if ( ret > 0.0 \n        \t&& lightInScene > 0 \n        \t&& VIEW_AXIS > 0\n       ) {\n        float eje;\n        \n        eje = ejeXSDF(p);\n        ret = unionSDF(ret, eje);\n        if ( eje < EPSILON ) mat = 2;\n        \n        eje = ejeYSDF(p);\n        ret = unionSDF(ret, eje);\n        if ( eje < EPSILON ) mat = 3;\n        \n        eje = ejeZSDF(p);\n        ret = unionSDF(ret, eje);\n        if ( eje < EPSILON ) mat = 4;\n    }\n    \n    if ( lightInScene > 0 )\n    {\n        float lightDist = sphereSDF(p - light1Pos, 0.15);\n        if ( lightDist < EPSILON ) mat = 5;\n\n        ret = unionSDF(ret, lightDist);\n    }\n    \n    ret = unionSDF(ret,leftHSpaceSDF(p.y, -3.0));\n    ret = unionSDF(ret,leftHSpaceSDF(p.z, -WALL_DIST));\n    ret = unionSDF(ret,leftHSpaceSDF(p.x, -WALL_DIST));\n    ret = unionSDF(ret,rightHSpaceSDF(p.z, WALL_DIST));\n    ret = unionSDF(ret,rightHSpaceSDF(p.x, WALL_DIST));\n    \n    return ret;\n}\n\nfloat lightSDF(vec3 p, vec3 l, out vec3 col) \n{\n    float ret = sphereSDF(l, 0.1);\n    if ( ret < EPSILON )\n    {\n        col = vec3(1.0,1.0,0.0);\n    }\n    return ret;\n}\n\nfloat rayMarch(vec3 eye, vec3 viewRayDirection, out int mat) {\n    float start = 0.0;\n    float end = 100.0;\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        //vec3 col;\n        float dist = sceneSDF(eye + depth * viewRayDirection, mat);\n        if (dist < EPSILON) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= end) {\n            // Gone too far; give up\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    int col;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z),col) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z),col),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z),col) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z),col),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON),col) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON),col)\n    ));\n}\n\nvec4 image( in vec2 fragCoord, in vec2 resolution )\n{\n    vec4 fragColor = vec4(0, 0, 0, 1);\n    \n    // MOELO TRANFORMATIONS\n    if ( ANIMATE_FIGURE > 0 )\n    {\n\t\tcubeRot = rot2d(0.5*iTime);\n\t\t//cubeTra = vec3(0.0, 0.0, 5.0*sin(1.7*iTime));\n        //cubeTra.x = 1.5 * sin(3.0*iTime);\n    }\n    else\n    {\n        cubeRot = rot2d(0.0);\n        cubeTra = vec3(3.0,0.0,0.0);\n    }\n    //cubeTra = vec3(-2.0,0.0,0.0);\n    \n    // LIGHT ROTATION\n\tlight1Pos = light1Pos_base;\n    if ( ROTATE_LIGHT > 0 )\n    {\n        mat2 rot = rot2d(iTime);\n        light1Pos.xz *= rot;  \n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / resolution.xy - 0.5;\n    uv.y *= resolution.y / resolution.x;\n\n\tvec3 eye;\n    if ( ROTATE_EYE == 0 )\n    {\n        eye = vec3(EYE_DIST*cos(1.1),3.0,EYE_DIST * sin(1.1));\n    }\n    else\n    {\n    \tfloat eyeAngle = 0.5 * iTime;\n        eye.xz = EYE_DIST * vec2 ( sin(eyeAngle), cos(eyeAngle) );\n        eye.y = 3.0;\n    }\n    \n    vec3 lookAt = vec3 ( 0.0, 0.0, 0.0 );\n    vec3 eyeDir = normalize(lookAt - eye);\n    vec3 up = vec3 ( 0.0, 1.0, 0.0 );\n    vec3 right = normalize(cross(eyeDir,up));\n    up = cross(right,eyeDir);\n    \n    vec3 screen = eye + eyeDir + uv.x * right + uv.y * up;\n    vec3 rayDir = normalize(screen - eye);\n    \n    int material;\n    float dist = rayMarch(eye, rayDir, material);\n    \n\tvec3 col;\n\n\tif ( material == 1 ) col = vec3(1.0,1.0,1.0);\n    \n    if ( material >= 2 && material <= 5 ) {\n        if ( material == 2 ) col = vec3(1.0,0.0,0.0);\n        if ( material == 3 ) col = vec3(0.0,1.0,0.0);\n        if ( material == 4 ) col = vec3(0.0,0.0,1.0);\n        if ( material == 5 ) col = vec3(1.0,1.0,0.0);\n        fragColor = vec4(col,1.0);\n    }\n    else \n    {\n\n        vec3 p = eye + dist * rayDir;\n\n        if ( dist < 100.0 ) {\n            \n            vec3 viewDir = - rayDir;\n\n            vec3 normal = estimateNormal(p);\n\n            // DIRECTIONAL LIGHT\n            //vec3 light = -light1Dir;\n            //float ligthPower = 1.0;\n\n            // POINT LIGHT\n            vec3 light = light1Pos - p;\n            float lightDist = length(light);\n            float ligthPower = pow(3.0 / lightDist,1.0);\n\n            light = normalize(light);\n\n            // DIFFUSE LIGHT\n            float light1Dif = max(dot(light, normal),0.0);\n\n            // SPECULAR LIGHT\n            vec3 reflectDir = reflect(-light, normal);\n            float angle = max(dot(reflectDir, viewDir),0.0);\n            float light1Spe = pow(angle,64.0);\n\n            // VIEW NORMALS\n            //fragColor = vec4(normal,1.0);\n\n            //\n            fragColor = vec4(AMBIENT_LIGHT);\n\n            // VIEW DIFF LIGHT\n            fragColor += 1.0 * ligthPower * vec4(light1Dif);\n\n            // VIEW SPEC LIGHT\n            fragColor += 1.0 * ligthPower * vec4(light1Spe);\n\n            //fragColor = vec4(abs(normal),1.0);\n            //fragColor = vec4(light,1.0);\n            //fragColor = vec4(pow(4.0/lightDist,10.0));\n\n            fragColor.rgb *= col;\n            \n            // VERIFY LIGHT OCCLUSION\n            ///*\n            lightInScene = 0;\n            rayDir = normalize(p-light1Pos);\n            float distFromLight = rayMarch(light1Pos, rayDir, material);\n            float diff = length(p-light1Pos) -distFromLight ;\n            if ( diff > 10.0 * EPSILON )\n            {\n                fragColor = vec4(AMBIENT_LIGHT);\n            }\n\t\t\t//*/\n        }\n    }\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float subSample = 3.0;\n    \n    \n    if ( subSample < 2.0 )\n    {\n    \tfragColor += image(fragCoord, iResolution.xy);\n    }\n    else\n    {\n        vec2 subResolution = iResolution.xy * subSample;\n\n        float samples = subSample * subSample;\n        float sampleWeight = 1.0 / samples;\n\n        for ( float i = 0.0; i < subSample ; i ++ )\n        {\n            for ( float j = 0.0; j < subSample ; j ++ )\n            {\n                vec2 newCoord = fragCoord * subSample + vec2(i,j);\n                fragColor += image(newCoord, subResolution) * sampleWeight;\n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}