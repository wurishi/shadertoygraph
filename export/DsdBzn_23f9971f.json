{"ver":"0.1","info":{"id":"DsdBzn","date":"1696807355","viewed":83,"name":"tri interlocked grids stacks dda","username":"jt","description":"Render three 2d xor-interlocked grids (rotated by 60 degrees with aspect ratio sqrt(3)): lift to 6d, apply hyper voxel DDA, project to 2d.\nAdded height which makes the hypervoxel DDA effectively 7 dimensional.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raytracing","raycasting","voxel","slice","honeycomb","dda","cut","kisrhombille","project","hyper","6d","lift","7d"],"hasliked":0,"parentid":"cdGcDt","parentname":"trigonally interlocked grids dda"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/DsdBzn tri interlocked grids stacks dda, 2023 by jt\n// extends https://www.shadertoy.com/view/cdGcDt trigonally interlocked grids dda\n// based on https://www.shadertoy.com/view/cl2fRd DDA test site 2d\n\n// DDA originally inspired by https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// and tutorial http://lodev.org/cgtutor/raycasting.html\n// distance & normal reconstruction, grid transform and lift to hypervoxels by jt\n\n// Render three 2d xor-interlocked grids\n// (rotated by 60 degrees with aspect ratio sqrt(3) )\n// by using a 6d hyper voxel DDA.\n// Added height - makes the hypervoxel DDA effectively 7 dimensional.\n\n// tags: 2d, 3d, raytracing, raycasting, voxel, slice, honeycomb, dda, cut, kisrhombille, project, hyper, 6d, lift, 7d\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//precision mediump float; // <-- try this in case of \"no default precision defined for variable\" error\n\n#define pi 3.1415926\n\n#define DIST_MAX 100.0\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\n// Emulate 6d and 7d vector. Would be so much easier if GLSL supported vec6 and vec7...\n#define VEC6 vec2[3]\n#define BVEC6 bvec2[3]\n#define IVEC6 ivec2[3]\n\nstruct VEC7\n{\n    VEC6 t;\n    float s;\n};\n\nstruct BVEC7\n{\n    BVEC6 t;\n    bool s;\n};\n\nstruct IVEC7\n{\n    IVEC6 t;\n    int s;\n};\n\nVEC6 RECIPROCAL(VEC6 v)\n{\n    return VEC6(1.0 / v[0], 1.0 / v[1], 1.0 / v[2]);\n}\n\nVEC7 RECIPROCAL(VEC7 v)\n{\n    return VEC7(RECIPROCAL(v.t), 1.0 / v.s);\n}\n\nVEC6 SCALAR_TO_VEC6(float s)\n{\n    return VEC6(vec2(s),vec2(s),vec2(s));\n}\n\nVEC7 SCALAR_TO_VEC7(float s)\n{\n    return VEC7(SCALAR_TO_VEC6(s), s);\n}\n\nIVEC6 SCALAR_TO_IVEC6(int s)\n{\n    return IVEC6(ivec2(s),ivec2(s),ivec2(s));\n}\n\nIVEC7 SCALAR_TO_IVEC7(int s)\n{\n    return IVEC7(SCALAR_TO_IVEC6(s), s);\n}\n\nVEC6 TO_FLOAT(BVEC6 v)\n{\n    return VEC6(vec2(v[0]),vec2(v[1]),vec2(v[2]));\n}\n\nVEC7 TO_FLOAT(BVEC7 v)\n{\n    return VEC7(TO_FLOAT(v.t), float(v.s));\n}\n\nVEC6 TO_FLOAT(IVEC6 v)\n{\n    return VEC6(vec2(v[0]),vec2(v[1]),vec2(v[2]));\n}\n\nVEC7 TO_FLOAT(IVEC7 v)\n{\n    return VEC7(TO_FLOAT(v.t), float(v.s));\n}\n\nIVEC6 TO_INT(BVEC6 v)\n{\n    return IVEC6(ivec2(v[0]),ivec2(v[1]),ivec2(v[2]));\n}\n\nIVEC7 TO_INT(BVEC7 v)\n{\n    return IVEC7(TO_INT(v.t),int(v.s));\n}\n\nIVEC6 TO_INT(VEC6 v)\n{\n    return IVEC6(ivec2(v[0]),ivec2(v[1]),ivec2(v[2]));\n}\n\nIVEC7 TO_INT(VEC7 v)\n{\n    return IVEC7(TO_INT(v.t),int(v.s));\n}\n\nVEC6 ABS(VEC6 v)\n{\n    return VEC6(abs(v[0]), abs(v[1]), abs(v[2]));\n}\n\nVEC7 ABS(VEC7 v)\n{\n    return VEC7(ABS(v.t), abs(v.s));\n}\n\nVEC6 SIGN(VEC6 v)\n{\n    return VEC6(sign(v[0]), sign(v[1]), sign(v[2]));\n}\n\nVEC7 SIGN(VEC7 v)\n{\n    return VEC7(SIGN(v.t), sign(v.s));\n}\n\nVEC6 NEG(VEC6 v)\n{\n    return VEC6(-v[0], -v[1], -v[2]);\n}\n\nVEC7 NEG(VEC7 v)\n{\n    return VEC7(NEG(v.t), -v.s);\n}\n\nIVEC6 NEG(IVEC6 v)\n{\n    return IVEC6(-v[0], -v[1], -v[2]);\n}\n\nIVEC7 NEG(IVEC7 v)\n{\n    return IVEC7(NEG(v.t), -v.s);\n}\n\nVEC6 FLOOR(VEC6 v)\n{\n    return VEC6(floor(v[0]), floor(v[1]), floor(v[2]));\n}\n\nVEC7 FLOOR(VEC7 v)\n{\n    return VEC7(FLOOR(v.t), floor(v.s));\n}\n\nVEC6 SCALE(VEC6 a, float b)\n{\n    return VEC6(a[0] * b, a[1] * b, a[2] * b);\n}\n\nVEC7 SCALE(VEC7 a, float b)\n{\n    return VEC7(SCALE(a.t, b), a.s * b);\n}\n\nVEC6 ADD_HALF(VEC6 v)\n{\n    return VEC6(v[0] + 0.5, v[1] + 0.5, v[2] + 0.5);\n}\n\nVEC7 ADD_HALF(VEC7 v)\n{\n    return VEC7(ADD_HALF(v.t), v.s + 0.5);\n}\n\nVEC6 ADD(VEC6 a, VEC6 b)\n{\n    return VEC6(a[0] + b[0], a[1] + b[1], a[2] + b[2]);\n}\n\nVEC7 ADD(VEC7 a, VEC7 b)\n{\n    return VEC7(ADD(a.t, b.t), a.s + b.s);\n}\n\nIVEC6 ADD(IVEC6 a, IVEC6 b)\n{\n    return IVEC6(a[0] + b[0], a[1] + b[1], a[2] + b[2]);\n}\n\nIVEC7 ADD(IVEC7 a, IVEC7 b)\n{\n    return IVEC7(ADD(a.t, b.t), a.s + b.s);\n}\n\nVEC6 SUB(VEC6 a, VEC6 b)\n{\n    return VEC6(a[0] - b[0], a[1] - b[1], a[2] - b[2]);\n}\n\nVEC7 SUB(VEC7 a, VEC7 b)\n{\n    return VEC7(SUB(a.t, b.t), a.s - b.s);\n}\n\nVEC6 MUL(VEC6 a, VEC6 b)\n{\n    return VEC6(a[0] * b[0], a[1] * b[1], a[2] * b[2]);\n}\n\nVEC7 MUL(VEC7 a, VEC7 b)\n{\n    return VEC7(MUL(a.t, b.t), a.s * b.s);\n}\n\nIVEC6 MUL(IVEC6 a, IVEC6 b)\n{\n    return IVEC6(a[0] * b[0], a[1] * b[1], a[2] * b[2]);\n}\n\nIVEC7 MUL(IVEC7 a, IVEC7 b)\n{\n    return IVEC7(MUL(a.t, b.t), a.s * b.s);\n}\n\nVEC6 DIV(VEC6 a, VEC6 b)\n{\n    return VEC6(a[0] / b[0], a[1] / b[1], a[2] / b[2]);\n}\n\nVEC7 DIV(VEC7 a, VEC7 b)\n{\n    return VEC7(DIV(a.t, b.t), a.s / b.s);\n}\n\nIVEC6 DIV(IVEC6 a, IVEC6 b)\n{\n    return IVEC6(a[0] / b[0], a[1] / b[1], a[2] / b[2]);\n}\n\nIVEC7 DIV(IVEC7 a, IVEC7 b)\n{\n    return IVEC7(DIV(a.t, b.t), a.s / b.s);\n}\n\nfloat DOT(VEC6 a, VEC6 b)\n{\n    return dot(a[0], b[0]) + dot(a[1], b[1]) + dot(a[2], b[2]);\n}\n\nfloat DOT(VEC7 a, VEC7 b)\n{\n    return DOT(a.t, b.t) + a.s * b.s;\n}\n\nfloat LENGTH(VEC6 v)\n{\n    return sqrt(DOT(v, v));\n}\n\nfloat LENGTH(VEC7 v)\n{\n    return sqrt(DOT(v, v));\n}\n\nVEC6 MIN(VEC6 a, VEC6 b)\n{\n    return VEC6(min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]));\n}\n\nVEC7 MIN(VEC7 a, VEC7 b)\n{\n    return VEC7(MIN(a.t, b.t), min(a.s, b.s));\n}\n\nVEC6 MAX(VEC6 a, VEC6 b)\n{\n    return VEC6(max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]));\n}\n\nVEC7 MAX(VEC7 a, VEC7 b)\n{\n    return VEC7(MAX(a.t, b.t), max(a.s, b.s));\n}\n\nBVEC6 LTE(VEC6 a, VEC6 b)\n{\n    return BVEC6(lessThanEqual(a[0], b[0]), lessThanEqual(a[1], b[1]), lessThanEqual(a[2], b[2]));\n}\n\nBVEC7 LTE(VEC7 a, VEC7 b)\n{\n    return BVEC7(LTE(a.t, b.t), a.s <= b.s);\n}\n\nBVEC6 GTE(VEC6 a, VEC6 b)\n{\n    return BVEC6(greaterThanEqual(a[0], b[0]), greaterThanEqual(a[1], b[1]), greaterThanEqual(a[2], b[2]));\n}\n\nBVEC7 GTE(VEC7 a, VEC7 b)\n{\n    return BVEC7(GTE(a.t, b.t), a.s >= b.s);\n}\n\n// sets bit to true if corresponding component is the minimum (multiples possible)\nBVEC6 LEAST(VEC6 v)\n{\n    float minimum = min(min(min(v[0].x, v[0].y), min(v[1].x, v[1].y)), min(v[2].x, v[2].y));\n    return LTE(v, SCALAR_TO_VEC6(minimum));\n}\n\n// sets bit to true if corresponding component is the minimum (multiples possible)\nBVEC7 LEAST(VEC7 v)\n{\n    float minimum = min(min(min(min(v.t[0].x, v.t[0].y), min(v.t[1].x, v.t[1].y)), min(v.t[2].x, v.t[2].y)), v.s);\n    return LTE(v, SCALAR_TO_VEC7(minimum));\n}\n\nVEC7 apply(mat2 M0, mat2 M1, mat2 M2, VEC7 v)\n{\n    return VEC7(VEC6(M0*v.t[0].xy, M1*v.t[1].xy, M2*v.t[2].xy), v.s);\n}\n\nvec3 project(VEC7 v)\n{\n    return vec3(v.t[0].xy + v.t[1].xy + v.t[2].xy, v.s); // collapse 6d to 2d by identifying (x,y) triples and move 7th dimension to 3rd dimension\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nbool get_voxel(IVEC7 v)\n{\n    //if(v.s != 0) return false;\n    \n    if(((v.t[0].x^v.t[0].y^v.t[1].x^v.t[1].y^v.t[2].x^v.t[2].y^v.s)&1) != 0) return false; // checker\n// XXX cause of excentric rotation?! XXX\n    vec3 p = project(TO_FLOAT(v))*vec3(1,2,mix(1.0, 4.0, 0.5+0.5*cos(iTime)))/*???*/;\n    //return length(p) < 12.0;\n    //vec2 r = vec2(mix(10.0, 20.0, 0.5+0.5*cos(iTime/2.0)), mix(5.0, 10.0, (0.5+0.5*cos(iTime))));\n    vec2 r = vec2(mix(10.0, 20.0, 0.5+0.5*cos(iTime/2.0)), 5.0);\n    return torus(p, r) < 0.0;\n/*\n    ivec2 size = ivec2(12,8);\n\n    if(any(lessThan(v.t[0], ivec2(-size)))) return false;\n    if(any(lessThan(v.t[1], ivec2(-size)))) return false;\n    if(any(lessThan(v.t[2], ivec2(-size)))) return false;\n    if(any(greaterThanEqual(v.t[0], ivec2(size)))) return false;\n    if(any(greaterThanEqual(v.t[1], ivec2(size)))) return false;\n    if(any(greaterThanEqual(v.t[2], ivec2(size)))) return false;\n\n    return ((v.t[0].x^v.t[0].y^v.t[1].x^v.t[1].y^v.t[2].x^v.t[2].y^v.s)&1) != 0; // checker\n*/\n}\n\n#define MAX_RAY_STEPS 128\n\nvec4 traverse_trigonally_interlocked_grids(vec3 ray_pos_orig, vec3 ray_dir_orig)\n{\n    // Fortunately mat3x7 can be replaced by three mat2 and a scalar here\n    // | +1, 0,+c,-s,+c,+s, 0 |\n    // |  0,+1,+s,+c,-s,+c, 0 |\n    // |  0, 0, 0, 0, 0, 0,+1 |\n    float c = cos(radians(60.0)), s = sin(radians(60.0));\n    // NOTE: matrix constructor by column therefore matrix looks transposed here\n    mat2 M0 = mat2(+1, 0, 0,+1); // rotate   0 deg\n    mat2 M1 = mat2(+c,+s,-s,+c); // rotate +60 deg\n    mat2 M2 = mat2(+c,-s,+s,+c); // rotate -60 deg\n\n    vec2 a = vec2(sqrt(3.0),1); // change aspect ratio so grid vertices meet\n    // Lift 2d coordinates to 6d coodrinates (this would be q=M*p)\n    VEC7 ray_pos = VEC7(VEC6((M0*ray_pos_orig.xy)*a, (M1*ray_pos_orig.xy)*a, (M2*ray_pos_orig.xy)*a), ray_pos_orig.z);\n    VEC7 ray_dir = VEC7(VEC6((M0*ray_dir_orig.xy)*a, (M1*ray_dir_orig.xy)*a, (M2*ray_dir_orig.xy)*a), ray_dir_orig.z);\n\n    IVEC7 tile_pos = TO_INT(FLOOR(ray_pos)); // round down position to get tile position\n\n    // decompose ray direction into reciprocal absolute ray direction and sign (-1,+1)\n    VEC7 delta_dist = RECIPROCAL(ABS(ray_dir)); // reciprocal absolute ray direction\n    IVEC7 ray_step = TO_INT(SIGN(ray_dir)); // sign of ray direction\n    // initial distances to nearest walls by dimension:\n    //     calculate ray position in relation to tile origin\n    //     (requires adding one half because tile origin is floor of ray position)\n    //     adjust sign according to ray direction\n    //     because tile has size 1 and we start in the middle wall is located at 0.5 (sign depends on ray direction)\n    //     divide by ray direction (to get distance with respect to ray)\n    VEC7 side_dist = MUL(ADD_HALF(MUL(TO_FLOAT(ray_step), ADD_HALF(SUB(TO_FLOAT(tile_pos), ray_pos)))), delta_dist); // initial distances to nearest walls by dimension\n    BVEC7 nearest = LEAST(side_dist); // component is true if nearest wall in that dimension\n\n    vec4 result = vec4(-ray_dir_orig, DIST_MAX); // sky\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        if(get_voxel(tile_pos))\n        {\n            float dist = LENGTH(MUL(TO_FLOAT(nearest), SUB(side_dist, delta_dist)));\n            // NOTE: nearest contains only one component set to true indicating nearest direction and since normal points along this direction just cast nearest to normal (sign opposite to ray direction)\n            // Then: Project 6d coordinates back to 2d (this would be p=transpose(M)*q)\n            result = vec4(project(apply(transpose(M0),transpose(M1),transpose(M2),MUL(TO_FLOAT(nearest),TO_FLOAT(NEG(ray_step))))), dist);\n\n            break;\n        }\n\n        // adapted from core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n        nearest = LEAST(side_dist); // component is true if nearest wall in that dimension\n        side_dist = ADD(side_dist, MUL(TO_FLOAT(nearest), delta_dist)); // update distances to nearest walls by dimension\n        tile_pos = ADD(tile_pos, MUL(TO_INT(nearest), ray_step)); // step to next tile in direction of nearest wall\n    }\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 I )\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I.xy / R - 1.0;\n    //I.x *= R.x / R.y;\n    I = (2.0 * I - R) / R.y; // concise pixel-position mapping thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = -pi/4.0 + pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 1.5 * pi/2.0;\n\n    vec3 ray_pos = vec3(0.0, 0.0, -16.0);\n    vec3 ray_dir = vec3(I.x, I.y, 2.0); // NOTE: un-normalized direction appears to work fine here!\n    //ray_dir = normalize(ray_dir); // looks like ray-direction does not need to be normalized\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0); // rotate camera\n    ray_pos = M * ray_pos;\n    ray_dir = M * ray_dir;\n\n    //ray_pos.z -= 0.0;\n\n    //ray_dir = normalize(ray_dir);\n\n    vec4 result = traverse_trigonally_interlocked_grids(ray_pos, ray_dir);\n    vec3 color = vec3(0);\n    if(result.w < DIST_MAX)\n    {\n        vec3 n = result.xyz;\n        float d = result.w;\n        vec3 dst = ray_pos + ray_dir * d;\n        d *= length(ray_dir); // fix distance in case ray was not normalized\n\n        vec3 light_dir = normalize(vec3(1,2,3));\n        //float brightness = max(0.0, dot(lightdir, n));\n        float diffuse = abs(dot(light_dir, n));\n        float shadow = diffuse > 0.0 ? traverse_trigonally_interlocked_grids(dst+result.xyz*0.001, light_dir).w < DIST_MAX ? 0.0 : 1.0 : 0.0;\n        float ambient = 0.5;\n        float specular = max(0.0, dot(result.xyz, normalize(-normalize(ray_dir) + light_dir)));\n        color = vec3(1);\n        //color *= mix(vec3(0.5), vec3(1.0), checker(dst*2.0)); // texture\n        color *= (shadow * diffuse + ambient) * vec3(0.5 + 0.5 * result.xyz);\n        color += shadow * 0.5 * pow(specular, 50.0);\n\n        vec3 fogcolor = vec3(0); // fog\n        color *= mix(fogcolor, color, exp(-d * d / 1000.0)); // fog for depth impression & to suppress flickering\n    }\n    else\n    {\n        color = vec3(0,0,0);\n    }\n\n    //color = mix(vec3(1,1,0),vec3(0,0,1),result.w/20.0); // debug distance\n\n    color = tanh(color); // roll-off overly bright colors\n\n    fragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}