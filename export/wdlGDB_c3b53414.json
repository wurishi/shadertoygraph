{"ver":"0.1","info":{"id":"wdlGDB","date":"1547449768","viewed":154,"name":"Re: materials","username":"gest","description":"original: https://www.shadertoy.com/view/Xsl3DS","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lighting","sphere","materials","plane","intersect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\n\tObject object;\t\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\nPlane plane_1 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,1,0));\nPlane plane_2 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,0,1));\n\nstruct Sphere {\n\tvec3  center;\n\tfloat radius;\n};\nSphere sphere_1 = Sphere(vec3(-1.0, 1.5, 1.0), 0.4);\nSphere sphere_2 = Sphere(vec3( 1.0, 1.5, 1.0), 0.4);\nSphere sphere_3 = Sphere(vec3( 0.0, 1.5, 1.0), 0.4);\nSphere sphere_4 = Sphere(vec3( 0.0, 1.5, 2.0), 0.4);\n\t\nstruct Box {\n\tvec3 center;\n\tvec3 size;\n};\nBox box_1 = Box(vec3(-1.0, 1.5, -1.0), vec3(0.4) );\nBox box_2 = Box(vec3( 1.0, 1.5, -1.0), vec3(0.4) );\nBox box_3 = Box(vec3( 0.0, 1.5, -1.0), vec3(0.4) );\nBox box_4 = Box(vec3( 0.0, 1.5, -2.0), vec3(0.4) );\n\nstruct Material {\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n\tfloat shininess;\n\t\n\tfloat reflectivity;\n\tfloat refractivity;\n\tfloat indexRefractive;\n\tbool flagSolid;\n};\nMaterial material_sphere_1;\nMaterial material_sphere_2;\nMaterial material_sphere_3;\nMaterial material_sphere_4;\nMaterial material_plane_1b;\nMaterial material_plane_1w;\n\nstruct Light {\n\tvec3 position;\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n};\nLight light_0 = Light ( vec3(-0.5, -0.5, -2.0), vec3(1), vec3(1), vec3(1) );\nLight light_1 = Light ( vec3( 0.5,  0.5, -2.0), vec3(1), vec3(1), vec3(1) );\nconst int lightCount = 1;\n\nMaterial getMaterial (Ray ray) {\n\tMaterial material;\n\tif (ray.object.id == 0) {\n\t\tmaterial = material_sphere_1;\n\t} else if (ray.object.id == 1) {\n\t\tmaterial = material_sphere_2;\n\t} else if (ray.object.id == 2) {\n\t\tmaterial = material_sphere_3;\n\t} else if (ray.object.id == 3) {\n\t\tmaterial = material_sphere_4;\n\t} else if (ray.object.id == 4) {\n//\t\tfloat r = 0.25;\n//\t\tfloat squareSize = ( 1.0 + r*2.0 ) / 2.0;\n\t\tfloat squareSize = 0.5;\n\t\tvec3 p = mod ( ray.position - plane_1.center - ray.epsilon, squareSize * 2.0 );\n\t\tfloat s = squareSize;\n\t\tfloat l = s;\n\t\tfloat h = s;\n\t\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t\t\t ( p.x > h && p.y < l && p.z > h ) ||\n\t\t\t ( p.x < l && p.y > h && p.z > h ) ||\n\t\t\t ( p.x > h && p.y > h && p.z < l ) ) {\n\t\t\tmaterial = material_plane_1b;\n\t\t} else {\n\t\t\tmaterial = material_plane_1w;\n\t\t}\n\t}\n\treturn material;\n}\n\t\n//-----------------------------------------------------------------------------------------\t\n//Пересечение луча со сферой\nfloat intersectSphere(Ray ray, Sphere sphere, inout vec3 normal) {\n\tfloat t0, t1, t;\n\t\n\tvec3 l = sphere.center - ray.origin;\n\tfloat tca = dot(l, ray.direction);\n\tif ( tca < 0.0 ) return ray.far;\n\tfloat d2 = dot (l, l) - (tca * tca);\n\tfloat r2 = sphere.radius*sphere.radius;\n\tif ( d2 > r2 ) return ray.far;\n\tfloat thc = sqrt(r2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\t\t\n\tif ( t0 < 0.0 ) {\n\t\tt = t1;\n\t} else if ( t1 < 0.0 ) {\n\t\tt = t0;\n\t} else {\n\t\tt = min(t0,t1);\n\t}\n\tif (t<0.0) return ray.far;\n\tvec3 p = ray.origin + t * ray.direction;\n\tfloat flagInside = -sign(dot(ray.direction, p - sphere.center));\n\tnormal = normalize ( p - sphere.center ) * flagInside;\n\treturn t;\n}\n//Пересечение луча с плоскостью\nfloat intersectPlane(Ray ray, Plane plane, inout vec3 normal) {\n\tfloat det = dot ( plane.normal, ray.direction );\n\tif (abs(det) < ray.epsilon) return ray.far;\n\n\tfloat t = - ( dot ( plane.normal, ray.origin ) + length(plane.center) ) / dot ( plane.normal, ray.direction );\n\t\n\tif ( t < 0.0 ) return ray.far;\n\t\n\tfloat flagInside = -sign(dot(ray.direction, plane.normal));\n\tnormal = plane.normal;\n\tnormal *= flagInside;\n\t\t\n\treturn t;\t\n}\n//Пересечение луча с кубом\nfloat intersectBox(Ray ray, Box box, inout vec3 normal) {\n\t\n\tvec3 minp = box.center - box.size;\n\tvec3 maxp = box.center + box.size;\n\t\n\tfloat tmin = (minp.x - ray.origin.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.origin.x) / ray.direction.x;\n\tif (tmin > tmax) { \n\t\tfloat s = tmin; \n\t\ttmin = tmax; \n\t\ttmax = s; \n\t}\n\tfloat tymin = (minp.y - ray.origin.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.origin.y) / ray.direction.y;\n\tif (tymin > tymax) { \n\t\tfloat s = tymin; \n\t\ttymin = tymax; \n\t\ttymax = s; \n\t}\n\tif ((tmin > tymax) || (tymin > tmax)) return ray.far;\n\tif (tymin > tmin) tmin = tymin;\n\tif (tymax < tmax) tmax = tymax;\n\tfloat tzmin = (minp.z - ray.origin.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.origin.z) / ray.direction.z;\n\tif (tzmin > tzmax) { \n\t\tfloat s = tzmin; \n\t\ttzmin = tzmax; \n\t\ttzmax = s; \n\t}\n\tif ((tmin > tzmax) || (tzmin > tmax)) return ray.far;\n\tif (tzmin > tmin) tmin = tzmin;\n\tif (tzmax < tmax) tmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < ray.epsilon && tmax < ray.epsilon ) return ray.far;\n\tif ( tmin < ray.epsilon ) {\n\t\tt = tmax;\n\t} else if ( tmax < ray.epsilon ) {\n\t\tt = tmin;\n\t} else {\n\t\tt = min(tmin, tmax);\n\t}\n\t\n\tfloat flagInside = 1.;\n\tif ( tmin < ray.epsilon && tmax > ray.epsilon ) flagInside = -1.;\n\t\n\tvec3 p = ray.origin + t * ray.direction;\n\t\n\tif ( abs(p.x - maxp.x) < ray.epsilon ) {\n\t\tnormal = vec3(1,0,0) * flagInside;\n\t} else if ( abs(p.x - minp.x) < ray.epsilon ) {\n\t\tnormal = vec3(-1,0,0) * flagInside;\n\t} else if ( abs(p.y - maxp.y) < ray.epsilon ) {\n\t\tnormal = vec3(0,1,0) * flagInside;\n\t} else if ( abs(p.y - minp.y ) < ray.epsilon ) {\n\t\tnormal = vec3(0,-1,0) * flagInside;\n\t} else if ( abs(p.z - maxp.z ) < ray.epsilon ) {\n\t\tnormal = vec3(0,0,1) * flagInside;\n\t} else {\n\t\tnormal = vec3(0,0,-1) * flagInside;\n\t}\n\treturn t;\n}\n\n\n//---------------------------------------------------------------------------------\nvoid rayMarch(inout Ray ray) {\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.hit \t\t= false;\n\tray.distance \t= ray.far;\n\tray.position \t= ray.origin + ray.distance * ray.direction;\n\tray.normal \t\t= vec3(0);\n\tray.object.id \t= -1;\n\n\tSphere sphere;\n\tPlane plane;\n\t\n\tfloat d;\n\tvec3 normal;\n\n\tfloat radius = 0.25;\n\t\n\tfor (float i=0.; i<4.; i++) {\n\t\tvec3 position = vec3(sin(i*1000.0), sin(i*10000.0), sin(i*100.0));\n\t\tvec3 velocity = vec3(cos(i*200.0+i*400.0+500.0), cos(i*400.0+i*2000.0+500.0), cos(i*600.0)) / 2.0;\n\t\tvec3 center = position + velocity * u_time;\n\t\t\n\t\tcenter = mod ( center, 4.0 ) - 2.0;\n\t\tif ( center.x >  1.0 ) center.x =  2.0 - center.x;\n\t\tif ( center.y >  1.0 ) center.y =  2.0 - center.y;\n\t\tif ( center.z >  1.0 ) center.z =  2.0 - center.z;\n\t\tif ( center.x < -1.0 ) center.x = -2.0 - center.x;\n\t\tif ( center.y < -1.0 ) center.y = -2.0 - center.y;\n\t\tif ( center.z < -1.0 ) center.z = -2.0 - center.z;\n\n\t\tsphere = Sphere(center, radius);\n\t\td = intersectSphere ( ray, sphere, normal );\n\t\tif (ray.distance > d) {\n\t\t\tray.hit \t \t= true;\n\t\t\tray.distance \t= d;\n\t\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\t\tray.normal   \t= normal;\n\t\t\tray.object.id \t= int(i);\n\t\t}\n\t}\n\t\n\tPlane planes[5];\n\tplanes[0] = Plane(vec3( 0,\t\t\t-1. - radius, 0\t\t\t ), vec3( 0, 1, 0));\n\tplanes[1] = Plane(vec3( 0,\t\t\t 1. + radius, 0\t\t\t ), vec3( 0,-1, 0));\n\tplanes[2] = Plane(vec3(-1. - radius\t,0,\t\t\t  0\t\t\t ), vec3( 1, 0, 0));\n\tplanes[3] = Plane(vec3( 1. + radius ,0,\t\t\t  0\t\t\t ), vec3(-1, 0, 0));\n\tplanes[4] = Plane(vec3( 0,\t\t\t 0, \t\t  1. + radius), vec3( 0, 0,-1));\n\t\n\tfor (int i=0; i<5; i++) {\n\t\td = intersectPlane ( ray, planes[i], normal );\n\t\tif (ray.distance > d) {\n\t\t\tray.hit \t \t= true;\n\t\t\tray.distance \t= d;\n\t\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\t\tray.normal   \t= normal;\n\t\t\tray.object.id \t= 4;\n\t\t}\n\t}\n}\n\nvec3 lighting(Ray ray, Light lights[lightCount], Material material) {\n\tvec3 col = vec3(0);\n\t\n\tfor (int i=0; i<lightCount; i++) {\n\t\tLight light = lights[i];\n\t\t\n\t\tfloat lightDistance = length(light.position - ray.position);\n\t\t\n\t\t//Тень\n\t\tfloat shadowFactor = 1.0;\n\t\t\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin \t= ray.position;\n\t\t\tray1.direction \t= normalize(light.position - ray.position);\n\t\t\tray1.near \t\t= 0.01;\n\t\t\tray1.far\t\t= lightDistance;\n\t\t}\n\t\trayMarch ( ray1 );\n\t\n\t\t\n\t\tif ( ray1.distance < ray1.far) {\n\t\t\tshadowFactor = clamp(1. - (lightDistance - 3.*ray1.distance) / lightDistance, 0.2, 1.);\n\t\t}\n\t\t\n\t\tfloat distanceAttenuationPower = 0.2;\n\t\tvec3 lightDir \t= normalize(light.position - ray.position);\n\t\tvec3 eyeDir \t= - ray.direction; //normalize ( ray.origin - ray.position );\n\t\tvec3 reflected \t= reflect ( -lightDir, ray.normal );\n\t\n\t\tvec3 color = light.colorAmbient * material.colorAmbient;\n\t\n\t\tcolor += shadowFactor * light.colorDiffuse * material.colorDiffuse * max(dot(ray.normal,lightDir), 0.0);\n\t\tcolor += shadowFactor * light.colorSpecular * material.colorSpecular * pow ( max ( dot(reflected, eyeDir), 0.0) , material.shininess ) * step(1., shadowFactor) ;\t\n\t\tcolor *= min ( 1.0/pow(length(ray.position - ray.origin), distanceAttenuationPower), 1.0);\n\t\n\t\tcol += color/float(lightCount);\n\t}\n\t\n\treturn col;\n}\n\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light lights[lightCount]) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\t//Цвет фона\n\t\t\tcolor += vec3(0.1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light lights[lightCount]) {\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//Луч преломления сквозь фигуру\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\n\t\t\t//Пересечение луча с границей 2 той же фигуры \n\t\t\trayMarch (ray);\n            \n            if (! material.flagSolid) {\n\n\t\t\t\t\n\t\t\t\tif (ray.hit) {\n\t\t\t\t\t//Достигли границы 2 фигуры\n\t\t\t\t\t//Луч преломления сквозь границу 2 фигуры\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t//Цвет за границей 2 фигуры\n\t\t\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t\t\t\t\n\t\t\t\t\t//Луч отражения от границы 2\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Отражение от границы 2\n\t\t\t\t\trayMarch (ray);\n\t\t\t\t\t\n\t\t\t\t\tif (ray.hit) {\n\t\t\t\t\t\t//Отраженный луч достиг границы 1 фигуры\n\t\t\t\t\t\t//Луч преломления сквозь границу 1 фигуры\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn color;\n}\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec3 u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2.0 - 1.0;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy -= 0.5;\n    if (u_mouse.xy==vec2(0) ) mouse.xy = vec2(0);\n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin  = vec3(0.0, 0.0, -3.0);\n        rotate (cam.origin, vec3(1,1,0) * vec3(mouse.y*PI, mouse.x*PI*2., 0));\n\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.;\n        ray.far  \t= 1e6;\n        ray.epsilon = 0.001;\n        ray.steps \t= 1;\n    }\t\n\n    Light lights[lightCount];\n    lights[0] = light_0;\n//\tlights[1] = light_1;\n\n    //Периодичность изменения материалов 5 сек\n    float time = mod(ceil(u_time/5.), 6.);\n\n\n    if (time==1.) {\n        //Металлические шарики и не отражающие стены\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==2.) {\n        //Один прозрачный сплошной шарик\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.8, 0.8, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==3.) {\n        //Все шарики разные\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.5, 0.8, 0.85, false  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.8, 0.85, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0,  true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.8, 0.85, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==4.) {\n        //Белые прозрачные стены\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.5, 0.5, 1.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.5, 0.5, 1.0, true );\n    } else if (time==5.) {\n        //Частично прозрачные стены\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.5, 0.5, 1.0, false );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==6.) {\n        //Все прозрачные сплошные шарики\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.5, 0.5, 1.0, false );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==0.) {\n        //Все матовые шарики\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    }\t\n    \n\tvec3 color = vec3(0);\n    color += rayReflect(ray, lights);\n    color += rayRefract(ray, lights);\n\n    GL_FragColor = vec4(color,1.0);\n\n}","name":"Image","description":"","type":"image"}]}