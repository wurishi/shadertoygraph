{"ver":"0.1","info":{"id":"MctBzX","date":"1733345488","viewed":15,"name":"inner space","username":"vivavolt","description":"hacking and slashing on the new feed","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","light","tirangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"triangle light\" by nayk. https://shadertoy.com/view/Xctfzf\n// 2024-12-04 20:49:32\n\n#define PI 3.14\nvoid rot(inout vec3 p,vec3 a,float t)\n{\n    a=normalize(a);\n    p=mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a);\n}\n\nvec2 modifiedAbs(vec2 x){\n    vec2 k= vec2(8); // Reduced from 15 to smooth out the abs function\n    vec2 h=tanh(x*k);\n    return h*h*abs(x);    \n}\n\nvec3 fold(vec3 p, float t)\n{\n    rot(p,vec3(cos(iTime*.2),sin(iTime*.3),.5*sin(iTime*.15)),iTime*.5); // Slowed down rotation\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n));         \n    for(float i=0.; i<t; i++){\n        p.xy=modifiedAbs(p.xy);\n        p.z-=min(abs(p.x*p.y),1.5)*.15; // Reduced z-displacement\n        p-=1.8*min(0.,dot(p,n))*n; // Reduced fold intensity\n    }\n    return p;\n}\n\nfloat c23(vec3 p){\n    float c1=dot(p.x,p.y);\n    float c2=reflect(p.x,p.y);\n    return smoothstep(-1.0, 1.0, c1*c2); // Smoothed transition\n}\n\nfloat map(vec3 p)\n{\n    rot(p,vec3(cos(iTime*.2),sin(iTime*.3),.5*sin(iTime*.15)),iTime*.5);\n    float t = float[](3.,4.,5.)[int(fract(iTime*0.1)*3.)]; // Slowed down transition\n    p = fold(p,t);\n    \n    p.z-=1.;\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n)); \n    \n    float d1 = dot(p, normalize(vec3(n.z,0,-n.x)));\n    float d2 = dot(p, normalize(vec3(0,n.z,-n.y)));\n    float d3 = length(p.xz)-.1;\n    float d4 = length(p.yz)-.1;\n    \n    // Smooth minimum between distances\n    return min(min(d1,d2), min(d3,d4));\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(.001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near;\n    float lastd = 1000.0;\n    \n    for(int i=0;i<90;i++) // Increased iterations for smoother convergence\n    {\n        float d = map(ro+rd*t);\n        // Adaptive step size based on previous distance\n        float step = min(d, lastd) * 0.5;\n        t += step;\n        lastd = d;\n        if (d<.001) return t;\n        if (t>=far) break;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    vec3 baseColor = vec3(.7,.5,.3);\n    vec3 pattern = cos(p*1.5)*.4+.6; // Reduced frequency and contrast\n    return mix(baseColor, pattern, 0.5);\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = smoothstep(0.0, 2.0, 2.0 - pos.x - pos.y); // Smoothed transition\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv3 = fragCoord/iResolution.xy - 0.5;\n    vec4 O = vec4(0);\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    \n    float time = iTime * 0.8; // Slowed down time\n    float zoomFactor = exp(time * 0.08);\n    vec2 zoomCenter = vec2(0.0, 0.0);\n    \n    vec2 uv2 = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = normalize(vec3(uv2,3));\n    vec3 col = vec3(0);\n    \n    const float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    col=pow(col,vec3(1./2.2));\n    uv = (uv - zoomCenter) * zoomFactor + zoomCenter;\n    \n    vec3 p,q,r=iResolution.xyz;\n    vec3 d=normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.y,1));\n    float g = 0.0;\n    \n    // Reduced iterations and smoothed accumulation\n    for(float i=0.; i<50.; i++) {\n        p = g*d;\n        p.z*=smoothstep(-1.0, 1.0, c23(p));\n        float a = 30.;\n        p = mod(p-a,a*2.)-a;\n        float s = 2.;\n        float e = 1.0;\n        \n        for(int j=0;j<int(abs(sin(iTime) * 10.) + 10.);j++){\n            p = .03-abs(p);\n            p.x<p.y?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.5+sin(iTime*.01)*.08;\n            p = abs(p)*e - vec3(5.*3., 120, 8.*5.)*col;\n        }\n        g += e=length(p.yz)/s;\n        O.xyz+=vec3(g*.08, g*.15, g*.25)/e/8e3;\n    }\n    \n    fragColor.xyz=O.xyz;\n    uv2 *= 2.0 * (cos(iTime * 1.5) -2.5);\n    float anim = sin(iTime * 8.0) * 0.08 + 1.0;\n    fragColor*= vec4(happy_star(uv3, anim) * vec3(0.35,0.2,0.15)*5., 1.0);\n}","name":"Image","description":"","type":"image"}]}