{"ver":"0.1","info":{"id":"7slyDM","date":"1642199700","viewed":157,"name":"Mech II (improved by Iq)","username":"rafaelcastrocouto","description":"SDF Mech II updated map \n\nMech I https://www.shadertoy.com/view/stBSDK","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sdf","mech"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define ZERO (min(iFrame,0))\n\nvec4 sphereColor( in vec3 pos, in vec3 nor, in vec3 rd ){\n\tvec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = 0.3 + 0.3 * vec3(texture( iChannel0, rd * 0.2 ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy ){ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 ){\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos, ZERO );\n        vec3 ref = reflect( rd, nor );\n        \n        // material\n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 3.6;\n        \n        vec4 mate = sphereColor(pos, nor, rd) * 1.2;\n        col *= mate.w;\n\t\tcol *= mate.xyz;\n        col.y = col.x;\n        col.z = col.x+0.03;\n        \n        if( m<1.5 ){\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 4.0*pos.xz, 4.0*dpdx.xz, 4.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor, ZERO );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          \n        \t      dif *= calcSoftshadow( pos, lig, 0.001, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n       \n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.3, 0.0 );\n    vec3 ro = ta + vec3( 1.2*sin(0.2*time + 5.0*mo.x), 0.2 + 5.0*mo.y, 1.2*cos(0.2*time + 5.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3( 0.0 );\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n\n        // focal length\n        const float fl = 3.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.95) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pi = 3.1415926535897932;\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdSphere( vec3 p, float s ){ return length(p)-s; }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCone( in vec3 p, in vec2 c, float h ){\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\nfloat sdHexPrism( vec3 p, vec2 h ){\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra){\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat rounding( in float d, in float h ) { return d - h; }\nvec2 opU( vec2 d1, vec2 d2 ){ return (d1.x<d2.x) ? d1 : d2; }\n\nvec3 rotateX( in vec3 p, float t ){\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t ){\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t ){\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    pos.x = abs(pos.x);\n    \n    int mat = 16;\n    { /* mech */\n    float s = 0.65; /* scale */\n    float legspread = 0.15*s;\n    float legangle = -0.25*s;\n    /* foot */\n    vec3 foot = vec3(0.02*s,0.05*s,0.06*s);\n    res = opU( res, vec2( rounding(sdBox( pos-vec3( legspread,0.0,-0.07*s), foot ), 0.025*s), mat ) );\n    /* toes */\n    vec3 toe = vec3(0.025*s,0.03*s,0.04*s);\n    res = opU( res, vec2( sdBox( pos-vec3( legspread+toe.z,0.0,-0.16*s), toe ), mat ) );\n    res = opU( res, vec2( sdBox( pos-vec3( legspread-toe.z,0.0,-0.16*s), toe ), mat ) );\n    res = opU( res, vec2( sdBox( pos-vec3( legspread,0.0,0.04*s), toe ), mat ) );\n    /* leg down */\n    vec3 leg = vec3(0.05*s,0.04*s,0.1*s);\n    res = opU( res, vec2( sdBox( rotateX(pos-vec3( legspread,0.1*s,0.0), legangle*pi), leg), mat ) );\n    /* leg up */\n    res = opU( res, vec2( sdBox( rotateX(pos-vec3( legspread,0.3*s,0.0), -legangle*pi), leg), mat ) );\n    /* knees */\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3( legspread,0.2*s,0.05*s), 0.5*pi), leg.x, leg.y ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3( legspread,0.2*s,0.05*s), 0.5*pi), 0.015*s, leg.y+0.01*s ), mat ) );\n    /* hip */\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3(0.0,0.38*s,-0.05*s), 0.5*pi), 0.045*s, 0.21*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3(0.0,0.38*s,-0.05*s), 0.5*pi), 0.015*s, 0.22*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3(0.0,0.38*s,-0.05*s), 0.5*pi), 0.065*s, 0.1*s ), mat ) );\n    /* belly */\n    res = opU( res, vec2( sdCappedCylinder( pos-vec3(0.0,0.42*s,-0.05*s), 0.08*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( pos-vec3(0.0,0.5*s,-0.05*s), 0.05*s, 0.05*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( pos-vec3(0.0,0.55*s,-0.05*s), 0.12*s, 0.04*s ), mat ) );\n    /* body */\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.0,0.62*s,-0.2*s), 0.43*pi), 0.1*s, 0.16*s, 0.23*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3(0.0,0.68*s,0.0), 0.5*pi), 0.09*s, 0.15*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateZ(pos-vec3(0.0,0.68*s,0.0), 0.5*pi), 0.05*s, 0.17*s ), mat ) );\n    /* missiles */\n    vec3 missile = vec3(0.09*s,0.06*s,0.1*s);\n    res = opU( res, vec2( rounding(sdBox( pos-vec3( 0.3*s,0.8*s,0.0), missile ), 0.01*s), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateX(pos-vec3( 0.22*s,0.74*s, 0.02*s), 0.5*pi), 0.04, 0.005 ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateX(pos-vec3( 0.22*s,0.74*s,-0.02*s), 0.5*pi), 0.04, 0.005 ), mat ) );\n    /* missile left */\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.24*s,0.8*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.3*s,0.8*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.36*s,0.8*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.27*s,0.84*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.33*s,0.84*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.27*s,0.76*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    res = opU( res, vec2( sdRoundCone( rotateX(pos-vec3(0.33*s,0.76*s,-0.16*s), 0.5*pi), 0.0, 0.018*s, 0.04*s ), mat ) );\n    /* arms */\n    res = opU( res, vec2( sdCapsule( pos-vec3( 0.16*s,0.68*s,0.0), vec3(0.0), vec3( 0.11*s,-0.12*s,-0.1*s), 0.03*s ), mat ) );        \n    res = opU( res, vec2( sdHexPrism( pos-vec3( 0.28*s,0.56*s,-0.2*s), vec2(0.03, 0.055) ), mat ) );\n    /*todo: subtrcat inner pipe */\n    res = opU( res, vec2( sdCappedCylinder( rotateX(pos-vec3( 0.28*s,0.58*s,-0.31*s), 0.5*pi), 0.018*s, 0.03*s ), mat ) );\n    res = opU( res, vec2( sdCappedCylinder( rotateX(pos-vec3( 0.28*s,0.54*s,-0.3*s), 0.5*pi), 0.008*s, 0.02*s ), mat ) );\n    /* back */\n    res = opU( res, vec2( sdRhombus( rotateZ(rotateX(pos-vec3( 0.1*s,0.72*s,0.18*s), 0.2*pi), 0.5*pi), 0.12*s, 0.05*s, 0.016*s, 0.03*s ), mat ) );\n    }\n    return res;\n}\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ){\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd ){\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.1;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }    \n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        \n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<48 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor, int ZERO ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcNormal(in vec3 pos, int ZERO){\n    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n        if( n.x+n.y+n.z>1.0 ) break;\n    }\n    return normalize(n);  \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ){\n    // bounding volume\n    float tp = (1.0-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<12; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.1,1.0);\n        res = min( res, s*s*(3.5-2.0*s) );\n        t += clamp( h, 0.001, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy ){\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n","name":"Common","description":"","type":"common"}]}