{"ver":"0.1","info":{"id":"sl3Bzs","date":"1663503387","viewed":121,"name":"box tree","username":"jt","description":"Recursively subdivides initial box into two (possibly overlapping) sub-boxes.\nInspired by iq's bounding volume hierarchy shaders but \"unrolling\" recursion.\nBlack screen? Try adjusting [b]#define box_tree[/b].\nSuggestions for optimization are welcome.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["volume","random","tree","box","bvh","hash","bounding","hierarchy","boxtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ft3BRs box tree by jt 2022-09-17\n// Recursively subdivides initial box into two (possibly overlapping) sub-boxes.\n// Inspired by iq's bounding volume hierarchy shaders but \"unrolling\" recursion.\n\n// box tree (c) 2022 by Jakob Thomsen is licensed under CC BY 4.0 \n\n// tags: box, tree, boxtree, BVH, bounding, volume, hierarchy, random, hash\n\n// NOTE: Black screen? Try adjusting the macro #define box_tree\n\n// TODO: fix z-fighting issue\n// TODO: why does adding iFrame to seed result in HALVED performance?!\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementation of Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementation of Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash1(uint x)\n{\n    //return float(triple32(x) & 0xffffffffU) / float(0xffffffffU);\n    return float(triple32(x)) / float(0xffffffffU);\n    //return float(lowbias32(x)) / float(0xffffffffU);\n}\n\nvec3 shash3(uint n)\n{\n    n *= 3u;\n    return 2.0 * vec3(hash1(n + 0u), hash1(n + 1u), hash1(n + 2u)) - 1.0;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 500.0\n\n#define pi 3.1415926\n\nvec2 box_intersection2(vec3 ro, vec3 rd, vec3 ext)\n{\n    vec3 m = -1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * ext;\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n    float tn = max(max(t1.x, t1.y), t1.z);\n    float tf = min(min(t2.x, t2.y), t2.z);\n    return (tn > tf || tf < 0.0) ? vec2(-1.0) : vec2(tn, tf);\n}\n\n// https://iquilezles.org/articles/boxfunctions\nfloat box_intersection(vec3 ro, vec3 rd, vec3 ext) \n{\n    vec3 m = -1.0/rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * ext;\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\tfloat tN = max(max( t1.x, t1.y), t1.z);\n\tfloat tF = min(min( t2.x, t2.y), t2.z);\n\treturn (tN > tF || tF < 0.0) ? -1.0 : tN;\n}\n\nvec3 box_normal(vec3 p, vec3 e)\n{\n    vec3 d = abs(p) - e;\n    vec4 s = vec4(vec3(sign(p)), 0);\n\n    //return (d.z > d.y && d.z > d.x) ? vec3(0, 0, s.z) : (d.y > d.x) ? vec3(0, s.y, 0) : vec3(s.x, 0, 0);\n    return d.z > d.y && d.z > d.x ? s.wwz : d.y > d.x ? s.wyw : s.xww;\n}\n\nvec4 box(vec3 ro, vec3 rd, vec3 e) // returns normal & distance\n{\n    float t = box_intersection(ro, rd, e);\n    if(t > 0.0)\n    {\n        vec3 d = ro + rd * t;\n        vec3 n = box_normal(d, e);\n\n        return vec4(n, t); // object hit? return object normal.\n    }\n\n    return vec4(vec3(-rd), DIST_MAX); // object missed? return sky-sphere normal.\n}\n\n// \"unrolled\" recursion (could be written in compact form if ## in macros was supported)\nvec4 box_tree0(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    vec4 r = box(ro, rd, e);\n    r.xyz *= float(n); // normal has unit length so we can use length to encode object index\n    return r;\n}\n\nvec4 box_tree1(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree0(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree0(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree2(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree1(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree1(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree3(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree2(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree2(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree4(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree3(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree3(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree5(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree4(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree4(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree6(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree5(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree5(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree7(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec3 ro0 = ro + o0;\n    vec3 ro1 = ro + o1;\n    vec3 e0 = e - abs(o0);\n    vec3 e1 = e - abs(o1);\n    float b0 = box_intersection(ro0, rd, e0); // bounding box\n    float b1 = box_intersection(ro1, rd, e1); // bounding box\n    vec4 i0 = b0 < DIST_MAX ? box_tree6(ro0, rd, e0, n0 * 3u) : vec4(-rd, DIST_MAX);\n    vec4 i1 = b1 < DIST_MAX ? box_tree6(ro1, rd, e1, n1 * 3u) : vec4(-rd, DIST_MAX);\n    return i0.w < i1.w ? i0 : i1;\n}\n\nvec4 box_tree8(vec3 ro, vec3 rd, vec3 e, uint n)\n{\n    uint n0 = n * 2u;\n    uint n1 = n0 + 1u;\n    vec3 e2 = e / 2.0;\n    vec3 o0 = e2 * shash3(n0);\n    vec3 o1 = e2 * shash3(n1);\n    vec4 i0 = box_tree7(ro + o0, rd, e - abs(o0), n0 * 3u);\n    vec4 i1 = box_tree7(ro + o1, rd, e - abs(o1), n1 * 3u);\n    return i0.w < i1.w ? i0 : i1;\n}\n\n/*\n#define box_tree(caller, callee) \\\nvec4 box_tree ## caller(vec3 ro, vec3 rd, vec3 e, uint n) \\\n{ \\\n    uint n0 = n * 6u + 0u; \\\n    uint n1 = n * 6u + 3u; \\\n    vec3 e2 = e / 2.0; \\\n    vec3 o0 = e2 * vec3(shash1(n0 + 0u), shash1(n0 + 1u), shash1(n0 + 2u)); \\\n    vec3 o1 = e2 * vec3(shash1(n1 + 0u), shash1(n1 + 1u), shash1(n1 + 2u)); \\\n    vec4 i0 = box_tree ## callee(ro + o0, rd, e - abs(o0), n0); \\\n    vec4 i1 = box_tree ## callee(ro + o1, rd, e - abs(o1), n1); \\\n    return i0.w < i1.w ? i0 : i1; \\\n} \\\n// end macro\n\nbox_tree(3,2) // \"'x' invalid character\"\n*/\n\n// choose by performance of your PC\n//#define box_tree box_tree0\n//#define box_tree box_tree1\n//#define box_tree box_tree2\n//#define box_tree box_tree3\n//#define box_tree box_tree4\n//#define box_tree box_tree5\n#define box_tree box_tree6\n//#define box_tree box_tree7\n//#define box_tree box_tree8\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ndc = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    vec2 m = length(iMouse.xy) <= 10. // click in lower left corner...\n           ? pi * vec2(0.2+2.0 * fract(iTime * 0.01), 2.5 / 4.0) // ...for demo mode\n           : pi * vec2(2.0 * iMouse.x / iResolution.x, 1.0 - 0.5 * iMouse.y / iResolution.y); // mouse look\n\n    mat2 R = mat2(cos(m.x), sin(m.x), -sin(m.x), cos(m.x));\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    mat2 S = mat2(cos(m.y), sin(m.y), -sin(m.y), cos(m.y));\n    ro.yz = S * ro.yz;\n    ro.xy = R * ro.xy;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = S * rd.yz;\n    rd.xy = R * rd.xy;\n\n    vec3 color = vec3(0);\n\n    vec3 e = vec3(1,1,1); // dimensions of outermost box\n    uint seed = 130u;\n    //uint seed = 130u + uint(iFrame/100); // XXX adding iFrame to seed more than HALVES performance on my PC - WHY?! XXX\n    vec4 r = box_tree(ro, rd, e, seed);\n\n    if(r.w > 0.0 && r.w < DIST_MAX)\n    {\n        vec3 lightdir = normalize(vec3(1,2,3));\n\n        // unpack index*normal\n        float l = length(vec3(r));\n        uint i = uint(floor(l)); // retrieve index\n        r.xyz /= l; // retrieve normal\n\n        vec3 d = ro + rd * r.w;\n\n        //color = vec3(1.0); // plain\n        color = vec3(hash1(i + 0u), hash1(i + 1u), hash1(i + 2u)); // random color based on index\n        //color = 0.5 + 0.5 * vec3(r); // normals color\n\n        float ambient = .01;\n        float diffuse = max(0.0, dot(lightdir, vec3(r))); // one-sided light\n        //float diffuse = abs(dot(lightdir, vec3(r))); // two-sided light\n\n        if(box_tree(d + vec3(r) * EPSILON, lightdir, e, seed).w < DIST_MAX) diffuse = 0.0; // shadow\n        \n        color *= ambient + diffuse;\n    }\n\n    fragColor = (r.w > 0.0 && r.w < DIST_MAX) ? vec4(color, 1.0) : vec4(0.0);\n    fragColor = sqrt(fragColor); // approximate gamma\n}\n","name":"Image","description":"","type":"image"}]}