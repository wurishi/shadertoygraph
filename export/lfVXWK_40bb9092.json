{"ver":"0.1","info":{"id":"lfVXWK","date":"1715800131","viewed":25,"name":"Cylinderraymarchdemo","username":"Teomik","description":"Cylinder made by using raymarch and sdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","simpleshapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.  \n#define SURF_DIST .01\n//dot because of float and integer\n  float sdcylinder (vec3 p,vec3 a, vec3 b, float r){\n  vec3 ab = b-a;\n  vec3 ap = p-a;\n  float t = dot(ab,ap)/ dot(ab,ab);\n  //t = clamp (t,0.,1.);\n  vec3 c = a +t*ab;\n  float x = length(p-c) - r;\n  float y = (abs(t-.5)-.5)*length(ab);\n  float e = length(max(vec2(x,y),0.));\n  float i = min(max(x,y),0.);\n  return e+i;\n  }\nfloat GetDist(vec3 p) {\n vec4 s =vec4(0,1,6,1);\n float planeDist = p.y;\n float cd = sdcylinder(p,vec3 (0,1,6),vec3 (1,2,6),.2); //cd - capsule  distance\n float cylind = sdcylinder (p,vec3 (0,.3,3),vec3 (3,1,5),.3);\n float d = min(planeDist,cylind);\n\n return d;\n }\nfloat RayMarch(vec3 ro,vec3 rd){ // raymarching\n  float dO =0.;\n  for(int i=0;i<MAX_STEPS;i++){\n  vec3 p = ro +rd*dO;\n  float ds = GetDist(p);\n  dO+=ds;\n  if(dO>MAX_DIST || ds<SURF_DIST) break;\n  }\n  return dO;\n}\nvec3 GetNormal(vec3 p){  //light\n float d = GetDist(p);\n vec2 e = vec2 (.01,0.);\n vec3 n = d - vec3(\n GetDist(p-e.xyy),\n GetDist(p-e.yxy),\n GetDist (p-e.yyx));\n return normalize (n);\n}\n float GetLight (vec3 p){  //light\n vec3 lightPos = vec3 (0,5,6);\n lightPos.xz+= vec2(sin(iTime),cos(iTime))*2.;\n vec3 l =normalize(lightPos-p);\n vec3 n = GetNormal(p);\n  float dif = clamp(dot(n,l), 0.,1.);  // n-normal, l-light //clamp - hold the values\n  float d = RayMarch(p+n*SURF_DIST*2.,l);   //shadow\n  if(d<length(lightPos-p)) dif*=.1;   //shadow\n return dif;\n \n }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; //middle\n\n    // Time varying pixel color\n    vec3 col =vec3(0);\n    vec3 ro = vec3 (0,1,0);\n    vec3 rd =normalize(vec3(uv.x,uv.y,1)); //check by deleting the normalize function (NORMALIZE MEANS THAT A LENGTH IS SETTING TO 1); \n    float d = RayMarch(ro,rd);\n    vec3 p =ro + rd*d;\n    float dif = GetLight(p);\n    d/=9.;\n    col = vec3(dif);\n    \n   \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}