{"ver":"0.1","info":{"id":"l3KGRm","date":"1717459888","viewed":114,"name":"sphere intersection antialiasing","username":"01000001","description":"code is messy and the way I encoded ray distance from centre sucks in so many ways because I was too lazy to do it right... but it works. And it's nearly free.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["thingy"],"hasliked":0,"parentid":"M3cGR4","parentname":"fresnelÕè"},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define zoom (sin(iTime)*2. + 4.)\n\nvec4 sphere(vec3 o, vec3 dirV){    \n    \n    /*\n    float a = dot(dirV, dirV);\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return vec4(-1);\n    return vec4((-b-sqrt(det))/(2.*a));\n    */\n    \n    /*\n    //value of a is always 1 if dirV is normalized so we can ignore it\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*c;\n    if (det < 0.) return vec4(-1);\n    return vec4((-b-sqrt(det))/2.);\n    */\n    \n    /*\n    //Adding t and normal calculation\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*c;\n    if (det < 0.) return vec4(-1);\n    float t = (-b-sqrt(det))/2.;\n    return vec4(t, o+dirV*t);\n    */\n    \n    // now here we find a clever optimization.\n    // the coeff. 2 in b is squared in det to give 4, and\n    // the det also has a -4 coeff. being subtracted. So we can \n    // bring the 4 outside the det\n    // the det is then square rooted, so we can bring the coeff. of 4\n    // outside as a 2.\n    // Now b was also multiplied by 2, so we can remove the 2 from both terms\n    // and bring it outside, where it is divided by 2, leaving 1, aka nothing\n    // Crazy stuff!\n    /*\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*c;\n    if (det < 0.) return vec4(-1);\n    float t = (-b-sqrt(det))/2.;\n    return vec4(t, o+dirV*t);\n    */\n    \n    float b = (dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - c;\n    if (det < 0.) return vec4(-1);\n    float t = (-b-sqrt(det));\n    return vec4(t, (o+dirV*t)*(1.+det));\n\n\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y * 3.;\n    \n    if (abs(uv.x - .5) < 2./r.x){\n        O = vec4(1);\n        return;\n    }\n    \n    vec3 o = vec3(0);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*\n    #ifdef zoom\n    zoom*zoom*.6\n    #else\n    5.\n    #endif\n    ;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec2 camUV = cuv \n    #ifdef zoom\n    / zoom\n    #else\n    * .3\n    #endif\n    ;\n    vec3 dirV = vec3(sin(camUV.x)*cos(camUV.y), cos(camUV.x)*cos(camUV.y), sin(camUV.y));\n    dirV = normalize(dir * dirV.y + right * dirV.x + up * dirV.z);\n\n\n    \n    vec4 s = sphere(o, dirV);\n    if (s.x < 0.){\n        O = texture(iChannel0, dirV);\n        return;\n    }\n    vec3 norm = normalize(s.yzw);\n    O = mix(\n        vec4(pow(max(0., dot(norm, vec3(0,0,1))*.4+.6), 1./2.2)), \n        texture(iChannel0, reflect(dirV, norm)), \n        vec4(pow(1.+dot(norm, dirV), 5.))\n    );\n    \n    if (uv.x > .5) \n        O = mix(O, texture(iChannel0, dirV), smoothstep(1. - s.x/r.x*10.\n        #ifdef zoom\n        /zoom\n        #else\n        *.3\n        #endif\n        , 1., 2.-length(s.yzw)));\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = texture(iChannel0, rayDir.xzy);\n}","name":"Cube A","description":"","type":"cubemap"}]}