{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float hash21(vec2 p) {\n    p = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.283185*(c*t+d) );\n}\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\nfloat smoothSquareWave(in float x, in float b) {\n    return sin(x) / sqrt(b * b + sin(x)*sin(x));\n}\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 10.;\n    uv.y += iTime;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 gv = fract(uv / 2.0) - 0.5;\n    vec2 id = floor(uv / 2.0);\n    \n    float n = hash21(id);\n    \n    if (n < 0.5) {        \n        gv = fract(uv) - 0.5;\n        id = floor(uv);\n    \n        n = hash21(id);\n    } else if (n < 0.75) {        \n        gv = fract(uv * 2.0) - 0.5;\n        id = floor(uv * 2.0);\n    \n        n = hash21(id);\n    }\n    \n    float modifier = 0.01;\n    float f = smoothSquareWave(iTime * 3.1415926535 * n * 0.02, 0.3 * modifier);\n    \n    gv.y /= f;\n    \n    //if (gv.x > 0.4 || gv.y > 0.4) col.r = 1.0;\n    float width = 0.3;\n    col += smoothstep(0.01, -0.01, abs(length(gv) - 0.5 + width) - width);\n    \n    col *= palette(n, vec3(0.5, 0.5, 0.5),vec3(0.5, 0.5, 0.5),vec3(1.0, 1.0, 1.0),vec3(0.30, 0.20, 0.20));\n    \n    if (n < 0.1) {\n        col = vec3(smoothstep(0.01, -0.01, length(gv) - 0.5)) * vec3(0.651, 0.651, 0.749);\n        col += smoothstep(0.01, -0.01, sdRoundedX(gv * rot(iTime + n), 0.4, 0.05));\n    } else if (n < 0.2) {\n        col += smoothstep(0.01, -0.01, sdHeart((gv * vec2(1.0, -1.0) + vec2(0.0, 0.3)) * 2.0)) * n;\n    } else if (n < 0.3) {\n        col += smoothstep(0.01, -0.01, sdStar5(gv, 0.4, 0.45)) * n;\n    }\n    \n    if (n > 0.95) {\n        col -= smoothstep(0.01, -0.01, sdUnevenCapsule(gv * vec2(1.0, -1.0) + vec2(0.0, 0.3), 0.01, 0.2, 0.4)) * n * 0.1;\n    }\n    //col *= vec3(1.0, 0.0, 0.0) * f + vec3(1.0) * (1.0 - f);\n    //if (uv.y - iTime < f) col = vec3(1.0, 0.0, 0.0);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcGBWG","date":"1734388554","viewed":44,"name":"circular tiles","username":"noxfy","description":":3","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tiles","symbols"],"hasliked":0,"parentid":"","parentname":""}}