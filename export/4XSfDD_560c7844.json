{"ver":"0.1","info":{"id":"4XSfDD","date":"1729796148","viewed":70,"name":"Dotted torus","username":"Konod","description":"A reconstruction of this animation from @Yumegaku: https://x.com/Yugemaku/status/1847452018681798961\nThis motion had been haunting my dreams for days, and I wanted to take up the challenge of reproducing it using maths, so here it is! ^^","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","differential","torusgeometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float torusSDF( vec3 p ) {\n    vec2 q = vec2(length(p.xz) - TORUSLARGERAD, p.y);\n  return length(q) - TORUSSMALLRAD;\n}\n\nvec3 torusSDFNormal(vec3 p) {\n    float l = length(p.xz);\n    vec2 q = vec2(l - TORUSLARGERAD, p.y);\n    vec3 n = vec3(q.x * p.x, q.x * p.z, q.y * l);\n    return normalize(n);\n}\n\nfloat displaceCoord(float x) {\n    float newX = mod(x - ROTATIONSPEED * iTime, 1.f);\n    return (newX < LAUNCHOFFSET)\n        ? 0.f\n        : pow((newX - LAUNCHOFFSET), POWER) /pow((1.f - LAUNCHOFFSET), POWER);\n}\n\nfloat derivativeDisplaceCoord(float x) {\n    float newX = mod(x - ROTATIONSPEED * iTime, 1.f);\n    return (newX < LAUNCHOFFSET)\n        ? 0.f\n        : POWER * pow((newX - LAUNCHOFFSET), POWER - 1.f) / pow((1.f - LAUNCHOFFSET), POWER);\n}\n\nvec2 recenteredCoordFromTopoCoord(vec2 coord) {\n    vec2 normalizedCoord = coord + vec2(0, displaceCoord(coord.y)); // normalizedCoord.y is now between 0 and 2.\n    vec2 rotatedCoord = vec2(0.8f * normalizedCoord.x - 0.6f * normalizedCoord.y,\n                            0.6f * normalizedCoord.x + 0.8f * normalizedCoord.y);\n    vec2 rescaledCoord = mod(rotatedCoord * GRIDRESCALING, 1.f);\n    \n    vec2 recenteredCoord = rescaledCoord - 0.5f;\n    \n    return recenteredCoord;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    \n    // Raymarching\n    vec3 pos = CAMERAPOS;\n    vec3 dir = normalize(vec3(uv, FOCAL));\n    float hit = 0.f;\n    dir = vec3(dir.x,\n                COSA * dir.y - SINA * dir.z,\n                SINA * dir.y + COSA * dir.z);\n    \n    for (float i = 0.f; i++ < 200.f;) {\n        float d = torusSDF(pos);\n        if (d < SDFTHRESHOLD) {\n            hit = 1.f;\n            break;\n        }\n        pos += d * dir;\n    }\n    \n    // Parametrization of the torus\n    vec3 normal = torusSDFNormal(pos);\n    \n    vec2 coord = vec2(-asin(normal.z), atan(normal.x, normal.y));\n    if (pos.x * pos.x + pos.z * pos.z < TORUSLARGERADSQUARE) {\n        coord.x = PI - coord.x;\n        coord.y += PI;\n    }\n    if (coord.x < 0.f) {\n        coord.x += TWO_PI;\n    }\n    if (coord.y < 0.f) {\n        coord.y += TWO_PI;\n    }\n    \n    vec2 normalizedCoord = coord / TWO_PI;\n    \n    // Transformation of the parameters/coordinates\n    \n    vec2 recenteredCoord = recenteredCoordFromTopoCoord(normalizedCoord);\n    \n    vec2 destretchedCoord = recenteredCoord;\n    destretchedCoord /= GRIDRESCALING;\n    \n    destretchedCoord = vec2(0.8 * destretchedCoord.x + 0.6 * destretchedCoord.y,\n                            -0.6 * destretchedCoord.x + 0.8 * destretchedCoord.y);\n    destretchedCoord.y /= 1.f + derivativeDisplaceCoord(normalizedCoord.y);\n    destretchedCoord /=  TWO_PI * vec2(TORUSLARGERAD + 0.f * TORUSSMALLRAD * cos(coord.x), TORUSSMALLRAD);\n    \n    fragColor = hit * vec4(step(length(destretchedCoord), POINTRAD));\n    //fragColor = vec4(cos(coord.xxx), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define LOOK_FROM_BOTTOM\n\nconst float PI = 3.1415926536f;\nconst float TWO_PI = 6.283185307f;\n\nconst float FOCAL = 1.8f;\n#ifdef LOOK_FROM_BOTTOM\nconst float CAMERAANGLE = -0.7f;\nconst vec3 CAMERAPOS = vec3(0.f, -0.4f, -0.8f);\n#else\nconst float CAMERAANGLE = 0.7f;\nconst vec3 CAMERAPOS = vec3(0.f, 0.4f, -0.7f);\n#endif\n\nconst float COSA = cos(CAMERAANGLE);\nconst float SINA = sin(CAMERAANGLE);\n\nconst float SDFTHRESHOLD = 0.001f;\n\nconst float TORUSSMALLRAD = 0.12f;\nconst float TORUSLARGERAD = 0.4f;\nconst float TORUSLARGERADSQUARE = TORUSLARGERAD*TORUSLARGERAD;\n\nconst vec2 GRIDRESCALING = vec2(15, 40 / 2); //Both numbers should be a multiple of 5 in order to have a continuous periodicity.\nconst float POINTRAD = 0.006;\n\nconst float ROTATIONSPEED = 0.15f;\nconst float LAUNCHOFFSET = 0.3f;\nconst float POWER = 4.f;","name":"Common","description":"","type":"common"}]}