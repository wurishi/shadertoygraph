{"ver":"0.1","info":{"id":"MftyDj","date":"1731296430","viewed":51,"name":"RT w/ structs + DL Sampling","username":"brickdude","description":"fork of my first try with ray tracing","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","spheres"],"hasliked":0,"parentid":"lcdcDS","parentname":"raytracing with structs"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a fork of my first raytracing attempt\n// The difference with this one is that I've tried to implement \"Direct Light Sampling\".\n// I saw it and was interested after studying this implementation:\n//    > https://www.shadertoy.com/view/4tl3z4\n\n#define GAMMA 2.5 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 result = texture(iChannel0, uv);\n    \n    // Color correction\n    result.xyz = pow(result.xyz, vec3(1.0 / GAMMA));\n    \n    // Output to screen\n    fragColor = vec4(result.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// OBJECTS --------------\nstruct Camera\n{\n    vec3 pos;\n    vec3 facing;\n    float zoom;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Material\n{\n    vec3 color;\n    float roughness, emission;\n    bool metallic;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n    Material mat;\n};\n\nstruct Plane\n{\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Intersect\n{\n    vec2 distances;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Bounce\n{\n    Material mat;\n    Ray bouncedRay;\n    bool bounced;\n    vec3 normal;\n};\n\n// CONSTANTS\nconst float PI = 3.1415926;\nconst float INFINITY = 1.0 / 0.000001;\nconst float INV_SQRT_2PI = 0.39894228;\nconst float EPSILON = 0.001;\n\n// UTILITIES ------------\n\n// RANDOM / HASH\n\nfloat rand(inout float seed)\n{\n    return fract(sin(seed += 0.1237) * 4933.288);\n}\n\nvec3 rand3(inout float seed)\n{\n    return fract(sin(vec3(seed += 0.1237, seed += 0.1237, seed += 0.1237)) * 3721.5325);\n}\n\nvec4 hash4(float id)\n{\n    return fract(sin(vec4(id)) * vec4(49533.288, 24353.4533, 73132.277, 6546.435));\n}\n\nvec3 hash3(float id)\n{\n    return fract(sin(vec3(id)) * vec3(49533.288, 24353.4533, 73132.277));\n}\n\nfloat hash(float id)\n{\n    return fract(sin(id) * 49533.288);\n}\n\n// Render object utils\nCamera cameraLookAt(Camera cam, vec3 target)\n{\n    vec3 newDir = normalize(target - cam.pos);\n    \n    return Camera( cam.pos, newDir, cam.zoom );\n}\n\nvec3 rotateCamVec(vec3 vec, vec3 facing)\n{   \n    // I learned this trick a while ago from learnopengl.com in the normal mapping section\n    // Again, not perfect, but does the trick so\n    vec3 n = normalize(facing);\n    vec3 t = normalize(cross(n, vec3(0.0, 1.0, 0.0)));\n    vec3 b = normalize(cross(t, n));\n    \n    mat3 tbn = transpose(inverse(mat3(t, b, n)));\n    \n    return tbn * vec;\n}\n\nRay getCameraRay(Camera cam, vec2 uv)\n{\n    vec3 rayDir = normalize(vec3(uv, cam.zoom));\n    rayDir = rotateCamVec(rayDir, cam.facing);\n    return Ray( cam.pos, normalize(rayDir) );\n}\n\n\n// COLOR UTILS ------------------\n\nfloat getColorLightness(vec3 color)\n{\n    return dot(color, vec3(0.44, 0.69, 0.23));\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\n// INTERSECT FUNCS ---------------\nIntersect raySphere(Sphere sphere, Ray ray)\n{\n    vec3 between = sphere.pos - ray.origin;\n    float dToClosest = dot(between, ray.dir);\n    float cSquared = dot(between, between) - sphere.radius * sphere.radius;\n    float hSquared = dToClosest*dToClosest - cSquared;\n    \n    if (hSquared < 0.0)\n        return Intersect(vec2(-1.0), vec3(0.0), sphere.mat);\n    \n    float h = sqrt(hSquared);\n    vec2 distances = vec2(dToClosest - h, dToClosest + h);\n    return Intersect(\n        distances,\n        normalize((ray.origin + ray.dir * min(distances.x, distances.y)) - sphere.pos),\n        sphere.mat\n    );\n}\n\n\nIntersect rayPlane(Plane plane, Ray ray)\n{\n    float dToPlane = dot(ray.origin - plane.pos, plane.normal);\n    if (dToPlane < 0.0)\n        return Intersect(\n            vec2(-1.0),\n            plane.normal,\n            plane.mat\n        );\n    \n    float dIntersect = dToPlane / dot(ray.dir, -plane.normal);\n    \n    return Intersect(\n        vec2(dIntersect),\n        plane.normal,\n        plane.mat\n    );\n}\n\n\nBounce raySky(Ray ray, samplerCube skybox, bool useSkybox)\n{\n    vec3 color = vec3(1.0);\n    if (useSkybox)\n    {\n        // Skybox\n        color = texture(skybox, ray.dir).xyz;\n    } else {\n        // Sky color\n        float skyMixFactor = pow(max(ray.dir.y - 0.01, 0.0), 0.3);\n        vec3 skyColor = vec3(0.75, 0.83, 1.0);\n        vec3 horizonColor = vec3(1.0, 0.75, 0.55);\n        vec3 voidColor = horizonColor * vec3(1.0, 0.75, 0.5) * 0.15;\n        color = mix(mix(voidColor, horizonColor, skyMixFactor), skyColor, skyMixFactor);\n\n        // Sun spot\n        vec3 sunColor = vec3(1.0, 0.98, 0.65);\n        vec3 sunDir = normalize(vec3(0.5, 0.25, -0.3));\n        color += sunColor * pow(max(dot(ray.dir, sunDir), 0.0), 1000.0);\n    \n    }\n    \n    //color = vec3(0.0);\n\n    // Material\n    Material mat = Material(color, 0.0, 0.0, false);\n    \n    return Bounce(mat, ray, false, vec3(0.0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// NOTE: Look in \"Common\" for object and utility definitions :)\n\n#define NUM_SPHERES 8\n#define TIMESCALE 1.0\n#define MAX_BOUNCES 3\n#define NUM_SAMPLES 1\n#define SHUTTER_FPS 60.0\n\n#define USE_SKYBOX true\n\nfloat SEED = 1.0; // Seed for the noise\n\nSphere balls[NUM_SPHERES];\n\nPlane getGround()\n{\n    vec3 groundColor = vec3(1.0);//vec3(0.65, 0.98, 0.43);\n    Material mat = Material(groundColor, 0.05, 0.0, false);\n    \n    return Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), mat);\n}\n\nBounce getIntersectionBounce(Bounce prevResult, Ray ray, Intersect inter, inout float minDist)\n{\n    float interDist = min(inter.distances.x, inter.distances.y);\n    if (0.01 < interDist && interDist < minDist)\n    {\n        minDist = interDist;\n    \n        // Wobble the normal based on roughness\n        vec3 hemisphere = rand3(SEED) * 2.0 - 1.0;\n        // Flipping this lets us pretend our bounce was nice and actually bounced off the object instead of being absorbed.\n        hemisphere *= sign(dot(hemisphere, inter.normal));\n        \n        vec3 wNorm = normalize(inter.normal + inter.mat.roughness * hemisphere);\n\n        vec3 reflectDir = reflect(ray.dir, wNorm);\n        vec3 newOrigin = ray.origin + ray.dir * interDist;\n        newOrigin += inter.normal * 0.001;\n\n        return Bounce(inter.mat, Ray(newOrigin, reflectDir), true, inter.normal);\n    }\n    return prevResult;\n}\n\nBounce rayScene(Ray ray, float time, inout float minDist)\n{   \n    minDist = min(INFINITY, minDist);\n    // Sky\n    Bounce result = raySky(ray, iChannel0, USE_SKYBOX);\n    // Ground\n    Plane ground = getGround();\n    Intersect gInter = rayPlane(ground, ray);\n    result = getIntersectionBounce(result, ray, gInter, minDist);\n    \n    // Spheres\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        Sphere sphere = balls[i];\n        Intersect inter = raySphere(sphere, ray);\n        result = getIntersectionBounce(result, ray, inter, minDist);\n    }\n    \n    return result;\n}\n\nfloat raySceneDepth(Ray ray)\n{\n    \n    float depth = INFINITY; // starting at sky depth (infinity)\n    \n    // Intersect with ground plane\n    Plane ground = getGround();\n    Intersect gInter = rayPlane(ground, ray);\n    \n    if (min(gInter.distances.x, gInter.distances.y) > 0.0)\n        depth = min(depth, min(gInter.distances.x, gInter.distances.y));\n    \n    // Balls\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        // Intersect the ray with the sphere\n        Sphere sphere = balls[i];\n        \n        // Ignore emissive spheres\n        if (!(sphere.mat.emission > 0.0))\n        {\n            Intersect inter = raySphere(sphere, ray);\n            if (min(inter.distances.x, inter.distances.y) > 0.0)\n                depth = min(depth, min(inter.distances.x, inter.distances.y));\n        }\n    }\n    \n    return depth;\n}\n\nvec3 randomPointOnSphere(Sphere s)\n{\n    return s.pos + normalize(rand3(SEED) * 2.0 - 1.0) * s.radius;\n}\n\nvec3 directLightAtBounce(Bounce b)\n{\n    vec3 result = vec3(0.0);\n    // Sample the skybox in a random direction\n    vec3 randSkyDir = normalize(rand3(SEED));\n    float skyShadowDist = raySceneDepth(Ray( b.bouncedRay.origin, randSkyDir ));\n    if (skyShadowDist >= INFINITY - EPSILON)\n        result += max(dot(b.normal, randSkyDir), 0.0) * b.mat.color * raySky(Ray( b.bouncedRay.origin, randSkyDir ), iChannel0, USE_SKYBOX).mat.color;\n    \n    // Check all spheres for if they are emissive\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        Sphere sphere = balls[i];\n        \n        if (sphere.mat.emission > 0.0)\n        {\n            // Pick a random point on the sphere\n            vec3 target = randomPointOnSphere(sphere);\n            vec3 toTarget = target - b.bouncedRay.origin;\n            float targetDist = length(toTarget);\n            \n            // Sample distance to the sphere\n            Ray r = Ray( b.bouncedRay.origin, normalize(toTarget) );\n            float dist = raySceneDepth(r);\n            \n            // If the distance is less than dist to target, contribute its light\n            if (dist >= targetDist - EPSILON)\n            {\n                float sphereContrib = sqrt(1.0 - max(sphere.radius*sphere.radius / (targetDist*targetDist), 0.0));\n                sphereContrib = 2.0 * max(1.0 - sphereContrib, 0.0);\n                result += b.mat.color * max(dot(b.normal, normalize(toTarget)), 0.0) * (sphereContrib * sphere.mat.color * sphere.mat.emission);\n            }\n        }\n    }\n    \n    return result;\n}\n\nvec4 RenderScene(Ray cameraRay, vec2 uv, float time)\n{\n    vec3 result = vec3(1.0, 0.0, 0.0);\n    \n    // Sample the scene\n    Bounce path[MAX_BOUNCES];\n    Ray lastRay = cameraRay;\n    int numBounces = 0;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float rayDepth = INFINITY;\n        path[i] = rayScene(lastRay, time, rayDepth);\n        // We only need the depth from the first bounce\n        if (i == 0)\n            minDist = rayDepth;\n        \n        if (path[i].bounced)\n        {\n            numBounces++;\n            lastRay = path[i].bouncedRay;\n        }\n        result = path[i].mat.color;\n    }\n    \n    // Reverse through path array and do light calculations\n    for (int i = 0; i < numBounces; i++)\n    {\n        Bounce b = path[numBounces - 1 - i];\n        float cosTheta = max(dot(b.bouncedRay.dir, b.normal), 0.0);\n        \n        // Get fresnel\n        vec3 F0 = vec3(0.04);\n        F0 = mix(F0, b.mat.color, b.mat.metallic ? 1.0 : 0.0);\n        vec3 f = fresnelSchlick(cosTheta, F0);\n        \n        vec3 specular = f * (1.0 - b.mat.roughness);\n        vec3 diffuse = 1.0 - specular;\n        diffuse *= b.mat.metallic ? 0.0 : 1.0;\n        \n        // Diffuse and specular light\n        result = (b.mat.emission * b.mat.color)                         // EMISSION\n                + (specular * result)                                   // SPECULAR\n                + (b.mat.color * diffuse / PI + f) * cosTheta * result; // DIFFUSE\n        \n        // DIRECT LIGHT SAMPLING\n        result += diffuse * directLightAtBounce(b);\n        \n    }\n    \n    // Put scene depth in w component\n    return vec4(result, minDist);\n}\n\n\n\n// SCENE INITIALIZATION: ----------------\n\nvec3 getCamPos(float time)\n{\n    return 3.0 * vec3(cos(time), 0.5, sin(time)) + vec3(0.0, 0.5 * (sin(time * 3.0) * 0.5 + 0.51), 0.0);\n}\n\nvec3 getSpherePos(float time, vec4 nums, float radius)\n{\n    float height = fract(nums.w * 13.13);\n    float sqrtH = sqrt(height);\n    \n    height = height - pow(fract((time + sqrtH) / 2.0 / sqrtH) * 2.0 * sqrtH - sqrtH, 2.0);\n    \n    vec3 sPos = 2.5 * vec3(hash(nums.y) * 2.0 - 1.0, height, nums.x * 2.0 - 1.0);\n    sPos.y += radius;\n    // Rotate them randomly around the center\n    //return rotateCamVec(sPos, vec3(\n    //    nums.z * cos(nums.z * 1.432 * time), \n    //    0.0,\n    //    nums.y * sin(nums.y * time + 13.13))\n    //);\n    return sPos;\n}\n\nSphere getSphere(int id, float time)\n{\n    vec4 nums = hash4(float(id));\n    float radius = pow(nums.w, 0.25) * 0.5;\n    vec3 pos = getSpherePos(time, nums, radius);\n    \n    // Move the sphere randomly along its path given the shutter period (to simulate motion blur)\n    vec3 sphVelocity = pos - getSpherePos(time - (1.0 / SHUTTER_FPS), nums, radius);\n    pos -= sphVelocity * rand(SEED);\n    \n    vec3 color = nums.xyz; //vec3(1.0, 0.898, 0.62);\n    float roughness = pow(nums.w, 6.0);\n    float emission = hash(dot(nums, nums));\n    emission = (emission < 0.3 ? max(emission, 0.7) : 0.0) * 15.0;\n    Material mat = Material(color, roughness, emission, nums.y > 0.5);\n    \n    return Sphere(pos, radius, mat);\n}\n\nvoid initBalls(float time)\n{\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        balls[i] = getSphere(i, time);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Offset seed using time and uv\n    vec2 sacrifice = fragCoord.xy / iResolution.xy;\n    SEED += iTime + dot(vec2(rand(sacrifice.x), rand(sacrifice.y)), sacrifice);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float time = iTime * TIMESCALE;\n    \n    // Initialize the scene\n    initBalls(time);\n    //vec3 pos = vec3(5.0 * cos(time), 0.0, 5.0 * sin(time));\n    vec3 pos = getCamPos(time / 3.0);\n    Camera cam = Camera(pos, vec3(0.0, 0.0, -1.0), 2.0); // waaaayyyy zoomed in\n    cam = cameraLookAt(cam, vec3(0.0, 0.25, 0.0));\n    \n    // RENDERING\n    Ray cameraRay = getCameraRay(cam, uv);\n    \n    vec4 result = vec4(0.0);\n    float firstDist = 0.0;\n    \n    // Render a few samples and get the average\n    for (int i = 0; i < NUM_SAMPLES; i++)\n    {\n        // EXPERIMENT: wobbling the camera ray for anti-aliasing?\n        vec3 pixelNums = rand3(SEED);\n        Ray ray = Ray(cameraRay.origin, normalize(1000.0 * cameraRay.dir + (pixelNums.xyz * 2.0 - 1.0)));\n        vec4 render = RenderScene(ray, uv, time);\n        result += render;\n    }\n    \n    result /= float(NUM_SAMPLES);\n    \n    // Output to screen\n    fragColor = result;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}