{"ver":"0.1","info":{"id":"Dt2SRG","date":"1677025161","viewed":185,"name":"Fork tiled nois with webcam","username":"shiyuugo","description":"tiled noises textures","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"Dl2Gzz","parentname":"tiled noise textures"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define RANDOM_COLOR\n#define AUTO_LIGHT\n#define WEBCAM\n\nconst float digi =.12;\n\nfloat calcHeight(vec2 uv){\n    int id = int(floor(uv.x/digi) + floor(uv.y/digi)*iResolution.x);\n    float rnd =random(float(id));\n    float s = mix(15.,100., rnd);\n    vec2  v = hash21(rnd*10.);\n    float a = floor(rnd*8.)*45.;\n    uv *=  mat2(cos(a),-sin(a), sin(a),cos(a));\n    return fbm(uv *s *v, 5, rnd) * .005;\n}\n\nvec3 calcNormal(vec2 uv){\n    float d = 0.0001;\n    float l0 = calcHeight(uv);\n    float l1 = calcHeight(uv + vec2(d, 0.0));\n    float l2 = calcHeight(uv + vec2(0.0, d));\n    return normalize(vec3(-(l1 - l0), -(l2 - l0), d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / min(iResolution.x, iResolution.y);\n    //fragColor = vec4(uv,0.,1.); return;\n    \n    vec3 lightPos;\n#ifdef AUTO_LIGHT\n    float t = iTime * 2.;\n    lightPos = vec3(cos(t) * 1.5 + 0.5, sin(t) * 0.5 + 0.5, 1.0);\n#else\n    vec2 mp = (2.0*iMouse.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n    lightPos = vec3(mp, 1.5);\n    //fragColor = vec4(smoothstep(.2,.1, distance(uv,mp))); return;\n#endif\n    \n    //float height = calcHeight(uv);\n    //fragColor = vec4(height); return;\n    vec3 normal = calcNormal(uv);\n    //fragColor = vec4(normal, 1.); return;\n    \n    //--- phong\n    vec3 lightDir = normalize(vec3(lightPos - vec3(uv, 0.0)));\n    float diffuse = max(0.0, dot(normal, lightDir));\n    vec3 vReflection = normalize(reflect(-lightDir, normal));\n    float specular = pow(max(0.0, dot(normal, vReflection)), 5.0);\n    vec3 ambientColor = vec3(0.01);\n    vec3 diffuseColor;\n#ifdef RANDOM_COLOR\n    int id = int(floor(uv.x/digi) + floor(uv.y/digi)*iResolution.x);\n    diffuseColor = hash31(float(id));\n#else\n    vec2 digiUV = floor(fragCoord.xy/iResolution.xy / digi) * digi;\n    #ifdef WEBCAM\n    diffuseColor = texture(iChannel0, digiUV).rgb;\n    diffuseColor = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    #else\n    diffuseColor = texture(iChannel1, digiUV).rgb;\n    diffuseColor = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    #endif\n#endif\n    //fragColor = vec4(diffuseColor , 1.0); return;\n    vec3 col = min(vec3(1.0), ambientColor + diffuseColor * diffuse + specular);\n    \n    \n    vec2 tileUV = mod(uv,digi) / digi;\n    float frame  = smoothstep(.3,.45,pow(sin(tileUV.x*3.1415), .75));\n          frame *= smoothstep(.3,.45,pow(sin(tileUV.y*3.1415), .75));\n          frame  = smoothstep(.4,.45,frame);\n    //col *= frame;\n    col = mix( vec3(1.,1.,1.), col, frame); \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*--------------------------------------------------\n # glslUtils\n - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n - https://github.com/ashima/webgl-noise\n - https://thebookofshaders.com/\n - \n--------------------------------------------------*/\n\nfloat random(float n){return fract(sin(n) * 43758.5453123);}\nfloat random(vec2 st) {return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);}\nfloat noise(float p){\n\tfloat fl = floor(p), fc = fract(p);\n\treturn mix(random(fl), random(fl + 1.0), fc);\n}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(random(b), random(b + d.yx), f.x), mix(random(b + d.xy), random(b + d.yy), f.x), f.y);\n}\n\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\n\nfloat permute(float x) { return mod289(((x * 34.0) + 1.0) * x);}\nvec2 permute(vec2 x) { return mod289(((x * 34.0) + 1.0) * x);}\nvec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x);}\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x);}\n\n/*============================== SimplexNoise ==============================*/\n//### 2D\nfloat snoise(vec2 v) {\n  vec4 C   = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n  vec2 i   = floor(v + dot(v, C.yy));\n  vec2 x0  = v - i + dot(i, C.xx);\n  vec2 i1  = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i      = mod289(i);  // Avoid truncation effects in permutation\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n  vec3 m  = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n  m       = m * m;\n  m       = m * m;\n  vec3 x  = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h  = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x  = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nfloat fbm(vec2 uv, int oct) {\n  vec2  pos = uv;\n  float amp = 1.0, val = 0.0;\n  for (int i = 0; i < oct; i++) {\n    val += amp * snoise(pos);\n    pos *= 2.0;\n    amp *= 0.5;\n  }\n  return val;\n}\n\n//### 3D\nfloat snoise(vec3 v) {\n  vec2 C   = vec2(1.0 / 6.0, 1.0 / 3.0);\n  vec4 D   = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i   = floor(v + dot(v, C.yyy));\n  vec3 x0  = v - i + dot(i, C.xxx);\n  vec3 g   = step(x0.yzx, x0.xyz);\n  vec3 l   = 1.0 - g;\n  vec3 i1  = min(g.xyz, l.zxy),i2  = max(g.xyz, l.zxy);\n  vec3 x1  = x0 - i1 + C.xxx, x2  = x0 - i2 + C.yyy, x3  = x0 - D.yyy;\n  i        = mod289(i);\n  vec4  p  = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n  vec4  j  = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4  x_ = floor(j * ns.z);\n  vec4  y_ = floor(j - 7.0 * x_);\n  vec4  x  = x_ * ns.x + ns.yyyy;\n  vec4  y  = y_ * ns.x + ns.yyyy;\n  vec4  h  = 1.0 - abs(x) - abs(y);\n  vec4  b0 = vec4( x.xy, y.xy );\n  vec4  b1 = vec4( x.zw, y.zw );\n  vec4  s0 = floor(b0) * 2.0 + 1.0, s1 = floor(b1) * 2.0 + 1.0;\n  vec4  sh = -step(h, vec4(0, 0, 0, 0));\n  vec4  a0 = b0.xzyw + s0.xzyw * sh.xxyy, a1 = b1.xzyw + s1.xzyw * sh.zzww;\n  vec3  p0 = vec3(a0.xy, h.x), p1 = vec3(a0.zw, h.y), p2 = vec3(a1.xy, h.z), p3 = vec3(a1.zw, h.w);\n  //Normalise gradients\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m      = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\nfloat fbm(vec2 uv, int oct, float time) {\n  vec2  pos = uv;\n  float amp = 1.0;\n  float val = 0.0;\n  for (int i = 0; i < oct; i++) {\n    val += amp * snoise(vec3(pos, time));\n    pos *= 2.0;\n    amp *= 0.5;\n  }\n  return val;\n}\n\n\n/*============================== hash ==============================*/\nfloat hash11(float p) {\n  p = fract(p * .1031);\n  p *= p + 33.33;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash12(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3) {\n  p3 = fract(p3 * .1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 hash22(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 hash23(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 hash31(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\nvec3 hash32(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\nvec4 hash41(float p) {\n  vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n  p4 += dot(p4, p4.wzxy + 33.33);\n  return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\nvec4 hash42(vec2 p) {\n  vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n  p4 += dot(p4, p4.wzxy + 33.33);\n  return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\nvec4 hash43(vec3 p) {\n  vec4 p4 = fract(vec4(p.xyzx) * vec4(.1031, .1030, .0973, .1099));\n  p4 += dot(p4, p4.wzxy + 33.33);\n  return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\nvec4 hash44(vec4 p4) {\n  p4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n  p4 += dot(p4, p4.wzxy + 33.33);\n  return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}","name":"Common","description":"","type":"common"}]}