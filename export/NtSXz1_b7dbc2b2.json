{"ver":"0.1","info":{"id":"NtSXz1","date":"1627034456","viewed":54,"name":"Fog1","username":"markf06","description":"Ray Marcher based on avoodoocado using a 3d volume image.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distSphere(vec3 r, vec3 pos, float rad)\n{\n    return distance(pos, r) - rad;\n}\n\nfloat distPlane(vec3 r, vec3 pos, vec3 normal)\n{\n    return r.y - pos.y;\n}\n\nfloat dist(vec3 r)\n{\n    float s0 = distSphere(r, vec3(1,-1.,-1), .7);\n    //float s1 = distSphere(r, vec3(1,0,1), 1.0);\n    //float s2 = distSphere(r, vec3(3,0,4), 1.0);\n    //float s3 = distSphere(r, vec3(5,0,2), 1.0);\n    float p0 = distPlane(r, vec3(0.5,-2,3), vec3(0,1,0));\n    //return min(min(min(min(s0, s1), s2), s3), p0);\n    return min(s0, p0);\n}\n\n  float fogDensity(vec3 r)\n{\n   \n    float density = 0.0;\n         \n     density += texture(iChannel0, 0.01*r).x;\n     density *= texture(iChannel0, 0.021*r).x;\n     density *= texture(iChannel0, 0.043*r).x;\n     density *= smoothstep(1.0,-1.0,r.y);\nreturn density;\n}    \n\nbool ray(vec3 r0, vec3 rd, float len, out vec3 pos, out vec3 normal, out float mind, out float fog)\n{ \n   vec3 r = r0;\n\n    float d = 1.0;\n     mind = len;\n    for(int i=0; i<100;i++)\n    {\n        d = dist(r);\n        \n        if(mind > d)\n        mind = d;\n        \n        if(d < 0.001)\n        {\n            pos = r;\n            \n            normal = normalize(vec3(\n                dist(r+vec3(0.001,0,0)),\n                dist(r+vec3(0,0.001,0)),\n                dist(r+vec3(0,0,0.001))) - d);\n           \n            \n               return true;\n        }\n        d = min(0.2, d);\n        r += rd * d;\n        float mul = 10.;\n        fog += d * fogDensity(r*mul);\n        if(distance(r, r0) > len)\n            return false;\n    }\n\n   return false;\n   \n}\n\nvec3 lightSpot(vec3 pos, vec3 normal, vec3 lpos, vec3 lcol)\n{\n    vec3 spos;\n    vec3 snormal;\n    vec3 rd = lpos - pos;\n    float mind;\n    float start = 0.3;\n    float fog;\n    float dist = distance(lpos, pos);\n    ray(pos+ rd*start,rd, dist, spos, snormal, mind, fog);\n    \n    float shadow = smoothstep(.001,start,mind);\n    \n    float falloff = 2.0/(1.0*dist+1.0);\n    return vec3(shadow) * lcol * falloff * max(0.0,dot(normal, normalize(lpos-pos)));            \n}\n\n\nvec3 lightDir(vec3 pos, vec3 normal, vec3 ldir, vec3 lcol)\n{\n    vec3 spos;\n    vec3 snormal;\n    vec3 rd = -ldir;\n    float mind;\n    float start = 0.3;\n    float fog;\n    float dist = 100.0;\n    ray(pos+ rd*start,rd, dist, spos, snormal, mind, fog);\n    \n    float shadow = smoothstep(.001,start,mind);\n    \n    return vec3(shadow) * lcol * max(0.0,dot(normal, normalize(-ldir)));            \n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 lights(vec3 pos, vec3 normal, float fog)\n{\n vec3 col = vec3(0);\n        col += lightSpot(pos, normal, vec3(4,1,1), vec3(1,0,.20));\n        col += lightSpot(pos, normal, vec3(-4,3,2), vec3(.3,1,0));\n        col += lightDir(pos, normal, vec3(0,-1,0), vec3(.2,.2,0.3));\n        col = mix(col,vec3(.4),1.0-1.0/(20.0*fog+1.0));\n       //col = vec3(mind);\n       return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.xx;\n    vec2 mouse = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx;\n\n    vec3 r0 = vec3(0,0,-1);\n    vec3 rd = vec3(uv,0) - r0;\n\n    rd = normalize(rd);\n\n    //mat4 m0 = rotationMatrix(vec3(0,1,0), -2.0*mouse.x);\n    mat4 m0 = rotationMatrix(vec3(0,1,0), 0.5*iTime);\n    //mat4 m1 = rotationMatrix(vec3(1,0,0), -2.0*mouse.y);\n    mat4 m1 = rotationMatrix(vec3(1,0,0), -.2);\n\n\n    r0 = (m1 * vec4(r0,1.0)).xyz;\n    rd = (m1 * vec4(rd,1.0)).xyz;\n\n    r0.z += -10.0 + 3.0*sin(0.5*iTime);\n    r0.y += 1.0;\n\n    r0 = (m0 * vec4(r0,1.0)).xyz;\n    rd = (m0 * vec4(rd,1.0)).xyz;\n\n    vec3 col = vec3(0.4);\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    float mind;\n    float fog;\n    if(ray(r0, rd, 100.0, pos, normal, mind, fog))\n    {\n        col = lights(pos, normal, fog);\n       \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}