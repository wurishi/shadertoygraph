{"ver":"0.1","info":{"id":"ctSBzG","date":"1694140019","viewed":30,"name":"Learning RayMarching;Noise;Light","username":"patrickhartono","description":"Learning Ray Marching, Light, and Perlin Noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Approximate the inverse square root of a number 'r'\n// Faster but less accurate than 1.0 / sqrt(r)\nfloat taylorInvSqrt(float r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// Generate a 2D Perlin noise value based on input coordinates 'p'\nfloat noise(vec2 p)\n{\n    // Separate the input point 'p' into integer and fractional parts\n    vec2 Pi = floor(p);\n    vec2 Pf = p - Pi;\n    // Limit the grid coordinates to a specific range (0-255)\n    Pi = mod(Pi, 256.0);\n\n    // Predefined gradients\n    vec2 grad3[12];\n    grad3[0] = vec2(1,1); grad3[1] = vec2(-1,1); grad3[2] = vec2(1,-1); grad3[3] = vec2(-1,-1);\n    grad3[4] = vec2(1,0); grad3[5] = vec2(-1,0); grad3[6] = vec2(1,0); grad3[7] = vec2(-1,0);\n    grad3[8] = vec2(0,1); grad3[9] = vec2(0,-1); grad3[10] = vec2(0,1); grad3[11] = vec2(0,-1);\n\n    // Calculate dot products between gradients and vectors from grid point to input point\n    float n00 = dot(grad3[int(mod(Pi.x + mod(Pi.y, 256.0), 12.0))], Pf);\n    float n01 = dot(grad3[int(mod(Pi.x + mod(Pi.y + 1.0, 256.0), 12.0))], Pf - vec2(0, 1));\n    float n10 = dot(grad3[int(mod(Pi.x + 1.0 + mod(Pi.y, 256.0), 12.0))], Pf - vec2(1, 0));\n    float n11 = dot(grad3[int(mod(Pi.x + 1.0 + mod(Pi.y + 1.0, 256.0), 12.0))], Pf - vec2(1, 1));\n\n    // Compute the fade curves for both x and y\n    vec2 fade = vec2(Pf.x * Pf.x * Pf.x * (Pf.x * (Pf.x * 6.0 - 15.0) + 10.0),\n                     Pf.y * Pf.y * Pf.y * (Pf.y * (Pf.y * 6.0 - 15.0) + 10.0));\n    \n    // Perform the interpolation based on the fade values\n    return mix(mix(n00, n10, fade.x), mix(n01, n11, fade.x), fade.y);\n}\n\n// Simplified 3D Perlin noise function\nfloat noise3D(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// Rotate a point 'p' around an axis defined by 'axis' by an angle 'angle'\nvec3 rotate(vec3 p, vec3 axis, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    return cosA * p + sinA * cross(axis, p) + (1.0 - cosA) * dot(axis, p) * axis;\n}\n\n// Calculate the shortest distance from a point 'p' to a box with dimensions 'b'\nfloat boxSDF(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Main rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Generate a random flickering background based on time\n    float timeFloor = floor(iTime * 10.0);  \n    float flicker = fract(sin(dot(vec2(timeFloor, timeFloor), vec2(12.9898, 79.233))) * 43758.5453);\n    flicker = step(0.5, flicker);\n    \n    vec3 bgColor = vec3(flicker);\n    fragColor = vec4(bgColor, 1.0);  // Set initial background color\n\n    // Convert pixel coordinates to normalized device coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Ray's origin and direction\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    vec3 boxSize = vec3(1.0, 1.0, 1.0);\n    vec3 lightPos = vec3(2.0, 2.0, -2.0);  // Light position\n\n    float t = 0.0;\n    bool hit = false;  // Flag to indicate if the ray hits the box\n\n    // Raymarching loop\n    for(int i = 0; i < 64; i++)\n    {\n        vec3 p = ro + t * rd;\n\n        // Rotate the box\n        p = rotate(p, vec3(1.0, 0.0, 0.0), sin(iTime));\n        p = rotate(p, vec3(0.0, 1.0, 0.0), cos(iTime));\n        p = rotate(p, vec3(0.0, 0.0, 1.0), sin(iTime) * cos(iTime));\n\n        float d = boxSDF(p, boxSize);\n\n        if(d < 0.01)\n        {\n            // Texture the box using 3D Perlin noise\n            float n = noise3D(p * 10.0);\n            n = n * 0.5 + 0.5;\n\n            // Apply simple lighting\n            vec3 lightDir = normalize(lightPos - p);\n            float diff = max(0.0, dot(vec3(0.0, 1.0, 0.0), lightDir));\n            \n            vec3 col = vec3(n) * diff;\n            \n            fragColor = vec4(col, 1.0);  // Update the pixel color\n            hit = true;\n            break;\n        }\n\n        t += d;\n\n        if(t > 10.0) break;\n    }\n    \n    // If the ray doesn't hit the box, use the background color\n    if (!hit) {\n        fragColor = vec4(bgColor, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}