{"ver":"0.1","info":{"id":"MlK3z3","date":"1475997577","viewed":328,"name":"Coil Symmetry","username":"DjinnKahn","description":"Use mouse to select scene.\n\nI made an `opTorusCoil` function to convert to coil space, where you walk along a torus. Y is distance from torus, X is left/right deviation from the path, Z is total progress along the path.","likes":19,"published":1,"flags":0,"usePreview":1,"tags":["torus","symmetry","coil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = acos(0.)*2.;\n\nfloat sdSphere( vec2 p, float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdBox( vec2 p, vec2 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat angleOf( vec2 v ) { return atan( v.y, v.x ); }\nfloat round_( float x, float m ) { return floor( x/m + .5 ) * m; }\nvec2 rotate( vec2 v, float a ) { return vec2( v.x*cos(a)+v.y*sin(a), -v.x*sin(a)+v.y*cos(a) ); }\n\n// map `pos` to a coiled space\n// Think of a thick wire (the coil) wrapped around a torus\n// Walking along the wire,\n//   the returned y-coordinate: distance from the torus \n//   the returned x-coordinate: left/right deviation from the coil\n//   the returned z-coordinate: the progress of walking the entire wire (usually ignore this)\n// * Lipschitz_continuity is NOT guaranteed *\n// \t\t- DjinnKahn\nvec3 opTorusCoil( vec3 pos, float bigRadius, float numCoils, float coilStep/*try 1.*/ )\n{        \n    vec3 polarPos = vec3( length( pos.xy ), angleOf( pos.xy ), pos.z );\n    vec3 polarC   = vec3( bigRadius      , polarPos.y       , 0. );\n    float tiltRelativeToRing = angleOf( ( polarPos - polarC ).xz );\n    float distToRing = length( ( polarPos - polarC ).xz );\n    \n    vec3 polarD = vec3( bigRadius, round_(polarPos.y-coilStep*tiltRelativeToRing/numCoils,2.*PI/numCoils) + coilStep*tiltRelativeToRing/numCoils, 0. );\n    //float sheetDeltaX = polarC.y - polarD.y; // if you want x-coordinate to be an angle\n    float sheetDeltaX = polarPos.x * sin( polarC.y - polarD.y );        \n    float sheetDeltaY = distToRing;\n    return vec3( sheetDeltaX, sheetDeltaY, fract(polarD.y/(2.*PI)) );\n}\n\nconst float NUM_SCENE_CHOICES = 8.;\nint sceneChoice()\n{    \n    return int(min(NUM_SCENE_CHOICES-1.,max(0.,floor(float(NUM_SCENE_CHOICES)*iMouse.x/iResolution.x))));\n}\n\nfloat calcDist( vec3 pos )\n{\n    float dist = 9999.9;\n    \n    int choice = sceneChoice();\n    \n    //// a simpler coil that doesn't look as intended (sweep a moving circle around an axis)\n    //vec3 p = vec3( length( pos.xy ), atan( pos.y, pos.x ), pos.z );\n    //dist = length( vec3( p.x+cos(p.y*7.)*.6, 0, p.z+sin(p.y*7.)*.6 ) - vec3( 2.0, 0, 0.0 ) ) - ( .6 );\n               \n    /// blobby coil\n    if ( choice == 0 || choice == 2 )\n    {\n    \tvec3 coilCoords = opTorusCoil( pos, 3., 20., 1. );    \n    \tdist = min( dist, sdSphere( coilCoords.xy - vec2( .0, .5 ), .06 + .05 * (cos(coilCoords.z*250.*PI + iTime*10.)+1.) ) );\n    } \n\n    //// coil with varying thickness\n    if ( choice == 1 )\n    {\n        vec3 coilCoords = opTorusCoil( pos, 3., 20., 3. );    \n        dist = length( coilCoords.xy - vec2( 0, .5 ) ) - .13 * (cos(coilCoords.z*2.*PI)+1.);\n    }\n    \t\n    // thick square coil\n    if ( choice == 2 )\n    {\n    \tvec3 coilCoords = opTorusCoil( pos, 3., 20., 1. );    \n    \tdist = min( dist, sdBox( coilCoords.xy - vec2( .0, .5 ), vec2( .1, .1 ), .03 ) );\n    }\n    \t\n    // thick square coil rotating            \n    if ( choice == 3 )\n    {\n    \tvec3 coilCoords = opTorusCoil( pos, 3., 20., 1. );    \n    \tdist = min( dist, sdBox( rotate( coilCoords.xy - vec2( .0, .5 ), coilCoords.z * PI/2. + iTime*1.4 ), vec2( .08, .08 ), .06 ) );\n    }       \n    \n    // twirling double coil\n    if ( choice == 4 )\n    {\n        vec3 coilCoords = opTorusCoil( pos, 3., 10., 1. );        \n        vec2 off = vec2( cos(iTime), sin(iTime) ) * .15;\n        dist = min( dist, sdSphere( coilCoords.xy - vec2( .0, .5 ) + off, .1 ) );\n        dist = min( dist, sdBox( coilCoords.xy - vec2( .0, .5 ) - off, vec2( .03, .03 ), .03 ) );\n    }\n    \n    // coil of coil\n    // i would like the wire to be rounder, but it's still neat!\n    if ( choice == 5 )\n    {\n        //// straighten the coil -- useful as a nested input\n        //vec3 coiledPos = vec3( pos.x + 3., 0, pos.y );   \n        //coiledPos.xy = rotate( coiledPos.xy, pos.z/10. );    \n        //vec3 coilCoords = opTorusCoil( coiledPos, 3., 20., 1. );    \n        //dist = min( dist, sdBox( coilCoords.xy - vec2( .0, .5 ), vec2( .1, .1 ), .03 ) );\n        \n        vec3 coilCoords = opTorusCoil( pos, 3., 14., 1. );\n        vec3 coiledPos = vec3( coilCoords.x + 9., 0, coilCoords.y );   // large radius 6. for less distortion\n        coiledPos.xy = rotate( coiledPos.xy, coilCoords.z*2.*PI + iTime*.04 );    \n        vec3 subCoilCoords = opTorusCoil( coiledPos - vec3(0,0,.95), 9., 100., 1. ); \n\n        dist = min( dist, sdSphere( subCoilCoords.xy - vec2( .0, .25 ), .10 ) );    \n    }\n        \n    // large skinny loops\n    if ( choice == 6 )\n    {\n        vec3 coilCoords = opTorusCoil( pos, 3., 20., 7. );    \n        dist = min( dist, sdSphere( coilCoords.xy - vec2( .0, 2.1 ), 0.13 ) );\n    }\n    \n    // moving pellets    \n    if ( choice == 7 )\n    {\n        vec3 coilCoords = opTorusCoil( pos, 3., 20., 1. );    \n        float z = mod( coilCoords.z*54. + iTime, 2. ) - 1.;\n        vec3 pp = vec3( coilCoords.xy, z );\n\n        dist = min( dist, length( pp - vec3( .0, 1.1, .0 ) ) - .3 );\n        dist *= .4; // try to fix glitchiness, i suppose it's because i'm using a sphere function, but result is very oblong \n    }\n    \n    return dist * .7;\n}\n\nvec3 normalAt( vec3 pos )\n{    \n    const float eps = 0.01;\n    float dist = calcDist( pos );\n    return normalize( vec3( dist - calcDist( pos + vec3(eps,0,0) )\n                          , dist - calcDist( pos + vec3(0,eps,0) )\n                          , dist - calcDist( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 surfaceColor( vec3 pos, vec3 dir )\n{\n    //float a = (sin( opTorusCoil( pos, 3., 20., 1. ).z * 2. * PI ) + 1.) / 2.;\n    float a = pow( opTorusCoil( pos, 3., 20., 1. ).z, 2. );\n    \n    vec3 norm = normalAt( pos );\n    vec3 reflectionDir = reflect( dir, norm );\n    vec3 lightDir = normalize( vec3( 1.0, -0.3, 0.0 ) );\n    return vec3( pow(max(0.0,dot(reflectionDir,-lightDir)),70.0) )\n         + vec3( pow(max(0.0,dot(norm,lightDir)),1.0) ) * .3\n        // + vec3(0.4);\n        // + texture( iChannel0, norm ).rgb * .3\n        // + min(0.001/pow(fract(pos*1.0)-0.5,vec3(2.0)),0.5)\n        + vec3(a,0,0)\n        ;\n}\n\nvec3 rotz( vec3 p, float a )\n{\n\treturn vec3( p.x * cos(a) + p.y * sin(a)\n               , p.x *-sin(a) + p.y * cos(a)\n               , p.z );\n}\nvec3 rotx( vec3 p, float a )\n{\n\treturn vec3( p.x\n               , p.y * cos(a) + p.z * sin(a)\n               , p.y *-sin(a) + p.z * cos(a) );\n}\nvec3 roty( vec3 p, float a )\n{\n\treturn vec3( p.x * cos(a) + p.z * sin(a)\n               , p.y\n               , p.x *-sin(a) + p.z * cos(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 screenPos = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;        \n    vec3 ray = normalize( vec3( screenPos, 3.0 ) );      \n    vec3 pos = vec3( 0, 0, -10.0 );\n        \n    if ( sdBox(fragCoord-vec2((float(sceneChoice())+.5)/NUM_SCENE_CHOICES*iResolution.x,0.), vec2(iResolution.x/NUM_SCENE_CHOICES/2.,4.), .01 ) < 0. )\n    {\n        fragColor = vec4(0,0,1.,1.);\n        return;\n    }\n    \n    float tilt = sin(iTime/2.2)*.4-.3;\n    pos = roty( rotx( pos, tilt + .0 ), iTime * .3 );\n    ray = roty( rotx( ray, tilt      ), iTime * .3 );  \n    \n    fragColor = texture( iChannel0, ray );\n    \n    \n    float dist = 999.9;\n    for ( int i = 0; i < 250; i++ )\n    {\n    \tdist = calcDist( pos );    \n    \tpos += ray * dist;\n        if ( dist < .01 || dist > 99. )\n            break;\n    }\n        \n    vec3 ray2 = reflect( ray, normalAt( pos ) );\n    vec3 pos2 = pos + ray2*.001; // start the ray away from the surface slightly\n    float dist2 = 999.9;\n    for ( int j = 0; j < 250; j++ )\n    {\n        dist2 = calcDist( pos2 );    \n        pos2 += ray2 * dist2;\n        if ( dist2 < .0005 || dist2 > 99.9 )\n            break;\n    }\n        \n    if ( dist >= .01 ) return;        \n            \n    fragColor.rgb = surfaceColor( pos, ray ) + texture( iChannel0, ray2 ).rgb * .3;\n    \n    if ( dist2 < .01 )\n    \tfragColor.rgb += surfaceColor( pos2, ray2 ) * 0.5 + texture( iChannel0, reflect( ray2, normalAt( pos2 ) ) ).rgb * .1;\n    \n}","name":"Image","description":"","type":"image"}]}