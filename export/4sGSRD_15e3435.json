{"ver":"0.1","info":{"id":"4sGSRD","date":"1463047888","viewed":176,"name":" Tunnel of Triangular tiling","username":"soma_arc","description":"Transformation of Right Triangular tiling","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n       vec2 seed = co * (sampleIndex + 1.0);\n       seed+=vec2(-1,1);\n       // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n       return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                   fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n     }\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nvec2 div(vec2 x, vec2 y){\n\tfloat a = y.x;\n    float b = y.y;\n    float c = x.x;\n    float d = x.y;\n   \n    return vec2((a * c + b * d), (a * d - b * c)) / (a * a + b * b);\n}\n\nvec2 cayley(vec2 x){\n\treturn div( (x + vec2(1, 0)).yx * vec2(-1, 1), -x + vec2(1, 0));\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float sampleNum = 50.;\nconst float PI = 3.141592653589;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    vec3 sum = vec3(0.);\n    float theta = PI / 4. + PI/6. * sin(iTime);\n    float xc = 10. * 2. * cos(theta);\n    float yc = 10. * 2. * sin(theta);\n    vec2 tileSize = vec2(xc, yc);\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        position *= 100.;\n\n    \tposition = circleInverse(position, vec2(0), 30. );\n        //position = cayley(position);\n        \n    \tvec2 p = position - tileSize * floor(position / tileSize) - tileSize / 2.;\n    \tfloat angle = atan(p.y, p.x);\n \n    \tif(mod(floor(angle / (PI/2.0)), 2.0) == 0. ){\n        \tif(mod(angle, PI/2.0) < theta){\n                vec2 n = floor(position / tileSize);\n        \t\tsum += hsv2rgb(vec3(0.1 + (n.x+n.y) * cos(iTime/20.), 1., 1.));//vec3(1);\n        \t}\n    \t}else{\n    \t\tif(mod(angle, PI/2.0) < PI / 2.0 - theta){\n                vec2 n = floor(position / tileSize);\n        \t\tsum += hsv2rgb(vec3(0.1 + (n.x + n.y) * cos(iTime/20.), 1., 1.));//vec3(1);\n        \t}\n    \t}\n    }\n    \n    fragColor = vec4(sum / sampleNum,1.);\n}","name":"Image","description":"","type":"image"}]}