{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define S 1.55\nconst float PI = 3.141592653589793;\nconst float TAU = 2.0 * PI;\nconst float TAU_INVERSE = 1.0 / TAU;\n\nvec2 uv2xy(vec2 uv) {\n    float aspect = iResolution.y / iResolution.x;\n    return 2.0 * (uv - vec2(0.5)) * vec2(1.0, aspect);\n}\n\nvec2 xy2polar(vec2 xy) {\n    return vec2(\n        length(xy),\n        atan(xy.y, xy.x)\n    );\n}\n\nvec2 polar2xy(vec2 polar) {\n    float r = polar.x;\n    float a = polar.y;\n    return vec2(\n        r * cos(a),\n        r * sin(a)\n    );\n}\n\nconst vec3 COLOR1 = vec3(1.0, 0.666, 0.0);\nconst vec3 COLOR2 = vec3(0, 0.333, 1.0);\n\nfloat between(float a, float b, float t1, float t2) {\n  float v = 0.5 + 0.25 * (sin(t1) + cos(t2));\n  return a + (b - a) * v;\n}\n\nvec2 findDisk(vec2 polar, float time, float i, float minSectors, float sectorsScale) {\n    float threshold = between(0.2, 0.4, time * 0.001074, time * 0.001247);\n    float len = polar.x;\n    float ang = polar.y;    \n    if (len < threshold) {\n        float spiral = between(-10.0, 10.0, time * 0.001078, time * 0.001777);\n        float ellipse = 0.8 - sin(ang * 4.0) * 0.2;\n        return vec2(ellipse * len / threshold, ang + time * 0.001 + spiral * len);\n    }\n    \n    float sectors = floor(i * 1.0 + minSectors);\n    float len2 = threshold + 0.5 * (1.0 - threshold);    \n    float ang2 = TAU * (0.5 + floor(ang * TAU_INVERSE * sectors)) / sectors;\n    vec2 center = polar2xy(vec2(len2, ang2));\n    vec2 xy = polar2xy(polar) - center;\n    vec2 polar2 = xy2polar(xy);\n    float effect = between(0.0, 4.0, i * time * 0.001574, -time * 0.000754);\n    polar2.x *= effect / (1.0 - threshold);\n    polar2.y += i * between(-2.0, 2.0, time * 0.000451, time * 0.0004995);\n    return polar2;\n}\n\nvec3 computeColor(float time, vec2 polar, vec3 colSub, vec3 colAdd, float minSectors, float sectorsScale) {\n    vec3 col = colSub;\n    for (float i=0.0; i<8.0; i++) {\n        float a = smoothstep(0.49, 0.51, polar.x);\n        col += (mix(colSub, colAdd, a) - mix(colAdd, colSub, a)) * 0.1;\n        float light = 1.0 - smoothstep(0.75, 1.0, polar.x);\n        col *= 0.7 + (light * .3);\n        vec3 tmp = colAdd;\n        colAdd = colSub;\n        colSub = tmp;\n        polar = findDisk(polar, time, i, minSectors, sectorsScale);\n    }\n    return col;\n}\n\nfloat getSectorsMin(float stageI) {\n  return floor(between(2.0, 23.0, stageI, stageI * stageI));\n}\n\nfloat getSectorsScale(float stageI) {\n  return floor(between(0.0, 4.0, 74.458 * stageI, stageI * 7.14545));\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    \n      vec2 uv = C/iResolution.xy;\n      \n          float time = iTime * 1.10;    \n\n\n    vec2 xy = uv2xy(uv);\n    vec2 polar = xy2polar(xy);\n    float stage = time * 0.0001;\n    float stageI = floor(stage);\n    float stageF = fract(stage);\n    \n \n    vec3 colSub = COLOR1;\n    vec3 colAdd = COLOR2;\n    vec3 col1 = computeColor(time, polar, colSub, colAdd, getSectorsMin(stageI), getSectorsScale(stageI));\n    vec3 col2 = computeColor(time, polar, colSub, colAdd, getSectorsMin(stageI + 1.0), getSectorsMin(stageI + 1.0));\n    \n    vec3 col = mix(col1, col2, smoothstep(0.9, 1.0, stageF));\n    vec2 P = vec2(0.5, 0.5)*vec2(iResolution.x/iResolution.y, 1.);\n  \n    float z = -S/length(uv*vec2(iResolution.x/iResolution.y, 1.)-P);\n    vec2 dir = normalize(P-uv*vec2(iResolution.x/iResolution.y, 1.1));\n    uv -= dir+(iTime);\n\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(7.,7.,0.),H(g*.1),.8)*7./e/8e3\n    )\n    {\n        p=g*d;\n          \n     p.z+=iTime*10.;\n         p.xy=uv*xy.xy;\n           p.xz*=mat2(cos(iTime*0.01),sin(iTime*0.01), -sin(iTime*0.01) ,cos(iTime*0.01));\n        a=100.;\n        p=mod(p-a,a*2.)-a;\n        s=1.0;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n             \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*.01)*.05;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcKBD1","date":"1734022804","viewed":103,"name":"multyply  golden ","username":"nayk","description":"source fractal 62","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}