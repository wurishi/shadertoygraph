{"ver":"0.1","info":{"id":"wlfGDB","date":"1557469575","viewed":931,"name":"plain Sine Wave","username":"matkatmusic","description":"I am trying to figure out how to get the curve to have a consistent thickness, as described in this link: https://iquilezles.org/articles/distance/distance.htm","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi_times_2 = 2.0 * 3.141592653589793238;\n\n#define WHITE vec3(1);\n\nfloat computeSine(float normalizedX)\n{\n    float x = normalizedX * pi_times_2;\n \treturn sin(x);   \n}\n\nfloat computeSine_prime_x(float normalizedX)\n{\n \t//return (dx/d)sin(x)\n    float x = normalizedX * pi_times_2;\n    return cos(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 normalizedFragCoord = fragCoord/iResolution.xy;\n\n    float y = computeSine(normalizedFragCoord.x) * 0.95;\n    \n    //we can't check if fragCoord.y == y directly. \n    //but we can check the distance/difference between them to \n    //determine if we should set the color of fragCoord.xy one way or the other\n    \n    //y is normalized to [-1,+1], so our threshold should also be normalized\n    //it should be scaled to [0,1]\n    y += 1.0;\n    y /= 2.0;\n    \n    float dfx = computeSine_prime_x(normalizedFragCoord.x);\n    \n    //dfx += 1.0;\n    //dfx /= 2.0;\n    \n    float threshold = 4.0 / iResolution.y; \n    \n    vec3 col = vec3(0); //all black\n    \n    float distanceEstimate = abs( y - normalizedFragCoord.y )/sqrt(1.0 + dfx*dfx);\n    \n    col = mix(vec3(1.0), col, smoothstep(0.0, threshold, distanceEstimate) );\n\t/*\n    if( abs( y - normalizedFragCoord.y )/sqrt(1.0 + dfx*dfx) < threshold )\n    {\n        //col = vec3(1);\n        col = smoothstep( 0, 1,  \n    }\n\t*/\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}