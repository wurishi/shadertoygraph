{"ver":"0.1","info":{"id":"Ddscz8","date":"1686643712","viewed":85,"name":"gravitational lensing test","username":"hexagon8899","description":"just testing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blackhole","gravitationallensing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n╭─────────────────────────────────────────────────────────────────────────────────────╮\n│                                                                                     │\n│     ACCRETION DISK AND NIGHT SKY TEXTURE (iChannel0 and iChannel1 respectively)     │\n│                                                                                     │\n│                         >>> https://imgur.com/a/FR7UbkQ <<<                         │\n│                                                                                     │\n├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n│                                                                                     │\n│                         HOW TO LOAD TEXTURES INTO SHADERTOY                         │\n│                                                                                     │\n│              >>> https://github.com/ahilus/ShadertoyCustomTextures <<<              │\n│                                                                                     │\n╰─────────────────────────────────────────────────────────────────────────────────────╯\n*/\n\n\n#define MAX_ITER 400\n#define RAY_STEP 0.02\n#define LENSING 0.005\n\n// reduces iterations on edges of screen \n#define OPTIMIZATION 5\n\n\n\n\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    vec3 camRot, camPos, rayPos, rayDir, gradient, B;\n    vec2 mouse = 2. * iMouse.xy/iResolution.y - vec2( iResolution.x/iResolution.y , 1. );\n    vec2 uv    = 2. *       pos/iResolution.y - vec2( iResolution.x/iResolution.y , 1. );\n    col = vec4( 0, 0, 0, 1 );\n    float xza, lens;\n    float colMul = 1.;\n    vec3 tex;\n    float x,y,z, ys;\n    int maxIter = MAX_ITER;\n    float rayStep = RAY_STEP;\n    float lensing = LENSING;\n    camPos = vec3(0, 0, -5);\n    \n    \n    if (iMouse.xy==vec2(0)) {\n        camRot = vec3(1, -.3, 0);\n    } else {\n        camRot = vec3(mouse * 3.14 * vec2(1., .5), 0);\n    }\n    //camRot.x -= iTime/7.;\n    \n    \n    \n    camPos.yz *= rot(camRot.y);\n    camPos.xz *= rot(camRot.x);\n    \n    \n    \n    \n    rayDir = vec3( uv, 1. );\n    \n    \n    rayDir.yz *= rot(camRot.y);\n    rayDir.xz *= rot(camRot.x);\n    \n    rayPos = camPos;\n    \n    if (\n        length(uv) > 1.3 ||\n        length(vec2(uv.x, uv.y * (1. + cos(camRot.y))/1.2 - sin(camRot.y) / 2. ) ) > 1.3\n    ) {\n        maxIter =  maxIter / OPTIMIZATION ;\n        rayStep *= float( OPTIMIZATION );\n        lensing *= float( OPTIMIZATION );\n        //col.z += 0.5;\n    }\n    \n    for (int i = 0; i < maxIter; i++) {\n        \n        x = rayPos.x;\n        y = rayPos.y;\n        z = rayPos.z;\n        ys = y*y;\n        xza = x*x+z*z;\n        lens = xza + ys;\n        \n        \n        if ( lens < .5 ) {\n            //col.z += colMul;\n            colMul = 0.;\n            break;\n        } else if (ys*200. + xza/15. < 1.) {\n            tex = texture(iChannel0, ( vec2(x,z)* cos(iTime + 4./(xza) / (1. - 1.5*y)) + \n                                       vec2(-z,x)*sin(iTime + 4./(xza) / (1. + 1.5*y))\n                                      )/9.+.5).xyz;\n            col.xyz += tex*tex*colMul;\n            colMul *= 1. - tex.x * xza / 20.;\n        }\n        \n        \n        rayPos += rayDir * rayStep;\n        rayDir =  normalize(rayDir - rayPos * lensing / ( lens - .5 ) );\n        \n\n    }\n    \n    vec3 nml = normalize(rayPos);\n    x = nml.x;\n    y = nml.y;\n    z = nml.z;\n    tex = texture(iChannel1, vec2(\n        atan(x,y)/3.14159/2. + .5,\n        atan(z,length(vec2(x,y)))/3.14159 + .5\n    )).xxx;\n    \n    col.xyz += tex * colMul;\n    col = sqrt(col);\n    col.w = 1.;\n}","name":"Image","description":"","type":"image"}]}