{"ver":"0.1","info":{"id":"NlfSRf","date":"1626150874","viewed":132,"name":"Spiral Repetition 2","username":"synulation","description":"Just messing around with sdf noise (https://iquilezles.org/articles/fbmsdf/fbmsdf.htm)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS = 96;\nconst float EPSILON = 0.001;\nconst float FAR = 70.0;\nconst float AO_STEPS = 5.0;\nconst float AO_DIST = 1.5;\nconst float PI = 3.1415926;\n\nfloat noise(vec2 uv)\n{\n\treturn fract(sin(dot(uv ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 schlick(vec3 f0, vec3 h, vec3 v)\n{\n\treturn f0 + (1.0 - f0) * pow(1.0 - dot(h,v), 5.0);\n}\n\nvec3 sampleHemi(float u1, float u2, vec3 n)\n{\n\tvec3 v = abs(n.y) < abs(n.z) ? vec3(0.0,1.0,0.0) : vec3(0.0,0.0,1.0);\n\tvec3 w = normalize(cross(n,v));\n\tv = normalize(cross(w,n));\n\t\n\tfloat r = sqrt(u1);\n\tfloat theta = 2.0 * PI * u2;\n\tfloat x = r * cos(theta);\n\tfloat y = r * sin(theta);\n\treturn normalize(n * sqrt(1.0 - u1) + v*x + w*y);\n}\n\nvec3 rotateX(vec3 pt, float theta)\n{\n\treturn vec3(pt.x, cos(theta)*pt.y + sin(theta)*pt.z, cos(theta)*pt.z - sin(theta)*pt.y);\n}\n\nvec3 rotateY(vec3 pt, float theta)\n{\n\treturn vec3(cos(theta)*pt.x + sin(theta)*pt.z, pt.y, cos(theta)*pt.z - sin(theta)*pt.x);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n\n// https://iquilezles.org/articles/fbmsdf\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        n = smax(n,d-0.1*s,0.3*s);\n        d = smin(n,d      ,0.3*s);\n        q = m*q;\n        s = 0.415*s;\n\n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n} \n\nfloat d_plane(vec3 pt, vec4 pln)\n{\n\treturn dot(pt, pln.xyz) - pln.w;\n}\n\nfloat d_sphere(vec3 pt, vec4 sph)\n{\n\treturn length(pt - sph.xyz) - sph.w;\n}\n\nfloat d_spiral(vec3 pt)\n{\n\tpt.x += sin(pt.y) * cos(iTime);\n\tpt.z += cos(pt.y) * sin(iTime);\n\tpt = rotateY(pt,pt.y);\n\treturn length(pt.xz) - 1.5*(2.0 + cos(iTime));\n}\n\nconst float precis = 0.5;\n\nfloat dist(vec3 pt)\n{\n\tfloat d0 = d_plane(pt, vec4(0.0,1.0,0.0,-3.0));\n\td0 = sdFbm(pt, abs(cos(iTime)*precis), d0).x;\n    \n\tvec3 pt2 = vec3(mod(pt.x,14.0)-7.0,pt.y,mod(pt.z,14.0)-7.0);\n\tfloat d1 = d_sphere(pt2, vec4(0.0,0.0,0.0,4.0));\n    d1 = sdFbm(pt2, abs(sin(iTime)*precis), d1).x;\n    \n\tvec3 pt3 = rotateY(pt2,iTime);\n\tfloat d2 = d_spiral(pt2);\n    d2 = sdFbm(pt3, abs(sin(iTime)*cos(iTime)*precis), d2).x;\n    \n    return min(min(d0,d1),d2);\n}\n\nvec3 calc_normal(vec3 pos)\n{\n\tvec3 res;\n\tres.x = dist(pos + vec3(EPSILON,0.0,0.0)) - dist(pos - vec3(EPSILON,0.0,0.0));\n\tres.y = dist(pos + vec3(0.0,EPSILON,0.0)) - dist(pos - vec3(0.0,EPSILON,0.0));\n\tres.z = dist(pos + vec3(0.0,0.0,EPSILON)) - dist(pos - vec3(0.0,0.0,EPSILON));\n\treturn normalize(res);\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfor (int i=0; i<STEPS; i++)\n\t{\n\t\tvec3 pt = ro + rd * t;\n\t\tfloat d = dist(pt);\n\t\tif (abs(d) < EPSILON)\n\t\t\treturn vec4(pt,1.0);\n\t\tt += d;\n\t\tif (t >= FAR)\n\t\t\tbreak;\n\t}\n\treturn vec4(0.0);\n}\n\nfloat calc_ao(vec3 p, vec3 n)\n{\n\tfloat r = 0.0;\n\tfloat w = 1.0;\n\tfor (float i=0.0; i<AO_STEPS; i++)\n\t{\n\t\tfloat d = ((i + 1.0) / AO_STEPS) * AO_DIST;\n\t\tr += w * (d - dist(p + n * d));\n\t\tw *= 0.5;\n\t}\n\treturn 1.0 - clamp(r,0.0,1.0);\n}\n\nfloat calc_shadow(vec3 p, vec3 l)\n{\n\tfloat r = 1.0;\n\tfloat t = 0.0;\n\tfor (float i=0.0; i<16.0; i++)\n\t{\n\t\tvec3 pt = p + l * t;\n\t\tfloat d = dist(pt);\n\t\tif (d < EPSILON)\n\t\t\treturn 0.0;\n\t\t\n\t\tr = min(r,32.0*d/t);\n\t\tt += clamp(d,0.01,4.0);\n\t}\n\treturn r;\n}\n\nvec3 diffuse(vec3 p, vec3 n, vec2 fragCoord)\n{\n\tvec3 clr = vec3(0.0);\n\tvec3 t = vec3(0.0,1.0,0.0);\n\tif (dot(t,n) < 0.001)\n\t\tt = vec3(0.0,0.0,1.0);\n\tvec3 b = cross(n,t);\n\tt = normalize(cross(b,n));\n\t\n\tfor (float i=0.0; i<8.0; i++)\n\t{\n\t\tfor (float j=0.0; j<8.0; j++)\n\t\t{\n\t\t\tvec2 s = vec2(i,j)*vec2(sin(iTime))*fragCoord.xy;\n\t\t\tfloat u = (noise(n.xy+s)+i)*0.125;\n\t\t\tfloat v = (noise(n.yz+s)+j)*0.125;\n\t\t\tvec3 n0 = sampleHemi(u*0.5,v,n);\n\t\t\tclr += pow(texture(iChannel1,n0).rgb, vec3(2.2));\n\t\t}\n\t}\n\t\n\treturn clr * 0.125 * 0.125;\n}\n\nvec3 shade(vec3 pos, vec3 v, vec2 fragCoord)\n{\n\tconst float spec_power = 128.0;\n\tfloat normalization = (spec_power + 2.0) / (2.0 * PI);\n\t\n\tvec3 ldir = normalize(vec3(cos(iTime),1.0,sin(iTime)));\n\tvec3 n = calc_normal(pos);\n\tvec3 h = normalize(n+ldir);\n\tfloat ndl = max(dot(n,ldir),0.0);\n\tfloat ndh = max(dot(n,h),0.0);\n\tvec3 fresnel = schlick(vec3(0.05,0.05,0.05),h,v);\n\tvec3 spec = vec3(pow(ndh, spec_power)) * normalization * ndl * (PI / 4.0);\n\tvec3 diff = vec3(ndl);\n\tvec3 lcolor = spec * fresnel + diff;\n\tfloat shadow = calc_shadow(pos + n * 0.2, ldir);\n\treturn lcolor*shadow + calc_ao(pos,n) * diffuse(pos,n,fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 rd = normalize(vec3((-1.0 + 2.0 * uv)*vec2(iResolution.x/iResolution.y,1.0), 1.0));\n\tvec3 ro = vec3(0.0, 4.0, -10.0);\n\tvec3 forward = vec3(0.0, 0.0, 1.0);\n\t\n\tfloat theta_y = sin(iTime) * 0.5;\n\trd = rotateY(rd, theta_y);\n\tro += forward * iTime * 8.0;\n\tro.x = cos(iTime) * 2.0;\n\tro.y = sin(iTime) * 4.0 + 6.0;\n\t\n\tvec4 res = march(ro,rd);\n\tif (res.w == 1.0)\n\t{\n\t\tvec4 clr = vec4(pow(shade(res.xyz,rd,fragCoord), vec3(0.45)), 1.0);\n\t\tfragColor = clr;\n\t}\n\telse\n\t{\n\t\tfragColor = texture(iChannel0,rd);\n\t}\n}","name":"Image","description":"","type":"image"}]}