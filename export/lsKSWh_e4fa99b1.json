{"ver":"0.1","info":{"id":"lsKSWh","date":"1464172276","viewed":394,"name":"Spherical Triangular Lamp","username":"soma_arc","description":"Dodecahedral tiling on sphere.\nInspired by Gerard Westendorp (http://westy31.home.xs4all.nl/index.html) and Henry Segerman\nFilm about Lamp https://www.youtube.com/watch?v=mk-qWF26A14\nVisualizing Mathematics with 3D Printing\n","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","volume","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc, Kazushi Ahara - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 cPos = vec2(-1.618033, 0.);\nfloat r = 1.90211;\nconst float PI = 3.14159265359;\nconst float EPSILON = 0.001;\n\nconst float k_isotropic = 1. / 12.566368;\n\n// PVR p297\nvec3 lightIntensity(vec3 lightPos, vec3 lightPower, vec3 p){\n\tvec3 dir = lightPos - p;\n    return lightPower * (1. / dot(dir, dir));\n}\n\n// PVR p301\nfloat phaseFunction(vec3 w, vec3 w_light){\n\t// isotropic phase function 1/(4 * PI)\n    return k_isotropic;\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 50;\nfloat loopNum = 0.;\nint IIS(vec2 pos){\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) > r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            fund = false;\n        }\n        if (atan(pos.y, pos.x) > PI/5.){\n            float theta = PI*2./5.;\n            mat2 reflectMat = mat2(cos(theta), sin(theta), sin(theta), -cos(theta));\n            pos = reflectMat * pos;\n            invCount++;\n\t       \tfund = false;\n        }\n        if(fund){\n            if(length(pos) < .05 ||\n               distance(pos, cPos + vec2(r, 0)) < .05 ||\n               distance(pos, cPos + vec2(r, 0.2)) < .05){\n            \treturn 0;\n            }\n        \treturn invCount;\n        }\n    }\n\n\treturn invCount;\n}\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.z), p.y / (1. - p.z));\n}\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n\tvec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 p = (rayOrigin + t * rayDir);\n            int d = 0;\n            vec2 projected = stereoProject(p.xzy);\n            d = IIS(projected);\n\t\t\tif(mod(float(d), 2.) == 0.)\n                return vec4(t, normalize(p - sphereCenter));\n            t = -b + s;\n            if(EPSILON < t && t < isect.x){\n            \tp = (rayOrigin + t * rayDir);\n               \td = IIS(stereoProject(p.xzy));\n\t\t\t\tif(mod(float(d), 2.) == 0.)\n                \treturn vec4(t, normalize(p - sphereCenter));\n            }\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nfloat distFunc(vec3 p){\n  return length(p) - 100.;\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 spherePos = vec3(0, .5, 0);\nfloat sphereR = 0.5;\nvec3 planeP = vec3(0, -0.5, 0);\nvec3 planeN = normalize(vec3(1, 1, 0));\n\nfloat lightVisibility(vec3 org, vec3 target){\n    vec3 v = target - org;\n    vec4 result = vec4(length(v));\n    result = intersectSphere(spherePos, sphereR, org, normalize(v), result);\n    if(result.x < length(v)) return 0.;\n    result = intersectPlane(planeP, planeN, org, normalize(v), result);\n    if(result.x < length(v)) return 0.;\n\treturn 1.;\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.1);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. && lightVisibility(p, lightPos) == 1.) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\n\n\nconst vec3 lightPos = vec3(3, 6, 0);\nconst vec3 lightPower = vec3(1.);\nconst vec3 lightPos2 = vec3(0, 0.5, 0);\nconst vec3 lightPower2 = vec3(2., .2, .2);\nconst int MAX_MARCHING_LOOP = 800;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold){\n    vec3 rayPos = origin;\n  \tfloat dist;\n  \tfloat rayLength = 0.;\n  \tfor(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    \tdist = distFunc(rayPos);\n    \trayLength += dist;\n    \trayPos = origin + ray * rayLength ;\n    \tif(dist < threshold) break;\n  \t}\n  \treturn vec2(dist, rayLength);\n}\n\n// PVR p186 Code 10.2\nvec3 integrateScattering(vec3 p, vec3 w, float rayLength){\n    const float current = 0.;\n    const float end = 10.;\n    const float stepSize = .1;\n    // Integration variables\n    vec3 T = vec3(1.);\n    vec3 L = vec3(0.);\n\t// Integration loop\n    for(float current = 0. ; current < end ; current += stepSize){\n\t\tif(current > rayLength) break;\n    \t// Determine sample position\n        vec3 p_i = p + w * current;\n        // Sample volume properties (This is constant volume)\n        //vec3 sigma_s = vec3(1. * (1. + sin(iTime)), 1., 1.);\n        vec3 sigma_s = vec3(.02);\n        \n        // Compute change in transmittance\n        vec3 T_i = vec3(exp(-sigma_s.x * stepSize),\n                         exp(-sigma_s.y * stepSize),\n                         exp(-sigma_s.z * stepSize));\n        // Update accumulated transmittance\n        T *= T_i;\n        \n        //Sample light source\n        vec3 w_light = lightPos - p_i;\n        vec3 L_light = lightIntensity(lightPos, lightPower, p_i);\n        L_light *= lightVisibility(lightPos, p_i);\n        // Accumulate reflected light\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n        \n        w_light = lightPos2 - p_i;\n        L_light = lightIntensity(lightPos2, lightPower2, p_i);\n        L_light *= lightVisibility(lightPos2, p_i);\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n    }\n    return L;\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n  \tvec4 result = intersectSphere(spherePos, sphereR, eye, ray, vec4(99999.));\n    result = intersectPlane(planeP, planeN, eye, ray, result);\n    \n    vec3 matColor = vec3(1.);\n  \t\n  \tif(result.x > 0.){\n        vec3 intersection = eye + ray * result.x;\n        l += integrateScattering(eye, ray, result.x);\n        vec3 normal = result.yzw;\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower2);\n\n    }\n  \treturn l;\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 eye = vec3(1, 0.5, 1);\nconst vec3 target = vec3(0., 0.5, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(1.5 * cos(iTime/2.) , 1.5, 1.5 *sin(iTime/2.));\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}","name":"Image","description":"","type":"image"}]}