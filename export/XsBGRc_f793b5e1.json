{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n\tvec3 position;\n\tfloat radius;\n};\n\nstruct plan_t\n{\n\tvec3 normal;\n\tfloat d;\n};\t\n\t\nstruct hyper_t\n{\n\tvec3 origin;\n\tvec3 param;\n};\n\t\nstruct ray_t\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\t\nstruct surface_t\n{\n\tvec3 normal;\n};\n\t\t\t\nstruct light_t\n{\n\tvec3 direction;\n\tvec3 color;\n};\n\t\n\t\nfloat max_distance = 1e5;\n\nfloat intersect_sphere(const in ray_t ray, const in sphere_t sphere) {\n\tfloat res1,res2,res;\n\tres = max_distance;\n\tfloat a = ray.direction.x*ray.direction.x\n\t\t\t+ ray.direction.y*ray.direction.y\n\t\t\t+ ray.direction.z*ray.direction.z;\n\tfloat b = ray.direction.x*(ray.origin.x-sphere.position.x)\n\t\t\t+ ray.direction.y*(ray.origin.y-sphere.position.y)\n\t\t\t+ ray.direction.z*(ray.origin.z-sphere.position.z);\n\tb *= 2.0;\n\tfloat c = pow(ray.origin.x-sphere.position.x,2.0)\n\t\t\t+ pow(ray.origin.y-sphere.position.y,2.0)\n\t\t\t+ pow(ray.origin.z-sphere.position.z,2.0)\n\t\t\t- pow(sphere.radius,2.0);\n\t\n\tfloat delta = b*b - 4.0*a*c;\n\tif (delta >= 0.0) {\n\t\tres1 = (-b - sqrt(delta))/(2.0*a);\n\t\tres2 = (-b + sqrt(delta))/(2.0*a);\n\t\tres = min(res1,res2);\n\t}\n\tif (res < 0.0) res = max_distance;\n\treturn res;\n\t\n}\n\nfloat intersect_plan(const in ray_t ray, const in plan_t plan) {\n\tfloat res;\n\tres = max_distance;\n\t\n\tfloat a = plan.normal.x*ray.origin.x\n\t\t\t+ plan.normal.y*ray.origin.y\n\t\t\t+ plan.normal.z*ray.origin.z\n\t\t\t+ plan.d;\n\t\n\tfloat b = plan.normal.x*ray.direction.x\n\t\t\t+ plan.normal.y*ray.direction.y\n\t\t\t+ plan.normal.z*ray.direction.z;\n\t\n\t\n\tif (b != 0.0) res = -a/b;\n\tif (res < 0.0) res = max_distance;\n\treturn res;\n\t\n}\n\nfloat intersect_hyper(const in ray_t ray, const in hyper_t hyper) {\n\tfloat res,res1,res2;\n\tres = max_distance;\n\t\n\tfloat premCoef   = pow(hyper.param.y,2.0)*pow(hyper.param.z,2.0);\n\tfloat deuxCoef   = pow(hyper.param.x,2.0)*pow(hyper.param.z,2.0);\n\tfloat troisCoef = -pow(hyper.param.x,2.0)*pow(hyper.param.y,2.0);\n\t\n\tfloat a = premCoef*pow(ray.direction.x,2.0)\n\t\t\t+ deuxCoef*pow(ray.direction.y,2.0)\n\t\t\t+ troisCoef*pow(ray.direction.z,2.0);\n\t\n\tfloat b = premCoef*ray.origin.x*ray.direction.x\n\t\t\t+ deuxCoef*ray.origin.y*ray.direction.y\n\t\t\t+ troisCoef*ray.origin.z*ray.direction.z;\n\t\n\tb *= 2.0;\n\t\n\tfloat c = premCoef*pow(ray.origin.x,2.0)\n\t\t\t+ deuxCoef*pow(ray.origin.y,2.0)\n\t\t\t+ troisCoef*pow(ray.origin.z,2.0)\n\t\t\t- pow(hyper.param.x,2.0)*pow(hyper.param.y,2.0)*pow(hyper.param.z,2.0);\n\t\n\tfloat delta = b*b - 4.0*a*c;\n\tif (delta >= 0.0) {\n\t\tres1 = (-b - sqrt(delta))/(2.0*a);\n\t\tres2 = (-b + sqrt(delta))/(2.0*a);\n\t\tres = min(res1,res2);\n\t}\n\tif (res < 0.0) res = max_distance;\n\treturn res;\n\t\n}\n\nfloat intersect(const in ray_t primary_ray,const in sphere_t sphere,const in plan_t plan) {\n\treturn min(intersect_sphere(primary_ray, sphere),intersect_plan(primary_ray, plan));\n}\n\nvoid light_information(out light_t light) {\n\tlight.direction = vec3(sin(iTime),1, cos(iTime));\n\tlight.color = vec3(0,abs(0.7*sin(iTime*4.0)),0);\n}\n\nvec3 illumination(const in ray_t ray, const in surface_t surface, const in light_t light) {\n\tfloat answer = dot(normalize(surface.normal),normalize(light.direction));\n\tvec3 diffuse = vec3(answer*light.color.x,answer*light.color.y,answer*light.color.z);\n\tvec3 reflected = reflect(normalize(ray.direction), normalize(surface.normal));\n\tfloat shininess = 1.0;\n\tfloat specular = pow(dot(reflected,normalize(light.direction)),shininess);\n\treturn diffuse + vec3(specular*light.color.x,specular*light.color.y,specular*light.color.z);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen_coordinate = fragCoord.xy / iResolution.xy;\n\tvec2 screen_coordinate_centered = 2.0*screen_coordinate - 1.0;\n\t\n\tfloat aspect_ratio = iResolution.x/iResolution.y;\n\tvec2 screen_coordinate_line_corrected = vec2(aspect_ratio, 1.0)*screen_coordinate_centered;\n\t\n\tray_t primary_ray;\n\tfloat vitesse = 2.2;\n\tprimary_ray.origin = vec3(5.0 + 10.0*cos(iTime*vitesse),8, 5.0 + 10.0*sin(iTime*vitesse));\n\tprimary_ray.direction = normalize(vec3(screen_coordinate_line_corrected,-1));\n\t\n\tplan_t plan;\n\tplan.normal = normalize(vec3(0.3,0.9,0.3));\n\tplan.d = 0.1;\n\t\n\tsphere_t sphere;\n\tsphere.position = vec3(0,8,-10);\n\tsphere.radius = 1.0;\n\t\n\tfloat distance_from_origin = intersect(primary_ray,sphere,plan);\n\t\n\tlight_t light;\n\t\n\tif (distance_from_origin < max_distance) {\n\t\tvec3 position = vec3(primary_ray.origin.x + distance_from_origin*primary_ray.direction.x, primary_ray.origin.y + distance_from_origin*primary_ray.direction.y, primary_ray.origin.z + distance_from_origin*primary_ray.direction.z);\n\t\tlight_information(light);\n\t\tsurface_t surface;\n\t\tsurface.normal = normalize(vec3(position.x - sphere.position.x, position.y - sphere.position.y, position.z - sphere.position.z));\n\t\tvec3 ill = illumination(primary_ray,surface,light);\n\t\tfragColor = vec4(ill,1.0);\n\t} else {\n\t\tconst vec3 background_color = vec3(0.3,0.3,0.5);\n\t\tfragColor = vec4(background_color,1.0);\n\t}\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsBGRc","date":"1391457767","viewed":715,"name":"Premier Shader Laroy","username":"Souf","description":"Mon premier Shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["premier"],"hasliked":0,"parentid":"","parentname":""}}