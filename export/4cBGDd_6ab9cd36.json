{"ver":"0.1","info":{"id":"4cBGDd","date":"1704773751","viewed":95,"name":"simple rotating cube","username":"axo","description":"A simple rotating cube. \nNo complex ray-marching or tricky math here, just simple sin waves and high school linear math.\n\nGoes to show that using simple tricks with well-tuned parameters can lead to interesting results.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cube","animation","rotating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897\n\nvec2 getPoint(int i, int j);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 color = vec4(0, 0, 0, 1);\n    vec2 lowestTopPoint = getPoint(0, 1);\n    \n    //get lowest point\n    for(int i = 1; i < 4; i++)\n    {\n        if(getPoint(i, 1).y < lowestTopPoint.y)\n        lowestTopPoint = getPoint(i, 1);\n    }\n    \n    //Draw top face\n    for(int i = 0; i < 4; i++)\n    {\n        vec2 pos1 = getPoint(i, 1);\n        vec2 pos2 = getPoint(i+1, 1);\n        \n        //only consider the top lines and if the pixel lies between its x-boundries\n        if(pos1.x > pos2.x && uv.x > pos2.x && uv.x < pos1.x)\n        {\n            float slope = (pos2.y-pos1.y)/(pos2.x-pos1.x);\n            float normalizedX = uv.x - pos2.x;\n            \n            //check if pixel lies between top line and bottom boundry of the top face\n            if(uv.y < pos2.y+ slope*normalizedX && uv.y > lowestTopPoint.y)\n            {\n                color = vec4(0.0, 0.0, 1.0, 1.0)*0.8;\n            }\n        }\n    }\n    \n    //Draw vertical faces\n    for(int j = 1; j <= 1; j+=2)\n    {\n        for(int i = 0; i < 4; i++)\n        {\n            vec2 pos1 = getPoint(i, j);\n            vec2 pos2 = getPoint(i+1, j);\n            vec2 pos3 = getPoint(i, clamp(j+2, -1, 1));\n            \n            if(pos1.x < pos2.x)\n            {\n                //check x-boundary of face\n                if(uv.x > pos1.x && uv.x < pos2.x)\n                {\n                    //check y-boundary of face\n                    float slope = (pos2.y-pos1.y)/(pos2.x-pos1.x);\n                    float normalizedX = uv.x - pos1.x;\n                    float topY = pos1.y + slope * normalizedX;\n                    float bottomY = topY - (0.6);\n                    if(uv.y < topY && uv.y > bottomY)\n                    {\n                        //draw face with some rudimentary shading\n                        float faceIntensity = 1.0 - clamp( 0.9 - (pos2.x - pos1.x), 0.0, 1.0); //face towards camera = more light\n                        faceIntensity *= 0.7;\n                        //a bit of glow\n                        float xIntensity = clamp(0.1 - abs(uv.x*-slope/2.0), 0.0, 1.0)*20.0;\n                        \n                        faceIntensity += clamp(0.1 - abs((uv.y*slope+0.1)/2.0), 0.0, 1.0)*5.0 * xIntensity;\n                        vec4[] colors = vec4[](vec4(1, 0, 0, 1), vec4(0, 1, 0, 1), vec4(0, 1, 1, 1), vec4(1, 0, 1, 1));\n                        vec4 faceColor = colors[i];\n                        color = faceColor*faceIntensity;\n                    }\n                }\n            }\n        }\n    }\n    \n    fragColor = color;\n}\n\n//get one of 4 point going in a circle. i = horizontal offset, j = vertical offset\nvec2 getPoint(int i, int j)\n{\n    float x = cos(iTime + PI/2. * float(i));\n    float y = sin(iTime + PI/2. * float(i)) * 0.4 + float(j) * 0.6;\n    return vec2(x, y) * 0.5;\n\n}","name":"Image","description":"","type":"image"}]}