{"ver":"0.1","info":{"id":"dscyzr","date":"1694669303","viewed":70,"name":"Quadratic Bezier approximation","username":"Envy24","description":"Source: https://hhoppe.com/ravg.pdf\nExact: https://www.shadertoy.com/view/7sGyWd","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier","approximation","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 2.0 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\n/* Slightly changed original code. */\nfloat cross2d(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n// Find vector 𝑣𝑖 given pixel 𝑝=(0,0) and Bézier points 𝑏0,𝑏1,𝑏2.\nvec2 get_distance_vector(vec2 NDC, vec2 b0, vec2 b1, vec2 b2) \n{\n    b0 -= NDC; b1 -= NDC; b2 -= NDC;\n\n    float a=cross2d(b0,b2), b=2.*cross2d(b1,b0), d=2.*cross2d(b2,b1); // 𝛼,𝛽,𝛿(𝑝)\n    float f=b*d-a*a; // 𝑓(𝑝)\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    \n    vec2 gf=2.*(b*d21+d*d10+a*d20);\n         gf=vec2(gf.y,-gf.x); // ∇𝑓(𝑝)\n    vec2 pp=-f*gf/dot(gf,gf); // 𝑝′\n    vec2 d0p=b0-pp; // 𝑝′ to origin\n    \n    float ap=cross2d(d0p,d20), bp=2.*cross2d(d10,d0p); // 𝛼,𝛽(𝑝′)\n    \n    // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n    float t=clamp((ap+bp)/(2.*a+b+d), 0.,1.); // 𝑡̅\n    \n    return mix(mix(b0,b1,t),mix(b1,b2,t),t); // 𝑣𝑖 = 𝑏(𝑡̅)\n}\n/* */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n     \n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    vec2 b0 = vec2(-2.0, 0.0) * 0.65; \n    vec2 b1 = vec2(-2.0, 0.0);\n    vec2 b2 = vec2(2.0, 0.0) * 0.65;\n    \n    b0 = rotateAroundZ(b0, iTime * 0.1) + vec2(2.*offs, -offs);\n    b1 = rotateAroundZ(b1, iTime * 0.9) + vec2(-6.*offs, 0.0);\n    b2 = rotateAroundZ(b2, iTime * 0.1) + vec2(-offs, offs);\n         \n    vec2 vi = get_distance_vector(NDC, b0, b1, b2);\n    float d = length(vi) - 0.1;\n\n    if (iMouse.z > 0.)\n        color = mix(color, vec3(1,0,0), SMAA(d));        \n    else\n        color = colorize_field(d, vec3(.1, .4, .7));\n    \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}