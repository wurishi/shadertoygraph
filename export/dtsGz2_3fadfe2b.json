{"ver":"0.1","info":{"id":"dtsGz2","date":"1672104131","viewed":69,"name":"Protogen Face v2","username":"coburn","description":"Version 2 of protogen face. Needed to be GLSL ES v1.0 compatible and much faster due to target platform (Raspberry Pi 1 B+). No more animated frames so draws procedurally. Reduced function calls to avoid \"register allocation failure\" during compile","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["video","animation","furry","protogen"],"hasliked":0,"parentid":"clsGDM","parentname":"Protogen Face"},"renderpass":[{"inputs":[],"outputs":[],"code":"// Trying to emulate: https://www.youtube.com/watch?v=lpbvKUYoOUQ\n// Inspired by: https://www.shadertoy.com/view/lt2SDK\n\n#define MAIN_BLOOM_ITERATIONS 3\n#define MAIN_BLOOM_SIZE 0.005\n\n#define PHOSPHOR_COL vec4(0.35, 0.55, 1.0, 0.0)\n\nprecision highp float;\n\nfloat rand(float s){\n    return fract(sin(s * 12.9898 ) * 43758.5453);\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float r) {\n\tp -= a;\n\tb -= a;\n\tfloat d = length(p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n\treturn d - r;\n}\nfloat sdCircle(vec2 p, vec2 center, float radius) {\n    return length(center - p) - radius; // inside is negative\n}\n\n// sdf for protogen face combining lines and circles\nfloat sdProtogen(vec2 uv, vec2 res) {\n    vec2 uv2 = uv;\n    // aspect correction\n    uv2.y = uv.y * (res.y / res.x);\n\n    float eyeInside = sdCircle(uv2, vec2(0.16, 0.39), 0.14);\n    float eyeLid = sdCircle(uv2, vec2(0.06, 0.17), 0.3);\n    float eye = max(-eyeLid, eyeInside); //combine via subtracting lid from inside\n    \n    float mouth0 = sdLine(uv2,  vec2(0.15,0.23),  vec2(0.22,0.19),  0.03);\n    float mouth1 = sdLine(uv2,  vec2(0.22,0.19),  vec2(0.50,0.15),  0.03);\n    float mouth2 = sdLine(uv2,  vec2(0.50,0.15),  vec2(0.55,0.13),  0.03);\n    float mouth3 = sdLine(uv2,  vec2(0.55,0.13),  vec2(0.62,0.07),  0.03);\n    float mouth4 = sdLine(uv2,  vec2(0.62,0.07),  vec2(0.68,0.12),  0.03);\n    float mouth5 = sdLine(uv2,  vec2(0.68,0.12),  vec2(0.76,0.14),  0.03);\n    float mouth6 = sdLine(uv2,  vec2(0.76,0.14),  vec2(0.81,0.13),  0.03);\n    float mouth7 = sdLine(uv2,  vec2(0.81,0.13),  vec2(0.87,0.11),  0.03);\n    float mouth8 = sdLine(uv2,  vec2(0.87,0.11),  vec2(0.92,0.07),  0.03);\n    float mouth9 = sdLine(uv2,  vec2(0.92,0.07),  vec2(0.97,0.11), 0.03);\n    float mouth10 = sdLine(uv2, vec2(0.97,0.11), vec2(1.01,0.12),  0.03);\n    float mouth = min(min(min(min(min(min(min(min(min(min(mouth0, mouth1), mouth2),\n    mouth3), mouth4), mouth5), mouth6), mouth7), mouth8), mouth9), mouth10);\n    \n    float noseInside = sdCircle(uv2, vec2(0.89, 0.37), 0.05);\n    float noseOut = sdCircle(uv2, vec2(0.86, 0.32), 0.07);\n    float nose = max(-noseOut, noseInside);\n\n    return min(min(nose, mouth), eye) - 0.005; // slightly grow the entire shape\n}\n\nvec4 ledFilter(vec2 uv, vec2 res) {\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Create an LED matrix-like grid of circles\n    // Pixelated grid of cells\n    vec2 count = vec2(128.0 / 2.0, 75.0 / 2.0);\n    vec2 uvPixel = ceil(uv * count) / count; // Global rounded UV of each cell\n    vec2 uvInsidePixel = mod(uv * count, 1.0); // [0,1] UV in each cell\n        \n    // Variable circle radius based on sampled pixel brightness\n    // add shimmer to make it feel \"animated\" without the expense of\n    // anything _actually_ animated (due to GPU restrictions)\n    float offset = uvPixel.y + uvPixel.x * count.x;\n    float noise = rand(offset);\n    float shimmerPhase = noise * 6.28;\n    float shimmerTheta = iTime * 6.28 * noise * 40.0;\n    float shimmer = sin(shimmerTheta + shimmerPhase) * noise;\n    \n    float d = sdProtogen(uvPixel, res);\n    float d2 = min(d, d - shimmer * 0.002); // add noise to edges\n    float lum = clamp(d2 * -100.0, 0.0, 1.0); // change d to a smooth gradient along edge [0,1]\n    \n    float radius = mix(0.0, 0.37, lum);\n    float dPixel = sdCircle(uvInsidePixel, vec2(0.5, 0.5), radius);\n    //float v = float(dPixel < 0.0);\n    \n    vec4 pxColor = PHOSPHOR_COL * lum; // circle brightness adjust by lum\n    // Fake bloom the effect instead of an actual postprocess bloom\n    // due to multiple calls to ledFilter too slow + register allocation failure\n    float bloomFalloff = mix(0.0, 1.0, clamp(dPixel * 4.0 * -1.0 + 0.5, 0.0, 1.0));\n    c += bloomFalloff * 2.0 * pxColor;\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    c = ledFilter(uv, iResolution.xy);\n    \n    fragColor = c;\n}","name":"Image","description":"","type":"image"}]}