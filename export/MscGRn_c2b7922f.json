{"ver":"0.1","info":{"id":"MscGRn","date":"1447638024","viewed":223,"name":"Soft Plate","username":"gaz","description":"Shane's idea.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"mat2 rotate(in float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat smin(in float a, in float b)\n{\n    float k = 0.06;\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fold(in float p, in float sz)\n{\n    const int iter = 30; \n    float c = sz / float(iter) / 2.0;\n\tfor(int i = 0; i < iter; i++){\n    \tp -= 2.0 * smin(0.0, p);\n    \tp -= 2.0 * c;\n\t}\n \tp += c;\n    return p;    \n}\n\nfloat map(in vec3 p)\n{   \n    p.yz *= rotate(iTime * 0.15);\n    p.zx *= rotate(iTime * 0.1);\n    \n    p.z += 0.05 * sin(5.0 * p.x + iTime * 0.5);\n    p.z += 0.05 * sin(7.0 * p.y + iTime * 1.5);\n    p.z += 0.05 * sin(8.0 * length(p.xy) + iTime);\n    \n    p.x = fold(p.x, 1.5);\n    p.y = fold(p.y, 1.5);\n\n    \n    return 0.8 * (length(p) - 0.05);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 96; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 rd = normalize(vec3(p, -1.5));\n    vec3 col = texture(iChannel0,\n    \tvec3(rd.xz * rotate(iTime * 0.015), 1.0 - rd.y).xzy ).rgb * vec3(0.15, 0.2, 0.3);\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n        vec3 ref = reflect(-li, nor);\n    \tcol = vec3(0.8, 0.5, 0.1);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0, 1.0), ref), 0.0), 50.0);\n       \tcol = mix(texture(iChannel0, ref).rrr, col, 0.9);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n    \n    /*\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(length(p) * 0.1);\n    vec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 rd = normalize(vec3(p, -1.5));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    \tcol = vec3(0.8, 0.5, 0.1);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.6)); \n    }\n    fragColor = vec4(col, 1.0);\n\t*/\n}\n","name":"","description":"","type":"image"}]}