{"ver":"0.1","info":{"id":"tsK3Rd","date":"1570805862","viewed":317,"name":"Flight through a nebula v3","username":"Delvar","description":"Simple fly though of a 3d box noise via ray marching.\nAdded some stars, a sun and lightning!\nhad to do some shufting around to hide the errors in the box noise, but its very fast.\nstill suffers from repetition though.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","cloud","nebula","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// also see \n// voronoi  version, https://www.shadertoy.com/view/tdyGzK\n// simplex version, https://www.shadertoy.com/view/WsG3zd\n// box version, https://www.shadertoy.com/view/tsK3Rd\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 30.0\n\n#define PI\t3.1415926535897932384626433832795\n    \n\n// Flags to use tecture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define noiseTecture3d\n#define noiseTecture2d\n\nstruct camera {\n   vec3 origin, forward, right, up;\n   float zoom; // Distance from screen\n};\n\nstruct ray {\n   vec3 origin, direction;\n};\n\nmat3x3 eulerToMatrix(float roll, float pitch, float yaw){\n  float\n      cPitch = cos(pitch),\n      sPitch = sin(pitch),\n      cYaw = cos(yaw),\n      sYaw = sin(yaw),\n      cRoll = cos(roll),\n      sRoll = sin(roll);\n    \n\tmat3x3 mPitch = mat3x3(\t1.0,\t0.0,\t0.0,\n\t\t\t\t\t\t\t0.0,\tcPitch,\tsPitch,\n\t\t\t\t\t\t\t0.0,\t-sPitch,\tcPitch);\n    \n    mat3x3 mYaw = mat3x3(\tcYaw,\t0.0,\tsYaw,\n\t\t\t\t\t\t\t0.0,\t1.0,\t0.0,\n\t\t\t\t\t\t\t-sYaw,\t0.0,\tcYaw);\n    \n    mat3x3 mRoll = mat3x3(\tcRoll,\t-sRoll,\t0.0,\n\t\t\t\t\t\t\tsRoll,\tcRoll,\t0.0,\n\t\t\t\t\t\t\t0.0,\t0.0,\t1.0);\n\n    return mPitch * mYaw * mRoll;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n\tcamera camera;\n\tcamera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n\tcamera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n\tcamera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n\tcamera.zoom = zoom;\n\treturn camera;\n}\n\nray getRay(vec2 uv, camera camera) {\n\tray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n\treturn ray;   \n}\n\nfloat random(in float st) {\n#if defined(noiseTecture3d)\n\treturn float(texelFetch( iChannel0, ivec3(vec3(139.181,151.199,229.211)*st)&31,0));\n#elif defined(noiseTecture2d)\n\treturn float(texelFetch( iChannel1, ivec2(vec2(139.181,151.199)*st)&255,0));\n# else\n\treturn fract(sin(st*139.181))* 437.5453123);\n#endif\n}\n\nfloat random3(in vec3 st) {\n#if defined(noiseTecture3d)\n\treturn float(texelFetch( iChannel0, ivec3(st)&31,0));\n#elif defined(noiseTecture2d)\n\treturn float(texelFetch( iChannel1, ivec2(st.xy*st.z)&255,0));\n# else\n\treturn fract(sin(dot(st,vec3(12.9898,79.233,96.9723)))* 437.5453123);\n#endif\n}\n\nfloat boxNoise(vec3 samplePoint) {\n    vec3 pointI =floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    \n   \n    float bbl = random3(pointI + vec3(0.0,0.0,0.0) );\n    float bbr = random3(pointI + vec3(1.0,0.0,0.0) );\n    float btl = random3(pointI + vec3(0.0,1.0,0.0) );\n    float btr = random3(pointI + vec3(1.0,1.0,0.0) );\n    \n    float fbl = random3(pointI + vec3(0.0,0.0,1.0) );\n    float fbr = random3(pointI + vec3(1.0,0.0,1.0) );\n    float ftl = random3(pointI + vec3(0.0,1.0,1.0) );\n    float ftr = random3(pointI + vec3(1.0,1.0,1.0) );\n    \n    vec3 u =pointF;\n    \n    float bb = mix(bbl,bbr,u.x);\n    float bt = mix(btl,btr,u.x);\n    \n    float b = mix(bb,bt,u.y);\n    \n    float fb = mix(fbl,fbr,u.x);\n    float ft = mix(ftl,ftr,u.x);\n    \n    float f = mix(fb,ft,u.y);\n    \n    return mix(b,f,u.z);\n}\n\nvec3 RayMarch(ray ray, float maxDistance, int maxSteps)\n{\n    float maxStepsf = float(maxSteps);\n    float stepSize = maxDistance/maxStepsf;\n    vec3 total = vec3(0.0);\n    float currentDistance = 1.0;\n    \n    for(float i=0.0; i<maxStepsf; i++) {\n        vec3 project = (ray.direction* currentDistance);\n        //Add some offsets to hide the aligned features in the box noise.\n        project.x +=sin(project.y*0.5);\n        project.y +=sin(project.z*0.2);\n        project.z +=sin(project.x*0.3);\n\t\tvec3 currentPoint = ray.origin + project  ;\n        \n        float stepf = ((maxStepsf - i)/maxStepsf);\n        float s = 1.0-(abs(boxNoise(currentPoint)-0.5)*2.0);\n        s=smoothstep(0.7,1.1, s);\n\n        s *= stepf;\n        vec3 light = sin((currentPoint+vec3(iTime/10.0,iTime/13.0,iTime/15.0))/4.0)*0.5+1.0; //Yes we blow out the colour a little.\n        total += light*s;\n        currentDistance += stepSize;\n    }\n    return (total*(3.0/maxStepsf));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    //Snap to center on startup.\n    if(iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        mouse = vec2(0.0,0.0);\n    }\n    \n\tcamera camera = getCamera(vec3(0.0,0.0,iTime), iTime*0.1, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    ray ray = getRay(uv, camera);\n\n    vec3 cloudColour = RayMarch(ray, RAY_MAX_DISTANCE, RAY_MAX_STEPS);\n    \n    //Stars\n    float starBase = random3(floor(ray.direction*iResolution.x*0.5));\n    float stars = starBase>0.05?0.0:starBase*20.0;\n    stars *= stars * stars * stars;\n    float cloudColourLength = length(cloudColour);\n   \tstars *= clamp(pow(clamp(1.0-smoothstep(0.1,1.0,length(cloudColourLength)),0.01,1.0),1.0),0.0,1.0)*0.6;\n    vec3 starColour = vec3(stars);\n    \n    //Sun\n    vec2 facing = vec2(iTime*0.01+1.2,iTime*0.03+0.3);\n    vec3 sunDir = normalize(vec3(\n        sin(facing.x),\n    \tsin(facing.y),\n    \tcos(facing.x)\n     ));\n    \n    float sunBright = clamp(dot(sunDir,ray.direction),0.0,1.0);\n    sunBright = pow(smoothstep(0.8,1.0,sunBright),2.0)* 10.0; //blow it right out\n    sunBright*=(clamp(1.0-cloudColourLength*0.5,0.1,1.0)); //obscure by nebula\n    vec3 suncolour = vec3(0.9, 0.7, 0.6); //nice orange/yellow\n   \n    //Lightning\n    float strikeBright = pow(clamp(sin(ray.direction.x+iTime*10.0)*sin(ray.direction.y+iTime*15.0)*cos(ray.direction.z+iTime*20.0),0.0,1.0),15.0+sin(iTime*2.0)*10.0);\n    strikeBright *= 8.0*clamp(1.0-cloudColourLength,0.1,1.0)*smoothstep(0.7,1.0,random(floor(iTime*5.0)));\n    vec3 strikeColour = vec3(0.7,0.9,1.0);\n    \n    //\n    vec3 colour = max(starColour,suncolour*sunBright*(clamp(1.0-cloudColourLength*0.5,0.1,1.0)) + cloudColour); \n\tcolour+=strikeBright*strikeColour;\n\n    //modualte expose, so the screen darkens when looking at the sun,\n    //rewrite the UV to remove aspect ratio but still in 0 > 1 range\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float exposure = smoothstep(-0.7,1.0,( 1.0-pow(clamp(dot(camera.forward, sunDir),0.0,1.0),4.0)));\n    colour *= exposure;\n \n    //Harsh gamma gives it a nicer look.\n    colour = pow(colour, vec3(1.0/0.8));\n    //flatten the colours\n    //colour = 1.35*colour/(1.0+colour);\n    colour = clamp(colour,0.0,1.0);\n  \tcolour = colour*colour*(3.0-2.0*colour);\n    \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.2)+0.3,0.0,1.0);\n    colour*=vignette;\n    fragColor = vec4(colour,1.0);\n}\n","name":"Image","description":"","type":"image"}]}