{"ver":"0.1","info":{"id":"3s2Bzt","date":"1590617593","viewed":89,"name":"Mesmerizing lights","username":"francismoy","description":"A simple set of rotating and collapsing circles that form some mesmerizing patterns","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circles","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 red = vec3(1.0, 0.25, 0.25);\nvec3 green = vec3(0.25, 1.0, 0.25);\nvec3 blue = vec3(0.25, 0.25, 1.0);\nvec3 yellow = vec3(0.8, 0.8, 0.2);\nvec3 cold = vec3(0.25, 0.8, 0.8);\nvec3 violet = vec3(0.7, 0.2, 0.7);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 colors[] = vec3[](red, green, blue, yellow, cold, violet);\n    vec3 color = vec3(0.0);\n    float separation = 0.008 * QuadIn(abs(sin(iTime)));\n    float k = -1.0;\n    float speed = 1.;\n    for (int i = 0; i < 80; ++i)\n    {\n     \tfloat index = float(i);\n\t\tk *= -1.0; \n        vec2 position = 0.5 + vec2(index * separation * sin(iTime * speed),\n                                   k * index * separation * cos(iTime * speed));\n        float distanceToCenter = distance(uv, position);\n        \n        float val = 1.0 - smoothstep(0.01, 0.04, distanceToCenter);\n        color += val * colors[i%colors.length()];\n        \n        speed += 0.02;\n    }\n     \n    fragColor = vec4(vec3(color), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWO_PI 6.28318530718\n#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nfloat SineIn(float t)\n{\n    return ((t - 1.0) * HALF_PI) + 1.0;\n}\n\nfloat SineOut(float t)\n{\n    return sin(t * HALF_PI);\n}\n\nfloat QuinticIn(float t)\n{\n    return pow(t, 5.0);\n}\n\nfloat QuinticOut(float t)\n{\n    return -(pow(t - 1.0, 5.0));\n}\n\nfloat QuinticInOut(float t)\n{\n    return t < 0.5 ? +16.0 * pow(t, 5.0)\n    \t\t\t: -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nfloat QuadIn(float t)\n{\n    return t*t;\n}\n\nfloat QuadOut(float t)\n{\n    return -t * (t -2.0);\n}\n\nfloat QuadInOut(float t)\n{\n \tfloat p = 2.0 * t * t;\n  \treturn t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat DoubleExponentialSeat(float t, float a)\n{\n    float y = 0.0;\n    \n    //Making sure a argument is stable\n    float epsilon = 0.0001;\n    float min_param_a = 0.0 + epsilon;\n    float max_param_a = 1.0 - epsilon;\n    a = min(max_param_a, max(min_param_a, a));\n    \n    if (t <= 0.5)\n    {\n        y = (pow(2.0*t, 1.0-a)) / 2.0;\n    }\n    else   \n    {\n        y = 1.0 - (pow(2.0*(1.0-t), 1.0-a)) / 2.0; \n    }\n    \n    return y;\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat DegToRad(float deg)\n{\n    return deg*(PI/180.0);\n}\n\nfloat RadToDeg(float rad)\n{\n \treturn rad*(180.0/PI);   \n}\n","name":"Common","description":"","type":"common"}]}