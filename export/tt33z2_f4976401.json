{"ver":"0.1","info":{"id":"tt33z2","date":"1577370914","viewed":236,"name":"3D Function Grapher","username":"kindpotato","description":"Here is a crappy way I figured out how I could graph a 3D function. For each ray I make small steps forward until I pass the surface. Then I use the bisection method to find a better intersection. Here I graph a wave function with 16 modes.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["functiongrapherbisection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define pi 3.14159265\n\n\n//func is a mode of vibration of a 2D plane with fixed boundary conditions\n//Look up membrane modes of vibrations\nfloat func(vec2 mn, vec2 uv){\n  float mag = length(mn);\n  return sin(iTime*mag)/mag*sin(mn.x*uv.x)*sin(mn.y*uv.y);\n}\n//I this case f is the addition of 16 modes of vibration on a 2D membrane.\nfloat f(float x, float y){ //this defines the function that is graphed.\n  float total = 0.;\n  for (float m = 1.; m < 4.1; m += 1.){\n    for (float n = 1.; n < 4.1; n += 1.){\n      total += func(vec2(m,n),vec2(x,y));\n    }\n  }\n\n  return total/3.;\n}\n/*float f(float x, float y){\n    return x*x +y*y-10.+sin(6.*x)+sin(6.*y);\n}*/\nvec2 times(vec2 a, vec2 b){\n  return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n  vec3 v = normalize(vec3(uv,1));\n  /*v is the ray for our current pixel. We must find a value \"t\"\n    which when multiplied by v is the intersection of v and the\n    func.*/\n  float angle = pi/6.;\n  v.zy = times(v.zy,vec2(cos(angle),-sin(angle)));\n  vec3 planePos = 3.*vec3(0,-1,1);//This is the position of the origin relative to camera\n  float a = 0., b = 0.;\n  vec3 pa = a*v-planePos; //Our starting pos relative to func origin\n\n\n  if (f(pa.x,pa.z) > pa.y){ //if our cam below func leave\n    fragColor = vec4(0);\n    return;\n  }\n  //step forward along v in coarse steps until we pass through the func\n  for (float i = 3.;i < 20.;i += 0.5){\n    vec3 pb = i*v-planePos;\n    if (f(pb.x,pb.z) > pb.y){\n      a = i-0.5; //Once we pass through, set a to slightly above func, and b below \n      b = i;\n      break;\n    }\n  }\n  if (b == 0.){ //if ray doesn't pass through the func\n    fragColor = vec4(0);\n    return;\n  }\n  float mid, diff; //midpoint of a and b and diff\n  int count = 0;\n  do { //Use bisections to find a better approximation for \n    mid = (a+b)/2.;\n    vec3 pm = mid*v-planePos;\n    diff = f(pm.x,pm.z) - pm.y;\n    if (diff < 0.)\n      a = mid;\n    else\n      b = mid;\n    ++count;\n  }while (abs(diff) > 0.001 && count < 10);\n//mid is now adequately close to the func\n  vec3 p = mid*v-planePos;\n    \n  const float dx = 0.05;\n  //gradX is a small vector which starts at point p (a point on the func)\n  //and ends at a point on the func when making a small step in the x dir\n  vec3 gradX = vec3(dx,f(p.x+dx,p.z)-p.y,0.);\n  vec3 gradZ = vec3(0.,f(p.x,p.z+dx)-p.y,dx);\n  //A vector perp to gradX and gradZ is a normal to our funcs surface\n  vec3 normal = normalize(cross(gradX,gradZ));\n  //Calculate lighting given our pos, lightPos, normal and texture\n  normal.y *= -1.;\n  vec3 reflected = reflect(v,normal);\n  vec3 toLight = normalize(vec3(0,1,0));\n  vec3 tex = texture(iChannel0,p.xz/pi).rgb;\n  float diffuse = dot(normal,toLight);\n  float specular = pow(abs(dot(toLight,reflected)),8.);\n  vec3 color = 0.6*vec3(specular)+diffuse*tex;\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}