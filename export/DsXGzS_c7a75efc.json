{"ver":"0.1","info":{"id":"DsXGzS","date":"1666277569","viewed":84,"name":"Failed mini-font Failure fail.","username":"spontificus","description":"\"maybe it would be fun and cool to see what a mini-font designed for a triangular-pixel based display could look like?\"\n- no, it was not\n- worst coordinate system ever\n- not worth fixing bugs\n- proof of badwrong concept","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagons","abjectfailure","2bad"],"hasliked":0,"parentid":"dsl3Dr","parentname":"TriHex"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// 11111 11001 10011 11111\n#define C_0 uint(1042047)\n\n// 00100 00110 00100 01110\n#define C_1 uint(137358)\n\n// 11111 11001 01111 11111\n#define C_2 uint(1041919)\n\n// 11111 11000 11000 11111\n#define C_3 uint(1041183)\n\n// 00100 00110 11111 00100\n#define C_4 uint(138212)\n\n// 11111 00011 11110 11111\n#define C_5 uint(1019871)\n\n// 01100 00110 11011 11011\n#define C_6 uint(400251)\n\n// 11111 11000 11110 00110\n#define C_7 uint(1041350)\n\n// 11111 11011 11011 11111\n#define C_8 uint(1044351)\n\n// 11011 11011 01100 00110\n#define C_9 uint(912774) \n\n\nbool myInRange(int t, int v1, int v2) {\n    return (abs(t - v1) + abs(v2 - t) <= abs(v2 - v1));\n}\n\n// centered and anti-square\nivec3 screenToSqHex( vec2 p ) {\n    int j = int(iResolution.y-p.y)/2 - int(iResolution.y/4.);\n    int i = (int(p.x) - j )/2 - int(iResolution.x/4.);\n    return ivec3(i,j,-(i+j));\n}\n\nvec4 disp2(ivec3 fragHex, int i, int j) {\n    // 0111110 0011110 0110010 0111110\n    // 0111110 00011110 00110010 00111110\n    float colVal = 0.;\n    int hmod = 4-(j-fragHex.y);\n    uint charOffsets = uint(130521406); //;); // 1042166334\n   // int lookupOffset = (fragHex.x - i) + 7*(fragHex.y - j);\n    \n    //if (myInRange(fragHex.x, i, i+7) && myInRange(fragHex.y, j, j+7)) {\n    int lookupOffset = (fragHex.x - i + hmod/2  ) + 7*hmod;\n\n    if (myInRange(hmod,0,3) && myInRange(fragHex.x,i,i+7-hmod) ) {\n        colVal = float(int(charOffsets >> uint(lookupOffset)) & 1);\n    }\n    return vec4(colVal,colVal,colVal,colVal);\n}\n\nvec4 disp3(ivec3 fragHex, int i, int j) {\n    // 0111110 0110000 0110000 0111110\n    float colVal = 0.;\n    int hmod = 4-(j-fragHex.y);\n    \n    uint charOffsets = uint(130816062);\n    int lookupOffset = (fragHex.x - i + hmod/2  ) + 7*hmod;\n\n    if (myInRange(hmod,0,3) && myInRange(fragHex.x,i,i+7-hmod) ) {\n        colVal = float(int(charOffsets >> uint(lookupOffset)) & 1);\n    }\n    return vec4(colVal,colVal,colVal,1.);\n}\n\n\n// broken algorithm is broken\nvec4 hexChar(uint charOffsets, ivec3 fragHex, int i, int j) {\n    float colVal = 0.;\n    int hmod = 4-(j-fragHex.y);\n    \n    int lookupOffset = (fragHex.x - i + hmod/2  ) + 5*(4-hmod);\n\n    if (myInRange(hmod,1,4) && myInRange(fragHex.x,i-hmod/2,i+5-hmod) ) {\n        colVal = float(int(charOffsets >> uint(lookupOffset)) & 1);\n    }\n    return vec4(colVal,colVal,colVal,colVal);\n}\n\n\n// centered and anti-square\n// i         j\n// 1 1 2 3  -1 -1 -2 -3 \n// 1 2 2 2  -1 -2 -2 -2\n// 0 1 1 1   0 -1 -1 -1\n// 0 0 1 2   0  0 -1  0  \n//                                  1        2        3        4\n//int iOffsets = 102066779;      // 00000110 00010101 01101010 01011011;\n//int jOffsets = 68512347;       // 00000100 00010101 01101010 01011011;\n\nivec3 screenToHex( vec2 p ) {\n    int screenX = int(p.x);\n    int screenY = int(p.y);\n    \n    // 11100101 10101001 01010100 10010000\n    uint iOffsets = uint(3853079696);   // 11100101 10100101 01010100 10010000 \n    // 01010101 01010101 00000000 00000000\n    uint jOffsets = uint(1431633920);    // 00010000 01010100 10101001 11100101\n\n    int oi = screenX % 4;\n    int oj = screenY % 4;\n    uint lookupOffset = uint(abs(oj*8) + abs(oi*2));\n\n    int gridJ = (screenY-oj)/2 - int(iResolution.y/4.0);\n    int gridI = (screenX-oi)/2 + gridJ/2 - int(iResolution.x/4.0);\n    \n\n    int j = gridJ + (int(jOffsets>>lookupOffset) & 3);\n    int i = gridI + (int(iOffsets>>lookupOffset) & 3);\n    \n    return ivec3(i,-j,(i+j));\n}\n\n\n\n// squarerootless solution\nint hexDist(ivec3 p1, ivec3 p2) {\n    return (p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y);\n    //return int(sqrt(float((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y))));\n}\n\n// precomputing k=-(i+j) shaves a couple percent\nint hexDist(int i, int j) {\n    return i*i + j*(i+j);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec3 center = ivec3(0,0,0);\n    ivec3 fragHex = screenToHex(fragCoord.xy);\n    ivec3 mouseHex = screenToHex(iMouse.xy);\n  /*  \n    if (iFrame % 120 > 60) {\n        fragHex = screenToSqHex(fragCoord.xy);\n        mouseHex = screenToSqHex(iMouse.xy);\n    }\n    */\n    int mouseDist = hexDist(mouseHex,center);\n    int mdist = hexDist(mouseHex,center);\n    int pdist = hexDist(fragHex,center);\n    \n    int mouseI = mouseHex.x;\n    int mouseJ = mouseHex.y;\n    int fragI = fragHex.x;\n    int fragJ = fragHex.y;\n    int fragK = -(fragI+fragJ);\n   \n\n    vec4 col = vec4(.1,.1,.1,1.);\n   \n\n    if ( fragHex == mouseHex ) {\n        col = vec4(1., 1., 1., 1.);\n    }\n    \n     \n    // center dot\n    if (fragI == 0 ) {\n        col += vec4(1., 0., 0., 1.);   \n    }\n    \n    // axis\n    if (abs(fragI) == 1 ) {\n        col += vec4(.5, 0., 0., 1.);   \n    }\n    if (abs(fragI) == 2 ) {\n        col += vec4(.25, 0., 0., 1.);   \n    }\n\n\n    if (abs(fragJ) == 1) {\n        col += vec4(0., .5, 0., 1.);   \n    }\n\n    if (abs(fragK) == 1) {\n        col += vec4(0., 0., .5, 1.);   \n    }\n\n    if ( fragJ == 0) {\n        col += vec4(0., 1., 0., 1.);   \n    }\n\n    if ( fragK == 0) {\n        col += vec4(0., 0., 1., 1.);   \n    }\n\n\n    // filler\n    if (mdist % pdist == 0) {\n        col += vec4(0.,1.,1., 1.);   \n    }\n    if (pdist % mdist == 0) {\n        if (abs(fragI) % 2 == abs(mouseI) % 2 && abs(fragJ) % 2 == abs(mouseJ) % 2) {\n            col += vec4(1.,0.,1., 1.);   \n        } else {\n            col += vec4(.5,.5,.0, 1.);   \n        }\n        \n    }\n    \n    // show points mirrored from mouse distance from center\n    if (pdist == mouseDist ) {\n       col = vec4(1.,1.,1., 1.);   \n    }\n    \n    \n    col += disp2(fragHex, 21,8);\n    col += disp3(fragHex, 27,8);\n    \n    int dispJ = mouseJ-4;\n    int dispI = mouseI;\n\n    col += hexChar(C_0,fragHex, dispI, dispJ);\n    col += hexChar(C_1,fragHex, dispI+1*8, dispJ);\n    col += hexChar(C_2,fragHex, dispI+2*8, dispJ);\n    col += hexChar(C_3,fragHex, dispI+3*8, dispJ);\n    col += hexChar(C_4,fragHex, dispI+4*8, dispJ);\n    col += hexChar(C_5,fragHex, dispI+5*8, dispJ);\n    col += hexChar(C_6,fragHex, dispI+6*8, dispJ);\n    col += hexChar(C_7,fragHex, dispI+7*8, dispJ);\n    col += hexChar(C_8,fragHex, dispI+8*8, dispJ);\n    col += hexChar(C_9,fragHex, dispI+9*8, dispJ);\n    \n    \n    fragColor = col;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}