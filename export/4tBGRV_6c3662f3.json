{"ver":"0.1","info":{"id":"4tBGRV","date":"1430218663","viewed":947,"name":"Music visualizer #1","username":"pixelzealot","description":"Not the best code in the world but it produced something that I really liked in the end. Final product could be re-written much more efficiently.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["squircle","musicvisualisation","rave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define M_PI \t3.14159265358979323846\n#define M_PI_2  1.57079632679489661923\n#define M_2_PI  6.28318530717958647692\n\nmat2 rotate2D(float angle)\n{\n   \tfloat cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    \n    return mat2(\n        vec2(cosTheta, sinTheta), \n        vec2(-sinTheta, cosTheta));\n}\n\n// Noise shamlessly storen from iq\nfloat noise(vec3 x) \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat fbm(vec2 p)\n{\n\tp += vec2(1.0,0.1) * iTime*0.5;\n    \n    float f;\n    f  = 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat f(vec2 uv, vec2 centre, float radius, float power)\n{\n    vec3 a = vec3(uv, radius);\n    vec3 b = vec3(centre, 0.0);\n    \n    return dot(pow(abs(a-b), vec3(power)), vec3(1.0, 1.0, -1.0));\n}\n\nvec2 grad_f(in vec2 x, vec2 centre, float radius, float power)\n{\n    vec2 h = vec2( 0.001, 0.0 );\n    return vec2( f(x+h.xy, centre, radius, power) - f(x-h.xy, centre, radius, power),\n                 f(x+h.yx, centre, radius, power) - f(x-h.yx, centre, radius, power) ) / (2.0*h.x);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1 < d2) ? d1 : d2;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nfloat sq(vec2 uv, vec2 centre, float radius, float power)\n{\n\tfloat v = f(uv, centre, radius, power);\n    vec2 g = grad_f(uv, centre, radius, power);\n    return v/length(g);    \n}\n\nvoid addScene(inout vec3 col, vec3 c, float de)\n{\n\tcol = mix(c, col, smoothstep(0.0, 2.5/iResolution.x, de));    \n}\n\nvoid addScene(inout vec3 col, vec3 c, float de, float width)\n{\n\tcol = mix(c, col, smoothstep(0.0, width, de));    \n}\n\nfloat avgFreq(int grid, int gridSize)\n{\n    float freq = 0.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float offset = (float(i) / (4.0)) + 0.5;\n        float samplePos = (float(grid-1) + offset) / float(gridSize);\n        freq += texture(iChannel1, vec2(samplePos, 0.25)).x;\n    }\n    \n    return freq / 4.0;\n}\n\nvec3 getPalette(float p)\n{\n    float m = 0.8;\n    float n = 0.1;\n    \n    p = sqrt(p);\n    \n    float range[5];\n    range[0] = 0.00;\n    range[1] = 0.40;\n    range[2] = 0.50;\n    range[3] = 0.60;\n    range[4] = 1.00;\n    \n    if (p <= range[1]) \n    {\n        float v = (p - range[0]) / (range[1] - range[0]);\n        return mix(vec3(n, n, m), vec3(n, m, m), v); \n    }\n    \n    if (p <= range[2]) \n    {\n        float v = (p - range[1]) / (range[2] - range[1]);\n        return mix(vec3(n, m, m), vec3(n, m, n), v); \n        \n    }    \n    \n    if (p <= range[3]) \n    { \n        float v = (p - range[2]) / (range[3] - range[2]);\n        return mix(vec3(n, m, n), vec3(m, m, n), v); \n    }    \n    \n    if (p <= range[4]) \n    {\n        float v = (p - range[3]) / (range[4] - range[3]);\n        return mix(vec3(m, m, n), vec3(m, n, n), v); \n    }    \n    \n    return vec3(p,0,1.0-p);\n}\n\nvoid addRingBloom(\n    inout vec3 col, \n    vec2 coord, \n\tfloat freq, \n    float ringRadius, \n    float ringSize, \n    float s, \n    float total,\n    float sqRadius,\n\tfloat offsetRotate)\n{\n \tvec3 c = getPalette(freq);\n   \n    mat2 midRotate = rotate2D(offsetRotate + (M_2_PI / total) * (s + 0.5));\n    vec2 q = midRotate*coord;\n    vec2 mid = vec2(0.0, ringRadius + ringSize*0.5);\n    \n    vec3 bloom = mix(c, vec3(1,1,1), 0.70);\n    \n    addScene(col, bloom, sq(q, mid - vec2(0.0, sqRadius*0.125), sqRadius, 0.5+(freq*freq)*3.5), sqRadius*1.5);        \n}\n    \n\nvoid addRingSegment(\n    inout vec3 col, \n    vec2 coord, \n    float freq, \n    float ringRadius, \n    float ringSize, \n    float s, \n    float total, \n    float sqRadius,\n\tfloat offsetRotate)\n{\n    float angle0 = offsetRotate + (M_2_PI / total) * s;\n    float angle1 = offsetRotate + (M_2_PI / total) * (s + 1.0);\n        \n \tvec2 inner0 = vec2(0.0, ringRadius) * rotate2D(angle0);\n    vec2 inner1 = vec2(0.0, ringRadius) * rotate2D(angle1);\n\n    vec2 outer0 = vec2(0.0, ringRadius) * rotate2D(angle0);\n    vec2 outer1 = vec2(0.0, ringRadius) * rotate2D(angle1);\n\t\n    vec3 c = getPalette(freq);\n    \n    mat2 midRotate = rotate2D(offsetRotate + (M_2_PI / total) * (s + 0.5));\n    vec2 q = midRotate*coord;\n    vec2 mid = vec2(0.0, ringRadius + ringSize*0.5);\n    \n    float de = sq(q, mid - vec2(0.0, sqRadius*0.125), sqRadius, 0.5+(freq*freq)*3.5);\n    \n    vec3 ac = mix(c, vec3(1,1,1), 0.5);\n    c = mix(c, ac, smoothstep(0.0, 2.5/iResolution.x, abs(de)));\n    \n    addScene(col, c, de);    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 coord = -1.0 + 2.0*uv;\n    coord.y /= aspect;\n\n    float ro[4];\n    ro[0] = 0.10;\n    ro[1] = 0.21;\n    ro[2] = 0.32;\n    ro[3] = 0.43;\n    \n    float rs[4];\n    rs[0] = 0.10;\n    rs[1] = 0.10;\n    rs[2] = 0.10;\n    rs[3] = 0.10;\n    \n    vec3 bc = vec3(0.9, 0.9, 0.9);\n    addScene(col, bc, abs(sq(coord, vec2(0,0), ro[0], 2.0)));      \n    addScene(col, bc, abs(sq(coord, vec2(0,0), ro[1], 2.0)));\n    addScene(col, bc, abs(sq(coord, vec2(0,0), ro[2], 2.0)));\n    addScene(col, bc, abs(sq(coord, vec2(0,0), ro[3], 2.0)));\n    addScene(col, bc, abs(sq(coord, vec2(0,0), ro[3]+rs[3], 2.0)));\n    \n    // Ring 0\n    float ring0 = avgFreq(1, 30);\n    const int numSegments0 = 24;\n    \n    for (int i = 0; i < numSegments0; i++)\n    {\n        if (float(i) / float(numSegments0-1) >= ring0) { break; }\n        addRingBloom(col, coord, ring0, ro[0], rs[0], float(i), float(numSegments0), 0.015, iTime);\n    }\n    \n    for (int i = 0; i < numSegments0; i++)\n    {\n        if (float(i) / float(numSegments0-1) >= ring0) { break; }\n        addRingSegment(col, coord, ring0, ro[0], rs[0], float(i), float(numSegments0), 0.015, iTime);\n    }\n    \n    // Ring 1\n    float ring1 = avgFreq(10, 30);\n    const int numSegments1 = 28;\n\n    for (int i = 0; i < numSegments1; i++)\n    {\n        if (float(i) / float(numSegments1-1) >= ring1) { break; }\n        addRingBloom(col, coord, ring1, ro[1], rs[1], float(i), float(numSegments1), 0.020, iTime*1.5);\n    }\n    \n    for (int i = 0; i < numSegments1; i++)\n    {\n        if (float(i) / float(numSegments1-1) >= ring1) { break; }\n        addRingSegment(col, coord, ring1, ro[1], rs[1], float(i), float(numSegments1), 0.020, iTime*1.5);\n    }\n    \n    // Ring 2\n    float ring2 = avgFreq(20, 30);\n    const int numSegments2 = 32;\n    \n    for (int i = 0; i < numSegments2; i++)\n    {\n        if (float(i) / float(numSegments2-1) >= ring2) { break; }\n        addRingBloom(col, coord, ring2, ro[2], rs[2], float(i), float(numSegments2), 0.025, iTime*2.0);\n    }      \n    \n    for (int i = 0; i < numSegments2; i++)\n    {\n        if (float(i) / float(numSegments2-1) >= ring2) { break; }\n        addRingSegment(col, coord, ring2, ro[2], rs[2], float(i), float(numSegments2), 0.025, iTime*2.0);\n    }    \n    \n    // Ring 3\n    float ring3 = avgFreq(30, 30);\n    const int numSegments3 = 32;\n    \n    for (int i = 0; i < numSegments3; i++)\n    {\n        if (float(i) / float(numSegments3-1) >= ring3) { break; }\n        addRingBloom(col, coord, ring3, ro[3], rs[3], float(i), float(numSegments3), 0.030, iTime*2.5);\n    }     \n    \n    for (int i = 0; i < numSegments3; i++)\n    {\n        if (float(i) / float(numSegments3-1) >= ring3) { break; }\n        addRingSegment(col, coord, ring3, ro[3], rs[3], float(i), float(numSegments3), 0.030, iTime*2.5);\n    }      \n    \n    \n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}