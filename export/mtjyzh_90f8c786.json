{"ver":"0.1","info":{"id":"mtjyzh","date":"1691496357","viewed":53,"name":"Implicit Parametric compare","username":"Envy24","description":"Drag control point to better see difference.\nRed - Cubic Bezier from link (incorrect),\nBlue - correct cubic Bezier.\nhttps://www.shadertoy.com/view/dtjcRh","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["implicit","plotter","tangent","graphs"],"hasliked":0,"parentid":"DtlcDs","parentname":"One More Implicit Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ORIGIN                    ( vec2(-0.5, -0.25) )\n#define SCENE_SCALE               ( 0.5 )\n#define UNIT                      ( 3.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n// Parametric function.\nvec2 A = vec2(0, 0.), B = vec2(.25, sin(1.5) * 0.5), C = vec2(0.75, 0.25), D = vec2(1, 0.);\nfloat X(float t) \n{ \n    float f = 1. - t;\n    return f*f*(A.x*f + 3.*B.x*t) + t*t*(3.*C.x*f + D.x*t); \n}\nfloat Y(float t) \n{ \n    float f = 1. - t;\n    return f*f*(A.y*f + 3.*B.y*t) + t*t*(3.*C.y*f + D.y*t); \n}\nvec2 parametric(float t) { return vec2(X(t), Y(t)); } // Cubic Bezier.\n\n// P(x, y) = P(x(t), y(t)) = P(x(t), 0) + P(0, y(t))\n\n// Implicit function definition.\nfloat implicit(float x, float y) { return Y(x) - y; } // defined like here: https://www.shadertoy.com/view/dtjcRh\n\n// Expensive method.\nfloat implicitAA( in vec2 NDC )\n{\n    float coverage = 0., // You can cheat and set this variable to some negative value.\n          th = 6.,        // thickness\n          c = implicit(NDC.x, NDC.y) >= 0. ? 1. : -1.; // only sign\n    \n    vec2 ps = vec2(0.35*SCENE_SCALE/iResolution.y); // affects thickness and artifacts\n   \n    // Supersampling.\n    for (float y = -th; y <= th; y += 1.)\n        for (float x = -th; x <= th; x += 1.)\n        {\n            vec2 p = NDC + vec2(x, y)*ps;\n            float n = implicit(p.x, p.y);\n            \n            /* 1. Filled shape *\n            coverage += n >= 0.0 ? 0.0 : 1.0;\n            /* 2. Shape contour */\n            n = n >= 0.0 ? 1. : -1.;\n            coverage += c == n ? 0. : 1.;\n            /**/\n        }\n  \n    // Convert coverage into intensity (.35 is arbitrary weight for AA).\n    return smoothstep(0., th*th, coverage*0.35);\n}\n\n// https://www.shadertoy.com/view/Dd23Ww#\nfloat parametric_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric(linear_remap(from.x, from, to));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from, to);\n    \n        vec2 E = parametric(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n    //return minimal_distance - 0.01;\n}\n       \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         XY_MAXs = map_to_centered_ndc(iResolution.xy, SCENE_SCALE, ORIGIN, false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n         \n    // Update control point.\n    C = iMouse.z > 0. ? MP : C;\n    \n    vec2 x_range = vec2(-XY_MAXs.x, XY_MAXs.x),\n         y_range = vec2(-XY_MAXs.y, XY_MAXs.y);\n\n    /* Implicit function f(x,y) */\n    color = mix(color, vec3(1,0,0), implicitAA(NDC));\n    \n    /* Parametric function P(x(t), y(t)) */\n    vec2 from = x_range, to = vec2(0, 1);   \n    color = mix(color, vec3(0,0,1), SMAA(parametric_sdf(NDC, from, to, 64.)));\n    \n    /* Control points */\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF(NDC, A, 0.01)));\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF(NDC, B, 0.01)));\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF(NDC, C, 0.01)));\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF(NDC, D, 0.01)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat linear_remap(float val, vec2 from, vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}","name":"Common","description":"","type":"common"}]}