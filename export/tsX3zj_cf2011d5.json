{"ver":"0.1","info":{"id":"tsX3zj","date":"1547097692","viewed":346,"name":"Tetris: The Grandmaster","username":"rory618","description":"Tetris has got to be my favorite game of all time. Based on TGM1 with efficiency and parallelism in mind. Will add some details and fix bugs/cleanup in time. Should run great now on windows, but seems to be a huge mess on linux.\nZ/X to rot, down to drop.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["game","tgm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getFeild(float x,float y){\n    if(x<0. || x>=10. || y<0.) return vec4(1);\n    if(  y >= 20.) return vec4(0);\n    return texture(iChannel0,(.5+floor(vec2(x,y/4.)))/R.xy);\n}\n\nbool keyPressed(int key){\n    return  texelFetch( iChannel1, ivec2(key,1),0).x>.5;\n}\nbool keyDown(int key){\n    return  texelFetch( iChannel1, ivec2(key,0),0).x>.5;\n}\nbool getCollision(int p, int x, int y, int rot){\n    if(y<0) return true;\n    if(p==0){\n        if(x<-1) return true;\n    \treturn texture(iChannel3, (.5+vec2(1+x+10*p,y+20*rot))/R.xy).x>.5;\n    } else {\n        if(x<0) return true;\n        if(x>=10) return true;\n    \treturn texture(iChannel3, (.5+vec2(x+10*p,y+20*rot))/R.xy).x>.5;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n//Block and highlight colors\nvec4[] colors = vec4[]( vec4(246,125,3,255)/255.,\n                        vec4(0,205,221,255)/255.,\n                        vec4(233,146,0,255)/255.,\n                        vec4(0,133,235,255)/255.,\n                        vec4(222,28,222,255)/255.,\n                        vec4(85,229,0,255)/255.,\n                        vec4(212,197,0,255)/255.\n                      );\nvec4[] colors2 = vec4[]( vec4(203,19,10,255)/255.,\n                        vec4(0,131,175,255)/255.,\n                        vec4(199,84,0,255)/255.,\n                        vec4(0,32,192,255)/255.,\n                        vec4(141,5,141,255)/255.,\n                        vec4(5,148,0,255)/255.,\n                        vec4(149,122,0,255)/255.\n                      );\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec4 state0 = texelFetch(iChannel2,ivec2(0,0),0);\n    vec4 state1 = texelFetch(iChannel2,ivec2(0,1),0);\n    vec4 state2 = texelFetch(iChannel2,ivec2(0,2),0);\n    \n    int bc = int(state2.w); //Level counter\n    \n    \n    //Load the game state variables, first the piece\n    \n    int rot = int(state0.x);\n    int x = int(state0.y);  \n    int y = int(state0.z);   \n    int p = int(state0.w);  \n    \n    //Then the various timers which tick down to zero.\n    \n    int ARE = int(state1.x);   //Time to spawn piece\n    int LCK = int(state1.y);   //Timer to lock piece once it hits the ground\n    int DAS = int(state1.z);   //Timer to start repeating arrow direction\n    int GRV = int(state1.w);   //Timer before dropping the piece from gravity\n    \n    //Binary coding of the sprite for the blocks\n    int[] sprite = int[] (0x00,0x00,0x01,0x05,0x2B,0x57,0x7F,0x7F);\n    \n    \n    \n    o = vec4(0);\n    \n    //Scale so that pixels are a little bigger, alternating every other row/column being twice as small if that fits the screen better\n    float scale = max(1.,floor(R.y/100.)/2.);\n    i=floor(i/scale);\n    vec2 feildBotLeft = vec2(floor(R.x/2.)/scale-80./scale,10);\n    \n    \n\tif(i.x>=feildBotLeft.x && i.x < feildBotLeft.x+81.&&\n       i.y>=feildBotLeft.y && i.y < feildBotLeft.y+161.){\n        i-=feildBotLeft;\n        //Draw grid lines\n        if(mod(i.x,8.)==0.)  o = vec4(.7);\n        if(mod(i.y,8.)==0.)  o = vec4(.7);\n        \n        //get block from feild buffer\n        float c = max(0.,floor(texture(iChannel0, (.5+floor(i/vec2(8.,32.)))/R.xy)[imod(int(i.y/8.),4)]));\n        vec2 blockPos = vec2(x,y);\n        \n        //Also include the current block\n        ivec2 deltaPos = ivec2( floor(i/8.)-blockPos)+1 ;\n        if(ARE==0&&deltaPos.x>=0 && deltaPos.x<4 && deltaPos.y>=0 && deltaPos.y<4){\n        \tc += getBlock(p)[rot][deltaPos.y][deltaPos.x]*float(1+p);\n        }\n        \n        //Draw the block\n        if(c!=0.&&i.x<80.&&i.y<160.){\n            \n            o=((sprite[int(mod(i.y,8.))]>>int(mod(i.x,8.)))&1)==0?colors2[int(c)-1]:colors[int(c)-1];\n        }\n        \n    } else {\n        \n        //Draw the piece preview\n        i-=feildBotLeft;\n        i-=vec2(4,21)*8.;\n        \n        int n = int(texture(iChannel2,vec2(.5,0)).w);\n        \n        vec2 blockPos = vec2(0);\n        \n        ivec2 deltaPos = ivec2( floor(i/8.)-blockPos)+1 ;\n        float c = 0.;\n        if(deltaPos.x>=0 && deltaPos.x<4 && deltaPos.y>=0 && deltaPos.y<4){\n        \tc += getBlock(n)[0][deltaPos.y][deltaPos.x]*float(1+n);\n        }\n        if(c!=0.){\n            o=((sprite[int(mod(i.y,8.))]>>int(mod(i.x,8.)))&1)==0?colors2[int(c)-1]:colors[int(c)-1];\n        }\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getFeild(float x,float y){\n    if(x<0. || x>=10. || y<0.) return vec4(1);\n    if(  y >= 20.) return vec4(0);\n    return texture(iChannel0,(.5+floor(vec2(x,y/4.)))/R.xy);\n}\n\nbool keyPressed(int key){\n    return  texelFetch( iChannel1, ivec2(key,1),0).x>.5;\n}\nbool keyDown(int key){\n    return  texelFetch( iChannel1, ivec2(key,0),0).x>.5;\n}\nbool getCollision(int p, int x, int y, int rot){\n    if(y<0) return true;\n    if(p==0){\n        if(x<-1) return true;\n    \treturn texture(iChannel3, (.5+vec2(1+x+10*p,y+20*rot))/R.xy).x>.5;\n    } else {\n        if(x<0) return true;\n        if(x>=10) return true;\n    \treturn texture(iChannel3, (.5+vec2(x+10*p,y+20*rot))/R.xy).x>.5;\n    }\n}\n\n\n\n//Calculate collisions\n//Pre calculate an entire collision space without using any game state information\n//Could use a little bit and only calculate collision for the current piece for example,\n//but performance is good with this method, only 8 textures and 16 iterations per thread to\n//compute collisions for all piece, x, y, and rotation\n\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    \n    if(i.x<70. && i.y<80.){\n        \n        //Seperate i into 4d collision space\n        int peice_num = int(i.x/10.);\n        int rotation = int(i.y/20.);\n        mat4 peice = getBlock(peice_num)[rotation];\n        vec2 loc = floor(mod(i,vec2(10,20)));\n        \n        if(peice_num==0){\n            loc.x--;\n        }\n        bool collision = false;\n        \n        //Load the upper and lower 4x4 chuks that could intersect the 4x4 piece matrix located at this location\n        mat4 lowerBlock = mat4(getFeild(loc.x-1.,(loc.y-1.)),\n                               getFeild(loc.x   ,(loc.y-1.)),\n                               getFeild(loc.x+1.,(loc.y-1.)),\n                               getFeild(loc.x+2.,(loc.y-1.)));\n        mat4 upperBlock = mat4(getFeild(loc.x-1.,(loc.y+3.)),\n                               getFeild(loc.x   ,(loc.y+3.)),\n                               getFeild(loc.x+1.,(loc.y+3.)),\n                               getFeild(loc.x+2.,(loc.y+3.)));\n        \n        //Check each of the 16 points for a collision\n        for(int i = 0; i < 16; i++){\n            ivec2 delta_pos = ivec2(i/4,imod(i,4));\n            float a = peice[delta_pos.y][delta_pos.x];\n            int vshift = int(.1+mod(loc.y-1.,4.));\n            float b = delta_pos.y + vshift >= 4?upperBlock[delta_pos.x][delta_pos.y+vshift-4] : lowerBlock[delta_pos.x][delta_pos.y+vshift];\n        \tcollision = collision || a*max(0.,b)!=0.;\n        }\n       o = vec4(collision);\n    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"int imod(int a, int b){\n    return a%b;\n    //return (a+b*10)-((a+b*10)/b)*b;\n    \n}\n\n\n#define R iResolution\n\n#define swapIfAisMinusOne(a,b) if(a==-1.){float t = a;a=b;b=t;}\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE  = 32;\n\nconst int KEY_Z  = 90;\nconst int KEY_X  = 88;\n\n\n\nmat4[] I =mat4[](\tmat4(\n                  0,0,0,0,\n                  1,1,1,1,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,0,1,0,\n                  0,0,1,0,\n                  0,0,1,0,\n                  0,0,1,0),\n                    mat4(\n                  0,0,0,0,\n                  1,1,1,1,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,0,1,0,\n                  0,0,1,0,\n                  0,0,1,0,\n                  0,0,1,0));\n\nmat4[] T =mat4[](\tmat4(\n                  0,1,0,0,\n                  1,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,1,0,0,\n                  1,1,0,0,\n                  0,1,0,0,\n                  0,0,0,0),\n                 mat4(\n                  1,1,1,0,\n                  0,1,0,0,\n                  0,0,0,0,\n                  0,0,0,0),\n                 mat4(\n                  0,1,0,0,\n                  0,1,1,0,\n                  0,1,0,0,\n                  0,0,0,0));\n\nmat4[] L =mat4[](\tmat4(\n                  1,0,0,0,\n                  1,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,1,0,0,\n                  0,1,0,0,\n                  1,1,0,0,\n                  0,0,0,0),\n                 mat4(\n                  1,1,1,0,\n                  0,0,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n                 mat4(\n                  0,1,1,0,\n                  0,1,0,0,\n                  0,1,0,0,\n                  0,0,0,0));\n\nmat4[] J =mat4[](\tmat4(\n                  0,0,1,0,\n                  1,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  1,1,0,0,\n                  0,1,0,0,\n                  0,1,0,0,\n                  0,0,0,0),\n                    mat4(\n                  1,1,1,0,\n                  1,0,0,0,\n                  0,0,0,0,\n                  0,0,0,0),\n                    mat4(\n                  0,1,0,0,\n                  0,1,0,0,\n                  0,1,1,0,\n                  0,0,0,0));\nmat4[] S =mat4[](\tmat4(\n                  1,1,0,0,\n                  0,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,1,0,0,\n                  1,1,0,0,\n                  1,0,0,0,\n                  0,0,0,0),\n                \tmat4(\n                  1,1,0,0,\n                  0,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,1,0,0,\n                  1,1,0,0,\n                  1,0,0,0,\n                  0,0,0,0));\nmat4[] Z =mat4[](\tmat4(\n                  0,1,1,0,\n                  1,1,0,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,1,0,0,\n                  0,1,1,0,\n                  0,0,1,0,\n                  0,0,0,0),\n                    mat4(\n                  0,1,1,0,\n                  1,1,0,0,\n                  0,0,0,0,\n                  0,0,0,0),\n          \t\t\tmat4(\n                  0,1,0,0,\n                  0,1,1,0,\n                  0,0,1,0,\n                  0,0,0,0));\nmat4[] O =mat4[] (mat4(\n                  0,1,1,0,\n                  0,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n                  mat4(\n                  0,1,1,0,\n                  0,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n                  mat4(\n                  0,1,1,0,\n                  0,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0),\n                  mat4(\n                  0,1,1,0,\n                  0,1,1,0,\n                  0,0,0,0,\n                  0,0,0,0));\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nmat4[4] getBlock(int b){\n    if(b==0){ return I; } else\n    if(b==1){ return T; } else \n    if(b==2){ return L; } else \n    if(b==3){ return J; } else \n    if(b==4){ return S; } else \n    if(b==5){ return Z; } else\n            { return O; }\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getFeild(float x,float y){\n    if(x<0. || x>=10. || y<0.) return vec4(1);\n    if(  y >= 20.) return vec4(0);\n    return texture(iChannel0,(.5+floor(vec2(x,y/4.)))/R.xy);\n}\n\nbool keyPressed(int key){\n    return  texelFetch( iChannel1, ivec2(key,1),0).x>.5;\n}\nbool keyDown(int key){\n    return  texelFetch( iChannel1, ivec2(key,0),0).x>.5;\n}\nbool getCollision(int p, int x, int y, int rot){\n    if(y<0) return true;\n    if(p==0){\n        if(x<-1) return true;\n        if(x>=10) return true;\n    \treturn texture(iChannel3, (.5+vec2(1+x+10*p,y+20*rot))/R.xy).x>.5;\n    } else {\n        if(x<0) return true;\n        if(x>=10) return true;\n    \treturn texture(iChannel3, (.5+vec2(x+10*p,y+20*rot))/R.xy).x>.5;\n    }\n}\n\n\nint[] levs = int[](0,30,35,40,50,60,70,80,90,100,120,140,160,170,200,220,230,233,236,239,243,247,251,300,330,360,400,420,450,500,1000);\nint[] gravs = int[](4,6,8,10,12,16,32,48,64,80,96,112,128,144,4,32,64,96,128,160,192,224,256,512,768,1024,1280,1024,768,5120);\n\n//Calculate peice state\n\n\n\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    \n          \n    vec4 state0 = texelFetch(iChannel2,ivec2(0,0),0);\n    vec4 state1 = texelFetch(iChannel2,ivec2(0,1),0);\n    vec4 state2 = texelFetch(iChannel2,ivec2(0,2),0);\n    \n    int bc = int(state2.x);\n    int gc = int(state2.y);\n    if(bc>=levs[gc+1]){\n        gc++;\n    }\n    \n    int rot = int(state0.x);\n    int x = int(state0.y);  \n    int y = int(state0.z);   \n    int p = int(state0.w);  \n    int ARE = int(state1.x);  \n    int LCK = int(state1.y);  \n    int DAS = int(state1.z); \n    int GRV = int(state1.w);\n    \n    //Gravity based on time, should really be based on 'level' which would increase with each piece placed and given by a table\n    int gravity = gravs[gc];/*1+iFrame/50;*/\n    bool dead = false;\n    o = texture(iChannel2, i/R.xy);  \n    \n    //Spawn new peice and check the losing condition, that is an intersection with an existing block on spawn\n    if(ARE>=1 && ARE <=30){\n        x=4;\n        y=19;\n        \n        //Pre rotate\n        rot=keyDown(KEY_Z)?3:(keyDown(KEY_X)?1:0);\n        \n        p=int(texture(iChannel2,vec2(.5,0)).w);\n        \n        LCK=0;\n        dead = getCollision(p,x,y,rot);\n        \n    }     \n    if(i.x<1.){\n        if(iFrame<3 || dead){\n            x=4;\n            y=19;\n            rot=0;\n            //Grab new piece from the stack\n            p=int(texture(iChannel2,vec2(.5,0)).w);\n            ARE=0;\n            LCK=0;\n            DAS=0;\n        }\n        //Count down all the timers\n        ARE-=ARE==0?0:1;\n        LCK-=LCK==0?0:1;\n        DAS-=DAS<=1?0:1; //DAS stops at one and stays active, rest of the timers trigger at 1 or 0 for a single frame\n        GRV-=GRV==0?0:1;\n        //rot++;\n        if(GRV==0){\n            //Fall until a collision, based on gravity\n            for(int j = 0; j<min(1+gravity/256,20);j++){\n                if(!getCollision(p,x,y-1,rot)){\n                    y--;\n                } else {\n                    break;\n                }\n            }\n            //When gravity > 256 there is a drop every frame, GRV timer reset to 1 and immediately activates\n            GRV = 256/gravity;\n        }\n        \n        //Calculate rotation\n        //First try rotating in place\n        //The try shift once left\n        //Then try shift right once\n        //Finally choose the first rotation that didnt cause a collision, and skip rotation if all collide\n        \n        if(keyPressed(KEY_Z)  ){\n            int nrot = rot-1;\n            if(nrot<0) nrot=3;\n            if(nrot>3) nrot=0;\n            bool a = !getCollision(p,x,y,nrot);\n            bool b = !getCollision(p,x-1,y,nrot);\n            bool c = !getCollision(p,x+1,y,nrot);\n            \n            if(a){\n            \trot=nrot;\n            } else if(b) {\n            \trot=nrot;\n                x--;\n            } else if(c) {\n            \trot=nrot;\n                x++;\n            }\n        };\n        if(keyPressed(KEY_X)  ){\n            int nrot = rot+1;\n            if(nrot<0) nrot=3;\n            if(nrot>3) nrot=0;\n            \n            \n            bool a = !getCollision(p,x,y,nrot);\n            bool b = !getCollision(p,x-1,y,nrot);\n            bool c = !getCollision(p,x+1,y,nrot);\n            \n            if(a){\n            \trot=nrot;\n            } else if(b) {\n            \trot=nrot;\n                x--;\n            } else if(c) {\n            \trot=nrot;\n                x++;\n            }\n        }\n        //As soon as an arrow key is pressed it should begin the DAS timer\n        if(keyPressed(KEY_LEFT ) || keyPressed(KEY_RIGHT) ){\n            DAS=15;\n                \n        }\n        //If no keys are down there should be no DAS\n        if(!keyDown(KEY_LEFT) && !keyDown(KEY_RIGHT)){\n            DAS=0;\n        }\n        \n        //If key is tapped or if DAS is active and the space is free, then move the block left or right\n        if((keyPressed(KEY_LEFT )||(DAS==1&&keyDown(KEY_LEFT ))) && !getCollision(p,x-1,y,rot)){x--;}\n        if((keyPressed(KEY_RIGHT)||(DAS==1&&keyDown(KEY_RIGHT))) && !getCollision(p,x+1,y,rot)){x++;}\n        \n               \n        //If the block is resting on the feild then begin the lock delay\n        if(getCollision(p,x,y-1,rot)){\n            if(LCK==0){\n                LCK=31;\n            }\n            if(ARE==0&&keyDown(KEY_DOWN)){\n                LCK=1;\n            }\n        } else {\n            //If floating then stop the lock delay and allow soft drop with down arrow\n            LCK=0;\n            if(keyDown(KEY_DOWN)){\n                y--;\n            }\n        }\n        //Start ARE timer for next block after locking\n        if(LCK==1){\n            ARE=31;\n            bc++;\n        }\n        \n        //Keep things from falling through the floor sometimes\n        y = max(0,y);\n        \n        o=i.y>1.?(i.y>2.?vec4(bc,gc,0,0):vec4(ARE,LCK,DAS,GRV)):vec4(rot,x,y,p);\n        \n    } else {\n        //Compute the next piece stack:\n        //Initialize with 4 Z pieces\n        //Try 4 times to randomly select a new piece that isnt in the stack\n        //Shift them all down whenever a new piece gets taken out\n        //Shift once at the start so you dont get a Z\n        if(iFrame<3 || dead){\n            o=vec4(5);\n            int np = IHash(0);\n            if(any(equal(vec4(imod(np,7)),o))) np=IHash(np);\n            if(any(equal(vec4(imod(np,7)),o))) np=IHash(np);\n            if(any(equal(vec4(imod(np,7)),o))) np=IHash(np);\n            o.xyz=o.yzw;\n            o.w=float(imod(np,7));\n        } else if(ARE==1){\n            int np = IHash(iFrame);\n            if(any(equal(vec4(imod(np,7)),o))) np=IHash(np);\n            if(any(equal(vec4(imod(np,7)),o))) np=IHash(np);\n            if(any(equal(vec4(imod(np,7)),o))) np=IHash(np);\n            o.xyz=o.yzw;\n            o.w=float(imod(np,7));\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 getFeild(float x,float y){\n    if(x<0. || x>=10. || y<0.) return vec4(1);\n    if(  y >= 20.) return vec4(0);\n    return texture(iChannel0,(.5+floor(vec2(x,y/4.)))/R.xy);\n}\n\nbool keyPressed(int key){\n    return  texelFetch( iChannel1, ivec2(key,1),0).x>.5;\n}\nbool keyDown(int key){\n    return  texelFetch( iChannel1, ivec2(key,0),0).x>.5;\n}\nbool getCollision(int p, int x, int y, int rot){\n    if(y<0) return true;\n    if(p==0){\n        if(x<-1) return true;\n    \treturn texture(iChannel3, (.5+vec2(1+x+10*p,y+20*rot))/R.xy).x>.5;\n    } else {\n        if(x<0) return true;\n        if(x>=10) return true;\n    \treturn texture(iChannel3, (.5+vec2(x+10*p,y+20*rot))/R.xy).x>.5;\n    }\n}\n\n\n//Calculate the feild\n//Each pixel stores a column of 4 cells in R G B A\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec4 state0 = texelFetch(iChannel2,ivec2(0,0),0);\n    vec4 state1 = texelFetch(iChannel2,ivec2(0,1),0);\n    vec4 state2 = texelFetch(iChannel2,ivec2(0,2),0);\n    int bc = int(state2.w);\n    int rot = int(state0.x);\n    int x = int(state0.y);  \n    int y = int(state0.z);   \n    int p = int(state0.w);  \n    int ARE = int(state1.x);  \n    int LCK = int(state1.y);  \n    int DAS = int(state1.z); \n    int GRV = int(state1.w);\n    \n    bool dead = false;\n    o = texture(iChannel0, i/R.xy);\n    \n    //Spawn new peice and check the losing condition, that is an intersection with an existing block on spawn\n    if(ARE>=1 && ARE <=30){\n        x=4;\n        y=19;\n        rot=keyDown(KEY_Z)?3:(keyDown(KEY_X)?1:0);\n        \n        p=imod((iFrame+ARE),7);\n        LCK=0;\n        dead = getCollision(p,x,y,rot);\n        \n    }\n    if(i.x<10. && i.y<5.){\n        if(iFrame<3 || dead){\n    \t\to = vec4(0);\n        }\n        \n        //Do a bunch of swapping to get rows that are cleared up and away, bringing the blocks above down the proper amount\n        vec4 bup = getFeild(floor(i.x),floor(i.y)*4.+4.);\n        vec4 bdown = getFeild(floor(i.x),floor(i.y)*4.-4.);\n        if(imod(iFrame,4)==0){\n        \tswapIfAisMinusOne(o.x,o.y);\n        \tswapIfAisMinusOne(o.y,o.z);\n        \tswapIfAisMinusOne(o.z,o.w);\n        \tswapIfAisMinusOne(o.x,o.y);\n        \tswapIfAisMinusOne(o.y,o.z);\n        \tswapIfAisMinusOne(o.z,o.w);\n        } else if(imod(iFrame,4)==2) {\n            swapIfAisMinusOne(bdown.w,o.x);\n            swapIfAisMinusOne(o.w,bup.x);\n        } else if(imod(iFrame,4)==1) {\n        }\n        \n        //Lock the peice by adding the squares the peices are made of to the corresponding channel if the block lies in that square\n        if(LCK==1){\n            for(int k = 0; k <4; k++){\n                vec2 blockPos = vec2(x,y);\n                ivec2 deltaPos = ivec2( vec2(floor(i.x),floor(i.y)*4.+float(k))-blockPos)+1 ;\n                if(deltaPos.x>=0&&deltaPos.x<4&&deltaPos.y>=0&&deltaPos.y<4){\n                \to[k] += getBlock(p)[rot][deltaPos.y][deltaPos.x]*float(1+p);\n                }\n            }\n        }\n        \n        //Find rows with no zeros\n        vec4 clears = vec4(1);\n        for(int x = 0; x < 10; x++){\n            vec4 f = min(vec4(1),max(vec4(0),getFeild(float(x),i.y*4.)));\n            clears*=f;\n        }\n        \n        //Fill each cleared row with -1's\n        o = o * (1.-clears) - clears;\n        \n    } else {\n        o = vec4(0);\n    }\n\n}","name":"Buffer C","description":"","type":"buffer"}]}