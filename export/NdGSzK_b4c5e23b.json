{"ver":"0.1","info":{"id":"NdGSzK","date":"1634917567","viewed":79,"name":"Mandelbrot Javachup","username":"Javachup","description":"Mandelbrot :) ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*************************************\n\nHello! Welcome to my fist actually functional shader! \n\nControls: \n    WASD to move \n    Q Zoom Out, E Zoom In \n    1-5 select speeds (1 is fast, 5 is slow)\n    \nTake a meander around and explore the \ninfinite goodness there is to offer \n\n(Pause the timer and reset to get back to starting position) \n\n*************************************/\n\n#define pos texelFetch( iChannel0, ivec2(0,0), 0 ).xy\n#define scale texelFetch( iChannel0, ivec2(0,0), 0 ).z\n\n/* Mandelbrot Consts */\nconst int maxIters = 1000;\nconst float threshhold = 100.0;\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_conj(a) vec2(a.x, -a.y)\n\n/* Mandlebrot Stuff */\nvec2 Func(vec2 z, vec2 c)\n{\n    return cx_mul(z, z) + c;\n}\n\nint Iterate(vec2 c)\n{\n    vec2 z = vec2(0, 0);\n    \n    for (int i = 0; i < maxIters; i++)\n    {\n        z = Func(z, c);\n        if (length(z) > threshhold)\n            return i;\n    }\n    \n    return maxIters;\n}\n\n/* Main */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = scale * (fragCoord.xy/iResolution.y) + pos;\n\n    float val = float(Iterate(c))/float(maxIters);\n\n\n    fragColor = vec4(val, val, val, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Returns 1 if key is pressed else returns 0 \n#define GetKey(keyCode) texelFetch(iChannel1, ivec2(keyCode, 0), 0).x\n\n#define info texelFetch( iChannel0, ivec2(0, 0), 0)\n\n/* Movement Consts */\nconst int k_W = 87;\nconst int k_A = 65;\nconst int k_S = 83;\nconst int k_D = 68;\n\nconst int k_E = 69;\nconst int k_Q = 81;\n\nconst int k_1 = 49;\nconst int k_2 = 50;\nconst int k_3 = 51;\nconst int k_4 = 52;\nconst int k_5 = 53;\nconst int k_6 = 54;\nconst int k_7 = 55;\nconst int k_8 = 56;\nconst int k_9 = 57;\nconst int k_0 = 48;\n\nconst float[] speeds = float[](.01, 0.001, .0001, .00001, .000001);\n\n//const int k_Left = 37;\n//const int k_Right = 39;\n//const int k_Up = 38;\n//const int k_Down = 40;\n\n//const float accel = 0.0001;\n//const float minSpeed = 0.0;\n//const float maxSpeed = 0.5;\n\nconst vec2 initPos = vec2(-0.5, -0.5);\nconst float initScale = 1.0;\nconst float initSpeed = 0.01;\n\nvec2 HandlePos(vec2 pos, float speed)\n{\n    vec2 up =    GetKey(k_W) * vec2( 0, 1);\n    vec2 left =  GetKey(k_A) * vec2(-1, 0);\n    vec2 down =  GetKey(k_S) * vec2( 0,-1);\n    vec2 right = GetKey(k_D) * vec2( 1, 0);\n    \n    pos += (up + left + down + right) * speed;\n    return pos;\n}\n\nfloat HandleScale(float scale, float speed)\n{\n    float zoomIn = -GetKey(k_E);\n    float zoomOut = GetKey(k_Q);\n    \n    scale += (zoomIn + zoomOut) * speed;\n    return max(scale, 0.0);\n}\n\nfloat HandleSpeed(float speed)\n{\n    if(GetKey(k_1) == 1.0)\n        return speeds[0];\n    if(GetKey(k_2) == 1.0)\n        return speeds[1];\n    if(GetKey(k_3) == 1.0)\n        return speeds[2];\n    if(GetKey(k_4) == 1.0)\n        return speeds[3];\n    if(GetKey(k_5) == 1.0)\n        return speeds[4];\n    \n    return speed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the previous frame's info \n    vec2 pos = info.xy;\n    float scale = info.z;\n    float speed = info.w;\n\n    if (iTime <= 0.5)\n    {\n        pos = initPos;\n        scale = initScale;\n        speed = initSpeed;\n    }\n    \n    // Update pos and scale \n    pos = HandlePos(pos, speed);\n    scale = HandleScale(scale, speed);\n    speed = HandleSpeed(speed);\n\n    // Stores the pos as the .xy and scale as .z of every pixel in the buffer \n    fragColor = vec4(pos, scale, speed);\n}","name":"Buffer A","description":"","type":"buffer"}]}