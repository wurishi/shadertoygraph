{"ver":"0.1","info":{"id":"4fG3W3","date":"1714242698","viewed":163,"name":"dango","username":"badatcode123","description":"it's a dango \nto dethrone dangocatX emoji in turbowarp server\nalso my first pathtracer in shadertoy so yay","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["pathtracer","dango","turbowarp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x){\n   float a = 2.51;\n   float b = 0.03;\n   float c = 2.43;\n   float d = 0.59;\n   float e = 0.14;\n   return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = ACESFilm(texelFetch(iChannel0,ivec2(fragCoord),0).rgb);\n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define W 87\n#define S 83\n#define A 65\n#define D 68\n#define Q 81\n#define E 69\n#define steps 1.0\nvec3 col;\nvec3 mouse_pos;\nfloat key(in int keynum)\n{\n   return float(texelFetch(iChannel0,ivec2(keynum,0),0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool moved = false;\n    vec3 cam_pos = texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    if (iFrame <= 1)\n    {\n      if (fragCoord.x <= 1.0)\n      {\n        col = vec3(0.0,0.0,-100.0);\n      }\n      else if (fragCoord.x < 55.0)\n      {\n        vec2 mouse_pos = vec2(0.0,0.0);\n        col = vec3(mouse_pos,0.0);\n      }\n      else\n      {\n        col = vec3(1,0,0);\n      }\n    }\n    else\n    {\n      vec2 mouse_pos = vec2(0);\n      mouse_pos = (iMouse.yx-iResolution.yx/2.0)/100.0;\n      mouse_pos.x *= -1.0;\n      moved = bool(abs(key(E)-key(Q)))|| bool(abs(key(W)-key(S))) || bool(abs(key(A)-key(D))) || !(mouse_pos == texelFetch(iChannel1,ivec2(10),0).rg);\n      if (fragCoord.x <= 1.0)\n      {      \n        cam_pos.x -= ((key(S)-key(W))*sin(mouse_pos.y)+(key(A)-key(D))*cos(mouse_pos.y))*iTimeDelta*steps*60.0;\n        cam_pos.z += ((key(A)-key(D))*sin(mouse_pos.y)-(key(S)-key(W))*cos(mouse_pos.y))*iTimeDelta*steps*60.0;\n        cam_pos.y += key(E)-key(Q); //i was too lazy to do any thing fancy for y movement\n        col = cam_pos;\n      }\n      else if (fragCoord.x < 55.0)\n      {\n        col = vec3(mouse_pos,0);\n      }\n      else\n      {\n        col = vec3(!moved)*vec3(texelFetch(iChannel1,ivec2(fragCoord),0));\n        col.r += 1.0;\n      }\n     }\n\n    fragColor = vec4(col,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define bounces 8\n#define samples 1\n\n#define epsil 0.001\n#define maxnum 10000.0\n#define pi 3.14159265\n\n// for defining materials\n#define metal 1\n#define lambert 2\n\n//all intersection code except plane intersection is from https://iquilezles.org/articles/intersectors/\nstruct ray\n{\n  vec3 dir;\n  vec3 origin;\n  vec3 col;\n  vec3 emmisive;\n};\nstruct obj_info\n{\n  float t;\n  bool hit;\n  vec3 col;\n  vec3 emmisive;\n  vec3 norm;\n  int mat;\n  bool light;\n  float smoothness;\n};\nfloat hash(vec4 p4)\n{//from https://www.shadertoy.com/view/4djSRW\n   p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n   p4 += dot(p4, p4.wzxy+33.33);\n   return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\nvec3 RandVec(vec4 p4,float rad)\n{\n   float a,b;\n   a = hash(p4.xyzw);\n   b = hash(vec4(rad*p4.yxzw*a));\n   a = acos(2.0*a-1.0)-(pi/2.0);\n   b = 2.0*pi*b;\n   vec3 x = vec3(cos(a)*cos(b),cos(a)*sin(b),sin(a))*rad;\n   return x;\n}\nvec3 rotate(vec3 pos, vec3 dir)\n{\n   vec3 outpos = pos;\n   outpos = vec3(outpos.x,outpos.y*cos(dir.x)-outpos.z*sin(dir.x),outpos.y*sin(dir.x)+outpos.z*cos(dir.x));\n   outpos = vec3(outpos.x*cos(dir.z)-outpos.y*sin(dir.z),outpos.x*sin(dir.z)+outpos.y*cos(dir.z),outpos.z);\n   outpos = vec3(outpos.x*cos(dir.y)+outpos.z*sin(dir.y),outpos.y,-outpos.x*sin(dir.y)+outpos.z*cos(dir.y));\n   return outpos;\n}\nvoid ray_caps(ray ray,vec3 pa,vec3 pb,float r,vec3 col,vec3 emmisive,float alb,int mat,bool light,float smoothness,inout obj_info obj){\n  vec3 ro = ray.origin;\n  vec3 rd = ray.dir;\n  vec3 ba = pb-pa;\n  vec3 oa = ro-pa;\n  float baba = dot(ba,ba);\n  float bard = dot(ba,rd);\n  float baoa = dot(ba,oa);\n  float rdoa = dot(rd,oa);\n  float oaoa = dot(oa,oa);\n  float a = baba-bard*bard;\n  float b = baba*rdoa-baoa*bard;\n  float c = baba*oaoa - baoa*baoa - r*r*baba;\n  float t = b*b-a*c;\n  if (t > epsil){\n    t = (-(b+sqrt(t)))/a;\n    float y = baoa+t*bard;\n    if (y>epsil && y<baba){\n      if(t>epsil && t<obj.t){\n      a = dot(oa+t*rd,ba)/baba;\n      obj.t = t;\n      obj.hit = true;\n      obj.col = col*alb;\n      obj.emmisive = emmisive;\n      obj.norm = ((oa+t*rd)-ba*a)/r;\n      obj.mat = mat;\n      obj.light = light;\n      obj.smoothness = smoothness;\n      }\n    }\n    else{\n      oa = (y<=0.0)? oa: ro-pb;\n      b = dot(oa,rd);\n      c = dot(oa,oa)-r*r;\n      t = b*b-c;\n      if (t > epsil){\n        t = (-(b+sqrt(t)));\n        if (t > epsil && t<obj.t){\n           vec3 norm = (oa+t*rd)/r;\n           obj.t = t;\n           obj.hit = true;\n           obj.col = col*alb;\n           obj.emmisive = emmisive;\n           obj.norm = norm;\n           obj.mat = mat;\n           obj.light = light;\n           obj.smoothness = smoothness;\n        }\n      }\n    }\n  }\n}\nvoid ray_plane(ray ray,vec3 p,vec3 n,vec3 col,vec3 emmisive,float alb,int mat,bool light,float smoothness,inout obj_info obj)\n{\n  vec3 ro = ray.origin;\n  vec3 rd = ray.dir;\n  float t = dot(n,p-ro)/dot(n,rd);\n  if (t >= epsil && t < obj.t && t < maxnum){\n    obj.t = t;\n    obj.hit = true;\n    obj.col = col*alb;\n    obj.emmisive = emmisive;\n    obj.norm = n*sign(-dot(rd,n));\n    obj.mat = mat;\n    obj.light = light;\n    obj.smoothness = smoothness;\n  }\n}\nvoid ray_sphere(inout ray ray,vec3 ce,float r,vec3 col, vec3 emmisive,float alb,int mat,bool light,float smoothness,inout obj_info obj)\n{\n  vec3 ro = ray.origin;\n  vec3 rd = ray.dir;\n  ce = ro-ce;\n  float b = dot(ce,rd);\n  float c = dot(ce,ce)-r*r;\n  float discrim = b*b-c;\n  if (discrim > epsil)\n  {\n    float t = -(b+sqrt(discrim)); //tiny optimization of -b-sqrt(discrim)\n    if (t >= epsil && t < obj.t && t < maxnum)\n    {\n      obj.t = t;\n      obj.hit = true;\n      obj.norm = (t*rd+ce)/r;\n      obj.col = col*alb;\n      obj.emmisive = emmisive;\n      obj.mat = mat;\n      obj.light = light;\n      obj.smoothness = smoothness;\n    }\n  }\n}\n\nvoid check_int(inout ray ray,inout obj_info info)\n{\n  info.t = pow(10.0,100.0);\n  info.hit = false; \n  ray_plane(ray,vec3(0,-21,0),vec3(0,1,0),vec3(1),vec3(0),0.5,lambert,false,0.0,info);\n  ray_plane(ray,vec3(0,50,0),vec3(0,-1,0),vec3(1),vec3(5),0.5,lambert,true,0.0,info);\n  ray_plane(ray,vec3(-50,0,0),vec3(1,0,0),vec3(1,0.2,0.2),vec3(0),0.5,lambert,false,0.0,info);\n  ray_plane(ray,vec3(50,0,0),vec3(-1,0,0),vec3(0.2,1,0.2),vec3(0),0.5,lambert,false,0.0,info);\n  ray_plane(ray,vec3(0,0,65),vec3(0,0,-1),vec3(1),vec3(0),0.5,lambert,false,0.0,info);\n  ray_plane(ray,vec3(0,0,-135),vec3(0,0,1),vec3(1),vec3(0),0.5,lambert,false,0.0,info);\n  vec3 ro = ray.origin;\n  vec3 rd = ray.dir;\n  ray.origin = rotate(ro-vec3(0,0,0),vec3(-0.75,0.5,-0.392699));\n  ray.dir = rotate(rd,vec3(-0.75,0.5,-0.392699));\n  ray_caps(ray,vec3(0,45,0),vec3(0,-20,0),3.0,vec3(0.8509803921568627,0.6196078431372549,0.5098039215686274),vec3(0),0.8,lambert,false,0.0,info);\n  ray_sphere(ray,vec3(0,30,0),9.0,vec3(0.9882352941176471,0.6941176470588235,0.8901960784313725),vec3(0),0.8,lambert,false,0.25,info);\n  ray_sphere(ray,vec3(0,15,0),9.0,vec3(1,0.8509803921568627,0.5137254901960784),vec3(0),0.8,lambert,false,0.0,info);\n  ray_sphere(ray,vec3(0,0,0),9.0,vec3(0.6509803921568628,0.8274509803921568,0.5333333333333333),vec3(0),0.8,lambert,false,0.0,info);  \n  ray.origin = ro;\n  ray.dir = rd;\n}\n\nvoid bounce(inout ray ray,obj_info info){\n  ray.emmisive += ray.col*info.emmisive;\n  ray.col *= info.col;\n  ray.origin += info.t*ray.dir;  \n  if (info.mat == 1){\n    ray.dir = reflect(ray.dir,info.norm);\n    vec3 rand = RandVec(vec4(ray.origin/ray.dir,iTime),info.smoothness);\n    ray.dir = normalize(ray.dir+rand);\n  }\n  else if (info.mat == 2){\n    ray.dir = normalize(info.norm+RandVec(vec4(ray.origin/ray.dir,iFrame),1.0));\n    ray.col /= pi; \n  }\n}\nvec3 shoot_ray(in vec3 ro,in vec3 rd)\n{\n   ray ray;\n   ray.dir = rd;\n   ray.origin = ro;\n   ray.col = vec3(1.0);\n   ray.emmisive = vec3(0);\n   vec3 col = vec3(1);\n   obj_info info;\n   for (int i=0;i < bounces;i++)\n   {\n      check_int(ray,info);\n      if (info.hit && !info.light){\n        bounce(ray,info);\n      }\n      else{\n        col = ray.col*((info.light)? info.emmisive: vec3(0.25,0.25,0.30));\n        return col;\n      }\n      \n   }\n   col = ray.emmisive;\n   return col;\n\n\n}\nvec3 DOF(vec3 dir,float focalen,float ApertureSize,vec3 cam_pos,out vec3 ro)\n{\n   ro = cam_pos;\n   return dir;\n  // random vectors\n   vec3 rand1 = RandVec(vec4(1,dir.xy*299236273.27402,iFrame),ApertureSize);\n   vec3 rand2 = RandVec(vec4(1,dir.xy*2756734.18323,iFrame),ApertureSize);\n   \n   // actual dof\n   vec3 C = cam_pos+focalen*dir;\n   ro = cam_pos+rand1;\n   vec3 rd = C-(ro+rand2);\n   return rd;\n   \n}\nvoid get_pixl_col(out vec3 col,in vec2 coord,vec2 cam_dir,vec3 cam_pos)\n{\n   col = vec3(0);\n   for(int i = 0;i<samples;i++){\n     vec3 ro = cam_pos;\n     vec3 vec = RandVec(vec4(coord,iDate.w,cam_dir.y/max(cam_dir.x,0.01)),0.075);\n     coord += clamp(vec.xy*vec.z,-0.15,0.15);\n     vec3 rd;\n     rd = rotate(vec3(coord,1.215),vec3(cam_dir,0));\n     //rd = DOF(rd,100.0,1.5,cam_pos,ro);\n     col += shoot_ray(ro,normalize(rd));\n   }\n   col /= float(samples);\n}\nfloat framenum()\n{\n   return texelFetch(iChannel0,ivec2(100.0),0).r;\n}\nvoid move_cam(out vec2 mouse_pos,out vec3 cam_pos)\n{\n   mouse_pos = texelFetch(iChannel0,ivec2(10.0),0).xy;\n   cam_pos = texelFetch(iChannel0,ivec2(0.0),0).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord-iResolution.xy/2.0)/iResolution.yy;\n    vec3 col;\n    vec3 cam_pos;\n    vec2 mouse_pos;\n    move_cam(mouse_pos,cam_pos);\n    get_pixl_col(col,coord,mouse_pos,cam_pos);\n    col = mix(texelFetch(iChannel1,ivec2(fragCoord),0).rgb,col,1.0/framenum());\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}