{"ver":"0.1","info":{"id":"cslSRS","date":"1669370481","viewed":112,"name":"Fork of  Envy24's Illusion","username":"blurryroots","description":"Based on Envy24's adaptation of bigblueboo's 'no|rotation', with some neat optimisation from FabriceNeyret2.\nSlowed down, changed color scheme, turned generation 'inside out' - marvelling at the inteference patterns âœ¨","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","illusion","square","rotation","l2"],"hasliked":0,"parentid":"ddXXRS","parentname":"Rotation illusion __"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n// Original work by https://www.shadertoy.com/view/ddXXRS\n\n#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define SCENE_SCALE                 1.0\n#define TAU                         6.2831853071795862\n#define UNIT                      ( 2.5*SCENE_SCALE / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0.0, x) )\n\nconst float PHI = ((1. + sqrt(5.)) / 2.);\nconst float PHI0 = (PHI-1.);\nconst float IPHI0 = 1.0 - PHI0;\nconst vec3 CPHI = vec3 (PHI0, 0.0, PHI0);\nconst vec3 ICPHI = vec3 (1.0) - CPHI;\nconst vec3 PHIL = vec3 (0.0, IPHI0 / 2.0, 0.0);\n\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat squareSDF_L2(in vec2 NDC, in vec2 C, in float size, in float r, in float rad)\n{\n    const float half_pi = 1.5707963267948966;\n    //vec4 c = cos(rad+vec4(0, half_pi, -half_pi, 0)); // row order\n    vec4 c = cos(rad+vec4(0, -half_pi, half_pi, 0)); // column order\n    \n    vec2 P = abs(mat2(c.x, c.y, c.z, c.w) * (NDC-C)) - size*0.5; \n    \n    return \n        (P.x > 0. && P.y > 0. ?\n            length(P) :\n            max(P.x, P.y)) - r;       \n}\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n    vec3 color = PHIL; // vec3(PHI0);    \n    float count = 64.,\n          ds = PHI/(0.002 + 0.0001*sin(iTime/1000.)),\n          da = (ds)/count,\n          T  = iTime*PHI0;\n    \n    for (float i = 0.; i < count; i += 1.)\n    //float k = 0.; for (float i = k; i < k+1.; i+= 1.) // shows only one square\n    {\n        float rad = \n              // static angle\n              TAU * 0.125 + i * da,               \n              s = (1. + sin(rad+T)) * 0.5,\n              // dynamic square size\n              size = PHI0 * exp (s),                              \n              dist = squareSDF_L2(NDC, vec2(0), size, 0., rad);\n        \n        color = \n            i == 0. ?\n                mix(color, ICPHI, (2.0 * SMAA(abs(dist*0.1)))) :\n                mix(color, CPHI,  (3.0 * SMAA(abs(dist*PHI0))));\n            \n    }\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}