{"ver":"0.1","info":{"id":"7sffD8","date":"1644781783","viewed":53,"name":"project_pezet_benjamin","username":"rawsmec","description":"telecom nancy project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["project","tn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constantes\nconst int MAX_RAY_SETPS = 255;\nconst float DIST_MIN = 0.0;\nconst float DIST_MAX = 100.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\n\nstruct Object {\n    float dist;\n    vec3 color;\n};\n\nObject Cube(vec3 p, vec3 b, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Object(d, color);\n}\n\nObject Sol(vec3 p, vec3 color) {\n  float d = p.y + 1.;\n  return Object(d, color);\n}\n\nObject minDist(Object obj1, Object obj2) {\n  if (obj2.dist < obj1.dist){\n    return obj2;\n  }\n  else\n    return obj1;\n}\n\nObject Scene(vec3 p) {\n  vec3 solColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Object o = Sol(p, solColor);\n  o = minDist(o, Cube(p, vec3(1), vec3(0.93, 0.79, 0.)));\n  return o;\n}\n\n// algorithme 'Ray Marching' pour l'éclairage\nObject rayMarch(vec3 origin, vec3 direction, float start, float end) {\n  float depth = start;\n  Object o;\n\n  for (int i = 0; i < MAX_RAY_SETPS; i++) {\n    vec3 p = origin + depth * direction;\n    o = Scene(p);\n    depth += o.dist;\n    if (o.dist < EPSILON || depth > end)\n      break;\n  }\n  \n  o.dist = depth;\n  \n  return o;\n}\n\nvec3 gradient(in vec3 p) {\n    return normalize(vec3(\n      Scene(vec3(p.x + EPSILON, p.y, p.z)).dist - Scene(vec3(p.x - EPSILON, p.y, p.z)).dist,\n      Scene(vec3(p.x, p.y + EPSILON, p.z)).dist - Scene(vec3(p.x, p.y - EPSILON, p.z)).dist,\n      Scene(vec3(p.x, p.y, p.z  + EPSILON)).dist - Scene(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nmat3 camera(vec3 pos, vec3 lookAt) {\n  vec3 View = normalize(lookAt - pos);\n  vec3 Horiz = normalize(cross(vec3(0, 1, 0), View));\n  vec3 Up = normalize(cross(View, Horiz));\n  \n  return mat3(-Horiz, Up, -View);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 cielColor = vec3(0., 0.6, 0.8);\n  vec3 color = vec3(0);\n\n  // camera config\n  vec3 lookAt = vec3(0, 0., 0.);\n  vec3 origin = vec3(0., 4., 0.);\n  \n  float angleCamera = 10.;\n  // coordonnées polaires\n  origin.x = angleCamera * cos(iTime) + lookAt.x;\n  origin.z = angleCamera * sin(.5*iTime) + lookAt.z;\n  \n  vec3 direction = camera(origin, lookAt) * normalize(vec3(uv, -1));\n\n  Object o = rayMarch(origin, direction, DIST_MIN, DIST_MAX);\n\n  // si le rayon ne rencontre aucun objet\n  if (o.dist > DIST_MAX) {\n    color = cielColor;\n  } \n  else {\n    vec3 p = origin + direction * o.dist; // point d'intersection entre le rayon et l'objet\n    vec3 normal = gradient(p);\n    vec3 lightPos = vec3(5, 2, 7);\n    vec3 lightDir = normalize(lightPos - p);\n    \n    // ombre portée\n    float dif = clamp(dot(normal, lightDir), 0.3, 1.);\n    vec3 newOrigin = p + normal * EPSILON * 2.;\n    Object shadowRayLength = rayMarch(newOrigin, lightDir, 3., DIST_MAX);\n    if (shadowRayLength.dist < length(lightPos - newOrigin)) \n      dif *= 0.;\n\n    color = dif * o.color ;\n  }\n\n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}