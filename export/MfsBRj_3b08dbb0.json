{"ver":"0.1","info":{"id":"MfsBRj","date":"1724085079","viewed":45,"name":"celes(tial) night","username":"camilaceles","description":"Dalux on a celes(tial) night","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["dalux"],"hasliked":0,"parentid":"fstyD4","parentname":"Coastal Landscape"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forked from bitless @ https://www.shadertoy.com/view/fstyD4\n\n#define p(t, a, b, c, d) ( a + 0.9*b*cos( 5.5*(c*1.2*t+d) ) ) //IQ's palette function (https://www.iquilezles.org/www/articles/palettes/palettes.htm)\n#define sp(t) p(t,vec3(.26,.46,.1),vec3(1.,.4,1),vec3(.6,.4,.7),vec3(0,.12,.54)) //sky palette\n#define hue(v) ( .6 + .76 * cos(6.3*(v) + vec4(0,23,21,0) ) ) //hue\n\n\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n////////////////////////\n\nvec2 rotate2D (vec2 st, float a){\n    return  mat2(cos(a),-sin(a),sin(a),cos(a))*st;\n}\n\nfloat st(float a, float b, float s) //AA bar\n{\n    return smoothstep (a-s, a+s, b);\n}\n\nfloat noise( in vec2 p ) //gradient noise\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( dot( hash22( i+vec2(0,0) ), f-vec2(0,0) ), \n                     dot( hash22( i+vec2(1,0) ), f-vec2(1,0) ), u.x),\n                mix( dot( hash22( i+vec2(0,1) ), f-vec2(0,1) ), \n                     dot( hash22( i+vec2(1,1) ), f-vec2(1,1) ), u.x), u.y);\n}\n\nvoid mainImage(out vec4 O, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,uv = (g+g-r)/r.y\n        ,sun_pos = vec2(-r.x/r.y*.42,-.43) //sun position \n        ,dalux_pos = vec2(r.x/r.y*.5,.45) //tree position \n        ,sh, u, id, lc, t;\n\n    vec3 f, c;\n    float xd, yd, h, a, l;\n    vec4 C;\n    \n    float sm = 3./r.y; //smoothness factor for AA\n\n    sh = rotate2D(sun_pos, noise(uv+iTime*.25)*.3); //big noise on the sky\n     \n    u = uv + sh;\n\n    yd = 50.; //number of rings \n\n    id =  vec2((length(u)+.01)*yd,0); //segment id: x - ring number, y - segment number in the ring  \n    xd = floor(id.x)*.09; //number of ring segments\n    h = (hash12(floor(id.xx))*.5+.25)*(iTime+10.)*.25; //ring shift\n    t = rotate2D (u,h); //rotate the ring to the desired angle\n\n    id.y = atan(t.y,t.x)*xd;\n    lc = fract(id); //segment local coordinates\n    id -= lc;\n\n    // determining the coordinates of the center of the segment in uv space\n    t = vec2(cos((id.y+.5)/xd)*(id.x+.5)/yd,sin((id.y+.5)/xd)*(id.x+.5)/yd); \n    t = rotate2D(t,-h) - sh;\n\n    h = 0.0;\n\n\n    lc += (noise(lc*vec2(1,4)+id))*vec2(.7,.2); //add fine noise\n\n    f = mix (sp(sin(length(u)-.1))*.35, //sky background\n            mix(sp(sin(length(u)-.1)+(hash12(id)-.5)*.15),vec3(1),h), //mix sky color and clouds\n            st(abs(lc.x-.5),.4,sm*yd)*st(abs(lc.y-.5),.48,sm*xd));\n    \n    O = vec4(f,1);\n    \n    float T = sin(iTime*.5); //dalux swing cycle\n    if (abs(uv.x+dalux_pos.x-.1-T*.1) < .6) // dalux box\n    {\n        xd = 20., yd = 5.;\n        \n        u = uv + dalux_pos + vec2 (-(T +.25)*.1,-.7); //dalux position\n\n        t = u * vec2(xd,1.);\n        h = hash12(floor(t.xx)); //number of segments for the row\n\n        yd = 7.+ h*1.;\n        t.y *= yd;\n\n        sh = t;\n        lc = fract(t);\n        h = hash12(t-lc); //segment color shade\n\n\n        t = (t-lc)/vec2(xd,yd)+vec2(0,.6);\n\n        float m = (step (length(t) ,0.) //the shape of the dalux - the top \n            + step (t.y,0.)*step (-0.8,t.y)) //the bottom\n            *step (abs(t.x),.5) //dalux size horizontally\n            *st(abs(lc.x-.5),.45,sm*xd*.5); \n\n        lc += noise((sh)*vec2(1.,3.))*vec2(.3,.3); //add fine noise\n\n        f = vec3(0.55,0.78,0.25); // dalux color (black)\n            C = mix(C,\n                    vec4(mix(f*.15,f*.6*(.7), //mix outline and foreground color\n                        st(abs(lc.y-.5),.47,sm*yd)*st(abs(lc.x-.5),.2,sm*xd)),m)\n                    ,m);\n\n        O = mix (O,C,C.a*(1.-a));\n    }\n    \n    if (abs(uv.x+dalux_pos.x-.1-T*.1) < .9) // roof 1\n    {\n        xd = 20.,\n        \n        u = uv + dalux_pos + vec2 (-(T +.25)*.1,-.7); //dalux position\n\n        t = u * vec2(xd,4.);\n        h = hash12(floor(t.xx)); //number of segments for the row\n\n        yd = 5.+ h*2.;\n        t.y *= yd;\n        \n        t.y -= 9. + (t.x);\n        t.x += 11.;\n\n        sh = t;\n        lc = fract(t);\n        h = hash12(t-lc); //segment color shade\n\n        t = (t-lc)/vec2(xd,yd)+vec2(0,.6);\n\n        float m = (step (length(t) ,0.) //the shape of the dalux - the top \n            + step (t.y,0.)*step (-0.8,t.y)) //the bottom\n            *step (abs(t.x),.5) //dalux size horizontally\n            *st(abs(lc.x-.5),.45,sm*xd*.5); \n\n        lc += noise((sh)*vec2(1.,3.))*vec2(.3,.3); //add fine noise\n\n        f = vec3(0.3,0.3,0.3); // dalux color (black)\n            C = mix(C,\n                    vec4(mix(f*.15,f*.6*(.7), //mix outline and foreground color\n                        st(abs(lc.y-.5),.47,sm*yd)*st(abs(lc.x-.5),.2,sm*xd)),m)\n                    ,m);\n\n        O = mix (O,C,C.a*(1.-a));\n    }\n\n\n    if (abs(uv.x+dalux_pos.x-.1-T*.1) < .9) // roof 1\n    {\n        xd = 20.,\n        \n        u = uv + dalux_pos + vec2 (-(T +.25)*.1,-.7); //dalux position\n\n        t = u * vec2(xd,4.);\n        h = hash12(floor(t.xx)); //number of segments for the row\n\n        yd = 5.+ h*2.;\n        t.y *= yd;\n        \n        \n        t.y -= 9. - (t.x);\n        t.x -= 10.;\n\n        sh = t;\n        lc = fract(t);\n        h = hash12(t-lc); //segment color shade\n\n        t = (t-lc)/vec2(xd,yd)+vec2(0,.6);\n\n        float m = (step (length(t) ,0.) //the shape of the dalux - the top \n            + step (t.y,0.)*step (-0.8,t.y)) //the bottom\n            *step (abs(t.x),.5) //dalux size horizontally\n            *st(abs(lc.x-.5),.45,sm*xd*.5); \n\n        lc += noise((sh)*vec2(1.,3.))*vec2(.3,.3); //add fine noise\n\n        f = vec3(0.3,0.3,0.3); // dalux color (black)\n            C = mix(C,\n                    vec4(mix(f*.15,f*.6*(.7), //mix outline and foreground color\n                        st(abs(lc.y-.5),.47,sm*yd)*st(abs(lc.x-.5),.2,sm*xd)),m)\n                    ,m);\n\n        O = mix (O,C,C.a*(1.-a));\n    }\n\n\n}","name":"Image","description":"","type":"image"}]}