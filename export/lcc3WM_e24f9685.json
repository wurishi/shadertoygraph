{"ver":"0.1","info":{"id":"lcc3WM","date":"1711746865","viewed":42,"name":"Progressive City","username":"w84death","description":"Simple infinite city. Unfinished.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float u_fft=1.0;\n\nconst float WORLD_MAX = 192.0;\nconst float WORLD_RES = 0.001;\n\nconst float MAT_GROUND = 1.0;\nconst float MAT_DARKBLUE = 2.0;\nconst float MAT_CITY = 3.0;\nconst float MAT_ASPHALT = 4.0;\nconst float MAT_CONCRETE = 5.0;\nconst float MAT_CHESS = 6.0;\nconst float MAT_METAL = 7.0;\nconst float MAT_CARS = 8.0;\nconst float MAT_CITY2 = 9.0;\n\nconst float T_SUNRISE=6.0;\nconst float T_INTRO=8.0;\nconst float T_STOP1=16.0;\nconst float T_STOP2=32.0;\nconst float T_END=50.0;\n\nint SCENE = 0;\nconst int SCENE_INTRO = 1;\nconst int SCENE_HELI = 2;\nconst int SCENE_STREETLOOK = 3;\nconst int SCENE_END = 4;\n\nconst float FOG_DIST = 0.05;\nconst vec3 FOG_COLOR = vec3(.8,.8,.8);\nconst float CAM_LENS_ABERRATION = 0.002;\nconst float CAM_LENS_DISTOR_K1 = 0.0015;\nconst float CAM_LENS_DISTOR_K2 = 0.0005;\nconst float CAM_LENS_24mm = 0.8;\nconst float CAM_LENS_35mm = 1.5;\nconst float CAM_LENS_50mm = 2.0;\nconst float CAM_LENS_80mm = 4.0;\n\n/*\n * SDF BRUSHES\n * https://iquilezles.org/articles/distfunctions/\n *\n * */\nfloat sdSphere( vec3 p, float s){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n/*\n * SDF OPs\n *\n * */\nfloat opUnion( float d1, float d2) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nvec3 opCheapBend( in vec3 p, float bend )\n{\n    float k = sin(iTime)*bend; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat map(float value, float inputMin, float inputMax, float outputMin, float outputMax) {\n    return outputMin + ((clamp(value, inputMin, inputMax) - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin);\n}\n\n/*\n * FAKE RANDOM GENERATOR\n *\n * */\nfloat rnd(vec2 pos){\n    return fract(sin(dot(pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n/*\n * COMBINE SDF WORLD\n *\n * */\nvec2 sdfWorld(in vec3 pos){\n    float m = MAT_GROUND;\n    float ground = pos.y+0.1;\n\n\n    vec3 qb = vec3(mod(abs(pos.x),20.0)-10.0,\n                   pos.y,\n                   mod(abs(pos.z),10.0)-5.0);\n\n    float base = sdRoundBox(qb+vec3(.0,.5,.0),vec3(5.5,1.0,3.),0.1);\n\n    vec2 bid = vec2(floor(abs(pos.x)/10.0)-5.0,\n                   floor(abs(pos.z)/5.0)-2.5);\n\n    vec3 qbBend = opCheapBend(qb,rnd(bid)*0.04);\n    float bheight = 2.0+10.0*abs(sin(iTime+rnd(bid)*.25));\n\n    vec3 qb1 = qbBend-vec3(3.1,0.,1.6);\n    vec3 qb2 = qbBend-vec3(-3.1,0.,1.6);\n    vec3 qb3 = qbBend-vec3(3.1,0.,-1.6);\n    vec3 qb4 = qbBend-vec3(-3.1,0.,-1.6);\n\n    float b1=sdRoundBox(qb1,vec3(2.0,bheight,1.),0.2);\n    float b2=sdRoundBox(qb2,vec3(2.0,bheight,1.),0.2);\n    float b3=sdRoundBox(qb3,vec3(2.0,bheight,1.),0.2);\n    float b4=sdRoundBox(qb4,vec3(2.0,bheight,1.),0.2);\n\n    float roofrnd = .1+rnd(bid)*.8;\n\n    float r1 = sdRoundBox(qb1-vec3(-0.5+rnd(bid+vec2(.1)),bheight,-0.5+roofrnd),vec3(roofrnd,roofrnd*1.5,roofrnd),0.1);\n    roofrnd = .1+rnd(bid+vec2(1.))*.8;\n    float r2 = sdRoundBox(qb2-vec3(-0.5+rnd(bid+vec2(.1)),bheight,-0.5+roofrnd),vec3(roofrnd,roofrnd*1.5,roofrnd),0.1);\n    roofrnd = .1+rnd(bid+vec2(2.))*.8;\n    float r3 = sdRoundBox(qb3-vec3(-0.5+rnd(bid+vec2(.1)),bheight,-0.5+roofrnd),vec3(roofrnd,roofrnd*1.5,roofrnd),0.1);\n    roofrnd = .1+rnd(bid+vec2(3.))*.8;\n    float r4 = sdRoundBox(qb4-vec3(-0.5+rnd(bid+vec2(.1)),bheight,-0.5+roofrnd),vec3(roofrnd,roofrnd*1.5,roofrnd),0.1);\n\n    float roofs_ = opUnion(r1,opUnion(r2,opUnion(r3,r4)));\n    float block_ = opUnion(b1,opUnion(b2,opUnion(b3,b4)));\n\n    block_ = opUnion(block_,base);\n    block_ = opSmoothUnion(block_,roofs_,.25);\n\n    if (block_<WORLD_RES) m=MAT_CITY;\n    if (base<WORLD_RES) m=MAT_CITY2;\n    if (roofs_<WORLD_RES) m=MAT_CONCRETE;\n\n    vec3 qlamps = vec3(mod(abs(pos.x),5.0)-1.6,\n                   pos.y,\n                   mod(abs(pos.z),5.0)-2.5);\n\n    float lampBase = sdBox(qlamps,vec3(0.05,.1,0.05));\n    float lampLeg = sdRoundBox(qlamps,vec3(0.01,2.0,0.01),0.04);\n    float lampLed = sdRoundBox(qlamps-vec3(0.2,2.0,0.0),vec3(0.3,0.05,0.02),0.04);\n    float lamps_ = opSmoothUnion(opSmoothUnion(lampBase,lampLeg,0.1),lampLed,0.04);\n\n    float pavementBase = sdBox(qb+vec3(.0,0.15,.0), vec3(8.5,0.1,4.5));\n    float pavementCut = sdBox(qb, vec3(7.5,0.2,3.5));\n    float pavement_ = opSubtraction(pavementCut,pavementBase);\n\n    if (lamps_<WORLD_RES) m=MAT_CONCRETE;\n    if (pavement_<WORLD_RES) m=MAT_CONCRETE;\n\n    vec3 qcarsL = vec3(mod(-pos.x,20.0)-0.8,\n                   pos.y,\n                   mod(abs(pos.z+iTime*5.0),2.0)-1.);\n    vec3 qcarsR = vec3(mod(pos.x,20.0)-0.8,\n                   pos.y,\n                   mod(abs(pos.z-iTime*5.0),2.0)-1.);\n    vec2 carLid = vec2(floor(abs(pos.x)/20.0)-0.8,\n                   floor(abs(pos.z+iTime*5.0)/2.0)-1.);\n    vec2 carRid = vec2(floor(abs(pos.x)/20.0)-0.8,\n                   floor(abs(pos.z-iTime*5.0)/2.0)-1.);\n\n    float rndL = rnd(carLid)*.1;\n    float rndR = rnd(carRid)*.1;\n    float carsL = opSubtraction(\n        sdBox(qcarsL-vec3(.0,-.25,0.), vec3(1,.2,1.)),\n        sdRoundBox(qcarsL-vec3(.0,-.1+rndL*4.,0.), vec3(.12,.1+rndL*4.,.3+rndL),0.2)\n    );\n    float carsR = opSubtraction(\n        sdBox(qcarsR-vec3(.0,-.25,0.), vec3(1.,.2,1.)),\n        sdRoundBox(qcarsR-vec3(.0,-.1+rndR*4.,0.), vec3(.12,.1+rndR*4.,.3+rndR),0.2)\n    );\n\n    float carSpd = iTime*5.0;\n    vec3 qcars2L = vec3(mod(abs(pos.x+carSpd),2.0)-1.,\n                   pos.y-5.2,\n                   mod(-pos.z,10.0)-0.6);\n    vec3 qcars2R = vec3(mod(abs(pos.x-carSpd),2.0)-1.,\n                   pos.y-5.2,\n                   mod(pos.z,10.0)-0.6);\n\n    vec2 car2Lid = vec2(floor(abs(pos.x+carSpd)/2.0)-1.,\n                   floor(abs(pos.z)/10.0)-.8);\n    vec2 car2Rid = vec2(floor(abs(pos.x-carSpd)/2.0)-1.,\n                   floor(abs(pos.z)/10.0)-.8);\n\n    float rnd2L = rnd(car2Lid)*.1;\n    float rnd2R = rnd(car2Rid)*.1;\n\n    float cars2L = opSubtraction(\n        sdBox(qcars2L-vec3(.0,-.2,0.), vec3(1.,.4,1.)),\n        sdRoundBox(qcars2L-vec3(.0,-.1+rnd2L*4.,0.), vec3(.1+rnd2L*4.,.3+rnd2L,.12),0.2)\n    );\n    float cars2R = opSubtraction(\n        sdBox(qcars2R-vec3(.0,-.2,0.), vec3(1.,.4,1.)),\n        sdRoundBox(qcars2R-vec3(.0,-.1+rnd2R*4.,0.), vec3(.1+rnd2R*4.,.3+rnd2R,.12),0.2)\n    );\n\n    float cars_ = opUnion(\n        opUnion(carsL,carsR),\n        opUnion(cars2L,cars2R)\n    );\n\n    if(cars_<WORLD_RES) m=MAT_CARS;\n\n    vec3 qhiRoad = vec3(mod(pos.x,5.0)-2.5,\n                   pos.y-5.0,\n                   mod(abs(pos.z-5.),10.0)-5.);\n\n    float hiRoad = opUnion(\n        opUnion(\n            sdBox(qhiRoad-vec3(.0,.0,.0),vec3(2.5,.1,1.4)),\n            sdBox(qhiRoad-vec3(.0,-.15,.0),vec3(2.5,.1,1.))),\n        opSubtraction(\n            sdRoundBox(qhiRoad-vec3(.0,.3,.0),vec3(2.5,.6,1.),.3),\n            sdRoundBox(qhiRoad-vec3(.0,.3,.0),vec3(2.5,.5,1.6),.1)\n        )\n    );\n    float hiBase = opSubtraction(\n        sdRoundBox(qhiRoad-vec3(.0,-3.2,.0),vec3(.2,2.6,.8),.2),\n        sdRoundBox(qhiRoad-vec3(.0,-3.,.0),vec3(.1,2.8,1.2),.1)\n    );\n    float hiRoads_ = opUnion(hiRoad, hiBase);\n\n    if(hiBase<WORLD_RES) m=MAT_CONCRETE;\n    if(hiRoad<WORLD_RES) m=MAT_ASPHALT;\n\n    float city_ = opUnion(opUnion(opUnion(block_,pavement_), lamps_),cars_);\n    city_ = opUnion(city_, hiRoads_);\n\n    pos -= vec3(.0,map(iTime,.0,T_INTRO*.8,15.,1.),-15.0);\n\n    float p1 = sdBox(pos-vec3(-0.7,0.95,.0),vec3(0.05,0.95,0.05));\n    float p2 = sdBox(pos-vec3(-0.5,1.85,.0),vec3(0.15,0.05,0.05));\n    float p3 = sdBox(pos-vec3(-0.5,0.95,.0),vec3(0.15,0.05,0.05));\n    float p4 = sdBox(pos-vec3(-0.3,1.40,.0),vec3(0.05,0.50,0.05));\n    float p_ = opUnion(p1,opUnion(p4,opUnion(p2,p3)));\n\n    float i1 = sdBox(pos-vec3(.0,0.95,.0),vec3(0.05,0.95,0.05));\n    float i2 = sdBox(pos-vec3(-.1,1.75,.0),vec3(0.05,0.05,0.05));\n    float i_ = opUnion(i1,i2);\n\n    float x1 = sdBox(pos-vec3(0.3,1.55,.0),vec3(0.05,0.35,0.05));\n    float x2 = sdBox(pos-vec3(0.7,1.55,.0),vec3(0.05,0.35,0.05));\n    float x3 = sdBox(pos-vec3(0.3,0.45,.0),vec3(0.05,0.45,0.05));\n    float x4 = sdBox(pos-vec3(0.7,0.45,.0),vec3(0.05,0.45,0.05));\n    float x5 = sdBox(pos-vec3(0.4,1.15,.0),vec3(0.05,0.05,0.05));\n    float x6 = sdBox(pos-vec3(0.6,1.15,.0),vec3(0.05,0.05,0.05));\n    float x7 = sdBox(pos-vec3(0.4,0.95,.0),vec3(0.05,0.05,0.05));\n    float x8 = sdBox(pos-vec3(0.6,0.95,.0),vec3(0.05,0.05,0.05));\n    float x9 = sdBox(pos-vec3(0.5,1.05,.0),vec3(0.05,0.05,0.05));\n    float x_ = opUnion(x1,opUnion(x2,opUnion(x3,opUnion(x4,opUnion(x5,opUnion(x6,opUnion(x7,opUnion(x8,x9))))))));\n\n    float p1x_=opUnion(p_,opUnion(i_,x_));\n    if (p1x_<WORLD_RES) m=MAT_DARKBLUE;\n\n    float world=opUnion(ground,opUnion(city_,p1x_));\n    return vec2(world,m);\n}\n\n/*\n * NORMALS\n *\n * */\nvec3 calcNormal(in vec3 pos){\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(\n        vec3(sdfWorld(pos+e.xyy).x-sdfWorld(pos-e.xyy).x,\n             sdfWorld(pos+e.yxy).x-sdfWorld(pos-e.yxy).x,\n             sdfWorld(pos+e.yyx).x-sdfWorld(pos-e.yyx).x));\n}\n\n/*\n * RAYCASTING\n *\n * */\nvec2 castRay(in vec3 ro, vec3 rd){\n    vec2 res=vec2(-1.0,-1.0);\n    float t = 0.5;\n    for (int i=0; i<2600; i++){\n        vec2 scene = sdfWorld(ro+rd*t);\n        if (abs(scene.x)<WORLD_RES){\n            res=vec2(t,scene.y);\n            break;\n        }\n        t+=scene.x;\n        if(t>WORLD_MAX) break;\n    }\n    return res;\n}\n\n/*\n * SHOFT SHADOW\n *\n * */\nfloat getSoftShadow( in vec3 ro, in vec3 rd, float w)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256 && t<WORLD_MAX; i++ )\n    {\n        float h = sdfWorld(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>WORLD_MAX ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n/*\n * AO\n *\n * */\nfloat getAO(in vec3 ro, vec3 normal){\n    float occ=0.0;\n    float weight=1.0;\n    for (int i=0; i<8; i++){\n        float len = 0.01+0.02*float(i*i);\n        float dist = sdfWorld(ro+normal*len).x;\n        occ=(len-dist)*weight;\n        weight*=.85;\n    }\n    return 1.0-clamp(.6*occ,0.0,1.0);\n}\n\n/*\n * MATERIALS GENERATION\n *\n * */\nvec3 getMaterial(vec3 p, vec3 nor, float id){\n    vec3 m=vec3(.0,.0,.0);\n\n    if(id==MAT_GROUND){\n        m=vec3(-2.,-2.,-1.5);\n        m+=vec3(.0,1.,.0)*vec3(mod(floor(.5+p.x*.25)*floor(.5+p.z*.5),5.0));\n\n    }else\n    if(id==MAT_DARKBLUE){\n        m=vec3(0.1,.2,5.0);\n    }else\n    if(id==MAT_CITY){\n        float crnd = rnd(vec2(floor(abs(p.x)/10.0),\n                floor(abs(p.z)/15.0)));\n        float win=\n        mod(floor(p.x*4.0)*floor(p.y*4.0),2.0)*nor.z+\n        0.1*nor.y+\n        mod(floor(p.y*4.0)*floor(p.z*4.0),2.0)*nor.x;\n        m=vec3(map(u_fft,0.65,1.0,0.0,4.0)*win,win+crnd,win+crnd);\n    }else\n    if(id==MAT_CITY2){\n        float crnd = rnd(vec2(floor(abs(p.x)/10.0),\n                floor(abs(p.z)/15.0)));\n        m=vec3(crnd*3.);\n    }else\n    if(id==MAT_METAL){\n        m=vec3(1.,1.,1.)*nor*.2;\n    }else\n    if(id==MAT_ASPHALT){\n        m=vec3(-2.,-2.,-1.5);\n    }else\n    if(id==MAT_CARS){\n        m=vec3(-1.,-1.,1.)+nor*.1;\n    }\n    return m;\n}\n\nvec3 getColor(vec3 pos, vec3 nor,vec3 rd, float material_id){\n    // colors reducer for better color correction\n    vec3 mate = vec3(0.2);\n\n    // environment: sun, shadows, fake bounce light\n    vec3 sun_pos = normalize(vec3(\n        map(iTime,T_SUNRISE*.25,T_SUNRISE,-6.0,1.0),\n        map(iTime,T_SUNRISE*.25,T_SUNRISE,-3.0,3.0),\n        3.0));\n    float sun_shadow = getSoftShadow(pos+nor*0.001, sun_pos,.1);\n    float ao = getAO(pos,nor);\n\n    float sun_dif = clamp(dot(nor,sun_pos),0.0,1.0);\n    float sky_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n    float bou_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n    float sunrise = map(iTime,T_SUNRISE*.25,T_SUNRISE,.01,1.0);\n\n\n    vec3 col = mate*getMaterial(pos,nor,material_id);\n    col *= ao;\n    col += mate*vec3(5.0,3.0,2.0)*sun_dif*sun_shadow;\n    col += mate*vec3(0.5,0.8,0.9)*sky_dif;\n    col *= ao;\n    col *= sunrise;\n\n    return col;\n}\n\n/*\n * THE RENDERER\n *\n * */\nvec3 render(in vec2 p){\n\n    // DIRECTOR OF PHOTOGRAPHY\n    float cam_fov = 4.;\n    float cam_z = -iTime;\n    float cam_x = 0.0;\n    float cam_y = 0.5;\n    float aim_x = cam_x;\n    float aim_y = 0.0;\n    float aim_z = -1.0;\n\n    if(iTime<T_INTRO){\n        SCENE=SCENE_INTRO;\n    }else\n    if(iTime<T_STOP1){\n        SCENE=SCENE_STREETLOOK;\n    }else\n    if(iTime<T_STOP2){\n        SCENE=SCENE_HELI;\n    }else\n    if(iTime<T_END){\n        SCENE=SCENE_END;\n    }else{\n        SCENE=SCENE_INTRO;\n    }\n\n    if(SCENE==SCENE_INTRO){\n        cam_fov = CAM_LENS_50mm;\n        cam_y = map(iTime,0.0,T_INTRO*.8,25.0,2.0);\n        aim_y = map(iTime,0.0,T_INTRO*.8,-2.0,0.0);\n    }else\n    if(SCENE==SCENE_HELI){\n        cam_fov = CAM_LENS_24mm;\n        cam_x = 2.;\n        cam_y = 15.+sin(iTime*.2)*.1;\n        aim_y = -2.;\n        aim_z = -.5-abs(sin(iTime*.2))*.5;\n    }else\n    if(SCENE==SCENE_STREETLOOK){\n        cam_fov = CAM_LENS_35mm;\n        cam_x = -3.5;\n        cam_y = 0.2;\n        cam_z = 20.;\n        aim_x = 3.;\n        aim_y = sin(iTime*.1)*2.;\n        aim_z = sin(1.0+iTime*.1)*2.;\n    }else\n    if(SCENE==SCENE_END){\n        cam_fov = CAM_LENS_35mm;\n        cam_y = .3;\n    }\n\n    vec3 ro = vec3(cam_x,cam_y,cam_z);\n    vec3 ta = vec3(cam_x+aim_x,cam_y+aim_y,cam_z+aim_z);\n\n    // calculate ray direction\n    vec3 ww = normalize (ta-ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize (cross(uu,ww));\n    vec3 rd = normalize(p.x*uu+p.y*vv+cam_fov*ww);\n\n    // sky simulation\n    vec3 col = vec3(map(iTime,T_SUNRISE*.5,T_SUNRISE,1.0,.0),0.75,1.0) - 0.5*rd.y;\n    col =  mix(col, vec3(0.7,0.8,0.8), exp(-10.0*rd.y));\n    col *= map(iTime,T_SUNRISE*.25,T_SUNRISE,.0,1.0);\n\n    // hit ray trace\n    vec2 ray = castRay(ro,rd);\n    float ray_hit=ray.x;\n    float material_id=ray.y;\n\n    if (ray_hit>0.0){\n        vec3 pos = ro+rd*ray_hit;\n        vec3 nor = calcNormal(pos);\n        col = getColor(pos,nor,rd,material_id);\n\n        float fogAmount = 1.0 - exp( -ray_hit*FOG_DIST );\n        vec3  fogColor  = FOG_COLOR* map(iTime,T_SUNRISE*.25,T_SUNRISE,.01,1.0);\n        col = mix( col, fogColor, fogAmount );\n\n    }\n    return col;\n}\n\nfloat barrelDistortion(vec2 pos) {\n    float radius = length(pos);\n\n    return 1.0 + CAM_LENS_DISTOR_K1 * pow(radius, 2.0) + CAM_LENS_DISTOR_K2 * pow(radius, 4.0);\n}\n\nvec2 chromaticAberration(vec2 coord, float radius, vec2 direction, float strength) {\n    return coord + strength * radius * direction;\n}\n\n\n/*\n * MAIN\n *\n * */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 TexCoords = fragCoord/iResolution.xy-vec2(0.5);\n    vec3 col = render(barrelDistortion(TexCoords)*TexCoords);\n\n    float filmNoise = rnd(TexCoords+vec2(iTime));\n\n    col -= col*vec3(filmNoise)*.2;\n\n     // Vignette.\n\tcol *= 1.0 - 0.2 * dot(TexCoords, TexCoords);\n\n\n    // color/exposure correction;\n    col = pow (col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}\n\n/*\n * END OF LISTING\n *\n * */\n","name":"Image","description":"","type":"image"}]}