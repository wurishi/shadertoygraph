{"ver":"0.1","info":{"id":"lcyXRd","date":"1715613032","viewed":121,"name":"metaball blending stylized","username":"int_45h","description":"testing blending of metaballs with multiple colors, with a dither effect","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DO_DITHER\n#define DITHER_STEPS 2.0\nint dither_matrix[64] = int[](\n    0,32,8,40,2,34,10,42,\n    48,16,56,24,50,18,58,26,\n    12,44,4,36,14,46,6,38,\n    60,28,52,20,62,30,54,22,\n    3,35,11,43,1,33,9,41,\n    51,19,59,27,49,17,57,25,\n    15,47,7,39,13,45,5,37,\n    63,31,55,23,61,29,53,21\n);\n\nvec4 posterize(vec4 col, float steps)\n{\n    return floor(col*steps)/steps;\n}\n\nvec4 nearest_palette(vec4 x)\n{\n    return posterize(x, DITHER_STEPS);\n}\n\nvec4 dither(vec4 col, vec2 uv)\n{\n    int x_m = int(uv.x) % 8;\n    int y_m = int(uv.y) % 8;\n    float M = float(dither_matrix[y_m*8+x_m])/64.;\n    \n    return nearest_palette(col+(M-.5f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord/2.)*2. / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    #ifdef DO_DITHER\n    fragColor = dither(fragColor, fragCoord*.5);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rot_x(float t)\n{\n    return mat3(\n        1,0,0,\n        0,cos(t),-sin(t),\n        0,sin(t),cos(t)\n    );\n}\n\nmat3 rot_y(float t)\n{\n    return mat3(\n        cos(t),0,-sin(t),\n        0,1,0,\n        sin(t),0,cos(t)\n    );\n}\n\nmat3 rot_z(float t)\n{\n    return mat3(\n        cos(t),-sin(t),0,\n        sin(t),cos(t),0,\n        0,0,1\n    );\n}\n\nmat3 look_at(vec3 d)\n{\n    vec3 front = normalize(d);\n    vec3 right = cross(vec3(0.,1.,0.), front);\n    vec3 up = cross(front, right);\n    \n    return mat3(right, up, front);\n}\n\nmat3 look_at(vec3 d, vec3 o)\n{\n    vec3 front = normalize(d-o);\n    vec3 right = cross(vec3(0.,1.,0.), front);\n    vec3 up = cross(front, right);\n    \n    return mat3(right, up, front);\n}\n\nfloat l_ntsc(vec3 c)\n{\n    return dot(c,vec3(.299,.587,.114));\n}\n\nvec4 brightness(vec4 col, float b)\n{\n    return (col + vec4(b-1.0));\n}\n\nvec4 contrast(vec4 col, float c)\n{\n    return (col*c + ((1.0-c)/2.));\n}\n\nbool threshold(vec4 v, float c)\n{\n    bvec4 res = lessThan(v, vec4(c));\n    return (res.x && res.y && res.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct surface\n{\n    float dist;\n    vec3 color;\n};\n\nfloat smooth_union( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sd_sphere(vec3 p, float r) {return length(p)-r;}\nvec4 color_from_idx(int id)\n{\n    vec3 col = vec3(0);\n    switch (id)\n    {\n        case 1: col = vec3(0.0,1.0,0.1); break;\n        case 2: col = vec3(0.0,1.0,0.6); break;\n        case 3: col = vec3(0.3,0.7,0.3); break;\n    }\n    return vec4(col, 1);\n}\nvec4 color_from_id(float id) { return color_from_idx(int(floor(id))); }\n\nvec3 blend_surf_color(surface s1, surface s2, float s)\n{\n    float t = .5+.5*((s1.dist - s2.dist) / s);\n    t = clamp(t, 0., 1.);\n    return mix(s1.color, s2.color, t);\n}\n\nsurface SDF(vec3 p)\n{\n    surface s1 = surface(\n        sd_sphere(p - vec3(0,sin(iTime*.8)*.2,3), .5),\n        color_from_id(1.0).xyz\n    );\n    surface s2 = surface(\n        sd_sphere(p - vec3(-.6+cos(iTime)*.2,sin(iTime)*.5 + .3,3), .3),\n        color_from_id(2.0).xyz\n    );\n    surface s3 = surface(\n        sd_sphere(p - vec3(.6+cos(iTime*.8)*.2,sin(iTime*1.3)*.2+.1,3), .2),\n        color_from_id(3.0).xyz\n    );\n    \n    float s = .4;\n    surface p1 = surface(\n        smooth_union(s1.dist,s2.dist,s),\n        blend_surf_color(s1, s2, s)\n    );\n    \n    return surface(\n        smooth_union(p1.dist,s3.dist,s),\n        blend_surf_color(p1, s3, s)\n    );\n}\n\nvec3 get_normals(vec3 p)\n{\n    const float e = .001;\n    return normalize(vec3(\n        SDF(p+vec3(e,0,0)).dist - SDF(p-vec3(e,0,0)).dist,\n        SDF(p+vec3(0,e,0)).dist - SDF(p-vec3(0,e,0)).dist,\n        SDF(p+vec3(0,0,e)).dist - SDF(p-vec3(0,0,e)).dist\n    ));\n}\n\nvec4 get_background(vec3 p)\n{\n    return vec4(\n        vec3(l_ntsc(texture(iChannel1, p).rgb)*.1),\n        1.\n    );\n}\n\n#define PI 3.14159265359\n#define FOV 60.\n#define MIN_DIST .001\n#define MAX_DIST 100.\n#define STEPS 80\n#define INNER_STEPS 32\nvec4 raymarch(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= tan(.5*FOV*PI/180.);\n    vec3 o = vec3(0,0,-1.);\n    vec3 go = vec3(0,0,3);\n    o = rot_x(cos(iTime*1.65)*.65)*(o-go);\n    o = o+go;\n    \n    vec3 d = look_at(go+vec3(0,cos(iTime*1.65)*.35,0),o)*normalize(vec3(uv, 1.));\n    float t = 0.;\n    float m = MAX_DIST;\n    \n    //return vec4(.1) + wave_color*wave_color.a + glow;\n    vec3 gc = vec3(0,1,0);\n    \n    for (int i=0;i<STEPS;i++)\n    {\n        vec3 p = o+d*t;\n        surface s = SDF(p);\n        t += s.dist;\n        \n        if (t > MAX_DIST)\n            break;\n        \n        if (s.dist < MIN_DIST)\n        {\n            vec3 c = s.color;\n            vec3 n = get_normals(p);\n            vec3 l = vec3(0, 0, 2) - p;\n            l = normalize(l);\n            float kD = max(dot(n, l), 0.);\n            float kA = .13;\n            \n            float fact = -dot(d, n);\n            c = mix(.3*c, .6*c, fact*fact);\n            c += c*(kD+kA)*.7;\n            return vec4(c, 1);\n        }\n        \n        if (s.dist < m)\n        {\n            m = s.dist;\n            gc = s.color;\n        }\n    }\n    \n    vec4 col = get_background(vec3(d));\n    vec4 glow = mix(\n        vec4(gc,1),\n        vec4(gc*vec3(.6,.8,.6),1),\n        sqrt(m*1.)\n    )*max(1.-(m*2.), 0.);\n    \n    return col+glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = raymarch(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}