{"ver":"0.1","info":{"id":"XfXyDr","date":"1721389639","viewed":48,"name":"Scale Grid Template","username":"martinsh","description":"Template for linear and logarithmic scale grids, with extra mouse control","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["grid","linear","logarithmic"],"hasliked":0,"parentid":"4stSR8","parentname":"Logarithmic frequency scale grid"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n----------------------------------------------------------------------------  \n    Something I mashed up for my GLSL MIE Plotter \n    https://www.shadertoy.com/view/X3ySWd\n----------------------------------------------------------------------------\n                             Credits\n----------------------------------------------------------------------------\n    BeRo = https://www.shadertoy.com/view/4stSR8\n    SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#\n----------------------------------------------------------------------------                             \n*/\n\n#define FONT_EFFECTS\n#define AUTO_FONT_SPACING\n#define TILE_SIZE 1.0\n#define LINE_WIDTH 2.0\n//#define SQUARE\n#define MOUSE_CONTROL\n\nfloat MIN_SIZE = 0.1; //in micron (top of LUT)\nfloat MAX_SIZE = 1000.0; // in micron (bottom of LUT)\n\nfloat MIN_ANGLE = 0.0; //degrees (left of LUT)\nfloat MAX_ANGLE = 180.0; //degrees (right of LUT)\n\n//\n#define FONT_SAMPLER iChannel1\nconst float ln10 = 2.3025850929; // log(10.0);\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n// SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n    {\n        return 0.1f;\n    }\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )\n    {     \n        return 0.8f;\n    }\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n    \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n#ifdef FONT_EFFECTS    \n    float fShadowDistance;\n    vec2 vNormal;    \n#endif\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n#ifdef FONT_EFFECTS        \n    state.fShadowDistance = 1000000.0;\n    state.vNormal = vec2(0.0);    \n#endif    \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold;\n#ifdef FONT_EFFECTS        \n    bool bShadow;\n    vec2 vShadowOffset;\n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(8.0f, 8.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n#ifdef FONT_EFFECTS        \n    style.vShadowOffset = vec2(0);\n    style.bShadow = false;\n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n#ifdef FONT_EFFECTS            \n    vec3 vOutlineColor;\n    vec3 vHighlightColor;\n    float fOutlineWeight;\n    float fBevelWeight;\n    float fShadowSpread;\n    float fShadowStrength;\n    vec2 vLightDir;\n#endif    \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;\n#ifdef FONT_EFFECTS            \n    style.vOutlineColor = vec3(1);\n    style.vHighlightColor = vec3(0);\n    style.fOutlineWeight = 0.0f;\n    style.fBevelWeight = 0.0f;\n    style.fShadowSpread = 0.0f;\n    style.fShadowStrength = 0.0f;\n    style.vLightDir = vec2(-1.0f, -0.5f );\n#endif    \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;\n#ifdef FONT_EFFECTS            \n        state.vNormal = v.yz;\n#endif        \n    }\n\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fShadowDistance = SampleCharacter( iChar, vUV - style.vShadowOffset ).a;\n        if ( style.bBold )\n        {\n            fShadowDistance -= 0.025f;\n        }\n        \n        if ( fShadowDistance < state.fShadowDistance )\n        {\n            state.fShadowDistance = fShadowDistance;\n        }        \n    }\n#endif\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fSize = renderStyle.fFontWeight + renderStyle.fOutlineWeight;\n        float fBlendShadow = clamp( (state.fShadowDistance - fSize - renderStyle.fShadowSpread * 0.5) / -renderStyle.fShadowSpread, 0.0, 1.0);\n        color.rgb = mix( color.rgb, vec3(0.0), fBlendShadow * renderStyle.fShadowStrength);    \n    }\n\n    if ( renderStyle.fOutlineWeight > 0.0f )\n    {        \n        float fBlendOutline = GetFontBlend( state, style, renderStyle.fFontWeight + renderStyle.fOutlineWeight );\n        color.rgb = mix( color.rgb, renderStyle.vOutlineColor, fBlendOutline);\n    }\n#endif\n    \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n\t\n#ifdef FONT_EFFECTS            \n    if ( renderStyle.fBevelWeight > 0.0f )\n    {    \n        float fBlendBevel = GetFontBlend( state, style, renderStyle.fFontWeight - renderStyle.fBevelWeight );    \n        float NdotL = dot( state.vNormal, normalize(renderStyle.vLightDir ) );\n        float shadow = 1.0 - clamp(-NdotL, 0.0, 1.0f);\n        float highlight = clamp(NdotL, 0.0, 1.0f);\n        highlight = pow( highlight, 10.0f);\n        vCol = mix( vCol, vCol * shadow + renderStyle.vHighlightColor * highlight, 1.0 - fBlendBevel);\n    }\n#endif\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n\nvoid PrintMessage( inout PrintState state, LayoutStyle style )\n{\n    uint strA[] = uint[] ( _H, _e, _l, _l, _o, _COMMA, _SP, _w, _o, _r, _l, _d, _PERIOD, _EOL );\n    ARRAY_PRINT( state, style, strA );\n\n    uint strB[] = uint[] ( _ITALON, _A, _B, _C, _1, _2, _3, _ITALOFF, _EOL );\n    ARRAY_PRINT( state, style, strB );\n    \n    uint strC[] = uint[] ( _BOLDON, _A, _B, _C, _1, _2, _3, _BOLDOFF, _SP );\n    ARRAY_PRINT( state, style, strC );\n}\n\n\n\n// Value Range Functions\n\n// Map 0-1 value to min-max range in lin scale\nfloat MapNormalizedToRangeLin(in float val,in float minVal,in float maxVal)\n{\n    float scale = 1.0 / (maxVal - minVal);\n    float valRange = (val / scale) + minVal;\n    return valRange;\n}\n\n// Map value range to linear 0-1 value\nfloat MapRangeToNormalizedLin(float val, float minVal, float maxVal) {\n    // Ensure the input value is within the valid range\n    val = clamp(val, minVal, maxVal);\n    // Normalize the value to the [0, 1] range\n    return (val - minVal) / (maxVal - minVal);\n}\n\n// Map 0-1 value to min-max log range\nfloat MapNormalizedToRangeLog(in float val, in float minVal, in float maxVal)\n{\n    const float ln10 = 2.3025850929; // log(10.0);\n    float lowLog = log(minVal) / ln10;\n    float highLog = log(maxVal) / ln10;\n    float scale = 1.0 / (highLog - lowLog);\n    float valLogRange = exp(((val / scale) + lowLog) * ln10);\n    return valLogRange;\n}\n\n// Map value range to log 0-1 value\nfloat MapRangeToNormalizedLog(float val, float minVal, float maxVal) {\n    // Ensure the input value is within the valid range\n    val = max(val, minVal);\n\n    // Calculate the logarithmic value\n    float logMin = log(minVal);\n    float logMax = log(maxVal);\n    float logVal = log(val);\n\n    // Normalize the logarithmic value to the [0, 1] range\n    return (logVal - logMin) / (logMax - logMin);\n}\n\n// Grid drawing functions\n// Horizontal linear scale grid for angle in degrees visualization\nfloat grid_lin_scale(in float val,in float minVal,in float maxVal)\n{\n    float valRange = MapNormalizedToRangeLin(val,minVal,maxVal);\n  \n    float grid = 0.0;\n    float line = 0.0;\n    \n    float scales[6] = float[6](1.0, 5.0, 10.0, 90.0, 180.0, 360.0); //visualize these values (for angle in degrees in my case)\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        grid = 1.0 * abs(mod(valRange + 0.5*TILE_SIZE, TILE_SIZE * scales[i]) - 0.5) / fwidth(valRange) / LINE_WIDTH;\n    \tline = max(line, pow(2.0, float(i)) * (1.0 - min(grid, 1.0)));\n    }    \n    return line;\n}\n\n// Vertical log scale grid for sphere radius visualization\n\n// The logarithmic frequency scale grid from the GLSL-based spectrum analyzer in my CreamTracker 64k softsynth tracker\n// Copyright (C) 2016 by Benjamin 'BeRo' Rosseaux\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\nfloat grid_log_scale(in float val,in float minVal,in float maxVal)\n{\n  float onePixel = LINE_WIDTH / iResolution.y;\n  float line = 0.;\n\n  float lowLog = log(minVal) / ln10;\n  float highLog = log(maxVal) / ln10;\n  float scale = 1.0 / (highLog - lowLog);\n  float valLogRange = exp(((val / scale) + lowLog) * ln10);\n  \n  float currentMajorDecade = exp(floor(log(valLogRange) / ln10) * ln10);\t\n  float nearestMajorDecade = exp(floor((log(valLogRange) / ln10) + 0.5) * ln10);\t\n  float nearestMinorDecade = floor((valLogRange / currentMajorDecade) + 0.5) * currentMajorDecade;\t\n  float nearestSubMinorDecade = floor((valLogRange / (currentMajorDecade * 0.1)) + 0.5) * (currentMajorDecade * 0.1);\t\n  float ignoreFirstAndLastXFactor = step(onePixel, val) * (1.0 - step(1.0 - onePixel, val)); \n  //float ignoreFirstAndLastXFactor = 1.0;\n  line = mix(line, 0.0625, smoothstep(onePixel, 0.0, abs((((log(nearestSubMinorDecade) / ln10) - lowLog) * scale) - val)) * ignoreFirstAndLastXFactor);\n  line = mix(line, 0.15,   smoothstep(onePixel, 0.0, abs((((log(nearestMinorDecade) / ln10) - lowLog) * scale) - val)) * ignoreFirstAndLastXFactor);\n  line = mix(line, 0.5,    smoothstep(onePixel, 0.0, abs((((log(nearestMajorDecade) / ln10) - lowLog) * scale) - val)) * ignoreFirstAndLastXFactor);\n  return line;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.x/iResolution.y;\n    uv.xy -= 0.5; // offset -0.5\n    #ifdef SQUARE\n    uv.x *= AR; // fix aspect ratio\n    #endif\n    uv *= vec2(1.1,1.1);\n    uv.xy += 0.5; // offset it back\n    \n    // Mouse interaction\n    #ifdef MOUSE_CONTROL\n    MAX_ANGLE = MAX_ANGLE+(1.0-(iMouse.x/iResolution.x)*2.0-1.0)*90.0*1.1;\n    MIN_ANGLE = MIN_ANGLE+(1.0-(iMouse.x/iResolution.x)*2.0-1.0)*90.0*1.1;    \n    MAX_SIZE = (MapNormalizedToRangeLog((iMouse.y/iResolution.y)*1.1, 1.0, 10000.0));\n    #endif\n    \n    //Draw grids\n    float gridH = grid_lin_scale(uv.x,MIN_ANGLE,MAX_ANGLE)*0.1;\n    float gridV = grid_log_scale(1.0-uv.y,MIN_SIZE,MAX_SIZE);\n    float grid = gridV+max(gridH,gridV); //avoid bright dots at crosspoints\n    \n    \n    //Font drawing\n    vec2 vCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y );      \n    vec2 vCanvasPixelSize = vec2(1.0);\n\tbool bScaleWithResolution = true;    \n    \n    if ( bScaleWithResolution )\n    {\n    \tvCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y ) * vec2(640.0, 360.0) / iResolution.xy;\n        vCanvasCoord -= vec2(640.0, 360.0)/2.0;\n        vCanvasCoord *= vec2(1.1,1.1);\n        #ifdef SQUARE\n        vCanvasCoord.x *= AR; // fix aspect ratio\n        #endif\n        vCanvasCoord += vec2(640.0, 360.0)/2.0;\n        \n    \tvCanvasPixelSize = vec2(640.0, 360.0) / iResolution.xy;\n        \n        //vec2 dVdx = dFdx(vCanvasCoord);\n        //vec2 dVdy = dFdy(vCanvasCoord);\n        //vCanvasPixelSize = vec2( length(vec2(dVdx.x, dVdy.x) ), length(vec2(dVdx.y, dVdy.y) ) );\n    }\n    \n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n    LayoutStyle style = LayoutStyle_Default();\n    \n    #ifdef SQUARE\n    style.vSize.x *= AR;// fix aspect ratio\n    #endif\n    \n    int vnums = int((log(MAX_SIZE-MIN_SIZE)/ln10)-0.1)+1;\n    \n    for (int v = -1; v < vnums+1; ++v)\n    {\n    \n        state.vPos.x = vCanvasCoord.x-640.0-style.vSize.x/2.0;\n        float ypos = min(MapRangeToNormalizedLog(pow(10.0,float(v)), MIN_SIZE, MAX_SIZE)*360.0,360.0);\n        state.vPos.y = vCanvasCoord.y-ypos-style.vSize.y/4.0;\n        float num = clamp(pow(10.0,float(v)),MIN_SIZE,MAX_SIZE);\n        Print( state, style, num,1);\n    }\n    \n    int hnums = int((MAX_ANGLE-MIN_ANGLE)/10.0)+1;\n    \n    for (int h = int(MIN_ANGLE/10.0+0.2)-1; h < int(MIN_ANGLE/10.0-0.2)+hnums; ++h)\n    {\n        float xpos = MapRangeToNormalizedLin(float(h*10), MIN_ANGLE, MAX_ANGLE)*640.0;       \n        state.vPos.x = vCanvasCoord.x-xpos+style.vSize.x/2.0;\n        state.vPos.y = vCanvasCoord.y-360.0-style.vSize.y;\n        int num = int(clamp(float(h)*10.0,MIN_ANGLE,MAX_ANGLE));\n        Print( state, style, num);\n    }\n    \n\n    RenderStyle renderStyle = RenderStyle_Default( vec3(1.0) );\n    vec3 col = vec3(grid);\n    \n    \n    if (uv.x > 1.0 || uv.x < 0.0 || uv.y > 1.0 || uv.y < 0.0)\n    {\n        \n        col = vec3(0.0); //clear color\n        RenderFont( state, style, renderStyle, col ); //render text\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}