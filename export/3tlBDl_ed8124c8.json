{"ver":"0.1","info":{"id":"3tlBDl","date":"1598063594","viewed":179,"name":"My first metaballs","username":"dub","description":"First attempt to do metaballs, raymarching","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching:\n// http://viclw17.github.io/2018/11/29/raymarching-algorithm/#more\n// Metaballs reference:\n// https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/blobbies\n\nconst int MAX_MARCHING_STEPS = 254;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.01;\nconst float MAGIC = 0.5;\n\n#define FAKE_AA 1\n\n#define DEBUG_DEPTH 0\n#define WIREFRAME 0\n\nconst int numballs = 7;\nvec4 balls[numballs];\nbool select[numballs];\nvec3 ballColor[] = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\nfloat minDist(vec3 p)\n{\n    float sumDensity = 0.0;\n    float sumRi = 0.0;\n    float minDistance = 10000.0;\n    for (int i = 0; i < numballs; i++)\n    {\n        if (!select[i])\n            continue;\n        \n        float r = length(p - balls[i].xyz);\n        if (r <= balls[i].w)\n        {\n            float c = r/balls[i].w;\n            sumDensity += c*c*(2.0*c - 3.0) + 1.0;\n        }\n        minDistance = min(minDistance, r - balls[i].w);\n        sumRi += balls[i].w;\n    }\n    \n    return max(minDistance, (MAGIC - sumDensity) / ( 3.0 / 2.0 * sumRi));\n}\n\n// average the colors in range\nvec3 colMetaballs(vec3 p)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    float c = 0.0;\n    for (int i = 0; i < numballs; i++)\n    {\n        if (length(p - balls[i].xyz) < balls[i].w)\n        {\n            float d = length(p - balls[i].xyz);\n            float ds = smoothstep(1.0, 0.0, d/balls[i].w);\n        \tn += ballColor[i % 8] * ds;\n            c += ds;\n        }\n        \n    }\n    \n    return n / c;\n}\n\n// average the normals in range\nvec3 normMetaballs(vec3 p)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < numballs; i++)\n    {\n        if (length(p - balls[i].xyz) < balls[i].w)\n        {\n            float d = length(p - balls[i].xyz);\n            float ds = smoothstep(1.0, 0.0, d/balls[i].w);\n        \tn += (p - balls[i].xyz) * ds;\n        }\n    }\n    \n    return normalize(n);\n}\n\nvec3 shortestDistanceToSurface(vec3 origin, vec3 direction, float start, float end) {\n    float depth = start;\n    float m = end;\n    float md = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = minDist(origin + depth * direction);\n        if (dist < EPSILON) {\n            return vec3(depth, m, md);\n        }\n        depth += dist;\n        #if FAKE_AA == 1\n        if (dist < m)\n        {\n            m = dist;\n            md = depth;\n        }\n        #endif\n        if (depth >= end) {\n            return vec3(end, m, md);\n        }\n    }\n    return vec3(end, m, md);\n}\n\n// borrowed from iq\nfloat hash1( float n )\n{\n    return fract(sin(n)*2345.4546);\n}\n\nvoid moveBalls(float time)\n{\n    for (int i = 0; i < numballs; i++)\n    {\n        float h1 = hash1(float(i+1));\n        float h2 = hash1(h1);\n        float h3 = hash1(h2);\n        float h4 = sin(h3)*0.25+0.25;\n    \tballs[i] = vec4(sin(time * h1*2.0), sin(time * h2), cos(time * h3), 0.7+h4);\n    }\n}\n\nvec3 shadeBalls(in vec3 p, in vec3 v, in mat4 rot)\n{\n    vec3 n = normMetaballs(p);\n    vec3 col = texture( iChannel0, (rot * vec4(reflect(v, n), 1.0)).xyz ).xyz;\n    vec3 env = mix(vec3(0.226, .21, 0.21), vec3(0.945, 0.945, 0.949), n.y *0.5 + 0.5);\n    col = mix(col, env, 0.8);\n    col = mix(col, colMetaballs(p), 0.3);\n    return col;\n}\n\nbool selectBalls(vec3 dir, vec3 origin)\n{\n    // work in progress\n    bool hit = false;\n    for (int i = 0; i < numballs; i++)\n    {\n        float radius2 = balls[i].w;\n        radius2 *= radius2;\n\n        vec3 L = origin - balls[i].xyz;\n        float a = dot(dir, dir);\n        float b = 2.0 * dot(dir, L);\n        float c = dot(L, L) - radius2;\n\n        float discr = b * b - 4.0 * a * c;\n        \n        // select[i] = (discr >= -EPSILON);\n        select[i] = (true); // this is not working\n        hit = hit || (discr >= -EPSILON);\n\t}\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord*2.0/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n \n    float time = iTime * 0.5; // slow down man!\n    moveBalls(time);\n    \n\tmat4 rot = mat4( cos(time), 0.0, sin(time), 0.0,\n                           0.0, 1.0,       0.0, 0.0,\n                    -sin(time), 0.0, cos(time), 0.0,\n                           0.0, 0.0,       0.0, 1.0);\n\n    vec3 pixelPos = vec3(xy, 2.0);\n    vec3 eyePos = vec3(0.,0.,5.);\n    vec3 rayDir = normalize(pixelPos-eyePos);\n    \n    bool hit = selectBalls(rayDir, eyePos);\n\n    vec3 dist = (hit)? shortestDistanceToSurface(eyePos, rayDir, MIN_DIST, MAX_DIST):\n    \tvec3(MAX_DIST, MAX_DIST, 0.0);\n\n    #if DEBUG_DEPTH == 0\n    if (dist.x > MAX_DIST - EPSILON) {\n        vec3 fp = vec3(0.0, 0.0, 1.0);\n        vec3 bgDir = (vec4(mix(rayDir, fp, 0.4), 1.0) * rot).xyz;\n        vec3 sky = texture( iChannel0, bgDir).xyz;\n        #if FAKE_AA == 1\n        if (dist.y < EPSILON*1.1)\n        {\n            rot = inverse(rot);\n            vec3 col = shadeBalls(rayDir * dist.z + eyePos, rayDir, rot);\n            fragColor.rgb = mix(col, sky, (dist.y - EPSILON) /(EPSILON *0.1) );\n            return;\n        }\n        #endif\n        fragColor = vec4(sky, 1.0);\n    }\n    else\n    {\n        rot = inverse(rot);\n        vec3 p = rayDir * dist.x + eyePos;\n        fragColor.rgb = shadeBalls(p, rayDir, rot);\n        #if WIREFRAME == 1\n        if (mod(p.x, 0.1) < EPSILON || mod(p.y, 0.1) < EPSILON)\n            fragColor.rgb += vec3(0.0, 1.0, 1.0);\n        #endif\n    }\n    #else\n    if(hit)\n    {\n    \tfragColor.rgb = vec3((7.0-dist.x)/3.0);\n        #if WIREFRAME == 1\n        vec3 p = rayDir * dist.x + eyePos;\n        if (mod(p.x, 0.1) < EPSILON || mod(p.y, 0.1) < EPSILON)\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 1.0, 1.0), 0.5);\n        #endif\n    }\n    else\n    \tfragColor.rgb = vec3(1.0, 0.0, 0.0);\n    #endif\n}","name":"Image","description":"","type":"image"}]}