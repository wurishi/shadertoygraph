{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Tetrahedronator by eiffie\n//This is an attempt at the 3d (or 4d?) version of Triangulator by Nimitz https://www.shadertoy.com/view/lllGRr\n\n//The idea is still simple: find the tetrahedral section of the cube we are in\n//then get 4 samples and compute distance using barycentric coords (4d version).\n//The implementation is not so simple. Tiling with good tetrahedra that are fairly regular\n//is tricky (unless your knighty) and the 4d version of barycentric coords requires \n//a matrix inverse every DE check. So many shortcuts have been taken. \n//It does produce only flat surfaces made of polys but with VERRRY irregular sizes.\n \n\n#define time iTime\n#define size iResolution\n\n//for comparison\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\n/*vec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y)+1e-9;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return abs(vec3(u,v,w));\n}*/\n\n//my own tet weighting function cause why not (actually i didn't want to do the mat inv thingy)\nvec4 eiffieCentricCoords(vec3 a, vec3 b, vec3 c, vec3 d, vec3 p) \n{\n\tb -= a; c -= a; d -= a, p -= a;\n\tvec3 B = cross(c,d), C=cross(b,d), D=cross(b,c);\n\tfloat y = dot(p,B)/(dot(b,B));\n\tfloat z = dot(p,C)/(dot(c,C));\n\tfloat w = dot(p,D)/(dot(d,D));\n\treturn abs(vec4(1.0-y-z-w,y,z,w));\n}\n\n//from iq, this version removes the mix\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\n\nfloat DO(in vec3 z){//the object's distance estimate\n\tfloat bowl=length(max(vec2(abs(length(z.xyz)-0.9),z.y),0.0))-0.1;\n\tfloat d=smin(bowl,length(z+vec3(-1.5,0.5,0.0))-0.5,0.5);\n\treturn d;\n}\n\nfloat rez,hrez;//the tesellation scale, and half it \nvec4 wt;\nfloat DE(in vec3 p){\n\tvec3 c=floor(p/rez)*rez+vec3(hrez);//tile the space into cubes and find the center\n\tfloat d0=DO(c);//get the approx distance and return if far away\n\tif(d0>rez*4.0)return d0-rez*1.5;\n\t\n\t//find 4 points in space surrounding point p, we know one will be c the center of the cube\n\t//we will find the three other corners of the cube that enclose our point\n\tvec3 o1=vec3(1.0),o2=vec3(-1.0),o3;//offsets for the other \"vertices\"\n\tvec3 tp=p-c,abp=abs(tp),sp=sign(tp);//get our position within the cube\n\tif(abp.x>abp.y && abp.x>abp.z){//now tile the cube into 12 tetrahedrons (very irregular) and find the one we are in\n\t\to1.x=sp.x;o2.x=sp.x;//the first 2 vertices we only need to know which side of the cube it is on\n\t\to3=vec3(sp.x,vec2(1.0,-1.0)*sign(tp.y-tp.z));//the third vertex is chosen from a diagonal\n\t}else if(abp.y>abp.z){//we are on one of the \"Y\" sides of the cube\n\t\to1.y=sp.y;o2.y=sp.y;//which y side is determined by the sign of y obviously\n\t\tif(tp.x>tp.z)o3=vec3(1.0,sp.y,-1.0);//now spilt this pyramid shape in 2 diagonally\n\t\telse o3=vec3(-1.0,sp.y,1.0);\n\t}else{//the \"Z\" sides, same same\n\t\to1.z=sp.z;o2.z=sp.z;\n\t\to3=vec3(vec2(1.0,-1.0)*sign(tp.x-tp.y),sp.z);\n\t}\n\to1*=hrez;o2*=hrez;o3*=hrez;//scale the offsets to the tetrahedron's vertices\n\t//eiffie centric coords are just like barycentric only they work like sh!@!T!\n\twt=eiffieCentricCoords(c,c+o1,c+o2,c+o3,p);\n\t//now use these points to determine the weighted avg distance\n\tvec4 pd=vec4(d0,DO(c+o1),DO(c+o2),DO(c+o3));//get the distances\n\tpd*=wt;//apply the weights\n\treturn pd.x+pd.y+pd.z+pd.w; //and wala! ...crappy tesellation\n}\nfloat meshy=0.0;\nvec3 scene( vec3 ro, vec3 rd, vec2 fragCoord ){\n\tfloat t=0.0,d,dm=100.0,tm,px=1.0/size.y,ff=0.75+0.25*cos(time*0.1);\n\tfor(int i=0;i<48;i++){\n\t\td=DE(ro+rd*t)*ff;\n\t\tif(d<dm){dm=d;tm=t;if(d<0.00001)break;}\n\t\tt+=d+px*t;\n\t\tif(t>5.0)break;\n\t}\n\tvec3 col=vec3(fragCoord.y/size.y*0.2);\n\tpx*=tm;\n\tif(dm<px){\n\t\tro+=rd*tm;\n\t\tfloat d=DE(ro);\n\t\tfloat w=min(wt.x,min(wt.y,min(wt.z,wt.w))),dif=0.5,spec=0.0;\n\t\tif(meshy<0.8){\n\t\t\tvec2 v=vec2(px*0.66,0.0);\n\t\t\tvec3 dn=vec3(DE(ro-v.xyy),DE(ro-v.yxy),DE(ro-v.yyx));\n\t\t\tvec3 dp=vec3(DE(ro+v.xyy),DE(ro+v.yxy),DE(ro+v.yyx));\n\t\t\tvec3 nor=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\t\t\tvec3 litDir=normalize(vec3(0.7,0.4,0.7));\n\t\t\tdif=0.5+0.5*dot(nor,litDir);\n\t\t\tspec=0.25*pow(max(0.0,dot(reflect(rd,nor),litDir)),4.0);\n\t\t\tvec3 scol=vec3(0.5);//vec3(0.6,0.3,0.3+dot(nor,rd)*0.1);\n\t\t\tscol=clamp(dif*scol+spec*vec3(1.0),0.0,1.0);\n\t\t\tcol=mix(scol,col,clamp(dm/px+meshy*2.0,0.0,1.0));\n\t\t}\n\t\tcol=mix(vec3(0.0,0.5,0.0),col,smoothstep(0.0,12.0*px,1.0-meshy+w));\n\t}\n\treturn col;\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nvec2 ch_p;\nfloat ch_d;\nvoid ch(int i){\n\tconst float ch_sv=0.4,ch_sh=0.2;\n\tif(i > 127){i-=128;ch_d=min(ch_d,max(abs(ch_p.x),abs(ch_p.y)-ch_sv));}\n\tif(i > 63){i-=64;ch_d=min(ch_d,max(abs(ch_p.x-ch_sh),abs(ch_p.y-ch_sh)-ch_sh));}\n\tif(i > 31){i-=32;ch_d=min(ch_d,max(abs(ch_p.x-ch_sh),abs(ch_p.y+ch_sh)-ch_sh));}\n\tif(i > 15){i-=16;ch_d=min(ch_d,max(abs(ch_p.x+ch_sh),abs(ch_p.y-ch_sh)-ch_sh));}\n\tif(i > 7){i-=8;ch_d=min(ch_d,max(abs(ch_p.x+ch_sh),abs(ch_p.y+ch_sh)-ch_sh));}\n\tif(i > 3){i-=4;ch_d=min(ch_d,max(abs(ch_p.x)-ch_sh,abs(ch_p.y-ch_sv)));}\n\tif(i>1){i-=2;ch_d=min(ch_d,max(abs(ch_p.x)-ch_sh,abs(ch_p.y)));}\n\tif(i>0)ch_d=min(ch_d,max(abs(ch_p.x)-ch_sh,abs(ch_p.y+ch_sv)));\n\tch_p.x-=ch_sv*1.5;\n}\nfloat cursor(vec2 uv, vec2 ms){\n\tfloat d=max(abs(uv.x-ms.x)*abs(uv.y-ms.y),max(abs(uv.x-ms.x)-0.015,abs(uv.y-ms.y)-0.02));\n\treturn smoothstep(0.0,0.01,sqrt(d));\n}\nvec2 mstsk(float t){\n\tif(t<0.0)return vec2(0.9,0.5);\n\tif(t==0.0 || t==4.0)return vec2(0.375,0.025);\n\tif(t==1.0)return vec2(0.9,0.6);\n\tif(t==2.0 || t==6.0)return vec2(0.77,0.5);\n\tif(t==3.0)return vec2(0.9,0.9);\n\tif(t==5.0)return vec2(0.9,0.7);\n\treturn vec2(0.9,0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\trez=0.01;\n\tfloat clk=1.0,tim=time,maxRez=0.15,minRez=0.01;\n\tvec2 slider=vec2(0.375,0.5), ms=slider;\n\tfloat tm=mod(tim,5.0),tsk=mod(floor(tim/5.0),8.0);\n\tif(tsk>1.0 && tsk<8.0)rez=maxRez;\n\tif(tsk==4.0)meshy=1.0;\n\tms=mstsk(tsk);\n\tif(tm<1.0){//moving mouse to task\n\t\tms=mix(mstsk(tsk-1.0)+vec2(-0.3,1.0)*tm,ms,tm);\t\n\t\tif(tsk==5.0)meshy=1.0;\n\t}else{//perform task\n\t\ttm-=1.0;tm*=0.25;\n\t\tif(ms.y<0.03){ms.x+=sin(tm*6.283)*0.3;slider.x=ms.x;}\n\t\telse if(ms.x==0.77){ms.y+=sin(tm*6.283)*0.4;slider.y=ms.y;}\n\t\t//if(tm<0.04)clk=0.0;\n\t\tif(tsk==1.0)rez=minRez+tm*(maxRez-minRez);\n\t\telse if(tsk==7.0)rez=maxRez-tm*(maxRez-minRez);\n\t\tif(tsk==3.0)meshy=tm;\n\t\tif(tsk==5.0)meshy=1.0-tm;\n\t\tclk=sin(time*50.0);\n\t}\n\tvec2 uv=fragCoord.xy/size.xy;\n\tvec3 color;\n\tif(uv.x<0.75 && uv.y>0.05){\n\t\t\n\t\threz=0.5*rez;\n\t\tfloat a=-slider.x*3.0,b=slider.y*3.0;\n\t\tvec3 ro=vec3(0.0,0.0,1.5),rd=vec3((vec2(2.5)*fragCoord.xy-size.xy)/size.y,1.5);\n\t\tro.xz=rotate(ro.xz,a);\n\t\tro.xy=rotate(ro.xy,b);\n\t\trd=lookat(vec3(0.0,-1.0,0.0)-ro,vec3(0.0,1.0,0.0))*normalize(rd);\n\t\tcolor=scene(ro,rd,fragCoord);\n\t}else{\n\t\tcolor=vec3(0.4);\n\t  \tif(uv.x>0.79 && uv.y<0.95 && uv.y>0.45){\n\t\t\tfloat sz=30.0;\n\t\t\tch_d=100.0;\n            const int _A=126, _C=29,_D=125,_E=31,_F=30,_H=122,_I=128,_L=25,_M=252,_P=94, _S=55,_T=132,_U=121;\n\t\t\tch_p=(uv-vec2(0.86,0.9))*sz;\n\t\t\tch(_M);ch(_E);ch(_S);ch(_H);\n\t\t\tch_p=(uv-vec2(0.83,0.8))*sz;\n\t\t\tch(_D);ch(_I);ch(_F);ch(_F);ch(_U);ch(_S);ch(_E);\n\t\t\tch_p=(uv-vec2(0.82,0.7))*sz;\n\t\t\tch(_S);ch(_P);ch(_E);ch(_C);ch(_U);ch(_L);ch(_A);ch(_A);\n\t\t\tch_p=(uv-vec2(0.81,0.6))*sz;\n\t\t\tch(_T);ch(_E);ch(_S);ch(_E);ch(_L);ch(_L);ch(_A);ch(_T);ch(_E);\n\t\t\tch_p=(uv-vec2(0.84,0.5))*sz;\n\t\t\tch(_S);ch(_M);ch(_D);ch(_D);ch(_T);ch(_H);\n\t\t\tfloat y=mod(uv.y+0.04,0.1);\n\t\t\tif(abs(uv.x-0.89)<0.1 && y<0.08)color=vec3(0.5+y*4.0);\n\t\t\tcolor=mix(vec3(0.0),color,smoothstep(0.0,0.1,ch_d));\n\t  \t}else if(uv.y<0.045 && uv.x<0.75){\n\t\t\tcolor=vec3(0.4+uv.y*5.0+max(0.0,0.4-abs(uv.x-slider.x)*60.0));\n\t\t}else if(uv.y>0.05 && uv.x>0.755 && uv.x<0.785){\n\t\t\tcolor=vec3(0.6+(0.755-uv.x)*5.0+max(0.0,0.4-abs(uv.y-slider.y)*40.0));\n\t\t}\t\t\n\t}\n\tcolor=mix(vec3(0.0),color,cursor(uv,ms));\n\tuv-=vec2(0.004);\n\tif(clk>0.5)color=mix(vec3(1.0),color,cursor(uv,ms));\n\tfragColor = vec4(color,1.0);\t\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llf3z8","date":"1418413898","viewed":801,"name":"Tetrahedronator","username":"eiffie","description":"I don't even know how to work this polygon software anymore. Where is the code window?","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["3d","tesellation"],"hasliked":0,"parentid":"","parentname":""}}