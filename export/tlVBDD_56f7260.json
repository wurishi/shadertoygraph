{"ver":"0.1","info":{"id":"tlVBDD","date":"1614555845","viewed":124,"name":"Granite materials","username":"JeanArthurDeda","description":"High key lighted granite mine, a test for materials and specular.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["specular","material","granit"],"hasliked":0,"parentid":"ttGfRW","parentname":"bondi template"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A bit of granite based materials\n\n#define TYPE_WOOD 0\n#define TYPE_GRANITE 1\n#define TYPE_COLOR 2\n\nstruct Surfs\n{\n    Surf wood;\n    Surf granit;\n    Surf wall;\n};\n\nstruct Context\n{\n    Surfs surfs;\n    Omni omni;\n    float t;\n};\nfloat pilar(vec3 p, float s)\n{\n    vec3 size=vec3(1.,3., .3);\n    const float mar=0.1;\n    float d = box (p, size)-s;\n    // carve out the cylinder\n    float r1 = size.x-mar;\n    d = opS(d, length(p.xy)-r1);\n    // carve out the bottom box\n    d = opS(d, box(p.xy-vec2(0,-(r1+size.y)*.5), vec2(size.x-mar,mar+.5*(size.y-r1))));\n    // add a cylinder\n    float r2 = .5*(size.y-r1)-mar*4.;\n    r2 = min(r2, size.x-mar);\n    float y2=.5*(r1+size.y);\n    d = min(d, cylinder((p-vec3(0,y2,size.z)).xzy,r2, 0.05)-s);\n    // carve out the bellow cylinder box\n    d = opS(d, box(p.xy-vec2(0,.5*(y2-r2+r1)),vec2(size.x-mar, (y2-r2-r1)*.15))-s);\n    return d;\n}\nSurf scene(vec3 p, Context cont)\n{\n    // floor\n    Surf s;\n    {\n        vec3 q=p;\n        q.y-=cos(dot(q.xz,vec2(1))*.9)*.1;\n        s = surf(cont.surfs.wood, plane(q,vec3(0,1,0),3.));\n    }\n\n    // wall\n    // do a fake sedentation bump\n    float b=texture(iChannel1,p.xy*.1).g;\n    b+=texture(iChannel1,p.yz*.1).g;\n    b=smoothstep(0.5,1.,b)*0.03;\n    s = opU(s, surf(cont.surfs.wall,.8*plane(p,vec3(0,0,1),b)));\n\n    // \"pilars\"\n    {\n        vec3 q = wrapl(p, vec3(2.7),vec3(10,0,0));\n        float i = wrapi(p, vec3(2.7)).x;\n        s = opU(s, surf(cont.surfs.granit, pilar(q-vec3(0,-mod(i+1.,2.),1),0.04)));\n    }\n    return s;\n}\nDECL_RAY (ray, scene,0.,40.,64)\nvec4 mat(vec3 p, vec3 n, Surf s, Context cont)\n{\n    if (s.t == TYPE_WOOD)\n    {\n        vec4 t = boxmap(iChannel0,p*.25,n);\n        t.xyz=smoothstep(s.cst.xxx,s.cst.yyy,t.xyz);\n        return vec4(s.c*t.xyz,smoothstep(0.0,0.3,t.z));\n    }\n    if (s.t == TYPE_GRANITE)\n    {\n        vec4 t = boxmap(iChannel1,p*.25,n);\n        float a=smoothstep(0.5, 1., t.x);\n        t.xyz=smoothstep (s.cst.xxx,s.cst.yyy,t.xyz);\n        return vec4(s.c*t.xyz,a);\n    }\n    return vec4(s.c,1);\n}\nDECL_NOR (nor, scene)\nDECL_AO  (ao, scene)\nDECL_SHD (shadow, scene)\nvoid light(vec3 p, vec3 d, vec3 n, Surf s, float f, Context cont, out vec3 dif, out vec3 spe)\n{\n    vec3 l;\n    float k;\n    omni(p,cont.omni.p,l,k);\n    k*=1.-(1.-shadow(p,normalize(l+vec3(0,0.0,.2)),0.1,5., cont))*.8;\n    dif=clamp(dot(n,l),0.3,1.)*k*cont.omni.c;\n    spe=pow(clamp(dot(reflect(d,n),l),0.0, 1.0),3.0)*k*cont.omni.c*f*s.s;\n}\nDECL_RENDER(render,ray,mat,nor,ao,light)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Context cont;\n    cont.t = iTime;\n    cont.surfs.wood = surf(col(255),vec2(0,1.),TYPE_WOOD,2.,1.);\n    cont.surfs.granit = surf(col(99,106,73),vec2(-0.2,0.5),TYPE_GRANITE,0.4,1.);\n    cont.surfs.wall = surf(col(141,118,42),vec2(-0.5,1),TYPE_GRANITE,2.0,1.);\n    cont.omni.p = vec3(cos(cont.t*.4)*8., 0.0, 3.);\n    cont.omni.c = col(6192);\n\n    float r=-cos(-cont.t*.1)*2.+5.;\n    float t=sin(cont.t*.2);\n    vec2 p =(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 o=vec3(sin(t*.2)*r,0.,cos(t*.2)*r);\n    vec3 d=normalize(vec3(p,2.)*camera(o,vec3(0,0,0)));\n    \n    fragColor=vec4(render(o,d,cont),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793238f\n\nvec3 col(int r, int g, int b){return vec3(r,g,b)/255.;}\n\nvec3 col(int i) {return vec3(i)/255.;}\n\nstruct Surf\n{\n    float d;\n    vec3 c;\n    vec2 cst;\n    int t; \n    float s;\n    float f;\n};\n\nSurf surf(vec3 c,vec2 cst,int t,float s_,float f){Surf s;s.c=c;s.cst=cst;s.t=t;s.s=s_;s.f=f;return s;}\n\nSurf surf(Surf s, float d){Surf r=s;r.d=d;return r;}\n\nstruct Dir\n{\n    vec3 c;\n    vec3 d;\n};\n\nstruct Omni\n{\n    vec3 c;\n    vec3 p;\n};\n\nstruct Spot\n{\n    vec3 c;\n    vec3 p;\n    vec3 d;\n    vec2 h;\n};\n\nfloat rad(float a) {return a*PI/180.0;}\n\nfloat sphere(vec3 p,float r){return length(p)-r;}\n\nfloat box(vec3 p,vec3 s){vec3 q=abs(p)-s;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);}\n\nfloat box(vec2 p, vec2 s){vec2 q=abs(p)-s;return length(max(q,0.0))+min(max(q.x,q.y),0.0);}\n\nfloat plane(vec3 p,vec3 n,float d){return dot(p,n)+d;}\n\nfloat cylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat capsule(vec3 p,vec3 a,vec3 b,float r)\n{\n  vec3 pa=p-a, ba=b-a;\n  float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0 );\n  return length(pa-ba*h)-r;\n}\n\nSurf opU(Surf s1,Surf s2) {if(s1.d<s2.d)return s1; return s2;}\n\nfloat opS(float d1, float d2 ) { return max(d1,-d2); }\n\nfloat opI(float d1, float d2 ) { return max(d1,d2); }\n\nvec2 rotate(vec2 v, vec2 o, float a) \n{\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\tmat2 m=mat2(c,-s,s,c);\n\treturn o+(v-o)*m;\n}\n\nvec3 wrap(vec3 p, vec3 s){return mod(p+.5*s,s)-.5*s;}\n\nvec3 wrapi(vec3 p, vec3 s){return floor(p/s-.5);}\n\nvec2 wrap(vec2 p, vec2 s){return mod(p+.5*s,s)-.5*s;}\n\nvec2 wrapi(vec2 p, vec2 s){return floor(p/s-.5);}\n\nfloat wrap(float p, float s){return mod(p+.5*s,s)-.5*s;}\n\nfloat wrapi(float p, float s){return floor(p/s-.5);}\n\nvec3 wrapl(vec3 p, vec3 s, vec3 l){return p-s*clamp(round(p/s),-l,l);}\n\nvec2 wrapl(vec2 p, vec2 s, vec2 l){return p-s*clamp(round(p/s),-l,l);}\n\nfloat atten(vec3 l) {return 1./length(l);}\n\nvec3 dir(vec3 p, vec3 n, Dir d)\n{\n    float k= clamp(dot(n,d.d),0.,1.);\n    return k*d.c;\n}\n\nvoid omni(vec3 p, vec3 op, out vec3 l, out float k)\n{\n    l=op-p;\n    k = atten(l);\n    l = normalize(l);\n}\n\nvec3 omni(vec3 p, vec3 n, Omni o)\n{\n    vec3 l;\n    float k;\n    omni(p, o.p, l, k);\n    k*= clamp(dot(n,l),0.,1.);\n    return k*o.c;\n}\n\nvoid spot(vec3 p, vec3 sp, vec3 sd, vec2 sh, out vec3 l, out float k)\n{\n    omni(p, sp, l, k);\n    k *= smoothstep (cos(sh.y),cos(sh.x),dot(l,-sd));\n}\n\nvec3 spot(vec3 p, vec3 n, Spot s)\n{\n    vec3 l;\n    float k;\n    spot(p, s.p, s.d, s.h, l, k);\n    k*= clamp(dot(n,l),0.,1.);\n    return k*s.c;\n}\n\nmat3 camera(vec3 o, vec3 t)\n{\n\tvec3 z = normalize(t-o);\n\tvec3 x = cross(vec3(0,1,0),z);\n\tvec3 y = cross(z,x);\n    return transpose(mat3(x,y,z));\n}\n\nvec4 boxmap(sampler2D s, vec3 p, vec3 n, float b)\n{\n    n = pow(abs(n),vec3(b));\n    vec4 nx = texture(s, p.yz);\n    vec4 ny = texture(s, p.xz);\n    vec4 nz = texture(s, p.xy);\n    return nx*n.x+ny*n.y+nz*n.z;\n}\n\nvec4 boxmap(sampler2D s, vec3 p, vec3 n)\n{\n    float v[3] = float[3](abs(n.x), abs(n.y), abs(n.z));\n    int m = 0;\n    for (int i=1;i<3;++i)\n        if (v[i]>v[m]) m=i;\n    v = float[3](p.x,p.y,p.z);\n    return texture(s,vec2(v[(m+1)%3],v[(m+2)%3]));\n}\n\n#define DECL_RAY(name,scene,near,far,iterations) \\\nSurf name(vec3 o, vec3 d, Context cont) \\\n{ \\\n    float t = near; \\\n    Surf r; \\\n    for( int i=0; i<iterations; i++ ) \\\n    { \\\n\t    r = scene(o+d*t,cont); \\\n        if(r.d<t*0.0001||t>far) break; \\\n        t+=r.d; \\\n    } \\\n    r.d=t>far?-1.:t; \\\n    return r; \\\n}\n\n#define DECL_NOR(name,scene) \\\nvec3 name(vec3 p, Context cont) \\\n{ \\\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005; \\\n    return normalize( e.xyy*scene(p+e.xyy,cont).d + \\\n\t\t\t\t\t  e.yyx*scene(p+e.yyx,cont).d + \\\n\t\t\t\t\t  e.yxy*scene(p+e.yxy,cont).d + \\\n\t\t\t\t\t  e.xxx*scene(p+e.xxx,cont).d );\\\n}\n\n#define DECL_AO(name,scene) \\\nfloat name(vec3 p, vec3 n, Context cont) \\\n{ \\\n\tfloat o = 0.0; \\\n    float s = 1.0; \\\n    for(int i=0;i<5;i++) \\\n    { \\\n        float hr = 0.01 + 0.12*float(i)/4.0; \\\n        vec3 aopos=n*hr+p; \\\n        float dd = scene(aopos,cont).d; \\\n        o += -(dd-hr)*s; \\\n        s *= 0.95; \\\n    } \\\n    return clamp(1.-3.*o,0.,1.); \\\n}\n\n#define DECL_SHD(name,scene) \\\nfloat name(vec3 p,vec3 d,float s,float e, Context cont) \\\n{ \\\n\tfloat res = 1.0; \\\n    float t = s; \\\n    for( int i=0; i<16; i++ ) \\\n    { \\\n\t\tfloat h = scene(p+d*t,cont).d; \\\n        res = min(res,8.0*h/t); \\\n        t += clamp(h,0.02,0.10); \\\n        if(h<0.001||t>e) break; \\\n    } \\\n    return clamp(res,0.,1.); \\\n}\n\n#define DECL_TO_REFL(name, SKY) vec3 name(vec3 p,vec3 d,Context cont) {return SKY(d,cont);}\n\n#define DECL_RENDER(name,RAY,MAT,NOR,AO,LIGHT) \\\nvec3 name(vec3 o,vec3 d, Context cont) \\\n{ \\\n    vec3 c=vec3(0); \\\n    Surf s=RAY(o,d,cont); \\\n    if (s.d>0.0) \\\n    { \\\n        vec3 p=o+s.d*d; \\\n        vec3 n=NOR(p,cont); \\\n        float occ=AO(p,n,cont); \\\n        float f=pow(1.-dot(n,-d),s.f);\\\n        vec3 dif=vec3(0); \\\n        vec3 spe=vec3(0); \\\n        LIGHT(p,d,n,s,f,cont,dif,spe); \\\n        vec4 m=MAT(p,n,s,cont); \\\n        c=m.xyz*sqrt(dif*m.xyz*occ)+sqrt(spe)*m.w; \\\n    } \\\n    return c; \\\n}","name":"Common","description":"","type":"common"}]}