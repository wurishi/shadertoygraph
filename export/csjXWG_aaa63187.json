{"ver":"0.1","info":{"id":"csjXWG","date":"1671177018","viewed":911,"name":"trying to learn fog","username":"Nemerix","description":"This shader borrows heavily from iq's rainforest shader, suyoku's shader: https://www.shadertoy.com/view/tsScDG, and his blog posts: https://wallisc.github.io/rendering/2020/05/02/Volumetric-Rendering-Part-1.html","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define MARCH_SCALE 1.0\n\n\nvec4 background(vec3 rd)\n{\n  float t = 1.0 - abs(rd.z);\n  return mix(vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.8, 1.0), 1.0-t*t);\n}\n\nstruct marchResult\n{\n  vec3 pos;\n  vec3 norm;\n  float inBounds;\n  float depth;\n  vec4 color;\n};\n\nstruct transparentMarchResult\n{\n  float opacity;\n  vec4 color;\n};\n\nstruct OrbLightDescription\n{\n    vec3 pos;\n    float Radius;\n    vec3 color;\n};\n\nvec3 GetLightColor(int lightIndex)\n{\n    switch(lightIndex)\n    {\n        case 0: return vec3(1, 0.0, 1.0);\n        case 1: return vec3(0, 1.0, 0.0);\n    }\n    return vec3(0, 0.0, 1.0);\n}\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    const float lightMultiplier = 17.0f;\n    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(3);\n    float radius = 28.5f;\n    \n    OrbLightDescription orbLight;\n    orbLight.pos = vec3(radius * cos(theta), radius * sin(theta), 16.0 + sin(theta * 2.0) * 2.5);\n    orbLight.color = GetLightColor(lightIndex) * lightMultiplier;\n    orbLight.Radius = 0.8f;\n\n    return orbLight;\n}\n\n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p )\n{\n\treturn p.z;\n}\n\nfloat SmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat QueryVolumetricDistanceField(vec3 ro)\n{\n  vec3 fbmCoord = (ro + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5f;\n  float sdfValue = sdSphere(ro - vec3(-8.0, 2.0 + 20.0 * sin(iTime), -1), 5.6);\n  sdfValue = SmoothUnion(sdfValue,sdSphere(ro - vec3(8.0, 8.0 + 12.0 * cos(iTime), 3), 5.6), 3.0f);\n  sdfValue = SmoothUnion(sdfValue, sdSphere(ro - vec3(5.0 * sin(iTime), 3.0, 0), 8.0), 3.0) + 7.0 * fbm_4(fbmCoord / 3.2);\n  sdfValue = SmoothUnion(sdfValue, sdPlane(ro + vec3(0, 0.4, 0)), 22.0);\n  return sdfValue;\n}\n\n// 18 ops + mod\nmarchResult traceToOpaque(vec3 ro, vec3 rd)\n{\n  float d = -ro.z / rd.z;\n  ro += d*rd;\n  float tileIdx = mod(floor(ro.x * 0.2) + floor(ro.y * 0.2), 2.0);\n  \n  marchResult result;\n  result.inBounds = step(0.0, d);\n  result.pos = ro;\n  result.norm = vec3(0.0, 0.0, 1.0);\n  result.color = vec4(vec3(0.2 + 0.6*tileIdx), 1.0);\n  result.depth = d;\n  return result;\n}\n\n// 400 ops, 54 calls to QueryVField\n// ~40,000 ops\nmarchResult marchToTransparent(vec3 ro, vec3 rd)\n{\n  int i = 0;\n  float d = 0.0;\n  float depth = 0.0;\n  for (; i < 50; ++i)\n  {\n    d = QueryVolumetricDistanceField(ro);\n    ro += 1.0*d*rd;\n    depth += d;\n    if (d < 0.1)\n    {\n      break;\n    }\n  }\n  marchResult result;\n  result.pos = ro;\n  bool inBounds = i < 50 || dot(ro, ro) < 1e4;\n  result.inBounds = inBounds ? 1.0 : 0.0;\n  if (inBounds)\n  {\n    result.color = vec4(1, 1, 1, 1);\n    d = QueryVolumetricDistanceField(ro);\n    result.norm.x = QueryVolumetricDistanceField(ro + vec3(0.001, 0.0, 0.0)) - d;\n    result.norm.y = QueryVolumetricDistanceField(ro + vec3(0.0, 0.001, 0.0)) - d;\n    result.norm.z = QueryVolumetricDistanceField(ro + vec3(0.0, 0.0, 0.001)) - d;\n    result.norm = normalize(result.norm);\n    result.depth = depth;\n  }\n  return result;\n}\n\n// 700 ops\nfloat fogDensity(in vec3 pos)\n{\n  //return QueryVolumetricDistanceField(pos) < 0.0 ? 1.0 : 0.0;\n  return clamp(-QueryVolumetricDistanceField(pos), 0.0, 0.5);\n}\n\n// 10 ops\nfloat massTransparency(float mass)\n{\n  return pow(0.9, mass*10.0);\n}\n\n// 10 ops\nfloat massOpacity(float mass)\n{\n  return 1.0 - pow(0.9, mass * 5.0);\n}\n\n// 20 calls to volume field\n// 14,000 ops\nfloat fastOpacityIntegral(vec3 ro, vec3 re)\n{\n  float intervalLength = length(ro-re);\n  vec3 rd = (re-ro) / intervalLength;\n  float stepLength = max(0.5, intervalLength / 20.0);\n  float totalMass = 0.0;\n  float d = 0.0;\n  vec3 pos = ro;\n  \n  do\n  {\n    float depth = QueryVolumetricDistanceField(pos);\n    if (depth > 2.0) break;\n    float thisStepLength = max(stepLength, depth);\n    //return massOpacity(clamp(-depth, 0.0, 5.0));\n    totalMass += thisStepLength * clamp(-depth, 0.0, 5.0);\n    d += thisStepLength;\n    pos += thisStepLength*rd;\n  } while (false && d < intervalLength && totalMass < 4.0);\n  return massOpacity(totalMass);\n}\n\n// (intervalLength/stepLength) calls to fogDensity, 700 ops per\n// up to 100ish in the far corners:\n// 100,000 ops\nfloat fastOpacityIntegral2(vec3 ro, vec3 re)\n{\n  float totalMass = 0.0;\n  const float stepLength = 1.0;\n  float fogDepth = max(0.0, QueryVolumetricDistanceField(ro));\n  // approximate integral as (distance into fog) * (fog density)\n  return fogDepth * clamp(fogDepth, 0.0, 1.0);\n  float intervalLength = length(ro-re);\n  vec3 rd = normalize(re-ro);\n  vec3 pos = ro;\n  for (int i = 0; i < int(floor(intervalLength / stepLength)); ++i)\n  {\n    totalMass += stepLength * fogDensity(pos);\n    pos += rd*stepLength;\n    //if (totalMass > -10.0) break;\n  }\n  return massOpacity(totalMass);\n}\n\n// 38 ops, 1 squaredSphereChordLength call, 1 massOpacity call\n// 63 ops\nfloat fastOpacityIntegral3(vec3 ro, vec3 re)\n{\n  float totalMass = 0.0;\n  float intervalLength = length(ro-re);\n  vec3 rd = (re-ro) / intervalLength;\n  vec3 pos = 0.5 * (ro+re);\n  // this is some bullshit\n  // just pretend the fog is a big sphere and calculate (squared) distance through it\n  \n  //totalMass = 0.0002 * intervalLength * squaredSphereChordLength(vec3(0.5, 0.5, 0.6)*pos - vec3(0,0,5), rd, 10.0);\n  return massOpacity(totalMass);\n}\n\n// 4 + 3*(3 + 10 + 11 + 8) ops\n// 100 ops, 3 calls to fastOpacityIntegral2\n// 300,000 ops\nvec4 calcLight(vec3 pos, vec3 norm)\n{\n  vec4 ambientLight = 0.3*vec4(1,1,1,0);\n  vec4 color = vec4(0,0,0,1);\n  for (int i = 0; i < 3; ++i)\n    {\n      OrbLightDescription light = GetLight(i);\n      vec3 toLight = light.pos - pos;\n      float dist = length(toLight);\n      float cosAngle = max(0.0, dot(toLight, norm)) / dist;\n      // use the more accurate opacity integral for the lighting that gets calculated once per pixel\n      color.rgb += light.color * cosAngle * 1.0/dist * (1.0 - fastOpacityIntegral(pos, light.pos));\n      //color.rgb += (cosAngle * 1.0/dist) * light.color;\n    }\n    return color + ambientLight;\n}\n\n// 100 ops, 3 calls to fastOpacityIntegral3\nvec4 calcLight(vec3 pos)\n{\n  vec4 ambientLight = 0.3*vec4(1,1,1,0);\n  vec4 color = vec4(0,0,0,1);\n  for (int i = 0; i < 3; ++i)\n    {\n      OrbLightDescription light = GetLight(i);\n      vec3 toLight = light.pos - pos;\n      float dist = length(toLight);\n      // this gets integrated over again anyway so who gives a shit\n      //color.rgb += light.color * 1.0/dist * (1.0 - fastOpacityIntegral3(light.pos, pos));\n      color.rgb += light.color * 1.0/dist * (1.0 - fastOpacityIntegral(pos, light.pos));\n      //color.rgb += light.color * 1.0/dist;\n    }\n    return color + ambientLight;\n}\n\n// 1000 ops, 100 calls to fogDensity, 100 calls to massOpacity, 100 calls to calcLight\n// 75,000 ops, 100 calls to calcLight(vec3)\ntransparentMarchResult marchThroughTransparent(vec3 ro, vec3 rd, float maxDepth, vec3 backgroundColor)\n{\n  vec3 color = vec3(0);\n  vec3 fogBaseColor = vec3(0.8);\n  float densityIntegral = 0.0;\n  //vec3 color = backgroundColor;\n  const float stepLength = 0.25;\n  float previousDensity = 0.0;\n  float density = 0.0;\n  float totalTransparency = 1.0;\n  vec3 pos = ro;\n  float maxStepsFloat = min(100.0, maxDepth / stepLength);\n  int maxSteps = int(maxStepsFloat);\n  float finalStep = min(stepLength, maxDepth - float(maxSteps)*stepLength);\n  for (int i = 0; i < maxSteps; ++i)\n  {\n    // could improve this by detecting when we're outside the fog\n    pos += stepLength*rd;\n    density = fogDensity(pos);\n    //float intervalMass = 0.5*stepLength*(previousDensity + density);\n    float intervalMass = 2.0*stepLength*(density);\n    //float intervalOpacity = massOpacity(intervalMass);\n    float intervalTransparency = massTransparency(intervalMass);\n    float prevTransparency = totalTransparency;\n    totalTransparency *= intervalTransparency;\n    float intervalWeight = prevTransparency - totalTransparency;\n    vec3 intervalColor = fogBaseColor * calcLight(pos).rgb;\n    color += intervalColor * intervalWeight;\n    \n    densityIntegral += intervalMass;\n    previousDensity = density;\n  }\n  pos += finalStep*rd;\n  density = fogDensity(pos);\n  //float intervalMass = 0.5*stepLength*(previousDensity + density);\n  float intervalMass = 2.0*finalStep*(density);\n  //float intervalOpacity = massOpacity(intervalMass);\n  float intervalTransparency = massTransparency(intervalMass);\n  float prevTransparency = totalTransparency;\n  totalTransparency *= intervalTransparency;\n  float intervalWeight = prevTransparency - totalTransparency;\n  vec3 intervalColor = fogBaseColor * calcLight(pos).rgb;\n  color += intervalColor * intervalWeight;\n  \n  densityIntegral += intervalMass;\n  previousDensity = density;\n  //color = mix(color, intervalColor, intervalOpacity);\n  //color = vec3(abs(pos.z));\n  //color = vec3(float(maxSteps) / 10.0);\n  \n  transparentMarchResult result;\n  result.opacity = 1.0 - totalTransparency;\n  result.color = vec4(color + backgroundColor*totalTransparency, 1);\n  // result.emission = vec4(0,0,0,0);\n  return result;\n}\n\n// called once per pixel = 810,000 times\n// some ops, one call to traceToOpaque, one call to calcLight(vec3, vec3), one call to marchToTransparent,\n// one call to marchThroughTransparent\n// 810k * (18 + 1 calcLight(vec3, vec3) + 40k + 75k + 100 calcLight(vec3))\n// 92G + 810k calcLight(vec3, vec3) + 81M calcLight(vec3)\n// i forgot that FMAs are a thing while calculating this fffffffuuuuuuuuuuuuuuuuuuuuuuuuuu\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) /iResolution.x;\n    \n    vec3 cameraPos = vec3(-70.0 * cos(0.5), 70.0*sin(0.5), 35.0);\n    vec3 cameraDirection = -normalize(cameraPos);\n    float nearPlane = 1.5;\n    vec3 cameraUp = vec3(0.0, 0.0, 1.0);\n    cameraUp = cameraUp - dot(cameraUp, cameraDirection) * cameraDirection;\n    vec3 cameraRight = cross(cameraDirection, cameraUp);\n    vec3 rd = normalize(nearPlane*cameraDirection + uv.x*cameraRight + uv.y*cameraUp);\n    \n    // draw background\n    fragColor = background(rd);\n    \n    // draw floor\n    marchResult floorRes = traceToOpaque(cameraPos, rd);\n    vec4 light = calcLight(floorRes.pos, floorRes.norm);\n    fragColor = mix(fragColor, floorRes.color * light, floorRes.inBounds);\n    \n    \n    // raymarch volumetric\n    marchResult marchRes = marchToTransparent(cameraPos, rd);\n    float maxDepth = floorRes.inBounds == 1.0 ? floorRes.depth - marchRes.depth : 100.0f;\n    transparentMarchResult transRes = marchThroughTransparent(marchRes.pos, rd, maxDepth, fragColor.rgb);\n    fragColor = transRes.color;\n    \n    //fragColor.rgb = vec3(fastOpacityIntegral(floorRes.pos, cameraPos));\n    //fragColor.rgb = vec3(-QueryVolumetricDistanceField(floorRes.pos));\n    \n    \n    //light = calcLight(marchRes.pos, marchRes.norm);\n    //surfColor *= light;\n    //surfColor.rgb = 0.5 + 0.5*marchRes.norm;\n    //fragColor = mix(fragColor, surfColor, transRes.opacity);\n    //fragColor.rgb = vec3(10.0 / maxDepth);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}