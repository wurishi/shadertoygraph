{"ver":"0.1","info":{"id":"wtKczh","date":"1610648055","viewed":296,"name":"Digging in the dirt","username":"kastorp","description":"simplified illumination experiment with voxels\nwork in progress...","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["illumination","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Destructible ED\" by kastorp. https://shadertoy.com/view/tttyRB\n// 2021-01-12 21:06:08\n\n/*\n---------------------------------------------------\nDigging in the Dirt  - by  KASTORP \n-------------------------------------------------------\nCONTROLS (based on as voxel game evolution):\n    drag mouse to move view and select blocks\n    WASD or arrows to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n    Z + mouse button to add dirt\n    X + mouse button to dig\t\n\n\tO,P to decrease/increase speed of day/night cycles   \n    k,L to decrease/increase pixel sizes \n    Page Up/Down to increase or decrease zoom \n\n//-----------------------------------------------------*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* ----------------------------------------------------------\n\tCONFIGURABLE SETTINGS\n//----------------------------------------------------------*/\n#define MAX_PICK_DISTANCE 200.\n#define OCCLUSION 1\n#define SHADOW 1.5\n#define FOG 20.\n#define LTORCH 20\n#define SURFACE 3.\n#define LOAD_TIME 40.\n#define TEXTURE 2\n#define SUBTEXTURE\n#define GI\n#define MIN_PIXELSIZE 2.\n#define MAX_PIXELSIZE 3.\n//#define XRAY_MODE\n\n//---------------------------\n//GLOBAL VARIABLES\n//----------------------------\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy)) \n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id / 8.)+2.)) / iChannelResolution[0].xy, 0.0)\n#define TS vec2(textureSize(iChannel3,0))\n\n//shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_B, 4, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);  \nvar(_renderScale, 9, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_rayDistMax,15,varRow);\nvar(_pixelSize,19,varRow);\nvar(_textureSize,25,varRow);\nvar(_old, 0, 1);  // previous value of each variable is stored at y=1\n\n//---------------------\n// BIT LEVEL FUNCTIONS\n//--------------------\n\n#define BITS 32.\n#define MAXUINT  0xFFFFFFFFu \n// pixel is a 128 bit mask (0-31 -> x, 32-63 -> y, 64-95 -> z, 96-127 -> w)\nuint getBit(inout uvec4 bm, uint i)\n{\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n       \n    return  (bm[bv]  &  (1u<<bi) )>0u?1u:0u;\n}\n\n//works only if n<=32u \nuint getBits(inout uvec4 bm, uint k, uint n){\n   \n    \n    uint bv = k/uint(BITS),  bi= k%uint(BITS);\n    if(n+bi<=32u){\n        //inside vec4 dimension\n        uint m = (1u<<n)-1u; \n        return (bm[bv] & (m<<bi) )>>bi;\n    }\n    else\n    {\n        //cross dimension\n        uint n1= 32u-bi, n2 = bi+n-32u;\n        uint m1 =(1u<<n1)-1u, m2= (1u<<n2)-1u;\n        return ((bm[bv] & (m1<<bi) )>>bi) \n             + ((bm[bv+1u] & m2 )<<n1);\n    }\n}\n\n// set bit value in a 128 bit mask \nvoid setBit(inout uvec4 bm, uint i, uint val){\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    bm[bv]  &= ( MAXUINT - (1u<<bi) );\n    if(val>0u)  bm[bv]  +=(1u<<bi);\n}\n\nvoid setBits(inout uvec4 bm, uint i, uint n, uint val){\n    val =clamp( val, 0u, (1u<<n)-1u) ;\n\n    uint bv = i/uint(BITS),  bi= i%uint(BITS);\n    if(n+bi<=32u){\n        bm[bv]  &= ( MAXUINT - (((1u<<n)-1u ) <<bi) );\n        bm[bv]  +=(val<<bi);\n    }\n    else\n    {\n        for(uint j=0u; j<n;j++) \n        {\n            uint b = (val  &  (1u<<j) )>0u?1u:0u;\n            setBit(bm, i+j, b);\n        }\n    }\n}\n//https://www.shadertoy.com/view/wtKyR1 by ttg\nvec4 b127_ieee754_encode (uvec4 v) {\n  v.w&=0x7FFFFFFFu;\n  uvec4 l = uvec4( v.xyz&0xFFFFFFu , v.x>>24 | v.y>>24<<8 | v.z>>24<<16 );\n  return uintBitsToFloat( (l&0x800000u)<<8 | l&0x7FFFFFu\n   | 1u+uvec4(v.w/uvec4(1,254,254*254,254*254*254))%254u <<23 );\n}\n\nuvec4 b127_ieee754_decode (vec4 f) {\n  uvec4 e = floatBitsToUint(f);\n  uvec4 l = (e&0x80000000u)>>8 | e&0x7FFFFFu;\n  uvec4 h = (e>>23&0xFFu)-1u;\n  return uvec4(\n    l.xyz | uvec3(l.w)>>uvec3(0,8,16)<<24,\n    h.x+254u*h.y+(254u*254u)*h.z+(254u*254u*254u)*h.w );\n}\n\n//------------------------\n// VOXEL CACHE FUNCTIONS\n//------------------------\nconst int  BUFFER_B = 1;\nconst vec2 packedChunkSize_B = vec2(13,7);\nconst float heightLimit_B = packedChunkSize_B.x * packedChunkSize_B.y;\nconst float N_SUBVOXEL=4.;\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat calcLoadDist_B(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_B); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_B(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_B(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n\n    vec2 packedChunkSize= packedChunkSize_B;\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n    vec2 packedChunkSize= packedChunkSize_B;\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    ivec2 light; //s=sun,t=other lights\n    int shape;\n    int buffer;\n    int damage;\n    uvec2 mask;\n     \n};\n\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    uvec4 iv =  b127_ieee754_decode(t);\n    o.id        = float(getBits(iv,0u,4u));    \n    o.light.s   = int(getBits(iv,9u, 4u) ); \n    o.light.t   = int(getBits(iv,4u, 5u));\n    o.shape     = int(getBits(iv,13u, 1u));\n    o.damage     = int(getBits(iv,14u, 2u));\n\n    o.mask      = uvec2(iv.yz);\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tuvec4 iv = uvec4(MAXUINT);\n    setBits(iv, 0u,4u,uint(v.id));\n    setBits(iv,9u,4u,uint(v.light.s));\n    setBits(iv,4u,5u,uint(v.light.t));\n    setBits(iv,13u,1u,uint(v.shape));    \n    setBits(iv,14u,2u,uint(v.damage));  \n   \n   \n\n    iv.yz=v.mask.xy;\n\n    return b127_ieee754_encode(iv);\n}\n\nint lightDefault(float z){\n\treturn z>50.?15:0;\n\n}\n\nvoxel newVox(float z){\n    voxel vox;\n\n    vox.shape=0;\n\tvox.id=0.;\n    vox.light.t = 0;\n    vox.light.s = lightDefault(z);\n \tvox.id=0.;\n    vox.damage=0;\n    vox.buffer=0;\n    vox.mask=uvec2(0u);\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    //return texelFetch(iChannel, ivec2(pos)  , 0); \n    return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);\n \n}\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p, bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\nfloat isSolidVoxel(voxel vox) {\n    \n    return (vox.id==0. || vox.id==12. )?0.:1.;\n}\n\n//-----------------------------------------\n// SDF FUNCTIONS\n//---------------------------------------\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) ;\n}\n\n\n//-----------------------------------------\n// HASH FUNCTIONS\n//---------------------------------------\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}    \n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)),\n         up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 mmin(vec2 a, vec2 b){return a.x<b.x?a:b;}\n//-----------------\n// WORLD GENERATION\n//------------------\nvec2 map(vec3 p) {\n\n    float d=p.z-85.-hash12(p.xy)*.5; \n    p.z-= hash12(floor((p.xy+10.)/20.))*10.;\n    p.xy= p.xy- floor((p.xy+10.) /20.)*20. ;\n    \n    \n   \n    d =max(d,-length(p-vec3(0,0,1))+4.+hash13(p)*2.);\n    d =max(d,-length(p.xy +3.*vec2(cos(p.z/2.),sin(p.z/2.)))+5. );\n    vec2 mm=vec2(d,d >=1. ?0.:p.z<2.?2.:hash13(p*3.1)<.1?4.:1.);\n    \n    mm=mmin(mm,vec2(sdBox(p-vec3(0,0,4),vec3(12,.2,.2)),15.));\n    \n    return mmin(mm, vec2(length(p-vec3(0,0,3.))-1.,4.));\n   \n}\n\n\nvoxel getGeneratedVoxel(vec3 c,bool detail,int frame){\n\n    \tvoxel vox=newVox(c.z);\n        vec2 m = map(c);\n        vox.id = m.y;\n       \n        if(m.x>0.) vox.id=0.;\n        vox.shape=1;\n        vox.mask=uvec2(MAXUINT);\n        \n        if(detail && m.x>-1.&& m.x<1.) \n        {   int n =0;\n            \n            uvec4 iv= uvec4(0u);\n            for(int k =min(0,frame); k<64;k++){\n                vec3 px= vec3(k%4,(k>>2)%4, k>>4)/4. -vec3(.375) +c;    \n                vec2 mx = map(px);\n                if(mx.x<0.){ \n                     setBit(iv,uint(k),1u);\n                     n++;\n                }\n            }\n            \n            if(n>0){\n             vox.shape=1;\n             vox.id=m.y;\n             vox.mask = iv.xy;\n            }else  vox.id=0.;\n        }\n          \n        if(c.z<=0.) vox.id=2.;\n        \n        return vox;\n\t\t\n}\n\n\n//------------------------------\n// MIX PROCEDURAL AND MEMORY VOXEL\n//------------------------------\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\n\nvoxel getVoxelData( vec3 voxelCoord,\n                    sampler2D iChannel_B,  \n                    int frame, \n                    vec3 resolution_B, \n                    vec4 range_B,\n                    vec3 offset,\n                    bool detail,\n                    int caller){\n\n    if (inRange(voxelCoord.xy,range_B) && frame > 0 && voxelCoord.z <heightLimit_B  && voxelCoord.z>0.\n        ) {\n        return getCachedVoxel(voxelCoord  - offset,iChannel_B,resolution_B,BUFFER_B); \n        \n    } \n      \n    return getGeneratedVoxel(voxelCoord,detail,frame);\n}\n#define getCVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n     v= getCachedVoxel(p-offset,iChannel1,iChannelResolution[1],1);}\n\n\n#define getVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    bool detail = id<3;\\\n    v= getVoxelData(p,iChannel1,iFrame,iChannelResolution[1],range_B,offset,detail,id);} \n    //detail || (float(iFrame) -load(_textureSize).z>LOAD_TIME  && load(_demo).r<1.)\n\n//------------------------\n// RAYMARCHING (voxel & subvoxel traversal)\n//------------------------\n\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n#ifdef SUBTEXTURE  \n    vec2 uv_txt;\n#endif    \n    float dist;\n    voxel vox;\n    float water;\n    vec3 color;\n    float fog;\n    uint k;\n\n};\n\n\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\nfloat VoxelStepDist(vec3 pos,vec3 mask, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini1 = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t1=  max ( mini1.x, max ( mini1.y, mini1.z ) );\n    vec3 mini2 = (pos-ro +mask*rs + 0.5 - 0.5*vec3(rs))*ri;\n    float t2=  max ( mini2.x, max ( mini2.y, mini2.z ) );\n    return t2-t1;\n}\n\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed,uvec2 mask){\n \n\trayCastResults  res;\n    \n    \n    vec3 c=vec3(.5);\n    float theta1= PI/2.*floor(mod(rotation,4.));\n    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta1,3)*rayDir; \n    float theta2= PI/2.*(floor(rotation/4.));\n    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta2,2)*rayDir; \n       \n     vec3 ro = (rayPosOrig) *N_SUBVOXEL;\n   \n\t//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);\n       \n\tvec3 ri = 1.0/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro-rayDir*0.002);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n       \n\tfor( int i=0; i<int(N_SUBVOXEL)*3; i++ ) \n    {\t\n              \n\t\tif(i>=0){\n       \t mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           \n        }\n         dis += mm * rs * ri;\n         pos += mm * rs;\n        \n        //BIT SUBVOXELS\n        if(shape==1){\n        \n            uvec3 up= uvec3(pos);\n            uint k = up.x +(up.y<<2)+ (up.z<<4 );\n            \n            uvec4 iv = uvec4(mask,0u,0u);\n            bool on = getBit(iv,uint(k))>0u;\n            if(on && sdBox( pos-vec3(1.5)  ,vec3(2.) )<.001 ) {res.hit=true;res.k=k;break;}\n        }           \n\t}\n\t\n\t\n    if(res.hit){\n        if( hash13(float(res.k)+seed+3.33)>.99 ) res.vox.id=6.;\n        res.normal = - mm*rs; \n        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);\n        res.dist=hitPos.a/N_SUBVOXEL;\n        vec3 xyz = hitPos.xyz - pos;\n        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );\n        if(abs(mm.x)>0.) res.uv=res.uv.yx; //invert xz \n        //relative to absolute normals:\n   \t\tres.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;\n    }\n    return res;  \n}\n\n\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType,\n  sampler2D iChannel0, sampler2D iChannel1, int iFrame, vec3[4] iChannelResolution, int callerId\n) {\n\t   \n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.; \n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        //MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n    \n#ifdef XRAY_MODE\n    voxel currentVoxel;\n    getVoxel( mapPos,currentVoxel,callerId);\n\tvec3 hitWater = (currentVoxel.id==12.? rayPos: vec3(0.));\n\n\tbool xRay=(currentVoxel.id!=0. && currentVoxel.id!=12.);\n#else\n    vec3 hitWater =  vec3(0.);\n    bool xRay=false;\n#endif    \n    \n    for (int i = 0; i < 300; i++) {\n\n        \n        if(i>0) mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        \n        \n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n        getVoxel( mapPos, vox ,callerId);\n      \n        if(vox.shape!=0 && vox.id!=0. ){ \n            //SUB VOXEL\n\n    \t\tvec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            \n            if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )<.001) hitVoxelPos=rayPos;\n            float rotation= 0.;//vox.rotation;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,rotation,mapPos,vox.mask);\n            if(subRes.hit && vox.id!=12.) { \t\t\n       \t\t \tres.hit = true; \n                if(subRes.vox.id!=0.) vox.id=subRes.vox.id;             \n                break;\n            }\n            else if(vox.id==12. && subRes.hit  && rayType!=3) { \n            \t//nothing to do Transparent\n            }\n            else {vox.id=0.;res.hit = false;}\n        }\n \n        //DISABLED...MIRROR\n        \n        if(vox.id==12.  ){ //vox.life < WATER && vox.life>0.){\n        \t//ENTERING WATER\n            if(hitWater.z<1.) {\n                \n                // deviate ray xy if intercept water NOT EXACT                \n    \t\t\tvec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                vec3 n=mask;\n                if(subRes.hit) {\n                    \tendRayPos+=rayDir * subRes.dist;                    \t\n                        n=subRes.normal;\n                }\n     \t\t\thitWater=endRayPos;\n                \n                //DISABLED... REFRACTION\n                               \n            }\n            subRes.hit=false;\n\n            continue;\n        }\n        \n        if( vox.id !=0. && vox.id!=26. && vox.id!=12. ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n        if(vox.light.s>12 && vox.id==0.) fog+= float(vox.light.s)/5.;//*VoxelStepDist(mapPos,mask ,rayPos,rayDir);\n        \n        //NO HIT\n        xRay=false; \n        if(hitWater.z>0. && vox.id==0.)  {waterDist +=length(hitWater-mapPos); hitWater=vec3(-1.);}\n        \n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n           \n   \n\t}\n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);\n    \n\n\n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>SURFACE) {vox.id = 0.; res.hit=false;}\n        else { vox.id=3.; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist = length(rayPos0 - res.rayPos);\n    res.vox=vox;\n    res.fog=fog;\n    res.water =waterDist;\n    //res.fog=fog;\n    \n    if(subRes.hit){\n        \n       \tres.normal=  subRes.normal; \n      \tmask=abs(subRes.normal);\n        res.rayPos += rayDir * subRes.dist ;\n        res.dist = length(rayPos - res.rayPos);\n        res.k=subRes.k;\n#ifdef SUBTEXTURE\n        // uv coordinates are relative to subvoxel (more detailed but aliased)\n    \tres.uv_txt = subRes.uv ;\n    \t//return res;\n#endif\n    }\n    \n    //uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n\n    return res;\n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\nvec4 sun(float t){\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n    ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//-------------------------\n// KEYBOARD FUNCTIONS\n//----------------------\n\n#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_SPRAY 90\n#define KEY_DIG 88\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\n//---------------------------\n//GLOBAL VARIABLE SETTERS\n//--------------------------\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getCVoxel(p,t,0);\n    return isSolidVoxel(t) * (!slope || t.shape!=1?1.:0.);\n    \n}\n\n\n\nrayCastResults  getRay(float type){\n       \n   vec4 ray=  texture(iChannel3, vec2(type,0.));\n   rayCastResults res;\n   res.hit = ray.a!=0.;\n   res.mapPos = ray.rgb;\n    \n   float eN = ray.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  \n   return res;\n}\n\n\n//---------------------\n// TEXTURE FUNCTIONS\n// --------------------\n\n\n//textures from https://www.shadertoy.com/view/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (32./255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { //NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n       \n        o.rgb =  vec3( 127./255., 127./255., 127./255.) *br;        \n    }\n    if (id == 2) { //DIRT\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n    }\n    if (id == 3) { //GRASS LATERAL\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb =  vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n    if (id == 4) { //GRASS UP  \t\t\n        o.rgb = vec3( 96./255., 157./255.,  59./255.)*br;\n    }\n\n    if (id == 6 ) {//YELLOW MATERIAL\n\n        o.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n        o.rgb*=.8;\n    }\n    //12=LASER (transparent) \n    \n    if (id == 13) {//GRAY \n\n\t\to.rgb= vec3(0.74,0.78,0.65);\n\t}\t\n\n    if (id == 15) {//PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n\n       \n\t}\n\n\n\n    \n}\n\n//----------------------------------------\n//  ACTIONS & TEXTURES\n//\n// x=0 && y<256: global variables update\n// x=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n// 1<=x<16 y<512: previous values fo variables and keys\n// x<= 128 && 16<=y< 140 : textures \n// \n//-------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<32.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,100.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n\n\t\t\t\tvec3 texSize=load(_textureSize).xyz;\n                    \n                if (iFrame <2  ) {\n                    pos = vec3(0.,-5.,1.);\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(1.2,1.3  );                                \n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -4.;\n                    time = vec2(149.5,0.);\n                    rayDistMax=150.;\n                    pixelSize=2.;\n                    texSize=vec3( TS, 0.);\n                }\n                \n                if(float(iFrame)-texSize.z >LOAD_TIME*.75 && float(iFrame)-texSize.z <LOAD_TIME*.75)  pixelSize=max(MAX_PIXELSIZE-1.,2.);\n                \n                if(float(iFrame)-texSize.z >LOAD_TIME && float(iFrame)-texSize.z <LOAD_TIME )  pixelSize=(TS.x<1025.?1.: MIN_PIXELSIZE);\n\n                \n                if(texSize.x != TS.x ) {\n                    texSize=vec3( TS, float(iFrame));\n                    pixelSize=max((TS.x<1025.?2.: MAX_PIXELSIZE),pixelSize);\n                }\n                \n                if (oldMouse.z > 0. && iMouse.z > 0.)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                //float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                //z of closest  blocks below\n                float minHeight = 0.; \n                \n                //z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                //XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                // rayCastResults posPointer = getRay(1.);\n                //if(posPointer.rayPos.z> 0. )  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                if(isSolidVoxel(false,pos-offset) >.5)  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                \n\n                //DOWN\n                \n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.01; \n                        \n                        break;\n                    }\n                }\n                \n               // minHeight = max(minHeight,posPointer.rayPos.z+1. );\n\t\t\t\t\n                //UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                         \n\n                }\n               \n                //LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n                        bool slope=j<2;\n                        solidL[i ] += isSolidVoxel(slope,hColPos - offset + vec3((i/2)*(j%2),(1-i/2)*(j%2),(j/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(   bool(keyToggled(KEY_STATS))?1.:0.,0.,0.);\n\n                \n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        //voxel t;\n                        //getCVoxel(pos -offset,t,0);\n                        //bool isWater=(t.id ==12.);\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                           \n                rayCastResults mousePointer = getRay(0.);\n\n                \n                //if (iMouse.z > 0. ) {                    \n                    \n\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n   \n                        if (bool(keyDown(KEY_SPRAY))) {\n                            pick.a = 3.;\n                            pick.xyz -= mousePointer.normal*.125;\n                            //timer += dt / 0.25;\n                        }\n                        if (bool(keyDown(KEY_DIG))) {\n                            pick.a = 4.;\n                            pick.xyz += mousePointer.normal*.25;\n                        }\n \n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        \n                        timer = 0.;\n                    }\n                \n                //}\n \n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1. ;               \n                if(!still){\n                    texSize.z=max(texSize.z,float(iFrame)-LOAD_TIME*.8);\n                    pixelSize=max((TS.x<1025.?2.: MAX_PIXELSIZE),pixelSize);\n                }\n                \n          \n                store3(_pos, pos);\n                store2(_angle, angle);       \n                store4(_loadRange_B,calcLoadRange_B(pos.xy,iChannelResolution[1].xy,0.));\n                store4(_mouse, mouse);               \n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);                \n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store1(_rayDistMax, rayDistMax);              \n                store1(_pixelSize,pixelSize);               \n                store3(_textureSize,texSize);               \n                fragColor = outValue;\n            }\n        }  \n        else fragColor = texture(iChannel0, (fragCoord - _old) / iChannelResolution[0].xy);\n    }\n    else setTexture(fragColor,fragCoord);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//-----------------------------------\n// VOXEL BUFFER\n//-----------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_B); \n\n    vec4 newRange= calcLoadRange_B(offset.xy,iChannelResolution[1].xy,0.);\n    \n    if(!inRange(voxelCoord.xy, newRange)) {discard;}\n    \n    vec4 pick = load(_pick);   \n\n    voxel vox ; \n    getVoxel( voxelCoord,vox,1);\n    if(vox.mask==uvec2(0u)) vox.id=0.;\n    \n    if(vox.id==12.  ) vox.id=0.;\n    vec2 angle = load(_angle).xy;\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0) *2.;\n    //vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n    \n    float d = sdCapsule(voxelCoord +.5,pick.xyz,load(_pos).xyz+cameraPlaneU);\n    d=min(d,sdCapsule(voxelCoord +.5,pick.xyz,load(_pos).xyz-cameraPlaneU));\n    //float d =udTriangle(voxelCoord +.5, pick.xyz , load(_old+_pick).xyz, load(_pos).xyz+vec3(0,0,4.6));\n    \n    //DIRT\n    if( pick.a == 3. && length(voxelCoord +.5 - pick.xyz)<2.  ) \n     {        \n         int n=0;\n         uvec4 iv= vox.shape==1?uvec4(vox.mask,0u,0u):vox.id!=0.?uvec4(MAXUINT):uvec4(0u);\n         for(int k =min(0,iFrame); k<64;k++){\n            vec3 px= voxelCoord+ vec3(k%4,(k>>2)%4, k>>4)/4. +vec3(.125);    \n            if(length(px- pick.xyz )<.4){ \n                 setBit(iv,uint(k),1u); n++;               \n            }\n         }\n         if(n>0) {  \n             vox.shape=1;\n             vox.mask = iv.xy;\n             vox.id = 4.;\n             \n         } \n         vox.damage=0;\n     }\n     //DIG\n    if( pick.a == 4. && d<2.  ) \n     {        \n         int n1=0,n2=0;\n         uvec4 iv= vox.shape==1?uvec4(vox.mask,0u,0u):vox.id!=0.?uvec4(MAXUINT):uvec4(0u);\n         for(int k =min(0,iFrame); k<64;k++){\n            vec3 px= voxelCoord+ vec3(k%4,(k>>2)%4, k>>4)/4. +vec3(.125); \n            \n            float d2 =sdCapsule(px, pick.xyz ,  load(_pos).xyz+cameraPlaneU);\n            d2= min(d2,d2 =sdCapsule(px, pick.xyz ,  load(_pos).xyz-cameraPlaneU));\n            //float d2 =udTriangle(px, pick.xyz , load(_old+_pick).xyz, load(_pos).xyz+vec3(0,0,4.6));\n            \n            \n            if(d2<1.1-(vox.id==4.?.7:0.)){\n      \n                 setBit(iv,uint(k), 0u);\n                 n1++;               \n            }\n            if(d2<.2 && vox.id==0.){\n      \n                 setBit(iv,uint(k),1u);\n                 n2++;               \n            }\n         }\n         \n         if(n1>0 ) {  \n             vox.shape=1;\n             vox.mask = iv.xy;\n                       \n             if(vox.id!=0.)vox.id = 2.;\n             vox.damage=1;\n         } \n         if(n2>0 )  {  \n             vox.shape=1;\n             vox.mask = iv.xy;\n             vox.light.t=15;\n             vox.id = 12.;\n             vox.damage=3;\n         } \n     \n         \n     }    \n\n   \t// SUN LIGHT SOURCES   \n    \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15;   \n    } else  {\n        vox.light.s=0; //correct but initial value is better oon surface\n        //vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    // TORCH LIGHT SOURCES\n     if(vox.id==4.) vox.light.t=14;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1:0),0,LTORCH);\n        \n    \n    int air=0;\n    voxel temp;  \n    voxel next[9];\n    for(int j=0;j<=1;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n      \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,1 );           \n    \t\tnext[i+3*j]= temp;\n            \n            \n            \n            if(voxelCoord.z> 80.) {vox.light.s=15;vox.light.t=0;}\n            else // lightDiffusion(vox,temp,n);\n                vox.light.t =  max( vox.light.t,   temp.light.t - (vox.id==0.?5: vox.shape==1 ? 7:15)); \n                \n                if(vox.id==0.)   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  - (vox.id==0.?2: vox.shape==1 ? 10:15));       \t\n\n            \n            if(temp.id==0. || temp.id==12. ) air++;\n        }\n    }\n#ifdef GI\n    bool airSample = vox.id==0. ;//&& length(fract(voxelCoord/2.))<0.1; //one every 8\n     if(air>0 && (air<6 || vox.id!=0. || airSample)){\n      \n        //VOXEL SHADOW\n        vec3 old_offset = floor(vec3(load(  _old  +_pos).xy, 0.));\n        vec4 range_B= calcLoadRange_B(old_offset.xy,iChannelResolution[1].xy,0.);\n        vec3 sunDir = sun( load(_time).r).xyz; sunDir *= sign(sunDir.z);        \n        vec3 ro=voxelCoord  + vec3(.5) + sunDir*(vox.id!=0.?1.:0.);\n        int rt=2;\n            \n    \trayCastResults res =rayCast(ro, sunDir,100,range_B,2, iChannel0,  iChannel1,  iFrame, iChannelResolution,4 );\n        vox.light.s= (res.hit )?  int( exp(-1.+ res.dist/55.)*15.):15;\n\n     }//else vox.light.s= 11;\n#else\n     vox.light.s= 15;\n#endif     \n     if(vox.id==2.) vox.id= (air==6?0.:vox.id);\n     \n     if(vox.id==0. || ( vox.mask==uvec2(0u) &&  vox.shape==1)) { \n              vox.id=0.; vox.shape=0; vox.mask =uvec2(0u);\n         }\n         \n    fragColor = encodeVoxel(vox);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//------------------------\n// RENDERING \n//------------------------\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\t//return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12.  ? 1. :0.;\n}\n\n#define SUBOCCLUSION\n\nvec4 calcOcclusion(vec3 r,vec3 n, vec2 uv,voxel vox,uint k) {\n#if OCCLUSION!=1\n    return vec4(vox.light , .75,0);\n#else \n \t//tangents:\n    vec3 s =abs(dot(n,vec3(0,0,1)))>.99 ? vec3(0,n.z,0):abs(cross(n,vec3(0,0,1)));\n    vec3 t = abs(cross(s,n));\n    vec3 px= vec3(k%4u,(k>>2u)%4u, k>>4u)/4. +vec3(.125);\n  \n   //neightbours vector\n   //v[0],v[1],v[2]\n   //v[3],v[4],v[5]\n   //v[6],v[7],v[8]\n   voxel v[9]; \n   float op[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1  ; j++) { \n            int m =4+ i+3*j +min(iFrame,0);\n            \n            vec3 npos=r  +((vox.shape==1   && floor(r+px +n*.25)== floor(r+px) ?vec3(0):n )+ s* float(i)+t*float(j));\n             getVoxel(npos,v[m ] ,3 );                         \n             op[m]=opaque(v[m].id);                 \n        }\n    }\n    vec2 lightm=vec2(vox.light);\n\n    float da[4], dam=0.;\n \tvec2 light[4];\n    for(int i=0;i<=3;i++){\n        \n        ivec4 ids;\n        if(i==0) ids=ivec4(6,7,3,4);\n        if(i==1) ids=ivec4(7,8,4,5);\n        if(i==2) ids=ivec4(3,4,0,1);\n        if(i==3) ids=ivec4(4,5,1,2);\n    \tlight[i +min(iFrame,0)] =vec2(  max(max(v[ids.x].light, v[ids.y].light), max(v[ids.z].light, v[ids.w].light)));\n        da[i +min(iFrame,0)] =float(  max(max(v[ids.x].damage, v[ids.y].damage), max(v[ids.z].damage, v[ids.w].damage)));\n    }\n    lightm = mix(mix(light[2], light[3], uv.x), mix(light[0], light[1], uv.x), uv.y);\n     //if(opaque(v[4].id)>0.) lightm= vec2(v[4].light) ;         \n    dam = mix(mix(da[2], da[3], floor(uv.x*4.)/4.+.125), mix(da[0], da[1], floor(uv.x*4.)/4.+.125), floor(uv.y*4.)/4.+.125);   \n\n\n#ifdef SUBOCCLUSION\n   if(vox.shape==1){\n       for (int i =-1; i <=1; i++) {\n            for (int j =-1; j <=1  ; j++) {\n                int m =4+ i+3*j +min(iFrame,0);\n                \n                vec3 npos= r+px + (n +s* float(i)+t*float(j))*.25; \n\n                voxel nvox= vox;\n                bvec3  outside= bvec3(\n                    floor(r+px + n*.25)!= floor(r+px),\n                    floor(r+px+ s* float(i)*.25)!= floor(r+px),\n                    floor(r+px+t*float(j)*.25)!= floor(r+px));\n\n                if(any(outside) ) nvox = v[4+ (outside.y?i:0)  +(outside.z? 3*j:0)]; \n\n                uvec4 iv =  nvox.shape==1?uvec4(nvox.mask,0u,0u):uvec4(MAXUINT);            \n                uvec3 up= uvec3(fract(npos)*4.);\n                uint kb = up.x +(up.y<<2)+ (up.z<<4 );                                  \n                bool on = getBit(iv,uint(kb))>0u ;\n                op[m]= on?opaque(nvox.id):0.;\n            }\n        }  \n\n        uv=fract(uv*4.);\n    }\n#endif   \n\n    float aom, ao[4];\n    for(int i=0;i<=3 ;i++){\n\n        ivec3 ids;\n        if(i==0) ids=ivec3(7,3,6);\n        if(i==1) ids=ivec3(7,5,8);\n        if(i==2) ids=ivec3(1,3,0);          \n        if(i==3) ids=ivec3(1,5,2);;\n        ao[i] = vertexAo(op[ids.x], op[ids.y], op[ids.z]);\n    }\n\n    aom = mix(mix(ao[2], ao[3], uv.x), mix(ao[0], ao[1], uv.x), uv.y);\n    aom *= .9+ n.z*.1;\n    \n    \n    return vec4(lightm , aom,dam);\n#endif    \n\n    \n}\n\n\n\nvec3 skyColor(vec3 rayDir,bool showsun) {\n    \n    vec4 s= sun( load(_time).r);\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir))*smoothstep(.0, 0.3, dot(rayDir, vec3(0,0,1)));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir))*smoothstep(.0, 0.3, dot(rayDir, vec3(0,0,1)));;\n    if(!showsun) {sunVis=0.;moonVis=0.;}\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\nvoid getColor(inout rayCastResults res,vec3 rayDir,int rayType)\n{\n    if(res.hit ){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;\n#ifdef SUBTEXTURE                \n        if(res.vox.shape!=0) uv_txt= res.uv_txt;\n#endif               \n\n#ifdef TEXTURE\n#if TEXTURE>1        \n        vec3 col=vec3(0.);\n        for(int i= min(iFrame,0);i<TEXTURE;i++) {\n            float d = min(.007 * res.dist,1.);           \n            vec2 uv = clamp(uv_txt + d* (hash33(res.rayPos*3.22 +float(i)*1.).xy-.5),0.01,.99);\n    \t\tcol += getTexture(textureId, uv).rgb;\n        }\n        res.color=col/float(TEXTURE);\n#else\n        res.color = getTexture(textureId, uv_txt).rgb;\n#endif \n#else        \n        res.color = getTexture(textureId, vec2(0.)).rgb;\n#endif        \n        \n    } \n    if(!res.hit){   \t\n         res.color = skyColor(rayDir,true);\n        if(rayType>=3) res.hit=true;\n    }\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n    float ll=lightLevelCurve(load(_time).r);\n    return clamp( mix(vec3(0), \n                  mix(vec3(0.11, 0.11, 0.21),vec3(1.), ll ),pow(.8,  light.s))\n                + mix(vec3(0), vec3(1., .9, .5), pow(.75, (.8+ll*.4)* float(light.t)*15./float(LTORCH))\n            ),0., 1.);   \n\n}\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec3 old_offset = floor(vec3(load(_old+_pos).xy, 0.));\n\n    vec4 range_B= calcLoadRange_B(old_offset.xy,iChannelResolution[1].xy,0.);\n\n    vec3 sunDir = sun( load(_time).r).xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;//0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_B,rt,\n          iChannel0,  iChannel1,  iFrame, iChannelResolution,3\n        \n        );\n        getColor(rays[i],rd,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<=.0 ) break;//|| rays[i].vox.buffer==1) break;\n        ro=rays[i].rayPos +rays[i].normal*0.01;\n        rd=sunDir;\n        maxRayDist= 120;\n        rt=2;\n            \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    if(res.mapPos.z>= heightLimit_B)res.fog=110.;\n    \n    if (res.hit ) {\n        \t\t\n        //float shadow =mix(rays[1].hit  ?exp( -res.dist/40.):0.  ,SHADOW, 1.- pow(abs(dot(sunDir,vec3(0.,0.,1.))),.3)) ;\n        float shadow =mix(rays[1].hit  ?SHADOW:0.  ,SHADOW, 1.- pow(abs(dot(sunDir,vec3(0.,0.,1.))),.3)) ;\n        color=res.color;\n\n\n        if(rayType==1 ){\n            // vec3 px= res.vox.shape==1  ?vec3(res.k%4u,(res.k>>2u)%4u, res.k>>4u)/4. +vec3(.125) :vec3(0.);\n            vec4 occ=calcOcclusion(res.mapPos, res.normal, res.uv,res.vox,res.k);\n            color =mix(color, vec3(.3,.2,.1),occ.w*.3);\n            color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z; \n        \n            \n           \n        }\n       \n    }\n    \n    color =mix( color, skyColor(rayDir,false),clamp(exp(-1.+(res.fog*(.7+.3*dot(rayDir,sunDir))-FOG)/FOG),0.,1.));\n     \n    vec3 wcolor= vec3(1.,1.,.0) ;\n    if(res.water>0.) {\n        \n        \n        color = mix(color,wcolor,exp(-(res.dist-res.water)/res.dist));//exp(res.water));\n    }\n    \n     // SELECTION AND MOUSE OVER\n    vec4 pick = load(_pick);\n    if (floor(res.mapPos) ==floor(pick.xyz) ) {\n        if(res.vox.shape==1 && length(fract(pick.xyz) -vec3(res.k%4u,(res.k>>2u)%4u, res.k>>4u)/4. -vec3(.125)  )<.125 ) color = mix(color, vec3(1,0,0), 0.8);       \n        else if(!res.hit) color = mix(color, vec3(0,1,0), 0.5);  \n        else color = mix(color,vec3(0,1,0), 0.2);\n    }   \n    //if(res.mirror) color *= vec3(.9,.5,.5);\n    \n    \n    fragColor.rgb = color; //pow(color, vec3(1.));\n    \n    if(rayType>=3 ) {\n        vec3 px= res.vox.shape==1  ?vec3(res.k%4u,(res.k>>2u)%4u, res.k>>4u)/4. +vec3(.125) :vec3(0.); \n        float encodeNormal=14.+ res.normal.x + res.normal.y*3. + res.normal.z*9.;\n        fragColor=vec4(floor(res.mapPos) +px,(res.hit && res.dist >0.5 && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n   \n    //DEBUG:\n    //fragColor=vec4( vec2(1.- res.dist /50.),  res.hit?1.:0.,1.);\n    //fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    //fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    //if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life/255.,1.);\n}\n\n\n#define FISHEYE 0.\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n    float fish = 1.0 - dot(uv, uv) * FISHEYE;\n\treturn normalize(cameraDir*fish + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return; //skip if pixelsize>1 and outside rendering area\n    }\n      \n    int  rayType = fragCoord.x<2. &&fragCoord.y<1. ? fragCoord.x<1.?3:4:1;\n    \n    float zoom = pow(10., load(_renderScale).r/10.)/(rayType==3? 1.:pixelSize);\n    renderResolution = iResolution.xy *zoom;\n    vec2 renderCenter=vec2(0.5);\n    vec2 uv = rayType>=3?  iMouse.x==0. || rayType==4?\n        (iChannelResolution[3].xy/2.- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize):\n        (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom):\n        (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);                 \n\n    \n   vec3  cameraPos = load(_pos).xyz + vec3(0,0,1.6),   \n         cameraDir = rayType==4?vec3(0,0,-1):rayDirection(load(_angle).xy,uv,renderResolution);\n    \n    \n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n    float loading= float(iFrame) -load(_textureSize).z;\n    //if(loading>LOAD_TIME +2.) fragColor=mix(fragColor,texture(iChannel3, fragCoord/iChannelResolution[3].xy ),.2);\n    if(loading<LOAD_TIME   && fragCoord.y <1. && fragCoord.x >2.  ) fragColor=vec4(1.);\n     \n\n}","name":"Buffer D","description":"","type":"buffer"}]}