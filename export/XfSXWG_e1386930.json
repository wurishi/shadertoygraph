{"ver":"0.1","info":{"id":"XfSXWG","date":"1716138929","viewed":77,"name":"GlassWork I","username":"pedrogzb","description":" ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["glass","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Poner el valor a 1 si se quiere habilitar el ratón\n#define HABILITAR_RATON 0 \n\n#define PI1D2 1.570796\n#define PI1D1 3.141592\n#define PI3D2 4.712388\n#define PI2D1 6.283185\n#define PI5D2 7.853981\n\n#define MAX_ITER 1500\n#define MIN_DIST 0.001\n#define MAX_DIST 70.\n#define MAX_REFLEX_REFRACT 15.\n\nfloat sdfSphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat sdfBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 offset_camino(){\n    float f = 3.75;\n    float t = mod(iTime,4.*f);\n    vec2 signo  = vec2( 0,0);\n    float vel = t/f; //un tramo cada 5 segundos\n          if(t < 1.*f){\n        signo  = vec2( 1, 1);\n        vel *= PI3D2;\n    }else if(t < 2.*f){\n        signo  = vec2( 1,-1);\n        vel *= PI5D2;\n        vel += PI1D1;\n    }else if(t < 3.*f){\n        signo  = vec2(-1,-1);\n        vel *= PI3D2;\n        vel += PI1D1;\n    }else{\n        signo  = vec2(-1, 1);\n        vel *= PI5D2;\n    }\n\n    vec2 circun = 1.8*vec2(-cos(vel),sin(vel));\n    vec3 p = vec3(signo.x*(1.8+circun.x),.5,signo.y*(1.8+circun.y));\n    return p;\n}\nfloat map(vec3 p, out int MAT_ID){\n    \n    float d1 = sdfBox(p-vec3(.0,-1.,.0), vec3(1.8,.1,1.8))-.2;\n    d1 = min(sdfBox(p-vec3(-1.7,0.,-1.7),vec3(.1,1.,.1))-.2,d1);\n    d1 = min(sdfBox(p-vec3( 1.7,0.,-1.7),vec3(.1,1.,.1))-.2,d1);\n    d1 = min(sdfBox(p-vec3(-1.7,0., 1.7),vec3(.1,1.,.1))-.2,d1);\n    d1 = min(sdfBox(p-vec3( 1.7,0., 1.7),vec3(.1,1.,.1))-.2,d1);\n    \n    vec3 pos = p - offset_camino();\n    \n    float d2 = sdfSphere(pos,0.8);\n    float d = min(d1,d2);\n    MAT_ID = (d > MIN_DIST)?0 : (d == d1)? 1:2;\n    return d;\n}\nvec3 calcNormal(vec3 pos){\n    vec2 e = vec2(1e-3,0.);\n    int ID;\n    return vec3(map(pos+e.xyy,ID)-map(pos-e.xyy,ID),\n                map(pos+e.yxy,ID)-map(pos-e.yxy,ID),\n                map(pos+e.yyx,ID)-map(pos-e.yyx,ID));\n}\nvec3 GetCamDir(vec2 p, vec3 ro, vec3 lookat,float FOV){\n    vec3 cam_z = normalize(ro-lookat);\n    vec3 cam_x = cross(cam_z,vec3(0,1,0));\n    vec3 cam_y = cross(cam_x,cam_z);\n    \n    return normalize(p.x*cam_x + p.y*cam_y -FOV*cam_z);\n} \nfloat RayMarch(vec3 ro, vec3 rd, out int ID,float side){\n    float h = 0.;\n    vec3 pos;\n    for(int i = 0; i < MAX_ITER; i++){\n        pos = ro + h * rd;\n        float d = map(pos,ID)*side;\n        h += d;\n        if(d < MIN_DIST || h > MAX_DIST) break;\n    }\n    return h;\n}\nvec3 GetColor(inout vec3 ro,inout vec3 rd,inout vec3 reflex){\n    vec3 col = vec3(0.);\n    int ID;\n    float h = RayMarch(ro,rd,ID,1.0);  \n    \n    vec3 light_dir = normalize(vec3(-.3,.3,.2));\n    vec3 dif_light = .04*vec3(.8,.7,.1);\n    \n    vec3 pos  = ro + h*rd;\n    vec3 norm = normalize(calcNormal(pos));\n    \n    float specular = mix(0.3,1.,clamp(dot(norm,light_dir),0.,1.));\n    /*Calculo por ID*/\n          if(ID == 0){//textura de fondo\n        col = texture(iChannel0,rd).rgb;  \n        reflex = vec3(0);\n    }else if(ID == 1){//material metalico\n        reflex *= vec3(0.3);\n        col = specular*vec3(2,0,65)/255.+dif_light;\n        ro = pos + norm*MIN_DIST*3.;\n        rd = reflect(rd,norm);\n    }else if(ID == 2){//material cristal\n        float IOR = 1.85;\n        col = 0.1*(specular*vec3(2,69,65)/255.+dif_light); \n        \n        vec3 rdIn = refract(rd,norm, 1./IOR);\n        vec3 pEnter = pos - norm*MIN_DIST*3.;\n        float dIn = RayMarch(pEnter,rdIn,ID,-1.);\n        vec3 pOut = pEnter + dIn*rdIn;\n        vec3 nOut = -normalize(calcNormal(pOut));\n        vec3 rdOut = refract(rdIn,nOut,IOR);\n        if(length(rdOut) == 0.){\n            rdOut = reflect(rdIn,nOut);\n            reflex *= vec3(.5);\n        }\n        ro = pOut - nOut*MIN_DIST*3.;\n        rd = rdOut;        \n    }\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    #if HABILITAR_RATON \n    vec2 M = (iMouse.xy/iResolution.xy);\n    #else\n    vec2 M = vec2(iTime*0.1,cos(iTime)*0.5+0.5);\n    #endif\n    float zoom = 3.;\n    float cosa = zoom * cos(M.x*PI2D1);\n    float sina = zoom * sin(M.x*PI2D1);\n    \n\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(sina,4.*M.y,cosa);\n    vec3 lookat = vec3(0,0.,0);\n    vec3 rd = GetCamDir(p,ro,lookat,0.4);\n\n    vec3 reflex=vec3(1.);\n    col = GetColor(ro,rd,reflex);\n\n    for(float i = 0.; i < MAX_REFLEX_REFRACT;++i){\n        if(reflex == vec3(0))break;\n        col += reflex*GetColor(ro,rd,reflex);\n    }\n    \n    // Corrección gamma\n    \n    col = pow(col,vec3(.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}