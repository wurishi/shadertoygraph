{"ver":"0.1","info":{"id":"sttyWj","date":"1660592576","viewed":185,"name":"Extreme Refraction","username":"pb","description":"fooling around","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ro,rd,pp;\nmat3 rot;\nvec3 light;\n\nmat3 rot_xz_xy(float a1, float a2) {\n    //rotation matrices - can't live with'em, can't live without'em\n    //even the rodrigues formula is a matrix in the end...\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n                     \n    return mat3( c2*c1, s2, c2*s1,\n                -s2*c1, c2, -s2*s1,\n                  -s1,   0.,  c1 );\n}\n\nfloat dist_func01(vec3 p) {\n\n    p = rot*p;\n    \n    p = mod(p-3.,6.)-3.;\n\n    pp = p;\n    return length(p) - .4;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .001 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n    float reverse = -1.;\n    float  rf = 2.;  // rf > 1.  causes rays to diverge behind lens\n    \n    float tt = mod(iTime,20.);\n    if ( tt > 10. ) reverse = 1.;  //reverses the normal used for refraction\n    \n    if      ( tt <  5. ) rf = 2.;   \n    else if ( tt < 10. ) rf = .9;  //rf < 1. cause rays to converge behind lens\n    else if ( tt < 15. ) rf = 2.;\n    else                 rf = .9;\n    \n    light = normalize( vec3( .5, 0., -1.) ) ;\n    xy = (2.*xy - iResolution.xy) / iResolution.y;\n    \n    ro = vec3(0.,0.,-2.5);\n    rd = normalize( vec3(xy,1.8) );\n    \n    vec3 p = ro;\n    \n    rot = rot_xz_xy(iTime/5.,iTime/3.);\n    \n    \n    float n=0.,dist,threshold=1e-4,totdist=0.;\n    vec3 color=vec3(0.);\n    for(;n<20.;n++) {\n        \n        dist = dist_func01(p);\n        if ( dist < threshold) {\n            color+=vec3(.3,.5,.8);\n            vec3 nn = gradient(p+dist*rd);\n           \n            color *= max(0.,dot(nn,light));\n            \n            break;\n \n        }\n        p += dist * rd;\n        totdist += dist;\n \n        if ( abs( length(p.xy) - .4) < .6) {\n            rd =  refract( rd, vec3(0.,0.,reverse*1.), rf);  //change ray direction\n            //rd =  reflect( rd, -vec3(0.,0.,reverse*1.) );\n            p +=  .8*rd;   //advance ray past refractive material\n            color.r += .9;\n            color.g += .3;\n            \n        }\n    }\n    \n    color *= exp(-totdist*totdist/600.);\n    \n    rgba = vec4(color,1.);\n    \n}","name":"Image","description":"","type":"image"}]}