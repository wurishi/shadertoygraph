{"ver":"0.1","info":{"id":"cs3cDN","date":"1695051675","viewed":50,"name":"Gradient field of Flow Noise","username":"jaolejnik","description":"This is a visualisation of a single octave Flow Noise (Perlin Noise with rotating gradients). \n\nHold the Left Mouse Button to see how the directions of gradients impact the value of generated noise.\nRed    -   Negative Values\nGreen -   Positive values","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlinnoise","flownoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Learning resources:\n// https://adrianb.io/2014/08/09/perlinnoise.html\n// https://youtu.be/7fd331zsie0\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;\n\n// random number generator adapted from:\n// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\nuint wangHash(inout uint seed)\n{\n    seed = uint(seed ^ 61u)^ uint(seed >> 16u);\n    seed *= uint(9);\n    seed = seed ^(seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^(seed >> 15);\n    return seed;\n}\n\nfloat random(in uint state)\n{\n    return float(wangHash(state)) / 4294967296.0;\n}\n\nvec2 randomGradient(in vec2 p)\n{\n    uint state = uint(uint(p.x) * 1973u + uint(p.y) * 9277u);\n    float theta = random(state) * TWO_PI;\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 randomGradientAnimated(in vec2 p)\n{\n    uint state = uint(uint(p.x) * 1973u + uint(p.y) * 9277u);\n    float rotationSpeed = 0.5 + iTime * (random(state) * 2.0 - 1.0);\n    float theta = random(state) * TWO_PI + rotationSpeed;\n    return vec2(cos(theta), sin(theta));\n}\n\n// iq's arrow SDF\n// https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow(in vec2 p, in vec2 a, in vec2 b, in float w1, in float w2)\n{\n    // constant setup\n    const float k = 3.0; // arrow head ratio\n    vec2 ba = b - a;\n    float l2 = dot(ba, ba);\n    float l = sqrt(l2);\n    \n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x, - ba.y, ba.y, ba.x) * p / l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l - w2 * k, w2);\n    \n    // === distance (four segments) ===\n    \n    vec2 q = p;\n    q.x -= clamp(q.x, 0.0, l - w2 * k);\n    q.y -= w1;\n    float di = dot(q, q);\n    //----\n    q = pz;\n    q.y -= clamp(q.y, w1 - w2, 0.0);\n    di = min(di, dot(q, q));\n    //----\n    if (p.x < w1)// conditional is optional\n    {\n        q = p;\n        q.y -= clamp(q.y, 0.0, w1);\n        di = min(di, dot(q, q));\n    }\n    //----\n    if (pz.x > 0.0)// conditional is optional\n    {\n        q = pz;\n        q -= vec2(k, - 1.0) * clamp((q.x * k-q.y) / (k * k+1.0), 0.0, w2);\n        di = min(di, dot(q, q));\n    }\n    \n    // === sign ===\n    \n    float si = 1.0;\n    float z = l - p.x;\n    if (min(p.x, z) > 0.0)//if( p.x>0.0 && z>0.0 )\n    {\n        float h = (pz.x < 0.0) ? w1 : z / k;\n        if (p.y < h)si = -1.0;\n    }\n    return si * sqrt(di);\n}\n\nfloat biLerp(in vec4 values, in vec2 weights)\n{\n    float a = mix(values.x, values.y, weights.x);\n    float b = mix(values.z, values.w, weights.x);\n    \n    return mix(a, b, weights.y);\n}\n\nfloat quintic(in float edge0, in float edge1, in float x)\n{\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * t * (6.0 * t * t - 15.0 * t + 10.0);\n}\n\nvec2 quintic(in float edge0, in float edge1, in vec2 p)\n{\n    return vec2(quintic(edge0, edge1, p.x), quintic(edge0, edge1, p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float frequency = 3.94;\n    \n    vec2 gridCell = uv * frequency;\n    vec2 gridId = floor(gridCell);\n    vec2 gridUv = fract(gridCell);\n    \n    vec4 samples;\n    vec2 cornerOffsets[4];\n    cornerOffsets[0] = vec2(0.0, 0.0);\n    cornerOffsets[1] = vec2(1.0, 0.0);\n    cornerOffsets[2] = vec2(0.0, 1.0);\n    cornerOffsets[3] = vec2(1.0, 1.0);\n    \n    float d = 1e20;\n    for(int i = 0; i < 4; ++ i)\n    {\n        vec2 c = gridId + cornerOffsets[i];\n        vec2 v = randomGradientAnimated(c);\n        vec2 dp = gridUv - cornerOffsets[i];\n        samples[i] = dot(v, dp);\n        \n        d = min(d, sdArrow(gridCell, c + 0.01, c + v, 0.005, 0.01));\n    }\n    \n    vec2 w = quintic(0.0, 1.0, gridUv);\n    float perlin = biLerp(samples, w);\n    \n    vec3 color = vec3((perlin + 1.0) / 2.0);\n    \n    \n    if( iMouse.z > 0.001 )\n    {\n        color = vec3(abs(perlin));\n        color *= perlin < 0.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n        color = min(gridUv.x, gridUv.y) < 0.01 ? vec3(1.0) : color;\n        color = mix(vec3(0.3, 0.6, 0.8), color, smoothstep(0.0, 0.01, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}