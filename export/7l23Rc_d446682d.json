{"ver":"0.1","info":{"id":"7l23Rc","date":"1626797732","viewed":404,"name":"Heightmap with Layers","username":"kastorp","description":"Rendering a 3d cached isosurface with 2d quadtree.\nBased on [url=https://www.shadertoy.com/view/WtSyWw]Heightmap cone tracing[/url] by Mathis ","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["heightmap","quadtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Heightmap with layers\" by Kastorp\n//-----------------------------------------------------------\n//  this shader is based on \"Heightmap cone tracing\" by Mathis\n//     https://www.shadertoy.com/view/WtSyWw\n//-----------------------------------------------------------\n// CONTROLS\n//  mouse: rotate view\n//  movement: W=fwd, S=back, A=left, D=right, Q=up, E=down\n//  sun direction: R or T\n//\n// TODO\n// - collision detection with terrain\n// - actions\n//------------------------------------------------------------\n\n#define SSAO\nfloat SSAO_(vec2 coord);\nint hash( int n );\nvoid  srand(int s );\nfloat depth(vec2 coord);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     \n    vec2  renderResolution = ceil(iResolution.xy ); \n    fragColor = textureLod(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy,0.);\n#ifdef SSAO    \n        // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // coordinate\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = fragCoord/iResolution.y;\n    float d = depth(coord);\n    if(d<200.){\n        float ao=  0.7 + .6* SSAO_(coord);\n        fragColor.xyz*= vec3(mix(1., ao, 1.0 - smoothstep(0.0, 0.99, d/200.)));\n    }\n#endif    \n\n    \n\n}\nfloat radicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10;\n }\n\n vec2 Hammersley(uint i, uint N) \n {\n     return vec2(float(i)/float(N), radicalInverse_VdC(i));\n }\n\n\n//--------------------------------------------------------------\n// based on SSAO (Screen Space AO) - by moranzcw - 2021\n// https://www.shadertoy.com/view/WtyfR1\n\n#define PI 3.14159265359\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 sphereVolumeRandPoint()\n{\n    vec3 p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    while(length(p)>1.0)\n    {\n        p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    }\n    return p;\n}\n\nfloat depth(vec2 coord)\n{\n    vec2 uv = coord*vec2(iResolution.y/iResolution.x,1.0);\n    return textureLod(iChannel3, uv,0.).a;\n}\n\nfloat avgdepth(vec2 coord,float lod)\n{\n    vec2 uv = coord*vec2(iResolution.y/iResolution.x,1.0);\n    return textureLod(iChannel3, uv,lod).a;\n}\n\n#define AOradius 2.\n#define Samples 64.0\n\nfloat SSAO_(vec2 coord)\n{\n    float cd = depth(coord);\n    float screenRadius = 0.5 * (AOradius / cd) / 0.53135;\n        \n    float li = 0.0;    \n    float count = 0.0;\n    for(float i=0.0; i<Samples; i++)\n    {\n    \n        vec2 xi = (Hammersley(uint(i), uint(Samples)) *vec2(2.,1.) -vec2(1.,.5)  )* 3.14;            \n        vec3 p = vec3(sin(xi.x)*cos(xi.y),cos(xi.x)*cos(xi.y),sin(xi.y));\n        \n        //vec3 p =sphereVolumeRandPoint();\n        vec2 sp = vec2(coord.x + p.x * screenRadius, coord.y + p.y * screenRadius);\n         \n        float d = depth(sp);\n        float at = pow(length(p)-1.0, 2.0);\n        li += step(cd + p.z * AOradius, d) * at;\n        count += at;\n    }\n    li/= count;\n    \n\n    \n    //object border highlight\n    float li3 =0.,w=0.;\n    for(float lod =1. ;lod<=4.;lod++){\n        float acd = avgdepth(coord,lod);\n        w+=pow(.5, lod);\n        li3 += step(cd ,acd)  *pow(.5, lod);\n    }   \n    li3/=w;\n     return 1.*(li*1. +li3 *.5);\n}\n//----------------------------\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//CONSTANTS\n#define SIZE 1 //3=HIGH 1024x1024 (full screen), 2=MEDIUM 512x512, 3=LOW 256x256 (work with preview)\n\n#if SIZE==3\nconst float LODS=8.;\nconst float LOD_SUM[10]=float[10](1022.,1020.,1016.,1008.,992.,960.,896.,768.,512.,0.);\nconst float LOD_OFF[11]=float[11](0.,0.,512.,\t768.,\t896.,\t960.,\t992.,\t1008.,\t1016.,\t1020.,\t1022.);\nconst float HRES=1024.;\n#else\n#if SIZE==2\nconst float LODS=7.;\nconst float LOD_SUM[9]=float[9](510.,508.,504.,496.,480.,448.,384.,256.,0.);\nconst float LOD_OFF[10]=float[10](0.,0.,256.,384.,448.,480.,496.,504.,508.,510.);\nconst float HRES=512.;\n#else  \nconst float LODS=6.;\nconst float LOD_SUM[8]=float[8](254.,252.,248.,240.,224.,192.,128.,0.);\nconst float LOD_OFF[9]=float[9](0.,0.,128.,192.,224.,240.,248.,252.,254.);\nconst float HRES=256.;\n#endif\n#endif\n\nconst float zMax=100.; // max terraing height\nconst float zSteps=256.; // discretization steps \nconst float zScale= zSteps/zMax; \nconst float hScale=1.; //>1. to stretch\n\nconst float I1024=1./1024.;\nconst vec2 eps=vec2(0.003,0.);\nconst float LOD_PIXELS=HRES*(1.-pow(0.5,LODS));\nconst float IHRES=1./HRES;\n\n//Resolution\n#define IRES 1./iResolution.xy\n#define Aspect vec2(iResolution.x/iResolution.y,1.)\n\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\n\nfloat boxfar2(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t2=max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nbool box(vec3 origin, vec3 dir, vec3 bmin, vec3 bsize, out vec2 bb) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmin+bsize-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    bb=vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n    return ((bb.x>0. && bb.x<bb.y) || (bb.x<0. && bb.y>0.));\n}\n\nvec3 boxN(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t2=min(tMin,tMax);\n    return ((t2.x>t2.y && t2.x>t2.z)?vec3(-sign(dir.x),0.,0.):((t2.y>t2.z)?\n    \t\t\t\tvec3(0.,-sign(dir.y),0.):vec3(0.,0.,-sign(dir.z))));\n}\n\n//------------------\nvec4[2] decodeLayers(vec2 c,sampler2D ch)\n{\n\n    uvec4 O = floatBitsToUint(texelFetch( ch,ivec2(c.x,c.y),0));\n    vec4 el= vec4(O &255u)/zScale,  //max layer height\n         sl= vec4((O>>8u)&255u)/zScale;    //min layer height\n\n   return vec4[2] (sl,el); \n   \n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//transform isosurface into a 4-layered heightmap\n\nlowp float snoise(in mediump vec3 v);\nlowp float snoise(in lowp vec2 v);\n\n#define R iResolution\n\n\n\n\n//ISOSURFACE FUNCTION\n//solid=1., void=-1.\nfloat map(vec3 c)\n{\n \n    vec3 p= c * vec3(1./hScale,1./hScale, 1./zScale);\n    \n    //overworld\n    float  d= (-54. + p.z)*.66 - mix(0., 40., pow(.5 + .5 * snoise(p.xy /135. ), 2.)) * snoise(p / 16.51 );\n    \n    //caves\n    float d2= snoise(p.yxz / 19.99 ) + smoothstep(3., 0., p.z)*.7 + 0.2* smoothstep(32., 54., p.z);\n\n    d=max(d,-d2);\n    return d<0.?1.:-1.; \n}\n\nint  frames; // frames since last resolution variation\nconst int mFrames=32; //number of frames used by encoding\n\n\n// 3D--> 2D encoding\n// see https://www.shadertoy.com/view/NlXSRB\nvec4 encode(ivec2  p)\n{\n    uvec4 O=uvec4(0u);\n    if((p.x % mFrames ) !=frames)return uintBitsToFloat(O) ;\n    float ld=-1.;\n    int i=0;\n    uint sl=0u;\n    for(float z =0.; z< zSteps ;z+= 1.){\n        float d=map(vec3(p.xy,z));\n            \n        if(d *ld<0.){\n            if(d>0.) sl=uint(z);\n            else{\n             O[i]= uint(z) +256u *sl;\n             i++;\n            }\n        }\n        if(i>4)break; \n        ld=d;          \n    }\n      \n    return uintBitsToFloat(O) ;\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 c )\n{\n    O = vec4(0.);\n    \n    ivec4 TS = ivec4(texture(iChannel1,vec2(6.5,0.5)*IRES)); \n    frames= iFrame -TS.z-1; \n    \n    // encoding on startup and et each resolution change \n    // for some reason data is partially reset on every resolution change\n    if(frames>mFrames || (int(c.x) % mFrames ) !=frames)\n    { \n        O=texelFetch( iChannel0,ivec2(c.x ,c.y),0);\n        return;\n    }\n        \n    O=encode(ivec2(c));\n}\n\n\n\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return -0.334 +.5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//LOD\n//entirely copied from \"Heightmap cone tracing\"\n//https://www.shadertoy.com/view/WtSyWw\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.); vec4 SC;\n    if (fragCoord.x<=LOD_PIXELS) {\n        float LOD=floor(log2(HRES-fragCoord.x));\n        float LRES=pow(2.,LOD);\n        if (fragCoord.y<=LRES) {\n            vec2 LODuv=floor(vec2(fragCoord.x-LOD_SUM[int(LOD)],fragCoord.y))*2.+0.5;\n            Color=vec4(0.,1000.,0.,0.);\n            if (fragCoord.x<=HRES*0.5) {\n                LODuv.y+=1.;\n            \tSC=texture(iChannel0,LODuv*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n                SC=texture(iChannel0,(LODuv+1.)*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n                SC=texture(iChannel0,(LODuv+vec2(1.,0.))*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n                SC=texture(iChannel0,(LODuv+vec2(0.,1))*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n            } else {\n                LODuv.x=LODuv.x+LOD_SUM[int(LOD)+1];\n                SC=texture(iChannel1,LODuv*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n                SC=texture(iChannel1,(LODuv+1.)*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n                SC=texture(iChannel1,(LODuv+vec2(1.,0.))*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n                SC=texture(iChannel1,(LODuv+vec2(0.,1))*IRES);\n                Color.xz=max(Color.xz,SC.xz); Color.y=min(Color.y,SC.y);\n            }\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Vars + voxelized scen\n//adapted from \"Heightmap cone tracing\" \n//https://www.shadertoy.com/view/WtSyWw\n\n\n\nfloat getMax(vec2 c,sampler2D ch)\n{\n\n   vec4 el=decodeLayers(c,ch)[1];\n   return  max(max(el.x,el.y),max(el.z,el.w));\n}\n\nvec4 isSolid(vec3 c,sampler2D ch)\n{\n    vec4  h =vec4(c.y*zScale);        //current height\n    vec4[2] l=decodeLayers( c.xz,ch);\n    return  step(l[0],h)*step(h,l[1]);   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color=vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color=vec4(-.75,0.8,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color=vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color=vec4(56.5,85.3,56.5,1.); //Player Pos\n            else if (fragCoord.x<5.) Color=vec4(0.3,2.8,0.,1.); //Sun angles\n            else if (fragCoord.x<6.) Color=vec4(0.,0.,0.,1.); //Sun direction\n        }\n    } else { //Update\n\t\tif (fragCoord.x<10. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //previous click\n                    if (Color.w==0.) {\n                    \tColor.w=1.;\n                    \tColor.xy=iMouse.zw;\n                    }\n                } else Color.w=0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse=texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw=Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x=Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x=clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y=Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y=mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles=texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                if(iMouse.x<=0.) Angles.y= iTime*.3+3.14;\n                Color.xyz=normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed=32.*iTimeDelta;\n                //\tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=28.*iTimeDelta;\n                vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n                vec3 TanH=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=TanH*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=TanH*Speed; //D\n                vec3 TanV=normalize(cross(Eye,TanH));\n                if (texelFetch(iChannel1,ivec2(81,0),0).x>0.) Color.xyz-=TanV*Speed; //Q\n                if (texelFetch(iChannel1,ivec2(69,0),0).x>0.) Color.xyz+=TanV*Speed; //E\n                \n                Color.xz=min(vec2(HRES),max( vec2(0.),Color.xz)); //clamp \n                if(iMouse.x<=0.) Color.xz= vec2(HRES*.5) + vec2(sin(iTime*.3),cos(iTime*.3))*HRES*.3;\n                \n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(82,0),0).x>0.) Color.y+=0.05; //R\n                if (texelFetch(iChannel1,ivec2(84,0),0).x>0.) Color.y-=0.05; //T\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*IRES).xy;           \n                Color=vec4(normalize(vec3(cos(Angles.y),1.,sin(Angles.y))),1.);\n            }else if (fragCoord.x<7.) { //texture size\n                ivec4 pTS = ivec4(texture(iChannel0,vec2(6.5,0.5)*IRES)); \n                ivec2 TS=textureSize(iChannel2,0);               \n                Color = vec4(TS,  pTS.x!=TS.x? iFrame :pTS.z ,0);            \n            }\n        } else if (fragCoord.x<HRES && fragCoord.y<HRES+1.) {\n            vec2 uv=vec2(fragCoord.x,fragCoord.y-1.);\n            float h = getMax(uv,iChannel2);            \n            Color=vec4(max(0.,h),0.,0.,0.);\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//QuadTree rendering\n\n//adapted from \"Heightmap cone tracing\" \n//https://www.shadertoy.com/view/WtSyWw\n\nvec4 QuadRay(vec3 p, vec3 d) {\n    vec3 IDir=1./d;\n    float FAR=boxfar2(p.xz,IDir.xz,vec2(0.),vec2(HRES));\n    float dist=0.; float LFar=FAR; vec3 cp,fp; vec2 bb; vec4 C;\n    float LOD=LODS;\n    float LS=pow(2.,LOD);\n    float ILS=pow(0.5,LOD);\n    for (int i=0; i<100; i++) {\n        if (dist>FAR) break;\n        if (dist>LFar && LOD<LODS) {\n            LOD=LOD+1.;\n            LS*=2.;\n            ILS*=0.5;\n            fp=floor(cp*ILS)*LS;\n            LFar=boxfar2(p.xz,IDir.xz,fp.xz,fp.xz+LS);\n        }\n        cp=p+d*dist;\n        fp=floor(cp*ILS)*LS;\n        C=((LOD==0.)?texture(iChannel0,(fp.xz+vec2(0.5,1.5))*IRES):\n           texture(iChannel2,(fp.xz*ILS+vec2(LOD_OFF[int(LOD)]+0.5,0.5))*IRES));\n       \n        bool b1 = box(p,IDir,vec3(fp.x,0.,fp.z),vec3(LS,C.x,LS),bb);\n        if(b1){// ((bb.y>=0. && bb.y>bb.x) || Box(p-vec3(fp.x,0.,fp.z),vec3(LS,C.x,LS))<=0.) {\n\n            if (LOD==0. ) {\n                                \n                vec3 p_in=p+d*(bb.x+eps.x) ;\n                vec4[2] l =decodeLayers(p_in.xz,iChannel1);\n                \n                bool hit=false;\n                //Layer4\n                hit = box(p,IDir,vec3(fp.x,l[0].w,fp.z),vec3(1.,l[1].w-l[0].w,1.),bb);\n                if(hit) return  vec4(boxN(p,IDir,vec3(fp.x,l[0].w,fp.z),vec3(fp.x+1.,l[1].w,fp.z+1.)),max(bb.x,0.));\n                //Layer3\n                hit = box(p,IDir,vec3(fp.x,l[0].z,fp.z),vec3(1.,l[1].z-l[0].z,1.),bb);\n                if(hit) return  vec4(boxN(p,IDir,vec3(fp.x,l[0].z,fp.z),vec3(fp.x+1.,l[1].z,fp.z+1.)),max(bb.x,0.));\n                //Layer2\n                hit = box(p,IDir,vec3(fp.x,l[0].y,fp.z),vec3(1.,l[1].y-l[0].y,1.),bb);\n                if(hit) return  vec4(boxN(p,IDir,vec3(fp.x,l[0].y,fp.z),vec3(fp.x+1.,l[1].y,fp.z+1.)),max(bb.x,0.));\n                //Layer1\n                 hit = box(p,IDir,vec3(fp.x,l[0].x,fp.z),vec3(1.,l[1].x-l[0].x,1.),bb);\n                if(hit ) return  vec4(boxN(p,IDir,vec3(fp.x,l[0].x,fp.z),vec3(fp.x+1.,l[1].x,fp.z+1.)),max(bb.x,0.));\n         \n            } else if (LOD>0.) {\n                LFar=boxfar2(p.xz,IDir.xz,fp.xz,fp.xz+LS);\n                LOD-=1.;\n                LS*=0.5;\n                ILS*=2.;\n                continue;\n            }\n        }\n        dist+=boxfar2(cp.xz,IDir.xz,fp.xz,fp.xz+LS)+eps.x;\n    }\n    return vec4(-1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    float Rot=-(iMouse.x/iResolution.x)*3.14*3.;\n\tvec3 Pos=texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    mat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*IRES).xyz);\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(Aspect*1.1),1.)*MM);\n    vec3 Color=vec3(1.);\n    \n    vec2 sunAngles=texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n    vec3 sunDir =normalize(vec3(cos(sunAngles.y),1.,sin(sunAngles.y)));\n\t//Trace\n    vec4 RayDist=QuadRay(Pos,Dir);\n    if (RayDist.w>=0.) {\n        vec3 PixelP=Pos+Dir*RayDist.w;\n        vec3 PixelN=RayDist.xyz;\n      \n        //albedo            \n         Color.rgb = mix( vec3(.9,.7,.1),  //dust\n             mix(vec3(.1,.5,0.), //grass\n                 vec3(.5,.2,.1), //dirt\n                  smoothstep(45.,35.,PixelP.y +(RayDist.y>0.? 0.:-5.)) \n             ),\n             smoothstep(65.,45.,PixelP.y +(RayDist.y>0.? 0.:-3.)) \n         );\n   \n        //shadows (no AO yet)\n        if(RayDist.w>0.){\n            float shad= QuadRay(PixelP  +PixelN*eps.x,sunDir).w >0. ? .5:1. ;        \n            Color*=shad * (.5 + dot(PixelN,sunDir)*.45) * PixelP.y/150.;\n        } else Color*=.2;  //inside blocks                               \n    } \n    else {\n        Color=vec3(0.2,0.5,0.9)*(Dir.y*0.5+0.5)+vec3(1.)*pow(max(0.,dot(sunDir,Dir)),8.);\n    }\n    \n    fragColor=vec4(pow(Color,vec3(0.45)),RayDist.w>0.?RayDist.w:1000.);\n}","name":"Buffer D","description":"","type":"buffer"}]}