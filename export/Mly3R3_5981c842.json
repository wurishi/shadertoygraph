{"ver":"0.1","info":{"id":"Mly3R3","date":"1475914934","viewed":675,"name":"icosahedronal symmetry","username":"DjinnKahn","description":"I was curious if a rounded icosahedron could be *elegantly* made.  Yes!\n\nA rounded box is made with abs() to \"fold\" space. For an icosahedron we can fold, rotate, fold, rotate, fold, rotate, fold :) It was a fun challenge! Has it been done before?\n","likes":32,"published":1,"flags":0,"usePreview":1,"tags":["icosahedron","dodecahedron","platonic","primitive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I was curious if a rounded icosahedron could be *elegantly* made.\n//\n// A rounded box is made with abs() to \"fold\" space. \n// For an icosahedron we can fold, rotate, fold, rotate, fold, rotate, fold.\n// Now all the points are located on one-sixth of one face.\n// This is already useful to repeat objects 120x times in a symmetric way.\n//\n// The rounded corner is also similar to the rounded box. The corner of the box\n// is translated to the origin, and max(pt,0) shifts all the points with negative\n// coordinates to 0. So, the sphere you draw at the origin is effectively extruded \n// in the negative x-direction/y-direction/z-direction.\n//\n// For the icosahedron, after folding, we have a triangle. The triangle vertices are \n// the center, a corner, and a mid-edge of a face. There are 120 such triangles\n// but they got folded into one. We transform the triangle so that the corner is at\n// the origin, the edge moves along the negative X-axis, and the normal is the Z-axis.\n// Now we can use max(pt,0) to extrude the flat face, just like the rounded box.\n\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\nconst float PI = 3.14159265359;\nconst float PHI = (1.+sqrt(5.))/2.;\nconst float A = PHI / sqrt( 1. + PHI*PHI );\nconst float B = 1. / sqrt( 1. + PHI*PHI );\nconst float J = 0.309016994375;\nconst float K = J+.5;\nconst vec3 ICOVERTEX  = vec3(0,A,B);\nconst vec3 ICOMIDFACE = vec3(0,A,B)*(1./3.) + vec3(0,0,A)*(2./3.);\nconst vec3 ICOMIDEDGE = vec3(0,A,B)*.5 + vec3(B,0,A)*.5;\nconst mat3 R0 = mat3(0.5,-K,J        ,K,J,-0.5                       ,J,0.5,K                          );\nconst mat3 R1 = mat3(K,J,-0.5        ,J,0.5,K                        ,0.5,-K,J                         );\nconst mat3 R2 = mat3(-J,-0.5,K       ,0.5,-K,-J                      ,K,J,0.5                          );      \nconst mat3 R3 = mat3(-0.5,sqrt(.75),0,K,0.467086179481,0.356822089773,-J,-0.178411044887,0.934172358963);\nconst vec3 O3 = vec3(B,B/sqrt(3.),sqrt(1.-4./3.*B*B));    \nconst mat3 R4 = mat3(0.587785252292,-K,0.,-0.425325404176,-J,0.850650808352,0.688190960236,0.5,0.525731112119);\nconst vec3 O4 = vec3(A/3./tan(PI/5.),A/3.,0.63147573033330584);\n\n\n// opIcosahedron will create 120x symmetry\n// All points will be mapped to a single face of a icosahedron (20x symmetry)\n// Also, points will be put into 1/6th of that face (addition 6x symmetry)\n//\n// The icosahedron face vertices are vec3(0,A,B), vec3(B,0,A), vec3(-B,0,A)\n//\n// return value will be between these rays:\n//    vertex:        vec3(0,A,B)\n//    face midpoint: vec3(0,A,B)*(1./3.) + vec3(0,0,A)*(2./3.)\n//    edge midpoint: vec3(0,A,B)*.5 + vec3(B,0,A)*.5  \n// \n// this is equivalent to dodecahedral symmetry (12x faces, 10x within face)\n// (formula by DjinnKahn)\nvec3 opIcosahedron( vec3 p )\n{    \n    p = R0 * abs( p );\n    p = R1 * abs( p );\n    p = R2 * abs( p );\n    return abs( p );  \n}    \n\n// rotate and translate `opIcosahedron` so that\n// icosahedron vertex is at origin\n// icosahedron edge is negative X-axis\n// icosahedron face normal is Z-axis \n// icosahedron is in negative Y-space\nvec3 opAlignedIcosahedron( vec3 p, float radius )\n{         \n    return R3 * opIcosahedron( p ) - O3 * radius;\n}  \n\nfloat sdRoundedIcosahedron( vec3 p, float radius, float cornerRadius )\n{         \n    p = opAlignedIcosahedron( p, radius );\t\n    return sdSphere( vec3( max(p.x, 0.), max(p.y, 0.), p.z ), cornerRadius );\n}\n\nfloat sdIcosahedronEdges( vec3 p, float radius, float edgeRadius )\n{         \t\n    p = opAlignedIcosahedron( p, radius );\n    return sdSphere( vec3( max( p.x, 0. ), p.y, p.z ), edgeRadius );\n}\n\n// let's use the face centers of `opIcosahedron` as the vertices of a dodecahedron\n// rotate and translate `opIcosahedron` so that\n// dodecahedron vertex is at origin\n// dodecahedron edge is negative Y-axis\n// dodecahedron face normal is Z-axis \n// dodecahedron is in negative X-space\nvec3 opAlignedDodecahedron( vec3 p, float radius )\n{         \n    return R4 * opIcosahedron( p ) - O4 * radius;\n}  \n\nfloat sdRoundedDodecahedron( vec3 p, float radius, float cornerRadius )\n{         \n    p = opAlignedDodecahedron( p, radius );\t\n    return sdSphere( vec3( max(p.x, 0.), max(p.y, 0.), p.z ), cornerRadius );\n}\n\nfloat sdDodecahedronEdges( vec3 p, float radius, float cornerRadius )\n{         \n    p = opAlignedDodecahedron( p, radius );\t\n    return sdSphere( vec3( p.x, max(p.y, 0.), p.z ), cornerRadius );\n}\n\n    \nfloat calcDist( vec3 pos )\n{    \n    float dist = 1e9;\n    \n    dist = min( dist, sdRoundedIcosahedron ( pos - vec3(0.,0.,3.), 0.6, 0.6 ) );\n    dist = min( dist, sdIcosahedronEdges   ( pos - vec3(3.,0.,3.), 1.0, 0.1 ) );\n    dist = min( dist, sdRoundedDodecahedron( pos - vec3(0.,0.,0.), 0.6, 0.6 ) );\n    dist = min( dist, sdDodecahedronEdges  ( pos - vec3(3.,0.,0.), 1.0, 0.1 ) );\n        \n    // sphere at vertex, edge center, face center\n    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(3.,-3.,0) ) - (vec3(0,A,B))\t\t\t\t\t\t\t   , 0.15 ) );\n    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(3.,-3.,0) ) - (vec3(0,A,B)*.5 + vec3(B,0,A)*.5)\t\t   , 0.07 ) );\n    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(3.,-3.,0) ) - (vec3(0,A,B)*(1./3.) + vec3(0,0,A)*(2./3.)), 0.03 ) );\n            \n    // morph between an icosahedron and dodecahedron\n    // (just move a sphere from the icosahedron vertex to middle of the face)\n    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(0,-3.,0) ) - mix(ICOVERTEX, ICOMIDFACE, sin(iTime)*.5+.5), 0.10 ) );    \n    \n    //// soccer ball vertices (truncated icosahedron)\n    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(0,-3.,3.) ) - mix(ICOVERTEX, ICOMIDEDGE, .66), 0.10 ) );    \n\n    //// 20 dodecahedrons arranged at dodecahedron vertices:\n    //dist = sdRoundedDodecahedron( opIcosahedron( pos ) - ICOMIDFACE*3., 0.5, 0.3 );\n        \n    //// 12 icosahedrons arranged at icosahedron vertices:\n    //dist = sdRoundedIcosahedron( opIcosahedron( pos ) - ICOVERTEX*2., 0.5, 0.3 );\n    \n    ////12 sets of 12 icosahedrons\n    //dist = sdRoundedIcosahedron( opIcosahedron( opIcosahedron( pos ) - ICOVERTEX*2.6 ) - ICOVERTEX*.6, 0.15, 0.1 );   \n        \n    //12 sets of 12 sets of 12 icosahedrons\n    if ( iMouse.w > 0. )\n    {\n        vec2 m = iMouse.xy/iResolution.xy;\n    \tdist = sdRoundedIcosahedron( opIcosahedron( opIcosahedron( opIcosahedron( pos ) - ICOVERTEX*12.*m.y ) - ICOVERTEX*5.*m.x ) - ICOVERTEX*.4, 0.1, 0.16 );   \n    }\n\n    return dist;\n}\n\n\n\n\n\n\n\n// no icosahedron code past this point : )\n\nvec3 normalAt( vec3 pos )\n{    \n    const float eps = 0.001;\n    float dist = calcDist( pos );\n    return normalize( vec3( dist - calcDist( pos + vec3(eps,0,0) )\n                          , dist - calcDist( pos + vec3(0,eps,0) )\n                          , dist - calcDist( pos + vec3(0,0,eps) ) ) );\n}\n\nvec3 surfaceColor( vec3 pos, vec3 dir )\n{\n    vec3 norm = normalAt( pos );\n    vec3 reflectionDir = reflect( dir, norm );\n    vec3 lightDir = normalize( vec3( 1.0, -0.3, 0.0 ) );\n    return vec3(.3,0,0)\n         + vec3( pow(max(0.0,dot(reflectionDir,-lightDir)),70.0) )\n         + vec3( pow(max(0.0,dot(norm,lightDir)),1.0) ) * .3\n        // + texture( iChannel0, norm ).rgb * .3        \n        // + min(0.001/pow(fract(pos*1.0)-0.5,vec3(2.0)),0.5)\n        ;\n}\n\nvec3 rotz( vec3 p, float a )\n{\n\treturn vec3( p.x * cos(a) + p.y * sin(a)\n               , p.x *-sin(a) + p.y * cos(a)\n               , p.z );\n}\nvec3 rotx( vec3 p, float a )\n{\n\treturn vec3( p.x\n               , p.y * cos(a) + p.z * sin(a)\n               , p.y *-sin(a) + p.z * cos(a) );\n}\nvec3 roty( vec3 p, float a )\n{\n\treturn vec3( p.x * cos(a) + p.z * sin(a)\n               , p.y\n               , p.x *-sin(a) + p.z * cos(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 screenPos = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;        \n    vec3 ray = normalize( vec3( screenPos, 3.0 ) );      \n    vec3 pos = vec3( 0, 0, -10.0 );\n    \n    float tilt = sin(iTime/2.2)*.4-.3;\n    pos = roty( rotx( pos, tilt + .1 ), iTime * .3 );\n    ray = roty( rotx( ray, tilt      ), iTime * .3 );  \n    \n    fragColor = texture( iChannel0, ray );\n    \n    \n    float dist = 999.9;\n    for ( int i = 0; i < 150; i++ )\n    {\n    \tdist = calcDist( pos );    \n    \tpos += ray * dist;\n        if ( dist < .01 || dist > 99. )\n            break;\n    }\n        \n    vec3 ray2 = reflect( ray, normalAt( pos ) );\n    vec3 pos2 = pos + ray2*.001; // start the ray away from the surface slightly\n    float dist2 = 999.9;\n    for ( int j = 0; j < 150; j++ )\n    {\n        dist2 = calcDist( pos2 );    \n        pos2 += ray2 * dist2;\n        if ( dist2 < .0005 || dist2 > 99.9 )\n            break;\n    }\n    \n    if ( dist >= .01 ) return;        \n            \n    fragColor.rgb = surfaceColor( pos, ray ) + texture( iChannel0, ray2 ).rgb * .3 * 0.;\n    \n    if ( dist2 < .01 )\n    \tfragColor.rgb += surfaceColor( pos2, ray2 ) * 0.5 + texture( iChannel0, reflect( ray2, normalAt( pos2 ) ) ).rgb * .1 * .0;\n    fragColor.rgb += texture( iChannel0, ray2 ).rgb * .5;\n    \n}","name":"Image","description":"","type":"image"}]}