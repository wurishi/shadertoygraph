{"ver":"0.1","info":{"id":"slS3Dz","date":"1626382719","viewed":113,"name":"ray oriented rectangle intersect","username":"Envy24","description":"ray intersection with plane, axis-aligned rectangle, oriented rectangle","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ray","intersection","rectangle","plane","oriented"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n#define CHANNEL iChannel1\n#define MX (iMouse.x / R.x)\n\nvec4 shootRayInPlane(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 plane,\n    vec3 normal)\n{\n    float denominator = dot(rayDir, normal);\n    float t = dot(plane - ray, normal) / denominator;\n    vec3 HP = ray + rayDir * t;\n    \n    float range = 0.125;\n    float u = abs(HP.x - plane.x) / range; // texture u\n    float v = abs(HP.y - plane.y) / range; // texture v\n    \n    return \n        t >= 0.0 ? //&&          // in front of camera?\n        //denominator <= 0.0 ?  // frontface?\n        \n        vec4(u, v, 0.0, 1.0) :\n        \n        BACKGROUND;\n}\n\nvec4 shootRayInAxisAlignedRectangle2(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 BL,      // bottom left\n    vec3 TR,      // top right\n    vec3 normal)\n{\n    float denominator = dot(rayDir, normal);\n    float t = dot(BL - ray, normal) / denominator;    \n    vec3 HP = ray + rayDir * t;\n\n    return \n        t >= 0.0 &&            // in front of camera?\n        denominator <= 0.0 &&  // frontface?\n        HP.x > BL.x &&         // in rectangle?\n        HP.x < TR.x &&\n        HP.y > BL.y &&\n        HP.y < TR.y ? \n        \n        vec4(\n            abs(HP.x - BL.x) / abs(TR.x - BL.x), // texture u\n            abs(HP.y - BL.y) / abs(TR.y - BL.y), // texture v\n            0.0, 1.0) :\n        \n        BACKGROUND;   \n}\n\nvoid swap(inout float l, inout float r)\n{\n    float t = l;\n    l = r;\n    r = t;\n}\n\n/*\n    Unoptimised.\n*/\nvec4 shootRayInOrientedRectangle(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 BL, // bottom left\n    vec3 BR, // bottom right\n    vec3 TR) // top right\n{\n    // Orthonormal basis.\n    vec3 r = normalize(BR-BL);\n    vec3 u = normalize(TR-BR);\n    vec3 f = normalize(cross(r, u)); // normal\n       \n    float denominator = dot(rayDir, f);\n    float dist = dot((BL+TR)*0.5-ray, f) / denominator;\n    vec3 HP = ray + rayDir * dist;\n       \n    mat3x3 invRotation = mat3x3(r, u, f);   \n    // because rotation matrix is orthogonal (othonormal) we can use transpose to calculate the invers of this matrix\n    invRotation = transpose(invRotation); \n    \n    // Align rectagle and hit point with \n    // axis (1.0, 0.0, 0.0); (0.0, 1.0, 0.0); (0.0, 0.0, 1.0).\n    BL = invRotation * BL;\n    BR = invRotation * BR;\n    TR = invRotation * TR;\n    HP = invRotation * HP;\n    \n    return \n        dist >= 0.0 &&         // in front of camera?\n        //denominator >= 0.0 && // frontface?\n        HP.x > BL.x &&         // inside AABB?\n        HP.x < BR.x &&\n        HP.y > BL.y &&\n        HP.y < TR.y ? \n        \n        vec4(\n            abs(HP.x - BL.x) / abs(BR.x - BL.x), // texture u\n            abs(HP.y - BL.y) / abs(TR.y - BL.y), // texture v\n            dist,\n            1.0) :\n        \n        BACKGROUND;   \n}\n\nvec4 scenePlane(vec3 ray, vec3 rayDir)\n{\n    /* AA Rect */\n    vec3 plane = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n    /* AA Rect */\n    \n    normal = rotateAroundY(normal, iTime);\n    normal = rotateAroundX(normal, iTime * 0.6);\n    normal = rotateAroundZ(normal, iTime * 0.3);\n    \n    vec4 res = shootRayInPlane(ray, rayDir, plane, normal);\n    return \n        res != BACKGROUND ?\n            texture(CHANNEL, vec2(res.x, res.y)) :\n            BACKGROUND;\n}\n\nvec4 sceneAARect(vec3 ray, vec3 rayDir)\n{\n    /* AA Rect */\n    float d = 0.2;\n    vec3 A = vec3(-d, -d, 0.0);\n    vec3 B = vec3(d, d, -2.0);\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    /* AA Rect */\n    \n    vec4 res = shootRayInAxisAlignedRectangle2(ray, rayDir, A, B, N);\n    return \n        res != BACKGROUND ?\n            texture(CHANNEL, vec2(res.x, res.y)) :\n            BACKGROUND;\n}\n\nvec4 sceneOrientedRect(vec3 ray, vec3 rayDir)\n{\n    /* Oriented Rect */\n    float d = 0.3;\n    vec3 A = vec3(-d, -d, -0.2);\n    vec3 B = vec3(d, -d, -0.4);\n    vec3 C = vec3(d, d, -0.4);\n    /* Oriented Rect */\n    \n    /* Rotation */\n    A = rotateAroundZ(A, iTime);\n    B = rotateAroundZ(B, iTime);\n    C = rotateAroundZ(C, iTime);\n    \n    A = rotateAroundY(A, iTime);\n    B = rotateAroundY(B, iTime);\n    C = rotateAroundY(C, iTime);\n    \n    A = rotateAroundX(A, iTime * 0.7);\n    B = rotateAroundX(B, iTime * 0.7);\n    C = rotateAroundX(C, iTime * 0.7);\n    /* Rotation */\n    \n    vec4 res = shootRayInOrientedRectangle(ray, rayDir, A, B, C);\n    return \n        res != BACKGROUND ?\n            texture(CHANNEL, vec2(res.x, res.y)) :\n            BACKGROUND;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 2.0);\n    //camera = rotateAroundY(camera, iTime);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n\n    // Choose scene.\n    //fragColor = scenePlane(ray, rayDir);\n    //fragColor = sceneAARect(ray, rayDir);\n    fragColor = sceneOrientedRect(ray, rayDir);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}\n","name":"Common","description":"","type":"common"}]}