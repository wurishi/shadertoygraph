{"ver":"0.1","info":{"id":"4XfyDX","date":"1726702613","viewed":47,"name":"Hilbert curve generator","username":"TriKri","description":"The Hilbert curve, colored by the distance along the curve from the start. Builds on the flipping strategy outlined by 3Blue1Brown in https://www.youtube.com/watch?v=3s7h2MHQtxc&t=4m35s. Flipping also flips the coordinate system of the subsquares.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hilbert","hilbertcurve"],"hasliked":0,"parentid":"43fyDX","parentname":"Hilbert curve generator (old)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * The Hilbert curve: https://en.wikipedia.org/wiki/Hilbert_curve\n * \n * The Hilbert curve, colored by the distance along the curve from the\n * start.\n * \n * Builds on the flipping strategy outlined by 3Blue1Brown in\n * https://www.youtube.com/watch?v=3s7h2MHQtxc&t=4m35s. Except for\n * flipping the curve, flipping also flips the coordinate system of the\n * subsquares. Since the algorithm keeps track of the two directions\n * connecting the subcurve with the adjacent parts of the curve, the\n * components of these directions need to change accordingly for the\n * directions to remain constant.\n * \n * When going deeper into the hierarchy, since the subsquare size gets\n * halved, the basis units are halved too in order to keep the\n * coordinates of the points of the subsquare between 0 and 1. (This also\n * has the effect that the numerical value of the pixel size is scaled\n * up, since it transforms oppositely to the change of basis, being a\n * contravariant quantity).\n */\n\n\nconst int min_iterations = 0;\nconst int max_iterations = 10;\nconst float timePerIteration = 2.0;\nconst float squareHeight = 1.0;\nconst float thickness = 0.6;\nconst float minThicknessPx = 3.0;\nconst float edgeHalfStepLengthPx = 0.75;\n//const float gamma = 1.0; // 1.0 = No gamma correction\nconst float gamma = 2.2; // Used for gamma correction\nconst vec3 backgroundColor = vec3(0);\n\nvec3 alphaToColor(float alpha) {\n    float Alpha = mod(6.0 * alpha, 6.0);\n    int A = int(Alpha);\n    float a = Alpha - float(A);\n    switch (A) {\n        case 0: return vec3(1.0  ,     a, 0.0  ); // Red to yellow\n        case 1: return vec3(1.0-a, 1.0  , 0.0  ); // Yellow to green\n        case 2: return vec3(0.0  , 1.0  ,     a); // Green to cyan\n        case 3: return vec3(0.0  , 1.0-a, 1.0  ); // Cyan to blue\n        case 4: return vec3(    a, 0.0  , 1.0  ); // Blue to magenta\n        case 5: return vec3(1.0  , 0.0  , 1.0-a); // Magenta to red\n        case 6: return vec3(1, 0, 0); // Red (somesimes the modulation will return 6.0)\n    }\n}\n\nvec3 gammaCorrected(vec3 col) {\n    float newGamma = pow(gamma, min(1.0-(col.z-col.x), 1.0));\n    return vec3(pow(col.x, 1.0/newGamma), pow(col.y, 1.0/newGamma), pow(col.z, 1.0/newGamma));\n    return vec3(pow(col.x, 1.0/gamma), pow(col.y, 1.0/gamma), pow(col.z, 1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Resolutionagnostic pixel coordinates\n    float pixelSize = 1.0 / (min(iResolution.x, iResolution.y) * squareHeight);\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) * pixelSize + 0.5;\n    \n    bool inSquare = uv.x >= 0.0 && uv.x < 1.0 && uv.y >= 0.0 && uv.y < 1.0;\n    \n    if (!inSquare) {\n        fragColor = vec4(gammaCorrected(backgroundColor), 1.0);\n        return;\n    }\n    \n    // Divide and conquer the square\n    float inv = 0.0;\n    float prec = 1.0;\n    vec2 inDir = vec2(0,0);\n    vec2 outDir = vec2(0,0);\n    int max_k = min_iterations + int(iTime / timePerIteration) % (max(max_iterations - min_iterations, 0) + 1);\n    for (int k = 0; k < max_k; k++) {\n        ivec2 ij = ivec2(uv.x >= 0.5, uv.y >= 0.5);\n        uv = 2.0*uv - vec2(ij);\n        pixelSize *= 2.0;\n        int subsquare = ij.x + 2*ij.y;\n        int order;\n        switch (subsquare) {\n        case 0: // Bottom left\n            order = 0;\n            uv = uv.yx;\n            inDir = inDir.yx;\n            outDir = vec2(1,0);\n            break;\n        case 1: // Bottom right\n            order = 3;\n            uv = vec2(1.0) - uv.yx;\n            inDir = vec2(-1,0);\n            outDir = -outDir.yx;\n            break;\n        case 2: // Top left\n            order = 1;\n            inDir = vec2(0,-1);\n            outDir = vec2(1,0);\n            break;\n        case 3: // Top right\n            order = 2;\n            inDir = vec2(-1,0);\n            outDir = vec2(0,-1);\n            break;\n        }\n        prec *= 0.25;\n        inv += prec * float(order);\n    }\n    \n    uv -= vec2(0.5);\n    vec2 mostAlignedDir = dot(uv, inDir) > dot(uv, outDir) ? inDir : outDir;\n    float cosAngle = -dot(inDir, outDir);\n    float tanHalfAngle = sqrt((1.0 - cosAngle)/(1.0 + cosAngle));\n    float deadStartDistance = thickness * tanHalfAngle;\n    inv += prec * max((dot(uv, mostAlignedDir) - 0.5*deadStartDistance) / (1.0 - deadStartDistance), 0.0) * (mostAlignedDir == outDir ? 1.0 : -1.0);\n    uv -= max(dot(uv, mostAlignedDir), 0.0) * mostAlignedDir;\n    float curveDist = length(uv);\n    curveDist = 0.5 * max(thickness, minThicknessPx*pixelSize) - curveDist;\n    \n    float alpha = inv / max(1.0 - prec, 0.5);\n    float edgeHalfStepLength = edgeHalfStepLengthPx * pixelSize;\n    float onCurve = smoothstep(-edgeHalfStepLength, edgeHalfStepLength, curveDist);\n    vec3 col = mix(backgroundColor, alphaToColor(6.0/6.0 * alpha), onCurve);\n    \n    // Gamma correct colors\n    col = gammaCorrected(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}