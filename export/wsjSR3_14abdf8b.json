{"ver":"0.1","info":{"id":"wsjSR3","date":"1554569006","viewed":476,"name":"simple sdf setup","username":"eliasku","description":"simple sdf setup\nbased on: https://www.shadertoy.com/view/MsfGRr\nmusic: https://www.shadertoy.com/view/ldfSW2\n","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","sdf","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat shrepe(in vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) - r\n    + min(max(d.x, max(d.y, d.z)), 0.0);// remove this line for an only partially signed sdf\n}\n\nfloat easeSmoothStep(float x) {\n    return -2.0 * x * x * x + 3.0 * x * x;\n}\n\nfloat map(in vec3 p0, out vec4 oTrap, in vec4 c) {\n    oTrap = vec4(1, 1, 1, 0.5);\n    vec3 p = p0;\n\n    vec3 scale = vec3(0.5, 0.5, 0.8);\n    float s1 = shrepe(p / scale) * min(scale.x, min(scale.y, scale.z));\n    float t1 = sdRoundBox(p, vec3(0.5 - 0.1, 0.5 - 0.1, 0.8 - 0.1), 0.1);\n    float ll = 2.0 * (clamp(sin(iTime), -0.25, 0.25) + 0.25);\n\n    s1 = mix(s1, t1, easeSmoothStep(ll));\n\n    float s2 = shrepe(p / 0.25 +  vec3(4.0 * cos(iTime * 4.0), 4.0 * sin(iTime * 4.0), 0)) * 0.25;\n\n    float spheres = min(s1, s2);\n    float plane = sdPlane(p, vec4(0, 1, 0, 1.5));\n    if (plane < spheres) {\n        oTrap.x = -0.5;\n        oTrap.w = 0.0;\n    }\n    return min(plane, spheres);\n}\n\nvec3 calcNormal(in vec3 pos, in vec4 c) {\n    vec4 kk;\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.001;\n    return normalize(e.xyy*map(pos + e.xyy, kk, c) +\n                        e.yyx*map(pos + e.yyx, kk, c) +\n                        e.yxy*map(pos + e.yxy, kk, c) +\n                        e.xxx*map(pos + e.xxx, kk, c));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 res, in vec4 c) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0; i<64; i++)\n    {\n        h = map(ro+rd*t, tmp, c);\n        if (h<0.001||t>maxd) break;\n        t += h;\n    }\n    if (t<maxd) { resT=t; res = tmp; }\n\n    return resT;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k, in vec4 c)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i=0; i<64; i++)\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk, c);\n        res = min(res, k*h/t);\n        if (res<0.001) break;\n        t += clamp(h, 0.01, 0.5);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n    #define MISS_BOTTOM vec3(1.0, 0.0, 0.0)\n    #define MISS_TOP vec3(0.0, 0.0, 1.0)\n\n    #define MATE_COLOR vec3(0.9, 0.5, 0.5) * 0.3\n\nvec3 applyFog(in vec3  rgb, in vec3 skyColor, in float distance) {\n    float startDist = 8.0;\n    float fogAmount = 2.0 * (1.0 - exp(-(distance-startDist) * (1.0/startDist)));\n    return mix(rgb, skyColor, clamp(fogAmount, 0.0, 1.0));\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox(vec2 p) {\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c)\n{\n    const vec3 sun = vec3(0.6, 0.6, 0.6);\n    vec4 tra;\n    float t = intersect(ro, rd, tra, c);\n\n    vec3 skybox = mix(MISS_BOTTOM, MISS_TOP, rd.y);\n    vec3 col = skybox;\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, c);\n\n        vec3 mate = MATE_COLOR;\n        //        mate.x = 1.0-10.0*tra.x;\n        if (tra.x <= -0.5) {\n            float grid = checkersGradBox(pos.xz*0.4) * 0.2 + 0.1;\n            mate = vec3(grid, grid, grid);\n        }\n\n        float occ = clamp(2.5*tra.w-0.15, 0.0, 1.0);\n        //        float occ = 0.5;\n\n        col = vec3(0.0, 0.0, 0.0);\n\n        // sky\n        {\n            float co = clamp(dot(-rd, nor), 0.0, 1.0);\n            vec3 ref = reflect(rd, nor);\n            float shadow = softshadow(pos+0.0005*nor, ref, 0.001, 4.0, c);\n            //            float sha = occ;\n            shadow *= smoothstep(-0.1, 0.1, ref.y);\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            float fre = 0.1 + 0.9*pow(1.0-co, 5.0);\n\n            vec3 sky_color = vec3(0.8, 0.9, 1.0);\n            col  = mate*0.3*sky_color*(0.6+0.4*nor.y)*occ;\n            col +=  2.0*0.3*sky_color*(0.6+0.4*nor.y)*shadowc*fre;\n        }\n\n        // sun\n        {\n            const vec3 lig = sun;\n            float dif = clamp(dot(lig, nor), 0.0, 1.0);\n            float shadow = softshadow(pos, lig, 0.001, 64.0, c);\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            //            vec3 shadowc = vec3(shadow);\n            vec3 hal = normalize(-rd+lig);\n            float co = clamp(dot(hal, lig), 0.0, 1.0);\n            float fre = 0.04 + 0.96*pow(1.0-co, 5.0);\n            float spe = pow(clamp(dot(hal, nor), 0.0, 1.0), 32.0);\n\n            vec3 sun_color = vec3(1, 0.9, 0.7);\n            vec3 sun_color2 = vec3(1, 0.9, 0.7);\n            //vec3(1.00,0.90,0.70)\n\n            col += mate*3.5*sun_color*dif*shadowc;\n            col +=  7.0*3.5*sun_color2*spe*dif*shadowc*fre;\n        }\n\n        // extra fill\n        {\n            const vec3 lig = vec3(-0.707, 0.000, -0.707);\n            float dif = clamp(0.5+0.5*dot(lig, nor), 0.0, 1.0);\n            mate = vec3(0, 1, 0);\n            col += mate* 1.5*vec3(0.14, 0.14, 0.14)*dif*occ;\n        }\n\n        // fake SSS\n        {\n            float fre = clamp(1.+dot(rd, nor), 0.0, 1.0);\n            mate = skybox;\n            col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\n        }\n\n        col = applyFog(col, skybox, t);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCoord = fragCoord.xy;\n    float t = iTime;\n    vec4 c = 0.45*cos(vec4(0.5, 3.9, 1.4, 1.1) + t*vec4(1.2, 1.7, 1.3, 2.5)) - vec4(0.3, 0.0, 0.0, 0.0);\n\n    // camera\n\n    float camTrackRadius = 3.0 + sin(t);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 camPos = vec3(camTrackRadius * cos(t), 1.0 + 0.5 * sin(t * 0.5), camTrackRadius * sin(t));\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n\n    float fPersp = 2.0;\n\n    // render\n    vec3 col = vec3(0.0);\n    for (int j=0; j<AA; j++) {\n        for (int i=0; i<AA; i++) {\n            vec2 offf = vec2(float(i), float(j))/float(AA);\n            vec2 result = 2.0 * ((screenCoord + offf) / iResolution.xy - 0.5);\n            result.x *= iResolution.x/iResolution.y;// Correct for aspect ratio\n            vec2 p = result;\n            vec3 vDir = normalize(p.x * camRight + p.y * camUp + camForward * fPersp);\n            col += render(camPos, vDir, c);\n        }\n    }\n    col /= float(AA*AA);\n    col = pow(col, vec3(1.0 / 2.2));\n\n    vec2 uv = screenCoord.xy / iResolution.xy;\n    col *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.25);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI_2 6.283185307179586476925286766559\n\n// hard clipping distortion\nfloat dist(float s, float d) {\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\nvec2 dist(vec2 s, float d) {\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\nvec2 note(float t, float m) {\n    return vec2( sin(6.2831*440.0*t * m)*exp(-3.0*t * m));\n}\n\n// quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s / c) * c;\n}\n\n// hash\nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n\t//return fract(sin(x * 110.082) * 13485.8372);\n}\nfloat nse_slide(float x)\n{\n\tfloat fl = floor(x);\n\treturn mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// heavy 909-ish bassdrum\nfloat kick(float t)\n{\n\tt = fract(t / 4.0) * 0.5;\n\tfloat aa = 5.0;\n\tt = sqrt(t * aa) / aa;\n\t\n\tfloat amp = exp(max(t - 0.15, 0.0) * -10.0);\n\tfloat v = sin(t * 100.0 * PI_2) * amp;\n\tv = dist(v, 4.0) * amp;\n\tv += nse(quan(t, 0.001)) * nse(quan(t, 0.00001)) * exp(t * -20.0) * 2.5;\n\treturn v;\n}\n\n// 909-ish open hihat\nfloat hat(float t)\n{\n\tt = fract(t / 4.0) * 0.5;\n\tfloat aa = 4.0;\n\t//tb = sqrt(tb * aa) / aa;\n\treturn nse(sin(t * 4000.0) * 0.0001) * smoothstep(0.0, 0.01, t - 0.25) * exp(t * -5.0);\n}\n\n// oldschool explosion sound fx\nfloat expl(float t)\n{\n\t//tb = fract(tb / 4.0) * 0.5;\n\tfloat aa = 20.0;\n\tt = sqrt(t * aa) / aa;\n\t\n\tfloat amp = exp(max(t - 0.15, 0.0) * -10.0);\n\tfloat v = nse(quan(mod(t, 0.1), 0.0001));\n\tv = dist(v, 4.0) * amp;\n\treturn v;\n}\n\nfloat _filter(float h, float cut, float res)\n{\n\tcut -= 20.0;\n\tfloat df = max(h - cut, 0.0), df2 = abs(h - cut);\n\treturn exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\n// note number to frequency\nfloat ntof(float n) {\n\treturn 440.0 * pow(2.0, (n - 69.0) / 12.0);\n}\n\n// number of synthesized harmonics (tune for quality/preformance)\n#define NSPC 256\n// tb303 core\nvec2 synth(float tseq, float t)\n{\n\tvec2 v = vec2(0.0);\n\t\n\tfloat tnote = fract(tseq);\n\tfloat dr = 0.26;\n\tfloat amp = 1.0;//smoothstep(0.05, 0.0, abs(tnote - dr - 0.05) - dr) * exp(tnote * -1.0);\n\tfloat seqn = nse(floor(tseq));\n\t//float seqn = nse_slide(tseq);\n\tfloat n = 20.0 + floor(seqn * 38.0);//50.0 + floor(time * 2.0);\n\tfloat f = ntof(n);\n\t\n    float sqr = smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n    \n\tfloat base = f;//50.0 + sin(sin(t * 0.1) * t) * 20.0;\n\tfloat flt = exp(tnote * -1.5) * 50.0 + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n\tfor(int i = 0; i < NSPC; i ++)\n\t{\n\t\tfloat h = float(i + 1);\n\t\tfloat inten = 1.0 / h;\n\t\t//inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * PI_2) * 0.9 + 0.1;\n\t\t\n\t\tinten = mix(inten, inten * mod(h, 2.0), sqr);\n\t\t\n\t\t//inten *= exp(-1.0 * max(2.0 - h, 0.0)) + exp(abs(h - flt) * -2.0) * 8.0;\n\t\t\n\t\t//inten *= _filter(h, flt, 4.0);\n\t\t\n\t\tfloat phase_offset = 0.01;\n\t\tv.x += inten * sin((PI_2 + phase_offset) * (t * base * h));\n\t\tv.y += inten * sin(PI_2 * (t * base * h));\n\t}\n\t\n\t\n\tfloat o = v.x * amp;//exp(max(tnote - 0.3, 0.0) * -5.0);\n\t\n\t//o = dist(o, 2.5);\n\t\n\treturn vec2(dist(v * amp, 2.0));\n}\n\nvec2 synth1_echo(float tb, float time)\n{\n    vec2 v;\n    v = synth(tb, time) * 0.5;// + synth2(time) * 0.5;\n\t//float ec = 0.4, fb = 0.6, et = 2.0 / 9.0, tm = 2.0 / 9.0;\n\t//v += synth(tb, time - et) * ec * vec2(1.0, 0.5); ec *= fb; et += tm;\n\t//v += synth(tb, time - et).yx * ec * vec2(0.5, 1.0); ec *= fb; et += tm;\n\t//v += synth(tb, time - et) * ec * vec2(1.0, 0.5); ec *= fb; et += tm;\n\t//v += synth(tb, time - et).yx * ec * vec2(0.5, 1.0); ec *= fb; et += tm;\n\t\n    return v;\n}\n\nvec2 mainSound( in int samp, float time ) {\n    vec2 mx = vec2(0.0);\n    \n    float tb = mod(time * 9.0, 16.0);\n    \n    float hi = 1.0;\n    //float ki = smoothstep(0.01, 0.0, abs(mod(time * 9.0, 256.0) - 64.0 - 128.0) - 64.0);\n    float ki = mod(time * 9.0, 16.0);\n   \n    hi = ki;\n    \n    mx += synth1_echo(tb, time);\n    //mx += vec2(hat(tb) * 1.5) * hi;\n    \n\t//mx += vec2(k);\n    //mx += kick(time * 9.0 + time * 9.0 * (1.0 + sin(time / 4.0)));// * clamp(sin(PI_2 * tb / 16.0), 0.0, 1.0);\n\t\n    //mx += vec2(expl(tb));\n    mx += vec2(hat(mod(time * 9.0, 16.0)));\n    mx *= (0.5 + fract(tb / 4.0) * 0.5);\n    \n    float sc = sin(PI_2 * tb) * 0.6 + 0.4;\n    //mx += vec2(kick(tb)) * 0.8 *  sc;\n    \n    // A 440 Hz wave that attenuates quickly overt time\n    //mx += note(tb,1.0);\n    //mx += note(tb/2.0,3.0);\n    //    mx += note(tb/3.0,5.0);\n    //    mx += note(tb/4.0,7.0);\n    \n    //mx = dist(mx, 1.0);\n    return mx;\n}","name":"Sound","description":"","type":"sound"}]}