{"ver":"0.1","info":{"id":"tlXcD8","date":"1591942569","viewed":349,"name":"Basic Concentric Circles","username":"kowbell","description":"This pattern is useful for all sorts of neat effects, and it's fun to look at. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle","concentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * You can fullscreen the shader, right click, and Save/View in browser!\n *\n *\n * This work is licensed under a Creative Commons 0 License.\n * No Rights Reserved, public Domain, etc.\n */\n\n// 1 = landscape orientation, 0 = portrait orientation\n#define LANDSCAPE 1\n\n#define RING_WIDTH 0.002\n#define RING_COLOR_A vec4(1., 1., 1., 1.)\n#define RING_COLOR_B vec4(0., 0., 0., 1.)\n\n#define AA_SHARPNESS 1.5\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //// Find min axis, define the center ///////////////////////////////////////////////\n    // we don't want to stretch the circles \n    // when the viewport is rectangular!\n#if (LANDSCAPE)\n    float resConstraint   = iResolution.x;\n    float centerShortAxis = (iResolution.y / resConstraint) / 2.0;\n    vec2 center = vec2(.5, centerShortAxis);\n#else // PORTRAIT\n    float resConstraint   = iResolution.y;\n    float centerShortAxis = (iResolution.x / resConstraint) / 2.0;\n    vec2 center = vec2(centerShortAxis, .5);\n#endif\n    // Uncomment this to instead focus the circle \n    // around the mouse while you click\n    //center = iMouse.xy / resConstraint;\n    \n    \n    //// Normalize the coordinates ///////////////////////////////////////////////\n    // For landscape images, x ∈ [0, 1], y ∈ [0, y resolution / x resolution]\n    // For portrait images,  y ∈ [0, 1], x ∈ [0, x resolution / y resolution]\n    // e.g. at 1080p landscape, y max is 1080 / 1920 = 0.5625\n\tvec2 uv = fragCoord / resConstraint;\n    \n    \n    //// Calculate the rings /////////////////////////////////////////////////////\n    float dist = distance(uv,center);\n    float ring = dist / RING_WIDTH;\n    \n    \n    //// Anti-Aliasing ///////////////////////////////////////////////////////////\n    // Anti-aliasing relies on circle sizes\n    float aaSharpness = AA_SHARPNESS * RING_WIDTH;\n    // Don't screw up sharpness based on resolution\n    aaSharpness = aaSharpness * resConstraint;\n    float smoothRing = ( (sin(ring) * aaSharpness) + 1. ) / 2.;\n    \n    \n    //// Use RING_COLORs /////////////////////////////////////////////////////////\n    fragColor = mix(RING_COLOR_A, RING_COLOR_B, smoothRing);\n}","name":"Image","description":"","type":"image"}]}