{"ver":"0.1","info":{"id":"ldGyz3","date":"1522757605","viewed":399,"name":"Toon Teapot - Edge Detection","username":"nawafuji","description":"Tested edge detection","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 mat2Rot;\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\n\nvec2 getDeltas(sampler2D buffer, vec2 uv) {\n  vec2 pixel = vec2(1. / iResolution.xy);\n  vec3 pole = vec3(-1, 0, +1);\n  float dpos = 0.0;\n  float dnor = 0.0;\n    \n  vec4 s0 = texture(iChannel0, uv + pixel.xy * pole.xx); // x1, y1\n  vec4 s1 = texture(iChannel0, uv + pixel.xy * pole.yx); // x2, y1\n  vec4 s2 = texture(iChannel0, uv + pixel.xy * pole.zx); // x3, y1\n  vec4 s3 = texture(iChannel0, uv + pixel.xy * pole.xy); // x1, y2\n  vec4 s4 = texture(iChannel0, uv + pixel.xy * pole.yy); // x2, y2\n  vec4 s5 = texture(iChannel0, uv + pixel.xy * pole.zy); // x3, y2\n  vec4 s6 = texture(iChannel0, uv + pixel.xy * pole.xz); // x1, y3\n  vec4 s7 = texture(iChannel0, uv + pixel.xy * pole.yz); // x2, y3\n  vec4 s8 = texture(iChannel0, uv + pixel.xy * pole.zz); // x3, y3\n\n  dpos = (\n    abs(s1.a - s7.a) +\n    abs(s5.a - s3.a) +\n    abs(s0.a - s8.a) +\n    abs(s2.a - s6.a)\n  ) * 0.5;\n  dpos += (\n    max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) +\n    max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) +\n    max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) +\n    max(0.0, 1.0 - dot(s2.rgb, s6.rgb))\n  );\n  \n  dpos = pow(max(dpos - 0.5, 0.0), 1.0);\n    \n  return vec2(dpos, dnor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n    vec4 buf = texture(iChannel0, q);\n  \tt = buf.a;\n  \tvec3 nor = buf.rgb;\n  \tvec3 pos = o + t * d;\n    \n    \n    vec3 col = vec3(0.5, 0.8, 1);\n    \n\n    vec2 deltas = getDeltas(iChannel0, q);\n    if (t > -0.5) {    \t\t\n        col = vec3(1.0);\n        col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5))));\n        col *= vec3(1, 0.8, 0.35);\n    }\n    col.r = smoothstep(0.1, 1.0, col.r);\n    col.g = smoothstep(0.1, 1.1, col.g);\n    col.b = smoothstep(-0.1, 1.0, col.b);\n    col = pow(col, vec3(1.1));\n    col -= deltas.x - deltas.y; \n    \n\tfragColor=vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nconst float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\nfloat tMorph;\nmat2 mat2Rot;\n\n// Distance to Bezier\n// inspired by [iq:https://www.shadertoy.com/view/ldj3Wh]\n// calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n// total distance is corrected using pytagore just before return\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}            \n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n\n//#define METHOD_2\n\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n#if defined(METHOD_2)\n  // method 2a variant\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n#else\n    \n  // method 1: ignoring n approaching -z\n#if 1\n  float a =  n.y/(1.0+n.z);\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n    \n#else\n    \n  // nimitz's impl of frisvad\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n#endif\n#endif\n}\n\nfloat teapot(vec3 p){\n    // Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n\t\n\t// !!! The morphing is here !!!\n    return dTeapot;\n}\n\nfloat cube(vec3 p){\n    float s = 0.3;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 2.0;\n}\n\nfloat plane(vec3 p){\n    float s = -1.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\n// Distance to scene\nfloat M(vec3 p) {\n\treturn teapot(p);\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\t//float pitch = .4 * t / iResolution.x;\n\t\n    float eps = 0.01;\n    vec2 d = vec2(-1,1) * eps;\n    \n\tvec3 p0 = p+d.xxx; // tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = M(p0);\n\tfloat f1 = M(p1);\n\tfloat f2 = M(p2);\n\tfloat f3 = M(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\treturn normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n\t//return normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n , x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>4.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), q.y);\n\t\t\n    // Calculate color on point\n\tif (h < .001) {\n\t\tx = o + t * d;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n        \n\t\tfragColor=vec4(n, t);\t\n    }\n    else\n    {\n        t = -1.0;\n        x = o + t * d;\n        n = normal(x,d,t);\n        \n    \tfragColor=vec4(n, t);\t\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"}]}