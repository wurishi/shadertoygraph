{"ver":"0.1","info":{"id":"mlfBWB","date":"1693400038","viewed":240,"name":"sdf_box_line_circle_roundbox","username":"linround","description":"关于sdf的一些计算","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2dsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926\n#define TWO_PI 6.28318530718\n\n\n\n\nvec3 distColor(float dist){\n    vec3 color = dist>0.?vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    color *=1.-exp(-6.*abs(dist));// 这里按照距离球体表面的值 进行颜色衰减\n    color *=(1.+ 0.1*sin(150.*abs(dist)));// 对已有颜色乘以某种周期性的函数\n\n    // smoothstep(0.01,0.,abs(dist)) 距离绝对值大于0.01 的都是0，距离绝对值小于等于0的 结果是1\n    color = mix(color,vec3(1.),smoothstep(0.01,0.,abs(dist))); // 添加上边缘线条\n    return color;\n}\n\n// 中心点为0，半径为r\nfloat sdfCircle(in vec2 st,in float r){\n    vec2 center = vec2(0.);\n    return length(st-center)-r;\n}\n\nvoid renderCircleSDF(in vec2 st,inout vec4 fragColor){\n    float radius = (sin(iTime)+1.)/2.;\n    float v = sdfCircle(st,radius);\n    vec3 color = distColor(v);\n    fragColor = vec4(color,1.0);\n}\n\n\n// a,b为线段的两端点\nfloat sdfLine(in vec2 p,in vec2 a,in vec2 b){\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    float h = dot(ap,ab)/dot(ab,ab);\n    vec2 qp = ap - clamp(h,0.,1.)*ab;\n\n    return length(qp);\n}\n\nvoid renderLineSDF(in vec2 st,inout vec4 fragColor){\n    vec2 a = vec2(sin(iTime),0.5);\n    vec2 b = vec2(0.,sin(iTime));\n    float v = sdfLine(st,a,b);\n    vec3 color = distColor(v);\n    fragColor = vec4(color,1.0);\n}\n\n// 中心点为 （0,0）;长宽为 a\nfloat sdfBox(in vec2 p,in vec2 a){\n    vec2 q = abs(p)-a;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n\nvoid renderBoxSDF(in vec2 st,inout vec4 fragColor){\n    float width = (sin(iTime)+1.)/2.;\n    float height = (cos(iTime)+1.)/2.;\n    vec2 a = vec2(width,height);\n    float v = sdfBox(st,a);\n    vec3 color = distColor(v);\n    fragColor = vec4(color,1.0);\n}\n\nfloat sdfRoundBox(in vec2 p,in vec2 a,in float r){\n    vec2 b = a - vec2(r);\n    vec2 q = abs(p)-b;\n    // 这里求出新的 以b点的sdf\n    // 为了弥补b失去的区域区域\n    // 将计算b区域的计算结果在原有基础上减去r\n    // 这样就能得到 原有坐标范围扩大了对应的r范围\n    return length(max(q,0.))+min(max(q.x,q.y),0.)-r;\n}\nvoid renderRoundBoxSDF(in vec2 st,inout vec4 fragColor){\n    float height = (cos(iTime)+1.)/2.;\n    vec2 a = vec2(0.5,height);\n    float r = 0.1;\n    float v = sdfRoundBox(st,a,r);\n    vec3 color = distColor(v);\n    fragColor = vec4(color,1.0);\n}\n\n// 菱形\nfloat rhombusSDF(in vec2 st,in vec2 range){\n    float height = range.y;\n    float width = range.x;\n    vec2 p =abs(st);\n\n    vec2 a = vec2(0.,height);\n    vec2 b = vec2(width,0.);\n\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 abDir = normalize(ab);\n    float h = clamp( dot(ap,abDir)/dot(abDir,abDir) ,0.,length(ab));\n\n    vec2 qp = ap-h*abDir;\n    float s = sign(abDir.x*ap.y-ap.x*abDir.y);\n    return s*(length(qp));\n}\nvoid renderRhombusSDF(in vec2 st,inout vec4 fragColor){\n    float h = 0.5*(sin(iTime)+1.);\n    float w = 0.5*(cos(iTime)+1.);\n    vec2 range = vec2(h,w);\n    float d = rhombusSDF(st,range);\n    vec3 color = distColor(d);\n    fragColor = vec4(color,1.);\n}\n\n\n\n\nfloat sideSDF(in vec2 p, in vec2 a,in vec2 b){\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 abDir = normalize(ab);\n\n    float h = dot(ap,ab)/dot(ab,ab);\n    vec2 qp = ap-clamp(h,0.,1.)*ab;\n    return length(qp);\n}\n\nbool sameSide(in vec2 uv,in vec3 A,in vec3 B,in vec3 C){\n    vec3 p = vec3(uv,0.);\n    vec3 side = B-A;\n    // 判断p点和C点是否在边的同一侧\n    vec3 n1 = cross(side,C-A);\n    vec3 n2 = cross(side,p-A);\n    if(dot(n1,n2)>=0.){\n        return true;\n    }\n    return false;\n}\nbool inSide(in vec2 st,vec3[3] triangle){\n    if(\n    sameSide(st,triangle[0],triangle[1],triangle[2])&&\n    sameSide(st,triangle[1],triangle[2],triangle[0])&&\n    sameSide(st,triangle[2],triangle[0],triangle[1])\n    ) { return true; }\n    return false;\n}\nfloat d2Cross(in vec2 v1,in vec2 v2){\n    // 叉乘结果大于0 返回1 逆时针\n    // 叉乘结果小于0 返回-1 顺时针\n    return (v1.x*v2.y-v2.x*v1.y);\n}\nfloat triangleSDF(in vec2 st,in vec2 a,in vec2 b,in vec2 c ){\n    float s = sign(d2Cross(b-a,c-b));\n    // 这里再次判断，点是位于外部还是内部，\n    // 外部点 叉积结果 小于0，顺时针；内部点叉积结果大于0，逆时针\n    // 再乘以s，\n    float qp0 = sideSDF(st,a,b);\n\n    float qp1 = sideSDF(st,b,c);\n\n    float qp2 = sideSDF(st,c,a);\n\n    float d = min(qp0,min(qp1,qp2));\n    vec3 triangle[3] = vec3[3](\n    vec3(a,0.),\n    vec3(b,0.),\n    vec3(c,0.)\n    );\n    bool i = inSide(st,triangle);// 判断点是否在三角形内部\n\n\n    return i?-d:d;// 内部为负，外部为正\n}\nvoid renderTriangleSDF(in vec2 st,inout vec4 fragColor){\n    float s = sin(iTime)+1.;\n    float c = cos(iTime)+1.;\n    vec2 v1 = vec2(0.3*s*c,0.5*c);\n    vec2 v2 = vec2(0.5*s,0.4*c);\n    vec2 v3 = vec2(-0.5*s,0.5*s);\n    float d = triangleSDF(st,v1,v2,v3);\n    vec3 color = distColor(d);\n    fragColor = vec4(color,1.);\n}\n\n\nvoid renderTest(in vec2 st,inout vec4 fragColor){\n    vec3 color1 = vec3(1.0,1.0,0.0);\n    vec3 color2 = vec3(.0,0.5,1.0);\n    vec3 color = min(color1,color2);\n    fragColor = vec4(color,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st*= 3.;\n    vec2 area = floor(st);\n    if(area.x == 0.&&area.y ==0. ){\n        st = fract(st);\n        st= st*2.-1.;\n        renderCircleSDF(st,fragColor);\n    }\n    if(area.x == 0.&&area.y ==1. ){\n        st = fract(st);\n        st= st*2.-1.;\n        renderLineSDF(st,fragColor);\n    }\n    if(area.x == 1.&&area.y ==0. ){\n        st = fract(st);\n        st= st*2.-1.;\n        renderBoxSDF(st,fragColor);\n    }\n    if(area.x == 1.&&area.y ==1. ){\n        st = fract(st);\n        st= st*2.-1.;\n        renderRoundBoxSDF(st,fragColor);\n    }\n    if(area.x==2. && area.y == 2.){\n        st = fract(st);\n        st = st*2.-1.;\n        renderRhombusSDF(st,fragColor);\n    }\n    if(area.x==0. && area.y == 2.){\n        st = fract(st);\n        st = st*2.-1.;\n        renderTriangleSDF(st,fragColor);\n    }\n    if(area.x==1. && area.y ==2.){\n        renderTest(st,fragColor);\n    }\n}","name":"Image","description":"","type":"image"}]}