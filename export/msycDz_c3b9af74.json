{"ver":"0.1","info":{"id":"msycDz","date":"1699716574","viewed":170,"name":"Texture distortion for lava","username":"binzero","description":"Just a texture distortion showcase.  extracted from  https://www.shadertoy.com/view/sdBGWh","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["noise","distortion","lava","blackbody","magma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Texture distortion for lava. extracted from : https://www.shadertoy.com/view/sdBGWh\n\n    BufferA: R - Perlin noise FBM for lava height map\n    BufferB: Blackbody spectrum\n   \n*/\n\n#define SHADING_SIMPLE\n\nconst vec2 DETAIL_SCALE = vec2(0.4);\nconst float DETAIL_EPSILON = 2e-3;\nconst float DISTORED_STRENGTH = 0.25;\nconst float DISTORED_SPEED = 0.25;\n\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\n//----------------------------- Noise -----------------------------\n\nfloat sampleLavaNoise(vec2 uv)\n{\n\n   float a = iResolution.x/iResolution.y;\n   uv.x *= a;\n   return texture(iChannel0, uv).x;\n}\n\nfloat sampleFade(vec2 uv)\n{\n    return texture(iChannel0, uv).y;\n}\n\nvec3 sampleSpectrum(float d)\n{ \n   return  texture(iChannel1, vec2(d,0)).rgb;\n}\n\n\n\n//----------------------------- Texture distortion -----------------------------\n\n// Find the local gradients in the X and Y directions which we use as the velocities \n// of the texure distortion\nvec2 getGradient(vec2 uv){\n\n    float scale = 0.1;\n    float delta = 1e-1;\n    \n    uv *= scale;\n    \n    float data = sampleLavaNoise(uv);\n    float gradX = data - sampleLavaNoise(uv-vec2(delta, 0.0));\n    float gradY = data - sampleLavaNoise(uv-vec2(0.0, delta));\n    \n    return vec2(gradX, gradY);\n}\n\n// https://catlikecoding.com/unity/tutorials/flow/texture-distortion/\nfloat getDistortedTexture(vec2 uv)\n{\n    float strength = DISTORED_STRENGTH;\n    \n    // The texture is distorted in time and we switch between two texture states.\n    float time = DISTORED_SPEED * iTime;\n\n    float f = fract(time);\n    \n    // Get the velocity at the current location\n    vec2 grad = getGradient(uv);\n    vec2 distortion = strength * vec2(grad.x, grad.y);\n    \n    // Get two shifted states of the texture distorted in time by the local velocity.\n    // Loop the distortion from 0 -> 1 using fract(time)\n    \n    float distort1 = sampleLavaNoise((uv + f * distortion));\n    float distort2 = sampleLavaNoise(0.1 + uv + fract(time + 0.5) * distortion);\n\n    // Mix between the two texture states to hide the sudden jump from 1 -> 0.\n    // Modulate the value returned by the velocity to make slower regions darker in the final\n    // lava render.\n    return (1.0-length(grad)) * (mix(distort1, distort2, abs(1.0 - 2.0 * f)));\n}\n\n// Glow from magma\nvec3 getEmissive(vec2 uv)\n{\n    // The depressions in the texture where we want to have glowing magma.\n    float depth = 1.0 - (length(vec3(getDistortedTexture(DETAIL_SCALE * uv))));\n    \n    depth *= 1.6; //(sin(uv.x * 0.5 + iTime) + 1.) * 0.5 * 1.6;\n    depth = clamp(depth, 0., 1.);\n    \n    //vec3 glow = 0.2 * texture(iChannel1, vec2(depth)).rgb;\n    vec3 glow = 0.2 * sampleSpectrum(depth).rgb;\n    return glow;\n\n}\n\n//----------------------------- Normal mapping -----------------------------\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal)\n{\n\n    float detail = 0.5 * length(getDistortedTexture(p.xy));\n    \n    return p + detail * normal;\n}\n\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2)\n{\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// Return the normal after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal)\n{\n\n    vec3 tangent;\n    vec3 bitangent;\n    \n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    vec3 delTangent = vec3(0);\n    vec3 delBitangent = vec3(0);\n    \n    for(int i = 0; i < 2; i++){\n        \n        //i to  s\n        //0 ->  1\n        //1 -> -1\n        float s = 1.0 - 2.0 * float(i&1);\n    \n        delTangent += s * getDetailExtrusion(p + s * tangent * DETAIL_EPSILON, normal);\n        delBitangent += s * getDetailExtrusion(p + s * bitangent * DETAIL_EPSILON, normal);\n\n    }\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n\n//----------------------------- Shading -----------------------------\n\nvec3 shadingSimple(vec3 position, vec3 normal, vec3 ro, vec3 rayDir)\n{\n    float diffuseStrength = 0.025;\n    float specularStrength = 0.02;\n    float shininess = 8.0;\n    \n    vec3 diffuseColour = vec3(1.5);\n    vec3 specularColour = vec3(1);\n    \n    vec3 lightDirection = normalize(ro - rayDir * 2.);\n    \n    // How much a fragment faces the light\n    float diff = max(dot(lightDirection, normal), 0.);\n    \n    vec3 diffuse = diff * diffuseColour;\n    \n    vec3 halfWayDir = normalize(lightDirection - rayDir);\n    \n    float spec = pow(max(dot(normal, halfWayDir), 0.0), shininess);\n    \n    // Colour of light sharply reflected into the camera\n    vec3 specular = spec * specularColour;\n    \n    vec3 result = vec3(0.0); \n    \n    result = diffuseStrength * diffuse + specularStrength * specular;\n    \n    return  result;\n}\n\n\n//----------------------------- Main Image -----------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iMouse.z > 0.)\n    {\n        uv += (iMouse.zw - iMouse.xy) * 0.001;\n    }\n\n\n    vec3 col = vec3(0.0);\n    \n    #ifdef SHADING_SIMPLE\n    // Define a ray.\n    vec3 ro = vec3(0.,0.75, 0.0);\n    vec3 rd = vec3(0., 0., -1.);\n    \n    // Define a quad\n    vec2 size = vec2(DETAIL_SCALE);\n    vec3 pos = vec3(size * uv, 0.);\n    vec3 normal =  vec3(0., 0., 1.0);\n    \n     // Shading\n    vec3 detailNomal = getDetailNormal(pos, normal);\n    col = shadingSimple(pos, detailNomal, ro, rd);\n    \n    #endif\n    \n    col += getEmissive(uv);\n    \n    \n    // Uncomment to see noise texture\n    //col = texture(iChannel0, fragCoord.xy/iResolution.xy).rrr;\n    //col = vec3(sampleLavaNoise(fragCoord.xy/iResolution.xy));\n    \n     // Tonemapping\n    col = ACESFilm(col);\n    \n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    // Uncomment to see detail normal color\n    //col = ((detailNomal/ 2.) + 0.5f);\n    \n    fragColor = vec4(col,1.0);\n    \n \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Perlin noise FBM for heightmap and Worley noise for texture fade out control.\n\n// GLSL version of 2D periodic seamless perlin noise.\n// https://github.com/g-truc/glm/blob/master/glm/gtc/noise.inl\n\nvec4 taylorInvSqrt(vec4 r){\n    return 1.79284291400159-0.85373472095314*r;\n}\n\nvec4 mod289(vec4 x){\n  return x-floor(x*(1.0/289.0))*289.0;\n}\n\nvec4 permute(vec4 x){\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec2 fade(vec2 t){\n  return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlin(vec2 Position, vec2 rep){\n    vec4 Pi = floor(vec4(Position.x, Position.y, Position.x, Position.y)) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(vec4(Position.x, Position.y, Position.x, Position.y)) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, vec4(rep.x, rep.y, rep.x, rep.y)); // To create noise with explicit period\n    Pi = mod(Pi, vec4(289)); // To avoid truncation effects in permutation\n    vec4 ix = vec4(Pi.x, Pi.z, Pi.x, Pi.z);\n    vec4 iy = vec4(Pi.y, Pi.y, Pi.w, Pi.w);\n    vec4 fx = vec4(Pf.x, Pf.z, Pf.x, Pf.z);\n    vec4 fy = vec4(Pf.y, Pf.y, Pf.w, Pf.w);\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = float(2) * fract(i / float(41)) - float(1);\n    vec4 gy = abs(gx) - float(0.5);\n    vec4 tx = floor(gx + float(0.5));\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(vec2(Pf.x, Pf.y));\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return float(2.3) * n_xy;\n}\n\nfloat hash(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\n// From Shadertoy somewhere but not sure where originally.\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0 - 2.0 * f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(\n\tmix(\n       \tmix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x),\n\t\tf.y),\n\tmix(\n\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\tf.y),\n\tf.z);\n}\n\nfloat TILES = 1.0;\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - noise(mod(tp, numCells / TILES));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn 1.0 - clamp(d, 0.0, 1.0);\n}\n\nfloat fbm(vec2 pos, vec2 scale){\n    float res = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float sum = 0.0;\n    \n    int limit = 5;\n    \n    for(int i = 0; i < limit; i++){ \n        float offset = float(limit-i);\n        res += perlin(freq*(pos+offset), freq*scale) * amp;\n\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return res/float(limit);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    float scale = 32.0;\n\n        // For seamless texture, UV scale has to match rep\n     float noise = perlin(scale*uv, vec2(scale));\n     noise = 0.5+0.5*(fbm(scale*uv, vec2(scale)));\n\n     //scale =2.0;\n     //float worley = worley(scale*vec3(uv, 0.0), (scale));\n        \n     //col = vec3(noise, worley, 0.0);\n     col = vec3(noise,  0.0, 0.0);\n    \n     // Output to screen\n     fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Blackbody radiation spectrum. \n    Does not match other spectra seen online. Seems about 500K off.\n    Some images show 1300C as bright white whereas images of lava vary from red to bright\n    yellow. Exposure and adaption seems to affect the look a lot.\n    Comments and critique are very welcome.\n\n    Based on:\n    \n    https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n    https://scipython.com/blog/converting-a-spectrum-to-a-colour/\n    https://www.fourmilab.ch/documents/specrend/\n    https://en.wikipedia.org/wiki/Black-body_radiation\n    https://en.wikipedia.org/wiki/Planck%27s_law\n    https://en.wikipedia.org/wiki/Draper_point\n    https://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law\n\n    https://www.shadertoy.com/view/MdBSRW\n    https://www.shadertoy.com/view/llSyRD\n    https://www.shadertoy.com/view/lsKczc\n*/\n\n// In C\nfloat MAX_TEMP = 2500.0;\n\n// The Draper point is the limit above which all solids glow with visible light\nfloat draperPoint = 525.0;\n\n// Given a temperature T, return the spectral radiance for wavelength lambda\nfloat planck(float T, float wavelength){\n\n    // Wavelength in metres\n    float wlm = wavelength * 1e-9;\n    \n    return (3.74183e-16 / pow(wlm, 5.0)) / (exp(1.4388e-2 / (wlm * T)) - 1.0);\n}\n\nconst mat3 XYZ_RGB_Matrix = (mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n));\n\nvec3 XYZToRGB(vec3 XYZ){\n    return XYZ_RGB_Matrix * XYZ;\n}\n\nvec3 spectrumToXYZ(float T){\n\n    // http://www.cie.co.at/technical-work/technical-resources\n    vec3 standardObserver1931[] =\n        vec3[] (\n        vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n        vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n        vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n        vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n        vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n        vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n        vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n        vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n        vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n        vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n        vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n        vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n        vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n        vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n        vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n        vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n        vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n        vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n        vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n        vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n        vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n        vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n        vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n        vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n        vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n        vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n        vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n        vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n        vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n        vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n        vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n        vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n        vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n        vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n        vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n        vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n        vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n        vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n        vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n        vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n        vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n        vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n        vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n        vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n        vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n        vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n        vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n        vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n        vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n        vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n        vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n        vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n        vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n        vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n        vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n        vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n        vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n        vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n        vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n        vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n        vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n        vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n        vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n        vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n        vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n        vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n        vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n        vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n        vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n        vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n        vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n        vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n        vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n        vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n        vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n        vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n        vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n        vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n        vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n        vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n        vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n    );\n    int size = 81;\n    \n    vec3 XYZ = vec3(0);\n    \n    for (int i = 0; i < size; i++){\n    \n        float radiance = planck(T, 380.0 + float(i) * 5.0);\n        \n        XYZ += radiance * standardObserver1931[i];\n        \n    }\n\n    return XYZ;\n}\n\nvec3 constrainRGB(vec3 col){\n\n    float w = -min(col.r, min(col.g, col.b));\n    \n    if (w > 0.0) {\n        col += w;\n    }\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    // bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n     float T;\n\n     T = 0.25 * draperPoint + uv.x * MAX_TEMP;\n\n     // C to K\n     T += 273.15;\n     MAX_TEMP += 273.15;\n     draperPoint += 273.15;\n\n     col = spectrumToXYZ(T);\n        \n \n     col = XYZToRGB(col);\n\n     col = constrainRGB(col);\n\n     float largest = max(max(col.r, col.g), col.b);\n     col /= largest > 0.0 ? largest : 1.0;\n\n     // The Stefanâ€“Boltzmann law gives the luminosity of a black body from its temperature\n     // The amount of radiance emitted is proportional to the 4th power of the temperature\n     float luminosity = 5.670374419e-8 * pow(T, 4.0);\n     float minLuminosity = 5.670374419e-8 * pow(draperPoint*0.25, 4.0);\n     float maxLuminosity = 5.670374419e-8 * pow(MAX_TEMP, 4.0);\n\n     // Pretty hacky\n     float EXPOSURE = 60.0;\n\n     col *= EXPOSURE * max(0.0,(luminosity-minLuminosity) / (maxLuminosity-minLuminosity));\n    \n     fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}