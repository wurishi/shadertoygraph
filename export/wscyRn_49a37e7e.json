{"ver":"0.1","info":{"id":"wscyRn","date":"1600245656","viewed":485,"name":"Specular roughness v2","username":"athibaul","description":"Trying out some more image-based lighting, using custom materials.\n","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["bumpmapping","imagebasedlighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// IMAGE-BASED LIGHTING OF CUSTOM MATERIALS\n// Alexis THIBAULT - 09/2020\n\n\n#define MIN_BLUR 1.\n#define MAX_BLUR 64.\n#define GAMMA 2.2\n\n\n\n\n// The material model is inspired from\n// https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// \"Metallic\" and \"roughness\" range from 0 to 1 and are\n// approximately perceptually linear.\nstruct Material\n{\n    vec3 baseColor;\n    float metallic;\n    float roughness;\n};\n  \nconst vec3 DIELECTRIC_F0 = vec3(0.04);\n\n// Some examples of materials\nconst Material CHROME = Material(vec3(0.9,0.92,0.95), 1.0, 0.0);\nconst Material RED_PLASTIC = Material(vec3(0.95,0.3,0.2), 0.0, 0.1);\nconst Material RED_METAL = Material(vec3(0.95,0.3,0.2), 1.0, 0.2);\nconst Material BLUE_GRIME = Material(vec3(0.0,0.4,0.7), 0.0, 1.0);\nconst Material BLACK_PLASTIC = Material(vec3(0), 0.0, 0.0);\nconst Material GREEN_PLASTIC = Material(vec3(0.2,0.9,0.2), 0.0, 0.6);\n\n// Materials can be blended together, e.g. for layering.\nMaterial matmix(Material a, Material b, float x)\n{\n    return Material(mix(a.baseColor, b.baseColor, x),\n                    mix(a.metallic, b.metallic, x),\n                    mix(a.roughness,  b.roughness, x));\n}\n\n// Image-based lighting trick by reinder:\n// To approximate the integrated specular lobe in\n// environment maps, we can use them with\n// varying levels of detail.\n// https://www.shadertoy.com/view/lscBW4\nvec3 getSpecularLightColor( vec3 rd, float roughness )\n{\n    roughness = clamp(roughness, 0.0, 1.0);\n    float lod = log2(mix(MIN_BLUR, MAX_BLUR, roughness));\n    // The large cubemap does not capture well high-intensity lights,\n    // so mix it with the small version.\n    vec3 t0 = pow(textureLod(iChannel0, rd.xzy, lod).rgb, vec3(GAMMA));\n    vec3 t1 = pow(textureLod(iChannel1, rd.xzy, lod).rgb, vec3(GAMMA));\n    vec3 col = mix(t0, t1, roughness);\n    // White balance\n    vec3 wb = pow(vec3(205.,159.,147.)/255.,vec3(-GAMMA));\n    return 3.0*wb*col;\n}\n\nvec3 getDiffuseLightColor( vec3 rd )\n{\n    // So yeah, we don't really have a diffuse model\n    return getSpecularLightColor(rd, 1.0);\n}\n\n\nfloat map(vec3 p);\n\n// Ambient Occlusion computation stolen from iq\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.5 ) break;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\n\nvec3 renderMaterial( vec3 p, vec3 rd, vec3 normal, Material mat )\n{\n    vec3 diffuseBaseColor = mix(mat.baseColor, vec3(0), mat.metallic);\n    vec3 diffuseCol = getDiffuseLightColor(normal) * diffuseBaseColor;\n    vec3 specularCol = getSpecularLightColor(reflect(rd, normal), mat.roughness);\n    vec3 F0 = mix(DIELECTRIC_F0, mat.baseColor, mat.metallic);\n    vec3 fre = F0 + (1.0-F0)*pow(clamp(1.0-dot(-rd,normal),0.0,1.0), 5.0);\n    vec3 col = mix(diffuseCol, specularCol, fre);\n    \n    // Add ambient occlusion for more convincing lighting\n    // (bouncing rays would be better)\n    float ao = calcAO(p, normal);\n    return col*ao;\n}\n\n\nfloat map( vec3 p )\n{\n    p.xy = mod(p.xy+0.5, 1.0)-0.5;\n    float d = length(p)-0.4;\n    d = min(d, p.z+0.41);\n\treturn d;\n}\n\nfloat bump( vec3 p )\n{\n    if(p.z > -0.4)// && mod(p.x-0.5, 2.0) < 1.0)\n        return 0.;\n    p = vec3(p.x+p.z, sqrt(2.)*p.y, p.x-p.z);\n    p = vec3(p.x+p.y, p.x-p.y, sqrt(2.)*p.z);\n    p = fract(p*4.);\n    float d = length(p - 0.5);\n    d = d*d;\n    return -d*0.002;\n}\n\nfloat bumpMap( vec3 p )\n{\n    return map(p) - bump(p);\n}\n\n\nvec3 calcNormal( vec3 p, float eps )\n{\n    //float eps = 1e-3;\n    vec2 e = eps*vec2(1,-1);\n    return normalize(\n          e.xxx*bumpMap(p+e.xxx)\n        + e.xyy*bumpMap(p+e.xyy)\n        + e.yxy*bumpMap(p+e.yxy)\n        + e.yyx*bumpMap(p+e.yyx));\n}\n\n\nMaterial getMaterial( vec3 p )\n{\n    \n    Material mat;\n\n    mat = Material(vec3(0.5),0.,0.);\n    mat.metallic = 1.0-step(0.0,p.y);\n    mat.roughness = smoothstep(-3.0,3.0,p.x);\n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.x;\n    \n    float th = iTime * 0.2;\n    vec3 ro = vec3(4.0*sin(th), -4.0*cos(th), 3.0+2.0*sin(th*1.618));\n    //vec3 ro = vec3(0.0,-3.0+2.0*sin(th),6.0 + 2.0*cos(th));\n    vec3 target = vec3(0);\n    vec3 camFwd = normalize(target-ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    float fov = 0.5;\n    vec3 rd = normalize(camFwd + fov*(uv.x*camRight + uv.y * camUp));\n    \n    vec3 col;\n    \n    float d;\n    float t=0.0;\n    for(int i=0;i<256;i++)\n    {\n        d = map(ro+t*rd);\n        if(d < 0.001 || t > 100.) break;\n        t += d;\n    }\n    \n    if(t < 100.)\n    {\n        vec3 p = ro+t*rd;\n        vec3 normal = calcNormal(p, 0.001);\n        Material mat = getMaterial(p);\n        col = renderMaterial(p, rd, normal, mat);\n    }\n    else\n    {\n        // We didn't hit anything, return world color\n        col = getSpecularLightColor(rd, 0.0);\n    }\n    \n    col = pow(col, vec3(1.0/GAMMA));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}