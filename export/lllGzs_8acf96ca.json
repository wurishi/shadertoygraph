{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\t\n\tAll Code stolen from \n\thttps://www.shadertoy.com/view/Mdl3Rr\n\n\tand\n\t\n\thttps://iquilezles.org/www/index.htm\n\thttps://www.shadertoy.com/user/iq\n\n\tand\n\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n#define time iTime\n\n\nconst vec3 lightColor = vec3( 1. , .8 , .2 );\nconst vec3 skyColor = vec3( .2 , .3 , .4 ); // .1 , .2 , .3 \nconst float PI = 3.14159;\n   \n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+time*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat fogmap(in vec3 p , float d )\n{\n    //p.x += time*.0005;\n   // p.z += sin(p.x*.00005);\n    return triNoise3d(p*2.2/(d * 20.),0.2);\n}\n\n\n// Robert Cupisz 2013\n// Creative Commons Attribution-ShareAlike 3.0 Unported\n//\n// Bits of code taken from Inigo Quilez, including fbm(), impulse()\n// and friends, sdCone() and friends; also box() by Simon Green.\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n#define ROOFPOS vec3(0,-1,0.01)\n\n\nvec4 spherePos[10];\nvec4 roofPos[9];\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\n\n// rd doesn't have to be normalized\nfloat sphere(vec3 ro, vec3 rd, float r)\n{\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - r * r;\n\tfloat a = dot(rd, rd);\n\t// Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif (c > 0.0 && b > 0.0)\n\t\treturn INF;\n\tfloat discr = b*b - a*c;\n\t// A negative discriminant corresponds to ray missing sphere\n\tif (discr < 0.0)\n\t\treturn INF;\n\t// Ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat t = - b - sqrt(discr);\n\tt /= a;\n\t// If t is negative, ray started inside sphere so clamp t to zero\n\tt = max(0.0, t);\n\treturn t;\n}\n\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\n\n// frustum inscribed in a unit cube centered at 0\n#define INF 1.0e38\nfloat frustum(vec3 org, vec3 dir, float apex, vec3 size, out float far)\n{\n\tvec2 dirf = vec2(0.5 - apex, 0.5); \n\tvec3 tbot, ttop;\n\t\n\t// intersection with near and far planes\n\tfloat invdirx = 1.0 / dir.x;\n\ttbot.x = invdirx * (-0.5*size.x - org.x);\n\tttop.x = invdirx * (0.5*size.x - org.x);\n\n\tfloat temp = dirf.y * (org.x-apex);\n\t\n\t// intersection with inclined planes on y\n\ttbot.y = size.y * (-temp - dirf.x * org.y) / (dirf.x * dir.y + dirf.y * dir.x);\n\tttop.y = size.y * ( temp - dirf.x * org.y) / (dirf.x * dir.y - dirf.y * dir.x);\n\t\n\t// intersection with inclined planes on z\n\ttbot.z = size.z * (-temp - dirf.x * org.z) / (dirf.x * dir.z + dirf.y * dir.x);\n\tttop.z = size.z * ( temp - dirf.x * org.z) / (dirf.x * dir.z - dirf.y * dir.x);\n\t\n\t// if intersecting behind the apex, set t to ray's end\n\tvec4 tempt = vec4(tbot.yz, ttop.yz);\n\ttempt = mix(tempt, INF * sign(dir.xxxx), step(org.xxxx + tempt * dir.xxxx, vec4(apex)));\n\ttbot.yz = tempt.xy;\n\tttop.yz = tempt.zw;\n\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\n\n\n// Makes brighter near top\nfloat transmittance (vec3 p)\n{\n    /*vec3 o;\n    o.x = sin( iTime ) * .1;\n    o.y = sin( iTime * .5) * 2.1;\n    o.z = sin( iTime * .05) * 20.1;\n\treturn noise( p * o);*/\n    \n    float a = 0.;\n    float mL = 100.;\n    float id = 0.;\n    for( int i = 0; i < 10; i++ ){\n     \n        vec3 dif = spherePos[i].xyz - p;\n        \n       // float n = noise(dif * 5.);\n        float l = length( dif ) - (spherePos[i].w*.9) ;\n        a +=  .2  / (l);\n        \n        if( l < mL ){mL = l; id = float( i );}\n        \n    }\n    \n   \n    a = pow(a,2.) / 20. + 3. * pow(fogmap( p * 1.  + sin(iTime*.1 )* .1 + sin(iTime*.174 )* .2 , clamp( a , 0. , 1.1)*1.3+.5  ),3.);\n    \n    return a;\n    \n}\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\n    for( int i = 0; i < 10; i++ ){\n        vec4 r = spherePos[i];\n\t\tHIT(sphere(ro - r.xyz, rd,r.w));\n    }\n    \n    for( int i = 0; i < 10; i++ ){\n        vec4 r = roofPos[i];\n\t\tHIT(box (ro - r.xyz, rd, vec3(r.w ,.01,r.w)));\n    }\n\n\n\tHIT(box (ro - vec3(0.,-4.,0.), rd, vec3(10.,.01,10.)));\n    /*HIT(box (ro - vec3(0.,-.9,0.), rd, vec3(2.,.05,2.)));\n    HIT(box (ro - vec3(0.,-.6,0.), rd, vec3(1.,.05,1.)));\n    HIT(box (ro - vec3(0.,-.4,0.), rd, vec3(.5,.05,.5)));\n    HIT(box (ro - vec3(0.,0.,0.), rd, vec3(.3,.3,.3)));*/\n    \n    float s = 5.;\n    HIT(box (ro - vec3(s,0.,0.), rd, vec3(.01,2.*s,2.*s)));\n    HIT(box (ro - vec3(-s,0.,0.), rd, vec3(.01,2.*s,2.*s)));\n    HIT(box (ro - vec3(0.,0.,s), rd, vec3(2.*s,2.*s,.01)));\n    HIT(box (ro - vec3(0.,0.,-s), rd, vec3(2.*s,2.*s,.01)));\n    \n \n\n\n\treturn hit;\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal(mat3 camMat , vec2 p, vec3 ro  ){\n    \n    // create view ray\n    vec2 eps = vec2( 0.0001, 0.0 );\n    \n\tvec3 l = normalize( camMat * vec3(p.xy - eps.xy,2.0) ); \n    vec3 r = normalize( camMat * vec3(p.xy + eps.xy,2.0) ); \n    vec3 u = normalize( camMat * vec3(p.xy - eps.yx,2.0) ); \n    vec3 d = normalize( camMat * vec3(p.xy + eps.yx,2.0) ); \n    \n    // raycast the scene\n\tfloat hL = intersect(ro,l);\n\tvec3 pL = ro + hL * l;\n    if( hL == INF ){ return vec3( INF ); }\n        \n    \n     // raycast the scene\n\tfloat hR = intersect(ro,r);\n\tvec3 pR = ro + hR * r;\n    if( hR == INF ){ return vec3( INF ); }\n    \n    // raycast the scene\n\tfloat hU = intersect(ro,u);\n\tvec3 pU = ro + hU * u;\n    if( hU == INF ){ return vec3( INF ); }\n    \n    // raycast the scene\n\tfloat hD = intersect(ro,d);\n\tvec3 pD = ro + hD * d;\n    if( hD == INF ){ return vec3( INF ); }\n    \n    vec3 d1 = pL - pR;\n    vec3 d2 = pU - pD;\n        \n    vec3 nor =cross( d1 , d2 );\n\n\treturn normalize(nor);\n    \n}\n\n#define STEPS 40\nvec3 inscatter ( vec3 origin, vec3 ro, vec3 rd, vec3 roLight , vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n    //float near = frustum(roLight + vec3(0.0, 1.0, 0.0), rdLight,.01, vec3(1.5, 3.0, 1.5), far);\n\tfloat near = box(roLight + origin, rdLight, vec3(4., 30., 4.), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0/float(STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n\tvec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n\t\n\t// add noise to the start position to hide banding\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*0.05;\n\n\tfor(int i = 0; i < STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\tl *= transmittance(pos);\n\t\tlight += l;\n        \n        //include light particles later ?\n\t\t//light += particles(pos)*l;\n\t\tpos += step;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n\treturn light*lightColor;\n}\n\n\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    for( int i =0; i < 10; i++ ){\n\n        float t = (float( i ) / 10. ) * 2. * PI;\n        \t\n        //float t = iTime;\n        float x = (2. +sin( iTime + t * 5. )) * cos( t );\n        float y = mod( iTime * (sin(float(i)*16.12)+2.) * .1 , 10. ) - 5.;//.5 + .1 *sin( iTime + t * 3. );\n        float z = (2. +sin( iTime + t * 5. ))  * sin( t );\n        \n        float r= .2 + .1 * sin( (float(i)+5.) * .01 * iTime);\n\n        //float x = 1. * sin( t *.01* float( i) + t * .9);\n        //float y = 3. * clamp( tan( time *.03* float( i) + time * .09),-4. , 4.  );\n        //float z = 1. * sin( t *.05* float( i) + t * .9);\n    \t\n        spherePos[i] = vec4( x ,  y ,  z , r );\n        \n        \n    }\n    \n    for( int i =0; i < 9; i++ ){\n  \n        float t = (float( i ) / 10. ) * 2. * PI;\n        \t\n        float m = mod( float(i) , 3.);\n        float x = (m - 1. ) *2.2;//(2. +sin( iTime + t * 5. )) * cos( t );\n        float y = 3.5;\n        float z = (floor(float(i)/3.) - 1. ) *2.2;\n        \n    \troofPos[i] = vec4( x ,  2., z , 1. );\n        \n        \n    }\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    \n    // raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n    vec3 col = normalize( hitPos ) * .5 + .5; //vec3( 0. );\n    \n   \n\t// white window\n\tif (hit == INF)\n\t{\n\t\tcol = vec3( 1. , 0. , 0. );\n        \n\n    }else{\n        \n        vec3 n;\n        \n        n.x = noise( hitPos * 10. );\n        n.y = noise( hitPos * 20. );\n        n.z = noise( hitPos * 30. );\n        \n       // col = vec3( n );//.3 * (normalize( hitPos ) * .5 + .5);// vec3( .1 , 0.1 , 0.2 );\n    \tcol = vec3( 0. );\n    }\n     \n    \n    // white window\n\tif (hit == INF)\n\t{\n\t\tfragColor = vec4(0.0);\n\t\treturn;\n\t}\n    \n    vec3 n = calcNormal( camMat , p , ro );\n    \n    if( n == vec3(INF) ){\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    \n    col = vec3( 0.);//vec3(dot( vec3( 0. , 1. , 0. ) , n ));\n    \n\n    /*vec3 roLight = vec3( 0. , 4. , 0. );\n    vec3 rdLight = vec3( 0. , -1. , 0. );\n    vec3 lightDir = normalize( rdLight );\n    \n    col += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);*/\n    \n    // direct light (screw shading!)\n\tvec3 lightRotAxis = vec3(0.707,0,0.707); //1,0,1 normalized\n    \n    \n    float angle = .4;//  + .01 * sin(iTime);\n\tvec2 lightAngleSinCos = vec2(sin(angle), cos(angle));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n\tfloat shadowBias = 1.0e-4;\n\t//vec3 col = vec3(0.0);\n    if (intersect(hitPos + lightDir*shadowBias, lightDir) == INF){\n        \n        vec4 t = texCube(iChannel0, hitPos,  n,10. );\n\n        col = t.xyz * vec3(dot( lightDir , n ));\n    \n\t\t//col = normalize( hitPos ) * .5 + .5;\n        //col = lightColor;\n    }\n\t\n\t// inscatter\n\tlightAngleSinCos.x *= -1.0; // rev angle\n\tvec3 roLight = rot(ro + ROOFPOS, lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n    \n    // The 5 lights\n\tcol += inscatter(vec3( 0. , 1. , 0.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);    \n\n    vec3 c = col;\n    // color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r * 1.5);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.0);\n\tc.b = smoothstep(-0.2, 1.3, c.b);\n    \n \tfragColor = vec4( c , 1. );   \n    \n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lllGzs","date":"1424552173","viewed":445,"name":"SHADE A DAY ( 2 / 21 / 2015 )","username":"cabbibo","description":"making the same scene again. Trying to make light smoke prettier","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""}}