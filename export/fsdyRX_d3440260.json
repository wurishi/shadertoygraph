{"ver":"0.1","info":{"id":"fsdyRX","date":"1659244412","viewed":644,"name":"GO","username":"mu777","description":"shadergo","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["go"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 backgroundColor = vec3(sin(iTime*0.013 + fragCoord.x/iResolution.x),\n                              sin(iTime*0.029 + fragCoord.y/iResolution.y),\n                              cos(iTime*0.7));\n  vec3 outPixel = backgroundColor;\n\n  // Conf values\n  IgoBoardConf ibc = CommonIgoConf(iResolution.xy);\n\n  // boardCoord.xy is pixel, boardCoord.zw is mouse.xy\n  vec2 boardCoord = FragCoordToBoardCoord(fragCoord.xy, iResolution.xy, ibc);\n  ivec2 boardPos = BoardCoordToBoardPos(boardCoord);\n  vec4 currStoneData = FetchBoardData(ivec2(0,0));\n\n  ivec2 mouseBoardPos = BoardCoordToBoardPos(currStoneData.xy);\n  float mouseState = currStoneData.z;\n  bool isBlackTurn = (currStoneData.w == BOARD_STATE_BLACK);\n\n  outPixel = DrawBoard(boardCoord.xy, ibc, outPixel);\n  \n  // Draw candidate stone\n  if(mouseState == MOUSE_PRESSING){\n    outPixel = DrawStone(boardCoord.xy, mouseBoardPos.xy, ibc, \n                         isBlackTurn, outPixel, 0.6);\n  }\n\n  // Draw current stone\n  if(IsInBoard(boardCoord, ibc, 0.0)){    \n    float boardState = FetchBoardData(boardPos).w;\n    if(boardState == BOARD_STATE_BLACK || boardState == BOARD_STATE_WHITE){\n      outPixel = DrawStone(boardCoord.xy, boardPos.xy, ibc, \n                           boardState == BOARD_STATE_BLACK, outPixel, 0.0);\n    }\n  }\n  \n  vec4 agehamaCache = FetchBoardData(GetAgehamaDataPos(ibc));\n  ivec2 luScrBoadPos = BoardCoordToBoardPos(ibc.screenRectInBoardCoord.xy);\n  ivec2 rbScrBoadPos = BoardCoordToBoardPos(ibc.screenRectInBoardCoord.zw);\n  if(boardPos.x >= 21 && boardPos.x <= rbScrBoadPos.x \n     && (rbScrBoadPos.x-21+1)*(rbScrBoadPos.y-boardPos.y) + (rbScrBoadPos.x-boardPos.x) < int(agehamaCache.x)){\n    outPixel = DrawStone(boardCoord.xy, boardPos, ibc, false, outPixel, 0.0);\n  }\n  if(boardPos.x <= -1 && boardPos.x >= luScrBoadPos.x \n     && (-1-luScrBoadPos.x+1)*(boardPos.y-luScrBoadPos.y) + (boardPos.x - luScrBoadPos.x) < int(agehamaCache.y)){\n    outPixel = DrawStone(boardCoord.xy, boardPos, ibc, true, outPixel, 0.0);\n  }\n  fragColor = vec4(outPixel, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FetchBoardData(addr) texelFetch(iChannel0, addr, 0)\n\nprecision highp float;\nstruct IgoBoardConf {\n  float boardNum;\n  vec3 boardColor;\n  vec3 boardLineColor;\n  float boardLineWidth;\n  float boardSizePx;\n  float boardStarRadiusPx;\n  float boardStarPos;\n  float boardCoordToPx;\n  float stoneRadiusPx;\n  vec4 screenRectInBoardCoord;\n};\n\nconst float BOARD_STATE_SPACE = 0.1, \n            BOARD_STATE_BLACK = 0.2,\n            BOARD_STATE_WHITE = 0.3,\n            BOARD_STATE_OUT = 0.9;\n\nconst float MOUSE_DOWN = 0.1, \n            MOUSE_PRESSING = 0.2,\n            MOUSE_UP = 0.3,\n            MOUSE_NO_PRESS = 0.9;\n\nIgoBoardConf CommonIgoConf(vec2 resolution){\n  IgoBoardConf ibc;\n  ibc.boardNum = 19.0; // 9.0 or 13.0 or 19.0\n  ibc.boardColor = vec3(0.82, 0.64, 0.27);\n  ibc.boardLineColor = vec3(0.1);\n  ibc.boardLineWidth = 1.; // px\n  ibc.boardSizePx = min(resolution.x, resolution.y) * 0.9;\n\n  // const values\n  ibc.boardStarPos = ibc.boardNum == 19.0 ? 6.0\n                     : ibc.boardNum == 13.0 ? 3.0\n                     : ibc.boardNum == 9.0 ? 2.0 : 0.0;\n  ibc.boardCoordToPx = ibc.boardSizePx/ibc.boardNum;\n  ibc.boardStarRadiusPx = ibc.boardCoordToPx * 0.15;\n  ibc.stoneRadiusPx = ibc.boardCoordToPx * 0.45;\n  \n  float offsetInBoordCoord = 0.5*(ibc.boardNum+1.0);\n  ibc.screenRectInBoardCoord = vec4(-0.5*resolution.x/ibc.boardCoordToPx + offsetInBoordCoord,\n                                    -0.5*resolution.y/ibc.boardCoordToPx + offsetInBoordCoord,\n                                    0.5*resolution.x/ibc.boardCoordToPx + offsetInBoordCoord - 1.0,\n                                    0.5*resolution.y/ibc.boardCoordToPx + offsetInBoordCoord - 1.0);\n  return ibc;\n}\n\nbool IsInBoard(vec2 posInBoardCoord, IgoBoardConf ibc, float offset){\n  return (posInBoardCoord.x >= 0.0-offset && posInBoardCoord.x <= ibc.boardNum+offset \n          && posInBoardCoord.y >= 0.0-offset && posInBoardCoord.y <= ibc.boardNum+offset);\n}\n\n// (0.0, 0.0)~(19.0, 19.0) to [1, 一]~[19, 十九]\nivec2 BoardCoordToBoardPos(vec2 posInBoardCoord){\n  return ivec2(int(floor(posInBoardCoord.x)) + 1,\n               int(floor(posInBoardCoord.y)) + 1);\n}\n// [1, 一]~[19, 十九] to (0.0, 0.0)~(19.0, 19.0)\nvec2 BoardPosToBoardCoord(ivec2 boardPos){\n  return vec2(boardPos) - vec2(0.5);\n}\n\nvec3 DrawBoard(vec2 boardCoord, IgoBoardConf ibc, vec3 defaultColor){\n  vec3 ret = defaultColor;\n  // Draw boardbase\n  if(IsInBoard(boardCoord, ibc, 0.2)){\n    ret = ibc.boardColor;\n\n    // Draw star\n    vec2 boardCenteredCoord = boardCoord - vec2(ibc.boardNum*0.5);\n    if(length(boardCenteredCoord)*ibc.boardCoordToPx < ibc.boardStarRadiusPx\n      || length(abs(boardCenteredCoord) - vec2(ibc.boardStarPos))*ibc.boardCoordToPx < ibc.boardStarRadiusPx){\n      ret = ibc.boardLineColor;\n    }\n    if(ibc.boardNum==19.0\n      && (length(abs(boardCenteredCoord) - vec2(ibc.boardStarPos, 0.0))*ibc.boardCoordToPx < ibc.boardStarRadiusPx\n          || length(abs(boardCenteredCoord) - vec2(0.0, ibc.boardStarPos))*ibc.boardCoordToPx < ibc.boardStarRadiusPx)){\n      ret = ibc.boardLineColor;\n    }\n  }\n  // Draw line\n  if(boardCoord.x > 0.0 && boardCoord.x < ibc.boardNum\n      && boardCoord.y >= 0.5 && boardCoord.y <= ibc.boardNum-0.5){\n    if(abs(fract(boardCoord.x)-0.5)*2.0*ibc.boardCoordToPx < ibc.boardLineWidth){\n      ret = ibc.boardLineColor;\n    }\n  }\n  if(boardCoord.x >= 0.5 && boardCoord.x <= ibc.boardNum-0.5 \n      && boardCoord.y > 0.0 && boardCoord.y < ibc.boardNum){\n    if(abs(fract(boardCoord.y)-0.5)*2.0*ibc.boardCoordToPx < ibc.boardLineWidth){\n      ret = ibc.boardLineColor;\n    }\n  }\n  return ret;\n}\n\nvec2 FragCoordToBoardCoord(vec2 fragCoord, vec2 resolution, IgoBoardConf ibc){\n  // [0, iResolution.xy] -> [-0.5*iResolution.xy, 0.5*iResolution.xy]\n  vec2 centerPxCoord = vec2(fragCoord.x - 0.5*resolution.x, \n                            0.5*resolution.y - fragCoord.y);\n  // [-0.5*iResolution.xy, 0.5*iResolution.xy] -> [0, 19.0]\n  // boardCoord.xy is pixel, boardCoord.zw is mouse.xy\n  return (centerPxCoord + vec2(ibc.boardSizePx*0.5)) / ibc.boardCoordToPx;\n}\n\nvec3 DrawStone(vec2 boardCoord, ivec2 targetBoardPos, IgoBoardConf ibc, \n               bool isBlackTurn, vec3 defaultColor, float alpha){\n  vec3 ret = defaultColor;\n  vec2 targetInBoardCoord = BoardPosToBoardCoord(targetBoardPos);\n  if(length(boardCoord.xy - targetInBoardCoord.xy)*ibc.boardCoordToPx < ibc.stoneRadiusPx ){\n    ret = mix(vec3(isBlackTurn ? 0.0 : 1.0), defaultColor, alpha);\n  }\n  return ret;\n}\n\nivec2 GetAgehamaDataPos(IgoBoardConf ibc){\n  return ivec2(0, int(ibc.boardNum)+1);\n}\n\nivec2 GetKouDataPos(IgoBoardConf ibc){\n  return ivec2(int(ibc.boardNum)+1, 0);\n}\n\nivec2 GetBufferDataPos(IgoBoardConf ibc){\n  return ivec2(int(ibc.boardNum)+1, int(ibc.boardNum)+1);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool IsPlaceable(vec2 mouseInBoardCoord, IgoBoardConf ibc){\n  return (IsInBoard(mouseInBoardCoord, ibc, 0.0) // The placing pos is in the board or not\n          && FetchBoardData(BoardCoordToBoardPos(mouseInBoardCoord)).w == BOARD_STATE_SPACE // The placing pos is SPACE or not\n         );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  ivec2 intFragCoord = ivec2(fragCoord.xy);\n  vec4 outPixel = FetchBoardData(intFragCoord);\n\n  IgoBoardConf ibc = CommonIgoConf(iResolution.xy);\n\n  if(intFragCoord.x > int(ibc.boardNum)+1\n     || intFragCoord.y > int(ibc.boardNum)+1){\n    return;\n  }\n  \n  vec2 mouseInBoardCoord = FragCoordToBoardCoord(iMouse.xy, iResolution.xy, ibc);\n  ivec2 mouseBoardPos = BoardCoordToBoardPos(mouseInBoardCoord);\n  vec4 prevStoneData = FetchBoardData(ivec2(0,0));\n  bool isMousePressing = (iMouse.z > 0.0);\n  \n  float prevMouseState = prevStoneData.z;\n  bool isFirstFrame = (prevMouseState == 0.0);\n  float currMouseState = isFirstFrame ? MOUSE_NO_PRESS \n                    : (prevMouseState == MOUSE_NO_PRESS) && !isMousePressing ? MOUSE_NO_PRESS\n                    : (prevMouseState == MOUSE_NO_PRESS) && isMousePressing ? MOUSE_DOWN\n                    : (prevMouseState == MOUSE_DOWN || prevMouseState == MOUSE_PRESSING) && isMousePressing ? MOUSE_PRESSING\n                    : (prevMouseState == MOUSE_DOWN || prevMouseState == MOUSE_PRESSING) && !isMousePressing ? MOUSE_UP\n                    : (prevMouseState == MOUSE_UP) ? MOUSE_NO_PRESS\n                    : prevMouseState;\n  bool isPlaceable = isFirstFrame || IsPlaceable(mouseInBoardCoord, ibc);\n  bool isUpdate = (currMouseState == MOUSE_UP && isPlaceable);\n  \n  if(isFirstFrame){\n    if(intFragCoord.x == 0 || intFragCoord.x == int(ibc.boardNum)+1\n           || intFragCoord.y == 0 || intFragCoord.y == int(ibc.boardNum)+1){\n      outPixel.w = BOARD_STATE_OUT;\n    }\n    else{\n      outPixel.w = BOARD_STATE_SPACE;\n    }\n  }\n\n  // Store mouse state in [0, 0]\n  if(intFragCoord.xy == ivec2(0, 0)){\n    if(IsInBoard(mouseInBoardCoord, ibc, 0.0)){\n      outPixel.xy = mouseInBoardCoord;\n    }    \n    outPixel.z = currMouseState;\n    outPixel.w = isFirstFrame ? BOARD_STATE_BLACK \n                 : !isUpdate ? prevStoneData.w\n                 : prevStoneData.w == BOARD_STATE_BLACK ? BOARD_STATE_WHITE : BOARD_STATE_BLACK;\n  }\n  else if(intFragCoord.xy == GetBufferDataPos(ibc)){\n    outPixel.w = isUpdate ? 1.0 : 0.0;\n  }\n  // Store board state\n  else{\n    if(isUpdate && intFragCoord.xy == mouseBoardPos){\n      outPixel.w = prevStoneData.w;\n    }\n  }\n  fragColor = outPixel;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define ARRAY_SIZE 361\n\n// Top with offsetDir==1, Right with offsetDir==2, Bottom with offsetDir==3, Left with offsetDir==4\nivec2 OffsetBoardPos(ivec2 boardPos, int offsetDir){\n  if(offsetDir == 1){\n    return ivec2(boardPos.x, boardPos.y-1);\n  }\n  if(offsetDir == 2){\n    return ivec2(boardPos.x+1, boardPos.y);\n  }\n  if(offsetDir == 3){\n    return ivec2(boardPos.x, boardPos.y+1);\n  }\n  if(offsetDir == 4){\n    return ivec2(boardPos.x-1, boardPos.y);\n  }\n  return boardPos;\n}\n\n// true if there is at least one space around boardPos\n// arround.x is Top of boardPos, y is Right, z is Bottom, w is Left\nbool CheckAround(ivec2 boardPos, ivec4 except, out vec4 around){\n  around.x = (except.x == 1) ? BOARD_STATE_OUT : FetchBoardData(OffsetBoardPos(boardPos, 1)).w;\n  around.y = (except.y == 1) ? BOARD_STATE_OUT : FetchBoardData(OffsetBoardPos(boardPos, 2)).w;\n  around.z = (except.z == 1) ? BOARD_STATE_OUT : FetchBoardData(OffsetBoardPos(boardPos, 3)).w;\n  around.w = (except.w == 1) ? BOARD_STATE_OUT : FetchBoardData(OffsetBoardPos(boardPos, 4)).w;\n  return (around.x == BOARD_STATE_SPACE)\n         || (around.y == BOARD_STATE_SPACE)\n         || (around.z == BOARD_STATE_SPACE)\n         || (around.w == BOARD_STATE_SPACE);\n}\n\nbool IsAroundByTheOther(ivec2 newBoardPos, bool isBlack, out ivec2[ARRAY_SIZE] aroundedStones, out int aroundedStonesLen){\n  aroundedStonesLen = 0;\n\n  vec4 around;\n  if(CheckAround(newBoardPos, ivec4(0), around)){\n    return false;\n  }\n  float thisSide = isBlack ? BOARD_STATE_BLACK : BOARD_STATE_WHITE;\n  if((around.x != thisSide) && (around.y != thisSide)\n     && (around.z != thisSide) && (around.w != thisSide)){\n    aroundedStones[aroundedStonesLen++] = newBoardPos; \n    return true;\n  }\n  \n//  int checkedLen = 0;\n//  ivec2 checked[ARRAY_SIZE];\n//  checked[checkedLen++] = newBoardPos;\n  aroundedStones[aroundedStonesLen++] = newBoardPos;\n  \n  int willCheckLen = 0;\n  ivec2 willCheck[ARRAY_SIZE];\n  if(around.x == thisSide){\n    willCheck[willCheckLen++] = OffsetBoardPos(newBoardPos, 1);\n  }\n  if(around.y == thisSide){\n    willCheck[willCheckLen++] = OffsetBoardPos(newBoardPos, 2);\n  }\n  if(around.z == thisSide){\n    willCheck[willCheckLen++] = OffsetBoardPos(newBoardPos, 3);\n  }\n  if(around.w == thisSide){\n    willCheck[willCheckLen++] = OffsetBoardPos(newBoardPos, 4);\n  }\n  \n  int cnt = 0;   \n  while(cnt != willCheckLen){\n    ivec2 target = willCheck[cnt++];\n\n    bool targetIsChecked = false;\n    ivec4 except = ivec4(0);\n    for(int i=0; i<aroundedStonesLen+1; i++){\n      // 1. 自身がchecked と被ってないか確認して，被ってたら次のwillCheckに移る（continue）\n      if(aroundedStones[i] == target){\n        targetIsChecked = true;\n        break;\n      }      \n      // 2. 周囲がchecked と被ってないか確認して，被ってたらCheckArroundのExceptに入れる\n      else if(aroundedStones[i] == OffsetBoardPos(target, 1)){\n        except.x = 1;\n      }\n      else if(aroundedStones[i] == OffsetBoardPos(target, 2)){\n        except.y = 1;\n      }\n      else if(aroundedStones[i] == OffsetBoardPos(target, 3)){\n        except.z = 1;\n      }\n      else if(aroundedStones[i] == OffsetBoardPos(target, 4)){\n        except.w = 1;\n      }\n    }\n    if(targetIsChecked){\n      continue;\n    }\n    \n    // 3. CheckArround して，Spaceがあれば即return false，味方がいればwillCheckに足す\n    //（すでにwillCheckに入ってる可能性があるが，自身のchecked確認ではじける）\n    if(CheckAround(target, except, around)){\n      aroundedStonesLen = 0;\n      return false;\n    }\n    aroundedStones[aroundedStonesLen++] = target;\n    if((around.x != thisSide) && (around.y != thisSide)\n       && (around.z != thisSide) && (around.w != thisSide)){\n      continue;\n    }\n    if(around.x == thisSide){\n      willCheck[willCheckLen++] = ivec2(target.x, target.y-1);\n    }\n    if(around.y == thisSide){\n      willCheck[willCheckLen++] = ivec2(target.x+1, target.y);\n    }\n    if(around.z == thisSide){\n      willCheck[willCheckLen++] = ivec2(target.x, target.y+1);\n    }\n    if(around.w == thisSide){\n      willCheck[willCheckLen++] = ivec2(target.x-1, target.y);\n    }\n  }\n//  aroundedStonesLen = checkedLen;\n//  aroundedStones = checked;\n  return true;\n}\n\nbool CanTakeStones(ivec2 newBoardPos, bool isBlack, out ivec2[ARRAY_SIZE] takenStones, out int takenStonesLen){\n  takenStonesLen = 0;\n  float otherSide = isBlack ? BOARD_STATE_WHITE : BOARD_STATE_BLACK;\n  \n  vec4 around;\n  CheckAround(newBoardPos, ivec4(0), around);\n  for(int i=1; i<5; i++){\n    if(otherSide != (i==1 ? around.x : i==2 ? around.y : i==3 ? around.z : i==4 ? around.w : BOARD_STATE_OUT)){\n      continue;\n    }\n    ivec2 target = OffsetBoardPos(newBoardPos, i);\n    ivec2[ARRAY_SIZE] takenStones_temp;\n    int takenStonesLen_temp;\n    if(IsAroundByTheOther(target, !isBlack, takenStones_temp, takenStonesLen_temp)){\n      for(int j=0; j<takenStonesLen_temp; j++){\n        takenStones[takenStonesLen+j] = takenStones_temp[j];\n      }\n      takenStonesLen = takenStonesLen+takenStonesLen_temp;\n    }    \n  }\n  return (takenStonesLen != 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  ivec2 intFragCoord = ivec2(fragCoord.xy);\n  vec4 outPixel = FetchBoardData(intFragCoord);\n\n  IgoBoardConf ibc = CommonIgoConf(iResolution.xy);\n\n  if(intFragCoord.x > int(ibc.boardNum)+1\n     || intFragCoord.y > int(ibc.boardNum)+1){\n    return;\n  }\n  // Update BufferB only when BufferA is updated\n  if(FetchBoardData(GetBufferDataPos(ibc)).w != 1.0){\n    fragColor = outPixel;\n    return;\n  }\n  \n  vec4 currStoneData = FetchBoardData(ivec2(0,0));\n  vec4 kouData = FetchBoardData(GetKouDataPos(ibc));\n  ivec2 kouBoardPos = ivec2(kouData.xy);\n  float kouTurn = kouData.w;\n\n  ivec2 currBoardPos = BoardCoordToBoardPos(currStoneData.xy);\n  // currStoneData.w was fliped in BufferA\n  bool isBlack = (currStoneData.w == BOARD_STATE_WHITE);\n  \n  ivec2[ARRAY_SIZE] takenStones;\n  int takenStonesLen;\n \n  // Check kou\n  if(currBoardPos == kouBoardPos && kouTurn == (isBlack ? BOARD_STATE_BLACK :BOARD_STATE_WHITE )){\n    if(intFragCoord.xy == ivec2(0, 0)){\n      outPixel.z = MOUSE_NO_PRESS;\n      // keep black turn\n      outPixel.w = isBlack ? BOARD_STATE_BLACK : BOARD_STATE_WHITE;\n    }\n    if(intFragCoord.xy == currBoardPos){\n      outPixel.w = BOARD_STATE_SPACE;\n    }\n  }\n  // Check taking stones\n  else if(CanTakeStones(currBoardPos, isBlack, takenStones, takenStonesLen)){\n    for(int i=0; i<takenStonesLen; i++){\n      if(intFragCoord.xy == takenStones[i]){\n        outPixel.w = BOARD_STATE_SPACE;\n      }\n    }\n    if(intFragCoord.xy == GetAgehamaDataPos(ibc)){\n      // Count up agehama\n      if(isBlack){\n        outPixel.x = outPixel.x + float(takenStonesLen);\n      }else{\n        outPixel.y = outPixel.y + float(takenStonesLen);\n      }\n    }\n    // Cache kou boardPos\n    if(intFragCoord.xy == GetKouDataPos(ibc) && takenStonesLen == 1){\n      outPixel.xy = vec2(takenStones[0].xy);\n      outPixel.w = isBlack ? BOARD_STATE_WHITE : BOARD_STATE_BLACK;\n    }   \n  }\n  // Check arounded by the other stones\n  else if(IsAroundByTheOther(currBoardPos, isBlack, takenStones/*not used*/, takenStonesLen/*not used*/)){\n    if(intFragCoord.xy == ivec2(0, 0)){\n      outPixel.z = MOUSE_NO_PRESS;\n      // keep black turn\n      outPixel.w = isBlack ? BOARD_STATE_BLACK :BOARD_STATE_WHITE;\n    }\n    if(intFragCoord.xy == currBoardPos){\n      outPixel.w = BOARD_STATE_SPACE;\n    }\n  }\n  \n  // Reset kou\n  if(kouBoardPos != ivec2(0, 0) && kouTurn != (isBlack ? BOARD_STATE_BLACK :BOARD_STATE_WHITE)){\n    if(intFragCoord.xy == GetKouDataPos(ibc)){\n      outPixel.xy = vec2(0.0, 0.0);\n      outPixel.w = BOARD_STATE_SPACE;\n    }\n  }\n  \n  fragColor = outPixel;\n}","name":"Buffer B","description":"","type":"buffer"}]}