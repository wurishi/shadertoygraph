{"ver":"0.1","info":{"id":"sdX3Dr","date":"1615863125","viewed":165,"name":"ROCK PLANET ","username":"romeosoft","description":"Earth-like rocky planet simulation.\nThanks to IQ for creating this website, I simulated many interesting things.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["earth","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\nconst float pi = 3.1415926;\n\nconst vec3 \n    c1 = vec3(0.04, 0.02, 0.3),\n\tc2 = vec3(0.12, 0.06,1.25);\nconst vec3 \n    c3 = vec3(0.06, 0.1, 0.1),\n\tc4 = vec3(0.10, 0.10,0.9);\n\nconst float R = 0.5;\n\nfloat time;\n\n//--------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.001 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 7; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*2.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\n// iq's noise\n//--------------------------------------------------------------\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n*5.;\n}\n/*\n// The following are from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n*/\n//--------------------------------------------------------------\n// hsv and rgb\n//--------------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n\n//--------------------------------------------------------------\nconst float unit = 0.001;\nvec3 getCor(float r, vec3 p, float dr, vec3 v, vec3 right, vec3 up)\n{\n    vec3 p2 = p + right * unit;\n    p2 = normalize(p2);\n    float dr2 = fbm(p2 * (r * 3.0)) * 0.01;\n    p2 = p2 * (r + dr2 - dr);\n    \n    vec3 p3 = p + up * unit;\n    p3 = normalize(p3);\n    float dr3 = fbm(p3 * (r * 3.0)) * 0.01;\n    p3 = p3 * (r + dr3 - dr);\n    \n    vec3 nz = normalize(cross(p2-p, p3-p));\n    vec3 cor0 = mix(vec3(0.0,0.1,0.0), vec3(0.8,0.6,0.5), dr / 0.1);\n    return mix(vec3(0.01,0.005,0.),cor0,clamp(-dot(vec3(-1.414 / 2.,-1.414 / 2.,0.), -nz),0.,1.));\n    \n}\n\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x + 80.5) / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n        \n    ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.75 + left*pp.x + up*pp.y);\n    float dis = length(cam);\n    float dotv = max(0.001, dot(v,front));\n    vec3 p = cam+v*(dis-R - 0.2);\n    \n    float dt = 0.0025;\n    vec3 cor = vec3(0.0);\n    \n    for(int i = 0; i < 150; i ++)\n    {\n        float r = length(p);\n        dt = mix(0.0001,0.01,smoothstep(0.,0.25,(r - R)/dotv)); // To be smooth\n\t\t\n        float dr = fbm(p*3.0) * 0.01;\n        if(r < R + 0.05)\n        {  \n            cor = mix(vec3(0.,0.0, 0.05),vec3(0.4,0.65,1.0),clamp(dot(normalize(p),vec3(-1.414 / 2.,-1.414 / 2.,0.)), 0., 1.));\n            break;\n        }\n        if(r < R + dr)\n        {  \n            vec3 right2 = normalize(cross(up,p));\n            vec3 up2 = normalize(cross(p,right2));\n            cor = getCor(r, p, dr, v, right2, up2);\n            break;\n        }\n        if(r < R + 0.2)\n        {\n           cor += (0.0075 * (smoothstep(0.2,0.,r-R))) * vec3(0.3,0.5,0.75);\n        }\n        p += v * dt;\n    }\n    fragColor = vec4(cor,1.0);\n}","name":"Image","description":"","type":"image"}]}