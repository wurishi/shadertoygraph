{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\tGradient descent pathfinding based on artificial potential fields\n\t\n\tAuthor: Dario Sancho-Pradel\n\n\tThe idea is to do pathfinding on a shader, in this case based on potential fields.\n\tThe target entity generates an attractive potential field, while the other entities\n\t(obstacles and start location) generate repulsive ones. \n\tThe path is found by following the gradient of the field. In this experiment the \n\tchosen fields for all entities have the form f = K/r so the gradient is of the form -K/r2.\n\n\tWhite(dotted) lines show the orientation of the gradient sampled at regular intervals.\n\n\tFeel free to add more obstacles (if your machine is powerful enough) and experiment with \n\tdifferent potential fields. You can change the constant of the current fields to make\n\tthem stronger or weaker (GOAL_K, START_K, OBST_K).\n\n\t'T' toggles the dragging mode (either dragging the source or the goal)\n\t'S' toggles sound-based fx on/off\n\t'W' toggles the obstacle configuration\n\t'1' toggles the more 'artistic' views\n\t'V' hold it to see vanilla view which clearly shows the equipotential curves.\n\t\n\tTips:\n\t* If your framerate is low, try removing the audio channel (and disable sound fx 'S')\n\t* You can also try reducing the number of gradient samples (NUM_GRAD_POINTS_PER_ROW)\n\t* You can also pause the shader and play around dragging the starting point\n\t* Notice that the path is always perpendicular to the equipotential curves.\n\t\n*/\n\n// Math\n#define PI 3.141592\n#define PI_HALF PI*0.5\n#define PI_2 6.28318530718\n\n// Simulation\n#define SIM_STEPS 120\n#define GOAL_K 0.05\t\t\t\n#define START_K 0.01\t\t\n#define OBST_K 0.005\n\n// sound\n#define K_SOUND_FADE_IN 0.2\n\n// Gradient Lines\n#define NUM_GRAD_POINTS_PER_ROW 10\n#define NUM_GRAD_LINE_POINTS 3\n\n#define DELTA_POS_PATH 0.015\n#define DELTA_POS_GRAD_LINES 0.015\n\n#define PATH_COL vec3(1.,1.,0.2)\n#define GRAD_COL vec3(0.8,0.8,0.8)\n\n// Lines radii\n#define PATH_RADIUS 0.015\n#define ENTITY_RADIUS 0.14\n#define GRAD_LINE_RADIUS 0.007\n\n// Keys\nconst float KEY_MOVE_TGT = 84.5 / 256.0;\t\t// T\nconst float KEY_SOUND  = 83.5/256.0;\t\t\t// S\nconst float KEY_VIEW_1  = 49.5/256.0;\t\t\t// 1\nconst float KEY_VIEW_VANILLA  = 86.5/256.0;\t\t// V\nconst float KEY_FORMATION_TYPE  = 87.5/256.0;\t// W\n\n// scene\n#define NUM_ENTITIES 6\n#define ENTITY_SRC_IDX 0\n#define ENTITY_TGT_IDX 1\n#define ENTITY_FIRST_OBS_IDX 2\n\n// other\n#define USE_BRANCHING_FOR_FIELD_EFFECTS 1\n\nstruct SPathEffect\n{\n\tfloat speed;\n\tfloat radius_k;\n};\n\t\nstruct SMusic\n{\n\tfloat freqs[4];\n\tfloat f;\n\tfloat fPow;\n};\n\nstruct SEntity\n{\n\tvec2 pos[NUM_ENTITIES];\n\tvec3 col[NUM_ENTITIES];\n\tfloat k[NUM_ENTITIES];\n};\n\n// Global data\nvec2 CENTRE_POS = vec2(0.);\nfloat AR = 0.;\nfloat gPathDynRadius = PATH_RADIUS;\n\nSPathEffect gPathEffect;\nSMusic gSound;\nSEntity gEntities;\n\n// ------------------------------------------------------------------------------------\n// ---------------------------------- Helper Functions --------------------------------\n// ------------------------------------------------------------------------------------\n\n// ------------------------------------ Init ------------------------------------------\nvoid InitGlobals()\n{\n\tAR = iResolution.x / iResolution.y;\n\tCENTRE_POS = vec2(0.5*AR, 0.5);\n\t\n\tgEntities.pos[ENTITY_SRC_IDX] = vec2(0.5*AR,0.1);\n\tgEntities.pos[ENTITY_TGT_IDX] = vec2(0.5*AR,0.5);\n\tgEntities.col[ENTITY_SRC_IDX] = vec3(1.,0.,0.);\n\tgEntities.col[ENTITY_TGT_IDX] = vec3(0.,1.,0.);\n\tgEntities.k[ENTITY_SRC_IDX] = START_K;\n\tgEntities.k[ENTITY_TGT_IDX] = -GOAL_K;\n\t\t\t  \n\tfor (int i=ENTITY_FIRST_OBS_IDX; i<NUM_ENTITIES; ++i)\n\t{\n\t\tgEntities.pos[i] = vec2(0.);\n\t\tgEntities.col[i] = vec3(1.,1.,0.);\n\t\tgEntities.k[i] = OBST_K;\n\t}\n\t\n\tgPathEffect.speed = 80.;\n\tgPathEffect.radius_k = 3.;\n}\n\n// ---------------------------- Potential Fields & Gradients ---------------------------------\n\n// Single Potential Filed K/R\nfloat pf1R(in vec2 p, in vec2 objPos, in float K)\n{\n\treturn K/max(length(p - objPos), 0.00005);\n}\n\n// Calculate the total PF\nfloat calcualtePfAtPoint(in vec2 p)\n{\n\tfloat pf = 0.;\n\tfor (int i = 0; i < NUM_ENTITIES; ++i)\n\t\tpf += pf1R(p,gEntities.pos[i], gEntities.k[i]);\n\t\n\treturn /*clamp(gSound.f, 0.5,1.)* */pf;\n}\n\n// Single Gradient for a PF K/R -> |gr| = K/R^2, dir = kSign*ir\nvec3 grPf1R(in vec2 p, in vec2 objPos, in float K)\n{\n\tfloat nSign = sign(K);\n\tvec2 r = p\t- objPos;\n\tfloat r2 = max(dot(r,r), 0.00005);\n\treturn vec3(nSign*K/r2,nSign * normalize(r));\n}\n\nvec3 calculateGradPF(in vec2 p)\n{\n\tvec2 res = vec2(0.);\n\tfor (int i = 0; i < NUM_ENTITIES; ++i)\n\t{\n\t\tvec3 gr = grPf1R(p, gEntities.pos[i], gEntities.k[i]);\n\t\tres += gr.x*gr.yz;\n\t}\n\t\t\n\tvec2 dir = normalize(res);\n\treturn vec3(length(res), dir.xy);\n}\n\n// ------------------------------------- Drawing --------------------------------------\n\nvec3 drawElement(in vec2 p, in vec2 objPos, in vec3 col, in float r, in float minR)\n{\n\tfloat d = length(p - objPos);\n\treturn mix(col, vec3(0.), smoothstep(0.0, max(r*gSound.f, minR), d));\n}\n\t\nvec3 drawGradLine(in vec2 p, in vec2 point)\n{\n\tvec3 col = vec3(0.);\n\tfor (int i=0; i < NUM_GRAD_LINE_POINTS; ++i)\n\t{\n\t\tvec3 gradInfo = calculateGradPF(point);\t\n\t\tvec3 path = drawElement(p, point, GRAD_COL, GRAD_LINE_RADIUS, GRAD_LINE_RADIUS*0.8);\n\t\tcol = max(col,path);\n\t\tpoint += DELTA_POS_GRAD_LINES*(gradInfo.yz);\n\t}\t\n\treturn col;\n\t\n}\n\nvec3 DrawEntities(in vec2 p)\n{\n\tvec3 entityLayer = vec3(0.);\n\tfor (int i = 0; i < NUM_ENTITIES; ++i)\n\t{\n\t\tentityLayer = max(entityLayer, drawElement(p, gEntities.pos[i], gEntities.col[i], ENTITY_RADIUS, 0.03));\n\t}\n\t\n\treturn entityLayer;\n}\n\nvec3 drawTiledBackground(in vec2 uv)\n{\t\n\tconst float invNumTiles = 1./20.; //max(20.*gSound.f,15.);\n\tvec2 tile = vec2(AR,1.)*invNumTiles;\n\t\n\t// calculate the column and row indices the pixel is in\n\tvec2 idx = floor(uv / tile);\n\tvec2 m = mod(idx,vec2(2.));\n\tfloat delta = m.x - m.y;\n\tfloat pixelOn = delta*delta; // m.x == m.y ? 0. : 1.;\n\t\n\t// draw tile\n\tvec2 centre = idx*tile + vec2(tile.x*.5, tile.y*0.5);\n\tfloat dist2Centre = length(uv-centre);\n\tfloat d = tile.y*clamp(gSound.fPow,0.1,0.3);\n\tpixelOn *= step(dist2Centre, d);\n\t\n\treturn vec3(pixelOn);\n}\n\nvec3 DrawFields(in vec2 p)\n{\n\tfloat onViewPink = 1.-texture( iChannel0, vec2(KEY_VIEW_1,0.75) ).x;\n\tfloat onViewVanilla = texture( iChannel0, vec2(KEY_VIEW_VANILLA,0.25) ).x;\n\n\tvec3 col = vec3(0.);\n\tvec3 data = vec3(0.);\n\tif (onViewVanilla > 0.5)\n\t{\n\t\tcol = vec3(0.1);\n\t\tdata.x = calcualtePfAtPoint(p);\n\t\tconst int NUM_CURVE_LINES = 20;\n\t\tconst float CURVE_WIDTH = 0.005;\t\t\n\t\tfor (int i = 0; i < NUM_CURVE_LINES; ++i)\n\t\t{\n\t\t\tfloat lc = float(i)/float(NUM_CURVE_LINES);\n\t\t\tfloat d = abs(sign(data.x)*data.x-lc);\n\t\t\tfloat t = smoothstep(0.,CURVE_WIDTH,d);\n\t\t\tfloat c1 = step(0.0001,data.x);\n\t\t\t\n\t\t\tvec3 colLine = c1* vec3((1.-t),0., t*(1.-t));\n\t\t\tcolLine += (1.-c1)* vec3((1.-t),(1.-t),0.);\n\t\t\t\n\t\t\tcol = mix(colLine, col, t);\n\t\t}\n\t}\n\telse if (onViewPink > 0.5)\n\t{\n\t\t// Default: Pink Psycodelia\n\t\tfloat pf = calcualtePfAtPoint(p);\n\t\tdata.x = 10.0*pf;\n\t\tcol = vec3(smoothstep(-10.,10.,pow(data.x,-0.4) ),0.,0.8);\n\t\tif (data.x < -0.8) col.x = col.x*0.9;\n\t\tcol += clamp(gSound.f*drawTiledBackground(p), 0.,0.02);\t\t\n\t\tcol -= clamp(gSound.freqs[2]*drawTiledBackground(p+0.1*vec2(sin(iTime))), 0.,0.04);\n\t}\n\telse\n\t{\n\t\t// Blue Psycodelia\n\t\tdata.x = calcualtePfAtPoint(p);\n\t\t\n#if USE_BRANCHING_FOR_FIELD_EFFECTS\t\n\t\t// with branching... runs faster in my machine\n\t\tif (data.x > 0.2) \n\t\t\tcol = vec3(smoothstep(0.,10.,pow(data.x,-0.4)),0.,0.8);\n\t\telse if (data.x < -0.1)\n\t\t\tcol = vec3(0.,smoothstep(-10.,0.,1./data.x),0.8);\n\t\telse\n\t\t\tcol = vec3(0.,smoothstep(-0.2,0.2,data.x),0.8);\n\t\n#else\t\t\t\n\t\t// without branching ... should this tun faster???\n\t\tfloat c1 = step(0.2, data.x);\n\t\tfloat c2 = 1.-step(-0.1, data.x);\n\t\t\t\n\t\tcol = (c1)*vec3(smoothstep(0.,10.,pow(data.x,-0.4)),0.,0.8);\n\t\tcol += (1.-c1)*c2*vec3(0.,smoothstep(-10.,0.,1./data.x),0.8);\n\t\tcol += (1.-c1)*(1.-c2)*vec3(0.,smoothstep(-0.2,0.2,data.x),0.8);\n#endif\t\t\n\t\t\n\t\tcol -= clamp(gSound.freqs[2]*drawTiledBackground(p+0.1*vec2(cos(iTime),sin(iTime))), 0.,0.05);\n\t}\n\t\n\t// draw samples of gradient at uniform distances\n\tconst float invNumPoints = 1.0/float(NUM_GRAD_POINTS_PER_ROW);\n\tfloat deltaX = AR*invNumPoints;\n\tfor (int i = 0; i < NUM_GRAD_POINTS_PER_ROW; ++i)\n\t{\n\t\tfloat i_float = float(i);\n\t\tfor (int j = 0; j < NUM_GRAD_POINTS_PER_ROW; ++j)\n\t\t{\n\t\t\tvec2 point = vec2((i_float+0.5)*deltaX, (float(j)+0.5)*invNumPoints);\n\t\t\tvec3 colGradLine = drawGradLine(p, point);\n\t\t\tcol = mix(col, colGradLine, dot(colGradLine,colGradLine));\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvec3 DrawPath(in vec2 p)\n{\n\tvec3 pathLayer = vec3(0.);\n\t\n\tfloat stepGlow = gPathEffect.speed*mod(iTime,1.);\n\tgPathDynRadius *= gPathEffect.radius_k;\n\tvec2 point = gEntities.pos[ENTITY_SRC_IDX]+DELTA_POS_PATH*normalize(gEntities.pos[ENTITY_TGT_IDX]-gEntities.pos[ENTITY_SRC_IDX]);\n\tfor (int i=0; i < SIM_STEPS; ++i)\n\t{\n\t\t// glow effect\n\t\tfloat showGlow = 1.-step(stepGlow,float(i));\n\t\tfloat ptRadiusDelta = showGlow * gPathDynRadius * smoothstep(0.6,1.,float(i)/stepGlow);\n\t\t\n\t\t// draw path\n\t\tvec3 gradInfo = calculateGradPF(point);\n\t\tvec3 path = drawElement(p, point, PATH_COL, PATH_RADIUS + ptRadiusDelta, PATH_RADIUS*0.5);\n\t\tpathLayer = max(pathLayer,path);\n\t\tpoint += DELTA_POS_PATH*(gradInfo.yz);\n\t\t\n\t\t// early exit (is it better a continue or a break here?)\n\t\tif (length(point - gEntities.pos[ENTITY_TGT_IDX]) < 0.01) continue;\n\t}\n\t\n\treturn pathLayer;\n}\n\n// ----------------------------------- Updates --------------------------------------------------\nvoid UpdateEntities()\n{\n\tvec2 mousePos = vec2(AR*iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n\t\n\tfloat onMoveTarget = texture( iChannel0, vec2(KEY_MOVE_TGT,0.75) ).x;\n\tfloat onTipo1 = texture( iChannel0, vec2(KEY_FORMATION_TYPE,0.75) ).x;\n\n\tif (onTipo1 < 0.5)\n\t{\n\t\tfloat theta = iTime*PI_2*0.1;\n\t\t// update goal/start positions\n\t\tgEntities.pos[ENTITY_TGT_IDX] = mix(gEntities.pos[ENTITY_TGT_IDX], mousePos, onMoveTarget);\n\t\tgEntities.pos[ENTITY_SRC_IDX] = mix(mousePos, gEntities.pos[ENTITY_SRC_IDX], onMoveTarget);\n\t\n\t\t// update obstacles positions\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX]   = gEntities.pos[ENTITY_TGT_IDX] + 0.2*(vec2(cos(theta),sin(theta)));\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX+1] = gEntities.pos[ENTITY_TGT_IDX] + 0.3*(vec2(sin(1.3*theta+PI),cos(1.3*theta+PI)));\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX+2] = gEntities.pos[ENTITY_TGT_IDX] + 0.4*(vec2(cos(1.4*theta),sin(1.4*theta)));\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX+3] = gEntities.pos[ENTITY_TGT_IDX] + 0.5*(vec2(sin(1.5*theta+PI_HALF),cos(1.5*theta+PI_HALF)));\n\t} \t\n\telse\n\t{\n\t\tconst float kSpeed = 4.;\n\t\tfloat thetaRadius = iTime*PI_2*0.1;\n\t\tfloat theta = thetaRadius*kSpeed;\n\t\tfloat s = sin(thetaRadius);\t\t\n\t\t\n\t\t// update goal/start positions\n\t\tgEntities.pos[ENTITY_TGT_IDX] = mix(vec2(AR*0.5,0.5), mousePos , onMoveTarget);\n\t\tgEntities.pos[ENTITY_SRC_IDX] = mix(mousePos , gEntities.pos[ENTITY_SRC_IDX], step(0.1,onMoveTarget));\n\t\t\n\t\tgEntities.pos[ENTITY_TGT_IDX].x = gEntities.pos[ENTITY_TGT_IDX].x + 0.4*abs(sin(thetaRadius));\n\t\t\n\t\tvec2 cPos = 0.5*(gEntities.pos[ENTITY_SRC_IDX] + gEntities.pos[ENTITY_TGT_IDX]);\n\t\tfloat sndOff = 1. - step(0.99, gSound.f);\n\t\t\n\t\t// update obstacles positions\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX]   = gEntities.pos[ENTITY_TGT_IDX] - 0.45*s*(vec2(cos(theta+PI_HALF),sin(theta+PI_HALF)));\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX+1] = gEntities.pos[ENTITY_TGT_IDX] + 0.4*s*(vec2(cos(theta+PI*0.25),sin(theta+PI*0.25)));\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX+2] = cPos - 0.35*s*(vec2(cos(theta),sin(theta)));\n\t\tgEntities.pos[ENTITY_FIRST_OBS_IDX+3] = cPos + sndOff*vec2(0., 0.25-clamp(gSound.f - 0.5, 0.0,0.5));\t\t\t\n\t\t\n\t}\n}\n\nvoid UpdateAudio()\n{\n\tfloat onSound = texture( iChannel0, vec2(KEY_SOUND,0.75) ).x;\n\n\tgSound.freqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tgSound.freqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tgSound.freqs[2] = texture( iChannel1, vec2( 0.014, 0.25 ) ).x;\n\tgSound.freqs[3] = texture( iChannel1, vec2( 0.028, 0.25 ) ).x;\n\tgSound.f = max(onSound,clamp(iTime*K_SOUND_FADE_IN, 0.2,1.)*gSound.freqs[1]*gSound.freqs[2]);\n\tgSound.fPow = pow( clamp( gSound.f*0.75, 0.0, 1.0 ), 2.0 );\n}\n\n// ----------------------------------------------------------------------------\n// -------------------------------- MAIN --------------------------------------\n// ----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tInitGlobals();\n\tvec3 col = vec3(0.);\n\t\n\tvec2 p = fragCoord.xy / iResolution.xy;\t\n\tp.x *= AR;\n\t\n\t// update audio\n\tUpdateAudio();\n\t\n\t// update entities\n\tUpdateEntities();\n\t\n\t// draw entities\n\tvec3 entityLayer = DrawEntities(p);\n\n\t// draw potential field / gradient\n\tvec3 fieldLayer = DrawFields(p);\n\n\t// draw path ('ride' the gradient from source to target)\n\tvec3 pathLayer = DrawPath(p);\t\t\t\n\n\t// mix layers\n\tcol = max(fieldLayer, entityLayer);\t\n\tcol = mix(col, pathLayer, length(pathLayer));\n\t\t\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s23zV","date":"1391529908","viewed":569,"name":"Pathfinding Trance","username":"dsp","description":"Basic gradient descent pathfinding toy. Keys: [1]:Toggles 'artistic' Views.-[V]:Vanilla View with equipotential curves-[S]:on/off sound fx-[W]:change config.-[T]:toggles move tgt/source: [Mouse]: move entity","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","simulation","pathfinding","psycodelia","potentialfields"],"hasliked":0,"parentid":"","parentname":""}}