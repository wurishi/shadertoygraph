{"ver":"0.1","info":{"id":"sssfDM","date":"1644962080","viewed":196,"name":"Ceci n'est pas un torus.","username":"stegu","description":"This is a fake torus. The shader traces cylinders, ellipsoids and a hyperboloid, some positioned and oriented in a view-dependent manner. It was messy to get the entire surface right, but I haven't ruled this is out as a stupid idea. Not completely. Yet.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["torus","quadric","fake","raytrace","proxy"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ray targets are on a \"view plane\" at z=0, intersecting the object\n    vec3 puv = 1.5*vec3((2.0*fragCoord-iResolution.xy)/min(iResolution.x, iResolution.y), 0.0);\n\n    // Zoom by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.98,iMouse.y-abs(iMouse.w));\n    puv.xy = zoom*puv.xy;\n\n    // Camera position (classic raycast central projection)\n    vec3 p0 = vec3(0.0, 0.0, 5.0);\n    vec3 V = normalize(puv-p0);\n\n// Disable this (#if 0) to see the numerical problems with the exact solution\n#if 0\n    // Retrace to make rays spawn from a plane close to the torus\n    // (This is a requirement only for the exact solution)\n    float vt = traceplane(2.0, p0, V);\n    p0 = p0+vt*V;\n#endif\n    \n    const float PI = 3.1415936;\n    // Rotate the view - mouse down stops the animation, rotate by left-right drag\n    float viewtilt;\n    if(iMouse.z > 0.0)\n        viewtilt = 0.01*(iMouse.x-abs(iMouse.z));\n    else\n        viewtilt = iTime;\n\n    float Ct = cos(viewtilt);\n    float St = sin(viewtilt);\n\n    float torusR = 1.0;\n    float torusr = 0.3+0.2*sin(iTime*sqrt(0.2)); // Variable proportions for show\n\n    // Our only matrix transforms from view space to object space.\n    // I have an itch to name this \"inverseModelViewMatrix\". (Nnngh.)\n    mat3 Rt = mat3(1.0, 0.0, 0.0, 0.0, Ct, St, 0.0, -St, Ct);\n\n    p0 = Rt * p0;   // Transform rays to object space,\n    puv = Rt * puv; // where we do our ray casting.\n    V = normalize(puv-p0); // Recompute (less work than a matrix mult)\n\n    vec3 color;\n    vec3 hit;\n    float t, tfake, treal;\n\n    // Ta-daa! This is our fake torus. It works. Finally. Phew.\n    tfake = tracefaketorus(torusR, torusr, p0, V);\n\n    // This is the exact solution to the 4th degree equation, courtesy of iq.\n    // However, it requires you to transform the rays to originate very\n    // close to the object. It breaks even at very modest camera distances.\n    // 32-bit precision is really only barely enough to solve this problem,\n    // and anything less (looking at you, MEDIUMP) just wouldn't work.\n    treal = iTorus(p0, V, vec2(torusR, torusr));\n    \n    // Change this to t=treal to test the exact solution, which glitches\n    // badly if you don't enable the camera ray retracing on lines 15-20.\n    t = tfake;\n\n    vec3 bgcolor = vec3(0.0, 0.0, 0.4);\n\n    // My function says t = 1e6 for \"no hit\", iq's says t = -1.0.\n    // Both are workarounds. GLSL has dodgy support for Inf and NaN.\n    if ((t >= 1e6) || (t < 0.0)) {  // \"No hit\"\n        fragColor = vec4(bgcolor,1.0);\n    } else {\n        hit = p0 + t*V; // We're in object space, which is convenient.\n        // Use the gradient of the implicit function to compute the normal.\n        // (This can be computed from the hit point instead, if desired.)\n        vec3 N = normalize(torusg(torusR, torusr, hit));\n        // Compute the texcoords (parameters u,v)\n        float theta = atan(hit.y, hit.x)/PI; // theta range is [-1,1)\n        float alpha = atan(hit.z, length(hit.xy)-torusR)/PI; // alpha range is [-1,1)\n        float thetaramp = 2.0*abs(fract(theta*12.0)-0.5); // Triangle wave for nice AA\n        float thetalines = aaline(0.5,thetaramp, 1.0);    // AA lines, 1 pixels wide\n        float alpharamp = 2.0*abs(fract(alpha*3.0)-0.5);\n        float alphalines = aaline(0.5,alpharamp, 1.0);\n        color = (0.5 + 0.5*N)*(1.0-max(thetalines, alphalines)); // Normal + grid overlay\n        // Some stray pixels outside the shape are false hits.\n        // Instead of refining our estimate further, we mask them out by the implicit\n        // function: if the hits are too far from the surface, we discard them.\n        // The absolute tolerance wrt the implicit function varies with r and R,\n        // but our faked trace is surprisingly accurate in most places.\n        float tol_o = max(0.01, 0.02*torusr/torusR); // Outer part is very accurate indeed\n        float tol_i = max(0.05, 0.1*torusr/torusR);  // Inner part is slightly less accurate\n        // \"tolerance\" is tol_i inside R, tol_o outside. Blend to avoid accidental sparklies.\n        float tolerance = tol_i-(tol_i-tol_o)*smoothstep(torusR-torusr*0.5, torusR, length(hit.xy));\n\n        // Fill in some spurious false hits with the background color\n        float abserr = abs(torusd(torusR, torusr, hit)); // 0.0 on true torus surface\n        color = mix(color, bgcolor, step(tolerance, abserr));\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Anti-aliased implicit line around v = t, in the spirit of\n// aastep(), with line width w specified in fragment space (pixels)\nfloat aaline(float t, float v, float w) {\n  float fw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)\n\t- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);\n}\n\n// Ray trace against an infinite cylinder with axis through \"pc\"\n// in direction \"ez\" with radius \"r\", with a ray from point p in\n// direction v (p+t*v). Return both hits (smallest t in .x).\n// \"No hit\" is signalled with t=1e6.\n// Both direction vectors, ez and v, need to be normalized.\nvec2 tracecylinder(vec3 pc, vec3 ez, float r, vec3 p, vec3 v) {\n    vec3 dp = p - pc;\n    vec3 vez = v - dot(v,ez)*ez;\n    vec3 dpez = dp - dot(dp,ez)*ez;\n    float a = dot(vez, vez);\n    float b2 = dot(vez, dpez); // b/2 for eqn \"a*t^2 + b*t + c = 0\"\n    float c = dot(dpez, dpez) - r*r;\n    float p2 = b2/a;\n    float q = c/a;\n    float p2q = p2*p2 - q;\n    vec2 t;\n    if(p2q < 0.0)\n        return vec2(1e6);\n    else {\n        float sqrtp2q = sqrt(p2q);\n        t.x = -p2 - sqrtp2q; // Closest hit\n        t.y = -p2 + sqrtp2q; // Farthest hit\n        return t;\n    }\n}\n\n// Ray trace against a \"rotational hyperboloid of one\n// surface\" with rotational symmetry along the z axis,\n// and parameters a and c according to the equation:\n// (x^2 + y^2)/a^2 - z^2/c^2 - 1 = 0\n// with a ray from point p in direction v: (p+t*v).\n// Return both hits, with smallest t in .x\n// \"No hit\" is signalled with t = 1e6.\nvec2 tracehyperboloid(float a, float c, vec3 p, vec3 v) {\n    vec3 s = vec3(1.0, 1.0, -a*a/c/c);\n    vec3 vs = v*s;\n    float rvvs = 1.0/dot(v, vs);\n    float pvs = dot(p, vs);\n    float pps = dot(p, p*s);\n    float p2 = pvs*rvvs;\n    float q = (pps - a*a)*rvvs;\n    float d = p2*p2 - q;\n    vec2 t;\n    if(d < 0.0)\n        return vec2(1e6);\n    else {\n        float sqrtd = sqrt(d);\n        t.x = -p2 - sqrtd; // Closest hit\n        t.y = -p2 + sqrtd; // Farthest hit\n        return t;\n    }\n}\n\n// Trace ray against a plane at z = z0\n// (Very simple, but making it a function improves readability)\nfloat traceplane(float z0, vec3 p, vec3 v) {\n    if(v.z == 0.0)\n        if(p.z == z0)\n            return 0.0; // Questionable degenerate case, but consider it a hit\n        else\n            return 1e6;  // No hit if view is parallel to the plane\n    return (z0-p.z)/v.z; // As stated above, really very simple...\n}\n\n// Trace a sphere at the origin with radius r,\n// with a ray from point p in direction v.\n// The vector v need not be normalized, and\n// t will then vary with 1/vecnorm(v) such that\n// the hit point is p+t*v regardless of length(v).\n// This is suitable for a ray-transformed trace of an\n// ellipsoid, where hit points can be evaluated on the\n// original ray (untransformed origin and direction.)\nvec2 tracesphere(float r, vec3 p, vec3 v) {\n    float vvr = 1.0/dot(v,v);\n    float pv = dot(p,v);\n    float pp = dot(p,p);\n    float d = (pv*pv*vvr - pp + r*r) * vvr;\n    vec2 t;\n    if (d < 0.0)\n        return vec2(1e6);\n    t.x = -pv*vvr - sqrt(d);\n    t.y = -pv*vvr + sqrt(d);\n    return t;\n}\n\nvec2 traceellipsoid(vec3 pe, vec3 ex, vec3 ey, vec3 ez,\n                    float rx, float ry, float rz, vec3 p, vec3 v) {\n    mat3 Mi = transpose(mat3(ex, ey, ez)); // inverse (Orthonormal)\n    p = p - pe; // Translate ray to ellipsoid coords\n    p = Mi * p; // Rotate p to ellipsoid orientation\n    v = Mi * v; // Rotate v to ellipsoid orientation\n    p = p / vec3(rx, ry, rz); // Scale p to match spherified ellipsoid\n    v = v / vec3(rx, ry, rz); // Scale v to match spherified ellipsoid\n    return tracesphere(1.0, p, v); // Trace unit sphere at origin\n}\n\n// Fake raytracing of a torus, using nothing but quadric surfaces.\n// The return value is the ray distance t to the nearest hit point\n// p + t*v. \"No hit\" is signalled by t = 1e6.\nfloat tracefaketorus(float R, float r, vec3 p, vec3 v) {\n    // To require less sign checks and conditionals below, flip sign\n    // of z if needed so that v points in the negative z direction,\n    // and in the positive x and y directions.\n    vec3 flip = sign(v);\n    flip.z = -flip.z;\n    p *= flip;\n    v *= flip;\n    // Trace an oblate spheroid B for a rough bounds check\n    vec2 tb = traceellipsoid(vec3(0.0,0.0,0.0),\n        vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), vec3(0.0,0.0,1.0),\n        R+r, R+r, sqrt(r*(R+r)), p, v);\n    if(tb.x >= 1e6)\n        // Outside the large spheroid: no hit\n        return 1e6;\n    vec3 B1 = p + tb.x*v; // Hit points on bounding spheroid\n    vec3 B2 = p + tb.y*v;\n    if(((B1.z >= r) && (B2.z >= r)) || ((B1.z <= -r) && (B2.z <= -r)))\n        // Outside the bounds when taking z into consideration: no hit\n        return 1e6;\n    // Next, trace a \"hole bounds\" hyperboloid H (radius R-r at z=0)\n//    vec2 th = tracecylinder(vec3(0.0,0.0,0.0), vec3(0.0,0.0,1.0), R-r, p, v);\n    vec2 th = tracehyperboloid(R-r, sqrt(r*(R-r)), p, v);\n    if (th.x >= 1e6) {\n        // Check for hole passage (hit with z=0 within radius R)\n        float tc = traceplane(0.0, p, v);\n        if(length(p.xy + tc*v.xy) < R-r)\n        // Ray passes through hole: no hit\n        return 1e6;\n    }\n    vec3 H1, H2;\n    H1 = p + th.x * v;\n    H2 = p + th.y * v;\n    // Tighten the bounds trace if needed\n    if(B1.z >= r) { // If we hit the \"top dome\" above z=r\n        // Retrace to +z plane\n        tb.x = traceplane(r, p, v);\n        B1 = p + tb.x*v;\n    }\n    // Time to determine whether we hit the \"inside\" or the \"outside\"\n    // of the torus (negative or positive Gaussian curvature, inside\n    // or outside radius R in the xy plane) and act accordingly.\n    float a1, a2, a, Ca, Sa, t, tp, tn, tf, tc, te;\n    vec3 C, q;\n    if(length(B1.xy) < R) { // \"Inside\": hit point < R from z axis\n        // Trace two proxy cylinders and pick the closest hit\n        if((th.x >= 1e6) || ((H2.z <= -r))) {\n            // Hole bounds second hit is nonexistent or useless:\n            // Use plane hit for a1, trace to plane z=-r for a2\n            a1 = atan(B1.y,B1.x);\n            tp = traceplane(-r, p, v);\n            C = p + tp*v;\n            a2 = atan(C.y, C.x);\n        } else {\n            // Use plane hit for a1 and hole bounds hit for a2\n            a1 = atan(B1.y,B1.x);\n            a2 = atan(H2.y,H2.x);\n        }\n        // (Second hit is discarded here)\n        tn = (tracecylinder(vec3(R*cos(a1), R*sin(a1), 0.0),\n                            vec3(-sin(a1), cos(a1), 0.0), r, p, v)).x;\n        // (Second hit is discarded here)\n        tf = (tracecylinder(vec3(R*cos(a2), R*sin(a2), 0.0),\n                            vec3(-sin(a2), cos(a2), 0.0), r, p, v)).x;\n        // Hack #1: fill in errors at upper inner rim with a static cylinder\n        Ca = 1.0-r/R; // Azimuth angle at grazing hits to hole bounds cylinder\n        Sa = sqrt(1.0-Ca*Ca);\n        // (Second hit is discarded here)\n        tc = (tracecylinder(vec3(R*Ca, R*Sa, 0.0),\n                            vec3(-Sa, Ca, 0.0), r, p, v)).x;\n        // Hack #2: fill in gap near x=R-r with a static cylinder\n        // (Second hit is discarded here)\n        te = (tracecylinder(vec3(R, 0.0, 0.0),\n                            vec3(0.0, 1.0, 0.0), r, p, v)).x;\n        t = min(min(tn, tf), min(tc, te));\n    } else {\n        // \"Outside part\" of torus. We could tighten the bounds some more\n        // to mask out some spurious false hits at upper-outer rim, but this\n        // is now handled by post-processing (discard hits based on SDF).\n        //\n        // This case is considerably less finicky than above: it's enough to\n        // trace one spheroid to get a good estimate of the hit with the torus.\n        a = atan(B1.y,B1.x); // Bounds are mostly quite tight on the outside\n        // (Second hit is discarded here)\n        t = (traceellipsoid(vec3(R*cos(a), R*sin(a), 0.0),\n                            vec3(-sin(a), cos(a), 0.0),\n                            vec3(cos(a), sin(a), 0.0),\n                            vec3(0.0,0.0,1.0),\n                            sqrt(R/r), r, r, p, v)).x;\n    }\n    if(t>=1e6)\n        return 1e6;\n    // Refine the hit for a \"corner case\" at upper-inner rim by\n    // retracing an ellipsoid centered at the first estimated hit\n    // (The condition here would be \"abs(q.x)>R\" in an ortho view)\n    q = p + t*v;\n    if(length(q.xy-dot(q.xy,normalize(v.xy))*v.xy) > R) {\n        a = atan(q.y,q.x);\n        // (Second hit is discarded here)\n        t = (traceellipsoid(vec3(R*cos(a), R*sin(a), 0.0),\n                            vec3(-sin(a), cos(a), 0.0),\n                            vec3(cos(a), sin(a), 0.0),\n                            vec3(0.0,0.0,1.0),\n                            sqrt(R/r), r, r, p, v)).x;\n    }\n    // Another corner case: refine the upper rim inside R.\n    // Most of these errors are between R and R-r, due to no hits with C.\n    if(length(q.xy) < R) {\n        a = atan(q.y,q.x);\n        // (Second hit is discarded here)\n        t = (tracecylinder(vec3(R*cos(a), R*sin(a), 0.0),\n                           vec3(-sin(a), cos(a), 0.0),\n                           r, p, v)).x;\n    }\n    return t;\n}\n\n// \"Implicit torus\": SDF for a torus with main axis along z,\n// centered on the origin, with major radius R and minor radius r\nfloat torusd(float R, float r, vec3 p) {\n    float b = R-length(p.xy);\n    return b*b + p.z*p.z - r*r;\n}\n\n// Gradient of the torus distance function above.\n// Can be used to compute the normal at the surface.\n// The argument r is not used, but kept for consistency with \"torusd\".\n// (Not sure that's such a great idea, actually, but anyway.)\nvec3 torusg(float R, float r, vec3 p) {\n     return vec3(2.0*p.xy*(1.0-sqrt(R/length(p.xy))), 2.0*p.z);\n}\n\n\n// Analytical ray-torus intersection, for comparison and validation\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n\n// Analytic intersection of a torus (degree 4 equation).\n// https://www.shadertoy.com/view/4sBGDy\n\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return -1.0;\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n","name":"Common","description":"","type":"common"}]}