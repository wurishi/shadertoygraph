{"ver":"0.1","info":{"id":"ctX3Wj","date":"1672503810","viewed":83,"name":"hill and cloud(practice FBM)","username":"nortonii","description":"一个非常简单粗糙的FBM生成的山和云，练习使用FBM","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 1000\n#define PI 3.1415926\nvec2 random2D2D (in vec2 st) {\nvec2 st1=vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(127.1,311.7)));\nreturn fract(sin(st1)* 43758.5453123);\n}\nfloat random2D2F (in vec2 st) {\nfloat st1=dot(st.xy,vec2(12.9898,78.233));\nreturn fract(sin(st1)* 43758.5453123);\n}\nfloat noise(vec2 uv){\nuv*=8.0;\nvec2 ind=floor(uv);\nvec2 cont=fract(uv);\nvec2 p[4];\np[0]=vec2(0.,0.);\np[1]=vec2(0.,1.);\np[2]=vec2(1.,0.);\np[3]=vec2(1.,1.);\nreturn 0.4*mix(mix(random2D2F(ind+p[0]),random2D2F(ind+p[1]),smoothstep(0.,1.,cont.y)),\n       mix(random2D2F(ind+p[2]),random2D2F(ind+p[3]),smoothstep(0.,1.,cont.y)),smoothstep(0.,1.,cont.x));\n}\n//1.0*1.0的山地模型，先在屏幕空间产生射线，步进，变换射线到模型空间，计算相交，没相交，继续步进\nfloat map(vec2 uv){\n    float result=0.0;\n    float am=0.4;\n    for(int i=0;i<3;i++){\n    result+=am*noise(uv);\n    uv*=3.0;\n    am/=2.0;}\n    return abs(result*2.0-1.0);\n}\nvec3 rotx(vec3 ray,float theta){\nmat3 rot=mat3(1.,0.,0.,\n0.,cos(theta),-sin(theta),\n0.,sin(theta),cos(theta));\nreturn rot*ray;\n}\nvec3 roty(vec3 ray,float theta){\nmat3 rot=mat3(\ncos(theta),0.,-sin(theta),\n0.,1.,0.,\nsin(theta),0.,cos(theta));\nreturn rot*ray;\n}\nvec3 getNormal(vec2 uv,float dxdy){\nvec3 result=vec3(0.0);\nfloat z=map(uv);\nfloat dz1=map(uv+dxdy*vec2(1.0,0.0))-z;\nfloat dz2=map(uv+dxdy*vec2(0.0,1.0))-z;\nresult=vec3(dz1/dxdy,dz2/dxdy,1.);\nreturn result;\n}\n\nvec2 random2D2D2 (vec2 st) {\nvec2 st1=vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(127.1,311.7)));\nreturn -1.+2.*fract(sin(st1* 43758.5453123));\n}\nfloat noise1(vec2 uv){\nvec2 ind=floor(uv);\nvec2 cont=fract(uv);\nvec2 f=cont;\nvec2 p[4];\np[0]=vec2(0.,0.);\np[1]=vec2(0.,1.);\np[2]=vec2(1.,0.);\np[3]=vec2(1.,1.);\nvec2 u = smoothstep(0.,1.,f);\nreturn mix(mix(dot(random2D2D2(ind+p[0]),cont-p[0]),dot(random2D2D2(ind+p[1]),cont-p[1]),u.y),\n       mix(dot(random2D2D2(ind+p[2]),cont-p[2]),dot(random2D2D2(ind+p[3]),cont-p[3]),u.y),u.x);\n}\n\nfloat cloud( vec2 uv )\n{\n    uv = uv*vec2(iResolution.x/iResolution.y,1.0);\n    float result=0.0;\n    float am=0.7;\n    float fade=0.6;\n    float scale=1.5;\n    uv*=scale;\n    uv+=iTime*0.1;\n    for(int i=0;i<8;i++){\n    result+=am*noise1(uv);\n    uv*=mat2( 1.6,  1.2, -1.2,  1.6 );\n    uv-=iTime*0.1;\n    am*=fade;\n    }\n    return result;}\n//(0.,0.)到(1.,1.)是模型的底，最高为1，所以我们从(0.5,0.5,0.5)发射射线\n//步进法\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 ori=vec3(0.5,-1.0,1.0);\n    vec2 st=uv-vec2(0.5,0.5);\n    vec3 ray=normalize(vec3(st.x,0.2,st.y));\n    vec3 light=normalize(vec3(0.0,0.0,1.0));\n    float lightIntensity=2.0;\n    ray=normalize(rotx(ray,0.2));\n    ori.x+=0.2*sin(iTime*0.4);\n    vec3 test=ori;\n    bool hit=false;\n    float d=0.01;\n    float step1=0.01;\n    vec3 hitPoint=vec3(0.0);\n    for(int i=0;i<STEPS;i++){\n    if(abs(test.x)>2.0 || abs(test.y)>2.0){\n    break;}\n    test+=step1*ray;\n    d=map(test.xy);\n    if(test.z-d<=1e-3){\n    hitPoint.z=d;\n    hitPoint.xy=test.xy;\n    hit=true;\n    break;}\n    step1=min(step1,0.1*abs(d-test.z))+0.0001;\n    }\n    vec3 n=normalize(getNormal(hitPoint.xy,0.000001));\n    lightIntensity*=1.-smoothstep(0.0,0.2,cloud(hitPoint.xy));\n    // Output to screen\n    if(hit)\n    fragColor = vec4(0.0,hitPoint.z,0.0,1.0)*dot(n,light)*lightIntensity;\n    else\n    fragColor = vec4(130.0/255.0,206.0/255.,250.0/255.,1.0)+smoothstep(0.0,0.2,cloud(uv));\n}","name":"Image","description":"","type":"image"}]}