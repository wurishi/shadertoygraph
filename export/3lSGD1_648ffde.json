{"ver":"0.1","info":{"id":"3lSGD1","date":"1559280040","viewed":93,"name":"Quadrupole","username":"hirak99","description":"Electric potential of four charges facing off each other.\n\nAlso gave me the excuse to demonstrate a pseudo-random function that is continuous over time - tricky without persistent variables.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["field","charge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float seed, float t) {\n    vec2 p = vec2(seed, t);\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat smooth_random(in float seed, in float t) {\n    float s1 = floor(t);\n    float s2 = s1 + 1.;\n    return hash(seed, s1) * (1. - fract(t)) + hash(seed, s2) * fract(t) - 0.5;\n}\n\nfloat rvec2_seed = 1.;\nvec2 rvec2(in float x, in float y) {\n    rvec2_seed += 0.1;\n    return vec2(x + smooth_random(rvec2_seed + 0., iTime * 10.) / 20.,\n                y + smooth_random(rvec2_seed + 0.05, iTime * 10.) / 20.);\n}\n\n\nfloat potential_at(in vec2 coord) {\n    coord /= 100.;\n    return 1. / length(coord - rvec2(1., -1.)) - 1./length(coord - rvec2(1., 1.)) +\n        1. / length(coord - rvec2(-1., 1.)) - 1./length(coord - rvec2(-1., -1.));\n    // return 1. / length(coord) + coord.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    float p = potential_at(uv) * 2.;\n\n    //int c = mod(p, 1.) < 0.02 ? 0 : 1;\n    float c = sin(3.1415926535 * mod(p, 1.));\n\n    vec3 col;\n    if (p < 0.) {\n    \tcol = vec3(1, 0, 0) * c;\n    } else {\n    \tcol = vec3(0, .5, 1) * c;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}