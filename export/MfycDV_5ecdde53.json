{"ver":"0.1","info":{"id":"MfycDV","date":"1732390628","viewed":131,"name":"kaliuresis - color variation","username":"najibxy","description":"kaliuresis - color variation","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["spin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Color variation from kaliuresis \n\n#define halfsqrt3 0.86602540\n#define invsqrt3 0.57735026\n#define tau 6.28318530\n#define pi 3.14159265358979323846264338327950\n\nfloat hash1D(vec2 x) {\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nvec2 hash2D(vec2 x) {\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 65536.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\nfloat hash(vec2 x, float time) {\n    return 0.5 + 0.5 * sin(tau * hash1D(x) + time);\n}\n\n// Value noise on a triangular lattice\nfloat tri_noise(vec2 p, float time) {\n    vec2 q = vec2(p.x - p.y * invsqrt3, p.y * 2.0 * invsqrt3);\n    vec2 iq = floor(q);\n    vec2 fq = fract(q);\n    float v = 0.0;\n    \n    float h = step(1.0, fq.x + fq.y); // which half of the unit cell this triangle lies in\n    vec2 c = iq + h;\n    vec2 r = p - vec2(c.x + 0.5 * c.y, halfsqrt3 * c.y);\n    float s = 1.0 - 2.0 * h;\n    r *= s;\n    \n    // Compute barycentric coordinates\n    vec3 lambda = vec3(1.0 - r.x - invsqrt3 * r.y, r.x - invsqrt3 * r.y, 2.0 * invsqrt3 * r.y);\n    // Quintic smoothing\n    vec3 lambda2 = lambda * lambda;\n    vec3 a = 15.0 * lambda2 * lambda2.zxy * lambda.yzx;\n    vec3 w = lambda * lambda2 * (10.0 - 15.0 * lambda + 6.0 * lambda2) + a + a.yzx;\n    \n    v += w.x * hash(abs(c), time);\n    v += w.y * hash(abs(iq + vec2(1.0 - h, h)), time);\n    v += w.z * hash(abs(iq + vec2(h, 1.0 - h)), time);\n    \n    return v;\n}\n\nfloat fbm(vec2 p, int octaves, float decay, float time) {\n    vec2 fwp = fwidth(p);\n    float w = dot(step(fwp.xy, fwp.yx), fwp);\n    vec2 v = vec2(0.0);\n    float weight = 1.0;\n    for (int i = 0; i < octaves; i++) {\n        v += weight * vec2(tri_noise(p, time) * smoothstep(1.0, 0.5, w), 1.0);\n        p *= 2.0 * mat2(4.0 / 5.0, -3.0 / 5.0, 3.0 / 5.0, 4.0 / 5.0);\n        w *= 2.0;\n        weight *= decay;\n        time *= 1.6;\n    }\n    return v.x / v.y;\n}\n\nfloat fcos(float x) {\n    float w = fwidth(x);\n    return cos(x) * sin(0.5 * w) / (0.5 * w);\n}\n\nfloat get_val(vec2 p) {\n    float l = length(p);\n    float wavf = 0.02;\n\n    // Adjust time to slow down further and loop in 20 seconds\n    float time = mod(iTime, 40.0) / 40.0 * tau; // Slow down: 40 seconds total loop time\n    \n    float w = fbm(5.0 * p + vec2(7.0), 3, 0.6, 0.01 * time);\n    float angle = 0.12 * time - 1.0 / wavf * 0.005 * fcos(100.0 * l + wavf * time) \n                  - 2.5 * log(l + 0.01) - 0.5 * w;\n    vec2 cs = vec2(cos(angle), sin(angle));\n    p = vec2(p.x * cs.x - p.y * cs.y, p.x * cs.y + p.y * cs.x);\n    \n    vec2 up = 5.0 * p + vec2(7.0);\n    float u = fbm(up, 6, 0.6, 0.01 * time) - 0.5;\n    u = fcos(10.0 * u);\n    vec2 vp = 2.0 * u + vec2(1.0);\n    float v = fbm(vp, 3, 0.3, 10.0 + 0.1 * time);\n    \n    v += 20.0 * l * smoothstep(0.0, 0.02, l);\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 p = 0.1 * uv;\n    float l = length(p);\n    float v = get_val(p);\n    \n    fragColor = mix(vec4(0.682, 0.055, 0.506,1.0), \n                    vec4(0.627, 0.09, 0.188, 1),\n                    smoothstep(1.5, 1.5, v));\n    vec2 e = vec2(2.0 * dFdx(p.x), 0.0);\n    vec3 grad = normalize(0.5 * vec3((get_val(p + e.xy) - get_val(p - e.xy)), \n                                     0.5 * (get_val(p + e.yx) - get_val(p - e.yx)), \n                                     10.0 * e.x));\n    fragColor.rgb += vec3(0.5) * pow(clamp(dot(grad, normalize(vec3(1.0, 1.0, 1.0))), 0.0, 1.0), 10.0);\n    fragColor.rgb += vec3(0.25, 0.0, 0.0) * pow(clamp(dot(grad, normalize(vec3(-1.0, 1.0, 1.0))), 0.0, 1.0), 10.0);\n    fragColor.rgb *= smoothstep(-1.0, 0.0, 1.0 - v + 13.0 * l - 0.7);\n    fragColor.rgb *= smoothstep(-0.1, 0.4, abs(v - 1.0));\n}\n","name":"Image","description":"","type":"image"}]}