{"ver":"0.1","info":{"id":"Nscczf","date":"1653821319","viewed":111,"name":"mycubetest","username":"mu777","description":"my study","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// study\n// https://www.shadertoy.com/view/4dG3RK\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float DEG2RAD = PI/180.0;\nconst float RAD2DEG = 180.0/PI;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\nconst float EPSILON = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nconst vec3 mainCol = vec3(0.0, 0.7, 0.7);\nconst vec3 bgCol = vec3(0.2, 0.2, 0.2);\nconst float unlitRate = 0.3;\n\nfloat distanceToNearestSurface(vec3 p){\n\t// Sphere\n    //return length(p) - 1.0;\n    \n    // Cube\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return length(max(d, 0.0));\n    //return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    //float d = 0.0;\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(-1.0);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0, 30.0, 50.0);\n            result = computeLambert(hit, computeSurfaceNormal(hit), light);\n            result = clamp(result, 0.0, 1.0);\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float camDist = 10.0;\n    vec2 mouseuv = iMouse.xy / iResolution.xy;\n    float maxCamAngle = 80.0 * DEG2RAD;\n    float theta = (mouseuv.y-0.5) * 2.0 * maxCamAngle;\n    float phi = (mouseuv.x-0.5) * 2.0 * maxCamAngle;\n    vec3 camPos = vec3(camDist*cos(theta)*cos(phi),\n                       camDist*sin(theta),\n                       camDist*cos(theta)*sin(phi));\n\tvec3 camDir = normalize(-camPos);\n\tvec3 nup = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = DEG2RAD * fov * 0.5;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 camRight = normalize(cross(nup, camDir));\n    vec3 camUp = normalize(cross(camDir, camRight));\n    vec3 pixel = camPos + camDir + camRight*camUV.x*ulen + camUp*camUV.y*vlen;\n    vec3 rayDir = normalize(pixel - camPos);\n    \n    vec3 pixelColor = intersectWithWorld(camPos, rayDir);\n    \n    if (pixelColor.x < 0.0) {\n        fragColor = vec4(bgCol, 1.0);\n    } else {\n        fragColor = vec4(mix(mainCol, pixelColor*mainCol, unlitRate), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}