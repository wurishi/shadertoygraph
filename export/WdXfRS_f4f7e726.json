{"ver":"0.1","info":{"id":"WdXfRS","date":"1588438108","viewed":851,"name":"Castle in the Sky ~","username":"sukupaper","description":"I've tried to recreate the famous flying castle using raymarching ~","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","anime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float t;\nfloat aa;\n\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,s,-s,c);}\nfloat rand(vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\n\n// 2D Primitives\nfloat sq(vec2 p, vec2 s, float r) { return length(max(abs(p) - s,0.)) - r;}\n\n// df operations\nfloat ext(float d, vec3 p, float h) {\n    vec2 w = vec2(d,abs(p.z) - h);\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\nfloat smoothunion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// 3D Primitives\nfloat sph(vec3 p, float s) { return length(p) - s; }\nfloat box(vec3 p, vec3 s, float r) { return length(max(abs(p) - s,0.)) - r;}\nfloat cyl2( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return max(length(max(abs(p.y) - h,0.)) - .01, length(p.xz) - r) - .01;\n}\nfloat hollowcyl( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return max(length(max(abs(p.y) - h,0.)) - .01, abs(length(p.xz) - r) - .0) - .01;\n}\nfloat door(vec3 p, float s) {\n    p *= s;\n    float d2d = sq(p.xy,vec2(-.05,.515),.3);\n    float d = ext(d2d,p,.2);\n    return d/s;\n}\nfloat doors1(vec3 p, float s) {\n    p *= s;\n    float d = max(box(p,vec3(.9,1.,.15),.01),-door(p - vec3(0.,-1.3,(-0.525)),.4));\n    p.x = abs(p.x);\n    d = max(d,-door(p - vec3(0.3,-.5,(-0.1)),1.2));\n    d = max(d,-box(p - vec3(0.3,-0.15,0.),vec3(.04,.08,.2),.001));\n    d = max(d,-box(p - vec3(0.,0.35,0.),vec3(.04,.08,.2),.001));\n    return d/s;\n}\nfloat towers1(vec3 p) {\n    p.x -= .65;\n    float d = hollowcyl(p,.51,.2) - .004*step(0.5,fract(1.5*p.y));\n    vec3 p1 = p; p1.x = abs(p.x) - .02; p1.z += .1;\n    d = max(d,-box(p1,vec3(.005,.02,5.),.001));\n    d = max(d,-box(p1 + vec3(0.,.325,0.),vec3(.005,.02,5.),.001));\n    d = max(d,-box(p1 - vec3(0.,.325,0.),vec3(.005,.02,5.),.001));\n    p.y -= .5;\n    d = smoothunion(d,sph(p,.19),.02);\n    return d;\n}\n\nfloat towersAndDoors(vec3 p, float s) {\n    p *= s;\n    p.x = abs(p.x) - .375;\n    float d1 = doors1(p*vec3(1.,1.,-1.),1.992);\n    float d2 = towers1(p);\n    float d = min(d1,d2);\n    return ((d - .005*smoothstep(0.45,0.455,p.y)) + .0001*rand(floor(p.xy*vec2(.75,1.)*180.)))/s;\n}\n\nfloat buildings(vec3 p, float s) {\n    float a = atan(p.x,p.z);\n    float l = length(p.xz);\n    vec3 rP = vec3(fract(a*3.03*s) - .5,fract(p.y*13.) - .5,l);\n    float d = cyl2(p, .38,.2*s);\n    d = max(d,-box(rP,vec3(.075,.15,10.),.001));\n    d = min(d,sph((p - vec3(0.,0.4,0.))*vec3(1.,1.2,1.),.210*s));\n    return d;\n}\n\nfloat df(vec3 p) {\n    p.zy *= rot(cos(t*.2)*0. + 3.14*.25*.0 - .2);\n    p.xz *= rot(t*.05);\n    \n    float a = atan(p.x,p.z);\n    float l = length(p.xz);\n    vec3 rP = vec3(fract(a*3.024) - .5,p.y,l - 2.5);\n    vec3 rPfloor = vec3(floor(a*3.024) - .5,p.y,l - 2.5);\n    vec3 rPnorm = vec3(a,p.y,l - 2.5);\n    vec3 rP1 = vec3(fract((a + .2)*2.7058) - .5,p.y - .5,l - 2.2);\n    vec3 rP2 = vec3(fract((a + .3)*2.285) - .5,p.y - 1.,l - 1.9);\n    \n    // 3 walls\n    float d = 10e9;\n    d = towersAndDoors(rP,2.065);\n    d = max(d, -rP.y - (.25 - .01*rand(floor(rP.xz*150.)) - .04*rand(floor(rP.xz*20. + rPfloor.xz*20.)) + .02 ));\n    d = min(d, towersAndDoors(rP1,2.065));\n    d = min(d, towersAndDoors(rP2,2.065));\n    \n    // \"grid\" structure below\n    float div = .35;\n    vec3 pp; pp.y = rP.y; pp.xz = mod(rP.xz,div) - div*.5;\n    float dGrid = max(box(pp,vec3(.2,.17 - .1*rand(floor(rP.xz*5.)),.2),.01), -box(pp,vec3(.15,1.,.15),.01));\n    dGrid = max(dGrid,sph(p,2.45));\n    d = min(d,dGrid);\n    \n    // main sphere\n    vec3 pSph = p;\n    pSph.y += .18;\n    d = min(d,max(sph(pSph,1.6 - .025*rand(floor(rPnorm.xz*4.))),pSph.y - 0.44));\n    \n    // buildings\n    p.y -= .25;\n    vec3 rP3 = vec3(fract(a*1.1) - .5,p.y - 1.,l - 1.2);\n    p.y -= .1;\n    vec3 rP4 = vec3(fract((a*1.6 + 1.)*.25)*2. - .5,p.y - 1.,l - .8);\n    vec3 rP5 = vec3(fract((a*.7 + 0.)) - .5,p.y - 1.,l - .7);\n    p.y -= .1;\n    vec3 rP6 = vec3(fract(a*.5) - .5,p.y - 1.,l - .5);\n    d = min(d,buildings(rP3,.4));\n    d = min(d,buildings(rP4,1.5));\n    d = min(d,buildings(rP5,.8));\n    d = min(d,buildings(rP6,.6));\n    \n    // huge tree\n    float varTree = 12. + cos(t*.1);\n    p.y += pow(length(p.xz)*.51,4.);\n    d = min(d, sph((p - vec3(0.,1.9,0.))*vec3(1.,2.,1.) + fract(cos(p.x*varTree) + sin(p.y*varTree) + sin(p.y*varTree))*.032,1.25));\n    \n    return d;\n}\n\n#define E .001\nvec3 normal(vec3 p) {\n    vec2 u = vec2(0.,E); float d = df(p);\n    return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d);\n}\n\n#define MAX_D 60.\n#define MIN_D 40.\n#define MAX_STEP 30\n#define EDP aa*10.\n#define LIM .001\nvec3 rm(vec3 cam, vec3 rayDir) {\n    vec3 c = vec3(0.245,0.493,0.880) - rayDir.y*2.;\n    vec3 pInit = cam + rayDir*MIN_D;\n    vec3 p = pInit;\n    float prevD = 10e9;\n    for(int i = 0; i < MAX_STEP; i++) {\n        float d = df(p);\n        if(prevD < EDP && d > prevD) return c;\n        if(d < LIM) {\n            float dist = clamp(pow(distance(p,pInit)*.1,12.),0.,1.);\n            vec3 n = normal(p);\n            vec3 light = normalize(vec3(-1.095,1.204,-1.006));\n            float lInf = clamp(dot(n,light),0.,1.);\n            vec3 c1 = vec3(0.274,0.445,0.840)*dist*2. + vec3(0.605,0.581,0.080)*smoothstep(0.5-aa,.5+aa,lInf)-n;\n            c = mix(c1,c,dist*.75);\n            return c+.2;\n        }\n        if(distance(pInit,p) > MAX_D) return c;\n        p += d*rayDir;\n        prevD = min(prevD,d);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    t = iTime;\n\taa = 1./iResolution.x;\n\n    vec3 c = vec3(0.,.55,-50.);\n    vec3 r = normalize(vec3(uv,9.));\n    vec3 col = rm(c,r);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}