{"ver":"0.1","info":{"id":"sdKSRy","date":"1634865471","viewed":119,"name":"Fork Spiraled L with periodic t","username":"froggynotacon","description":"Original author said it looked cool if you inverted time.  Well, what if time was periodic?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","spiral","roll","rolling"],"hasliked":0,"parentid":"Ns3XWf","parentname":"Spiraled Layers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define STEPS 200.0\n#define MDIST 100.0\n\n//some neat animation\n//#define FUN_MODE\n\n//Reverse time\n//#define iTime -iTime\n\n//Change to 2.0 for AA\n#define AA 1.0\n\nvec3 rdg = vec3(0);\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\nfloat h11(float a) {\n    a+=0.65343;\n    return fract(fract(a*a*12.9898)*43758.5453123);\n}\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    p/=b;\n    vec3 dir = sign(rd)*.5;   \n    vec3 rc = (dir-p)/rd;\n    rc*=b;\n    float dc = rc.z+0.01;\n    return dc;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\nfloat lim2(float p, float s,  float limb){\n    return p-s*min(round(p/s),limb);\n}\nfloat idlim2(float p, float s, float limb){\n    return min(round(p/s),limb);\n}\nfloat spiral(vec2 p, float t, float m, float scale, float size, float expand){\n    size-=expand-0.01;\n    //Offset Spiral To the left\n    t = max(t,0.);\n    \n    p.x+=pi*-t*(m+m*(-t-1.));\n    t-=0.25;\n    \n    vec2 po = p;\n    //Move Spiral Up\n    p.y+=-t*m-m*0.5;\n    \n    //Counter the rotation\n    p*=rot(t*pi*2.+pi/2.);\n    \n    //Polar Map\n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    //Create Spiral\n    p.y+=theta*scale*0.5;\n\n    //Duplicate Line outwards to fill spiral\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n    \n    //float hel = -(theta+pi)/(2.*pi)+id;\n    \n    //Line SDF of the spiral\n    float a = abs(p.y)-size;\n    \n    //Calcuate moving outer spiral segment\n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    //The unrolled Line SDF\n    a = min(a,b-size);\n    b = abs(po.y)-size;\n    b = max(po.x,b);\n    //if(b<a) hel = po.x-(pi*-t*(m+m*(-t-1.))-3.);\n    //else hel*=id;\n    \n    //Combine Them\n    a = min(a,b);\n\n    return a;\n}\nvec3 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    float c = 0.;\n    float t = 10. * -sin(0.5*iTime)*sin(-iTime)*sin(iTime);\n\n    float size = 0.062; //Thickness of spiral curls\n    float scale = size-0.01 ; //Space between spiral curls\n    \n    float expand = 0.04; //Corner Rounding Amount \n\n    float m2 = size*6.0; //Repetition Sizes\n    float m = pi*scale; //Repetition Sizes\n    \n    float ltime = 10.; //How often the spirals rolls repeat\n    \n    //Move everything upwards so it stays in frame\n    p.y-=(t/ltime)*size*6.;\n    \n    //small offset for framing\n    p.x-=3.; \n    \n    float width = 0.5; //Lane Width\n    float count = 6.; //Number of spirals (x2)\n    \n    float modwidth = width*2.0+0.04+0.06;\n    \n    float id3 = idlim(p.z,modwidth,-count,count);\n    t+=h11(id3*0.76)*8.0;\n    p.z = lim(p.z,modwidth,-count,count);\n    \n    #ifdef FUN_MODE\n        scale+=(sin(t)*0.5+0.5)*0.05;\n        m = pi*scale;\n    #endif\n    \n    float to = t;\n    vec3 po = p;\n\n    //float id = 0.;\n\n    //Spiral 1\n    float stack = -floor(t/ltime);\n    float id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    a.x = spiral(p.xy,t,m,scale,size,expand);\n    //a.y = id2*3.-2.;\n    c = a.x;\n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 2\n    p = po;\n    t = to;\n    p.y+=size*2.0;\n    t-=ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    \n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    //b.y = id2*3.-1.;\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 3\n    p = po;\n    t = to;\n    p.y+=size*4.0;\n    t-=2.*ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);    \n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    //b.y = id2*3.;\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal\n    \n    \n    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;\n    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand;\n    \n    //Intersection distance to plane between each lane\n    b.x = diplane(po ,vec3(modwidth), rdg); //Artifact Removal\n    b.y = 0.;\n    \n    //a.y-=10.0;\n    //a.y+=h11(id3);\n    \n    a=(a.x<b.x)?a:b; //Artifact Removal\n    \n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor,in vec2 fragCoord){\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    float px = 8./iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(5,1.8,-12)*1.2;\n    ro.zx*=rot(0.09);\n    \n    //Mouse control\n    if(iMouse.z>0.5){\n    ro.yz*=rot(0.5*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-0.5*(iMouse.x/iResolution.x-0.5));\n    }\n    //Camera Setup\n    vec3 lk = vec3(-2.5,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*2.0+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n\n    vec3 p = ro;\n    vec3 d;\n    float dO = 0.;\n    bool hit = false;\n    \n    //Raymarcher\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.001||i==STEPS-1.0){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    //Color Surface\n    if(hit&&d.y!=0.){\n        vec3 ld = normalize(vec3(0.5,0.4,0.9));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        rdg = ld;\n        float shadow = 1.;\n        for(float h = 0.09; h<7.0;){\n            vec3 dd = map(p+ld*h+n*0.005);\n            if(dd.x<0.001&&dd.y==0.0){break;}\n            if(dd.x<0.001){shadow = 0.0; break;}\n            shadow = min(shadow,dd.z*30.0);\n            h+=dd.x;\n        }\n        shadow = max(shadow,0.8);\n\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.05,n,p)*AO(.1,n,p);\n        ao = max(ao,0.1);\n        n.xz*=rot(4.*pi/3.);\n        col = n*0.5+0.5;\n        col = col*shadow;\n        col*=ao;\n\n    }\n    //Color Background\n    else{\n        col = mix(vec3(0.355,0.129,0.894),vec3(0.278,0.953,1.000),clamp((rd.y+0.05)*2.0,-0.15,1.5));\n    }\n    //Gamma Approximation\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);  \n}\n\n//External AA (check render function for usual code)\n#define ZERO min(0.0,iTime)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float px = 1.0/AA; vec4 col = vec4(0);\n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n","name":"Image","description":"","type":"image"}]}