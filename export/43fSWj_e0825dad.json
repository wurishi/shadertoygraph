{"ver":"0.1","info":{"id":"43fSWj","date":"1712072826","viewed":343,"name":"tm menger sponge","username":"tubeman","description":"like menger sponge but divides space by 4 instead of 3\n\nif you have any tips for a shader noob on how to refine things, please don't hesitate to leave a comment <3","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["menger","sponge","flythrough"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 16.\n#define PI 3.14159\n#define TAU (2.*PI)\n\n//https://suricrasia.online/blog/shader-functions/\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\nfloat hash31(vec3 p) {\n    return hash(vec2(hash(p.xy), p.z));\n}\n\nfloat sdBox( in vec3 p, float r) {\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 scene(vec3 p) {\n    // based on https://iquilezles.org/articles/menger/\n    vec2 res = vec2(sdBox(p, 10000.), 0.);\n    float s = 1.;\n    for (float i=1.; i<=5.; i++) {\n        vec3 pRep = mod( p*s, 2.0 )-1.0;\n        s *= 4.;\n        vec3 q = abs(1. - 4.*abs(pRep));\n        float da = max(q.x,q.z);\n        float db = max(q.y,q.z);\n        float dc = max(q.x,q.y);\n        float d = (min(da,min(db,dc))-1.01)/s;\n        if (d>res.x) {\n            res = vec2(d,i);\n        }\n    }\n    return res;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    vec3 r = vec3(scene(p+e.xyy).x-scene(p-e.xyy).x, scene(p+e.yxy).x-scene(p-e.yxy).x, scene(p+e.yyx).x-scene(p-e.yyx).x);\n    return normalize(r);\n}\n\nvec3 castRay(vec3 cam, vec3 rd) {\n    float tot = 0.;\n    float iter = 0.;\n    float id = 0.;\n    for (int i = 0; i < 256; i++) {\n        vec3 p = cam + tot*rd;\n        vec2 r = scene(p);\n        float d = r.x;\n        tot += d;\n        if (abs(d) < .0001*(1.+tot*4.)) {\n            iter = r.y;\n            id = hash31(floor(p));\n            break;\n        }\n        if (tot >= FAR) {\n            tot = FAR;\n            break;\n        }\n    }\n    return vec3(tot, iter, id);\n}\n\n// adapted from @Shane\nfloat getAO(vec3 sp, vec3 sn){\n\tfloat occ = 0.;\n    for (float i=0.; i<4.; i++) {\n        float t = i*.1;        \n        float d = scene(sp + sn*t).x;\n        occ += t-d;\n    }\n    return clamp(1.-occ, 0., 1.);    \n}\n\n// adapted from @iq\nvec3 pal(float t) {\n    vec3 b = vec3(.5);\n    vec3 c = vec3(.5);\n    return b + c*cos(6.28318*(t*vec3(.5,.5,1)+vec3(.25,.4, .25)));\n}\n\nvec3 camPath(float t) {\n    t -= PI/2.+.5;\n    float t2 = t+.5;\n    float x = 1.+sin(t2+sin(t2*2.)/2.);\n    float y = 1.+sin(t+sin(t*2.)/2.);\n    return vec3(x,y,t*.6379);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.3;\n    vec3 cam = camPath(t);\n    // @Shane\n    vec3 target = camPath(t+.25);\n    float FOV = PI/2.;\n    vec3 fwd = normalize(target-cam);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n\n    vec3 r = castRay(cam, rd);\n    float d = r.x;\n    float iter = r.y;\n    float id = r.z;\n    vec3 sp = cam + rd*d;\n    vec3 sn = calcNormal(sp);\n\n    vec3 col = pal(iter/5.+1.4);\n    if (iter > 3.) col *= .01;\n\n    float glow = sin(iTime*2.+id*PI)*.5+.5;\n    if (iter == 1.) col = mix(col*.1,col,glow);\n    col *= mix(.5, 1. ,glow);\n    \n    vec3 fogCol = vec3(.85,.64,.5)*1.5;\n    float fogStart = 1.;\n\n    float ao = getAO(sp,sn);\n    ao = pow(ao, 5.);\n    col *= ao*fogCol*fogCol;\n\n    float v = smoothstep(0.,1., max(0., (d-fogStart)/(FAR-fogStart)));\n    col = mix(col, fogCol, v);\n    fragColor.xyz = pow(col, vec3(.4545));\n}","name":"Image","description":"","type":"image"}]}