{"ver":"0.1","info":{"id":"4XSBzz","date":"1729097056","viewed":43,"name":"upsidedown","username":"veeluminati","description":"idk","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["idk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple Noise Function (from https://www.shadertoy.com/new)\nfloat noise(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Improved Perlin Noise Function for Smoother Waves\nfloat perlinNoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    // Four Corners in 2D of a Tile\n    float a = noise(i);\n    float b = noise(i + vec2(1.0, 0.0));\n    float c = noise(i + vec2(0.0, 1.0));\n    float d = noise(i + vec2(1.0, 1.0));\n    \n    // Smooth Interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    // Mix 4 Corners Interpolating the Values\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Procedural Wave Function with Perlin Noise\nfloat waveHeight(vec2 pos, float freq, float amp, float seed) {\n    pos *= freq;\n    float n = perlinNoise(pos + seed + iTime * 0.1); // Animated waves using Perlin noise\n    return sin(n * 6.2831) * amp;\n}\n\n// Gerstner Wave Function for Realistic Wave Shapes\nvec3 gerstnerWave(vec2 pos, float amp, float freq, float speed, float phase, vec2 dir) {\n    float theta = dot(dir, pos * freq) + iTime * speed + phase;\n    float displacement = sin(theta) * amp;\n    float steepness = 0.4; // Adjusted steepness for more natural wave peaks\n    vec2 displacementDir = dir * (cos(theta) * steepness * amp);\n    return vec3(displacementDir, displacement);\n}\n\n// Fresnel Effect for More Realistic Water\nfloat fresnel(vec3 viewDir, vec3 normal, float bias, float scale, float power) {\n    return bias + scale * pow(1.0 - dot(viewDir, normal), power);\n}\n\n// Phong Shading for Improved Lighting and Shadows\nvec3 phongShading(vec3 normal, vec3 lightDir, vec3 viewDir, vec3 lightColor, vec3 diffuseColor) {\n    // Diffuse\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * diffuseColor * lightColor;\n    \n    // Specular\n    float specStrength = 0.3; // Reduced specular strength for natural reflection\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);\n    vec3 specular = specStrength * spec * lightColor;\n    \n    return diffuse + specular;\n}\n\n// Glowing Sun Function with 3D Shadow Effect\nvec3 glowingSun(vec2 uv, vec2 sunPos, float radius, vec3 sunColor) {\n    float dist = length(uv - sunPos);\n    float glow = smoothstep(radius, radius * 1.5, dist);\n    vec3 sun = sunColor * (1.0 - glow);\n    \n    // Adding 3D Shadow Effect\n    float shadow = smoothstep(radius * 0.9, radius * 1.1, dist);\n    vec3 shadowColor = vec3(0.1, 0.05, 0.05); // Deep shadow color\n    sun = mix(sun, shadowColor, shadow);\n    \n    // Adding spherical shading\n    float shading = clamp(dot(normalize(vec3(0.0, 1.0, 1.0)), normalize(vec3(uv - sunPos, radius))), 0.0, 1.0);\n    sun *= 0.5 + 0.5 * shading; // Darken the sun based on spherical shading for a 3D effect\n    \n    return sun;\n}\n\n// Caustics Function to Simulate Light Refraction in Water\nfloat caustics(vec2 uv, float time) {\n    float scale = 6.0;\n    uv *= scale;\n    float noiseValue = perlinNoise(uv + time * 0.3) * 0.5 + 0.5;\n    return pow(noiseValue, 2.0) * 0.1; // Further reduced intensity for subtle caustics\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize Coordinate\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera Setup (simple pan and zoom)\n    float zoom = 1.0;\n    float panX = sin(iTime * 0.02) * 0.05; // Adjusted pan speed and range for smoother movement\n    uv = (uv + vec2(panX, 0.0)) * zoom;\n    \n    // Sky Color (basic gradient)\n    vec3 skyColorTop = vec3(0.94, 0.91, 0.92); // Lighter sky at the top\n    vec3 skyColorBottom = vec3(0.44, 0.62, 0.86); // Darker towards horizon\n    vec3 skyColor = mix(skyColorBottom, skyColorTop, smoothstep(-0.3, 0.5, uv.y));\n    \n    // Sea Setup\n    float seaLevel = -0.05; // Lowered sea level for better separation\n    vec3 seaColorDeep = vec3(0.02, 0.04, 0.08); // Deep sea color with more blue\n    vec3 seaColorShallow = vec3(0.1, 0.25, 0.35); // Muted shallow sea color for more natural appearance\n    \n    // Calculate Gerstner Waves\n    vec3 totalWave = vec3(0.0);\n    vec2 waveDirections[5] = vec2[](normalize(vec2(1.0, 0.3)), normalize(vec2(0.8, -0.6)), normalize(vec2(-0.6, 0.8)), normalize(vec2(0.5, 0.9)), normalize(vec2(-0.9, 0.5)));\n    float waveAmplitudes[5] = float[](0.08, 0.07, 0.08, 0.1, 0.07); // Reduced amplitudes for more subtle waves\n    float waveFrequencies[5] = float[](2.5, 3.5, 2.0, 4.0, 1.8);\n    float waveSpeeds[5] = float[](2.0, 2.5, 2.0, 2.8, 2.4);\n    float wavePhases[5] = float[](0.0, 1.0, 2.0, 0.5, 1.5);\n    \n    for (int i = 0; i < 5; i++) {\n        totalWave += gerstnerWave(uv, waveAmplitudes[i], waveFrequencies[i], waveSpeeds[i], wavePhases[i], waveDirections[i]);\n    }\n    \n    uv += totalWave.xy;\n    float depth = uv.y - (seaLevel + totalWave.z);\n    \n    // Improved Horizon Transition\n    float horizonFade = smoothstep(-0.05, 0.15, depth); // Sharper horizon transition for better distinction between sea and sky\n    \n    // Enhanced Liquid Smoothness and Shadows\n    float totalDepth = depth;\n    vec3 seaColor = mix(seaColorShallow, seaColorDeep, smoothstep(-0.8, 0.0, totalDepth)); // Increased range for deeper contrast\n    seaColor *= 0.5 + horizonFade * 0.2; // Reduced brightness for a more realistic appearance with distinct shadows\n    \n    // Caustics Effect for Realism\n    float causticIntensity = caustics(uv, iTime);\n    seaColor += vec3(0.15, 0.25, 0.3) * causticIntensity * (1.0 - smoothstep(-0.4, 0.0, totalDepth)); // Reduced brightness of caustics\n\n    // Transparency Effect for Water\n    float transparency = clamp(1.0 - smoothstep(-0.6, 0.0, totalDepth), 0.2, 0.85); // Adjusted transparency for realistic water appearance\n    seaColor = mix(seaColor, skyColor, 1.0 - transparency); // Blend with sky color to create transparency\n    \n    // Refraction Effect\n    vec2 refractOffset = totalWave.xy * 0.05; // Increased refraction for more visible water effect\n    vec3 refractedSky = texture(iChannel0, uv + refractOffset).rgb; // Sample sky texture with refraction\n    seaColor = mix(seaColor, refractedSky, 0.2); // Subtle refraction blending for realistic effect\n    \n    // Sun Reflection (Improved)\n    vec2 sunDir = normalize(vec2(1.0, -0.8));\n    float sunDot = dot(normalize(vec2(uv.x, totalWave.z)), sunDir);\n    vec3 sunColor = vec3(1.0, 0.8, 0.6);\n    seaColor += sunColor * pow(max(sunDot, 0.0), 24.0) * 0.05; // Adjusted reflection intensity for realism\n    \n    // Fresnel Effect for Realistic Water Surface\n    vec3 viewDir = normalize(vec3(uv, 1.0));\n    float fresnelEffect = fresnel(viewDir, vec3(0.0, 1.0, 0.0), 0.1, 0.6, 5.0);\n    seaColor = mix(seaColor, skyColor, fresnelEffect * 0.3); // Adjusted fresnel effect to reduce overexposure\n    \n    // Depth-based Fog for Immersion\n    float fogStrength = smoothstep(0.2, 1.0, totalDepth + 0.3); // Adding depth-based fog to create a sense of distance\n    vec3 fogColor = mix(seaColor, skyColor, fogStrength);\n    \n    // Lighting and Shadows with Phong Shading\n    vec3 normal = normalize(vec3(-totalWave.xy, 1.0));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -0.5)); // Light direction\n    vec3 lightColor = vec3(1.0, 0.9, 0.8); // Slightly warm light color\n    seaColor += phongShading(normal, lightDir, viewDir, lightColor, seaColor) * 0.3; // Balanced Phong shading effect for natural lighting\n    \n    // Add Static Sun Rotating on Its Axis\n    vec2 sunPos = vec2(0.3, 0.45); // Adjusted position of the sun for improved composition\n    float sunRadius = 0.1; // Radius of the sun\n    vec3 sunGlowColor = vec3(0.6, 0.1, 0.1); // Deep brown-red sun color like a blood moon\n    float sunRotation = mod(iTime * 0.1, 6.2831); // Rotation of the sun around its own axis\n    vec3 sunGlow = glowingSun(fragCoord.xy / iResolution.xy, sunPos + vec2(cos(sunRotation) * 0.01, sin(sunRotation) * 0.01), sunRadius, sunGlowColor); // Sun rotates around its own axis\n    skyColor += sunGlow; // Add sun to the sky\n    \n    // Perspective Projection to Add Depth\n    float perspective = 1.0 / (1.0 + uv.y * 2.0); // Simple perspective effect for increased depth\n    seaColor *= perspective;\n    \n    // Final Color: Sky or Sea\n    vec3 finalColor = mix(skyColor, fogColor, smoothstep(seaLevel, seaLevel + 0.02, uv.y)); // More distinct horizon blending for clear separation\n    \n    // Final Touch: Subtle Color Gradient to Enhance Smoothness\n    finalColor = mix(finalColor, vec3(0.1, 0.2, 0.3), 0.02); // Slightly darker, bluer tint for overall coherence\n    \n    // Output to Screen\n    fragColor = vec4(finalColor, transparency); // Apply transparency to the final output\n}","name":"Image","description":"","type":"image"}]}