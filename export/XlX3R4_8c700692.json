{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Overstepping from Eiffie's sans normal : https://www.shadertoy.com/view/Xll3zH \n// Coloring and lighting based on IQ's Apollonian : https://www.shadertoy.com/view/4ds3zn\n\n#define AUTO_OVERSTEP\n\nconst int MaxIter = 12;\nfloat zoom=1.;\n\n\n// Complex operations\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n// Biomplex multiplication\n\nvec4 bmul(vec4 a, vec4 b){vec2 dx = cmul(a.xy,b.xy)-cmul(a.zw,b.zw);vec2 dy = cmul(a.xy,b.zw)+cmul(a.zw,b.xy);return vec4(dx,dy);}\n\n// Intersection with sphere from IQ\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// Distance estimation for bicomplex fractal\n\nfloat de( vec3 p)\n{\n\tfloat dr = 1.;\t\n    p*=dr;\n\tfloat r2;\n    vec4 z = vec4(p.yzx,0.);        \n    vec4 c= z;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{            \n            r2 = dot(z,z);\n            if(r2>100.)continue;\n            dr=2.*sqrt(r2)*dr+1.0;\n\t\t\tz=z.wxyz;\n            z=bmul(z,z)+c;\n            \t\t\t\t\t\t\n\t}\n    return .5*length(z)*log(length(z))/dr;\t    \t\n}\n\n    \n// Orbit trapping for bicomplex fractal\n    \nvec4 map(in vec3 p,inout vec3 nor)\n{\n\tfloat dr = 1.0;\n\tvec4 ot = vec4(1000.0);\n        \n\tfloat r2;\n    vec4 z = vec4(p.yzx,0.);     \n    vec4 c= z;\n    vec4 pz= vec4(0.);\n    float otl=100.;\n\n\tfor( int i=0; i<MaxIter;i++ )\n\t{            \n            r2 = dot(z,z);\n            if(r2>100.)continue;\n\t\t\n            ot = min( ot, vec4(abs(z.xyz),r2) );\n        \n            pz=z;\n            dr=2.*sqrt(r2)*dr+1.0;\n\t\t\tz=z.wxyz;\n            z=bmul(z,z)+c;           \t\t\t\t\t\t\n\t}\t\n\t\n        nor= normalize((z-pz).xyz);    \n        return ot;\t\n}\n\n\n// Distance estimation for pseudo kleinian fractal    \n\t\n\nvec4 orb;\nfloat de2( vec3 p )\n{\n\tfloat scale = .4;\n\tvec3 CSize = vec3(1.0,0.8,1.1);\n    float g=.85;\n\torb = vec4(1000.0);\n    p+=vec3(2.5,0.,2.5);\n\tp*=scale;\n    \n    \n\tfor( int i=0; i<6;i++ )\n\t{\n\n\t\tp = (-1.0 + 2.0*fract(0.5*p*CSize+0.5))/CSize;\n\t\tp = clamp(p,-CSize,  CSize) * 2.0 - p;\n\n\t\tfloat r2 = dot(p,p);\t\t\t\t\n        orb = min( orb, vec4(abs(p),r2) );\t\t\n\t\tfloat k = max(1.3/r2,.1)*g;\n\n\t\tp     *= k;\n\t\tscale *= k;\n\n\t}\n\n    return 0.5*abs(p.y+.03)/scale;\t\n}\n\n\n\nbool hit1,hit2 = false;\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  delta = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n    if(hit1){\n\t\tnor.x = de(pos+delta.xyy) - de(pos-delta.xyy);\n\t\tnor.y = de(pos+delta.yxy) - de(pos-delta.yxy);\n\t\tnor.z = de(pos+delta.yyx) - de(pos-delta.yyx);\n    }else{\n    \tnor.x = de2(pos+delta.xyy) - de2(pos-delta.xyy);\n\t\tnor.y = de2(pos+delta.yxy) - de2(pos-delta.yxy);\n        nor.z = de2(pos+delta.yyx) - de2(pos-delta.yyx);\n    }\n\treturn normalize(nor);\n}\n\n\nfloat march( in vec3 ro, in vec3 rd , in vec2 tminmax )\n{\t\n\tfloat t = tminmax.x,pd=10.0,os=0.0,step;\n   \tfloat dt = 1.;\n    float dt1 = 1.;\n    float dt2 = 1.;\n       \n    float preci =  .3/min(iResolution.x,iResolution.y);//0.001;//\n\n\tfor(int i=0; i<128; i++)\n\t{\n\t\t\n        if( t>tminmax.y || dt<=preci*t ) continue;\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\t\n\t\tdt1 = de(pos);\n        dt2 = de2(pos);\n        dt= min(dt1,dt2);\n#ifdef AUTO_OVERSTEP\n\t\tif(dt>=os){\t\t//we have NOT stepped over anything\n\t\t\tos=0.44*dt*dt/pd;//overstep based on ratio of this step to last\n\t\t\tstep=dt+os;\t//add in the overstep\n\t\t\tpd=dt;\t\t//save this step length for next calc\n\t\t}else{step=-os*1.2;dt=1.0;pd=100000.0;os=0.0;}//remove overstep\n#else\n\t\tstep=dt;\n#endif\n        \n        t += step;\n                     \t\t\n\t}\n   \tif(t>tminmax.y||dt>preci*t)return-1.;\n    if(dt1<dt2)hit1=true;\n    else hit2=true;\n    \n\treturn t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n    \n    vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n\n    vec3 ro = zoom*1.7*vec3(cos(an), .6-0.5*cos(2.*an), sin(an));\n    vec3 ta = vec3(0.0,.6, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = vec3(0.0);\n    float t;\n    vec2 seg= vec2(0.,30.);;\n\n      \n    t = march( ro, rd, seg );\n    if(t>=0.&&hit1){//Bicomplex\n        //t-=.01;\n\t\tvec3 nor=vec3(0.);\n\t\tvec3 pos = ro+ t* rd;\n\t\tvec4 res = map( pos,nor );\n\t\tvec3 col1 =clamp(res.xyz,0.,1.);\n\t\tcol1=.5*(col1+col1.brg);\n\t\tcol1.g+=col1.r;\n\t\tif(pos.y>1.5)col1=vec3(.9,.9,.2);                     \n\t\tvec3 nor1 = calcNormal( pos);\n         //nor1=nor;\n\n        // lighting\n        \n\t\tfloat key = clamp( dot( light1, nor1 ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor1 ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor1.y);\n\t\tfloat ao = pow( clamp(res.a*2.0,0.2,1.0), 2.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+1.5*key+.2*bac);\n        \n        col = col1*brdf;\n            \n            \n\t\t//Light Strings\n                \n\t\tvec3 lightString1=vec3(.7,.6,0.2);\n\t\tvec3 lightString2=vec3(.4,.5,0.7);\n\t\tif(fract(iTime)<.5)lightString1=vec3(0.);\n\t\tif(fract(1.3*iTime)>.5)lightString2=vec3(0.);\n\t\tif(abs(res.x-sin(res.y))<.0005)col+=lightString1;\n\t\tif(abs(res.y-sin(res.z))<.0005)col+=lightString2;\n               \n                \n\t    \n        }\n        \n        \n        vec3 c = vec3(.8,.4,.5);\n        seg = iSphere( ro, rd, vec4(c,0.05) );\n        if(seg.x<t&&seg.y>0.||t<0.&&seg.x>0.){\n            col=   vec3(  0.8, 0., 0. );\n            vec3 pos = ro+ seg.x* rd;\n            vec3 nor = normalize(pos-c);\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            nor = reflect(rd, nor);\n            col*=(.2+key);\n            col += pow(max(dot(light1, nor), 0.0), 25.0)*vec3(.3);\n            hit2=false;\n        }\n        c = vec3(-.32,1.15,-.0);\n        seg = iSphere( ro, rd, vec4(c,0.05) );\n        if(seg.x<t&&seg.y>0.||t<0.&&seg.x>0.){\n            col=   vec3(  0.0, 0., 0.7 );\n            vec3 pos = ro+ seg.x* rd;\n            vec3 nor = normalize(pos-c);\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            nor = reflect(rd, nor);\n            col*=(.2+key);\n            col += pow(max(dot(light1, nor), 0.0), 25.0)*vec3(.3);\n            hit2=false;\n        }\n        \n\n    if( t>0.0&&hit2 )\n\t{\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n       \n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(orb.w*2.0,0.0,1.0), 1.2 );\n\n\t\tvec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n\t\t\t brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n\t\t\t brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n\t\tvec3 rgb = vec3(1.0);\n\t\trgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*orb.y,0.0,1.0) );\n\t\trgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*orb.z,0.0,1.0),8.0) );\n\t\t\n\t\tcol = rgb*brdf*exp(-0.2*t);\n\t}          \n\n        \n   \n\tcol = pow( col, vec3(0.4) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlX3R4","date":"1418934524","viewed":469,"name":"Christmas Mandeltree","username":"guil","description":"A bicomplex Mandelbrot like fractal for the tree.\nA pseudo kleinian fractal for the environment.\nUsing IQ's code for coloring and lighting and","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""}}