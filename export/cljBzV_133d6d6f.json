{"ver":"0.1","info":{"id":"cljBzV","date":"1694259890","viewed":58,"name":"Simple Box SDF Ray Marching","username":"cobyneedmedicine","description":"A simple SDF ray marcher ive made in preparation for making my own CAD software\nAdded a glow for fun, ray marching creates a really nice styled bloom effect ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","sdf","debug","demonstration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate(vec3 input_axis, float angle) {\n    // this is not an axis angle rotation function, this only works with exact unit vectors for X (1,0,0) Y (0,1,0) and Z (0,0,1)\n    // i only wrote this because i dont really like writing down 3 separate functions for rotation in each dimension; this is just a bit nicer.\n    \n    float sine = sin(angle);\n    float cosine = cos(angle);\n    vec3 axis = normalize(input_axis);\n    \n    return mat3(\n        axis.x + cosine * (axis.y + axis.z), sine * axis.z, -sine * axis.y,\n        -sine * axis.z, axis.y + cosine * (axis.x + axis.z), -sine * axis.x,\n        sine * axis.y, sine * axis.x, axis.z + cosine * (axis.x + axis.y)\n    );\n    \n}\n\n//amazing resource: https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n/*\n\nmatrices (row major)\n\nX\n1 0 0\n0 c -s\n0 s c\n\nY\nc 0 -s\n0 1 0\ns 0 c\n\nZ\nc s 0\n-s c 0 \n0 0 1\n\n\n*/\n\nvec3 points[8] = vec3[8](\n\n    vec3(-1.0, 1.0,  1.0),\n    vec3(1.0,  1.0,  1.0),\n    vec3(-1.0, -1.0, 1.0),\n    vec3(1.0,  -1.0, 1.0),\n    \n    vec3(-1.0, 1.0,  -1.0),\n    vec3(1.0,  1.0,  -1.0),\n    vec3(-1.0, -1.0, -1.0),\n    vec3(1.0,  -1.0, -1.0)\n     \n);\n\nvec3 getDebugCube(vec2 fragCoord) {\n    /*\n        This debug cube is only used so i know my rotation function works correctly. Remove line 119 to see what this does\n    */\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat3 r = rotate(vec3(0,1,0), iMouse.x / 59.0);\n    mat3 r2 = rotate(vec3(1,0,0), iMouse.y / 59.0);\n\n    vec2 uvMiddle = (uv - vec2(0.5,0.5));\n    float distanceMin = 2.0;\n    for (int i = 0; i < 8; i++) {      \n        vec3 point = (points[i] / 10.0) * r * r2;\n        float dist = length(uvMiddle - point.xy);\n        if (distanceMin > dist) {\n            distanceMin = dist;\n        } \n    }\n    \n    vec3 col = vec3(0.5,0.6,1) * clamp(0.01-distanceMin,0.0,0.01) * 100.0;\n    return col;\n}\n\nvec3 pathTrace(vec2 screenUV) {\n\n    vec3 rayDirection = normalize(vec3(screenUV.x,screenUV.y,-1.0));\n    vec3 rayOrigin = vec3(0,0,0);\n    vec3 rayPosition = rayOrigin;\n\n    vec3 boxPos = vec3(0,0,-20);\n    vec3 boxSize = vec3(1,2,5);\n    \n    mat3 r = rotate(vec3(0,1,0), iMouse.x / 59.0);\n    mat3 r2 = rotate(vec3(1,0,0), iMouse.y / 59.0);\n    \n    float closest = 900.0;\n\n    for (int raystep = 0; raystep < 100; raystep++) {\n\n        float pointcheck = sdBox((rayPosition - boxPos) * r * r2, boxSize);\n        if (pointcheck < closest) closest = pointcheck;\n        \n        if (pointcheck < 0.1) {\n            float shadow = length(rayOrigin-rayPosition) / 15.0;\n            shadow = shadow * shadow * shadow;\n            return vec3(1,1,1) / shadow;\n        }\n\n        rayPosition += rayDirection * pointcheck; \n\n    }\n    \n    vec3 col = vec3(1,1,1)/closest*0.1;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Shift coordinates to originate from center, -0.5 to 0.5 in each dimension\n    vec2 uvMiddle = (uv - vec2(0.5,0.5));\n    \n    vec3 col = getDebugCube(fragCoord);    \n    col = pathTrace(uvMiddle);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}