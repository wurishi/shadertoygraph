{"ver":"0.1","info":{"id":"l3lfR4","date":"1728163327","viewed":19,"name":"ray marching spheres+collisions","username":"jeremyfdslkjew","description":"asdf","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TOP = 1.9;\nconst float BOTTOM = -1.9;\nconst float LEFT = -3.4;\nconst float RIGHT = 3.4;\nconst float FRONT = 1.5;\nconst float BACK = 0.5;\n\n\nconst int NUM_PARTICLES = 16;\nconst int SIZE = 2;\n\nstruct object3d {\n    // stores a sphere\n    vec3 pos;\n    float size;\n    vec3 vel;\n    float mass;\n};\n\nivec2 to2d(int index){\n    // 1d index to 2d location\n    int res = int(iResolution.x);\n    return ivec2(index%res, index/res);\n}\n\nobject3d getObject(in int index) {\n    ivec2 loc1 = to2d(index*SIZE);\n    ivec2 loc2 = to2d(index*SIZE+1);\n    // extract data\n    vec4 a = texelFetch(iChannel0, loc1, 0);\n    vec4 b = texelFetch(iChannel0, loc2, 0);\n    // convert to struct\n    object3d o = object3d(a.xyz, a.w, b.xyz, b.w);\n    return o;\n}\n\nvec4 putObject(object3d o, int subindex) {\n    // takes an object and decomposes it into pixels that can be stored\n    if(subindex==0){\n        return vec4(o.pos, o.size);\n    }\n    else if(subindex==1){\n        return vec4(o.vel, 0.);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y*4.;\n    \n    // set up simulated camera\n    vec3 lense_pixel = vec3(uv,0);\n    vec3 camera = vec3(0,0,-3);\n    vec3 ray = normalize(lense_pixel - camera);\n        \n    // initial colour\n    vec3 col = vec3(0.);\n    // initial pixel location\n    vec3 current_loc = lense_pixel;\n    \n    float prev_dist = 0.;\n    \n    // move ray forward 500 times\n    for(int i=0; i < 500; i++){\n    \n        // calculate closest object\n        float floor_dist = current_loc.y-BOTTOM;\n        \n        float min_dist = floor_dist;\n        int min_idx = 0;        \n        \n        if(current_loc.z < 2. && current_loc.z > -1.){\n            for(int sphere_idx=0; sphere_idx < NUM_PARTICLES; sphere_idx++){\n                object3d o = getObject(sphere_idx);\n                // get distance to sphere\n                float tmp_dist = length(current_loc - o.pos) - o.size;\n\n                if(tmp_dist < min_dist){\n                    min_idx = sphere_idx;\n                    min_dist = tmp_dist;\n                }\n            }\n        }\n        \n        \n        float dist = min_dist;\n        \n        // if we have hit an object, reflect off it\n        if(dist < 0.0001){\n            if(dist == floor_dist){\n                //floor\n                ray = reflect(ray, vec3(0,1,0));\n                // floor absorbs red and blue\n                col.rb -= 0.5;\n                // is slightly brighter on the horizon\n                col.rgb += current_loc.z/200.;\n                // floor pattern\n                vec2 xz = current_loc.xz;\n                col.r -= sin(xz.x*(xz.y+25.)*50.)/2.;\n                // avoid getting stuck in floor\n                current_loc.y=BOTTOM+0.01;\n            } else {\n                // sphere\n                object3d o = getObject(min_idx);\n\n                ray = reflect(ray, normalize(current_loc-o.pos));\n                \n                // sphere absorbs a little light\n                col -= 0.1;\n                \n                current_loc += 0.001*ray; // get out of the sphere\n            }\n            \n        } else {\n            // we haven't hit an object, so move forward\n            current_loc += dist*ray;\n        }\n        //if(prev_dist < 0. && dist < 0.) col.r += 1.;\n        prev_dist = dist;\n    }\n    \n    // get sun brightness\n    float t = -iTime/100.;\n    col += pow((dot(1.*normalize(ray),normalize(vec3(sin(t),sin(0.5*t)+2.5,cos(t)))))*0.5 + 1.,3.)/3.; // white\n    col.r += pow((dot(1.*normalize(ray),normalize(vec3(sin(t),sin(t)+1.,cos(t)))))*0.5 + 1.,5.)/20.;\n    \n    \n    if(dot(ray,vec3(0,1,0))>-0.5){\n        // add blue to sky\n        col.b += 0.3;\n    }\n\n    // add black bar to top and bottom to reduce camera artifacts\n    if(uv.y < BOTTOM || uv.y > TOP){\n        col = vec3(0,0,0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float TOP = 1.9;\nconst float BOTTOM = -1.9;\nconst float LEFT = -3.4;\nconst float RIGHT = 3.4;\nconst float FRONT = 1.5;\nconst float BACK = 0.5;\n\n\nconst int NUM_PARTICLES = 16;\nconst int SIZE = 2;\n\nfloat uniform_rand(int seed){\n    // random number generator between 0 and 1\n    int tmp = 0x4ab2d3df^(seed+0xabfe) % 0xffff;\n    tmp *= 0x23452345*(seed+8746);\n    tmp = tmp % 0xffff;\n    return float(tmp)/float(0xffff);\n}\n\nstruct object3d {\n    // stores a sphere\n    vec3 pos;\n    float size;\n    vec3 vel;\n    float mass;\n};\n\nivec2 to2d(int index){\n    // 1d index to 2d location\n    int res = int(iResolution.x);\n    return ivec2(index%res, index/res);\n}\n\nobject3d getObject(in int index) {\n    ivec2 loc1 = to2d(index*SIZE);\n    ivec2 loc2 = to2d(index*SIZE+1);\n    // extract data\n    vec4 a = texelFetch(iChannel0, loc1, 0);\n    vec4 b = texelFetch(iChannel0, loc2, 0);\n    // convert to struct\n    object3d o = object3d(a.xyz, a.w, b.xyz, b.w);\n    return o;\n}\n\nvec4 putObject(object3d o, int subindex) {\n    // takes an object and decomposes it into pixels that can be stored\n    if(subindex==0){\n        return vec4(o.pos, o.size);\n    }\n    else if(subindex==1){\n        return vec4(o.vel, 0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // work out which sphere this thread should handle\n    ivec2 ifragCoord = ivec2(fragCoord);\n    int index = ifragCoord.x + ifragCoord.y*int(iResolution.x);\n    int subindex = index%SIZE;\n    index = index/SIZE;\n    \n    // get the single sphere we are dealing with currently\n    object3d o = getObject(index);\n\n    if(iFrame < 3){\n        // set initial locations\n        int grid = int(ceil(sqrt(float(NUM_PARTICLES))));\n        float x = 2.*float(index%grid)/float(grid) - 1.;\n        float y = 2.*float(index/grid)/float(grid) - 1.;\n        // add noise so that they don't start in a perfect grid\n        x += (uniform_rand(index))/1000000.;\n        float z = 1. + uniform_rand(100*index)/1000000.;\n        o.pos.xyz = vec3(x,y,z);\n        o.vel.xyz = vec3(0,0,0);\n        \n        // set initial size of all boalls\n        o.size = 0.2;\n    } else {\n        vec3 vel = o.vel;\n        float size = o.size;\n        vec3 pos = o.pos;\n        \n        vel *= 0.9995; // velocity damping\n        \n        vel.y += -0.001; // gravity\n    \n        // bounce off boundaries\n        if (pos.y < BOTTOM+size) {\n            vel.y = -vel.y;\n            pos.y = BOTTOM+size;\n        } else if (pos.x < LEFT) {\n            vel.x = -vel.x;\n            pos.x = LEFT;\n        } else if (pos.x > RIGHT) {\n            vel.x = -vel.x;\n            pos.x = RIGHT;\n        } else if (pos.y > TOP) {\n            vel.y = -vel.y;\n            pos.y = TOP;\n        } else if (pos.z > FRONT) {\n            vel.z = -vel.z;\n            pos.z = FRONT;\n        } else if (pos.z < BACK) {\n            vel.z = -vel.z;\n            pos.z = BACK;\n        }\n\n        // handle interactions between spheres\n        for(int i = 0; i < NUM_PARTICLES; i++){\n            if(i != index){\n                vec3 pos2 = getObject(i).pos;\n                if (length(pos2-pos) < 2.*size){\n                    vec3 normal = normalize(pos-pos2);\n                    vel = reflect(vel,normal);\n                    pos += (2.*size+0.01-length(pos-pos2))*(pos-pos2); // push overlapping particles apart\n                }\n            }\n        }\n        \n        pos += vel;\n        \n        o.pos = pos;\n        o.vel = vel;\n        o.size = size;\n    }\n    \n    fragColor = putObject(o, subindex);\n}","name":"Buffer A","description":"","type":"buffer"}]}