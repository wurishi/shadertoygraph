{"ver":"0.1","info":{"id":"3t3cR2","date":"1609445666","viewed":414,"name":"playtime - HogmanayParty2020","username":"bitnenfer","description":"It's time to come out and play.\n\nReleased at Hogmanay Party 2020.\n- Dec. 24th, 2020 -","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer","exegfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ================================================================ */\n/* playtime - 4k Executable Graphics released at Hogmanay Party 2020*/\n/*                              by                                  */ \n/*                           bitnenfer                              */\n/* ================================================================ */\n/* Ported from HLSL to ESSL */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    fragColor = vec4(clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* ================================================================ */\n/* playtime - 4k Executable Graphics released at Hogmanay Party 2020*/\n/*                              by                                  */ \n/*                           bitnenfer                              */\n/* ================================================================ */\n/* Ported from HLSL to ESSL */\n#define f1 float\n#define f2 vec2\n#define f3 vec3\n#define f4 vec4\n#define NZ normalize\n#define LN length\n#define M min\n#define Q max\n#define PHI 1.61\n#define PI 3.14\n#define RENDER_ON_30_SEC 0\n\nf3 seed = f3(0, 0, 0);\nf1 random()\n{\n    return fract(sin(fract(sin(dot(seed.xy, f2(12.98, 78.23)) * (seed.z += 1.)) * 437.54))*73.54);\n}\nf3 getSampleBiased(f3 dir, f1 power) {\n    dir = NZ(dir);\n    f3 o1 = NZ(abs(dir.x) > abs(dir.z) ? f3(-dir.y, dir.x, 0) : f3(0, -dir.z, dir.y));\n    f3 o2 = NZ(cross(dir, o1));\n    f2 r = f2(random(), random());\n    r.x = r.x * 2. * PI;\n    r.y = pow(r.y, 1. / (power + 1.));\n    f1 oneminus = sqrt(1. - r.y * r.y);\n    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nf1 hash( f1 n ) { return fract(sin(n)*753.5); }\n\nf4 noised( in f3 x )\n{\n    f3 p = floor(x);\n    f3 w = fract(x);\n    f3 u = w*w*(3.-2.*w);\n    f3 du = 6.*w*(1.-w);\n    \n    f1 n = p.x + p.y*157. + 113.*p.z;\n    \n    f1 a = hash(n);\n    f1 b = hash(n+  1.);\n    f1 c = hash(n+157.);\n    f1 d = hash(n+158.);\n    f1 e = hash(n+113.);\n    f1 f = hash(n+114.);\n    f1 g = hash(n+270.);\n    f1 h = hash(n+271.);\n    \n    f1 k0 =   a;\n    f1 k1 =   b - a;\n    f1 k2 =   c - a;\n    f1 k3 =   e - a;\n    f1 k4 =   a - b - c + d;\n    f1 k5 =   a - c - e + g;\n    f1 k6 =   a - b - e + f;\n    f1 k7 = - a + b + c - d + e - f - g + h;\n\n    return f4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (f3(k1,k2,k3) + u.yzx*f3(k4,k5,k6) + u.zxy*f3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\nf4 fbmd( in f3 x )\n{\n    const f1 scale  = 1.5;\n\n    f1 a = 0.,\n    b = .5,\n    f = 1.;\n    f3  d = f3(0,0,0);\n    for( int i=0; i<3+min(0,iFrame); i++ )\n    {\n        f4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values      \n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= .5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n    return f4( a, d );\n}\n\nvoid rot(inout f2 p, f1 r)\n{\n    f1 c = cos(r), s = sin(r);\n    p = mat2(c, -s, s, c) * p;\n}\n\nstruct HD\n{\n    f1 D;\n    f3 C;\n    f1 S;\n    f1 X;\n    f1 T;\n    f1 I;\n    f1 G;\n    bool E;\n};\n\nf1 sdBox( f3 p, f3 b )\n{\n  f3 q = abs(p) - b;\n  return LN(Q(q,0.)) + M(Q(q.x,Q(q.y,q.z)),0.);\n}\n\nf1 sdCapsule( f3 p, f3 a, f3 b, f1 r )\n{\n  f3 pa = p - a, ba = b - a;\n  return LN( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0., 1. ) ) - r;\n}\n    \nHD opUnion(HD a, HD b)\n{\n    if (a.D < b.D) return a;\n    return b;\n}\n\nf1 smin( f1 a, f1 b, f1 k )\n{\n    f1 h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\nf1 sdRoundedCylinder( f3 p, f1 ra, f1 rb, f1 h )\n{\n  f2 d = f2( LN(p.xz)-2.*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.) + LN(max(d,0.)) - rb;\n}\n\nf1 palm(f3 p)\n{\n\tp.x += 1.1;\n\tp.y += .5;\n    p.x += p.x * .3;\n    rot(p.yz, .1);\n    f1 topPalm = sdRoundedCylinder(p + f3(0., .7, -3.9), 4., 1.5, .1);\n    return topPalm;\n}\n\nf1 finger3(f3 p, f1 len, f1 r)\n{\n    f1 d = 100.;\n    f1 rotation = -.01;\n    f1 sc = .6;\n    for (int i = 0; i < 3+min(0,iFrame); ++i)\n    {\n        rot(p.yz, rotation);\n        len *= 1.4;\n        p.z += len*1.4;\n        f1 dd = sdCapsule(p, f3(0, 0, 0), f3(0, 0, len+2.5), sc);\n        d = smin(d, dd, 1.2);\n        rotation += r;\n        sc *= .7;\n    }\n    return d;\n}\n\nf1 fingers(f3 p, f4 r4, f1 thr)\n{\n    f3 pd1 = p;\n    f3 pd2 = p - f3(2.5, 0, -.5);\n    f3 pd3 = p + f3(2.5, .3, .5);\n    f3 pd4 = p - f3(3.5, -1.8, 5.5);\n    f3 pd5 = p + f3(4.5, .8, -1.6);\n    \n    rot(pd2.xz, .1);\n    rot(pd3.xz, -.1);\n    rot(pd4.xy, -1.7);\n    rot(pd4.yz, 2.);\n    rot(pd5.xz, -.3);\n    \n    r4 = -abs(r4);\n    thr = -abs(thr);\n    f1 right = finger3(pd2, 3.1, r4.x);    \n    f1 middle = finger3(pd1, 3.2, r4.y);\n    f1 left = finger3(pd3, 2.5, r4.z);\n    f1 pinky = finger3(pd5, 2.1, r4.w);\n    f1 thumb = finger3(pd4, 2.1, thr)-.2;\n    \n    return min(min(min(min(right, middle), left), thumb), pinky);\n}\n\nf1 handSdf(f3 p, f1 thickAdded, f4 r1, f1 r2)\n{\n\tp.z-=9.;\n    f1 pl = (palm(p) - thickAdded) * .7;\n    f1 fing = fingers(p + f3(0, .4, 0), r1, r2);\n    \n    pl = smin(pl, fing, 1.);\n    \n    return pl;\n}\n\nHD cabinet(f3 p)\n{\n\tf4 ns = abs(fbmd(p));\n\tf1 baseSdf = sdBox(p, f3(45, 45, 25));\n\tbaseSdf = max(baseSdf, -sdBox(p + f3(0, -30, 5), f3(36, 8, 24)));\n\tbaseSdf = max(baseSdf, -sdBox(p + f3(0, 13, 5), f3(36, 28, 24)));\n\n\tf1 topSdf = sdBox(p + f3(0., -42., 0.), f3(45., 2., 25.)) - 2.;\n\ttopSdf = max(topSdf, -sdBox(p, f3(50, 42, 50)));\n\n\tf1 cajonSdf = abs(sdBox(p + f3(0, -30, 15), f3(35, 8, 24)))-1.;\n\tcajonSdf = max(cajonSdf, -sdBox(p + f3(0, -40, 5), f3(45, 5, 34)));\n\n\tf1 doorsSdf = sdBox(p + f3(18, 13, 25), f3(18, 28, 1));\n\tf3 p2 = p + f3(-21, 13, 33);\n\trot(p2.xz, .5);\n\tdoorsSdf = min(doorsSdf, sdBox(p2, f3(18, 28, 1)));\n\n\tf1 knobSdf = LN(p + f3(0., -30., 42.)) - 3.;\n\tknobSdf = min(knobSdf, LN(p + f3(-13., -8., 42.)) - 3.);\n\tknobSdf = min(knobSdf, LN(p + f3(8., -8., 29.)) - 3.);\n\n\tknobSdf = (knobSdf) * .5;\n\n\tf3 col = f3(1, .95, .9)*.5;\n\tHD base = HD(baseSdf, f3(1, 1, 1)*1.2, 0., 0., 0., 0., 0., false);\n\tHD top = HD( topSdf, col, .8, 1., 0., 0., 0., false );\n\tHD cajon = HD( cajonSdf, f3(.9, .98, 1.), .2, 1000000., 0., 0., 0., false );\n\tHD doors = HD( doorsSdf-.7, col, .5, 1., 0., 0., 0., false );\n\tHD knob1 = HD( abs(knobSdf), f3(.85,.5,.5), .8, 10000000., .8, 1.3, 1., false );\n\tHD knob2 = HD( abs(knobSdf+.6), f3(.6,0,0), 0., 0., .2, 1.1, 2., false );\n\n\tHD scene = opUnion(base, top);\n\tscene = opUnion(scene, cajon);\n\tscene = opUnion(scene, doors);\n\tscene = opUnion(scene, knob1);\n\tscene = opUnion(scene, knob2);\n\n\treturn scene;\n}\n\nHD hand(f3 p, f4 ns, f4 r1, f1 r2)\n{\n\tf1 sdHand = handSdf((p)+f3(0, 0, 20), .01, r1, r2)+ns.y*.05;\n\tHD handa = HD( abs(sdHand-.3)-.01, f3(1.1, 1, 1), 1., 1000000.*ns.y, .6, 1.41, 2., false );\n\tHD handb = HD( abs(sdHand+.1)-.01, f3(.5, .1, .1)*.1, 0., 0., 1., 1.36, 5.*LN(ns), false );\n\tHD handc = HD( sdHand+.15, f3(1, 1, 1), 0., 0., 0., 0., 0., false );\n\tHD scene = handa; \n\tscene = opUnion(scene, handb);\n\tscene = opUnion(scene, handc);\n\treturn scene;\n}\n\nHD map(f3 p)\n{\n\tHD scene = HD( sdBox(p, f3(50, 60, 60)), f3(0,0,0), 0., 0., 0., 0., 0., false );\n\tif (scene.D < .001)\n\t{\n\t\tscene.D = 999.;\n\t\tf4 ns = abs(fbmd(p*10.));\n\t\tf3 pHand1 = (p + f3(20, -37, 25)) * .7;\n\t\tf3 pHand2 = (p + f3(-14, -25, 25)) * .7;\n\t\tf3 pHand3 = (p + f3(-12, 5, 15)) * .7;\n\t\tpHand2.x *= -1.;\n\n\t\trot(pHand1.xy, .15);\n\t\trot(pHand1.yz, .5);\n\t\trot(pHand2.xz, .3);\n\t\trot(pHand2.xy, 3.6);\n\t\trot(pHand2.yz, -1.1);\n\t\trot(pHand3.xz, -.5);\n\t\trot(pHand3.xy, -1.4);\n\n\t\tscene = opUnion(scene, cabinet(p));\n\t\tif (sdBox(pHand1, f3(20, 20, 40)) < .001)\n\t\t\tscene = opUnion(scene, hand(pHand1, ns, f4(1.1, 1.05, .9, .8), .1));\n\t\tif (sdBox(pHand2, f3(10, 10, 30)) < .001)\n\t\t\tscene = opUnion(scene, hand(pHand2, ns, f4(.9, .8, .9, .8), .8));\n\t\tif (sdBox(pHand3, f3(30, 20, 50)) < .001)\n\t\t\tscene = opUnion(scene, hand(pHand3, ns, f4(.5, .6, .7, .8), .6));\n\n\n\t\tf3 eyeOffset = f3(-2.6, 32, 25);\n\n\t\tf1 size = .2;\n\t\tf1 eyesSdf = LN(p + eyeOffset) - size;\n\t\teyesSdf = min(eyesSdf, LN(p + eyeOffset + f3(-1, -10.5, 0)) - size);\n\t\tHD eyes = HD( eyesSdf, f3(.4, 0, 0), 0., 0., 0., 0., 0., true );\n\n\t\tscene = opUnion(scene, eyes);\n\t}\n\n\tHD light1 = HD( LN(p + f3(-110, -380, 100)) - 250., f3(1, 1, 1)*2., 0., 0., 0., 0., 0., true );\n\tHD light2 = HD( LN(p + f3(250, -100, 0)) - 105., f3(.5, .3, .3), 0., 0., 0., 0., 0., true );\n\tscene = opUnion(scene, light1);\n\tscene = opUnion(scene, light2);\n\n\treturn scene;\n}\n\nf3 pathtrace(f2 uv)\n{\n    f3 ro = f3(0, 5, -280);\n    f3 rd = NZ(f3(uv.x, uv.y, 4));\n    f3 direct = f3(0, 0, 0), luminance = f3(1, 1, 1);\n    f2 e = f2(0, .001);\n    \n    for (int b = 0; b < 7+min(0,iFrame); ++b)\n    {    \n        HD data;\n        bool hit = false;\n        f1 t = 0.;\n        for (int i = 0; i < 200+min(0,iFrame); ++i)\n        {\n            HD d = map(ro + rd * t);\n            if (d.D < .001)\n            {\n                data = d;\n                data.D = t;\n                hit = true;\n                break;\n            }\n            t += d.D;\n            if (t > 400.) break;\n        }\n        if (hit)\n        {\n            f3 p = ro + rd * data.D;\n            // iq's trick for reducing compilation time :D\n            #if 0\n            f3 n = NZ(f3(\n                map(p + e.yxx).D - map(p - e.yxx).D, \n                map(p + e.xyx).D - map(p - e.xyx).D, \n                map(p + e.xxy).D - map(p - e.xxy).D \n            ));\n            #else\n            f4 n1 = vec4(0.0);\n            for( int i=min(0,iFrame); i<4; i++ )\n            {\n                f4 s = f4(p, 0.0);\n                f1 kk; f2 kk2;\n                s[i] += 0.001;\n                n1[i] = map(s.xyz).D;\n                if( n1.x+n1.y+n1.z+n1.w>100.0 ) break;\n            }\n            f3 n = normalize(n1.xyz-n1.w);\n            #endif\n            f1 rng = random();\n            f1 offset = .2;\n            if ( random() < data.T)\n            {\n                rd = getSampleBiased(NZ(refract(rd, n, 1./Q(data.I, 1.))), data.G);\n                offset = .08;\n            }\n            else if ( random() < data.S)\n            {\n                rd = getSampleBiased(NZ(reflect(rd, n)), data.X);\n            }\n            else\n            {\n                rd = getSampleBiased(n, 1.);\n            }\n            rd = NZ(rd);\n            ro = p + rd * offset;\n            luminance *= data.C;\n            \n            if (data.E)\n            {\n                direct += luminance;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n    return direct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    f2 uv = fragCoord.xy/iResolution.xy;\n    f4 prevFrame = texture(iChannel0, uv);\n    #if RENDER_ON_30_SEC\n    if (iTime < 30.0)\n    {\n    #endif\n        f3 color = f3(0, 0, 0);\n        seed = f3(uv,iTime);\n        f2 jitter = 2. / iResolution.xy * (f2(random(), random()) * 2. - 1.);\n        color = pathtrace((uv * 2. - 1.) * f2(iResolution.x / iResolution.y, 1.) + jitter);\n        #if RENDER_ON_30_SEC\n        f1 blend = (prevFrame.a == 0. || iTime < .1) ? 1. : 1. / (1. + (1. / prevFrame.a));\n        #else\n        f1 blend = (prevFrame.a == 0. || iTime < .1 || iMouse.z > 0.) ? 1. : 1. / (1. + (1. / prevFrame.a));\n        #endif\n        color = mix(prevFrame.rgb, color, blend);\n        fragColor = f4(color, blend);\n    #if RENDER_ON_30_SEC\n    }\n    else\n    {\n        fragColor = prevFrame;\n    }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}