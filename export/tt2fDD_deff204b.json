{"ver":"0.1","info":{"id":"tt2fDD","date":"1599007938","viewed":698,"name":"Light Intensity 3D","username":"stevejtrettel","description":"The light intensity function for various 3-D homogeneous spaces.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//BUILT FROM THE VOLUMETRIC RAYMARCHER BY FLYGUY //https://www.shadertoy.com/view/XtsGRf\n\n#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_STEPS 48\n#define MAX_VOLUME_STEPS 500\n#define VOLUME_STEP_SIZE 0.01\n\n\n\n\n\n\n\n\n//The following functions define the light intensity in three different homogeneous geometries.\n//use the one you would like to visualize in the main Intensity function, directly below their definitions\n//right now, they automatically cycle through.\n\n\nfloat intensityS2E(vec3 pos){\n    \n    \n    float L2=pos.x*pos.x+pos.y*pos.y;\n    float r2=L2+pos.z*pos.z;\n    float L=sqrt(L2);\n   \n    float intensity =abs(L/(r2*sin(L)));\n    \n    return intensity;\n}\n\nfloat intensityNil(vec3 pos){\n    \n    \n   \n    //Stuff Needed to compute the intensity\n    float z=pos.z;\n    float L2=pos.x*pos.x+pos.y*pos.y;\n    float r2=L2+z*z;\n    float z4=z*z*z*z;\n    \n    //the denominator of the intensity function factors into two commponents contributing to the brightness\n    float intensityLine=2.*r2*sin(z/2.);\n    float intensityCurve=(L2*z*cos(z/2.)-2.*r2*sin(z/2.));\n   \n    float intensity=abs(z4/(intensityLine*intensityCurve));\n    \n    return intensity;\n}\n\n\nfloat intensitySL2(vec3 pos){\n    \n    float z=pos.z;\n    float L2=pos.x*pos.x+pos.y*pos.y;\n    \n   //first; the components of the cylindrical coordinate polynomials\n    float L,L4, L6,z2,z4,z6;\n    L=sqrt(L2);\n    L4=L2*L2;\n    L6=L2*L4;\n    z2=z*z;\n    z4=z2*z2;\n    z6=z2*z4;\n    \n    //the hyperbola you lie on\n    float k=sqrt(abs(L2-z2));\n    \n    //the polynomials coefficients of the area density\n    float f1=(L2+z2)/pow(abs(L2-z2),6.);\n    float f2=17.*L6+7.*L4*z2+16.*L2*z4+32.*z6;\n    float f3=48.*L2*z2*(L2+z2);\n    float f4=3.*L4*(5.*L2+3.*z2);\n    float f5=L6-2.*L2*z2-z4-L4*(1.+z2);\n    float f6=(L6+2.*L2*z2+z4-L4*(z2-1.));\n    float f7=2.*L2*(L2+z2)*k;\n    \n    \n    //Trigonometric Components\n    float c1=cos(k);\n    float c2=cos(2.*k);\n    float s1=sin(k);\n    float s2=sin(k/2.);\n    s2*=s2;//now sin(k/2)^2;\n    \n    float C1=cosh(k);\n    float C2=cosh(2.*k);\n    float S1=sinh(k);\n    \n    float S2=sinh(k/2.);\n    S2*=S2;//now it's sinh(k/2)^2\n    \n    //the signs that change depending on formula type:\n    float sgn=1.;\n    float Sgn=-1.;\n    \n    //the area density function, depending on if you are in or out of the lightcone\n    float areaDensity;\n    \n    \n  if(abs(z)>abs(L)){\n            areaDensity=sqrt(abs(f1*s2*(f2 - f3*c1 + f4*c2)*(f5 + f6*c1 + sgn* f7*s1)))/2.;\n        }\n        else if(abs(z)<abs(L)){\n            areaDensity=sqrt(abs(f1*S2*(f2 - f3*C1 + f4*C2)*(f5 + f6*C1 + Sgn*f7*S1)))/2.;\n        }   \n   \n   \n    float intensity=1./areaDensity;\n    \n    return intensity;\n}\n\n\n\n\nfloat intensity(vec3 pos,float time){\n   // float t=floor(time/6.28);\n   // t=mod(t,3.);\n    \n    //switch(int(t)){\n    //case 0:return 1.5*intensityS2E(pos);\n        \n   // case 1:return 1.5*intensityNil(pos);\n        \n   // case 2:return 1.5*intensitySL2(pos);\n   // }\n    return 10.5*intensitySL2(pos);\n   // return 1.5*intensityNil(pos);\n   // return 1.5*intensityS2E(pos);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec4 Volume(vec3 pos,float opacity)\n{\n    //rotate starting position\n    RotateY(pos,iTime/3.);\n    RotateZ(pos,-0.5);\n    \n    pos=15.*pos;//fixed zoom level\n    //pos=(15.-5.*cos(iTime/4.))*pos;//zoom in and out\n    \n    //calculate the light intensity;\n\n    float vol =2.*intensity(pos,iTime/5.);\n    \n    //mix two colors together: first is for lower intensity second is high intensity\n    vec3 col = mix(vec3(0.85,0.45,0.2),vec3(1.,1.,0.6),step(3.,vol));\n    \n    vol = smoothstep(0.6,0.9,abs(vol));\n    \n\treturn vec4(col, max(0.0,vol)*0.01*opacity);  \n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    //Ray march to find the region surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    \n    float radius=3.;\n    float opacity=1.;//fixed size of bounding sphere\n    //float radius=1.5*(1.-cos(iTime/5.));//make the bounding sphere get larger with time\n    //float opacity=3.5/(0.5+radius);\n   \n    \n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        \n        dist = min(dist, 8.0-length(pos));\n        dist=min(dist,length(pos)-radius);\n       // dist = min(dist, max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0);//cube\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){\n           \torig=pos;//reset the origin to your new point\n           \tt=0.;//reset the marching counter\n            break;}//you made it to the region! Start volume march\n    }\n    \n    \n    //Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        //Stop if the sample leaves the volume.\n        //if(max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-radius > 0.0) {break;}//cube\n        if(length(pos)>radius) {break;}//sphere\n\n        \n        //if you are rendering a shell: add up zero intensity when you are inside the shell\n       // if(length(pos)>radius-0.2)//uncomment to make the below only apply in the shell\n        {\n            vec4 vol = Volume(pos,opacity);\n        \tvol.rgb *= vol.w;\n            //distance foog\n            vol.rgb=exp(-t/3.)*vol.rgb;//weight by the distance fog travelled to get here.\n            col += vol;}\n    }\n  \n    \n    return col.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-4.);\n      \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n  \n    vec3 color = MarchVolume(orig,dir);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}