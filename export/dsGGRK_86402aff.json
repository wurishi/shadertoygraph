{"ver":"0.1","info":{"id":"dsGGRK","date":"1678788163","viewed":70,"name":"Maths world","username":"jtremesay","description":"WIP scene to raytracing shader\nhttps://github.com/jtremesay/mathsworld/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nuniform vec2 uResolution;\n\nconst float INFINITY = 1e9;\n\nstruct Material {\n    vec3 color;\n    float specular;\n};\n\nstruct Hit {\n    vec3 position;\n    vec3 normal;\n    float distance;\n    Material material;\n};\n\nconst Hit NO_HIT = Hit(\n    vec3(INFINITY, INFINITY, INFINITY),\n    vec3(0.0, 0.0, 0.0),\n    INFINITY,\n    Material(\n        vec3(1.0, 1.0, 1.0),\n        0.0\n    )\n);\n\nHit sdf_union(Hit a, Hit b) {\n    if (a.distance <= b.distance) {\n        return a;\n    } else {\n        return b;\n    };\n}\n\nHit sdf_sphere(vec3 camera, vec3 ray, vec3 position, float radius, Material material) {\n    vec3 co = camera - position;\n    float a = dot(ray, ray);\n    float b = dot(co, ray) * 2.0;\n    float c = dot(co, co) - radius * radius;\n    float delta = b * b - 4.0 * a * c;\n    if (delta < 0.0) {\n        return NO_HIT;\n    }\n\n    float d1 = (-b + sqrt(delta)) / (a + a);\n    float d2 = (-b - sqrt(delta)) / (a + a);\n    float d = min(d1, d2);\n    if (d < 0.0) {\n        return NO_HIT;\n    }\n\n    vec3 hit_position = camera + ray * d;\n    vec3 normal = normalize(hit_position - position);    \n    \n    return Hit(\n        hit_position,\n        normal,\n        d,\n        material\n    );\n}\n\nHit scene(vec3 camera, vec3 direction) {\n    return sdf_union(\n        sdf_union(\n            sdf_sphere(\n                camera,\n                direction,\n                vec3(0.0, -5001.0, 0.0),\n                5000.0,\n                Material(\n                    vec3(1.0, 1.0, 0.0),\n                    1000.0\n                )\n            ),\n            sdf_sphere(\n                camera,\n                direction,\n                vec3(0.0, -1.0, 3.0),\n                1.0,\n                Material(\n                    vec3(1.0, 0.0, 1.0),\n                    500.0\n                )\n            )\n        ),\n        sdf_union(\n            sdf_sphere(\n                camera,\n                direction,\n                vec3(2.0, 0.0, 4.0),\n                1.0,\n                Material(\n                    vec3(0.0, 0.0, 1.0),\n                    500.0\n                )\n            ),\n            sdf_sphere(\n                camera,\n                direction,\n                vec3(-2.0, 0.0, 4.0),\n                1.0,\n                Material(\n                    vec3(1.0, 1.0, 1.0),\n                    10.0\n                )\n            )\n        )\n    );\n}\n\nfloat directional_light(float intensity, vec3 direction, vec3 position, vec3 normal, float specular, vec3 inverse_direction) {\n    if (scene(position, direction).distance < INFINITY) {\n        return 0.0;\n    }\n\n    // Diffuse\n    float n_dot_l = dot(normal, direction);\n    float i = 0.0;\n    if (n_dot_l > 0.0) {\n        i += intensity * n_dot_l / (length(normal) * length(direction));\n    }\n\n    // Specular\n    if (specular > -1.0) {\n        vec3 r = normal * n_dot_l * 2.0 - direction;\n        float r_dot_v = dot(r, inverse_direction);\n        if (r_dot_v > 0.0) {\n            i += intensity * pow((r_dot_v / (length(r) * length(inverse_direction))), specular);\n        }\n    }\n\n    return i;\n}\n\nfloat compute_lights(vec3 position, vec3 normal, float specular, vec3 inverse_direction) {\n    float intensity = 0.0;\n\n    // AMBIANT LIGHTS BEGIN\n    intensity += 0.2;\n    // AMBIANT LIGHTS END\n\n    // OMNIDIRECTIONAL LIGHTS BEGIN\n    intensity += directional_light(\n        0.6, \n        vec3(2.0, 1.0, 0.0) - position, \n        position,\n        normal, \n        specular, \n        inverse_direction\n    );\n    // OMNIDIRECTIONAL LIGHTS END\n\n    // DIRECTIONAL LIGHTS BEGIN\n    intensity += directional_light(\n        0.2, \n        vec3(1.0, 4.0, 4.0), \n        position,\n        normal, \n        specular, \n        inverse_direction);\n    // DIRECTIONAL LIGHTS END\n\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Relative position on the screen\n    // (0, 0) = bottom left\n    // (1, 1) = top right\n    // (1, 0) = bottom right\n    vec2 uv = fragCoord.xy / vec2(iResolution.y, iResolution.y);\n\n    // View port\n    vec3 view_port = vec3(1.0, 1.0, 1.0);\n\n    // Camera\n    vec3 camera = vec3(0.0, 0.0, 0.0);\n\n    // The direction of the ray for the current pixel\n    vec3 direction = vec3(\n        uv.x - 0.5,\n        uv.y - 0.5,\n        1.0\n    ) * view_port;\n\n    Hit hit = scene(camera, direction);\n    if (hit.distance < INFINITY) {\n        fragColor = vec4(\n            hit.material.color * compute_lights(\n                hit.position, \n                hit.normal, \n                hit.material.specular, \n                -direction\n            ), \n            1.0\n        );\n    } else {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}