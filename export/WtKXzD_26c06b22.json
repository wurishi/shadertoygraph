{"ver":"0.1","info":{"id":"WtKXzD","date":"1583103778","viewed":143,"name":"Infinite expanding grid","username":"julianlumia","description":"please ignore the messy code... its really inefficient but i really like the result of this quick doodle)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n vec3 d = abs(p) - b;\n return length(max(d,0.0)); \n}\n\n\nfloat dBar(vec2 p, float width) {\n vec2 d = abs(p) - width;\n return min(max(d.x, d.y), 0.0) + length(max(d, 0.)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n float bar_x = dBar(p.yz, x);\n float bar_y = dBar(p.zx, x);\n float bar_z = dBar(p.xy, x);\n return min(bar_z, min(bar_x, bar_y));\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat dMengerSponge(vec3 p,vec3 size) \n{\n float d = sdBox(p, vec3(size));\n float itt =1.;\n float one_third = .094 / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.5)\n\nfloat GetDist(vec3 p) {\t\n float gap = 1.;\n p.xyz = mod(p.xyz + gap,2.0 * gap) - gap;\n float d;\n d=float(1.0);  \n p = rotate( ( vec3(sin(p.z*2.+iTime*.5) , 0.,0. ) ), 2.)*p;\n vec3 q = p;\n float dp = dot(p,(p*1.))*.2;\n p /= dp;\n p = abs(p*5.);   \n p=fract(p-vec3(T*tau*.1,T*tau*.1,T*tau*.1))*.1;\n float dm1= (dMengerSponge(p,vec3(1.)))+(dMengerSponge(q,vec3(.85)));\n d *=1.;\n d = min( d,dm1); \n d = (((d*dp)/1.));\n g1 +=1./(.001+pow(abs(dm1),1.));\n return d;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) \n{\n float    dO = 0.;        \n for (int i=0; i<100; i++) \n  {\n   vec3 p = ro + dO * rd;\n   float dS = GetDist (p);\n   if (dS<0.001 || abs(dO)>100.) break;  \n   dO += dS*1.;\n  }\n return dO;\n}\n \nvec3 GetNormal(vec3 p)\n{\n float d = GetDist(p);\n vec2 e = vec2(0.001,0.);\n vec3 n = d - vec3(\n  GetDist(p-e.xyy),\n  GetDist(p-e.yxy),\n  GetDist(p-e.yyx));\n return normalize(n);\n}\n\n\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(1);\n    \n    if(fract(dot(floor(p), vec3(.1))) > .1) col = vec3((sin(iTime*2.5)*0.5+0.5),0.2,0.);\n    if(fract(dot(floor(p), vec3(.5))) < .5) col = vec3((cos(iTime*1.5)*0.5+0.5),0.,0);\n    \n    return col;\n    \n}\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);\n vec3 cameraPos = vec3(1.,1.,1);\n vec3 lightPos1 = vec3(-cameraPos-vec3(1,1.,0.0));\n vec3 l1 = normalize(lightPos1-p);\n vec3 n1 = GetNormal(p);    \n float dif1 = clamp(dot(n1, l1), 0., 1.);\n float d1 = RayMarch(p+n1*0.001*1., l1);\n if(d1<length(lightPos1-p)) dif1 *= .6;    \n return (dif1)/=.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 col = vec3(0);\n float s = mod(iTime * 0.25, 1.0);\n float t = 1. * (2.0 * s - s * s);  \n vec3 cameraPos = vec3(1.,1.,1);\n vec3 ro = vec3(-cameraPos);\n vec3 rd = normalize(vec3(uv.x, uv.y, 2.5));\n float the = iTime *1.;\n the = 3.85;\n rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float d = RayMarch(ro, rd);\n float t2;\n t2=d;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  vec3 objCol = getObjectColor(p);\n\n  col+=objCol;\n }  \n col*=g1*vec3(.00001);  \n\n         col/=g1*vec3(.0001);  \nfloat fog = 3. / (1. + d * d * 10.);\n col *= vec3(fog);  \n vec3 sky = vec3(0., 1., 1.);\n col = mix(sky, col, 1.15/(d*d/1./1.*.5+1.)); \n fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}