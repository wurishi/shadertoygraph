{"ver":"0.1","info":{"id":"7tKXzD","date":"1640300936","viewed":187,"name":"Fork Neutral sR - oklch sweep","username":"fu5ha","description":"Ad hoc. No toe, only shoulder. Intended for use with HDR grading.\nBlends between luminance-only compression (in the lows) and per-channel compression (in the highs).\nAttempts to preserve hues, while allowing some shifts as luminance increases (for VFX).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tonemap"],"hasliked":0,"parentid":"slGSRh","parentname":"Neutral sRGB tonemap; old, bad"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nvec3 rgb_to_ycbcr(vec3 col) {\n    mat3 m = mat3(0.2126, 0.7152, 0.0722, -0.1146,-0.3854, 0.5, 0.5,-0.4542,-0.0458);\n    return col * m;\n}\n\nfloat rgb_to_luminance(vec3 col) {\n    return dot(vec3(0.2126, 0.7152, 0.0722), col);\n}\n\nfloat tonemap_curve(float v) {\n    #if 1\n        // Large linear part in the lows, but compresses highs.\n        float c = v + v*v + 0.5*v*v*v;\n        return c / (1.0 + c);\n    #else\n        return 1.0 - exp(-v);\n    #endif\n}\n\nvec3 tonemap_curve(vec3 v) {\n    return vec3(tonemap_curve(v.r), tonemap_curve(v.g), tonemap_curve(v.b));\n}\n\nvec3 neutral_tonemap(vec3 col) {\n    vec3 ycbcr = rgb_to_ycbcr(col);\n\n    float bt = tonemap_curve(length(ycbcr.yz) * 2.4);\n    float desat = max((bt - 0.7) * 0.8, 0.0);\n    desat *= desat;\n\n    vec3 desat_col = mix(col.rgb, ycbcr.xxx, desat);\n\n    float tm_lum = tonemap_curve(ycbcr.x);\n    vec3 tm0 = col.rgb * max(0.0, tm_lum / max(1e-5, rgb_to_luminance(col.rgb)));\n    vec3 tm1 = tonemap_curve(desat_col);\n    col = mix(tm0, tm1, bt * bt);\n\n    return col * 0.97;\n}\n\n// stolen\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\nvec3 oklch_to_oklab(vec3 c) {\n    float a = c.y * cos(c.z);\n    float b = c.y * sin(c.z);\n    return vec3(c.x, a, b);\n}\nvec3 oklab_to_linear_srgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = oklab_to_linear_srgb(oklch_to_oklab(vec3(0.5, 0.09, uv.x * 2.0 * PI + 0.5)));\n    //col /= max(1e-5, rgb_to_ycbcr(col).x);\n    col *= max(0.0, exp2(uv.y *9.0) - 1.0);\n    \n    if (iMouse.z <= 0.0) {\n        #if 1\n            col = neutral_tonemap(col);\n        #else\n            col = 1.0 - exp(-col);\n        #endif\n    }\n\n    fragColor = vec4(Srgb3(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}