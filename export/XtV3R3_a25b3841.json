{"ver":"0.1","info":{"id":"XtV3R3","date":"1475868245","viewed":132,"name":"Raymarching + diffuse","username":"xyten","description":"Hello raymarching!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n    vec4 position;\n    float radius;\n    vec3 color;\n};\n   \n    \nstruct DirectionalLight\n{\n\tvec4 direction;\n    float intensity;\n    vec3 color;\n};\n\n    \nfloat traceS(Sphere sphere, vec4 currT){\n    return length(sphere.position - currT) - sphere.radius;\n}\n\n\nfloat kPrecision = 0.002;\nconst int maxStep = 50;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float oneOverResX = 1.0 / iResolution.x;\n   float oneOverResY = 1.0 / iResolution.y;\n   vec2 displayUV = vec2((fragCoord.x + 0.5) * oneOverResX, (fragCoord.y + 0.5) * oneOverResY);\n   float imageAspectRatio = iResolution.x * oneOverResY;\n   float fov = 75.0;\n   \n   //create ray\n   vec4 rayOrig = vec4(0.0, 0.0, 0.0, 1.0);\n   \n   float rayDirX = (displayUV.x*2.0-1.0) * imageAspectRatio * tan(radians(fov * 0.5));\n   float rayDirY = (displayUV.y*2.0-1.0) * tan(radians(fov * 0.5));\n   \n   vec4 rayDir = vec4(rayDirX, rayDirY, -1.0, 0.0);   \n   \n   vec3 backgroundColor = vec3(0.5);\n   vec3 actualColor = backgroundColor;\n   \n   //Mouse control\n   float mouseX = iResolution.x * 0.5;\n   float mouseY = iResolution.y * 0.5;\n    if(iMouse.x != 0.0){\n      mouseX = iMouse.x;\n    }\n    if(iMouse.y != 0.0){\n      mouseY = iMouse.y;\n    }\n    \n   //sphere\n   Sphere sphere;\n   sphere.position = vec4(((mouseX * oneOverResX) * 2.0-1.0)*5.0, ((mouseY * oneOverResY) * 2.0-1.0)*3.0, -4.0, 1.0);\n   sphere.color = vec3(1.0, 0.55, 0.55);\n   sphere.radius = 1.0;\n    \n    //light\n   DirectionalLight light;\n   light.direction = vec4(0.2, -0.4,-0.7, 0.0);\n   light.intensity = 1.0;\n   light.color = vec3(1.0, 1.0, 1.0);\n\n   //raymarch\n   //distance field check\n   vec4 currTPos = rayOrig;\n   bool hit = false;\n   for(int currStep = 0; currStep < maxStep; ++currStep){\n      float dist = traceS(sphere, currTPos);\n      if(dist <= kPrecision){ hit = true; break; }\n      currTPos = currTPos + normalize(rayDir) * dist;\n   }\n\n  //hit handle\n  if(hit == true){\n    actualColor = sphere.color * max(dot(-light.direction, normalize(currTPos - sphere.position)),0.0); \n  }\n  else {\n    actualColor = backgroundColor;\n  }\n        \n   //display\n    fragColor = vec4(actualColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}