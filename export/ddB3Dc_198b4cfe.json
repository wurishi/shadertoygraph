{"ver":"0.1","info":{"id":"ddB3Dc","date":"1668277610","viewed":574,"name":"Distrct 13 Final","username":"LuncyTB","description":"A sci-fi style scene.","likes":45,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","scene","weather"],"hasliked":0,"parentid":"DsSGDG","parentname":"Distrct 13"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    col = pow(col * 0.72, vec3(0.86));\n    \n    col /= 1.0 + 0.7 * pow(length(uv * 2.0 - 1.0) * 0.8, 2.3);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI atan(0.0, -1.0)\n\nstruct Material\n{\n    vec4 albedo;\n    float roughness;\n    vec4 emission;\n};\n\nfloat packDepth(float dist, vec2 uv, float ID)\n{\n    return dist;\n}\n\nvec4 packSurface(float dist, vec2 uv, float ID)\n{\n    return vec4(uv, dist, ID);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float p = pow(clamp(abs(a - b) * k, 0.0, 1.0) - 1.0, 2.0) * 0.25 / k;\n    return min(a, b) - p;\n}\n\nvec4 smin(vec4 a, vec4 b, float k)\n{\n    float p = pow(clamp(abs(a.z - b.z), 0.0, 1.0) - 1.0, 2.0);\n    vec4 res = mix(b, a, p * 0.5 * sign(a.z - b.z) - (sign(a.z - b.z) * 0.5 - 0.5));\n    res.z = smin(a.z, b.z, k);\n    return res;\n}\n\nfloat nmin(float a, float b)\n{\n    return min(a, b);\n}\n\nvec4 nmin(vec4 a, vec4 b)\n{\n    return a.z < b.z ? a : b;\n}\n\nfloat SDFSphere(vec3 pos)\n{\n    return length(pos) - 1.0;\n}\n\nfloat SDFCube(vec3 pos, vec4 hsize)\n{\n    pos = abs(pos) - hsize.xyz;\n    return (length(max(vec3(0.0), pos)) + min(0.0, max(max(pos.x, pos.y), pos.z))) - hsize.w;\n}\n\nfloat SDFGround(vec3 pos)\n{\n    return abs(pos.z);\n}\n\nvec3 transform(vec3 pos, vec3 offset, vec3 rotation, float scale)\n{\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n    mat3 r = mat3(cy, 0.0, -sy, 0.0, 1.0, 0.0, sy, 0.0, cy) *\n        mat3(1.0, 0.0, 0.0, 0.0, cx, sx, 0.0, -sx, cx) *\n        mat3(cz, sz, 0.0, -sz, cz, 0.0, 0.0, 0.0, 1.0);\n    \n    return r * (pos + offset) / scale;\n}\n\nvec3 camera(vec3 dir, vec3 rotation)\n{\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n    mat3 r = mat3(cy, 0.0, -sy, 0.0, 1.0, 0.0, sy, 0.0, cy) *\n        mat3(1.0, 0.0, 0.0, 0.0, cx, sx, 0.0, -sx, cx) *\n        mat3(cz, sz, 0.0, -sz, cz, 0.0, 0.0, 0.0, 1.0);\n    \n    return dir * r;\n}\n\nvec3 UV2Normal(vec2 uv)\n{\n    float cy = cos(uv.y * PI - PI * 0.5);\n    return vec3(cos(uv.x * PI * 2.0 + PI) * cy, sin(uv.x * PI * 2.0 + PI) * cy, sin(uv.y * PI - PI * 0.5));\n}\n\nvec2 normal2UV(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) / PI / 2.0 + 0.5, atan(normal.z, length(normal.xy)) / PI + 0.5);\n}\n\nfloat hash2(vec2 d)\n{\n    return fract(731.38123 * sin(dot(d, vec2(16.231, 14.793))));\n}\n\n#define SKYCOL mix(vec3(0.3, 0.28, 0.25) * 1.8, vec3(0.5, 0.7, 0.9) * 1.8, cos(iTime * 0.1) * 0.5 + 0.5)\n#define CLOUD0 normalize(vec3(0.3, 0.7, 2.0))\n#define CLOUD1 normalize(vec3(-0.3, 0.2, 2.2))\n\n#define C0COL vec3(0.9, 0.96, 0.94)\n#define C1COL vec3(0.93, 0.98, 0.95)\n\n#define SUN normalize(vec3(0.2, 0.10, -0.2))\n#define SUNCOL mix(vec3(1.0, 0.96, 0.8) * 7.0, vec3(1.0, 0.96, 0.8) * 3.0, cos(iTime * 0.1) * 0.5 + 0.5)\n#define SUNSIZE (1.0 / mix(0.1, 3.2, cos(iTime * 0.1) * 0.5 + 0.5))\n\n#define E 0.0025\n#define SE 0.055\n#define FAR 200.0\n#define MAXT 256.0\n#define SMAXT 128.0\n#define AOMAXT 8.0\n\n#define FOG mix(vec3(0.3, 0.29, 0.275), vec3(0.5, 0.7, 0.9) * 1.3, cos(iTime * 0.1) * 0.5 + 0.5)\n#define FOGSCALE 0.15\n#define FOGEX 1.3\n\n#define BLOCK 2\n// >= 1, smaller to higher quality\n\n#define BLOCKF float(BLOCK)\n\n#define REAL_REFLECT\n// #define MARCH_TEST\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T0 min(iTime, 0.0)\n\nvec3 blurSky(vec3 normal)\n{\n    return SKYCOL - \n        0.031 * max(0.0, dot(normal, CLOUD0)) -\n        0.03 * max(0.0, dot(normal, CLOUD0)) -\n        max(0.0, -normal.z) * 0.1;\n}\n\nvec4 ObjTestTransform(vec3 pos)\n{\n    return vec4(transform(pos, vec3(1.9, 1.8, 0.0), vec3(0.0, 0.0, -1.83), 0.4), 0.4);\n}\n\nfloat ObjTest(vec3 pos)\n{\n    float d = SDFCube(pos + vec3(0.0, 0.0, -0.6), vec4(0.4, 1.5, 1.85, 0.0));\n    if (d < 0.06)\n    {\n        vec3 subPos = vec3(pos.x, pos.y, mod(pos.z, 0.1) - 0.05);\n        d = nmin(d, SDFCube(subPos, vec4(0.415, 1.515, 0.00, 0.01)));\n    }\n    \n    if (d < 2.0)\n    {\n        d = nmin(d, SDFCube(pos - vec3(0.0, 0.5, 2.55), vec4(0.355, 0.515, 0.1, 0.00)));\n        d = nmin(d, SDFCube(pos - vec3(0.0, 0.85, 2.75), vec4(0.015, 0.015, 0.4, 0.00)));\n        d = nmin(d, SDFCube(pos - vec3(0.1, 0.75, 2.75), vec4(0.015, 0.015, 0.76, 0.00)));\n    }\n    \n    float d0 = SDFCube(pos - vec3(-1.0, 0.8, 1.0), vec4(0.06, 0.06, 0.07, 0.00));\n    if (d0 < 2.8)\n    {\n        d0 = nmin(d0, SDFCube(pos - vec3(-1.0, 0.8, 1.3), vec4(0.035, 0.215, 0.03, 0.00)));\n        d0 = nmin(d0, SDFCube(pos - vec3(-1.2, 0.8, 1.3), vec4(0.195, 0.065, 0.01, 0.00)));\n        d0 = nmin(d0, SDFCube(pos - vec3(-1.0, 0.8, 1.0), vec4(0.02, 0.02, 0.3, 0.00)));\n    }\n    \n    d = nmin(d, d0);\n    \n    return d;\n}\n\nfloat ObjTestP0(vec3 pos)\n{\n    float d = SDFCube(pos - vec3(-0.3, 0.8, -0.1), vec4(0.75, 0.01, 1.5, 0.12));\n    \n    if (d < 0.2)\n    {\n        float d0 = SDFCube(pos - vec3(-0.3, 0.8, 0.86), vec4(0.76, 0.02, 0.02, 0.13));\n        d0 = -nmin(-d0, SDFCube(pos - vec3(-0.3, 0.8, 0.33), vec4(2.0, 0.8, 0.5, 0.0)));\n        d = nmin(d, d0);\n    }\n    \n    d = -nmin(-d, SDFCube(pos - vec3(-0.3, 0.8, 1.4), vec4(2.0, 0.8, 0.5, 0.0)));\n    \n    d = smin(d, SDFSphere(pos * 1.2 - vec3(-0.3, 0.8, -0.4) ) / 1.2, 5.1);\n    d = smin(d, SDFSphere(pos * 1.2 - vec3(-0.3, 0.8, -1.1) ) / 1.2, 5.1);\n    \n    \n    if (d < 0.2)\n    {\n        d = -nmin(-d, SDFCube(pos - vec3(-0.95, 0.9, -0.24), vec4(0.07, 0.26, 1.0, 0.0)));\n        d = -nmin(-d, SDFCube(pos - vec3(-0.7, 0.9, -0.24), vec4(0.07, 0.26, 1.0, 0.0)));\n    }\n    \n    return d;\n}\n\nfloat ObjTestP1(vec3 pos)\n{\n    float d = SDFSphere((pos - vec3(-4.3, 0.8, 0.95)) * 3.4) / 3.4;\n    d = -nmin(-d, SDFCube((pos - vec3(-4.3, 0.8, 0.95)), vec4(1.0, 1.0, 0.03, 0.0)));\n    \n    return d;\n}\n\nfloat ObjTestP2(vec3 pos)\n{\n    float dk = SDFSphere((pos - vec3(-4.3, 0.0, 0.95)) * 3.4) / 3.4;\n    \n    float d = FAR;\n    \n    if (dk < 2.0)\n    {\n        d = nmin(d, SDFCube(pos - vec3(-4.3, 0.8, 1.45), vec4(0.005, 0.005, 0.23, 0.0)));\n        d = nmin(d, SDFCube(pos - vec3(-4.3, 0.8, 1.24), vec4(0.02, 0.02, 0.13, 0.0)));\n        d = nmin(d, SDFCube(pos - vec3(-4.43, 0.85, 0.55), vec4(0.007, 0.007, 0.23, 0.0)));\n        d = nmin(d, SDFCube(pos - vec3(-4.19, 0.70, 0.55), vec4(0.007, 0.007, 0.23, 0.0)));\n        d = nmin(d, SDFCube(pos - vec3(-4.25, 0.87, 0.55), vec4(0.007, 0.007, 0.23, 0.0)));\n    }\n    \n    return d;\n}\n\nfloat ObjTestP3(vec3 pos)\n{\n    \n    float d = FAR;\n    \n    d = nmin(d, SDFCube(pos - vec3(-4.3, 0.8, 0.64), vec4(0.01, 0.01, 0.01, 0.0)));\n    \n    return d;\n}\n\nvec2 ObjTestUV(vec3 pos)\n{\n    return pos.xy;\n}\n\nvec4 ObjGroundT(vec3 pos)\n{\n    return vec4(transform(pos, vec3(-4.7, -0.55, 0.7), vec3(0.0), 1.0), 1.0);\n}\n\nfloat SDFRock(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat ObjGround(vec3 pos)\n{\n    float k;\n    float m;\n    float h = 0.5;\n    float r = 0.7;\n    float d = FAR;\n    \n    k = hash2(floor(pos.xy / 2.0));\n    m = 0.3 + k * 0.7;\n    d = nmin(d, SDFRock(vec3(mod(pos.xy, 2.0), pos.z - k * h), r * m));\n    \n    k = hash2(floor(pos.xy / 2.0 + vec2(1.0, 0.0)));\n    m = 0.3 + k * 0.7;\n    d = nmin(d, SDFRock(vec3(mod(pos.xy, 2.0) - vec2(2.0, 0.0), pos.z - k * h), r * m));\n    \n    k = hash2(floor(pos.xy / 2.0 + vec2(0.0, 1.0)));\n    m = 0.3 + k * 0.7;\n    d = nmin(d, SDFRock(vec3(mod(pos.xy, 2.0) - vec2(0.0, 2.0), pos.z - k * h), r * m));\n    \n    k = hash2(floor(pos.xy / 2.0 + vec2(1.0, 1.0)));\n    m = 0.3 + k * 0.7;\n    d = nmin(d, SDFRock(vec3(mod(pos.xy, 2.0) - vec2(2.0, 2.0), pos.z - k * h), r * m));\n    \n    return d;\n}\n\nfloat ObjGround2(vec3 pos)\n{\n    return SDFGround(pos + vec3(0.0, 0.0, 0.5));\n}\n\nfloat ObjHills(vec3 pos, float bias)\n{\n    float d = FAR;\n    d = nmin(d, ObjGround2(pos));\n    \n    if (d > 4.0 + bias)\n    {\n        return d;\n    }\n    \n    d = smin(d, ObjGround(pos), 0.67);\n    \n    if (d < 2.1 + bias)\n    {\n        float d0 = FAR;\n        d0 = nmin(d0, ObjGround((pos + vec3(62.3433, 18.1213, -0.5)) * 6.0) / 6.0);\n        d0 = nmin(d0, ObjGround((pos + vec3(35.4123, 84.9931, -1.0)) * 6.0) / 6.0);\n        d0 = nmin(d0, ObjGround((pos + vec3(12.7542, 55.5973, -1.5)) * 6.0) / 6.0);\n\n        d0 = -smin(-d0, -d + 0.05, 7.3);\n\n        d = smin(d, d0, 2.4);\n        \n        if (d < 1.6 + bias)\n        {\n            float d1 = FAR;\n            d1 = nmin(d1, ObjGround((pos + vec3(47.3351, 11.7521, -0.5)) * 6.0) / 6.0);\n            d1 = nmin(d1, ObjGround((pos + vec3(89.5073, 67.6396, -0.75)) * 6.0) / 6.0);\n            d1 = nmin(d1, ObjGround((pos + vec3(38.5951, 31.2831, -1.0)) * 6.0) / 6.0);\n            d1 = nmin(d1, ObjGround((pos + vec3(41.2641, 38.7748, -1.25)) * 6.0) / 6.0);\n            d1 = nmin(d1, ObjGround((pos + vec3(26.7448, 76.4833, -1.5)) * 6.0) / 6.0);\n\n            d1 = -smin(-d1, -d + 0.06, 12.5);\n\n            d = smin(d, d1, 3.6);\n        }\n    }\n    \n    if (d < 0.1 + bias)\n    {\n        d = d - textureLod(iChannel1, pos.xy * 1.4 + 0.1, 0.0).r * 0.028;\n        d = d - textureLod(iChannel1, pos.xy * 3.0, 0.0).r * 0.0115;\n        d = d - textureLod(iChannel1, pos.xy * 4.0, 0.0).r * 0.0063;\n        d = d - textureLod(iChannel1, pos.xy * 8.0, 0.0).r * 0.0035;\n    }\n    \n    return d;\n}\n\nvec2 ObjGroundUV(vec3 pos)\n{\n    return pos.xy;\n}\n\nvec4 ObjWaterT(vec3 pos)\n{\n    return vec4(transform(pos, vec3(0.0, 0.0, 0.35), vec3(0.0), 1.0), 1.0);\n}\n\nfloat ObjWater(vec3 pos, float bias)\n{\n    float h = 0.001; \n    float b = SDFGround(pos);\n    if (b < h * 1.5 + bias)\n    {\n        float offset = 0.0;\n        offset -= textureLod(iChannel2, pos.xy * 0.1 + vec2(iTime * 0.003, iTime * 0.01), 0.0).r * h;\n        offset -= textureLod(iChannel2, pos.xy * 0.2 - vec2(iTime * 0.0043, iTime * 0.016), 0.0).r * h;\n        return b + offset;\n    }\n    return b;\n}\n\nvec2 ObjWaterUV(vec3 pos)\n{\n    return pos.xy;\n}\n\n#define SCENE(type, name, init, pack) \\\ntype name(vec3 pos, float bias) \\\n{ \\\n    type d = init; \\\n    \\\n    vec4 pos0 = ObjTestTransform(pos); \\\n    d = nmin(d, pack(ObjTest(pos0.xyz) * pos0.w, ObjTestUV(pos0.xyz), 1.0)); \\\n    d = nmin(d, pack(ObjTestP0(pos0.xyz) * pos0.w, ObjTestUV(pos0.xyz), 4.0)); \\\n    d = nmin(d, pack(ObjTestP1(pos0.xyz) * pos0.w, ObjTestUV(pos0.xyz), 6.0)); \\\n    d = nmin(d, pack(ObjTestP2(pos0.xyz) * pos0.w, ObjTestUV(pos0.xyz), 7.0)); \\\n    d = nmin(d, pack(ObjTestP3(pos0.xyz) * pos0.w, ObjTestUV(pos0.xyz), 5.0)); \\\n    \\\n    vec4 pos1 = ObjGroundT(pos); \\\n    d = nmin(d, pack(ObjHills(pos1.xyz, bias) * pos1.w, ObjGroundUV(pos1.xyz), 2.0)); \\\n    \\\n    vec4 pos2 = ObjWaterT(pos); \\\n    d = nmin(d, pack(ObjWater(pos2.xyz, bias) * pos2.w, ObjWaterUV(pos2.xyz), 3.0)); \\\n    \\\n    return d * min(iTime + 1.0, 1.0); \\\n}\n\n/*\n\n\n*/\n\n// ------------------------------------------------------\n\nSCENE(float, getDist, FAR, packDepth)\nSCENE(vec4, getSurface, vec4(vec2(0.0), FAR, 0.0), packSurface)\n\nvec2 march(vec3 org, vec3 dir, float simplify)\n{\n    float d = 0.0;\n    vec3 p = org;\n    float t = T0;\n    for (; t < MAXT * simplify; t += 1.0)\n    {\n        float nd = getDist(p, E * d);\n        d += nd;\n        p += nd * dir;\n        if (abs(nd) <= E * d)\n        {\n        \n#ifdef MARCH_TEST\n            return vec2(t / MAXT * simplify, 0.0);\n#endif\n            return vec2(d, E * d);\n        }\n        if (d >= FAR)\n        {\n            break;\n        }\n    }\n\n#ifdef MARCH_TEST\n    return vec2(t / MAXT * simplify, 0.0);\n#endif\n    \n    return vec2(FAR, FAR * E);\n}\n\nvec3 getNormal(vec3 pos, float bias)\n{\n    vec2 offset = vec2(1.0, -1.0);\n    float d = getDist(pos, bias);\n    return normalize(\n        offset.xyy * getDist(pos + offset.xyy * E, bias) + \n        offset.yyx * getDist(pos + offset.yyx * E, bias) + \n        offset.yxy * getDist(pos + offset.yxy * E, bias) +\n        offset.xxx * getDist(pos + offset.xxx * E, bias)\n    );\n}\n\nfloat shadow(vec3 org, \n             vec3 dir, \n             float start, \n             float width, \n             float simplify, \n             float seed)\n{\n    float d = start + start * seed;\n    vec3 p = org + dir * start * seed;\n    float mind = FAR;\n    float pd = 0.0001;\n    for (float t = T0; t < SMAXT * simplify; t += 1.0)\n    {\n        float nd = getDist(p, SE * d);\n        float gd = sqrt(pd * pd - nd * nd / 4.0) * nd / pd;\n        float k = nd * nd / 2.0 / pd;\n        mind = min((gd + nd * 0.4) / max(0.0, d - k + d * 0.4) * width, mind);\n        if (abs(nd) <= SE * d)\n        {\n            return clamp(0.0, 0.0, 1.0);\n        }\n        if (d >= FAR)\n        {\n            break;\n        }\n        d += nd;\n        p += nd * dir;\n        pd = nd;\n    }\n    return clamp(mind - SE * width, 0.0, 1.0);\n}\n\nfloat ambientOcclusion(vec3 org, \n                       vec3 dir, \n                       float dis, \n                       float start, \n                       float seed)\n{\n    float d = start + start * seed * 2.0;\n    vec3 p = org + start * seed * dir * 2.0;\n    float ao = 0.0;\n    float base = 0.0;\n    for (float t = T0; t < AOMAXT; t += 1.0)\n    {\n        float nd = getDist(p, SE * d);\n        ao += max(0.0, nd) / max(0.001, d);\n        base += 1.0;\n        if (d >= dis)\n        {\n            break;\n        }\n        d += nd;\n        p += nd * dir;\n    }\n    return clamp(ao / base, 0.0, 1.0);\n}\n\nvec3 rfnNormal(vec3 normal, float rfn, vec3 pos, float seed)\n{\n    vec3 U = normalize(abs(normal.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0));\n    vec3 V = cross(U, normal);\n    float a = seed * PI * 2.0;\n    float r = fract(a * 647.831371);\n    return normalize(normal / (0.0001 + pow(rfn, 1.7)) * 0.31 + U * cos(a) * r + V * sin(a) * r);\n}\n\nvec3 calEnv(vec3 normal, float rfn, vec3 pos, float seed)\n{\n    vec3 rnormal = rfnNormal(normal, rfn * 0.4, pos, seed);\n    vec3 clear = textureLod(iChannel0, normal2UV(rnormal), 0.0).xyz;\n    vec3 blur = blurSky(normal);\n    return mix(clear, blur, rfn * 0.75);\n}\n\n\nMaterial ms[] = Material[](\n    Material(vec4(0.0), 0.0, vec4(0.0)),\n    Material(vec4(0.4, 0.42, 0.47, 0.8), 0.0, vec4(0.0)),\n    Material(vec4(0.4, 0.41, 0.36, 0.05), 0.98, vec4(0.0)),\n    Material(vec4(0.6, 0.63, 0.57, 0.88), 0.0, vec4(0.0)),\n    Material(vec4(0.74, 0.74, 0.73, 0.05), 0.0, vec4(0.0)),\n    Material(vec4(0.34, 0.34, 0.33, 0.05), 0.0, vec4(0.9, 0.4, 0.1, 1.2)),\n    Material(vec4(0.78, 0.71, 0.43, 0.95), 0.02, vec4(0.0)),\n    Material(vec4(0.84, 0.84, 0.84, 0.95), 0.01, vec4(0.0))\n);\n\nvec3 light(vec3 normal, \n           vec3 vdir, \n           float id, \n           vec2 uv, \n           float sd, \n           float ao, \n           vec3 wpos, \n           float seed)\n{\n    \n    int bid = int(id);\n    float fac = fract(id);\n    vec4 albedo = mix(ms[bid].albedo, ms[bid + 1].albedo, fac);\n    float rfn = mix(ms[bid].roughness, ms[bid + 1].roughness, fac);\n    vec4 emission = mix(ms[bid].emission, ms[bid + 1].emission, fac);\n    \n    float nl = max(0.0, dot(normal, -SUN));\n    vec3 rfdir = reflect(vdir, normal);\n    float rfnl = max(0.0, dot(rfdir, -SUN));\n    float sp = max(0.0, dot(rfdir, -SUN));\n    float fnl = pow(1.0 - max(0.0, dot(vdir, -normal)), 5.0) * 0.5;\n    fnl = fnl + 0.07;\n    fnl = mix(fnl, 0.95, albedo.w);\n    \n    vec3 rfCol = calEnv(rfdir, rfn, wpos, seed);\n    \n    rfdir = rfnNormal(rfdir, rfn, wpos, seed);\n\n#ifdef REAL_REFLECT\n    vec2 p = march(wpos, rfdir, 0.5);\n    vec3 rhpos = wpos + rfdir * p.x;\n    \n    if (p.x < FAR)\n    {\n        vec4 data = getSurface(rhpos, p.y);\n        vec3 rfnormal = getNormal(rhpos, p.y);\n        \n        float rfsd = shadow(rhpos - SUN * E, -SUN, E, 1.0 / SUNSIZE, 0.25, seed);\n        \n        int rfbid = int(data.w);\n        float rffac = fract(data.w);\n        vec4 rfalbedo = mix(ms[rfbid].albedo, ms[rfbid + 1].albedo, rffac);\n        float rfrfn = mix(ms[rfbid].roughness, ms[rfbid + 1].roughness, rffac);\n        vec4 rfemission = mix(ms[rfbid].emission, ms[rfbid + 1].emission, rffac);\n        vec3 rfabd = mix(vec3(1.0) , rfalbedo.xyz * 2.0, rfalbedo.w);\n        \n        rfCol = rfalbedo.xyz * (calEnv(rfnormal, 1.0, wpos, seed) + rfabd * SUNCOL * rfsd * max(0.0, dot(rfnormal, -SUN)));\n        rfCol = mix(rfCol, FOG, clamp(pow(p.x * FOGSCALE, FOGEX), 0.0, 1.0));\n        rfCol += ms[rfbid].emission.xyz * ms[rfbid].emission.w;\n    }\n#endif\n    \n    vec3 f = vec3(0.0);\n    f += albedo.xyz * nl * sd * SUNCOL * (1.0 - albedo.w);\n    \n    f += albedo.xyz * calEnv(normal, 1.0, wpos, seed) * ao * (1.0 - fnl);\n    \n    vec3 rfalbedo = mix(vec3(1.0), albedo.xyz, albedo.w);\n    \n    f += ao * fnl * rfCol * rfalbedo;\n    \n    f += rfalbedo * fnl * sd * pow(rfnl, 64.0 / SUNSIZE * (1.024 - rfn)) * 33.0 * (1.111 - rfn) / SUNSIZE;\n    \n    f += ms[bid].emission.xyz * ms[bid].emission.w;\n    \n    return f;\n}\n\n// -------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x > (iResolution.x + BLOCKF - 1.0) / BLOCKF || \n        fragCoord.y > (iResolution.y + BLOCKF - 1.0) / BLOCKF)\n    {\n        return;\n    }\n    \n    vec2 fragPos = fragCoord * BLOCKF;\n    fragPos += vec2((iFrame % (BLOCK * BLOCK)) / BLOCK, iFrame % BLOCK);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 vdir = normalize(vec3((fragPos * 2.0 - iResolution.xy) / iResolution.x, 1.0).xzy);\n    \n    float mousex = iMouse.z > 0.0 ? iMouse.x : 0.0;\n    vdir = camera(vdir, vec3(0.0, 0.0, -750.0 * 0.01 + mousex * 0.01));\n    \n    vec3 pos = vec3(0.0, -3.0, 0.0);\n    \n    vec2 p = march(pos, vdir, 1.0);\n    \n#ifdef MARCH_TEST\n    fragColor = mix(vec4(0.5, 0.8, 0.9, 1.0), vec4(1.0, 0.6, 0.1, 1.0), p.x);\n    return;\n#endif\n    \n    vec3 spos = p.x * vdir + pos;\n    \n    vec3 normal = getNormal(spos, p.y);\n    \n    vec2 seed = normal2UV(normal + fract(spos * 882.134) / 0.3381);\n    float s = hash2(seed);\n    \n    vec4 data = getSurface(spos, p.y);\n    \n    float sd = shadow(spos - E * SUN * 8.0, -SUN, E * 8.0, 1.0 / SUNSIZE, 1.0, s);\n    sd = sd * 0.5 + shadow(spos - E * SUN * 8.0, -SUN, E * 8.0, 1.0 / SUNSIZE, 0.3, s);\n    \n    float ao = ambientOcclusion(spos + normal * E * 2.0, normal, 1.0, E * 2.0, s);\n    \n    vec3 face = light(normal, vdir, data.w, data.xy, sd, ao, spos, s);\n    \n    vec3 sky = calEnv(vdir, 0.0, spos, 0.0);\n    \n    face = mix(face, FOG, clamp(pow(p.x * FOGSCALE, FOGEX), 0.0, 1.0));\n\n    // Output to screen\n    fragColor = p.x < FAR ? vec4(face, 1.0) : vec4(sky, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 normal = UV2Normal(uv);\n    \n    vec2 cloudUV = normal.xy / normal.z * 0.1;\n    \n    vec3 cloud0 = texture(iChannel0, cloudUV).r * C0COL * SKYCOL;\n    vec3 cloud1 = texture(iChannel0, cloudUV * 0.7).r * C1COL * SKYCOL;\n    \n    vec3 sky = SKYCOL * mix(texture(iChannel0, cloudUV * 0.5).r, 1.0, 0.8);\n    \n    sky = mix(sky, cloud0, 0.7 * pow(max(0.0, dot(normal, CLOUD0)), 1.0));\n    sky = mix(sky, cloud1, 0.6 * pow(max(0.0, dot(normal, CLOUD1)), 1.5));\n    \n    sky = mix(sky, SUNCOL, 0.1 * pow(max(0.0, dot(normal, -SUN)), 36.0 / SUNSIZE));\n    \n    if (normal.z > 0.0)\n    {\n        fragColor = vec4(sky, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(SKYCOL * 0.8, 1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    ivec2 update;\n    \n    update = ivec2((iFrame % (BLOCK * BLOCK)) / BLOCK, iFrame % BLOCK);\n    \n    if (p % BLOCK == update)\n    {\n        fragColor = texelFetch(iChannel1, p / BLOCK, 0);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel0, p, 0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}