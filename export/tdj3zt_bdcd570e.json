{"ver":"0.1","info":{"id":"tdj3zt","date":"1549773901","viewed":196,"name":"Friendly Robots","username":"cbrpnk","description":"Everyday","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat caps(vec3 p, float r, float l)\n{\n    return length(p - vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat map(vec3 p)\n{\n    p.xz = mod(p.xz+vec2(1.5), 3.5)-vec2(1.5);\n    //p.xz *= rotate(iTime);\n    //p.yz *= rotate(iTime);\n    \n    vec3 symp = p;\n    symp.x = abs(symp.x);\n    \n    // Head\n    float mask = caps(p-vec3(0., -.06, 0.), .25, .1);\n    float negMask = caps(p-vec3(0., -.2, -.26), .3, .1);\n    float eyeHole = sphere(symp-vec3(.13, -.01, .21), .023);\n    float mouthHole = sphere(p-vec3(0., -.26, .26), .045);\n    float axle = caps(p.yxz, .12, .2);\n    axle = max(axle, symp.x-.21);\n    float head = max(max(max(mask, -negMask), -eyeHole), -mouthHole);\n    // Flatten sides\n    head = max(head, symp.x-.2);\n    head = min(head, axle);\n    //vec3 fp = symp;\n    \n    \n    // Body\n    vec3 bp = symp;\n    bp.y += 1.;\n    bp.xy *= rotate(-.25);\n    float body = caps(bp, .3, .3);\n    float bottomNeg = caps(symp.xzy-vec3(0.5, 0., -1.2), .4, .3);\n    float backNeg = caps(p-vec3(0., -1., -.1), .3, .3);\n    float armNeg = caps(symp.yxz-vec3(-.7, 0., -.1), .2, .3);\n    float neckHole = sphere(p-vec3(0., -.25, 0.), .4);\n    body = max(max(max(max(body, -bottomNeg), -backNeg), -armNeg), -neckHole);\n    \n    // Pelvis\n    float pelvis = caps(p.yxz-vec3(-1.45, .0, .0), .13, .3);\n    pelvis = max(pelvis, abs(p).x-.25);\n    \n    // Core\n    vec3 cp = p*20.;\n    float verteb = floor(cp.y);\n    cp.y = mod(cp.y, 1.);\n    cp.z -= sin((verteb)*.2)*2.;\n    float core = max(sphere(cp, 1.)/20., abs(p-vec3(0., -.7, 0.)).y-.7);\n    \n    // Legs\n    vec3 lp = symp;\n    lp -= vec3(.2, -1.2, -.15);\n    lp.yz *= rotate(-.7);\n    float legs = caps(lp, .07, .3);\n    lp = symp;\n    lp -= vec3(.2, -.3, -.15);\n    lp.yz *= rotate(-.3);\n    float lower = caps(lp-vec3(.0, -1.3, -.4), .07, .7);\n    legs = min(legs, lower);\n    \n    // Arms\n    vec3 ap = symp;\n    ap.xy *= rotate(.2);\n    float arms = caps(ap.yxz-vec3(-.5, 0., 0.), .02, .2);\n    float shoulder = sphere(symp-vec3(.3, -.55, .0), .1);\n    float upper = caps(symp-vec3(.35, -.75, 0.), .05, .2);\n    vec3 lowap = ap-vec3(0.15, -1.3, 0.15);\n    lowap.yz *= rotate(-.5);\n    float lowera = caps(lowap, .06, .3);\n    arms = min(min(min(arms, shoulder), upper), lowera);\n    \n\t// Floor\n    float flo = p.y + 2.5;\n    \n    return min(min(min(min(min(min(head, body), pelvis), core), legs), arms), flo);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<328; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .0001) break;\n        if(t > 100.) return -1.;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 eps = vec3(.001, 0., 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 eye = vec3(0.5, -1., 2.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    eye.x += iTime*.5;\n    dir.yz *= rotate(-.3);\n    dir.xz *= rotate(.6);\n    \n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    \n    vec3 col;\n    if(d < 0.) {\n        col = vec3(1., .2, .2)/pow((uv.y+.4), 1.1);\n    } else {\n        vec3 normal = getNormal(p);\n        col = vec3(.95, .95, 1.) * (1.-pow(max(0., dot(normal, -dir)), 2.));\n        col *= vec3(.3, .27, .27) * max(0., dot(normal, vec3(0., 1., 0.)));\n        col += vec3(1., .5, .5) * pow(max(0., dot(normal, -dir)), 200.);\n        col += vec3(.8, .8, 1.) * pow(max(0., dot(normal, vec3(0., 1., .5))), 30.);\n        col += vec3(.1, 0., 0.) * d/10.;\n        col += vec3(1.) * d/50.;\n    }\n\t\n    col *= 1.-length(uv)*.8;\n    col = pow(col, vec3(.6));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}