{"ver":"0.1","info":{"id":"XdXcDf","date":"1490275929","viewed":382,"name":"ArtDovWater","username":"ArtDov","description":"WaterArtDov","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["artdov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141593;\nconst float KPT180 = 0.017453;\nconst float WATER_AMP = 0.35;\nconst float WATER_FRECQ = 4.97;\nconst float WAVE_LENGHT = 5.1;\nconst float WAVE_SPEED = 7.8;\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n#define WATER_TIME (iTime*WAVE_SPEED/6.0)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(16.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\nfloat frequency(float l) {\n\tfloat w = 2.0*PI/l;\n    return w;\n}\nfloat phase(float w, float speed){\n\tfloat phase = speed*w;\n    return phase;\n}\nfloat waveHeight(float amplitude, vec2 directional, vec2 uv, float w, float time, float phasa){\n    float waveH = float(amplitude* dot(directional, uv) * w +phasa * time);\n\treturn waveH;\n}\nfloat wave_shape(vec2 uv){\n\tvec2 waveShape = 1.0-abs(cos(uv));\n    vec2 smoothWaveShape = abs(sin(uv));\n    waveShape = -(mix(waveShape, smoothWaveShape, waveShape)) + 1.0;\n    return pow(1.0-pow(waveShape.x * waveShape.y,0.6),0.67);\n}\nvec3 rotXAxis(vec3 Directional, float teta){\n    teta = KPT180*teta;\n    Directional.yz *= mat2(cos(teta), sin(teta), -sin(teta), cos(teta));\n    return Directional;\n}\nvec3 rotYAxis(vec3 Directional, float teta){\n    teta = KPT180*teta;\n    Directional.xz *= mat2(cos(teta), -sin(teta), sin(teta), cos(teta));\n    return Directional;\n}\nvec3 rotZAxis(vec3 Directional, float teta){\n    teta = KPT180*teta;\n    Directional.xy *= mat2(cos(teta), -sin(teta), sin(teta), cos(teta));\n    return Directional;\n}\nfloat map(vec3 position){\n    float amplitude = WATER_AMP;\n    float l = WAVE_LENGHT;\n    float s = WAVE_SPEED;\n\tfloat waveH = 0.0; \n    float dif = 0.0;\n    float w = frequency(l);\n    float p = phase(w,s);\n    vec2 directional = vec2(1.1,1.1);\n    vec2 uv = position.xz;\n        for(int i = 0; i<4; i++){\n            dif =  wave_shape(w *(uv+WATER_TIME));\n            dif += wave_shape(w *(uv-WATER_TIME));\n            waveH += dif * amplitude;\n            w*=1.2; amplitude*=0.6;\n        }\n    return  (position.y - waveH) ;\n}\n\nfloat Trace(vec3 origin, vec3 directional, out vec3 position){\n    float t = 0.0;\n    for (int i = 0; i <32; i++){\n        vec3 position = origin + directional * t;\n       \tfloat dif = map(position);\n        t += dif * 0.9;\n    }\n    return t;\n}\n\nfloat mapCircle(vec3 p){\n   return length(p) - 1.0;\n}\nfloat TraceSun(vec3 origin, vec3 directional, out vec3 position){\n    float t = 0.0;\n    for (int i = 0; i <16; i++){\n        vec3 position = origin + directional * t + vec3(0.0,-7.0,-10.0);\n        position.x *=0.78;\n       \tfloat dif = mapCircle(position);\n        t += dif * 0.6;\n    }\n    return t;\n}\n//use float cool)))\nvec3 GradientMap(vec3 heightMap){\nreturn mix(vec3(0.9,0.92,0.91),vec3(0.0,0.5,0.85), heightMap);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n   \t//Init UV\n   \tvec2 uv = fragCoord.xy/iResolution.xy;\n   \tuv = 2.0*uv - 1.0;\n   \tuv.x *= iResolution.x/iResolution.y;\n\t\n    //Init Space \n    vec3 origin = vec3(WAVE_SPEED,1.4,-1.0); \n    vec3 directional = normalize(vec3(uv,1.0)) ;\n    directional = rotXAxis(directional, -60.0 * fract(iTime*0.006));\n    directional = rotZAxis(directional, 0.0);\n    directional = rotYAxis(directional, 15.0);\n    \n    \n   \t//Trace\n    vec3 position = vec3(0.0,0.0,0.0) ;\n    float t = Trace(origin, directional, position);\n    vec3 dist = origin - position;\n    \n    //TraceSun\n    vec3 SunPosition = vec3(0.0);\n    vec3 DirectionalSun = normalize(vec3(uv,1.0)) ;\n    vec3 originSun = vec3(0.0,0.0,0.0); \n    float tSun = TraceSun(originSun, DirectionalSun, SunPosition);\n    \n    //Height Map\n    vec3 hm;\n    float attenuation = 1.0 /(1.0 +t*t*0.08);\n    hm = vec3(attenuation);\n    \n    //HeightMapSun\n    vec3 hms;\n    float attenuationSun = 2.0 /(1.0 +tSun*tSun*0.08);\n    hms = vec3(attenuationSun);\n    \n    //Diffuse\n    vec3 gm; \n    gm = GradientMap(hm);\n    \n    //DiffuseSun\n    hms =1.0* hms*vec3(0.8,0.7,0.1);\n    \n    //Gamma corection\n    float gamma = 1.6;\n    gm = pow(gm, vec3(1.0/gamma));\n    \n    //SumColor\n    vec3 fc = gm + hms;\n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}