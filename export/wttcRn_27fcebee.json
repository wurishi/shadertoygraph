{"ver":"0.1","info":{"id":"wttcRn","date":"1608396682","viewed":62,"name":"Basic Mandelbrot Set Visualizati","username":"Seenax","description":"basic Mandelbrot set visualization","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 03.1415926535897932384626433\n#define MAX_STEPS 256\n#define ZOOM_POINT vec2(-.1, 0.) //vec2(-0.812223315621338, -0.185453926110785)\n#define ZOOM_SPEED 0.\n#define POWER 2.\n\n// from Mattz\nvec3 magma(float t)\n{ \n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    t *= 2.; if(t >= 1.) { t = 2. - t; }\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 vec3pow(in vec3 a, in float p)\n{\n    return vec3(\n        pow(a.x, p),\n        pow(a.y, p),\n        pow(a.z, p)\n    );\n}\n\nvec2 complexPow(in vec2 z, in float power)\n{\n    float len = length(z);\n    if (len == 0.)\n        return vec2(0.);\n    \n    float cosTetha = dot(z/len, vec2(1., 0.));\n    float tetha = acos(cosTetha) * (z.y == 0. ? 1. : sign(z.y));\n    return pow(len, power) * vec2(cos(tetha * power), sin(tetha * power));\n}\n\nvec2 Fc(in vec2 z, in vec2 c)\n{\n    return complexPow(z, POWER) + c;\n    //return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c; // optimized\n}\n\n// from here https://iquilezles.org/articles/msetsmooth\nfloat smoothIterateMandelbrot(in vec2 z, in vec2 c)\n{\n    const float B = 256.0;\n\n    float n = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        z = Fc(z, c);\n        if (dot(z,z) > (B*B))\n            break;\n            \n        n += 1.0;\n    }\n\n    float sn = n - log(log(length(z))/log(B))/log(POWER); // smooth iteration count\n    //float sn = n - log2(log2(dot(z,z))) + 4.0;  // equivalent optimized smooth iteration count for POWER 2\n   \n    return max(0., sn * .075);\n}\n\nfloat iterateMandelbrot(in vec2 z, in vec2 c)\n{\n    for (int i=0; i < MAX_STEPS; ++i)\n    {\n        z = Fc(z, c);\n        if (length(z) > 2.)\n            return float(i)/10.;\n    }\n    \n    return 0.;\n}\n\nfloat clickTime = 0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    float zoom = pow(iTime - clickTime, 5. * ZOOM_SPEED);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - vec2(1.);\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= .5;\n    uv /= zoom;\n    uv += ZOOM_POINT;\n    \n    vec2 z = vec2(0., 0.);\n    float value = clamp(sqrt(smoothIterateMandelbrot(z, uv) * .05), 0., 1.);\n    vec3 col = magma(value);\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}