{"ver":"0.1","info":{"id":"NsdcW4","date":"1653472270","viewed":111,"name":"cmyk square fly through","username":"HaleyHalcyon","description":"created as a background graphic for a technical difficulties screen","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["aeuaoueaouaeo"],"hasliked":0,"parentid":"NddcDn","parentname":"technical difficulties please st"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// uniform noise, pre-generated.\nconst float[32] rfloat = float[](\n0.870967,\n0.580645,\n0.193548,\n0.774193,\n0.838709,\n0.225806,\n0.806451,\n0.161290,\n0.967741,\n0.741935,\n0.096774,\n0.645161,\n0.032258,\n0.0,\n0.935483,\n0.677419,\n0.290322,\n0.354838,\n0.064516,\n0.387096,\n0.451612,\n0.258064,\n1.0,\n0.129032,\n0.709677,\n0.322580,\n0.548387,\n0.516129,\n0.612903,\n0.903225,\n0.483870,\n0.419354\n);\n\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 1;\n    return float((xy.x ^ xy.y) * 2 + xy.y)/ 4.;\n}\n\nvec3 colormap(vec3 rgb) {\n    const vec3 c000 = HEX(0x010a31);\n    const vec3 c001 = HEX(0x009be8);\n    const vec3 c011 = HEX(0xb57eff);\n    const vec3 c010 = HEX(0xeb0072);\n    const vec3 c110 = HEX(0xffba97);\n    const vec3 c100 = HEX(0xfff100);\n    const vec3 c101 = HEX(0xacff9e);\n    const vec3 c111 = HEX(0xffffff);\n    \n    vec3 c00x = mix(c000, c001, rgb.r);\n    vec3 c01x = mix(c010, c011, rgb.r);\n    vec3 c10x = mix(c100, c101, rgb.r);\n    vec3 c11x = mix(c110, c111, rgb.r);\n    \n    vec3 c0xx = mix(c00x, c01x, rgb.g);\n    vec3 c1xx = mix(c10x, c11x, rgb.g);\n    \n    return mix(c0xx, c1xx, rgb.b);\n}\n\n// How many squares to render. Max 32\n#define COUNT 24\n// The time multiplier. 1x will cause it to loop once every second!\n#define SPEED 1./16.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    vec3 rgb = vec3(0);\n    float t = iTime * SPEED;\n    \n    for (int i = 0; i < COUNT; i++) {\n        // generate random squares\n        float rOffset = rfloat[i % 32];\n        float rSize = rfloat[(1 + i * 5) % 32];\n        float rXPosition = rfloat[(4 + i * 9) % 32];\n        float rYPosition = rfloat[(2 + i * 13) % 32];\n        // generate the properties\n        float size = 0.1 + 0.6 * rSize;\n        float time = fract(t + rOffset);\n        vec2 uvScale = uv * (6. * (1.02 - time)) + vec2(\n            4. * (rXPosition - 0.5),\n            4. * (rYPosition - 0.5)\n        );\n        // antialias width\n        float aa = fwidth(uvScale.x) * 1.;\n        \n        // generate square bounds\n        float alphaX = smoothstep(\n            -aa, aa,\n            size - abs(uvScale.x)\n        );\n        // y bounds move with time\n        float alphaY = smoothstep(\n            -aa, aa,\n            size - abs(uvScale.y)\n        );\n        // squares fade in/out\n        float alphaTime = smoothstep(0.5, 0.4, abs(0.5 - time)) * 0.5;\n        \n        float alpha = alphaX * alphaY * alphaTime;\n        \n        rgb = mix(\n        rgb, vec3(1.), vec3(i%3==0, i%3==1, i%3==2) * alpha\n        );\n    }\n    // overexposure\n    rgb = 2. * rgb;\n    rgb = min(rgb, vec3(1.0)) + 2. * max(vec3(0.0), rgb.gbr - 1.) + 2. * max(vec3(0.0), rgb.brg - 1.);\n    \n    const float steps = 1.;\n    float thres = 1.0 - (\n    crosshatch(fragCoord) +\n    crosshatch(fragCoord / 2.) / 4. +\n    crosshatch(fragCoord / 4.) / 16.+\n    crosshatch(fragCoord / 8.) / 64.);\n    //v = fract(uv.x + 0.5); // crosshatch patterntest \n    rgb = clamp(\n    (floor(steps * rgb) + step(thres, fract(steps * rgb))) / steps\n    , vec3(0.), vec3(1.));\n    vec3 col = colormap(\n        rgb\n    );\n    \n    // masking where the center graphic will be\n    //col = mix(col, HEX(0x800030), step(uv.y*uv.y + uv.x*uv.x, 0.2));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}