{"ver":"0.1","info":{"id":"sljSzD","date":"1627249345","viewed":162,"name":"Gamma (complex function grapher)","username":"harry7557558","description":"Manipulated from [url]https://harry7557558.github.io/tools/complex_webgl.html[/url], but for 3D.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["domain","complex","gamma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ZERO min(int(iTime),0)\n\nconst vec3 CTR = vec3(0.0, 0.0, 1.0);  // center of viewport\nconst vec3 RAD = vec3(3.0, 2.0, 1.5);  // bounding box radius\n\n\n// function to graph\nvec2 fun(vec2 z) {\n    // some interesting functions you may try\n    //return CSC(2.0*z);\n    //return TAN(2.0*z);\n    //return SIN(INV(MUL(z,z)));\n    //return 0.5*SQR(LOG(POW(z,vec2(6,0))));\n    \n    // gamma function product formula, zoom to fit\n    z *= 1.5;\n    vec2 c = INV(z);\n    for (float n=float(ZERO)+1.; n<10.; n++) {\n        c = MUL(c, DIV(POW(vec2(1.+1./n,0),z), vec2(1,0)+z/n) );\n    }\n    return c/2.0;\n}\n\n\n// sdf and gradient\nvec3 sdf_grad(vec3 p) {\n    const float eps = 0.01;\n    float dh_x = length(fun(p.xy+vec2(eps,0)))-length(fun(p.xy-vec2(eps,0)));\n    float dh_y = length(fun(p.xy+vec2(0,eps)))-length(fun(p.xy-vec2(0,eps)));\n    return vec3(vec2(dh_x,dh_y)/(2.*eps), 1.0);\n}\nfloat sdf(vec3 p) {\n    float h = length(fun(p.xy));\n    vec3 n = sdf_grad(p);\n    return (p.z-h)/length(n);\n}\n\n// raymarching shape\nfloat raymarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin + 1e-2;\n    for (int i=ZERO; i<100; i++) {\n        float dt = 0.2*sdf(ro+rd*t);\n        t += dt;\n        if (abs(dt) < 1e-2) return t;\n        if (t > tmax || t < tmin) return -1.0;\n    }\n    //return -1.0;\n    return t;\n}\n\n\n// complex domain coloring\nfloat hue2rgb(float p, float q, float t) {\n    if (t < 0.) t += 1.;\n    if (t > 1.) t -= 1.;\n    if (t < 1./6.) return p + (q - p) * 6. * t;\n    if (t < 1./2.) return q;\n    if (t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}\nvec3 hslToRgb(float h, float s, float l) {\n    if (s == 0.) return vec3(l);\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2. * l - q;\n    return vec3(\n        hue2rgb(p, q, h + 1./3.),\n        hue2rgb(p, q, h),\n        hue2rgb(p, q, h - 1./3.)\n    );\n}\nvec3 complexColor(vec2 z) {\n    float h = Arg(z) * 0.159;\n    float s = 1.0;\n    // s *= 0.5 + 0.5 * sqrt(abs(sin(3.141592653569793 * Mag(z))));  // linear contour\n    // s *= 0.5 + 0.5 * sqrt(abs(sin(1.364 * logMag(z))));   // logarithmic contour\n    float l = 1.0 - pow(1.0 - 0.5, log(log(Mag(z) + 1.0) + 1.05));\n    return hslToRgb(h, s, l);\n}\n\n// box intersection function from iq\nvec2 boxIntersection(vec3 ro, vec3 rd) {\n    vec3 inv_rd = 1.0/rd;\n    vec3 n = inv_rd*(ro-CTR), k = abs(inv_rd)*RAD;\n    vec3 t1 = -n - k, t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if(tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n\n// main rendering function\nvec3 render(vec3 ro, vec3 rd) {\n\n    // raymarching surface\n    vec2 tnf = boxIntersection(ro, rd);\n    float tmin = tnf.x, tmax = tnf.y;\n    if (tmax < 0.0) return vec3(0.0);\n    float t = raymarch(ro, rd, tmin, tmax);\n    if (t < tmin) return vec3(0.1);\n    \n    // shading\n    vec3 p = ro + rd*t;\n    vec3 light = normalize(vec3(10.,10.,20.) - p);\n    vec3 n = normalize(sdf_grad(p));\n    vec3 col = 1.5*sqrt(complexColor(fun(p.xy)));\n    vec3 bkg = 0.8 * col;\n    vec3 dif = max(dot(n, light), 0.0) * col;\n    vec3 spc = pow(max(dot(rd-2.0*dot(rd,n)*n, light),0.0), 10.0) * vec3(1.0);\n    return 0.5*bkg+0.5*dif+0.2*spc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.z>0.?1.57*(iMouse.y/iResolution.y):0.3;\n    float rz = iMouse.z>0.?-iMouse.x/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u=vec3(-sin(rz),cos(rz),0);\n    vec3 v=cross(w,u);\n\n    vec3 ro = CTR + 10.0*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution));\n\n    vec3 col = render(ro, normalize(rd));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// elementary complex functions for GLSL\n// from https://harry7557558.github.io/tools/complex_webgl.html\n\nfloat Mag(vec2 a) { return length(a); }\nfloat Arg(vec2 a) { return atan(a.y, a.x); }\nfloat logMag(vec2 a) {\n    //return 0.5*log(dot(a,a));\n    return log(length(a));\n}\nvec2 REL(vec2 e) { return vec2(e.x, 0); }\nvec2 IMA(vec2 e) { return vec2(e.y, 0); }\nvec2 CNJ(vec2 e) { return vec2(e.x, -e.y); }\nvec2 ADD(vec2 a, vec2 b) { return a + b; }\nvec2 SUB(vec2 a, vec2 b) { return a - b; }\nvec2 MUL(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 DIV(vec2 a, vec2 b) { return (1.0/dot(b,b)) * vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y); }\nvec2 POW(vec2 e, vec2 t) {\n    float a = Arg(e), r = logMag(e), c = exp(t.x*r-t.y*a), s = t.x*a+t.y*r;\n    return c * vec2(cos(s), sin(s));\n}\nvec2 CBR(vec2 e) { return POW(e, vec2(1.0/3.0,0)); }\nvec2 EXP(vec2 e) { return exp(e.x) * vec2(cos(e.y),sin(e.y)); }\nvec2 LOG(vec2 e) { return vec2(logMag(e), Arg(e)); }\nvec2 SQR(vec2 e) {\n    float m = Mag(e);\n    return e.y>0. ? vec2(sqrt(0.5*(m+e.x)), sqrt(0.5*(m-e.x))) :\n        vec2(sqrt(0.5*(m+e.x)), -sqrt(0.5*(m-e.x)));\n}\nvec2 INV(vec2 e) { return (1./dot(e,e)) * vec2(e.x, -e.y); }\n\nvec2 SIN(vec2 e) { return vec2(sin(e.x)*cosh(e.y), cos(e.x)*sinh(e.y)); }\nvec2 COS(vec2 e) { return vec2(cos(e.x)*cosh(e.y), -sin(e.x)*sinh(e.y)); }\nvec2 TAN(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cos(a)+cosh(b);\n    return (1./d) * vec2(sin(a), sinh(b));\n}\nvec2 COT(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cos(a)-cosh(b);\n    return (1./d) * vec2(-sin(a), sinh(b));\n}\nvec2 SEC(vec2 e) {\n    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) + 0.5*cos(2.*a);\n    return (1./d) * vec2(cos(a)*cosh(b), sin(a)*sinh(b));\n}\nvec2 CSC(vec2 e) {\n    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) - 0.5*cos(2.*a);\n    return (1./d) * vec2(sin(a)*cosh(b), -cos(a)*sinh(b));\n}\nvec2 SNH(vec2 e) { return vec2(sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y)); }\nvec2 CSH(vec2 e) { return vec2(cosh(e.x)*cos(e.y), sinh(e.x)*sin(e.y)); }\nvec2 TNH(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)+cos(b);\n    return (1./d) * vec2(sinh(a), sin(b));\n}\nvec2 CTH(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)-cos(b);\n    return (1./d) * vec2(sinh(a), -sin(b));\n}\nvec2 CCH(vec2 e) {\n    float d = cos(2.*e.y) - cosh(2.*e.x);\n    return (2./d) * vec2(-sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y));\n}\nvec2 SCH(vec2 e) {\n    float d = cos(2.*e.y) + cosh(2.*e.x);\n    return (2./d) * vec2(cosh(e.x)*cos(e.y), -sinh(e.x)*sin(e.y));\n}\n\nvec2 ASN(vec2 e) {\n    float a = e.x, b = e.y;\n    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));\n    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));\n    return vec2(t2.y, -t2.x);\n}\nvec2 ACS(vec2 e) {\n    float a = e.x, b = e.y;\n    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));\n    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));\n    return vec2(1.570796327-t2.y, t2.x);\n}\nvec2 ATN(vec2 e) {\n    float a = e.x, b = e.y, d = a*a + (1.-b)*(1.-b);\n    vec2 t1 = LOG(vec2((1.-b*b-a*a)/d, -2.*a/d));\n    return vec2(-0.5*t1.y, 0.5*t1.x);\n}\nvec2 ACT(vec2 e) { return ATN(INV(e)); }\nvec2 ASC(vec2 e) { return ACS(INV(e)); }\nvec2 ACC(vec2 e) { return ASN(INV(e)); }\nvec2 ASH(vec2 e) { vec2 r = ASN(vec2(e.y,-e.x)); return vec2(-r.y,r.x); }\nvec2 ACH(vec2 e) { vec2 r = ACS(e); return r.y<=0.?vec2(-r.y,r.x):vec2(r.y,-r.x); }\nvec2 ATH(vec2 e) {\n    float a = e.x, b = e.y;\n    float oneMinus = 1.-a, onePlus = 1.+a, d = oneMinus*oneMinus + b*b;\n    vec2 x = (1./d) * vec2(onePlus*oneMinus-b*b, b*oneMinus+b*onePlus);\n    return vec2(0.5*logMag(x), 0.5*Arg(x));\n}\nvec2 AKH(vec2 e) { return ATH(INV(e)); }\nvec2 AXH(vec2 e) { return ASH(INV(e)); }\nvec2 AGH(vec2 e) { return ACH(INV(e)); }\n\n","name":"Common","description":"","type":"common"}]}