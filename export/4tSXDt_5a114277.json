{"ver":"0.1","info":{"id":"4tSXDt","date":"1451414690","viewed":499,"name":"Touch with LeapMotion Hand Test","username":"edankwan","description":"It is a test for the LeapMotion WebGL demo http://www.edankwan.com/experiments/touch/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float INTERSECTION_PRECISION = 0.001;\nconst float NEAR = 0.1;\nconst float FAR = 2000.0;\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\nfloat sdCappedCylinderLower( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y + h.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ) {\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nfloat sdFingerBone( in vec3 p, in mat4 fingerBone) {\n    \n    vec3 scale = vec3(fingerBone[0][3], fingerBone[1][3], fingerBone[2][3]);\n    \n    fingerBone[0][3] = 0.0;\n    fingerBone[1][3] = 0.0;\n    fingerBone[2][3] = 0.0;\n    \n    p = (fingerBone * vec4(p, 1.0)).xyz;\n    \n    return min(\n        sdSphere(p, scale.x),\n        sdCappedCylinderLower(p, vec2(scale.x, scale.y / 2.0))\n    );\n}\n\nfloat map( in vec3 p, in mat4[16] data ) {\n    float d = FAR;\n    \n    mat4 palmData = data[0];\n    vec3 scale = vec3(palmData[0][3], palmData[1][3], palmData[2][3]);\n    \n    palmData[0][3] = 0.0;\n    palmData[1][3] = 0.0;\n    palmData[2][3] = 0.0;\n    \n    d = min(d, sdHexPrism((palmData * vec4(p, 1.0)).xyz, vec2(scale.x, scale.z / 2.0)));\n    \n    for( int i = 1; i < 16; i++ ) {\n        d = min(d, sdFingerBone(p, data[i]));\n    }\n    \n    \n    //d = min(d, sdHexPrism(p, vec2(100.0, 10.0)));\n    \n    //d = min(d, sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)));\n    \n    //d = min(d, sdCappedCylinderLower(p, vec2(100.0, 100.0)));\n    \n    return d;\n}\n\nvec3 calcNormal_old( in vec3 pos, in mat4[16] data ) {\n    vec3 eps = vec3(0.002,0.0,0.0);\n    return normalize( vec3(\n           map(pos+eps.xyy, data) - map(pos-eps.xyy, data),\n           map(pos+eps.yxy, data) - map(pos-eps.yxy, data),\n           map(pos+eps.yyx, data) - map(pos-eps.yyx, data) ) );\n}\n\nvec3 calcNormal( in vec3 pos, in mat4[16] data )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*.01;\n    return normalize( e.xyy*map( pos + e.xyy, data ) +\n                      e.yyx*map( pos + e.yyx, data ) +\n                      e.yxy*map( pos + e.yxy, data ) +\n                      e.xxx*map( pos + e.xxx, data ) );\n}\n\n\nvec4 intersect( in vec3 ro, in vec3 rd, in mat4[16] data ) {\n    \n    float d = NEAR;\n    float sumd = NEAR;\n    \n    vec3 p = ro + rd * d;\n    \n    float t = 0.0;\n    for( int i=0; i<50; i++ ) { \n        d = map( p, data );\n        if(d < INTERSECTION_PRECISION || sumd > FAR) break;\n        \n        sumd += d;\n        p += rd * d;\n    }\n\n    return vec4(p, d);\n    \n}\n\n\nvoid render(in vec3 ro, in vec3 rd, inout vec3 col, in mat4[16] data ) {\n\n    vec4 res = intersect(ro, rd, data);\n    vec3 pos = res.xyz;\n    vec3 nor = calcNormal( pos, data );\n    vec3 ref = reflect( rd, nor );\n    \n    if (res.w < INTERSECTION_PRECISION) {\n        col = vec3(1.0, 1.0, 1.0);\n    \n        // lighitng\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00);\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00);\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25);\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00);\n        brdf += 0.02;\n        col = col*brdf;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    mat4 data[16];\n    \n\t// data dumped from the webpage\n    data[0] = mat4( 0.5071753263473511, 0.37931835651397705, 0.8147028684616089, 33.020286560058594, 0.8555222749710083, -0.5918408632278442, -0.3567546010017395, 36.038330078125, 0.2751452326774597, 0.8457598090171814, -0.6530782580375671, 25.9517879486084, -145.39219665527344, 101.49678039550781, 68.79705047607422, 1.0);\n    data[1] = mat4( 0.5983963012695312, 0.758206307888031, -0.25893062353134155, 8.985650062561035, 3.3658409392955946e-10, 0.32317841053009033, 0.9463380575180054, 44.30060958862305, 0.801200270652771, -0.5662851929664612, 0.19338877499103546, 8.985650062561035, -34.11090850830078, -88.48513793945312, -147.6454620361328, 1.0);\n    data[2] = mat4( 0.8364007472991943, 0.5346810817718506, -0.12062347680330276, 8.985650062561035, 1.5648309314997277e-8, 0.22006824612617493, 0.9754844903945923, 30.258787155151367, 0.5481184720993042, -0.8158959150314331, 0.18406522274017334, 8.985650062561035, -44.376338958740234, -88.93354797363281, -159.31216430664062, 1.0);\n    data[3] = mat4( 0.9921209812164307, 0.12517434358596802, -0.005222442094236612, 8.985650062561035, 5.661379143262479e-10, 0.0416850782930851, 0.9991307854652405, 15.952950477600098, 0.12528324127197266, -0.9912586212158203, 0.0413566417992115, 8.985650062561035, -62.56550598144531, -50.18754196166992, -173.701904296875, 0.9999999403953552);\n    data[4] = mat4( 0.9149901270866394, 0.36118781566619873, -0.1798233836889267, 8.583100318908691, -2.1303717900877928e-8, 0.4456852078437805, 0.8951897621154785, 38.1278076171875, 0.4034762680530548, -0.8190897703170776, 0.40779757499694824, 8.583100318908691, -12.331381797790527, -154.5205841064453, -173.60504150390625, 1.0);\n    data[5] = mat4( 0.8975245356559753, 0.44039908051490784, -0.022325173020362854, 8.583099365234375, 1.3945320453956356e-8, 0.05062802881002426, 0.9987175464630127, 21.450544357299805, 0.44096460938453674, -0.8963735103607178, 0.04543989151716232, 8.583100318908691, -9.800576210021973, -94.13629913330078, -220.8803253173828, 1.0);\n    data[6] = mat4( 0.8854115605354309, 0.44700491428375244, 0.12740905582904816, 8.583100318908691, -4.148359167288618e-8, -0.27411115169525146, 0.961698055267334, 11.688687324523926, 0.46480798721313477, -0.8514986038208008, -0.24270115792751312, 8.583099365234375, -7.581989765167236, -29.797914505004883, -239.5002899169922, 1.0);\n    data[7] = mat4( 0.9694989919662476, 0.21628578007221222, -0.115291528403759, 8.429749488830566, 6.317946166234378e-10, 0.4703948199748993, 0.8824560642242432, 42.77682876586914, 0.24509523808956146, -0.8555402755737305, 0.45604729652404785, 8.429749488830566, 2.7783355712890625, -160.21107482910156, -168.93592834472656, 1.0);\n    data[8] = mat4( 0.9228090643882751, 0.3836064040660858, -0.03563050553202629, 8.429750442504883, -2.2501051688550433e-8, 0.09248493611812592, 0.9957140684127808, 25.23654556274414, 0.3852575719356537, -0.9188539385795593, 0.08534594625234604, 8.429749488830566, 11.869654655456543, -106.56092071533203, -217.85340881347656, 1.0);\n    data[9] = mat4( 0.8772222995758057, 0.4674670398235321, 0.10934170335531235, 8.429750442504883, 2.0535672717869602e-8, -0.22775517404079437, 0.9737184047698975, 12.829567909240723, 0.4800843894481659, -0.8541674613952637, -0.19979192316532135, 8.429750442504883, 20.8353214263916, -43.19974136352539, -239.99951171875, 0.9999999403953552);\n    data[10] = mat4( 0.9830896258354187, 0.16083373129367828, -0.08756321668624878, 8.02145004272461, 2.3755797329272355e-10, 0.4781606197357178, 0.8782724142074585, 39.651947021484375, 0.1831251084804535, -0.8634204864501953, 0.47007474303245544, 8.02145004272461, 19.648418426513672, -152.8498992919922, -161.8258819580078, 1.0);\n    data[11] = mat4( 0.9358811378479004, 0.3485816419124603, -0.05116010084748268, 8.02145004272461, 8.598387779557015e-9, 0.145210862159729, 0.9894007444381714, 24.584932327270508, 0.3523159325122833, -0.9259614944458008, 0.1359000951051712, 8.02145004272461, 29.295255661010742, -107.8292007446289, -205.30209350585938, 1.0);\n    data[12] = mat4( 0.8877815008163452, 0.4560469090938568, 0.06217017024755478, 8.02145004272461, 6.990820811125786e-9, -0.13507471978664398, 0.9908353686332703, 12.711485862731934, 0.46026504039764404, -0.8796454071998596, -0.11991684138774872, 8.02145004272461, 38.15982437133789, -55.37266540527344, -226.62335205078125, 0.9999999403953552);\n    data[13] = mat4( 0.9999863505363464, 0.0046876524575054646, -0.0022922460921108723, 7.12529993057251, -9.570149360482727e-12, 0.4392881691455841, 0.8983461856842041, 31.380311965942383, 0.005218090955168009, -0.8983339071273804, 0.43928220868110657, 7.12529993057251, 30.588350296020508, -136.5830535888672, -154.39779663085938, 0.9999999403953552);\n    data[14] = mat4( 0.9570824503898621, 0.2880112826824188, -0.03229079768061638, 7.12529993057251, -1.515598491153014e-8, 0.11141838878393173, 0.9937736392021179, 17.358001708984375, 0.2898157835006714, -0.9511232972145081, 0.10663658380508423, 7.12529993057251, 44.9504508972168, -83.1126480102539, -192.5747833251953, 1.0);\n    data[15] = mat4( 0.880604088306427, 0.4666370451450348, 0.08237865567207336, 7.12529993057251, -1.8095587250854805e-8, -0.17384862899780273, 0.9847723841667175, 11.763103485107422, 0.4738526940345764, -0.867194652557373, -0.15309181809425354, 7.12529993057251, 56.18177795410156, -27.11683464050293, -206.44894409179688, 1.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 2.1;\n    \n    // camera\n    vec3 ro = vec3(0.0, 200.0, 500.0);\n    \n    ro.x = sin(time) * 400.0;\n    ro.z = cos(time) * 400.0;\n    \n    vec3 ta = vec3(0.0, 200.0, 0.0);\n    \n    // look at\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );\n    \n    \n    // ray direction\n    vec3 rd = normalize( camMat * vec3(uv, 2.0) );\n    \n    vec3 col = vec3(0.9);\n    \n    render(ro, rd, col, data);\n    \n    // gamma\n    fragColor = vec4(pow(col, vec3(0.75)), 1.0);\n    \n}","name":"","description":"","type":"image"}]}