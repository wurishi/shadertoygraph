{"ver":"0.1","info":{"id":"DtlyWB","date":"1691130071","viewed":51,"name":"Contour lines blending operators","username":"arkan","description":"Display contour lines of various 2D functions (here max, min, smoothMin).\nconsider f(x,y) -> v; \nA continuous line on the graph represents the same value 'v' \ngreen => v == 0.0\nred     =>    0.0 < v < 1.0\nblue    =>   -1.0 < v < 0.0","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["contourlines2dfunction"],"hasliked":0,"parentid":"XdycRw","parentname":"Level curves"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThe goal is to show how one can vizualize blending operators used to combine SDFs\nThis makes it easier to interpret the behavior of the 2D operator.\n\nFor instance we can see that smoothMin() is very similar to the min() function, \nexcept it produces smoothed isolines around the diagonal y = x \nwhich is where the  two sdf values x and y are equal, that is to say where the shapes of the \nsdf intersect.\n\nWhen getting used to this way of graphing and interpreting the operators\nand how it relates with the input SDFs values then you can start imagining\ndrawing operators by hand and find ways to express it mathematically in order to get \nthe desired blending between two SDFs.\n\nSee fig 16 of https://inria.hal.science/hal-00753246/document to see an operator \nthat produce a bulge when two sdf \"collide\" \n(material seems to be pushed around the line of intersection). \nThis was crafted in part thanks to the graphical insight \non how the \"shape\" of the blending operator effects the final result.\n\n*/\n\nfloat level_curves_greyscale(float f, float scale)\n{\n    float opacity = cos(f * 3.141592 * scale + 0.5);\n    opacity *= opacity;\n    opacity  = 1.0 - opacity;\n    opacity *= opacity;\n    opacity *= opacity;\n    opacity  = 1.0 - opacity;\n    return opacity;\n}\n\n//------------------------------------------------------------------------\n\nvec4 level_curves_color(float f, float iso_level, float scale)\n{\n\tfloat opacity = level_curves_greyscale(f, scale);\n\tvec4 color;\n\n\t     if(f >  iso_level) color = vec4(0.9, 0.2, 0.1, 1.0); // Inside red\n    else if(f <= iso_level) color = vec4(0.1, 0.2, 0.9, 1.0); // Outside blue\n\n\tif(true)\n    {\n        \n    \t     if(f >= 1.0    ) color = vec4(1.0, 0.75, 0.5, 1.0);\n        else if(f < -1.0    ) color = vec4(0.9, 0.90, 0.2, 1.0);\n\t\telse if( isnan(f)   ) color = vec4(1.0,  1.0, 0.0, 1.0); // yellow\n        \n        // Color strip that belong to iso-surface\n        if( abs(f-iso_level) < (1./scale) * 0.5 )\n            color = vec4(0.2, 0.9, 0.1, 1.0); // greenish\n            //color = Vec3(0.5); // grey\n\t}\n\n/*\n    float eps = 1e-4f;\n    if( f < (1.f + eps) && f > (1.f - eps)) \n        return vec4(0.0,0.0,0.0,1.0); // black\n    if( f < (eps*10.0) && f > 0.0 ) \n        return vec4(0.0,0.0,0.0,1.0); // black\n*/\n       \n    // glsl equivalent of lerp:\n    color = mix(color, vec4(1.0), opacity);\n    \n    color.a = 1.0 - opacity;\n    return color;\n}\n\n\n//------------------------------------------------------------------------\n\nfloat smoothMax(float a, float b, float k) {\n    return log(exp(k*a) + exp(k*b)) / k;\n}\n\nfloat smoothMin(float a, float b, float k){\n    return -smoothMax(-a, -b, k);\n}\n\n//------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1 on the y axis)\n    vec2 p = fragCoord / iResolution.y;\n    // place 0 at iResolution.y/2 and scale 10 times\n    // so that y ranges from [-10(bottom); 10(top)] \n    p -= 0.5;\n    p *= 10.0;\n    \n    \n    // Switch every 3 seconds\n    int mode = int(iTime / 3.0) % 3;\n    \n    \n    // Output value of our 2D function\n    float value = 0.0;\n    \n    if( mode == 1 ) \n        // Intersection of SDFs\n        value = max(p.x, p.y);\n    else if( mode == 2 )\n        // Union of SDFs\n        value = min(p.x, p.y);\n    else\n        // Smooth union of SDFs\n        value = smoothMin(p.x, p.y, 1.0);\n    \n    \n    // Output color to screen\n    fragColor = level_curves_color(value, \n                                   0.0/*central isoline (green)*/, \n                                   6.5/*spacing between isos*/ );\n}","name":"Image","description":"","type":"image"}]}