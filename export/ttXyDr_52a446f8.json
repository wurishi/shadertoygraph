{"ver":"0.1","info":{"id":"ttXyDr","date":"1592312555","viewed":294,"name":"Illustrative Skin Shader","username":"datamonkey","description":"A quick, easy way of making an illustrative skin shader. Drag the mouse to see the difference between a standard illustrative and the illustrative skin shading.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["skin","toon","npr","illustrative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Really simple modification to a standard toon/illustrative shading technique to get a skin/subsurface-scattering type effect.\n//\n// calcDiffuseToon() is the \"standard\" toon model. It effectively does a soft threshold of the light angle.\n// calcDiffuseToonSeparate() does the same, but per-channel. This results in being able to spread/diffuse given color\n// \t\tchannels more or less than others. If you set up the spreading so the green and blue channels spread more than\n//\t\tthe red channel, you end up with a nice red-tinted fringe, similar to how light diffuses through skin.\n//\n// Set ZERO_CENTERED below to shift the shading so it occurs across the zero point instead of from zero (which is definitely\n//\t\tless \"realistic\" than without). For the per-channel shading, this has the effect of creating a color fringe of\n//\t\tthe opposite color on the negative side.\n\n\n// Scene/Shading parameters\n\n// 0 = torus\n// 1 = sphere\n#define SHAPE 1\n\n// Change to make the spread cross the zero line (which brings in some negative colors for the per-channel on the opposite side)\n#define ZERO_CENTERED 0\n\n\nfloat calcDiffuseToon(vec3 lightDirection, vec3 normal, float spread)\n{\n    float NdotL = dot(lightDirection, normal);\n#if ZERO_CENTERED\n    return smoothstep(-spread * 0.5, spread * 0.5, NdotL);\n#else\n    return smoothstep(0.0, spread, NdotL);\n#endif\n}\n\nvec3 calcDiffuseToonSeparate(vec3 lightDirection, vec3 normal, vec3 spread)\n{\n    float NdotL = dot(lightDirection, normal);\n#if ZERO_CENTERED\n    return smoothstep(-spread * 0.5, spread * 0.5, vec3(NdotL, NdotL, NdotL));\n#else\n    return smoothstep(vec3(0.0, 0.0, 0.0), spread, vec3(NdotL, NdotL, NdotL));\n#endif\n}\n\n\n// Tracing Parameters, probably leave these alone\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 60\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.7\n\nvec2 scene(vec3 position)\n{\n    // to move the sphere one unit forward, we must subtract that translation from the world position\n    vec3 translate = vec3(0.0, -0.75, 1.0);\n    \n    mat4 rotMat = rotationMatrix(normalize(vec3(1.0, 1.0, 1.0)), iTime);\n    vec3 actualPos = (inverse(rotMat) * vec4(position - translate, 0.0)).xyz;\n    \n#if SHAPE == 0\n    float distance = sdTorus(actualPos, vec2(0.5, 0.1));\n#elif SHAPE == 1\n    float distance = sdSphere(actualPos, 0.5);\n#endif\n\tfloat materialID = 1.0;\n    \n    return vec2(distance, materialID);\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec2 result = scene(position + direction * total_distance);\n        if(result.x < EPSILON)\n        {\n            return vec2(total_distance, result.y);\n        }\n\n        total_distance += result.x * DISTANCE_BIAS;\n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nvec3 calcNormal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 rawUV = uv;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 viewDirection = normalize(vec3(uv, 4.0)); // smaller Z is bigger FOV\n    vec3 cameraOrigin = vec3(0.0, -0.75, -1.75);\n    vec2 result = raymarch(cameraOrigin, viewDirection);\n    \n    if (result.y != 0.0)\n    {\n        float fog = pow(1.0 / (1.0 + result.x), 0.45);\n\n        vec3 materialColor = vec3(0.79, 0.59, 0.39);\n\n        vec3 intersection = cameraOrigin + viewDirection * result.x;\n        vec3 normal = calcNormal(intersection, 0.01);\n\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n        vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n\n        float bands = 1.0;\n        float fresnelBands = 2.0;\n\n        vec3 diffuse;\n        if (fragCoord.x < iMouse.x) {\n        \tdiffuse = vec3(calcDiffuseToon(lightDir, normal, 0.2)).xxx;\n        } else {\n        \tdiffuse = calcDiffuseToonSeparate(lightDir, normal, vec3(0.2, 0.28, 0.29));\n        }\n\n        // Combine ambient light and diffuse lit directional light\n\n        vec3 diffuseLight = diffuse * lightColor;\n        vec3 lighting = (diffuseLight + ambientColor) * materialColor;\n        fragColor = vec4(lighting, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float saturate(float v) {\n\treturn clamp(v, 0.0, 1.0);\n}\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\n","name":"Common","description":"","type":"common"}]}