{"ver":"0.1","info":{"id":"wtSXD1","date":"1566698737","viewed":484,"name":"Vaporwave__0001","username":"dreamur","description":"Technically not the first vaporwave-esque scene I've tried, but I digress","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["skyline","cityscape","vaporwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\nstruct sceneObject\n{\n    float shadowBackLayer;\n    float buildingBackLayer;\n    float shadowFrontLayer;\n    float buildingFrontLayer;\n    float windowsBackLayer;\n\tfloat wReflectBackLayer;\n    float windowsFrontLayer;\n\tfloat wReflectFrontLayer;\n\n    float vaporGrid;\n};\n\nfloat random (in float x) { return fract(sin(x) * 1e4); }\nfloat random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\n\n// credit to @patriciogv from The Book of Shaders\n// https://thebookofshaders.com/edit.php#10/ikeda-04.frag\nfloat DeFrag(in vec2 _st)\n{\n\tvec2 tmpSpace = (_st / 2.0) - vec2(0.08, -0.09);\n    vec2 grid = vec2(100.0,50.);\n    tmpSpace *= grid;\n\n    vec2 ipos = floor(tmpSpace);\n\n    vec2 vel = floor(vec2(1.0));\n\n    float totalCells = grid.x * grid.y;\n    float t = mod(48.989 * max(grid.x, grid.y), totalCells);\n    vec2 head = vec2(mod(t, grid.x), floor(t / grid.x));\n\n    vec2 offset = vec2(0.0, 0.0);\n\n    float color = 1.0;\n    color *= step(grid.y - head.y, ipos.y);\n    color = clamp(color, 0.0, 1.0);\n    \n    color *= random(floor(tmpSpace + vel));    \n    color *= random( floor( 1.0 - color * sin( (iTime * color) / 3.0) ) );\n\n    color *= step(0.075, fract(tmpSpace.x + vel.x)) * step(0.2, fract(tmpSpace.y + vel.y));\n        \n\treturn color;\n}\n\nvec2 rotate( in vec2 _st, in float angle )\n{\n\treturn mat2( cos(angle * PI), -sin(angle * PI),\n                 sin(angle * PI), cos(angle * PI) ) * _st;\n}\n\nfloat rect( in vec2 _st, in vec2 xCoords, in vec2 yCoords)\n{\n    vec2 bl = step( vec2(xCoords.x, yCoords.x), _st );\n    vec2 tr = step( vec2(xCoords.y, yCoords.y), 1.0 - _st );\n\n\treturn bl.x * bl.y * tr.x * tr.y;\n}\n\nfloat vaporGrid(in vec2 _st)\n{\n    float vaporGrid     = 0.0;\n    vec2 lineDirection  = vec2(cos(PI), sin(PI));\n\n    vec2 tmpSpace       = _st;\n\n    if(tmpSpace.y < 1.0)\n        tmpSpace.y = mod(0.58 + tmpSpace.y, 1.0);\n    else tmpSpace.y = 1.0;\n        vaporGrid +=\n            1.0 - rect( (tmpSpace * vec2(0.35, 0.9)) - vec2(-0.2, -0.489), vec2(0.00001), vec2(0.490));\n\n    tmpSpace = _st - vec2(0.0, -0.025);\n    if(tmpSpace.y < 0.45)\n    {\n        float yVal \t= cos( (_st.y * 0.775) - 3.15 );     \n    \tfloat speed = ( iTime / (4.97 - yVal)) ;\n        tmpSpace.y \t= mod( speed * 0.94 + tmpSpace.y, 0.09);\n    }\n    else tmpSpace.y = 1.0;\n    vaporGrid *=\n        1.0 - rect( tmpSpace * vec2(0.35, 1.0) + vec2(0.2, 0.4925), vec2(0.00001), vec2(0.4985));\n\n    tmpSpace = 1.0 * _st;\n    tmpSpace -= vec2(0.85, -0.059);\n\n    for(int i = -6; i <= 6; i++)\n    {\n        float offsetAdjustMent = ( float(i)  / 8.5);\n\n        vec2 ts         = tmpSpace + vec2(clamp(0.45 - offsetAdjustMent, -90.0, 90.0), 0.0);\n        ts              -= 0.5;\n        ts              = rotate(ts, float(i) / 15.75);\n        ts              += 0.5;\n        float rectDF    = rect( ts + vec2(0.0, 0.5), vec2(0.4975), vec2(0.000001));\n        vaporGrid       = vaporGrid - (vaporGrid * rectDF);\n    }\n\n    return vaporGrid;\n}\n\n// by Inigo Quilez @iq \n// more info can be found here: https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min( max(d.x, d.y), 0.0 );\n}\n\nfloat skyline(in vec2 _st, in float _inner_stretch, in float _outer_stretch, in float _shadow_factor)\n{\n    float rnd   \t= random(floor(_st.xx * 9.0 + vec2(_shadow_factor, _shadow_factor) ));\n    vec2 ra     \t= vec2(2.0, _inner_stretch + rnd);\n\n    return sign( sdBox(_st, ra + vec2(0.0, _shadow_factor / 5.0)) );\n}\n\nvec3 calculateFinalColor(sceneObject _scene, vec2 _st)\n{\n    vec3 color         = vec3(0.0);\n    vec3 gradient      = vec3(0.0);\n    float tmpDF        = 0.0;\n    \n    //************************** sky ******************     \n    if(_st.y >= 0.43) \t{ color \t= mix(vec3(0.0, 0.0, 0.7), vec3(0.0, 0.0, 0.0), _st.y - 0.10); }\n    else \t\t\t\t{ color \t= mix( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.7), _st.y + 0.15); }\n    \n\t//************************** back-layer ******************\n    tmpDF\t\t\t   = _scene.shadowBackLayer;\n    color\t\t\t   = mix(vec3(0.153, 0.153, 1.0), color, tmpDF);\n    gradient = vec3(0.0);\n     \n    if(_st.y < 0.43)\n    {\n        tmpDF\t\t   = abs( 0.025 - ( _st.y *  1.5) );\n        gradient       = mix(gradient, vec3(0.0, 0.0, 0.7), tmpDF);\n    }\n    color              = mix(gradient, color, _scene.buildingBackLayer);\n      \n\ttmpDF\t\t\t   =  1.0 - ( _scene.windowsBackLayer *  (1.0 - _scene.buildingBackLayer) );    \n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\n\tcolor              = mix(vec3(0.475, 0.325, 0.141), color, tmpDF);\n    \n    tmpDF              = 1.0 - (_scene.wReflectBackLayer - (_scene.buildingBackLayer * _scene.wReflectBackLayer));\n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\t\t\n\tcolor              = mix(vec3(0.0, 0.0, 0.4), color, tmpDF); \n    \n    //************************** front-layer ******************   \n    color\t\t\t   = mix(vec3(0.153, 0.153, 1.0), color, _scene.shadowFrontLayer);    \n    gradient\t\t   = vec3(0.0);\n    \n    \n    if(_st.y >= 0.43)\n    {\n        tmpDF\t\t   =  5.875 - ( _st.y *  2.325) - 0.6;\n        gradient       = mix(vec3(0.251, 0.356, 0.054), vec3(0.0), tmpDF);\n    }\n    else\n    {\n        tmpDF\t\t   = 0.5 - ( _st.y *  1.5) - 0.6;\n        gradient       = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.7), tmpDF);\n    }\n    color              = mix(gradient, color, _scene.buildingFrontLayer);\n    \n    tmpDF\t\t\t   =  1.0 - ( _scene.windowsFrontLayer *  (1.0 - _scene.buildingFrontLayer)  );    \n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\n    color              = mix(vec3(0.424, 0.565, 0.137), color, tmpDF);\n    \n    tmpDF              = 1.0 - (_scene.wReflectFrontLayer - (_scene.buildingFrontLayer * _scene.wReflectFrontLayer));\n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\n    color              = mix(vec3(0.0, 0.0, 0.9), color, tmpDF);\n\n    //************************** grid ******************   \n    vec2 tmpCoord      = (gl_FragCoord.xy / iResolution.xy).y + vec2(0.0, -0.275);\n    gradient           = mix(vec3(0.0, 0.0, 0.75), vec3(0.0, 0.8, 0.7), tmpCoord.y * 7.0);\n    color              = mix(gradient, color, _scene.vaporGrid);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sceneObject scene;\n    vec3 color  = vec3(0.0, 0.0, 0.306);\n\n    vec2 st   = (fragCoord.xy / iResolution.xy);\n    st.x      *= iResolution.x / iResolution.y;\n    \n\n    vec2 buildingLocalSpace     = st * vec2(2.0, 2.35) - vec2(1.770 + sin(iTime / 4.0) / 6.0, 1.0);\t\n    scene.buildingBackLayer\t\t= skyline(buildingLocalSpace, 0.175, 0.8, 0.0);\n    scene.shadowBackLayer    \t= skyline(buildingLocalSpace, 0.176, 0.775, 0.075);\n    \n    buildingLocalSpace     \t\t= st * vec2(1.0, 2.82) - vec2(1.77 + sin(iTime / 4.0) / 5.85, 1.0);\n    scene.buildingFrontLayer    = skyline(buildingLocalSpace, 0.453, 0.875, 0.0);  \n    scene.shadowFrontLayer    \t= skyline(buildingLocalSpace, 0.453, 0.875, 0.05);\n\n    scene.vaporGrid             = vaporGrid(st - vec2(sin(iTime / 4.0) / 5.85, 0.0) );\n\n    vec2 defragSpace            = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    scene.windowsBackLayer      = DeFrag(defragSpace - vec2(-0.5 + sin(iTime / 4.0) / 6.0, 0.0));\n    scene.wReflectBackLayer     = DeFrag(defragSpace * vec2(1.0, -1.0) - vec2(-0.5 + sin(iTime / 4.0) / 6.0, 0.27));\n    \n    scene.windowsFrontLayer     = DeFrag(defragSpace - vec2(-1.77 + sin(iTime / 4.0) / 3.0, 0.0));\n    scene.wReflectFrontLayer    = DeFrag(defragSpace * vec2(1.0, -1.0) - vec2(-1.77 + sin(iTime / 4.0) / 3.0, 0.27));\n\n    fragColor = vec4( calculateFinalColor(scene, st), 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}