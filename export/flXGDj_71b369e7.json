{"ver":"0.1","info":{"id":"flXGDj","date":"1622806683","viewed":174,"name":"crosses_dance","username":"skaplun","description":"Original animation: https://dribbble.com/shots/3581536-crisscross-007/attachments/3581536-crisscross-007?mode=media ","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","animation","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 tex = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(mix(tex.rgb, vec3(1.), tex.a), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nvec2 calcPoint(in float ang){\n    return mix(vec2(-1. + cos(ang), sin(ang)),\n               vec2(1. + cos(ang + PI), sin(ang)),\n               step(PI*2., mod(ang, PI*4.)));\n}\n\nvec2 rotate( in vec2 uv, float a){\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat dist2Line(vec2 a, vec2 b, vec2 p) { \n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.); \n\treturn length( p - b * h );                       \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 5./iResolution.y\nconst vec2 CROSS_SIZE = vec2(.5, .1);\n\nconst vec3 COLORS[4] = vec3[4](\n    vec3(207., 16., 53.)/255.,\n    vec3(94., 199., 189.)/255.,\n    vec3(231., 31., 62.)/255.,\n    vec3(6., 144., 208.)/255.);\n\nfloat makeCross(vec2 uv, vec2 size){\n    return smin(smax(abs(uv.x) - size.x, abs(uv.y) - size.y, 50.),\n               smax(abs(uv.y) - size.x, abs(uv.x) - size.y, 50.), .05);\n}\n\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y * 1.75;\n    vec3 color = vec3(0.);\n    vec2 crosses;\n    float ang = iTime * 4.;\n    for(int i=0; i<2; i++){\n        vec2 curPoint;\n        {\n            float a = ang - PI * 1.5 * float(i);\n            vec2 muv = uv + calcPoint(a);\n            float ra = cos(a * .5) * (3. + 2. * float(i));\n            muv = rotate(muv, ra);\n            crosses[i] = smoothstep(AA, 0., makeCross(muv, CROSS_SIZE));\n            curPoint = abs(muv);\n        }\n        \n        color += COLORS[i * 2] * smoothstep(.1 + AA, .1, length(curPoint + vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y)));\n        color += COLORS[i * 2 + 1] * smoothstep(.1 + AA, .1, length(curPoint + vec2(-CROSS_SIZE.x + CROSS_SIZE.y, 0.)));\n    }\n    vec4 prevColor = .95 * texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor.rgb = max(prevColor.rgb, color);\n    fragColor.a = max(crosses.x, crosses.y);\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y * 1.75;\n    vec3 color = vec3(0.);\n    vec2 crosses;\n    float ang = iTime * 4.;\n    for(int i=0; i<2; i++){\n        vec2 curPoint, prevPoint;\n        float a1, a2;\n        {\n            float a = ang - PI * 1.5 * float(i);\n            curPoint = calcPoint(a);\n            prevPoint = calcPoint(a - iTimeDelta * 3.);\n            vec2 muv = uv - curPoint.xy;\n            a1 = cos(a * .5) * (3. + 2. * float(i));\n            a2 = cos((a - iTimeDelta * 3.) * .5) * (3. + 2. * float(i));\n            muv = rotate(muv, a1);\n            crosses[i] = smoothstep(AA, 0., makeCross(muv, CROSS_SIZE));\n        }\n        \n        vec2 a = curPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a1);\n        vec2 b = prevPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a2);\n        color += COLORS[i * 2] * smoothstep(.11, .1, dist2Line(a, b, uv));\n        \n        a = curPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a1 - PI);\n        b = prevPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a2 - PI);\n        color += COLORS[i * 2] * smoothstep(.11, .1, dist2Line(a, b, uv));\n        \n        a = curPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a1 - PI * .5);\n        b = prevPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a2 - PI * .5);\n        color += COLORS[i * 2 + 1] * smoothstep(.11, .1, dist2Line(a, b, uv));\n        \n        a = curPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a1 - PI * 1.5);\n        b = prevPoint + rotate(vec2(0., -CROSS_SIZE.x + CROSS_SIZE.y), -a2 - PI * 1.5);\n        color += COLORS[i * 2 + 1] * smoothstep(.11, .1, dist2Line(a, b, uv));\n    }\n    vec4 prevColor = .95 * texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor.rgb = max(prevColor.rgb, color);\n    fragColor.a = max(crosses.x, crosses.y);\n}","name":"Buffer A","description":"","type":"buffer"}]}