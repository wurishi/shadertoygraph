{"ver":"0.1","info":{"id":"tdyBzt","date":"1607706382","viewed":140,"name":"Magic Boxes","username":"Kamoshika","description":"I drew magic circles on the boxes.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I made this while streaming.\n// Watch YouTube video!!\n// https://www.youtube.com/watch?v=0ahLMwimXcw\n\nconst float pi = acos(-1.0);\n\nmat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 pmod(vec2 p, float n) {\n\tfloat a = 2.*pi/n;\n\tfloat theta = atan(p.y, p.x) + 0.5*a;\n\ttheta = floor(theta/a)*a;\n\treturn p*rotate(-theta);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\n/*vec3 hsv2rgb(float h, float s, float v) {\n\tfloat c_max = v;\n\tfloat c_min = c_max-s*c_max;\n\tfloat r,g,b;\n\n\th = mod(h, 1.);\n\th *= 6.;\n\tif(h < 1.) {\n\t\tr = c_max;\n\t\tg = h*(c_max-c_min) + c_min;\n\t\tb = c_min;\n\t} else if(h < 2.) {\n\t\tr = (2.-h)*(c_max-c_min) + c_min;\n\t\tg = c_max;\n\t\tb = c_min;\n\t} else if(h < 3.) {\n\t\tr = c_min;\n\t\tg = c_max;\n\t\tb = (h-2.)*(c_max-c_min) + c_min;\n\t} else if(h < 4.) {\n\t\tr = c_min;\n\t\tg = (4.-h)*(c_max-c_min) + c_min;\n\t\tb = c_max;\n\t} else if(h < 5.) {\n\t\tr = (h-4.)*(c_max-c_min) + c_min;\n\t\tg = c_min;\n\t\tb = c_max;\n\t} else if(h < 6.) {\n\t\tr = c_max;\n\t\tg = c_min;\n\t\tb = (6.-h)*(c_max-c_min) + c_min;\n\t}\n\treturn vec3(r,g,b);\n}*/\n\nfloat rand2(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.5322, 57.2115)))*65231.1264);\n}\n\nfloat distBox(vec3 p, float size) {\n\treturn length(max(abs(p)-size, 0.))-size*0.5;\n}\n\nconst float num = 5.;\nfloat interval_xy;\nfloat interval_z = 15.;\nfloat dist(vec3 p) {\n\tfloat d = 1e5;\n\tvec3 z;\n\tp.xy = mod(p.xy, interval_xy) - 0.5*interval_xy;\n\tfor(float i=0.; i<num; i++) {\n\t\tz = p;\n\t\tz.z -= interval_z/num*i;\n\t\tz.z = mod(z.z, interval_z) - 0.5*interval_z;\n\t\t\n\t\tfloat size = 0.1 + abs(sin(iTime*4.+pi/num*i))*0.5;\n\t\td = min(d, distBox(z, size));\n\t}\n\treturn d;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = 0.0001;\n\treturn normalize(vec3(dist(p+vec3(d,0,0))-dist(p+vec3(-d,0,0)),\n\t\t\t      dist(p+vec3(0,d,0))-dist(p+vec3(0,-d,0)),\n\t\t\t      dist(p+vec3(0,0,d))-dist(p+vec3(0,0,-d))\n\t\t\t      ));\n}\n\nfloat exp2Fog(float distance, float density) {\n\tfloat s = distance * density;\n\treturn exp(-s*s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 color=vec3(1);\n\t\n\tvec3 cPos = vec3(0, 0, 5);\n\tvec3 cDir = vec3(0, 0, -1);\n\tvec3 cUp = vec3(0, 1, 0);\n\tcUp.xy *= rotate(iTime*0.1);\n\tvec3 cSide = cross(cDir, cUp);\n\t\n\tvec3 lightDir = normalize(vec3(-1, 1, 2));\n\tlightDir.xy *= rotate(iTime*0.1);\n\t\n\tfloat targetDepth = 2.5;\n\tvec3 ray = normalize(p.x*cSide + p.y*cUp + cDir*targetDepth);\n\t\n    interval_xy = 5.+sin(iTime)*2.5;\n    \n\tfloat distance = 0.;\n\tvec3 rPos = cPos;\n\tfor(int i=0; i<100; i++) {\n\t\tdistance = dist(rPos);\n\t\tif(abs(distance) < 0.001) {\n\t\t\tbreak;\n\t\t}\n\t\trPos += ray * distance;\n\t}\n    \n    if(distance < 0.001) {\n        vec3 normal = getNormal(rPos);\n        vec3 Pos = rPos;\n\n        Pos.xy = mod(Pos.xy, interval_xy)-0.5*interval_xy;\n        vec2 id = rPos.xy - Pos.xy;\n        id /= interval_xy;\n        float r= rand2(id*0.005+floor(iTime*2.));\n        vec3 base = hsv2rgb(r, 1., 1.);\n\n        Pos *= num;\n        Pos.z = mod(Pos.z, interval_z)-0.5*interval_z;\n\n        vec3 temp = abs(Pos);\n        vec2 fPos;\n        if(temp.x > temp.y && temp.x > temp.z) {\n            fPos = Pos.yz;\n        } else if(temp.y > temp.z && temp.y > temp.x) {\n            fPos = Pos.zx;\n        } else {\n            fPos = Pos.xy;\n        }\n        fPos /= num;\n\n        fPos *= rotate(iTime*2.);\n        float s = 0.06;\n        vec2 z;\n        z = fPos;\n        z = pmod(z, 3.);\n        base *= s/abs(z.x-0.3);\n        z = fPos*rotate(pi/3.);\n        z = pmod(z, 3.);\n        base *= s/abs(z.x-0.3);\n        z = fPos;\n        base *= s/length(z-normalize(z)*0.6);\n        float spec = pow(max(dot(lightDir, normal), 0.), 30.);\t\n\n        color = base + spec;\n    }\n    \n    float fog = exp2Fog(length(rPos-cPos), 0.01);\n    color = mix(vec3(1), color, fog);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}