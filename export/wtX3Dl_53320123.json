{"ver":"0.1","info":{"id":"wtX3Dl","date":"1558737984","viewed":238,"name":"Animated Iris - prototype","username":"jaszunio15","description":"Experimenting with noise - animated iris.\nFast prototype.\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","eye","iris"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\nfloat hash(vec2 uv)\n{\n \treturn fract(sin(dot(uv, vec2(20.974, 80.2171))) * 300.963);   \n}\n\nfloat noise(vec2 uv)\n{\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash(uv00);\n    float v01 = hash(uv01);\n    float v10 = hash(uv10);\n    float v11 = hash(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    \n    return mix(v0, v1, f.x);\n}\n\nfloat radialNoise(vec2 uv, float dist, float noiseScale)\n{\n    //x - 360 angle mapped from 0 to 1\n \tvec2 polarUV = vec2((atan(uv.y, uv.x) + PI) / (2.0 * PI), dist);\n    \n    //x - angle mapped drom 0 to noiseScale\n    polarUV.x *= noiseScale;\n    \n    if(polarUV.x + 0.5 > noiseScale) polarUV.x -= noiseScale;\n    \n    //for debug\n    \t//polarUV.x = floor(polarUV.x);\n    polarUV.x += hash(vec2(polarUV.y, 2.0)) * 834.1;\n    \n    return noise(polarUV);\n}\n\nfloat irisNoise(vec2 uv, float len, float deltaDist, float densityMultiplier, float distanceStart)\n{\n \tfloat dist = len + (radialNoise(uv, deltaDist, 30.0) - 0.5) * 0.1 + distanceStart;\n    float lerpVal = fract(dist / deltaDist);\n    \n    float firstIndex = floor(dist / deltaDist);\n    float secondIndex = firstIndex + 1.0;\n    \n    float firstDist = firstIndex * deltaDist;\n    float secondDist = secondIndex * deltaDist;\n    \n    float firstDensity = firstIndex * densityMultiplier;\n    float secondDensity = secondIndex * densityMultiplier;\n    \n    float firstNoise = radialNoise(uv, firstDist, firstDensity);\n    float secondNoise = radialNoise(uv, secondDist, secondDensity);\n    \n    return mix(firstNoise, secondNoise, lerpVal);\n}\n\nfloat fractalNoise(vec2 uv, in float alphaMul, in float sizeMul, in float layers)\n{\n \tfloat fNoise = 0.0;\n    float size = 1.0;\n    float alpha = 1.0;\n    for(float i = 0.0; i < layers; i++)\n    {\n        fNoise += noise(uv) * alpha;\n        alpha *= alphaMul;\n        size *= sizeMul;\n    }\n    \n    fNoise /= layers;\n    \n    return fNoise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\n    float dist = length(uv);\n    \n    float pupilModifier = (1.0 - sqrt(noise(vec2(iTime * 0.5, 2.1))) * 0.75);\n    float vDist = (-IRIS_RADIUS + dist) * pupilModifier;\n    \n    \n    float pupilRadius = PUPIL_RADIUS;\n    \n    float pupil = 1.0 - smoothstep(pupilRadius, pupilRadius + ALIASING * pupilModifier, vDist + pupilRadius * 2.0);\n    float pupil2 = 1.0 - smoothstep(pupilRadius * 1.05, pupilRadius * 1.05 + ALIASING * 4.0 * pupilModifier, vDist + pupilRadius * 2.0);\n    float iris = irisNoise(uv, vDist,  0.015, 60.0, 0.15);\n    float irisCenter = irisNoise(uv, vDist,  0.015, 120.0, 0.15);\n    float irisDetails = irisNoise(uv, vDist,  0.016, 150.0, 0.14);\n    float irisBorder = 1.0 - smoothstep(0.0, IRIS_RADIUS, abs(dist - IRIS_RADIUS));\n    float irisWhiteBorder = 1.0 - smoothstep(0.0, 0.2 * (1.0 - pow(pupilModifier, 1.4)), abs(dist - IRIS_RADIUS + 0.001));\n    float whiteEye = smoothstep(IRIS_RADIUS, IRIS_RADIUS + ALIASING * 3.0, dist);\n    \n    vec3 eye = smoothstep(-0.5, 1.0, iris) * vec3(0.8, 0.8, 0.5) * 0.9;\n    eye = mix(eye, eye * irisDetails * irisDetails + irisWhiteBorder * 0.7 * vec3(0.6,1,1), 0.3);\n    eye = mix(eye, eye * irisCenter * 0.3, pupil2);\n    eye = mix(eye, vec3(0.0), pupil);\n    eye = mix(eye, vec3(1.0), whiteEye);\n    eye = mix(eye, vec3(irisBorder), 0.4);\n    //eye = mix(eye, vec3(irisWhiteBorder) * irisDetails, 0.5);\n    \n    eye = smoothstep(0.1, 1.0, eye);\n    \n    float reflection = smoothstep(0.0, 1.0, 0.5 - distance(uv, vec2(0.16, 0.22))) * 1.2;\n\n    \n    \n    fragColor = vec4(eye + reflection, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define PUPIL_RADIUS 0.1\n#define IRIS_RADIUS 0.45\n#define ALIASING 0.01\n\n\n#define POW2(x) x*x","name":"Common","description":"","type":"common"}]}