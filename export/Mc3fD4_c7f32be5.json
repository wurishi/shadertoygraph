{"ver":"0.1","info":{"id":"Mc3fD4","date":"1733182881","viewed":60,"name":"Fork Branchless Bearkirb 175","username":"BearKirb","description":"asdfasdfasd","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel"],"hasliked":0,"parentid":"4dX3zl","parentname":"Branchless Voxel Raycasting"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_RAY_STEPS = 512;\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(1.0);\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 0.0, -72.0);\n\tvec3 colAccum=vec3(0.0);\n    rayDir=normalize(rayDir);\n    vec3 sav1=rayPos;\n    vec3 sav2=rayDir;\n    Rotate(rayPos, vec2(-iMouse.x/iResolution.x*4.0,-iMouse.y/iResolution.y*2.0+1.0));\n    Rotate(rayDir, vec2(-iMouse.x/iResolution.x*4.0,-iMouse.y/iResolution.y*2.0+1.0));\n    rayDir=normalize(rayDir);\n    //Branchless DDA algorithm by fb39ca4 https://www.shadertoy.com/view/4dX3zl\n    \n    int i=0;\n   float mip=8.0;\n   \n\tivec3 mapPos = ivec3(rayPos);\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos)) * deltaDist; \n\t\n\tbvec3 mask;\n  \n\tfor(int i=0;i<MAX_RAY_STEPS;i++){\n    \n     if(distance(vec3(mapPos),rayPos)>120.0) break;\n    vec3 worldPos=vec3(vec3(mapPos)+vec3(CHUNKSIZE/2.0));\n    if(!(max(max(worldPos.x,worldPos.y),worldPos.z)>=CHUNKSIZE||min(min(worldPos.x,worldPos.y),worldPos.z)<0.0)){\n  \n\n\n    vec2 sampleLoc=xyzToUv(worldPos,mip);\n    vec4 dat=texelFetch(iChannel0,ivec2(sampleLoc),0);\n    if(dat.r>0.5){\n    \n    vec3 normal=vec3(mask)*sign(rayDir);\n    colAccum=vec3(dot(normal,rayDir))*vec3(float(i)/156.0,1.0-float(i)/156.0,0.0);\n   \n    break;\n    }\n\n}\n     mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\n    }\n\t\n\t\n    fragColor.rgb=colAccum;\n//fragColor.rgb=texelFetch(iChannel0,ivec2(fragCoord.xy),0).rgb;\n    fragColor.a=1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//256\n//64\n#define CHUNKSIZE 64.0\n#define SQRTCHUNK 512.0\n#define SOVERQ 8.0\n\n\nfloat getVoxel(vec3 c) {\nvec3 p=c;\nfloat len=length(p);\np=(p/64.0)*3.14159*2.0;\nreturn cos(p.x)*sin(p.y)+cos(p.y)*sin(p.z)+cos(p.z)*sin(p.x);\n\n}\n\nfloat vertexAo(vec2 side, float corner) {\n\t//if (side.x == 1.0 && side.y == 1.0) return 1.0;\n\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\n}\n\nvec4 voxelAo(vec3 pos, vec3 d1, vec3 d2) {\n\tvec4 side = vec4(getVoxel(pos + d1), getVoxel(pos + d2), getVoxel(pos - d1), getVoxel(pos - d2));\n\tvec4 corner = vec4(getVoxel(pos + d1 + d2), getVoxel(pos - d1 + d2), getVoxel(pos - d1 - d2), getVoxel(pos + d1 - d2));\n\tvec4 ao;\n\tao.x = vertexAo(side.xy, corner.x);\n\tao.y = vertexAo(side.yz, corner.y);\n\tao.z = vertexAo(side.zw, corner.z);\n\tao.w = vertexAo(side.wx, corner.w);\n\treturn 1.0 - ao;\n}\n\nvec2 xyzToUv(vec3 pos,float mip){\npos=floor(pos/mip)*mip;\nreturn vec2(pos.x+mod(pos.z,SOVERQ)*CHUNKSIZE,pos.y+floor(pos.z/SOVERQ)*CHUNKSIZE);\n}\nivec3 uvToXyz(vec2 uv){\nreturn ivec3(mod(uv.x,CHUNKSIZE),mod(uv.y,CHUNKSIZE),floor(uv.y/CHUNKSIZE)*SOVERQ+floor(uv.x/CHUNKSIZE));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    if(iFrame<1){\n    vec3 sav=vec3(uvToXyz(fragCoord.xy));\n    \n    fragColor.rgb=vec3(float(getVoxel(sav)));\n    \n    \n    }else{\n    fragColor.rgb=texture(iChannel0,fragCoord.xy/iResolution.xy).rgb;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}