{"ver":"0.1","info":{"id":"WdfGRl","date":"1547122664","viewed":269,"name":"Bubble fractal ","username":"JoshScholar","description":"scriptkiddying  Dave_Hoskins Space Jewels https://www.shadertoy.com/view/llX3zr Note the mouse moves up/down in/out - you get a pretty nice tour without touching the mouse (I recommend), but there are realms above and below you can only see with the mouse","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xtl3RM","filepath":"https://soundcloud.com/in-an-electronic-way-1/arrival","previewfilepath":"https://soundcloud.com/in-an-electronic-way-1/arrival","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// When I tried forking it, it never appeared on the page, so I'm forking by copying,\n// Joshua Scholar 1/10/2019\n// Space Jewels. December 2014\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/llX3zr\n\n//I realize that after playing with cross fading between iteration levels, changing\n//the path, messing with the shadow code, the only difference between the equation\n//of David Hoskins' Jewels and the bubbles is one line I deleted by accident.   I \n//I do have alternate equations that are cool but they make rather enclosed spaces\n//that are hard to tour.\n\n//Define REJEWEL to turn it from bubbles back into jewels. It is cool\n//If I were to turn that on and off, parts of the image would go back and forth\n//between being solid and being waving and ephemeral. \n//#define REJEWEL\n\n//--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(0.07, 0.05, 0.05)\n#define MOD2 vec2(443.8975,397.2973)\n\nvec3 CSize;\nvec4 aStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\n//----------------------------------------------------------------------------------------\n// From https://www.shadertoy.com/view/4djSRW\nfloat Hash(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p)\n{\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\t\t\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.z-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n\t\tfloat k = max((1.1)/(r2), .03);\n\t\tp *= k;\n\t}\n\treturn (0.5+0.5*sin(col*vec3(1.647,-1.0,4.9)));\n}\n\n//--------------------------------------------------------------------------\n\nvec4 initp(vec3 p)\n{\n    return vec4(p,1.0);\n}\n//p.w starts as 1.0\nvec4 Map1( vec4 p)\n{\n\t  p.xyz = 2.0*clamp(p.xyz, -CSize, CSize) - p.xyz;\n      //p.xyz = 1.5*vec3(mod(p.x+CSize.x, 2.*CSize.x)-CSize.x,mod(p.y+CSize.y,2.*CSize.y)-CSize.y,mod(p.z+CSize.z,2.*CSize.z)-CSize.z);\n\n\tfloat r2 = dot(p.xyz,p.xyz);\n\tfloat k = max((1.1)/(r2), .03);\n\tp.xyz     = p.xyz*k;\n#ifdef REJEWEL    \n    p.w *= k;\n#endif    \n    return p;\n//      return vec4(sqrt(abs(p.z*p.x))*sign(p.z*p.x),p.y,p.x,p.w*k);\n  //    return vec4(sqrt(abs(p.z*p.x))*sign(p.z*p.x),sqrt(abs(p.y*p.x))*sign(p.y*p.x),sqrt(abs(p.z*p.y))*sign(p.z*p.y),p.w*k);\n //   return vec4(p.z,p.y,p.x,p.w*k);\n}\nfloat p2v(vec4 p)\n{\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) / (length(p.xyz))-.1);\n\treturn (rxy) / abs(p.w);\n}\n\nfloat Map( vec3 ps, float level )\n{\n\tfloat scale = 1.0;\n\t\n//    float level = abs(mod(((iTime+10.)/15.+20.),40.)-20.);\n    int it = int(level);\n    float amount = level-float(it);\n    vec4 p = initp(ps);\n    vec4 d = vec4(1.0,1.0,1.0,1.0);\n    p=Map1(p);\n    p=Map1(p);\n\n    while (it-->=0) \n        p=Map1(p);\n/*    \n    switch (it){\n        case 15:\n    \tp=Map1(p);\n        case 14:\n    \tp=Map1(p);\n        case 13:\n    \tp=Map1(p);\n        case 12:\n    \tp=Map1(p);\n        case 11:\n    \tp=Map1(p);\n        case 10:\n    \tp=Map1(p);\n        case 9:\n    \tp=Map1(p);\n        case 8:\n    \tp=Map1(p);\n        case 7:\n    \tp=Map1(p);\n        case 6:\n    \tp=Map1(p);\n        case 5:\n    \tp=Map1(p);\n        case 4:\n    \tp=Map1(p);\n        case 3:\n    \tp=Map1(p);\n        case 2:\n    \tp=Map1(p);\n        case 1:\n    \tp=Map1(p);\n        case 0:\n        d=Map1(p);\n        break;\n        default:\n        amount=0.;\n    }\n*/\n     d=Map1(p);\n    //return p2v((1.0-amount)*p+amount*d);\n \treturn (1.0-amount)*p2v(p)+amount*p2v(d);   \n    //return p2v(p);\n}\n\nfloat Map(vec3 p)\n{\n     return Map(p,abs(mod(((iTime+10.)/15.+20.),40.)-20.));\n}\n\n//--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    float level = abs(mod(((iTime+10.)/15.+20.),40.)-20.);\n    int by= (20-int(level))/3;    \n    \n    //int by = int(iTime/26.)*3;\n    \n    for (int i = 0; i < 1+by; i++)\n\t{\n\t\th = Map( ro + rd*t, level );\n\t\tres = min(7.0*h / t, res);\n\t\tt += h+.01;\n\t}\n    return max(res, 0.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n    vec3 sunLight  = normalize( vec3(  0.5, 0.2,  0.3 ) );\n\tfloat sh = Shadow(pos,  sunLight);\n    // Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    //col += mat * vec3(0.1, .0, .0)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 25.0)  * SUN_COLOUR * 1.5 *sh;\n    // Abmient..\n    col += mat * .2 * max(normal.z, 0.0);\n    col = mix(FOG_COLOUR,col, min(exp(-d*d*.05), 1.0));\n    \n\treturn col;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR*.5, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n//--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n\tif (t< 1.4) t= (1.4-t) * 4.5;\n\tt = t*0.04;\n\treturn max(t*t, 16.0/iResolution.x);\n}\n\n//--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n    //float t = 0.0;\n\tfloat t = .1 * Hash(fcoord*fract(iTime));\n\tfloat  alphaAcc = 0.0;\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (hits == 8 || alphaAcc >= 1.0 || t > 10.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n        // Is it within the sphere?...\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t// Accumulate the alphas with the scoop of geometry from the sphere...\n            // Think of it as an expanding ice-cream scoop flying out of the camera! \n\t\t\tfloat alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);\n\t\t\t// put it on the 2 stacks, alpha and distance...\n\t\t\taStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;\n\t\t\taStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;\n\t\t\tdStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;\n\t\t\tdStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n\t\t\talphaAcc += alpha;\n\t\t\thits++;\n\t\t}\n\t\tt +=  h*.85+t*.001;\n        \n\t}\n\t\n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t// Then...\n\t#define CONTRAST 1.3\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t// Vignette...\n\trgb *= .5+0.5*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel0, pos*.1, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t, float inward )\n{\n    vec3 p = inward*vec3(-2.9 +2.5 * sin(t),-3.8+5.0 * cos(t),-1.94+2.2 * sin(1.3*t+2.0) );\n\treturn p;\n} \n    \n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x/iResolution.x);\n\tfloat n = ((iMouse.y-iResolution.y)/iResolution.y+.5)*20.0;\n    \n\tfloat gTime = ((iTime+26.)*.12);\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n    // Animate...\n    CSize = vec3(.808, .99-sin((gTime+35.0)*.5)*.3, 1.151-sin((gTime+16.0)*.78)*.3);\n\t\n\tvec3 cameraPos \t= CameraPath(gTime*.3 + 0.0, 2.*(m-.5))+vec3(0.,0.,n);\n\tvec3 camTarget \t= vec3 (-12., .0, -2.0);\n\n\tvec3 cw = normalize(camTarget-cameraPos);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\n\tvec3 col = vec3(.0);\n\t\n    for (int i = 0; i <2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n    }\n\tfloat alpha = Scene(cameraPos, dir);\n\t\n    \n    // Render both stacks...\n    for (int s = 0; s < 2; s++)\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            float d = dStack[s][i];\n            if (d < 0.0) continue;\n            float sphereR = SphereRadius(d);\n            vec3 pos = cameraPos + dir * d;\n            vec3 normal = GetNormal(pos, sphereR);\n            vec3 alb = Albedo(pos, normal);\n            col += DoLighting(alb, pos, normal, dir, d)* aStack[s][i];\n        }\n    }\n    // Fill in the rest with fog...\n   col += FOG_COLOUR *  (1.0-alpha);\n   \n   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------","name":"Image","description":"","type":"image"}]}