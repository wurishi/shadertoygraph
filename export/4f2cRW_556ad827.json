{"ver":"0.1","info":{"id":"4f2cRW","date":"1722139784","viewed":78,"name":"Occluded Point Lights - DnD Map","username":"dansh0","description":"Using my other demo to show a use case of a DnD-style map\nLights and wall segments are stored in buffers\n\nDrag mouse to move one of the bigger lights","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["lighting","occlusion","radiance","los","dnd","ttg","ttrpg","vtt"],"hasliked":0,"parentid":"4c2yzh","parentname":"Occluded Point Lights"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Demo of lights and walls\n// Buffer A has light data (x, y, radius, color)\n// Buffer B has wall data (x1, y1, x2, y2)\n// Lights are tested against walls for intersections\n// Non-occluded lights are drawn over background texture\n// Walls are drawn on top\n\n// CONTROL:\n// Mouse moves one of the lights\n\nvec3 hueToRGB(float hue) {\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // From IQ - https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nbool lineIntersect(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 s1 = p1 - p0;\n    vec2 s2 = p3 - p2;\n    float s = (-s1.y * (p0.x - p2.x) + s1.x * (p0.y - p2.y)) / (-s2.x * s1.y + s1.x * s2.y);\n    float t = ( s2.x * (p0.y - p2.y) - s2.y * (p0.x - p2.x)) / (-s2.x * s1.y + s1.x * s2.y);\n    return (s >= 0. && s <= 1. && t >= 0. && t <= 1.);\n}\n\nfloat isOccludedSoft(vec2 lightPos, vec2 fragPos, vec4 line, float softness) {\n    const int samples = 1;\n    float occlusion = 0.0;\n    vec2 offset[samples];\n    \n    for (int i = 0; i < samples; i++) {\n        float angle = float(i) * 6.283185 / float(samples);\n        offset[i] = vec2(cos(angle), sin(angle)) * softness;\n    }\n    \n    for (int i = 0; i < samples; i++) {\n        vec2 samplePos = fragPos + offset[i];\n        if (lineIntersect(lightPos, samplePos, line.xy, line.zw)) {\n            occlusion += 1.0;\n        }\n    }\n    \n    return occlusion / float(samples);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Paras\n    float lineWidth = 0.005;\n    vec3 lineColor = vec3(0.5, 0.3, 0.3);\n    float softness = 0.01;\n    vec3 bgndColor = vec3(0.2);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uvAdjust = vec2((iResolution.x-iResolution.y)/iResolution.x, 0.);\n    uv -= uvAdjust;\n    \n    // Sample light count and light data from Buffer A\n    int lightCount = int(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    \n    // Sample line segment count and line segment data from Buffer B\n    int lineCount = int(texelFetch(iChannel1, ivec2(0, 0), 0).x);\n    \n    // Sample line segment data\n    vec4 lineSegments[40];\n    for (int i = 0; i < lineCount; i++) {\n        vec4 lineSegment = texelFetch(iChannel1, ivec2(i + 1, 0), 0);\n        lineSegment.xz = lineSegment.xz*aspect - vec2(uvAdjust.x);\n        lineSegments[i] = lineSegment;\n    }\n    \n    // Background\n    vec3 col = bgndColor;\n    vec2 ssUV = fragCoord/iResolution.xy;\n    vec3 bgndTex = texture(iChannel2, uv).rgb;\n    vec3 outsideTex = texture(iChannel3, uv).rgb;\n    vec2 inner = step(0.1, ssUV) - step(0.9, ssUV);\n    vec3 background = mix(outsideTex, bgndTex, min(inner.x, inner.y));\n\n    // Iterate over each light\n    for (int i = 0; i < lightCount; i++) {\n        vec4 light = texelFetch(iChannel0, ivec2(i + 1, 0), 0);\n        \n        // update over time\n        light.xy += 0.01*sin(light.zw*iTime/1.);\n        \n        // Update mouse light position\n        if (i == 19) {\n            light.xy = iMouse.xy/iResolution.xy;\n        }\n        \n        light.x = light.x*aspect - uvAdjust.x;\n        \n        // SDF\n        float dist = distance(uv, light.xy);\n        float sdf = dist - light.z;\n        \n        if (sdf < 0.) {\n            // find occlusion with walls\n            float occlusion = 0.0;\n            for (int j = 0; j < lineCount; j++) {\n                if (udSegment(light.xy, lineSegments[j].xy, lineSegments[j].zw) < light.z) {\n                    occlusion += isOccludedSoft(light.xy, uv, lineSegments[j], softness);\n                }\n            }\n            occlusion = min(1., occlusion);\n\n            // Solve color\n            vec3 colLight = vec3(0.7) + 0.2*hueToRGB(light.w);\n            col = mix(col, 2.0*colLight * (1.0 - occlusion), smoothstep(0.0, 1.0, -sdf / light.z));\n        }\n    }\n    \n    // Lights + Albedo\n    col *= background;\n     \n    // Wall rendering\n    for (int i = 0; i < lineCount; i++) {\n        float sdfWall = udSegment(uv, lineSegments[i].xy, lineSegments[i].zw) - lineWidth;\n        col = mix(col, lineColor, smoothstep(0.0, 1.0, 1.0 - (sdfWall / lineWidth)));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Light data storage with prescribed light positions for a DnD map\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int lightCount = 20; // Total number of lights\n\n    vec4 lightData[21]; // Array to store light count and light data\n    lightData[0] = vec4(float(lightCount), 0.0, 0.0, 0.0); // Store the count in the first texel\n\n    // Prescribed light positions with a buffer away from the walls\n    float buffer = 0.02;\n    float lightRad = 0.15;\n\n    lightData[1] = vec4(0.1 + buffer, 0.1 + buffer, lightRad, 0.4);        \n    lightData[2] = vec4(0.5  - buffer, 0.1 + buffer, lightRad, 0.7);           \n    lightData[3] = vec4(0.9 - buffer, 0.1 + buffer, lightRad, 0.5);  \n    lightData[4] = vec4(0.1 + buffer, 0.6 - buffer, lightRad, 0.9);           \n    lightData[5] = vec4(0.9 - buffer, 0.5 - buffer, lightRad, 0.2);     \n    lightData[6] = vec4(0.1 + buffer, 0.9 - buffer, lightRad, 0.5);  \n    lightData[7] = vec4(0.5 - buffer, 0.9 - buffer, lightRad, 0.6);     \n    lightData[8] = vec4(0.9 - buffer, 0.9 - buffer, lightRad, 0.7);\n    lightData[9] = vec4(0.3 + buffer, 0.1 + buffer, lightRad, 0.8);\n    lightData[10] = vec4(0.7 - buffer, 0.1 + buffer, lightRad, 0.9);\n    lightData[11] = vec4(0.3 + buffer, 0.9 - buffer, lightRad, 0.3);\n    lightData[12] = vec4(0.7 - buffer, 0.7 - buffer, lightRad, 0.1);\n    lightData[13] = vec4(0.5 + buffer, 0.2 + buffer, lightRad, 0.2);\n    lightData[14] = vec4(0.6 - buffer, 0.2 + buffer, lightRad, 0.3);\n    lightData[15] = vec4(0.2 + buffer, 0.8 - buffer, lightRad, 0.4);\n    lightData[16] = vec4(0.8 - buffer, 0.8 - buffer, lightRad, 0.5);\n    lightData[17] = vec4(0.3 + buffer, 0.5 + buffer, lightRad, 0.6);\n    lightData[18] = vec4(0.6 - buffer, 0.5 + buffer, lightRad, 0.7);\n    lightData[19] = vec4(0.4 + buffer, 0.6, lightRad, 0.8);\n    lightData[20] = vec4(0.8 - buffer, 0.4 - buffer, 2.*lightRad, 0.6);\n\n    // Get the current index based on the fragment coordinate\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n\n    if (index < lightCount + 1) {\n        fragColor = lightData[index];\n    } else {\n        fragColor = vec4(0.0); // Default value for unused texels\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: Line segment data storage with prescribed line segments for a DnD-style map\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int lineCount = 50; // Total number of line segments\n\n    vec4 lineData[51]; // Array to store line count and line segment data\n    lineData[0] = vec4(float(lineCount), 0.0, 0.0, 0.0); // Store the count in the first texel\n\n    // Map line segments\n    lineData[1] = vec4(0.1, 0.1, 0.9, 0.1);\n    lineData[2] = vec4(0.9, 0.1, 0.9, 0.9);\n    lineData[3] = vec4(0.9, 0.9, 0.1, 0.9);\n    lineData[4] = vec4(0.1, 0.9, 0.1, 0.1);\n    lineData[5] = vec4(0.3, 0.1, 0.3, 0.7);\n    lineData[6] = vec4(0.3, 0.7, 0.6, 0.7);\n    lineData[7] = vec4(0.6, 0.7, 0.6, 0.1);\n    lineData[8] = vec4(0.4, 0.1, 0.4, 0.5);\n    lineData[9] = vec4(0.4, 0.5, 0.5, 0.5);\n    lineData[10] = vec4(0.5, 0.5, 0.5, 0.1);\n    lineData[11] = vec4(0.2, 0.8, 0.4, 0.8);\n    lineData[12] = vec4(0.4, 0.8, 0.4, 0.6);\n    lineData[13] = vec4(0.4, 0.6, 0.2, 0.6);\n    lineData[14] = vec4(0.2, 0.6, 0.2, 0.8);\n    lineData[15] = vec4(0.3, 0.9, 0.35, 0.9);\n    lineData[16] = vec4(0.6, 0.1, 0.65, 0.1);\n    lineData[17] = vec4(0.7, 0.2, 0.8, 0.2);\n    lineData[18] = vec4(0.8, 0.2, 0.8, 0.3);\n    lineData[19] = vec4(0.8, 0.3, 0.7, 0.3);\n    lineData[20] = vec4(0.7, 0.3, 0.7, 0.2);\n    lineData[21] = vec4(0.5, 0.6, 0.55, 0.6);\n    lineData[22] = vec4(0.55, 0.6, 0.55, 0.65);\n    lineData[23] = vec4(0.55, 0.65, 0.5, 0.65);\n    lineData[24] = vec4(0.5, 0.65, 0.5, 0.6);\n    lineData[25] = vec4(0.1, 0.4, 0.2, 0.4);\n    lineData[26] = vec4(0.2, 0.4, 0.2, 0.5);\n    lineData[27] = vec4(0.2, 0.5, 0.1, 0.5);\n    lineData[28] = vec4(0.1, 0.5, 0.1, 0.4);\n    lineData[29] = vec4(0.7, 0.8, 0.8, 0.8);\n    lineData[30] = vec4(0.8, 0.8, 0.8, 0.9);\n    lineData[31] = vec4(0.8, 0.9, 0.7, 0.9);\n    lineData[32] = vec4(0.7, 0.9, 0.7, 0.8);\n    lineData[33] = vec4(0.4, 0.2, 0.45, 0.2);\n    lineData[34] = vec4(0.45, 0.2, 0.45, 0.25);\n    lineData[35] = vec4(0.45, 0.25, 0.4, 0.25);\n    lineData[36] = vec4(0.4, 0.25, 0.4, 0.2);\n    lineData[37] = vec4(0.15, 0.6, 0.2, 0.6);\n    lineData[38] = vec4(0.2, 0.6, 0.2, 0.65);\n    lineData[39] = vec4(0.2, 0.65, 0.15, 0.65);\n    lineData[41] = vec4(0.15, 0.65, 0.15, 0.6);\n    lineData[42] = vec4(0.75, 0.4, 0.8, 0.4);\n    lineData[43] = vec4(0.8, 0.4, 0.8, 0.45);\n    lineData[44] = vec4(0.8, 0.45, 0.75, 0.45);\n    lineData[45] = vec4(0.75, 0.45, 0.75, 0.4);\n    lineData[46] = vec4(0.55, 0.8, 0.6, 0.8);\n    lineData[47] = vec4(0.6, 0.8, 0.6, 0.85);\n    lineData[48] = vec4(0.6, 0.85, 0.55, 0.85);\n    lineData[49] = vec4(0.55, 0.85, 0.55, 0.8); \n\n    // Get the current index based on the fragment coordinate\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n\n    if (index < lineCount + 1) {\n        fragColor = lineData[index];\n    } else {\n        fragColor = vec4(0.0); // Default value for unused texels\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}