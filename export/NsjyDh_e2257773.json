{"ver":"0.1","info":{"id":"NsjyDh","date":"1643938709","viewed":112,"name":"Raycasting Reflections +","username":"Rugged","description":"Raycaster with reflections and Diffractions. The light diffracts through ball 3 (orbiting the middle two).","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ballL vec3(0., 0., 0.)\n//#define ballR 1.\n//#define ballC vec4(.5, 0., .5, 0.)\n\n#define floorH 0.\n#define floorC vec4(0., .6, 0., 1.)\n\n//#define camL vec3(5., 0., 3.)\n\n#define pi 3.1415\n\nvec3 quaternionVectorRotation(vec3 v, vec4 q){\n    vec3 rowOne = vec3(1. - (2. * ((q.z * q.z) + (q.w * q.w))), 2.* ((q.y * q.z) - (q.x * q.y)), 2. * ((q.x * q.z) + (q.y * q.w)));\n    vec3 rowTwo = vec3(2. * ((q.y * q.z) + (q.x * q.w)), 1. - (2. * ((q.y * q.y) + (q.w * q.w))), 2. * ((q.y * q.z) + (q.x * q.w)));\n    vec3 rowThree = vec3(2. * ((q.y * q.w) - (q.x * q.z)), 2. * ((q.x * q.y) + (q.z * q.w)), 1. - (2. * ((q.y * q.y) + (q.z * q.z))));\n    \n    mat3 r = mat3(rowOne, rowTwo, rowThree);\n    return r * v;\n}\n\nvec4 quaternionMult(vec4 a, vec4 b){\n    return vec4(a.x * b.x - dot(a.yzw, b.yzw), a.x*b.yzw + b.x*a.yzw + cross(a.yzw, b.yzw));\n}\n\n\n\n\n\nvec3 ray1(vec3 rayO, vec3 rayDV, vec3 ballL, float ballR){\n    //scaled vector from camera to ball\n    vec3 abc = rayO - ballL;\n    \n    float alpha = dot(rayDV, rayDV);//(rayDV.x * rayDV.x) + (rayDV.y * rayDV.y) + (rayDV.z * rayDV.z);\n    float beta = 2. * dot(rayDV, abc);//((camL.x * abc.x) + (camL.y * abc.y) + (camL.z * abc.z));\n    float gamma = dot(abc, abc) - (ballR * ballR);\n    \n    float discrim = (beta * beta) - (4. * alpha * gamma);\n    \n    float t = (-beta - sqrt(discrim)) / (2. * alpha);\n    \n    vec3 p = (rayDV * t ) + rayO;\n    \n    float d = distance(rayO, p);\n    \n    return vec3((discrim / abs(discrim) + 1.) / 2., t, d);//(rayDV * t) + camL;\n}\n\nvec3 ray1Internal(vec3 rayO, vec3 rayDV, vec3 ballL, float ballR){\n    //scaled vector from camera to ball\n    vec3 abc = rayO - ballL;\n    \n    float alpha = dot(rayDV, rayDV);//(rayDV.x * rayDV.x) + (rayDV.y * rayDV.y) + (rayDV.z * rayDV.z);\n    float beta = 2. * dot(rayDV, abc);//((camL.x * abc.x) + (camL.y * abc.y) + (camL.z * abc.z));\n    float gamma = dot(abc, abc) - (ballR * ballR);\n    \n    float discrim = (beta * beta) - (4. * alpha * gamma);\n    \n    float t = (-beta + sqrt(discrim)) / (2. * alpha);\n    \n    vec3 p = (rayDV * t ) + rayO;\n    \n    float d = distance(rayO, p);\n    \n    return vec3((discrim / abs(discrim) + 1.) / 2., t, d);//(rayDV * t) + camL;\n}\n\nvec3 rayFloor(vec3 rayDV, vec3 rayO){\n    float t = -(rayO.z - floorH) / rayDV.z;\n    vec3 p = (rayDV * t )+ rayO;\n    \n    float d = distance(rayO, p);\n    \n    return vec3(-rayDV.z / abs(rayDV.z), t, d);\n}\n\n\nvec3 generateReflectionVector(vec3 normal, vec3 inV){\n    return inV - (2. * normal);\n}\n\nvec3 generateDiffractionVector(vec3 normal, vec3 inV){\n    return inV + (2. * normal);\n}\n\n\n\n\n\n\nvec4 ballR(vec4 col, vec3 rayO, vec3 rayD, vec3 otherBallL, float otherBallR, vec4 otherBallC){\n    vec4 newCol = col;\n    \n    //ball # 1 ray casting\n    vec3 hit = ray1(rayO, rayD, otherBallL, otherBallR);\n    \n    //ball one reflections\n    vec3 sphereInt = (hit.y * rayD) + rayO;\n    \n    vec3 reflD = generateReflectionVector(normalize(otherBallL - sphereInt), rayD);\n    \n    vec3 newFloorHit = rayFloor(reflD, sphereInt);\n    \n    vec3 newFloorHitInt = (newFloorHit.y * reflD) + sphereInt;\n    \n    vec3 newHit = ray1(sphereInt, reflD, otherBallL, otherBallR);\n    \n    //color mixing for ball one\n    \n    if((newHit.z < newFloorHit.z || newFloorHit.y < 0.) && newHit.y > 0.){\n        newCol = mix(newCol, otherBallC, .6);\n    }\n    else if(newFloorHit.y > 0.){\n        newCol = mix(newCol, texture(iChannel1, newFloorHitInt.xy / iResolution.xy), .6);\n    }\n    else if(hit.y > 0.){\n        newCol = mix(newCol, vec4(0.), .6);\n    }\n    \n    return newCol;\n    \n}\n/*\nvec4 ball2(vec3 rayO, vec3 rayD, vec3 otehrBallL, float otherBallR, vec4 otherBallC){\n    vec4 newCol = vec4(0.);\n    \n    //ball # 2\n    vec3 hitTwo = ray1(camL, rayD, ballTwoL, ballTwoR);\n    \n    //ball two reflections\n    vec3 sphereTwoInt = (hitTwo.y * rayD) + camL;\n    \n    vec3 reflTwoD = generateReflectionVector(normalize(ballTwoL - sphereTwoInt), rayD);\n    \n    vec3 newFloorHitTwo = rayFloor(reflTwoD, sphereTwoInt);\n    \n    vec3 newFloorHitTwoInt = (newFloorHitTwo.y * reflTwoD) + sphereTwoInt;\n    \n    vec3 newHitTwo = ray1(sphereTwoInt, reflTwoD, ballOneL, ballOneR);\n    \n    //color mixing for ball two\n    \n    if((newHitTwo.z < newFloorHitTwo.z || newFloorHitTwo.y < 0.) && newHitTwo.y > 0.){\n        newCol = mix(newCol, ballOneC, .6);\n    }\n    else if(newFloorHitTwo.y > 0.){\n        newCol = mix(newCol, texture(iChannel1, newFloorHitTwoInt.xy / iResolution.xy), .6);\n    }\n    else if(hitTwo.y > 0.){\n        newCol = mix(newCol, vec4(0.), .6);\n    }\n    \n    return newCol;\n}\n\nvec4 ball3(vec3 rayO, vec3 rayD, vec3 otherBallL, float otherBallR, vec4OtherBallC){\n    vec4 newCol = vec4(0.);\n    \n    //ball # 3\n    vec3 hitThree = ray1(camL, rayD, ballThreeL, ballThreeR);\n    \n    //ball three diffractions\n    //add .1 to t here so that the intersection wont be on the edge of the sphere as we are going to ray trace this spehere again for diffractions\n    vec3 sphereThreeInt = ((hitThree.y + .1) * rayD) + camL;\n    \n    vec3 difrThreeD = generateDiffractionVector(normalize(ballThreeL - sphereThreeInt), rayD);\n    \n    //vec3 reflThreeD = generateReflectionVector(normalize(ballThreeL - sphereThreeInt), rayD);\n    \n    //now we have to do an internal ray trace to see where the ray hits the inside of the ray\n    hitThree = ray1Internal(sphereThreeInt, difrThreeD, ballThreeL, ballThreeR);\n    //get the new place where the ray will exit\n    sphereThreeInt = (hitThree.y * difrThreeD) + sphereThreeInt;\n    //light diffracts again as it exits\n    difrThreeD = generateDiffractionVector(normalize(ballThreeL - sphereThreeInt), difrThreeD);\n    \n    vec3 newFloorHitThree = rayFloor(difrThreeD, sphereThreeInt);\n    \n    vec3 newFloorHitThreeInt = (newFloorHitThree.y * difrThreeD) + sphereThreeInt;\n    \n    vec3 newHitThree = ray1(sphereThreeInt, difrThreeD, ballTwoL, ballTwoR);\n    \n    //color mixing for ball three\n    \n    if((newHitThree.z < newFloorHitThree.z || newFloorHitThree.y < 0.) && newHitThree.y > 0.){\n        newCol = mix(newCol, ballOneC, .9);\n    }\n    else if(newFloorHitThree.y > 0.){\n        newCol = mix(newCol, texture(iChannel1, newFloorHitThreeInt.xy / iResolution.xy), .9);\n    }\n    else if(hitThree.y > 0.){\n        newCol = mix(newCol, vec4(0.), .9);\n    }\n    \n    return newCol;\n}\n\n*/\n\n\n\n\n\n\n\n\nvec3 ray2(vec3 rayO, vec3 camDV, vec3 rayDV, vec3 ballL, float ballR){\n    vec3 beta = rayO - ballL;\n    \n    vec3 r3 = vec3(ballR);\n    \n    //float t = (r3 - beta) / camDV;\n    float t = 0.;\n    return vec3((t * rayDV) + rayO); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.35);\n    \n    vec3 camL =  vec3(6., 0., 8.);//vec3(5. + cos(iTime), cos(iTime), 3. + sin(iTime));\n    \n    vec4 col = vec4(.5, .5, 1., 1.);\n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi =  radians(360. * (1.- muv.x));\n    float theta = radians(180. * (1. - muv.y));\n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    float rad90 = radians(90.);\n    \n    float fov = 110.;\n    \n    float xAng = radians(fov * (.5 - uv.x));\n    //replace \"fov\" with \"(fov + (110. * pow(.5 - uv.x, 2.)))\" below to add a counteractment to the fisheye lens effect\n    //it basically counteracts the artifact with quaternions that happens when you rotate by a large angle on one axis then try to rotate on another axis perpendicular, it just rotates around it thus making the new direction lesser\n    float yAng = radians(fov * screenRatio * (.5 - uv.y));\n    \n    //get the axes that the quarternions should be based around (perpendicular to the camera plane or dv)\n    vec3 xRotAxis = vec3(cos(phi) * sin(theta - rad90), sin(phi) * sin(theta - rad90), cos(theta - rad90));\n    vec3 yRotAxis = cross(xRotAxis, camD.yzw);//vec3(cos(phi - rad90) * sin(theta), sin(phi - rad90) * sin(theta), cos(theta));\n    \n    //get the quarternions of the ray direction rotations\n    vec4 xQuat = vec4(cos(xAng / 2.), xRotAxis * sin(xAng / 2.));\n    vec4 yQuat = vec4(cos(yAng / 2.), yRotAxis * sin(yAng / 2.));\n    \n    \n    \n    //combine the rotations\n    vec4 compQuat = quaternionMult(yQuat, xQuat);\n    \n    \n    \n    //get the conjugate of the compQuart\n    vec4 conjComp = vec4(compQuat.x, -compQuat.yzw);\n\n    \n    //ray direction\n    vec3 rayD = quaternionMult(quaternionMult(compQuat, camD), conjComp).yzw;\n    \n    \n    //############################################\n    \n    \n    vec3 ballOneL = vec3(0., 0., 3. * cos(iTime) + 4.);//vec3(0., 0., -3. + iTime);\n    vec4 ballOneC = vec4(0.26, 0.27, 0.29, 1.);\n    float ballOneR = 1.;\n    \n    vec3 ballTwoL = vec3(0., 3. * sin(iTime) + cos(iTime), 4.);\n    vec4 ballTwoC = vec4(.8, .3, 0., 0.);\n    float ballTwoR = 1.;\n    \n    vec3 ballThreeL = vec3(-2. * cos(iTime), sin(iTime) * 6., 5.);\n    vec4 ballThreeC = vec4(1.);\n    float ballThreeR = 1.;\n    \n    \n    \n    //First raycast\n    \n    \n    //vec3 hitL = ray1(camD, o);\n    \n    //ball # 1 ray casting\n    vec3 hit = ray1(camL, rayD, ballOneL, ballOneR);\n    \n    //floor ray casting\n    vec3 floorHit = rayFloor(rayD, camL);\n    \n    \n    //ball # 2\n    vec3 hitTwo = ray1(camL, rayD, ballTwoL, ballTwoR);\n    \n    \n    //ball # 3\n    vec3 hitThree = ray1(camL, rayD, ballThreeL, ballThreeR);\n    \n    \n    //float floorOrBall = (1. + ((floorHit.y - hit.y) / abs(floorHit.y - hit.y))) / 2.; \n    \n    vec3 floorInt = (floorHit.y * rayD) + camL;\n    \n    \n    if((hit.z < floorHit.z || floorHit.y < 0.) && hit.y > 0.){\n        col = ballOneC;\n    }\n    else if((hitTwo.z < floorHit.z || floorHit.y < 0.) && hitTwo.y > 0.){\n        col = ballTwoC;\n    }\n    else if((hitThree.z < floorHit.z || floorHit.y < 0.) && hitThree.y > 0.){\n        col = ballThreeC;\n    }\n    else{\n        col = texture(iChannel1, floorInt.xy / iResolution.xy) * floorHit.x;\n    }\n    \n    \n    \n    \n    \n    \n    //Reflection raycasts\n    \n    \n    //floor new ray direction\n    vec3 newRayD = generateReflectionVector(vec3(0., 0., 1.), rayD);\n    //vec3 newFloorHit = ray1(floorInt, newRayD, ballOneL, ballOneR);\n\n    /*\n    //ball one reflections\n    vec3 sphereInt = (hit.y * rayD) + camL;\n    \n    vec3 reflD = generateReflectionVector(normalize(ballOneL - sphereInt), rayD);\n    \n    vec3 newFloorHit = rayFloor(reflD, sphereInt);\n    \n    vec3 newFloorHitInt = (newFloorHit.y * reflD) + sphereInt;\n    \n    vec3 newHit = ray1(sphereInt, reflD, ballTwoL, ballTwoR);\n    */\n\n    //ball two reflections\n    vec3 sphereTwoInt = (hitTwo.y * rayD) + camL;\n    \n    vec3 reflTwoD = generateReflectionVector(normalize(ballTwoL - sphereTwoInt), rayD);\n    \n    vec3 newFloorHitTwo = rayFloor(reflTwoD, sphereTwoInt);\n    \n    vec3 newFloorHitTwoInt = (newFloorHitTwo.y * reflTwoD) + sphereTwoInt;\n    \n    vec3 newHitTwo = ray1(sphereTwoInt, reflTwoD, ballOneL, ballOneR);\n    \n    \n    //ball three diffractions\n    //add .1 to t here so that the intersection wont be on the edge of the sphere as we are going to ray trace this spehere again for diffractions\n    vec3 sphereThreeInt = ((hitThree.y + .1) * rayD) + camL;\n    \n    vec3 difrThreeD = generateDiffractionVector(normalize(ballThreeL - sphereThreeInt), rayD);\n    \n    //vec3 reflThreeD = generateReflectionVector(normalize(ballThreeL - sphereThreeInt), rayD);\n    \n    //now we have to do an internal ray trace to see where the ray hits the inside of the ray\n    hitThree = ray1Internal(sphereThreeInt, difrThreeD, ballThreeL, ballThreeR);\n    //get the new place where the ray will exit\n    sphereThreeInt = (hitThree.y * difrThreeD) + sphereThreeInt;\n    //light diffracts again as it exits\n    difrThreeD = generateDiffractionVector(normalize(ballThreeL - sphereThreeInt), difrThreeD);\n    \n    vec3 newFloorHitThree = rayFloor(difrThreeD, sphereThreeInt);\n    \n    vec3 newFloorHitThreeInt = (newFloorHitThree.y * difrThreeD) + sphereThreeInt;\n    \n    vec3 newHitThree = ray1(sphereThreeInt, difrThreeD, ballTwoL, ballTwoR);\n    \n    \n    \n    /*\n    //color mixing for ball one\n    \n    if((newHit.z < newFloorHit.z || newFloorHit.y < 0.) && newHit.y > 0.){\n        col = mix(col, ballTwoC, .6);\n    }\n    else if(newFloorHit.y > 0.){\n        col = mix(col, texture(iChannel1, newFloorHitInt.xy / iResolution.xy), .6);\n    }\n    else if(hit.y > 0.){\n        col = mix(col, vec4(0.), .6);\n    }\n    */\n    \n    //color mixing for ball two\n    \n    if((newHitTwo.z < newFloorHitTwo.z || newFloorHitTwo.y < 0.) && newHitTwo.y > 0.){\n        col = mix(col, ballOneC, 1.);\n    }\n    else if(newFloorHitTwo.y > 0.){\n        col = mix(col, texture(iChannel1, newFloorHitTwoInt.xy / iResolution.xy), 1.);\n    }\n    else if(hitTwo.y > 0.){\n        col = mix(col, vec4(0.), 1.);\n    }\n    \n    \n    //color mixing for ball three\n    \n    \n    if((newHitThree.z < newFloorHitThree.z || newFloorHitThree.y < 0.) && newHitThree.y > 0.){\n        col = mix(col, ballOneC, .9);\n    }\n    else if(newFloorHitThree.y > 0.){\n        col = mix(col, texture(iChannel1, newFloorHitThreeInt.xy / iResolution.xy), .9);\n    }\n    else if(hitThree.y > 0.){\n        col = mix(col, vec4(0.), .9);\n    }\n    \n    \n    \n    col = ballR(col, camL, rayD, ballOneL, ballOneR, ballTwoC);\n    //col = ballR(col, \n    //col = mix(col, vec4(0.), .4);\n    //col = vec4(floorHit.z);\n    fragColor = col;//hit.x * vec4(1.) * (1. + floorOrBall) + (floorHit.x * floorC * floorOrBall);\n}","name":"Image","description":"","type":"image"}]}