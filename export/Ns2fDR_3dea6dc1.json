{"ver":"0.1","info":{"id":"Ns2fDR","date":"1646041546","viewed":113,"name":"Island_C","username":"dragonyhr","description":"island","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["island"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// global parameters for users\n#define pi (3.1415926)\n#define globalSeed (13344.3415926)\n\nfloat main_island_radius=500.;\nvec2 beach_length_min_max = vec2(240.,550.);\nvec2 coast_cliff_length_min_max = vec2(10.,220.);\nvec3 coast_cliff_main_large_detail_noise_scale = vec3(0.004,0.005,0.05);\nfloat coast_cliff_main_large_detail_noise_amplifier = 3.5;\n\nint mountain_account=4;\nvec2 mountain_radius_min_max = vec2(100.,350.);\nvec3 mountain_main_large_detail_noise_scale = vec3(0.01,0.03,0.05);\nfloat mountain_noise_amplifier = 4.5;\nvec2 rand_poses [5] = vec2[5](vec2(.0,.0),vec2(.0,.0),vec2(.0,.0),vec2(.0,.0),vec2(.0,.0));\nvec3 platform_noise_scale = vec3(0.01,0.03,0.05);\n\nfloat maskes [5] = float[5] (0.2,0.0,0.0,0.0,0.0);\nfloat foliageMaskes [5] = float[5] (0.2,0.0,0.0,0.0,0.0);\nfloat clamp_value [5] =float[5] (0.0,0.0,0.0,0.0,0.0);\nfloat platforms [5] = float[5] (0.0,0.0,0.0,0.0,0.0);\n\n\n\n\n///////////--------noise----------//////////////\n\nfloat _z =1.;\nvec2 hash22( vec2 x ) \n{\n    float s = 0.;                      // standard Perlin noise\n    const vec2 k = vec2( .3183099, .3678794 );\n    x = x*k + k.yx + 5.;\n    return ( -1. + 2.*fract( 16. * k*fract( x.x*x.y*(x.x+x.y)) ) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y) dot( hash22( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\n\nfloat perlin( vec2 p)  //fractal noise\n{\t\n    float _z =1.;\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n   \n    for( int i=0; i < 4; i++, s /= 2. ) { _z = s; // for flownoise\n        v += s*noise( p ); p *= m;\n    }\n    v*= 1.1;\n    return v;\n}\n///////////--------noise-----//////////////\n\nfloat remap01(float value, vec2 range)\n{\n    float min = range.x;\n    \n    float max = range.y;\n    max = max-min;\n    float va = value - min;\n    return va*(1./max);\n\n}\n\n\n\nfloat Get_Mask(float height)\n{\n    \n    return ceil(clamp(height,0.,1.));\n}\n\nfloat Draw_A_Circle(vec2 center,vec2 pos,float radius)\n{\n    float circle_mask = 0.;\n    circle_mask = (radius-distance(pos,center))/radius;\n    return circle_mask;\n\n}\n\nvec2 Get_Point_At_Circle(vec2 center,float radius_length,float radian)\n{\n    float x =cos(radian)*radius_length+center.x;\n    float y = sin(radian)*radius_length+center.y;\n    return vec2(x,y);\n\n}\n\nfloat Random_Value(float seeed, float min,float max)\n{\n    float rand = fract(sin(globalSeed+seeed) * 43758.5453123);\n    float range = (max-min)*rand+min;\n    return range;\n    \n\n}\n\nfloat Draw_Island(vec2 p,vec2 center,float radius,vec3 noise_scale,float distortDistance)\n{\n     float main_p_scale = noise_scale.x;\n     float large_p_scale = noise_scale.y;\n     float detail_p_scale = noise_scale.z;\n     \n     float noise1 = 0.;\n     noise1 += noise(p*main_p_scale);\n     noise1 += noise(p*large_p_scale)*0.25;//\n     radius += noise1*distortDistance;\n     float island = 0.;\n     float main_shape = Draw_A_Circle(center,p,radius);\n     main_shape += clamp(abs(perlin(p*detail_p_scale)),0.,1.)*0.1;\n\n     island = main_shape;\n     return island;\n\n}\n\n\nfloat cliff(float radius_length,vec2 center,vec2 pos,float cliff_max_height)\n{\n    float rand_start = 0.0;//Random_Value(seed,0.,2.*pi);\n    float total_radian =0.;\n    float cliff =0.;\n    while(total_radian<2.1*pi)\n    {\n        float beach_length = Random_Value(rand_start+total_radian,beach_length_min_max.x,beach_length_min_max.y);\n        total_radian += beach_length/radius_length;\n        \n        //start point of coast_cliff\n        vec2 startP = Get_Point_At_Circle(center,radius_length,rand_start+total_radian);\n        \n        float coast_cliff_length = Random_Value(total_radian,coast_cliff_length_min_max.x,coast_cliff_length_min_max.y);\n        total_radian += coast_cliff_length/radius_length;\n        \n        //end point of coast_CLIFF\n        vec2 endP = Get_Point_At_Circle(center,radius_length,rand_start+total_radian);\n        \n        // get minddle point of start and end\n        vec2 middleP = (startP+endP)/2.;\n        \n        float rand_weight = Random_Value(rand_start+total_radian,0.1,0.4);\n        vec2 coast_cliff_center = mix(middleP,center,rand_weight);\n        \n        float rand_coast_cliff_radius_scale = Random_Value(rand_start+total_radian,0.8,1.);\n        float coast_cliff_radius = distance(endP,coast_cliff_center)*rand_coast_cliff_radius_scale;\n//(vec2 p,vec2 center,float radius,vec3 noise_scale,float distortDistance)\n        float single_cliff = Draw_Island(pos,coast_cliff_center,coast_cliff_radius,coast_cliff_main_large_detail_noise_scale,\n        \n        coast_cliff_main_large_detail_noise_amplifier);\n        float x = (distance(pos,center)-distance(coast_cliff_center,center))/coast_cliff_radius;\n        //x= remap(x,vec2(-1.,1.));\n        x = clamp(x,-1.,1.);\n        x =remap01(x,vec2(-1.,1.));\n        \n        x *=ceil(clamp(single_cliff,0.,1.));\n        //0.36= tan(20degree)\n        if(2.*coast_cliff_radius*0.36<cliff_max_height)\n        {\n             x *=(2.*coast_cliff_radius*0.36)/cliff_max_height;\n          \n            \n        }\n\n        cliff = max( x,cliff);\n        \n        \n    }\n \n    return cliff;\n}\n\n\n\nvec2[5]Get_rand_pos(vec2 center, vec2 radius)\n{\n    float min = radius.x;\n    float max = radius.y;\n    for(int i =0; i<5;i++)\n    {\n        float area = Random_Value(float(i)*32223.,radius.x, radius.y);\n        float rand_radian = Random_Value(float(i)*323.,0., 2.*pi);\n        vec2 rand_pos = Get_Point_At_Circle(center,area,rand_radian);\n        rand_poses[i]=rand_pos;\n    \n    }\n    \n\n\n    return rand_poses;\n\n}\n\n\nfloat Moutain_Plat(vec2 p, vec2 center, vec2 radius_in_out,float distort_dsitance)\n{\n    float main_noise = platform_noise_scale.x;\n    float large_noise =platform_noise_scale.y;\n    float radius_inner = radius_in_out.x;\n    float radius_outer = radius_in_out.y;\n    radius_inner += (noise(p*main_noise)+noise(p*large_noise)*0.3)*distort_dsitance ;\n    radius_outer += (noise(p*main_noise)+noise(p*large_noise)*0.3)*distort_dsitance ;\n    float dist = distance(p,center);\n    \n    \n    \n    float platform = (dist-radius_inner)/(radius_outer-radius_inner);\n    platform = 1.-platform;\n    return platform;\n\n}\n\nfloat mask = 0.;\n\nfloat Make_Mask(float value,vec2 threshold_min_max,out float mask)\n{\n    float min_ = threshold_min_max.x;\n    float max_ = threshold_min_max.y;\n    float val =0.;\n    mask = 0.;\n    if(value>min_ && value<=max_)\n    {\n        \n        return val = min_;\n        mask=1.;\n        \n\n    \n    }\n   \n    val = 0.;\n    mask=0.;\n    \n    return val;\n\n}\n\n\n\n\nfloat Place_Platform(vec2 p,vec2 clamp_threshold, float inHeight,vec2 radius_in_out,float distort_dsitance,\nout float[5] maskes,out float[5] clamp_value,out float[5] platforms)\n{\n    \n    float heightfield=inHeight;\n    //float temp_height=0.0;\n    float mask = 0.;\n    int listLength =4;\n\n  \n    for(int i =0; i<=listLength;i++)\n    {\n        \n        float maxclp = Random_Value(globalSeed+float(i)*34343.,clamp_threshold.x,clamp_threshold.y);\n   \n        distort_dsitance *= Random_Value(globalSeed+float(i)*34343.,0.8,1.2);\n        float single_plat = Moutain_Plat(p,rand_poses[i], radius_in_out,distort_dsitance);\n        \n        heightfield =  max(clamp(single_plat,0.,maxclp),heightfield);\n        \n        float temp_mask = Make_Mask(single_plat,vec2(maxclp,1000.),mask);\n        \n        maskes [i]=temp_mask ;\n        float cutDist = (radius_in_out.y-radius_in_out.x)*(1.-maxclp);\n        foliageMaskes [i] = Draw_A_Circle(rand_poses[i],p,radius_in_out.x+cutDist);\n        clamp_value [i]= maxclp;\n        platforms [i]= single_plat;\n        \n        \n    }\n    return heightfield;\n}\n\n\nfloat [5] mask_checker( float maskes[5], float clamp_value[5],float platforms[5],float foliageMaskes [5])\n{\n    int listLength =4;\n    for(int i =0; i<=listLength;i++)\n    {\n        for(int j =0; j<=listLength;j++)\n        {\n            if(clamp_value[i]<clamp_value[j])\n            {\n\n                float heightfield_mask = Make_Mask(platforms[j],vec2(clamp_value[i],1000.),mask);\n                //Make_Mask(platforms[j],vec2(clamp_value[i]-0.05,1000.));\n                float temp_mask = ceil(maskes[i])-ceil(heightfield_mask);\n                maskes[i] = clamp(temp_mask,0.,1.)*clamp_value[i];\n                //foliageMaskes [i] = clamp((foliageMaskes [i],0.,1.)*ceil( maskes[i]),0.,1.);\n            }\n        }\n    }\n    return maskes;\n\n\n}\n\n\n\nfloat mountain(vec2 p,vec2 center)\n{\n    float heightfield=0.;\n    vec2[5]rand_poses =  Get_rand_pos(center, vec2(100.,200.));\n    for(int i =0; i<=mountain_account;i++)\n    {\n\n        vec2 mountain_center = rand_poses[i];\n        float mountain_radius = Random_Value(globalSeed+float(i),mountain_radius_min_max.x,mountain_radius_min_max.y);\n        float mountain_height = Draw_Island(p,mountain_center,mountain_radius,mountain_main_large_detail_noise_scale,mountain_noise_amplifier);\n        \n        mountain_height = clamp(mountain_height,0.,1.);\n        heightfield+= mountain_height;\n        \n        \n    }\n    \n    return clamp(heightfield,0.,1.);\n}\n\nfloat road(vec2 p)\n{\n    return perlin( p) ;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n\n    uv*=1800.;\n\n \n    float r,g,b,m=0.;\n    float radius_length= 300.;\n    vec2 center = vec2(0.,0.);\n    vec2[5]rand_poses =  Get_rand_pos(center, vec2(100.,1000.));\n\n   \n//////r is the main shape of island, base height is 10\n    r = Draw_Island(uv,center,main_island_radius,vec3(0.004,0.02,0.11),1100.);\n    r = ceil(r);\n    \n    \n////g is the cliff area    base height is 50\n    float circle = clamp(Draw_A_Circle(center,uv,main_island_radius),0.,1.);\n    \n    \n    float noise1 = 0.;\n    noise1 += noise(uv*0.003);\n    noise1 += noise(uv*0.02)*0.25;\n    //main_island_radius += noise1*200.;\n     \n    g = cliff(main_island_radius,center,uv,75.);\n    g = clamp(g,0.,1.);\n\n  \n  \n\n////  b is the mountain area  base height is 100  //////\n   // b = Moutain_Plat(uv, center, vec2(50.,500.),100.);\n   // place_platform(vec2 p,vec2 clamp_threshold, float inHeight,vec2 radius_in_out,float distort_dsitance)\n    //g = Place_Platform(uv,vec2(0.5,1.), 0.0,vec2 (40.,450.),50.,maskes,clamp_value,platforms);\n      \n    float value1 = 0.45;\n    platforms[3]*=value1;\n    maskes[3]*=value1;\n    clamp_value[3]*=value1;\n    \n    float value2 = 0.2;\n    platforms[0]*=value2;\n    maskes[0]*=value2;\n    clamp_value[0]*=value2;\n    //platforms[1]=0.1;\n       // maskes[1]=0.1;\n       // clamp_value[1]=0.1;\n  \n     maskes = mask_checker( maskes,clamp_value, platforms,foliageMaskes);\n     //for(int i =0; i<=2;i++)\n     //{\n      //  g =max(ceil(maskes [i])*foliageMaskes [i],g);\n      //}\n      \n       b=0.;\n      for(int i =0; i<=4;i++)\n     {\n        b =max(clamp(maskes [i],0.,.2),b);\n      }\n    //g=0.;\n     //for(int i =0; i<=4;i++)\n     //{\n       // g =max(clamp(platforms [i],0.,clamp_value[i]),g);\n      //}\n       b = ceil(b);\n\n    //g = maskes[0];\n    \n\n//// final is max (r,g,b);//////    \n    vec3 col = vec3(r,g,b);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}