{"ver":"0.1","info":{"id":"4dyXDD","date":"1466891289","viewed":368,"name":"Multi-biomes Planet","username":"Karang","description":"Small Planet","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nvec3 lPos = normalize(vec3(1.0, 0.0, 0.0)); // Sun direction\nvec3 pAxis = normalize(vec3(0.0, 1.0, 0.5)); // Axe de rotation\nfloat pRadius = 10.0; // Planet radius\nfloat sLevel = 0.8; // Sea level\n\nfloat hash(float h) {\n    h += 40.0; // prevent center symetry\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat snoise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat star(vec3 p) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<6 ; i++) {\n        h += (snoise(p*f*300.0)/f);\n        f *= 2.0;\n    }\n    return smoothstep(0.1, 0.9, 1.0-h*2.0);\n}\n\n// Ridged multi-fractal helps to create mountain chains and ocean rift\nfloat elevation(vec3 p, int octaves) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<8 ; i++) {\n        if (i>octaves) break;\n        h += abs((snoise(p*f*0.2)-0.5)/f);\n        f *= 2.0;\n    }\n    return h-1.0;\n}\n\nfloat rivers(vec3 p, float height, float t, int octaves) {\n    p = (rotationMatrix(pAxis, iTime*0.05) * vec4(p,1.0)).xyz;\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<3 ; i++) {\n        if (i>octaves) break;\n        h += (snoise(p*f*2.0+80.0)-0.5)/f;\n        f *= 2.0;\n    }\n    return abs(h)*0.2+1.0-smoothstep(0.0, 1.0, (1.0-t)*10.0);\n}\n\n// Compute temperature gradient based on lattitude and altitude\nfloat meanTemperature(vec3 p) {\n    float lat = asin(dot(normalize(p), pAxis))/(3.14159/2.0);\n    float h = length(p) - pRadius;\n    return 1.5 - abs(lat)*1.5 - h*0.3;\n}\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n    p = (rotationMatrix(pAxis, iTime*0.05) * vec4(p,1.0)).xyz;\n    \n    d = length(p) - pRadius + elevation(p, 8);\n    \n    if (d<dMin) {\n        dMin = d;\n        mID = 0.0;\n    }\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 screenP) {\n\tconst int geoLOD = 8;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n    \n    vec3 color = vec3(0.005,0.005,0.06);\n    float sun = clamp(dot(rd, lPos),0.0,1.0)+0.05;\n    color += 0.01 * lCol * pow(sun, 100.0);\n    \n    color += star(rd);\n    \n    // Fake atmosphere\n    float uFrac = 0.55;\n    float uWidth = 0.05;\n    color += vec3(0.6, 0.8, 1.0)*(1.0-smoothstep(0.0, (1.0+uWidth)*uFrac, length(screenP)-uFrac));\n    \n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n    int norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\t\n    vec3 pos = ro + rd*res.x;\n    float h = length(pos) - pRadius;\n    float t = meanTemperature(pos);\n    float riv = rivers(pos, h, t, norLOD);\n    \n\t// vec3 nor = normalize(pos); // Sphere normals (disable relief visualisation)\n\tvec3 nor = calcNormal(pos, norLOD);\n    \n    float slope = dot(normalize(pos), nor);\n\t\n    // Temperature visualisation\n\t//color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), t);\n    \n    \n    if (h<sLevel || riv<0.005) {\n        color = vec3(0.0, 0.0, 1.0);\n        if (t<0.1) {\n            color = vec3(0.4, 0.7, 1.0);\n        }\n    } else {\n        if (t<0.1) {\n            color = vec3(0.7, 0.8, 1.0);\n            if (slope<0.98) color = vec3(0.1, 0.1, 0.1);\n        } else if (t<0.8 && h>sLevel+0.01) {\n            color = vec3(0.3, 0.5, 0.2);\n            if (slope<0.98) color = vec3(0.1, 0.1, 0.1);\n        } else if(t<0.83 || (t>0.8 && (h<(sLevel+0.02) || riv<0.025)))\n            color = vec3(0.4, 0.5, 0.2);\n         else\n            color = vec3(0.8, 0.7, 0.5);\n    }\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.09, 2.0);\n\n    color += (0.3*lAmb) * lCol;\n    color *= (1.1*lDif) * lCol;\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    \n\t// Camera\n    float radius = 26.0;\n    vec3 cPos = vec3(radius, 0.0, 0.0);\n    cPos = (rotationMatrix(vec3(0.0, 1.0, 0.0), iMouse.x*0.01)*rotationMatrix(vec3(0.0, 0.0, 1.0), clamp(-2.0+iMouse.y*0.01, -3.14/2.0, 3.14/2.0))*vec4(cPos, 1.0)).xyz;\n\t/*float x = 0.0 + radius*cos(iMouse.x*0.01);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + radius*sin(iMouse.x*0.01);\n\tvec3 cPos = vec3(x, y, z);*/\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(0.0, 0.0, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd, pos);\n\t\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}