{"ver":"0.1","info":{"id":"mdKSDK","date":"1681666705","viewed":123,"name":"Melting Crayons","username":"edziewanowski","description":"Experimenting with curl noise","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["curl","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float Swirl(vec2 coords)\n{\n    return texture(iChannel1, coords * 0.9).x;\n}\n\nvec2 Rotate(vec2 coords, float angle)\n{\n    float sinValue = sin(angle);\n    float cosValue = cos(angle);\n\n    float x = (cosValue * coords.x) - (sinValue * coords.y);\n    float y = (sinValue * coords.x) + (cosValue * coords.y);\n\n    vec2 rotatedCoords = vec2(x, y);\n    return rotatedCoords;\n}\n\nvec2 QuakeWaterUV(vec2 coords, float amplitude, float speed, float wavelength)\n{\n    float scaledTime = iTime * speed;\n    vec2 scaledCoords = coords * wavelength;\n    float x = sin(scaledTime + scaledCoords.x)*amplitude;\n    float y = sin(scaledTime + scaledCoords.y)*amplitude;\n    return coords + vec2(y,x);\n}\n\n\nfloat AnimatedNoise(vec2 coords)\n{\n    float period = 5.0;\n    float scaledTime = iTime / period;\n    float noiseAstep = floor(scaledTime);\n    float noiseBstep = floor(scaledTime - 0.5);\n    float noiseAfrac = scaledTime - noiseAstep;\n    float noiseAsaw = abs(noiseAfrac * 2.0 - 1.0);\n    \n    float noiseA = Swirl(QuakeWaterUV(coords*1.3, 0.03, -0.8, 8.0));\n    float noiseB = Swirl(QuakeWaterUV(coords*0.7, 0.02, 1.3, 7.0));\n    \n    float result = mix(noiseA, noiseB, noiseAsaw);\n    \n    return result;\n}\n\n\nfloat CellNoise(vec2 coords, float cellCount)\n{\n    vec2 uv = coords/iResolution.y;\n    vec2 cells = ceil(uv*cellCount);\n    float cellValue = (sin(cells.x * cells.y) + 1.0) * 0.5;\n    return cellValue;\n}\n\nvec4 MapValueToPalette(float source, vec2 coords, float cellCount)\n{\n    vec3[5] paletteA = vec3[](vec3(0.8,0,0), vec3(1,1,1), vec3(1,0.4,0), vec3(0.5,0.1,0), vec3(0,0,0));\n    vec3[5] paletteB = vec3[](vec3(1.0,0,0), vec3(0.5,0.5,0.5), vec3(0.9,0.5,0), vec3(0.7,0.2,0), vec3(0.3,0,0));\n    float noise = CellNoise(coords, cellCount);\n    float blend = (sin(iTime * 2.0 + noise *20.0) + 1.0)*0.5;\n    int index = int(clamp(floor(source * 5.0),0.0,4.0));\n    vec3 mixedColor = mix(paletteA[index], paletteB[index], blend);\n    return vec4(mixedColor, 0);\n}\n\nvec4 InitialImage(vec2 coords, float cellCount)\n{\n    float cellValue = CellNoise(coords, cellCount);\n    vec4 cellColor = MapValueToPalette(cellValue, coords, cellCount);\n    return cellColor;\n}\n\n\nfloat SwirlingCrayons(vec2 coords, float cellCount)\n{\n    vec2 uv = coords/iResolution.y;\n    vec2 cellUV = fract(uv*cellCount);\n    float cellTime = mix(-3.0, 3.0, CellNoise(coords, cellCount)) * iTime;\n    vec2 circleCenter = vec2(0.5 + 0.2 * cos(cellTime), 0.5 + 0.2 * -sin(cellTime));\n    float centerDistance = distance(cellUV, circleCenter);\n    float circle = clamp((centerDistance - 0.02) * 10.0, 0.0, 1.0);\n    return circle;\n}\n\n\nvec2 CalculateCurl(sampler2D source, vec2 coords, float epsilion )\n{\n    float span = epsilion * 2.0;\n    float sampleN = AnimatedNoise(coords + vec2(0, epsilion));\n    float sampleS = AnimatedNoise(coords + vec2(0,-epsilion));\n    float sampleE = AnimatedNoise(coords + vec2( epsilion,0));\n    float sampleW = AnimatedNoise(coords + vec2(-epsilion,0));\n    \n    float dx = (sampleE - sampleW) / span;\n    float dy = (sampleN - sampleS) / span;\n    \n    vec2 curl = vec2(dy, -dx);\n    return curl;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cells = 7.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    if(iFrame == 0)\n    {\n        fragColor = InitialImage(fragCoord, cells);\n        return;\n    }\n    vec2 curl = CalculateCurl(iChannel1, uv, 0.01 );\n    vec4 curledImage = texture(iChannel0,uv + curl * 0.0003 );\n    fragColor = mix(InitialImage(fragCoord, cells),curledImage, SwirlingCrayons(fragCoord, cells));\n    //float aniNoise = AnimatedNoise(uv);\n    //fragColor = vec4(aniNoise,aniNoise,aniNoise, 0);   \n}","name":"Buffer A","description":"","type":"buffer"}]}