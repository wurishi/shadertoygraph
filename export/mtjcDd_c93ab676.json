{"ver":"0.1","info":{"id":"mtjcDd","date":"1692471192","viewed":107,"name":"Artic Radar","username":"hicster_rs","description":"My implementation of the recommended shader practice of the book of shaders ch.08. \"Oblivion Radar\".","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["rotation","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535\n#define HALF_PI PI/2.\n#define DOUBLE_PI PI*2.\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n\n\nmat2 get_2d_rotation_matrix(float radian){\n    return mat2(cos(radian),-sin(radian),\n        sin(radian),cos(radian));\n}\nvec3 normalize_rgb(vec3 rgb) {\n    return rgb/255.;\n}\nvec3 normalize_rgb(int r, int g, int b) {\n    return vec3(float(r)/255., float(g)/255., float(b)/255.);\n}\n\n#define BACKGROUND_COLOR normalize_rgb(0x2e, 0x34, 0x40)\n#define BLUE normalize_rgb(0x81, 0xa1, 0xc1) // #81a1c1 or #50aadd\n#define WHITE normalize_rgb(0xec, 0xef, 0xf4) // #eceff4\n#define RED normalize_rgb(0xbf, 0x61, 0x6a) // #bf616a\n\nfloat noise(float x) {\n    return sin(x)*(sin(x*.3+2.)*1.5)*cos(x*2.+3.)*sin(x/2.+PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 rotating_uv = get_2d_rotation_matrix(iTime) * uv;\n    vec3 final_buffer = vec3(0.);\n\n    float d = length(uv);\n    float circles_df = smoothstep(0.06,.01,abs(sin(d*PI*4.))) + smoothstep(.0,.5,.03/abs(sin(d*PI*4.)));\n    float mask = smoothstep(1.12,1.08,d/PI*3.45); // mask to limit some elementds to render constrained, clip space\n    circles_df *= mask;\n    final_buffer = vec3(circles_df)*BLUE;\n    \n    float cross_mask = 1.-step(.005,abs(uv.y-uv.x));\n    uv = get_2d_rotation_matrix(-PI/2.) * uv;\n    cross_mask += 1.-step(.005,abs(uv.y-uv.x));\n    uv = get_2d_rotation_matrix(PI/2.) * uv;\n    cross_mask *= mask;\n    final_buffer += max(vec3(cross_mask)*WHITE-circles_df*.1,0.);\n\n    float sonar_mask = smoothstep(0.,1.,atan(rotating_uv.y,rotating_uv.x)-HALF_PI);\n    sonar_mask *= mask;\n    final_buffer += clamp(sonar_mask,0.,1.)*BLUE;\n\n    d = length(vec2(uv.x, uv.y+.54));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x+.08, uv.y+.6));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI+.08,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x+.06, uv.y+.75));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI-.06,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x-.18, uv.y+.92));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI-.18,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x+.38, uv.y-.26));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time+.60,DOUBLE_PI)/2.),3.5)*RED;\n\n    d = length(vec2(uv.x+noise(u_time/2.)*.3-.45, uv.y+noise(u_time/2.+DOUBLE_PI)*.5-.2));\n    final_buffer += smoothstep(.01,0.005,abs(d-.05))*BLUE;\n    final_buffer += max(0.,step(abs(d/(fract(u_time*1.5))),0.35)-smoothstep(.35,.2,d/fract(u_time*1.5)))*BLUE;\n    final_buffer += step(d,0.03)*pow(max(0.,1.-abs(mod(u_time,.4)-.5)),pow(2.,2.5))*BLUE*mask;\n\n    d = length(vec2(uv.x-noise(u_time/2.+654.)*.8, uv.y-noise(u_time+897.)*.6-.02));\n    final_buffer += smoothstep(.01,0.005,abs(d-.05))*BLUE;\n    final_buffer += max(0.,step(abs(d/(fract((u_time+1.5)*1.5))),0.35)-smoothstep(.35,.2,d/fract((u_time+1.5)*1.5)))*BLUE;\n    final_buffer += step(d,0.03)*pow(max(0.,1.-abs(mod(u_time,.4)-.5)),pow(2.,2.5))*BLUE*mask;\n\n    d = length(uv);\n    rotating_uv = get_2d_rotation_matrix(sin(u_time*.325)/DOUBLE_PI) * uv;\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI-1.2))*(step(abs(d-1.2),.005)+smoothstep(0.02,0.,abs(d-1.2)))*WHITE;\n    rotating_uv = get_2d_rotation_matrix(sin(-u_time*.75)/DOUBLE_PI) * (get_2d_rotation_matrix(.5)*uv);\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI-1.3))*(step(abs(d-1.1),.005)+smoothstep(0.02,0.,abs(d-1.1)))*WHITE;\n    rotating_uv = get_2d_rotation_matrix(u_time*.075) * uv;\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI+.5356))*(step(abs(d-1.3),.005)+smoothstep(0.02,0.,abs(d-1.3)))*WHITE;\n    rotating_uv = get_2d_rotation_matrix(sin(-u_time*.5)/DOUBLE_PI) * (get_2d_rotation_matrix(PI)*uv);\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI-.8))*(step(abs(d-1.15),.005)+smoothstep(0.02,0.,abs(d-1.15)))*WHITE;\n\n    float colors_mask = (final_buffer.r + final_buffer.g + final_buffer.b) / 3.; \n    final_buffer += BACKGROUND_COLOR*(1.-colors_mask); \n    \n    fragColor = vec4(vec3(final_buffer),1.);\n}","name":"Image","description":"","type":"image"}]}