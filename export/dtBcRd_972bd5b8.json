{"ver":"0.1","info":{"id":"dtBcRd","date":"1692478686","viewed":50,"name":"hexsdf","username":"magnias","description":"geometry","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"7llBRX","parentname":"hexagonsymmetry"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -- util --\n\nmat4 translate(float x, float y, float z) {\n    return mat4(\n        1, 0, 0, x,\n        0, 1, 0, y,\n        0, 0, 1, z,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateThirdRight() {\n    return mat4(\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        1, 0, 0, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateSixthRight() {\n    return mat4(\n        0, -1, 0, 0,\n        0, 0, -1, 0,\n        -1, 0, 0, 0,\n        0, 0, 0, 1\n    );\n}\n\nfloat dist(vec3 pos1, vec3 pos2) {\n    vec3 s = abs(pos1 + pos2);\n    return max(s.x, max(s.y, s.z));\n}\n\nvec3 screenPosToHexCoord(vec2 position, float diameter)\n{\n    mat2 hexToScreenMatrix = mat2(-1, 0,\n                                       -1.0 / 2.0f, sqrt(3.0f) / 2.0);\n\n    vec2 posInHexSpace = inverse(hexToScreenMatrix) * (position / vec2(diameter));\n\n    vec3 newPos;\n    newPos.x = -posInHexSpace.x - posInHexSpace.y;\n    newPos.y = posInHexSpace.x;\n    newPos.z = posInHexSpace.y;\n\n    // How much does the position deviate from a unit coord?\n    vec3 roundDelta;\n    roundDelta.x = abs(round(newPos.x) - newPos.x);\n    roundDelta.y = abs(round(newPos.y) - newPos.y);\n    roundDelta.z = abs(round(newPos.z) - newPos.z);\n\n    // Recalculate the axis with the biggest error\n    vec3 nodepos;\n    if (roundDelta.z > roundDelta.x && roundDelta.z > roundDelta.y)\n    {\n        // Z biggest error\n        nodepos.x = round(newPos.x);\n        nodepos.y = round(newPos.y);\n        nodepos.z = -nodepos.x - nodepos.y;\n    } else if (roundDelta.y > roundDelta.x && roundDelta.y > roundDelta.z)\n    {\n        // Y biggest error\n        nodepos.x = round(newPos.x);\n        nodepos.z = round(newPos.z);\n        nodepos.y = -nodepos.x - nodepos.z;\n    } else\n    {\n        // X biggest error\n        nodepos.y = round(newPos.y);\n        nodepos.z = round(newPos.z);\n        nodepos.x = -nodepos.y - nodepos.z;\n    }\n\n    return nodepos;\n}\n\n\n// -- sdf implementation --\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdf( vec3 p )\n{\n    p = rotateX( iTime / 7.0 ) * p;\n    float scale = .8f;\n    return min( \n        max( - (length( p ) - 30.0f * scale ), sdBox( p, vec3( 20.0f * scale ) ) ),\n        min( min(\n        sdCapsule( p, vec3( -100.0f, 0.0f, 0.0f ), vec3( 100.0f, 0.0f, 0.0f ), 1.0f ), \n        sdCapsule( p, vec3( 0.0f, -100.0f, 0.0f ), vec3( 0.0f, 100.0f, 0.0f ), 1.0f ) ), \n        sdCapsule( p, vec3( 0.0f, 0.0f, -100.0f ), vec3( 0.0f, 0.0f, 100.0f ), 1.0f ) )\n    );\n}\n\n// @param t: a distance between [ 0 .. 1 ]\nvec3 color( float t )\n{\n    return vec3( t );\n}\n\nvec3 traceHex( in vec3 hexCoord )\n{\n    // The hex coordinate system follow the following structure: x + y = z\n    // Interpreting these variables as a position in a 3d coordinate system, you get a tilted plane.\n    // Any hex position is guaranteed to lay on this plane.\n    // Using this info I cast a ray from any position in 3d space to the hex position on the plane in 2d space.\n    \n    // A fixed distance the camera takes from the plane to not cast rays inside the geometry.\n    float dist = 100.0f;\n    // The max depth the camera takes\n    float farclip = 50.0f;\n\n    vec3 origin = hexCoord - normalize( vec3( 1 ) ) * dist;\n    vec3 direction = normalize( vec3( 1, 1, 1 ) );\n    \n    float t = 0.0f;\n    for( int i = 0; i < 100; i++ )\n    {\n        float d = sdf( origin + direction * t );\n        t += d;\n        \n        if( d < 0.005f )\n        {\n            // Map t to a range of [0 .. 1] corresponding to the camera's view depth\n            float clipdist = ( t - dist + farclip ) / farclip;\n            return color( clipdist );\n        }\n    }\n    return vec3( 0 );\n}\n\n// -- main --\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 hexCoord = screenPosToHexCoord(uv, 0.009);\n    vec3 color = traceHex( hexCoord );\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}","name":"Common","description":"","type":"common"}]}