{"ver":"0.1","info":{"id":"dllfWH","date":"1694936322","viewed":53,"name":"Ray Marching - jc","username":"joshuc","description":"Time accumulating unoptimized path tracing with ray marching. Render of the Cornell box. ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","sdf","globalillumination","pathtracing","signeddistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Output to screen\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = texture(iChannel0, vec2(uv)).xyz;\n    \n    if (iFrame > 0) {\n        // gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define u_fov 65. \n#define u_strataSize 1\n#define u_lightSamples 1\n#define u_maxSteps 100\n#define u_maxBounces 3\n#define u_aaSpread 0.001 \n\n/*\n    vector methods\n*/\nvec3 calculatePerspective(vec2 raster) {\n    float ar = iResolution.x/iResolution.y;\n    vec2 ndc = raster/iResolution.xy;\n    \n    return normalize(vec3((ndc*2.0-1.0)*vec2(ar, 1.0), ar/tan(degToRad(u_fov)/2.0)));\n}\n\nmaterial idToMaterial(int id) {\n    if (id == 0) {\n        return material(0, 1., vec3(1, 1, 1), 0.,   vec3(0, 0, 0));\n    } else if (id == 1) {\n        return material(0, 1., vec3(1, 0, 0), 0.,   vec3(0, 0, 0));\n    } else if (id == 2) {\n        return material(0, 1., vec3(0, 1, 0), 0.,   vec3(0, 0, 0));\n    } else if (id == 3) {\n        return material(0, 1., vec3(0, 0, 1), 0.,   vec3(0, 0, 0));\n    } else if (id == 4) {\n        return material(0, 1., vec3(1, 1, 1), 100., vec3(1, 0.7, 0.4));\n    } else if (id == 5) {\n        return material(0, 1., vec3(1, 1, 1), 2.,   vec3(0.8, 0.5, 1));\n    } else if (id == 6) {\n        return material(1, 1., vec3(1, 1, 1), 0.,   vec3(0, 0, 0));\n    }\n}\n\n/* \n    Microfacet distributions\n*/\nfloat dist(vec3 w, float alphax, float alphay) {\n    float theta = atan(sqrt(w.x*w.x+w.y*w.y)/w.z);\n    float phi = atan(w.y/w.x);\n    float sinphi = sin(phi);\n    float cosphi = cos(phi);\n    float costheta = cos(theta);\n    float tantheta = tan(theta);\n    return pow(E, -tantheta*tantheta*cosphi*cosphi/(alphax*alphax)+sinphi*sinphi/(alphay*alphay))/PI*alphax*alphay*costheta*costheta*costheta*costheta;\n}\n\nfloat lambda(vec3 w, float alphax, float alphay) {\n    float theta = atan(sqrt(w.x*w.x+w.y*w.y)/w.z);\n    float phi = atan(w.y/w.x);\n    float alpha = sqrt(cos(phi)*cos(phi) * alphax * alphax + sin(phi)*sin(phi) * alphay * alphay);\n    float a = 1./(alpha*abs(tan(theta)));\n    if (a >= 1.6) return 0.;\n    return (1.-1.259*a+0.396*a*a)/3.535*a+2.181*a*a;\n}\n\nfloat g(vec3 i, vec3 o, float alphax, float alphay) {\n    return 1./(1.+lambda(o, alphax, alphay)+lambda(i, alphax, alphay));\n}\n\nfloat brdff(vec3 i, vec3 o, vec3 n) {\n    float alphax = PI/8.;\n    float alphay = PI/8.;\n    float thetai = atan(sqrt(i.x*i.x+i.y*i.y)/i.z);\n    float thetao = atan(sqrt(o.x*o.x+o.y*o.y)/o.z);\n    return dist(n, alphax, alphay)*g(i, o, alphax, alphay)/(4.*cos(thetai)*cos(thetao));\n}\n\n/*\n    BRDFs\n    output: ratio of radiance to irradiance\n*/\nfloat lambertianBRDF(vec3 n, vec3 i, vec3 r, material mat) {\n    // assumes normalized vectors\n    return 1./PI;\n}\n\nfloat brdf(vec3 n, vec3 i, vec3 r, material mat) {\n    if (mat.brdfID == 0) {\n        return lambertianBRDF(n, i, r, mat);\n    }\n    if (mat.brdfID == 1) {\n        return brdff(i, r, n);\n    }\n}\n\n/* \n    Geometry\n*/\nfloat sphereSDF(vec3 p, vec3 pos, float r) {\n    return length(p-pos)-r;\n}\n\nfloat boxSDF(vec3 p, vec3 pos, vec4 rotation, vec3 r) {\n    p = rotate(p-pos, rotation);\n    vec3 q = abs(p)-r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat intersectSDF(float a, float b) {\n    return max(a, b);\n}\n\nfloat differenceSDF(float a, float b) {\n    return max(a, -b);\n}\n\nmatSDF unionMatSDF(matSDF a, matSDF b) {\n    if (a.dist < b.dist) {\n        return a;\n    }\n    return b;\n}\n\nmatSDF sceneMatSDF(vec3 p) {\n    // room\n    matSDF d =         matSDF(   boxSDF(p, vec3(-1,    0,    2), eulerToQuaternion(vec3(0)),           vec3(0.5,  0.5,  0.5)), 1);\n    d = unionMatSDF(d, matSDF(   boxSDF(p, vec3( 1,    0,    2), eulerToQuaternion(vec3(0)),           vec3(0.5,  0.5,  0.5)), 2));\n    d = unionMatSDF(d, matSDF(   boxSDF(p, vec3( 0,    1,    2), eulerToQuaternion(vec3(0)),           vec3(0.5,  0.5,  0.5)), 0));\n    d = unionMatSDF(d, matSDF(   boxSDF(p, vec3( 0,   -1,    2), eulerToQuaternion(vec3(0)),           vec3(0.5,  0.5,  0.5)), 0));\n    d = unionMatSDF(d, matSDF(   boxSDF(p, vec3( 0,    0.59, 2), eulerToQuaternion(vec3(0)),           vec3(0.1,  0.1,  0.1)), 4));\n    d = unionMatSDF(d, matSDF(   boxSDF(p, vec3( 0,    0,    3), eulerToQuaternion(vec3(0)),           vec3(0.5,  0.5,  0.5)), 0));\n                    \n    // left block   \n    d = unionMatSDF(d, matSDF(   boxSDF(p, vec3(-0.2, -0.35, 2), eulerToQuaternion(vec3(0, PI/8., 0)), vec3(0.15, 0.15, 0.15)), 0));\n    d = unionMatSDF(d, matSDF(sphereSDF(p, vec3(-0.2, -0.1,  2), 0.1), 5));\n    \n    // right\n    d = unionMatSDF(d, matSDF(sphereSDF(p, vec3(0.2,  -0.4,    2), 0.1), 6));\n\n    return d;\n}\n\nvec3[1] sceneLights() {\n    vec3[1] vals;\n    vals[0] = vec3(0.);\n    // TODO: return some representation of lights\n    //   maybe move the scene definition out of SDF code, then have one-time\n    //   calculation of emissive materials\n\n    return vals;\n}\n\nvec3 dSceneSDF(vec3 p) {\n    float sdf000 = sceneMatSDF(p+vec3(0., 0., 0.)).dist;\n    float sdf100 = sceneMatSDF(p+vec3(EPSILON, 0., 0.)).dist;\n    float sdf010 = sceneMatSDF(p+vec3(0., EPSILON, 0.)).dist;\n    float sdf001 = sceneMatSDF(p+vec3(0., 0., EPSILON)).dist;\n\n    float dx = (sdf100-sdf000)/EPSILON;\n    float dy = (sdf010-sdf000)/EPSILON;\n    float dz = (sdf001-sdf000)/EPSILON;\n    return normalize(vec3(dx, dy, dz));\n}\n\n/*\n    Main functions\n*/\nrayHit march(vec2 seed, vec3 o, vec3 d) {\n    float depth = 0.;\n    for (int j = 0; j < u_maxSteps; ++j) {\n        vec3 p = o+d*depth;\n        matSDF s = sceneMatSDF(p);\n        if (s.dist < EPSILON) {\n            vec3 n = dSceneSDF(p);\n            return rayHit(true, s.dist, p, n, s.matID);\n        }\n        depth += s.dist;\n    }\n    return rayHit(false, -1., vec3(0.), vec3(0.), -1);\n}\n\nvec3 path(vec2 seed, vec3 o, vec3 d) {\n    vec3 color = vec3(1.);\n    for (int i = 0; i < u_maxBounces+1; ++i) {\n        rayHit hit = march(seed, o, d);\n        if (!hit.did) {\n            return vec3(0.);\n        }\n        material mat = idToMaterial(hit.matID);\n        // kind of hacky, lights should be able to reflect other light too but good enough for now\n        if (mat.intensity > 0.) {\n            return color*mat.emission*mat.intensity;\n        }\n        vec3 r = randomHemisphere(seed, hit.norm);\n        color *= mat.color*mat.albedo*brdf(hit.norm, d, r, mat)*dot(hit.norm, r);\n\n        // this may cause problems in the future. check here if any issues regarding smaller geometry arises\n        o = hit.pos;\n        for (int j = 0; j < u_maxSteps; j++) {\n            if (sceneMatSDF(o).dist >= EPSILON) {\n                break;\n            }\n            o += r*EPSILON;\n        }\n        d = r;\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 cameraPosition = vec3(0., 0., 0.);\n    vec4 cameraRotation = eulerToQuaternion(vec3(0., 0., 0.));\n\n    vec3 rd = rotate(calculatePerspective(fragCoord), cameraRotation);\n\n    vec3 s;\n    for (int i = 0; i < u_strataSize; i++) {\n        s += path(uv+iTime/1000., cameraPosition, rotate(rd, eulerToQuaternion(vec3((rand(uv+iTime)*2.-1.)*u_aaSpread, (rand(uv+iTime)*2.-1.)*u_aaSpread, (rand(uv+iTime)*2.-1.)*u_aaSpread))));\n    }\n    s /= float(u_strataSize);\n\n    vec4 color = vec4(s, 1.);\n    if (iFrame == 0) {\n        color = vec4(s, 1.);\n    } else {\n        vec4 p = texture(iChannel0, vec2(uv));   \n        color = vec4(mix(s, p.xyz, float(iFrame)/float(iFrame+u_strataSize)), 1.);\n    }\n    fragColor = color;\n    // fragColor = vec4(rand(uv));\n}\n\n/*\n\nTODO: \n1. sample the lights\n2. implement other brdf (full reflective?)\n3. importance sampling\n4. glass brdf\n5. volumetric scattering (cause it looks dope asf lol)\n\nLATER: \n1. why are there some random black dots lol\n\n*/\n\n// ~38-40fps\n//  ~25ms\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EPSILON  0.0001\n#define PI       3.14159265359\n#define E        2.71828182846\n\n/*\n    Math\n*/\nfloat degToRad(float d) {\n    return PI/180.*d;\n}\n\nfloat radToDeg(float r) {\n    return 180./PI*r;\n}\n\n// hash functions stolen from https://thebookofshaders.com/10/\nint seed = 0;\nfloat rand(vec2 p) {\n    ++seed;\n    return fract(sin(dot(p+vec2(seed)/1000., vec2(12.9898, 78.233)))*43758.5453);\n}\n\n// int seed = 0;\n// float rand(vec2 p) {\n//     ++seed;\n//     vec2 k1 = vec2(\n//         23.14069263277926, 2.665144142690225\n//     );\n//     return fract(cos(dot(p+vec2(seed), k1))*12345.6789);\n// }\n\nvec3 randomSphere(vec2 s) {\n    float az = 2.*PI*rand(s);\n    float al = 2.*PI*rand(s);\n    float saz = sin(az);\n    float caz = cos(az);\n    float cal = cos(al);\n    float sal = sin(al);\n\n    return vec3(caz*cal, sal, saz*cal);\n}\n\nvec3 randomHemisphere(vec2 s, vec3 n) {\n    vec3 r = randomSphere(s);\n    if (dot(r, n) < 0.) {\n        return -r;\n    }\n    return r;\n}\n\nvec3 rotate(vec3 p, vec4 quat) {\n    float i = quat[0];\n    float j = quat[1];\n    float k = quat[2];\n    float w = quat[3];\n\n    mat3x3 m = mat3x3(w*w+i*i-j*j-k*k,  2.*(i*j-w*k),    2.*(i*k+w*j),\n                      2.*(w*k+i*j),     w*w-i*i+j*j-k*k, 2.*(j*k-w*i),\n                      2.*(i*k-w*j),     2.*(w*i+j*k),    w*w-i*i-j*j+k*k);\n    return m*p;\n}\n\nvec4 eulerToQuaternion(vec3 e) {\n    float sx = sin(e.x/2.);\n    float cx = cos(e.x/2.);\n    float sy = sin(e.y/2.);\n    float cy = cos(e.y/2.);\n    float sz = sin(e.z/2.);\n    float cz = cos(e.z/2.);\n\n    return vec4(sx*cy*cz+cx*sy*sz,\n                sx*cy*sz-cx*sy*cz,\n                cx*cy*sz-sx*sy*cz,\n                cx*cy*cz+sx*sy*sz);\n}\n\n/*\n    structs\n*/\nstruct matSDF {\n    float dist;\n    int matID;\n};\n\nstruct rayHit {\n    bool did;\n    float dist;\n    vec3 pos;\n    vec3 norm;\n    int matID;\n};\n\nstruct material {\n    int brdfID;\n    float albedo;\n    vec3 color;\n    float intensity;\n    vec3 emission;\n};\n\nstruct object {\n    int geomID;\n    int matID;\n    vec3 pos;\n    vec4 rot;\n    float[3] params;\n};\n","name":"Common","description":"","type":"common"}]}