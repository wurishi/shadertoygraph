{"ver":"0.1","info":{"id":"Ns2SWm","date":"1620409112","viewed":86,"name":"Giant Orange","username":"livvy","description":"I had a weird dream awhile ago about giant oranges so I decided to make one.\n\n~UNFINISHED~","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","orange","fruit","orannayarr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GIANT ORANGE by livvy / mag3nta\n// TODO:\n// - add specular highlight\n// - use some noise to add dimpled texture pattern\n// - shape slightly\n// - improve leaves and stalk\n// - add something for scale \n\n#define PI 3.14159265\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdTri( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdCyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(in vec3 p) {\n    float h = 3.0;\n\n    //p.y*=(1.1+abs(sqrt(p.x)));\n    \n    // orange\n    float d = length(p) - h+0.02;\n    \n    // table/plane\n    float dP = p.y+h-0.04;\n    \n    // middle of leaves\n    float s = 0.1;\n    vec3 p1 = vec3(-s, h, s);\n    vec3 p2 = vec3( s, h, s);\n    vec3 p3 = vec3( s, h,-s);\n    vec3 p4 = vec3(-s, h,-s);\n    float leaf = sdQuad(p, p1, p2, p3, p4);\n    \n    // leaves\n    float tri1 = sdTri(p, p1, p2, vec3( 0.,   h+s*.5,  s*2.));\n    float tri2 = sdTri(p, p2, p3, vec3( s*2., h+s*.5,  0.));\n    float tri3 = sdTri(p, p3, p4, vec3( 0.,   h+s*.5, -s*2.));\n    float tri4 = sdTri(p, p4, p1, vec3(-s*2., h+s*.5,  0.));\n    float tri = min(min(tri1, tri2), min(tri3, tri4));\n    \n    // leafy bits\n    float leaves = min(leaf,tri)-0.008;\n    \n    // stalk\n    p.y-=h;\n    const float k = 2.0; // or some other amount\n    float co = cos(k*p.y);\n    float si = sin(k*p.y);\n    mat2  m = mat2(co,-si,si,co);\n    vec3  q = vec3(m*p.xy,p.z);\n  \n    float stalk = sdCyl(q, 0.08, 0.5);\n    \n    float SL = min(leaves, stalk);\n    return min(min(d,dP), SL);\n}\n\nvec3 norm(in vec3 p) {\n    vec2 o = vec2(0.0001, 0.);\n    return normalize(vec3(map(p+o.xyy)-map(p-o.xyy),\n                          map(p+o.yxy)-map(p-o.yxy),\n                          map(p+o.yyx)-map(p-o.yyx)));\n}\n\nmat3 cam( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = abs(LdotV - NdotL * NdotV);\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.2);\n    \n    vec3 ro = vec3(sin(iTime/5.)*7.0,5.0,cos(iTime/5.)*7.0);    \n    vec3 ta = vec3( 0.0, -0.0, 0.0 );\n    mat3 ca = cam( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    float t = 0.000;\n    for (int i=0; i<255; ++i) {\n        vec3 P = ro+rd*t;\n        float d = map(P);\n        if (d<0.001) {\n            vec3 N = norm(P);\n            vec3 L = normalize(vec3(4.0,5.0,4.));\n            vec3 C = pow(vec3(1.0,0.5,0.), vec3(2))*((-clamp(texture(iChannel1, N.xy*2.).r*2.0,0.2,1.0))-0.8); // orange\n            float I = 0.6;\n            float NdotL = dot(N,L);\n\n            // change material colour depending on the Y-position\n            if (P.y<-2.399){\n                C = texture(iChannel0, P.xz*0.2).rgb; // wood texture\n            }\n\n            if (P.y>=3.0) {\n                C = vec3(0.22,0.24,0.00); // green\n            }\n            \n            C = pow(C,vec3(2));\n            // 'studio lights'\n            vec3 Nrot = erot(N, normalize(vec3(-1,1,0)), 3.0);\n            float studio =  dot(max(Nrot, 0.), vec3(.04));\n            \n            // oren-nayer diffuse lighting\n            float Li = (\n                orenNayarDiffuse(L, rd, N, 0.3, 0.7)\n                * I\n                * shadow(P, L, 0.1, 20.0, 12.));\n\n            Li += studio;\n\n            // colourize\n            col=Li*C;\n\n            col *= exp( -0.0005*t*t*t ); // fog\n            col = sqrt(col);\n            break;\n        }\n        t+=d;\n        if (d>15.) break;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}