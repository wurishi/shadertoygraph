{"ver":"0.1","info":{"id":"sddSDM","date":"1633373591","viewed":261,"name":"entremÃªlement","username":"sukupaper","description":"First successfull attempt using log-spherical mapping and SDF ~","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","abstract","logspherical","intertwining"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 aa = 1./iResolution.xy;\n    \n    float k = length(st - .5);\n    k *= k;\n    aa *= max(1., k*10.);\n    \n    vec3 c = vec3(\n        texture(iChannel0, st + vec2(0.,.5)*aa).r,\n        texture(iChannel0, st + vec2(0.,-.5)*aa).g,\n        texture(iChannel0, st - vec2(.5,.5)*aa).b\n    );\n    \n    fragColor = vec4(c - k*.25, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T 6.283185307\n#define E 2.71828182\n\nfloat t;\n\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat sph(in vec3 p, in float r) { return length(p) - r; }\nfloat tor(in vec3 p, in float ir, in float or) { vec2 k = vec2(length(p.xz) - or, p.y); return length(k) - ir; }\n\nfloat noeud(in vec3 p) {\n    const float or = 1.968, ir = 0.085;\n    float a = atan(p.x, p.z);\n    vec2 k = vec2(length(p.xz) - or, p.y);\n    k *= rot(a);\n    k.y = abs(k.y) - .5;\n    return length(k) - ir;\n}\n\nfloat div(in float x, in float d) { return floor(x*d)/d; }\nfloat df(in vec3 p) {\n    p.xz *= rot(t/4.);\n    p.xy *= rot(t/4. + T/3.);\n    p.yz *= rot(t/4. + 2.*T/3.);\n    \n    float scale = exp(mod(-t*T/8., 1.096));\n    p *= scale;\n    \n    vec3 p1 = p;\n    float ldist1 = div(log(length(p1)), E/3.);\n    float sz1 = exp(ldist1);\n    p1 /= sz1;\n    \n    float max_d1 = -(abs(sph(p1, 2.)) - 1.056);\n    float d1 = noeud(p1);\n    \n    float sh = E/5.;\n    vec3 p2 = p*sh;\n    float ldist2 = div(log(length(p2)), E/3.);\n    float sz2 = exp(ldist2);\n    p2 /= sz2;\n    \n    float max_d2 = -(abs(sph(p2, 2.)) - 1.056);\n    float nsz = 3.;\n    float d2 = noeud(vec3(abs(p2.x) - 2.072, p2.zy)*nsz)/nsz;\n    \n    float d = min(\n        min(d1, max_d1)*sz1,\n        (min(d2, max_d2)*sz2)/sh\n\t);\n    \n    return d/scale;\n}\n\n#define LIM .0001\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,.0004); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n#define MAX_D 1000.\n#define MIN_D .25\n#define MAX_IT 110\nstruct rmr { vec3 p; int i; float d; };\nrmr rm(in vec3 c, in vec3 r) {\n    rmr res;\n    res.p = c + r*MIN_D, res.i = MAX_IT;\n    for(int i = 0; i < MAX_IT; i++) {\n        res.d = df(res.p);\n        if(res.d < LIM || distance(c,res.p) > MAX_D) { res.i = i; return res; }\n        res.p += res.d*r;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n    t = iTime + 7.05; // T/4.\n    \n    float k = cos(t/4. + T/4.)*.5 + .5;\n    k *= k;\n    \n    rmr res;\n    if(abs(st.y) - .15*(2. - k) < 0.)\n        res = rm(vec3(0.,0.,-2.), normalize(vec3(st, mix(1.75, .1, k))));\n    \n    float color = 0.01;\n    \n    if(res.d < LIM) {\n        vec3 n = normal(res.p), l = normalize(vec3(1.069,2.001,-2.318)), l2 = normalize(vec3(0.981,-1.550,-2.100));\n        float diff = dot(n, l)*.5 + .5, diff2 = dot(n, l2)*.5 + .5;\n        float spec = pow(max(0., diff*1.02), 50.), spec2 = pow(max(0., diff2), 10.);\n        \n        color = spec + spec2*.2;\n    }\n    \n    fragColor = vec4(vec3(color), 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}