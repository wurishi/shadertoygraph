{"ver":"0.1","info":{"id":"Ws3XR2","date":"1576636719","viewed":267,"name":"Earthboundy-1","username":"bembi","description":"tp3","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["game","cartoon","animation","rpg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;      \n    \n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec2 translate(vec2 _st, vec2 _pos){\n    return _st - _pos;\n}\nvec2 rotate(vec2 _st, float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) \n           *_st;\n}\nvec2 scale(vec2 _st, vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y)\n           *_st;\n}\nfloat poly(vec2 uv,vec2 p, float s, float dif,float N,float a, vec2 scale){\n    vec2 st = p - uv ;\n    st *= scale;     \n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,s+dif,d);\n    return e;\n}\nvec3 poly3(vec2 uv,vec2 p, float s, float dif,float N,float a, vec2 scale, vec3 phase){\n    return vec3(\n        poly(uv,p + phase.x, s, dif, N, a, scale),\n        poly(uv,p + phase.y, s, dif, N, a, scale),\n        poly(uv,p + phase.z, s, dif, N, a, scale));\n}\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\nfloat eye(vec2 st, float angle, float diff, vec2 scale, bool flip)\n{   \n    if (flip) st.x = 1. - st.x;\n    st -= .5;\n    st = rotate(st, angle);\n    st += .5;    \n    float y = -0.01;\n    return poly(st+vec2(0.058,y), vec2(.5), 0.003, diff, 4., 0., scale) \n            + poly(st+vec2(0.045,y), vec2(.5), 0.003, diff, 4., 0., scale)\n            / (1. - poly(st+vec2(0.065,y), vec2(.5), 0.009, diff, 20., 0., scale))\n            / (1. - poly(st+vec2(0.035,y), vec2(.5), 0.009, diff, 20., 0., scale));\n}\nfloat wisp(vec2 st)\n{   \n    return poly(st, vec2(.5), 0.003, 0.0001, 4., 0., vec2(1.));\n}\nvec2 pixelate(vec2 st, float pixelX, float pixelY){\n    vec2 xy = vec2(pixelX, pixelY);\n    xy = (floor(st * xy) + 0.5)/xy;    \n    st = xy;    \n    return st;\n}\nfloat spiral(vec2 st, float speed)\n{\n    vec2 p = vec2(.5, .5) - st;\n    float r = length(p);\n    float a = atan(p.x, p.y);\n    float e = sin(a*1.-r*20.+iTime*speed); // manera de generar una spiral\n    e = e * 1.;\n    return e;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv -= vec2(.5);\n    uv.x *= (iResolution.x/iResolution.y);\n    uv += vec2(.5);\n    \n//    uv = pixelate(uv, 100, 100);\n    \n    \n    vec2 st = uv;    \n\n    // -----------------------\n    // -------- WISPS --------\n    // -----------------------\n    float wisp_ring = 0.;\n    \n    if(true){\n        float wisp_quantity = (10. *fract(uv.y*10.)*fract(uv.x*10.) +1.);\n        for(float i=0.;i<wisp_quantity; i=i+1.){\n            st = uv;\n            st *= 0.3 + uv.y;\n            st = fract(st*i*0.6);\n            float a = TWO_PI/wisp_quantity * i + (iTime*(5.));\n            vec2 pos = .5 + vec2(sin(a), cos(a))*(0.2);\n            wisp_ring += poly(st, pos, 0.003, 0.001, 3., 0., vec2(.5)); \n        }\n    }\n    \n    st = uv;\n    wisp_ring += sin(iTime+st.y*10.*uv.x)*\n                 sin(iTime+st.y*10.*uv.x)\n                 *.01;         \n                 \n    st = pixelate(st, 70., 10.);\n    st -= .5;\n    st = rotate(st, iTime*2.1);\n    st += .5;\n    wisp_ring -= spiral(st+vec2(0.,-0.1), 3.)*0.09;  \n    \n    \n    // -----------------------\n    // -------- GHOST --------\n    // -----------------------\n    vec2 ghost_uv = uv + vec2(0., 0.05);\n    \n    float curse = sin(iTime); // used to sync animations and giladas    \n    float diff = 0.007;\n    vec3 color = vec3(sin(iTime*2.)*.5+.5, 0, uv.y);\n    color = rgb2hsb(color);\n    color = color + hsb2rgb(vec3(fract(iTime*2.), color.g, color.b))/0.3*curse;\n    \n    float speed;\n    if (false){ // rotar spirte a la par de la posicion. pero no garpa al final\n        speed = 0.4;\n        ghost_uv += vec2( sin(iTime*speed*TWO_PI), -cos(iTime*speed*TWO_PI)) * 0.2;\n        ghost_uv -= .5;\n        ghost_uv *= 1.3 + sin(iTime)*0.5;        \n        ghost_uv = rotate(ghost_uv, ((iTime*speed) * TWO_PI) + PI/2. );\n        ghost_uv += .5;\n    }\n    else{\n        speed = 0.4;\n        ghost_uv += vec2( sin(iTime*speed*TWO_PI), sin(iTime*speed*TWO_PI) + -cos(iTime*speed*TWO_PI)) * 0.01;\n        ghost_uv -= .5;\n        ghost_uv *= 1.15 + sin(iTime)*0.2;        \n        ghost_uv += .5;\n        ghost_uv.y -= .2; // giive room for text box\n    }       \n    \n    st = ghost_uv;\n    vec2 face_off = vec2(sin(iTime)*0.01, cos(iTime)*0.02 -0.01);    \n    //cheeks\n    float cheeks_size = 0.005;    \n    float cheeks = poly(st+face_off+vec2(0.079,0.03- ((1.-smoothstep(0.,.1,curse*0.5+0.5))*0.015)), vec2(.5), cheeks_size, diff, 20., 0., vec2(1.)) +\n                 poly(st+face_off+vec2(-0.079,0.03- ((1.-smoothstep(0.,.1,curse*0.5+0.5))*0.015)), vec2(.5), cheeks_size, diff, 20., 0., vec2(1.));\n    //mouth\n    float mouth = poly(st+face_off+vec2(0,0.02), vec2(.5), 0.008  + ((1.-smoothstep(0.,.1,curse*0.5+0.5))*0.015), diff, 20., 0., vec2(1))\n            * (1. - poly(st+face_off+vec2(0,0.04 + (curse*0.01)), vec2(.5), 0.015 + ((1.-smoothstep(0.,.1,curse*0.5+0.5))*0.015), diff, 20., 0., vec2(1)));\n    // body\n    st = ghost_uv;\n    vec3 body;\n    for(float i=0.; i < 1.; i+=0.1){\n        vec2 p =  st +\n            vec2(\n                sin(iTime*4.+4.*(i))*0.02*(i),\n                0.3 * pow((i), 0.1)\n                - 0.65*(i)\n                );\n        float e = poly(p, vec2(.5), 0.13*(.3-i), 0.1, 20., 0., vec2(1));\n        body += vec3(0.2, uv.y, uv.x) * e * 3.;\n    }\n    body = smoothstep(0., 1., body); // clamp after 1\n    \n    // eyes\n    vec2 eyes_scale = vec2(1, 1.4);\n    float eyes_angle = (sin(iTime*20.)*0.015) - 0.2 + ((smoothstep(0.,.1,curse*0.5+0.5))*0.3);\n    float eyes = eye(st+face_off, eyes_angle, diff, eyes_scale, false);\n    eyes += eye(st+face_off, eyes_angle, diff, eyes_scale, true);\n    \n    \n    vec3 dib = color * body*1.2;\n    dib.r *= 1. - step(0.5, sin(iTime*20.+uv.y*400.)) * 0.2;\n    dib.g *= 1. - step(0.5, sin(iTime*22.+uv.y*3000.)) * 0.2;\n    \n    // -----------------------\n    // -------- DIALOG BOX --------\n    // -----------------------\n    \n    vec2 dialogbox_uv = uv + vec2(0, sin(iTime*2.)*0.003+0.3);\n    st = dialogbox_uv;\n    st.y += sin(iTime*20.+uv.x*600.)*0.007;\n    st.x += sin(iTime*20.+uv.y*600.)*0.007;\n    st -= .5;\n    st *= vec2(0.30, 1.5);\n    st += .5;\n    vec3 dialog_box = poly3(st, vec2(.5), 0.1, 0.003, 4., 0., vec2(1), vec3(0, 0.001, 0));\n\n    st = dialogbox_uv;\n    st -= .5;\n    st *= vec2(0.30, 1.45);\n    st += .5;\n    dialog_box *= poly3(st, vec2(.5), 0.1, 0.003, 4., 0., vec2(1), vec3(0, 0.001, 0));\n    st = dialogbox_uv;\n    st -= .5;\n    st *= vec2(0.305, 1.6);\n    st += .5;\n    float d_box_bg_force = 1.5; \n    dialog_box -= poly(st, vec2(.5), 0.1, 0.003, 4., 0., vec2(1))*d_box_bg_force;\n    \n    st = dialogbox_uv;\n    vec3 text;\n    float text_quantity = 3.;\n    for(float i=0.;i<text_quantity;i++){\n        vec2 pos = vec2(0.46+ i* 0.04, 0.5 + sin(iTime*20.+i*0.5)*0.004);\n        text += poly3(st, pos, 0.006 + (0.007 * smoothstep(.92, 1., sin(iTime*2.5+(text_quantity-i)))), 0.001, 4., PI, vec2(1), vec3(0.001, 0, 0)); \n    }    \n    dialog_box += text*d_box_bg_force;\n    \n    st = dialogbox_uv;\n    st = pixelate(st, 250., 200.);\n    dialog_box += poly(st, vec2(.79 + step(0., sin(iTime*50.))*0.004, .47), 0.007 + 0.002*step(0., -sin(iTime*10.)), 0.001, 3., PI/6., vec2(1.)) * (1. - 0.8*step(0., sin(iTime*10.))) * d_box_bg_force;\n \t\n    //    -------- COMPO STUFF ----------    \n    vec2 uf = gl_FragCoord.xy / iResolution.xy;\n\n    float pixelateForce = 1000. - step(0.8,sin(iTime*30.))*950.;\n    uf = pixelate(uf, pixelateForce, pixelateForce);\n    \n    uf.y -= 0.003;    \n    dib = dib + texture(iChannel0, uf).rgb * (0.7 * (curse*0.5+0.5)) * step(0.5, fract(iTime*50.));\n\n    uf.x += sin(iTime+uv.y*10.)*0.01;\n    uf.x += sin(iTime+uv.x*20.)*0.01;\n    dib = mix(texture(iChannel0, uf).rgb*0.4*curse, dib, dib);        \n    \n    \n    dib -= cheeks*10.;\n    dib -= (mouth+eyes)*20.;    \n\n    dib += vec3(cos(iTime*0.5+uv.y)*.5+.5 ,0, 1. + sin(iTime+uv.y)*.5+.5)*wisp_ring;\n    \n    dib += dialog_box;\n    \n    dib += cheeks*9.;\n    \n    dib = clamp(dib, 0., 1.); // in shadertoy you need to manually clamp the channels at the end!\n    \n    fragColor = vec4(dib, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}