{"ver":"0.1","info":{"id":"DlGBWw","date":"1702110691","viewed":126,"name":"计图19组 期末作业","username":"computergraphic19","description":"计图19组 期末作业","likes":7,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define MAX_DIST 200.\n#define MAX_ITER 200\n\n#define STEPS 256\n#define EPS (2.0/iResolution.x)\n#define FAR 6.0\n#define PI 3.14159265359\n\n#define iGT (iTime+10.0)\n\nvec2 fixUV(vec2 uv) {\n    return (2. * uv - iResolution.xy) / iResolution.x;\n}\n\nfloat random(vec2 pos) {\n    vec2 p2 = 95.1876653 * fract(pos * 10.1321513);\n    return fract((p2.x + p2.y) * p2.x * p2.y);\n}\n\n//generate a random vec2\nvec2 random2(vec2 p)\n{\n    float n = random(p);\n    return vec2(n, random(p + n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = random2(id + offset) * iTime;\n    return offset + sin(n) * .4;\n}\n\nfloat Layer_point(vec2 uv)\n{\n    uv *= 5.;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    float m = 0.;\n    vec2 p[4];\n    int i = 0;\n\n    for(float x = -1.; x <= 0.; x++){\n        for(float y = -1.; y <= 0.; y++){\n            p[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n\n    //用t加上一个twinkle效果，随着时间变化光辉会发生闪烁\n    float t = iTime * 10.;\n\n    for(i=0; i<4; i++){\n        float d = length(gv - p[i]);\n        m += smoothstep(.015, .01, d);\n        //sparkle制作一个光辉效果，距离目标点越近的像素越亮\n        vec2 j = (p[i] - gv) * 60.;\n        float sparkle = 1./dot(j, j);\n        m += sparkle * (sin(t + fract(p[i].x) * 10.) * .5 + .5);\n    }\n\n    return m;\n}\n\n\nvec3 noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6. * u * (1. - u);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    return vec3(a + (b - a) * u.x * (1. - u.y) +\n        (c - a) * (1. - u.x) * u.y +\n        (d - a) * u.x * u.y, du * (vec2(b - a, c - a) +\n        (a - b - c + d) * u.yx));\n}\n\nmat2 mat = mat2(0.6, -0.8, 0.8, 0.6);\n\nfloat ground(vec2 x) {\n    vec2 p = 0.003 * x;\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for(int i = 0; i < 8; i++) {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = mat * p * 2.;\n        b *= 0.5;\n    }\n\n    return 120. * a;\n}\n\nfloat groundH(vec2 x) {\n    vec2 p = 0.003 * x;\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for(int i = 0; i < 12; i++) {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = mat * p * 2.;\n        b *= 0.5;\n    }\n\n    return 120. * a;\n}\n\nfloat groundL(vec2 x) {\n    vec2 p = 0.003 * x;\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for(int i = 0; i < 3; i++) {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = mat * p * 2.;\n        b *= 0.5;\n    }\n\n    return 120. * a;\n}\n\n\nfloat groundM(vec2 p) {\n    float a = 0.0;\n    float b = 0.5;\n    for(int i = 0; i < 4; i++) {\n        a += b * noise(p).x;\n        p = mat * p * 2.0;\n        b *= 0.5;\n    }\n    return a;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - ground(p.xz);\n        if(abs(h) < EPSILON * t || t > tmax)\n            break;\n        t += 0.3 * h;\n    }\n    return t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float dis) {\n    float minStep = clamp(0.01 * dis, 0.5, 50.0);\n    float res = 1.0;\n    float t = 0.001;\n    for(int i = 0; i < 80; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - ground(p.xz);\n        res = min(res, 8.0 * h / t);\n        t += max(minStep, h);\n        if(res < 0.001 || p.y > 200.0)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNorm(vec3 p, float t) {\n    vec2 epsilon = vec2(0.0027 * t, 0);\n    return normalize(vec3(groundH(p.xz - epsilon.xy) - groundH(p.xz + epsilon.xy), 2.0 * epsilon.x, groundH(p.xz - epsilon.yx) - groundH(p.xz + epsilon.yx)));\n}\n\nmat3 setCamera(vec3 ro, vec3 target, float cr) {\n    vec3 z = normalize(target - ro);\n    vec3 up = normalize(vec3(sin(cr), cos(cr), 0));\n    vec3 x = cross(z, up);\n    vec3 y = cross(x, z);\n    return mat3(x, y, z);\n}\n// new adds\n// moon\nvec3 skyCol = 2.5*pow(vec3(40., 56., 84.)/255., vec3(2.2));\nvec3 moonCol = pow(vec3(168., 195., 224.)/255., vec3(2.2));\n\nvec3 fullSky(vec3 sundir, vec3 dir) {\n    vec3 clouds = vec3(0.0);\n    float s = 0.35;\n    for (int i = 0; i < 3; ++i) {\n    \tclouds += groundM(dir.xz/(dir.y+EPS)-s*iGT);\n        s *= 1.35;\n    }\n    \n    vec3 col = skyCol + 0.15*clouds*max(0.0, dir.y);\n    \n    col += max(0.0, -dir.z)*moonCol*pow(max(dot(sundir, dir), 0.0), 16.0);\n    vec2 moonPos = dir.xy/dir.z - sundir.xy/sundir.z;\n    col = mix(col, vec3(1.65), max(0.0, -dir.z)*groundM(8.5*moonPos)*smoothstep(0.37, 0.35, length(moonPos)));\n    \n    return col / (col + 1.0);\n}\n\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n\n    float an = 0.1 * iTime;\n    float r = 300.;\n    vec2 pos2d = vec2(r * sin(an), r * cos(an));\n    float h = groundL(pos2d) + 25.;\n    vec3 ro = vec3(pos2d.x, h, pos2d.y);\n    vec3 target = vec3(r * sin(an + 0.01), h, r * cos(an + 0.01));\n    mat3 cam = setCamera(ro, target, 0.);\n\n    float fl = 1.;\n    vec3 rd = normalize(cam * vec3(uv, fl));\n\n    float tmin = 0.001;\n    float tmax = 1000.;\n\n    float maxh = 300.;\n\n    float tp = (maxh - ro.y) / rd.y;\n    if(tp > 0.) {\n        if(maxh > ro.y)\n            tmax = min(tmax, tp);\n        else\n            tmin = max(tmin, tp);\n    }\n    float t = rayMarch(ro, rd, tmin, tmax);\n    vec3 sunlight = normalize(vec3(0.5, 0.5, -1.));\n    float sundot = clamp(dot(rd, sunlight), 0., 1.);\n\n    \n    if(t > tmax) {\n        vec3 l = normalize(vec3(.5, .2, -1.0));\n        col = fullSky(l, rd);\n        \n        float t1 = 0.4 * iTime;\n        float m = 0.;\n        float z = fract(t1);\n        float size = mix(1., .5, z);\n        float fade = smoothstep(0., .5, z) * smoothstep(1., .8, z);\n        m += Layer_point(uv*size) * fade;\n        vec3 base = sin(t*vec3(.345, .234, .567)) * .4 + .6;\n        col = mix(col, m * base, 0.1);\n    } else {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNorm(p, t);\n        vec3 difColor = mix(vec3(0.08, 0.05, 0.03), vec3(0.10, 0.09, 0.08), noise(p.xz * 0.02).x);\n        float r = noise(p.xz * 0.1).x;\n\n        // rocks\n        col = (r * 0.25 + 0.75) * 0.9 * difColor;\n        col = mix(col, vec3(0.09, 0.06, 0.03) * (0.5 + 0.5 * r), smoothstep(0.7, 0.9, n.y));\n        col = mix(col, vec3(0.045, 0.045, 0.015) * (0.25 + 0.75 * r), smoothstep(0.95, 1., n.y));\n        col *= 0.1 + 1.8 * sqrt(groundM(p.xz * 0.04) * groundM(p.xz * 0.005));\n        \n\n        // Snow\n        float h = smoothstep(35.0, 80.0, p.y + 35.0 * groundM(0.01 * p.xz));\n        float e = smoothstep(1.0 - 0.5 * h, 1.0 - 0.1 * h, n.y);\n        float o = 0.3 + 0.7 * smoothstep(0.0, 0.1, n.y + h * h);\n        float s = h * e * o;\n        col = mix(col, 0.29 * vec3(0.62, 0.65, 0.7), smoothstep(0.1, 0.9, s));\n\n        // Linear Lighting\n        vec3 lin = vec3(0.);\n\n        float dif = .3 * clamp(dot(sunlight, n), 0., 1.);\n        float sh = softShadow(p + 0.01 * sunlight, sunlight, t);\n        float amb =  clamp(0.5 + 0.5 * n.y, 0., 1.);\n        float bac = .6 * clamp(0.2 + 0.8 * dot(vec3(-sunlight.x, 0., sunlight.z), n), 0., 1.);\n        lin += dif * vec3(8.0, 5.0, 3.0) * 1.8 * vec3(sh, sh * sh * 0.5 + 0.5 * sh, sh * sh * 0.8 + 0.2 * sh);\n        lin += amb * vec3(0.4, 0.6, 1.) * 1.2;\n        lin += bac * vec3(0.4, 0.5, 0.6);\n\n        lin *= 0.4;\n        col *= lin;\n\n        // half-angle\n        vec3 hal = normalize(sunlight - rd);\n\n        col += (0.7 + 0.3 * s) * (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0)) *\n            vec3(7.0, 5.0, 3.0) * sh * dif *\n            pow(clamp(dot(n, hal), 0.0, 1.0), 16.0);\n\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fixUV(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(1. - exp(-col * 2.), 1.);\n}","name":"Image","description":"","type":"image"}]}