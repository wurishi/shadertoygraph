{"ver":"0.1","info":{"id":"Ns3fz8","date":"1655981197","viewed":42,"name":"MSC Shader Template","username":"MisterSirCode","description":"I really dont like shadertoy's default template.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = mapScaleY(fragCoord, iResolution.xy);\n    vec2 ms = mapScaleY(iMouse.xy, iResolution.xy);\n    vec2 ck = mapScaleY(iMouse.zw, iResolution.xy);\n    \n    fragColor = color(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mapScaleX(vec2 pos, vec2 map) { return (2.0 * pos - map.xy) / map.x; }\n\nvec2 mapScaleY(vec2 pos, vec2 map) { return (2.0 * pos - map.xy) / map.y; }\n\nvec4 color(float v) { return vec4(vec3(v), 1.0); }\n\nvec4 color(vec2 v) { return vec4(v, 0.0, 1.0); }\n\nvec4 color(vec3 v) { return vec4(v, 1.0); }\n\n// All this noise stuff comes from here: https://www.shadertoy.com/view/4dS3Wd\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nfloat fbm(float x, int oct) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < oct; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x, int oct) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < oct; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x, int oct) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < oct; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}","name":"Common","description":"","type":"common"}]}