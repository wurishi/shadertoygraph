{"ver":"0.1","info":{"id":"7lsfW8","date":"1650869638","viewed":142,"name":"simple single cosine water wave","username":"batersy","description":"a simple implementation of single cosine water wave,\nimplement cosine wave and cosine exponent k model on directional or circular waves","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wave","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * simple water cosine wave by batersy\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// a simple implementation of single cosine water wave reference on\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models\n// implement cosine wave and cosine exponent k model\n// on directional or circular waves\n\nfloat wavelength = 6.0;\nfloat amplitude = 0.5;\nfloat frequency = 0.2;\nvec3 lightDir = normalize(vec3(1,1,1));\nfloat cameraHeight = 4.0;\nfloat n1 = 1.000293;\nfloat n2 = 1.33;\nvec3 waterColor = vec3(30,144,255) / 255.0;\n\n// wave type 0-cosine 1-cosine exponent\n#define WAVE_TYPE 1\n// power exponent of cosine\nint cosineExponent = 6;\n// wave direction type 0-directional 1-circular\n#define WAVE_DIRECTION_TYPE 1\n// directional wave direction\nvec2 waveDir = normalize(vec2(-1,1));\n// circular wave center\nvec2 circularWaveCenter = vec2(10);\n\n// raymarching config\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t100\n#define MIN_STEP_LEN        0.01\n\nvec4 waveSdf(float amplitude, float wavelength, float frequency, vec2 dir, vec3 pos) {\n    vec3 normal = vec3(0);\n#if WAVE_DIRECTION_TYPE==WAVE_DIRECTION_TYPE_DIR\n    dir = waveDir;\n#else\n    dir = normalize(pos.xz - circularWaveCenter);\n#endif\n    float x = dot(pos.xz, dir);\n    float phase = TWO_PI * (frequency * iTime - x / wavelength);\n#if WAVE_TYPE==WAVE_TYPE_COSINE\n    // use vertical length as sdf distance, with the requirement that\n    // wavelength should be enough bigger than amplitude\n    float d = pos.y - amplitude * cos(phase);\n    if (d <= 0.0) {\n        normal.xz = -sin(phase) * dir;\n        normal.y = wavelength / TWO_PI / amplitude;\n        normal = normalize(normal);\n    }\n#else\n    float inside = 0.5 * cos(phase) + 0.5;\n    float d = pos.y - 2.0 * amplitude * pow(inside, float(cosineExponent));\n    if (d <= 0.0) {\n        normal.xz = -pow(inside, float(cosineExponent - 1)) * sin(phase) * dir;\n        normal.y = wavelength / TWO_PI / amplitude / float(cosineExponent);\n        normal = normalize(normal);\n    }\n#endif\n    return vec4(d, normal);\n}\n\nfloat getReachDistance(vec3 ro, vec3 rd, float height) {\n    if (ro.y < height) return 0.;\n    return (ro.y - height) / rd.y;\n}\n\nfloat rayMarching(vec3 ro, vec3 rd, out vec3 normal) {\n    float dis = getReachDistance(ro, rd, amplitude), tmpDis;\n    if(dis > RAY_LENGTH_MAX) return -1.0;\n    vec3 pos = ro + dis * rd;\n    vec4 sdf;\n    for (int i = 0; i < RAY_STEP_MAX; ++i) {\n        sdf = waveSdf(amplitude, wavelength, frequency, waveDir, pos);\n        tmpDis = max(sdf.x, MIN_STEP_LEN);\n        dis += tmpDis;\n        if (sdf.x <= 0.0) {\n            normal = sdf.yzw;\n            break;\n        }\n        pos += rd * tmpDis;\n    }\n    if (sdf.x > 0.) return -1.0;\n    return dis;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0);\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float angleX = 3.5 * mo.x;\n    float angleY = 3.5 * mo.y;\n    vec3 ro = vec3(0, cameraHeight, 0);\n    vec3 ta = vec3(cos(angleX)*cos(angleY), cameraHeight + sin(angleY), sin(angleX)*cos(angleY));\n    mat3 cam2World = LookAt(ro, ta, angleY);\n    vec3 rd = cam2World * normalize(vec3(p.xy, -1.0));\n    \n    vec3 normal;\n    float d = rayMarching(ro, rd, normal);\n    if(d > 0.) {\n        float f = fresnel(n1, n2, dot(-rd, normal));\n        vec3 refl = texture(iChannel0, reflect(rd, normal)).rgb;\n        vec3 refr = texture(iChannel0, refract(rd, normal, n1 / n2)).rgb;\n        float diffuse = dot(normal, lightDir);\n        color += 0.2 * diffuse * waterColor + 0.8 * mix(refr, refl, f);\n    } else {\n        color = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor = vec4(pow(color, vec3(1.0/2.2)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define WAVE_TYPE_COSINE 0\n#define WAVE_TYPE_COSINE_EXP 1\n#define WAVE_DIRECTION_TYPE_DIR 0\n#define WAVE_DIRECTION_TYPE_CIR 1\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530717958647692\n\nfloat fresnel(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float n1cosi = n1 * cosi;\n    float n1cost = n1 * cost;\n    float n2cosi = n2 * cosi;\n    float n2cost = n2 * cost;\n    float Rs = (n1cosi - n2cost) / (n1cosi + n2cost); Rs *= Rs;\n    float Rp = (n1cost - n2cosi) / (n1cost + n2cosi); Rp *= Rp;\n    return 0.5 * (Rs + Rp);\n}\n\nmat3 LookAt(vec3 eye, vec3 at, float angle) {\n    vec3 zaxis = normalize(eye - at);\n    vec3 up = sign(cos(angle)) * vec3(0,1,0);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n","name":"Common","description":"","type":"common"}]}