{"ver":"0.1","info":{"id":"WllGzH","date":"1555652198","viewed":156,"name":"Differential Mandelbrot","username":"rory618","description":"Next version of https://www.shadertoy.com/view/Wtl3z8, this time varying power. Mouse to control zoom.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal","ad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R (iResolution.xy)\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float p = 2. + 3.*(-cos(float(iFrame)/400.)+1.);\n    float scale = pow(p,-1.5)/30.*exp(iMouse.x==0.?0.:-4.+12.*iMouse.y/R.y);\n\tvec2 c = (I-R.xy/2.)/R.y*scale;\n    c += texture(iChannel0, vec2(0)).zw;\n    float col=0.;\n    \n    vec2 z = vec2(0);\n    for(int i = 0; i < 128; i++){\n        \n        z = cpow(z,p) + c;\n        if(length(z) > 16.){\n            col = float(i);\n            break;\n        }\n    }\n    \n\tO =  vec4(sin(5.+.25*log(1.+col)*vec3(3,4,5)),1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define R (iResolution.xy)\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    if(iFrame<3){\n    \to = vec4(-1.8,.001,-1.8,.001);\n    } else {\n        vec4 oMouse = texture(iChannel3, vec2(0));\n        o = texture(iChannel1, i/R.xy);\n        float scale = 16.;\n        vec2 c = o.xy;\n\n        float p = 2. + 3.*(-cos(float(iFrame)/400.)+1.);\n        vec2 dpdt = vec2(3.*sin(float(iFrame)/400.)/400. ,0);\n\n        float col=0.;\n\t\tbool convergent = false;\n        /*vec2 z = cpow(c,p) + c;\n        vec2 dzdc = vec2(1,0) + cpow(c,p-1.)*p;\n        vec2 dzdp = cprod(cpow(c,p)*p,clog(c));*/\n        vec2 z = c;\n        vec2 dzdc = vec2(1,0);\n        vec2 dzdp = vec2(0);\n        int i;\n        for(i = 0; i < 64; i++){\n\t\t\tvec2 z_p = cpow(z,p);\n            dzdc = vec2(1,0) + cprod(cpow(z,p-1.)*p,dzdc);\n            dzdp = cprod(clog(z),z_p) + cprod(cpow(z,p-1.)*p,dzdp);\n            z = z_p + c;\n            if(length(z) > 2.){\n                convergent = true;\n                break;\n            }\n        }\n\n        vec2 dcdt = -cdivide(cprod(dzdp,dpdt),dzdc);\n        //if(iMouse.z>0. && oMouse.z>0.){\n            \n            \n            \n            \n            if(convergent){\n        \t\to.xy += dcdt;\n            }\n    \t//} else {\n        //    o = texture(iChannel1, i/R.xy);\n        //}\n        vec2 toEdge = -cdivide(z,dzdc);\n        o.xy += (convergent)?toEdge*(i>55?-1.:1.):vec2(0);\n        o.zw = mix(o.zw,o.xy,.4);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define IM vec2(0,1)\n#define RE vec2(1,0)\n#define PI 3.14159\n#define E 2.71828\n\n//cproj\nfloat creal(vec2 z) {\n    return z.x;\n}\nfloat cimag(vec2 z) {\n    return z.y;}\nvec2 conj(vec2 z) {\n    return vec2(z.x,-z.y);\n}\nvec2 cprod(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 csqr(vec2 a){\n    return cprod(a,a);\n}\nfloat cabs(vec2 z) {\n    return sqrt(cprod(z,conj(z)).x);\n}\nfloat cabs2(vec2 z) {\n    return cprod(z,conj(z)).x;\n}\nvec2 cinv(vec2 z){\n    return conj(z)/cabs2(z);\n}\nvec2 cdivide(vec2 a, vec2 b){\n    return cprod(a,cinv(b));\n                            }\nfloat carg(vec2 z) {\n    vec2 nz = normalize(z);\n    return atan(nz.y/(nz.x+1.))*2.;\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\nvec2 clog(vec2 z) {\n    return vec2(log(cabs(z)), carg(z));\n}\nvec2 cpow(vec2 a, float b) {\n    return cexp(b*clog(a));\n}\nvec2 csqrt(vec2 z){\n    return cpow(z, .5);\n}\nvec2 csinh(vec2 z){\n    return (cexp(z)-cexp(-z))/2.;\n}\nvec2 ccosh(vec2 z){\n    return (cexp(z)+cexp(-z))/2.;\n}\nvec2 ctanh(vec2 z){\n    return cdivide(csinh(z),ccosh(z));\n}\nvec2 casinh(vec2 z){\n    return clog(z + csqrt(RE + cprod(z,z)));\n}\nvec2 cacosh(vec2 z){\n    return clog(z + csqrt(z + RE) + csqrt(z - RE));\n}\nvec2 catanh(vec2 z){\n    return (clog(z + RE) + clog(z - RE))/2.;\n}\nvec2 csin(vec2 z){\n    return cprod(-IM,csinh(cprod(IM,z)));\n}\nvec2 ccos(vec2 z){\n    return ccosh(cprod(IM,z));\n}\nvec2 ctan(vec2 z){\n    return cprod(-IM,ctanh(cprod(IM,z)));\n}\nvec2 casin(vec2 z){\n    return cprod(-IM,casinh(cprod(IM,z)));\n}\nvec2 cacos(vec2 z){\n    return RE*PI/2.+cprod(IM, clog(cprod(IM,z) + csqrt(RE + cprod(z,z))));\n}\nvec2 catan(vec2 z){\n    return cprod(-IM,catanh(cprod(IM,z)));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n#define R (iResolution.xy)\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = iMouse;\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}