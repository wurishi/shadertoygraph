{"ver":"0.1","info":{"id":"tddfRB","date":"1605489269","viewed":141,"name":"Partial Sphere","username":"Firal","description":"The shader for Day 2 of my self-imposed 30 shaders in 30 days challenge (not all will be made public).\n\nAn example of a sphere / circle sdf that is only rendered partially around. In a very Pac-Man like fashion.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","sphere","circle","partial","firal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://www.shadertoy.com/view/tddfRB\nMade by Firal (Zack Misso)\n*/\n\n#define ANIM_SPEED 0.35\n\n// The sdf for a sphere which is partially rendered. It is computed as the combined sdf\n// between a sphere, and two planes intersecting the sphere according to the angle which\n// is passed in as a parameter.\nfloat sdPartialSphere(vec3 p, float r, float max_angle)\n{\n    // hard coding axis and normal for now. The normal is the direction tangential to\n    // both of the lips. Axis is where the lips start\n    vec3 axis = vec3(0.0, 1.0, 0.0);\n    vec3 norm = vec3(0.0, 0.0, 1.0);\n    //max_angle = 0.0;\n    \n    // compute the tanget vector\n    vec3 tang = cross(norm, axis);\n    \n    // we want the angle between the projection onto the tangent\n    float angle = acos(dot(normalize(vec3(p.x, p.y, 0.0)), axis));\n    \n    if (angle < max_angle)\n    {\n        // compute the closest lip, the other can be ignored\n        float max_a = max_angle * sign(dot(tang, p));\n        \n        // direction of the closest 'lip'\n        vec3 dir = vec3(axis.x * cos(max_a) - axis.y * sin(max_a),\n                        axis.x * sin(max_a) + axis.y * cos(max_a),\n                        0.f);\n\n        \n        // normal vector for the plane of the 'lip'\n        vec3 norm_dir = cross(norm, dir);\n        \n        // project the point onto the infinite plane\n        vec3 plane_point = p - norm_dir * dot(p, norm_dir);\n        \n        // project the point back onto the intersection between the sphere and the plane.\n        plane_point = max(sign(dot(dir, plane_point)), 0.0) * \n            \t\t  min(length(plane_point), r) * \n            \t\t  normalize(plane_point);\n        \n        // project the point onto the base line of the sphere\n        vec3 base_p = p;\n        base_p.z = 0.0;\n\n        // return the min of the projected point and the distance to the center line.\n        return min(length(base_p), length(p-plane_point));\n    }\n    \n    // compute distance to the sphere\n    float dist = length(p) - r;\n    \n    // TODO: there is probably some optimization I can do to avoid these if statements, but\n    //       I'll look into that later.\n    // if the point is inside the sphere, we need to correctly account for the 'lips'\n    if (dist < 0.0 && max_angle != 0.0)\n    {\n        // compute the closest lip, the other can be ignored\n        float max_a = max_angle * sign(dot(tang, p));\n        \n        // direction of the closest 'lip'\n        vec3 dir = vec3(axis.x * cos(max_a) - axis.y * sin(max_a),\n                        axis.x * sin(max_a) + axis.y * cos(max_a),\n                        0.f);\n        \n        // normal vector for the plane of the 'lip'\n        vec3 norm_dir = cross(norm, dir);\n        \n        // project the point onto the infinite plane\n        vec3 plane_point = p - norm_dir * dot(p, norm_dir);\n        \n        // project the point back onto the intersection between the sphere and the plane.\n        plane_point = max(sign(dot(dir, plane_point)), 0.0) * \n            \t\t  min(length(plane_point), r) * \n            \t\t  normalize(plane_point);\n        \n        // project the point onto the base line of the sphere\n        vec3 base_p = p;\n        base_p.z = 0.0;\n\n        // return the min of the projected point and the distance to the center line. Returns\n        // the negative since the point is inside the sdf.\n        return -min(length(base_p), min(-dist, length(p-plane_point)));\n    }\n    \n    \n    return dist;\n}\n\n// creates a fancy little animation progress bar\nvec3 shade_progress_bar(vec2 p, vec2 res, float z)\n{\n    // have to take account of the aspect ratio\n    float xpos = p.x * res.y / res.x;\n    \n    if (xpos > z - 0.01 && xpos < z + 0.01) return vec3(1.0);\n    else return vec3(0.0);\n}\n\n// the shading routine. Modified version of iq's\n// https://www.shadertoy.com/view/3ltSW2\nvec3 shade(float sd)\n{\n    vec3 col = vec3(1.0) - sign(sd) * vec3(0.9,0.4,0.2);\n    \n    col *= 1.0 - exp(-6.0*abs(sd));\n\tcol *= 0.8 + 0.2*cos(140.0*sd);\n\tcol = mix( col, vec3(1.0, 0.0, 0.0), 1.0-smoothstep(0.0,0.02,abs(sd)) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float angle = 3.14 * cos(ANIM_SPEED * iTime);\n    vec3 world_p = vec3(p*1.3, 0.6 * cos(iTime * ANIM_SPEED));\n\t\n    if (p.y < -0.95)\n        fragColor = vec4(shade_progress_bar(p, iResolution.xy, angle / 3.14), 1.0);\n    else\n        fragColor = vec4(shade(sdPartialSphere(world_p, 1.0, abs(angle))), 1.0);\n}","name":"Image","description":"","type":"image"}]}