{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Based on Polyhedron again by Knighty :\n//https://www.shadertoy.com/view/XlX3zB\n\n\n#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n#define time iTime\n\nfloat Type;\nfloat cospin, scospin;\nvec3 nc,ot;\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\nvec3 dmul( vec3 a, vec3 b )  {\n    float r = length(a);\n    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.yz=cmul(normalize(a.yz), b.yz);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    \n    return r*b;\n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<6 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\n\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n\nfloat map( vec3 p)\n{\n\tfloat dr = 1.0;\n\tot = vec3(1000.0);\n\tfloat r2;\n\n\tfor( int i=0; i<4;i++ )\n\t{            \n       \tr2 = dot(p,p);      \n       \tif(r2>16.)continue;\n\t\t            \n       \tp=1.5*fold(p);dr*=1.5;p=p.zxy-.5;\n        dr=2.*sqrt(r2)*dr;\n        p=dmul(p,p)-.3;\n        \n        ot = min( ot, abs(p)/(.5+r2) );\n                   \n\t}\n    \n\treturn .3*length(p)*log(length(p))/dr;\t\n       \t\n}\n\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.2 + (iMouse.y-0.5*iResolution.y)*PI2/360.);\n    p.zx = rotate(p.zx, iTime * 0.125 + (0.5*iResolution.x-iMouse.x)*PI2/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tType=(fract(0.025*time)*3.5)+2.;//4.5;\n\tcospin=cos(PI/(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin),ot;\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(.3);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat dif = clamp(dot(nor, li), 0.0, 1.0);\n        vec3 col1 =.5*(ot+ot.grb);\n        col1.r+=.5*col1.g-.3*col1.b;\n        nor = reflect(rd, nor);\n        col1 += pow(max(dot(li, nor), 0.0), 25.0)*vec3(1.);\n\t    col = .3+.6*mix( col, col1, t );\n        col = col * dif;\n        col = pow(col, vec3(0.5));\n\t}\n    \n   \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tsGzB","date":"1423086397","viewed":295,"name":"Polyhedron fold","username":"guil","description":"Based on Polyhedron again by Knighty :\nhttps://www.shadertoy.com/view/XlX3zB","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","polyhedron"],"hasliked":0,"parentid":"","parentname":""}}