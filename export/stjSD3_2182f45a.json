{"ver":"0.1","info":{"id":"stjSD3","date":"1628791425","viewed":258,"name":"20210813","username":"0b5vr","description":"haha","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["ifs","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec4 tex = texture( iChannel0, uv );\n\n  vec3 color = tex.rgb / tex.a;\n  color = pow( color, vec3( 0.4545 ) );\n\n  fragColor = vec4( color, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// render\n\n#define saturate(i) clamp(i,0.,1.)\n\nconst float PI = acos( -1. );\nconst float TAU = PI * 2.0;\nconst float EPSILON = 1E-4;\nconst float FAR = 1E3;\n\nvec4 seed;\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\n// Ref: https://cs.uwaterloo.ca/~thachisu/tdf2015.pdf\nfloat random() {\n  const vec4 q = vec4( 1225, 1585, 2457, 2098 );\n  const vec4 r = vec4( 1112, 367, 92, 265 );\n  const vec4 a = vec4( 3423, 2646, 1707, 1999 );\n  const vec4 m = vec4( 4194287, 4194277, 4194191, 4194167 );\n    vec4 beta = floor( seed / q );\n    vec4 p = a * ( seed - beta * q ) - beta * r;\n    beta = ( sign( -p ) + vec4( 1 ) ) * vec4( 0.5 ) * m;\n    seed = ( p + beta );\n    return fract( dot( seed / m, vec4( 1, -1, 1, -1 ) ) );\n}\n\nvec2 random2() {\n  return vec2( random(), random() );\n}\n\nvec3 randomSphere() {\n  float phi = TAU * random();\n  float theta = acos( 1.0 - 2.0 * random() );\n  return vec3(\n    cos( phi ) * sin( theta ),\n    sin( phi ) * sin( theta ),\n    cos( theta )\n  );\n}\n\nvec3 randomHemisphere( vec3 N ) {\n  vec3 d = randomSphere();\n  return dot( N, d ) < 0.0 ? -d : d;\n}\n\nmat3 orthBas( vec3 d ) {\n  vec3 z = normalize( d );\n  vec3 x = normalize( cross(\n    abs( z.y ) < 0.999 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ),\n    z\n  ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nvec3 F_Schlick( vec3 f0, float VdotH ) {\n  float v = 1.0 - VdotH;\n  return mix( f0, vec3( 1.0 ), ( v * v ) * ( v * v ) * v );\n}\n\nfloat G_Smith( float roughness, float NdotV, float NdotL ) {\n  float k = roughness;\n  k = k * k;\n  k /= 2.0;\n\n  float G1V = NdotV / ( NdotV * ( 1.0 - k ) + k );\n  float G1L = NdotL / ( NdotL * ( 1.0 - k ) + k );\n\n  return G1V * G1L;\n}\n\nvec3 importanceSampleLambert( vec3 N ) {\n  float phi = TAU * random();\n  float cosTheta = random();\n  cosTheta = cos( asin( sqrt( cosTheta ) ) );\n  cosTheta = saturate( cosTheta );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nvec3 importanceSampleGGX( float roughness, vec3 N ) {\n  float phi = TAU * random();\n  float cosTheta = random();\n  cosTheta = sqrt( ( 1.0 - cosTheta ) / ( 1.0 + ( pow( roughness, 4.0 ) - 1.0 ) * cosTheta ) );\n  cosTheta = saturate( cosTheta );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nstruct Material {\n  vec3 albedo;\n  float roughness;\n  float metallic;\n  vec3 emissive;\n};\n\nstruct MarchResult {\n  float d;\n  Material mtl;\n};\n\nfloat sdbox( vec3 p, vec3 s ) {\n  vec3 d = abs( p ) - s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nvec3 ifs( vec3 p, vec3 r, vec3 s, int iter ) {\n  mat3 b = orthBas( r );\n  for( int i = 0; i < 10; i ++ ) {\n    if ( i >= iter ) { break; }\n    p = abs( p );\n    p.xz = p.x < p.z ? p.xz : p.zx;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    p.yz = p.y < p.z ? p.yz : p.zy;\n    s *= b;\n    s *= 0.58;\n    p = abs( p ) - abs( s );\n  }\n  return p;\n}\n\nMarchResult map( vec3 p ) {\n  float d = 1E9;\n  float d2;\n  Material mtl;\n  \n  vec3 rot = vec3( 1.4, 1.8, 2.2 );\n  vec3 shift = vec3( 3.2, 3.8, 3.5 );\n  \n  vec3 pt = p;\n  pt = ifs( pt, rot, shift, 4 );\n  d2 = sdbox( pt, vec3( 0.44 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.0;\n    mtl.metallic = 0.0;\n    mtl.emissive = 20.0 * vec3( 19.0, 0.1, 0.7 );\n  }\n\n  pt = p;  \n  pt.y = mod( pt.y - 1.0, 2.0 ) - 1.0;\n  d2 = -sdbox( pt, vec3( 20.0 ) );\n  d2 = max( d2, length( abs( pt.y ) ) - 0.2 );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.04, 0.05, 0.06 );\n    mtl.roughness = 0.7;\n    mtl.metallic = 0.7;\n    mtl.emissive = vec3( 0.0 );\n  }\n  \n  pt = ifs( p, rot, shift, 7 );\n  d2 = sdbox( pt, vec3( 0.16 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.04, 0.05, 0.06 );\n    mtl.roughness = 0.2;\n    mtl.metallic = 0.7;\n    mtl.emissive = vec3( 0.0 );\n  }\n  \n  pt = p;\n  d2 = sdbox( pt, vec3( 0.5, 100.0, 0.5 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.0;\n    mtl.metallic = 0.0;\n    mtl.emissive = 20.0 * vec3( 2.0, 2.2, 3.7 );\n  }\n\n  return MarchResult( d, mtl );\n}\n\nvec3 nMap( vec3 p, vec2 d ) {\n  return normalize( vec3(\n    map( p + d.yxx ).d - map( p - d.yxx ).d,\n    map( p + d.xyx ).d - map( p - d.xyx ).d,\n    map( p + d.xxy ).d - map( p - d.xxy ).d\n  ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  seed = texture( iChannel0, uv );\n  seed += float( iFrame );\n  random();\n\n  vec2 p = ( fragCoord.xy + random2() - 0.5 ) / iResolution.xy - 0.5;\n  p.x *= iResolution.x / iResolution.y;\n  \n  vec3 cp = vec3( 5.0, 3.0, 5.0 );\n  vec3 ct = vec3( 0.0 );\n  mat3 cm = orthBas( normalize( cp - ct ) );\n\n  vec3 ro = cm * vec3( 15.0 * p, 10 );\n  vec3 rd = cm * vec3( 0, 0, -1 );\n\n  vec3 col = vec3( 0 );\n  vec3 colRem = vec3( 1 );\n\n  for ( int iRef = 0; iRef < 6; iRef ++ ) {\n    float rl = 1E-2;\n    vec3 rp = ro + rd * rl;\n    MarchResult result;\n    \n    for ( int i = 0; i < 140; i ++ ) {\n      result = map( rp );\n      rl += 0.7 * result.d;\n      rp = ro + rd * rl;\n    }\n\n    if ( result.d > 1E-2 ) {\n      // col += 0.5 * colRem;\n      break;\n    }\n    col += result.mtl.emissive * saturate( colRem );\n    \n    vec3 N = nMap( rp, vec2( 0.0, 1E-4 ) );\n\n    ro = rp + N * EPSILON;\n\n    vec3 albedo = mix( 0.96 * result.mtl.albedo, vec3( 0.0 ), result.mtl.metallic );\n    vec3 f0 = mix( vec3( 0.04 ), result.mtl.albedo, result.mtl.metallic );\n\n    if ( random() < 0.5 ) {\n      // specular\n      // Ref: http://gregory-igehy.hatenadiary.com/entry/2015/02/26/154142\n      vec3 H = importanceSampleGGX( result.mtl.roughness, N );\n      vec3 wo = reflect( rd, H );\n      if ( dot( wo, N ) < 0.0 ) { break; }\n\n      float VdotH = dot( -rd, H );\n      float NdotL = dot( N, wo );\n      float NdotH = dot( N, H );\n      float NdotV = dot( N, -rd );\n      vec3 F = F_Schlick( f0, VdotH );\n      float G = G_Smith( result.mtl.roughness, NdotV, NdotL );\n\n      colRem *= F * G * VdotH / ( NdotH * NdotV );\n      rd = wo;\n    } else {\n      // diffuse\n      vec3 wo = importanceSampleLambert( N );\n      vec3 H = normalize( -rd + wo );\n\n      float VdotH = dot( -rd, H );\n      vec3 F = F_Schlick( f0, VdotH );\n\n      colRem *= ( 1.0 - F ) * albedo;\n      rd = wo;\n    }\n\n    colRem *= 2.0;\n\n    if ( dot( colRem, colRem ) < EPSILON ) {\n      break;\n    }\n  };\n\n  fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // accumulate using backbuffer\n  fragColor = texture( iChannel0, uv );\n\n  if ( iFrame > 1 ) {\n    fragColor += texture( iChannel1, uv );\n  }\n}","name":"Buffer B","description":"","type":"buffer"}]}