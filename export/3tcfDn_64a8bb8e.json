{"ver":"0.1","info":{"id":"3tcfDn","date":"1612484732","viewed":144,"name":"density-based cloud shader","username":"itsjonebone","description":"From the creator of this 2D noise shader ( https://www.shadertoy.com/view/3lcfz7 )\nand its thrilling 3D sequel ( https://www.shadertoy.com/view/tttfz7 )\ncomes the all-new density-based shader\n(use the mouse to pan and get a sense of depth)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","cloud","perlin","worley","gpupro7"],"hasliked":0,"parentid":"tttfz7","parentname":"3d noise shader"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// image will be comprised of t x t tiles\nfloat t = 2.0; \n// noises start generation with freq x freq cells\nfloat freq = 4.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // create tiles\n    //uv *= t;\n    // add time XY animation\n    //uv -= 0.05 * iTime;\n    \n    uv = fract(uv);\n    \n    vec2 m = iMouse.xy/iResolution.y;\n    m = (m * 2. - 1.);\n    m /= 8.;\n    \n    float freq = 4.;\n    float z_slices = 4.; // for now going much higher than 5 produces significant frame loss\n    \n    float density = 0.;\n    \n    for (float w = 0.; w <= 1.; w += 1. / z_slices) {\n        // using the full cloud FBM is what primarily causes lag\n        //float c = cloud(vec3(uv - ((1. - w) * m), w), freq);\n        //c = remap(c, 0.69, 1., 0., 1.);\n        float c = perlin_worley(vec3(uv - ((1. - w) * m), w), freq);\n        c = remap(c, 0.5, 1., 0., 1.);\n        density += (.8 - (w * .5)) * c;\n    }          \n    \n    vec3 col = vec3(density);\n    \n    \n    // Output color\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// *** noisemaking in here *** ////\n\n// remapping as described by Schneider's chapter in GPU Pro 7\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec3 poi_gen (vec3 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    // NB: side effect of fract is that all values will be positive \n    return fract(sin(vec3(\n                dot(gridIndex + 1.0, vec3(127.4, 723.8, 872.4)),\n                dot(gridIndex + 1.0, vec3(387.4, 275.4, 567.6)),\n                dot(gridIndex + 1.0, vec3(837.7, 208.7, 576.4)) )) * 25787.33);\n}\n// => !! NB: this needs replacing with a lookup \n\n\n/// Inverse Worley Noise \nfloat worley(vec3 p, float freq) {\n    // split p into id and position\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    \n    float minDist = 1000.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 offset = vec3(x, y, z);\n                vec3 poi = poi_gen(mod(id + offset, vec3(freq))); // use mod for tiling\n                poi += offset;\n                vec3 diff = poi - pos;\n                minDist = min(minDist, length(diff));\n            }\n        }\n    }\n    return 1.0 - minDist; // inverting noise\n}\n\n/// Compound Worley Noise\n// uses the Worley FBM described by Schneider's chapter in GPU Pro 7\nfloat worleyFBM(vec3 p, float freq) {\n    return worley(p * freq, freq) * 0.625 +\n           worley(p * freq * 2., freq * 2.) * 0.25 +\n           worley(p * freq * 4., freq * 4.) * 0.125;\n}\n\n//// PERLIN\n// Perlin noise is a varient of gradient noise\n// gradient noise works by interpolating between random values at cell corners\n// Perlin noise does the same interpolation of values\n// but the Perlin values are found by taking the dot product of \n// a normal vector in a random direction from a cell corner\n// and the vector from that cell corner to the point in question\n// for more check out http://physbam.stanford.edu/cs448x/old/Procedural_Noise(2f)Categories.html\n\n/// Perlin Hash\nvec3 hash(vec3 p) {\n    vec3 poi = poi_gen(p);\n    // my poi_gen function makes values between 0 and 1\n    // this limits the directionality if we used poi_gen alone to get vectors\n    // below is a simplified remap from 0...1 to -1...1 \n    poi = vec3(-1.) + (poi * 2.);\n    return normalize(poi);\n}\n\n/// Perlin noise generator \n// get vectors using perlin hash\n// dot vectors by (offset - pos)\n// interpolate values\nfloat perlin(vec3 uvw, float freq) {\n    vec3 p = uvw * freq;\n    // split into ID and position\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    \n    // dotted vals\n    float a0 = dot(hash(mod(id + vec3(0., 0., 0.), freq)), pos - vec3(0., 0., 0.));\n    float b0 = dot(hash(mod(id + vec3(1., 0., 0.), freq)), pos - vec3(1., 0., 0.));\n    float c0 = dot(hash(mod(id + vec3(0., 1., 0.), freq)), pos - vec3(0., 1., 0.));\n    float d0 = dot(hash(mod(id + vec3(1., 1., 0.), freq)), pos - vec3(1., 1., 0.));\n    \n    float a1 = dot(hash(mod(id + vec3(0., 0., 1.), freq)), pos - vec3(0., 0., 1.));\n    float b1 = dot(hash(mod(id + vec3(1., 0., 1.), freq)), pos - vec3(1., 0., 1.));\n    float c1 = dot(hash(mod(id + vec3(0., 1., 1.), freq)), pos - vec3(0., 1., 1.));\n    float d1 = dot(hash(mod(id + vec3(1., 1., 1.), freq)), pos - vec3(1., 1., 1.));\n    \n    //smooth interpolation\n    //vec3 u = smoothstep(0., 1., pos);\n    \n    // quintic interpolation (6pos^5 - 15pos^4 + 10pos^3)\n    vec3 u = pos * pos * pos * (pos *(pos * 6.0 - 15.0) + 10.0);\n    \n    // interpolation based on iq's blog article on gradient noise\n    // https://iquilezles.org/articles/gradientnoise\n    return a0 + \n           u.x *(b0 - a0) + \n           u.y *(c0 - a0) + \n           u.z *(a1 - a0) + \n           u.x * u.y * (a0 - b0 - c0 + d0) + \n           u.y * u.z * (a0 - c0 - a1 + c1) + \n           u.z * u.x * (a0 - b0 - a1 + b1) + \n           u.x * u.y * u.z * (-a0 + b0 + c0 - d0 + a1 - b1 - c1 + d1);\n    \n}\n\n\n/// Multi-octave perlin noise compounder\nfloat perlinFBM(vec3 p, float freq, int octaves) {\n    float noise = 0.;\n    float w = 0.5;\n    float c = 1.;\n    for (int i = 0; i < octaves; ++i) {\n        noise += w * perlin(p , freq * c);\n        c = c * 2.;\n        w *= 0.5;\n    }\n    return noise;\n}\n\n/// Puffy Perlin\n// had to do some witchcraft here to look like figure 4.5 in GPU Pro 7\n// tbh not sure why it was like this\nfloat puffyPerlin(vec3 p, float freq) {\n    float puff = abs(abs(perlinFBM(p, freq, 7)) * 2. - 1.);\n    return remap(puff, 1., 0., 0., 1.);\n}\n\n//// PerlinWorley\n\n/// Perlin-Worley noise combined\n// puffy Perlin noise is remapped with Worley as the new min\nfloat perlin_worley(vec3 uvw, float freq) {\n    float w = worleyFBM(uvw, freq);\n    float p = puffyPerlin(uvw, freq);\n    return remap(p, 0., 1., w, 1.);\n}\n\n/// cloud\n// a combination of Perlin-Worley noise and a few octaves of Worley noise\n// described in GPU Pro 7 within the \"Cloud Sampler\" section\nfloat cloud(vec3 uvw, float freq) {\n    float pw = perlin_worley(uvw, freq);\n    float wg = worleyFBM(uvw, freq);\n    float wb = worleyFBM(uvw, freq * 2.);\n    float wa = worleyFBM(uvw, freq * 4.);\n    \n    float wfbm = wg * .625 + wb * .25 + wa * 0.125;\n    \n    return remap(pw, wfbm - 1., 1., 0., 1.);\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}