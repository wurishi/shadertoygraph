{"ver":"0.1","info":{"id":"fsjBzy","date":"1646560899","viewed":609,"name":"Tinsel starfield","username":"trapped_in_a_while_loop","description":"Space Bar: Colorful, Right/Left: resolution. Enjoy.\n\nDemo for: https://github.com/tiawl/spaceporn\n\nIf you have any advice to improve it, I will be happy to read you.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["pixel","star","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define BufferAChannel  iChannel0\n# define BufferBChannel  iChannel1\n\nfloat pixel_res;\nuint seed;\nfloat pix;\nconst float depth = 1. / 360.;\n\n# define BIGSTARS_DENSITY 4.5\n# define MAX_BIGSTAR_SZ 8.\n\n# define DIAMOND 0u\n# define NOVA    1u\n# define POLAR   2u\n\n# define SWIRLS_RADIUS 0.5\n\nstruct Star\n{\n  uint type;\n  vec2 center;\n  float size;\n  float power;\n  float brightness;\n  uint shape;\n  float diag;\n  float ring_size;\n};\n\nfloat floor2(float x, float base)\n{\n  return floor(x / base) * base;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle(vec2 p, float r)\n{\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat opRing(vec2 p, float r1, float r2)\n{\n  return abs(sdCircle(p, r1)) - r2;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k)\n{\n  float h = max(k - abs(a - b), 0.);\n  return max(a, b) + h * h * 0.25 / k;\n}\n\nvec2 rotation(vec2 p, float a)\n{\n  return p * mat2(cos(a), -sin(a),\n                  sin(a),  cos(a));\n}\n\n// 3D hash function to simulate seeding:\n// https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3d(uvec3 v)\n{\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * v.z;\n  v.y += v.z * v.x;\n  v.z += v.x * v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y * v.z;\n  v.y += v.z * v.x;\n  v.z += v.x * v.y;\n\n  return v;\n}\n\n// https://www.shadertoy.com/view/XlGcRh\nfloat hash(vec2 s, uint hash_seed)\n{\n  float res;\n  uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y));\n  uvec3 p = pcg3d(uvec3(u.x, u.y, hash_seed));\n  res = float(p) * (1. / float(0xffffffffu));\n  return res;\n}\n\nfloat noise(vec2 coord, uint noise_seed)\n{\n  vec2 i = floor(coord);\n  vec2 f = fract(coord);\n  f = f * f * (3. - 2. * f);\n\n  float a = hash(i, noise_seed);\n  float b = hash(i + vec2(1., 0.), noise_seed);\n  float c = hash(i + vec2(0., 1.), noise_seed);\n  float d = hash(i + vec2(1., 1.), noise_seed);\n\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n// https://www.shadertoy.com/view/MslGWN\nvec3 nrand3(vec2 co)\n{\n  float a = hash(co, 98u);\n  float b = hash(co, 99u);\n  float c = mix(a, b, 0.5);\n  return vec3(c);\n}\n\n// https://www.shadertoy.com/view/MslGWN\nfloat stars(vec2 uv)\n{\n  vec3 rnd = nrand3(uv);\n  float r = rnd.y;\n  float starcolor = r * r * r * r * r;\n\n  if (starcolor > 0.3)\n  {\n    float brighness_variance = max(0.15, hash(uv, 94u) / 2.);\n    return starcolor + abs(sin((iTime * 10. + hash(uv, 94u)) *\n      hash(uv, 95u))) * brighness_variance\n      - (brighness_variance / 2.);\n  } else {\n    return 0.;\n  }\n}\n\n// https://www.shadertoy.com/view/NsfyDs\nfloat circles(vec2 p, float r, float w, uint s)\n{\n  vec3 col;\n  vec2 i = floor(p), f = fract(p), h;\n  int k, q;\n\n  float d = (sign(w) > -0.5 ? 8. : -1e9), c, rad, h2;\n  for (k = -1; k < 2; k++)\n  {\n    for (q = -1; q < 2; q++)\n    {\n      p = vec2(k, q);\n      h = vec2(hash(i + p, s + 89u), hash(i + p, s + 52u));\n      c = length(p + h - f);\n    \n      if (sign(w) > -0.5)\n      {\n        // https://iquilezles.org/articles/smoothvoronoi\n        col = 0.5 + 0.5 * sin(hash(i + p, seed + 32u) * 2.5 + 3.5 + vec3(2.));  \t\t\n        h2 = smoothstep(0., 1., 0.5 + 0.5 * (d - c) / w);\n\t    d = mix(d, c, h2) - h2 * (1. - h2) * w / (1. + 3. * w);\n      } else {\n        rad = r / 2. + hash(i + p, s + 2u) * r;\n        d = smax(d, rad - c, 0.3);\n      }  \n    }\n  }\n  return (sign(w) > -0.5 ? 1. - d : d);\n}\n\nfloat fbmVoronoi(vec2 U, uint seed)\n{\n  float r = (circles(1.5 * U, -1., 0.3, seed)) * 0.625\n    + (circles(3. * U, -1., 0.3, seed + 314u)) * 0.25\n    + (circles(6. * U, -1., 0.3, seed + 92u)) * 0.125;\n  return r;\n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat fbmCircles(vec2 p, uint se)\n{\n  float s = 1., d = 0.;\n  uint o = 2u;\n  for (uint i = 0u; i < o; i++)\n  {\n    float n = s * circles(p, 0.5, -1., se + i);\n\n    d = smax(d, n, 0.3 * s);\n\n    p *= 2.;\n    s = 0.5 * s;\n  }\n  return d;\n}\n\n// original author warned against discontinuities that I did not fix:\n// https://www.shadertoy.com/view/fsKSWD\nvec2 swirls(vec2 p, uint se, float ro)\n{\n  vec2 i = round(p), d, cc;\n  int k, q;\n  float r, h;\n  for (k = -1; k < 2; k++)\n  {\n    for (q = -1; q < 2; q++)\n    {\n      cc = i + vec2(k, q);\n      d = cc + vec2(hash(cc, se + 222u), hash(cc, se + 278u)) - vec2(0.5);\n      h = hash(cc, se + 72u)  * 2. - 1.;\n      p -= d;\n      r = ro * sign(h) * smoothstep(0., SWIRLS_RADIUS, (SWIRLS_RADIUS - length(p)) * abs(h));\n      p = rotation(p, r) + d;\n    }\n  }\n  return p;\n}\n\nvec2 fbmSwirls(vec2 p, uint se)\n{\n  uint o = 3u;\n  float sz = 42., ro = 1.5;\n  p *= 360. / sz;\n  for (uint i = 0u; i < o; i++)\n  {\n    p = swirls(p, se + i, ro);\n  }\n  return p / (360. / sz);\n}\n\nfloat diamond(vec2 coords, Star star)\n{\n  star.brightness = 1. / star.brightness;\n  vec2 A = vec2(-star.size,         0.);\n  vec2 B = vec2( star.size,         0.);\n  vec2 C = vec2(        0.,  star.size);\n  vec2 D = vec2(        0., -star.size);\n\n  float s1 = sdSegment(coords, A, B) - depth;\n  float s2 = sdSegment(coords, C, D) - depth;\n  float m = min(s1, s2);\n\n  float color = (sign(m) < 0.5 ? -1. : 0.);\n  color *= 1. - (abs(coords.x) + abs(coords.y)) * star.brightness;\n\n  float ring = opRing(coords, star.size * star.ring_size,\n    depth * BIGSTARS_DENSITY * (100. / pix) * 1.5);\n  ring = (sign(ring) < 0.5 ? -1. : 0.);\n  color = min(color * 1.3, ring * 0.5 * star.power);\n\n  return color;\n}\n\nfloat novapattern(vec2 coords, Star star)\n{\n  float res = 1e9;\n  coords = abs(coords);\n  if ((star.size / star.diag >= 1.5 * pixel_res) && (star.shape > 24u))\n  {\n    vec2 A = vec2(3. * pixel_res,      pixel_res);\n    vec2 B = vec2(     pixel_res, 3. * pixel_res);\n    vec2 C = vec2(2. * pixel_res,      pixel_res);\n    vec2 D = vec2(     pixel_res, 2. * pixel_res);\n    float s1 = sdSegment(coords, A, B) - depth;\n    float s2 = sdSegment(coords, C, D) - depth;\n    res = min(res, min(s1, s2));\n  } else if (star.shape > 24u) {\n    vec2 A = vec2(2. * pixel_res,      pixel_res);\n    vec2 B = vec2(     pixel_res, 2. * pixel_res);\n    res = min(res, sdSegment(coords, A, B) - depth);\n  }\n  if ((star.shape >= 30u) && (star.shape <= 32u))\n  {\n    if (star.size / star.diag >= 1.5 * pixel_res)\n    {\n      vec2 A = vec2(5. * pixel_res, 2. * pixel_res);\n      vec2 B = vec2(4. * pixel_res, 2. * pixel_res);\n      vec2 C = vec2(2. * pixel_res, 4. * pixel_res);\n      vec2 D = vec2(2. * pixel_res, 5. * pixel_res);\n      float s1 = sdSegment(coords, A, B) - depth;\n      float s2 = sdSegment(coords, C, D) - depth;\n      res = min(res, min(s1, s2));\n    } else {\n      vec2 A = vec2(3. * pixel_res, 3. * pixel_res);\n      vec2 B = vec2(5. * pixel_res, 5. * pixel_res);\n      res = min(res, sdSegment(coords, A, B) - depth);\n    }\n  } else if ((star.shape >= 33u) && (star.shape <= 35u)) {\n    if (star.size / star.diag >= 1.5 * pixel_res)\n    {\n      vec2 A = vec2(5.  * pixel_res, 2.  * pixel_res);\n      vec2 B = vec2(4.5 * pixel_res, 2.  * pixel_res);\n      vec2 C = vec2(2.  * pixel_res, 4.5 * pixel_res);\n      vec2 D = vec2(2.  * pixel_res, 5.  * pixel_res);\n      float s1 = sdSegment(coords, A, B) - depth;\n      float s2 = sdSegment(coords, C, D) - depth;\n      res = min(res, min(s1, s2));\n    } else {\n      vec2 A = vec2(3. * pixel_res, 3. * pixel_res);\n      vec2 B = vec2(5. * pixel_res, 5. * pixel_res);\n      res = min(res, sdSegment(coords, A, B) - depth);\n    }\n  } else if ((star.shape >= 36u) && (star.shape <= 38u)) {\n    if (star.size / star.diag >= 1.5 * pixel_res)\n    {\n      vec2 A = vec2(4.  * pixel_res, 2.  * pixel_res);\n      vec2 B = vec2(3.5 * pixel_res, 2.  * pixel_res);\n      vec2 C = vec2(2.  * pixel_res, 3.5 * pixel_res);\n      vec2 D = vec2(2.  * pixel_res, 4.  * pixel_res);\n      float s1 = sdSegment(coords, A, B) - depth;\n      float s2 = sdSegment(coords, C, D) - depth;\n      res = min(res, min(s1, s2));\n    } else {\n      vec2 A = vec2(3. * pixel_res, 3. * pixel_res);\n      vec2 B = vec2(5. * pixel_res, 5. * pixel_res);\n      res = min(res, sdSegment(coords, A, B) - depth);\n    }\n  }\n  return res;\n}\n\nfloat nova(vec2 coords, Star star)\n{\n  star.brightness = 1. / star.brightness;\n\n  float size = (star.shape == 39u ? 17. * pixel_res / star.size :\n    (star.shape == 40u ? 11. * pixel_res / star.size : star.size));\n  vec2 A = vec2(            -size,                0.);\n  vec2 B = vec2(             size,                0.);\n  vec2 C = vec2(               0.,              size);\n  vec2 D = vec2(               0.,             -size);\n  vec2 E = vec2(-size / star.diag,  size / star.diag);\n  vec2 F = vec2( size / star.diag, -size / star.diag);\n  vec2 G = vec2( size / star.diag,  size / star.diag);\n  vec2 H = vec2(-size / star.diag, -size / star.diag);\n\n  float s1 = sdSegment(coords, A, B) - depth;\n  float s2 = sdSegment(coords, C, D) - depth;\n  float s3 = sdSegment(coords, E, F) - depth;\n  float s4 = sdSegment(coords, G, H) - depth;\n  float m = min(min(min(s1, s2), min(s3, s4)), novapattern(coords, star));\n\n  float color = (sign(m) < 0.5 ? -1. : 0.);\n  color *= 1. - (abs(coords.x) + abs(coords.y)) * star.brightness;\n\n  size = (star.shape > 38u ? star.size * 0.35 + 70. / pix : star.size);\n  float ring = opRing(coords, size * star.ring_size,\n    depth * BIGSTARS_DENSITY * (100. / pix) * (star.size / pixel_res > 7. ? 1. : 1.5));\n  ring = (sign(ring) < 0.5 ? -1. : 0.);\n  color = min(color * 1.3, ring * 0.5 * star.power);\n\n  return color;\n}\n\nfloat polar(vec2 coords, Star star)\n{\n  star.brightness = 1. / star.brightness;\n\n  vec2 A = vec2(            -star.size,                                 0.);\n  vec2 B = vec2(             star.size,                                 0.);\n  vec2 C = vec2(                    0.,  star.size / (star.diag * 2. / 3.));\n  vec2 D = vec2(                    0., -star.size / (star.diag * 2. / 3.));\n  vec2 E = vec2(-star.size / star.diag,              star.size / star.diag);\n  vec2 F = vec2( star.size / star.diag,             -star.size / star.diag);\n  vec2 G = vec2( star.size / star.diag,              star.size / star.diag);\n  vec2 H = vec2(-star.size / star.diag,             -star.size / star.diag);\n\n  float s1 = sdSegment(coords, A, B) - depth;\n  float s2 = sdSegment(coords, C, D) - depth;\n  float s3 = sdSegment(coords, E, F) - depth;\n  float s4 = sdSegment(coords, G, H) - depth;\n  float m = min(min(s1, s2), min(s3, s4));\n\n  float color = (sign(m) < 0.5 ? -1. : 0.);\n  color *= 1. - (abs(coords.x) + abs(coords.y)) * star.brightness;\n\n  float ring = opRing(coords, star.size * star.ring_size,\n    depth * BIGSTARS_DENSITY * (100. / pix) * (star.size / pixel_res > 7. ? 1. : 1.5));\n  ring = (sign(ring) < 0.5 ? -1. : 0.);\n  color = min(color * 1.3, ring * 0.5 * star.power);\n\n  return color;\n}\n\nfloat calc_star(vec2 coords, vec2 center)\n{\n  float type = hash(center, seed + 2u);\n  uint rd_bigstar = (type < 0.15 ? NOVA : (type < 0.3 ? POLAR : DIAMOND));\n  float size_hash = hash(center, seed + 3u) * 0.05;\n  float min_size = (rd_bigstar == DIAMOND ? 3. : 7.);\n  float max_size = MAX_BIGSTAR_SZ - min_size;\n  float size =\n    (min(floor(size_hash * (max_size + 1.)), max_size) + min_size) * pixel_res * (pix / 150.);\n  float brightness = hash(center, seed + 4u) + 1.;\n  float ring_size = hash(center, seed + 5u) * 0.8;\n  ring_size = (ring_size * size < pixel_res * 4. ? 0. : ring_size);\n  float power = round(sin(iTime * (3. + 4. * hash(center, seed + 6u)))) * 0.2 + 1.;\n\n  float star = 0.;\n  Star bigstar =\n    Star(rd_bigstar, center, size, power, 1., 0u, 1., ring_size);\n  if (bigstar.type == DIAMOND)\n  {\n    bool rotated = hash(bigstar.center, seed + 7u) > 0.5;\n    bigstar.brightness *= bigstar.size;\n    bigstar.brightness *= bigstar.power;\n    coords = rotation(coords, radians(rotated ? 45. : 0.));\n    star = diamond(coords, bigstar);\n  } else if (bigstar.type == NOVA) {\n    bigstar.shape = uint(ceil(hash(bigstar.center, seed + 7u) * 38.));\n    bigstar.diag = (bigstar.shape > 38u ? 0. :\n      (bigstar.shape < 25u ?\n        1. + hash(bigstar.center, seed + 8u) * 3.5 :\n        hash(bigstar.center, seed + 8u) > 0.5 ? bigstar.size / pixel_res :\n        2. + hash(bigstar.center, seed + 9u) * 3.));\n    bigstar.brightness = (bigstar.shape > 38u ?\n      100. / pix : bigstar.size * bigstar.brightness);\n    bigstar.brightness *= bigstar.power;\n    star = nova(coords, bigstar);\n  } else {\n    bigstar.brightness *= bigstar.size;\n    bigstar.brightness *= bigstar.power;\n    bigstar.diag = 2.5 + hash(bigstar.center, seed + 7u) * 0.5;\n    star = polar(coords, bigstar);\n  }\n  return star;\n}\n\nvec3 bigstars(vec2 coords)\n{\n  coords *= BIGSTARS_DENSITY;\n  float d = 1e9, c;\n\n  pixel_res = BIGSTARS_DENSITY / pix;\n\n  vec2 i = floor(coords);\n  vec2 f = fract(coords);\n  vec2 h, o, p, center, tmp;\n\n  for (int k = 0; k < 9; k++)\n  {\n    o = vec2(k % 3, k / 3) - 1.;\n\n    center = i + o;\n    h = vec2(hash(center, seed), hash(center, seed + 1u));\n    p = vec2(floor2(o.x + h.x - f.x, pixel_res),\n      floor2(o.y + h.y - f.y, pixel_res));\n\n    c = calc_star(p, center);\n    if (c < d)\n    {\n      d = c;\n      tmp = p;\n    }\n  }\n  \n  vec2 U = (coords + tmp) / BIGSTARS_DENSITY;\n  float fv = fbmVoronoi(U, seed);\n  \n  return vec3(-d * fv * fv * 0.5, U * pix);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec3 rgb = clamp(abs(mod(c.x * 6.\n    + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n// https://www.slynyrd.com/blog/2018/1/10/pixelblog-1-color-palettes\nvec3 color(float sm, uint cseed)\n{\n  float var = 0.01 * sin(iTime * 50.);\n  float hu, sa = 0., br = 0.;\n  sa += var * 2.;\n  hu = radians(6.2832 * (9. * hash(vec2(1.), cseed)\n    + sm * (hash(vec2(10.), cseed) * 0.25)));\n  if (sm < 2.5)\n  {\n    sa += 0.2 + 0.15 * sm;\n  } else if (sm < 4.5) {\n    sa += 0.35 + 0.1 * (sm - 2.);\n  } else {\n    sa += 0.55 - 0.07 * (sm - 4.);\n  }\n  if (sm < 3.5)\n  {\n    br += 0.1 + 0.1 * sm;\n  } else if (sm < 6.5) {\n    br += 0.5 + 0.075 * (sm - 3.);\n  } else {\n    br += 0.7 + 0.1 * (sm - 6.);\n  }\n  return hsv2rgb(vec3(hu, sa, br));\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n  seed = 1u + uint(floor(iTime * 0.5));\n  uint col_seed = uint(floor(iTime * 0.5));\n  bool multicolor = (abs(texelFetch(BufferAChannel, ivec2(u), 0).x) > 0.5);\n  pix = round(texelFetch(BufferAChannel, ivec2(u), 0).y);\n  float cols = multicolor ? 8. : 18.;\n  \n  vec2 text = texelFetch(BufferBChannel, ivec2(u), 0).yz;\n  if (text.y > 0.)\n  {\n    O = vec4((0.6 + 0.6 * cos(6.3 *\n      ((u.x * 6. - iResolution.x * 0.25) / (3.14 * iResolution.y)) + vec4(0, 23, 21, 0))\n      * 0.85 + 0.15) * text.x);\n    return;\n  }\n  \n  vec2 bU = 2. + (u / iResolution.y) + iTime * 0.05;\n  vec2 U = floor(bU * pix);\n  bool dith = mod(U.x + U.y, 2.) < 1.;\n  U /= pix;\n  \n  float fv = fbmVoronoi(U, seed);\n  vec2 aU = fbmSwirls(U, seed) * 10.;\n  float g = max(fbmCircles(aU, seed + 10u), fbmCircles(aU, seed + 20u));\n  g = smax(-1., g, 3.2) * fv * fv * (multicolor ? 0.7 : 1.);\n  g *= (dith ? 1.35 : 1.5);\n  \n  vec3 b = bigstars(U) * vec3(4., 1., 1.);\n\n  if (multicolor)\n  {\n    U *= 360.;\n    float sta = stars(U);\n    if ((b.x > 0.) && (b.x > g))\n    {\n      U = b.yz;\n      g = b.x;\n    } else if (sta > g) {\n      g = sta;\n      fv = fv * fv;\n    }\n    g = floor(g * cols) / cols;\n    vec3 col = vec3(2. * noise(U * 0.025, 47u), 2.5 * noise(U * 0.025, 52u), 3.);\n    O = vec4(g * col * fv, 1.);\n  } else {\n    g = max(b.x, g);\n    g = floor(g * cols) / cols;\n    O = vec4(color(10. * g, col_seed), 1.);\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define BufferAChannel  iChannel0\n# define KeyboardChannel iChannel1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  fragColor =   texelFetch(BufferAChannel, ivec2(fragCoord), 0);\n  float space = texelFetch(KeyboardChannel, ivec2(KEY_SPACE, 0), 0).x;\n  float right = texelFetch(KeyboardChannel, ivec2(KEY_RIGHT, 0), 0).x;\n  float left =  texelFetch(KeyboardChannel, ivec2(KEY_LEFT, 0), 0).x;\n\n  fragColor.x = (space > 0.5 ? 1. : 0.);\n  \n  if ((right > 0.5) && (fragColor.y < iResolution.y))\n  {\n    fragColor.y += 5.;\n  }\n  if ((left > 0.5) && (fragColor.y > 50.))\n  {\n    fragColor.y -= 5.;\n  }\n  if ((iFrame < 1) || (fragColor.w != iResolution.y))\n  {\n    fragColor = vec4(0., 150., 0., iResolution.y);\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"# define KEY_SPACE 32\n# define KEY_LEFT  37\n# define KEY_RIGHT 39","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    --------------------------------------------------------------------------------------------\n       until mainImage function: dirty copy-pasting from https://www.shadertoy.com/view/Xd2fzK\n    --------------------------------------------------------------------------------------------\n*/\n\n# define BufferBChannel  iChannel0\n# define KeyboardChannel iChannel1\n# define fontChannel     iChannel2\n# define BufferAChannel  iChannel3\n# define SPACE_CHAR 0x02U\n# define STOP_CHAR 0x0AU\n\nconst int[] FONT_NB = int[](0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73, 0x83, 0x93);\n\nvec4 fontCol;\nvec3 fontColFill;\nvec3 fontColBorder;\nvec4 fontBuffer;\nvec2 fontCaret;\nfloat fontSize;\nfloat fontSpacing;\nvec2 fontUV;\n\nfloat log10(float x)\n{\n  if (x < 9.5)\n  {\n    return 0.;\n  } else if (x < 99.5) {\n    return 1.;\n  } else if (x < 999.5) {\n    return 2.;\n  } else if (x < 9999.5) {\n    return 3.;\n  } else if (x < 99999.5) {\n    return 4.;\n  } else {\n    return floor(log(x) / log(10.));\n  }\n}\n\nvec4 fontTextureLookup(vec2 xy){\n  float dxy = 1024. * 1.5;\n  vec2 dx = vec2(1., 0.) / dxy;\n  vec2 dy = vec2(0., 1.) / dxy;\n  return (\n           texture(fontChannel, xy + dx + dy) +\n           texture(fontChannel, xy + dx - dy) +\n           texture(fontChannel, xy - dx - dy) +\n           texture(fontChannel, xy - dx + dy) +\n      2. * texture(fontChannel, xy)\n  ) / 6.;\n}\n\nvoid drawStr4(uint str)\n{\n  if (str < 0x100U)\n  {\n    str = str * 0x100U + SPACE_CHAR;\n  }\n    \n  if (str < 0x10000U)\n  {\n    str = str * 0x100U + SPACE_CHAR;\n  }\n  \n  if (str < 0x1000000U)\n  {\n    str = str * 0x100U + SPACE_CHAR;\n  }  \n  \n  for (int i = 0; i < 4; i++)\n  {\n    uint xy = (str >> 8 * (3 - i)) % 256U;\n    if (xy != SPACE_CHAR)\n    {\n      vec2 K = (fontUV - fontCaret) / fontSize;\n      if (length(K) < 0.6)\n      {\n        vec4 Q = fontTextureLookup((K + vec2(float(xy / 16U) + 0.5,\n          16. - float(xy % 16U) - 0.5)) / 16.);\n        fontBuffer.rgb += Q.rgb * smoothstep(0.6, 0.4, length(K));\n\n        if (max(abs(K.x), abs(K.y)) < 0.5)\n        {\n          fontBuffer.a = min(Q.a, fontBuffer.a);\n        }\n      }\n    }\n      \n    if (xy != STOP_CHAR)\n    {\n      fontCaret.x += fontSpacing * fontSize;\n    }\n  }\n}\n\nvoid beginDraw()\n{\n  fontBuffer = vec4(0., 0., 0. , 1.);\n  fontCol = vec4(0.);\n  fontCaret.x += fontSpacing * fontSize / 2.;\n}\n\nvoid endDraw()\n{\n  float a = smoothstep(1., 0., smoothstep(0.51, 0.53, fontBuffer.a));\n  float b = smoothstep(0., 1., smoothstep(0.48, 0.51, fontBuffer.a));\n    \n  fontCol.rgb = mix(fontColFill, fontColBorder, b);\n  fontCol.a = a;\n}\n\nvoid _(uint str)\n{\n  beginDraw();\n  drawStr4(str);\n  endDraw();\n}\n\nvoid _(uvec2 str)\n{\n  beginDraw();\n  drawStr4(str.x);\n  drawStr4(str.y);\n  endDraw();\n}\n\nvoid _(uvec3 str)\n{\n  beginDraw();\n  drawStr4(str.x);\n  drawStr4(str.y);\n  drawStr4(str.z);\n  endDraw();\n}\n\nvoid _(uvec4 str)\n{\n  beginDraw();\n  drawStr4(str.x);\n  drawStr4(str.y);\n  drawStr4(str.z);\n  drawStr4(str.w);\n  endDraw();\n}\n\nvec2 viewport(vec2 b)\n{\n  return (b / iResolution.xy - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n}\n\n/*\n   ---------------------------------------------------------------------------------------\n    end of copy-pasting\n   ---------------------------------------------------------------------------------------\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float pix = round(texelFetch(BufferAChannel, ivec2(fragCoord), 0).y);\n\n  fragColor = texelFetch(BufferBChannel, ivec2(fragCoord), 0);\n  fragColor.z = (fragColor.x > 0. ? fragColor.z : 0.);\n  float space = texelFetch(KeyboardChannel, ivec2(KEY_SPACE, 0), 0).x;\n  float right = texelFetch(KeyboardChannel, ivec2(KEY_RIGHT, 0), 0).x;\n  float left =  texelFetch(KeyboardChannel, ivec2(KEY_LEFT, 0), 0).x;\n\n  vec2 coord = viewport(fragCoord);\n  fontCaret = vec2(-0.8, 0.4);\n  fontSize = 0.1;\n  fontSpacing = 0.45;\n  fontUV = coord;\n  fontColFill = vec3(1.);\n  fontColBorder = vec3(0.);\n    \n  if (space > 0.5)\n  {\n    _(uvec2(0x34F6C6F6, 0x276657C6));\n    fragColor = vec4(-1., fontCol.x, fontCol.w, 0.);\n  } else if ((left > 0.5) || (right > 0.5)) {\n    float chars = log10(pix) + 1.;\n    fontCaret.x -= 0.05 * (4. - chars);\n    float p = pix, power;\n    int str = 0x02020202;\n    while (chars > 0.5)\n    {\n      chars -= 1.;\n      power = pow(10., chars);\n      str = (str << 8) + FONT_NB[int(p / power)];\n      p = floor(mod(p, power));\n    }\n    _(uvec3(str, 0x02079687, 0x56C63702));\n    fragColor = vec4(iTime, fontCol.x, fontCol.w, 0.);;\n  }\n    \n  if (((fragColor.x > 0.) && (iTime - fragColor.x > 1.)) || (iFrame < 1))\n  {\n    fragColor = vec4(0.);\n  }\n}","name":"Buffer B","description":"","type":"buffer"}]}