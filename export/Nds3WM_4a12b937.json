{"ver":"0.1","info":{"id":"Nds3WM","date":"1616061919","viewed":87,"name":"Mediated Life","username":"alexshortt","description":"Raymarching Volume turned Art Piece\n\nRemix of https://www.shadertoy.com/view/7sf3W7","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volume","raymarch","cloud"],"hasliked":0,"parentid":"7sf3W7","parentname":"Raymarching Volume"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// camera from https://www.shadertoy.com/view/4dcBRN\nmat3 camera(vec3 ro, vec3 ta, float cr ) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// fbm from https://www.shadertoy.com/view/lss3zr\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n ) { \n    return fract(sin(n)*43758.5453); \n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\n\n// smin from the legend iq \nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n#define VOL_STEPS 6\n#define VOL_LENGTH 10.\n#define VOL_DENSITY 0.15\n\n#define SHA_STEPS 24\n#define SHA_LENGTH 10.\n#define SHA_DENSITY 0.8\n\n#define DLIGHT_DIR normalize(vec3(1., 2., 1.))\n#define DLIGHT_COL vec3(1., 0., 0.)\n\n#define ALIGHT_COL vec3(0.94, 0.94, 0.94)\n#define ALIGHT_DENSITY 0.1\n\n#define VOL_1_COL vec3(0.08, 0.02, 0.02)\n#define VOL_2_COL vec3(0.1, 1., 0.)\n\n#define EXTINCTION_COL vec3(0.6, 0.6, 1.)\n\nfloat jitter;\n\n// returns (color, depth)\nvec4 volume( vec3 p )\n{\n    // get noise value\n    float t = iTime * 0.38;\n    \n    vec3 q = 1. * (p - vec3(0.0,0.5,1.0) * t * 0.5);\n    float f = fbm(q);\n\n    float f2 = fbm(p - vec3(0.0,-0.5,-1.0) * t * 0.5);\n    \n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    float s2 = 0.3 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n    \n    float s3_1 = length(p * 0.2 - vec3(cos(t * 3.) * 6., sin(f2) * 2., sin(t * 3.) * 6.));\n    float s3_2 = length(p * 2. - vec3(0.0, sin(f2) * 4., cos(t * 2.) * 3.));\n    float s3_3 = length(p * 3. - vec3(cos(t * 2.) * 3., 0.0, sin(f2 * 3.3) * 7.));\n    float s3 = 1.0 - smin(smin(s3_1 ,s3_2 , 4.0), s3_3, 4.0) + f * 2.5;\n    \n    float d = mix(s1, s3, 0.5);\n    float perc1 = abs(s1) / mix(s1, s3, 0.5);\n    vec3 color = mix(VOL_2_COL, VOL_1_COL, perc1);\n    \n    return vec4( color, min(max(0.0, d), 1.0) );\n}\n\nvec4 raymarchVolume(vec3 rot, vec3 ray) {\n    float stepLength = VOL_LENGTH / float(VOL_STEPS);\n    float shadowStepLength = SHA_LENGTH / float(SHA_STEPS);\n    \n    float volumeDensity = VOL_DENSITY * stepLength;\n    float shadowDensity = SHA_DENSITY * shadowStepLength;\n    vec3 dlight = DLIGHT_DIR * shadowStepLength;\n    \n    float density = 0.;\n    float transmittance = 1.;\n    vec3 energy = vec3(0.);\n    vec3 pos = rot + ray * jitter * stepLength;\n    \n    // raymarch\n    for (int i = 0; i < VOL_STEPS; i++) {\n        vec4 vol = volume(pos);\n        float dsample = vol.a;\n        vec3 vol_color = vol.rgb * 0.2;\n        \n        if(transmittance < 0.1) break;\n        \n        if (dsample > 0.001) {\n            vec3 lpos = pos;\n            float shadow = 0.;\n            \n            // raymarch shadows\n            for (int s = 0; s < SHA_STEPS; s++) {\n                lpos += dlight;\n                vec4 lsample = volume(lpos);\n                shadow += lsample.a;\n            }\n            \n            // combine shadow with density\n            density = clamp(dsample * volumeDensity, 0., 1.);\n            vec3 shadowterm = exp(-shadow * vec3(shadowDensity) / (EXTINCTION_COL + vol_color));\n            vec3 absorbedlight = shadowterm * density;\n            energy += absorbedlight * transmittance;\n            transmittance *= 1. - density;     \n            \n            // ambient lighting\n            shadow = 0.;\n            vec4 asample = vec4(0.);\n            for (float s = 0.; s < 3.; s++) {\n                lpos = pos + vec3(0., 0., 0.05 + s * 1.3);\n                asample = volume(lpos);\n                shadow += asample.a;\n            }\n            \n            energy += exp(-shadow * ALIGHT_DENSITY) * density * ALIGHT_COL * transmittance / vol_color;\n        }\n\n        pos += ray * stepLength;\n    }\n    \n    return vec4(energy, transmittance);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up raycast\n    vec2 origin = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 rot = vec3(cos(iTime * .3) * 8., -5.5, sin(iTime * .3) * 8.);\n    vec3 tran = vec3(0.0, 1., 1.0);\n    mat3 cam = camera(rot, tran, 0.0);\n    vec3 ray = cam * normalize(vec3(origin, 3.));\n    \n    jitter = 0. * hash(origin.x + origin.y * 70.0 + iTime);\n    vec4 col = raymarchVolume(rot, ray);\n    \n    // Output to screen\n    vec3 top_col = vec3(.99);\n    vec3 bot_col = vec3(.94);\n    vec3 result = col.rgb + mix(top_col, bot_col, -origin.y) * (col.a);\n\n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}