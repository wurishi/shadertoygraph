{"ver":"0.1","info":{"id":"X3sBR7","date":"1728277804","viewed":58,"name":"texture uv mapping","username":"letbonsaibe","description":"test some kind of uv mapping tech in raymarching, click to zoom out","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","texture","uvmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define SMOOTH2(r,R) (1.0-smoothstep(R-0.01, R+0.01, r))\n#define SS(r,R) (smoothstep(r-0.005, r+0.005, R))\n#define ROT(p, a) (mat2(cos(a),-sin(a),sin(a),cos(a))*p)\n\n// tile mode copied from https://www.shadertoy.com/view/fdK3DD\n\n\n// used in vscode shadertoy plugin\n/*\n#iChannel0 \"file://./media/london.jpg\" \n#iChannel0::MinFilter \"NearestMipMapNearest\"\n#iChannel0::MagFilter \"Nearest\"\n#iChannel0::WrapMode \"Repeat\"\n\n#iChannel1 \"file://./media/tile.png\" \n#iChannel1::MinFilter \"Nearest\"\n#iChannel1::MagFilter \"Nearest\"\n#iChannel1::WrapMode \"Repeat\"\n*/\n\n\nfloat stroke(float x, float s, float w) { \n    float d = SS(s, x + w / 2.) - SS(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\n\nfloat fill(float x, float size) { \n    return 1. - SS(size, x);\n}\n\n\nfloat sdCircle(vec2 st) { \n    return length(st - 0.5) * 2.;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\n\nvec3 draw(vec2 st, vec2 tileXY, vec2 count) {\n\n\n    int cardNumber = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    switch(cardNumber) {    \n    case 0: {  // how to load texture\n     \n        return texture(iChannel0, st).xyz;\n    }\n    case 1: {  // texture warp clamp\n        return texture(iChannel0, st * 2.0).xyz;\n    }\n    case 2: {  // texture filter linear\n        return texture(iChannel0, st * 0.2).xyz;\n    }    \n    case 3: { // texture filter nearest \n        st = st * 2.0 - 1.0;\n        float a = atan(st.y, st.x);\n        float r = length(st);\n        vec2 uv = vec2( 0.3/r + 0.2*iTime, a/PI ); \n        vec3 color = texture(iChannel1, uv).xyz;\n        color = color*r;                                           \n        return color;\n    }\n    }\n    \n    \n    vec3 color = vec3(0.0);\n    st = st * 2.0 - 1.0;\n    vec3 ro = vec3(0, 3, -3);\n    float t = 0.1 * iTime;\n    ro.yz *= Rot(-t*PI+1.);\n    ro.xz *= Rot(-t*TAU);\n    switch(cardNumber) {  \n    case 4: { // plane maping in raymarching\n        int idx = 1;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            \n            vec2 uv = p.xz;\n            color =  texture(iChannel2,uv ).xyz * dif;\n        }\n        break;\n    }\n    case 5: { // box mapping2 in raymarching\n        int idx = 2;\n    \n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n   \n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            vec3 cXZ =  texture(iChannel2, p.xz ).xyz ;\n            vec3 cYZ =  texture(iChannel2, p.yz ).xyz ;\n            vec3 cXY =  texture(iChannel2, p.xy ).xyz ;\n            color = cXZ * abs(n.y)+ cXY * abs(n.z) + cYZ * abs(n.x);\n        }\n        break;\n    }\n    case 6: { //\n        int idx = 3;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            \n            float theta = atan(p.z, p.x); // angle around the Y-axis\n            float u = 0.5 + theta / (2.0 * 3.14159); // map theta to [0,1]\n            float v = (p.y + 2.5 / 2.0) / 2.5; // map height to [0,1]\n           \n            color =  texture(iChannel2, vec2(u,v) ).xyz ;\n            break;\n           \n        }\n        break;\n    }\n    case 7: {   // triplanar mapping\n        int idx = 4 ;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n   \n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            vec3 cXZ =  texture(iChannel2, p.xz * 0.5 + 0.5 ).xyz ;\n            vec3 cYZ =  texture(iChannel2, p.yz * 0.5 + 0.5  ).xyz ;\n            vec3 cXY =  texture(iChannel2, p.xy * 0.5 + 0.5  ).xyz ;\n            n = abs(n);\n            n = pow(n, vec3(10.0));\n            n /= n.x + n.y + n.z;\n            color = cXZ * abs(n.y)+ cXY * abs(n.z) + cYZ * abs(n.x);\n            //color = n;\n            break;\n        }\n        break;\n    }\n\n    case 8: {  // wrong when object tranform\n        ro = vec3(0, 3, -3);\n        int idx = 5;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            \n            vec2 uv = p.xz;\n            color =  texture(iChannel2,uv ).xyz * dif;\n        }\n        break;\n    }\n    \n    case 9: { \n        ro = vec3(0, 3, -3);\n        int idx = 5;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            p = Transform(p, iTime, idx);\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            \n            vec2 uv = p.xz;\n            color =  texture(iChannel2,uv ).xyz * dif;\n        }\n        break;\n    }\n    case 10: {\n       ro = vec3(0, 3, -3);\n        int idx = 6;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n        float d = RayMarch(ro, rd, idx, iTime);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            p = Transform(p, iTime, idx);\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            \n              \n            float theta = atan(p.z, p.x); // angle around the Y-axis\n            float u = 0.5 + theta / (2.0 * 3.14159); // map theta to [0,1]\n            float v = p.y  /1.5;\n            u = fract(u + iTime*0.2);\n            color =  texture(iChannel3,vec2(u,v) ).xyz * dif;\n        }\n        break;\n    \n    }\n    case 11: {\n        \n        ro = vec3(0, 2, -4);\n        int idx = 7;\n        vec3 rd = GetRayDir(st, ro, vec3(0,0.,0), 1.);\n        float d = RayMarch(ro, rd, idx, iTime);\n        \n        // sky uv\n        vec2 sky_uv =  fract(1.8 * rd.xz/abs(rd.y + 0.11)* 0.1);\n        //sky_uv.y *= 0.;\n        color += texture(iChannel1, sky_uv).xyz * smoothstep(0.,0.1, rd.y);\n        \n        \n        //color = mix( color, vec3(0.5, 0.7, .9), exp(-20.0*max(rd.y+0.2 - 0.08,0.0)) );  \n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            p = Transform(p, iTime, idx);\n            vec3 n = GetNormal(p, idx);\n            vec3 r = reflect(rd, n);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            \n            // ground uv\n            vec2 uv = p.xz;\n            vec2 w = fwidth(uv);    // filter kernel\n            vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))/w;   // analytical integral (box filter)\n            float grid = 0.5 - 0.5*i.x*i.y;  \n            color += vec3(0.2, 0.8, 0.4)*dif*grid;\n            \n           \n            \n        }\n        break;\n    \n    \n    }\n    \n \n    }\n    color = pow(color, vec3(.4545));\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(4, 3);\n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    vec2 tileXY = floor(uv * count);\n    // coordinates for each tile\n    vec2 st = vec2(\n        uv.x * count.x - tileXY.x, \n        (uv.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n    vec2 gridBars = clamp(cos(uv * TAU * count) * 10. - 9.9, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y)*2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    color = draw(st, tileXY, count);\n    color += grid;\n\n    \n     if (iMouse.z > 0.01) {\n        tileXY = floor(iMouse.xy / iResolution.xy * count);\n        st.x = (uv.x - .5) / coordAspectRatio + .5;\n        st.y = uv.y;\n        //tileXY = vec2(3.0, 1.0);\n         color = draw(st, tileXY, count);\n\n        // color *= 0.15;\n        // color += clamp(draw(st, tileXY, count), 0., .85);\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n\n\n// copied from https://www.shadertoy.com/view/WtGXDD (the art of code)\n// copied from https://iquilezles.org/articles/distfunctions/ (iq sdf functions)\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat GetDist(vec3 p, int idx) {\n    switch (idx) {\n        case 1 :\n            return sdBox(p, vec3(2., 0.02, 2.));\n        case 2:\n            return sdBox(p, vec3(1));\n        case 3:\n            return sdCappedCylinder(p, 2.5, 0.5);\n        case 4:\n            return sdSphere(p, 1.5);\n        case 5:\n            return sdBox(p, vec3(2., 0.02, 2.));\n        case 6:\n            return sdSphere(p, 1.5);\n        case 7:\n           return sdPlane(p, vec3(0., 1., 0.), 0.0);\n        \n    }\n    \n    return 0.;\n}\n\n\nvec3 Transform(vec3 p, float t, int idx) {\n    switch(idx) {\n        case 5:\n           float alp = t;\n           p.yz = p.yz * mat2(cos(alp), -sin(alp), sin(alp), cos(alp));\n           return p;\n    }\n    return p;\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd, int idx, float t) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        p = Transform(p, t, idx);\n    \n        float dS = GetDist(p, idx);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p, int idx) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p, idx) - \n        vec3(GetDist(p-e.xyy, idx), GetDist(p-e.yxy, idx),GetDist(p-e.yyx,idx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n// triangular signal\nvec2 tri( in vec2 x )\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}","name":"Common","description":"","type":"common"}]}