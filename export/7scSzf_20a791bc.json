{"ver":"0.1","info":{"id":"7scSzf","date":"1633624999","viewed":178,"name":"quadmap","username":"jt","description":"Map a quad to another quad via projective 3x3 matrix, as described in the answer \"Computing a projective transformation\"\n [url]https://math.stackexchange.com/questions/296794/finding-the-transform-matrix-from-4-projected-points-with-javascript[/url] .\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["map","projection","quad","mat3","projective","quadrilateral","adjugate","quadmap","quad2quad","quadtoquad","mat3x3","3x3matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/7scSzf\n// ported from: https://jsfiddle.net/dFrHS/1/\n// https://math.stackexchange.com/questions/296794/finding-the-transform-matrix-from-4-projected-points-with-javascript/\n// original author: MvG\n// shadertoy-port by jt\n\n// keywords: quad, map, quadmap, quad2quad, quadtoquad, quadrilateral, projective, projection, mat3, mat3x3, 3x3matrix, adjugate\n\n// NOTE: Possibly using adjugate results in being off by a scalar factor\n//       which is removed by the dehomogenization in the project function.\n\n// Compute the adjugate of m\nmat3 adj(mat3 M)\n{\n  /*\n  // Trying to make structure in adjugate calculation more visible. Ideas for improvement are welcome. (jt)\n  // Unfortunately \"Swizzling does not work with matrices.\" https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)\n  // Workaround: permuation matrix.\n  mat3 P120 = mat3(vec3(0.,0.,1.),vec3(1.,0.,0.),vec3(0.,1.,0.)); // transpose permutation\n  mat3 P201 = mat3(vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(1.,0.,0.)); // transpose permutation\n  mat3 Syxx = mat3(vec3(0.,1.,0.),vec3(1.,0.,0.),vec3(1.,0.,0.)); // transpose swizzle\n  mat3 Szzy = mat3(vec3(0.,0.,1.),vec3(0.,0.,1.),vec3(0.,1.,0.)); // transpose swizzle\n  mat3 flipy = mat3(vec3(1.,0.,0.),vec3(0.,-1.,0.),vec3(0.,0.,1.)); // mirror y\n  mat3 T = transpose(M);\n  return (matrixCompMult(P120*T*Syxx,P201*T*Szzy)-matrixCompMult(P201*T*Syxx,P120*T*Szzy))*flipy;\n  */\n  /*\n  vec3 flip = vec3(+1.0,-1.0,+1.0);\n  // Trying to make adjugate more readable...suggestions? (jt)\n  // Unfortunately \"Swizzling does not work with matrices.\" https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)\n  return\n    transpose(mat3\n    (\n      flip * M[1].yxx * M[2].zzy,\n      flip * M[2].yxx * M[0].zzy,\n      flip * M[0].yxx * M[1].zzy\n    ))\n    -\n    transpose(mat3\n    (\n      flip * M[2].yxx * M[1].zzy,\n      flip * M[0].yxx * M[2].zzy,\n      flip * M[1].yxx * M[0].zzy\n    ));\n  */\n  // close to the original code\n  return\n    mat3\n    (\n      vec3(M[1][1]*M[2][2]-M[2][1]*M[1][2], M[2][1]*M[0][2]-M[0][1]*M[2][2], M[0][1]*M[1][2]-M[1][1]*M[0][2]),\n      vec3(M[2][0]*M[1][2]-M[1][0]*M[2][2], M[0][0]*M[2][2]-M[2][0]*M[0][2], M[1][0]*M[0][2]-M[0][0]*M[1][2]),\n      vec3(M[1][0]*M[2][1]-M[2][0]*M[1][1], M[2][0]*M[0][1]-M[0][0]*M[2][1], M[0][0]*M[1][1]-M[1][0]*M[0][1])\n    );\n}\n\nmat3 basisToPoints(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n  mat3 m = mat3\n  (\n    vec3(p0, 1.0),\n    vec3(p1, 1.0),\n    vec3(p2, 1.0)\n  );\n\n  // WARNING: Using adjugate here only to reproduce the code this is based on - use inverse instead!\n  // Reason: adjugate is off by some potentially HUGE factor which cancels out during dehomogenization\n  //         so mostly everything appears to be ok until it breaks in some cases due to numerical instability!\n  vec3 v = adj(m) * vec3(p3,1.0);\n  mat3 d =\n    mat3\n    (\n      vec3(v.x, 0.0, 0.0),\n      vec3(0.0, v.y, 0.0),\n      vec3(0.0, 0.0, v.z)\n    );\n\n  return m*d;\n}\n\nmat3 general2DProjection(\n  vec2 s0, vec2 d0,\n  vec2 s1, vec2 d1,\n  vec2 s2, vec2 d2,\n  vec2 s3, vec2 d3\n)\n{\n  mat3 s = basisToPoints(s0, s1, s2, s3);\n  mat3 d = basisToPoints(d0, d1, d2, d3);\n\n  // WARNING: Using adjugate here only to reproduce the code this is based on - use inverse instead!\n  // Reason: adjugate is off by some potentially HUGE factor which cancels out during dehomogenization\n  //         so mostly everything appears to be ok until it breaks in some cases due to numerical instability!\n  return d*adj(s);\n}\n\nvec2 project(mat3 m, float x, float y)\n{\n  vec3 v = m * vec3(x,y,1.0);\n  return v.xy/v.z;\n}\n\n// Just some code to visualize the quad\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nfloat checker(vec2 p)\n{\n  return smoothstep(-0.05,+0.05, sin(p.x*TAU)*sin(p.y*TAU));\n}\n\nfloat bounce(float t)\n{\n    return 1.0 - abs(2.0 * fract(t) - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime / 5.0;\n    //vec2 p0 = vec2(bounce(2.0 * t), bounce(3.0 * t));\n    //vec2 p1 = vec2(1.0 - bounce(5.0 * t / 2.0), bounce(7.0 * t / 2.0));\n    //vec2 p2 = vec2(bounce(11.0 * t / 8.0), 1.0 - bounce(13.0 * t / 8.0));\n    //vec2 p3 = vec2(1.0 - bounce(17.0 * t / 10.0), 1.0 - bounce(19.0 * t / 10.0));\n    vec2 p0 = vec2(0.2, 0.2) + 0.1 * vec2(+cos(t),+sin(t));\n    vec2 p1 = vec2(0.8, 0.2) + 0.15 * vec2(-sin(t),+cos(t));\n    vec2 p2 = vec2(0.2, 0.8) + 0.2 * vec2(-cos(t),-sin(t));\n    vec2 p3 = vec2(0.8, 0.8) + 0.25 * vec2(+sin(t),-cos(t));\n\n    // NOTE: quads must be convex\n    mat3 m = general2DProjection\n    (\n      p0, vec2(0.0, 0.0),\n      p1, vec2(1.0, 0.0),\n      p3, vec2(1.0, 1.0),\n      p2, vec2(0.0, 1.0)\n    );\n\n    vec2 q = project(m, uv.x, uv.y);\n    fragColor = texture(iChannel0, q);\n    //fragColor = vec4(checker(5.0 * q));\n\n    if(any(lessThan(q, vec2(0.0))) || any(greaterThan(q, vec2(1.0))))\n        fragColor = vec4(0.0);\n}\n","name":"Image","description":"","type":"image"}]}