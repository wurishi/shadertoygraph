{"ver":"0.1","info":{"id":"wdlcR7","date":"1600353165","viewed":102,"name":"Secret chamber","username":"GCScholar","description":"The sphere and the walls are rendered in the same way you render a terrain with ray marching.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain","displacement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_DISTANCE 25.\n#define PI 3.14\n\n#define ASP_RATIO iResolution.y/iResolution.x\n\nstruct Point \n{\n\tfloat d;\t\t// Point distance\n    vec3 P;\t\t\t// Point coordinate\n    vec3 normal;\n    float mat;  \t// Point material\n};\n\n// WALLS\nfloat terrainMap(vec3 P, vec4 N)\n{\t\n    // Size of the tile mapped on the texture\n    float tileSize = 5.0;\n    float aspRatio = iResolution.y/iResolution.x;\n    \n    vec2 c;\n    if(N.x == 0.0 && N.z == 0.0) { c.x = P.x; c.y = P.z; } // Floor and ceil\n    if(N.x == 0.0 && N.y == 0.0) { c.x = P.y; c.y = P.x; } // 2 walls\n    if(N.y == 0.0 && N.z == 0.0) { c.x = P.y; c.y = P.z; } // Other 2 walls\n    \n    vec2 uv = vec2(\n    \tabs(mod(c.x/ASP_RATIO , tileSize/ASP_RATIO)) / (tileSize/ASP_RATIO),\n        abs(mod(c.y , tileSize)) / tileSize);\n    float step = texture(iChannel0, uv).x;\n    \n    float h = dot(P, N.xyz) + N.w + step;\n\n    return h;\n    \n}\n\nvec3 terrainMapNormal(vec3 P, vec4 N)\n{\n\tvec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n        terrainMap(P + eps.xyy, N) - terrainMap(P - eps.xyy, N),\n        terrainMap(P + eps.yxy, N) - terrainMap(P - eps.yxy, N),\n        terrainMap(P + eps.yyx, N) - terrainMap(P - eps.yyx, N)));\n}\n\n\n// SPHERE\nfloat sphereMap(vec3 P, float r)\n{\n \t// Get the terrain sphere radius in the direction of P \n    vec3 P_ver = normalize(P);\n    vec2 uv = vec2(0.5 + atan(P_ver.z, P_ver.x)/(2.0 * PI), 0.5 - asin(P_ver.y)/PI);\n    uv = fract(uv);\n    float radius = r + 3.0*vec3(texture(iChannel1, uv.yx * vec2(ASP_RATIO, 1.0))).x;\n    \n    return radius - length(P); \n}\n\nvec3 terrainSphereNormal(vec3 P, float r)\n{\n\tvec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        sphereMap(P + eps.xyy, r) - sphereMap(P - eps.xyy, r),+\n        sphereMap(P + eps.yxy, r) - sphereMap(P - eps.yxy, r),\n        sphereMap(P + eps.yyx, r) - sphereMap(P - eps.yyx, r)));\n}\n\n\n// Render scene\nPoint castRayIntoScene(const vec3 ro, const vec3 rd) \n{\n    // Holds (distance, material)\n\tPoint hit = Point( 0.0, vec3(0.0), vec3(0.0), 0.0);\n    \n    // Render terrain map and the sphere map\n    float dt = 0.01;\n    float lh = 0.0;\n    float ly = 0.0;\n    for( float t=1.0; t<MAX_MARCHING_DISTANCE; t+=dt)\n    {\n    \tvec3 P = ro + rd*t;\n        float h;\n        float lh;\n    \tvec3 lP;\n        \n        if(P.x > -15.0 && P.x < 15.0 && P.z > -15.0 && P.z < 15.0)\n        {\n            // Floor\n         /*\n            h = terrainMap(P, vec4(0.0, 1.0, 0.0, 4.0));\n            if(h < 0.001)\n            {\n                hit.d = t - 0.5*dt;\n                hit.P = ro + rd*hit.d;\n                hit.mat = 1.0;\n                hit.normal = terrainMapNormal(P, vec4(0.0, 1.0, 0.0, 4.0));\n                return hit;\n            }\n           \n            // Ceil\n            h = terrainMap(P, vec4(0.0, -1.0, 0.0, 4.0));\n            if(h < 0.001)\n            {\n                hit.d = t - 0.5*dt;\n                hit.P = ro + rd*hit.d;\n                hit.mat = 1.0;\n                hit.normal = terrainMapNormal(P, vec4(0.0, -1.0, 0.0, 4.0));\n                return hit;\n            }\n            \n            // Wall 1\n\t\t\th = terrainMap(P, vec4(1.0, 0.0, 0.0, 4.0));\n            if(h < 0.001)\n            {\n                hit.d = t - 0.5*dt;\n                hit.P = ro + rd*hit.d;\n                hit.mat = 1.0;\n                hit.normal = terrainMapNormal(P, vec4(1.0, 0.0, 0.0, 4.0));\n                return hit;\n            }\n            \n            // Wall 2\n\t\t\th = terrainMap(P, vec4(-1.0, 0.0, 0.0, 3.0));\n            if(h < 0.001)\n            {\n                hit.d = t - 0.5*dt;\n                hit.P = ro + rd*hit.d;\n                hit.mat = 1.0;\n                hit.normal = terrainMapNormal(P, vec4(-1.0, 0.0, 0.0, 4.0));\n                return hit;\n            }\n            \n            // Wall 3\n\t\t\th = terrainMap(P, vec4(0.0, 0.0, -1.0, 4.0));\n            if(h < 0.001)\n            {\n                hit.d = t - 0.5*dt;\n                hit.P = ro + rd*hit.d;\n                hit.mat = 1.0;\n                hit.normal = terrainMapNormal(P, vec4(0.0, 0.0, -1.0, 4.0));\n                return hit;\n            }\n            \n            // Wall 4\n\t\t\th = terrainMap(P, vec4(0.0, 0.0, 1.0, 4.0));\n            if(h < 0.001)\n            {\n                hit.d = t - 0.5*dt;\n                hit.P = ro + rd*hit.d;\n                hit.mat = 1.0;\n                hit.normal = terrainMapNormal(P, vec4(0.0, 0.0, 1.0, 4.0));\n                return hit;\n            }\n\t\t*/\n        }               \n      \n        // Sphere\n        h = sphereMap(P, 1.3);\n        if(h < 0.01)\n        {\n            hit.d = t - 0.5*dt;\n        \thit.mat = 2.0;\n            hit.P = ro + rd*hit.d;\n            hit.normal = terrainSphereNormal(hit.P, 1.3);\n            return hit;\n        }\n      \n        lh = h;\n        lP = P;\n    }\n   \n    return Point(MAX_MARCHING_DISTANCE + 1.0, vec3(0.0), vec3(0.0), 0.0);\t // Hit nothing\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates\n    vec2 U = (2.* fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    float angle = iMouse.x / iResolution.x * 2.0 * 3.14;\n    vec3 eye = vec3(1.0*sin(angle), 0.0, 1.0*cos(angle));\n    \n    // The camera reference system has the local z-axis pointing backward\n    vec3 ww = normalize((eye - target));\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // Ray marching\n    vec3 ray = normalize(vec3(U.x*uu + U.y*vv - (1.0)*ww));\n    Point hit = castRayIntoScene(eye, ray);\n    \n    // Shading\n    vec3 col = vec3(0.0);\n    vec3 N;\n    vec3 ligth_pos_1 = vec3(0.0, 0.0, 0.0);\n\tvec3 ligth_pos_2 = vec3(-4.0, -4.0, -4.0);\n    vec3 ligth_pos_3 = vec3(4.0, -4.0, 4.0);\n\n\n    if(hit.d < MAX_MARCHING_DISTANCE) \n    {   \n        vec3 mat = vec3(0.0);\n        if(hit.mat == 1.0)\t\t // Terrain\n        {\n            N = hit.normal;\n           \tmat = vec3(0.4, 0.1, 0.1);\n        }\n        \n        else if(hit.mat == 2.0)\n        {\n        \tN = hit.normal;\n\t\t\tmat = vec3(0.1, 0.2, 0.6);\n        }\n        \n        vec3 sun_diff_1 = dot(N, normalize(ligth_pos_1-hit.P)) * mat;\n       \tvec3 sun_diff_2 = dot(N, ligth_pos_2-hit.P) * mat;\n       \tvec3 sun_diff_3 = dot(N, ligth_pos_3-hit.P) * mat;\n        \n       float sun_shadow = (castRayIntoScene(hit.P+N, normalize(ligth_pos_1-hit.P)).d < length( ligth_pos_1-hit.P)) ? 0.0 : 1.0;\n        \n        col = ((sun_diff_1*sun_shadow));\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0); \n    //fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).x);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// TERRAIN MAP GENERATION\n\nfloat noise(vec2 v, float seed) \n{\n\treturn fract(sin(dot(v, vec2(33.1234, 13.23))) * seed);\n}\n\nfloat valueNoise(vec2 v, float scale) \n{\n    vec2 i = floor(v * scale);\n    vec2 f = fract(v * scale);\n    \n    float p00 = noise(vec2(floor(i.x), floor(i.y)), 3241.3);\n    float p01 = noise(vec2(floor(i.x), floor(i.y) + 1.0), 3241.3);\n    float p10 = noise(vec2(floor(i.x) + 1.0, floor(i.y)), 3241.3);\n    float p11 = noise(vec2(floor(i.x) + 1.0, floor(i.y) + 1.0), 3241.3);\n    \n    // Cubic interpolate values\n    vec2 c = smoothstep(0.0, 1.0, f);\n    \n    return p00 * (1.0 - c.x) * (1.0 - c.y) + \n           p10 * c.x * (1.0 - c.y) +\n           p01 * (1.0 - c.x) * c.y +\n           p11 * c.x * c.y;             \n}\n\n////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (2.* fragCoord - iResolution.xy) / iResolution.xy;\n    fragColor = vec4(clamp(sin(iTime*2./3.140)*noise(floor(U*1.0), 3241.3), 0.1, 0.2)) + \n        \t\tvec4(clamp(sin(iTime*2.)*noise(floor(U*3.0), 41.3), 0.1, 0.2)) ;\n         \n         +vec4(clamp(sin(iTime+1.72)*noise(floor(U*6.0),3241.3), 0.1, 0.2));\n    \n        \t\t//+vec4(clamp(sin(iTime*4.*0.5+2342.0)*noise(floor(U*3.0),11.3), 0.0, 0.1));\n    \n    //fragColor = vec4(valueNoise(U, 5.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// TERRAIN MAP GENERATION\n\nfloat noise(vec2 v, float seed) \n{\n\treturn fract(sin(dot(v, vec2(33.1234, 13.23))) * seed);\n}\n\nfloat valueNoise(vec2 v, float scale) \n{\n    vec2 i = floor(v * scale);\n    vec2 f = fract(v * scale);\n    \n    float p00 = noise(vec2(floor(i.x), floor(i.y)), 3241.3);\n    float p01 = noise(vec2(floor(i.x), floor(i.y) + 1.0), 3241.3);\n    float p10 = noise(vec2(floor(i.x) + 1.0, floor(i.y)), 3241.3);\n    float p11 = noise(vec2(floor(i.x) + 1.0, floor(i.y) + 1.0), 3241.3);\n    \n    // Cubic interpolate values\n    vec2 c = smoothstep(0.0, 1.0, f);\n    \n    return p00 * (1.0 - c.x) * (1.0 - c.y) + \n           p10 * c.x * (1.0 - c.y) +\n           p01 * (1.0 - c.x) * c.y +\n           p11 * c.x * c.y;             \n}\n\n////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (4.* fragCoord - iResolution.xy) / iResolution.xy;\n    fragColor = vec4(clamp(sin(iTime*3./3.140)*noise(floor(U*10.0), 41.3), 0.1, 0.2)) + \n                vec4(clamp(sin(iTime*2.+1.72)*noise(floor(U*3.0),324.3), 0.1, 0.2)) +\n        \t\tvec4(clamp(sin(iTime*3.*0.5+25642.0)*noise(floor(U*3.0),1.3), 0.0, 0.1));\n    \n    //fragColor = vec4(valueNoise(U, 5.0));\n}","name":"Buffer B","description":"","type":"buffer"}]}