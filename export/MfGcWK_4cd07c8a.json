{"ver":"0.1","info":{"id":"MfGcWK","date":"1732374112","viewed":496,"name":"Tentacle Lattice","username":"Dave_Hoskins","description":"Lots of folded tubes. A shader I did a few years ago, and totally forgot about it. It sometimes clumps into interesting lattices.\nMouse X to scrub through time.","likes":38,"published":3,"flags":32,"usePreview":0,"tags":["3d","raymarching","sdf","folded","tentaclelattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2020.\n\n// This function checks a rough area around the light source to see if any part obscures it,\n// diminshing the lense flare accordigly.\nfloat obscurePartsOfLight(vec2 p)\n{\n    float a = 0.0, z;\n    float e = .03;\n    float d = length(sunPos - camera);\n    \n   \tvec2 texUV = .5+.5*p*vec2(iResolution.y/iResolution.x,1.0);\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.5;\n    \n    texUV = .5+.5*(p+vec2(e, e))*vec2(iResolution.y/iResolution.x,1.0);\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n\n    texUV = .5+.5*(p+vec2(e, -e))*vec2(iResolution.y/iResolution.x,1.0);\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n\n    texUV = .5+.5*(p+vec2(-e, -e))*vec2(iResolution.y/iResolution.x,1.0);\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n    \n    texUV = .5+.5*(p+vec2(-e, e))*vec2(iResolution.y/iResolution.x,1.0);\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n\n    return a;\n}    \n\n\n//---------------------------------------------------------------------------------\nvec3 lenseFlare(vec2 uv,vec3 dir)\n{\n\n    vec3 col = vec3(0);\n    sunLight = normalize(sunPos - camera);\n\n    mat3 inv = transpose(camMat);\n    vec3 cp = inv * (camera - sunPos);\n    if (cp.z < 0.0)\n    {\n    \tvec2 sun2d = zProj * cp.xy / cp.z;\n    \t//vec2 texUV = .5+.5*sun2d*vec2(iResolution.y/iResolution.x,1.0);\n    \t//float z = texture(iChannel0, texUV).w;\n   \n        float z = obscurePartsOfLight(sun2d);\n        if (z > 0.0)\n        {\n            vec2 uvT = uv - sun2d;\n            uvT = uvT*(length(uvT));\n            float bri = dot(dir, sunLight)*.5;\n            bri = pow(bri, 4.0)*.7*z;\n\n\n            // glare1 = the red shifted blob...\n            float glare1 = max(dot(dir,sunLight),0.0);\n            // glare2 is the yellow ring...\n            float glare2 = max(1.7-length(uvT+sun2d*2.)*5.0, 0.0);\n            //uvT = mix (uvT, uv, -2.3);\n            // glare3 is a splodge...\n\t\t\tfloat glare3 = max(1.-pow(length(uvT+sun2d*.5)*3., 2.), 0.0);\n\n            col += vec3(1.0, .0, .0)  * pow(glare1, 18.5)*.15;\n            col += bri * vec3(.0, .4, 1.) * pow(glare2, 2.0)*10.;\n          \tcol += bri * vec3(1.0,.6, .3) * pow(glare3, 4.0)*4.0;\n        }\n\t}\n    return max(vec3(0.0),col);\n}\n// https://lime-limelemon.blogspot.com/2016/03/aces-filmic-tone-mapping-curve.html\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n    //return -0.053173 + x*(2.170622 + x*(-2.132296 + x*(0.996822 + x*-0.176583)));\n}\n\n//---------------------------------------------------------------------------------\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    \n    float mouseX = iMouse.x / iResolution.x;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n \n\n           // Setup camera...\n\ttime = getTime(iTime, mouseX);\n     // Setup camera...\n    camera = getCamPos(time);\n\tvec3 lookat = camera *.5;\n    camMat = getCamMat(camera, lookat, 0.);\n    zProj = projectZ(uv);\n    vec3 setDir = normalize( vec3(uv, zProj));\n\tvec3 rd = camMat * setDir;\n\tsunPos = getLightPos(time) + lookat;\n  \n    \n    // Init output...\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    col += lenseFlare(uv, rd);\n\n    col = clamp(col, 0.0, 1.0);\n    col = col*col*(3.0-2.0*col); \n    col = acesFilm(col);// Filmic filter AND some over-kill contrast. Yeah!!!! :)\n\n    \n\t// Finally some border vignette...\n    uv = fragCoord / iResolution.xy;\n    col *= .5+ .5*pow(100.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.6 );\t\n    //col *= smoothstep(0.0, 4.0, iTime) * smoothstep(336.0, 328.0, iTime);\n\n    colOut = vec4(sqrt(col), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define OFF_LINE\n\nfloat time;\nvec3 camera;\nmat3 camMat;\nmat4 camMat4;\nvec3 sunLight;\nvec3 sunPos;\nfloat zProj;\nfloat fov = 1.;\n//--------------------------------------------------------------------------------\n\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//--------------------------------------------------------------------------------\nvec3 getCamPos(float t)\n{\n\n    vec3 p = vec3(18.0*sin(t*.31),\n                  18.0*cos(t*.32),\n                  18.0*cos(t*.30));\n    return p;\n}\n\n//--------------------------------------------------------------------------------\nvec3 getLightPos(float t)\n{\n\tt+=20.;\n    vec3 p = vec3(10.0*sin(t*3.3),\n                  8.0*sin(t*2.5),\n                  10.0*sin(t*2.4));\n    return p;\n}\n\n//--------------------------------------------------------------------------------\nfloat getTime(float iTime, float mx)\n{\n    float t = (iTime+370.0)*.1+820.6;\n    #ifndef OFF_LINE\n\tt += mx*15.0;\n    #endif\n    return t;\n}\nfloat projectZ(vec2 uv)\n{\n    return .75;\n   //return cos(length(uv*.75));\n}\n    \n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nmat2 rotm;\nfloat pix;\nfloat mist;\n\n//--------------------------------------------------------------------------------\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//--------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------------\nmat2 rot2D(float a) {\n    a=radians(a);\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n//--------------------------------------------------------------------------------\n// With thanks to Kali...\n// https://www.shadertoy.com/view/WtfXzf\nvec2 de(vec3 p)\n{\n    p=abs(15.-mod(p+15.,30.));\n    float md=200.;\n    float s=1.2;\n    float sc=1., id = 0.;\n    vec3 pc;\n    \n    float turn  = sin(time*1.3)*2.0;\n\n    float rot=sin(time*.3)*20.;\n    for (float i = 0.0; i < 1.0; i+= 1.0/7.0)\n    {\n      \tp.xy=abs(p.xy); \n        p=p*s-4./sc;\n        sc*=s;\n        p.xz*=rotm;\n        p.yz*=rot2D(15.+rot);\n        float d=length(p.xz+sin(p.y*turn));\n        if (d<md)\n        {\n        \tmd=d;\n\t\t\tpc=p;\n            id = i;\n        }\n    }\n    float l=max(0.2,(pc.y*.1));\n    return vec2((md/sc)*l, id);\n}\n\n//--------------------------------------------------------------------------------\n// Shadow only reaches so far then everything is lit...\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\t\n    for (int i = 0; i < 15; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = de(p).x;\n\t\tres = min(8.*h / t, res);\n\t\tt += h*.8;\n\t}\n\n    return clamp(res, .1, 1.0);\n}\n\n//--------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nvec2 rayMarch(vec3 ro, vec3 rd, vec2 uv)\n{\n    float l = hash12(uv);\n    int i;\n    vec2 d2;\n    mist = 0.0;\n    \n    #ifdef OFF_LINE\n    for (i = 0; i < 800; i++)\n    #else\n    for (i = 0; i < 250; i++)\n    #endif\n    {\n        vec3 p = ro + rd * l;\n        d2 = de(p);\n        mist += smoothstep(.12,.03,d2.x);\n        \n        if (abs(d2.x) < .03 || l > 1000.0) break;\n        #ifdef OFF_LINE\n        l += d2.x*.5;\n        #else\n        l += d2.x*.85;\n        #endif\n\t}\n    mist = pow(mist, 3.) * .0001;\n    return vec2(l, d2.y);\n}\n\n\n//--------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 nor, vec3 rd, vec3 mat)\n{\n    sunLight = normalize(sunPos - p);\n    float c = max(dot(nor, sunLight), 0.0)+abs(nor.y)*.1;\n    vec3 ref = reflect(rd, nor);\n\tfloat sh = shadow(p+sunLight*0.2,  sunLight);\n    vec3 spec = texture(iChannel0, ref).xyz;\n    return ((mat * c)+ pow(spec, vec3(3.0))*.2)*sh;\n}\n\n\n//--------------------------------------------------------------------------------\nvec3 normal(vec3 p, float ds)\n{\n    ds *= ds;\n\tfloat e = min(.1, pix * ds);\n\n    return normalize( vec3( de(p+vec3(e,0.0,0.0)).x - de(p-vec3(e,0.0,0.0)).x,\n                            de(p+vec3(0.0,e,0.0)).x - de(p-vec3(0.0,e,0.0)).x,\n                            de(p+vec3(0.0,0.0,e)).x - de(p-vec3(0.0,0.0,e)).x));\n}\n\n//----------------------------------------------------------------------------------------\nvec3 lightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n\t\tg = pow(max(dot(normalize(spotLight), dir), 0.0), 2000.0);\n    }\n   \n    return vec3(g, g*.8, g*.7)*.8;\n}\n\n\n//--------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalise coordinates to whatever resolution / ratio we have...\n    float mouseX = iMouse.x / iResolution.x;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    pix = .1/iResolution.y;\n    \n    rotm=rot2D(-30.);\n    \n    /// Init output...\n    vec3 col = vec3(0.);\n    \n\n    // Setup camera...\n    time = getTime(iTime, mouseX);\n    camera = getCamPos(time);\n\tvec3 lookat = camera *.5;\n    \n    camMat = getCamMat(camera, lookat, 0.);\n    zProj = projectZ(uv);\n\n    vec3 setDir = normalize( vec3(uv, zProj));\n\tvec3 rd = camMat * setDir;\n    \n    //mat3 camMat = getCamMat(uv, camera, lookat,0.0, rd);\n    sunPos = getLightPos(time)+lookat;\n    \n    vec2 dis = rayMarch(camera, rd, fragCoord);\n    if (dis.x < 1000.0)\n    {\n        vec3 p  = camera + rd * dis.x;\n        vec3 nor = normal(p, dis.x);\n        vec3 mat =  pal( dis.y, vec3(0.5,0.5,0.3),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n        mat = mix(mat, texCube(iChannel1, p*.2, nor.yzx), .5);\n        col = lighting(p, nor, rd, mat);//texture(iChannel0, nor).xyz;\n        \n        \n        float fog = exp(-dis.x*.018);\n        col = mix(vec3(0.04, .04, .04), col, fog);\n    }\n    #ifndef OFF_LINE\n    col+= mist *vec3(.01, .0025, 0.001);\n    #else\n    col+= mist *vec3(.01, .0025, 0.001) * .2;\n    #endif\n    \n    col += lightSource(sunPos - camera, rd, dis.x);\n    //col += lenseFlare(uv, rd)*10.;\n    col = clamp(col, 0.0, 1.0);\n\n    // Output to screen\n    fragColour = vec4(col,dis.x);\n}","name":"Buffer A","description":"","type":"buffer"}]}