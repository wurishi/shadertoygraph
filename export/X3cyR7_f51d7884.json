{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Fork of \"Albino Viz by Orblivius\" by orblivius. https://shadertoy.com/view/M32GRW\n// 2024-12-22 06:00:42\n\n// Albino Visualzier by Orblivius\n//\n// License: Free as long as you mention me in credits or \n// give link to this shadertoy\n//\n// GitHub: github.com/mewza\n//\n// Sources: https://shadertoy.com/view/43S3Rz\n//          https://shadertoy.com/view/43S3RD\n\n\n#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\nfloat random1d(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate2D(vec2 position, float theta){\n    mat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n    return m * position;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv;\n    uv -= 0.5;\n    //fix aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    //get a bass level\n    float bass  = texelFetch( iChannel0, ivec2(1,0), 0 ).x; \n    bass = clamp((bass-0.5)*2.0,0.0,1.0);\n    //bass bounce\n   // uv *= 1.0 + (1.0 - bass)*2.0;\n    //bass shake\n    uv += bass*(vec2(random1d(iTime),random1d(iTime + 1.0)) - 0.5)* 0.015;\n    //spin\n  uv = rotate2D(uv, 3.1415);\n    \n    uv += 0.5;\n    \n    // get polar angle and radius\n\tvec2 pos = vec2(0.5)-uv;\n    float r = length(pos)*2.0 ;\n    float a = atan(pos.y,pos.x);   \n    float normAng = fract(0.75 -(a /PI) /2.0); //0 - 1 clockwise\n    \n    //get stepped angle\n    float SPOKES = 100.0;\n    float sa = floor(normAng * SPOKES)/ SPOKES;\n   \n    // the sound texture is 512x2\n    float tx = (sa*256.);\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(mod(abs(127.-tx),128.),0), 0 ).x; \n    \n    //white spokes\n    vec3 fgCol =  vec3(abs(bass-1.0),bass,abs(bass-1.0));\n    fgCol = mix(vec3(1.), vec3(1.000,0.302,0.000),bass); \n   fgCol = vec3(1.0, 1.0,1.0);  \n\n\n    //mask spokes by angle\n    float aEdge = 0.1;\n    float s = fract(normAng * SPOKES);\n    float mask = smoothstep(0.8, 0.8 + aEdge, s);\n    float edgerr = smoothstep(aEdge, 0.0, s);\n    mask = max(mask,edgerr);\n    \n    //mask radial center and edges\n    float rEdge = 0.04;\n    float maxLen = 1.0;\n    float innerRad = 0.2;\n    float inner = 1.0 - smoothstep(innerRad,innerRad + rEdge, r);\n    \n    //outer edge dependent on volume\n    float top = innerRad + maxLen * fft * fft;\n    float outer = smoothstep(top, top + rEdge,r);\n    mask = max(mask,inner);\n    mask = max(mask,outer);\n    fgCol -= mask;\n    \n    //add a glowy rainbow\n    float radialGrad = (1.0 - r * 0.4) * 2.0;\n    vec3 bgCol = hsv2rgb(vec3(normAng + iTime*0.2,0.9,fft*fft * radialGrad + 0.1));\n    \n    //knockout inner circ\n    //float inner2 = 1.0 - smoothstep(0.0,0.5, r);    \n    float inner2 = 1.0 - step(0.2, r);\n    bgCol = min(bgCol,1.0 - inner2); \n    \n    ////--------------------------------------------- RAYMARCHING\n    vec2 raymarchingUV = fragCoord.xy / iResolution.xy;\n    vec3 outC = texture(iChannel1, raymarchingUV).xyz;\n    outC *= 2.0;\n\n    bass  = texelFetch( iChannel0, ivec2(1,0), 0 ).x; \n    bass = clamp((bass-0.8)*2.0,0.0,1.0);\n   \n    vec3 col = fgCol+(1.-fgCol)*(bgCol*outC);\n    // output final color\n\tfragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Albino Visualzier by Orblivius\n//\n// License: Free as long as you mention me in credits or \n// give link to this shadertoy\n//\n// GitHub: github.com/mewza\n//\n// Sources: https://shadertoy.com/view/43S3Rz\n//          https://shadertoy.com/view/43S3RD\n\n#define EPS 0.0001\n#define TAU 6.28318530718\n#define FAR 10.0\n#define SURREAL_FALL      2.\n#define STEPS 200\n#define WEB\n\n#ifdef WEB\n#define freq(f) texture(iChannel0, vec2(f,0.35)).r\n#else\n#define freq(f) iData[int(min(f*256.,255.))]/200.\n#endif\n\nvec2 rotateUV(vec2 uv, float angle) {\n    angle = angle*TAU;\n    mat2 matrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return matrix * uv;\n}\n\n\nfloat trig( float dist, float decay, float frequency, float amplitude, float speed )\n{\n\n\treturn exp( -decay * dist ) *  \n   \t\t   sin( dist * frequency + ( speed ) ) * amplitude;\n    \n}\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\nfloat map( vec3 p )\n{\n\n    float dis = length( p );\n    float dec = 0.01;\n    float fre = 5.1;\n    float amp = 4.1;\n    float spe = ( texture( iChannel0, vec2( 0.0, 0.25 ) ).x );\n    float tri = trig( dis, dec, fre, amp, spe );\n    return length( p ) - 0.0 + tri;\n\n}\n\nvec3 grad( vec3 p )\n{\n\n    vec2 e = vec2( 0.0, EPS );\n    return vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                 map( p + e.yxy ) - map( p - e.yxy ),\n                 map( p + e.yyx ) - map( p - e.yyx )\n                );\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n\tfloat res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t );\n        if( h < EPS ) return 0.0;\n        res = min( res, 8.0 * h / t );\n        t += h;\n        \n    }\n    \n    return res;\n    \n}\n\nvec3 shade( vec3 ro, vec3 rd, float t )\n{\n\n\n    vec3 p = ro + rd * t;\n    vec3 n = normalize( grad( p ) );\n    vec3 col=vec3(0);\n    vec3 lig = normalize( vec3( 0.3, 0.8, 0.7 ) );\n    vec3 ref = reflect( rd, lig );\n    \n    float wav = ( texture( iChannel0, vec2( 0.0, 0.25 ) ).x );\n    float amb = 0.5 + 0.5 * n.y;\n    float sha = softShadows( p, lig );\n    float dif = max( 0.0, dot( n, lig ) );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\n    \n    col += vec3( 0.8, 0.7, 0.8 ) * amb;\n    col += dif * vec3( 0.8, 0.7, 0.8 ) * sha;\n    col += 1.0 * spe;\n    col *= mix( vec3( 0.2, 0.4, 0.6 ), vec3( 0.4, 0.2, 0.2 ), fbm( p + iTime + wav ) );\n    return col;\n    \n}\n\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    float interp = smoothstep(0.0, 1.0, t); // Smooth interpolation between a and b\n    return mix(a, b, interp) + c * cos(6.28318 * (t * d));\n}\n\nfloat avgFreq(float start, float end, float smoothstep) {\n    float div = 0.0;\n    float total = 0.0;\n    for (float pos = start; pos < end; pos += smoothstep) {\n        div += 1.0;\n        total += freq(pos);\n    }\n    return total / div;\n}    \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.85);\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.95);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n  uv = rotateUV(uv,iTime*max(medFreq,topFreq)*5.); \n vec2 q = uv - vec2(0.5, 0.5);\n    vec2 a = uv + mod(0.5, 0.5);\n    vec3 col = vec3(0.26, 0.15, 0.43);\n\n\n// ---\n\n // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    \n    //vec3 ro = 3.0 * vec3( sin( iTime ), 0.0, cos( iTime ) );\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 vv = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 uu = normalize( cross( ww, vv ) );\n    vec3 rd = normalize( uvv.x * uu + uvv.y * vv + 1.5 * ww );\n    \n    float t = 0.0; float dd = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        dd = map( ro + rd * t );\n        if( dd < EPS || t > FAR ) break;\n        t += dd;\n        \n    }\n\n    // Time varying pixel color\n    vec3 colp = dd < EPS ? shade( ro, rd, t ) : vec3( 0.0 );\n\n    // Output to screen\n   \n// ---\n\n\n    float timeFactor = iTime * 0.21;  // Adjust the multiplier as needed\n\n    // Modulate the scaling and rotation based on audio frequencies\n    float scale = 1.0 + 0.5 * bassFreq;\n    float rotation = sin(medFreq * timeFactor) * 3.14;\n\n    // Apply scaling and rotation to uv coordinates\n    uv *= scale;\n    uv = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation)) * uv;\n\n    float r = 0.02 + 0.9 * sin(timeFactor * bassFreq / 6.3);\n    float d =  cos( timeFactor * fract(a.x *= medFreq * 0.4));\n\n    col *= mix(r, r, length(q / d * 2.23 ));\n\n    vec2 uv0 = uv;\n    vec3 finalColor = col;\n\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        uv = fract(uv * (medFreq )) - medFreq;\n\n        float distortion = length(uv ) * exp(-length(uv0));\n        float fractalTime = (timeFactor + i * (0. * topFreq)) * 0.465;\n\n        vec3 col = palette(length(uv0) + fractalTime);\n\n        distortion = sin(distortion /(bassFreq *.5) * 4.0 + fractalTime) / 8.0;\n       distortion = abs(distortion);\n\n        distortion = pow(0.02 / distortion, 1.2);\n\n        finalColor += col * distortion;\n    }\n\n    fragColor = vec4(2.*colp*colp*finalColor+finalColor, 1.); //finalColor + 1.5*colp*colp*finalColor,1.0);\n }\n    \n    /*\n#define EPS 0.0001\n#define FAR 100.0\n#define STEPS 2000\n#define freq(f) texture(iChannel0, vec2(f, 0.15)).x\n\n\nfloat trig( float dist, float decay, float frequency, float amplitude, float speed )\n{\n\n\treturn exp( -decay * dist ) *  \n   \t\t   sin( dist * frequency + ( speed ) ) * amplitude;\n    \n}\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\nfloat map( vec3 p )\n{\n\n    float dis = length( p );\n    float dec = 0.01;\n    float fre = 5.1;\n    float amp = 4.1;\n    float spe = ( texture( iChannel0, vec2( 0.0, 0.25 ) ).x );\n    float tri = trig( dis, dec, fre, amp, spe );\n    return length( p ) - 0.0 + tri;\n\n}\n\nvec3 grad( vec3 p )\n{\n\n    vec2 e = vec2( 0.0, EPS );\n    return vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                 map( p + e.yxy ) - map( p - e.yxy ),\n                 map( p + e.yyx ) - map( p - e.yyx )\n                );\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n\tfloat res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t );\n        if( h < EPS ) return 0.0;\n        res = min( res, 8.0 * h / t );\n        t += h;\n        \n    }\n    \n    return res;\n    \n}\n\nvec3 shade( vec3 ro, vec3 rd, float t )\n{\n\n\n    vec3 p = ro + rd * t;\n    vec3 n = normalize( grad( p ) );\n    vec3 col=vec3(0);\n    vec3 lig = normalize( vec3( 0.3, 0.8, 0.7 ) );\n    vec3 ref = reflect( rd, lig );\n    \n    float wav = ( texture( iChannel0, vec2( 0.0, 0.25 ) ).x );\n    float amb = 0.5 + 0.5 * n.y;\n    float sha = softShadows( p, lig );\n    float dif = max( 0.0, dot( n, lig ) );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\n    \n    col += vec3( 0.8, 0.7, 0.8 ) * amb;\n    col += dif * vec3( 0.8, 0.7, 0.8 ) * sha;\n    col += 1.0 * spe;\n    col *= mix( vec3( 0.2, 0.4, 0.6 ), vec3( 0.4, 0.2, 0.2 ), fbm( p + iTime + wav ) );\n    return col;\n    \n}\n\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    float interp = smoothstep(0.0, 1.0, t); // Smooth interpolation between a and b\n    return mix(a, b, interp) + c * cos(6.28318 * (t * d));\n}\n\nfloat avgFreq(float start, float end, float smoothstep) {\n    float div = 0.0;\n    float total = 0.0;\n    for (float pos = start; pos < end; pos += smoothstep) {\n        div += 1.0;\n        total += freq(pos);\n    }\n    return total / div;\n}    \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.85);\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.95);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 q = uv - vec2(0.5, 0.5);\n    vec2 a = uv + mod(0.5, 0.5);\n    vec3 col = vec3(0.26, 0.15, 0.43);\n\n\n// ---\n\n // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    \n    //vec3 ro = 3.0 * vec3( sin( iTime ), 0.0, cos( iTime ) );\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 vv = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 uu = normalize( cross( ww, vv ) );\n    vec3 rd = normalize( uvv.x * uu + uvv.y * vv + 1.5 * ww );\n    \n    float t = 0.0; float dd = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        dd = map( ro + rd * t );\n        if( dd < EPS || t > FAR ) break;\n        t += dd;\n        \n    }\n\n    // Time varying pixel color\n    vec3 colp = dd < EPS ? shade( ro, rd, t ) : vec3( 0.0 );\n\n    // Output to screen\n   \n// ---\n\n\n    float timeFactor = iTime * 0.21;  // Adjust the multiplier as needed\n\n    // Modulate the scaling and rotation based on audio frequencies\n    float scale = 1.0 + 0.5 * bassFreq;\n    float rotation = sin(medFreq * timeFactor) * 3.14;\n\n    // Apply scaling and rotation to uv coordinates\n    uv *= scale;\n    uv = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation)) * uv;\n\n    float r = 0.02 + 0.9 * sin(timeFactor * bassFreq / 6.3);\n    float d =  cos( timeFactor * fract(a.x *= medFreq * 0.4));\n\n    col *= mix(r, r, length(q / d * 2.23 ));\n\n    vec2 uv0 = uv;\n    vec3 finalColor = col;\n\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        uv = fract(uv * (medFreq )) - medFreq;\n\n        float distortion = length(uv ) * exp(-length(uv0));\n        float fractalTime = (timeFactor + i * (0. * topFreq)) * 0.465;\n\n        vec3 col = palette(length(uv0) + fractalTime);\n\n        distortion = sin(distortion /(bassFreq *.5) * 4.0 + fractalTime) / 8.0;\n       distortion = abs(distortion);\n\n        distortion = pow(0.02 / distortion, 1.2);\n\n        finalColor += col * distortion;\n    }\n\n    fragColor = vec4(finalColor+colp, 1.); //finalColor + 1.5*colp*colp*finalColor,1.0);\n    }\n */","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"X3cyR7","date":"1734847545","viewed":112,"name":"Albino Vizualizer","username":"orblivius","description":"Albino Visualizer by Orblivius","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["sound","fft","spectrum","visualice"],"hasliked":0,"parentid":"","parentname":""}}