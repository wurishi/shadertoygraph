{"ver":"0.1","info":{"id":"lcsSWr","date":"1705169802","viewed":226,"name":"GM Shaders: Tiled Noise","username":"Xor","description":"Tillable value and fractal noise for my tutorial:\nhttps://mini.gmshaders.com/p/noise3","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","tutorial","value","gmshaders","tillable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Tiled Noise\" by @XorDev\n\n    Noise:    | Value  | Perlin |\n\n    Written for my tutorial series on noise:\n    https://mini.gmshaders.com/p/noise3\n\n    Based on:\n    https://www.shadertoy.com/view/DdBGDh\n*/\n\n//Typical pseudo-random hash (white noise)\nfloat hash1(vec2 p)\n{\n    //Generate a pseudo random number from 'p'.\n    return fract(sin(p.x*0.129898 + p.y*0.78233) * 43758.5453);\n}\n//Tillable value noise\n//s - tile size (e.g. a value of 8 means it tiles every 8 units)\nfloat value_noise(vec2 p, vec2 s)\n{\n    //Cell (whole number) coordinates\n    vec2 cell = floor(p);\n    //Sub-cell (fractional) coordinates\n    vec2 sub = p - cell;\n    //Cubic interpolation (use sub for linear interpolation)\n    vec2 cube = sub*sub*(3.-2.*sub);\n    //Offset vector\n    const vec2 off = vec2(0,1); \n\n    //Sample cell corners and interpolate between them.\n    return mix( mix(hash1(mod(cell+off.xx,s)), hash1(mod(cell+off.yx,s)), cube.x),\n                mix(hash1(mod(cell+off.xy,s)), hash1(mod(cell+off.yy,s)), cube.x), cube.y);\n}\n\n//Generate fractal value noise from multiple octaves\n//s - tile size (e.g. a value of 8 means it tiles every 8 units)\n//oct - The number of octave passes\n//per - Octave persistence value (should be between 0 and 1)\nfloat fractal_noise(vec2 p,vec2 s, int oct, float per)\n{\n    float noise_sum = 0.0; //Noise total\n    float weight_sum = 0.0; //Weight total\n    float weight = 1.0; //Octave weight\n\n    for(int i = 0; i < oct; i++) //Iterate through octaves\n    {\n        //Add noise octave to total\n        noise_sum += value_noise(p,s) * weight; \n        //Add octave weight to total\n        weight_sum += weight;\n        //Reduce octave amplitude with persistence value\n        weight *= per;\n        //Rotate, scale and translate for next octave\n        p = p.yx*2.0+9.0;\n        s *= 2.0;\n    }\n    //Compute weighted average\n    return noise_sum / weight_sum; \n}\n\n//Function demo\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Compute 3x2 uv cells\n    vec2 uv = fragCoord / iResolution.xy * vec2(2,1);\n    \n    //Use scaled coordinates\n    vec2 coord = fragCoord/iResolution.y*16.0;\n    //Scroll horizontally\n    coord.x += iTime;\n    \n    //Initialize noise value\n    float noise = 0.0;\n    vec2 size = vec2(8);\n    //Value noise\n    if (uv.x<1.0) noise = value_noise(coord,size);\n    //Fractal noise\n    else          noise = fractal_noise(coord,size, 6, 0.5);\n    //Compute shaded divider bars\n    vec2 bars = pow(smoothstep(0.5,0.4,abs(fract(uv)-0.5)), vec2(0.1));\n    \n    //Output noise + divider bars\n    fragColor = vec4(noise * bars.x * bars.y);\n}","name":"Image","description":"","type":"image"}]}