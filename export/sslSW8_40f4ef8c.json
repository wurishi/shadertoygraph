{"ver":"0.1","info":{"id":"sslSW8","date":"1618617383","viewed":83,"name":"friday means .... (vlllll)","username":"valalalalala","description":"... shiny square donut and cookie transformation wave hell","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"3lGyzz","parentname":"simple marcher (vlllll)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"       /////////////////////////////////////////////////////////////////\n      //                                                            ////\n     //  \"friday means shiny square donut and cookie               // //\n    //  transformation wave hell\"                                 //  //\n   //                                                            //   //\n  //  everyone talks about it, but no one *does* anything       //    //\n //  it                                                        //    //\n//                                                            //    //\n////////////////////////////////////////////////////////////////   // \n//                                                            //  //\n// CC0 1.0 Universal                                          // //\n// https://creativecommons.org/publicdomain/zero/1.0/         ////\n//                                                            ///\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          //\n///////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// scene definition\n\n\nfloat sint;\nfloat cost;\n\nfloat map( vec3 p ) {\n    float t = iTime * .88 + 9.3;\n    cost = cos( t * .66 );\n    \n    float modo = 3.3 + - .36 * cost;\n\n    // like it better horizontal...\n    \n    p = p.xzy;\n\n    // lateral motion\n     \n    p.xy += 5. * cost;\n    \n    // don't make me repeat myself... I'll do it myself\n    \n    vec2 id = p.xy;\n    p.xy = mod( p.xy + .5 * modo, modo ) - .5 * modo;\n    id -= p.xy;\n    \n    sint  = 1.22 * sin( t + ( id.x + id.y ) );\n    \n    // can you see me waving at you?\n    \n    float wave = .88 * ( cos( p.x + t - id.y * .2 ) - sin( p.y + t + id.x * .2) );\n    p.z += 7. + wave;\n    \n    // now spin in a circle\n    \n    t = iTime * .70;\n    vec3 b1 = erot( p, vec3( .0, .0, +1. ), t - sint * 3.3 );\n    vec3 b2 = erot( p, vec3( .0, .0, -1. ), t + sint * 2.2 );\n    \n    // how big? how round?\n    \n    float b = 1.;\n    float f = .4 + .2 * abs( sint );\n    float roundness = .04 + f * .2;\n    float thickness = .01 + f * .2;\n    \n    vec3 outer = vec3( b, b, thickness );\n    vec3 inner = vec3( b * f );\n    \n    // feeling boxed in? box out!\n   \n    float positive = sdBox( b1, outer ) - roundness;\n    float negativ1 = sdBox( b1, inner ) - roundness;\n    float negativ2 = sdBox( b2, inner ) - roundness;\n    \n    float negative = min( negativ1, negativ2 );\n    float miff = max( positive, -negative * sint * .8 ); // lol\n    \n    // \"Why use a word like 'sphere'?\" asked the sphinx's asphyxiated sphincter blasphemously;\n    \n    float ball = distance( p, vec3( .0, .0, sint ) ) - .44 - sint * .1;\n    \n    // warped spaces is a mess... but also hilarious\n    \n    return min( miff , ball ) * .5;\n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 kolor( float m ) {\n    //float sint = sin( iTime );\n    return mix(\n        vec3( sint ) * vec3( .2, .1, .05 ) + vec3 (.6,.3,.1),\n        vec3( sint ) * vec3( .05, .1, .2 ) + vec3 (.1,.2,.5),\n        m\n    );\n}\n\nvec3 simpleColor( vec3 p, vec3 n ) {    \n    return kolor( .0 ) * ( -n.z + 1.5 );\n    // based on https://www.shadertoy.com/view/ttGfz1\n    vec3 q = sin(n*2.)*.5+.5;\n    float light = dot( q, q ) / 3.;\n    return sqrt( light * kolor( .0 ) );\n}\n\nvec3 colorHit( vec3 eye, vec3 direction, float d ) {\n    vec3 p = eye + direction * d;\n    vec3 n = mapNormal( p, d );\n    vec3 color = simpleColor( p, n );\n    \n    //float cost = cos( iTime );\n    \n    float cx=cost;\n    float sx=sint;\n    \n    float rd = march( p + n * .003, n );\n    #if 1\n    cost = cx;\n    sint = sx;\n    #endif\n    \n    vec3 reflection;\n    if ( rd < MARCH.z  ) {\n        vec3 rp = p * n * rd;\n        vec3 rn = mapNormal( rp, rd );\n        reflection = simpleColor( rp, rn );        \n    } else {    \n        reflection = kolor( 1. );\n    }\n    \n    float mixer = .4 + .4 * cost;\n    color = mix( color, reflection, mixer);\n    \n    return color;\n\n}\n\nvec3 colorMiss( in vec2 uv ) {\n    return .3 * kolor( abs( sint ) );\n    return .3 * kolor( abs( sin( iTime * .3 + 3.33 ) ) );\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = boilerPlateMain( fragCoord, iMouse, iResolution, iTime );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////\n// hack for forward declarations https://www.shadertoy.com/view/WldSRj\n// try to hide the boilerplate a little\n\n#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON\n#endif\n\n////////////////////////////////////////////////////////////////\n// camera settings\n\n#define CAMERA_DISTANCE 3.\n#define CAMERA_ZOOM     2.\n\n////////////////////////////////////////////////////////////////\n// handy constants\n\nconst float TAU = 6.283185307179586;\n\n///////////////////////////////////////////////////////////////////\n// ray marching\n\nconst vec3 MARCH = vec3( .0, .0001, 55. );\n\nfloat map( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nfloat map( vec3 p ) { return 33.44; }\n#endif\n\nfloat march( vec3 eye, vec3 direction ) { \n    float total = .0, now;\n    vec3 current = eye;\n    for( int i = 0 ; i < int( MARCH.z ) ; i++ ) {\n        total += ( now = map( current ) );\n        if ( abs( now ) < MARCH.y || total > MARCH.z ) break;\n        current += now * direction;\n    }\n    return total + MARCH.z * step( MARCH.z, total );\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 mapNormal(vec3 p,float d) {\n    mat3 k = mat3(p,p,p) - mat3(MARCH.y*d);\n    return normalize(map(p) - vec3(map(k[0]),map(k[1]),map(k[2])) );\n}\n\n////////////////////////////////////////////////////////////////\n// miscellanous mess\n\n#define FROM_SCREEN(uv,R)  ( ( 2. * (uv) - (R).xy ) / (R).y )\n\nvec2 trig( float a ) {\n    return vec2( cos( a  * TAU ), sin( a * TAU ) );\n}\n\n////////////////////////////////////////////////////////////////\n// rotation \n// from https://www.shadertoy.com/view/ttGfz1\n// https://suricrasia.online/demoscene/functions/\n\nvec3 erot(vec3 p, vec3 ax, float c, float s) {\n    return mix( dot(ax,p) * ax, p, c) + s * cross(ax,p);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return erot(p,ax,cos(ro),sin(ro));\n}\n\n////////////////////////////////////////////////////////////////\n// signed distance fields\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n////////////////////////////////////////////////////////////////\n// basic camera controls\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, .0 );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec3 cameraEye( float viewDistance, vec4 mouse, vec3 resolution, float time ) {\n    vec2 ms = mouse.z > -999999.0 ? mouse.xy / resolution.xy : vec2( time *.1, .0 );\n    vec2 t = viewDistance * trig( ms.x );\n    #if 1\n    float ey = viewDistance * sin( (ms.y*2.-1.) * TAU * .5 );\n    #else\n    // better for grounded scenes...\n    float ey = viewDistance * sin( ms.y  * 1.11); \n    #endif\n    return vec3( t.x, ey, t.y );\n}\n\n////////////////////////////////////////////////////////////////\n\nvec3 colorHit( vec3 eye, vec3 direction, float d );\nvec3 colorMiss( in vec2 uv );\n#ifdef _SHADERTOY_TAB_COMMON\nvec3 colorHit( vec3 eye, vec3 direction, float d ) { return vec3( 1. ); }\nvec3 colorMiss( in vec2 uv ) { return vec3( .0 ); }\n#endif\n\nvec4 boilerPlateMain( in vec2 fragCoord, vec4 mouse, vec3 resolution, float time ) {\n    vec2 uv = FROM_SCREEN( fragCoord, resolution );\n\n    ////////////////////////////////////////////////////////////////\n\n    vec3 eye = cameraEye( CAMERA_DISTANCE, mouse, resolution, time );\n    vec3 b = vec3( .0 );\n    vec3 ab = normalize( makeCamera( eye, b, .0 ) * vec3( uv, CAMERA_ZOOM ) );\n    \n    ////////////////////////////////////////////////////////////////\n\n    float d = march( eye, ab );\n    float hit = step( d, MARCH.z * .9);\n\n    vec3 color = mix( colorMiss( uv ), colorHit( eye, ab, d ), hit );\n    \n    //fog\n    //color = mix( color, vec3( .33, .11, .1 ), pow( d / MARCH.z, 3.33 ) * hit );\n    color = mix( color, vec3( .22, .11, .1 ), pow( d / MARCH.z, .933 ) );\n    //color = mix( color, vec3( .22, .11, .1 ), pow( d / MARCH.z, .33 ) * (1.-hit) );\n\n    ////////////////////////////////////////////////////////////////\n    \n    return vec4( color, 1. );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}