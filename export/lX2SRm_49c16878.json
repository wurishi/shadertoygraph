{"ver":"0.1","info":{"id":"lX2SRm","date":"1713218641","viewed":153,"name":"Circle perspective projection","username":"celifan","description":"Mixing rasterisation and ray casting to render projected square and inscribed circle.\n\n","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["circle","projection","ellipse","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//**************\n// Experimenting with rendering projected circle efficiently.\n// As I have plenty of them to render for a side project.\n// Any suggestion/ pointer more than welcome !\n//\n// **************\n// For convenience positions are expressed as integers in a [_n x _n] grid \nconst float s = 1.0; //  grid width in normalize pix coordinates\nconst float _n = 12.0; // grid num subdivision.\n\n// transformation to apply to vec2 in [_n X _n ] -->  normalize pix coordinates\n#define O (vec2(_ar/2.0,.1))\n#define V(x,y) (vec2(float(x),float(y))*s/_n)\n#define S(x) ((float(x))*s/_n) \n//\n\nconst float PI = 3.1415926;\nfloat _ar; //aspect ratio.\nfloat _pixSize ;\nconst float _lw =1.0; // default line width in pixels\nconst float _ps =3.0; // default point size in pixels\n\n// projection\nvec3 _eyePos = vec3(S(12),S(0),S(0));\nvec3 _aimPos = vec3(S(0),S(0),S(0));\nvec3 _eyeDir; // _aimPos-_eyePos\nvec3 _eyeDir01; // normalize(_eyeDir)\nvec3 _up= vec3(0.0,0.0,1.0);\nfloat _frameScale =2.1;\nvec3 _frameI,_frameJ; //frame (i,j) vectors\n\nfloat _eyePlaneDist = S(6);\n// default colors.\nconst vec3 _c0 = vec3(.95,.92,.9);\nconst vec3 _c1 =  vec3(0.4,0.4,0.4);\nconst vec3 _cBlue = vec3(0.0,0.36,1.0);\nconst vec3 _c2 = vec3(.9,.9,.9);\nconst vec3 _pc = vec3( .9,0.3,0.0); \nfloat _f ;\n#define CS(a) vec2(cos(a), sin(a))\n\n// cs = vec2(cos(rotAngle), sin(rotAngle));\nvec2 R(vec2 v, vec2 cs)\n{\n    return mat2(cs.x, cs.y, -cs.y, cs.x)*v;\n}\n\n// signed distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// solid stroke for the boundary of shape described by sd\nvoid strokeSolid( float sd, vec3 color,float lineWidth ,inout vec3 pixel  )\n{\n   \n    lineWidth = mix( lineWidth/1.1, lineWidth*1.1,_f);\n    pixel =  mix(pixel,color, (1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize,_pixSize*(lineWidth +.5), abs(sd)))));\n}\n\n\nvoid drawSegment(vec2 p, vec2 a, vec2 b,float lineWidth,\n                 vec3 color,\n                 inout vec3 pixel )\n{\n \n   float d =    sdSegment(p,a, b );\n   strokeSolid(d, color, lineWidth,pixel);\n}\n\n// draw a line with default line width and color\n#define DS(p,a,b,pixel)\\\ndrawSegment(p,a,b,_lw, _c1,pixel) \n\nvoid drawPoint(vec2 p, float pointSize, vec3 color, inout vec3 pixel )\n{\n   float sd =length(p);\n   pixel =  mix(pixel, color, (1.0 -sqrt(smoothstep((pointSize-1.0)*_pixSize, _pixSize*(pointSize +.5), abs(sd))))); \n}\n\n//perspective/orthographic proj\nvec2 proj(vec3 p, bool ortho)\n{\n    vec3 ep =p-_eyePos;\n    float d =length(ep);\n    float z = dot(ep,_eyeDir01);\n    vec3  pj = z*_eyeDir01;\n   \n    float ra = ortho ? 1.0 : _eyePlaneDist/z;\n    vec3 pjpe = (ep-pj)*_frameScale*ra;\n    return vec2(dot(_frameI,pjpe),dot(_frameJ,pjpe));\n}\n\n\n#define PRJ2(p,m)\\\n    proj(vec3(p,0.0),m) \n   \n\n// Draw point with default linewidth & color & ptSize\n#define DP(p,pixel)\\\n    drawPoint(p,_ps,_pc,pixel)\n\nvoid draw(vec2 p, inout vec3 pixel)\n{\n    vec3 sc= vec3(vec2(_ar)*.5, .5);   \n    //\n    vec2 p0 =  V(3,0)*sc.xy+ V(0,1);\n    vec2 p1 =  V(9,0)*sc.xy+ V(0,1);\n    vec2 p2 =  V(9,6)*sc.xy+ V(0,1);\n    vec2 p3 =  V(3,6)*sc.xy+ V(0,1);\n     \n    _aimPos =vec3((p0+p1+p2+p3)/4.0,0.0);\n    _eyePos = vec3(vec2(0.0,sin(iTime))*.2+V(0,3)*sc.xy+ V(0,1),cos(iTime)*.5+S(3)*sc.z*1.0);\n    _eyeDir = _aimPos -_eyePos;\n    _eyeDir01 = normalize(_eyeDir);\n    _eyePlaneDist =S(2)*sc.x*(.5+abs(sin(iTime))*3.0);\n    \n    _frameI = normalize(cross(_eyeDir01, _up));\n    _frameJ = normalize(cross(_frameI, _eyeDir01));\n    \n    \n    DP(p-_eyePos.xy,pixel);\n\n    DP(p-p0,pixel); DS(p,p0,p1,pixel);\n    DP(p-p1,pixel); DS(p,p1,p2,pixel);\n    DP(p-p2,pixel); DS(p,p2,p3,pixel);\n    DP(p-p3,pixel); DS(p,p3,p0,pixel);\n\n    vec2 A = V(4,1)*sc.xy+ V(0,1);\n    vec2 B= V(8,1)*sc.xy+ V(0,1);\n    vec2 C= V(8,5)*sc.xy+ V(0,1);\n    vec2 D = V(4,5)*sc.xy+ V(0,1);\n    DP(p-A,pixel);\n    DS(p,A,B,pixel);\n    DP(p-B,pixel);\n    DS(p,B,C,pixel);\n    DP(p-C,pixel);\n    DS(p,C,D,pixel);\n    DP(p-D,pixel);\n    DS(p,D,A,pixel);\n\n    // front view\n    vec2 p0f =  V(3,0)*sc.xz + V(0,7);\n    vec2 p1f =  V(9,0)*sc.xz+ V(0,7);\n    vec2 p2f =  V(9,6)*sc.xz+ V(0,7);\n    vec2 p3f =  V(3,6)*sc.xz+ V(0,7);\n\n    DP(p-p0f,pixel); DS(p,p0f,p1f,pixel);\n    DP(p-p1f,pixel); DS(p,p1f,p2f,pixel);\n    DP(p-p2f,pixel); DS(p,p2f,p3f,pixel);\n    DP(p-p3f,pixel); DS(p,p3f,p0f,pixel);\n\n    vec2 Cf = V(8,0)*sc.xy+ V(0,7);\n    DP(p-Cf,pixel);\n    vec2 Df = V(4,0)*sc.xy+ V(0,7);\n    DP(p-Df,pixel);\n     \n    vec2 eyePosf =  vec2(0.0,_eyePos.z+S(7));\n    DP(p-eyePosf,pixel);\n\n    vec2 aimf = (Cf+Df)/2.0;\n    DP(p-aimf,pixel);\n    DS(p, eyePosf, aimf,pixel);\n\n    // perspective view\n    vec2 poff = V(9,1);\n    vec2 p0p = V(0,0)+poff;\n    vec2 p1p = V(6,0)*sc.xy*_frameScale+poff;\n    vec2 p2p = V(6,6)*sc.xz*_frameScale+poff;\n    vec2 p3p = V(0,6)*sc.xz*_frameScale+poff;\n\n    vec2 p0p1p = p1p-p0p;\n    vec2 p1p2p = p2p-p1p;\n    vec2 p2p3p = p3p-p2p;\n    vec2 p3p0p = p3p-p0p;\n    //\n    bool inPersRec = dot(p-p0p,vec2(-p0p1p.y,p0p1p.x))>0.0 &&\n    dot(p-p1p,vec2(-p1p2p.y,p1p2p.x))>0.0 &&\n    dot(p-p2p,vec2(-p2p3p.y,p2p3p.x))>0.0 &&\n    dot(p-p3p,vec2(p3p0p.y,-p3p0p.x))>0.0;\n    pixel = inPersRec? _c1 : pixel;\n\n    DP(p-p0p,pixel); DS(p,p0p,p1p,pixel);\n    DP(p-p1p,pixel); DS(p,p1p,p2p,pixel);\n    DP(p-p2p,pixel); DS(p,p2p,p3p,pixel);\n    DP(p-p3p,pixel);DS(p,p3p,p0p,pixel);\n\n    vec2 pcp = (p0p+p1p+p2p+p3p)/4.0;\n    // project\n    vec2 pA =PRJ2(A,false);\n    vec2 pB =PRJ2(B,false);\n    vec2 pC =PRJ2(C,false);\n    vec2 pD =PRJ2(D,false);\n    //\n    DS(p,eyePosf,Cf,pixel);\n    //\n    DP(p-(pcp+pA), pixel);drawSegment(p,pcp+pA,pcp+pB,_lw,_pc, pixel);\n    DP(p-(pcp+pB), pixel);drawSegment(p,pcp+pC,pcp+pB,_lw,_pc, pixel);\n    DP(p-(pcp+pC), pixel);drawSegment(p,pcp+pC,pcp+pD,_lw,_pc, pixel);\n    DP(p-(pcp+pD), pixel);drawSegment(p,pcp+pD,pcp+pA,_lw,_pc, pixel);\n    // ray trace disk\n    if (inPersRec)\n    {\n      vec2 pin = (p-pcp)/_frameScale;\n      vec3 fc =(_eyePos +(_eyeDir01*_eyePlaneDist )) ;\n      vec3 pip = fc+  (_frameI*pin.x +_frameJ*pin.y);\n      vec3 rayDir = pip-_eyePos;\n      // plane normal \n      vec3 pN = cross(vec3(B,0.0)-vec3(A,0.0), vec3(D,0.0)-vec3(A,0.0));\n\n      float a = dot(pN,vec3(A,0.0)-_eyePos);\n      float b = dot(pN,rayDir);\n     \n      if (abs(b) >0.001)\n      {\n       float ab =a/b;\n       vec3 pi = _eyePos +rayDir*a/b;\n       float d = length(pi-_aimPos)-S(2)*sc.x;\n       //pixel =  d<0.0 ? vec3(0.0,0.5,0.3)*.5 : pixel;\n       float d1=abs(d)/length(vec2(dFdx(d),dFdy(d))/_pixSize);\n       strokeSolid(d1,_pc,_lw,pixel); \n      }\n    }\n    \n    float d = length(p-_aimPos.xy)-S(2)*sc.x;\n    //pixel =  d<0.0 ? vec3(0.0,0.5,0.3)*.5 : pixel;\n    strokeSolid(d,_pc,_lw,pixel); \n    // draw on top\n    DP(p-_aimPos.xy,pixel);\n    DS(p,_eyePos.xy,_aimPos.xy,pixel);\n    DS(p,_eyePos.xy,B,pixel);\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p2 =  fragCoord.xy/iResolution.y;\n    _ar = iResolution.x/iResolution.y;\n    _pixSize = 1.0/iResolution.y;\n  \n    // draw\n    vec3 pixel = vec3(.1);\n    draw(p2,pixel);\n       \n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}","name":"Image","description":"","type":"image"}]}