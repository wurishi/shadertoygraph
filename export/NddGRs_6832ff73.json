{"ver":"0.1","info":{"id":"NddGRs","date":"1630492502","viewed":143,"name":"project stochastics round 3","username":"Dusty","description":"noise everywhere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------\n// project stochastics round 3\n//\n// continuing goal: \n//\n//   approximate an ideal noise function,\n//   that reveals no visual correlations,\n//   when sampled at regular intervals,\n//   everywhere!\n//\n//   efficiency is still of only secondary consideration\n//\n//  note that all bijective transforms of a machine word can be viewed as some kind\n//  of shuffling - its shuffling all the way down - addition is a cut of the deck - \n//  bitwise rolling is a faro shuffle! - multiplication by odd numbers is like a\n//  weird multi-pile shuffle\n//\n//  always answering the question where does the Nth card go after this shuffle?\n//  \n//  thats how hashing do\n//\n//  the bijections used here are \n//  \n//    addition modulo 2^32 (cutting the deck)\n//    multiplication by primitive element modulo 2^32 (a pile making shuffle)\n//    xoring the high half of the word with the low half (sort of a block swapping shuffle)\n//\n// the shuffle is provably uniform, but correlations can be uniform too, so to hash, \n// shuffling is done more than once. \n//\n// Casinos require three riffle shuffles and a \"strip\", ending with a cut, \n// when shuffling by hand, for a reason! Here it is.\n//\n// The reason for many shuffles in both cases is that the ascending or \n// descending orderings of inputs to outputs is not sufficiently shuffled with \n// only a couple of mixing steps. cards that began near each other tend to appear \n// in an ordering related to the one that they began with until sufficient \n// shuffling is done.\n//\n// the crypto guys go hundreds of shuffling steps just to be sure that they have \n// achieved all properties of an ideal stochastic generator that are achievable \n// when using only bijections\n//\n// - lets not go that far - our level of analysis is visual, upon the scaled \n// regular latice of key space\n\n\n\n//  the refined shuffling step (like a single cut and riffle)\n//\n//    h  the machine word to be shuffled\n//    k  the machine word shuffle key\n//\n//  outputs machine word between 0u <= x <= 0xffffffffu \n\nuint shuffle(uint h, uint k)\n{\n    h += k; h ^= h >> 16; h *= 0xCC2BFE9Du;\n    return h;\n}\n\n//  point_noise()\n//\n//  noise at every point in space\n\nfloat point_noise(uint h, float key)\n{   uint k = floatBitsToUint(key); h = shuffle(shuffle(h, k), 0x8675309u);\n    return 5.96046448e-8 * float(0xffffffu & h); }\n\nfloat point_noise(uint h, vec2 key)\n{   uvec2 k = floatBitsToUint(key); h = shuffle(shuffle(shuffle(h, k.x), k.y), 0x8675309u);\n    return 5.96046448e-8 * float(0xffffffu & h); }\n\nfloat point_noise(uint h, vec3 key)\n{   uvec3 k = floatBitsToUint(key); h = shuffle(shuffle(shuffle(shuffle(h, k.x), k.y), k.z), 0x8675309u);\n    return 5.96046448e-8 * float(0xffffffu & h); }\n\nfloat point_noise(uint h, vec4 key)\n{   uvec4 k = floatBitsToUint(key); h = shuffle(shuffle(shuffle(shuffle(shuffle(h, k.x), k.y), k.z), k.w), 0x8675309u);\n    return 5.96046448e-8 * float(0xffffffu & h); }\n\n\nconst float pi = 3.14159265358979323846;\n#define cmix(e0, e1, x)         mix(e0, e1, 0.5 * (1.0 - cos(pi * (x))))\n\n//  lattice_noise()\n//\n//  noise on the key lattice\n\nfloat lattice_noise(uint h, float key)\n{   float i = floor(key), f = fract(key);\n    return cmix(point_noise(h, i + 0.0), point_noise(h, i + 1.0), f); }\n\nfloat lattice_noise(uint h, vec2 key)\n{   vec2 i = floor(key), f = fract(key);\n    return cmix(cmix(point_noise(h, i + vec2(0,0)), point_noise(h, i + vec2(0,1)), f.y),\n                cmix(point_noise(h, i + vec2(1,0)), point_noise(h, i + vec2(1,1)), f.y), f.x) ; }\n\nfloat lattice_noise(uint h, vec3 key)\n{   vec3 i = floor(key), f = fract(key);\n    return cmix(cmix(cmix(point_noise(h, i + vec3(0,0,0)), point_noise(h, i + vec3(0,0,1)), f.z),\n                     cmix(point_noise(h, i + vec3(0,1,0)), point_noise(h, i + vec3(0,1,1)), f.z), f.y),\n                cmix(cmix(point_noise(h, i + vec3(1,0,0)), point_noise(h, i + vec3(1,0,1)), f.z),\n                     cmix(point_noise(h, i + vec3(1,1,0)), point_noise(h, i + vec3(1,1,1)), f.z), f.y), f.x); }\n\nfloat lattice_noise(uint h, vec4 key)\n{   vec4 i = floor(key), f = fract(key);\n    return cmix(cmix(cmix(cmix(point_noise(h, i + vec4(0,0,0,0)), point_noise(h, i + vec4(0,0,0,1)), f.w),\n                          cmix(point_noise(h, i + vec4(0,0,1,0)), point_noise(h, i + vec4(0,0,1,1)), f.w), f.z),\n                     cmix(cmix(point_noise(h, i + vec4(0,1,0,0)), point_noise(h, i + vec4(0,1,0,1)), f.w),\n                          cmix(point_noise(h, i + vec4(0,1,1,0)), point_noise(h, i + vec4(0,1,1,1)), f.w), f.z), f.y),\n                cmix(cmix(cmix(point_noise(h, i + vec4(1,0,0,0)), point_noise(h, i + vec4(1,0,0,1)), f.w),\n                          cmix(point_noise(h, i + vec4(1,0,1,0)), point_noise(h, i + vec4(1,0,1,1)), f.w), f.z),\n                     cmix(cmix(point_noise(h, i + vec4(1,1,0,0)), point_noise(h, i + vec4(1,1,0,1)), f.w),\n                          cmix(point_noise(h, i + vec4(1,1,1,0)), point_noise(h, i + vec4(1,1,1,1)), f.w), f.z), f.y), f.x); }\n\n\nconst mat3 brown_transform = mat3(vec3(0.5,0,0), vec3(0,0.5,0), vec3(0,0,0.5)) * mat3(vec3(0.54030231, 0.84147098, 0), vec3(-0.84147098, 0.54030231, 0), vec3(0, 0, 1)) * mat3(vec3(1, 0, 0), vec3(0, 0.54030231, 0.84147098), vec3(0, -0.84147098, 0.54030231));\n\nfloat brown_noise(uint h, vec3 key, int steps)\n{  \n  key *= exp2(float(steps));\n  float c = lattice_noise(h, key); \n  for(int i = 1; i < steps; i++) \n    c += 0.5 * (lattice_noise(h + uint(i), key *= brown_transform) - c);\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // give brown noise a workout\n    vec3 pos = 0.003 * vec3(fragCoord.xy, 30.0 * iDate.w);\n    float c = 1.0; for(int i = 0; i < 6; i++) c = min(c, brown_noise(uint(i), pos, 8));\n    fragColor = vec4(c*c, c, sqrt(c),1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}