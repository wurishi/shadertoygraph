{"ver":"0.1","info":{"id":"XlcfDn","date":"1539165831","viewed":196,"name":"Chromosome","username":"HuRamb","description":"Result of a practical lesson on implicit surfaces & sphere tracing.\n\nBased on a sphere tracing code provided by Eric Galin.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spheretracing","helix","signeddistancefunction","chromosome","id3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265359\n\n#define custom_color 1\n#define custom_lambda 0\n#define rotate_mode 3\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// ---------- Animation functions ---------- //\n\nfloat animate(float min_value, float max_value, float period, float time) {\n    float x = (time / period) * 2.0 * M_PI;\n    float s = (sin(x) + 1.0) / 2.0;\n    return min_value + ((max_value - min_value) * s);\n}\n\n// ---------- Transforms ---------- //\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Value of the lambda aka Liptschitz constant\n// e : energy associated to the primitive\n// R : radius associated to the primitive\nfloat lambda(float e, float R){\n    // maximum of the falloff function derivative\n    float lambda_zero = 96. / (25. * sqrt(5.));\n    \n    return e * lambda_zero / R;\n}\n\n// ---------- Primitive shapes --------- //\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Line skeleton\n// p : point\n// d : line direction; must be normalized\nfloat line(vec3 p, vec3 o, vec3 d, float e, float R){\n    vec3 p_on_line = o + dot(d, p - o) * d;\n    return e * falloff(length(p - p_on_line), R);\n}\n\n// Segment skeleton\n// p : point\n// A, B : extremities of the segment\nfloat segment(vec3 p, vec3 A, vec3 B, float e, float R){\n  \n  vec3 Ap = p - A;\n  vec3 AB = B - A;\n  float param = dot(AB, Ap) / dot(AB, AB);\n  param = clamp(param, 0., 1.); // sphere is located at the extremities if not on the segment\n    \n  return e * falloff(length(Ap - AB * param), R); // distance to the closest point from the segment (ie sphere)\n}\n\n// Cuboid skeleton\n// p : point\n// min_bbox : min of the cube\n// max_bbox : max of the cube\nfloat cuboid(vec3 p, vec3 min_bbox, vec3 max_bbox, float e, float R){\n    \n    vec3 cube_center = (min_bbox + max_bbox) / 2.; // centering the cube\n    vec3 p_cube_coord = abs(p - cube_center); // 'folding' the coordinates inside the cube with all three positive coord\n    \n    vec3 cube_half_size = abs(max_bbox - min_bbox) / 2.;\n    \n    vec3 p_to_cube_dim = p_cube_coord - cube_half_size;\n    float p_to_cube_distance = max(max(p_to_cube_dim.x, p_to_cube_dim.y), p_to_cube_dim.z);\n    \n    return e * falloff(p_to_cube_distance, R);\n}\n\n// 'Rounded' Cuboid skeleton\n// p : point\n// min_bbox : min of the cube\n// max_bbox : max of the cube\nfloat rounded_cuboid(vec3 p, vec3 min_bbox, vec3 max_bbox, float e, float R){\n    \n    vec3 p_to_cube_dim;\n    p_to_cube_dim.x = min(min(0., p.x - min_bbox.x), min(0., max_bbox.x - p.x));\n    p_to_cube_dim.y = min(min(0., p.y - min_bbox.y), min(0., max_bbox.y - p.y));\n    p_to_cube_dim.z = min(min(0., p.z - min_bbox.z), min(0., max_bbox.z - p.z));\n    \n    float p_to_cube_distance = sqrt(dot(p_to_cube_dim, p_to_cube_dim));\n    \n    return e * falloff(p_to_cube_distance, R);\n}\n\n// 'Rounded' Cuboid skeleton\n// p : point\n// d : diagonal\nfloat rounded_cuboid_better(vec3 p, vec3 d, float e, float R){\n    \n    vec3 p_to_cube_dim = abs(p) - d;\n    float p_to_cube_distance = length(max(p_to_cube_dim, 0.));\n    \n    return e * falloff(p_to_cube_distance, R);\n}\n\n// 'Rounded' Cuboid skeleton using a smooth maximum\n// p : point\n// min_bbox : min of the cube\n// max_bbox : max of the cube\nfloat rounded_cuboid_smooth(vec3 p, vec3 min_bbox, vec3 max_bbox, float e, float R){\n\n    // centering the cube\n    vec3 cube_center = (min_bbox + max_bbox) / 2.;\n    vec3 p_cube_coord = abs(p - cube_center); // 'folding' the coordinates inside the cube with all three positive coord\n    \n    vec3 cube_half_size = abs(max_bbox - min_bbox) / 2.;\n    \n    vec3 p_to_cube_dim = p_cube_coord - cube_half_size;\n    \n\t// Using a smooth maximum\n    float smooth_max_power = 2.5;\n    float p_to_cube_distance = p_to_cube_dim.x * exp(smooth_max_power * p_to_cube_dim.x)\n        \t\t\t\t\t+ p_to_cube_dim.y * exp(smooth_max_power * p_to_cube_dim.y)\n        \t\t\t\t\t+ p_to_cube_dim.z * exp(smooth_max_power * p_to_cube_dim.z);\n    p_to_cube_distance /= exp(smooth_max_power * p_to_cube_dim.x)\n        \t\t\t\t+ exp(smooth_max_power * p_to_cube_dim.y)\n        \t\t\t\t+ exp(smooth_max_power * p_to_cube_dim.z);\n\n    return e * falloff(p_to_cube_distance, R);\n}\n\n// Disc skeleton\n// p : point\nfloat disc(vec3 p, vec3 c, float r, vec3 n, float e, float R){\n    \n\n    float p_to_plane = dot(n, p - c);\n    vec3 p_on_plane = p - p_to_plane * n;\n    \n    float p_on_plane_to_circle = max(0., length(p_on_plane - c) - r);    \n    float p_to_disc_space = sqrt(p_on_plane_to_circle * p_on_plane_to_circle\n                                + p_to_plane * p_to_plane);\n    \n    return e * falloff(p_to_disc_space, R);\n}\n\n// 'Round' Cylinder skeleton\n// p: point\n// A, B : extremities of the cylinder\n// radius : radius of the cylinder\nfloat round_cylinder(vec3 p, vec3 A, vec3 B, float radius, float e, float R){\n    // distance to disc on A\n    vec3 planeA_normal = normalize(B - A);\n    float p_to_planeA = dot(planeA_normal, p - A);\n    vec3 p_on_planeA = p - p_to_planeA * planeA_normal;\n    float p_on_planeA_to_circle = max(0., length(p_on_planeA - A) - radius);\n    \n    float dist_discA = sqrt(p_on_planeA_to_circle * p_on_planeA_to_circle\n                           + p_to_planeA * p_to_planeA);\n    \n    // distance to disc on B\n    vec3 planeB_normal = normalize(A - B);\n    float p_to_planeB = dot(planeB_normal, p - B);\n    vec3 p_on_planeB = p - p_to_planeB * planeB_normal;\n    float p_on_planeB_to_circle = max(0., length(p_on_planeB - B) - radius);\n    \n    float dist_discB = sqrt(p_on_planeB_to_circle * p_on_planeB_to_circle\n                           + p_to_planeB * p_to_planeB);\n    \n    // distance to cylinder body\n    vec3 Ap = p - A;\n    vec3 AB = B - A;\n    float body_param = dot(AB, Ap) / dot(AB, AB);\n    \n    float dist_body;\n    if(body_param < 0. || body_param > 1.){\n        dist_body = dist_discA + dist_discB;\n    }else{\n        dist_body = length(Ap - AB * body_param) - radius;\n    }\n  \n    float distance_to_cylinder = min(min(dist_discA, dist_discB), dist_body);\n    \n    return e * falloff(distance_to_cylinder, R);\n}\n\n// Torus skeleton\n// p : point\n// c : center of the tore\n// r : radius of the major circle of the tore ie radius of the loop on the plane\n// n : normal of the circle plane; must be normalized\nfloat torus(vec3 p, vec3 c, float r, vec3 n, float e, float R){\n\t\n    float p_to_plane = dot(n, c - p);\n    \n    vec3 p_on_plane = p + p_to_plane * n;\n    \n    float p_to_circle_on_plane = length(p_on_plane - c) - r;\n    \n    float p_to_circle_in_space = sqrt(p_to_plane * p_to_plane + p_to_circle_on_plane * p_to_circle_on_plane);\n    \n    return e * falloff(p_to_circle_in_space, R);\n}\n\n// Elipsoid skeleton\n// p : point\n// c : center of the elipsoid\n// aspect_ratio : (a, b, c) coefficients in the equatoin of the elipsoid (x^2 / a^2) + (y^2 / b^2) + (z^2 / c^2) = 1\nfloat elipsoid(vec3 p, vec3 c, vec3 aspect_ratio, float e, float R){\n  \n    //vec3 lc = p - c; // local coord\n    vec3 lc = p + c;\n    \n    float distance_to_elipsoid = (lc.x * lc.x) / (aspect_ratio.x * aspect_ratio.x)\n        \t\t\t\t\t\t+ (lc.y * lc.y) / (aspect_ratio.y * aspect_ratio.y)\n        \t\t\t\t\t\t+ (lc.z * lc.z) / (aspect_ratio.z * aspect_ratio.z);\n    \n    return e * falloff(distance_to_elipsoid, R);\n}\n\nfloat cone(vec3 p, float angle, float e, float R){\n    float distance_to_cone = p.x * p.x + p.y * p.y - p.z * p.z * tan(angle);\n    \n    return e * falloff(distance_to_cone, R);\n}\n\n// ---------- Combinations ---------- //\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersect(float a, float b)\n{\n    return min(a, b);\n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Difference(float a, float b)\n{\n    return min(a, 2. * T - b);\n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat DifferenceBlend(float a, float b)\n{\n    return a - b;\n}\n\n// Interpolate\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Interpolate(float a, float b, float speed, float min_value, float max_value){\n    return mix(a, b, min_value + (max_value - min_value) * (0.5 + 0.5 * sin(speed * M_PI)));\n}\n\n// Repeat\n// p : point\n// c : period\n// distance : signed distance function to repeat\nvec3 Repeat(vec3 p, vec3 period)\n{\n    return mod(p, period) - 0.5 * period;\n}\n\nvec3 Twist(vec3 p, float freq){\n    float cos_value = cos(freq * p.y);\n    float sin_value = sin(freq * p.y);\n    \n    mat2  rot_matrix = mat2(cos_value, -sin_value,\n                            sin_value, cos_value);\n    \n    return vec3(rot_matrix * p.xz, p.y);\n}\n\n\n// ---------- Lambda Combinations ---------- //\n// Based on the rules of the addition / min / max of two derivative\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat lambdaBlend(float lambdaA, float lambdaB){\n    return lambdaA + lambdaB;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat lambdaUnion(float lambdaA, float lambdaB){\n    return max(lambdaA, lambdaB);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat lambdaIntersec(float lambdaA, float lambdaB){\n    return max(lambdaA, lambdaB);\n}\n\n// Interpolate\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat lambdaInterpolate(float a, float b, float speed, float min_value, float max_value){\n    return mix(a, b, min_value + (max_value - min_value) * (0.5 + 0.5 * sin(speed * M_PI)));\n}\n\n// ---------- Scene objects ---------- //\n\nfloat SUR_LES_ROTULES(vec3 p){\n    float v = segment(p, vec3(-1., -1., -1.), vec3(1., 1., 1.), 1., 4.5);\n    \n    for(int i = 0; i != 300; ++i){\n        v = Blend(v, point(p, vec3(0., 0., 0.), 1., 4.5));\n    }\n    \n    return v;\n}\n\nfloat libellule(vec3 p){\n    vec3 min_bbox = vec3(-30., -100., -5.);\n    vec3 max_bbox = vec3(30., 100., 5.);\n    float bounding_box = cuboid(p, min_bbox, max_bbox, 1., 1.);\n    \n    vec3 spatial_repeat;\n    spatial_repeat.x = 4.;\n    spatial_repeat.y = 4.;\n    spatial_repeat.z = 6.;\n    \n    vec3 repeat_sphere_coord = vec3(p.x + 0.9 + cos(M_PI * iTime), p.y - 0.9 + 1.5 * iTime, p.z + 0.4 * sin(M_PI * iTime));\n    float sphere_repeat = point(Repeat(repeat_sphere_coord, spatial_repeat), vec3(0., 0., 0.), 1., 4.5);\n    \n    vec3 unique_coord = vec3(p.x, p.y, p.z);\n    float sphere_unique = point(unique_coord, vec3(0., 0., 0.), 1., 4.5);\n    \n    float cube_unique = rounded_cuboid_better(Repeat(unique_coord, vec3(10.5, 10.5, 0.)), vec3(4.5, 4.5, 3.), 1., 1.);\n    \n    float together = Interpolate(sphere_repeat, cube_unique, 0.25 * iTime, 0.3, 0.4);\n    float tog = Interpolate(together, sphere_unique, 0.5 * iTime, 0.25, 2.);\n    \n    return Intersect(bounding_box, tog);\n}\n\nfloat tasse(vec3 p){\n    float v = round_cylinder(p, vec3(0., -1., 0.), vec3(0., 3., 0.), 1., 1., 4.5);\n\tv = Blend(v, torus(p, vec3(5., 2., 0.), 2., vec3(0., 0., 1.), 1., 1.));\n\tv = Difference(v, round_cylinder(p, vec3(0., 0., 0.), vec3(0., 4., 0.), 0.6, 1., 4.5));\n\tv = Blend(v, torus(p, vec3(0., 4., 0.), 2.5, vec3(0., 1., 0.), 1., 0.5));\n    \n    return v;\n}\n\nfloat lambdaEbola(){\n    float helix = lambda(1., 1.5);\n    float helix_link = lambda(1., 0.5);\n    float linked_double_helix = lambdaUnion(lambdaUnion(helix, helix), helix_link);\n    \n    float background_spheres = lambda(1., 0.75);\n    float helix_spheres = lambdaUnion(linked_double_helix, background_spheres);\n    \n    float chromosome_arm = lambda(1., 3.5);\n    float chromosome = lambdaBlend(chromosome_arm, chromosome_arm);\n    \n    float square_walls = lambda(1., 0.5);\n    float chromosome_walls = lambdaUnion(chromosome, square_walls);\n    \n    float scene_lambda = lambdaUnion(linked_double_helix, chromosome_walls);\n    \n    return scene_lambda;\n}\n\nfloat Ebola(vec3 p){\n    \n    float time_synchro = 3. * M_PI / 2. + iTime;\n    \n    // Filaments ADN\n    vec3 size_ratio = vec3(1.5, 3.5, 1.5);    \n    vec3 spatial_repeat = vec3(12., 0., 0.);\n    vec3 helix_decal = vec3(0., 0., 2.5);\n    \n    vec3 p_helix = p;\n    p_helix.x = abs(p_helix.x);\n    \n    float helixA = line(Twist(rotateY(Repeat(size_ratio * p_helix + helix_decal + vec3(0.2 * sin(p.y + iTime), 0., 0.), spatial_repeat), iTime), 0.1), vec3(0., 3., 0.), vec3(0., 0., 1.), 1., 1.5);\n    float helixB = line(Twist(rotateY(Repeat(size_ratio * p_helix + helix_decal + vec3(0.2 * sin(p.y + iTime), 0., 0.), spatial_repeat), iTime), 0.1), vec3(0., -3., 0.), vec3(0., 0., 1.), 1., 1.5);\n    \n    float linkAB = segment(Repeat(Twist(rotateY(Repeat(size_ratio * p_helix + helix_decal + vec3(0.2 * sin(p.y + iTime), 0., 0.), spatial_repeat), iTime), 0.1), vec3(0., 0., 1.)), vec3(0., 3., 0.), vec3(0., -3., 0.), 1., 0.5);\n    \n    float double_helix = Union(helixA, helixB);\n    float linked_double_helix = Union(double_helix, linkAB);\n    \n    // Additional background spheres\n    vec3 sphere_p = abs(Repeat(p + vec3(0., -2.5 * iTime, 0.), vec3(9., 5., 0.))) + vec3(0., 0., 0.);\n    float sphere = point(sphere_p, vec3(4.5, 0., 0.), 1., 0.75);\n    float helix_spheres = Union(linked_double_helix, sphere);\n    \n    // Chromosome\n    float sin_var = max(0.05, min(0.7, (0.45 + 0.55 * sin(time_synchro))));\n    float s = 2. + 50. * sin_var; // chromosome size\n    vec3 as = vec3(s / 2., s, s / 2.); // chromosome aspect ratio\n    \n    vec3 chr_p = abs(p);\n    \n    float chromosomeA = elipsoid(rotateZ(chr_p - vec3(0.65 * s, s, 0.), - M_PI / 6.), vec3(0., 0., 0.), as, 1., 3.5);\n    float chromosomeB = elipsoid(rotateZ(chr_p - vec3(0.65 * s, -s, 0.), M_PI / 6.), vec3(0., 0., 0.), as, 1., 3.5);\n    \n    float chromosomeAB = Blend(chromosomeA, chromosomeB);\n    \n    // Walls of squares\n    vec3 wall_p = rotateX(Repeat(abs(rotateX(p, 1. - sin_var)) + vec3(-20. + 0.5 * p.z, 0., 0.), vec3(0., 5., 5.)), 1.25 * iTime);\n    float square_walls = rounded_cuboid_better(wall_p, vec3(1.5, 1.5, 1.5), 1., 0.5);\n    chromosomeAB = Union(chromosomeAB, square_walls);\n    \n    // Bounding Box / Cone Inside Chromosome\n    //float box_hole_distance = cuboid(p, vec3(-100., -100., -13.), vec3(100., 100., 10.), 1., 4.5);\n    float cone_hole_distance = cone(p + vec3(0., 0., 10. + 10.), -0.1 + 1.5 * sin_var, 1., 4.5);\n    \n\tfloat hole_chromosome = Difference(chromosomeAB, cone_hole_distance);\n    \n    float inside_chromosome = Difference(helix_spheres, Difference(helix_spheres, chromosomeAB));\n    \n    return Union(hole_chromosome, inside_chromosome);\n    //return noise_globs;\n}\n\n// ---------- Tracing functions ---------- //\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  \n    // ----- Empty scene ----- //\n    //float v = 0.;\n    \n    // ----- Examples of primitives ----- //\n\t//float v = point(p, vec3(0.0, 0.0, 0.0), 1.0, 15.5);\n\t//float v = segment(p, vec3(-5.f, -5.f, -5.f), vec3(5.f, 5.f, 5.f), 1.0, 10.5);\n    //float v = round_cylinder(p, vec3(-5.f, -5.f, -5.f), vec3(5.f, 5.f, 5.f), 2., 1.0, 4.5);\n    //float v = disc(p, vec3(0., 0., 0.), 6., normalize(vec3(-1., 1., 0.)), 1., 4.5);\n    //float v = torus(p, vec3(0., 0., 0.), 3., normalize(vec3(1., 0., 0.)), 1., 3.5);\n    //float v = cuboid(p, vec3(-1., -1., -1.), vec3(1., 1., 1.), 1., 4.5);\n    //float v = rounded_cuboid(p, vec3(-1., -1., -1.), vec3(1., 1., 1.), 1., 4.5);\n    //float v = rounded_cuboid_smooth(p, vec3(-1., -1., -1.), vec3(1., 1., 1.), 1., 7.5);\n    //float v = line(p, vec3(0., 0., 0.), normalize(vec3(0., 1., 0.)), 1., 4.5);\n    //float v = elipsoid(p, vec3(0., 0., 0.), vec3(1., 1., 1.), 1., 4.5);\n    //float v = cone(p, 0.3, 1., 4.5);\n    \n    //float v = Interpolate(v1, v2, iTime, 0., 1.);\n    \n    // ----- Scenes with combinations of primitives ----- //\n    //float v = SUR_LES_ROTULES(p);\n    //float v = libellule(p);\n    float v = Ebola(p);\n    //float v = tasse(p);\n    \n  return v-T;\n}\n\n// Value of the lambda Lipschitz constant\n// according to the primitives inside object(vec3)\nfloat objectLambda(){\n    \n    #if custom_lambda == 1\n    return lambdaEbola();\n    #endif\n    \n    #if custom_lambda == 0\n    return 2.; // default value - less accurate but very often more efficient\n    #endif\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n    \n    // Lipschitz constant    \n    float lambda_value = objectLambda();\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lambda_value);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using enhanced sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// omega : over-relaxation parameter; in [1; 2[\nfloat EnhancedSphereTrace(vec3 o, vec3 u, out bool h, out int s, float omega)\n{\n  h = false;\n    \n    // makes sure the enhanced test won't fail at first iteration\n    float step_length = 0.;\n    float previous_sphere_radius = 0.;\n    \n    // Don't start at the origin, instead move a little bit forward\n    float t=rA; // step distance\n    \n    // Lipschitz constant\n    float lambda_value = objectLambda();\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n      \n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      \n      // Move along ray\n      float sphere_radius = max(Epsilon,abs(v)/lambda_value);\n      \n      bool enhanced_fail = ((omega > 1.) && ((previous_sphere_radius + sphere_radius) < step_length));\n      \n      if(enhanced_fail){\n          step_length -= omega * step_length; // back to previous position\n          omega = 1.; // disabling enhanced sphere tracing\n      }else{\n          step_length = omega * sphere_radius;\n      }\n      \n      previous_sphere_radius = sphere_radius;\n      t += step_length;\n      \n      \n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n\n  #if custom_color == 0\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n  #endif\n    \n  #if custom_color == 1\n  float time_synchro = 3. * M_PI / 2. + iTime;\n  float sin_var = max(0.05, min(1., (0.45 + 0.55 * sin(time_synchro))));  \n  return mix(vec3(1. - sin_var + 0. - sin_var, 0., 0.), vec3(0.5 + 1. - sin_var, 0.5, 0.5), rd.y*0.5+0.5);\n  #endif\n\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{  \n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n \n  #if custom_color == 0\n  vec3 lightColor = vec3(0.5, 0.5, 0.5);\n  #endif\n    \n  #if custom_color == 1\n  float time_synchro = 3. * M_PI / 2. + iTime;\n  float sin_var = max(0.05, min(1., (0.45 + 0.55 * sin(time_synchro))));  \n  vec3 lightColor = vec3(0.5 + sin_var, 0.5 + sin_var, 0.5 + sin_var);\n  #endif\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   //return vec3(t,0.25+0.75*t,0.5-0.5*t);\n    \n   float time_synchro = 3. * M_PI / 2. + iTime;\n   float sin_var = max(0.5, min(0.8, (0.45 + 0.55 * sin(time_synchro))));\n   return vec3(sin_var * 5. * t,\n               sin_var * 5. * t,\n               sin_var * 5. * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -1.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n  \n  //vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  \n  //ro = rotateX(ro, -0.8); // up view\n  //ro.z += 10.;\n  \n  #if rotate_mode == 1\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n  #endif\n  \n  #if rotate_mode == 2\n  ro = rotateX(rotateY(ro, a), a);\n  rd = rotateX(rotateY(rd, a), a);\n  #endif\n\n  #if rotate_mode == 3\n  float time_synchro = 3. * M_PI / 2. + iTime;\n  float sin_var = max(0., min(0.8, 1.5 * (0.45 + 0.55 * sin(M_PI + time_synchro))));\n  \n    \n  ro = rotateZ(ro, 3.9 * sin_var);\n  rd = rotateZ(rd, 3.9 * sin_var);\n  #endif\n    \n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n  //float t = SphereTrace(ro, rd, hit,s);\n  float t = EnhancedSphereTrace(ro, rd, hit,s, 1.2);\n  vec3 pos=ro+t*rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  rgb += ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}