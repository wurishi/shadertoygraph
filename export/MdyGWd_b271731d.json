{"ver":"0.1","info":{"id":"MdyGWd","date":"1457026571","viewed":332,"name":"Ellipsoid Shadow Formula v2","username":"Cellulose","description":"Use your mouse to rotate the (4x2x1) ellipsoid.<br/>The shadow cast by an ellipsoid is always an ellipse.<br/>Getting the shape of the shadow ellipse (yellow) is trivial if we express it as a level surface of a gaussian distribution (blue).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math","shadow","geometry","statistics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate(vec3 sora)\n{\n    float ang = length(sora);\n    vec3  ax = sora/((ang==0.0) ? 1.0 : ang);\n    float s = sin(ang);\n    float c = cos(ang);\n    float oc = 1.0 - c;\n    \n    return mat3(oc*ax.x*ax.x + c,       oc*ax.x*ax.y - ax.z*s,  oc*ax.z*ax.x + ax.y*s,\n                oc*ax.x*ax.y + ax.z*s,  oc*ax.y*ax.y + c,       oc*ax.y*ax.z - ax.x*s,\n                oc*ax.z*ax.x - ax.y*s,  oc*ax.y*ax.z + ax.x*s,  oc*ax.z*ax.z + c     );\n}\n\nmat3 transpose_func(mat3 m)\n{\n    return mat3(\n        m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //The size of the 3D ellipsoid, called a \"bead\" for brevity.\n    vec3 beadSize = vec3(1.0, .50, .25);\n    \n    //Mouse control vector\n    vec2 mouseSelect = 2.0 * (iMouse.xy / iResolution.xy) - vec2(1.0);\n    \n    //The orientation of the bead.\n    mat3 beadOri =\n        rotate(vec3(0.0,mouseSelect.x*-3.14,0.0)) *\n        rotate(vec3(mouseSelect.y*2.0,0.0,0.0));\n        \n    \n    //Compute a covariance matrix describing the oriented bead.\n    mat3 mBead = mat3(1.0);\n    mBead[0][0] = beadSize.x;\n    mBead[1][1] = beadSize.y;\n    mBead[2][2] = beadSize.z;\n    mBead = beadOri * mBead * transpose_func(beadOri);\n    \n    //The shadow can be described by a 2x2 covariance matrix...\n    //  This is just the XY submatrix of the bead's matrix.\n      \n    //We might use the shadow matrix directly if we weren't rendering it...\n    mat2 mShadow = mat2(\n        mBead[0][0], mBead[0][1],\n        mBead[1][0], mBead[1][1]);\n    \n    //...Except we need to use inverse matrices to do sampled rendering.\n    \n    \n    //Simplified mShadowDet formula\n    float\n        o00 = beadOri[0][0],\n        o01 = beadOri[0][1],\n        o02 = beadOri[0][2],\n        o10 = beadOri[1][0],\n        o11 = beadOri[1][1],\n        o12 = beadOri[1][2];\n    float mShadowDet2\n    \t= beadSize.x*beadSize.y *\n        \t( o00*o00*o11*o11 + o10*o10*o01*o01\n            - o00  *  o11     * o10  *  o01)\n        + beadSize.y*beadSize.z *\n        \t( o01*o01*o12*o12 + o11*o11*o02*o02\n            - o01  *  o12     * o11  *  o02)\n        + beadSize.z*beadSize.x *\n        \t( o02*o02*o10*o10 + o12*o12*o00*o00\n            - o02  *  o10     * o12  *  o00);\n    \n    \n    //Then take the XY submatrix of that.\n    float mShadowDet = (mShadow[0][0]*mShadow[1][1]-mShadow[0][1]*mShadow[1][0]);\n    mat2 mShadowInv = mat2(\n        mShadow[1][1]/mShadowDet, mShadow[0][1]/mShadowDet, \n        mShadow[1][0]/mShadowDet, mShadow[0][0]/mShadowDet);\n    \n    \n    // (this is the screen coordinate space for sampling.)\n    vec2 loc = 2.0 * (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    \n    //Map into ellipse-space.  Are we in the shadow?\n    vec2 shadowPos = mShadowInv * loc;\n    bool inShadow = length(shadowPos) < 1.0;\n    \n    //vec3 beadPos = mBeadInv * vec3(loc, 0.0);\n    //bool inBead = (length(beadPos) < 1.0);\n    \n    fragColor = vec4(\n        (inShadow?1.0:0.0),\n        (inShadow?1.0:0.0),\n        1.5/(1.0+length(shadowPos)), 1.0);\n    \n    if (loc.x < -1.25 && (.5+.5*loc.y) < (2.0*mShadowDet)) fragColor.r = 1.0;\n    \n    //Add a grid pattern\n    fragColor.rgb += vec3((floor(4.0*loc+vec2(.03,.03))!=floor(4.0*loc-vec2(.03,.03))) ? 0.1 : 0.0);\n}","name":"Image","description":"","type":"image"}]}