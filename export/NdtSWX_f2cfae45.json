{"ver":"0.1","info":{"id":"NdtSWX","date":"1634069999","viewed":91,"name":"newtons fractals","username":"hggg","description":"college debts and sleep deprivation are not cool, but 3Blue1Brown is","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// step = -f(x)/f'(x)\n// (x-x1)(x-x2)(x-x3) = 0\n\n// f(x) = (x-x1)(x-x2)(x-x3) = x^3 + (b/a)x^2 + (c/a)x + d/a = 0\n// b/a = -x1 -x2 -x3              (probably)\n// c/a = x1x2 + x2x3 + x1x3       (probably 2nd time)\n// f'(x) = 3x^2 + 2(b/a)x + c/a   (hopefully)\n\n// complex solutions as vec2:\nvec2 sol[3] = vec2[3](vec2(1.0, 0.0), vec2(-0.5, -0.866025403784),  vec2(-0.5, 0.866025403784));\nvec2 ba;// = -sol[1]-sol[2]-sol[0]; // b/a\nvec2 ca;// = sol[0]*sol[1] + sol[1]*sol[2] + sol[2]*sol[0]; // c/a\n\n// colours\nvec3 solcol[3] = vec3[3](vec3(1.0, .0, .0), vec3(.0, 1.0, .0), vec3(.0, .0, 1.0));\n\n\nvec2 f(vec2 x) { // (x-x1)(x-x2)(x-x3)\n    return cmplxmult(cmplxmult( x-sol[0] , x-sol[1] ), x-sol[2] );\n}\n\nvec2 f_prime(vec2 x) { // 3x^2 + 2(b/a)x + c/a\n    return 3.0*cmplxmult(x,x) + 2.0*cmplxmult(ba, x) + ca;\n}\n\nvec2 next_step(vec2 x) { // step = -f(x)/f'(x)\n    return -cmplxdiv(f(x), f_prime(x));\n}\n\nconst float s = 16.0; // tiles/screenW\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    sol[0] += vec2(5.0*sin(iTime/4.0), 3.0*sin(iTime/2.0));\n    sol[1] += vec2(4.0*sin(iTime/2.0), 2.0*sin(iTime/4.0));\n    sol[2] += vec2(6.0*sin(1.5*iTime/4.0), 4.0*sin(3.0*iTime/4.0));\n    ba = -sol[0]-sol[1]-sol[2]; // b/a\n    ca = cmplxmult(sol[0],sol[1]) \n        + cmplxmult(sol[1],sol[2])\n        + cmplxmult(sol[2],sol[0]); // c/a\n    vec2 t = iResolution.xx/s; // tile dimension\n    vec2 uv = fc/iResolution.xy;\n    vec2 c = (fc.xy-(iResolution.xy/2.0) )/t.xy;\n    vec2 fmou = (iMouse.xy-iResolution.xy/2.0)/t.xy;\n    float borderw = 1.0/iResolution.x*s;\n    \n    vec2 rem = vec2(abs(round(c.x) - c.x), abs(round(c.y) - c.y));\n    vec3 col = (0.25 + 0.5*step(0.5, 1.0-min(round(abs(c.x) + 0.4), round(abs(c.y) + 0.4)))\n        ) * vec3(0.0, 1.0, 1.0) * (1.0 - min(\n        step(0.5, 1.0-(0.5 + borderw - rem.x) ),\n        step(0.5, 1.0-(0.5 + borderw - rem.y) )\n    ));\n    \n    int ni = 0; // nearest sol's index\n    vec2 x = c.xy;\n    vec2 nstep;\n    float ii = 0.0; // sum\n    int m = 20;//1+int(iTime) % 20; // uncomment to see transition as m increases\n    for (int i = 0; i < m; i++) {\n        nstep = next_step(x);\n        x += nstep;\n        \n        if (iMouse.z > 0.0)\n            ii += 1.0;\n        else\n            ii += length(nstep);\n        \n        if (length(nstep) < 0.00001) {\n            break;\n        }\n    }\n    \n    float d = 9999999999999999.0;\n    for (int i = 0; i < 3; i++) {\n        float t = distance(x, sol[i]);\n        if (t < d) {\n            d = t;\n            ni = i;\n        }\n    }\n    col += (1.0-pow(0.8, 0.5*ii)*sqrt(float(m))/7.0)*solcol[ni];\n    for (int i = 0; i < 3; i++) {\n        col += 0.75 * step(0.95, 1.0-length(c-sol[i]));\n        col += 0.5 * step(0.8, 1.0-length(c-sol[i]));\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// i derived them so idk if theyre actually correct\nvec2 cmplxmult(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x - a.y*b.y, a.y*b.x + a.x*b.y);\n}\nvec2 cmplxcjg(vec2 x) { // conjugation\n    return vec2(x.x, - x.y);\n}\nvec2 cmplxdiv(vec2 a, vec2 b) { // complex division a/b\n    return cmplxmult(a, cmplxcjg(b)) / (b.x*b.x + b.y*b.y);\n}\n//vec2 cmplxexp()","name":"Common","description":"","type":"common"}]}