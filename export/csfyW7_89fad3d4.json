{"ver":"0.1","info":{"id":"csfyW7","date":"1691518315","viewed":81,"name":"Neon Maths Equations [V 1.2]","username":"sagescherrytree","description":"More modifications to original maths based code based on noise.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","perlinnoise","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette(float t) {\n    //vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 a = vec3(0.500, 0.500, 0.770);\n    //vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.610, 0.500, 0.790);\n    //vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 c = vec3(0.801, 0.800, 0.664);\n    //vec3 d = vec3(0.263,0.416,0.557);\n    //vec3 d = vec3(1.388, -0.842, -0.132);\n    //vec3 d = vec3(1.388, -0.842, 0.628);\n    vec3 d = vec3(-0.682, -0.485, 2.675);\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nfloat f(vec3 p) \n{\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 32; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec2 random(vec2 r) {\n    return fract(sin(vec2(dot(r, vec2(127.1, 311.7)), dot(r, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat surflet(vec2 P, vec2 gridPoint) {\n    // Compute falloff function by converting linear distance to a polynomial\n    float distX = abs(P.x - gridPoint.x);\n    float distY = abs(P.y - gridPoint.y);\n    float tX = cos(iTime) - 5.f * cos(iTime) * pow(distX, cos(iTime) * 2.5) + 15.0 * pow(distX, 4.f) - 10.0 * pow(distX, 3.f);\n    float tY = 1.0 - 5.0 * pow(distY, 5.f) + 15.0 * pow(distY, 4.f) - 10.0 * pow(distY, 3.f);\n    // Get the random vector for the grid point\n    vec2 gradient = 2.f * random(gridPoint) - vec2(1.f);\n    // Get the vector from the grid point to P\n    vec2 diff = P - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * tX * tY;\n}\n\n\nfloat perlinNoise(vec2 uv) {\n        float surfletSum = 0.f;\n        // Iterate over the four integer corners surrounding uv\n        for(int dx = 0; dx <= 1; ++dx) {\n                for(int dy = 0; dy <= 1; ++dy) {\n                        surfletSum += surflet(uv, floor(uv) + vec2(dx, dy));\n                }\n        }\n        return surfletSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 baseCol = vec3(0.0);\n    vec3 finalCol = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i+=1.0) {\n        //uv = fract(uv * 1.5) - 0.5;\n        float x = perlinNoise(uv * 2.4);\n        vec3 col = palette(length(uv0) + iTime * 0.3 + i * 0.4);\n        baseCol = col;\n        float fCol = f(col);\n        \n        // Time varying pixel color\n        baseCol += col * x;\n        finalCol += col * fCol * x;\n    }\n\n    // Output to screen\n    fragColor = pow(vec4(f(finalCol)), vec4(1.0, 2.0, 3.0, 4.0)) * pow(vec4(f(baseCol)) * 2.5, vec4(3.0, 2.0, 1.0, 0.0));\n}","name":"Image","description":"","type":"image"}]}