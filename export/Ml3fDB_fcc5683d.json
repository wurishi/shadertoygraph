{"ver":"0.1","info":{"id":"Ml3fDB","date":"1544302191","viewed":213,"name":"Quaternion RGB vector rotation","username":"cardinalsine","description":"A demo using quaternion math to rotate a 3D (r, g, b) vector through color space. Also featured: the logistic map, and a version interpolated by a raised inverted cosine.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["math","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_t iTime\n#define u_res iResolution\n#define u_mouse iMouse\n#define PI 3.1415926\n\nvec4 qNorm(vec4 q) {\n    float magnitude = sqrt(q.x*q.x+q.y*q.y+q.z*q.z+q.w*q.w);\n    return q/magnitude;\n}\n\nvec4 qMatToVec(mat4 q) {\n    //return transpose(q)[1];\n    return vec4(q[0][0],q[0][1],q[0][2],q[0][3]);\n}\n\nmat4 qNorm(mat4 q) {\n    return q/length(qMatToVec(q));\n}\n\nmat4 qVecToMat(vec4 q) {\n    return mat4( q.x, q.y, q.z, q.w,\n                -q.y, q.x,-q.w, q.z,\n                -q.z, q.w, q.x,-q.y,\n                -q.w,-q.z, q.y, q.x);\n}\n\nmat4 qRotate(mat4 q, float theta) {\n    float r = cos(theta/2.);\n    vec3 v = vec3(sin(theta/2.));\n    mat4 a = qVecToMat(vec4(r,v));\n    return q*a;\n}\n\nmat4 qConj(mat4 q) {\n    return transpose(q);    \n}\n\nvec3 qRotate3D(vec3 v, vec3 axis, float theta) {\n    mat4 p = qVecToMat(vec4(0.,v));\n    mat4 q = qRotate(qVecToMat(qNorm(vec4(1.,axis))),theta);\n    mat4 q_ = transpose(q);\n    mat4 p_ = q*p*q_;\n    \n    return qMatToVec(p_).yzw;\n}\n\nfloat logisticMap(float n, float x0, float r){\n\tx0 = clamp(x0, 0., 1.);\n    r = clamp(r,0.,4.);\n    \n    float x = x0;\n    for(float i = 0.; i < n; i++) {\n        x *= r*(1.-x);\n    }\n    return x;\n}\n\nfloat cosInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*0.5*(1.-cos(PI*fract(x)));\n}\n\nfloat logisticMapInterp(float n, float x0, float r) {\n    return cosInterp(n, logisticMap(n,x0,r), logisticMap(n+1.,x0,r));\n}\n\nfloat cosNorm(float x) {\n    // cos(x) normalized to be between 0 and 1\n    return 0.5*(1.+cos(x));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = abs(-1.+2.*fragCoord/iResolution.xy);\n    vec2 mpos = iMouse.xy/iResolution.xy;\n    \n    vec3 a = 0.5+vec3(0.25,-0.125,0.125);\n    vec3 b = 0.5+vec3(0.);\n    \n    vec3 a_ = normalize(a)/sqrt(3.);\n    vec3 b_ = normalize(b)/sqrt(3.);\n    \n    float n = -1.;\n    float m = 4.0;\n    \n    float w_r = exp2(-4.)*PI;\n    \n    float r1 = 2.+2.*cosNorm(w_r*u_t);\n    float r2 = 2.+2.*cosNorm(w_r*u_t+PI/2.);\n\n\tfloat lMap_xy = (2.*(logisticMap(m*uv.x, uv.y, r1)))/2.;\n    float lMap_yx = floor(2.*(logisticMapInterp(m*uv.y, uv.x, r2)))/2.;\n    float lMap_intersect = lMap_xy*lMap_yx;\n    \n    float steps_x = 0.5*(1.+1.*floor((uv.x)*m)/(m));\n    float colGrad_y = (0.9+0.1*uv.y);\n    float colGrad_x = 1.;\n\n    float colorOffset = 0.5*steps_x*(lMap_xy*colGrad_y+lMap_yx*colGrad_x);\n    float theta = 2.*PI*(0.125*uv.y+0.75*lMap_intersect+0.*colorOffset);\n\n    // invert colors when the pattern repeats\n    float s = mod(floor(w_r/PI*u_t+0.5), 2.);\n    \n    vec3 col = qRotate3D(a_, b_, theta);\n    col = mix(col, 1.-col, s);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}