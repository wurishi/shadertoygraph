{"ver":"0.1","info":{"id":"4sdyDl","date":"1520606667","viewed":279,"name":"Smooth 4-point Quad","username":"kim_schmider","description":"Draw a 4-point quad based on 4 points including rotation & translation tranformations","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["smoothstep","quad","shape","transformations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2[4] translate(vec2[4] quad, vec2 pos)\n{\n    for (int i = 0; i < 4; ++i)\n        quad[i] += pos;\n    return quad;\n}\n\nvec2[4] rotate(vec2[4] quad, float ang)\n{\n    mat2 rotMat = mat2(\n    \tcos(ang), -sin(ang),\n        sin(ang),  cos(ang)\n    );\n    \n    for (int i = 0; i < 4; ++i)\n        quad[i] *= rotMat;\n    return quad;\n}\n\nvec2 normalizedNormal(vec2 vec)\n{\n\treturn normalize(vec).yx * vec2(1, -1);\n}\n\n// Heavy modification of https://git.io/vAp66\nfloat draw(vec2 st, vec2[4] p, float smoothness){\n  \tvec3[4] e;\n   \tfloat[4] v;\n\n\tfor (int i = 0; i < 4; ++i)\n\t\te[i].xy = normalizedNormal(p[i < 3 ? i + 1 : 0] - p[i]);\n   \n\tfor (int i = 0; i < 4; ++i)\n\t\te[i].z = dot(e[i].xy, p[i]) - smoothness;\n  \n  \tfor (int i = 0; i < 4; ++i)\n        v[i] = max(0., dot(e[i].xy, st) - e[i].z);\n\n  return smoothstep(smoothness * 2., 1e-7, length(vec4(v[0], v[1], v[2], v[3])));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Center = [0, 0]\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2[4] quad = vec2[4](\n    \tvec2( .5,  .3),\n        vec2( .0,  .2),\n        vec2(-.1, -.2),\n        vec2( .3, -.3)\n    );\n    \n    quad = rotate(quad, 3.14);\n    quad = translate(quad, vec2(.3, .2));\n\n    vec3 col = vec3(draw(uv, quad, .005));\n    \n    // Add some color\n    col *= .5 + .5 * sin(iDate.w + uv.xyx + vec3(0, 2, 4));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}