{"ver":"0.1","info":{"id":"cljSWy","date":"1676531101","viewed":83,"name":"Tower in Mountain","username":"bryan05","description":"tower, mountain","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["towerandmountain"],"hasliked":0,"parentid":"ctBSR3","parentname":" Pavilion painting"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 sunLig = normalize(vec3(0.1,0.4,0.7));\n\n\n\nvec2 TowerBodySDF(vec3 p)\n{\n    vec2 res ;\n    res.x = 99999.;\n    vec3 q;\n    \n    p *= 0.6;\n    p.y*= 1.2;\n\n\n\n\np.y-=5.;\n\n    {  \n        //floor    \n        q = p;\n\n        \n        \n        q.y = p.z;\n        q.z = p.y;\n        q.z +=15.;\n        vec2 rFloor;\n        rFloor.x = sdHexPrism(q, vec2(6., 0.6));\n        rFloor.y = 4.3;\n        res = combine(res, rFloor);\n    \n        //columns\n        q = p;\n        float angle = PI2/6.0;\n        float tan = atan(p.z, p.x);\n        float sector =  round( tan/ angle) ; \n        {\n            float an = sector * angle;\n            q.xz = mat2(cos(an), -sin(an), sin(an),cos(an)) * q.xz;\n\n        }\n\n        q.x -= 5.;  \n        q.y += 11.;\n\n\n  \n        vec2 rColumns;\n        rColumns.x = sdCylinder( q, vec3(0., -4., 0.), vec3(0., 4., 0.), 0.5);\n        rColumns.y = 4.2;\n\n        res = combine(res, rColumns);\n\n        float an = PI2/12.;\n        q.xz = mat2(cos(an), -sin(an), sin(an),cos(an)) * p.xz;   \n\n        q.y = 11. +p.y;\n\n        angle = PI2/6.0;\n        tan = atan(q.z, q.x);\n        sector =  round( tan/ angle) ; \n        {\n            float an = sector * angle ;\n            q.xz = mat2(cos(an), -sin(an), sin(an),cos(an)) * q.xz;\n\n        }\n\n\n\n        q.x -=4.;\n        \n        vec2 rBox;\n        rBox.x = sdBox( q, vec3 (0.5, 4. ,2.5));\n        rBox.y = 4.1;\n\n        res = combine(res, rBox);\n        p.y -= 8.;\n        p.xz *= 1.2;\n    }\n    return res;\n}\n\n\nvec2 towerTop(vec3 p)\n{\n    vec2 res ;\nres.x = 1000.;\n\n\np.y-=67.;\np*= 0.8;\n    //ceiling\n    vec3 q = p;\n\n    q.y = p.z;\n    q.z = p.y;\n\n    float r = max(-q.z, 0.);\n    r = 0.15* pow(r, 2.);\n\n    vec2 rCeiling; \n    rCeiling.x = sdHexPrism( q,vec2( r, 7. ) );\n    rCeiling.x *= 0.4;\n    rCeiling.y = 4.3;\n    \n    //sphere\n    q = p;\n    q.y +=0.6;\n    vec2 rSphere;\n    rSphere.x = length(q) -0.5;\n    rSphere.y = 4.3;    \n    res =  combine(rCeiling, rSphere);\n    \n    return res;\n}\n\nvec2 TowerSDF(vec3 p) {    \np *= 5.5;\n    vec2 res ;\nres.x = 1000.;\n\n\n    p.y-=48.;\np.x -= 20.;\n    vec2 rTop = towerTop(p);\n\n\n    float sec = p.y/12.;\n\n    if(sec >= -2. && sec <=5.)\n    {\n        p.y = mod(p.y,12.);\n        p.y -= 14.;\n        p.xz *=  (1. + sec/10.);\n    }\n    vec2 rBody= TowerBodySDF( p);\n\n     res = combine(rTop, rBody);\n    res.x *= 0.3;\n    return res;\n}\n\n\n\n\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.3,0.3)*0.3 - 0.3 * rd.y;\n\n    rd.y+= 0.025;\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0. )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, 0.00003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.2,0.2,0.2), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.25,0.25,0.25)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.35 + 0.65*dot(sunLig,-(rd)), 0.0, 1.0 ), 21.0 );\n    col = mix( col, vec3(0.5,0.30,0.05)/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n   // return vec3(abs(sd));\n    return col * 5.;\n}\n\n\n\nvec2 terrainSDF(vec3 p, vec3 d)\n{\n    vec2 res;\n    vec3 origP = p;\n    float t = 0.0f;\n    res.x = 0.;\n    res.y = 0.;\n    for(float i=200.0;i<900.8; i += 0.2)\n    {\n        float s=.5;\n        \n        t = texture(iChannel2,.3+p.xz*s/3e3).x /s ;\n        s+=s;\n        t += texture(iChannel2,.3+p.xz*s/3e3).x /s ;\n        s+=s;        \n        t += texture(iChannel2,.3+p.xz*s/3e3).x /s ;\n        s+=s;    \n        \n     \n        if( t>p.y*.02+1.3)\n        {\n            res.x = t ;\n            res.y = length(p);\n            return res;\n        }\n\n        p = origP + d * i ;\n    }\n    \n\n    return res;\n}\n\nvec2 sceneSDF(vec3 p, vec3 direction) {    \n\n\n    vec2 res = TowerSDF(p);\n\n   res.x *= 0.5;\n    return res;\n}\n\n\nvec2 calculateDistance(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 res;\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(eye + depth * marchingDirection, marchingDirection);\n        res.y = dist.y;\n        if (dist.x < EPSILON) {\n            res.x = depth;\n\t\t\treturn res;\n        }\n        depth += dist.x;\n        if (depth >= end) {\n            res.x = end;\n            return res;\n        }\n    }\n    res.x = end;\n    return res;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\nmat3 buildViewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(120.0, 30.0 , 120.0);\n   // eye = vec3(30.0, 10.0 , 30.0);\n    mat3 viewToWorld = buildViewMatrix(eye, vec3(.0, 10.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n     vec2 distToScene = calculateDistance(eye, worldDir, MIN_DIST, MAX_DIST);\n     vec2   dist = terrainSDF(eye, worldDir);\n  \n    if ( dist.x == 0. ) \n    {\n      \n        fragColor =vec4( skyColor( eye, worldDir ), 1.0);\n\t\treturn;\n    }\n    \n    //fragColor = vec4(  1.0); return;\n    \n    //\n    \n    \n    vec3 p = eye + dist.x * worldDir;\n    \n     vec3 color;\n    \n    \n\n    if(dist.y < distToScene.x)\n    {\n       color =  vec3(0.8);\n       color *= 1.-dist.x/2.;\n    }\n    else\n    {\n         if (distToScene.y == 4.1)\n        {\n            color = vec3(214./255.,64./255.,64./255.) *0.3; \n\n        }\n        else if (distToScene.y == 4.2)\n        {\n            color = vec3(214./255.,64./255.,64./255.) *0.3; \n\n        }\n        else if (distToScene.y == 4.3)\n        {\n            color = vec3(100./255.,244./255.,244./255.) *0.15; \n\n        }\n    }\n    \n    vec3 fogcol = vec3(0.1,0.125,0.15);\n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,abs(worldDir)), 0.0, 1.0 ), 4.0 );\n\tfogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(worldDir.y))) ) ;\n\n    float fog = 1.0 - exp(-0.0013*dist.x);\n    color *= 1.0-0.5*fog;\n    color = mix( color, fogcol *4., fog );\n    \n    fragColor = vec4( color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//functions from iq\n\n#define PI2 6.283185\nconst int MAX_MARCHING_STEPS = 300;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 900.0;\nconst float EPSILON = 0.001;\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    else p.y = p.y + sin(p.x)* .3;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x ;\n    float d2 = abs(p.z)-h.y ;\n  //  d2 -= step(p.z, 0.) * sin(p.y) *0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 getColor(vec3 color)\n{\n    return vec3(color.x/255., color.y/255., color.z/255. );\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n/////////////// iq's distance funs\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nfloat noise( in vec3 x , in sampler2D iChannel1 )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x , in sampler2D iChannel1)\n{\n    vec2 p = vec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy;\n\tfloat rgA = textureLod( iChannel1, (uv+vec2(0,0))/256.0, 0. ).x;\n    float rgB = textureLod( iChannel1, (uv+vec2(1,0))/256.0, 0. ).x;\n    float rgC = textureLod( iChannel1, (uv+vec2(0,1))/256.0, 0. ).x;\n    float rgD = textureLod( iChannel1, (uv+vec2(1,1))/256.0, 0. ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat fbm4( in vec3 p , in sampler2D iChannel1)\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 , iChannel1);\n    n += 0.500*noise( p*2.0 , iChannel1);\n    n += 0.250*noise( p*4.0 , iChannel1);\n    n += 0.125*noise( p*8.0 , iChannel1);\n    return n;\n}\n\nfloat fbm4( in vec2 p , in sampler2D iChannel1)\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 , iChannel1);\n    n += 0.50000*noise( p*2.0 , iChannel1);\n    n += 0.25000*noise( p*4.0 , iChannel1);\n    n += 0.12500*noise( p*8.0 , iChannel1);\n    return n;\n}\n\nfloat fbm6( in vec3 p , in sampler2D iChannel1)\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 , iChannel1);\n    n += 0.50000*noise( p*2.0 , iChannel1);\n    n += 0.25000*noise( p*4.0 , iChannel1);\n    n += 0.12500*noise( p*8.0 , iChannel1);\n    n += 0.06250*noise( p*16.0 , iChannel1);\n    n += 0.03125*noise( p*32.0 , iChannel1);\n    return n;\n}\n\n\nfloat fbm6( in vec2 p , in sampler2D iChannel1 )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 , iChannel1);\n    n += 0.50000*noise( p*2.0 , iChannel1);\n    n += 0.25000*noise( p*4.0 , iChannel1);\n    n += 0.12500*noise( p*8.0 , iChannel1);\n    n += 0.06250*noise( p*16.0 , iChannel1);\n    n += 0.03125*noise( p*32.0 , iChannel1);\n    return n;\n}\n\nfloat fbm( in vec3 p , in sampler2D iChannel1)\n{\n    return fbm4(p, iChannel1);\n}\n\nvec2 combine(vec2 res1, vec2 res2)\n{\n    if( res1.x < res2.x ) return res1;\n    else return res2;\n\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\n\n\n\nvec4 textureGood( sampler2D sam, in vec2 uv )\n{\n    uv = uv*1024.0 - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, 0.0 );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n}\n\n\n","name":"Common","description":"","type":"common"}]}