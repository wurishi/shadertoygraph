{"ver":"0.1","info":{"id":"WsdyRl","date":"1601570953","viewed":383,"name":" Schädeldämmerung","username":"Yusef28","description":"English / DEUTSCH README in \"Common\" (Der Deutsche ist noch nicht fertig)\nProjekt ZeitDauer/ Lenge of project: 2 months\nStunden pro tag / hours per day: 2-8\nAnzahl Schädeln Erstellt / Number of skulls created: 20 - 30\nFPS mit/with MSI GL62: 12 ","likes":27,"published":3,"flags":96,"usePreview":0,"tags":["modeling","model","radialblur","schdel","skullskull","deutsch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4l23WV","filepath":"https://soundcloud.com/felipe-moreno-11/resident-evil-4-soundtrack","previewfilepath":"https://soundcloud.com/felipe-moreno-11/resident-evil-4-soundtrack","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\nREADME.md\n\n(ENGLISCH / DEUTSCH )\n\n\nENGLISH\n\nI suggest that you minimize all functions and then only\nexpand the \"knochen\" function and the \"map\" funtion and\nread those.\n\n\n*** Inspiration and Resources ***\n\nAnother learning Resource: Scratchpixel\nhttps://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry\nIf you don't have a computer science degree and / or aren't confident with basic\nlinear algebra and trigonometry I suggest you go through the geometrie section\nof this site.\n\nAlas, poor Yorick - from shau: https://www.shadertoy.com/view/3ddXR4\n[The teeth in my projekt is based on his but with simpler code \nthat I think I first discovered in an IQ project.]\n_______\n\nLost_Astronaught - from duvengar: https://www.shadertoy.com/view/Mlfyz4\n[This convinced me that it was possible to create detailed models \nwith only a few basic primitives ]\n________\n\nBlume[skull] - from tdhooper: https://www.shadertoy.com/view/WdScDG\n[This showed me how elegant a skull shader could look. and more of\nwhat makes a skull look like a skull, without too many details. \nI didn't use any ellipsoids so maybe that was part of why I wasn't \nable to achieve such elegance.]\n________\n\nRaymarched Reflections - von Shane: https://www.shadertoy.com/view/4dt3zn\n[The Shane reflection shader is one of the best starting points \nfor any 3d shader project imo. Other than the map function and \nthe knochen function, and a few tweaks, rest of the code is Shanes (or IQs). \nHis comments are still there. \nIf you took a month to understand and memorize his shader, you\nwould feel way more confident in create 3d shaders. (At least if\nyou are the type that needs to feel like they understand everything about \na project they are working on.)]\n_________\n\nIQ's Primitives:\nFrom Shadertoy: https://www.shadertoy.com/view/Xds3zN\nFrom his website: https://iquilezles.org/articles/distfunctions\nHis store: https://www.redbubble.com/people/inigoquilez/explore?page=1&sortOrder=recent\n_________\n\nEventually I want to have a redbubble store selling artwork like this\nas well. I've tried it before on redbubble but only with my pattern\nshaders and it didn't work out.\n_________\n\nPinterest: pinterest.de \nI have maybe 300 skull images saved in a private album. It helped me\na lot in figuring out what made a skull look like a skull. \n\n\n\n\n*** Projekt Walkthrough (only map and knochen) **** \n\n\n\n\n1. The \"knochen\"(bone) function:\n\n\"konchen\" is the \"power function\" of this program. Basically it\nreturns a rounded box but allows complete control through it's\nparameters for:\n\n- Rotate (th, phi, and ga): in x, y, and z\n- Gross Dimentionen (dim): in x, y and z\n- Position (xyz): x, y, and z\n- rounding (r)\n- mirror (speigel): amount the distance from the mirror-axis (the x axis for\na symmetrical skull and 50% fewer calculations.\n\nRoundedBox + smoothmin / smoothmax allows for very good\norganic models.\n\nMost of this skull model is built from roundedboxes.\n\n\n2. The map function:\n\nIn the early days of this projekt I was able to create a \n\"project skeleton\" pretty fast with 9 roundboxes (using the \n\"knochen\" funktion and copy and paste). This aloud me to easily \ntry things out. \n\nThe 9 main bones for the projekt skeleton are: \n\n1. A bone above the eye socket. (Aug\n2. A bone on the side of the eye socket.\n3. (A bone from the top-outer corner of the eye zu die top of the head.)\n4. A bone for the front of the cheek bones.\n5. A bone for the side of the cheekbones leading to the ear hole.\n6. A bone from the ear hole to the bottom jaw. \n7. A bone for the bottom jaw.\n8. A bone for the nose.\n9. A bone for the chin. (in some cases not needed)\n\nThese bones when oriented, give you a gut starting point \nfor the rest of the project.\nYou can see them in my map function.\n\n\n\n\n\n*** IMPORTANT DISCOVERIES ***\n\n\n\n\n\n1. The first important discovery during this project was\nthe gum ripple. It's a cyliner with something like:\nabs(cos(atan(sp.z,sp.y)*number-of-teetch))*0.003\nThis early discovery gave me a lot of motivation to continue.\n\n2. The Bone function and the 9 bones as a starting point.\n\n3. The rule of thirds: https://www.pinterest.ca/pin/862650503613525587/\nThe skull from the front and side should obey this rule.\nMy early attempts were really ugly and the reason was that I \ncompletely ignored this idea.\n\n\n4. Light: The Angle of light has a dramatic affect on the look\nof the skull.\n\n\nOther Discoveries:\nSuture lines, Teeth Specular Licht, A good shade of black, \n\n\nBrute Force: I stopped caring about how fast my code would run. \nWithout that I would never have been able to make this. \nThat's one of the many things Leetcode has taught me. Bruteforce \nis better than nothing. \n\n\n\n\n\n\n\nDEUTSCH:\n\nIch schlage vor, dass Sie alle Funktionen minimieren und sie nur die \n\"knochen\" funktion und die \"map\" zu lesen.\n\n\n\n\n*** Inspirationen und Resourcen ***\n\n\n\n\nAusbildung: Scratchpixel\nhttps://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry\nWenn sie habe kein Computer Wissenshaft Abschluss Ich schlage vor, \ndass Sie den Abschnitt Geemetrie von Scratchpixel.com studieren.\nLineare Algebra und Trigonometrie bilden die Grundlage für alles, \nwas ich hier getan habe. Kalkül ist auch wichtig, aber das ist für \neinen anderen Beitrag.\n_________\n\nAlas, poor Yorick - von shau: https://www.shadertoy.com/view/3ddXR4\n[Die Zähne in diesem Projekt basieren auf seinen.]\n_________\n\nLost_Astronaught - von duvengar: https://www.shadertoy.com/view/Mlfyz4\n[Diese hat mir uberzeugt das es moglisch war, ein sehr detailiert\nModell mit nur sehr sehr grundlisch Primitiven zu erstellen.]\n__________\n\nBlume[skull] - von tdhooper: https://www.shadertoy.com/view/WdScDG\n[Diese zeigt mir ein bischen uber was macht ein schadel seiht wie ein\nschadel. Es ist sehr elegant. Ich hab keine ellipsoiden benutzt.\nVielleicht war das einer der Gründe, warum ich dieses Maß an Eleganz \nnicht erreichen konnte. Ich weiß es nicht.]\n__________\n\nRaymarched Reflections - von Shane: https://www.shadertoy.com/view/4dt3zn\n__________\n\nDer Shane Relfection Shader ist eine die Best Ausgangspunkte\nfur jedes 3d projekte (Meine meinung nach). \nAbgesehen von der Kartenfunktion der Knochenfunktion und einigen \nÄnderungen ist dieser Code shanes. Seine Kommentare sind da.\nWenn Sie die Reflection Shader code verstehen UND auswendig kennen, \nwerden Sie beim Erstellen von 3D-Shadern viel sicherer sein.\n__________\n\nIQ's Primitiven:\nAuf Shadertoy: https://www.shadertoy.com/view/Xds3zN\nVon seiner webseit: https://iquilezles.org/articles/distfunctions\nSein Laden: https://www.redbubble.com/people/inigoquilez/explore?page=1&sortOrder=recent\n__________\n\nSchließlich möchte ich auch ein Geschäft haben, in dem meine \nShader-Kunstwerke verkauft werden. Ich habe es mit Redbubble versucht, \naber nur mit Mustern und es hat nicht geklappt.\n__________\n\nPinterest: pinterest.de \nIch hab vielleich 300 Schadel bilden in ein privat Album\ngespeichert. Pinterst ist eine meien wichtigste Resourcen fur\nshader inspiration.\n\n\n\n\n*** Projekt Anleitung ***\n\n\n\n\n\n1. die knochen funktion:\n\n\"knochen\" ist die \"Machtfunktion\" von diese program. Grundlisch es\ngibt ein roundedbox zuruck aber es erlaubt komplett kontroll durch die \nparametern fur:\n\n- Drehen (th, phi,und ga): in x,y,und z\n- Gross Dimentionen (dim): in x,y und z\n- Position (xyz): x,y,und z\n- Menge die Runden (r)\n- spiegeln (speigel): menge die entfernung von die spiegeln-axis (die x axis fur \nein symmetrish schadel und 50% weniger berechnungen.\n\nVon diese parametern es ist moglish viele roundedbox in die map \nfunktion zu erstellen (kopie und paste) and leich mit sie spielen.\n\nRoundedBox + smoothmin / smoothmax erlaut fur ein sehr \norganisch Modelle.\n\nMeistens von diese Schadel Model ist von roundedbox aufgebaut.\n\n2. map funktion:\n\nIn die fruhen Tagen diese experiment ich war in der lag ein \n\"skelett\" schnell mit roundedbox(\"knochen\") zu entwickeln durch \ndie drehen/skalieren/runden und position.\n\nSie brauch nur 9 haupt teilen, wann sie ein Schadel beobachten:\n\n\n1.Ein Knochen über der Augenhöhle.\n2.Ein Knochen an der Seite der Augenhöhle.\n3.(Ein Knochen aus dem oberen äußeren Augenwinkel zu der Oberseite des Kopfes.)\n4.Ein Knochen für die Vorderseite der Wangenknochen.\n5.Ein Knochen für die Seite der Wangenknochen, die zum Ohrloch führt.\n6.Ein Knochen vom Ohrloch bis zum Unterkiefer.\n7.Ein Knochen für den Unterkiefer.\n8.Ein Knochen für die Nase.\n9.Ein Knochen für das Kinn. (in einigen Fällen nicht erforderlich)\n\nDiese knochen wann recht orientiert gibt sie ein gut Startpunkt.\n\nSie konnen diese in meine map funktion sehen. \n\n\n\n***** WICHIG ENTDECKUNGEN *****\n\n1. Die erste wichtig Entdeckung wahren dieses Projekt war\ndie Zahnfleich welligkeit. Das war nur ein sdCappedCylinder \nmit abs(cos(atan(sp.z,sp.y)*zahnAnzahl))*0.003 oder so.\nIch hat diese sehr Fruh entdeckt und es hat mir sehr viel\nmotiviert weiterzumachen.\n\n2. Die Knochen funktion und die 9 knochen als ein Startpunkt.\n\n3. die 3-3-3 Proportion Regeln: \nhttps://www.pinterest.ca/pin/862650503613525587/\nDie shadel von voderseit und Seit sollte die 3-3-3 Regel folgen.\nMeine erste Schadeln war sehr hasslich und diese war die haupt \nGrunde.\n\n4.Licht: die licht winkle hat ein Dramatisch auswirkung von die\naussehen die schadel!\n\nAndere Entdeckungen:\nSuture lines, Zahn Specular Licht, Schwarze, \n\nRohe-stark(Brute Force):Ich hörte auf, mich darum zu kümmern, \nwie langsam mein Code laufen würde. Ohne das hätte ich das \nnie geschafft. Das ist eines der vielen Dinge, die Leetcode\nmir beigebracht hat. RoheStark ist besser als nichts.\n\n*/\n\n//Radial Blur Based on shaders by Shane and Passion\n//Shane's https://www.shadertoy.com/view/XsKGRW\n//Passion's https://www.shadertoy.com/view/MdG3RD\n\n//Also\n//Radial Blur - IQ https://www.shadertoy.com/view/4sfGRn\n//Rays of Blinding Light - mu6k https://www.shadertoy.com/view/lsf3Dn\n\n//and an nvidia gpu gems 3 tutorial\n//    http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\n\n\nconst float SAMPLES = 95.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float sample1 = pow(audio_ampl(iChannel1, 0.01), 10.);\n    float weight = 0.012;//sample1/40.;// 0.012 + //+sin(iTime)*0.01; //weighting factor to get a weighted of each sample\n    //orback to 0.08\n    \t\t\t\t\t\n    float decay = 0.95; //used to decrease the weighting fact so each step adds less to the sum,\n    \t\t\t\t\t//to model scattering and absortion\n    \n    float density = 0.95;//0.3 //used to scale the step size of the samples and step size(or totaal distance)\n    \t\t\t\t\t//determines how far in each ray direction calulations and bluring is done for\n    \t\t\t\t\t//higher density means longer streaks of light and also more blur\n    float exposure = 4.1;  //or back to 1.1\n    /*from nvidia: exposure controls the overall intensity of the \n    post-process, weight controls the intensity of each sample, \n        and decayi (for the range [0, 1]) dissipates each sample's \n        contribution as the ray progresses away from the light source. \n        This exponential decay factor practically allows each light shaft \n        to fall off smoothly away from the light source.*/\n    \n    \t\t\t\t\t\t \n    //uv here will be used as a direction vector. So each coordinate will have it's cooresponding\n    //vector. eg. coor 0.5, 0.5, is a vector, 0.5, 0.5\n    //This vector is used as a ray and the algorithm will step through the ray in this \n    //direction, from 0.,0., to the end of the ray at the current coordinate.\n    \n    \n\t\n    \n    //we subtract 0.5 to shift it to -0.5 to +0.5 so 0.0, 0.0 is center of screen\n    //so the blur goes out in all directions\n    vec2 tuv = uv-0.5; //also we use a new vec2 because we still need uv for sampling and \"jitter\"\n    \n    vec2 duv = tuv/SAMPLES*density;\n    \n    vec4 initColor = texture(iChannel0, uv.xy)*0.25;//portion of total color to start with.\n    //color in this case comes from channel0 which is a buffer that returns the scene color\n    \n    //jitter is a way of reducing banding which is a type of artifact... which we don't want\n    //shane's version uses time to change the jitter which seems like a good idea but I'm\n    //going for simple right now so I'm going with Passions which is just muliplying duv and random\n    \n    //this is added as an offset to uv.  uv which will be used to sample each texture in the alg loop.\n    //so we add a random percentage of duv to uv.\n    //random is key because the issue is banding is you get these weird lines or waves\n    //so to smooth them out you can offset each point by a random amount.\n    uv+=duv*fract(sin(dot(uv, vec2(12.9898, 78.233)))*43758.5453);\n    \n    for(float i=0.;i<SAMPLES;i++)\n    {\n        \n     \n        //for each step move along the ray towards the center(uv - stepsize for all steps\n        //where step is fraction of uv, will result in 0, 0 the middle\n        uv-=duv;\n        \n        //add weighted percentage of scene color\n        \n    \n    \n        \n        initColor+=texture(iChannel0, uv)*weight;\n        \n        weight*=decay;//decay the weight.\n    }\n\tinitColor*=exposure;\n  \tinitColor*= (1. - dot(tuv, tuv)*.975);\n\tfragColor = vec4(vec3(initColor),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FAR 5.\n#define Mausaktivieren 0.\n\n\n\n\n//Sie konnen alle funktionen minimieren und erweitern nur map / doColor \n//You can minimize all these funktions and then only expand map / doColor\n\n\n\n\n\nfloat noise( in vec3 x ){\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    \n}\nfloat map(vec3 p, float lr, float ou){\n    //p*=2.;p.xy = mod(p.xy, 2.5)-1.25;\n    \n    /* Maus Kontroll, nicht verwendet / Mous control, unused\n    vec3 reinP = p;\n    float PosX, PosY;\n    PosX = 1.0 - iMouse.x/iResolution.x*4. + 0.5;\n    PosY = 1.0 - iMouse.y/iResolution.y*4. + 0.5;\n    \n    float cs = cos(PosX*Mausaktivieren), si = sin(PosX*Mausaktivieren);\n    //p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(PosY*Mausaktivieren-0.1), si = sin(PosY*Mausaktivieren-0.1);\n    //p.yz = mat2(cs, si, -si, cs)*p.yz;\n    */\n\t\n    float cs, si;\n    \n    //ANIMATION\n    //float lr = (noise(vec3(iTime/3.))-0.5)*1.5;\n    cs = cos(lr), si = sin(lr);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    \n    //float ou = (noise(vec3(iTime/3.+9.))-0.5)*.5;\n    cs = cos(ou), si = sin(ou);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    \n    \n    //POSITION\n\tp*=0.5; //Ich muss diese ganze model skalieren oder es gibt artifakte\n    p.x*=0.95;\n    //Deshalt die camera(in mainImage) ist weiter weg von die objekt\n    //I had to skale the whole model up or else there are artifacts\n    //therefore the camera(in mainImage) is further away from the objekt\n    p.y-=0.2;\n    \n    \n    \n    /* fbm nicth verwendet / fmb unused\n    float f = 0.;\n    float f2 = 0.;\n    float f3 = 0.;\n    float f4 = 0.;\n    vec3 q = p*16.;\n            f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;f2 = f;\n            f += 0.1250*noise( q ); q = m*q*2.03;f3 = f;\n            f += 0.0625*noise( q ); q = m*q*2.01;f4 = f;\n\t*/\n    \n    vec3 sp = p - vec3(0., 0., 0.03);\n    float k = length(sp*vec3(1.-sin(sp.z*6.-0.4)*0.05, \n                             0.95+sin(sp.z*6.+1.6)*0.05, \n                             0.87)) - 0.5;\n    float alle = k;\n    \n    //Kugel untenschnitt / Sphere under cut\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    ///return alle;\n    \n    //Kugel Seiteschnitt (abgeschrieben) / Sphere sidecut depretiated\n    sp = p  - vec3(0., -0.05, -0.28);\n    sp.x = abs(sp.x) - 0.65;\n    //length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.87))\n    k = length(sp) - 0.3;\n    //k = length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.6)) - 0.3;\n    //alle = smax(alle, -k, 0.09);\n\n    //Kugel Seite schnitt / Sphere side cut\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.18 ), \n                vec3(0.005, \n                     0.17 + sin(sp.z*4.+2.4)*0.1, \n                     0.2+ sin(sp.y*4.+2.)*0.18), \n                -0.2, -0.4, 0.1, 0.42+ sin(sp.z*4.+2.4)*0.05, 0.03);\n    alle = smax(alle, -k, 0.09);\n    \n    //return alle;\n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.03*1. - 0.04*1. , \n                        -0.45 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., -0., 0.14, 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //return alle;\n\n    \n    //oberest knochen / uppermost bone\n    sp = p;\n    k = knochen(p, vec3(0., 0.055 , -0.37 ), vec3(0.005, 0.005, 0.12), \n                -1., -0.25, 0., 0.28, 0.02);\n    alle = smin(alle, k, 0.06);\n    \n    //Knochen von der Seite der Augenlöcher\n    // Bone for the side of the eyeholes\n    sp = p;\n    k = knochen(p, vec3(0., -0.14 , -0.46+ cos(sp.y*8.+1.5)*0.07), \n                vec3(0.01, 0.08, 0.02), \n                0.0, 0.0, 0.35, 0.26+ cos(sp.y*12.+1.2)*0.06, 0.015);\n    alle = smin(alle, k, 0.06);\n    \n    float th = -.25-step(p.y,-0.07)*0.4;\n    //Sutur Linie (fast unsichtbar)\n    //Suture lines (almost invisible)\n    /*\n    sp = p;\n    \n    cs = cos(th), si = sin(th);\n    sp.yz = mat2(cs, si, -si, cs)*sp.yz;\n    alle += 0.007 - smoothstep(0., 0.015, \n                           abs(sp.z+0.35\n                               //basketball \n                               //+sin(atan(sp.y, sp.x)*4.)))*0.002;\n                               //tenis\n                               //+sin(atan(sp.y, sp.x)*2.)*.2)*2.)*0.002;\n                               +sin(atan(sp.y, sp.x)*12. + 9.)*.005\n                               +sin(atan(sp.y, sp.x)*54. + 2.)*.008\n                               +sin(atan(sp.y, sp.x)*33. + 3.)*.005\n                              )*2.)*0.004;\n    sp = p;\n    th = 1.5;\n    cs = cos(th), si = sin(th);\n    sp.y-=0.2 +sin(p.z*9.+3.)*0.14;\n    sp.yz = mat2(cs, si, -si, cs)*sp.yz;\n    \n    alle += 0.007 - smoothstep(0., 0.015, \n                           abs(sp.z+0.35\n                               //basketball \n                               //+sin(atan(sp.y, sp.x)*4.)))*0.002;\n                               //tenis\n                               //+sin(atan(sp.y, sp.x)*2.)*.2)*2.)*0.002;\n                               +sin(atan(sp.y, sp.x)*12. + 9.)*.005\n                               +sin(atan(sp.y, sp.x)*54. + 2.)*.008\n                               +sin(atan(sp.y, sp.x)*33. + 3.)*.005\n                              )*2.)*0.004;\n    */\n    \n    //VoderSeite der wangen Knochen / Front of the cheekbones\n    sp = p;\n    k = knochen(p, vec3(0., -0.28, -0.42+cos(abs(sp.x)*8.+2.)*0.02), \n                vec3(0.13, 0.055+sin(abs(sp.x)*8.+2.)*0.02, 0.05), \n                -0.5, 0.2, -0.1, 0.12, 0.05);\n    alle = smin(alle, k, 0.09);\n    \n    //wangenknochen vor schneiden  //ohne diese es it nicht ein schadel\n    sp = p;\n    k = knochen(p, vec3(0.,-0.315,-0.54), \n                vec3(0.12, 0.005, 0.001), \n                0., 0., -0., 0.16, 0.02);\n    alle = smax(alle, -k, 0.02);\n    \n    //schonheit mitte\n    sp = p - vec3(0., -0.32, -0.525);\n    sp.x = abs(sp.x) - 0.16;\n    k = length(sp.xy) - 0.001;\n    alle = smax(alle, -k, 0.03);\n    \n    \n    //return alle;\n    \n    //wangen knochen seit sollte dasselb (gesamt)breit haben wie die augen seit!\n    //Seite die wangen Knochen / Side of the Cheekbones\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.28), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.27 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.02);\n    \n\n    \n\n    //sollte siemlich schaf sein\n    //Augenhöhlen / Eye sockets\n    sp = p;\n    sp.x = abs(sp.x) - 0.172;\n    k = length(sp - vec3(0., -0.14, -0.48)) - 0.084;\n    alle = smax(alle, -k, 0.075);\n    \n    //Nase / Nose\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //Nasenschnitt / Nose cut\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.028 - sin(iTime*4.+sp.y*20.+sp.z*20.)*0.002);\n    alle = smax(alle, -k, 0.04);\n    \n    //Nase Linie / Nose Line\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005 - sin(iTime*4.)*0.003);\n    alle = smin(alle, k, 0.03);\n    \n    //Anzahl von Zahne/ Number of teeth\n    float zahnNum = 12.;\n    \n    //Drehung für den oberen Zylinder / rotation for the upper cylinder\n    th = 0.15;\n    sp = p;\n    cs = cos(th), si = sin(th);\n    \n    sp = sp - vec3(0., -0.43, -0.4);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    //oberen Zylinder / upper cylinder\n    k = sdCappedCylinder(sp, 0.205 //nicht so breit\n                         + cos(sp.y*12. -3.)*0.025\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.005\n                         , 0.043 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02\n                        - cos(sp.z*6.-1.75)*0.05\n                        );\n    alle = smin(alle, k, 0.07); //weniger smooth weil die echte schadel\n    \n    //Oberen Zahne / Upper teeth\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*6.6, 24, 1.); //nicht so breit\n    float zahn = k;\n    \n    \n    \n\n    \n    /* augen?\n    \n    sp = p - vec3(0., -0.13, -0.4);\n    sp.x = abs(sp.x) - 0.17;\n    k = length(sp) - 0.11;\n    float augen = k;//min(alle, k);\n    */\n    \n    \n    \n    /*************  UNTER SEITE DIE KOPF *******************/\n    /************KEIFERKEIFERKEIFERKIEFER *******************/\n    /*************  UNTER SEITE DIE KOPF *******************/\n    /************KEIFERKEIFERKEIFERKIEFER *******************/\n    \n    \n    //drehen / rotation\n    float kf = (sin(iTime*7.))*.05*step(0.,smin(sin(iTime/4.), 0.5,0.2)-0.5);\n    cs = cos(kf), si = sin(kf);\n    \n    //p -= vec3(0., -0.1, -0.1);\n    p.xz = mat2(cs, si, -si, cs)*(p.xz);\n    \n    \n    float keiferHohe = 0.01;\n    //Knochen vom Wangenknochen bis zum kiefer / \n    //Bone from cheekbones to jaw\n    sp = p;\n    k = knochen(p, vec3(0., -0.51+keiferHohe, -0.25 - cos(abs(sp.y)*12. + 3.)*0.04), \n                vec3(0.005-cos(sp.z*12.+4.5)*0.004 - cos(sp.y*6.+1.2)*0.017, \n                     0.125, \n                     0.1), \n                0.2+(-sp.y-0.5)*0.2, -0.35, -0.25, \n                0.29 , 0.01); //kiefer ein bisschen mehr eng war hilfreich\n    float keifer = k;\n    \n    \n    \n    \n    //Kiefer / Jaw\n    sp = p;\n    k = knochen(p, vec3(0., -0.67+keiferHohe, -0.35), vec3(0.005, 0.02, 0.16), \n                -0.3, -0.5, 0., 0.18+cos(sp.z*8.+3.14)*0.02, 0.045);\n    keifer = smin(keifer, k, 0.04);\n    \n    //Schnitt von WangeKnochen-Kiefer Knochen / Cut from cheekbone-jaw bone\n    sp = p;\n    k = knochen(p, vec3(0., -0.58+keiferHohe, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.15, 0.055), \n                0.2+(-sp.y-0.5)*0.2, -0.45, -0.3, 0.34, 0.01);\n    keifer = smax(keifer, -k, 0.04);\n    \n    //Loche fur WangenKnochen-Kiefer Knochen / Hole for Cheekbone-jaw bone\n    sp = p;\n    sp.x = abs(sp.x) - 0.31;\n    k = length(sp - vec3(0., -0.38+keiferHohe, -0.23)) - 0.06;\n    keifer = smax(keifer, -k, 0.04);\n    \n    //kinn / Chin\n    sp = p;\n    k = knochen(p, vec3(0., -0.73+keiferHohe, -0.45-cos(sp.x*8.)*0.1), vec3(0.09, 0.02, 0.015), \n                0., 0., 0., 0., 0.03);\n    keifer = smin(keifer, k, 0.09);\n    \n\n    \n    //Zyl Unten / Bottom Cylinder\n    sp = p - vec3(0., -0.65+keiferHohe, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.01\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.05 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    keifer = smin(keifer, k, 0.06);\n\n    \n    //unten zahn / Bottom teeth\n    sp = p - vec3(0.0, -0.58+keiferHohe, -0.39);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*6.6, 24, -1.);//nicht so breit\n    zahn = min(zahn, k);\n    \n    objID = vec4(zahn-0.05, alle, keifer, 0.);\n    alle = smin(zahn,alle, 0.09);\n    alle = smin(alle, keifer, 0.09);\n    //alle = min(alle,augen);\n    \n    \n    //Zyl Schnitt / cyl cut\n    sp = p - vec3(0., -0.58, -0.15);\n    k = sdCappedCylinder(sp, 0.17, 0.24);\n    alle = smax(alle, -k, 0.06);\n    \n    \n   \t//schonheit Loche unten / Beuty holes bottom\n    sp = p - vec3(0., -0.72, -0.565);\n    sp.x = abs(sp.x) - 0.07;\n    k = length(sp.xy ) - 0.005;\n    alle = smax(alle, -k, 0.02);\n    \n    return alle +0.002;// + f3*0.009;\n}\nfloat trace(vec3 ro, vec3 rd, float lr, float ou){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t, lr, ou);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001*(1. + t*.25) || t>FAR) break;        \n        \n        t += d*.95;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\nfloat softShadow(vec3 ro, vec3 lp, float k, float lr, float ou){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 14; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist, lr, ou);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\nvec3 getNormal(in vec3 p, float lr, float ou) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy, lr, ou) - map(p - e.xyy, lr, ou), map(p + e.yxy, lr, ou) - map(p - e.yxy, lr, ou),\tmap(p + e.yyx, lr, ou) - map(p - e.yyx, lr, ou)));\n}\nvec3 getObjectColor(vec3 p){\n    float PosX, PosY;\n    PosX = 1.0 - iMouse.x/iResolution.x*4. + 0.5;//0.2*2.*(rechts - links);\n    PosY = 1.0 - iMouse.y/iResolution.y*4. + 0.5;\n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n\tp*=0.6;\n    p.y-=0.2;\n    \n    // \"floor(p)\" is analogous to a unique ID - based on position.\n    vec3 ip = floor(p);\n    \n    // Unique random cell number.\n    float rnd = fract(sin(dot(ip, vec3(27.17, 112.61, 57.53)))*43758.5453);\n    \n    vec3 knochenFarber = vec3(237./255., 218./255., 201./255.)*1.5;\n    vec3 schwarze = vec3(0.);\n    vec3 rot = vec3(0.4, 0., 0.);\n    // Color up the objects in a cubic checkered arrangement using a subtle version\n    // of IQ's palette formula.\n    float stripe = smoothstep(0.9-0.004,0.9+0.004,fract(p.x+0.1));\n    stripe -= smoothstep(0.98-0.004,0.98+0.004,fract(p.x+0.1));\n    vec3 col =  vec3(1.4, 0., 0.);//vec3(.9, .45, 1.5);\n    \n    col = vec3(2.);\n    col = vec3(237./255., 218./255., 201./255.)*1.5;\n    //col = vec3(0.03);///schwarz\n    // Reverse the RGB channels on some of the objects, for a bit of variance.\n    //if(fract(rnd*1183.5437 + .42)>.65) col = col.zyx;\n    vec3 gold = vec3(205./255.,120./255.,15./255.)*1.5;\n    vec3 silber = vec3(0.2,0.3, 0.4);\n    //zahn\n    //if(stripe > 0.){col = vec3(1.0-stripe*0.7)*1.5;}\n    //keifer\n    if(svObjID == 0.){col = vec3(2.);}//vec3(237./255., 218./255., 201./255.)*1.5;}\n    return col;\n    \n}\nfloat phongSpecular(in vec3 l, in vec3 normal, in vec3 v, float ap, float f0){\n    // Phong specular BRDF\n    // Formulae from \n    // https://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\n    \n    vec3 h = normalize(l+v); // Half-vector\n    float dp = (ap+2.)/(2.*3.1416)*pow(dot(normal, h), ap); // microfacet distribution function\n    float gct = 1./dot(l,h); // Approximate Cook-Torrance geometry function\n\t// Schlick approximation of Fresnel reflectance\n    float fresnel = f0 + (1.-f0)*pow(1.-dot(l,h),5.);\n    \n    return dp*gct*fresnel;\n}\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t, float lr, float ou){\n    \n\n    \n    \n    //speicher die ursprunglich oberflasche normal fur zhane\n    //save the originl surface normal for teeth\n    vec3 asn = sn;\n    float cs, si;\n    \n    //beweg die oberflache koordinaten hier auch, anderefalls die texture wirde \n    //nicht mit die objekt beweg.\n    //move the surface coordinate hier too or else the texture wont\n    //move with the objekt\n    //float lr = (noise(vec3(iTime/3.))-0.5)*1.5;\n    cs = cos(lr), si = sin(lr);\n    sp.xz = mat2(cs, si, -si, cs)*sp.xz;\n    //float ou = (noise(vec3(iTime/3.+9.))-0.5)*.5;\n    cs = cos(ou), si = sin(ou);\n    sp.yz = mat2(cs, si, -si, cs)*sp.yz;\n    \n    \n    //wenn unterkeifer, wir habe ein zeitens bewegung zu verfolgen\n    //if its the bottom jaw, we have a second movement to track\n    if(svObjID == 2.){\n    \tfloat kf = (sin(iTime*7.))*.05*step(0.,smin(sin(iTime/4.), 0.5,0.2)-0.5);\n    \tcs = cos(kf), si = sin(kf);\n        sp.xz = mat2(cs, si, -si, cs)*(sp.xz);\n    }\n    \n    // Licht richtung Vektor / Light direction vector.\n    vec3 ld = lp-sp; \n    \n    // Entfernung vonlicht zu oberflasche \n    //Light to surface distance.\n    float lDist = max(length(ld), .001); \n    \n    // Licht vektor normalizieren.\n    // Normalizing the light vector.\n    ld /= lDist; \n    \n    //Licht abschwächen basierend auf entfernung.\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    \n    //1./6. funktioniert gut bei ichannel1=organic 2\n    //fur meist andere texturen, 1./2. ist besser.\n    // 1./8. oder 1./12. fur blue noise;\n    //1.6 works well for ichannel1=organic 2 \n    //most other textures, 1./2. is better\n    //or 1./8. for blue noise\n    const float texSize0 = 1./2.;\n    \n    \n    sn = doBumpMap(iChannel1, sp*texSize0, sn, 0.01);\n        \n        // Obtain the texel color at the surface position.\n    vec3 objCol = pow(tex3D( iChannel1, sp*texSize0, sn )*1.5, vec3(2.7));//vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 10.));\n        \n    \n    \n    // Standard diffuse.\n    float diff;// = max(dot(sn, ld), 0.);\n    //Phone specular von Athibaul: https://www.shadertoy.com/view/wlsBRX\n    float spec; //= phongSpecular(-rd, sn, ld, 60., 0.4);\n    //standard specular: pow(max( dot( reflect(-ld, sn), -rd ), 0.), 5.);\n    \n    //Wenn die objekt ist zhane, \n    if(svObjID == 0.){\n        \n        objCol *=3.1;// getObjectColor(sp);\n        sn = asn;\n        diff = max(dot(sn, ld), 0.);\n        spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 5.);\n        spec = pow(spec*6.,3.);\n    }\n    else{\n        objCol *=1.8;\n        diff = max(dot(sn, ld), 0.);\n        spec = phongSpecular(-rd, sn, ld, 60., 0.4);\n    }\n    \n    \n    \n    //Fur augen Nicht benutze\n    //For eyes Not used\n    /*\n    if(svObjID == 3.){\n        spec = pow(spec*6.,3.);\n        objCol = tex3D( iChannel2, sp*texSize0, sn )*1.5;;//vec3(2.);// getObjectColor(sp);\n        sn = asn;\n        diff = max(dot(sn, ld), 0.);\n        spec = spec = phongSpecular(-rd, sn, ld, 60., 0.4);\n           // pow(max( dot( reflect(-ld, sn), -rd ), 0.), 5.)*6.;\n    }*/\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    \n    //vec3 objCol = getObjectColor(sp);\n    \n    //kombinieren die oben genannten Bedingungen fur endgültige szene Farber.\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(0.9, 0.6, 0.3)*spec*(1.2-svObjID/3.)) * atten;\n    \n    // Nebel Faktor - basierend auf entfernung von Kamera\n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n\n    sceneCol = mix(sceneCol, vec3(0.01), fogF); \n    \n    return sceneCol;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Bildschirm Koordinaten / Screen coordinates\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Einheit Richtungs Ray / Unit direction ray\n    vec3 rd = normalize(vec3(uv, 1.));\n\n    //Ray Ursprung (auch also Oberflasche punkt verwendet)\n    //Ray origin (doubles as surface point)\n    vec3 ro = vec3(0., 0., -3.4);\n    \n    // Licht Position / Light position\n    vec3 lp = ro + vec3(0., 2.5, -0.5);\n    \n    //Trace\n    float lr = (noise(vec3(iTime/3.))-0.5)*1.5;\n    float ou = (noise(vec3(iTime/3.+9.))-0.5)*.5;\n    \n    \n    \n    float t = trace(ro, rd, lr, ou);\n        \n    //Berechnen welche objekt ID wir haben und es speichern.\n    svObjID = objID.x<objID.y? 0. : 1.;\n    if(objID.z < objID.x && objID.z < objID.y) svObjID = 2.;\n    //if(objID[3] < objID.x && objID[3] < objID.y && objID[3] < objID.z) svObjID = 3.;\n    oSvObjID = objID;\n   \n    //Schieben sie die Ray zu die triff punkt vor.\n    ro += rd*t;\n    \n    //Abruf die Normal von die Szene am diesem punkt\n    vec3 sn = getNormal(ro, lr, ou);\n    \n\t//Abruf die Farber von die szene am diesem punkt\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t, lr, ou);\n    \n\t//Uberpruf wann diese pixel sollte Schatten haben\n    float sh = softShadow(ro +  sn*.0015, lp, 16., lr, ou);\n\n    //Multiplizieren die Schatten zu die scene.\n    sceneColor *= sh;\n\n    //wenn die ray trifft die weitest erlaubt punkt, es ist hintergrund. Diese ist die \n    //Berechnung fur hintergrund.\n    if(t > FAR){\n        sceneColor = mix(vec3(0.77, 0.89, 1.),1.1*vec3(1., 0.89, 0.77), 1.0-(uv.y+0.2))/32.;\n    }\n    \n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\n\nREADME.md\n\n(ENGLISCH / DEUTSCH )\n\n\nENGLISH (first since most of you speak English. \n\nI suggest that you minimize all functions and then only\nexpand the \"knochen\" function and the \"map\" funtion and\nread those.\n\n\n*** Inspiration and Resources ***\n\nAnother learning Resource: Scratchpixel\nhttps://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry\nIf you don't have a computer science degree and / or aren't confident with basic\nlinear algebra and trigonometry I suggest you go through the geometrie section\nof this site.\n\nAlas, poor Yorick - from shau: https://www.shadertoy.com/view/3ddXR4\n[The teeth in my projekt is based on his but with simpler code \nthat I think I first discovered in an IQ project.]\n_______\n\nLost_Astronaught - from duvengar: https://www.shadertoy.com/view/Mlfyz4\n[This convinced me that it was possible to create detailed models \nwith only a few basic primitives ]\n________\n\nBlume[skull] - from tdhooper: https://www.shadertoy.com/view/WdScDG\n[This showed me how elegant a skull shader could look. and more of\nwhat makes a skull look like a skull, without too many details. \nI didn't use any ellipsoids so maybe that was part of why I wasn't \nable to achieve such elegance.]\n________\n\nRaymarched Reflections - von Shane: https://www.shadertoy.com/view/4dt3zn\n[The Shane reflection shader is one of the best starting points \nfor any 3d shader project imo. Other than the map function and \nthe knochen function, and a few tweaks, rest of the code is Shanes (or IQs). \nIf you took a month to understand and memorize his shader, you\nwould feel way more confident in create 3d shaders. (At least if\nyou are the type that needs to feel like they understand everything about \na project they are working on.)]\n_________\n\nIQ's Primitives:\nFrom Shadertoy: https://www.shadertoy.com/view/Xds3zN\nFrom his website: https://iquilezles.org/articles/distfunctions\nHis store: https://www.redbubble.com/people/inigoquilez/explore?page=1&sortOrder=recent\n_________\n\nEventually I want to have a redbubble store selling artwork like this\nas well. I've tried it before on redbubble but only with my pattern\nshaders and it didn't work out.\n_________\n\nPinterest: pinterest.de \nI have maybe 300 skull images saved in a private album. It helped me\na lot in figuring out what made a skull look like a skull. \n\n\n\n\n*** Projekt Walkthrough (only map and knochen) **** \n\n\n\n\n1. The \"knochen\"(bone) function (in the common tab):\n\n\"konchen\" is the \"power function\" of this program. Basically it\nreturns a rounded box but allows complete control through it's\nparameters for:\n\n- Rotate (th, phi, and ga): in x, y, and z\n- Gross Dimentionen (dim): in x, y and z\n- Position (xyz): x, y, and z\n- rounding (r)\n- mirror (speigel): amount the distance from the mirror-axis (the x axis for\na symmetrical skull and 50% fewer calculations.\n\nRoundedBox + smoothmin / smoothmax allows for very good\norganic models.\n\nMost of this skull model is built from roundedboxes.\n\n\n2. The map function (In der \"Buffer A\" tab):\n\nIn the early days of this projekt I was able to create a \n\"project skeleton\" pretty fast with 9 roundboxes (using the \n\"knochen\" funktion and copy and paste). This aloud me to easily \ntry things out. \n\nThe 9 main bones for the projekt skeleton are: \n\n1. A bone above the eye socket. (Aug\n2. A bone on the side of the eye socket.\n3. (A bone from the top-outer corner of the eye zu die top of the head.)\n4. A bone for the front of the cheek bones.\n5. A bone for the side of the cheekbones leading to the ear hole.\n6. A bone from the ear hole to the bottom jaw. \n7. A bone for the bottom jaw.\n8. A bone for the nose.\n9. A bone for the chin. (in some cases not needed)\n\nThese bones when oriented, give you a gut starting point \nfor the rest of the project.\nYou can see them in my map function.\n\n\n\n\n\n*** IMPORTANT DISCOVERIES ***\n\n\n\n\n\n1. The first important discovery during this project was\nthe gum ripple. It's a cyliner with something like:\nabs(cos(atan(sp.z,sp.y)*number-of-teetch))*0.003\nThis early discovery gave me a lot of motivation to continue.\n\n2. The Bone function and the 9 bones as a starting point.\n\n3. The rule of thirds: https://www.pinterest.ca/pin/862650503613525587/\nThe skull from the front and side should obey this rule.\nMy early attempts were really ugly and the reason was that I \ncompletely ignored this idea.\n\n\n4. Light: The Angle of light has a dramatic affect on the look\nof the skull.\n\n\nOther Discoveries:\nSuture lines, Teeth Specular Licht, A good shade of black, \n\n\nBrute Force: I stopped caring about how fast my code would run. \nWithout that I would never have been able to make this. \nThat's one of the many things Leetcode has taught me. Bruteforce \nis better than nothing. \n\n\n\n\n\n\n\nDEUTSCH:\n\nIch schlage vor, dass Sie alle Funktionen minimieren und sie nur die \n\"knochen\" funktion und die \"map\" zu lesen.\n\n\n\n\n*** Inspirationen und Resourcen ***\n\n\n\n\nAusbildung: Scratchpixel\nhttps://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry\nWenn sie habe kein Computer Wissenshaft Abschluss Ich schlage vor, \ndass Sie den Abschnitt Geemetrie von Scratchpixel.com studieren.\nLineare Algebra und Trigonometrie bilden die Grundlage für alles, \nwas ich hier getan habe. Kalkül ist auch wichtig, aber das ist für \neinen anderen Beitrag.\n_________\n\nAlas, poor Yorick - von shau: https://www.shadertoy.com/view/3ddXR4\n[Die Zähne in diesem Projekt basieren auf seinen.]\n_________\n\nLost_Astronaught - von duvengar: https://www.shadertoy.com/view/Mlfyz4\n[Diese hat mir uberzeugt das es moglisch war, ein sehr detailiert\nModell mit nur sehr einfachem Primitiven zu erstellen.]\n__________\n\nBlume[skull] - von tdhooper: https://www.shadertoy.com/view/WdScDG\n[Diese zeigt mir ein bischen uber was macht ein schadel seiht wie ein\nschadel. Es ist sehr elegant. Ich hab keine ellipsoiden benutzt.\nVielleicht war das einer der Gründe, warum ich dieses Maß an Eleganz \nnicht erreichen konnte. Ich weiß es nicht.]\n__________\n\nRaymarched Reflections - von Shane: https://www.shadertoy.com/view/4dt3zn\n__________\n\nDer Shane Relfection Shader ist eine die Best Ausgangspunkte\nfur jedes 3d projekte (Meine meinung nach). \nAbgesehen von der Kartenfunktion der Knochenfunktion und einigen \nÄnderungen ist dieser Code shanes.\nWenn Sie die Reflection Shader code verstehen UND auswendig kennen, \nwerden Sie beim Erstellen von 3D-Shadern viel sicherer sein.\n__________\n\nIQ's Primitiven:\nAuf Shadertoy: https://www.shadertoy.com/view/Xds3zN\nVon seiner webseit: https://iquilezles.org/articles/distfunctions\nSein Laden: https://www.redbubble.com/people/inigoquilez/explore?page=1&sortOrder=recent\n__________\n\nSchließlich möchte ich auch ein Geschäft haben, in dem meine \nShader-Kunstwerke verkauft werden. Ich habe es mit Redbubble versucht, \naber nur mit Mustern und es hat nicht geklappt.\n__________\n\nPinterest: pinterest.de \nIch hab vielleich 300 Schadel bilden in ein privat Album\ngespeichert. Pinterst ist eine meien wichtigste Resourcen fur\nshader inspiration.\n\n\n\n\n*** Projekt Anleitung ***\n\n\n\n\n\n1. die knochen funktion (In Der \"Common\" tab):\n\n\"knochen\" ist die \"Machtfunktion\" von diese program. Grundlisch es\ngibt ein roundedbox zuruck aber es erlaubt komplett kontroll durch die \nparametern fur:\n\n- Drehen (th, phi,und ga): in x,y,und z\n- Gross Dimentionen (dim): in x,y und z\n- Position (xyz): x,y,und z\n- Menge die Runden (r)\n- spiegeln (speigel): menge die entfernung von die spiegeln-axis (die x axis fur \nein symmetrish schadel und 50% weniger berechnungen.\n\nVon diese parametern es ist moglish viele roundedbox in die map \nfunktion zu erstellen (kopie und paste) and leich mit sie spielen.\n\nRoundedBox + smoothmin / smoothmax erlaut fur ein sehr \norganisch Modelle.\n\nMeistens von diese Schadel Model ist von roundedbox aufgebaut.\n\n2. map funktion (in der \"Buffer A\" tab):\n\n\nIn den frühen Tagen dieses Experiments ich war in der Lage ein \n\"skelett\" schnell mit roundedbox(\"knochen\") zu entwickeln durch \ndie drehen/skalieren/runden und position.\n\nSie brauch nur 9 haupt teilen, wann sie ein Schadel beobachten:\n\n\n1.Ein Knochen über der Augenhöhle.\n2.Ein Knochen an der Seite der Augenhöhle.\n3.(Ein Knochen aus dem oberen äußeren Augenwinkel zu der Oberseite des Kopfes.)\n4.Ein Knochen für die Vorderseite der Wangenknochen.\n5.Ein Knochen für die Seite der Wangenknochen, die zum Ohrloch führt.\n6.Ein Knochen vom Ohrloch bis zum Unterkiefer.\n7.Ein Knochen für den Unterkiefer.\n8.Ein Knochen für die Nase.\n9.Ein Knochen für das Kinn. (in einigen Fällen nicht erforderlich)\n\nDiese knochen wann recht orientiert gibt sie ein gut Startpunkt.\n\nSie konnen diese in meine map funktion sehen. \n\n\n\n***** WICHIG ENTDECKUNGEN *****\n\n1. Die erste wichtig Entdeckung wahren dieses Projekt war\ndie Zahnfleich welligkeit. Das war nur ein sdCappedCylinder \nmit abs(cos(atan(sp.z,sp.y)*zahnAnzahl))*0.003 oder so.\nIch hat diese sehr Fruh entdeckt und es hat mir sehr viel\nmotiviert weiterzumachen.\n\n2. Die Knochen funktion und die 9 knochen als ein Einstiegspunkt.\n\n3. die 3-3-3 Proportion Regeln: \nhttps://www.pinterest.ca/pin/862650503613525587/\n\nDer Schädel sollte der Drittelregel folgen, wenn er von vorne \noder von der Seite betrachtet wird.\nMeine erste Schadeln war sehr hasslich und diese war die haupt \nGrunde.\n\n4.Licht: die licht winkle hat ein Dramatisch auswirkung von die\naussehen die schadel!\n\nAndere Entdeckungen:\nSuture lines, Zahn Specular Licht, Schwarze, \n\nRohe-stark(Brute Force):Ich hörte auf, mich darum zu kümmern, \nwie langsam mein Code laufen würde. Ohne das hätte ich das \nnie geschafft. Das ist eines der vielen Dinge, die Leetcode\nmir beigebracht hat. RoheStark ist besser als nichts.\n\n*/\n\n\n\n\n//Von Shane / From Shane: Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n//Von Shane / From Shane: Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    //n = abs(n)/1.732051;\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    //n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n//Von Shane / From Shane:  Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\nfloat audio_ampl( in sampler2D channel, in float t) \n{ return texture( channel, vec2(t, 0.00000000005) ).x; }\n\n//IQ PRIMITIV\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//IQ Smooth funktionen\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n//die \"Macht-Funktion\" von dieses projekt / Power function of the project\n//es erstellt eine gerundete kiste / it creates a rounded box\n\n/*\np = ursprunglich position / original position\nxyz = Verschiebung / Translation\ndim = Skalierung fur alle axis / Scaling for all axis\nth,phi,ga = drehen x,y,z / rotation x,y,z\nspiegel = Spielgen auf x axis / reflection auf x axis\nr = Radius (fur rounden box am end / for the rounded box at the end)\n*/\n\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    /*\n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n    */\n    sp.yz*=mat2(cos(th + vec4(0,11,33,0)));\n    sp.xz*= mat2(cos(phi + vec4(0,11,33,0)));\n    sp.xy*= mat2(cos(ga + vec4(0,11,33,0)));\n    \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, \n                    0.19, \n                    0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen + cos(sp.x*6.+ 1.4)*0.05);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.03;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\n\n//fur nicth verwendete fbm / for unused fbm\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n//speicher fur objekt IDs / storage for object ids\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.","name":"Common","description":"","type":"common"}]}