{"ver":"0.1","info":{"id":"XdGfDK","date":"1532236278","viewed":501,"name":"Stylized Jellyfish","username":"AmanSachan","description":"Animated Jellyfish made with no textures and only math (signed Distance Fields)\nAlso serves as a template for future ray marching projects;","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animated","jellyfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Aman Sachan\n// Github: https://github.com/Aman-Sachan-asach\n// LinkedIn: https://linkedin.com/in/amansachan1/\n// Personal Website: http://amansachan.com/\n\n//change AA to 1 to turn off AntiAliasing --> greatly improves framerate\n#define AA 2\n#define DEBUG_NORMALS 0\n#define USE_BOUNDING_VOLUMES 1\n\n#define CONTROL_CAMERA 0\n#define SINGLE_JELLYFISH 1\n\n//--------------\n// Camera Stuff\n//--------------\n\nvoid initCamera()\n{\n    #if( SINGLE_JELLYFISH < 1 )\n        cam.eye     = vec3(0.0, 0.0, 600.0);\n        cam.target  = vec3(0.0, 0.0, 0.0);\n    #else\n        cam.eye     = vec3(0.0, -5.0, 120.0);\n        cam.target  = vec3(-24.0, 0.0, 0.0);\n    #endif\n    \n    cam.right   = vec3(1.0, 0.0, 0.0);\n    cam.up      = vec3(0.0, 1.0, 0.0);\n    cam.forward = vec3(0.0, 0.0, -1.0);\n}\n\nvoid moveCamera_viaMouse()\n{\n    //convert m to a -0.5 to 0.5 range in both x and y\n    vec2 m = (iMouse.xy/iResolution.xy) - vec2(0.5,0.5);\n    //convert m to -PI/2 to PI/2 range in both x and y\n    m *= PI;\n    \n    mat3 camView = transpose( mat3(cam.right, cam.up, cam.forward) );\n    camView = rotateY(m.x) * rotateX(m.y) * camView;\n    \n    cam.right   = vec3(camView[0][0], camView[1][0], camView[2][0]);\n    cam.up      = vec3(camView[0][1], camView[1][1], camView[2][1]);\n    cam.forward = vec3(camView[0][2], camView[1][2], camView[2][2]);   \n}\n\nRay castRay(vec2 uv, Camera camera) \n{\n    float imgAspectRatio = iResolution.x / iResolution.y; // assuming width > height\n        \n    // Compute ndc space point from screenspace point //[-1,1] to [0,1] range\n    vec2 NDC_Space_Point = uv * 2.0 - 1.0;\n    \n    float tanFOV_Y_by2 = tan(FOV_Y *0.5 * deg2rad);\n    \n    vec3 cam_x = NDC_Space_Point.x * tanFOV_Y_by2 * imgAspectRatio * camera.right;\n    vec3 cam_y = NDC_Space_Point.y * tanFOV_Y_by2 * camera.up;\n\n    //convert to world space\n    vec3 ref = camera.eye + camera.forward;\n    vec3 p = ref + cam_x + cam_y; //facing the screen\n    \n    Ray ray;\n    ray.origin = camera.eye;\n    ray.dir = normalize(p - camera.eye);\n    return ray;\n}\n\n//------------------\n// Jellyfish Colors\n//------------------\n\nvec3 jellyShellColorHelper(vec3 p, float pumpTheta)\n{\n    float x = p.x*2.5;\n    float y = p.y*2.5;\n    float z = p.z*2.5;\n    \n    float pattern = abs(tan((sin(x) - cos(x))*1.15) * 0.1) +\n                    abs(tan((sin(y) - cos(y))*1.15) * 0.1) +\n                    abs(tan((sin(z) - cos(z))*1.15) * 0.1);\n\n    float alpha = pumpTheta*0.3;\n    float colorPump = 2.0 * ( cos(alpha+cos(alpha))+\n                              sin(2.0*alpha)*0.2+\n                              sin(4.0*alpha)*0.02 );\n    \n    //golden\n    float k = abs(colorPump)*pattern;\n    k -= 2.75;\n    vec3 rippleColor = mix(BLUE, PURPLE, k);\n    \n    if(pattern < 0.5)\n    {\n        return LIGHT_BLUE;\n    }\n    \n    if( dot(BLUE, normalize(rippleColor))>0.5 )\n    {\n        return INTENSE_PURPLE;\n    }\n    \n    return rippleColor;\n}\n\nvec3 jellyOuterTentaclesColorHelper(vec3 p, float pumpTheta)\n{\n    float x = p.x*2.5;\n    float y = p.y*2.5;\n    float z = p.z*2.5;\n    \n    float pattern = abs(tan((sin(x) - cos(x))*1.15) * 0.1) +\n                    abs(tan((sin(y) - cos(y))*1.15) * 0.1) +\n                    abs(tan((sin(z) - cos(z))*1.15) * 0.1);\n\n    float alpha = pumpTheta*0.3;\n    float colorPump = 2.0 * ( cos(alpha+cos(alpha))+\n                              sin(2.0*alpha)*0.2+\n                              sin(4.0*alpha)*0.02 );\n    \n    float k = abs(colorPump)*pattern;\n    k -= 2.75;\n    vec3 goldPurpleTransition = mix(BLUE, PURPLE, k);\n\n    if( dot(BLUE, normalize(goldPurpleTransition))>0.5 )\n    {\n        return INTENSE_PURPLE;\n    }\n    \n    return goldPurpleTransition;\n}\n\nvec3 heartColorHelper(vec3 p, float pumpTheta)\n{\n    float alpha = pumpTheta*0.5;\n    float colorPump = ( cos(alpha+cos(alpha)) +\n                        sin(2.0*alpha)*0.2 +\n                        sin(4.0*alpha)*0.02 );\n    \n    float k = colorPump + 0.85;\n    float e = mod(k * 0.25,iTime) * 0.75;\n    \n    vec3 color = mix(DARK_BLUE, NEON_BLUE, e);\n    return color;\n}\n\nvec3 jellyShellColor( vec3 p, float pumpTheta )\n{\n    return jellyShellColorHelper( p, pumpTheta );\n}\n\nvec3 jellyOuterTentaclesColor(vec3 p, float pumpTheta)\n{\n    return jellyOuterTentaclesColorHelper( p, pumpTheta );\n}\n\nvec3 heartColor(vec3 p, float pumpTheta)\n{\n    return heartColorHelper( p, pumpTheta );\n}\n\n//------------------\n// Background Colors\n//------------------\n\n//large\nvec3 godRaySet1( in vec2 uv, inout float count, in vec3 oceanGradient )\n{\n    vec2 sunBeamOrigin;\n    float beamAngle;\n    \n    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );\n    \n    for(float i=0.0; i<2.0; i++)\n    {\n        sunBeamOrigin = vec2(0.45 + i*0.5,5.0);\n        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 8.0, 2.5);\n        float t = (1.0+sin(iTime*2.5+0.1073))*0.5;\n        t = remap(t, 0.0,1.0,0.5,1.1);\n        beamAngle = abs(sin(0.0035*PI*t)) * noise;\n            \n        vec2 sunToPoint = normalize(uv - sunBeamOrigin);\n        float theta = acos(dot(sunToPoint, beamDir));\n        \n        if( theta < beamAngle )\n        {           \n            count += 1.0;\n            \n            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);\n            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_LARGE, 0.5);\n            return mix(OCEANBLUE3, godRayColor, beta*(uv.y+0.1));\n        }\n    }\n    \n    return vec3(0.0);\n}\n\n//medium\nvec3 godRaySet2( in vec2 uv, inout float count, in vec3 oceanGradient )\n{\n    vec2 sunBeamOrigin;\n    float beamAngle;\n    \n    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );\n    \n    for(float i=0.0; i<4.0; i++)\n    {\n        sunBeamOrigin = vec2(0.25 + i*0.3,5.0);\n        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 1.75, 4.0);\n        float t = (1.0+sin(iTime*1.25+0.9873))*0.5;\n        t = remap(t, 0.0,1.0,0.75,1.25);\n        beamAngle = abs(sin(0.0035*PI*t)) * noise;\n            \n        vec2 sunToPoint = normalize(uv - sunBeamOrigin);\n        float theta = acos(dot(sunToPoint, beamDir));\n        \n        if( theta < beamAngle )\n        {           \n            count += 1.0;\n            \n            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);\n            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_LARGE, 0.5);\n            return mix(OCEANBLUE3, godRayColor, beta*(uv.y+0.1));\n        }\n    }\n    \n    return vec3(0.0);\n}\n\n//small\nvec3 godRaySet3( in vec2 uv, inout float count, in vec3 oceanGradient )\n{\n    vec2 sunBeamOrigin;\n    float beamAngle;\n    \n    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );\n\n    for(float i=0.0; i<=10.0; i++)\n    {\n        sunBeamOrigin = vec2(0.25 + i*0.1,5.0);\n        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 0.35, 1.15);\n        float t = (1.0+sin(iTime*0.4+0.45678))*0.5;\n        t = remap(t, 0.0,1.0,0.5,1.0);\n        beamAngle = abs(sin(0.0035*PI*t)) * noise;\n            \n        vec2 sunToPoint = normalize(uv - sunBeamOrigin);\n        float theta = acos(dot(sunToPoint, beamDir));\n        \n        if( theta < beamAngle )\n        {\n            count += 1.0;\n            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);\n            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_SMALL, 0.5);\n            return mix(OCEANBLUE3, godRayColor, beta*uv.y);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 calcBackgroundColor( in vec2 uv )\n{\n    vec3 oceanGradient = OCEANBLUE3;\n    float count = 0.0;\n    \n    vec3 c1 = godRaySet1( uv, count, oceanGradient );\n    c1 = mix(c1, oceanGradient, 1.0-luminance(c1));\n    \n    vec3 c2 = godRaySet2( uv, count, oceanGradient );\n    c2 = mix(c2, oceanGradient, 1.0-luminance(c2));\n    \n    vec3 c3 = godRaySet3( uv, count, oceanGradient )*0.85;\n    c3 = mix(c3, oceanGradient, 1.0-luminance(c3));\n\n    vec3 total = c1+c2+c3;\n    float t = abs(sin(iTime*0.2)); // in a 0.0 to 1.0 range\n    t = remap(t, 0.0, 1.0, 1.15, 1.95);\n    vec3 bgColor = mix(total, oceanGradient, t-luminance(total));\n    \n    return bgColor*0.6;\n}\n\n//--------------\n// Complex SDFs\n//--------------\n\nfloat N_tentaclesInner( vec3 p )\n{\n    p = invTranslateOp( p, vec3(2.0,0.0,0.0) );\n    vec3 deformedR =  vec3(40.0,3.0,0.2);\n    \n    float udbox = udBox( p, deformedR );\n    \n    deformedR =  vec3(50.0,0.2,0.2);\n    deformedR.y += clamp( N1(p.xy, 2.0, 0.65, 1.5), 0.0, 10.0 );\n    \n    p = invTranslateOp( p, vec3(-10.0,0.0,0.0) );\n    float ellipsoid = sdEllipsoid( p, deformedR );\n    \n    return intersectSDF( udbox, ellipsoid );\n}\n\nfloat heart(vec3 p)\n{\n    p /= 1.3;\n    //slightly weird down the middle but thats okay cause it will be hidden\n    float h = p.x*p.x+p.y*p.y+2.0*p.z*p.z-1.0;\n    float y3 = p.y*p.y*p.y;\n    float v = h*h*h-(p.x*p.x)*y3;\n    \n    vec3 g = vec3(6.0 *p.x*h*h-2.0*p.x*y3,\n                  6.0 *p.y*h*h-3.0*p.x*p.x*p.y*p.y-0.3*p.z*p.z*p.y*p.y,\n                  12.0*p.z*h*h-0.2*p.z*y3 );\n    \n    return v/max(0.2,length(g));\n}\n\nfloat N_tentaclesOuter( vec3 p )\n{\n    p = invTranslateOp( p, vec3(2.0,0.0,0.0) );\n    vec3 deformedR =  vec3(40.0,3.0,0.2);\n    \n    float udbox = udBox( p, deformedR );\n    \n    deformedR =  vec3(25.0,0.2,0.2);\n    deformedR.y += clamp( N2(p.xy, 1.5), 0.0, 10.0 );\n    \n    p = invTranslateOp( p, vec3(-25.0,0.0,0.0) );\n    float ellipsoid = sdEllipsoid( p, deformedR );\n    \n    return intersectSDF( udbox, ellipsoid );\n}\n\nIntersection tentaclesInner(vec3 p, float pump, float bob, float t, float N, float pumpTheta)\n{\n    pModPolar(p.xz, 5.0);\n    p.x += pump*noise((p.y+p.x+p.z)+iTime*TWO_PI*0.7);\n    \n    // add some sway to the tentacles\n    {   \n        float S = smoothstep(.5, -3., p.y);\n        float theta = t+p.y+N*TWO_PI;\n        float sway = sin(theta*1.25)*N;\n        p.x += sway*N;\n    }\n    \n    vec3 pHeart = p;\n    p = invTranslateOp( p, vec3(5.0,-38.0,0.0) ); //controls distance from center of jellyHeadBottom\n    p *= rotateZ(90.0*deg2rad);\n    \n    float d = N_tentaclesInner(p);\n    \n    //place hearts down the tentacle\n    pHeart = invTranslateOp( pHeart, vec3(5.0,-3.0,0.0) );\n    pHeart *= rotateY(90.0*deg2rad);\n    pModInterval(pHeart.y, 5.0, -12.5, 0.0);\n    float e = heart(pHeart);\n    \n    vec3 hColor = heartColor(p, pumpTheta);\n    \n    Intersection hearts = Intersection(e, hColor, obj_Jelly_InnerTentacles);\n    Intersection innerTentacles = Intersection(d, RED, obj_Jelly_InnerTentacles);    \n    Intersection jellyInnerTentacles = smin(hearts, innerTentacles, 0.2);\n    \n    return jellyInnerTentacles;\n}\n\nIntersection tentaclesOuter(vec3 p, float pump, float bob, float t, float N, float pumpTheta)\n{\n    pModPolar(p.xz, 25.0);  \n    p.y -= bob;\n    p.x += pump*1.65;\n    \n    p = invTranslateOp( p, vec3(15.0,-38.2,0.0) ); //controls distance from center of jellyHeadBottom\n    \n    //------ add some sway to the tentacles -----\n    {   \n        float S = smoothstep(-1.0, -3.5, p.y); //used to keep the top most bit of the tentacle stationary\n        \n        const float freq = 0.4;\n        const float amp = 1.0;\n        float sway = sin((t+p.y+N*TWO_PI)*freq)*N*S;\n        p.x += sway*N*amp;\n    }\n    //------ \n    \n    p = rotateZ(-90.0*deg2rad) * p;\n    float tentacles = N_tentaclesOuter(p);\n    \n    //------ add the top joints -----   \n    p = invTranslateOp( p, vec3(-36.5,-0.1,0.0) );\n    vec3 tx_p = invRotateZ(-90.0*deg2rad) * p;\n    \n    float coneSection = sdConeSection( tx_p, 1.8, 0.2, 0.65 );\n    float a = smin( coneSection, tentacles, 0.5 );\n\n    tx_p = invRotateZ(90.0*deg2rad) * invRotateX(90.0*deg2rad) * p;\n    tx_p = invTranslateOp( tx_p, vec3(0.0,-0.75,0.0) );\n    float b = sdTriPrism( tx_p, vec2 (2.0,0.2) );\n    float c = smin( a,b, 0.5 );\n    //------\n        \n    vec3 baseColor = jellyOuterTentaclesColor(p, pumpTheta);\n    Intersection jellyOuterTentacles = Intersection(c, baseColor, obj_Jelly_OuterTentacles);\n\n    return jellyOuterTentacles;\n}\n\nIntersection JellyFishHead(vec3 p, float pump, float bob, float t, float N, float pumpTheta) \n{   \n    //----- pump -----\n    p.y -= bob;\n    p.xz *= (1.0 + pump*0.1);\n    //-----\n    \n    float ellipsoid = sdEllipsoid( p, vec3(15.0, 13.0, 15.0) );\n    float innerEllipsoid = sdEllipsoid( p, vec3(13.0, 11.0, 13.0) );\n    \n    vec3 moved_p = invTranslateOp( p, vec3(0.0,-8.0,0.0) );\n    float box = sdBox( moved_p, vec3(15.5,8.0,15.5) );\n    float a = intersectSDF( -box, ellipsoid );\n    \n    // the shell of a hemi-ellipsoid\n    float b = differenceSDF( a, innerEllipsoid );\n    \n    //The blob inside the jelly fish head\n    vec3 tx_p = invTranslateOp( p, vec3(0.0,5.0,0.0) );\n    float d = sdTorus( tx_p, vec2( 4.5, 4.0 ) );\n    float e = opDisplace( tx_p, d, 1.5, 0.75 );\n    \n    float f = unionSDF( b, e );\n\n    vec3 jellyBlobColor = RED;\n    vec3 jellyShellColor = jellyShellColor( tx_p, pumpTheta );\n    \n    const float k = 0.5;\n    float h = clamp( 0.5+0.5*(b-e)/k, 0.0, 1.0 );\n    vec3 baseColor = mix(jellyShellColor, jellyBlobColor, h);\n    \n    Intersection jellyHead = Intersection(f, baseColor, obj_Jelly_Head);\n    \n    return jellyHead;\n}\n\nIntersection JellyFish(vec3 p, float t, float N) \n{   \n    Intersection jellyfish = Intersection(MORE_THAN_MAX_DIST, GREEN, obj_null);\n    \n    float theta = t + N*TWO_PI;\n    float bob   = (cos(theta+cos(theta))+sin(2.0*theta)*0.2)*0.6;\n    float x     = (p.y+N*TWO_PI)*0.2+t;\n    float pump  = 2.0 * ( cos(x+cos(x))  +\n                          sin(2.0*x)*0.2 +\n                          sin(4.0*x)*0.02 );\n    \n    #if(USE_BOUNDING_VOLUMES == 1)\n        Intersection head   = Intersection(MORE_THAN_MAX_DIST, PURPLE, obj_null);\n        Intersection innerT = Intersection(MORE_THAN_MAX_DIST, RED, obj_null);\n        Intersection outerT = Intersection(MORE_THAN_MAX_DIST, PURPLE, obj_null);\n        \n        vec3 p_bb_head = invTranslateOp( p, vec3(0.0,6.15,0.0) );\n        float bbHead = sdBox( p_bb_head, vec3(18.65,7.65,18.65) );\n        \n        vec3 p_bb_innerT = invTranslateOp( p, vec3(0.0,-40.0,0.0) );\n        float bbInnerT = sdCappedCylinder( p_bb_innerT, vec2(10.15, 40.0));\n        \n        vec3 p_bb_outerT = invTranslateOp( p, vec3(0.0,-20.05,0.0) );\n        float bbOuterT = sdCappedCylinder( p_bb_outerT, vec2(19.85, 20.7) );\n\n        if(bbHead <= EPSILON)   \n        { head = JellyFishHead( p, pump, bob, t, N, x ); }\n        else                    \n        { head.t = bbHead; }\n        \n        if(bbInnerT <= EPSILON) \n        { innerT = tentaclesInner( p, pump, bob, t, N, x ); }\n        else                    \n        { innerT.t = bbInnerT; }\n    \n        if(bbOuterT <= EPSILON) \n        { outerT = tentaclesOuter( p, pump, bob, t, N, x ); }\n        else                    \n        { outerT.t = bbOuterT; }\n        \n        jellyfish = unionSDF( combine( head, outerT, 0.15 ), combine(head, innerT, 0.15 ), 0.5 );\n    #else\n        Intersection head      = JellyFishHead( p, pump, bob, t, N, x );\n        Intersection innerT    = tentaclesInner( p, pump, bob, t, N, x );\n        Intersection outerT    = tentaclesOuter( p, pump, bob, t, N, x );\n        \n        jellyfish = unionSDF( smin( head, outerT, 0.5 ), smin(head, innerT, 0.5 ), 0.5);\n    #endif\n    \n    return jellyfish;\n}\n\nIntersection sceneSDF(vec3 samplePoint) \n{   \n    float t = iTime*10.0;\n    float N = N3(vec3(iResolution));\n    \n    Intersection sdf = Intersection(MORE_THAN_MAX_DIST, GREEN, obj_null);\n    \n    vec3 txSamplePoint = samplePoint;   \n    #if( SINGLE_JELLYFISH >= 1 )\n        txSamplePoint = invRotateX(30.0*deg2rad)*invRotateY(iTime)*samplePoint; //iTime 375.35 -90.0*deg2rad\n        //move diagonally up \n        txSamplePoint = invTranslateOp( txSamplePoint, vec3(-24.0,15.0,0.0) );\n    #endif\n    \n    //tilt        \n    mat3 rot = invRotateZ(-50.0*deg2rad) * invRotateX(-20.0*deg2rad);\n    txSamplePoint = rot * txSamplePoint;    \n    \n    #if( SINGLE_JELLYFISH >= 1 )\n        txSamplePoint = invRotateY( iTime ) * txSamplePoint;\n    #endif\n\n    #if(USE_BOUNDING_VOLUMES == 1)\n        vec3 p_bb = invTranslateOp( txSamplePoint, vec3(0.0,-33.5,0.0) );\n        float bbJellyFish = sdCapsule( p_bb, vec3(0.0,27.5,0.0), vec3(0.0,-27.5,0.0), 20.0 );\n\n        if(bbJellyFish <= EPSILON)\n        {    \n            sdf = JellyFish( txSamplePoint, t, N );\n        }\n        else\n        {\n            sdf.t = bbJellyFish;\n        }\n    #else\n        sdf = JellyFish( txSamplePoint, t, N );\n    #endif\n\n    return sdf;\n}\n\n//----------------\n// Sphere Tracing\n//----------------\n\n//Returns the 't' value at the point of intersection with the scene; \n//if it fails it returns a 't' value = 'end'\nIntersection shortestDistanceToSurface(Ray ray, float start, float end) \n{\n    Intersection res = Intersection(start, vec3(0.0), obj_null);\n    \n    vec3 p;\n    RC rc; //repeated coordinates\n    \n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++) \n    {\n        p = ray.origin + res.t * ray.dir;\n        float sceneBB_Dist = sdBox( p, sceneBBsize );\n\n        if (sceneBB_Dist<EPSILON)\n        {\n            #if( SINGLE_JELLYFISH < 1 )\n                rc = pModGrid(p, jellySpacing);\n                rc.p += 100.0f*N3(rc.id);\n                Intersection intersection = sceneSDF(rc.p);\n            #else\n                Intersection intersection = sceneSDF(p);\n            #endif\n            if (intersection.t < EPSILON) \n            {\n                res.color = intersection.color;\n                res.objHit = intersection.objHit;\n                return res;\n            }\n            res.t += intersection.t;\n            if (res.t >= end) \n            {\n                return res;\n            }     \n        }\n        else\n        {\n            res.t = end + 1.0f;\n            return res;\n        }\n    }\n    return res;\n}\n\n//---------------------------------\n// Surface Properties and Lighting\n//---------------------------------\n\n//Calculate the gradient of the surface at 'p' by going a delta distance along every axis\n//Might be possible to do a dF/dx and dF/dy thing if the objects are close to the camera\n//Experiment with it because that is a hardware accelerated function\nvec3 calcNormal(vec3 p ) \n{\n    float t_atPoint = sceneSDF(p).t;\n    vec3 normal = vec3( sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).t - t_atPoint,\n                        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).t - t_atPoint,\n                        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).t - t_atPoint );\n    return normalize(normal);\n}\n\n//--------\n// Render\n//--------\n\nvec4 render( in Ray r, in Intersection intersection, in vec2 uv )\n{\n    vec3 backgroundColor = calcBackgroundColor( uv );\n    // Background Color\n    if ((intersection.objHit == obj_null)||(intersection.t > MAX_DIST - EPSILON)) \n    {\n        // Didn't hit anything\n        return vec4(backgroundColor,1.0);\n    }\n    \n    //Surface Coloration\n    vec3 p = r.origin + intersection.t * r.dir;\n    \n    vec3 surfaceNormal = calcNormal( p );\n    vec3 LightDir = vec3(0.0,0.0,1.0);    \n    vec3 baseColor = intersection.color;\n    \n#if (DEBUG_NORMALS == 1)\n    baseColor = abs(surfaceNormal);\n    return vec4(baseColor, 1.0);\n#else    \n    //assumes surfaceNormal and LightDir are normalized\n    float lambert = max( dot(surfaceNormal, LightDir), 0.3 ); //0.3 and not zero to add ambient light\n    vec3 color = baseColor * lambert;\n\n    float lum = clamp(luminance(color)+0.4,0.0,1.0); \n    \n    vec3 finalColor = mix(backgroundColor, color, lum);\n    return vec4(finalColor, 1.0);\n#endif\n}\n\n//------\n// Main\n//------\n\nvec4 getSceneColor(in Ray ray, in vec2 uv)\n{   \n    vec4 sceneColor = vec4(0.0);\n    Intersection intersection = shortestDistanceToSurface(ray, MIN_DIST, MAX_DIST);\n    vec4 renderColor = render(ray, intersection, uv);\n\n#if (DEBUG_NORMALS == 1)\n    sceneColor += renderColor;\n#else\n    // gamma correction --> 1/2.2 = 0.4545\n    vec3 gcColor = pow( renderColor.xyz, vec3(0.4545) );\n    sceneColor += vec4( gcColor, renderColor.w );\n#endif\n\n    return sceneColor;\n}\n\nvec4 getSceneColorAntiAliased(in vec2 uv, in vec2 fragCoord)\n{\n    vec4 totalSceneColor = vec4(0.0);\n    for( int m=0; m<AA; m++ )\n    {\n        for( int n=0; n<AA; n++ )\n        {\n            // offset pixel coordinates so as to imitate supersampling\n            vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;\n            uv = (fragCoord + offset)/iResolution.xy;\n            Ray ray = castRay( uv, cam );\n\n            totalSceneColor += getSceneColor(ray, uv);\n        }\n    }\n    totalSceneColor /= float(AA*AA);\n    \n    return totalSceneColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv coordinates are the same as Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    initCamera();\n    \n#if CONTROL_CAMERA\n    moveCamera_viaMouse();\n#endif\n    \n    vec4 totalColor = vec4(0.0);\n    //The AA implementation is just supersampling\n#if AA>1\n    totalColor = getSceneColorAntiAliased(uv, fragCoord);\n#else\n    Ray ray = castRay( uv, cam );\n    totalColor = getSceneColor(ray, uv);\n#endif\n   \n    //Post-processing\n    totalColor = postProcess(totalColor, uv);\n    fragColor = totalColor;\n}\n\n//------------\n// References:\n//------------\n// IQ's Blog: https://iquilezles.org/articles/distfunctions\n// Jamie Wong: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#model-transformations\n// Useful sdf functions but primarily PolarMod: http://mercury.sexy/hg_sdf/\n// Borrowed and modified the pump and sway functions from Luminescence: https://www.shadertoy.com/view/4sXBRn\n// Heart shape from https://www.shadertoy.com/view/llXGRX","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------\n// GlobalConstants\n//-----------------\n\n#define PI 3.14159265359\n#define TWO_PI 6.283185307179586\n#define deg2rad PI / 180.0\n#define NUM_NOISE_OCTAVES 5\n\nconst int MAX_RAYMARCH_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 2500.0;\nconst float MORE_THAN_MAX_DIST = MAX_DIST + 1.0;\nconst float MIN_T_SHADOWS = 0.001;\nconst float MAX_T_SHADOWS = 10.0;\nconst float EPSILON = 0.0001;\n\nconst float FOV_Y = 45.0;\nconst vec3 jellySpacing =  vec3(250.0,300.0,250.0);\nconst vec3 sceneBBsize = vec3(800.0, 1200.0, 1200.0);\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 WHITE = vec3(1.0);\nconst vec3 GREEN = vec3(1.0,0.0,0.0);\nconst vec3 BLUE  = vec3(0.0,0.0,1.0);\n\nconst vec3 NEON_RED = 1.50*vec3(200.0/255.0, 28.0/255.0, 35.0/255.0);\nconst vec3 RED = 0.50*vec3(200.0/255.0, 28.0/255.0, 35.0/255.0);\n\nconst vec3 ORANGE = vec3(40.0/255.0, 214.0/255.0, 81.0/255.0);\nconst vec3 VIOLET = vec3(192.0/255.0, 116.0/255.0, 224.0/255.0);\n\nconst vec3 PURPLE = vec3(131.0/255.0, 50.0/255.0, 252.0/255.0);\nconst vec3 PURPLE2 = vec3(94.0/255.0, 56.0/255.0, 175.0/255.0);\nconst vec3 INTENSE_PURPLE = 0.85*vec3(131.0/255.0, 50.0/255.0, 252.0/255.0);\n\nconst vec3 NEON_BLUE = 10.5*vec3(0.01, 98.0/255.0, 1.0);\nconst vec3 LIGHT_BLUE = 2.5*vec3(0.01, 98.0/255.0, 1.0);\nconst vec3 DARK_BLUE = 1.2*vec3(0.01, 98.0/255.0, 1.0);\n\nconst vec3 SUN_BEAM_SMALL = vec3(1.0, 252.0/255.0, 119.0/255.0);\nconst vec3 SUN_BEAM_MEDIUM = vec3(1.0, 252.0/255.0, 119.0/255.0);\nconst vec3 SUN_BEAM_LARGE = vec3(1.0, 252.0/255.0, 119.0/255.0);\n\nconst vec3 OCEANBLUE0 = vec3(0.0/255.0, 199.0/255.0, 255.0/255.0);\nconst vec3 OCEANBLUE1 = vec3(0.0/255.0, 162.0/255.0, 232.0/255.0);\nconst vec3 OCEANBLUE2 = vec3(0.0/255.0, 133.0/255.0, 242.0/255.0);\nconst vec3 OCEANBLUE3 = vec3(0.0/255.0, 91.0/255.0, 165.0/255.0);\nconst vec3 OCEANBLUE4 = vec3(14.0/255.0, 70.0/255.0, 135.0/255.0);\nconst vec3 OCEANBLUE5 = vec3(14.0/255.0, 55.0/255.0, 102.0/255.0);\nconst vec3 OCEANBLUE6 = vec3(13.0/255.0, 41.0/255.0, 73.0/255.0);\nconst vec3 OCEANBLUE7 = vec3(8.0/255.0, 26.0/255.0, 45.0/255.0);\nconst vec3 OCEANBLUE8 = vec3(3.0/255.0, 12.0/255.0, 20.0/255.0);\nconst vec3 OCEANBLUE9 = vec3(0.0/255.0, 4.0/255.0, 7.0/255.0);\n\n//GLSL doesnt support enums so we are goint to use some const defines\nconst uint obj_null                 = 0x00000001u;\nconst uint obj_Jelly_Head           = 0x00000002u;\nconst uint obj_Jelly_InnerTentacles = 0x00000003u;\nconst uint obj_Jelly_OuterTentacles = 0x00000004u;\nconst uint obj_Jelly_InsideBlob     = 0x00000005u;\nconst uint obj_Jelly_TentaclePrisms = 0x00000006u;\nconst uint obj_mix                  = 0x00000007u;\n\n//---------\n// Structs\n//---------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Camera \n{\n    vec3 eye;\n    vec3 target;\t\t// the point the camera is focussed on\n    \n    vec3 right;\n    vec3 up;\n    vec3 forward;\n};\n\n//2D Cones of light for god rays\nstruct SunBeam\n{\n    vec2 origin;\n    vec2 dir;\n    float angle;\n};\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    uint objHit;\n};\n    \n// data type used to handle a repeated coordinate\nstruct RC\n{\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 p;\t\t// the repeated coordinate\n    //vec3 h;\t// half of the size of the cell\n    //vec3 c; \t// the center of the cell, world coordinates\n};\n\n//----------------\n// Camera Stuff\n//----------------\n\nCamera cam;\n\n//---------\n// Helpers\n//---------\n\nfloat remap(in float value, in float original_min, in float original_max, in float new_min, in float new_max)\n{\n\treturn new_min + ( ((value - original_min) / (original_max - original_min)) * (new_max - new_min) );\n}\n\nfloat luminance(vec3 color_rgb)\n{\n    const vec3 weight = vec3(0.2125, 0.7154, 0.0721); //Weighting according to human eye perception\n    return dot(color_rgb, weight);\n}\n\n//-----------------\n// Noises and FBMs\n//-----------------\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\n\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat noise(float x) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    float result = mix(hash(i), hash(i + 1.0), u);\n    result = remap( result, 0.0, 1.0, 0.25, 1.5);\n    return result*1.5;\n}\n\nfloat fbm(float x, float persistence) \n{\n    const float diffReductionFactor = -0.1;\n    const float shift = 100.0;\n    \n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\t\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) \n    {\n\t\tv += a * noise(x) + diffReductionFactor;\n\t\tx = x * 2.0 + shift;\n\t\ta *= persistence;\n\t}\n\treturn v;\n}\n\n// 1D height returned using 2D point\nfloat N1(vec2 p, float freq, float persistence, float scale)\n{\n    float coord = p.x*freq;// + iTime * 5.0;\n    float height = fbm(coord, persistence)*scale;\n    return height;\n}\n\nfloat N2(vec2 p, float scale) { return 0.5*noise(p.x*0.1)*scale; }\n\nfloat N3(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n    \n//------------\n// Operations\n//------------\n\n//-----------------------\n// Rotational Operations\n//-----------------------\n\n// All basic operations have to be done as their inverse operations because \n//we are taking the ray from world space into local space\n\n// ----- Rotations (CCW) -----\n//Rotation matrix to rotate about the X axis\nmat3 rotateX(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3( vec3(1, 0, 0 ),\n                 vec3(0, c, -s),\n                 vec3(0, s, c ) );\n}\n\n//Rotation matrix to rotate about the Y axis\nmat3 rotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3( vec3( c, 0, s),\n                 vec3( 0, 1, 0),\n                 vec3(-s, 0, c) );\n}\n\n//Rotation matrix to rotate about the Z axis\nmat3 rotateZ(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3( vec3(c, -s, 0),\n                 vec3(s,  c, 0),\n                 vec3(0,  0, 1) );\n}\n\n// ----- Axis Angle Rotation Matrix -----\nmat3 rotationAxisAngle(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );\n}\n\n// ----- Inverse of the rotation matrix -----\n//Could do the actual inverse but for rotation matrices, i.e orthogonal matrices that is the\n// same as the transpose, which for simple cases of rotating about the X,Y, or Z axes can be\n// calculated by just negating the angle\n// So inverse(rotateX(theta)) = rotateX(-theta)\n\nmat3 invRotateX(float theta) { return rotateX(-theta); }\n\nmat3 invRotateY(float theta) { return rotateY(-theta); }\n\nmat3 invRotateZ(float theta) { return rotateZ(-theta); }\n\nmat3 invRotAxisAngle(vec3 axis, float angle) { return inverse(rotationAxisAngle(axis, angle)); }\n\n// ----- Translate, Repeat -----\n\nvec3 translateOp(vec3 samplePoint, vec3 translation)  { return samplePoint + translation; }\n\nvec3 invTranslateOp(vec3 samplePoint, vec3 translation) { return samplePoint - translation; }\n\nvec3 repeatOp(vec3 samplePoint, vec3 center) { return (mod(samplePoint, center)-0.5*center); }\n\n// Polar Repeat function by Mercury\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*0.5;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*0.5;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions*0.5)) c = abs(c);\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval(inout float p, float size, float start, float stop) \n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) \n    { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) \n    {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nRC pModGrid(vec3 pos, vec3 size) \n{\n\tRC rc_out;\n    vec3 halfSize = size*0.5;\t\n    // rc_out.id is used to give a unique id to each cell so that we can move \n    // individual elements independent of the overall repeated structure\n    rc_out.id = floor((pos+halfSize)/size);\n    rc_out.p = mod(pos + halfSize, size) - halfSize;\n    //rc_out.c = floor((pos+halfSize)/size);\n    \n    return rc_out;\n}\n\n// ----- Miscellaneous -----\n\nfloat opDisplace( vec3 p, float sdf1, float freq, float scale )\n{\n    float displacement = sin(freq*p.x) * sin(freq*p.y) * sin(freq*p.z);\n    return sdf1 + displacement*scale;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 color, float k) \n{\n    return vec3(gain(color.x, k), gain(color.y, k), gain(color.z, k));\n}\n\n// ----- CSG -----\n\nfloat intersectSDF(float distA, float distB) { return max(distA, distB); }\n\nfloat unionSDF(float distA, float distB) { return min(distA, distB); }\n\nIntersection unionSDF(Intersection A, Intersection B, float k) \n{\n    float h = clamp( 0.5+0.5*(B.t-A.t)/k, 0.0, 1.0 );\n    \n    Intersection result;\n    result.objHit = obj_mix;\n    result.t = min(A.t, B.t);\n    result.color = mix(B.color, A.color, h );\n    return result;\n}\n\nfloat differenceSDF(float distA, float distB) { return max(distA, -distB); }\n\n// ----- Smooth Min -----\n\n// polynomial smin\n// Easy to control and fast\n// k maps directly to blending band distance\nfloat smin( float distA, float distB, float k )\n{\n    //k values close to 0.5 as starting point\n    float h = clamp( 0.5+0.5*(distB-distA)/k, 0.0, 1.0 );\n    return mix( distB, distA, h ) - k*h*(1.0-h);\n}\n\nIntersection smin( Intersection A, Intersection B, float k )\n{\n    Intersection result;\n    //k values close to 0.5 as starting point\n    float h = clamp( 0.5+0.5*(B.t-A.t)/k, 0.0, 1.0 );\n    result.t =  mix( B.t, A.t, h ) - k*h*(1.0-h);\n    \n    result.color = mix(B.color, A.color, h);\n    result.objHit = obj_mix;\n    \n    return result;\n}\n\nIntersection combine( Intersection A, Intersection B, float k )\n{\n    Intersection result;\n    //k values close to 0.5 as starting point\n    float h = clamp( 0.5+0.5*(B.t-A.t)/k, 0.0, 1.0 );\n    result.t =  min( B.t, A.t);\n    \n    result.color = mix(B.color, A.color, h);\n    result.objHit = obj_mix;\n    \n    return result;\n}\n\n//------------\n// Basic SDFs\n//------------\n    \n//sphere\nfloat sdSphere( vec3 p, float radius ) { return length(p)-radius; }\n\n//unsigned box\nfloat udBox( vec3 p, vec3 b ) { return length(max(abs(p)-b,0.0)); }\n\n//box\nfloat sdBox( vec3 p, vec3 boxDimensions )\n{\n\tvec3 d = abs(p) - boxDimensions;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    //r = radius\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n    //t = vec2( ring radius, ring thickness )\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//cone section\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    //h = height\n    //r1 = bottom radius;\n    //r2 = top radius;\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//capped cylinder\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//tri prism\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//-----------------\n// Post Proecesses\n//-----------------\n\nvec4 postProcess(in vec4 color, in vec2 uv)\n{\n    // --- vignette ---\n\tconst vec2 center = vec2(0.5,0.5);\n    const float outer = 1.2;\n    const float inner = 0.05;\n    vec2 temp = center - uv;\n    float dist = sqrt(temp.x*temp.x + temp.y*temp.y) * 1.414213;\n    float vig = clamp((outer - dist*dist)/(outer-inner), 0.0, 1.0); // can be dist, using dist*dist for a better vignette boundary\n\t// ---\n    return color*vig;\n}\n","name":"Common","description":"","type":"common"}]}