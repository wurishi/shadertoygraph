{"ver":"0.1","info":{"id":"MfGyRy","date":"1732009991","viewed":33,"name":"Insomniascope","username":"akr51","description":"Don't stare at it for too long","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Number of scene \"objects\"\n#define NSO 3\n// Iterations\n#define ITR 90\n// Max ray travel distance\n#define DST 90.0\n// Collision with surface  \n#define SRF 0.0001\n// 2D rotation which can be used in 3D by rotating\n// about plane. E.G xy is about z axis.\n#define RT(X) mat2(cos(X), -sin(X), sin(X), cos(X))\n// PI\n#define PI acos(-1.0)\n\nfloat t = 0.0;\nfloat g0 = 0.0;\nfloat g1 = 0.0;\nfloat g2 = 0.0;\n\nvec3 pal(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\n    return a + b * cos(PI * 2.0 * (c * t + d));\n\n}\n\nfloat box(vec3 sp, vec3 d)\n{\n\n\n    sp = abs(sp) - d;\n    return max(max(sp.y, sp.x), sp.z);\n\n\n}\n\n\nvec2 map(vec3 sp)\n{\n\n    float dst[NSO];\n    float id = 0.0;\n    \n    sp.xy *= RT(sp.z * (0.025 * (sin(t) * 0.5 + 0.5)));\n    \n    float b = box(abs(sp) - vec3(0, 1.5, 0), vec3(2, 1, 2));\n    \n    dst[0] = max(length(sp) - 2.0, -b);\n    vec3 spc = sp;\n    \n    for (int i = 0; i < 3; i++)\n    {\n    \n        spc = abs(spc) - vec3(4.7, 2, 0.8);\n        spc.xy *= RT(3.68);\n    \n    \n    }\n    \n    spc.xz *= RT(spc.y * 0.125 + t * 0.5);\n    dst[0] = min(dst[0], box(abs(spc) - vec3(1, 0, 1), vec3(0.1, 23.0, 0.1)));\n    \n    g0 += pow(0.1 / max(dst[0], 0.001), 3.0);\n    \n    for (int i = 0; i < 3; i++)\n    {\n    \n        sp = abs(sp) - vec3(6, 7, 3);\n        sp.xy *= RT(2.1);\n        \n    \n    }\n    \n    vec3 spw = sp;\n    spw.xz *= RT(spw.y * 0.5 + 1.7);\n    dst[1] = box(abs(spw) - vec3(3, 3, 3), vec3(7.0,0.25,0.5));\n    g1 += pow(0.1 / max(dst[1], 0.001), 3.0);\n    vec3 spk = sp;\n    spk.xz *= RT(t + PI * 0.5);\n    dst[2] = length(abs(spk) - vec3(10, 3, 3)) - 0.25;\n    g2 += pow(0.1 / max(dst[2], 0.001), 2.0);\n    \n    for (int i = 1; i < NSO; i++)\n    {\n    \n        if (dst[i] < dst[0])\n        {\n        \n            dst[0] = dst[i];\n            id = float(i);\n            \n        }\n    \n    }\n    return vec2(dst[0] * 0.5, id);\n}\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n        \n        vec3 sp = ro + rd * d0;\n        vec2 ds = map(sp);\n        if (d0 > DST || abs(ds.x) < SRF) break;\n        d0 += ds.x;\n        id = ds.y;\n\n\n    }\n    \n    if (d0 > DST) d0 = 0.0;\n    return vec2(d0, id);\n}\n\n\nvoid mainImage(out vec4 c_out, in vec2 uu)\n{\n    vec2 rr = iResolution.xy;\n    vec2 uv = (uu + uu - rr) / rr.y;\n    \n    vec3 a = vec3(0.25, 0.25, 0.25);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0) * 0.1;\n    vec3 f = vec3(0.15, 0.5, 1.67);\n    \n    t = mod(iTime, PI * 10.0);\n \n    vec3 clr = vec3(0);\n    // camera\n    vec3 ro = vec3(cos(t) * 3.0, 0, sin(t) * 2.0 - 23.0);\n    vec3 w = normalize(vec3(0) - ro);\n    vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(mat3(u, v, w) * vec3(uv, 0.5));\n    // light position\n    vec3 lp = vec3(0, 0.5, -4.0);\n    // color of scene objects\n   \n    // march scene\n    vec2 sc = mrch(ro, rd);\n    // distance to scene object\n    float d = sc.x;\n    // scene object id\n    int id = int(sc.y);\n    \n    clr += g0 * pal(a, b, c, f, length(uv) + t) + g1 * pal(a, b, c, f, length(uv) + t * 0.5) + g2;\n    \n    c_out = vec4(pow(clr, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}