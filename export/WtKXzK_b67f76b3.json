{"ver":"0.1","info":{"id":"WtKXzK","date":"1583141706","viewed":229,"name":"DrunkFog","username":"ddorn","description":"Sea of oil creating while trying to create fog.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","waves","oil","fractalnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/// Return a determistic random value between 0 and 1.\n/// This function was taken from The Book of Shaders.\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n/// Return a vec2 in the unit sphere\nvec2 random2(vec2 st){\n    float a = random(st) * 6.1831;\n    return vec2(cos(a), sin(a));\n}\n\n\nvec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.1547*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n\n\n/// Return a random value in [0,1]. This function is continuous.\nfloat noise(vec2 st) {\n\n    st = skew(st);\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    // A random gradient for each corner of the simplex\n    vec2 op = (f.y >= f.x) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 a = random2(i);\n    vec2 b = random2(i + op);\n    vec2 c = random2(i + vec2(1.0, 1.0));\n\n    // Dot pruduct between the random gradient and\n    // the vecteur comming from the corner\n    vec3 t = vec3(\n        dot(a, (f)),\n        dot(b, (f - op)),\n        dot(c, (f - 1.))\n    );\n\n    if (u.y >= u.x) {\n        u = u.yx;\n    }\n\n    // Barycentric coordinates according to\n    // https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\n    vec3 l = vec3(1. - u.x, u.x - u.y, u.y);\n    float r = dot(t, l);\n    return .5*r + 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ratio =  iResolution.xy/iResolution.yx;\n    \n    vec2 pos = fragCoord.xy / iResolution.xy * iResolution.x / 1000.;\n    vec2 dp = vec2(-.5, 1.) * iTime / 3.;\n    pos *= 4.;\n    pos += dp;\n    //pos = (pos - 0.25) * (iMouse.y / iResolution.y * 9. + 1.) + dp;\n    \n    float c1 = 10.;\n    float c2 = 5.;\n    vec2 d1 = vec2(1) * iTime / 2. ;\n    float d2 = iTime / 10.;\n\n    float f = noise(pos.yx + d1 + c1 * noise(pos + d2 + c2 * noise(pos)));\n\n    vec3 a = vec3(0.0);\n    vec3 b = vec3(0.3, 0.1, 0.2);\n    vec3 c = vec3(0.22, 0.741, 0.616);\n    vec3 d = vec3(0.965, 0.971, 0.349);\n\n    vec3 p = vec3(0.4, 0.6, 0.7);\n\n\tvec3 color;\n    if (f < p.x) {\n        color = mix(a, b, f);\n    } else if (f < p.y) {\n        color = mix(b, c, smoothstep(p.x, p.y, f));\n    } else {\n        color = mix(c, d, smoothstep(p.y, p.z, f));\n    }\n\n    fragColor = vec4(color, 1.) ;\n}\n\n","name":"Image","description":"","type":"image"}]}