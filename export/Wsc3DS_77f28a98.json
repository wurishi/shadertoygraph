{"ver":"0.1","info":{"id":"Wsc3DS","date":"1569353481","viewed":328,"name":"Flame producing structure","username":"TambakoJaguar","description":"I've been inspired by an image I created with POVRay in 1997 for a flyer and wanted to recreate it with Shadertoy!\nUse mouse to move around","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","mouse","sunset","flame","fire","light","sky","shadows","animated","hot","metallic","structure","installation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Flame producing structure\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n#define shadow\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 8;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.35;\n\n// Specular options\nconst float specint = 0.36;\nconst float specshin = 25.;\n\n// Shadow options\nconst float shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0001;\nconst float maxdist = 50.;\nconst int nbref = 2;\n\n// Color options\nconst float gamma = 1.75;\nconst vec3 structure_color = vec3(0.98, 0.8, 0.6);\nconst vec3 structure_color2 = vec3(0.7, 0.9, 0.65);\nconst vec3 floor_color = vec3(0.5, 0.65, 0.2);\nconst float structureRef = 0.8;\n\n// Geometry options\nconst float r1 = 0.1;\nconst float r2 = 0.3;\nconst float r3 = 0.75;\nconst float h = 1.;\nconst float e = 1.75;\nconst float l = 0.2;\nconst float f1 = 1.18;\nconst float f2 = 1.088;\nconst float ng = 12.;\nconst float gd = 0.07;\nconst float sf = 250.;\nconst float sa = 0.02;\n\n// Flame parameters\nconst float fcp = 1.5;\nconst vec3 flameColor = vec3(1., 0.6, 0.22);\nconst float flameIntensity = 0.7;\nconst float flameIntensity2 = 0.5;\nconst float flameStep = 0.02;\nconst float flamePow = 2.5;\nconst float flameBias = 0.;\nconst float dnf = -0.85;\nconst float dnx = -0.25;\nconst float dns = -21.;\nconst float fts = 7.5;\nconst float ftf = 1.1;\nfloat ft;\n\n// Campera options\nvec3 campos = vec3(0., 0., 10.);\nvec3 camtarget = vec3(0., 1.4, 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 4.2;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define FLOOR_OBJ       1\n#define STRUCTURE_OBJ   2\n#define FLAME_OBJ       3\n    \nLamp lamps[3];\n\nint aai;\nint aaj;\n\nfloat flameVar;\n\nvoid init()\n{    \n    lamps[0] = Lamp(vec3(30., 70., .0), vec3(0.5, 0.7, 1.), 1.3, 0.01);\n    lamps[1] = Lamp(vec3(10., 40., -100.), vec3(1., 0.7, 0.1), 3.8, 0.01);\n    lamps[2] = Lamp(vec3(0., h*2. + r2, 0.), flameColor, 0.5, 0.01);\n    \n    // Power of the flame in function of the time\n    flameVar = sin(iTime*0.55) + 0.56*sin(iTime*0.134) + 0.22*sin(iTime*0.095);\n    \n    ft = iTime*dns;\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat2 m = mat2(1.1,  1., -1.,  1.1);\nfloat fbm(vec3 n)\n{\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn.xy = m * n.xy;\n        n.yz = m * n.yz;\n        n.zx = m * n.zx;\n\t\tamplitude *= 0.8;\n\t}\n\treturn total;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat map_floor(vec3 pos)\n{\n   return pos.y;\n}\n\nfloat map_structure(vec3 pos)\n{\n   pos.x = abs(pos.x);\n    \n   float a = atan(pos.x - e, pos.z); \n   float r1b = r1*(1. - gd*smoothstep(-0.7, 1., sin(a*ng))*smoothstep(1.95*h, 1.8*h, pos.y));\n   float c = sdCylinder(pos - vec3(e, h, 0.), vec2(r1b, h*1.0));\n   float t = max(-pos.y + h*2., max(-pos.x + e - r2, sdTorus(pos.xzy - vec3(e - r2, 0., h*2.), vec2(r2, r1))));\n   c = min(c, t);\n   c = min(c, sdCylinder(pos.yxz - vec3(h*2. + r2, e - r2 - l, 0.), vec2(r1, l)));\n   float r2b = r2*(1. + sa*sin(pos.x*sf)*smoothstep(e - r2 - l - r2*0.85, e - r2 - l - r2*0.65, pos.x));\n   c = smin(c, length(pos - vec3(e - r2 - l - r3, h*2. + r2b, 0.)) - r3, 0.15);\n   c = smax(c, -length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) + r3*f2, 0.06);\n   c = max(c, -pos.x + e - r2 - l - r3*0.35);\n       \n   return c;\n}\n\nfloat map_flame(vec3 pos, bool turb)\n{\n   vec3 pos0 = pos;    \n    \n   if (turb)\n   {\n      vec3 q = pos*fts;       \n       \n      float n = 0.1*noise(q*1.9);\n      q.xy = rotateVec(-q.xy, pos.z*n);\n      q.yz = rotateVec(-q.yz, pos.x*n);\n      q.zx = rotateVec(-q.zx, pos.y*n);\n        \n      q*= vec3(1., 1.5, 1.);\n      q+= vec3(ft, 0., 0.);\n      q.x+= 0.5*pos.x*noise(q + vec3(30., 40., 50. + ft));\n      q.y+= 0.5*pos.x*noise(q + vec3(10., 30. + ft, 20.));\n      q.z+= 0.5*pos.x*noise(q + vec3(20., 60. - ft, 40. - ft));\n \n      float dn = dnf;\n      pos.x+= dn*noise(q + vec3(12., 3.+ ft, 16. - ft)) - dn/2.;\n      pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;\n      pos.z+= dn*noise(q + vec3(8. + ft*0.3, 22., 9.)) - dn/2.;\n   }\n   pos.x = abs(pos.x);\n    \n   float c = length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) - r3*f2;\n   c = min(c, length(pos - vec3(0., h*2. + r2, 0.)) - r3*1.35);\n   c = max(c, sdCylinder(pos.yxz - vec3(h*2. + r2, 0., 0.), vec2((turb?0.45:0.58) + 0.32*cos(pos.x*pi/e), e)));\n    \n   if (turb)\n   {\n     c = mix (c, 0.3*c -0.9*smoothstep(0.7, 0.3, length(pos0.yz - vec2(h*2. + r2, 0.))), smoothstep(e - r2 - l - 1.3, e - r2 - l, -pos0.x));\n     c*= (1. + 0.6*smoothstep(e - r2 - l - 1., e - r2 - l, pos0.x)); \n   }\n   return c;\n}\n\nfloat map_flame_s(vec3 pos)\n{\n   vec3 pos0 = pos;    \n    \n   vec3 q = pos*0.6;\n   q*= vec3(1., 1.5, 1.);\n   q+= vec3(ft, 0., 0.);\n   float dn = 0.5*(dnf - dnx*pos.x);\n   pos.x+= dn*noise(q + vec3(12., 3. + ft, 16.)) - dn/2.;\n   pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;\n   pos.z+= dn*noise(q + vec3(8., 22., 9.)) - dn/2.;\n   \n   pos.x = abs(pos.x);\n    \n   float c = length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) - r3*f2;\n   c = min(c, length(pos - vec3(0., h*2. + r2, 0.)) - r3*1.35);\n   c = max(c, sdCylinder(pos.yxz - vec3(h*2. + r2, 0., 0.), vec2(0.58 + 0.32*cos(pos.x*pi/e), e)));\n\n   c = mix (c, 0.6*c -0.3*smoothstep(0.7, 0.3, length(pos0.yz - vec2(h*2. + r2, 0.))), smoothstep(e - r2 - l - 1.2, e - r2 - l, -pos0.x)); \n    \n   return c;\n}\n\nvec2 map(vec3 pos, bool flame)\n{\n    float floor = map_floor(pos);\n    vec2 res = vec2(floor, FLOOR_OBJ);\n    \n    float structure = map_structure(pos);\n    res = opU(res, vec2(structure, STRUCTURE_OBJ)); \n    \n    if (flame)\n    {\n       float flame = map_flame(pos, false);\n       res = opU(res, vec2(flame, FLAME_OBJ));\n    }\n    \n    return res;\n}\n\n// Gets the color of the flame depending on the position and ray direction by volume sampling\nvec3 getFlameDensColor(vec3 pos, vec3 ray, float s, float fi, int nbSteps)\n{\n    float d = 1.;\n    float f;\n    vec3 scol = vec3(0.);\n    for (int i=0; i<nbSteps; i++)\n    {\n        pos+= ray*s;\n        f = -map_flame(pos, true);\n        f = sign(f)*pow(abs(f), flamePow);\n    \td = clamp(f + flameBias, 0., 1.);\n        scol+= flameIntensity2*d*flameColor;\n    }\n    \n    return clamp(scol*fi, 0., 1.5);\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool flame) \n{\n    float t = 0.08;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 140; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, flame);\n        dist = res.x;\n        objnr = abs(res.y);        \n        if (dist>maxdist || abs(dist)<(int(objnr)==FLAME_OBJ?0.03:0.0001))\n            break;\n        t+= dist*0.95;\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2, false).x;\n    }\n    return normalize(n);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<30; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, false).x;\n        res = min( res, 27.0*h/t );\n        t += clamp( h, 0., 0.80 );\n        if( res<0.0005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    vec3 col = mix(vec3(1.1, 0.8, 0.), vec3(0.2, 0.4, 0.7), clamp(1.1*ray.y + 0.5*ray.z, 0., 1.));\n    col*= 1.+ 0.4*smoothstep(0.5, 0., pow(clamp(0.7*ray.y + 2.2*ray.z + 2.3, 0., 1.), 1.1));\n    col.b+= smoothstep(0.5, 0., pow(clamp(0.7*ray.y + 2.2*ray.z + 2.25, 0., 1.), 0.7));\n    \n    return col;\n}\n\nfloat mm;\nfloat gg;\nvec3 getStructureColor(vec3 pos)\n{\n   pos.x = abs(pos.x);\n   mm = (length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)));\n   gg = pos.y>2.*h?0.:smoothstep((1. - 0.1*gd)*r1, (1. - 0.8*gd)*r1, length(pos.xz - vec2(e, 0.)));\n   gg+= smoothstep(0.83, 0.815, mm);\n       \n   vec3 col = mix(structure_color, structure_color2, gg);\n   col*= smoothstep(0.813, 0.824, mm);\n   float fb = fbm(pos);\n   col = mix(structure_color2*0.5, col, 0.5 + 0.5*gg + 0.5*(1. - gg)*(1. - smoothstep(0.155, 0.16, fb) + smoothstep(0.16, 0.165, fb)));\n   return col;\n}\n\nfloat getStructureRef(vec3 pos)\n{\n   pos.x = abs(pos.x);\n   float rf = pos.y>2.*h?1.:smoothstep((1. - 1.3*gd)*r1, (1. - 0.1*gd)*r1, length(pos.xz - vec2(e, 0.)));\n   rf*= smoothstep(0.815, 0.824, mm);\n   float fb = fbm(pos);\n   rf*= 0.5 + 0.5*(1. - gg)*(1. - smoothstep(0.155, 0.16, fb) + smoothstep(0.16, 0.165, fb));    \n   return rf*structureRef;\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==FLOOR_OBJ)\n      return floor_color;   \n   else if (objnr==STRUCTURE_OBJ)\n      return getStructureColor(pos);\n   else\n      return getSkyColor(ray);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    if (lampnr==2)\n    {\n        if (objnr==FLOOR_OBJ)\n            lamp.position.x = pos.x*0.25;\n        lamp.intensity = 0.9*(1. + 0.3*flameVar)*smoothstep(0., 2.2, 2.8/(map_flame_s(pos) - 0.4) - 0.45); //*smoothstep(e + 1.8, e + 1., abs(pos.x));\n    }    \n    \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.78, 0.83);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm);\n\n   camdir = camtarget - campos;   \n}\n\n// Combine the flame color with its background in a non-linear way\nvec3 combFlameCol(vec3 col1, vec3 col2)\n{\n    return pow(pow(col1, vec3(fcp)) + pow(clamp(col2, 0., 1.), vec3(fcp)), vec3(1./fcp));   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool flame)\n{\n    vec2 tr = trace(tpos, ray, maxdist, flame);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist, true);\n  \tvec3 col = traceinf.col;\n    vec3 startpos = campos;\n    \n    vec3 flamecol;\n    float flameIntensityV = flameIntensity*(1. + 0.37*flameVar);    \n    \n    #ifdef reflections\n    vec3 rf = vec3(1.);\n    for (int r=0; r<nbref; r++)\n    {\n       flamecol = vec3(0.);\n       if (traceinf.objnr==STRUCTURE_OBJ)\n       {           \n          rf*= getStructureRef(traceinf.pos);\n          vec3 refray = reflect(ray, traceinf.norm);\n        \n          traceinf = trace0(traceinf.pos, refray, maxdist, true);\n          col = mix(col, structure_color*traceinf.col, rf);\n\n          rf*= structure_color;\n          ray = refray;\n       }\n       else if (traceinf.objnr==FLAME_OBJ)\n       {\n          flamecol = getFlameDensColor(traceinf.pos, ray, flameStep, flameIntensityV, 70);\n          traceinf = trace0(startpos, ray, maxdist, false);\n          col = traceinf.col;\n       }\n       startpos = traceinf.pos;        \n       col = combFlameCol(col, flamecol);\n    }\n    #endif\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"}]}