{"ver":"0.1","info":{"id":"fs2cWt","date":"1644335504","viewed":114,"name":"voxels signed distance field 2d","username":"PrenexNormalForm","description":"signed distance field sufficient for raymarching a voxel grid (max distance 1.0 units)\n\ntodo: dist>1.0 units","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//now branchless!\n\n// rand function https://www.shadertoy.com/view/Xt23Ry\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nbool isVoxel(vec2 pos);\n\nfloat signedDist(vec2 pos) {\n    vec2 up = pos + vec2(0.0, 1.0);\n    vec2 down = pos + vec2(0.0, -1.0);\n    vec2 left = pos + vec2(-1.0, 0.0);\n    vec2 right = pos + vec2(1.0, 0.0);\n    vec2 upleft = pos + vec2(-1.0, 1.0);\n    vec2 upright = pos + vec2(1.0);\n    vec2 downright = pos + vec2(1.0, -1.0);\n    vec2 downleft = pos + vec2(-1.0);\n    bool isVox = isVoxel(pos);\n    \n    //determine adjacent boundaries\n    float upb = float(isVox ^^ isVoxel(up));\n    float downb = float(isVox ^^ isVoxel(down));\n    float leftb = float(isVox ^^ isVoxel(left));\n    float rightb = float(isVox ^^ isVoxel(right));\n    float upleftb = float(isVox ^^ isVoxel(upleft));\n    float uprightb = float(isVox ^^ isVoxel(upright));\n    float downrightb = float(isVox ^^ isVoxel(downright));\n    float downleftb = float(isVox ^^ isVoxel(downleft));\n    \n    //are you ready for the headache of 3 dimensions?\n    //just be thankful we aren't 4 dimensional beings\n    float dist = 1.0 - upb + upb * (1.0 - mod(pos.y, 1.0));\n    dist = min(dist, 1.0 - downb + downb * mod(pos.y, 1.0));\n    dist = min(dist, 1.0 - leftb + leftb * mod(pos.x, 1.0));\n    dist = min(dist, 1.0 - rightb + rightb * (1.0 - mod(pos.x, 1.0)));\n    dist = min(dist, 1.0 - upleftb + upleftb * length(vec2(0.0, 1.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - uprightb + uprightb * length(vec2(1.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - downrightb + downrightb * length(vec2(1.0, 0.0) - mod(pos, 1.0)));\n    dist = min(dist, 1.0 - downleftb + downleftb * length(mod(pos, 1.0)));\n    dist *= 1.0 - 2.0 * float(isVox);\n    \n    return dist;\n    \n    /*\n    float dist = 1.0\n    if (isVox) {\n        //dist = min(fract(pos.x), 1.0 - fract(pos.x));\n        //dist = min(dist, min(fract(pos.y), 1.0 - fract(pos.y)));\n        //dist *= -1.0;\n        dist = -1.0;\n        if (!isVoxel(up))\n            dist = -1.0 + mod(pos.y, 1.0);\n        if (!isVoxel(down))\n            dist = max(dist, -mod(pos.y, 1.0));\n        if (!isVoxel(left))\n            dist = max(dist, -mod(pos.x, 1.0));\n        if (!isVoxel(right))\n            dist = max(dist, -1.0 + mod(pos.x, 1.0));\n        if (!isVoxel(upleft))\n            dist = max(dist, -length(vec2(0.0, 1.0) - mod(pos, 1.0)));\n        if (!isVoxel(upright))\n            dist = max(dist, -length(vec2(1.0) - mod(pos, 1.0)));\n        if (!isVoxel(downright))\n            dist = max(dist, -length(vec2(1.0, 0.0) - mod(pos, 1.0)));\n        if (!isVoxel(downleft))\n            dist = max(dist, -length(mod(pos, 1.0)));\n    } else {\n        if (isVoxel(up))\n            dist = 1.0 - mod(pos.y, 1.0);\n        if (isVoxel(down))\n            dist = min(dist, mod(pos.y, 1.0));\n        if (isVoxel(left))\n            dist = min(dist, mod(pos.x, 1.0));\n        if (isVoxel(right))\n            dist = min(dist, 1.0 - mod(pos.x, 1.0));\n        if (isVoxel(upleft))\n            dist = min(dist, length(vec2(0.0, 1.0) - mod(pos, 1.0)));\n        if (isVoxel(upright))\n            dist = min(dist, length(vec2(1.0) - mod(pos, 1.0)));\n        if (isVoxel(downright))\n            dist = min(dist, length(vec2(1.0, 0.0) - mod(pos, 1.0)));\n        if (isVoxel(downleft))\n            dist = min(dist, length(mod(pos, 1.0)));\n    }*/\n}\n\nbool isVoxel(vec2 pos) {\n    pos = floor(pos);    \n    return rand(pos) < 0.45;\n}\n\nvec3 distColor(float dist) {\n    float stepWidth = fwidth(dist);\n//    float farStep = smoothstep(0.999 - stepWidth, 1.0, dist);\n    float nearStep = smoothstep(0.0, stepWidth, dist);// - farStep;\n    float negStep = 1.0 - smoothstep(-0.1, -0.1 + stepWidth, dist);\n    float borderStep = 1.0 - negStep - nearStep;// - farStep;\n    \n//    vec3 color = farStep * vec3(0.0, 1.0, 1.0)\n      vec3 color = nearStep * vec3(0.0, vec2(1.0 - 0.5 * dist))\n               + negStep * -dist\n               //+ borderStep * vec3(0.6, 0.0, 0.7)\n               ;\n    \n//    vec3 color = vec3(0.6, 0.0, 0.7);\n//    if (dist < -0.1) {\n//        color = vec3(-dist);\n//    } else if (dist > 0.0) {\n//        color = vec3(1.0 - mod(dist, 1.0) * 0.5);\n//        color.x = 0.0;\n//    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float viewportWidth = max(iResolution.x, iResolution.y);\n    float viewportScale = 32.0;\n    vec2 initialCameraPos = vec2(-30);\n    float speed = 2.0;\n    vec2 offset = speed * (iTime + 0.0) + initialCameraPos;\n    vec2 pos = (fragCoord) / vec2(viewportWidth) * viewportScale + offset;\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(distColor(signedDist(pos))),1.0);\n}","name":"Image","description":"","type":"image"}]}