{"ver":"0.1","info":{"id":"lfBGWh","date":"1704524792","viewed":39,"name":"simple ray-marched scene","username":"soggymongoose","description":"feel free to comment on my implementation of the algorithms, lighting, etc. I'm not sure how to define different materials for the plane and cube. I used resources from IQ's website","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Rot2D(vec2 p, float theta) {\n    return vec2(p.x * cos(theta) - p.y * sin(theta),p.x * sin(theta) + p.y * cos(theta));\n}\n\nfloat SphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat CubeSDF( vec3 p, float s, vec3 pos)\n{\n    p -= pos;\n    p.xzy = vec3(Rot2D(p.xz,iTime),p.y);\n    vec3 uv = abs(p);\n    \n    return length(max(uv-vec3(s),vec3(0.)));\n}\n\nfloat PlaneSDF(vec3 p, float h) {\n    return p.y - h;\n}\n\n\nfloat map(vec3 p) {\n    float map;\n    \n    float t = iTime * .3;\n    float h = -1.;\n    h += sin(.32*(p.x+t))*cos(.55*(p.z+t))*1.;\n    h += sin(1.32*(p.x+t))*cos(2.65*(p.z+t))*.25;\n    h += sin(5.52*(p.x+t))*cos(7.65*(p.z+t))*.1;\n    h += sin(11.92*(p.x+t))*cos(13.85*(p.z+t))*.05;\n    \n    map = CubeSDF(p,.4,vec3(cos(iTime)*2.,sin(iTime)+3.,1.)) - .2;\n    map = min(map, PlaneSDF(p,h));\n    \n    return map;\n}\n\n\nvec3 Calc_Norm(vec3 p) {\n        vec2 e = vec2(.001,.0);\n        \n        float dx = map(p+e.xyy) - map(p-e.xyy);\n        float dy = map(p+e.yxy) - map(p-e.yxy);\n        float dz = map(p+e.yyx) - map(p-e.yyx);\n        \n        return normalize(vec3(dx,dy,dz));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 150; i++) {\n        vec3 p = ro + rd * t; // position along the ray \n    \n        float d = map(p); // distance from scene\n    \n        t += d * .5; // march the ray - lowering d to fix artifacts\n        \n        if ((d < .001) || (t > 100.0)) break; // break loop early\n        \n        \n    }\n    return t;\n}\n\nfloat Calc_occ(vec3 p, vec3 vec_dir) {\n    float check;\n    \n    vec3 offs = p + vec3(.001);\n    \n    p += Calc_Norm(p) * .005;\n    float d = rayMarch(p,-1.*vec_dir);\n    \n    if (d > 100.) {check = 1.;} else {check = 0.;}\n    \n    //check = \n    \n    return check;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.0;\n\n    // define virtual camera and initialize\n    vec3 ro = vec3(0.0, 3, -4.0); // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    \n    vec3 col = vec3(0.0); // final rgb of scene\n\n    float d = rayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d;\n    vec3 nor = Calc_Norm(p);\n    \n    if (d > 100.) nor = vec3(0.,0.,1.);\n    \n    // Materials\n    vec3 Mat = vec3(.6,.5,.5) ;\n    //Mat *= nor * .5 + .5;\n    \n    // Lighting terms - shadows/occulsion could be better but not sure how\n    vec3 sun_dir = normalize(vec3(-1.,-1.5,1.5));\n    \n    float ambi = .25;\n    float bounce = pow(max(dot(nor.y,-1.),0.),1.5);\n    float sun = max(dot(nor,-1.*sun_dir),0.) * Calc_occ(p,sun_dir);\n    float sky = max(dot(nor.y,1.),0.) * Calc_occ(p,vec3(0,-1.,.0));\n    \n    vec3 sun_col = vec3(.8,.8,.6);\n    vec3 sky_col = vec3(.6,.8,.9);\n    vec3 ambi_col = vec3(.6,.8,.9);\n    \n    vec3 ilu = vec3(0.);\n    ilu += sun * sun_col;\n    ilu += sky * sky_col * .8;\n    ilu += ambi * ambi_col;\n    ilu += ilu * bounce;\n    \n    // Apply light to Materials\n    col = Mat * ilu;\n    \n    // add fog and sky - not sure how to fix banding\n    sky_col = mix(vec3(.3,.6,.8),vec3(.7,.8,.9),smoothstep(40.,-10.,p.y));\n    col = mix(col,sky_col,smoothstep(30.,80.,d));\n    \n    col = pow( col, vec3(1.0/2.2) ); // gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}