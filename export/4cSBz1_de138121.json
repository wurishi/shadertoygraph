{"ver":"0.1","info":{"id":"4cSBz1","date":"1726263809","viewed":13,"name":"Between Order and Chaos","username":"Chromaney","description":"A shader born out of desire to try something CA/WFC-inspired. But then it took on a life of its own, lol.\nCreates a picture with moving parts of chaotic colors and orderly gradients.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader \"Between Order and Chaos\" by Chromaney.\n// Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A shader born out of desire to try something CA/WFC-inspired.\n// But then it took on a life of its own, lol.\n// Uses classic \"noise -> memory buffer -> output processing\" pipeline.\n// This time - for a picture with moving parts of chaotic colors and orderly gradients.\n// Commented out code lines are alternative/early versions of certain parts.\n\n// --------------------------------\n\n// Main image buffer.\n\nvec3 palette(float c, float d, float t){\n    c = clamp(c, 0.0, 1.0);\n    c = pow(c, 1.0 + 0.75 * cos(M_PI * d));\n    \n    vec3 col1 = vec3(0.10, 0.40, 0.20);\n    vec3 col2 = vec3(0.20, 0.60, 0.60);\n    vec3 col3 = vec3(0.66, 1.00, 1.00);\n    float pos2 = 0.65;\n    \n    t *= 2.0 * M_PI;\n    float colCoeff = 0.85 + 0.15 * cos(t);\n    col1 *= colCoeff;\n    col2 *= colCoeff;\n    col3 *= colCoeff;\n    \n    float c12 = c / pos2;\n    float c23 = (c - pos2) / (1.0 - pos2);\n    vec3 col = (c12 <= 1.0) ? mix(col1, col2, c12) : mix(col2, col3, c23);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 data = texture(iChannel0, uv).rgb;\n    float bloom = data.b;\n    vec2 modifCoord = uv;\n    vec2 bloomGrad = vec2(dFdx(bloom), dFdy(bloom));\n    if (length(bloomGrad) > 0.0){\n        modifCoord += 0.03 * bloom * normalize(bloomGrad);\n    }\n    vec3 dataM = texture(iChannel0, modifCoord).rgb; // ! data or dataM?\n    \n    vec3 col = palette(dataM.r, data.b, iTime * 0.07 + 0.3); // shift to better align palette for 10 s\n    col *= min(iTime * 0.3, 1.0);\n    float gamma = 1.0; // no gamma corr. - colors selected w/o it\n    fragColor = vec4(pow(col, vec3(1.0 / gamma)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926536\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 3D Perlin noise buffer.\n\nvec3 hash3to3(vec3 coord){\n    uint k = 835171995U;\n    uvec3 res = uvec3(coord) + k;\n    \n    res = (res.zxy * k + res.yzx) ^ res.z;\n    res = (res.zxy * k + res.yzx) ^ res.y;\n    res = (res.zxy * k + res.yzx) ^ res.x;\n    \n    return (vec3(res.xyz) / float(0xffffffffU));\n}\n\nvec3 blendFcn(vec3 t){\n    return (t * t * t * (t * (t * 6.0 - 15.0) + 10.0));\n}\n\nfloat perlinNoise(vec3 coord, float scale){\n    vec3 intCoord = floor(coord);\n    vec3 fracCoord = fract(coord);\n    vec3 blendVals = blendFcn(fracCoord);\n    \n    vec3 intCoordPlus = intCoord + vec3(1.0, 1.0, 1.0);\n    vec3 modVec = vec3(scale);\n    intCoord = mod(intCoord, modVec);\n    intCoordPlus = mod(intCoordPlus, modVec);\n    \n    vec2 r000 = hash3to3(vec3(intCoord.x,     intCoord.y,     intCoord.z    )).xy;\n    vec2 r001 = hash3to3(vec3(intCoord.x,     intCoord.y,     intCoordPlus.z)).xy;\n    vec2 r010 = hash3to3(vec3(intCoord.x,     intCoordPlus.y, intCoord.z    )).xy;\n    vec2 r011 = hash3to3(vec3(intCoord.x,     intCoordPlus.y, intCoordPlus.z)).xy;\n    vec2 r100 = hash3to3(vec3(intCoordPlus.x, intCoord.y,     intCoord.z    )).xy;\n    vec2 r101 = hash3to3(vec3(intCoordPlus.x, intCoord.y,     intCoordPlus.z)).xy;\n    vec2 r110 = hash3to3(vec3(intCoordPlus.x, intCoordPlus.y, intCoord.z    )).xy;\n    vec2 r111 = hash3to3(vec3(intCoordPlus.x, intCoordPlus.y, intCoordPlus.z)).xy;\n    \n    r000 = vec2((r000.x - 0.5) * M_PI, r000.y * 2.0 * M_PI);\n    r001 = vec2((r001.x - 0.5) * M_PI, r001.y * 2.0 * M_PI);\n    r010 = vec2((r010.x - 0.5) * M_PI, r010.y * 2.0 * M_PI);\n    r011 = vec2((r011.x - 0.5) * M_PI, r011.y * 2.0 * M_PI);\n    r100 = vec2((r100.x - 0.5) * M_PI, r100.y * 2.0 * M_PI);\n    r101 = vec2((r101.x - 0.5) * M_PI, r101.y * 2.0 * M_PI);\n    r110 = vec2((r110.x - 0.5) * M_PI, r110.y * 2.0 * M_PI);\n    r111 = vec2((r111.x - 0.5) * M_PI, r111.y * 2.0 * M_PI);\n    \n    vec3 grad000 = vec3(cos(r000.x) * cos(r000.y), sin(r000.x), cos(r000.x) * sin(r000.y));\n    vec3 grad001 = vec3(cos(r001.x) * cos(r001.y), sin(r001.x), cos(r001.x) * sin(r001.y));\n    vec3 grad010 = vec3(cos(r010.x) * cos(r010.y), sin(r010.x), cos(r010.x) * sin(r010.y));\n    vec3 grad011 = vec3(cos(r011.x) * cos(r011.y), sin(r011.x), cos(r011.x) * sin(r011.y));\n    vec3 grad100 = vec3(cos(r100.x) * cos(r100.y), sin(r100.x), cos(r100.x) * sin(r100.y));\n    vec3 grad101 = vec3(cos(r101.x) * cos(r101.y), sin(r101.x), cos(r101.x) * sin(r101.y));\n    vec3 grad110 = vec3(cos(r110.x) * cos(r110.y), sin(r110.x), cos(r110.x) * sin(r110.y));\n    vec3 grad111 = vec3(cos(r111.x) * cos(r111.y), sin(r111.x), cos(r111.x) * sin(r111.y));\n    \n    vec3 dir000 = fracCoord - vec3(0.0, 0.0, 0.0);\n    vec3 dir001 = fracCoord - vec3(0.0, 0.0, 1.0);\n    vec3 dir010 = fracCoord - vec3(0.0, 1.0, 0.0);\n    vec3 dir011 = fracCoord - vec3(0.0, 1.0, 1.0);\n    vec3 dir100 = fracCoord - vec3(1.0, 0.0, 0.0);\n    vec3 dir101 = fracCoord - vec3(1.0, 0.0, 1.0);\n    vec3 dir110 = fracCoord - vec3(1.0, 1.0, 0.0);\n    vec3 dir111 = fracCoord - vec3(1.0, 1.0, 1.0);\n    \n    float val000 = dot(grad000, dir000);\n    float val001 = dot(grad001, dir001);\n    float val010 = dot(grad010, dir010);\n    float val011 = dot(grad011, dir011);\n    float val100 = dot(grad100, dir100);\n    float val101 = dot(grad101, dir101);\n    float val110 = dot(grad110, dir110);\n    float val111 = dot(grad111, dir111);\n    \n    float k_1 = val000;\n    float k_x = val100 - val000;\n    float k_y = val010 - val000;\n    float k_z = val001 - val000;\n    float k_xy = val110 - val100 - val010 + val000;\n    float k_xz = val101 - val100 - val001 + val000;\n    float k_yz = val011 - val010 - val001 + val000;\n    float k_xyz = val111 - val110 - val101 - val011 + val100 + val010 + val001 - val000;\n    \n    float val = 1.0 * k_1 + blendVals.x * k_x + blendVals.y * k_y + blendVals.z * k_z + \n        blendVals.x * blendVals.y * k_xy + blendVals.x * blendVals.z * k_xz + \n            blendVals.y * blendVals.z * k_yz + \n        blendVals.x * blendVals.y * blendVals.z * k_xyz;\n    \n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    float baseLenScale = 128.0;\n    float amplScale = 1.0;\n    vec3 sampleCoord = vec3(uv, iTime * 0.03178);\n    float distScale = 1.0;\n    \n    for (int i = 0; i < int(ceil(log2(max(iResolution.x, iResolution.y)))); i ++){\n        vec3 curSampleCoord = sampleCoord;\n        vec3 curNoise = vec3(perlinNoise(1.0 - curSampleCoord, distScale));\n        // ^ (1.0 - coord) is fixing very obvious vertical \"RNG\" pattern\n        col += amplScale * curNoise;\n        sampleCoord = 2.0 * sampleCoord;\n        amplScale /= 2.0;\n        distScale *= 2.0;\n    }\n    col = 0.5 + 0.5 * col;\n    col = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, col)); // exaggerate values\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// \"Memory\" and nearest-values processing buffer.\n\nivec2 wrapCoords(ivec2 coord){ // texture wrap mode darkens edges over time\n    ivec2 iiRes = ivec2(iResolution.xy);\n    if (coord.x < 0){\n        coord.x += iiRes.x;\n    }\n    if (coord.x >= iiRes.x){\n        coord.x -= iiRes.x;\n    }\n    if (coord.y < 0){\n        coord.y += iiRes.y;\n    }\n    if (coord.y >= iiRes.y){\n        coord.y -= iiRes.y;\n    }\n    return coord;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    float val, waveMax, bloom;\n    if (iFrame == 0){\n        val = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0).r;\n        waveMax = 0.0;\n        bloom = 0.0;\n    } else {\n        float pts[9];\n        // potentially interesting things with different weights, but also very unstable\n        const float diagWt = 1.0;\n        const float edgeWt = 1.0;\n        const float centWt = 1.0;\n        float weights[9] = float[9](\n            diagWt, edgeWt, diagWt, \n            edgeWt, centWt, edgeWt, \n            diagWt, edgeWt, diagWt\n        );\n        float baseVal = 0.0;\n        float baseBloom = 0.0;\n        float weightsSum = 0.0;\n        float weightsMax = 0.0;\n        float weightsMin = 1.0e6;\n        \n        for (int dx = -1; dx <= 1; dx ++){\n            for (int dy = -1; dy <= 1; dy ++){\n                int arrIdx = (dx + 1) * 3 + (dy + 1);\n                pts[arrIdx] = \n                    texelFetch(iChannel1, wrapCoords(ivec2(fragCoord - 0.5) + ivec2(dx, dy)), 0).r;\n                float curWeight = weights[arrIdx];\n                weightsSum += curWeight;\n                weightsMax = max(weightsMax, curWeight);\n                if (curWeight > 0.0){\n                    weightsMin = min(weightsMin, curWeight);\n                }\n                baseVal += curWeight * pts[arrIdx];\n                baseBloom += curWeight * \n                    texelFetch(iChannel1, wrapCoords(ivec2(fragCoord - 0.5) + ivec2(dx, dy)), 0).b;\n            }\n        }\n        baseVal /= weightsSum;\n        baseBloom /= weightsSum;\n        \n        float minDiff = 1.0e6;\n        for (int dx = -1; dx <= 1; dx ++){\n            for (int dy = -1; dy <= 1; dy ++){\n                int arrIdx = (dx + 1) * 3 + (dy + 1);\n                float curWeight = weights[arrIdx];\n                if ((dx != 0) || (dy != 0)) {\n                    if (curWeight > 0.0){\n                        //float curDiff = (pts[arrIdx] - baseVal) * curWeight / weightsMax;\n                        float curDiff = (pts[arrIdx] - baseVal) * curWeight;\n                        minDiff = (abs(minDiff) < abs(curDiff)) ? minDiff : curDiff;\n                    }\n                }\n            }\n        }\n        \n        float newRand = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0).r;\n        float updDiffLim = (0.002 + 0.001 * sin(2.0 * M_PI * 100.0 * newRand)) * 1.5; // quick random\n        //updDiffLim *= (1.0 - cos(2.0 * M_PI * iTime * 0.1)) / 2.0;\n        \n        /*float waveH = pow((1.0 + cos(2.0 * M_PI * (uv.x * 0.25 + iTime * 0.15 + 0.1))) / 2.0, 20.0);\n        float waveV = pow((1.0 + cos(2.0 * M_PI * (uv.y * 0.25 + iTime * 0.15 + 0.1 + 0.5))) / 2.0, 20.0);\n        waveMax = max(waveH * 1.0, waveV * 1.0);*/\n        \n        /*vec2 scale = iResolution.xy / max(iResolution.x, iResolution.y);\n        float waveH = cos(2.0 * M_PI * (uv.x * 2.0 + cos(iTime * 0.25)) * scale.x);\n        float waveV = cos(2.0 * M_PI * (uv.y * 2.0 + sin(iTime * 0.25)) * scale.y);\n        waveMax = 0.5 + 0.5 * waveH * waveV * sin(iTime * 1.0);\n        waveMax = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, waveMax));\n        waveMax = pow(clamp(waveMax - 0.4, 0.0, 1.0) / (1.0 - 0.4), 1.0);*/\n        \n        vec2 scale = iResolution.xy / max(iResolution.x, iResolution.y);\n        float t = iTime * 2.0 * M_PI * 0.015 + 0.1; // shift to better align pattern for 10 s\n        vec2 pos1 = 1.3 * vec2(cos(t), sin(t));\n        vec2 pos2 = 1.5 * vec2(sin(t * 0.83), cos(t * 0.83));\n        float scale1 = 3.0 + 1.0 * cos(t * 0.94 + 0.50);\n        float scale2 = 2.2 + 0.8 * sin(t * 1.07 + 0.87);\n        float wave1 = cos(2.0 * M_PI * length((uv - pos1) * scale) * scale1);\n        float wave2 = cos(2.0 * M_PI * length((uv - pos2) * scale) * scale2);\n        waveMax = 0.5 + 0.5 * wave1 * wave2;\n        waveMax = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, waveMax));\n        waveMax = pow(clamp(waveMax - 0.4, 0.0, 1.0) / (1.0 - 0.4), 1.0);\n        \n        updDiffLim *= waveMax;\n        if (abs(minDiff) > updDiffLim){\n            val = mix(baseVal, baseVal + minDiff, 5.0);\n            val = mix(val, newRand, 0.001);\n        } else {\n            val = pts[4];\n        }\n        \n        float newBloom = max(abs(val - 0.5) - 0.5, 0.0);\n        bloom = 0.9990 * baseBloom + newBloom;\n    }\n    fragColor = vec4(vec3(val, waveMax, bloom), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}