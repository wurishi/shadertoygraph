{"ver":"0.1","info":{"id":"lstBzX","date":"1526234257","viewed":169,"name":"squiggle test","username":"dahart","description":"squiggle test","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["squiggle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define S(a,b,t) smoothstep(a,b,t)\n#define unlerp(a,b,t) ((t-a)/(b-a))\n\n// lump between a and b. \n// returns 0 when t is outside [a,b]\n// returns 1 at t=(a+b)/2.\n// smoothstep from center to either end (t==a, t==b)\nfloat L(float a, float b, float t) {\n    float u = unlerp(a, b, t);\n    return S(0., 1., 2.*u) * S(0., 1., 2. - u*2.);\n}\n\nvec4 premult(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 comp(vec4 bg, vec4 fg) {\n    return fg + bg * (1. - fg.a);\n}\n    \nconst vec3 green = vec3(.2, .8, .5);\n\n//https://www.shadertoy.com/view/ltXSDB\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3., p3 = p*p*p;\n    float q = a * (2.*a*a - 9.*b) / 27. + c;\n    float d = q*q + 4.*p3 / 27.;\n    float offset = -a / 3.;\n    if(d >= 0.) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27. / p3) * q / 2.) / 3.;\n    float m = cos(v), n = sin(v)*sqrt(3.);//1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.) + offset;\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Find the signed distance from a point to a bezier curve\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdBezier(vec2 p, vec3 A, vec3 B, vec3 C)\n{    \n    //B = (4.0 * B - A - C) / 2.0;\n    // handle instability when B is midpoint between A and C\n    //B = vec3(mix(B.xy + vec2(1e-4), B.xy, abs(sign(B.xy * 2.0 - A.xy - C.xy))), B.z);\n    \n    vec3 a = B - A;\n    vec3 b = A - B * 2.0 + C;\n    vec3 c = a * 2.0;\n    vec2 d = A.xy - p;\n    \n    vec3 k = vec3(3.*dot(a.xy,b.xy),2.*dot(a.xy,a.xy)+dot(d.xy,b.xy),dot(d.xy,a.xy)) / dot(b.xy,b.xy);      \n    vec3 rawt = solveCubic(k.x, k.y, k.z);\n    vec3 t = clamp(rawt, 0.0, 1.0);\n    vec3 it = vec3(1.0) - t;\n\n    vec3 pos0 = A + (c + b*t.x)*t.x;\n    vec3 pos1 = A + (c + b*t.y)*t.y;\n    vec3 pos2 = A + (c + b*t.z)*t.z;\n\n    float dis0 = length(pos0.xy - p) - pos0.z;\n    float dis1 = length(pos1.xy - p) - pos1.z;\n    float dis2 = length(pos2.xy - p) - pos2.z;\n    \n\tfloat minT = rawt.x;\n    vec3 minP = pos0;\n\tfloat minDis = dis0;\n\tif (dis1 < minDis) { minDis = dis1; minT = rawt.y; minP = pos1; }\n\tif (dis2 < minDis) { minDis = dis2; minT = rawt.z; minP = pos2; }\n            \n    return vec4(minDis, minDis + minP.z, 1., minT);\n}\n\n\nvec4 squiggles( vec2 uv, float time )\n{\n    const float timeSlices = 60.;\n    const int xyslices = 5;\n    const float width = .01;\n    const float scale = .9 / float(xyslices);\n    \n    \n    float ti1 = floor(fract(time) * timeSlices);\n\tfloat ti2 = floor(fract(time + 1./timeSlices) * timeSlices);\n\tfloat ti3 = floor(fract(time + 2./timeSlices) * timeSlices);\n\tfloat ti4 = floor(fract(time + 3./timeSlices) * timeSlices);\n    \n    // background\n    vec4 color = vec4(green*.4, 1.);\n    \n    ivec2 texSize = textureSize( iChannel0 , 0 );\n    float ts = float(texSize.x);\n    \n    int x = int(floor(uv.x*float(xyslices)));\n    int y = int(floor(uv.y*float(xyslices)));\n\n    float index = float(y*xyslices+x);\n\n    vec4 rnd1 = texture(iChannel0, vec2((index+.5)/ts, (ti1+.5)/ts));\n    vec4 rnd2 = texture(iChannel0, vec2((index+.5)/ts, (ti2+.5)/ts));\n    vec4 rnd3 = texture(iChannel0, vec2((index+.5)/ts, (ti3+.5)/ts));\n\n    vec2 xyuv = (vec2(x, y) + .5) / float(xyslices);\n    vec2 a = xyuv + (rnd1.xy-.5) * scale;\n    vec2 b = xyuv + (rnd2.xy-.5) * scale;\n    vec2 c = xyuv + (rnd3.xy-.5) * scale;\n    \n    vec4 d = sdBezier( \n        uv, \n        vec3(.5*(a+b), width), \n        vec3(b       , width),\n        vec3(.5*(b+c), width));\n\n    float dx = fwidth(d.x) * 1.5;\n    \n    // Try to get rid of POV overlap artifacts. \n    // This might be specific to my mac's display gamma.\n    float blend = 20. * dx;\n    float bias = blend * -0.4; \n    const float alpha = 1.;\n    \n    float aa = S(0., -dx, d.x);\n    float blendIn = S(-blend+bias, blend+bias, d.w);\n    float blendOut = S(1.+blend-bias, 1.-blend-bias, d.w);\n    if (d.x < dx) color = comp(color, premult(vec4(vec3(1.), alpha*aa*blendIn*blendOut)));\n\n    /*\n\t// optionally show a second segment, to see the overlap blending when not animating. \n    vec4 rnd4 = texture(iChannel0, vec2((index+.5)/ts, (ti4+.5)/ts));\n\n    xyuv = (vec2(x, y) + .5) / float(xyslices);\n    a = xyuv + (rnd2.xy-.5) * scale;\n    b = xyuv + (rnd3.xy-.5) * scale;\n    c = xyuv + (rnd4.xy-.5) * scale;\n\n    d = sdBezier( \n        uv, \n        vec3(.5*(a+b), width), \n        vec3(b       , width),\n        vec3(.5*(b+c), width));\n\n\tif (d.x < 0.) color = comp(color, premult(vec4(vec3(1.), alpha*S(0., -dx, d.x)*S(-blend+bias, blend+bias, d.w)*S(1.+blend-bias, 1.-blend-bias, d.w))));\n\t//*/\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float margin = .5 * (iResolution.x - iResolution.y);\n\tvec2 uv = 1.*(fragCoord.xy - vec2(1.,0.)*margin) / iResolution.yy;\n    float mouseU = (iMouse.x - margin) / (iResolution.x - 2.*margin);\n    float time = iTime + mouseU;\n    \n    if (uv.x >= 0.0 && uv.x <= 1.0) fragColor = squiggles(uv, time);\n    else fragColor = vec4(0.);\n}\n","name":"Image","description":"","type":"image"}]}