{"ver":"0.1","info":{"id":"4cKGDG","date":"1713568041","viewed":53,"name":"AF - fractal pyramid","username":"tristanC","description":"With more params:\n- https://www.youtube.com/watch?v=RkFilb-Zt8I","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractalcineshader"],"hasliked":0,"parentid":"tsXBzS","parentname":"fractal pyramid"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forked from https://www.shadertoy.com/view/tsXBzS\n// Created by Created by bradjamesgrant in 2020-05-03\n// Default licence: CC-BY-NC-SA-3.0\n\n// The shader has been adapted^Wbutchered to support new parameters\n// to be controlled from midi/audio inputs with animation-fractal.\n\n#ifndef ANIMATION_FRACTAL\n#define STEP1(x) ((x) - sin(x))\n#define STEP(x, offset, amp) (STEP1(STEP1(offset + x * amp)) * .15)\n#define is (iTime * .5)\n#define t1p1 (STEP(is, 1., 1.))\n#define t1p2 (STEP(is, 2., 3.))\n#define t1p3 (STEP(is, 3., 2.))\n#define t1p4 (STEP(is, 4., 4.))\n#define t1p5 (STEP(is, 9., 1.))\n#define t1p6 (STEP(is, 3., 2.))\n#define t1p7 (STEP(is, 4., 2.))\n#define t1p8 (STEP(is, 9., 2.))\n#define t1p9 (STEP(is, 4., 2.))\n#define t1p10 (STEP(is, 9., 2.))\n\n#define icolor (iTime*.1)\n#define imoveFWD (iTime*.1)\n#endif\n\nfloat pitches[10];\n\nvec3 palette(float d){\n    return mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p, int id){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n\n        float px = 0., py = 0., pz = 0.;\n        px = .5 * pitches[(id + 1) % 8];\n        py = .5 * pitches[(id + 2) % 8];\n        pz = .5 * pitches[(id + 3) % 8];\n        p.xz = rotate(p.xz, px);\n        p.xy = rotate(p.xy, py);\n        p.yz = rotate(p.yz, pz);\n        p.xz = abs(p.xz);\n        p.xz-=.4;\n        p.yz-= .15+.15*sin(pitches[(id + 4) % 8]);\n        p.xy-= .15+.15*sin(pitches[(id + 5) % 8]);\n    }\n    return dot(sign(p),p)/5.;\n}\nfloat smin(float a, float b) {\n    float k = 12.;\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res) / k;\n}\nvec3 rm (vec3 ro, vec3 rd, float id){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n        vec3 p = ro + rd*t;\n        float d0 = map(p + vec3(-2.5, -.5, 0.), 0)*.5;\n        float d1 = map(p + vec3( 2.5, -.5, 0.), 5)*.5;\n        float d2 = map(p + vec3( 0.0, 1., 0.), 2)*.5;\n        d = min(min(d0, d1), d2);\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n            break;\n        }\n        // col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(sin(icolor)*.15 + length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return col;\n}\n\n#ifdef ANIMATION_FRACTAL\nvoid main() {\n    vec2 uv = -.5 + inUV;\n    uv.y *= scene.screenRatio;\n#else\nvoid mainImage( out vec4 oColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n#endif\n    uv *= 2.;\n    vec3 ro = vec3(0.,0.,-50.);\n    uv.xy = rotate(uv.xy, imoveFWD);\n\n    float t = iTime * .01;\n    pitches[0] = t+t1p1;\n    pitches[1] = t+t1p2;\n    pitches[2] = t+t1p3;\n    pitches[3] = t+t1p4;\n    pitches[4] = t+t1p5;\n    pitches[5] = t+t1p6;\n    pitches[6] = t+t1p7;\n    pitches[7] = t+t1p8;\n    pitches[8] = t+t1p9;\n    pitches[9] = t+t1p10;\n\n    // uv.x += 0.5;\n    // uv *= 1.5;\n    // vec2 id2=pMod2(uv, vec2(1., 0.));\n    // float id = pModPolar(uv, 8.); // pMod3(ro, vec3(2., 1., 1.));\n    // float id = smoothKaleidoscope(uv, 0., 4., 4.);\n    ro.xy = rotate(ro.xy,iTime*.1);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n\n    vec3 rd = normalize(uuv-ro);\n\n    float id = 0.;\n    vec3 col = rm(ro,rd, id);\n\n    col = pow(col, vec3(1.2, .9, .9) * 1.7);\n    oColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}