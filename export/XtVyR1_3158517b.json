{"ver":"0.1","info":{"id":"XtVyR1","date":"1535105365","viewed":260,"name":"Lemniscata","username":"frozenshady","description":"Simple lemniscate equation produces nearly chaotic bubbles.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","algebraiccurves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n\nfloat sin01(in float x)\n{\n    return (sin(x) + 1.0) / 2.0;\n}\n\nfloat smoothStep2(in float edge, in float x)\n{\n    const float fadeWidth = 0.4;\n    return smoothstep(edge - fadeWidth, edge + fadeWidth, x);\n}\n\nvec2 complexProd(in vec2 v1, in vec2 v2)\n{\n    return vec2(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v2.x * v1.y);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    return smoothStep2(abs(length(cp12) - (r * r)), width);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in vec2 f3, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    vec2 cp123 = complexProd(uv - f3, cp12);\n    return smoothStep2(abs(length(cp123) - (r * r * r)), width);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in vec2 f3, in vec2 f4, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    vec2 cp123 = complexProd(uv - f3, cp12);\n    vec2 cp1234 = complexProd(uv - f4, cp123);\n    return smoothStep2(abs(length(cp1234) - pow(r, 4.0)), width);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in vec2 f3, in vec2 f4, in vec2 f5, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    vec2 cp123 = complexProd(uv - f3, cp12);\n    vec2 cp1234 = complexProd(uv - f4, cp123);\n    vec2 cp12345 = complexProd(uv - f5, cp1234);\n    return smoothStep2(abs(length(cp12345) - pow(r, 5.0)), width);\n}\n\nvec2 circMotion(in vec2 center, in float r, in float freq, in float phase)\n{\n    float s = sin(iTime * freq + phase);\n    float c = cos(iTime * freq + phase);\n    return center + r * vec2(c, s);\n}\n\nvec2 ellipseMotion(in vec2 center, in float a, in float b, in float angle, in float freq, in float phase)\n{\n    float s = b * sin(iTime * freq + phase);\n    float c = a * cos(iTime * freq + phase);\n    float rs = sin(angle);\n    float rc = cos(angle);\n    return center + mat2(rc, -rs, rs, rc) * vec2(c, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - vec2(1.0);\n    uv.x *= (iResolution.x / iResolution.y);\n\n    float r = sin01(iTime) * 0.6 + 0.6;\n    const vec2 f1 = vec2(-0.5, 0.0);\n    const vec2 f2 = vec2(0.8, -0.3);\n    const vec2 f3 = vec2(0.0, 0.3);\n    const vec2 f4 = vec2(-0.85, 0.6);\n    \n    vec2 f1m = circMotion(f1, 0.4, 5.1, 0.7);\n    vec2 f2m = ellipseMotion(f2, 0.2, 0.4, PI / 4.0, 4.3, 0.3);\n    vec2 f3m = circMotion(f3, 0.3, 7.0, 0.0);\n    vec2 f4m = circMotion(f4, 0.3, 2.0, 1.0);\n    \n    vec3 c1 = vec3(1.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.0, 1.0, 0.0);\n    vec3 c3 = vec3(0.0, 0.0, 1.0);\n    vec3 c4 = vec3(1.0);\n    \n    float d1 = distance(uv, f1m);\n    float d2 = distance(uv, f2m);\n    float d3 = distance(uv, f3m);\n    float d4 = distance(uv, f4m);\n    \n    vec3 col = (d1 * c1 + d2 * c2 + d3 * c3 + d4 * c4) / 1.5;\n    \n    float c = lem(uv, f1m, f2m, f3m, f4m, r, 0.008);\n    \n    \n    // Output to screen\n    fragColor = vec4(col * c,1.0);\n}\n","name":"Image","description":"","type":"image"}]}