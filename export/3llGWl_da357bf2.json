{"ver":"0.1","info":{"id":"3llGWl","date":"1558046590","viewed":410,"name":"Small test","username":"bitnenfer","description":"This is just a small test. Rotate camera around center with mouse.\nPlease, be patient. It takes a long time to converge ","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 (PI*2.)\n#define MAX_STEPS 200\n#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n#define BOUNCES 4\n#define saturate(n) clamp(n,0.0,1.0)\n\nstruct Material\n{\n    vec3 color;\n    float glossy;\n    float emissive;\n    float checker;\n};\n\nstruct SceneDist\n{\n    float dist;\n    Material material;\n};\n\nstruct RayResult\n{\n    float dist;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\n    \nconst Material kMatNone = Material(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0);\nconst Material kMatRed = Material(vec3(0.0, 0.0, 0.1), 0.99, 0.0, 0.0);\nconst Material kMatGreen = Material(vec3(0.1, 0.08, 0.0), 1.0, 0.0, 0.0);\nconst Material kMatBlue = Material(vec3(0.1, 0.0, 0.0), 0.8, 0.0, 0.0);\nconst Material kMatWhite = Material(vec3(0.1), .7, 0.0, 1.0);\nconst Material kMatLight = Material(vec3(1.0), 0.0, 0.2, 0.0);\n\nconst vec3 E = vec3(0.0, MIN_DIST, 1.0);\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nSceneDist unions(SceneDist a, SceneDist b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nSceneDist map(in vec3 p)\n{\n    vec3 rep = vec3(25.0, 0.0, 25.0);\n    vec3 p2 = mod(p + vec3(0, -40.0, 0.0), rep) - rep * 0.5;\n   \n    SceneDist s0 = SceneDist(length(p + vec3(0.4, -1.1, -0.6)) - 0.8, kMatRed);\n    SceneDist s1 = SceneDist(length(p + vec3(-1.2, 0.5, 0.0)) - 1.0, kMatBlue);\n    SceneDist s2 = SceneDist(length(p + vec3(0.0, 0.4, -1.0)) - 1.5, kMatGreen);\n    SceneDist b0 = SceneDist(sdBox(p2 , vec3(10.0, 1.0, 10.0)), kMatLight);\n    SceneDist b1 = SceneDist(\n        min(\n            sdBox(vec3(0.0, -1.0, 0.0) + p + vec3(-2.5, 0.0, -5.0), vec3(4.0, 1.3, 0.3)),\n            sdBox(vec3(0.0, -1.0, 0.0) + p + vec3(4.5, 0.0, 2.5), vec3(0.3, 1.3, 4.5))\n        )-.1\n    , kMatGreen);\n    SceneDist fl = SceneDist(p.y + 1.0, kMatWhite);\n    \n    return unions(unions(unions(fl, unions(unions(s0, s1), s2)), b0), b1);\n}\n\nfloat SEED = 0.0;\n\nfloat random() {\n    return fract(sin(SEED++) * 43758.5453123);\n}\n\nvec3 randomUnitVector() {\n    float theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\nvec3 randomUnitVector2(vec3 d, float f) {\n    float phi = 2. * PI * (random());\n    float r2 = (random()*f);\n    float sinTheta = sqrt(r2);\n    float cosTheta = sqrt(1. - r2);\n    vec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);    \n\treturn (u * cos(phi) + v * sin(phi)) * sinTheta + w * cosTheta;\n}\n\nvec3 normal(in vec3 p)\n{\n    return normalize(vec3(\n        map(p + E.yxx).dist - map(p - E.yxx).dist,\n        map(p + E.xyx).dist - map(p - E.xyx).dist,        \n        map(p + E.xxy).dist - map(p - E.xxy).dist\n    ));\n}\n\nRayResult raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ro + rd * t;\n        SceneDist scene = map(p);\n        if (scene.dist < MIN_DIST)\n        {\n            return RayResult(t, p, normal(p), scene.material);\n        }\n        t += scene.dist;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n    }\n    return RayResult(MAX_DIST, vec3(0.0), vec3(0.0), kMatNone);\n}\n\nvec4 trace(vec2 uv)\n{\n    float mx = -150.0 * PI / 180.0;\n    vec3 ro = vec3(uv.x, uv.y + 14.0, -35.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 3.0, 8.0));\n    vec3 color = vec3(0.0);\n    float depth = 0.0;\n    float attenuation = 1.0;\n\n    mx += (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n        \n    mat2 tm = mat2(cos(mx), sin(mx), -sin(mx), cos(mx));\n    ro.xz *= tm;\n    rd.xz *= tm;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n        RayResult mainResult = raymarch(ro, rd);\n        \n        if (mainResult.dist < MAX_DIST)\n        {\n            if (i == 0) depth = mainResult.dist;\n            vec3 mainColor = mainResult.material.color;\n            vec3 P2 = mainResult.position;\n        \tfloat c = mod((floor(P2.x) + floor(P2.z) + floor(P2.y)), 2.0);\n            \n\t\t\tcolor += attenuation * (mainColor * mix(1.0, c, mainResult.material.checker));\n                        \n            if (mainResult.material.emissive > 0.0)\n            {\n                color += attenuation * (mainResult.material.emissive);\n            }\n            else\n            {\n                vec3 rd = randomUnitVector2(mainResult.normal, 1.0);\n                vec3 ro = mainResult.position + rd * 0.1;\n                \n                RayResult diffuseBounce = raymarch(ro, rd);\n                float bounceEmissive = diffuseBounce.material.emissive;\n                                  \n                if (bounceEmissive > 0.0)\n                {\n                    color += attenuation * ((diffuseBounce.material.color * bounceEmissive));\n                }\n            }\n            \n            if (mainResult.material.glossy > 0.0)\n            {\n                float glossy = saturate(1.0 - mainResult.material.glossy);\n                vec3 rd = normalize(reflect(rd, randomUnitVector2(mainResult.normal, glossy)));\n                vec3 ro = mainResult.position + rd * 0.1;\n                \n                RayResult specularBounce = raymarch(ro, rd);\n                float specularEmissive = specularBounce.material.emissive;\n                \n                if (specularEmissive > 0.0)\n                {\n                    color += attenuation * ((specularBounce.material.color * specularEmissive));\n                }\n            }\n            \n            attenuation *= clamp(mainResult.material.glossy, 0.0, 0.8);\n        }\n        else break;\n        \n        float glossy = saturate(1.0 - mainResult.material.glossy);\n        rd = normalize(reflect(rd, randomUnitVector2(mainResult.normal, glossy)));\n        ro = mainResult.position + rd * 0.1;\n    }\n    \n    return vec4(color, depth);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    SEED = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 pixelSize = vec2(1.0)/iResolution.xy;\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n    vec2 j = pixelSize * ((random()*2.0-1.0)*1.5);\n    vec4 color = trace(uv + j);\n    vec4 prevColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    #if 1\n    float frames = 1.0 / float(iFrame + 1);\n    if (iFrame > 1 && iMouse.z < 1.0)\n        color.rgb = mix(prevColor.rgb, color.rgb, frames);\n    #else\n    float steps = min(float(iFrame + 1), 300.0);\n    if (iMouse.z <= 0.0) steps = 1.0;\n    if (iFrame > 1)\n        color.rgb = mix(prevColor.rgb, color.rgb, clamp(steps / 300.0, 0.0, 1.0));\n    #endif\n    fragColor = vec4(color);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BLUR 1\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\treturn abs(coc) * 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = (vec2(1.0)/iResolution.xy);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 texel = texture(iChannel0, uv);\n    float depth = texel.w;\n    float blurSize = pow(getBlurSize(depth*0.096, 3.7, 1.25)*.5,4.);\n    #if BLUR\n    float samples = 1.0;\n    \n    for (float r = 0.0; r < 3.14*2.0; r+=0.1)\n    {\n    \tfloat cr = cos(r);\n        float sr = sin(r);\n        texel += texture(iChannel0, uv + (vec2(cr,sr) * (pixelSize*blurSize)));\n    \tsamples += 1.0;\n    }\n    \n    fragColor = vec4(texel.rgb / samples, 1.0);\n\t#else\n    fragColor = vec4(texel.rgb, 1.0);\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"}]}