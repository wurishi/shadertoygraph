{"ver":"0.1","info":{"id":"7lBXzz","date":"1627194729","viewed":80,"name":"Class 3: Fork 4 359 Cephalopod","username":"Cephalopodium","description":"Sphereflake. adapated from siggraph course . Expanded to level 3. Increased horizontal rotational options. Varying separation. test2 43, 151, 223, 259 objects. Note to self.. Strangely only compiles with > 151 objects if I'm running it at off peak hours.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphereflake"],"hasliked":0,"parentid":"7tX3zf","parentname":"Class 3: Complex Scene"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 1000000.0\n\nfloat seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n    int id;\n    int firstChild;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = MAXX; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nconst int NUM_SPHERE = 223; // 151; // 259; // 43 2nd gen ok - 259 for full 3rd gen \nSphere spheres[NUM_SPHERE];\nLight  lights[1];\n\nfloat theta = 0.0;\n\nvoid rotateSceneTenDegrees(int f, int parent, int child) {\n    theta += float(f)/5.0 * 3.1415/45.0;\n    //theta = 0.0;\n    for (int i=child+2; i<child+6; i++) { // cda was i=0 i=2 skips Top and bottom sphere rotations\n        // rotate each child sphere about y-axis \n        // through the center of the large one\n        vec3 v1 = spheres[i].center - spheres[parent].center;\n        vec3 axis = normalize(vec3(0.0, spheres[parent].radius, 0.0));\n        vec3 newv = v1*cos(theta) + cross(axis, v1)* sin(theta) + axis*dot(axis, v1)*(1.0-cos(theta));\n        spheres[i].center = newv + spheres[parent].center;\n  /*      if (parent==0) {  // cda move the grandkids\n           for (int j=spheres[i].firstChild;j<spheres[i].firstChild+6;j++) {\n             // deal with 4 middle level 2 spheres [2..5]\n             vec3 v2 = spheres[j].center - spheres[i].center;\n             vec3 axis2 = normalize(vec3(0.0, spheres[i].radius, 0.0));\n             vec3 newv2 = v2*cos(theta) + cross(axis2, v2)* sin(theta) + axis2*dot(axis2, v2)*(1.0-cos(theta));\n             spheres[j].center = newv + spheres[i].center;\n           }\n        } */\n    } \n}\n\nint addSixSpheres(Sphere parentSphere, int count) {\n    float radius = parentSphere.radius;\n    vec3 center = parentSphere.center;\n    int id = parentSphere.id;\n    parentSphere.firstChild = count+1;   // set firstChild attribute\n    float sep = -0.1; // sin(iTimeDelta)/10.0; // -0.1;  // cda separation variable\n    float dTop = 1.0; float dBot  = 1.0; float dRhs = 1.0; // cda seperation factors\n    float dLhs = 1.0; float dNear = 1.0; float dFar = 1.0;  // cda positive values push out \n    float childRadius = radius/2.181;   // parent to child reduction factor was 2.8\n    int cdaCount = count;\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y+radius+childRadius+(sep*dTop), center.z), vec3(0,0,1), id, cdaCount+1); // random(), random(), random())); // top blue\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y-radius-childRadius-(sep*dBot), center.z), vec3(1,1,0), id, cdaCount+2); // random(), random(), random())); // bot yellow\n    spheres[++count] = Sphere(childRadius, vec3(center.x+radius+childRadius+(sep*dRhs), center.y, center.z), vec3(1,0,0), id, cdaCount+3); // random(), random(), random())); // rhs red \n    spheres[++count] = Sphere(childRadius, vec3(center.x-radius-childRadius-(sep*dLhs), center.y, center.z), vec3(0,1,0), id, cdaCount+4); // random(), random(), random())); // lhs green\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z+radius+childRadius+(sep*dNear)), vec3(1,1,1), id, cdaCount+5); // random(), random(), random())); //  // near white -was vec3(sin(iTime)+1.0/2.0, random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z-radius-childRadius-(sep*dFar)), vec3(.5,.5,.5), id, cdaCount+6); // random(), random(), random())); // far grey\n   /* if (id<7) {\n       spheres[cdaCount+1].color = vec3(1/6,1,1);\n       spheres[cdaCount+2].color = vec3(2/6,1,1); \n       spheres[cdaCount+3].color = vec3(3/6,1,1);\n       spheres[cdaCount+4].color = vec3(4/6,1,1);\n       spheres[cdaCount+5].color = vec3(5/6,1,1);\n       spheres[cdaCount+6].color = vec3(6/6,1,1); \n    } else {\n       spheres[cdaCount+1].color = vec3(1,1/6,0);\n       spheres[cdaCount+2].color = vec3(1,2/6,0);\n       spheres[cdaCount+3].color = vec3(1,3/6,0);\n       spheres[cdaCount+4].color = vec3(1,4/6,0);\n       spheres[cdaCount+5].color = vec3(1,5/6,0);\n       spheres[cdaCount+6].color = vec3(1,6/6,0); \n    } */\n    return count;\n}\n\nvoid makeScene(int f) {\n    float radius=0.8;\n    vec3 center = vec3(0, 0, -6); \n    vec3 color = vec3(random(), random(), random());\n    int count = -1; // cda TBRLNF top[1] bottom[2] right[3] left[4] near[5] far[6]\n    spheres[++count] = Sphere(radius, center, color,0,-1);    // root count = 0 id=0 firstChild = -1;\n    count = addSixSpheres(spheres[0], count);  // 1st gen returns count=6\n    count = addSixSpheres(spheres[1], count);  // 2nd gen for 1st of 6 kids count=12 top T\n    count = addSixSpheres(spheres[2], count);  // count = 18 bot B\n    count = addSixSpheres(spheres[3], count);  // 24 rhs R\n    count = addSixSpheres(spheres[4], count);  // 30 lhs L\n    count = addSixSpheres(spheres[5], count);  // 36 near N\n//    count = addSixSpheres(spheres[6], count);  // 2nd gen for Last of six kids count = 42 far F invisible\n\nif (1==1) {\n    count = addSixSpheres(spheres[7], count);  // 3rd gen TT count = 48\n    count = addSixSpheres(spheres[8], count);  // 3rd gen TB count = 54\n    count = addSixSpheres(spheres[9], count);  // 3rd gen TR count = 60\n    count = addSixSpheres(spheres[10], count); // 3rd gen TL count = 66\n    count = addSixSpheres(spheres[11], count); // 3rd gen TN count = 7\n//  count = addSixSpheres(spheres[12], count); // 3rd gen TF count = 78 Invisible\n\n    count = addSixSpheres(spheres[13], count); // 3rd gen BT count = 84\n    count = addSixSpheres(spheres[14], count); // 3rd gen BB count = 90\n    count = addSixSpheres(spheres[15], count); // 3rd gen BR count = 96\n    count = addSixSpheres(spheres[16], count); // 3rd gen BL count = 102\n    count = addSixSpheres(spheres[17], count); // 3rd gen BN count = 108\n//    count = addSixSpheres(spheres[18], count); // 3rd gen BF count = 114 Invisible\n\n    count = addSixSpheres(spheres[19], count); // 3rd gen RT count = 120\n    count = addSixSpheres(spheres[20], count); // 3rd gen RB count = 126\n    count = addSixSpheres(spheres[21], count); // 3rd gen RR count = 132\n    count = addSixSpheres(spheres[22], count); // 3rd gen RL count = 138\n    count = addSixSpheres(spheres[23], count); // 3rd gen RN count = 144\n//    count = addSixSpheres(spheres[24], count); // 3rd gen RF count = 150 Invisible\n/* */\n    count = addSixSpheres(spheres[25], count); // 3rd gen LT count = 156\n    count = addSixSpheres(spheres[26], count); // 3rd gen LB count = 162\n    count = addSixSpheres(spheres[27], count); // 3rd gen LR count = 168\n    count = addSixSpheres(spheres[28], count); // 3rd gen LL count = 174\n    count = addSixSpheres(spheres[29], count); // 3rd gen LN count = 180\n//    count = addSixSpheres(spheres[30], count); // 3rd gen LF count = 186\n\n    count = addSixSpheres(spheres[31], count); // 3rd gen NT count = 192\n    count = addSixSpheres(spheres[32], count); // 3rd gen NB count = 198\n    count = addSixSpheres(spheres[33], count); // 3rd gen NR count = 204\n    count = addSixSpheres(spheres[34], count); // 3rd gen NL count = 210\n    count = addSixSpheres(spheres[35], count); // 3rd gen NN count = 216\n//    count = addSixSpheres(spheres[36], count); // 3rd gen NF count = 222\n/*\n    count = addSixSpheres(spheres[37], count); // 3rd gen FT count = 228\n    count = addSixSpheres(spheres[38], count); // 3rd gen FB count = 234\n    count = addSixSpheres(spheres[39], count); // 3rd gen FR count = 240\n    count = addSixSpheres(spheres[40], count); // 3rd gen FL count = 246\n    count = addSixSpheres(spheres[41], count); // 3rd gen FN count = 252\n    count = addSixSpheres(spheres[42], count); // 3rd gen FF count = 258 */\n  }\n    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1)); \n    rotateSceneTenDegrees(f*9,23,139);  // level 3 RN 23,145\n//  rotateSceneTenDegrees(f*9,22,133);  // level 3 RL 22,133    // hidden by FR\n    rotateSceneTenDegrees(f*9,21,127);  // level 3 RR 21,127\n    rotateSceneTenDegrees(f*9,20,121);  // level 3 RB 20,121\n    rotateSceneTenDegrees(f*9,19,115);  // level 3 RT 19,115);    // level 3 top top 7,43\n/*    rotateSceneTenDegrees(f*4,1,7);    // level 2 top\n    rotateSceneTenDegrees(f*4,2,13);   // level 2 bottom \n    rotateSceneTenDegrees(f*4,3,19);   // level 2 right\n    rotateSceneTenDegrees(f*4,4,25);   // level 2 left\n    rotateSceneTenDegrees(f*4,5,31);   // level 2 near\n  //  rotateSceneTenDegrees(f*4,6,37);   // level 2 far \n    rotateSceneTenDegrees(f*9,0,1);    // level 1 */\n}\n\nint numSamples = 1;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   if (iFrame==0) theta = 0.0;\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -1.50; // was -2.0\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float t = MAXX;\n       int iSphere = -1;\n       float minT = MAXX;\n       for (int i=0; i < NUM_SPHERE; i++) {\n           Sphere sphere = spheres[i];\n         \n           t = raySphereIntersect(ray, sphere);\n         \n           if (t < minT) {\n               minT = t;\n               iSphere = i;\n           }\n       }\n       if (iSphere > -1 && minT < MAXX) {\n           Sphere sphere = spheres[iSphere];\n           vec3 hit = ray.origin + minT*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           float angle = dot(hitPointNormal, hitPointToEye);\n           samp = samp + angle*sphere.color;\n          \n       }\n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}