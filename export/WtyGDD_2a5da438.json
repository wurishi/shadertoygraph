{"ver":"0.1","info":{"id":"WtyGDD","date":"1579055402","viewed":497,"name":"Simple and practical fire","username":"Tara","description":"Steps:\n1. Take a heat gradient.\n2. Multiply it with a mask defining where the fire should be (can be combined with [1]).\n3. Multiply that with scrolling noise.\n4. Sample a gradient using the resulting value.\n\nYou can play with the settings at the top.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["noise","simple","fire","texture","lookup","practical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings:\nconst float noise_scale = 0.028;\nconst float time_scale = -0.035;\n\n// This option is experimental.\n// With a properly tuned noise texture\n// this option shouldn't be necessary.\n//#define WIGGLE_UV\n\n// Use time-based 3D noise instead of 2D noise.\n#define USE_3D_NOISE\n\n// Color gradient lookup table.\n// This would ideally be a 1D texture.\nvec3 colors[] = vec3[](\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.45, 0.045, 0.027),\n    vec3(0.7, 0.08, 0.048),\n    vec3(0.9, 0.15, 0.06),\n    vec3(1.0, 0.25, 0.09),\n    vec3(1.1, 0.35, 0.122),\n    vec3(1.2, 0.45, 0.155),\n    vec3(1.3, 0.5, 0.189),\n    vec3(1.35, 0.6, 0.256),\n    vec3(1.4, 0.65, 0.325),\n    vec3(1.5, 0.7, 0.396),\n    vec3(1.6, 0.75, 0.469),\n    vec3(1.7, 0.8, 0.544),\n    vec3(1.8, 0.85, 0.621),\n    vec3(1.9, 0.9, 0.7),\n    vec3(2.0, 1.0, 0.77),\n    vec3(2.2, 1.2, 0.84),\n    vec3(2.5, 1.5, 1.4),\n    vec3(3.0, 3.0, 2.1)\n);\n    \n// This would ideally be a texture containing perlin noise.\nfloat get_noise(vec2 uv)\n{\n    // All layers moving at the same speed (faster):    \n#ifdef USE_3D_NOISE\n    uv = uv * noise_scale * 8.0 + vec2(0.0, iTime * time_scale * 8.0 );\t// You make the scroll direction math the wind direction.\n    vec3 uv_3d = vec3(uv, iTime * 0.1);\n    float noise = texture(iChannel1, 1.0 * uv_3d).r * 0.8 +\n    \t\t\t  texture(iChannel1, 2.0 * uv_3d).r * 0.4 +\n                  texture(iChannel1, 4.0 * uv_3d).r * 0.2 +\n                  texture(iChannel1, 8.0 * uv_3d).r * 0.1;\n#else\n    uv = uv * noise_scale + vec2(0.0, iTime * time_scale);\t// You make the scroll direction math the wind direction.\n    float noise = texture(iChannel0, 1.0 * uv).r * 0.8 +\n    \t\t\t  texture(iChannel0, 2.0 * uv).r * 0.4 +\n                  texture(iChannel0, 4.0 * uv).r * 0.2 +\n                  texture(iChannel0, 8.0 * uv).r * 0.1;    \n#endif\n    \n    /* Each layer moving at different speeds (slower):\n    float noise = textureLod(iChannel0, 0.5 * uv * noise_scale + vec2(0.0, iTime * time_scale), 0.0).r;\n    noise += textureLod(iChannel0, 1.0 * uv * noise_scale + vec2(0.0, iTime * time_scale), 0.0).g * 0.5;\n    noise += textureLod(iChannel0, 2.0 * uv * noise_scale + vec2(0.0, iTime * time_scale), 0.0).b * 0.25;\n    //noise += textureLod(iChannel0, 4.0 * uv * noise_scale + vec2(0.0, iTime * time_scale), 0.0).a * 0.125;\n   \t*/\n    \n    noise *= noise;\n    \n    return(noise);    \n}\n\n// This would ideally be a texture or a vertex attribute.\nfloat get_gradient(vec2 uv)\n{\n    float gradient = 1.0 - uv.y;\n    //gradient *= gradient;\n    return(gradient);\n}\n\n// This would ideally be a texture.\nfloat get_mask(vec2 uv, vec2 offset, vec2 scale)\n{\n    uv -= offset;\n    uv /= scale;\n    float mask = distance(vec2(0.0), uv);\n    \n    //float mask = distance(offset, uv * scale);\n    mask = smoothstep(0.45, 0.0, mask);\n    return(mask);\n}\n\n// Linearly interpolates all values in the \"colors\" array.\nvec3 get_gradient(float factor)\n{\n    const int max_index = colors.length() - 1;\n    const float key_distance = 1.0f / float(max_index);\n\n    // First we select the indices of the two keys to interpolate:\n    int start_index = int(factor * float(max_index));\n    int end_index = min(start_index + 1, max_index);\n\n    // Calculate the interpolation factor between the two key values:\n    float key_start_time = float(start_index) * key_distance;\n    float sub_factor = (factor - key_start_time) / key_distance;\n\n    return(mix(colors[start_index], colors[end_index], sub_factor));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1):\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float slot_width = iResolution.x / iResolution.y / 4.0;\t// Divided by 4 because we have 4 slots.\n    \n    vec2 noise_uv = uv;\n    \n#ifdef WIGGLE_UV\n   noise_uv.x += sin(iTime * 25.0 + uv.y * 10.0) * 0.01;\n#endif\n    \n    float noise = get_noise(noise_uv);\n    float gradient = get_gradient(uv);\n    float mask = get_mask(uv, vec2(slot_width / 1.8, 0.3), vec2(slot_width * 1.2, 2.25));\n    float heat = mask * gradient * noise;\n  \n    if(uv.x > slot_width * 3.0)\t// Gradient:\n    {\n   \t\tfragColor.rgb = vec3(get_mask(uv, vec2(slot_width * 3.5, 0.3), vec2(slot_width * 1.2, 2.25)));\n    }\n    else if(uv.x > slot_width * 2.0)\t// Noise:\n    {\n   \t\tfragColor.rgb = vec3(gradient);\n    }\n    else if(uv.x > slot_width * 1.0)\t// Mask:\n    {\n   \t\tfragColor.rgb = vec3(noise);\n    }\n    else if(uv.x > slot_width * 1.0)\t// Mask:\n    {\n   \t\tfragColor.rgb = vec3(noise);\n    }\n    else if(uv.x > slot_width * 0.1)\t// Fire:\n    {\n    \tfragColor.rgb = get_gradient(heat);\n    }\n    else\t// Fire:\n    {\n    \tfragColor.rgb = get_gradient(gradient);\n    }\n    \n    // Transform to sRGB:\n   \tfragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}