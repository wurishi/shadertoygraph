{"ver":"0.1","info":{"id":"3s3yRr","date":"1600224007","viewed":269,"name":"Sinbloc","username":"JacobC","description":"My capsule-prism grid, move camera with mouse (click and drag)","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","light","ao","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Sinbloc\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n// Set it to 1. if runs slow\n#define AA 2.\n// Set to 0 to compute AO in one grid cell (also goes faster)\n#define AO 1\n\nstruct mat\n{\n    float z;\n    vec3 c;\n    float ao;\n};\n\nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    // Cheap Ambient Occlusion: https://www.shadertoy.com/view/ttXfWX\n    // Adjust AO influence\n    // I like darker values e.g: 1., 1.4, 7.2\n    // but i think it looks more realistic with clearer values e.g: 1., 5.6, 115.2\n    // or 1., 2.8, 28.8 <---- I think this is better\n    float ao = map(max(a.z, b.z), 1., 2.8, 28.8);\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c,\n            a.ao * ao\n        );\n}\n\n#define T iTime\n#define Pi 3.141592\n#define MIN_S .05\n\nmat scene(in vec3 p)\n{\n    vec3 w = p;\n    w.xz = mod(w.xz, 2.) - 1.;\n    float h = 1.-length(floor(p.xz / 2.)) - 2.;\n    h = cos(h + T) + .5;\n    \n    mat p0 = mat(cube(w, vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.5) / Pi, 1.);\n    mat p1 = mat(p.y, vec3(1.5) / Pi, 1.);\n    mat q = uop(p0, p1);\n    \n    // Checking closest neighboring grid cells which are the centered ones\n    // Center Top, Center Below, Center Left, Center Right\n    // Also you must consider the height of each neighboring cell\n    // this can be replaced with a loop.\n    #if AO\n    if (q.z < MIN_S)\n    {\n        h = h = 1.-length(floor((p.xz - vec2( 0.,  2.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCB = mat(cube(w - vec3( 0., 0., -2.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n\n        h = h = 1.-length(floor((p.xz - vec2( 0., -2.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCT = mat(cube(w - vec3( 0., 0.,  2.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n        \n        h = h = 1.-length(floor((p.xz - vec2( 2.,  0.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCL = mat(cube(w - vec3(-2., 0.,  0.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n        \n        h = h = 1.-length(floor((p.xz - vec2(-2.,  0.)) / 2.)) - 2.;\n        h = cos(h + T) + .5;\n        mat pCR = mat(cube(w - vec3( 2., 0.,  0.), vec3(.8, .8 + h, .8), sin(T) * .4 + .4), vec3(1.), 1.);\n        \n        q = uop(q, pCB);\n        q = uop(q, pCT);\n        q = uop(q, pCL);\n        q = uop(q, pCR);\n    }\n    #endif\n    \n    return q;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene(p).z;\n    return normalize(d - vec3(scene(p - e.xyy).z, scene(p - e.yxy).z, scene(p - e.yyx).z));\n}\n\n#define STEPS 255\n#define MAX_S 40.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.z * .2;\n        if (s.z < MIN_S)\n            return mat(t, s.c, s.ao);\n        if (t > MAX_S)\n            break;\n    }\n    return mat(t, vec3(-1.), -1.);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(in vec3 o, in vec3 d, float k)\n{\n    float t = 0.;\n    float ms = 1.;\n    for (int i = 1; i <= 16; i++)\n    {\n        float s = scene(o + d * t).z;\n        ms = min(ms, s / float(i) * k);\n        t += s;\n        if (s < MIN_S)\n            return 0.;\n    }\n    return ms;\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define gd vec3(3., 2.4, 1.8)\n#define sk vec3(3., 2.4, 1.8)\n\n#define l0 vec3(6., 12., 6.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 fc;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n            vec3 o = iMouse.z > 0. ? vec3(sin(ms.x * Pi * 2.), max(ms.y * 3., .35), cos(ms.x * Pi * 2.)) * 9. \n                : vec3(sin(5.), 1., cos(5.)) * 8.;\n            vec3 d = camera(uv, o, vec3(0., 0., 0.));\n            vec3 bg = mix(gd, sk, d.y * .5 + .5);\n            vec3 col;\n\n            mat m = marcher(o, d);\n            if (m.ao != -1.)\n            {\n                vec3 p = o + d * m.z;\n                vec3 n = normal(p);\n                bg = mix(gd, sk, n.y * .5 + .5);\n\n                vec3 l = l0 - p;\n                vec3 ld0 = normalize(l);\n                float att = 1.-map(length(l), 1., .02, .001);\n                float sh = shadow(p + n * .3, ld0, max(32. - length(l), 0.));\n                vec3 diff = max(dot(ld0, n), 0.) * vec3(1.) * att * sh + m.ao / Pi;\n                vec3 ambi = bg * m.ao / Pi;\n                \n                vec3 all_l = ambi + diff;\n\n                col += all_l * m.c;\n            }\n            else\n                col += sk / Pi;\n            fc += col;\n        }\n    }\n\n    fc /= AA * AA;\n    \n    fragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}