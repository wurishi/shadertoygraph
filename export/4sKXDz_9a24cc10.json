{"ver":"0.1","info":{"id":"4sKXDz","date":"1464341946","viewed":480,"name":"Witkin Kass Reaction Diffusion","username":"Antonalog","description":"Yo I heard Reaction Diffusion was cool again!  I was playing with this stuff in the late 90s when it took hours to render and it's more fun now.  This variant allows warping the patterns easily with implicit functions. ","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["texture","diffusion","synthesis","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Makes organic looking reaction diffusion patterns from competing pairs of \"chemicals\"\n//based on this paper: https://www.cs.cmu.edu/~aw/pdf/texture.pdf\n//https://www.cs.cmu.edu/~aw/gifs/space_cookies.gif\n//Challenge for the reader: reproduce the stranger patterns described in the paper!\n\n//convolution mask for stretch factors a,b angle t\nmat3 Aniso(float a, float b, float t)\n{\n    a = a*a;\n    b = b*b;\n    float c = cos(t);\n    float s = sin(t);\n    float cc = c*c;\n    float ss = s*s;\n    float a11= a * cc + b * ss;\tfloat a12 =\t (b-a) * c * s;\n    float a21 = a12;\t\t\tfloat a22 = b * cc + a * ss;\n    mat3 M;\n    M[0][0]=-a12;  \t\tM[0][1]=2.*a22; \t\t\t\t\tM[0][2] = a12;\n    M[1][0]=2.*a11;\t\tM[1][1]=-4.*(a11+a22);\t\t\t\tM[1][2] = 2.*a11;\n    M[2][0]=a12;\t\tM[2][1]=2.*a22;\t\t\t\t\t\tM[2][2] = -a12;\n    return M;\n}\n\nconst float growTime = 3.;\nconst float warpCycleTime = growTime*5.;\nconst float reactionCycleTime = growTime*2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //warp functions\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n   \tvec2 cuv = uv-vec2(1.,0.5);\n    float warp = 0.; \t\t\t\t//not warped\n    \n    if (mod(iTime,warpCycleTime) < growTime)\n\t    warp = atan(cuv.y,cuv.x);\t\t\t\t\t\t//circle\n    else if (mod(iTime,warpCycleTime) < growTime*2.)    \n\t    warp = atan(cuv.y,cuv.x) + 3.1415927*0.125;\t\t//spiral\n    else if (mod(iTime,warpCycleTime) < growTime*3.)\n\t\twarp = sin((cuv.x+cuv.y)*5.)*3.1415927*0.5;\t\t//wave\n    else if (mod(iTime,warpCycleTime) < growTime*4.)\n\t    warp = atan(cuv.y,cuv.x)+3.1415927*0.5;\t\t\t//circle\n        \n    float t = warp;\n    mat3 aniso[4];\n    aniso[0] = Aniso(2., 1.,  t);\n    aniso[1] = Aniso(2., 1.5, t);\n    t = warp + 3.1415927 * 0.5;\t\t\t//perpendicular angle!\n    aniso[2] = Aniso(2., 1.,  t);\n    aniso[3] = Aniso(2., 1.5, t);\n    \n    //3x3 neighbourhood    \n    vec4 old = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n    vec4 old_l = texture(iChannel1, (fragCoord+vec2(-1,0 ))/iChannelResolution[1].xy);\n    vec4 old_r = texture(iChannel1, (fragCoord+vec2( 1,0 ))/iChannelResolution[1].xy);\n    vec4 old_t = texture(iChannel1, (fragCoord+vec2( 0,-1))/iChannelResolution[1].xy);\n    vec4 old_b = texture(iChannel1, (fragCoord+vec2( 0,1 ))/iChannelResolution[1].xy);        \n    vec4 old_tl = texture(iChannel1, (fragCoord+vec2(-1,-1))/iChannelResolution[1].xy);\n    vec4 old_bl = texture(iChannel1, (fragCoord+vec2(-1,1 ))/iChannelResolution[1].xy);        \n    vec4 old_tr = texture(iChannel1, (fragCoord+vec2(1,-1))/iChannelResolution[1].xy);\n    vec4 old_br = texture(iChannel1, (fragCoord+vec2(1,1 ))/iChannelResolution[1].xy);        \n \n    vec4 lap = vec4(0.);    \n    for (int e=0; e<4; e++)\n    {\n        mat3 c = aniso[e];\n        float v = \n\t        c[0][0] * old_tl[e] + c[0][1] * old_t[e] + c[0][2] * old_tr[e] + \n\t        c[1][0] *  old_l[e] + c[1][1] *   old[e] + c[1][2] *  old_r[e] + \n    \t    c[2][0] * old_bl[e] + c[2][1] * old_b[e] + c[2][2] * old_br[e];\n        \n        lap[e] += v;\n\t}\n       \n\n    float k = 1.0; //reaction rate\n\n    //reaction function\n    vec2 D = old.xz - old.yw;\n    \n    float r = 0.;\n    \n    if (mod(iTime,reactionCycleTime) > growTime)\n\t    r = max(D.x, D.y) > 0.03 ? k : 0.;\t//weave: bigger number thinner strands\n    else\n        r = old.x > old.y ? k : 0.;\t\t\t//wibbly stripes\n        \n//    float r = abs(max(D.x, D.y)) > abs(min(D.x, D.y)) ? 0.75 : 0.; //maze ?\n    \n    vec4 b = vec4(1.,1.,1.,1.);\t\t//decay rates    \n    \n    vec4 dC = lap - b * old + r; \n    old += 0.02 * dC;\t\t\t\t//time integration\n    \n    if (mod(iTime,growTime) <= 0.02)\n    {\n\t    //concentrations initialized to random noise in the interval [-1,1]\n\t    vec2 init_coord = fragCoord + iTime*.01234567;    \n\t    vec4 init = texture(iChannel0, init_coord/iChannelResolution[0].xy)*2.-1.;    \n\t    init += texture(iChannel0, init_coord*0.7777777/iChannelResolution[0].xy)*2.-1.;        \n\t    fragColor = init;\n    }\n    else        \n\t    fragColor = old;\n}\n","name":"Buf A","description":"","type":"buffer"}]}