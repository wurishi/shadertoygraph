{"ver":"0.1","info":{"id":"ltjBzK","date":"1516917142","viewed":5129,"name":"Squishy balls","username":"nimitz","description":"aka Inverse metaball\n(Featuring moon-like gravity)","likes":125,"published":1,"flags":32,"usePreview":0,"tags":["sdf","deformation","physics","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Squishy balls by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/ltjBzK\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tThe \"physics\" code is in the Buf A tab\n\t\n\tThe original idea was to create \"inverse metaballs\"\n\tI quickly realized that the shader would benefit from some\n\tbasic physics \n\n\tThe physics side could handle a vast array of balls, but to make them\n\tdeformable means a polynomial increase in sdf computation time not to mention\n\tthat I need to use texture fetches to get the ball position information which\n\tcould be sent as uniform data for more optimal rendering (not possible on shadertoy)\n*/\n\n#define ITR 100\n#define FAR 10.\n#define time iTime\n\nfloat smax(float a, float b)\n{\n    float pw = 14.;\n    float res = exp2(pw*a) + exp2(pw*b);\n    return log2(res)/pw;\n}\n\nfloat sbox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat matid = 0.;\n\nfloat map(vec3 p)\n{\n    vec2 w = 1./iChannelResolution[0].xy;\n    const float dmx = .6;\n    \n    float df = 100.;\n    \n    float d[5];\n    \n    #if 1\n    vec4 sp = textureLod(iChannel0, vec2(1.5, 0.5)*w, 0.);\n    d[0] = length(p - sp.xyz)-sp.w;\n    sp = textureLod(iChannel0, vec2(2.5, 0.5)*w, 0.);\n    d[1] = length(p - sp.xyz)-sp.w;\n    sp = textureLod(iChannel0, vec2(3.5, 0.5)*w, 0.);\n    d[2] = length(p - sp.xyz)-sp.w;\n    sp = textureLod(iChannel0, vec2(4.5, 0.5)*w, 0.);\n    d[3] = length(p - sp.xyz)-sp.w;\n    sp = textureLod(iChannel0, vec2(5.5, 0.5)*w, 0.);\n    d[4] = length(p - sp.xyz)-sp.w;\n    #else\n    d[0] = length(p+vec3(0,sin(time*3.)*0.5,0))-1.;\n    d[1] = length(p+vec3(1.2+cos(time*3.)*1.,sin(time*6.+0.7)*0.5,1))-1.;\n    d[2] = length(p+vec3(.2+cos(time*2.+1.)*1.,-1.2,0))-.9;\n    d[3] = length(p+vec3(.2+cos(time*2.+5.)*1.,-0.2,-.9))-.9;\n    d[4] = length(p+vec3(.2+cos(time*2.+5.)*1.,-0.9,.9))-.9;\n    #endif\n    \n    float dm = 100.;\n    \n    for (int j=0; j<5; j++)\n    {\n        dm = d[j];\n        for (int i=0; i<5; i++)\n        {\n            if (i == j) continue;\n\t\t\tdm = mix(smax(dm, -d[i]),dm, dmx);\n        }\n        if (dm < df) matid = float(j);\n        df = min(df,dm);\n    }\n    \n    \n    float box = - sbox(p, vec3(2.2,2.2,2.2));\n    df = smax(df, -box);\n    \n    return df;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\n//Raytraced box from iq: https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec4 b) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-b.xyz);\n    vec3 k = abs(m)*b.w;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp(occ*-2.+1., 0.0, 1.0 );    \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.1, 0.4 );\n        if( h<0.001 || t>5. ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 lgt = normalize( vec3(-.5, 0.5, -0.2) );\nvec3 lcol = vec3(1.1);\n\n//mostly from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 rd, in vec3 n, in vec3 alb)\n{\n    const float rough = 0.57;\n    float nl = dot(n, lgt);\n    float nv = dot(n, -rd);\n    vec3 col = vec3(0.);\n    float ao = calcAO(pos, n);\n    vec3 f0 = vec3(0.1);\n    if (nl > 0.)\n    {\n        vec3 haf = normalize(lgt - rd);\n        float nh = clamp(dot(n, haf), 0., 1.); \n        float nv = clamp(dot(n, -rd), 0., 1.);\n        float lh = clamp(dot(lgt, haf), 0., 1.);\n        float a = rough*rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(3.14159*dnm*dnm);\n        float k = pow(rough + 1., 2.)/8.; //hotness reducing\n\t\tfloat G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));\n        vec3 F = f0 + (1. - f0) * exp2((-5.55473*lh - 6.98316) * lh);\n        vec3 spec = nl*D*F*G;\n        col.rgb = lcol*nl*(spec + alb*(1. - f0));\n    }\n    col *= shadow(pos, lgt, 0.1,2.)*0.8+0.2;\n    \n    #if 1\n    float bnc = clamp(dot(n, normalize(vec3(-lgt.x,5.0,-lgt.z)))*.5+0.28,0. , 1.);\n    col.rgb += lcol*alb*bnc*0.1;\n    #endif\n    \n    col += 0.05*alb;\n    col *= ao;\n    return col;\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}                           \n\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\nfloat triNoise3d(in vec3 p)\n{\n    p.y *= 0.57;\n    float z=1.5;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<2.; i++ )\n\t{\n        vec3 dg = tri3(bp*.5);\n        p += (dg+0.1);\n\n        bp *= 2.2;\n\t\tz *= 1.4;\n\t\tp *= 1.2;\n        p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.9;\n\t}\n\treturn rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.2,-0.0):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=5.14;\n    vec3 ro = vec3(.0,0.,5.5);\n    vec3 rd = normalize(vec3(p,-1.));\n    mo.x += sin(time*0.1);\n    ro = rotx(ro,mo.y), rd = rotx(rd,mo.y);\n    ro = roty(ro,mo.x), rd = roty(rd,mo.x);\n\n    vec3 bg = sin(vec3(rd.x*1., rd.y*.5 + 1., rd.z*0.2 - 1.5)*.65-1.5)*.45+1.;\n    bg += smoothstep(-0.4,1.,rd.y)*0.6;\n    vec3 col = bg;\n    vec3 brd = rd;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro +rd*rz;\n        vec3 nor = normal(pos);\n        vec3 alb = (sin(vec3(nor.x*.4 + 0., nor.y*.5 + 1., nor.z*0.4 + 4.)*.9 - 4. + matid*1.1))*0.47+0.5;\n        col = shade(pos, rd, nor, alb);\n    }\n    \n    vec2 ib2 = iBox(ro, brd, vec4(0,0,0, 2.2));\n    float brad= 2.28;\n    \n    if(ib2.x>0.0)\n        {\n            if( ib2.y < rz )\n            {\n                vec3 pos = ro + brd*ib2.y;\n                vec3 e = smoothstep( brad-0.15, brad, abs(pos) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(.03), 0.0 + 0.4*al );\n                col *= (triNoise3d(pos*2.)*0.1+0.95)*vec3(.97,1.,.99);\n            }\n            if( ib2.x < rz )\n            {\n                vec3 pos = ro + brd*ib2.x;\n                vec3 e = smoothstep( brad-0.15, brad, abs(pos) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(.03), 0.0 + .4*al );\n                col *= (triNoise3d(pos*2.)*0.17+0.9)*vec3(.97,1.,.99);\n            }\n        }\n        \n\t\n    col = clamp(col,0.,1.);\n    col = pow(col, vec3(0.416667))*1.055 - 0.055;\n    col *= pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), .07); //Vign\n    \n    col *= smoothstep(0.,50., mod(float(iFrame)-1800., 1800.)-18.);\n    col *= smoothstep(1800.,1750., mod(float(iFrame)-1800., 1800.)-18.);\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Squishy balls by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\nfloat sbox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p, vec4[5] sp)\n{\n    float d = 100.;\n    \n    for (int i=0; i<5; i++)\n    {\n    \td = min(length(p-sp[i].xyz)-sp[i].w, d);\n    }\n    \n    float box = - sbox(p, vec3(2.2,2.2,2.2));\n    box = pow(box, 3.); //Cube is a hard surface, increase the distance metric\n    d = min(d, box);\n    \n    return d;\n}\n\nvec3 normal(vec3 p, vec4[5] sp)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;\n\treturn normalize(e.yxx*map(p + e.yxx, sp) + e.xxy*map(p + e.xxy, sp) + \n\t\t\t\t\t e.xyx*map(p + e.xyx, sp) + e.yyy*map(p + e.yyy, sp) );   \n}\n\nvec3 hash3( float n ){return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423))*2.0-1.0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 w = 1./iChannelResolution[0].xy;\n    \n    if (p.y > 2.*w.y)\n        discard;\n    \n    vec4[6] sp;\n    vec4[5] sp2;\n    \n    sp[1] = texture(iChannel0, vec2(1.5, 0.5)*w);\n    sp[2] = texture(iChannel0, vec2(2.5, 0.5)*w);\n    sp[3] = texture(iChannel0, vec2(3.5, 0.5)*w);\n    sp[4] = texture(iChannel0, vec2(4.5, 0.5)*w);\n    sp[5] = texture(iChannel0, vec2(5.5, 0.5)*w);\n    \n    vec4[6] sv;\n    \n    sv[1] = texture(iChannel0, vec2(1.5, 1.5)*w);\n    sv[2] = texture(iChannel0, vec2(2.5, 1.5)*w);\n    sv[3] = texture(iChannel0, vec2(3.5, 1.5)*w);\n    sv[4] = texture(iChannel0, vec2(4.5, 1.5)*w);\n    sv[5] = texture(iChannel0, vec2(5.5, 1.5)*w);\n    \n    if (iFrame%1800 == 20)\n    {\n        sp[1] = vec4(0, 0.9, 1, 1);\n        sp[2] = vec4(1, 0.5, 0, 0.95);\n        sp[3] = vec4(-1, -0.5, 1, 0.9);\n        sp[4] = vec4(1, -0.2, 1, 0.85);\n        sp[5] = vec4(-0.5, 0.5, -1.5,0.8);\n        \n        sv[1] = vec4(hash3(float(iFrame)), 0)*0.04;\n        sv[2] = vec4(hash3(float(iFrame+1)), 0)*0.06;\n        sv[3] = vec4(hash3(float(iFrame+2)), 0)*0.06;\n        sv[4] = vec4(hash3(float(iFrame+3)), 0)*0.06;\n        sv[5] = vec4(hash3(float(iFrame+4)), 0)*0.06;\n    }\n    \n    float cp = fragCoord.x;\n    vec4 csp = vec4(0);\n    vec4 csv = vec4(0);\n    float td = 100.;\n    int cnt = 0;\n    \n    //split into the current object and the rest\n    for (int i=1; i<6; i++)\n    {\n        if (i == int(cp))\n        {\n            csp = sp[i];\n            csv = sv[i];\n        }\n        else\n        {\n            sp2[cnt] = sp[i];\n            cnt++;\n        }\n    }\n    \n    //evaluate the movement of the current object\n    vec3 nor = normal(csp.xyz, sp2);\n    float dst = map(csp.xyz, sp2);\n#if 0\n    //csv.xyz += (nor*0.0025*(exp(-dst*7. + 1.5))); //Repulsion\n    csv.xyz += (nor*0.002*(exp(-dst*7. + 2.))); //Repulsion\n    csv.xyz *= clamp(1.5*(abs(dst)),0.,1.)*0.01+0.99; //internal and external friction\n#else\n    csv.xyz += (nor*0.0025*(exp(-dst*8. + 1.75))); //Repulsion\n    csv.xyz *= clamp(1.5*(abs(dst)),0.,1.)*0.006+0.994; //internal and external friction\n#endif\n    csv.y -= 0.0001; //gravity\n    csv.xyz = clamp(csv.xyz, vec3(-0.5), vec3(0.5)); //Sanity\n    csp.xyz += csv.xyz;\n    \n    vec4 ret = vec4(0);\n    \n    if (fragCoord.y < 1.0)\n    {\n        ret = csp;\n    }\n    else\n        ret = csv;\n    \n    fragColor = ret;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}