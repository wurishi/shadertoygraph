{"ver":"0.1","info":{"id":"ctfXRN","date":"1674343527","viewed":122,"name":"3D bump fake","username":"ianertson","description":"Fake 3D bump map","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","fake","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64\n#define NEAR 0.02\n#define FAR 200.0\n\n#define UV_SCALE 32.0\n\n#define TAU 6.283185\n#define ONE(g) clamp(g, 0.0, 1.0)\n#define T (iTime*0.3)\n\n\nvec3 grass(vec2 uv) {\n    return texture(iChannel2, uv).rgb;\n}\n\nvec3 extractBumpGrass(float scale, vec2 uv, vec3 normal) {\n    vec3 color = texture(iChannel2, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(FAR);\n    vec3 dx = texture(iChannel2, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(iChannel2, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033*0.6));\n    return normalize(normal+n);\n}\n\n\n\nmat2 rot(float a) {\n    float s = sin(a); \n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n#define ENTITY_NONE 0\n#define ENTITY_GRASS 1\n#define ENTITY_ROCK 2\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    int entity;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat getDistPlane(vec3 p, vec3 normal, vec3 pos) {\n    return dot(p, normal) + length(pos * normal);\n}\n \n\nfloat getDist(vec3 p, inout int entity) {\n  \n\n    vec3 uv = p / FAR;\n    vec2 uv2 = (uv.xz + uv.y);\n    \n    vec3 bump = grass(uv2*UV_SCALE);//extractBumpGrass(1.0, uv2 * UV_SCALE, vec3(0.0));\n    float lum = luma(bump);\n    \n    float plane = getDistPlane(p, vec3(0, 1, 0), vec3(0, -1.6, 0));\n    \n    plane *= max(0.0, 1.0 - sqrt(lum*1.009));\n    \n    \n    \n    entity = ENTITY_GRASS;\n\n    return plane;\n}\n\nfloat getDist(vec3 p) {\n    int entity = 0;\n    return getDist(p, entity);\n\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.1, 0.0);\n    \n    return normalize(getDist(p) - vec3(\n        getDist(p+e.xyy),\n        getDist(p+e.yxy),\n        getDist(p+e.yyx)\n    ));\n}\n\nvec2 getUv(vec3 p, in Data data, int entity) {\n    if (entity == ENTITY_ROCK) {\n        p = data.normal;\n        float u = atan(p.x, -p.z) / (2. * M_PI) + .5;\n        float v = p.y * .5 + .5;\n        return vec2(u, v);\n    }\n    vec3 uv = p / FAR;\n    \n    return (uv.xz + uv.y);\n}\n\nData getData(vec3 p) {\n    Data data;\n    data.dist = getDist(p, data.entity);\n    data.normal = getNormal(p);\n    data.uv = getUv(p, data, data.entity);\n    \n    return data;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        data = getData(p);\n        dist += data.dist;\n        \n        if (abs(data.dist) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    data.dist = dist;\n    data.point = ro+rd*dist;\n    return data.dist < FAR;\n}\n\n\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 render(vec3 ro, vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    Data data;\n    \n    \n    if (march(ro, rd, data)) {\n        vec2 uv = data.uv;\n        \n        vec3 albedo = vec3(0.0);\n        \n        vec3 normal = data.normal;\n        \n        if (data.entity == ENTITY_GRASS) {\n            float uvScale = UV_SCALE;\n            albedo = grass(data.uv*uvScale);\n            normal = normalize(mix(normal, extractBumpGrass(uvScale, data.uv*uvScale, data.normal), 0.6));\n        } \n        float distLight = distance(data.point, light.pos);\n        vec3 L = normalize(data.point - light.pos);\n        float NdotL = max(0.0, dot(normal, L));\n        float att = NdotL * (pow(light.strength, 2.0) / max(0.0001, pow(distLight, 2.0)));\n        \n        float occlusion = 0.0;\n        vec3 ocPos = light.pos;\n        Data ocData;\n        if (march(ocPos, L, ocData) && ocData.entity != data.entity && ocData.dist < distLight) {\n            occlusion = distLight / max(0.0001, ocData.dist);\n            occlusion *= 0.64;\n        }\n        \n        att *= (1.0 - occlusion);\n        \n        \n        col += albedo * att;\n    }\n    return col;\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*iResolution.xy)/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 3., -10.0);\n    \n    Light light = Light(vec3(1.0, 6.0, -2.0), vec3(1.0), 8.0);\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(-m.y*M_PI+1.);\n        ro.xz *= rot(-m.x*TAU);\n        ro.y = max(ro.y, 2.5);\n    } else {\n        ro.xz *= rot(T);\n    }\n    vec3 rd = getRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    col += render(ro, rd, light);\n    \n    \n    \n    col = tonemap(col);\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265359\n\nfloat noise0(vec2 uv) {\n    uv += 0.5;\n    uv.y = fract(uv.y * 10.033415);\n    uv.x = fract(uv.x * 10.082715);\n    float a = fract(cos(uv.x*256.0))*10.0;\n    float b = fract(sin(uv.y*256.0))*10.0;\n    float c = fract(dot(vec2(a, b), uv));\n    float d = fract(tan(a+b+c) * dot(uv, vec2(c, b*c)));\n    float e = fract(sin(d*10.0) * dot(uv, vec2(d, c)));\n    float f = fract(cos(c*10.0+a-b) * dot(vec2(c, d), vec2(e, b)));\n    float ma = 23516.0;\n    return float(int((113.023123+(f*10.0)*ma))%int(ma)) / ma;\n}\n\nfloat noise1(vec2 uv) {\n    float x = noise0(uv+vec2(0.0213, 1.2013))*10.0;\n    float y = noise0(uv-vec2(9.2132, 3.7938))*10.0;\n    return fract(sin((x+y+uv.x+uv.y)*3.161246)*dot(uv, vec2(x,y)));\n}\n\nfloat noise(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv));\n    float a = noise1(id);\n    float b = noise1(id+vec2(1.0, 0.0));\n    float c = noise1(id+vec2(0.0, 1.0));\n    float d = noise1(id+vec2(1.0, 1.0));\n    return mix(mix(a, b, lv.x), mix(c, d, lv.x), lv.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}