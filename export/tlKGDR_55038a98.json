{"ver":"0.1","info":{"id":"tlKGDR","date":"1579229629","viewed":118,"name":"Self Reflection","username":"pocketCoffee","description":"Little water experiment to get my feet wet in noise and height maps.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.0\n#define EPSILON 0.001\n   \nstruct Mat{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 shininess;\n};\n\nstruct Hit{\n    float d;\n\tMat mat;\n};\n    \nstruct Light{\n\tvec3 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool isHit = false;\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n      return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 rep(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\n// Noise\nfloat hash(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z); \n}\n\nfloat noise(vec2 x){\n    // Make the waves move\n    x += iTime;\n    x *= .25;\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    float m = mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n\treturn m;\n}\n\nfloat fbm(vec2 x){\n    x *= .3;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );// * iTime*.002;\n    float f = 0.0;\n\tf  = 0.5000*noise(x); \n    x = m*x;\n\tf += 0.2500*noise(x); \n    x = m*x;\n\tf += 0.1250*noise(x); \n    x = m*x;\n\tf += 0.0625*noise(x); \n    return f;\n}\n\nfloat waterHeight(vec2 p){\n    float time = iTime * 0.3;\n    float h = fbm(p*time*.05)*1.2;\n    // Maximize induced nausea by adding more waves\n    h += sin(iTime *.7 + dot(vec2(.3, .1), p));\n    h += sin(iTime *.2 + dot(vec2(.1, .7), p));\n    return h;\n}\n\n// Materials\nMat waterMat = Mat(vec3(.2, .4, .6), vec3(.4, .7, .6), vec3(.5), vec3(1.)); // Water material\nMat redMat = Mat(vec3(.8, .2, .3), vec3(.8, .2, .2), vec3(.3), vec3(0.0)); // Red material\nHit hit; // Global hit that saves material\n\n// Scene map\nHit map(vec3 p){\n\tfloat ground = box(rep(p + vec3(0., 3., 1.1), vec3(0., 0., 1.)), vec3(15., 2.*waterHeight(p.xz)*.07+2., 2.));\n    float ceiling = box(rep(p + vec3(0., -3., 1.1), vec3(0., 0., 1.)), vec3(15., 2.*waterHeight(p.xz)*.05+1.8, 2.));\n    float ball = sphere(p + vec3(0.3, 0.9, .7), .5);\n    \n    float result = min(ground, ceiling);   \n    result = min(result, ball);\n    hit.d = result;\n    if(result == ball){\n        hit.mat = redMat;\n    }\n    else{\n        hit.mat = waterMat;\n    }\n    return hit;\n}   \n\nvec3 march(vec3 ro, vec3 rd){\n    float dt = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dt * rd;\n        p.y += sin(p.z - iTime * 2.) * .03; // Makes everything all wavey\n        Hit mhit = map(p);\n        float dist = mhit.d;\n        if(dist < MIN_DIST){\n            isHit = true;\n            hit.mat = mhit.mat;\n            break;\n        }\n        dt += dist*0.925;\n    }\n    return ro + dt * rd;\n}\n\nvec3 normals(vec3 p){\n    const vec2 eps = vec2(EPSILON, 0);\n    return normalize(vec3(map(p + eps.xyy).d - map(p - eps.xyy).d,\n                          map(p + eps.yxy).d - map(p - eps.yxy).d,\n                          map(p + eps.yyx).d - map(p - eps.yyx).d));\n}\n\nvec4 light(vec3 p, vec3 rd, Light mLight, Mat mat, vec3 n){\n    \n    vec3 l = normalize(mLight.pos - p);\n        \n    // Ambient\n    float ambientStr = 0.8;\n    vec3 ambient = ambientStr * mLight.ambient;\n    \n    // Diffuse\n    float dif = max(dot(n, l), 0.0);\n    vec3 diffuse = dif * mLight.diffuse;\n    \n    // Specular\n    vec3 viewDir = normalize(rd - p);\n    vec3 reflectDir = reflect(-l, n);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    float specularStr = 12.;\n    vec3 specular = mLight.specular * (spec * mat.specular * specularStr);\n    \n    return vec4((diffuse * mat.diffuse + ambient * mat.ambient + specular * mat.shininess) , 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= ar;\n    \n    //vec3 camPos = vec3(0, -.3, fract(iTime*.1)*24.);\n    vec3 camPos = vec3(0.1, 0.1, 0.1);\n    camPos.zx *= rot(iTime);\n    camPos.z -=5.;\n    vec3 ro = camPos;\n    vec3 rd = vec3(uv, 1.0);\n    \n    vec3 p = march(ro, rd);\n    vec3 n = normals(p); // Calculating normals\n    p.y += sin(p.z - iTime * 2.) * .3; // Also appears within march\n    \n    vec4 col = vec4(0.0);\n    \n    if ( isHit == true){\n        vec3 lightPos = vec3(0, 2., -8.);\n    \tLight mLight = Light(lightPos, vec3(.3), vec3(.9), 0.5 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4)));\n        \n        vec3 fp = floor(p * 3. + fract(iTime)); // Checkerboard pattern\n        col = light(p, rd, mLight, hit.mat, n);\n        //if(hit.mat == waterMat){\n        // Reflections\n        vec3 reflection = reflect(rd, n);\n        vec3 refraction = refract(rd, n, 5.);\n    \tvec3 rp = march(rd, reflection);\n        vec3 rn = normals(rp);\n        vec4 reflCol = light(rp, reflection, mLight, hit.mat, rn);\n        //reflCol.rgb += refraction;\n        //reflCol.rgb *= hit.mat.shininess;\n    \n    \tcol *= reflCol * vec4(hit.mat.shininess, 1.0) * 4.;\n        //}\n        //col *= vec4(vec3(mod(fp.x + fp.z, 2.)), 1.); // Add checkerboard\n        //vec2 coord = fragCoord.xy * 0.1 - vec2(iTime * 5.0, iResolution.y / 2.0);\n        //col *= fbm(p.xz*iTime*.01)*3.; // Shows the height map\n        \n    }\n    else{\n        col = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)),1.0);\n        //col = vec4(.7, .2, .4, 1.0);\n        col *= .05;\n    }\n\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}