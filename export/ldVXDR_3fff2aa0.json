{"ver":"0.1","info":{"id":"ldVXDR","date":"1463900365","viewed":379,"name":"Volume Scattering","username":"soma_arc","description":"Volume rendering experiment\nThis code is based on Production Volume Rendering (http://magnuswrenninge.com/productionvolumerendering)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float PI = 3.14159265359;\nconst float EPSILON = 0.001;\nconst vec3 BLACK = vec3(0);\n\nconst float PI_4 = 12.566368;\nconst float k_isotropic = 1. / 12.566368;\n\n// PVR p297\nvec3 lightIntensity(vec3 lightPos, vec3 lightPower, vec3 p){\n\tvec3 dir = lightPos - p;\n    return lightPower * (1. / dot(dir, dir));\n}\n\nfloat lightVisibility(vec3 lightPos, vec3 w){\n\t// There is no objects\n    return 1.0;\n}\n\n// PVR p301\nfloat phaseFunction(vec3 w, vec3 w_light){\n\t// isotropic phase function 1/(4 * PI)\n    return k_isotropic;\n}\n\nconst vec3 lightPos = vec3(0, 1.5, 0);\nconst vec3 lightPower = vec3(2.);\n// PVR p186 Code 10.2\nvec3 integrateScattering(vec3 p, vec3 w){\n    const float current = 0.;\n    const float end = 10.;\n    const float stepSize = .1;\n    // Integration variables\n    vec3 T = vec3(1.);\n    vec3 L = vec3(0.);\n\t// Integration loop\n    for(float current = 0. ; current < end ; current += stepSize){\n    \t// Determine sample position\n        vec3 p_i = p + w * current;\n        // Sample volume properties (This is constant volume)\n        vec3 sigma_s = vec3(1. * (1. + sin(iTime)), 1., 1.);\n        //vec3 sigma_s = vec3(1. , 1., 1.);\n        \n        // Compute change in transmittance\n        vec3 T_i = vec3(exp(-sigma_s.x * stepSize),\n                         exp(-sigma_s.y * stepSize),\n                         exp(-sigma_s.z * stepSize));\n        // Update accumulated transmittance\n        T *= T_i;\n        \n        //Sample light source\n        vec3 w_light = lightPos - p_i;\n        vec3 L_light = lightIntensity(lightPos, lightPower, p_i);\n        L_light *= lightVisibility(lightPos, p_i);\n        // Accumulate reflected light\n        L += T * sigma_s * phaseFunction(w, w_light) * L_light;\n            \n    }\n    return L;\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \treturn l + integrateScattering(eye, ray);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 eye = vec3(0, 0, 3);\nconst vec3 target = vec3(0., 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}","name":"Image","description":"","type":"image"}]}