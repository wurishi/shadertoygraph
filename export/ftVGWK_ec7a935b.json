{"ver":"0.1","info":{"id":"ftVGWK","date":"1638365883","viewed":93,"name":"Spherical triangle groups","username":"TotallyReal","description":"Use reflections of triangles on the sphere to tile it, and color it according to the texture.\nSee also the standard Euclidean version here : https://www.shadertoy.com/view/7lV3Wy ,\nand the hyperbolic version here :  https://www.shadertoy.com/view/NtyGW1  ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tiling","spherical","trianglegroup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nA bit about triangle groups:\n\nStart with one triangle and take its reflections through each of its edges. Then for each reflection, \ntake its reflection through each of its edges (one of them will be the original triangle). Continue like\nthis until you cover the whole plane.\n\nIn general, the triangles that we get this way can intersect one another. To avoid messy images, if\ntwo such triangles intersect, we want them to be exactly the same. For example, if we look at triangle \nreflections around a single vertex, they all have the same angle near that vertex. Hence, this angle must\ndivide 2*PI for this overlap=identical condition, and unless the triangle is an isosceles triangle, the\nangle must divide PI. In other words all the angles should be of the form PI/N for some integer N.\n\nWe now have the three angles PI/L, PI/N and PI/M.\nIn the Euclidean geometry, the sum of the angles in a triangle is PI, so that 1/L + 1/M + 1/N = 1.\nHowever, in the spherical geometry the sum is more than PI, or equivalently 1/L + 1/M + 1/N > 1.\n\nIn the spherical geometry, \"straight line\" correspond to large circles, namely circles which have the same \nradius as the sphere. These are the pathes of shortest distance on the sphere, and we can define triangles\nusing 3 such large circles.\n\nOnce you have such a single trianle, we can move each point outside the triangle into it using a sequence of \nreflections through the large circles defining it. If a point is not inside the triangle, then one of the circles\nseparates it from the triangle, so we take its reflection though that circle (change the ONLY_TRIANGLE\nto true to see the 3 circles defining the triangle). A bit of math magic shows that each point will eventually \nfind its way into your original triangle, and no matter the order of your reflections, \nit will end up at the same place.\n\nFinally, add some texture to your triangle, and use the procedure above to spread it out to the whole plane.\n\nTo see such triangle tiling in the Euclidean geometry (so 1/L + 1/M + 1/N = 1) see : \nhttps://www.shadertoy.com/view/7lV3Wy\n\nand in the hyperbolic geometry (1/L + 1/M + 1/N < 1) see :\nhttps://www.shadertoy.com/view/NtyGW1\n\nand all of them together:\nhttps://openprocessing.org/sketch/1375921\n\n*/\n\n// Only see the triangle which is the fundamental\n// domain (from which we take the texture and reflect it).\nconst bool ONLY_TRIANGLE = false;\n\n// darken domains which need odd number of steps to get to the main fundamental domain.\nconst bool SHOW_REFLECTIONS = false;\n\n// ------------------------------ Fundamental domains ------------------------------\n\nconst int MAX_STEPS = 16;\n\nstruct Reflection {\n    vec3 normal;\n};\n\nconst float PI = 3.1415926535897;\n\n// Condition: 1/L + 1/M + 1/N > 1 .\nconst float L = 2.;\nconst float N = 3.;\nconst float M = 3.;\n// The angle theta between two large circles in the sphere defined by their normals U,V is PI-angle(U,V).\n// Hence, we need to check that\n//             <U, V> = cos(angle(U,V)) = cos(PI-theta) = -cos(theta).\nconst Reflection reflection1 = Reflection(vec3(1.,0.,0.));\nconst Reflection reflection2 = Reflection(vec3(-cos(PI/N),sin(PI/N),0.));\nconst float TEMP = -( cos(PI/N)*cos(PI/M) + cos(PI/L) )/sin(PI/N);\nconst Reflection reflection3 = Reflection( vec3(-cos(PI/M), TEMP, sqrt(1.-TEMP*TEMP-cos(PI/M)*cos(PI/M))));\n\n\n\nint reflectThrough(vec3 point, Reflection ref, out vec3 result){\n    float alpha = dot(point, ref.normal);\n    if (alpha>=0.){\n        result = point;\n        return 0;\n    }\n    result = point - 2.*alpha*ref.normal;\n    return 1;\n}\n\n// assumption: point.y>0 (positive imaginary part).\nvec3 toFundamentalDomainTriangle(vec3 point, out int reflections){\n    reflections = 0;\n    int steps = 0;\n    while (steps<MAX_STEPS){\n        int extra = \n            reflectThrough(point, reflection1, point) +\n            reflectThrough(point, reflection2, point) +\n            reflectThrough(point, reflection3, point);\n        if (extra==0)\n            return point;\n        reflections += extra;\n        steps ++;            \n    }\n    return point;\n\n}\n\n\n// ------------------------------ geometric actions ------------------------------\n\nmat2 rotation(float angle){\n    return mat2(\n        cos(angle), sin(angle), \n        -sin(angle), cos(angle)\n        );\n}\n\nmat3 rotationX(float angle){\n    return mat3(\n        1., 0., 0.,\n        0., cos(angle), sin(angle), \n        0., -sin(angle), cos(angle)\n        );\n}\n\nmat3 rotationY(float angle){\n    return mat3(\n        cos(angle), 0., sin(angle), \n        0., 1., 0.,\n        -sin(angle), 0., cos(angle)\n        );\n}\n\nmat3 rotationZ(float angle){\n    return mat3(\n        cos(angle), sin(angle), 0.,\n        -sin(angle), cos(angle), 0.,\n        0., 0., 1.\n        );\n}\n\nmat2 shearing(float t){\n    return mat2(1., t, 0., 1.);\n}\n\n\n// ------------------------------ main ------------------------------\n\nconst vec3 OUT_OF_BOUNDS = vec3(0.);\n\n/**\n * Transform the fragCoord to the coordinate in our spherical space (x,y,z) with x^2+y^2+z^2=1.\n */\nvec3 spaceCoordinate(vec2 fragCoord){\n    \n    // Normalized pixel coordinates (height goes from 0 to 1, and keep the ratio with the width)\n    vec2 uv = 2.2*(fragCoord-iResolution.xy/2.)/iResolution.y;\n\n    float d = length(uv);\n    d *= d;\n    if (d > 1.)\n        return OUT_OF_BOUNDS; // is not in the sphere\n    return vec3(uv.xy, sqrt(1.-d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 v = spaceCoordinate(fragCoord);\n    if (v==OUT_OF_BOUNDS){\n        fragColor = vec4(0., 0., 0. ,1.0); // black\n        return;\n    }\n    \n    // add dynamics - move the whole tiling.\n    v = rotationY(iTime/3.)*v;\n    v = rotationZ(iTime/2.)*v;\n    \n    if (ONLY_TRIANGLE){\n        // Use this part to see the triangle which is the fundamental\n        // domain (from which we take the texture and reflect it).\n        vec3 result;\n        fragColor = vec4(\n            float(reflectThrough(v, reflection1, result)),\n            float(reflectThrough(v, reflection2, result)),\n            float(reflectThrough(v, reflection3, result)),\n            1.);\n        return;\n    }\n    \n    \n    // move to fundamental domain \n    int reflections = 0;\n    vec3 u = toFundamentalDomainTriangle(v, reflections);\n    \n    reflections %= 2;\n    \n    // To XY coordinates, so we could use texture\n    vec2 uv = u.xz;\n    \n    // add second dynamics to move the location in the texture from which we choose the pixels.\n    uv += 2.*vec2(cos(iTime/7.), sin(-iTime/5.));\n    uv *= (cos(iTime/10.)*0.2 + 0.6);\n    uv = rotation(iTime/8.)*uv;\n    \n    vec3 pixel = 1.2*texture(iChannel0, uv).rgb;\n\n    if (SHOW_REFLECTIONS){\n        pixel = (3.*pixel+vec3(float(reflections), 1.-float(reflections),0.))/4.;\n    }\n\n    // Output to screen\n    fragColor = vec4(uv*float(reflections), 0. ,1.0);\n    fragColor = vec4(pixel, 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}