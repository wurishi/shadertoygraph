{"ver":"0.1","info":{"id":"XX2XWD","date":"1710946319","viewed":57,"name":"Erosion Simulations","username":"hschott","description":"Simulating separetely fluvial erosion (stream power), thermal erosion and sediment deposition.\nScreen split can be moved with the mouse.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["terrain","erosionsimulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 Rz(float a) {\n    a = a * 3.14159 / 180.;\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\nmat3 Rx(float a) {\n    a = a * 3.14159 / 180.;\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(1., 0., 0., 0., ca, sa, 0., -sa, ca);\n}\n\nmat3 Ry(float a) {\n    a = a * 3.14159 / 180.;\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, 0., -sa, 0., 1., 0., sa, 0., ca);\n}\n\nvec3 RxC(vec3 p, float a, vec3 c) {\n    return Rx(a) * (p - c) + c;\n}\n\nvec3 RyC(vec3 p, float a, vec3 c) {\n    return Ry(a) * (p - c) + c;\n}\n\nvec3 RzC(vec3 p, float a, vec3 c) {\n    return Rz(a) * (p - c) + c;\n}\n\nvoid Ray(vec2 m, vec2 p, out vec3 ro, out vec3 rd) {\n  float a = -0.05 * iTime;//3. * m.x;\n  float le = 3.5;\n  \n  // Origin\n  ro = vec3(37., 0., 15.);\n  ro = vec3(15., 0., 9.);\n  ro = vec3(40., 0., 20.);\n  ro *= Rz(a * 360.);\n  \n  // Target point\n  vec3 ta = vec3(0., 0., -1.);\n  \n  // Orthonormal frame\n  vec3 w = normalize(ta - ro);\n  vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n  vec3 v = normalize(cross(u, w));\n  rd = normalize(p.x * u + p.y * v + le * w);\n}\n\n\nfloat Plan(vec3 p, vec3 c, vec3 n) {\n    return dot(p - c, n);\n}\n\nfloat Inter(float a, float b) {\n    return max(a, b);\n}\n\nvec2 ToBufferSpace(vec3 p) {\n    vec2 p_norm = 1. * (p.xy + 1. * vec2(20, 20)) / (2. * vec2(20, 20));\n    p_norm *= iResolution.y;\n    return p_norm;\n}\n\nfloat Scene(vec3 p, vec2 pixel) {\n  float v = 1000000.;\n  \n  vec3 c = vec3(0., 0., 0.);\n  float l = 20.;\n  float w = 4.;\n  float d = 4.;\n  \n  // Terrain\n  vec2 mouse = iMouse.xy;\n  if (mouse.y <= 2.) mouse = 0.1 + iResolution.xy * 0.5;\n  float n;\n  if (pixel.y < mouse.y) n = HeightNice(ToBufferSpace(p));\n  else n = Terrain(ToBufferSpace(p));\n  \n  v = 2. + p.z - n;\n  \n  v = Inter(v, length(p) - l);\n  \n  return v;\n\n}\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05;\n\nvec3 SceneNormal(vec3 p, vec2 pixel) {\n  const float eps = 0.001;\n  vec3 n;\n  float v = Scene(p, pixel);\n  n.x = Scene(vec3(p.x + eps, p.y, p.z), pixel) - v;\n  n.y = Scene(vec3(p.x, p.y + eps, p.z), pixel) - v;\n  n.z = Scene(vec3(p.x, p.y, p.z + eps), pixel) - v;\n  return normalize(n);\n}\n\n\nfloat SphereTrace(vec2 pixel, vec3 o, vec3 u, float e, out bool h, out int s) {\n  h = false;\n  \n  float t = 0.;\n  \n  for(int i = 0; i < Steps; i++) {\n    s = i;\n    vec3 p = o + t * u;\n    float v = Scene(p, pixel);\n    // Hit object\n    if(v < 0.) {\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += 0.1 * max(Epsilon,v);\n    // Escape marched too far away\n    if(t > e) {\n      break;\n    }\n  }\n  return t;\n}\n\n\nvec3 background(vec3 d) {\n    return vec3(0.3);//vec3(0.2, 0.2, 0.2);\n}\n\n\nvec3 Shade(vec3 p, vec3 n, vec3 e, vec2 pxy) {\n  vec2 mouse = iMouse.xy;\n  if (mouse.y <= 2.) mouse = 0.1 + iResolution.xy * 0.5;\n\n  vec3 lp = vec3(5.,10.,25.);\n  vec3 l = normalize(lp - p);\n\n  vec3 ambient = vec3(0.3);\n    \n  vec3 color_rock = 0.2 * (2. * Turbulence(5. * p) - 1.) + vec3(240, 237, 228) / 255.;//vec3(255, 203, 100) / 255.;\n  vec3 color_depo = 0.2 * (2. * Turbulence(5. * p) - 1.) + vec3(73, 135, 66) / 255.;//vec3(140, 100, 80) / 255.;\n  \n  vec3 color = color_rock;\n  if (Depo(ToBufferSpace(p)) > 0.02 && pxy.y < mouse.y) color = color_depo;\n  \n  float spec = 0.05;\n  \n  float cos_light = dot(n, l);\n  vec3 diffuse = 0.4 * clamp(cos_light, 0., 1.) * vec3(1);\n  \n  if (cos_light < 0.) {\n      diffuse = vec3(1.);\n      color = vec3(0.2);\n      ambient = vec3(0);\n      spec = 0.;\n  }\n  \n  \n  if (abs(pxy.y - mouse.y) < 1. || abs(pxy.x - mouse.x) < 1.) {\n      return vec3(0);\n  } else if (pxy.x > mouse.x) {\n      color = 0.2 * (vec3(3) + 2. * n);\n      spec = 0.;\n      diffuse = vec3(1);\n      ambient = vec3(0);\n  }\n\n  diffuse *= color;\n  \n  // Specular\n  vec3 r = reflect(e, n);\n  vec3 specular = spec * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n  vec3 c = ambient + (diffuse + specular);\n  return c;\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy) {\n  \n  // Pixel\n  vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n  \n  // Mouse\n  vec2 m = iMouse.xy / iResolution.xy;\n  \n  // Camera\n  vec3 ro, rd;\n  Ray(m, pixel, ro, rd);\n    \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t = SphereTrace(pxy, ro, rd, 100., hit, s);\n  \n  // Shade background\n  vec3 rgb = background(rd);\n  \n  if(hit) {\n    // Position\n    vec3 p = ro + t * rd;\n    \n    // Compute normal\n    vec3 n = SceneNormal(p, pxy);\n    \n    // Shade object with light\n    rgb = Shade(p, n, rd, pxy);\n  }\n  color = vec4(rgb, 1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define P(x,y) pow(texelFetch(tex, pi + ivec2(x,y), 0), vec4(1.))\nconst mat4 W = mat4( 0,-1, 2,-1,  2, 0,-5, 3,  0, 1, 4,-3,  0, 0,-1, 1);\n\nvec4 textureNice(sampler2D tex, vec2 p) {\n    p -= .5;\n    ivec2 pi = ivec2(floor(p));\n    vec2 pf = fract(p);\n\n    vec4 fnn = P(-1,-1),  f0n = P( 0,-1),  f1n = P( 1,-1),  f2n = P( 2,-1);\n    vec4 fn0 = P(-1, 0),  f00 = P( 0, 0),  f10 = P( 1, 0),  f20 = P( 2, 0);\n    vec4 fn1 = P(-1, 1),  f01 = P( 0, 1),  f11 = P( 1, 1),  f21 = P( 2, 1);\n    vec4 fn2 = P(-1, 2),  f02 = P( 0, 2),  f12 = P( 1, 2),  f22 = P( 2, 2);\n\n    #define S(t,fn,f0,f1,f2) dot(.5 * t * W, vec4(fn, f0, f1, f2))\n    #define S4(t,fn,f0,f1,f2) vec4(S(t, fn.r, f0.r, f1.r, f2.r),\\\n                                   S(t, fn.g, f0.g, f1.g, f2.g),\\\n                                   S(t, fn.b, f0.b, f1.b, f2.b),\\\n                                   S(t, fn.a, f0.a, f1.a, f2.a))\n\n    vec4 vx = vec4(1, pf.x, pf.x*pf.x, pf.x*pf.x*pf.x);\n    vec4 vy = vec4(1, pf.y, pf.y*pf.y, pf.y*pf.y*pf.y);\n\n    vec4 bn = S4(vx, fnn, f0n, f1n, f2n);\n    vec4 b0 = S4(vx, fn0, f00, f10, f20);\n    vec4 b1 = S4(vx, fn1, f01, f11, f21);\n    vec4 b2 = S4(vx, fn2, f02, f12, f22);\n        \n    return S4(vy, bn, b0, b1, b2);\n}\n\n#define buffA(p) texture(iChannel0, (p)/iResolution.xy)\n#define Height(p) buffA(p).x\n#define Flow(p) buffA(p).y\n#define Sed(p) buffA(p).z\n#define Depo(p) buffA(p).w\n\n#define buffANice(p) textureNice(iChannel0, p)\n#define HeightNice(p) buffANice(p).x\n#define FlowNice(p) buffANice(p).y\n#define SedNice(p) buffANice(p).z\n#define DepoNice(p) buffANice(p).w\n\nfloat Hash(vec3 p) {\n    p  = fract(p * 0.3199 + 0.152);\n\tp *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat Hash4(vec3 p) {\n\tp.x = float(int(p.x) % 20) + fract(p.x);\n    p  = fract(p * 0.3199 + 0.152);\n\tp *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat Noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix( Hash(i + vec3(0, 0, 0)), \n                        Hash(i + vec3(1, 0, 0)), f.x),\n                   mix( Hash(i + vec3(0, 1, 0)), \n                        Hash(i + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix( Hash(i + vec3(0, 0, 1)), \n                        Hash(i + vec3(1, 0, 1)), f.x),\n                   mix( Hash(i + vec3(0, 1, 1)), \n                        Hash(i + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\nfloat Noise4(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix( Hash4(i + vec3(0, 0, 0)), \n                        Hash4(i + vec3(1, 0, 0)), f.x),\n                   mix( Hash4(i + vec3(0, 1, 0)), \n                        Hash4(i + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix( Hash4(i + vec3(0, 0, 1)), \n                        Hash4(i + vec3(1, 0, 1)), f.x),\n                   mix( Hash4(i + vec3(0, 1, 1)), \n                        Hash4(i + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\nfloat Turbulence(vec3 p) {\n    float t = 2. * Noise(0.5 * p) + Noise(p) + 0.5 * Noise(2. * p) + 0.1 * Noise(10. * p);\n    return t / (2. + 1. + 0.5 + 0.1);\n}\n\nfloat Softness(vec2 p) {\n    return Turbulence(0.1 * vec3(p, -12.365));\n}\n\nvec3 dir = normalize(vec3(1., 0., 0.));\n\nfloat Terrain(vec2 p) {\n    float low_freq  = 4. * Noise(vec3(25.3658, 65.659, -6.12) + 0.01 * vec3(p, 0));\n    float high_freq = 0.1 * Noise(0.2  * vec3(p, 0));\n    float h = low_freq + high_freq + 0.5 * Softness(p);\n    \n    return h;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat flow_routing_exp = 1.3;\n\nvec2 neighbor[8] = vec2[8](vec2(1,  0), vec2(1,   1), vec2(0,  1), vec2(-1, 1),\n                           vec2(-1, 0), vec2(-1, -1), vec2(0, -1), vec2(1, -1));\n\nfloat Slope(vec2 p, vec2 q) {\n    return (Height(p) - Height(q)) / length(p - q);\n}\n\nfloat Steepest(vec2 p, out vec2 q) {\n\n    float max_slope = 0.;\n    q = p;\n    \n    // look around p\n    for (int i = 0; i < 8; i++) {\n        vec2 pp = p + neighbor[i];\n        if (Height(p) < Height(pp)) continue;\n        float s = Slope(p, pp);\n        if (s > max_slope) {\n            max_slope = s;\n            q = pp;\n        }\n    }\n    \n    return max_slope;\n}\n\n// flow weight from p to q\nfloat GetFlowWeight(vec2 p, vec2 q) {\n\n    float weight = 0.;\n    float total_weight = 0.;\n    \n    // look around p\n    for (int i = 0; i < 8; i++) {\n        vec2 pp = p + neighbor[i];\n        if (Height(p) < Height(pp)) continue;\n        float s = pow(Slope(p, pp), flow_routing_exp);\n        total_weight += s;\n        if (pp == q) weight = s;\n    }\n    \n    if (total_weight == 0.) return 0.;\n    return weight / total_weight;\n}\n\nfloat GetFlow(vec2 p) {\n    float flow = 0.;\n    // look around p\n    for (int i = 0; i < 8; i++) {\n        vec2 q = p + neighbor[i];\n        if (Height(p) > Height(q)) continue;\n        float weight = GetFlowWeight(q, p);\n        flow += Flow(q) * weight;\n    }\n    \n    return flow;\n}\n\nfloat GetSedFlow(vec2 p) {\n    float sed_flow = 0.;\n    // look around p\n    for (int i = 0; i < 8; i++) {\n        vec2 q = p + neighbor[i];\n        if (Height(p) > Height(q)) continue;\n        float weight = GetFlowWeight(q, p);\n        sed_flow += Sed(q) * weight;\n    }\n    \n    return sed_flow;\n}\n\n\nint GetThermalDelta(vec2 p, float s_max) {\n    int up = 0;\n    int down = 0;\n    // look around p\n    for (int i = 0; i < 8; i++) {\n        vec2 q = p + neighbor[i];\n        float s = Slope(p, q);\n        if (s > s_max) {\n            down++;\n        } else if (s < -s_max){\n            up++;\n        }\n    }\n    \n    return up - down;\n}\n\n\n\nvoid mainImage(out vec4 result, in vec2 p ) {\n    \n    if (iFrame < 10) {\n        // init Height\n        result.x = Terrain(p);\n        \n        // init Flow\n        result.y = 1.;\n        \n        // init Sed\n        result.z = 0.;\n        \n        // init Depo\n        result.w = 0.;\n        \n        return;\n    } else if (iMouse.z > 0.) {\n        result = buffA(p);\n        return;\n    } else if (iFrame % 400 < 80) {\n        // SPE\n        vec2 steepest_p;\n        float s = Steepest(p, steepest_p);\n        float steepest_h = Height(steepest_p);\n        float spe = 0.3 * min(3., pow(Flow(p), 0.8) * s * s) * Softness(p);\n        result.x = max(steepest_h, Height(p) - spe);\n        result.z = buffA(p).z;\n        result.w = max(0., Depo(p) - (Height(p) - result.x));\n    } else if (iFrame % 400 < 200) {\n        // THERMAL\n        int thermal_delta = GetThermalDelta(p, 0.04 + 0.02 * Softness(p));\n        result.x = Height(p) + 0.003 * float(thermal_delta);\n        result.z = buffA(p).z;\n        result.w = Depo(p);\n    } else if (iFrame % 400 < 290) {\n        // DEPOSITION\n        vec2 steepest_p;\n        float s = Steepest(p, steepest_p);\n        float spe = pow(Flow(p), 0.8) * s * s;\n        float new_sed = GetSedFlow(p);\n        float depo_index = max(0., new_sed - 0.7 * spe);\n        float depo = min(new_sed, 0.01 * depo_index);\n        result.x = Height(p) + depo;\n        result.z = new_sed + 0.1 * spe - depo;\n        result.w = Depo(p) + depo;\n    } else {\n        result = buffA(p);\n    }\n        \n    // update Flow\n    result.y = 1. + GetFlow(p);\n    \n    return;\n}","name":"Buffer A","description":"","type":"buffer"}]}