{"ver":"0.1","info":{"id":"7dGSzm","date":"1634417770","viewed":62,"name":"Another shot at raymarching","username":"big_chonk","description":"Trying to make a proper raymarcher. This time it has toon shading!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Hit\n{\n    float dist;\n    vec4 color;\n};\n\nfloat sdSphere(in vec3 point, in vec4 sphere)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat sdPlane(in vec3 point, in vec4 plane)\n{\n    return dot(vec4(point, 1.), plane);\n}\n\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max(k - abs(a - b), 0.);\n    return min(a, b) - h * h / (k * 4.);\n}\n\nfloat Map(in vec3 point)\n{\n    float minDistance = MAX_DISTANCE;\n    \n    // Spheres\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float dist = sdSphere(point, g_Spheres[i]);\n        minDistance = smin(dist, minDistance, g_Settings.smoothness);\n    }\n\n    // Planes\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        float dist = sdPlane(point, g_Planes[i]);\n        minDistance = smin(dist, minDistance, g_Settings.smoothness);\n    }\n\n    return minDistance;\n}\n\nfloat MapWithColor(in vec3 point, out vec4 color)\n{\n    float minDistance = MAX_DISTANCE;\n\n    // Spheres\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float dist = sdSphere(point, g_Spheres[i]);\n        minDistance = smin(dist, minDistance, g_Settings.smoothness);\n        \n        float t = 1. - clamp(abs(dist - minDistance) * g_Settings.blending, 0., 1.);\n        color = mix(color, g_Colors[g_SphereColors[i]], t);\n    }\n\n    // Planes\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        float dist = sdPlane(point, g_Planes[i]);\n        minDistance = smin(dist, minDistance, g_Settings.smoothness);\n        \n        float t = 1. - clamp(abs(dist - minDistance) * g_Settings.blending, 0., 1.);\n        color = mix(color, g_Colors[g_PlaneColors[i]], t);\n    }\n\n    return minDistance;\n}\n\nvec3 GetNormal(in vec3 point)\n{\n    vec2 e = vec2(0.001, 0);\n    \n    return normalize(vec3(\n        Map(point + e.xyy) - Map(point - e.xyy),\n        Map(point + e.yxy) - Map(point - e.yxy),\n        Map(point + e.yyx) - Map(point - e.yyx)\n    ));\n}\n\nvoid MarchRay(in vec3 ro, in vec3 rd, out Hit hit)\n{\n    vec3 point = ro;\n    float minDistance = 0.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        point += rd * minDistance;\n        \n        minDistance = MapWithColor(point, hit.color);\n        hit.dist += minDistance;\n        \n        if (minDistance <= MIN_DISTANCE)\n            break;\n        \n        if (minDistance >= MAX_DISTANCE)\n        {\n            hit.dist = -1.;\n            break;\n        }\n    }\n}\n\nvoid MarchRay(in vec3 ro, in vec3 rd, out float dist)\n{\n    vec3 point = ro;\n    float minDistance = 0.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        point += rd * minDistance;\n        \n        minDistance = Map(point);\n        dist += minDistance;\n        \n        if (minDistance <= MIN_DISTANCE)\n            break;\n        \n        if (minDistance >= MAX_DISTANCE)\n        {\n            dist = -1.;\n            break;\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n#   ifdef USE_MOUSE_FOR_SMOOTHING\n    g_Settings.smoothness = (5. * iMouse.x / iResolution.x) + 0.01;\n    g_Settings.blending = 1. / g_Settings.smoothness;\n#   else\n    g_Settings.smoothness = CONSTANT_SMOOTHING;\n    g_Settings.blending = 1. / CONSTANT_SMOOTHING;\n#   endif\n\n    vec4 color;\n\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., 0., 1.);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    Hit hit;\n    MarchRay(ro, rd, hit);\n    \n    if (hit.dist > 0.)\n    {\n        vec3 hitPoint = ro + hit.dist * rd;\n        vec3 normal = GetNormal(hitPoint);\n\n        // Light\n        float diffuse = clamp(dot(lightDirection, normal), 0., 1.);\n        float ambient = .25 + .5 * dot(normal, vec3(0., 1., 0.));\n\n#       ifdef TOON_SHADING_ENABLED\n        diffuse = floor(TOON_SHADING_STEPS * diffuse) / TOON_SHADING_STEPS;\n#       endif\n\n        // Shadow\n        float lightDistance;\n        MarchRay(hitPoint + 0.01 * normal, lightDirection, lightDistance);\n        float shadow = step(lightDistance, 0.);\n\n        color = diffuse * shadow * hit.color + ambient * ambientColor;\n    }\n    else\n    {\n        color = mix(g_Colors[0], g_Colors[1], uv.y + .5);\n    }\n    \n    fragColor = pow(color, vec4(0.4545));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Settings\n\n// Ray Marching\n#define MAX_ITERATIONS 256\n#define MAX_DISTANCE 100.\n#define MIN_DISTANCE .0015\n\n// Lighting\n#define TOON_SHADING_ENABLED\n#define TOON_SHADING_STEPS 3.\n\n// Blending\n#define USE_MOUSE_FOR_SMOOTHING\n#define CONSTANT_SMOOTHING 1.\n\nstruct Settings\n{\n    float smoothness;\n    float blending;\n} g_Settings;\n\n// DATA\n\n// Colors\nvec4[] g_Colors = vec4[] (vec4(0., .5, .75, 1), vec4(0., .25, 1., 1), vec4(1., .25, .25, 1), vec4(1., .75, 0., 1), vec4(.25, .75, 0., 1));\n\n// Shapes\n#define NUM_SPHERES 3\n#define NUM_PLANES 2\n\nvec4[NUM_SPHERES] g_Spheres = vec4[NUM_SPHERES] (vec4(2., 1., -9.5, 1.), vec4(.5, -.5, -10., 2.), vec4(-1., -1., -14., 5.));\nint[NUM_SPHERES] g_SphereColors = int[NUM_SPHERES] (3, 2, 0);\n\nvec4[NUM_PLANES] g_Planes = vec4[NUM_PLANES] (vec4(0., 1., 0., 2.), vec4(2., 0., 1., 20.));\nint[NUM_PLANES] g_PlaneColors = int[NUM_PLANES] (4, 1);\n\n// Lighting\nvec3 lightDirection = normalize(vec3(.8, .4, .2));\nvec4 ambientColor = vec4(0., .1, .3, 1.);","name":"Common","description":"","type":"common"}]}