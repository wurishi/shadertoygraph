{"ver":"0.1","info":{"id":"3tSyWG","date":"1595242846","viewed":111,"name":"Julia's Mirror","username":"CyanMARgh","description":"Julia set, as a reflective surface.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0., .4, -6.5);\nfloat softShadow = 10.;\nfloat depthmax = 50.; \nconst float eps = 1e-3;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\nstruct point{\n    vec3 pos;\n    vec3 col;\n};\n\n//additioanal operations\nvec4 qxq( in vec4 a, in vec4 b){\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, \n        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );\n\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat julia(vec3 p, int L){\n\tfloat t = iTime / 3.0;\n    \n\tvec4 c = .3*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( p, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<L;i++){\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0){\n\t\t\tbreak;\n        }\n\t}\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n//color functions\nvec3 checkerboard(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return vec3(1.)*((d.x+d.y+d.z)%2==0?1.:.8);\n}\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(.9,.9,1.,-box(vec3(20.,20.,20.),p-vec3(0.,18.,0.)));\n    d0.xyz *= checkerboard(p);    \n    return d0;\n}\nvec4 mirrorMap(vec3 p){\n    return vec4(.2,.05,.05,julia(p*.4,6));\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\nvec3 mirrorNorm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = mirrorMap(p).w;\n    return normalize(vec3(\n        mirrorMap(p + e.xyy).w-d,\n        mirrorMap(p + e.yxy).w-d,\n        mirrorMap(p + e.yyx).w-d\n    ));\n}\n\n//color and length of ray\npoint rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist, distM;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w; distM = mirrorMap(pos).w;\n\n        depth += min(dist,distM);\n        sdepth += min(dist,distM);\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(distM < eps){ //intersection with mirror\n            depth=0.;\n            vec3 n = mirrorNorm(pos);\n            eye = pos + dir*distM;\n            dir = normalize(dir + dot(-dir,n)*2.*n);            \n            eye = pos + dir*distM + n*eps*1.2;\n\n            col+=mirrorMap(pos).xyz*k;\n            k/=1.1;\n            \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    col+=map(pos).xyz;\n    vec3 n = norm(pos);\n    pos+=eps*n;\n    return point( pos , col * exp(-0.003*sdepth) / k);\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //direction calculation\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float angle = (1.2+cos(iTime*.4))*.6;\n    eye.xz*=ro(angle);\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n\n    //raymarching\n    point rc = rayCast(eye, dir);\n\n    vec3 pos = rc.pos;\n    vec3 n = norm(pos);\n    pos+=eps*n;\n    \n    vec3 col = rc.col;\n    vec3 lighting = vec3(.25);\n\n    if (length(pos) < depthmax){\n        // adding 3 point lights and one directional light\n\t\tlighting += getLight(pos, vec3(6., 8., 0.), n, vec3(1.,.9,.9), 15.,false);\n        lighting += getLight(pos, vec3(-6., 23., 10.), n, vec3(1.,1.,1.), 100.,false);\n        lighting += getLight(pos, vec3(-10., 33., -2.), n, vec3(1.,1.,1.), 100.,false);\n        lighting += getLight(pos, vec3(2., 13., -10.), n, vec3(1.,.9,.9), 120.,false);\n        \n        //lighting -= getOcc(pos, n);\n\t\tcol *= lighting;\n    }else{\n        col = backcol;\n    }\n    \n    //compositing color, lighting and fog\n    fragColor = vec4(1.5*log(1.+ col), 1.0);\n}","name":"Image","description":"","type":"image"}]}