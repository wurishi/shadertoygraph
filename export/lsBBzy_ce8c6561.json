{"ver":"0.1","info":{"id":"lsBBzy","date":"1500900336","viewed":168,"name":"28 Moons","username":"zproxy","description":"https://www.shadertoy.com/view/XsjBWm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sun","space","stars","moon","globe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by Ramon Viladomat\n\n#define DRAW_RED_MAGIC \n//#define DRAW_GREEN_MAGIC \n#define DRAW_BLUE_MAGIC \n#define DRAW_YELLOW_MAGIC \n \n#define PI 3.1415\n#define EPSILON 0.002\n\n// 384,400 km\n#define SATELITE_RADIUS 384.400\n//#define SATELITE_RADIUS 34.400\n\n//#define MAGIC_RADIUS\t384.400\n#define MAGIC_RADIUS\t(384.400  + 7.)\n\n// 1,737 km\n#define SATELLITE_RADIUS 1.737\n//#define SATELLITE_RADIUS 10.737\n//#define SATELLITE_RADIUS 0.1737\n\n// 6,371 km\n#define PLANET_RADIUS \t6.371\n\n// camera rotation basically means one rotates with a planet.\n// the texture has to also rotate for that effect\n//#define CAM_ROTATION_SPEED 0.01\n// moon is supposed to do a real orbit in 28days\n//#define SAT_ROTATION_SPEED 0.1\n\n//#define CAM_ROTATION_SPEED 0.0\n//#define SAT_ROTATION_SPEED 0.0\n\n#define CAM_ROTATION_SPEED 0.02\n#define SAT_ROTATION_SPEED 0.01\n// if its the same speed. its basically at the same spot.\n// it has to fall back on x axis full circle within 28days\n// yet it has to travel from blue to red in 14 days\n//#define SAT_ROTATION_SPEED 0.1\n//#define SAT_ROTATION_SPEED (CAM_ROTATION_SPEED/28.)\n\n\n\n// ah. so this defines how the shadow should behave, per expected distance of the sun\n#define SOFTSHADOW_BANDWIDTH 0.7\n//#define SOFTSHADOW_BANDWIDTH 0.2\n\n\n\n\n\n// moon pos. can we make it move?\n\n///////////////\n// MATERIALS //\n///////////////\n\n\n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<1.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\n\n\nvec3 startrails(in vec3 rd)\n{\n    // do not move. we got a blinking star we would need to move too. \n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.00)));\n\n    vec3 col = col0;\n\n    // our blinky star is fixed via ro? we dont know how to rotate it all in sync yet.\n    \n    if (false)\n    for (int i = -30; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\nvec2 GetNormalMap(in sampler2D s, in vec2 resolution, in vec2 uv)\n{\n\tvec3 eps=vec3(1.0/resolution,0.0);\n\tvec2 norm = vec2(length(texture(s,uv+eps.xz)) - length(texture(s,uv-eps.xz)),\n\t\t\t\t\t length(texture(s,uv+eps.zy)) - length(texture(s,uv-eps.zy)));\n\t\n\treturn norm;\n}\t\n\nvec4 calcColor( in vec3 pos, in vec3 nor, in float material, out vec3 normal, vec3 ballPos  )\n{\n\tvec4 materialColor = vec4(0.0);\n\t\n\tvec3 q = pos - mix(ballPos,vec3(0.0),material);\n\tfloat radius = mix(0.5,3.0,material);\n\tvec2 angles = vec2(atan(abs(q.z)/abs(q.x)),acos(q.y/radius));\n\t\n\tfloat mixer = step(1.0,material);\n\t\n\t\n    // material ?\n    //materialColor = vec4(0.01,0.01,0.7*material, 0.01);\n    \n    // float1 is earth.\n    // float0 is moon?\n    if (material < 0.5)\n    \t//materialColor = vec4(material,material,1.0-material, 0.01);\n        //materialColor = vec4(0.4,0.4,0.4, 0.01);\n    \n        // does the light hit it the right way?\n        materialColor = vec4(0.4,0.4,0.4, 0.01);\n    else\n        materialColor =\n        \n//        (1./ 14.) *\n        vec4(\n            \n                        0.01,0.01,0.7, \n\n             //0.01,0.01,0.7 - startrails(angles.xyy).x,\n            //0.01,0.01,0.7, \n            \n            0.01);\n    \n    //materialColor = vec4(0.01,0.01,0.01, 0.01);\n    \n  \n\tvec2 normalMap = //mix(\n        \n        // looks like a golfball?\n        //hash33(angles.xyy).xy\n        //hash33(pos * 0.00001).yx * 0.1\n        \n        0.\n        //startrails(pos).xy\n        //4.0 * sin(float(iFrame) * 0.1)//*GetNormalMap(iChannel1,iChannelResolution[1].xy,angles)\n        * vec2(1)\n        ;\n        \n        //GetNormalMap(iChannel0,iChannelResolution[0].xy,angles),mixer);\n\t\t\n\tvec3 left = normalize(cross(vec3(0.0,1.0,0.0),nor));\n\tvec3 up = normalize(cross(left,nor));\n\tnormal = normalize(normalMap.x*left + nor + normalMap.y*up);\n\t\n\treturn materialColor;\n}\n\n// can it become a scanline?\n//float GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params, in vec2 sine)\nfloat GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params)\n{\n\tfloat rotAngle = movement.x+iTime*movement.y;\n\tvec2 refPos = MAGIC_RADIUS*vec2(sin(rotAngle),cos(rotAngle));\n\tvec2 refFwd = vec2(-refPos.y,refPos.x);\n\t\n\tfloat hVert = pos.y - movement.z;\n\tfloat hDist = length(pos.xz - refPos);\n\t\n\t//float fl = max(dot(pos.xz,refFwd),0.0)*(1.0 - smoothstep(0.0,params.x,hDist));\n\tfloat fl = max(dot(pos.xz,refFwd),0.0)\n        \n        *(1.0 - smoothstep(0.0,params.x,hDist));\n    \n    \n\t//float fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z*sin(sine.x*angle+sine.y)));\n\tfloat fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z\n                                                // *sin(sine.x*angle+sine.y)\n                                                ));\n\t\n\treturn fl*fh;\n}\n\nvec3 GetAlphaColor(in vec3 pos)\n{\n\tvec3 ret = vec3(0.0);\n\tfloat angle = atan(pos.z/pos.x);\n\t\n#ifdef DRAW_RED_MAGIC\n\tret +=  0.000001 \n        * vec3(1.,0.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle,\n            \n            \n            vec3(0.0,-4., 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                1270.0,\n                \n                // width\n                2.,\n                \n                // moves it up or down?\n                \n                // up\n                -135.\n            \n                // down\n                //5.\n            \n                // center\n                //0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n#endif\n#ifdef DRAW_GREEN_MAGIC\n\tret += vec3(0.0,1.0,0.0)*GetTrail(pos,angle,vec3(0.5,2.1, 0.5),vec3(8.0,0.1,0.8),vec2(2.0,1.0));\n#endif\n#ifdef DRAW_BLUE_MAGIC\n\tret +=  0.000001 \n        * vec3(0.,0.0,1.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle,\n            \n            \n            vec3(0.0,4.1, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                1270.0,\n                \n                // width\n                2.,\n                \n                // moves it up or down?\n                \n                // up\n                //-2.\n            \n                // down\n                135.\n            \n                // center\n                //0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    #endif\n#ifdef DRAW_YELLOW_MAGIC\n\tret +=0.0000 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                -4.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    ret += 0.0000 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                4.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n      ret += 0.00000 \n        * vec3(1.,1.0,0.0)\n        *\n        // float GetTrail(in vec3 pos, in float angle, in vec3 movement, \n        // in vec3 params, in vec2 sine)\n        GetTrail(\n            pos,\n            angle + 2.,\n            vec3(0.0,\n                 // slower?\n                 0.5, 0.0),\n            \n            // what does params do?\n            vec3(\n                // makes it longer?\n                2145.0,\n                //0.01,\n                //0.02,\n                1.,\n                \n                // moves it up or down?\n                \n                // up\n                //-5.\n            \n                // down\n                //5.\n            \n                // center\n                0.\n            )\n            \n        //    vec2(4.0,0.0)\n        );\n    \n    #endif\n\treturn ret;\n}\n\n/////////////////\n// RAY METHODS //\n/////////////////\n\nfloat raySphereIntersection( in vec3 ro, in vec3 rd, in vec3 center, in float radius, float multiplier)\n{\n\tfloat res = 9999.0;\n\tvec3 oc = ro - center;\n\tfloat b = dot(rd,oc); //should be 2*rd*oc but the 2 gets eliminated after expanding the quadratic equation\n\tfloat c = dot(oc,oc)-(radius*radius);\n\t\n\tfloat bminac = (b*b)-c;\n\tif (bminac >= 0.0)\n\t{\n\t\t//intersection\n\t\tfloat sqrtbminac = sqrt(bminac);\n\t\tfloat t = (-b + multiplier*sqrtbminac);\n\t\tres = mix(res,t,step(0.0,t));\n \t}\n\t\n\treturn res;\n\t\n}\n\nfloat shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)\n{\n\tfloat lambda = dot(-(ro - sphere.xyz),rd);\n\tfloat dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;\n\treturn mix(9999.0,dist,step(0.0,lambda)); \n}\n\n////////////////\n// RAY TRACER //\n////////////////\n\nvec2 intersect( in vec3 ro, in vec3 rd,  vec3 ballPos, int imoon )\n{\n\tvec2 res = vec2(9999.0,-1.0);\n\t\n\tvec2 centerSatellite = vec2(raySphereIntersection(ro,rd,ballPos,SATELLITE_RADIUS,-1.0),0.0);\n\tvec2 centerPlanet = vec2(raySphereIntersection(ro,rd,vec3(0.0),PLANET_RADIUS,-1.0),1.0);\n\t\n\tif (centerSatellite.x < res.x) res = centerSatellite; \n\t\n    // unless we need multiple eclipses?\n    // keep only moon0 near sun. others should not be able to cause the eclipse\n    // ha. also. other moons should not appear thru the planet.\n    \n    if (centerPlanet.x < res.x) \n    {\n         if (imoon == 0)\n         {\n        \tres = centerPlanet; \n        \n         }\n        else\n        {\n            \n            // erase any moons...\n        res = vec2(9999.0,-1.0);\n        }\n\n    }\n        \n\treturn res;\n}\n\nfloat GetShadows( in vec3 ro, in vec3 rd, vec3 ballPos )\n{\n\tfloat shadowSatellite = shadowRaySphere(ro,rd,vec4(ballPos,SATELLITE_RADIUS));\n    \n    \n\tfloat shadowPlanet = shadowRaySphere(ro,rd,vec4(0.0,0.0,0.0,PLANET_RADIUS));\n\t\n\treturn smoothstep(0.0,SOFTSHADOW_BANDWIDTH,min(shadowSatellite,shadowPlanet));\n}\n\nvec3 GetTransparency( in vec3 ro, in vec3 rd, float depth)\n{\n\tfloat back = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,1.0);\n\tfloat front = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,-1.0);\n\n\treturn GetAlphaColor(ro+rd*back)*step(back,depth) \n        // what does this do?\n        + GetAlphaColor(ro+rd*front)*step(front,depth)\n        ;\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nvec3 calcNormal( in vec3 pos, in vec2 tmat, vec3 ballPos )\n{\n\treturn normalize(pos-mix(ballPos,vec3(0.0),tmat.y));\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd , vec3 ballPos )\n{\n\tfloat scene = GetShadows(ro,rd, ballPos);\n\tfloat alpha = 1.0 - 0.8*clamp(length(GetTransparency(ro,rd,9999.0)),0.0,1.0);\n    return min(alpha,scene);\n\t\n}\n\n\n\n\n\n\nvoid line_rgb (\n    //inout vec4 fragColorR,\n\tinout vec3 rgb1,\n\n    in float lat180,  \n    in float lat180target, \n    in float lat180radius,\n\n\tvec3 rgb)\n{\n    if (lat180 < (lat180target + lat180radius))\n        if (lat180 >( lat180target - lat180radius))\n            \n \t\t//if (lat180 < 108.)\n     //   if (lat180 > 72.)            \n        {\n\n            \n            //float a = 0.3;\n\n            \n\n            rgb1.rgb = rgb;\n\n            //fragColorR.b = a;\n            //fragColorR.g = a;\n\n        }\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n// nested functions would be just awesome. \nvec3 draw(int imoon, vec3 ballPos, vec3 camPosition, \n          vec3 rayDir,  \n          vec3 lightPos1 ,\n          vec3 lightColor1 ,\n           float attenuation,\n          \n          out vec2 tmat,\n          inout int space\n         )\n{\n    vec3 finalcolor = vec3(0.0);\n    \n      float depth = 9999.0;\n        for( int reflectCount=0; reflectCount<2; reflectCount++ )\n        {\n            float isFirst = min(float(reflectCount),1.0);\n\n\n\n\n\n            // Compute color for single ray\n             tmat = intersect(camPosition,rayDir, ballPos, imoon);\n            vec3 alpha = GetTransparency(camPosition,rayDir,tmat.x);\n\n            //finalcolor += attenuation*alpha;\n            finalcolor += alpha;\n\n            if (tmat.y > -0.5)\n            {\n                depth = mix(tmat.x,depth,isFirst);\n\n                // results extraction\n                vec3 position \t= camPosition + tmat.x*rayDir;\n                vec3 normal \t= calcNormal(position,tmat,ballPos);\n\n                // lights and materials \n                vec3 normalMod = vec3(0.0);\n                vec4 materialColor \t= calcColor( position, normal, tmat.y , normalMod, ballPos);\n                normal = normalMod;\n\n                float ambient  \t\t= 0.1 + 0.1*normal.y;\n                vec3 ambientColor \t= ambient*materialColor.rgb;\n\n                //light 1 ( specular computed through reflections )\n                vec3 lightDir1 \t= normalize(lightPos1 - position);\n\n                float diffuse1  = max(dot(normal,lightDir1),0.0);\n                float shadow1   = 1.* softShadow( position, lightDir1 , ballPos);\n\n                // HDR bright\n                vec3 diffuseColor1 = 10.0* diffuse1*lightColor1*materialColor.rgb;\n                vec3 ilumColor1 = shadow1*diffuseColor1;\n\n                // mixing lights\n                finalcolor += attenuation*mix(ambientColor,ilumColor1,0.8);\n\n                // prepare next ray for reflections \n                rayDir = reflect(rayDir,normal);\n                attenuation *= 2.0*materialColor.w;\n                camPosition = position + EPSILON*normal;\n                \n                space--;\n            }\n\n\n        }\t\n    \n    return finalcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // need SIRIUS from\n    // https://www.shadertoy.com/view/XdXcDB\n    \n    // need scanlines from\n    // https://www.shadertoy.com/view/ldXyzs\n    \n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\t//move camera when clicking\n\tfloat animatedCamAngle = -0.7 + iTime*CAM_ROTATION_SPEED;\n\t//float inputCamAngle = PI + 2.0*PI*(mousePos.x*14.);\n    float inputCamAngle = PI + 2.0*PI*(mousePos.x);\n\t//float inputCamAngle = PI + 2.0*PI*(mousePos.x*7.);\n\t\n\t//float camAngle = mix(animatedCamAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\n    float camAngle = animatedCamAngle+inputCamAngle;\n    \n    //float camDist = 5.0; \n\t//float camDist = 10.0; \n\t//float camDist = 10.0 +1.* sin(iTime);  \n\t//float camDist = 50.0  ;  \n\t//float camDist = 6.3715  ;  \n\t //float camDist = 5. * 6.3715  ;  \n\t//float camDist = 384.400 + 6.; \n    float camDist = 2. * 384.400; \n    \n    // #define PLANET_RADIUS \t6.371\n\n    // #define MAGIC_RADIUS\t384.400\n\n    \n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), \n                                              \n                                              \n                                              0.0, cos(camAngle)));\n    \n    // will rock the boat\n    //camPosition.y += 2. * sin(iTime * 0.5);\n    //camPosition.y += .2 * sin(iTime * 0.5);\n    \n    \n    //vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    // the closer we get. the more horizon we need to look at in 2D\n    vec3 camTarget\t = vec3( -8.0, 0.0, 0.0 );\n    \n    if (camDist > 10.)\n        camTarget.x = 0.;\n    \n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n\tvec3 rayRaw \t = p.x*camRight + p.y*camUp + 2.0*camFront;\n    vec3 rayDir \t = normalize( rayRaw );\n\t\n    //rayDir *=  rotationMatrix(vec3(1., 0., 0.), radians(90.0 )); // make it wavy\n    //camPosition *=  rotationMatrix(vec3(1., 0., 0.), radians(90.0 )); // make it wavy\n    \n\t// light compute (fake fire light)\n\t// how does the eclipse behve if we move the lightsource?\n    \n    // so if it needs to be northern minight sun sun has too appear at +20?\n    //vec3 lightPos1 = vec3(00.0,1300.0,-3840.400);\n    \n    // recenter scanline 0\n//    vec3 lightPos1 = vec3(00.0, 0. * 1300.0,-3840.400);\n    \n    \n    \n    // looky sun as seen within a year.\n    vec3 lightPos1 = vec3(00.0, \n                          1. * 1300.0 * sin(iTime * 0.005),\n                          -3840.400);\n    \n    \n\t\n\t//vec3 lightColor1 = vec3(1.0,0.7,0.0);\n\t//vec3 lightColor1 = vec3(0.7,0.7,0.7);\n\t\n\t//Update World\n\tfloat rotAngle = PI + SAT_ROTATION_SPEED * iTime; \n    \n    \n    //#define SATELITE_RADIUS 12.0\n \n\t\t\n\t//Compute Screen Shadow\n\t//vec3 barPos = camPosition + rayRaw*0.5*BAR_DEPTH;\n\t//vec3 lightDirExt = normalize(camPosition - barPos);\n\t//float screen_shadow = GetShadows(barPos,lightDirExt);\n\t\n\t//Start Ray\n    vec3 finalcolor = vec3(0.0);\n    \n    // need it be dynamic?\n    // ISO\n\t\n    // degamma?\n    float attenuation = 11.0;\n    attenuation += 8.5 * (cos(camAngle));  \n    //attenuation = 5.0;\n    \n    \n    vec3 lightColor1 = vec3(2.0,2.*0.7,0.0);\n    \n//    lightColor1 = 0.01 * vec3(2.0,2., 2. - (1.+cos(camAngle)));\n    \n    //finalcolor += 0.05 * vec3(\n    //    0.2* sin(camAngle / 2.),\n    //    0.2 * sin(camAngle / 2.),\n    //    1.0  * sin(camAngle / 2.)\n    //);\n    \n    //finalcolor.b += 0.01 * (  1.0 * 1.0  * sin(camAngle /2. ));\n    \n    \n    //finalcolor.b = .03;\n             \n    //if (cos(camAngle) < 0.)\n    // lightColor1 =  vec3(0.1,0.1,0.1);\n\t\n    \n    //attenuation = 0.2; // daytime\n\t//lightColor1 = vec3(0.7,0.7,0.7);\n    // at daylight we just need the pre lit map to show? in this case blue.\n    // in night time. yellow sun is cool.\n    \n       \n\n    int space = 0;\n    \n    for( int imoon=0; imoon<28; imoon++ )\n    {\n         vec2 tmat;\n        \n            vec3 ballPos = vec3(0.0, 0.0, 0.0);\n        \n        float mooncycle = float(imoon) / 28. * 3.14 * 2. ;\n\n\n        // will it work for shadows?\n        ballPos = \n            vec3(\n                 //sin(float(imoon)),\n                \n                0,\n\n                 // blue to red in 14 days\n                 //-2. * cos(float(iFrame) * 0.01), 0.)+\n            //-2. * cos(camAngle / 14.)\n\n                 // how far must the sun then be?\n                 // how hight can the moon be so we can still get an eclipse?\n                 //1.7\n\n                 //1. * 1300.0 * sin(iTime * 0.05)\n                 // 1. * 135.0 * sin(iTime * 0.005 * 12.)\n\n                 //1. * 135.0 * (float(imoon) / 28.)\n\n                 // 135.\n\n                 \n                 //float(-1 + imoon) * 20.\n                 \n                 //1.\n                 //20. * float(imoon)\n                \n                135. * sin (mooncycle)\n                 //0.1\n                 //0.000001 * float(imoon)\n\n                 \n                 //1.\n                 ,  \n                \n                0.\n                // cos(float(imoon))\n            )+\n\n            SATELITE_RADIUS * vec3(\n            sin(rotAngle + mooncycle),\n            0.0,\n            cos(rotAngle + mooncycle));\n\n\n      \n        finalcolor += draw(imoon,ballPos,\n                          camPosition,\n                           rayDir,\n                           lightPos1,\n                            lightColor1 ,\n                           \n                            attenuation,\n                           \n                           // out\n                            tmat,\n                           space\n                          );\n        \n       \n            // actually. it hase to be false for all moons\n            \n\t}\n    \n \t\t\tif (space == 0)\n            {\n                //stars achieved via noise texture\n                //vec2 angles = vec2(atan(rayDir.z/abs(rayDir.x)),acos(rayDir.y));\t\n                //float a1 = texture(iChannel1,angles).x;\n                //float a2 = texture(iChannel1,angles*2.0+0.01).x;\n                //float a3 = texture(iChannel1,angles*2.1+0.07).x;\n                //float a4 = texture(iChannel1,angles*5.0+0.03).x;\n\n                //float stars = smoothstep(0.1,1.0,a1*a2*a3*a4);\n\n                //stars = 0.;\n\n\n                float sun = 1000.0 * pow(max(dot(normalize(lightPos1 - camPosition),rayDir),0.1),100000.0);\n\n\n                // overrride. cant have stars be much brighter than unlit moon\n\n                // what about milkiway?\n\n\n                //if (p.y > -0.7 &&  p.y < 0.7)\n                {\n\n\n                    //if (p.x > -0.5)\n                    {\n                        // overide ISO\n                        //attenuation = 0.7;\n                    }\n\n                //\tfinalcolor += attenuation*(lightColor1*sun + stars*vec3(0.5));\n                    finalcolor += attenuation*(lightColor1*sun  );\n\n\n                    finalcolor+=finalcolor;\n\n\n                        //attenuation *= 0.005;\n                        //attenuation *= 0.05;\n                        attenuation *= 0.01;\n\n\n                    //attenuation -= 2.0;\n\n                    // will kill fps on fullscreen \n                    finalcolor += attenuation * startrails( rayDir);\n\n                }\n                //else\n                {\n                // show stars from scanline concept\n                }\n\n\n                attenuation = 0.0;\n            }\n    \n    \n    vec3 rgb1 = vec3(0.0);\n\n    vec3 rd1 = rayDir;\n    \n    float lat180 = (acos(-rd1.y) / 3.1415926535897932384626433832795) * 180. ;\n\nfloat hlat180 = (acos(-rd1.y) / 3.1415926535897932384626433832795) * 180. ;\n//float hlng360 = -(atan(rd0.z, rd0.x) / 6.283185307179586476925286766559) + 0.5;\n\n//if (hlat180  > 90.|| (mod(float(lng360blue), 2. * dashsize) >= dashsize))\n{\n line_rgb(rgb1, lat180, 90. +20., 0.3, vec3(1.0, 0, 0)* 0.5);\n //line_rgb(rgb1, lat180, 90. +16., 0.3, vec3(1.0, 0, 0) * 0.5);\n            \n            \n            // center line\n\n            //line(fragColorR, lat180, 90. - 19., 1., 0.8);\n            //line_rgb(rgb1, lat180, 90. , 0.19, vec3(1.0, 1.0, 0));\n            //line_rgb(rgb1, lat180, 90. + 3., 0.19, vec3(1.0, 1.0, 0)*0.5);\n\t\t\t//line_rgb(rgb1, lat180, 90. - 3., 0.19, vec3(1.0, 1.0, 0)*0.5);\n\n            \n              // lower line\n            //line(fragColorR, lat180, 90. + 19., 1., 0.4);\n            //line_rgb(rgb1, lat180, 90.- 16., 0.3, vec3(0.0, 0.0,1.0)* 0.7);\n            line_rgb(rgb1, lat180, 90.- 20., 0.3, vec3(0.0, 0.0,1.0)* 0.5);\n    \n}\n \n    // hide HUD after init\n    if (iFrame < 60)\n    if (camDist <50.)\n    \tfinalcolor+= rgb1;\n\t \n\t// desaturation, gamma correction\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\n    fragColor = vec4( finalcolor, 1.0 );\n}","name":"Image","description":"","type":"image"}]}