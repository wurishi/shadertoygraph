{"ver":"0.1","info":{"id":"4fyXzc","date":"1715778689","viewed":169,"name":"The journey","username":"Miolith","description":"Terrible replica of the game Journey","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","clouds","mountain","sand","desert","journey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst float TWO_PI = 6.28318531;\n\n#define TIME_OFFSET 20.0\n#define TIME (iTime + TIME_OFFSET)\n\nconst int SUN_COLOR_INDEX = 0;\nconst int MOUNTAIN_INDEX = 1;\nconst int GUY_INDEX = 2;\nconst int CLOUDS_INDEX = 3;\n\nstruct VFXObj\n{\n    vec3 color;\n    float opacity;\n    float dist;\n};\n\nstruct Obj\n{\n    int color_index;\n    float dist;\n    vec3 relative_pos;\n};\n\nmat2x2 rotation(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise3d(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D\n    // hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\n// Credit to inigo quilez https://iquilezles.org/articles/\n\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n    // sampling independent computations (only depend on shape)\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n\n    // sampling dependant computations\n    vec2 q = vec2( length(p.xz), p.y );\n    float k = dot(q,vec2(-b,a));\n    if( k<0.0 ) return length(q) - r1;\n    if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 ellipseRot(vec2 pos, float angle, vec2 distances)\n{\n    pos.x += cos(angle) * distances.x;\n    pos.y += sin(angle) * distances.y;\n    return pos;\n}\n\nObj closestObject(in Obj obj1, in Obj obj2)\n{\n    // You can't use ternary operators on struct...\n    // return (obj1.dist < obj2.dist) ? obj1 : obj2;\n    \n    if (obj1.dist < obj2.dist)\n        return obj1;\n    return obj2;\n}\n\nVFXObj closestObject(in VFXObj obj1, in VFXObj obj2)\n{\n    // You can't use ternary operators on struct...\n    // return (obj1.dist < obj2.dist) ? obj1 : obj2;\n    \n    if (obj1.dist < obj2.dist)\n        return obj1;\n    return obj2;\n}\n\n\nfloat rand(vec2 p)\n{\n\tp+=.2127+p.x+.3713*p.y;\n\tvec2 r=4.789*sin(789.123*(p));\n\treturn fract(r.x*r.y);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i=floor(p-.5);\n\tvec2 f=fract(p-.5);\n\tf = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tfloat rt=mix(rand(i),rand(i+vec2(1.,0.)),f.x);\n\tfloat rb=mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.,1.)),f.x);\n\treturn mix(rt,rb,f.y);\n}\n\nfloat sphereSdf(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nObj sun(vec3 pos)\n{\n    float dist = pos.y+ 0.2*sin(pos.z+pos.x) + 0.4*sin(pos.z*0.5-pos.x*0.1);\n        \n    return Obj(SUN_COLOR_INDEX, dist, pos);\n}\n\nObj mountain(vec3 pos)\n{\n    vec3 mountain_pos = pos - vec3(10., 40., 80.);\n    mountain_pos.x += sin(noise3d(pos*0.1))*4.;\n    \n    const float angle = 0.5;\n    float dist = sdCone(mountain_pos, vec2(sin(angle), cos(angle)), 1500.);\n    \n    vec3 box_pos = mountain_pos;\n    box_pos.x -= 5.0;\n    box_pos.xy *= rotation(radians(25.0));\n    dist = opSubtraction(sdBox(box_pos, vec3(10.)), dist);\n            \n    return Obj(MOUNTAIN_INDEX, dist, mountain_pos);\n}\n\nfloat dot2(vec3 p) { return dot(p,p); }\n\nfloat udQuad( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4)\n{    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n\n\nObj guy(vec3 pos)\n{\n    vec3 cape_pos = pos;\n    cape_pos.z += sin(mod(iTime*3., 2.*PI) + cape_pos.x*6. * (3. - 3.*pos.y) )*0.3 * (1. - pos.y);\n    vec3 v1 = vec3(0,1,1);\n\tvec3 v2 = v1 + vec3(0.22, 0, 0);\n\tvec3 v3 = v2 + vec3(0.2, -1, -0.5);\n    vec3 v4 = v3 + vec3(-0.8, 0, 0);\n    \n    float dist = udQuad( cape_pos, v1, v2, v3, v4) - 0.01;\n    \n    Obj CAPE = Obj(GUY_INDEX, dist*0.5, cape_pos);\n    \n    vec3 head_pos = pos - vec3(0.1, 1, 1.05);\n    \n    const float k = 1.7;\n    float c = cos(k*head_pos.x);\n    float s = sin(k*head_pos.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*head_pos.xy,head_pos.z);\n    float head =  sdBox(q, vec3(0.125,0.22,0.1));\n    \n    Obj HEAD = Obj(GUY_INDEX, head, pos);\n    \n    vec3 scarf_pos = pos;\n    scarf_pos.y += sin(pos.x*3. + iTime)*0.05 + cos(pos.x*5. + 2.*iTime+1.0)*0.05;\n    v1 = vec3(-1.2, 1, 1);\n\tv2 = v1 + vec3(1.2, 0, 0);\n\tv3 = v2 + vec3(0, -0.05, 0);\n    v4 = v3 + vec3(-1.2, 0, 0);\n    \n    float scarf = udQuad( scarf_pos, v1, v2, v3, v4) - 0.01;\n    \n    Obj SCARF = Obj(GUY_INDEX, scarf, scarf_pos);\n    \n    return closestObject(\n        closestObject(CAPE, HEAD),\n        SCARF\n    );\n}\n\nfloat sdfCloud(vec3 pos, float radius, float offset, vec3 pos_offset)\n{\n    pos = pos - pos_offset;\n    float rep = radius * 2.0 + offset;\n    vec3  rep_space = pos - mod(pos - rep * 0.5, rep);\n    pos.y +=  sin(3. + rep_space.x * 0.23  )  * 2. ;\n    pos.y +=  sin(3. + rep_space.x * 0.9 ) * 5.;\n    pos.x = (fract( (pos.x + rep * 0.5) / rep ) - 0.5) * rep;\n    float dist = length(pos) - radius;\n    return dist;\n}\n\nObj clouds(vec3 pos)\n{\n    pos.x += iTime; \n    float dist = sdfCloud(pos, 2.0, 0., vec3(0., 0.0, 50.0));\n    dist = smin(dist, sdfCloud(pos, 3.0, 1., vec3(0.0, 0.0, 48.0)), 6.0);\n    dist = smin(dist, sdfCloud(pos, 5.0, .1, vec3(10., 0.0, 55.0)), 5.0);\n    dist -= sin(pos.x)*sin(pos.z) * sin(pos.y)*0.5 + 0.3;\n    return Obj(CLOUDS_INDEX, dist, pos);\n}\n\nObj scene(vec3 ray_pos)\n{\n    Obj objects = closestObject(sun(ray_pos), mountain(ray_pos));\n    objects = closestObject(objects, guy(ray_pos));\n    objects = closestObject(objects, clouds(ray_pos));\n    return objects;\n}\n\n// ************** COLORIZE ************** //\n\nvec3 sunColor(vec3 relative_pos)\n{\n    const vec3 color1 = vec3(245, 172, 148)/255.0;\n    vec3 color2 = vec3(245, 182, 158)/255.0;\n    \n    return color1;\n}\n\nvec3 mountainColor(vec3 pos)\n{\n    return mix(\n        vec3(0.141,0.122,0.192),\n        vec3(0.467,0.463,0.482),\n        smoothstep(70.0, 80.0, pos.y)\n    );\n}\n\nvec3 cloudsColor()\n{\n    return vec3(0.871,0.867,0.855);\n}\n\nvec3 guyColor(vec3 pos)\n{\n    if ( pos.y > 0.15)\n        return vec3(0.647,0.114,0.176);\n    return vec3(0.898,0.647,0.039);\n}\n\nvec3 colorize(Obj obj)\n{\n    vec3 col = vec3(0.0);\n    \n    switch(obj.color_index)\n    {\n        case SUN_COLOR_INDEX: col = sunColor(obj.relative_pos); break;\n        case MOUNTAIN_INDEX: col = mountainColor(obj.relative_pos); break;\n        case GUY_INDEX: col = guyColor(obj.relative_pos); break;\n        case CLOUDS_INDEX: col = cloudsColor(); break;\n        \n        default: col = vec3(0.0); break;\n    }\n    \n    return col;\n}\n\n#define ZERO (min(iFrame,0)) // non-constant zero\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(pos+e*h).dist;\n    }\n    return normalize(n);\n}\n\nvec3 skyColor(vec3 ray_dir)\n{\n    vec3 up = vec3(185,201,160)/255.;\n    vec3 down = vec3(220,219,193)/255.;\n    return mix(down, up, ray_dir.y);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n        m = vec2(0.0, 0.0);\n        \n    \n    vec3 ray_origin = vec3(0.0, 0.0, -4.0);\n    \n    vec2 start_xy = uv;\n    vec3 ray_dir = normalize(vec3(start_xy, 1.5));\n    vec3 col = skyColor(ray_dir);\n    const vec2 peakLight = vec2(0.16,0.6);\n    col = mix(col, vec3(1.000,0.965,0.804), smoothstep(0.4, 0.1, distance(uv,peakLight)));\n\n    ray_origin.y += 1.0;\n    \n    ray_origin.z -= 0.5+sin(iTime*0.5)*0.5;\n    \n    float t = 0.0;\n    vec3 ray_pos = ray_origin;\n    \n    Obj object;\n    \n    const float MAX_DIST = 100.0;\n    \n    for (int i = 0; i < 100; i++)\n    {\n        ray_pos = ray_origin + ray_dir * t;\n\n        object = scene(ray_pos);\n        \n        t += object.dist;\n        \n        if (t > MAX_DIST || object.dist < 0.01) break;\n    }\n    \n\n    vec3 color = colorize(object);\n    \n    float vertical_fog = smoothstep(0.5, 0.0, abs(uv.y));\n\n    if (t < MAX_DIST)\n    {\n        vec3 normal = calcNormal(ray_pos);\n        const vec3 lightPos = -normalize(vec3(-1,-1,0));\n        \n        float lightContrib =  max(0.0, dot(normal, lightPos));\n        vec3 toonShading = mix(color, color*0.5, smoothstep(0.8, 0.7, lightContrib));\n        col = toonShading;\n        col = mix(col, vec3(1.000,0.965,0.804), 0.5*smoothstep(0.4, 0.1, distance(uv,peakLight)));\n        if (object.color_index != MOUNTAIN_INDEX)\n            col = mix(col, vec3(1.0), clamp(ray_pos.z*0.05*vertical_fog, 0.0, 0.7));\n        else\n            col = mix(col, vec3(1.0), vertical_fog);\n\n    }\n    else\n    {\n        col = mix(col, vec3(1.0), vertical_fog);\n    }\n    \n    col = mix(col, vec3(1.0), smoothstep(0.01, -0.02, sdVesica(uv-peakLight, 0.24, 0.21)));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}