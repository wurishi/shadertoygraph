{"ver":"0.1","info":{"id":"wltSzj","date":"1581369265","viewed":173,"name":"Connected 2D Bezier SDF","username":"bio998","description":"Two bezier curves connected, use mouse to interact.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on https://www.shadertoy.com/view/Mlj3zD\n\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n \n#define EPSILON 0.000000001\n#define MAX 9999999.\n#define PI 3.14159265358979\n \n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nint findRoots(float a, float b, float c, float d, out float r[3])\n{\n\tvec3 vS = vec3(-1.0,-1.0,-1.0);\n\tif (abs(a) > EPSILON)\n\t{\n\t\tfloat z = 1.0/a;\n\t\tfloat d3 = 1.0/3.0;\n\t\tfloat d27 = 1.0/27.0;\n\t\ta = b*z;\n\t\tb = c*z;\n\t\tc = d*z;\n\t\tfloat p = b-a*a*d3;\n\t\tfloat q = a*(2.0*a*a-9.0*b)*d27+c;\n\t\tfloat ppp = p*p*p;\n\t\tfloat D = q*q+4.0*ppp*d27;\n\t\tfloat delta = -a*d3;\n\t\tif (D > EPSILON)\n\t\t{\n\t\t\tz = sqrt(D);\n\t\t\tfloat u = (-q+z)*0.5;\n\t\t\tfloat v = (-q-z)*0.5;\n\t\t\tu = sign(u)*pow(abs(u),d3);\n\t\t\tv = sign(v)*pow(abs(v),d3);\n\t\t\tr[0] = u+v+delta;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (D < -EPSILON)\n\t\t{\n\t\t\tfloat u = sqrt(-p*d3)*2.0;\n            float s = -sqrt(-27.0/ppp)*q*0.5;\n            if (abs(s) > 0.) {}\n\t\t\tfloat v = acos(s)*d3;\n\t\t\tr[0] = u*cos(v)+delta;\n\t\t\tr[1] = u*cos(v+2.0*PI*d3)+delta;\n\t\t\tr[2] = u*cos(v+4.0*PI*d3)+delta;\n\t\t\treturn 3;\n\t\t}\t\t\n\t\telse\n\t\t{\n\t\t\tq = sign(q)*pow(abs(q)*0.5,d3);\n\t\t\tr[0] = 2.0*-q+delta;\n\t\t\tr[1] = q+delta;\n\t\t\treturn 2;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (abs(b) <= EPSILON && abs(c) > EPSILON)\n\t\t{\n\t\t\tr[0] = -d/c;\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat D = c*c-4.0*b*d;\n\t\t\tfloat z = 1.0/(2.0*b);\n\t\t\tif (D > EPSILON)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tr[0] = (-c-D)*z;\n\t\t\t\tr[1] = (-c+D)*z;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse if (D > -EPSILON)\n\t\t\t{\n\t\t\t\tr[0] = -c*z;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nvec2 getPositionOnBezierCurve(float t, vec2 p0, vec2 p1, vec2 p2) \n{\n\tfloat fOneMinusT = 1.0-t;\n\tvec2 pos = fOneMinusT*fOneMinusT*p0+2.0*t*fOneMinusT*p1+t*t*p2;\n\treturn pos;\n}\n \nfloat calculateDistanceToQuadraticBezier(vec2 p, vec2 p0, vec2 p1, vec2 p2) \n{\n\tvec2 dP0P = p0-p;\n\tvec2 dP1P0 = p1-p0;\n\tvec2 sP0P2 = p0+p2-p1*2.0;\n\tfloat a = dot(sP0P2,sP0P2);\n\tfloat b = dot(dP1P0,sP0P2)*3.0;\n\tfloat c = dot(dP1P0,dP1P0)*2.0+dot(dP0P, sP0P2);\n\tfloat d = dot(dP0P,dP1P0);\n\tfloat r[3];\n\tint roots = findRoots(a,b,c,d,r);\n\tfloat dist = MAX;\n    float tmp;\n    if (roots > 0 && r[0] >= 0. && r[0] <= 1.) {\n        dist = distance(p,getPositionOnBezierCurve(r[0],p0,p1,p2));\n        //return r[0] * 50.;\n    }\n    if (roots > 1 && r[1] >= 0. && r[1] <= 1.) {\n        dist = min(dist, distance(p,getPositionOnBezierCurve(r[1],p0,p1,p2)));\n    }\n    if (roots > 2 && r[2] >= 0. && r[2] <= 1.) {\n        dist = min(dist, distance(p,getPositionOnBezierCurve(r[2],p0,p1,p2)));\n    }\n \tdist = min(dist, min(distance(p, p0), distance(p, p2)));\n\treturn dist;\n}\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy;\n\t\n\tvec2 b0_a = vec2(0.25, .5) * iResolution.xy;\n\t// vec2 b1 = vec2(0.5, .75 + .1*sin(iTime)) * iResolution.xy;\n\tvec2 b1_a = iMouse.xy;\n\tvec2 b2_a = vec2(.5, .5) * iResolution.xy;\n    \n    vec2 b0_b = vec2(0.5, .5) * iResolution.xy;\n\t// vec2 b1 = vec2(0.5, .75 + .1*sin(iTime)) * iResolution.xy;\n\tvec2 b1_b = iResolution.xy-iMouse.xy;\n\tvec2 b2_b = vec2(.75, .5) * iResolution.xy;\n    \n\tvec2 mid = .5*(b0_a+b2_a) + vec2(0.0,0.01);\n\t\n\tfloat d_a = calculateDistanceToQuadraticBezier(xy, b0_a, b1_a, b2_a);\n\tfloat d_b = calculateDistanceToQuadraticBezier(xy, b0_b, b1_b, b2_b);\n    float d = min(d_a, d_b);\n    \n\tfloat thickness = 1.0;\n\t\n\tfloat a;\n\t\n\tif(d < thickness) {\n\t  a = 1.0;\n\t} else {\n\t  // Anti-alias the edge.\n\t  a = 1.0 - smoothstep(d, thickness, thickness+1.0);\n\t}\n\t\n\t//fragColor = vec4(a,1.0,1.0, 1.0);\n\t\n\tfragColor = vec4(a,a,mod(d/50.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}