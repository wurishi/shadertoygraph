{"ver":"0.1","info":{"id":"dds3R8","date":"1696526723","viewed":64,"name":"Simple Mandelbrot Set Render","username":"samkhorner","description":"A simple Mandelbrot set render","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colourGradient[15] = vec3[15](vec3(0.098,0.027,0.102),vec3(0.035,0.004,0.184),vec3(0.016,0.016,0.286),vec3(0.0,0.027,0.392),vec3(0.047,0.173,0.541),vec3(0.094,0.322,0.694),vec3(0.224,0.49,0.82),vec3(0.525,0.71,0.898),vec3(0.827,0.925,0.973),vec3(0.945,0.914,0.749),vec3(0.973,0.788,0.373),vec3(1.0,0.667,0.0),vec3(0.8,0.502,0.0),vec3(0.6,0.341,0.0),vec3(0.416,0.204,0.012));\nvec2 zSquared(in vec2 z){\n    // Where x is real and y is imaginary\n    vec2 result = vec2(0,0);\n    result.x = z.x * z.x - z.y * z.y;\n    result.y = z.x * z.y * 2.0;\n    return result;\n}\n\nvec3 mandelbrot(in vec2 c, in int df){\n    vec2 z = c;// Initial value of z\n    int i = 0;// Number of iterations\n    // Iterations < max && |z| < 2\n    while(i <= df && z.x * z.x + z.y * z.y <= 4.0){\n        z = zSquared(z) + c;// Mandelbrot Quadratic\n        i += 1;\n    }\n    return vec3(1.0 - float(i)/float(df),0,0);// Returns a RGB value, iterations/max ensures that only numbers\n                          // inside the set are black\n}\n\nvec3 pointOrbitTrappedMandelbrot(in vec2 c, in int df){\n    vec2 z = c;// Initial value of z\n    int i = 0;// Number of iterations\n    float dist = 10e5f;\n    // Iterations < max && |z| < 2\n    while(i < df && z.x * z.x + z.y * z.y <= 16.0){\n        z = zSquared(z) + c;// Mandelbrot Quadratic\n        i += 1;\n        dist = min(dist, length(z));\n    }\n    vec3 colA = colourGradient[15 - int(clamp(sqrt(dist),0.,1.) * 15. - 1.)-2];\n    vec3 colB = colourGradient[15 - int(clamp(sqrt(dist),0.,1.) * 15. - 1.)-1];\n    float interp = clamp(sqrt(dist),0.,1.) * 15. - 1. - float(int(clamp(sqrt(dist),0.,1.) * 15. - 1.));\n    return mix(colB, colA, interp);\n    //return vec3(sqrt(dist));\n    //return colourGradient[15 - int(clamp(sqrt(dist),0.,1.) * 15. - 1.) - 1];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Ensures the correct scale\n    uv.x = uv.x * 2.0 - 2.5;\n    uv.y = uv.y * 2.0 - 1.0;\n\n    vec3 col = pointOrbitTrappedMandelbrot(uv,50);\n    //vec3 col = mandelbrot(uv,50);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}