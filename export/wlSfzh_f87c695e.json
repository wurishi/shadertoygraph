{"ver":"0.1","info":{"id":"wlSfzh","date":"1598291552","viewed":101,"name":"Murky","username":"Vectornaut","description":"One of my ray-marching practice projects from the CODAME shaders workshops, Aprilâ€“May 2020. Playing with lighting and camera movement techniques from the May 16 workshop, \"Explorations in Raymarching.\"","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","aerialperspective","atmosphericscattering","codame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// playing with lighting and camera movement techniques from the may 16\n// \"explorations in raymarching\" workshop. i threw in two physics goodies. the\n// halo around the sun comes from a model for scattering off atmospheric haze.\n// the camera orientation is determined from the camera's path by pretending the\n// camera is on an airplane making perfectly banked turns\n\nfloat sphere(vec3 p) {\n    return length(mod(p, vec3(2.)) - vec3(1., 1., 1.)) - 0.2;\n}\n\nconst float PI = 3.141592653589793;\n\nfloat ground(vec3 p) {\n    return p.y - 0.1*(cos(PI*p.x) + cos(PI*p.z)) + 1.1;\n}\n\nfloat scene(vec3 p) {\n    return min(sphere(p), ground(p));\n}\n\nconst float eps = 0.001;\n\nvec3 scene_grad(vec3 p) {\n    vec2 step = vec2(0.02, 0.);\n    return vec3(\n        scene(p + step.stt) - scene(p - step.stt),\n        scene(p + step.tst) - scene(p - step.tst),\n        scene(p + step.tts) - scene(p - step.tts)\n    );\n}\n\nconst int steps = 1024;\nconst float horizon = 60.;\nconst float dust_horizon = 30.;\n\nconst float SQRT2 = sqrt(2.);\nconst float SQRT3 = sqrt(3.);\n\n// sky parameters\nconst float g = 0.6; // scattering anisotropy. runs from 0 to 1\nconst float h = (1.-g)/(1.+g); // the cube root of the scattering phase opposite the sun\nconst float scat_frac = 0.4;\nvec3 sun_color = vec3(1.);\nvec3 sky_base = vec3(0.0, 0.2, 0.3);\n\nfloat dotplus(vec3 a, vec3 b) { return max(dot(a, b), 0.); }\n\n// if we're looking straight at the sun, we see the color of the sun. otherwise,\n// we see a mixture of Mie-scattered sunlight and other skylight.\n//\n// the angular size of the sun, as seen from Earth, is around acos(0.99999). the\n// sun looks small in the scene because we're using a very wide field of view.\n//\n// Mie scattering is scattering off large particles, like atmospheric haze. a\n// scattering process is described by its the phase function, which gives the\n// intensity of scattered light at each scattering angle. i'm using\n// Scratchapixel's approximate phase function for Mie scattering.\n//\n//   https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//\n// i don't know where Scratchapixel got it from, but it's the product of the\n// Rayleigh scattering phase function and the Henyey-Greenstein phase function,\n// an approximate phase function for scattering off interstellar dust.\n//\n//   https://www.oceanopticsbook.info/index.php/view/scattering/the-henyey-greenstein-phase-function\n//\n//   L. G. Henyey and J. L. Greenstein. \"Diffuse radiation in the galaxy\"\n//   https://ui.adsabs.harvard.edu/abs/1941ApJ....93...70H/abstract\n//\nvec3 skylight(vec3 dir, vec3 sun_dir) {\n    float sun_cos = dotplus(dir, -sun_dir);\n    if (sun_cos > 0.99999) {\n        return sun_color;\n    } else {\n        float rayleigh_phase = (1.+sun_cos*sun_cos)/2.;\n        float hg_phase = pow((1.-g)*(1.-g) / (1. - 2.*g*sun_cos + g*g), 1.5);\n        return mix(sky_base, sun_color, scat_frac * rayleigh_phase * hg_phase);\n    }\n}\n\nvec3 radiance(vec3 color, vec3 sky_color, vec3 normal, vec3 view_dir, vec3 sun_dir) {\n    vec3 ambient = color * sky_color;\n    vec3 diffuse = color * sun_color * dotplus(-normal, sun_dir);\n    \n    // `spec_dir` is the viewing direction with the strongest specular highlight\n    vec3 spec_dir = -reflect(sun_dir, normal);\n    vec3 specular = sun_color * pow(dotplus(view_dir, spec_dir), 32.);\n    \n    return ambient + diffuse + specular;\n}\n\nvec3 ray_color(vec3 eye, vec3 dir) {\n    // time-varying sky parameters\n    vec3 sky_color = mix(sky_base, sun_color, scat_frac*h*h*h);\n    vec3 sun_dir = normalize(vec3(cos(iTime/SQRT2), -0.5, sin(iTime/SQRT2)));\n    \n    float r = 0.;\n    for (int cnt = 0; cnt < steps; cnt++) {\n        // find ray position\n        vec3 p = eye + r*dir;\n        \n        // find scene distance\n        float dist = scene(p);\n        \n        // march\n        if (dist < eps) {\n            vec3 normal = normalize(scene_grad(p));\n            vec3 rad = radiance(vec3(1.0, 0.4, 0.5), sky_color, normal, dir, sun_dir);\n            \n            // this is a kludgy way to deal with the fact that the spheres cover\n            // the whole sky. the idea is that faraway spheres act like dust\n            // that contributes to atmospheric perspective, rather than distinct\n            // objects that block out the sky. the implementation probably isn't\n            // very physical; i just picked something that looked all right\n            vec3 atm_color;\n            if (r < dust_horizon) {\n                atm_color = sky_color;\n            } else {\n                atm_color = mix(skylight(dir, sun_dir), sky_color, exp(-0.05*(r-dust_horizon)));\n            }\n            return mix(atm_color, rad, exp(-0.2*r));\n        } else if (r > horizon) {\n            return skylight(dir, sun_dir);\n        } else {\n            r += dist;\n        }\n    }\n    \n    // if you see lime green, we ran out of steps\n    return vec3(0., 1., 0.);\n}\n\nvec3 cam_pos(float t) {\n    return vec3(SQRT3*sin(t), (1.+sin(2.*t)), 6.*t);\n}\n\nvec3 cam_vel(float t) {\n    return vec3(SQRT3*cos(t), 2.*cos(2.*t), 6.);\n}\n\nvec3 cam_accel(float t) {\n    return vec3(-SQRT3*sin(t), -4.*sin(2.*t), 0.);\n}\n\nvec3 ray_dir(vec2 screen_pt, float t) {\n    // let's pretend the camera's on an airplane. point the yaw axis along the\n    // lift vector for a perfect banked turn\n    const vec3 gravity = vec3(0., -120., 0.);\n    vec3 roll_ax = normalize(cam_vel(t));\n    vec3 thrust_lift = cam_accel(t) - gravity;\n    vec3 lift = thrust_lift - dot(roll_ax, thrust_lift)*roll_ax;\n    vec3 yaw_ax = normalize(lift);\n    vec3 pitch_ax = cross(roll_ax, yaw_ax);\n    \n    vec3 screen_dir = normalize(vec3(screen_pt, -1.));\n    return mat3(pitch_ax, yaw_ax, -roll_ax) * screen_dir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime/6.;\n    vec3 pos = cam_pos(t);\n    float small_dim = min(iResolution.x, iResolution.y);\n    vec2 jiggle = vec2(0.25);\n    vec3 color_sum = vec3(0.);\n    for (int sgn_x = 0; sgn_x < 2; sgn_x++) {\n        for (int sgn_y = 0; sgn_y < 2; sgn_y++) {\n            vec2 screen_pt = 2.*(fragCoord + jiggle - 0.5*iResolution.xy)/small_dim;\n            vec3 dir = ray_dir(screen_pt, t);\n            color_sum += ray_color(pos, dir);\n            jiggle.y = -jiggle.y;\n        }\n        jiggle.x = -jiggle.x;\n    }\n    fragColor = vec4(color_sum/4., 1.);\n}","name":"Image","description":"","type":"image"}]}