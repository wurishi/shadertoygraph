{"ver":"0.1","info":{"id":"XfjGRz","date":"1703754929","viewed":180,"name":"Fork Snowglobe_ sevenlabs 923","username":"sevenlabs","description":"Hello, this is the final version of the Snowglobe shader I made a while ago. Had to keep that unchanged during the voting.\n\nMany thanks to iq and TekF for some of the functions.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["reflection","christmas","refraction","triplanar","ambientocclusion","snow","snowglobe"],"hasliked":0,"parentid":"MtfGR8","parentname":"Snowglobe_v2"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// shader by Andrei Jiman\n//\n//Many thanks to the following:\n//            - IÃ±igo QuÃ­lez for the distance functions, shadows and ambient occlusion and noise... and smin :)\n//            - TekF for the CamPolar function and the sphere trace function\n \n#define PI (3.1415926535897932384626433832795)\n \n#define FIREFOX_HACK 0\n \nconst vec3 e = vec3(0.001,0.0,0.0);\n \n#define GetNormal(fun, p)         normalize(vec3(fun(p+e.xyy) - fun(p-e.xyy), fun(p+e.yxy) - fun(p-e.yxy), fun(p+e.yyx) - fun(p-e.yyx)));\n \nfloat dot2( in vec3 v )                                                                      {return dot(v,v);}\nfloat sdPlane( vec3 p, vec4 n )                                                    {return dot(p,n.xyz) + n.w;}\nfloat sdSphere( vec3 p, float s )                                 {return length(p)-s;}\nfloat udRoundBox( vec3 p, vec3 b, float r ) {return length(max(abs(p)-b,0.0))-r;}\nfloat udBox( vec3 p, vec3 b )                                                       {return length(max(abs(p)-b,0.0));}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n                vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n                return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n \nfloat phong(vec3 l, vec3 e, vec3 n, float power)\n{\n    float nrm = (power + 8.0) / (PI * 8.0);\n    return pow(max(dot(l,reflect(e,n)),0.0), power) * nrm;\n}\n \n#define AA 0\n \nmat3 rX(float a) {return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a), cos(a));}\nmat3 rY(float a) {return mat3(cos(a),0.0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\nmat3 rZ(float a) {return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n \nvec3 triPlanar(in sampler2D tex, in vec3 p, in vec3 n)\n{\n    mat3 texMat = mat3(texture(tex, p.yz).rgb, texture(tex, p.xz).rgb, texture(tex, p.xy).rgb);\n    return texMat * abs(n);;\n}\n \n//----------------------------------------------------------------\n// SHAPES\nconst float maxd = 10.0;\n \nfloat shapeBall(in vec3 pos)\n{\n    return sdSphere( pos, 0.6 );\n}\n \nfloat traceBall(in vec3 pos, in vec3 ray)\n{\n                float r = 0.6;\n               \n                float t = dot(-pos,ray);\n               \n                float p = length(-pos-t*ray);\n                if ( p > r )\n                                return 0.0;\n               \n                return t-sqrt(r*r-p*p);\n}\n \nfloat shapeSupport(in vec3 pos)\n{\n    vec3 p = pos;\n    p.y += 0.55;\n   \n    return sdCappedCylinder(p, vec2(0.55, 0.2)) - 0.03;;\n}\n \nfloat traceSupport(in vec3 pos, in vec3 ray)\n{\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( h<0.01 || t>maxd ) break;\n        h = shapeSupport(pos+ray*t);\n        t += h;\n    }\n \n    if( t>maxd ) t=-1.0;\n               \n    return t;\n}\n \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n \n//3d noise by iq\nfloat hash( float n )          {return fract(sin(n)*43758.5453123);}\n \nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n \nfloat shapeSnow(in vec3 pos)\n{\n    float dp = sdPlane( pos, vec4(0.0, 1.0, 0.0, 0.3) );\n   \n#if !FIREFOX_HACK\n    dp += noise(pos.xzy * 123.0) * 0.01;\n    dp += noise(pos.xzy * 35.12679) * 0.02;\n#endif\n   \n    vec3 poss1 = pos + vec3(0.0, 0.2, 0.0);\n    poss1 *= 0.99 + noise(pos * 200.0) * 0.01;\n   \n    vec3 poss2 = pos - vec3(0.0, 0.05, 0.0);\n    poss2 *= 0.99 + noise(pos * 200.0) * 0.02;\n   \n    float ds1 = sdSphere(poss1, 0.2);\n    float ds2 = sdSphere(poss2, 0.13);\n   \n    ds1 = smin(ds1, ds2, 0.03);\n   \n    dp = smin(dp, ds1, 0.05);\n   \n    return max(dp, shapeBall(pos + 0.1));\n}\n \nfloat traceSnow(in vec3 pos, in vec3 ray)\n{\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( h<0.01 || t>maxd ) break;\n        h = shapeSnow(pos+ray*t);\n        t += h;\n    }\n \n    if( t>maxd ) t=-1.0;\n               \n    return t;\n}\n \nfloat shapeTable(in vec3 pos)\n{\n    vec3 b = vec3(3.0, 0.2, 1.5);\n    vec3 p = pos;\n    p.y += 0.9;\n   \n    vec3 presentSize = vec3(0.4);\n    vec3 pPr1 = pos + vec3(1.55, +0.145, 0.5);\n   \n    pPr1 = rY(0.2 * PI) * pPr1;\n   \n    float dTable = udRoundBox(p, b, 0.1);\n    float dPresent1 = udRoundBox(pPr1, presentSize, 0.075);\n \n//enable for table feet\n#if 0\n    float l1 = udBox(p - vec3(2.5, -1.7, 1.2), vec3(0.2, 2.0, 0.2));\n    float l2 = udBox(p - vec3(2.5, -1.7, -1.2), vec3(0.2, 2.0, 0.2));\n    float l3 = udBox(p - vec3(-2.5, -1.7, 1.2), vec3(0.2, 2.0, 0.2));\n    float l4 = udBox(p - vec3(-2.5, -1.7, -1.2), vec3(0.2, 2.0, 0.2));\n   \n    dTable = min(dTable, l1);\n    dTable = min(dTable, l2);\n    dTable = min(dTable, l3);\n    dTable = min(dTable, l4);\n#endif\n   \n    return min(dTable, dPresent1);\n}\n \nfloat traceTable(in vec3 pos, in vec3 ray)\n{\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n        h = shapeTable(pos+ray*t);\n        t += h;\n    }\n \n    if( t>maxd ) t=-1.0;\n               \n    return t;\n}\n \n//----------------------------------------------------------------\n \nfloat map( in vec3 pos )\n{\n    float d1 = shapeBall(pos);\n    float d2 = shapeTable(pos);\n    float d3 = shapeSupport(pos);\n   \n    return min( d1, min(d2, d3) );\n}\n \n//----------------------------------------------------------------\n// SHADING\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n \nfloat calcSoftshadow( in vec3 _lo, in float _k )\n{\n    float _res = 1.0;\n    float _t = 0.0;\n                float _h = 1.0;\n   \n    for( int _i=0; _i<16; _i++ )\n    {\n        _h = map(_lo + lig * _t);\n        _res = min( _res, _k *_h / _t );\n                                _t += clamp( _h, 0.01, 1.0 );\n                               \n        if( _h<0.001 ) break;\n    }\n   \n    return clamp(_res,0.0,1.0);\n}\n \nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n \nvec3 background(vec3 rd)\n{\n    return texture(iChannel3, rd).xyz;\n}\n \nvec3 shadeSupport(in vec3 pos, in vec3 ray)\n{\n    vec3 col = vec3(1.0);\n    vec3 norm = GetNormal(shapeSupport, pos);\n   \n    float sha = calcSoftshadow( pos + norm*0.1, 8.0 );\n    float occ = calcOcclusion( pos, norm );\n   \n    vec3 color3D = triPlanar(iChannel2, pos, norm);\n   \n    float spec = phong(lig, ray, norm, 1.0);\n    float atten = dot(norm, lig);\n   \n    float f = 1.0 - smoothstep(0.3, 0.31, pos.y + 0.95);\n   \n    col = mix(vec3(0.2, 0.7, 0.7), vec3(1.0), f);\n    col *= atten * 0.5 + 0.5;\n    col *= sha * 0.5 + 0.5;\n    col *= occ;\n   \n    col += max(spec * sha * color3D * 2.0, 0.0);\n    col *= 0.8 + color3D * 0.5;\n   \n    return col;\n}\n \nvec3 shadeTable(in vec3 pos, in vec3 ray)\n{\n    vec3 nor = GetNormal(shapeTable, pos);\n   \n    float sha = calcSoftshadow( pos + nor*0.01, 8.0 );\n    float occ = calcOcclusion( pos, nor );\n    float atten = clamp(dot(nor, lig), 0.0, 1.0) * 0.7 + 0.3;\n    float spec = phong(lig, ray, nor, 16.0) * sha;\n               \n    vec3 tex = triPlanar(iChannel1, pos, nor);\n    vec3 col = tex;\n   \n    if (pos.y > -0.55)\n        col = vec3(0.1, 0.3, 1.0) * atten;\n   \n    if (pos.y <= -0.599)\n        spec = spec * tex.r * tex.r;\n    else\n    {\n        float n = noise(pos * 200.0);\n        spec = spec * n + n * 0.01;\n       \n        col = triPlanar(iChannel0, pos, nor);\n       \n        col.r = 0.8;\n    }\n   \n    col *= 0.5 + sha * atten * 0.5;\n    col *= occ;\n   \n    col += spec;\n   \n    return col;\n}\n \nvec3 shadeSnow(in vec3 po, in vec3 ray)\n{\n    vec3 col = vec3(0.8);\n    vec3 norm = GetNormal(shapeSnow, po);\n    float atten = dot(norm, lig);\n   \n    col *= 0.85 + atten * 0.3;\n   \n    return col;\n}\n \n#define SNOW_STEPS 16\n \nfloat snowFlakes(in vec3 pos, in vec3 ray)\n{\n    float total = 0.0;\n   \n    vec3 p2 = pos;\n   \n    p2.y += iTime / 8.0;\n    p2.x += iTime / 20.0;\n   \n    const float stepSize = 0.6 / float(SNOW_STEPS);\n   \n    for (int i=0;i<SNOW_STEPS;i++)\n    {\n        p2 += ray * stepSize * sqrt(float(i));\n        \n        vec3 p21, p22, p23;\n        \n        p21 = p2 * rX(45.0) * rY(45.0) * rZ(45.0);\n        p22 = p21 * rX(-45.0) * rY(-45.0) * rZ(-45.0);\n        p23 = p22 * rX(-45.0) * rY(45.0) * rZ(-45.0);\n       \n        float val = noise(p21.xyz * 64.0) * noise(p22.yzx * 32.0) * noise(p23.zxy * 16.0);\n        total += pow(val * 2.0, 8.0);\n    }\n   \n    return clamp(total, 0.0, 1.0) * 0.7;\n}\n \nvec3 shadeBall(in vec3 pos, in vec3 ray)\n{\n    float ior = 0.98;\n    vec3 norm = normalize(pos);\n   \n    vec3 refrRay = normalize(refract(ray, norm, ior));\n    vec3 refrPos = pos + refrRay * 0.001;\n   \n    //reflection\n    vec3 reflRay = normalize(reflect(ray, norm));\n    vec3 reflPos = pos + reflRay * 0.001;\n   \n    float tb = traceBall(refrPos, refrRay);\n    float ts = traceSnow(refrPos, refrRay);\n   \n    float ttr = traceTable(reflPos + reflRay * 0.001, reflRay);\n   \n    vec3 refl = vec3(0.0);\n   \n    if (ttr > 0.0)\n        refl = shadeTable(reflPos + reflRay * ttr, reflRay);\n    else\n        refl = background(reflRay);\n   \n    \n    vec3 col = vec3(0.0);\n   \n    if (ts > 0.0)\n        col = shadeSnow(refrPos + refrRay * ts, refrRay) * 0.95;\n    else\n    {\n        vec3 norm2 = normalize(refrPos + refrRay * tb);\n        vec3 newRay2 = refract(refrRay, norm2, ior);\n        vec3 newPos2 = refrPos + refrRay * tb;\n \n        float tt = traceTable(newPos2 + newRay2 * 0.001, newRay2);\n        float tsup = traceSupport(newPos2 + newRay2 * 0.001, newRay2);\n \n        if (tt > 0.0 && (tt < tsup || tsup < 0.0))\n        {\n            col = shadeTable(newPos2 + newRay2 * tt, newRay2) * 0.8;\n        }\n        else if (tsup > 0.0)\n            col = shadeSupport(newPos2 + newRay2 * tt, newRay2) * 0.8;\n        else\n            col = background(newRay2) * 0.6;\n    }\n   \n    float flakes = snowFlakes(refrPos, refrRay);\n   \n    col += flakes;\n   \n    float spec = phong(lig, ray, norm, 16.0);\n   \n    col += max(spec, 0.0);\n       \n    col = mix(col, refl, pow(1.0 - dot(norm, -ray), 1.0));\n   \n    col += (1.0 - dot(norm, -ray)) * 0.2;\n   \n    return col;\n}\n \n \n//----------------------------------------------------------------\n \nvoid camPolar( out vec3 pos, out vec3 dir, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 offset, in vec2 fragCoord )\n{\n    // get rotation coefficients\n    vec2 c = cos(rotation);\n    vec4 s;\n    s.xy = sin(rotation);\n    s.zw = -s.xy;\n\n    // ray in view space\n    dir.xy = fragCoord.xy - iResolution.xy*.5 + offset;\n    dir.z = iResolution.y*zoom;\n    dir = normalize(dir);\n\n    // rotate ray\n    dir.yz = dir.yz*c.x + dir.zy*s.zx;\n    dir.xz = dir.xz*c.y + dir.zx*s.yw;\n\n    // position camera\n    pos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n   \n#if AA\n\tvec2 off[4];\n    float osize = 0.25;\n    off[0] = vec2(-osize, -osize);\n    off[1] = vec2(osize, -osize);\n    off[2] = vec2(-osize, osize);\n    off[3] = vec2(osize, osize);\n   \n    for (int i = 0; i < 4; i++)\n    {\n        vec2 q = vec2(0.0);\n#else\n        vec2 q = fragCoord.xy / iResolution.xy;\n#endif\n        vec2 p = -1.0 + 2.0 * q;\n        p.x *= iResolution.x/iResolution.y;\n\n        vec3 camPos = vec3(0.0, 0.0, 0.0);\n        vec2 camRot = vec2(0.3, iTime * 0.2);\n\n        camRot.x += iMouse.y * 0.003;\n\n        vec3 ro, rd;    \n#if AA\n        camPolar(ro, rd, camPos, camRot, 1.8 + 2.0 * iMouse.y * 0.002, 1.0, off[i], fragCoord);\n#else\n        camPolar(ro, rd, camPos, camRot, 1.8 + 2.0 * iMouse.y * 0.002, 1.0, vec2(0.0), fragCoord);\n#endif\n\n        float tBall = traceBall(ro,rd);\n        float tTable = traceTable(ro, rd);\n        float tSupport = traceSupport(ro, rd);\n\n        int hit = 0;\n\n        vec3 renderColor = vec3(0.0);\n        if ((tBall > 0.0) && (tBall < tSupport || tSupport < 0.0) && (tBall < tTable || tTable < 0.0))\n        {\n            renderColor = shadeBall(ro+rd*tBall, rd);\n        }\n        else if ((tSupport > 0.0) && (tSupport < tTable || tTable < 0.0))\n        {\n            renderColor = shadeSupport(ro+rd*tSupport, rd);\n        }\n        else if (tTable > 0.0)\n        {\n            renderColor = shadeTable(ro+rd*tTable, rd);\n        }\n        else\n            renderColor = background(rd);\n\n        col += renderColor;\n   \n#if AA\n    }\n   \n    col /= 4.0;\n#endif\n               \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}