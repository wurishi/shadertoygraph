{"ver":"0.1","info":{"id":"wtjczR","date":"1593620782","viewed":493,"name":"MÃ¶bius Spiral with Hex Grid","username":"mla","description":"Inverts at mouse position (so you can get to see both poles).\n\ncf. [url]https://www.shadertoy.com/view/wlByRR[/url]","likes":16,"published":3,"flags":16,"usePreview":0,"tags":["spiral","mobius","complex","atanh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Complex log with hex grid\n//\n// mla, 2020\n//\n// Complex log maps the strip with -PI < Im(z) < PI to the complex\n// plane with a branch cut on the negative real axis (for log).\n// A transformed pattern that repeats vertically with a\n// period of 2PI will then appear seamless across the branch cut.\n//\n// See eg. https://www.shadertoy.com/view/WdSSWz for the square pattern case.\n// A hexagonal grid is slightly more complicated.\n//\n// 'm' shows transition from x to log(x)\n// 'b' shows untransformed plane\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Just show the untransformed band between -PI and PI.\nbool showband = false;\n// Do a gradual transition from x to log(x), this disables\n// the inversion as it's too confusing with it.\nbool mixit = false;\n\n// Constants for hexagonal grid\nconst float X = 1.732050808; // sqrt(3)\nconst float Y = 0.577350269; // 1/sqrt(3)\nconst mat2 M = 0.5*mat2(1,-X,1,X);\nconst mat2 Minv = mat2(1,1,-Y,Y);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  showband = key(CHAR_B);\n  mixit = key(CHAR_M);\n  // From start point p in the grid, go A up and B/2 along to\n  // arrive at point q. A and B must be of same parity for\n  // this to work with K = 1.0. Now rotate grid so q is\n  // vertically above p, and scale so the distance between\n  // them is 2PI. K > 1 adds more triangles so all parities\n  // of A and B work (as far as the grid skeleton is concerned).\n  // Not sure of exact relationship between N, the number\n  // of colors, and A,B,K. These all work:\n  //float A = 7.0, B = 4.0, K = 2.0, N = 8.0;\n  float A = 6.0, B = 1.0, K = 6.0, N = 6.0;\n  //float A = 3.0, B = 5.0, K = 3.0, N = 3.0;\n  //float A = 4.0, B = 3.0, K = 2.0, N = 3.0;\n  //float A = 7.0, B = 3.0, K = 4.0, N = 12.0;\n  //float A = 3.0, B = 5.0, K = 1.0 + floor(iTime), N = 3.0; // Test\n\n  float scale = 1.0;\n  if (showband) scale = 4.0;\n    \n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n\n  vec2 m = vec2(-0.5);\n  if (iMouse.x > 1.0) {\n    m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= scale;\n  }\n  if (!showband) {\n    z -= m;\n    if (!mixit) z /= dot(z,z);\n    z += m;\n    float t = 1.0;\n    if (mixit) {\n      t = mod(0.2*iTime,4.0);\n      t = min(t,4.0-t);\n        t -= 0.5;\n        t = clamp(t,0.0,1.0);\n    }\n    z = mix(z,clog(z),smoothstep(0.0,1.0,t));\n  }\n\n  vec3 col = vec3(0);\n  z /= PI;\n  if (abs(z.y) < 1.0) {\n    // Alignment of rotated triangular grid.\n    // Rotated grid should fit between -1 < y < 1\n    // with top and bottom edges coherent.\n    vec2 rot = vec2(A,B/X);\n    z = cmul(rot,z);\n    if (!key(CHAR_T)) z.x += 0.1*iTime*length(rot);\n    z *= 0.25*K;\n\n    // Hexagonal grid.\n    z *= X;\n    z.x += 0.5;\n    z = Minv*z; // Convert to square grid\n    ivec2 index = ivec2(floor(z)); // Remember cell in grid\n    z -= floor(z);\n    z = M*z; // Back to triangles\n    z.x -= 0.5;\n\n    // Color from index\n    col = hsv2rgb(vec3(float(index.x+index.y)/N,1,1));\n    bool inlower = z.y < 0.0; // Point is in lower triangle,\n    if (inlower) col *= 0.6;\n    // Shade edges of triangle\n    z = abs(z);\n    float d = z.y;\n    d = min(d,abs(dot(z-vec2(0.5,0),0.5*vec2(X,1))));\n    col *= smoothstep(0.02,0.05,d);\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.1415929;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n","name":"Common","description":"","type":"common"}]}