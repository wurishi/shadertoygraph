{"ver":"0.1","info":{"id":"WlBGDV","date":"1586705810","viewed":331,"name":"Spring Tree","username":"blackle","description":"boing","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["helix","spring","coil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//boing\nfloat map(vec3 p, float height, float k) {\n    vec3 pc = vec3(normalize(p.xy)*0.2, clamp(p.z, 0.0,height/k));\n    float d2 = asin(sin((p.z*k+0.5*atan(pc.x,pc.y)-iTime*acos(-1.)*2.0)))/k;\n    \n    return length(vec2(distance(p, pc), d2))-0.08;\n}\n\nfloat map2(vec3 p, inout vec3 q, inout float angl) {\n    q=p;\n    angl = 0.5;\n    float h = 15.0;\n    float c = 8. + cos(iTime*acos(-1.)*0.5)*0.5;\n    float dist = map(p, h, c);\n    vec3 pc = p;\n    float X = 0.6 + sin(iTime*acos(-1.)*0.5)*0.1;\n    float mul = 1.0;\n    for (int i = 0; i < 10; i++) {\n    \tpc -= vec3(0.0,0.0,(h+0.5)/c*mul);\n        float stor = sign(pc.y);\n   \t\tpc = vec3(pc.x, abs(pc.y)-0.1, pc.z);\n    \tmat3 rot = mat3(1.0, 0.0, 0.0,\n                    0.0, cos(X), sin(X),\n                    0.0,-sin(X), cos(X));\n    \tpc=rot*pc;\n\t\tpc=(rot*rot*pc.zyx).zyx;\n        h*=0.93;\n        X*=0.95;\n        mul*=0.84;\n        c*=1.03;\n        float dist2 = map(pc/mul, h, c)*mul;\n        if (dist2 < dist) {\n            float piss = pc.z/(h/c);\n        \tangl += stor * pow(2.0, -float(i+1))*piss;\n    \t\tdist = dist2;\n            q=pc/mul;\n        }\n    }\n    \n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float X = 0.3;\n    mat3 rot = mat3(cos(X), sin(X), 0.0,\n                   -sin(X), cos(X), 0.0,\n                       0.0, 0.0, 1.0);\n    vec3 origin = vec3(12.0,0.0,0.0);\n    vec3 dir = -normalize(origin - vec3(0.0, uv)*4.);\n    origin+=vec3(0.,0.,4.5);\n    origin*=rot;\n    dir*=rot;\n    vec3 point = origin;\n    vec3 pcolor = point;\n    float angl;\n    float mini = 10000.0;\n    float mini2 = 1.0;\n    float last1 = 0.0;\n    float last2 = 0.0;\n    for (int i = 0; i < 80; i++) {\n        float dist = map2(point, pcolor, angl);\n        mini=min(mini,dist);\n        if (last2 > last1 && last1 < dist && i > 1) mini2 = min(mini2,mini);\n        last2 = last1;\n        last1 = dist;\n        if(distance(point, origin)>30.0 || dist < 0.005) break;\n        point += dir * dist;\n    }\n    angl*=4.;\n    angl+=iTime*0.5*acos(-1.);\n    mini2= min(atan((atan(mini2)-0.001*distance(point,origin))*80.0),1.0);\n    uv*=30.;\n    float checker = cos(uv.x)*cos(uv.y) < 0. ? 0.7 : 0.95;\n    // Time varying pixel color\n    vec3 col = vec3(sqrt(cos(length(pcolor.xy)*20.0)*0.4+0.5))*sqrt(vec3(cos(angl), sin(angl), -cos(angl))*0.45+0.7)*mini2;\n    if(distance(point, origin)>30.0) col= vec3(checker*mini2);\n\n    // Output to screen\n    fragColor = vec4(pow(sqrt(col)-0.2,vec3(1.5))*1.3,1.0);\n}","name":"Image","description":"","type":"image"}]}