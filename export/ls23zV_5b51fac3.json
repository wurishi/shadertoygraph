{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// For LINUX, a good version is available at :\n// https://www.shadertoy.com/view/4djGzV\n\n// Created by sebastien durand - 01/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on :\n//     - effie - D.E.A.L (https://www.shadertoy.com/view/4ss3Ws) \n//     - _ben's - Area lights (https://www.shadertoy.com/view/ldfGWs)\n// *****************************************************************************\n\n\n\n\n\n\n//    ------------------------------------------------\n//  !!!             >>>  IMPORTANT  <<<              !!! \n//  !!! Decomment this on Windows, it may works fine !!!\n//  !!!   Not sure for Linux (pease comment if ok)   !!!\n//    ------------------------------------------------\n\n\n\n\n\n\n\n\n#define ANIMATION\n\n// Precise shape\n//#define PRECISE\n\n\n\n\n\n\n\n\n\n#define PRECALCULATE\n\n// not happy at all if commented !  :'(\n\n// for Linux, a dancing version is available at :\n// https://www.shadertoy.com/view/4djGzV\n\n\nconst vec3 LaserColor = vec3(.2,.2,1.);\nconst float \n\tSpecFalloff=3.3335,\n\tBloomFalloff=5000.0, \n\tAttenFalloff=1.;//season to taste (higher # falls quicker)\n//const float SpecFalloff=33.5, BloomFalloff=50000.0, AttenFalloff=10.0;//season to taste (higher # falls quicker)\n\n#define TAO 6.28318530718\n#define NB_ITER 45\n#define MAX_DIST 400.\n#define PRECISION .0001\n\n\n// - LegoMan Constants & Globals ------------------------------------------\n\n#define HEAD 1.\n#define SHIRT 2.\n#define MIDDLE 3.\n#define LEGS 4.\n#define ARMS 5.\n#define HAND 6.\n\nconst float \n\tlegh = 1., \n\tlege=.34, \n\tlegx=.31;\n\nfloat laserLength = 0.;\nmat2 handmat;\n\n// -- Tools -----------------------------------------------------------\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\nvec2 minObj(in vec2 o1, in vec2 o2) {\n    return (o1.x<o2.x) ? o1 : o2;\n}\n\nmat2 Rot(in float a) {\n\tfloat sa=sin(a), ca=cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\n// -------------------------------------------------------------------\n\n//vec4 boundingSphere;\nvec3 armn = normalize(vec3(-.4,-1.,-.5) - vec3(-.25,-.5,0));\nvec2 boby2 = normalize(vec2(1,.15));\n\n// -- Renderer Constants & Globals -------------------------------------\nvec3 sunLight = normalize(vec3(-25,25.,-10));\nvec2 fCoord;\n\n// -- Legoman position and color -------------------------------------\n\nstruct Legoman {\n#ifdef ANIMATION\n\n    #ifdef PRECALCULATE\n\tmat2 \n\t\trhead,\n\t\trarm_left, rarm_right,\n\t\trleg_left, rleg_right,\n\t\trhand_left, rhand_right,\n\t\trroll;\n    #else\n\tfloat \n\t\thead,\n\t\tarm_left, arm_right,\n\t\tleg_left, leg_right,\n\t\thand_left, hand_right,\n\t\troll;\n    #endif\n#endif\n\tvec3 pos;\n\tvec3 c_shirt, c_arms, c_middle, c_legs;\n};\n\n\tLegoman man\n#ifdef ANIMATION\n  #ifdef PRECALCULATE\n    ;\n  #else\n \t= Legoman(\n\t\t  -.2, \n\t\t  2.,-.4,.6,-.5, 0.,0.,\n\t\t  0.,\n\t\t  vec3(0,-1.9,0),\n\t\t  vec3(.96,.92,.75),vec3(.39,.17,.1),  vec3(.3,.1,0.), vec3(.69,.54,.39));\n        \n  #endif\n#endif\n\t\n// -- Distance functions -----------------------------------------------\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat roundCylinder(in vec3 p, in float h, in float r1, in float r2) {\n    float a = abs(p.y)-(h-r2), b = length(p.xz)-r1;\n    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n}\n\nfloat head(in vec3 p) {\n    float d = max(abs(p.y+.4)-.3, length(p.xz)-.326);\n    d = min(d, roundCylinder(p, .425,.51,.1));\n    p.y -= .425;\n    return min(d, roundCylinder(p, .173, .245,.025));\n}\n\nfloat body(in vec3 p) {\n    vec3 vd = abs(p) -  vec3(.75,.6,1.);\n    float d = min(max(vd.x,max(vd.y,vd.z)),0.0) + length(max(vd,0.0));\n    p.x = abs(p.x);\n    d = max(dot(p.xy, boby2)-.7,d);\n    p.y -= .4;    \n    d = min(d, length(max(abs(p)- vec3(.47,.14,.45),0.0))-.16);\n    return max(abs(p.z)-.392, d);\n}\n\nfloat leg(in vec3 p) {\n    float d = length(p.zy)-lege;\n    d = min(d, length(max(abs(p+vec3(0.,legh*.5,-.08))-vec3(legx,legh*.5,lege-.08),0.)));\n    d = min(d, length(max(abs(p+vec3(0.,legh,.02))-vec3(legx,.15,lege+.02),0.)));\n    d = max(abs(p.x)-legx, d)-.02;\n#ifdef PRECISE\n    vec3 dd = abs(p+vec3(0.,legh,-.08))-vec3(legx-.1,legh+.2,lege-.18);\n    float d2 = min(max(dd.x,max(dd.y,dd.z)),0.) + length(max(dd,0.));\n    dd = abs(p+vec3(0.,legh+.1,.02))-vec3(legx-.1,.15,lege-.98);\n    d2 = min(d2, min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.)));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-vec2(0,-.1))-.24));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-vec2(0,-.8))-.24));\n    return max(-d2,d);\n#else\n\treturn d;\n#endif\t\n}\n\nfloat arm(in vec3 p) {\n    float d = smin(sdCapsule(p, vec3(0), vec3(-.25,-.5,0), .22, .23), \n\t\t\t\t   sdCapsule(p, vec3(-.25,-.5,0), vec3(-.4,-1.,-.5), .23, .24),.02); \n    return max(dot(p, armn) - .9, d);\n}\n\nfloat hand(in vec3 p) {\n    float d1 = length(p)-.15;\n\tp.y+=.29;\n    float d=length(p.xy);\n    return max(abs(p.z+.09)-.2, max(-length(p.xy+vec2(-.1,.25))+.2, max(-d+.18, smin(d1, d-.26,.02))));\n}\n\nvec2 legoman(in vec3 p, in Legoman lego) {\n\tfloat sa,ca, a;\n\tbool isLeft = p.x>0.;\n\t\n\t// - Head & Shirt --------------------\n\tvec2 dHead = vec2(head(p+vec3(0,-1.4,0)), HEAD),\n    \t dBody = vec2(body(p+vec3(0,-.15,0)), SHIRT);\n \n\t// - Middle --------------------------\n    float middle = length(max(abs(p+vec3(0,.44,0))- vec3(.65,.1,.325),0.0))-.05;\n    middle = min(middle,roundCylinder(p.yxz+vec3(.76,0,0),.06,.39,.02));\n    vec2 dMiddle = vec2(middle,MIDDLE);   \n\t// - Legs ----------------------------\n    \n\tvec3 p1 = p;\n\tp1.y +=.77;\n#ifdef ANIMATION\n    #ifdef PRECALCULATE    \n\tp1.yz *= lego.rleg_left;\n\t#else\n    p1.yz *= Rot(-lego.leg_left);\n\t#endif\t\n#endif\t\n\tp1.x += .38;\n\tvec2 dLeg = vec2(leg(p1), LEGS);\n    \n    p1 = p;\n\tp1.y +=.77;\n#ifdef ANIMATION\n    #ifdef PRECALCULATE    \n\tp1.yz *= lego.rleg_right;\n\t#else\n    p1.yz *= Rot(-lego.leg_right);\n\t#endif\t\n#endif\t\n\tp1.x -= .38;\n\tdLeg = minObj(dLeg, vec2(leg(p1), LEGS));\n    \n\tp.x = -abs(p.x);\n\n\t// - Arms ----------------------------\n\tp1 = p;\n    p1 += vec3(.7,-.55,0);\n#ifdef ANIMATION\t\n    #ifdef PRECALCULATE\n\tp1.yz *= isLeft?lego.rarm_left:lego.rarm_right;\n\t#else\n    p1.yz *= Rot(isLeft?-lego.arm_left:-lego.arm_right);\n    #endif\n#endif\t\n    vec2 dArm = vec2(arm(p1), ARMS);\n\t\n\t// - Hands ---------------------------\n\tp1 += vec3(.35,.85,.35);\n\tp1.yz *= handmat;\n#ifdef ANIMATION\t\n    #ifdef PRECALCULATE\n\tp1.xz *= isLeft?lego.rhand_left:lego.rhand_right;\n\t#else\n    p1.xz *= Rot(isLeft?-lego.hand_left:-lego.hand_right);\n    #endif\n#endif\n    vec2 dHand = vec2(hand(p1), HAND);\n\n\t// - Mix -----------------------------\n    return minObj(minObj(minObj(minObj(minObj(dHead, dBody),dHand),dArm),dMiddle),dLeg);\n}\n\nvec3 ManRef(vec3 p) {\n\tp *= 10.;\n#ifdef ANIMATION\t\n     #ifdef PRECALCULATE\n\tp.yz *= man.rroll;//Rot(man.leg_right);\n\t#else\n    p.yz *= Rot(man.roll);//Rot(man.leg_right);\n\t#endif\n#endif\n\treturn p + man.pos;\n}\n\n// -- Legoman colors ----------------------------------------- \n\nvec3 getTexture(in vec3 p, in float m, in Legoman lego) {\n\tp = ManRef(p);\n\tvec3 c;   \n  \n    if (m == HEAD) {\n\t\tc = vec3(1.,1.,0);\n#ifdef ANIMATION\t\n    #ifdef PRECALCULATE\n\t\tp.xz*= lego.rhead;\n\t#else\n        p.xz*= Rot(lego.head);\n\t#endif\t\t\n#endif\t\t\n\t\tif (p.z<0.) { // draw face\t\t\t\n\t\t\tvec2 p2 = p.xy;\n\t\t\tp2.y -= 1.46;\n\t\t\tp2 *= 100.; // scale because \n\t\t\tfloat face_r = 27.;\n\t\t\tfloat face_x = face_r*0.453596121, //face_r*cos(a); // precalcul\n\t\t\t\t  face_y = -face_r*0.89120736; //face_r*sin(a); // precalcul\n\t\t\tfloat px = abs(p2.x);\n\t\t\tfloat e = 4.-.08*px;\n\t\t\tfloat v = (px<face_x && p2.y<-e) ? abs(length(p2)-face_r)-e : \n\t\t\t\t\t  (p2.y<-e) ? length(vec2(px,p2.y)-vec2(face_x,face_y))-e :\n\t\t\t\t\t  length(vec2(px,p2.y)-vec2(face_x,-face_y*.1))-1.8*e; \n\t\t\tv = clamp(v, 0., 1.);\n\t\t\tc = mix(vec3(0), c, v);\n\t\t}\n    } else {\n        c = m == HAND   ? vec3(1.,1.,0.) :\n\t\t\tm == SHIRT  ? lego.c_shirt :\n\t\t\tm == MIDDLE ? lego.c_middle :\n\t\t\tm == LEGS   ? lego.c_legs : lego.c_arms;\n    }\n\treturn c;\n}\n\n// Standard Ray-Marching stuff --------------------------------------------\n\nfloat DEL(vec3 p){ // distance estimated light\n\tp = ManRef(p);\n\tp += vec3(.7,-.55,0);\n#ifdef ANIMATION\t\n    #ifdef PRECALCULATE    \n\tp.yz *= man.rarm_right;\n    #else\n\tp.yz *= Rot(-man.arm_right);\n    #endif\n#endif\t\n\tp += vec3(.35,.85,.35);\n\tp.yz *= handmat;\n#ifdef ANIMATION\t\n     #ifdef PRECALCULATE  \n\tp.xz *= man.rhand_right;\n\t#else\n    p.xz *= Rot(-man.hand_right);\n    #endif\n#endif\t\n\treturn .1*sdCapsule(p, vec3(0,-.25,0),vec3(0,-.25,-laserLength),.13, .13);\n}\n\nvec2 DE(in vec3 p) {\n\tvec2 res = legoman( ManRef(p), man);\n\treturn vec2(.1*res.x, res.y);\n}\n\n// ---------------------------\n\nvec4 cp; //closest point to light along ray (well kinda, very inaccurate if ray does not come close)\n\nvec2 map( in vec3 pos ) {\n\tfloat bump = 0.0;\n\tif(pos.y<0.005) bump = texture( iChannel0, pos.xz * 6.0 ).x * 0.002;\n\tvec2 res = vec2( pos.y + bump, 10.0 );\n\tres = minObj(res, DE(pos));\n\n\tfloat dL = DEL(pos);\n\tif(dL<cp.w) cp=vec4(pos,dL);//catch the position nearest the light as we march by (accurate only when close)\n\tif(dL<res.x)res=vec2(dL,-2.0);\n\treturn res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {//same as iq's but adding a light trap\n\tcp=vec4(1000.0);//reset the light trap\n\tvec2 res=vec2(100.0);\n\tfloat t = PRECISION*10.0;\n\tfor( int i=0; i<NB_ITER; i++ )\n\t{\n\t\tif( res.x<PRECISION||t>maxd ) break;\n\t\tres = map( ro+rd*t );\n\t\tt += res.x;\n\t}\n\tif( t>maxd ) res.y=-1.0;\n\treturn vec2( t, res.y );\n}\n\nvec3 findLightDir(vec3 p, float d){ //find the light direction given a point and estimated distance\n\tvec2 v=vec2(d,0.0);\n\treturn normalize(vec3(DEL(p-v.xyy)-DEL(p+v.xyy),DEL(p-v.yxy)-DEL(p+v.yxy),DEL(p-v.yyx)-DEL(p+v.yyx)));\n}\n\nfloat specTrowbridgeReitz( float HoN, float a, float aP ) {\n\tfloat a2 = a*a;\n\treturn (a2*aP*aP)/pow(HoN*HoN*(a2-1.)+1.,2.);\n}\n\nfloat visSchlickSmithMod( float NoL, float NoV, float r ) {\n\tfloat k = pow(r*.5+.5,2.) * .5;\n\treturn 1./(4.*(NoL*(1.-k)+k)*NoV*(1.-k)+k );\n}\n\nfloat fresSchlickSmith( float HoV, float f0 ) {\n\treturn f0+(1.-f0)*pow(1.-HoV, 5.);\n}\n\nfloat findSpecLight( vec3 pos, vec3 N, vec3 V, float f0, float roughness )\n{//calculates the specular portion of light by finding the point on the light closest to the reflected ray\n //and using that as the light direction\n\tfloat res = 0.;\n\tif (laserLength>.1){\n\tcastRay(pos, reflect( -V, N ), 3.0);//find the closest point to the light along the reflected ray\n\tfloat distLight=max(DEL(pos),length(cp.xyz-pos));//find the distance to that point\n\tvec3 NL=findLightDir(cp.xyz,cp.w); //the direction to light from closest point on reflected ray\n\tvec3 closestPoint=cp.xyz+NL*cp.w; //an estimate of the light surface point nearest the reflected ray\n\tvec3 l=normalize(closestPoint-pos); //the direction to this point\n\n\t//pretty much the same as original from here\n\tfloat NoV\t\t= clamp( dot( N, V ),0.,1.);\t\n\tvec3 h\t\t\t= normalize( V + l );\n\tfloat HoV\t\t= dot( h, V );\n\tfloat NoL\t\t= clamp( dot( N, l ),0.,1.);\t\n\tfloat alpha\t\t= roughness * roughness;\n\tfloat alphaPrime\t= clamp( 1./(1.+distLight*SpecFalloff) + alpha, 0., 1. );//not sure at all about this??\n\tfloat specD\t\t= specTrowbridgeReitz( clamp(dot(h,N),0.,1.), alpha, alphaPrime );\n\tfloat specF\t\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t\t= visSchlickSmithMod( NoL, HoV, roughness );\n\tres = specD*specF*specV*NoL;\n\t}\n\treturn res;\n}\n\t\nvec3 areaLights( vec3 pos, vec3 nor, vec3 rd, vec3 col)\n{\n\tvec3 albedo\t\t= pow(col, vec3(2.2));\n\tfloat roughness = 0.7 - clamp( 0.5 - dot( albedo, albedo ), 0.05, 0.95 );\n\tfloat dist\t= DEL(pos);\n\tvec3 L\t\t= findLightDir(pos,dist); //the direction to light\n\tfloat NdotL\t= max(0.0,dot(nor,L));\n\tvec2 vShad\t= castRay(pos, L, 0.5);\n\tfloat shad\t= ((vShad.y>-0.5)?1.0-NdotL:1.0);\n\tfloat spec\t= findSpecLight( pos, nor, -rd, .3, roughness );\n\tfloat atten\t= 1.0/(1.0+dist*dist*AttenFalloff);\n\tvec3 color\t= albedo * 0.63 * NdotL * atten * shad + spec;\n\treturn pow(color,vec3(1./2.2));\n}\n\nconst vec2 eps = vec2(0.001, 0. );\nvec3 calcNormal(in vec3 pos) {\n\treturn normalize(vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x ));\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0, h, t = .02;\n    for( int i=0; i<15; i++ ) {\n\t\th = DE( ro + rd*t ).x;\n\t\tres = min( res, 10.*h/t );\n\t\tt += .06;\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat CalcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<4; aoi++ ) {\n        dd = DE(nor * hr + pos).x;\n        totao += -(dd-hr)*sca;\n        sca *= .8;\n        hr += .03;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\nvec3 render( in vec3 ro, in vec3 rd ) {\n\tvec2 res = castRay(ro,rd,MAX_DIST);\n\tvec3 pos, nor, c0, col = LaserColor/(1.+cp.w*cp.w*BloomFalloff);\n\tif( res.y>-0.5 ) {\n\t\tpos = ro + res.x * rd;\n\t\tnor = calcNormal(pos); // TODO le faire direct sur le bon objet\n\t\tif (res.y>0.5&&res.y<10.) {\n\t\t\tc0 =  getTexture(pos, res.y, man); \n\t\t} else {\n\t\t\tc0 = .5*textureLod( iChannel0, pos.xz, 0.).xxx;\n\t\t\t//c*=vec3(.4,1.2,.4);\n\t\t}\n\t\tc0;\n\t\tfloat sh = 1.,\n          ao = CalcAO(pos, nor ),\n          amb = clamp(.5+.5*nor.y, .0, 1.),\n          dif = clamp(dot( nor, sunLight ), 0., 1.);\n\t\tsh = SoftShadow( pos, sunLight); \n\t\tdif *= (.1+.8*sh); \n\n\t\tvec3 brdf =\n\t\t\tao*.2*(amb)+// + bac*.15) +\n\t\t\t1.2*dif*vec3(1.,.9,.7);\n\t\n\t\tfloat\n\t\t\tpp = clamp(dot(reflect(rd,nor), sunLight),0.,1.),\n\t\t\tspe = 4.*sh*pow(pp,16.),\n\t\t\tfre = ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\t\n\t\tvec3 c = c0*(brdf + spe) + fre*(.5*c0+.5);//*exp(-.01*res.x*res.x);\n   \t//\treturn sqrt(c);\n\t\tcol = .2*sqrt(c)+ max(col,LaserColor*areaLights( pos, nor, rd, c0 ));\n\t}//else if(res.y<-1.5)col=vec3(1.0);\n\treturn clamp(col,0.0,1.0);\n}\n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return LookAt(cp-ro, vec3(0,1,0))*normalize(vec3((2.*fCoord-iResolution.xy)/iResolution.y, 12.0));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tfloat time = 9.0 + iTime*.2;\n\tfloat time2 = time*16.;\n    \n    handmat = Rot(-.5);\n\n\t\t// - Animation -----------------------------------------------\n#ifdef ANIMATION\n\tfloat c2 = cos(2.*time2);\n\tfloat c4 = cos(4.*time2);\n    \n#ifdef PRECALCULATE\n    \n    man.rhead = Rot(.2*c4);\n\tman.rarm_left = Rot(-1.2-.5*c2);\n    man.rarm_right = Rot(-1.2-.5*c2+.5);\n\tman.rleg_left = Rot(.8*c2);\n    man.rleg_right  = Rot(-.8*c2);\n\tman.rhand_left = Rot(.6*c2);\n    man.rhand_right = Rot(.6*c2+.5);\n\tman.rroll = Rot(-.1);\n    \n    man.pos = vec3(0,-1.9,0);\n\tman.c_shirt = vec3(.96,.92,.75);\n\tman.c_arms = vec3(.39,.17,.1);\n\tman.c_middle = vec3(.3,.1,0.);\n\tman.c_legs = vec3(.69,.54,.39);                \n\n#else\n\tman.head = .2*c4;\n\tman.hand_left = .6*c2;\n\tman.hand_right = man.hand_left+.5;\t\n\tman.arm_left  = 1.2+.5*c2;\n\tman.arm_right  = man.arm_left -.5; \n\tman.leg_left  = .8*c2;\n\tman.leg_right  = -man.leg_left;\n\tman.roll =-.1;\n#endif\n    man.pos = vec3(0,-2.2+.4*c4,0);\n#endif\n\t//------------------------------------------------------------\n\tlaserLength = clamp(mod(iTime*15., 60.)-20., 0., 3.);\n\n\tfCoord = fragCoord.xy;\n\tvec3 ro =4.*vec3(1.2*cos(iMouse.x*.01+time*2.),iMouse.y/200. + 1.2+0.6*cos(time*6.),1.2*sin(iMouse.x*.01+time*2.));\n\tvec3 rd = RD(ro,vec3(-.2, .19, 0));\t\t\n\tvec3 col = render( ro, rd );\n\n\tfragColor = vec4((q.y>.15&&q.y<.85)?col:vec3(0), 1);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls23zV","date":"1391379907","viewed":1120,"name":"Dancing Jedi","username":"iapafoto","description":">>> To see him dancing decoment line 16  - Windows: ok -  Linux: if lucky !.. (sorry) <<<\n    #define ANIMATION\nMixing classic lightening and DEAL lightening\nfor Linux, a dancing version is available at : https://www.shadertoy.com/view/4djGzV","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["shadow","lego","deal","legoman","ligthening"],"hasliked":0,"parentid":"","parentname":""}}