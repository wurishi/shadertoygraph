{"ver":"0.1","info":{"id":"XtGSRz","date":"1482349839","viewed":294,"name":"4D Raymarching","username":"Neph","description":"Orthographic projection 4D volume onto a 3D cube onto the 2D viewport. Lit by two 4D lights. I made the projection function up so it may not be the best way of doing this... Mouse to move w position, click to see normals.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","4d","tesseract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 40 \n//marching iterations (per z step)\n\n#define ZRES 100\n//projection cube resolution down z axis\n\nfloat sdTesseract( vec4 p, vec4 b ) {\n    float tt = iTime*0.2;\n    p.xy *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    p.xw *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    p.yz *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    p.yw *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n  vec4 d = abs(p) - b;\n  return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec4 p)\n{\n    float box = sdTesseract(p, vec4(0.5));\n    return box;\n}\n\nvec4 gradient (vec4 p){\n    const vec4 dx = vec4(0.1, 0.0, 0.0, 0.0);\n    const vec4 dy = vec4(0.0, 0.1, 0.0, 0.0);\n    const vec4 dz = vec4(0.0, 0.0, 0.1, 0.0);\n    const vec4 dw = vec4(0.0, 0.0, 0.0, 0.1);\n    \n    return normalize(vec4(\n        \t\tmap(p+dx) - map(p-dx),\n                map(p+dy) - map(p-dy),\n                map(p+dz) - map(p-dz),\n                map(p+dw) - map(p-dw)\n    \t\t\t));\n}\nvec3 shade(vec4 n, vec4 pos){\n    vec3 iFin = vec3(0.0);\n    float amb = 0.5;\n    {\n        vec3 col = vec3(0.7, 0.3, 0.0);\n        vec4 lpos = vec4(1.0);\n     \tvec4 lidir = normalize(lpos - pos);\n     \tfloat libdir = dot(n, lidir);\n     \tiFin += col * (libdir + amb);\n    }\n    {\n        vec3 col = vec3(0.0, 0.2, 0.7);\n        vec4 lpos = vec4(-1.0);\n     \tvec4 lidir = normalize(lpos - pos);\n     \tfloat libdir = dot(n, lidir);\n     \tiFin += col * (libdir + amb);\n    }\n    return iFin;\n}\n\nvec2 project(vec4 ro)\n{\n    float wdist = 0.0;\n    float zdist = 0.0;\n    \n    const float amt = 1.0 / float(ZRES);\n    for(float z = 0.0; z < 1.01; z += amt)\n    {\n        if(wdist > 0.5)\n            break;\n        zdist = z;\n        \n        vec3 xyz = vec3(ro.xy, z + ro.z);\n        float w = 0.0;\n        for(int i = 0; i < ITER; i++)\n        {\n            vec4 p = vec4(xyz, ro.w) + vec4(0.0, 0.0, 0.0, 1.0) * w;\n            float d = map(p);\n            w += d * 0.5;\n        }\n        wdist = w;\n    }\n    return vec2(wdist, zdist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 zw = vec2(0.0, iMouse.x / iResolution.x);\n    \n    vec2 res = project(vec4(uv.x, uv.y, zw));\n    vec3 voxel = vec3(uv, res.y);\n    vec4 fdpos = vec4(voxel, 0.0) * res.y;\n    vec4 grad = gradient(fdpos);\n\t\n    vec3 col = vec3(0.0);\n    \n    if(iMouse.z < 0.0)\n    \tcol = shade(grad, fdpos);\n    else\n    \tcol = grad.xyz;\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}