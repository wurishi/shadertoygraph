{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Checks if spesific pixel is located within these bounds\nfloat pixelInCube(vec2 p, vec4 t){\n    return float(p.x > t.x-t.z*.5 && p.x < t.x+t.z*.5 && p.y > t.y-t.w*.5 && p.y < t.y+t.w*.5);\n}\n\n// Checks if spesific pixel is located within these bounds\nfloat pixelInCircle(vec2 p, vec3 t){\n    float hypT = pow(t.z*.5,2.)+pow(t.z*.5,2.);\n    float hypP = pow(p.x-t.x,2.)+pow(p.y-t.y,2.);\n    return float(hypP < hypT);\n}\n\n// Creates a cone for the light\nfloat shadow_isInBounds(vec2 p, vec3 l, vec4 t, float side){\n    \n    float ty = t.y - t.w*.5*(float(l.x > t.x)-.5)*2.*side;\n    float tx = t.x - t.z*.5*(float(l.y < t.y)-.5)*2.*side;\n    \n\tfloat rot = atan(ty-l.y,tx-l.x)+45.;\n    float lx = l.x + cos(rot)*l.z*side;\n    float ly = l.y + sin(rot)*l.z*side;\n    \n    float angle = (ly-ty)/(lx-tx);\n    float \tf = float(p.y > ly+((p.x-lx)*angle) && lx>tx);  \n    \t\tf += float(p.y < ly+((p.x-lx)*angle) && lx<tx);\n    \n\treturn f;\n}\n\n// Culls the \"front\" of the cone so that only the \"shadow\" is visible\nfloat shadow_cullLight(float f, vec2 p, vec3 l, vec4 t){\n\tfloat ty = t.y - t.w*.5*(float(l.y > t.y)-.5)*2.;\n    float tx = t.x - t.z*.5*(float(l.x > t.x)-.5)*2.;\n    \n    float c = 1.0;\n    \n    c*= float((p.y < ty && ty > l.y) || (p.y > ty && ty < l.y));\n    c*= float((p.x < tx && tx > l.x) || (p.x > tx && tx < l.x));\n    return clamp(f-c,0.0,1.0);\n}\n\n// Checks if spesific pixel is located within these bounds\nfloat pixelInShadow(vec2 p, vec3 l, vec4 t){\n\treturn shadow_cullLight(shadow_isInBounds(p, l, t, 1.)-shadow_isInBounds(p, l, t, -1.),p,l,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(.3);\n\tvec4 cube;\n    vec4 T = vec4(fragCoord.xy,iResolution.xy);\n    vec3 light = vec3(iMouse.x+float(iMouse.x == 0.0)*T.z*.4,iMouse.y+float(iMouse.y == 0.0)*T.w*.5,20.0);\n    float time = iTime; // Controlls the rotationspeed of the circle\n    \n    color.rg += pixelInCircle(T.xy,light);\n    float circleScale = 1.01;\n    // Draw rotating circle\n    for(int i = 0; i < 6; i+=1){\n    \tcube = vec4(cos(float(i)*circleScale+time)*T.w*.3+T.z*.7,sin(float(i)*circleScale+time)*T.w*.3+T.w*.5,40.0,40.0);\n        color.r += pixelInCube(T.xy,cube);\n        color -= pixelInShadow(T.xy,light,cube)*.95;\n    }\n    \n    // Draw the corner objects\n    for(int i = 0; i < 4; i+=1){\n    \tcube = vec4(mod(floor(float(i)*.5),2.0)*-T.z*.8 + T.z*.9,mod(float(i),2.0)*-T.w*.8 + T.w*.9,40.0,40.0);\n        color.r += pixelInCube(T.xy,cube);\n        color -= pixelInShadow(T.xy,light,cube)*.95;\n    }\n    \n    // Draw the wall\n    cube = vec4(T.z*.2,0.0,10.0,T.w);\n    color.r += pixelInCube(T.xy,cube);\n    color -= pixelInShadow(T.xy,light,cube)*.95;\n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSXR1","date":"1408673205","viewed":1065,"name":"2d Shadow casting (Corner based)","username":"Tharich","description":"This is my first attempt implementing shadow casting for 2D objects.\nNotes: \nDoesn't handle thin objects well.\nJumping when shadow changes source corner.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d","lighting","shadows"],"hasliked":0,"parentid":"","parentname":""}}