{"ver":"0.1","info":{"id":"WtlXDf","date":"1564945924","viewed":150,"name":"Tamby Infinite balls","username":"TambakoJaguar","description":"I don't know why, but I got a hard time figuring out how to combine the diffuse color, reflection and fog. But I think now I got it right.\nNothing special, but still funny.\nUse mouse to move around.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["reflection","mouse","fog","balls","animation","mod","infinite","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Golf Ball\" by Emmanuel Keller aka Tambako - August 2017\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float dist;\n};\n    \nLamp lamps[3];\n\n//#define testmode;\n\nvec3 campos = vec3(0., 0., 9.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 4.7;\n\nconst vec3 ambientColor = vec3(0.1);\nconst float ambientint = 0.16;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\nconst float normdelta = 0.0001;\nconst float maxdist = 100.;\n\nconst float fogdens = 0.012;\nconst float sr = 1.;\n#ifdef testmode\nconst float gridDist = 3.2;\nconst int nblamps = 1;\n#else\nconst float gridDist = 2.2;\nconst int nblamps = 3;\n#endif\n\nconst int nbref = 3;\nconst float ior = 4.2;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvec3 posr;\n\nfloat angle;\nfloat angle2;\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat hash2(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\nvec3 rotateVec2(vec3 posr, vec2 angle)\n{\n    posr = vec3(posr.x, posr.y*cos(angle.y) + posr.z*sin(angle.y), posr.y*sin(angle.y) - posr.z*cos(angle.y));\n    posr = vec3(posr.x*cos(angle.x) + posr.z*sin(angle.x), posr.y, posr.x*sin(angle.x) - posr.z*cos(angle.x)); \n    \n    return posr;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 posr2 = mod(pos + vec3(gridDist), gridDist*2.) - vec3(gridDist);\n    vec3 posr3 = floor(0.5/gridDist*(pos + vec3(gridDist))); \n    \n    return length(posr2) - sr*(1. + 0.3*cos(iTime*2.7 + 0.55*posr3.x + 0.55*posr3.y + 0.55*posr3.z));\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.8;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 130; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist;\n  \t}\n        \n  \treturn vec2(t, dist);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    #ifdef testmode\n    return vec3(0.7);\n    #else\n    posr = floor(0.5/gridDist*(pos + vec3(gridDist)));    \n    return vec3(hash2(posr), hash2(posr + vec3(15., 7., 9.)), hash2(posr + vec3(25., 17., 49.)));\n    #endif\n}\n\nvec3 getSkyColor(vec3 ray)\n{  \n    vec3 col;\n    col.r = 0.55*clamp(0.2-ray.z, 0., 1.);\n    col.g = 0.8*clamp(0.4-ray.z, 0., 1.);\n    col.b = clamp(1.-ray.z, 0., 1.);\n    \n    col = mix (col, vec3(1.), 0.02*pow(max(0., dot(ray, vec3(0.2, 0.2, -1.))), 120.));\n    \n    return col;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tpos-= campos;\n    \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<nblamps; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n       col = getSkyColor(ray);\n    \n  return RenderData(col, pos, norm, tx);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   #ifdef testmode\n   return 1.;\n   #else\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n   #endif\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-2., 4.5, 1.), vec3(1., 1., 1.), 4.8, 0.08);\n  lamps[1] = Lamp(vec3(9., -2.5, 4.), vec3(0.77, 0.87, 1.0), 5.1, 0.1);\n  lamps[2] = Lamp(vec3(-9., -5., -4.), vec3(1.0, 0.6, 0.5), 3.6, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n    \n  float dist = traceinf.dist;     \n    \n  vec3 refray;\n  float rf = fresnel(ray, traceinf.norm, ior);\n    \n  float fogdens2 = fogdens*(0.7 + 2.3*noise(ray*8. + vec3(0.4*iTime)));\n   \n  float fogd = clamp(exp(-pow(fogdens2*dist, 2.)), 0., 1.);\n  vec3 ray0 = ray;\n    \n  col = mix(getSkyColor(ray), traceinf.col, fogd*(1. - rf));\n  //col = traceinf.col;\n  \n for (int r=0; r<nbref+1; r++)\n  {\n      if (traceinf.dist<=maxdist)\n      {\n         refray = reflect(ray, traceinf.norm);\n         if (r<nbref)\n         {\n             RenderData traceinf_ref = trace0(traceinf.pos, refray);\n             rf*= fresnel(ray, traceinf.norm, ior);\n             \n             float fogd2 = clamp(exp(-pow(fogdens2*traceinf_ref.dist, 2.)), 0., 1.);             \n             col = vec3(mix(col, mix(getSkyColor(refray), traceinf_ref.col, fogd*fogd2), rf*fogd));\n             fogd*= fogd2;\n             \n             traceinf = traceinf_ref;\n             ray = refray;\n         }\n         else\n         {\n            rf*= fresnel(ray, traceinf.norm, ior);\n            col = mix(col, getSkyColor(refray), rf*fogd);\n         }\n      }\n  }\n    \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;    \n    \n   campos = rotateVec2(campos, vec2(5.*iMouse2.x/iResolution.x, 3.1*iMouse2.y/iResolution.y + 1.6));\n   camdir = camtarget - campos;   \n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}","name":"Image","description":"","type":"image"}]}