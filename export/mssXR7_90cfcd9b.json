{"ver":"0.1","info":{"id":"mssXR7","date":"1668693857","viewed":173,"name":"- EXP - Spherical Coord. System","username":"yuempek","description":"https://medium.com/@yuempek/spherical-coordinat-system-e859ecb31825","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["texture","sphere","sphericalcoordinatesystem"],"hasliked":0,"parentid":"flyGWW","parentname":"Sphere texture mapping test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sphere has taken from https://www.shadertoy.com/view/flyGWW\n// plot has taken from https://www.shadertoy.com/view/4tB3WV\n\n#define PI 3.141592653\n#define PI2 2.*PI\n\nfloat betweenAngle(vec3 v1, vec3 v2){\n    return acos(dot(v1, v2)/length(v1)/length(v2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = (fragCoord* 2.- r)/r.y;\n    \n    vec3 col = vec3(0.5);\n    vec3 ro = vec3(0, 0, -30);\n    vec3 rd = normalize(vec3(uv, 20));\n    \n    float ll = 0.;\n    \n    vec2 rot = vec2(-1, -1) * (iMouse.yx-iResolution.yx/2.0) / 100.0; \n    \n    for(int i = 0; i < 100; i++)\n    {\n       vec3 p = ro + rd * ll;\n       \n       float dd = length(p) - 1.;\n       \n       if(dd < 0.001)\n       {\n           p.yz *= mat2(cos(rot.x), -sin(rot.x), sin(rot.x), cos(rot.x));       \n           p.xz *= mat2(cos(rot.y), -sin(rot.y), sin(rot.y), cos(rot.y));\n       \n           \n           // translation to spherical coordinate system\n           //begin\n               vec3 G = vec3(0, 0, 1);\n               vec3 Pxz = p*vec3(1,0,1);\n               vec3 Pyz = p*vec3(0,1,1);\n\n               float X = 2.*betweenAngle(Pxz-G, -G)/PI;\n               float Y = 2.*betweenAngle(Pyz-G, -G)/PI;\n\n               X *= sign(Pxz.x);\n               Y *= sign(Pyz.y);\n           //end\n           \n           X = X*0.5+0.5;\n           Y = Y*0.5+0.5;\n\n           \n           vec3 diff = texture(iChannel0, vec2(X,Y)).rgb;\n           col = diff;\n           \n           break;\n       }\n       \n       ll += dd;\n       \n       if(ll > 100.)\n          break;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).rgb,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653\nfloat t = 0.0;\n\nfloat f_x(float x, float n) {\n    // return x/(1.0-abs(x));\n    //return x*pow(abs(x), n-1.)/(1.-pow(abs(x), n));\n    return sign(x) * tan((pow(abs(x), n))*PI/2.); //alternative\n}\n\nfloat f_y(float y, float n) {\n    // return y/(1.0+abs(y));\n     //return sign(y) * pow(abs(y)/(1.+abs(y)), 1./n);\n    return sign(y) * pow(atan(abs(y))/(PI/2.), 1./n); //alternative\n}\n\n#define FUNC0 n = 0.3; Y=f_y(func0(f_x(x, n)), n)\nfloat func0(float x){\n    return 1.0;\n}\n\n#define FUNC1 n = 0.3; Y=f_y(func1(f_x(x, n)), n)\nfloat func1(float x){\n    return 1./x;\n}\n\n#define FUNC2 n = 0.1; Y=f_y(func2(f_x(x, n)), n)\nfloat func2(float x){\n    return tan(x/PI/2.0);\n}\n\n#define FUNC3 n = 1.0; Y=f_y(func3(f_x(x, n)), n)\nfloat func3(float x){\n    return pow(x, 2.0);\n}\n\n#define FUNC4 n = 1.0; Y=f_y(func4(f_x(x, n)), n)\nfloat func4(float x){\n    return sin(x);\n}\n\n#define FUNC5 n = 1.0; Y=f_y(func5(f_x(x, n)), n)\nfloat func5(float x){\n    return x*x*x;\n}\n\n#define FUNC6 n = 1.0; Y=f_y(func6(f_x(x, n)), n)\nfloat func6(float x){\n    return tan(t)*x+0.1;\n}\n\n#define FUNC7 n = 1.0; Y=f_y(func7(f_x(x, n)), n)\nfloat func7(float x){\n    return log(x);\n}\n\n#define FUNC8 n = 1.0; Y=f_y(func8(f_x(x, n)), n)\nfloat func8(float x){\n    return exp(x);\n}\n\nfloat f(float x){\n    float Y, n;\n    \n /******** buradaki fonksiyonu degistireceksin ********/\n    FUNC1;\n    \n    return Y;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float pi = atan(1.0) * 4.0;\n\n#define DISP_SCALE 2.0 \n\n#define LINE_SIZE 0.2\n\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n//Number of grid lines per unit.\n#define GRID_LINES 10.0\n\nconst vec2 GRAD_OFFS = vec2(0.00001, 0.);\n\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.xx)\n\n//PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE*(clamp(length(uv), 0., 1.)*10.0+4.0) / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f,p)))))\n\nfloat commonfunc(vec2 p)\n{\n\tfloat y = f(p.x);\n\treturn p.y - y;\n}\n\nfloat grid(vec2 p)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\t\n\tfloat halfScale = 1.0 / GRID_LINES / 2.0;\n\t\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tfloat grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n\t\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\tfloat axis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad-0.05, axisRad, axis);\n\t\n\treturn 1.-min(grid, axis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    \n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= DISP_SCALE;\n\tuv.x /= aspect.x; \n\tvec3 col = vec3(grid(uv)/5.);\n    \n    PLOT(commonfunc, vec3(1,1,1), col, uv);\n\n\t#ifdef CLIP_EDGES \n\t\tcol *= 1.0 - step(DISP_SCALE / 2.0, abs(uv.x));    \n\t#endif\n\t\n\tfragColor = vec4( vec3(col), 1.0 );\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}