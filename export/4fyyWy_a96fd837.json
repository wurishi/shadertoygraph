{"ver":"0.1","info":{"id":"4fyyWy","date":"1732357513","viewed":172,"name":"Hexagon Truchet Warp","username":"byt3_m3chanic","description":" Reworking, and older shader https://www.shadertoy.com/view/DsKXDy \noptimized code based on what I picked up from @Shane's hexagon/truchet shaders.\nAdd in some warping @mla and you get this neat effect!","likes":26,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","hexagon","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Hexagon Truchet Warp\n    11/23/2024  @byt3_m3chanic\n    \n    Reworking, and older shader https://www.shadertoy.com/view/DsKXDy \n    optimized code based on what I picked up from @Shane's hexagon/truchet shaders.\n    Add in some warping @mla and you get this neat effect!\n    \n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265\n#define PI2         6.28318530\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    20.\n\n\n// globals\nvec4 FC = vec4(0.059,0.078,0.141,0);\nvec3 hp,hit;\nvec2 gid, sid, shx, ghx, speed;\nmat2 r2;\n\n// constants\nconst float thrs = .75;\nconst float s4 = .577350;\nconst float s3 = .288683;\nconst float s2 = .866025;\nconst vec2 s = vec2(1.732,1);\n    \nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,32.93)))*4374.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec3 hue(float t) { return .35 + .35*cos(PI2*t*(vec3(1.,.85,.75)+vec3(.94,.67,.28)));}\n\n// @IQ extrude 2D sdf\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n// @Shane tile grid and functions\n// https://www.shadertoy.com/view/4td3zj\nvec4 hexGrid(vec2 uv) {\n    vec4 hC = floor(vec4(uv, uv - vec2(1,.5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\n\nvec2 map(vec3 pos) {\n    vec2 res = vec2(1e5,0);\n    \n    //@mla inversion\n    float kk = 7.5/dot(pos,pos); \n    pos *= kk;\n    \n    pos.xy += vec2(25,1.75);\n    pos.xz += speed;\n    \n    vec2 uv = pos.xz;\n    vec4 hex = hexGrid(uv/1.325);//3.65//1.325//0.6625\n    vec2 id = hex.zw, p = hex.xy;\n\n    id=mod(id,48.);\n    sid = id, shx = p;\n\n    float rnd = hash21(id);\n\n    if(rnd<.5) {\n        p *= r2;\n        p.y = -p.y;\n    } \n\n    vec2 p0 = p - vec2(-s3, .5),\n         p1 = p - vec2( s4,  0),\n         p2 = p - vec2(-s3,-.5);\n\n    vec3 d3 = vec3(length(p0), length(p1), length(p2));\n    vec2 pp = vec2(0);\n\n    if(d3.x>d3.y) pp = p1;\n    if(d3.y>d3.z) pp = p2;\n    if(d3.z>d3.x && d3.y>d3.x) pp = p0;\n\n    float circle = length(pp)-s3;\n    \n    rnd = fract(rnd*4334.343);\n    if(rnd<.4) {    \n        float c1 = 1e5, c2 = 1e5;\n        circle = length(p.x);\n        c2 = length(p1)-s3;\n        c1 = length(p1+vec2(1.155,0))-s3;\n        c1 = min(c2,c1);\n        circle = min(circle,c1);\n    }\n    float circle2 = circle;\n    \n    rnd = fract(rnd*4334.343);\n\n    circle  = abs(abs(circle )-.06)-.02;\n    circle2 = abs(abs(circle2)-.25)-.075;\n    \n    float pat = opx(circle ,pos.y-.175, .02),\n         pat2 = opx(circle2,pos.y-.075,.015);\n   \n    float tile = max(abs(hex.x)*s2 + abs(hex.y)*.5, abs(hex.y))-.46;\n\n    pat = max(pat,opx(tile,pos.y-.15,2.))-.01;\n    if(pat<res.x) {\n        res=vec2(pat,1.);\n        hit=pos;\n    }\n\n    pat2 = max(pat2,opx(tile,pos.y-.15,2.))-.004;\n    if(pat2<res.x) {\n        res=vec2(pat2,2.);\n        hit=pos;\n    }\n    \n    float flr = min(opx(tile+.01,pos.y,.05),pos.y+.01)-.03;\n    if(flr<res.x) {\n        res=vec2(flr,3.);\n        hit=pos;\n    }\n        \n    // compensate for the scaling that's been applied\n    float mul = 1./kk;\n    res.x = res.x* mul / 1.5;\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n// @Shane based on the original by @IQ.\nfloat calcAO(in vec3 p, in vec3 n) {\n\tfloat sca = 4., occ = 0.;\n    for( int i=1; i<5; i++ ) {\n        float hr = float(i)*.125/5.;        \n        float dd = map(p + hr*n).x;\n        occ += (hr - dd)*sca;\n        sca *= .8;\n    }\n    return clamp(1.-occ,0.,1.);   \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d) {\n\n    vec3 C = FC.rgb, p = ro;\n    float m = 0.;\n    \n    // marcher\n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32?ray.x*.35:ray.x;\n        m  = ray.y;\n    } \n    \n    gid=sid, ghx=shx, hp=hit;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d),\n             l = normalize(vec3(-5,10,5)),\n             h = vec3(.001);\n             \n        float diff = clamp(dot(n,l),0.,1.),\n              shdw = 1.;\n              \n        for( float t=.01;t<10.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>10. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75)*calcAO(p, n);\n\n        if(m==1.) {\n            float hs = hash21(gid);\n            float a = T*.01 +((hs+gid.x+gid.y)*.045);\n            h = hue(a);\n            ref = mix(vec3(.5),h,.5);\n        }\n        if(m==2.) {\n            h = vec3(.01);\n            ref = vec3(.2);\n        }\n        if(m==3.) {\n            float px = fwidth(p.x);\n            float hs = hash21(gid);\n            hp.xz *= rot(hs*PI2);\n            \n            float tile = max(abs(ghx.x)*s2 + abs(ghx.y)/2., abs(ghx.y))-.465;\n            \n            h = mix(vec3(.02),texture(iChannel1,hp.xz*.5).rgb*vec3(.82,.37,.08),smoothstep(px,-px,tile));\n            h = mix(h,h*.15,smoothstep(px,-px,abs(tile+.015)-.01));\n\n            ref = mix(vec3(.5),h,.5);\n        }\n\n        C = h * diff;\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    r2 = rot(1.047197);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,-2.4,5),\n         rd = normalize(vec3(uv, -1));\n\n    mat2 rx =rot(-.157);\n    ro.zy*=rx, rd.zy*=rx;\n        \n    // mouse //\n    float y = M.xy==vec2(0) || M.z < 0. ? 0. :  (M.x/R.x*.1-.05);\n    speed = (T+50.)*vec2(-(y+.1),.25);\n\n    vec3 C = vec3(0), ref = vec3(0), fil = vec3(1);\n    \n    float d = 0.,a = 0., bounces = 2.;\n    \n    // main reflective loop\n    for(float i=0.; i<bounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) {a = d; };\n    }\n   \n    C = mix(FC.rgb,C,  exp(-.0035*a*a*a));\n\n    // some overlay things\n    float ck = length(uv)-.8;\n    float px = fwidth(uv.x);\n    C = mix(C,texture(iChannel0,uv-vec2(0,T*.01)).rgb*vec3(.82,.37,.08),smoothstep(-px,px,ck)*.5);\n    C = mix(C,vec3(.95),smoothstep(px,-px,abs(ck)-.005));\n    C = mix(C,vec3(.95),smoothstep(px,-px,abs(ck-.05)-.03));\n    // gamma and output\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n","name":"Image","description":"","type":"image"}]}