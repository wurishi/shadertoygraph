{"ver":"0.1","info":{"id":"4cffWN","date":"1723740270","viewed":36,"name":"non-manifold","username":"mehtaib","description":"\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["nonmanifold"],"hasliked":0,"parentid":"wsjSR3","parentname":"simple sdf setup"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w + 3.0;\n}\n\nfloat shrepe(in vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat easeSmoothStep(float x) {\n    return -2.0 * x * x * x + 3.0 * x * x;\n}\n\nfloat map(in vec3 p0, out vec4 oTrap, in vec4 c) {\n    oTrap = vec4(1, 1, 1, 0.5);\n    vec3 p = p0;\n\n    vec3 scale = vec3(0.5, 0.5, 0.8);\n    float t1 = udTriangle(p, vec3(0.0, -1, 0.0), vec3(0.0, 1, 0.0), vec3(0.0, 0.0, 1));\n    float t2 = udTriangle(p, vec3(-1, 0.0, 0.0), vec3(1, 0.0, 0.0), vec3(0.0, 0.0, 1));\n    \n    float ll = 2.0 * (clamp(sin(iTime), -0.25, 0.25) + 0.25);\n\n    float s1 = min(t1, t2);\n    float s2 = shrepe(p / 0.25 +  vec3(4.0 * cos(iTime * 2.0), 4.0 * sin(iTime * 2.0), 0)) * 0.25;\n\n    float spheres = opSmoothUnion(s1, s2, 0.5);\n    float plane = sdPlane(p, vec4(0, 1, 0, 1.5));\n    if (plane < spheres) {\n        oTrap.x = -0.5;\n        oTrap.w = 0.0;\n    }\n    return min(plane, spheres);\n}\n\nvec3 calcNormal(in vec3 pos, in vec4 c) {\n    vec4 kk;\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.001;\n    return normalize(e.xyy*map(pos + e.xyy, kk, c) +\n                        e.yyx*map(pos + e.yyx, kk, c) +\n                        e.yxy*map(pos + e.yxy, kk, c) +\n                        e.xxx*map(pos + e.xxx, kk, c));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 res, in vec4 c) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    for (int i=0; i<64; i++)\n    {\n        h = map(ro+rd*t, tmp, c);\n        if (h<0.001||t>maxd) break;\n        t += h;\n    }\n    if (t<maxd) { resT=t; res = tmp; }\n\n    return resT;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k, in vec4 c)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i=0; i<64; i++)\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk, c);\n        res = min(res, k*h/t);\n        if (res<0.001) break;\n        t += clamp(h, 0.01, 0.5);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n    #define MISS_BOTTOM vec3(.5, 0.0, 0.0)\n    #define MISS_TOP vec3(0.0, 0.0, .5)\n\n    #define MATE_COLOR vec3(0.9, 0.5, 0.5) * 0.3\n\nvec3 applyFog(in vec3  rgb, in vec3 skyColor, in float distance) {\n    float startDist = 8.0;\n    float fogAmount = 2.0 * (1.0 - exp(-(distance-startDist) * (1.0/startDist)));\n    return mix(rgb, skyColor, clamp(fogAmount, 0.0, 1.0));\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox(vec2 p) {\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c)\n{\n    const vec3 sun = vec3(0.6, 0.6, 0.6);\n    vec4 tra;\n    float t = intersect(ro, rd, tra, c);\n\n    vec3 skybox = mix(MISS_BOTTOM, MISS_TOP, rd.y);\n    vec3 col = skybox;\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, c);\n\n        vec3 mate = MATE_COLOR;\n        //        mate.x = 1.0-10.0*tra.x;\n        if (tra.x <= -0.5) {\n            float grid = checkersGradBox(pos.xz*0.4) * 0.2 + 0.1;\n            mate = vec3(grid, grid, grid);\n        }\n\n        float occ = clamp(2.5*tra.w-0.15, 0.0, 1.0);\n        //        float occ = 0.5;\n\n        col = vec3(0.0, 0.0, 0.0);\n\n        // sky\n        {\n            float co = clamp(dot(-rd, nor), 0.0, 1.0);\n            vec3 ref = reflect(rd, nor);\n            float shadow = softshadow(pos+0.00005*nor, ref, 0.0001, 5.0, c);\n            //            float sha = occ;\n            shadow *= smoothstep(-0.1, 0.1, ref.y);\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            float fre = 0.1 + 0.9*pow(1.0-co, 5.0);\n\n            vec3 sky_color = vec3(0.8, 0.9, 1.0);\n            col  = mate*0.3*sky_color*(0.6+0.4*nor.y)*occ;\n            col +=  2.0*0.3*sky_color*(0.6+0.4*nor.y)*shadowc*fre;\n        }\n\n        // sun\n        {\n            const vec3 lig = sun;\n            float dif = clamp(dot(lig, nor), 0.0, 1.0);\n            float shadow = softshadow(pos, lig, 0.001, 64.0, c);\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\n            //            vec3 shadowc = vec3(shadow);\n            vec3 hal = normalize(-rd+lig);\n            float co = clamp(dot(hal, lig), 0.0, 1.0);\n            float fre = 0.04 + 0.96*pow(1.0-co, 5.0);\n            float spe = pow(clamp(dot(hal, nor), 0.0, 1.0), 32.0);\n\n            vec3 sun_color = vec3(1, 0.9, 0.7);\n            vec3 sun_color2 = vec3(1, 0.9, 0.7);\n            //vec3(1.00,0.90,0.70)\n\n            col += mate*3.5*sun_color*dif*shadowc;\n            col +=  7.0*3.5*sun_color2*spe*dif*shadowc*fre;\n        }\n\n        // extra fill\n        {\n            const vec3 lig = vec3(-0.707, 0.000, -0.707);\n            float dif = clamp(0.5+0.5*dot(lig, nor), 0.0, 1.0);\n            mate = vec3(0, 1, 0);\n            col += mate* 1.5*vec3(0.14, 0.14, 0.14)*dif*occ;\n        }\n\n        // fake SSS\n    //    {\n            //float fre = clamp(1.+dot(rd, nor), 0.0, 1.0);\n          //  mate = skybox;\n        //    col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\n      //  }\n\n        col = applyFog(col, skybox, t);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCoord = fragCoord.xy;\n    float t = iTime;\n    vec4 c = 0.45*cos(vec4(0.5, 3.9, 1.4, 1.1) + t*vec4(1.2, 1.7, 1.3, 2.5)) - vec4(0.3, 0.0, 0.0, 0.0);\n\n    // camera\n\n    float camTrackRadius = 3.0 + sin(t);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 camPos = vec3(camTrackRadius * cos(t), 1.0 + 0.5 * sin(t * 0.5), camTrackRadius * sin(t));\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n\n    float fPersp = 2.0;\n\n    // render\n    vec3 col = vec3(0.0);\n    for (int j=0; j<AA; j++) {\n        for (int i=0; i<AA; i++) {\n            vec2 offf = vec2(float(i), float(j))/float(AA);\n            vec2 result = 2.0 * ((screenCoord + offf) / iResolution.xy - 0.5);\n            result.x *= iResolution.x/iResolution.y;// Correct for aspect ratio\n            vec2 p = result;\n            vec3 vDir = normalize(p.x * camRight + p.y * camUp + camForward * fPersp);\n            col += render(camPos, vDir, c);\n        }\n    }\n    col /= float(AA*AA);\n    col = pow(col, vec3(1.0 / 2.2));\n\n    vec2 uv = screenCoord.xy / iResolution.xy;\n    col *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.25);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}