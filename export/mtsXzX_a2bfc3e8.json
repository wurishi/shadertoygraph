{"ver":"0.1","info":{"id":"mtsXzX","date":"1675177416","viewed":182,"name":"Rolling Sine 2","username":"ChunderFPV","description":"New version of an older shader.  Mouse X to transform.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["wave","sine","trig","polar","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define L(v)  smoothstep(l*min(fwidth(v), 1.), 0., abs(v)) // line\n#define CL(v) step(max(0., v), min(v, 1.))                 // clamp line\n#define P(v)  max(0., 1.-length((v)/.15))                  // point\n#define H(a) (sin(vec3(0, 1.047, 2.094)+(a*6.3))*.5+.5)    // hue\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec3 c = vec3(0),\n         c_sin = vec3(.9, .1, .0),\n         c_cos = vec3(.0, .5, .9);\n    \n    vec2 R = iResolution.xy,\n         uv = (XY-.5*R)/R.y*5.,\n         u = uv,\n         g, sb;\n    \n    float PI = 3.14159,\n          l = 2.,   // line size\n          b = .75,  // brightness\n          t = iTime,\n          at = PI-mod(t+PI, PI*2.), // arc time\n          x = u.x, \n          y = u.y,\n          st = sin(x+t),\n          ct = cos(x+t),\n          pa, ps, pc,\n          mx = (iMouse.z > 0.) ? \n               iMouse.x/R.x*2.-.5:\n               cos(t/2.)+.5;\n    \n    mx = smoothstep(0., 1., mx); // smooth clamp\n    \n    // grid\n    g = max(vec2(0), 1.-abs(fract(vec2(t,0)+u+.5)-.5)/fwidth(u)/2.);\n    c += max(g.x, g.y)*.25 + min(g.x, g.y)*.75;\n    \n    // non transformed waves\n    if (x < 0.)\n        c += L(y-st) * c_sin * mx,\n        c += L(y-ct) * c_cos * mx;\n    \n    // points\n    pa = round(x/PI)*PI+t;\n    ps = P(u-vec2(0, sin(pa)));\n    pc = P(u-vec2(0, cos(pa)));\n    c += H(1.-ps) * ps * 1.5;\n    c += H(pc) * pc * 1.5;\n    \n    // polar transform\n    u = u * (1.-mx) + vec2(atan(x, -y) * mx, -length(u) * mx);\n    x = u.x;\n    y = u.y;\n    st = sin(x+t);\n    ct = cos(x+t);\n    \n    c   += L(y+1.) * .3;           // unit circle\n    c.g += L(y+1.) * CL(x/at) * b; // arc length\n    \n    // waves\n    c += L(y-st) * c_sin * b;\n    c += L(y-ct) * c_cos * b;\n    \n    // lengths\n    c += L(uv.x) * CL(y/st) * c_sin * b;\n    c += L(uv.x) * CL(y/ct) * c_cos * b;\n    \n    // unit radius\n    c += L(x-at) * CL(-y) * b;\n    \n    // screen border\n    sb = abs(fract(XY/R+.5)-.5)/.05;\n    c = min(c, min(sb.x, sb.y));\n    \n    RGBA = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}