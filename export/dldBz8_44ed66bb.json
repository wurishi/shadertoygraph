{"ver":"0.1","info":{"id":"dldBz8","date":"1701119734","viewed":34,"name":"pokeball_jakeross","username":"jakeross","description":"pokeball","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pokeball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sphere\nstruct Sphere {\n    vec3 pos;\n    float r;\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n};\n\n// plane\nstruct Plane {\n    vec3 n;\n    float D;\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n};\n\n// world objects + light\nSphere sphere_0 = Sphere(vec3(0.0, 0.0, 0.45), 0.45, vec3(0.0, 0.01, 0.02), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 50.0);\nSphere sphere_1 = Sphere(vec3(1.5, 0.0, 0.45), 0.45, vec3(0.0, 0.01, 0.02), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 50.0);\nSphere sphere_2 = Sphere(vec3(-1.5, 0.0, 0.45), 0.45, vec3(0.0, 0.01, 0.02), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 50.0);\nSphere sphere_3 = Sphere(vec3(3.0, 0.0, 0.45), 0.45, vec3(0.0, 0.01, 0.02), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 50.0);\nSphere button = Sphere(vec3(0.3, 0.3, 0.45), 0.08, vec3(0.1, 0.1, 0.1), vec3(0.7, 0.7, 0.7), vec3(1.0, 1.0, 1.0), 50.0);\nSphere button1 = Sphere(vec3(1.8, 0.3, 0.45), 0.08, vec3(0.1, 0.1, 0.1), vec3(0.7, 0.7, 0.7), vec3(1.0, 1.0, 1.0), 50.0);\nSphere button3 = Sphere(vec3(3.3, 0.3, 0.45), 0.08, vec3(0.1, 0.1, 0.1), vec3(0.7, 0.7, 0.7), vec3(1.0, 1.0, 1.0), 50.0);\nSphere button2 = Sphere(vec3(-1.2, 0.3, 0.45), 0.08, vec3(0.1, 0.1, 0.1), vec3(0.7, 0.7, 0.7), vec3(1.0, 1.0, 1.0), 50.0); // 0.7 works???\nPlane plane_0 = Plane(vec3(0.0, 0.0, 0.1), 0.0, vec3(0.05, 0.5, 0.05), vec3(0.0, 0.5, 0.0), vec3(0.0, 0.0, 0.0), 50.0);\nPlane ballTex = Plane(vec3(0.0, 0.0, 0.1), 0.0, vec3(1.0, 0.0, 0.0), vec3(0.7, 0.7, 0.7), vec3(0.0, 0.0, 0.0), 50.0);\nvec3 lightDir = normalize(vec3(-0.9, 0.5, 1.1));\n\n// stripe texture function\nvec3 stripeTex(vec2 coord, float width) {\n    float scaler = 7.5;\n    vec2 scaledCoord = coord * scaler;\n    // use x coords to make the pattern\n    float stripe = smoothstep(0.5 - width / 2.0, 0.5 + width / 2.0, mod(scaledCoord.x, 1.0));\n    vec3 result = vec3(stripe);\n    return result;\n}\n\n// test ray against a sphere\n// returns closest distance to start of ray / -1 otherwise\nfloat sphere(in Sphere sph, in vec3 ro, in vec3 rd) {\n    float t = -1.0;\n    ro -= sph.pos;\n    float r = sph.r;\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    if (h >= 0.0)\n        t = (-b - sqrt(h));\n    if (t < 0.0)\n        t = (-b + sqrt(h));\n    return t;\n}\n\n// ray against plane\nfloat plane(in Plane p, in vec3 ro, in vec3 rd) {\n    return (p.D - dot(ro, p.n)) / dot(rd, p.n);\n}\n\n// shoot function (to make objects)\nvec2 shoot(in vec3 ro, in vec3 rd) {\n    vec2 res;\n    float t = 1000.0;\n    // Try to intersect with sphere_0\n    float s = sphere(sphere_0, ro, rd);\n    if (s > 0.0) {\n        t = s;\n        res.y = 1.0;\n    }\n    // Try to intersect with sphere_1\n    float s2 = sphere(sphere_1, ro, rd);\n    if (s2 > 0.0) {\n        t = s2;\n        res.y = 4.0;\n    }\n    // Try to intersect with sphere_2\n    float s3 = sphere(sphere_2, ro, rd);\n    if (s3 > 0.0) {\n        t = s3;\n        res.y = 6.0;\n    }\n    // Try to intersect with sphere_3\n    float s4 = sphere(sphere_3, ro, rd);\n    if (s4 > 0.0) {\n        t = s4;\n        res.y = 8.0;\n    }\n    // Try to intersect with plane\n    float p = plane(plane_0, ro, rd);\n    if (p > 0.0 && p < t) {\n        t = p;\n        res.y = 2.0;\n    }\n    // button sphere\n    float s_silver = sphere(button, ro, rd);\n    if (s_silver > 0.0 && s_silver < t) {\n        t = s_silver;\n        res.y = 3.0;\n    }\n    // button1 sphere\n    float s_silver2 = sphere(button1, ro, rd);\n    if (s_silver2 > 0.0 && s_silver2 < t) {\n        t = s_silver2;\n        res.y = 5.0;\n    }\n    // button2 sphere\n    float s_silver3 = sphere(button2, ro, rd);\n    if (s_silver3 > 0.0 && s_silver3 < t) {\n        t = s_silver3;\n        res.y = 7.0;\n    }\n    // button3 sphere\n    float s_silver4 = sphere(button3, ro, rd);\n    if (s_silver4 > 0.0 && s_silver4 < t) {\n        t = s_silver4;\n        res.y = 9.0;\n    }\n    res.x = t;\n    return res;\n}\n\n// lighting for the pokeball main sphere\nvec3 phongLighting(vec3 normal, vec3 lightDir, vec3 viewDir, vec3 ambientColor, vec3 diffuseColor, vec3 specularColor, float shininess) {\n    vec3 ambient = ambientColor * 0.8;\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * diffuseColor;\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), shininess);\n    vec3 specular = spec * specularColor * 1.5;\n\n    return ambient + diffuse + specular;\n}\n\n// lighting for the pokeball button\nvec3 buttonLighting(vec3 normal, vec3 lightDir, vec3 viewDir, vec3 ambientColor, vec3 diffuseColor, vec3 specularColor, float shininess) {\n    vec3 ambient = ambientColor * 0.8;\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * diffuseColor;\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), shininess);\n    vec3 specular = spec * specularColor * 1.5;\n    float shadowFactor = 1.0; \n    return ambient + (diffuse * shadowFactor + vec3(1.0 - shadowFactor)) + specular;\n}\n\n// perlin noise function for clouds\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// cloud texture helper function\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// cloud texture function\nvec3 cloudTex(vec2 coord) {\n    float cloudValue = noise(coord * 10.0);\n    return vec3(cloudValue);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in vec3 lightPos) {\n    float shadow = 0.0;\n    int num_samples = 20;\n\n    vec3 shadowDir = normalize(lightPos - ro);\n\n    for (int i = 0; i < num_samples; i++) {\n        float u = float(i) / float(num_samples);\n        for (int j = 0; j < num_samples; j++) {\n            float v = float(j) / float(num_samples);\n\n            // Use the position of the first sphere for simplicity\n            vec3 samplePos = lightPos + (u - 0.01) * 0.5 + (v - 0.01) * 0.5;\n            vec3 sampleShadowDir = normalize(samplePos - ro * 1.2);\n\n            // Check intersection with all spheres\n            float t0 = sphere(sphere_0, ro + vec3(0.0, 0.01, 0.01), sampleShadowDir);\n            float t1 = sphere(sphere_1, ro + vec3(0.0, 0.01, 0.01), sampleShadowDir);\n            float t2 = sphere(sphere_2, ro + vec3(0.0, 0.01, 0.01), sampleShadowDir);\n            float t3 = sphere(sphere_3, ro + vec3(0.0, 0.01, 0.01), sampleShadowDir);\n\n            // Find the closest intersection\n            float min_t = min(min(t0, t1), min(t2, t3));\n\n            // Use smoothstep for smoother shadows\n            float penumbra = smoothstep(0.02, 0.09, min_t);\n            shadow += penumbra;\n\n        }\n    }\n\n    // Adjust the darkness of the shadows\n    float darkness = 0.25;\n    return 1.0 - (shadow / float(num_samples * num_samples)) * darkness;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // main function variable/camera stuff\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float d = 2.0;\n    float resetTime = 2.945;\n    float panSpeed = 0.5;\n    float originLocation = 2.0;\n    float editedTime = iTime;\n\n    editedTime -= floor(editedTime / resetTime) * resetTime;\n\n    vec3 pan_offset = vec3(panSpeed * editedTime, 0.0, 0.0);\n    \n\n    vec3 ray_origin = vec3(0, 1.5, 0.65) + pan_offset;\n\n\n    vec3 target = vec3(0.0, 0.0, 0.65) + pan_offset;\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    vec3 cam_forward = normalize(target - ray_origin);\n    vec3 cam_right = normalize(cross(cam_forward, up));\n    vec3 cam_up = normalize(cross(cam_forward, cam_right));\n    vec3 ray_direction = normalize(uv.x * (iResolution.x / iResolution.y) * cam_right - uv.y * cam_up + 2.0 * cam_forward);\n\n    // jumping code (speed, height, etc)\n    float jumpFrequency = 0.4;\n    float jumpAmplitude = 0.1;\n    float jumpPauseDuration = 3.2;\n    float jumpTime = mod(iTime, jumpFrequency + jumpPauseDuration);\n    float jumpPhase = 0.5 + 0.5 * sin(jumpTime / jumpFrequency * 2.0 * 3.14159);\n\n    // jump twice pause once code\n    bool skipJump = mod(floor(jumpTime / jumpFrequency), 3.0) == 2.0;\n    float jumpOffset = skipJump ? 0.0 : jumpPhase * jumpAmplitude * sin(jumpTime / jumpFrequency * 2.0 * 3.14159);\n    button.pos.z += jumpOffset;\n    sphere_0.pos.z += jumpOffset;\n    button1.pos.z += jumpOffset;\n    sphere_1.pos.z += jumpOffset;\n    button2.pos.z += jumpOffset;\n    sphere_2.pos.z += jumpOffset;\n    button3.pos.z += jumpOffset;\n    sphere_3.pos.z += jumpOffset;\n    \n    // general shooting\n    vec2 res = shoot(ray_origin, ray_direction);\n    vec3 point = ray_origin + res.x * ray_direction;\n    float fog = 1.0 / res.x;\n    vec3 color;\n    \n    if (res.x > 0.0 && res.x < 1000.0) {\n        vec3 normal;\n        \n        // grass code\n        if (res.y == 2.0) {\n            normal = plane_0.n;\n            vec3 stripePattern = stripeTex(point.xz, 0.1);\n            plane_0.diffuseColor = mix(plane_0.diffuseColor, stripePattern, 0.5);\n            // Add a black stripe along the center\n            float stripeWidth = 0.05;\n            float centerStripe = smoothstep(0.5 - stripeWidth / 2.0, 0.5 + stripeWidth / 2.0, abs(mod(point.z, 0.1) - 0.05) / stripeWidth);\n    \n            // Soft shadow calculation for the plane\n            vec3 lightPos = vec3(1.5, 1.1, 2.9);\n            float shadow = softShadow(point, normalize(lightPos - point), lightPos);\n    \n            color = mix(color, vec3(0.0), centerStripe * shadow);\n            color = phongLighting(normal, lightDir, -ray_direction, plane_0.ambientColor, plane_0.diffuseColor * 2.0, plane_0.specularColor, plane_0.shininess) * shadow;\n}\n        \n        // main ball code\n        if (res.y == 1.0) {\n            normal = normalize(point - sphere_0.pos);\n            vec3 stripePattern;\n            bool ifNotStripe = true;\n            vec3 ambientLight;\n            // use z coords to determine what color\n            if (point.z < sphere_0.pos.z + 0.035 && point.z > sphere_0.pos.z - 0.035) {\n                // black stripe\n                stripePattern = vec3(0.0, 0.0, 0.0);\n                ifNotStripe = false;\n            }\n            if (point.z > sphere_0.pos.z + 0.03) {\n                // Use the top texture (red)\n                stripePattern = vec3(1.0, 0.0, 0.0);\n                ambientLight = vec3(0.3, 0.0, 0.0);\n            }\n            if (point.z < sphere_0.pos.z - 0.03) {\n                // Use the bottom texture (white)\n                stripePattern = vec3(1.0, 1.0, 1.0);\n                ambientLight = vec3(0.5);\n            }\n            if (ifNotStripe == true) {\n                ballTex.diffuseColor = stripePattern;\n                // Apply lighting to the ball\n                color = ambientLight + phongLighting(normal, lightDir, -ray_direction, sphere_0.ambientColor, ballTex.diffuseColor, sphere_0.specularColor, sphere_0.shininess);\n            }\n        }\n        \n        // small button code\n        if (res.y == 3.0) {\n            normal = normalize(point - button.pos);\n            // smooth change from red to silver\n            float t = 0.5 + 0.5 * sin(iTime * 2.0);\n            vec3 buttonColor = mix(vec3(0.7, 0.7, 0.7), vec3(1.0, 0.0, 0.0), t);\n            // Apply lighting to the button\n            color = buttonLighting(normal, lightDir, -ray_direction, button.ambientColor, buttonColor, vec3(1.0, 1.0, 1.0), button.shininess);\n        }\n        \n        // 2nd main ball code\n        if (res.y == 4.0) {\n            normal = normalize(point - sphere_1.pos);\n            vec3 stripePattern;\n            bool ifNotStripe = true;\n            vec3 ambientLight;\n            // use z coords to determine what color\n            if (point.z < sphere_1.pos.z + 0.035 && point.z > sphere_1.pos.z - 0.035) {\n                // black stripe\n                stripePattern = vec3(0.0, 0.0, 0.0);\n                ifNotStripe = false;\n            }\n            if (point.z > sphere_1.pos.z + 0.03) {\n                // Use the top texture (red)\n                stripePattern = vec3(1.0, 0.0, 0.0);\n                ambientLight = vec3(0.3, 0.0, 0.0);\n            }\n            if (point.z < sphere_1.pos.z - 0.03) {\n                // Use the bottom texture (white)\n                stripePattern = vec3(1.0, 1.0, 1.0);\n                ambientLight = vec3(0.5);\n            }\n            if (ifNotStripe == true) {\n                ballTex.diffuseColor = stripePattern;\n                // Apply lighting to the ball\n                color = ambientLight + phongLighting(normal, lightDir, -ray_direction, sphere_1.ambientColor, ballTex.diffuseColor, sphere_1.specularColor, sphere_1.shininess);\n            }\n        }\n        \n        // small button1 code\n        if (res.y == 5.0) {\n            normal = normalize(point - button1.pos);\n            // smooth change from red to silver\n            float t = 0.5 + 0.5 * sin(iTime * 2.0);\n            vec3 buttonColor = mix(vec3(0.7, 0.7, 0.7), vec3(1.0, 0.0, 0.0), t);\n            // Apply lighting to the button\n            color = buttonLighting(normal, lightDir, -ray_direction, button1.ambientColor, buttonColor, vec3(1.0, 1.0, 1.0), button1.shininess);\n        }\n        \n        // 3rd main ball code\n        if (res.y == 6.0) {\n            normal = normalize(point - sphere_2.pos);\n            vec3 stripePattern;\n            bool ifNotStripe = true;\n            vec3 ambientLight;\n            // use z coords to determine what color\n            if (point.z < sphere_2.pos.z + 0.035 && point.z > sphere_2.pos.z - 0.035) {\n                // black stripe\n                stripePattern = vec3(0.0, 0.0, 0.0);\n                ifNotStripe = false;\n            }\n            if (point.z > sphere_2.pos.z + 0.03) {\n                // Use the top texture (red)\n                stripePattern = vec3(1.0, 0.0, 0.0);\n                ambientLight = vec3(0.3, 0.0, 0.0);\n            }\n            if (point.z < sphere_2.pos.z - 0.03) {\n                // Use the bottom texture (white)\n                stripePattern = vec3(1.0, 1.0, 1.0);\n                ambientLight = vec3(0.5);\n            }\n            if (ifNotStripe == true) {\n                ballTex.diffuseColor = stripePattern;\n                // Apply lighting to the ball\n                color = ambientLight + phongLighting(normal, lightDir, -ray_direction, sphere_1.ambientColor, ballTex.diffuseColor, sphere_1.specularColor, sphere_1.shininess);\n            }\n        }\n        \n        // small button2 code\n        if (res.y == 7.0) {\n            normal = normalize(point - button2.pos);\n            // smooth change from red to silver\n            float t = 0.5 + 0.5 * sin(iTime * 2.0);\n            vec3 buttonColor = mix(vec3(0.7, 0.7, 0.7), vec3(1.0, 0.0, 0.0), t);\n            // Apply lighting to the button\n            color = buttonLighting(normal, lightDir, -ray_direction, button2.ambientColor, buttonColor, vec3(1.0, 1.0, 1.0), button2.shininess);\n        }\n        \n        // 4th main ball code\n        if (res.y == 8.0) {\n            normal = normalize(point - sphere_3.pos);\n            vec3 stripePattern;\n            bool ifNotStripe = true;\n            vec3 ambientLight;\n            // use z coords to determine what color\n            if (point.z < sphere_3.pos.z + 0.035 && point.z > sphere_3.pos.z - 0.035) {\n                // black stripe\n                stripePattern = vec3(0.0, 0.0, 0.0);\n                ifNotStripe = false;\n            }\n            if (point.z > sphere_3.pos.z + 0.03) {\n                // Use the top texture (red)\n                stripePattern = vec3(1.0, 0.0, 0.0);\n                ambientLight = vec3(0.3, 0.0, 0.0);\n            }\n            if (point.z < sphere_3.pos.z - 0.03) {\n                // Use the bottom texture (white)\n                stripePattern = vec3(1.0, 1.0, 1.0);\n                ambientLight = vec3(0.5);\n            }\n            if (ifNotStripe == true) {\n                ballTex.diffuseColor = stripePattern;\n                // Apply lighting to the ball\n                color = ambientLight + phongLighting(normal, lightDir, -ray_direction, sphere_3.ambientColor, ballTex.diffuseColor, sphere_3.specularColor, sphere_3.shininess);\n            }\n        }\n        \n        // small button3 code\n        if (res.y == 9.0) {\n            normal = normalize(point - button3.pos);\n            // smooth change from red to silver\n            float t = 0.5 + 0.5 * sin(iTime * 2.0);\n            vec3 buttonColor = mix(vec3(0.7, 0.7, 0.7), vec3(1.0, 0.0, 0.0), t);\n            // Apply lighting to the button\n            color = buttonLighting(normal, lightDir, -ray_direction, button3.ambientColor, buttonColor, vec3(1.0, 1.0, 1.0), button3.shininess);\n        }\n        \n    } else {\n        // background and clouds\n        float cloudScale = 0.31;\n        vec3 cloudColor = cloudTex(uv * cloudScale);\n        color = mix(vec3(0.5, 0.7, 1.0), cloudColor, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}