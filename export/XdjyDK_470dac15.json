{"ver":"0.1","info":{"id":"XdjyDK","date":"1493840854","viewed":100,"name":"s7","username":"fangyuan267","description":"123","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["123"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sky color\nconst vec3 sky = vec3(0.0);\n\n// base pos for the light\nconst vec3 light =  vec3(-3.5, 10.0,5.0);\n\n// origin and radius of the sphere\nvec3 ps;\nconst float r = 0.8;\n\n// camera params\nvec3 ta = vec3(3.0,1,-6.0);\nfloat theta = 80.0;\n\n// raytracing params\nconst int max_bounces = 4;\nconst int supersampling =2;\nvec3 colorSphere(vec3 ro, vec3 rd, float id, out float kS, out vec3 I, vec3 normale)\n{\n    vec3 colA = sky;\n    vec3 colL = vec3(1,1,0.8);\n    vec3 colS = vec3(1,0,0);\n    \n    float kA = 0.1;\n    float kD = 0.7;\n          kS = 1.0;\n    float n  = 50.0;\n    \n    I = ro + id * rd;\n    vec3 L = normalize(light - I);\n    vec3 R = 2.0*normale*dot(normale,L)-L;\n    \n    vec3 ia = kA * colA;\n    vec3 il = kD * colS * colL * max(dot(L, normale),0.0);\n    vec3 is = kS *        colL * pow(max(dot(R,-rd),0.0),n);\n    return vec3(ia + il + is);\n}\n\nvec4 intersectSphere(in vec3 ro, in vec3 rd)\n{\n    float a = dot(rd, rd);\n    float b = dot(ro - ps, rd);\n    float c = dot(ro - ps, ro - ps) - r*r;\n    \n    float discr = b*b - a*c;\n    if (discr < 0.0)\n        return vec4(rd,-1.0);\n    discr = sqrt(discr);\n    float t0 = (-b - discr) / a;\n    float t1 = (-b + discr) / a;\n    float t = t0;\n    float normalMultiplier = 1.0;\n    if (t1 < 0.0)\n        return vec4(rd,-1.0);\n    if (t0 < 0.0)\n    {\n        normalMultiplier = -1.0;\n        t = t1;\n    }\n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((ro+rd*t) - ps) * normalMultiplier;\n    \n    return vec4(normal, t);\n}\n\nvec2 noise(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(100,500);\n    const float m = 200.0;\n    return vec2(fract(sin(dot(location + delta, c)) * m),\n                fract(sin(dot(location + vec2(delta.y,delta.x),c))*m));\n}\nvec3 colorPlane(vec3 ro, vec3 rd, float p, vec3 light, out float kS, out vec3 I, vec3 normale)\n{\n    I = ro + p * rd;\n    \n     float f = mod (floor ((I.x)) + floor ((I.z)),2.0); // checkerboard pattern\n    vec3 colS = f*vec3(0.5) + 0.4;\n    \n    float di = intersectSphere(I, normalize(light-I)).w;\n    bool shadow = (di > 0.0 && di < length(light-I));\n    if (shadow)\n        colS = f*vec3(0.4) + 0.1;\n   // colS -= distance(I, ro)*0.03; // attenuate the color to avoid moire\n    \n    vec3 colL = vec3(0.8);\n   \n    vec3 colA = vec3(1,1,1);\n    \n    float kA = 0.1;\n    float kD = 1.0;\n          kS = 0.3;\n    float n  = 50.0;\n    \n    vec3 L = normalize(light - I);\n    vec3 R = 2.0*normale*dot(normale,L)-L;\n    \n    vec3 ia = kA * colA;\n    vec3 il = kD * colS * colL * max(dot(L, normale), 0.0);\n    vec3 is = kS *        colL * pow(max(dot(R,-rd),0.0),n);\n    \n    return vec3(ia + il + is);\n}\n\n\nvec4 intersectPlane(in vec3 ro, in vec3 rd)\n{\n //  Pi = (X0 + Xd * t ; Y0 + Yd * t ; Z0 + Zd * t)\n     vec3 n = vec3(0.0,1.0,0.0);\n    vec3 pa = vec3(0.0,0.0,0.0);\n    \n    if (abs(dot(n, rd)) < 0.001)\n        return vec4(-1.0);\n    float t = dot(n, (pa - ro)) / dot(n, rd);\n    return vec4(n,t);\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd, out int id)\n{\n    // Compute all potential intersections\n    vec4 s = intersectSphere(ro, rd);\n    vec4 p = intersectPlane( ro, rd);\n    \n    // Find the nearest\n    if (s.w >= 0.0 && (p.w < 0.0 || s.w < p.w))\n    {\n        id = 1;    // sphere\n        return s;\n    }\n    else if (p.w >= 0.0)\n    {\n        id = 2;    // plane\n        return p;\n    }\n    else\n    {\n        id = 0;    // sky\n        return vec4(rd, 0.0);\n    }\n}\n\nvec4 rayTrace(vec3 ro, vec3 rd)\n{ \n    vec3  colors[max_bounces];\n    float kSes[max_bounces];\n    \n    for (int raybounce = 0; raybounce < max_bounces; raybounce++)\n    {\n        // Find nearest intersected object\n        int id = 0;    // sky\n        vec4 inter = intersect(ro, rd, id);\n        \n        // shading\n        float kS = 0.0;\n        vec3 colorPhong = vec3(0);\n        vec3 I = vec3(0);\n        vec3 normale = inter.xyz;\n        if (id > 0)\n        {\n            if (id == 1) {\n                colorPhong = colorSphere(ro, rd, inter.w, kS, I, normale);\n            }\n                else if (id == 2)\n            {\n                float shadowOff = 0.05;\n                for (float i = -shadowOff*10.0; i < shadowOff*10.0; i += shadowOff)\n                    colorPhong += colorPlane(ro, rd,  inter.w, vec3(light.x + i, light.y, light.z + i), kS, I, normale);\n                colorPhong *= shadowOff;\n            }\n\n            // nouveau ro et rd\n            ro = I + 0.0001*normale;\n            rd = reflect(rd, normale);\n        }\n        else\n            colorPhong = sky;\n        \n        //save colorPhong, kS de l'objet\n        colors[raybounce] = colorPhong;\n          kSes[raybounce] = kS;\n    }\n    \n    vec4 resColor = vec4(0,0,0,1);\n    for (int raybounce =  max_bounces-1; raybounce >= 0; raybounce--)\n        resColor = vec4(colors[raybounce] + kSes[raybounce] * resColor.rgb, 1.0);\n    \n    return resColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    for (int i = 0; i < supersampling; i += 1) {\n        for (int j = 0; j < supersampling; j += 1)\n        {\n            float fi = float(i)/float(supersampling);\n              \n            /*\n            // noise-based supersampling\n            vec2 q = vec2(float(i), float(j));\n            vec2 n = noise(fragCoord.xy,q);\n            vec2 offset = vec2(n.x,n.y) - vec2(0.5,0.5);\n            uv+= offset/500.0;\n            */\n            vec2 uv;\n            uv.x = (fragCoord.x+float(i)/float(supersampling)) / iResolution.y * 2.0 - iResolution.x / iResolution.y;\n            uv.y = (fragCoord.y+float(j)/float(supersampling)) / iResolution.y * 2.0 - 1.0;\n            \n            // origin of the camera\n            vec3 ro = vec3(3.0 + 4.0*cos(iTime),3,-6.0 - 4.0*sin(iTime));\n            \n            vec3 cz = normalize(ta-ro);\n            vec3 cx = normalize(cross(vec3(0,-1,0),cz));\n            vec3 cy = cross(cz,cx);\n            float dist = 1.0/tan(radians(theta/2.0));\n            vec3 diag = uv.x * cx - uv.y * cy;\n\n            // ray direction\n            vec3 rd = normalize(dist*cz+diag);\n            \n            // animated sphere position\n            ps = vec3(3,1.0 +r + sin(iTime*2.0),-6);\n\n            fragColor += rayTrace(ro, rd);\n        }\n    }\n    fragColor = fragColor / (float(supersampling)*float(supersampling));\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}