{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\n    Analytical Gaussian Blur by chronos\n    ---------------------------------------------------------------------\n    |                                                                   |\n    |  Exactly what the title says, but with some limitations:          |\n    |  This computes the analytical convoltion of a rectangle           |\n    |  with a normal distribution (normalized gaussian).                |\n    |                                                                   |\n    |  Sorry for the boring visuals, but hopefully it can be useful ^_^ |\n    |                                                                   |\n    ---------------------------------------------------------------------\n    self link: https://www.shadertoy.com/view/4fVfRm\n\n*/\n\nconst float PI = 3.14159265;\n\n// Decent-ish erf approximation I just found manually :)\n// https://www.wolframalpha.com/input?i=max+abs%28erf%28x%29+-+sign%28x%29*tanh%281.125*abs%28x%29%5E1.2725%29%5E1%2F1.2725%29+from+-3+to+3\n// abs error <= 0.00472696\nfloat erf(float x)\n{\n    float c = 1.2725;\n    return sign(x)*pow(tanh(1.125*pow(abs(x),c)),1./c);\n}\n\nfloat analytical_1D_blur(float sigma, float t0, float t1, float t)\n{\n    float s_sqrt2 = sigma * sqrt(2.); \n    return (erf((t - t0)/s_sqrt2) - erf((t - t1)/s_sqrt2)) / 2.;\n}\n\nfloat rectangle_analytical_gaussian_blur(float sigma, float x0, float x1, float y0, float y1, vec2 uv)\n{\n    return\n        analytical_1D_blur(sigma, x0, x1, uv.x) \n        *\n        analytical_1D_blur(sigma, y0, y1, uv.y)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (2. * fragCoord-iResolution.xy) / iResolution.y;\n    vec2  mouse = (2. * iMouse.xy-iResolution.xy) / iResolution.y;\n    float ps =  2. / iResolution.y;\n\n    if(length(iMouse.xy) < 10.) mouse.x = 1.66*cos(iTime*.25);\n\n    vec3 color = vec3(0);\n                \n    float size = 1./1.;\n    \n    float x0 = -.25*size;\n    float x1 = 0.25*size;\n    float y0 = -.25*size;\n    float y1 = 0.25*size;\n    \n    float sigma = .2* (cos(iTime)*.5+.5);\n    float f = 0.;\n    \n    for(float i = -1.; i<=1.; i++)\n    for(float j = -1.; j<=1.; j++)\n    {\n       vec2 ij = vec2(i,j);\n       if(ij == vec2(0) || ij == vec2(1,0)) continue;\n       vec2 p = ij*0.25*size;\n       f += rectangle_analytical_gaussian_blur(sigma, x0+p.x, x1+p.x, y0+p.y, y1+p.y, uv-p);\n    } \n    \n    float c = cos(iTime), s = sin(iTime);\n    mat2 R = mat2(c, s, -s, c);\n    f += rectangle_analytical_gaussian_blur(sigma, -0.025, 0.025, -0.2, 0.2, R * uv);\n    \n    f -= rectangle_analytical_gaussian_blur(sigma, -0.5, -0.4, -0.5, 0.5, uv);\n    \n    f += rectangle_analytical_gaussian_blur(sigma, -0.025+1.2, 0.025+1.2, -0.2, 0.2, transpose(R) * uv);\n                \n    if(uv.x < mouse.x)\n    {\n        color += mix(vec3(0.4, 0.2+0.6*(uv.y*.5+.5), 0.9), vec3(0.8, 0.2, 0.1), f);\n        color *= 1.-0.125*length(uv);\n    }\n    else\n    color += f;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fVfRm","date":"1733885287","viewed":124,"name":"Analytical Gaussian Blur","username":"chronos","description":"Analytical Gaussian Blur for a 2D rectangle","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["math","blur","analytical","gaussian","erf"],"hasliked":0,"parentid":"","parentname":""}}