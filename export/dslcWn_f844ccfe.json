{"ver":"0.1","info":{"id":"dslcWn","date":"1686734367","viewed":61,"name":"Quad SDF With L1 Metric","username":"Envy24","description":"Optimized implementation for convex quads with L2 metric: https://www.shadertoy.com/view/7dSGWK","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","convex","quad","metric","l1","non"],"hasliked":0,"parentid":"cdlyWn","parentname":"Quad SDF With L2 Metric"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE ( 1. )\n#define ORIGIN      ( vec2(0) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/*\n    SDF\n*/\nfloat quadSDF_L1(\n    vec2 NDC,\n    vec2 A,\n    vec2 B,\n    vec2 C,\n    vec2 D)\n{\n    float R = sinOSC(0.0, 0.1, iTime);\n    \n    vec2 AB = B - A,   \n         BC = C - B,\n         CD = D - C,\n         DA = A - D;\n\n    /*Minimal distance for cases 2,3*/\n    float min_dist = segmentSDF_L1(NDC, A, B, 0.);\n          min_dist = min(min_dist, segmentSDF_L1(NDC, B, C, 0.));\n          min_dist = min(min_dist, segmentSDF_L1(NDC, C, D, 0.));\n          min_dist = min(min_dist, segmentSDF_L1(NDC, D, A, 0.));\n    float sig = 0.; // Used only for sign.  \n\n    /*Cases 1,2: Non-convex quad, \"visible\" and \"invisible\" intersection point. */\n    vec2 V[4] = vec2[4](A, B, C, D);    \n    for (int i = 0; i < 4; ++i)\n    {\n        vec2 a = V[i],\n             b = V[(i + 1) & 3],\n             c = V[(i + 2) & 3],\n             d = V[(i + 3) & 3];\n             \n        vec2 roots = segment_segment_intersection(b, c, d, a);   \n        \n        if (roots.x >= 0. && roots.x <= 1.) {\n            vec2 I = b+(c-b)*roots.x;\n            \n            sig = min(\n                triangleSDF_L1(NDC, a, b, I, 0.),\n                triangleSDF_L1(NDC, d, c, I, 0.));\n                \n            float sign_ = sig <= 0.001 ? -1. : 1.;\n            return sign_*min_dist - R;\n        }\n        if (roots.y >= 0. && roots.y <= 1.) {\n            vec2 I = d+(a-d)*roots.y;\n            \n            sig = min(\n                triangleSDF_L1(NDC, a, b, I, 0.),\n                triangleSDF_L1(NDC, d, c, I, 0.));\n                \n            float sign_ = sig <= 0.001 ? -1. : 1.;\n            return sign_*min_dist - R;\n        } \n    }\n    \n    /*Case 3: Convex quad.*/\n    sig = min(\n          triangleSDF_L1(NDC, A, B, C, 0.),\n          triangleSDF_L1(NDC, C, D, A, 0.));\n        \n    float sign_ = sig <= 0.001 ? -1. : 1.;\n    return sign_*min_dist - R;\n}\n/*\n    SDF\n*/\n\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.6, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(4./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric(vec2 NDC, vec2 A, vec2 B, vec2 C, vec2 D, vec3 color)\n{\n    float unit = 4.0 / iResolution.y,\n          half_pi = 1.5707963267948966,\n          T = iTime * 0.5;\n          \n    vec2 M = \n        iMouse.z > 0. ?\n            map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false) :\n            ORIGIN + cos(T+vec2(0., -half_pi))*SCENE_SCALE;\n            //vec2(0);\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(L1(NDC, M) - abs(quadSDF_L1(M, A, B, C, D)))));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float T = iTime*0.5;\n    vec2 A=rotz(-T*0.15)*vec2(-0.75, -0.55), B=rotz(-T*0.5)*vec2(0.75, 0.75)+vec2(sin(T))*0.5,\n         C=rotz(T*0.25)*vec2(-0.1, -0.75), D=rotz(T*0.25)*vec2(0.1, 0.75)-vec2(sin(T))*0.5;\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n    float minDist = quadSDF_L1(NDC, A, B, C, D);\n    \n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n         color = add_metric(NDC, A, B, C, D, color);\n         \n#define UNIT                      (  8.0 / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, A, 0.02))); // Red    - A\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, B, 0.02))); // Green  - B\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, C, 0.02))); // Blue   - C\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, D, 0.02))); // Purple - D\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nmat2 rotz(float rad)\n{\n    vec2 cs = vec2(cos(rad), sin(rad));\n    mat2 M = mat2( // row order\n         cs.x, -cs.y,\n         cs.y,  cs.x);\n    return transpose(M); // column order\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float r)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x) / (E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC))) - r;\n}\n\nfloat triangleSDF_L1(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    float r)\n{\n    float minDist = 99.9;\n\n    minDist = min(minDist, segmentSDF_L1(NDC, P1, P0, 0.));\n    minDist = min(minDist, segmentSDF_L1(NDC, P1, P2, 0.));\n    minDist = min(minDist, segmentSDF_L1(NDC, P2, P0, 0.));\n    \n    vec3 BARY = inverse(mat3(\n                     P0.x, P0.y, 1.0,\n                     P1.x, P1.y, 1.0,\n                     P2.x, P2.y, 1.0)) * vec3(NDC.x, NDC.y, 1);\n    \n    return \n        BARY.x >= 0.0 && BARY.y >= 0.0 && BARY.z >= 0.0 ?\n            -(minDist + r) :\n             minDist - r;\n}\n    \n\n/* Source: https://www.shadertoy.com/view/cdjXRG */\n// Pseudo-scalar vector multiplication\n//float cross_2d(vec2 L, vec2 R) { return L.x*R.y - L.y*R.x; }\nfloat cross_2d(vec2 L, vec2 R) { return determinant(mat2(L, R)); }\nvec2 segment_segment_intersection(vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    /* Variant 1: *\n    float a = P1.x - P0.x, // A.x\n          b = P3.x - P2.x, // B.x\n          \n          c = P1.y - P0.y, // A.y\n          d = P3.y - P2.y, // B.y\n          \n          e = P2.x - P0.x, // C.x\n          f = P2.y - P0.y; // C.y        \n    return vec2(\n        (e*d-b*f)/(a*d-b*c),\n        (c*e-a*f)/(a*d-c*b) );\n        \n    /* Variant 2: *\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / (A.x*B.y-A.y*B.x);\n    return vec2(\n        (B.y*C.x-B.x*C.y)*inv,\n        (A.y*C.x-A.x*C.y)*inv);\n        \n    /* Variant 3: */\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / cross_2d(A, B);\n    return vec2(\n        cross_2d(C, B)*inv,\n        cross_2d(C, A)*inv);\n}","name":"Common","description":"","type":"common"}]}