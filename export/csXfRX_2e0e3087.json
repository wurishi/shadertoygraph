{"ver":"0.1","info":{"id":"csXfRX","date":"1689181156","viewed":221,"name":"Ecosystem CA","username":"kastorp","description":"that's enough for today!\n\nPress bar to regenerate terrain\n","likes":35,"published":1,"flags":48,"usePreview":0,"tags":["terrain","ca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ecosystem CA by Kastorp\n//------------------\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n    vec2 R= iResolution.xy;\n    float sp= (R.x-200.)/2.;\n    ivec2 c=  ivec2(I/R.y*100.+ (iMouse.z>0.? vec2(iMouse.x*sp/R.x,0): vec2(sp +sin(iTime/sp*20.)*sp,0.)) );\n    O = texelFetch(iChannel0,c,0);\n    vec3 col= vec3(0);\n    if(TREE) col= (O.y>0.? vec3(.2,.7,0):vec3(0.6,0.4,0.2))*(.6+O.z/20.);\n    if(FLAME) col=O.y>0.? vec3(1.000,0.302,0.000)*(.2+O.z*mod(iTime,.2)):vec3(0.761,0.761,0.259);\n    if(BLOCK) col=vec3(.2)* (1.+.5*float((c.x-c.y)&1));\n    if(GROUND) col=vec3(.5);\n    if(MUSH) col= (O.y>0.? vec3(0.702,0.408,0.000):vec3(0.847,0.729,0.616))*(.6+O.z/20.);\n    if(GRASS) col= vec3(0.561,0.616,0.282);\n    if(EMPTY) col= vec3(0.000,0.267,0.302)*(.6 +.01*float(c.y) +O.z/30.);\n    if(SNOW) col= vec3(0.9);\n    O.xyz=col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat map(vec2 c)\n{\n    vec3 p=vec3(c.x ,float(iFrame),c.y);   \n    //overworld\n    float  d= (-54. + p.z)*.66 - mix(0., 40., pow(.5 + .5 * snoise(p.xy /135. ), 2.)) * snoise(p / 16.51 );    \n    //caves\n    float d2= snoise(p.yxz / 24.99 ) -.1 \n        + smoothstep(5., 0., p.z)*.9 //bottom\n        + 0.3* smoothstep(32., 54., p.z); //top\n    d=max(d,-d2);\n    return d; \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    bool rc = texelFetch(iChannel0,ivec2(iResolution.x-1.,0),0)==vec4(0);\n    if(iFrame==0|| rc ||texelFetch(iChannel3,ivec2(32,0),0).x>.5) { \n    \n        //initialize\n        O = vec4(0); //VOID\n        if(map(I)<0.)  O = vec4(4,0,3,0);\n        \n        vec2 ic =floor((I+10.)/20.)*20.;\n        ic+= hash22(ic+1.)*8.;\n        \n        if(map(ic)<-.5  && I.y<50. && sdBox(I-ic ,vec2(3)+4.*hash22(ic) )<0.)  O = vec4(3,0,5,0); //ROOM\n                \n        return;\n    }\n    else{\n        //get current\n        O=texelFetch(iChannel0,ivec2(I),0);\n        if(I.y>110.) return;\n        \n        //get neighbors\n        vec4[4] c ;\n        for(int i=0;i<4;i++){ \n           //0:Bottom, 1:up, 2:left, 3:right\n           vec2 d =vec2(i<2?0:i==2?-1:1, i>1?0:i==0?-1:1);\n           c[i]= texelFetch(iChannel0,ivec2(I+d),0);      \n        }\n               \n        //FLAME\n        RULE_ANY( hash12(I)>.99 && GROUND && i==UP && N_EMPTY, vec4(1,0,2,0));\n        RULE_ANY( EMPTY && i==BOTTOM && N_FLAME && NT==0. && N_ALIVE ,LIFE_DECREASE);\n        RULE_ANY( EMPTY && N_FLAME && NT==0. && N_DEAD, vec4(NG,NT+1.,3.,0))\n        RULE_ANY( EMPTY && N_FLAME && NT==1. && N_ALIVE && NGB==1. && NVB>0.  ,LIFE_DECREASE) \n\n        //MUSH\n        RULE_ANY( abs(hash12(I)-.5)<.025 && GROUND  &&I.y<35. && map(I+vec2(0,4))>.05 ,vec4(5,0,4,0));\n        RULE_ANY(EMPTY && i==BOTTOM && N_MUSH && NT==0. && N_ALIVE , LIFE_DECREASE);\n        RULE_ANY(EMPTY && N_MUSH && NT==0. && N_DEAD , vec4(NG,NT + 1.,2.,0))\n        RULE_ANY(EMPTY && (i==LEFT || i==RIGHT ) && N_MUSH && NT==1. && N_ALIVE  , LIFE_DECREASE)\n        \n        //TREE\n        RULE_ANY( hash12(I)<.07 && GROUND &&I.y>40. && map(I+vec2(0,6))>.1 ,vec4(2,0,8,0));\n        RULE_ANY(EMPTY && i==BOTTOM  && N_TREE && NT==0. && N_ALIVE , LIFE_DECREASE);\n        //RULE_ANY(EMPTY && (i==2 || i==3 ) && N_TREE && NT==0. && N_ALIVE , LIFE_MIN);\n        RULE_ANY(EMPTY && N_TREE && NT==0. && N_DEAD , vec4(NG,NT + 1.,5.,0))\n        RULE_ANY(EMPTY && N_TREE && NT==1. && N_ALIVE  , LIFE_DECREASE_RND)\n        \n        //GRASS\n        RULE_ANY(GROUND && i==UP && N_EMPTY, vec4(6,1,1,0));\n                \n        //ROOMS\n        RULE_ALL(BLOCK && N_BLOCK , vec4(0))\n \n         //SNOW\n        RULE_ANY(sin(iTime/10.)>.8 && I.y>99. && hash12(I + iTime)<.0001  ,vec4(7,0,10,0));\n        RULE_ANY( iFrame%2==1 && EMPTY && N_SNOW && i==UP, c[i]);\n        RULE_ANY( iFrame%2==0 && SNOW && N_SNOW  && i==BOTTOM, vec4(0,0,10,0));\n        RULE_ANY( hash12(I + iTime)>.995 && SNOW && !N_EMPTY && !N_SNOW && i==BOTTOM  ,vec4(0,0,10,0));\n        \n        //AIR + SHADOW\n        RULE_ALL(((EMPTY && N_EMPTY && NV>=O.z) || i!=BOTTOM   ), vec4(0,0,10,0));\n        RULE_ANY(EMPTY && !N_EMPTY &&i==UP , vec4(0));\n        RULE_ANY(EMPTY && N_EMPTY &&NV < O.z+1. &&i==UP, vec4(0,0,NV+1.,0));\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NG c[i].x //near group\n#define NT c[i].y //near type\n#define NV c[i].z //near value                           \n#define RULE(check,val) if( check) O=val;\n#define RULE_ANY(check,val) for(int i=0;i<4;i++){ if( check) O=val;}\n#define RULE_ALL(check,val) {bool ch=true; for(int i=0;i<4;i++) ch=ch&& check; if(ch) O=val;}\n#define BOTTOM 0 \n#define UP 1 \n#define LEFT 2 \n#define RIGHT 3  \n#define NVB c[0].z    \n#define NGB c[0].x \n\n\n//ACTIONS\n#define LIFE_DECREASE vec4(NG,NT,NV-1.,0)\n#define LIFE_DECREASE_RND vec4(NG,NT,NV-1.-floor(hash12(I)*1.8),0)\n#define LIFE_MIN vec4(NG,NT,0.,0)\n\n//NEIGHBORS CONDITIONS\n#define N_FLAME (NG==1.)\n#define N_TREE  (NG==2.)\n#define N_BLOCK  (NG==3.)\n#define N_ALIVE (NV>0.)\n#define N_DEAD (NV==0.)\n#define N_MUSH  (NG==5.)\n#define N_EMPTY (NG==0.)\n#define N_SNOW (NG==7.)\n\n//CURENT BLOCK CONDITIONS\n#define EMPTY (O.x==0.)\n#define TREE (O.x==2.)\n#define FLAME (O.x==1.)\n#define GROUND (O.x==4.)\n#define BLOCK (O.x==3.)\n#define MUSH (O.x==5.)\n#define GRASS (O.x==6.)\n#define SNOW (O.x==7.)\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return -0.334 +.5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}","name":"Common","description":"","type":"common"}]}