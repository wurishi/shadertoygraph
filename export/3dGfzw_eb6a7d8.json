{"ver":"0.1","info":{"id":"3dGfzw","date":"1606758930","viewed":114,"name":"Pseudo morthing","username":"geranyan","description":"I`ve tried to create shadow and i took this )) ","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["try"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtlXRr","filepath":"https://soundcloud.com/paper-bag-records/young-galaxy-new-summer","previewfilepath":"https://soundcloud.com/paper-bag-records/young-galaxy-new-summer","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sph_dist(in vec3 pos, in vec3 cen, in float r){\n\treturn length(pos - cen) - r; \n\n}\n\nfloat box_dist(vec3 pos, vec3 cen, vec3 r){\n\tvec3 q = abs(pos - cen) - r;\n    \n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); \n\n}\n\n/*float map(in vec3 pos){\n    \n    float disp =  sin(5.0*pos.x) * sin(5.0*pos.y) * sin(5.0*pos.z) * 0.25;\n\n\tfloat d = sph_dist(pos, vec3(0.0, 0.0, 0.0),3.0);\n    \n    float d2 = pos.y - (-3.0);\n    \n    float d3 = box_dist(pos, vec3(0.0), vec3(1.0));\n    \n    return min(d2, d+disp);\n}*/\n\nvec2 map(in vec3 pos){\n    \n    float disp =  sin(5.0*pos.x) * sin(5.0*pos.y) * sin(5.0*pos.z) * 0.25;\n\tfloat an2 = 10.0 * iTime/10.0;\n\tfloat d = sph_dist(pos, vec3(cos(an2), 0.0, sin(an2)), sin(an2) + cos(an2) + 1.5);\n    \n    float d2 = pos.y - (-3.0);\n    \n    float d3 = box_dist(pos, vec3(0.0), vec3(1.0));\n    if (min(d2, d+disp) == d2){\n    \t//return vec2(d2, 1.0);\n    }\n    \n    return vec2(d+disp, 2.0);\n}\n\n\n\nvec3 normal(in vec3 pos){\n\n\tconst vec3 eps = vec3(0.0001, 0.0, 0.0);\n    \n    \n    \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    \n    \n    \n    return normalize(vec3(grad_x, grad_y, grad_z));\n\n\n\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(pos - cen);\n    float diff_intens = max(0.0, dot(nor, dir_to_light));\n    \n    return diff_intens;\n\n}\n\n\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro){\n\t\n    const float specPower = 30.0;\n    vec3 n = normal(pos);\n    vec3 l = normalize(pos - cen);\n    vec3 v = normalize(pos - ro);\n    vec3 r = reflect(v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\nfloat CookTorrance(in vec3 pos, in vec3 cen, in vec3 ro){\n \tconst float m = 0.5;\n    vec3 n = normal(pos);\n    vec3 l = normalize(pos - cen);\n    vec3 v = normalize(pos - ro);\n    vec3 h = normalize(v + l);\n    \n    float nl    = dot( n, l );\n    float nv    = dot( n, v);\n    float nh    = max( dot( n, h ), 1.0e-7 );\n    float vh    = dot( v, h );\n    \n    float tmp = 1.0 / (4.0 * m * m * pow(nh, 4.0));\n    float d = tmp * exp((nh*nh - 1.0)/(m*m*nh*nh));\n    tmp = 1.0 / (1.0 + vh);\n    float f = tmp + (1.0 - pow(nv, 5.0)) *(1.0 - tmp);\n    tmp = 2.0 * nh * nv / vh;\n    float g = min(1.0, min(tmp, 2.0 * nh * nl/ vh));\n    \n    float I = f * g * d /  nv;\n    \n    \n    return I;\n    \n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd )\n{\t\n    float mint = 0.0;\n    float maxt = 100.0;\n   \tfloat k = 2.0;\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec2 rayMarch(in vec3 ro, in vec3 rd){\n\t\n\tconst float max_dist = 100.0;\n    const float min_dist = 0.01;\n    const int max_step = 1000;\n    float total_dist = 0.0;\n    \n    for(int i = 0; i < max_step; i++){\n    \t\n        \n        vec3 cur_pos = ro + total_dist * rd;\n        \n        vec2 cur_dist = map(cur_pos);\n        \n        if(cur_dist.x < min_dist){\n            cur_dist.x = total_dist;\n            return cur_dist;\n        }\n        \n        if(cur_dist.x > max_dist){\n        \tbreak;\n        }\n        total_dist += cur_dist.x;\n    }\n    \n    return vec2(-1.0);\n    \n}\n\n//(vec3(0.7, 0.0, 0.0) * diffuse_light(cur_pos, light_pos) + \n                   // vec3(0.7, 0.7, 0.7) * phong_light(cur_pos, light_pos, ro));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y; //получаем пиксель\n\n\t//float an = 10.0 * iMouse.x/iResolution.x;\n\n\tfloat an = 10.0 * iTime/iResolution.x;\n    \n\tvec3 ro = vec3(7.0*sin(an), 0.0, 7.0* cos(an)); //положение камеры\n\n\n\n\tvec3 ta = vec3(0.0, 0.0, 0.0); // target for camera\n\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu, ww));\n\n\n\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n\n    \n    \n    \n    vec2 obj = rayMarch(ro, rd);\n    \n    vec3 obj_pos = ro + obj.x * rd;\n\tfloat an2 = 10.0 * iTime/10.0;\n    vec3 light_pos = vec3(sin(an2), -7.0, 7.0 * cos(an2));\n    \n    vec3 light = (vec3(0.3, 0.2, 0.7) * diffuse_light(obj_pos, light_pos) + \n                  vec3(1.7, 0.7, 0.7) * phong_light(obj_pos, light_pos, ro));\n    \n    vec3 col =  light;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}