{"ver":"0.1","info":{"id":"DtjcRR","date":"1691406615","viewed":44,"name":"Gradient simple","username":"bkeenan","description":"Simple linear gradient.\nIncludes a plot of the shaping function used to mix the gradient.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Experiment to understand how shaping functions can be used to modify gradients.\n *\n * Includes a rudimentary plot() function to draw a curve, that doesn't \n * maintain a constant thickness as the steepness of the curve varies.\n */\n\n// Use medium precision on mobile devices\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Size of one pixel in normalized texture coordinates (0-1)\nfloat pixel_size;\n\nvec3 color_background = vec3(0.0);\nvec3 color_gradient = vec3(0.0, 0.7, 1.0);\nvec3 color_curve = vec3(0.7, 0.0, 0.0);\n\n/**\n * Plot a function y = f(x) as a curve.\n * If current fragment's y value equals result of f(x), then the fragment is on the curve.\n *\n * e.g. 'fx' is the result of the rhs of a curve equation:\n * y = x;           // linear\n * y = pow(x, 2.0); // exponential\n * y = sin(x);      // sine\n *\n * @param  {float} uv               Current fragment point (x,y)\n * @param  {float} fx               Result of the rhs of a curve equation\n * @param  {vec3}  background_color Current color of this fragment\n * @param  {vec3}  line_color       Color to use for the line\n * @param  {float} thickness        Thickness of the line in pixels\n * @return {vec3}                   New color of the fragment (on or off the line).\n */\nvec3 plot(vec2 uv, float fx, vec3 background_color, vec3 line_color, float thickness) {\n  // Naive distance to curve\n  float distance_to_curve = abs(uv.y - fx);\n\n  // Line is half thickness from the curve on each side\n  thickness = pixel_size * thickness;\n  float anti_alias = pixel_size * 1.0; // must be greater than 0.0\n\n  // Line has half total thickness on either side of the curve\n  float inner_edge = thickness / 2.0;\n  float outer_edge = inner_edge + anti_alias;\n\n  // Line color falls-off slightly to give anti-aliasing\n  float intensity = smoothstep(outer_edge, inner_edge, distance_to_curve);\n\n  return mix(background_color, line_color, intensity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Current fragment position in normalized coordinates (0-1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // maintain aspect ratio\n    // uv.x *= iResolution.x / iResolution.y;\n\n    // Size of one pixel in normalized texture coordinates (0-1)\n    pixel_size = 1.0 / iResolution.y;\n  \n    vec3 color = color_background;\n\n    // Shaping function y=f(x)\n    // float fx = 0.5; // constant\n    float fx = uv.x; // linear\n    // float fx = pow(uv.x, 2.0); // exponential ease-in\n    // float fx = sqrt(uv.x); // exponential ease-out\n    // float fx = pow(uv.x, 0.5); // different way of writing square root\n\n    // Mix a gradient using the curve\n    color = mix(color, color_gradient, fx);\n\n    // Plot the curve\n    color = plot(uv, fx, color, color_curve, 1.0);\n\n  \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}