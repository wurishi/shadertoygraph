{"ver":"0.1","info":{"id":"ssXfWX","date":"1647293404","viewed":710,"name":"RoundRainDrops","username":"MelisaHot","description":"Rain drops on window","likes":14,"published":1,"flags":0,"usePreview":1,"tags":["water","rain","drops"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// s is smoothstep\n#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n\tvec3 o, d; // ray origin and direction \n};\n\n//function for random numer \nfloat N(float t){\n    return fract(sin(t*3456.)*6547.); // noise function -- random number\n}\n\n//random numer - 1 imput 4 out\nvec4 N14(float t){\n    return fract(sin(t*vec4(123., 1024., 3456., 9564.))*vec4(6547., 345., 8799., 1564.)); // noise function -- random number\n}\n\nray CameraSetup(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n\tray cam;\n    cam.o = camPos;\n    \n    vec3 f = normalize(lookAt-cam.o); // forward vec\n    vec3 r = cross(vec3(0., 1., 0.), f); // right vec\n    vec3 u = cross(f, r); // up vec\n    \n    vec3 c = cam.o + f * zoom; // center of screen\n    vec3 i = c + uv.x*r + uv.y*u; // itersection point\n    \n    cam.d = normalize(i-cam.o); \n    \n    return cam;\n}\n  \n\nvec2 Rain(vec2 uv, float t){\n    \n    t *=40.;\n   \n    vec2 a= vec2(3., 1); // aspect ratio\n    vec2 st = uv*a;\n    vec2 id= floor(st);\n    st.y+=t*.22;\n    float rand= fract(sin(id.x*716.34)*768.34); //random number\n    st.y+=rand;\n    uv.y+=rand;\n   \n    id= floor(st);\n    st = fract(st)-0.5; // to save value of uv\n     uv.x +=sin(uv.y*300.)*.002;\n    t +=fract(sin(id.x*76.34*id.y*1453.7)*768.34)*6.287;\n    float y = -sin(t+sin(t+sin(t)*0.5))*.43;\n    \n    vec2 p1=vec2(0., y);\n    vec2 o1= (st-p1)/a;\n    float d = length(o1); // distance of pixel from the center of the box\n    \n    float m1 = S(.07,.0, d);\n    vec2 o2=(fract(uv*a.x*vec2(1., 2.))-.5)/vec2(1., 2.);\n    d = length(o2);\n    \n    float m2 = S(.3*(.5-st.y),.0, d)*S(-.1, .1, st.y-p1.y);\n \n    return vec2(m1*o1*30.+m2*o2*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0., 0., 0.); //position of camera\n    vec3 lookAt = vec3(0., 0., 1); // position of lookat point \n    \n    float t = iTime*.05;\n    \n    vec2 rainDistort = Rain(uv*5., t)*0.5;\n    rainDistort += Rain(uv*11., t)*0.5;\n    rainDistort += Rain(uv*3., t)*0.5;\n    uv.x +=sin(uv.y*50.)*.002;\n   // uv.y +=sin(uv.x*170.)*.002;*/\n    ray r = CameraSetup(uv - rainDistort*.5, camPos, lookAt, 2.);\n    \n   vec4 col = texture(iChannel0,uv);\n   col += (r.d.y*2.);\n\n  fragColor = vec4(col); // Output to screen\n}","name":"Image","description":"","type":"image"}]}