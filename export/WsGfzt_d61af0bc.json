{"ver":"0.1","info":{"id":"WsGfzt","date":"1607684457","viewed":73,"name":"fractalPlay","username":"Kaeylos","description":"small shader to experiment using menger and sierpinski triangle fractal ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["menger","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Ray marching options ----- //\n#define AA_SAMPLES 2 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 300\n#endif\n#define MAX_DIST 100.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.001\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\n\n// ----- easingFunct -----//\nfloat quadInOut(float t) { return t < 0.5 ? 8. * pow(t, 4.) : 1. - pow(-2. * t + 2., 4.) / 2.;}\nfloat saw(float t) { return (-abs(2.*t-1.)+1.); }\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0, 1], including hue.\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0, 1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 blendColor(float t, vec3 a, vec3 b) {\n\treturn sqrt((1. - t) * pow(a, vec3(2.)) + t * pow(b, vec3(2.)));\n}\n\n// ----- distance functions modifiers ----- //\n// source: https://iquilezles.org/articles/smin\n\nvec3 arrayOp(vec3 p, vec3 offset) {\n    return mod(p + 0.5 * offset, offset) - 0.5 * offset;\n}\n\nvec3 arrayOp(vec3 p, vec3 offset, vec3 count) {\n    return p - offset * clamp(round(p/offset),vec3(0.0), count);\n}\n\nfloat unionOp( float d1, float d2) { return min(d1, d2);}\nfloat subOp( float d1, float d2) { return max(d1, -d2); }\nfloat interOp( float d1, float d2) { return max(d1,d2); }\n\n\n// ----- distance functions for 3D primitives ----- //\n// source: https://iquilezles.org/articles/distfunctions\n\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\nfloat octahedronSDF(vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n/*\nfloat octahedronSDF( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}*/\n\nfloat pyramidSDF(vec3 p, float size) {\n\treturn interOp(octahedronSDF(p, size), -p.y);\n}\n\nfloat torusSDF( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat crossSDF(vec3 p, float size) {\n\t  float da = maxComp(abs(p.xy));\n\t  float db = maxComp(abs(p.yz));\n\t  float dc = maxComp(abs(p.zx));\n\t  return min(da,min(db,dc)) - size;\n}\n\nfloat menger(vec3 p, float boxSize, int iterations) {\n\tfloat d = boxSDF(p, vec3(boxSize));\n\t\n\t/* NICE\n\tfloat scale = 1.;\n\tfor(int i=0; i<iterations; ++i) {\n\t\t\n\t\tvec3 q = arrayOp(p * scale, vec3(1.));\n\t\td = subOp(d, crossSDF(q , 1./3.) / scale);\n\t\tscale *= 3.;\n\t}*/\n\t\n\tfloat anim = ((cos(iTime/2.)+1.)/2.+1.);\n\t// anim = 1;\n\tfloat count = 1.;\n\tfor(int i=0; i<iterations; ++i) {\n\t\tvec3 q = arrayOp(p * anim , vec3(2.*boxSize/count));\n\t\td = subOp(d, crossSDF(q, 1./(count*3.)));\n\t\tcount *= 3.;\n\t}\n\treturn d;\n}\n\n// sources http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat Sierpinski(vec3 z, int iterations) {\n\tvec2 D = vec2(1., 0.);\n\tvec3[5] SierpinskiOffset = vec3[5](D.xyy, -D.xyy, D.yyx, -D.yyx, D.yxy);\n\tfloat Scale = 2.;\n\tvec3 c;\n\tfloat dist, d;\n\tfor(int n=0; n < iterations; n++) {\n\t\tc = SierpinskiOffset[0]; dist = length(z-SierpinskiOffset[0]);\n\t\tfor(int i=1; i<5; i++) {\n\t\t     d = length(z-SierpinskiOffset[i]);\n\t\t     if (d < dist) { c = SierpinskiOffset[i]; dist=d; }\n\t\t }\n\t\tz = Scale*z-c*(Scale-1.0);\n\t}\n\t\n\treturn pyramidSDF(z* pow(Scale, float(-iterations)), pow(2., -float(iterations)));\n}\n\n/*\nfloat Sierpinski(vec3 z)\n{\nfloat Scale = 2.;\nfloat Offset = 10.;\n    float r;\n    int n = 0;\n    while (n < 5) {\n       if(z.x+z.y<0) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0) z.zy = -z.yz; // fold 3\t\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    return (length(z-1.) ) * pow(Scale, -float(n));\n}\n*/\n\nfloat sceneSDF(vec3 p) {\n\t/*\n\t// tricks from https://www.shadertoy.com/view/4tXGDn\n    const float n = 5;\n    const float speed = 0.5;\n    float phi = 2.0 * PI / n;\n    float t1 = phi / 4.0;\n    float t2 = 3.0 * t1;\n    \n    float s = Sierpinski((p+vec3(0., 0.5, .0)), 5);\n\tfloat m = menger(p, 1., 5);\n\tfloat b = boxSDF(p, vec3(1.));\n\tfloat py = pyramidSDF(p+vec3(0., 0.5, .0), 1.);\n\t\n    float sk  = smoothstep(cos(t2),cos(t1),cos(iTime*speed));\n    float pyk = smoothstep(cos(t2),cos(t1),cos(iTime*speed-phi));\n    float b0k  = smoothstep(cos(t2),cos(t1),cos(iTime*speed-2.*phi));\n    float mk  = smoothstep(cos(t2),cos(t1),cos(iTime*speed-3.*phi));\n    float b1k  = smoothstep(cos(t2),cos(t1),cos(iTime*speed-4.*phi));\n\t// return s*sk+py*pyk+m*mk+b*(b0k+b1k);*/\n\t\n\tfloat s = Sierpinski((p+vec3(0., 0.5, .0)), 6);\n\tfloat m = menger(p, 1., 5);\n\t\n\treturn mix(s, m, quadInOut(quadInOut(saw(mod(iTime/30.,1.)))));\n}\n\n// from iq technique\n// source: https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++) {\n        float h = 03.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = sceneSDF(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// source: https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sceneSDF( p + k.xyy*h ) + \n                      k.yyx * sceneSDF( p + k.yyx*h ) + \n                      k.yxy * sceneSDF( p + k.yxy*h ) + \n                      k.xxx * sceneSDF( p + k.xxx*h ) );\n}\n\n// return dist, marchingCount\nvec2 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 pos = O + D * t;\n        float d = sceneSDF(pos);\n        \n        t += d *0.8; // precision handling\n        ++marchingCount;\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return vec2(t, marchingCount);\n}\n\nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tfloat shadowsAttenuation = 5.;\n\tfloat specularStrength = 20.;\n\tvec3 backgroundColor = vec3(2,43,58)/255.0;\n\tvec3 ballsColor = vec3(255,166,43)/255.0;\n\t\n\tvec3 sunDir = normalize(vec3(0., 1., -1.));\n    vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));\n    float sunIntensity = 2.; \n    \n\tfloat d = rayMarching(O, D).x;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tif( d < MAX_DIST) {\n    \t// intersected point position\n        vec3 p = O + D * d;\n        vec3 normal = getNormal(p);\n        vec3 ref = normalize(reflect(D, normal));\n        \n        float occ = calcOcclusion(p, normal); // ambient occlusion\n        float sunDiffuse = min(1.,max(0., dot(normal, sunDir)));\n\t\t\n\t\tcol = ballsColor;\n        col += sunIntensity*sunColor*sunDiffuse;\n\t\tcol *= mix(occ, 1., 0.5);\n        col *= 0.3;\n    }else {\n    \tcol = backgroundColor;\n    }\n\t    \n\treturn vec3(min(vec3(1.), max(vec3(0.), col)));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.; // zoom\n\t\n\tfloat radius = 3.;\n\t\n// handle origin\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    \n    vec3 O;\n    \n    if(iMouse.z > 0.) {\n\t    // camera pos\n\t    float mag = 5.;\n\t    O = vec3(radius*sin(mag*m.x + PI/2.0), -10.*m.y, radius*cos(mag*m.x+PI/2.0));\n\t}else {\n\t\tfloat timeAnim = iTime/10.;\n\t\tradius = 3. + 1.5*cos(timeAnim);\n\n\t\tO = vec3(radius*sin(timeAnim + PI/2.0), -1.*cos(timeAnim), radius*cos(timeAnim+PI/2.0));\n\t}\n\n\t\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // gamma corection\n    finalColor = pow(finalColor, vec3(1./2.2));\n    \n    \n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y *= 1.5; // saturate\n    hsv.z *= 1.3;\n    finalColor = hsv2rgb(min(vec3(1.), max(vec3(0.), hsv)));\n    \n    // color grading\n    finalColor *= vec3(1.07 ,0.92, 0.95);\n    \n\tfragColor = vec4(finalColor,1.);\n}","name":"Image","description":"","type":"image"}]}