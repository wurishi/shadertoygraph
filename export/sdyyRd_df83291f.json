{"ver":"0.1","info":{"id":"sdyyRd","date":"1655373710","viewed":287,"name":"A Simple Diamond","username":"nelsonkuang","description":"Learn BSDF, add a diamond to https://www.shadertoy.com/view/4tyXDR","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","bsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mainly from: https://www.shadertoy.com/view/4tyXDR\n// Add object type 3, a diamond\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 3 // 0 = sphere, 1 = box, 2 = geometric gem shape, 3 = diamond\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * HASHSCALE3);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox(in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv) {\n\t// ray-box intersection\n  vec3 m = 1.0 / rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n  vec3 n = m * rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n  vec3 k = abs(m) * boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\n  vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n  vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n  float timeNear = max(max(t1.x, t1.y), t1.z);\n  float timeFar = min(min(t2.x, t2.y), t2.z);\n\n  if(timeNear > timeFar || timeFar < 0.0)\n    return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n  if(timeNear < 0.0)\n    timeNear = timeFar;\n\n  vec3 relPoint = rayOrigin + rayDirection * timeNear;\n\n  vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n\n  vec3 normal;\n  vec3 uaxis;\n  vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n  if(absRelPoint.x >= absRelPoint.y) {\n        // if X is the winner\n    if(absRelPoint.x >= absRelPoint.z) {\n      normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n      uaxis = vec3(0.0, 1.0, 0.0);\n      vaxis = vec3(0.0, 0.0, 1.0);\n    }\n        // else it's Z\n    else {\n      normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n      uaxis = vec3(1.0, 0.0, 0.0);\n      vaxis = vec3(0.0, 1.0, 0.0);\n    }\n  }\n    // else X isn't the biggest value so it can't be the normal axis\n  else {\n        // if Y is the winner\n    if(absRelPoint.y >= absRelPoint.z) {\n      normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n      uaxis = vec3(1.0, 0.0, 0.0);\n      vaxis = vec3(0.0, 0.0, 1.0);\n    }\n        // else it's Z\n    else {\n      normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n      uaxis = vec3(1.0, 0.0, 0.0);\n      vaxis = vec3(0.0, 1.0, 0.0);\n    }\n  }\n\n  uv = vec2(dot(relPoint, uaxis), dot(relPoint, vaxis));\n\n  return vec4(timeNear, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere(in vec3 rayPos, in vec3 rayDir, in vec4 sphere) {\n\t//get the vector from the center of this circle to where the ray begins.\n  vec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n  float b = dot(m, rayDir);\n\n  float c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n  if(c > 0.0 && b > 0.0)\n    return vec4(-1.0);\n\n\t//calculate discriminant\n  float discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n  if(discr < 0.0)\n    return vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n  float normalMultiplier = 1.0;\n  float collisionTime = -b - sqrt(discr);\n  if(collisionTime < 0.0) {\n    collisionTime = -b + sqrt(discr);\n    normalMultiplier = -1.0;\n  }\n\n    // calculate the normal, flipping it if we hit the inside of the sphere\n  vec3 normal = normalize((rayPos + rayDir * collisionTime) - sphere.xyz) * normalMultiplier;\n\n    // return the time t that the collision happened, as well as the surface normal\n  return vec4(collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane(in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv) {\n  float collisionTime = -(dot(rayPos, plane.xyz) + plane.w) / dot(rayDir, plane.xyz);\n  vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n  vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n  vec3 collisionPos = rayPos + rayDir * collisionTime;\n  uv.x = dot(collisionPos, uaxis);\n  uv.y = dot(collisionPos, vaxis);\n  return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval(vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal) {\n  vec2 uv;\n  vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);\n  if(dot(rayInfo.yzw, rayDir) < 0.0) {\n    if(rayInfo.x > rayMinMax.x) {\n      rayMinMax.x = rayInfo.x;\n      nearNormal = rayInfo.yzw;\n    }\n  } else {\n    if(rayInfo.x < rayMinMax.y) {\n      rayMinMax.y = rayInfo.x;\n      farNormal = rayInfo.yzw;\n    }\n  }\n}\n\n//============================================================\nvec4 RayIntersectObject(in vec3 rayPos, in vec3 rayDir) {\n    #if OBJECT_TYPE == 0\n  return RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n  vec2 uv;\n  vec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n  if(dot(rayDir, ret.yzw) > 0.0)\n    ret.yzw *= -1.0;\n  return ret;\n    #elif OBJECT_TYPE == 2\n  vec2 rayMinMax = vec2(-1.0, 1000.0);\n  vec3 nearNormal;\n  vec3 farNormal;\n\n  float size = -0.5;\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, 1.0, 1.0)), size * 0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, -1.0, 0.0)), size), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, -0.3, 1.0)), size), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, 0.3, -1.0)), size), nearNormal, farNormal);\n\n  if(rayMinMax.x > rayMinMax.y)\n    return vec4(-1.0);\n\n  if(rayMinMax.x > 0.0)\n    return vec4(rayMinMax.x, nearNormal);\n  else\n    return vec4(rayMinMax.y, -farNormal);\n    #else\n  // Diamond's model from https://www.shadertoy.com/view/NlVSzh\n  vec2 rayMinMax = vec2(-1.0, 1000.0);\n  vec3 nearNormal;\n  vec3 farNormal;\n\n  // float size = -0.5;\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, 0.70711, 0.70711)), -0.53033), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.70711, -0.5, -0.5)), 0.), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, 0.0, -1.)), 0.0), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-0.70711, -0.5, -0.5)), -0.0), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-0., -1., 0.0)), -0.0), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.70711, 0.5, 0.5)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.5, 0.85355, 0.14645)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.0, 1.0, 0.0)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-0.5, 0.85355, 0.14645)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-0.70711, 0.5, 0.5)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-0.5, 0.14645, 0.85355)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(-0., 0.0, 1.0)), -0.5), nearNormal, farNormal);\n  TrimRayInterval(rayPos, rayDir, rayMinMax, vec4(normalize(vec3(0.5, 0.14645, 0.85355)), -0.5), nearNormal, farNormal);\n\n  if(rayMinMax.x > rayMinMax.y)\n    return vec4(-1.0);\n\n  if(rayMinMax.x > 0.0)\n    return vec4(rayMinMax.x, nearNormal);\n  else\n    return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard(vec2 uv) {\n  return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel(vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow) {   \n    // ambient\n  vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n\n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n  if(doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n    return pixelColor;\n\n    // diffuse\n  float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n  pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n\n    // specular highlight\n  if(specPower > 0.0) {\n    vec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n    pixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);\n  }\n\n  return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident) {\n    #if DO_FRESNEL\n        // Schlick aproximation\n  float r0 = (n1 - n2) / (n1 + n2);\n  r0 *= r0;\n  float cosX = -dot(normal, incident);\n  if(n1 > n2) {\n    float n = n1 / n2;\n    float sinT2 = n * n * (1.0 - cosX * cosX);\n            // Total internal reflection\n    if(sinT2 > 1.0)\n      return 1.0;\n    cosX = sqrt(1.0 - sinT2);\n  }\n  float x = 1.0 - cosX;\n  float ret = r0 + (1.0 - r0) * x * x * x * x * x;\n\n        // adjust reflect multiplier for object reflectivity\n  ret = (OBJECT_REFLECTIVITY + (1.0 - OBJECT_REFLECTIVITY) * ret);\n  return ret;\n    #else\n  return OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor(in vec3 rayPos, in vec3 rayDir) {\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n\n    // if we hit the box, return the lit box color\n  vec2 uv;\n  vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n  if(rayInfo.x >= 0.0)\n    return LightPixel(rayPos + rayDir * rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n  else\n    return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor(in vec3 rayPos, in vec3 rayDir) {\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n  float multiplier = 1.0;\n  vec3 ret = vec3(0.0);\n  float absorbDistance = 0.0;\n  for(int i = 0; i < MAX_RAY_BOUNCES; ++i) {\n        // try and intersect the object\n    vec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n\n        // should \"never\" happen but handle it anyways\n    if(rayInfo.x < 0.0)\n      return ret;\n\n        // move the ray position to the intersection point.\n    rayPos = rayPos + rayDir * rayInfo.x;\n\n        // calculate beer's law absorption.\n    absorbDistance += rayInfo.x;\n    vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n\n        // calculate how much to reflect or transmit (refract or diffuse)\n    float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n    float refractMultiplier = 1.0 - reflectMultiplier;\n\n        // add in refraction outside of the object\n    vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n    ret += GetSceneRayColor(rayPos + refractDir * 0.001, refractDir) * refractMultiplier * multiplier * absorb;\n\n        // add specular highlight based on refracted ray direction\n    ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n\n        // follow the ray down the internal reflection path.\n    rayDir = reflect(rayDir, rayInfo.yzw);\n\n        // move the ray slightly down the reflect path\n    rayPos += rayDir * 0.001;\n\n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n    multiplier *= reflectMultiplier;\n  }\n\n    // return the color we calculated\n  return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor(in vec3 rayPos, in vec3 rayDir) {\n  vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n  vec3 rayHitDiffuse = vec3(1.0);\n  vec3 additiveColor = vec3(0.0);\n\n  vec3 ret = vec3(0.0);\n\n    // see if we've hit the platform and remember if we have\n  vec2 uv;\n  vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n  if(rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x) {\n    bestRayHitInfo = rayInfo;\n    rayHitDiffuse = Checkerboard(uv);\n  }\n\n    // if we've hit the main object, and it's closer than the platform\n  // vec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n  rayInfo = RayIntersectObject(rayPos, rayDir);\n  if(rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x) {       \n        // light the surface of the ball a bit\n    additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n\n        // move the ray to the intersection point\n    rayPos += rayDir * rayInfo.x;    \n\n        // calculate how much to reflect or transmit (refract or diffuse)\n    float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n    float refractMultiplier = 1.0 - reflectMultiplier;\n\n        // get reflection color\n        #if DO_REFLECTION\n    vec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n    ret += GetSceneRayColor(rayPos + reflectDir * 0.001, reflectDir) * reflectMultiplier;\n        #endif\n\n        // get refraction color\n        #if DO_REFRACTION\n    vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n    ret += GetObjectInternalRayColor(rayPos + refractDir * 0.001, refractDir) * refractMultiplier;\n        #endif\n\n    return ret + additiveColor;\n  }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n  else {\n    if(bestRayHitInfo.x == 1000.0)\n      return texture(iChannel0, rayDir).rgb;\n    else {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n      rayPos += rayDir * bestRayHitInfo.x;\n      return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);\n    }\n  }\n}\n\n//============================================================\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    //----- Camera Setup\n  vec2 mouse = iMouse.xy / iResolution.xy;\n\n  vec3 cameraAt = vec3(0.0);\n\n  float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n  float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n  vec3 cameraPos = (vec3(sin(angleX) * cos(angleY), sin(angleY), cos(angleX) * cos(angleY))) * 3.0;\n\n  vec3 cameraFwd = normalize(cameraAt - cameraPos);\n  vec3 cameraLeft = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0, sign(cos(angleY)), 0.0)));\n  vec3 cameraUp = normalize(cross(cameraLeft, cameraFwd));\n\n  float cameraViewWidth = 6.0;\n  float cameraViewHeight = cameraViewWidth * iResolution.y / iResolution.x;\n  float cameraDistance = 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n  vec2 rawPercent = (fragCoord.xy / iResolution.xy);\n  vec2 percent = rawPercent - vec2(0.5, 0.5);\n\n  vec3 rayTarget = (cameraFwd * vec3(cameraDistance, cameraDistance, cameraDistance)) - (cameraLeft * percent.x * cameraViewWidth) + (cameraUp * percent.y * cameraViewHeight);\n  vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n  vec3 finalColor = vec3(0.0);\n    #if DO_AA\n  for(int i = 1; i <= 16; ++i) {\n            // calculate stratified subpixel jitter in a 4x4 grid\n    float x = mod(float(i) - 1.0, 4.0);\n    float y = mod(floor(float(i) / 4.0), 4.0);\n    vec2 jitter = hash21(float(i)) / 4.0;\n    jitter.x += x / 4.0;\n    jitter.y += y / 4.0;\n\n            // set up the jittered ray\n    rawPercent = ((fragCoord.xy + jitter) / iResolution.xy);\n    percent = rawPercent - vec2(0.5, 0.5);\n\n    rayTarget = (cameraFwd * vec3(cameraDistance, cameraDistance, cameraDistance)) - (cameraLeft * percent.x * cameraViewWidth) + (cameraUp * percent.y * cameraViewHeight);\n    rayDir = normalize(rayTarget);                \n\n\t\t\t// raytrace\n    vec3 color = RayTracePixelColor(cameraPos, rayDir);\n\n            // incrementally average our pixel color in\n    finalColor = mix(finalColor, color, 1.0 / float(i));\n  }\n    #else\n  finalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n\n    //----- Final color, gamma corrected\n  fragColor = vec4(pow(finalColor, vec3(1.0 / 2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}