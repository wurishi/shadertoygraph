{"ver":"0.1","info":{"id":"csycDG","date":"1697973939","viewed":414,"name":"20231022_Bauhaus Quadtree","username":"0b5vr","description":"Bauhaus Quadtree by 0b5vr\nAppeared in TDF 16ms #0 Combined Graphics Compo\n\nOriginally made with Blossom, the 4k exegfx framework.\nIt would be compressed into a 2kb of Windows executable.\n","likes":39,"published":1,"flags":32,"usePreview":0,"tags":["3d","pathtracer","quadtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Present\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec4 tex = texelFetch( iChannel0, ivec2( fragCoord ), 0 );\n  fragColor = vec4(sqrt(tex.rgb / tex.a),1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Draw\n\n// Originally made with Blossom, the 4k exegfx framework\n// Shoutouts to yx!\n// https://github.com/lunasorcery/Blossom\n\nconst int SAMPLES_PER_FRAME = 5;\nconst int TRAVERSAL_STEPS = 30;\nconst int QUADTREE_SUBDIV = 3;\n\nconst float TAU = 2.0 * acos( -1.0 );\nconst float FAR = 100.0;\nconst float ROUGHNESS = 0.2;\nconst float SQ_ROUGHNESS = ROUGHNESS * ROUGHNESS;\nconst float SQ_SQ_ROUGHNESS = SQ_ROUGHNESS * SQ_ROUGHNESS;\nconst float HALF_SQ_ROUGHNESS = 0.5 * SQ_ROUGHNESS;\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash3f( vec3 s ) {\n  uvec3 r = floatBitsToUint( s );\n  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;\n  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;\n  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;\n  return vec3( r ) / float( -1u );\n}\n\nvec4 isectBoxPillar( vec3 ro, vec3 rd, vec3 s, vec3 po, float r ) {\n  // box sides\n  // front: each components of `dfv`\n  // back: each components of `dbv`\n  vec3 i_xo = -ro / rd;\n  vec3 xsOrRot = abs( s / rd );\n\n  vec3 dfv = i_xo - xsOrRot;\n  vec3 dbv = dfv + xsOrRot + xsOrRot;\n\n  // pillar side\n  // front: pf\n  // back: pb\n  xsOrRot = ro - po;\n  float sqLenXY = 1.0 - rd.z * rd.z;\n\n  float b = dot( xsOrRot, rd ) - xsOrRot.z * rd.z;\n  float i_c = dot( xsOrRot, xsOrRot ) - xsOrRot.z * xsOrRot.z - r * r;\n  float h = b * b - sqLenXY * i_c;\n\n  float df;\n\n  if ( h < 0.0 ) { return vec4( FAR ); }\n  h = sqrt( h );\n\n  float i_pf = ( -b - h ) / sqLenXY;\n  float i_pb = ( -b + h ) / sqLenXY;\n\n  // check faces\n  df = max( max( max( dfv.x, dfv.y ), dfv.z ), i_pf );\n  float i_db = min( min( min( dbv.x, dbv.y ), dbv.z ), i_pb );\n\n  if ( i_db < df || df < 0.0 ) { return vec4( FAR ); }\n\n  // calc normals\n  // crime: if NBox is not zero, use that. if NBox is zero, use NPillar instead\n  vec3 i_NBox = -sign( rd ) * step( vec3( df ), dfv );\n  vec3 i_NPillar = vec3( 0.01, 0.01, 0.0 ) * ( df * rd + xsOrRot ) / r;\n  vec3 i_N = normalize( i_NBox + i_NPillar );\n\n  // determine normal\n  return vec4( i_N, df );\n}\n\nmat3 orthBas( vec3 z ) {\n  vec3 x = normalize( cross(\n    step( 0.5, vec3( 0.0, z.z, 1.0 - z.z ) ),\n    z\n  ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  fragColor *= 0.0;\n\n  vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  vec3 seed = vec3( p, iFrame );\n\n  for ( int i = 0; i ++ < SAMPLES_PER_FRAME; ) {\n    vec3 colRem = normalize( vec3( -0.5, 0.2, 1.0 ) );\n\n    // cringe: normal distribution looks better than rectangle supersampling\n    vec2 i_aaJitter = sqrt( -2.0 * log( ( seed = hash3f( seed ) ).x ) ) * sin( TAU * seed.z + vec2( 0.0, TAU / 4.0 ) ) / iResolution.y;\n    vec3 ro = orthBas( colRem ) * vec3( ( p + i_aaJitter ), 6.0 );\n    vec3 rd = orthBas( colRem ) * vec3( 0.0, 0.0, -1.0 );\n\n    colRem /= colRem;\n\n    for ( int i = 0; i ++ < TRAVERSAL_STEPS; ) {\n      float colIndex = -1.0;\n\n      // background\n      vec4 isect = isectBoxPillar( ro - vec3( 0.0, 15.0, 0.0 ), rd, vec3( 10.0 ), vec3( 0.0 ), 10.0 );\n      vec4 isect2;\n\n      {\n        // quadtree subdivision\n        ro += rd * 0.001;\n\n        const float QUADTREE_DEPTH = 2.0;\n\n        vec3 cell = vec3( 0.0, 0.0, sign( ro.z ) * ( 0.5 * FAR + 0.5 * QUADTREE_DEPTH ) );\n        vec3 cellSize = vec3( FAR );\n        vec3 cellDice = vec3( 1e9 );\n\n        if ( abs( ro.z ) < 0.5 * QUADTREE_DEPTH ) {\n          cellSize = vec3( QUADTREE_DEPTH );\n          for ( int i = 0; i ++ < QUADTREE_SUBDIV && cellDice.x > 0.5; ) {\n            cellSize *= 0.5;\n            cellSize.z = QUADTREE_DEPTH;\n\n            cell = ( floor( ro / cellSize ) + 0.5 ) * cellSize;\n            cell.z = 0.0;\n            cellDice = hash3f( cell + 3.0 );\n          }\n        }\n\n        ro -= rd * 0.001;\n\n        {\n          // quadtree traversal\n          vec3 i_src = -( ro - cell ) / rd;\n          vec3 i_dst = abs( 0.5 * cellSize / rd );\n          vec3 bvOrRot = i_src + i_dst;\n          float distToNextCell = min( min( bvOrRot.x, bvOrRot.y ), bvOrRot.z );\n\n          vec3 rand = vec3( 0.0 );\n\n          // scene\n          bvOrRot = ro - cell - vec3( 0.0, 0.0, 0.4 * cellDice.y - 1.0 );\n\n          for ( int i = 0; i ++ < 3; ) {\n            cellDice = hash3f( cellDice );\n\n            isect2 = isectBoxPillar(\n              bvOrRot,\n              rd,\n              vec3( 0.5 * cellSize.xx - 0.001, 1.0 + 0.02 * float( i ) ),\n              cellSize * step( cellDice.z, 0.8 ) * ( step( 0.5, hash3f( -cellDice ) ) - 0.5 ),\n              ( cellSize.x - 0.002 ) * exp2( 1.0 - rand.y )\n            );\n\n            if ( isect2.w < isect.w ) {\n              isect = isect2;\n              colIndex = rand.x;\n            }\n\n            rand += 1.0 + step( 0.5, cellDice );\n          }\n\n          // should we skip the cell?\n          if ( distToNextCell < isect.w ) {\n            ro += distToNextCell * rd;\n            continue;\n          }\n        }\n      }\n\n      // does it miss?\n      fragColor.xyz += step( colIndex, -1.0 ) * step( isect.w + 1.0, FAR ) * min( colRem, 1.0 ) / 0.1;\n      colRem *= step( 0.0, colIndex );\n\n      // if hit then\n      ro += isect.w * rd;\n\n      {\n        float NdotV = dot( isect.xyz, -rd );\n        float Fn = mix( 0.04, 1.0, pow( 1.0 - NdotV, 5.0 ) );\n        float spec = step( ( seed = hash3f( seed ) ).x, Fn );\n\n        // sample ggx or lambert\n        seed.y = sqrt( ( 1.0 - seed.y ) / ( 1.0 - spec * ( 1.0 - SQ_SQ_ROUGHNESS ) * seed.y ) );\n        vec3 woOrH = orthBas( isect.xyz ) * vec3(\n          sqrt( 1.0 - seed.y * seed.y ) * sin( TAU * seed.z + vec2( 0.0, TAU / 4.0 ) ),\n          seed.y\n        );\n\n        if ( spec > 0.0 ) {\n          // specular\n          // note: woOrH is H rn\n          vec3 i_H = woOrH;\n          vec3 i_wo = reflect( rd, i_H );\n\n          // vector math\n          float NdotL = dot( isect.xyz, i_wo );\n          float i_VdotH = dot( -rd, i_H );\n          float i_NdotH = dot( isect.xyz, i_H );\n\n          // fresnel\n          float i_Fh = mix( 0.04, 1.0, pow( 1.0 - i_VdotH, 5.0 ) );\n\n          // brdf\n          // colRem *= Fh / Fn * G * VdotH / ( NdotH * NdotV );\n          colRem *= i_Fh / Fn\n          //        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Fh\n            / ( NdotV * ( 1.0 - HALF_SQ_ROUGHNESS ) + HALF_SQ_ROUGHNESS ) // G1V / NdotV\n            * NdotL / ( NdotL * ( 1.0 - HALF_SQ_ROUGHNESS ) + HALF_SQ_ROUGHNESS ) // G1L\n            * i_VdotH / i_NdotH;\n\n          // wo is finally wo\n          woOrH = i_wo;\n        } else {\n          // diffuse\n          // note: woOrH is wo rn\n\n          // calc H\n          // vector math\n          vec3 i_H = normalize( -rd + woOrH );\n          float i_VdotH = dot( -rd, i_H );\n\n          // fresnel\n          float i_Fh = mix( 0.04, 1.0, pow( 1.0 - i_VdotH, 5.0 ) );\n\n          // color\n          vec3 i_baseColor = vec3[](\n            vec3( 0.01, 0.02, 0.03 ),\n            vec3( 0.04, 0.04, 0.3 ),\n            vec3( 0.8, 0.1, 0.1 ),\n            vec3( 0.8, 0.4, 0.1 ),\n            vec3( 0.8 )\n          )[ int( colIndex ) ];\n\n          // brdf\n          colRem *= ( 1.0 - i_Fh ) / ( 1.0 - Fn ) * i_baseColor;\n        }\n\n        // prepare the rd for the next ray\n        rd = woOrH;\n\n        // if the ray goes beind the surface, invalidate it\n        colRem *= step( 0.0, dot( woOrH, isect.xyz ) );\n      }\n\n    }\n\n    fragColor.w += 1.0;\n  }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Accumulate\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // accumulate using backbuffer\n  fragColor = texture( iChannel0, uv );\n\n  if ( iFrame > 1 && iMouse.w < 0.5 ) {\n    fragColor += texture( iChannel1, uv );\n  }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}