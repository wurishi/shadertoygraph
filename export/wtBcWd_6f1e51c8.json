{"ver":"0.1","info":{"id":"wtBcWd","date":"1595702882","viewed":161,"name":"Waves v.4","username":"pli","description":"Same boat, now in 3d. Only realized how slow it was when I tried it on my old computer :)\nV.5 is much faster: https://www.shadertoy.com/view/wt2yDt","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define EYE_COLOR vec3(0., 0.0, 0.0)\n\n#define BOAT_INITIAL_X 0.1\n#define BOAT_INITIAL_Z 0.3\n\n\n#define X_WAVES 10.\n#define Z_WAVES 10.\n#define X_WAVE_SPACE 0.15\n#define Z_WAVE_SPACE 0.1\n\n#define WAVE_SMOOTH 0.13\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\t\treturn sqrt( (p.x-center.x) * (p.x-center.x) + (p.y-center.y) * (p.y-center.y) + (p.z-center.z) * (p.z-center.z)) - radius;   \n}\n\nfloat distPoints(vec2 p1, vec2 p2) {\n\treturn sqrt( (p1.x-p2.x) * (p1.x-p2.x) + (p1.y-p2.y) * (p1.y-p2.y));   \n}\n\n\nfloat heightAt(float xd, float z) {\n    return -0.1 + 0.01 * cos(13.*xd + 2.*z);\n}\n\nfloat boatHeight(vec3 pos, float delta) {\n    return -0.1 - 0.01 * cos(6. * pos.x + delta * 2. * 3.14159) + 0.1;\n}\n\nfloat sphereSize(float x, float z) {\n    return 0.1 + 0.02 * cos(4.*x - z);\n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n\tvec3 coords;\n    coords.x = -X_WAVE_SPACE * X_WAVES / 2. + grid.x * X_WAVE_SPACE;\n    coords.y = grid.y;\n    coords.z = grid.z * Z_WAVE_SPACE;\n    return coords;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n\tvec3 grid;\n    grid.x = (coords.x + X_WAVE_SPACE * X_WAVES / 2.) / X_WAVE_SPACE;\n    grid.y = coords.y;\n    grid.z = coords.z / Z_WAVE_SPACE;\n    return grid;\n}\n\nfloat waveSizeAt(vec3 coords) {\n    return 0.10 + 0.03 * cos(coords.x + 2. * sin(0.5*coords.z) + 4.*iTime);   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.04 + waveSizeAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    float dist = 1.;\n    for (float x = 0. ; x < X_WAVES ; x+=1.) {\n        for (float z = 0. ; z < Z_WAVES ; z+=1.) {\n\n            vec3 coords = coordsFromGrid(vec3(x, 0., z));            \n            \n            float size = waveSizeAt(vec3(x, 0., z));\n\t\t\tfloat distSphere = distSphere(pos, coords, size);\n   \t\t \tdist = smoothmin(dist, distSphere, WAVE_SMOOTH); // 0.08\n        }\n    }\n    \n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\n    float initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\n\n    // boat\n    vec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .5;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    vec3 ink = vec3(0.15, 0.2, 0.3);\n    \n    //camera\n    vec3 eye = vec3(0., 1.,6.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.12) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.23, 0.25);\n    if (distPoints(moonPosition, uv) < 0.2) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totDist = 0.;\n    float maxDist = 7.;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n\n    col = colorVariation * (0.75 + dot(normal, light));\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.3);\n\tcol = mix(col, vec3(1.), (shineVariation -  0.5 * colorVariation) * spec);\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}