{"ver":"0.1","info":{"id":"XstyD8","date":"1518691817","viewed":405,"name":"Minimal mouse-lit sphere","username":"KaleyGoode","description":"Click the canvas to alter the light origin.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["lighting","sphere","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Minimal mouse-lit sphere.\nClick the canvas to alter the light origin.\n\nFrom part of a tutorial I wrote here:\nhttp://mines.lumpylumpy.com/Electronics/Computers/Software/Cpp/Graphics/Bitmap/Textures/Wait/spheres.php\n\nOnly two of the helper functions are used but I've left the rest in for completeness.\n___________________________________________________________________________________________\nMinimise mapping by having everything return normalised ranges [0,1] or [-1,1].\nUnsigned Interval is [0,1]; Signed interval is [-1,1]; These change between the two (useful for double or float):\n*/\n#define unsigned(t) ((t + 1.0) / 2.0) // in = [-1,1] out = [ 0,1]\n#define   signed(t) (2.0 * t - 1.0)   // in = [ 0,1] out = [-1,1]\n\n#define   invert(t) (1.0 - t) // in = [0,1] out = [1,0]\n\n#define map(v)  ((v - middle) / radius) // Map the vector to the sphere\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float radius = min(iResolution.x, iResolution.y) / 3.0; // Radius is 1/3 of the smallest canvas dimension\n    vec2  middle = iResolution.xy / 2.0, // Middle of the canvas\n      mousePixel = map(iMouse.xy), // Mapped to sphere-relative coordinates\n      drawnPixel = map(fragCoord); // Mapped to sphere-relative coordinates\n    float      z = 3.0 * sqrt(abs(invert(dot(drawnPixel, drawnPixel)))); // Spherical model for the perceived height\n    fragColor    = vec4(unsigned((dot(mousePixel, drawnPixel) + z) / (1.0 + length(mousePixel))));\n}","name":"Image","description":"","type":"image"}]}