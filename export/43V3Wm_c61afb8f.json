{"ver":"0.1","info":{"id":"43V3Wm","date":"1717736412","viewed":39,"name":"menger with  Tetrahedral","username":"nnew","description":"1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*from https://www.shadertoy.com/user/nimitz*/\n#define ITR 200\n#define FAR 27\n#define time iTime\n\nconst float fov = 1.5;\nfloat dfog = 0.;\nfloat matid = 0.;\n\n#define TYPE 2\n\n#if TYPE == 1\nconst vec3 ofst1 = vec3(2.35,-2.4,0.0);\nconst vec3 ofst2 = vec3(0.2,0.5,.1);\nconst float fixed_radius2 = 13.5;\nconst float min_radius2 = 9.;\nconst float folding_limit = 4.1;\nconst float scale = -3.;\nconst float thresh = 2.9;\n#elif TYPE == 2\nconst vec3 ofst1 = vec3(2.5,-1.5,-0.5);\nconst vec3 ofst2 = vec3(0.,1.,0.);\nconst float fixed_radius2 = 14.;\nconst float min_radius2 = 8.;\nconst float folding_limit = 3.7;\nconst float scale = -2.8;\nconst float thresh = 3.7;\n#else\nconst vec3 ofst1 = vec3(2.3,-2.3,0.);\nconst vec3 ofst2 = vec3(0.2,10.,0.);\nconst float fixed_radius2 = 14.;\nconst float min_radius2 = 10.;\nconst float folding_limit = 4.;\nconst float scale = -2.9;\nconst float thresh = 2.9;\n#endif\n\nvec3 sphere_fold(vec3 p, inout float d) \n{\n  \n\t\n    float p2 = dot(p, p);\n  \n    if(p2 < min_radius2) \n    {\n        float t = (fixed_radius2 / min_radius2);\n        p *= t;\n        d *= t;\n    }\n    \n    return p;\n}\n\nvec3 fold_tet(in vec3 p)\n{\n    const vec3 nc = vec3(-00.55,-0.5,0.7071);\n    p.xy = abs(p.xy);\n   \tfloat t = 2.*dot(p,nc);\n    p -= t*nc;\n    p.xy = abs(p.xy);\n    t = 2.*min(0.,dot(p,nc));\n    p -= t*nc;\n    return p;\n}\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);} \n\nfloat map(vec3 p) \n{\n\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    \n    p = fold_tet(p);\n    p += ofst1;\n    vec3 c = p;\n  \n    p += ofst2;\n    float dr = 1.;\n    for(int n = 0; n < 10; ++n) \n    {\n        p = clamp(p, -folding_limit, folding_limit) * 2.0 - p;\n        p = sphere_fold(p, dr);\n        p = scale*p + c;\n        p.xy*=ma;\n        dr = dr * abs(scale) + 1.0;\n    }\n    float dd = length(p)/abs(dr);\n    dd= max(dd, (max(abs(c.x), max(abs(c.y),abs(c.z)))-thresh));\n    return dd;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp(occ*-2.+1., 0.0, 1.0 );    \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.2, 0.5);\n        if( h<0.0005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat shadow2( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<5; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.2, 1.);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n//5 taps total, returns both normal and curvature\nvec3 norcurv(in vec3 p, out float curv, out float t0)\n{\n    vec2 e = vec2(-1., 1.)*0.01;\n    t0 = map(p);\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n\t\n    \n    //curv = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*t0);\n    curv = 10./(e.y)*(t1 + t2 + t3 + t4 - 4.0*t0);\n    return normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n}\n\n//Curvature only, 5 taps, with epsilon width as input\nfloat curv(in vec3 p, in float w, in float t0)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .125/(e.x*e.x)*(t1 + t2 + t3 + t4 - 4.0*t0);\n}\n\nstruct mtl{float rough; vec3 alb; vec3 f0;};\nvec3 lgt = normalize( vec3(-1., 0.2, 0.3) );\n//vec3 lgt = normalize( vec3(-1., 0.2, -0.3) );\nvec3 lcol = vec3(1.,0.87,0.95);\n\nvec3 shade(in vec3 pos, in vec3 rd)\n{\n    float crv2 = 0.;\n    float tb = 0.;\n    vec3 nor = norcurv(pos, crv2, tb);\n\n    //lighting\n    float crv = curv(pos, 0.022, tb)*0.15;\n    vec3 mat = sin(vec3(5.7,5.8,0.9)+crv + 4.5)*0.6+0.4;\n    mat *= mat;\n \n    float dif = max(dot(nor,lgt),0.);\n    float bac = clamp( dot( nor, -lgt), 0., 1. )*clamp( 1.0-rd.y,0.0,1.0);\n    float fre = pow( clamp(1.+dot(nor,rd), 0., 1.), 2. );\n    float spe = pow(max(dot(reflect(rd,nor),lgt),0.),30.);\n    \n    float shd = shadow2(pos, lgt, 0.1,4.)+0.0001;\n    return (dif*mat*lcol + spe*0.75 + fre*0.1*spe)*shd;\n    \n}\n\n\nvec3 marchAA(in vec3 ro, in vec3 rd, in vec3 bgc, in float px, in mat3 cam)\n{\n\tfloat precis = 0.005;\n    float h=precis*2.0;\n    float d = 0.;\n    float told = 0.;\n    for( int i=0; i<120; i++ )\n    {\n       \n        told = d;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n    \n \n\n    \n    vec3 col = bgc;\n    \n\n     \n        vec3 pos = ro+d*rd;\n        col = shade(pos, rd);\n    \n  \n   \n    return col;\n}\n\nvec3 bgt(in vec3 rd)\n{\n    //Bg color\n    float sun = clamp(dot(lgt,rd),0.0,1.0 );\n\tvec3 hor = mix( vec3(0.2,.1,.3), vec3(1.,.5,0.55), sun );\n    vec3 col = mix( vec3(2.1,0.,.4)*0.2, hor, exp(-(4.0+2.0*(1.-sun))*max(0.0,rd.y)) )*0.5;\n\tcol += vec3(1.0,0.8,1.)*pow(sun,128.0);\n\t\n    return col;\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define ITR2 200\n#define FAR2 200.\n\nconst float fov2 = 1.4;\nfloat dfog2 = 0.;\nfloat matid2 = 0.;\n\n#define FLIP_SPEED 0.22\n#define FLIP_REV 0.5\n#define FLIP_CURVE 0.3\n\n\nfloat an2 = 0.;\n\nvoid sphere_fold2(inout vec3 z, inout float dz, float rd1, float rd2) {\n    float r2 = dot(z, z);\n    if(r2 < rd1) \n    {\n        float temp = (rd2 / rd1);\n        z *= temp;\n        dz *= temp;\n    }\n    else if(r2 < rd2) {\n        float temp = (rd2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid octfold2(inout vec3 z, float octsize, float limit) {\n    \n    float odst = dot(abs(z), vec3(0.57735));\n    \n    if (odst > octsize)\n    {\n        vec3 sn = vec3(lessThanEqual(vec3(0.0), z))*2.0 - 1.0;\n        vec3 n = vec3(sn)*0.57735;   \n        float fdist = (odst - octsize);\n        fdist = clamp(fdist, -limit, limit);\n        z -= 2.0*n*fdist;\n    }\n}\n\nmat2 rot2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat smoothfloor2(in float x, in float k)\n{\n    k = clamp(k, 0., 1.);\n    float xk = x+k*0.5;\n    return floor(xk)+smoothstep(0.,1.,smoothstep(0.,k,fract(xk)));\n}\n\nfloat map2(vec3 p)\n{\n\n    float an1 = sin(an2*1.1*2.)*.2;\n    float an2 = sin(an2*1.4*2. + 1.)*3.;\n    float an3 = cos(an2*2.1*2.)*4.;\n     float t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p.xy) + .37)) * 2.2;\n    float si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n    p.xy*=ma;\n    float fixed_radius2 = 15.*cos(iTime);\n\tfloat min_radius2 = 0.;\n\tfloat folding_limit = 8. + an2*.2;\n\tfloat scale = -1.85 + an1;\n\tfloat octsize = 2. + an3;\n    \n    vec3 c = p;\n    float ds = 1.;\n    for(int n = 0; n < 18; ++n) \n    {\n        octfold2(p, octsize, folding_limit);\n        sphere_fold2(p, ds, min_radius2, fixed_radius2);\n        p = scale*p + c;\n        ds = ds * abs(scale) + 1.;\n    }\n    return length(p)/abs(ds)*.8;\n}\n\nvec3 normal2(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.04;   \n\treturn normalize(e.yxx*map2(p + e.yxx) + e.xxy*map2(p + e.xxy) + \n\t\t\t\t\t e.xyx*map2(p + e.xyx) + e.yyy*map2(p + e.yyy) );   \n}\n\nfloat shadow3( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = map2( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.2, 0.5);\n        if( h<0.0005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat curvM2(in vec3 p, in float w, vec3 n)\n{\n    float t1 = map2(p + n*w*1.0), t2 = map2(p - n*w*1.0);\n    float t3 = map2(p + n*w*3.0), t4 = map2(p - n*w*3.0);\n    float t5 = map2(p + n*w*9.0), t6 = map2(p - n*w*9.0);\n    float t0 = map2(p);\n    return smoothstep(-.1, .9, (10.*(t1 + t2) + 1.*(t3 + t4) + 1.*(t5+t6) - 40.*t0))*3.0;\n}\n\nstruct mtl2{float rough; vec3 alb; vec3 f0;};\nvec3 lgt2 = normalize( vec3(-.5, 0.3, -0.2) );\nvec3 lcol2 = vec3(1.,0.9,0.8);\n\nmat3 rot_x2(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y2(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z2(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n//http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade2(in vec3 pos, in vec3 rd)\n{\n    vec3 nor = normal2(pos);\n    \t\n    mtl m; //Material\n    m.alb = vec3(0.25,0.4,0.8);\n    m.rough = 0.5;\n    m.f0 = vec3(.04);\n    m.alb *= rot_y2(sin(an2*0.2 + 3.5)*0.2);\n    \n\tfloat nl = clamp(dot(nor,lgt2), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    if (nl > 0.)\n    {\n        nl *= shadow2(pos, lgt2, .8,15.)+0.0001;\n        vec3 haf = normalize(lgt2 - rd);\n        float nh = clamp(dot(nor, haf), 0., 1.); \n        float nv = clamp(dot(nor, -rd), 0., 1.);\n        float lh = clamp(dot(lgt2, haf), 0., 1.);\n        float a = m.rough*m.rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(3.14159*dnm*dnm);\n        float k = pow(m.rough + 1., 2.)/8.; //hotness reducing\n\t\tfloat G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));\n        vec3 F = m.f0 + (1. - m.f0) * exp2((-5.55473*lh - 6.98316) * lh); //\"optimization\"\n        vec3 spec = nl*D*F*G;\n        col = lcol2*nl*(spec + m.alb*(1. - m.f0));\t\t\n    }\n    col += 0.015*m.alb;\n    float crv = curvM2(pos, .17,nor);\n   \n    col *= crv;\n    return col;\n}\n\n//From eiffie: https://www.shadertoy.com/view/XsSXDt\nvec3 marchAA2(in vec3 ro, in vec3 rd, in vec3 bgc, in float px, in mat3 cam)\n{\n    float precis = px*0.1;\n    float prb = precis;\n    float t=map2(ro);\n\tvec3 col = vec3(0);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0,d=0.;\n\tfor(int i=0;i<ITR;i++)\n    {\n\t\td=map2(ro+rd*t)*1.2;\n\t\tif(df==100.0)\n        {\n\t\t\tif(d>od)\n            {\n\t\t\t\tif(od<px*(t-od))\n                {\n\t\t\t\t\tdf=od;tf=t-od;\n                    t += .01; //step forward a bit when the first occluder is found\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tt+=d;\n\t\n\t}\n\tcol=bgc;\n    \n\tif(dm<px*tm)\n        col=mix(shade2((ro+rd*tm) - rd*(px*(tm-dm)) ,rd),col,clamp(dm/(px*tm),0.0,1.0));\n    \n\tfloat qq=0.0;\n\t\n  \n    \n        ro+=cam*vec3(0.5,0.5,0.)*px*tm*1.;\n        tf=tm;\n        df=dm;\n        qq= .01;\n\t\n    dfog = tm;\n    return mix(shade2((ro+rd*tf) - rd*(px*tf-df),rd),col,clamp(qq+df/(px*tf),0.0,1.0));\n}\n\nvec3 bgt2(in vec3 rd)\n{\n    float sun = clamp(dot(lgt2,rd),0.0,1.0 );\n\tvec3 c2 = mix( vec3(0.8,.95,1.1), vec3(1.,.8,0.55), sun );\n    vec3 col = mix( vec3(5.2,0.6,.9), c2, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\n    col *= 0.6;\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,128.0);\n\tcol += 0.3*vec3(1.0,0.6,0.2)*pow(sun,32.0);\n    col += 0.1*vec3(1.0,0.6,0.2)*pow(sun,4.0);\n    return col;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px= .5/(iResolution.y*fov);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n    p*=2.;\n\tp.x*=iResolution.x/iResolution.y;\n    float t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p.xy) + .37)) * 2.2;\n    float si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n   \n   \n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.15,0.05):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=4.14;\n\t\n    vec3 ro = vec3(0.,-0.,12.);\n    vec3 rd = normalize(vec3(p,-fov));\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x);\n   \tro *= cam;\n\trd *= cam;\n    \n\t\n   \n   \n    float px2= 1./(iResolution.y*fov2);\n\tvec2 q2 = fragCoord.xy / iResolution.xy;\n    vec2 p2 = q2 - 0.5;\n        p2*=2.;\n\tp2.x*=iResolution.x/iResolution.y;\n\tvec2 mo2 = iMouse.xy / iResolution.xy-.5;\n    \n    \n   \n  \n   \n   \t    vec3 ro2 = vec3(0.,-0.0,110.);\n    vec3 rd2 = normalize(vec3(p2,-fov2));\n    \n   rd2*=cam;\n   ro2*=cam;\n   vec3 bg2 = bgt2(rd2);\n    vec3 col2 = bg2;\n    \n    col2 = marchAA2(ro2, rd2, bg2, px2, cam);\n  \n\n  \n    vec3 bg = bgt(rd);\n    vec3 col = bg;\n    \n    col = marchAA(ro, rd, bg, px, cam);\n    col = clamp(col, 0.,1.);\n    \n\n\n  vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n\tfragColor = vec4( col2*col, 0.0 );\n      uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.55,0.5,0.55)*3., 1.0);\n}","name":"Image","description":"","type":"image"}]}