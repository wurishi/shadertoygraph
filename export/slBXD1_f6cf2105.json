{"ver":"0.1","info":{"id":"slBXD1","date":"1627981461","viewed":438,"name":"Tetris Effect","username":"nr4","description":"This is an already-solved tetris effect!\nTweak board size in the common tab.\nIt also has a 2D visualization (turn on in common tab).","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","cellular","tetris","multipass","automaton","solved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Tetris Effect\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst float fsaa = 144.;\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // SSAA\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*mix(3.,depthBlur?20.:3.,2.*abs(fragCoord.y/iResolution.y-.5))*exp(-abs(1.e-2*length(fragCoord.xy)/iResolution.y-.5))/max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    // edge glow\n    vec2 uv2 = uv;\n    uv = fragCoord/iResolution.xy;\n    vec2 unit = 1./iResolution.xy;\n\n    float o = 1.0;\n    float p = 3.0;\n    float q = 0.0;\n\n\n    vec4 col11 = texture(iChannel0, uv + vec2(-unit.x, -unit.y));\n    vec4 col12 = texture(iChannel0, uv + vec2( 0., -unit.y));\n    vec4 col13 = texture(iChannel0, uv + vec2( unit.x, -unit.y));\n\n    vec4 col21 = texture(iChannel0, uv + vec2(-unit.x, 0.));\n    vec4 col22 = texture(iChannel0, uv + vec2( 0., 0.));\n    vec4 col23 = texture(iChannel0, uv + vec2( unit.x, 0.));\n\n    vec4 col31 = texture(iChannel0, uv + vec2(-unit.x, unit.y));\n    vec4 col32 = texture(iChannel0, uv + vec2( 0., unit.y));\n    vec4 col33 = texture(iChannel0, uv + vec2( unit.x, unit.y));\n\n    vec4 x = col11 * -o + col12 * -p + col13 * -o + col31 * o + col32 * p + col33 * o + col22 * q;\n    vec4 y = col11 * -o + col21 * -p + col31 * -o + col13 * o + col23 * p + col33 * o + col22 * q;\n\n    // Output to screen\n    fragColor = vec4(abs(y.rgb) * 0.5 + abs(x.rgb) * 0.5, 1.);\n    fragColor = vec4(mix(col, fragColor.rgb, clamp(length(col)>.7?.2:0.,0.,1.)),1.0);\n\n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0;\n    vig = pow(vig, 0.2);\n    fragColor *= vig;\n\n    // team210 watermark\n    float d = d210(8.*(uv2-.5*vec2(iResolution.x/iResolution.y,1.)+vec2(.1,.04)));\n    fragColor.rgb = mix(fragColor.rgb, mix(fragColor.rgb, c.xxx, .5), sm(d));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Tetris Effect\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \n// State texture\n// Layout:\n// board state (width * height) below a line with state of the game\n// state of the game: last time step, did move in the last step, current tile type, \n// current tile pivot location, current tile coordinates, current tile location on the board\n\nint currentState(ivec2 index)\n{\n    return int(round(texelFetch(iChannel0, index, 0).r));\n}\n\nfloat currentStateF(ivec2 index)\n{\n    return texelFetch(iChannel0, index, 0).r;\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\nfloat readStateF(ivec2 index, ivec2 where, float state)\n{\n    return all(equal(index, where)) ? state : -1.;\n}\n\nstruct Tile\n{\n    ivec2 coordinates[4];\n    int tileType;\n    ivec2 pivot;\n};\n\nconst int NTILES = 19;\nconst mat2 m = mat2(0.,1.,-1.,0.),\n    ms = m * m,\n    mt = transpose(m);\nconst Tile\n    to = Tile(ivec2[4](ivec2(0,0), ivec2(1,0), ivec2(0,-1), ivec2(1,-1)), 1, ivec2(0,0)),\n    ti = Tile(ivec2[4](ivec2(0,0), ivec2(0,-1), ivec2(0,-2), ivec2(0,-3)), 2, ivec2(0,-1)),\n    ti90 = Tile(ivec2[4](ivec2(m*vec2(0,0)), ivec2(m*vec2(0,-1)), ivec2(m*vec2(0,-2)), ivec2(m*vec2(0,-3))), 2, ivec2(m*vec2(0,-1))),\n    ts = Tile(ivec2[4](ivec2(1,0), ivec2(2,0), ivec2(0,-1), ivec2(1,-1)), 3, ivec2(1,0)),\n    ts90 = Tile(ivec2[4](ivec2(m*vec2(1,0)), ivec2(m*vec2(2,0)), ivec2(m*vec2(0,-1)), ivec2(m*vec2(1,-1))), 3, ivec2(m*vec2(1,0))),\n    tz = Tile(ivec2[4](ivec2(0,0), ivec2(1,0), ivec2(1,-1), ivec2(2,-1)), 4, ivec2(1,0)),\n    tz90 = Tile(ivec2[4](ivec2(m*vec2(0,0)), ivec2(m*vec2(1,0)), ivec2(m*vec2(1,-1)), ivec2(m*vec2(2,-1))), 4, ivec2(m*vec2(1,0))),\n    tl = Tile(ivec2[4](ivec2(0,0), ivec2(0,-1), ivec2(0,-2), ivec2(1,-2)), 5, ivec2(0,-1)),\n    tl90 = Tile(ivec2[4](ivec2(m*vec2(0,0)), ivec2(m*vec2(0,-1)), ivec2(m*vec2(0,-2)), ivec2(m*vec2(1,-2))), 5, ivec2(m*vec2(0,-1))),\n    tl180 = Tile(ivec2[4](ivec2(ms*vec2(0,0)), ivec2(ms*vec2(0,-1)), ivec2(ms*vec2(0,-2)), ivec2(ms*vec2(1,-2))), 5, ivec2(ms*vec2(0,-1))),\n    tl270 = Tile(ivec2[4](ivec2(mt*vec2(0,0)), ivec2(mt*vec2(0,-1)), ivec2(mt*vec2(0,-2)), ivec2(mt*vec2(1,-2))), 5, ivec2(mt*vec2(0,-1))),\n    tj = Tile(ivec2[4](ivec2(1,0), ivec2(1,-1), ivec2(1,-2), ivec2(0,-2)), 6, ivec2(1,-1)),\n    tj90 = Tile(ivec2[4](ivec2(m*vec2(1,0)), ivec2(m*vec2(1,-1)), ivec2(m*vec2(1,-2)), ivec2(m*vec2(0,-2))), 6, ivec2(m*vec2(1,-1))),\n    tj180 = Tile(ivec2[4](ivec2(ms*vec2(1,0)), ivec2(ms*vec2(1,-1)), ivec2(ms*vec2(1,-2)), ivec2(ms*vec2(0,-2))), 6, ivec2(ms*vec2(1,-1))),\n    tj270 = Tile(ivec2[4](ivec2(mt*vec2(1,0)), ivec2(mt*vec2(1,-1)), ivec2(mt*vec2(1,-2)), ivec2(mt*vec2(0,-2))), 6, ivec2(mt*vec2(1,-1))),\n    tt = Tile(ivec2[4](ivec2(0,0), ivec2(-1,0), ivec2(1,0), ivec2(0,-1)), 7, ivec2(0,0)),\n    tt90 = Tile(ivec2[4](ivec2(m*vec2(0,0)), ivec2(m*vec2(-1,0)), ivec2(m*vec2(1,0)), ivec2(m*vec2(0,-1))), 7, ivec2(m*vec2(0,0))),\n    tt180 = Tile(ivec2[4](ivec2(ms*vec2(0,0)), ivec2(ms*vec2(-1,0)), ivec2(ms*vec2(1,0)), ivec2(ms*vec2(0,-1))), 7, ivec2(ms*vec2(0,0))),\n    tt270 = Tile(ivec2[4](ivec2(mt*vec2(0,0)), ivec2(mt*vec2(-1,0)), ivec2(mt*vec2(1,0)), ivec2(mt*vec2(0,-1))), 7, ivec2(mt*vec2(0,0)));\nconst Tile[NTILES] tiles = Tile[NTILES](to, ti, ti90, ts, ts90, tz, tz90, tl, tl90, tl180, tl270, tj, tj90, tj180, tj270, tt, tt90, tt180, tt270);\nconst float[NTILES] weights = float[NTILES](2.,.25,1.,2.,1.,2.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,.25,.25,.25);\n\n// Note: where is not absolute here.\nbool isInTile(ivec2 where, Tile tile)\n{\n    for(int i=0; i<4; ++i)\n        if(all(equal(tile.coordinates[i], where)))\n            return true;\n    return false;\n}\n\n// Note: This can only be applied to the state from the last pass invocation. Local changes from\n// the current pass will not have any effects.\nbool canSpawn(ivec2 where, Tile tile)\n{\n    ivec4 presentState;\n    bool inBounds = true;\n    for(int i=0; i<4; ++i)\n    {\n        presentState[i] = currentState(where + tile.coordinates[i]);\n        inBounds = inBounds \n            && all(lessThan(where + tile.coordinates[i], boardSize))\n            && all(lessThan(ivec2(0), where + tile.coordinates[i]));\n    }\n    return all(equal(presentState, ivec4(0))) && inBounds;\n}\n\nfloat spawnTile(ivec2 index, ivec2 where, float oldState, Tile tile)\n{\n    for(int i=0; i<4; ++i)\n        if(all(equal(index, where + tile.coordinates[i]))) \n            return float(tile.tileType);\n            \n    return oldState;\n}\n\nfloat eraseTile(ivec2 index, ivec2 where, float oldState, Tile tile)\n{\n    for(int i=0; i<4; ++i)\n        if(all(equal(index, where + tile.coordinates[i])))\n            return 0.;\n            \n    return oldState;\n}\n\nbool canMoveTile(ivec2 where, Tile tile)\n{\n    // true if new tile only overlaps old tile or empty fields - and does not leave the board; \n    ivec4 presentState;\n    bool inBounds = true,\n        otherTilesDoNotOverlap = true;\n    for(int i=0; i<4; ++i)\n    {\n        ivec2 delta = tile.coordinates[i] + ivec2(0,-1);\n        otherTilesDoNotOverlap = otherTilesDoNotOverlap\n            && (currentState(where + delta) == 0 || isInTile(delta, tile));\n        inBounds = inBounds \n            && all(lessThan(where + tile.coordinates[i], boardSize))\n            && all(lessThan(ivec2(0), where + tile.coordinates[i]));\n    }\n    return otherTilesDoNotOverlap && inBounds;\n}\n\nfloat moveTile(ivec2 index, ivec2 where, float oldState, Tile tile)\n{\n    float newState = eraseTile(index, where, oldState, tile);\n    newState = spawnTile(index, where + ivec2(0,-1), newState, tile);\n    return newState;\n}\n\nstruct Profile\n{\n    ivec4 xValues;\n    ivec3 differences;\n    int nDifferences;\n};\n\nbool areProfilesCompatible(Profile p1, Profile p2)\n{\n    if(p1.nDifferences != p2.nDifferences) return false;\n    for(int i=0; i<p1.nDifferences + 1; ++i)\n        if(p1.xValues[i] != p2.xValues[i]) return false;\n    for(int i=0; i<p1.nDifferences; ++i)\n        if(p1.differences[i] != p2.differences[i]) return false;\n    return true;\n}\n\n// Note: this reads only the last state, without the current tile!\n// Note: xValues *must* be sorted in ascending order!\nProfile stackProfile(ivec4 xValues, int nXValues)\n{\n    Profile profile;\n    \n    ivec4 yValues;\n    for(int i=0; i<nXValues; ++i)\n        yValues[i] = currentState(ivec2(xValues[i], boardSize.y + 1));\n        \n    profile.nDifferences = nXValues - 1;\n    profile.xValues = xValues;\n    //profile.yValues = yValues; // TODO: remove\n    for(int i=0; i<nXValues-1; ++i)\n        profile.differences[i] = yValues[i+1]-yValues[i];\n    \n    return profile;\n}\n\n// Bubble-sort the coordinates. That's slow, but we only have 4 coordinates.\nivec2[4] sorted(ivec2 list[4])\n{\n    ivec2 buf;\n    for(int k=1; k < 4; ++k)\n        for(int b = 0; b < 4-k; ++b)\n            if(list[b].x > list[b+1].x) \n            {\n                buf = list[b+1];\n                list[b+1] = list[b];\n                list[b] = buf;\n            }\n    return list;\n}\n\nProfile tileProfile(ivec2 where, Tile tile)\n{\n    Profile profile;\n    \n    for(int i=0; i<4; ++i)\n        tile.coordinates[i] += where;\n    ivec2[4] sortedCoordinates = sorted(tile.coordinates);\n    \n    // Make an array with the minimum y value for each (increasingly sorted) x value\n    ivec4 sortedUniqueYCoordinates,\n        sortedUniqueXCoordinates;\n    int lastX = sortedCoordinates[0].x,\n        minY = sortedCoordinates[0].y,\n        nX = 0;\n    for(int i=1; i<4; ++i)\n    {\n        if(lastX != sortedCoordinates[i].x)\n        {\n            ++nX;\n            sortedUniqueYCoordinates[nX-1] = minY;\n            sortedUniqueXCoordinates[nX-1] = lastX;\n            \n            lastX = sortedCoordinates[i].x;\n            minY = sortedCoordinates[i].y;\n        }\n        else minY = min(minY, sortedCoordinates[i].y);\n    }\n    ++nX;\n    sortedUniqueYCoordinates[nX-1] = minY;\n    sortedUniqueXCoordinates[nX-1] = lastX;\n    \n    // Fill profile with difference values\n    profile.nDifferences = nX - 1;\n    profile.xValues = sortedUniqueXCoordinates;\n    for(int i=0; i<nX-1; ++i)\n        profile.differences[i] = sortedUniqueYCoordinates[i+1] - sortedUniqueYCoordinates[i];\n    \n    return profile;\n}\n\nbool doesTileFit(ivec2 where, Tile tile)\n{\n    Profile tp = tileProfile(where, tile);\n    return areProfilesCompatible(stackProfile(tp.xValues, tp.nDifferences + 1), tp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        // Initialize state here.\n        fragColor.r = 0.;\n    }\n    else\n    {\n        ivec2 index = ivec2(fragCoord);\n        float lastStepTime = currentStateF(ivec2(0,boardSize.y)),\n            state = currentStateF(index);\n\n        // Handle time step advancing\n        if(iTime >= lastStepTime + stepTimeDelta)\n        {\n            // Check if last step did move anything; if no: Spawn a tile. If yes: move.\n            bool didAnythingMoveLastStep = bool(currentState(ivec2(1,boardSize.y))),\n                didAnythingMoveThisStep = false;\n            Tile currentTile;\n            ivec2 currentTilePosition;\n            \n            // Deserialize\n            currentTile.tileType = currentState(ivec2(2, boardSize.y));\n\n            currentTile.pivot.x = currentState(ivec2(3, boardSize.y));\n            currentTile.pivot.y = currentState(ivec2(4, boardSize.y));\n                \n            currentTile.coordinates[0].x = currentState(ivec2(5, boardSize.y));\n            currentTile.coordinates[0].y = currentState(ivec2(6, boardSize.y));\n            currentTile.coordinates[1].x = currentState(ivec2(7, boardSize.y));\n            currentTile.coordinates[1].y = currentState(ivec2(8, boardSize.y));\n            currentTile.coordinates[2].x = currentState(ivec2(9, boardSize.y));\n            currentTile.coordinates[2].y = currentState(ivec2(10, boardSize.y));\n            currentTile.coordinates[3].x = currentState(ivec2(11, boardSize.y));\n            currentTile.coordinates[3].y = currentState(ivec2(12, boardSize.y));\n                \n            currentTilePosition.x = currentState(ivec2(13, boardSize.y));\n            currentTilePosition.y = currentState(ivec2(14, boardSize.y));\n            \n            // Iterate\n            if(!didAnythingMoveLastStep)\n            {\n#if PACKED\n                ivec2 where = ivec2(1,currentState(ivec2(1,boardSize.y+1)));\n                for(int i=2; i<boardSize.x; ++i)\n                {\n                    int y = currentState(ivec2(i, boardSize.y+1));\n                    if(y < where.y)\n                    {\n                        where.y = y;\n                        where.x = i;\n                    }\n                }\n                where.y = boardSize.y - 3;\n#else\n                ivec2 where = ivec2(floor(vec2(boardSize)*vec2(hash12(lastStepTime*c.xx+.1),1.)))-ivec2(0,3);\n#endif\n                \n                // make the spawned tile fit!\n                int nAvailableTiles = NTILES;\n                for(int i=0; i<NTILES; ++i)\n                {\n                    if(doesTileFit(where, tiles[i]))\n                    {\n                        if(hash12(lastStepTime*c.xx+float(i)/float(NTILES)) < weights[i]/float(nAvailableTiles))\n                        {\n                            if(canSpawn(where, tiles[i]))\n                            {\n                                didAnythingMoveThisStep = true;\n                                state = spawnTile(index, where, state, tiles[i]);\n\n                                // Reset current tile related state\n                                currentTile = tiles[i];\n                                currentTilePosition = where;\n                                break;\n                            }\n                        }\n                    }\n                    --nAvailableTiles;\n                }\n            }\n            else\n            {\n                if(canMoveTile(currentTilePosition, currentTile))\n                {\n                    state = moveTile(index, currentTilePosition, state, currentTile);\n                    currentTilePosition += ivec2(0,-1);\n                    didAnythingMoveThisStep = true;\n                    \n                    if(!canMoveTile(currentTilePosition, currentTile))\n                    {\n                        // Update heightmap here\n                        for(int i=0; i<4; ++i)\n                        {\n                            ivec2 currentDataCoordinates = ivec2(currentTilePosition.x+currentTile.coordinates[i].x, boardSize.y + 1),\n                                currentBlockCoordinates = currentTilePosition + currentTile.coordinates[i];\n                            state = setStateF(index, currentDataCoordinates, state, max(float(readStateF(index, currentDataCoordinates, state)), float(currentBlockCoordinates.y + 1)));\n                        }\n                    }\n                }\n            }\n            \n            // Serialize\n            state = setStateF(index, ivec2(0, boardSize.y), state, iTime);\n            \n            state = setStateF(index, ivec2(1, boardSize.y), state, float(didAnythingMoveThisStep));\n            \n            state = setStateF(index, ivec2(2, boardSize.y), state, float(currentTile.tileType));\n                \n            state = setStateF(index, ivec2(3, boardSize.y), state, float(currentTile.pivot.x));\n            state = setStateF(index, ivec2(4, boardSize.y), state, float(currentTile.pivot.y));\n                \n            state = setStateF(index, ivec2(5, boardSize.y), state, float(currentTile.coordinates[0].x));\n            state = setStateF(index, ivec2(6, boardSize.y), state, float(currentTile.coordinates[0].y));\n            state = setStateF(index, ivec2(7, boardSize.y), state, float(currentTile.coordinates[1].x));\n            state = setStateF(index, ivec2(8, boardSize.y), state, float(currentTile.coordinates[1].y));\n            state = setStateF(index, ivec2(9, boardSize.y), state, float(currentTile.coordinates[2].x));\n            state = setStateF(index, ivec2(10, boardSize.y), state, float(currentTile.coordinates[2].y));\n            state = setStateF(index, ivec2(11, boardSize.y), state, float(currentTile.coordinates[3].x));\n            state = setStateF(index, ivec2(12, boardSize.y), state, float(currentTile.coordinates[3].y));\n                \n            state = setStateF(index, ivec2(13, boardSize.y), state, float(currentTilePosition.x));\n            state = setStateF(index, ivec2(14, boardSize.y), state, float(currentTilePosition.y));\n        }\n        \n        fragColor.r = state;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n * Tetris Effect\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \n#define DRAW_3D\n// If PACKED is 1, the holes in the original effect will be avoided (costly).\n#define PACKED 0 \n\nconst vec3 c = vec3(1.,0.,-1.);\nconst ivec2 boardSize = ivec2(16,16)*2;\nconst float stepTimeDelta = 0.;\nconst bool depthBlur = false;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n * Tetris Effect\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \n// Draw the state.\n\nint currentState(ivec2 index)\n{\n    return int(round(texelFetch(iChannel0, index, 0).r));\n}\n\nfloat currentStateF(ivec2 index)\n{\n    return texelFetch(iChannel0, index, 0).r;\n}\n\nfloat dbox(vec2 x, vec2 b)\n{\n    vec2 da = abs(x)-b;\n    return length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\n// to, ti, ts, tz, tl, tj, tt,\nvec3 palette(float scale)\n{\n    const int N = 8;\n    vec3 colors[N] = vec3[N](\n        .7*c.xxx,\n        vec3(0.80,0.04,0.06), // to\n        vec3(0.35,0.69,0.74), // ti\n        vec3(0.54,0.25,0.53), // ts\n        vec3(0.85,0.52,0.00), // tz\n        vec3(0.21,0.60,0.19), // tl\n        vec3(0.08,0.40,0.65), // tj\n        vec3(0.92,0.84,0.00)  // tt\n    );\n    float i = mod(floor(scale), float(N)),\n        ip1 = mod(i + 1., float(N));\n    return mix(colors[int(i)], colors[int(ip1)], fract(scale));\n}\n\n#ifdef DRAW_3D\n\nconst float pi = 3.14159;\nconst vec2 blockSize = vec2(.9)/vec2(boardSize);\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  vec3 da = abs(x) - b;\n  return length(max(da,0.0))\n         + min(max(da.x,max(da.y,da.z)),0.0);\n}\n\n// Scene marching information\nstruct SceneData\n{\n    float\n\n        // Material for palette\n        material,\n    \n        // Distance\n        dist,\n    \n        // Light accumulation for clouds\n        accumulation,\n    \n        // Reflectivity\n        reflectivity,\n    \n        // Transmittivity\n        transmittivity,\n    \n        // Illumination\n        specular,\n    \n        // Diffuse\n        diffuse;\n};\n\nSceneData add(SceneData a, SceneData b)\n{\n    if(a.dist < b.dist) return a;\n    return b;\n}\n\nSceneData scene(vec3 x)\n{\n    vec2 y = mod(x.xy, blockSize)-.5*blockSize,\n        xij = (x.xy-y)/blockSize + vec2(boardSize / 2);\n    int state = currentState(ivec2(xij));\n    \n    SceneData sdf = SceneData(0., x.z+.5*blockSize.x-.001*sm(dbox(y, .3*blockSize)-.15*blockSize.x), 0., .3, 0., .7, 1.);\n    \n    if(\n        all(lessThan(xij, vec2(boardSize)))\n        && all(lessThan(c.yy, xij))\n        && state != 0\n    )\n        sdf = add(sdf, SceneData(float(state), dbox3(vec3(y,x.z), .3*blockSize.xyx)-.15*blockSize.x, 0., .7, 0., .7, 1.));\n\n    return sdf;\n}\n\nvec3 normal(vec3 x)\n{\n    float s = scene(x).dist,\n        dx = 5.e-5;\n    return normalize(vec3(\n        scene(x+dx*c.xyy).dist, \n        scene(x+dx*c.yxy).dist, \n        scene(x+dx*c.yyx).dist\n    )-s);\n}\n\nbool ray(inout vec3 col, out vec3 x, inout float d, vec3 dir, out SceneData s, vec3 o, vec3 l, out vec3 n)\n{\n    for(int i=0-min(iFrame, 0); i<250+min(iFrame,0); ++i)\n    {\n        x = o + d * dir;\n        s = scene(x);\n        \n        if(x.z > 5.1*blockSize.x) break;\n        \n        if(s.dist < 1.e-4)\n        {\n            // Blinn-Phong Illumination\n            n = normal(x);\n            if(s.material == 0.)\n                col = .4*c.xxx;\n            else\n                col = 1.5*palette(s.material);\n\n            col = .2 * col\n                + s.diffuse * col*max(dot(normalize(l-x),n),0.)\n                + s.specular * col*pow(max(dot(reflect(normalize(l-x),n),dir),0.),2.);\n                \n            return true;\n        }\n        \n        d += s.dist<1.e-1?min(s.dist,1.e-3):min(s.dist,1.e-2);\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Marching tools\n    float d = 0.,\n        d1;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 o = c.yzx,\n        col = c.yyy,\n        c1 = c.yyy,\n        x,\n        x1,\n        n,\n        n1,\n        r = c.xyy,\n        t = c.yyy,\n        dir = normalize(uv.x * r + uv.y * cross(r,normalize(t-o))-o),\n        l = c.zzx-.5*c.yyx;\n    SceneData s, \n        s1;\n\n    d = -(o.z-.5*blockSize.x)/dir.z;\n    x = o + d * dir;\n        \n    // Material ray\n    if(ray(col, x, d, dir, s, o, l, n))\n    {\n        //for(int i=0; i<1; ++i)\n        {\n        // Reflections\n        d1 = 2.e-3;\n        if(ray(c1, x1, d1, reflect(dir,n), s1, x, l, n1))\n            col = mix(col, c1, s.reflectivity);\n        \n        if(s.transmittivity > 0.)\n        {\n            // Refractions\n            d1 = 2.e-3;\n            if(ray(c1, x1, d1, refract(dir,n, .99), s1, x, l, n1))\n                col = mix(col, c1, s.transmittivity);\n            }\n        }\n        \n        // Hard Shadow\n        d1 = 1.e-2;\n        if(ray(c1, x1, d1, normalize(l-x), s1, x, l, n1))\n        {\n            if(length(l-x1) < length(l-x))\n                col *= .5;\n        }\n    }\n\n    fragColor = mix(texture(iChannel1, fragCoord.xy/iResolution.xy), vec4(clamp(col,0.,1.),1.), .5);\n}\n\n#else\nconst vec2 blockSize = vec2(.8)/vec2(boardSize);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = c.xxxx;\n    \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y,\n        x = mod(uv, blockSize)-.5*blockSize,\n        xij = (uv-x)/blockSize + vec2(boardSize / 2);\n    \n    if(all(lessThan(xij, vec2(boardSize))) && all(lessThan(c.yy, xij)))\n    {\n        fragColor = mix(fragColor, vec4(palette(float(currentState(ivec2(xij)))), 1.), sm(dbox(x, .5*blockSize)));\n    }\n}\n\n#endif\n\n","name":"Buffer B","description":"","type":"buffer"}]}