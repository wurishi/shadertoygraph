{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Simple Ray marcher over distance field. \n// To be improved on the BTEs and the approximations quality.\n// I am mainly using tools originally written by Inigo Quilez.\n// See his articles at : https://iquilezles.org/www/index.htm\n\n#define RM_USE_ABSORPTION\n#define RM_USE_SCATTERING\n\n// Will requires : \nvec2 sceneMap(vec3 p);\nvec4 renderMaterial(vec3 pos, vec3 dir, vec3 normal, float material, float d, float absorption, float scattering);\n\n// Can require : \n#ifdef RM_USE_ABSORPTION\nfloat absorption(vec3 p, vec3 dir, float d);\n#endif\n\n#ifdef RM_USE_SCATTERING\nfloat scattering(vec3 p, vec3 dir, float d);\n#endif\n\n// Primitives :\nfloat plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sphere(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    return max(length(vec2(length(p.xz)-t.x,p.y))-t.y, 0.0);\n}\n\nfloat length4(vec2 p)\n{\n    p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/4.0 );\n}\n\nfloat torus42(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length4(q)-t.y;\n}\n\n// Operators :\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opSubstraction(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n// Core functions for the RayMarcher : \nfloat sceneMapSimple(vec3 p)\n{\n    vec2 tmp = sceneMap(p);\n    return tmp.x;\n}\n\nmat3 computeCameraMatrix(in vec3 p, in vec3 target, float roll)\n{\n    vec3 \tvForward = normalize(target-p),\n        \tvUpAlign = vec3(sin(roll), cos(roll), 0.0),\n        \tvLeftReal = normalize(cross(vForward, vUpAlign)),\n        \tvUpReal = normalize(cross(vLeftReal, vForward));\n    return mat3(vLeftReal, vUpReal, vForward);\n}\n\nvec4 castRay(in vec3 rayOrigin, in vec3 rayDirection, const float dMin, const float dNear, const float dMax)\n{\n    const int numSteps = 128;\n    float d = dMin;\n    float m = -1.0;\n    float a = 0.0, s = 0.0;\n    for(int i=0; i<numSteps; i++)\n    {\n        vec3 p = rayOrigin+rayDirection*d;\n        vec2 res = sceneMap(p);\n        if(res.x<dNear || d>dMax)\n            break;\n        d += res.x;\n        m = res.y;\n        #ifdef RM_USE_ABSORPTION\n        a += absorption(p, rayDirection, res.x);\n        #endif\n        #ifdef RM_USE_SCATTERING\n        s += scattering(p, rayDirection, res.x);\n        #endif\n    }\n    if(d>dMax)\n        m = -1.0;\n    return vec4(d, m, a, s);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    const vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\tsceneMap(pos+eps.xyy).x - sceneMap(pos-eps.xyy).x,\n                  \tsceneMap(pos+eps.yxy).x - sceneMap(pos-eps.yxy).x,\n                  \tsceneMap(pos+eps.yyx).x - sceneMap(pos-eps.yyx).x );\n    return normalize(n);\n}\n\nvec4 renderScene(const ivec2 formatSize, vec3 eyePos, vec3 eyeTarget, const float focalLength, const float dMin, const float dNear, const float dMax)\n{\n    mat3 camera = computeCameraMatrix(eyePos, eyeTarget, 0.0);\n    vec2 o = (gl_FragCoord.xy - vec2(formatSize)/2.0)/max(float(formatSize.x),float(formatSize.y));\n    vec3 rayOrigin = vec3(o, 0.0) + eyePos,\n        rayDirection = normalize(camera*vec3(o, focalLength));\n    vec4 res = castRay(rayOrigin, rayDirection, dMin, dNear, dMax);\n    vec3 p = rayOrigin + rayDirection * res.x;\n    vec3 n = calcNormal(p);\n    return renderMaterial(p, rayDirection, n, res.y, res.x, res.z, res.w);\n}\n\n// Other tools : \nfloat softShadow(vec3 rayOrigin, vec3 lightPos, float dNearLight, float kShadowSoftness)\n{\n    const int maxStep = 128;\n    const float dNearIntersect = 0.0000001;\n    vec3 rayDirection = lightPos - rayOrigin;\n    float dMax = length(rayDirection) - dNearLight;\n    rayDirection = normalize(rayDirection);\n    float res = 1.0;\n    float d=0.0;\n    for(int k=0; k<maxStep; k++)\n    {\n        float closest = sceneMapSimple(rayOrigin + rayDirection*d);\n        if(closest<dNearIntersect)\n            return 0.0;\n        res = min(res, kShadowSoftness*closest/d);\n        d += closest;\n        if(d>=dMax)\n            break;\n    }\n    return res;\n}\n\n// Scene settings :\nconst vec3 \teyeTarget = vec3(0, 1.4, 5),\n    \t\tobjectCenter = vec3(0,1.8,5.0);\nconst float focalLength = 0.5;\nconst vec3 \tlightPos = vec3(2.8, 3, 4.3),\n            lightDir = vec3(-2.0, -0.5, 0.7),\n        \tlightCol = vec3(1, 1, 1.5);\nconst float lightSpan = 0.7, // cosine\n    \t\tlightRadiance = 15.0,\n    \t\tthetaRing2 = 0.2,\n    \t\tthetaRing3 = 0.4;\nmat3 rotMat2, rotMat3;\n\nfloat test(vec3 p)\n{\n    return length(max(abs(p-vec3(0,0,5))-0.5,0.0));\n}\n\nvec2 sceneMap(in vec3 p)\n{\n    return\topUnion( vec2(plane(p), 1), \n            opUnion( vec2(sphere(p-lightPos, 0.01), 1024),\n            opUnion( vec2(sphere(p-objectCenter, 0.5), 2),\n            opUnion( vec2(torus42(p-objectCenter, vec2(1.0, 0.1)), 3),\n            opUnion( vec2(torus42(rotMat2*(p-objectCenter), vec2(1.3, 0.1)), 4),\n                     vec2(torus42(rotMat3*(p-objectCenter), vec2(1.6, 0.1)), 5)\n                     )))));\n}\n\n\nfloat absorption(vec3 p, vec3 dir, float d)\n{\n    return d*exp(-p.y*5.0)/2.0;\n}\n\nfloat scattering(vec3 p, vec3 dir, float d)\n{\n    vec3 u = normalize(p - lightPos);\n    float dLight = distance(p, lightPos);\n    return  d*0.2*exp(-p.y*0.1)/(dLight*dLight) * (max(dot(u, normalize(lightDir)), lightSpan)-lightSpan)/(1.0-lightSpan);\n}\n\nvec4 renderMaterial(vec3 p, vec3 dir, vec3 normal, float material, float dist, float absorption, float scattering)\n{\n    vec4 col = vec4(0, 0, 0, 1);\n\n    if(material>0.0) // Valid object intersection\n    {\n        if(material<=1.0) //floor\n            col = mod(floor(5.0*p.z) + floor(5.0*p.x), 2.0)*vec4(0.3,0.3,0.3,0)+vec4(0.3,0.3,0.3,1);\n        else // other\n            col = vec4(material/5.0,1.0-material/5.0, material*material/25.0-p.y/3.0, 1.0);\n\n        // Simple shading :\n        vec3 u = p - lightPos;\n        float l = length(u);\n        u = u/l;\n        float s = max(dot(-dir, normal), 0.0) * max(dot(-u, normal),0.0) * max((max(dot(u, normalize(lightDir)), lightSpan)-lightSpan)/(1.0-lightSpan), 0.0) / max(l*l, 1.0) * lightRadiance;\n        col = col * max(s,0.0001) * vec4(lightCol,1);\n\n        // Light source : \n        col = (material>=1024.0) ? vec4(1,1,1,1) : col;\n    }\n\n    col.rgb = col.rgb * softShadow(p, lightPos, 1.0, 32.0) * max(1.0 - absorption,0.0) + scattering * lightRadiance * lightCol/max(1.0,dist*dist);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup the animation of the scene :\n\trotMat2 = mat3( 1, 0, 0,\n                    0, cos(thetaRing2*iTime), sin(thetaRing2*iTime),\n                    0, -sin(thetaRing2*iTime), cos(thetaRing2*iTime));\n\n\trotMat3 = mat3(\tcos(thetaRing3*iTime), sin(thetaRing3*iTime), 0,\n                    -sin(thetaRing3*iTime), cos(thetaRing3*iTime), 0,\n                     0, 0, 1);\n    vec3 eyePos = eyeTarget + vec3(4.0*cos(0.1*iTime), 1.5, 4.0*sin(0.1*iTime));\n    \n    // Render :\n    vec4 c = renderScene(ivec2(iResolution.xy), eyePos, eyeTarget, focalLength, 0.5, 0.001, 100.0);\n    fragColor = vec4(pow(c.rgb, vec3(1, 1, 1)/2.2), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mls3D2","date":"1425435780","viewed":818,"name":"PseudoArmillaryTest","username":"RK","description":"A simple test on the ray marching concepts.\nI am mainly using tools originally written by Inigo Quilez.\nEdits :\n- Radiometric correction (the usual cos(-rayDirection, surfaceNormal) was missing).","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","softshadows","armillary"],"hasliked":0,"parentid":"","parentname":""}}