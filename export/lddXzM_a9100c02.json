{"ver":"0.1","info":{"id":"lddXzM","date":"1458489171","viewed":3035,"name":"Shadertext","username":"Andre","description":"Distance field font, made by hand.","likes":59,"published":1,"flags":48,"usePreview":0,"tags":["text","distance","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define line1 h_ e_ l_ l_ o_ _ s_ h_ a_ d_ e_ r_ t_ o_ y_ crlf\n#define line2 t_ h_ i_ s_ _ i_ s_ _ m_ y_ _ f_ o_ n_ t_ crlf\n#define line3 h_ o_ p_ e_ _ y_ o_ u_ _ l_ i_ k_ e_ _ i_ t_ crlf\n#define line4 f_ e_ e_ l_ _ f_ r_ e_ e_ _ t_ o_ _ u_ s_ e_ crlf\n#define line5 _ a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ crlf\n#define line6 _ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\nfloat pz_scale;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= pz_scale = position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    \n    return fragCoord;\n}\n//======End shared code for state\n\n// line function, used in k, s, v, w, x, y, z\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv,float w,float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4))) +.4;\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)))+.4;\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    float t = _u(uv,.25,-.15);\n    float x = uv.x>0.?t:length(vec2(uv.x,uv.y+.8))+.4;\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)))+.4;\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25)+.4;\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2)+.4;\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2)))+.4);\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:length(vec2(uv.x-.22734,uv.y-.254))+.4;\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254))+.4,\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05))+.4);\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y))+.4);\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||uv.y<-.65?_u(uv,0.25,-0.2):length(vec2(uv.x+0.25,uv.y+.65))+.4 );\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.7))+.4);\n}\nfloat jj(vec2 uv) {\n    uv.x += .05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.7))+.4);\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4))+.4;\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4))+.4);\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254))+.4;\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    \n    if (uv.y <.145 && uv.x>0. || uv.y<-.145)\n        uv = -uv;\n    \n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?\n                abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2)+.4:\n                length(vec2(uv.x-.231505,uv.y-.284))+.4;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y))+.4);\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4))+.4;\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4))+.4,\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1))+.4);\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4))+.4;\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4))+.4,\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8))+.4);\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4))+.4;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4))+.4;\n    return min(x,l);\n}\n\n// Spare Q :)\nfloat Q(vec2 uv) {\n    \n    float x = _o(uv);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.) +.4);\n}\n\n//Render char if it's up\n#define ch(l) if (nr++==ofs) x=min(x,l(uv));\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n\n//Space\n#define _ nr++;\n\n//Next line\n#define crlf uv.y += 2.0; nr = 0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = pz_initializeState(fragCoord);\n    \n    float scale = 1.0;//3.5-3.0*sin(iTime*.2);\n\tvec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    \n    float ofs = floor(uv.x)+8.;\n    uv.x = mod(uv.x,1.0)-.5;\n    \n    float x = 100.;\n    float nr = 0.;\n    uv.y -= 5.;\n \n    line1;\n    line2;\n    line3;\n    line4;\n    line5;\n    line6;\n        \n\tvec3 clr = vec3(0.0);\n    \n    float px = 17.0/iResolution.x*pz_scale;\n    \n    clr.r = 0.7-0.7*smoothstep(0.49-px,0.49+px, x); // The body\n    clr.g = 0.7-0.7*smoothstep(0.00,px*1.5, abs(x-0.49+px)); // Yellow outline\n    clr.b = 0.4-0.4*smoothstep(0.43,0.53,1.0-x); // Background with shadow\n    clr.rg += 0.12-0.12*smoothstep(0.00,0.1+px, abs(x-0.49+px)); // Yellow glow\n    \n    if (iMouse.z>0.0) {\n        clr.rgb = vec3(smoothstep(0.49-px,0.49+px, x)); \n    }\n    \n    fragColor = vec4(clamp(clr,0.0,1.0),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n//======Defines for state behaviour\n#define pz_resetOnMove 1\n#define pz_kinetic 0.9\n\nbool pz_checkCell(float nr, vec2 coord) {\n    return distance(pz_nr2vec(nr),coord)<=0.5;\n}\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\nconst float KEY_ADD   = 107.5/256.0;\nconst float KEY_SUBS  = 109.5/256.0;\nconst float KEY_EQUAL = 187.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\n\nbool checkKey(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.25)).x > 0.5;\n}\n\nbool checkKey(float key1, float key2)\n{\n    return checkKey(key1) || checkKey(key2);\n}\n\nbool checkKey(float key1, float key2, float key3)\n{\n    return checkKey(key1) || checkKey(key2) || checkKey(key3);\n}\n\nvoid pz_mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pz_initializeState();\n    fragColor = pz_stateSample(fragCoord/pz_realBufferResolution);\n    if (fragCoord.x < 1. \n     && fragCoord.y < 1.) {\n        //Lets store the initial buffersize at pos0 and use that for addressing\n        if (pz_originalBufferResolution.x == 0.0)\n            fragColor = vec4(pz_realBufferResolution,1.0,1.0);\n        \n    } else if (pz_checkCell(1.,fragCoord)) {\n        \n        // Use postion 1 to trigger screen size changes so we can clear other buffers on going fullscreen\n        if (distance(fragColor.xy,pz_realBufferResolution)>1.0 \n#if pz_resetOnMove            \n            || pz_readState(3.).w > 0.0\n#endif            \n           ) {\n            fragColor.xy = pz_realBufferResolution;\n            fragColor.z = 60.0;\n        } else {\n            if (fragColor.z > 0.0)\n                fragColor.z -= 1.0;\n        }\n        \n    } else if (pz_checkCell(2.,fragCoord)) {\n        // Store mouse delta if keydown\n        if (iMouse.w>0.5) {\n            if (fragColor.x>0.0) {\n                fragColor.zw = fragColor.xy - iMouse.xy;\n            } else {\n                fragColor.zw = vec2(0.0);\n            }\n            fragColor.xy = iMouse.xy;\n        } else {\n            \n            fragColor.xy = vec2(-1.,-1.);\n#ifdef pz_kinetic\n            fragColor.zw = length(fragColor.zw)>0.1?fragColor.zw*pz_kinetic:vec2(0.0,0.0);\n#else                             \n            fragColor.zw = vec2(0.0,0.0);\n#endif                             \n        }\n        \n    } else if (pz_checkCell(3.,fragCoord)) { \n        // Handle keyboard moves\n        vec2 delta = vec2( checkKey(KEY_LEFT ,KEY_A,KEY_Q)?-0.02:\n                           checkKey(KEY_RIGHT,KEY_D      )? 0.02:0.0\n                         , checkKey(KEY_DOWN ,KEY_S      )?-0.02:\n                           checkKey(KEY_UP   ,KEY_W,KEY_Z)? 0.02:0.0);\n        float factor = checkKey(KEY_SUBS, KEY_MINUS)?1.01:\n                       checkKey(KEY_ADD , KEY_EQUAL)?0.99:1.0;\n        if (fragColor.z<0.0000001)\n            fragColor.z = 1.0;\n        \n        //Update transform state\n        vec2 mouseDelta = pz_readState(2.).zw;\n        fragColor.z *= factor;\n        fragColor.xy += delta *  fragColor.z; //Add keyboard move\n        fragColor.xy += mouseDelta / iResolution.xy *  fragColor.z; //Add mouse delta\n        \n        //Store movement in w\n        fragColor.w = abs(factor-1.0)*3. + length(delta) + length(mouseDelta);\n                \n    } else\n        fragColor = vec4(0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pz_mainImage( fragColor, fragCoord );\n    \n    // Add multiple state handlers here\n}\n","name":"Buffer A","description":"","type":"buffer"}]}