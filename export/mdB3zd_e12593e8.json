{"ver":"0.1","info":{"id":"mdB3zd","date":"1670776891","viewed":58,"name":"ray_sphere","username":"madevgeny","description":"sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{vec3 o; vec3 d;};\nstruct Plane{vec3 n; vec3 p0; vec4 c;};\nstruct Sphere{vec3 p; float r; vec4 c;};\nstruct DirectionalLight{vec3 d; vec4 c;};\n\nconst float duv = 0.00001;\nconst int N_RAYS = 5;\n\nconst DirectionalLight dlight = DirectionalLight(vec3(0, -1.0, 0), vec4(1, 1, 1, 1));\nconst Sphere sphere = Sphere(vec3(0, 0, 0), 0.25, vec4(1, 0, 1, 1));\n\nvec2 get_coords(in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nvec4 get_background(in vec2 uv){\n   if(uv.x < 0.0 && uv.y > 0.0){\n       return vec4(0.5, 0.5, 0.5, 0.0);\n   }\n   \n   if(uv.x > 0.0 && uv.y < 0.0){\n       return vec4(0.5, 0.5, 0.5, 0.0);\n   }\n    \n   return vec4(1, 1, 1, 0);\n}\n\nRay[N_RAYS] get_initial_rays(in vec2 uv){\n    Ray r[N_RAYS];\n    vec3 o = vec3(0, 0, -1);\n    r[0] = Ray(o, normalize(vec3(uv.x, uv.y, 0) - o));\n    r[1] = Ray(o, normalize(vec3(uv.x + duv, uv.y + duv, 0) - o));\n    r[2] = Ray(o, normalize(vec3(uv.x - duv, uv.y - duv, 0) - o));\n    r[3] = Ray(o, normalize(vec3(uv.x + duv, uv.y - duv, 0) - o));\n    r[4] = Ray(o, normalize(vec3(uv.x - duv, uv.y + duv, 0) - o));\n    return r;\n}\n\nfloat ray_plane_intersect(in Ray r, in Plane plane){\n    float f = clamp(dot(r.d, plane.n), 0.0, 1.0) * 10.0;\n    return f;\n}\n\nfloat ray_sphere_intersect(out vec3 ip, out vec3 n, in Ray r, in Sphere sphere){\n    vec3 o = r.o - sphere.p;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(o, r.d);\n    float c = dot(o, o) - sphere.r * sphere.r;\n    \n    float det = b * b - 4.0 * a * c;\n    if(det < 0.0){\n        return -1.0;\n    }\n    \n    float t = (-b - sqrt(det)) / (2.0 * a);\n    ip = r.o + r.d * t; \n    \n    n = normalize(sphere.p - ip );\n    \n    return t;\n    \n}\n\nvec3 calc_light_color(in vec3 p, in vec3 n, in DirectionalLight light){\n\n    float t = dot(n, light.d);\n    if(t < 0.0){\n        return vec3(0);\n    }\n    \n    return t * light.c.rgb;\n}\n\nvec4 run(in Ray r, in Sphere sphere, in DirectionalLight light){\n    vec3 ip, n;\n    vec4 c = vec4(0);\n    float t = ray_sphere_intersect(ip, n, r, sphere);\n    if(t < 0.0){\n        return vec4(0);\n    }\n    \n    c = vec4(sphere.c.rgb * 0.4, 1);\n    \n    \n    vec3 lc = calc_light_color(ip, n, light);\n    c.rgb += lc;\n        \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = get_coords(fragCoord);\n    vec4 c = get_background(uv);\n    \n    Ray[N_RAYS] rays = get_initial_rays(uv);\n    \n    vec4 sc;\n    for(int i = 0; i < N_RAYS; i += 1){\n        sc += run(rays[i], sphere, dlight);\n    }\n    \n    sc /= float(N_RAYS);\n    \n    c = mix(c, sc, sc.a);\n    \n    fragColor = c;\n}","name":"Image","description":"","type":"image"}]}