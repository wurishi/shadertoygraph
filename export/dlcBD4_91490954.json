{"ver":"0.1","info":{"id":"dlcBD4","date":"1701465509","viewed":40,"name":"Garrett Laverty Final","username":"garrett155l","description":"Ray-Marching with SDF's\nSoft shadows\nambient occlusion\nanti-aliasing\nmotion-blur\ninfinite mirrors","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","motionblur","antialiasing","final"],"hasliked":0,"parentid":"dl3fRn","parentname":"Fork Mirror - T garrett155 461"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfragColor = texture(iChannel1, fragCoord.xy / iResolution.xy).rgba;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//======================================================================\n//                            WORLD OBJECTS\n//======================================================================\n\n// Sphere (p-pos)^2 = r^2\nstruct Sphere {\n  vec3 pos;\n  float r;\n};\n\n// implicit plane equation n*p-D=0\nstruct Plane {\n  vec3 n;\n  float D;\n};\nstruct Cylinder {\n    vec3 pos;\n    float h;\n    float r;\n};\nstruct Torus {\n    vec3 pos;\n    float r;\n    float thickness;\n};\n// A collection of all objects\nstruct World {\n    // Sphere subtracting from top of Rook\n    Sphere sphere;\n    Sphere sphere2;\n    Sphere sphere3;\n    Sphere sphere4;\n    \n    // Cylinders for Rook, 1 for body, two for top\n    Cylinder cylinder;\n    Cylinder cylinder2;\n    Cylinder cylinder3;\n    \n    // Torus's to make rings on Rook's body\n    Torus torus;\n    Torus torus1;\n    \n    // Scene Box\n    Plane plane;\n    Plane plane2;\n    Plane plane3;\n    Plane plane4;\n    Plane plane5;\n    Plane plane6;\n    \n    Cylinder cylinder02;\n    Cylinder cylinder22;\n    Cylinder cylinder32;\n    Torus torus02;\n    Torus torus12;\n    Sphere sphere02;\n    Sphere sphere22;\n    Sphere sphere32;\n    Sphere sphere42;\n    \n    \n};\n//======================================================================\n//                            CONSTANT VALUES\n//======================================================================\n\n// Constants for ambient and shadow strength\nfloat ambientDist = 0.35;\nfloat shadowConst = 22.;\n\nconst float pi = 3.14159265358;\n\n// Marching constants\nint maxMarchingSteps = 50;\nfloat minMarchRadius = 0.0015;\n\n// Lowering the number of reflections means you should increase the fallOff\n// Otherwise, you will see the original colors of the walls off in the distance\n//float reflectionCount = 40.;\n//float reflectionFallOff = 0.01;\n\n// I recommend using these reflection variables on laptops, use above values for desktop\nfloat reflectionCount = 8.;\nfloat reflectionFallOff = 0.058;\n\n// Determines the number of extra rays for anti-aliasing between 0. and 3.\n// For laptops 0. or 1. is recommended\n// For desktops 2. is recommended\nfloat antiAliasing = 1.;\n\n\n// Applying antiAliasing to reflections that are very far out is costly without\n// being very noticeable. This limits those reflections.\n// This should always be <= reflectionCount\nfloat antiAliasingReflections = 2.;\n\nWorld w;\n\n\n//======================================================================\n//                MARCHING FUNCTIONS FOR DRAWING OBJECTS\n//======================================================================\n\n// Distance from point to sphere surface:\n// Find the length from the point to the sphere center\n// Subtract the radius\n// Similar to what has been done in class\nfloat sdfSphere(vec3 position, Sphere s)\n{\n    return length(position-s.pos)-s.r;\n}\n\n// Distance from point to plane surface:\n// This one works because position is not a unit vector, this means the\n// result of the dot product will be the perpendicular distance from\n// the plane (assumed to be at (0, 0, 0)) to the point\n// To account for that assumption, add the plane's distance scalar\n// Similar to what has been done in class\nfloat sdfPlane(vec3 position, Plane p) {\n    return dot(p.n, position) + p.D;\n}\n\n// Distance from point to Torus surface\nfloat sdfTorus(vec3 position, Torus t)\n{\n    // Find the horizontal length to the center of the Torus\n    // Subtract the radius of the Torus to find the distance to the radius\n    float horizontalDistToRadius = length(position.xy - t.pos.xy) - t.r;\n    \n    // Now find the vertical length to Torus, just use the center since it is horizontal\n    float verticalDistToCenter = position.z - t.pos.z;\n    \n    // Now just use pythagorean theorem and subtract the thickness of the Torus\n    return sqrt(horizontalDistToRadius * horizontalDistToRadius +\n                verticalDistToCenter * verticalDistToCenter) - t.thickness;\n}\n\n// Distance from point to Cylinder surface\n// The following function is a slight modification from this source:\n// https://iquilezles.org/articles/distfunctions/\nfloat sdfCylinder(vec3 position, Cylinder c) \n{\n  vec2 d = abs(vec2(length(position.xy-c.pos.xy),position.z-c.pos.z)) - vec2(c.r,c.h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// By checking the minimum with a negative value, we can essentially use one\n// object to cut into another (since the negative allows us to go into an object)\n// This is similar to the resource below,\n// except mine allows the cut to be a different material.\n// https://www.shadertoy.com/view/NsjSR3\nvec2 mergeSubtract(vec2 d2, vec2 d1) {\n    return max(d1.x, -d2.x) == d1.x ?  d2 : vec2(-d1.x, d1.y);\n}\n\n// Merge two objects in a smooth manner based on a constant k\n// The following function is entirely from this source:\n// https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// This functions essentially checks a position against every object\n// in the scene and returns the smallest distance, and the id of that object\nvec2 distToNearestObj(vec3 position) {\n    // Set current result to default values\n    vec2 current = vec2(1000., -1);\n    \n    // Calculate distances to each object in scene\n    float planeDist = sdfPlane(position, w.plane);\n    float plane2Dist = sdfPlane(position, w.plane2);\n    float plane3Dist = sdfPlane(position, w.plane3);\n    float plane4Dist = sdfPlane(position, w.plane4);\n    float plane5Dist = sdfPlane(position, w.plane5);\n    float plane6Dist = sdfPlane(position, w.plane6);\n    \n    \n    \n    // This bound is used to avoid calculating the rook whenever we know it will be unnecessary\n    // The bound is large enough to ensure a negative result whenever we may want to render the rook\n    // Even though calculations are only skipped for a small portion of the rays, this can result in about\n    // a 10 fps increase when I tested the difference on my laptop\n    float cylBound = sdfCylinder(position, Cylinder(vec3(0.0, -0.4, 1.55), 1.55, 1.45)); \n    if(cylBound < 0.){\n        // Calculate distances to each object in scene\n        float sphereDist = sdfSphere(position, w.sphere);\n        float sphere2Dist = sdfSphere(position, w.sphere2);\n        float sphere3Dist = sdfSphere(position, w.sphere3);\n        float sphere4Dist = sdfSphere(position, w.sphere4);\n        float cylinderDist = sdfCylinder(position, w.cylinder);\n        float cylinder2Dist = sdfCylinder(position, w.cylinder2);\n        float cylinder3Dist = sdfCylinder(position, w.cylinder3);\n        float torusDist = sdfTorus(position, w.torus);\n        float torus1Dist = sdfTorus(position, w.torus1);\n        \n        // Calculate distances from equations between objects\n        float bottomOfRook = smin(torus1Dist, cylinderDist, 0.7);\n        vec2 topRingOfRook = mergeSubtract(vec2(smin(cylinder2Dist, cylinderDist, 0.33), 1.), vec2(cylinder3Dist, 1.));\n\n        vec2 topRingCut = mergeSubtract(topRingOfRook, vec2(sphere2Dist, 1.));\n        topRingCut = max(topRingCut, mergeSubtract(topRingOfRook, vec2(sphereDist, 1.)));\n        topRingCut = max(topRingCut, mergeSubtract(topRingOfRook, vec2(sphere3Dist, 1.)));\n        topRingCut = max(topRingCut, mergeSubtract(topRingOfRook, vec2(sphere4Dist, 1.)));\n\n\n        current = vec2(smin(torusDist, cylinderDist, 0.7), 1.);\n\n        if(bottomOfRook < current.x)\n            current = vec2(bottomOfRook, 1.);\n\n        if(topRingCut.x < current.x)\n            current = topRingCut;\n\n        float cylBoundMini = sdfCylinder(position, Cylinder(vec3(0.1, -0.4, 1.25), 0.5, 0.4));\n        if(cylBoundMini < 0.){\n            // Calculate distances to each object in scene\n            float sphere02Dist = sdfSphere(position, w.sphere02);\n            float sphere22Dist = sdfSphere(position, w.sphere22);\n            float sphere32Dist = sdfSphere(position, w.sphere32);\n            float sphere42Dist = sdfSphere(position, w.sphere42);\n            float cylinder02Dist = sdfCylinder(position, w.cylinder02);\n            float cylinder22Dist = sdfCylinder(position, w.cylinder22);\n            float cylinder32Dist = sdfCylinder(position, w.cylinder32);\n            float torus02Dist = sdfTorus(position, w.torus02);\n            float torus12Dist = sdfTorus(position, w.torus12);\n            \n            // Calculate distances from equations between objects\n            float bottomOfRook2 = smin(torus12Dist, cylinder02Dist, 0.7/5.);\n            vec2 topRingOfRook2 = mergeSubtract(vec2(smin(cylinder22Dist, cylinder02Dist, 0.33/5.), 1.),\n                                                vec2(cylinder32Dist, 1.));\n\n            vec2 topRingCut2 = mergeSubtract(topRingOfRook2, vec2(sphere22Dist, 1.));\n            topRingCut2 = max(topRingCut2, mergeSubtract(topRingOfRook2, vec2(sphere02Dist, 1.)));\n            topRingCut2 = max(topRingCut2, mergeSubtract(topRingOfRook2, vec2(sphere32Dist, 1.)));\n            topRingCut2 = max(topRingCut2, mergeSubtract(topRingOfRook2, vec2(sphere42Dist, 1.)));\n\n\n            if(smin(torus02Dist, cylinder02Dist, 0.7/5.) < current.x)\n                current = vec2(smin(torus02Dist, cylinder02Dist, 0.7/5.),1.);\n\n            if(bottomOfRook2 < current.x)\n                current = vec2(bottomOfRook2, 1.);\n\n            if(topRingCut2.x < current.x)\n                current = topRingCut2;\n\n        }\n    }\n    \n    // Render all the walls (each has a different material for different colors)\n    if(planeDist < current.x) current = vec2(planeDist, 2);\n    if(plane2Dist < current.x) current = vec2(plane2Dist, 3);\n    if(plane3Dist < current.x) current = vec2(plane3Dist, 4);\n    if(plane4Dist < current.x) current = vec2(plane4Dist, 5);\n    if(plane5Dist < current.x) current = vec2(plane5Dist, 6);\n    if(plane6Dist < current.x) current = vec2(plane6Dist, 7);\n    \n    return current;\n}\n\n// The main ray-marching function\n// The idea for how this function operates is based off of this source:\n// https://www.cl.cam.ac.uk/teaching/1819/FGraphics/1.%20Ray%20Marching%20and%20Signed%20Distance%20Fields.pdf\nvec2 march(vec3 ro, vec3 rd) {\n    float dist = 0.005;\n    vec2 stepInfo;\n    // Loop to continually march forward a set number of times\n    for(int i = 0; i < maxMarchingSteps; i++) {\n        // Get the distance to the nearest object and its id number\n        stepInfo = distToNearestObj(ro + rd * dist);\n        dist += stepInfo.x; // Add the distance of this step to our overall distance traveled\n        \n        if(stepInfo.x <= minMarchRadius) // If we have hit an object, return the gathered info\n            return vec2(dist, stepInfo.y);\n    }\n    return vec2(dist, stepInfo.y); // Exceeded max steps, return closest info\n}\n\n//======================================================================\n//                      LIGHTING AND RENDERING\n//======================================================================\n\n// This entire function is based on this source:\n// https://iquilezles.org/articles/normalsSDF/\nvec3 findNormal(in vec3 position) {\n    vec2 epsilon = vec2(0.001, 0.0);\n    return normalize(vec3(\n          distToNearestObj(position + epsilon.xyy).x - distToNearestObj(position - epsilon.xyy).x,\n          distToNearestObj(position + epsilon.yxy).x - distToNearestObj(position - epsilon.yxy).x,\n          distToNearestObj(position + epsilon.yyx).x - distToNearestObj(position - epsilon.yyx).x));\n}\n\n// From Assignment 2\nvec3 checkerTex(vec2 coord) { \n   float total = floor(coord.x) + floor(coord.y);\n   bool isEven = mod(total, 2.0) == 0.0;\n   return (mod(total, 2.0) == 0.0)?vec3(1.):vec3(0.); \n}\n\n// Calculate shadow constant\n// Based off of the following source:\n// https://www.cl.cam.ac.uk/teaching/1819/FGraphics/1.%20Ray%20Marching%20and%20Signed%20Distance%20Fields.pdf\nfloat shadowMarch(vec3 ro, vec3 rd, float distToLight) {\n    float dist = 0.005;\n    float finalShadow = 1.;\n    // March until we have made it to the light\n    while(dist < distToLight) {\n        // Get the distance to the nearest object\n        float stepDist = distToNearestObj(ro + rd * dist).x;\n        dist += stepDist; // Add the distance of this step to our overall distance traveled\n        \n        if(stepDist <= minMarchRadius) // If we have hit an object, 100% shadow\n            return 0.;\n            \n        // The shadow will be proportionate to however close the ray was to hitting an object\n        // It will also have a stronger affect the closer the object casting the shadow is\n        float stepShadow = shadowConst * stepDist / dist;\n        \n        // We always want the darkest shadow found along the path\n        if(stepShadow < finalShadow)\n            finalShadow = stepShadow;\n    }\n    return finalShadow;\n}\n\n// Determines ambient factor by using one check for nearest object\n// Use that distance and subtract ambientDist from it. Add 1.075 so it doesn't get too dark\n// Clamp to 1. so that it only makes things darker\nfloat ambient(vec3 point, vec3 norm) {\n    float checkRadius = 0.3;\n    float dist = distToNearestObj(point + norm * ambientDist).x;\n    return clamp(dist - ambientDist + 1.075, 0., 1.);\n}\n\n// Returns the phong equation for a given direction to a camera, \n// direction to a light, and normal for a surface\nvec3 phongEquation(vec3 rd, vec3 light_dir, vec3 normal, float id, vec3 point) {\n  vec3 R = reflect(-rd, normal);\n  \n  // values for lighting\n  float d = 0.6;\n  float spec = 0.1;\n  \n  vec3 out_color;\n  // For the wooden chesspiece, we need to choose which coords to use to avoid stretching\n  // My solution to this is relying on the values of the normal to tell us what way we are facing\n  // And mixing between which coords we use for the wood texture, this is nice b/c normals will be 0-1\n  // when we take their absolute value\n  if(id == 1.) {\n      out_color = mix(texture(iChannel0, vec2(point.x, point.z)).rgb, \n                      texture(iChannel0, vec2(point.x, point.y)).rgb, abs(normal.z));\n      out_color = mix(out_color, texture(iChannel0, vec2(point.y, point.z)).rgb, abs(normal.x));\n      d = 0.45;\n      spec = 0.045;\n  }else if(id == 2.) {\n      // These control the direction and speed of the chess board's movement\n      float s = sin((iTime-(pi/2.))/4.+3.25*pi/2.)*6.;\n      float c = cos(iTime/4.)*6.;\n      if(s < 0.) s = 1.;\n      if(c < 0.) c = 1.;\n      float xpoint = s*6.+point.x*0.9+0.5;\n      float ypoint = c*6.+point.y*0.9-0.14;\n      \n      // This determines how dark each square is\n      vec3 checkerVal = clamp((checkerTex(vec2(xpoint, ypoint))), 0.4, 1.);\n      // This changes the direction of the grain of the wood based on its' darkness\n      vec3 grainDir = mix(texture(iChannel0, vec2(xpoint, ypoint)).rgb,\n                          texture(iChannel0, vec2(ypoint, xpoint)).rgb, checkerVal);\n      out_color = grainDir * checkerVal + vec3(0.06, 0., 0.01);\n      d = 0.45;\n      spec = 0.055;\n  }\n  else if(id == 3. || id == 7.) out_color = vec3(0.0, 0., 0.5);\n  else if(id == 4.) out_color = vec3(0.5, 0., 0.0);\n  else if(id == 5.) out_color = vec3(0.0, 0.5, 0.0);\n  else if(id == 6.) out_color = vec3(0.5, 0.5, 0.0);\n  out_color += d*max(0.0,dot(normal, light_dir))*vec3(1.0); \n  out_color += spec*pow(max(0.0,dot(light_dir, R)),10.)*vec3(10.0); \n  \n  return out_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // screen uv in (-1, 1)\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec3 light = vec3(cos(iTime/2.), sin(iTime/2.), 1.5);\n    // Rays from camera\n    // depth from optical center to image plane\n    float d = 2.0;\n    vec3 ray_origin = vec3(cos(iTime * -0.2) * d, sin(iTime * -0.2) * d, 0.5*cos(iTime/6.)*cos(iTime/6.)+1.05);\n    vec3 target = vec3(0.0, 0.0, .8);\n    \n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 cam_forward = normalize(target - ray_origin);\n    vec3 cam_right = normalize(cross(cam_forward, up));\n    vec3 cam_up = normalize(cross(cam_forward, cam_right));\n    \n    vec3 ray_direction = normalize(uv.x * (iResolution.x / iResolution.y) * cam_right - uv.y * cam_up + 2.0 * cam_forward);\n    \n    \n    // Declare all objects here\n    w.plane = Plane(vec3(0.0,0.0,1.0),0.0); \n    w.plane2 = Plane(vec3(1.0,0.0,0.0),2.0); \n    w.plane3 = Plane(vec3(0.0,-1.0,0.0),2.0); \n    w.plane4 = Plane(vec3(-1.0,0.0,0.0),2.0);\n    w.plane5 = Plane(vec3(0.0,1.0,0.0),2.0);\n    w.plane6 = Plane(vec3(0.0,0.0,-1.0),3.0); \n    w.cylinder = Cylinder(vec3(0.0, -0.4, 0.5), 0.5, 0.23);\n    w.cylinder2 = Cylinder(vec3(0.0, -0.4, 1.08), 0.05, 0.3);\n    w.cylinder3 = Cylinder(vec3(0.0, -0.4, 1.14), 0.1, 0.25);\n    w.torus = Torus(vec3(0.0, -0.4, 0.15), 0.27, 0.015);\n    w.torus1 = Torus(vec3(0.0, -0.4, 0.07), 0.39, 0.025);\n    w.sphere = Sphere(vec3(-0.28, -0.4, 1.12),0.07);\n    w.sphere2 = Sphere(vec3(0.28, -0.4, 1.12),0.07);\n    w.sphere3 = Sphere(vec3(0.0, -0.12, 1.12),0.07);\n    w.sphere4 = Sphere(vec3(0.0, -0.68, 1.12),0.07);\n    \n    // To simulate the chess piece moving based on floor movement\n    float s = sin((iTime-(pi/2.))/4.+3.25*pi/2.)/8.;\n    float c = cos(iTime/4.)/8.;      \n      \n    if(s < 0.) s = 0.;\n    if(c < 0.) c = 0.;\n      \n    w.cylinder02 = Cylinder(vec3(0.0 - s, -0.4 - c, 1.15), 0.1, 0.23/5.);\n    w.cylinder22 = Cylinder(vec3(0.0 - s, -0.4 - c, 1.266), 0.05/5., 0.3/5.);\n    w.cylinder32 = Cylinder(vec3(0.0 - s, -0.4 - c, 1.278), 0.1/5., 0.25/5.);\n    w.torus02 = Torus(vec3(0.0 - s, -0.4 - c, 1.08), 0.27/5., 0.015/5.);\n    w.torus12 = Torus(vec3(0.0 - s, -0.4 - c, 1.064), 0.39/5., 0.025/5.);\n    w.sphere02 = Sphere(vec3(-0.056 - s, -0.4 - c, 1.274),0.07/5.);\n    w.sphere22 = Sphere(vec3(0.056 - s, -0.4 - c, 1.274),0.07/5.);\n    w.sphere32 = Sphere(vec3(0.0 - s, -0.344 - c, 1.274),0.07/5.);\n    w.sphere42 = Sphere(vec3(0.0 - s, -0.456 - c, 1.274),0.07/5.);\n    \n    \n    \n    // Constants for setting color\n    vec3 color = vec3(0);\n    vec3 leftcolor = vec3(0);\n    float offset = 0.;\n    // For anti-aliasing, we repeat the inner process 3 times, once at the center of a pixel\n    // and twice at a small offset in opposite directions (using noise to randomize it slightly)\n    // Any more than two extra times costs too much\n    for(float j = 0.; j < antiAliasing + 1.; j++){\n        if(j == 1.) offset = 1./iResolution.x * (2.*(texture(iChannel1, uv.xy*50.).r)+ 0.3);\n        if(j == 2.) offset *= -1.;\n        ray_origin = vec3(cos(iTime * -0.2) * d, sin(iTime * -0.2) * d, 0.7*cos(iTime/6.)*cos(iTime/6.)+1.05);\n        ray_direction = normalize((uv.x+offset) * (iResolution.x / iResolution.y) * cam_right - (uv.y+offset)\n                                   * cam_up + 2.0 * cam_forward);\n        vec3 tmpCol = vec3(0);\n\n        for(float i = 0.; i < reflectionCount; i++){\n        \n            // shoot the ray\n            vec2 res = march(ray_origin, ray_direction);\n            // point the ray hit    \n            vec3 point = ray_origin + res.x * ray_direction;\n\n            // calculate direction to the light and normal at point\n            vec3 lightDir = normalize(light - point);\n            vec3 norm;\n            \n            // Minor performance boost from only using the findNormal function when\n            // the point is not on a flat surface, since findNormal is costly to run\n            if(res.y < 2.) norm = findNormal(point);\n            else if(res.y == 2.) norm = vec3(0.0,0.0,1.0);\n            else if(res.y == 3.) norm = vec3(1.0,0.0,0.0);\n            else if(res.y == 4.) norm = vec3(0.0,-1.0,0.0);\n            else if(res.y == 5.) norm = vec3(-1.0,0.0,0.0);\n            else if(res.y == 6.) norm = vec3(0.0,1.0,0.0);\n            else if(res.y == 7.) norm = vec3(0.0,0.0,-1.0);\n\n            // Color has to be set in two steps\n            // If this ray is the first ray being shot, set the initial color of the pixel\n            if(i < 1.)\n                tmpCol = phongEquation(ray_direction, lightDir, norm, res.y, point);\n            else\n            // For all rays after the first, do two things:\n            // subtract a small amount proportionate to the number of reflections to create a fading effect\n            // instead of completely resetting color, preserve some of it each iteration, this creates\n            //    a cool color combo effect inbetween mirror reflections\n                tmpCol = tmpCol * 0.4 + phongEquation(ray_direction, lightDir, norm, res.y, point) * 0.6\n                                                                         - (reflectionFallOff * i + 0.1);\n\n            // Apply ambient factor\n            tmpCol *= ambient(point, norm);\n            \n            // calculate shadows (add a small amount to avoid pitch black, don't compute shadows for mirrors)\n            // Break because we only want to continue reflecting if we are continuously hitting mirrors\n            // Hitting an object means that object is what will be reflected\n            if(res.y < 3.){\n                tmpCol *= shadowMarch(point + norm * 0.0029, lightDir, length(light - point)) + .12;\n                break;\n            }\n\n\n            // Only apply anti-Aliasing to a certain number of reflections\n            if(j > 0. && i > antiAliasingReflections) {\n                tmpCol = color;\n                break;\n            }\n            // The last reflection should be black, this compliments the fading we do earlier\n            if(i == reflectionCount - 1.){\n                tmpCol = vec3(0.);\n            }else { // Don't bother with these two calculations if on the last reflection\n                // Create a reflection by setting a new origin point (adding some of the norm\n                // as always to avoid hitting itself on the next iteration), direction using reflect\n                ray_origin = point + norm * 0.0005;\n                ray_direction = reflect(ray_direction, norm);\n            }\n        }\n        // Setting color like this ensures an even mix\n        if(j == 0.) color = tmpCol;\n        else if(j == 1.) leftcolor = tmpCol;\n        else color = 0.34 * color + 0.33 * leftcolor + 0.33 * tmpCol;\n    }\n    \n    // motion blur\n    color = mix(color, texture(iChannel2, fragCoord.xy / iResolution.xy).rgb, 0.5);\n    fragColor = vec4(color, 1.);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfragColor = mix(texture(iChannel0, fragCoord.xy / iResolution.xy).rgba,\n                 texture(iChannel1, fragCoord.xy / iResolution.xy).rgba, 0.4);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfragColor = mix(texture(iChannel0, fragCoord.xy / iResolution.xy).rgba,\n                 texture(iChannel1, fragCoord.xy / iResolution.xy).rgba, 0.3);\n}","name":"Buffer C","description":"","type":"buffer"}]}