{"ver":"0.1","info":{"id":"XlSGDK","date":"1432673954","viewed":2190,"name":"Ice Dreamer","username":"vgs","description":"Just a quick doodle! :)","likes":47,"published":1,"flags":0,"usePreview":1,"tags":["ice","dream","cold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Created by Vinicius Graciano Santos - vgs/2015\n// https://www.shadertoy.com/view/XlSGDK\n\n#define STEPS 100\n#define EPS 0.02\n#define FAR 100.0\n#define PI 3.14159265359\n\n// smin by iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p) {\n    p = mod(p, 10.0) - 5.0;\n    return smin(length(p)-1.25, min(length(p.yz), \n                min(length(p.xz), length(p.xy))), 0.5)-1.0;\n}\n\nvec3 grad(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n                map(p + q.xyx) - map(p - q.xyx),\n                map(p + q.xxy) - map(p - q.xxy));\n}\n\n// Cube and bump mapping by iq\nvec3 cubeMap(vec3 p, vec3 n) {\n    vec3 a = texture(iChannel0, 0.1*p.yz).rgb;\n    vec3 b = texture(iChannel0, 0.1*p.xz).rgb;\n    vec3 c = texture(iChannel0, 0.1*p.xy).rgb;\n    n = abs(n);\n    return (a*n.x + b*n.y + c*n.z)/(n.x+n.y+n.z);   \n}\n\nvec3 bumpMap(vec3 p, vec3 n, float c) {\n    vec2 q = vec2(0.0, 0.25);\n\tvec3 grad = -(vec3(cubeMap(p+q.yxx, n).r, cubeMap(p+q.xyx, n).r, cubeMap(p+q.xxy, n).r)-c)/q.y;\n    vec3 t = grad - n*dot(grad, n);\n    return normalize(n - t);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(grad(p));\n    vec3 tex = cubeMap(p, n);\n    n = bumpMap(p, n, tex.r);\n    \n    vec3 col = 3.0*vec3(0.3, 0.5, 0.7)*tex*(pow(1.0-dot(-rd, n), 4.0)*.6 + .4*dot(-rd, n));\n    float fog = 1.0 - exp(-0.01*t);\n    return mix(col, vec3(1.0), fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 vi = fragCoord.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.5+iTime);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = 0.0, d = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        d = .55*map(ro + t*rd);\n        if (d < EPS || t > FAR) break;\n        t += d;\n        rd.xy = cos(0.05*d)*rd.xy + sin(0.05*d)*vec2(-rd.y, rd.x);\n    }\n\t\n    vec3 col = d < EPS ? shade(ro, rd, t) : vec3(1.0);\n\tcol += 1.0-vec3(1.0)*pow(vi.x*vi.y*(1.0-vi.x)*(1.0-vi.y), 0.03);\n    \n    col = max(col-0.26, 0.0);\n\tcol = (col*(6.2*col+.5))/(col*(6.2*col+1.7)+0.06);\n    \n    col = pow(col, vec3(1.0/2.2));    \n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}