{"ver":"0.1","info":{"id":"DljcWD","date":"1691787883","viewed":93,"name":"integer modulo strictly positive","username":"jt","description":"The following expression implements a strictly positive integer modulo  (instead of negative for different signs):\n[code](a > 0 && b < 0) ? (a - 1) % b + b + 1 : (a < 0 && b > 0) ? (a + 1) % b + b - 1 : a % b[/code]\nCan this be implemented for ivec4?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["modulo","integer","codegolf","positive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/DtjyWD integer modulo strictly positive, 2023 by jt\n// Often I require a strictly positive integer modulo (instead of negative for different signs).\n\n// tags: integer, modulo, codegolf, positive\n/*\n// Is there a shorter way to implement strictly POSITIVE integer-modulo?\nint mod_positive(int a, int b)\n{\n    // TODO: codegolf this line\n    // XXX looks like this works on linux but not on windows?! XXX\n    return (a > 0 && b < 0) ? (a - 1) % b + b + 1 : (a < 0 && b > 0) ? (a + 1) % b + b - 1 : a % b;\n    //return a*b >= 0 // golfed version by Fabrice\n    //   ?  a % b\n    //   : (a - sign(a)) % b + b + sign(a); \n}\n\nivec4 mod_positive(ivec4 a, ivec4 b) // vector version thanks to Fabrice\n{\n    ivec4 s = (sign(abs(a*b))-sign(a*b))/2; // 0 if a*b >= 0\n    return (1-s)* (a%b) + s * ((a - sign(a)) % b + b + sign(a)); // emulates ()?: \n}\n*/\n\nint div_floor(int a, int b)\n{\n    return (a > 0 && b < 0) ? ((a - 1) / b) - 1 : (a < 0 && b > 0) ? (a + 1) / b - 1 : a / b; // codegolf this line\n    //return (a ^ b) < 0 && a != 0 ? (1 - abs(a)) / abs(b) - 1 : a / b; // fenix found this at https://blog.demofox.org/2022/07/21/rounding-modes-for-integer-division/\n    //return a * b < 0 // golfed version by Fabrice\n    //           ? (1 - abs(a)) / abs(b) - 1 \n    //           : a / b; \n}\n\n// this implementation avoids operator % for stability on windows XXX differs from original at 0 ? XXX\nint mod_positive(int a, int b) // vector version thanks to Fabrice\n{\n    return a - div_floor(a, b) * b;\n}\n\n// https://www.shadertoy.com/view/DtjyWD integer division - rounding down\nivec4 div_floor(ivec4 a, ivec4 b) // vector version thanks to Fabrice\n{\n    ivec4  S = (sign(abs(a*b))-sign(a*b))/2; // 0 if a*b >= 0\n    return S * ((1 - abs(a)) / abs(b) - 1)+(1-S)*(a / b); // emulates ()?:\n}\n\n// this implementation avoids operator % for stability on windows XXX differs from original at 0 ? XXX\nivec4 mod_positive(ivec4 a, ivec4 b) // vector version thanks to Fabrice\n{\n    return a - div_floor(a, b) * b;\n}\n\nvoid mainImage( out vec4 c, in vec2 I)\n{\n    I -= iResolution.xy / 2.0;\n    //c = vec4(mod_positive(int(I.x),int(I.y)));\n    c = vec4(mod_positive(ivec4(I.x),ivec4(I.y)));\n    //c = vec4(int(I.x)%int(I.y));\n}\n","name":"Image","description":"","type":"image"}]}