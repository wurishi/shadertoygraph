{"ver":"0.1","info":{"id":"wdVyDR","date":"1602624970","viewed":223,"name":"Rocket planet","username":"sylvain69780","description":"Can a dodecahedron be used as launch pad for rockets ?\n","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["rocket","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Rocket planet\n    -------------\n    \n    Again the magic of domain repetition.\n    \n    Related references\n    \n    IQ Distance functions\n    https://iquilezles.org/articles/distfunctions\n    https://iquilezles.org/articles/distfunctions2d    \n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n\n    Iridescent crystals - tdhooper\n    https://www.shadertoy.com/view/llcXWM\n\n*/\n\n#define PHI (1.618033988749895)\n#define PI acos(-1.)\n#define TAU 6.283185\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define S smoothstep\n\n\n// Nearest icosahedron vertex and id\nfloat quadrant(float a, float b) {\n\treturn ((sign(a) + sign(b) * 2.) + 3.) / 2.;\n}\nvec4 icosahedronVertex(vec3 p) {\n    vec3 v1, v2, v3, result, plane;\n    float id;\n    float idMod = 0.;\n\tv1 = vec3(sign(p.x) * PHI,sign(p.y) * 1.,0);\n\tv2 = vec3(sign(p.x) * 1.,0,sign(p.z) * PHI);\n\tv3 = vec3(0,sign(p.y) * PHI,sign(p.z) * 1.);\n    plane = normalize(cross(mix(v1, v2, .5),cross(v1, v2)));\n    if (dot(p, plane) > 0.) {\n    \tresult = v1;\n        id = quadrant(p.y, p.x);\n    } else {\n    \tresult = v2;\n        id = quadrant(p.x, p.z) + 4.;\n    }\n    plane = normalize(cross(mix(v3, result, .5),cross(v3, result)));\n    if (dot(p, plane) > 0.) {\n    \tresult = v3;\n        id = quadrant(p.z, p.y) + 8.;\n    }\n    return vec4(normalize(result), id);\n}\n\n// https://iquilezles.org/articles/noacos\nmat3 rotationAlign( vec3 d, vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n    return mat3(v.x*v.x*k + c,   v.y*v.x*k - v.z, v.z*v.x*k + v.y,\n                v.x*v.y*k + v.z, v.y*v.y*k + c,   v.z*v.y*k - v.x,\n                v.x*v.z*k - v.y, v.y*v.z*k + v.x, v.z*v.z*k + c    );\n}\nmat3 rotationAlignY( vec3 d )\n{\n    return mat3( d.z*d.z/(1.+d.y)+d.y, d.x,-d.x*d.z/(1.+d.y),\n                -d.x, d.y, -d.z,\n                -d.z*d.x/(1.+d.y), d.z, d.x*d.x/(1.+d.y)+d.y);\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//-------------------------------------------------\n// https://www.shadertoy.com/view/4lyfzw\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p)-r; \n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// AKA ModPolar !\nvec3 opRepRoundabout(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    float sector = round(atan(p.z,p.x)/angle); // thanks to IQ video https://youtu.be/sl9x19EnKng?t=1745\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    return p;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\nfloat sdRocket( vec3 pos)\n{\n\tvec3 q=pos;\n\tfloat d = -0.03+abs(-0.1 + sdVesica(opRevolution(q,0.0), 1.4, 1.1 ));  // ABS for onioning\n    // porthole\n    // hole with cylinder\n    d = max(d,-max(-q.z,sdCylinder(q.yzx, vec3(0.,0.,0.15))));\n    // 3 sectors for engines\n\tq = opRepRoundabout(pos,0.,5.);\n    d = min(d, -0.05 + sdVesica(opRevolution(vec3(q.x-.6,q.y+.8,q.z),0.0), 0.65, 0.5 )) ;\n    // cut the bottom\n\td = smax( d, -pos.y-1.1, 0.05 );\n    // link between engines and rocket's body\n\tq += vec3(0.1,1.13,0.0);\n    float lnd = sdCircle(q.xy, 1.00 );\n        lnd = max(lnd,-sdCircle(q.xy+vec2(-0.3,0.3),0.6));\n        lnd = max(lnd,-sdCircle(q.xy+vec2(0.8,-1.1),1.3));\n        lnd = max(lnd,q.x-0.8);\n        lnd = max(lnd,-q.y+0.2);\n    d = min(d,opExtrussion (q,lnd,0.02)-0.01);\n    return d;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\nvec4 getRocketPath(float key) {\n\tfloat h=2.*S(1.,2.,key)*S(10.,9.,key);\n\tfloat r=S(1.2,3.,key)*S(9.8,8.,key);\n\tfloat a = 3.*TAU*S(1.2,9.5,key);\n\treturn vec4(0.,h+r*sin(a),r*cos(a),a);    \n}\n\nvec3 animateRocket(vec3 p,float time) {\n    time*=.3;\n    vec3 q=p;\n    float key = 20.*fract(time);\n\tfloat key2 =  20.*fract(time+.01);\n\tvec4 p1 = getRocketPath(key);\n\tq-=p1.xyz;\n\tq.y-=1.05;\n    q.yz*=Rot(p1.w);\n\treturn q;   \n}\n\n\nvec2 GetDist(vec3 p) {\n    float time = iTime;\n    p.xz *= Rot(time*.01*6.2831);        \n    p.yz *= Rot(time*.005*6.2831);        \n\ttime=time*.2;\n\tvec3 q=p;\n    vec4 ico = icosahedronVertex(q);\n    float id = ico.w;\n//    q=rotationAlign(ico.xyz,vec3(0.,1.,0.))*q;\n    q=rotationAlignY(ico.xyz)*q;\n    float rocket = sdRocket(3.*animateRocket(q,time+id))*.333;\n    float earth = length(p)-.7;\n\tfloat c = -sdCone(q,vec2(sin(PI/6.),cos(PI/6.)));   // disance to domain bouding cone \n    float d=min(rocket,earth);    \n    d=min(d,max(c,.5));  // this is trying to slow down the ray marcher when approaching the bound of the cone over the face of the dode\n    return vec2(d,id);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;    \n    vec2 m;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        m = GetDist(p);\n        float dS = m.x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return vec2(dO,m.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 3, -3);\n    if ( iMouse.x != 0. ) {\n        vec2 mo = 2.*iMouse.xy/iResolution.xy-vec2(1.);\n        ro.yz *= Rot(-mo.y);\n        ro.xz *= Rot(-mo.x*6.2831);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec2 m = RayMarch(ro, rd);\n    float d=m.x;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3  sun_lig = normalize( vec3(0.2, 0.35, -0.5) );        \n    \tfloat dif = clamp(dot( n, sun_lig ), 0.0, 1.0 )+.1;\n        vec3  sun_hal = normalize( sun_lig-rd );\n\t\tfloat sun_spe = pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sun_sha = step(-RayMarch(p+0.01*n, sun_lig).x,-MAX_DIST);\n        col += 1.*sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        vec3 c = hsv2rgb(vec3(m.y/12.+fract(iTime*.05),0.8,.9)); // nice ?\n    \tcol += dif*c*(sun_sha*.9+.1);  \n    } else { col = vec3(.1)*(.5-abs(uv.y));}\n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}