{"ver":"0.1","info":{"id":"3lXXDX","date":"1564432040","viewed":322,"name":"Serenity","username":"peet","description":"A bit more chilled than most of my other stuff :)\nCode pretty much lifted from 'Battle in the Clouds' ","likes":7,"published":1,"flags":8,"usePreview":0,"tags":["sound","clouds","volumetric","serene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n\n// comment me out if you need some more FPS!\n#define HIGHER_QUALITY\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#ifdef HIGHER_QUALITY\n    // HIGHER QUALITY SETTINGS\n    #define MARCH_ITERATIONS \t220\n    #define MARCH_DELTA\t\t\t0.03\n    #define MARCH_DELTA2\t\t1.015\n    #define START_DIST \t\t\t4.0\n    #define LIGHT_LOD\t\t\t6\n    #define MIST_LOD\t\t\t5\t\n#else\n\t// LOWER QUALITY SETTINGS\n    #define MARCH_ITERATIONS \t130\n    #define MARCH_DELTA\t\t\t0.075\n    #define MARCH_DELTA2\t\t1.02\n    #define START_DIST \t\t\t4.0\n    #define LIGHT_LOD\t\t\t6\n    #define MIST_LOD\t\t\t4\t\n#endif //HIGHER_QUALITY\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\nResult g_result;\n    \n///////////////////////////////////////////////////////////////////////////////////\n\nconst int lightarraysize = 2;\nconst int numlights = 1;\nLight g_lights[lightarraysize];\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's noise functions\n\nfloat noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    //f = (f*f*(3.0-2.0*f)+f)*0.5;\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat mist(vec3 p, int LOD)\n{   \n    vec3 p2 = p;\n    p *= 0.2;\n    float weight = 0.25;\n    float totalweight = 0.0;\n    float value = 0.0;\n    for (int i=0; i<LOD; i++)\n    {\n        totalweight += weight;\n        value += noise2(p)*weight;    \n        p *= 2.03;\n        weight *= 0.6;\n    }\n    return (value/totalweight - abs(p2.y)*0.015);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat fogvalue(float mistvalue, float z)\n{\n    float value=0.0;\n    const float density = 0.7;\n    const float vmax=mix(0.85, 0.85, density);\n    const float vmin=mix(0.5, 0.25, density);\n\n    if (mistvalue >= vmax)\n        value = 1.0;\n    else if (mistvalue <= vmin)\n        value = 0.0;\n    else\n        value = (mistvalue-vmin)/(vmax-vmin);\n\n    value=value*value;\n    return value;\n}\n\nvoid AlphaBlend(in float ascr, in float atex, out float aout, in vec3 cscr, in vec3 ctex, out vec3 cout)\n{\n    // scr=existing screen colour/alpha, tex=incoming texture colour/alpha, out = value to write to screen\n    aout = ascr + atex*(1.0-ascr);\n    cout = (cscr*ascr + ctex*atex*(1.0-ascr))/(aout);\n}\n\nResult raymarch_query(Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial, vec4(0.0, 0.5, 0.0, 0.0));    \n    float dist = 0.0;\n    float fog=0.0;\n    float dstalpha = 0.0;\n    float srcalpha = 0.0;\n    const float densitythreshold = 0.70;\n    const float densityscale = 100.0/(1.0-densitythreshold);\n    const float lightstep = 0.6;\n    const float lightatten = 1.0 / (sqrt(lightstep)*1.8);\n    \n    vec3 lighting = vec3(-1.0, -1.0, 1.0);\n    lighting = normalize(lighting);\n    \n\tfor (int i=0; i<iterations; i++)\n    {        \n\t\tfloat v1 = mist(ray.pos, MIST_LOD);\n\t\tfloat value=fogvalue(v1, ray.pos.z);\n\t\tvec3 fogcolour = mix(vec3(1.0), vec3(0.0), value);\n\n        // density is the value times the step       \n        float density = clamp(value*delta*0.9, 0.0, 1.0);\n        density*=clamp(delta*8.0, 0.0, 1.0);\n        // update the alpha\n        srcalpha = density;\n        \n        if (srcalpha>0.001)\n        {\n            for (int j=0; j<numlights; j++)\n            {\n                lighting = ray.pos - g_lights[j].pos;\n                float attenuation = 9.0 / length(lighting);\n                lighting = normalize(lighting);        \n                float v2 = mist(ray.pos + lighting*lightstep, LIGHT_LOD);\n\n                if ((v2-v1) >= 0.0)\n                {\n                    attenuation = clamp(attenuation, 0.0, 1.0);\n                    attenuation *= lightatten;\n                    fogcolour += 6.0*(v2-v1)*(v2-v1)*10.0*g_lights[j].colour*1.0*attenuation;\n                    fogcolour += 0.35*g_lights[j].colour*1.0*attenuation*attenuation;\n                }\n                else\n                {\n                    attenuation = clamp(attenuation*0.5, 0.0, 1.0);\n                    attenuation *= lightatten;\n                    //fogcolour += 10.5*(v1-v2)*(v1-v2)*10.0*g_lights[j].colour*1.0*pow(attenuation, 5.0);\n                    fogcolour += 5.5*0.3*g_lights[j].colour*1.0*pow(attenuation, 10.0);                \n                }\n            }    \n            \n            AlphaBlend(dstalpha, srcalpha, dstalpha, result.fog.xyz, fogcolour, result.fog.xyz);\n            \n            // modify the destingation alpha, based on the current srcalpha\n//            float prevdstalpha = dstalpha;\n//            dstalpha = dstalpha + srcalpha*(1.0 - dstalpha);\n//            result.fog.xyz = mix(fogcolour, result.fog.xyz, prevdstalpha/dstalpha);\n        }\n        if (dstalpha>0.999)\n        {\n\t\t   \tresult.fog.w = dstalpha;\n    \t\treturn result;            \n        }\n             \n        ray.pos += ray.dir*delta;\n        delta*=MARCH_DELTA2;\n    }\n            \n   \tresult.fog.w = dstalpha;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 raymarch(Ray inputray, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;    \n    \n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, MARCH_DELTA);\n    \n//    colour = vec3(g_result.fog.w);\t\n//    colour = g_result.fog.xyz;    \n    colour = mix(vec3(0.2, 0.3, 0.4)*(1.1-uv.y), g_result.fog.xyz, g_result.fog.w);       \n    //colour = mix(vec3(0.0), g_result.fog.xyz, g_result.fog.w);       \n            \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 volumelights( Ray ray )\n{   \n    float caststep=0.5;    \n    vec3 colour = vec3(0.0, 0.0, 0.0);                \n    float castdistance = 0.0;\n    for (int i=0; i<numlights; i++)\n    {\n\t    castdistance = max(length(g_lights[i].pos-ray.pos)*1.1, castdistance);    \n    }\n    float castscale=castdistance/caststep;\n\tfloat obscurity = 0.0;\n    \n    for (float t=0.0; t<castdistance; t+=caststep)\n    {\n        vec3 pos = ray.pos + ray.dir*t; \n        obscurity += fogvalue(mist(pos, 4), pos.z) * 1.2;\n\t\tvec3 deltapos;\n        float d2;\n                        \n        for (int i=0; i<numlights; i++)\n        {        \n            deltapos = g_lights[i].pos-pos;\n            d2=dot(deltapos, deltapos);\n            \n            if (d2<40.0)\n            {\n                colour.xyz += g_lights[i].colour/(d2*castscale*0.8);\n            }   \n        }\n    }\n    \n    return colour*clamp((1.0-obscurity*0.1), 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float roll = 0.5;\n    float time = iTime;\n    \n    vec3 p0, p1;\n    p0=vec3(0.0, 8.0, 0.0+time);\n    p1=vec3(0.0, 0.0, 55.0+time);\n    //ViewVector(time, p0, p1); \n        \n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, 0.0) + p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    ray.dir = normalize(ray.dir);\n        \n    ray.pos += ray.dir*START_DIST;\n    \n    g_lights[0].pos = p0 + vec3(perlin(time*0.4, 2.5)*24.0-12.0, perlin(time*0.4, 3.5)*8.0-4.0, 20.0 + perlin(time*0.4, 13.5)*4.0-4.0);\n    g_lights[1].pos = p0 + vec3(perlin(time*0.6, 1.5)*24.0-12.0, perlin(time*0.6, 2.5)*8.0-4.0, 20.0 + perlin(time*0.6, 11.5)*4.0-4.0);\n    \n    const float looptime = 3.0;\n            \n    g_lights[0].colour = vec3(1.0, 0.7, 0.3)*1.7;\n    g_lights[1].colour = vec3(0.4, 0.4, 1.3);\n        \n    fragColor.xyz = vec3(0.0);        \n    fragColor.xyz += raymarch(ray, fragCoord); \n    fragColor.xyz += volumelights(ray);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n    vec4 fog;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\nvoid ViewVector(in float time, out vec3 p0, out vec3 p1)\n{\n    float ft = time-1.0;\n\tp0 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0);  \n    ft+=0.5;\n\tp1 = vec3(12.0 - perlin(ft*0.25, 7.5)*24.0, 3.0 - perlin(ft*0.25, 8.5)*6.0, 0.0); \n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{\n    float s=0.0;\n    float freq=100.0;\n    float scale=1.0;\n    float octaves=12.0;\n \n    for (float i=0.0; i<octaves; i++)\n    {\n        s += perlin(time*freq, 100.5 + (float(i)))*scale; \n        freq*=2.0;\n        scale *= 0.5;\n    }\n    s*=1.0/octaves;\n    s*=perlin(time*500.0, 99.5);\n    \n    return vec2( s*0.4 );\n}","name":"Sound","description":"","type":"sound"}]}