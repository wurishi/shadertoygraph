{"ver":"0.1","info":{"id":"lfGXWm","date":"1715259018","viewed":51,"name":"rounded healthbar","username":"vec3f","description":"rounded healthbar","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","rounded","healthbar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nobvious imperfections arise when of/of1/of2 are set close to diameters\nrecommended to keep smoothstep offsets < 5.0\n*/\n\nfloat d1 = 50.0; // diameter (inner)\nfloat d2 = 20.0; // diameter (outline)\nfloat w = 600.0; // width\n// for intended usage scale, set d1=5.0, d2=2.0, w=60.0\n\nfloat of = 1.0; // smoothstep offset (outline, exterior)\nfloat of1 = 1.0; //  (healthbar, outline) - \nfloat of2 = 1.0; // (healthbar, outline) +  | set of2 <= d2/2\n\nvec4 hc1 = vec4(0.0, 1.0, 0.0, 1.0); // color (high)\nvec4 hc0_5 = vec4(1.0, 1.0, 0.0, 1.0); // color (mid)\nvec4 hc0 = vec4(1.0, 0.0, 0.0, 1.0); // color (low) \nvec4 oc = vec4(0.05, 0.05, 0.05, 1.0); // outline color\nvec4 bg = vec4(0.9, 0.9, 0.9, 1.0); // bg color\n\nvec4 vec4_lerp(vec4 c1, vec4 c2, float t) {\n    return c1 + (c2 - c1) * t;\n}\nvec3 gamma_correct(vec3 color, float gamma) {\n  return pow(color, vec3(gamma));\n}\n\nfloat hp_dist_chk(vec2 fc, float hp, float r1, float lp, float px, vec2 ce) {\n    float pd = fc.x - lp; // pixel dist from left\n    float dp = px * hp - r1; // dividing point\n    if (pd < dp) return -1.0; // no dist calc needed\n    return distance(fc, vec2(lp + dp, ce.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    of2 = min(of2, d2 / 2.0);\n    vec2 ce = vec2(iResolution.xy / 2.0);\n    fragColor = bg;\n    float hp = sin(iTime) * 0.5 + 0.5;\n    \n    vec2 fc = fragCoord;\n    float dx = fc.x - ce.x;\n    float dy = abs(fc.y - ce.y);\n    \n    float p1 = -float(w) / 2.0;\n    float p2 = float(w) / 2.0;\n    \n    float r1 = d1 / 2.0;\n    float r2 = (d1 + d2 / 2.0) / 2.0;\n    float r21 = r2 + of;\n\n    float lp = ce.x + p1 - r1; // leftmost x\n    float rp = ce.x + p2 + r1; // rightmost x\n    float px = rp - lp;\n    \n    vec4 final_hc;\n    if (hp >= 0.5) final_hc = vec4_lerp(hc0_5, hc1, hp * 2.0 - 1.0);\n    else final_hc = vec4_lerp(hc0, hc0_5, hp * 2.0);\n        \n    if (p1 <= dx && dx < p2) {\n        float t = smoothstep(r2, r21, dy);\n      \n        float res = hp_dist_chk(fc, hp, r1, lp, px, ce);\n        // if (dy < r1 + of2 && (res == -1.0 || res <= r1)) {\n        // fragColor = mix(hc, oc, smoothstep(r1 - of1, r1 + of2, dy));\n        // fragColor = mix(hc, oc, smoothstep(r1 - of1, r1 + of2, res));\n        if (dy <= r1 + of2 && res == -1.0) {\n            fragColor = mix(final_hc, oc, smoothstep(r1 - of1, r1 + of2, dy));\n        } else if (dy <= r1 + of2 && res <= r1) {\n             fragColor = mix(final_hc, oc, smoothstep(r1 - of1, r1 + of2, res));\n        } else if (dy <= r21) {\n            fragColor = mix(oc, bg, smoothstep(r2, r21, dy));\n        }\n    } else {\n        vec2 mp;\n        if (p1 > dx) mp = ce + vec2(p1, 0);\n        else mp = ce + vec2(p2, 0); // p2 <= dx\n        \n        float d = distance(mp, fc);\n        float res = hp_dist_chk(fc, hp, r1, lp, px, ce);\n        if (d < r1 + of2 && (res == -1.0 || res <= r1)) {\n        fragColor = mix(final_hc, oc, smoothstep(r1 - of1, r1 + of2, max(d, res)));\n        } else if (d <= r21) {\n            fragColor = mix(oc, bg, smoothstep(r2, r21, d));\n        }\n \n    }\n}","name":"Image","description":"","type":"image"}]}