{"ver":"0.1","info":{"id":"3td3zN","date":"1575803741","viewed":132,"name":"Shader de Noël moche","username":"Windless","description":"Inspiré par le pull de Nicole Ferroni,je decide de faire un shader de noel moche.","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["test","christmasshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XlS3RR","filepath":"https://soundcloud.com/loicmusique/8bit-christmas","previewfilepath":"https://soundcloud.com/loicmusique/8bit-christmas","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n#define NB_BRANCHES 3.0\n\n#define C_FOND       0\n#define C_PAYSAGE    1\n#define C_TRONC      2\n#define C_BRANCHES   3\n#define C_NEIGE      4\n\nvec3 couleur(int c) {\n  if (c == C_FOND)     return vec3(1.00, 0.00, 0.00);     \n  if (c == C_PAYSAGE)  return vec3(0.90, 0.90, 0.90);\n  if (c == C_TRONC)    return vec3(0.40, 0.15, 0.00);\n  if (c == C_BRANCHES) return vec3(0.00, 0.80, 0.00);\n  if (c == C_NEIGE)    return vec3(1.00, 1.00, 1.00);\n}\n\nint paysage(in vec2 uv) {\n  return int(min(1., 1.35 - uv.y + cos(uv.x * 3.) / 12.));\n}\n\nint tronc(in vec2 uv) {    \n\n  uv = abs(uv);\n  \n  return int(\n    1. - (step(0.2, uv.y) + step(0.1, uv.x) )\n  );\n}\n\nint branches(in vec2 uv) {\n\n  uv = abs(uv);\n  float l =\n    1.0\n    - (uv.x + uv.y)\n    + floor(uv.y * 5.) / 8.0;\n\n  l = step(0.5, l);\n  \n  l *= step(0.2, uv.y);\n\n  return int(l);\n}\n\nint neige(in vec2 uv) {\n  float angle = atan(uv.y,uv.x);\n  float radius = length(uv);\n  \n  angle *= NB_BRANCHES;\n  \n  uv = vec2(cos(angle + iTime),sin(angle + iTime)) * radius;\n\n  vec2 uv2 = uv;\n  \n  uv = abs(uv);\n  float t =\n    step(uv.x, 0.045)\n    * step(uv.y, 0.3);\n  \n  t +=\n    step(uv.x, 0.15)\n    * step(abs(uv.y - 0.2), 0.015);\n\n  t +=\n    step(uv.x, 0.25)\n    * step(abs(uv.y - 0.1), 0.025);\n\n  return int(min(1., t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv.x -= 0.2;\n  \n  int plan = 0;\n  \n  float sx = 2.2 - mod(iTime / 4.0, 3.);\n   \n  plan = max(plan, tronc(uv - vec2(sx, 0.))         * C_TRONC);\n  plan = max(plan, branches(uv - vec2(sx, 0.))      * C_BRANCHES);\n  plan = max(plan, paysage(uv + vec2(iTime/13.,0.)) * C_PAYSAGE);\n  plan = max(plan, neige(fract( (uv- vec2(0.3,-0.2) * float(iTime))*5.0) -0.5 )       * C_NEIGE);\n \n  fragColor = vec4(couleur(plan), 1.0);\n}","name":"Image","description":"","type":"image"}]}