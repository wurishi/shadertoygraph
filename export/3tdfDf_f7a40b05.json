{"ver":"0.1","info":{"id":"3tdfDf","date":"1613651239","viewed":417,"name":"DuoShader","username":"paulsinnett","description":"A shader simulating the old duoshade / duotone cartoonist paper.\n\nSee this video for an explanation: https://www.youtube.com/watch?v=GftgBL-sHnI\n\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["monochrome","duotone","duoshade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 undeveloped_colour = vec3(0.8392, 0.9137, 0.9607); // light blue\nvec3 developed_colour = vec3(0.2588, 0.2823, 0.2823); // dark but not black\nvec3 ink_colour = vec3(0.2784, 0.2313, 0.2392); // aged ink\nvec3 paper_colour = vec3(0.8549, 0.7882, 0.7254); // aged paper\nfloat undeveloped = 0.01; // the level the of undeveloped lines\nfloat level = 0.3; // the thickness of the diagonal lines as a fraction of their separation\nfloat edge = 0.1; // smoothing for the above\n\nfloat black = 0.35; // the level of black in the source image\nfloat dark = 0.45; // the level for painting with the dark chemical in the source\nfloat light = 0.75; // the level for painting with the light chemical in the source\n\nfloat print_black_level = 0.78; // the level considered black for output\nfloat noise_level = 0.04; // the level of noise for dithering between levels\n\n// slice out a section:\n// from 0     -> dark  returns 0\n// from dark  -> light returns 1\n// from light -> 1     returns 0\n//\n// multiply by this to mask out light and dark values\nfloat slice(float dark, float light, float value)\n{\n    return 1.0 - (1.0 - step(dark, value)) - step(light, value);\n}\n\n// returns the a hatching pattern based on the input level and corrdinates\nfloat shade(float l, vec2 uv)\n{\n    // f represents the distance in pixels between stripes\n    float f = 6.;\n    float width = iResolution.x / f;\n    float height = iResolution.y / f;\n    // l1 is the distance of this pixel from a diagonal line\n    float l1 = uv.x * width + uv.y * height;\n    // l2 is the distance of this pixel from the other diagonal line\n    float l2 = uv.x * width + (1.0 - uv.y) * height;\n    // d1 the distance from the centre of a repeating diagonal\n    float d1 = abs(0.5 - fract(l1)) * 2.0;\n    // d2 same as above for the other diagonal\n    float d2 = abs(0.5 - fract(l2)) * 2.0;\n\n    // w is a mask of the white area\n    float w = step(light, l);\n    // b is a mask of the black area\n    float b = 1.0 - step(black, l);\n    // cd is a mask of the dark chemical area\n    float cd = ((1.0 - smoothstep(black, dark, l)) * 0.5 + 0.5) * slice(black, dark, l);\n    // cl is a mask of the dark to light chemical areas\n    float cl = ((1.0 - smoothstep(dark, light, l)) * 0.5) * slice(black, light, l);\n\n    // s1 is the fully developed diagonal lines\n    float s1 = smoothstep(1.0 - level - edge, 1.0 - level, d1);\n    // s2 is the same as above for the other diagonal\n    float s2 = smoothstep(1.0 - level - edge, 1.0 - level, d2);\n\n    // hatch is the combined diagonals modified by the dark and light chemicals\n    float hatch = clamp(0.0, 1.0, s1 * (cl + undeveloped) + s2 * (cd + undeveloped));\n    return hatch;\n}\n\n// standard noise function\nfloat noise(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// convert from rgb to luma light level\nfloat luma(vec3 col)\n{\n    vec3 coefs = vec3(0.2126, 0.7152, 0.0722);\n    return dot(coefs, col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    vec3 rgb = col.rgb;\n    // get the brightness\n    float l = luma(rgb) + noise(uv) * noise_level;\n    // get duoshade stripes for this level of brightness\n    float s = shade(l, uv);\n    // colour using the given undeveloped / developed colours\n    rgb = mix(vec3(1, 1, 1), mix(undeveloped_colour, developed_colour, s), step(undeveloped, s));\n    // black out black areas\n    float black = 1.0 - step(black, l);\n    rgb *= (1.0 - black);\n    \n    // sample for black and white print values (as if printing)\n    // comment out these lines to see the pre-printed image\n    s = step(print_black_level, luma(rgb) + noise(uv) * noise_level);\n    rgb = mix(ink_colour, paper_colour, s);\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}