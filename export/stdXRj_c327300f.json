{"ver":"0.1","info":{"id":"stdXRj","date":"1639423780","viewed":195,"name":"Sub Quantum Attraction","username":"tomachi","description":"trying to capture the \"velcro and elastic\" concept of strong and weak force. these can be water molecules. eventually i'm hoping to model the pauli exclusion principle. not yet though.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["particlephysics"],"hasliked":0,"parentid":"3l3fWn","parentname":"Bouncing balls"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe main problem with this way of visualizing particles is that the visualization\ntakes way more processing power than the simulation. \nEspecially at high render resolution, because every pixelshader has to loop through every particle.\nVisualization should normally be done with polygons, but that is ofcourse not possible here.\n\n*/\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    // replace \"numPart\" in the for loop with a low numer to see less particles rendered and the fps increase. \n     for(int x = 0; x < numPart; x++)\n     for(int y = 0; y < numPart; y++){\n     vec4 particle = texelFetch(iChannel0, ivec2(x,y), 0);\n     float mydot = dot(particle.zw,particle.zw);\n     float depth = ceil(-64. + particle.y)*0.01;\n    \n    if(dot(particle.xy - fragCoord, particle.xy - fragCoord) < radius){\n        col = hsv2rgb(vec3(min(mydot,10.9)* -0.3+0.6,1.-(mydot*0.00125), 1. )); // color indicates velocity\n        //col = vec3(1); // simple white particle\n    }\n    }\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nPhisics engine:\n\n\n[0] / x = x\n[1] / y = y\n[2] / z = Vx\n[3] / w = Vy\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nivec2 iCoord = ivec2(fragCoord);\n\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\nvec2 cuv = uv - vec2(0.5);\n\nif(iCoord.x < numPart && iCoord.y < numPart){\n ivec2 iRes = ivec2(iResolution);\n vec4 This = texelFetch(iChannel0, iCoord, 0);\n \n \n if(iTime < 0.2 || iFrame < 2 ) // setup\n  //   This = vec4(1.5*radius*fragCoord.x+fragCoord.x,3.5*radius*fragCoord.y+uv.y, -0.1*fragCoord.x,0.); \n   This = vec4(3.5 * radius * fragCoord.x + uv.x, 3.5 * radius * fragCoord.y  + uv.y, -1.0,  fragCoord.y); \n else{\n \n  // vec2 force = vec2(0);This.zw\n   vec2 force = This.zw * 0.9995; // remember existing motion\n \n   for(int x = 0; x < numPart; x++)\n     for(int y = 0; y < numPart; y++){\n       vec4 other = texelFetch(iChannel0, ivec2(x,y), 0);\n \n       vec2 relPos = other.xy - This.xy;\n       float hg = other.x - This.x;\n       float vg = other.y - This.y;\n       float centerDist = length(relPos);\n      //loat surfDis = centerDist - (radius);\n       float surfDis = centerDist - (radius);\n // GRAVITY between all other balls\n force.x += (0.000000001 * (1. / surfDis)); // horizontal attaction\n force.y += (0.000000001 * (1. / surfDis)); // horizontal attaction\n\n\n       if(surfDis > radius*10.  ){ // electro-static attraction via hydrogen bonds of water\n          force += strong * relPos *(-0.0091 / surfDis);\n          force += 0.01 *(This.zw - other.zw) * colFric;\n          force *= -0.89999 ;//* relPos / surfDis;\n   \n      } else  { // collision\n          force *= 0.900045769; // dampening\n          force += relPos / surfDis ;\n          force += strong * (This.zw - other.zw) *(-0.0091 / surfDis);\n          force += (other.zw - This.zw) * colFric ; // collision friction\n           This.z *= 0.9905;\n           This.w *= 0.9905;\n       } \n\n \n } // for\n \n force.y += max(radius - This.y,0.)*0.91; // ground collision\n force.x += max(radius - This.x,0.)*0.91; // left side collision\n force.x -= max(radius + This.x - iResolution.x,0.)*0.91; // right side collision\n \n // if (This.y > 64.) { force.y += -gravity;}  // apply gravity\n force.y -= gravity;\n This.zw += force; // apply force\n This.xy += This.zw; // move\n \n }\n fragColor = This;\n\n}else{ // not active particle\n    fragColor = vec4(0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define numPart 24 // actual number of particles is this^2\n#define radius 8.\n#define gravity 0.00658943543\n#define strong 0.00510909421094\n#define sspeed -191\n#define gas 0.001\n#define liquid 0.002\n#define solid 0.05\n#define colFric liquid\n// collision friction, behaves 0.0 like gas, 0.002 like liquid 0.05 like solid, unstable above 0.05","name":"Common","description":"","type":"common"}]}