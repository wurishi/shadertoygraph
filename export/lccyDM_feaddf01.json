{"ver":"0.1","info":{"id":"lccyDM","date":"1730729992","viewed":25,"name":"Blob with glitch","username":"Maraba","description":"Test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(vec2 uv, vec2 position, float radius) \n{\n    return smoothstep(radius, radius - 0.01, length(uv - position));\n}\n\nfloat hash(vec2 p)\n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) -3.0) -1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 N = vec2(6.0, 6.0);\n    vec2 uv = fragCoord.xy / iResolution.xy * N;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime * 0.3;\n    float glitchFreq = 2.0;\n    float glitchDuration = 0.1;\n    float glitchStrength = 0.05;\n\n    float glitchTime = mod(t * glitchFreq, 1.0);\n    float glitchActive = step(1.0 - glitchDuration, glitchTime);\n\n    float hueSpeed = 0.1;\n    float baseHue = hash(id);\n    float hue = mod(baseHue + t * hueSpeed, 1.0);\n    vec3 cellColor = hsv2rgb(vec3(hue, 1.0, 1.0));\n    \n    vec2 seed = id;\n    float rand1 = hash(seed + vec2(1.0, 0.0));\n    float rand2 = hash(seed + vec2(0.0, 1.0));\n    float rand3 = hash(seed + vec2(1.0, 1.0));\n    float rand4 = hash(seed + vec2(2.0, 2.0));\n    float rand5 = hash(seed + vec2(3.0, 3.0));\n    float rand6 = hash(seed + vec2(4.0, 4.0));\n    float rand7 = hash(seed + vec2(5.0, 5.0));\n    float rand8 = hash(seed + vec2(6.0, 6.0));\n    \n    vec2 centralCirclePos = vec2(\n        sin(t * (1.123 + rand1 * 2.0) + sin(t * (2.345 + rand2 * 2.0))) * 0.1,\n        sin(t * (1.789 + rand3 * 2.0) + sin(t * (3.456 + rand4 * 2.0))) * 0.1\n    );\n    \n    float radius1 = 0.1 + 0.05 * sin(t + rand5 * 6.2831);\n    float radius2 = 0.1 + 0.05 * cos(t + rand6 * 6.2831);\n    \n    vec2 electron1Offset = vec2(\n        sin(t * (1.567 + rand7 * 2.0) + sin(t * (0.987 + rand8 * 2.0))) * radius1,\n        cos(t * (0.876 + rand1 * 2.0) + cos(t * (1.234 + rand2 * 2.0))) * radius1\n    );\n    \n    vec2 electron2Offset = vec2(\n        sin(t * (1.789 + rand3 * 2.0) + sin(t * (1.345 + rand4 * 2.0) + 3.14159)) * radius2,\n        cos(t * (1.456 + rand5 * 2.0) + cos(t * (0.543 + rand6 * 2.0) + 3.14159)) * radius2\n    );\n    \n    vec2 electron1Pos = centralCirclePos + electron1Offset;\n    vec2 electron2Pos = centralCirclePos + electron2Offset;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mouse.y *= -1.0;\n    mouse *= N;\n    vec2 mouseCell = floor(mouse);\n    \n    if (iMouse.z > 0.0 && mouseCell == id)\n    {\n        vec2 mouseLocal = fract(mouse) - 0.5;\n        mouseLocal.x *= iResolution.x / iResolution.y;\n        \n        float attractionStrength = 0.5;\n        centralCirclePos += (mouseLocal - centralCirclePos) * attractionStrength * 0.1;\n        electron1Pos += (mouseLocal - electron1Pos) * attractionStrength * 0.1;\n        electron2Pos += (mouseLocal - electron2Pos) * attractionStrength * 0.1;\n    }\n    \n    if (glitchActive > 0.0)\n    {\n        float glitchOffset = (hash(vec2(t, id.y)) - 0.5) * glitchStrength;\n        electron1Pos.x += glitchOffset;\n        electron2Pos.x -= glitchOffset;\n        centralCirclePos.y += glitchOffset;\n    }\n    \n    float centralCircle = circle(uv, centralCirclePos, 0.1);\n    float electron1 = circle(uv, electron1Pos, 0.08);\n    float electron2 = circle(uv, electron2Pos, 0.06);\n    \n    float trail = 0.0;\n    int numTrails = 10;\n    for (int i = 1; i <= numTrails; i++) {\n        float fi = float(i) / float(numTrails);\n        float timeOffset = t - fi * 0.05;\n        \n        float radius1_t = 0.1 + 0.05 * sin(timeOffset + rand5 * 6.2831);\n        float radius2_t = 0.1 + 0.05 * cos(timeOffset + rand6 * 6.2831);\n        \n        vec2 electron1Offset_t = vec2(\n            sin(timeOffset * (1.567 + rand7 * 2.0) + sin(timeOffset * (0.987 + rand8 * 2.0))) * radius1_t,\n            cos(timeOffset * (0.876 + rand1 * 2.0) + cos(timeOffset * (1.234 + rand2 * 2.0))) * radius1_t\n        );\n        \n        vec2 electron2Offset_t = vec2(\n            sin(timeOffset * (1.789 + rand3 * 2.0) + sin(timeOffset * (1.345 + rand4 * 2.0) + 3.14159)) * radius2_t,\n            cos(timeOffset * (1.456 + rand5 * 2.0) + cos(timeOffset * (0.543 + rand6 * 2.0) + 3.14159)) * radius2_t\n        );\n        \n        vec2 electron1Pos_t = centralCirclePos + electron1Offset_t;\n        vec2 electron2Pos_t = centralCirclePos + electron2Offset_t;\n        \n        trail += circle(uv, electron1Pos_t, 0.08) * (1.0 - fi) * 0.5;\n        trail += circle(uv, electron2Pos_t, 0.06) * (1.0 - fi) * 0.5;\n    }\n    \n    float blobs = centralCircle + electron1 + electron2 + trail;\n    blobs = clamp(blobs, 0.0, 1.0);\n    \n    vec3 color = cellColor * blobs;\n    \n    if (glitchActive > 0.0)\n    {\n        float colorShift = glitchStrength * 5.0;\n        float offsetR = hash(vec2(t, 1.0)) - 0.5;\n        float offsetG = hash(vec2(t, 2.0)) - 0.5;\n        float offsetB = hash(vec2(t, 3.0)) - 0.5;\n        \n        color.r += offsetR * colorShift;\n        color.g += offsetG * colorShift;\n        color.b += offsetB * colorShift;\n        \n        color = clamp(color, 0.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}