{"ver":"0.1","info":{"id":"DlKBWV","date":"1702563513","viewed":62,"name":"Raymarching Test 2 (RS)","username":"roey_shap","description":"Will update this as I go!\nFixed specular direciton thanks to @spalmer.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_MAX_STEPS 200\n#define MARCH_MAX_DIS 1000.0\n\n#define EPSILON 0.01\n#define LIGHT_EPSILON 0.00001\n\n#define PI 3.1415926535\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n\nfloat SDF_K = 8.0;\n\n// WANT TO REFERENCE THIS LATER\n// https://iquilezles.org/articles/distfunctions/\n// https://www.alanzucconi.com/2016/07/01/signed-distance-functions/\n\n\n// Math Aux\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nvec3 map(float min1, float max1, vec3 value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nvec3 roundTo(vec3 v, vec3 snap)\n{\n    return round(v / snap) * snap;\n}\n\nmat3 rotateX(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cosAngle, -sinAngle),\n        vec3(0.0, sinAngle, cosAngle)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(cosAngle, 0.0, sinAngle),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sinAngle, 0.0, cosAngle)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(cosAngle, -sinAngle, 0.0),\n        vec3(sinAngle, cosAngle, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nfloat mapPercentClamp(float value, float min2, float max2)\n{\n    return clamp(map(0.0, 1.0, value, min2, max2), min2, max2);\n}\n\n// SDF Aux\nvec4 intersectSDF(vec4 infoA, vec4 infoB) \n{\n    return infoA.w > infoB.w ? infoA : infoB;\n}\n/*\n// from https://www.alanzucconi.com/2016/07/01/signed-distance-functions/\nfloat smoothUnionSDF(float a, float b)\n{\n    float res = exp(-SDF_K * a) + exp(-SDF_K * b);\n    return -log(max(EPSILON, res)) / SDF_K;\n}\n\nvec3 smoothUnionSDF_Color(vec3 c1, vec3 c2, float dis1, float dis2, float dMix)\n{\n    return mix(c1, c2, max(dis1, dis2) / (dis1 + dis2));\n}\n*/\n\nvec4 unionSDF(vec4 infoA, vec4 infoB) \n{\n    return infoA.w < infoB.w ? infoA : infoB;\n}\n\nvec4 differenceSDF(vec4 infoA, vec4 infoB)\n{\n    return infoA.w > -infoB.w ? infoA : vec4(infoB.rgb, -infoB.w);\n}\n\nvec4 xorSDF(vec4 infoA, vec4 infoB)\n{\n    \n    return intersectSDF(unionSDF(infoA, infoB), -intersectSDF(infoA, infoB));\n}\n\n// https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\nvec4 smoothUnionSDF(vec4 a, vec4 b, float k) \n{\n    // squaring k here gives a weird lip to combinations\n  float h = clamp(0.5 + 0.5*(a.w-b.w) / k, 0., 1.);\n  vec3 c = mix(a.rgb,b.rgb, clamp(0.5 + 0.5*(a.w-b.w) / sqrt(k), 0., 1.));\n  float d = mix(a.w, b.w, h) - k*h*(1.-h); \n   \n  return vec4(c, d);\n}\n\nvec4 smoothIntersectSDF(vec4 a, vec4 b, float k) \n{\n  float h = clamp(0.5 - 0.5*(a.w-b.w) / k, 0., 1.);\n  vec3 c = mix(a.rgb,b.rgb, clamp(0.5 + 0.5*(a.w-b.w) / sqrt(k), 0., 1.));\n  float d = mix(a.w, b.w, h) + k*h*(1.-h); \n   \n  return vec4(c, d);\n}\n\nvec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n{\n  float h = clamp(0.5 - 0.5*(a.w+b.w) / k, 0., 1.);\n  vec3 c = mix(a.rgb,b.rgb, clamp(0.5 + 0.5*(a.w-b.w) / sqrt(k), 0., 1.));\n  float d = mix(a.w, -b.w, h) + k*h*(1.-h); \n   \n  return vec4(c, d);\n}\n\nfloat rounded(float d, float radiusJump)\n{\n    return d - radiusJump;\n}\n\nvec3 repeatSpace(vec3 position, vec3 snap)\n{\n    return position - roundTo(position, snap);\n}\n\n// broken :/\n/*\nvec3 repeatSpaceStagger(vec3 position, vec3 snap)\n{\n    vec3 pTag = repeatSpace(position, snap);\n    pTag += float(1 & int((pTag.x + position)/snap.x));\n    return pTag;\n}\n*/\n\nvec3 warpSpace(vec3 position, vec3 snap)\n{\n    return position + roundTo(position, snap);\n}\n\n// Shape SDFs\nfloat sphereSDF(vec3 position, vec3 center, float radius)\n{\n    return length(position - center) - radius;\n}\n\n// from https://iquilezles.org/articles/distfunctions/\nfloat cubeSDF(vec3 p, vec3 center, mat3 rotations, float b)\n{\n    p = ((p - center) * rotations) + center;\n    vec3 d = abs(p - center) - (b * 0.75);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat planeSDF(vec3 p, vec3 planeNormal, float h)\n{\n    return dot(p, planeNormal) + h;\n}\n\nvec4 sceneSDF(in vec3 samplePoint) \n{   \n    float wrapValue = 7.5;\n    vec3 repeatedPoint = repeatSpace(samplePoint, vec3(wrapValue));\n    repeatedPoint.xz += 0.5 * sin(length(samplePoint));\n    samplePoint = repeatedPoint;\n    vec4 finalDist = vec4(BLACK, MARCH_MAX_DIS);\n    \n    vec3 sphere1Pos = vec3(sin(iTime) - 1.0, 0.0, 0.0);\n    float sphere1Radius = 0.75;\n    vec3 sphere1Col = RED;\n    vec3 cubePos = vec3(-sin(iTime) + 1.0, 0.0, 0.0);\n    vec3 cubeCol = BLUE;\n    \n    float sphere1Dis = sphereSDF(repeatedPoint, sphere1Pos, sphere1Radius);\n    mat3 xRot = rotateX(sin(iTime) * HALF_PI / 4.0);\n    mat3 yRot = rotateY(cos(iTime + 1.0) * HALF_PI / 2.0);\n    float squareEdgeRad = 0.25;\n    float squareSideLength = 0.8 - squareEdgeRad;\n    float cubeDis = rounded(cubeSDF(repeatedPoint, cubePos, xRot * yRot, squareSideLength), squareEdgeRad);\n    finalDist = smoothUnionSDF(vec4(sphere1Col, sphere1Dis), vec4(cubeCol, cubeDis), 0.2);\n    \n    \n    //finalDist = smoothUnionSDF(vec4(WHITE, cubeDist), finalDist, 0.2);\n    \n    float planeDis = planeSDF(samplePoint, vec3(0.0, 1.0, 0.0), 1.0);\n    vec3 planeCol = WHITE;\n    finalDist = unionSDF(finalDist, vec4(planeCol, planeDis));\n    \n    return finalDist;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    vec2 eps = vec2(LIGHT_EPSILON, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + eps.xyy).w - sceneSDF(p - eps.xyy).w,\n        sceneSDF(p + eps.yxy).w - sceneSDF(p - eps.yxy).w,\n        sceneSDF(p + eps.yyx).w - sceneSDF(p - eps.yyx).w\n    ));\n}\n\n\nfloat getObjectIntersectionDistance(vec3 camPos, vec3 viewRayDir, inout vec4 color)\n{\n    color.a = 1.0;\n    float distanceMarched = 0.0;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++)\n    {\n        vec4 safeStepDistanceInfo = sceneSDF(camPos + (distanceMarched * viewRayDir));\n        float smallestDistanceToObj = safeStepDistanceInfo.w;\n        if (smallestDistanceToObj < EPSILON)\n        {\n            color.rgb = safeStepDistanceInfo.rgb;\n            return distanceMarched;\n        }\n        \n        distanceMarched += smallestDistanceToObj;\n        \n        // give up\n        if (distanceMarched >= MARCH_MAX_DIS)\n        {\n            return MARCH_MAX_DIS;\n        }\n    }\n    \n    // give up\n    return MARCH_MAX_DIS;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float focalDistance = map(-1.0, 1.0, sin(sqrt(iTime)), 0.65, 0.9);\n    float introPercent = map(0.0, 10.0, iTime, 0.0, 1.0);\n    float camY = mapPercentClamp(introPercent, -0.95, 0.3);\n    vec3 camPos = vec3(0.0, camY, focalDistance + 3.0);\n    mat3 cameraRotation = rotateZ(-PI * mapPercentClamp(introPercent, 0.04, -0.02));\n\n    float smallerDim = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / smallerDim;\n\n    vec3 pixelPos = vec3(uv, camPos.z - focalDistance);\n    vec3 pixelCamDelta = pixelPos - camPos;\n    vec3 viewRayDir = normalize(pixelPos - camPos);\n    \n    pixelPos -= pixelCamDelta;\n    pixelPos *= cameraRotation;\n    pixelPos += pixelCamDelta;\n    viewRayDir *= cameraRotation;\n\n    vec4 hitColor;\n    float objDistance = getObjectIntersectionDistance(camPos, viewRayDir, hitColor);\n    \n    vec3 hitPoint = camPos + (objDistance * viewRayDir);\n    \n    vec3 skyColor = vec3(0.0, length(uv), length(uv));\n    vec3 col = vec3(0.0);\n    float shadowStrength = 0.0;\n    \n    // assume we have a single point light\n    float lx = 1.0;\n    float ly = 2.0; \n    float lz = -2.0; //map(-1.0, 1.0, sin(1.2 * iTime), 1.0, -3.0);\n    vec3 lightPosition = vec3(lx, ly, lz);\n    \n    if (objDistance < MARCH_MAX_DIS)\n    {\n        //vec3 lightPosition = vec3(map(-1.0, 1.0, sin(iTime), -1.5, 0.5) + 1.0, -1.0, map(-1.0, 1.0, sin(iTime), -1.5, 0.5));\n        vec3 directionToLight = normalize(lightPosition - hitPoint);\n        \n        vec3 surfaceNormal = estimateNormal(hitPoint);\n        \n        // check if it's in shadow\n        vec3 shadowRayOrigin = hitPoint + (6.5 * EPSILON * surfaceNormal);\n        vec3 shadowRayDir = directionToLight;\n        vec4 shadowColor;\n        float shadowCheckDis = getObjectIntersectionDistance(shadowRayOrigin, shadowRayDir, shadowColor);\n        if (shadowCheckDis < MARCH_MAX_DIS)\n        {\n            vec3 shadowHitPoint = shadowRayOrigin + (shadowRayDir * (shadowCheckDis + (3.0 * EPSILON)));\n            vec3 shadowHitNormal = estimateNormal(shadowHitPoint);\n            shadowStrength = map(-1.0, 1.0, dot(shadowHitNormal, shadowRayDir), 1.0, 0.6);\n        }\n        \n        vec3 ambient = hitColor.rgb;\n        float ks = 0.8;\n        float kd = 0.5;\n        float shineSharpness = 10.0;\n        vec3 specularColor = vec3(1.0, 1.0, 1.0);\n        vec3 diffuseColor = vec3(1.0, 1.0, 0.0);\n        vec3 reflectedLightDir = reflect(-directionToLight, surfaceNormal);\n        vec3 surfaceToCameraDir = -viewRayDir;\n        float cosShineAmount = dot(reflectedLightDir, surfaceToCameraDir);\n        float specularAngleIntensity = cosShineAmount > 0.0 ? pow(cosShineAmount, shineSharpness) : 0.0;\n\n        vec3 specular = ks * specularAngleIntensity * specularColor;\n        float diffusionFactor = dot(directionToLight, surfaceNormal);\n        vec3 diffuse = kd * diffusionFactor * diffuseColor;\n        \n        col += ambient + specular + diffuse;\n        \n        col = mix(col, BLACK, shadowStrength);\n    }\n    else\n    {\n        /*float d = planeSDF(vec3(0.0, -1.0, 0.0), vec3(0.0, -2.0, 0.0), cameraPosition, viewRayDirection);\n        if (d < CLIPPING_PLANE_FAR)\n        {\n            //col = vec3(1.0);\n            col += vec3(1.0 - (d / CLIPPING_PLANE_FAR));\n        }\n        else\n        {\n            col = skyColor;\n        }*/\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}