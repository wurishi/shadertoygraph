{"ver":"0.1","info":{"id":"ml2SRh","date":"1678720112","viewed":102,"name":"Foldster Cel Shader","username":"foldster","description":"Cel Shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D to 3D\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c*v.x - s*v.y, s*v.x + c*v.y);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n  vec3 k = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  return v*c + cross(k, v)*s + k*dot(k, v)*(1.0-c);\n}\n\n#define pi 3.14159265\n#define tau 6.2821853\n\n#define EPS (1.0/iResolution.x)\n#define EPSX vec2(1.0*EPS,0.0)\n#define EPSY vec2(0.0,1.0*EPS)\n\n#define to01(v) ((v+1.0)*0.5)\n\n#define up2(v) (normalize(vec2(v.x,abs(v.y))))\n#define up3(v) (normalize(vec3(v.x,v.y,abs(v.z))))\n\n// f one param\n#define f1d_ds(f,s) ((f(s+EPS)-f(s-EPS))/(2.0*EPS))\n#define f1d_dv(f,v) (vec2(f(v+EPSX)-f(v-EPSX),f(v+EPSY)-f(v-EPSY))/(2.0*EPS))\n#define f1lap(f,v) ((4.0*f(v)-f(v+EPSX)-f(v-EPSX)-f(v+EPSY)-f(v-EPSY))/(EPS*EPS))\n\n#define f1norm1(f,s) up2(vec2(f1d_ds(f,s),-1.0))\n#define f1norm2(f,v) up3(vec3(f1d_dv(f,v).x,f1d_dv(f,v).y,-1.0))\n\n// f two param\n#define f2d_ds(f,c1,s) ((f(c1,s+EPS)-f(c1,s-EPS))/(2.0*EPS))\n#define f2d_dv(f,c1,v) (vec2(f(c1,v+EPSX)-f(c1,v-EPSX),f(c1,v+EPSY)-f(c1,v-EPSY))/(2.0*EPS))\n\n#define f2norm1(f,c1,s) up2(vec2(f2d_ds(f,c1,s),-1.0))\n#define f2norm2(f,c1,v) up3(vec3(f2d_dv(f,c1,v).x,f2d_dv(f,c1,v).y,-1.0))\n\n// f three param\n#define f3d_ds(f,c1,c2,s) ((f(c1,c2,s+EPS)-f(c1,c2,s-EPS))/(2.0*EPS))\n#define f3d_dv(f,c1,c2,v) (vec2(f(c1,c2,v+EPSX)-f(c1,c2,v-EPSX),f(c1,c2,v+EPSY)-f(c1,c2,v-EPSY))/(2.0*EPS))\n\n#define f3norm1(f,c1,c2,s) up2(vec2(f3d_ds(f,c1,c2,s),-1.0))\n#define f3norm2(f,c1,c2,v) up3(vec3(f3d_dv(f,c1,c2,v).x,-1.0,f3d_dv(f,c1,c2,v).y))\n\nconst vec2 O2 = vec2(0.0, 0.0);\nconst vec3 O3 = vec3(0.0, 0.0, 0.0);\nconst vec4 O4 = vec4(0.0, 0.0, 0.0, 0.0);\nconst vec2 X2 = vec2(1.0, 0.0);\nconst vec2 Y2 = vec2(0.0, 0.0);\nconst vec3 X3 = vec3(1.0, 0.0, 0.0);\nconst vec3 Y3 = vec3(0.0, 1.0, 0.0);\nconst vec3 Z3 = vec3(0.0, 0.0, 1.0);\n\n#define norm2dTo3d(v,angle) to01(up3(rotate(vec3(v.x, 0.0, v.y),Z3,angle)))\n\n// symmetric mod: returns the remainder in (-y/2,y/2)\nfloat smod(float x, float y) {\n  return mod(x + y*0.5, y) - y*0.5;\n}\n\n// 2d cross product\nfloat cross2(vec2 a, vec2 b) {\n  return a.x*b.y - a.y*b.x;\n}\n\n// gets the distance of a line to a point\nfloat lineDist(vec2 pl1, vec2 pl2, vec2 pn) {\n  vec2 p1 = normalize(pl2 - pl1);\n  vec2 p2 = pn - pl1;\n  float s = sign(cross2(p1, p2));\n  return s*length(p2 - p1*dot(p1, p2));\n}\n\n// gets the vector perpindicular to the line with magnitude\n// of the distance to the line\nvec2 lineNormal(vec2 pl1, vec2 pl2, vec2 pn) {\n  vec2 p1 = normalize(pl2 - pl1);\n  vec2 p2 = pn - pl1;\n  return (p2 - p1*dot(p1, p2));\n}\n\n\nfloat bevel(float setpoint, float amount, float t) {\n  return smoothstep(setpoint-amount, setpoint+amount, t);\n}\n\n/////////////////////////////////////////////////////////////////////\n//  _     ___ ____  ____      _    ______   __  _____ _   _ ____   //\n// | |   |_ _| __ )|  _ \\    / \\  |  _ \\ \\ / / | ____| \\ | |  _ \\  //\n// | |    | ||  _ \\| |_) |  / _ \\ | |_) \\ V /  |  _| |  \\| | | | | //\n// | |___ | || |_) |  _ <  / ___ \\|  _ < | |   | |___| |\\  | |_| | //\n// |_____|___|____/|_| \\_\\/_/   \\_\\_| \\_\\|_|   |_____|_| \\_|____/  //\n//                                                                 //\n/////////////////////////////////////////////////////////////////////\n\n\nfloat sigil(vec2 uv) {\n  \n  int sectors = 3;\n  float circ_radius = 0.25;\n  float circ_offset = 0.65;\n  float wedge_theta = 2.5;\n  float wedge_stop  = -0.01;\n  float wedge_offset = 0.06;\n  float border = 0.1;\n  \n  float theta = atan(uv.y, uv.x); // 0.0 to 1.0\n  float theta_s = smod(atan(uv.y, uv.x), tau/float(sectors));\n  float wedge_theta_s = wedge_theta/float(sectors);\n  float radius = length(uv);\n  \n  if (radius > 1.0) {\n    return 0.0;\n  }\n  \n  vec2 uv_s = radius*vec2(cos(theta_s), sin(theta_s));\n  \n  // Wedges\n  if (abs(theta_s) < wedge_theta_s/2.0) {\n    vec2 p1 = vec2(cos(wedge_theta_s/2.0), sin(wedge_theta_s/2.0));\n    vec2 p2 = vec2(cos(-wedge_theta_s/2.0), sin(-wedge_theta_s/2.0));\n    \n    float l1 = -lineDist(O2, p1, uv_s);\n    float l2 =  lineDist(O2, p2, uv_s);\n    float l3 =  lineDist(p1, p2, uv_s);\n    \n    \n    if (l1 > wedge_offset && l2 > wedge_offset && l3 < wedge_stop) {\n      \n      float b_off1      = bevel(wedge_offset, border, l1);\n      float b_off2      = bevel(wedge_offset, border, l2);\n      float b_stop      = bevel(wedge_stop, -border, l3);\n      \n      return min(min(b_off1, b_off2), b_stop);\n      \n    }\n    \n  }\n  \n  vec2 circ1 = circ_offset*vec2(cos(tau/float(2*sectors)), sin(tau/float(2*sectors)));\n  vec2 circ2 = circ_offset*vec2(cos(-tau/float(2*sectors)), sin(-tau/float(2*sectors)));\n  \n  if (distance(uv_s, circ1) <= circ_radius || distance(uv_s, circ2) <= circ_radius) {\n    float circle_bevel = bevel(circ_radius, -0.1, min(distance(uv_s, circ1), distance(uv_s, circ2)));\n    return circle_bevel;\n  }\n  return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n  vec2 uv = 2.0*fragCoord/iResolution.yy - 1.0;\n  \n  vec3 normal = up3(f1norm2(sigil,uv));\n  float height = sigil(uv);\n  float lap = f1lap(sigil,uv);\n  \n  vec3 light_source = normalize(vec3(2.0*iMouse.xy/iResolution.yy - 1.0, -1.0));\n  \n  if (distance(uv, light_source.xy) < 0.05) {\n    fragColor = vec4(1.0);\n    return;\n  }\n  \n  if (distance(uv, iMouse.xy) < 0.05) {\n    fragColor = vec4(1.0);\n    return;\n  }\n  \n\n  \n  vec3 light_vector = vec3(uv, height) - light_source;\n  float shadow = to01(dot(normal, light_vector));\n \n  vec3 color = shadow > 0.5 ? vec3(0.900, 0.758, 0.154) : vec3(0.2);\n  color = (lap > 80.0 && shadow > 1.00) ? vec3(1.0) : color;\n  \n  color = (height < 0.6) ? vec3(0.3) : color;\n  \n  // Output the colour for this pixel.\n  fragColor = vec4(color, 1.0);\n  \n}\n\n","name":"Image","description":"","type":"image"}]}