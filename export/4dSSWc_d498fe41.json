{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float PI = 3.14159265;\n\nfloat width = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\t\n    vec2 pos = fragCoord.xy/iResolution.xy - vec2(0.5);\n    \n    vec3 col = vec3(0.0); //Will be filled with twister later on\n    \n    float a = (sin(iTime*1.4+pos.y)*3.0)*pos.y+iTime*1.2; //Rotation value\n    vec4 twister = vec4(sin(a), sin(a+0.5*PI), sin(a+PI), sin(a+1.5*PI))*width; //Contains \"vertices\"\n    \n    vec4 alpha=vec4( //If here in x should be filled or not. Multiply color with this\n        (1.0-clamp(((pos.x-twister.x)*(pos.x-twister.y))*100000.0, 0.0, 1.0)),\n        (1.0-clamp(((pos.x-twister.y)*(pos.x-twister.z))*100000.0, 0.0, 1.0)),\n        (1.0-clamp(((pos.x-twister.z)*(pos.x-twister.w))*100000.0, 0.0, 1.0)),\n        (1.0-clamp(((pos.x-twister.w)*(pos.x-twister.x))*100000.0, 0.0, 1.0))\n    );\n    \n    alpha *= vec4( //Test if line is facing the way it will be showing\n    \t1.0-clamp((twister.x-twister.y)*10000.0, 0.0, 1.0),\n    \t1.0-clamp((twister.y-twister.z)*10000.0, 0.0, 1.0),\n    \t1.0-clamp((twister.z-twister.w)*10000.0, 0.0, 1.0),\n    \t1.0-clamp((twister.w-twister.x)*10000.0, 0.0, 1.0)\n    );\n\n    vec4 shade=vec4(\n    \ttwister.y-twister.x,\n    \ttwister.z-twister.y,\n    \ttwister.w-twister.z,\n    \ttwister.x-twister.w\n    );\n    \n    shade /= width*1.8;\n\n    col.rgb += texture(iChannel0, vec2(((pos.x-((twister.x+twister.y)/2.0))/(twister.x-twister.y))*width, pos.y)).rgb * alpha.x * shade.x;\n    col.rgb += texture(iChannel1, vec2(((pos.x-((twister.y+twister.z)/2.0))/(twister.y-twister.z))*width, pos.y)).rgb * alpha.y * shade.y;\n    col.rgb += texture(iChannel2, vec2(((pos.x-((twister.z+twister.w)/2.0))/(twister.z-twister.w))*width, pos.y)).rgb * alpha.z * shade.z;\n    col.rgb += texture(iChannel3, vec2(((pos.x-((twister.w+twister.x)/2.0))/(twister.w-twister.x))*width, pos.y)).rgb * alpha.w * shade.w;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSSWc","date":"1416328029","viewed":425,"name":"Simple twister textured","username":"luutifa","description":"Four points, rotate the points by sin of y, time and stuff. (points are 1D, in x)\nDraw a horizontal line between each point, but only if p1 < p2 (\"side\" is \"visible\")\nI have no idea why the hell the texturing works.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["twister"],"hasliked":0,"parentid":"","parentname":""}}