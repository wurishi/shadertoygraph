{"ver":"0.1","info":{"id":"3dXcWS","date":"1585410423","viewed":304,"name":"Glass Flower","username":"JuliaPoo","description":"Small experiment with distance deformation. Change f between 0 to 3 for a different flower.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","glass","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define f 1\n\nconst float END = 20.;\nconst float ep = 0.001;\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat cube(vec3 p, float b, float r){\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r){\n \treturn length(p) - r;  \n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat light(vec3 p){\n    vec3 move = vec3(0., sin(iTime), 0.);\n    vec3 off = vec3(0., -1., 0.);\n    vec3 p_ = p - move + off; p_.xy *= rot(iTime * 3.); p_.zy *= rot(iTime * 2.);\n\treturn min(cube(p_, .17, 0.), sphere(p + move + off, .2)); \n}\n\n# define ang 6.2831853 / 5.\n# define frames 9\n\nstruct PETAL {\n    float curve1;\n    float curve2;\n    float curve3;\n    float curve4;\n    float curve5;\n    float wide;\n    float bound;\n    float opt;\n};\n\nPETAL ptlayers[frames] = PETAL[frames](PETAL(1., .9, 1.0, 0., 0., 1.5, 3.5, .6),\n                                       PETAL(1., .9, 1.0, .1, .2, 1.3, 3.5, .6),\n                                       PETAL(1.7, .9, 0.8, .1, .2, 1.0, 3.5, .4),\n                                       PETAL(2.3, .9, 0.5, .1, .3, 1.0, 3.5, .4),\n                                       PETAL(3., .9, 0.5, .5, .3, 1.0, 3.5, .4),\n                                       PETAL(3., .9, 0.5, .5, .3, 1.0, 3.5, .4),\n                                       PETAL(3., .9, 0.5, .5, .5, 1.0, 3.5, .4),\n                                       PETAL(3., .9, 0.5, .5, .7, 1.0, 3.5, .4),\n                                       PETAL(3., .9, 0.5, .5, .9, 1.0, 3.5, .4));\nfloat ptoffsetx[frames] = float[frames](3., 2.5, 1.8, 1.6, 1.6, 1.6, 1.5, 1.3, 1.);\nfloat ptoffsety[frames] = float[frames](.0, .0, .2, .2, .0, .0, .0, .0, .0);\n\nfloat sdPetal(vec3 P, PETAL pt)\n{\n    \n    vec3 p, p0;\n    \n    P.xy *= rot(-pt.curve5);\n\tp = P;\n    \n    // Contain the heavy distortion to speed up raytracing\n    float bound = length(p) - pt.bound;\n    float d = bound + 1.;\n    if (bound < 0.)\n    {\n        p0 = p;\n        p.y = p0.y - sin(p0.x*pt.curve3) * pt.curve1 + cos(p0.z)*pt.curve2;\n        p.xy *= rot(-p0.y * pt.curve4);\n        float petal = sdEllipsoid(p, vec3(2., 0.3, 1.5*pt.wide)) * pt.opt;\n        \n        d = petal;\n    }\n    \n    return d;\n}\n\n\nfloat sdPetals(vec3 P)\n{\n    \n    vec3 p;\n    float d;\n\n    p = P;\n\n    // Repeat radially\n    float a = mod(atan(p.z,p.x), ang) - ang/2.;\n    p.xz = vec2(length(p.xz), 0.) * rot(a);\n\n    p.x -= ptoffsetx[f];\n    p.y -= ptoffsety[f];\n    d = sdPetal(p, ptlayers[f]);\n    \n    return d;\n}\n\nfloat obj(vec3 P)\n{\n    vec3 p;\n    float d;\n    \n    p = P*2.;\n    float Petals = sdPetals(p);\n    \n    p = P;\n    p.y += 1.7;\n    float base = sdEllipsoid(p, 1.4*vec3(1., .5, 1.));\n    \n    d = min(Petals, base)/2.;\n    \n    return d;\n}\n\nfloat mirror(vec3 p){\n    float ripples = 0.1*sin(3.*length(p.xz) - iTime*pow(abs(sin(iTime*0.1)*0.5), 4.));\n    //return plane(p, vec4(0.,1.,0., 1.1)) + ripples;\n    return cube(p + vec3(0., 4., 0.), 1.7, 0.3) + ripples;\n}\n\nfloat SDscene(vec3 p){\n   \n\tfloat obj = obj(p);\n    float mirror = mirror(p);\n    float light = light(p);\n    float d = min(min(obj, mirror), light);\n    \n    return d;\n}\n\nvec3 SDnormal(vec3 p){\n    \n    //Calculates the normal vector of SDscene\n    \n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z))-SDscene(vec3(p.x-ep,p.y,p.z)),\n    SDscene(vec3(p.x,p.y+ep,p.z))-SDscene(vec3(p.x,p.y-ep,p.z)),\n    SDscene(vec3(p.x,p.y,p.z+ep))-SDscene(vec3(p.x,p.y,p.z-ep))\n    ));\n}\n\nfloat depth(vec3 ro, vec3 rd, float sig, inout float min_l){\n    \n    //Returns depth from ro given raydirection\n    \n    int max=300;\n    vec3 p;\n    \n    float dist=0., d;\n    for (int i=0; i<max; i++){\n        p = ro + dist*rd;\n    \td = SDscene(p)*sig;\n        if (light(p) < min_l){ min_l = light(p);}\n    if (abs(d)<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > END){\n        return END;\n    }\n  }\n}\n\nvoid ray_mirror(inout vec3 ro, inout vec3 rd, inout float d, inout float min_l){\n    \n    int Nmax = 15, count = 0;\n    while (count < Nmax){\n        \n        ro -= rd*ep*5.;\n        rd = normalize(reflect(rd, SDnormal(ro)));\n        d = depth(ro, rd, 1., min_l);\n        ro += d*rd;\n       \n        if (mirror(ro) > ep){break;}\n        \n        count += 1;\n    }\n}\n\nvoid ray_obj(inout vec3 ro, inout vec3 rd, inout float Dglass, inout float d, inout float min_l){\n    \n    int Nmax = 15, count = 0, count2 = 0;\n    vec3 p, rd_;\n    while (count < Nmax){\n        \n        //Go into glass\n        ro += rd * ep*50.;\n        rd = normalize(refract(rd, SDnormal(ro), 0.6));\n        d = depth(ro, rd, -1., min_l);\n        ro += rd * d;\n    \tDglass += d;\n        \n        //internal refraction\n    \trd_ = refract(rd, -SDnormal(ro), 1.5);\n       \twhile (length(rd_) < 0.0001 && count2 < Nmax){\n            \n            rd = normalize(reflect(rd, -SDnormal(ro)));\n            d = depth(ro, rd, -1., min_l);\n            ro += d*rd;\n            \n            Dglass += d;\n            rd_ = refract(rd, -SDnormal(ro), 1.5);\n            count2 += 1;\n        }\n  \n        if (length(rd_) > 0.0001){rd = normalize(rd_);}\n        ro += rd * ep*10.;\n        d = depth(ro, rd, 1., min_l);\n        ro += rd * d;\n        \n        if (obj(ro) > ep){break;}\n        \n        //if (mirror(ro) > ep){ break;}\n      \t\n\t\tcount += 1;\n    }\n}\n\n\nvoid fresnel(vec3 ro, vec3 rd, inout float refl, inout float refr){\n \t   \n   \tfloat b = ((1. - 1.5)/(1. + 1.5));\n    float r0 = b*b;\n    refl = r0 + (1. - r0)*pow((1. - abs(dot(SDnormal(ro), normalize(rd)))), 5.);\n    refr = 1.-refl;\n    //refl = .5; refr = .5;\n}\n\nvec3 render(vec2 uv){\n    vec3 col;\n    \n    //Camera\n    float ScreenSize = 4.;\n    float shake = .7*sin(.3*iTime);\n    \n    float zoom = 2.5;\n    float k = 0.4;\n    float osc = sin(iTime*.3); //3.5 + 2.*osc*osc\n  \tvec3 ro = 6.*vec3(sin(k*iTime), shake, cos(k*iTime)) + vec3(0.,2.,0.);\n  \tvec3 lookat = vec3(0,0,0);\n    \n    \n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw;\n  \tvec3 scrP = scrC + (uv.x*r + uv.y*up) * ScreenSize;\n  \tvec3 rd = normalize(scrP - ro);\n    \n    float Dglass, min_l = END;\n    float d = depth(ro, rd, 1., min_l);\n    ro += d*rd;\n    \n    vec3 ro_, rd_;\n    float refl, refr;\n    int Nmax = 15, count;\n    while (count < Nmax){\n        //hits background\n        if (d > END - ep){\n            col += texture(iChannel0, ro).xyz;\n            vec3 tint = vec3(exp(Dglass*-0.05),exp(Dglass*-0.3),exp(Dglass*-0.7));\n            col *= tint;\n            col += pow(clamp(abs(1./min_l)*0.1, 0., 1.), .7);\n            break;\n        }\n        \n        //hit light\n        else if (light(ro) < ep){\n        \tcol += vec3(1.);\n            break;\n        }\n\n        //hit obj\n        else if (obj(ro) < ep){\n            ro_ = ro; rd_ = rd;\n            ray_obj(ro, rd, Dglass, d, min_l);\n            ray_mirror(ro_, rd_, d, min_l);\n        }\n\n        //hit mirror\n        else if (mirror(ro) < ep){\n            ray_mirror(ro, rd, d, min_l);\n        }\n        \n        else{d = END;}\n        \n        count += 1;\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float degree = .35*pow(0.538502*(sin(3.*iTime) + sin(iTime * 1.8)),8.) + .1;\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5*R)/R.x;\n    vec3 col = render(uv);\n    fragColor = vec4(col ,1.);\n    \n}","name":"Image","description":"","type":"image"}]}