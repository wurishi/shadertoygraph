{"ver":"0.1","info":{"id":"lXSGzV","date":"1708704471","viewed":61,"name":"Darboux Cyclide Rays","username":"delajor","description":"Wanted to do some work exploring Darboux Cyclides.  Working through using volume ray casting\nRed is cyclide, green is quadric.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","cube","darbouxcyclide"],"hasliked":0,"parentid":"l3S3RV","parentname":"volume ray casting primitive"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\nfloat quadricSDF(vec4 p, mat4 Q) {\n    \n    float X2 = dot(p,p);\n    \n    float Qx = dot(p, Q * p); //ptRtQRp\n    return -Qx;\n}\n\nfloat darbouxSDF(vec4 p, mat4 Q, vec3 L, float lambda) {\n    vec3 pd = p.xyz + Q[3].xyz;\n    pd = p.xyz;\n    float X2 = dot(pd,pd);\n\n    float Qx = dot(p, Q * p); //ptRtQRp\n    float Lx = dot(L, pd);\n\n    \n    float Db = lambda * X2*X2 + Lx * X2 + Qx;\n    //return A*xx + B*yy + C*zz + J;\n    //return length(p) - 1.0;\n    //return pow(dot(p,p), 0.1) + J;\n    return Db;\n}\n\n\nvec4 transfer(vec3 p){\n    p =1.5 * p;\n    vec3 N0 = normalize(vec3(1.0, 1.0, 0.0));\n    vec3 Nt = cross(vec3(0.0, 1.0, 0.0), N0);\n    vec3 N1 = normalize(cross(N0, Nt));\n    vec3 N2 = normalize(cross(N0, N1));\n    mat3 R = mat3(N0, N1, N2);\n    float \n    A = 0.2,\n    B = -1.5,\n    C = -2.0,\n    D = -0.0,\n    E = 0.0,\n    F = 0.0,\n    G = 0.0,\n    H = 0.0,\n    I = 0.0,\n    J = 0.5,\n    lambda = 1.0,\n    mu = 0.05,\n    nu = 0.1,\n    kappa = -0.1;\n    //mu = D + E + G,\n    //nu = D + F + H,\n    //kappa = E + F + I;\n    \n    mat4 Q = mat4(A, D, E, G,\n                  D, B, F, H,\n                  E, F, C, I,\n                  G, H, I, J);\n    vec3 L = 0.5*vec3(mu, nu, kappa);\n    vec4 p4 = vec4(R*p, 1.0);\n    vec4 Db = darbouxSDF(p4, Q, L, lambda) < 0.0 ? vec4(1.0, 0.0, 0.0, 0.01) : vec4(0.0);\n    vec4 Qt = quadricSDF(p4, Q) < 0.0 ? vec4(0.0, 1.0, 0.0, 0.01) : vec4(0.0);\n\n    return Db + Qt;\n}\n\nvec2 intersect_box(vec3 orig, vec3 dir) {\n  const vec3 box_min = vec3(-1);\n  const vec3 box_max = vec3(1);\n  vec3 inv_dir = 1.0 / dir;\n  vec3 tmin_tmp = (box_min - orig) * inv_dir;\n  vec3 tmax_tmp = (box_max - orig) * inv_dir;\n  vec3 tmin = min(tmin_tmp, tmax_tmp);\n  vec3 tmax = max(tmin_tmp, tmax_tmp);\n  float t0 = max(tmin.x, max(tmin.y, tmin.z));\n  float t1 = min(tmax.x, min(tmax.y, tmax.z));\n  return vec2(t0, t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n\n    vec2 t_hit = intersect_box(orig, dir);\n    \n    if (t_hit.x > t_hit.y){\n        fragColor = vec4(0.0);\n        return;\n    }\n\n\n      // We don't want to sample voxels behind the eye if it's\n      // inside the volume, so keep the starting point at or in front\n      // of the eye\n      t_hit.x = max(t_hit.x, 0.0);\n\n      ivec3 volume_dims = ivec3(100);\n\n      // Step 3: Compute the step size to march through the volume grid\n      vec3 dt_vec = 1.0 / (vec3(volume_dims) * abs(dir));\n      float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z));\n\n      // Step 4: Starting from the entry point, march the ray through the volume\n      // and sample it\n      vec3 p = orig + t_hit.x * dir;\n      //gl_FragColor= vec4(p, 1.00);\n      //return;\n      vec4 color = vec4(0.0);\n\n      for (float t = t_hit.x; t < t_hit.y; t += dt) {\n\n        vec4 val_color = transfer(p);\n        //vec4 val_color = vec4(p, 0.01);\n        \n\n        // Step 4.2: Accumulate the color and opacity using the front-to-back\n        // compositing equation\n        color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;\n        color.a += (1.0 - color.a) * val_color.a;\n\n        // Optimization: break out of the loop when the color is near opaque\n        if (color.a >= 0.95) {\n          break;\n        }\n        p += dir * dt;\n        }\n    fragColor = color;\n    \n}","name":"Image","description":"","type":"image"}]}