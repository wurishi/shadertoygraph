{"ver":"0.1","info":{"id":"McVGDW","date":"1712805684","viewed":60,"name":"2. Drawing axis","username":"nitish","description":"Playlist: https://www.shadertoy.com/playlist/s33cWf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nvec4 plotAxis(vec2 uv) {\n    float thickNess = 5.0 / iResolution.x;\n    \n    /*\n    let thickNess = 0.1;\n    \n    step(-thickNess, uv.y) will produce \n                0 for uv.y < -0.1 [-infity, -0.1]\n                1 for uv.y > -0.1 [-0.1, infinity]\n                \n    \n    step(uv.y, thickNess) => Please look carefully, input are switched\n    This will produce\n            0 for 0.1 < uv.y or uv.y > 0.1 [0.1, infinity]\n            1 for 0.1 > uv.y or uv.y < 0.1 [-infinity, 0.1]\n            \n     \"AND\" bright side of  both the domain\n            [-0.1, infinity] * [-infinity, 0.1] = [-0.1, 0.1]\n            \n            [-0.1, 0.1] is the common area where both the domains are white\n            \n            \n    */\n    \n    float xAxis = step(-thickNess, uv.y) * step(uv.y, thickNess);\n    float yAxis = step(-thickNess, uv.x) * step(uv.x, thickNess);\n    \n    \n    // Restricting xAsix line between [-1, 1]\n    xAxis *= step(abs(uv.x), 1.0);\n    \n    uv = abs(uv);\n    \n    for(int i = 0; i <= 10; ++ i) {\n        xAxis = xAxis +\n        // Left side of line thinkness\n        step(float(i) * 0.1 - thickNess, uv.x) *\n        // right side of the line thicness\n        step(uv.x, float(i) * 0.1 + thickNess) *\n        // Height of the axis\n        step(uv.y, 4. * thickNess);\n        \n        yAxis = yAxis +\n        // Left side of line thinkness\n        step(float(i) * 0.1 - thickNess, uv.y) *\n        // right side of the line thicness\n        step(uv.y, float(i) * 0.1 + thickNess) *\n        // Height of the axis\n        step(uv.x, 4. * thickNess);\n    }\n    \n    return vec4(vec3(xAxis + yAxis), 1.0);\n    \n}\n\n// This will convert our input range from [width,height] to\n// [-1, 1] domain, with (0,0) as the center\nvec2 normalizeCoords(vec2 uv) {\n    \n    /*\n   let o = uv / iResolution.xy => current point / total dimension will give range between [0,1]\n    o = o * 2. => will change domain from [0, 2]\n    o = 0 - 1. => Shift domain to [-1, 1]\n    */\n    \n    vec2 p = uv / iResolution.xy * 2.0 - 1.0;\n    p.x = p.x * iResolution.x / iResolution.y;\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = normalizeCoords(fragCoord);\n    \n    float circle = step(length(uv), 0.6);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(circle * 0.5), 1.0) + plotAxis(uv);\n}","name":"Image","description":"","type":"image"}]}