{"ver":"0.1","info":{"id":"tsGSDz","date":"1577209161","viewed":76,"name":"ryan noise","username":"rmccampbell7","description":"different noise functions","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hashes from https://www.shadertoy.com/view/4djSRW\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat vnoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 t = smoothstep(0., 1., f);\n    return mix(mix(hash1(i+vec2(0,0)), hash1(i+vec2(1,0)), t.x),\n               mix(hash1(i+vec2(0,1)), hash1(i+vec2(1,1)), t.x), t.y);\n}\n\nvec2 grad(vec2 p, float adjust) {\n    float theta = (hash1(p)-.5) * (1.+adjust) * 6.283185;\n    return vec2(cos(theta), sin(theta));\n}\n\nfloat pnoise(vec2 p, float adjust) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 t = smoothstep(0., 1., f);\n    return mix(\n        mix(dot(grad(i+vec2(0,0), adjust), f-vec2(0,0)),\n            dot(grad(i+vec2(1,0), adjust), f-vec2(1,0)), t.x),\n        mix(dot(grad(i+vec2(0,1), adjust), f-vec2(0,1)),\n            dot(grad(i+vec2(1,1), adjust), f-vec2(1,1)), t.x),\n        t.y);\n}\nfloat pnoise(vec2 p) { return pnoise(p, 0.); }\n\nfloat vfbm(vec2 p, int oct) {\n    float n = 0.;\n    for (int i=0; i<oct; i++) {\n        float f = exp2(float(i));\n        n += vnoise(p * f) / f;\n    }\n    return n;\n}\n\nfloat fbm(vec2 p, int oct, float adjust) {\n    float n = 0.;\n    for (int i=0; i<oct; i++) {\n        float f = exp2(float(i));\n        n += pnoise(p * f, adjust) / f;\n    }\n    return n;\n}\nfloat fbm(vec2 p, int oct) { return fbm(p, oct, 0.); }\n\nvec4 voronoi(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 d = vec2(1.5);\n    vec2 id;\n    for (int j=-1; j<=1; j++) {\n\t    for (int i=-1; i<=1; i++) {\n            vec2 g = n + vec2(i, j);\n            vec2 r = hash2(g) + vec2(i, j) - f;\n            float d2 = dot(r, r);\n            if (d2 < d.x) {\n                d.y = d.x;\n                d.x = d2;\n                id = g;\n            } else if (d2 < d.y) {\n                d.y = d2;\n            }\n        }\n    }\n    return vec4(sqrt(d), id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    //col = vec3(hash1(fragCoord+iTime*.001));\n    //col = vec3(vnoise(fragCoord*1./32.));\n    //col = vec3(vfbm(fragCoord*1./32., 5)*.5);\n    //col = vec3(pnoise(fragCoord*1./32.)*sqrt(.5)+.5);\n    //col = vec3(fbm(fragCoord*1./64.+iTime*.4, 5, .5*iTime)*sqrt(.5)+.5);\n    vec4 v = voronoi(fragCoord*1./64.+iTime*.5);\n    //col = (1.-v.x)*pow(hash3(v.zw + floor(iTime*2.)*137.), vec3(1.2));\n    col = smoothstep(.05,.1,v.y-v.x)*pow(hash3(v.zw + floor(iTime*2.)*137.), vec3(1.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}