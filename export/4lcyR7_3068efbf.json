{"ver":"0.1","info":{"id":"4lcyR7","date":"1531936917","viewed":191,"name":"Catan Dice","username":"Veggiebob","description":"Using intersection of box and sphere distance fields to get this shape that looks like the dice in Catan. I also used some fractal coloring just for extra fun :) Mouseable","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mouse","distancefields","intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define bigness 0.1\n#define EPSILON pow(10., -4.)\nfloat align (float diff, float dim){\n    if(diff>=dim){\n        return diff-dim;\n    } else {\n        return 0.;\n    }\n}\nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\nfloat sphere (vec3 spherePos, vec3 pos, float radius){\n    return length(pos-spherePos)-radius;\n}\nfloat SDF (vec3 p){\n    float rad = bigness*sqrt(2.);\n    float d1 = sphere(vec3(0.), p, rad);\n    float d2 = box3D(vec3(0.), vec3(bigness), p);\n    return max(d1, d2);\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<128; i++){\n        p = o+r*t;\n        float d = SDF(p);\n        t+=d*0.6;\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n//made this one myself with some tutorials I found out there on the \nfloat diffuseLight (vec3 n, vec3 r){\n    return dot(n, -r);\n}\nfloat specularLight (vec3 n, vec3 r){\n    vec3 nr = reflect(r, n);\n    float d = dot(nr, -r);\n    return pow(max(dot(nr, -r), 0.), 8.);\n}\nvec3 fractalColor (vec3 p, float iters){\n    vec3 c = texture(iChannel1, p).rgb;\n    for(float i = 0.; i<iters; i++){\n        c+=texture(iChannel1, p*pow(2., i)).rgb*pow(0.8, i);\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=5.;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float camDist = mouse.y+bigness*2.;\n    vec3 camera = vec3(cos(mouse.x)*camDist, 0., sin(mouse.x)*camDist);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    ray = normalize(ray);\n    \n    vec4 v = trace(camera, ray);\n    vec3 normal = estimateNormal(v.xyz);\n    vec3 col = fractalColor(v.xyz, 5.);//fractalize\n    col*=1./length(col);//normalize\n    //vec3 randomize = texture(iChannel1, v.xyz*10.).xyz-0.5; \n    //col = texture(iChannel0, estimateNormal(v.xyz)+randomize*0.05).rgb;\n    col+=specularLight(normal, ray)*0.1;\n    col+=diffuseLight(normal, ray)*0.3;\n\tfloat fog = 1./(1.+pow(v.w, 10.)*0.1);\n    col*=fog;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}