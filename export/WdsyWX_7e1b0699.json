{"ver":"0.1","info":{"id":"WdsyWX","date":"1585728473","viewed":229,"name":"Mandelbrot Journey(Control+Long)","username":"dashed_man","description":"Mandelbrot journey :3\n\nUse mouse to move.\nArrows left/right to zoom.\nArrows up/down to change brightness.\nHold Space to draw Julia set with point in center.\n.-.\nTo get moar zoom change EXPERIMENTAL in Common\n","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks:\n// Keyboard - https://www.shadertoy.com/view/lsXGzf\n// Mouse - https://www.shadertoy.com/view/Mss3zH\n// Numbers - https://www.shadertoy.com/view/4sf3RN\n// Saved state - https://www.shadertoy.com/view/4tfBzn\n\n\n//read Describes\n//check Common\n\n\n/*\nz = z^2 + c\n\nz := x+iy\nz^2 = x^2-y^2 + i2xy\n\nrz = x^2-y^2+rc\niz = i2xy + ic\n\nif |z|>2 => point tend to inf\n*/\n\n\n\n//Copyed state class method...\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\nvoid LoadState(out JourneyState s)\n{\n    vec4 tmpData;\n    #if EXPERIMENTAL\n    tmpData = LoadValue(0, 0);\n    s.zoom = tmpData.x;\n    s.center_x.Z = int(tmpData.y);\n    s.center_y.Z = int(tmpData.z);\n    s.brightness = tmpData.w;\n    \n    ivec4 tmpDatai = ivec4(LoadValue(1, 0));\n    s.center_x.E = (tmpDatai.x<<16)|tmpDatai.y;\n    s.center_y.E = (tmpDatai.z<<16)|tmpDatai.w;\n    \n    uvec4 tmpDatau;\n    for(int i=0;i<EXPERIMENTAL;i++){\n        tmpDatau = uvec4(LoadValue(i, 1));\n        s.center_x.M[i] = tmpDatau.x;\n    \ts.center_y.M[i] = tmpDatau.y;\n    }\n    #else\n    tmpData = LoadValue(0, 0);\n    s.center_x = tmpData.x;\n    s.center_y = tmpData.y;\n    s.zoom = tmpData.z;\n    s.brightness = tmpData.w;\n    #endif\n}\n//endcopy\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Loading...\n    JourneyState s;\n    LoadState(s);\n    vec3 col =  texelFetch(iChannel2, ivec2(fragCoord), 0).xyz*10.*s.brightness;\n    \n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord*2.f-iResolution.xy)/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord.xy / iResolution.xx;\n    // Normalized mouse (from 0 to 1)\n    vec4 m = iMouse / iResolution.xxxx * vec4(1.0, 1.0, 1.0, -1.0);\n\n    \n    ///////////////////////////////////////////////////////////\n    //Center point\n    col +=  vec3(0.6) *( 1.0-smoothstep(0.01f,0.02f, length(uv)) );\n    \n    //Mouse navigator\n    if( m.z>0.0 )\n\t{\n\t\tfloat d = distanceToSegment( m.xy, m.zw, xy );\n        col +=  vec3(0.3) *( 1.0-smoothstep(0.f,0.01, d) );\n        col += vec3(0.3) *( 1.0-smoothstep(0.01,0.015, length(xy-abs(m.xy))) );\n      \tcol += vec3(0.3) *( 1.0-smoothstep(0.01,0.015, length(xy-abs(m.zw))) );\n\t}\n    \n    \n    //PRINT ZONE\n    \n\t//Print Zoom \n    col = mix( col, \\\n               vec3(0.6), \\\n               PrintValue(fragCoord,\\\n                          vec2(70.f,iResolution.y-20.f), \\\n                          s.zoom, \\\n                          2.0, \\\n                          1.0)\n              );\n    \n    //Print XY\n    #if EXPERIMENTAL\n    col = mix( col, \\\n               vec3(0.6), \\\n               PrintValue(fragCoord,\\\n                          vec2(10.f,iResolution.y-40.f), \\\n                          LF2f(s.center_x), \\\n                          2.0, \\\n                          12.0)\n              );\n    col = mix( col, \\\n               vec3(0.6), \\\n               PrintValue(fragCoord,\\\n                          vec2(10.f,iResolution.y-60.f), \\\n                          LF2f(s.center_y), \\\n                          2.0, \\\n                          12.0)\n              );\n    #else\n    col = mix( col, \\\n               vec3(0.6), \\\n               PrintValue(fragCoord,\\\n                          vec2(10.f,iResolution.y-40.f), \\\n                          iMouse.z, \\\n                          2.0, \\\n                          7.0)\n              );\n    col = mix( col, \\\n               vec3(0.6), \\\n               PrintValue(fragCoord,\\\n                          vec2(10.f,iResolution.y-60.f), \\\n                          iMouse.w, \\\n                          2.0, \\\n                          7.0)\n              );\n    #endif    \n    \n    //*/\n    fragColor = vec4(col,0.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//State buffer\n\n    \n//...and state class methods\n//\n//low-level methods\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\nvoid StoreValue(ivec2 bufferCoord, vec4 dataToSave, inout vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 intFragCoord = ivec2(fragCoord);\n    if( intFragCoord!=bufferCoord )return;\n    fragColor = dataToSave;\n}\n\n\n//high-level methods\nvoid LoadState(out JourneyState s)\n{\n    vec4 tmpData;\n    #if EXPERIMENTAL\n    tmpData = LoadValue(0, 0);\n    s.zoom = tmpData.x;\n    s.center_x.Z = int(tmpData.y);\n    s.center_y.Z = int(tmpData.z);\n    s.brightness = tmpData.w;\n    \n    ivec4 tmpDatai = ivec4(LoadValue(1, 0));\n    s.center_x.E = (tmpDatai.x<<16)|tmpDatai.y;\n    s.center_y.E = (tmpDatai.z<<16)|tmpDatai.w;\n    \n    uvec4 tmpDatau;\n    for(int i=0;i<EXPERIMENTAL;i++){\n        tmpDatau = uvec4(LoadValue(i, 1));\n        s.center_x.M[i] = tmpDatau.x;\n    \ts.center_y.M[i] = tmpDatau.y;\n    }\n    #else\n    tmpData = LoadValue(0, 0);\n    s.center_x = tmpData.x;\n    s.center_y = tmpData.y;\n    s.zoom = tmpData.z;\n    s.brightness = tmpData.w;\n    #endif\n}\n\n\nvec4 SaveState(in JourneyState s, in vec2 fragCoord)\n{\n    if (iFrame <= 0)\n    {\t\n        #if EXPERIMENTAL\n        s.center_x = f2LF(-0.5f);\n        s.center_y = f2LF(0.f);\n   \t\t#else\n\t\ts.center_x = -0.5f;\n        s.center_y = 0.f;\n        #endif\n        s.zoom = 0.f;\n        s.brightness = 10.f;\n    }\n    \n    vec4 colorData = vec4(0.);\n    #if EXPERIMENTAL\n    StoreValue(ivec2(0,0), vec4(s.zoom, s.center_x.Z, s.center_y.Z, s.brightness), colorData, fragCoord);\n    StoreValue(ivec2(1,0), vec4(s.center_x.E>>16, \\\n                                s.center_x.E&0xffff, \\\n                                s.center_y.E>>16, \\\n                                s.center_y.E&0xffff), colorData, fragCoord);\n    for(int i=0;i<EXPERIMENTAL;i++){\n        StoreValue(ivec2(i,1), vec4(s.center_x.M[i]&HOOK, \\\n                                    s.center_y.M[i]&HOOK, \\\n                                    0., 0.), colorData, fragCoord);\n    }\n    \n    #else\n\tStoreValue(ivec2(0,0), vec4(s.center_x, s.center_y,  s.zoom,   s.brightness),   colorData, fragCoord);\n    #endif\n\treturn colorData;\n}\n//endClass\n\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //Loading...\n    JourneyState s;\n    LoadState(s);\n    \n   \n    if(bool(texelFetch( iChannel1, ivec2(KEY_RIGHT,0) ,0).x)){\n        s.zoom -= 2.f*iTimeDelta;\n    }\n    if(bool(texelFetch( iChannel1, ivec2(KEY_LEFT,0) ,0).x)){\n        s.zoom = min(1.f,s.zoom+2.f*iTimeDelta);\n    }\n    if(bool(texelFetch( iChannel1, ivec2(KEY_UP,0) ,0).x)){\n        s.brightness = min(100.f,s.brightness*(2.*iTimeDelta+1.));\n    }\n    if(bool(texelFetch( iChannel1, ivec2(KEY_DOWN,0) ,0).x)){\n        s.brightness = max(0.05,s.brightness/(2.*iTimeDelta+1.));\n    }\n\t#if EXPERIMENTAL\n   \n    if(iMouse.z>0.f){\n        s.center_x = sum(s.center_x, \\\n                         mul(f2LF( (iMouse.x-iMouse.z)*2.f*iTimeDelta/iResolution.y ), \\\n                             LFexp2(s.zoom))\n                        );\n        s.center_y = sum(s.center_y, \\\n                         mul(f2LF( (iMouse.y-iMouse.w)*2.f*iTimeDelta/iResolution.y ), \\\n                             LFexp2(s.zoom))\n                        );\n        \n    }\n\t//*/\n    #else\n    if(iMouse.z>0.f){\n        s.center_x += (iMouse.x - iMouse.z) * 2.f * iTimeDelta * exp2(s.zoom)/iResolution.y;\n        s.center_y += (iMouse.y + iMouse.w) * 2.f * iTimeDelta * exp2(s.zoom)/iResolution.y;\n    }\n    #endif\n\n    // Saving...\n    fragColor = SaveState(s,fragCoord);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define KEY_LEFT \t37\n#define KEY_UP \t\t38\n#define KEY_RIGHT \t39\n#define KEY_DOWN  \t40\n#define KEY_SPACE \t32\n\n#define PI \t\t\t3.1415926535\n\n//change on int >= 0 to use EXPERIMENTAL version\n//be carefull\n// 0 - off:-20 zoom\n// 1 - no comments:0 zoom\n// 2 - -25 zoom\n// 3 - -40 zoom\n// 4 - -55 zoom\n#define EXPERIMENTAL 0\n// after compilation need reset time!!!\n\nprecision highp float;\nprecision highp int;\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n//Long Float Class with Base 2^16\n#if EXPERIMENTAL\nconst uint HOOK = 0xffffu;\t\t \t // mask 0000 0000 0000 0000 1111 1111 1111 1111\nconst uint HOOK2 = 0xffff0000u;\t\t // mask 1111 1111 1111 1111 0000 0000 0000 0000\nfloat symmetric_mod(float x, float y){\n    return sign(x)*(abs(x)-y*floor(abs(x)/y));\n}\n\nstruct LongFloat\n{\n    int Z; \t\t\t\t    //sign\n    int E;\t\t\t\t\t//exp\n    uint M[EXPERIMENTAL];\t//mantice \n};\n    \n//METHODS\n\n//print(A) - Print for C language.\n    \n//f2LF(A) - convert float to LongFloat \n//LF2f(f) - convert LongFloat to float\n\n//sum(A,B) - sum of two LongFloats\n//sub(A,B) - substitution of two LongFloats\n//mul(A,B) - multiplication of two LongFloats\n//div(A,B) - division of two LongFloats  - NOT WORK!!!\n\n//LFexp2(x) - calculate LongFloat = 2^x. x is float\n\n/*\n// C print\n#include <stdio.h>\n#include <math.h>\n#define EXPERIMENTAL 4\n#define in  \ntypedef unsigned int uint;\nfloat mod(float x,float y){return x-y*floor(x/y);}\nfloat sign(float x){return x<0?-1:1;}\nfloat fract(float x){return x-floor(x);}\nint max(int a, int b){return a>b?a:b;}\nfloat max(float a, float b){return a>b?a:b;}\nfloat min(float a, float b){return a<b?a:b;}\n//up /\\\n\nLongFloat f2LF(float x);\nfloat LF2f(LongFloat C);\nvoid print(LongFloat a) {\n\tint size = EXPERIMENTAL;\n\tprintf(\"inverse float compilation: %.16f\\n\",LF2f(a));\n\t\n    for (int i = 0; i < size; i++) {\n        printf(\"%p \",a.M[i] & HOOK);\n    }\n    printf(\"e%d\\n\",a.E);\n\t//debug overflow bits\n    for (int i = 0; i < size; i++) {\n        printf(\"%p \",a.M[i] >> 16);\n    }\n    printf(\"\\n\");\n}\n\n//down \\/\nint main() {\n\tfloat a=3.4;\n\tfloat b=2.3;\n\n\tLongFloat la = f2LF(a);\n\tLongFloat lb = f2LF(b);\n \t\n\tprint(la);\n\tprintf(\"\\n\");\n\tprint(lb);\n \n\tprintf(\"\\n%f + %f = %.16f\\n\",a,b,a+b);\n\tprint(sum(la,lb));\n \n\tprintf(\"\\n%f - %f = %.16f\\n\",a,b,a-b);\n\tprint(sub(la,lb));\n \n\tprintf(\"\\n%f * %f = %.16f\\n\",a,b,a*b);\n\tprint(mul(la,lb));\n \n\tprintf(\"\\nexp2( %f )=%.16f\\n\",a,exp2(a));\n\tprint(LFexp2(a));\n\n\treturn 0;\n}\n//*/\n\n\n    \nLongFloat f2LF(float x){\n    LongFloat C;\n    //sign\n    C.Z = x<0.f?-1:1;\n    x*=float(C.Z);\n    if(x == 0.){ \n        //C.E = 0;//for C\n        //for(int i=0;i<EXPERIMENTAL;i++)C.M[i]=0u; //for C\n    \treturn C;\n    }\n    //exp\n    float x_e = floor(log2(x)/16.f);\n    // may be floor(floor(log2(x))/16.f)\n    C.E = int(x_e); \n    \n    //mantice\n\tx*=exp2((1.f-x_e)*16.f);\n\tuint x_m = uint(x);\n\t\n    C.M[0] = x_m>>16;\n    #if EXPERIMENTAL>1\n    C.M[1] = (x_m&HOOK);\n    #endif\n    #if EXPERIMENTAL>2\n    C.M[2] = uint(fract(x)*exp2(16.f));\n    #endif\n    //for(int i=3;i<EXPERIMENTAL;i++)C.M[i]=0u;//for C\n    return C;\n}\nfloat LF2f(LongFloat C){\n\tfloat f = 0.f;\n\t#if EXPERIMENTAL>2\n    \tf = float(C.M[2])*exp2(-16.f);\n    #endif\n\t#if EXPERIMENTAL>1\n    \tf += float((C.M[0]<<16)|(C.M[1]));\n    #else\n    \tf += float(C.M[0]<<16);\n    #endif\n\t\n    \n    //*/\n    return float(C.Z)*f*exp2(float(C.E-1)*16.f);\n}\n\n\n//Operator method\n\nLongFloat sum(in LongFloat A, in LongFloat B)\n{\n    \n\tLongFloat C;\n    int r = A.E-B.E;\n    C.E = max(A.E,B.E);\n    \n    \n    \n    if(A.Z==B.Z){\n        C = f2LF(LF2f(A)+LF2f(B));\n    \t/*if(r>0){     \n        \tfor(int i=EXPERIMENTAL-1;i>=0;i--){\n                if(i == EXPERIMENTAL-r)B.M[i-1] += ((B.M[i]<0x8000u)?0u:1u);\n\t            B.M[i] = i<r?0u:B.M[i-r];\n\t        }\n\t    }else if(r<0){\n\t        for(int i=EXPERIMENTAL-1;i>=0;i--){\n                if(i == EXPERIMENTAL+r)A.M[i-1] += ((A.M[i]<0x8000u)?0u:1u);\n\t            A.M[i] = i<-r?0u:A.M[i+r];\n\t        }\n\t    }\n        for(int i=EXPERIMENTAL-1;i>0;i--){\n            uint tmp = A.M[i] + B.M[i] + C.M[i];\n            C.M[i] = tmp&HOOK;\n            C.M[i-1] += tmp>>16;\n        }\n        C.M[0] = A.M[0] + B.M[0] + C.M[0];\n\t    if((C.M[0]>>16) > 0u){\n            #if EXPERIMENTAL>1\n\t        C.E++;\n\t        for(int i = EXPERIMENTAL-1;i>1;i--)\n\t            C.M[i] = C.M[i-1];\n\t        C.M[1] = C.M[0]&HOOK;\n            #endif\n\t        C.M[0] >>= 16;\n\t    }\n        C.Z=A.Z;//*/\n\n    }else{\n        C = f2LF(LF2f(A)+LF2f(B));\n        /*\n    \tuint tail=0x10000u;\n  \n    \tif(r>0){\n    \t\tfor(int i=EXPERIMENTAL-1;i>EXPERIMENTAL-1-r;i--){\n    \t\t\ttail=0xffffu-B.M[i]+(tail>>16);\n    \t\t}\n\t        for(int i=EXPERIMENTAL-1;i>=0;i--){\n\t            B.M[i] = i<r?0u:B.M[i-r];\n\t        }\n\t    }else if(r<0){\n\t    \ttail=0x0u;\n\t        for(int i=EXPERIMENTAL-1;i>=0;i--){\n\t            A.M[i] = i<-r?0u:A.M[i+r];\n\t        }\n\t    }\n\t    \n    \n    \tC.M[EXPERIMENTAL-1] = 0xffffu+A.M[EXPERIMENTAL-1]-B.M[EXPERIMENTAL-1]+(tail>>16);\n    \tfor(int i=EXPERIMENTAL-2;i>=0;i--){\n    \t\tC.M[i] = 0xffffu+A.M[i]-B.M[i]+(C.M[i+1]>>16);\n    \t}\n    \t\n    \tif((C.M[0]>>16)==1u){\n    \t\tC.Z=A.Z;\n    \t\tfor(int i=0;i<EXPERIMENTAL;i++)C.M[i] &= HOOK;\n    \t}else{\n    \t\tC.Z=-A.Z;\n    \t\tC.M[EXPERIMENTAL-1] = 0x10000u-(C.M[EXPERIMENTAL-1]&HOOK)-(r<0?1u:0u);\n    \t\tfor(int i=EXPERIMENTAL-2;i>=0;i--){\n\t    \t\tC.M[i] = 0xffffu-(C.M[i]&HOOK)+(C.M[i+1]>>16) ;\n\t    \t\tC.M[i+1] &= HOOK;\n\t    \t}\n    \t}\n\n    \tint i=0;\n    \twhile(i<EXPERIMENTAL){\n    \t\tif(C.M[i]!=0u)break;\n    \t\ti++;\n    \t}\n    \tif(i != EXPERIMENTAL){\n\t    \tfor(int j=0;j<EXPERIMENTAL;j++){\n\t    \t\tC.M[j] = j<EXPERIMENTAL-i?C.M[i+j]:0u;\n\t    \t}\n\t    \tC.E-=i;\n    \t}\n    \t//*/\n    \t\n    }\n//*/\n    return C; \n}\nLongFloat sub(in LongFloat A, in LongFloat B)\n{\n    B.Z *= -1;\n    return sum(A,B);\n}\n\nLongFloat mul(in LongFloat A, in LongFloat B)\n{\n    LongFloat C = f2LF(LF2f(A)*LF2f(B));\n/*\n\tLongFloat C;\n    //for(int i=0;i<EXPERIMENTAL;i++)C.M[i]=0u; // for C\n    C.E = A.E+B.E;\n    C.Z = A.Z*B.Z;\n \n    uint tmp;\n\t   \n    for(int i=EXPERIMENTAL-1;i>0;i--){\n        for(int j=EXPERIMENTAL-1;j>0;j--){\n            tmp=A.M[i]*B.M[j]+C.M[j];\n            C.M[j] = tmp & HOOK;\n            C.M[j-1] += tmp>>16;\n        }\n        tmp=A.M[i]*B.M[0]+C.M[0];\n        C.M[0] = tmp&HOOK;\n        for(int j=EXPERIMENTAL-1;j>0;j--)C.M[j]=C.M[j-1];\n        C.M[0] = tmp>>16;\n\t}\n    for(int j=EXPERIMENTAL-1;j>0;j--){\n        tmp=A.M[0]*B.M[j]+C.M[j];\n        C.M[j] = tmp & HOOK;\n        C.M[j-1] += tmp>>16;\n    }\n    C.M[0]+=A.M[0]*B.M[0];\n    \n    \n    if((C.M[0]>>16) != 0u){\n        #if EXPERIMENTAL>1\n        C.E++;\n        for(int i = EXPERIMENTAL-1;i>1;i--)\n            C.M[i] = C.M[i-1];\n        C.M[1] = C.M[0]&HOOK;\n        #endif\n        C.M[0] >>= 16;\n    }\n    \n//*/\n    return C;\n}\n\n\nLongFloat div(LongFloat A, LongFloat B)\n{\n    LongFloat C;\n\t// no idea :(\n    return C;\n}\n\n//math methods\n\nLongFloat LFexp2(float x){\n    LongFloat C = f2LF(exp2(symmetric_mod(x,16.f)));\n    C.E+=int(x)/16;\n\treturn C;\n}\n\n//*/\n#endif\n//endclass\n/////////////////////////////////////////////////////////////////////////////////////    \n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n//State class\nstruct JourneyState { \n    #if EXPERIMENTAL\n    LongFloat center_x;\n    LongFloat center_y;\n    #else\n    float center_x;\n    float center_y;\n    #endif\n    float brightness;\n    float zoom;\n};\n//methods in Buffer A^...\n//endclass\n/////////////////////////////////////////////////////////////////////////////////////  \n    \n    \n    \n    \n//\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\nvec3 colorShift(vec3 color,float shift){\n    float shift2 = fract(shift + 1./3.);\n    float shift3 = fract(shift - 1./3.);\n    shift = fract(shift);\n    return vec3(color.r*abs(shift-0.5)+ \\\n                color.g*abs(shift2-0.5)+ \\\n                color.b*abs(shift3-0.5), \\\n                \n                color.g*abs(shift-0.5)+ \\\n                color.b*abs(shift2-0.5)+ \\\n                color.r*abs(shift3-0.5), \\\n                \n                color.b*abs(shift-0.5)+ \\\n                color.r*abs(shift2-0.5)+ \\\n                color.g*abs(shift3-0.5) );\n}\n\n\n\n//NUMBERS\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\n#define FONT_SIZE\tvec2(8.0, 15.0)\n#ifndef BITMAP_VERSION\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\t\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\n\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\n#else\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\n#endif\n\nfloat PrintValue(const in vec2 vStringCharCoords, \\\n                 const in float fValue, \\\n                 const in float fMaxDigits, \\\n                 const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\n\nfloat PrintValue(in vec2 fragCoord, \\\n                 const in vec2 vPixelCoords, \\\n                 const in float fValue, \\\n                 const in float fMaxDigits, \\\n                 const in float fDecimalPlaces)\n{\n\treturn PrintValue( (fragCoord.xy - vPixelCoords)/FONT_SIZE, \\\n                       fValue, \\\n                       fMaxDigits, \\\n                       fDecimalPlaces);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#if EXPERIMENTAL\nbool LFMandelInf(in LongFloat real,in LongFloat imaginary){\n    LongFloat Z_mod = sum(mul(real,real), \\\n                   \t\t\t   mul(imaginary,imaginary));\n    if(Z_mod.E==0){\n        if(Z_mod.M[0]==4u)\n            for(int i=1;i<EXPERIMENTAL;i++){\n                if(Z_mod.M[i]>0u)return false;\n            }\n        return Z_mod.M[0]<=4u;\n    }\n    return Z_mod.E<0;\n\n}\n#endif\n\n\n//Copyed state class method...\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\nvoid LoadState(out JourneyState s)\n{\n    vec4 tmpData;\n    #if EXPERIMENTAL\n    tmpData = LoadValue(0, 0);\n    s.zoom = tmpData.x;\n    s.center_x.Z = int(tmpData.y);\n    s.center_y.Z = int(tmpData.z);\n    s.brightness = tmpData.w;\n    \n    ivec4 tmpDatai = ivec4(LoadValue(1, 0));\n    s.center_x.E = (tmpDatai.x<<16)|tmpDatai.y;\n    s.center_y.E = (tmpDatai.z<<16)|tmpDatai.w;\n    \n    uvec4 tmpDatau;\n    for(int i=0;i<EXPERIMENTAL;i++){\n        tmpDatau = uvec4(LoadValue(i, 1));\n        s.center_x.M[i] = tmpDatau.x;\n    \ts.center_y.M[i] = tmpDatau.y;\n    }\n    #else\n    tmpData = LoadValue(0, 0);\n    s.center_x = tmpData.x;\n    s.center_y = tmpData.y;\n    s.zoom = tmpData.z;\n    s.brightness = tmpData.w;\n    #endif\n}\n//endcopy\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Loading...\n    JourneyState s;\n    LoadState(s);\n    bool OPT_FLAG = true;\n    if(iFrame<=0)OPT_FLAG=false;\n\tfloat zoomdelt = 0.;\n    \n    if(bool(texelFetch( iChannel1, ivec2(KEY_SPACE,0) ,0).x)){\n        OPT_FLAG = false;\n    }\n    if(bool(texelFetch( iChannel1, ivec2(KEY_RIGHT,0) ,0).x)){\n        zoomdelt = -2.*iTimeDelta;\n        OPT_FLAG = false;\n    }\n    if(bool(texelFetch( iChannel1, ivec2(KEY_LEFT,0) ,0).x)){\n        zoomdelt = 2.*iTimeDelta;\n    }\n    \n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord*2.f-iResolution.xy)/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord.xy / iResolution.xx;\n    // Normalized mouse (from 0 to 1)\n    \n    \n    \n    //c = (uv)*exp2(s.zoom)+vec2(s.center_x,s.center_y);\n    //uv = (fragCoord*2.f-iResolution.xy)/iResolution.y;\n    //s.zoom -= 2.f*iTimeDelta;\n    if(OPT_FLAG){\n        if(iMouse.z>0.f){\n            vec2 coord = (fragCoord+(iMouse.xy - vec2(iMouse.z, -iMouse.w))*iTimeDelta)/iResolution.xy;\n            coord= 0.5+(coord-0.5)*exp2(zoomdelt);\n            if(coord.x>0.f && \\\n               coord.x<1.f && \\\n               coord.y>0.f && \\\n               coord.y<1.f){\n                //fragColor = mix(texture(iChannel2, coord),vec4(0.,0.5,0.,1.),0.0005);\n                fragColor = texture(iChannel2, coord);\n                fragColor.w = 1.;\n                return;\n            }\n        }else if(zoomdelt != 0.f){\n        \tvec2 coord = 0.5+(fragCoord/iResolution.xy-0.5)*exp2(zoomdelt);\n            if(coord.x>0.f && \\\n               coord.x<1.f && \\\n               coord.y>0.f && \\\n               coord.y<1.f){\n                fragColor = texture(iChannel2, coord);\n                //fragColor = mix(texture(iChannel2, coord),vec4(0.,0.5,0.,1.),0.0005);\n                fragColor.w = 1.;\n                return;\n            }\n        }else{\n            fragColor = texelFetch(iChannel2, ivec2(fragCoord),0);\n            if(fragColor.w == 0.){\n                return;\n            }\n        }\n    }\n    //*/\n    \n    \n    //Calculate\n    vec3 col = vec3(0.);\n    \n    float i = 0.f;\n    float MAX_ITER = 1536.f;//(2.f-s.zoom)*196.f;\n    #if EXPERIMENTAL\n    vec2 c = vec2(10.f);\n    if(s.zoom>-5.f){\n        c = (uv)*exp2(s.zoom)+ \\\n        vec2(LF2f(s.center_x), \\\n             LF2f(s.center_y));\n    }\n    #else\n    vec2 c = (uv)*exp2(s.zoom)+vec2(s.center_x,s.center_y);\n    #endif\n\n        \n        \n    #if EXPERIMENTAL\n    LongFloat realC = sum(mul(f2LF(uv.x), \\\n                              LFexp2(s.zoom)), \\\n                          s.center_x);\n    LongFloat imaginaryC = sum(mul(f2LF(uv.y), \\\n                                   LFexp2(s.zoom)), \\\n                               s.center_y);\n\n    LongFloat realZ = f2LF(0.);\n    LongFloat imaginaryZ = f2LF(0.);\n    LongFloat new_realZ;\n    LongFloat new_imaginaryZ;\n\n\n    LongFloat LONG_TWO;\n    LONG_TWO.Z=1;\n    LONG_TWO.M[0]=2u;\n    while(i<MAX_ITER && LFMandelInf(realZ,imaginaryZ)){\n        //rz = x^2-y^2+rc\n\n        new_realZ = sum(sub(mul(realZ, \\\n                                realZ), \\\n                            mul(imaginaryZ, \\\n                                imaginaryZ)), \\\n                        realC);\n        //iz = i2xy + ic\n        new_imaginaryZ = sum(mul(LONG_TWO, \\\n                                 mul(realZ, \\\n                                     imaginaryZ)), \\\n                             imaginaryC);\n\n        realZ = new_realZ;\n        imaginaryZ = new_imaginaryZ;\n        i++;\n    }\n\n\n    #else\n    vec2 z  = vec2(0.f);\n    while(i<MAX_ITER && dot(z,z) <= 4.f){\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        i++;\n    }\n    #endif\n    //MandelBrot color\n    float lambda = i/MAX_ITER;\n    if(i<MAX_ITER){\n        /*col = vec3( lambda, \\\n                    0., \\\n                    0.)*10.*s.brightness;//*/\n        col = vec3( lambda*0.5, \\\n                    min(0.5,lambda-0.5), \\\n                    0.5-lambda) *sin(lambda);//*/\n    }\n    \n    \n    //Calc Julia\n    if(bool(texelFetch( iChannel1, ivec2(KEY_SPACE,0) ,0).x)){\n        //Calculate\n    \tfloat i = 0.f;\n        #if EXPERIMENTAL\n        LongFloat realC = s.center_x;\n        LongFloat imaginaryC = s.center_y;\n        \n        LongFloat realZ = sum(f2LF(uv.x), \\\n                              s.center_x);\n        LongFloat imaginaryZ = sum(f2LF(uv.y), \\\n                                   s.center_y);\n        LongFloat new_realZ;\n        LongFloat new_imaginaryZ;\n        \n        \n        LongFloat LONG_TWO;\n        LONG_TWO.Z=1;\n        LONG_TWO.M[0]=2u;\n        while(i<MAX_ITER && LFMandelInf(realZ,imaginaryZ)){\n            //rz = x^2-y^2+rc\n\n            new_realZ = sum(sub(mul(realZ, \\\n                                    realZ), \\\n                                mul(imaginaryZ, \\\n                                    imaginaryZ)), \\\n                            realC);\n            //iz = i2xy + ic\n            new_imaginaryZ = sum(mul(LONG_TWO, \\\n                                     mul(realZ, \\\n                                         imaginaryZ)), \\\n                                 imaginaryC);\n            \n            realZ = new_realZ;\n            imaginaryZ = new_imaginaryZ;\n            i++;\n        }\n        \n        \n        #else\n        vec2 c = vec2(s.center_x,s.center_y);\n        vec2 z = vec2(uv);\n        while(i<MAX_ITER && dot(z,z) <= 4.f){\n            z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n            i++;\n        }\n        #endif\n        float lambda = i/MAX_ITER;\n        lambda = (1.f-pow(1.f-lambda,2.f));\n        if(i<MAX_ITER)col = mix(col, \\\n                                vec3( .2, \\\n                                      .2, \\\n                                      1. )*lambda, \\\n                                0.9);\n        else col = mix(col, \\\n                                vec3(0.), \\\n                                0.9);\n    }//*/\n    //col = mix(col,vec3(0.,1.,0.),0.5);\n    fragColor = vec4(col,0.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}