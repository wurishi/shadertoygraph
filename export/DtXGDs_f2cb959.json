{"ver":"0.1","info":{"id":"DtXGDs","date":"1672637828","viewed":146,"name":"Porter-Duff's Operators","username":"bestknighter","description":"Thomas Porter and Tom Duff, on their 1984's paper \"Compositing Digital Images\", came up with the alpha premultiplication and blending operators. Here's an interactive shader for exploring them.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["study","learning","alphablending","operator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://ciechanow.ski/alpha-compositing/\n\n/***************************************************************************\n * There are 5 defines that you can use on line 48 to                      *\n * choose which operator will be in effect. They are:                      *\n * - OVER : Traditional alpha blending; render source OVER destination     *\n * - OUT  : Render source only, and take OUT destination                   *\n * - IN   : Render source only, and only INSIDE where destination would be *\n * - ATOP : Render both but put source only ATOP of destination            *\n * - XOR  : Render both but remove the overlap                             *\n *                                                                         *\n *   Click and drag to move the blue circle around                         *\n **************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 uvMouse = iMouse/iResolution.xyxy;\n    aspectRatio = iResolution.x/iResolution.y;\n\n    vec4 composite = compFn(\n        vec4(1.0, 0.0, 0.0, 1.0)*0.8*square(uv, vec2(0.5), 0.24),\n        vec4(0.0, 0.0, 1.0, 1.0)*0.8*circle(uv, uvMouse.xy, 0.28),\n        OVER\n    );\n\n    // Output to screen\n    composite = opOver(transparencyGrid(uv, vec2(40.0)), composite);\n    fragColor = encondeSRGB(composite);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/***\nMIT License\n\nCopyright (c) 2023 Gabriel F B Barbosa                                     \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n***/\n\n// Although credits are not required,\n// they're strongly encouraged and very much appreciated!\n\n#define OVER 0\n#define OUT 1\n#define IN 2\n#define ATOP 3\n#define XOR 4\n\nfloat aspectRatio;\n\nfloat len(vec2 v) {\n    return sqrt(v.x*v.x + v.y*v.y);\n}\n\n// srgb-ish approximation\nvec4 encondeSRGB(vec4 color) {\n    color.rgb /= color.a;\n    color.rgb = pow(color.rgb, vec3(1.0/2.2))*color.a;\n    return color;\n}\n\n// srgb-ish approximation\nvec4 decodeSRGB(vec4 color) {\n    color.rgb /= color.a;\n    color.rgb = pow(color.rgb, vec3(2.2))*color.a;\n    return color;\n}\n\nvec4 transparencyGrid(vec2 uv, vec2 nSquares) {\n    nSquares *= vec2(aspectRatio, 1.0);\n    vec2 uvSize = vec2(1.0)/nSquares;\n    vec2 sqCoord = floor(uv/uvSize);\n    \n    return vec4(\n        vec3(1.0-0.5*mod(sqCoord.x+sqCoord.y, 2.0)),\n        1.0\n    );\n}\n\nfloat square(vec2 uv, vec2 pos, float uvSize) {\n    float feather = 0.0075/2.0;\n    vec2 dist = vec2(\n        min(uv.x-(pos.x-(uvSize/aspectRatio)), pos.x+(uvSize/aspectRatio)-uv.x),\n        min(uv.y-(pos.y-uvSize), pos.y+uvSize-uv.y)\n    );\n    return smoothstep(-feather, feather, min(dist.x, dist.y));\n}\n\nfloat circle(vec2 uv, vec2 pos, float r) {\n    float feather = 0.0075/2.0;\n    return smoothstep(r+feather, r-feather, len((uv-pos)*vec2(aspectRatio, 1.0)));\n}\n\nvec4 opOver(vec4 destination, vec4 source) {\n    return source + destination*(1.0-source.a);\n}\n\nvec4 opOut(vec4 destination, vec4 source) {\n    return destination*(1.0-source.a);\n}\n\nvec4 opIn(vec4 destination, vec4 source) {\n    return source*destination.a;\n}\n\nvec4 opAtop(vec4 destination, vec4 source) {\n    return source*destination.a + destination*(1.0-source.a);\n}\n\nvec4 opXor(vec4 destination, vec4 source) {\n    return source*(1.0-destination.a) + destination*(1.0-source.a);\n}\n\nvec4 compFn(vec4 destination, vec4 source, int operator) {\n    if(operator <= OVER)      return opOver(destination, source);\n    else if(operator == OUT)  return opOut (destination, source);\n    else if(operator == IN)   return opIn  (destination, source);\n    else if(operator == ATOP) return opAtop(destination, source);\n    else                      return opXor (destination, source);\n}","name":"Common","description":"","type":"common"}]}