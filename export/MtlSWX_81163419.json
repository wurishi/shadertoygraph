{"ver":"0.1","info":{"id":"MtlSWX","date":"1440256365","viewed":340,"name":"Experiment#DF Noise2","username":"tomkh","description":"A simple experiment tracing through a bare noise function. A new version: XlfXDl","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","distancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// A simple example tracing over value-noise\n// tomkh@2015\n\nconst int iterations = 260;\nconst float dist_eps = .004;\nconst float ray_max = 100.0;\nconst float fog_density = .05;\n\nconst float cam_dist = 14.7;\n\n// Estimated inverse \"steepness\" factor, drag mouse up/down to change:\nfloat invslope_factor = .98;\n\n//------------------------------------------------------------------------\n// Some of IQ's noise that is in fact a value-noise (not a gradient-noise)\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//------------------------------------------------------------------------\n\nfloat dField(in vec3 p)\n{\n   // Simply take a noise value * invslope_factor as a distance:\n   return (noise(p) - .2)*invslope_factor; \n}\n\nvec3 dNormal(in vec3 p)\n{\n   const float eps = .005;\n   const vec3 x_eps = vec3(eps,0,0);\n   const vec3 y_eps = vec3(0,eps,0);\n   const vec3 z_eps = vec3(0,0,eps);\n   return normalize(vec3(\n      dField(p + x_eps) - dField(p - x_eps),\n      dField(p + y_eps) - dField(p - y_eps),\n      dField(p + z_eps) - dField(p - z_eps) ));\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir, inout float ray_len)\n{\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = dField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\nvec4 shade(in vec3 ray_dir, in float ray_len, in vec3 light_dir, in vec4 hit)\n{\n   vec3 fog_color = vec3(.7);\n   \n   if (hit.w == 0.0) {\n      return vec4(fog_color, 1.0);\n   }\n   \n   vec3 norm = dNormal(hit.xyz);\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),ray_dir));\n   spec = pow(spec, 16.0)*.5;\n\n   vec3 base_color = vec3(1.0);\n   vec3 color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n   \n   float fog = 1.0 - 1.0/exp(ray_len*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n    \n   if (iMouse.z > 0.0) {\n   \t  invslope_factor = iMouse.y * 2.0 / iResolution.y;\n   }\n   \n   // Simple rotating camera:\n   float ang, si, co;\n   ang = sin(iTime*.5)*.05;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   float ray_len = 0.0;\n   vec4 hit = trace(pos, dir, ray_len);\n   fragColor = shade(dir, ray_len, light_dir, hit);\n}\n","name":"","description":"","type":"image"}]}