{"ver":"0.1","info":{"id":"llyBRG","date":"1542916626","viewed":494,"name":"4.6.12 Truchet","username":"fizzer","description":"Truchet tiling using the semi-regular tiling made of squares, hexagons, and dodecagons. This is based on the idea that any regular polygon with an even number of sides can be used as a Truchet tile. The big arrays seem to cause big slowdown on WebGL...","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","truchet","tiling","dodecagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Truchet tiling using the semi-regular tiling made of squares, hexagons, and dodecagons.\n// This is based on the idea that any regular polygon with an even number of sides can be used\n// as a Truchet tile.\n//\n// Inspired by this JavaScript canvas version here: http://somethingorotherwhatever.com/truchet-polygons/\n//\n// The side connection tables were pre-generated using my own rather brute-force program.\n//\n// 4.8^2 version is here: https://www.shadertoy.com/view/MlyBRG\n//\n// Weaved version is here: https://www.shadertoy.com/view/WsyXWR\n//\n\nfloat pi = 3.141592653589;\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n/*\n// Returns the origin and radius of a circle intersecting a and b, with tangents\n// at a and b pointing towards vec2(0). This is for drawing the circular arcs.\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r)\n{\n    float th = acos(dot(normalize(a), normalize(b))) / 2.;\n    float adj = length(a);\n    r = tan(th) *adj;\n    o = normalize((a + b) / 2.) * sqrt(r * r + adj * adj);\n}\n*/\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    if(dot(normalize(a), normalize(b)) < -.99999)\n    {\n        float d = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        return smoothstep(0.03, 0.03 - w * 2., d - .02);\n    }\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return smoothstep(0.03, 0.03 - w * 2., abs(distance(p, o) - r) - .02);\n}\n\n// Array of unique hexagon side connections without overlaps.\nconst float arr6[2*3*2] = float[2*3*2](\n    1., 2., 3., 4., 5., 6.,\n    1., 2., 3., 6., 4., 5.\n);\n\n// Array of unique dodecagon side connections without overlaps.\nconst float arr12[29*6*2] = float[29*6*2](\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 8. ,  9. , 10. ,  11. , 12. ,\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 8. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 12. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 6. ,  7. , 12. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 4. ,  5. , 8. ,  6. , 7. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 7. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 7. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 9. ,  7. , 8. ,  10. , 11. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 11. ,  7. , 8. ,  9. , 10. ,\n    1. , 2. ,  3. , 4. ,  5. , 12. ,  6. , 11. ,  7. , 10. ,  8. , 9. ,\n    1. , 2. ,  3. , 6. ,  4. , 5. ,  7. , 8. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 6. ,  4. , 5. ,  7. , 12. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 6. ,  4. , 5. ,  7. , 12. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 8. ,  4. , 5. ,  6. , 7. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 8. ,  4. , 7. ,  5. , 6. ,  9. , 12. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 7. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 7. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 9. ,  7. , 8. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 11. ,  7. , 8. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 5. ,  6. , 11. ,  7. , 10. ,  8. , 9. ,\n    1. , 2. ,  3. , 12. ,  4. , 7. ,  5. , 6. ,  8. , 9. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 7. ,  5. , 6. ,  8. , 11. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 9. ,  5. , 6. ,  7. , 8. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 9. ,  5. , 8. ,  6. , 7. ,  10. , 11. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 6. ,  7. , 8. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 6. ,  7. , 10. ,  8. , 9. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 8. ,  6. , 7. ,  9. , 10. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 10. ,  6. , 7. ,  8. , 9. ,\n    1. , 2. ,  3. , 12. ,  4. , 11. ,  5. , 10. ,  6. , 9. ,  7. , 8.\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 5.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    // The plane is first divided in to equilaterial triangles.\n    \n    float s = 1. / sqrt(3.);\n\n    vec2 op = p;\n\n    p.x /= s;\n    p.x += mod(floor(p.y), 2.);\n\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    if(fp.x > mix(fp.y, 1. - fp.y, mod(ip.x, 2.)))\n        ip.x += 1.;\n\n    fp = p - ip;\n\n    fp.x *= s;\n    fp.y -= 1. / 3. + mod(ip.x + 1., 2.) / 3.;\n\n    if(mod(ip.x, 2.) > .5)\n        fp.y =- fp.y;\n\n    float a = 0.;\n\n    vec3 col = vec3(1, 1, 0);\n\n    fp.x = abs(fp.x);\n\n    float th = pi * 2. / 3.;\n\n    // Use the symmetry of the figure within the triangular tile.\n    \n    if(dot(fp, vec2(cos(th), sin(th))) < 0.)\n        fp = fp - vec2(cos(th), sin(th)) * dot(fp, vec2(cos(th), sin(th))) * 2.;\n\n    fp.x = abs(fp.x);\n\n    float dd = fp.y;\n    dd = max(dd, dot(fp, vec2(sin(th), -cos(th))));\n\n\t// Get the precise distances of the tile edges.\n    \n    float c = tan(pi * 2. / 6.) / (3. * tan(pi * 2. / 6.) + 3.);\n    float e = 1. / 3. - c;\n    float f = 1. / (3. * cos(pi * 2. / 6.)) - c;\n\tfloat g = 0.;\n    \n    if(dd - c < 0.)\n    {\n        // Hexagon.\n        op = op * vec2(1. / s, 1) + vec2(.5, 0);\n        ip = floor(op);\n\n        vec2 fp = op - ip - .5;\n\n        fp.x *= s;\n        fp.y -= 1. / 6. * (1. - 2. * mod(ip.x + ip.y, 2.));\n\n        float th = pi * 2. / 6.;\n\n        float tha = th*(floor(6. * hash(ip * 3. + 2.)) + .5);\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        int i = int(floor(hash(ip * 13. + 99.) * 1.999));\n\n        for(int j = 0; j < 3; j += 1)\n        {\n            float ia = arr6[i * 6 + j * 2 + 0] - 1.;\n            float ib = arr6[i * 6 + j * 2 + 1] - 1.;\n            a += l(fp, c * vec2(cos(th * float(ia)), sin(th * float(ia))), c * vec2(cos(th * float(ib)), sin(th * float(ib))));\n        }\n\n        g = max(g, smoothstep(-w * 2., 0., dd - c));\n\n        col = vec3(1, 0, 0);\n    }\n    else if((abs(fp.x)-e)<0.)\n    {\n        // Square.\n        op = op * vec2(1. / s, 2) + vec2(.5 + .5 * mod(floor(op.y * 2. + .5), 2.), .5);\n        ip = floor(op);\n\n        vec2 fp = op - ip - .5;\n\n        fp.x *= s;\n        fp.y /= 2.;\n\n        float th = pi * 2. / 4.;\n\n        float tha = th * floor(3.999 * hash(ip * 3. + 2.));\n\n        if(mod(ip.y, 2.) > .5)\n            tha += pi * 2. / 3. * .5 * (2. - mod(ip.x + floor(ip.y / 2.), 2.));\n\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        a += l(fp, +e * vec2(0., 1.), +e * vec2(sin(th), cos(th)));\n        a += l(fp, -e * vec2(0., 1.), -e * vec2(sin(th), cos(th)));\n\n        g = max(g, smoothstep(e - w * 2., e, max(abs(fp.x), abs(fp.y))));\n\n        col = vec3(0, 0, 1);\n    }\n    else\n    {\n        // Dodecagon.\n        op = op * vec2(1. / s / 2., 1.) + vec2(.5 + .5 * mod(floor(op.y + .5), 2.), .5);\n        ip = floor(op);\n\n        vec2 fp = op - ip - .5;\n\n        fp.x *= s * 2.;\n\n        float th = pi * 2. / 12.;\n\n        float tha = th * floor(12. * hash(ip * 3.));\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        int i = int(floor(hash(ip * 13. + 99.) * 28.999));\n\n        float d = -1.;\n\n        for(int j = 0; j < 6; j+=1)\n        {\n            float ia = arr12[i * 12 + j * 2 + 0] - 1.;\n            float ib = arr12[i * 12 + j * 2 + 1] - 1.;\n            a += l(fp, f * vec2(cos(th * float(ia)), sin(th * float(ia))), f * vec2(cos(th * float(ib)), sin(th * float(ib))));\n            d = max(d, abs(dot(fp, vec2(cos(th * float(j)), sin(th * float(j))))) - f);\n        }\n\n        g = max(g, smoothstep(-w * 2., 0., d));\n    }\n\n    // Shade.\n    col = mix(col, vec3(1), .3) + .2;    \n    col = mix(col, vec3(0), g);\n\n    float l = 1. - (min(fract(iTime / 4.) * 2., 2. - 2. * fract(iTime / 4.)) - .5) * 16.;\n\n    fragColor.rgb = mix(vec3(.8), col, smoothstep(0., 1., l));\n\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), a);\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}