{"ver":"0.1","info":{"id":"llSSzc","date":"1445371285","viewed":353,"name":"StereoProj 4D","username":"Ouid","description":"First test of a stereographic projection in 4D. The raymarch is not well controlled, but it's difficult to navigate in such a world.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["4d","stereographic","tesseract","hypercube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Mathieu Simon aka Ouid (2015)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define DEBUG\n\n\n#define READPLANE(_PlaneId) readPlane ( _PlaneId )\n\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#if SHAPE == 0\n// 5 cell\n\n#define FOREACH_PLANES(_World,_Call) /*\n*/\t_Call(READPLANE(Object(10)),Object(10))/*\n*/\t_Call(READPLANE(Object(11)),Object(11))/*\n*/\t_Call(READPLANE(Object(12)),Object(12))/*\n*/\t_Call(READPLANE(Object(13)),Object(13))/*\n*/\t_Call(READPLANE(Object(14)),Object(14))\n    \n#elif SHAPE == 1\n//tesseract\n\n#define FOREACH_PLANES(_World,_Call) /*\n*/\t_Call(READPLANE(Object(10)),Object(10))/*\n*/\t_Call(READPLANE(Object(11)),Object(11))/*\n*/\t_Call(READPLANE(Object(12)),Object(12))/*\n*/\t_Call(READPLANE(Object(13)),Object(13))/*\n*/\t_Call(READPLANE(Object(14)),Object(14))/*\n*/\t_Call(READPLANE(Object(15)),Object(15))/*\n*/\t_Call(READPLANE(Object(16)),Object(16))/*\n*/\t_Call(READPLANE(Object(17)),Object(17))\n       \n#endif\n    \n#define SPHERE_SIZE 2.0\n#define SPHERE_OBJECT_RATIO 1.0\n          \n\nvec3 load3(in int planeV, in int Object)\n{\n    return texelFetch(iChannel0, ivec2(planeV,Object), 0).xyz;\n}\n\nfloat load(in int planeV, in int Object)\n{\n    return texelFetch(iChannel0, ivec2(planeV,Object), 0).x;\n}\n          \nHyperPlane readPlane(in Object _object)\n{\n    HyperPlane plane;\n    plane.m_normal[0] = load(0, _object.m_id-10);\n    plane.m_normal[1] = load(1, _object.m_id-10);\n    plane.m_normal[2] = load(2, _object.m_id-10);\n    plane.m_normal[3] = load(3, _object.m_id-10);\n    plane.m_d = load(4, _object.m_id-10);\n    \n    return plane;\n}              \n\nRay4Result rayCastCube ( in World _world, in Ray4 _ray )\n{  \n    Ray4Result rayResFront, rayResRear;\n    \n    rayResFront.m_d = 0.0;\n    rayResRear.m_d = MAX;\n    \n    // a cube is convex, so we can intersect all planes, this will give us a range of frontal max and rear min\n\t\n\t#define INTERSECT_PLANE_RANGE(_Plane,_PlaneId) intersectRayHyperPlaneRange ( _ray, _Plane, _PlaneId, rayResFront, rayResRear );\n\tFOREACH_PLANES(_world,INTERSECT_PLANE_RANGE)\n        \n\treturn rayResFront;\n}\n\nRay4Result rayCastWorld ( in World _world, in Ray4 _ray )\n{\n    return rayCastCube ( _world, _ray );\n}\n\n// Stereographic projection\n\nRay4Result stereographicProj ( in World _world, in vec3 _pos )\n{\n    // x;y;z;0 on hyperplane w=0\n    // on sphere of radius 1 => (2x/(R+1);2y/(R+1);2x/(R+1);R-1/R+1) where R = x²+y²+z²\n    \n    float R = dot(_pos,_pos);\n    \n    vec4 onSphere = vec4(2.0*_pos,R-1.0) / vec4(R+1.0);\n\n\tRay4 raySTC;\n    raySTC.m_pos = onSphere;\n    raySTC.m_dir = _world.m_cube.m_trans - onSphere;\n    \n    return rayCastCube ( _world, raySTC );\n}\n\n// standard [image -> screen -> view -> world] funcs\n\nvec2 imageToScreen ( in vec2 _uv )\n{\n    vec2 ratioUV = _uv.xy / iResolution.xy;\n    vec2 ratio = 2.0*iResolution.xy/vec2(min(iResolution.x,iResolution.y));\n    vec2 xy = (ratioUV*2.0-1.0)*ratio;\n    return xy;\n}\n\nvoid screenToWorld ( in Camera _camera, in vec2 _screenPos, float _z, out vec3 _pos )\n{\n    _pos = (_camera.m_matrix * vec4(_screenPos,_z,1.0)).xyz;    \n}\n\nvoid screenToRay ( in Camera _camera, in vec2 _screenPos, out Ray _ray )\n{\n    vec3 rayPoint;\n    \n    //fov is hardcoded here (distance of Z plane)\n    screenToWorld ( _camera, _screenPos, 3.0, rayPoint );        \n    \n    _ray.m_pos = _camera.m_matrix[3].xyz;\n    _ray.m_dir = normalize(rayPoint-_ray.m_pos);\n}\n\nvoid cameraLookAt ( in vec3 _eye, in vec3 _lookAtPos, in vec3 _up, out Camera _camera )\n{\n    vec3 front = normalize(_lookAtPos-_eye);    \n    vec3 left = normalize(cross(front, _up));\n    vec3 up = normalize(cross(left,front));\n    _camera.m_matrix[0] = vec4(left,0.0);\n    _camera.m_matrix[1] = vec4(up,0.0);\n    _camera.m_matrix[2] = vec4(front,0.0);\n    _camera.m_matrix[3] = vec4(_eye,1.0);\n}\n\n// color funcs\n\nvec3 computeMaterial ( in Ray4Result _rayResult )\n{\n    return load3(5, _rayResult.m_object.m_id-10);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // setup world, cam & light\n    \n    Camera cam;\n    World world;    \n     \n    world.m_sphere = Sphere4 ( vec4(0.0,0.0,0.0,0.5), 0.5 );\t\n    \n    \n    float animTime = iTime / 2.0;\n    \n    mat4 rot = rotationXY ( animTime*1.278914) * rotationXZ(animTime) * rotationYZ(animTime*0.332567);\n\t\n\trot *= rotationXW ( animTime*0.3565) * rotationYW(animTime*0.578246) * rotationZW(animTime*0.275689);\n    \n    float scaleFactor = 0.25; //world.m_sphere.m_radius/sqrt(4.0);\n    world.m_cube = Transform4 ( scale ( vec4(scaleFactor) ) * rot, world.m_sphere.m_pos );\n    \n   \n    cameraLookAt ( vec3(0.0,0.0,-6.5), vec3(0.0,0.0,1.0), vec3(0.0,1.0,0.0), cam );\n    \n\t// raymarch\n\t\n    vec2 xy = imageToScreen ( fragCoord );  \n    \n\tfloat rStop = 10.0;\n    float rStart = 1.0;\n\t\n\t#define RAYMARCH_COUNT 100\n\tRay viewRay;\n\t\n\tscreenToRay ( cam, xy, viewRay );\n\t\n\tvec3 color = vec3 (0.0);\n    \n    float sumRatio = 0.0;\n    float ratio = 0.75;\n    float startRatio = 0.9;\n    float startDiminish = 0.4;\n    float diminish = 0.75;\n    \n    int lastId = 0;\n\t\n\tvec3 rayVec = (rStop-rStart) * viewRay.m_dir;\n\tvec3 rayStart = rStart * viewRay.m_dir + viewRay.m_pos;\n    \n    float invRayMarchCount = 1.0 / float(RAYMARCH_COUNT);\n\n    float rayRatio = 0.0f;\n\tfor ( int i=0; i<RAYMARCH_COUNT; ++i )\n\t{\t\t\n\t\trayRatio += invRayMarchCount;\n\t\tvec3 currPos = rayStart + rayRatio * rayVec;\n\t\t\n\t\tRay4Result result = stereographicProj ( world, currPos );\n\t\t\n\t\tvec3 currcolor = computeMaterial ( result );\n        \n        if ( result.m_object.m_id != lastId )\n        {\n            if ( lastId != 0 )\n            {\n                ratio = startRatio;\n                startRatio *= startDiminish;\n            }\n            \n            lastId = result.m_object.m_id;\n        }\n\t\t\n\t\tcolor += currcolor * ratio;\n        sumRatio += ratio;\n        ratio *= diminish;\n\t}\n\t\n\tcolor /= sumRatio;\n\t \n    fragColor = vec4(clamp(color,0.0,1.0),1.0);\n    \n   \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by Mathieu Simon aka Ouid (2015)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define DEBUG\n\n\nfloat MAX = 10000.0;\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#define SHAPE 1\n\n#define CENTER4(_a,_b,_c,_d) (((_a)+(_b)+(_c)+(_d))/4.0)\n\n#if SHAPE == 0\n// 5 cell\n#define PLANE_COUNT 5\n#elif SHAPE == 1\n//tesseract\n#define PLANE_COUNT 8 \n#endif\n    \n#define SPHERE_SIZE 2.0\n#define SPHERE_OBJECT_RATIO 1.0\n\n// structures (I love structures, sorry, C/C++ habits)\n\nstruct Ray4\n{\n    vec4 m_pos;\t\t\t// start of the ray\n    vec4 m_dir;    \t\t// direction of the ray, intersect functions need \"normalized\" dir\n};\n\nstruct Ray\n{\n    vec3 m_pos;\t\t\t// start of the ray\n    vec3 m_dir;    \t\t// direction of the ray, intersect functions need \"normalized\" dir\n};\n    \nstruct Transform4\n{\n\tmat4\tm_rot;\n    vec4\tm_trans;\n};\n\nstruct Camera\n{ \n    mat4\tm_matrix;\n};\n    \nstruct Object\n{\n    int\t\tm_id;\t\t// just an id, to find material after all raycasts\n};\n    \nstruct Ray4Result\n{\n    float\tm_d;\t\t// distance from origin of the ray that cause the result\n\tvec4\tm_pos;\t\t// position of intersection\n\tvec4\tm_normal;\t// normal of intersection\n    Object\tm_object;\t// object intersected\n};\n    \nstruct Lighting\n{\n    vec3\tm_ambient; \t// xyz = color\n    vec2\tm_shading;\n};\n    \nstruct Light\n{\n    vec4\tm_pos;\t\t// position of the light    \n    vec4\tm_spec;\t\t// xyz = color, w = intensity\n};\n    \nstruct Sphere4\n{\n    vec4\tm_pos;\n    float\tm_radius;\n};\n\nstruct HyperPlane\n{\n    vec4\tm_normal;\n    float\tm_d;\n};\n    \nstruct World\n{\n    Sphere4\t\tm_sphere;\n    Transform4\tm_cube;   \t// transform of the object\t\n};\n    \nstruct Material\n{\n    vec2\tm_spec;\t\t//x : shininess, y : ratio\n    vec3\tm_color;\n};\n    \n   \n\n// util funcs\n\nfloat maxPerElem ( in vec2 _v )\n{\n    return max(_v.x,_v.y);\n}\n\nfloat maxPerElem ( in vec3 _v )\n{\n    return max(_v.z,maxPerElem(_v.xy));\n}\n\nfloat maxPerElem ( in vec4 _v )\n{\n    return max(_v.w,maxPerElem(_v.xyz));\n}\n    \n\nvoid minRay4Result ( inout Ray4Result _rayResultMin, in float _min, in float _max, in Ray4Result _curr )\n{\n    if ( _curr.m_d < _min )\n        return;\n    \n    if ( _curr.m_d > _max )\n        return;\n    \n    if ( _curr.m_d > _rayResultMin.m_d )\n        return;\n    \n\t_rayResultMin = _curr;\n}\n\nvoid minRay4Result ( inout Ray4Result _rayResultMin, in Ray4Result _curr )\n{ \n    if ( _curr.m_d > _rayResultMin.m_d )\n        return;\n    \n    _rayResultMin = _curr;\n}\n\nvoid maxRay4Result ( inout Ray4Result _rayResultMax, in float _min, in float _max, in Ray4Result _curr )\n{\n    if ( _curr.m_d < _min )\n        return;\n    \n    if ( _curr.m_d > _max )\n        return;\n    \n    if ( _curr.m_d < _rayResultMax.m_d )\n        return;\n    \n\t_rayResultMax = _curr;\n}\n\nvoid maxRay4Result ( inout Ray4Result _rayResultMax, in Ray4Result _curr )\n{  \n    if ( _curr.m_d < _rayResultMax.m_d )\n        return;\n    \n    _rayResultMax = _curr;\n}\n    \nvec4 appendColor ( in vec4 _color, in vec4 _mul, in vec4 _add, float _ratio )\n{\n    return _color * mix(vec4(1.0),_mul,_ratio) + _ratio * _add;\n}\n\nvec3 appendColor ( in vec3 _color, in vec3 _mul, in vec3 _add, float _ratio )\n{\n    return _color * mix(vec3(1.0),_mul,_ratio) + _ratio * _add;\n}\n\nfloat gridXYZ ( in vec3 _pos, in float _size, in float _ceil )\n{\n    vec3 gridPos;\n    gridPos.x = mod(_pos.x/_size+0.5,1.0);\n    gridPos.y = mod(_pos.y/_size+0.5,1.0);\n    gridPos.z = mod(_pos.z/_size+0.5,1.0);\n\n    gridPos = 2.0*abs(gridPos-vec3(0.5));\n\n    float grid = maxPerElem(gridPos);\n \n    return smoothstep(0.0,1.0,pow(grid,15.0));\n}\n\nmat4 rotationXY ( float _angle )\n{\n\tmat4 rot;\n    rot[0] = vec4(cos(_angle),sin(_angle),0.0,0.0);\n    rot[1] = vec4(-sin(_angle),cos(_angle),0.0,0.0);\n    rot[2] = vec4(0.0,0.0,1.0,0.0);\n    rot[3] = vec4(0.0,0.0,0.0,1.0);\n    return rot;\n}\n\nmat4 rotationYZ ( float _angle )\n{\n    mat4 rot;\n    rot[0] = vec4(1.0,0.0,0.0,0.0);\n    rot[1] = vec4(0.0,cos(_angle),sin(_angle),0.0);\n    rot[2] = vec4(0.0,-sin(_angle),cos(_angle),0.0);\n    rot[3] = vec4(0.0,0.0,0.0,1.0);    \n    return rot;\n}\n\nmat4 rotationXZ ( float _angle )\n{\n    mat4 rot;\n    rot[0] = vec4(cos(_angle),0.0,-sin(_angle),0.0);\n    rot[1] = vec4(0.0,1.0,0.0,0.0);\n    rot[2] = vec4(sin(_angle),0.0,cos(_angle),0.0);\n    rot[3] = vec4(0.0,0.0,0.0,1.0);    \n    return rot;\n}\n\n\nmat4 rotationXW ( float _angle )\n{\n    mat4 rot;\n    rot[0] = vec4(cos(_angle),0.0,0.0,sin(_angle));\n    rot[1] = vec4(0.0,1.0,0.0,0.0);\n    rot[2] = vec4(0.0,0.0,1.0,0.0);\n    rot[3] = vec4(-sin(_angle),0.0,0.0,cos(_angle));    \n    return rot;\n}\n\nmat4 rotationYW ( float _angle )\n{\n    mat4 rot;\n    rot[0] = vec4(1.0,0.0,0.0,0.0);\n    rot[1] = vec4(0.0,cos(_angle),0.0,-sin(_angle));\n    rot[2] = vec4(0.0,0.0,1.0,0.0);\n    rot[3] = vec4(0.0,sin(_angle),0.0,cos(_angle));    \n    return rot;\n}\n\nmat4 rotationZW ( float _angle )\n{\n    mat4 rot;\n    rot[0] = vec4(1.0,0.0,0.0,0.0);\n    rot[1] = vec4(0.0,1.0,0.0,0.0);\n    rot[2] = vec4(0.0,0.0,cos(_angle),-sin(_angle));\n    rot[3] = vec4(0.0,0.0,sin(_angle),cos(_angle));    \n    return rot;\n}\n\nmat4 scale ( vec4 _scale )\n{\n    mat4 rot;\n    rot[0] = vec4(_scale.x,0.0,0.0,0.0);\n    rot[1] = vec4(0.0,_scale.y,0.0,0.0);\n    rot[2] = vec4(0.0,0.0,_scale.z,0.0);\n    rot[3] = vec4(0.0,0.0,0.0,_scale.w);    \n    return rot;\n}\n\nvec4 mul4(Transform4 _l, vec4 _r)\n{\n\treturn _l.m_rot * _r + _l.m_trans;\n}\n\nTransform4 mul4(Transform4 _l, Transform4 _r)\n{\n\tTransform4 trfm;\n\ttrfm.m_rot = _l.m_rot * _r.m_rot;\n\ttrfm.m_trans = mul4(_l, _r.m_trans);\n\treturn trfm;\n}\n\n\n// raycCast funcs\n    \nbool intersectRayHyperPlane(in Ray4 _ray, in HyperPlane _plane, in Object _object, out Ray4Result _rayResult )\n{\n    \n    _rayResult.m_d = - ( dot(_ray.m_pos,_plane.m_normal) + _plane.m_d ) / ( dot (_ray.m_dir,_plane.m_normal) );\n\t_rayResult.m_pos = _ray.m_pos + _ray.m_dir * _rayResult.m_d;\n\t_rayResult.m_normal = _plane.m_normal;\n\t_rayResult.m_object = _object;\n    return true;\n\n}\nvoid intersectRayHyperPlaneRange (in Ray4 _ray, in HyperPlane _plane, in Object _object, inout Ray4Result _rayResFront, inout Ray4Result _rayResRear )\n{\n    Ray4Result curr;\n    intersectRayHyperPlane ( _ray, _plane, _object, curr );\n    \n    if ( dot(_ray.m_dir,_plane.m_normal) > 0.0 )\n    {\n        minRay4Result ( _rayResRear, curr );\n    }\n    else\n    {\n        maxRay4Result ( _rayResFront, curr );\n    }\n}\n\nvoid initRay4Result ( inout Ray4Result _rayResult )\n{\n    _rayResult.m_d = MAX;\n    _rayResult.m_object.m_id = -1;    \n}\n\nHyperPlane pointAndNormToHyperPlane ( in vec4 _p, in vec4 _n )\n{\n    return HyperPlane ( _n , -dot(_p,_n) );\n}\n\nHyperPlane centerNormToHyperPlane ( in World _world, in vec4 _n, in float _dist )\n{\n\tvec4 n = _world.m_cube.m_rot * _n;\n\tvec4 p = _world.m_cube.m_trans + _dist*n;\n\t\n    return HyperPlane ( n , -dot(p,n) );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Mathieu Simon aka Ouid (2015)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define DEBUG\n\n\n#define CENTRIC_PLANE(_World,_dist,_Vec4Normal) centerNormToHyperPlane ( _World, _Vec4Normal, _dist )\n\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#define CENTER4(_a,_b,_c,_d) (((_a)+(_b)+(_c)+(_d))/4.0)\n\n#if SHAPE == 0\n// 5 cell\n#define P1 vec4(1.0,1.0,1.0,-1.0/sqrt(5.0))\n#define P2 vec4(1.0,-1.0,-1.0,-1.0/sqrt(5.0))\n#define P3 vec4(-1.0,1.0,-1.0,-1.0/sqrt(5.0))\n#define P4 vec4(-1.0,-1.0,1.0,-1.0/sqrt(5.0))\n#define P5 vec4(0.0,0.0,0.0,(5.0-1.0)/sqrt(5.0))\n\nconst float Dist_5Cell = sqrt(5.0) / (5.0-1.0);\n\n#define FOREACH_PLANES(_World,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_World,Dist_5Cell,CENTER4(P1,P2,P3,P4)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_World,Dist_5Cell,CENTER4(P1,P2,P3,P5)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_World,Dist_5Cell,CENTER4(P1,P2,P4,P5)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_World,Dist_5Cell,CENTER4(P1,P3,P4,P5)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(_World,Dist_5Cell,CENTER4(P2,P3,P4,P5)), Object(14))\n    \n#define COLOR_COUNT 5    \n    \n#elif SHAPE == 1\n//tesseract\n\n#define FOREACH_PLANES(_World,_Call) /*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(1.0,0.0,0.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(-1.0,0.0,0.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(0.0,1.0,0.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(0.0,-1.0,0.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(0.0,0.0,1.0,0.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(0.0,0.0,-1.0,0.0)), Object(15))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(0.0,0.0,0.0,1.0)), Object(16))/*\n*/\t_Call(CENTRIC_PLANE(_World,1.0,vec4(0.0,0.0,0.0,-1.0)), Object(17))\n    \n#define COLOR_COUNT 8    \n    \n#endif\n    \nvec3 computeColor ( in Object _object )\n{\n    if ( _object.m_id >= 10 )\n    {\n        float ratio = float(_object.m_id-10) / float(COLOR_COUNT);\n        vec3 a = vec3(0.5,0.5,0.5);\n        vec3 b = vec3(0.5,0.4,0.5);\n        vec3 c = vec3(1.0,1.0,1.0);        \n        vec3 d = vec3(0.0,0.33,0.67);\n        \n        //https://iquilezles.org/articles/palettes\n        return a+b*cos(2.0*3.141592*(c*ratio+d));\n    }\n    else   \n    {\n\t\treturn vec3(0.0);\n    }   \n}    \n\nvec3 saveFloat ( in float _x, in HyperPlane _plane, in Object _object)\n{\n    if ( _x < 1.0 )\n        return vec3(_plane.m_normal[0]);\n    else if ( _x < 2.0 )\n        return vec3(_plane.m_normal[1]);\n    else if ( _x < 3.0 )\n        return vec3(_plane.m_normal[2]);\n    else if ( _x < 4.0 )\n        return vec3(_plane.m_normal[3]);\n    else if ( _x < 5.0 )\n    \treturn vec3(_plane.m_d);\n\telse if ( _x < 6.0 )\n        return computeColor(_object);\n}\n\nvoid saveFloat ( in vec2 _coord, in HyperPlane _plane, in Object _object, inout vec3 value )\n{\n    if ( int(_coord.y) == (_object.m_id-10))\n    {\n        value = saveFloat(_coord.x, _plane, _object);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam;\n    World world;    \n     \n    world.m_sphere = Sphere4 ( vec4(0.0,0.0,0.0,0.5), 0.5 );\t\n    \n    float animTime = iTime / 2.0;\n    \n    mat4 rot = rotationXY ( animTime*1.278914) * rotationXZ(animTime) * rotationYZ(animTime*0.332567);\n\t\n\trot *= rotationXW ( animTime*0.3565) * rotationYW(animTime*0.578246) * rotationZW(animTime*0.275689);\n    \n    float scaleFactor = 0.25; //world.m_sphere.m_radius/sqrt(4.0);\n    world.m_cube = Transform4 ( scale ( vec4(scaleFactor) ) * rot, world.m_sphere.m_pos );\n    \n\tvec2 ratioCoord = fragCoord;\n    \n    vec3 value = vec3(.0);\n    \n\t#define SAVE_PLANE_FLOAT(_Plane,_PlaneId) saveFloat ( ratioCoord, _Plane, _PlaneId, value );\n\tFOREACH_PLANES(world,SAVE_PLANE_FLOAT);\n       \n    fragColor.xyz = value;\n}\n","name":"Buf A","description":"","type":"buffer"}]}