{"ver":"0.1","info":{"id":"wld3zl","date":"1577321257","viewed":691,"name":"Rectangular domain coloring","username":"rreusser","description":"The same domain coloring algorithm as https://www.shadertoy.com/view/tlcGzf, except rectangular.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["math","complex","domaincoloring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Rectangular domain coloring\n * Copyright 2019 Ricky Reusser. MIT License.\n *\n * See Common tab for cubehelix license: \n * https://github.com/d3/d3-color\n * Copyright 2010-2016 Mike Bostock *\n * Features:\n *\n * Based on https://www.shadertoy.com/view/tlcGzf except with rectangular\n * domain coloring instead of polar.\n *\n */\n\n// Available functions: cadd, csub, cmul, cdiv, cinv, csqr, cconj,\n// csqrt, cexp, cpow, clog, csin, ccos, ctan, ccot, ccsc, csec, casin,\n// cacos, catan, csinh, ccosh, ctanh, ccoth, ccsch, csech, casinh,\n// cacosh, catanh\nvec2 f (vec2 z, float t, vec2 mouse) {\n    vec2 a = vec2(sin(t), 0.5 * sin(2.0 * t));\n    vec2 b = vec2(cos(t), 0.5 * sin(2.0 * (t - HALF_PI)));\n    vec2 m = mouse;\n\n    // Try a different equation:\n    // return csin((cmul(z - a, z - b, z - m)));\n\n    return cdiv(cmul(z - a, m - b), cmul(z - b, m - a));\n\n    z *= 0.6;\n    z.x -= 0.5;\n    vec2 sum = z;\n    for (int i = 0; i < 10; i++) {\n        sum = csqr(sum) + z;\n    }\n    return sum;\n}\nconst bool animate = true;\nconst bool grid = true; // (when not animating)\n\nconst int octaves = 4;\n\n// Grid lines:\nconst float lineWidth = 1.0;\nconst float lineFeather = 1.0;\nconst vec3 gridColor = vec3(0);\n\n// Power of contrast ramp function\n\nvec2 pixelToXY (vec2 point) {\n  \tvec2 aspect = vec2(1, iResolution.y / iResolution.x);\n    return (point / iResolution.xy - 0.5) * aspect * 5.0;\n}\n\n// Select an animation state\nfloat selector (float time) {\n    const float period = 10.0;\n    float t = fract(time / period);\n    return smoothstep(0.4, 0.5, t) * smoothstep(1.0, 0.9, t);\n}\n\nvec3 colorscale (float phase) {\n    return rainbow(phase / 2.0 - 0.25);\n}\n\nvec2 complexContouringGridFunction (vec2 x) {\n  return 2.0 * abs(fract(x - 0.5) - 0.5);\n}\n\nfloat checkerboard (vec2 xy) {\n  vec2 f = fract(xy * 0.5) * 2.0 - 1.0;\n  return f.x * f.y > 0.0 ? 1.0 : 0.0;\n}\n\nvec4 rectangularDomainColoring (vec4 f_df,\n                     vec2 steps,\n                     vec2 baseScale,\n                     vec2 gridOpacity,\n                     float shadingOpacity,\n                     float lineWidth,\n                     float lineFeather,\n                     vec3 gridColor,\n                     float phaseColoring\n) {\n  float cmagRecip = 1.0 / hypot(f_df.xy);\n  baseScale *= 10.0;\n\n  vec2 znorm = f_df.xy * cmagRecip;\n  float cmagGradientMag = hypot(vec2(dot(znorm, f_df.zw), dot(vec2(znorm.y, -znorm.x), f_df.zw)));\n\n  float xContinuousScale = log2(cmagGradientMag) / log2(steps.x);\n  float xDiscreteScale = floor(xContinuousScale);\n  float xScalePosition = 1.0 - (xContinuousScale - xDiscreteScale);\n\n  float yContinuousScale = log2(cmagGradientMag) / log2(steps.y);\n  float yDiscreteScale = floor(yContinuousScale);\n  float yScalePosition = 1.0 - (yContinuousScale - yDiscreteScale);\n\n  vec2 scalePosition = 1.0 - vec2(xContinuousScale, yContinuousScale) + vec2(xDiscreteScale, yDiscreteScale);\n  vec2 scaleBase = vec2(pow(steps.x, -xDiscreteScale), pow(steps.y, -yDiscreteScale)) / baseScale;\n\n  float width1 = max(0.0, lineWidth - lineFeather);\n  float width2 = lineWidth + lineFeather;\n\n  float totalWeight = 0.0;\n  float shading = 0.0;\n  vec2 invSteps = 1.0 / steps;\n  vec2 octaveScale = vec2(1.0);\n  vec2 grid = vec2(0.0);\n  vec2 gridScaleBase = vec2(\n    pow(steps.x, xScalePosition),\n    pow(steps.y, yScalePosition)\n  );\n\n  for(int i = 0; i < octaves; i++) {\n    float w0 = i == 0 ? 1e-4 : 1.0 + float(i);\n    float w1 = i == octaves - 1 ? 1e-4 : 1.0 + float(i + 1);\n    float w = mix(w0, w1, xScalePosition);\n    totalWeight += w;\n    vec2 value = f_df.xy * scaleBase * octaveScale;\n\n    vec2 gridSlope = baseScale * gridScaleBase / octaveScale / steps;\n    //float t = 0.01;\n    //float gridStrength = smoothstep(2.0 / t, 1.0 / t, 1.0 / value.x);\n    vec2 xygrid = complexContouringGridFunction(value) * gridSlope;\n\n    grid += w * vec2(smoothstep(width2, width1, xygrid.x), smoothstep(width2, width1, xygrid.y));\n\n    shading += w * checkerboard(value);\n    \n    octaveScale *= invSteps;\n  }\n\n  shading = shading / totalWeight;\n  grid /= totalWeight;\n  grid *= gridOpacity;\n\n  float carg = atan(f_df.y, f_df.x) * HALF_PI_INV * 2.0;\n  vec3 color = mix(vec3(1.0), clamp(colorscale(carg), 0.0, 1.0), phaseColoring);\n\n  const float gamma = 0.454;\n  color.r = pow(color.r, gamma);\n  color.g = pow(color.g, gamma);\n  color.b = pow(color.b, gamma);\n    \n  color = mix(vec3(1), color, 0.97);\n\n  float mixedGrid = max(grid.x, grid.y);\n  float shade = mix(1.0, shading, shadingOpacity);\n  vec3 result = clamp(mix(color * shade, gridColor, mixedGrid), vec3(0), vec3(1));\n\n  result.r = pow(result.r, 1.0 / gamma);\n  result.g = pow(result.g, 1.0 / gamma);\n  result.b = pow(result.b, 1.0 / gamma);\n  \n  return vec4(result, 1);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = pixelToXY(fragCoord);\n    vec2 mouse = pixelToXY(iMouse.xy);\n\n    vec2 fz = f(xy, iTime * 0.2, mouse);\n    \n    // fwidth(fz) works, but it adds ugly anisotropy in the width of lines near zeros/poles.\n    // Insead, we compute the magnitude of the derivatives separately.\n    //\n    // Also *NOTE* that this is a very important place in which we use `hypot` instead of an\n    // algebraically equivalent built-in `length`. Floating point is limited and we lose lots\n    // of our floating point domain if we're not careful about over/underflow.\n    vec4 fdf = vec4(fz, vec2(hypot(dFdx(fz)), hypot(dFdy(fz))));\n\n   \tfloat select = animate ? selector(iTime) : (grid ? 1.0 : 0.0);\n\n    fragColor = rectangularDomainColoring(\n        fdf,\n        vec2(8.0), // steps\n        vec2(1.0), // scale\n        mix(vec2(0.4), vec2(1.0), select), // grid opacity\n        mix(0.2, 0.0, select),       // shading opacity\n        lineWidth,\n        lineFeather,\n        gridColor,\n        mix(1.0, 0.0, select)        // phase coloring\n    );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n/*\nfloat sinh (float x) {\n  return 0.5 * (exp(x) - exp(-x));\n}\n\nfloat cosh (float x) {\n  return 0.5 * (exp(x) + exp(-x));\n}*/\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n\n\nvec4 cmul (vec4 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec2 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw)\n  );\n}\n\nvec4 cmul (vec4 a, vec2 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec4 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\n\nvec4 csqr (vec4 a) {\n  return vec4(\n    csqr(a.xy),\n    2.0 * cmul(a.xy, a.zw)\n  );\n}\nvec4 cdiv (vec4 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw) - cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec2 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(-cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec4 a, vec2 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw), csqr(b.xy))\n  );\n}\n\nvec4 csub(vec4 a, vec4 b) {\n  return a - b;\n}\n\nvec4 csub(vec2 a, vec4 b) {\n  return vec4(a.xy - b.xy, -b.zw);\n}\n\nvec4 csub(vec4 a, vec2 b) {\n  return vec4(a.xy - b.xy, a.zw);\n}\n\nvec4 cadd(vec4 a, vec4 b) {\n  return a + b;\n}\n\nvec4 cadd(vec2 a, vec4 b) {\n  return vec4(a.xy + b.xy, b.zw);\n}\n\nvec4 cadd(vec4 a, vec2 b) {\n  return vec4(a.xy + b.xy, a.zw);\n}\n\n\nvec4 cinv(vec4 a) {\n  vec2 ainv = cinv(a.xy);\n  return vec4(ainv, cmul(a.zw, -csqr(ainv)));\n}\n\nvec4 cexp(vec4 a) {\n  vec2 expa = cexp(a.xy);\n  return vec4(expa, cmul(expa, a.zw));\n}\n\nvec4 csqrt(vec4 a) {\n  float r = hypot(a.xy);\n  float b = sqrt(2.0 * (r + a.x));\n  float c = sqrt(2.0 * (r - a.x));\n  float re = a.x >= 0.0 ? 0.5 * b : abs(a.y) / c;\n  float im = a.x <= 0.0 ? 0.5 * c : abs(a.y) / b;\n  vec2 s = vec2(re, a.y < 0.0 ? -im : im);\n  return vec4(s, cmul(a.zw, 0.5 * cinv(s)));\n}\n\n/*vec4 cpow(vec4 a, float n) {\n  float theta = atan(a.y, a.x);\n  float r = hypot(a.xy);\n  float tn = theta * n;\n  float rn = pow(r, n);\n  vec2 s = rn * vec2(sin(tn), cos(tn));\n  float rn1 = pow(r, n - 1.0);\n  float tn1 = theta * (n - 1.0);\n  return vec4(s, cmul(a.zw, n * rn1 * vec2(sin(tn1), cos(tn1))));\n}*/\n\nvec4 clog(vec4 z) {\n  return vec4(\n    log(hypot(z.xy)),\n    atan(z.y, z.x),\n    cdiv(z.zw, z.xy)\n  );\n}\n\nvec4 csin(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.xy, cmul(asincos.zw, a.zw));\n}\n\nvec4 ccos(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.zw, cmul(-asincos.xy, a.zw));\n}\n\nvec4 ctan(vec4 a) {\n  return cdiv(csin(a), ccos(a));\n}\n\nvec4 casin(vec4 z) {\n  vec4 s = clog(vec4(-z.y, z.x, -z.w, z.z) + csqrt(csub(vec2(1, 0), csqr(z))));\n  return vec4(s.y, -s.x, s.w, -s.z);\n}\n\nvec4 cacos(vec4 z) {\n  vec4 s = -casin(z);\n  s.x += HALF_PI;\n  return s;\n}\n\nvec4 catan(vec4 z) {\n  vec2 s = clog(cdiv(cadd(vec2(0, 1), z.xy), csub(vec2(0, 1), z.xy)));\n  return vec4(\n     0.5 * vec2(-s.y, s.x),\n     cmul(z.zw, cinv(cadd(vec2(1, 0), csqr(z))))\n  );\n}\n\nvec4 csinh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez - cinv(ez));\n}\n\nvec4 ccosh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez + cinv(ez));\n}\n\nvec4 ctanh(vec4 z) {\n  vec4 ez = cexp(z);\n  vec4 ezinv = cinv(ez);\n  return 0.5 * cdiv(ez - ezinv, ez + ezinv);\n}\n\nvec4 casinh(vec4 z) {\n  return clog(cadd(z, csqrt(cadd(vec2(1, 0), csqr(z)))));\n}\n\nvec4 cacosh(vec4 z) {\n  return clog(z + cmul(csqrt(cadd(z, vec2(1, 0))), csqrt(csub(z, vec2(1, 0)))));\n}\n\nvec4 catanh(vec4 z) {\n  return 0.5 * clog(cdiv(cadd(z, vec2(1,  0)), csub(vec2(1, 0), z)));\n}\n\n// https://github.com/d3/d3-color\n// Copyright 2010-2016 Mike Bostock\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n// \n// * Redistributions of source code must retain the above copyright notice, this\n//   list of conditions and the following disclaimer.\n// \n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// \n// * Neither the name of the author nor the names of contributors may be used to\n//   endorse or promote products derived from this software without specific prior\n//   written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nvec3 cubehelix(vec3 c) {\n  vec2 sc = vec2(sin(c.x), cos(c.x));\n  return c.z * (1.0 + c.y * (1.0 - c.z) * (\n    sc.x * vec3(0.14861, 0.29227, -1.97294) + \n    sc.y * vec3(1.78277, -0.90649, 0.0)\n  ));\n}\n\nvec3 rainbow(float t) {\n  return cubehelix(vec3(\n    TWO_PI * t - 1.74533,\n    (0.25 * cos(TWO_PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n  ));\n}","name":"Common","description":"","type":"common"}]}