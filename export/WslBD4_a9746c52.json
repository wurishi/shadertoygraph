{"ver":"0.1","info":{"id":"WslBD4","date":"1588331044","viewed":95,"name":"Snowflake fun","username":"johnyboy94","description":"It's something","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","koch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZOOM_OUT_F (2.)\n#define BRUSH_SIZE (5. / iResolution.x)\n#define PI (3.14159)\n\n\n\nvec2 getLineNormal(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\n\nfloat lineDist(vec2 uv, vec2 lineNormal)\n{\n    return dot(uv, lineNormal);\n}\n\n\nvoid reflect(inout vec2 uv, vec2 lineNormal)\n{\n    float dist = lineDist(uv, lineNormal);\n    \n    uv -= 2. * lineNormal * min(0., dist);\t//Reflect only if dist < 0\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * ZOOM_OUT_F;\n    \n    //float mx = getRemappedMouseAngle();\n    \n    float curveAngle = 2./3. * PI;\n    float snowAngle = 5./6. * PI;\n    \n    vec2 lineNormal = getLineNormal(curveAngle);\t// Axis normal for koch curve\n    vec2 diagNormal = getLineNormal(snowAngle);\t\t// Axis normal for koch snowflake\n\n    uv.x = abs(uv.x);\n    uv.y += tan(snowAngle) * 0.5;\t// Move up so it's centered vertically\n    \n    //col += line(uv, diagNormal);\t// debug draw for diagonal reflection\n    \n    // Reflect, but with the uv parameter offset temporarily\n    float d = lineDist(uv - vec2(.5, 0), diagNormal);\n   \tuv -= 2. * diagNormal * max(0., d);\n    \n\n    float scale = 1.;\n    uv.x += .5;\n    \n    for(float i = 0.; i < mod(iTime, 5.); i++)\n    {   \n        uv *= 3.;\t\t// \"Zoom out\"\n        scale *= 5.;\t// Can be used to make the line thickness constant (use 3)\n        uv.x -= 1.5;\t// Shift right, get a new x = 0 \"origin\"\n        \n        uv.x = abs(uv.x);\t\t\t// Reflect around y, for symmetry\n        uv.x -= 0.5f;\t\t\t\t// Create two x=0 around shifted center\n        reflect(uv, lineNormal);\t// Reflect UVs around the curve normal\n    }\n    \n    // Coloring coordinates change over time\n    float theta = abs(cos(iTime * .5 * PI));\n    mat2x2 rotMat = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    uv = rotMat * uv; \n    \n    // Line but adjusted distance to scale\n    float dist = abs(lineDist(uv, vec2(0., 1.)));\n    col.b = smoothstep(BRUSH_SIZE, 0., dist / scale);\n    \n    col.g = (col.b * col.b);\n    col.r = col.g * col.g;\n    \n    //col.xy += uv / scale; visual space folding\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n// Not directly used in the final shader but... \n// useful for debugging / trying out other options with the above\n\nfloat rect(vec2 uv, vec4 rect)\n{\n    vec2 clsPtOnLine = vec2(clamp(uv.x, rect.x, rect.z), clamp(uv.y, rect.y, rect.w));\n    float dist = length(uv - clsPtOnLine);\n    return smoothstep(BRUSH_SIZE, 0., dist);\n}\n\n\nfloat line(vec2 uv, vec2 lineNormal)\n{  \n    return smoothstep(BRUSH_SIZE, 0., abs(lineDist(uv, lineNormal)));\n}\n\n\nfloat lineSeg(vec2 uv, vec2 lineNormal, float hl)\n{\n    return line(uv, lineNormal) * float(length(uv) < hl);\n}\n\n\nfloat getRemappedMouseAngle()\t// Edge of screen input is clunky so...\n{\n    float mx = (iMouse.x / iResolution.x) * 2.;\t// 0,1 to 0,2\n    float mxAngle = clamp(mx - .5, 0., 1.)  * PI;\n    return mxAngle;\n}","name":"Image","description":"","type":"image"}]}