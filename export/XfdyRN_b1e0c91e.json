{"ver":"0.1","info":{"id":"XfdyRN","date":"1730405872","viewed":57,"name":"octree - XfdyRN","username":"Pangolecimal","description":"octree","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://www.shadertoy.com/view/4ttSWf\n*/\n\n#define SEED 0\n#define PI 3.141592653589\n#define ITER_BASE (2.0)\n#define ITER_MAX (floor(log(iResolution.y) / log(ITER_BASE)) - 1.0)\nconst int MAX_MARCHING_STEPS = 256;\nconst float MIN_DEPTH = 0.001;\nconst float MAX_DEPTH = 100.0;\nconst float EPSILON = 0.0001;\n\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233) + float(SEED))) * 43758.5453);\n}\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 3.1415) + float(SEED))) * 43758.5453);\n}\n\nfloat floorv(float v, float m) { return floor(v * m) / m; }\n vec2 floorv( vec2 v, float m) { return floor(v * m) / m; }\n vec3 floorv( vec3 v, float m) { return floor(v * m) / m; }\nfloat maxcomp(vec2 v) { return max(v.x, v.y); }\nfloat maxcomp(vec3 v) { return max(max(v.x, v.y), v.z); }\n\n\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nfloat scene_depth(vec3 ro, vec3 rd, out vec3 normal) {\n    normal = vec3(0);\n    vec2 bi = boxIntersection(ro, rd, vec3(1), normal);\n    if (bi == vec2(-1.0)) { return MAX_DEPTH; }\n    \n    float depth = bi.x;\n    depth = clamp(depth, MIN_DEPTH + EPSILON, MAX_DEPTH - EPSILON);\n    \n    return depth;\n}\n\nvec3 ray_direction(vec3 ro, vec3 target, vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 dir = normalize(target - ro);\n    \n    vec3 rx = cross(vec3(0,1,0), dir);\n    vec3 ry = cross(dir, rx);\n    \n    return normalize(dir + rx*uv.x + ry*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uvm = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    vec2 sphere_angles = vec2(uvm.x * PI, uvm.y * PI * 0.5); // x=azimuth, y=polar\n    vec3 ro = 3.0 * vec3(\n        sin(sphere_angles.x),\n       -sin(sphere_angles.y),\n        cos(sphere_angles.x)\n    );\n    vec3 rd = ray_direction(ro, vec3(0), fragCoord);\n    \n    vec3 normal = vec3(0);\n    float depth = scene_depth(ro, rd, normal);\n    \n    if (depth > MAX_DEPTH - EPSILON) {\n        fragColor = vec4(vec3(0.33), 1);\n        return;\n    }\n    \n    vec3 p = ro + rd * depth;\n    //vec3 light = vec3(3,3,3);\n    vec3 color = p;// * (dot(normal, normalize(light-p))/2.+.5);\n    \n    fragColor.rgb = color;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}