{"ver":"0.1","info":{"id":"Nsj3W3","date":"1618041732","viewed":46,"name":"Fork Cellular n emaduranda 377","username":"emadurandal","description":"Differentiation of [url=https://www.shadertoy.com/view/NdBGDG]cellular noise sample[/url]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bd202104"],"hasliked":0,"parentid":"fsS3DG","parentname":"Cellular noise -diffuse light"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nfloat length2_2d(vec2 v){\n    return dot(v, v);\n}\nfloat length2_3d(vec3 v){\n    return dot(v, v);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32) - 0.5;\n}\nvec4 sort(vec4 list, float v){\n    if (list.x >= v) {\n       return vec4(v, list.xyz);\n    } else if (list.y >= v) {\n       return vec4(list.x, v, list.yz);\n    } else if (list.z >= v) {\n       return vec4(list.xy, v, list.z);\n    } else if (list.w >= v) {\n       return vec4(list.xyz, v);\n    } else {\n       return list;\n    }\n}\nvec4 F4_2d(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    vec4 dist4 = vec4(length2_2d(1.5 - abs(f)));\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 4.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n            continue;\n        }\n        for(float i = 0.0; i <= 4.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + sin(iTime) * rot2(iTime) * hash22(n + glid) / sqrt(2.0);\n            float dist = length2_2d(nbd -f);\n            dist4 = sort(dist4, dist);\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist4);\n}\nvec4 F4_3d(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    vec4 dist4 = vec4(length2_3d(1.5 - abs(f)));\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    for(float k = 0.0; k <= 4.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n            for(float i = 0.0; i <= 4.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + sin(iTime) * hash33(n + glid);\n                float dist = length2_3d(nbd - f);\n                dist4 = sort(dist4, dist);\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return sqrt(dist4);\n}\nfloat cnoise2(vec2 p, vec4 wt){\n    return abs(dot(F4_2d(p), wt));\n}\nfloat cnoise3(vec3 p, vec4 wt){\n    return dot(F4_3d(p), wt);\n}\nvec2 grad2(vec2 p, vec4 w) {\n    float d = 0.001;\n    return 0.5 * (vec2(\n            cnoise2(p + vec2(d, 0.0), w) - cnoise2(p - vec2(d, 0.0), w),\n            cnoise2(p + vec2(0.0, d), w) - cnoise2(p - vec2(0.0, d), w)\n        )) / d;\n}\nvec3 grad3(vec3 p, vec4 w) {\n    float d = 0.001;\n    return 0.5 * (vec3(\n            cnoise3(p + vec3(d, 0.0, 0.0), w) - cnoise3(p - vec3(d, 0.0, 0.0), w),\n            cnoise3(p + vec3(0.0, d, 0.0), w) - cnoise3(p - vec3(0.0, d, 0.0), w),\n            cnoise3(p + vec3(0.0, 0.0, d), w) - cnoise3(p - vec3(0.0, 0.0, d), w)\n        )) / d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    // int ind = int(3.0 * fragCoord.x / iResolution.x);\n    // mat3x4 wt = mat3x4(\n    //     vec4(-1.0, 1.0, 0.0, 0.0),  //left\n    //     vec4(-.5, -1., 1., 0.0),  //center \n    //     vec4(-.25, -.5, -1.2, 1.0)  //right\n    // );\n    vec2 ray2 = vec2(1.0, 0.0);\n    vec3 ray3 = vec3(1.0, 0.0, 0.0);\n    vec4 wt;\n    if (fragCoord.x < 0.33 * iResolution.x){\n        wt = vec4(-1.0, 1.0, 0.0, 0.0);\n    } else if (fragCoord.x < 0.66 * iResolution.x) {\n        wt = vec4(-.5, -1., 1., 0.0);\n    } else {\n        wt = vec4(-.25, -.5, -1.2, 1.0);\n    }\n    \n    if(fragCoord.y < 0.5 * iResolution.y){\n       // fragColor = vec4(dot(grad2(pos, wt[ind]), ray2)) * vec4(0.9, 0.9, 0.7, 1.0);  \n       fragColor = vec4(dot(grad2(pos, wt), ray2)) * vec4(0.9, 0.9, 0.7, 1.0);  \n    } else {\n        // fragColor = vec4(dot(grad3(vec3(pos, 0.5 * iTime), wt[ind]), ray3)) * vec4(0.6, 0.8, 0.8, 1.0);\n        fragColor = vec4(dot(grad3(vec3(pos, 0.5 * iTime), wt), ray3)) * vec4(0.6, 0.8, 0.8, 1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}