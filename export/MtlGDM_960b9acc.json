{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Gomez by @Polyflare (30/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Gomez is a character from the video game Fez by Polytron Corporation\n// http://fezgame.com/\n\n//-----------------------------------------------------------------------------\n// User settings\n\n// 0 = No antialiasing\n// 1 = Antialiasing enabled\n#define ANTIALIAS 0\n\n// 0 = 2x2 supersampling\n// 1 = 3x3 supersampling\n#define ANTIALIAS_HQ 0\n\n// 0 = Static camera\n// 1 = Animate the camera\n#define ANIMATE_CAM 1\n\n// 0 = No noise in the background\n// 1 = Add noise to the background to reduce banding\n#define BG_NOISE 1\n\n// 0 = No camera vignetting\n// 1 = Camera vignetting enabled\n#define BG_VIGNETTE 0\n\n//-----------------------------------------------------------------------------\n\n// Internal settings\n#define MAX_STEPS 70\n#define MAX_DIST 70.0\n#define GEPS 0.001\n#define HIT_DIST 0.005\n#define LIGHT_DIR vec3(0.40825, 0.40825, 0.81650)\n#define LIGHT_AMB 0.79588\n#define LIGHT_DIF 0.25\n#define TEX_OFFSET vec2(7.0, 8.0)\n#define FLOOR_OFFSET vec3(0.0, 16.0, 0.0)\n\n// High quality antialiasing is 3x3 grid while low quality is 2x2\n#if ANTIALIAS_HQ\n#define AA_XY 3\n#define AA_SEP 0.333333\n#define AA_OFF 0.333333\n#define AA_MIX 0.111111\n#else\n#define AA_XY 2\n#define AA_SEP 0.5\n#define AA_OFF 0.25\n#define AA_MIX 0.25\n#endif\n\n// Pixel colours\n#define SKIN_COL vec3(1.0, 1.0, 1.0)\n#define SKIN_LSHAD_COL vec3(0.8902, 0.9686, 0.8902)\n#define SKIN_DSHAD_COL vec3(0.6667, 0.7255, 0.6667)\n#define FACE_COL vec3(0.0, 0.0, 0.0)\n#define TONGUE_COL vec3(0.9216, 0.1137, 0.3804)\n#define FEZ_COL vec3(0.8392, 0.1176, 0.1176)\n#define FEZ_SHAD_COL vec3(0.7529, 0.1059, 0.1059)\n#define TASSEL_COL vec3(0.9333, 0.7333, 0.2667)\n#define TASSEL_SHAD_COL vec3(0.8392, 0.6588, 0.2392)\n#define BGT_COL vec3(0.6588, 0.4941, 0.8824)\n#define BGB_COL vec3(0.5451, 0.3922, 0.749)\n\nfloat box(vec3 p, vec3 offset, vec3 size)\n{\n\treturn length(max(abs(p - offset) - size, 0.0));\n}\n\n// Distance field of Gomez's silhouette\nfloat scene(vec3 p)\n{\n    p.xy += TEX_OFFSET;\n#define BOX(x1, y1, w, h) box(p, vec3(x1 + w * 0.5, y1 + h * 0.5, 0.0), vec3(w * 0.5, h * 0.5, 0.5))\n    // Body\n    float a =  BOX(1., 8.,  12., 7.);\n    a = min(a, BOX(0., 9.,  14., 5.));\n    a = min(a, BOX(4., 7.,  6.,  1.));\n    a = min(a, BOX(3., 1.,  7.,  6.));\n    a = min(a, BOX(1., 6.,  11., 1.));\n    a = min(a, BOX(2., 5.,  9.,  1.));\n    a = min(a, BOX(2., 0.,  2.,  1.));\n    a = min(a, BOX(7., 0.,  2.,  1.));\n    // Fez\n    a = min(a, BOX(3., 16., 3.,  3.));\n    a = min(a, BOX(2., 17., 1.,  1.));\n    return a;\n}\n\n// Pixel colours\nvec3 pixtocol(vec2 uv)\n{\n    uv += TEX_OFFSET;\n    // Ugly, ugly, ugly\n#define UVB(x1, y1, x2, y2) (uv.x > x1 && uv.x <= x2 && uv.y > y1 && uv.y <= y2)\n    if(UVB(2., 13., 3., 15.) || UVB(1., 9., 2., 14.) || UVB(2., 9., 3., 10.) ||\n       UVB(3., 8., 4., 9.) || UVB(6., 7., 7., 8.) || UVB(8., 7., 10., 8.) ||\n       UVB(4., 6., 5., 7.) || UVB(4., 1., 5., 4.) || UVB(3., 0., 4., 1.) ||\n       UVB(8., 1., 9., 2.) || UVB(7., 0., 8., 1.))\n        return SKIN_LSHAD_COL;\n    if(UVB(0., 0., 2., 15.) || UVB(2., 8., 3., 9.) || UVB(4., 7., 6., 8.) ||\n       UVB(2., 0., 3., 6.) || UVB(3., 0., 4., 5.) || UVB(5., 0., 10., 2.) ||\n       UVB(10., 5., 12., 7.))\n        return SKIN_DSHAD_COL;\n    if(UVB(6., 10., 10., 12.) || UVB(7., 9., 9., 10.) || UVB(3., 12., 4., 13.) || \n       UVB(12., 12., 13., 13.)) {\n        if(UVB(6., 9., 8., 11.))\n            return TONGUE_COL;\n        return FACE_COL;\n    }\n    if(UVB(3., 16., 4., 18.))\n        return FEZ_SHAD_COL;\n    if(UVB(3., 18., 4., 19.))\n        return TASSEL_COL;\n    if(UVB(2., 17., 3., 18.))\n        return TASSEL_SHAD_COL;\n    return uv.y > 15.5 ? FEZ_COL : SKIN_COL;\n}\n\n// Ray-plane intersection where the plane crosses the origin. Returns the\n// point of intersection.\nvec3 rayplaneintersect(vec3 pos, vec3 dir, vec3 n)\n{\n    float d = -dot(pos, n) / dot(dir, n);\n    return pos + d * dir;\n}\n\n// Calculate the normal at a point using distance field gradients\nvec3 gradnormal(vec3 pos)\n{\n    vec3 v1 = vec3( 1.0, -1.0, -1.0);\n    vec3 v2 = vec3(-1.0, -1.0,  1.0);\n    vec3 v3 = vec3(-1.0,  1.0, -1.0);\n    vec3 v4 = vec3( 1.0,  1.0,  1.0);\n\treturn normalize(\n        v1 * scene(pos + v1 * GEPS) + \n\t\tv2 * scene(pos + v2 * GEPS) + \n\t\tv3 * scene(pos + v3 * GEPS) + \n\t\tv4 * scene(pos + v4 * GEPS)\n    );\n}\n\n// Base raymarching algorithm\nbool raymarch(inout vec3 pos, vec3 cdir)\n{\n    float dist = 0.0;\n    float d;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        d = scene(pos);\n        if(d < HIT_DIST || dist > MAX_DIST)\n        \tbreak;\n        dist += d;\n        pos += cdir * d;\n    }\n    return d < HIT_DIST;\n}\n\n// How much is the specified point in shadow? 0 = Complete shadow\nfloat shadowamount(vec3 pos)\n{\n    pos += LIGHT_DIR * (HIT_DIST * 1.1);\n    float dist = 0.0;\n    float dmin = 100.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = scene(pos + LIGHT_DIR * dist);\n        dmin = min(dmin, d);\n        if(d < HIT_DIST || dist > MAX_DIST)\n        \tbreak;\n        dist += d;\n    }\n    return dmin < HIT_DIST ? 0.0 : 1.0;\n}\n\nfloat rand(vec2 co)\n{\n   return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 pixpos;\n    pixpos.xy = uv - 0.5;\n    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction\n    pixpos.z = -0.6; // Focal length (Controls field of view)\n    return normalize(pixpos);\n}\n\n// Render the scene from the normalised screen position\nvec3 render(vec2 uv)\n{\n    vec3 cdir = pixtoray(uv);\n    vec3 cpos = vec3(0.0, 0.0, 32.0); // Camera position\n#if ANIMATE_CAM\n    // Rotating camera\n    float angt = sin(iTime * 0.25) * 0.5;\n    float cost = cos(angt);\n    float sint = sin(angt);\n    cpos.xz = cost * cpos.xz + sint * vec2(-cpos.z, cpos.x);\n    cdir.xz = cost * cdir.xz + sint * vec2(-cdir.z, cdir.x);\n#endif\n    \n    vec3 p = cpos;\n    vec3 frag;\n    if(raymarch(p, cdir)) {\n        // Hit Gomez. Move hit position towards the model to get the\n        // correct pixel colour and then fetch it.\n        vec3 n = gradnormal(p);\n        p -= n * 0.1;\n        frag = pixtocol(p.xy);\n        // Lighting\n        frag *= dot(LIGHT_DIR, n) * LIGHT_DIF + LIGHT_AMB;\n    } else {\n        // Background\n        frag = mix(BGB_COL, BGT_COL, uv.y);\n#if BG_NOISE\n        frag = mix(frag, vec3(rand(uv)), 0.02);\n#endif\n        // Shadow\n        p = rayplaneintersect(\n            cpos + FLOOR_OFFSET, cdir, vec3(0.0, 1.0, 0.0)\n        \t) - FLOOR_OFFSET;\n        // Clip shadow check to improve performance\n        if(p.x > -32.0 && p.x < -4.0 && p.z > -56.0 && p.z < -15.0)\n        \tfrag = mix(frag * LIGHT_AMB, frag, shadowamount(p));\n    }\n    return frag;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if ANTIALIAS\n    for(int y = 0; y < AA_XY; y++) {\n        for(int x = 0; x < AA_XY; x++) {\n        \tvec2 offset = vec2(AA_SEP) * vec2(x, y) - vec2(AA_OFF);\n\t\t\tvec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n        \tfragColor.rgb += render(uv) * vec3(AA_MIX);\n    \t}\n    }\n#else\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.rgb = render(uv);\n#endif\n#if BG_VIGNETTE\n    vec2 buv = uv - 0.5;\n    buv.y *= iResolution.y / iResolution.x; // Aspect correction\n    fragColor.rgb *= 1.0 - pow(dot(buv, buv) * 2.0, 4.0) * 0.5;\n    // Anamorphic alternative, iq-style\n    //float cendist = uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y);\n    //fragColor.rgb *= pow(16.0 * cendist, 0.15) * 0.25 + 0.75;\n#endif\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtlGDM","date":"1422604681","viewed":2673,"name":"Gomez","username":"Polyflare","description":"Gomez from the extremely fun indie video game Fez. [url]http://fezgame.com/[/url]","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fez"],"hasliked":0,"parentid":"","parentname":""}}