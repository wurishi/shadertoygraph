{"ver":"0.1","info":{"id":"WsGczh","date":"1642775475","viewed":56,"name":"Lab 6 Sebastian Meredith","username":"smeredith116","description":"Lab 5 ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n//  -> IMAGE TAB (final)\n\n//------------------------------------------------------------\n// SHADERTOY MAIN\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    // setup\n    // test UV for input image\n    sCoord uv = fragCoord / iChannelResolution[0].xy;\n    float pct = abs(sin(iTime));\n    // TESTING\n    // set iChannel0 to 'Misc/Buffer A' and fetch sample\n    //fragColor = texture(iChannel0, uv);\n    //fragColor *= texture(iChannel2, uv);\n    //fragColor = texture(iChannel2, uv);\n    //fragColor += texture(iChannel0, uv);\n    //fragColor = texture(iChannel2,uv); \n    //fragColor =mix(iChannel1.uv, iChannel2.uv)\n    vec4 tex0 = texture(iChannel0, uv);\n    vec4 tex1 = texture(iChannel1, uv);\n    vec4 tex2 = texture(iChannel2, uv);\n    fragColor = mix(tex0, tex2, pct);\n    \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n//  -> COMMON TAB (shared with all other tabs)\n\n//------------------------------------------------------------\n// TYPE ALIASES & UTILITY FUNCTIONS\n\n// sScalar: alias for a 1D scalar (non-vector)\n#define sScalar float\n\n// sCoord: alias for a 2D coordinate\n#define sCoord vec2\n\n// sDCoord: alias for a 2D displacement or measurement\n#define sDCoord vec2\n\n// sBasis: alias for a 3D basis vector\n#define sBasis vec3\n\n// sPoint: alias for a point/coordinate/location in space\n#define sPoint vec4\n\n// sVector: alias for a vector/displacement/change in space\n#define sVector vec4\n\n\n// color3: alias for a 3D vector representing RGB color\n// \t(this is non-spatial so neither a point nor vector)\n#define color3 vec3\n\n// color4: alias for RGBA color, which is non-spatial\n// \t(this is non-spatial so neither a point nor vector)\n#define color4 vec4\n\n\n// asPoint: promote a 3D vector into a 4D vector \n//\trepresenting a point in space (w=1)\n//    v: input 3D vector to be converted\nsPoint asPoint(in sBasis v)\n{\n    return sPoint(v, 1.0);\n}\n\n// asVector: promote a 3D vector into a 4D vector \n//\trepresenting a vector through space (w=0)\n//    v: input 3D vector to be converted\nsVector asVector(in sBasis v)\n{\n    return sVector(v, 0.0);\n}\n\n\n// lengthSq: calculate the squared length of a vector type\n//    x: input whose squared length to calculate\nsScalar lengthSq(sScalar x)\n{\n    return (x * x);\n    //return dot(x, x); // for consistency with others\n}\nsScalar lengthSq(sDCoord x)\n{\n    return dot(x, x);\n}\nsScalar lengthSq(sBasis x)\n{\n    return dot(x, x);\n}\nsScalar lengthSq(sVector x)\n{\n    return dot(x, x);\n}\n\n\n//------------------------------------------------------------\n// VIEWPORT INFO\n\n// sViewport: info about viewport\n//    viewportPoint: location on the viewing plane \n//\t\t\t\t\t\t\tx = horizontal position\n//\t\t\t\t\t\t\ty = vertical position\n//\t\t\t\t\t\t\tz = plane depth (negative focal length)\n//\t  pixelCoord:    position of pixel in image\n//\t\t\t\t\t\t\tx = [0, width)\t-> [left, right)\n//\t\t\t\t\t\t\ty = [0, height)\t-> [bottom, top)\n//\t  resolution:    resolution of viewport\n//\t\t\t\t\t\t\tx = image width in pixels\n//\t\t\t\t\t\t\ty = image height in pixels\n//    resolutionInv: resolution reciprocal\n//\t\t\t\t\t\t\tx = reciprocal of image width\n//\t\t\t\t\t\t\ty = reciprocal of image height\n//\t  size:       \t in-scene dimensions of viewport\n//\t\t\t\t\t\t\tx = viewport width in scene units\n//\t\t\t\t\t\t\ty = viewport height in scene units\n//\t  ndc: \t\t\t normalized device coordinate\n//\t\t\t\t\t\t\tx = [-1, +1) -> [left, right)\n//\t\t\t\t\t\t\ty = [-1, +1) -> [bottom, top)\n// \t  uv: \t\t\t screen-space (UV) coordinate\n//\t\t\t\t\t\t\tx = [0, 1) -> [left, right)\n//\t\t\t\t\t\t\ty = [0, 1) -> [bottom, top)\n//\t  aspectRatio:   aspect ratio of viewport\n//\t  focalLength:   distance to viewing plane\nstruct sViewport\n{\n    sPoint viewportPoint;\n\tsCoord pixelCoord;\n\tsDCoord resolution;\n\tsDCoord resolutionInv;\n\tsDCoord size;\n\tsCoord ndc;\n\tsCoord uv;\n\tsScalar aspectRatio;\n\tsScalar focalLength;\n};\n\n// initViewport: calculate the viewing plane (viewport) coordinate\n//    vp: \t\t      output viewport info structure\n//    viewportHeight: input height of viewing plane\n//    focalLength:    input distance between viewer and viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid initViewport(out sViewport vp,\n                  in sScalar viewportHeight, in sScalar focalLength,\n                  in sCoord fragCoord, in sDCoord resolution)\n{\n    vp.pixelCoord = fragCoord;\n    vp.resolution = resolution;\n    vp.resolutionInv = 1.0 / vp.resolution;\n    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;\n    vp.focalLength = focalLength;\n    vp.uv = vp.pixelCoord * vp.resolutionInv;\n    vp.ndc = vp.uv * 2.0 - 1.0;\n    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;\n    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * 0.5, -vp.focalLength));\n}\n\n\n//------------------------------------------------------------\n// RAY INFO\n\n// sRay: ray data structure\n//\t  origin: origin point in scene\n//    direction: direction vector in scene\nstruct sRay\n{\n    sPoint origin;\n    sVector direction;\n};\n\n// initRayPersp: initialize perspective ray\n//    ray: \t\t   output ray\n//    eyePosition: position of viewer in scene\n//    viewport:    input viewing plane offset\nvoid initRayPersp(out sRay ray,\n             \t  in sBasis eyePosition, in sBasis viewport)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    ray.origin = asPoint(eyePosition);\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    ray.direction = asVector(viewport - eyePosition);\n}\n\n// initRayOrtho: initialize orthographic ray\n//    ray: \t\t   output ray\n//    eyePosition: position of viewer in scene\n//    viewport:    input viewing plane offset\nvoid initRayOrtho(out sRay ray,\n             \t  in sBasis eyePosition, in sBasis viewport)\n{\n    // offset eye position to point on plane at the same depth\n    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);\n}\n\n\n//------------------------------------------------------------\n/*\n// GLSL FRAGMENT SHADER STRUCTURE WITH COMMON TAB\n//  -> This is (likely) how Shadertoy compiles buffer tabs:\n\n// latest version or whichever is used\n#version 300 es\n\n// PROGRAM UNIFORMS (see 'Shader Inputs' dropdown)\n\n// **CONTENTS OF COMMON TAB PASTED HERE**\n\n// **CONTENTS OF BUFFER TAB PASTED HERE**\n\n// FRAGMENT SHADER INPUTS (more on this later)\n\n// FRAGMENT SHADER OUTPUTS (framebuffer render target(s))\n//out vec4 rtFragColor; // no specific target\nlayout (location = 0) out vec4 rtFragColor; // default\n\nvoid main()\n{\n    // Call 'mainImage' in actual shader main, which is \n\t// \tour prototyping interface for ease of use.\n\t//\t\trtFragColor:  shader output passed by reference,\n\t//\t\t\tfull vec4 read in 'mainImage' as 'fragColor'\n\t//\t\tgl_FragCoord: GLSL's built-in pixel coordinate,\n\t//\t\t\tvec2 part read in 'mainImage' as 'fragCoord'\n    mainImage(rtFragColor, gl_FragCoord.xy);\n}\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\n//  -> BUFFER A TAB (scene)\n\n//------------------------------------------------------------\n// RENDERING FUNCTIONS\n\n// calcColor: calculate the color of current pixel\n//\t  vp:  input viewport info\n//\t  ray: input ray info\ncolor4 calcColor(in sViewport vp, in sRay ray)\n{\n    // test inputs\n    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass\n    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass\n    //return color4(vp.uv, 0.0, 0.0);\n    //return color4(vp.ndc, 0.0, 0.0);\n    mat3 rotate = mat3(vec3(cos(iTime), 0.0 , sin(iTime)),\n                       vec3(0.0, 1.0, 0.0),\n                       vec3(-sin(iTime), 0.0, cos(iTime)));\n    vec3 cubeLoc = rotate * ray.direction.xyz;\n    return texture(iChannel0, cubeLoc);\n}\n\n\n//------------------------------------------------------------\n// SHADERTOY MAIN\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    // viewing plane (viewport) inputs\n    const sBasis eyePosition = sBasis(0.0);\n    const sScalar viewportHeight = 2.0, focalLength = 1.5;\n    \n    // viewport info\n    sViewport vp;\n\n    // ray\n    sRay ray;\n    \n    // render\n    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);\n    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);\n    fragColor += calcColor(vp, ray);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy);\n    vec3 luminate = vec3(0.4126, 0.7152, 0.5622);\n    float luminance = dot(luminate, tex.rgb);\n    tex.rgb *= luminance;\n    tex.a = 1.0;\n    if(tex.r < 1.5)\n    {\n        tex.rgb -= 0.46;\n    }\n    fragColor = tex;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//https://www.shadertoy.com/view/ltScRG \n//Was able to get a good grasp of what to do from this example \n\nconst int NumSamples = 25,\n          detail = 1,         //Level of Detail\n          sDetail = 1 << detail; // tile size = 2^LOD\nconst float sigma = float(NumSamples) * .25;\n\nfloat gaussian(vec2 i) \n{\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    \n    vec4 O = vec4(0);  \n    int s = NumSamples/sDetail;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sDetail) - float(NumSamples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(detail) );\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage(out vec4  fragColor, in vec2 fragCoord) {\n    vec4 blur = blur( iChannel0, fragCoord.xy/iChannelResolution[0].xy, 1./iChannelResolution[0].xy );\n    fragColor = blur;\n}","name":"Buffer C","description":"","type":"buffer"}]}