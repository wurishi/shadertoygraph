{"ver":"0.1","info":{"id":"4fSXRc","date":"1706807144","viewed":53,"name":"Base_geometry","username":"ChaosDragon","description":"A testing projecting for basical geometry.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R (iResolution.x/iResolution.y)\n\nfloat Sphere( vec2 p, vec2 c, float r)\n{\n    float d2 = distance(p, c);\n    return step(-r, -d2);\n}\n\nfloat Square( vec2 p, vec2 c, float a)\n{\n    float d1 = abs(p.x-c.x)+abs(p.y-c.y);\n    return step(-a, -d1);\n}\n\nfloat Rectangle( vec2 p, vec2 tl_ver, vec2 wh)\n{\n    float top = tl_ver.y;\n    float bottom = tl_ver.y-wh.y;\n    float left = tl_ver.x;\n    float right = tl_ver.x+wh.x;\n    // vec4 box = vec4(-top, bottom, left, -right);\n    // vec4 pos = vec4(-p.y, p.y, p.x, -p.x);\n    // bvec4 range = bvec4(step(box, pos));\n    // return float(range.x && range.y && range.z && range.w);\n    if(p.x>=left && p.x <= right && p.y >= bottom && p.y <= top)\n        return 1.;\n    else\n        return 0.;\n}\n\nvec2 Rotate( vec2 p, vec2 c, float phi)\n// Rotate the shape on the screen, counterclockwise\n{\n    float theta = radians(phi);\n    vec2 x = p - c;\n    vec2 x_hat = x*mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    return x_hat + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (height from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*vec2(R,1);\n    \n    //Center of pattern\n    vec2 cen = vec2(0.5*R, 0.5);\n    //Define a time and spatial varying color\n    vec3 varying_term = vec3(sin(iTime)*cos(uv.y), cos(uv.x*uv.y)*sin(uv.x+uv.y), sin(uv.x)*cos(iTime));\n    // Time varying pixel color\n    vec2 uv_hat = Rotate(uv, cen, 180.*sin(iTime));\n    //Geometry defination\n    float square = Square(uv_hat, cen, 0.5);\n    float sphere = Sphere(uv_hat, vec2(R/2.+sin(iTime)*R/2., 0.5-cos(iTime)*0.5), 0.3);\n    float rect = Rectangle(uv, cen/2., cen/4.);\n    \n    vec3 col = (square + sphere + rect) * varying_term;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}