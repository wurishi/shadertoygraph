{"ver":"0.1","info":{"id":"cdXBRn","date":"1688376289","viewed":36,"name":"Nbody problem fractal","username":"BagelOrb","description":">>Click to re-randomize.<<\nBasically the chaos of a 3-body problem\nCalculates the closest attractor among randomly generated positions on screen starting with zero velocity at each pixel.\nGravity equation is changed over time.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal","chaos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer A: main stuff\n// Buffer B: blurring\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst int MAX_ITER = 100;\n\nconst float E = .01; // step size\n\nconst float DRAG = .001; // limits the maximum velocity effectively\n\nconst float ANIMATION_SPEED = .5;\n\nconst float GRAVITY_OFFSET = .0; // offset to distance just to play with. Should be zero.\n\nconst int NUM_ATRS = 4;\n\nvec3[NUM_ATRS + 1] attractor_colors;\nvec2[NUM_ATRS] attractors;\n\nvec2 rand(in vec2 mousePos, in int extraSeed)\n{\n    float seed = fract(sin(dot(mousePos, vec2(12.9898, 78.233))) * 43758.5453 + 512.124 * float(extraSeed));\n    float x = seed;\n    float y = fract(seed * 11.61803398875);\n    return vec2(x, y);\n}\n\nvoid initVecList()\n{\n    for (int i = 0; i < NUM_ATRS; i++)\n    {\n        vec2 xy = rand(iMouse.xy / iResolution.xy, i);\n        attractors[i] = xy * .5 + .25;\n        vec3 rgb = vec3(xy, 1. - max(xy.x, xy.y));\n        attractor_colors[i] = rgb / max(rgb.r, max(rgb.g, rgb.b)) * .9; // Always put one channel at 1\n    }\n}\n\n// return index of closest attractor\nint attract(vec2 pos)\n{\n    vec2 v = vec2(0.);\n    int best_id = NUM_ATRS;\n    float best_dist = 100.;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        \n        // pos += normalize(vec2(.5,.5) - pos) * ;\n        for (int at_id = 0; at_id < NUM_ATRS; at_id++)\n        {\n            vec2 attractor = attractors[at_id];\n            vec2 dir = attractor - pos;\n            float d = length(dir);\n            \n            if (d < best_dist)\n            {\n                best_dist = d;\n                best_id = at_id;\n            }\n            \n            v += normalize(dir) / pow(d + GRAVITY_OFFSET, .5 + .6 * asin(sin(iTime * ANIMATION_SPEED)));\n        }\n        v -= v * v * DRAG;\n        pos += v * E;\n    }\n    return best_id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize the vecList array on the first frame\n    if (iFrame == 0 || length(attractors[0] - attractors[1]) == 0. || iMouse.z == 1.)\n    {\n        initVecList();\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n\n    int at_id = attract(pos);\n    \n    vec3 col = attractor_colors[at_id];\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Gaussian blur and time blur\n// ChatGPT generated\n\n// Define the size of the kernel\nconst int kernelSize = 5;\n\n// Define the standard deviation of the Gaussian distribution\nconst float sigma = .75;\n\nconst float TIME_BLUR = .75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the offset for each pixel\n    float offset = float(kernelSize) / 2.0;\n\n    // Accumulate the blurred color and the sum of weights\n    vec3 blurredColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    // Iterate over the kernel\n    for (int i = 0; i < kernelSize; i++)\n    {\n        for (int j = 0; j < kernelSize; j++)\n        {\n            // Calculate the sampling position\n            vec2 samplePos = vec2(float(i) - offset, float(j) - offset) / float(iResolution.xy);\n\n            // Calculate the Gaussian weight for the current sample position\n            float weight = exp(-(samplePos.x * samplePos.x + samplePos.y * samplePos.y) / (2.0 * sigma * sigma)) / (2.0 * 3.14159 * sigma * sigma);\n\n            // Accumulate the color\n            blurredColor += texture(iChannel0, fragCoord / iResolution.xy + samplePos).rgb * weight;\n\n            // Accumulate the weight\n            totalWeight += weight;\n        }\n    }\n\n    // Divide the accumulated color by the total weight\n    blurredColor /= totalWeight;\n\n    // Output the final blurred color\n    fragColor = mix(\n        vec4(blurredColor, 1.0), \n        texture(iChannel1, fragCoord / iResolution.xy),\n        TIME_BLUR);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}