{"ver":"0.1","info":{"id":"4tXyDB","date":"1506164239","viewed":270,"name":"Hexagon Genesis","username":"isak","description":"Animation showing how to generate a hexagonal grid, or partitioning. Visually explaining the process.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["animation","mod","floor","hexagons","genesis","partitioning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by IQ shader https://www.shadertoy.com/view/Xd2GR3\n\n#define PI 3.1415926535897932\n\n#define COL_R vec4(1, 0, 0, 1)\n#define COL_B vec4(0, 0, 1, 1)\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat trigger(float a, float b, float t) {\n\treturn step(a, t) - step(b, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy  - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    \n    \n    float DT = 1.0; // Duration of step in seconds\n    float c_time = smoothstep(0.25, 0.5, mix(0.0, 1.0, mod(iTime,DT)/DT) );\n     \n    float N = 7.0;\n    \n    vec2 p = N*uv;   \n    vec2 Rp;\n   \tvec2 n = normalize(vec2(-1.0, 1.0));\n    float scale = tan(PI/6.0) - 1.0;\n    vec2 qf = floor(p);\n   \n    // Step 1\n    float step_1 = floor(p.x/(0.00001 + c_time)); // 0.00001 to avoid div by 0 \n    \n    // Step 2\n    float step_2 = qf.x + c_time*qf.y;\n    \n    // Step 3\n    float step_3 = mix(1.0, 2.0, c_time)*floor((qf.x + qf.y + 2.0*c_time)/(1.0 + 2.0*c_time));\n    \n    // Step 4\n    qf = floor( p + c_time*scale*dot(p, n)*n );\n    float step_4 = 2.0*floor( (qf.x + qf.y + 2.0) / 3.0 );\n \t\n    // Step 5\n    qf = floor(p + scale*dot(p, n)*n);\n    float vs_f = floor( (qf.x + qf.y + 2.0) / 3.0 );\n    float step_5 = mix(2.0*vs_f, abs(vs_f)*0.71*2.449, c_time);\n    \n    // Step 6\n    float ss = 2.4494897427831781;  // Sqrt(3)*Sqrt(2)\n    vec2 v1 = ss*rot(PI/6.0 - PI/2.0)*vec2(1.0, 0.0);\n    vec2 v2 = ss*rot(-PI/6.0 + PI/2.0)*vec2(1.0,0.0);\n    Rp = rot(-c_time*PI/12.0)*p;\n    qf = floor(Rp + scale*dot(Rp, n)*n);\n    float f1 = floor( (qf.x + qf.y + 2.0) / 3.0 );\n    Rp = rot(-c_time*(PI/3.0 + PI/12.0))*p;\n    qf = floor(Rp + scale*dot(Rp, n)*n);\n    float f2 = floor( (qf.x + qf.y + 2.0) / 3.0 );\n    vec2 pos = f1*v1 + f2*v2;\n    float step_6 = length(pos)*0.71;\n    \n    // Step 7\n    Rp = rot(-PI/12.0)*p;\n    qf = floor(Rp + scale*dot(Rp, n)*n);\n    f1 = floor( (qf.x + qf.y + 2.0) / 3.0 );\n    Rp = rot(-PI/3.0 -PI/12.0)*p;\n    qf = floor(Rp + scale*dot(Rp, n)*n);\n    f2 = floor( (qf.x + qf.y + 2.0) / 3.0 );\n    pos = f1*v1 + f2*v2;\n   \tfloat step_7 = (1.0 - c_time)* length(pos)*0.71;\n\n    // Composition\n    float T = 7.0*DT;\n    float glob_time = clamp(mod(iTime, T), 0.0, T);\n    float final = trigger( 0.0*DT, 1.0*DT, glob_time)*step_1\n        \t    + trigger( 1.0*DT, 2.0*DT, glob_time)*step_2\n    \t\t\t+ trigger( 2.0*DT, 3.0*DT, glob_time)*step_3\n        \t\t+ trigger( 3.0*DT, 4.0*DT, glob_time)*step_4\n        \t\t+ trigger( 4.0*DT, 5.0*DT, glob_time)*step_5\n    \t\t\t+ trigger( 5.0*DT, 6.0*DT, glob_time)*step_6\n       \t\t\t+ trigger( 6.0*DT, 7.0*DT, glob_time)*step_7;\n    \t\t\t\n    float shade = final; \n    fragColor = (COL_R*shade - COL_B*shade)/(N);\n    \n}","name":"Image","description":"","type":"image"}]}