{"ver":"0.1","info":{"id":"7tcBW8","date":"1663107649","viewed":102,"name":"Mesh Raytracing","username":"FifthStateOfMatter","description":"Raytracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define epsilon 0.0001\n#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define FOV 90.0*degreesToRadians\n#define objClr vec3(1, 0, 0)\n#define fogDensity 0.0\n#define fogColor vec3(0.9)\n\nfloat f = 1.0/tan(FOV/2.0);\n\nstruct sphere{\n    vec3 center;\n    float radius;\n};\n\nstruct material{\n    vec3 clr;\n};\n\nstruct triangle{\n    vec3 v1;\n    vec3 v2;\n    vec3 v3;\n    material mat;\n};\n\nbool raytraceSphere(vec3 orig, vec3 dir, out float t, sphere sphr){\n    vec3 oc = orig - sphr.center;\n    float a = dot(dir, dir);\n    float b = 2.0*dot(oc, dir);\n    float c = dot(oc, oc) - sphr.radius*sphr.radius;\n    float d = b*b - 4.0*a*c;\n    t = (-b - sqrt(d))/(2.0*a);\n    bool h;\n    d >= 0.0 ? h = true : h = false;\n    return h;\n}\n\nbool raytraceTri(vec3 orig, vec3 dir, triangle tri, out float t, out material mat){\n    vec3 d1 = tri.v2 - tri.v1;\n    vec3 d2 = tri.v3 - tri.v1;\n    \n    vec3 normal = cross(d1, d2);\n    \n    float area = length(normal);\n    float rayNormalDot = dot(dir, normal);\n    if(abs(rayNormalDot) < epsilon){\n        return false;\n    }\n    \n    float d = -dot(tri.v1, normal);\n    \n    t = -(dot(orig, normal) + d)/rayNormalDot;\n    \n    if(t < 0.0){\n        return false;\n    }\n    \n    vec3 p = orig + dir*t;\n    \n    vec3 c;\n    \n    vec3 edge1 = tri.v2 - tri.v1;\n    vec3 vp1 = p - tri.v1;\n    c = cross(edge1, vp1);\n    if(dot(c, normal) < 0.0){\n        return false;\n    }\n    \n    vec3 edge2 = tri.v3 - tri.v2;\n    vec3 vp2 = p - tri.v2;\n    c = cross(edge2, vp2);\n    if(dot(c, normal) < 0.0){\n        return false;\n    }\n    \n    vec3 edge3 = tri.v1 - tri.v3;\n    vec3 vp3 = p - tri.v3;\n    c = cross(edge3, vp3);\n    if(dot(c, normal) < 0.0){\n        return false;\n    }\n    \n    mat = tri.mat;\n    return true;\n}\n\nconst int meshLength = 12;\n\ntriangle[meshLength] transformMesh(triangle[meshLength] tris, float xT, float yT, float tX, float tY, float tZ, float sX, float sY, float sZ){\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(xT*degreesToRadians), -sin(xT*degreesToRadians));\n    xRotation[2] = vec3(0, sin(xT*degreesToRadians), cos(xT*degreesToRadians));\n\n    mat3 yRotation;\n    yRotation[0] = vec3(cos(yT*degreesToRadians), 0, sin(yT*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(-sin(yT*degreesToRadians), 0, cos(yT*degreesToRadians));\n    \n    triangle[meshLength] outPut;\n    for(int i = 0; i < meshLength; i++){\n        outPut[i] = triangle(tris[i].v1*vec3(sX, sY, sZ)*xRotation*yRotation + vec3(tX, tY, tZ), tris[i].v2*vec3(sX, sY, sZ)*xRotation*yRotation + vec3(tX, tY, tZ), tris[i].v3*vec3(sX, sY, sZ)*xRotation*yRotation + vec3(tX, tY, tZ), tris[i].mat);\n    }\n    return outPut;\n}\n\ntriangle[] mesh = triangle[](\n    triangle(vec3(-2, 2, -2), vec3(2, -2, -2), vec3(-2, -2, -2), material(objClr)),\n    triangle(vec3(-2, 2, -2), vec3(2, 2, -2), vec3(2, -2, -2), material(objClr)),\n    triangle(vec3(2, 2, -2), vec3(2, -2, 2), vec3(2, -2, -2), material(objClr)),\n    triangle(vec3(2, 2, -2), vec3(2, 2, 2), vec3(2, -2, 2), material(objClr)),\n    triangle(vec3(2, 2, 2), vec3(-2, -2, 2), vec3(2, -2, 2), material(objClr)),\n    triangle(vec3(2, 2, 2), vec3(-2, 2, 2), vec3(-2, -2, 2), material(objClr)),\n    triangle(vec3(-2, 2, 2), vec3(-2, -2, -2), vec3(-2, -2, 2), material(objClr)),\n    triangle(vec3(-2, 2, 2), vec3(-2, 2, -2), vec3(-2, -2, -2), material(objClr)),\n    triangle(vec3(-2, 2, 2), vec3(2, 2, -2), vec3(-2, 2, -2), material(objClr)),\n    triangle(vec3(-2, 2, 2), vec3(2, 2, 2), vec3(2, 2, -2), material(objClr)),\n    triangle(vec3(-2, -2, -2), vec3(2, -2, 2), vec3(-2, -2, 2), material(objClr)),\n    triangle(vec3(-2, -2, -2), vec3(2, -2, -2), vec3(2, -2, 2), material(objClr))\n);\n\nbool raytraceMesh(vec3 orig, vec3 dir, triangle[meshLength] tris, out float t, out vec3 normals, out material mat){\n    float minT = 10000000.0;\n    int index = 0;\n    bool h = false;\n    for(int i = 0; i < meshLength; i++){\n        float testT;\n        bool r = raytraceTri(orig, dir, tris[i], testT, mat);\n        if(r && testT < minT && testT > 0.0){\n            minT = testT;\n            index = i;\n            h = true;\n        }\n    }\n    t = minT;\n    normals = cross(tris[index].v2 - tris[index].v1, tris[index].v3 - tris[index].v1);\n    mat = tris[index].mat;\n    return h;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    vec3 orig = vec3(0, 0, 0);\n    vec3 dir = vec3(uv.xy, 1)*projection;\n    float t;\n    vec3 normal;\n    material mat;\n    bool r = raytraceMesh(orig, dir, transformMesh(mesh, iTime*25.0, iTime*25.0, 0.0, 0.0, 11.0, 1.0, 0.5, 2.0), t, normal, mat);\n    vec3 rh = orig + dir*t;\n    vec3 lp = vec3(10, 10, -10);\n    vec3 lr = lp - rh;\n    float d = (dot(normalize(normal), normalize(lr)) + 1.0)/2.0;\n    float spec = d*d;\n    spec *= spec;\n    spec *= spec;\n    spec *= spec;\n    spec *= spec;\n    spec *= spec;\n    spec *= spec;\n    spec *= spec;\n    spec *= spec;\n    vec3 col;\n    r && dot(rh, normal) <= 0.0 ? col = col = mix(mat.clr*d + spec, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0)) : col = fogColor;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}