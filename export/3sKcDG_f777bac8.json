{"ver":"0.1","info":{"id":"3sKcDG","date":"1603651445","viewed":127,"name":"Enhanced&relaxed sphere tracing","username":"abence2","description":"Controls:\n    WASD    - camera movement\n    E           - use normal sphere tracing\n    R           - use relaxed sphere tracing\n    T           - use enhanced sphere tracing\n    G           - show sdf evaluation count (black=0,white=128)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int KeyG     = 71;\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 scene = texelFetch(iChannel0,ivec2(fragCoord),0);\n    int steps = int(scene.w);\n   \n    fragColor = scene;\n    \n    if (isKeyHeld(KeyG))\n    \tfragColor = vec4(float(steps)/128.);\n    \n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n///SDF\n\nfloat sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    float f = sdSphere(p, 1.);\n    float g = sdBox(p-vec3(2,0,0),vec3(1,1,1));\n    float h = sdBox(p,vec3(20));\n    return min(\n        min(f, g),\n        min(p.y+1., -h)\n        //p.y+1.\n    );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n                    // bit 2:   iteration condition:    true if took too many iterations\n    int steps;      // Count of SDF evaluations\n};\n\nstruct SphereTraceDesc\n{\n    float epsilon;  // Stopping distance to surface\n    int maxiters;   // Maximum iteration count\n};\n\nTraceResult normal_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n\nTraceResult relaxed_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d = 0.0;\n    float prev_t = ray.Tmin;\n    float prev_d = 0.;\n    const float omega = 1.6;\n    \n    int i = 0; do\n    {\n        prev_d = d;\n        \n        d = sdf(ray.P+ret.T*ray.V);\n        \n        // If the bigger step was a mistake\n        if (prev_d + d < omega * prev_d)\n        {\n            // Step back and take a normal step\n            ret.T = prev_t + prev_d;\n            d = sdf(ray.P+ret.T*ray.V);\n            ++i;\n        }\n        \n        prev_t = ret.T;\n        ret.T += d * omega;\n        \n        ++i;\n    } while (\n\t\tprev_t < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * prev_t &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.T = prev_t;\n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult enhanced_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d = 0.0;\n    float prev_t = ray.Tmin;\n    float prev_d = 0.;\n    const float omega = 0.9;\n    float next_d = 0.;\n    \n    int i = 0; do\n    {\n        prev_d = d;\n        \n        d = sdf(ray.P+ret.T*ray.V);\n        \n        // If the bigger step was a mistake\n        if (d < omega * next_d || d < 0.)\n        {\n            // Step back and take a normal step\n            ret.T = prev_t + prev_d;\n            d = sdf(ray.P+ret.T*ray.V);\n        }\n        \n        float diff_d = d - prev_d;\n        float diff_t = ret.T - prev_t;\n        next_d = diff_t - diff_d > 0. ? d * (diff_t + diff_d) / (diff_t - diff_d) : 0.;\n        next_d = max(0., next_d);\n        \n        prev_t = ret.T;\n        ret.T += d + next_d * omega;\n        \n        ++i;\n    } while (\n\t\tprev_t < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * prev_t &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.T = prev_t;\n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nint g_algo;\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    if (g_algo == 0)\n        return normal_sphere_trace(ray, params);\n    \n    if (g_algo == 1)\n    \treturn relaxed_sphere_trace(ray, params);\n    \n    return enhanced_sphere_trace(ray, params);\n}\n\n// ---- SHADING ----\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    \n \n    vec3 lightPos=vec3(10.,10.,10.);\n    \n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = vec3(1./pi);\n    \n    //specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = vec3(0.4);\n    \n    Ray shadow_ray = Ray(p, 0.05, l, distance(p,lightPos));\n    \n    SphereTraceDesc params = SphereTraceDesc(0.0006, 64);\n    TraceResult result = sphere_trace(shadow_ray, params);\n    \n    \n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),160.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    \n    if(bool(result.flags&2)) col = vec3(0); //arnyek\n    if(bool(result.flags&4)) col = vec3(0,1,0); //arnyek\n    \n    return vec4(col,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeySpace = 32;\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\nconst int KeyE     = 69;\nconst int KeyR     = 82;\nconst int KeyT     = 84;\nconst int Key0     = 0x30;\nconst int Key1     = 0x31;\nconst int Key2     = 0x32;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nvoid KeyEvents()\n{\n    if (isKeyHeld(KeyE))\n        g_algo = 0;\n    else if (isKeyHeld(KeyR))\n        g_algo = 1;\n    else if (isKeyHeld(KeyT))\n        g_algo = 2;\n}\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2, out bool moved)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n    moved = false;\n\tfloat speed = 5. * iTimeDelta;\n    if (isKeyHeld(KeyLeft )) { eye -= u*speed; moved = true; }\n    if (isKeyHeld(KeyRight)) { eye += u*speed; moved = true; }\n    if (isKeyHeld(KeyUp   )) { eye += w*speed; moved = true; }\n    if (isKeyHeld(KeyDown )) { eye -= w*speed; moved = true; }\n    if (isKeyHeld(KeySpace)) { eye = vec3(0);  moved = true; }\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n    {\n        data2 = abs(data2.xy);\n        moved = true;\n    }\n\telse if(data2.x >= 0.)\t//mouse released\n    {\n        data2 = -mod(uv,2.*pi);\n        moved = true;\n    }\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.05,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nvoid renderScene(in Ray ray, out vec4 fragColor)\n{\n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.0006, 64);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n        \n    fragColor.w = float(result.steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    bool cameraMoved;\n    Ray ray = Camera(fragCoord, eye, data, cameraMoved);\n    \n    g_algo = int(texelFetch(iChannel0, ivec2(2,0), 0).x);\n    \n    KeyEvents();\n    \n\trenderScene(ray, fragColor);\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) // pixel (1,0)\n        fragColor.zw = data;\n    if(fragCoord.x == 2.5 && fragCoord.y == 0.5) // pixel (2,0)\n        fragColor.x = float(g_algo);\n}","name":"Buf A","description":"","type":"buffer"}]}