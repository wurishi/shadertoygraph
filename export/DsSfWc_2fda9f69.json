{"ver":"0.1","info":{"id":"DsSfWc","date":"1695332231","viewed":41,"name":"First Raymarching Experiments","username":"Seebone","description":"My first raymarching shader. Better AA would be good. Performance with multiple lights is quite bad.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mostly from reading iq's amazing articles.\n// There's bound to be a lot of errors here, but it's (at least on my machine) functional.\n#define err .0001\n#define MAX_ITERATIONS 400\n#define MAX_DIST 80.\n \n// Bad but functional. Didn't have time to research how to actually do AA.\n//#define EDGE_AA\n\n#define LIGHT_COUNT 2\n\n/* constants */\n#define M_PI 3.1415926535897932384626433832795\n#define M_TAU 6.2831853071795864769252867665590\n#define M_SQRT2 1.4142135623730950488016887242096\n#define FLT_MAX 3.402823466e+38\n\n\n// Material properties (just params, not pbr at all)\nstruct Mat {\n    vec3 col; // Color\n    float ref; // reflectivity (at point completely facing light)\n    float colRef; // How much the reflected light keeps the light color\n};\n\nstruct Light {\n    vec3 pos; // position\n    vec3 col; // color\n    float lum; // brightness\n};\n\n// Not phase-adjusted to begin at 0\nfloat adjustedSine(float x, float yMin, float yMax, float period) {\n    return .5*((yMax - yMin) * sin(M_TAU*x/period) + yMax + yMin);\n}\n\n// https://www.desmos.com/calculator/udnerpr09b\nfloat smp(float x, float yMin, float yMax, float period, float L) {\n    period = abs(period)*.5;\n    L = clamp(L, 0., 1.)*period;\n    // Function\n    x += .5*L;\n    bool a = mod(x,2.*period) >= period;\n    x = (a ? 1. : -1.)*smoothstep(L, period, mod(x, period)) + (a ? 0. : 1.);\n    \n    //shifting\n    return yMin + (yMax - yMin)*x;\n}\n\n// https://iquilezles.org/articles/functions/\nfloat truncFalloff( float x, float m ) {\n    x = 1.0/((x+1.0)*(x+1.0));\n    m = 1.0/((m+1.0)*(m+1.0));\n    return (x-m)/(1.0-m);\n}\n\nfloat sdSphere(vec3 p, float radius, vec3 spherePos) {\n    return distance(p, spherePos) - radius;\n}\n\nfloat sdHPlane(vec3 p, float level) {\n    return abs(p.y - level);\n}\n\n// From: https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e ) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// get the normalized ray coresponding to a certain point\nvec3 getRay(vec2 uv, vec3 viewDir) {\n    \n    // https://www.math3d.org/6EvPX6TgC\n    // Check if looking straight up or down\n    vec3 right;\n    vec3 up;\n    float vxzLen = length(vec2(viewDir.x, viewDir.z));\n    right = vec3(-viewDir.z, 0., viewDir.x)/vxzLen;\n    // First one should work, but it gets really unstable when vxzLen approaches 0\n    //up = -vec3(viewDir.x*viewDir.y/vxzLen, -vxzLen, viewDir.y*viewDir.z)/length(viewDir);\n    up = cross(right, viewDir);\n    const float planeDist = 1.; // fov\n    \n    vec3 uv3D = normalize(viewDir)*planeDist + uv.x*right + uv.y*up;\n    \n    \n    // Normalized vector from camera\n    return normalize(uv3D);\n    \n    // not relevant to anything here: https://www.math3d.org/cJyaS7Vby\n}\n\n\nbool idEq(float ID1, float ID2) {\n    return abs(ID1 - ID2) <= .1;\n}\n\n// Get the nth light\nLight getLight(int ID) {\n    Light light;\n    // Returning light\n    if (ID == 2) {\n        light.pos = vec3(10.,10.,0.);\n        light.col = vec3(1.000,1.000,1.000);\n        light.lum = 200.;\n        return light;\n    }\n    if (ID == 1) {\n        light.pos = 5.*vec3(cos(iTime+M_PI), 0., sin(iTime+M_PI)) + vec3(0.,3.,0.);\n        light.col = vec3(1.000,0.000,0.000);\n        light.lum = 20.;\n        return light;\n    }\n\n    return light;\n}\n\nMat getMat(float ID, vec3 p) {\n    Mat m;\n    \n    if (ID < 0.) return m;\n    \n    // Ball\n    if (idEq(ID, 1.)) {\n        m.col = vec3(1.,0.,0.);\n        m.ref = .5;\n        m.colRef = .3;\n        return m;\n    }\n    \n    // Floor\n    if (idEq(ID, 2.)) {\n        // Hideous aliasing:\n        //m.col = mix(vec3(0.), vec3(1.), (abs(mod(p.x,2.)) > 1.) ^^ (abs(mod(p.z,2.)) > 1.) ? 1. : 0.);\n        \n        // Without aliasing. Probably still better to use an actual 2D distance field:\n        float x = smp(p.x, 0., 1., 2., .95);\n        float y = smp(p.z, 0., 1., 2., .95);\n        m.col = mix(vec3(0.), vec3(1.), .5*(x+y)-x*y);\n        //m.col = vec3(.1);\n        m.ref = .7;\n        m.colRef = .3;\n        return m;\n    }\n    \n    // Ball\n    if (idEq(ID, 3.)) {\n        m.col = vec3(0.,1.,0.);\n        m.ref = .6;\n        m.colRef = .3;\n        return m;\n    }\n    // Ball\n    if (idEq(ID, 4.)) {\n        m.col = vec3(0.141,0.122,0.192);\n        m.ref = .6;\n        m.colRef = .3;\n        return m;\n    }\n    \n    // Box frame \n    if (idEq(ID, 5.)) {\n        m.col = vec3(0.000,1.000,1.000);\n        m.ref = .8;\n        m.colRef = .3;\n        return m;\n    }\n    \n    return m;\n}\n\nvec2 getDistID(vec3 v) {\n        float D1 = sdSphere(v, .5, vec3(4.*cos(.75*iTime),adjustedSine(iTime, 1., 5., 4.),4.*sin(iTime)));\n        vec2 O1 = vec2(D1,                                1.);\n        vec2 O2 = vec2(sdHPlane(v, 0.),                   2.);\n        vec2 O3 = vec2(sdSphere(v, .8, vec3(4.*sin(.2*iTime),2.,4.*cos(.2*iTime))),   3.);\n        vec2 O4 = vec2(sdSphere(v, 2., vec3(0.,1.,0.)),   4.);\n        vec2 O5 = vec2(sdBoxFrame(v-vec3(6.,2.,-6.), vec3(2.,2.,2.), .2), 5.);\n        \n        // Find minimum distance\n        // abs?\n        vec2 O;\n        O = O1;\n        if (abs(O2.x) < abs(O.x)) O = O2;\n        if (abs(O3.x) < abs(O.x)) O = O3;\n        if (abs(O4.x) < abs(O.x)) O = O4;\n        if (abs(O5.x) < abs(O.x)) O = O5;\n\n        return O;\n}\n\nfloat dist(vec3 v) {\n    return getDistID(v).x;\n}\n\n// returns vec2(distance from ro to hit, material ID at hit)\nvec2 rayMarch(vec3 ro, vec3 rd, float maxDist) {\n    float rayLen = 0.;\n    vec2 O;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {   \n       O = getDistID(ro + rd*rayLen);\n       \n       if(abs(O.x) <= err) {\n            return vec2(rayLen, O.y);\n        }\n        \n       rayLen += O.x;    \n       if(rayLen >= maxDist) {\n           break;;\n       }\n    }\n    return vec2(-1.);\n}\n\n// The normal is the gradient of the sdf\n// https://iquilezles.org/articles/normalsSDF/\n// faster than central differences, I don't completely understand this yet\nvec3 normal( in vec3 p ) {\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*dist( p + k.xyy*h ) + \n                      k.yyx*dist( p + k.yyx*h ) + \n                      k.yxy*dist( p + k.yxy*h ) + \n                      k.xxx*dist( p + k.xxx*h ) );\n}\n\n// Thanks to Real_NC https://www.shadertoy.com/user/Real_NC\n// I have no idea how this works\nvec3 getVolumeLuminance (vec3 ro, vec3 rd, float d) {\n    vec3 lum = vec3(0);\n    float dMax;\n    float dMin;\n    Light light;\n    for(int ID = 1; ID <= LIGHT_COUNT; ID++)\n    {\n        light = getLight(ID);\n        dMin = dot(rd, light.pos - ro);\n        dMax = sqrt(max(.01 - pow(distance(light.pos, ro + rd*dMin), 2.), 1e-20));\n        dMin -= dMax;\n        dMax += dMin + dMax;\n        \n        dMax = min(dMax, d);\n        dMin = max(dMin, 0.);\n        \n        lum += light.col*(max(dMax - dMin, 0.))*4.;\n    }\n    lum += pow(length(lum)*2., 2.)*0.2;\n    return lum;\n}\n\n\nvec3 getCol(vec2 hit, vec3 camPos, vec3 ray) {\n    vec3 col = vec3(0.);\n    vec3 p = camPos + ray*hit.x;\n    vec3 N = normal(p);\n    Mat objMat = getMat(hit.y,p);\n    \n    // Determine light color and intensity\n    vec3 lightCol;\n    float luminance;\n    for (int ID = 1; ID <= LIGHT_COUNT; ID++) {\n       Light light = getLight(ID);\n       float lightDist = distance(p, light.pos);\n       \n       // See if there is anything between p and light\n       vec2 lightSearch = rayMarch(p+N*2.*err, normalize(light.pos-p), lightDist);\n       \n       // If there is no object between the light and current position\n       if(lightSearch.y < 0.) {\n           // how much the surface is facing the light\n           float intensity = clamp(dot(normalize(light.pos-p),N),0.,1.);\n           // inverse square law\n           \n           // the color a light contributes should be proportional to its intensity\n           lightCol += light.col*intensity;\n           // Inverse square law, but making infinite planes look good\n           luminance += light.lum*intensity*truncFalloff(lightDist,MAX_DIST - distance(light.pos, camPos));\n       }\n    \n    }\n    \n    // Calculate the final light color as an average of all lights \n    lightCol /= float(LIGHT_COUNT);\n    //luminance /= float(LIGHT_COUNT); // probably wan't this to stack\n    \n    // Simulating overexposure, cameras see brighter liht as more white\n    lightCol += .2*luminance*luminance;\n    \n    col = luminance * objMat.ref  * mix(objMat.col, lightCol, objMat.colRef);\n    \n    col += getVolumeLuminance(camPos, ray, hit.y > 0. ? hit.x : MAX_DIST);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.x;\n\n        // y is height\n    vec3 camPos = 15.*vec3(cos(.3333*iTime),0.,sin(.2*iTime))+vec3(0.,2.3+2.*cos(.5*iTime),0.);\n    //vec3 camPos = vec3(0.,4.,15.);\n    vec3 viewDir = normalize(-camPos+vec3(0.,2.,0.)); // magnitude needs to be 1\n\n    vec3 ray = getRay(uv, viewDir);\n    vec2 hit = rayMarch(camPos, ray, MAX_DIST);\n    vec3 col = getCol(hit, camPos, ray);\n\n    #ifdef EDGE_AA\n\n    // Smoothing edges.\n    // Makes the ray continue and blends the edges of objects with the objects behind them\n    vec3 p = camPos + ray*hit.x;\n    // yes, the normal is calculated twice for no reason\n    p += normal(p)*.005;\n    vec2 hit1 = rayMarch(p, ray, MAX_DIST);\n    if (!idEq(hit1.y, hit.y)) col = mix(getCol(hit1, p, ray), col, .5);\n\n        #endif\n\n    // Gamma correction?\n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}