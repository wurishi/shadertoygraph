{"ver":"0.1","info":{"id":"ddXcRr","date":"1686524225","viewed":49,"name":"Overlapping circles Flower","username":"feeg1","description":"Changing color based on number of overlaps + some border highlighting","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"dsfyRr","parentname":"Overlapping circles testing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfCircle(vec2 point, vec2 center, float radius)\n{\n    return abs(length(point-center)-radius);\n}\nfloat circle(vec2 point, vec2 center, float radius, float blur)\n{\n    return smoothstep(radius+blur,radius-blur,length(point-center));\n}\n\nfloat scaledCos(float theta, float minimum, float maximum)\n{\n    return ((maximum-minimum)*cos(theta)+(maximum+minimum))*0.5;\n}\n\nconst float PI = 3.1415926;\nconst float TAU = PI * 2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv = uv0-vec2(0.5,0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float value = 0.;\n    \n    float numCircles = 8.;\n    float majorRadius = 0.4f;\n    float offset = 0.;\n    offset+= iTime/3.;\n    float rOffset = scaledCos(iTime+PI,0.4,0.7);\n    float minDist = 100.;\n    for(float i = 0.; i < numCircles; i++)\n    {\n        vec2 center = majorRadius*vec2(cos(TAU*i/(numCircles)+offset),sin(TAU*i/(numCircles)+offset));\n        minDist = min(abs(sdfCircle(uv,center,rOffset)),minDist);\n        value +=  round(circle(uv,center,rOffset,0.01));\n    }\n    rOffset *= 0.5;\n    majorRadius = 0.3;\n    for(float i = 0.; i < numCircles; i++)\n    {\n        vec2 center = majorRadius*vec2(cos(TAU*i/(numCircles)+offset),sin(TAU*i/(numCircles)+offset));\n        minDist = min(abs(sdfCircle(uv,center,rOffset)),minDist);\n        value +=  round(circle(uv,center,rOffset,0.01));\n    }\n    minDist = min(abs(sdfCircle(uv,vec2(0.),rOffset-0.2)),minDist);\n    value += round(circle(uv,vec2(0.),rOffset-0.2,0.01));\n    \n    majorRadius = 0.5;\n    rOffset = scaledCos(iTime+PI,0.03,0.05);\n    for(float i = 0.; i < numCircles; i++)\n    {\n        vec2 center = majorRadius*vec2(cos(TAU*i/(numCircles)+offset),sin(TAU*i/(numCircles)+offset));\n        minDist = min(abs(sdfCircle(uv,center,rOffset)),minDist);\n        value +=  round(circle(uv,center,rOffset,0.01));\n    }\n    \n    float c = 7./8.;\n    majorRadius += scaledCos(iTime,-0.08,0.05);\n    for(float i = 0.; i < numCircles; i++)\n    {\n        vec2 center = majorRadius*vec2(cos(TAU*i/(numCircles)+offset+PI*c),sin(TAU*i/(numCircles)+offset+PI*c));\n        minDist = min(abs(sdfCircle(uv,center,rOffset)),minDist);\n        value +=  round(circle(uv,center,rOffset,0.01));\n    }\n    \n    value = value / (numCircles*2.);\n    \n    vec3 light = vec3(0.8,0.1,0.1);\n    vec3 dark = 1.1*8.*vec3(0.2,0.1,0.2);\n    vec3 col = mix(dark,light,value);\n    value = 1.-value;\n    value = scaledCos(value,0.0f,1.0f);\n    float iTimeOffset = 100.;\n    value = scaledCos(value * 2.*(iTime+iTimeOffset),0.3f,0.9f);\n   // value = scaledCos(value*iTime*4.,0.3f,0.9f);\n    float eDist = 0.02;\n    if(minDist < scaledCos(iTime,0.01,eDist))\n    {\n        float d = 1.-smoothstep(0.,eDist,minDist);\n        col+= d*vec3(1.,0.7,0.7);\n    }\n  \n    fragColor = vec4(value*col,1.);\n}","name":"Image","description":"","type":"image"}]}