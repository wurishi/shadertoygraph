{"ver":"0.1","info":{"id":"XtcBDf","date":"1611980748","viewed":75,"name":"lava_lamp","username":"teraspora","description":".","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lava Lamp\n// a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Based on voronoi-2;\n// Date: Jan. 2021\n\n\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My own functions:\n\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n\nvec3 inc_hue(vec3 col, float delta) {\n    return changeHue(col, mod(hue(col) + delta, 1.));\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\t//return abs(pow(abs(pow(atan(v.x) - sin(u.x), order)) + abs(pow(atan(v.y) - sin(u.y), order)), 1. / order));\n    //return length(sin(length(pow(length(sinh(u + v)), order))));\n    return length(sin(length(sinh(u + v + 0.04 * cos(16. * sin(atan(u.y, v.x)))))));\n    //return dot(u, v);\n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(4483.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col; \n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 2. + 2.;\n    float numPoints = 7.; // clamp(floor(t / 2.), 0., 3.);\n    \n    t = 1. - t;\n    float scale =  13. *ncos(t / 293.); // / numPoints;\n    if (iTime > 20. && iTime < 60.) scale *= 2.;\n\tfloat asp = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n    // uv.x = abs(uv.x);\n    uv.y *=  6. *ncos(t / 31.);\n    uv.x *= 4.1 * nsin(t / numPoints);\n    float tk = 1.; // \n    mod(uv.x + uv.y, 2.) - 1.;\n    uv = rotate(uv, PI / 2. + tk * t / 17. );\n    float sr = sin(uv.x * 401.) > cos(uv.y * 283.) ? 1. : -1.;\n    // uv = rotate(uv, sr *  85.);\n    // uv.y = abs(uv.y);\n    uv.x = 2.-uv.x;\n    uv = polar(uv.x, uv.y);\n    if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    vec2 friz = vec2(8. * sin(t / 128. * uv.x), .1 * cos(t / 93. * uv.y));\n    vec2 vel = vec2(1., 1.);\n    \n    uv.yx *= vec2(om(sin(20. * friz.x * cos(vel.y * 1.) * uv.x) / 7.), om(cos(17. * friz.y * sin(vel.x * t) * uv.y) / 11.)); \n    // uv.y = abs(uv.y);\n    // col = crimson;\n    \n    float m = 0.;\n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * 1.);\n        // get distance to point\n        float d = minkd(uv, p, 1.0);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind + .5) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    // uv.y = abs(uv.y);\n    col = vec3(mind);\n    col.g -= nsin(1. + length(uv)) / 2.;\n    col.b += 0.5 * smoothstep(0., 1., col.r + col.b);\n    col.r *= 4.;\n \n    \n    \n    col = inc_hue(col, -cos(t / 3.) / 7.);\n    \n    if (rgb2hcv(col).z < 0.04) {\n        col = cos(0.3 * 1.+ uv.xyx / 6. + vec3(4.7,2.9,6.1));\n        // col.r = col.g;\n        // col = gold;\n    }\n    \n    fragColor = vec4(col.rgb, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ","name":"Image","description":"","type":"image"}]}