{"ver":"0.1","info":{"id":"ct2Bzz","date":"1693703281","viewed":91,"name":"Denoise Diffusion Implicit Model","username":"chronos","description":"Denoising Diffusion Implicit Model (DDIM) variant of Iterative :alpha: (De)Blending (Appendix C): https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["blending","diffusion","model","implicit","alpha","denoising","deblending","ddim"],"hasliked":0,"parentid":"ctlBRj","parentname":"Deblending Diffusion Model 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Current version info:\n\n// - Changed to using DDIM blending and deblending method. \n//   This changes the paths taken by the particles during the simulation\n//   But is otherwise theoretically equivalent to IADB according to the paper (Appendix C).\n//   As far as I understand, they adjust DDIM to behave as IADB in the paper,\n//   whereas here I adjust IADB to behave like DDIM.\n//   (Thanks to shadertoy user @pyBlob for making me aware of the existence of Appendix C!)\n\n// - Added new parameter and related code: 'num_subsamples' (see Common tab)\n//   This is for estimating the exected values of the gradient more accurately at each step.\n//   previously I used a single sample estimate at each step. \n//   as this parameter increases, the stochasticity at each step decreases.\n\n// - Also modified the simulation and rendering code slightly\n\n// Previous version info:\n\n// - Added more target shapes. Change the SCENE macro paramter in the \"Common tab\"\n\n// Based on the paper Iterative :alpha: (De)Blending: https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// and\n// https://www.shadertoy.com/view/mlXyRf by Fabrice Neyret\n\n// Buffer A computes the Transport Map by iterative alpha (de-)blending.\n// Buffer B draws the trails / trace\n// Buffer C draws the particles. Only a few while the mapping is computed, but then shows the rest.\n// The Common tab has additional parameters and helper functions.\n\n// If you have a faster GPU you can increase the 'num_substeps' parameter in the Buffer A tab, or reduce if you are on a slower GPU\n// Alternatively to can reduce or increase the 'total_steps'.\n// Lower number of total iteration steps takes less time but is more noisy\n// Higher number of total iteration steps takes longer time but is less noisy\n\nvec4 draw_target_shape(vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n#if SCENE == 4\n    float sdf1 = circle_sdf(uv, circle_center1, circle_radius1);\n    float sdf2 = circle_sdf(uv, circle_center1, circle_radius1*.5);\n    float sdf3 = circle_sdf(uv, circle_center2, circle_radius2);\n    float sdf4 = circle_sdf(uv, circle_center2, circle_radius2*.5);\n    float alpha1 = min(sdf1, sdf3);\n    float alpha2 = min(sdf2, sdf4);\n    alpha1 = smoothstep( 2./iResolution.y, 0., abs(alpha1) );\n    alpha2 = smoothstep( 2./iResolution.y, 0., abs(alpha2) );\n    float alpha = max(alpha1, alpha2);\n    return mix(fragColor, vec4(1), alpha);\n#else\n    float sdf1 = circle_sdf(uv, circle_center1, circle_radius1);\n    float sdf2 = circle_sdf(uv, circle_center2, circle_radius2);\n    float alpha1 = abs(sdf1);\n    float alpha2 = abs(sdf2);\n    float alpha = min(alpha1, alpha2);\n#endif\n    return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., alpha ) );\n}\n\nvec4 draw_source_shape(vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = pixel_to_uv(fragCoord, iResolution.xy);\n   float sdf = square_sdf(uv, box_center, radius);\n   float alpha = abs(sdf);\n   return mix(fragColor, vec4(1), smoothstep( 2./iResolution.y, 0., abs(alpha) ) );\n}\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_trace(vec2 U) { return  texelFetch( iChannel1, ivec2(U), 0 ); }\nvec4 get_particles(vec2 U) { return  texelFetch( iChannel2, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = get_trace(fragCoord);\n\n    \n\n    // --- plot particles ----------------------------\n    vec4 particles = get_particles(fragCoord);\n    \n    fragColor = vec4(mix(fragColor.rgb, particles.rgb, particles.a), 1.);\n   \n    // --- draw source & target shapes -------- \n    fragColor = draw_source_shape(fragColor, fragCoord);\n    fragColor = draw_target_shape(fragColor, fragCoord);\n   \n    fragColor = gamma_correct(fragColor.rgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\n// Solver parameters ( mostly used in buffer A)\n\n// For rejection sampling.\n// Increase this if you see stragglers at the end of the simulation, i.e. points outside the target area.\nconst float max_sampling_iterations = 1000.;\n\nconst int num_substeps = 1;      // alpha (de-)blend steps per frame\nconst float total_steps = 1000.; // total number of steps t between 0 and 1\nconst float dt = 1./total_steps;  // step increment\nconst int num_subsamples = 10;\n\n// Shape parameters\n\n#define SCENE 4\n\n#if SCENE == 0\n\n// Two discs aside\nconst float circle_radius1 = .25; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1.25, .1 );\nvec2 circle_center2 = vec2(1.05, .65 );\n\n#elif SCENE == 1\n\n// Two discs colinear\nconst float circle_radius1 = .25; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1.3, .55 );\nvec2 circle_center2 = vec2(.7, .2 );\n\n#elif SCENE == 2\n\n// Annulus\nconst float circle_radius1 = .5; \nconst float circle_radius2 = .25; \nvec2 circle_center1 = vec2(1., .4 );\nvec2 circle_center2 = vec2(1., .4 );\n\n#elif SCENE == 3\n\n// Two discs overlapping\nconst float circle_radius1 = .45; \nconst float circle_radius2 = .45; \nvec2 circle_center1 = vec2(1.25, .1 );\nvec2 circle_center2 = vec2(1.05, .5 );\n\n#elif SCENE == 4\n\n// Two annuluses overlapping (annuli? annulodes? :D)\nconst float circle_radius1 = .35; \nconst float circle_radius2 = .35; \nvec2 circle_center1 = vec2(1.275, .05 );\nvec2 circle_center2 = vec2(1.00, .5 );\n\n#else\n\n#endif\n   \nconst float radius = .50;              // disc( (c,c), r ) to square [0,2r]Â²\nvec2 box_center = vec2(-.75, -.45 );\n\n// Misc parameters\n\nconst int num_particles = 10;\n\n// Gamma / sRGB\n\nconst float GAMMA = 2.2;\n\nvec4 gamma_correct( vec3 color )\n{\n    return vec4(pow(clamp(color, 0., 1.), vec3(1./GAMMA)), 1.);\n}\n\n// Noise functions\n\nuint hash(uint x, uint y)\n{\n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    return x;\n}\n\nfloat hash(vec2 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u;\n    uint y = floatBitsToUint(uv.y);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    uint z = ((x>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    return 2. * uintBitsToFloat(z) - 1.;\n}\n\nvec2 hash2(vec2 uv)\n{\n    float x = hash(uv);\n    float y = hash(uv + vec2(x, 0.));\n    return vec2(x,y);\n}\n\n// SDF functions\n\nfloat circle_sdf(vec2 p, vec2 circle_center, float circle_radius) { return length(p - circle_center) - circle_radius; }\n\nfloat square_sdf(vec2 p, vec2 square_center, float box_radius)\n{ \n    vec2 f = abs(p-square_center) - box_radius;\n    return (f.x >= 0. && f.y >= 0.) ? length(f) : max(f.x, f.y);\n}\n\n// Pixel and UV helper functions\nvec2 pixel_to_uv(vec2 fragCoord, vec2 iResolution) { return (2. * fragCoord.xy - iResolution.xy) / iResolution.y; }\nvec2 uv_to_pixel(vec2 uv, vec2 iResolution) { return 0.5 * (uv.xy * iResolution.y + iResolution.xy); }\nvec2 uncentered_to_centered_uv(vec2 uncentered_uv, vec2 iResolution) { return 2.*(uncentered_uv-.5) * vec2(iResolution.x / iResolution.y, 1.); }\nvec2 centered_to_uncentered_uv(vec2 centered_uv, vec2 iResolution) { return .5*(centered_uv / vec2(iResolution.x / iResolution.y, 1.)+1.); }\n\n// Distribution functions\n\n// float source_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n// float target_distribution_pdf(vec2 x) { return 1.; } // Unused for now\n\nvec2 sample_source_distribution(vec2 hash)\n{   \n    return (2.*radius * hash) + (box_center-radius);\n}\n\nvec2 sample_target_distribution(vec2 hash)\n{\n#if SCENE == 2\n    float angle = 2.* PI * hash.y;\n    float radius = sqrt(hash.x*(circle_radius1*circle_radius1-circle_radius2*circle_radius2)+circle_radius2*circle_radius2);\n    return circle_center1 + radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));   \n    \n#elif SCENE == 4\n\n    int circle_idx = int(hash.x > .5);\n    vec2 circle_center = circle_idx == 0 ? circle_center1 : circle_center2;\n    float circle_radius = circle_idx == 0 ? circle_radius1 : circle_radius2;\n    \n    float R1 = circle_radius;\n    float R2 = circle_radius * .5;\n    \n    float rnd = 2. * hash.x - float(circle_idx == 1); \n    float R = sqrt(rnd*(R1*R1 - R2*R2) + R2*R2);\n    \n    float angle = 2.* PI * hash.y;\n    return circle_center + R * vec2(cos(angle), sin(angle));\n    \n#else\n    int circle_idx = int(hash.x > .5);\n    vec2 circle_center = circle_idx == 0 ? circle_center1 : circle_center2;\n    float circle_radius = circle_idx == 0 ? circle_radius1 : circle_radius2;\n    float angle = 2.* PI * hash.y;\n    return circle_center + circle_radius * sqrt(hash.x) * vec2(cos(angle), sin(angle));\n#endif\n}\n\nbool is_inside_source_distribution(vec2 position)\n{\n    return square_sdf(position, box_center, radius) < 0.;\n}\n\nbool is_inside_target_distribution(vec2 position)\n{\n#if SCENE == 2 \n    return \n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        &&\n        circle_sdf(position, circle_center2, circle_radius2) > 0.\n        ;\n    \n#elif SCENE == 4        \n       return \n       (\n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        &&\n        circle_sdf(position, circle_center1, circle_radius1*.5) > 0.\n       )\n       ||\n       (\n        circle_sdf(position, circle_center2, circle_radius2) < 0.\n        &&\n        circle_sdf(position, circle_center2, circle_radius2*.5) > 0.\n       )\n        ; \n#else\n      return \n        circle_sdf(position, circle_center1, circle_radius1) < 0.\n        ||\n        circle_sdf(position, circle_center2, circle_radius2) < 0.\n        ;  \n#endif\n}\n\nvec2 alpha_blend(vec2 source_point, vec2 target_point, float alpha)\n{\n    return mix(source_point, target_point, alpha);\n}\n\nvec2 alpha_deblend(vec2 blended_point, vec2 sample_point, float alpha)\n{\n    // Solve \n    //\n    //    blended_point = (1.-alpha) * sample_point + alpha * target_point\n    //  \n    // for 'target_point'\n    \n    return ( blended_point - (1.-alpha)*sample_point ) / alpha;\n}\n\n// DDIM\n// See appendix C of paper\n\nvec2 ddim_alpha_blend(vec2 source_point, vec2 target_point, float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    float beta_0 = sqrt(1.-alpha);\n    float beta_1 = sqrt(alpha);\n    return beta_0 * source_point + beta_1 * target_point;\n}\n\nvec2 ddim_alpha_deblend(vec2 blended_point, vec2 sample_point, float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    float beta_0 = sqrt(1.-alpha);\n    float beta_1 = sqrt(alpha);\n    return ( blended_point - beta_0*sample_point ) / beta_1;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Transport map buffer\n\n// Each pixel corresponds to a source location\n// The value of each pixel gives a target location\n\n\nvec4 get_transport_map(vec2 U) { return texelFetch( iChannel0, ivec2(U), 0 ); }\n\nvec4 init_transport_map(vec2 fragCoord)\n{\n    vec2 box_uv = fragCoord.xy/iResolution.xy;\n    return vec4(sample_source_distribution(box_uv), 0., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame==0) \n    {\n        fragColor = init_transport_map(fragCoord);\n    }\n    if(iFrame > 0)\n    {\n        vec4 transport_map = get_transport_map(fragCoord); // previous state\n        fragColor = transport_map;\n        \n        // This gives better results than t = (float(iFrame * num_substeps)/total_steps);\n        // Because of rejection sampling, the pixels may be slightly out of sync in terms of iterations,\n        // We should let the t-value reflect that, so that t = num_steps / total_steps;\n        float num_steps = transport_map.z;\n        float t = num_steps / total_steps;\n        \n        if ( t >= 1. ) // end of iterations\n            return;                            \n        \n        vec2 current_point = fragColor.xy;                          // P: previous pivot\n        vec2 next_point = current_point;\n        vec2 Hash;\n                                                 // point in the target shape ( disc )\n        \n        \n        for(int substep = 0; substep < num_substeps; substep++)\n        {\n            vec2 source_point = vec2(0);                                          // point in the source shape ( square )\n            vec2 target_point = vec2(0); \n            float weight = 0.;\n            vec2 candidate_target_point;\n            vec2 candidate_source_point;\n            \n            // ------- deblending phase --------\n            \n            // rejection sampling\n            if ( t < .5 ) // --- if first half of iterations:\n            {\n                for( int k = 0; k < num_subsamples; k++)\n                {\n                    bool accepted = false;\n                    \n                    for( float i = 0.; i < max_sampling_iterations && !accepted; i++)    \n                    {  \n                        Hash = hash2( float(k+1)*current_point + vec2(t -i/1.3) + fragCoord.xy/iResolution.xy );\n                        candidate_target_point = sample_target_distribution(Hash);              \n                        candidate_source_point = ddim_alpha_deblend(current_point, candidate_target_point, 1.-t);\n                        accepted = is_inside_source_distribution(candidate_source_point);// reject up to A in square\n                    }\n                    \n\n                    if(accepted)\n                    {\n                        weight += 1.;\n                        source_point += candidate_source_point;\n                        target_point += candidate_target_point;\n                    }\n                    \n                }\n            }\n            else // --- if second half of iterations: \n            {\n                for( int k = 0; k < num_subsamples; k++)\n                {\n                    bool accepted = false;\n                    for( float i = 0.; i < max_sampling_iterations && !accepted; i++)    \n                    {  \n                        Hash = hash2( float(k+1)*current_point + vec2(t -i/1.3) + fragCoord.xy/iResolution.xy );\n                        candidate_source_point = sample_source_distribution(Hash);\n                        candidate_target_point = ddim_alpha_deblend(current_point, candidate_source_point, t);\n                        accepted = is_inside_target_distribution(candidate_target_point); // reject up to B is disc\n                    }\n                    \n                    if(accepted)\n                    {\n                        weight += 1.;\n                        source_point += candidate_source_point;\n                        target_point += candidate_target_point;\n                    }\n                }\n            }\n\n            // ------- alpha blending phase --------\n            if (weight > 0.)\n            {\n                source_point /= weight;\n                target_point /= weight;\n                \n                num_steps++;\n                t += dt;\n                t = clamp(t, 0., 1.);\n                float alpha = t;  \n                next_point = ddim_alpha_blend(source_point, target_point, alpha);\n            }\n            \n            current_point = next_point;\n        }\n        fragColor.xy = current_point;\n        fragColor.z = num_steps;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Trace-lines buffer\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_trace(vec2 U) { return  texelFetch( iChannel1, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\n    vec4 trace = get_trace(fragCoord);\n    \n    float t = get_transport_map(fragCoord).z / total_steps;\n    \n    if(iFrame == 0)\n        fragColor = vec4(0,0,0,1);\n    else\n        fragColor = trace;\n         \n    if(t >= 1.) return; // Stop tracing when the schedule is complete\n         \n    vec2 Id = vec2(0);\n    float min_dist_squared = 1e9;\n\n    // Find nearest particle\n    int N = num_particles;\n    for( int i = 0; i < N*N; i++ )\n    {\n        vec2 pixel_uv = ( ( .5 + vec2(i%N, i/N) ) / float(N) );\n        vec2 particle_position_uv = get_transport_map( pixel_uv * iResolution.xy ).xy;\n        vec2 P = uv_to_pixel(particle_position_uv, iResolution.xy) - fragCoord;  // offset to current pixel\n\n        float dist_squared = dot(P,P);\n        if(dist_squared < min_dist_squared)\n        {\n            min_dist_squared = dist_squared;\n            Id = pixel_uv;\n        }\n    }\n    \n    float len = sqrt(min_dist_squared);\n    vec3 dot_color =  vec3(Id, 1);\n   \n    const float trace_strength = 0.01;\n    fragColor.rgb = mix(fragColor.rgb, dot_color, trace_strength * smoothstep( 2.5, 2., len ));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Draw particles buffer\n// Visualizes the resulting transport map\n\nvec4 get_transport_map(vec2 U) { return  texelFetch( iChannel0, ivec2(U), 0 ); }\nvec4 get_particles(vec2 U) { return  texelFetch( iChannel2, ivec2(U), 0 ); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = vec4(0);\n                                 \n    vec2 Id = vec2(0);\n    float min_dist_squared = 1e12;\n    \n    float t = get_transport_map(fragCoord).z / total_steps;\n\n    vec2 pixel_uv_offset = vec2(0);\n    \n    int N = num_particles; // Should be same as buffer B to have trails match particles\n\n    // When we reach the end we store the previous state and try to fill out the target mapping\n    if(t >= 1.)\n    {\n        pixel_uv_offset = .499*(2.*hash2(fragCoord.xy + iTime)-1.);\n        N = 5; // Use fewer when filling over time\n        \n        vec4 particles = get_particles(fragCoord);\n        fragColor = particles;\n    }\n    \n    // Find nearest particle\n    for( int i = 0; i < N*N; i++ )\n    {\n        vec2 pixel_uv = (( .5 + vec2(i%N, i/N) + pixel_uv_offset )/float(N));\n        vec4 transport_map_particle = get_transport_map( pixel_uv * iResolution.xy );\n        float particle_t = transport_map_particle.z / total_steps;\n        vec2 particle_position_uv = transport_map_particle.xy;\n        vec2 P = uv_to_pixel(particle_position_uv, iResolution.xy) - fragCoord;  // offset to current pixel\n\n        float dist_squared = dot(P, P);\n        \n        // Keep if nearest so far.\n        // Also check whether we are drawing particles in progress (t < 1.),\n        // and and whether the particle we intend to draw has reached its final destination (particle_t >= 1.)\n        // This is to prevent stragglers from being drawn (i.e. particles that have not reached t == 1. yet)\n        if(dist_squared < min_dist_squared && (t < .998 || particle_t >= 1.))\n        {\n            min_dist_squared = dist_squared;\n            Id = pixel_uv;\n        }\n    }\n\n    if(min_dist_squared < 1e11) // Check whether a valid nearest particle was found.\n    {\n        float len = sqrt(min_dist_squared);\n        vec2 rowcol = (floor(8.*Id));\n        float checker = mod(rowcol.x + rowcol.y, 2.);\n        vec3(.678, .747, .902);\n        vec4 dot_color =  vec4(vec3(Id,0.) * (.75*checker+.25), 1);\n\n        float alpha = smoothstep( 2.5, 2., len );\n\n        //fragColor = mix( fragColor, dot_color, alpha); // draw dots \n        \n        \n        if(fragColor.a < 1.)\n        {\n            fragColor.rgb += alpha * dot_color.rgb;\n            fragColor.a += alpha;\n        }\n        if(fragColor.a >= 1.)\n        {\n            alpha *= mix(0.25, 0.01, smoothstep(30., 200., iTime));\n            fragColor.rgb += alpha * dot_color.rgb;\n            fragColor.a += alpha;\n            fragColor /= fragColor.a;\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}