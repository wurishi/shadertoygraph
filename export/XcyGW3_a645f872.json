{"ver":"0.1","info":{"id":"XcyGW3","date":"1713431373","viewed":83,"name":"de Laval nozzle","username":"ukeshet","description":"Compressible 2D flow simulation of converging vs. converging-diverging (de Laval) nozzles.\nDemo for ICP+Astrophysics-1 courses.\nClick a field name for view.\nIf the code crashes on your setup, lower the CFL time-stepping parameter in Common (line 6).","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","physics","finitedifferences","hydro","nozzle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compressible flow simulation of the de Laval nozzle.\n// Two identical-engines shown; de Laval achieves a supersonic outflow within the nozzle.\n// Buffer A sets up initial and boundary conditions. Buffer B is a simple 2D fluid solver.\n// Demo for ICP + Astrophysics 1 courses, by ukeshet.\n\n// If the code crashes on your setup, lower the CFL time-stepping parameter in Common (line 6).\n// Otherwise, raise CFL for a faster and more interesting (best before crash!) visualization.\n\n// Visualization cycles through field views unless you click on a field name or elsewhere.\n\n#define Bx .8\n#define y1 .64\n#define y2 .57\n#define y3 .50\n#define y4 .43\n\nvec2 uv, k;\n\nvec4 K(int c) {\n    vec2 p=(uv-k)*22.; k.x+=.02; \n    if (p.x<.0||p.x>1.||p.y<0.||p.y>1.) return vec4(0.);\n    return textureGrad(iChannel1,p/16.+fract(vec2(c+64,15-(c+64)/16)/16.),dFdx(p/16.),dFdy(p/16.));\n}\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n    uv = Coo.xy/iResolution.xy;\n    float dx = 1.0/iResolution.x, dy = 1.0/iResolution.y;\n    vec4 A=texture(iChannel0, uv);\n    Col = vec4(log(A.z)*.4,log(A.w)*.1,.5*length(A.xy)/pow(G*A.w/A.z,0.5),1.);\n    int V; vec2 M;\n    if ((uv.x>Bx) && (uv.y>y4) && (uv.y<y1)) Col*=0.; // Text box and text:\n    k=vec2(.81,.46); Col += vec4((K(4)+K(37)+K(46)+K(51)+K(41)+K(52)+K(57)).x,0.,0.,1.);\n    k=vec2(.81,.56); Col += vec4(0.,(K(16)+K(50)+K(37)+K(51)+K(51)+K(53)+K(50)+K(37)).x,0.,1.);\n    k=vec2(.81,.51); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)).x,1.);\n    if(iMouse.z<=0.) V=0; else { M=iMouse.xy/iResolution.xy; \n        if (M.x>Bx && M.y>y2 && M.y<y1) V=1; \n        else if (M.x>Bx && M.y>y3 && M.y<y2) V=2; \n        else if (M.x>Bx && M.y>y4 && M.y<y3) V=3;      \n        else V=4;}\n    if (V==1 || (V==0 && (mod(iTime,30.)>18.) && (mod(iTime,30.)<22.))) {  // show only P = green\n        Col.xz*=0.; if ((uv.x>Bx) && (uv.y>y4) && (uv.y<y2)) Col*=0.; } \n    if (V==2 || (V==0 && (mod(iTime,30.)>10.) && (mod(iTime,30.)<14.))) {  // show only Mach = blue\n        Col.xy*=0.; if ((uv.x>Bx) && (((uv.y>y4) && (uv.y<y3)) || ((uv.y>y2) && (uv.y<y1)))) Col*=0.; \n        if ((uv.y > .51) && (uv.y<.56)) Col=vec4(0.,0.,.5,1.);             // show M=1 reference\n        k=vec2(.63,.57); Col += vec4(0.,0.,(K(13)+K(33)+K(35)+K(40)+K(241)).x,1.); }\n    if (V==3 || (V==0 && mod(iTime,30.)>26.)) {                            // Show only rho = red\n        Col.yz*=0.; if ((uv.x>Bx) && (uv.y>y3) && (uv.y<y1)) Col*=0.; }\n    if ((uv.x > xLN) && ((abs(dyBN1(uv))<dy) || (abs(dyTN1(uv))<dy))) Col=vec4(1.); // mark nozzle 1\n    if ((uv.x > xLN) && ((abs(dyBN2(uv))<dy) || (abs(dyTN2(uv))<dy))) Col=vec4(1.); // mark nozzle 2\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: Initial and boundary conditions.\n// Presently sets up the double-nozzle problem. \n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1.0/iResolution.x;\n    float dy = 1.0/iResolution.y;\n\n    Col = texture(iChannel0, uv); // Fetch pixel and neighbors\n    vec4 AR = texture(iChannel0, uv+vec2(dx,.0));\n    vec4 AL = texture(iChannel0, uv-vec2(dx,.0));\n    vec4 AU = texture(iChannel0, uv+vec2(.0,dy));\n    vec4 AD = texture(iChannel0, uv-vec2(.0,dy));  \n\n    // Boundary conditions\n    if (uv.x<1.1*dx)                       // Left boundary\n        Col = vec4(-abs(AR.x),AR.yzw);     // outflow\n    if (uv.x>1.0-1.1*dx)                   // Right boundary \n        Col = vec4(+abs(AL.x),AL.yzw);     // outflow\n    if (uv.y<1.1*dy)                       // Bottom boundary \n        Col = vec4(AU.x,-abs(AU.y),AU.zw); // outflow\n    if (uv.y>1.0-1.1*dy)                   // Top boundary \n        Col = vec4(AD.x,+abs(AD.y),AD.zw); // outflow\n    if (uv.x > xLN) { // Nozzle region\n        float dyB=dyBN1(uv), dyT=dyTN1(uv);\n        if ((dyB>0.) && (dyT<0.)) {                     // inside nozzle 1\n            if (uv.x > xRN) Col = vec4(v0,0.,rho1,P1);  // inlet\n            if (dyT>-1.1*dy) Col = vec4(AD.xy-NormT1(uv)*dot(AD.xy,NormT1(uv)),AD.zw); // slip\n            if (dyB<1.1*dy)  Col = vec4(AU.xy-NormB1(uv)*dot(AU.xy,NormB1(uv)),AU.zw); // slip\n        } else {                                                      // outside nozzle 1\n            if ((dyB>0.) && (dyT<2.1*dy))  Col = vec4(0.,0.,rho0,P0); // ambient\n            if ((dyT<0.) && (dyB>-2.1*dy)) Col = vec4(0.,0.,rho0,P0); // ambient\n        }\n        float dyB2=dyBN2(uv), dyT2=dyTN2(uv);\n        if ((dyB2>0.) && (dyT2<0.)) {                   // inside nozzle 2\n            if (uv.x > xRN) Col = vec4(v0,0.,rho1,P1);  // inlet\n            if (dyT2>-1.1*dy) Col = vec4(AD.xy-NormT2(uv)*dot(AD.xy,NormT2(uv)),AD.zw); // slip\n            if (dyB2<1.1*dy)  Col = vec4(AU.xy-NormB2(uv)*dot(AU.xy,NormB2(uv)),AU.zw); // slip\n        } else {                                                        // outside nozzle 2\n            if ((dyB2>0.) && (dyT2<1.1*dy))  Col = vec4(0.,0.,rho0,P0); // ambient\n            if ((dyT2<0.) && (dyB2>-1.1*dy)) Col = vec4(0.,0.,rho0,P0); // ambient\n        }\n    }\n\n    if (iFrame<1) {  // Initial conditions\n        vec2 vi = vec2(0,0.);\n        float rho=rho0;\n        float P=P0;\n        if ((uv.x>xLN) && (dyBN1(uv)>0.) && (dyTN1(uv)<0.)) { // init nozzle 1\n            P = P0+(P1-P0)*smoothstep(xLN,xRN,uv.x); \n            vi.x = v0*smoothstep(xLN,xRN,uv.x);\n            if (uv.x > xRN) {P=P1; rho=rho1; vi.x=v0;}        // inlet\n        }\n        if ((uv.x>xLN) && (dyBN2(uv)>0.) && (dyTN2(uv)<0.)) { // init nozzle 2\n            P = P0+(P1-P0)*smoothstep(xLN,xRN,uv.x);\n            vi.x = v0*smoothstep(xLN,xRN,uv.x);\n            if (uv.x > xRN) {P=P1; rho=rho1; vi.x=v0;}        // inlet\n        }\n        Col = vec4(vi,rho0,P);\n    }    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: 2D ideal fluid solver.\n// Simplest version: nearest neighbors only, operator splitting, donor-cell advection.\n\nvoid mainImage(out vec4 Col, in vec2 Coo) {\n\n    float CV = 1./(G-1.); \n    float minV = .001;\n\n    // Grid\n    vec2 uv = Coo.xy/iResolution.xy;\n    float dx = 1.0/iResolution.x;\n    float dy = 1.0/iResolution.y;\n    float dt = CFL*min(dx,dy); // lower CFL (defined in Common line 6) if crash.\n\n    // Fetch pixel and neighbours\n    vec4 A = texture(iChannel0, uv);\n    vec4 AR = texture(iChannel0, uv+vec2(dx,.0));\n    vec4 AL = texture(iChannel0, uv-vec2(dx,.0));\n    vec4 AU = texture(iChannel0, uv+vec2(.0,dy));\n    vec4 AD = texture(iChannel0, uv-vec2(.0,dy));  \n    \n    // Edge veclocities\n    float uR = .5*(AR.x+A.x), uL = .5*(AL.x+A.x);\n    float vU = .5*(AU.y+A.y), vD = .5*(AD.y+A.y);\n\n    // Mass flux\n    float frhoR = uR*(step(0.,uR)*A.z + step(uR,0.)*AR.z);\n    float frhoL = uL*(step(0.,uL)*AL.z + step(uL,0.)*A.z);\n    float frhoU = vU*(step(0.,vU)*A.z + step(vU,0.)*AU.z);\n    float frhoD = vD*(step(0.,vD)*AD.z + step(vD,0.)*A.z);\n    float rho2 = A.z - dt*( (frhoR-frhoL)/dx + (frhoU-frhoD)/dy );\n    rho2 = max(minV,rho2);\n\n    // x-momentum flux\n    float fpxR = uR*(step(0.,uR)*A.z*A.x + step(uR,0.)*AR.z*AR.x);\n    float fpxL = uL*(step(0.,uL)*AL.z*AL.x + step(uL,0.)*A.z*A.x);\n    float fpxU = vU*(step(0.,vU)*A.z*A.x + step(vU,0.)*AU.z*AU.x);\n    float fpxD = vD*(step(0.,vD)*AD.z*AD.x + step(vD,0.)*A.z*A.x);\n    float vx2 = ( A.z*A.x - dt*( (fpxR-fpxL)/dx + (fpxU-fpxD)/dy + (AR.w-AL.w)/dx/2. ) )/rho2;\n    \n    // y-momentum flux\n    float fpyR = uR*(step(0.,uR)*A.z*A.y + step(uR,0.)*AR.z*AR.y);\n    float fpyL = uL*(step(0.,uL)*AL.z*AL.y + step(uL,0.)*A.z*A.y);\n    float fpyU = vU*(step(0.,vU)*A.z*A.y + step(vU,0.)*AU.z*AU.y);\n    float fpyD = vD*(step(0.,vD)*AD.z*AD.y + step(vD,0.)*A.z*A.y);\n    float vy2 = ( A.z*A.y - dt*( (fpyR-fpyL)/dx + (fpyU-fpyD)/dy + (AU.w-AD.w)/dy/2. ) )/rho2;\n\n    // Total energy*density\n    float erho = CV*A.w+.5*A.z*(A.x*A.x+A.y*A.y);\n    float erhoR = CV*AR.w+.5*AR.z*(AR.x*AR.x+AR.y*AR.y);\n    float erhoL = CV*AL.w+.5*AL.z*(AL.x*AL.x+AL.y*AL.y);\n    float erhoU = CV*AU.w+.5*AU.z*(AU.x*AU.x+AU.y*AU.y);\n    float erhoD = CV*AD.w+.5*AD.z*(AD.x*AD.x+AD.y*AD.y);\n\n    // Energy flux\n    float feR = uR*(step(0.,uR)*erho + step(uR,0.)*erhoR);\n    float feL = uL*(step(0.,uL)*erhoL + step(uL,0.)*erho);\n    float feU = vU*(step(0.,vU)*erho + step(vU,0.)*erhoU);\n    float feD = vD*(step(0.,vD)*erhoD + step(vD,0.)*erho);\n    float erho2 = erho - dt*( (feR-feL)/dx + (feU-feD)/dy + \n                              (AR.w*AR.x-AL.w*AL.x)/dx/2. + (AU.w*AU.y-AD.w*AD.y)/dy/2. );\n\n    // Reconstruct pressure\n    float P2 = (erho2 - .5*rho2*(vx2*vx2+vy2*vy2))/CV;\n    P2 = max(minV,P2);\n\n    Col = vec4(vx2,vy2,rho2,P2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Common: Geometry and parameter setup.\n\n#define pi 3.1415926535\n\n// Lower the time stepping (CFL) parameter if the simulation crashes.\n#define CFL .015\n\n\n// Hydro params:\n#define rho0 1.0\n#define P0 1.0\n#define P1 100.\n#define rho1 3.\n#define v0 0.\n#define G 1.4 // adiabatic index\n\n// Nozzle x ranges:\n#define xLN 0.7\n#define xRN 0.97\n\n// Nozzle 1 profile:\n#define yBN 0.12\n#define yTN 0.23\n#define dyN (yTN-yBN)*.24\n\n// Nozzle 2 profile:\n#define yBN2 0.77\n#define yTN2 0.85\n#define dyN2 (yTN2-yBN2)*.2\n\n\nfloat dyBN1(vec2 xy) { // Oriented distance from bottom edge of nozzle 1\n    return xy.y-(yBN-dyN*cos((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN)));\n}\n        \nfloat dyTN1(vec2 xy) { // Oriented distance from top edge of nozzle 1\n    return xy.y-(yTN+dyN*cos((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN)));\n}\n\nfloat dyBN2(vec2 xy) { // Oriented distance from bottom edge of nozzle 2\n    return xy.y-(yBN2-dyN2*cos((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN)));\n}\n        \nfloat dyTN2(vec2 xy) { // Oriented distance from top edge of nozzle 2\n    return xy.y-(yTN2+dyN2*cos((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN)));\n}\n\nvec2 NormB1(vec2 xy) { // Normal to bottom edge of nozzle 1\n    float a=atan(2.*pi*dyN*sin((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormT1(vec2 xy) { // Normal to top edge of nozzle 1\n    float a=atan(-2.*pi*dyN*sin((xy.x-xLN-.1*pi)*2.*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormB2(vec2 xy) { // Normal to bottom edge of nozzle 2\n    float a=atan(.3*pi*dyN2*sin((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}\n\nvec2 NormT2(vec2 xy) { // Normal to top edge of nozzle 2\n    float a=atan(-.3*pi*dyN2*sin((xy.x-xLN+1.1*pi)*.3*pi/(1.-xLN))/(1.-xLN));\n    return vec2(-sin(a),cos(a));\n}","name":"Common","description":"","type":"common"}]}