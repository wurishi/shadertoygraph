{"ver":"0.1","info":{"id":"dljcDd","date":"1692499643","viewed":74,"name":"6. Raytracer (texturing)","username":"Envy24","description":"Mouse.x - zoom in/out, Mouse.y - rotate around x axis.\nAdded textures support.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","phong","uv","light","shadows","textures","model","hard","reflectance"],"hasliked":0,"parentid":"dtSyWd","parentname":"5. Raytracer (reflections)"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Turn AA off if you have low fps\n#define AA ( 1. ) // 0. - off, 1. - on 3x3 box filter, 2 - on 4x4 box filter, ...\n\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec3 smooth_checker(vec2 uv)\n{\n    const float tau = 6.2831853071795862;    \n    uv = mod(uv * 0.5, 2.0);\n      \n    float d = sin(tau/2.+uv.x*tau) * cos(-tau/4.+uv.y*tau),\n          //fw = 0.8*fwidth(d);\n          fw = 4./iResolution.y;\n    return vec3(mix(vec3(.7), vec3(1.), smoothstep(-fw, fw, d)));\n}\nvec3 get_background(RAY ray) { return texture(iChannel0, ray.direction).xyz; }\n\n#define NUM_OF_OBJECTS ( 3 )\nmat4 fwd_model[NUM_OF_OBJECTS]; // per object forward model transformations.\nmat4 bwd_model[NUM_OF_OBJECTS]; // per object backward model transformations.\nmat4 fwd_view = mat4(1);        // forward transformation for all objects in scene (should be applyed many times).\nmat4 bwd_view = mat4(1);        // or backward transformation for camera (should be applyed once).\nMATERIAL materials[NUM_OF_OBJECTS];\n#define NUM_OF_LIGHTS ( 3 )\nLIGHT lights[NUM_OF_LIGHTS];\n\nvoid init_scene()\n{   \n    //\n    // Model transformations.\n    //\n    for (int i = 0; i < NUM_OF_OBJECTS; ++i)\n        fwd_model[i] = mat4(1);\n\n    fwd_model[0] = fwd_srt_transform(vec3(5), vec3(0), vec3(0,-1,0));\n    fwd_model[1] = fwd_srt_transform(vec3(1), vec3(0), vec3(0,0,0));\n    fwd_model[2] = fwd_srt_transform(vec3(.5), vec3(0), vec3(0,0.8,2));  \n   \n    for (int i = 0; i < NUM_OF_OBJECTS; ++i)\n        bwd_model[i] = inverse(fwd_model[i]);\n     \n    //\n    // View transformation.\n    //\n    vec2 MP = iMouse.xy == vec2(0) ? vec2(0) : (iMouse.xy/iResolution.xy)*2.-1.;\n    float s = (1.+sin(iTime))*.5, T = iTime;\n    bwd_view = bwd_srt_transform(vec3(2.0 + MP.x*1.9), vec3(.5*3.1415*MP.y,T*.1,0), vec3(0,0,-2.0));\n    \n    //\n    // Lights.\n    //\n    lights[0].pos = (rotY(0.*TO_RAD) * vec4(0,10,10,1)).xyz;\n    lights[0].diffuse_Id = vec3(1,0,0);\n    lights[0].ambient_Ia = 0.1 * lights[0].diffuse_Id;\n    lights[0].specular_Is = lights[0].diffuse_Id;\n\n    lights[1].pos = (rotY(120.*TO_RAD) * vec4(0,10,10,1)).xyz;\n    lights[1].diffuse_Id = vec3(0,1,0);\n    lights[1].ambient_Ia = 0.1 * lights[1].diffuse_Id;\n    lights[1].specular_Is = lights[1].diffuse_Id;\n    \n    lights[2].pos = (rotY(240.*TO_RAD) * vec4(0,10,10,1)).xyz;\n    lights[2].diffuse_Id = vec3(0,0,1);\n    lights[2].ambient_Ia = 0.1 * lights[2].diffuse_Id;\n    lights[2].specular_Is = lights[2].diffuse_Id;\n}\n\n// Define this tables.\nHIT intersection_table(RAY ray, int object_idx)\n{\n    // Intersect with simplified primitives.\n    switch (object_idx)\n    {\n    case 0: return ray_infinite_plane_XZ_int(ray);\n    //case 0: return ray_plane_XZ_int(ray);\n    case 1: return ray_unit_sphere_int(ray);\n    case 2: return ray_unit_sphere_int(ray);\n    }\n}\nvoid construct_material(HIT hit)\n{\n    vec3 texColor;\n    switch (hit.hitted_idx)\n    {\n    case 0:\n        texColor = texture(iChannel1, fract(hit.uv*2.)).xyz;\n        materials[0].diffuse_Kd = 1. * texColor;\n        materials[0].ambient_Ka = 0.1 * materials[0].diffuse_Kd;\n        materials[0].specular_Ks = 0.8 * materials[0].diffuse_Kd;\n        materials[0].Krefl = 1.8 * materials[0].specular_Ks;\n        materials[0].spec_exp = 64.;\n        break;\n    case 1:\n        materials[1].diffuse_Kd = 1. * smooth_checker(8. * hit.uv);\n        materials[1].ambient_Ka = 0.1 * materials[1].diffuse_Kd;\n        materials[1].specular_Ks = 0.2 * materials[1].diffuse_Kd;\n        materials[1].Krefl = 1.8 * materials[1].specular_Ks;\n        materials[1].spec_exp = 64.;\n        break;\n     case 2:\n        // Planar mapping\n        materials[2].diffuse_Kd = 1. * smooth_checker(8. * hit.hit_point.xz);\n        materials[2].ambient_Ka = 0.1 * materials[2].diffuse_Kd;\n        materials[2].specular_Ks = 0.6 * materials[2].diffuse_Kd;\n        materials[2].Krefl = 0.2 * materials[2].specular_Ks;\n        materials[2].spec_exp = 64.;\n        break;\n    }\n}\n\nHIT find_closest_intersection(RAY ray)\n{\n    HIT c_hit; c_hit.hit_dist = 9e5;\n    int hit_something = 0; // Set only once, when firts hit occurs.\n    int hitted_idx = 0;\n    float min_sq_d = 9e5;\n    \n    for (int obj_idx = 0; obj_idx < NUM_OF_OBJECTS; ++obj_idx)\n    {                \n        // Apply inverse transform.\n        RAY t_ray = apply_transform_to_ray(ray, bwd_model[obj_idx]);\n        \n        // Intersect with simplified primitives.\n        HIT hit = intersection_table(t_ray, obj_idx);\n        \n        if (hit.hit_something == 1) // Hit i-th object?\n        {\n            // Recover hit point in world coordinates.\n            hit.hit_point = apply_transformation_to_point(hit.hit_point, fwd_model[obj_idx]);\n            \n            // Calculate squared distance in world coordinates.\n            vec3 CAMtoHP = hit.hit_point - ray.position;\n            float sq_d = dot(CAMtoHP, CAMtoHP);\n            \n            if (min_sq_d > sq_d) // Find closer hit-point?\n            {\n                // Update distance.\n                min_sq_d = sq_d;\n                \n                // Save hit data.\n                c_hit = hit;\n                c_hit.hitted_idx = obj_idx;\n            }\n        }\n        \n        // If we find any hit, then this value will be set to 1, and not changed before the function exits.\n        hit_something = max(hit.hit_something, hit_something);\n    }\n\n    // Save global hit flag.\n    c_hit.hit_something = hit_something;\n\n    // Recover normal (cheap, so i don't use branch here).\n    c_hit.hp_normal = apply_transformation_to_normal(c_hit.hp_normal, bwd_model[c_hit.hitted_idx]);\n\n    return c_hit;\n}\nint find_any_intersection_for_shadows(RAY ray, int hitted_idx, float sq_dist_to_light_source)\n{\n    for (int obj_idx = 0; obj_idx < NUM_OF_OBJECTS; ++obj_idx)\n    {        \n        // Skip hitted object.\n        if (obj_idx == hitted_idx) { continue; }\n\n        // Apply inverse transform.\n        RAY t_ray = apply_transform_to_ray(ray, bwd_model[obj_idx]);\n        \n        // Intersect with simplified primitives.\n        HIT hit = intersection_table(t_ray, obj_idx);\n\n        if (hit.hit_something == 1) // Hit i-th object?\n        {\n            // Recover hit point in world coordinates.\n            hit.hit_point = apply_transformation_to_point(hit.hit_point, fwd_model[obj_idx]);\n\n            // Calculate squared distance between camera and object.\n            vec3 diff = hit.hit_point - ray.position;\n\n            // Object is between camera and hit_point?\n            if (dot(diff, diff) < sq_dist_to_light_source) { return 1; }\n        }\n    }\n\n    return 0;\n}\n\nvec3 phong(RAY ray, HIT hit, int light_idx, int is_in_shadow)\n{\n    // Construct material.    \n    construct_material(hit);\n\n    // Fetch metarial data.\n    int idx = hit.hitted_idx;\n    vec3 Ka = materials[idx].ambient_Ka; \n    vec3 Kd = materials[idx].diffuse_Kd;\n    vec3 Ks = materials[idx].specular_Ks;\n    float se = materials[idx].spec_exp;\n    \n    // Calculate directions.\n    vec3 hp_to_l_dir = normalize(lights[light_idx].pos - hit.hit_point); \n    vec3 reflect_dir = reflect(hp_to_l_dir, hit.hp_normal);\n\n    /* Phong reflectance model. */\n    // Calculate diffuse and specular components, and their sum for shadows.\n    float diffuse = max(dot(hit.hp_normal, hp_to_l_dir), 0.), \n          specular = pow(max(dot(ray.direction, reflect_dir), 0.0), se);\n\n    vec3 ambient_color = Ka * lights[light_idx].ambient_Ia;\n    vec3 total_color =\n        ambient_color +\n        Kd * lights[light_idx].diffuse_Id * diffuse +\n        Ks * lights[light_idx].specular_Is * specular;\n    vec3 result = total_color;\n    /* !Phong reflectance model. */\n        \n    return \n        is_in_shadow == 1 ?\n            ambient_color :\n            total_color;\n}\n\nvec3 process_lights(RAY ray, HIT hit)\n{\n    vec3 accumulated_color = vec3(0);\n    \n    for (int light_idx = 0; light_idx < NUM_OF_LIGHTS; ++light_idx)\n    {           \n        // Cast shadow ray.\n        RAY shadow_ray;\n        shadow_ray.direction = lights[light_idx].pos - hit.hit_point;\n        shadow_ray.position = hit.hit_point;\n        float sq_len = dot(shadow_ray.direction, shadow_ray.direction);\n        shadow_ray.direction = normalize(shadow_ray.direction);\n        \n        // Trace scene.\n        int is_in_shadow = find_any_intersection_for_shadows(shadow_ray, hit.hitted_idx, sq_len);\n\n        // Calculate color.\n        accumulated_color += phong(ray, hit, light_idx, is_in_shadow);      \n    }\n    \n    return accumulated_color;\n}\n\nvec3 Reinhard_tone_mapping(vec3 HDR)\n{\n    return HDR / (HDR + vec3(1));\n}\nvec3 exposure_tone_mapping(vec3 HDR, float exposure)\n{\n    return vec3(1.0) - exp(-HDR * exposure);\n}\nvec3 ACES(const vec3 x) \n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51; const float b = 0.03; const float c = 2.43;\n    const float d = 0.59; const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 scene(vec2 SC)\n{\n    // Generate primary ray.\n    vec2 MP = iMouse.xy == vec2(0) ?\n        vec2(0) :\n        map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n        \n    RAY ray;\n        //ray = orthographic_camera(SC, vec3(0,0,0), vec3(0,0,-1), iResolution.xy);\n        ray = perspective_camera(SC, vec3(0,6,12), vec3(0,0,0), iResolution.xy);\n\n    // View transformation.\n    ray = apply_transform_to_ray(ray, bwd_view);  \n\n    vec3 total_color = vec3(0);\n    vec3 cur_Krefl = vec3(1);\n\n    const float max_num_of_refl_rays = 3.; // 1 -> long compilation time.\n    for (float r = 0.; r < max_num_of_refl_rays; r += 1.)\n    {\n        // Trace scene.\n        HIT hit = find_closest_intersection(ray);\n        \n        // Miss?\n        if (hit.hit_something == 0)\n        {\n            // Then we hit in backround.\n            total_color += get_background(ray) * cur_Krefl;\n            \n            // Background doesn't reflect, so break cycle.\n            break;\n        }\n        \n        // Get color for hit point.\n        total_color += process_lights(ray, hit) * cur_Krefl;\n        \n        // Material doesn't reflect?\n        if (materials[hit.hitted_idx].Krefl == vec3(0.)) { break; }\n        \n        // Reflected ray.\n        ray.direction = reflect(ray.direction, hit.hp_normal);\n        ray.position = hit.hit_point + ray.direction*0.01;\n        \n        // Compute product of coeffitients for next ray.\n        cur_Krefl *= materials[hit.hitted_idx].Krefl;\n    }\n     \n    //return Reinhard_tone_mapping(total_color);\n    return exposure_tone_mapping(total_color, 1.8);\n    //return ACES(total_color);\n}\n\n// Basic anti-aliasing (supersample).\nvec3 OSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = AA, inv = 1./(2.*order + 1.), blur = 1.;\n\n    for (float y = -order; y <= order; y += 1.0)\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            vec2 offset = (blur*vec2(x, y)) * inv;\n            col += scene(SC + offset);\n        }\n        \n    order = 2.*order + 1.;\n    return col / (order*order);  \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    init_scene();\n\n    //O = vec4(scene(SC),1.0);\n    O = vec4(OSSAA(SC), 1.0);\n    \n    // Camera look_at.\n    //O = mix(O, vec4(0,1,0,1), smoothstep(3., 0., length(SC - 0.5*iResolution.xy) - 0.5));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Structures.\nstruct RAY\n{\n    vec3 position;\n    vec3 direction;\n};\nstruct HIT\n{\n    int hit_something;\n    float hit_dist;\n    vec3 hit_point;\n    vec3 hp_normal;\n    vec2 uv;\n    int hitted_idx;\n};\nstruct LIGHT\n{\n    vec3 pos;\n    vec3 ambient_Ia;\n    vec3 diffuse_Id;\n    vec3 specular_Is;\n};\nstruct MATERIAL\n{\n    vec3 ambient_Ka;\n    vec3 diffuse_Kd;\n    vec3 specular_Ks;\n    float spec_exp;\n    vec3 Krefl;\n};\n// Cameras.\nRAY perspective_camera(vec2 SC, vec3 position, vec3 look_at, vec2 resolution)\n{\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = position;\n\n    vec3 f = normalize(look_at - camera);               // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n        \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = resolution.x / resolution.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n\n    return RAY(\n        camera,\n        normalize(uv.x * r + uv.y * u + f * zFocalLength));\n}\nRAY orthographic_camera(vec2 SC, vec3 pos, vec3 look_at, vec2 resolution)\n{\n    vec3 vp = pos;                 // viewport and camera position\n    \n    vec3 f = normalize(look_at - vp);                   // forward\n    vec3 r = normalize(cross(vec3(0.0, -1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(r, f));                    // up\n    \n    float aspectRatio = resolution.x / resolution.y;\n    float orthographicScale = 6.8;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n   \n    vec2 uv = SC / resolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n     \n    RAY ray;\n    return RAY(\n        vp + uv.x * r + uv.y * u,\n        f);\n}\n\n// Ray-Object intersection routines.\nHIT ray_infinite_plane_XZ_int(RAY ray)\n{\n    // Plane definition:\n    // Equation: Ax + By + Cz + D = 0\n    // Primitive constrains:\n    //   N = vec3(A, B, C) = vec3(0, 1, 0)\n    //   D = 0\n\n    HIT hit;\n    float root = -ray.position.y/ray.direction.y;\n    float backface = float(dot(vec3(0,1,0), ray.direction) > .0);\n\n    if (//backface == 1.|| // back face?    \n        root < 0.)         // behind camera?\n    { \n        hit.hit_something = 0; \n        hit.hit_dist = 9e5;\n        return hit; \n    }\n    \n    hit.hit_something = 1;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = vec3(0,backface == 1. ? -1. : 1.,0);\n    hit.uv = hit.hit_point.xz;\n    \n    return hit;\n}\nHIT ray_plane_XZ_int(RAY ray)\n{\n    // Plane definition:\n    // Equation: Ax + By + Cz + D = 0\n    // Primitive constrains:\n    //    N = vec3(A, B, C) = vec3(0, 1, 0)\n    //    D = 0, abs(x) <= 1, abs(y) <= 1\n    \n    HIT hit;\n    float root = -ray.position.y/ray.direction.y;\n    hit.hit_point = ray.position + ray.direction * root;\n    float backface = float(dot(vec3(0,1,0), ray.direction) > .0);\n\n    if (//backface == 1. ||             // back face?    \n        root < 0. ||                  // behind camera?\n        abs(hit.hit_point.x) > 1. ||  // outside plane area in x direction?\n        abs(hit.hit_point.z) > 1.)    // outside plane area in z direction?\n    { \n        hit.hit_something = 0;\n        hit.hit_dist = 9e5;\n        return hit; \n    }\n    \n    hit.hit_something = 1;\n    hit.hit_dist = root;\n    hit.hit_point = hit.hit_point;\n    hit.hp_normal = vec3(0,backface == 1. ? -1. : 1.,0);\n    hit.uv = hit.hit_point.xz;\n    \n    return hit;\n}\nHIT ray_unit_sphere_int(RAY ray) // sphere_pos always equals vec3(0), and sphere_r equals to 1.\n{\n    float half_b = dot(ray.position, ray.direction),\n          c = dot(ray.position, ray.position) - 1.,\n          discriminant = (half_b * half_b - c),\n          sqrtDiscriminant = sqrt(discriminant),\n          root = min(-half_b - sqrtDiscriminant, -half_b + sqrtDiscriminant);\n    \n    HIT hit;\n    \n    if (discriminant < 0. || // no real roots?\n        root < 0.)           // behind camera?\n    { \n        hit.hit_something = 0;\n        hit.hit_dist = 9e5;\n        return hit; \n    }\n    \n    hit.hit_something = 1;\n    hit.hit_dist = root;\n    hit.hit_point = ray.position + ray.direction * root;\n    hit.hp_normal = normalize(hit.hit_point);\n    \n    const float inv_pi = 0.31830988618;\n    const float inv_tau = 0.1591549430918953;\n    float x = hit.hit_point.x, y = hit.hit_point.y, z = hit.hit_point.z;\n    hit.uv = vec2(.5 + atan(x, z) * inv_tau,\n                  .5 + asin(y) * inv_pi);\n    \n    return hit;\n}\n\n/*\n    Matricies for column vectors and row major matricies,\n    because i prefer this variant)\n    \n    Multiplication order:\n    T2 * T1 * T0 * V;\n    \n    Representation for points and directions\n    in homogeneous coordinates:\n        Points     p = vec4(p.xyz, 1),\n        Direction  d = vec4(p.xyz, 0).\n*/\nmat4 scale(vec3 s)\n{\n    mat4 M = mat4(\n        s.x,   0,   0, 0,\n          0, s.y,   0, 0,\n          0,   0, s.z, 0,\n          0,   0,   0, 1);\n    return transpose(M);\n}\nmat4 rotX(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         1, 0,  0, 0,\n         0, c, -s, 0,\n         0, s,  c, 0,\n         0, 0,  0, 1);\n    return transpose(M);\n}\nmat4 rotY(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, 0, s, 0,\n         0, 1, 0, 0,\n        -s, 0, c, 0,\n         0, 0, 0, 1);\n    return transpose(M);\n}\nmat4 rotZ(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, -s, 0, 0,\n         s,  c, 0, 0,\n         0,  0, 1, 0,\n         0,  0, 0, 1);\n    return transpose(M);\n}\nmat4 translate(vec3 t)\n{\n    mat4 M = mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0,   1);\n    return transpose(M);\n}\nmat4 fwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return translate(t) * rotX(r.x) * rotY(r.y) * rotZ(r.z) * scale(s);\n}\nmat4 bwd_srt_transform(vec3 s, vec3 r, vec3 t) // scale, rotate, translate\n{\n    return inverse(translate(t) * rotX(r.x) * rotY(r.y) * rotZ(r.z) * scale(s));\n}\nRAY apply_transform_to_ray(RAY ray, mat4 T)\n{\n    vec4 P = vec4(ray.position + ray.direction, 1);   \n         P = T * P;\n         \n    RAY res;\n    res.position = (T * vec4(ray.position, 1.)).xyz;\n    res.direction = normalize(P.xyz - res.position);\n    return res;\n}\nvec3 apply_transformation_to_normal(vec3 normal, mat4 T)\n{\n    mat3 SR = mat3(T[0].xyz, T[1].xyz, T[2].xyz);\n    // https://paroj.github.io/gltut/Illumination/Tut09%20Normal%20Transformation.html\n    normal = normal * transpose(inverse(SR));\n    \n    return normalize(normal);\n}\nvec3 apply_transformation_to_point(vec3 p, mat4 T)\n{\n    vec4 P = vec4(p, 1.); \n    return (T * P).xyz;\n}","name":"Common","description":"","type":"common"}]}