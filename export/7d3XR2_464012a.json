{"ver":"0.1","info":{"id":"7d3XR2","date":"1633523186","viewed":370,"name":"Holographic Torus Knot","username":"Flopine","description":"Learnign new stuff :D thanks to The Art Of Code youtube channel   <3    https://youtu.be/2dzJZx0yngg\nMotivated by byt3_m3chanic shader https://www.shadertoy.com/view/NstXDM","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Based on BigWings tuts ~ https://youtu.be/2dzJZx0yngg\n\n#define PI acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define pal(t,c) (vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.5,0.63))))\n#define swi(sp) floor(sin(fract(iTime*sp)*2.*PI))+1.\n\nfloat box2d (vec2 p, vec2 c)\n{\n    vec2 q = abs(p)-c;\n    return min(0.,max(q.x,q.y))+length(max(q,0.));\n}\n\nfloat a;\nfloat torus (vec3 p, vec2 rs)\n{\n    float s = length(p.xz)-rs.x, b = max(abs(p.x),abs(p.z))-rs.x;\n    vec2 cp = mix(vec2(b,p.y),vec2(s,p.y),clamp(swi(0.2),0.,1.));\n    a = atan(p.z,p.x);\n    cp *= rot(a+iTime);\n    cp.y = abs(abs(cp.y)-.6)-.3;\n    \n    float d = box2d(cp,vec2(rs.y,(rs.y+sin(a)/PI)*.35))-0.03;\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    return torus(p,vec2(2.5,0.3));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 n, vec3 l, vec3 rd)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.), 25.);\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return SDF(p+eps*n)/eps;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(uv*3.5,-30.),rd=vec3(0.,0.,1.),p=ro,\n    col=vec3(0.95,0.9,0.8),l=vec3(1.,2.,-2.);\n\n    bool hit=false;\n    \n    for(float i=0.; i<60.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit=true;break;\n        }\n        p += d*rd*0.65;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,normalize(l))*.5+.5, ao=AO(0.1,p,n)+AO(0.45,p,n)+AO(0.8,p,n);\n        col = mix(vec3(0.,0.,0.2),pal(a/PI,vec3(2.)),light)*ao/3.+spec(n,l,rd);\n    }\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}