{"ver":"0.1","info":{"id":"DsscDn","date":"1686730524","viewed":132,"name":"SDF Fractals","username":"isotach","description":"This shader is based on [url=https://youtu.be/f4s1h2YETNY]an \"intro to shader art\" video by @kishimisu[/url], modified to make it easy to play around with using a few simple parameters.\n\nOriginal shadertoy: [url]https://www.shadertoy.com/view/mtyGWy[/url]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------ Configuration ------------ //\n\nint sdf = 7;        // 0-9\nint iterations = 3; // Non-zero positive number\n\nbool iterDepthFade = false; // Make each consecutive iteration dimmer\n\n// Palette Tool: http://dev.thi.ng/gradients/\nvec3 paletteA = vec3(0.5, 0.5, 0.5);\nvec3 paletteB = vec3(0.5, 0.5, 0.5);\nvec3 paletteC = vec3(1.0, 1.0, 1.0);\nvec3 paletteD = vec3(0.2, 0.4, 0.6);\n\n// --------------------------------------- //\n\n\n// Utility Functions\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n\n// SDF Functions - https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdQuadraticCircle( in vec2 p )\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = a*a + c*c*c;\n    float t;\n    if( h>=0.0 )\n    {   \n        h = sqrt(h);\n        t = sign(h-a)*pow(abs(h-a),1.0/3.0) - pow(h+a,1.0/3.0);\n    }\n    else\n    {   \n        float z = sqrt(-c);\n        float v = acos(a/(c*z))/3.0;\n        t = -z*(cos(v)+sin(v)*1.732050808);\n    }\n    t *= 0.5;\n    vec2 w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w) * sign( a*a*0.5+b-1.5 );\n}\n\nfloat sdfCoolS( in vec2 p )\n{\n    float six = (p.y<0.0) ? -p.x : p.x;\n    p.x = abs(p.x);\n    p.y = abs(p.y) - 0.2;\n    float rex = p.x - min(round(p.x/0.4),0.4);\n    float aby = abs(p.y-0.2)-0.6;\n    \n    float d = dot2(vec2(six,-p.y)-clamp(0.5*(six-p.y),0.0,0.2));\n    d = min(d,dot2(vec2(p.x,-aby)-clamp(0.5*(p.x-aby),0.0,0.4)));\n    d = min(d,dot2(vec2(rex,p.y  -clamp(p.y          ,0.0,0.4))));\n    \n    float s = 2.0*p.x + aby + abs(aby+0.4) - 0.4;\n\n    return sqrt(d) * sign(s);\n}\n\n\n// Config Handlers\nvec3 palette(float t) {\n    return paletteA + paletteB * cos(6.28318 * (paletteC * t + paletteD));\n}\n\nfloat sdfSelect(vec2 p) {\n    sdf = max(min(sdf, 9), 0); // jic <3\n\n    if (sdf == 0) return sdCircle(p, 0.0);\n    if (sdf == 1) return sdEquilateralTriangle(p, 0.5);\n    if (sdf == 2) return sdPentagon(p, 0.5);\n    if (sdf == 3) return sdHexagon(p, 0.5);\n    if (sdf == 4) return sdOctogon(p, 0.5);\n    if (sdf == 5) return sdHexagram(p, 0.5);\n    if (sdf == 6) return sdHeart(p);\n    if (sdf == 7) return sdRoundedX(p, 1.0, 0.5);\n    if (sdf == 8) return sdQuadraticCircle(p);\n    if (sdf == 9) return sdfCoolS(p);\n}\n\n// Rendering\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float baseSDF = sdfSelect(uv);\n    vec3 fCol = vec3(0.0);\n    \n    iterations = max(iterations, 1); // jic <3\n    for (int i = 0; i < iterations; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        float d = sdfSelect(uv) * exp(-baseSDF);\n        vec3 col = palette(baseSDF + float(i) * 0.4 + iTime * 0.4);\n        d = pow(0.01 / abs(sin(d * 8.0 + iTime) / 8.0), 1.2);\n        fCol += col * d * (iterDepthFade ? (1.0 / float(i + 1)) : 1.);\n    }\n    \n    fragColor = vec4(fCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}