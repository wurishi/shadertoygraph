{"ver":"0.1","info":{"id":"mlySWG","date":"1687105346","viewed":98,"name":"Atmosphere sky sphere","username":"Confession","description":"A semi realistic atmosphere render","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi (3.16159)\n\nfloat density(float height) {\n    const float land = 0.1;\n    float height01 = (height - land) / (1.0 - land);\n    return exp(-height01*0.5);\n}\n\nvec2 raySphere(vec3 spherePos,float sphereRad, vec3 rayPos, vec3 rayDir) \n{\n    vec3 delta = rayPos - spherePos;\n    float angle = dot(delta, rayDir) * 2.;\n    float sphereSquaredDistance = dot(delta, delta) - sphereRad * sphereRad;\n    float D = angle*angle - 4.0 * sphereSquaredDistance;\n    \n    if(D > 0.0) \n    {\n        float s = sqrt(D);\n        float near = max(0., (-angle - s) / 2.);\n        float far = (-angle + s) / 2.;\n        if(far > 0.)\n            return vec2(near, far - near);\n    }\n    return vec2(-1.0, 0.0);\n}\n\nfloat opticalDepth(vec3 spherePos, float sphereRad, vec3 rayPos, vec3 rayDir, float rayLength) \n{\n    const float step = 0.05;\n    float depth = 0.0;\n    vec2 sphereCast = raySphere(spherePos, sphereRad, rayPos, rayDir);\n    rayPos += rayDir * sphereCast.x;\n    float castLength = min(rayLength - sphereCast.x, sphereCast.y);\n    for(float i = 0.; i < castLength; i += step) \n    {\n        depth += density(length(spherePos - rayPos)) * step;\n        rayPos += rayDir * step;\n    }\n    return depth;\n}\n\nvec3 atm(vec3 spherePos, float sphereRad, vec3 rayPos, vec3 rayDir) \n{\n    vec3 sun = normalize(vec3(5.0, 2.0,0.0));\n    const vec3 waveLengths = vec3(700., 560., 440.)/440.;\n    float scatterStrength = 8.5;\n    vec3 coeffs = vec3(\n    pow(1./waveLengths.x,4.) * scatterStrength,\n    pow(1./waveLengths.y,4.) * scatterStrength,\n    pow(1./waveLengths.z,4.) * scatterStrength\n    );\n    const float step = 0.005;\n    float steplen = 0.0;\n    vec3 inScatter = vec3(0.);\n    \n    vec2 sphereCast = raySphere(spherePos, sphereRad, rayPos, rayDir);\n    rayPos += rayDir * sphereCast.x;\n    float castLength = sphereCast.y;\n    \n    float eyeOpticalDepth = 0.0;\n    \n    for(float i = 0.; i < castLength; i += step) \n    {\n        rayPos += rayDir * step;\n        steplen += step;\n        float optDepth = opticalDepth(spherePos, sphereRad, rayPos, sun, 1.0);\n        eyeOpticalDepth += density(length(spherePos - rayPos)) * step;\n        vec3 transmitance = exp((-optDepth-eyeOpticalDepth) * coeffs);\n        inScatter += density(length(rayPos - spherePos)) * 2.0 * transmitance * coeffs * step;\n    }\n    return inScatter;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayPos = vec3(0.0, 0.9, 0.0);\n    vec3 rayDir = normalize(vec3(sin(uv.x * pi) * sin(uv.y*pi), cos((1.0-uv.y)*pi), cos(uv.x * pi) * sin(uv.y*pi)));\n    //rayDir = normalize(rayDir);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 s = atm(vec3(0.0, 0.0, 0.0), 1.0, rayPos, rayDir);\n    \n    // Output to screen\n    fragColor = vec4(s, 1.0);\n}","name":"Image","description":"","type":"image"}]}