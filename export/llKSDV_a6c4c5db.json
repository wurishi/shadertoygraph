{"ver":"0.1","info":{"id":"llKSDV","date":"1486063028","viewed":144,"name":"Hi World","username":"pineapplemachine","description":"Displays a hello world animation by transitioning through the letters HIWORLD.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["hello","world"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Defines size of glyphs on the render target\n#define GlyphWidth 6.0\n#define GlyphHeight 3.0\n\n// Weight of glyph lines\n#define LineWeight 0.15\n\n// Enumeration of possible glyphs\n#define GlyphCount 7\n#define GlyphH 0\n#define GlyphI 1\n#define GlyphW 2\n#define GlyphO 3\n#define GlyphR 4\n#define GlyphL 5\n#define GlyphD 6\n\n// Get minimum distance from a point to a line segment.\n// Credit http://stackoverflow.com/a/1501725/3478907\nfloat ptlinedist(in vec2 point, in vec4 line){\n    float dx = line.x - line.z;\n    float dy = line.y - line.w;\n    float lensq = dx * dx + dy * dy;\n    float t = clamp(dot(point - line.xy, line.zw - line.xy) / lensq, 0.0, 1.0);\n    vec2 proj = line.xy + t * (line.zw - line.xy);\n    return distance(point, proj);\n}\n\n// Get minimum distance from a point to any line or curve of a glyph.\nfloat glyphdist(in vec2 point, in int glyph){\n    if(glyph == GlyphH){\n        float l0 = ptlinedist(point, vec4(-1.0, -1.0, -1.0, +1.0));\n    \tfloat l1 = ptlinedist(point, vec4(+1.0, -1.0, +1.0, +1.0));\n    \tfloat l2 = ptlinedist(point, vec4(-1.0, +0.0, +1.0, +0.0));\n    \treturn min(min(l0, l1), l2);\n    }else if(glyph == GlyphI){\n    \tfloat l0 = ptlinedist(point, vec4(-1.0, -1.0, +1.0, -1.0));\n    \tfloat l1 = ptlinedist(point, vec4(-1.0, +1.0, +1.0, +1.0));\n    \tfloat l2 = ptlinedist(point, vec4(+0.0, -1.0, +0.0, +1.0));\n    \treturn min(min(l0, l1), l2);\n    }else if(glyph == GlyphW){\n    \tfloat l0 = ptlinedist(point, vec4(-1.0, -1.0, -1.0, +1.0));\n    \tfloat l1 = ptlinedist(point, vec4(+1.0, -1.0, +1.0, +1.0));\n    \tfloat l2 = ptlinedist(point, vec4(-1.0, -1.0, +0.0, -0.125));\n    \tfloat l3 = ptlinedist(point, vec4(+1.0, -1.0, +0.0, -0.125));\n    \treturn min(min(min(l0, l1), l2), l3);\n    }else if(glyph == GlyphO){\n    \treturn abs(1.0 - length(point));\n    }else if(glyph == GlyphR){\n    \tfloat l0 = ptlinedist(point, vec4(-1.0, -1.0, -1.0, +1.0));\n    \tfloat l1 = ptlinedist(point, vec4(-1.0, +1.0, +1.0, +1.0));\n    \treturn min(l0, l1);\n    }else if(glyph == GlyphL){\n    \tfloat l0 = ptlinedist(point, vec4(-1.0, -1.0, -1.0, +1.0));\n    \tfloat l1 = ptlinedist(point, vec4(-1.0, -1.0, +1.0, -1.0));\n    \treturn min(l0, l1);\n\t}else{ // glyph == GlyphD\n        if(point.x >= 0.0){\n    \t\treturn abs(1.0 - length(point));\n        }else{\n            float l0 = ptlinedist(point, vec4(-1.0, -1.0, -1.0, +1.0));\n            float l1 = ptlinedist(point, vec4(-1.0, -1.0, +1.0, -1.0));\n            float l2 = ptlinedist(point, vec4(-1.0, +1.0, +1.0, +1.0));\n            return min(min(l0, l1), l2);\n        }\n\t}\n}\n\nint imod(in int a, in int b) {\n    float m = float(a) - floor((float(a) + 0.5) / float(b)) * float(b);\n    return int(floor(m + 0.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    const vec4 fg = vec4(0.9, 0.9, 0.9, 1.0); // Foreground color\n    const vec4 bg = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    vec2 texuv = fragCoord.xy / iResolution.xy;\n    vec2 gylphuv = (texuv - vec2(0.5, 0.5)) * vec2(GlyphWidth, GlyphHeight);\n    int glyph = imod(int(iTime * 0.2), GlyphCount);\n    bool isfg = texture(iChannel0, texuv) == fg;\n    bool usefg = glyphdist(gylphuv, glyph) < LineWeight;\n    if(isfg != usefg){\n        int countfg = 0;\n        int bias = 0;\n        for(int i = -3; i <= 4; i++){\n            for(int j = -3; j <= 4; j++){\n                int absi = (i > 0 ? i : -i);\n                int absj = (j > 0 ? j : -j);\n                if(absi + absj <= 4){\n                    vec2 target = (fragCoord.xy + vec2(i, j)) / iResolution.xy;\n                    bool pixfg = texture(iChannel0, target) == fg;\n                    countfg += int(pixfg);\n                    bias += int(pixfg == usefg) * int(absi == absj);\n                }\n            }\n        }\n        float rand = iTime * cos(fragCoord.x) * sin(fragCoord.y);\n        rand = abs(rand - floor(rand));\n        int fgthreshold = 5 + int(rand * 4.0) - bias;\n        int bgthreshold = 16 + int(rand * 5.0) + bias;\n        if(usefg && (countfg >= fgthreshold || iFrame == 0)){\n            fragColor = fg;\n        }else if(!usefg && (countfg <= bgthreshold || iFrame == 0)){\n            fragColor = bg;\n        }else{\n            fragColor = isfg ? fg : bg;\n        }\n    }else{\n        fragColor = isfg ? fg : bg;\n    }\n}\n","name":"Buf A","description":"","type":"buffer"}]}