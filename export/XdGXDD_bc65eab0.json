{"ver":"0.1","info":{"id":"XdGXDD","date":"1464376216","viewed":293,"name":"landscapes","username":"stduhpf","description":"My very first 3D landscpe test. \nalt+downarrow=a new random scene\nedit: i reduced the step amount and added a true random seed.(and removed reflections, because they were not really visible and the shader didn't compile)\nEdit 2 : added tilt-shift dof","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","terrain","perlinnoise","cartoon","tiltshift"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this part is not from me, it's a modified version of the simplified version of Dave Hoskin's blur I copied from: https://www.shadertoy.com/view/ltKGzc\n//#define SHOW_FOCUS //show where the camera is focusing\n\n\n//#define CEL_SHADING // depth derivative  based outline effect. It works, but disabeld because it does not fit well with dof\n#define TILT_SHIFT //Depth of field\n#define gamma 1.4 // gamma correction\n\n#define res  iResolution\n\nfloat GA =2.399;  // golden angle = 2pi/(1+phi)\n\n#define blit 50 // blur iterations (changes the quality , but also the radius of the blur\n#define  rot  mat2(cos(GA),sin(GA),-sin(GA),cos(GA))\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);\n    rad=1.;\n\tfor (int j=0;j<blit;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(blit) ;\n}\nvec4 pow4(vec4 v, float p)\n{\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),pow(v.w,p));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef TILT_SHIFT\n    float depth =texture(iChannel0,fragCoord/res.xy).w;\n    vec2 um = iMouse.xy/res.xy;\n    if(iMouse.xy ==vec2(0))\n        um = vec2(.5,.2);\n    float d0 = texture(iChannel0,um).w; // click to focus\n    if(d0==0.)d0=50.;\n\tdepth =depth ==0.?0.:abs(.5* log(depth/d0));\n    \n   fragColor = pow4(vec4(dof(iChannel0,fragCoord/res.xy,depth),1.),gamma);\n    \n    #ifdef SHOW_FOCUS\n   if(depth-.02<0.&& depth !=0.)\n       fragColor=vec4(length(fragColor.rgb),0.,0.,0.);\n    #endif\n\n    #else\n    fragColor  = pow4(texture(iChannel0,fragCoord/res.xy),gamma);\n    #endif\n    #ifdef CEL_SHADING\n    vec2 e = vec2(.001,0);\n    vec4 dif = vec4(texture(iChannel0,fragCoord/res.xy+e.xy).w,texture(iChannel0,fragCoord/res.xy+e.yx).w,\n                    texture(iChannel0,fragCoord/res.xy-e.xy).w,texture(iChannel0,fragCoord/res.xy-e.yx).w);\n    dif = log(dif);\n    float d = length(vec2(abs(dif.x-dif.z),abs(dif.y-dif.w)));\n    if(d>.1)  fragColor*=.1;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float seed =0.;\n\nfloat rand(vec2 co){\n    return fract(seed+sin(seed+dot(co,vec2(12.9898,78.233)))*43758.5453)-.5;}\n\nvec2 grad(vec2 co){\n    return vec2(rand(co),rand(vec2(2,3)*co.yx+.5));\n        }\nfloat perlin(vec2 uv)\n{\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n    \n    vec2 grad1 = grad(inco);\n    vec2 grad2 = grad(inco+vec2(1,0));\n    vec2 grad3 = grad(inco+vec2(1,1));\n    vec2 grad4 = grad(inco+vec2(0,1));\n    \n    float s = dot(grad1,relco);\n    float t = dot(grad2, relco-vec2(1,0));\n    float u = dot(grad3, relco-1.);\n    float v = dot(grad4, relco-vec2(0,1));\n    \n    float n1 = mix(s,t,smoothstep(0.,1.,relco.x));\n    float n2 = mix(v,u,smoothstep(0.,1.,relco.x));\n\n    return mix(n1,n2,smoothstep(0.,1.,relco.y));\n}\nfloat fbm(vec2 co)\n{\n    mat2 r = mat2(0.69670670934,-0.7173560909,0.7173560909,0.69670670934);\n    float f = .5*perlin(co);co*=r*2.02;\n    f += .25*perlin(co);co*=r*2.01;\n    f += .125*perlin(co);co*=r*2.03;\n    return f + .0625*perlin(co);\n}\n                \nfloat terrainheightmap(vec3 p)\n{\n    return p.y+.75+5.*fbm(p.xz)+ 30.*perlin(p.xz*.025)+.1*fbm(10.*p.zx)+length(p.xz)/5.;\n}\nfloat water(vec3 p)\n{\n    return p.y+1.+.01*cos(iTime-10.*length(p.xz))+.001*sin(iTime-50.*length(p.xz+1.6))+length(p.xz)/5.;\n}\n\nvec2 un(vec2 a, vec2 b)\n{\n    float t =  min(a,b).x;\n    float m = b.y;\n    if(a.x==t)\n        m=a.y;\n    return vec2(t,m);\n}\n\n vec2 map(vec3 pos)\n {\n     vec2 dl = vec2(terrainheightmap(pos),1.);\n     dl = un(dl,vec2(water(pos),2.));\n     return dl;\n }\nvec2 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    for(int i = 0; i <400; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<0.01)\n                return vec2(f,h.y);\n               \tif(f > n)\n           break;\n        \n            f+=h.x*(h.y==1.?.25:.5);\n    }\n    return vec2(0);\n}\n\nfloat shadow(vec3 ro, vec3 rd,float n)\n{\n    float res = .5;\n    float f=0.1;\n    for(int i = 0; i <200; i++)\n    {\n        float h = map(ro+f*rd).x;\n            if(h<0.01)\n                return 0.;\n               \tif(f > n)\n           break;\n        res = min(res,8.*h/f);\n            f+=.25*h;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.001,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nvec4 getmaterial(float m,vec3 pos)\n{\n    if (m == 1.)\n    {\n        pos.y+=(pos.y+.5)*(perlin(pos.xz*10.)/2.)+2.*perlin(pos.zx)+length(pos.xz)/5.;\n        vec4 col = vec4(1.);\n\n        if (pos.y<1.)col=vec4(.5,.5,.5,.001);\n        if (pos.y<-.1)col=vec4(.1,.5,.1,.001);\n        if (pos.y<-.9)col=vec4(.9,.8,.1,.2);\n        return col;\n    }\n    if (m == 2.)\n        return vec4(0,.2,1,1);\n    return vec4 (0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    seed =  floor(iDate.w-iTime);\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(2.*(uv-.5),-1.5));\n    vec2 rc = intersect(ro,rd,50.);\n    vec3 light = vec3 (cos(iTime),.5,sin(iTime));\n    vec3 col = vec3(0,.1,.9);\n    col+=.1/length(rd-light);\n    col = mix(col,vec3(.5),max(2.*perlin(10.*(rd).zx*vec2(1,.3)+iTime/10.)+.2,0.));\n    if (rc.y>0.)\n    {\n        col*=0.;\n        vec3 pos = ro+rc.x*rd;\n        vec3 nor = normal(pos);\n        vec4 mat = getmaterial(rc.y,pos);\n        vec3 ref =  -(2.*dot(nor,rd)*nor-rd);\n        float phong = 1./length(light-ref);\n        float shad = shadow(pos,light,8.);\n        col+=.2;\n        col+=max(0.,dot(nor,light))*shad; \n        col*=mat.rgb+phong*shad*mat.a;\n       // col = mix(col,reflet(pos+ref*.01,ref,8.,4.),mat.a/5.);\n    }\n\tfragColor = vec4(col,rc.x/50.);\n}","name":"Buf A","description":"","type":"buffer"}]}