{"ver":"0.1","info":{"id":"3dfGzf","date":"1546965756","viewed":210,"name":"RayTracer Vs RayMarcher","username":"gPlatl","description":"Try to compare Raytracer (green) with RayMarcher (red) displaying an antialiased sphere in a cubemap scenery. \n\nPlease set view to fullsceen and press mouse button to toggle between the 2 methods.\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","raytracer","sphere","antialiasing","cubemap","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//----------------------------------------------------------\n// RayTracer_Vs_RayMarcher.glsl       by Gerd Platl\n//\n// Try to compare Raytracer (green) with RayMarcher (red)\n// displaying an antialiased sphere in a cubemap scenery.\n// Please set view to fullsceen and press mouse button\n// to toggle between the 2 methods.\n// In principle no difference but antialiased sphere is better\n// with raytracer, because of calculated normal!\n//\n//   v1.0  2019-01-08  initial version at 3dfGzf\n//   v1.1  2019-02-12  hit & light handling added\n//         2019-02-22  camera correction  if mouse==0\n//\n// tags: 3d, raymarcher, raytracer, sphere, reflection, antialiasing, cubemap\n//\n// --- features ---\n//   cubebox:     yes     transparency: no\n//   reflection:  yes     refraction:   no\n//   light:       yes     shadow:       no\n//   antialiased: yes\n//----------------------------------------------------------\n\nconst vec3  skyboxColor   = vec3(0.80, 0.96, 1.00);\nconst vec3  sphMarchColor = vec3(0.50, 0.70, 0.40);  // Green\nconst vec3  sphTraceColor = vec3(0.90, 0.70, 0.70);  // Red\n\n//------- ray -------\nstruct Ray\n{\n  vec3 origin;\n  vec3 direction;\n};\nRay camera = Ray(vec3(0), vec3(0,0,1));\n\n//------- sphere -------\nstruct Sphere\n{\n  vec3 center;\n  float radius;\n};\nSphere sphere1 = Sphere(vec3(0), 3.4);\n\n// ray intersection hit\nstruct Hit      // ray intersection data\n{ vec3 pos;     // hit position\n  vec3 normal;  // normalized object normal\n  float dist;   // distance to object\n};\nHit hit1 = Hit(vec3(0,0,0), vec3(0,1,0), 1.);\n\n//==========================================================\n// RayMarcher\n//==========================================================\n\n// get sphere distance\nfloat sdSphere(in vec3 p)\n{ return length(p) - sphere1.radius; }\n\n// get surface normal vector\nvec3 getNormal(vec3 pos)\n{\n  float d = sdSphere(pos);\n  vec3 eps = vec3(0.002, 0.0, 0.0);\n  return normalize(vec3(d - sdSphere(pos - eps.xyy),\n                        d - sdSphere(pos - eps.yxy),\n                        d - sdSphere(pos - eps.yyx)));\n}\n\n// raymarcher from rayOrigin in rayDirection,\n// return sphere intersection hit data\nbool rayMarch()\n{\n  float d = 0.0, t = 0.0;\n  for(int i = 0; i < 64; ++i)\n  {\n    d = sdSphere(camera.origin + t * camera.direction);\n    if(abs(d) < 0.001) break;\n    if(t > 100.0) break;\n    t += d;\n  }\n  hit1.dist = d;\n  bool ip = ((d > 0.0) && (d < 100.0));\n  if(ip)\n  {\n    hit1.pos = camera.origin + t * camera.direction;    // sphere intersection point\n    hit1.normal = getNormal(hit1.pos);           // sphere surface normal\n  }\n  return ip;\n}\n\n//==========================================================\n// RayTracer\n//==========================================================\n\nvec3 SphereNormal (in vec3 surfacePos, in Sphere sphere)\n{\n  return normalize(surfacePos - sphere.center);\n}\n//----------------------------------------------------------\nbool RaySphereIntersection (in Ray ray, in Sphere sphere)\n{\n  vec3 h = ray.origin - sphere.center;\n  float lf = dot(ray.direction, h);\n  float s = sphere.radius*sphere.radius -dot(h,h) +lf*lf;\n  if (s > 0.0);       // Schnittpunkte ?\n    s = -lf -sqrt(s);\n  hit1.pos = ray.origin + s * ray.direction;   // sphere intersection point\n  hit1.normal = SphereNormal (hit1.pos, sphere); // sphere surface normal\n  hit1.dist = s;\n  return (s > 0.0);\n}\n\n//==========================================================\n// Testframe\n//==========================================================\n\n// get camera origin and direction\nvoid getCamera(vec2 coord)\n{\n  vec2 uv = (coord * 2.0 - iResolution.xy) / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.y * 3.5;\n  if (mo == vec2(0)) mo = vec2(0,1.75);\n  vec3 ro = 5.0 * vec3(sin(mo.x), 2.0-mo.y, cos(mo.x));\n  vec3 z = normalize(ro);\n  vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n  vec3 rd= normalize(mat3(x, cross(z, x), z) * vec3(uv, -1.0));\n  camera = Ray(ro,rd);\n}\n//----------------------------------------------------------\nvec3 color;\n\nvoid AddColor(vec3 color2)\n{\n  vec3 ro = camera.origin;\n  vec3 rd = camera.direction;\n\n  vec3 sp = hit1.pos;                // sphere intersection point\n  vec3 sn = hit1.normal;             // sphere surface normal\n  vec3 refDir = reflect(rd, sn);     // reflection vector\n  vec3 refColor = texture(iChannel0, refDir).rgb * color2;\n\n  // add light reflection\n  const vec3 lightPos = vec3(60.,250.,10.);\n  const vec3 lightColor = vec3(0.5);\n  vec3 lightDir = normalize(lightPos - hit1.pos);\n  vec3 liRefDir = reflect (lightDir, hit1.normal);\n  float rf = max(0.,dot(liRefDir,rd));\n  refColor += lightColor*pow(rf,40.);\n\n  float d = 5.0 * dot(refDir, sn);   // antialiasing\n  color = mix(color, refColor, smoothstep(0.,1.,d));\n}\n//----------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  getCamera(fragCoord);\n\n  // get skybox pixel color\n  color = texture(iChannel0, camera.direction).xyz * skyboxColor;\n\n  if (iMouse.z > 0.5)          // mousePressed ?\n  {\n    //=== RayMarcher ===\n    if (rayMarch())            // sphere intersection ?\n      AddColor(sphMarchColor);\n  }\n  else\n  {\n    //=== RayTracer ===\n    if (RaySphereIntersection (camera, sphere1))\n      AddColor(sphTraceColor);\n  }\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}