{"ver":"0.1","info":{"id":"fsd3DH","date":"1629731274","viewed":98,"name":"RTiOW Final Render","username":"LeoLeo3D","description":"Followed and implemented Ray-Tracing in One Weekend by Peter Shirley. https://raytracing.github.io/books/RayTracingInOneWeekend.html\nYou can follow the fork links to see my process. Next I plan to follow and implement the second book.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"ss33W8","parentname":"Ray-Tracing 1.13"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    LeoLeo's Ray-Tracing in One Weekend implementation. 1000th one on Shadertoy\n    \n    Been a little while since I've messed around with shaders, thought the best way to come back was to implement \n    Peter Shirley's ray-tracing book. After this, I plan to implement the second book. \n\n    You can follow the 'Forked from' links to follow my process through the book. All those shaders are unlisted and\n    are not documented.\n    \n*/\n\n// Following: https://raytracing.github.io/books/RayTracingInOneWeekend.html\n// ~LeoLeo\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.xyz/data.w;\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 6\n\n#define PI 3.14159265358979323846\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nvec3 random_unit_vector() {\n    return normalize(random_in_unit_sphere(g_seed));\n}\n\n\n// From book\nvec3 random_in_hemisphere(in vec3 n) {\n    vec3 in_unit_sphere = random_in_unit_sphere(g_seed);\n    if(dot(in_unit_sphere, n) > 0.0) // In the same hemisphere as normal\n        return in_unit_sphere;\n    else\n        return -in_unit_sphere;\n}\n\nbool near_zero(vec3 vec) {\n    float s = 1e-8;\n    return(abs(vec.x) < s) && (abs(vec.y) < s) && (abs(vec.z) < s);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Following: https://raytracing.github.io/books/RayTracingInOneWeekend.html\n// ~LeoLeo\n\n// Primitive IDs\n#define SPHERE      1\n\n// Samples constant. !! Not in use in this implementation, can be removed if neccesary\n#define SAMPLES     1\n\n// Materials IDs\n#define LAMBERT     0 \n#define METAL       1\n#define DIELECTRIC  2\n\n// ----------------------------------------------------------------------\nstruct camera\n{\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\nstruct ray \n{\n    vec3 o;\n    vec3 d;\n};\n\nstruct material\n{\n    int type;\n    vec3 albedo;\n    float mat_val; // Can be metal fuzz or dielectric ir. Depends on type val.\n};\n\nstruct hit_rec\n{\n    vec3 p; // hit point location\n    vec3 n; // hit normal vector\n    material mat; // material of hit object\n    float t; // t value\n    bool front_face; // is the face hit an outward facing face?\n};\n\nstruct object\n{\n    int type;\n    \n    material mat;\n\n    vec3 a; // Sphere: center\n    vec3 b; // Sphere: b.x -> Radius\n};\n\n// ----------------------------------------------------------------------\nvec3 ray_at(in ray r, in float t) \n{\n    return r.o + t*r.d;\n}\n\nfloat degrees_to_radians(float deg)\n{\n    return deg*(PI/180.0);\n}\n\ncamera get_cam(vec3 lookFrom, vec3 lookAt, vec3 vup, in float vfov, in float aspect, float aperature, float focus_dist) \n{\n    camera cam;\n    \n    \n    float theta = degrees_to_radians(vfov);\n    float h = tan(theta/2.0);\n    float viewport_height = 2.25*h;\n    float viewport_width = aspect * viewport_height;\n    \n    cam.w = normalize(lookFrom - lookAt);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.origin = lookFrom;\n    cam.horizontal = focus_dist * cam.u * viewport_width;\n    cam.vertical = focus_dist * cam.v * viewport_height;\n    cam.lower_left_corner = cam.origin - cam.horizontal/2.0 - cam.vertical/2.0 - focus_dist*cam.w;\n    \n    cam.lens_radius = aperature/2.0;\n    \n    return cam;\n}\n\n// Get ray from the given camera and uv position on the image plane\nray cam_get_ray(in float s, in float t, in camera cam) \n{\n    vec3 rd = cam.lens_radius * random_in_unit_sphere(g_seed);\n    vec3 offset = cam.u*rd.x + cam.v*rd.y;\n    return ray(cam.origin + offset, cam.lower_left_corner + s*cam.horizontal + t*cam.vertical - cam.origin - offset);\n}\n\nvoid set_face_normal(in ray r, in vec3 outward_normal, inout hit_rec rec)\n{\n    rec.front_face = dot(r.d, outward_normal) > 0.0;\n    rec.n = rec.front_face ? -outward_normal : outward_normal;\n}\n\nfloat reflectance(float cosine, float ref_idx) \n{\n    // Use Schlick's approximation for reflectance\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    \n    r0 = r0*r0;\n    \n    return r0 + (1.0-r0)*pow((1.0-cosine), 5.0);\n}\n\n// For some reason the implemented refract function leads to black dot artefacts, don't know why.\nvec3 modified_refract(vec3 uv, vec3 n, float ir) {\n    float cos_theta = min(dot(-uv, n), 1.0);\n    vec3 r_out_perp =  ir * (uv + cos_theta*n);\n    vec3 r_out_parallel = -sqrt(abs(1.0 - pow(length(r_out_perp), 2.0))) * n;\n    return r_out_perp + r_out_parallel;\n}\n\n// Where does the ray go after hitting?\nbool scatter(in ray r, inout hit_rec rec, inout vec3 atten, inout ray scattered)\n{\n    if(rec.mat.type == LAMBERT) {\n        vec3 scatter_dir = rec.n + random_unit_vector();\n        \n        // Catch degenerate scatter direction\n        if(near_zero(scatter_dir))\n            scatter_dir = rec.n;\n        \n        scattered = ray(rec.p, scatter_dir);\n        atten = rec.mat.albedo;\n        return true;\n    }\n    else if(rec.mat.type == METAL) {\n        vec3 reflected = reflect(normalize(r.d), rec.n);\n        \n        rec.mat.mat_val = rec.mat.mat_val < 1.0 ? rec.mat.mat_val : 1.0; // Max value of 1.0 fuzz\n        \n        scattered = ray(rec.p, reflected + rec.mat.mat_val*random_in_unit_sphere(g_seed));\n        atten = rec.mat.albedo;\n        return(dot(scattered.d, rec.n) > 0.0);\n    }\n    else if(rec.mat.type == DIELECTRIC) {\n        atten = vec3(1.0);\n        \n        float refract_ratio = rec.front_face ? rec.mat.mat_val : (1.0/rec.mat.mat_val);\n        float cos_theta = min(dot(-r.d, rec.n), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n    \n        bool cannot_refract = refract_ratio * sin_theta > 1.0;\n        vec3 direction;\n        \n        // if refraction cant happen or the refracted ray does not count\n        if(cannot_refract || rand1(g_seed) < reflectance(cos_theta, refract_ratio))\n            direction = reflect(normalize(r.d), rec.n);\n        else\n            direction = modified_refract(normalize(r.d), rec.n, refract_ratio);\n            \n        scattered = ray(rec.p, direction);\n        return true;\n    }\n    return false;\n}\n\n// Does the ray hit this specific primitive?\nbool hit(in ray r, in float t_min, in float t_max, inout hit_rec rec, in object obj)\n{\n    // Sphere collision\n    if(obj.type == SPHERE) {\n        vec3 oc = r.o - obj.a;\n        float a = pow(length(r.d), 2.0);\n        float half_b = dot(oc, r.d);\n        float c = pow(length(oc), 2.0) - obj.b.x*obj.b.x;\n        \n        float discriminant = half_b*half_b - a*c;\n        if(discriminant < 0.0) return false;   \n        float sqrtd = sqrt(discriminant);\n        \n        // Find the nearest root that lies in the acceptable range.\n        float root = (-half_b - sqrtd) / a;\n        if(root < t_min || t_max < root) {\n            root = (-half_b + sqrtd) / a;\n            if(root < t_min || t_max < root)\n                return false;\n        }\n        \n        rec.t = root;\n        rec.p = ray_at(r, rec.t);\n        vec3 outward_normal = (rec.p - obj.a) / obj.b.x;\n        set_face_normal(r, outward_normal, rec);\n        rec.mat = obj.mat;\n        \n        return true;\n    }\n}\n\n// ========================================================================\n// World function, holds all information of the world objects.\n// ========================================================================\nbool world(in ray r, in float t_min, in float t_max, inout hit_rec rec)\n{\n    // Unchanging seed for random spheres. g_seed is based on time and so cannot be used to seed the random colors.\n    float CONST = 410.0;\n\n    hit_rec temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n\n    // Ground Sphere\n    object ground = object(SPHERE, material(LAMBERT, vec3(0.5), 0.0), vec3(0.0, -1000.0, 0.0), vec3(1000.0, 0.0, 0.0));\n    \n    if(hit(r, t_min, closest_so_far, temp_rec, ground)) {\n        hit_anything = true;\n        closest_so_far = temp_rec.t;\n        rec = temp_rec;\n    }\n\n    // make randomized grid of random spheres\n    for(int a = -6; a < 6; a++) {\n        for(int b = -6; b < 6; b++) {\n            float choose_mat = rand1(CONST);\n            vec3 center = vec3(float(a)*2.0 + 0.9*rand1(CONST), 0.2, float(b)*2.0*rand1(CONST));\n            \n            if(length(center - vec3(4.0, 0.2, 0.0)) > 0.9) {\n                material sphere_mat;\n                \n                if(choose_mat < 0.8) {\n                    // diffuse\n                    vec3 albedo = rand3(CONST) * rand3(CONST);\n                    sphere_mat = material(LAMBERT, albedo, 0.0);\n                } else if(choose_mat < 0.95) {\n                    // metal\n                    vec3 albedo = vec3(0.5) + rand3(CONST);\n                    float fuzz = rand1(CONST);\n                    sphere_mat = material(METAL, albedo, fuzz);\n                } else {\n                    sphere_mat = material(DIELECTRIC, vec3(1.0), 1.5);\n                }\n                \n                if(hit(r, t_min, closest_so_far, temp_rec, object(SPHERE, sphere_mat, center, vec3(0.2, 0.0, 0.0)))) {\n                    hit_anything = true;\n                    closest_so_far = temp_rec.t;\n                    rec = temp_rec;\n                }\n            }\n        }\n    }\n    \n    // Ground Metal\n    object mat_1 = object(SPHERE, material(METAL, vec3(0.7, 0.6, 0.5), 0.0), vec3(4.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0));\n    \n    if(hit(r, t_min, closest_so_far, temp_rec, mat_1)) {\n        hit_anything = true;\n        closest_so_far = temp_rec.t;\n        rec = temp_rec;\n    }\n    \n    // Ground Lambert\n    object mat_2 = object(SPHERE, material(LAMBERT, vec3(0.4, 0.2, 0.1), 0.0), vec3(-4.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0));\n    \n    if(hit(r, t_min, closest_so_far, temp_rec, mat_2)) {\n        hit_anything = true;\n        closest_so_far = temp_rec.t;\n        rec = temp_rec;\n    }\n    \n    // Ground Dielectric\n    object mat_3 = object(SPHERE, material(DIELECTRIC, vec3(0.5), 1.5), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0));\n    \n    if(hit(r, t_min, closest_so_far, temp_rec, mat_3)) {\n        hit_anything = true;\n        closest_so_far = temp_rec.t;\n        rec = temp_rec;\n    }\n\n    return hit_anything;\n}\n\n// Get color from ray-trace\nvec3 ray_color(in ray r) \n{\n    // initialize the hit record and base color of image\n    hit_rec rec;\n    vec3 res = vec3(1.0);\n    \n    // Recursive alternative from book\n    for(int i = 0; i < MAX_RECURSION; ++i) {\n        if(world(r, EPSILON, MAX_FLOAT, rec)) {\n        \n            ray scattered;\n            vec3 atten;\n            \n            if(scatter(r, rec, atten, scattered)) {\n                res *= atten;\n                r = scattered;\n            } else {\n                return vec3(0.0);\n            }\n            \n        } else {\n            // If no hit from scatter, just color sky.\n            float t = .5*r.d.y + .5;\n            res *= mix(vec3(1),vec3(.5,.7,1), t);\n            return res;\n        }\n    }\n    // if not hit at all, color black.\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool change_resolution = iFrame == 0;;\n    \n    // Grab resolution from data pixel at 0,0\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    // If the resolution has changed, will need to resample\n    if(data.w != iResolution.x)\n        change_resolution = true;\n    \n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // If pixel at 0,0 record the current resolution\n        fragColor = vec4(vec3(0.0), iResolution.x);\n        \n    } else {\n        if (abs(data.xy) == abs(iResolution.xy)) {\n            change_resolution = true;\n        }\n\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Initializing random seed\n        init_rand(uv, iTime);\n\n        // Camera values\n        vec3 lookfrom = vec3(13.0, 2.0, 3.0);\n        vec3 lookat = vec3(0.0, 0.0, 0.0);\n        vec3 vup = vec3(0.0, 1.0, 0.0);\n        float dist_to_focus = 10.0;\n        float aperature = 0.1;\n\n        // Build camera from values\n        camera cam = get_cam(lookfrom, lookat, vup, 20.0, iResolution.x/iResolution.y, aperature, dist_to_focus);\n\n        // Render\n        vec3 col = vec3(0.0);\n\n        // AA sampling from book, set to 1 to allow averaging in the image buffer. Plan is to use this for a real time sampling method.\n        for(int s = 0; s < SAMPLES; ++s) {\n            float u = float(fragCoord.x + rand1(g_seed)) / (iResolution.x - 1.0);\n            float v = float(fragCoord.y + rand1(g_seed)) / (iResolution.y - 1.0);\n            ray r = cam_get_ray(u, v, cam);\n            col += ray_color(r);\n        }\n\n        // Averaging colors\n        col = col/float(SAMPLES);\n\n        if(change_resolution) {\n            fragColor = vec4(col, 1.0);  \n        } else {\n            // Combine with previous image\n            fragColor = vec4(col, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}