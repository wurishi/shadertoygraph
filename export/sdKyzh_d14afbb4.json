{"ver":"0.1","info":{"id":"sdKyzh","date":"1654446693","viewed":362,"name":"[FieldFX Shader Jam] Vorocracks","username":"MonsieurSoleil","description":"Result got by playing with FabriceNeyret vorocracks and iq voronoi.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["jam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n/*\n\nResult mostly got by playing with https://www.shadertoy.com/view/Xd3fRN\nVorocracks\nand https://www.shadertoy.com/view/MsXGzM\nVoronoi\n\n*/\n\nstruct Matter\n{\n    float m;\n    int type;\n    bool reflected;\n    float glow;\n    bool hit;\n    vec3 posHit;\n    float voroval;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 t;\n    vec3 p;\n    vec3 dir;\n    float dist;\n    vec3 hitloc;\n};\n\nstruct Light\n{\n    vec3 liPos;\n    vec3 liDir;\n    float shad;\n    float liGlow;\n};\n\nstruct Res\n{\n    vec3 skyColor;\n    vec3 fogGlow;\n    vec3 glowCol;\n    vec3 color;\n};\n\nMatter mat;\nRay ray;\nLight li;\nRes res;\n\n#define BPM iTime/60.0 * 120.0\n\n#define mod01 mod(floor(BPM*2.0), 4.0)\n#define mod02 mod(floor(BPM*0.5), 4.0)\n#define mod03 mod(floor(BPM*0.25), 4.0)\n\n#define hash22(p)  fract( 18.5453 * sin( p * mat2(127.1,311.7,269.5,183.3)) )\n\n//https://www.shadertoy.com/view/lsVyRy\nfloat CRACK_zebra_scale = 10.0 * 0.15,\n      CRACK_zebra_amp = 5.0 * 0.6;\n\nfloat animation()\n{\n    return 1.0 - pow(abs(sin(iTime*0.1)), 16.2) * 2.0;\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec2 opRepLim( in vec2 p, in float c, in vec2 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n\n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) +1e-30; // <- eps to fix a windows/angle bug\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\n\nint MOD = 1;  // type of Perlin noise\n#define noise22(p) vec2(noise2(p),noise2(p+17.7))\n#define hash21(p) fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123)\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix(hash21(i+vec2(0,0)),hash21(i+vec2(1,0)),f.x),\n                  mix(hash21(i+vec2(0,1)),hash21(i+vec2(1,1)),f.x), f.y);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\nvec3 random3f( vec3 p )\n{\n\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 9; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise22(p);\n\n    return v;\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 kifs(vec3 p, float t, float t3) {\n  \n  vec3 bp=p;\n  float s=0.0 + smoothstep(0.0,1.0,fract(t3))*10.0;\n  for(int i=0; i<3; ++i) {\n    float t2 = t + float(i);\n    p.xz *= rot(t2);\n    p.xy *= rot(t2*0.7);\n    \n    // using smooth minimum on all 3 channels to make a \"smooth\" symmetry\n    p=smin(p, -p, -3.0);\n    //p=abs(p);\n    p-=s;// + sin(t*0.2-length(p)*1.0) * 0.5;\n    s*=0.7;\n  }\n  \n  \n  return p;\n}\n\n\nvoid map(inout Matter ma, vec3 p)\n{\n    float mat01 = 10.0, mat02 = 10.0;\n    \n    vec3 p01 = p, p02 = p;\n    \n    vec3 p3 = kifs(p, iTime, iTime + 1.0);\n      vec3 p4 = kifs(p+vec3(3,2,1), iTime, iTime + 1.0);\n      \n      p.xz *= rot(length(p) * 0.75 - sin(mod03) + iTime * 0.15);\n    \n  //p.xz *= rot(length(p) * 0.05);\n   // p.xy*= rot(p.y*0.25);\n    p01.xy = opRepLim(p01.xy, 3.05 - sin(iTime), vec2(5.0));\n  \n    //https://www.shadertoy.com/view/lsVyRy\n    p02.xy = fbm22(p02.xy * CRACK_zebra_scale) / CRACK_zebra_scale / CRACK_zebra_amp;\n    \n    p.x += sin(p.z*5.9)*0.05 + mod02;\n    mat01 = sphere(p + vec3(0.0), 3.0);\n   \n   float d1 = length(p3)-1.5;\n       mat01 = max(d1, mat01);\n  \n    p.y += 0.01 + iTime * 0.1;\n   vec3 v = voronoi((0.75)*p + p02 + iTime * 0.25 + mod02);\n    vec3 v02 = voronoi((0.25)*p + p02 + iTime * 0.1);\n\n    float f = clamp( 5.5*(v.y-v.x), 0.0, 1.0 );\n    float f02 = clamp( 5.5*(v02.y-v02.x), 0.0, 1.0 );\n   mat01 += f * (0.05  + abs(cos(iTime * 0.2)) * 1.0)+ (f02 * 3.55 - abs(sin(iTime * 0.1))*3.0);\n    \n    ma.voroval = v.y * 1.0 + v02.y * 5.0;\n  \n    \n    ma.glow += pow(0.1/(0.05+abs(clamp(mat01, 0.00001, 100.0))), 20.0 * 0.3);\n\n    ma.m = mat01;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n\n    res.glowCol = vec3(0.0);\n    mat.hit = false;\n    \n    ray.o = vec3(1.0 * cos(iTime * 0.1), 10.0 * 0.9, 2.0 * 0.75 * sin(iTime * 0.2)), ray.t = vec3(0.0);\n    vec3 fr = normalize(ray.t-ray.o);\n    vec3 ri = normalize(cross( fr, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(ri ,fr));\n    ray.dir = normalize(fr + uv.x * ri + uv.y * up);\n    ray.p = ray.o + ray.dir * 0.25;\n    \n    for(int i = 0; i < 100; i++)\n    {\n        map(mat, ray.p);\n        \n       \n        \n        res.glowCol += 0.000005 * mat.glow * mat.voroval;\n        \n        if(mat.m < 0.001)\n        {\n            \n            if(!mat.hit)\n            {\n                mat.hit = true;\n                mat.posHit = ray.p;\n                //break;\n            }\n            mat.m =10.0 * 0.1;\n            //\n        }\n       \n       ray.p += ray.dir * mat.m * 1.0 * 0.05;\n    }\n    res.glowCol *= smoothstep(0.0,0.01,pow(length(uv), 0.8)-0.25);\n    res.glowCol += max(vec3(0),res.glowCol.yzx-1.0);\n  res.glowCol += max(vec3(0),res.glowCol.zxy-1.0);\n  \n  //col=smoothstep(0,1,col);\n  res.glowCol=1.0-exp(-res.glowCol);\n  res.glowCol=pow(res.glowCol, vec3(1.0));\n    \n\tfragColor = vec4(res.glowCol,1.0);\n}","name":"Image","description":"","type":"image"}]}