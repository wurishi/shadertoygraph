{"ver":"0.1","info":{"id":"wdScWw","date":"1586737894","viewed":384,"name":"Twitch: CupWorld(tm)","username":"blackle","description":"live coded on twitch in 1 hour. https://www.twitch.tv/videos/590568063\n\ncan you survive the incessant clanging in cupworld?","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["terrain","cups","livecode","coffeecup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a, b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a, b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a);int y = FK(b);\n  return float((x*x-y)*(y*y+x)-y)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 idglob;\nfloat hsglob;\nint mat;\n\nfloat hillheight(vec2 p) {\n  float hillscale = 0.5;\n  return cos(dot(p.xy*hillscale, vec2(0.05,0.02)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.01,0.03)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.02,0.05)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.08,0.05)))*2.5;\n}\n\nfloat scene(vec3 p) {\n  p.z += hillheight(p.xy);\n  float fl = p.z;\n\n  float scale = 10.;\n  vec2 id = floor(p.xy/scale);\n  idglob = idglob;\n  p.xy = (fract(p.xy/scale)-0.5)*scale;\n\n  \n  float seed = hash(id.x, id.y);\n  float h1 = hash(seed, seed);\n  float h2 = hash(h1, seed);\n  float h3 = hash(h2, seed);\n  float h4 = hash(h3, seed);\n  float h5 = hash(h4, seed);\n  float h6 = hash(h5, seed);\n  float arcx = fract(iTime+h6*5.);\n  p.z -= arcx*(1.-arcx)*10.;\n  hsglob = hash(h5, h5);\n  vec3 ax = normalize(tan(vec3(h1, h2, h3)));\n  vec3 off = vec3(0, 0, 1.2);\n  p -= off;\n  p = erot(p, ax, h4*100. + iTime);\n  \n  p = erot(p, vec3(0,0,1), h5*100.);\n  p.x += asin(sin(iTime*0.5*acos(-1.)));\n  p += off;\n  \n  float sphere = length(p.xy)-1.;\n  float crds = linedist(vec2(sphere, p.z), vec2(0,2.2), vec2(0,0))/sqrt(2.);\n  float bottom = linedist(vec2(length(p.xy), p.z), vec2(-0.5,0), vec2(1.,0))/sqrt(2.);\n  \n  float handle_skel = linedist(vec2(max(p.y,1.3), p.z), vec2(1.3,1.4), vec2(1.3,0.9))-0.3;\n  float handle = linedist(vec2(p.x, handle_skel), vec2(-0.2, 0.), vec2(0.2, 0.))/sqrt(2.);\n  handle = max(1.-p.y, handle);\n  float cup = 0.9*min(crds, min(bottom,handle))-0.05;\n  mat = 0;\n  if (fl < cup) {\n    mat = 1;\n    return fl;\n  }\n  return cup;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n#define ITERCOUNT 500\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n  vec3 cam =normalize(vec3(1,uv));\n  vec3 init = vec3(0,0,10);\n  float rot = 0.1;\n  float zrot = cos(iTime)*0.4-0.5;\n  cam = erot(cam, vec3(0,1,0), rot);\n  init = erot(init, vec3(0,1,0), rot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  init += fract(iTime/100.)*2000.*vec3(1,1,0);\n  init.z -= hillheight(init.xy) + sin(iTime)*5.;\n  vec3 p = init;\n  bool hit = false;\n  int i;\n  for (i = 0; i < ITERCOUNT && !hit; i++) {\n    float dist = scene(p);\n    hit = hit || dist*dist < 1e-6;\n    p += cam*dist;\n  }\n  float perc = float(i)/float(ITERCOUNT);\n  \n  vec3 idloc = idglob;\n  float hsloc = hsglob;\n  int matloc = mat;\n  \n  float fog = pow(exp(-distance(init, p)*0.05), .05);\n \n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float ao = sqrt(sqrt(scene(p+n*0.5)+0.5));\n  \n  vec3 col = pow(vec3(0.2,0.1,0.05), vec3(2));\n  col = abs(erot(col,vec3(1,0,0), hsloc*400.));\n  if (matloc == 1) {\n    col = abs(erot(col,vec3(0,1,0), hsloc*900.));\n  } else {\n    col = abs(erot(col,vec3(0,1,0), hsloc*1800.));\n  }\n  float factor = ao*length(sin(r*3.)*0.5+0.5)/sqrt(3.);\n  vec3 brass = mix(col, col*10., factor) + pow(factor, 7.);\n  vec3 bgcol = mix(vec3(0.6,0.3,0.8), vec3(0.3,0.6,.9), smoothstep(0., 1., uv.y+0.5));\n  \n  fragColor.xyz = hit ? mix(bgcol, brass, 1.-perc) : bgcol;\n  fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x,uv.y),iTime)*0.02;\n}\n","name":"Image","description":"","type":"image"}]}