{"ver":"0.1","info":{"id":"4sVSWh","date":"1464363051","viewed":598,"name":"Mesh tests","username":"TambakoJaguar","description":"I tried to procedurally transform a surface to a mesh, here for example a vase, but it could be anything. You can change the switches smooth_mesh and golden_mesh, or other ones. You can rotate the object with your mouse. Please tell me what you think!","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","wireframe","tests","reflections","complex","mesh","gold","vase","wire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Mesh tests\" by Emmanuel Keller aka Tambako - May 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n//#define ambocc\n//#define antialias\n\n//#define cut_mesh;\n#define smooth_mesh\n#define golden_mesh\n\n#define show_mesh\n#define show_inside\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n    \n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define MESH_OBJ       1\n\nLamp lamps[3];\n\n// Campera options\nvec3 campos = vec3(0., 0., 11.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 4.7;\nfloat angle = 0.;\nfloat angle2 = 0.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.2;\n\n// Color options\nconst vec3 insideColor = vec3(0.7);\nconst vec3 meshColor = vec3(0.93, 0.84, 0.41);\nconst vec3 meshColor_v = vec3(1., 0.3, 0.3);\nconst vec3 meshColor_h = vec3(0.3, 1., 0.3);\nconst vec3 meshColor_d1 = vec3(0.3, 0.3, 1.);\nconst vec3 meshColor_d2 = vec3(1., 1., 0.3);\n\n// Shading options\nconst float specint = 0.4;\nconst float specshin  = 25.;\nconst float aoint = 0.4;\n\n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 30.;\nconst int nbref = 3;\nconst float mesh_ior = 1.7;\nconst float mesh_gref = 0.78;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 3;\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-1.5, 3., 6.), vec3(1., 1., 1.), 1.5, 0.01);\n    lamps[1] = Lamp(vec3(5., -2., 1.), vec3(0.75, 0.85, 1.), 1.3, 0.01);\n    lamps[2] = Lamp(vec3(-3., 5., -5.), vec3(1., 0.6, 0.5), 1.0, 0.01);\n}\n\n// From www.shadertoy.com/view/4s3XD2\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// 3D hash function\nvec3 hash3( vec3 n ){\n\treturn fract(vec3(sin(n.x)*3538.5453, sin(n.y)*2753.8256, sin(n.z)*5296.3728));\n}\n\nconst float mt = 0.13;\n#ifdef smooth_mesh\nconst float mb = 0.88;\n#else\nconst float mb = 0.33;\n#endif\nconst float mf0 = 0.478;\nconst float mf = mf0*7.;\nconst float mp = mf0*8.;\nconst float ms = 0.31;\nconst float mpow = 0.5;\nconst float mdo = 0.14;\n\nfloat map_mesh(vec3 pos, int type)\n{\n    float a = atan(pos.x, pos.z);\n\n    float mfct = 0.;\n    if (type==0)\n       mfct = 0.47;\n    if (type==1)\n       mfct = 2.*mf*pos.y;\n    if (type==2)\n       mfct = mp*a + mf*pos.y;\n    if (type==3)\n       mfct = -mp*a + mf*pos.y;\n    if (type==4)\n       mfct = 2.*mp*a;\n    if (type==5)\n       mfct = 0.55;\n    \n    if (type>0 && type<5)\n    {\n       mfct = 2.*abs(fract(mfct) - 0.5);\n       mfct-= pow(mb, mpow);\n    }\n    \n    float sc = (0.45 + 0.12*pos.y)*sin(pos.y*2.);\n    float bd = pow(smoothstep(-1.82, -1.3, pos.y), 0.2) - (type==0?mdo:0.);\n    \n    float df1 = abs(length(pos.xz) - bd + sc) - mt*sign(mfct)*(pow(abs(mfct), mpow)) + 0.07;\n    float df2 = length(pos.xz) - bd + sc - mt*sign(mfct)*(pow(abs(mfct), mpow));\n    float df = mix(df2, df1, smoothstep(-1.85, -1.53, pos.y));\n    \n    return df;\n}\n\nvec2 map(vec3 pos)\n{\n    pos = rotateVec2(pos);\n\n    #ifdef show_inside\n    float mesh_i = map_mesh(pos, 0);\n    #else\n    float mesh_i = 10.;\n    #endif\n    \n    #ifdef show_mesh\n    float mesh_h = map_mesh(pos, 1);\n    float mesh_v = map_mesh(pos, 4);\n    float mesh_d1 = map_mesh(pos, 2);\n    float mesh_d2 = map_mesh(pos, 3);\n    float mesh_0 = map_mesh(pos, 5);\n    \n    #ifdef smooth_mesh\n    float mesh = SmoothMin(mesh_d1, mesh_d2, ms);\n    mesh = SmoothMin(mesh, mesh_h, ms);\n    mesh = SmoothMin(mesh, mesh_v, ms);\n    mesh = SmoothMax(mesh, mesh_0, 0.03);\n    #else\n    float mesh = min(mesh_d1, mesh_d2);\n    mesh = min(mesh, mesh_h);\n    mesh = min(mesh, mesh_v);\n    #endif\n    #else\n    float mesh = 10.;\n    #endif\n   \n    mesh = min(mesh, mesh_i); \n    mesh = max(mesh, abs(pos.y) - 1.8);\n    #ifdef cut_mesh\n    mesh = max(mesh, pos.x);\n    #endif\n    vec2 res = vec2(mesh, MESH_OBJ);\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.01;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*(0.21 + 0.005*float(i));\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    //return vec3(0.5*ray.y);\n    return 0.1 + 1.2*texture(iChannel0, ray).rgb;\n}\n\nconst float cd = 0.03;\nbool isMesh(vec3 pos)\n{\n    float mesh_i = map_mesh(pos, 0);  \n    return mesh_i>0.03;\n}\nvec3 getMeshColor(vec3 pos)\n{\n    pos = rotateVec2(pos);\n    #ifdef golden_mesh\n    vec3 col_e = meshColor;\n    #else\n    float mesh_h = map_mesh(pos, 1);\n    float mesh_v = map_mesh(pos, 4);\n    float mesh_d1 = map_mesh(pos, 2);\n    float mesh_d2 = map_mesh(pos, 3);\n\n    vec3 col_e = mix(meshColor_h, meshColor_v, smoothstep(-cd, cd, mesh_h - min(min(mesh_v, mesh_d1), mesh_d2)));\n    col_e = mix(meshColor_d1, col_e, smoothstep(-cd, cd, mesh_d1 - min(min(mesh_h, mesh_v), mesh_d2)));\n    col_e = mix(meshColor_d2, col_e, smoothstep(-cd, cd, mesh_d2 - min(min(mesh_h, mesh_v), mesh_d1)));\n    #endif\n    vec3 col_i = insideColor;\n    \n    return isMesh(pos)?col_e:col_i;\n}\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   return objnr==MESH_OBJ?getMeshColor(pos):sky_color(ray);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<8; i++)\n    {\n        float hr = 0.03 + 0.5*float(i)/9.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.9;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1.0, dnp);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n        //col = vec3(calcAO(pos, norm));\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    vec3 refray;\n    int oObjNr = traceinf.objnr;\n\n    for (int i=0; i<nbref; i++)\n    {\n        #ifdef reflections\n        if (traceinf.objnr!=SKY_OBJ)\n        {\n            refray = reflect(ray, traceinf.norm);\n\n            RenderData traceinf_ref = trace0(traceinf.pos, refray, 20.);\n            bool bIsMesh;\n            #ifdef golden_mesh\n            bIsMesh = isMesh(rotateVec2(traceinf.pos));\n            float rf = bIsMesh?mesh_gref:fresnel(ray, traceinf.norm, mesh_ior);\n            #else\n            bIsMesh = false;\n            float rf = fresnel(ray, traceinf.norm, mesh_ior);\n            #endif\n\n            col = mix(col, (bIsMesh?col:vec3(1.))*traceinf_ref.col, rf);\n        }\n        #endif\n\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            col+= sky_color(ray);\n            break;\n        }\n        oObjNr = traceinf.objnr;\n    }\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    angle = 2.*pi*(iMouse.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse.y/iResolution.y - 0.5);\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}