{"ver":"0.1","info":{"id":"csSSW3","date":"1671405913","viewed":112,"name":"Compactification","username":"Langwedocjusz","description":"Homotopy between a plane and its image under stereographic projection (a punctured sphere).","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Also see defines on top of Buffer A before uncommenting\n//#define SHOW_2D_VERSION\n\n#define PI 3.1415926535\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float INV_PI = 1.0/3.1415926535;\n\nfloat Isolines(in float x)\n{\n    float scale = 20.0;//iTime;\n    x = mod(scale*x, 1.0);\n    x = abs(0.5-x);\n    x = smoothstep(0.0, 0.05, x);\n    return x;\n}\n\nfloat Grid(vec2 q)\n{   \n    float grid_grey = Isolines(q.x)\n                    * Isolines(q.y);\n    grid_grey = saturate(0.5+grid_grey);\n    \n    float grid_black = Isolines(0.2*q.x)\n                     * Isolines(0.2*q.y);\n    \n    return min(grid_black, grid_grey);\n}\n\nvec2 getCoords(vec3 p)\n{\n    float phi = atan(p.x, p.z);\n    float theta = acos(dot(normalize(p), vec3(0.0, 1.0, 0.0)));\n    return vec2(phi, theta);\n}\n\nvec2 Homotopy2d(vec2 p, float t)\n{\n    //This map sends points from the unit circle to the x-axis\n    //It can be obtained by considering a complex homographic function\n    //which fixes {-1, 1}, sends i to 0 and -i to infinity\n    //It is then interpreted as a function from R^2 to R^2\n    float A = 1.0/(p.x*p.x + (1.0+p.y)*(1.0+p.y));\n    \n    vec2 q = A*vec2(2.0*p.x, dot(p,p)-1.0);\n\n    //Linearly interpolate\n    return (1.0-t)*p + t*q;\n}\n\nvec3 Homotopy(vec3 p, float t)\n{\n    //Cylindrical coordinates\n    float h = p.y;\n    float r = length(p.xz);\n    float phi = atan(p.z, p.x);\n    \n    //Transform each half-plane\n    vec2 q = Homotopy2d(vec2(r, h), t);\n    \n    r = q.x;\n    h = q.y;\n    \n    //Go back to rectangular\n    return vec3(r*cos(phi), h, r*sin(phi));\n}\n\nfloat sdPlane(vec3 p)\n{\n    //Usual sdf for an upwards facing, horizontal plane y=0\n    return p.y;\n}\n\nfloat Map(vec3 p)\n{\n    float t = mod(0.1*iTime, 1.0);\n    \n    //Deforming plane sdf through our homotopy\n    vec3 q = Homotopy(p, t);\n    float sd = sdPlane(q);\n    \n    return sd;\n}\n\n#define MAX_MARCH_STEPS 128\n#define MAX_MARCH_DIST 10.0\n#define MIN_MARCH_DIST 0.0001\n\n//Usual sdf raymarching\nbool Raymarch(vec3 org, vec3 dir, inout float t)\n{\n    const float L = 2.0;\n\n    t = 0.0;\n    \n    for (int i=0; i<MAX_MARCH_STEPS; i++)\n    {\n        vec3 p = org + t*dir;\n        float sd = Map(p);\n        if (abs(sd) < MIN_MARCH_DIST)\n        {\n            //Only draw result inside a cube\n            if (abs(p.x)<L && abs(p.y)<L && abs(p.z)<L)\n                return true;\n        }\n        else if (t > MAX_MARCH_DIST) break;\n        t += sd;\n    }\n    \n    return false;\n}\n\nvec3 Norm(vec3 p)\n{\n    vec2 h = vec2(0.0, 0.0001);\n    return normalize(vec3(\n        Map(p+h.yxx) - Map(p-h.yxx),\n        Map(p+h.xyx) - Map(p-h.xyx),\n        Map(p+h.xxy) - Map(p-h.xxy)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 ts = fragCoord/iResolution.xy;\n    \n    #ifdef SHOW_2D_VERSION\n    vec3 col = texture(iChannel0, ts).rgb;\n    #else\n    const float R = 4.0;\n    float phi = 0.33;\n    \n    vec3 org = vec3(0.0, R*sin(phi), -R*cos(phi));\n    vec3 dir = normalize(vec3(uv, 2.5));\n    \n    mat2 rot1, rot2;\n    \n    {\n        float c = cos(phi), s = sin(phi);\n        rot1 = mat2(c, s, -s, c);\n    }\n    \n    {\n        float c = cos(0.25*iTime), s = sin(0.25*iTime);\n        rot2 = mat2(c, s, -s, c);\n    }\n    \n    org.xz = rot2*org.xz;\n    \n    dir.yz = rot1*dir.yz; \n    dir.xz = rot2*dir.xz;\n    \n    vec3 col = texture(iChannel1, dir).rgb;\n    \n    float dist = 0.0;\n    \n    if (Raymarch(org, dir, dist))\n    {\n        vec3 p = org+dist*dir;\n        vec2 coords = getCoords(p);\n        float grid = Grid(coords);\n        \n        vec3 norm = Norm(p);\n        vec3 ldir = normalize(vec3(1.0, 1.0, -1.0));\n        float diff = saturate(dot(ldir, norm));\n        diff = 0.2 + 0.8*diff;\n        \n        col = vec3(grid*diff);\n    }\n    #endif\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//To prevent it from doing unnecessary work\n#define DO_NOTHING\n\n//Actual variants\n//#define CONFORMAL_RESCALING\n//#define EDGE_ONLY\n\nvec3 ColorMap(in float x)\n{\n    x *= 1.5;\n    float lorentz = 1.0 - 0.8/(1.0+x*x);\n    \n    vec3 base_col = (x < 0.0) \n                  ? vec3(lorentz, 0.0, 0.0)\n                  : vec3(0.0, 0.0, lorentz);\n    \n    float isolines = sin(30.0*x);\n    isolines = smoothstep(0.95, 1.0, isolines);\n    isolines = 1.0 - isolines;\n    \n    return isolines*base_col;\n}\n\nvec2 Homotopy(vec2 p, float t) \n{\n    #ifdef CONFORMAL_RESCALING\n    float A = 1.0;\n    #else\n    float A = 1.0/(p.x*p.x + (1.0+p.y)*(1.0+p.y));\n    #endif\n    \n    vec2 q = A*vec2(2.0*p.x, dot(p,p) - 1.0);\n\n    return (1.0-t)*p + t*q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef DO_NOTHING\n    fragColor = vec4(vec3(0.0), 1.0);\n    return;\n    #endif\n\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n    \n    \n    float t = mod(0.125*iTime, 1.0);\n    \n    vec2 p = Homotopy(uv, t);\n    \n    float f = p.y;\n    \n    #ifdef EDGE_ONLY\n    float border = abs(f);\n    border = smoothstep(0.0, 0.01, border);\n    vec3 col = vec3(border);\n    #else\n    vec3 col = ColorMap(f);\n    #endif\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}