{"ver":"0.1","info":{"id":"MlBGDw","date":"1429428162","viewed":1457,"name":"Hydrogen: 1s/2p/3d transition","username":"indutny","description":"Transition between 1s, 2p, and 3d electron wave functions in a hydrogen atom.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["wavefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\n#define SCALE 26.0\n\n#define Z_FROM -2.0\n#define Z_TO 2.0\n#define Z_STEP 0.1\n\n#define A0 1.0\n#define E1 1.0\n#define E_1s E1\n#define E_2p (E1 / 4.0)\n#define E_3d (E1 / 9.0)\n\n#define PI 3.141592653589793\n#define R_A_PI_3 0.5641895835477563\n\nvoid im_exp(float amp, float phase, out vec2 im) {\n  im.x = cos(phase) * amp;\n  im.y = sin(phase) * amp;\n}\n\n\nvoid wave_1s(vec3 pos, float t, out vec2 im) {\n  float amp = R_A_PI_3 * exp(-pos.x / A0);\n  float phase = E_1s * t;\n\n  im_exp(amp, phase, im);\n}\n\n\nvoid wave_2p(vec3 pos, float t, out vec2 im) {\n  float amp = 1.0 / (sqrt(2.0) * 4.0 * A0);\n  amp *= R_A_PI_3 * exp(-pos.x / (2.0 * A0));\n  amp *= pos.x * cos(pos.y);\n\n  float phase = E_2p * t;\n\n  im_exp(amp, phase, im);\n}\n\n\nvoid wave_3d(vec3 pos, float t, out vec2 im) {\n  float amp = 1.0 / (sqrt(6.0) * 81.0 * A0 * A0);\n  amp *= R_A_PI_3 * exp(-pos.x / (3.0 * A0));\n  amp *= pos.x * pos.x;\n  amp *= 3.0 * cos(pos.y) * cos(pos.y) - 1.0;\n\n  float phase = E_3d * t;\n\n  im_exp(amp, phase, im);\n}\n\n\nvoid draw(vec3 pos, float t, out vec2 i) {\n  vec2 w1;\n  wave_1s(pos, t, w1);\n\n  vec2 w2;\n  wave_2p(pos, t, w2);\n\n  vec2 w3;\n  wave_3d(pos, t, w3);\n\n  float f = time / 1.5;\n  float trans = max(cos(f), 0.0);\n\n  float c1 = trans * cos(f);\n  float c2 = sin(f);\n  float c3 = (1.0 - trans) * cos(f);\n\n  w1 *= c1;\n  w2 *= c2;\n  w3 *= c3;\n\n  i = w1 + w2 + w3;\n  i.x *= i.x;\n  i.y *= i.y;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float dim = min(resolution.x, resolution.y);\n  vec2 pos = fragCoord.xy / dim;\n  pos.x -= resolution.x / (2.0 * dim);\n  pos.y -= resolution.y / (2.0 * dim);\n\n  float yz_ang = PI/2.0 + time * 0.6;\n  float xz_ang = PI/2.0 + time * 0.33;\n\n  mat3 rot_yz = mat3(\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, cos(yz_ang), sin(yz_ang)),\n    vec3(0.0, -sin(yz_ang), cos(yz_ang))\n  );\n  mat3 rot_xz = mat3(\n    vec3(cos(xz_ang), 0.0, sin(xz_ang)),\n    vec3(0.0, 1.0, 0.0),\n    vec3(-sin(xz_ang), 0.0, cos(xz_ang))\n  );\n  mat3 rot = rot_yz * rot_xz;\n\n  vec2 intensity = vec2(0.0, 0.0);\n  for (float z = Z_FROM; z <= Z_TO; z += Z_STEP) {\n    vec3 cart = vec3(pos, z);\n\n    cart *= SCALE;\n    cart *= rot;\n\n    vec3 sph;\n    sph.x = sqrt(cart.x * cart.x + cart.y * cart.y + cart.z * cart.z),\n    sph.y = acos(cart.z / sph.x);\n    sph.z = atan(cart.y / cart.x);\n\n    vec2 i;\n    draw(sph, time / E1 * 30.0, i);\n\n    intensity += i * Z_STEP / (Z_TO - Z_FROM);\n  }\n\n  // Normalize intensity\n  intensity /= 0.0001;\n\n  vec3 total = vec3(intensity.x + intensity.y);\n  vec3 hue = vec3(intensity, 0.0);\n  fragColor = vec4((total + hue * 0.23) / 1.23, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}