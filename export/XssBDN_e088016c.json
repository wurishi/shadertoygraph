{"ver":"0.1","info":{"id":"XssBDN","date":"1496298319","viewed":192,"name":"pt-4","username":"wuerzig","description":"cornell box path tracing experiment","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pathtracing","cornell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// enable the following line\n// to disable animation and \n// converge a single frame\n// change the same define in \"Buf A\" too\n\n//#define SUPERPRETTY 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    if (iTime > 3.)\n    \tcol /= float(iFrame-100);\n\n    \n\tcol = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// enable the following line\n// to disable animation and \n// converge a single frame\n// change the same define in \"Image\" too\n\n//#define SUPERPRETTY 1\n\n#define EPSILON 0.0005\n#define NUMSAMPLES 16\n#define NUMSAMPLES_F 16.0\n#define BOUNCES 4\n#define BOUNCES_F 4.0\n\nvec3 sunDir = vec3(10.0, 10.0, -10.0);\nvec3 sunColor = vec3(1.0, 1.0, 1.0);\nvec3 skyColor = vec3(0.0, 0.0, 0.0);\n\n// stolen from https://thebookofshaders.com/12/?lan=de\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec2 random2f(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat sdDisplace(vec3 p) {\n    return 0.3*sin(20.0*p.x)+0.3*sin(10.0*p.y)+0.3*sin(10.0+p.z);\n}\n\nfloat sdPlaneZ(vec3 p) {\n\treturn abs(p.z);\n}\n\nfloat sdPlaneY(vec3 p) {\n\treturn abs(p.y);\n}\n\nfloat sdPlaneX(vec3 p) {\n\treturn abs(p.x);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdWobblySphere(vec3 p, float s) {\n    return sdSphere(p,s)+sdDisplace(p)*0.1;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n#define MAT_NOTHING -1\n#define MAT_CHECKER 0\n#define MAT_DIFF 1\n#define MAT_SPEC 2\n\nstruct Material {\n\tvec3 col;\n    vec3 emm;\n    int type;\t\t\t// 0..CHECKERBOARD 1..DIFF 2..SPEC\n};\n\nstruct dfObject {\n    float d; // distance\n    Material mat; // material\n};\n\ndfObject dfUnion(dfObject d1, dfObject d2) {\n    if (d1.d < d2.d) {\n        return d1;\n    } else {\n        return d2;\n    }\n}\n\n// stolen from https://www.shadertoy.com/view/lsX3DH\nvec2 rv2;\nvec3 cosWeightedRandomHemisphereDirection2(const vec3 n) {\n\t\n    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));\n\tvec3  vv = cross(uu, n);\t\n    \n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831 * rv2.x); \n\tfloat ry = ra*sin(6.2831 * rv2.x);\n\tfloat rz = sqrt(1.0 - rv2.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n\n    return normalize(rr);\n}\n\n\n\ndfObject map(in vec3 p) {\n    \n    dfObject res;\n    \n    // bottom\n    res = dfObject(\n                    sdPlaneY(p), \n                    Material(vec3(0.), vec3(0.), MAT_CHECKER)\n                );\n    \n    // big sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p-vec3(0.0, 1.0, 0.0), 0.55),\n                        Material(vec3(0.9, 0.7, 0.3), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // shiny sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(1.55, 0.5, 1.0), 0.5),\n                        Material(vec3(1.0), vec3(0.), MAT_SPEC)\n                    )\n                  );\n    \n    // small marble\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(-1.1, 0.2, 0.2), 0.2),\n                        Material(vec3(0.1, 0.17, 0.08), vec3(0.), MAT_SPEC)\n                    )\n                  );\n    \n    \n    // cube\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdBox(p - vec3(-1.5, 0.6, 1.5), vec3(0.4)),\n                        Material(vec3(0.7), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    \n    \n    \n        \n    // right wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneX(p - vec3(-3., 0., 0.)),\n                        Material(vec3(1.0, 0.0, 0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // left wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneX(p - vec3(3., 0., 0.)),\n                        Material(vec3(0.0, 0.0, 1.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    \n    // top wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneY(p - vec3(0.0, 3.0, 0.0)),\n                        Material(vec3(1.0), vec3(40.), MAT_DIFF)\n                    )\n                  );\n    \n    // back wall\n\tres = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneZ(p - vec3(0.0, 0.0, 3.0)),\n                        Material(vec3(1.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    \n    // back wall behind cam\n\tres = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneZ(p - vec3(0.0, 0.0, -3.0)),\n                        Material(vec3(0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    //res = dfUnion(res, vec2(sdTorus(p - vec3(-0.3, 1.8, 0), vec2(0.6, 0.1)), 200.9)); // 30.9\n    \n    // back wall\n    \n    return res;\n}\n\ndfObject march(in vec3 rayStart, in vec3 rayDir) {\n    \n    // Near Clipping\n    float t = 0.01;\n\n    // Far Clipping\n    float tmax= 50.0;\n    \n    Material obj = Material(vec3(0.), vec3(0.), MAT_NOTHING);\n    \n    for (int i = 0; i < 50; i++) {\n    \t\n        float prec = EPSILON*t;\n        \n        // map on Distance Field\n        vec3 p = rayStart + t*rayDir;\n        dfObject res = map(p);\n        \n\n        // If we hit something, or out of far clipping, exit\n        if ((res.d < EPSILON) || (t > tmax))\n        \tbreak;\n       \t\n        t += res.d;\n        obj = res.mat;\n        \n        \n    }\n    if (t > tmax) obj.type = -1;\n    return dfObject(t, obj);\n    \n}\n\n\n// Stolen from https://iquilezles.org\n// Calculate Normal in a Distance Field\nvec3 dfNormal( in vec3 p ) {\n    \n    \n\tvec3 eps = vec3(0.0005, 0.0, 0.0);\n\tvec3 res = vec3(\n\t    map(p+eps.xyy).d - map(p-eps.xyy).d,\n\t    map(p+eps.yxy).d - map(p-eps.yxy).d,\n\t    map(p+eps.yyx).d - map(p-eps.yyx).d);\n\treturn normalize(res);\n\t\n}\n\nmat3 makeCam( in vec3 origin, in vec3 target) {\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 lookVec = normalize(target-origin);\n\tvec3 right = normalize(cross(lookVec, worldUp));\n\tvec3 camUp = normalize(cross(right, lookVec));\n    return mat3(right, camUp, lookVec);\n}\n\nvec3 getObjectColor(in Material obj, in vec3 p) {\n\t\n    if( obj.type == MAT_CHECKER ) {\n\t\t// checkboard pattern\n        float f = mod( floor(p.z) + floor(p.x), 2.0);\n        vec3 col = 0.2 + 0.2 * f * vec3(1.0);\n        return col;\n    } \n    //return vec3(0.9);\n    return obj.col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // 0...fragCoord...iResolution.xy\n    // Texture Sampler 0...uv...1\n    vec3 rayStart;\n    vec3 rayDirection;\n    vec3 camTarget;\n    vec2 point;\n\n    float j_float;\n    \n    vec3 totalEnergy = vec3(0.);\n    vec3 totalColor = vec3(1.);\n    vec3 col, emm;\n    \n    float time = iTime + 5.;\n    float time2 = time;\n    \n//#ifdef SUPERPRETTY\n    if (iTime > 3.)\n    \ttime2 = 8.0;\n//#endif    \n    \n    point = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    float seed = time + (point.x + iResolution.x*point.y) * 1.51269341231;\n\n\n\tcamTarget = vec3(0.0, 1.0, 0.0);\n\n    for ( int i=0; i<NUMSAMPLES; i++) {\n        \n        float i_float = float(i);\n\n        rv2 = random2f(vec2(i_float + time + seed));\n        vec2 point2 = point + rv2/(1.5*iResolution.xy);\n        \n    \trayStart = vec3(-0.5 + 2.5*cos(-0.2*time2), 2.1, 0.5 + 2.5*sin(-0.2*time2));\n    \tmat3 cameraMatrix = makeCam(rayStart, camTarget);\n\n        rayDirection = cameraMatrix * normalize(vec3(point2.xy,3.0 /*fov*/));\n\t\t\n        \n        \n        for (int j=0;j<BOUNCES;j++) {\n            \n            \n            j_float = float(j);\n\n            rv2 = random2f( vec2((rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) ));\n            \n            dfObject res = march(rayStart, rayDirection);\n            float t = res.d;\n            Material obj = res.mat;\n            \n            // Calculate Point of Intersection and normal\n            vec3 intersection = rayStart + t*rayDirection;\n            vec3 normal = dfNormal(intersection);\n        \n        \tif (obj.type >= 0) {\n            \t// we hit something, awesome!\n\t\t\t\tcol = getObjectColor(obj, intersection);\n\t\t\t\temm = obj.emm;\n\n                // Bounce Ray off Surface\n                // material 2...20 is glossy\n                if (obj.type == MAT_SPEC) {\n                    rayDirection = reflect(rayDirection, normal);\n\t                \n    \t            totalEnergy += totalColor * emm;\n                    totalColor *= col;\n                } else {\n                    rayDirection = cosWeightedRandomHemisphereDirection2(normal);\n\n                    totalEnergy += totalColor * emm;// + totalColor * col * e;\n                    totalColor *= col;\n                \n                }\n                \n                // if the material emits light we stop bouncing around\n                if (length(emm)>0.)\n                    break;\n                \n                // get off the surface\n\t\t\t\trayStart = intersection + EPSILON*rayDirection;\n            \t\n            } else {\n                // hit sky\n                totalColor *= skyColor;\n                totalEnergy += skyColor * 100.;\n               \tbreak;\n            }\n\t\t}\n        \n        //totalCol += pathCol;\n    }\n    \n    vec3 pxl = totalEnergy / (NUMSAMPLES_F * (j_float + 1.0));\n   \n    //totalCol /= (NUMSAMPLES_F * (j_float + 1.0));\n    fragColor = vec4(clamp(pxl, 0.0, 1.0), 1.0);\n    \n    // uncomment to accumulate over several frames\n//fdef SUPERPRETTY\n    if (iTime > 3.) {\n    \tcol = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n    \tif( iFrame==0 ) col = vec3(0.0);\n    \tcol += pxl;    \n    \tfragColor = vec4( col, 1.0 );\n    }\n//ndif\n    \n}","name":"Buf A","description":"","type":"buffer"}]}