{"ver":"0.1","info":{"id":"lcX3W7","date":"1703122279","viewed":30,"name":"Mobile Noise","username":"FoxyOfJungle","description":"Noise shader that works on Mobile platforms.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","mobile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*------------------------------------------------------------------------------------------------------------------------------\n    I've been having precision issues with noise on mobile platforms (Android, iOS) for some time now.\n    I tested several of the options available on the internet, and as time went by in the shader, they had the same problem:\n    the generated values started to look weird, as numbers became complex quickly.\n    So I ended up developing a simple noise function that uses an array with random values as a look-up table.\n    I could use a texture directly, but the API I'm using doesn't allow this in Vertex Shader, so I'm sharing my solution here\n    in case anyone needs it. You could pass the array by uniform too, as a last resort.\n    I don't know if this is efficient, but I left it running on my phone for more than one hour and the shader continued to\n    behave the same way. :)\n    I don't plan on using this for a long time, though, but it was the only solution I had.\n------------------------------------------------------------------------------------------------------------------------------*/\n\n// 16x16 noise texture baked\nconst float u_noiseTex[256] = float[](0.90,0.30,0.93,0.55,0.33,0.47,0.63,0.38,0.78,0.19,0.67,0.94,0.40,0.16,0.23,0.97,0.71,0.36,0.50,0.02,0.20,0.94,0.54,0.68,0.35,0.84,0.48,0.56,0.58,0.28,0.52,0.20,0.27,0.99,0.64,0.14,0.83,0.03,0.07,0.15,0.09,0.88,0.46,0.73,0.32,0.09,0.79,0.84,0.63,0.95,0.70,0.71,0.72,0.41,0.73,0.59,0.06,0.70,0.16,0.81,0.14,0.99,0.49,0.05,0.93,0.51,0.48,0.72,0.63,0.46,0.33,0.29,0.80,1.00,0.26,0.65,0.07,0.90,0.98,0.87,0.77,0.87,0.68,0.80,0.43,0.21,0.21,0.11,0.31,0.71,0.29,0.13,0.12,0.10,0.39,0.71,0.70,0.97,0.25,0.01,0.19,0.15,0.32,0.48,0.80,0.26,0.85,0.53,0.62,0.25,0.49,0.95,0.21,0.14,0.31,0.62,0.92,0.86,0.55,0.57,0.33,0.78,0.47,0.17,0.30,0.33,0.40,0.43,0.31,0.54,0.24,0.91,0.45,0.65,0.40,0.07,0.53,0.62,0.25,0.98,0.80,0.62,0.93,0.33,0.99,0.85,0.53,0.62,0.80,0.26,0.13,0.19,0.22,0.94,0.26,0.91,0.38,0.22,0.63,0.83,0.55,0.51,0.33,0.67,0.49,0.64,0.54,0.84,0.94,0.74,0.44,0.94,0.11,0.84,0.97,0.89,0.72,0.33,0.05,0.57,0.56,0.80,0.35,0.16,0.50,0.15,0.82,0.74,0.37,0.07,0.03,0.43,0.02,0.12,0.45,0.10,0.87,0.34,0.73,0.01,0.41,0.62,0.27,0.60,0.37,0.21,0.46,0.46,0.29,0.40,0.89,0.74,0.45,0.83,0.53,0.08,0.07,0.25,0.52,0.30,0.89,0.61,0.40,0.08,0.84,0.94,0.54,0.02,0.18,0.08,0.09,0.09,0.39,0.92,0.92,0.82,0.01,0.57,0.90,0.54,0.99,0.29,0.45,0.17,0.81,0.43,0.96,0.89,0.48,0.89,0.83,0.81,0.93,0.77,0.25,0.98);\n\nfloat noise(vec2 seed) {\n    float u = fract(sin(seed.x+sin(seed.y)*37.27)*10.7);\n    int index = int(256.0 *  u);\n    return u_noiseTex[index];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // RGB Noise\n    vec3 col;\n    /*col.r = noise(fragCoord+10.0);\n    col.g = noise(fragCoord+50.0);\n    col.b = noise(fragCoord+100.0);*/\n    \n    // Grayscale Noise\n    col = vec3(noise(vec2(fragCoord+iTime)));\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}