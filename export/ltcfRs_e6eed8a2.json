{"ver":"0.1","info":{"id":"ltcfRs","date":"1540615627","viewed":68,"name":"BIFURCATE_INTERSECT","username":"cardinalsine","description":"Playing around with the logistic map function.\nhttps://en.wikipedia.org/wiki/Logistic_map\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_t iTime\n#define u_res iResolution\n#define u_mouse iMouse\n\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\nfloat cosNorm(float x) {\n    // cos(x) normalized to be between 0 and 1\n    return 0.5*(1.+cos(x));\n}\n\nfloat cosInterp(float x, float p0, float p1) {\n    return p0+(p1-p0)*0.5*(1.-cos(PI*fract(x)));\n}\n\nfloat logisticMap(float n, float x0, float r){\n\tx0 = clamp(x0, 0., 1.);\n    r = clamp(r,0.,4.);\n    \n    float x = x0;\n    for(float i = 0.; i < n; i++) {\n        x *= r*(1.-x);\n    }\n    return x;\n}\n\nfloat logisticMapInterp(float n, float x0, float r) {\n    return cosInterp(n, logisticMap(n,x0,r), logisticMap(n+1.,x0,r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = abs(-1.+2.*(fragCoord.xy/u_res.xy));//*(u_res.xy/u_res.yy);\n    //vec2 mpos = -1.+2.*u_mouse.xy/u_res.xy;\n    \n    float w_r = exp2(-4.)*PI;\n    float m = 7.;\n\tfloat lMap_xy = floor(0.5+logisticMap(m*uv.x, uv.y, 2.+2.*cosNorm(w_r*u_t)));\n    float lMap_yx = floor(0.5+logisticMap(m*uv.y, uv.x, 2.+2.*cosNorm(w_r*u_t+PI/2.)));\n    float lMap_intersect = lMap_xy*lMap_yx;\n    \n    float steps_x = (1.+1.*floor((uv.x)*m)/(m*m));\n    float colGrad_y = (0.9+0.1*uv.y);\n    float colGrad_x = 1.;\n    \n    vec3 colorOffset = 0.5*steps_x*(lMap_xy*colGrad_y+lMap_yx*colGrad_x)*vec3(0.,0.5,1.);\n\t\n    // constants derived from experimentation - \n    // I used the mouse to find colors I liked and estimated the x and y positions\n    vec3 color = vec3(cos(2.*PI*(-2./3.)*(-0.055+(0.0675*uv.y)+0.75*lMap_intersect+colorOffset)));\n    \n    // invert colors when the pattern repeats\n    float s = mod(floor((w_r/(2.*PI))*u_t+0.5), 2.);\n    color = mix(color, 1.-color, s);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}