{"ver":"0.1","info":{"id":"7lK3RK","date":"1638197893","viewed":88,"name":"Moon Crater","username":"OfficeBatman","description":"Want to make something like https://www.shadertoy.com/view/MlSBDt. WIP","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float collisionEpsilon = .005;\nconst float normalEpsilon = collisionEpsilon;\nconst float materialEpsilon = collisionEpsilon + .005;\nconst float maxDist = 20.;\nconst float nearPlaneDist = .5;\nconst float fov = 0.1*PI;\nconst int maxIter = 100;\n\nconst int SKY_MAT = 1;\nconst int FLOOR_MAT = 2;\nconst int CRATER_MAT = 3;\nconst int CRATERLING_MAT = 4;\n\nconst vec3 craterCenter = vec3(0.1, 0.5, 0);\nconst vec2 craterSize = vec2(2, .33);\nconst vec3 skyColorBase = vec3(0.2, 0.4, 0.7);\nconst vec3 floorColorBase = vec3(0.85);\nconst vec3 floorColorDark = vec3(0.55);\nconst vec3 craterColorBase = vec3(0.25);\n\nvec3 cameraPos() { return\n    vec3(\n        0.,\n        0. + 3. * iMouse.y / iResolution.y,\n        -3. - 3. * iMouse.x / iResolution.x\n    )\n    * rotateY(iTime / 2.);\n}\nvec3 cameraDir() {\n    vec3 target = vec3(0., 0., 2. - 2. * iMouse.x / iResolution.x);\n    return normalize(target - cameraPos());\n}\nvec3 skyColor(vec3 dir) {\n    return mix(vec3(0.1), skyColorBase, clamp(dir.y + 0.1, 0., 1.));\n}\n    \n\nstruct hit {\n    float dist;\n    int material;\n    vec3 point;\n    vec3 dir;\n    vec3 color;\n    int iter;\n};\n\nfloat floorHeight(vec3 p) {\n    float dFloor = p.y;\n    dFloor += .2*(fbm(p.xxz) - .5) + (fbm(p.xxz*0.1 + vec3(12341)) - .5);\n    return dFloor;\n}\n\nvec3 floorColor(vec3 p) {\n    return floorColorDark;\n\n    float a = atan(p.x, p.z);\n    float r2 = p.x*p.x + p.z*p.z;\n    const float R2 = craterSize.x*craterSize.x;\n    \n    vec3 color = floorColorDark;\n    //color = mix(color, floorColorBase, SIN01(20.*a));\n    color = mix(color, floorColorBase, smoothstep(-1., 1., sin(100.*a)));\n    color = mix(color, floorColorDark, smoothstep(R2, 4.*R2, r2));\n    return color;\n}\n\nfloat sdfCrater(vec3 p) {\n    // perfect ball\n    float dBall = sdfSphere(p - craterCenter, craterSize.x);\n    // unperfect it\n    dBall += .1*(fbm(p - vec3(124.551,112.152,41.512))-.5);\n    \n    float dBottom = p.y + craterSize.y;\n    dBottom += .2*(fbm(p.xxz + vec3(151)) - .5);\n\n    float d = maxDist;\n    d = opSmoothUnion(d, dBall, 0.01);\n    d = opSmoothSubtraction(dBottom, d, 0.09);\n    d *= 0.5;\n    return d;\n}\n\nhit scene(vec3 p) {\n    float dFloor = floorHeight(p) * .9;\n    float dCrater = sdfCrater(p);\n    \n    float r2 = p.x*p.x + p.z*p.z;\n    const float R2 = craterSize.x*craterSize.x;\n\n    hit hit;\n    hit.material = SKY_MAT;\n    hit.point = p;\n    hit.color = vec3(0.75);\n    hit.dist = maxDist;\n    hit.dist = min(hit.dist, dFloor);\n    hit.dist = opSmoothSubtraction(dCrater, hit.dist, 0.05);\n    \n    if (abs(dCrater) <= materialEpsilon) {\n        float a = atan(p.x, p.z);\n        a = a + sin(3.5*a) + 2.*sin(a);\n        float ph = .5 * sin(3.*a) + .5;\n        float start = -craterSize.y*(1. + .25*ph);\n        vec3 targetColor = mix(craterColorBase, floorColorBase, r2 / R2);\n        hit.material = CRATER_MAT;\n        hit.color = craterColorBase;\n        hit.color = mix(hit.color, targetColor, 1. * (hit.point.y - start) / -start);\n    } else if (abs(dFloor) <= materialEpsilon) {\n        hit.material = FLOOR_MAT;\n        hit.color = floorColor(p);\n    }\n    \n    return hit;\n}\n\nhit march(vec3 o, vec3 d, int maxI) {\n    hit mp;\n    \n    float l = 0.;\n    \n    int i;\n    for (i = 0; i < maxI; i++) {\n        mp = scene(o + d * l);\n        l += mp.dist;\n        \n        if (abs(mp.dist) < collisionEpsilon || l > maxDist) {\n            break;\n        }\n    }\n    if (i == maxI) mp.material *= -1;\n    \n    mp.dist = clamp(l, 0., maxDist);\n    mp.iter = i;\n    mp.dir = d;\n    return mp;\n}\n\nvec3 normal(vec3 pos)\n{\n\tfloat d = scene(pos).dist;\n\treturn normalize(\n        vec3(\n            scene(pos+vec3(normalEpsilon,0,0)).dist-d,\n            scene(pos+vec3(0,normalEpsilon,0)).dist-d,\n            scene(pos+vec3(0,0,normalEpsilon)).dist-d \n        )\n    );\n}\n\n// parameters should be normalized\nmat3 camera(vec3 forward, vec3 globalUp) {\n    vec3 right = cross(forward, globalUp);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // Raymarch\n    vec3 rayOrigin = cameraPos();\n    vec3 rayDir = cameraDir();\n    rayDir = normalize(camera(rayDir, vec3(0., 1., 0.)) * vec3(uv, 1./fov));\n    hit hit = march(rayOrigin, rayDir, maxIter);\n    \n    // Coloring\n    vec3 col = hit.color;\n    if (hit.material == SKY_MAT) {\n        col = skyColor(hit.dir);\n    } else {\n        // do normal\n        col *= .5 + .5*dot(normal(hit.point), normalize(vec3(.2,1,0)));\n        // ambient occulsion\n        col = mix(col, vec3(0), float(hit.iter) / float(maxIter));\n    } \n    // fog\n    col = mix(col, vec3(0), 0.4*hit.dist / maxDist);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n#define CLAMP01(X) clamp((X), 0., 1.)\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat3 rotateX(float a) {\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\nmat3 rotateY(float a) {\n    return mat3(\n        cos(a), 0., -sin(a),\n        0., 1., 0.,\n        sin(a), 0., cos(a)\n    );\n}\nmat3 rotateZ(float a) {\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\n// Noise functions\n\nfloat hash2d(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise3d(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash2d( ii + vec2(0.0,0.0) );\n\tfloat b = hash2d( ii + vec2(1.0,0.0) );    \n    float c = hash2d( ii + vec2(0.0,1.0) );\n\tfloat d = hash2d( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash2d( ii + vec2(0.0,0.0) );\n\tb = hash2d( ii + vec2(1.0,0.0) );    \n    c = hash2d( ii + vec2(0.0,1.0) );\n\td = hash2d( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<7; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise3d(s * x);\n    }\n    return r;\n}\n\n// Sdf\nfloat sdfSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}","name":"Common","description":"","type":"common"}]}