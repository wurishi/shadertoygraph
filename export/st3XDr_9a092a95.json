{"ver":"0.1","info":{"id":"st3XDr","date":"1639214533","viewed":64,"name":"WaveSurf","username":"csterea","description":"Wave ray tracing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["waveraytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define M_INV_SQRT2 0.7071067811865475244008443621048490\n\n#define SURFACE_WIDTH_XY 40.0f\n#define SURFACE_HEIGHT_Z 1.0f\n\n#define SURFACE_DISPLACEMENT_Z 50.0f\n\n\nmat3 RotX(in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,  -s,\n        0.0,   s,   c);\n}\nmat3 RotY(in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat3(\n    \tc,   0.0,   s,\n        0.0, 1.0, 0.0,\n        -s,  0.0,   c);\n}\nmat3 RotZ(in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat3(\n    \tc,    -s, 0.0,\n    \ts,     c, 0.0,\n    \t0.0, 0.0, 1.0);\n}\n\n// plane = (normal, distToOrigin)\n// Plane from normal, point and additional distance to origin.\nvec4 PlaneFromNormDir(vec3 n, float additionalDist) {\n    return vec4(n, additionalDist);\n}\nfloat DistToPlane(vec3 p, vec4 plane) {\n    return dot(p, plane.xyz) - plane.w;\n}\nfloat RayIntersectPlane(vec3 rayO, vec3 rayD, vec4 plane) \n{\n    float t = dot(rayD, plane.xyz);\n    if(t == 0.0)\n        return 0.0;\n    return (plane.w - dot(plane.xyz, rayO)) / t;\n}\n\nbool RayIntersectBox(\n    vec3 rayO, vec3 rayD, // Normalized ray direction\n    vec3 boxExt,\n    out vec3 out_point1, out vec3 out_point2,\n\tout float out_rayDist1, out float out_rayDist2)\n{\n\tvec3 ox = vec3(1, 0, 0);\n    vec3 oy = vec3(0, 1, 0);\n    vec3 oz = vec3(0, 0, 1);\n        \n    int intersCount = 0;\n    \n    vec4 boxPlanes[6];\n    boxPlanes[0] = PlaneFromNormDir(-ox, boxExt.x);\n    boxPlanes[1] = PlaneFromNormDir(ox, boxExt.x);\n    boxPlanes[2] = PlaneFromNormDir(-oy, boxExt.y);\n    boxPlanes[3] = PlaneFromNormDir(oy, boxExt.y);\n    boxPlanes[4] = PlaneFromNormDir(-oz, boxExt.z); \n    boxPlanes[5] = PlaneFromNormDir(oz, boxExt.z);\n    \n    for(int i=0; i<6; ++i)\n    {\n        vec4 crtPlane = boxPlanes[i];\n        \n        float crtRayDist = RayIntersectPlane(rayO, rayD, crtPlane);\n        vec3 crtIntersPt = rayO + rayD * crtRayDist;\n        \n        bool intersContained = true;\n        for(int j=0; j<6; ++j)\n        {\n            if(i != j && DistToPlane(crtIntersPt, boxPlanes[j]) > 0.0)\n            {\n                intersContained = false;\n                break;\n            }\n        }\n        \n        if(intersContained)\n        {\n            ++intersCount;\n            if(intersCount == 1)\n            {\n                out_rayDist1 = crtRayDist;\n                out_point1 = crtIntersPt;\n            }\n            else \n            {\n                out_rayDist2 = crtRayDist;\n                out_point2 = crtIntersPt;\n                // We reached two intersection points, stop searching.\n                break;\n            }\n        }\n    }\n    \n    return intersCount == 2;\n}\n\nfloat SurfaceZ(float x, float y, float phase)\n{\n    return SURFACE_HEIGHT_Z * sin(phase + sqrt(x*x + y*y));\n}\n\nfloat SurfaceFunc(vec3 v, float phase)\n{\n    return SurfaceZ(v.x, v.y, phase) - v.z;\n}\n\nvec3 SurfaceNormal(vec3 v, float phase)\n{\n    float a2 = v.x*v.x + v.y*v.y;\n    if(a2 == 0.0)\n    {\n        return normalize(vec3(1.0, 1.0, 0.0));\n    }\n    \n    float a = sqrt(a2);\n    float c = cos(phase + a);\n    float d = SURFACE_HEIGHT_Z * c / a;\n    \n    float dzdx = d * v.x;\n    float dzdy = d * v.y;\n    \n    return normalize(vec3(-dzdx, -dzdy, 1.0));\n}\n\nbool RayIntersectSurface(\n    vec3 ray, // Normalized ray direction\n    vec3 surfaceCenter, mat3 surfaceRot, \n    out vec3 out_position, out vec3 out_normal, out vec2 out_uv)\n{\n    // Surface-local ray.\n    vec3 localRay0 = -surfaceRot * surfaceCenter;\n    vec3 localRayD = surfaceRot * ray;\n    \n    vec3 surfaceBoxExt = vec3(SURFACE_WIDTH_XY, SURFACE_WIDTH_XY, SURFACE_HEIGHT_Z);\n    \n    vec3 boxPoint1, boxPoint2;\n    float boxRayDist1, boxRayDist2;\n    if(!RayIntersectBox(\n        localRay0, localRayD, // Normalized ray direction\n        surfaceBoxExt,\n        boxPoint1, boxPoint2,\n        boxRayDist1, boxRayDist2))\n    {\n        return false;\n    }\n    \n    float phase = iTime * 2.0;    \n\n    float zDist1 = SurfaceFunc(boxPoint1, phase);\n    float zDist2 = SurfaceFunc(boxPoint2, phase);\n    \n    float crtRayDist;\n    float crtRayStep;\n    if(boxRayDist1 < boxRayDist2)\n    {\n        crtRayDist = boxRayDist1;\n        crtRayStep = zDist1;\n    }\n    else\n    {\n        crtRayDist = boxRayDist2;\n        crtRayStep = zDist2;\n    }\n    \n    vec3 crtRayPoint;\n\n    const float tol = 0.01;\n    for(int i=0; i<30; ++i)\n    {\n        float nextRayDist = crtRayDist + crtRayStep;\n        crtRayPoint = localRay0 + localRayD * nextRayDist;\n        float crtDeviationZ = SurfaceFunc(crtRayPoint, phase);\n        \n        if(abs(crtDeviationZ) < tol)\n        {\n            break;\n        }\n        \n        if(crtDeviationZ < 0.0f)\n        {\n            crtRayStep *= 0.5f;\n        }\n        else \n        {\n            crtRayStep = crtDeviationZ;\n            crtRayDist = nextRayDist;\n        }\n    }\n    \n    out_position = crtRayPoint * surfaceRot + surfaceCenter;\n    out_normal = SurfaceNormal(crtRayPoint, phase) * surfaceRot;\n    out_uv = 0.1 * vec2(crtRayPoint[0], crtRayPoint[1]);\n    \n    return true;\n}\n\nvec3 GetCombinedNormal(vec3 baseNormal, vec2 uv, sampler2D normalMap, float normalMapIntensity)\n{\n    float normalMapDensity = 2.0;\n    \n    vec2 normalMapValue = texture(normalMap, normalMapDensity * uv).xy;\n    vec2 ldudv = dFdx(normalMapValue) + dFdy(normalMapValue);\n    //vec3 ldudv = vec3(normalMapValue, 0.0);\n\n    vec3 dudv = vec3(ldudv, 0.0) - baseNormal * dot(ldudv, baseNormal.xy);\n    float lenDudv = length(dudv);\n    if(lenDudv != 0.0)\n    \tdudv /= lenDudv;\n    dudv *= length(ldudv);\n    \n    return normalize(baseNormal + normalMapIntensity * dudv);\n}\n\nvec3 GetLightingColor(\n    vec3 matColor, \n    vec3 position, vec3 baseNormal, float normalMapIntensity,\n\tvec2 uv, sampler2D baseTexture, sampler2D normalMap)\n{\n    vec3 lightPos = normalize(vec3(0.0, 0.0, -10.0));\n    \n    vec3 lightDir = normalize(position - lightPos);\n\n    vec3 normal = (normalMapIntensity != 0.0\n        ? GetCombinedNormal(baseNormal, uv, normalMap, normalMapIntensity)\n        : baseNormal);\n\n    float reflection = abs(dot(normal, lightDir));\n\n    // Apply Phong shading of the 3rd degree.\n    reflection *= reflection * reflection;\n    \n    return 0.5 * (matColor + texture(baseTexture, uv).xyz) \n        * reflection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 matColor = vec3(0.99, 0.99, 0.99);    \n  \n    vec3 surfaceCenter = vec3(0, 0, SURFACE_DISPLACEMENT_Z);\n    float surfaceNormalMapIntensity = 1.0;\n    \n    mat3 rot = mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n    vec2 uvm = vec2(\n        1.8 - 4.0 * iMouse.x / iResolution.x,\n        1.8 - 4.0 * iMouse.y / iResolution.y);\n    \n\t// Perform the animations.\n    rot *= RotX(-uvm.y);\n    rot *= RotY(uvm.x);\n\n    // Create a 3D rendering ray from the user point of view to a 3D point containing the current pixel.\n    float aspect = iResolution.x / iResolution.y;\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 renderRayDir = normalize(vec3(\n        aspect * (fragCoord.x/(0.5 * iResolution.x) - 1.0),\n        fragCoord.y/(0.5 * iResolution.y) - 1.0,\n        1.5));\n        \n    // Get the intersection point with the surface.\n    vec3 position, normal;\n    vec2 uv;\n    bool isIntersecting = RayIntersectSurface(\n        renderRayDir, \n        surfaceCenter, rot, \n        position, normal, uv);\n\n    // Get the lighting colors.\n    vec3 col = vec3(0,0,0);\n    if(isIntersecting)\n    {\n        col = GetLightingColor(\n            matColor, \n            position, normal, surfaceNormalMapIntensity, \n            uv, iChannel0, iChannel1);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}