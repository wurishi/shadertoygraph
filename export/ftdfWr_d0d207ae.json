{"ver":"0.1","info":{"id":"ftdfWr","date":"1663008677","viewed":90,"name":"intense sliding color blocks","username":"Michael_White","description":"A techno looking blocks sliding through a frame with lasers and ripples","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// draw components of background\nvec3 drawLaser (vec2 pixel, vec3 color, vec2 startPos, vec2 endPos, float blurScale, float seed)\n{\n    // pixel is in uv format based on screen's resolution\n    // find slope\n    float dx = endPos.x - startPos.x + 0.00001; //avoid divide by 0 error\n    float dy = endPos.y - startPos.y + 0.00001;\n    float lineSlope = dy/dx;\n    // float xdir = abs(dx)/dx; unnecessary\n    // float ydir = abs(dy)/dx; unnecessary\n    \n    // find pixel length from line\n    float lineDistY = abs(((pixel.x - startPos.x) * lineSlope) + startPos.y - pixel.y);\n    float lineDistX = abs(((pixel.y - startPos.y) / lineSlope) + startPos.x - pixel.x);\n    float lineDist = lineDistX * lineDistY / sqrt(lineDistX * lineDistX + lineDistY * lineDistY);\n    \n    vec3 returnColor = color;\n\n    // add randomness for unstable look\n    if (lineDist <= blurScale)\n    {\n        returnColor *= abs(sin(iTime * 1.2 * abs(sin(iTime + seed) * (2.0 + seed)) * (pixel.x + 1.34 * seed) * (pixel.y + 2.09 * seed) * 43296.23));\n        //returnColor *= abs(sin(iTime * pixel.x));\n    }\n\n    // shade based on length from line\n    returnColor *= (1.0 - (pow(lineDist / blurScale, 2.0)));\n\n    return returnColor;\n}\n\n// Used to show colored lasers in background\nvec3 laserAnimation(vec2 uv)\n{\n    float thickNum = sin(iTime) * 0.05;\n    vec3 col = vec3(0.0);\n    \n    // laser timing\n    if (mod(iTime,3.0) < 1.0 || mod(iTime,9.0) < 3.0)\n    {\n        col += drawLaser(uv, vec3(1.0,0.0,0.0), vec2(1.0), vec2(0.5), 0.055 - thickNum, 1.0);\n    }\n    if (mod(iTime,3.0) < 1.0 || (mod(iTime,9.0) > 3.0 && mod(iTime,9.0) < 6.0))\n    {\n        col += drawLaser(uv, vec3(0.0,1.0,0.0), vec2(0.0,1.0), vec2(0.5), 0.055 + thickNum, 0.5);\n    }\n    if (mod(iTime,3.0) < 1.0 || (mod(iTime,9.0) > 6.0 && mod(iTime,9.0) < 9.0))\n    {\n        col += drawLaser(uv, vec3(0.0,0.0,1.0), vec2(0.5,0.0), vec2(0.5), 0.055 - thickNum, 0.3);\n    }\n    if (mod(iTime,9.0) > 7.0 && mod(iTime,9.0) < 9.0)\n    {\n        col += drawLaser(uv, vec3(1.0,1.0,0.0), vec2(0.0,0.5), vec2(0.5), 0.055 + thickNum, 0.7);\n    }\n    if (mod(iTime,9.0) > 1.0 && mod(iTime,9.0) < 3.0)\n    {\n        col += drawLaser(uv, vec3(0.0,1.0,1.0), vec2(0.25,0.0), vec2(0.5), 0.055 + thickNum, 0.8);\n    }\n    if (mod(iTime,9.0) > 4.0 && mod(iTime,9.0) < 6.0)\n    {\n        col += drawLaser(uv, vec3(1.0,0.0,1.0), vec2(0.75,0.0), vec2(0.5), 0.055 - thickNum, 0.2);\n    }\n    return col;\n}\n\n// draw one distortion ripple\nvec2 ripple(float innerR, float outerR, vec2 c, vec2 uv)\n{\n    vec2 offset = vec2(0.0);\n    float dist = length(c - uv);\n    if (dist > innerR && dist < outerR)\n    {\n        vec2 normal = normalize(c - uv); \n        offset += normal * (0.005/(outerR-innerR));\n    }\n    return offset;\n}\n\n// adds ripples on top of image by distorting the uv map\n// returns offset to modify uv by\nvec2 rippleDistort(vec2 uv)\n{\n    vec2 offset = vec2(0.0);\n    \n    offset += ripple(mod(iTime, 7.0) / 4.0, mod(iTime, 7.0) / 3.0, vec2(0.5,0.5), uv);\n    offset += ripple(mod(iTime, 11.0) / 4.0, mod(iTime, 11.0) / 3.0, vec2(0.25,0.75), uv);\n    offset += ripple(mod(iTime, 13.0) / 4.0, mod(iTime, 13.0) / 3.0, vec2(0.75,0.25), uv);\n    offset += ripple(mod(iTime, 17.0) / 4.0, mod(iTime, 17.0) / 3.0, vec2(0.75,0.75), uv);\n    offset += ripple(mod(iTime, 19.0) / 4.0, mod(iTime, 19.0) / 3.0, vec2(0.25,0.25), uv);\n    offset += ripple(mod(iTime, 23.0) / 4.0, mod(iTime, 23.0) / 3.0, vec2(0.0,0.50), uv);\n    offset += ripple(mod(iTime, 29.0) / 4.0, mod(iTime, 29.0) / 3.0, vec2(1.0,0.50), uv);\n    offset += ripple(mod(iTime, 31.0) / 4.0, mod(iTime, 31.0) / 3.0, vec2(0.50,0.0), uv);\n    offset += ripple(mod(iTime, 37.0) / 4.0, mod(iTime, 37.0) / 3.0, vec2(0.50,1.0), uv);\n    \n    return offset;\n}\n\n// 3d geometry\n\n//Box Frame - exact   (https://www.shadertoy.com/view/3ljcRh)\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Box - exact   (Youtube Tutorial with derivation: https://www.youtube.com/watch?v=62-pRVZuS5c)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // overLay distortion\n    uv += rippleDistort(uv);\n    \n        // background animation\n    \n    vec3 col = laserAnimation(uv);\n    \n    // set up eye\n    vec2 eyeXY = vec2(sin(iTime/3.0),cos(iTime/3.0));\n    float eyeZ = sin(iTime/11.0) * 0.99;\n    eyeXY *= sqrt(1.0 - eyeZ*eyeZ);\n    vec3 eye = normalize(vec3(eyeXY.x,eyeXY.y,eyeZ)); //shouldn't need to normalize due to careful math\n    eye *= 500.0;\n    \n    // set up ray trace rectangle\n    vec3 upVec = vec3(0.0,0.0,1.0);\n    vec3 horVec = normalize(cross(upVec, eye));\n    vec3 verVec = normalize(cross(eye, horVec));\n    \n    // points for ray trace\n    vec3 rayPxl = eye - 10.0*normalize(eye);\n    rayPxl += horVec * (uv.x - 0.5);\n    rayPxl += verVec * (uv.y - 0.5);\n    \n    // other points for normal calculation\n    vec3 rayPxlB = rayPxl + horVec * 0.001;\n    vec3 rayPxlC = rayPxl + verVec * 0.001;\n    \n    vec3 vecA = normalize(rayPxl - eye);\n    vec3 vecB = normalize(rayPxlB - eye);\n    vec3 vecC = normalize(rayPxlC - eye);\n    \n    // set up light source\n    vec3 lightDir = normalize(-eye);\n    \n    // prepare for ray tracing\n    float distA = 0.0;\n    float distB = 0.0;\n    float distC = 0.0;\n    float tA = 0.0;\n    float tB = 0.0;\n    float tC = 0.0;\n    \n    // moving cubes \n    float cubeX = 0.0;\n    float cubeY = 0.0;\n    float cubeZ = 0.0;\n    float timeSeg = mod(iTime, 6.0);\n    if (timeSeg < 1.0)\n    {\n        cubeX = 1.0 - mod(iTime, 1.0)*2.0;\n        cubeY = 1.0;\n        cubeZ = 1.0;\n    }\n    else if (timeSeg < 2.0)\n    {\n        cubeX = -1.0;\n        cubeY = 1.0 - mod(iTime, 1.0)*2.0;\n        cubeZ = 1.0;\n    }\n    else if (timeSeg < 3.0)\n    {\n        cubeX = -1.0;\n        cubeY = -1.0;\n        cubeZ = 1.0 - mod(iTime, 1.0)*2.0;\n    }\n    else if (timeSeg < 4.0)\n    {\n        cubeX = -1.0 + mod(iTime, 1.0)*2.0;\n        cubeY = -1.0;\n        cubeZ = -1.0;\n    }\n    else if (timeSeg < 5.0)\n    {\n        cubeX = 1.0;\n        cubeY = -1.0 + mod(iTime, 1.0)*2.0;\n        cubeZ = -1.0;\n    }\n    else\n    {\n        cubeX = 1.0;\n        cubeY = 1.0;\n        cubeZ = -1.0 + mod(iTime, 1.0)*2.0;\n    }\n    \n    // run loops to see if object is hit\n    for( int i = 0; i < 50; i++){\n        //calc positions from view rays\n        vec3 posA = eye + vecA * tA;\n        vec3 posB = eye + vecB * tB;\n        vec3 posC = eye + vecC * tC;        \n        \n        //get distance from positions to spheres\n        distA = min(min(sdBoxFrame(posA, vec3(5.0), 1.0), \n                    sdBox(posA + vec3(cubeX,0.0,0.0) * 6.0, vec3(3.0))),\n                    min(sdBox(posA + vec3(0.0,cubeY,0.0) * 6.0, vec3(3.0)),\n                    sdBox(posA + vec3(0.0,0.0,cubeZ) * 6.0, vec3(3.0))));\n        distB = min(min(sdBoxFrame(posB, vec3(5.0), 1.0), \n                    sdBox(posB + vec3(cubeX,0.0,0.0) * 6.0, vec3(3.0))),\n                    min(sdBox(posB + vec3(0.0,cubeY,0.0) * 6.0, vec3(3.0)),\n                    sdBox(posB + vec3(0.0,0.0,cubeZ) * 6.0, vec3(3.0))));\n        distC = min(min(sdBoxFrame(posC, vec3(5.0), 1.0), \n                    sdBox(posC + vec3(cubeX,0.0,0.0) * 6.0, vec3(3.0))),\n                    min(sdBox(posC + vec3(0.0,cubeY,0.0) * 6.0, vec3(3.0)),\n                    sdBox(posC + vec3(0.0,0.0,cubeZ) * 6.0, vec3(3.0))));\n        \n        tA += distA;\n        tB += distB;\n        tC += distC;\n        \n        // calculate surface\n        if (distA < 0.01 && distB < 0.01 && distC < 0.01)\n        {\n            vec3 AB = normalize(posB - posA);\n            vec3 AC = normalize(posC - posA);\n            \n            vec3 surfNorm = cross(AB, AC);\n            \n            // draw surface\n            \n            // determine surface color based on coordinates from eye based on vector projection\n            vec3 surfCol = vec3(0.0);\n            \n            // find vectors for projection\n            vec3 frontV = normalize(-eye)* 600.0;\n            vec3 rightV = horVec * 40.0;\n            vec3 upV = verVec * 40.0;\n            vec3 loc = vecA * tA;\n            \n            // find vector projection\n            vec3 progFront = (dot(loc,frontV)/dot(frontV,frontV))*frontV;\n            vec3 progRight = (dot(loc,rightV)/dot(rightV,rightV))*rightV;\n            vec3 progUp = (dot(loc,upV)/dot(upV,upV))*upV;\n            \n            // assign color based on projections\n            float gridLen = 200.0; \n            float colIndex = (dot(progFront,progFront) / gridLen) + (dot(progRight,progRight)/ gridLen) + (dot(progUp,progUp) / gridLen);\n            colIndex = mod(colIndex,5.0);\n            if (colIndex < 1.0)\n            {\n                surfCol = vec3(0.0,0.0,0.0);\n            }\n            else if (colIndex < 2.0)\n            {\n                surfCol = vec3(1.0,ceil(mod(iTime/10.0,2.0)-1.0),0.0);\n            }\n            else if (colIndex < 3.0)\n            {\n                surfCol = vec3(0.0,1.0,ceil(mod(iTime/10.0,2.0)-1.0));\n            }\n            else if (colIndex < 4.0)\n            {\n                surfCol = vec3(ceil(mod(iTime/10.0,2.0)-1.0),0.0,1.0);\n            }\n            else \n            {\n                surfCol = vec3(1.0,1.0,1.0);\n            }\n            \n            col = surfCol*dot(-lightDir, surfNorm);\n            break;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}