{"ver":"0.1","info":{"id":"ds3GRN","date":"1677121029","viewed":78,"name":"chefal brick wall","username":"chefal","description":"trying to make a brick wall with SDFs. AO and shadows don't seem to work.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bricks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR 1.\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           \n                );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat displacement(vec3 p) {\n    return noise(p);\n}\n\nfloat opDisplace( float d1, in vec3 p )\n{\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec2 map( vec3 pos ){\n    vec3 q = pos;\n    q.x *= 4.;\n    q.y *= 8.;\n    q *= 0.6;\n    vec3 id = vec3(floor(q));\n    float idn = noise(id);\n    float pn = noise(pos*100.+id*vec3(1113.34,1000.30,35.3));\n    q.x = fract(q.x);\n    q.y = fract(q.y);\n    float sp = sdBox( q + vec3(-0.08, -0.08, .3), vec3(.9, .9, .4) );\n    sp = sp + (.005 * pn);\n    \n    float box2 = sdBox( q + vec3(-0.08, -0.08, 0.1), vec3(.1) );\n    vec2 res = vec2( min(sp,box2), 1. );\n    return res;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;   \n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    return vec2( res , id );\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-map(normalPos).x;\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n  vec3 color = vec3( 0. );\n  vec3 lightPos = vec3( 1. , 4. , -3. ) + vec3(iTime*.3,0.,0.);// move light with cam\n  if( res.y > -.5 ){\n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 lightDir = normalize( lightPos - pos );\n    float match = max( 0. , dot( lightDir , norm ));\n    // sphere\n    if( res.y == 1. ){\n        float cn = noise(pos*100.);\n        color = vec3( .9 , .5, .35) * match;\n        float sh = shadow(pos, lightPos,  0.02, 2.5);\n        color *= sh;\n        color *= clamp(calcOcclusion(pos, norm), 0., 1.);\n    } \n  }\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 mv = vec3(iTime*.3,0.,0.);\n    vec3 ro = vec3( 0., 0., -1.8) + mv;\n    vec3 ta = vec3( 0. , 0. , 0. ) + mv;\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    vec2 res = calcIntersection( ro , rd  );\n    vec3 color = render( res , ro , rd );\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}