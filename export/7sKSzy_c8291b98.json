{"ver":"0.1","info":{"id":"7sKSzy","date":"1634869397","viewed":172,"name":"Swarm Thing","username":"shyuriken","description":"This is a coincidence, but it stimulates an emotional response.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat pBox(vec3 b, vec3 p) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a),\n\t      c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat hash(float x) { return fract(sin(x) * 43758.545) * 2. - 1.; }\n\nfloat sdf(vec3 p) {\n\tvec3 z = p;\n\tfloat sum = 1.5,\n\t      d = 1e5,\n\t      rnd = 0.;\n\tfor (float i = 0.; i < 12.; i++) {\n\t\tfloat td = pBox(vec3(.5), z) / sum;\n\t\tz = abs(z) - vec3(1.2, 1.2, 0);\n\t\trnd += .01 + hash(iTime * 8e-6);\n\t\td = min(td, d);\n\t\tz.xy *= rot(3.1415926 * .2 * rnd);\n\t\tz.yz *= rot(3.1415926 * .2 * rnd);\n\t\tz *= 1.5;\n\t\tsum *= 1.5;\n\t}\n\n\treturn d;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (abs(h) < .001) break;\n\t\tt += h;\n\t\tif (t > 20.) break;\n\t}\n\n\tif (t > 20.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 5. * sin(th) * sin(fi), 5. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(4) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.5, .8, .9) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}","name":"Image","description":"","type":"image"}]}