{"ver":"0.1","info":{"id":"ws2XzV","date":"1554411603","viewed":289,"name":"[TWITCH] Strokes are dancing","username":"Flopine","description":"Result of a Twitch stream. You can see all of them here: https://www.twitch.tv/flopine\nThey happened every thursday 9pm UTC+1.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","paint","npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define PI 3.141592\n#define ITER 100.\n#define time iTime\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash2d (vec2 st)\n{return fract(sin(dot(st,vec2(2.445,8.55)))*4.4541);}\n\nfloat hash (float x)\n{return fract(sin(x)*14.4545);}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor((a-per*0.5)/per);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep/2.) id = abs(id);\n    return id;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// iq's function\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat water (vec3 p)\n{\n  vec3 pp = p;\n  float s= sphe (p, 3.);\n  float b = box(p+vec3(0.,.6,0.), vec3(5.,0.5,5.));\n  \n  p.xz *= rot(p.y*0.5);\n  float cyl_id = moda(p.xz, 4.);\n  p.x -= 2.5;\n  float c = cyl(p.xzy, 0.8, 10.);\n  \n  p = pp;\n  p.y += sin(length(p.xz*4.)-time*2.)*0.1;\n  return max(-b,max(-c,max(s,abs(p.y+2.)-3.)));\n}\n\nfloat waterfall (vec3 p)\n{\n  p.xz *= rot(p.y*0.5);\n  float cyl_id = moda(p.xz, 4.);\n  p.x -= 2.5;\n  float c = cyl(p.xzy, 0.4+sin(p.y*0.15), 3.);\n  return c;\n}\n\nfloat gem (vec3 p)\n{\n    p.y -= 3.;\n    p.xz*=rot(time);\n    float o = od(p, 1.2);\n    return o;\n}\n\nfloat inside_gem (vec3 p)\n{\n  p.y += 0.5;\n  float o = od(p,0.5);\n  return o;\n}\n\nvec3 cyl_grid_ids;\nfloat cyl_grid (vec3 p)\n{\n  p.z += sin(p.y+time);\n  vec3 per = vec3(0.3,2.,0.3);\n  cyl_grid_ids = floor((p-per*0.5)/per);\n  p.y -= hash2d(cyl_grid_ids.xz)+time;\n  p = mod(p-per*0.5, per)-per*0.5;\n  p.x -= sin(p.y*5.+time)*0.1;\n  return cyl(p.xzy, 0.1, 0.8);\n}\n\nint mat = 0;\nfloat SDF (vec3 p)\n{\n  p.y += texNoise(p.xz).x*0.8;\n  float g = gem(p);\n  float ig = inside_gem(p);\n  float w = water(p);\n  float wf = waterfall(p);\n  \n  float d = smin(g,min(ig,min(w, wf)), 0.2);\n  if (d == w) mat=1;\n  if (d == wf) mat=2;\n  if (d == g || d == ig) mat=3;\n  d = max(cyl_grid(p), d);\n  return d;\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv, float fov)\n{\n  vec3 forward = normalize(tar-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.),forward));\n  vec3 up = normalize(cross(forward, left));\n  return normalize(forward * fov + left * uv.x + up * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  float dither = hash2d(uv);\n  \n  vec3 ro = vec3(0.01,3.,-10.); vec3 p = ro;\n  vec3 tar = vec3(0.,1.,0.);\n  vec3 rd = getcam(ro, tar, uv, 1.);\n  vec3 col = vec3(0.);\n  \n  bool hit = false;\n  float shad = 0.;\n  \n  for (float i=0.; i<ITER; i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      shad = i/ITER;\n      break;\n    }\n    d *= 0.9+dither*0.2;\n    p += d*rd;\n  }\n  if (hit) \n  {\n    if (mat == 1) col = vec3(hash(cyl_grid_ids.x)*0.5, hash(cyl_grid_ids.z), 1.);\n    if (mat == 2) col = vec3(hash(cyl_grid_ids.z), 1., hash(cyl_grid_ids.x));\n    if (mat == 3) col = vec3(1., hash(cyl_grid_ids.z),hash(cyl_grid_ids.x)*0.3);;\n   }\n   else col = vec3(1.);\n   \n   // vignetting (from iq)\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.3);\n   \n  fragColor = vec4(pow(col,vec3(0.4545)),1.);\n}","name":"Image","description":"","type":"image"}]}