{"ver":"0.1","info":{"id":"4ffGRB","date":"1703171393","viewed":94,"name":"colorful tunnel","username":"nayk","description":"stars,colorful, tunnel, neon\ncombination, and copypast","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","colorful","stars","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/tll3zB https://www.shadertoy.com/view/DtGyWh*/\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nconst float pi = acos(-1.);\nconst float innerR = 1.;\nconst float outerR = 12.;\n\nfloat globalTime = 0.;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Adapted from IQ's iCappedCone: https://www.shadertoy.com/view/llcfRf\n// Simplified with the assumption that the cone's axis is always the Z axis, and\n// that the caps are not needed.\n// Also, it automatically returns either the near or far intersection depending on\n// the Z order of the endpoints.\nfloat intersectCone( in vec3  ro, in vec3  rd, \n                    in float ra, in float rb,\n                    in float  paz, in float pbz)\n{\n    float ba = pbz - paz;\n    vec3  oa = ro - vec3(0, 0, paz);\n    vec3  ob = ro - vec3(0, 0, pbz);\n\n    float m0 = ba * ba;\n    float m1 = oa.z * ba;\n    float m2 = ob.z * ba; \n    float m3 = rd.z * ba;\n\n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n\n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n\n    float t0 = (-k1-sqrt(h))/k2;\n    float t1 = (-k1+sqrt(h))/k2;\n\n    float y0 = m1 + t0*m3;\n    float y1 = m1 + t1*m3;\n\n    if(paz>pbz)\n        return ( y0>0.0 && y0<m0 ) ? (-k1-sqrt(h))/k2 : -1.;\n    else\n        return ( y1>0.0 && y1<m0 ) ? (-k1+sqrt(h))/k2 : -1.;\n}\n\n\nfloat trace(vec3 ro, vec3 rd, out vec3 nearN, out vec2 nearUV)\n{\n    const int N = 4;\n\n    float minT = 1e4;\n    float outTh0 = 0., outTh1 = 0.;\n\n    float twist = globalTime / 0.005;\n\n    // Make a torus from cones\n    \n    for(int i = 0; i < N; ++i)\n    {\n        float th0 = pi * 2. / float(N) * float(i + 0) + twist;\n        float th1 = pi * 2. / float(N) * float(i + 1) + twist;\n\n        float z0 = sin(th0) * innerR;\n        float z1 = sin(th1) * innerR;\n\n        float r0 = outerR + cos(th0) * innerR;\n        float r1 = outerR + cos(th1) * innerR;\n\n        float t = intersectCone(ro, rd, r0, r1, z0, z1);\n\n        if(t > 0. && t < minT)\n        {\n            // Save only the pertinent data for later construction\n            // of shading inputs.\n            outTh0 = th0;\n            outTh1 = th1;\n            minT = t;\n        }\n    }\n\n    if(minT > 1e3)\n        return -1.;\n\n    float th0 = outTh0;\n    float th1 = outTh1;\n    float th2 = (th0 + th1) / 2.;\n\n    vec3 rp = ro + rd * minT;\n\n    float phi = atan(rp.y, rp.x);\n\n    // Get the surface differentials and a reference point for texturing\n    \n    vec3 tangent = \tnormalize(vec3(cos(phi) * cos(th1), sin(phi) * cos(th1), sin(th1)) -\n                              vec3(cos(phi) * cos(th0), sin(phi) * cos(th0), sin(th0)));\n\n    float incircleRadius = innerR * cos(pi / float(N));\n\n    vec3 midPoint = vec3(cos(phi) * (outerR + cos(th2) * incircleRadius),\n                         sin(phi) * (outerR + cos(th2) * incircleRadius), sin(th2) * incircleRadius);\n\n    nearUV.x = (phi + pi) / pi * 16.;\n    nearUV.y = dot(rp - midPoint, tangent);\n\n    nearN = vec3(cos(phi) * cos(th2), sin(phi) * cos(th2), sin(th2));\n\n    return minT;\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\nvec4 render(vec2 fragCoord)\n{    \n    vec4 jitter = texelFetch(iChannel0, ivec2(fragCoord * 2.) & 1023, 0);\n\n    // Motion blur jitter\n    globalTime = iTime + jitter.x * 1. / 50.;\n    \n    jitter = jitter.yzxw;\n\n    // Set up primary ray, including ray differentials\n\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(outerR, sin(globalTime / 7.) * .3, cos(globalTime / 5.) * .3);\n    vec3 rd = normalize(vec3(p, -1.5));\n    \n    // Rotation transformation. There is no translation here, because the tunnel\n    // motion is faked with texture scrolling.\n\n    mat3 m = rotZ(globalTime / 2.) * rotX(cos(globalTime / 4.) * .2) * rotY(sin(globalTime / 3.) * .2);\n\n    m = rotX(pi/2.)*m;\n\n    rd = m * rd;\n\n    vec3 nearN = vec3(0);\n    vec2 nearUV = vec2(0);\n\n    vec3 transfer = vec3(1);    \n    vec4 fragColor = vec4(0);\n\n    // Trace ray bounces\n    for(int j = 0; j < 3; ++j)\n    {\n        float t0 = trace(ro, rd, nearN, nearUV);\n\n        if(t0 < 0.)\n            break;\n\n        vec3 rp = ro + rd * t0;\n\n        vec3 c = vec3(0);\n\n        // Fake motion-blurred camera motion by blurring the\n        // surface shading. Note that the non-jittered time value\n        // is used here as a base time for the blur offset.\n        \n        const int motionBlurSamples = 5;\n\n        for(int i = 0; i < motionBlurSamples; ++i)\n        {\n            // Tunnel surface shading\n            float time = iTime*2.01 + (float(i) + jitter.x) / float(motionBlurSamples) * (1. / 60.);\n            vec2 uv = nearUV;\n            uv.x += time * 5.;\n            c += vec3(pow(1. - smoothstep(0.1, .4, length(fract(uv + vec2(.25, .5)) - .5)),8.)) * vec3(.3, .5, 1.) * 2.;\n            c += vec3(1. - smoothstep(0.1, .11, length(fract(uv + vec2(.25, .5)) - .5))) * vec3(.3, .5, 1.) * 4.;\n            c += vec3(step(.9, fract(uv.x - .3))) / 2. * vec3(.4, .4, 1.) * 3.;\n            c += vec3(step(.95, fract(uv.x - .3))) / 2. * vec3(.4, .4, 1.) * 6.;\n            c += step(abs(textureLod(iChannel1, uv / 15. + time / 10. * vec2(1, 0), 0.).r - .6), .2) / 4. * vec3(.4, .4, 1.);\n            c += step(abs(textureLod(iChannel1, uv / 15. + time / 10. * vec2(1, 0), 0.).r - .6), .02) * 2. * vec3(.4, .4, 1.);\n            c += step(abs(uv.y), .01) * 1.5;\n            c += step(abs(uv.y - .5), .01) * 1.5;\n        }\n\n        c /= float(motionBlurSamples);\n\n        // Fog\n        c = mix(vec3(1) * vec3(.5,.5,1), c, exp2(-t0 / 13.));\n\n        // Tint\n        c *= vec3(.6, .6, 1) / 1.3;\n\n        // Accumulate\n        fragColor.rgb += c * transfer;\n        \n        // Reflection amount\n        transfer *= .8 * pow(clamp(1. - dot(-nearN, -rd), 0., 1.), 4.);\n\n        if(max(max(transfer.x, transfer.y), transfer.z) < 1e-3)\n            break;\n        \n        // Reflect\n        ro = rp + nearN * 1e-4;\n        rd = reflect(rd, nearN);\n\n        jitter = jitter.yzxw;\n    }\n\n    fragColor.a = 1.;\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n   vec4 fragColor = vec4(0);\n\n    vec3 backg = vec3(.07);\n\n    // Anti-aliasing loop\n\n    for(int y = 0; y < 2; ++y)\n        for(int x = 0; x < 2; ++x)\n        {\n            vec4 r = render(C+ vec2(x,y) / 2.);\n            r.rgb = mix(backg, r.rgb, r.a);\n            fragColor.rgb += clamp(r.rgb, 0., 1.);\n        }\n\n    fragColor /= 4.;\n\n\t// Tonemap and \"colourgrade\"\n    \n    fragColor /= (fragColor + .4) / 1.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1,1.4,1.8));\n\n    // Gamma correction\n    \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n    fragColor.a = 1.;\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d ;\n        p.z+=iTime*1.5;\n        a=10.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*fragColor.rgb;\n         }\n         g+=e=length(p.yz)/s;\n         g+=e=length(p.yx)/s;\n    }\n}","name":"Image","description":"","type":"image"}]}