{"ver":"0.1","info":{"id":"lsGBWt","date":"1549467604","viewed":110,"name":"raymarch experiment","username":"snipstruis","description":"quick test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// signed distance field primitives\nfloat sphere( vec3 p, float s ){ return length(p)-s; }\nfloat cube(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat cylinderY(vec3 v, float r){return length(v.xz)-r;}\nfloat cylinderX(vec3 v, float r){return length(v.yz)-r;}\nfloat cylinderZ(vec3 v, float r){return length(v.xy)-r;}\nfloat planeX(vec3 v, float h){return h-v.x;}\nfloat planeY(vec3 v, float h){return h-v.y;}\nfloat planeZ(vec3 v, float h){return h-v.z;}\nfloat plane( vec3 v, float h, vec3 n){/*n must be normalized*/return dot(v,n)+h;}\nfloat beamX(vec3 p, vec2 size){ \n    vec2 d = abs(p.yz) - size;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat beamY(vec3 p, vec2 size){ \n    vec2 d = abs(p.xz) - size;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat beamZ(vec3 p, vec2 size){ \n    vec2 d = abs(p.xy) - size;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cone( vec3 p, vec2 c){// c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nfloat hemisphereY(vec3 p, float r){\n    return max(sphere(p,r),\n               -planeY(p,-p.y));\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nconst float pi = 3.14159265359;\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\nvec3 repeatRotY(vec3 p, float rep){\n    pModPolar(p.xz,rep);\n    return p;\n}\n\n// model that is rendered\nfloat isosurface(vec3 o){\n    float archbox = \n        MIN(// pedestal\n            MAX(cylinderY(o,sqrt(2.0)*1.5),\n                1.25-o.y),\n            // inner stair step\n            MAX(beamY(o,vec2(1.0)),\n                1.0-o.y),\n            // outer stair step\n            MAX(beamY(o,vec2(1.25)),\n                1.125-o.y),\n            // big arches\n            MAX(beamY(o,vec2(1.0)),\n                MIN(sphere(o,1.0*sqrt(2.0)),\n                    cube(o-vec3(0,1,0),vec3(1.0) )\n                ),\n                -1.0-o.y,\n                -cylinderX(o,0.75),\n                -cylinderZ(o,0.75),\n                -cylinderY(o,0.75),\n                -sphere(o,0.75*sqrt(2.0)),\n                -beamX(o-vec3(0,1,0),vec2(1.0,0.75)),\n                -beamZ(o-vec3(0,1,0),vec2(0.75,1.0))\n    \t\t),\n\t\t\t// ring of arches\n            MAX(cylinderY(o,1.0),\n                -cylinderY(o,0.75),\n                -1.5-o.y,\n                1.0+o.y,\n            \t-cylinderX(repeatRotY(o+vec3(0,1.25,0),12.0),0.19),\n            \t-beamX(repeatRotY(o+vec3(0,1.125,0),12.0),vec2(0.125,0.19))\n            ),\n            // dome roof\n            MAX(hemisphereY(o+vec3(0,1.5,0),1.025),\n                -sphere(o+vec3(0,1.5,0),0.75)\n            )\n        );\n    return archbox;\n}\n\nconst float cot_half_fovy = 1.0/tan(0.5*radians(60.0));\nvec3 raycast(vec3 origin, vec3 direction, vec2 uv){\n    vec3 forward = direction*cot_half_fovy;\n    vec3 right   = normalize(cross(direction,vec3(0,1,0)));\n    vec3 up      = cross(direction,right); // right angle -> normalized output\n    return normalize(forward + right*uv.x + up*uv.y);\n}\n\nconst float max_dist  =  10.0;\nconst float min_step_size =  1e-4;\nconst float epsilon   =  1e-5;\nfloat march(vec3 ray_origin, vec3 ray_direction, out int iterations){\n    iterations = 0;\n    float prev_value = isosurface(ray_origin);\n    if(prev_value<0.0) return 0.0;\n    float prev_t = 0.0;\n    for(float t=prev_value*(0.5-epsilon); t<max_dist; iterations++){\n        float current_value = isosurface(ray_origin+ray_direction*t);\n        if(sign(prev_value)!=sign(current_value)){\n            float estimated_intersection = prev_value/(current_value-prev_value);\n            return mix(t,prev_t,estimated_intersection);\n        }\n        prev_t = t;\n        t+=max(min_step_size,current_value*(1.0-epsilon));\n        prev_value = current_value;\n    }\n    return max_dist;\n}\n\nvec3 derivative(vec3 o){\n    const float d = 1e-4;\n    vec3 v = vec3(\n        isosurface(o+vec3(d,0,0)) - isosurface(o+vec3(-d, 0, 0)),\n        isosurface(o+vec3(0,d,0)) - isosurface(o+vec3( 0,-d, 0)),\n        isosurface(o+vec3(0,0,d)) - isosurface(o+vec3( 0, 0,-d)));\n    return normalize(v);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = isosurface(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nconst vec3 light_dir = -normalize(vec3(1,3,2));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 half_res = 0.5*iResolution.xy;\n    vec2 uv = (fragCoord-half_res)/half_res.yy;\n    vec3 ray_origin    =  5.0*normalize(vec3( sin(-4.0*iMouse.x/iResolution.y + 0.1*iTime),\n                                -2.0+4.0*iMouse.y/iResolution.y,\n                                cos(-4.0*iMouse.x/iResolution.y + 0.1*iTime)));\n   \tvec3 ray_direction = raycast(ray_origin, normalize(-ray_origin), uv);\n    \n    int iter;\n\tfloat dist = march(ray_origin, ray_direction, iter);\n    #if 0 // visualize itterations\n    vec3 iterValue = iter<=  4?vec3(0,0,0) // black\n                   : iter<=  8?vec3(0,0,1) // blue\n                   : iter<= 16?vec3(0,1,1) // cyan\n                   : iter<= 32?vec3(0,1,0) // green\n                   : iter<= 64?vec3(1,1,0) // yellow\n                   : iter<=128?vec3(1,0,0) // red\n                   : iter<=256?vec3(1,0,1) // cyan\n                   : vec3(1,1,1);          // white\n    fragColor = vec4(pow(iterValue,vec3(1.0/2.2)),1.0);\n    #else\n    if(dist<max_dist){\n        vec3 pos    = ray_origin + ray_direction*dist;\n        vec3 normal = derivative(pos);\n        float shadow = softshadow(pos,light_dir,0.01, 10.0, 64.0);\n        float light  = shadow*1.5*max(0.0,dot(normal,light_dir));\n        float back   = 0.5*max(0.0,dot(normal,-vec3(light_dir.x,0,light_dir.z)));\n        float sky    = 0.2*max(0.0,dot(normal,vec3(0,-1,0)));\n        #if 1\n        vec3 material = vec3(0);\n        // blue roof\n        if(normal.y<-1e-4 && ((pos.y>-0.999 && pos.y<0.0)||pos.y<-1.50))\n            material = vec3(0.02,0.02,0.2);\n        // pedestal\n        else if(pos.y>1.25)\n            material = vec3(0.1,0.1,0.1);\n        // blocky texture\n        else material = \n            material = ( int(pos.x+100.001)\n                        ^ int(pos.y+100.001)\n                        ^ int(pos.z+100.001))%2==0? vec3(0.15) : vec3(0.2);\n        #else\n        vec3 material = vec3(0.2);\n        #endif\n        vec3 color = light*vec3(1,1,0.8)\n                   + back *vec3(1)\n                   + sky  *vec3(0.5,0.5,1.0);\n        color *= material;\n        fragColor = vec4(pow(color,vec3(1.0/2.2)),1.0);\n    }else fragColor = texture(iChannel0,vec3(ray_direction.x,-ray_direction.y,ray_direction.z));\n    #endif\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float MAX(float a, float b)\n{return max(a,b);}\nfloat MAX(float a, float b, float c)\n{return max(max(a,b),c);}\nfloat MAX(float a, float b, float c, float d)\n{return max(max(a,b),max(c,d));}\nfloat MAX(float a, float b, float c, float d, float e)\n{return MAX(max(a,b),c,d,e);}\nfloat MAX(float a, float b, float c, float d, float e, float f)\n{return MAX(max(a,b),max(c,d),e,f);}\nfloat MAX(float a, float b, float c, float d, float e, float f, float g)\n{return MAX(max(a,b),max(c,d),max(e,f),g);}\nfloat MAX(float a, float b, float c, float d, float e, float f, float g, float h)\n{return MAX(max(a,b),max(c,d),max(e,f),max(g,h));}\nfloat MAX(float a, float b, float c, float d, float e, float f, float g, float h, float i)\n{return MAX(max(a,b),c,d,e,f,g,h,i);}\n\nfloat MIN(float a, float b)\n{return min(a,b);}\nfloat MIN(float a, float b, float c)\n{return min(min(a,b),c);}\nfloat MIN(float a, float b, float c, float d)\n{return min(min(a,b),min(c,d));}\nfloat MIN(float a, float b, float c, float d, float e)\n{return MIN(min(a,b),c,d,e);}\nfloat MIN(float a, float b, float c, float d, float e, float f)\n{return MIN(min(a,b),min(c,d),e,f);}\nfloat MIN(float a, float b, float c, float d, float e, float f, float g)\n{return MIN(min(a,b),min(c,d),min(e,f),g);}\nfloat MIN(float a, float b, float c, float d, float e, float f, float g, float h)\n{return MIN(min(a,b),min(c,d),min(e,f),min(g,h));}\nfloat MIN(float a, float b, float c, float d, float e, float f, float g, float h, float i)\n{return MIN(min(a,b),c,d,e,f,g,h,i);}","name":"Common","description":"","type":"common"}]}