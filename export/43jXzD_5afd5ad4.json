{"ver":"0.1","info":{"id":"43jXzD","date":"1711051708","viewed":64,"name":"Data Path","username":"3t13nn3","description":"Data Path","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","distortion","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 p, float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * p;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n\nvec3 map(vec2 p) {\n    vec3 r = mix(vec3(0.3, 0.7, 1), vec3(0.2, 0.8, 1), p.y + 0.5);\n    p += vec2(p.x * p.y, iTime / 5. + p.y);\n    //p += vec2(iTime / 5., 0);\n    float randomOffset = step(0.5, fract(sin(dot(floor(p * 8.0), vec2(12.9898, 78.233))) * 43758.5453));\n    vec2 boxPos = vec2(randomOffset, 0.5);\n\n    float boxSize = 0.25;\n    float borderSize = 0.1;\n    \n    // Garder une position de boîte constante\n    vec2 rotatedP = rotate(fract(p * 8.) - boxPos, radians(0.0));\n\n    // Utiliser une taille de boîte constante\n    float b = sdBox(rotatedP, vec2(0.25));\n\n    if (b < 0.0) {\n        r += vec3(0.7, 0.2, 0.18);\n        \n    // Ajouter la bordure à l'intérieur de la boîte\n    float border = smoothstep(borderSize, 0., abs(b));\n        r = mix(r, vec3(0.0, 0.0, 0.0), border);\n    } else if (b < 0.1) {\n        r += vec3(sin(p.x + iTime ), 0.0, cos(p.y - iTime ) / 5.);\n    } else if (fract(b * 5.) < 0.2) {\n        r += vec3(0.1, sin(p.x + iTime ), 0.9) / 3.;\n    }\n \n    return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; \n\n    vec3 col = map(uv);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)),1.0);\n}","name":"Image","description":"","type":"image"}]}