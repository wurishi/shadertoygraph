{"ver":"0.1","info":{"id":"3sf3W2","date":"1547488522","viewed":672,"name":"ShaderDojo 013","username":"antonOTI","description":"Training session for shader showdown.\nI tried to make a smooth edged cube, failed and then roll with it\n(thanks iq for your ever usefull function toolbox)","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","training","dojo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159\n\n#define REP(p, r) (mod(p + r/2.,r) - r/ 2.)\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat map(vec3 p)\n{\n  vec3 cp = p;\n  float dist = 1000.;\n\n  float time = iTime * .25;\n p *= .36;\n  p.zx *= rot(-time * .25);\n\n  p.xz *= rot(p.z*1.1);\n\n  for(float it = 0.; it < 2.; it += 1.)\n{\n  p.xz *= rot(sin(p.y + time + (fract(sin(it * 2369.)))) * PI / (it + 1.) * .5);\n\n//  p.y += p.x * .125;\n  p.zy *= rot(time+PI);\nvec3 ap = max(vec3(0.),abs(p)) - 1.;\nfloat cu = length(ap)-.5 + min(max(ap.x,max(ap.y,ap.z)), 0.);\n  dist  =smin(dist, cu , .25);\n\n}\n\n  p = cp;\n  p.xz *= rot(-time * .5);\n\n\n  float rad = 5.;\n  float wi = .5;\n  float sph = length(p) - rad + wi /2.;\n\n  dist = -smin(sph,-dist,.15);\n\n  sph = length(p) - rad - wi /2.;\n\n  dist = -smin(-sph,-dist,.15);\n\n  sph = distance(cp, vec3(0.,0.,-5.)) - 2.;\n\n  dist = -smin(sph,-dist,.3);\n\n  return dist;\n}\n\nfloat ray(inout vec3 cp, vec3 rd, out float cd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1. /128.)\n  {\n    cd = map(cp);\n    if(cd < .01)\n    {\n      break;\n    }\n    cp += rd * cd * .75;\n  }\n\n  return st;\n}\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv *= 1.4;\n\n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 rd = normalize(vec3(uv, 1.));\n  vec3 cp = eye;\n\n  float cd;\n  float st = ray(cp, rd, cd);\n\n  fragColor = vec4(0.);\n  if(cd < .01)\n  {\n    vec3 ld = normalize(vec3(0.,-1.,1.));\n    ld.xz *= rot(iTime * .1);\n\n    vec3 norm = normal(cp);\n    float li = dot(ld, norm);\n\n    ld.zy *= rot(iTime * .25);\n    float li2 = dot(normalize(vec3(1.,0.,1.)), norm);\n    \n\n    float f = pow(max(li,li2), 2.);\n    f = sqrt(f);\n    vec4 col = vec4(norm, 0.);\n\n    col.xy *= rot(iTime * .5);\n    col.yz *= rot(iTime * .75);\n    col.xz *= rot(iTime * .125);\n    col = abs(col);\n    fragColor = mix(vec4(0.), col * 1.5, f);\n  }\n\n}","name":"Image","description":"","type":"image"}]}