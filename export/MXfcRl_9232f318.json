{"ver":"0.1","info":{"id":"MXfcRl","date":"1726585691","viewed":31,"name":"Fork Simple 2D  - scattering","username":"dsmiller95","description":"casting random rays and hitting objects to simulate 2d lighting\n\nconfigure flags at the bottom of Common to change rendering parameters. Click clears the current buffer.\n\nHARDSTEP will move the objects at discrete intervals, clearing the rendering buffer ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"3tsXzB","parentname":"Simple 2D Lighting"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    vec3 colAdjust = col.rgb / col.a;\n    //float v = col.a/(4. * 1024.);\n    #ifdef LINE_ART\n    colAdjust *= 4.;\n    #endif\n    fragColor = vec4(colAdjust * 4., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// samples per frame\n#define SAMPLES_PER_FRAME 1\n// higher steps per ray leads to better reflections\n#define STEPS_PER_RAY 50\n// how much to decay the render buffer every frame. low values result in better but less responsive renders\n#define DECAY_PER_FRAME .05\n//When defined, only move objects at discrete intervals, at a frequency of STEPS_PER_SECOND seconds\n//#define HARDSTEP\n#define STEPS_PER_SECOND 1./4.\n#define SPEED 1./16.\n// when defined, only render rays emerging from this many discrete directions from the light sources\n//#define LINE_ART 12\n\n\nint MIN = -2147483648;\nint MAX = 2147483647;\n\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(inout int seed) {\n    seed = xorshift(seed);\n    return abs(fract(float(seed) / 2147483647.));\n}\n\nfloat nextFloat(inout int seed, in float max) {\n    return nextFloat(seed) * max;\n}\n\nvec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nfloat sphereSDF(vec2 p, float size, inout vec2 normal) {\n     normal = -normalize(p);\n     return length(p) - size;\n}\n\nfloat boxSDF(vec2 p, vec2 size) {\n\tvec2 r = abs(p) - size;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nvoid addObj(inout float dist, inout vec3 color, inout vec2 normal, float d, vec3 c, vec2 n) {\n    if (dist > d) {\n        dist = d;\n        color = c;\n        normal = n;\n    }\n}\n\nvoid addBox(in vec2 pos, inout float dist, inout vec3 color, inout vec2 normal, vec2 size, float rNorm){\n    float w = .15;\n    \n    addObj(dist, color, normal, boxSDF   (pos - vec2(-size.x-w/2., 0), \t      vec2(w, size.y)), \tvec3( -1.,  .0,  .0), rotate(vec2(-1., 0.), rNorm));\n    addObj(dist, color, normal, boxSDF   (pos - vec2(-size.x+w/2., 0), \t      vec2(w, size.y)), \tvec3( -1.,  .0,  .0), rotate(vec2(1., 0.), rNorm));\n    addObj(dist, color, normal, boxSDF   (pos - vec2( size.x-w/2., 0), \t      vec2(w, size.y)), \tvec3( -1.,  .0,  .0), rotate(vec2(-1., 0.), rNorm));\n    addObj(dist, color, normal, boxSDF   (pos - vec2( size.x+w/2., 0), \t      vec2(w, size.y)), \tvec3( -1.,  .0,  .0), rotate(vec2(1., 0.), rNorm));\n    addObj(dist, color, normal, boxSDF   (pos - vec2( 0., size.y-w-w/2.),    vec2(size.x+w, w)),vec3( -1.,  .0,  .0), rotate(vec2(0., -1.), rNorm));\n    addObj(dist, color, normal, boxSDF   (pos - vec2( 0., size.y-w+w/2.),    vec2(size.x+w, w)),vec3( -1.,  .0,  .0), rotate(vec2(0., 1.), rNorm));\n}\n\n\nvoid scene(in vec2 pos, out vec3 color, out float dist, out vec2 normal, inout int rng, in float iTime) {\n    dist = 1e9; color = vec3(0,0,0); normal = vec2(0,0);\n    vec2 tmpN = vec2(0,0);\n    float safeRand = fract(sin(iTime*42.88720));\n    float safeRand2 = fract(sin(iTime*97.29342));\n    addObj(dist, color, normal, boxSDF   (pos - vec2(-4, 1.3), \t\t\t\tvec2(.5, .5)), \t\tvec3(1.0,  .8, .0), vec2(0., 0.));\n    addObj(dist, color, normal, sphereSDF(pos - vec2(4., 1.),  \t            0.2, tmpN), \t\t\t\tvec3(1, 0.9, 3.8), tmpN);\n    addObj(dist, color, normal, sphereSDF(pos - vec2(6., 1.),  \t            0.2, tmpN), \t\t\t\tvec3(1, 2.9, 0.8), tmpN);\n    \n    //addObj(dist, color, normal, boxSDF   (pos - vec2(-2. + 2.0 * sin(iTime), -3.), \tvec2(3.5, .5)), \tvec3( .4,  .1,  .1), vec2(0., 0.));\n    \n    // box walls\n    //vec2 rotated = rotate(pos - vec2(-4.2,3.5), 3. * 3.1415 / 4.);\n    addBox(rotate(pos - vec2(0,2), iTime), dist, color, normal, vec2(2,2), -iTime);\n    float rb2 = -iTime*1.5f;//-6. * 3.1415 / 4.;\n    addBox(rotate(pos - vec2(6,1), rb2), dist, color, normal, vec2(.5,1), -rb2);\n    float rb3 = 3. * 3.1415 / 4.;\n    vec2 rotated = rotate(pos - vec2(-4.2,3.5), rb3);\n    addBox(rotated, dist, color, normal, vec2(.5,1), -rb3);\n    \n    // sphere walls\n    addObj(dist, color, normal, sphereSDF(pos - vec2(5., -2.),  \t            0.8, tmpN), \t\t\t\tvec3(-1., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(3., 2.),  \t            0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(3., 1.),  \t            0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(3., 0.),  \t            0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(2., 3.),  \t            0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(1., 3.),  \t            0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(0., 3.),  \t            0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(-1., 3.),  \t        0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(-2., 3.),  \t        0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(-2., 0.),  \t        0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    //addObj(dist, color, normal, sphereSDF(pos - vec2(-2., -1.),  \t        0.8, tmpN), \t\t\t\tvec3(0., 0., 0.), tmpN);\n    \n    // floor + ceiling + walls\n    addObj(dist, color, normal, boxSDF   (pos - vec2( 0,-4.2), \t          vec2(50, .2)), \tvec3( -1.,  .0,  .0), vec2(0, -1));\n    addObj(dist, color, normal, boxSDF   (pos - vec2( 0,5.), \t          vec2(50, .2)), \tvec3( -1.,  .0,  .0), vec2(0, 1));\n    addObj(dist, color, normal, boxSDF   (pos - vec2(-8.5,0.), \t          vec2(.2, 50)), \tvec3( -1.,  .0,  .0), vec2(1, 0));\n    addObj(dist, color, normal, boxSDF   (pos - vec2(8.5,0.), \t          vec2(.2, 50)), \tvec3( -1.,  .0,  .0), vec2(-1, 0));\n}\n\nvoid trace(vec2 p, inout vec2 dir, out vec3 c, out vec2 n, inout int seed, in float iTime) {\n    float totalDist = 0.;\n    int hitN = 0;\n    for (int j = 0; j < STEPS_PER_RAY; j++) {\n        float d;\n        scene(p, c, d, n, seed, iTime);\n        if (d > 1e1) {\n            \n            break;\n        }\n        float randDir = nextFloat(seed) * 2. * 3.1415;\n        vec2 randDirVec = vec2(cos(randDir), sin(randDir));\n        if (d < 1e-3) {\n            if(j == 0) return;\n            if (c.x <= -1. && (n.x != 0. || n.y != 0.)){\n              if(hitN > 1){\n                c = vec3(0,0,0);\n                return;\n              }\n              // bounce\n              dir = reflect(dir, n);\n              d = 0.09;\n              hitN++;\n              //dir = randDirVec;\n            }else{\n              //c = vec3(0,.1,0);\n              \n              return;\n            }\n        }else{\n          // ray dispersal\n          dir = normalize(dir + randDirVec * 0.0 * d);\n          hitN = 0;\n        }\n        //d = min(d, 1.);\n        p += dir * d;\n        totalDist += d;\n    }\n    c = vec3(0,0,0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.z > 0.){\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    float time = iTime;\n    #ifdef HARDSTEP\n    time = floor(time * float(STEPS_PER_SECOND)) / float(STEPS_PER_SECOND);\n    float lastTime = (iTime - iTimeDelta);\n    lastTime = floor(lastTime * float(STEPS_PER_SECOND)) / float(STEPS_PER_SECOND);\n    if(lastTime != time){\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    #endif\n    time = time * float(SPEED);\n    \n    //time = time * 3.14159265359;\n    \n\n\tvec2 uvBuf = fragCoord.xy / iResolution.xy;\n    vec4 colBuf = texture(iChannel0, uvBuf);\n    vec4 oldColor = vec4(colBuf.rgb, colBuf.a);\n    \n    //if(iFrame%2 == 1) return;\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    int rngSeed = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);// + floatBitsToInt(oldColor.b);\n    rngSeed *= int(iTime * 100.);\n    for (int i = 0; i < 4; i++) rngSeed = xorshift(rngSeed);\n    //float r = nextFloat(rngSeed);\n    //fragColor = vec4 (r,r,r,1);\n    //return;\n    \n    vec2 uv = (gl_FragCoord.xy-(iResolution.xy/2.0))/iResolution.y*10.0;\n    \n    vec3 col = vec3(0,0,0);\n    for (int i = 0; i < SAMPLES_PER_FRAME; i++) {\n        float t = (float(i) + nextFloat(rngSeed)) / float(SAMPLES_PER_FRAME);\n        #ifdef LINE_ART\n        //t = floor(t * 16.) / 16.;\n        #endif\n        float tRad = t * 2. * 3.1415;\n        //float t = nextFloat(rngSeed) * 2. * 3.141;\n        //float t = (float(i)) / float(SAMPLES) * 2. * 3.1415;\n        //t /= 4.;\n        vec3 c;\n        vec2 n;\n        vec2 dir = vec2(cos(tRad), sin(tRad));\n        trace(uv, dir, c, n, rngSeed, time);\n        #ifdef LINE_ART\n        float angle = atan(dir.x, dir.y);\n        // reduce to specific directionals\n        angle /= 3.1415 * 2.;\n        angle *= float(LINE_ART);\n        if(abs(fract(angle)) > 0.2){\n            c = vec3(0, 0, 0);\n        }\n        #endif\n        col += c;\n        //if(c.x == -1.) samples--;\n    }\n    col /= float(SAMPLES_PER_FRAME);\n\n\n    vec4 newColor = vec4(col*0.25,1.0);\n    \n    \n    \n    float lerp = DECAY_PER_FRAME;//iTimeDelta * 0.1;\n    fragColor = newColor + oldColor * (1. - lerp);//(newColor * lerp + oldColor * (1. - lerp));\n    \n    // Output to screen\n    //fragColor = vec4(col*2.0,3.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}