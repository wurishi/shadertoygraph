{"ver":"0.1","info":{"id":"DldXWS","date":"1685745998","viewed":337,"name":"CRT TV Shader","username":"aleklesovoi","description":"Implementation steps:\n1. Brown Conrady Distortion algorithm;\n2. Apply chromatic aberration by simply biasing the color, using distorted UVs;\n3. Draw scanlines. Get Pixels\n4. Cut the corners and delete extra information\n","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["crt","posteffects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCANLINES 1\n#define CHROMATIC_ABERRATION 1\n#define VIGNETTE 1\n#define DISTORT 1\n\n//Chromatic aberration parameters\n#define CA_STRENGTH 15.0\n\n// Vignette parameters\n#define CORNER_OFFSET 0.61\n#define CORNER_MASK_INTENSITY_MULT 16.0\n#define BORDER_OFFSET 0.04\n\nvec3 ChromaticAberration(vec2 uv)\n{\n    vec3 color = texture(iChannel0, uv).rgb;\n\tcolor.r = texture(iChannel0, (uv - 0.5) * (1.0 + CA_STRENGTH / iResolution.xy) + 0.5).r;\n\tcolor.b = texture(iChannel0, (uv - 0.5) * (1.0 - CA_STRENGTH / iResolution.xy) + 0.5).b;\n\n    return color;\n}\n\n// https://www.imatest.com/support/docs/pre-5-2/geometric-calibration-deprecated/distortion-models/\n// https://www.control.isy.liu.se/student/graduate/DynVis/Lectures/le2.pdf\n// Only radial distortion. Brown Conrady gives better result and less affects performance\nvec2 BrownConradyDistortion(in vec2 uv)\n{\n    // positive values of K1 give barrel distortion\n    float k1 = 0.3;\n    float k2 = 0.1;\n\n    uv = uv * 2.0 - 1.0; // brown conrady takes [-1:1]\n    \n    float r2 = uv.x * uv.x + uv.y * uv.y;\n    uv *= 1.0 + k1 * r2 + k2 * r2 * r2;\n    \n    uv = uv * 0.5 + 0.5; // [0:1]\n    \n    // using the distortion param as a scale factor, to keep the image close to the viewport dims\n    float scale = abs(k1) < 1.0 ? 1.0 - abs(k1) : 1.0 / (k1 + 1.0);\t\t\n    \n    uv = uv * scale - (scale * 0.5) + 0.5; // scale from center\n    \n    return uv;\n}\n\nfloat Scanlines(vec2 uv)\n{\n    return (abs(sin( iResolution.y * uv.y)) + abs(sin( iResolution.x * uv.x))) / 2.0;\n}\n\n// Or we can bake vignette map to get more custom vignette with better visual result\n// But current implementation is faster on GPU\nfloat Vignette(vec2 uv)\n{\n    uv = uv - 0.5; // [-0.5; 0.5]\n    \n    // Cut the corners\n    float res = length(uv)- CORNER_OFFSET;\n    res *= CORNER_MASK_INTENSITY_MULT;\n    res = clamp(res, 0.0, 1.0);\n    res = 1.0 - res;\n    \n    // Cut the out of bounds information\n    uv = abs(uv); // [0.0; 0.5]\n    uv = uv - (0.5 - BORDER_OFFSET);\n    uv = smoothstep(1.0, 0.0, uv / BORDER_OFFSET);\n    \n    // combine\n\treturn min(uv.x, uv.y) * res;\n}\n\n// main shader body\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen space coordinates [0;1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if DISTORT\n    uv = BrownConradyDistortion(uv);\n#endif\n    \n#if CHROMATIC_ABERRATION\n    vec3 result = ChromaticAberration(uv);\n#else\n    vec3 result = texture(iChannel0, uv).rgb;\n#endif\n    \n#if SCANLINES\n    result *= Scanlines(uv);\n#endif    \n\n#if VIGNETTE\n    result *= Vignette(uv);\n#endif\n     \n    // final output\n    fragColor = vec4( result, 1.0 );\n}","name":"Image","description":"","type":"image"}]}