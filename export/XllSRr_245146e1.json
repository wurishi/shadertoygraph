{"ver":"0.1","info":{"id":"XllSRr","date":"1434098744","viewed":246,"name":"Flipped grid","username":"udart","description":"Displays a grid with the specified texture in the lines and flips it","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// This helper function returns 1.0 if the current pixel is on a grid line, 0.0 otherwise\nfloat IsGridLine(vec2 fragCoord)\n{\n    //The number of rows\n    float rows = 50.0;\n    \n    float sizeOfSquares = iResolution.y / rows;\n    \n\t// Define the size we want each grid square in pixels\n\tvec2 vPixelsPerGridSquare = vec2(sizeOfSquares, sizeOfSquares);\n\t\n\t// fragCoord is an input to the shader, it defines the pixel co-ordinate of the current pixel\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\t\n\t// Get a value in the range 0->1 based on where we are in each grid square\n\t// fract() returns the fractional part of the value and throws away the whole number part\n\t// This helpfully wraps numbers around in the 0->1 range\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\t\n\t// Convert the 0->1 co-ordinates of where we are within the grid square\n\t// back into pixel co-ordinates within the grid square \n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\t// step() returns 0.0 if the second parmeter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\t\n\t// Combine the x and y gridlines by taking the maximum of the two values\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\t// return the result\n\treturn fIsGridLine;\n}\n\n// main is the entry point to the shader. \n// Our shader code starts here.\n// This code is run for each pixel to determine its colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t// We set the rgb of the result based on the IsGridLine() function\n\tvec3 gridCol = vec3(IsGridLine(fragCoord));\n    \n    //The coordinate to sample in the texture\n    vec2 q = fragCoord / iResolution.xy;\n    \n    q = vec2(q.x,1.0 - q.y);\n    \n    //The color of the sampled point in the texture\n    vec3 texCol = texture( iChannel0, vec2(q.x,q.y) ).xyz;\n    \n    //Combine the grid and the texture by using the texture where grid color is 1\n\tvec3 col = min(gridCol, texCol);\n    \n    if (col.r > 0.5)\n        col = vec3(1.0);\n    else\n        col = vec3(0.0);\n    \n\t// The output to the shader is fragColor. \n\t// This is the colour we write to the screen for this pixel\n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}