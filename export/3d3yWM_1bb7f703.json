{"ver":"0.1","info":{"id":"3d3yWM","date":"1600982263","viewed":170,"name":"P H A S E D","username":"BlooBewwiez","description":"floating slices. Domain repetition of spheres and torus intersections.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","spheres","learning","trippy","infinite","chips"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define SURF_DIST .001\n# define SPHERE 1\n# define TORUS 2\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat rand(vec2 coordinate) {\n    return fract(sin(dot(coordinate.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat displacement(vec3 p, int type){\n    switch (type) {\n        case 1:\n\t        return (sin(p.x * -.5) + -sin(length(p)) + -sin(p.z));\n        case 2:\n        \treturn (rand(p.xy) * rand(p.xz) * rand(p.yz));\n        case 3:\n        \treturn (rand(p.xx));\n        default:\n        \tbreak ;\n    }\n}\n\n\nfloat sdf_sphere(vec3 p, float r){\n    return (length(p) - r);\n}\nfloat sdf_torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\nfloat sdf_capped_cone(vec3 p, float h, float r1, float r2){\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp(dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt(min(dot2(ca),dot2(cb)) );\n}\nfloat sdf_hex_prism(vec3 p, vec2 h){\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdf_cone( in vec3 p, in vec2 c, float h ){\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdf_tocta(vec3 p, float r) {\n    vec3 n1 = vec3(1.000,0.000,0.000);\n\tvec3 n2 = vec3(0.000,1.000,0.000);\n\tvec3 n3 = vec3(0.000,0.000,1.000);\n\tvec3 n4 = vec3(0.577,0.577,0.577);\n\tvec3 n5 = vec3(-0.577,0.577,0.577);\n\tvec3 n6 = vec3(0.577,-0.577,0.577);\n\tvec3 n7 = vec3(0.577,0.577,-0.577);\n\tvec3 n8 = vec3(0.000,0.357,0.934);\n\tvec3 n9 = vec3(0.000,-0.357,0.934);\n\tvec3 n10 = vec3(0.934,0.000,0.357);\n\tfloat s = abs(dot(p,n1));\n\ts = max(s,abs(dot(p,n2)));\n\ts = max(s,abs(dot(p,n3)));\n\ts = max(s,abs(dot(p,n4)));\n\ts = max(s,abs(dot(p,n5)));\n\ts = max(s,abs(dot(p,n6)));\n\ts = max(s,abs(dot(p,n7)));\n\treturn s-r;\n}\nfloat sdf_capsule(vec3 p, float h, float r){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat opUni( float d1, float d2 ) { return min(d1,d2);  }\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\nfloat opInt( float d1, float d2 ) { return max(d1,d2);  }\nfloat opSUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opRep( in vec3 p, in vec3 c, int type, vec2 torus_data, float sphere_data){\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float ret = 0.0;\n    switch(type){\n        case 0 :\n  \t\t\tret = sdf_torus(q, torus_data);\n        \tbreak;\n        case 1 :\n        \tret = sdf_sphere(q, sphere_data);\n        \tbreak;\n    }\n    return ret;\n}\nfloat opSInt( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat make_noised_capsule(in vec3 p){\n    float d1 = sdf_capsule(p, 5., 3.);\n    float d2 = displacement(p, 1);\n    return d1+d2;\n}\n\nmat2  rot(float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return(mat2(ca, sa, -sa, ca));\n}\n\nfloat get_dist(vec3 position){\n    // declaring & assign position of objects\n    vec3 sphere_pos = position - vec3(0, 1.2, 5);\n    vec3 torus_pos  = position - vec3(0, 2, 5);\n    vec3 cone_pos   = position - vec3(0, -0.2, 5);\n    vec3 hex_pos    = position - vec3(0, 2.2, 5);\n    vec3 top_cone_pos = position - vec3(0, 3.4, 5);\n    vec3 tocta_pos  = position - vec3(2, 2, 5);\n\tvec3 capsule_pos = position - vec3(0, -4, 5);\n    \n    torus_pos.yz *= rot(-iTime * .3); \n    torus_pos.yx *= rot(-iTime * .3);\n\n   \tfloat torus_dist = opRep(torus_pos * iTime * 0.3, vec3(2, 0.2, 3), 0, vec2(1.5, 0.3), 0.);\n   \tfloat sphere_dist = opRep(sphere_pos + iTime, vec3(5, 4, 6), 1, vec2(0), 1.);\n    float torus_sphere_suni = opInt(sphere_dist, torus_dist);\n    return(torus_sphere_suni);\n}\n\nfloat ray_march(vec3 ray_orientation, vec3 ray_direction){ // done\n\tfloat distance_to_scene;\n    float distance_to_surface;\n    vec3  position;\n    \n    distance_to_scene = 0.;\n    for (int i = 0; i < MAX_STEPS; i++){\n        position = vec3(ray_orientation + ray_direction * distance_to_scene);\n        distance_to_surface = get_dist(position);\n        distance_to_scene += distance_to_surface;\n        if (distance_to_scene > MAX_DIST || distance_to_surface < SURF_DIST)\n            break;\n    }\n    return (distance_to_scene);\n}\n\nvec3 get_normal(vec3 cam_position){\n    float d = get_dist(cam_position);\n    vec2 eps = vec2(0.1, 0);\n    \n    vec3 n = d - vec3(\n        get_dist(cam_position - eps.xyy),\n    \tget_dist(cam_position - eps.yxy),\n        get_dist(cam_position - eps.yyx));\n\n    return (normalize(n));\n}\n\nfloat get_light(vec3 p){\n    vec3 light_pos = vec3(0, 1, 2);\n    light_pos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(light_pos-p);\n    vec3 n = get_normal(p);\n    float diffuse_lighting = clamp(dot(n, l), 0., 1.);\n    float d = ray_march(p + n * SURF_DIST * 2., l);\n    if (d < length(light_pos - p))\n        diffuse_lighting *= .1;\n    return (diffuse_lighting);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 1));\n    //vec3 ray_orientation = vec3(0, 3, 2.5);\n    vec3 ray_orientation = vec3(0, 1, 0);\n    float dist = ray_march(ray_orientation, ray_direction);\n    \n    vec3 col;\n    if (dist < MAX_DIST){\n        vec3 p = ray_orientation + ray_direction * dist;\n        float diffuse_light = get_light(p) * 1.;\n        \n        col = vec3(diffuse_light);\n    }\n\telse\n    \tcol = vec3(0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}