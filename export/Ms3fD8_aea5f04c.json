{"ver":"0.1","info":{"id":"Ms3fD8","date":"1524855077","viewed":713,"name":"Times table and mandelbrot set","username":"akhgary","description":"as mentioned in the mathologer video, there is a relation. so  i decided to put them together as well.\n\nafter a lot of experiments, i found the exact circle radius that matches the Mandelbrot set for positive powers. \n\nr = (7+n)/(10+n)\n\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","line","circle","distance","complex","draw","pattern","generalized","modular","times","timestable","timestables"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ===========================================\n// Times tables and mandelbrot set\n// a great video by Mathologer\n// https://www.youtube.com/watch?v=qhbuKbxJsk8\n// ===========================================\n//\n// Mandelbrot set and modular times tables relation\n//\n// in order to match times table with the mandelbrot set\n// the circle is rotated by amount of -pi/(N-1) where N is the power.\n// notice that \"N\" is also the \"times\" value for Times table\n//\n// the circle has a radius of (7+N)/(10+N)\n// this is where the cardioid (for N=2) attaches to secondary circle.\n// it holds for all N>=2. (teseted by zooming 100x at attachment positions)\n//\n// ============================================\n// all of this was achieved by experiment. i have no mathematical proof \n// or what so ever that this is correct or not. \n// but it seems to be some how working this way.\n\nconst float pi = 3.14159265359;\nconst float epsilon = 1e-5;\n\nconst float scale = 1.5;\nconst float thickness = 3.0*scale;\n\n// mandelbrot set properties\nconst int iterations = 100;\nconst float bailout = 100.0;\n\n// times table properties\nconst int modular = 200;\n\n// shared properties\nconst float minPower = 0.0; // minimum power of Z.\nconst float maxPower = 5.0; // maximum power of Z.\nconst float duration = 50.0; // transition cycle duration in seconds.\n\n\nvec2 uvmap(vec2 uv) {\n    return (2.0*uv-iResolution.xy)/iResolution.y;\n}\n\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat smoothout(float dist){\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat smoothfloor(float x) {\n    return x - sin(2.0*pi*x)/(2.0*pi);\n}\n\nfloat clock(){\n    float t = 1.-abs(mod(2.*iTime/duration,2.)-1.);\n    return (maxPower-minPower)*t + minPower;\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothout(dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothout(dist);\n}\n\nvec2 function(vec2 z, float n) {\n    float r = pow(dot(z, z), n/2.0);\n    float th = n*atan(z.y,z.x+epsilon);\n    return r*vec2(cos(th), sin(th));\n}\n\nvec2 dfunction(vec2 z, vec2 dz, float n){\n    // f(f(z))' = f'(f(z))*f'(z)\n\tvec2 df = n*function(z, n - 1.0);\n\treturn vec2(df.x*dz.x-df.y*dz.y, df.x*dz.y + df.y*dz.x) + vec2(1,0);\n}\n\nfloat mandelbrotDistance(float r, float dr) {\n    float dist = r*log(r)/dr;\n    return clamp(pow(dist,0.25),0.0,1.0);\n}\n\nvec3 mandelbrot(vec2 uv, float n) {\n    vec3 set = vec3(0);\n    vec2 c = uv;\n    vec2 z = c;\n    vec2 dz = vec2(1, 0);\n    \n    for(int i = 0; i < iterations && dot(z, z) <= bailout; i++) {\n\t    dz = dfunction(z,dz,n);\n\t    z = function(z,n) + c;\n    }\n    \n    float dist = mandelbrotDistance(length(z), length(dz));\n    \n    if(dot(z, z) > bailout) set = dist+pickColor(n/5.0)/2.0;\n    \n    return clamp(set*0.8,0.0,1.0);\n}\n\nvec3 timesTable(vec2 uv, float times)\n{\n    vec3 col = vec3(0);\n    float len = 2.0*pi/float(modular);\n    float r = (7.0+times)/(10.0+times); // radius of the circle\n    float phase = -pi/(times-1.0);\n    \n    col+=circle(uv,vec2(0),r,false);\n    \n    for(int i = 0; i < modular; i++) {\n        float n = float(i);\n        \n        vec2 c = vec2(cos(n*len+phase),sin(n*len+phase))*r;\n        vec2 p = vec2(cos(n*len*times+phase),sin(n*len*times+phase))*r;\n        \n        col+= circle(uv,c,0.005,true);\n        col+= line(uv,c,p)*pickColor(n/float(modular)/3.+iTime/10.0);\n    }\n    return clamp(col*0.5,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n\t\n    float time = smoothfloor(clock());\n    \n    vec3 color = mandelbrot(uv,time)\n               + timesTable(uv,time);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}