{"ver":"0.1","info":{"id":"mslSDr","date":"1668758329","viewed":175,"name":"Discrete Normal Map Wheel","username":"jbehreandt","description":"Draws a discrete normal map color wheel. Related to normal map wheel color picking for Aseprite. See https://github.com/aseprite/aseprite/issues/3594 .","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["normalmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TAU = 6.2831855;\nconst vec4 RETICLE_COLOR = vec4(1.0, 1.0, 1.0, 1.0);\n\n// Changes to these constants must be matched in Buffer A.\nconst float RETICLE_SIZE = 1.0 / 24.0;\nconst int SECTORS = 12;\nconst int RINGS = 6;\n\n// Constants calculated from other constants.\nconst float OUTER_RING = float(RINGS - 1) / float(RINGS);\nconst float RADIUS = 1.0 - RETICLE_SIZE * 2.0;\nconst float RETICLE_INNER = RETICLE_SIZE * 0.75;\n\nfloat quantizeSigned(in float a, in float b) {\n    return floor(0.5 + a * b) / b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 uvUnsigned = fragCoord / iResolution.xy;    \n    vec2 uvSigned = uvUnsigned * 2.0 - 1.0;\n    uvSigned.x *= aspectRatio;\n    \n    vec2 mUnsigned = iMouse.xy / iResolution.xy;\n    vec2 mSigned = mUnsigned * 2.0 - 1.0;\n    mSigned.x *= aspectRatio;\n    \n    vec2 reticle = vec2(0.0);\n\n    vec4 clrSample = texture(iChannel0, mUnsigned);\n    vec4 clrSigned = clrSample * 2.0 - 1.0;\n    vec2 clr2d = clrSigned.xy;\n\n    float sqMag2d = dot(clr2d, clr2d);\n    if(length(mSigned) >= RADIUS * OUTER_RING) {\n        float heading = atan(mSigned.y, mSigned.x);\n        float sectorDivTau = float(SECTORS) / TAU;\n        heading = quantizeSigned(heading, sectorDivTau);\n        vec2 normal = vec2(cos(heading), sin(heading));\n        clrSample = vec4(normal * 0.5 + 0.5, 0.5, 1.0);\n        reticle = RADIUS * normal;\n    }\n    else if(sqMag2d > 0.0) {\n        reticle = normalize(clrSigned).xy;\n    }\n\n    vec2 diff = uvSigned - reticle;\n    float distSq = dot(diff, diff);\n    float dist = sqrt(distSq);\n        \n    /*\n    if(dist <= RETICLE_SIZE) {\n        if(dist <= RETICLE_INNER) {\n            fragColor = clrSample;\n        } else {\n            fragColor = RETICLE_COLOR;\n        }\n    } else {\n        fragColor = texture(iChannel0, uvUnsigned);\n    }\n    */\n     \n    vec4 background = texture(iChannel0, uvUnsigned);\n    fragColor = mix(background, \n        mix(RETICLE_COLOR, clrSample,\n        smoothstep(RETICLE_INNER, RETICLE_INNER * 0.75, dist - RETICLE_INNER)),\n        smoothstep(RETICLE_SIZE, RETICLE_SIZE * 0.75, dist - RETICLE_SIZE));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const bool CIRCLE_SHAPE = true;\nconst vec4 BACKGROUND = vec4(0.5, 0.5, 1.0, 1.0);\nconst float HALF_PI = 1.5707964;\nconst float TAU = 6.2831855;\nconst float ONE_255 = 1.0 / 255.0;\n\n// Changes to these constants must be matched in Buffer B.\nconst int SECTORS = 12;\nconst int RINGS = 6;\nconst float RETICLE_SIZE = 1.0 / 24.0;\n\n// Constants calculated from other constants.\nconst float RADIUS = 1.0 - RETICLE_SIZE * 2.0;\n\nfloat quantizeSigned(in float a, in float b) {\n    return floor(0.5 + a * b) / b;\n}\n\nfloat quantizeUnsigned(in float a, in float b) {\n    return clamp(ceil((a * b) - 1.0) / (b - 1.0), 0.0, 1.0);\n}\n\nvec3 sphericalToCartesian(in float azim, in float incl, in float radius) {\n    float rhoCosIncl = radius * cos(incl);\n    return vec3(\n        cos(azim) * rhoCosIncl,\n        sin(azim) * rhoCosIncl,\n        radius * sin(incl));\n}\n\nvec3 normalToColor(in vec3 n) {\n    return normalize(n) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Assumes that screen is always wider than it is tall.\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 uvUnsigned = fragCoord / iResolution.xy;\n    vec2 uvSigned = uvUnsigned * 2.0 - 1.0;\n    uvSigned.x *= aspectRatio;\n    \n    float azimSmooth = atan(uvSigned.y, uvSigned.x);\n    float sectorDivTau = float(SECTORS) / TAU;\n    float azimDiscrete = quantizeSigned(azimSmooth, sectorDivTau);\n    float magUv = length(uvSigned);\n    float facSmooth = magUv / RADIUS;\n    float azimDelta = azimDiscrete - azimSmooth;\n    float cosAzimDelta = CIRCLE_SHAPE ?  1.0 : cos(azimDelta);\n    float facDiscrete = quantizeUnsigned(\n        cosAzimDelta * facSmooth, float(RINGS));    \n    float inclDiscrete = HALF_PI - facDiscrete * HALF_PI;\n    \n    vec3 normalDiscrete = sphericalToCartesian(azimDiscrete, inclDiscrete, RADIUS);\n    \n    // Reduce chance of 0x7f / 0x80 difference at pi = 180.\n    vec3 normalAbs =  abs(normalDiscrete);\n    if(normalAbs.x < ONE_255) normalDiscrete.x = 0.0;\n    if(normalAbs.y < ONE_255) normalDiscrete.y = 0.0;\n    if(normalAbs.z < ONE_255) normalDiscrete.z = 0.0;\n\n    vec3 rgb = normalToColor(normalDiscrete);\n    fragColor = \n        mix(BACKGROUND, vec4(rgb, 1.0),\n        smoothstep(0.0125, 0.0, facSmooth - 1.0));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}