{"ver":"0.1","info":{"id":"tdjGzm","date":"1557460956","viewed":58,"name":"ray_tracing_wip","username":"lqt0223","description":"ray_tracing_wip","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// the coordinate: 0, 0, 0 in center, -1, 0, 0 on left edge, xy aspect ratio 1:1;\n\n// data structures\nstruct material_t {\n    vec3 albedo;\n    vec4 diffuse_color;\n    float specular_exponent;\n};\n\nstruct sphere_t {\n  vec3 position;\n    float radius;\n    material_t material;\n};\n\nstruct light_t {\n    vec3 position;\n    float intensity;\n};\n\n// colors\nconst vec4 red_color = vec4(0.3, 0.1, 0.1, 1.);\nconst vec4 ivory_color = vec4(0.4, 0.4, 0.3, 1.);\nconst vec4 white_color = vec4(1., 1., 1., 1.);\n\nconst vec4 background_color = vec4(0.2, 0.7, 0.8, 1);\n\n// materials\nconst material_t ivory = material_t(vec3(0.6, 0.3, 0.1), ivory_color, 50.);\nconst material_t red_rubber = material_t(vec3(0.9, 0.1, 0.0), red_color, 10.);\nconst material_t mirror = material_t(vec3(0.0, 10.0, 0.8), white_color, 1425.);\n\n// scene\nconst int num_of_spheres = 4;\nsphere_t[] spheres = sphere_t[] (\n    sphere_t(vec3(-3., 0.0, -16.), 2., ivory),\n    sphere_t(vec3(-1.0, -1.5, -12), 2., red_rubber),\n    sphere_t(vec3(1.5, -0.5, -18), 3., red_rubber),\n    sphere_t(vec3(9, 5, -18), 4., ivory)\n);\n\nconst int num_of_lights = 3;\nlight_t[] lights = light_t[] (\n  light_t(vec3(-20, 20, -20), 1.5),\n  light_t(vec3(30, 50, -25), 1.8),\n  light_t(vec3(30, 10, 30), 1.7)\n);\n\nvec3 camera_pos = vec3(0, 0, -4);\n\nfloat fov = 3.1415 / 2.5;\n\n// functions\nvec3 reflect2(vec3 incident, vec3 normal) {\n  return incident - normal * 2. * dot(incident, normal);\n}\n\nbool ray_sect_sphere(vec3 origin, vec3 direction, sphere_t sphere, inout float dist) {\n    /*\n    vec3 oc = sphere.position - origin;\n    float opLength = dot(oc, direction);\n    vec3 op = direction * opLength;\n    vec3 pc = oc - op;\n    float pcLength = length(pc);\n    if (pcLength < sphere.radius) {\n        float psLength = sqrt(pow(sphere.radius, 2.) - pow(pcLength, 2.));\n        dist = opLength - psLength;\n      return true;\n    } else {\n        dist = 10000000000000000.;\n        return false;\n    }\n  \n    */  \n    \n    vec3 L = sphere.position - origin;\n    float tca = dot(L, direction);\n    float d2 = dot(L, L) - pow(tca, 2.);\n    if (d2 > pow(sphere.radius, 2.)) {\n        return false;\n    } else {\n        float thc = sqrt(pow(sphere.radius, 2.) - d2);\n        dist = tca - thc;\n        float t1 = tca + thc;\n        if (dist < 0.) {\n            dist = t1;\n        }\n        if (dist < 0.) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nbool scene_sect(\n    vec3 origin,\n    vec3 direction,\n    sphere_t[num_of_spheres] spheres,\n    inout material_t material,\n    inout vec3 sect_point,\n    inout vec3 normal) {\n    float spheres_dist = 10000000000000000.;\n    for (int i = 0; i < num_of_spheres; i++) {\n        float dist_i;\n        sphere_t sphere = spheres[i];\n        bool sect = ray_sect_sphere(origin, direction, sphere, dist_i);\n        if (sect && dist_i < spheres_dist) {\n            spheres_dist = dist_i;\n            sect_point = origin + direction * dist_i;\n            normal = normalize(sect_point - sphere.position);\n            material = sphere.material;\n        }\n    }\n    return spheres_dist < 1000.;\n}\n\nvec4 get_diffuse_color(material_t material, float light_intensity, vec3 light_direction, vec3 normal) {\n    float luminosity = max(dot(light_direction, normal), 0.);\n    return material.diffuse_color * material.albedo.x * light_intensity * luminosity;\n}\n\nvec4 get_specular_color(material_t material, float light_intensity, vec3 light_direction, vec3 ray_direction, vec3 normal) {\n\tfloat luminosity = pow(max(dot(-reflect2(-light_direction, normal), ray_direction), 0.), material.specular_exponent);\n    float intensity = light_intensity * luminosity;\n    return vec4(vec3(1., 1., 1.)*intensity*material.albedo.y, 1);\n}\n\n\nvec4 get_local_color(material_t material, float light_intensity, vec3 light_direction, vec3 ray_direction, vec3 normal) {\n  return get_diffuse_color(material, light_intensity, light_direction, normal) +\n      get_specular_color(material, light_intensity, light_direction, ray_direction, normal);\n}\n\nvec4 cast_ray(vec3 origin, vec3 direction, sphere_t[num_of_spheres] spheres, light_t[num_of_lights] lights, int depth) {\n    material_t material;\n    vec3 sect_point;\n    vec3 normal;\n    if (depth > 4 || !scene_sect(origin, direction, spheres, material, sect_point, normal)) {\n      return background_color;\n    } else {\n        vec3 reflect_dir = normalize(reflect2(direction, normal));\n        vec3 reflect_origin = dot(reflect_dir, normal) < 0. ? sect_point - normal*1e-3 : sect_point + normal*1e-3;\n        \n        vec4 final_color = vec4(0,0,0,1);\n        for (int i = 0; i < num_of_lights; i++) {\n            light_t light = lights[i];\n            vec3 light_dir = normalize(light.position - sect_point);\n            \n            float light_distance = length(light.position - sect_point);\n            vec3 shadow_origin = dot(light_dir, normal) < 0. ? sect_point-normal*1e-3 : sect_point+normal*1e-3;\n            vec3 shadow_pt, shadow_normal;\n            material_t temp_mat;\n            \n            \n            if (\n                (scene_sect(shadow_origin, light_dir, spheres, temp_mat, shadow_pt, shadow_normal)) &&\n                (length(shadow_pt - shadow_origin) < light_distance)\n            ) {\n                continue;\n            }\n      \n            \n            final_color += get_local_color(material, light.intensity, light_dir, direction, normal);\n        }\n        return final_color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinate transformation\n    /*\n    vec2 uv = (fragCoord / iResolution.x);\n    uv.x = (uv.x - 0.5) * 2.;\n    uv.y = (uv.y - 0.5 / iResolution.x * iResolution.y) * 2.;\n    */\n    float width = iResolution.x, height = iResolution.y;\n    float x = (2.*(fragCoord.x+0.5)/width-1.) * tan(fov / 2.)*width / height;\n    float y = (2.*(fragCoord.y+0.5)/height-1.)*tan(fov/2.);\n    \n    lights[0].position.x += cos(iTime) * 100.;\n    lights[0].position.y += -sin(iTime) * 100.;\n    lights[0].position.z += cos(iTime) * 100.;\n    lights[1].position.x += -cos(iTime) * 100.;\n    lights[1].position.y += sin(iTime) * 100.;\n    lights[1].position.z += -cos(iTime) * 100.;\n    lights[2].position.x += cos(iTime) * 100.;\n    lights[2].position.y += -sin(iTime) * 100.;\n    lights[2].position.z += cos(iTime) * 100.;\n    \n    vec3 ray = normalize(vec3(x, y, -1));\n    vec4 rendered = cast_ray(camera_pos, ray, spheres, lights, 4);\n    fragColor = rendered;\n}","name":"Image","description":"","type":"image"}]}