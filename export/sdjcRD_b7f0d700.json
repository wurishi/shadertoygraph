{"ver":"0.1","info":{"id":"sdjcRD","date":"1643638217","viewed":186,"name":"Fork cloud_003 kuma720 167","username":"kuma720","description":"cloud","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"3d23Ww","parentname":"cloud_003"},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec3 uv) {\n  return fract( sin( dot( uv ,vec3(123.,65.,44.) ) ) * 4811.424 );\n}\nfloat pnoise(vec3 uv,float f) {\n\n  vec3 t = uv * f;\n  vec3 v1 = floor(t);\n  vec3 v2 = fract(t);\n\n  float a0 = hash(v1 + vec3(0.,0.,0.));\n  float b0 = hash(v1 + vec3(1.,0.,0.));\n  float c0 = hash(v1 + vec3(0.,1.,0.));\n  float d0 = hash(v1 + vec3(1.,1.,0.));\n\n  float a1 = hash(v1 + vec3(0.,0.,1.));\n  float b1 = hash(v1 + vec3(1.,0.,1.));\n  float c1 = hash(v1 + vec3(0.,1.,1.));\n  float d1 = hash(v1 + vec3(1.,1.,1.));\n\n  float o1 = mix(a0,b0,v2.x);\n  float o2 = mix(c0,d0,v2.x);\n  float o3 = mix(o1,o2,v2.y);\n\n  float o4 = mix(a1,b1,v2.x);\n  float o5 = mix(c1,d1,v2.x);\n  float o6 = mix(o4,o5,v2.y);\n\n  float o7 = mix(o3,o6,v2.z);\n  \n  return o7;\n}\nfloat fbm(vec3 uv) {\n  float o = 0.;\n  float n = 1.;\n  float f = 2.5;\n  \n  for ( int i = 0 ; i < 4 ; ++ i ) {\n    o += pnoise( uv , f ) * n ;\n    f *= 2.; \n    n *= 0.5;\n  }\n\n  return o ;\n}\n\nfloat map( in vec3 p )\n{\n  float f = texture( iChannel0 , p * 0.025 ).x * fbm( p ) ;\n  return max( 0.0, cos( f * 3.8 ) );\n}\n\nfloat sdf(vec3 p) {\n  \n  float l = length( p ) - 2.3;\n  if ( l < 0.0 ) {\n    float CLOUD_DENSITY = 5.5;\n    return map( p ) * CLOUD_DENSITY ;\n  }\n  return 0.;\n}\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\n\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 worldDir ) {\n\n  vec3 cloudColor = vec3( 1.0 , 1.0 , 1.0 );\n  vec3 lightVec = normalize ( vec3( 0.5 , 1. , 0.5 ) );\n\n  int steps = 50;\n  int shadowSteps = 30;\n\n  float invSteps = 1. / float(steps);\n  float invShadowSteps = 1. / float(shadowSteps);\n  float stepDistance = 2. * invSteps;\n  float shadowStepSize = 2. * invShadowSteps;\n\n  vec3 lightColor = vec3(0.,0.,0.);\n  float lightPower = 1.0;\n\n  float dist = length ( eye ) - 1.2;\n  vec3 start = worldDir * dist ;\n  vec3 CurPos = eye + start ;\n  int flg = 0;\n  for(int I=0;I<steps;++I) {\n\n    float cursample = sdf( CurPos ) * 3.;\n    if ( cursample > 0.01 ) {\n\n      vec3 lpos = CurPos;\n\n      float shadowDist = 0.;\n      for ( int S = 0 ; S< shadowSteps ; ++S ) {\n        lpos += lightVec * shadowStepSize ;\n        float lsample = sdf( lpos );\n        shadowDist += lsample;\n      }\n\n      float curdensity = clamp( cursample * invSteps , 0. , 1. );\n      lightColor += exp( - shadowDist * invShadowSteps ) * curdensity * cloudColor * lightPower ;\n      lightPower *= (1. - curdensity) ;\n      \n      if ( lightPower < 0.1 ) {\n        break;\n      }\n    }\n\n    CurPos += worldDir * stepDistance;\n  }\n   \n  vec3 sky = vec3(0.8,0.9,1.0);\n  vec3 o = lightColor + sky - 0.8 ;\n  return vec4( o , 1. );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    float t = iTime * .15;\n    vec3 eye = vec3( cos(t) * 5. , 3.2 , sin(t) * 5. );\n\n\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(90.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n    fragColor = render( uv , eye , worldDir );\n}","name":"Image","description":"","type":"image"}]}