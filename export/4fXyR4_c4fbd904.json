{"ver":"0.1","info":{"id":"4fXyR4","date":"1720820548","viewed":225,"name":" butterfly stained glass 3D","username":"harsukh","description":"butterfly stained glass animation","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["2d","polar","transformation","butterfly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \" butterfly stained glass\" by None. https://shadertoy.com/view/-1\n// 2024-07-12 17:34:35\n\n// Fork of \"[ #07 ] - Flourescent butterfly\" by Yrai. https://shadertoy.com/view/4sfyWB\n// 2024-07-11 19:30:48\n\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float PI = 3.1415926;\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, -s),vec2( s, c));\n}\n\nvec2 rand (vec2 x)\n{return fract(sin(vec2(dot(x, vec2(1.2,5.5)), dot(x, vec2(4.54,2.41))))*4.45);}\n\n\nvec3 voro(vec2 uv){\n    vec2 uv_id = floor(uv);\n    vec2 uv_st = fract(uv);\n    \n    vec2 m_diff;\n    vec2 m_point;\n    vec2 m_neighbor;\n    float m_dist = 10.0; //minimum distance\n    \n    for (int j= -1; j<=1; j++){\n        for (int i =-1; i<=1; i++){\n            \n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = rand(uv_id+neighbor);//find radom point in cell\n            vec2 diff = neighbor+ point- uv_st;//vector between pixel and point\n            \n            float dist = length(diff);\n            if (dist < m_dist){// if distance is smaller than min, set new vals\n                m_dist = dist;\n                m_point = point;\n                m_diff = diff;\n                m_neighbor = neighbor;\n             }\n          }\n     }\n     \n     //uniform border pass\n     m_dist = 10.0;\n     for(int j = -2; j<= 2; j++){\n         for(int i =-2; i<=2; i++){\n             if (i==0 && j==0) continue;\n             //find point in neighboring cells\n             vec2 neighbor = m_neighbor+ vec2(float(i), float(j));\n             vec2 point = rand(uv_id+neighbor);\n             //find distance between adjacent points\n             vec2 diff = neighbor+ point- uv_st;\n             float dist = dot(0.5*(m_diff+diff), normalize(diff-m_diff));\n             m_point= point;\n             m_dist = min(m_dist, dist);\n          }\n      }\n      \n      return vec3(m_point, m_dist);\n } \n \nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return Color;\n}\n\nvec3 blue_grid (vec2 uv, float detail)\n{\n    uv *= detail;\n    vec3 v = voro(uv);\n    vec3 col= clamp(vec3(v.x*0.5, v.y*0.9,1.0)*smoothstep(0.01,0.06, v.z),0.,1.);\n    col= HueShift(col, (-uv.y)*0.01);\n    \n    col+=(0.15-0.1*(-0.2*uv.y))*smoothstep(0.01,0.04, v.z);\n    col= (((col-0.5)*0.85)+0.5)*smoothstep(0.01,0.04, v.z);\n    return col;\n}\n\nvec3 magenta_grid (vec2 uv, float detail)\n{\n    uv *= detail;\n    vec3 v = voro(uv);\n    vec3 col= clamp(vec3(1.0,0.9*v.x, v.y*.7)*smoothstep(0.01,0.06, v.z),0.,1.);\n    col= HueShift(col, (-uv.y)*0.03);\n    col+=0.2*smoothstep(0.01,0.06, v.z);\n    col.yz+=(-0.1*(-0.7*uv.y))*smoothstep(0.01,0.04, v.z);\n    col= (((col-0.5)*0.9)+0.5)*smoothstep(0.01,0.04, v.z);\n    return col;\n}\n\n\nfloat butterfly_mask(vec2 p, float offset) {\n    p*=33.;\n   \tfloat r = length(p);\n\tfloat t = atan(p.y, p.x);\n    \n    float butterfly = \n        7. - .5*sin(t) + 2.5*sin(3.*t) + 2.*sin(5.*t) - 1.7*sin(7.*t) +\n        3.*cos(2.*t) - 2.*cos(4.*t) - 0.4*cos(16.*t) - r;\n\treturn smoothstep(-1.,offset,butterfly);\n}\n\nfloat butterfly_mask2(vec2 p, float offset) {\n    p*=33.;\n   \tfloat r = length(p);\n\tfloat t = atan(p.y, p.x);\n    \n    float butterfly = \n        7. - .5*sin(t) + 2.5*sin(3.*t) + 2.*sin(5.*t) - 1.7*sin(7.*t) +\n        3.*cos(2.*t) - 2.*cos(4.*t) - 0.4*cos(16.*t) - r;\n\treturn smoothstep(offset,-2.0,butterfly);\n}\n\nfloat border = 0.003;\n\n\n\nfloat sdBox2( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    float box = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    \n    return box;\n}\nfloat sdCircle( in vec2 p, in float r ) //uv, radius\n{\n    return length(p)-r;\n}\n\n\nfloat sdVesica2(vec2 p, float r, float d)//radius,sharpness\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    float shape=((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n    \n    return shape;\n}\nfloat wall_mask ( vec2 uv, vec2 wh){\n    uv.x+=0.02;\n    uv.y+=wh.y-0.05;\n    float cuttoff = (1.-smoothstep(-border,border,(sdBox2(uv,wh))));\n    uv.y-=wh.y;\n    float top = sdVesica2(uv,0.5,0.25);\n     top = smoothstep(-border,border,top)*(1.-cuttoff);\n    return (1.0-top);\n}\n\nfloat window_border(vec2 uv_w, float thickness){\n    return wall_mask(uv_w*0.89, vec2(0.25,0.25))\n                    *(1.0-wall_mask(uv_w*thickness, vec2(0.25,0.25)));\n}\n\n\nfloat ring (vec2 uv, float r, float m, float n)\n{\n    float circle =sdCircle(uv,r);\n    return mix( 0.0, 1.0, 1.0-smoothstep(m,n,abs(circle)) );\n}\n\nfloat coolWin(vec2 p, vec2 dim){\n    vec2 uv = p;\n    vec2 wh = dim;\n    float base =wall_mask(uv,wh);\n    \n    uv.y+=wh.y-0.06;\n    \n    uv.x+=0.21;\n    wh*=vec2(0.27,1.15);\n    float mask = 0.;\n    \n    for (float i =0.; i<4.;i++){\n    \n        float bottom = (1.-sdBox2(uv,wh));\n        float cuttoff = (1.-smoothstep(-border,border,(sdBox2(uv,wh))));\n       \n        float top = sdVesica2(vec2(uv.x,uv.y-wh.y),0.36,0.3);\n\n        mask +=mix( 0.0, 1.0, 1.0-smoothstep(0.005,0.006,abs(top)) )*(1.0-cuttoff);\n        mask +=mix( 0.0, 1.0, 1.0-smoothstep(0.006,0.008,abs(1.-bottom)) );\n            \n            \n        uv.x-=0.125;\n    } \n    \n    //2nd layer\n    uv.x=p.x+0.1475;\n    wh=dim*vec2(0.41,1.15);\n    \n    for (float i =0.; i<2.;i++){\n    \n        float cuttoff = (1.-smoothstep(-border,border,(sdBox2(uv,dim*vec2(0.6,1.15)))));\n       \n        float top = sdVesica2(vec2(uv.x,uv.y-wh.y),0.435,0.318);\n      \n        mask +=mix( 0.0, 1.0, 1.0-smoothstep(0.006,0.008,abs(top)) )*(1.0-cuttoff);\n        \n        uv.x-=0.255;\n    } \n    //circles\n    \n    uv=p +vec2(0.15,-0.3);\n    mask += ring(uv,0.055,0.005,0.006);\n    \n    uv=p +vec2(-0.11,-0.3);\n    mask += ring(uv,0.055,0.005,0.006);\n    \n    uv=p +vec2(0.02,-0.38);\n    mask += ring(uv,0.085,0.005,0.006);\n   \n    uv+= vec2(0.035,-0.03);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(-0.035,-0.02);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(-0.035,0.02);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(-0.015,0.035);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(0.015,0.035);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(0.035,0.015);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(0.035,-0.015);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    uv+= vec2(0.015,-0.035);\n    mask += ring(uv,0.035,0.002,0.004);\n    \n    mask = clamp(mask, 0.,1.0);\n    float final = base-mask;\n    return (final);\n}\n\nvec3 sky (vec2 uv_mask, vec2 uv){\n    float m1 = clamp((1.0-butterfly_mask2(uv_mask,-2.3)),0.0,1.0);\n    return blue_grid(uv,30.)*m1;\n}\nvec3 butterfly(vec2 uv_mask, vec2 uv){\n    float m1 = clamp(butterfly_mask(uv_mask,-0.7),0.0,1.0);\n    return magenta_grid(uv,30.) * m1;\n    \n}\n\n\n//https://www.shadertoy.com/view/4ljXDy\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nfloat simplegridnoise(vec2 v)\n{\n    float s = 1. / 256.;\n    vec2 fl = floor(v), fr = fract(v);\n    float mindist = 1e9;\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 pos = .5 + .5 * cos(2. * PI * (.1 + hash(fl+offset)) + vec2(0,1.6));\n            mindist = min(mindist, length(pos+offset -fr));\n        }\n    \n    return mindist;\n}\n\n\nfloat blobnoise(vec2 v, float s)\n{\n    return pow(.5 + .5 * cos(PI * clamp(simplegridnoise(v)*2., 0., 1.)), s);\n}\n\nvec3 blobnoisenrm(vec2 v, float s)\n{\n    vec2 e = vec2(.01,0);\n    return normalize(\n           vec3(blobnoise(v + e.xy, s) - blobnoise(v -e.xy, s),\n                blobnoise(v + e.yx, s) - blobnoise(v -e.yx, s),\n                1.0));\n}\nfloat blobnoises(vec2 uv, float s)\n{\n    float h = 0.0;\n    const float n = 3.0;\n    for(float i = 0.0; i < n; i++)\n    {\n        vec2 p = vec2(0.0,  (i + 1.0) / n) + 1.0 * uv;\n    \th += pow(0.5 + 0.5 * cos(PI * clamp(simplegridnoise(p * (i + 1.0)) * 2.0, 0.0, 1.0)), s);\n    }\n    \n    return h / n;\n}\n\nvec3 blobnoisenrms(vec2 uv, float s)\n{\n    float d = 0.01;\n    return normalize(\n           vec3(blobnoises(uv + vec2(  d, 0.0), s) - blobnoises(uv + vec2( -d, 0.0), s),\n                blobnoises(uv + vec2(0.0,   d), s) - blobnoises(uv + vec2(0.0,  -d), s),\n                d));\n}\n\n\n// ----------------------------------------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 uv0 = uv;\n    uv*=2.5;\n    uv*=rot(-PI/4.0);\n    \n    uv.x *= 1. - sin(iTime*6.)*.05;\n       \n\tvec3 c = vec3(0.180,0.122,0.149);\n    \n    //mosiac color\n    c+=sky(uv,uv0 );\n    c+= butterfly(uv,uv0);\n    c= clamp(c,0.0,1.0);\n    \n    //final color \n    vec2 bgUV= fragCoord.xy / iResolution.xy;\n    \n    vec2 r = vec2(1.0, iResolution.y / iResolution.x);\n\tvec3 n = blobnoisenrms(25.0 * bgUV * r, 3.);\n    \n    vec4 background = texture(iChannel0, bgUV + 0.1 * n.xy);\n    \n    vec4 finalCol = background*vec4(c,1.0)*1.4;\n    \n    //wall masks\n    vec2 uv_w = uv0*1.3;\n    float w = wall_mask(uv_w, vec2(0.25,0.25));   \n    float wall = w;\n    float borderWall = window_border(uv_w,0.95);\n    \n    //make left and right windows\n    vec2 p = fragCoord/iResolution.xy;\n    uv_w+=vec2(0.6,0);\n    wall+=coolWin(uv_w, vec2(0.25,0.25));\n    borderWall+=window_border(uv_w,0.95);\n    \n    uv_w-=vec2(1.2,0);\n    wall+=coolWin(uv_w, vec2(0.25,0.25));\n    borderWall+=window_border(uv_w,0.95);\n    \n    \n    float wallMask = 0.7*borderWall+wall;\n    \n    finalCol*=wallMask;\n    finalCol*=1.;\n    \n    //texture wall\n   // vec4 wallTex = texture(iChannel1,uv0*5.)*0.2;\n    \n   // finalCol+=wallTex*(1.0-wallMask);\n    \n    fragColor = finalCol;\n}\n\n","name":"Image","description":"","type":"image"}]}