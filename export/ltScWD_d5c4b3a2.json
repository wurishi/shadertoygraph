{"ver":"0.1","info":{"id":"ltScWD","date":"1508584295","viewed":89,"name":"ModdedVoronoi","username":"TakeABow","description":"Playing around with a shader generated Voronoi diagram and many different distance functions","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","voronoi","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int np = 10;\n// These points I randomly generated with Javascript and pasted here\nconst vec2 points[np] = vec2[](vec2(0.6186725684191758,0.9013979672059935),\n\tvec2(0.5970432383686626,0.12471788257904826),\n\tvec2(0.6594730167379934,0.8410989366302655),\n\tvec2(0.5248776564385373,0.4754697364264593),\n\tvec2(0.7662812689827636,0.17799346012058437),\n\tvec2(0.30523752784610103,0.6978629438005812),\n\tvec2(0.26613076294909255,0.2683168324534364),\n\tvec2(0.799705127097059,0.9429251242981911),\n\tvec2(0.13100242635343928,0.06884877475879425),\n\tvec2(0.6599766833003013,0.2913968136921876));\n// Same for colors\nconst vec4 colors[np] = vec4[](vec4(0.7976546742546204,0.15035842472222583,0.11517092534598605,1),\nvec4(0.3676184834699774,0.7543026794128258,0.9720752102408108,1),\nvec4(0.8026922289526459,0.5458778952073027,0.4913904956110091,1),\nvec4(0.1024304502528961,0.8802745031748171,0.32917373852984544,1),\nvec4(0.14526995116046937,0.13249780810279943,0.9457994471057671,1),\nvec4(0.6867880687620096,0.46550186538131477,0.29090184261935303,1),\nvec4(0.8542754695802102,0.9713211518912821,0.6503197578215154,1),\nvec4(0.5964152725941196,0.9448139687967412,0.7256535732858176,1),\nvec4(0.11276235745977092,0.7804043752785401,0.5619548588868382,1),\nvec4(0.8827799112035521,0.7362459496773777,0.029401933574938255,1));\n// And weights\nconst float weights[np] = float[](0.25405662431939824,\n0.2010103961845815,\n0.5341501868502319,\n0.31093203585241325,\n0.9655686839904978,\n0.923959944897776,\n0.127810939249262256,\n0.1764120990417084,\n0.49069291177482244,\n0.773088538864926);\n\nconst float dsize = 4.0; // Dot size\n\nfloat inv_dist(vec2 p1, vec2 p2) {\n    return 1.0/length(p1-p2);\n}\n\nfloat weighted_inv_dist(vec2 p1, vec2 p2, float w) {\n    return w/length(p1-p2);\n}\n\nfloat weighted_inv_dist2(vec2 p1, vec2 p2, float w) {\n    return w/pow(length(p1-p2), 2.0);\n}\n\nfloat manhattan_inv_dist(vec2 p1, vec2 p2) {\n    return 1.0/(abs(p1.x-p2.x) + abs(p1.y-p2.y));\n}\n\nfloat weighted_minkowski_inv_dist(vec2 p1, vec2 p2, float f, float w) {\n    return w/pow(pow(abs(p1.x-p2.x), 1.0/f) + pow(abs(p1.y-p2.y), 1.0/f), f);\n}\n\nfloat sin2_dist(vec2 p1, vec2 p2, float w, float ripple) {\n    return pow(sin(length(p1-p2)*w*ripple), 2.0);\n}\n\nfloat dotprod_dist(vec2 p1, vec2 p2, vec2 dir, float w) {\n    vec2 dp = p2-p1;\n    float l = length(dp);\n    \n    return w/(dot(dp, dir)/(l*length(dir))+1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat max_func = 0.0;\n    int max_i;\n    for (int i = 0; i < np; ++i) {\n        float func;\n        // Here comes the evaluation of the function to maximise.\n        // By changing the function we use, we change the look of the diagram\n\n        // Inverse distance (basic Voronoi)\n        func = inv_dist(fragCoord.xy, points[i]*iResolution.xy); \n        // Inverse Manhattan distance (Manhattan Voronoi)\n        func = manhattan_inv_dist(fragCoord.xy, points[i]*iResolution.xy); \n        // Weighted inverse distance (weighted Voronoi #1)\n        func = weighted_inv_dist(fragCoord.xy, points[i]*iResolution.xy, weights[i]); \n        // Weighted inverse distance^2 (weighted Voronoi #2)\n        func = weighted_inv_dist2(fragCoord.xy, points[i]*iResolution.xy, weights[i]); \n        // Weighted inverse distance with time (animated transition)\n        func = weighted_inv_dist(fragCoord.xy, points[i]*iResolution.xy, pow(weights[i], pow(sin(iTime*0.5), 2.0)));\n        // Inverse weighted Minkowski distance (transition between basic and Manhattan Voronoi, weights ignored)\n        func = weighted_minkowski_inv_dist(fragCoord.xy, points[i]*iResolution.xy, 0.5+0.5*pow(sin(iTime), 2.0), 1.0); \n        // Sine^2 of distance of frequency w (fixed ripple)\n        func = sin2_dist(fragCoord.xy, points[i]*iResolution.xy, weights[i], 0.01);\n        /*\n        // Sine^2 of distance of frequency w (animated ripple)\n        func = sin2_dist(fragCoord.xy, points[i]*iResolution.xy, weights[i], iTime*0.003);\n        // Dot product of distance and one given vector (directional Voronoi)\n        func = dotprod_dist(fragCoord.xy, points[i]*iResolution.xy, vec2(1,0), weights[i]);\n\n\t\t/* */\n        \n        if (func > max_func) {\n            max_func = func;\n            max_i = i;\n        }\n\n        // Visualise dots?\n        if (length(fragCoord.xy-points[i]*iResolution.xy) < dsize) {\n            fragColor = vec4(0,0,0,1);\n            return;\n        }\n    \n    // Use x\n    fragColor = vec4(points[max_i].x*0.8+0.2, 0.2, 1.0-points[max_i].x*0.5, 1.0);        \n    // Use y\n    fragColor = vec4(points[max_i].y*0.5+0.5, points[max_i].y, 1.0-points[max_i].y, 1.0);        \n    // Mixed \n    fragColor = vec4(points[max_i].x*0.8+0.2, points[max_i].y*0.5, 1.0-points[max_i].x*0.5, 1.0);        \n    // Use map of colors\n    fragColor = colors[max_i];\n    }\n}","name":"Image","description":"","type":"image"}]}