{"ver":"0.1","info":{"id":"stjXzW","date":"1627238221","viewed":276,"name":"voxel traversal 3D","username":"HalbFettKaese","description":"This shader is the result of plugging my old 2D algorithm into my ray marching template.\nThe algorithm in isolation:\nhttps://www.shadertoy.com/view/wlXBD8\nThe shader is designed to run in vanilla minecraft \"AR\", for which the alternative #define is used","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","voxel","voxeltraversal"],"hasliked":0,"parentid":"slXXWl","parentname":"ray marching template"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEXTURE(coords) texture(iChannel0, coords/16.)\n//#define TEXTURE(coords) texelFetch(Sampler0, ivec2(coords), 0)\n\n#define TWOPI 6.28\nconst vec3 lowerCorner = vec3(0);\nconst ivec3 size = ivec3(2, 2, 2);\nconst int[] blocks = int[size.x*size.y*size.z](\n    0, 2, \n    2, 0, \n    \n    1, 0, \n    0, 1\n);\n// textures[].xy: A texture's start position on the texture atlas\n// textures[].zw: A texture's end position on the texture atlas\nconst vec4[] textures = vec4[3](\n    vec4(0), //air\n    vec4(27 * 16, 2 * 16, 28 * 16, 3 * 16), // Block 1\n    vec4(304, 144, 320, 160) // Block 2\n);\n\nmat3 rotation(float x, float y) {\n    return mat3(\n        1, 0, 0, \n        0, cos(x), sin(x),\n        0, -sin(x), cos(x)\n    ) * mat3(\n        cos(y), 0, -sin(y),\n        0, 1, 0,\n        sin(y), 0, cos(y)\n    );\n}\n\nint getBlock(vec3 p) {\n    p -= lowerCorner;\n    ivec3 iP = ivec3(floor(p));\n    if (\n        any(greaterThan(ivec3(0), iP))||\n        any(greaterThanEqual(iP, size)))\n        return 0;\n    else {\n        return blocks[\n            iP.x + \n            iP.y * size.x + \n            iP.z * size.x * size.y];\n    }\n}\n\nivec2 Traverse(vec3 start, vec3 dir, out vec3 pos) {\n    \n    // The position at which the \n    pos = start;\n    \n    // Fold direction into positive quadrant and save original quadrant\n    vec3 sgn = sign(dir);\n    dir *= sgn;\n    \n    // The length of one square in transformed space\n    vec3 l = 1./dir;\n    \n    vec3 t = (\n        sgn*(0.5-fract(start))+0.5\n    ) / dir;\n    int lastFace = -1;\n    for (int i = 0; i < 20; i++) {\n        int block = getBlock(pos);\n        if (block != 0) return ivec2(block, lastFace);\n        if (t.z < t.x && t.z < t.y) {\n            t.z += l.z;\n            lastFace = 2;\n            pos.z += sgn.z;\n        } else {\n            if (t.x < t.y) {\n                t.x += l.x;\n                lastFace = 0;\n                pos.x += sgn.x;\n            } else {\n                t.y += l.y;\n                lastFace = 1;\n                pos.y += sgn.y;\n            }\n        }\n    }\n    \n    \n\treturn ivec2(0);\n}\n\nvec4 colorAt(vec3 ro, vec3 rd, vec3 center, out float depth) {\n    ro -= center;\n    vec3 col = vec3(0);\n    vec3 pos;\n    ivec2 traversed = Traverse(ro, rd, pos);\n    int block = traversed.x;\n    vec3 normal;\n    vec2 texCoords = vec2(0);\n    vec3 p;\n    if (traversed.y == 0) {\n        normal = vec3(1, 0, 0) * sign(rd.x);\n        float x1 = floor(pos.x);\n        float x2 = ceil(pos.x);\n        float x = abs(ro.x - x1) < abs(ro.x - x2) ? x1 : x2;\n        x -= ro.x;\n        p = ro + x * rd/rd.x;\n        texCoords = fract(p.zy);\n        \n    } else if (traversed.y == 1) {\n        normal = vec3(0, 1, 0) * sign(rd.y);\n        float y1 = floor(pos.y);\n        float y2 = ceil(pos.y);\n        float y = abs(ro.y - y1) < abs(ro.y - y2) ? y1 : y2;\n        y -= ro.y;\n        p = ro + y * rd/rd.y;\n        texCoords = fract(p.xz);\n    } else {\n        normal = vec3(0, 0, 1) * sign(rd.z);\n        float z1 = floor(pos.z);\n        float z2 = ceil(pos.z);\n        float z = abs(ro.z - z1) < abs(ro.z - z2) ? z1 : z2;\n        z -= ro.z;\n        p = ro + z * rd/rd.z;\n        texCoords = fract(p.xy);\n    }\n    depth = length(p);\n    normal *= -1.;\n    \n    if (block != 0) {\n        vec4 texPos = textures[block];\n        vec4 texCol = TEXTURE(mix(texPos.xy, texPos.zw, texCoords));\n        col = mix(col, texCol.rgb, texCol.a);\n        col.rgb *= mix(.5, 1., clamp(dot(normal, normalize(vec3(2, 3, -1))), 0., 1.));\n        return vec4(col, 1);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    if (iMouse.xy == vec2(0))\n        m = vec2(.5);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.xx;\n    float near = 1.;\n    mat3 rotation = rotation(3.14 * (m.y - .5), -TWOPI * (m.x-.5));\n    vec3 rd = normalize(vec3(uv, near) * rotation);\n    vec3 ro = vec3(0) - vec3(0, 0, 1)*rotation* 10.;\n    float depth;\n    vec4 col = colorAt(ro, rd, vec3(-1), depth);\n    \n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}