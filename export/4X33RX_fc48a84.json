{"ver":"0.1","info":{"id":"4X33RX","date":"1724166710","viewed":33,"name":"Usagi","username":"miyaya","description":"Practice of drawing Kanahei's small animal (usagi) by SDF.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define EPSILON 0.0005\n#define PI 3.14159265359\n#define COLOR_BACKGROUND vec3(.741, .675, .82)\n#define COLOR_RABBIT_BODY vec3(0.9, 0.55, 0.55)\n#define COLOR_GROUND vec3(.6, .8, .9)\n#define COLOR_EYE vec3(0.22, 0.2, 0.2)\n\nstruct Surface\n{\n  float sd;\n  vec3 col;\n};\n\nmat2 rotate2d(float theta) \n{\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotate3d(vec3 theta)\n{\n  float sx = abs(sin(theta.x)), cx = -abs(cos(theta.x))*.8;\n  float sy = abs(sin(theta.y)), cy = abs(cos(theta.y));\n  float sz = abs(sin(theta.z)), cz = abs(cos(theta.z));\n  \n  return mat3(cz, -sz, 0., sz, cz, 0., 0., 0., 1.) * \n         mat3(cy, 0., sy, 0., 1., 0., -sy, 0., cy) * \n         mat3(1., 0., 0., 0., cx, -sx, 0., sx, cx); \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 volumeNoise(vec3 p)\n{\n  return textureLod(iChannel0, p, 0.);\n}\n\n//////////////// sdf //////////////////\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{ \n  return length(p - offset) - r;\n}\n\nfloat sdDisplacedSphere(vec3 p, float r, vec3 offset)\n{\n  float displace = sin(p.x*2.)*sin(6.*p.y)*sin(7.*p.z)*0.125;\n  return length(p - offset) - r + displace;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r, vec3 offset)\n{\n  float k0 = length((p-offset)/r);\n  float k1 = length((p-offset)/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r, vec3 offset, vec3 theta)\n{\n  vec3 pp = (p - offset) * rotate3d(theta);\n  float k0 = length(pp/r);\n  float k1 = length(pp/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length(pa - ba*h) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdTorus(vec3 p, vec2 t, vec3 offset)\n{\n  p -= offset;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b, vec3 offset)\n{\n  vec3 q = abs(p - offset) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, float h)\n{\n  return p.y + h;\n}\n\nfloat opUnion(float d1, float d2)\n{\n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n  float h = clamp(.5 + .5*(d2-d1)/k, 0., 1.);\n  return mix(d2, d1, h) - k*h*(1.-h);\n}\n\nSurface opUnion(Surface d1, Surface d2)\n{\n  if(d1.sd >= d2.sd) return d2;\n  return d1;\n}\n\nSurface opSmoothUnion(Surface d1, Surface d2, float k)\n{\n  Surface s;\n  \n  float h = clamp(.5 + .5*(d2.sd-d1.sd)/k, 0., 1.);\n  s.sd = mix(d2.sd, d1.sd, h) - k*h*(1.-h);\n  s.col = mix(d2.col, d1.col, h) - k*h*(1.-h);\n\n  return s;\n}\n\nfloat opIntersection(float d1, float d2)\n{\n  return max(d1, d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k)\n{\n  float h = clamp(.5 - .5*(d2-d1)/k, 0., 1.);\n  return mix(d2, d1, h) + k*h*(1.-h);\n}\n\nfloat opSubtraction(float d1, float d2)\n{\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n  float h = clamp(.5 - .5*(d2+d1)/k, 0., 1.);\n  return mix(d2, -d1, h) + k*h*(1.-h);\n}\n\nfloat opSym(vec3 p, float r, vec3 o, bool x, bool y, bool z)\n{\n  if(x) p.x = abs(p.x);\n  if(y) p.y = abs(p.y);\n  if(z) p.z = abs(p.z);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymEllipsoid(vec3 p, vec3 r, vec3 o, bool x, bool y, bool z)\n{\n  if(x) p.x = abs(p.x);\n  if(y) p.y = abs(p.y);\n  if(z) p.z = abs(p.z);\n  return sdEllipsoid(p, r, o);\n}\n\nfloat opSymCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  float c1 = sdCapsule(p, vec3(-b.x, b.yz), vec3(-a.x, a.yz), r);\n  float c2 = sdCapsule(p, a, b, r);\n  return opUnion(c1, c2);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 spacing)\n{\n  vec3 q = mod(p + .5*spacing, spacing) - .5*spacing;\n  return sdSphere(q, r, o);\n}\n\nfloat opRepLim(vec3 p, float r, vec3 o, float spacing, vec3 times)\n{\n  vec3 q = p - spacing*clamp(round(p/spacing), -times, times);\n  return sdSphere(q, r, o);\n}\n\n////////////// Surface creation /////////////////\n\nSurface getMainBody(vec3 p)\n{\n  Surface mainBody;\n  \n  float head = sdSphere(p, .85, vec3(0, .5, 0));\n  float body = sdSphere(p, .7, vec3(0, -.3, 0));\n  float ears = opSymEllipsoid(p, vec3(.2, .3, .2), vec3(0.45, 1.4, 0.), true, false, false);\n  \n  float t = iTime * 1.5;\n  float armLeft = sdEllipsoid(p, vec3(.3, .14, .2), vec3(.9, -.19, 0.), vec3(0., t, 0.));\n  float armRight = sdEllipsoid(vec3(-p.x, p.yz), vec3(.3, .14, .2), vec3(.9, -.19, 0.), vec3(0., t+3.14/2., 0.));\n  float arms = opUnion(armLeft, armRight);\n  \n  float legLeft = sdEllipsoid(p, vec3(.18, .3, .2), vec3(0.3, -1., 0.), vec3(t+3.14/2., 0., 0.));\n  float legRight = sdEllipsoid(vec3(-p.x, p.yz), vec3(.18, .3, .2), vec3(0.3, -1., 0.), vec3(t, 0., 0.));\n  float legs = opUnion(legLeft, legRight);\n  \n  const float smoothPar = .16;\n  mainBody.sd = body;\n  mainBody.sd = opSmoothUnion(head, ears, smoothPar);\n  mainBody.sd = opSmoothUnion(mainBody.sd, body, .1);\n  mainBody.sd = opSmoothUnion(mainBody.sd, arms, smoothPar);\n  mainBody.sd = opUnion(mainBody.sd, legs);\n  \n  mainBody.col = COLOR_RABBIT_BODY;\n  \n  return mainBody;\n}\n\nSurface getFace(vec3 p)\n{\n  vec3 a = vec3(.34, .76, .74);\n  vec3 b = vec3(.22, .82, .82);\n  float thick = .03;\n  float eyes = opSymCapsule(p, vec3(-a.x, a.yz), vec3(-b.x, b.yz), thick);\n  float nose = sdSphere(p, .06, vec3(0, .76, .84));\n  float line = sdCapsule(p, vec3(0., .74, .86), vec3(0., .6, .86), thick);\n  float mouth = sdTorus(p.xzy, vec2(thick*2., thick), vec3(thick*2., .86, .6));\n  mouth = opUnion(mouth, sdTorus(p.xzy, vec2(thick*2., thick), vec3(-thick*2., .86, .6)));\n  float mouthHelper = sdBox(p, vec3(.7, .3, .15), vec3(0., .3, .86));\n  mouth = opIntersection(mouth, mouthHelper);\n  float menton = sdCapsule(p, vec3(-.02, .46, .86), vec3(.02, .46, .86), thick*.8);\n  \n  Surface face;\n  face.sd = eyes;\n  face.sd = opUnion(face.sd, nose);\n  face.sd = opUnion(face.sd, line);\n  face.sd = opUnion(face.sd, mouth);\n  face.sd = opUnion(face.sd, menton);\n  face.col = COLOR_EYE;\n  \n  return face;\n}\n\nSurface getBlush(vec3 p)\n{\n  Surface blush;\n  float bLeft = sdCappedCylinder(p, vec3(.5, .36, .62), vec3(.5, .36, .7), .28);\n  blush.col = vec3(1., 0., 0.);\n  blush.sd = bLeft;\n  \n  return blush;\n}\n\nSurface getSkin(vec3 p)\n{\n  Surface skin;\n  skin.col = vec3(1., 1., 1.);\n  \n  const float i = -.36;\n  const float j = 0.;\n  const float k = .6;\n  float belly = sdCappedCylinder(p, vec3(j, i, .62), vec3(j, i, .7), .28);\n  float face = sdCappedCylinder(p, vec3(j, k, .8), vec3(j, k, .86), .2);\n  \n  skin.sd = opUnion(belly, face);\n  \n  return skin;\n}\n\nSurface getGround(vec3 p, float h, bool move)\n{\n  Surface ground;\n  float z = move ? p.z + iTime*.26 : p.z;\n  ground.col = vec3(COLOR_GROUND + 0.2*mod(floor(p.x) + floor(z), 2.0));\n  ground.sd = sdPlane(p, h);\n  \n  return ground;\n}\n\nfloat getTransparentSd(vec3 p)\n{\n  return sdDisplacedSphere(p, 0.6, vec3(-2., 1.+.05*sin(iTime*2.), 2.));\n}\n\nfloat getTranslucentSd(vec3 p)\n{\n  //return sdSphere(p, .85, vec3(2., .5, 0));\n  return sdDisplacedSphere(p, .6, vec3(2., 1.+.05*sin(iTime*2.), 2.));\n}\n\nSurface sceneOpaque(vec3 p) \n{\n  Surface scene = getMainBody(p);\n  Surface face = getFace(p);\n  Surface skin = getSkin(p);\n  Surface ground = getGround(p, 1.3, true);\n  \n  scene = opUnion(scene, skin);\n  scene = opUnion(scene, face);\n  scene = opUnion(scene, ground);\n  \n  return scene;\n}\n\nSurface sceneOpaqueTranslucent(vec3 p)\n{\n  Surface opaque = sceneOpaque(p);\n  Surface translucent;\n  translucent.sd = getTranslucentSd(p);\n  opaque = opUnion(opaque, translucent);\n  \n  return opaque;\n}\n\nSurface rayMarch(vec3 origin, vec3 rayDirection) \n{\n  float stepSize = .02;\n  float sampleAttenuation = exp(-stepSize * .06);\n  \n  // opaque\n  Surface opaque;\n  float marchingDepth = MIN_DIST;\n  vec3 posOpaqueTranslucent = origin + (1. + stepSize * (float(MAX_MARCHING_STEPS) + .5)) * rayDirection;\n \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n  {\n    vec3 po = origin + marchingDepth * rayDirection;\n    opaque = sceneOpaque(po);\n    marchingDepth += opaque.sd;\n    \n    if (opaque.sd < PRECISION || marchingDepth > MAX_DIST) \n    {\n      posOpaqueTranslucent = po;\n      break;\n    }\n  }\n  \n  opaque.sd = marchingDepth;\n  \n  if(opaque.sd >= MAX_DIST) \n    opaque.col = COLOR_BACKGROUND;\n    \n  \n  // translucent\n  \n  Surface translucent;\n  float marchingDepth_tl = MIN_DIST;\n  float dIn = -1., dOut = -1.;\n  vec3 col = vec3(0.3, 0.1, 1.), col_tlIn = vec3(0., 1., 0.);\n  bool isTranslucent = false;\n \n  //// forward (ray dir: from cam to obj, like opaque)\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n  {\n    vec3 pt = origin + marchingDepth_tl * rayDirection;\n    if (distance(pt, posOpaqueTranslucent) < PRECISION || marchingDepth_tl > MAX_DIST) break;\n    \n    translucent.sd = getTranslucentSd(pt);\n    //marchingDepth_tl += stepSize;\n    \n    if (translucent.sd < PRECISION) \n    {\n      marchingDepth_tl += stepSize;\n      if (dIn<0.)\n      {\n        dIn = marchingDepth_tl;\n        isTranslucent = true;\n        posOpaqueTranslucent = pt;\n      }\n    }\n    else \n    {\n      marchingDepth_tl += translucent.sd;\n      if(dOut<dIn)\n      {\n        dOut = marchingDepth_tl;\n        break;\n      }\n    }\n  }\n  \n  translucent.sd = isTranslucent? dIn : MAX_DIST + 50.0;\n  float gradient = distance(dOut, dIn);\n  gradient = pow(gradient, 3.0);\n  translucent.col = mix(vec3(0.1, 0.4, 1), vec3(0.1, 0.3, 0.6), gradient);\n  //translucent.col = (col + distance(dOut, dIn) * col_tlIn * 0.8) * 0.9;\n  \n  //// backward (ray dir: from obj to cam, like transparent)\n  //float translucency = 1.;\n  \n  //for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n  //{\n  //  translucency *= sampleAttenuation;\n    \n  //  vec3 pt = posOpaque - marchingDepth_tl * rayDirection;\n  \n  //  if (getTranslucentSd(pt) < PRECISION)\n  //  {\n  //    if (dIn<0. && !isTranslucent) \n  //    {\n  //      dIn = marchingDepth_tl;\n  //      isTranslucent = true;\n  //      translucent.sd = getTranslucentSd(pt);\n  //    }\n  //    //translucent.col = col_tlIn;\n  //    marchingDepth_tl += stepSize;\n  //  }\n  //  else\n  //  {\n  //    if(dOut<dIn) dOut = marchingDepth_tl; \n  //    marchingDepth_tl += getTranslucentSd(pt);\n  //  }\n  //}\n  \n  //translucent.sd = isTranslucent?dOut:marchingDepth_tl;\n  //translucent.col = distance(dIn, dOut) * col_tlIn;\n  \n  opaque = opUnion(translucent, opaque);\n  \n  // transparent\n  float transparency = 1., marchingDepth_tp = MIN_DIST;\n  vec3 col_tp = vec3(1., 0., 0.);\n  \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n  {\n    transparency *= sampleAttenuation;\n    \n    vec3 pt = posOpaqueTranslucent - marchingDepth_tp * rayDirection;\n  \n    if(getTransparentSd(pt) < PRECISION)\n    {\n      opaque.col -= transparency * (vec3(1.) - col_tp) * stepSize;\n      marchingDepth_tp += stepSize;\n    }\n    else\n    {\n      marchingDepth_tp += getTransparentSd(pt);\n    }\n  }\n  \n  // fog\n  float visibility = 1.;\n  vec3 col_fog = COLOR_BACKGROUND, pf = posOpaqueTranslucent;\n  \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n  {\n    pf -= stepSize * rayDirection;\n    \n    vec3 fogPosition = pf;\n    //fogPosition.z += iTime * 0.2;\n    //fogPosition.z %= 1.0;\n    //fogPosition.y += iTime * 2.5;\n    //fogPosition.y %= 1.0;\n    float fogDensity = volumeNoise(fogPosition * 0.05).x; // sample from texture\n    \n    fogDensity = pow(fogDensity, 2.0) * 3.0;\n    \n    opaque.col = mix(col_fog, opaque.col, exp(-fogDensity * opaque.sd * 0.001));\n    \n    if (distance(pf, origin) < visibility)\n        break;\n  }\n  \n  return opaque;\n}\n\nvec3 calcNormal(vec3 p) \n{\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sceneOpaqueTranslucent(p + e.xyy).sd + e.yyx * sceneOpaqueTranslucent(p + e.yyx).sd +\n      e.yxy * sceneOpaqueTranslucent(p + e.yxy).sd + e.xxx * sceneOpaqueTranslucent(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) \n{\n    vec3 front = normalize(lookAtPoint - cameraPos);\n    vec3 right = normalize(cross(vec3(0, 1, 0), front));\n    vec3 up = normalize(cross(front, right));\n\n    return mat3(-right, up, -front);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n\n  if (mouseUV == vec2(0.0)) \n    mouseUV = vec2(0.5); // center mouse on page load\n\n  vec3 col;\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin, camera position\n\n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface d = rayMarch(ro, rd);\n\n  vec3 p = ro + rd * d.sd; // point discovered from ray marching\n  vec3 normal = calcNormal(p); // surface normal\n\n  vec3 lightPosition = vec3(0, 2, 2);\n  vec3 lightDirection = normalize(lightPosition - p);\n\n  float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // [.5, 1.]\n\n  col = vec3(dif) * d.col;\n\n  //float fogDensity = 0.036;\n  //col = mix(COLOR_BACKGROUND, col, exp(-fogDensity * d.sd));\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}