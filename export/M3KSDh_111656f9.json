{"ver":"0.1","info":{"id":"M3KSDh","date":"1719911243","viewed":68,"name":"gradient  - metaballs ","username":"valvw","description":"gradient metaballs","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 400\n#define MIN_DIST 0.0001\n#define MAX_DIST 50.0\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.0);\n    return min(d1, d2) - h * h * 0.25 / k;\n}\n\nfloat scene(vec3 p) {\n    float k = 0.4; \n    float d = sdPlane(p, vec3(0.0, 1.0, 0.0), 1.0); \n\n    for (int i = 0; i < 10; i++) {\n        float angle = iTime * (0.5 + float(i) * 0.1);\n        vec3 pos = vec3(sin(angle + float(i)) * 1.5, cos(angle * 1.5 + float(i)) * 1.5, sin(angle * 0.5 + float(i)) * 1.5);\n        d = opSmoothUnion(d, sdSphere(p - pos, 0.6), k);\n    }\n\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        scene(p + e.xyy) - scene(p - e.xyy),\n        scene(p + e.yxy) - scene(p - e.yxy),\n        scene(p + e.yyx) - scene(p - e.yyx)\n    ));\n}\n\nvec3 getColor(vec3 p) {\n    vec3 color = vec3(0.5 + 0.5 * sin(p.x + iTime),\n                      0.5 + 0.5 * sin(p.y + iTime),\n                      0.5 + 0.5 * sin(p.z + iTime));\n    return color;\n}\n\nvec3 getGlowColor(vec3 p) {\n    vec3 glowColor = vec3(0.5 + 0.5 * cos(p.x + iTime),\n                          0.5 + 0.5 * cos(p.y + iTime),\n                          0.5 + 0.5 * cos(p.z + iTime));\n    return glowColor;\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.01;\n    for (int i = 0; i < 50; i++) {\n        float h = scene(ro + rd * t);\n        if (h < 0.001) {\n            res = 0.0;\n            break;\n        }\n        t += h;\n        if (t > 10.0) break;\n    }\n    return res;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = scene(p);\n        if (d < MIN_DIST) break;\n        t += d;\n        p = ro + t * rd;\n        if (t > MAX_DIST) break;\n    }\n\n    vec3 color = vec3(0.0);\n    if (t < MAX_DIST) {\n        vec3 normal = getNormal(p);\n        vec3 lightDir = normalize(vec3(5.0, 5.0, -5.0));\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        vec3 baseColor = getColor(p);  \n        vec3 glowColor = getGlowColor(p);\n\n        vec3 planeColor = vec3(0.0); \n        if (abs(p.y + 1.0) < MIN_DIST) {\n            vec3 shadowColor = vec3(0.0);\n            for (int i = -3; i <= 3; i++) {\n                for (int j = -3; j <= 3; j++) {\n                    vec3 offset = vec3(float(i) * 0.02, 0.0, float(j) * 0.05);\n                    vec3 shadowPos = vec3(p.x + offset.x, -1.0, p.z + offset.z); \n                    float shadowFactor = shadow(shadowPos, normalize(vec3(0.0, 1.0, 0.0)));\n                    shadowColor += baseColor * (1.0 - shadowFactor);\n                }\n            }\n            shadowColor /= 49.0;\n            color = planeColor + shadowColor * 0.5;\n        } else {\n            color = mix(baseColor * diff, glowColor, 0.5);\n        }\n\n        vec3 ambient = vec3(0.01);\n        color += ambient;\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.7, -5.0); \n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    vec3 color = render(ro, rd);\n    \n    if (color == vec3(0.0)) {\n        color = vec3(0.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}