{"ver":"0.1","info":{"id":"4dByRG","date":"1492484631","viewed":189,"name":"G to SchlickPhase K","username":"TinyTexel","description":"Approximate mapping (green) from asymmetry parameter g to Schlick phase func's parameter k.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["scatteringvolumerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// G to SchlickPhase K\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nThe asymmetry parameter g of a phase function is equal to its first moment:\ng = Integrate[phase[mu] * mu, {mu, -1, 1}]*2*Pi\nmu : cos(theta)\n\nWhile g, in general, does not uniquely describe the angular single scattering behavior, \nit nevertheless bears quite some importance as the asymptotic flux extinction \ninside an homogeneous disperse medium only depends on g (in addition to the radiance extinction\ncoefficient and the single scattering albedo) and not on the exact shape of the phase func.\n(source: Light Scattering Media Optics: Problems and Solutions (3rd Edition) A.A. Kokhanovsky)\n(In contrast to radiance extinction, flux extinction also considers the effect of in-scattering) \n\nConveniently, in case of the Henyey-Greenstein phase function g directly parameterizes the\nscattering behavior. \ng = Integrate[HG[mu, g] * mu, {mu, -1, 1}]*2*Pi\n\nTo improve performance, the HG phase func can be approximated by\nthe Schlick phase function, which is parameterized in a similar fashion. \nHowever, the parameter k of the Schlick phase func is not exactly equal to g. \nA closed form approach to map a given k to the asymmetry parameter g of the corresponding \nSchlick phase func can be obtained by means of integration:\ng = Integrate[Schlick[mu, k] * mu, {mu, -1, 1}]*2*Pi\n\nThe resulting function is implemented in SchlickKtoG(float k) and it's graph is shown in red.\nUnfortunately, the inverse mapping from a given g to k, as might be required for approximating \na HG by a Schlick phase func, has, to the best of my knowledge, no closed form solution.\nThe approximate inverse mapping implemented in GtoSchlickK(float g) (shown in green) has an \nmaximal absolute error < 0.002 which should be sufficient for most rendering related use cases.\n\n\nThe blue graph shows a mapping that approx minimizes the root-mean-square error. For rendering,\nthis one is prob more usefull since we usually dont care about the asymptotic props of the light field.\n*/\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;    \n\nfloat Plot(float f, float y)\n{\n    float v = f - y;\n    v /= length(vec2(dFdx(v), dFdy(v)));\n    v = clamp01(1.0 - abs(v));\n    \n    return v;\n}\n\n\nfloat HenyeyGreensteinPhF(float cosTheta, float g)\n{\n\tfloat sqrG = g * g;\n\t\n\tfloat t0 = 1.0 - sqrG;\n\tfloat t1 = 1.0 + sqrG - 2.0 * g * cosTheta;\n\t\n\t// return t0 * rsqrt(max(0.0, t1*t1*t1));// nan if ct&&g==-1 or ct&&g==1\n\treturn t0 * rsqrt(max(1.0e-37, t1*t1*t1));\n}\n\nfloat SchlickPhF(float cosTheta, float k)\n{\t\n\tfloat t0 = 1.0 - k * k;\n\tfloat t1 = 1.0 - k * cosTheta;\n\t\n\t//return t0 / (t1 * t1);// nan if ct&&g==-1 or ct&&g==1\n\treturn t0 / max(1.0e-37, t1 * t1);    \n}\n\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhF(cosTheta, g) * RcpPi4;\n}\n\nfloat SchlickPDF(float cosTheta, float k)\n{\n    return SchlickPhF(cosTheta, k) * RcpPi4;\n}\n\n\n\nfloat ArcTanh(float x)\n{\n   return 0.5 * log((1.0 + x) / (1.0 - x));\n}\n\nfloat SchlickKtoG(float k)\n{\n    float k2 = k * k;\n    \n    float g = (k + (k2 - 1.0) * ArcTanh(k)) / k2;\n    \n    return g;\n}\n    \nfloat GtoSchlickK(float g)\n{\t\n    const float n = 0.22785;\n \n    float k = ((n * abs(g) - (n + 0.5)) * g*g  + 1.5) * g;\n\n    return k;\n}\n\n\n// this one minimizes the RMS error between the two phase functions\n// more usefull if asymptotic properties of the light field dont matter\n// like when only single scattering is considered (f.i. in case of Lommel-Seeliger/Hapke BRDF)\nfloat GtoSchlickK2(float g)\n{\t\n    const float a = -0.1322072338291953;\n    const float b = -0.7355855323416429;\n    const float c = 0.5 + a;\n \n    float k = g * (1.5 + g*g * (a + (b + c * abs(g)) * abs(g)));\n\n    return k;\n}\n\n// this one minimizes the RMS error between the logarithms of the two phase functions\n// pretty similar to GtoSchlickK; prob not very usefull\nfloat GtoSchlickK3(float g)\n{\t\n    const float a = -0.9982416960625763;\n    const float b =  0.6931389921251526;\n    const float c = -0.19489729606257716;\n \n    float k = g * (1.5 + g*g * (a + (b + c * abs(g)) * abs(g)));\n\n    return k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    vec2 tex = uv / iResolution.xy;\n    vec2 tex2 = (tex) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float x = tex2.x;\n    float y = tex2.y;\n    \n    vec3 col = vec3(0.0);\n    float cos0 = cos((x - 1.5) * Pi);\n    float cos1 = cos0/Pi*2.0 * 0.5 + 0.5;\n    col = mix(col, vec3(0.05), Plot(0.5, y));\n    col = mix(col, vec3(0.05), Plot(0.5, x));\n    col = mix(col, vec3(0.01), Plot(x, y));\n    \n    col = mix(col, vec3(0.1, 0.0, 0.2), Plot(GtoSchlickK3((x*2.0-1.0))*0.5+0.5, y));\n    col = mix(col, vec3(0.0, 0.0, 1.0), Plot(GtoSchlickK2((x*2.0-1.0))*0.5+0.5, y));\n    \n    col = mix(col, vec3(1.0, 0.0, 0.0), Plot(SchlickKtoG((x*2.0-1.0))*0.5+0.5, y));    \n    col = mix(col, vec3(0.0, 1.0, 0.0), Plot(GtoSchlickK((x*2.0-1.0))*0.5+0.5, y));\n\n  \n    if(x > 1.0 || x < 0.0) col = vec3(0.0);\n    \n    //col = vec3(v);\n\t//fragColor = vec4(tex2, 0.0,1.0);\n    fragColor = vec4(pow(clamp01(col), vec3(1.0/2.2)), 0.0);\n}","name":"Image","description":"","type":"image"}]}