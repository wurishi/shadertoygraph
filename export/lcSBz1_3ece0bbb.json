{"ver":"0.1","info":{"id":"lcSBz1","date":"1724634458","viewed":33,"name":"Drop 01a - colors","username":"Elsio","description":"Colorir shaders desse tipo não é uma coisa trivial. Você tem que escolher IDs e eles tem de ser coerentes em todo o trajeto do objeto. Mas, o número de cores possíveis depende do número de ids. Então, colorir passa a ser um algoritmo a mais pra se pensar.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","tutorial","block","shape","traversal","slength"],"hasliked":0,"parentid":"4fByDV","parentname":"Drop 01a explained"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cor(a) (cos(6.3 * vec4(h11(a), h11(a + 1.), h11(a + 2.), 0)) * .5 + .6)\n#define h11(k) fract(sin(k * 453.2734) * 994.3434)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2   r = iResolution.xy, q,\n           p = 8. * vec2(u + u - r) / r.y;\n\n    float  h = 34., c1, c,\n           k = floor(p.x),\n           t = h * h11(k) + iTime;\n\n     p.y += sin(k + t) * .3 + fract(t);\n\n     c = min(floor(p.y), 0.) + floor(t);\n\n     p.y < 0.\n         ? h = 1.\n         : h;\n\n     u = fract(p) - .5;\n\n     p.y += (h - 1.) / 2. * fract(t);\n\n     q = vec2(\n                u.x,\n                mod(p.y, h) - h / 2.\n             );\n\n     \n     \n     \n     o = vec4(\n               // rain\n               smoothstep(c1 = 24. / r.y, .0,\n                       length(q) - .45\n               ) * cor(h11(floor(p.x) + h11(c)))\n\n                 // grid\n               + smoothstep(0., c1,\n                       + min(               // box\n                             (r = abs(u) - .5, 0.),\n                             max(r.x, r.y))\n                       + .05\n                 ) * .1\n         );\n}","name":"Image","description":"","type":"image"}]}