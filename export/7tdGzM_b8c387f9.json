{"ver":"0.1","info":{"id":"7tdGzM","date":"1635902920","viewed":75,"name":"color highlight using okLAB","username":"bennett","description":"Push the image toward a selected color, if close, or further away, if far. \n\nSuggestions welcome","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["postfx","color","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n// implementation from https://www.shadertoy.com/view/WtccD7\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n    vec3 lms = invB * c;\n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n    vec3 lms = fwdA * c;\n    return fwdB * (lms * lms * lms);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 targetCol = vec3(0.2,0.3,0.8);\nfloat power = .01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 inCol = texture(iChannel0,uv).xyz;\n    \n    vec3 targetLAB = oklab_from_linear_srgb(targetCol);\n    \n    vec3 inputLAB = oklab_from_linear_srgb(inCol);\n    \n    //color complement of L,a,b is L,-a,-b I think \n    vec3 complementLAB = vec3(targetLAB.x,-targetLAB.y,-targetLAB.z);\n    \n    //float distToTarget = distance(targetLAB,inputLAB);\n    //float distToComplement = distance(complementLAB,inputLAB);\n    \n    float distSqToTarget = dot((targetLAB-inputLAB),(targetLAB-inputLAB));\n    float distSqToComplement = dot((complementLAB-inputLAB),(complementLAB-inputLAB));\n    \n    //push toward either target or complement, harder if close?\n    float timeFactor = sin(iTime*2.0)*0.5 + 0.5;\n    float powerToTarget = power*timeFactor/(distSqToTarget);\n    float powerToComplement = power*timeFactor/(distSqToComplement);\n    \n    vec3 outLAB = mix(inputLAB,complementLAB, powerToComplement);\n    outLAB = mix(outLAB, targetLAB, powerToTarget);\n    \n    vec3 outCol = linear_srgb_from_oklab(outLAB);\n    \n    //swatch to see target color\n    if ((uv.x > 0.9)&&(uv.y>0.85)) outCol = targetCol;\n    \n    fragColor = vec4(outCol,1.0);\n}","name":"Image","description":"","type":"image"}]}