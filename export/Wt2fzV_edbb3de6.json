{"ver":"0.1","info":{"id":"Wt2fzV","date":"1599385602","viewed":781,"name":"easy adaptive sampling: raytrace","username":"FabriceNeyret2","description":"Application of [url]https://shadertoy.com/view/3ljfRG[/url]\noversample only where aliased Left: none, for reference.\nMouse.x : ref separator   \nSPACE: show where oversampling is done ( B&W area - colors where LOD#0 )","likes":23,"published":3,"flags":48,"usePreview":0,"tags":["raytracing","antialiasing","sampling","optimization","adaptive","gpmipmap","spacefungus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// adapted from https://shadertoy.com/view/3ljfRG\n//          and https://shadertoy.com/view/WtjBzV\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n\n//#define T(U,l)          texelFetch(iChannel0, ivec2(U)>>l, l)\n  #define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n//#define M(U,l)          T(U,l).w\n  #define M(U,l)        ( length( T(U,l).rgb )*.58 ) \n  #define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n   \n    O -= O;                             // background\n    vec4 C = vec4(0);\n\n    float n = float(N),\n       // m = M( u, 3 ),                // check neighborhood. Here: LOD #2 of mask\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n\n    if ( u.x > s\n     //  && abs(m-M(u,0)) > eps ) {     // neighborhood does not agree\n         && length( T(u,3) - T(u,0) ) > eps ) { // thanks Gijs !\n        for (int k=0; k<N*N; k++) {     // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            C += f(  U +  2.*D/R.y , iTime);\n        }\n        C /= n*n;\n    }\n    else                                // LOD#0 is ok\n        C = T( u, 0 ),\n        keyToggle(32)                   // SPACE: show red/blue where not oversampled\n            ? C.r -= .5*C.a, C.b += .5*(1.-C.a) , C.a = 1.: n;\n        \n    O = mix( O, C, C.a );\n    if ( abs(u.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n    O = pow( O, vec4(1./2.2) );         // to sRGB\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// --- custom function or image or render\n\n#define R  iResolution.xy\n\n\n// Space fungus https://www.shadertoy.com/view/lsSBWh\nvec4 f(vec2 U, float t) {\n    float a,b;                                             // materials id\n    mat2  rot = mat2( cos( .1*t + vec4(0,33,11,0)) );  \n    vec3  D = normalize( vec3(U,-1) ),                     // ray direction\n          p = vec3(0,0,13), q;                             // ray origine\n    \n    vec4  O = vec4(1);\n    for ( ; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= rot,\n        q.yz *= rot,\n        t = max( length(q) - 9.,                           // Sphere\n                 abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ),    // EggCarton\n        t = max( t, 8.5-length(q) ),                       // inner hole\n        q = mod(q,.5)-.25, t = max(t,.2-length(q) ),       // cheese holes \n        p += t*D;\n\n    if (O.x>0.) O.r -= b/30., O.g -= a, O*=O,              // coloring\n                O.a = 1.;                                  // hit -> opaque\n       else     O -= O;\n    return O;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = ( 2.*u - R ) / R.y;      // normalized centered coords\n    O = f( U, iTime );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}