{"ver":"0.1","info":{"id":"ttdcWn","date":"1674974623","viewed":145,"name":"cosmic - chenhang","username":"chenhang","description":"cosmic","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cosmic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 50;\n\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\n/**\n * 逆矩阵\n */\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n/**\n * 摄像机位置和朝向\n */\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float radius = 4.0;\n    float theta = 0.3 + 5.0*mouse.x - iTime*0.5;\n    float phi = 3.14159*0.4;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n/**\n * 噪声函数\n */\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// 此处以上的代码为常规方法定义，可不管\n\n\n/**\n * 球体变形\n */\nvec2 map( vec3 pos ){  \n    // 控制球体变形的幅度、频率、快慢\n    float sphere = distSphere(pos, 1.75) + noise(pos * 1.0 + iTime*0.55) * 0.5;   \n    float t1 = sphere;\n   \n   \treturn vec2( t1, 1.0 );\n    \n}\n\n/**\n * 计算法向量\n */\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n/**\n * 球体颜色渲染\n */\nvoid renderColor( vec3 ro , vec3 rd, inout vec3 color, vec3 currPos )\n{\n    // 计算出球体法向量\n    vec3 normal = calcNormal( currPos );\n    // 根据当前球体的点随机偏移，计算出偏移点的法向量\n    vec3 normal_distorted = calcNormal( currPos +  noise(currPos*1.5 + vec3(0.0,0.0,sin(iTime*0.75))) );\n\n    // 计算视线与法向量的夹角，正对视线的位置 ndotl 越大（1），与视线相切的位置 ndotl 越小（0）\n    float ndotl = abs(dot( -rd, normal ));\n    // 计算视线与随机偏移点法向量的夹角，正对视线的位置 ndotl_distorted 越大（1），与视线相切的位置 ndotl_distorted 越小（0）\n    float ndotl_distorted = abs(dot( -rd, normal_distorted ));\n    // 把 ndotl 的值倒转，可简单理解为 rim = 1.0 - ndotl，且把值变化曲线从余弦曲线变为多次幂曲线\n    float rim = pow(1.0-ndotl, 6.0);\n    // 同上\n    float rim_distorted = pow(1.0-ndotl_distorted, 6.0);\n\n    // 将基础色与法向量颜色混合，混合比例通过 rim_distorted 的值控制\n    color = mix( color, normal*0.5+vec3(0.5), rim_distorted+0.1 );\n    // 边缘提亮\n    color += rim;\n}\n\n/**\n * 光线步进&&计算颜色\n */\nbool renderRayMarch(vec3 ro, vec3 rd, inout vec3 color ) \n{\n    const int maxSteps = NUM_OF_TRACE_STEPS;\n        \n    float t = 0.0;\n    float d = 0.0;\n    \n    // 计算出视线与球体相交的（光线步进相关，视觉可不管）\n    for(int i = 0; i < maxSteps; ++i) \n    {\n        vec3 currPos = ro + rd * t;\n        d = map(currPos).x;\n        if(d < INTERSECTION_PRECISION) \n        {\n            break;\n        }\n        \n        t += d;\n    }\n    \n    if(d < INTERSECTION_PRECISION) \n    {\n        // 视线与球体相交，计算出球体坐标（光线步进相关，视觉可不管）\n        vec3 currPos = ro + rd * t;\n        // renderColor 与球体视觉强相关，需要关注\n        renderColor( ro, rd, color, currPos );\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 归一化坐标系（光线步进相关，视觉可不管）\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // 定义相机位置（光线步进相关，视觉可不管）\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // 根据相机位置和观察点计算视线矩阵（光线步进相关，视觉可不管）\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// 根据矩阵计算视线方向（光线步进相关，视觉可不管）\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    // 定义基础色\n    vec3 col = vec3(0.9);\n    // 使用光线步进渲染球体\n    renderRayMarch( ro, rd, col );\n    \n    // 可选，给四个角添加渐变阴影\n    float vignette = 1.0 - smoothstep(1.0 , 2.5, length(p));\n    col.xyz *= mix( 0.7, 1.0, vignette);\n   \n    // 把最终颜色输出\n    fragColor = vec4( col , 1. );\n}","name":"Image","description":"","type":"image"}]}