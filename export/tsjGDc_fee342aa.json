{"ver":"0.1","info":{"id":"tsjGDc","date":"1551338148","viewed":696,"name":"Try cloud raymarching","username":"edo_m18","description":"Try cloud raymarching\n\nRefer to : https://shaderbits.com/blog/creating-volumetric-ray-marcher\nAlso refer to : https://www.shadertoy.com/view/WdXGRj","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///\n/// Refer to : https://shaderbits.com/blog/creating-volumetric-ray-marcher\n///\n/// Also refer to : https://www.shadertoy.com/view/WdXGRj\n///\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\n////////////////////////////////////////////////////////////////////\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 uu = cross(ww, up);\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, ww);\n}\n\nfloat scene(vec3 p)\n{\n    return 1.0 - length(p) * 0.1 + fbm(p * 0.3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    const int sampleCount = 48;\n    const int shadowSampleCount = 8;\n    \n    float camDist = 25.0;\n    \n    vec2 mo = vec2(iTime * 0.1, cos(iTime * 0.25) * 3.0);\n    vec3 ro = camDist * normalize(vec3(cos(2.75 - 3.0 * mo.x), mo.y * 0.2, sin(2.75 - 3.0 * mo.x)));\n\n    vec3 ta = vec3(0.0);\n    \n    mat3 c = camera(ro, ta);\n    float fl = 1.0;\n    vec3 dir = c * normalize(vec3(uv, fl));\n        \n    float zmax = 25.0;\n    float zstep = zmax / float(sampleCount);\n    float invStep = 1.0 / float(sampleCount);\n    \n    float shadowmax = 3.0;\n    float shadowstep = shadowmax / float(shadowSampleCount);\n    float invShadowStep = 1.0 / float(shadowSampleCount);\n    \n    vec3 p = ro;\n    \n    vec3 lightenergy = vec3(0.0);\n    float transmittance = 1.0;\n    \n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n    \n    for (int i = 0; i < sampleCount; i++)\n    {        \n        if (transmittance < 0.1)\n        {\n            break;\n        }\n        \n        float density = scene(p);\n        \n        if (density > 0.001)\n        {\n            vec3 lpos = p;\n            float shadow = 0.0;\n            \n            for (int s = 0; s < shadowSampleCount; s++)\n            {\n                lpos += light * shadowstep;\n                shadow += scene(lpos);\n            }\n                        \n            float opacity = 20.0;\n            float ds = density * invStep;\n            float linearDensity = ds * opacity;\n            linearDensity = clamp(linearDensity, 0.0, 1.0);\n            \n            float shadowStrength = 3.0;\n            float shadowterm = exp(-shadow * invShadowStep * shadowStrength);\n            \n            vec3 cloudCol = vec3(1.1, 0.9, 0.5);\n            float cloudDarkness = shadowterm * linearDensity * transmittance;\n            lightenergy += cloudCol * cloudDarkness;\n            \n            vec3 offset = p + vec3(0.0, 0.25, 0.0);\n            vec3 col = vec3(0.15, 0.45, 1.1);\n            \n            lightenergy += col * (exp(-scene(offset) * 0.2) * linearDensity * transmittance);\n            \n            shadow = 0.0;\n            lpos = p + vec3(0.0, 0.0, 0.05);\n            float lsample = scene(lpos);\n            shadow += lsample;\n            \n            lpos = p + vec3(0.0, 0.0, 0.1);\n            lsample = scene(lpos);\n            shadow += lsample;\n            \n            lpos = p + vec3(0.0, 0.0, 0.2);\n            lsample = scene(lpos);\n            shadow += lsample;\n            \n            float ambientDensity = 2.0;\n            vec3 ambcolor = vec3(1.0, 0.2, 0.3);\n            lightenergy += ambcolor * (exp(-shadow * ambientDensity) * linearDensity * transmittance);\n        \n            transmittance *= 1.0 - linearDensity;\n        }\n        \n        p += dir * zstep;\n    }\n    \n    vec3 skyColor = mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), uv.y + 0.75);\n   \n    lightenergy += skyColor * transmittance;\n    \n    fragColor = vec4(lightenergy, 1.0);\n}","name":"Image","description":"","type":"image"}]}