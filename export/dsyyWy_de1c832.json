{"ver":"0.1","info":{"id":"dsyyWy","date":"1699648649","viewed":30,"name":"slimani_mayouf_m1_image","username":"abdennour","description":"test for tp image","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\nstruct Cylinder {\n    vec3 Base;        // Base position of the cylinder\n    vec3 Axis;        // Axis of the cylinder (normalized)\n    float Radius;     // Radius of the cylinder\n    float Height;     // Height of the cylinder\n    int textureId;    // Texture ID\n};\nstruct Torus {\n    vec3 center;\n    float R;       // Major radius\n    float r;       // Minor radius\n    int textureId; // Texture ID\n};\nstruct Capsule {\n    vec3 Base;       // Base position of the first sphere\n    float Radius;     // Radius of the spheres\n\n    // Additional properties specific to the capsule\n    vec3 Axis;        // Axis of the cylinder (normalized)\n    float Height;     // Height of the cylinder\n    int textureId;    // Texture ID\n};\nstruct Ellipsoid {\n    vec3 c;           // Center of the ellipsoid\n    vec3 radii;       // Radii along the three principal axes\n    int textureId;    // Texture ID for the ellipsoid\n};\nstruct Cube {\n    vec3 minCorner;  // Minimum corner of the cube\n    vec3 maxCorner;  // Maximum corner of the cube\n    int textureId;   // Texture ID\n};\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n};\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Material(vec3(.7,.5,.4));\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.5,.5,.5)+f*vec3(.7);\n        return Material(col);\n    }\n    else if(i == 4){\n        float r=sqrt(p.x*p.x+p.y*p.y);\n        float colorValue = 1. + 1.5 * cos (13.1415927 * r ) ;\n        return Material(vec3(colorValue, 2.0 - colorValue, 1.0));\n    }\n    else if(i == 5)\n    {\n        // Wood texture\n        float r = sqrt(p.x*p.x + p.y*p.y);\n\n        // Increase noise frequency to make circles more imperfect\n        float noise = 0.1 * sin(100.0 * r);\n\n        // Add more noise to break up perfect circles\n        float woodPattern = 1. + 1.5 * cos(13.1415927 * (r + noise));\n\n        // Dark brown lines with shininess\n        float darkBrownLines = smoothstep(0.25, 0.35, woodPattern);\n\n        // Make brown lines thinner\n        float thinnerLines = smoothstep(0.28, 0.32, darkBrownLines);\n\n        // Combine colors based on the wood pattern, thinner brown lines, and increased noise\n        vec3 woodColor = mix(vec3(0.6, 0.4, 0.2), vec3(0.8, 0.5, 0.4), woodPattern);\n        vec3 darkBrownLinesColor = mix(woodColor, vec3(0.2, 0.1, 0.05), thinnerLines);\n        vec3 finalColor = mix(darkBrownLinesColor, woodColor, noise);\n\n        return Material(finalColor);\n    }\n\n    return Material(vec3(0));\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n//ellipsoid intersection\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x)\n{\n    // Translate the ray origin to the ellipsoid's local coordinate system\n    vec3 oc = ray.o - ellipsoid.c;\n\n    // Calculate coefficients for the quadratic equation\n    vec3 invRadiiSq = 1.0 / (ellipsoid.radii * ellipsoid.radii);\n    float a = dot(ray.d, ray.d * invRadiiSq);\n    float b = 2.0 * dot(oc, ray.d * invRadiiSq);\n    float c = dot(oc, oc * invRadiiSq) - 1.0;\n\n    // Calculate the discriminant of the quadratic equation\n    float discriminant = b * b - 4.0 * a * c;\n\n    // Check for intersection\n    if (discriminant > 0.0)\n    {\n        // Calculate the two possible solutions\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Ensure t1 is the smaller value\n        if (t1 > t2)\n        {\n            float temp = t1;\n            t1 = t2;\n            t2 = temp;\n        }\n\n        // Check if t1 is within the valid range\n        if (t1 >= 0.0)\n        {\n            // Calculate the intersection point using the ray equation\n            vec3 intersectionPoint = ray.o + t1 * ray.d;\n\n            // Calculate the normal at the intersection point\n            vec3 normal = (intersectionPoint - ellipsoid.c) / ellipsoid.radii;\n\n            // Update the Hit structure with intersection information\n            x = Hit(t1, normal, ellipsoid.textureId);\n            return true;\n        }\n    }\n\n    // No intersection\n    return false;\n}\n\n//cylinder intersection\nbool IntersectCylinder(Ray ray, Cylinder cylinder, out Hit x)\n{\n    // Translate the ray origin and cylinder position into local coordinates\n    vec3 oc = ray.o - cylinder.Base;\n\n    // Project oc onto the cylinder's axis\n    float projection = dot(oc, cylinder.Axis);\n\n    // Project the ray direction onto the cylinder's axis\n    float directionProjection = dot(ray.d, cylinder.Axis);\n\n    // Calculate coefficients for the quadratic equation\n    float a = dot(ray.d - directionProjection * cylinder.Axis, ray.d - directionProjection * cylinder.Axis);\n    float b = 2.0 * dot(oc - projection * cylinder.Axis, ray.d - directionProjection * cylinder.Axis);\n    float c = dot(oc - projection * cylinder.Axis, oc - projection * cylinder.Axis) - cylinder.Radius * cylinder.Radius;\n\n    // Calculate the discriminant of the quadratic equation\n    float discriminant = b * b - 4.0 * a * c;\n\n    // Check for intersection with the side of the cylinder\n    if (discriminant > 0.0)\n    {\n        // Calculate the two possible solutions\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Ensure t1 is the smaller value\n        if (t1 > t2)\n        {\n            float temp = t1;\n            t1 = t2;\n            t2 = temp;\n        }\n\n        // Calculate the intersection point\n        vec3 intersectionPoint = ray.o + t1 * ray.d;\n\n        // Calculate the distance along the axis to the intersection point\n        float intersectionDistance = dot(intersectionPoint - cylinder.Base, cylinder.Axis);\n\n        // Check if the intersection is within the height of the cylinder\n        if (t1 >= 0.0 && intersectionDistance >= 0.0 && intersectionDistance <= cylinder.Height)\n        {\n            // Calculate the normal at the intersection point\n            vec3 normal = normalize(intersectionPoint - (cylinder.Base + projection * cylinder.Axis*0.5));\n            // Update the Hit structure with intersection information\n            x = Hit(t1, normal, cylinder.textureId);\n            return true;\n        }\n    }\n\n    // Check for intersection with the top cap of the cylinder\n    float t_top = (cylinder.Height - projection) / directionProjection;\n    if (t_top > 0.0)\n    {\n        // Calculate the intersection point on the top cap\n        vec3 intersectionPointTop = ray.o + t_top * ray.d;\n\n        // Calculate the distance to the center of the top cap\n        vec3 centerToIntersectionTop = intersectionPointTop - (cylinder.Base + cylinder.Height * cylinder.Axis);\n        float distanceToCenterTop = length(centerToIntersectionTop);\n\n        // Check if the intersection point is within the top cap's radius\n        if (distanceToCenterTop <= cylinder.Radius)\n        {\n            // Update the Hit structure with intersection information\n            vec3 normalTop = normalize(cylinder.Axis); // Normal points outward\n            x = Hit(t_top, normalTop, cylinder.textureId);\n            return true;\n        }\n    }\n\n    // Check for intersection with the bottom cap of the cylinder\n    float t_bottom = -projection / directionProjection;\n    if (t_bottom > 0.0)\n    {\n        // Calculate the intersection point on the bottom cap\n        vec3 intersectionPointBottom = ray.o + t_bottom * ray.d;\n\n        // Calculate the distance to the center of the bottom cap\n        vec3 centerToIntersectionBottom = intersectionPointBottom - cylinder.Base;\n        float distanceToCenterBottom = length(centerToIntersectionBottom);\n\n        // Check if the intersection point is within the bottom cap's radius\n        if (distanceToCenterBottom <= cylinder.Radius)\n        {\n            // Update the Hit structure with intersection information\n            vec3 normalBottom = -normalize(cylinder.Axis); // Normal points outward\n            x = Hit(t_bottom, normalBottom, cylinder.textureId);\n            return true;\n        }\n    }\n\n    // No intersection\n    return false;\n}\n//intersect cube\nbool IntersectCube(Ray ray, Cube cube, out Hit x) {\n    vec3 tMin = (cube.minCorner - ray.o) / ray.d;\n    vec3 tMax = (cube.maxCorner - ray.o) / ray.d;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if (tNear > tFar || tFar < 0.0) {\n        return false;\n    }\n\n    if (tNear < 0.0) {\n        tNear = tFar;\n    }\n\n    vec3 intersectionPoint = Point(ray, tNear);\n    vec3 normal;\n    vec3 p = Point(ray, tNear);\n    if (p.x > cube.maxCorner.x - 0.001) normal = vec3(1,0,0);\n        else if (p.x < cube.minCorner.x + 0.001) normal = vec3(-1,0,0);\n        else if (p.y > cube.maxCorner.y - 0.001) normal = vec3(0,1,0);\n        else if (p.y < cube.minCorner.y + 0.001) normal = vec3(0,-1,0);\n        else if (p.z > cube.maxCorner.z - 0.001) normal = vec3(0,0,1);\n        else if (p.z < cube.minCorner.z + 0.001) normal = vec3(0,0,-1);\n\n    x = Hit(tNear, normal, cube.textureId);\n    return true;\n}\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n//intersect capsule\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x)\n{\n    // Intersect the two spheres\n    Hit sphereHit1, sphereHit2;\n    bool hitSphere1 = IntersectSphere(ray, Sphere(capsule.Base, capsule.Radius, capsule.textureId), sphereHit1);\n    bool hitSphere2 = IntersectSphere(ray, Sphere(capsule.Base + capsule.Axis * capsule.Height, capsule.Radius, capsule.textureId), sphereHit2);\n    \n    // Intersect the cylinder\n    Hit cylinderHit;\n    \n    Cylinder cylinder = Cylinder(capsule.Base, capsule.Axis, capsule.Radius, capsule.Height, capsule.textureId);\n    bool hitCylinder = IntersectCylinder(ray, cylinder, cylinderHit);\n\n    // Determine the closest hit\n    bool hit = false;\n\n    if (hitSphere1 && (!hit || sphereHit1.t < x.t))\n    {\n        x = sphereHit1;\n        hit = true;\n    }\n\n    if (hitSphere2 && (!hit || sphereHit2.t < x.t))\n    {\n        x = sphereHit2;\n        hit = true;\n    }\n\n    if (hitCylinder && (!hit || cylinderHit.t < x.t))\n    {\n        x = cylinderHit;\n        hit = true;\n    }\n\n    return hit;\n}\n\n\nmat4 RotationMatrix(vec3 axis, float time)\n{\n    float angle = time; \n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n\n    vec3 normalizedAxis = normalize(axis);\n    float x = normalizedAxis.x;\n    float y = normalizedAxis.y;\n    float z = normalizedAxis.z;\n\n    mat4 rotationMat = mat4(\n        t * x * x + c, t * x * y - s * z, t * x * z + s * y, 0.0,\n        t * x * y + s * z, t * y * y + c, t * y * z - s * x, 0.0,\n        t * x * z - s * y, t * y * z + s * x, t * z * z + c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return rotationMat;\n}\n\nfloat GetTime()\n{\n    return 1.0 * iTime;\n}\n\nRay translateRay(Ray ray, vec3 t)\n{\n    Ray newRay;\n    newRay.o = ray.o + t;\n    newRay.d = ray.d;\n    return newRay;\n}\n\n// Construit une matrice de mise à l'échelle 4x4 \nmat4 ScalingMatrix(vec3 s) {\n    mat4 scaleMat = mat4(1.0); // matrice identité\n    scaleMat[0] = vec4(s.x, 0.0, 0.0, 0.0); // colonne pour X\n    scaleMat[1] = vec4(0.0, s.y, 0.0, 0.0); // colonne pour Y\n    scaleMat[2] = vec4(0.0, 0.0, s.z, 0.0); // colonne pour Z\n    return scaleMat;\n}\n\n\nRay ScaleRay(Ray r, vec3 s) {\n    mat4 scaleMat = ScalingMatrix(s);\n    r.o = (inverse(scaleMat) * vec4(r.o, 1.0)).xyz; \n    r.d = (inverse(scaleMat) * vec4(r.d, 0.0)).xyz; \n    return r;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.,1.),1.,1);\n    const Sphere sph2=Sphere(vec3(3.,0.,1.),1.,4);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,-1.),5);\n    const Cylinder cyl1 = Cylinder(vec3(-12., 0., 1.0), vec3(0.0, 0., 1.), 1.5, 3.0, 1);\n    const Ellipsoid ellipsoid1 = Ellipsoid(vec3(7., 0.0, 1.), vec3(2.0, 0.5, 2.5), 3);\n    const Cube cube1 = Cube(vec3(-6., -2., 0.5), vec3(-3., 2., 2.5), 5);\n    const Capsule capsule = Capsule(vec3(-8.0, 0, 1.), 1.0, vec3(.0, 0.0, 1.0), 3., 1);\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    \n    \n     // Create a rotation matrix\n    mat4 rotationMat = RotationMatrix(vec3(.0, 0.0, 1.0), GetTime());\n    \n    // Rotate the ray\n    Ray rotatedRay;\n    rotatedRay.o = (rotationMat * vec4(ray.o, 1.0)).xyz;\n    rotatedRay.d = normalize((rotationMat * vec4(ray.d, 0.0)).xyz);\n    \n    //scaled ray\n    Ray transformedRay = ScaleRay(ray, vec3(1., 2., 1.0) ); \n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(rotatedRay,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n   \n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCapsule(ray, capsule, current) && current.t < x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinder(rotatedRay,cyl1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (IntersectCube(ray, cube1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    } \n    if (IntersectEllipsoid(transformedRay, ellipsoid1, current) && current.t < x.t) {\n    x = current;\n    ret = true;\n    }\n    \n     \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n//occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n, int N)\n{\n    if (N == 0) return 1.0; // Avoid division by zero\n\n    float ao = 0.0;\n\n    for (int i = 0; i < N; i++)\n    {\n        vec3 d = Hemisphere(i, n); // Generate random direction in the hemisphere\n\n        // Ray origin is slightly offset from the surface to avoid self-intersections\n        vec3 pOffset = p + 0.01 * n; \n\n        // Shoot a ray in the generated direction\n        Hit occlusionHit;\n        if (!Intersect(Ray(pOffset, d), occlusionHit))\n        {\n            // If there is no intersection, consider this as occlusion\n            ao += 1.0;\n        }\n    }\n\n    // Calculate the average occlusion factor\n    ao /= float(N);\n\n    return ao;\n}\n\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m, vec3 n, vec3 p, Ray ray)\n{\n    // Define the two light sources\n    vec3 lightSource1 = vec3(10, 15, 10);\n    vec3 lightSource2 = vec3(-5, 10, 10);\n\n    // Define light colors for both sources\n    vec3 lightColor1 = vec3(1.0, 1.0, 1.0);\n    vec3 lightColor2 = vec3(0.8, 0.8, 0.8);\n\n    // Ambient light\n    vec3 ambient = vec3(.2, .2, 0.2);\n    float ambientOcclusion = AmbientOcclusion(p, n, 64);\n    \n    // Initialize the total color\n    vec3 totalColor = ambient;\n\n    // Calculate lighting for the first light source\n    vec3 lightVec1 = normalize(lightSource1 - p);\n    Hit intersection1;\n    if (!Intersect(Ray(p + n * 0.01, lightVec1), intersection1))\n    {\n        float diffStrength1 = clamp(dot(n, lightVec1), 0.0, 1.0);\n        vec3 diffuse1 = diffStrength1 * lightColor1 * 0.7;\n\n        // Specular reflection for the first light source\n        vec3 viewVec1 = normalize(ray.o - p);\n        vec3 reflectVec1 = reflect(-lightVec1, n);\n        float specStrength1 = pow(clamp(dot(viewVec1, reflectVec1), 0.0, 1.0), 16.0);\n        vec3 specular1 = specStrength1 * lightColor1 * 0.6;\n\n        // Add the contribution of the first light source to the total color\n        totalColor += m.d * (diffuse1 + specular1) * ambientOcclusion;\n    }\n\n    // Calculate lighting for the second light source\n    vec3 lightVec2 = normalize(lightSource2 - p);\n    Hit intersection2;\n    if (!Intersect(Ray(p + n * 0.01, lightVec2), intersection2))\n    {\n        float diffStrength2 = clamp(dot(n, lightVec2), 0.0, 1.0);\n        vec3 diffuse2 = diffStrength2 * lightColor2 * 0.7;\n\n        // Specular reflection for the second light source\n        vec3 viewVec2 = normalize(ray.o - p);\n        vec3 reflectVec2 = reflect(-lightVec2, n);\n        float specStrength2 = pow(clamp(dot(viewVec2, reflectVec2), 0.0, 1.0), 16.0);\n        vec3 specular2 = specStrength2 * lightColor2 * 0.6;\n\n        // Add the contribution of the second light source to the total color\n        totalColor += m.d * (diffuse2 + specular2) * ambientOcclusion;\n    }\n\n    return totalColor;\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    vec3 col = vec3(0.0); // Initialize the color to black\n\n    // The maximum number of reflections\n    int maxReflections = 2;\n\n    for (int numReflections = 0; numReflections < maxReflections; numReflections++) {\n        Hit x;\n        bool idx = Intersect(ray, x);\n        vec3 p = Point(ray, x.t);\n\n        if (idx)\n        {\n            Material mat = Texture(p, x.i);   \n            \n            if (x.i == 3) {\n                // Apply reflection only to objects with texture index 1\n                vec3 normal = x.n;\n                vec3 reflectionDir = reflect(ray.d, normal); // Reflect the ray\n\n                // Create a new ray for the reflection\n                ray = Ray(p + 0.001 * reflectionDir, reflectionDir);\n\n                // Continue the loop to trace the reflection ray\n            }\n            else {\n                // Apply the color model without reflection for other objects\n                col += Color(mat, x.n, p, ray);\n                break; // Exit the loop\n            }\n                        \n        \n        }else {\n            // If there's no intersection, return the background color\n            col += Background(ray.d);\n            break; // Exit the loop\n        }\n            \n            \n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=15.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.7)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}