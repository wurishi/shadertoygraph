{"ver":"0.1","info":{"id":"XlBXWR","date":"1442620414","viewed":1408,"name":"Simple Raymarch Circle","username":"davepl","description":"Raymarches to locate a simple circle - with comments.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["simple","raymarch","tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Davepl 9/18/2015\n// Creative Commons Attribution License\n//\n// Really basic Raymarch demo\n//\n// You're going to get a shot at coloring each and every pixel in the rectanlge canvas.  This code\n// will run once for each pixel.  If it lies inside the circle, we'll color it white.  Outside, black.\n// How do we know if we're inside or outside the circle?\n//\n// Basic idea - we start at the origin.  We know what direction the pixel is we're working on is,\n// and the value we are going to 'hunt' for is the amount that we'd have to multiply that diretion\n// to get right to the candidate pixel.  This would be trivial to calculate but we're just doing this\n// as an example.\n//\n// We're going to pick a value, see where we're at (too far?  not far enough?) and then keep \n// adding half the distance, negative or positive, to our multiplier 't' until we get as close\n// as we can to the value.  We could stop when we hit it exactly but this code will run 64 times,\n// halving the disance each time, even if it's already at 0 distance (we could break out but \n// do not for simplicity).\n//\n// We use 64 steps to yield a crisper circle; 32 is a little blurry.  This is really dependent on how\n// much resolution you have and coule be a function of it and how big your step changes (we use 1/2 of last step)\n\nconst  float radius = 2.0;\n\nfloat distanceFromEdge(vec3 p)\t\t\t// Circles are defined as everything a uniform distance from the center\n{\t\t\t\t\t\t\t\t\t\t// In this case we are looking for how far the current candidate guess\n    return length(p) - radius;\t\t\t//   is from the radius of the circle\n}\n\nfloat trace(vec3 origin, vec3 ray)\t\t\t\t// You -could- do this recursively, but itterative is simpler and safer\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i)\t\t\t\t// We know what direction the pixel is, and we want to know\n    {\t\t\t\t\t\t\t\t\t\t\t//   the amount t must be to get to it\n        vec3 p = origin + ray * t;\t\t\t\t// Pick a point along the ray r at a distance t from the origin \n        float distance = distanceFromEdge(p);   // Let d be the new distance from the circle edge, negative or positive\n        t += distance * 0.5;\t\t\t\t\t// Now change the distance factor t by half the distance we currently are from edge\n    }\n    return t;\t\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio; rescale texcoords horizontally based on it\n    \n    vec3 ray    = normalize(vec3(uv, 1.0));\t\t// Direction to the pixel (unit vector, no magnitude)\n    vec3 origin = vec3(0.0, 0.0, -3);\t\t\t// Camera origin at 0,0,-3\n\n    float t     = trace(origin, ray);\t\t\t\n    \n    // For values that are close to zero, meaning they took very little to get them to the\n    // edge of the circle, the resulting color value will be large (white).  For values that are far\n    // away from the edfe, the color value will be small (black):\n    \n\tfragColor   = vec4(1.0/t);\n}","name":"","description":"","type":"image"}]}