{"ver":"0.1","info":{"id":"wtXyWH","date":"1598341803","viewed":178,"name":"Simple Slime","username":"imanishi","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_MARCH_STEP = 50;\nconst vec3 BG_COLOR = vec3(0.78, 0.8, 0.9);\n\n\n// 球の距離関数\nfloat dSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid setCamera(out vec3 camPos, out vec3 camTarget, in float time, in vec2 mouse)\n{\n    float radius = 3.0;\n    float theta = 0.1 + 5.0 * mouse.x - iTime * 0.2;\n    float phi = 3.14159 * 0.4; //5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTarget = vec3(0.0,0.0,0.0);\n}\n\n// スムース(距離関数をスムーズに合成) \nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// -----------\n// Noise\n// -----------\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// -----------\n// Modelling\n// -----------\n\nvec2 map(vec3 pos) {\n    float sphere = dSphere(pos, 2.0) + noise(pos * 1.0 + (iTime * 0.5));\n    float t1 = sphere;\n\n    // 距離関数の合成\n    t1 = smin(t1, dSphere(pos + vec3(1.8, 0.0, 0.0), 0.2), 2.0);\n    t1 = smin(t1, dSphere(pos + vec3(-1.8, 0.0, -1.0), 0.2), 2.0);\n    \n    return vec2(t1, 1.0);\n}\n\n/*\nfloat distFunc(vec3 pos)\n{\n    float sphere = dSphere(pos, 2.0) + noise(pos * 1.0 + (iTime * 0.1));\n    float t1 = sphere;\n\n    // 距離関数の合成\n    t1 = smin(t1, dSphere(pos + vec3(1.8, 0.0, 0.0), 0.2), 2.0);\n    t1 = smin(t1, dSphere(pos + vec3(-1.8, 0.0, -1.0), 0.2), 2.0);\n\n    return t1;\n}\n*/\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos + eps.xyy).x - map(pos - eps.xxy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x);\n    return normalize(nor);\n}\n\nvoid renderColor(vec3 rayOrigin, vec3 rayDirection, inout vec3 color, vec3 currentPos) {\n    vec3 lightDirection = normalize(vec3(1.0, 4.0, 1.0));\n\n    vec3 normal = calcNormal(currentPos);\n    vec3 normalDistorted = calcNormal(currentPos + noise(currentPos * 1.5 + vec3(0.0, 0.0, sin(iTime*0.75))));\n\n    // リムライティング\n    float l = abs(dot(-rayDirection, normal));\n    float lDistorted = abs(dot(-rayDirection, normalDistorted));\n    float rim = pow(1.0 - l, 6.0);\n    float rimDistorted = pow(1.0 - lDistorted, 6.0);\n    \n    color = mix(color, normal * 0.3 + vec3(1.0), rimDistorted + 0.1);\n    color += rim;\n\n}\n\n// -----------\n// Ray March\n// -----------\n\nvec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec4 plane) {\n\tfloat t = -(dot(rayOrigin, plane.xyz) + plane.w) / dot(rayDirection, plane.xyz);\n\treturn rayOrigin + t * rayDirection;\n}\nbool renderRayMarch(vec3 rayOrigin, vec3 rayDirection, inout vec3 color) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < NUM_MARCH_STEP; i++) {\n        vec3 currentPos = rayOrigin + rayDirection * t;\n        d = map(currentPos).x;\n        if (d < INTERSECTION_PRECISION) {\n            break;\n        }\n        t += d;\n    }\n\n    if (d < INTERSECTION_PRECISION) {\n        vec3 currentPos = rayOrigin + rayDirection * t;\n        renderColor(rayOrigin, rayDirection, color, currentPos);\n        return true;\n    }\n\n    vec3 planePoint = rayPlaneIntersection(rayOrigin, rayDirection, vec4(0.0, 1.0, 0.0, 1.0));\n\n    return false;\n}\n\n// -----------\n// Output\n// -----------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 rayOrigin, camTarget;\n    setCamera(rayOrigin, camTarget, iTime, m);\n\n    // Ray生成\n    mat3 camMat = calcLookAtMatrix(rayOrigin, camTarget, 0.0);\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, 2.0));\n\n    // RayMarching\n\n    vec3 color = BG_COLOR;\n    renderRayMarch(rayOrigin, rayDirection, color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}