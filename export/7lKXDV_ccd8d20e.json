{"ver":"0.1","info":{"id":"7lKXDV","date":"1641394712","viewed":87,"name":"GLSL bug?","username":"Envy24","description":"See Image tab lines 7 and 10.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["glsl","bug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define TEX0(x)               ( texture(iChannel0, x) )\n\n\n\n// Works fine.\n#define TEX_COORDS(SC)        ( (SC) / (R.xy) )                       // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\n// This line brokes shader!\n//#define TEX_COORDS(SC)        ( SC / R.xy )                       // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\n\n/*\n    FabriceNeyret2, 2022-01-05\n    the second definition give me a filled heart, while the first only show a contour.\n    ( ubuntu / Chrome / nVidia )\n\n    () are necessary around SC in the macro otherwise parameter SC + vec2(1.0, 0.0)  will be substituted\n    by the macro as SC + vec2(1.0, 0.0)/R.xy\n*/\n\n\n\nbool compareNE(float l, float r)\n{\n    l = l >= 0.0 ? 1.0 : -1.0;\n    r = r >= 0.0 ? 1.0 : -1.0;\n    \n    return l != r;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float CENTER = TEX0(TEX_COORDS(SC)).r;\n    float RIGHT  = TEX0(TEX_COORDS(SC + vec2(1.0, 0.0))).r;\n    float LEFT   = TEX0(TEX_COORDS(SC + vec2(-1.0, 0.0))).r;\n    float TOP    = TEX0(TEX_COORDS(SC + vec2(0.0, 1.0))).r;\n    float BOTTOM = TEX0(TEX_COORDS(SC + vec2(0.0, -1.0))).r;\n\n    bool isVisible = \n        compareNE(CENTER, RIGHT) ||\n        compareNE(CENTER, LEFT) ||\n        compareNE(CENTER, TOP) ||\n        compareNE(CENTER, BOTTOM);\n\n    // Only 2 quantization levels.\n\n    O = vec4(!isVisible);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                       iResolution\n#define AR                    ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define NZMY                  ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD           ( iMouse.z > 0.0 )\n\n#define XMIN     -2.0\n#define XMAX     2.0\n#define YMIN     -2.0\n#define YMAX     2.0\n      \nfloat heart_curve(float x, float y)\n{\n    float term = x*x + y*y - 1.0;\n    return term * term * term - x*x * y*y*y;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float xStep = (XMAX - XMIN) / (R.x - 1.0);\n    float yStep = (YMAX - YMIN) / (R.y - 1.0);\n\n    float modulation = \n        LMB_IS_HOLD == true ?\n            NZMY :\n            0.0;\n    \n    float dist = \n        modulation + heart_curve(\n            (XMIN + floor(SC.x) * xStep) * AR,\n            YMIN + floor(SC.y) * yStep);\n\n    O = vec4(dist);\n}","name":"Buffer A","description":"","type":"buffer"}]}