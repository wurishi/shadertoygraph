{"ver":"0.1","info":{"id":"csj3RD","date":"1667317066","viewed":120,"name":"Artober - Golden medusa","username":"Flopine","description":"Shader 26 of the artober series (yeah I know we're in november but eh, I'm getting close to the 31 pieces!)\nStill experimenting with reaction diffusion usage in 3D !","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","reactiondiffusion","everyday","grayscott"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\nstruct obj \n{\n    float d;\n    int mid;\n    vec3 c;\n};\n\nobj minobj (obj a, obj b)\n{\n    if(a.d<b.d) return a;\n    else return b;\n}\n\nfloat extrude (vec3 p, vec2 dh)\n{\n    vec2 q = vec2(dh.x, abs(p.z)-dh.y);\n    return min(0., max(q.x,q.y))+length(max(q, 0.));\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(PI/20.);\n    float bump = texture(iChannel1, p.xy*.8).x*.015;\n    vec2 agent = T(p.xy*.25); \n    obj ag = obj( extrude(p, vec2(agent.y, .1-bump))-.05, 1,  vec3(0.01)),\n    \n    plane = obj( abs(p.z)-.1+bump, 2, vec3(1., .7, 0.1) ); \n    \n    return minobj(ag, plane);\n}\n\nvec3 gn (vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d, SDF(p-eps.yxy).d, SDF(p-eps.yyx).d));\n}\n\nfloat spec (vec3 rd, vec3 l, vec3 n, float ex)\n{ return pow(max(dot(n, normalize(l-rd)), 0.),ex); } \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(.4, .3, -3.), rd=normalize(vec3(uv, 1.)), p=ro,\n    col=vec3(0.), l=vec3(.3, 0.5, -.2);\n    \n    obj O;    \n    for (float i=0.; i<64.; i++)\n    {\n        O  = SDF(p);\n        if (O.d<0.001) break;\n        p += O.d*rd*.8;\n    }\n\n    vec3 n = gn(p);\n    float sp;\n    col = O.c;\n    if (O.mid == 2) \n    {\n        sp = spec(rd,l,n, 60.);\n        col += vec3(1., .8, .4)*sp;\n    }       \n    else if (O.mid == 1) \n    {\n        sp = spec(rd,l,n, 40.);\n        col += vec3(0.05, 0.05, 0.09)*sp;    \n    }\n\n    fragColor = vec4(sqrt(col),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 laplacian (vec2 uv, vec2 current)\n{\n    vec2 r = iResolution.xy;\n    \n    vec2 sa = vec2(0.);\n    \n    sa -= current;\n    sa += T(uv+vec2(0., 1.)/r)*.2;\n    sa += T(uv+vec2(0., -1.)/r)*.2;\n    sa += T(uv+vec2(1., 0.)/r)*.2;\n    sa += T(uv+vec2(-1., 0.)/r)*.2;\n    \n    sa += T(uv+vec2(1., 1.)/r)*.05;\n    sa += T(uv+vec2(1., -1.)/r)*.05;\n    sa += T(uv+vec2(-1., 1.)/r)*.05;\n    sa += T(uv+vec2(-1., -1.)/r)*.05;\n    \n    return sa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2  cuv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (iFrame == 0)\n    {\n        fragColor = vec4(1., init(cuv, iTime), 0., 1.);\n        return;\n    }\n    \n    vec2 c  = T(uv);\n    vec2 la = laplacian(uv, c);\n    \n    fragColor = vec4(rd_calculus(c, la, cuv, iTime) + c,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI acos(-1.)\n\n#define da 1.\n#define db .5\n#define f(u) mix(0.01, .1, clamp(abs(u.y), 0., 1.))\n#define k(u) mix(0.06, 0.067, clamp(abs(u.x)-.2, 0., 1.))\n#define dt 1.\n\n#define T(u) texture(iChannel0, u).xy\n\nfloat init (vec2 u, float t)\n{return step(abs(length(u)-.5), .02);}\n\nvec2 rd_calculus (vec2 c, vec2 la, vec2 uv, float t)\n{;\n    return vec2(\n                (da*la.x - c.x*c.y*c.y + f(uv)*(1.-c.x))*dt,\n                (db*la.y + c.x*c.y*c.y - (k(uv)+f(uv))*c.y)*dt\n                );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 laplacian (vec2 uv, vec2 current)\n{\n    vec2 r = iResolution.xy;\n    \n    vec2 sa = vec2(0.);\n    \n    sa -= current;\n    sa += T(uv+vec2(0., 1.)/r)*.2;\n    sa += T(uv+vec2(0., -1.)/r)*.2;\n    sa += T(uv+vec2(1., 0.)/r)*.2;\n    sa += T(uv+vec2(-1., 0.)/r)*.2;\n    \n    sa += T(uv+vec2(1., 1.)/r)*.05;\n    sa += T(uv+vec2(1., -1.)/r)*.05;\n    sa += T(uv+vec2(-1., 1.)/r)*.05;\n    sa += T(uv+vec2(-1., -1.)/r)*.05;\n    \n    return sa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2  cuv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (iFrame == 0)\n    {\n        fragColor = vec4(1., init(cuv, iTime), 0., 1.);\n        return;\n    }\n    \n    vec2 c  = T(uv);\n    vec2 la = laplacian(uv, c);\n    \n    fragColor = vec4(rd_calculus(c, la, cuv, iTime) + c,0.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 laplacian (vec2 uv, vec2 current)\n{\n    vec2 r = iResolution.xy;\n    \n    vec2 sa = vec2(0.);\n    \n    sa -= current;\n    sa += T(uv+vec2(0., 1.)/r)*.2;\n    sa += T(uv+vec2(0., -1.)/r)*.2;\n    sa += T(uv+vec2(1., 0.)/r)*.2;\n    sa += T(uv+vec2(-1., 0.)/r)*.2;\n    \n    sa += T(uv+vec2(1., 1.)/r)*.05;\n    sa += T(uv+vec2(1., -1.)/r)*.05;\n    sa += T(uv+vec2(-1., 1.)/r)*.05;\n    sa += T(uv+vec2(-1., -1.)/r)*.05;\n    \n    return sa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2  cuv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (iFrame == 0)\n    {\n        fragColor = vec4(1., init(cuv, iTime), 0., 1.);\n        return;\n    }\n    \n    vec2 c  = T(uv);\n    vec2 la = laplacian(uv, c);\n    \n    fragColor = vec4(rd_calculus(c, la, cuv, iTime) + c,0.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}