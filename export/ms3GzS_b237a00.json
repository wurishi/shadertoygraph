{"ver":"0.1","info":{"id":"ms3GzS","date":"1677444141","viewed":147,"name":"PopJect","username":"QuantumSuper","description":"One codes and sees. \nRaymarched auto-VJ. Daddy in mind of PopBaby.","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","reflection","music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PopJect 1.02.230226\n// raymarched auto-vj, daddy of PopBaby\n//\n// - use with music in iChannel0 -\n\n\n#define MAX_STEP 80\n#define MAX_DIST 10.\n#define MIN_DIST .002\n\nfloat aTime; //animation time\nvec3 r; //material reflection color amplitude factor\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //compress sound in iChannel0 to simple frequency-range amplitude estimations \n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n    fft.x = step(.91,fft.x); //weaken weaker sounds, hard limit\n}\n\nmat3 rotMY(float rad){ //rotation about y-axis\n    return mat3(cos(rad),0.,-sin(rad),0.,1.,0.,sin(rad),0.,cos(rad));\n}\n\nfloat fitPoly2(float x, vec3 y){ //simple polynom2 fit: expects y at x = {0, .5, 1.}\n    return y.r+(4.*y.g-3.*y.r-y.b)*x+(2.*y.r-4.*y.g+2.*y.b)*x*x;\n}\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nvec3 getCol(int id, float s){ //color definitions\n    vec3 setCol = vec3(1);\n    \n\t//id += 2*int(aTime);\n\t\n\tif (id==0) setCol = vec3( //vaporwave blue shift\n        fitPoly2(s, vec3(9,30,0)), //r\n        fitPoly2(s, vec3(0,29,250)), //g\n        fitPoly2(s, vec3(66,215,253))); //b\n    else if (id==1) setCol = vec3( //vaporwave red shift\n        fitPoly2(s, vec3(132,244,255)),\n        fitPoly2(s, vec3(0,0,148)),\n        fitPoly2(s, vec3(92,204,255)));\n\telse if (id==2) setCol = vec3( //miami green shift\n        fitPoly2(s, vec3(39,26,173)),\n        fitPoly2(s, vec3(153,246,252)),\n        fitPoly2(s, vec3(106,138,248)));\n\telse if (id==3) setCol = vec3( //miami orange shift\n        fitPoly2(s, vec3(250,252,236)),\n        fitPoly2(s, vec3(47,157,212)),\n        fitPoly2(s, vec3(11,0,80)));\n\telse if (id==4) setCol = vec3( //arena red\n        fitPoly2(s, vec3(53,231,237)),\n        fitPoly2(s, vec3(17,15,114)),\n        fitPoly2(s, vec3(18,20,41)));\n\telse if (id==5) setCol = vec3( //arena blue\n        fitPoly2(s, vec3(35,103,178)),\n        fitPoly2(s, vec3(87,211,225)),\n        fitPoly2(s, vec3(97,225,245)));\n   \n    return setCol/255.;\n}\nvec3 getCol(int id){ //overloaded\n    return getCol(id,1.); //return full intensity\n}\n\nfloat sdSphere(vec3 pos, float rad){\n    return length(pos)-rad;\n}\n\nfloat sdBox(vec3 p, vec3 b){ //source: https://iquilezles.org/articles/distfunctions/\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron(vec3 p, float s){ //source: https://iquilezles.org/articles/distfunctions/\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdMorphject(vec3 pos){\n    float aFrac = fract(fract(aTime/4.)+8.*sin(.04*aTime));\n    float r = .06+.12*ffts.w; //size\n    pos *= rotMY(-.139*aTime); //rotate\n    \n    if (aFrac<.33) return sdSphere(pos, r);\n    else if (aFrac<.66) return sdBox(pos, vec3(0.805996*r)); //volume dependend on sphere: .5*(4/3*pi*r^3)^(1/3)\n    else return sdOctahedron(pos, 1.46459*r); //volume dependend on sphere: .5*(4/sqrt(2)*pi*r^3)^(1/3)/sin(pi/4)\n\n}\n\nfloat getDist(vec3 pos){ //also sets r\n    float minDist = MAX_DIST;\n    float myDist;\n\t\n\tmyDist = min(minDist, abs(pos.y-.31)); //ceiling\n\tif (myDist != minDist){ minDist = myDist; r = vec3(.05+.2*smoothstep(.02+.1*ffts.y,.0,abs(pos.x))+.2*fft.x);} //hit\n    \n\tmyDist = min(minDist, abs(abs(pos.x)-.71)); //side walls\n\tif (myDist != minDist){ minDist = myDist; r = vec3(.1+.4*smoothstep(.02+.05*ffts.x,.0,abs(pos.y-.27+clamp(.8*fft.y,.0,.57)))+.2*fft.x);} //hit\n    \n    myDist = min(minDist, sdMorphject(pos)*1.); //central object\n\tif (myDist != minDist){ minDist = myDist; r = getCol(int(2.*mod(floor(.0156*aTime),3.)+floor(2.*fract(aTime))),fft.z);} //hit\n\n    return minDist;\n}\n\nvec4 rayMarch(vec3 rPos, vec3 rDir){\n    float rLen = MIN_DIST;\n    float rLenFull = 0.; \n\tfloat rad; vec3 myPos;\n    \n    for (int n=0; n<MAX_STEP; n++){\n        myPos = rPos+rLen*rDir;\n        \n        // Check if reflection and reset march from there\n        if (myPos.y<-.31 && abs(myPos.x)<.7){ //floor reflection, hide corner artifacts\n            rLen = (-.31-rPos.y)/rDir.y; //get length to reflection surface \n            rPos = rPos+rLen*rDir; //set new start pos on reflection surface\n            rLenFull += rLen; //save walked distance\n            rLen = MIN_DIST; //reset current distance to walk from new\n            \n            if (fract(.5*aTime+10.*fract(.01*aTime))<.33){ //racing shapes floor, ref. aFrac from fun sdMorphject\n                if (length(vec2(rPos.x,fract(rPos.z+.5*aTime+.1)-.5))>.15) rDir.y*=-1.; //circles\n            } else if (abs(rPos.x)>.15 || abs(fract(rPos.z+.5*aTime+.1)-.5)>.12) rDir.y*=-1.; //squares    \n        }  \n        \n        rad = getDist(myPos); //get distance sphere\n        rLen += rad; //march\n        if (rLen>MAX_DIST || abs(rad)<MIN_DIST) break;\n    }\n    \n    return vec4(rPos+rLen*rDir, rLenFull+rLen); //true pos, path length\n}\n\n\nvec3 guessNormal(vec3 pos){ //estimate the surface normal at pos\n\tvec2 tangent = vec2(.01*MIN_DIST, 0); //sensitive!\n\t\n\tvec3 normal = getDist(pos) - vec3(\n\t\tgetDist(pos-tangent.xyy),\n\t\tgetDist(pos-tangent.yxy), \n\t\tgetDist(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nvec3 getLight(vec3 pos, vec3 lPos){\n\tvec3 lDir = normalize(lPos - pos);\n\tvec3 surfN = guessNormal(pos);\n    \n\tfloat lOut = clamp(dot(lDir, surfN), 0.0, 1.0); //intensity\n\tlOut *= 1.5*lOut*lOut; //intensity modification\n    \n\tif (rayMarch(pos + 2.0*MIN_DIST*surfN, lDir).w < length(lPos-pos)) lOut *= .2; //shadows are 20%\n    \n\treturn vec3(lOut); //color \n}\nvec3 getLight(vec3 pos, vec2 lPos){//overloaded for vec2, integrate over all z here simplifies to ignore z\n    vec3 lDir = normalize(vec3(lPos-pos.xy,.0)); \n    vec3 surfN = guessNormal(pos);\n    \n    float lOut = clamp(dot(lDir, surfN), .0, 1.); //intensity\n    lOut *= 1.5*lOut*lOut; //intensity correction\n    \n    if (rayMarch(pos + 2.0*MIN_DIST*surfN, lDir).w < length(lPos-pos.xy)) lOut *= .2; //shadows are 20%\n \n\treturn vec3(lOut); //color \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 uv = (2.*fragCoord-iResolution.xy) / maxRes; // -1..1 on longer side\n    float maxX = (maxRes == iResolution.y) ? 1. : iResolution.x/maxRes;\n    aTime = 2.133333*iTime;\n\tvec3 col = vec3(0);\n    compressFft(); //initializes fft, ffts\n    \n    // Camera\n    float cZoom = 1.1; uv *= cZoom; //zoom    \n    vec3 cPos = rotMY(.15*sin(aTime/8.))*vec3(.0,.0,-.7); //move\n\tvec3 cDir = rotMY(.15*sin(aTime/8.))*normalize(vec3(1.5*uv.xy,1.)); //rotate\n    \n    // Depth calculation\n    vec4 myRay = rayMarch(cPos,cDir); // cf. The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n    \n    // Lights\n\tvec3 myR = r; //reflectivity of hit object, ?is there a better way of value transfer than global var?\n    myR /= 1.*myRay.w*myRay.w; //haze\n    vec3 col1 = getCol(int(2.*mod(floor(.0156*aTime),3.)+floor(2.*fract(aTime/16.))), ffts.x);\n    vec3 col2 = getCol(int(2.*mod(floor(.0156*aTime),3.)+floor(2.*fract(-aTime/16.))), ffts.y);\n    vec2 lPos1 = vec2(.69-.02*ffts.x,.27-clamp(.8*fft.y,.0,.57));\n    \n    col += myR*.3*fft.x*getLight(myRay.xyz, cPos); //flashing light at cam pos   \n    col += myR*col1*getLight(myRay.xyz, lPos1); //right light ray\n    col += myR*col1*getLight(myRay.xyz, lPos1*vec2(-1,1)); //left light ray\n    col += myR*col2*getLight(myRay.xyz, vec2(.0,.29-.04*ffts.y)); //center light ray\n\t\n\t// Misc\n\tif (abs(myRay.x)>.7 && abs(fract(2.*myRay.y-.5))<.8 && abs(fract(.5*(myRay.z+aTime-myRay.y)))<.9) col *= ffts.z*(myRay.y+.6); //racing stripes\n    col *= .92+(1.+fft.w)*.16*vec3(hash21(floor(300.12*uv+42.)+fract(aTime))); //noise\n\tcol += fft.x*.03/abs(abs(uv.x)-maxX*cZoom); //white side bars\n\tcol *= col; //light falloff modifier\n    \n    // Utility\n    //col = .6*vec3(myRay.w); //depth map\n    //col = vec3(hash21(floor(300.12*uv+42.)+fract(aTime))); //pure noise\n\t//col = (uv.y<0.) ? getCol(2*int(mod(floor(.1*aTime),3.)),fract(.5*aTime)) : getCol(1+2*int(mod(floor(.1*aTime),3.)),fract(.5*aTime)); //color sets\n    \n    // Output\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}