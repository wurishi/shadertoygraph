{"ver":"0.1","info":{"id":"mtl3D2","date":"1672760679","viewed":170,"name":"P3D Game Level - intersection","username":"EisernSchild","description":"Simple game level for a (*bloody*) Pseudo 3D game based on planar voxel intersection where each voxel represesnts a level tile.","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["voxel","intersection","planar","p3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// P3D Game Level - intersection\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    P3D Game Level - intersection\n    \n    Simple game level for a (*bloody*) Pseudo 3D game based on planar \n    voxel intersection where each voxel represesnts a level tile. In\n    case we have full blocks (size .5f/.5f) and wedges half the size.\n    \n    Should be quite fast since we only have 4 steps here (uMaxSteps) to\n    walk through the planar voxel grid.\n    \n    other simplified intersections:\n    https://www.shadertoy.com/view/mdfGDB - Planar Voxel\n    https://www.shadertoy.com/view/slyyWW - Cylinder aligned\n    https://www.shadertoy.com/view/fl3cDr - Hex Voxel City\n*/\n\n// tile types\nconst uint TL_NONE     = 0x0u;\nconst uint TL_BLOCK    = 0x1u;\nconst uint TL_WD1LT    = 0x2u; // wedge size 1 left top\nconst uint TL_WD1LB    = 0x3u; // wedge size 1 left bottom\nconst uint TL_WD1RT    = 0x4u; // wedge size 1 right top\nconst uint TL_WD1RB    = 0x5u; // wedge size 1 right bottom\n\n// loop helper for voronoi funcs\n#define f3(x) for(int x=-1; x<=1; x++)\n#define PI 3.141592654\nconst float fAxisNor = sqrt(1.f) * .5f;\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n};\n\n// max ray steps\nconst uint uMaxSteps = uint(4);\n// ray min/max distance\nconst float fTMin = 0.f, fTMax = 50.f;\n// adjust raysteps to avoid flaws\nconst float fStepAdjust = 0.001f;\n\n// hash float1<-float2\nfloat hash12(vec2 vP)\n{\n\tvec3 vP3  = fract(vec3(vP.xyx) * .1031);\n    vP3 += dot(vP3, vP3.yzx + 33.33);\n    return fract((vP3.x + vP3.y) * vP3.z);\n}\n\n// hash float2<-float2\nvec2 hash22(vec2 p) { return fract(vec2(262144, 32768)*sin(dot(p, vec2(27.619, 57.583)))); }\n\n// simplex noise by iq : https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nfloat simplex(in vec2 uv)\n{\n    uv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n// full block or no full block\nbool Block(in vec2 vP)\n{\n    // set P accordingly\n    vec2 vPf = fract(vP);\n    vP = floor(vP);\n    float fH = hash12(vP);\n    \n    const float fA = .2f, fB = .4f, fC = .5f, fD = .6f;    \n    if (fH < fA)\n        // 2x2 blocks\n        return true;\n    else if (fH < fB)\n    {\n        // bottom blocks\n        if (vPf.y < .5f) return true; else return false;        \n    }\n    else if (fH < fC)\n    {\n        // bottom blocks\n        if (vPf.x < .5f) return true; else return false;        \n    }\n    else if (fH < fB)\n    {\n        // bottom blocks\n        if (vPf.x >= .5f) return true; else return false;        \n    }\n\n    return false;\n}\n\n// get type of tile by uv\nuint TileType(vec2 vP)\n{\n    if (!Block(vP))\n    {\n        vec2 vEps = vec2(.5f, .0f);\n        bool bL = Block(vP - vEps);\n        bool bR = Block(vP + vEps);\n        bool bT = Block(vP + vEps.yx);\n        bool bB = Block(vP - vEps.yx);\n        \n        if (bL && bT && !bR && !bB) return TL_WD1LT;\n        if (bR && bT && !bL && !bB) return TL_WD1RT;\n        if (bL && bB && !bR && !bT) return TL_WD1LB;\n        if (bR && bB && !bL && !bT) return TL_WD1RB;\n    }\n    else return TL_BLOCK;\n    \n    return TL_NONE;\n}\n\n// ortho project to plane with center (0,0,0)\nfloat iPlane(in vec3 vOri, in vec3 vDir, vec3 vNor)\n{\n    // return -dot(vNor, vOri)/dot(vDir, vNor);\n    return -vOri.z / vDir.z;\n}\n\n// distance to sloped (or rotated on y axis) plane (45 degrees)\nfloat iVoxelSlope45(in vec3 vOri, in vec3 vDir, in bool bInv)\n{\n    // constant normal\n    vec3 vNor = (bInv) ? vec3(-fAxisNor, 0.f, fAxisNor) : vec3(fAxisNor, 0.f, fAxisNor);\n    \n    // dot normal.direction\n    float fDND = dot(vDir, vNor);\n    \n    // set tile center as slope surface center\n    vec3 vO = vOri - vec3(floor(vOri.xz * 2.f) * .5f + .25f, 0.f).xzy;\n\n    // return T hit position\n    return -dot(vNor, vO)/fDND;\n}\n\n// peek possible rotated plane from top hit (= T Min) origin\nvoid PeekSlope(inout bool bPeek, in vec3 vOri, inout vec3 vOriT, in vec3 vDir, in vec2 vTMinMax, inout float fT)\n{\n    // backup local orientation\n    vec3 vOriL = vOriT;\n    bPeek = false;\n    \n    // inverse slope 45 degree\n    fT = vTMinMax.x + iVoxelSlope45(vOriL, vDir, true);\n    if ((fT > vTMinMax.x) && (fT < vTMinMax.y))\n    {\n        // set hit point, get destination tile index, set hit boolean\n        vOriT = vOri + vDir * fT;\n        uint uTile = TileType(vOriT.xz);\n        bPeek = ((uTile == TL_WD1LT) || (uTile == TL_WD1RB));\n    }\n    \n    // compare wether left->right slope or right->left first hit (or no hit...)\n    float fTt = vTMinMax.x + iVoxelSlope45(vOriL, vDir, false);\n    if ((fTt > vTMinMax.x) && (fTt < vTMinMax.y) && (((bPeek) && (fTt < fT)) || (!bPeek)))\n    {\n        // set hit point, get destination tile index, set hit boolean\n        vec3 vOriTt = vOri + vDir * fTt;\n        uint uTile = TileType(vOriTt.xz);\n        if ((uTile == TL_WD1LB) || (uTile == TL_WD1RT))\n        {\n            bPeek = true;\n            fT = fTt;\n            vOriT = vOriTt;\n        }\n    }\n}\n\n// true if voxel grid intersection based on tile type\nbool GridHit(in vec3 vDir, bool bXZ, uint uTile)\n{\n    if (uTile == TL_NONE) \n        return false;\n    else if (uTile == TL_BLOCK)\n        return true;\n    else if (uTile == TL_WD1LT)\n        return (vDir.x < 0.f) ? \n                   ((vDir.z < 0.f) && (!bXZ)) ? true : false : \n               (vDir.z > 0.f) ?\n                   (bXZ) ? true : false : true;\n    else if (uTile == TL_WD1LB)\n        return (vDir.x < 0.f) ? \n                   ((vDir.z > 0.f) && (!bXZ)) ? true : false : \n               (vDir.z < 0.f) ?\n                   (bXZ) ? true : false : true;\n    else if (uTile == TL_WD1RT)\n        return (vDir.x > 0.f) ? \n                   ((vDir.z < 0.f) && (!bXZ)) ? true : false : \n               (vDir.z > 0.f) ?\n                   (bXZ) ? true : false : true;\n    else if (uTile == TL_WD1RB)\n        return (vDir.x > 0.f) ? \n                   ((vDir.z > 0.f) && (!bXZ)) ? true : false : \n               (vDir.z < 0.f) ?\n                   (bXZ) ? true : false : true;\n    return false;\n}\n\n// simply slice square to get two triangles for possible top hit\nbool iHalfSquare(in vec2 v, bool bInvX)\n{\n    v = fract(v);\n    if (bInvX) v.x = 1.f - v.x;\n    return ((v.x + v.y) < 1.f);\n}\n\n// true if top plane intersection based on tile type\nbool TopHit(in vec2 vOriXZ, in uint uTile)\n{\n    vOriXZ *= 2.0f;\n    \n    if (uTile == TL_NONE) \n        return false;\n    else if (uTile == TL_BLOCK)\n        return true;\n    else if (uTile == TL_WD1LT)\n        return !iHalfSquare(vOriXZ, true);\n    else if (uTile == TL_WD1LB)\n        return iHalfSquare(vOriXZ, false);\n    else if (uTile == TL_WD1RT)\n        return !iHalfSquare(vOriXZ, false);\n    else if (uTile == TL_WD1RB)\n        return iHalfSquare(vOriXZ, true);\n\n    return false;\n}\n\n// planar, sloped voxel intersector\n// @returns: T hit distance, normal, origin as destination point\nvec4 iVoxelWedgedPlanar(inout vec3 vOri, in vec3 vDir)\n{\n    // back up origin\n    vec3 vOriB = vOri;\n    \n    // top / bottom plane intersection\n    float fTHit = -vOri.y/vDir.y;\n    float fTHitB = -(vOri.y + .5)/vDir.y;\n\n    // set bottom plane hit position, set origin to top plane hit\n    vec3 vDst = vOri + fTHitB * vDir;\n    vOri = vOri + fTHit * vDir;\n\n    // top plane hit ?\n    uint uTile = TileType(vOri.xz); \n    if (TopHit(vOri.xz, uTile))\n    {\n        // top hit, up normal\n        return vec4(fTHit, 0., 1., 0.);\n    }\n    else\n    {\n        // fields to peek slope intersections\n        bool bPeekSlope = false;\n        vec3 vOriSl;\n        float fTSl = fTHitB;\n            \n        // march from grid intersection to grid intersection (XZ grid)\n        uint uI = uint(0);\n        while ((uI++ < uMaxSteps) && (fTHit < fTHitB))\n        {   \n            // ray from top to bottom\n            vec3 vTB = vDst - vOri;\n            \n            // ray goes right or left (x) ? up or down ? get offset from top to bottom plane\n            float fIX = (vOri.x > vDst.x) ? mod(vOri.x, .5) : -mod(vOri.x, .5) + .5;\n            float fIZ = (vOri.z > vDst.z) ? mod(vOri.z, .5) : -mod(vOri.z, .5) + .5;\n            \n            // get grid next hit distance (XZ)\n            vec2 vTHit = vec2(fTHit + abs(fIX / vTB.x) * length(vTB) + fStepAdjust,\n                              fTHit + abs(fIZ / vTB.z) * length(vTB) + fStepAdjust);\n            \n            // next hit X or Z ?\n            bool bXZ = vTHit.x < vTHit.y;\n            float fTHitM = bXZ ? vTHit.x : vTHit.y;\n            \n            // peek next step to slope\n            if (!bPeekSlope)\n            {\n                vOriSl = vOri;\n                PeekSlope(bPeekSlope, vOriB, vOriSl, vDir, vec2(fTHit, min(fTHitB, fTHitM)), fTSl);\n            }\n            \n            // step forward after (!) peeking for slope\n            fTHit = fTHitM;\n            vOri = vOriB + fTHit * vDir;\n                                   \n            // render XZ grid... bottom hit or grid hit first ? slope hit first ?\n            if ((fTHit < fTHitB) && ((!bPeekSlope) || ((bPeekSlope) && (fTHit < fTSl))))\n            {\n                // get destination tile\n                uint uTile = TileType(vOri.xz);\n\n                // tile present ?\n                if (uTile != TL_NONE)\n                {\n                    // any XZ grid to be rendered ?\n                    if (GridHit(vDir, bXZ, uTile))\n                        // set normal wether X or Z grid plane, return\n                        return bXZ ? vec4(fTHit, -sign(vDir.x), 0., 0.) : vec4(fTHit, 0., 0., -sign(vDir.z));\n                }\n            }\n            \n        }\n        \n        // render slope ? (in case no grid is rendered)\n        if (bPeekSlope)\n        {\n            vOri = vOriSl;\n            fTHit = fTSl;\n            \n            // set normal by destination tile\n            uTile = TileType(vOri.xz);\n            if (uTile == TL_WD1LT)\n                return vec4(fTHit, vec3(fAxisNor, 0., -fAxisNor));\n            if (uTile == TL_WD1LB)\n                return vec4(fTHit, vec3(fAxisNor, 0., fAxisNor));\n            if (uTile == TL_WD1RT)\n                return vec4(fTHit, vec3(-fAxisNor, 0., -fAxisNor));\n            if (uTile == TL_WD1RB)\n                return vec4(fTHit, vec3(-fAxisNor, 0., fAxisNor));\n        }\n        \n        // bottom hit / no hit if ray directs upwards\n        vOri = vOriB + fTHitB * vDir;\n        return (vDir.y > 0.f) ? vec4(-1.) : vec4(fTHitB, 0., 1., 0.);\n    }\n}\n\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// phong pointlight.. in Position Texel, Light, Camera, Material Color, Ray Direction, Normal\n// inspired by Shane's lighting model\nvec3 Phong_PointLight(vec3 vPosTex, vec3 vPosLig, vec3 vPosCam, vec3 cMat, vec3 vDir, vec3 vNor)\n{\n    const float fAmbient = .2f;\n    const float fAttenuation = .005f;\n    const vec3 cWarm = vec3(1.f, .9f, .8f);\n        \n    // light direction, distance\n\tvec3 vLDir = vPosTex - vPosLig;\n\tfloat fLDist = max(length(vLDir), .001f);\n\tvLDir /= fLDist;\n\n\t// ambient, diffuse, attenuation, specular\n\tfloat fDif = max(dot(-vLDir, vNor), 0.f);\n\tfDif = pow(fDif, 2.f) * .6f + pow(fDif, 4.f) * .2f + pow(fDif, 8.f) * .2f;\n\tfloat fAtt = 1. / (1. + fLDist * fLDist * fAttenuation);\n\tvec3 vRef = reflect(vLDir, vNor);\n\tfloat fSpec = pow(max(dot(-vDir, vRef), 0.0), 32.f);\n\n\treturn clamp(((cMat * max(fDif, fAmbient)) + fSpec * .5f) * fAtt, 0.f, 1.f) * cWarm;\n}\n\n// voronoi 2D - minkowski distance\nvec2 voronoi22_minkowski(in vec2 vP, in float fPow) \n{\n    vec2 vF = fract(vP), vRs = vec2(1.f);\n    vP = floor(vP);\n    f3(nJ) { f3(nI) {\n        vec2 vR = vec2(nI, nJ) - vF + hash22(vP + vec2(nI, nJ));\n        float fD = pow(pow(abs(vR.x), fPow) + pow(abs(vR.y), fPow), 1.f / fPow);\n        if (fD < vRs.x) vRs = vec2(fD, vRs.x ); else if (fD < vRs.y) vRs.y = fD;\n    } }\n    return vRs;\n}   \n\n// simple checkers\nfloat checkers_002(in vec2 vUv, in float fDist)\n{\n    vUv.x += floor(vUv.y) * 1.5f;\n    return mix(0.3, smoothstep(0.005, 0.005 + fDist * 0.005, min(fract(vUv.x), fract(vUv.y))) * (max(mod(floor(vUv.x), 2.), mod(floor(vUv.y), 2.)) * .25 + .75),\n        (1. - smoothstep(0.995 - fDist * 0.005, 0.995, max(fract(vUv.x), fract(vUv.y)))));\n}\n\n// floor normal perturbation\nfloat floor_perturb(vec2 vP, float fT)\n{\n    float fA = length(voronoi22_minkowski(vP * 30.f, .7f)) * .0025f;\n    float fChk = checkers_002(vP * vec2(4.f, 6.f), fT);\n    return 1.f - fChk * .005f + fA;    \n}\n\n// floor normal perturbation\nvec3 floor_bump_nor(vec2 vPos, float fT)\n{\n    // perturbe by y axis\n    const vec2 vEps = vec2(.005f , 0);\n    const float fBumpF = .5f;\n    vec3 vP = vec3(0.f, floor_perturb(vPos, fT), 0.f);\n    vec3 vPX = vec3(0.f, floor_perturb(vPos + vEps.xy, fT), 0.f);\n    vec3 vPZ = vec3(0.f, floor_perturb(vPos + vEps.yx, fT), 0.f);\n    return normalize(vec3((vPX.y - vP.y) * fBumpF / vEps.x, 1., (vPZ.y - vP.y) * fBumpF  / vEps.x));\n}\n\n// floor normal perturbation\nfloat top_perturb(vec2 vP, float fT)\n{\n    vec2 vVoro = voronoi22_minkowski(vP, 1.6f);\n    float fV = 1.f - smoothstep(.0f, .2f, (vVoro.y - vVoro.x) * 2.f);\n    return fV * .01f + simplex(vP * .25f) * .05f + length(voronoi22_minkowski(vP * 10.f, 2.2f)) * .005f;\n}\n\n// top normal perturbation\nvec3 top_bump_nor(vec2 vPos, float fT)\n{\n    // perturbe by y axis\n    const vec2 vEps = vec2(.01f , 0);\n    const float fBumpF = .5f;\n    vec3 vP = vec3(0.f, top_perturb(vPos, fT), 0.f);\n    vec3 vPX = vec3(0.f, top_perturb(vPos + vEps.xy, fT), 0.f);\n    vec3 vPZ = vec3(0.f, top_perturb(vPos + vEps.yx, fT), 0.f);\n    return normalize(vec3((vPX.y - vP.y) * fBumpF / vEps.x, 1., (vPZ.y - vP.y) * fBumpF  / vEps.x));\n}\n\n// function from : https://www.shadertoy.com/view/4dsSzr\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\nvec3 fireGradient(float t) {\n\treturn max(pow(vec3(min(t * 1.02, 1.0)), vec3(1.7, 25.0, 100.0)), \n\t\t\t   vec3(0.06 * pow(max(1.0 - abs(t - 0.35), 0.0), 5.0)));\n}\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    // shader constants\n    vec3 vLightOffset = vec3(-3.f, 4.5f, 2.5f);\n    float fTmOff = sin(iTime * .03f) * 30.f;\n    float fCamDist = 2.6f;\n    \n    //------------------------------- CAMERA / RAY\n    \n    // get current camera position and lookat matrix\n    vec4 vCamPos = vec4(sin(fTmOff) + fTmOff, 4.75f,  cos(fTmOff) + fTmOff - 1.4f, 0.f);\n    vec3 vCamLAt = vec3(fTmOff, 0.45f, fTmOff);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vCamLAt, vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    //------------------------------- RAYTRACING\n    \n    // do raytracing\n    float fTHit = -1.f, fTDist = 0.f, fB = 1.f;\n    vec4 vTHitNor;\n    PosNorm sAttr;\n    \n    // intersect primitives\n    vec3 vNor = normalize(vec3(sin(iTime * .3), cos(iTime * .2), sin(iTime * .4)));\n    vec3 vOriT = vOri;\n    vTHitNor = iVoxelWedgedPlanar(vOriT, vDir);\n    fTHit = vTHitNor.x;           \n    \n    // skip far/no hit\n    if ((fTHit < 0.) || (fTHit > 16.)) return;\n    \n    // get lit position + normal (hit attributes)\n    sAttr.vPosition = vOriT;\n    sAttr.vNormal = vTHitNor.yzw;\n    \n    //------------------------------- TEXTURE\n    \n    // top? bottom? or wall? (do that by index eventually)\n    if (sAttr.vNormal.y == 1.f)\n    {\n        // floor or top XZ\n        if (sAttr.vPosition.y < -.01f)\n        {\n            // floor.. get some blood on it *harhar*\n            float fA = length(voronoi22_minkowski(sAttr.vPosition.xz, .7f)) * .8f;\n            cOut = vec4(mix(fireGradient(fA).rgb, vec3(1.f), .5f), 1.f);\n            float fChk = checkers_002(sAttr.vPosition.xz * vec2(4.f, 6.f), fTHit);\n            cOut.rgb = mix(1.f - cOut.brg, cOut.rgb, fChk);\n            \n            // bump normal\n            sAttr.vNormal = floor_bump_nor(sAttr.vPosition.xz, fTHit);\n        }\n        else\n        {\n            // bump normal\n            sAttr.vNormal = top_bump_nor(sAttr.vPosition.xz, fTHit);\n            \n            // concrete top\n            cOut = vec4(mix(vec3(.7f, .6f, .5f), vec3(1.f, .8f, .7f), simplex(sAttr.vPosition.xz * .25f)), 1.f);\n        }               \n    }\n    else\n    {\n        // wall... same as top but XY..\n        vec2 vXZ = abs(normalize(sAttr.vNormal.xz));\n        vec2 vBUv = vec2(mix(sAttr.vPosition.x, sAttr.vPosition.z, vXZ.x), sAttr.vPosition.y);\n        \n        // not sure if that is fully mathematically correct\n        vec3 vNS = sign(sAttr.vNormal);\n        sAttr.vNormal = abs(top_bump_nor(vBUv, fTHit));\n        sAttr.vNormal = mix(sAttr.vNormal.yxz * vNS, sAttr.vNormal.xzy * vNS, vXZ.y);\n\n        // concrete top\n        cOut = vec4(mix(vec3(.7f, .6f, .5f), vec3(1.f, .8f, .7f), simplex(vBUv * .25f)), 1.f);\n    }\n    \n    //------------------------------- LIGHTING\n\n    // get shadow.. cast ray from light position here for now...\n    vec3 vPosLg = vCamLAt + vLightOffset;\n    vec3 vDirLg = sAttr.vPosition - vPosLg;\n    float fTLight = length(vDirLg);\n    vDirLg = normalize(vDirLg);\n    vec4 vTHitSh = iVoxelWedgedPlanar(vPosLg, vDirLg);\n    if ((vTHitSh.x + .001f) < fTLight)\n    {\n        // shadow\n        cOut.rgb *= .1f;\n    }\n    else\n        // no shadow\n        cOut.rgb = Phong_PointLight(sAttr.vPosition, vCamLAt + vLightOffset, vOri, cOut.rgb, vDir, sAttr.vNormal);\n}","name":"Image","description":"","type":"image"}]}