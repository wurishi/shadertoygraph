{"ver":"0.1","info":{"id":"cscSW8","date":"1679670209","viewed":101,"name":"Simple hexagon shader","username":"OnoSendai","description":"Modified from https://www.shadertoy.com/view/wtdSzX","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float length2(vec2 v) { return dot(v, v); }\n\nfloat hash21(vec2 p) // hash function, just for visualisation.\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453);\n}\n\n#define SQRT_3 1.7320508\n\nvec2 closestHexCentre(vec2 p)\n{\n    vec2 grid_p = vec2(p.x, p.y * (1.0 / SQRT_3));\n    \n    // Alternating rows of hexagon centres form their own rectanglular lattices.\n    // Find closest hexagon centre on each lattice.\n    vec2 p_1 = (floor((grid_p + vec2(1,1)) * 0.5) * 2.0            ) * vec2(1, SQRT_3);\n    vec2 p_2 = (floor( grid_p              * 0.5) * 2.0 + vec2(1,1)) * vec2(1, SQRT_3);\n    \n    // Now return the closest centre from the two lattices.\n    float d_1 = length2(p - p_1);\n    float d_2 = length2(p - p_2);\n    return d_1 < d_2 ? p_1 : p_2;\n}\n\n\n// Fraction along line from hexagon centre at (0,0) through p to hexagon edge.\n// Also 1 - distance from boundary (I think)\nfloat hex(in vec2 p)\n{\n\tp = abs(p);\n    float right_frac = p.x;\n    float upper_right_frac = dot(p, vec2(0.5, 0.5*SQRT_3));\n\treturn max(right_frac, upper_right_frac);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * 0.01;\n    \n    vec2 hex_centre = closestHexCentre(uv);\n    \n    float frac_to_edge = hex(uv - hex_centre);\n    \n    vec3 col = frac_to_edge < 0.9 ? vec3(hash21(hex_centre)) : vec3(0, 0.5, 1);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}