{"ver":"0.1","info":{"id":"XsXyzj","date":"1488904540","viewed":120,"name":"Raymarching_Again","username":"Nihilus","description":"TODO:\n- refraction","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","distancefields","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 512\n#define EPSILON 0.00001\n#define MAX_DISTANCE 40.0\n#define MAX_REFLECTIONS 4\n#define MAX_REFRACTIONS 1\n#define NUM_LIGHTS 1\n//#define ANTIALIASING\n\n#define GLASS_ETA 1.5\n#define METAL_ETA 50.0\n#define MAX_ETA 20.0\n\n#define SKY_ID 0\n#define FLOOR_ID 4\n\n/*\n\tTODO:\n\t- implement refraction properly\n*/\n\n// Utility function to convert from integer RGB to float\nvec3 RGB(int r, int g, int b)\n{\n    return vec3(float(r), float(g), float(b))/255.0;\n}\n\n// Struct to keep track of the distance and the object ID\nstruct Object\n{\n    float d; \t\t\t// distance\n    int id; \t\t\t// used to identify the object\n    float eta; \t\t\t// used for refraction\n    bool reflection; \t// enable reflection\n    bool refraction; \t// enable refraction\n};\n\n// Signed distance of a point p from the surface of a sphere of radius r\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Signed distance of a point p from the surface of a plane\nfloat sdPlane(vec3 p)\n{ \n    return p.y;\n}\n\n// Signed distance of a point p from the surface of a torus\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Unsigned distance of a point p from the surface of a box\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\n// Union of two objects using distance fields\nObject opUnion(Object ob1, Object ob2)\n{\n    if(ob1.d < ob2.d)\n        return ob1;\n    else\n        return ob2;\n}\n\n// Subtraction of two objects using distance fields\nObject opSubtract(Object ob1, Object ob2)\n{\n    if(-ob1.d < ob2.d)\n        return ob1;\n    else if(-ob2.d < ob1.d)\n        return ob2;\n}\n\n// Find the distance of the point p to the nearest object\n// Scene for testing purpose\nObject map(vec3 p)\n{\n    Object s1 = Object(\n        sdSphere(p - vec3(0.0, 0.6, 0.0), 0.6),\n        6,\n        GLASS_ETA,\n        true,\n        true\n    );\n    \n    Object b1 = Object(\n        udBox(p - vec3(0.0, 0.5, 0.0), vec3(0.5)),\n        6,\n        METAL_ETA,\n        false,\n        true\n    );\n\n    Object b2 = Object(\n        udBox(p - vec3(1.2, 0.5, 1.2), vec3(0.5)),\n        1,\n        METAL_ETA,\n        true,\n        false\n    );\n    Object b3 = Object(\n        udBox(p - vec3(1.2, 0.5, -1.2), vec3(0.5)),\n        2,\n        METAL_ETA,\n        true,\n        false\n    );\n    Object b4 = Object(\n        udBox(p - vec3(-1.2, 0.5, 1.2), vec3(0.5)),\n        3,\n        METAL_ETA,\n        true,\n        false\n    );\n    Object b5 = Object(\n        udBox(p - vec3(-1.2, 0.5, -1.2), vec3(0.5)),\n        5,\n        METAL_ETA,\n        true,\n        false\n    );\n    \n    Object p1 = Object(\n        sdPlane(p),\n        FLOOR_ID,\n        METAL_ETA,\n        true,\n        false\n    );\n    \n    Object res = opUnion(s1, p1);\n    //Object res = opUnion(b1, p1);\n    \n    res = opUnion(res, b2);\n    res = opUnion(res, b3);\n    res = opUnion(res, b4);\n    res = opUnion(res, b5);\n    \n    return res;\n}\n\n// Return the object color based on the id and the point\nvec3 color(int id, vec3 p)\n{\n    if(id == 1)\n    {\n        return RGB(204, 70, 70);\n    }\n    else if(id == 2)\n    {\n        return RGB(94, 204, 30);\n    }\n    else if(id == 3)\n    {\n        return RGB(30, 105, 204);\n    }\n    else if(id == 4)\n    {\n        // Implement checkerboard pattern\n        vec3 grey = RGB(255, 255, 255);\n        float f = mod(floor(4.0*p.z) + floor(4.0*p.x), 2.0);\n        return 0.3 + grey * f;\n    }\n    else if(id == 5)\n    {\n        return RGB(200, 160, 0);\n    }\n    else if(id == 6)\n    {\n        return RGB(255, 255, 255);\n    }\n    return RGB(255, 255, 100);\n}\n\n// Determine the normal of a surface (gradient trick)\nvec3 normal(vec3 p) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(p + eps.xyz).d - map(p - eps.xyz).d,\n\t\tmap(p + eps.zxy).d - map(p - eps.zxy).d,\n\t\tmap(p + eps.yzx).d - map(p - eps.yzx).d\n\t);\n\treturn normalize(nor);\n}\n\n// Determine light on the surface of an object: Lambertian model\n// https://en.wikipedia.org/wiki/Lambertian_reflectance\nvec3 LambertianLight(vec3 p, int id)\n{\n    // Check if we are dealing with the background\n    if(id == 0)\n        return color(id, p);\n    \n    // Add light to the object (light intensity and source)\n    vec3 li = RGB(255, 255, 255);\n    vec3 ls = vec3(2.0*cos(iTime), 2.5, 2.0*sin(iTime));\n    //vec3 ls = vec3(0.0, 2.5, -1.0);\n    \n    // Determine the normal vector and the Lambertian coefficient\n    vec3 sn = normal(p);\n    vec3 ls_p = normalize(ls - p); // light source to surface point vector\n    float NdotL = clamp(dot(ls_p, sn), 0.0, 1.0);\n    \n    // Determine light intensity based on the distance between the light source and the object\n    float k = 0.2;\n    NdotL *= (1.0 / (1.0 + dot(ls_p, ls_p) * k));\n    \n    // Add ambience light (light color and source)\n    vec3 alc = RGB(255, 255, 255);\n    //alc = vec3(0.0); // Disabling ambient light!\n    vec3 als = vec3(0.0, 1.0, 0.0);\n    \n    // Determine the Lambertian coefficient and the ambience light intensity\n    float aNdotL = 0.5 * dot(sn, normalize(als));\n    float ak = 1.0;\n    aNdotL *= (1.0 / (1.0 + dot(als, als) * ak));\n    \n    // Add object occlusion\n    float occ = 0.5 + 0.5 * sn.y;\n    \n    // Apply the Lambertian reflectance\n    vec3 c = color(id, p);\n    c *= NdotL;\n    c += aNdotL * alc;\n    c += 0.05 * occ; \n    return c;\n}\n\n// Determine the object shadow using the light origin and direction\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 origin, vec3 direction) {\n    float hit = 1000.0;\n    float t = EPSILON;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(origin + direction * t).d;\n        if (d < EPSILON)\n            return 0.05;\n        t += d;\n        hit = min(hit, 20.0 * d / t);\n        if (t > MAX_DISTANCE)\n            break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n// Determine reflection using Reflected Ray Origin and Direction\nvec3 reflection(vec3 rro, vec3 rrd, vec3 ls)\n{\n    vec3 p = vec3(0.0);\n    vec3 c = vec3(1.0);\n    // Save ray origin\n    vec3 origin = rro;\n    float t = 0.01;\n    Object hit = Object(0.0, 0, 0.0, false, false);\n    // Reflect more times\n    for(int j = 0; j < MAX_REFLECTIONS; j++)\n    {\n        // Raytrace the reflection vector\n        for(int i = 0; i < MAX_STEPS; i++)\n        {\n            // Check if we hit an object in the scene\n            hit = map(rro + rrd * t);\n            if(hit.d < EPSILON)\n                break;\n            // Reset hit object to default\n            hit = Object(hit.d, 0, 0.0, false, false);\n            // Increment the steps\n            t += hit.d;\n            // Check the maximum distance\n            if(t > MAX_DISTANCE)\n                break;\n        }\n        // Check if we hit the sky\n        if(hit.id == SKY_ID)\n        \tbreak;\n        // We hit an object, determine if it reflects\n        if(hit.reflection == false)\n            break;\n        // We hit an object, determine the base color\n        p = rro + rrd * t;\n        // We hit an object, determine if it refracts\n        if(hit.refraction == false)\n        \tc *= color(hit.id, p) * shadow(p, ls);\n        else\n            c *= color(hit.id, p);\n        // Determine new object normal and riflected ray direction\n        vec3 N = normal(p);\n        vec3 L = rrd;\n        vec3 R = normalize(reflect(L, N));\n        rro = p;\n        rrd = R;\n        t = 0.01;\n    }\n    return c;\n}\n\n// Determine refraction using Refraction Ray Origin and Direction\nvec3 refraction(vec3 rro, vec3 rrd, vec3 ls)\n{\n    Object hit = Object(0.0, 0, 0.0, false, false);\n    float t = 0.0;\n    // Raytrace the refraction vector\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // Check if we hit an object in the scene\n        hit = map(rro + rrd * t);\n        // Check if we exited the object\n\t\tif(hit.d > EPSILON)\n            break;\n        // Reset hit object to default\n        hit = Object(hit.d, 0, 0.0, false, false);\n        // Increment the steps\n        t += 0.01;\n        // Check the maximum distance\n        if(t > MAX_DISTANCE)\n            break;\n    }\n    // Check if we hit the sky or a non refractive material\n    if(hit.id != 0)\n    {\n        // We hit the other face of the object\n        vec3 p = rro + rrd * t;\n        vec3 N = normal(p);\n        vec3 L = normalize(p - rro);\n        vec3 R = refract(L, -N, hit.eta);\n        // Trace to see which object the ray will hit\n        rro = p;\n        rrd = R;\n        t = 0.0;\n        for(int i = 0; i < MAX_STEPS; i++)\n        {\n            // Check if we hit an object in the scene\n            hit = map(rro + rrd * t);\n            if(hit.d < EPSILON)\n                break;\n            // Reset hit object to default\n            hit = Object(hit.d, 0, 0.0, false, false);\n            // Increment the steps\n            t += hit.d;\n            // Check the maximum distance\n            if(t > MAX_DISTANCE)\n                break;\n        }\n    }\n    vec3 c = color(hit.id, rro + rrd * t);\n    \n    if(hit.reflection == true)\n        c *= reflection(rro, rrd, ls);\n    \n    return c;\n}\n\n// Determine light on the surface of an object: Blinn-Phong model\n// https://en.wikipedia.org/wiki/Phong_reflection_model\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n// p = point on the surface\n// e = direction\n// eye = viewer eye location\n// ls = light source coordinates\n// lc = light color\n// obj = object hit by the ray\nvec3 light(vec3 p, vec3 e, vec3 eye, vec3 ls[4], vec3 lc[4], Object obj)\n{\n    // Check if we hit the background\n    if(obj.id == 0)\n        return color(obj.id, p);\n    \n    // Setup intensities: ambient, diffuse, specular, reflection\n    vec3 ia = RGB(255, 255, 255);\n    vec3 id = RGB(255, 255, 255);\n    vec3 is = RGB(255, 255, 255);\n    vec3 ir = RGB(255, 255, 255);\n    \n    // Setup reflection constants: ambient, diffuse, specular\n    vec3 ka = vec3(0.9);\n    vec3 kd = vec3(0.6);\n    vec3 ks = vec3(0.9);\n        \n    // Setup shininess of the material: specular\n    float a = 64.0;\n    \n    // Define base color\n    vec3 c = vec3(0.0);\n    \n    for(int i = 0; i < NUM_LIGHTS; i++)\n    {\n        // Determine useful vectors\n        vec3 N = normal(p);\t\t\t\t// vector normal to the surface\n        vec3 L = normalize(ls[i] - p); \t// light-point direction\n        vec3 H = normalize(-e + ls[i]); \t// light-eye direction\n\n        // Determine the diffuse and specular coefficients\n        float diff = clamp(dot(L, N), 0.0, 1.0);\n        float spec = clamp(pow(dot(H, N), a), 0.0, 1.0);\n\n        // Add ambient and object light\n        float occ = 0.5 + 0.5 * N.y;\n        float amb = clamp(0.5 + 0.5 * N.y, 0.0, 1.0);\n\n        // Add shadows to the image\n        float sha = shadow(p + N * EPSILON, L);\n\n        // Add surface reflection\n        vec3 esd = normalize(p - eye); // eye-surface direction\n        vec3 R1 = normalize(reflect(esd, N));\n        vec3 refl = reflection(p + N * EPSILON, R1, ls[i]);\n\n        // Determine Blinn-Phong value (with reflection too)\n        vec3 phong =\n            amb * ia * occ * ka\t\t\t\t\t\t\t\t\t\t\t// ambient\n            + diff * id * occ * kd\t\t\t\t\t\t\t\t\t\t// diffuse\n            + diff * spec * is * occ * ks\t\t\t\t\t\t\t\t// specular\n            ;\n        \n        // Check if we need to add reflection to the object\n        if(obj.reflection)\n            phong += diff * refl * ir * occ * exp(-1.4*p.y);\t\t\t\t// reflection\n        \n        // Check if we need to add refraction to the object\n        if(obj.refraction)\n        {\n            // Add surface refraction\n        \tvec3 esd2 = normalize(eye - p);\n        \tvec3 R2 = normalize(refract(esd2, N, 1.0/obj.eta));\n        \tvec3 refr = refraction(p - N * EPSILON, R2, ls[i]);\n            phong += occ * refr;\t\t\t\t\t\t\t\t\t\t// refraction\n        }\n        \n        // The light intensity depends on the distance\n        float li = 3.0; // light intensity tweaker\n        phong *= 1.0/(1.0 + dot(L, L) * li);\n        \n        // Mix lights\n        if(i == 0)\n        {\n            c = color(obj.id, p) * lc[i] * phong;\n            if(!obj.refraction)\n                c *= sha;\n        }\n        else\n        {\n            if(!obj.refraction)\n            \tc += color(obj.id, p) * lc[i] * phong * sha;\n            else\n                c += color(obj.id, p) * lc[i] * phong;\n        }\n        \n    }\n    \n    // Global intensity, let's tweak the shit out of this shader\n    c *= 1.8;\n    \n    return c;\n}\n\n// Raymarching algorithm with distance fields\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n    // Save eye position\n    vec3 eye = ro;\n    // Define standard empty object\n    Object obj = Object(0.0, 0, 0.0, false, false);\n    // Maximum distance\n    float t = 0.0;\n    // Raymarch MAX_STEPS\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // Passing the point origin to the scene\n        obj = map(ro);\n        // Checking if we hit something\n        if(obj.d < EPSILON)\n            break;\n        // Incrementing the step\n        ro += rd * obj.d;\n        // Reset object to default\n        obj = Object(obj.d, 0, 0.0, false, false);\n        // Keep track of the maximum distance\n        t += obj.d;\n        if(t > MAX_DISTANCE)\n            break;\n    }\n    // Determine pixel color\n    vec3 lc[4], ls[4];\n    lc[0] = vec3(1.0, 1.0, 1.0);\n    lc[1] = vec3(0.0, 0.0, 0.0);\n    lc[2] = vec3(0.0, 0.0, 0.0);\n    lc[3] = vec3(1.0, 1.0, 1.0);\n    ls[0] = vec3(4.0, 5.0, 4.0);\n    ls[1] = vec3(6.0, 5.0, -6.0);\n    ls[2] = vec3(-6.0, 5.0, 6.0);\n    ls[3] = vec3(-2.0, 5.0, -2.0);\n    vec3 color = light(ro, rd, eye, ls, lc, obj);\n    // Add fog to the image (distance)\n    float fogAmount = 1.0 - exp(-t*0.04);\n    return mix(color, RGB(255, 255, 255), fogAmount);\n}\n\n// Total control over the camera\nmat3 setCamera(vec3 origin, vec3 target, float rotation)\n{\n\tvec3 forward = normalize(target - origin);\n\tvec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coordinates [-1, 1]\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 1.6, 0.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    float speed = 0.5;\n    origin.x += 3.5 * cos(speed*iTime + 0.0*iMouse.x);\n    origin.z += 3.5 * sin(speed*iTime + 0.0*iMouse.y);\n    \n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(uv.xy, 2.0));\n    \n    // Raymarch scene  \n#ifdef ANTIALIASING\n    vec3 color = vec3(0.0);\n    vec3 point = origin;\n    float AA = 0.00055;\n    //float AA = 0.002;\n    for(int i = 0; i < 10; i++)\n    {\n        if(i == 1)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y - AA;\n            point.z = origin.z - AA;\n        } else if(i == 2)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y - AA;\n            point.z = origin.z - AA;\n        } else if(i == 3)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y + AA;\n            point.z = origin.z - AA;\n        } else if(i == 4)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y + AA;\n            point.z = origin.z - AA;\n        } else if(i == 5)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y - AA;\n            point.z = origin.z + AA;\n        } else if(i == 6)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y - AA;\n            point.z = origin.z + AA;\n        } else if(i == 7)\n        {\n            point.x = origin.x - AA;\n            point.y = origin.y + AA;\n            point.z = origin.z + AA;\n        } else if(i == 8)\n        {\n            point.x = origin.x + AA;\n            point.y = origin.y + AA;\n            point.z = origin.z + AA;\n        }\n    \tcolor += raymarch(point, direction);\n    }\n    color /= 10.0;\n#else\n    vec3 color = raymarch(origin, direction);\n#endif\n    // Adjust the gamma\n    vec3 gamma = vec3(1.0/0.9);\n    color = pow(color, gamma);\n    \n    // Return pixel color\n\tfragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"}]}