{"ver":"0.1","info":{"id":"Ms2BW3","date":"1527271389","viewed":270,"name":"Monotonous domain wraping","username":"asiJa","description":"Domain wrap function which is guarantied to create continous flow field (i.e. continuous objects (e.g. lines, rectangle) are maped to new continous objects ... not scattered to many discontinous pieces )","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","fbm","wrap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sin_poles_signed( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    float s = cp.x*cp.y;\n    float D = 1.0/(w2 + dot(sp,sp) );\n    return vec3( (-2.0*D*cp*s - cp.yx)*freq*sp, s )*D*w2;\n}\n\nvec3 textureWithDerivs( vec2 p, vec2 freq, float w2 ){\n    p *= freq;\n    const float d = 0.01;\n\tfloat f0  =  texture(iChannel1, p ).r;\n    float dfx = (texture(iChannel1, p+vec2(d,0.0) ).r - f0);\n    float dfy = (texture(iChannel1, p+vec2(0.0,d) ).r - f0);\n    return vec3( vec2(dfx,dfy)*(d/freq), f0 );\n}\n\nvec3 func( vec2 p, vec2 freq ){\n    //return textureWithDerivs( p, freq*0.01, 0.01 );\n    return sin_poles_signed( p, freq, 0.8 )*0.1;\n}\n\nvoid move( inout vec2 p, float dt, vec2 freq ){\n    vec3 fd = func( p, freq );\n    //p += -fd.xy*dt;               // gradient  move\n    p += vec2( -fd.y, fd.x ) * dt;  // vorticity move    \n    //p += dt*0.05;\n    //p += texture(iChannel1, p*0.05).r*0.1*dt;\n}\n\nvoid move4( inout vec2 p, float dt, vec2 freq ){\n\tmove( p, dt, freq );\n    move( p, dt, freq );\n    move( p, dt, freq );\n    move( p, dt, freq );\n}\n\nvec2 checkFuncDeriv( vec2 p, vec2 freq ){\n    vec3 fd = func( p, freq );\n    if(p.x>0.0){\n        float dd = 0.001;\n        fd.xy=vec2(   func( p + vec2(dd,0.0), freq ).z - fd.z ,\n                      func( p + vec2(0.0,dd), freq ).z - fd.z )/dd;\n    }\n    return fd.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p0    = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n\tvec2 p     = 6.0*p0;\t\n\t\n    vec2 freq = vec2(1.0);\n    \n\tfloat dt  = 0.9;\n\t//for(int i=0; i<32; i++){ move( p, dt, freq ); };\n    move4( p,  dt, vec2(1.0) ); p+=0.4;\n    move4( p, -dt, vec2(2.0) ); p+=0.1;\n    move4( p,  dt, vec2(3.0) ); p+=0.1;\n    move4( p, -dt, vec2(4.0) ); p+=0.1;\n    move4( p, -dt, vec2(4.0) ); p+=0.1;\n    \n    vec4 clr = vec4( texture(iChannel0, p*0.05 ).rgb, 1.0 );\n    \n    if( p0.x < 0.0 ){ // check derivatives\n    \tclr.rgb =vec3(0.5,0.5,0.0);\n        if( p0.y > 0.0 ){ clr.xy += checkFuncDeriv( p, freq )   *10.0; }\n        else            { clr.xy += func          ( p ,freq ).xy*10.0; }\n    }\n    fragColor = clr;\n}\n","name":"Image","description":"","type":"image"}]}