{"ver":"0.1","info":{"id":"3dlfzS","date":"1608760012","viewed":155,"name":"Multiple Point Lights","username":"MinimilisticBits","description":"Multiple point lights","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pointlights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ni = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y, a.x)+(c*ni/180.0);    \nreturn vec2(l*cos(ang), l*sin(ang));    \n}\n\nfloat box(vec3 p, vec3 c){\nvec3 a = abs(p)-c;\nreturn max(max(a.x,a.y), a.z);\n}\n\nfloat sphere(vec3 p, float s){\nreturn length(p)-s;\n}\n\nvec3 r(vec3 p, float c){\np/=c;return ((p-floor(p))*c)-0.5*c;\n}\nvec3 r2(vec3 p, vec3 c){\np/=c;return ((p-floor(p))*c)-0.5*c;\n}\n\nfloat dis(vec3 p){\n    float disp = texture(iChannel0, vec2(p.x-p.y, p.z-p.y)*0.01).x;\n    return  min(-box(vec3(0.0,iTime,-5.0)-p+disp*0.3, vec3(10.,40.,20.0)),\n              length(r(vec3(0.0, 2.0, 0.0)-p, 8.0))-2.0\n              \n              \n              );\n}\n\nbool trac(inout vec3 p, vec3 d, inout float dd){\n    for(int i = 0; i < 60; i++){\n        dd = dis(p);\n        if(dd < 0.01)return true;\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\nreturn normalize(\nvec3(\ndd-dis(vec3(p.x-0.1, p.yz)),\ndd-dis(vec3(p.x, p.y-0.1, p.z)),\ndd-dis(vec3(p.xy,p.z-0.1))\n));\n}\n\nfloat shadow(vec3 p, vec3 lig){\nvec3 d = normalize(lig-p);\n    float dd,lg;\n    for(int i = 0; i < 60; i++){\n        lg = length(lig-p)-1.3;\n        dd = min(dis(p), lg);\n        if(dd < 0.01)break;\n        p+=d*dd;\n    }\n\n    if(dd < 0.01 && dd == lg)return 1.0;  \n    vec3 n = norm(p,dd);\n    \n    float ang = dot(-d, n);\n    return 1.0-max(ang,0.0);\n   // return 0.2;\n}\n\n\nvec3 volumetrics(vec3 p, vec3 prevp, vec3 lig, vec3 col){\nconst int am = 12;\n    vec3 dsp = (p-prevp)/float(am);\n    float l = 0.;\n    for(int i = 0; i < am; i++){\n        l += shadow(prevp + dsp*float(i), lig);       \n    }\n    l/=float(am);\n    return col*l;\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a,2.0))/(ni*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv -= 0.5;\n    //uv.x *= iResolution.x / iResolution.y;\n    //uv *= 2.0;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.7;\n    \n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, -mouse.x*90.);\n    vec3 p = vec3(0.0, -5.0+iTime, 2.0);\n    \n    vec3 col = texture(iChannel1, d.xzy).xyz;\n    col = vec3(0.0);\n    float dd;\n    \n    \n    vec3 lig = vec3(8.0*sin(iTime), -2.0*cos(iTime)+iTime, 9.0);\n    vec3 coll1 = vec3(.9, 0.2, 0.4);\n    vec3 lig2 = vec3(3.0*cos(iTime), -6.0*sin(iTime)+iTime, 4.0);\n    vec3 coll2 = vec3(0.2,.29, .9);\n        vec3 prevp=p;\n\n    if(trac(p,d,dd)){\n       vec3 n = norm(p,dd);\n       vec3 light = normalize(lig - p);\n        vec3 light2 = normalize(lig2 - p);\n\n        float l1 = length(lig-p);\n        float l2 = length(lig2-p);\n        \n        vec3 shd2 = coll1*max(dot(n,light),0.1)+coll2*max(dot(n, light2), 0.1);\n                                                shd2 *= 0.5;\n        float r = 33.1;\n        //shd2 = shd2 * ligt*0.5;\n        vec3 s = texture(iChannel1, reflect(d,n).xzy).xyz;\n        shd2 = (shd2 + s)/2.0;\n        col = shd2 * (shadow(p-d*0.1, lig)+shadow(p-d*0.1, lig2))*0.5;\n        col += rough(0.4, dot(reflect(d,n),light))*1.2 + rough(0.4, dot(reflect(d,n),light2))*1.2;\n        //col = mix((volumetrics(p, prevp, lig, coll1) + volumetrics(p, prevp, lig2, coll2))*0.5 , col, 0.5);\n       // col = vec3(ligt);\n        p-=d*0.1;\n        d = reflect(d, n);\n        \n        if(trac(p,d,dd)){\n        \n        n = norm(p,dd);\n        light = normalize(lig - p);\n         light2 = normalize(lig2 - p);\n            \n         shd2 = coll1*max(dot(n,light),0.1)+coll2*max(dot(n, light2), 0.1);\n                                                shd2 *= 0.5;\n            \n        s = texture(iChannel1, reflect(d,n).xzy).xyz;\n       shd2 = (shd2 + s)/2.0;\n            \n      vec3 col2 = shd2 * (shadow(p-d*0.1, lig)+shadow(p-d*0.1, lig2))*0.5;\n         col2 += rough(0.4, dot(reflect(d,n),light))*0.9 + rough(0.4, dot(reflect(d,n),light2))*0.9;\n            \n              float l11 = length(lig-p);\n              float l22 = length(lig2-p);\n            \n              float ligt = max((r-l11),0.0)/r + max((r-l22),0.0)/r;\n\n            col += col2;\n            col*=ligt;\n        }else{\n        n = norm(p,dd);\n        col += texture(iChannel1, reflect(d,n).xzy).xyz;\n            \n        }\n        \n        col/=2.0;\n        float ligt = max((r-l1),0.0)/r + max((r-l2),0.0)/r;\n\n        \n        col*=ligt;\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Created by MinimilisticBits","name":"Common","description":"","type":"common"}]}