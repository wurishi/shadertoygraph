{"ver":"0.1","info":{"id":"MtXyzn","date":"1503554904","viewed":142,"name":"Noisy Sphere Distortion","username":"dust","description":"More fun with the noise function shared in https://www.shadertoy.com/view/XsSBDt\nClick and drag to explore different noise configurations.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\nfloat BaseSphereDF(vec3 coord, float r)\n{\n    return length(coord) - r;\n}\n\nfloat SphereDF(vec3 coord, float r, vec3 sphPos)\n{\n    coord -= sphPos;\n    coord = QtnRotate(coord, normalize(vec4(normalize(vec3(0.0, 1.0, 1.0)) * sin(iTime) * 4.0, cos(iTime) * 4.0)));\n    float noise = fract(length(coord / cos(1e4)) * sin(sin((length(iMouse) + 0.01) * 0.01)));\n    float noise2 = fract(length(coord / cos(2e4)) * sin(sin((length(iMouse) + 0.02) * 0.03)));\n    float noise3 = fract(length(coord / cos(3e4)) * sin(sin((length(iMouse) + 0.01) * 0.06)));\n    return max(length(coord * vec3(noise / noise2, noise2, noise3 / noise2)) - r, BaseSphereDF(coord, r * 1.2));\n}\n\nvec3 GetNormal(vec3 samplePoint, float eps, vec3 sphPos, float r)\n{\n    float normXA = SphereDF(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z), r, sphPos);\n    float normXB = SphereDF(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z), r, sphPos);\n\n    float normYA = SphereDF(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z), r, sphPos);\n    float normYB = SphereDF(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z), r, sphPos);\n\n    float normZA = SphereDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps), r, sphPos);\n    float normZB = SphereDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps), r, sphPos);\n\n    return normalize(vec3(normXA - normXB,\n                          normYA - normYB,\n                          normZA - normZB));\n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float eps = 0.0001;\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 sphPos = vec3(0.0, 0.0, 4.0);\n    for (int i = 0; i < 255; i += 1)\n    {\n        vec3 eyePos = vec3(0.0, 0.0, -3.0);\n    \tvec3 rayVec = eyePos + (rayDir * currRayDist);\n        float sphDist = SphereDF(rayVec, 2.0, sphPos);\n        if (sphDist < eps)\n        {   \n            float nDL = dot(GetNormal(rayVec, eps, sphPos, 2.0), \n                            normalize(vec3(1.0, 1.0, -1.0)));\n            fragColor = vec4(cos(sin(sin(iTime))), sin(cos(sin(iTime))), nDL, 1.0) * nDL;\n            fragColor.w = 1.0;\n            return;\n        }\n        \n        currRayDist += sphDist;\n    }\n    \n\tfragColor = vec4(0.8, 0.8, 0.8, 1.0);\n}","name":"Image","description":"","type":"image"}]}