{"ver":"0.1","info":{"id":"fdSSWm","date":"1620331848","viewed":80,"name":"Coder Husk's Ray-Marcher","username":"CoderHusk","description":"learning","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 position;\n    vec3 color;\n    float radius;\n    float dist;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float t;\n};\n\nconst int MAX_SPHERES = 2;\nconst float EPSILON = 0.01;\nconst int MAX_STEPS = 10000;\nconst float RENDER_DISTANCE = 1000.0;\nconst vec3 light = vec3(-2.0, 5.0, -3.0);\n\nSphere SPHERES[MAX_SPHERES];\n\nfloat SDF_Sphere(Sphere sphere, vec3 p) {\n    return length(sphere.position - p) - sphere.radius;\n}\n\nfloat mapWorld(vec3 p) {\n  float modifier = (cos(iTime)*0.5+1.5)*3.0;\n  float displacement = sin(p.x * modifier) * sin(p.y * modifier) * sin(p.z * modifier) * 0.25;\n    \n  SPHERES[0].position = vec3(0.0, 0.0, 0.0);\n  SPHERES[0].color = vec3(1.0, 0.0, 0.0);\n  SPHERES[0].radius = 1.0;\n  SPHERES[0].dist = SDF_Sphere(SPHERES[0], p);\n  \n  return SPHERES[0].dist + displacement;\n}\n\nvec3 calcNormal(vec3 p) {\n  const vec3 epsilonStep = vec3(EPSILON, 0.0, 0.0);\n  \n  float gX = mapWorld(p+epsilonStep.xyy) - mapWorld(p - epsilonStep.xyy);\n  float gY = mapWorld(p+epsilonStep.yxy) - mapWorld(p - epsilonStep.yxy);\n  float gZ = mapWorld(p+epsilonStep.yyx) - mapWorld(p - epsilonStep.yyx);\n  \n  return normalize(vec3(gX,gY,gZ));\n}\n\nvec3 raymarch(inout Ray ray) {\n      for (int i=0; i<MAX_STEPS; i++) {\n          vec3 cp = ray.origin+(ray.direction*ray.t);\n          float dist = mapWorld(cp);\n          \n          \n          if (dist < EPSILON) {\n              vec3 normal = calcNormal(cp);\n              float diffuseMix = max(dot(normalize(light - cp), normal),0.0);\n              float specularAngle = pow(max(dot(normalize(reflect(ray.direction, normal)), normalize(light - cp)),0.0), 10.0);\n              return (vec3(1.0, 0.0, 0.0)*diffuseMix*(1.0 - specularAngle) + specularAngle) + (vec3(1.0, 1.0, 0.0) * 0.2);\n          } else if (dist > RENDER_DISTANCE) {\n              break;\n          }\n          ray.t += dist;\n  }\n  return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    Ray primaryRay;\n    primaryRay.origin = vec3(0.0, 0.0, -4.0);\n    primaryRay.direction = normalize(vec3(uv.x, uv.y, 1.0));\n    primaryRay.t = 0.0;\n    \n    vec3 col = raymarch(primaryRay);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}