{"ver":"0.1","info":{"id":"ltdBRM","date":"1539725678","viewed":117,"name":"Pf341 - Supervision FGx","username":"patrico","description":"Working through GLSL examples and building SDF for Supervision on Friday 19th October 2018","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cube(vec3 p, vec3 dim) {\n    vec3 d = abs(p) - dim;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n    return dot(p, normalize(n));\n}\n\nfloat cylinder(vec3 p, float r) {\n \treturn length(p.xz) - r;\n}\n\nfloat hemisphere(vec3 p, float r) {\n \tfloat sphere = sphere(p, r);\n    float plane = sdPlane(p, vec3(0.0, -1.0, 0.0));\n    return max(sphere, plane);\n}\n\nfloat cone(vec3 p, vec2 hr) {\n    vec2 nhr = normalize(hr);\n    float q = length(p.xz);\n    return dot(nhr, vec2(q, p.y));\n}\n\n\nfloat igloo(vec3 p) {\n    mat4 r = inverse(rotateZ(PI/2.0));\n    float c = max(cylinder((r * vec4(p, 1.0)).xyz , 0.4), sdPlane((r * vec4(p, 1.0)).xyz,(r * vec4(vec3(0, -1.0, 0), 1.0)).xyz));\n    float p1 = sdPlane((r * vec4(p - vec3(0.0, 0.0, 0.0), 1.0)).xyz,(r * vec4(vec3(1.0, 0.0, 0.0), 1.0)).xyz);\n    float p2 = sdPlane((r * vec4(p + vec3(1.25, 0.0, 0.0), 1.0)).xyz,(r * vec4(vec3(-1.0, 0.0, 0.0), 1.0)).xyz);\n    float capped = max(p1, max(c, p2));\n    float h =  max(hemisphere(p, 1.0), sdPlane(p, vec3(0, -1.0, 0)));\n    return min(capped, h);\n}\n\nfloat tetrahedron(vec3 p) {\n    vec3 p1 = p - vec3(1.0, 1.0, 1.0);\n    vec3 p2 = p - vec3(1.0, -1.0, -1.0);\n    vec3 p3 = p - vec3(-1.0, 1.0, -1.0);\n    vec3 p4 = p - vec3(-1.0, -1.0, 1.0);\n    \n    vec3 normal1 = cross(p2 - p1, p3 - p1);\n    vec3 normal2 = cross(p4 - p1, p2 - p1);\n    vec3 normal3 = cross(p3 - p1, p4 - p1);\n    vec3 normal4 = cross(p4 - p2, p3 - p2);\n    \n    float plane1 = sdPlane(p1, normal1);\n    float plane2 = sdPlane(p1, normal2);\n    float plane3 = sdPlane(p1, normal3);\n    float plane4 = sdPlane(p2, normal4);\n \n    \n    return max(max(plane1, plane2), max(plane3, plane4));   \n}\n\nfloat corkscrew(vec3 p) {\n   p.x = p.x - cos(p.y/0.5);\n   p.z = p.z - sin(p.y/0.5);\n   float cy = cylinder(p, 1.0);\n   return cy;\n}\n\nfloat scene(vec3 p) {\n    float flr = sdPlane(p - vec3(0, -3.0, 0), vec3(0, 1, 0));\n \t//return min(igloo(p), flr);  \n    //return min(tetrahedron(p), flr);\n    return min(corkscrew(p), flr);\n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}","name":"Image","description":"","type":"image"}]}