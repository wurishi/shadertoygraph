{"ver":"0.1","info":{"id":"mlcXWM","date":"1686066274","viewed":67,"name":"Ray Marching with Metalic","username":"khycan","description":"My first ray marching practice.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100   // 최대 스텝 수\n#define MAX_DIST  200.0   // 최대 전진 거리\n#define SURF_DIST 0.01  // 표면 인식 거리\n#define VERY_FAR 10000.0  // 아주 원거리 ( 하늘로 판정 )\n\nvec3 g_lightPos = vec3(30, 80, 60);\nvec3 g_cameraOrigin = vec3(0, 10, -10);\n\nstruct RayResult\n{\n    float   _dist;\n    vec4    _color;\n    float   _reflectRatio;  // 표면 반사율 (높을수록 반사가 쎄다)\n};\n\n\nvec2 getCoord() {\n    return vec2(\n    \ttexelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r\n    ) - vec2(0.5, 0.5);\n}\n\n///////////////////////////////////////////////////\n// Distance Functions\n\nRayResult sdBoxFrame(vec3 point, vec3 boxPoint, vec3 b, float e )\n{\n    vec3 p = boxPoint - point;\n\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    \n    return RayResult(\n        // dist\n        min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),\n        \n        // color\n        vec4(0.8, 0.3, 0.5, 1.0),\n        \n        // reflect ratio\n        0.4);\n}\n\n\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\n\nRayResult sdPlane( vec3 p, vec3 n, float h )\n{\n    vec4 checkerTexture = checkers(p.xz / 8.0) * vec4(0.9, 0.9, 0.9, 1.0);\n\n    // n must be normalized\n    return RayResult(dot(p,n) + h, checkerTexture, 0.2);\n}\n\n\nRayResult sdSphere(vec3 point, vec3 center, float radius)\n{\n    return RayResult( length(point - center) - radius, vec4(0.5, 0.8, 0.3, 1.0), 0.4);\n}\n\n// Distance Functions\n///////////////////////////////////////////////////\n\nRayResult getDist(vec3 p)\n{\n    RayResult ret;\n\n    // 구1\n    ret = sdSphere(p, vec3(0, 1.0 + 2.5 * sin(3.0 * iTime), 45), 5.0);\n    \n    // 구2\n    RayResult sp = sdSphere(p, vec3(-8, 1.0 + 2.5 * sin(3.0 * iTime), 20), 5.0);\n    if (sp._dist < ret._dist) ret = sp;\n    \n    // 바닥\n    RayResult dp = sdPlane(p, vec3(0, 1, 0), 15.0);\n    if (dp._dist < ret._dist) ret = dp;\n    \n    // 프레임 박스\n    RayResult dfb = sdBoxFrame(p, vec3(20, 1.0 + 2.5 * cos(3.0 * iTime), 45), vec3(5, 3, 4), 0.5);\n    if (dfb._dist < ret._dist) ret = dfb;\n    \n    return ret;\n}\n\nRayResult rayMarch(vec3 ro, vec3 rd)\n{\n    // RO에서 현재까지 전진한 누적 거리 저장\n    float dO = 0.;\n    RayResult rr = RayResult(0.0, vec4(0.0), 0.0);\n    \n    int i = 0;\n    for(; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        \n        // GetDist() : 지정한 위치로부터 최단 SDF 거리값 계산\n        rr = getDist(p);\n        dO += rr._dist;              // 레이 전진\n        \n        // 하늘에 닿은 것( 최대 거리 )으로 간주\n        if( dO > MAX_DIST )\n            return RayResult(VERY_FAR, vec4(0.8, 0.9, 1.0, 1.0), 0.0);\n            \n        // 표면에 닿은 것으로 간주\n        if( rr._dist < SURF_DIST)\n            break;\n    }\n    \n    rr._dist = dO;\n    return rr;\n}\n\n// 물체 표면 위치에서 노멀 계산\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p)._dist;\n    vec2  e = vec2(0.001, 0.0);\n    \n    vec3 n = vec3(\n        getDist(p + e.xyy)._dist,\n        getDist(p + e.yxy)._dist,\n        getDist(p + e.yyx)._dist\n    );\n    \n    return normalize(n - d);\n}\n\nfloat getLight(vec3 p)\n{\n    vec3 objectToLight = g_lightPos - p;\n    vec3 L = normalize(objectToLight);\n    vec3 N = getNormal(p);\n    \n    // Diffuse\n    float diff = clamp( dot(N, L), 0.0, 1.0 );\n    \n    // Specular\n    float specFactor = 0.0;\n    if ( diff > 0.0 )\n    {\n        vec3 r = reflect(-L, N);\n        vec3 toEye = normalize(g_cameraOrigin - p);\n        specFactor = pow(max(dot(r, toEye), 0.0), 10.0);\n    }\n    \n    // Shadow\n    float d = rayMarch(p + L, L)._dist;\n    if( d < length(objectToLight) )\n        diff *= 0.3;\n    \n    return max(diff + specFactor, 0.15);\n}\n\nvec4 getReflectedColor(vec3 p)\n{\n    vec3 cameraToObject = p - g_cameraOrigin;\n    vec3 N = getNormal(p);\n    \n    vec3 reflectedRayDir = reflect(normalize(cameraToObject), N);\n    \n    RayResult rr = rayMarch(p + reflectedRayDir, reflectedRayDir);\n    return rr._color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 카메라 이동\n    g_cameraOrigin.xz += (getCoord() * 30.0);\n\n    // 광원 이동\n    g_lightPos.x = g_lightPos.x * cos( iTime);\n    g_lightPos.z = g_lightPos.z * sin( iTime);\n    \n    \n    // uv 좌표를 -1 ~ 1인 좌표로 만들고 z가 1인 레이를 만든다.\n    // 따라서, 수직수평 시야각이 90인 카메라 FOV가 된다.\n    vec2 uv = ((fragCoord * vec2(2, 2)) / iResolution.xy ) - vec2(1, 1);\n    vec3 rayDir = normalize(vec3(uv, 1));\n\n\n    // 픽셀의 거리 계산\n    RayResult rr = rayMarch(g_cameraOrigin, rayDir);\n    if (rr._dist >= VERY_FAR)\n    {\n        // 하늘\n        fragColor = rr._color;\n        return;\n    }\n    \n    // 광원으로부터 light 계산\n    float diff = getLight(g_cameraOrigin + (rayDir * rr._dist));\n        \n    // 물체 위치로부터 1차 반사 계산\n    vec4 reflectedColor = getReflectedColor(g_cameraOrigin + (rayDir * rr._dist));\n        \n    // color + reflect color\n    fragColor = (1.0 - rr._reflectRatio) * rr._color + rr._reflectRatio * reflectedColor;\n    \n    // + light\n    fragColor = clamp(fragColor * diff, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float outData = 0.0;\n    \n    // 현재 A버퍼의 값에 키보드 버퍼에서 값을 더한것을 A버퍼에 write\n    switch(int(fragCoord.x)) {\n        case 0:\n        \toutData = texelFetch(iChannel0, ivec2(0), 0).r +\n                iTimeDelta * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                iTimeDelta * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        \tbreak;\n        \n        case 1:\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r +\n                iTimeDelta * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n        \t\tiTimeDelta * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        \tbreak;\n    }\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}