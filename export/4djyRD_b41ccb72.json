{"ver":"0.1","info":{"id":"4djyRD","date":"1491165072","viewed":1597,"name":"Atari Puzzle Game (Sokoban)","username":"LukeRissacher","description":"Transforming your GPU into crappy 1970s technology... click game to focus, use arrow keys / WASD to play. ","likes":37,"published":1,"flags":56,"usePreview":0,"tags":["game","crt","puzzle","atari","2600","sokoban"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Some Atari 2600 fun - wanted to try my hand at a shadertoy game. A lot of the coding \n// approach for persistence etc. was inspired by KNarkowicz's amazing Contra: \n// https://www.shadertoy.com/view/XltGDr\n// Most of the action happens on Buf A, then a pixel buffer subset of it is CRT-ified \n// on this layer.\n\n#define ATARI_REZ vec2(160, 96)\n//#define SHOW_RAM\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    #ifdef SHOW_RAM\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    return;\n    #endif\n    \n    // Do CRT warp / vignette\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.1 * uv - 1.05;\n    vec2 vignetteOffset = pow(abs(uv), vec2(8.0));\n    float vignette = 1.0 - 0.5 * max(vignetteOffset.x, vignetteOffset.y);\n    uv += uv * uv.yx * uv.yx * vec2(0.025, 0.05); // crt warp\n    float cornerInset = 0.15;\n    vec2 cornerVec = max(abs(uv) + cornerInset - 1.0, 0.0) / cornerInset;\n    vignette *= 1.0 - smoothstep(1.0, 1.05, length(cornerVec)); // rounded screen corners\n    uv = 0.5 * uv + 0.5;\n    \n    // Get atari screen buffer pixel, with scanlines / chromatic aberration / flicker / vsync\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (uv.x > 0.0 && uv.y > 0.0) {    \n        vec2 atariXy = uv * ATARI_REZ;\n        float scanAmt = mix(0.1, 1.0, sin(3.14 * fract(atariXy.y)));\n        atariXy.y = floor(atariXy.y);\n        float vsyncT = max(0.0, 1.0 - iTime);\n        if (vsyncT > 0.0) {\n            float offset = pow(50.0 * vsyncT, 2.0);\n            atariXy.y = mod(atariXy.y + offset, ATARI_REZ.y + 10.0);\n        }\n        vec2 atariUv = (atariXy + vec2(0.5)) / iChannelResolution[0].xy;\n        for (int chan = 0; chan < 3; chan++) {    \n            fragColor[chan] = texture(iChannel0, atariUv)[chan];\n            atariUv += vec2(0.002, 0.002) * ATARI_REZ / iChannelResolution[0].xy; // chromatic aberration\n        }\n        float flicker = mod(float(iFrame), 4.0) >= 2.0 ? 1.0 : 0.95;\n        fragColor.rgb *= scanAmt * flicker * vignette * 1.0;\n    }\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Tweakables\nconst float START_LEVEL = 1.0;\nconst bool LOAD_CONTINUALLY = false;\n\n// Misc. constants\nconst vec2 ATARI_REZ = vec2(160.0, 96.0);\nconst float RAM_Y = 110.0;\nconst float RAM_SIZE = 32.0;\nconst vec2 BG_POS = vec2(0.0, 115.0);\nconst vec2 BG_REZ = vec2(20.0, 12.0);\nconst float ROCK_MOVE_INTERVAL = 0.065;\n\n// RAM addresses\nconst float A_PLAYER = 0.0;  // xy: pos in BG tiles  z: repeat counter\nconst float A_FG_COLOR = 1.0; \nconst float A_BG_COLOR = 2.0; \nconst float A_STATE = 3.0;  // Overall game state; x: mode  y: level num   z: state timer   w: rock timer\nconst float A_DOORS = 4.0;  // x: Door 1 open   z: door fanfare timer\nconst float A_BOX_POS = 5.0;  // xy: box 1 pos\nconst float A_TARGET_POS = 6.0;  // xy: box target 1 pos\nconst float A_ROCK_POS = 7.0;  // xy: rock pos    zw: move velocity\n\n// BG tiles\nconst float TIL_EMPTY = 9.0;\nconst float TIL_SOLID = 1.0;\nconst float TIL_SPIKES_SMASHED = 2.0;\nconst float TIL_EXIT = 3.0;\nconst float TIL_SPIKES = 4.0;\nconst float TIL_BOX_1 = 5.0;\nconst float TIL_DOOR_1 = 6.0;\nconst float TIL_TARGET_1 = 7.0;\n\n// Game modes\nconst float MODE_LOADING_LEVEL = 0.0;\nconst float MODE_PLAYING = 1.0;\nconst float MODE_CELEBRATING = 2.0;\nconst float MODE_LAMENTING = 3.0;\n\n\n// Rounds to nearest integer.\nfloat Round(float x) {\n    return floor(x + 0.5);\n}\n\n\n// Gets a RAM value.\nvec4 Get(float addr) {\n    return texture(iChannel0, vec2(addr + 0.5, RAM_Y + 0.5) / iChannelResolution[0].xy); \n}\n\n\n// Sets a RAM value, if we're on that pixel\nvoid Set(float addr, vec4 newValue, vec2 intPos, inout vec4 fragColor) {\n    if (intPos == vec2(addr, RAM_Y)) {\n        fragColor = newValue;\n    }\n}\n\n\nfloat ValueNoise(vec3 pos) {\n    const vec2 Z_OFFSET = vec2(37.0, 17.0) / 256.0;\n    float zi = floor(pos.z);\n    float zf = pos.z - zi;\n    vec2 uv = pos.xy / 256.0 + zi * Z_OFFSET;\n    vec2 val = texture(iChannel2, uv).rg;\n    return mix(val.g, val.r, zf);\n}\n\n\n// Returns tile type at 'bgPos'.\nfloat GetTile(vec2 bgPos) {\n    return texture(iChannel0, (BG_POS + bgPos + 0.5) / iChannelResolution[0].xy).r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Skip pixels outside the ram/screen buffer areas\n    vec2 intPos = floor(fragCoord);\n    bool onScreen = (intPos.x < ATARI_REZ.x && intPos.y < ATARI_REZ.y);\n    bool onRam = (intPos.x < RAM_SIZE && intPos.y == RAM_Y);\n    bool onBg = (intPos.x < BG_REZ.x && intPos.y >= BG_POS.y && intPos.y < (BG_POS.y + BG_REZ.y));\n    if (!onScreen && !onRam && !onBg) {\n        discard;\n    }\n    \n    // Load RAM values\n    vec4 g_Player = Get(A_PLAYER);\n    vec4 g_FgColor = Get(A_FG_COLOR);\n    vec4 g_BgColor = Get(A_BG_COLOR);\n    vec4 g_State = Get(A_STATE);\n    vec4 g_Doors = Get(A_DOORS);\n    vec4 g_BoxPos = Get(A_BOX_POS);\n    vec4 g_TargetPos = Get(A_TARGET_POS);\n    vec4 g_RockPos = Get(A_ROCK_POS);\n    if (LOAD_CONTINUALLY) {\n    \tg_State.x = MODE_LOADING_LEVEL;\n    }\n    \n    \n    // SCREEN BUFFER:\n    \n    if (onScreen) {\n        \n        // Get BG tile coord\n        vec2 tilePos = floor(intPos / 8.0);\n        vec2 p = mod(intPos, 8.0); // p: tile pixel\n        vec2 pc = p - vec2(4.0, 4.0); // pc: tile pixel, centered\n        float tileId = GetTile(tilePos);\n        tileId = floor(tileId);\n        \n        // Default to BG\n        const vec3 BOX_1_COL = vec3(0.0, 1.0, 0.5);\n        fragColor.rgb = g_BgColor.rgb;\n        if (g_State.x == MODE_LAMENTING) {\n            if (mod(intPos.y + 100.0 * iTime, 27.0) > 8.0) {\n                fragColor.rgb += vec3(0.1);\n            }\n        }\n        else if (g_Doors.z > 0.0) {\n\t\t\tfragColor.rgb = mix(g_BgColor.rgb, BOX_1_COL, g_Doors.z);\n        }\n        \n        // On last level, do non-Atari noise effects\n        if (g_State.y == 10.0) {\n            float val = ValueNoise(vec3(0.125 * intPos, floor(iTime))) + 0.2 * iTime;\n            fragColor.rgb = 0.25 + 0.5 * cos(6.28 * (vec3(0.25, 0.37, 0.45) + val * vec3(0.1, 0.2, 0.3)));\n        }\n\n        // Player sprite\n        if (tilePos == g_Player.xy && g_State.x != MODE_LAMENTING) {\n            if (p.x >= 1.0 && p.x < 7.0 && p.y >= 1.0 && p.y < 7.0) {\n                fragColor.rgb = vec3(1.0, 0.5, 0.25);\n            }\n        }\n        // Box sprite\n        else if (tilePos == g_BoxPos.xy) {\n            pc = abs(pc);\n            if (pc.x + pc.y == 1.0 || (pc.x == 2.0 && pc.y < 3.0) || (pc.y == 2.0 && pc.x < 3.0)) {\n            \tfragColor.rgb = BOX_1_COL;\n            }\n        }\n        // Target sprite\n        else if (tilePos == g_TargetPos.xy) {\n            pc = abs(pc);\n            if (pc.x + pc.y != 1.0 && pc.x < 2.0 && pc.y < 2.0) {\n            \tfragColor.rgb = BOX_1_COL;\n            }\n        }\n        // Rock sprite\n        else if (tilePos == g_RockPos.xy) {\n            float radius = length(p - vec2(4.0, 4.0));\n            if (radius <= 3.6) {\n                fragColor.rgb = vec3(1.0);\n            }\n        }\n        // Exit\n        else if (tileId == TIL_EXIT) {\n            if (p.x < 1.0 || p.x >= 7.0 || p.y < 1.0 || p.y >= 7.0) {\n                fragColor.rgb = vec3(1.0, 0.5, 0.25);\n            }\n        }\n        // Solid\n        else if (tileId == TIL_SOLID) {\n            fragColor.rgb = g_FgColor.rgb;\n        }\n        // Spikes\n        else if (tileId == TIL_SPIKES) {\n            pc = abs(pc);\n            if (pc.x + pc.y < 3.0 || (pc.x == 2.0 && pc.y == 2.0)) {\n            \tfragColor.rgb = vec3(1.0);\n                if (g_State.x == MODE_LAMENTING && tilePos == g_Player.xy) {\n                    fragColor.rgb = vec3(1.0, 0.0, 0.0);\n                }\n            }\n        }\n        // Smashed spikes\n        else if (tileId == TIL_SPIKES_SMASHED) {\n            if (p == vec2(4, 4) || p == vec2(6, 5) || p == vec2(2, 2) || p == vec2(5, 2)) {\n            \tfragColor.rgb = vec3(1.0);\n            }\n        }\n        // Door\n        else if (tileId == TIL_DOOR_1) {\n            if (g_Doors.x < 1.0) {\n                if (p.y == 3.0 || p.y == 4.0) {\n                    fragColor.rgb = vec3(0.0, 1.0, 0.5);\n                }\n            }\n            else {\n                if (p.x < 1.0 || p.x > 6.0) {\n                    fragColor.rgb = vec3(0.0, 1.0, 0.5);\n                }\n            }\n        }\n    }\n    \n    // RAM / GAMEPLAY:\n    \n    else if (onRam) {\n\n        // Sample keys\n        bool keyLeft  \t= texture( iChannel1, vec2( 37.5 / 256.0, 0.25 ) ).x > 0.5; // arrows\n        bool keyRight \t= texture( iChannel1, vec2( 39.5 / 256.0, 0.25 ) ).x > 0.5;\n        bool keyUp  \t= texture( iChannel1, vec2( 38.5 / 256.0, 0.25 ) ).x > 0.5;\n        bool keyDown \t= texture( iChannel1, vec2( 40.5 / 256.0, 0.25 ) ).x > 0.5;\n        keyLeft =  keyLeft  || texture( iChannel1, vec2( 65.5 / 256.0, 0.25 ) ).x > 0.5; // wasd\n        keyRight = keyRight || texture( iChannel1, vec2( 68.5 / 256.0, 0.25 ) ).x > 0.5; \n        keyUp = keyUp       || texture( iChannel1, vec2( 87.5 / 256.0, 0.25 ) ).x > 0.5;\n        keyDown = keyDown   || texture( iChannel1, vec2( 83.5 / 256.0, 0.25 ) ).x > 0.5;\n        const float KEY_A    \t\t\t\t= 65.5 / 256.0;\n        const float KEY_S    \t\t\t\t= 83.5 / 256.0;\n        const float KEY_W    \t\t\t\t= 87.5 / 256.0;\n        bool anyKey = (keyLeft || keyRight || keyDown || keyUp);\n        \n        // Handle repeat timer\n        if (!anyKey) {\n            g_Player.z = 0.0;\n        }\n        else {\n            if (g_Player.z <= 0.0) {\n                g_Player.z += 0.07;\n            }\n            else {\n                g_Player.z -= iTimeDelta;\n                anyKey = false;\n            }\n        }\n        \n        // Update player pos\n        vec2 moveDelta = vec2(0.0);\n        if (anyKey) {\n            if (keyRight && g_Player.x < (BG_REZ.x - 1.0)) {\n                moveDelta.x = 1.0;\n            }\n            else if (keyLeft && g_Player.x >= 1.0) {\n                moveDelta.x = -1.0;\n            }\n            else if (keyUp && g_Player.y < (BG_REZ.y - 1.0)) {\n                moveDelta.y = 1.0;\n            }\n            else if (keyDown && g_Player.y >= 1.0) {\n                moveDelta.y = -1.0;\n            }\n        }\n        \n        // Main game mode:\n        if (g_State.x == MODE_PLAYING) {\n            \n            // Check destination tile\n            float dest = TIL_EMPTY;\n            if (anyKey) {\n                vec2 destPos = g_Player.xy + moveDelta;\n            \tdest = GetTile(destPos);\n                if (dest == TIL_SOLID) {\n                \tmoveDelta = vec2(0.0);\n                }\n                else if (dest == TIL_DOOR_1 && g_Doors.x == 0.0) {\n                \tmoveDelta = vec2(0.0);\n                }\n                else if (dest == TIL_EXIT) {\n                \tg_State.x = MODE_CELEBRATING;\n                    g_State.z = 1.5;\n                }\n                else if (dest == TIL_SPIKES) {\n                \tg_State.x = MODE_LAMENTING;\n                    g_State.z = 0.75;\n                }\n                else if (destPos == g_BoxPos.xy) {\n                    vec2 boxDestPos = floor(destPos + moveDelta);\n                \tfloat boxDest = GetTile(boxDestPos);\n                    if ((boxDest != TIL_EMPTY && boxDest != TIL_SPIKES_SMASHED) || boxDestPos == g_RockPos.xy) {\n                        moveDelta = vec2(0.0);\n                    }\n                    else {\n                        g_BoxPos.xy += moveDelta;\n                        if (boxDestPos == g_TargetPos.xy) {\n                            g_BoxPos.xy = g_TargetPos.xy = vec2(-1);\n                            g_Doors.x = 1.0;\n                            g_Doors.z = 1.0;\n                        }\n                    }\n                }\n                else if (destPos == g_RockPos.xy && g_RockPos.zw == vec2(0.0)) {\n                    vec2 rockDestPos = floor(destPos + moveDelta);\n                \tfloat rockDest = GetTile(rockDestPos);\n                    if (rockDestPos == g_BoxPos.xy || (rockDest != TIL_EMPTY && rockDest != TIL_SPIKES && \n                        !(rockDest == TIL_DOOR_1 && g_Doors.x == 1.0))) {\n                        \n                        moveDelta = vec2(0.0);\n                    }\n                    else {\n                        g_RockPos.xy += moveDelta;\n                        g_RockPos.zw = moveDelta;\n                        g_State.w = ROCK_MOVE_INTERVAL;\n                    }\n                }\n            }\n            \n            // Update door fanfare timer\n            g_Doors.z = max(0.0, g_Doors.z - iTimeDelta);\n            \n            // Move rock if needed, handle collisions\n            if (g_State.w > 0.0) {\n                g_State.w -= iTimeDelta;\n                if (g_State.w <= 0.0) {\n                    vec2 rockDestPos = floor(g_RockPos.xy + g_RockPos.zw);\n                    float rockDest = GetTile(rockDestPos);\n                    if (rockDest == TIL_SOLID || (rockDest == TIL_DOOR_1 && g_Doors.x < 1.0) || rockDestPos == g_BoxPos.xy) {\n                    \tg_RockPos.zw = vec2(0.0);\n                        g_State.w = 0.0;\n                    }\n                    else {\n                    \tg_RockPos.xy += g_RockPos.zw;\n                    \tg_State.w += ROCK_MOVE_INTERVAL;\n                    }\n                }\n            }\n        }\n        \n        // Loading-level mode: set player pos, BG/FG\n        else if (g_State.x == MODE_LOADING_LEVEL) {\n            \n            // LEVEL VARS SETUP\n            \n            // Set player start pos & box pos\n            g_BoxPos = g_TargetPos = g_RockPos = vec4(-1.0);\n            g_RockPos.zw = vec2(0.0);\n            if (g_State.y == 1.0) { // level 1\n                g_Player.xy = vec2(4.0, 2.0);\n            }\n            else if (g_State.y == 2.0) {\n            \tg_Player.xy = vec2(17.0, 9.0);\n            }\n            else if (g_State.y == 3.0) {\n            \tg_Player.xy = vec2(9.0, 9.0);\n                g_BoxPos.xy = vec2(10.0, 4.0);\n                g_TargetPos.xy = vec2(6.0, 7.0);\n            }\n            else if (g_State.y == 4.0) {\n            \tg_Player.xy = vec2(3, 9);\n                g_BoxPos.xy = vec2(4, 2);\n                g_TargetPos.xy = vec2(15, 2);\n            }\n            else if (g_State.y == 5.0) {\n            \tg_Player.xy = vec2(7, 7);\n                g_BoxPos.xy = vec2(7, 4);\n                g_TargetPos.xy = vec2(15, 2);\n                g_RockPos.xy = vec2(9, 7);\n            }\n            else if (g_State.y == 6.0) {\n            \tg_Player.xy = vec2(7, 7);\n                g_BoxPos.xy = vec2(2, 6);\n                g_TargetPos.xy = vec2(1, 6);\n                g_RockPos.xy = vec2(11, 8);\n            }\n            else if (g_State.y == 7.0) {\n            \tg_Player.xy = vec2(11, 5);\n                g_BoxPos.xy = vec2(2, 4);\n                g_TargetPos.xy = vec2(1, 6);\n                g_RockPos.xy = vec2(9, 5);\n            }\n            else if (g_State.y == 8.0) {\n            \tg_Player.xy = vec2(14, 7);\n                g_BoxPos.xy = vec2(13, 5);\n                g_TargetPos.xy = vec2(14, 3);\n                g_RockPos.xy = vec2(9, 3);\n            }\n            else if (g_State.y == 9.0) {\n            \tg_Player.xy = vec2(18, 10);\n                g_BoxPos.xy = vec2(2, 9);\n                g_TargetPos.xy = vec2(17, 2);\n                g_RockPos.xy = vec2(17, 9);\n            }\n            \n            // Set BG color\n            if (g_State.y <= 3.0) { // level 1-3 colors\n            \tg_BgColor.rgb = vec3(0.0, 0.0, 1.0);\n                g_FgColor.rgb = vec3(0.0, 0.5, 1.0);\n            }\n            else if (g_State.y <= 6.0) { // level 4-6 colors\n            \tg_BgColor.rgb = vec3(0.0, 0.5, 0.5);\n                g_FgColor.rgb = vec3(1.0, 0.0, 0.5);\n            }\n            else if (g_State.y <= 9.0) { // level 7-9 colors\n            \tg_BgColor.rgb = vec3(0.25, 0.25, 0.25);\n                g_FgColor.rgb = vec3(0.0, 0.5, 0.5);\n            }\n            \n            g_Doors = vec4(0.0);\n            g_State.x = MODE_PLAYING;\n            moveDelta = vec2(0.0);\n        }\n        \n        // Celebrating mode: flash colors, then load next level\n        else if (g_State.x == MODE_CELEBRATING) {\n        \tmoveDelta = vec2(0.0);\n            g_BgColor.rgb = fract(vec3(0.25, 0.5, 0.75) * 3.0 * iTime);\n            g_FgColor.rgb = fract(vec3(0.75, 0.5, 0.25) * 4.7 * iTime);\n            g_State.z -= iTimeDelta;\n            if (g_State.z <= 0.0) {\n            \tg_State.x = MODE_LOADING_LEVEL;\n                g_State.y = floor(g_State.y + 1.0);\n            }\n        }\n        // Lamenting mode (death): flash red, reset after timer\n        else if (g_State.x == MODE_LAMENTING) {\n        \tmoveDelta = vec2(0.0);\n            g_BgColor.rgb = vec3(0.5, 0.0, 0.0);\n            g_State.z -= iTimeDelta;\n            if (g_State.z <= 0.0) {\n            \tg_State.x = MODE_LOADING_LEVEL;\n            }\n        }\n\n        // If not yet initialized: set all variables\n        if (g_Player.x == 0.0) {\n            g_Player = vec4(1.0, 1.0, 0.0, 0.0);\n            g_FgColor = vec4(0.0, 0.5, 1.0, 0.0);\n    \t\tg_BgColor = vec4(0.0, 0.0, 1.0, 0.0);\n            g_Doors = vec4(0.0);\n            g_State = vec4(MODE_LOADING_LEVEL, START_LEVEL, 0.0, 0.0);\n            g_BoxPos = g_TargetPos = g_RockPos = vec4(-1.0);\n        }\n\n        // Store values\n        g_Player.xy = floor(g_Player.xy + moveDelta);\n        Set(A_PLAYER, g_Player, intPos, fragColor);\n        Set(A_FG_COLOR, g_FgColor, intPos, fragColor);\n        Set(A_BG_COLOR, g_BgColor, intPos, fragColor);\n        Set(A_STATE, g_State, intPos, fragColor);\n        Set(A_DOORS, g_Doors, intPos, fragColor);\n        Set(A_BOX_POS, g_BoxPos, intPos, fragColor);\n        Set(A_TARGET_POS, g_TargetPos, intPos, fragColor);\n        Set(A_ROCK_POS, g_RockPos, intPos, fragColor);\n    }\n    \n    // BG TILE BUFFER:\n    else if (onBg) {\n        \n        // Default to previous value\n        fragColor = texture(iChannel0, fragCoord / iChannelResolution[0].xy); \n        vec2 p = intPos - BG_POS;\n        \n        // Loading level:\n        if (g_State.x == MODE_LOADING_LEVEL) {\n        \t\n            // Mirrored p, for atari-esque layouts\n\t\t\tvec2 pm = vec2(10.0 - ceil(abs(9.5 - p.x)), p.y);\n            \n            // All levels: solid border\n\t\t\tfloat t = TIL_EMPTY;\n            if (p.y < 1.0 || p.y > 10.0 || p.x < 1.0 || p.x > 18.0) {\n                t = TIL_SOLID;\n            }\n            // Level 1: \n            else if (g_State.y == 1.0) {\n                if (p == vec2(17.0, 9.0)) {\n                \tt = TIL_EXIT;\n                }\n                else if ((p.y != 1.0 && pm.x == 9.0) || (p.y == 4.0 && pm.x >= 8.0) || \n                    ((p.y == 5.0 || p.y == 8.0) && pm.x >= 5.0) ||\n                    ((p.y == 6.0 || p.y == 7.0) && pm.x >= 4.0) || \n                    pm == vec2(1, 2) || pm == vec2(1, 3)) {\n                \t\n                    t = TIL_SOLID;\n                }\n            }\n            // Level 2:\n            else if (g_State.y == 2.0) {\n                if (p == vec2(18.0, 8.0) || p == vec2(17.0, 6.0) || p == vec2(13.0, 7.0) ||\n                \tp == vec2(12.0, 2.0) || p == vec2(6.0, 1.0) || p == vec2(6.0, 8.0)) {\n                    t = TIL_SPIKES;\n                }\n                else if (p == vec2(9.0, 9.0)) {\n                \tt = TIL_EXIT;\n                }\n\t\t\t\telse if ((pm.x >= 3.0 && pm.x <= 5.0 && p.y >= 8.0) ||\n\t\t\t\t\tpm == vec2(6, 9) || \n\t\t\t\t\t(pm.x == 1.0 && pm.y >= 6.0 && pm.y <= 7.0) ||\n                    (pm.y == 6.0 && pm.x >= 7.0) ||\n                    (pm.y >= 4.0 && pm.y <= 5.0 && pm.x >= 7.0 && pm.x <= 8.0) ||\n                    (pm.y >= 2.0 && pm.y <= 3.0 && pm.x == 8.0)) {\n                \tt = TIL_SOLID;\n\t\t\t\t}\n            }\n            // Level 3:\n            else if (g_State.y == 3.0) {\n                if (p == vec2(18.0, 3.0)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(17.0, 5.0)) {\n                    t = TIL_DOOR_1;\n                }\n                else if (p == vec2(6.0, 10.0) || p == vec2(13.0, 10.0) || p == vec2(7.0, 5.0)) {\n                    t = TIL_SPIKES;\n                }\n\t\t\t\telse if ((pm.x == 1.0 && pm.y >= 9.0) ||\n\t\t\t\t\t(pm.x >= 3.0 && pm.x <= 6.0 && pm.y <= 6.0) ||\n\t\t\t\t\tpm == vec2(9, 3) || p == vec2(18, 5) ||\n\t\t\t\t\t(pm.y == 1.0 && pm.x <= 6.0)) {\n                \tt = TIL_SOLID;\n\t\t\t\t}\n            }\n            // Level 4:\n            else if (g_State.y == 4.0) {\n                if (p == vec2(10, 9)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(13, 8)) {\n                    t = TIL_DOOR_1;\n                }\n                else if (p == vec2(6, 8) || p == vec2(10, 1) || p == vec2(4, 3)) {\n                    t = TIL_SPIKES;\n                }\n\t\t\t\telse if ((pm.y == 18.0 && pm.x >= 8.0) ||\n\t\t\t\t\t(pm.y >= 8.0 && pm.x == 5.0) ||\n\t\t\t\t\t(pm.x == 1.0 && (pm.y == 6.0 || pm.y == 9.0)) ||\n\t\t\t\t\t(pm.y == 8.0 && pm.x >= 7.0) ||\n\t\t\t\t\t(pm.y == 7.0 && pm.x >= 8.0) ||\n\t\t\t\t\t(pm.y >= 5.0 && pm.y <= 6.0 && pm.x == 9.0) ||\n\t\t\t\t\t(pm.y == 5.0 && pm.x >= 4.0 && pm.x <= 5.0) ||\n\t\t\t\t\t(pm.x == 2.0 && (pm.y == 2.0 || pm.y == 4.0)) ||\n\t\t\t\t\t(pm.x == 6.0 && pm.y <= 4.0) ||\n\t\t\t\t\t(pm.y == 1.0 && (pm.x == 5.0 || pm.x == 8.0))) {\n                \tt = TIL_SOLID;\n\t\t\t\t}\n            }\n            // Level 5:\n            else if (g_State.y == 5.0) {\n                if (p == vec2(10, 1)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(9, 3)) {\n                    t = TIL_DOOR_1;\n                }\n                else if ((p.x == 6.0 || p.x == 12.0 || p.y == 9.0 || p.y == 5.0) && \n                    p.x > 5.0 && p.x < 13.0 && p.y < 10.0 && p.y > 4.0) {\n                    t = TIL_SPIKES;\n                }\n                else if (pm.x <= 2.0 || \n\t\t\t\t\t(pm.y == 10.0 && (pm.x == 3.0 || pm.x == 5.0)) ||\n\t\t\t\t\t(pm.y == 4.0 && pm.x == 3.0) ||\n\t\t\t\t\t(pm.y == 3.0 && pm.x >= 8.0) ||\n\t\t\t\t\t(pm.y == 2.0 && pm.x == 8.0) ||\n\t\t\t\t\t(pm.y == 1.0 && pm.x == 7.0)) {\n                \tt = TIL_SOLID;\n                }\n            }\n            // Level 6:\n            else if (g_State.y == 6.0) {\n                if (p == vec2(9, 1)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(10, 3)) {\n                    t = TIL_DOOR_1;\n                }\n                else if ((p.y == 4.0 && p.x >= 8.0 && p.x <= 11.0) || (pm.x > 4.0 && p.y == 8.0 && p.x != 12.0)) {\n                    t = TIL_SPIKES;\n                }\n                else if ((pm.y == 10.0 && pm.x == 3.0) ||\n\t\t\t\t\t(pm.y >= 8.0 && (pm.x == 4.0 || pm.x == 8.0)) ||\n\t\t\t\t\t(pm.y == 9.0 && pm.x == 6.0) ||\n\t\t\t\t\t(pm.y >= 3.0 && pm.y <= 5.0 && pm.x >= 3.0 && pm.x <= 4.0) ||\n\t\t\t\t\t(pm.y == 4.0 && pm.x == 7.0) ||\n\t\t\t\t\t(pm.y <= 4.0 && pm.x == 6.0) ||\n\t\t\t\t\t(pm.y == 3.0 && (pm.x == 5.0 || pm.x >= 8.0)) ||\n\t\t\t\t\t(pm.y == 2.0 && pm.x == 3.0) ||\n\t\t\t\t\t(pm.y == 1.0 && pm.x == 1.0)) {\n                \tt = TIL_SOLID;\n                }\n            }\n            // Level 7:\n            else if (g_State.y == 7.0) {\n                if (p == vec2(17, 1)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(17, 3)) {\n                    t = TIL_DOOR_1;\n                }\n                else if ((pm.x == 4.0 || pm.x == 7.0 || p.y == 7.0 || p.y == 3.0) && p.x > 3.0) {\n                    t = TIL_SPIKES;\n                }\n                else if (p == vec2(9, 10) || (p.y == 5.0 && pm.x == 1.0) || \n                    (p.y == 9.0 && pm.x == 1.0) || (p.x >= 16.0 && p.y <= 2.0 && p.x != 17.0)) {\n                \tt = TIL_SOLID;\n                }\n            }\n            // Level 8:\n            else if (g_State.y == 8.0) {\n                if (p == vec2(6, 2)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(4, 4)) {\n                    t = TIL_DOOR_1;\n                }\n                else if (p.y >= 9.0 || p.y <= 1.0 || p.x <= 3.0 || p.x >= 16.0 || \n                    (p.x == 7.0 && p.y != 4.0 && p.y != 6.0) || (p.y == 8.0 && p.x >= 7.0 && p.x <= 12.0) || \n                    (p.x == 12.0 && (p.y == 2.0 || p.y == 5.0 || p.y == 7.0)) ||\n                    p == vec2(10, 4) || p == vec2(11, 4)) {\n                \tt = TIL_SOLID;\n                }\n                else if ((p.y == 4.0 && p.x >= 5.0 && p.x <= 9.0) || p == vec2(7, 6)) {\n                    t = TIL_SPIKES;\n                }\n            }\n            // Level 9:\n            else if (g_State.y == 9.0) {\n                if (p == vec2(9, 1)) {\n                \tt = TIL_EXIT;\n                }\n                else if (p == vec2(9, 2)) {\n                    t = TIL_DOOR_1;\n                }\n                else if ((p.x >= 8.0 && p.x <= 10.0 && p.y <= 2.0) || (p.y == 6.0 && p.x <= 4.0)) {\n                \tt = TIL_SOLID;\n                }\n                else if (pm.x <= 4.0) {\n                \tt = TIL_EMPTY;\n                }\n                else {\n                    t = TIL_SPIKES;\n                }\n            }\n            // Level 10 (victory)\n            else if (g_State.y == 10.0) {\n                if (pm == vec2(8, 7) || pm == vec2(7, 5) || (pm.y == 4.0 && pm.x >= 8.0)) {\n                \tt = TIL_SOLID;\n                }\n            }\n            \n            // Set tile\n            fragColor.x = t;\n        }\n        \n        // Game playing:\n        else {\t\n            \n            // If rock is on a spike, change to smashed\n            if (fragColor.x == TIL_SPIKES && p == g_RockPos.xy) {\n            \tfragColor.x = TIL_SPIKES_SMASHED;\n            }\n        }\n        \n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"float SquareIsh(float freq, float time) {\n    float phase = fract(time * freq);\n    return ((phase > 0.6) ? 1.0 : -1.0) * mix(1.0, 0.0, fract(phase * 2.0));\n}\n\n// Make some janky beeps\nvec2 mainSound( in int samp,float time) {\n    if (time < 1.4) {\n        float noteRate;\n        if (time < 0.25) {\n            noteRate = 0.25;\n        }\n        else if (time < 0.85) {\n            noteRate = 0.13;\n        }\n        else {\n            noteRate = 0.001;\n        }\n        float rand = texture(iChannel0, vec2(0.5 + noteRate * time, 0.1)).r;\n        float freq = mix(60.0, 600.0, rand);\n        if (time > 1.02) { \n            freq *= 0.5;\n        }\n        float highDamping = mix(0.15, 0.08, freq / 600.0);\n        return vec2(highDamping * SquareIsh(freq, time));     \n    }\n    return vec2(0.0);\n}","name":"Sound","description":"","type":"sound"}]}