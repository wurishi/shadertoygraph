{"ver":"0.1","info":{"id":"M3VGWR","date":"1728047098","viewed":21,"name":"Diffuse 04/06/24","username":"Stenator","description":"Diffuse from Shader Workshop at the Fuz lead by z0rg! 04/06/24 ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["diffuse040624"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 col= texture(iChannel1,uv).xyz*1.;\n    \n\n    // Time varying pixel color\n    //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Intersection shader\n\n\n#define rot(a) mat2(cos(a),-sin(a), sin(a),cos(a))\n\nfloat hash(float seed) {\n    return fract(sin(seed* 123.456)*123.455);\n}\n\nfloat _seed;\nfloat rand(){\n    return hash(_seed++);\n}\n\nfloat _cube(vec3 p, vec3 s){\nvec3 l =  abs(p)-s;\nreturn max(l.x, max(l.y, l.z));\n}\n\n\n\nfloat Sdf(vec3 Pos) {\n    float sdf= distance(Pos,vec3(0.,0.,0.))-.3;\n    \n    //Pos.xy *= rot(iTime);\n    sdf= -_cube(Pos,vec3(4.,2.,22.));\n    return sdf;\n}\n\n\n\n\nvec3 getNorm(vec3 p) {\n    vec2 e= vec2(0.01,0.);\n    return normalize(vec3(Sdf(p))-\n    vec3(Sdf(p-e.xyy),Sdf(p-e.yxy),Sdf(p-e.yyx)));\n    \n}\n#define sat(a) clamp(a, 0.,1.)\n\nvec3 getMat(vec3 p, vec3 n) {\n    \n    vec3 col= vec3(0.);\n\n    for( float i = 0.; i<4.; i++){\n    \n        float factor = float(abs(i-mod(floor(iTime),4.))< 0.01);// ca permet de selectionner un ray en particulier\n        // i c'ets l'index !\n        \n        vec3 pplane= p-vec3(0.,0.,5.); // le rectangle  est un sdf dans le sdf!\n        pplane.xz *= rot(iTime+i);\n        pplane.yz *= rot(iTime+1.);\n        float plane = abs(pplane.z)-.1;\n        \n        vec3 rgb= vec3(1.,0.5,.7);\n        rgb.xy *= rot(i*3.5+ iTime);\n        \n        rgb = abs(rgb);\n        col = mix(col, rgb, (1. -sat(plane*1.))*factor);\n    }\n    return col;\n}\n\nfloat trace(vec3 Pos,vec3 rd) {\n    vec3 col;\n    float dist;\n    vec3 ro =Pos;\n    for(int i=0;i<124;i++){\n    \n        \n        dist= Sdf(Pos);\n        \n        if(dist>4000.){break;}\n        if(dist<0.02){\n                      \n            return distance(Pos,ro);\n\n        }\n    \n        Pos+= dist*rd;  \n    \n    }\n    return -1.;\n}\n\n\n\nvec3 rdr(vec3 Pos,vec3 rd) {\n    vec3 col;\n    float dist;\n    for(int i=0;i<124;i++){\n    \n        dist= Sdf(Pos);\n        \n        \n        if(dist<0.02){\n                      \n            col=vec3(1.,1.,1.);\n            vec3 n = getNorm(Pos);\n            col= getMat(Pos, n);\n            \n            \n            //Trace here\n            vec3 pdiffuse = Pos+n*.01;\n            vec3 rddiffuse = normalize(vec3(rand(), rand(), rand())-0.5);\n            vec3 spec= normalize(reflect(rd,n));\n            \n            //\n            rddiffuse *= sign(dot(rddiffuse, n));\n            rddiffuse = normalize(mix(spec, rddiffuse,.05));\n            float distdiffuse= trace(pdiffuse, rddiffuse);\n            if(distdiffuse > 0.)\n            {\n                vec3 prefl = pdiffuse+ rddiffuse * distdiffuse;\n                vec3 nrefl= getNorm(prefl);\n                col += getMat(prefl, nrefl)*sat(exp(-distdiffuse*0.004));\n            \n            }\n            \n            break;\n        }\n    \n        Pos+= dist*rd;  \n    \n    }\n\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.xx;\n    vec2 ouv = fragCoord/iResolution.xy;\n\n    _seed= texture(iChannel0, uv).x + iTime;\n    vec3 rd= vec3(uv.x,uv.y,1.);\n    vec3 ro= vec3(0.,0.,-5.);\n    float dist;\n    vec3 col=vec3(0.);\n    vec3 Pos= ro;\n\n    col=rdr(Pos,rd);\n    \n    col= mix(col, texture(iChannel1,ouv).xyz,.7);\n    \n    \n\n    // Time varying pixel color\n    //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}