{"ver":"0.1","info":{"id":"wsXSD2","date":"1552247826","viewed":65,"name":"Ray Marching / First Task","username":"annie","description":"Loyko A.A. \n314 group\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///marching\nconst int iter = 750;\nconst float epsilon = 0.0001;\n    \nstruct material {\n\tfloat amb;\n    float diff;\n    float spec;\n    \n    float ref;\n    vec3 color;\n    float hit;\n};\n\nstruct for_capsule {\n\tvec3 c1;\n    vec3 c2;\n    float c3;\n};\n        \n#define PI 3.14159265359\n\nfloat sdPlane( vec3 p, vec4 n) {\n  n = normalize(n);\n  return dot(p,n.xyz) + n.w; //n - nor\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s) {\n  return length(p) - s; //s - rad\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    c = normalize(c);\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nmat3 rotateY(float _angle) {\n    return mat3(cos(_angle), 0, sin(_angle),\n                0, 1, 0,\n                -sin(_angle), 0, cos(_angle));\n}\n\nmaterial opUmat(material d1, material d2) {\n    if ( d1.hit < d2.hit ) { return d1; }\n    return d2;\n}    \n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec3 translate (vec3 v1, vec3 v2) {\n    return (v1-v2);\n}\n\nmaterial sceneSDF( vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n\tvec4 sphere = vec4(  0.0, 1.0, 0.0, 1.0 ); // xyz, r\n\tvec3 box = vec3 (0.5, 0.3, 0.4);\n    vec3 rbox = vec3 (0.5, 0.3, 0.4);\n    vec2 cone = vec2 (1.0, 0.3);\n    vec2 torus = vec2 (0.7, 0.2);\n    vec2 cylinder = vec2 (0.3, 0.6);\n    vec2 prism = vec2 (1.0, 1.2);\n    for_capsule capsule;\n    capsule.c1 = vec3(0.0, 0.2, 0.0);\n    capsule.c2 = vec3(1.2, 0.2, 0.2);\n    capsule.c3 = 0.2;\n        \n    material dPlane;\n    material dSphere;\n    material drBox;\n    material dCone;\n    material dTorus;\n    material dCylinder;\n    material dPrism;\n    material dCapsule;\n    \n    dPlane.color = vec3(1.0, 1.0, 1.0);\n    dPlane.hit = sdPlane( pos, plane );\n    dPlane.diff = 1.0;\n    dPlane.spec = 0.0;\n    dPlane.ref = 0.0;\n    \n    dSphere.color = vec3(0.61, 0.37, 0.68);\n    dSphere.hit = sdSphere( translate(pos, vec3 (2.0, 1.0, 0.0)), sphere.w );\n\tdSphere.diff = 3.0;\n    dSphere.spec = 0.8;\n    dSphere.ref = 0.7;\n    \n    drBox.color = vec3(0.7, 0.4, 0.4);\n    drBox.hit = udRoundBox (translate (pos, vec3(-1.0, 0.3, 0.0)), rbox, 0.15);\n    drBox.diff = 2.0;\n    drBox.spec = 2.0;\n    drBox.ref = 0.0;\n    \n    dCone.color = vec3(0.1, 0.1, 0.8);\n    dCone.hit = sdCone (translate (pos, vec3(6.0, 0.3, 0.0)), cone);\n    dCone.diff = 2.0;\n    dCone.spec = 2.0;\n    dCone.ref = 0.0;\n    \n    dTorus.color = vec3(0.91, 0.72, 0.3);\n    dTorus.hit = sdTorus (translate (pos, vec3(4.0, 0.3, 0.5)), torus);\n    dTorus.diff = 1.0;\n    dTorus.spec = 2.3;\n    dTorus.ref = 0.0;\n    \n    dCylinder.color = vec3(0.3, 0.3, 0.6);\n    dCylinder.hit = sdCappedCylinder (translate (pos, vec3 (0.5, 0.6, 1.0)), cylinder);\n    dCylinder.diff = 2.0;\n    dCylinder.spec = 2.0;\n    dCylinder.ref = 0.0;\n    \n    dPrism.color = vec3(0.22, 0.71, 0.75);\n    dPrism.hit = sdTriPrism (rotateY(PI/4.0)*translate(pos, vec3(-3.0, 0.2, 0.7)), prism);\n    dPrism.diff = 1.0;\n    dPrism.spec = 1.0;\n    dPrism.ref = 0.0;\n    \n    dCapsule.color = vec3(0.57, 0.87, 0.27);\n    dCapsule.hit = sdCapsule (rotateY(-PI/4.0)*translate(pos, vec3(-2.3, 0.2, -2.7)), capsule.c1, capsule.c2, capsule.c3);\n    dCapsule.diff = 0.2;\n    dCapsule.spec = 4.0;\n    dCapsule.ref = 0.0;\n    \n    material for_return = opUmat(dPlane, opUmat (dSphere, opUmat (drBox, opUmat (dTorus, opUmat (dCylinder, opUmat (dPrism, dCapsule))))));\n    return for_return;\n}\n\nvec3 estimateNormal( vec3 pos, float d )\n{\n    vec3 n;\n\t\n    n.x = sceneSDF( vec3( pos.x + epsilon, pos.y, pos.z ) ).hit - d;\n    n.y = sceneSDF( vec3( pos.x, pos.y + epsilon, pos.z ) ).hit - d;\n    n.z = sceneSDF( vec3( pos.x, pos.y, pos.z + epsilon ) ).hit - d;\n\t\n    return normalize(n);\n}\n\nconst int max_depth = 2;\n\nmaterial RayMarching (vec3 Camera, vec3 RayDirection, \n                      out vec3 hitPos, out vec3 hitNrm) {\n    \n    float min_dist = 0.0625;\n\thitPos = Camera;\n\tvec3 pos = Camera;\n    \n    material d;\n    d = sceneSDF( pos );\n    \n    \tfor ( int i = 0; i < iter; i++ ) {\n            if ( d.hit < epsilon ) { // we are inside \n                hitPos = pos;\n                hitNrm = estimateNormal( pos, d.hit );\n                break;\n            }\n            pos += 0.5 * d.hit * RayDirection;\n            d = sceneSDF( pos );\n        }\n    \n        \n    if (d.ref != 0.0) {\n            for ( int j = 1; j < max_depth; ++j) {\n\n                vec3 normal = estimateNormal( pos, d.hit );\n                RayDirection = reflect (RayDirection, normal);\n                pos += normal * min_dist;\n\n                for ( int i = 0; i < iter; i++ ) {\n                    d = sceneSDF( pos );\n                    if ( d.hit < epsilon ) { // we are inside \n                        hitPos = pos;\n                        hitNrm = estimateNormal( pos, d.hit );\n                        break;\n                    }\n                    pos += 0.5 * d.hit * RayDirection;\n                }\n            }\n            return d;\n    }\n    else return d;\n    \n}\n\nvec3 RayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd,  float mint,  float maxt,  float k) {\n    float res = 1.0;\n    float t = mint;\n    \n    for( int i = 0; i<iter; i++) {\n        if (t>maxt) break;\n        float h = sceneSDF(ro + rd*t).hit;\n        if( h<0.001 ) {\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    \n    return res;\n}\n\n\nvec3 shade( vec3 pos, vec3 N, vec4 light, vec3 Camera, material RM, vec3 dir)\n{\n\tvec3 L = light.xyz - pos;\n\t\n\tfloat LLen = length(L);\n\tL = normalize(L);\n    \n    vec3 V = Camera - pos;\n    V = normalize (V);\n\t\n    vec3 R = reflect (-L, N);\n    \n\tfloat comb = 0.01;\n\tfloat vis = softshadow( pos, L, 0.0625, LLen, 8.0);\n    float k_d = RM.diff;\n\tfloat k_s = RM.spec;\n    float delta = 0.0;\n    \n\tif ( vis > 0.0 ) {\n        \n\t\tfloat diff = k_d * max( 0.0, dot( N, L ) );\n        float spec = k_s * max( 0.0, pow(dot( R, V ), 8.0 ) );\n        \n\t\tfloat attn = 1.0 - pow( min( 1.0, LLen / light.w ), 2.0 );\n        \n        if (RM.ref != 0.0) {delta = RM.ref * (1.0- RM.ref);}\n\t\tcomb += diff * attn * vis + spec * attn * vis + delta*vis;\n\t}\n\t\n\treturn vec3(comb);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    //vec2 uv = 2.5*(fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    \n    vec2 m = 2.0 * iMouse.xy/iResolution.xy;\n    \n    float rotX = (iMouse.x/iResolution.x)*2.0*PI;\n    vec3 camO = vec3(cos(rotX),0.4,sin(rotX))*0.95;\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD,vec3(0,1,0)));\n    vec3 camU = cross(camR,camD);\n    \n    //vec3 Camera = 6.0 * vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x));\n    //vec3 Camera = vec3 (0.0, 2.0, 5.0);\n    vec3 Camera = vec3 (1.0 * m.x, 2.0 * m.y, -5.0 * m.y);\n    vec3 Direction = normalize (vec3 (uv.x, uv.y - 0.2, 1.0));\n    \n    \n    //vec3 Direction = RayDirection(100.0, iResolution.xy, fragCoord);\n    //vec3 Camera = vec3(0.0, 2.0, 5.0);\n    \n    \n    //light\n    vec4 light1 = vec4( 3.0, 6.0, 3.0, 9.0 );\n\t\n\tvec4 light2 = vec4( -2.0, 3.0, 0.0, 8.0 );\n\tlight2.x = -cos( iTime * 1.2 ) * 4.0;\n\tlight2.z = -sin( iTime * 1.2 ) * 4.0;\n    \n    vec4 light3 = vec4 (-2.0, 2.0, -1.0, 9.0 );\n    \n    float delta = 1.0;\n    vec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n    material RM = RayMarching (Camera, Direction, sceneWsPos, sceneWsNrm);\n    vec4 depth = vec4(RM.color, RM.hit);\n   \n    if (RM.ref != 0.0) {delta = RM.ref * (1.0 - RM.ref);}\n    if (depth.a<epsilon) {\n        \n\t\tvec3 shade1 = shade( sceneWsPos, sceneWsNrm, light1, Camera, RM, Direction );\n\t\tvec3 shade2 = shade( sceneWsPos, sceneWsNrm, light2, Camera, RM, Direction );\n        vec3 shade3 = shade( sceneWsPos, sceneWsNrm, light3, Camera, RM, Direction );\n\t\t\n\t\tvec3 shadeAll = \n\t\t\t  shade1 *vec3 (0.5, 0.5, 0.5) + shade2 * vec3( 0.6, 0.5, 0.5 )\n            \t+ shade3 * vec3(0.4, 0.4, 0.5);\n        \n\t\tfragColor = vec4(delta * depth.rgb * shadeAll, 1.0 );\n\t}\n\telse {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t}\n    \n}","name":"Image","description":"","type":"image"}]}