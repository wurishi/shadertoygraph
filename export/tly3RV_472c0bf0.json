{"ver":"0.1","info":{"id":"tly3RV","date":"1579366195","viewed":276,"name":"RingTest","username":"dila","description":"Test","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nmat2 timerot(float f, float t, float n) {\n\treturn rot(mix(f,0.0,clamp(abs(mod(t,n)),0.0,1.0)) * 3.141592);\n}\n\nfloat ismissing(float t) {\n    return min(mod(t, 2.0) * mod(t, 3.0) * mod(t, 5.0), 1.0);\n}\n\nfloat cutbox(vec3 p, float a, float b) {\n    vec3 q = abs(p);\n    float ba = max(q.x - a, q.y - a);\n    float bb = max(q.x - b, q.y - b);\n    return max(max(ba, -bb), q.z - 0.1);\n}\n\nfloat map(vec3 p) {\n    float gt = iTime * 2.0;\n    \n    float t = floor(mod(gt, 30.0));\n    float f = smoothstep(0.0, 1.0, fract(gt));\n    \n\tfloat nt = ismissing(t);\n    \n    vec3 q = p;\n    q.z += mix(0.0, sin(f*3.141592*1.0), nt);\n    q.yz *= timerot(f, t, 2.0);\n    float disk3 = cutbox(q, 3.0, 2.3);\n\n    q = p;\n    q.z += mix(0.0, sin(f*3.141592*2.0), nt);\n    q.xz *= timerot(-f, t, 3.0);\n    float disk2 = max(max(length(q.xy) - 2.0, 1.5 - length(q.xy)), abs(q.z) - 0.1);\n    \n    q = p;\n    q.z += mix(0.0, sin(f*3.141592*3.0), nt);\n    q.xy *= timerot(-f, t, 5.0);\n    float disk1 = cutbox(q, 0.9, 0.4);\n    \n    vec2 r = vec2(p.z + 3.0, (abs(p.x / 5.0) - 0.5) * 5.0);\n    float back = length(r) - 0.2;\n    p.xy *= rot(3.141592 * 0.5);\n    r = vec2(p.z - 4.0, (abs(p.x / 16.0) - 0.5) * 16.0);\n    back = min(back, length(r) - 0.25);\n    \n    return min(min(min(disk1, disk2), disk3), back);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n  float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 light(vec3 w, vec3 n, vec3 p, vec3 c) {\n\tvec3 d = w - p + n * 0.01;\n    float l = length(d);\n    float m = max(sign(trace(p, d / l) - l), 0.0);\n    float a = 1.0 / (1.0 + dot(d, d) * 0.01);\n    float s = max(dot(d / l, -n), 0.0);\n    return s * a * c * m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.2));\n    vec3 o = vec3(0.0, 0.0, -6.0);\n\n    float gt = iTime * 2.0;\n    float nt = floor(mod(gt, 30.0));\n    float nf = smoothstep(0.0, 1.0, fract(gt));\n    float isp = mix(0.0, sin(-nf*3.141592*2.0), ismissing(nt));\n    o.z -= isp;\n    r.xy *= rot(3.141592 * -0.25) * timerot(-nf, nt, 5.0);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 n = normal(w);\n    \n    vec3 lit = light(w, n, vec3(1.0, 2.0, -5.0), vec3(0.75, 0.5, 0.5));\n\tlit += light(w, n, vec3(0.0, 0.0, -6.0), vec3(0.0, 0.5, 1.0));\n\n    fragColor = vec4(vec3(sqrt(lit)), 1.0);\n}","name":"Image","description":"","type":"image"}]}