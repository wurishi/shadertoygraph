{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Shows the error (value of distance function at position)\n// -- Left: before binary search -- Right: after binary search\n//#define SHOW_ERROR    \n\n// Use binary search\n#define BINARY\n\n// Quality settings\n//#define VERY_LOW\n//#define LOW\n#define MEDIUM\n//#define HIGH\n//#define VERY_HIGH\n\n#define REFLECTIONS\n#define CLOUDS\n#define SHADOWS\n\n#define SHADOW_ITERS 10\n#define SHADOW_QUALITY 3.0\n#define REFLECTION_ITERS 50\n#define REFLECTION_QUALITY 5.0\n\n#ifdef VERY_LOW\n\t#define LINEAR_ITERS 20\n\t#define BINARY_ITERS 9\n\t#define LINEAR_ACCURACY 1.25\n\t#define LINEAR_DISTANCE_RATIO 0.6\n\t#define FOG_BASE 0.09\n#endif\n\n#ifdef LOW\n\t#define LINEAR_ITERS 40\n\t#define BINARY_ITERS 14\n\t#define LINEAR_ACCURACY 1.2\n\t#define LINEAR_DISTANCE_RATIO 0.3\n\t#define FOG_BASE 0.09\n#endif\n\n#ifdef MEDIUM\n\t#define LINEAR_ITERS 80\n\t#define BINARY_ITERS 11\n\t#define LINEAR_ACCURACY 0.8\n\t#define LINEAR_DISTANCE_RATIO 0.2\n\t#define FOG_BASE 0.06\n#endif\n\n#ifdef HIGH\n\t#define LINEAR_ITERS 140\n\t#define BINARY_ITERS 16\n\t#define LINEAR_ACCURACY 0.6\n\t#define LINEAR_DISTANCE_RATIO 0.05\n\t#define FOG_BASE 0.06\n#endif\n\n#ifdef VERY_HIGH\n\t#define LINEAR_ITERS 280\n\t#define BINARY_ITERS 20\n\t#define LINEAR_ACCURACY 0.3\n\t#define LINEAR_DISTANCE_RATIO 0.04\n\t#define FOG_BASE 0.04\n\t#define AA\n#endif\n\n#define PI 3.14159265358979\n\n//// Noise function by iq\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\nfloat noiseHigh(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                        mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y),\n                    mix(mix(hash(n+113.0), hash(n+114.0), f.x),\n                        mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n//// End iq\n\nvec3 rotate(vec3 p, float theta)\n{\n\tfloat c = cos(theta), s = sin(theta);\n\treturn vec3(p.x, p.y * c + p.z * s,\n\t\t\t\tp.z * c - p.y * s);\n}\n\nfloat clouds(vec2 p) {\n\tfloat final = noise(p);\n\tp *= 2.94; final += noise(p) * 0.4;\n\tp *= 2.87; final += noise(p) * 0.2;\n\tp *= 2.93; final += noise(p) * 0.1;\n\treturn final;\n}\n\nfloat fbm(vec3 p) {\n\tfloat final = noiseHigh(p);\n\tp *= 2.94; final += noise(p.xz) * 0.4;\n\tp *= 2.87; final += noise(p.xz) * 0.1;\n\tfinal += final * 0.005; // Compensate for mssing noise on low quality version\n\treturn pow(final, 1.5) - 1.0;\n}\n\nfloat fbmHigh(vec3 p) {\n\tfloat final = noiseHigh(p); \n\tp *= 2.94; final += noise(p.xz) * 0.4;\n\tp *= 2.87; final += noise(p.xz) * 0.1;\n\tp *= 2.97; final += noiseHigh(p) * final * 0.02;\n\tfinal = pow(final, 1.5);\n\tp *= 1.97; final += noise(p) * final * 0.007;\n\tp *= 1.99; final += noise(p) * final * 0.002;\n\tp *= 1.91; final += noise(p) * final * 0.0008;\n\treturn final - 1.0;\n}\n\nfloat scene(vec3 pos) {\n\treturn pos.y - fbm(pos * 0.006) * 80.0 + 55.0;\n}\n\nfloat sceneHigh(vec3 pos) {\n\treturn pos.y - fbmHigh(pos * 0.006) * 80.0 + 55.0;\n}\n\nvec3 normal(vec3 x) {\n\tconst vec2 eps = vec2(0.1, 0.0);\n\tfloat h = scene(x);\n\treturn normalize(vec3(\n\t\t(scene(x+eps.xyy)-h),\n\t\t(scene(x+eps.yxy)-h),\n\t\t(scene(x+eps.yyx)-h)\n\t));\n}\n\nvec3 normalHigh(vec3 x) {\n\tconst vec2 eps = vec2(0.05, 0.0);\n\tfloat h = sceneHigh(x);\n\treturn normalize(vec3(\n\t\t(sceneHigh(x+eps.xyy)-h),\n\t\t(sceneHigh(x+eps.yxy)-h),\n\t\t(sceneHigh(x+eps.yyx)-h)\n\t));\n}\n\nfloat shadow(vec3 rpos, vec3 rdir) {\n\tfloat t = 1.0;\n\tfloat sh = 1.0;\n\n\tfor (int i = 0; i < SHADOW_ITERS; i++) {\n\t\tvec3 pos = rpos + rdir * t;\n\t\tfloat h = scene(pos);\n\t\tif (h < 0.01) return 0.0;\n\t\tsh = min(sh, h/t*8.0);\n\t\tt += max(h, SHADOW_QUALITY);\n\t}\n\t\n\treturn sh;\n}\nconst float waterHeight = 100.0;\nconst vec3 lightDir = vec3(0.819232, 0.573462, 0.);\n\nvec3 calculateFogColor(vec3 rpos, vec3 rdir) {\n\tvec3 col = mix(vec3(0.3, 0.5, 0.7), vec3(0.0, 0.05, 0.1), clamp(rdir.y*2.5, 0.0, 1.0));\n\tcol += pow(dot(lightDir, rdir) * 0.5 + 0.5, 2.0) * vec3(0.3, 0.2, 0.1);\t\n\treturn col;\n}\n\nvec3 traceRefl(vec3 rpos, vec3 rdir) {\n\tfloat tfar = (rpos.y - 10.0) / rdir.y;\n\tfloat t = 0.0, h = 0.0;\n\t\n\tvec3 pos = vec3(0.0);\n\tfor (int i = 0; i < REFLECTION_ITERS; i++) {\n\t\tpos = rpos + rdir * t;\n\t\th = scene(pos);\n\t\tif (h < 0.0001) break;\n\t\tt += min(h*2.0, REFLECTION_QUALITY);\n\t\tif (t > 2000.0) return calculateFogColor(rpos, rdir);\n\t}\n\t\n\tif (h < 1.0) return vec3(0.0, 0.0, 0.0);\n\treturn calculateFogColor(rpos, rdir);\n}\n\nvec3 shade(vec3 rpos, vec3 rdir, float t, vec3 pos) {\n\tfloat watert = ((rpos.y - waterHeight-10.0) / rdir.y);\n\t\n\t// Calculate fog\n\tfloat b = 0.01;\n\tfloat fogt = min(watert, t);\n\tfloat fog = 1.0 - FOG_BASE * exp(-rpos.y*b) * (1.0-exp(-fogt*rdir.y*b)) / rdir.y;\n\tvec3 fogColor = calculateFogColor(rpos, rdir);\n\n\tvec4 ns = texture(iChannel0, pos.xz * 0.0001);\n\t\n\tif (fog < 0.01) return fogColor;\n\t\n\tvec3 nl = normal(pos);\n\tvec3 n = normalHigh(pos);\n\tfloat h = pos.y;\n\t\n\tfloat slope = n.y;\n\tvec3 albedo = vec3(0.36, 0.25, 0.15);\n\t\n\t// Apply texture above water\n\tif (watert > t) {\n\t\tfloat snowThresh = 1.0 - smoothstep(-50.0, -40.0, h) * 0.4 + 0.1;\n\t\tfloat grassThresh = smoothstep(-70.0, -50.0, h) * 0.3 + 0.75;\n\t\t\n\t\tif (nl.y < 0.65)\n\t\t\talbedo = mix(albedo, vec3(0.65, 0.6, 0.5), smoothstep(0.65,0.55,nl.y));\n\t\tif (slope > grassThresh - 0.05)\n\t\t\talbedo = mix(albedo, vec3(0.4, 0.6, 0.2), smoothstep(grassThresh-0.05,grassThresh+0.05,slope));\n\t\tif (slope > snowThresh - 0.05)\n\t\t\talbedo = mix(albedo, vec3(1.0, 1.0, 1.0), smoothstep(snowThresh-0.05,snowThresh+0.05,slope));\n\t}\n\t\n\t// Fade in 'beach' and add a bit of noise\n\talbedo = mix(albedo, vec3(0.6, 0.5, 0.2), smoothstep(-waterHeight+4.0,-waterHeight+0.5,h));\n\n\t// Lighting\n\tfloat diffuse = clamp(dot(n, lightDir), 0.0, 1.0);\n\t#ifdef SHADOWS\n\tif (diffuse > 0.005) diffuse *= shadow(pos, vec3(lightDir.xy, -lightDir.z));\n\t#endif\n\tvec3 col = vec3(0.0);\n\tcol += albedo * vec3(1.0, 0.9, 0.8) * diffuse;\n\tcol += albedo * fogColor * max(n.y * 0.5 + 0.5, 0.0) * 0.5;\n\t\n\t// Shade water\n\tif (t >= watert) {\n\t\tfloat dist = t - watert;\n\t\tvec3 wpos = rpos+rdir*watert;\n\t\tcol *= exp(-vec3(0.3, 0.15, 0.08)*dist);\n\t\t\n\t\tfloat f = 1.0 - pow(1.0 - clamp(-rdir.y, 0.0, 1.0), 5.0);\n\t\tvec3 refldir = rdir * vec2(-1.0, 1.0).yxy;\n\t\trefldir = normalize(refldir + ns.xyz * 0.1);\n\t\t#ifdef REFLECTIONS\n\t\tvec3 refl = traceRefl(wpos, refldir);\n\t\t#else\n\t\tvec3 refl = calculateFogColor(wpos, refldir);\n\t\t#endif\n\t\tcol = mix(refl, col, f);\n\t}\n\t\n\treturn mix(fogColor, col, fog);\n}\n\nvec3 trace(vec3 rpos, vec3 rdir) {\n\tfloat t = (rpos.y - 10.0) / rdir.y;\n\tfloat tfar = (rpos.y - 150.0) / rdir.y;\n\tfloat cloudst = (rpos.y + 130.0) / rdir.y;\n\tfloat dt = (tfar - t) / 80.0;\n\t\n\tif (t > 0.0 && tfar > t) {\n\t\tfloat pt = 0.0, h;\n\t\tvec3 pos = vec3(0.0);\n\t\t\n\t\t/// Distance map search\n\t\tfor (int i = 0; i < LINEAR_ITERS; i++) {\n\t\t\tpos = rpos + rdir * t;\n\t\t\th = scene(pos);\n\t\t\tif (h < 0.0001) break;//return vec3(float(i)/80.0);\n\t\t\tpt = t;\n\t\t\tt += max(h * LINEAR_ACCURACY, dt * LINEAR_DISTANCE_RATIO);\n\t\t\tif (t > tfar || t > 2000.0) return calculateFogColor(rpos, rdir);\n\t\t}\n\t\t\n\t\t//return vec3(1.0, 0.0, 0.0);\n\t\t\n\t\t#ifdef SHOW_ERROR\n\t\tif (fragCoord.x < iResolution.x*0.5) return vec3(abs(h));\n\t\t#endif\n\t\t\t\n\t\t/// Binary search\n\t\t#ifdef BINARY\n\t\tfloat st = (t - pt)*0.5;\n\t\tfloat bt = pt+st;\n\t\tfor (int i = 0; i < BINARY_ITERS; i++) {\n\t\t\tpos = rpos + rdir * bt;\n\t\t\th = scene(pos);\n\t\t\tif (abs(h) < 0.0001) break;\n\t\t\tst *= sign(h) * sign(st) * 0.5;\n\t\t\tbt += st;\n\t\t}\n\t\t#else\n\t\tfloat bt = t;\n\t\t#endif\n\t\t\n\t\t#ifdef SHOW_ERROR\n\t\treturn vec3(abs(h));\n\t\t#endif\n\t\t\n\t\treturn shade(rpos, rdir, bt, rpos + rdir * bt);\n\t}\n\t#ifdef CLOUDS\n\telse if (cloudst > 0.0) {\n\t\tvec3 fc = calculateFogColor(rpos, rdir);\n\t\tfloat f = 1.0/exp(cloudst*0.0005);\n\t\t\n\t\tvec3 pos = rpos + rdir * cloudst;\n\t\tfloat c = clouds(pos.xz*0.005);\n\t\tfloat c2 = clouds((pos.xz+vec2(50.0, 0.0))*0.005);\n\t\tfloat dir = max((c-c2)+0.5, 0.0);\n\t\t\n\t\tc = max(c - 0.5, 0.0) * 1.8;\n\t\tc = c*c*(3.0-2.0*c);\n\t\tvec3 col = mix(vec3(0.4, 0.5, 0.6), vec3(1.0, 0.9, 0.8), dir);\n\t\treturn mix(fc, col, clamp(f*c, 0.0, 1.0));\n\t}\n\t#endif\n\t\n\treturn calculateFogColor(rpos, rdir);\n}\n\n// Ray-generation\nvec3 camera(vec2 px) {\n\tvec2 rd = (px / iResolution.yy - vec2(iResolution.x/iResolution.y*0.5-0.5, 0.0)) * 2.0 - 1.0;\n\tvec3 rpos = vec3(iTime*2.0, 5.0, iTime*20.0);\t\n\tvec3 rdir = rotate(vec3(rd.x*0.5, rd.y*0.5, 1.0), -0.2);\n\treturn trace(rpos, normalize(rdir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t#ifdef AA\n\tvec3 col = (camera(fragCoord.xy) + camera(fragCoord.xy + vec2(0.0, 0.5))) * 0.5;\n\t#else\n\tvec3 col = camera(fragCoord.xy);\n\t#endif\n\tfragColor = vec4(pow(col, vec3(0.4545)), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdl3W7","date":"1372340370","viewed":1399,"name":"Lakes and mountains","username":"vanburgler","description":"Uses ray-marching and binary-search (@Dave_Hoskins thanks for the idea) for terrain intersection, uses iq's noise functions, penumbra shadows and fog. Water uses Beer's law and fresnel approximation.\nv1.1 - Added tunables\nV1.2 - Bug-fixes","likes":24,"published":1,"flags":0,"usePreview":1,"tags":["noise","terrain","raymarch","fbm"],"hasliked":0,"parentid":"","parentname":""}}