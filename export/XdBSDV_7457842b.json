{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define add(a,b)    min((a),(b))\n#define com(a,b)    max((a),(b))\n#define neg(a)        (-(a))\n#define sub(a,b)    com((a),neg(b))\n#define inf(a,v)    ((a)+(v))\n\n#define pi2            (2.*3.141593)\n#define R(plane,a)  (plane=vec2(cos((a)*pi2)*plane.x+sin((a)*pi2)*plane.y,cos((a)*pi2)*plane.y-sin((a)*pi2)*plane.x))\n\n#define pmod(a,b)    ( mod(mod((a),(b))+(b),(b)) )\n#define rep(a,r)    ( pmod(((a)+(r)*.5),(r))-(r)*.5 )\n\n#define repx(a,r)    vec3( rep((a).x,(r)), (a).yz )\n#define repy(a,r)    vec3( (a).x, rep((a).y,(r)), (a).z )\n#define repz(a,r)    vec3( (a).xy,rep((a).z,(r)) )\n#define repxy(a,r)    vec3( rep((a).xy,(r)), (a).z )\n#define repyz(a,r)    vec3( (a).x, rep((a).yz,(r)) )\n#define repxz(a,r)    vec3( rep((a).x,(r)), (a).y, rep((a).z,(r)) )\n\n\nfloat qla(vec3 pos,float r)\n{\n    return length(pos)-r;\n}\n\nfloat szescian(vec3 pos,vec3 s)\n{\n    pos = abs(pos)-s;\n    return max(pos.x,max(pos.y,pos.z));\n}\n\n\nfloat fn(vec3 pos)\n{\n    R(pos.xy,iTime/8.);\n    pos = repxy(pos,3.);\n    float q = qla(pos,1.2);\n    float s = szescian(pos,vec3(1.,1.,1.));\n    return sub(s,q);\n}\n\nfloat light(vec3 n,vec3 pos,vec3 ldir)\n{\n    ldir = normalize(ldir);\n\n    pos += n*.02;\n    vec3 spos = pos;\n    for(int i=0;i<50;i++)\n        pos += ldir*fn(pos);\n    if( length(pos-spos)<50. )\n        return 0.;\n\n    return clamp(dot(n,ldir),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vpos = uv*2.-1.;\n    vpos.x *= iResolution.x/iResolution.y;\n    vpos *= .65;\n\n    float t = iTime;\n//    vec3 front = normalize(vec3(sin(t),cos(t),0));\n    vec3 front = normalize(vec3(1.,0.,-0.5));\n    vec3 up = vec3(0,0,1);\n    vec3 right = cross(up,front);\n    vec3 pos = vec3(0.,0.,0.)-front*8.0;\n\n    vec3 rdir = normalize(front + vpos.x*right + vpos.y*up);\n\n    vec3 rpos = pos;\n    float d;\n\n    for(int i=0;i<50;i++)\n    {\n        d = fn(rpos);\n        rpos += d*rdir;\n        if(d<0.01) break;\n    }\n\n    if( d>0.05 )\n    {\n        // pustkosc\n        fragColor = vec4(.5,.8,.9,0.)*(pow(1.-abs(rdir.z),1.5));\n    }\n    else\n    {\n        // trafiony - normalka z pochodnych czastkowych (gradient)\n        vec2 e = vec2(0.01,0.);    // delta (epsilon)\n        // to sie dobrze kompresuje, ale Pawel tego nieeeee chceeeee... :P\n        // (chce, ale potem)\n        //vec3 n = normalize( vec3(\n        //    fn(rpos+e.xyy)-fn(rpos-e.xyy),\n        //    fn(rpos+e.yxy)-fn(rpos-e.yxy),\n        //    fn(rpos+e.yyx)-fn(rpos-e.yyx)\n        //) );\n\n        vec3 n = normalize(vec3(\n            fn(vec3(rpos.x+e.x, rpos.y, rpos.z)) - fn(vec3(rpos.x-e.x, rpos.y, rpos.z)),\n            fn(vec3(rpos.x, rpos.y+e.x, rpos.z)) - fn(vec3(rpos.x, rpos.y-e.x, rpos.z)),\n            fn(vec3(rpos.x, rpos.y, rpos.z+e.x)) - fn(vec3(rpos.x, rpos.y, rpos.z-e.x))));\n\n        vec3 col = vec3(0.);\n        float sunh = (sin(iTime)*.5+.5)*.5+.2;\n        col += light(n,rpos,vec3(-1.,-1.,sunh))*vec3(1,.8,.7);    // sun light\n        col += (1.-col)*(n.z*.5+.5)*vec3(.2,.6,.9);    // sky light; *(1-col) - soft swiatlo\n\n        fragColor = vec4(sqrt(col),0.);\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdBSDV","date":"1415832286","viewed":271,"name":"ShaderKK","username":"pjdevpl","description":"testing ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["shadows","spheretracing","repeat"],"hasliked":0,"parentid":"","parentname":""}}