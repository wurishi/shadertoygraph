{"ver":"0.1","info":{"id":"dlXfz2","date":"1693405715","viewed":75,"name":"Hex grid procedural generation","username":"vizaxo","description":"Procedurally-generated hex grid world with trains","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["procedural","hex","train","procgen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct cell {\n    vec2 uv;\n    ivec2 id;\n};\n\ncell hexGrid(vec2 uv) {\n    vec2 r = vec2(1.73, 1.);\n    vec2 h = r*0.5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 aID = floor(uv/r);\n    vec2 b = mod(uv-h, r)-h;\n    vec2 bID = floor((uv-h)/r);\n\n    bool aGrid = dot(a,a)<dot(b,b);\n    \n    vec2 gId = aGrid ? vec2(aID.x*2.-1., aID.x+aID.y-1.) : vec2(bID.x*2., bID.y+bID.x);\n    vec2 gv  = aGrid ? a : b;\n    \n    return cell(gv, ivec2(gId));\n}\n\nvec3 colourScene (cell c) {\n    float height = (texelFetch(iChannel0, c.id+OFFSET, 0).r);\n    \n    // base colour\n    vec3 col = vec3(0.);\n    float seaLevel = -5.;// + sin(iTime)*0.3;\n    if (height < seaLevel)\n        col.rgb = mix(vec3(0,0,0.0), vec3(0, 0.1, 0.95), (height+16.) / (seaLevel+16.));\n    //else if (height < seaLevel+1.0)\n        //col.rgb = vec3(0.9, 1.0, 0)*0.7;\n    else if (height > 10.0)\n        col = vec3(1.0)*0.9;\n    else\n        col = mix(vec3(0,0.15,0), vec3(0,1,0),(height-seaLevel) / 16.);\n        \n    // tracks\n    if (c.id.x == 40 && c.id.y < 14 || c.id.y == 14 && c.id.x <= 40) {\n        float trackCoord = float(c.id.y);\n        if (c.id.y == 14) {\n            float theta;\n            if (c.id.x == 40) theta = -3.1415/1.50;\n            else              theta = -3.1415/1.2;\n            \n            c.uv = mat2(sin(theta), -cos(theta), cos(theta), sin(theta)) * c.uv;\n            if (c.id.x == 40) c.uv += vec2(-0.20, 0.0);\n            trackCoord = -float(c.id.x) + 54.;\n        }\n    \n        if (abs(c.uv.x) < 0.16 && abs(c.uv.x) > 0.05)\n            col = vec3(0,0,0);\n        if (mod(c.uv.y, 0.3) < 0.10 && abs(c.uv.x) < 0.25)\n            col = vec3(0,0,0);\n            \n        // train\n        float trainLen = 20.;\n        float t = mod(iTime * 10., 150.);\n        float carId = trackCoord - floor(t)+30.;\n        //if (trackCoord > floor(t)-30. && trackCoord < (floor(t) - 30. + trainLen+1.)) {\n        if (carId >= 0. && carId <= trainLen) {\n            if (abs(c.uv.x) < 0.2 && abs(c.uv.y) < 0.4) {\n                if (carId == trainLen)\n                    col = vec3(0.8,0,0.2);\n                else\n                    col = vec3(length(c.uv)*1.3);\n            }\n        }\n\n        t = mod(iTime*20., 200.);\n        trainLen = 6.;\n        if (trackCoord > floor(t)-80. && trackCoord < (floor(t)-80. + trainLen+1.)) {\n            if (abs(c.uv.x) < 0.2 && abs(c.uv.y) < 0.4) col = vec3(0.7,0.3,0.3);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y - 0.5) * 2.;\n    //uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 20.;\n    uv.x += 10.;\n    cell c = hexGrid(uv);\n    \n    vec3 col = colourScene(c);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 id = ivec2(fragCoord) + OFFSET;\n    vec2 p = vec2(id)/0.7895; // perlin integer coords give 0\n    float height = 0.;\n    \n    height +=noise(p);\n    height +=noise(p/2.)*2.;\n    height +=noise(p/4.)*4.;\n    height +=noise(p/8.)*8.;\n    height +=noise(p/16.)*16.;\n    \n    fragColor = vec4(height, 0.0, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 OFFSET = ivec2(100,100);\n\nvec2 randomGradient(int ix, int iy) {\n    const uint w = 8u * 4u;\n    const uint s = w / 2u; // rotation width\n    uint a = uint(ix), b = uint(iy);\n    a *= 3284157443u; b ^= a << s | a >> w-s;\n    b *= 1911520717u; a ^= b << s | b >> w-s;\n    a *= 2048419325u;\n    float random = float(a) * (2.*3.14159265 / pow(2.,32.)); // in [0, 2*Pi]\n    vec2 v;\n    v.x = cos(random); \n    v.y = sin(random);\n    return v;\n}\n\nfloat f (float t) {\n    return 3.*t*t - 2.*t*t*t;\n}\n\nfloat perlinNoise(vec2 p) {\n    vec2 v0 = floor(p);\n    vec2 v1 = ceil(p);\n    float x0 = v0.x;\n    float y0 = v0.y;\n    float x1 = v1.x;\n    float y1 = v1.y;\n    vec2 g00 = randomGradient(int((v0.x)), int((v0.y)));\n    vec2 g01 = randomGradient(int((v0.x)), int((v1.y)));\n    vec2 g10 = randomGradient(int((v1.x)), int((v0.y)));\n    vec2 g11 = randomGradient(int((v1.x)), int((v1.y)));\n    \n    float s = dot(g00, p - vec2(x0,y0));\n    float t = dot(g10, p - vec2(x1,y0));\n    float u = dot(g01, p - vec2(x0,y1));\n    float v = dot(g11, p - vec2(x1,y1));\n    \n    float Sx = f(p.x-x0);\n    float a = s+Sx*(t-s);\n    float b = u+Sx*(v-u);\n    \n    float Sy = f(p.y-y0);\n    float z = a+Sy*(b-a);\n    return z;\n}\n\nfloat noise(vec2 v) { return perlinNoise(v); }","name":"Common","description":"","type":"common"}]}