{"ver":"0.1","info":{"id":"tlcGz8","date":"1617059648","viewed":55,"name":"Lava Lamp Experiment","username":"etiennecreator","description":"lava","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float lipschitzFallOff = 1.71730020672; // http://liris.cnrs.fr/~egfr/BestPapers/Deuxieme2014_Genevaux.pdf\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 blue=vec3(0,0.0,1.0);\nconst vec3 green=vec3(0.0,1.0,0.0);\nconst vec3 pink=vec3(0.8,0.6,0.6);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 fonce=vec3(0.141,0.117,0.078);\nconst vec3 clair=vec3(0.407,0.329,0.211);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 orangeFonce = vec3(0.3,0.0,0.0);\nconst vec3 blanc = vec3(0.9,0.9,0.9);\nconst vec3 noir = vec3(0.1,0.1,0.1);\nconst vec3 tenebres = vec3(0.0,0.0,0.0);\n\n\n\n\n// ----------------------------------\n// Noise\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) \n{ \n    return fract(sin(n)*43758.5453123); \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nfloat noiseGen(in vec3 p, float frequence)\n{\n    float b = 0.0;\n    vec3 q = frequence*p;\n    b += 0.7*noise(q); q = m*q*2.01;\n    b += 0.25*noise(q); q = m*q*2.02;\n    b/= 0.7+0.25;\n    \n    return b;\n}\n\nvec3 warp(in vec3 p)\n{\n \tfloat b = noiseGen(p, .25);\n    vec3 pprime = vec3(p.x + b, p.y + cos(b)*b, p.z + sin(b)*b);\n\n    return pprime;\n}\n\n\n// ----------------------------------\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n\n\n\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n\n\n\n// ----------------------------------\n\n\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n\n\n\n\nfloat klipschitz(float e, float R) {\n \treturn e * lipschitzFallOff / R;   \n}\n\nfloat lavaLamp(vec3 p, out float lip, out vec3 colorOut)\n{\n    lip = klipschitz(1.0, 1.5);\n    \n    //p =  rotateZ(p, 52.0);\n    \n \n \tfloat sphere1 = point(warp(p), vec3(\n        0.4 * cos(iTime), \n        ((1.0 +cos(iTime*0.4))/2.0)*6.-2., \n        0.4*sin(iTime)\n    ), 1.0, 1.5);\n   \n \tfloat sphere2 = point(warp(p), vec3(\n        0.2*sin(iTime),\n        ((1.0+cos(iTime*0.2))/2.0)*3.5-1.75, \n        0.2*cos(iTime)\n    ), 1.5, 2.0);\n  \n \tfloat sphere3 = point(warp(p), vec3(\n        0.5*sin(iTime+3546.), \n        ((1.0+cos(iTime*0.3))/2.0)*4.5-2.25, \n        0.5*cos(iTime+3546.)\n    ), 1.25, 1.75);\n    \n   \n   \n    float v = sphere1+sphere1+sphere3;\n    return v;\n    \n}\n\n// ----------------------------------\n\n\n\n\n// Potential field of the object\n// p : point\n// lip : lipschitz's constant\n// color : color of the point\nfloat object(vec3 p, out float lip, out vec3 color)\n{\n  p.z=-p.z;\n    \n    \n    vec3 aCube = vec3(-1.5,-1.5,-1.5);\n    vec3 bCube = vec3(1.5,1.5,1.5);\n    vec3 sphr1 = vec3(1.,0.0,0.0);\n    vec3 sphr2 = vec3(-1.,0.0,0.0);\n\n  \tfloat v = lavaLamp(p, lip, color);\n    \n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    float lip = 0.0;\n    vec3 color;\n  float v = object(p, lip, color);\n  n.x = object( vec3(p.x+eps, p.y, p.z) , lip, color) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) , lip, color) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) , lip, color) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip = 0.0;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\tfloat lip = 0.0;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lip);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\n// color : color of the point\nvec3 Shade(vec3 p, vec3 n, in vec3 color)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.5*color;\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\tvec3 color;\n  float t = SphereTrace(ro, rd, hit,s, color);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n, color);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}