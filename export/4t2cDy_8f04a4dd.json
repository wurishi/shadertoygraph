{"ver":"0.1","info":{"id":"4t2cDy","date":"1510021420","viewed":850,"name":"462 Shader Quiz","username":"KeenanCrane","description":"Fill in the \"TODOs\" in the method shade() at the top of the program.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["educational","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\nvec3 shade( in vec3 N, in vec3 L, in vec3 V, in vec3 R )\n{   \n    // color of each term\n    vec3 diffuseColor = vec3(1,0,0);\n    vec3 specularColor = vec3(1,.8,.5);\n    vec3 fresnelColor = vec3(1,1,1);\n    vec3 ambientColor = vec3(1,1,1);\n    \n    // intensity of each term\n    float kd = .9;\n    float ks = .6;\n    float kf = .4;\n    float ka = .03;\n    \n    // tuning parameters\n    float k = 10.; // specular glossiness\n    float p = 5.; // fresnel sharpness\n    \n    // TODO add the diffuse term\n    float diffuse = 0.;\n    \n    // TODO add the specular term\n    float specular = 0.;\n    \n    // TODO add the fresnel term\n    float fresnel = 0.;\n    \n    // TODO add the ambient term\n    float ambient = 0.;\n    \n    return kd * diffuse * diffuseColor +\n           ks * specular * specularColor +\n           kf * fresnel * fresnelColor +\n           ka * ambient * ambientColor ;\n}\n\n//------------------------------------------------------------------------------\n// (Nothing to edit below this line)\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    \n    vec3 color = vec3(0,0,0);\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n\n    // We've hit something in the scene\n    if (hit.y > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l1 = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 l2 = normalize(vec3(-0.6, 0.5, 0.7));\n        vec3 r = normalize(reflect(direction, n));\n\n\n        vec3 diffuseColor;\n        \n        if (hit.y < 4.0)  {\n            // sphere\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            diffuseColor = 0.4 + f * vec3(0.6);\n            color = diffuseColor;\n        } else if (hit.y < 16.0) {\n            // sphere\n            diffuseColor = vec3(0.3, 0.0, 0.0);\n            color  = shade( n, l1, v, r );\n            color += shade( n, l2, v, r );\n        }\n    }\n\n    return color;\n}\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0,.4,0);\n\n    origin.x += 1.1 * cos(iTime * 0.2);\n    origin.z += 1.1 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.8, 0.8, 1.0), 1.0 - exp2(-0.1 * distance * distance));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}