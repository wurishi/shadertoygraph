{"ver":"0.1","info":{"id":"3sfSW7","date":"1551378246","viewed":211,"name":"Polar juggling","username":"duvengar","description":"Based on a comment by Shane in this [url=https://www.shadertoy.com/view/ll2fzG]Shader[/url] by skaplun. I ended up playing around with some frequencies looking for harmonious interlaced patterns. Uncomment SHOW_STRUC  to see better how it works.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Polar juggling\"\n// by Julien Vergnaud @duvengar-2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n// Based on a comment by Shane in this shader https://www.shadertoy.com/view/ll2fzG by skaplun.\n// I ended up playing around with some frequencies looking for harmonious interlaced patterns.\n// Uncomment SHOW_STRUC  to see better how it works.\n// ====================================================================\n\n\n#define R iResolution.xy\n#define T iTime*.5\n#define TWO_PI (2.* acos(-1.))\n#define PI acos(-1.)\n#define POL(u) vec2(atan(u.y,u.x)/TWO_PI, length(u))\n#define ROT2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//#define SHOW_STRUC \n#define DOMAIN_REP\n#define BLACK_BG\n#define GRAIN\n\n\nfloat hash( float n ){\n    \n\treturn fract(sin(n)*75728.5453123); \n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    // INITIALIZING\n\t/////////////////////////////////////////////////////////\n    vec2 uv =  (U.xy - R *.5) / R.y;\n    \n    vec2 pc = uv  *22.;                        // domain zoom -\n\tpc *= ROT2(iTime*.2);\n    float pa = POL(pc).x ;                     // polar Angle\n\n    float steps = 40.;                         // number of steps\n    \n    float index =  floor(pa * steps);          // id for each step from 0 > 1\n    \n    float sa = (index + .5) / steps * TWO_PI;  // remap each step angle\n    \n    float pair = mod(index, 2.);               // if the step is pair or not?\n    \n\n    \n    pc *=  ROT2(sa);                           // rotate coordinate by the step angle\n \t\n    float dist = 3. ;  \n    float speed = tan(T*.3)*.5+.5;\n  \t\n    \n   // float cc[5] = float[5](float(22.),float(3.),float(16.), float(35.), float(11.));     // array of interresting numbers 3(41), 5, 11, 16, 19,  22, 24, 30, 33, 35, 38, 49, 57\n    float cc[5] = float[5](22.,3.,16., 35., 11.); // lol thanks Fabrice !\n    \n    int i =  int(floor(5.*(speed)));\n    float coef = cc[i];\n    float amp = 1.+ cos(coef*(.3*T + index));           // amplitude for sphere offseting\n\n    pc.x -=  dist + amp;                                // translate cartesian coordinates on the X axis\n \t#ifdef DOMAIN_REP\n    pc.x = pc.x >1. && pc.x < 3.? mod(pc.x, 1.) : pc.x; // domain repetition\n    #endif\n    //pa += PI * 1.5;\t\t\t\t\t                    // polar angle adjustement\n    \n\tfloat r = (amp*.19);                                // radius to draw the spheres                      \n\n\t\n   \n    float  b1 = fwidth(length(uv.x)*30.);             // stabilised blur value accross screen for circle's drawing\n    float  b2 = fwidth(pa*steps);                   // stabilised blur value accross screen for polar_grid's drawing\n\n    \n    vec3 polar_G = vec3(1.-smoothstep(.0,b2*1.3,abs(fract(pa*steps)-.5))); // polar segments grid\n    \n    float c  = length(pc + vec2(-.5, .0)) - r;      // the circle's distance function for each steps\n   \n\t\n\n    \n    // SHADING\n    //////////////////////////////////////////////////////////////////////////////////////////\n    \n    vec3 col = vec3(.0);\n    \n    #ifdef SHOW_STRUC\n    col +=  vec3(.1*smoothstep(.0,.1,pc.x));\n    col = clamp(col,vec3(.0),vec3(1.));\n    #endif\n    \n    vec3(.05*index,.0,.0);\n    \n    // drawing the circles with fill or stroke depending on the pair state\n    col += pair == .0 ? vec3(1.-smoothstep(.0,b1,abs(c)-.0015)) :vec3(1.-smoothstep(.0,b1,c)) ;\n    \n    // adding a bit of grain\n    #ifdef GRAIN\n    float noise = length(uv*.5)*hash(uv.x*298.987*uv.y*863.456);\n    col += .1*max(noise,.2);\n    #endif\n    // final color output\n    #ifdef BLACK_BG\n    C = vec4(pow(col,vec3(.6)),.0);\n    #else\n    C = vec4(1.-pow(col,vec3(.6)),.0);\n    #endif\n\n     \n  \n}","name":"Image","description":"","type":"image"}]}