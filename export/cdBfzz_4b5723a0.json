{"ver":"0.1","info":{"id":"cdBfzz","date":"1689384725","viewed":84,"name":"Voronoi with distances","username":"H4mm3r","description":"Distance based texture.\nThank you to alwas for the hamming distance code (https://www.shadertoy.com/view/WtKGWm)","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["distance","hamming","metricspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float seed= 21.9;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float m = 0.;\n    float minDist=100.;\n    float sndDist=100.;\n    float sndCellIndex;\n    float t = 100. + iTime*.3;\n    vec3 col = vec3(0.);\n    float cells = 10.;\n    float stripe=0.;\n    float stripeW = 40.;\n\n    float cellIndex = 0.;\n    \n    if(true){\n    //cool effects\n    for(float i = 1.; i < cells+1.; ++i)\n    {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n        //for alignment with maxDis stripes\n        //vec2 p = floor(stripeW*sin(n*t))/stripeW;\n        \n        float randX = round(N22(vec2(i))).x*2.-1.;\n        float randY = round(N22(vec2(i))).y*2.-1.;\n        \n        //stripe config\n        //float s = float(int(floor(stripeW*maxDis(uv,p)))%2);\n        //float s = float(int(floor(stripeW*(maxDis(uv,p)+disM(uv,p)+disT(uv,p))))%2);\n        float s = float(int(floor(stripeW*disT(uv,p)))%2);\n        \n        //distance config\n        float d = disT(uv,p);\n        \n        //float d = disT(uv,p)+ham(vec2(randX, randY),vec2((p.x-uv.x-randX),p.y-uv.y-randY));\n        //float d = disT(uv,p)+disF(vec2(randX, randY),vec2((p.x-uv.x),p.y-uv.y));\n        \n        if (d < minDist)\n        {\n            minDist=d;\n            stripe = s;\n            cellIndex=i;\n        }\n        else if (d < sndDist)\n        {\n            sndDist = d;\n            sndCellIndex = i;\n        }\n    }\n    }else\n    //grid based, more efficient\n    {\n        uv *= 2.;\n        vec2 gv = fract(uv)-0.5;\n        vec2 id = floor(uv);\n        vec2 cid = vec2(0);\n        \n\n        \n        for(float x =-1.;x<=1.;++x){\n            for(float y =-1.;y<=1.;++y){\n                float randX = round(N22(vec2(x*y))).y*2.-1.;\n                float randY = round(N22(vec2(x*y+1.))).y*2.-1.;\n           \n\n                vec2 offset = vec2(x,y);\n                vec2 n = N22(id+offset);\n                vec2 p = offset + sin(n*t)*.5;\n                \n                float d = disT(gv,p);\n                float s = float(int(floor(stripeW*disT(gv,p)))%3);\n\n                //float d = disT(gv,p)+ham(vec2(randX, randY),vec2((p.x-gv.x-randX),p.y-gv.y-randY));\n\n                \n                if(d<minDist)\n                {\n                    minDist=d;\n                    stripe=s;\n                    cid=id+offset;\n                }\n            }\n        }\n        cellIndex=cid.x*10.+cid.y;\n    }\n\n    //col = vec3(N22(vec2(cellIndex*seed)), N22(vec2(cellIndex)).x);\n    //col = vec3(N22(vec2(sndCellIndex*seed)), N22(vec2(sndCellIndex)).x);\n    //col = vec3(N22(vec2(cellIndex*seed)), N22(vec2(cellIndex)).x)*(1.0-minDist);\n    col = vec3(0.5,N22(vec2(cellIndex*seed)).x,0.3);\n    //col = vec3(stripe);\n    //col = vec3(stripe)*floor(stripeW*(1.-minDist))/stripeW;\n    //col = vec3(N22(vec2(cellIndex*seed)), N22(vec2(cellIndex)).x)*stripe;\n    //col = vec3(N22(vec2(cellIndex))*(1.1+cos(t*5.)), (1.1+sin(t*5.))*N22(vec2(cellIndex)).x)*stripe;    \n    //col = vec3(N22(vec2(cellIndex*seed)), N22(vec2(cellIndex)).x)*stripe*(1.-minDist);\n    //col = vec3(1.-minDist);\n    //col = vec3(minDist);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec2 mainSound( int samp, float time )\n{\n    vec2 n = N22(vec2(1.));\n    vec2 p = sin(n*time);\n    vec2 s1 = vec2(sin(6.2831*200.*(disA(n,p))));\n    vec2 s2 = vec2(sin(6.2831*50.*(disA(n,p*p))));\n\n    return s1+s2;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"float disM(vec2 uv, vec2 p);\nfloat disK(vec2 uv, vec2 p);\nfloat disA(vec2 uv, vec2 p);\nfloat ham(vec2 uv, vec2 p);\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\nfloat factors(vec2 uv)\n{\n    uv*=50.;\n    float n =0.;\n    float p = abs(float(floor(uv.x*uv.y)));\n    for(int i = 2; i < int(sqrt(p));++i)\n    {\n        if(int(p)%i==0)\n        {\n            n++;\n            p/=float(i);\n            i = 2;\n        }\n    }\n    return n;\n}\nfloat disF(vec2 uv, vec2 p)\n{\n    return abs(factors(uv) - factors(p))/3.;\n\n}\nfloat disT(vec2 uv, vec2 p)\n{\n   return sqrt(pow((uv.x-p.x),2.)+pow((uv.y-p.y),2.));\n}\nfloat disI(vec2 uv, vec2 p)\n{\n    vec2 x = (uv+p)/2.;\n    vec2 y = (uv-p)/2.;\n    return (ham(uv,x)+ham(uv,y)+ham(p,x)+ham(p,y)+ham(uv,p)+ham(x,y))/8.;\n    //return (disT(uv,x)+disT(uv,y)+disT(p,x)+disT(p,y)+disT(uv,p)+disT(x,y))/8.;\n    //return (disA(uv,x)+disA(uv,y)+disA(p,x)+disA(p,y)+disA(uv,p)+disA(x,y))/8.;\n    //return (disK(uv,x)+disK(uv,y)+disK(p,x)+disK(p,y)+disK(uv,p)+disK(x,y))/8.;\n\n}\nfloat disM(vec2 uv, vec2 target)\n{\n   return abs(uv.x-target.x)+abs(uv.y-target.y);\n}\n\nfloat disA(vec2 uv, vec2 p)\n{\n     vec2 l = uv-p;\n     return(disT(uv, l)+disT(p,l))/2.;\n}\nfloat ham(vec2 uv, vec2 target) {\n    int a = int(floor(uv.x*uv.y*100.));\n    int b = int(floor(target.x*target.y*100.));\n    float h=0.;    \n    for (int c = 32; c >= 0; c--){\n      int ak = a >> c;\n      int bk = b >> c;\n      if ((ak & 1) != (bk & 1))\n          h++;\n    }\n    return float(h/32.);\n}\nfloat disK(vec2 uv,vec2 p)\n{\n    float x = abs(uv.x-p.x);\n    float y = abs(uv.y-p.y);\n    if(x>y)\n         return x;\n    return y;\n}\nfloat disC(vec2 uv, vec2 p)\n{\n    return tan(abs(uv.y-p.y)/abs(uv.x-p.x));\n}","name":"Common","description":"","type":"common"}]}