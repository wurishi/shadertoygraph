{"ver":"0.1","info":{"id":"stKGD3","date":"1638717558","viewed":137,"name":"Feedback3","username":"akohdr","description":"More (pun) localized feedback exploration with sampling in BufferB originally to prevent strobing.\nDoodle an initial condition and wait, then mouse around to set parameters\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["diffusion","feedback","cellular","reaction"],"hasliked":0,"parentid":"Nly3W3","parentname":"Feedback2"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// \"..look for the girl with sun in her eyes and she's gone.\"\n\n// The lower fps from sampling in BufferB produces a stuttering motion brightness/contrast effect\n// Feels similar to result of old school hand drawn photographed animation ala. YellowSubmarine\n\n\n//#define BREATHING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    fragCoord *= 3.;                     // tiling\n\n#ifdef BREATHING\n    float depth = .1,\n            cad = sin(6.28*iT/7.745);      // √60 == 2√15 near breathing bpm\n    fragCoord -= cad*depth*iR.y;\n    fragCoord *= ((1.-depth)+depth*cad);   // gentle centered zooming (breathing)\n#endif\n\n    fragColor = TX(fragCoord);\n\n    // fract() appears to trip isnan near limits of numeric range\n    fragColor.rgb = trunc(fragColor.rgb)*vec3(.1,.8,.1);\n    \n//    fragColor = vec4(length(fragColor));  //B&W\n//    fragColor = vec4(length(fragColor));  //B&W\n//    fragColor = vec4(mod(length(fragColor),1.));  //B&W\n\n//    fragColor = normalize(fragColor);\n//    fragColor.rgb = normalize(fragColor.rgb);\n\n    // debugging propagation of isnan values\n    if(any(isnan(fragColor.rgb))) fragColor = vec4(1,0,0,0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Technically these are variations of totalistic cellular automata\n// increasingly involved neighbourhood lookups\n// (macro TD(p,dx,dy) is pixel offset texture read on iChannel0)\n\nvec4 moore1(vec2 p)\n{\n    return TD(p,-1, 1) + TD(p, 0, 1) + TD(p, 1, 1) + \n           TD(p,-1, 0) +               TD(p, 1, 0) + \n           TD(p,-1,-1) + TD(p, 0,-1) + TD(p, 1,-1);\n}\n\nvec4 moore1r(vec2 p, float r)\n{\n    return TD(p,-r, r) + TD(p, 0, r) + TD(p, r, r) + \n           TD(p,-r, 0) +               TD(p, r, 0) + \n           TD(p,-r,-r) + TD(p, 0,-r) + TD(p, r,-r);\n}\n\nvec4 moore2(vec2 p, vec2 q)\n{\n    float n = q.x, o = q.y;\n    return TD(p,-n, n) + TD(p, 0, o) + TD(p, n, n) + \n           TD(p,-o, 0) +               TD(p, o, 0) + \n           TD(p,-n,-n) + TD(p, 0,-o) + TD(p, n,-n);\n}\n\nvec4 moore4(vec2 p, vec4 q)\n{\n    float a = q.x, b = q.y, c = q.z, d = q.w;\n    return TD(p,-a, a) + TD(p, 0, b) + TD(p, c, c) + \n           TD(p,-d, 0) +               TD(p, d, 0) + \n           TD(p,-c,-c) + TD(p, 0,-b) + TD(p, a,-a);\n}\n\nvec4 moore4osc(vec2 p, vec4 mag, vec4 freq)\n{\n    vec4 osc1 = .5+.5*sin(TAU*(float(iFrame)/8.)*freq+vec4(0,1,-1,2)*1.54),\n         osc2 = 1. - osc1,  // complementary oscillator  => osc1 + osc2 == 1\n\n    // oscillator freqs and magnitudes determnine Moore radii in four axis\n    q = mag * osc1;\n    float a = q.x, b = q.y, c = q.z, d = q.w;\n    q = mag * osc2;\n    float A = q.x, B = q.y, C = q.z, D = q.w;\n    \n    return TD(p,-a, a) + TD(p, 0, b) + TD(p, c, c) + \n           TD(p,-d, 0) +               TD(p, D, 0) + \n           TD(p,-C,-C) + TD(p, 0,-B) + TD(p, A,-A);\n}\n\n// when we start applying weight we're heading into convolutions\nvec4 moore4ow(vec2 p, vec4 mag, vec4 freq, vec4 weights)\n{\n    vec4 osc1 = .5+.5*sin(TAU*(float(iFrame)/8.)*freq+vec4(0,1,-1,2)*1.54),\n         osc2 = 1. - osc1,  // complementary oscillator  => osc1 + osc2 == 1\n\n    // oscillator freqs and magnitudes determnine Moore radii in four axis\n    q = mag * osc1;\n    float a = q.x, b = q.y, c = q.z, d = q.w;\n    q = mag * osc2;\n    float A = q.x, B = q.y, C = q.z, D = q.w;\n    \n    float n = weights.x, e = weights.y, s = weights.z, w = weights.w; \n    \n    return (n+w)*TD(p,-a, a) + n*TD(p, 0, b) + (n+e)*TD(p, c, c) + \n               w*TD(p,-d, 0) +                     e*TD(p, D, 0) + \n           (s+w)*TD(p,-C,-C) + s*TD(p, 0,-B) + (s+e)*TD(p, A,-A);\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    float t = float(iFrame),                    // framebased time\n          w = TAU*t;                            // angular position\n    \n    vec2 u = iR.xy/vec2(7,5),                   // range of x/y mouse input\n        cs = vec2(cos(w), sin(w)),              // oscillation source\n         r = iM.z>0. ? cs * iM.xy/u : vec2(1);  // diagonal/orthogonal Moore radii\n\n    vec4 self = TX(p),\n         sumN = moore4ow(p, vec4(5.+sin(iT))*r.xyxy, \n                            vec4(PI4*vec4(1,2,3,4)),\n                            vec4(1));\n          \n//    sumN = sumN*sumN*sumN;                    // must be odd to retain sign\n    \n    k.rgb = (sumN.rgb - self.brg)               // swizzle fields\n            * (vec3(.4,.5,.6)/2.);              // add some colour\n;\n    if(iFrame<300)  // allow doodle of an initial condition in first few secs\n        k = iMouse.z>0. && length(p-iMouse.xy)<64. ? vec4(mod(iT,1.)) : k;\n \n\n// deal with inevitable isnan resulting from any overflow of sum\n    float reset = trunc(abs(sin(iTime)));\n    \n    if(mod(t,3.)<1. && any(isnan(k)) ) k = vec4(reset); \n\n//    if(mod(f,3.)<1. && isnan(k.r)) k.r = .0;\n//    if(mod(f,6.)<1. && isnan(k.g)) k.g = .0;\n//    if(mod(f,9.)<1. && isnan(k.b)) k.b = .0;\n    \n    if(isnan(k.r)) k.r = reset;\n    if(isnan(k.g)) k.g = reset;\n    if(isnan(k.b)) k.b = reset;\n    \n//    k.rgb *= .91;  //seems to be limit\n}\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define iT iTime\n#define iM iMouse\n#define iR iResolution\n\n#define PI12    0.261799387799149436538553615273291907016430783281258818414578716\n#define PI8     0.392699081698724154807830422909937860524646174921888227621868074\n#define RT22    0.707106781186547524400844362104849039284835937688474036588339869\n#define PI4     0.785398163397448309615660845819875721049292349843776455243736148\n#define PI3     1.047197551196597746154214461093167628065723133125035273658314864\n#define RT2     1.414213562373095048801688724209698078569671875376948073176679738\n#define PI2     1.570796326794896619231321691639751442098584699687552910487472296\n#define PI      3.141592653589793238462643383279502884197169399375105820974944592\n#define PI3_2   4.712388980384689857693965074919254326295754099062658731462416888\n#define TAU     6.283185307179586476925286766559005768394338798750211641949889185\n\n#define TX(p)  texture(iChannel0, (p)/iR.xy)\n#define TX1(p) texture(iChannel1, (p)/iR.xy)\n#define TD(p,dx,dy) texture(iChannel0, ((p)+vec2((dx),(dy)))/iR.xy)\n\n// sum of Moore neighbours of two radii n=diagonal  o=orthogonal NSEW\n#define MOORE2(p,n,o) (TD(p,-n,n)+TD(p,0,o)+TD(p,n,n)+TD(p,-o,0)+TD(p,o,0)+TD(p,-n,-n)+TD(p,0,-o)+TD(p,n,-n))\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// retain FRAME_I of a process PERIOD_N to prevent strobing\n\n#define FRAME_I  0\n#define PERIOD_N 6.\n// (for optimized shader @60fps,  one frame in six drops output to 10fps)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = mod(float(iFrame-FRAME_I),PERIOD_N)<1. ? TX(fragCoord) : TX1(fragCoord);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}