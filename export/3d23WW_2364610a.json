{"ver":"0.1","info":{"id":"3d23WW","date":"1548964305","viewed":164,"name":"Refraction Practice","username":"oalpha","description":"refraction practice","likes":9,"published":1,"flags":1,"usePreview":0,"tags":["reflection","refraction","fresnel","gem","transmission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ALTITUDE 0.6\n#define RHOMBICTRICONTAHEDRON\n#ifdef RANDOM\n\t#define SHARD_SEED 6\n    #define SHARD_PLANE_NUM 32\n    vec3 SHARD_SHAPE = vec3(.5, .5, 1.2);\n#elif defined TETRAHEDRON\n\t#define SHARD_PLANE_NUM 4\n#elif defined CUBE\n\t#define SHARD_PLANE_NUM 6\n#elif defined OCTAHEDRON\n\t#define SHARD_PLANE_NUM 8\n#elif defined DODECAHEDRON\n\t#define SHARD_PLANE_NUM 12\n#elif defined ICOSCAHEDRON\n\t#define SHARD_PLANE_NUM 20\n#elif defined RHOMBICTRICONTAHEDRON\n\t#define SHARD_PLANE_NUM 30\n#endif\nconst vec3 SHARD_SPECULAR_COLOR = vec3(1., .2, .2);\nconst vec3 SHARD_TRANSMISSIVE_COLOR = vec3(.2, 0., 1.);\nconst float SHARD_OPACITY = .875;\n#define SAMPLES 2\n#define CAMERA_DISTANCE 2.25\n\nstruct RSet2 {\n    mat2 q;\n    vec2 l;\n    vec4 r;\n};\n    RSet2 rset2() {\n        return RSet2(\n            mat2(1.0),\n            vec2(0.0),\n            vec4(0.0)\n        );\n    }\n\nconst vec4 rs1 = vec4(\n    3.3540e-1,   7.2490e-1,   6.9690e-1,   5.2740e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\nconst vec4 rs2 = vec4(\n    2.7730e-2,   5.1710e-1,   3.3970e-1,   1.0300e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\nconst vec4 rs3 = vec4(\n    4.4190e-1,   7.6040e-1,   7.7920e-1,   3.7080e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300);\n\nfloat randSin(float x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\n\n#define RAND randSin\n\nvec3 rvec3(float x, vec4 r1, vec4 r2, vec4 r3) {\n    return vec3(RAND(x, r1), RAND(x, r2), RAND(x, r3));\n}\n\nfloat dot2(vec3 v) {\n    return dot(v, v);\n}\n\nstruct Ray3 {\n    // base\n    vec3 b;\n    // direction\n    vec3 d;\n};\n#define eray3 Ray3(O3,O3)\n#define nray3(b,d) Ray3(b,normalize(d))\n    \nRay3 cameraRay(\n    vec3 camera,\n    vec3 focus,\n    vec3 up,\n    vec2 fov,\n    float screen,\n    vec2 uv\n) {\n    vec3 z = normalize(camera - focus);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    \n    mat3 raycaster = screen * mat3(\n        fov.x,0.,0.,\n        0.,fov.y,0.,\n        0.,0.,1.\n    ) * mat3(x, y, -z);\n    \n    Ray3 ray = nray3(\n        camera,\n        raycaster * vec3(uv, 1.)\n    );\n    \n    return ray;\n}\n\n#define Sphere3 vec4\nfloat SphereHit(Ray3 r, Sphere3 s) {\n    vec3 D = s.xyz - r.b;\n    if(length(D) <= s.w)\n        return 1.;\n    if(dot(r.d, D) < 0.)\n        return 0.;\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float h = D2 / dD * sqrt(1. - dD * dD / D2);\n    return h <= s.w ? 1. : 0.;\n}\n\nmat4 SphereTrace(Ray3 r, Sphere3 s, mat3 o) {\n    vec3 D = s.xyz - r.b;\n    if(length(D) <= s.w || dot(r.d, D) < 0.)\n        return mat4(0.);\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float len = dD - sqrt(dD * dD - D2 + s.w * s.w);\n    vec4 p = vec4(len * r.d + r.b, 1.);\n    vec4 z = vec4(normalize(p.xyz - s.xyz), 0.);\n    vec4 x = vec4(normalize(cross(o[1], z.xyz)), 0.);\n    vec4 y = vec4(normalize(cross(z.xyz, x.xyz)), 0.);\n    return mat4(x, y, z, p);\n}\n\nmat4 SphereInnerTrace(Ray3 r, Sphere3 s, mat3 o) {\n    vec3 D = s.xyz - r.b;\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float len = dD - sqrt(dD * dD - D2 + s.w * s.w);\n    vec4 p = vec4(len * r.d + r.b, 1.);\n    vec4 z = vec4(normalize(s.xyz - p.xyz), 0.);\n    vec4 x = vec4(normalize(cross(o[1], z.xyz)), 0.);\n    vec4 y = vec4(normalize(cross(z.xyz, x.xyz)), 0.);\n    return mat4(x, y, z, p);\n}\n\nfloat ShardHit(Ray3 r, vec4 p[SHARD_PLANE_NUM]) {\n    float x, xset = 0.;\n    float n, nset = 0.;\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 pn = p[i].xyz;\n        if(dot(pn, r.d) < 0.) {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l > x || xset < .5) {\n                x = l;\n                xset = 1.;\n            }\n        }\n        else {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l < n || nset < .5) {\n                n = l;\n                nset = 1.;\n            }\n        }\n    }\n    return x < n ? 1. : 0.;\n}\n\nmat4 ShardTrace(Ray3 r, vec4 p[SHARD_PLANE_NUM], mat3 o) {\n    float d;\n    vec3 n;\n    int s = 0;\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 pn = p[i].xyz;\n        if(dot(pn, r.d) < 0.) {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l > d || s == 0) {\n                d = l;\n                n = pn;\n                s = 1;\n            }\n        }\n    }\n    vec4 t = vec4(d * r.d + r.b, 1.);\n    vec4 z = vec4(n, 0.);\n    vec4 x = vec4(normalize(cross(o[1], z.xyz)), 0.);\n    vec4 y = vec4(normalize(cross(z.xyz, x.xyz)), 0.);\n    return mat4(x, y, z, t);\n}\n\nmat4 ShardInnerTrace(Ray3 r, vec4 p[SHARD_PLANE_NUM], mat3 o) {\n    float d;\n    vec3 n;\n    int s = 0;\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 pn = p[i].xyz;\n        if(dot(pn, r.d) > 0.) {\n            vec3 pc = pn * p[i].w;\n            vec3 D = r.b - pc;\n            float l = -dot(pn, D) / dot(pn, r.d);\n            if(l < d || s == 0) {\n                d = l;\n                n = -pn;\n                s = 1;\n            }\n        }\n    }\n    vec4 t = vec4(d * r.d + r.b, 1.);\n    vec4 z = vec4(n, 0.);\n    vec4 x = vec4(normalize(cross(o[1], z.xyz)), 0.);\n    vec4 y = vec4(normalize(cross(z.xyz, x.xyz)), 0.);\n    return mat4(x, y, z, t);\n}\n\nvoid surface(\n    const in vec3 i,\n    mat4 s,\n    float n1,\n    float n2,\n    out bool tr,\n    out Ray3 r,\n    out float cr,\n    out Ray3 t,\n    out float ct\n) {\n    vec3 p = s[3].xyz;\n    vec3 n = s[2].xyz, nx = s[0].xyz, ny = s[1].xyz;\n    float Rn = dot(i, n);\n    vec3 rn = Rn * n;\n    vec3 rp = i - rn;\n    float Rp = length(rp);\n    \n    r.b = p;\n    r.d = rp - rn;\n    \n    float cosi = -Rn, sini = sqrt(1. - cosi * cosi);\n    float sint = sini * n1 / n2;\n    if(sint > 1.) {\n        tr = true;\n        t.b = p;\n        t.d = vec3(0.);\n        cr = 1.;\n        ct = 0.;\n    }\n    else {\n        tr = false;\n        t.b = p;\n        float cost = sqrt(1. - sint * sint);\n        t.d = sint * rp / Rp - cost * n;\n        float cs = (n1*cosi-n2*cost)/(n1*cosi+n2*cost);\n        float cp = (n1*cost-n2*cosi)/(n1*cost+n2*cosi);\n        cr = .5 * (cs * cs + cp * cp);\n        ct = 1. - cr;\n    }\n}\n\nvec3 plane(vec3 a, vec3 b, vec3 c) {\n    vec3 m = a + b + c;\n    vec3 n = normalize(cross(b - a, c - a));\n    if(dot(m, n) < 0.)\n        n *= -1.;\n    return n;\n}\n\nvoid genPlanes(out vec4 planes[SHARD_PLANE_NUM], float R, vec3 center) {\n    #ifdef RANDOM\n    float seeds[SHARD_PLANE_NUM];\n    for(int i = 0; i < SHARD_PLANE_NUM; i++)\n        seeds[i] = float(i * SHARD_SEED) * 3.14159265358;\n    for(int i = 0; i < SHARD_PLANE_NUM; i++) {\n        vec3 v = normalize(2. * rvec3(seeds[i], rs1, rs2, rs3) - 1.);\n        vec3 p = R * v * SHARD_SHAPE;\n        v = normalize(v * SHARD_SHAPE.yzx * SHARD_SHAPE.zxy);\n        planes[i] = vec4(v, dot(p, v));\n    }\n    #elif defined TETRAHEDRON\n    vec3 i = vec3(1,0,0), j = vec3(0,1,0), k = vec3(0,0,1);\n    vec3 nnn = -i-j-k, nnp = -i-j+k, npn = -i+j-k, npp = -i+j+k;\n    vec3 pnn =  i-j-k, pnp =  i-j+k, ppn =  i+j-k, ppp =  i+j+k;\n    R /= sqrt(3.);\n    planes[0] = vec4(plane(nnp,ppp,pnn), R);\n    planes[1] = vec4(plane(nnp,ppp,npn), R);\n    planes[2] = vec4(plane(pnn,npn,ppp), R);\n    planes[3] = vec4(plane(pnn,npn,nnp), R);\n    #elif defined CUBE\n    //R /= sqrt(3.);\n    planes[0] = vec4( 1.,  0.,  0., R);\n    planes[1] = vec4( 0.,  1.,  0., R);\n    planes[2] = vec4( 0.,  0.,  1., R);\n    planes[3] = vec4(-1.,  0.,  0., R);\n    planes[4] = vec4( 0., -1.,  0., R);\n    planes[5] = vec4( 0.,  0., -1., R);\n    #elif defined OCTAHEDRON\n    vec3 i = vec3(1,0,0), j = vec3(0,1,0), k = vec3(0,0,1);\n    vec3 nnn = -i-j-k, nnp = -i-j+k, npn = -i+j-k, npp = -i+j+k;\n    vec3 pnn =  i-j-k, pnp =  i-j+k, ppn =  i+j-k, ppp =  i+j+k;\n    planes[ 0] = vec4(normalize(nnn), R);\n    planes[ 1] = vec4(normalize(nnp), R);\n    planes[ 2] = vec4(normalize(npn), R);\n    planes[ 3] = vec4(normalize(npp), R);\n    planes[ 4] = vec4(normalize(pnn), R);\n    planes[ 5] = vec4(normalize(pnp), R);\n    planes[ 6] = vec4(normalize(ppn), R);\n    planes[ 7] = vec4(normalize(ppp), R);\n    #elif defined DODECAHEDRON\n    float h = .5 * (sqrt(5.) - 1.);\n    float a = 1. + h, b = 1. - h * h;\n    vec3 i = vec3(1,0,0), j = vec3(0,1,0), k = vec3(0,0,1);\n    vec3 nnn = -i-j-k, nnp = -i-j+k, npn = -i+j-k, npp = -i+j+k;\n    vec3 pnn =  i-j-k, pnp =  i-j+k, ppn =  i+j-k, ppp =  i+j+k;\n    float c = 1.;\n    //R /= sqrt(3.);\n    planes[ 0] = vec4(plane(npp,ppp,c*vec3( 0, a, b)), R);\n    planes[ 1] = vec4(plane(pnp,nnp,c*vec3( 0,-a, b)), R);\n    planes[ 2] = vec4(plane(nnn,pnn,c*vec3( 0,-a,-b)), R);\n    planes[ 3] = vec4(plane(ppn,npn,c*vec3( 0, a,-b)), R);\n    planes[ 4] = vec4(plane(pnp,ppp,c*vec3( b, 0, a)), R);\n    planes[ 5] = vec4(plane(ppn,pnn,c*vec3( b, 0,-a)), R);\n    planes[ 6] = vec4(plane(nnn,npn,c*vec3(-b, 0,-a)), R);\n    planes[ 7] = vec4(plane(npp,nnp,c*vec3(-b, 0, a)), R);\n    planes[ 8] = vec4(plane(ppn,ppp,c*vec3( a, b, 0)), R);\n    planes[ 9] = vec4(plane(npp,npn,c*vec3(-a, b, 0)), R);\n    planes[10] = vec4(plane(nnn,nnp,c*vec3(-a,-b, 0)), R);\n    planes[11] = vec4(plane(pnp,pnn,c*vec3( a,-b, 0)), R);\n\t#elif defined ICOSCAHEDRON\n    float h = .5 * (sqrt(5.) - 1.);\n    float a = 1. + h, b = 1. - h * h;\n    vec3 i = vec3(1,0,0), j = vec3(0,1,0), k = vec3(0,0,1);\n    vec3 nnn = -i-j-k, nnp = -i-j+k, npn = -i+j-k, npp = -i+j+k;\n    vec3 pnn =  i-j-k, pnp =  i-j+k, ppn =  i+j-k, ppp =  i+j+k;\n    planes[ 0] = vec4(normalize(nnn), R);\n    planes[ 1] = vec4(normalize(nnp), R);\n    planes[ 2] = vec4(normalize(npn), R);\n    planes[ 3] = vec4(normalize(npp), R);\n    planes[ 4] = vec4(normalize(pnn), R);\n    planes[ 5] = vec4(normalize(pnp), R);\n    planes[ 6] = vec4(normalize(ppn), R);\n    planes[ 7] = vec4(normalize(ppp), R);\n    planes[ 8] = vec4(normalize(vec3( a, b, 0)), R);\n    planes[ 9] = vec4(normalize(vec3( a,-b, 0)), R);\n    planes[10] = vec4(normalize(vec3(-a, b, 0)), R);\n    planes[11] = vec4(normalize(vec3(-a,-b, 0)), R);\n    planes[12] = vec4(normalize(vec3( 0, a, b)), R);\n    planes[13] = vec4(normalize(vec3( 0, a,-b)), R);\n    planes[14] = vec4(normalize(vec3( 0,-a, b)), R);\n    planes[15] = vec4(normalize(vec3( 0,-a,-b)), R);\n    planes[16] = vec4(normalize(vec3( b, 0, a)), R);\n    planes[17] = vec4(normalize(vec3(-b, 0, a)), R);\n    planes[18] = vec4(normalize(vec3( b, 0,-a)), R);\n    planes[19] = vec4(normalize(vec3(-b, 0,-a)), R);\n    #elif defined RHOMBICTRICONTAHEDRON\n    float h = .5 * (sqrt(5.) - 1.);\n    float a = 1. + h, b = 1. - h * h;\n    vec3 i = vec3(1,0,0), j = vec3(0,1,0), k = vec3(0,0,1);\n    vec3 nnn = -i-j-k, nnp = -i-j+k, npn = -i+j-k, npp = -i+j+k;\n    vec3 pnn =  i-j-k, pnp =  i-j+k, ppn =  i+j-k, ppp =  i+j+k;\n    float c = 1.;\n    //R /= sqrt(3.);\n    planes[ 0] = vec4(normalize(vec3( a, b, 0)+ppp), R);\n    planes[ 1] = vec4(normalize(vec3( a, b, 0)+ppn), R);\n    planes[ 2] = vec4(normalize(vec3( a,-b, 0)+pnp), R);\n    planes[ 3] = vec4(normalize(vec3( a,-b, 0)+pnn), R);\n    planes[ 4] = vec4(normalize(vec3(-a, b, 0)+npp), R);\n    planes[ 5] = vec4(normalize(vec3(-a, b, 0)+npn), R);\n    planes[ 6] = vec4(normalize(vec3(-a,-b, 0)+nnp), R);\n    planes[ 7] = vec4(normalize(vec3(-a,-b, 0)+nnn), R);\n    planes[ 8] = vec4( i, R);\n    planes[ 9] = vec4(-i, R);\n    planes[10] = vec4(normalize(vec3( 0, a, b)+ppp), R);\n    planes[11] = vec4(normalize(vec3( 0, a, b)+npp), R);\n    planes[12] = vec4(normalize(vec3( 0, a,-b)+ppn), R);\n    planes[13] = vec4(normalize(vec3( 0, a,-b)+npn), R);\n    planes[14] = vec4(normalize(vec3( 0,-a, b)+pnp), R);\n    planes[15] = vec4(normalize(vec3( 0,-a, b)+nnp), R);\n    planes[16] = vec4(normalize(vec3( 0,-a,-b)+pnn), R);\n    planes[17] = vec4(normalize(vec3( 0,-a,-b)+nnn), R);\n    planes[18] = vec4( j, R);\n    planes[19] = vec4(-j, R);\n    planes[20] = vec4(normalize(vec3( b, 0, a)+ppp), R);\n    planes[21] = vec4(normalize(vec3( b, 0, a)+pnp), R);\n    planes[22] = vec4(normalize(vec3(-b, 0, a)+npp), R);\n    planes[23] = vec4(normalize(vec3(-b, 0, a)+nnp), R);\n    planes[24] = vec4(normalize(vec3( b, 0,-a)+ppn), R);\n    planes[25] = vec4(normalize(vec3( b, 0,-a)+pnn), R);\n    planes[26] = vec4(normalize(vec3(-b, 0,-a)+npn), R);\n    planes[27] = vec4(normalize(vec3(-b, 0,-a)+nnn), R);\n    planes[28] = vec4( k, R);\n    planes[29] = vec4(-k, R);\n    #endif\n}\n\n#define N1 1.0003\n#define N2 1.3\nvoid ray(vec4 planes[SHARD_PLANE_NUM], Ray3 r, float weight, inout vec4 pixel) {\n    //#define SPHERE_FRONT\n    #ifdef SPHERE_FRONT\n    if(SphereHit(r, vec4(vec3(0.), 1.)) > 0.) {\n        mat4 trace = SphereTrace(r, vec4(vec3(0.), 1.), mat3(1.));\n    #else\n    if(ShardHit(r, planes) > 0.) {\n        mat4 trace = ShardTrace(r, planes, mat3(1.));\n    #endif\n        Ray3 rr, rt;\n        float cr, ct, ca;\n        bool tr;\n        surface(\n            r.d,\n            trace,\n            N1,\n            N2,\n            tr,\n            rr,\n            cr,\n            rt,\n            ct\n        );\n        float l = 0.;\n        ca = ct;\n        vec3 rcol = cr * texture(iChannel0, rr.d.xzy).rgb * SHARD_SPECULAR_COLOR;\n        vec3 tcol;\n        r = rt;\n        vec3 col = rcol;\n        #define BOUNCES 8\n        if(!tr)\n            for(int b = 0; b < BOUNCES && ca > .001; b++) {\n    \t\t\t#ifdef SPHERE_REAR\n                trace = SphereInnerTrace(r, vec4(vec3(0.), 1.), mat3(1.));\n    \t\t\t#else\n                trace = ShardInnerTrace(r, planes, mat3(1.));\n    \t\t\t#endif\n                surface(\n                    r.d,\n                    trace,\n                    N2,\n                    N1,\n                    tr,\n                    rr,\n                    cr,\n                    rt,\n                    ct\n                );\n                l += distance(r.b, rr.b);\n                vec3 c = texture(iChannel0, rt.d.xzy).rgb;\n                /*\nc = mix(\nc,\nSHARD_TRANSMISSIVE_COLOR,\nl * SHARD_OPACITY\n);\n*/\n                vec3 C = c * mix(\n                    vec3(1.),\n                    SHARD_TRANSMISSIVE_COLOR,\n                    SHARD_OPACITY\n                );\n                if(tr) {\n                    if(BOUNCES - b > 1)\n                        tcol = vec3(0.);\n                    else\n                        tcol = ca * C;\n                }\n                else\n                    tcol = ca * ct * C;\n                col += tcol;\n                ca *= cr;\n                r = rr;\n            }\n        pixel += weight * vec4(col, 1.);\n    }\n    else\n        pixel += weight * texture(iChannel0, r.d.xzy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tm = iTime * 0.25;\n    \n    float R = 1.;\n    vec3 center = vec3(0.);\n    \n    vec4 planes[SHARD_PLANE_NUM];\n    genPlanes(planes, R, center);\n    \n    vec3\n        camera = vec3(\n            CAMERA_DISTANCE * vec2(cos(tm), sin(tm)),\n            CAMERA_DISTANCE * ALTITUDE\n            //D * 2. * vec2(cos(tm), sin(tm)),\n            //D * .5\n        ),\n        focus = vec3(0., 0., .25),\n        up = vec3(0., 0., 1.);\n    vec2 fov = vec2(1.);\n    float screen = 1.;\n    \n    const int SAMPLES2 = SAMPLES * SAMPLES;\n    vec4 pixel = vec4(0.);\n    float weight = 1. / float(SAMPLES2);\n    for(int si = 0; si < SAMPLES2; si++) {\n        int sx = si / SAMPLES;\n        int sy = si - sx * SAMPLES;\n        vec2 shift = vec2(ivec2(sx, sy) + 1) / (float(SAMPLES) * 2.);\n        shift /= iResolution.x;\n        Ray3 r = cameraRay(\n            camera,\n            focus,\n            up,\n            fov,\n            screen,\n            ((uv + shift) * 2. - 1.) * vec2(1., iResolution.y / iResolution.x)\n        );\n        ray(planes, r, weight, pixel);\n    }\n\n    // Output to screen\n    fragColor = pixel;\n    //fragColor *= 0.;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float R = 1.;\n    vec3 center = vec3(0.);\n    \n    vec4 planes[SHARD_PLANE_NUM];\n    genPlanes(planes, R, center);\n    Ray3 r = Ray3(\n        fragRayOri,\n        fragRayDir\n    );\n    ray(planes, r, 1., fragColor);\n}","name":"Image","description":"","type":"image"}]}