{"ver":"0.1","info":{"id":"ftdyWH","date":"1659724849","viewed":136,"name":"Mayan Acid Ride","username":"Mojomajor","description":"I don't know what I'm doing except mayan statue faces\n\nuint and << operators are not supported in iPhone. Anybody know a workaround?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","hexagon","rohrschacht"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"ShaderToy Tutorial - Hexagonal Tiling\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/VmrIDyYiJBA\n\n#define MIRROR_X 1\n#define MIRROR_Y 1\n#define ACID_MODE 0 // 0 = TRANCE MODE\n#define EPILEPSY 0\n#define POLAR 0 // less faces :-(\n\nfloat HexDist(vec2 p)\n{\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1, 1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\n\nvec4 HexCoords(vec2 uv)\n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r * .5;\n\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv = dot(a, a) < dot(b, b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5 - HexDist(gv);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n}\nmat2 rotate2d(float _angle)\n{\n    return mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle));\n}\nfloat random(in vec2 _st)\n{\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898 * sin(iTime / 600000.), 78.233))) *\n                 43758.5453123);\n}\nfloat noise(in vec2 _st)\n{\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1. - u.x) +\n           (d - b) * u.x * u.y;\n}\nuint noiseSquirrel3(in int position)\n{\n    uint BIT_NOISE1 = uint(0xB5297A4D);\n    uint BIT_NOISE2 = uint(0x68E31DA4);\n    uint BIT_NOISE3 = uint(0x1B56C4E9);\n\n    uint mangled = uint(position);\n    mangled *= BIT_NOISE1;\n    mangled ^= (mangled >> 8);\n    mangled += BIT_NOISE2;\n    mangled ^= (mangled << 8);\n    mangled *= BIT_NOISE3;\n    mangled ^= (mangled >> 8);\n\n    return mangled;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv*=1.0;\n    \n    vec3 ampl = texture(iChannel0,uv).xyz;\n    vec3 col = vec3(0);\n    uv.x -=iMouse.y/iResolution.y;\n    float acidDrop = 0.;\n    // polar coordinates\n\n#if ACID_MODE\n    acidDrop = 10.*(iMouse.x/iResolution.y);\n#endif\n    uv *= 20.-acidDrop;\n#if MIRROR_X\n    uv.x = abs(uv.x);\n#endif\n#if MIRROR_Y\n    uv.y = abs(uv.y);\n#endif\n\n    // vec4 hc = HexCoords(uv*sin(noise(uv)));\n    float n1 = noise(uv);\n    float n2 = float(noiseSquirrel3(int(iTime * 100.))) / 3.;\n#if POLAR\n    uv = vec2(atan(uv.x,uv.y), length(uv));\n#endif\n    vec4 hc = HexCoords(uv * sin(n1));\n       \n#if EPILEPSY\n    float d = length(vec2(n1*uv.x,n2*uv.y));\n    hc /= .5*d/999999900.;\n#else\n    hc /= .5;\n#endif\nuv *= sin(mix(n1, n2, cos(iTime) * .5 + n1));\n    float c = smoothstep(.01, .5, hc.y * cos(hc.z * hc.w + iTime) * .5 + .20);\n#if ACID_MODE\n    hc.zw = hc.xy*rotate2d(22.4);\n    hc.xy = hc.zw*rotate2d(32.2),\n    col = hc.xyz;\n#endif\n    col += c;\n    col *= vec3(abs(sin(uv.x + iTime)), cos(hc.w * iTime / 200.), tan(hc.z * iTime / 300.));\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}