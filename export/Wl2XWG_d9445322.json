{"ver":"0.1","info":{"id":"Wl2XWG","date":"1566949752","viewed":69,"name":"Colors from Grid","username":"gressettd","description":"Playing with the idea of pattern functions providing \"color control\", eg different perspectives on the same pattern, to drive color mapping. In this case, the simplest pattern of all, the grid.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gridSize = 3.0;\nconst float penSize = 15.0;\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\nvec4 ComputeGridPattern(\n\tvec2 p,\n\tfloat pen, \n\tfloat scale,\n\tfloat maxRes\n\t)\n{\n\tp *= scale;\n\tpen *= scale / maxRes;\n\tvec2 cell = floor(p);\n\tvec2 cellCoords = p - cell;\n\n\tvec2 d = abs(cellCoords) - vec2(1, 1);\n\tfloat edgeDistance = length(max(d, vec2(0, 0))) + min(max(d.x, d.y), 0.0);\n\tfloat annularDistance = abs(edgeDistance) - pen / 2.0;\n\t\n\tfloat intensity = 1.0 - step(0.0, annularDistance);\n\treturn vec4(intensity, annularDistance, cellCoords.x, cellCoords.y);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= float(iResolution.x) / float(iResolution.y);\n\n    float maxRes = max(float(iResolution.x), float(iResolution.y));\n    \n    float tm = iTime * 0.5;\n    \n    \n    vec4 pattern = ComputeGridPattern(uv + (iTime * 0.01), penSize, gridSize + (4.0 * (sin(iTime * .30)+1.0)), maxRes);\n        \n    vec4 bias = vec4(0.350,0.906,0.689,1.0);\n    vec4 scale = vec4(0.772,0.114,0.263,1.0);\n    vec4 freq = vec4(0.077,0.368,1.016,1.0);\n    vec4 phase = vec4(3.859,3.252,5.857,1.0);\n    \n    \n    vec4 baseColor = ComputeWaveGradientRGB(sin(pattern.x + tm),bias,scale, freq, phase);\n\tvec4 accent0 = ComputeWaveGradientRGB(cos(pattern.y + tm),bias,scale, freq, phase);\n    vec4 accent1 = ComputeWaveGradientRGB(fract(pattern.z*tm * tan(tm)),bias,scale, freq, phase);\n    vec4 accent2 = ComputeWaveGradientRGB(fract(pattern.w*tm* sin(tm)),bias,scale, freq, phase);\n    \n    \n    vec4 finalColor = (baseColor * accent0 * accent1 * accent2);\n    fragColor = finalColor;\n}","name":"Image","description":"","type":"image"}]}