{"ver":"0.1","info":{"id":"sdXBzn","date":"1644598541","viewed":149,"name":"Fake pit (parallax mapping)","username":"stegu","description":"A fake, parallax mapped round pit. A strict one-shot surface shader on a plane, no ray tracing.\nStudy for the pupil in the iris for an eyeball shader.\n(Next step: add a fake rounded edge for the rim. A pupil can't have a crisp edge like this.)\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fake","parallax","hole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fit unit circle in viewport\n    vec3 uvw = vec3((2.0*fragCoord-iResolution.xy)/min(iResolution.x, iResolution.y), 0.0);\n\n    float tilt = 0.7 - 0.7*cos(iTime);\n    float Ct = cos(tilt);\n    float St = sin(tilt);\n    // Note to self: GLSL matrix constructors enumerate elements column by column!\n    mat2 Rt = mat2(Ct, St, -St, Ct); // Transforms from object space to view space\n    mat2 invRt = mat2(Ct, -St, St, Ct); // Transforms from view space to object space\n\n    // This is not \"proper\" ray tracing, just a straight projection to object coords\n    vec3 N = vec3(0.0, 0.0, 1.0); // Object space\n    vec3 q = uvw;\n    vec3 qv = q; // Save \"ray origin\" in view space\n    q.z = q.y * St/Ct; // Hit point for current fragment in view space, with z \"traced\"\n    q.yz = invRt*q.yz; // Hit point is now in object space\n    // vec3 V = vec3(0.0, 0.0, 1.0); // This simple demo doesn't use V for anything\n    // V.yz = invRt*V.yz; // View direction is now in object space\n\n    // (\"Hit point\" y in object space is now (view y) * (Ct + St*St/Ct)\n\n    float rpit = 0.9;  // Radius of pit\n    float dpit = 0.25; // Depth of pit (relative to radius)\n    float robj = length(q.xy) - rpit; // Distance to rim in object space\n    float pitmask = aastep(0.0, robj); // Binary mask for fragments \"in the pit\"\n    vec3 dp = -dpit*St*N; // Object space offset for displaced fake lower rim\n    dp.yz = Rt*dp.yz; // dp is now in view space\n    // Displace the hit point in view xy, discard and \"retrace\" z to the tilted plane\n    vec3 q_ = qv + dp;\n    q_.z = q_.y * St/Ct; // Retrace (reproject) to the tilted object plane in view space\n    q_.yz = invRt*q_.yz; // q_ is now in object space on the object plane\n    float pitmaskd = aastep(0.0, length(q_.xy) - rpit); // Mask for \"bottom of the pit\"\n    // Recompute the texture coordinates on the fake pit wall: \"move up to the rim\"\n    vec2 s; // This is our possibly adjusted 2-D texcoord in the object plane\n    if((1.0-pitmask)*pitmaskd == 0.0) { // In the pit, but not at bottom: on the \"wall\"\n        // We're either outside the pit (texcoords are fine, don't touch them)\n        // or on the bottom (texcoords are not needed, because it's a hole)\n        s = q.xy;\n    }\n    else { // We're inside the pit *and* on the fake wall: stretch the texcoords\n        // (Retrace translation with dp in view space to z=0 in obj space. A bit tricky.)\n        // We need to solve a 2nd order equation to find where q_ crossed the upper rim.\n        vec2 a = q.xy;\n        vec2 b = dp.xy;\n        float bb = dot(b,b);\n        float c = dot(a,b)/bb;\n        float d = c*c - (dot(a,a) - rpit*rpit)/bb;\n        if(d < 0.0) { // Shouldn't happen given the circumstances, but play it safe\n            vec2 s = q.xy;\n        } else {\n            float t = - c + sqrt(d);\n            s = a + t*b;\n            // TODO: find a way to \"smooth-bevel the texcoords\"\n            // We need to interpolate with q from *outside* the rim, somehow\n            // s = mix(q.xy, s, smoothstep(0.0,1.0,t)); // Meh, fail\n        }\n    }\n    float spokes = aastep(0.0, sin(atan(s.y, s.x)*50.0));  // Looks a bit weird\n    float grid = aastep(0.0, sin(s.y*10.0)+sin(s.x*10.0)); // in this ortho proj,\n    vec3 pattern = vec3(1.0-spokes, 1.0-grid, 0.5*spokes+0.5*grid); // but okay\n    float planeshade = 1.0 - 0.3*(1.0-pitmask)*pitmaskd;\n    vec3 planecolor = vec3((pitmask+(1.0-pitmask)*pitmaskd)*planeshade*pattern);\n    \n    fragColor = vec4(planecolor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}