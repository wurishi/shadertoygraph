{"ver":"0.1","info":{"id":"Ws2fDy","date":"1590747126","viewed":181,"name":"Rasterizing a Blob to a grid","username":"Schrompf","description":"Analytically (*) calculates the common area between a rectangle and the blob. The result is a perfectly anti-aliased rasterization of said blob.\n(*) First tried circloid functions (like y = (1 - x^a) ^ (1/a)) which are nearly impossible to integrate","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GridSize = 32.0f;\nconst float Exp = 4.0f;\nconst float InvExp = 1.0f / Exp;\n\n\n// Hull curve is \"y = 1 - x^5\"\n// Inverse is \"x = (1 - y) ^ (1/5)\"\n// Integral is \"y = x - 1/6 x^6\"\nfloat hullIntegral(float x) \n{\n    return x - (1.0f / (Exp + 1.0f)) * pow( x, (Exp + 1.0f));\n}\n\n// Area integral of Blob shape (0, 0) to (x, y). Sign is Positive (TopRight/BottomLeft) or Negative (other)\nfloat areaIntegral(vec2 pos) \n{\n    vec2 p = abs( pos);\n    float plus = sign( pos.x) * sign( pos.y);\n    \n    // only top-right quadrant: calculate xpos of intersection between hull and upper area border\n    float intersectPos = pow( clamp( 1.0f - p.y, 0.0f, 1.0f), InvExp);\n    // area of the part completely inside the hull, 0 .. intersectPos\n    float insideArea = min( p.x, intersectPos) * min( p.y, 1.0f);\n    // area under hull function beyond intersect position, intersectPos .. right border\n    float remainPos = clamp( p.x, intersectPos, 1.0f);\n    float remainArea = hullIntegral( remainPos) - hullIntegral( intersectPos);\n    \n    return plus * (insideArea + remainArea);\n}\n\nfloat integral( vec2 blobCenter, float blobRadius, vec2 rectMin, vec2 rectMax)\n{\n    float invBlobRadius = 1.0f / blobRadius;\n    vec2 minpos = invBlobRadius * (rectMin - blobCenter);\n    vec2 maxpos = invBlobRadius * (rectMax - blobCenter);\n    \n    float totalArea = (maxpos.x - minpos.x) * (maxpos.y - minpos.y);\n    float area\n        = areaIntegral( maxpos)\n        - areaIntegral( vec2( minpos.x, maxpos.y))\n        - areaIntegral( vec2( maxpos.x, minpos.y))\n        + areaIntegral( minpos);\n    return area / totalArea;\n}\n\nfloat doBlob( vec2 center, float radius, vec2 pos)\n{\n    vec2 off = abs( pos - center) / radius;\n    float y = 1.0f - pow( off.x, Exp);\n    float i = off.y < y ? 1.0f : 0.0f;\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Blob controllable by mouse\n    vec2 blobPos = iMouse.xy;\n    float blobRadius = 150.0f + 50.0f * sin(0.5f * iTime);\n\tfloat blobPresence = doBlob( blobPos, blobRadius, fragCoord.xy);\n        \n    // a grid of rectangles\n    ivec2 gridpos = ivec2(fragCoord.xy / GridSize);\n    vec2 rectMin = vec2( gridpos) * GridSize;\n    vec2 rectMax = rectMin + vec2( GridSize, GridSize);   \n    \n    // calculate the percentage of the area the blob occupies \n    float factor = integral( blobPos, blobRadius, rectMin, rectMax);\n    // quick gamma correction\n    factor *= factor;\n    \n    // base colour is rasterized blob\n    vec3 res = vec3( factor, factor, factor);\n    // paint real blob shape on top\n    res = mix( res, vec3( 1, 0, 0), 0.3f * blobPresence);\n    \n    fragColor = vec4( res, 1.0);\n}","name":"Image","description":"","type":"image"}]}