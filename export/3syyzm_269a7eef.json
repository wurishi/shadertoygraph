{"ver":"0.1","info":{"id":"3syyzm","date":"1602430426","viewed":435,"name":"inercia Shader Royale 2020 NuSan","username":"NuSan","description":"Shader coded live during Inercia Shader Royale 2020 Competion: 1st place\nShader was made in about 50m, with 7 other coders competing at the same time","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","livecoding","inercia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Shader coded live during Inercia Shader Royale 2020 Competion: 1st place\n// Shader was made in about 50m, with 7 other coders competing at the same time\n//\n// Shader evolved a lot during the show\n// You can activate various parts here:\n\nfloat globalSpeed = 0.5; // was at 1 with lug00ber set!\n#define USE_RAINBOW 1\n#define USE_SYMMETRY 1\n#define USE_POSTFX 1\n#define USE_LINES 0\n\n\nfloat time;\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s+.5)-.5)*s;  \n}\nvec3 repid(vec3 p, vec3 s) {\n  return floor(p/s+.5); \n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nvec3 rnd(vec3 p) {\n  \n  return fract(sin(p*452.512+p.yzx*847.512+p.zxy*245.577)*512.844);\n}\n\nfloat tick(float t, float d) {\n  t/=d;\n  return (floor(t) + pow(smoothstep(0.,1.,fract(t)), 10.))*d;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*457.588)*942.512);\n}\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(rnd(floor(t)), rnd(floor(t)+1.), pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\nvec3 aco=vec3(0);\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  float t3 = time*0.4;\n  p.xz *= rot(t3 + sin(p.y*0.3+t3*.7)*.5);\n  p.xy *= rot(t3 + sin(p.z*.4+t3*.6)*.5);\n  p.yz *= rot(t3 + sin(p.x*.2+t3*.8)*.5);\n  \n  float d=length(p)-3.;\n  \n  float sd=3./length(p);\n  d = min(d, length(p.xz)-sd);\n  d = min(d, length(p.xy)-sd);\n  d = min(d, length(p.yz)-sd);\n  \n  \n  float an = pow(fract(time*0.5),2.);\n  float ep = 0.2;\n  ep -= an*0.1 + d*0.05;\n  float d3 = abs(length(p)-an*20.-3.)-ep;\n  d3=max(d3, 0.1);\n  aco += vec3(0.8,0.5,1) * 0.004 / (0.05 + abs(d3));\n  \n  d = min(d, d3);\n  \n  vec3 p6 = bp;\n  p6.xz=abs(p6.xz);\n  if(p6.z>p6.x) p6.xz = p6.zx;\n  p6.x -= 22.;\n  p6.z = abs(p6.z)-6.-sin(bp.y*.03 + time)*5.-sin(bp.y*.1 + time)*10.;\n  p6.z = abs(p6.z)-3.-sin(bp.y*.07 + time)*5.-sin(bp.y*.2 + time*1.3)*4.;\n  \n  float d7 = length(p6.xz) - 1.;\n  d7=max(d7,0.2);\n  d = min(d, d7);\n  aco += vec3(0.8,0.5,1) * 0.008*exp(fract(-time*2.)) / (0.05 + abs(d7));\n  \n  d *= 0.7;\n  \n  p.x += tick(time, 1.)*4.;\n  \n  if(d<0.1) {\n  for(float i=1.; i<11.; ++i) {\n    \n    p-= 0.8;\n    float ss = 9./i;\n    vec3 id = repid(p, vec3(ss));\n    vec3 p2 = repeat(p, vec3(ss));\n    p2 += rnd(id)*0.2;\n    \n    float d2 = length(p2)-ss*0.3;\n    \n    \n    \n    d=max(d, -d2);\n    \n    p.xz *= rot(0.7);\n    p.yz *= rot(0.6);\n  }\n  \n  vec3 p4 = repeat(p + time*4., vec3(8));\n  float d4 = max(abs(p4.x)-0.1, d);\n  aco += vec3(0.4,0.5,1.9) * 0.026 / (0.15 + abs(d4));\n  float d5 = max(abs(p4.y)-0.1, d);\n  aco += vec3(0.8,0.5,0.4) * 0.016 / (0.15 + abs(d5));\n  d = min(d, d4);\n  d = min(d, d5);\n}\n  \n  return d;\n}\n\nfloat gao(vec3 p, vec3 n, float s) {\n  \n  return clamp(map(p+n*s)/s, 0.,1.);\n}\n\nfloat pulse;\n\nvoid cam(inout vec3 p) {\n  \n  float t=time * 0.3 + curve(pulse, 0.6)*27.3;\n  p.yz *= rot(t*0.7);\n  p.xz *= rot(t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = mod(iTime*globalSpeed, 300.);\n  pulse = floor(time*0.5);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float alpha = 1.0;\n  \n  #if USE_POSTFX\n      float gd = 10.+curve(time, 0.1)*50.;\n      float se = curve(time - length(uv)*0.5, 0.15);\n      if(se>0.6) {\n        //uv.x += floor(uv.y*gd)*time*0.1;\n        vec2 tmp = smoothstep(0.8,0.9,fract(uv*gd));\n        uv=floor(uv*gd)/gd;\n\n        alpha = mix(1.,max(tmp.x,tmp.y)*.5+.5,se);\n      }\n  #endif\n\n  #if USE_SYMMETRY\n      uv.y += pow(curve(time, 0.3),2.0)*0.2;\n\n      uv *= 1.0+curve(time - length(uv), 0.3)*.3;\n\n      if(curve(time, 2.0)>0.6) uv=abs(uv);\n  #endif\n\n\n  vec3 s=vec3(0,0,-6. - curve(pulse, 0.5)*10.);\n  s.x += (curve(pulse, 0.4)-.5)*8.;\n  s.y += (curve(pulse, 0.7)-.5)*8.;\n  vec3 r=normalize(vec3(-uv, 1. + sin(time*curve(pulse, 0.3)*2.0)*.5));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) break;\n    if(d>100.0) break;\n    p+=r*d;    \n  }\n  \n  float fog=1.-clamp(length(p-s)/100., 0.,1.);\n  \n  vec3 col=vec3(0);\n  \n  col += aco*.9;\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  float ao = gao(p,n,0.3);\n  ao *= gao(p,n,0.6)*.5+.5;\n  ao *= gao(p,n,1.2)*.5+.5;\n  \n  for(float i=1.; i<30.; ++i) {\n    float dd=0.1*i;\n    col += map(p+r*dd) * fog * 0.06 * vec3(dd+0.3,0.6,0.9+dd*.3) * ao;\n  }\n  \n  float fre=pow(1.-abs(dot(n,r)), 3.);\n  col += fre * vec3(1,.5,.7) * 1.4 * (0.5-0.5*n.y) * ao * fog;\n  \n  col += (1.-fog) * mix(vec3(0), vec3(0.5,0.6,0.7), pow(abs(r.x), 4.)) * 2.;\n  col += (1.-fog) * mix(vec3(0), vec3(0.7,0.6,0.3), pow(abs(r.z), 4.)) * 2.;\n  \n  #if USE_RAINBOW\n    float t5 = time*.3;\n    col.xz *= rot(t5);\n    col.xy *= rot(t5*.7);\n    col=abs(col);\n  #endif\n  \n  col *= alpha;\n  \n  vec3 bcol = col;\n  \n  #if USE_LINES\n      if(abs(length(uv)-0.3-curve(floor(time*5.)*.4, 0.4))<0.05) col = 1.-col;\n      if(abs(length(uv)-0.4-curve(floor(time*5.)*.4, 0.5))<0.05) col = 1.-col;\n\n      uv *= 0.4;\n      for(int i=0; i<3; ++i) {\n\n        uv *= rot(0.7+time*0.2);\n        uv = abs(uv)-curve(time, 0.3)*0.3;\n        uv *= 1.2;\n\n        if(abs(uv.y)<0.003) col = 1.-col;\n      }\n  #endif\n  \n  //col = mix(col, bcol, clamp(curve(time, 0.3)*2,0,1));\n  \n  col *= 1.2-length(uv);\n  \n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}