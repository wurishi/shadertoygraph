{"ver":"0.1","info":{"id":"msdcRB","date":"1695215872","viewed":12,"name":"Moment-Based OIT","username":"haddington","description":"Simplified implementation of Moment-Based Order-Independent Transparency\n\nCedrick Münstermann, Stefan Krumpen, Reinhard Klein, and Christoph Peters. 2018.\n   Moment-Based Order-Independent Transparency. \n   Proc. ACM Comput. Graph. Interact. Tech. 1, 1, A","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["transparency","rasterization","momentbased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Based on:\n   \n   Cedrick Münstermann, Stefan Krumpen, Reinhard Klein, and Christoph Peters. 2018.\n   Moment-Based Order-Independent Transparency. \n   Proc. ACM Comput. Graph. Interact. Tech. 1, 1, Article 7 (July 2018), 20 pages. https://doi.org/10.1145/3203206\n*/\n\n// Resolve moments and composite. This is the second stage and final stage together, as there are no opaque elements\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = vec4(0);\n    float total = 0.0;\n    \n    for(int i = 0; i < MaxPlanes; ++i) {\n        Plane plane = getPlane(i, wrapTime(iTime), iMouse.xy/iResolution.xy);\n        if (isOnPlane(uv, plane)) {\n            float td;\n            float tt;\n            resolveMoments(iChannel1, iChannel0, td, tt, 0.1, uv);\n            color += vec4(plane.color, 1.0) * td;\n            total += tt;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(compositeOIT(vec3(0.0)/*Opaque*/, color, total), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Based on:\n   \n   Cedrick Münstermann, Stefan Krumpen, Reinhard Klein, and Christoph Peters. 2018.\n   Moment-Based Order-Independent Transparency. \n   Proc. ACM Comput. Graph. Interact. Tech. 1, 1, Article 7 (July 2018), 20 pages. https://doi.org/10.1145/3203206\n*/\n\n// Number of Moments = 4, Single precision, no ROV\n\n// Basic fused multiplication and addition. No precision benefit here, only to keep closer to the original implementation\nfloat fma(float a, float b, float c) {\n    return a*b+c;\n}\n\n// Heart of the method. Used in the second stage\nfloat computeTransmittanceAtDepthFrom4PowerMoments(float b_0, vec2 b_even, vec2 b_odd, float depth, float bias, float overestimation, vec4 bias_vector) {\n\tvec4 b = vec4(b_odd.x, b_even.x, b_odd.y, b_even.y);\n\t\n    // Bias input data to avoid artifacts\n\tb = mix(b, bias_vector, bias);\n\tvec3 z;\n\tz[0] = depth;\n\n\t// Compute a Cholesky factorization of the Hankel matrix B storing only non-\n\t// trivial entries or related products\n\tfloat L21D11               = fma(-b[0],b[1],b[2]);\n\tfloat D11                  = fma(-b[0],b[0], b[1]);\n\tfloat InvD11               = 1.0f/D11;\n\tfloat L21                  = L21D11*InvD11;\n\tfloat SquaredDepthVariance = fma(-b[1],b[1], b[3]);\n\tfloat D22                  = fma(-L21D11,L21,SquaredDepthVariance);\n\n\t// Obtain a scaled inverse image of bz=(1,z[0],z[0]*z[0])^T\n\tvec3 c = vec3(1.0f,z[0],z[0]*z[0]);\n\t\n    // Forward substitution to solve L*c1=bz\n\tc[1] -= b.x;\n\tc[2] -= b.y+L21*c[1];\n\t\n    // Scaling to solve D*c2=c1\n\tc[1] *= InvD11;\n\tc[2] /= D22;\n\t\n    // Backward substitution to solve L^T*c3=c2\n\tc[1] -= L21*c[2];\n\tc[0] -= dot(c.yz,b.xy);\n\t\n    // Solve the quadratic equation c[0]+c[1]*z+c[2]*z^2 to obtain solutions \n\t// z[1] and z[2]\n\tfloat InvC2= 1.0f/c[2];\n\tfloat p    = c[1]*InvC2;\n\tfloat q    = c[0]*InvC2;\n\tfloat D    = (p*p*0.25f)-q;\n\tfloat r    = sqrt(D);\n\tz[1] = -p*0.5f-r;\n\tz[2] = -p*0.5f+r;\n\n\t// Compute the absorbance by summing the appropriate weights\n\tvec3 polynomial;\n\tvec3 weight_factor = vec3(overestimation, (z[1] < z[0])?1.0f:0.0f, (z[2] < z[0])?1.0f:0.0f);\n\n\tfloat f0   = weight_factor[0];\n\tfloat f1   = weight_factor[1];\n\tfloat f2   = weight_factor[2];\n\tfloat f01  = (f1-f0)/(z[1]-z[0]);\n\tfloat f12  = (f2-f1)/(z[2]-z[1]);\n\tfloat f012 = (f12-f01)/(z[2]-z[0]);\n\n\tpolynomial[0] = f012;\n\tpolynomial[1] = polynomial[0];\n\tpolynomial[0] = f01-polynomial[0]*z[1];\n\tpolynomial[2] = polynomial[1];\n\tpolynomial[1] = polynomial[0]-polynomial[1]*z[0];\n\tpolynomial[0] = f0-polynomial[0]*z[0];\n\n\tfloat absorbance = polynomial[0] + dot(b.xy, polynomial.yz);\n\n\t// Turn the normalized absorbance into transmittance\n\treturn clamp(exp(-b_0 * absorbance), 0.0, 1.0);\n}\n\n// First stage\nvoid generateMoments(float depth, float transmittance, out float b_0, out vec4 b) {\n    float absorbance = -log(transmittance);\n\n\tb_0 = absorbance;\n\tfloat depth_pow2 = depth * depth;\n\tfloat depth_pow4 = depth_pow2 * depth_pow2;\n\tb = vec4(depth, depth_pow2, depth_pow2 * depth, depth_pow4) * absorbance;\n}\n\n// Second stage\nvoid resolveMoments(sampler2D zeroth_moment, sampler2D moments, out float transmittance_at_depth, out float total_transmittance, float depth, vec2 sv_pos) {\n    total_transmittance = 1.0;\n    transmittance_at_depth = 1.0;\n\n\tfloat b_0 = texture(zeroth_moment, sv_pos).x;\n\tif(b_0 - 0.00100050033f < 0.0) return;// discard; // In the original code you would discard here\n\n\ttotal_transmittance = exp(-b_0);\n\n\tvec4 b_1234 = texture(moments, sv_pos).xyzw;\n\tvec2 b_even = b_1234.yw;\n\tvec2 b_odd = b_1234.xz;\n\n\tb_even /= b_0;\n\tb_odd /= b_0;\n\n\tconst vec4 bias_vector = vec4(0.0, 0.375, 0.0, 0.375);\n    \n    float moment_bias = 1e-4;\n    float overestimation = 0.25;\n\n\ttransmittance_at_depth = computeTransmittanceAtDepthFrom4PowerMoments(b_0, b_even, b_odd, depth, moment_bias, overestimation, bias_vector);\n}\n\n// Final stage of OIT\nvec3 compositeOIT(vec3 opaque_color, vec4 transparent_color, float total_transmittance) {\n    return opaque_color * total_transmittance + transparent_color.rgb * (1.0 - total_transmittance) / transparent_color.a;\n}\n\n// Basic scene with multiple planes in different depths and with different transmittance. Also animated (maybe a bit too much)\nstruct Plane {\n    vec2 offset;\n    vec2 size;\n    float depth;\n    vec3 color;\n    float transmittance;\n};\n\n/*const int MaxPlanes = 7;\n\nPlane getPlane(int i, float time, vec2 mousePos) {\n    if (i==0) {\n        return Plane (vec2(0.24, 0.33) + vec2( 0.10,  0.00) * time, vec2(0.21, 0.43) + vec2( 0.01,  0.01) * time,  0.2 + 0.2 * time, vec3(0.1,0.4,0.5), 0.1);\n    } else if (i==1) {\n        return Plane (vec2(0.42, 0.63) + vec2(-0.02,  0.01) * time, vec2(0.43, 0.25) + vec2( 0.02,  0.05) * time, -0.2 + 0.1 * time, vec3(0.5,0.1,0.3), 0.4);\n    } else if (i==2) {\n        return Plane (vec2(0.11, 0.12) + vec2( 0.00,  0.10) * time, vec2(0.15, 0.32) + vec2(-0.11,  0.02) * time,  0.4 - 0.6 * time, vec3(0.2,0.6,0.1), 0.2);\n    } else if (i==3) {\n        return Plane (vec2(0.54, 0.24) + vec2( 0.01, -0.02) * time, vec2(0.27, 0.53) + vec2(-0.02, -0.05) * time, -0.5 + 0.2 * time, vec3(0.7,0.5,0.2), 0.3);\n    } else if (i==4) {\n        return Plane (vec2(0.12, 0.11) + vec2( 0.03,  0.04) * time, vec2(0.45, 0.17) + vec2( 0.05,  0.03) * time, -0.1 + 0.4 * time, vec3(0.1,0.3,0.8), 0.5);\n    } else if (i==5) {\n        return Plane (vec2(0.34, 0.72) + vec2(-0.01,  0.04) * time, vec2(0.41, 0.67) + vec2( 0.01, -0.03) * time,  0.9 - 0.8 * time, vec3(0.4,0.4,0.6), 0.2);\n    } else {\n        return Plane (vec2(-0.05, -0.05) + mousePos, vec2(0.1, 0.1),  0.2, vec3(0.7,0.7,0.6), 0.4);\n    }\n}*/\n\n// Basic scene with three planes overlapping each other. The depth of each plane is animated.\n// No visual difference should be observed, as the order is independent.\nconst int MaxPlanes = 4;\n\nPlane getPlane(int i, float time, vec2 mousePos) {\n    if (i==0) {\n        return Plane (vec2(0.24, 0.33), vec2(0.22, 0.43),  0.2 - 0.4 * time, vec3(1,0,0), 0.3);\n    } else if (i==1) {\n        return Plane (vec2(0.26, 0.35), vec2(0.22, 0.43), -0.2 + 0.5 * time, vec3(0,1,0), 0.3);\n    } else if (i==2) {\n        return Plane (vec2(0.28, 0.37), vec2(0.22, 0.43),  0.4 - 0.6 * time, vec3(0,0,1), 0.3);\n    } else {\n        return Plane (vec2(-0.05, -0.05) + mousePos, vec2(0.1, 0.1), 0.2, vec3(0.7,0.7,0.6), 0.4);\n    }\n}\n\nbool isOnPlane(vec2 coord, Plane plane) {\n    vec2 o = coord - plane.offset;\n    return o.x > 0.0 && o.x < plane.size.x && o.y > 0.0 && o.y < plane.size.y;  \n}\n\n// Ping pong value [0, 1] in 5 seconds\nfloat wrapTime(float time) {\n    return (cos(2.0*fract(time / 5.0)*3.1415+3.1415) + 1.0) / 2.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Based on:\n   \n   Cedrick Münstermann, Stefan Krumpen, Reinhard Klein, and Christoph Peters. 2018.\n   Moment-Based Order-Independent Transparency. \n   Proc. ACM Comput. Graph. Interact. Tech. 1, 1, Article 7 (July 2018), 20 pages. https://doi.org/10.1145/3203206\n*/\n\n// First stage extract moments\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 moments = vec4(0.0);\n    \n    for(int i = 0; i < MaxPlanes; ++i) {\n        Plane plane = getPlane(i, wrapTime(iTime), iMouse.xy/iResolution.xy);\n        if (isOnPlane(uv, plane)) {\n            vec4 b;\n            float b0;\n            generateMoments(plane.depth, plane.transmittance, b0, b);\n\n            moments += b;\n        }\n    }\n\n    // Output to buffer\n    fragColor = moments;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Based on:\n   \n   Cedrick Münstermann, Stefan Krumpen, Reinhard Klein, and Christoph Peters. 2018.\n   Moment-Based Order-Independent Transparency. \n   Proc. ACM Comput. Graph. Interact. Tech. 1, 1, Article 7 (July 2018), 20 pages. https://doi.org/10.1145/3203206\n*/\n\n// First stage extract zero moment. Usually fused with the moments within the same pass, but due to Shadertoy limitations split here\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float zero_moments = 0.0;\n    \n    for(int i = 0; i < MaxPlanes; ++i) {\n        Plane plane = getPlane(i, wrapTime(iTime), iMouse.xy/iResolution.xy);\n        if (isOnPlane(uv, plane)) {\n            vec4 b;\n            float b0;\n            generateMoments(plane.depth, plane.transmittance, b0, b);\n\n            zero_moments += b0;\n        }\n    }\n\n    // Output to buffer\n    fragColor = vec4(zero_moments);\n}","name":"Buffer B","description":"","type":"buffer"}]}