{"ver":"0.1","info":{"id":"XlVcD3","date":"1537977713","viewed":218,"name":"Periodic2D SimplexCellular Noise","username":"Markyparky56","description":"Adapted from Brian Sharpe's Simplex Cellular Noise (see code)\nIt wraps the position coordinate by a given period in the hash function to cause the hash to repeat. Seems to be slightly stretched in the x-axis.\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley","simplex","cellular","periodic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from Brian Sharpe's Simplex Cellular Noise from https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvoid FAST32_hash_2D( vec2 gridcell, float period, out vec4 hash_0, out vec4 hash_1 )\t//\tgenerates 2 random numbers for each of the 4 cell corners\n{    \n    //gridcell = mod(gridcell, period);\n    const vec2 OFFSET = vec2( 26.0, 161.0 );\n    const float DOMAIN = 71.0;\n    const vec2 SOMELARGEFLOATS = vec2( 951.135664, 642.949883 );\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n        \n    // Wrap by period\n    P = mod(P, period);\n    \n    P = P - floor(P * ( 1.0 / DOMAIN )) * DOMAIN;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 / SOMELARGEFLOATS.y ) );\n}\n\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\nvec2 rotUV(in vec2 uv, in mat2 rotMatrix)\n{\n    return uv = vec2((uv.x - 0.5), uv.y - 0.5) * rotMatrix;\n}\n\nfloat SimplexCellular2D( vec2 P, float period )\n{\n    //\tsimplex math based off Stefan Gustavson's and Ian McEwan's work at...\n    //\thttp://github.com/ashima/webgl-noise\n\n    //\tsimplex math constants\n    const float SKEWFACTOR = 0.36602540378443864676372317075294;\t\t\t// 0.5*(sqrt(3.0)-1.0)\n    const float UNSKEWFACTOR = 0.21132486540518711774542560974902;\t\t\t// (3.0-sqrt(3.0))/6.0\n    const float SIMPLEX_TRI_HEIGHT = 0.70710678118654752440084436210485;\t// sqrt( 0.5 )\theight of simplex triangle.\n    const float INV_SIMPLEX_TRI_HEIGHT = 1.4142135623730950488016887242097;\t//\t1.0 / sqrt( 0.5 )\n    const vec3 SIMPLEX_POINTS = vec3( 1.0-UNSKEWFACTOR, -UNSKEWFACTOR, 1.0-2.0*UNSKEWFACTOR ) * INV_SIMPLEX_TRI_HEIGHT;\t\t//\tvertex info for simplex triangle\n\n    //\testablish our grid cell.\n    P *= SIMPLEX_TRI_HEIGHT;\t\t// scale space so we can have an approx feature size of 1.0  ( optional )\n    vec2 Pi = floor( P + dot( P, vec2( SKEWFACTOR ) ) );\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_x, hash_y;\n    FAST32_hash_2D( Pi, period, hash_x, hash_y );\n    //SGPP_hash_2D( Pi, hash_x, hash_y ); \n\n    //\tpush hash values to extremes of jitter window\n    const float JITTER_WINDOW = ( 0.10566243270259355887271280487451 * INV_SIMPLEX_TRI_HEIGHT );\t\t// this will guarentee no artifacts.\n    hash_x = Cellular_weight_samples( hash_x ) * JITTER_WINDOW;\n    hash_y = Cellular_weight_samples( hash_y ) * JITTER_WINDOW;\n    \n    //\tcalculate sq distance to closest point    \n    vec2 p0 = ( ( Pi - dot( Pi, vec2( UNSKEWFACTOR ) ) ) - P ) * INV_SIMPLEX_TRI_HEIGHT;\n    hash_x += p0.xxxx;\n    hash_y += p0.yyyy;\n    hash_x.yzw += SIMPLEX_POINTS.xyz;\n    hash_y.yzw += SIMPLEX_POINTS.yxz;    \n    vec4 distsq = hash_x*hash_x + hash_y*hash_y;\n    vec2 tmp = min( distsq.xy, distsq.zw );\n    return min( tmp.x, tmp.y );\n}\n\nvec3 renderGrid(vec2 pos, float period, vec3 gridCol, vec3 colIn)\n{\n    pos.x = mod(pos.x, period*1.0);\n    pos.y = mod(pos.y, period*1.0);\n    float aa = 0.0000000025;\n    \n    vec2 toGrid = pos - round(pos);\n    if(pos.x > (toGrid.x - aa) && pos.x < (toGrid.x + aa)) return gridCol;\n    else if(pos.y > (toGrid.y - aa) && pos.y < (toGrid.y + aa)) return gridCol;\n   \telse return colIn;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    const float period = 8.0;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    uv *= 8.0;\n    uv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));\n    \n    const float angle = 0.2617994; //15deg in rads, because simplex tile at an angle we rotate space/uvs slightly to correct this\n    const float cos_factor = cos(angle);\n    const float sin_factor = sin(angle);\n    const mat2 rotMat = mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n    vec2 rotUV = rotUV(uv, rotMat);\n\n    vec3 col = vec3(SimplexCellular2D(rotUV, period));    \n   \n    vec2 griduv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    griduv *= 8.0;\n    griduv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));\n    //col = renderGrid(griduv, period, vec3(1.0,0.0,0.0), col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}