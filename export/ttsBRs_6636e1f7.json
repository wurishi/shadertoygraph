{"ver":"0.1","info":{"id":"ttsBRs","date":"1597521151","viewed":232,"name":"Depth of Field Raymarching","username":"athibaul","description":"A modified raymarching loop that allows to approximate a depth of field effect.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","dof","depthoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Depth of Field effect in Raymarching\n// by athibaul\n//\n// Uses a modified raymarching loop to evaluate\n// partial obstruction by nearby objects.\n//\n// Effectively combines views of the \n// inflated and shrunk objects in a smart way.\n\n// UPDATE 17/12/2020 - Added texture filtering based on comment by Xor\n\n#define MAX_STEPS 2048\n\nvec3 sun = normalize(vec3(-1., -1., 2.));\n\nfloat sclamp(float x, float k){\n    float h = max(k-abs(abs(x)-1.), 0.);\n    return clamp(x, -1., 1.) - sign(x)*h*h/(4.*k);\n}\n\n\nfloat sphereSDF(vec3 pos)\n{\n    // Repeating pattern of spheres\n    \n    vec2 turned = vec2(pos.x+pos.y, pos.x-pos.y);\n    turned = 6.0*round(turned/6.0);\n    turned = vec2(turned.x+turned.y, turned.x-turned.y)/2.0;\n    pos.x -= turned.x;\n    if(pos.y>-7.5)\n    \tpos.y -= turned.y;\n    return length(pos-vec3(0.,0.,1.))-1.;\n}\n\nfloat planeSDF(vec3 pos)\n{\n    // Bottom plane\n    return pos.z+0.4;\n}\n\nfloat blocksSDF(vec3 pos)\n{\n    // Just a few blocks\n    // Rounded box distance function by iq\n    // https://www.youtube.com/watch?v=62-pRVZuS5c\n    pos.xy -= 3.*round(pos.xy/3.);\n    vec3 c = vec3(0., 0., 0.0);\n    float rounded = 0.1;\n    vec3 r = vec3(0.3, 0.3, 0.8)-rounded;\n    vec3 q = abs(pos - c) - r;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;\n}\n\nint surfaceHit = -1; // 0 for plane, 1 for spheres, 2 for blocks\nfloat sceneSDF(vec3 pos)\n{\n    pos.xz += 1.-cos(pos.y/30.) - sin(pos.x/20.);\n    pos.y += sin(pos.y/40.)+1.-cos(pos.x/25.);\n    float d = planeSDF(pos);\n    surfaceHit = 0;\n    float d1 = sphereSDF(pos);\n    if(d1<d) { surfaceHit = 1; d = d1; }\n    d1 = blocksSDF(pos);\n    if(d1<d) { surfaceHit = 2; d = d1; }\n    return d;\n}\n\n\nvec3 calculateNormal(vec3 pos)\n{\n    // Tetrahedral normal calculation method by iq\n    vec2 e = vec2(0.002,-0.002);\n    return normalize(e.xxx * sceneSDF(pos+e.xxx)\n            + e.xyy * sceneSDF(pos+e.xyy)\n            + e.yxy * sceneSDF(pos+e.yxy)\n            + e.yyx * sceneSDF(pos+e.yyx));\n}\n\nvec3 rayDir(vec3 camFwd, float fov, vec2 uv)\n{\n    // In what direction to shoot?\n    vec3 camUp = vec3(0.,0.,1.);\n    camUp = normalize(camUp - camFwd*dot(camFwd, camUp)); // Orthonormalize\n    vec3 camRight = cross(camFwd, camUp);\n    return normalize(camFwd + (uv.x * camRight + uv.y * camUp)*fov);\n}\n\nvec3 texColor(vec3 p, float lodBias)\n{\n    //vec3 d = vec3(sceneSDF(p), planeSDF(p), sphereSDF(p));\n    if(surfaceHit==0) // Plane hit\n    { \n        return (texture(iChannel1, p.xy*0.03, lodBias)\n                + texture(iChannel1, p.xy*0.2, lodBias)).rgb/1.4;\n    }\n    if(surfaceHit==1) // Spheres hit\n    {\n        p *= 0.2*1.618;\n        return (texture(iChannel0, p.xy, lodBias)\n                +texture(iChannel0, p.yz, lodBias)\n                +texture(iChannel0, p.zx, lodBias)).rgb/2.;\n    }\n    // Blocks hit\n    p *= 0.3*1.618;\n    return (texture(iChannel2, p.xy, lodBias)\n            +texture(iChannel2, p.yz, lodBias)\n            +texture(iChannel2, p.zx, lodBias)).rgb/2.;\n}\n\nvec3 computeColor(in vec3 p, float lodBias){\n    vec3 normal = calculateNormal(p);\n    float diffuse = max(dot(normal, sun), 0.);\n    return diffuse*texColor(p, lodBias);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    // uv.y goes between +-1, and uv.x a bit more depending on the display format.\n\n    // Camera ray\n    //vec3 ro = vec3(2.*cos(iTime*0.5), -8., 2.+sin(iTime));\n    float motion = sclamp(1.3*cos(0.5*iTime), 0.15);\n    float mot2 = cos(3.*iTime);\n    float mot3 = cos(1.618*2.*iTime+5.);\n    vec3 unsteady = (mot2+mot3)*vec3(0.01,0.0,0.)\n        +(mot2-mot3)*vec3(0.,0.,0.01);\n    vec3 ro = vec3(2.8,-8.,2.+1.1*motion) + unsteady.xyz;\n    vec3 target = vec3(0.,0.,1.) + unsteady.zyx;\n    vec3 ri = rayDir(normalize(target-ro), 0.5, uv);\n    float w0 = 0.1; // Camera aperture size\n    //float fp = length(ro)-1.; // Camera focus distance\n    float fp = exp(1.4*motion)*8.;\n\n    // Modified raymarching\n    // \n    float d, t=0.;\n    float stepsize;\n    float w;\n    float ocl=0., ocl_c;\n    vec3 col=vec3(0.), col_c; // Current collected luminance\n    float pxSpread = length(fwidth(ri)); // \n    for(int j=0; j<MAX_STEPS; j++)\n    {\n        d = sceneSDF(ro + t*ri);\n        // Local spread of light rays:\n        // Starting with a spread of w0, they converge at a distance of fp,\n        // with a minimal spread of 5mm, then diverge again.\n        w = w0 * abs(1. - t/fp)+0.005;\n        // Partial occlusion occurs when an object is at a distance\n        // less than w from the ray.\n        // We approximate this by testing if d is between +-w.\n        ocl_c = clamp(0.5*(1.-d/w), 0.,1.);\n        //ocl_c *= ocl_c;\n        // In case of partial occlusion, compute local luminance\n        if(ocl_c > min(ocl+0.01, 0.99))\n        { \n            // filter textures based on ray width - thank you Xor!\n            float lodBias = log2(w*200.);\n        \tcol_c = computeColor(ro+t*ri, lodBias);\n            col += (ocl_c - ocl)*col_c;\n            ocl = ocl_c;\n        }\n        // We must march down to a depth of at least d=-w\n        //stepsize = max(0.7*d,0.)+0.5*w;\n        //stepsize = 0.7*(d + w);\n        stepsize = max(0.7*(d-w),0.)+pxSpread*t; // No artifacts, but many steps\n        if(ocl >= 0.99){break;}\n        t += stepsize;\n        if(t>1000.){t=1000.; break; }\n    }\n    vec3 pos = ro + t*ri;\n    vec3 sky = 1.3*vec3(0.5,0.7,0.9);\n    col += (1.-ocl) * sky;\n    // Tone mapping\n    //col = 1.-exp(-2.*col);\n    \n    // Output to screen\n    fragColor.rgb = vec3(col);\n    \n    \n    //fragColor.rgb = vec3(ocl);\n    \n}","name":"Image","description":"","type":"image"}]}