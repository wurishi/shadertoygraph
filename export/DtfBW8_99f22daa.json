{"ver":"0.1","info":{"id":"DtfBW8","date":"1693538052","viewed":61,"name":"Plane & Simple Texture Encoding","username":"mileslacey","description":"PASTE compression of RGB888 (LDR) colors as 3 vertices which define a plane. The plane's normal is encoded in an octahedral format. The output texture has been compressed up to 60%. It's still a work in progress, some artifacts may appear.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["compression","plane","encoding","octahedral","paste"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Final render target, decompress the input texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Every 3 output pixels will read the same input texel\n    uvec2 pixelPos = uvec2(fragCoord.xy);\n    uvec2 iFragCoord = pixelPos.xy - (pixelPos.xy % uvec2(3u, 1u));\n\tivec2 uv = ivec2(iFragCoord);\n    vec4 c = texelFetch(iChannel0, uv, 0);\n    vec4 plane;\n    \n    // Set to TRUE for 3-channel octahedral decoding of a plane.\n    // Set to FALSE for simple 4-channel decoding.\n    if (PACK_PIXEL_PLANE == true)\n    {\n        vec2 hemiNorm = c.xy;\n        float hemiDist = c.z;\n        vec3 outNorm = packed_norm_decode(hemiNorm);\n        plane = vec4(outNorm, hemiDist);\n    }\n    else\n    {\n        plane = c;\n    }\n    \n    // Read the encoded axes of the input plane. Each axis corresponds to one\n    // of 3 RGB values from the original input texture.\n    vec3 p0, p1, p2;\n    does_plane_intersect_line(plane, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), p0);\n    does_plane_intersect_line(plane, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), p1);\n    does_plane_intersect_line(plane, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), p2);\n    \n    // Separate the axis value into RGB components.\n    vec3 c0 = index_to_color(p0.x);\n    vec3 c1 = index_to_color(p1.y);\n    vec3 c2 = index_to_color(p2.z);\n    \n    // Associate each of the 3 RGB values with an output pixel.\n    vec4 compressed;\n    vec4 orig = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    if (pixelPos.x % 3u == 0u)\n    {\n        compressed = vec4(c0, 1.0);\n    }\n    else if (pixelPos.x % 3u == 1u)\n    {\n        compressed = vec4(c1, 1.0);\n    }\n    else\n    {\n        compressed = vec4(c2, 1.0);\n    }\n    \n    // Show results, with comparison against the original texture.\n    const float dilation = 10.0;\n    float modulation;\n    \n    if (iMouse.x > 0.f)\n    {\n        modulation = step(fragCoord.x, iMouse.x);\n    }\n    else\n    {\n        float timedMod = cos(fract(iTime / dilation) * 3.14159265 * 2.0);\n        modulation = step(fragCoord.x/iResolution.x, timedMod * 0.5 + 0.5);\n    }\n    \n    fragColor = mix(compressed, orig, modulation);\n    \n    // Debug\n    #if 0\n    vec4 f = texelFetch(iChannel0, uv, 0);\n    fragColor = plane;\n    if (f.z > 10000.0)\n    {\n        fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    }\n    #endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// This framebuffer just outputs a common texture which can be referenced by\n// subsequent render targets\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n/*\n    Set to \"true\" to pack colors into 3 bytes per pixel, \"false\" for 4 bytes per pixel.\n*/\n#define PACK_PIXEL_PLANE true\n\n/*\n    Use 0 for hemi-octahedral normal encoding, 1 for spheremap normal encoding\n*/\n#define NORMAL_PACKING_TYPE 0\n\n\n\n/*\n    Set to 0 to use morton-encoding of each RGB component in a texture.\n    Set to 1 to shift RGB bits into the low 24-bits of a float.\n*/\n#define TEXEL_PACKING_TYPE 0\n\n\n\n/*\n    Set to 0 so bits used from texel to plane conversion are interpreted directly as floats.\n    Set to 1 so bits read from a texture are cast to a float (following int-to-float conversion rules).\n*/\n#define TREAT_UINT_BITS_AS_FLOAT 0\n\n\n\nvec4 plane_from_point_and_normal(in vec3 p, in vec3 normal)\n{\n    return vec4(normal, -dot(p, normal));\n}\n\n\n\nvec4 plane_from_points(in vec3 p0, in vec3 p1, in vec3 p2)\n{\n    vec3 normal = normalize(cross(p1-p0, p2-p0));\n    return plane_from_point_and_normal(p0, normal);\n}\n\n\n\nbool does_plane_intersect_line(in vec4 p, in vec3 l0, in vec3 l1, out vec3 outIntersection)\n{\n    vec3 u = l1 - l0;\n    float denom = dot(p.xyz, u);\n    \n    if (abs(denom) == 0.f)\n    {\n        outIntersection = l0;\n        return false;\n    }\n\n    vec3 pco = p.xyz * (-p.w / dot(p.xyz, p.xyz));\n    vec3 w = l0 - pco;\n    float fac = -dot(p.xyz, w) / denom;\n    outIntersection = l0 + (u * fac);\n\n    return true;\n}\n\n\n\nvec2 hemioct_norm_encode(in vec3 n)\n{\n    float d = max(abs(n.x), abs(n.y));\n    float sz = abs(n.z) + d; //could drop the abs(z)\n    return n.xy / sz;\n}\n\n\n\nvec3 hemioct_norm_decode(in vec2 n)\n{\n    float z = 1.f - max(abs(n.x), abs(n.y));\n    return normalize(vec3(n, z));\n}\n\n\n\nvec2 spheremap_norm_encode(in vec3 n)\n{\n    // Extrapolated from https://www.shadertoy.com/view/llfcRl\n    return n.xy / sqrt(2.f * n.z + 2.f);\n}\n\n\n\nvec3 spheremap_norm_decode(in vec2 n)\n{\n    // Extrapolated from https://www.shadertoy.com/view/llfcRl\n    float f = dot(n, n);\n    return normalize(vec3((n + n) * sqrt(1.f - f), 1.f - (f + f)));\n}\n\n\n\nvec2 packed_norm_encode(in vec3 n)\n{\n    #if NORMAL_PACKING_TYPE == 0\n        return hemioct_norm_encode(n);\n    #else\n        return spheremap_norm_encode(n);\n    #endif\n}\n\n\n\nvec3 packed_norm_decode(in vec2 n)\n{\n    #if NORMAL_PACKING_TYPE == 0\n        return hemioct_norm_decode(n);\n    #else\n        return spheremap_norm_decode(n);\n    #endif\n}\n\n\n\nuint color_to_morton_index(in uvec3 bits)\n{\n    uvec3 x = bits & 0x000000FFu;      // x = ---- ---- ---- ---- ---- ---- 7654 3210\n    x = (x ^ (x << 8u)) & 0x0000F00Fu; // x = ---- ---- ---- ---- 7654 ---- ---- 3210\n    x = (x ^ (x << 4u)) & 0x000C30C3u; // x = ---- ---- ---- 76-- --54 ---- 32-- --10\n    x = (x ^ (x << 2u)) & 0x00249249u; // x = ---- ---- --7- -6-- 5--4 --3- -2-- 1--0\n    \n    return (x.z << 2u) | (x.y << 1u) | x.x;\n}\n\n\n\nuvec3 morton_index_to_color(uint bits)\n{\n    uvec3 x = uvec3(bits, bits >> 1, bits >> 2);\n    x = x & 0x00249249u;               // x = ---- ---- --7- -6-- 5--4 --3- -2-- 1--0\n    x = (x ^ (x >> 2u)) & 0x000C30C3u; // x = ---- ---- ---- 76-- --54 ---- 32-- --10\n    x = (x ^ (x >> 4u)) & 0x0000F00Fu; // x = ---- ---- ---- ---- 7654 ---- ---- 3210\n    x = (x ^ (x >> 8u)) & 0x000000FFu; // x = ---- ---- ---- ---- ---- ---- 7654 3210\n    \n    return x;\n}\n\n\n\nuint color_to_packed_index(in uvec3 c)\n{\n    const uvec3 shifts = uvec3(0u, 8u, 16u);\n    uvec3 rgb = (c & 0x000000FFu) << shifts;\n    return rgb.r | rgb.g | rgb.b;\n}\n\n\n\nuvec3 packed_index_to_color(uint m)\n{\n    const uvec3 shifts = uvec3(0u, 8u, 16u);\n    uvec3 rgb = uvec3(m, m, m) >> shifts;\n    return rgb & 0x000000FFu;\n}\n\n\n\nfloat color_to_index(in vec3 c)\n{\n    uint index;\n    uvec3 rgb = clamp(uvec3(c * 255.f), uvec3(0u), uvec3(255u));\n    \n    #if TEXEL_PACKING_TYPE == 0\n        index = color_to_morton_index(rgb);\n    #else\n        index = color_to_packed_index(rgb);\n    #endif\n    \n    \n    #if TREAT_UINT_BITS_AS_FLOAT == 0\n        return float(index);\n    #else\n        return uintBitsToFloat(index | 0x3E000000u);\n    #endif\n}\n\n\n\nvec3 index_to_color(float i)\n{\n    uint m;\n    uvec3 rgb;\n    \n    #if TREAT_UINT_BITS_AS_FLOAT == 0\n        m = uint(i);\n    #else\n        m = floatBitsToUint(i) & 0x00FFFFFFu;\n    #endif\n    \n    #if TEXEL_PACKING_TYPE == 0\n        rgb = morton_index_to_color(m);\n    #else\n        rgb = packed_index_to_color(m);\n    #endif\n    \n    return clamp(vec3(rgb) / 255.f, vec3(0.f), vec3(1.f));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// PASTE texture compression\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Only store data on every 3rd pixel of our render target.\n    // In actual applications, the render target is 1/3 the size\n    // of the input texture.\n    ivec2 pixelPos = ivec2(fragCoord.xy);\n    if (pixelPos.x % 3 != 0)\n    {\n        discard;\n    }\n    \n    // Read 3 input texels\n\tivec2 uv0 = pixelPos + ivec2(0, 0);\n\tivec2 uv1 = pixelPos + ivec2(1, 0);\n\tivec2 uv2 = pixelPos + ivec2(2, 0);\n    \n    vec3 c0 = texelFetch(iChannel0, uv0, 0).xyz;\n    vec3 c1 = texelFetch(iChannel0, uv1, 0).xyz;\n    vec3 c2 = texelFetch(iChannel0, uv2, 0).xyz;\n    \n    // Convert the 3 RGB values to 3 manipulable floating-point\n    // values. It's important that the values van be converted\n    // back into 8-bit RGB colors with minimal data-loss.\n    float id0 = color_to_index(c0);\n    float id1 = color_to_index(c1);\n    float id2 = color_to_index(c2);\n    \n    // Store the floats as 3 discrete cartesian points.\n    vec3 p0 = vec3(id0, 0.0, 0.0);\n    vec3 p1 = vec3(0.0, id1, 0.0);\n    vec3 p2 = vec3(0.0, 0.0, id2);\n    \n    // Convert the 3 points into a plane\n    vec4 plane = plane_from_points(p0, p1, p2);\n    \n    // Set to TRUE for 3-channel octahedral encoding of a plane.\n    // Set to FALSE for simple 4-channel encoding.\n    if (PACK_PIXEL_PLANE == true)\n    {\n        vec2 hemiPlane = packed_norm_encode(plane.xyz);\n        float hemiDist = plane.w;\n        plane = vec4(hemiPlane, hemiDist, 1.0);\n    }\n    \n    fragColor = plane;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}