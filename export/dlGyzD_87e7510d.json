{"ver":"0.1","info":{"id":"dlGyzD","date":"1700054715","viewed":332,"name":"Philip Glass 'Opening' (sound)","username":"athibaul","description":"A reproduction of Philip Glass's piece \"Opening\", from \"Glassworks\", and some raytraced glass.","likes":32,"published":1,"flags":40,"usePreview":1,"tags":["sound","music","lens","audio","optics","physical","spectral"],"hasliked":0,"parentid":"dtGcRW","parentname":"Lens optics"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See \"sound\" tab for the music\n// and \"Buffer A\" for the scene\n\n\n\nMain {\n    O = 3. * B(U) / C(U);\n    // tone mapping\n    //O = 1. - exp(-O);\n    O = pow(O, vec4(0.8,1.0,1.2, 1.0));\n    // gamma correction\n    O = sqrt(O);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Index of refraction as a function of wavelength\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\n// Constants for borosilicate glass BK7\n//#define IOR(wavelength) (1.5046 + 0.00420 / ((wavelength) * (wavelength)))\n#define IOR(wavelength) (1.4 + 0.1 / ((wavelength) * (wavelength)))\n\n\n#define T_MAX 1000.\n#define T_MIN 0.001\n// Materials\n#define NO_MATERIAL 0.0\n// Floor material\n#define FLOOR 1.0\n// Glass (incoming ray)\n#define GLASS_IN 2.0\n// Glass (outgoing ray)\n#define GLASS_OUT 3.0\n// Absorbing material\n#define ABSORB 4.0\n\n\n// Light direction and radius\nvec3 l_dir = normalize(vec3(-0.8,-1,0.5));\nfloat lrad = 0.2;\n\nfloat sceneIntersect(vec3 ro, vec3 rd, out vec3 normal, out float material) {\n    // Raytrace the scene\n    float t = T_MAX;\n    // Bottom plane\n    float plane_z = -1.0;\n    float t_plane = -(ro.z - plane_z) / rd.z;\n    if(T_MIN < t_plane && t_plane < t) {\n        t = t_plane;\n        normal = vec3(0,0,1);\n        material = FLOOR;\n    }\n    // Glass sphere\n    {\n    vec2 t_sphere = sphIntersect(ro, rd, vec3(0), 1.0);\n    if(T_MIN < t_sphere.x && t_sphere.x < t) {\n        t = t_sphere.x;\n        vec3 p = ro + rd * t_sphere.x; normal = normalize(p);\n        material = GLASS_IN;\n    } else if(T_MIN < t_sphere.y && t_sphere.y < t) {\n        t = t_sphere.y;\n        vec3 p = ro + rd * t_sphere.y; normal = -normalize(p);\n        material = GLASS_OUT;\n    }\n    }\n    \n    // Glass sphere 2\n    {\n    vec3 sphereC = vec3(-1.3,-2,0);\n    vec2 t_sphere = sphIntersect(ro - sphereC, rd, vec3(0), 1.0);\n    if(T_MIN < t_sphere.x && t_sphere.x < t) {\n        t = t_sphere.x;\n        vec3 p = ro + rd * t_sphere.x; normal = normalize(p - sphereC);\n        material = GLASS_IN;\n    } else if(T_MIN < t_sphere.y && t_sphere.y < t) {\n        t = t_sphere.y;\n        vec3 p = ro + rd * t_sphere.y; normal = -normalize(p - sphereC);\n        material = GLASS_OUT;\n    }\n    }\n    \n    // Glass cube\n    /*\n    {\n    vec3 boxNormal = vec3(0);\n    vec3 boxOrigin = vec3(-1.3,-2,0.01);\n    vec3 boxSize = vec3(1.0);\n    vec2 t_cube = boxIntersection(ro - boxOrigin, rd, boxSize, boxNormal);\n    if(T_MIN < t_cube.x && t_cube.x < t) {\n        t = t_cube.x;\n        normal = boxNormal;\n        material = GLASS_IN;\n    } else if(T_MIN < t_cube.y && t_cube.y < t) {\n        t = t_cube.y;\n        vec3 p = ro + (t + T_MIN)*rd;\n        boxIntersection(ro - boxOrigin, -rd, boxSize, boxNormal);\n        normal = -roundedboxNormal(p - boxOrigin, boxSize, 0.);\n        //normal = boxNormal;\n        material = GLASS_OUT;\n    }\n    }\n    */\n    \n    // Glass hex prism\n    {\n    vec4 tN, tF;\n    vec3 hexOrigin = vec3(0.01,-1,2.01);\n    float ra = 1.0, ha = 1.0;\n    iHexPrism(ro.zyx - hexOrigin, rd.zyx, ra, ha, tN, tF);\n    if(T_MIN < tN.x && tN.x < t) {\n        t = tN.x;\n        normal = tN.yzw;\n        normal = normal.zyx;\n        material = GLASS_IN;\n    } else if(T_MIN < tF.x && tF.x < t) {\n        t = tF.x;\n        vec3 p = ro + (t + T_MIN)*rd;\n        // Hack: for outgoing normal, perform the calculation again with the opposite ray\n        iHexPrism(ro.zyx - hexOrigin, -rd.zyx, ra, ha, tN, tF);\n        normal = -tN.yzw;\n        normal = normal.zyx;\n        material = GLASS_OUT;\n    }\n    }\n    \n    // Black veil with circular opening for light\n    {\n    float veil_d = 20.0;\n    vec3 veil_o = veil_d * l_dir;\n    vec3 veil_n = l_dir;\n    float t_veil = -dot(ro - veil_o, veil_n) / dot(rd, veil_n);\n    vec3 p = ro + t_veil * rd;\n    vec3 q = cross(veil_n, p);\n    if(T_MIN < t_veil && t_veil < t && length(q) > 3.0) {\n        t = t_veil;\n        material = ABSORB;\n        normal = veil_n;\n    }\n    }\n    \n    \n    return t;\n}\n\n\nvec3 refractOrReflect(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    if (k < 0.0)\n        return reflect(I, N);\n        //return vec3(0);\n    else\n        return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec3 uniformHemisphere(vec2 h) {\n    // Generate uniform sample in hemisphere\n    float theta0 = 2.*3.1415926 * h.x;\n    float theta1 = abs(asin(1. - 2.*h.y));\n    return vec3(cos(theta0) * cos(theta1), sin(theta0) * cos(theta1), sin(theta1));\n}\n\nvec3 cosWeightedHemisphere(vec2 h) {\n    // Generate cosine-weighted sample in hemisphere\n    float r = sqrt(h.x);\n    float theta = 2.*3.1415926 * h.y;\n    return vec3(cos(theta)*r, sin(theta)*r, sqrt(1.-h.x));\n}\n\nfloat calcLuminance(vec3 ro, vec3 rd, float wavelength) {\n    float nLambda = IOR(wavelength);\n    float transm = 1.0;\n    \n    for(int i = 0; i < 10; i++) {\n        // Pathtrace the scene\n        vec3 normal = vec3(0);\n        float material = NO_MATERIAL;\n        float t = sceneIntersect(ro, rd, normal, material);\n        vec3 p = ro + t * rd;\n        \n        if(material == FLOOR) {\n            /*\n            // The floor is an emissive material: stop bouncing\n            float scale = 3.0;\n            p *= scale;\n            p.xy *= ROT(0.5);\n            float emission = mod(floor(p.x) + floor(p.y), 2.);\n            return emission;\n            */\n            ro = p + T_MIN * normal;\n            vec2 p2 = hash23(vec3(p.xy * 100., iFrame));\n            rd = cosWeightedHemisphere(p2);\n            transm *= 0.5;\n        } else if(material == GLASS_IN) {\n            // Either reflect or refract the ray into the glass\n            float R0 = 0.05;\n            float fresnel = R0 + (1. - R0) * pow(1. + dot(rd, normal), 5.);\n            float h = hash13(vec3(1000.*rd.xz, iFrame));\n            if(h < fresnel) {\n                ro = p + T_MIN * normal;\n                rd = reflect(rd, normal);\n            } else {\n                ro = p - T_MIN * normal;\n                rd = refract(rd, normal, 1.0/nLambda);\n            }\n            transm *= 0.9;\n        } else if(material == GLASS_OUT) {\n            // Refract the ray out of the glass\n            ro = p;\n            rd = refractOrReflect(rd, normal, nLambda);\n        } else if(material == ABSORB || (t == T_MAX && i==0)) {\n            return 0.;\n        } else if (t == T_MAX){\n            // Failed to intersect scene : light at infinity\n            return transm * step(1. - lrad*lrad, dot(rd, l_dir)) / (lrad*lrad);\n        }\n    }\n    \n    \n    //return step(dot(rd.xz, rd.xz), wavelength);\n    return 0.;\n}\n\nMain {\n    vec2 u = (2.*U-R)/R.y;\n    \n    vec3 camPos = vec3(2., 2., 2.0);\n    vec3 target = vec3(0.5,-1,0);\n    //vec3 target = vec3(0);\n    float theta = 6.28 * (0.8 + 0.2 * iMouse.x / R.x);\n    //float theta = 6.28 * 0.9;\n    camPos.xy *= ROT(theta);\n    vec3 camDir = normalize(target - camPos);\n    vec3 camRight = normalize(cross(camDir, vec3(0,0,1)));\n    vec3 camUp = normalize(cross(camRight, camDir));\n    // Choose random wavelength\n    float wavelength = 0.4 + 0.3 * hash13(vec3(U, iFrame));\n    // Simulate simple lens flare\n    float h1 = hash13(vec3(U, iFrame + 100));\n    if(h1 < 0.03) {\n        u *= (- wavelength);\n    }\n    \n    float r_dia = 0.03 + 0.02 * wavelength; // diaphragm radius\n    // Choose random point in (square) aperture\n    vec2 p2 = hash23(vec3(U, iFrame));\n    p2 = r_dia * (2.*p2 - 1.);\n    // Ray origin and direction\n    vec3 ro = camPos + p2.x * camRight + p2.y * camUp;\n    float fov = 1.0; // Field of view\n    vec3 rd = normalize(normalize(target - ro) + fov * (u.x * camRight + u.y * camUp));\n    \n    \n    float luminance = calcLuminance(ro, rd, wavelength);\n    \n    O = vec4(luminance, wavelength, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define Main void mainImage(out vec4 O, in vec2 U)\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define B(U) texelFetch(iChannel1, ivec2(U), 0)\n#define C(U) texelFetch(iChannel2, ivec2(U), 0)\n#define R iResolution.xy\n#define ROT(theta) mat2(cos(theta), sin(theta), -sin(theta), cos(theta))\n\n// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Sphere intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\n\nvoid iHexPrism( in vec3  ro, in vec3  rd, in float ra, in float he,\n    out vec4 tN, out vec4 tF)\n{\n    // tN : vec4(t, normal) at entry point\n    // tF : vec4(t, normal) et exit point\n    const float ks3 = 0.866025;\n\n    // normals\n    const vec3 n1 = vec3( 1.0,0.0,0.0);\n    const vec3 n2 = vec3( 0.5,0.0,ks3);\n    const vec3 n3 = vec3(-0.5,0.0,ks3);\n    const vec3 n4 = vec3( 0.0,1.0,0.0);\n\n    // slabs intersections\n    vec3 t1 = vec3((vec2(ra,-ra)-dot(ro,n1))/dot(rd,n1), 1.0);\n    vec3 t2 = vec3((vec2(ra,-ra)-dot(ro,n2))/dot(rd,n2), 1.0);\n    vec3 t3 = vec3((vec2(ra,-ra)-dot(ro,n3))/dot(rd,n3), 1.0);\n    vec3 t4 = vec3((vec2(he,-he)-dot(ro,n4))/dot(rd,n4), 1.0);\n    \n    // inetsection selection\n    if( t1.y<t1.x ) t1=vec3(t1.yx,-1.0);\n    if( t2.y<t2.x ) t2=vec3(t2.yx,-1.0);\n    if( t3.y<t3.x ) t3=vec3(t3.yx,-1.0);\n    if( t4.y<t4.x ) t4=vec3(t4.yx,-1.0);\n   \n    tN=vec4(t1.x,t1.z*n1);\n    if( t2.x>tN.x ) tN=vec4(t2.x,t2.z*n2);\n    if( t3.x>tN.x ) tN=vec4(t3.x,t3.z*n3);\n    if( t4.x>tN.x ) tN=vec4(t4.x,t4.z*n4);\n    \n    /*tF=vec4(t1.y,t1.z*n1);\n    if( t2.y<tF.x ) tN=vec4(t2.y,t2.z*n2);\n    if( t3.y<tF.x ) tN=vec4(t3.y,t3.z*n3);\n    if( t4.y<tF.x ) tN=vec4(t4.y,t4.z*n4);\n    */\n    tF = vec4(min(min(t1.y,t2.y),min(t3.y,t4.y)), tN.yzw);\n    \n    // no intersection\n    //if( tN.x>tF || tF<0.0) return vec4(-1.0);\n    if(tN.x > tF.x || tF.x < 0.0) {\n        tN.x = -1.0; tF.x = -1.0;\n    }\n}\n\n// Spectral color scheme by Alan Zucconi \n// https://www.shadertoy.com/view/ls2Bz1\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nvec4 calcInfluence(float wavelength) {\n    return vec4(spectral_zucconi(1000.*wavelength), 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"Main {\n    vec4 a = A(U);\n    float luminance = a.x;\n    float wavelength = a.y;\n    vec4 influence = calcInfluence(wavelength);\n    if(iMouse.z > 0.) {\n        O = luminance * influence;\n    } else {\n        O = B(U) + luminance * influence;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"Main {\n    vec4 a = A(U);\n    float wavelength = a.y;\n    vec4 influence = calcInfluence(wavelength);\n    \n    if(iMouse.z > 0.) {\n        O = influence;\n    } else {\n        O = C(U) + influence;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// A reproduction of Philip Glass's piece \"Opening\", from \"Glassworks\"\n// https://en.wikipedia.org/wiki/Glassworks_(composition)\n// Arrangement for Shadertoy by Alexis THIBAULT, November 2023.\n\n// I previously made an arrangement of the same piece\n// for \"dittytoy\", a platform similar to Shadertoy, but oriented\n// towards audio creation using javascript:\n// https://dittytoy.net/ditty/13d7ee15e5\n\n#define TAU (2.*3.1415926)\n\nconst float BPM = 92.;\nconst float BPS = BPM / 60.;\nconst float SPB = 1.0 / BPS; // Seconds per beat\nconst int SampPerBeat = int(44100. * SPB);\n\n#define ssin(ft) sin(TAU * mod(ft,1.))\n#define msin(ft,m) sin(TAU * mod(ft,1.) + m)\n\nvec2 playNote(float nn, float t, float vel) {\n    t = max(t, 0.);\n    vec2 sig = vec2(0);\n    float f = 440. * pow(2., (nn-69.)/12.);\n    vec2 f2 = f * (1. + 0.06*0.05*vec2(-1,1));\n    float dur = 5. * pow(0.8, (nn-69.)/12.);\n    float amp0 = pow(0.8, (nn-69.)/12.);\n    float amp1 = (0.5+vel);\n    float iom = amp1 * exp(-3.*t/dur);\n    sig += msin(f2*t, iom * ssin(f*t)) * exp(-7.*t/dur);\n    float dur8 = 0.1*dur;\n    float amp8 = 0.05*amp1*(0.7+vel);\n    sig += amp8 * ssin(8.*f*t) * exp(-7.*t/dur8);\n    float amp12 = 0.02*amp1*(0.1+vel);\n    float dur12 = dur * 0.02;\n    sig += amp12 * ssin(12.*f*t) * exp(-7.*t/dur12);\n    float env = smoothstep(0., 0.002, t);\n    return sig * amp1 * env;\n}\n\nvec2 playBar(float t, vec3 lh, vec2 rh, float v0, float v1) {\n    float b = t * BPS;\n    vec2 sig = vec2(0);\n    if(b > 0. && b < 4.) {\n        float vel = mix(v0, v1, b/4.);\n        sig += playNote(lh.x, t, vel);\n        for(float b0 = 0.0; b0 < 4.; b0++) { sig += playNote(lh.y, t-b0*SPB, vel); }\n        for(float b0 = 0.5; b0 < 4.; b0++) { sig += playNote(lh.z, t-b0*SPB, vel); }\n        for(float b0 = 0.0; b0 < 3.9; b0+=2./3.) { sig += playNote(rh.x, t-b0*SPB, vel); }\n        for(float b0 = 1./3.; b0 < 3.9; b0+=2./3.) { sig += playNote(rh.y, t-b0*SPB, vel); }\n    }\n    float env = smoothstep(0.,0.001,b) * smoothstep(4.0,3.99,b);\n    return sig * env;\n}\n\n#define Z(a,b,c,d,e,v0,v1) sig += playBar(t, vec3(a,b,c), vec2(d,e), v0, v1);\n\nvec2 fullSong(int s, float t)\n{\n    vec2 sig = vec2(0);\n    t = max(t, 0.);\n    s = max(s, 0);\n    int bn = s / (4 * SampPerBeat); // bar number\n    s -= 4 * bn * SampPerBeat;\n    t = float(s)/iSampleRate;\n    switch(bn%48) {\n        case 0: case 4: case 8:  case 12: Z(53,56,60,65,68,0.0,0.2); break;\n        case 1: case 5: case 9:  case 13: Z(53,56,60,72,65,0.2,0.5); break;\n        case 2: case 6: case 10: case 14: Z(51,55,58,67,72,0.5,0.4); break;\n        case 3: case 7: case 11:          Z(49,55,58,68,72,0.4,0.0); break;\n        case 15: Z(46,55,58,67,72,0.5,0.3); break;\n        case 16: case 20: case 24: case 28: Z(48,53,56,60,65,0.3,0.9); break;\n        case 17: case 21: case 25: case 29: Z(46,53,56,62,65,0.9,0.8); break;\n        case 18: case 22: case 26: case 30: Z(46,51,55,58,63,0.8,0.6); break;\n        case 19: case 23: case 27:          Z(43,51,55,60,63,0.6,0.3); break;\n        case 31: Z(43,51,55,58,63,0.5,0.0); break;\n        case 32: case 36: case 40: Z(53,58,62,74,65,0.0,0.2); break;\n        case 33: case 37: case 41: Z(53,58,62,68,74,0.2,0.8); break;\n        case 34: case 38: case 42: Z(56,60,63,75,68,0.8,0.9); break;\n        case 35: case 39:          Z(58,60,63,75,68,0.9,0.0); break;\n        case 43: Z(58.01,60,63,75,68,0.9,1.0); break;\n        case 44: Z(55,58,62,74,67,1.0,0.5); break;\n        case 45: Z(-1,58,62,74,67,0.5,0.2); break;\n        case 46: Z(53,58,62,74,68,0.2,0.0); break;\n        case 47: Z(53,58,62,74,70,0.0,0.0); break;\n    }\n    return 0.1 * sig;\n}\n\nvec2 mainSound(int s, float t) {\n    return fullSong(s, t);\n}","name":"Sound","description":"","type":"sound"}]}