{"ver":"0.1","info":{"id":"tllyD7","date":"1639549169","viewed":83,"name":"RayMarching study2","username":"photonic","description":"study","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.14159265358979323846\n\n\n\nfloat map(vec3 p) {\n    p.y += sin(iTime * 2.) / 20.;\n    float sphere = length(p + 0.03 * vec3(texture(iChannel0, p.xy))) - 0.25 ;\n    float plane = p.y + .35;\n    //return min(sphere,plane);\n\treturn sphere;\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx) ) );\n}\n\nvec3 spherical_texturing(in vec3 normal, in sampler2D text, float delta) {\n     float u = atan(normal.z, normal.x) / PI * 1.0 + delta;\n\t float v = asin(normal.y) / PI * 1.0;\n     return texture(text, vec2(u, v)).xyz;\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i=0;i<100;i++)\n    {\n    \tvec3 pos = ro +dO*rd;\n        float dS = map(pos);\n        if (dS < 0.001)\n            break;\n        dO += dS;\n        if (dO > 20.0)\n            break;\n    }\n    if (dO > 20.0 ) dO = -1.0;\n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float dist = length(uv / 2.0);\n    vec3 col = mix(vec3(.03), vec3(0.0), dist * 1.4);\n\n       //CAMERA\n    float an = -iMouse.x/iResolution.x * 10.;\n\tvec3 ro = vec3(1.0*sin(an), 0.0, 1.0*cos(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );  \n    \n    float dO = castRay(ro, rd);\n    if ( dO > 0.0) \n    {\n        vec3 pos = ro + dO*rd;\n        vec3 nor = getNormal(pos);\n        vec3 mate = vec3(0.5);\n        \n        vec3 sun_dir = normalize( vec3(0.0, 1.0,0.0) );\n        float sun_dif = clamp( 0.5+0.5*dot(nor, sun_dir), 0.0, 1.0);\n        vec3 sun_col = vec3(7.0, 4.5, 3.0) / 5.0;\n        \n        vec3 sky_dir = normalize( vec3(-1.0, -1.0, 0.0) );\n        float sky_dif = clamp(  dot(nor, sky_dir), 0.0, 1.0);\n        vec3 sky_col = vec3(0.3, 0.4,0.6);\n        \n        vec3 bounce_dir = normalize( vec3(1.0, -1.0, 0.0));\n\t\tfloat bounce_dif = clamp( 0.5 +0.5*dot(nor, bounce_dir), 0.0, 1.0);        \n        \n        float shadow = step(castRay(pos+nor*0.001, sun_dir), 0.0); \n        \n        col = mate*sun_dif * 2.0;\n        col += mate*sky_dif*vec3(0.0, 0.3, 0.5) / 1.0;\n\t\t//col = mate*sun_col*sun_dif*shadow;\n        //col += mate*sky_col*sky_dif;\n        //col += mate*bounce_dif*vec3(.8,0.3,0.1);\n    }\n    float zDepth = length(dO);\n\t//col += zDepth / 4.0;\n    \n    col = pow( col, vec3(.4545) );\n    \n \n    \n        fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}