{"ver":"0.1","info":{"id":"tts3zl","date":"1557360529","viewed":235,"name":"RayMarcing Tree","username":"ankd","description":"I want to create tree from http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html \nbut my implementation (maybe particularly branch part) is wrong so there is many distortion...\n(2019/05/09) add \"tree\" function that include Intersect function.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Reference ... http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n//\nconst float PI = 3.1415926;\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate(in float r){\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n, in float offset){\n    return dot(p, n) - offset;\n}\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\nfloat sdTorus(in vec3 p, in vec2 r){\n    vec2 q = vec2(length(p.xz)-r.x, p.y);\n    return length(q) - r.y;\n}\nfloat sdCylinder(in vec3 p, in float r){\n    return length(p.xz) - r;\n}\nfloat sdCone(in vec3 p, in vec2 n){\n    return dot(vec2(length(p.xz), p.y), n);\n}\n\nvec2 opU(in vec2 d1, in vec2 d2){\n    return d1.x<d2.x ? d1 : d2;\n}\nvec2 opS(in vec2 d1, in vec2 d2){\n    return vec2(\n            (d1.x<-d2.x ? -d2.x : d1.x),\n            d1.y\n        );\n}\nvec2 opI(in vec2 d1, in vec2 d2){\n    return vec2(\n        (d1.x<d2.x ? d2.x : d1.x),\n        d1.y\n    );\n}\n\nvec3 opRep(in vec3 p, in vec3 c){\n    return mod(p, c)-0.5*c;\n}\nvec2 opRepAngle(in vec2 p, in float n){\n    float angle = 2.0*PI / n;\n    float sector = floor(atan(p.x,p.y)/angle + 0.5);\n    p *= rotate(sector * angle);\n    return p;\n}\nvec3 opRepAngleS(in vec2 p, in float n){\n    float angle = 2.0*PI / n;\n    float sector = floor(atan(p.x,p.y)/angle + 0.5);\n    p *= rotate(sector * angle);\n    return vec3(p, mod(sector, n));\n}\n\nfloat star(in vec3 p, in float r){\n    p.xy = opRepAngle(p.xy, 5.0);\n    p = abs(p);\n    vec3 n = vec3(0.5, 0.25, 0.8);\n    return sdPlane(p, n, r);\n}\nfloat topper(in vec3 p){\n    float s = star(p, 0.3);\n    float c = max(sdCylinder(p, 0.2), sdPlane(abs(p-vec3(0., -0.5, 0.)), vec3(0.,1.,0.), 0.5));\n    // return c;\n    return min(s, c);\n}\nvec2 bauble(in vec3 p){\n    float t = sdTorus(p.yxz-vec3(0.7, 0., 0.), vec2(0.1, 0.02));\n    float c = max(sdCylinder(p, 0.08), sdPlane(abs(p-vec3(0., 0.55, 0.)), vec3(0., 1., 0.), 0.1));\n    float s = sdSphere(p, 0.5);\n    vec2 res = opU(\n            vec2(min(t,c), 0.8),\n            vec2(s, 1.0)\n        );\n    return res;\n}\n#define NEEDLE_LENGTH           0.5\n#define NEEDLE_SPACING          0.2\n#define NEEDLE_THICKNESS        0.02\n#define NEEDLES_RADIAL_NUM      17.0\n#define NEEDLE_BEND             0.99\n#define NEEDLE_TWIST            1.6\n#define NEEDLE_GAIN             1.5\nfloat needles(in vec3 p){\n    p.xy *= rotate(-length(p.xz)*NEEDLE_TWIST);    // 7. twist the needles\n    p.xy = opRepAngle(p.xy, NEEDLES_RADIAL_NUM);         // 6. replicate the needles radially\n    p.yz *= rotate(-NEEDLE_BEND);                  // 5. rotate the row of needles to align back with Z axis\n    p.y -= p.z*NEEDLE_GAIN;                             // 4. skew the row of needles down along Y\n    p.z = min(p.z, 0.0);                                // 3. remove the Z+ part\n    p.z = opRep(p, vec3(NEEDLE_SPACING)).z;                  // 2. clone the needle along Z\n    return max(\n            sdCone(p-vec3(0., NEEDLE_LENGTH, 0.), vec2(NEEDLE_LENGTH, NEEDLE_THICKNESS)),\n            -sdPlane(p, vec3(0.,1.,0.), 0.)\n        );    // 1. A single needle (cone)\n}\n#define STEM_THICKNESS          0.05\nvec2 branch(in vec3 p) {\n    vec2 res = vec2(needles(p), 1.0);\n    float s = sdCylinder(p.xzy, STEM_THICKNESS);\n    s = max(s, sdPlane(p, vec3(0.0, 0.0, 1.0), 0.0));\n    vec2 stem = vec2(s, 0.3);\n    res = opU(res, stem);\n    return res;\n}\n#define BRANCH_ANGLE            0.5\n#define BRANCH_ANGLE_FADE  0.11\n#define BRANCH_SPACING          1.3\n#define BRANCH_NUM_MAX          9.0\n#define BRANCH_NUM_FADE         2.2\n#define BRANCH_CURVATURE      0.08\n\n#define TREE_H                  4.0\n#define TREE_R                  1.0\n#define TRUNK_WIDTH             0.025\n#define TREE2_ANGLE             0.4\n#define TREE2_OFFSET            0.4\n#define TREE2_SCALE             0.9\n\nvec2 halfTree(vec3 p) {\n    float section = floor(p.y/BRANCH_SPACING);\n    float numBranches =  max(2.0, BRANCH_NUM_MAX - section*BRANCH_NUM_FADE);\n    // 6. Revolve/clone around Y:\n    p.xz = opRepAngle(p.xz, numBranches); \n    // 5. Offset to get the tree foundation:\n    p.z -= TREE_R; \n    // 4. Rotate to get the tree slope:\n    p.yz *= rotate(BRANCH_ANGLE); \n    // 3. Clone vertically:\n    p.y = opRep(p, vec3(BRANCH_SPACING)).y; \n    // Offset to compensate for the bend:\n    p.y -= BRANCH_SPACING*0.2; \n    // 2. Bend it to a parabolic shape:\n    p.yz *= rotate(-length(p.yz)*BRANCH_CURVATURE + BRANCH_ANGLE + section*BRANCH_ANGLE_FADE); \n    // 1. A branch:\n    vec2 b =  branch(p); \n    return b;\n}\nvec2 tree(vec3 p) {\n    //  the first bunch of branches\n    vec2 res = halfTree(p); \n    \n    // the second bunch of branches (to hide the regularity)\n    p.xz *= rotate(TREE2_ANGLE);\n    p.y -= BRANCH_SPACING*TREE2_OFFSET;\n    p /= TREE2_SCALE;\n    vec2 t2 = halfTree(p);\n    t2.x *= TREE2_SCALE;\n    res = opU(res, t2);\n\n    // trunk    \n    vec2 tr = vec2(sdCone(p.xyz, vec2(TREE_H*2.0, TRUNK_WIDTH)), 0.);\n    res = opU(res, tr);\n\n    res = opI(res, vec2(sdSphere(p - vec3(0.0, TREE_H*0.5 + 1.0, 0.0), TREE_H + 0.8), 0.0));    \n    return res;\n}\n\nvec2 map(in vec3 p){\n    vec2 res = tree(p-vec3(0., -3.0, 0.));\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD = 0.0;\n    float maxD = 20.0;\n    \n    float d = minD, m = -2.0;\n    for(int i=0;i<100;i++){\n        vec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<0.00001 || maxD<tmp.x) break;\n        d += tmp.x*0.7;\n        m = tmp.y;\n    }\n    if(maxD<d) m = -1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 e = vec2(1.0, -1.0)*0.0001;\n    return normalize(vec3(\n            e.xyy*map(p+e.xyy).x +\n            e.yxy*map(p+e.yxy).x +\n            e.yyx*map(p+e.yyx).x +\n            e.xxx*map(p+e.xxx).x\n        ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 ld = normalize(vec3(1.0));\n    \n    vec3 color = vec3(0.);\n    if(0.<=m)color = vec3(dot(ld, nor)) * hsv(m/5.0, 1.0, 1.0);\n\n    color *= exp(-0.01*d);\n\n    return color;\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar-eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cp, cw));\n    vec3 cv = normalize(cross(cw, cu));\n    return mat3(cu, cv, cw);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = 10.0*sin(iTime*0.4)*vec3(cos(iTime*0.2), 0.2, sin(iTime*0.2));\n    vec3 tar = vec3(0.);\n    vec3 rd = normalize(lookAt(ro, tar, 0.)*vec3(p, 1.0));\n    \n    vec3 color = render(ro, rd);\n    \n    color = pow(color, vec3(2.2));    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}