{"ver":"0.1","info":{"id":"MdG3z3","date":"1455720272","viewed":175,"name":"Riemann Sphere 2016.02.17","username":"samuelotherion","description":"projection of the complex plane to a Riemann Sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","projection","complexplane","riemannsphere","malndelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n#define RES   \tiResolution\n#define ASP \tRES.x/RES.y\n#define M\t\t(vec2(10.5,1./2.5)+vec2(20,7) * (iMouse.xy/RES.xy-.5))\n#define ID3   \tmat3(1,0,0,0,1,0,0,0,1)\n#define Rxy\t\t(mat3(1,0,0,0,cos(M.y),sin(M.y),0,-sin(M.y),cos(M.y))*mat3(-sin(.1 * t),0,cos(.1 * t),0,1,0,cos(.1 * t),0,sin(.1 * t)))\n#define t     \tiTime\n#define NP\t\t.1\n#define FP\t\t100.\n#define NOO     0\n#define PLN     1\n#define SPH     2\n#define L1P\t\tvec3( 5.3 * sin( 3.2 * sin( .64 * t ) ),  1.1, 5.3 * cos( 3.2 * sin( .63 * t ) ) )\n#define L2P\t\tvec3( 0.,  -19.1 + 18. * cos( .2 * sin( .8 * t ) ), 18. * sin( .2 * sin( .8 * t ) ) )\n#define N       vec3(0,1,0)\n#define MIT\t\t256 //max iterations for fractal, use smaller numbers if speed drops down! \nstruct Hit { float d; vec3 p, n; int i; } hit;\nvec3   eye, ray;\nvec4   col;\nvoid \n    isPln( ) {\n        \n        vec3\n            n = sign( eye.y ) * N;\n        \n        float\n            l = dot( n, eye ) / dot( n, ray );\n\n        if( hit.d < l || l < NP ) return;\n                \n        hit.d = l;\n        hit.p = eye - l * ray;\n\t\thit.n = n;\n\t\thit.i = PLN;\n}\nvoid\n    isSph( ) {\n\n        float\n            ab = dot( ray, eye ),\n            bb = dot( eye, eye ),\n            ds = ( 1. - bb ) + ab * ab;\n\n        if( 0. <= ds ) {\n\n            ds = sqrt( +ds );\n\n            float\n                l = ab - ds;\n           \n            if( l <= NP ) \n             \n\t\t\t\tl = ab + ds;\n            \n            if( hit.d < l || l <= NP ) return;\n            \n            \n            hit.d = l;\n            hit.p = eye - l * ray;\n            hit.n = normalize( hit.p );\n            hit.i = SPH;\n        }\n    }\nfloat\n    mb( vec2 iC ) {\n        \n        vec2\n            c = iC;\n\n        for( int i = 0; i < MIT; ++i ) {\n         \n            if( 8. < dot( c, c ) ) return 1. - mod( float( i ), 16. ) / 16.;\n            \n            c = vec2( c.x * c.x - c.y * c.y, 2. * c.x * c.y ) - iC;\n        }        \n\n        return 0.;\n    }\nvec3\n    getPix( vec2 iXy ) {\n    \n        vec2\n            d = iXy - 1.5 * vec2( cos( .9 * t ), sin( t ) );\n        \n        float\n            f = dot( d, d );\n        \n        vec3\n            c = vec3( 0. );\n        \n        if( f < .1 ) \n            \n            c += sqrt( 1. - 10. * f ) *  ( .5 + 2. * vec3( iXy.y, iXy.x, .00 ) );\n        \n        d = iXy - 1.5 * vec2( cos( .69 * t ), sin( t ) );\n        \n        if( all( lessThan( abs( d - .5 ), vec2( .5 ) ) ) ) \n            \n            c += ( .5 + 2. * vec3( iXy.y, iXy.x, .00 ) );\n        \n        return c + texture( iChannel0, mod( iXy + .5, vec2( 1. ) ) ).rgb + smoothstep( 0., mb( iXy * ( 1. / ( 10.01 + 10. * sin( .2 * t ) ) ) - vec2( -2, 0. ) ), .2 + .1 * sin( .76 * t ) ) * vec3( .3, .3, .2 );;\n    }\n\nvoid\n   \n    light( ) {\n\n        vec3\n            d = L1P - hit.p;\n        \n        float\n            f = dot( d, d ),\n        \tb = pow( clamp( dot( d, hit.n ) / f, 0., 1. ), 1. );\n        \n        d = L2P - hit.p;\n        f = dot( d, d );\n            b += pow( clamp( dot( d, hit.n ) / f, 0., 1. ), 11. );\n        \n        b = .252422 + .52441 * b;\n        \n        col = \n            hit.i == NOO\n            \t? vec4( b * vec3( .71231, .8521, .913331 ), 1. )\n            \t: hit.i == SPH \n                    ? vec4( b * getPix( hit.p.xz  / ( 1. - hit.p.y ) ), 1. )// * .5 * vec3( 1. + hit.p.y, 1. - hit.p.y, 1. + hit.p.x ), 1. ) \n                    : vec4( b * ( vec3( .3, .4, .5 ) + getPix( hit.p.xz ) ), sin( t ) );\n    }\nvoid\n    mainImage( out vec4 oCol, in vec2 iXy ) {\n       \n\t\teye = vec3( 0, 0, M.x );\n        ray = normalize( - vec3( ( 2. * iXy / RES.xy - 1. ) * vec2( ASP, 1. ), -2. ) );\n        eye = eye * Rxy;\n        ray = ray * Rxy;\n\n        hit = Hit( FP, eye - FP * ray, ray, NOO );\n        \n        isSph( );\n        isPln( );\n        \n        light( );\n        \n        oCol = col;\n}","name":"Image","description":"","type":"image"}]}