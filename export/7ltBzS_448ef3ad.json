{"ver":"0.1","info":{"id":"7ltBzS","date":"1663361921","viewed":142,"name":"Computer Graphics - Task II","username":"VNR","description":"The second homework for Computer Graphics course in MIPT GameDev master program. This shader is PBR-based. Clouds are procedurally generated. You can drag mouse to change camera view.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","sdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS      250\n#define MAX_DIST       100.\n#define EPSILON        0.01\n#define HALF_CUBE_EDGE 1.\n#define M_PI           3.1415926\n#define F_DIEL         0.04\n#define F_METAL        0.\n#define GAMMA          2.2\n\nconst int MAT_CUBE  = 1;\nconst int MAT_PLANE = 2;\n\nvec3 lightPos = vec3(0., 15., -10.);\nvec3 rayOrigin = vec3(0., 1., -7.);\nvec3 lookAtPoint = vec3(0.);\nvec3 up = vec3(0., 1., 0.);\n\nvec3 lightColor = vec3(1.);\n\nconst mat2 m2 = mat2(0.1, -1.2,\n                     1.2,  0.1);\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(1, 0,  0),\n        vec3(0, c, -s),\n        vec3(0, s,  c)\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3( c, 0, s),\n        vec3( 0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s,  c, 0),\n        vec3(0,  0, 1)\n    );\n}\n\nmat3 view(vec3 rayOrigin, vec3 lookAtPoint, vec3 up) {\n    vec3 cameraZ = normalize(rayOrigin - lookAtPoint);\n    vec3 cameraX = normalize(cross(up, cameraZ));\n    vec3 cameraY = normalize(cross(cameraZ, cameraX));\n    return mat3(cameraX, cameraY, cameraZ);\n}\n\nvec3 getTriplanarWeights(in vec3 n) {\n    vec3 weights = pow(abs(n), vec3(2.));\n    return weights / (weights.x + weights.y + weights.z);\n}\n\nfloat sdfRoundedBox(vec3 pos, vec3 size, float r) {\n    vec3 q = abs (pos) - (size - r);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdfTorus(vec3 pos, vec2 radii) {\n    float x = length(pos.xz) - radii.x;\n    return length(vec2(x, pos.y)) - radii.y;\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvoid rotateDice(inout vec3 pos) {\n    pos *= rotateZ(iTime);\n    pos *= rotateX(iTime);\n}\n\nfloat sdfDice(vec3 pos) {\n    rotateDice(pos);    \n    float boxDist = sdfRoundedBox(pos, vec3(HALF_CUBE_EDGE), 0.2);\n    \n    vec3 torusPosition = pos - vec3(0, HALF_CUBE_EDGE, 0.);\n    float torusTop = sdfTorus(torusPosition, vec2(0.5, 0.125));\n    \n    torusPosition += vec3(0, 2.*HALF_CUBE_EDGE, 0.);\n    float torusBottom = sdfTorus(torusPosition, vec2(0.5, 0.125));\n    \n    torusPosition -= vec3(0, 2.*HALF_CUBE_EDGE, 0.);\n    torusPosition *= rotateZ(3.14/2.);\n    torusPosition += vec3(-HALF_CUBE_EDGE, HALF_CUBE_EDGE, 0.);\n    float torusLeft = sdfTorus(torusPosition, vec2(0.5, 0.125));\n    \n    torusPosition += vec3(0, -2.*HALF_CUBE_EDGE, 0.);\n    float torusRight = sdfTorus(torusPosition, vec2(0.5, 0.125));\n    \n    torusPosition *= rotateX(3.14/2.);\n    torusPosition += vec3(0, HALF_CUBE_EDGE, HALF_CUBE_EDGE);\n    float torusFront = sdfTorus(torusPosition, vec2(0.5, 0.125));\n    \n    torusPosition += vec3(0, -2. * HALF_CUBE_EDGE, 0);\n    float torusBack = sdfTorus(torusPosition, vec2(0.5, 0.125));\n    \n    float dist = smoothSubtraction(torusTop, boxDist, 0.1);\n    dist = smoothSubtraction(torusBottom, dist, 0.1);\n    dist = smoothSubtraction(torusLeft, dist, 0.1);\n    dist = smoothSubtraction(torusRight, dist, 0.1);\n    dist = smoothSubtraction(torusFront, dist, 0.1);\n    dist = smoothSubtraction(torusBack, dist, 0.1);\n    \n    return dist;\n}\n\nfloat sdfHorizontalPlane(vec3 pos, float height) {\n    return pos.y - height;\n}\n\nfloat sdfScene(vec3 pos) {\n    float diceDist = sdfDice(pos);    \n    float planeDist = sdfHorizontalPlane(pos, -2.*HALF_CUBE_EDGE);    \n    float dist = min(diceDist, planeDist);\n    \n    return dist;\n}\n\nint getMaterial(vec3 pos) {\n    float diceDist = sdfDice(pos);    \n    float planeDist = sdfHorizontalPlane(pos, -2.*HALF_CUBE_EDGE); \n    float dist = min(diceDist, planeDist);\n    \n    int material = 0;    \n    if (dist == diceDist)\n        material = MAT_CUBE;\n    else if (dist == planeDist)\n        material = MAT_PLANE;    \n    \n    return material;\n}\n\nfloat rayMarching(in vec3 rayOrigin, in vec3 rayDirection, out bool hit) {\n\tvec3 point = rayOrigin;\n\tfloat totalDist = 0.;\n\thit = false;\n\n\tfor ( int steps = 0; steps < MAX_STEPS; steps++ ) {\n\t\tfloat dist = sdfScene(point);        \n\t\tif (dist < EPSILON) {\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\t\t\n\t\ttotalDist += 0.8 * dist;\t\t\n\t\tif (totalDist > MAX_DIST)\n\t\t\tbreak;\n\t\tpoint += 0.8 * dist * rayDirection;\n\t}\t\n\treturn totalDist;\n}\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal) {\n    float occ = 0.;\n    float sca = 1.;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i) / 4.;\n        float d = sdfScene(pos + h * normal);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if (occ > 0.35) \n            break;\n    }\n    return clamp(1. - 3. * occ, 0., 1.)*(0.5 + 0.5 * normal.y);\n}\n\nvec3 fresnel(in vec3 f0, in float product) {\n    product = clamp(product, 0., 1.);\n    return mix(f0, vec3(1.), pow(1. - product, 5.));\n}\n\nfloat D_GGX(in vec3 n, in vec3 lightVec, in vec3 v, in float roughness) {\n    float r2 = roughness * roughness;\n    float r4 = r2 * r2;\n    vec3 h = normalize(lightVec + v);\n    float nh = dot(n, h);\n    float nh2 = nh * nh;\n    float d = (r4 - 1.) * nh2 + 1.;\n    return r4 / (M_PI * d * d);\n}\n\nfloat G_neumann(in vec3 n, in vec3 lightVec, in vec3 v) {\n    float nl = dot(n, lightVec);\n    float nv = dot(n, v);\n    return nl * nv/ max(nl, nv);\n}\n\nvec3 cookTorrance(in vec3 n, in vec3 lightVec, in vec3 v, in vec3 f0, in float roughness) {\n    float D = D_GGX(n, lightVec, v, roughness);\n    float G = G_neumann(n, lightVec, v);\n    return f0 * D * G;\n}\n\nvec3 getNormal(vec3 pos, float accuracy) {\n    float dist = sdfScene(pos);\n    vec2 delta = vec2(accuracy / 2., 0); \n    vec3 n1 = vec3(\n        sdfScene(pos + delta.xyy),\n        sdfScene(pos + delta.yxy),\n        sdfScene(pos + delta.yyx)\n    );\n    vec3 n2 = vec3(\n        sdfScene(pos - delta.xyy),\n        sdfScene(pos - delta.yxy),\n        sdfScene(pos - delta.yyx)\n    );\n    return normalize(n1 - n2);\n}\n\nvec3 skyColor(in vec3 rayOrigin, in vec3 rayDirection) {\n    vec3 color = vec3(0.5, 0.6, 1.) - 0.5 * rayDirection.y;    \n    return color;\n}\n\nfloat fractionalBrownianMotion(vec2 point) {\n    float f = 0.0;\n    \n    f += 0.5000 * texture(iChannel1, (point + 0.4 * iTime)/256.0).x;\n    point = m2 * point * 2.02;\n    \n    f += 0.2500 * texture(iChannel1, (point + 0.1 * iTime)/256.0).x;\n    point = m2 * point * 2.03;\n    \n    f += 0.1250 * texture(iChannel1, point / 256.0).x;\n    point = m2 * point * 2.01;\n    \n    f += 0.0625 * texture(iChannel1, point/256.0).x;\n    return f / 0.9375;\n}\n\nvoid ColorRoughnessMetalness(int material, in vec3 point,\n                             inout vec3 baseColor, inout float roughness,\n                             inout float metalness) {\n\n    if (material == MAT_CUBE) {\n        vec3 n1 = getNormal(point, 0.001);\n        vec3 pos = point;\n        rotateDice(n1); \n        rotateDice(pos); \n        vec3 tx = getTriplanarWeights (n1);\n        vec2 textureScale = 6.0 * iResolution.xy/max(iResolution.x, iResolution.y);\n\n        vec4 cx = texture(iChannel2, pos.yz / textureScale + 0.5);\n        vec4 cy = texture(iChannel2, pos.zx / textureScale + 0.5);\n        vec4 cz = texture(iChannel2, pos.xy / textureScale + 0.5);\n        baseColor = vec4(cx * tx.x + cy * tx.y + cz * tx.z).xyz;\n\n        float average = (baseColor.r + baseColor.g + baseColor.b) / 3.;\n        roughness = baseColor.r - average;\n        roughness = (roughness + 0.047058824) / 0.215686275;\n        metalness = pow((1. - roughness), 2.);\n        roughness *= 3.;\n        baseColor = clamp(baseColor * 1.5, 0., 1.);\n    }\n    else if (material == MAT_PLANE) {\n        baseColor = texture(iChannel0, point.xz * 0.25).rgb * vec3(1.5);\n        metalness = 0.;\n        roughness = 1.;\n    }\n}\n\nbool isInShadow(in vec3 point, in vec3 lightVec, in vec3 n) {\n    bool hit;\n    float dist = rayMarching(point + n * EPSILON * 2., lightVec, hit);\n    if (dist < length(lightPos - point))\n        return true;\n    return false;\n}\n\nvec3 calculateLighting(in vec3 baseColor, in float metalness, in float roughness,\n                       in vec3 n, in vec3 v, in float nv, in vec3 lightVec, in float nl,\n                       in vec3 point, in float dist, in int material) {\n              \n    baseColor = pow(baseColor, vec3(GAMMA));\n    \n    vec3 F0;\n    if (material == MAT_CUBE)\n        F0 = vec3(F_METAL);\n    else if (material == MAT_PLANE)\n        F0 = vec3(F_DIEL);\n        \n    F0 = mix(F0, baseColor, metalness);\n    vec3 specFresnel = fresnel(F0, nv);\n    vec3 spec = cookTorrance(n, lightVec, v, specFresnel, roughness)\n        * nl / max(0.001, 4.* nl * nv);\n    vec3 diff = (vec3(1.) - specFresnel) * nl / M_PI;\n    vec3 color = (diff * mix(baseColor, vec3(0.), metalness) + spec) * lightColor;\n    color += 0.25 * baseColor * ambientOcclusion(point, n);\n\n    if (isInShadow(point, lightVec, n) && material == MAT_PLANE)\n        color *= vec3(0.25, 0.3, 0.5);\n\n    color = pow(color, vec3(1. / GAMMA));\n    color = mix(color, vec3(0.5, 0.6, 1.0), pow(dist/MAX_DIST, 1.));\n    \n    return color;\n}\n\nvec3 getColor(in vec3 point, in float dist) {\n    int material = getMaterial(point);\n        \n    vec3 lightVec = normalize(lightPos - point);\n    vec3 n = getNormal(point, 0.001);\n    vec3 v = normalize(rayOrigin - point);\n    float nv = dot(n, v);\n    float nl = max(0., dot(n, lightVec));\n\n    vec3 baseColor;\n    float metalness, roughness;\n\n    ColorRoughnessMetalness(material, point, baseColor, roughness, metalness);  \n    \n    vec3 color = calculateLighting(baseColor, metalness, roughness, \n                                   n, v, nv, lightVec, nl,  point, dist, material);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy * 0.125 - 0.05;\n    rayOrigin *= rotateX(-3.0 * mouse.y) * rotateY(-20.0 * mouse.x);\n    rayOrigin *= rotateY(-iTime / (4. * M_PI));\n    mat3 viewMatrix = view(rayOrigin, lookAtPoint, up);\n    vec3 rayDirection = viewMatrix * normalize(vec3(uv, -1));\n    bool hit;\n    \n    float dist = rayMarching(rayOrigin, rayDirection, hit);\n    vec3 point = rayOrigin + rayDirection * dist;\n    \n    vec3 color = skyColor(rayOrigin, rayDirection);\n    \n    vec2 sc = rayOrigin.xz + rayDirection.xz * (250.*5000. - rayOrigin.y) / rayDirection.y;\n    vec3 clouds = mix(color, vec3(1., 0.95, 1.),\n        0.6 * smoothstep(0.4, 0.8, fractionalBrownianMotion(0.0001*sc/250.)));\n    if (rayDirection.y > 0.)\n        color = mix(color, clouds, clamp(rayDirection.y, 0., 0.01) * 100.);\n      \n    if (hit)\n        color = getColor(point, dist);\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}