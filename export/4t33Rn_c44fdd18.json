{"ver":"0.1","info":{"id":"4t33Rn","date":"1468316603","viewed":402,"name":"Bending Circle","username":"soma_arc","description":"Bending 2223 hyperbolic tiling. Most of larger bending parameter don't meet the requirements of the Tiling Theorem.\nFor more details, please refer Bending Hyperbolic Kaleidoscopes and Bending Circle Limits by Vladimir Bulatov\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\n\nvec2 cPos1 = vec2(1.2631, 0);\nvec2 cPos2 = vec2(0, 1.2631);\nfloat cr1 = 0.771643;\nfloat cr2 = 0.771643;\nconst float PI = 3.14159265359;\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nvec2 reverseStereoProject(vec3 pos){\n\treturn vec2(pos.x / (1. - pos.z), pos.y / (1. - pos.z));\n}\n\nvec4 circleIntersection(vec2 cPos1, float r1, vec2 cPos2, float r2){\n\tfloat x = cPos1.x - cPos2.x;\n    float y = cPos1.y - cPos2.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x2y2 = x2 + y2;\n    float a = (x2y2 + r2 * r2 - r1 * r1) / 2.;\n    float a2 = a * a;\n    float numR = sqrt(x2y2 * r2 * r2 - a2);\n    return vec4((a * x + y * numR) / x2y2 + cPos2.x, (a * y - x * numR) / x2y2 + cPos2.y,\n                (a * x - y * numR) / x2y2 + cPos2.x, (a * y + x * numR) / x2y2 + cPos2.y);\n}\n\n\nvec3 stereoProject(vec2 pos){\n\tfloat x = pos.x;\n    float y = pos.y;\n    float x2y2 = x * x + y * y;\n    return vec3((2. * x) / (1. + x2y2),\n                (2. * y) / (1. + x2y2),\n                (-1. + x2y2) / (1. + x2y2));\n}\n\nvec3 getCircleFromSphere(vec3 upper, vec3 lower){\n\tvec2 p1 = reverseStereoProject(upper);\n    vec2 p2 = reverseStereoProject(lower);\n   \treturn vec3((p1 + p2) / 2., distance(p1, p2)/ 2.); \n}\n\nbool revCircle = false;\nbool revCircle2 = false;\nconst int ITERATIONS = 50;\nfloat colCount = 0.;\nbool outer = false;\nint IIS(vec2 pos){\n    colCount = 0.;\n    //if(length(pos) > 1.) return 0;\n\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(revCircle){\n            if(distance(pos, cPos1) > cr1 ){\n                pos = circleInverse(pos, cPos1, cr1);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }else{\n        \tif(distance(pos, cPos1) < cr1 ){\n                pos = circleInverse(pos, cPos1, cr1);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }\n        \n        if(revCircle2){\n            if(distance(pos, cPos2) > cr2 ){\n                pos = circleInverse(pos, cPos2, cr2);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }else{\n        \tif(distance(pos, cPos2) < cr2 ){\n                pos = circleInverse(pos, cPos2, cr2);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }\n        \n        if(fund){\n            if(length(pos) > 1.5){\n                outer = true;\n            \treturn 0;\n            }\n        \treturn invCount;\n        }\n    }\n\n\treturn invCount;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 calcCircleFromLine(vec4 line){\n\tfloat a = line.x;\n    float b = line.y;\n    float c = line.z;\n    float d = line.w;\n    \n    float bcad = b * c - a * d;\n    float a2 = a * a;\n    float b2 = b * b;\n    float c2 = c * c;\n    float d2 = d * d;\n    float c2d2 = (1. + c2 + d2);\n    vec2 pos = vec2(((1. + a2) * d + b2 * d - b * c2d2)/(-2. * bcad),\n                     (a2 * c + (1. + b2) * c - a * c2d2)/ (2. * bcad));\n    return vec3(pos, distance(pos, line.xy));\n}\n\nconst float sampleNum = 30.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 10.);\n    t = abs(t - 5.) / 5.;\n    \n    float ratio = iResolution.x / iResolution.y / 2.0;\n    vec3 sum = vec3(0);\n    float x = 0.57735;\n\n    float bendX = t;// 0. + 1. * abs(sin(iTime));;//PI / 6.;\n    mat3 xRotate = mat3(1, 0, 0,\n                        0, cos(bendX), -sin(bendX),\n                        0, sin(bendX), cos(bendX));\n    float bendY = 0.;//PI/6.5;//-abs(0.8 * sin(iTime));\n    mat3 yRotate = mat3(cos(bendY), 0, sin(bendY),\n                         0, 1, 0,\n                         -sin(bendY), 0, cos(bendY));\n\tfloat y = .57735;\n    vec3 c1 = getCircleFromSphere(vec3(0, y, sqrt(1. - y * y))* xRotate,\n                                  vec3(0, y, -sqrt(1. - y * y))* xRotate);\n    vec3 c2 = getCircleFromSphere(vec3(x, 0, sqrt(1. - x * x)) * yRotate,\n                                  vec3(x, 0, -sqrt(1. - x * x)) * yRotate);\n    \n\tcr1 = c1.z;\n    cr2 = c2.z;\n    cPos1 = c1.xy;\n    cPos2 = c2.xy;\n    \n    if(y > cPos1.y){\n    \trevCircle = true;\n    }\n\tif(x > cPos2.x){\n    \trevCircle2 = true;\n    }\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\n        position *= ( 2.2 + ( t * 8.));\n        //position += vec2(cos(iTime), 0.3 * sin(iTime));\n\n        int d = IIS(position);\n        \n        if(d == 0){\n            sum += vec3(0.,0.,0.);\n        }else{\n            if(mod(float(d), 2.) == 0.){\n                if(outer){\n                \tsum += hsv2rgb(vec3(0.4 + 0.02 * colCount, 1., 1.));\n                }else{\n                    sum += hsv2rgb(vec3(0.02 * colCount, 1., 1.));\n                }\n            }else{\n                if(outer){\n                \tsum += hsv2rgb(vec3(0.8 + 0.02 * colCount, 1., 1.));\n                }else{\n                    sum += hsv2rgb(vec3(0.7 + 0.02 * colCount, 1., 1.));\n                }\n            }\n        }\n    }\n    fragColor = vec4(sum/sampleNum, 1.);\n}","name":"Image","description":"","type":"image"}]}