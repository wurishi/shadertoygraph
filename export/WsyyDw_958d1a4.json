{"ver":"0.1","info":{"id":"WsyyDw","date":"1670591948","viewed":154,"name":"Star, Nebula 002","username":"Delvar","description":"Using a 2d pixel aligned random noise for stars, it sort of allows you to look around by doing x and y tailing but the rotation is off when looking up and down. Lots of improvements to make but i never came back to it.\n\n","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["stars","nebula","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Star, Nebula 002'\n//  https://www.shadertoy.com/view/WsyyDw\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Using a 2d pixel aligned random noise for stars, \n//\tit sort of allows you to look around by doing x and y tailing \n//\tbut the rotation is off when looking up and down.\n//\tThen I went over the top and added random nebula and warp transition :)\n//\tRelated to my Javascript experiment that looks similar, https://delvar.github.io/nebula/\n//\n// =================================================================\n\n#define PI  3.1415926535897932384626433832795\n\n#define RAY_MAX_STEPS 10\n#define RAY_MAX_DISTANCE 100.0\n\n#define MIN_SURFACE_DISTANCE_BASE 0.02\n#define MIN_SURFACE_DISTANCE_MOD 0.2\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_NORMAL\t1\n\n// -- Debug Colours, https://en.wikipedia.org/wiki/Web_colors\n#define White vec3(1.0)\n#define Silver vec3(0.75)\n#define Gray vec3(0.5)\n#define Black vec3(0.001)\n#define Red vec3(1.0,0.001,0.001)\n#define Maroon vec3(0.5,0.001,0.001)\n#define Yellow vec3(1.0,1.0,0.001)\n#define Olive vec3(0.5,0.5,0.001)\n#define Lime vec3(0.001,1.0,0.001)\n#define Green vec3(0.001,0.5,0.001)\n#define Aqua vec3(0.001,1.0,1.0)\n#define Teal vec3(0.001,0.5,0.5)\n#define Blue vec3(0.001,0.001,1.0)\n#define Navy vec3(0.001,0.001,0.5)\n#define Fuchsia vec3(1.0,0.001,1.0)\n#define Purple vec3(0.5,0.001,0.5)\n#define Orange vec3(1.0,0.65,0.001)\n\n// https://iquilezles.org/articles/normalsSDF\n#define ZERO (min(iFrame,0))\n#define ZEROf (min(iTime,0.0))\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    float zoom, roll, pitch, yaw;\n    float xFov, yFov;\n};\n/*\nstruct rayMarch {\n    vec3 origin, direction;\n};\n\nstruct rayQuery {\n    vec3 origin;\n    float surfaceDistance;\n    int materialId;\n};\n\nstruct rayHit {\n    vec3 rayOrigin, origin, incidence, normal, albedo, diffuse, specular;\n    float surfaceDistance, rayDistance, rayDistanceRatio, cameraDistance, cameraDistanceRatio;\n    float reflectivity, occlusion, shadow, shininess;\n    int materialId, iteration;\n};\n  */  \n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n/*\nrayMarch getRay(vec2 uv, camera camera) {\n    rayMarch ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n*/\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n// ========== https://www.shadertoy.com/view/3lSXzD ==========\n\n// 2D Weyl hash 32-bit XOR  - https://www.shadertoy.com/view/4dlcR4\n\n#define _W0 0x3504f335u   \n#define _W1 0x8fc1ecd5u  \n#define _W2 0xbb67ae85u\n#define _W3 0xf1bbcdcbu\n\n// 741103597u, 1597334677u, 204209821u, 851723965u  // MLCG constants\n#define _M0 741103597u    \n#define _M1 1597334677u\n#define _M2 204209821u\n#define _M3 851723965u\n\n#define _FSCALE 256.0f\n#define _FNORM (1.0f/16777216.0f/_FSCALE)\n\nuint base_hash_1D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n  n.x *= _M0;    // MLCG constant\n\n  return( n.x ^ (n.x >> 16) );\n}\n\nuvec2 base_hash_2D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n\n  return( (n.x * uvec2(_M0, _M1)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nuvec4 base_hash_4D(in uvec4 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t// z' = Fz(z)\n  n.w *= _W3;\t// w' = Fw(w)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n  n.x ^= n.w;    // combine\n\n  return( (n.x * uvec4(_M0, _M1, _M2, _M3)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nfloat hash11(in float x) \n{\n\treturn float(base_hash_1D(uvec2(uint(_FSCALE * x)))) * _FNORM;\n}\n\nfloat hash12(in vec2 x)\n{\n\treturn float(base_hash_1D(uvec2(_FSCALE * x))) * _FNORM;\n}\n\nvec2 hash22(in vec2 xy)\n{\n\treturn vec2(base_hash_2D(uvec2(_FSCALE * xy))) * _FNORM;\n}\n\nvec4 hash41(in float x) \n{\n\treturn vec4(base_hash_4D(uvec4(uint(_FSCALE * x)))) * _FNORM;\n}\n\nvec4 hash42(in vec2 x) \n{\n\treturn vec4(base_hash_4D(uvec4(_FSCALE * x, 0, 0))) * _FNORM;\n}\n\nvec4 hash44(in vec4 x) \n{\n\treturn vec4(base_hash_4D(uvec4(_FSCALE * x))) * _FNORM;\n}\n\n// ========== Seeded Hash Functions ==========\n// Well sort off, instead of using static defined values we use a set of global hash values instead so we can modulate over time.\n\nvec4 randSeed01 = vec4(0.0);\nvec4 randSeed02 = vec4(0.0);\nvec4 randSeed03 = vec4(0.0);\nvec4 randSeed04 = vec4(0.0);\n\nfloat shash12(in vec2 s)\n{\n    return hash12(s + randSeed01.xy);\n}\n\nvec4 shash42(in vec2 s) \n{\n\treturn hash42(s + randSeed02.xy);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 2d, Unsigned, Fract Wraped, with smoothstep\n// Sample pos loops around at 0.0 and 1.0, number of cells is spread over this range, removed the requirment for 2 Mods\nfloat svalueNoise2duf(in vec2 samplePoint, float cells, in vec2 randSeed) {\n    vec2 pointI2 = floor(fract(samplePoint + 1.0/cells)*cells);\n    samplePoint = fract(samplePoint)*cells;\n    vec2 pointI1 = floor(samplePoint);\n    vec2 u = smoothstep(0.0,1.0,fract(samplePoint));\n\n    //Using smooth step here to push up the brighter parts of the noise\n    vec2 m = mix(\n        vec2(\n            smoothstep(0.0,1.0,hash12(pointI1 + randSeed)), //bl\n            smoothstep(0.0,1.0,hash12(vec2(pointI1.x,pointI2.y) + randSeed))//fl\n        ),\n        vec2(\n            smoothstep(0.0,1.0,hash12(vec2(pointI2.x,pointI1.y) + randSeed)),//br\n            smoothstep(0.0,1.0,hash12(vec2(pointI2.x,pointI2.y) + randSeed))//fr\n        ),u.x);\n    \n    return mix(m.x,m.y,u.y);\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n/*\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n// ========== ==========\n\n// ========== Camera Motion ==========\n\ncamera getTableCamera(vec3 lookAt, float distance, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw );\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.origin = lookAt + camera.forward*-distance;\n\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec2 mouse, in float time) {\n    float zoom = 1.0;\n    return getTableCamera(vec3(0.0,0.0,0.0), 5.0, 0.0, -mouse.y*2.0*PI, -mouse.x*2.0*PI,  zoom);\n}\n\n// ========== ==========\n\n// ========== Nebula Functions ==========\n\nfloat n1(in vec2 pos, in vec4 randSeed, in float res, in float time) {\n    return smoothstep(0.0,1.0,svalueNoise2duf(pos, res, randSeed.xy));\n}\n\n// - This looks a mess but its jsut basic fractal noise with a lot of hacky bits to make it look better\nfloat sampleNebula(in vec2 pos,in vec4 randSeed01,in vec4 randSeed02,in vec4 randSeed03,in vec4 randSeed04, float maxRes, in float time) {\n    float total = 1.0;\n    float res = randSeed01.x*10.0+2.0;\n    \n\tvec2 distortion =(vec2(\n    \tsvalueNoise2duf(pos, floor(res), randSeed02.xy)+svalueNoise2duf(pos, floor(res*2.0), randSeed03.xy),\n        svalueNoise2duf(pos, floor(res), randSeed02.zw)+svalueNoise2duf(pos, floor(res*2.0), randSeed03.zw)\n    )-1.0)*randSeed01.y*sin(time*0.005);\n    \n    #define STEPS 20.0\n    \n    float lacunarity = 1.4 + randSeed01.z * 0.3;\n    float roughness = 0.5 + randSeed01.w * 0.4;\n    \n    float pwHL = pow(lacunarity,-roughness);\n    float pwr = pwHL;\n\n    float value = 1.0-abs(n1(pos+(distortion/floor(res)),randSeed03, floor(res), time)*2.0-1.0);\n    \n    for(float i = ZEROf; i<STEPS; i++) {\n        vec4 randSeed=hash44(i+randSeed04);\n\t\tpwr *= pwHL;\n        res *= lacunarity;\n        //distortion *= pwHL;\n\t\tvalue += (n1(pos+sin(time*(randSeed.xy*0.002-0.001))+distortion/floor(res), randSeed, floor(res), time)*2.0-1.0) * pwr * value;\n        total += pwr * value;\n\n        if( (res>maxRes) || (value < 0.01 && value > -0.01) || (pwr < 0.01) ) {\n            break;\n        }\n    }\n    return clamp( (value/total),0.0,1.0);\n}\n\n// Given a nebula Id it switches round the seeds to get different looks\nfloat sampleNebulaId(in int nebulaId, in vec2 pos, float maxRes, in float time) {\n\tif (nebulaId == 0) {\n\t\treturn sampleNebula(pos, randSeed01, randSeed02, randSeed03, randSeed04, maxRes, time);\n\t} else if (nebulaId == 1) {\n\t\treturn sampleNebula(pos, randSeed02, randSeed03, randSeed04, randSeed01, maxRes, time);\n\t} else if (nebulaId == 2) {\n\t\treturn sampleNebula(pos, randSeed03, randSeed04, randSeed01, randSeed02, maxRes, time);\n    } else if (nebulaId == 3) {\n\t\treturn sampleNebula(pos, randSeed04, randSeed01, randSeed02, randSeed03, maxRes, time);\n\t}\n    return 1.0;\n}\n\n// Given a nebula Id it switches round the seeds to get different looks\nvec4 nebulaColourId(in int nebulaId, in float nebulaSample, in float light, in float time) {\n    vec4 r;\n    if (nebulaId == 0) {\n\t\tr = vec4(\n            mix(clamp(randSeed01.xyz,0.01,1.0),clamp(randSeed02.xyz,0.01,1.0),nebulaSample * light),\n            clamp(pow(nebulaSample,0.2+(randSeed02[nebulaId])*0.4)*(1.5),0.0,1.0)\n            );\n\t} else if (nebulaId == 1) {\n\t\tr =  vec4(\n            mix(clamp(randSeed03.xyz,0.01,1.0),clamp(randSeed04.xyz,0.01,1.0),nebulaSample * light),\n            clamp(pow(nebulaSample,0.45+(randSeed02[nebulaId])*0.4)*(1.75),0.0,1.0)\n            );\n\t} else if (nebulaId == 2) {\n\t\tr =  vec4(\n            mix(clamp(randSeed02.zwx,0.01,1.0),clamp(randSeed01.zwx,0.01,1.0),nebulaSample * light),\n            clamp(pow(nebulaSample,0.7+(randSeed02[nebulaId])*0.4)*(2.0),0.0,1.0)\n            );\n    } else if (nebulaId == 3) {\n\t\tr =  vec4(0.02, 0.01, 0.005, nebulaSample);\n    } else {\n        return vec4(White, 1.0);\n    }\n    \n    return clamp(r,vec4(vec3(0.01),0.0),vec4(1.0));\n}\n    \n// ========== ==========\n\n// ========== Sky Box ==========\n\nvec3 getStarField(inout camera camera, in vec2 fragCoord, in vec2 uv, in float time) {\n    //Radians in FOV\n    vec2 fov = (atan((iResolution.xy/iResolution.y)/camera.zoom)*2.0);\n    //Number of Radians per pixle\n    vec2 radsPerPixel = fov/iResolution.xy;\n    vec2 pixelsPerRad = iResolution.xy/fov;\n    \n    //Number of pixles in 2PI Radians\n    vec2 pixlesPerCircle = floor(vec2(2.0*PI)/radsPerPixel);\n    vec2 starSamplePos = fragCoord-iResolution.xy*0.5;\n    vec2 cameraPos = floor(vec2(camera.yaw,camera.pitch)*pixelsPerRad);\n    starSamplePos = mod(starSamplePos+cameraPos,pixlesPerCircle);\n\n    vec4 r = shash42(starSamplePos);\n    // lots 0.8 > few 0.99\n    // 0.99-0.8 = 0.19\n    // + 0.19 * (1.0-pow(1.0-randSeed01.x,4.0))\n    vec3 starColour = r.xyz*clamp(map(r.w, 0.8+ 0.19 * (1.0-pow(1.0-randSeed01.x,4.0)) , 1.0, 0.0, 1.0),0.0,1.0)*min(r.z,min(r.x,r.y));\n    \n    vec2 nebulaSamplePos = (starSamplePos/pixlesPerCircle);\n    \n    float yRatio = pixlesPerCircle.y/pixlesPerCircle.x;\n    \n    // - Bright Stars\n    //vec2 bsPos[8];\n    vec2 bsDelta[8];\n    float bsDistance[8];\n    float bsSize[8];\n    vec2 bsOffset[8];\n    float bsPower[8];\n    \n    //Tryng to find the closest delta, assuming we wrap around 0.0 to 1.0, \n    // eg. when the star is at 0.9 and the sample point is 0.1 the delta should be -0.2 not 0.8\n    // so if the delta is more than 0.5 it must be shorter to go round the other way\n    // Here we do all x's and y's using vector math, then split out later, for a bit of extra speed*.\n    // * maybe?\n    \n    //vec2 testStarPos = fract((vec2(camera.yaw, camera.pitch)*pixelsPerRad)/pixlesPerCircle);\n\n\t//Use random seed for Bright Star position but pixle align them\n    //removed pixle alignment and move them around a bit cuases them to twinkle :)\n    vec4 bsPosX = ( fract(randSeed01 + sin(randSeed02*time*0.001)) * pixlesPerCircle.x)/pixlesPerCircle.x;\n    vec4 bsDeltaX = nebulaSamplePos.x-bsPosX;\n    bsDeltaX = mix(bsDeltaX, (abs(bsDeltaX)-1.0)*sign(bsDeltaX), step(0.5, abs(bsDeltaX)));\n    \n    vec4 bsPosY = ( fract(randSeed02 + cos(randSeed03*time*0.001))*pixlesPerCircle.y)/pixlesPerCircle.y;\n    vec4 bsDeltaY = nebulaSamplePos.y-bsPosY;\n    bsDeltaY = mix(bsDeltaY, (abs(bsDeltaY)-1.0)*sign(bsDeltaY), step(0.5, abs(bsDeltaY))) * yRatio;\n    \n    //bsPos[0] = vec2(bsPosX[0], bsPosY[0]);\n    //bsPos[1] = vec2(bsPosX[1], bsPosY[1]);\n    //bsPos[2] = vec2(bsPosX[2], bsPosY[2]);\n    //bsPos[3] = vec2(bsPosX[3], bsPosY[3]);\n    \n    bsDelta[0] = vec2(bsDeltaX[0], bsDeltaY[0]);\n    bsDelta[1] = vec2(bsDeltaX[1], bsDeltaY[1]);\n    bsDelta[2] = vec2(bsDeltaX[2], bsDeltaY[2]);\n    bsDelta[3] = vec2(bsDeltaX[3], bsDeltaY[3]);\n    \n    bsDistance[0] = length(bsDelta[0]);\n    bsDistance[1] = length(bsDelta[1]);\n    bsDistance[2] = length(bsDelta[2]);\n    bsDistance[3] = length(bsDelta[3]);\n\n    float offsetLength = length(1.0/pixlesPerCircle)*1.0;\n    \n    bsOffset[0] = normalize(bsDelta[0])*offsetLength;\n    bsOffset[1] = normalize(bsDelta[1])*offsetLength;\n    bsOffset[2] = normalize(bsDelta[2])*offsetLength;\n    bsOffset[3] = normalize(bsDelta[3])*offsetLength;\n    \n    vec4 bsSizes = clamp(randSeed03*0.25,0.05,0.25);\n    \n    bsSize[0] = bsSizes[0];\n    bsSize[1] = bsSizes[1];\n    bsSize[2] = bsSizes[2];\n    bsSize[3] = bsSizes[3];\n\n    bsPower[0] = pow(clamp(bsSize[0]-bsDistance[0],0.0,1.0)/bsSize[0],2.0);\n    bsPower[1] = pow(clamp(bsSize[1]-bsDistance[1],0.0,1.0)/bsSize[1],2.0);\n    bsPower[2] = pow(clamp(bsSize[2]-bsDistance[2],0.0,1.0)/bsSize[2],2.0);\n    bsPower[3] = pow(clamp(bsSize[3]-bsDistance[3],0.0,1.0)/bsSize[3],2.0);\n    \n    // -- Bright Stars 4 to 8\n    \n\t//Use random seed for Bright Star position but pixle align them\n    bsPosX = ( fract(randSeed03 + sin(randSeed04*time*0.001))*pixlesPerCircle.x)/pixlesPerCircle.x;\n    bsDeltaX = nebulaSamplePos.x-bsPosX;\n    bsDeltaX = mix(bsDeltaX, (abs(bsDeltaX)-1.0)*sign(bsDeltaX), step(0.5, abs(bsDeltaX)));\n    \n    bsPosY = ( fract(randSeed04 + cos(randSeed01*time*0.001))*pixlesPerCircle.y)/pixlesPerCircle.y;\n    bsDeltaY = nebulaSamplePos.y-bsPosY;\n    bsDeltaY = mix(bsDeltaY, (abs(bsDeltaY)-1.0)*sign(bsDeltaY), step(0.5, abs(bsDeltaY))) * yRatio;\n    \n    //bsPos[4] = vec2(bsPosX[0], bsPosY[0]);\n    //bsPos[5] = vec2(bsPosX[1], bsPosY[1]);\n    //bsPos[6] = vec2(bsPosX[2], bsPosY[2]);\n    //bsPos[7] = vec2(bsPosX[3], bsPosY[3]);\n    \n    bsDelta[4] = vec2(bsDeltaX[0], bsDeltaY[0]);\n    bsDelta[5] = vec2(bsDeltaX[1], bsDeltaY[1]);\n    bsDelta[6] = vec2(bsDeltaX[2], bsDeltaY[2]);\n    bsDelta[7] = vec2(bsDeltaX[3], bsDeltaY[3]);\n    \n    bsDistance[4] = length(bsDelta[4]);\n    bsDistance[5] = length(bsDelta[5]);\n    bsDistance[6] = length(bsDelta[6]);\n    bsDistance[7] = length(bsDelta[7]);\n\n    bsOffset[4] = normalize(bsDelta[4])*offsetLength;\n    bsOffset[5] = normalize(bsDelta[5])*offsetLength;\n    bsOffset[6] = normalize(bsDelta[6])*offsetLength;\n    bsOffset[7] = normalize(bsDelta[7])*offsetLength;\n    \n    bsSizes = clamp(randSeed04*0.25,0.05,0.25);\n    \n    bsSize[4] = bsSizes[0];\n    bsSize[5] = bsSizes[1];\n    bsSize[6] = bsSizes[2];\n    bsSize[7] = bsSizes[3];\n    \n    bsPower[4] = pow(clamp(bsSize[4]-bsDistance[4],0.0,1.0)/bsSize[4],2.0);\n    bsPower[5] = pow(clamp(bsSize[5]-bsDistance[5],0.0,1.0)/bsSize[5],2.0);\n    bsPower[6] = pow(clamp(bsSize[6]-bsDistance[6],0.0,1.0)/bsSize[6],2.0);\n    bsPower[7] = pow(clamp(bsSize[7]-bsDistance[7],0.0,1.0)/bsSize[7],2.0);\n    \n    vec3 c = starColour;\n  \n   \n    //4 Nebula\n    for(int nebulaId=ZERO; nebulaId<4; nebulaId++) {\n\t\tfloat nebulaSample = sampleNebulaId(nebulaId, nebulaSamplePos, pixlesPerCircle.x, time);\n        \n        float light = 0.0;\n        \n        //8 Bright Stars\n            \n\t\tfor(int bsId=ZERO; bsId<8; bsId++) {\n            if(bsPower[bsId] <= 0.0) {\n                continue;\n            }\n            // -- Front Light\n            float tLight = 0.0;\n            for(float samples=ZEROf+1.0; samples<=4.0; samples++) {\n\t\t\t\tfloat ss = sampleNebulaId(nebulaId,nebulaSamplePos + bsOffset[bsId]*pow(2.0,samples), pixlesPerCircle.x, time);\n\t\t\t\tfloat sb = sampleNebulaId(nebulaId,nebulaSamplePos - bsOffset[bsId]*pow(2.0,samples), pixlesPerCircle.x, time);\n    \t\t\tvec2 slopeNormal = normalize(vec2(offsetLength*pow(2.0,samples)*-20.0,ss-sb));\n\t\t\t\tvec2 lightDir = normalize(vec2(bsDistance[bsId],1.1+(float(bsId)*0.5)-((ss+sb)*0.5)));\n            \ttLight += (dot(slopeNormal, lightDir)*0.5+0.5)*pow(bsPower[bsId],2.0);\n            }\n            light+=tLight/4.0;\n            // --\n\t\t}\n        vec4 nebulaColour;\n        \n        if (nebulaId == 3) {\n\t\t\tnebulaSample = clamp(pow(clamp(nebulaSample*(1.0+randSeed01.w),0.0,1.0),4.0+randSeed02.w*3.0)*10.0,0.0,1.0);\n        } else {\n\t\t\tnebulaSample = pow(nebulaSample*(0.7+randSeed01[nebulaId]*0.7),3.0+randSeed02[nebulaId]+(float(nebulaId)*0.25));\n        }\n        nebulaColour = nebulaColourId(nebulaId, nebulaSample, pow(0.25+light,2.0), time);\n        c = mix(c, mix(nebulaColour.xyz,clamp(nebulaColour.xyz*5.0,0.1,1.0),pow(light*1.5,1.0))*(0.5+light*2.0), nebulaColour.w);\n  \t}\n    \n    c = clamp(c*0.9,0.0,0.9);\n    \n    //Hard coded 45 degree rotation.\n    mat2 rot = mat2(0.70710678118, -0.70710678118, 0.70710678118, 0.70710678118);\n    \n    // Add the spiky bits\n    float light = 0.0;\n    for(int bsId=ZERO; bsId<8; bsId++) {\n        \tlight += pow(bsPower[bsId],30.0);\n        \tvec2 d = bsDelta[bsId]/(bsSize[bsId]*0.5);\n        \tlight += 0.75 * pow(bsPower[bsId],3.0) * pow(clamp(1.0-abs(d.x*d.y*100.0),0.0,1.0),15.0);\n        \td*=rot;\n        \tlight += 0.5 * pow(bsPower[bsId],10.0) * pow(clamp(1.0-abs(d.x*d.y*150.0),0.0,1.0),25.0);\n\t\t}\n    light = clamp(light,0.0,1.0);\n    c = mix(c, vec3(2.0,1.6,1.4), light);\n\n    // Add the lense flare\n    light = 0.0;\n    for(int bsId=ZERO; bsId<8; bsId++) {\n        \tlight += bsPower[bsId]*0.15;\n\t\t}\n    light = clamp(light,0.0,1.0);\n    c = mix(c, White, light);\n    return c;\n}\n\n\n// ========== Ray Marcher ==========\n/*\nvoid sdfShapes(inout rayQuery query, float cameraDistanceRatio, in float time) {\n\tfloat newDistance = query.surfaceDistance;\n    vec3 objectPos;\n\n    objectPos=vec3(0.0,0.0,0.0);\n    newDistance = min(newDistance, sdBox(query.origin - objectPos, vec3(0.25))-0.01);\n\n    if (newDistance < query.surfaceDistance) {\n        query.surfaceDistance = newDistance;\n        query.materialId = MAT_NORMAL;\n    }\n}\n\nvoid QuerySdf(inout rayQuery query, float cameraDistanceRatio, in float time) {\n    query.materialId = MAT_SKY;\n    query.surfaceDistance = RAY_MAX_DISTANCE;\n\n    //sdfShapes(query, cameraDistanceRatio, time);\n}\n\nrayHit RayMarch(inout rayMarch ray, float cameraDistance, int cameraSteps, in float time)\n{\n\trayQuery query;\n    float accumilatedRayDistance = 0.0;\n    int i = cameraSteps;\n    for(; i<RAY_MAX_STEPS; i++) {\n        float cameraDistanceRatio = (accumilatedRayDistance+cameraDistance)/RAY_MAX_DISTANCE;\n        //the more iterations the less precise we are, improve perfomance a bit with only mild artifacts\n        float modulatedMinSurfaceDistance=MIN_SURFACE_DISTANCE_MOD * cameraDistanceRatio + MIN_SURFACE_DISTANCE_BASE;\n        query.origin = ray.direction * accumilatedRayDistance + ray.origin;\n\n        QuerySdf(query, cameraDistanceRatio,time);\n        accumilatedRayDistance += query.surfaceDistance;\n\n        if(accumilatedRayDistance+cameraDistance >= RAY_MAX_DISTANCE) {\n            accumilatedRayDistance = RAY_MAX_DISTANCE - cameraDistance;\n            query.materialId=MAT_SKY;\n            break;\n        }\n        else if(query.surfaceDistance >= 0.0 && query.surfaceDistance < modulatedMinSurfaceDistance) {\n            break;\n        }\n    }\n    \n    rayHit hit;\n    hit.origin = query.origin;\n    hit.surfaceDistance = query.surfaceDistance;\n\thit.materialId = query.materialId;\n    hit.rayOrigin = ray.origin;\n    hit.incidence = ray.direction;\n    hit.iteration = i;\n    hit.rayDistance = accumilatedRayDistance;\n    hit.rayDistanceRatio = clamp((hit.rayDistance/RAY_MAX_DISTANCE),0.0,1.0);\n    hit.cameraDistance = accumilatedRayDistance+cameraDistance;\n    hit.cameraDistanceRatio = clamp((hit.cameraDistance/RAY_MAX_DISTANCE),0.0,1.0);\n    return hit;\n\n}\n// https://iquilezles.org/articles/normalsSDF\n#define ZERO (min(iFrame,0))\nvoid calcNormal(inout rayHit hit, in float time )\n{\n    if(hit.materialId == MAT_SKY) {\n        return;        \n    }\n   \n    rayQuery query;\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        query.origin=hit.origin+0.001*e;\n        QuerySdf(query, hit.cameraDistanceRatio,time);\n        n += e*query.surfaceDistance;\n    }\n    hit.normal = normalize(n);\n}\n\nvoid renderRay(inout rayHit hit, inout camera camera, in vec2 fragCoord, in vec2 uv, in float time) {\n    if(hit.materialId == MAT_SKY) {\n        hit.albedo = getStarField(camera, fragCoord, uv, time);//vec3(sampleStars(floor(hit.origin.xy)*100.0));\n        hit.diffuse = White;\n        hit.occlusion=1.0;\n        hit.reflectivity = 0.0;\n        return;\n    }\n    \n    calcNormal( hit, time );\n\n    switch (hit.materialId) {\n\t\tcase MAT_NORMAL:\n        hit.reflectivity = 0.5;\n        //hit.albedo=(hit.normal*0.5+0.5) * pow(clamp(-dot(hit.incidence,hit.normal),0.0,1.0),20.0);\n        hit.albedo=(hit.normal*0.5+0.5) * 0.2+pow(clamp(-dot(hit.incidence,hit.normal),0.0,1.0),20.0)*0.8;\n        //hit.albedo=vec3(pow(clamp(-dot(hit.incidence,hit.normal),0.0,1.0),20.0));\n        //hit.shininess = 10.0;\n        break;\n    }\n\n   \thit.diffuse = White;\n   \thit.specular = Black;\n}*/\n/*\nvec3 realRenderRay(inout rayMarch ray, inout camera camera, in vec2 fragCoord, in vec2 uv, in float time) {\n    \n    vec3 colour;\n    \n    rayHit mainHit = RayMarch(ray, 0.0, 0, time);\n    renderRay(mainHit, camera, fragCoord, uv, time);\n    colour = mainHit.albedo;//*mainHit.diffuse;//*mainHit.occlusion;\n    //colour+=mainHit.specular;  \n    \n    return colour;\n}\n*/\n// ========== ==========\n\n// ========== Tone Mapping ==========\n\nfloat gamma =1.2;\n\nvec3 toneMaping(vec3 colour)\n{\n    //colour *= 1.75;\n\tcolour = pow(colour, vec3(1.0 / gamma));\n    colour=clamp(colour,0.0,1.0);\n\treturn colour;\n}\n\n// ========== ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime+91.0;\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float seed = iDate.x+iDate.y+iDate.z;\n    float angle = atan(uv.x,uv.y);\n\tfloat ring = ((time-length(uv)*0.5)*0.1);\n    ring = ring + \n        sin((time*5.0)+(angle*5.0))*\n        sin((time*5.0)-(angle*7.0))*\n        sin((time*7.0)+(angle*11.0))*\n        sin((time*7.0)-(angle*13.0))*\n        (length(uv)*0.01);\n    randSeed01 = hash44(hash41(seed+floor(ring)));\n    randSeed02 = hash44(randSeed01);\n    randSeed03 = hash44(randSeed02);\n    randSeed04 = hash44(randSeed03);\n    \n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(time*0.01,sin(time*0.1)*0.05);\n    }\n    \n    camera camera = getCamera(mouse, time);\n\n    //rayMarch mainRay = getRay(uv, camera);\n    //vec3 colour = realRenderRay(mainRay, camera, fragCoord, uv, time);\n    vec3 colour = getStarField(camera, fragCoord, uv, time);\n    \n    \n    // - just the fancy warp thing...\n    float dx = 0.001 + abs(fract(ring+0.002));\n    float x = clamp(abs(map(fract(ring-dx),1.0-dx*2.0,1.0,-1.0,1.0)),0.0,1.0);\n    x = clamp((x + sin((time*3.0)+(angle*3.0))*sin((time*3.0)-(angle*5.0)) * (1.0-x)) * 1.2,0.0,1.0);\n    //x=clamp(x*1.2,0.0,1.0);\n\tvec3 c = mix(White,Blue,x)*2.0;\n    c = mix(c,colour,x);\n    colour = mix(c,colour,pow(clamp(1.0-length(uv),0.0,1.0),4.0));\n    colour = toneMaping(colour);\n    \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*10.0,0.2)+0.4,0.0,1.0);\n    colour=1.0-((1.0-colour)/vignette);\n    \n    fragColour = vec4(colour,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}