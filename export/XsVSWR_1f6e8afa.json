{"ver":"0.1","info":{"id":"XsVSWR","date":"1463788413","viewed":3721,"name":"HSV vs HSL","username":"MichaelPohoreski","description":"Instructions: Click and Drag mouse to change:\n* up/down to change the saturation (bottom = 0%, top = 100%)\n* left/right to change the lightness (left = 0%, right = 100%)\nLeft: HSV, Right: HSL","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["color","hsv","hsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// HSV vs HSL demo by Michael Pohoreski aka mysticreddit\n// https://www.shadertoy.com/view/XsVSWR\n// Version 3.6\n// Reddit Thread: https://www.reddit.com/r/gamedev/comments/4k8l33/using_an_hsl_shader_to_recolor_textures/\n\n// Original\nvec3 hsl2rgb(vec3 HSL)\n{\n   float R = abs(HSL.x * 6.0 - 3.0) - 1.0;\n   float G = 2.0 - abs(HSL.x * 6.0 - 2.0);\n   float B = 2.0 - abs(HSL.x * 6.0 - 4.0);\n   vec3 RGB = clamp(vec3(R,G,B), 0.0, 1.0);\n   float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n   return (RGB - 0.5) * C + HSL.z;\n}\n\n// References:\n// * http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// * http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n// Optimized by Michael Pohoreski\nvec3 hsv2rgb( vec3 c )\n{\n    vec3 K = vec3(3,2,1) / 3.0;\n    vec3 p = abs(fract(c.rrr + K.rgb) * 6.0 - vec3(3));\n    return c.b * mix(K.rrr, clamp(p - K.rrr, 0.0, 1.0), c.g);\n}\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 m  = iMouse.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float duration = 12.0; // seconds\n    float hue      = fract( iTime / duration );\n    float sat      = (iMouse.z < 0.5) ? 0.5 : m.y;\n    float val      = (iMouse.z < 0.5) ? 0.5 : m.x; \n\n    float h = 0.1; // status bar height\n    float w = 0.1; // side monochrome status bar\n\n    /* Remap saturation by clamping y to inside of borders\n\n       y        Sat\n       1     -> 1\n       1-2*h -> 1\n       :\n       h     -> 0\n       0     -> 0\n    */\n    float innerH = 1.0 - 2.0*h;\n    if( sat < (0.0 + h ))\n        sat = 0.;\n    else\n    if( sat > (1.0 - h ))\n        sat = 1.;\n    else\n        sat = (sat - h) / innerH;\n \n    // x = localized val\n    // y = localized sat\n    float y = clamp( uv.y - h, 0., 1.0 ) / innerH;;\n    float x = ( uv.x > 0.5 )\n        ? (uv.x - 0.5)*2.0  // normalize 0.5 .. 1.0 -> 0.0 .. 1.0\n        :  uv.x       *2.0; // normalize 0.0 .. 0.5 -> 0.0 .. 1.0\n\n    /*\n       Top 2 status bars\n         1.0  = Top of screen\n         top4 = y top of cursor\n         top2 = bottom of 2nd status bar\n         top3 = y bottom of cursor\n         top1 = bottom of 1st status bar\n              :\n         0.0  = Bottom of screen\n    */\n    float top1 = 1.0 - h;\n    float top2 = 1.0 - h*0.5;\n    float top3 = (top2 - h*0.25);\n    float top4 = (top2 + h*0.25);\n        \n    vec3 color;\n    vec3 zero3 = vec3( 0. );\n    \n    vec3 hsv1 = vec3( 1.0 - hue, 1., 1. ); \n    vec3 hueL = vec3( mod( hue + 1./3.0, 1.0 ), 1., 0.75 );\n    vec3 hueR = vec3( mod( hue + 2./3.0, 1.0 ), 1., 0.75 );\n    \n    vec3 hsv3 = vec3( hue, sat, val );\n    vec3 hsvR = 1.0 - hsv3;\n    \n    vec3 colorL = hsv2rgb( hsv3 );\n    vec3 colorR = hsl2rgb( hsv3 );\n    \n    // Cursor\n    float hueMono  = smoothstep( 0.006, 0.008, abs(x - hue) );\n    float satMono  = smoothstep( 0.006, 0.008, abs(y - sat) );\n    float valMono  = smoothstep( 0.006, 0.008, abs(x - val) );\n\n    vec3 cursorColorL = hsl2rgb( hueL );\n    vec3 cursorColorR = hsl2rgb( hueR );\n\n    if( uv.y > top1 ) // Top status bar\n    {\n        if( uv.x < 0.5 )\n        {\n            color = hsv2rgb( vec3( x, 1.0, 1.0 ) );\n\n            if (uv.y < top2)\n                color = hsv2rgb( vec3( x, sat, val ) );\n\n            if ((uv.y >= top3) &&  (uv.y <= top4))\n                color = mix( color, cursorColorL, 1.-hueMono ); // Cursor\n        }\n        else\n        {\n            color = hsl2rgb( vec3( x, 1.0, 0.5 ) );\n\n            if (uv.y < top2)\n                color = hsl2rgb( vec3( x, sat, val ) );\n\n            if ((uv.y >= top3) &&  (uv.y <= top4))\n                color = mix( color, cursorColorR, 1.-hueMono ); // Cursor\n        }\n\n    }\n    else\n    if (uv.y < h) // Bottom status bar\n    {\n        if (uv.y < h*0.5)\n        {\n            color = vec3( x ); \n\n            vec2 vFontSize = vec2(8.0, 15.0);\n            float fIsDigit2 = PrintValue( fragCoord, vec2( 0.,0. ), vFontSize, val, 5.0, 3.0);\n            color = mix( color, cursorColorL, fIsDigit2);\n\n            float fIsDigit3 = PrintValue( fragCoord, vec2( iResolution.x*0.5,0. ), vFontSize, sat, 5.0, 3.0);\n            color = mix( color, cursorColorR, fIsDigit3);\n        }\n        else\n        {\n            if( uv.x < 0.5 )\n            {\n                color = hsv2rgb( vec3( hue, sat, x ) );\n                color = mix( color, cursorColorL, 1.-valMono ); // Cursor\n            }\n            else\n            {\n                color = hsl2rgb( vec3( hue, sat, x ) );\n                color = mix( color, cursorColorR, 1.-valMono ); // Cursor\n            }\n        }\n    }\n    else\n    {\n        float x1 = (0.0 + w*0.5);\n        float x2 = (1.0 - w*0.5);\n        float x3 = (1.0 - w*0.25);\n        \n        if (uv.x < x1) // Left Status =  vertical gradient HSV,\n        {\n            float borderXleft = (x1 - 0.02*w);\n            \n            if( uv.x < 0.5*x1)\n                color = vec3( y ); \n            else    \n            if (uv.x > borderXleft )\n                color =  1.0 - vec3( val ); // vec3( 0 ); // cursorColorL;\n            else\n                color = mix( hsv2rgb( vec3( hue, y, val ) ), cursorColorL, 1.-satMono ); // Cursor satColor\n        }\n        else\n        if (uv.x > x2) // Right Status = vertical gradient HSL\n        {\n            float borderXright = (x2 + 0.02*w);\n            \n            if( uv.x > x3)\n                color = vec3( y ); \n            else\n            if (uv.x < borderXright)\n                color = 1.0 - vec3( val ); // vec3( 0 ); // cursorColorR;\n            else\n                color = mix( hsl2rgb( vec3( hue, y, val ) ), cursorColorR, 1.-satMono ); // Cursor: satColor\n        }\n        else\n        {\n            if (uv.x < 0.5) \n                color = colorL; // Left HSV\n            else \n                color = colorR; // Right HSL\n        }\n    }\n    \n    fragColor.rgb = color;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}