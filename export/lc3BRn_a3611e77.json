{"ver":"0.1","info":{"id":"lc3BRn","date":"1732738331","viewed":224,"name":"Improved 96-bit 8x12 Font ","username":"JoostAB","description":"See Common tab for the font library. Buffer A for usage.\nBuffer B adds some effects","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["text","font","digit","character","bits"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFork of \"96-bit 8x12 Font\" by Flyguy. https://shadertoy.com/view/Mt2GWD\nAdded some textmodes and improvements. \nAlso converted the font to integers, to make use of binary operations.\n\nStill WIP\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Fork of \"96-bit 8x12 Font\" by Flyguy. https://shadertoy.com/view/Mt2GWD\n// 2024-11-26 09:24:55\n\n// The font is 8x12 pixels. So scaling down actually means multiplying that.\n// E.g. a scale down of 2.0 means you get characters 16 pixels wide and 24 pixels high.\n#define DOWN_SCALE 2.0\n\n// The maximum number of digits to be shown when using the print_integer function \n#define MAX_INT_DIGITS 4\n\n// Several font effects. Assign these values to TEXT_MODE to have effect on the \n// text that follows.\n// These can be combined by simply adding them. \n// E.g. TEXT_MODE=UNDERLINE+GLOW results in glowing underlined text.\n\n#define NORMAL    0x00 \n#define INVERT    0x01 \n#define UNDERLINE 0x02 \n#define BLINVERT  0x04\n#define BLINK     0x08\n#define GLOW      0x10\n\n// Some shortcuts for simple text modes. Looks better when used in the text\n#define MODE_NORMAL    TEXT_MODE=NORMAL;\n#define MODE_INVERT    TEXT_MODE=INVERT;\n#define MODE_UNDERLINE TEXT_MODE=UNDERLINE;\n#define MODE_BLINVERT  TEXT_MODE=BLINVERT;\n#define MODE_BLINK     TEXT_MODE=BLINK;\n#define MODE_GLOW      TEXT_MODE=GLOW;\n\n// Adds or removes a textmode fromk the current mode\n#define INVERT_ON TEXT_MODE+=INVERT;\n#define INVERT_OFF TEXT_MODE-=INVERT;\n#define UNDERLINE_ON TEXT_MODE+=UNDERLINE;\n#define UNDERLINE_OFF TEXT_MODE-=UNDERLINE;\n#define BLINVERT_ON TEXT_MODE+=BLINVERT;\n#define BLINVERT_OFF TEXT_MODE-=BLINVERT;\n#define BLINK_ON TEXT_MODE+=BLINK;\n#define BLINK_OFF TEXT_MODE-=BLINK;\n#define GLOW_ON TEXT_MODE+=GLOW;\n#define GLOW_OFF TEXT_MODE-=GLOW;\n\n// Speed of blinking. Result is 1.0/BLINKRATE seconds\n#define BLINKRATE 2.0\n\n// The acitve text mode\nint TEXT_MODE = NORMAL;\n\n// Indentation of following lines\n// Next CR will return to this position\nint INDENT = 0;\n\n// Next character will be printed in this position\nvec2 print_pos = vec2(0);\n\nvec2 res = vec2(0);\nfloat itime = 0.0;\n\n// Size of the characters. Used in calculations so don't touch ;)\n#define CHAR_SIZE vec2(8, 12) \n\n#define CR print_pos.x=float(INDENT)*CHAR_SIZE.x; // Carriage Return\n#define LF print_pos.y-=CHAR_SIZE.y;              // Line feed\n#define CRLF CR;LF;                               // Carriage Return/Line feed\n#define LASTCOL (int(res.x/CHAR_SIZE.x)-1)        // Last visible column \n#define LASTLINE (int(res.y/CHAR_SIZE.y)-1)       // Last visible line\n\n// Sets the cursor at the specified column/line position\n#define setCursor(c,l) print_pos=charPos(c,l)     \n\n/*\nHow the font is defined:\n\nFor example, the ampersand &\n\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nch_amp ivec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n// Automatically generated from the 8x12 font sheet here:\n// http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n// and then turned into ivecs\n#define ch_spc ivec4(0x000000,0x000000,0x000000,0x000000)\n#define ch_exc ivec4(0x003078,0x787830,0x300030,0x300000)\n#define ch_quo ivec4(0x006666,0x662400,0x000000,0x000000)\n#define ch_hsh ivec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000)\n#define ch_dol ivec4(0x30307C,0xC0C078,0x0C0CF8,0x303000)\n#define ch_pct ivec4(0x000000,0xC4CC18,0x3060CC,0x8C0000)\n#define ch_amp ivec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n#define ch_apo ivec4(0x003030,0x306000,0x000000,0x000000)\n#define ch_lbr ivec4(0x000C18,0x306060,0x603018,0x0C0000)\n#define ch_rbr ivec4(0x006030,0x180C0C,0x0C1830,0x600000)\n#define ch_ast ivec4(0x000000,0x663CFF,0x3C6600,0x000000)\n#define ch_crs ivec4(0x000000,0x18187E,0x181800,0x000000)\n#define ch_com ivec4(0x000000,0x000000,0x000038,0x386000)\n#define ch_dsh ivec4(0x000000,0x0000FE,0x000000,0x000000)\n#define ch_per ivec4(0x000000,0x000000,0x000038,0x380000)\n#define ch_lsl ivec4(0x000002,0x060C18,0x3060C0,0x800000)\n//#define ch_0   ivec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000) // Orininal with filling\n#define ch_0  ivec4(0x007CC6,0xCEDEF6,0xE6C6C6,0x7C0000) // With diagonal line\n//#define ch_0   ivec4(0x007CC6,0xC6C6C6,0xC6C6C6,0x7C0000) // Empty 0\n#define ch_1   ivec4(0x001030,0xF03030,0x303030,0xFC0000)\n#define ch_2   ivec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000)\n#define ch_3   ivec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000)\n#define ch_4   ivec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000)\n#define ch_5   ivec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000)\n#define ch_6   ivec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000)\n#define ch_7   ivec4(0x00FEC6,0xC6060C,0x183030,0x300000)\n#define ch_8   ivec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000)\n#define ch_9   ivec4(0x0078CC,0xCCCC7C,0x181830,0x700000)\n#define ch_col ivec4(0x000000,0x383800,0x003838,0x000000)\n#define ch_scl ivec4(0x000000,0x383800,0x003838,0x183000)\n#define ch_les ivec4(0x000C18,0x3060C0,0x603018,0x0C0000)\n#define ch_equ ivec4(0x000000,0x007E00,0x7E0000,0x000000)\n#define ch_grt ivec4(0x006030,0x180C06,0x0C1830,0x600000)\n#define ch_que ivec4(0x0078CC,0x0C1830,0x300030,0x300000)\n#define ch_ats ivec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000)\n#define ch_A   ivec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000)\n#define ch_B   ivec4(0x00FC66,0x66667C,0x666666,0xFC0000)\n#define ch_C   ivec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000)\n#define ch_D   ivec4(0x00F86C,0x666666,0x66666C,0xF80000)\n#define ch_E   ivec4(0x00FE62,0x60647C,0x646062,0xFE0000)\n#define ch_F   ivec4(0x00FE66,0x62647C,0x646060,0xF00000)\n#define ch_G   ivec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000)\n#define ch_H   ivec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000)\n#define ch_I   ivec4(0x007830,0x303030,0x303030,0x780000)\n#define ch_J   ivec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000)\n#define ch_K   ivec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000)\n#define ch_L   ivec4(0x00F060,0x606060,0x626666,0xFE0000)\n#define ch_M   ivec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000)\n#define ch_N   ivec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000)\n#define ch_O   ivec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000)\n#define ch_P   ivec4(0x00FC66,0x66667C,0x606060,0xF00000)\n#define ch_Q   ivec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00)\n#define ch_R   ivec4(0x00FC66,0x66667C,0x6C6666,0xE60000)\n#define ch_S   ivec4(0x0078CC,0xCCC070,0x18CCCC,0x780000)\n#define ch_T   ivec4(0x00FCB4,0x303030,0x303030,0x780000)\n#define ch_U   ivec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000)\n#define ch_V   ivec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000)\n#define ch_W   ivec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000)\n#define ch_X   ivec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000)\n#define ch_Y   ivec4(0x00CCCC,0xCCCC78,0x303030,0x780000)\n#define ch_Z   ivec4(0x00FECE,0x981830,0x6062C6,0xFE0000)\n#define ch_lsb ivec4(0x003C30,0x303030,0x303030,0x3C0000)\n#define ch_rsl ivec4(0x000080,0xC06030,0x180C06,0x020000)\n#define ch_rsb ivec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000)\n#define ch_pow ivec4(0x10386C,0xC60000,0x000000,0x000000)\n#define ch_usc ivec4(0x000000,0x000000,0x000000,0x00FF00)\n#define ch_a   ivec4(0x000000,0x00780C,0x7CCCCC,0x760000)\n#define ch_b   ivec4(0x00E060,0x607C66,0x666666,0xDC0000)\n#define ch_c   ivec4(0x000000,0x0078CC,0xC0C0CC,0x780000)\n#define ch_d   ivec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000)\n#define ch_e   ivec4(0x000000,0x0078CC,0xFCC0CC,0x780000)\n#define ch_f   ivec4(0x00386C,0x6060F8,0x606060,0xF00000)\n#define ch_g   ivec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78)\n#define ch_h   ivec4(0x00E060,0x606C76,0x666666,0xE60000)\n#define ch_i   ivec4(0x001818,0x007818,0x181818,0x7E0000)\n#define ch_j   ivec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78)\n#define ch_k   ivec4(0x00E060,0x60666C,0x786C66,0xE60000)\n#define ch_l   ivec4(0x007818,0x181818,0x181818,0x7E0000)\n#define ch_m   ivec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000)\n#define ch_n   ivec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000)\n#define ch_o   ivec4(0x000000,0x0078CC,0xCCCCCC,0x780000)\n#define ch_p   ivec4(0x000000,0x00DC66,0x666666,0x7C60F0)\n#define ch_q   ivec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E)\n#define ch_r   ivec4(0x000000,0x00EC6E,0x766060,0xF00000)\n#define ch_s   ivec4(0x000000,0x0078CC,0x6018CC,0x780000)\n#define ch_t   ivec4(0x000020,0x60FC60,0x60606C,0x380000)\n#define ch_u   ivec4(0x000000,0x00CCCC,0xCCCCCC,0x760000)\n#define ch_v   ivec4(0x000000,0x00CCCC,0xCCCC78,0x300000)\n#define ch_w   ivec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000)\n#define ch_x   ivec4(0x000000,0x00C66C,0x38386C,0xC60000)\n#define ch_y   ivec4(0x000000,0x006666,0x66663C,0x0C18F0)\n#define ch_z   ivec4(0x000000,0x00FC8C,0x1860C4,0xFC0000)\n#define ch_lpa ivec4(0x001C30,0x3060C0,0x603030,0x1C0000)\n#define ch_bar ivec4(0x001818,0x181800,0x181818,0x180000)\n#define ch_rpa ivec4(0x00E030,0x30180C,0x183030,0xE00000)\n#define ch_tid ivec4(0x0073DA,0xCE0000,0x000000,0x000000)\n#define ch_lar ivec4(0x000000,0x10386C,0xC6C6FE,0x000000)\n\n\n// _Some shortcuts to make life easier. \n// To write 'My string' just do: _M _y _  _s _t _r _i _n _g\n// Just make sure that the variables 'col' and 'uv' are in scope.\n#define _spc col+=char(ch_spc,uv);\n#define _ _spc // Just because I'm lazy ;)\n#define _exc col+=char(ch_exc,uv);\n#define _quo col+=char(ch_quo,uv);\n#define _hsh col+=char(ch_hsh,uv);\n#define _dol col+=char(ch_dol,uv);\n#define _pct col+=char(ch_pct,uv);\n#define _amp col+=char(ch_amp,uv);\n#define _apo col+=char(ch_apo,uv);\n#define _lbr col+=char(ch_lbr,uv);\n#define _rbr col+=char(ch_rbr,uv);\n#define _ast col+=char(ch_ast,uv);\n#define _crs col+=char(ch_crs,uv);\n#define _com col+=char(ch_com,uv);\n#define _dsh col+=char(ch_dsh,uv);\n#define _per col+=char(ch_per,uv);\n#define _lsl col+=char(ch_lsl,uv);\n#define _0   col+=char(ch_0  ,uv);\n#define _1   col+=char(ch_1  ,uv);\n#define _2   col+=char(ch_2  ,uv);\n#define _3   col+=char(ch_3  ,uv);\n#define _4   col+=char(ch_4  ,uv);\n#define _5   col+=char(ch_5  ,uv);\n#define _6   col+=char(ch_6  ,uv);\n#define _7   col+=char(ch_7  ,uv);\n#define _8   col+=char(ch_8  ,uv);\n#define _9   col+=char(ch_9  ,uv);\n#define _col col+=char(ch_col,uv);\n#define _scl col+=char(ch_scl,uv);\n#define _les col+=char(ch_les,uv);\n#define _equ col+=char(ch_equ,uv);\n#define _grt col+=char(ch_grt,uv);\n#define _que col+=char(ch_que,uv);\n#define _ats col+=char(ch_ats,uv);\n#define _A   col+=char(ch_A  ,uv);\n#define _B   col+=char(ch_B  ,uv);\n#define _C   col+=char(ch_C  ,uv);\n#define _D   col+=char(ch_D  ,uv);\n#define _E   col+=char(ch_E  ,uv);\n#define _F   col+=char(ch_F  ,uv);\n#define _G   col+=char(ch_G  ,uv);\n#define _H   col+=char(ch_H  ,uv);\n#define _I   col+=char(ch_I  ,uv);\n#define _J   col+=char(ch_J  ,uv);\n#define _K   col+=char(ch_K  ,uv);\n#define _L   col+=char(ch_L  ,uv);\n#define _M   col+=char(ch_M  ,uv);\n#define _N   col+=char(ch_N  ,uv);\n#define _O   col+=char(ch_O  ,uv);\n#define _P   col+=char(ch_P  ,uv);\n#define _Q   col+=char(ch_Q  ,uv);\n#define _R   col+=char(ch_R  ,uv);\n#define _S   col+=char(ch_S  ,uv);\n#define _T   col+=char(ch_T  ,uv);\n#define _U   col+=char(ch_U  ,uv);\n#define _V   col+=char(ch_V  ,uv);\n#define _W   col+=char(ch_W  ,uv);\n#define _X   col+=char(ch_X  ,uv);\n#define _Y   col+=char(ch_Y  ,uv);\n#define _Z   col+=char(ch_Z  ,uv);\n#define _lsb col+=char(ch_lsb,uv);\n#define _rel col+=char(ch_rsl,uv);\n#define _rsb col+=char(ch_rsb,uv);\n#define _pow col+=char(ch_pow,uv);\n#define _usc col+=char(ch_usc,uv);\n#define _a   col+=char(ch_a  ,uv);\n#define _b   col+=char(ch_b  ,uv);\n#define _c   col+=char(ch_c  ,uv);\n#define _d   col+=char(ch_d  ,uv);\n#define _e   col+=char(ch_e  ,uv);\n#define _f   col+=char(ch_f  ,uv);\n#define _g   col+=char(ch_g  ,uv);\n#define _h   col+=char(ch_h  ,uv);\n#define _i   col+=char(ch_i  ,uv);\n#define _j   col+=char(ch_j  ,uv);\n#define _k   col+=char(ch_k  ,uv);\n#define _l   col+=char(ch_l  ,uv);\n#define _m   col+=char(ch_m  ,uv);\n#define _n   col+=char(ch_n  ,uv);\n#define _o   col+=char(ch_o  ,uv);\n#define _p   col+=char(ch_p  ,uv);\n#define _q   col+=char(ch_q  ,uv);\n#define _r   col+=char(ch_r  ,uv);\n#define _s   col+=char(ch_s  ,uv);\n#define _t   col+=char(ch_t  ,uv);\n#define _u   col+=char(ch_u  ,uv);\n#define _v   col+=char(ch_v  ,uv);\n#define _w   col+=char(ch_w  ,uv);\n#define _x   col+=char(ch_x  ,uv);\n#define _y   col+=char(ch_y  ,uv);\n#define _z   col+=char(ch_z  ,uv);\n#define _lpa col+=char(ch_lpa,uv);\n#define _bar col+=char(ch_bar,uv);\n#define _rpa col+=char(ch_rpa,uv);\n#define _tid col+=char(ch_tid,uv);\n#define _lar col+=char(ch_lar,uv);\n\n// Shortcuts to print numbers\n#define INT(i,d) col+=print_integer(i,d,uv); \n#define NUM(n,d) col+=print_number(n,d,uv); \n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nint extract_bit(int n, int b) {\n    return (n >> clamp(b,-1,24)) & 1;\n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(ivec4 spr, vec2 size, vec2 uv) {\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    int bit = int((size.x-uv.x-1.0) + uv.y * size.x);\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    int pixels = 0;\n\n    if (bounds) {\n        pixels += extract_bit(spr.x, bit - 72);\n        pixels += extract_bit(spr.y, bit - 48);\n        pixels += extract_bit(spr.z, bit - 24);\n        pixels += extract_bit(spr.w, bit - 00);\n    }\n    \n    return float(pixels);\n\n}\n\nvec2 charPos(int col, int line) {\n    vec2 cp = vec2(0.0);\n    cp.x = float(col + INDENT)*CHAR_SIZE.x;\n    cp.y = res.y - (float(line+1)*CHAR_SIZE.y);\n    return cp;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(ivec4 ch, vec2 uv) {\n    bool inv = (TEXT_MODE&INVERT)>0;\n\n    if ((TEXT_MODE & UNDERLINE) > 0) {\n        ch.w = (ch.w/256)*256 + 255;  \n    }\n    \n    if ((TEXT_MODE & BLINVERT)>0) {\n        if (mod(floor(itime*BLINKRATE),2.)==0.0) {\n            inv = !inv;\n        }\n    }\n    \n    if (inv) {\n        ch = 0xFFFFFF-ch;\n    }\n    \n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    \n    if ((TEXT_MODE & GLOW)>0) {\n        px *= 2.0;\n    }\n    \n    if ((TEXT_MODE & BLINK)>0) {\n        if (mod(floor(itime*BLINKRATE),2.)==0.0) {\n            px = 0.0;\n        }\n    }\n    \n    print_pos.x += CHAR_SIZE.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nivec4 get_digit(int d) {\n    if(d == 0) return ch_0;\n    if(d == 1) return ch_1;\n    if(d == 2) return ch_2;\n    if(d == 3) return ch_3;\n    if(d == 4) return ch_4;\n    if(d == 5) return ch_5;\n    if(d == 6) return ch_6;\n    if(d == 7) return ch_7;\n    if(d == 8) return ch_8;\n    if(d == 9) return ch_9;\n    return ch_spc;\n}\n\n//Prints out the given float number starting at pos with up to \n// the specified number of decimals.\nfloat print_number(float number, int decimals, vec2 uv) {\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -decimals;i--) {\n        int digit = int(mod( number / pow(10.0, float(i)) , 10.0));\n        \n        if(i == -1) {\n            //Add a decimal point.\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) {\n            //Clip off leading zeros.\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n// Prints an integer number, up to MAX_INT_DIGITS digits.\n// The zeros argument determines the maximum leading zeros\nfloat print_integer(float number, int zeros, vec2 uv) {\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS; i >= 0; i--) {\n        int digit = int(mod( number / pow(10.0, float(i)) , 10.0));\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) {\n            //Clip off leading zeros.\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n// Overloaded print_integer to accept integers\nfloat print_integer(int number, int zeros, vec2 uv) {\n    return print_integer(float(number),zeros,uv) ;\n}\n\n// Initializes the res and itime variables, and returnes a scaled uv vector\nvec2 initFont(vec3 resolution, vec2 fragCoord, float time) {\n    res = resolution.xy / DOWN_SCALE;\n    itime = time;\n    vec2 uv = fragCoord.xy / DOWN_SCALE;\n    return uv;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float text(vec2 uv) {\n    float col = 0.0; // Used in character macros\n    \n    /* Credits */\n    TEXT_MODE = NORMAL;\n    print_pos = charPos(LASTCOL-18,LASTLINE-1);\n    \n    _I _n _s _p _i _r _e _d _ _b _y _ GLOW_ON _F _l _y _g _u _y GLOW_OFF\n    \n    TEXT_MODE = NORMAL;\n    print_pos = charPos(LASTCOL-18,LASTLINE);\n    \n    _E _x _t _e _n _d _e _d _ _b _y _ GLOW_ON _J _o _o _s _t _A _B GLOW_OFF\n    \n    /* Modes */\n    INDENT = 0;\n        \n    TEXT_MODE = NORMAL;\n    setCursor(0,0);\n    \n    _M _o _d _e _s _col _\n    \n    INDENT = 7;\n   \n    _N _o _r _m _a _l\n    \n    CRLF\n    \n    UNDERLINE_ON _U _n _d _e _r _l _i _n _e UNDERLINE_OFF\n\n    CRLF\n    \n    BLINK_ON _B _l _i _n _k BLINK_OFF\n    \n    CRLF\n    \n    INVERT_ON _I _n _v _e _r _t INVERT_OFF\n    \n    CRLF\n    \n    BLINVERT_ON _B _l _i _n _v _e _r _t BLINVERT_OFF\n    \n    CRLF\n    \n    GLOW_ON _G _l _o _w GLOW_OFF\n    \n    /* Title */\n    INDENT = 0;\n    setCursor((LASTCOL/2)-8,LASTLINE/2);\n    \n    GLOW_ON UNDERLINE_ON _9 _6 _ _b _i _t _ _8 _x _1 _2 _ _F _o _n _t GLOW_OFF UNDERLINE_OFF\n    \n    /* Demo text */\n    setCursor((LASTCOL/2)-22,(LASTLINE/2)+2);\n    \n    MODE_NORMAL\n    _T _h _e _ _q _u _i _c _k _ _b _r _o _w _n _ _f _o _x _\n    _j _u _m _p _s _  _o _v _e _r _  _t _h _e _  _l _a _z _y _  _d _o _g _per\n    \n    /* Clock */\n    float hour = floor(iDate.w/60.0/60.0);\n    float minute = floor(mod(iDate.w/60.0,60.0));\n    float second = floor(mod(iDate.w,60.0));\n    \n    print_pos = charPos(LASTCOL-18,0);\n    INT(iDate.z,2) _lsl INT(iDate.y+1.0,2) _lsl INT(iDate.x,4) _\n    INT(hour,2) _col INT(minute,2) _col INT(second,2)\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = initFont(iResolution, fragCoord, iTime);\n    \n    // Get state of current pixel\n\tfloat pixel = text(floor(uv));\n    \n    // Create the character pixels\n    vec3 col = vec3(1.0) * mix(vec3(0.2),vec3(0,1,0),pixel);\n    \n\tfragColor = vec4(vec3(col), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nSome effects to make life more beautiful!\n*/\n//#define EFF_GRID\n#define EFF_SCAN\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    #ifdef EFF_GRID\n        // Add a small grid\n        vec2 uv = fragCoord.xy / DOWN_SCALE;\n        col *= (1.-distance(mod(uv,vec2(1.0)),vec2(0.65)))*1.2;\n    #endif\n    \n    #ifdef EFF_SCAN\n        // Add scanlines, but only if DOWN_SCALE is a whole number and > 1.0\n        if (DOWN_SCALE > 1.0 && (floor(DOWN_SCALE) == DOWN_SCALE)) {\n            col -= mod(fragCoord.y, 2.0) < 1.0 ? 0.5 : 0.0;\n        }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}