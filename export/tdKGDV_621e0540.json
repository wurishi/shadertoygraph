{"ver":"0.1","info":{"id":"tdKGDV","date":"1571015850","viewed":577,"name":"Texture Mapping, Integration","username":"Veggiebob","description":"Mapping a texture onto a curve using integration. Slow, but it works","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["texture","integration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 0.001;\nconst float STEP = 0.003;\n//not exact but works for all surfaces\nvec2 rotate2D (vec2 v, float b) {\n\treturn vec2(\n\t\tv.y*cos(b)+v.x*sin(b),\n\t\tv.x*cos(b)-v.y*sin(b)\n\t);\n}\nvec2 getTexPos (vec3 p, vec3 n) {\n    //return sqrt(sq(p.xz*n.y) + sq(p.xy*n.z) + sq(p.yz*n.x));\n    return ((p.xz*n.y) + (p.xy*n.z) + (p.yz*n.x));\n}\nfloat sq (float x) {\n\treturn x*x;\n}\nfloat y (vec2 p) {\n    return 0.3 * sin((p.x+0.1*cos(p.y*8.+iTime*0.1))*6.) * sin(p.y*6. + iTime*0.1);\n    //return \n        //0.1*\n        //sin(p.y*10.*(1.+cos(iTime)*0.0)+iTime*0.1) *\n        //(1.+cos(p.x*10. + iTime*0.1)*1.5);\n}\nfloat dydx (vec2 p) {\n\treturn (y(vec2(epsilon,0.)+p)-y(vec2(-epsilon,0.)+p))/epsilon/2.;\n}\nfloat dydz (vec2 p) {\n\treturn (y(vec2(epsilon,0.).yx+p)-y(vec2(-epsilon,0.).yx+p))/epsilon/2.;\n}\nfloat iydx (vec2 p) {\n\t// brute force :(\n\tfloat x = 0.;\n    float ry = p.y;\n    for(float i = 0.; i<p.x; i+=STEP) {\n\t\tx += STEP*sqrt(1.+sq(dydx(vec2(i, ry))));\n    \try += STEP*sqrt(1.+sq(dydz(vec2(i, ry))));\n    }\n\treturn x;\n}\nfloat iydz (vec2 p) {\n\tfloat x = 0.;\n    float rx = p.x;\n    for(float i = 0.; i<p.y; i+=STEP) {\n\t\tx += STEP*sqrt(1.+sq(dydz(vec2(rx, i))));\n    \trx += STEP*sqrt(1.+sq(dydx(vec2(rx, i))));\n    }\n\treturn x;\n}\nvec2 iy (vec2 p) {\n\treturn vec2(\n        iydx(p), \n        iydz(p)\n   \t);\n}\nvec3 getNormal (vec2 p) {\n    return normalize(\n        cross(\n            vec3(\n                epsilon,\n                0.,\n                y(vec2(p.x+epsilon, p.y))-y(p)\n            ),\n            vec3(\n                0.,\n                epsilon,\n                y(vec2(p.x, p.y+epsilon))-y(p)\n            )\n       \t)\n    );\n}\nvec3 contrast (vec3 hi, float n) {\n    return 0.5+(hi-0.5)*n;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 pos = vec3(uv.xy, y(uv));\n    vec3 normal = getNormal(uv);\n    vec3 look = normalize(vec3(\n    \t0.1,\n    \t0.0,\n    \t0.1\n    ));\n    //look.xz = rotate2D(look.xz, mouse.x*5.);\n    \t//normalize(vec3( (g.yz), 1.));\n    float diffuse = max(dot(look, normal), 0.);\n    vec3 refl = reflect(look, normal);\n    float specular = pow(dot(refl, look), 4.);\n    vec2 tp = getTexPos(pos, normal);\n    tp = iy(uv)*vec2(0.2, 0.2) * 8.0;\n    vec3 col = texture(iChannel0, tp).rgb;\n    col = contrast(col, sqrt(1.-specular));\n    col += 0.1;\n    vec3 back = texture(iChannel1, refl).rgb;\n    col *= (specular * 0.5 + diffuse * 0.8) * (vec3(1.5)*contrast(back, 0.2));\n   \t//col *= pos.zzz*0.5+0.5;\n\t\t//col = vec3(tp.xy, pos.z);\n    // Output to screen\n   \tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}