{"ver":"0.1","info":{"id":"ttXyWM","date":"1592186087","viewed":75,"name":"mandelbrot-deformado","username":"jorge2017a1","description":"mandelbrot-deformado","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrotdeformado"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n#define SCALE 7.5 // plot scale\n\n//hecho por jorge flores p.....23/jun-2019\n\n\n#define COLOR_FREQ 0.5 // Change to 1.0 to get more interesting color patterns in deep zooms\n#define COLOR_SHIFT 0.\n\nstruct complex\n{\n    float re;\n    float im;\n}; \n\nconst float M_PI = 3.14159265359;\n\n\n\n///-------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n///-------------------------------------\n\ncomplex complex_set(float re , float im)\n{\n\tcomplex cout;\n    cout.re = re;\n    cout.im = im;\n    return cout;\n}\n    \n\ncomplex complex_neg(complex p) \n{\n    complex cout;\n    cout.re = -p.re;\n    cout.im = -p.im;\n    return cout;\n}\n   \n\ncomplex complex_add(complex c1 , complex c2) \n{\n\t\n    complex cout;\n    cout.re = c1.re + c2.re;\n    cout.im = c1.im + c2.im;\n    return cout;\n}    \n\n\n\ncomplex complex_multiply(complex a, complex b) \n{\n    complex cout;\n\tcout.re= a.re * b.re - a.im * b.im;\n    cout.im =a.im * b.re + a.re * b.im;\n    return cout;\n}\n\n/** Square a complex number. */\ncomplex complex_square(complex a) \n{\n    return complex_multiply(a, a);\n}\n\n\ncomplex complex_sub(complex  c1 ,complex  c2) \n{\n    complex cout;\n\n    cout.re = c1.re - c2.re;\n    cout.im = c1.im - c2.im;\n    return  cout;\n}\n\n\n\n\n/*vec2 cmpxpow(in vec2 c, int p) {\n    vec2 orig = c;\n\tfor (int i = 0; i < p-1; ++i) {\n\t\tc = cmpxmul(c, orig);\n\t}\n    return c;\n}\n*/\n\n\nfloat complex_mag(complex c)\n{\n    \n    return sqrt(c.re * c.re + c.im * c.im);\n}\n\n\n\ncomplex complex_exp(complex z) \n{\n    complex tmp;\n    complex cout;\n    tmp.re= cos(z.im);\n    tmp.im= sin(z.im);\n    \n    cout.re=exp(z.re)*tmp.re;\n    cout.im=exp(z.re)*tmp.im;\n    \n    \n    return cout;\n}\n\n\n\nfloat complex_norm(complex c )\n{\n\tfloat result ;\n    \n    result = c.re * c.re + c.im * c.im;\n        \n    return  result;\n}\n    \n\ncomplex complex_pow(complex a, float b) \n{\n    float r = complex_mag(a);\n    float theta = atan(a.im, a.re);\n    complex tmp;\n    \n    tmp.re=b * log(r);\n    tmp.im=b *  theta;\n    \n    return complex_exp(tmp);\n    \n}\n\nvec3 getColor(float v)\n{\n    \n    \n    vec3 col = vec3(0.1) * sin(v);\n    col = mix(col, vec3(0.1, 0.2, 0.4), sin(1.-v));\n    col = mix(col, vec3(0.1, 0.2, 0.7), pow(sin(1.-v),2.));\n    \n\t\n    float a = 1.;\n    float b = 0.2357022603955158;  // 1/3*sqrt(2)\n    float c = 0.12452650612453368; // 1/7*3^(1/8)\n    vec3 col2= vec3((1.-cos(a*v))*0.5, (1.-cos(b*v))*0.5, (1.-cos(c*v))*0.5);\n    return col+col2;\n\n}\n\n\n\n// https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_(smooth)_coloring\n\nfloat smooth_color(vec2 z, int n) \n{\n    //return float(n) + 1. - log2(log2(length(z)));\n    return float(n) + 2. - log2(log2(dot(z, z)));\n}\n\n\n// Colormap is matplotlib.cm.twilight: https://matplotlib.org/tutorials/colors/colormaps.html\nvec3[] colors = vec3[] (\n    vec3(0.88575016, 0.85000925, 0.88797365),\n    vec3(0.76751109, 0.80980076, 0.83252817),\n    vec3(0.58301487, 0.70958888, 0.77925782),\n    vec3(0.44802471, 0.59238331, 0.75574176),\n    vec3(0.38407269, 0.46139019, 0.73094665),\n    vec3(0.36987980, 0.31638410, 0.67703755),\n    vec3(0.35060304, 0.16595130, 0.56147965),\n    vec3(0.27008638, 0.07548368, 0.36056376),\n    vec3(0.18488036, 0.07942573, 0.21307652),\n    vec3(0.29128515, 0.07489905, 0.25755102),\n    vec3(0.45383005, 0.11622184, 0.30970441),\n    vec3(0.59659918, 0.20721296, 0.31258523),\n    vec3(0.69806082, 0.33828976, 0.32207479),\n    vec3(0.76257334, 0.48718907, 0.38675335),\n    vec3(0.80029415, 0.64098213, 0.53730535),\n    vec3(0.84892246, 0.77992021, 0.74663719)\n);\n\nconst int N = colors.length();\n\nvec3 colormap(float v) {\n    float i = clamp(v, 0., 1.)*float(N);\n    int i0 = int(i) % N;\n    int i1 = (i0+1) % N;\n    float f = fract(i);\n    return mix(colors[i0], colors[i1], f);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 zcord = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\t\n    zcord*=(0.125+2.5*cos(.12), 2.0*cos(iTime*0.5));\n    \n    \n    zcord.y=zcord.y-1.0;\n    \n    float n = 0.;\n    \n    complex zc,cc;\n    \n    \n    zcord *= SCALE*0.12345;\n    \n    \n    cc.re = zcord.x;\n   cc.im = zcord.y;\n    \n    vec3 p=vec3(uv,1.0);\n\n    for( ; n<150. && complex_norm(zc)<100.0; n++ )\n    {\n        \n        float sd1= sdBox(p- vec3(0.0,0.5,0.0) , vec3(1.0) );\n        \n        float sd2 =sdSphere(p-vec3(0.0,0.5,0.0), 1.0 );\n        cc.re+=sd1;\n        cc.im+=sd2;\n        \n        \n        \n        zc =complex_add(complex_pow(zc, 2.0), cc);\n        \n\t}    \n    \n    vec2 tmp2= vec2(zc.re, zc.im);\n    float tmp= smooth_color( tmp2, int( n));\n    float val = log(max(tmp, 1.));\n    vec3 col  =colormap(fract(val*COLOR_FREQ + COLOR_SHIFT));\n    vec3 col2= getColor(n*1.0);\n   col=col*col2;\n    col =pow(col, vec3(0.542));\n    fragColor = vec4(col,1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}