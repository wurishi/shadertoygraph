{"ver":"0.1","info":{"id":"NdXfRs","date":"1645527738","viewed":134,"name":"Alphago Master VS 柯洁(KeJie)","username":"qubailiang00","description":"Facing the more powerful Alphago Master, 柯洁(KeJie) shows the strongest level of human beings(in the first 100 moves)\n\nYou can close \"#define startPieces\" and play chess by yourself (the fourth line in BufferA)\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","sdf","chess","alphago"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#iChannel0 \"file://ShaderToyBufferA.glsl\"\n\n#define exposure 1.0\n\nvec3 aces(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3((f.x < value) ? 1.0 : 0.0, (f.y < value) ? 1.0 : 0.0, (f.z < value) ? 1.0 : 0.0);\n}\n\nvec3 srgbToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(pow(((rgb + 0.055) / 1.055), vec3(2.4)), rgb / 12.92, LessThan(rgb, 0.04045));\n}\n\nvec3 linearToSrgb(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055, rgb * 12.92, LessThan(rgb, 0.0031308));\n}\n\n\nvec3 schlickFresnel(vec3 f0, float LoH) {\n\n\tfloat tmp = 1.0 - clamp(LoH, 0.0, 1.0);\n\tfloat tmp2 = tmp * tmp;\n\tfloat Fc = tmp2 * tmp2 * tmp;\n\treturn f0 * (1.0 - Fc) + vec3(1.0) * Fc;\n}\n\nfloat ggxTerm(float NoH, float a) {\n\n\tfloat a2 = a * a;\n\tfloat t = 1.0 + (a2 - 1.0) * NoH * NoH;\n\treturn a2 / (PI * (t * t));\n}\n\nfloat smithG_GGX(float NoV, float alphaG) {\n\n\tfloat a = alphaG * alphaG;\n\tfloat b = NoV * NoV;\n\treturn 1.0 / (NoV + sqrt(a + b - a * b) + 0.0001);\n}\n\nfloat SmithJointGGXVisibilityTerm (float NoL, float NoV, float roughness) {\n\n    float a = roughness;\n    float lambdaV = NoL * (NoV * (1.0 - a) + a);\n    float lambdaL = NoV * (NoL * (1.0 - a) + a);\n    return 0.5 / (lambdaV + lambdaL);\n}\n\nuint wang_hash(inout uint seed) {\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat randomFloat01(inout uint state) {\n\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\nMarchingInfo sdfScene(inout Ray ray) {\n\n    vec3 pos = ray.ro + ray.rd * ray.t;\n    vec3 coord = floor(pos);\n    pos.xz = pos.xz - coord.xz - vec2(0.5);\n    pos.y -= _dimsY;\n    return sdfScene(iChannel0, iResolution, pos, coord, iTime);\n}\n\nvec3 calcNormal(in Ray ray) {\n    \n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.00025;\n    //vec3 v[4] = vec3[](e.xyy, e.yyx, e.yxy, e.xxx);\n\n    Ray r = ray;\n    vec3 res = vec3(0.0);\n    // for(int i = 0; i < 4; i++) {\n\n    //     r.ro = ray.ro + v[i] * eps;\n    //     res += sdfScene(r).hit * v[i];\n    // }\n\n    {\n        r.ro = ray.ro + e.xyy * eps;\n        res += sdfScene(r).hit * e.xyy;\n    }\n\n    {\n        r.ro = ray.ro + e.yyx * eps;\n        res += sdfScene(r).hit * e.yyx;\n    }\n    \n    {\n        r.ro = ray.ro + e.yxy * eps;\n        res += sdfScene(r).hit * e.yxy;\n    }\n    \n    {\n        r.ro = ray.ro + e.xxx * eps;\n        res += sdfScene(r).hit * e.xxx;\n    }\n\n\n    return normalize(res);\n}\n\n\nHitSurfInfo intersect(inout Ray ray, sampler2D channel, vec3 resolution, float time) {\n\n    HitSurfInfo info = intersectPure(ray, channel, resolution, time);\n    info.geoInfo.normal = calcNormal(ray);\n    return info;\n}\n\nvec3 diffuseBRDF(Material material, vec3 fresnel) {\n\n    return material.albedo * (1.0 - fresnel) / PI;\n}\n\nvec3 specularBRDF(Material material, vec3 H, vec3 V, vec3 N, float NoL, float NoV, vec3 fresnel) {\n\n\tfloat NoH = abs(dot(N, H));\n\tfloat VoH = abs(dot(V, H));\n\tfloat a = material.roughness * material.roughness;\n\tfloat D = ggxTerm(NoH, a);\n\tfloat G = smithG_GGX(NoL, a) * smithG_GGX(NoV, a);//SmithJointGGXVisibilityTerm(NoL, NoV, a);\n\t\n    return D * fresnel * G;\n}\n\n\nvec3 calBRDF(HitSurfInfo info, vec3 V, vec3 L, float NoL) {\n\n    vec3 brdf = vec3(0.0);\n    vec3 N = info.geoInfo.normal;\n    float NoV = dot(V, N);\n    if (NoV > 0.0) {\n\n        vec3 H = normalize(V + L);\n        vec3 fresnel = schlickFresnel(info.material.specular, dot(L, H));\n\t\tvec3 diffuse = diffuseBRDF(info.material, fresnel);\n\t\tvec3 specular = specularBRDF(info.material, H, V, N, NoL, NoV, fresnel);\n\n\t\tbrdf = diffuse + specular;\n\t}\n    return brdf;\n}\n\nfloat usmoothstep( in float x )\n{\n    x = clamp(x,0.0,1.0);\n    return x*x*(3.0-2.0*x);\n}\n\nfloat softshadow(in Ray ray, in float maxt, in float k, sampler2D channel, vec3 resolution, float time)\n{\n    float res = 1.0;\n\n    Ray r = ray;\n    r.ro.x -= _dimsX;\n    r.ro.y -= _dimsY;\n    r.ro.z -= _dimsZ;\n\n    vec2 b = boundingBox(r.ro, r.rd, _dimsH - 0.001);\n\n    if(b.y > 0.0) {\n\n        ray.t = max(b.x, 0.001);\n\n        vec3 position = ray.ro + ray.rd * ray.t;\n        vec3 pcoord = floor(position);\n\n        for( int i=0; i<24; i++ )\n        {\n            vec3 p = position;\n            p.xz = position.xz - pcoord.xz - vec2(0.5);\n            p.y -= _dimsY;\n\n            MarchingInfo info = sdfScene(channel, resolution, p, pcoord, time);\n            res = min( res, usmoothstep(k*info.hit/ray.t) );\n            if(info.hit < 0.001 || ray.t > maxt) break;\n            float t = ray.t + info.hit;\n            vec3 pos = ray.ro + ray.rd * t;\n            vec3 coord = floor(pos);\n            vec2 tmp = coord.xz - pcoord.xz;\n            if(dot(tmp, tmp) > 0.05) {\n                \n            ray.t += boundingBox(p, ray.rd, vec3(0.5, _dimsY, 0.5)).y + 0.01;\n            position = ray.ro + ray.rd * ray.t;\n            pcoord = floor(position);\n            }\n            else {\n\n                ray.t = t;\n                position = pos;\n            }\n\n        }\n    }\n\n    //float t = mint;\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render(Ray ray, sampler2D channel, vec3 resolution, float time) {\n\n    HitSurfInfo info = intersect(ray, channel, resolution, time);\n    if(info.material.idType > 10.0) return info.material.albedo;\n    vec3 N = info.geoInfo.normal;\n    \n    vec3 radiance = vec3(0.0);\n\n    vec3 dir = normalize(vec3(1.0));\n\n    {\n        vec3 light = vec3(1.0, 0.973, 0.984) * 3.0;//vec3(0.957, 0.545, 0.29) * 5.0;//vec3(1.0, 0.973, 0.984)//vec3(0.957, 0.545, 0.29)\n        //vec3 lightPos = vec3(40.0, 10.0, 40.0);\n\n        //vec3 d = vec3(1.0)//lightPos - info.geoInfo.pos;\n        vec3 L = dir;\n        float NoL = dot(N, L);\n\n        Ray r;\n        setRay(r, info.geoInfo.pos + N * 0.1, L, 0.01);\n        //HitSurfInfo h = intersect(r, channel, resolution, time);\n        if(NoL > 0.0) {\n\n            vec3 brdf = calBRDF(info, -ray.rd, L, NoL);\n            radiance += light * brdf * NoL;\n        }\n        //if(h.material.idType < 10.0) radiance *= 0.2;\n        \n        \n        float shadow = softshadow(r, 10.0, 8.0, channel, resolution, time);\n        radiance *= 0.1 + 0.9 * vec3(shadow, 0.65 * shadow + 0.35 * shadow * shadow, 0.35 * shadow + 0.65 * shadow * shadow);\n        \n\n    }\n    \n    {\n        vec3 light = vec3(0.15, 0.2, 0.36) * 2.0;//;//5.8, 5.2, 15.6//vec3(0.047, 0.2, 0.97)\n        //vec3 lightPos = vec3(65.0, 10.0, 65.0);\n\n        //vec3 d = lightPos - info.geoInfo.pos;\n        vec3 L = normalize(-vec3(dir.x, 0.0, dir.z));\n        float NoL = dot(N, L);\n        if(NoL > 0.0 /*shadow(hitInfo.geoInfo.pos, L)*/) {\n\n            vec3 brdf = calBRDF(info, -ray.rd, L, NoL);\n            radiance += light * brdf * NoL;\n        }\n    }\n    \n    //{\n       //vec3 light = vec3(0.5, 0.2, 0.36) * 4.0;//;//5.8, 5.2, 15.6//vec3(0.047, 0.2, 0.97)\n       //vec3 lightPos = vec3(35.0, 10.0, 35.0);\n\n       //vec3 d = lightPos - info.geoInfo.pos;\n       //vec3 L = normalize(d);\n       //float NoL = dot(N, L);\n       //if(NoL > 0.0 /*shadow(hitInfo.geoInfo.pos, L)*/) {\n\n       //    vec3 brdf = calBRDF(info, -ray.rd, L, NoL);\n       //    radiance += light * brdf * NoL / length(d);\n       //}\n    //}\n\n\n    radiance += (0.8 + 0.2 * N.y) * vec3(0.01,0.02,0.03) * 0.5;\n\n\n    // vec3 spec = info.material.albedo * max(dot(N, normalize(normalize(lightPos - info.geoInfo.pos) - ray.rd)), 0.0);\n\n    // vec3 a = (N + vec3(1.0)) / 2.0;\n    // vec3 color = spec + a * info.material.albedo * 0.2;\n\n    return radiance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    Ray ray;\n    castRay(uv, ray, iResolution, iTime);\n\n    vec3 color = render(ray, iChannel0, iResolution, iTime);\n\n    color *= exposure;\n\n    color = aces(color);\n\n    color = linearToSrgb(color);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#iChannel0 \"self\"\n\n#define Count 101\n#define startPieces\n\nconst vec2 pieces[Count] = vec2[](vec2(17.0, 4.0), vec2(16.0, 16.0), vec2(3.0, 3.0), vec2(3.0, 16.0), vec2(5.0, 17.0), vec2(15.0, 3.0), vec2(16.0, 6.0), vec2(4.0, 14.0), vec2(14.0, 17.0), vec2(17.0, 14.0), vec2(16.0, 17.0), vec2(17.0, 17.0), vec2(17.0, 18.0), vec2(15.0, 17.0), vec2(16.0, 18.0), vec2(15.0, 16.0), vec2(15.0, 18.0), vec2(18.0, 17.0), vec2(14.0, 16.0), vec2(13.0, 18.0), vec2(12.0, 17.0), vec2(12.0, 18.0), vec2(17.0, 16.0), vec2(18.0, 16.0), vec2(10.0, 17.0), vec2(13.0, 17.0), vec2(16.0, 15.0), vec2(15.0, 15.0), vec2(12.0, 16.0), vec2(11.0, 4.0), vec2(9.0, 3.0), vec2(6.0, 4.0), vec2(4.0, 6.0), vec2(9.0, 5.0), vec2(3.0, 12.0), vec2(3.0, 8.0), vec2(5.0, 12.0), vec2(3.0, 13.0), vec2(2.0, 13.0), vec2(2.0, 14.0), vec2(6.0, 6.0), vec2(5.0, 7.0), vec2(5.0, 6.0), vec2(5.0, 9.0), vec2(11.0, 3.0), vec2(12.0, 3.0), vec2(12.0, 4.0), vec2(10.0, 3.0), vec2(11.0, 2.0), vec2(10.0, 4.0), vec2(10.0, 2.0), vec2(13.0, 3.0), vec2(9.0, 4.0), vec2(8.0, 5.0), vec2(7.0, 4.0), vec2(4.0, 3.0), vec2(7.0, 5.0), vec2(3.0, 4.0), vec2(12.0, 5.0), vec2(11.0, 6.0), vec2(12.0, 6.0), vec2(11.0, 7.0), vec2(4.0, 4.0), vec2(8.0, 4.0), vec2(8.0, 3.0), vec2(7.0, 3.0), vec2(7.0, 2.0), vec2(6.0, 3.0), vec2(8.0, 6.0), vec2(10.0, 5.0), vec2(6.0, 2.0), vec2(4.0, 5.0), vec2(3.0, 5.0), vec2(5.0, 4.0), vec2(2.0, 4.0), vec2(13.0, 16.0), vec2(12.0, 7.0), vec2(15.0, 14.0), vec2(14.0, 15.0), vec2(12.0, 15.0), vec2(11.0, 8.0), vec2(10.0, 8.0), vec2(7.0, 8.0), vec2(11.0, 9.0), vec2(12.0, 8.0), vec2(10.0, 9.0), vec2(13.0, 10.0), vec2(7.0, 10.0), vec2(16.0, 3.0), vec2(16.0, 2.0), vec2(17.0, 2.0), vec2(16.0, 5.0), vec2(17.0, 5.0), vec2(15.0, 6.0), vec2(15.0, 4.0), vec2(14.0, 4.0), vec2(16.0, 7.0), vec2(15.0, 7.0), vec2(14.0, 5.0), vec2(2.0, 5.0), vec2(4.0, 4.0));\n\n\nvec2 getCoord(Ray ray, sampler2D channel, vec3 resolution, float time) {\n\n    HitSurfInfo info = intersectPure(ray, channel, resolution, time);\n    if(info.material.idType > 10.0) return vec2(-1.0);\n\n    float x = info.geoInfo.coord.x - (_dimsX - 9.5) + 0.5;\n    float z = info.geoInfo.coord.z - (_dimsZ - 9.5) + 0.5;\n\n    vec2 coord = vec2(-1.0);\n    if(x > 0.0 && x < 19.0 && z > 0.0 && z < 19.0) coord = vec2(x, z);\n    return coord;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(-1.0);\n    if(iFrame < 1) {\n\n        fragColor = vec4(-1.0, -1.0, 1.0, 0.0);\n        return;\n    }\n    if(fragCoord.x > 19.0 || fragCoord.y > 19.0) return;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    vec2 curr = fragColor.rg;\n    vec2 next = fragColor.ba;\n\n    float frame = float(iFrame) - next.y;\n    if(frame > 50.0 && curr.y < 0.5) fragColor.xy = vec2(-1.0);\n\n#ifdef startPieces\n    if(frame > 59.0) {\n\n        int ti = iFrame / 60 - 1;//floor(float(iFrame) / 60.);\n        if(ti > Count - 1) return;\n        vec2 coord = pieces[ti].xy - vec2(0.5);\n\n        if(fragCoord == coord) fragColor.x = next.x;\n        fragColor.z = 1.0 - next.x;\n        fragColor.w = float(iFrame);\n        fragColor.y = -1.0;\n        return;\n    }\n#else\n    if(iMouse.z > 0.0 && frame > 59.0) {\n\n        vec2 uv = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        Ray ray;\n        castRay(uv, ray, iResolution, iTime);\n\n        vec2 coord = getCoord(ray, iChannel0, iResolution, iTime);\n\n        if(coord.x < 0.0) return;\n        if(texture(iChannel0, coord / iResolution.xy).x > -0.5) return;\n\n        if(fragCoord == coord) fragColor.x = next.x;\n        fragColor.z = 1.0 - next.x;\n        fragColor.w = float(iFrame);\n        fragColor.y = -1.0;\n        return;\n    }\n#endif\n\n    if(curr.x < -0.5) return;\n\n    if(abs(next.x - curr.x) > 0.5) {\n\n        fragColor.y = 1.0;\n        return;\n    }\n\n    if(fragCoord.y < 18.0) {\n\n        vec2 t = texture(iChannel0, vec2(fragCoord.x, fragCoord.y + 1.0) / iResolution.xy).rg;\n        if(t.x < -0.5) {\n\n            fragColor.y = 1.0;\n            return;\n        }\n        else if(abs(t.x - curr.x) < 0.1) fragColor.y = t.y;\n        if(fragColor.y > 0.5) return;\n    }\n    if(fragCoord.y > 1.0) {\n\n        vec2 t = texture(iChannel0, vec2(fragCoord.x, fragCoord.y - 1.0) / iResolution.xy).rg;\n        if(t.x < -0.5) {\n\n            fragColor.y = 1.0;\n            return;\n        }\n        else if(abs(t.x - curr.x) < 0.1) fragColor.y = t.y;\n        if(fragColor.y > 0.5) return;\n    }\n    if(fragCoord.x > 1.0) {\n\n        vec2 t = texture(iChannel0, vec2(fragCoord.x - 1.0, fragCoord.y) / iResolution.xy).rg;\n        if(t.x < -0.5) {\n\n            fragColor.y = 1.0;\n            return;\n        }\n        else if(abs(t.x - curr.x) < 0.1) fragColor.y = t.y;\n        if(fragColor.y > 0.5) return;\n    }\n    if(fragCoord.x < 18.0) {\n\n        vec2 t = texture(iChannel0, vec2(fragCoord.x + 1.0, fragCoord.y) / iResolution.xy).rg;\n        if(t.x < -0.5) {\n\n            fragColor.y = 1.0;\n            return;\n        }\n        else if(abs(t.x - curr.x) < 0.1) fragColor.y = t.y;\n        if(fragColor.y > 0.5) return;\n    }\n\n}\n\n/*\nconst vec3 pieces[Count] = vec3[](\n    vec3(16., 4., 0.),\nvec3(4., 16., 1.),\nvec3(3., 4., 0.),\nvec3(17., 16., 1.),\nvec3(15., 16., 0.),\nvec3(15., 17., 1.),\nvec3(14., 17., 0.),\nvec3(16., 17., 1.),\nvec3(3., 14., 0.),\nvec3(6., 17., 1.),\nvec3(13., 16., 0.),\nvec3(16., 15., 1.),\nvec3(9., 17., 0.),\nvec3(5., 3., 1.),\nvec3(8., 4., 0.),\nvec3(3., 7., 1.),\nvec3(5., 4., 0.),\nvec3(3., 10., 1.),\nvec3(4., 3., 0.),\nvec3(2., 16., 1.),\nvec3(14., 3., 0.),\nvec3(17., 9., 1.),\nvec3(5., 16., 0.),\nvec3(5., 15., 1.),\nvec3(4., 11., 0.),\nvec3(6., 16., 1.),\nvec3(3., 11., 0.),\nvec3(4., 10., 1.),\nvec3(5., 10., 0.),\nvec3(5., 9., 1.),\nvec3(6., 9., 0.),\nvec3(5., 8., 1.),\nvec3(6., 8., 0.),\nvec3(2., 10., 1.),\nvec3(6., 11., 0.),\nvec3(6., 7., 1.),\nvec3(7., 7., 0.),\nvec3(6., 6., 1.),\nvec3(7., 6., 0.),\nvec3(13., 3., 1.),\nvec3(13., 4., 0.),\nvec3(12., 3., 1.),\nvec3(14., 2., 0.),\nvec3(9., 4., 1.),\nvec3(8., 3., 0.),\nvec3(10., 7., 1.),\nvec3(16., 10., 0.),\nvec3(16., 9., 1.),\nvec3(15., 10., 0.),\nvec3(15., 9., 1.),\nvec3(14., 9., 0.),\nvec3(14., 8., 1.),\nvec3(13., 8., 0.),\nvec3(14., 7., 1.),\nvec3(13., 7., 0.),\nvec3(13., 9., 1.),\nvec3(14., 10., 0.),\nvec3(13., 6., 1.),\nvec3(12., 9., 0.),\nvec3(14., 5., 1.),\nvec3(14., 4., 0.),\nvec3(13., 10., 1.),\nvec3(12., 6., 0.),\nvec3(13., 11., 1.),\nvec3(13., 5., 0.),\nvec3(14., 6., 1.),\nvec3(12., 8., 0.),\nvec3(17., 10., 1.),\nvec3(11., 11., 0.),\nvec3(9., 11., 1.),\nvec3(10., 9., 0.),\nvec3(7., 8., 1.),\nvec3(8., 10., 0.),\nvec3(7., 5., 1.),\nvec3(8., 5., 0.),\nvec3(6., 4., 1.),\nvec3(6., 3., 0.),\nvec3(11., 9., 1.),\nvec3(10., 10., 0.),\nvec3(12., 10., 1.),\nvec3(11., 8., 0.),\nvec3(10., 8., 1.),\nvec3(13., 12., 0.),\nvec3(14., 11., 1.),\nvec3(15., 12., 0.),\nvec3(15., 11., 1.),\nvec3(16., 11., 0.),\nvec3(16., 12., 1.),\nvec3(17., 11., 0.),\nvec3(14., 12., 1.),\nvec3(11., 10., 0.),\nvec3(9., 9., 1.),\nvec3(18., 11., 0.),\nvec3(15., 13., 1.),\nvec3(16., 7., 0.),\nvec3(17., 12., 1.),\nvec3(3., 16., 0.),\nvec3(3., 15., 1.),\nvec3(15., 5., 0.),\nvec3(18., 12., 1.),\nvec3(19., 11., 0.),\nvec3(18., 10., 1.),\nvec3(8., 7., 0.),\nvec3(9., 10., 1.),\nvec3(11., 13., 0.),\nvec3(7., 9., 1.),\nvec3(6., 10., 0.),\nvec3(10., 12., 1.),\nvec3(11., 12., 0.),\nvec3(7., 12., 1.),\nvec3(6., 12., 0.),\nvec3(7., 13., 1.),\nvec3(3., 8., 0.),\nvec3(5., 5., 1.),\nvec3(5., 2., 0.),\nvec3(2., 7., 1.),\nvec3(4., 7., 0.),\nvec3(5., 7., 1.),\nvec3(5., 14., 0.),\nvec3(6., 15., 1.),\nvec3(4., 6., 0.),\nvec3(4., 8., 1.),\nvec3(9., 13., 0.),\nvec3(8., 11., 1.),\nvec3(2., 14., 0.),\nvec3(9., 6., 1.),\nvec3(7., 4., 0.),\nvec3(6., 5., 1.),\nvec3(8., 6., 0.),\nvec3(9., 8., 1.),\nvec3(2., 8., 0.),\nvec3(3., 9., 1.),\nvec3(8., 15., 0.),\nvec3(7., 15., 1.),\nvec3(15., 18., 0.),\nvec3(18., 7., 1.),\nvec3(4., 14., 0.),\nvec3(3., 17., 1.),\nvec3(16., 18., 0.),\nvec3(17., 18., 1.),\nvec3(18., 6., 0.),\nvec3(17., 7., 1.),\nvec3(17., 6., 0.),\nvec3(10., 3., 1.),\nvec3(7., 18., 0.),\nvec3(19., 6., 1.),\nvec3(19., 5., 0.),\nvec3(19., 7., 1.),\nvec3(18., 4., 0.),\nvec3(2., 12., 1.),\nvec3(2., 11., 0.),\nvec3(1., 11., 1.),\nvec3(3., 12., 0.),\nvec3(8., 14., 1.),\nvec3(9., 14., 0.),\nvec3(8., 16., 1.),\nvec3(6., 18., 0.),\nvec3(5., 18., 1.),\nvec3(5., 19., 0.),\nvec3(4., 19., 1.),\nvec3(1., 8., 0.),\nvec3(1., 9., 1.),\nvec3(11., 4., 0.),\nvec3(9., 5., 1.),\nvec3(11., 3., 0.),\nvec3(11., 2., 1.),\nvec3(7., 11., 0.),\nvec3(9., 2., 1.),\nvec3(17., 8., 0.),\nvec3(18., 8., 1.),\nvec3(17., 19., 0.),\nvec3(18., 19., 1.),\nvec3(15., 8., 0.),\nvec3(19., 12., 1.),\nvec3(15., 6., 0.),\nvec3(19., 10., 1.),\nvec3(14., 9., 0.),\nvec3(14., 10., 1.),\nvec3(15., 15., 0.),\nvec3(10., 16., 1.),\nvec3(8., 8., 0.),\nvec3(12., 7., 1.),\nvec3(11., 7., 0.),\nvec3(11., 6., 1.),\nvec3(11., 10., 0.),\nvec3(12., 5., 1.),\nvec3(11., 9., 0.),\nvec3(12., 7., 1.),\nvec3(15., 12., 0.),\nvec3(11., 10., 0.),\nvec3(9., 9., 1.),\nvec3(9., 10., 0.),\nvec3(7., 9., 1.),\nvec3(6., 10., 0.),\nvec3(10., 8., 1.),\nvec3(11., 8., 0.),\nvec3(8., 6., 1.),\nvec3(8., 7., 0.),\nvec3(9., 6., 1.),\nvec3(7., 10., 0.),\nvec3(10., 10., 1.),\nvec3(10., 11., 0.),\nvec3(8., 6., 1.),\nvec3(8., 7., 0.),\nvec3(9., 6., 1.),\nvec3(8., 9., 0.),\nvec3(14., 6., 1.),\nvec3(13., 10., 0.),\nvec3(12., 4., 1.),\nvec3(18., 5., 0.),\nvec3(6., 4., 1.),\nvec3(6., 3., 0.),\nvec3(14., 10., 1.),\nvec3(17., 10., 0.),\nvec3(14., 11., 1.),\nvec3(18., 9., 0.),\nvec3(18., 8., 1.),\nvec3(18., 10., 0.),\nvec3(14., 8., 1.),\nvec3(13., 9., 0.),\nvec3(13., 8., 1.),\nvec3(12., 9., 0.),\nvec3(12., 8., 1.),\nvec3(11., 9., 0.),\nvec3(17., 7., 1.),\nvec3(16., 13., 0.),\nvec3(12., 4., 1.),\nvec3(13., 5., 0.),\nvec3(9., 2., 1.),\nvec3(7., 2., 0.),\nvec3(9., 4., 1.),\nvec3(11., 6., 0.),\nvec3(8., 3., 1.),\nvec3(7., 4., 0.),\nvec3(10., 5., 1.),\nvec3(5., 11., 1.),\nvec3(6., 10., 0.),\nvec3(2., 11., 1.),\nvec3(5., 12., 0.),\nvec3(12., 17., 1.),\nvec3(12., 16., 0.),\nvec3(14., 18., 1.),\nvec3(11., 17., 0.),\nvec3(13., 17., 1.),\nvec3(10., 14., 0.),\nvec3(6., 4., 1.),\nvec3(5., 5., 0.),\nvec3(10., 3., 1.),\nvec3(3., 11., 1.),\nvec3(6., 16., 0.),\nvec3(5., 17., 1.),\nvec3(4., 15., 0.),\nvec3(3., 15., 1.),\nvec3(4., 14., 0.),\nvec3(7., 16., 1.),\nvec3(6., 15., 0.),\nvec3(8., 17., 1.),\nvec3(9., 16., 0.),\nvec3(7., 15., 1.),\nvec3(6., 14., 0.),\nvec3(7., 14., 1.),\nvec3(6., 13., 0.),\nvec3(2., 14., 1.),\nvec3(5., 17., 1.),\nvec3(4., 15., 0.),\nvec3(3., 16., 1.),\nvec3(4., 11., 0.),\nvec3(3., 11., 1.),\nvec3(3., 12., 0.),\nvec3(4., 12., 1.),\nvec3(5., 12., 0.),\nvec3(4., 13., 1.),\nvec3(5., 13., 0.),\nvec3(3., 13., 1.),\nvec3(2., 13., 0.),\nvec3(2., 12., 1.),\nvec3(4., 14., 0.),\nvec3(3., 12., 1.),\nvec3(7., 16., 0.),\nvec3(6., 16., 1.),\nvec3(7., 15., 0.),\nvec3(4., 5., 1.),\nvec3(3., 5., 0.),\nvec3(4., 6., 1.),\nvec3(3., 7., 0.),\nvec3(4., 7., 1.),\nvec3(3., 8., 0.),\nvec3(4., 8., 1.),\nvec3(4., 9., 0.),\nvec3(5., 9., 1.),\nvec3(5., 10., 0.),\nvec3(3., 6., 1.),\nvec3(2., 6., 0.),\nvec3(2., 5., 1.),\nvec3(2., 7., 0.),\nvec3(3., 3., 1.),\nvec3(2., 4., 0.),\nvec3(4., 10., 1.),\nvec3(3., 9., 0.),\nvec3(6., 9., 1.),\nvec3(6., 10., 0.),\nvec3(7., 10., 1.),\nvec3(7., 9., 0.),\nvec3(6., 7., 1.),\nvec3(8., 9., 0.),\nvec3(7., 11., 1.),\nvec3(6., 12., 0.),\nvec3(4., 13., 1.)\n);\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n\n#define _dims vec3(99.0, 6.0, 99.0)\n\n#define _dimsH _dims * 0.5\n#define _dimsX _dims.x * 0.5\n#define _dimsY _dims.y * 0.5    \n#define _dimsZ _dims.z * 0.5\n\n#define Far 10000.0\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n    float t;\n};\n\nstruct Material\n{\n    float idType;\n    vec3 albedo;\n    float roughness;\n    vec3 emissive;\n    vec3 specular;\n};\n\nstruct MarchingInfo\n{\n    float hit;\n    Material material;\n};\n\nstruct SurfGeoInfo\n{\n    vec3 pos;\n    vec3 coord;\n    vec3 normal;\n};\n\nstruct HitSurfInfo\n{\n    SurfGeoInfo geoInfo;\n    Material material;\n};\n\nvoid setRay(inout Ray ray, vec3 ro, vec3 rd, float t) {\n\n    ray.ro = ro;\n    ray.rd = rd;\n    ray.t = t;\n}\n\nRay setRay(vec3 ro, vec3 rd, float t) {\n\n    Ray ray;\n    ray.ro = ro;\n    ray.rd = rd;\n    ray.t = t;\n    return ray;\n}\n\nMaterial setMaterialInfo(float idType, vec3 albedo, float roughness, vec3 emissive, vec3 specular) {\n\n    Material info;\n    info.idType = idType;\n    info.albedo = albedo;\n    info.roughness = roughness;\n    info.emissive = emissive;\n    info.specular = specular;\n    return info;\n}\n\nMaterial setMaterialInfo(Material material) {\n\n    Material info;\n    info.idType = material.idType;\n    info.albedo = material.albedo;\n    info.roughness = material.roughness;\n    info.emissive = material.emissive;\n    info.specular = material.specular;\n    return info;\n}\n\nMaterial initMaterialInfo() {\n\n    Material matInfo;\n    matInfo.albedo = vec3(0.0);\n    matInfo.roughness = 0.1;\n    matInfo.emissive = vec3(0.0);\n    matInfo.specular = vec3(0.5);\n\n    return matInfo;\n}\n\nvec2 boundingBox(in vec3 ro, in vec3 rd, in vec3 k) {\n\n    vec3 a = ro / rd;\n    vec3 b = k / abs(rd);\n    vec3 t1 = -a - b;\n    vec3 t2 = -a + b;\n\n    float n = max(max(t1.x, t1.y), t1.z);\n    float f = min(min(t2.x, t2.y), t2.z);\n\t\n    if(n > f || f < 0.0) return vec2(-1.0); \n    return vec2(n, f);\n}\n\nfloat opUn(float d1, float d2) {  return min(d1, d2); }\nfloat opSub(float d1, float d2) { return max(d1, -d2); }\nfloat opInter(float d1, float d2) { return max(d1, d2); }\n\nmat2 rot(float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float s) {\n\n    return length(p) - s;\n}\n\nfloat sdCube(vec3 p, vec3 b) {\n\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sCCyl(vec3 p, float r, float h) {\n\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// from iq\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nMarchingInfo unionSDF(MarchingInfo infoA, MarchingInfo infoB) {\n\n    //return infoA.hit < infoB.hit ? infoA : infoB;\n    if(infoA.hit < infoB.hit) return infoA;\n    return infoB;\n}\n\nMarchingInfo differenceSDF(MarchingInfo infoA, MarchingInfo infoB) {\n\n    infoB.hit *= -1.0;\n    if(infoA.hit > infoB.hit) return infoA;\n    return infoB;\n}\n\nMarchingInfo sdBallObj(vec3 pos) {\n\n    MarchingInfo info;\n    vec3 p = pos;\n    p.y -= 2.4;\n    info.hit = sdSphere(p, 0.4134);\n    info.material = setMaterialInfo(0.0, vec3(0.01), 0.05, vec3(0.0), vec3(0.04));\n    return info;\n}\n\nMarchingInfo sdPiece(vec3 pos) {\n\n    MarchingInfo info;\n    vec3 p = pos;\n    p.yz = rot(3.1416 / 2.0) * pos.yz;\n    //p.z += 2.0;\n    p.z -= 2.1;\n    info.hit = sdEllipsoid(p, vec3(0.4, 0.4, 0.12));\n    info.material = setMaterialInfo(9.0, vec3(0.9705, 0.906, 0.97), 0.575, vec3(0.0), vec3(0.05));\n    return info;\n}\n\nMarchingInfo sdCCylObj(vec3 pos, float r, float h) {\n\n    MarchingInfo info;\n    info.hit = sCCyl(pos, r, h);\n    info.material =setMaterialInfo(0.0, vec3(0.01), 0.05, vec3(0.0), vec3(0.04));\n    return info;\n}\n\nMarchingInfo sdBoxObj(vec3 pos, vec3 v) {\n\n    MarchingInfo info;\n    info.hit = sdCube(pos, v);\n    info.material =setMaterialInfo(0.0, vec3(0.75, 0.76, 0.297), 0.1, vec3(0.0), vec3(0.0));\n    return info;\n}\n\nMarchingInfo sdLatticeObj(vec3 pos, float h, float r, float m, float n) {\n\n    MarchingInfo info;\n    info.hit = sdCube(pos, vec3(0.5, h, 0.5));\n    info.material =setMaterialInfo(0.0, vec3(0.912, 0.3837, 0.0175), 0.4, vec3(0.0), vec3(0.04));\n\n    vec3 p0 = pos;\n    p0.yz = rot(3.1416 / 2.0) * pos.yz;\n    p0.z -= h;\n    p0.y += m - 0.5;\n\n    info = differenceSDF(info, sdCCylObj(p0, r, 0.5 - abs(m - 0.5) + 0.001));\n\n    vec3 p1 = pos;\n    p1.xz = rot(3.1416 / 2.0) * pos.xz;\n    p1.yz = rot(3.1416 / 2.0) * p1.yz;\n    p1.z -= h;\n    p1.y += n - 0.5;\n\n    info = differenceSDF(info, sdCCylObj(p1, r, 0.5 - abs(n - 0.5) + 0.001));\n\n    return info;\n}\n\nMarchingInfo sdCheckerboard(vec3 pos, vec3 coord) {\n\n    // vec3 mid = vec3(9.0, 0.0,  9.0);\n    // float mlength = 0.5 - length(coord - mid) / length(mid) * 0.5;\n    //if(coord.x== .0 && coord.z  ==.0) mlength = 0.49;\n    // if(coord.x > 9.0 && coord.y < 9.0) mlength = 0.49;\n    // float t = 0.5 - mlength;\n    // pos.y += t;\n    MarchingInfo info;\n\n    vec2 v = vec2(0.5);\n    if(coord.x < _dimsX - 9.0) v.y = 0.75;\n    else if(coord.x > _dimsX + 8.0) v.y = 0.25;\n    if(coord.z < _dimsZ - 9.0) v.x = 0.75;\n    else if(coord.z > _dimsZ + 8.0) v.x = 0.25;\n\n    info = sdLatticeObj(pos, 2.0, 0.02, v.x, v.y);\n\n    return info;\n}\n\nMarchingInfo sdfScene(sampler2D channel, vec3 resolution, vec3 pos, vec3 coord, float time) {\n\n    MarchingInfo info;\n    info.hit = Far;\n    info.material = setMaterialInfo(0.0, vec3(0.5), 0.1, vec3(0.0), vec3(0.0));\n\n    if(coord.x > _dimsX - 10.0 && coord.x < _dimsX + 9.0 && coord.z > _dimsZ - 10.0 && coord.z < _dimsZ + 9.0) {\n\n        info = sdCheckerboard(pos, coord);\n        float f = abs(coord.x - _dimsX + 0.5);\n        if(f == 0.0 || f == 6.0) {\n\n            float t = abs(coord.z - _dimsZ + 0.5);\n            if(t == 0.0 || t == 6.0) {\n\n                info = differenceSDF(info, sdBallObj(pos));//sdBallObj\n            }\n        }\n        float x = coord.x - (_dimsX - 9.5) + 0.5;\n        float z = coord.z - (_dimsZ - 9.5) + 0.5;\n        vec2 q = texture(channel, vec2(x, z) / resolution.xy).rg;\n        //vec2 q = texture(iChannel0, vec2(18.5) / iResolution.xy).rg;\n\n\n        if(q.x < -0.5) return info;\n        else if(q.x < 0.5) info = unionSDF(info, sdPiece(pos));//sdEllipsoid   sdPiece\n        else {\n\n            MarchingInfo m = sdPiece(pos);\n            m.material.albedo = vec3(0.01, 0.013, 0.01);\n            info = unionSDF(info, m);\n        }\n\n    }\n    else {\n\n        float tt = sin(coord.x * PI * 0.005 * time) * cos(coord.z * PI * 0.005 * time) + 1.0;\n        vec3 p = pos;\n        p.y += _dimsY - tt;\n        info.hit = sdCube(p, vec3(0.4, tt, 0.4)) - 0.1;//sdCube\n        vec3 v = vec3(0.975 * tt, 0.45 * tt, tt * 0.15) * 0.96 + 0.04;//coord.x / _dims.x * //coord.z / _dims.z * \n        info.material =setMaterialInfo(0.0, vec3(0.0095), 0.3, vec3(0.0), v);\n    }\n    \n\n    return info;\n}\n\nHitSurfInfo intersectPure(inout Ray ray, sampler2D channel, vec3 resolution, float time) {\n\n    HitSurfInfo hitInfo;\n    SurfGeoInfo geoInfo;\n\n    Ray r = ray;\n    r.ro.x -= _dimsX;\n    r.ro.y -= _dimsY;\n    r.ro.z -= _dimsZ;\n\n    vec2 b = boundingBox(r.ro, r.rd, _dimsH - 0.001);\n\n\tif(b.y > 0.0) {\n\n        ray.t = max(b.x, 0.001);\n\n    \tgeoInfo.pos = ray.ro + ray.rd * ray.t;\n        geoInfo.coord = floor(geoInfo.pos);\n\n        for(int i = 0; i < 128 && ray.t < b.y; i++) {\n\n            vec3 p = geoInfo.pos;\n            p.xz = geoInfo.pos.xz - geoInfo.coord.xz - vec2(0.5);\n            p.y -= _dimsY;\n\n            MarchingInfo info = sdfScene(channel, resolution, p, geoInfo.coord, time);\n            if(info.hit < 0.001 && info.hit > -0.0001) {\n\n                hitInfo.geoInfo = geoInfo;\n                hitInfo.material = info.material;\n                return hitInfo;\n            }\n\n            float t = ray.t + info.hit;\n            vec3 pos = ray.ro + ray.rd * t;\n            vec3 coord = floor(pos);\n            vec2 tmp = coord.xz - geoInfo.coord.xz;\n            if(dot(tmp, tmp) > 0.05) {\n                \n                ray.t += boundingBox(p, ray.rd, vec3(0.5, _dimsY, 0.5)).y + 0.01;\n                geoInfo.pos = ray.ro + ray.rd * ray.t;\n                geoInfo.coord = floor(geoInfo.pos);\n            }\n            else {\n\n                ray.t = t;\n                geoInfo.pos = pos;\n            }\n        }\n        // hitInfo.geoInfo = geoInfo;\n        // hitInfo.material = setMaterialInfo(11.0, vec3(0.5, 0.2, 1.0), 0.1, vec3(0.0), vec3(0.0));\n        // return hitInfo;\n    }\n    hitInfo.geoInfo = geoInfo;\n    hitInfo.material = setMaterialInfo(12.0, vec3(0.0), 0.1, vec3(0.0), vec3(0.0));\n    return hitInfo;\n}\n\nvoid setCamera(vec4 mouse, inout Ray ray, vec3 resolution){\n\n    vec2 mo = mouse.xy / resolution.xy;\n    float x = -(mo.x * 2.0 - 1.0) * PI;\n    float y = (mo.y * 2.0 - 1.0) * 1.5707963268;\n    mat4 my = mat4(cos(x), 0.0, sin(x), 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  -sin(x), 0.0, cos(x), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    mat4 mx = mat4(1.0, 0.0, 0.0, 0.0,\n                  0.0, cos(y), -sin(y), 0.0,\n                  0.0, sin(y), cos(y), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    ray.ro = (my * mx * vec4(ray.ro, 1.0)).xyz;\n\n    ray.ro -= vec3(-_dimsX, 0.0, -_dimsZ);\n    ray.rd = (my * mx * vec4(ray.rd, 0.0)).xyz;\n}\n\nvoid castRay(vec2 uv, inout Ray ray, vec3 resolution, float time) {\n\n    float a = 15.0;\n    vec3 o = vec3(0.0, 0.0, -8.0 - a);\n    vec3 d = normalize(vec3(uv, -6.3 - a) - o);\n    setRay(ray, o, d, Far);\n\n    vec4 mouse = vec4((0.5 + 0.05 * sin(time * 0.2)) * resolution.x , (0.15 + 0.02 * cos(time * 0.2)) * resolution.y, 0.0, 0.0);\n\n    //vec4 mouse = iMouse;\n    setCamera(mouse, ray, resolution);\n}","name":"Common","description":"","type":"common"}]}