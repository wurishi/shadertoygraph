{"ver":"0.1","info":{"id":"XfjGzz","date":"1703773547","viewed":23,"name":"Raymarch repeat","username":"Konsey","description":"proof of concept - striped measure line in raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"dsKBWc","parentname":"Raymarching arrow"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\nconst float MAX_DIST = 30.;\nconst int MAX_STEPS = 100;\nconst float SURF_DIST = .001;\n\n// Shading parameters\nconst vec3 LIGHT_POS = vec3(0, 3, 2);\n\nconst bool USE_SHADOWS = false; \n\n// Gets the required rotation matrix to rotate v1 into v2\n// https://gist.github.com/kevinmoran/b45980723e53edeb8a5a43c49f134724#fixing-our-function\nmat3 rotateAlign( vec3 v1, vec3 v2)\n{\n    vec3 axis = cross( v1, v2 );\n\n    float cosA = dot( v1, v2 );\n    float k = 1.0f / (1.0f + cosA);\n\n    mat3 result=mat3( (axis.x * axis.x * k) + cosA,\n                 (axis.y * axis.x * k) - axis.z, \n                 (axis.z * axis.x * k) + axis.y,\n                 (axis.x * axis.y * k) + axis.z,  \n                 (axis.y * axis.y * k) + cosA,      \n                 (axis.z * axis.y * k) - axis.x,\n                 (axis.x * axis.z * k) - axis.y,  \n                 (axis.y * axis.z * k) + axis.x,  \n                 (axis.z * axis.z * k) + cosA \n                 );\n\n    return result;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  float d = length(pa - ba * h) - r;\n\n  return d;\n}\n\nconst float SPACING = 0.3;\nconst float SEG_SIZE = .1;\nconst float DIST_FROM_SCREEN = 3.;\nconst float LINE_LENGTH = 3.;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat repeatedBox( vec3 p, float s, vec3 direction )\n{\n    vec3 std_direction = normalize(vec3(1.,1.,0.));\n    mat3 rot_mat = rotateAlign(std_direction, normalize(direction));\n    p *= rot_mat;\n    p += vec3(0.,-1.*iTime,0.);\n    p.y -= s*round(p.y/s);\n    return sdBox(p, vec3(100.,SEG_SIZE,100.));\n}\n\n\nfloat getDist(vec3 pos){\n    // float directionX = sin(iTime*.4+.33);\n    // float directionY = sin(iTime*.6);\n    vec2 mouse = vec2(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    float directionX = mouse.x;\n    float directionY = mouse.y;\n    float directionZ = sin(iTime*.7+.78);\n    \n    vec3 arrowDirection = vec3(directionX,directionY,directionZ);\n    // arrowDirection = vec3(-1.,-1.,-1.);\n    \n    \n    vec3 a = vec3(0.,-LINE_LENGTH,DIST_FROM_SCREEN+2.);\n    vec3 b = vec3(2.,LINE_LENGTH,DIST_FROM_SCREEN);\n    vec3 direction_cap = b-a;\n    \n    float d_viewbox= sdBox(pos+vec3(0.,0.,-DIST_FROM_SCREEN), vec3(4.,4.,4.));\n    float d_shapes = repeatedBox(pos+vec3(0.,0.,-DIST_FROM_SCREEN), SPACING,direction_cap);\n    float d_cap = sdCapsule(pos, a, b,0.05);\n    //return d_viewbox;\n    //return d_shapes;\n    //return d_cap;\n    float d = d_viewbox;\n    d = max(d, d_shapes);\n    d = max(d, d_cap);\n    //return max(d_viewbox, d_shapes);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 l = normalize(LIGHT_POS-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float light = mix(.2,1.,dif);\n    // shadow\n    if(USE_SHADOWS){\n        float d = RayMarch(p+n*SURF_DIST*2., l);\n        if(d<length(LIGHT_POS-p)) light *= .5;\n    }\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 aspect = vec2(1./aspectRatio,aspectRatio);\n    \n    //uv = vec2(uv.x*(aspectRatio)-.5,uv.y);\n    \n    // Time varying pixel color\n    \n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv.xy,1.));\n    \n    vec3 col = vec3(uv.y);\n    \n    \n     float d = RayMarch(ro, rd);\n     // col = vec3(d/1000.);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(dif);\n        col*=vec3(1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}