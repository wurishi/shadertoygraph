{"ver":"0.1","info":{"id":"wl3GRH","date":"1575729453","viewed":160,"name":"Shaky cube","username":"Anskiere","description":"-","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","sdf","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define time iTime\n\nconst float maxDist = 200.;\nconst float planeDist = 2.;\n\nvec3 cameraPos()\n{\n    float t = time*0.2;\n    float r = 7.;\n\n    vec3 res = vec3(sin(t),1.3,-cos(t));\n    res *= r;\n\n    return res;\n}\n\nvec3 getRay(vec2 uv)\n{\n    vec3 cam = cameraPos();\n    vec3 origin = vec3(0, 0, 0);\n    vec3 look = normalize(origin - cam);\n    vec3 upGlob = vec3(0,1,0);\n    vec3 right = normalize(cross(upGlob, look));\n    vec3 camUp = normalize(-cross(right, look));\n\n    vec3 p = cam + camUp * uv.y + right * uv.x;\n    p += look * planeDist;\n\n    vec3 res = p - cam;\n    return normalize(res);\n}\n\nfloat getSphere(vec3 p, float size, vec3 origin)\n{\n    return length(p - origin) - size;\n}\n\nfloat getSphere(vec3 p, float size)\n{\n    return getSphere(p, size, vec3(0,0,0));\n}\n\nvec2 rot(vec2 p, float a)\n{\n    float ca = cos(a), sa = sin(a);\n    mat2 m = mat2(ca, sa, -sa, ca);\n    return p * m;\n}\n\nvec3 rot(vec3 p, vec3 u, float a)\n{\n    float omc = 1. - cos(a);\n    float sa = sin(a);\n    float ca = cos(a);\n\n    mat3 m = mat3(\n        ca + u.x*u.x*omc,\n        u.x*u.y*omc + u.z*sa,\n        u.x*u.z*omc - u.y*sa,\n\n        u.x*u.y*omc - u.z*sa,\n        ca + u.y*u.y*omc,\n        u.y*u.z*omc + u.x*sa,\n\n        u.x*u.z*omc + u.y*sa,\n        u.y*u.z*omc - u.x*sa,\n        ca + u.z*u.z*omc\n    );\n\n    return m * p;\n}\n\nfloat getSd(vec3 uv)\n{\n    const int steps = 7;\n    float t = time * 0.5;\n    float s = 1.;\n\n    vec3 u = normalize(vec3(1));\n    vec3 ouv = uv;\n\n    for (int i = 0; i < steps; i++)\n    {\n        uv = abs(uv);\n        uv -= .5;\n        uv = rot(uv, u, .3*cos(ouv.y*2. + t*5.));\n        \n        uv *= 2.;\n        s *= 2.;\n    }\n\n    float res = getSphere(uv, 0.5)/s;\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.001; // or some other value const\n    vec2 k = vec2(1,-1);\n\n    return\n        normalize(\n            k.xyy*getSd( p + k.xyy*h ) +\n            k.yyx*getSd( p + k.yyx*h ) +\n            k.yxy*getSd( p + k.yxy*h ) +\n            k.xxx*getSd( p + k.xxx*h ) );\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n    float depth = 0.;\n\n    for(int i = 0; i < 150; i++)\n    {\n        vec3 p = sp + ray * depth;\n        float dist = getSd(p);\n\n        if (dist <= 0.001)\n            return depth - dist;\n\n        depth += dist;\n\n        if (depth >= maxDist)\n            return depth;\n    }\n\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= .65;\n    \n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n    float d = raymarch(camPos, ray);\n\n    vec3 col = vec3(1);\n\n    if (d > 30.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec3 intP = camPos + d*ray;\n    vec3 n = calcNormal(intP);\n    float dis = length(intP-camPos);\n    vec3 lightDir = normalize(vec3(-1,1,1));\n    float dd = dot(n, lightDir);\n\n    dd = dd *.1 + .9;\n\n    vec3 res = col * intP * dd;\n\n    res = pow(abs(res), vec3(1.2));\n    fragColor = vec4(res, 0);\n}","name":"Image","description":"","type":"image"}]}