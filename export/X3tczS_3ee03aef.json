{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Remix by Orblivius of Christmas Tree Packing as a visualizer!\n// Original: https://shadertoy.com/view/X3tyW7\n\n#define time iTime*5.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec2 uv;\n\nuniform vec2 resolution;\n\nconst float pi = atan(1.0)*4.0;\nconst float tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nconst float epsilon = 1e-3;\nconst float infinity = 1e6;\n\nconst vec2 ch_size  = vec2(2.0, 4.0);              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -6., 2.); // start position\n      vec2 ch_pos   = vec2 (0.0, -0.5);             // character position(X,Y)\n      vec3 ch_color = vec3 (1.0, 0.2, 0.1);        // character color (R,G,B)\nconst vec3 bg_color = vec3 (0.0, 0.0, 0.0);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n#define n0 ddigit(0x22FF);\n#define n1 ddigit(0x0281);\n#define n2 ddigit(0x1177);\n#define n3 ddigit(0x11E7);\n#define n4 ddigit(0x1189);\n#define n5 ddigit(0x11EE);\n#define n6 ddigit(0x11FE);\n#define n7 ddigit(0x0087);\n#define n8 ddigit(0x11FF);\n#define n9 ddigit(0x11EF);\n\n#define A ddigit(0x119F);\n#define B ddigit(0x927E);\n#define C ddigit(0x007E);\n#define D ddigit(0x44E7);\n#define E ddigit(0x107E);\n#define F ddigit(0x101E);\n#define G ddigit(0x807E);\n#define H ddigit(0x1199);\n#define I ddigit(0x4466);\n#define J ddigit(0x4436);\n#define K ddigit(0x9218);\n#define L ddigit(0x0078);\n#define M ddigit(0x0A99);\n#define N ddigit(0x8899);\n#define O ddigit(0x00FF);\n#define P ddigit(0x111F);\n#define Q ddigit(0x80FF);\n#define R ddigit(0x911F);\n#define S ddigit(0x8866);\n#define T ddigit(0x4406);\n#define U ddigit(0x00F9);\n#define V ddigit(0x2218);\n#define W ddigit(0xA099);\n#define X ddigit(0xAA00);\n#define Y ddigit(0x4A00);\n#define Z ddigit(0x2266);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0);\n#define s_minus   ddigit(0x1100);\n#define s_plus    ddigit(0x5500);\n#define s_greater ddigit(0x2800);\n#define s_less    ddigit(0x8200);\n#define s_sqrt    ddigit(0x0C02);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nfloat d = 1e6;\n\nvoid ddigit(int n)\n{\n\tfloat v = 1e6;\t\n\tvec2 cp = uv - ch_pos;\n\tif (n == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nvec3 computeLocalSphereLighting(vec3 p, vec3 n) {\n    vec3 col = vec3(0.0);\n\n    vec3 voxelPos = worldToVoxel(p.xyzz).xyz; \n    ivec3 basePos = ivec3(floor(voxelPos));\n\n    vec4 distances = vec4(FLOAT_INF);     \n    uvec4 indices = uvec4(uint(-1));   \n\n    for(int z = -1; z <= 1; z++) {\n        for(int y = -1; y <= 1; y++) {\n            for(int x = -1; x <= 1; x++) {\n                \n                ivec3 sampleCoord = basePos + ivec3(x, y, z);\n                uvec4 fetchedClosest = fetchClosest3D(vec3(sampleCoord), iChannel1);\n\n                for(int j = 0; j < 4; j++) {\n                    uint sphereIdx = fetchedClosest[j];\n                    if (sphereIdx == uint(-1) || any(equal(indices, uvec4(sphereIdx)))) {\n                        continue;\n                    } \n\n                    vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n                    vec3 sphereCenter = e.xyz;\n                    float sphereRadius = e.w;\n\n                    float dist = length(sphereCenter - p) - sphereRadius;\n\n                    if(dist < distances.x) {\n                        distances = vec4(dist, distances.x, distances.y, distances.z);\n                        indices = uvec4(sphereIdx, indices.x, indices.y, indices.z);\n                    }\n                    else if(dist < distances.y) {\n                        distances = vec4(distances.x, dist, distances.y, distances.z);\n                        indices = uvec4(indices.x, sphereIdx, indices.y, indices.z);\n                    }\n                    else if(dist < distances.z) {\n                        distances = vec4(distances.x, distances.y, dist, distances.z);\n                        indices = uvec4(indices.x, indices.y, sphereIdx, indices.z);\n                    }\n                    else if(dist < distances.w) {\n                        distances.w = dist;\n                        indices.w = sphereIdx;\n                    }\n                }\n            }\n        }\n    }\n\n        uint sphereIdx = indices[0];\n      //  if(sphereIdx == uint(-1)) continue; \n\n        vec3 ballCol = vec3(\n            xorshiftFloat(sphereIdx * 12345u), \n            xorshiftFloat(sphereIdx * 34567u), \n            xorshiftFloat(sphereIdx * 56789u)\n        );\n\n        vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n        vec3 sphereCenter = e.xyz;\n        float sphereRadius = e.w;\n\n        vec3 emissionColor = ballCol;\n        float emissionPower = 0.00175; \n\n        vec3 LL = sphereCenter - p + n * 0.025;\n        float dist = length(LL);\n        vec3 lDir = LL / dist;\n\n        float NoL = max(dot(n, lDir), 0.0);\n        float falloff = 1.0 / (dist * dist);\n        col += ballCol * emissionPower * NoL * falloff;\n   \n\n    return col; //+vec3(0.000,0.502,0.902);\n}\n\n\n\nfloat getSpheres(vec3 p) {\n    vec3 voxelPos = worldToVoxel(p.xyzz).xyz;\n    ivec3 basePos = ivec3(floor(voxelPos));\n    uint index = 0u;\n    float vol = 0.0;\n    float shapeD = 999.0;\n\n                ivec3 sampleCoord = basePos;\n                uvec4 fetchedClosest = fetchClosest3D(vec3(sampleCoord), iChannel1);\n                for (int j = 0; j < 4; j++) {\n                    uint sphereIdx = fetchedClosest[j];\n                    if(sphereIdx == uint(-1)) { continue; }\n\n                    vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n                    e.w *= 0.5;\n                    float dist = length(p - e.xyz) - e.w;\n                    shapeD = min(dist, shapeD);\n\n  \n    }\n\n\n\n    return shapeD;\n}\n\n\nfloat fullScene(vec3 p) {\n    return smin(scene2(p), getSpheres(p), 0.01);\n}\n\n\nfloat raymarchMapStart(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 24; i++) {\n        vec3 p = ro + rd * t;\n        float shapeD = scene0(p);\n                \n        if(shapeD < 0.01)  return t;\n        t += shapeD;\n        if(t > 6.0)  break;  \n    }\n \n    return t;\n}\n\nfloat raymarchMap(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 32; i++) {\n        vec3 p = ro + rd * t;\n        float shapeD = fullScene(p);\n                \n        if(shapeD < 0.005)  return t;\n        t += shapeD;\n        if(t > 6.0)  break;  \n    }\n \n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = fullScene(p);\n    vec2 e = vec2(.002, 0);\n    \n    vec3 n = d - vec3(\n        fullScene(p-e.xyy),\n        fullScene(p-e.yxy),\n        fullScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// Auroras by nimitz 2017 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<30.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*2.;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n\n\nvec4 mainImage2(in vec2 fragCoord) {\n    vec2 uvv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uvv.x  *= aspect;\n   \n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p2 = q - 0.5;\n\tp2.x*=iResolution.x/iResolution.y;\n     p2.y += 0.1;\n\n    bool groundTruth = true;\n\n    vec2 uvCam = uvv;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0,0,-5.);\n    vec3 rd = normalize(vec3(p2,1.9));\n    \n   // vec3 rd = normalize(vec3(uvCam, -1.05));\n  // vec3 ro = vec3(0.0, 0.0, 2.0);\n\n    float yrot = 0.0;\n    float zrot =  iTime * 0.25;\n    if (iMouse.z > 0.0) {\n       yrot += -2.0 * mouse.y;\n        zrot = 2.0 * mouse.x;\n    }\n    rd = rotate(rd, vec3(1, 0, 0), yrot);\n    ro = rotate(ro, vec3(1, 0, 0), yrot);\n    rd = rotate(rd, vec3(0, 1, 0), zrot);\n    ro = rotate(ro, vec3(0, 1, 0), zrot);\n    \n    \n    float t0 = raymarchMapStart(ro, rd);\n    float t = raymarchMap(ro + rd * t0, rd);\n    vec4 background =  vec4(0.5, 0.5, 1.0, 1.0) * pow(length(uvCam), 0.33) * 0.5 * (hash(uvCam) * 0.1 + 0.9);\n\n    if(t > 6.0) {\n       // fragColor = vec4(0.02);\n        return vec4(0);\n    }\n    \n    vec3 p = ro + rd * (t + t0);\n    vec3 nor = getNormal(p);  \n    vec3 lp =  vec3(1);\n    vec3 green = vec3(0.3, 0.6, 0.2);\n\tvec3 diff = max(dot(nor, normalize(lp)), 0.0) * green * mix(0.1, 0.0, smoothstep(-0.5, -0.6, p.y));\n    float snd = texture(iChannel2, vec2(fragCoord.x/iResolution.x)).r;\n   \n    diff += (snd*snd) * computeLocalSphereLighting(p, nor);\n    //diff = nor;\n   \n   // vec3 col = max(diff, 0.02);\n    \n    return vec4( diff.rgb*diff.rgb, 1.);\n    \n    //vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n     fragColor=vec4(0,0,0,1);\n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    \n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n   // vec3 rd = normalize(vec3(uvCam, -1.05));\n   // vec3 ro = vec3(0.0, 0.0, 2.0);\n\n    float yrot = 0.0;\n    float zrot =  iTime * 0.25;\n    if (iMouse.z > 0.0) {\n     //  yrot += -4.0 * mouse.y;\n     // zrot = 4.0 * mouse.x;\n    }\n   // rd = rotate(rd, vec3(1, 0, 0), yrot);\n   // ro = rotate(ro, vec3(1, 0, 0), yrot);\n   // rd = rotate(rd, vec3(0, 1, 0), zrot);\n   // ro = rotate(ro, vec3(0, 1, 0), zrot);\n    \n    \n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd);//*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,2.,aurora(ro,rd));//*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.1;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n    \n    float snow = 0.0;\n    float gradient = (1.0-float(fragCoord.y / iResolution.x))*0.4;\n    float random = fract(sin(dot(fragCoord.xy,vec2(12.9898,78.233)))* 43758.5453);\n    for(int k=0;k<3;k++){\n        for(int i=0;i<7;i++){\n            float cellSize = 2.0 + (float(i)*3.0);\n\t\t\tfloat downSpeed = 0.3+(sin(iTime*0.4+float(k+i*20))+1.0)*0.00008;\n            vec2 uv = (fragCoord.xy / iResolution.x)+vec2(0.01*sin((iTime+float(k*6185))*0.6+float(i))*(5.0/float(i)),downSpeed*(iTime+float(k*1352))*(1.0/float(i)));\n            vec2 uvStep = (ceil((uv)*cellSize-vec2(0.5,0.5))/cellSize);\n            float x = fract(sin(dot(uvStep.xy,vec2(12.9898+float(k)*12.0,78.233+float(k)*315.156)))* 43758.5453+float(k)*12.0)-0.5;\n            float y = fract(sin(dot(uvStep.xy,vec2(62.2364+float(k)*23.0,94.674+float(k)*95.0)))* 62159.8432+float(k)*12.0)-0.5;\n\n            float randomMagnitude1 = sin(iTime*2.5)*0.7/cellSize;\n            float randomMagnitude2 = cos(iTime*2.5)*0.7/cellSize;\n\n            float d = 4.0*distance((uvStep.xy + vec2(x*sin(y),y)*randomMagnitude1 + vec2(y,x)*randomMagnitude2),uv.xy);\n\n            float omiVal = fract(sin(dot(uvStep.xy,vec2(32.4691,94.615)))* 31572.1684);\n            if(omiVal<0.08?true:false){\n                float newd = (x+1.0)*0.4*clamp(1.9-d*(15.0+(x*6.3))*(cellSize/1.4),0.0,1.0);\n                /*snow += d<(0.08+(x*0.3))/(cellSize/1.4)?\n                    newd\n                    :newd;*/\n                snow += newd;\n            }\n        }\n    }\n    \n    \n\n\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tuv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= 30.0 ;//+ sin(time);     //  set zoom size\n\tuv.y += -7.;\n    uv.x -= -1.;\n\n\tch_pos = ch_start;// i//+ vec2(sin(time),0.0);  // set start position\n\t\n\n    H A P P Y _ N E W _ Y E A R _ nl3 \n\n\tvec3 color = mix(ch_color, bg_color, 1.0- (0.08 / d));  // shading\n\t//color *= 0.4 + abs(sin(time*5.));\n\n    //Flicker fade in effect.\n    float tf_text = max(epsilon, abs(1.));\n    float bright_text = 1. * min(1.0, 1.0 - sin(tf_text * pi * 50.0) / (tf_text * pi * 1.3));\n\n\tcolor *= bright_text;\n\n    \n    vec4 rgb = mainImage2(fragCoord);\n\tfragColor.rgb += rgb.rgb + 3. * sqrt(col.rgb)*col.rgb;\n    \n    fragColor.rgb += .8 * vec3(snow);\n    fragColor.rgb += (.2 + 2.*texture(iChannel2, vec2(0.08,0.)).r) * color;\n    \n    \n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define N_SPHERES 400\n#define MIN_RADIUS 0.01\n#define PI 3.14159265359\n\nint seed = 93726;\nint randInt() { seed = seed*0x343fd + 0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(randInt())/32767.0; }\n\nvoid srand( ivec2 p, int frame ) {\n    int n = frame;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589; \n    n += p.y;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\nvec3 randomOnSphere( void ) {\n    float theta = (6.283185 / 32767.0) * float(randInt());\n    float u = (2.0 / 32767.0) * float(randInt()) - 1.0;\n    return vec3(sqrt(max(0.0, 1.0 - u * u)) * vec2(cos(theta), sin(theta)), u);\n}\n\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);   \n}\n\n\nfloat hash(float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nfloat xorshiftFloat(uint state) {\n    return float(xorshift(state)) / float(0xffffffffU);\n}\n\nfloat smin(float a, float b, float k) \n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h*h*k*0.25;\n}\n\n\nfloat dot2(vec2 a) { return dot(a, a); }\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb ) {\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat scene2(vec3 pp) {\n    vec3 p = pp;\n    p.y += 0.6;\n    float stepSize = 0.25;\n    vec3 q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    float repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    float scaleFactor = 0.2;\n\n    float scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    float a = sdCappedCone(q - vec3(0.0, 0.1, 0.0), 0.7, 1.0 * (scale * 0.75 + 0.25), 0.001) - 0.05;\n\n    float noiseScale = 40.0;     \n    float noiseAmplitude = 0.05;\n    float r = atan(q.x, q.z);\n    float noise1 = noise(vec2(r * scale, p.y) * noiseScale);\n    float noise2 = noise(vec2(r * scale, p.y) * noiseScale * 1.5);\n    float dis = sin(r * 8.0  * PI + repIndex * PI) * (length(p.xz) / scale);\n    \n    p.y += 0.1;\n    q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    // q.y += length(q.xz) * 0.075;\n    repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    a = smin(a, sdRoundedCylinder(q, 0.365 * (scale * 0.6 + 0.4), 0.01, 0.01), 0.1);\n\n    a = a + (dis * 0.02 + noise1 * noiseAmplitude + noise2 * noiseAmplitude * 0.5);\n    a = smin(a, ((p.y) + 0.1), 0.05);\n\n    return a;\n}\n\nfloat scene0(vec3 pp) {\n    vec3 p = pp;\n    p.y += 0.6;\n    float stepSize = 0.25;\n    vec3 q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    float repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    float scaleFactor = 0.2;\n\n    float scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    float a = sdCappedCone(q - vec3(0.0, 0.1, 0.0), 0.7, 1.0 * (scale * 0.75 + 0.25), 0.01) - 0.05;\n\n    p.y += 0.1;\n    q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    // q.y += length(q.xz) * 0.075;\n    repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    a = smin(a, sdRoundedCylinder(q, 0.365 * (scale * 0.6 + 0.4), 0.01, 0.01), 0.1);\n\n    a *= smoothstep(0.0, 0.4, p.y);\n    a = smin(a, ((p.y) + 0.1), 0.1);\n    a -= 0.04;\n    \n    return a;\n }\n \n\nfloat scene(vec3 pp) {\n    vec3 p = pp;\n    p.y += 0.6;\n    float stepSize = 0.25;\n    vec3 q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    float repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    float scaleFactor = 0.2;\n\n    float scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    float a = sdCappedCone(q - vec3(0.0, 0.1, 0.0), 0.7, 1.0 * (scale * 0.75 + 0.25), 0.001) - 0.05;\n\n    p.y += 0.1;\n    q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    // q.y += length(q.xz) * 0.075;\n    repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    a = smin(a, sdRoundedCylinder(q, 0.365 * (scale * 0.6 + 0.4), 0.01, 0.01), 0.1);\n\n    a = max(a, -((p.y) + 0.01));\n\n    a -= 0.02;\n    a = abs(a) - 0.02;\n    \n    return a;\n }\n \n\n\n#define PI2      6.28318531\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\nconst ivec3 iResolution3D = ivec3(64);\n\n\nconst uint PARTICLE_COUNT = uint(N_SPHERES);\nconst int slicesPerRow = 8;\n\nvec4 worldToVoxel(vec4 raw) {\n    return (raw + 3.0) * (1.0 / 6.0) * vec4(iResolution3D.x);\n}\n\nvec4 decodeEntity3D(sampler2D sampler, uint particleIndex)  {\n    ivec2 texCoord = ivec2(particleIndex, 0);\n    vec4 raw = texelFetch(sampler, texCoord, 0);\n\n    return worldToVoxel(raw);\n}\n\nivec3 to3D(uint flatId, ivec3 volumeSize) {\n    int x = int(flatId % uint(volumeSize.x));\n    int yz = int(flatId / uint(volumeSize.x));\n    int y = yz % volumeSize.y;\n    int z = yz / volumeSize.y;\n    return ivec3(x, y, z);\n}\n\nuint to1D(ivec3 coord, ivec3 volumeSize) {\n    return uint(coord.x) \n         + uint(coord.y) * uint(volumeSize.x)\n         + uint(coord.z) * uint(volumeSize.x * volumeSize.y);\n}\n\n\nivec2 to2D(uint flatId, ivec3 volumeSize) {\n    ivec3 c3D = to3D(flatId, volumeSize);\n    int sliceIndex = c3D.z;\n    int row = sliceIndex / slicesPerRow;\n    int col = sliceIndex % slicesPerRow;\n    return ivec2(c3D.x + col * volumeSize.x, c3D.y + row * volumeSize.y);\n}\n\n\nivec3 from2D(ivec2 texCoord, ivec3 volumeSize) {\n    int col = texCoord.x / volumeSize.x;\n    int x = texCoord.x % volumeSize.x;\n    int y = texCoord.y % volumeSize.y;\n    int z = col + (texCoord.y / volumeSize.y) * slicesPerRow;\n    return ivec3(x, y, z);\n}\n\n\nuvec4 fetchClosest3D(vec3 position, sampler2D voroBuffer) {\n    ivec3 ipos = ivec3(clamp(floor(position), vec3(0.0), vec3(iResolution3D) - 1.0));\n    \n    uint flatId = to1D(ipos, iResolution3D);\n    ivec2 texCoord2D = to2D(flatId, iResolution3D);\n    \n    return floatBitsToUint(texelFetch(voroBuffer, texCoord2D, 0));\n}\n\nvoid sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec3 center,\n        sampler2D iChannel0\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    vec4 e = decodeEntity3D(iChannel0, index);\n    float dist = length(center - e.xyz) - e.w;\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle) {\n    return mix(dot(p, axis) * axis, p, cos(angle)) + sin(angle) * cross(axis, p);\n}\n\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float getAvailableSpaceSDF(vec3 p, int currentIndex) {\n    float shapeSDF = scene(p);\n    \n    uvec4 fetchedClosest = fetchClosest3D(worldToVoxel(p.xyzz).xyz, iChannel1);\n\n    for(int i = 0; i < 4; i++) {\n        uint sphereIdx = fetchedClosest[i];\n        if(sphereIdx == uint(-1)) { continue; }\n        vec4 circle = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n        if(circle.w <= 0.0) continue;\n\n        float currentCircleSDF = length(p - circle.xyz) - circle.w * 4.0;\n        shapeSDF = max(-currentCircleSDF, shapeSDF);\n    }\n    \n    \n    for(int i = 0; i < (currentIndex % 4); i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(i, 0), 0);\n        if(circle.w <= 0.0) continue;\n        \n        float currentCircleSDF = length(p - circle.xyz) - circle.w * 4.0;\n        \n        shapeSDF = max(-currentCircleSDF, shapeSDF);\n    }\n    \n    return shapeSDF;\n}\n\nvec4 gtSDG(vec3 pos) {\n    float eps = 0.02;\n    vec3 n;\n    float d = scene(pos);\n    n.x = scene(vec3(pos.x + eps, pos.y, pos.z)) - d;\n    n.y = scene(vec3(pos.x, pos.y + eps, pos.z)) - d;\n    n.z = scene(vec3(pos.x, pos.y, pos.z + eps)) - d;\n\n    return vec4(n, d);\n}\n\nvec3 availableSpaceSDG(vec3 pos, int currentIndex) {\n    float eps = 0.02;\n    vec3 n;\n    float d = getAvailableSpaceSDF(pos, currentIndex);\n    n.x = getAvailableSpaceSDF(vec3(pos.x + eps, pos.y, pos.z), currentIndex) - d;\n    n.y = getAvailableSpaceSDF(vec3(pos.x, pos.y + eps, pos.z), currentIndex) - d;\n    n.z = getAvailableSpaceSDF(vec3(pos.x, pos.y, pos.z + eps), currentIndex) - d;\n\n    return n;\n}\n\nvec3 snapToMedialAxis(vec3 candidate, int currentIndex) {\n    vec3 pos = candidate;\n    float s = 0.1;   \n    float alpha = 0.1;  \n    float beta = 0.5;    \n\n    for(int iter = 0; iter < 32; iter++) {\n        vec3 g = gtSDG(pos).xyz; \n        float mg = length(g);        \n        if(mg < 1e-4) break; \n        \n        vec3 dir = g / mg;\n        \n        float currentSDF = getAvailableSpaceSDF(pos, currentIndex);        \n        float stepSize = s;\n        bool stepAccepted = false;\n\n        while(stepSize > 1e-4) {\n            vec3 newPos = pos - stepSize * dir;            \n            float newSDF = getAvailableSpaceSDF(newPos, currentIndex);\n            \n            if(newSDF <= currentSDF - alpha * stepSize * mg) {\n                pos = newPos;\n                stepAccepted = true;\n                break;\n            }\n            \n            stepSize *= beta;\n        }\n        \n        if(!stepAccepted) {\n            break;\n        }\n        \n        s = stepSize;\n    }\n    \n    return pos;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    if(fragCoord.y > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    int circleIndex = int(fragCoord.x);\n    \n    if(circleIndex >= N_SPHERES) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 oldData = texelFetch(iChannel0, ivec2(circleIndex, 0), 0);\n    vec3 center = oldData.xyz;\n    float radius = oldData.w;\n    \n    if(circleIndex > iFrame) {\n        fragColor = oldData;\n        return;\n    }\n    \n    srand(ivec2(fragCoord), iFrame);\n    if(circleIndex == iFrame && iFrame < N_SPHERES) {\n        float bestScore = -1.0;\n        vec3 bestPos = randomOnSphere() * frand();\n        \n        for(int c = 0; c < 16; c++) {\n            vec3 candidate;\n            float spaceSDF = 0.0;\n            \n            candidate = bestPos + randomOnSphere() * frand() * frand() * mix(0.05, 1.0, float(c) / 7.0);\n            spaceSDF = getAvailableSpaceSDF(candidate, circleIndex);\n\n            if(spaceSDF > 0.1) {\n                vec3 g = availableSpaceSDG(candidate, circleIndex);\n                candidate -= g * spaceSDF * 1.001;\n            }\n                        \n            float score = -spaceSDF;\n            \n            vec3 snapped = snapToMedialAxis(candidate, circleIndex);\n            float snappedSpaceSDF = getAvailableSpaceSDF(snapped, circleIndex);\n            float snappedScore = -snappedSpaceSDF;\n            \n            if(snappedSpaceSDF < 0.0 && snappedScore > score) {\n                candidate = snapped;\n                score = snappedScore;\n            }\n            \n            \n            if(score > bestScore) {\n                bestScore = score;\n                bestPos = candidate;\n            }\n        }\n        \n        if(bestScore > MIN_RADIUS) {\n            center = bestPos;\n            radius = max(bestScore, MIN_RADIUS);\n        } else {\n            center = vec3(0.0);\n            radius = 0.0;\n        }\n    }\n    fragColor = vec4(center, radius);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nvoid fetchAndSortClosest3D(\n    inout vec4 distances, \n    inout uvec4 indices,\n    in vec3 samplePoint,\n    in vec3 voxelCenter\n) {\n    uvec4 ids = fetchClosest3D(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, indices, ids[i], voxelCenter, iChannel0);\n    }\n}\n\n\nfloat randomFloat(inout uint state) {\n    state ^= state >> 16;\n    state *= 0x7feb352dU;\n    state ^= state >> 15;\n    state *= 0x846ca68bU;\n    state ^= state >> 16;\n    return float(state) / 4294967296.0;\n}\n\nvec3 randomDir3D(inout uint state) {\n    float z  = randomFloat(state) * 2.0 - 1.0;  // range [-1,1]\n    float az = randomFloat(state) * PI2;\n    float r  = sqrt(1.0 - z * z);\n    float x  = r * cos(az);\n    float y  = r * sin(az);\n    return vec3(x, y, z);\n}\n\nuint rngSeed = 314159265u;\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(fragCoord);\n    ivec2 maxSize = ivec2(slicesPerRow * iResolution3D.x);\n    if (any(greaterThanEqual(fc, maxSize))) {fragColor = vec4(0.0); return; }\n  \n    ivec3 cellCoord = from2D(fc, iResolution3D); \n    vec3 voxelCenter = vec3(cellCoord) + 0.5; \n    \n    vec4 bestDistances = vec4(FLOAT_INF);\n    uvec4 closestIndices = uvec4(uint(-1));\n    \n    if (iFrame == 0) {\n        closestIndices = uvec4(nextUint(), nextUint(), nextUint(), nextUint()) % 63u;\n    }\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    float rad = 3.0;\n\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n\n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, nextUint() % PARTICLE_COUNT, voxelCenter, iChannel0);\n    }\n    \n\n    fragColor = uintBitsToFloat(closestIndices);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 getNormal(vec3 p) {\n\tfloat d = scene2(p);\n    vec2 e = vec2(.05, 0);\n    \n    vec3 n = d - vec3(\n        scene2(p-e.xyy),\n        scene2(p-e.yxy),\n        scene2(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int j = int(fragCoord.x);\n    vec4 lastCircle = texelFetch(iChannel1, ivec2(j, 0), 0);\n    vec4 circle = texelFetch(iChannel0, ivec2(j, 0), 0);\n    float fun = 0.05;\n    vec3 n = getNormal(circle.xyz);\n    vec3 t = cross(n, rotate(vec3(1, 0, 0), vec3(0, 1, 0), iTime + float(j)));\n\n    \n    vec3 animation = t * 0.025;\n    circle.xyz += animation;\n    fragColor = circle;\n}","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"X3tczS","date":"1735281415","viewed":226,"name":"Christmas Tree Visualizer","username":"orblivius","description":"merry christmas! <remixed by Orblivius>","likes":9,"published":3,"flags":32,"usePreview":1,"tags":["3d","raymarching","christmas","fft","wave","sdf","light","sphere","particles","tree","point","packing","medialaxis","medial"],"hasliked":0,"parentid":"","parentname":""}}