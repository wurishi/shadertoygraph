{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.141592653\n\n// 计算从uv到角度为angle，半径为r的圆弧的最短距离，s为线宽\n// angle的范围[0.0,180.0] 从Y轴方向向两边生长\nfloat sdArc(vec2 uv, float angle, float r, float s) {\n    // 将角度转换为弧度，并确保角度在0到PI之间\n    angle = angle * (PI / 180.0);\n    angle = mod(angle, PI);\n    \n    // 计算圆弧的方向向量\n    vec2 v = vec2(sin(angle), cos(angle));\n    uv.x = abs(uv.x);\n    \n    // 计算uv和圆弧方向向量的叉乘，判断uv是否在圆弧的一侧\n    float arrow = uv.x * v.y - uv.y * v.x;\n    \n    // 如果uv在圆弧的一侧，则计算uv到圆弧的距离减去线宽s\n    if (arrow > 0.0) {\n        return distance(uv, v * r) - s;\n    } else {\n        // 否则，计算uv到圆的直线距离减去半径r再减去线宽s\n        return abs(length(uv) - r) - s;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec3 color = vec3(1.0);\n    \n    // 计算当前时间对应的弧度值，并传入sdArc函数\n    // 这里iTime*10.0将时间转换为角度，乘以10使得动画速度更快\n    float d = sdArc(uv, 135.0, 0.5, 0.05);\n    \n    // 使用step函数将距离d转换为二值，大于0.01的为1，小于等于0.01的为0\n    d = smoothstep(0.0,0.01,d);\n    \n    // 使用mix函数将颜色混合，d为1时使用vec3(0.0)，d为0时使用vec3(1.0)\n    color = mix(vec3(0.0), color, d);\n    \n    // 设置最终的片元颜色\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"X3tcWH","date":"1735021293","viewed":38,"name":"cc_circle03","username":"hero2828","description":"弧度","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""}}