{"ver":"0.1","info":{"id":"3tSfD3","date":"1599944054","viewed":220,"name":"Hex-pattern Circle Render","username":"logangilmour","description":"Playing around with a roughly hex-pattern circle render. Actual graphics (very cool dancing tree distance field march) come from here: https://www.shadertoy.com/view/4lVyzh. Full-screen it for full effect!\n\nClick and drag left and right to change the size","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float scale = floor(iMouse.x/iResolution.x*8.)+2.;\n    vec2 sz = vec2(2.,2.)*scale;\n    vec2 hsz = vec2(1,1.)*scale;\n    vec2 uvi = floor(U/sz);\n    float offset = mod(uvi.y,2.);\n    vec2 uvf = mod((mod(U,sz)-vec2(hsz.x*offset,hsz.y))/vec2(hsz.x,hsz.x)+1.,2.)-1.;\n    \n    vec4 col = texture(iChannel0,(floor(U/sz+vec2((1.-offset)*float(uvf.x<0.5f)*0.5,0.))-0.5)/iResolution.xy);\n    highp vec3 hdrColor = col.rgb*2.*clamp((1.1-length(uvf))*2.,0.,1.);\n    \n    hdrColor = pow(hdrColor,vec3(.7));\n    float over = dot(clamp(hdrColor-vec3(1.,1.,1.),0.,1.),vec3(1.,1.,1.));\n\n    hdrColor+=vec3(over);\n    \n    C.rgb = hdrColor;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DOUBLE 2.\n\n\n#define pi 3.1415926\nvec3 light;\nfloat ln (vec3 p, vec3 a, vec3 b, float R) { \n    float r = dot(p-a,b-a)/dot(b-a,b-a);\n    r = clamp(r,0.,1.);\n    p.x+= 0.2*sqrt(R)*smoothstep(1.,0.,abs(r*2.-1.))*cos(pi*(2.*iTime));\n    return length(p-a-(b-a)*r)-R*(1.5-0.4*r);\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat map (vec3 p) {\n    float l = length(p-light)-1e-2;\n    l = min(l,abs(p.y+0.4)-1e-2);\n    l = min(l,abs(p.z-0.4)-1e-2);\n    l = min(l,abs(p.x-0.7)-1e-2);\n    p.y += 0.4;\n    p.z += 0.1;\n    p.zx *= ro(.5*iTime);\n    vec2 rl = vec2(0.02,.25+ 0.01*sin(pi*4.*iTime));\n    for (int i = 1; i < 11; i++) {\n        \n        l = min(l,ln(p,vec3(0),vec3(0,rl.y,0),rl.x));\n    \tp.y -= rl.y;\n        p.xy *= ro(0.2*sin(3.1*iTime+float(i))+sin(0.222*iTime)*(-0.1*sin(0.4*pi*iTime)+sin(0.543*iTime)/max(float(i),2.)));\n        p.x = abs(p.x);\n        p.xy *= ro(0.6+0.4*sin(iTime)*sin(0.871*iTime)+0.05*float(i)*sin(2.*iTime));\n        p.zx *= ro(0.5*pi+0.2*sin(0.5278*iTime)+0.8*float(i)*(sin(0.1*iTime)*(sin(0.1*pi*iTime)+sin(0.333*iTime)+0.2*sin(1.292*iTime))));\n        \n        rl *= (.7+0.015*float(i)*(sin(iTime)+0.1*sin(4.*pi*iTime)));\n        \n        l=min(l,length(p)-0.15*sqrt(rl.x));\n    }\n\treturn l;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float o = 1e3;\n    for (int i = 0; i < 100; i++) {\n        float l = map(p);\n    \tp += l*d;\n        if (l < 1e-4)break;\n    }\n    return p;\n}\nvec3 norm (vec3 p) { // iq\n\t\tvec2 e = vec2 (.001,0.);\n\t\treturn normalize(vec3(\n\t\t\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\t\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\t\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t\t\t));\n\t}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n        float scale = floor(iMouse.x/iResolution.x*8.)+2.;\n    vec2 sz = vec2(2.,2.)*scale;\n    vec2 hsz = vec2(1,1.)*scale;\n    \n    vec2 R = iResolution.xy/sz;\n \tvec2 sentinel = U/iResolution.xy*sz;\n    float offset = floor(mod(U.y,2.));\n if(sentinel.x>1.||sentinel.y>1.){\n  return;   \n }\n    U.x+=(1.-offset)*.5;\n    light = vec3(0.2*sin(iTime),0.5,-.5);\n    //if (iMouse.z > 0.) light = vec3(vec2(-0.5,0.5)*0.+0.7*(iMouse.xy-0.5*R)/R.y,-.3);\n    U = (U-0.5*R)/R.y;\n    vec3 p = vec3(0,0,-1);\n    vec3 d = normalize(vec3(U,1));\n    p =  march(p,d);\n    vec3 n = norm(p);\n\tC = 0.6+0.4*sin(1.1*vec4(1,2,3,4)*dot(d,n));\n    vec3 D = light-p;\n    d = normalize(D);\n    vec3 lp = march(p+d*1e-2,d);\n    C *= 2.5*(dot(d,n))*(.3+0.7*length(lp-p)/length(light-p));\n    C = atan(C)/pi*2.;\n}","name":"Buffer A","description":"","type":"buffer"}]}