{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n\n#define R iResolution\n\n//Do a little filtering\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    O = texture(iChannel1, I/R.xy)/2.;\n    O += texture(iChannel1, (I+vec2(1,0))/R.xy)/8.;\n    O += texture(iChannel1, (I-vec2(1,0))/R.xy)/8.;\n    O += texture(iChannel1, (I+vec2(0,1))/R.xy)/8.;\n    O += texture(iChannel1, (I-vec2(0,1))/R.xy)/8.;\n  \n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define W 16\n\nuint MRHI(uint l, uvec3 c){\n\n    return (\n    (((c.x)>>l) * 591558727u)^\n    (((c.y)>>l) * 1500450271u)^\n    (((c.z)>>l) * 3267000013u)^\n    (l        * 54218443u));\n}\n\nvec2 packID(int id){\n    return vec2(id%2048,id/2048);\n}\n\nint unpackID(vec2 x){\n    return int(x.x)+int(x.y)*2048;\n}\n\n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\nint RayDirToInd(vec3 dir){\n    ivec3 XYFace = RayDirToXYFace(dir);\n    return XYFace.x + XYFace.y * 1024 + XYFace.z * 1024 * 1024;\n}\n\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleIndex(int ind){\\\n    ivec3 XYFace = ivec3(ind%1024, (ind/1024)%1024, ind/(1024*1024));\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dX3Rr"}],"inputs":[{"channel":0,"type":"cubemap","id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"getters\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int index = RayDirToInd(rayDir);\n    if(index < 1024*1024*3){  //Index in 1st half of buffer - hash table\n    \n        fragColor = sampleIndex(index);\n        fragColor.w-=.006; //Decay all mass\n        \n        //Check for things to enter in\n        vec4 c = sampleIndex(index + 1024*1024*3);\n        if(unpackID(c.zw)==index){ //If ther is data with dest=me then save it off replacing to handle collisions\n            fragColor=vec4(c.xy,0,1);\n        }\n        if(iFrame<3){\n            fragColor = vec4(0);\n        }\n    } else { //Index in 2nd half of buffer - data going into hash table\n        int s_index = index-1024*1024*3;\n        int stage = iFrame%15;\n        //15 stages of jump flooding, init with a collection of points x color x time \n        if(stage==0){ //Init stage generate data to write to the hash table\n            \n            //write 5000 points into each W levels of the octree into the hash table\n            int i = s_index%W;\n            int id = (s_index/W)%5000;\n            \n            \n            //Interpolate 1000 points in time\n            float Time = float(iFrame/15)/60. + float(id%1000)/1000./60.;\n            \n            //Points go along\n            vec3 uv = vec3(sin((-vec3(5,6,7)+vec3(2.23,3.3463,4.65)*float(id/1000))*Time*20.));\n            uv = normalize(uv)*(.8+.06*sin(float(id/1000)));\n            if(id/1000==0) uv*=sin(Time*5000.); //Zoom in and out the middle\n            \n            //Scale up into 2^W uint coords and hash\n            uint c = MRHI(uint(i),uvec3(uv*(float(1<<W)/2.) + float(1<<W)/2.));   \n            \n            //Want to send this color and time data to this dest in 1st half of buffer  \n            int dest = int(c%(1024u*1024u*3u));    \n            float color = .5+.5*cos(float(2)*float(id/1000));\n            fragColor = vec4(color, mod(Time,2.), packID(dest) );\n        } else { //Jump flood stages - try to get data closer to its dest\n            fragColor = sampleIndex(index); //Init with current\n            int d = abs(s_index - unpackID(fragColor.zw) ); //How close is current data to dest?\n            \n            //Scan varying distances away for data that might need to come this way\n            int dist = int(pow(1.9,float(15-stage)));\n            for(int n = 1; n <= 20; n++){\n                //Sample some data check if it is closer and save it if it is\n                vec4 c = sampleIndex(1024*1024*3 + ((s_index + dist*n)%(1024*1024*3)));\n                int cd = abs(s_index - unpackID(c.zw));\n                if(cd<d || fragColor.w==0.){\n                    d = cd;\n                    fragColor = c;\n                }\n            }\n            \n        }\n    }\n    \n}","name":"Cube A","description":"","type":"cubemap"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"cubemap","id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"getters\n\n#define R iResolution\n\n#define eps 1e-6\n\n// For each marching option, take a realative coordinate from -1 to 1 r0, a uint coordinate, quadtree level, ray direction\n// The coordinate must be on the cube from -1 to 1 and represents the location in the scene in tandem with uint coord\n\n\n//Advance ray through a cube\n//At l=0 c will change by 1\n//Only time ray advances\nvoid goThru(inout vec3 r0,inout uvec3 c, uint l, vec3 rd){\n\n    //Calc where ray advances to in the cube\n    vec3 v0 =  1. - r0;\n    vec3 v1 = -1. - r0;\n    vec3 m0 = v0/rd;\n    vec3 m1 = v1/rd;\n    float b = 1e10;\n    m0 += b*vec3(lessThan(m0,vec3(eps)));\n    m1 += b*vec3(lessThan(m1,vec3(eps)));\n    vec3 m = min(m0,m1);\n    float lm = min(min(m.x,m.y),m.z);\n    \n    r0 += rd*lm;\n    \n    //which face do we exit thru\n    vec3 d = r0*vec3(greaterThan(abs(r0),vec3(1.-eps)));\n    \n    //bring r0 to the opposite wall since its against a new coord\n    r0 -= 2.*d;\n    \n    //Change the coord to the cube on the exit face\n    if(dot(d,vec3(1))>0.){\n        c += uvec3(abs(d)*1.5)<<(l);\n    } else {\n        c -= uvec3(abs(d)*1.5)<<(l);\n    }\n    \n}\n\n//Go up a level in the quadtree. We have just passed detail and this is better than goThru\nvoid goUp(inout vec3 r0,inout uvec3 c, inout uint l, vec3 rd){\n    \n    vec3 r = r0;\n    \n    \n    uint m = ~((2u<<l) - 1u);\n    \n    //Update r0 to parent cooerds\n    r = vec3(greaterThan(c&(1u<<l),uvec3(0))) + r*.5-.5;\n    \n    if(any(greaterThan(abs(r),vec3(1.-eps)))){\n        l++;\n        r0=r;\n        c &= m; //Mask bits used in child coords to get parnt coord\n    } else {\n        //If not on the edge of the parent cube then we cant go up\n        goThru(r0,c,l,rd);\n    }\n    \n}\n\n//There is detail in this cube and the child nodes have to be marched through\nvoid goDown(inout vec3 r0,inout uvec3 c, inout uint l, vec3 rd){\n    //Which of the 8 sub cubes\n    vec3 cd = vec3(greaterThan(r0,vec3(0)));\n    l--;\n    c += uvec3(cd)<<l;\n    \n    //Adjust r0 depending on face getting subdivided\n    if(abs(r0.x)>abs(r0.y) && abs(r0.x)>abs(r0.z)){\n        r0.yz = (fract(r0.yz)*2.-1.);\n    } else {\n        if(abs(r0.y)>abs(r0.z)){\n            r0.xz = (fract(r0.xz)*2.-1.);\n        } else {\n            r0.xy = (fract(r0.xy)*2.-1.);\n        }\n    }\n    \n    \n}\n\n\n\nvec4 march(vec3 r0,vec3 rd){\n    vec4 col = vec4(0);\n    vec3 r = r0;\n    \n    \n    \n    //Run up to the top level cube\n    vec3 a0 = abs(r0);\n    vec3 ad = abs(rd);\n    vec3 v = a0 - 1.;\n    vec3 m = v/ad;\n    float lm = max(max(m.x,m.y),m.z);\n    r+=lm*rd;\n    \n    //Check if missed the cube\n    a0 = abs(r);\n    if(a0.x>1. || a0.y >1. || a0.z > 1.){\n        a0 = abs(r+rd*1e-6);\n        if(a0.x>1. || a0.y >1. || a0.z > 1.){\n            return vec4(0); \n        }\n    }\n    \n\n    \n    uint l = uint(W);\n    uvec3 c = uvec3(0); // Setup at root node\n    float y = 1.;\n    \n    //Go in a bit\n    goDown(r, c, l, rd);\n    goDown(r, c, l, rd);\n    \n    for(int n = 0; n < 200; n++){\n    \n        uint i = MRHI(l+1u,c);\n        vec4 s = sampleIndex(int(i%(1024u*1024u*3u)));\n        uvec3 cl = c; \n        if(s.w<.0  && l<uint(W-1)){\n            goUp(r, c, l, rd);\n        } else {\n        \n            i = MRHI(l,c);\n            vec4 sp = sampleIndex(int(i%(1024u*1024u*3u)));\n            \n            \n            if(sp.w<.0 || l==0u){\n                goThru(r, c, l, rd);\n            } else {\n                if(.5<mod(float(iFrame)/60.-s.y*15.+.2,2.*15.))\n                    col += texture(iChannel1,s.xx)*exp(-3.2+(float(W)-float(l))*.2)*y*s.w;\n                y*=.98;\n                goDown(r, c, l, rd);\n            }\n        }\n        if(any(bvec3(c & (0xffffffffu - ((1u<<W)-1u) )  ))) {\n            return col;\n        }\n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n\n        vec3 r0 = vec3((I-R.xy/2.)/R.y,1);\n        vec3 rd = vec3(0,0,-1);\n        \n        float p = 2.*(iMouse.y/R.y*2.-1.)*3.14/2. + iTime/23.45;\n        float y = 2.*(1.-iMouse.x/R.x*2.)*3.14 + iTime/14.;\n        \n        r0.yz = mat2(r0.yz,-r0.z,r0.y) * vec2(cos(p), sin(p));\n        rd.yz = mat2(rd.yz,-rd.z,rd.y) * vec2(cos(p), sin(p));\n        \n        r0.xz = mat2(r0.xz,-r0.z,r0.x) * vec2(cos(y), sin(y));\n        rd.xz = mat2(rd.xz,-rd.z,rd.x) * vec2(cos(y), sin(y));\n        \n        rd /= length(rd);\n        r0 *= 2.;\n        O = march(r0,rd);\n    \n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"NsGcDK","date":"1655605093","viewed":217,"name":"Hash octree 2","username":"rory618","description":"Adaptation of \"Impossibly big canvas\" to 3D. Using jump flood to write data to the hash table more quickly","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","hash","octree"],"hasliked":0,"parentid":"","parentname":""}}