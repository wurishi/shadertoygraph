{"ver":"0.1","info":{"id":"wtXXzS","date":"1563348678","viewed":63,"name":"3d first","username":"tfkfan","description":"test 3d","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Two structs are used. Ray structs represent light rays. In this example\n// a simple ray struct is used with only two fields. More fields are used in\n// more advanced ray tracers.\n\n// Ray represents a ray of light's origin and direction\nstruct Ray {\n\tvec3 origin; // Origin\n\tvec3 direction; // Direction\n};\n\n// Sphere represents of centre and radius of a sphere\nstruct Sphere {\n\tvec3 center;  // Center\n\tfloat radius; // Radius\n};\n\nvec4 diffuse(in vec3 surface, in vec3 center, in vec4 color, in vec3 litePos) {\n\t// Surface normal\n\tvec3 n = normalize(surface - center);\n  \n\t// Light direction from surface\n\tvec3 l = normalize(litePos - surface);\n\n    vec4 result = color * max(0.0, dot(n, l));\n        \n    //dark side light\n    float d = 0.1;\n    float nd = 0.3;\n    if(length(result) <=d && abs(n.z) <=nd)\n        result =  vec4(1.0, 0.0, 0.0, 1.0);\n  \n\t// The diffuse equation\n\treturn result;\n}\n\n// https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, calculate the origin-surface distance\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant); //\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    uv.x = 1.5*uv.x;\n\n\tvec3 pixelPos = vec3(uv.x, uv.y, 0);\n\n    // The eye position in this example is fixed.\n    vec3 eyePos = vec3(0, 0, -4); // Some distance in front of the screen\n    \n\t// The ray for the raytrace - which is just intersectSphere in this tutorial\n\tvec3 rayDir = normalize(pixelPos - eyePos);\n    Ray ray = Ray(eyePos, rayDir);\n    \n    Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0); // Position and size of sphere\n\n\t// Does rayDirUnit ray from ndcEye intersect the sphere?\n\tfloat eyeToSphere = intersectSphere(ray, sphere);\n\n    \n\t// If positive, then we draw a pixel of the sphere\n\tif (eyeToSphere >= 0.)\n\t{\n\t\t// Choose a diffuse colour\n\t\tvec4 diffuseColour =  vec4(1.,1.,1.,1);\n\n\t\t// Choose an ambient colour\n\t\tvec4 ambientColour =  vec4(vec3(0.03),1.0);\n\n        // Position of a white light\n        float r = 20.0;\n        float t = iTime/2.0;\n        vec3 litePos = vec3(r*cos(t), 0., r*sin(t));\n        \n\t\tfragColor = ambientColour + diffuse(eyePos + eyeToSphere * rayDir, sphere.center, diffuseColour, litePos);\n\t} else\n        // Otherwise we draw the colour of the background\n\t\tfragColor = vec4(0, 0, 0, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}