{"ver":"0.1","info":{"id":"MlSfWw","date":"1515956261","viewed":100,"name":"[comfy] Raycasting","username":"ComfyKernel","description":"It's a test thing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool rayCube(in vec3 size, in vec3 pos, in vec3 ray, out vec3 color, in vec3 camPos) {\n    color = vec3(1.0,0.0,0.0);\n    \n\tif(ray.x>pos.x&&ray.x<pos.x+size.x&&\n       ray.y>pos.y&&ray.y<pos.y+size.y&&\n       ray.z>pos.z&&ray.z<pos.z+size.z) {\n     \treturn true;   \n    }\n    \n    return false;\n}\n\nbool raySphere(in float size, in vec3 pos, in vec3 ray, out vec3 color, in vec3 camPos) {\n    color = vec3(0.5,1.0,0.0);\n    \n\tif(distance(ray,pos)<size) {\n     \treturn true;   \n    }\n    \n    return false;\n}\n\nbool rayTexture(in vec3 size, in vec3 pos, in vec3 ray, out vec3 color, in vec3 camPos) {\n    color = vec3(texture(iChannel0,ray.xz/size.xz));\n    \n    if(ray.x>pos.x&&ray.x<pos.x+size.x&&\n       ray.y>pos.y&&ray.y<pos.y+(texture(iChannel0,ray.xz/size.xz).y*size.y)&&\n       ray.z>pos.z&&ray.z<pos.z+size.z) {\n     \treturn true;   \n    }\n    \n    return false;\n}\n\nvec3 rayMarch(in vec3 camPos, in vec3 camDir) {\n    vec3 ray=camPos;\n    \n    vec3 color;\n    \n    for(int i=0; i<1000; ++i) {\n        // ray+=(camDir*vec3(i/50))/50.0;\n        ray+=(camDir*vec3(i/100))/100.0;\n        \n        if(rayCube(vec3(1),vec3(2.0,0.0,0.0),ray,color,camPos)) {\n         \treturn color;  \n        }\n        \n        if(rayCube(vec3(1),vec3(-2.0,0.0,0.0),ray,color,camPos)) {\n         \treturn vec3(0.0,1.0,0.0);  \n        }\n        \n        if(rayCube(vec3(1),vec3(0.0,-2.0,0.0),ray,color,camPos)) {\n         \treturn vec3(0.0,1.0,1.0);  \n        }\n        \n        if(rayTexture(vec3(50.0,3.0,50.0),vec3(-25.0,-2.0,-25.0),ray,color,camPos)) {\n            return color;\n        }\n        \n        if(raySphere(2.0,vec3(5.0,2.0,2.0),ray,color,camPos)) {\n         \treturn color;   \n        }\n    }\n   \n    return vec3(0.0,0.0,0.0);\n}\n\n\n// MATRIX MATH //\n\n\nmat4 mat_identity() {\n    mat4 mat;\n    mat[0][0]=1.0;\n    mat[1][1]=1.0;\n    mat[2][2]=1.0;\n    mat[3][3]=1.0;\n    \n    return mat;\n}\n\nmat4 mat_translate(in vec3 pos) {\n \tmat4 mat=mat_identity();\n    \n    mat[3][0]=pos.x;\n    mat[3][1]=pos.y;\n    mat[3][2]=pos.z;\n    \n    return mat;\n}\n\nmat4 mat_scale(in vec3 size) {\n \tmat4 mat;\n    \n    mat[0][0] = size.x;\n    mat[1][1] = size.y;\n    mat[2][2] = size.z;\n    mat[3][3] = 1.0;\n    \n    return mat;\n}\n\nmat4 mat_rotate(in float rotation, in int direction) {\n \tmat4 mat=mat_identity();\n    \n    switch(direction) {\n     \tcase 0:\n        \tmat[1][1]= cos(rotation);\n        \tmat[2][1]=-sin(rotation);\n        \tmat[1][2]= sin(rotation);\n        \tmat[2][2]= cos(rotation);\n        \tbreak;\n        case 1:\n        \tmat[0][0]= cos(rotation);\n        \tmat[2][0]= sin(rotation);\n       \t\tmat[0][2]=-sin(rotation);\n        \tmat[2][2]= cos(rotation);\n        \tbreak;\n        case 2:\n        \tmat[0][0]= cos(rotation);\n        \tmat[1][0]=-sin(rotation);\n        \tmat[0][1]= sin(rotation);\n        \tmat[1][1]= cos(rotation);\n        \tbreak;\n        \n        default:\n        \tbreak;\n    }\n    \n    return mat;\n}\n\nvec3 mat_apply(in mat4 A, in vec3 B) {\n \treturn (A*vec4(B,1.0)).xyz;   \n}\n\n// NOT MATRIX MATH //\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec3 dir = vec3(vec2(uv.x-0.5,(uv.y-0.5)/(iResolution.x/iResolution.y))*vec2(2.0),1.0);\n    \n    mat4 rotMat = mat_rotate(iMouse.x/30.0,1)*mat_rotate(-iMouse.y/30.0,0);\n    \n    fragColor = vec4(rayMarch(vec3(sin(iTime/3.0),3.0,cos(iTime/3.0)),normalize(mat_apply(rotMat,dir))),1.0);\n}","name":"Image","description":"","type":"image"}]}