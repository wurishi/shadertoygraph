{"ver":"0.1","info":{"id":"4lVSRt","date":"1486582656","viewed":804,"name":"Space Invaders Game","username":"Mourtz","description":"Original shader: http://glslsandbox.com/e#424.8\n\nControls:\n- Left and Right Arrow keys or mouse to move your spacecraft\n- Up Arrow to shoot\n- Press P to pause the game\n- Press SPACE to reset","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["procedural","2d","game","wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OldTVScreenEffect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb + texture(iChannel1,uv).rgb;\n\n#ifdef OldTVScreenEffect\n    // screen curve\n    uv \t\t= (uv - 0.5) * 2.0;\n    uv     *= 1.1;\t\n    uv.x   *= 1.0 + pow((abs(uv.y) * 0.1), 2.0);\n    uv.y   *= 1.0 + pow((abs(uv.x) * 0.15), 2.0);\n    uv \t \t= uv / 2.0 + 0.5;\n    uv \t\t= uv *0.92 + 0.04;\n    uv      = clamp(uv, 0.0, 1.0);\n    \n    // brightness\n    float bright = - 0.05;\n    col += bright;\n    col = clamp(col * 0.6 + 0.4 * col * col, 0.0, 1.0);\n    \n    // vignette effect\n    float vig = (0.0 + 16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));\n    col *= pow(vig, 0.3) * vec3(2.66, 2.94, 2.66);\n    \n    // scanline effect\n    float scans = 0.35 + 0.35 * sin(3.5 + uv.y * iResolution.y * 1.5);\n    col *= 0.3 + 0.7 * pow(scans, 1.7);\n#endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* \n * Game Logic\n */\n\n// storage register/texel addresses\nconst vec2 txPlayerPos \t\t= vec2(0.0,0.0);\nconst vec2 txState     \t\t= vec2(1.0,0.0);\nconst vec2 txIsShooting     = vec2(2.0,0.0);\nconst vec2 txProjectilePos  = vec2(2.0,1.0);\nconst vec2 txAliensOfst   \t= vec2(3.0,1.0);\nconst vec2 txAliensOfst2 \t= vec2(3.0,2.0);\nconst vec2 txScore\t\t\t= vec2(4.0,0.0);\nconst vec2 txLives\t\t\t= vec2(5.0,0.0);\nconst vec2 txResolution\t\t= vec2(6.0,0.0);\n\nconst vec3 clSpace = vec3(0.05, 0.07, 0.15);\nconst vec3 clShot = vec3(1.0, 0.0, 0.3);\nconst vec3 clShot2 = vec3(1.0, 0.8, 0.3);\nconst vec3 clEnemy = vec3(0.7, 0.7, 0.9);\nconst vec3 clExplosion = vec3(1.0);\nconst vec3 clSpacecraft = vec3(0.3,\t1.0, 0.1);\nconst vec3 clObstacle = vec3(0.0, 0.6, 0.0);\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float Key_P = 80./256.0;\nconst float Key_D = 68./256.0;\n\n//----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ){\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ){\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixel = 1./iChannelResolution[2].xy;\n    \n\tvec2 playerPos = vec2(0.5, 0.01);\n    vec4 state = vec4(0.);\n    vec2 IsShooting = vec2(0.);\n    vec2 ProjectilePos = playerPos;\n    vec4 AliensOffset = vec4(0.);\n    vec4 AliensOffset2 = vec4(0.);\n    vec2 oldResolution = vec2(0.);\n    float Score = 0.0;\n\tfloat Lives = 3.0;\n    \n    // reset trigger\n    bool reset = false;\n    \n    if(iFrame>0){        \n        oldResolution = loadValue( txResolution ).xy;\n        reset = (oldResolution != iResolution.xy) || texture( iChannel1, vec2(KEY_SPACE,0.25) ).x > 0.;\n        \n        if(!reset){\n            playerPos \t= loadValue( txPlayerPos ).xy;\n            state \t\t= loadValue( txState );\n            if(state.x == 0.5) state.x = 0.0;\n            IsShooting \t= loadValue( txIsShooting ).xy;\n            ProjectilePos = loadValue( txProjectilePos ).xy;\n            AliensOffset = loadValue( txAliensOfst );\n            AliensOffset2 = loadValue( txAliensOfst2 );\n            Score \t\t= loadValue( txScore ).x;\n            Lives \t\t= loadValue( txLives ).x;\n        }\n    }\n    \n    float AliensSpeed = 0.9 - min(Score/52., 0.9);\n\tconst float AliensMaxSteps = 3.;\n   \tfloat AliensStep = 10. * -pixel.x;\n    \n    // pause trigger\n    if(texture( iChannel1, vec2(Key_P,0.25) ).x > 0.){\n        if(iTime - state.y > 0.1){\n            if(state.x == 0.){\n                if(IsShooting.x == 0.0){ state.z = 0.;}\n                else{ \n                    state.z = ProjectilePos.x; \n                    state.w = ProjectilePos.y;\n                }\n                \n            \tstate.xy = vec2(1., iTime);\n            }else{\n                state.xy = vec2(0., iTime);\n                if(state.z!=0.){\n                    IsShooting = vec2(1.0, iTime);\n                    ProjectilePos = vec2(state.z, state.w);\n                }\n            }\n        }\n    }\n    \n    // if game runs normally\n    if(state.x == 0.0){\n        bool moved = false;\n        if( iMouse.w>0.01 ){ // move with mouse\n            moved = abs(playerPos.x - iMouse.x/iResolution.x) >= 0.1;\n            playerPos.x = iMouse.x/iResolution.x;\n        } else { // move with keyboard\n            float moveRight = texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n            float moveLeft  = texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n            moved = abs(moveRight - moveLeft) >= 0.1;\n            playerPos.x += 0.005 * (moveRight - moveLeft);\n        }  \n        playerPos.x = clamp(playerPos.x, 0.05, 0.95);\n        \n        if (mod(iTime * 1.0, 1.0) > AliensSpeed && AliensOffset == vec4(0.0)) {\n            if(AliensOffset2.z > AliensMaxSteps){\n            \tAliensStep = -AliensStep;\n                if(AliensOffset2.z > AliensMaxSteps*2. + 1.){AliensOffset2.z = 0.;}\n            }\n            \n            if(AliensOffset2.w == 1.){\n                AliensOffset.x = AliensStep;\n            } else if(AliensOffset2.w == 2.){\n                AliensOffset.y = AliensStep;\n            } else if(AliensOffset2.w == 3.){\n                AliensOffset.z = AliensStep;\n            } else if(AliensOffset2.w == 4.){\n                AliensOffset.w = AliensStep;\n            }\n            \n            if(AliensOffset2.w == 4.){\n                AliensOffset2.z++;\n                AliensOffset2.w = 0.; \n            } else {\n                AliensOffset2.w++; \n            }\n        } else {\n        \tAliensOffset = vec4(0.0);\n        }\n        \n        if(IsShooting.x == 0.0){\n            if((iTime - IsShooting.y) > 0.1){\n                if(texture( iChannel1, vec2(KEY_UP,0.25) ).x > 0.){\n                    IsShooting = vec2(1.0, iTime);\n                    ProjectilePos = vec2(playerPos.x, playerPos.y + 0.08);\n                }\n            }\n        } else {\n            vec3 tex0 = texture(iChannel2, vec2(ProjectilePos.x, ProjectilePos.y+0.07)).rgb;\n            vec3 tex1 = texture(iChannel2, vec2(ProjectilePos.x - pixel.x, ProjectilePos.y+0.07)).rgb;\n            vec3 tex2 = texture(iChannel2, vec2(ProjectilePos.x + pixel.x, ProjectilePos.y+0.07)).rgb;\n\n            bool b0 = tex0 == clEnemy || tex1 == clEnemy || tex2 == clEnemy;\n            bool b1 = tex0 == clObstacle || tex1 == clObstacle || tex2 == clObstacle; \n            if(b0 || b1 || ProjectilePos.y > 0.9){\n                IsShooting = vec2(0.0, iTime);\n                if(b0) Score++;\n            } else {\n                ProjectilePos.y += 0.012;\n            }  \n            \n        }\n        \n    }      \n          \n    if(reset) state.x = 0.5;\n    \n    //---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    storeValue( txPlayerPos, \t vec4(playerPos, 0., 0.), \t\t\t fragColor, fragCoord );\n    storeValue( txState,\t\t state,             \t \t \t\t fragColor, fragCoord );\n    storeValue( txIsShooting,\t vec4(IsShooting, 0., 0.),           fragColor, fragCoord );\n    storeValue( txProjectilePos, vec4(ProjectilePos, 0., 0.),        fragColor, fragCoord );\n    storeValue( txAliensOfst,  \t AliensOffset,        \t\t \t\t fragColor, fragCoord );\n    storeValue( txAliensOfst2,\t AliensOffset2,        \t\t \t \t fragColor, fragCoord );\n    storeValue( txResolution, \t vec4(iResolution.xy,reset,0.),      fragColor, fragCoord );\n    storeValue( txScore, \t\t vec4(Score),         \t\t \t\t fragColor, fragCoord );\n    storeValue( txLives, \t\t vec4(Lives),         \t\t \t\t fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* \n * Game Renderer\n */\n\n// storage register/texel addresses\nconst vec2 txPlayerPos \t\t= vec2(0.0,0.0);\nconst vec2 txState     \t\t= vec2(1.0,0.0);\nconst vec2 txIsShooting     = vec2(2.0,0.0);\nconst vec2 txProjectilePos  = vec2(2.0,1.0);\nconst vec2 txAliensOfst   \t= vec2(3.0,1.0);\nconst vec2 txAliensOfst2 \t= vec2(3.0,2.0);\nconst vec2 txScore\t\t\t= vec2(4.0,0.0);\nconst vec2 txLives\t\t\t= vec2(5.0,0.0);\nconst vec2 txResolution\t\t= vec2(6.0,0.0);\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in vec2 re ){\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec2 position;\nvec2 pixel;\n\nconst vec3 clSpace = vec3(0.05, 0.07, 0.15);\nconst vec3 clShot = vec3(1.0, 0.0, 0.3);\nconst vec3 clShot2 = vec3(1.0, 0.8, 0.3);\nconst vec3 clEnemy = vec3(0.7, 0.7, 0.9);\nconst vec3 clExplosion = vec3(1.0);\nconst vec3 clSpacecraft = vec3(0.3,\t1.0, 0.1);\nconst vec3 clObstacle = vec3(0.0, 0.6, 0.0);\n\n#define IsSpacecraft(col) \t(clSpacecraft == col)\n#define IsEnemy(col)\t\t(clEnemy == col)\n#define IsShot(col) \t\t(clShot == col)\n#define IsExplosion(col) \t(clExplosion == col)\n#define IsObstacle(col) \t(clObstacle == col)\n#define IsSpace(col) \t\t(clSpace == col)\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed+=0.1f)*43758.5453123f); }\n\n//---------------------------------------------------------------------------------\n// objects coverage functions\n//---------------------------------------------------------------------------------\n\nconst vec2 spacecraftScale = vec2(0.04, 0.06);\nbool spacecraft(vec2 playerPos){\n    if(position.y < playerPos.y + spacecraftScale.y \n       && position.y > playerPos.y\n       && abs(position.x - playerPos.x) < spacecraftScale.x){\n\n        if(abs(position.x - playerPos.x) < spacecraftScale.y + 0.02 - position.y\n           && position.y < playerPos.y + (2.5*spacecraftScale.y/4.))\n            return true;\n        if(abs(position.x - playerPos.x) < spacecraftScale.x/5.\n           && position.y < playerPos.y + (3.5*spacecraftScale.y/4.))\n            return true;\n        if(abs(position.x - playerPos.x) < spacecraftScale.x/30.)\n            return true;  \n    }\n    return false;\n}\n\nbool alien(float x, float y) {\n\tif (x > 5.9999) {\n\t\tx = 11.0 - x;\n\t}\n\n\tif ((x < -0.0001) || (y < -0.0001)) {\n\t\treturn false;\n\t} else if (y <= 1.9999) {\n\t\treturn (x >= (1.9999 - y));\n\t} else if (y <= 3.9999) {\n\t\treturn ((x < 1.9999) || (x >= 3.9999));\n\t} else if (y <= 7.9999) {\n\t\treturn true;\n\t} else if (y <= 10.9999) {\n\t\treturn ((x >= (10.9999 - y)) && (x <= (12.9999 - y)));\n\t}\n\treturn false;\n}\n\nconst vec2 obstacleScale = vec2(0.1, 0.14);\nbool obstacle(vec2 pos){  \n    if(abs(position.x - pos.x) < obstacleScale.x\t&&\n      position.y > pos.y \t\t\t\t\t\t\t&&\n      position.y < pos.y + obstacleScale.y)\n    { \n        if(position.y < pos.y + obstacleScale.y - 0.04){\n            if(position.y < pos.y + obstacleScale.y - 0.1\t&&\n               abs(position.x - pos.x) < (0.4-position.y) * 0.25){\n                return false;\n            }\n\t    \treturn true;  \n        } else {\n            if(abs(position.x - pos.x) > (0.63-position.y) * 0.31 ){\n            \treturn false;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n//---------------------------------------------------------------------------------\n// blast effects\n//---------------------------------------------------------------------------------\n\nbool blastFx0(in float r){\n    vec2 eps = vec2(r, 0.0f);\n    \n    return (IsExplosion(texture(iChannel0, position + eps * pixel).rgb)) \t\t\t\t\t||\n        (IsExplosion(texture(iChannel0, position - eps * pixel).rgb))\t  \t\t\t\t\t||\n        (IsExplosion(texture(iChannel0, position + eps.yx * pixel).rgb)) \t\t\t\t\t||\n        (IsExplosion(texture(iChannel0, position - eps.yx * pixel).rgb))   \t\t\t\t\t||\n        (IsExplosion(texture(iChannel0, position + eps.xx * pixel).rgb))\t  \t\t\t\t||\n        (IsExplosion(texture(iChannel0, position - eps.xx * pixel).rgb))\t  \t\t\t\t||\n        (IsExplosion(texture(iChannel0, position + vec2(-eps.x, eps.x) * pixel).rgb))\t  \t||\n        (IsExplosion(texture(iChannel0, position + vec2(eps.x, -eps.x) * pixel).rgb));\n}\n\n//=================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tposition = ( fragCoord.xy / iResolution.xy );\n\tpixel = 1./iResolution.xy;\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec2 oldResolution = loadValue( txResolution ).xy;\n    bool reset = (oldResolution != iResolution.xy);\n    \n    vec2 playerPos = loadValue( txPlayerPos ).xy;\n    float state = loadValue( txState ).x;\n    vec2 IsShooting = loadValue( txIsShooting ).xy;\n    vec2 ProjectilePos = loadValue( txProjectilePos ).xy;\n    vec4 AliensOffset = loadValue( txAliensOfst );\n    float Score = loadValue( txScore ).x;\n    \n    vec4 old = texture(iChannel0, position);\n\tvec4 me = vec4(clSpace,1.);\n\n    bool init = iFrame == 0 || state == 0.5;\n    \n    if(state == 1.0) discard;\n    \n  \n    if (position.y < 0.09) {\n        // Spacecraft Renderer\n        if (spacecraft(playerPos)) {\n            me.rgb = clSpacecraft;\n        }\n    } else {\n        // Shot generator\n        if (IsShooting.x == 1.0 \n            && (abs(position.x - ProjectilePos.x) <= pixel.x)\n            && (position.y - ProjectilePos.y) > 0.0\n            && (position.y - ProjectilePos.y) < 0.06) \n        {\n            me.rgb = clShot;\n        }\n    }\n    \n    if(position.y >= 0.15)\n    {\n\t\t// Playing field\n\t\tvec4 below = texture(iChannel0, vec2(position.x, position.y - 0.015));\n        \n        float enemyrow = (0.9 - position.y - 0.05) * 12.0;\n        float enemyrowmod = mod(enemyrow, 1.0);\n        float enemycol = position.x * 15.0;\n        float enemycolmod = mod(enemycol, 1.0);\n        \n        // Aliens Movement\n        if(AliensOffset != vec4(0.)){\n            if(enemyrow>=3. && enemyrow<=4.){\n                old.rgb = texture(iChannel0, position + vec2(AliensOffset.x, 0.0)).rgb;\n            }\n            else if(enemyrow>=2. && enemyrow<=3.){\n                old.rgb = texture(iChannel0, position + vec2(AliensOffset.y, 0.0)).rgb;\n            }\n            else if(enemyrow>=1. && enemyrow<=2.){\n                old.rgb = texture(iChannel0, position + vec2(AliensOffset.z, 0.0)).rgb;\n            }\n            else if(enemyrow>=0. && enemyrow<=1.){\n                old.rgb = texture(iChannel0, position + vec2(AliensOffset.w, 0.0)).rgb;\n            }\n        }\n        \n\t\tif (init) {\n\t\t\t//float enemyrow = (0.9 - position.y - 0.05) * 12.0;\n\t\t\t//float enemyrowmod = mod(enemyrow, 1.0);\n\t\t\t//float enemycol = position.x * 15.0 - 0.2;\n\t\t\t//float enemycolmod = mod(enemycol, 1.0);\n\t\t\tif ((enemyrow >= 0.0) && (enemyrow < 4.0)) {\n\t\t\t\tif ((enemycol >= 1.0) && (enemycol < 14.0)) {\n\t\t\t\t\tme.rgb = alien(enemycolmod * 25.0, enemyrowmod * 25.0) ? clEnemy : clSpace;\n\t\t\t\t}\n\t\t\t}\n            \n            // draw obstacles\n            if(obstacle(vec2(0.2,0.2))\t||\n               obstacle(vec2(0.5,0.2))\t||\n               obstacle(vec2(0.8,0.2))){ \n                me.rgb = clObstacle; \n            }\n                \n\t\t} else if (IsShot(below.rgb)) {\n\t\t\tif (IsEnemy(old.rgb) || IsObstacle(old.rgb)) {\n\t\t\t\tme.rgb = clExplosion;\n\t\t\t} else if (IsExplosion(old.rgb)) {\n\t\t\t\tme.rgb = old.rgb;\n            } else {\n            \t//me.rgb = clShot;\n            }\n        } else if (IsEnemy(old.rgb)) {\n\t\t\tme.rgb = blastFx0(5.) || blastFx0(ceil(rand()*5.))? clExplosion : clEnemy;\n        } else if (IsObstacle(old.rgb)) {\n            bool exploding = (\n                IsExplosion(texture(iChannel0, position + vec2(0., (-rand()*4.)) * pixel).rgb)\t||\n                IsExplosion(texture(iChannel0, position + vec2(1., (-rand()*2.)) * pixel).rgb)\t||\n                IsExplosion(texture(iChannel0, position + vec2(-1., (-rand()*2.)) * pixel).rgb)\n            );\n\t\t\tme.rgb = exploding ? clExplosion : clObstacle;\n        } else { // dissolver\n\t\t\tif (!IsShot(old.rgb) && !IsEnemy(old.rgb) && !IsObstacle(old.rgb)) {\n\t\t\t\tme.rgb = old.rgb * 0.9 + clSpace * 0.1;\n\t\t\t\tif (length(me.rgb - clSpace) < 0.05) {me.rgb = clSpace;}\n\t\t\t}\n\t\t}\n\t}\n\n\tfragColor = me;\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/* \n * UI\n */\n\n#define show_fps\n\nconst vec2 txPlayerPos \t\t= vec2(0.0,0.0);\nconst vec2 txState     \t\t= vec2(1.0,0.0);\nconst vec2 txIsShooting     = vec2(2.0,0.0);\nconst vec2 txProjectilePos  = vec2(2.0,1.0);\nconst vec2 txAmmo\t\t\t= vec2(3.0,0.0);\nconst vec2 txScore\t\t\t= vec2(4.0,0.0);\nconst vec2 txLives\t\t\t= vec2(5.0,0.0);\nconst vec2 txResolution\t\t= vec2(6.0,0.0);\n\n//----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ){\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ){\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n//----------------------------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------------\n// font take from 'http://glslsandbox.com/e#27059.10'\n//---------------------------------------------------------------------------------\nvec2 SPR_SIZE = vec2(6, 8);\n\nvec2 start = vec2(0,0);\nvec2 tuv = vec2(0,0);\nvec2 chp = vec2(0,0);\nvec2 cur = vec2(0,0);\nvec2 char = vec2(0,0);\n\nvec2 c_a = vec2(0x7228BE, 0x8A2000);\nvec2 c_b = vec2(0xF22F22, 0x8BC000);\nvec2 c_c = vec2(0x722820, 0x89C000);\nvec2 c_d = vec2(0xE248A2, 0x938000);\nvec2 c_e = vec2(0xFA0E20, 0x83E000);\nvec2 c_f = vec2(0xFA0E20, 0x820000);\nvec2 c_g = vec2(0x72282E, 0x89C000);\nvec2 c_h = vec2(0x8A2FA2, 0x8A2000);\nvec2 c_i = vec2(0xF88208, 0x23E000);\nvec2 c_j = vec2(0xF84104, 0x918000);\nvec2 c_k = vec2(0x8A4A34, 0x8A2000);\nvec2 c_l = vec2(0x820820, 0x83E000);\nvec2 c_m = vec2(0x8B6AA2, 0x8A2000);\nvec2 c_n = vec2(0x8B2AA6, 0x8A2000);\nvec2 c_o = vec2(0x7228A2, 0x89C000);\nvec2 c_p = vec2(0xF228BC, 0x820000);\nvec2 c_q = vec2(0x7228AA, 0x99E000);\nvec2 c_r = vec2(0xF228BC, 0x8A2000);\nvec2 c_s = vec2(0x7A0702, 0x0BC000);\nvec2 c_t = vec2(0xF88208, 0x208000);\nvec2 c_u = vec2(0x8A28A2, 0x89C000);\nvec2 c_v = vec2(0x8A28A2, 0x508000);\nvec2 c_w = vec2(0x8A28AA, 0xDA2000);\nvec2 c_x = vec2(0x8A2722, 0x8A2000);\nvec2 c_y = vec2(0x8A2782, 0x89C000);\nvec2 c_z = vec2(0xF84210, 0x83E000);\nvec2 c_0 = vec2(0x732AA6, 0x89C000);\nvec2 c_1 = vec2(0x218208, 0x23E000);\nvec2 c_2 = vec2(0x722108, 0x43E000);\nvec2 c_3 = vec2(0x722302, 0x89C000);\nvec2 c_4 = vec2(0x92491E, 0x104000);\nvec2 c_5 = vec2(0xFA0F02, 0x89C000);\nvec2 c_6 = vec2(0x72283C, 0x89C000);\nvec2 c_7 = vec2(0xF82108, 0x420000);\nvec2 c_8 = vec2(0x722722, 0x89C000);\nvec2 c_9 = vec2(0x722782, 0x89C000);\nvec2 c_per = vec2(0x000000, 0x008000);\nvec2 c_exc = vec2(0x208208, 0x008000);\nvec2 c_com = vec2(0x000000, 0x008400);\nvec2 c_col = vec2(0x008000, 0x008000);\nvec2 c_sol = vec2(0x008000, 0x008400);\nvec2 c_pls = vec2(0x00823E, 0x208000);\nvec2 c_dsh = vec2(0x00003E, 0x000000);\nvec2 c_div = vec2(0x002108, 0x420000);\nvec2 c_ast = vec2(0x000508, 0x500000);\nvec2 c_lbr = vec2(0x084104, 0x102000);\nvec2 c_rbr = vec2(0x810410, 0x420000);\nvec2 c_lsb = vec2(0x184104, 0x106000);\nvec2 c_rsb = vec2(0xC10410, 0x430000);\nvec2 c_lcb = vec2(0x184208, 0x106000);\nvec2 c_rcb = vec2(0xC10208, 0x430000);\nvec2 c_les = vec2(0x084208, 0x102000);\nvec2 c_grt = vec2(0x408104, 0x210000);\nvec2 c_sqo = vec2(0x208000, 0x000000);\nvec2 c_dqo = vec2(0x514000, 0x000000);\nvec2 c_que = vec2(0x72208C, 0x008000);\nvec2 c_pct = vec2(0x022108, 0x422000);\nvec2 c_dol = vec2(0x21EA1C, 0x2BC200);\nvec2 c_num = vec2(0x53E514, 0xF94000);\nvec2 c_ats = vec2(0x722BAA, 0xA9C000);\nvec2 c_equ = vec2(0x000F80, 0xF80000);\nvec2 c_tdl = vec2(0x42A100, 0x000000);\nvec2 c_rsl = vec2(0x020408, 0x102000);\nvec2 c_crt = vec2(0x214880, 0x000000);\nvec2 c_amp = vec2(0x42842C, 0x99C000);\nvec2 c_bar = vec2(0x208208, 0x208208);\nvec2 c_blk = vec2(0xFFFFFF, 0xFFFFFF);\nvec2 c_trd = vec2(0xFD5FD5, 0xFD5FD5);\nvec2 c_hlf = vec2(0xA95A95, 0xA95A95);\nvec2 c_qrt = vec2(0xA80A80, 0xA80A80);\nvec2 c_spc = vec2(0x000000, 0x000000);\n\nvec2 digit(float n)\n{\n\tn = mod(floor(n),10.0);\n\tif(n == 0.0) return c_0;\n\tif(n == 1.0) return c_1;\n\tif(n == 2.0) return c_2;\n\tif(n == 3.0) return c_3;\n\tif(n == 4.0) return c_4;\n\tif(n == 5.0) return c_5;\n\tif(n == 6.0) return c_6;\n\tif(n == 7.0) return c_7;\n\tif(n == 8.0) return c_8;\n\tif(n == 9.0) return c_9;\n\treturn vec2(0.0);\n}\n\nfloat sprite(vec2 ch,vec2 uv)\n{\n\tuv = floor(uv);\n\tvec2 b = vec2((SPR_SIZE.x - uv.x - 1.0) + uv.y * SPR_SIZE.x) - vec2(24,0);\n\tvec2 p = mod(floor(ch / exp2(clamp(b,-1.0, 25.0))), 2.0);\n\treturn dot(p,vec2(1)) * float(all(bvec4(greaterThanEqual(uv,vec2(0)), lessThan(uv,SPR_SIZE))));\n}\n\nvoid ch(vec2 ch)\n{\n\tif(floor(chp) == floor(cur))\n\t{\n\t\tchar = ch;\n\t}\n\tcur.x++;\n}\n\nvoid start_print(vec2 uv)\n{\n\tcur = uv;\n\tstart = uv;\n}\n\nvoid spc()\n{\n\tcur.x++;\n}\nvoid nl()\n{\n\tcur.x = start.x;\n\tcur.y--;\n}\n\nvoid number(float n)\n{\n\tfor(int i = 5;i > -1;i--)\n\t{\n\t\tfloat d = n/pow(10.0, float(i));\n\t\tif(i == -1){ ch(c_per); }\n\t\tif(d > 1.0 || i <= 0){ ch(digit(d)); }\n\t}\t\n}\n\nvec2 str_size(vec2 cl)\n{\n\treturn SPR_SIZE * cl;\n}\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool reset = loadValue( txResolution ).z == 1.;\n    \n    float SCALE = iResolution.x*0.003125;\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = fragCoord.xy/ SCALE;\n    \n    chp = floor(uv/SPR_SIZE);\n\tvec2 cuv = mod(uv,SPR_SIZE);\n\t\n\ttuv = floor(cuv);\n\t\n    float startX = 6.;\n    float startY = 20.;\n    start_print(vec2(startX,startY));\n        \n    ch(c_s);\n    ch(c_c);\n    ch(c_o);\n    ch(c_r);\n    ch(c_e);\n    ch(c_col);\n    number(loadValue( txScore ).x);\n\n    start_print(vec2(startX*6.7,startY));\n    ch(c_l);\n    ch(c_i);\n    ch(c_v);\n    ch(c_e);\n    ch(c_s);\n    ch(c_col);\n    number(loadValue( txLives ).x);\n    \n#ifdef show_fps\n    start_print(vec2(4., 1.));\n    ch(c_f);\n    ch(c_p);\n    ch(c_s);\n    ch(c_col);\n    number(iFrameRate);\n#endif\n    \n    fragColor = vec4( vec3( sprite(char,cuv) ), 1.0 );\n}","name":"Buf C","description":"","type":"buffer"}]}