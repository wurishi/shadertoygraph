{"ver":"0.1","info":{"id":"XltBzH","date":"1538689666","viewed":384,"name":"Normals With Sobel Filter","username":"CliqCity","description":"Sobel filter of a checkerboard pattern","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sobel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float dx = 1.0f / iResolution.x;\n    float dy = 1.0f / iResolution.y;\n        \n    float h00 = texture(iChannel0, uv + vec2(-dx, -dy)).r;\n    float h10 = texture(iChannel0, uv + vec2(0.0, -dy)).r;\n    float h20 = texture(iChannel0, uv + vec2(+dx, -dy)).r;\n    float h01 = texture(iChannel0, uv + vec2(-dx, 0.0)).r;\n    float h21 = texture(iChannel0, uv + vec2(+dx, 0.0f)).r;\n    float h02 = texture(iChannel0, uv + vec2(-dx, +dy)).r;\n    float h12 = texture(iChannel0, uv + vec2(0.0, +dy)).r;\n    float h22 = texture(iChannel0, uv + vec2(+dx, +dy)).r;\n    \n    //\t\t+1  0 -1\t\t     +1 +2 +1\t\t\n    // Gx = +2  0 -2\t\tGy =  0  0  0\n    //\t\t+1  0 -1             -1 -2 -1\n    \n    // Gx = h00*1 + h10*0 + h20*-1 + h01*2 +h11*0 + h21*-2 + h02*1 + h12*0 + h22*-1\n    //\t  = h00 - h20 + 2*h01 - 2*h21 + h02 - h22\n    \n    // Gy = h00*1 + h10*2 + h20*1 + h01*0 + h11*0 + h21*0 + h02*-1 + h12*-2 + h22*-1\n    // \t  = h00 + 2*h10 + h20 - h02 - 2*h12 - h22\n    \n    float Gx = h00 - h20 + 2.0f * h01 - 2.0f * h21 + h02 - h22;\n    float Gy = h00 + 2.0f * h10 + h20 - h02 - 2.0f * h12 - h22;\n    \n    vec3 Px = vec3(2.0f, 0, 2.0f*Gx);\n    vec3 Py = vec3(0, 2.0f, 2.0f*Gy);\n    \n    //vec3 normal = normalize(cross(Px, Py));\n    vec3 normal = normalize(vec3(Gx, Gy, 1);\n\n    normal = normal * 0.5f + 0.5f;\n    \n    // Output edges\n    // fragColor = vec4(sqrt(Gx*Gx + Gy * Gy), 0,0,1);\n\n    // Output normals\n       fragColor = vec4(normal,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 GRID_DIMS = vec2(50, 50);\nconst vec4 COL_EVEN = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 COL_ODD = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = mod(fragCoord, 2.0 * GRID_DIMS);\n\tif (m.x < GRID_DIMS.x && m.y < GRID_DIMS.y ||\n        m.x >= GRID_DIMS.x && m.y >= GRID_DIMS.y)\n        fragColor = COL_EVEN;\n    else\n        fragColor = COL_ODD;\n}","name":"Buffer A","description":"","type":"buffer"}]}