{"ver":"0.1","info":{"id":"XcK3R1","date":"1712411842","viewed":238,"name":"Figma Gradient","username":"DrNoob","description":"Reproduction of https://www.figma.com/community/file/988224044020078891","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient","blend","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Figma Gradient\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Reproduction of https://www.figma.com/community/file/988224044020078891\n//\n// The colors in the list of constants are the original colors from the\n// template. I also took over the blending modes of the original layers. The\n// remaining parameters have been manually tweaked to achieve a similar\n// appearance. In particular, I faked the blur of each layer by simply fading\n// out the colors from the center of each blob.\n\n\nconst vec3 k_bg = vec3(19, 17, 38) / 255.0;\n\nconst vec2 k_pos1 = vec2(0.1, 0.0);\nconst float k_scale1 = 1.75;\nconst vec3 k_inner1 = vec3(255, 216, 75) / 255.0;\nconst vec3 k_outer1 = k_inner1;\n\nconst vec2 k_pos2 = vec2(0.25, -0.1);\nconst float k_scale2 = 2.0;\nconst vec3 k_inner2 = vec3(146, 7, 255) / 255.0;\nconst vec3 k_outer2 = vec3(255, 152, 152) / 255.0;\n\nconst vec2 k_pos3 = vec2(-0.35, 0.125);\nconst float k_scale3 = 1.0;\nconst vec3 k_inner3 = vec3(90, 233, 253) / 255.0;\nconst vec3 k_outer3 = k_inner3;\n\nfloat blend_overlay(in float a, in float b) {\n    return (a < 0.5) ?\n        (2.0 * a * b) :\n        (1.0 - 2.0 * (1.0 - a) * (1.0 - b));\n}\nvec3 blend_overlay(in vec3 a, in vec3 b) {\n    return vec3(blend_overlay(a.r, b.r),\n                blend_overlay(a.g, b.g),\n                blend_overlay(a.b, b.b));\n}\nvec3 blend_overlay(in vec3 a, in vec3 b, in float opacity) {\n    return mix(a, blend_overlay(a, b), opacity);\n}\n\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat blob(in vec2 p, in vec2 pos, in float scale) {\n    float b = saturate(scale * length(p - pos));\n    return pow(b, 1.5);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize input coordinates such that (0, 0) is in the center\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Initialize output color with background\n    vec3 col = k_bg;\n\n    // First blob\n    float b1 = blob(p, k_pos1, k_scale1);\n    vec3 b1Col = mix(k_inner1, k_outer1, b1);\n    col = mix(col, b1Col, pow(1.0 - b1, 2.0));\n\n    // Second blob\n    float b2 = blob(p, k_pos2, k_scale2);\n    vec3 b2Col = mix(k_inner2, k_outer2, b2);\n    col = blend_overlay(col, b2Col, pow(1.0 - b2, 1.5));\n\n    // Third blob\n    float b3 = blob(p, k_pos3, k_scale3);\n    vec3 b3Col = mix(k_inner3, k_outer3, b3);\n    col = mix(col, b3Col, pow(1.0 - b3, 3.0) * 0.4);\n    \n    // Address color banding\n    col += mix(-0.5/255.0, 0.5/255.0, hash(fragCoord.xy));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}