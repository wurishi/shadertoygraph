{"ver":"0.1","info":{"id":"ttK3Rm","date":"1578589321","viewed":81,"name":"bounding box test","username":"BrianDeLange","description":"making a bounding box around a transformed shape","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 transformationMat(vec2 scale, float angle, vec2 pos){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1., 0., pos.x,\n                0., 1., pos.y, \n                0., 0., 1.) *\n           mat3(c , -s, 0.,\n           \t\ts ,  c, 0.,\n          \t\t0., 0., 1.)*\n           mat3(1./scale.x, 0., 0.,\n                0., 1./scale.y, 0.,\n                0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col;\n\n    float r = 1.;\n    \n    mat3 transform = transformationMat(vec2(0.125, (1.3+sin(iTime))/8.), iTime, vec2(cos(iTime)/3., sin(iTime)/3.));\n    \n    mat3 inv = inverse(transform);\n    \n    float xPos = inv[0][2];\n    float yPos = inv[1][2];\n    float x = (abs(inv[0][0])+abs(inv[0][1]));\n    float y = (abs(inv[1][0])+abs(inv[1][1]));\n    \n    float minX = xPos-x;\n    float minY = yPos-y;\n    float maxX = xPos+x;\n    float maxY = yPos+y;\n    \n    if(uv.x < maxX && uv.x > minX &&\n       uv.y < maxY && uv.y > minY)\n    {\n        col = vec3(1., 0., 0.);\n    }\n    \n    uv = (vec3(uv.xy, 1.)*transform).xy;\n    \n\t\n    if(uv.x < 1. && uv.x > -1. &&\n       uv.y < 1. && uv.y > -1.)\n    {\n        col = vec3(1., 1., 1.);\n    }\n    \n    if(uv.x*uv.x+uv.y*uv.y < r*r)\n    {\n        col = vec3(0., 1., 0.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}