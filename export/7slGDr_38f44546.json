{"ver":"0.1","info":{"id":"7slGDr","date":"1615852830","viewed":58,"name":"RM__","username":"3t13nn3","description":"RM","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst int reflectionCount = 2;\nconst float reflexionIntensity = 0.5;\nconst float envReflexionIntensity = 0.8;\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n\nfloat mengerSponge(vec3 p, int iteration){\n   float d = boxSDF(p, vec3(2));\n\n   float s = 1.0;\n   float da;\n   float db;\n   float dc;\n   float c;\n   for( int m=0; m<iteration; m++ )\n   {\n      vec3 a = mod(p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.5 + cos(iTime/15.0)*2.5 - 3.0*abs(a));\n\n\n\n      da = max(r.x,r.y);\n      db = max(r.y,r.z);\n      dc = max(r.z,r.x);\n      c = (min(da,min(db,dc))-iteration)/s;\n      \n\n      d = max(d,c); \n   }\n   return d;\n}\n\n\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nvec4 booleanUnion(vec4 pointA, vec4 pointB){\n\treturn (pointA.w <pointB.w) ? pointA : pointB;\n}\n\nfloat sdOctahedron(vec3 p, vec3 h)\n{\n    float d = 0.0;\n\n    // Get distance against pyramid's sides going through origin.\n    // Test: d = p.x * sin a + p.y * cos a\n    d = dot(vec2(max(abs(p.x), abs(p.z)), abs(p.y)), \n            vec2(h.x, h.y));\n\n    // Subtract distance to a side when at height h.z from the origin.\n    return d - h.y * h.z;\n}\nfloat sdP(vec3 p, vec3 h) // h = { sin a, cos a, height }\n{\n    float octa = sdOctahedron(p, h);\n\n    // Subtract bottom half\n    return max(octa, -p.y);\n}\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat booleanSubtraction(float pointA, float pointB){\n\treturn (-pointA >pointB) ? -pointA : pointB;\n}\n\n//Plus Z est grand, moins la figure est profonde\nfloat sdEth(in vec3 p, in float z, in float scale) {\n\n    float bot = 1.0;\n    float top = 1.0;\n    \n    mat3 extend = mat3(\n        vec3(scale,0,0),\n        vec3(0,scale,0),\n        vec3(0,0,scale)  \n    );\n    p*=extend;\n    \n    vec3 pp = p;\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.8),\n        vec3(0,0,z)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    top = sdPyramid(p, 1.0);\n    p *= rotateX(PI);\n    top = booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,sdPyramid(p, 0.5))).w *.2;\n    \n    p = pp*rotateY(PI);\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.4),\n        vec3(0,0,z/2.0)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.1205;\n    bot = sdPyramid(p, 1.0)*.4;\n    p = pp *rotateY(PI);\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.4),\n        vec3(0,0,0.01) //degree of the blank  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.12 - scale * 0.001;\n    bot = max(bot, -sdPyramid(p, 0.5)*0.6);\n    \n    /*if (z > 4.0)\n        return booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,bot)).w * .5 / scale;*/\n    \n    return booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,bot)).w /scale;\n    //return bot;\n\n}\n\n\n/*\n//Plus Z est grand, moins la figure est profonde\nfloat sdEth(in vec3 p, in float z, in float scale) {\n\n    float bot = 1.0;\n    float top = 1.0;\n    \n    mat3 extend = mat3(\n        vec3(scale,0,0),\n        vec3(0,scale,0),\n        vec3(0,0,scale)  \n    );\n    p*=extend;\n    \n    vec3 pp = p;\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.8),\n        vec3(0,0,z)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    top = sdP(p, vec3(0.5,0.25,1.0));\n    p *= rotateX(PI);\n    top = booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,sdP(p, vec3(0.5,0.5,0.5)))).w *.2;\n    \n    p = pp*rotateY(PI);\n    extend = mat3(\n        vec3(1.0 ,0,0),\n        vec3(0,1.0,0.4),\n        vec3(0,0,z/2.0)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.1305;\n    bot = sdP(p, vec3(0.5,0.25,1.0))*.8;\n    p = pp *rotateY(PI);\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.4),\n        vec3(0,0,0.01) //degree of the blank  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.12 - scale * 0.001;\n    bot = max(bot, -sdP(p, vec3(0.5,0.5,0.5))*0.8);\n    \n    \n    return booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,bot)).w /scale;\n    //return bot;\n\n}\n*/\n\nvec4 sceneSDF(vec3 p) {        \n    \n    vec4 ball = vec4(cos(iTime/3.0),0.3,0.2, sphereSDF(p, 0.2) - sin(p.x *8.0 + iTime*6.0) *0.02);\n    float scale = 4.0;\n    //vec4 ball = vec4(0.6,0.6,0.85,sdEth(p, 4.0, scale));\n    vec4 sponge = vec4(0.334, 0.4, 0.76, mengerSponge(p, 4));\n    \n    vec4 res = booleanUnion(ball/1.1, sponge);\n    \n    vec3 newPoint = p * rotateZ(3.14159265359) - vec3(0.0, 2.75, 0.0);\n    vec4 cone = vec4(0.8,0.9,0.7, sdCone(newPoint,vec2(1.0),1.5));\n    res = booleanUnion(res,cone);\n    \n    vec3 alias = p;\n    alias *= rotateY(-iTime/3.0);\n    alias += vec3(-8.0, -2.0*sin(iTime*0.5), -0.5);\n    //eye *= rotateZ(iTime);\n    //alias *= rotateX(iTime/3.0);\n    //alias *= rotateY(-iTime/3.0);\n    vec4 b = vec4(cos(iTime),cos(iTime*1.2),cos(iTime*1.42),sphereSDF(alias, 0.2));\n    \n    res = booleanUnion(res, b);\n    return res;\n    \n    /*\n    float scale = 1.5;\n    return vec4(0.6,0.6,0.85,sdEth(samplePoint, 4.0, scale));\n    */\n    //return vec4(0.6,0.6,0.85,sdP(samplePoint, vec3(0.5)));\n    \n}\n\n\nbool shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float maxDistance, int maxIteration, inout vec3 p, inout vec4 dist) {\n    float depth = start;\n    bool hit;\n    for (int i = 0; i < maxIteration; i++) {\n        p = eye + depth * marchingDirection;\n        dist = sceneSDF(p);\n        if (dist.w < EPSILON) {\n\t\t\thit = true;\n            break;\n        }\n        depth += dist.w;\n        if (depth >= maxDistance) {\n            hit = false;\n            break;\n        }\n    }\n    return hit;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).w - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).w,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).w - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).w,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).w - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).w\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n   \n   \n    //SHADOW\n    vec4 dist = vec4(0.0);\n    vec3 hitPosition;\n    shortestDistanceToSurface(p + N * EPSILON *2.0, L, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS, hitPosition, dist);\n\n\t\tif(dist.w<length(lightPos - p))\n\t\t\tlightIntensity *= 0.5;\n    \n    \n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(5.0,\n                          5.0,\n                          5.0);\n    \n    //vec3 light1Pos = eye - 8.0;\n                          \n    vec3 light1Intensity = vec3(0.7, 0.7, 0.7);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    /*vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);*/\n    vec3 light2Pos = eye - vec3(sin(iTime/10.0)/5.0,cos(iTime/8.0)/4.0,0.0);\n                         \n    vec3 light2Intensity = vec3(0.3, 0.3, 0.3);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    \n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 2.0*sin(iTime*0.5), -0.0);\n    //eye *= rotateZ(iTime);\n    eye *= rotateY(iTime/3.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec3 hitPosition;\n    vec4 dist;\n    \n    bool hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS, hitPosition, dist);\n    \n    vec4 res;\n    \n    if(hit){\n\n        vec3 K_a = dist.xyz;\n        vec3 K_d = K_a;\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n        vec3 s = phongIllumination(K_a, K_d, K_s, shininess, hitPosition, eye);\n        res = vec4(s,1.0);\n        vec3 n = estimateNormal(hitPosition);\n        res += vec4(texcube(iChannel0, hitPosition, n).rgb * reflexionIntensity * envReflexionIntensity,0);\n        if(reflectionCount > 0){\n            vec3 n = estimateNormal(hitPosition);\n            worldDir = normalize(reflect(worldDir,n));\n            eye = hitPosition + (worldDir * 0.01);\n            hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST * 0.5, MAX_MARCHING_STEPS / 2, hitPosition, dist);\n            if(hit) {\n                vec3 K_a = dist.xyz;\n                vec3 K_d = K_a;\n                vec3 K_s = vec3(1.0, 1.0, 1.0);\n                float shininess = 10.0;\n                vec3 s = phongIllumination(K_a, K_d, K_s, shininess, hitPosition, eye);\n\n                res = vec4(s * reflexionIntensity,1.0);\n\n                if(reflectionCount > 1){\n                    vec3 n = estimateNormal(hitPosition);\n                    worldDir = normalize(reflect(worldDir,n));\n                    eye = hitPosition + (worldDir * 0.01);\n                    hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST * 0.25, MAX_MARCHING_STEPS / 4, hitPosition, dist);\n                    if(hit) {\n                        vec3 K_a = dist.xyz;\n                        vec3 K_d = K_a;\n                        vec3 K_s = vec3(1.0, 1.0, 1.0);\n                        float shininess = 10.0;\n                        vec3 s = phongIllumination(K_a, K_d, K_s, shininess, hitPosition, eye);\n                        res = vec4(s * reflexionIntensity * 0.5,1.0);\n                    }\n                }\n            }\n        }\n        \n    } else {\n        \n        res = vec4(0.4,0.6,0.9,0);\n    }\n\n    \n    fragColor = res;\n}\n","name":"Image","description":"","type":"image"}]}