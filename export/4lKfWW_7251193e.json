{"ver":"0.1","info":{"id":"4lKfWW","date":"1542570674","viewed":364,"name":"PointLights","username":"gest","description":"thanks  https://www.shadertoy.com/view/MtK3DG","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lighting","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n#define u_canvas iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n\nconst float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\t#if 1\n\t\t//Правильно\n\t\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\t\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\t#else\n\t\t//Не правильно\n\t\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\t\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\t#endif\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\t#if 1\t\t\n\t\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t#else\n\t\t\tfloat angle = radians(cam.fov);\n\t\t\tray.direction = normalize(vec3(sin(angle*0.5) * uv.x * cam.aspect,  sin(angle*0.5) * uv.y,  -cos(angle*0.5)));\n\t\t#endif\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.steps\t\t= 200.;\n\t\tray.swing\t\t= 1.0;\n\t}\n\treturn ray;\n}\n\nfloat random(vec2 p) {\n  return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//-------------------Контроль времени-------------------\n//      -------         -------\n//     |       |       |       |\n//_____|       |_______|       |\nfloat demoTimer(float time, float intervalCount, float intervalDuration) {\n    float interval_id = floor(time/intervalDuration);\n\treturn mod(interval_id, intervalCount);\n}\n//       -------\n//      /\n//_____/\nfloat timeStep(float time, float time_start, float duration) {\n    return smoothstep(time_start, time_start + duration, time);\n}\n//       -------\n//      /       \\\n//_____/         \\______\n// v.x - time_start, v.y - time_stop\nfloat timeClamp(float time, vec2 v, float duration) {\n    return smoothstep(v.x, v.x+duration, time) - smoothstep(v.y-duration, v.y, time);\n}\n\n//-------------------Функции позиционирования объектов сцены\nvoid translate(inout vec3 p, vec3 dist) {\n\tp = p - dist;\n}\nvoid translate(inout vec2 p, vec2 dist) {\n\tp = p - dist;\n}\nvoid translate(inout float p, float dist) {\n\tp = p - dist;\n}\n\n//Вращение вокруг осей\nmat3 rotate(vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \treturn mx * my * mz;\n}\nvoid rotate(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = tMat * p;\n}\nvoid rotateOrigin(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = p * tMat;\n}\n\nvoid rotateX(inout vec3 p, float r) {\n\tfloat s = sin(r); float c = cos(r);\n\tmat2 tMat = mat2(c, s, -s, c);\n\tp.yz = tMat * p.yz;\n}\nvoid rotateY(inout vec3 p, float r) {\n\tfloat s = sin(r); float c = cos(r);\n\tmat2 tMat = mat2(c, s, -s, c);\n\tp.xz = tMat * p.xz;\n}\nvoid rotateZ(inout vec3 p, float r) {\n\tfloat s = sin(r); float c = cos(r);\n\tmat2 tMat = mat2(c, s, -s, c);\n\tp.xy = tMat * p.xy;\n}\n\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n//Закручивание на угол angle и вращение offset\nvoid twistX( inout vec3 p, float r, float offset ) {\n\tfloat an = r*(p.x+offset);\n    float  c = cos(an),  s = sin(an);\n    mat2   tMat = mat2(c,s,-s,c);\n    p = vec3(tMat * p.yz, p.x);\n}\nvoid twistY( inout vec3 p, float r, float offset ) {\n\tfloat an = r*(p.y+offset);\n    float  c = cos(an),  s = sin(an);\n    mat2   tMat = mat2(c,s,-s,c);\n    p = vec3(tMat * p.xz, p.y);\n}\nvoid twistZ( inout vec3 p, float r, float offset ) {\n\tfloat an = r*(p.z+offset);\n    float  c = cos(an),  s = sin(an);\n    mat2   tMat = mat2(c,s,-s,c);\n    p = vec3(tMat * p.xy, p.z);\n}\n//Размножение. Возвращает центр ячейки с id=0.\nfloat replica(inout float p, float d) {\n    float id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec2 replica(inout vec2 p, vec2 d) {\n    vec2 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nvec3 replica(inout vec3 p, vec3 d) {\n    vec3 id = floor(p/d + 0.5);\n    p = mod(p + 0.5*d, d) - 0.5*d;\n    return id;\n}\nfloat replicaLimit(inout float p, float d, float ida, float idb) {\n\tfloat id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec2 replicaLimit(inout vec2 p, vec2 d, vec2 ida, vec2 idb) {\n\tvec2 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nvec3 replicaLimit(inout vec3 p, vec3 d, vec3 ida, vec3 idb) {\n\tvec3 id = floor(p/d + 0.5);\n\tp = p-d*clamp(floor(p/d + 0.5), ida, idb);\n\treturn id;\n}\nfloat replicaAngle(inout vec2 p, float n, float off) {\n\tfloat a = 2.* PI /n;\n\t//polar\n\tp = vec2(atan(p.y, p.x), length(p.xy));\n\tfloat id = floor(mod(p.x + 0.5*a + off, 2.*PI)/a);\n    p.x = mod(p.x + 0.5*a + off, a) - 0.5*a;\n\tp = p.y * vec2(cos(p.x),sin(p.x));\n\treturn id;\n}\n//Вытягивание 2D-профиля dist_2D_profile в направлении p (p.x, p.y, p.z) между -h...+h \nfloat extrude2D(float dist_2D_profile, float p, float h) {\n\tfloat dist_3D_between = abs(p) - h;\n    vec2 w = vec2(dist_2D_profile, dist_3D_between);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\nfloat extrude2D(float dist_2D_profile, float dist_3D_between) {\n    vec2 w = vec2(dist_2D_profile, dist_3D_between);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n//Все нечетные id\nbool replicaOddID(vec3 id) {\n\tid = sign(id - floor(id/2.)*2. - 0.5);\n\treturn id.x*id.y*id.z<0.;\n}\nbool replicaOddID(vec2 id) {\n\treturn mod (floor (id.y + id.x), 2.)==0.;\n}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n#if 1\n\t//Гладкое сложение / Объединение / ИЛИ (k==0 без)\n\tfloat OR( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) - k*h*(1.-h);\n\t}\n\t//Гладкое умножение / Пересечение / И (k==0 без)\n\tfloat AND( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) + k*h*(1.-h);\n\t}\n#else\n\t//Гладкое сложение / Объединение / ИЛИ (k==0 без)\n\tfloat OR(float distA, float distB, float k) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distA-distB)/k, 0., 1. );\n\t\treturn mix(distA, distB, 1.-h) - k*h*(1.-h);\n\t}\n\t//Гладкое умножение / Пересечение / И (k==0 без)\n\tfloat AND(float distA, float distB, float k) {\n\t\tfloat h = clamp( 0.5 + 0.5*(distA-distB)/k, 0., 1. );\n\t\treturn mix(distA, distB, 1.-h) + k*h*(1.-h);\n\t}\n#endif\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n//-------------------функции расстояний до объектов\n\nfloat dfBefore(float p, float p1) {\n\treturn p - p1;\n}\nfloat dfBall(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\n#define ID_PLANE 0.0\n#define ID_BALL 1.0\n\nfloat map(vec3 p, inout Object object){\n\t\n\tobject = Object(1e6, -1.0);\n\t\n\t//Плоскость\n\tObject PLANE = Object(1e6, ID_PLANE);\n\t{\n\t\tPLANE.distance = dfBefore(p.y, 0.);\n\t}\n\tobject = OR(object, PLANE);\n\n\t//Сфера\n\tObject BALL = Object(1e6, ID_BALL);\n\t{\n\t\tBALL.distance = dfBall(p, 0.25);\n\t}\n\tobject = OR(object, BALL);\n\n\treturn object.distance;\n}\n\n//Карта расстояний до элементов сцены (без доп. параметров)\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n//Нормали в точке поверхности\nvec3 mapNormal( in vec3 p, float eps ) {\n\tmat3 e = mat3(eps);\n\treturn normalize( vec3(\n\t\tmap( p + e[0]) - map(p - e[0]),\n\t\tmap( p + e[1]) - map(p - e[1]),\n\t\tmap( p + e[2]) - map(p - e[2])\n\t));\n}\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps = 1.;\n\tfor (float i = 0.; i < 100.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nstruct Material {\n\tvec3  ambientColor;\n\tfloat diffuse;\n\tfloat specular;\n    float shininess;\n    float mirror;\n};\nMaterial material_0 = Material(vec3(0.1, 0.1, 0.5), 0.6, 0.8, 16.0, 0.75);\nMaterial material_1 = Material(vec3(0.1, 0.5, 0.1), 0.2, 0.4, 16.0, 0.5);\n\nMaterial getMaterial(Ray ray) {\n\tMaterial material = Material(vec3(0),0.0,0.0,0.0,0.0);\n\tif (ray.object.id==ID_PLANE) {\n\t\tmaterial = material_0;\n\t} else if (ray.object.id==ID_BALL) {\n\t\tmaterial = material_1;\n\t}\n\treturn material;\n}\n\nstruct Light {\n    vec3 position;\n    vec3 direction;\n\tvec3 color;\n\tfloat radius;\n};\nLight light = Light(vec3(1.5, 0.25, 0.0), vec3(0), vec3(1), 0.5);\n\nconst int COUNT = 12;\nLight lights[COUNT];\n\nvec3 diffuseLighting(in vec3 normal, Light light, Material material){\n    float lambertian = max(dot(light.direction, normal), 0.0);\n  \treturn  lambertian * vec3(material.diffuse) * light.color; //colorDiffuse\n}\n\n\n\nvec3 specularLighting(in vec3 p, in vec3 normal, in vec3 camPos, Light light, Material material){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    vec3 V = normalize(camPos - p);\n    vec3 H = normalize(light.direction + V);\n    \n    float NdotH = dot(normal, H);\n    float NdotV = dot(normal, V);\n    float VdotH = dot(V, H);\n    float NdotL = dot(normal , light.direction);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    return specular * vec3(material.specular) * light.color; //colorSpecular\n}\n\nvec3 lighting(in Ray ray, in Light light, in Material material) {\n\tfloat lightDistance = length(light.position - ray.position);\n\t\n  \tvec3 color =  diffuseLighting(ray.normal, light, material);\n    color += specularLighting(ray.position, ray.normal, ray.origin, light, material);\n\t\n\tRay ray1 = ray;\n\t{\n\t\tray1.origin \t= ray.position;\n\t\tray1.direction \t= light.direction;\n\t\tray1.near\t\t= 0.01;\n\t\tray1.far  \t\t= lightDistance;\n\t\tray1.epsilon\t= 0.001;\n\t\tray1.steps\t\t= 96.;\n\t}\n    rayMarch(ray1);\n\t\n\tif (ray1.hit) {\n\t\tfloat shadow = clamp(ray1.distance/ray1.far, 0.0, 1.0);\n\t\tfloat  attenuation = 1.0 / (1.0 +  0.1 * lightDistance * lightDistance);\n\t\tcolor *= attenuation * shadow;\n\t}\n    return  color;\n}\n\nvec3  drawLight(vec3 color, vec3 p, vec3 camPos, Light light){\n\tvec3 rayDirection = normalize(camPos - p);\n    vec3 v = camPos - light.position;\n\tvec3 v_proj = dot(v, rayDirection) * rayDirection;\n    float d = length(v - v_proj);\n    \n    if (d < light.radius){\n       \tfloat a = 1.0 - d/light.radius;\n       \tcolor =  mix(color, light.color, pow(a, 4.0));\n    }\n    return color;\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy / u_canvas.xy;\n\tuv = uv - 0.5;\n\t\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin \t= vec3( 0.0, 2.5,-4.0);\n\t\tcam.target  = vec3( 0.0, 0.0, 0.0);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.0;\n\t\tray.far  \t= 20.0;\n\t\tray.epsilon = 0.001;\n\t\tray.steps \t= 64.;\n\t\tray.swing\t= 1.0;\n\t}\n\trayMarch(ray);\n\t\n\tvec3 color = vec3(0);\n\t\n\tif (ray.distance<ray.far) {\n\t\tray.normal = mapNormal(ray.position, ray.epsilon*10.);\n\t\t\n\t\tMaterial material = getMaterial(ray);\n\t\tvec3 col = material.ambientColor;\n\t\t\n\t\tfor (int i=0; i<COUNT; i++) {\n\t\t\tlights[i] = light;\n\t\t\tfloat index = mod(float(i),6.);\n\t\t\tif ( index==0.) {\n\t\t\t\tlights[i].color = vec3(0.6, 0.1, 0.1);\n\t\t\t} else if (index==1.) {\n\t\t\t\tlights[i].color = vec3(0.1, 0.6, 0.1);\n\t\t\t} else if (index==2.) {\n\t\t\t\tlights[i].color = vec3(0.1, 0.1, 0.6);\n\t\t\t} else if (index==3.) {\n\t\t\t\tlights[i].color = vec3(0.6, 0.1, 0.6);\n\t\t\t} else if (index==4.) {\n\t\t\t\tlights[i].color = vec3(0.6, 0.6, 0.1);\n\t\t\t} else if (index==5.) {\n\t\t\t\tlights[i].color = vec3(0.1, 0.6, 0.6);\n\t\t\t}\n\t\t\trotate(lights[i].position, vec3(0,1,0) * (0.6 + float(i)*0.2) * u_time);\n\t\t\tlights[i].direction = normalize(lights[i].position - ray.position);\n\t\t\tcol += lighting(ray, lights[i], material);\n\t\t\t//Цвет источников света\n\t\t\tcolor = drawLight(color, ray.position, ray.origin, lights[i]);\n\t\t}\n\t\tcolor += col*(1.0 - material.mirror);\n\t}\n\t\n\t//Гамма-коррекция\n\tfloat screenGamma = 2.2;\n\tcolor = pow(color, vec3(1.0/screenGamma));\n\t\n\tgl_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}