{"ver":"0.1","info":{"id":"Wlf3Rs","date":"1557320734","viewed":218,"name":"SOARP with OverRelaxing","username":"bignobody","description":"Fourth generation of my practice raymarcher. Integrates some suggestions I received (conditional free object map, no global arrays) and integrates a first try at the \"Over Relaxing\" technique (which brought big speed increases to my older machine).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on the previous generation https://www.shadertoy.com/view/3tXGRX\n// Thanks as always to iq, Jamie Wong, BigWIngs (Art of Code) for the tutorials\n// Special thanks to ollj and shau for their suggestions on the previous iteration\n// -----------------------------------------------------------------------------\n// Limited the number of reflection bounces to 20 for safety.\n// Update: Fixed bug in shadow march (thanks ollj!)\n// Update: added Mouse camera control by request (hi Mitch!)\n\n\n#define NUM_LIGHTS 1\n#define AMBIENT_LIGHT 1.61\n#define NUM_SPHERES\t6\n\n// adapted sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n// objects map\n\n//From Shane (via shau) to avoid conditionals\nvec2 nearest(vec2 a, vec2 b) \n{    \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;    \n}\n// As refactored by shau to demonstrate the above nearest function:\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    //floor\n    vec2 d = vec2(sdfPlane(p,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0))), 1.);\n    \n    //cross\n    d = nearest(d, vec2(opUnion( sdfBox(p, vec3(0.0), vec3(4.0,6.0,1.0)), sdfBox(p, vec3(0.0), vec3(1.0,6.0,4.0))), 2.)); \n\n    float offset = 0.0; \n    float offsetinc = 6.28318 / float(NUM_SPHERES);\n    for (int s = 0; s < NUM_SPHERES; s ++) {\n        d = nearest(d, vec2(sdfSphere(p,vec3(6.5 * cos(iTime+offset),0.75*cos(iTime*offset),6.5 * sin(iTime+offset)),1.0), float(s) + 3.));\n        d = nearest(d, vec2(sdfSphere(p,vec3(8.5 * cos(-iTime+offset),0.95*cos(-iTime*offset * 0.33),8.5 * sin(-iTime+offset)),1.2), float(s) + 3.));\n        offset += offsetinc;\n    }\n\n    pick = int(d.y);\n    return d.x;\n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.00085;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n\tvec3 lps[6] = vec3[](vec3(-8.0 * cos(iTime * 0.25),3.5,-8.0 * sin(iTime * 0.25)),\n\t\t\t\tvec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,5.5* cos(iTime * 0.5)),\n                vec3(5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 1.3)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 2.7)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 4.5)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 0.5)));\n    if (l > 5)\n    {\n        return lps[0];\n    }\n\n    return lps[l];\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize(lightOrigin-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(surfacePoint,lightOrigin);\n    for( float s=0.01; s < end; )\n    {\n        vec3 marchStep = surfacePoint + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.00085)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\tvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\n\tvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\n\tfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0);\n\n\tvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\tfloat mx = iMouse.x/iResolution.x * 3.14159;\n    // camera setup and ray cast\n    float zoom = 1.0;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    float camTime = (length(iMouse.zw) > 0.0) ? mx : iTime * 0.1;\n    float upTime = camTime * 5.0;\n    vec3 camOrigin = vec3(10.0 * cos(camTime),6.5 * cos(upTime)+4.2,-10.0 * sin(camTime));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const float MAX_DISTANCE = 128.0;\n    const float CLOSE_ENOUGH = 0.00085;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\tfloat overEstimate = 10.2;\n    float errorAmount = 99999.;\n    float previousDistance = 0.0;\n    vec3 colAccum = vec3(0.0);\n\tfloat bounceCount = 0.0;\n\tfloat refMixVal = 0.35; // don't start with a solid mix\n//initialize with sky colour\n    pickTarget = 0;\n\tcolAccum =  vec3(0.2,0.4,0.6) - rayDirection.y * 0.5;\n\tfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\n\tfloat stepLength = 0.0;\n\tfloat pixelRadius = 0.00000001;\n    \n\tfor (marchDistance = 0.0; marchDistance < MAX_DISTANCE;)\n\t{\n\t\tmarchStep = marchVec + rayDirection * marchDistance;\n\t    distNow = distanceToClosest(marchStep, pickTarget);\n\t\tbool failCondition = overEstimate > 1.0 && (abs(distNow)+previousDistance) < stepLength;\n        if (failCondition)\n        {\n        \tstepLength -= overEstimate * stepLength;\n            overEstimate = 1.0;\n        }\n        else\n        {\n        \tstepLength = distNow * overEstimate;\n            overEstimate += 1.0;\n        }\n        previousDistance = distNow;\n\n        float errorNow = distNow / marchDistance;\n\t\tif (!failCondition && errorNow < errorAmount)\n        {\n        \terrorAmount = errorNow;\n        }\n\n\t\tmarchDistance += distNow;\n\n\t\tif (marchDistance >= MAX_DISTANCE || bounceCount >= 20.0 || errorAmount < pixelRadius)\n        {\n          // sky colour\n                int lastPick = pickTarget;\n        \t\tpickTarget = 0;\n\t\t\t\tcolAccum = mix(colAccum,vec3(0.2,0.4,0.6) - rayDirection.y * 0.5,\n\t\t\t\t\t\t\tclamp(reflectivity[lastPick]+bounceCount*0.1,0.0,1.0));\n\n            \tbreak;   \n        }\n        \n\t\tif (distNow <= CLOSE_ENOUGH)\n       \t{\n\t\t\t// hit something!\n   \t\t\tsurfaceNormal = estimateNormal(marchStep, pickTarget);\n\t\t\t// calculate colour accumulation\n\t\t\tcolAccum = mix(colAccum,lightSurfacePoint(marchVec , marchStep, surfaceNormal, AMBIENT_LIGHT, pickTarget),\n\t\t\t\t\tclamp(reflectivity[pickTarget] + refMixVal + bounceCount * 0.1,0.0,1.0));\n          \trayDirection = normalize(reflect((rayDirection ), surfaceNormal));\n            bounceCount += 1.0;\n            marchDistance = 0.01;\n\t\t\t// move camera origin to reflection location\n\t\t\tmarchVec = marchStep; // + rayDirection * marchDistance;\n\t\t}\n\t\t\t\t\n\t}\n    col = colAccum;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}