{"ver":"0.1","info":{"id":"sdByRD","date":"1643159199","viewed":135,"name":"Silkfoil","username":"do","description":"<>","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["trefoil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Silkfoil\n//2022\n//do\n\nconst int seed = 153435;\n\nconst int steps = 100;\nfloat eps = 0.0001;\nfloat dmin = 0.;\nfloat dmax = 255.;\nconst int aa = 2;\n \nconst int shsteps = 125; \nfloat shblur = 70.;\nfloat shmax = 10.; \n\nfloat h11(float p) {\n    uvec2 n = uint(int(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat h21(vec2 p) {\n    uvec2 n = uvec2(ivec2(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat sin3(vec3 p,vec3 f) { \n    return sin(p.x) * f.x + sin(p.y) * f.y + sin(p.z) * f.z;\n}\n    \nmat2 rot2(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nvec3 twist(vec3 p,vec4 w) {\n    float c = cos(w.x*p.y+w.y);\n    float s = sin(w.z*p.y+w.w);\n    mat2 m = mat2(c,-s,s,c);\n    return vec3(p.xz*m,p.y);\n}\n\nmat3 camOrthographic(vec3 ro,vec3 ta,float r) {\n     \n     vec3 w = normalize(ta - ro); \n     vec3 p = vec3(sin(r),cos(r),0.);           \n     vec3 u = normalize(cross(w,p)); \n     vec3 v = normalize(cross(u,w));\n\n     return mat3(u,v,w); \n} \n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat smod(float d1,float d2,float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2+d1)/k,0.0,1.0);\n    return mix(d2,-d1,h) + k * h * (1.0 - h);\n}\n\nfloat smoi(float d1,float d2,float k) {\n\n    float h = clamp(0.5 + 0.5 * (d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) + k * h * (1.0 - h);\n\n}\n\nfloat plane(vec3 p,vec4 n) {\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat trefoil(vec3 p,vec2 t,float n,float l,float e) {\n\n    vec2 q = vec2(length(p.xz)-t.x,p.y);     \n\n    float a = atan(p.x,p.z);\n    float c = cos(a*n);\n    float s = sin(a*n);\n\n    mat2 m = mat2(c,-s,s,c);    \n    q *= m;\n\n    q.y = abs(q.y)-l;\n \n    return (length(q) - t.y)*e;\n\n}\n\nvec2 scene(vec3 p) {\n\n    vec2 res = vec2(1.,0.);    \n    float t = iTime;  \n\n    vec3 q = p;\n\n    p.xz *= rot2(iTime*.1);\n    p.zy *= rot2(iTime*.125);    \n    \n    vec4 t1 = vec4(.25,.1,h11(245.),-.25);\n   \n    t1 = mix(vec4(-.5,h11(125.),-.25,h11(111.)),vec4(0.),\n    step(h11(12.),h11(235.)));\n\n    t1 = mix(vec4(h11(100.),-.25,-h11(35.),.5),vec4(0.),\n    step(h11(155.),h11(95.)));\n\n    res = opu(res,vec2(\n        trefoil(twist(p,t1),vec2(1.5,.25),3.,.35,.5),25.));  \n\n    float pl = plane(q*.5,vec4(1.,1.,0.,0.));\n\n    res = opu(res,vec2(smod(\n    trefoil(twist(p,t1),vec2(1.5,.35),3.,.35,.5),pl,.1)\n    ,12.5));\n\n    return res;\n\n}\n\nvec2 rayScene(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = dmin;\n    float e = dmax;  \n\n    for(int i = 0; i < steps; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(abs(dist.x) < eps || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n        \n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\n \nfloat shadow(vec3 ro,vec3 rd) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < shsteps; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,shblur * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < eps || t > shmax) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * eps;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 renderScene(vec3 ro,vec3 rd) {\n \nvec2 d = rayScene(ro, rd);\n\nvec3 bg = vec3(.25,.15,.15);\nvec3 col = bg * max(0.,rd.y);\n\nif(d.y >= 0.) {\n\nvec3 p = ro + rd * d.x;\nvec3 n = calcNormal(p);\nvec3 l = normalize(vec3(3.,5.,-6.));\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\nif(d.y == 25.) {\n    col = vec3(sin3(p,vec3(h11(222.),h11(155.),h11(335.))*.025));\n} else {\n    col = vec3(.9);\n}\n\nfloat amb = clamp(0.5 + 0.5 * n.y,0.,1.);\n\nfloat dif = clamp(dot(n,l),0.0,1.0);\n\nfloat spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n* dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\nfloat fre = pow(clamp(1. + dot(n,rd),0.0,1.0),2.0);\nfloat ref = smoothstep(-.2,.2,r.y);\n\nvec3 linear = vec3(0.);\n\ndif *= shadow(p,l);\nref *= shadow(p,r);\n\nlinear += dif * vec3(.5); \nlinear += amb * vec3(0.01,0.05,0.05);\nlinear += ref * vec3(0.05,0.01,0.05);\nlinear += fre * vec3(0.25,0.5,0.35);\n\ncol = col * linear;\ncol += spe * vec3(.25,.01,.05); \ncol = mix(col,bg,1.-exp(-0.01 * d.x*d.x*d.x)); \n\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n \nvec3 color = vec3(0.);\nvec3 ro = vec3(2.5);\nvec3 ta = vec3(0.0);\n\nfor(int k = 0; k < aa; ++k) {\n    for(int l = 0; l < aa; ++l) {\n\n    vec2 o = vec2(float(l),float(k)) / float(aa) - .5;\n\n    vec2 uv = (2. * (fragCoord.xy + o) -\n    iResolution.xy) / iResolution.y; \n\n    mat3 cm = camOrthographic(ro,ta,0.);\n    vec3 rd = cm * normalize(vec3(uv.xy,2.));\n  \n    vec3 render = renderScene(ro,rd);\n    render = pow(render,vec3(.4545));\n    color += render;\n\n    }\n}\n\ncolor /= float(aa*aa);\nfragColor = vec4(color,1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}