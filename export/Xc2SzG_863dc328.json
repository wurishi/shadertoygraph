{"ver":"0.1","info":{"id":"Xc2SzG","date":"1707627438","viewed":192,"name":"Terrain shadow-casting and AO","username":"totimannino","description":"Iterating on height map terrains. Added ambient occlusion, some shadow-casting improvements, fixed some bugs, and added more interesting terrain and camera fly-by.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","heightmap","ambientocclusion"],"hasliked":0,"parentid":"7ldBR7","parentname":"HeightMap Clouds and Terrain"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixOffset = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float focalLength = 1.0;\n        \n    constructScene(iTime);\n    \n    mat3 camMat = constructCameraMat(sceneCam);\n    vec3 rayDir = camMat*normalize(vec3(pixOffset, focalLength));\n    Ray ray = Ray(rayDir, sceneCam.pos);\n        \n    HitInfo hitInfo;\n    hitInfo.dist = MAX_DIST;\n    vec3 surfaceColor = vec3(0.);\n    \n    HitInfo hmapHit = heightMapIntersect(ray, sceneHmap, iChannel1, 60.);\n    if(hmapHit.dist > 0. && hmapHit.dist < MAX_DIST)\n    {\n        vec3 sunDir = getSunDirection(iTime);\n        surfaceColor = hmapHit.albedo;\n        hitInfo.dist = hmapHit.dist;\n    }\n    \n    HitInfo skyHit = heightMapIntersect(ray, skyHmap, iChannel0, 60.);\n    vec3 skyColor = vec3(0.);\n    if(skyHit.dist > 0. && skyHit.dist < MAX_DIST)\n    {\n        skyColor = skyHit.albedo;\n        hitInfo.dist = skyHit.dist;\n    }\n    \n    vec3 color = skyColor + surfaceColor;\n\n    color = mix(color,vec3(0.55,0.55,0.85), clamp((hitInfo.dist-20.)/50., 0., 1.));\n    \n    fragColor = vec4(color,1.0);\n    \n    // ground color map debug\n    //fragColor = texture(iChannel1,fract(pixOffset)).rgba;\n    \n    // sky color map debug\n    //fragColor = texture(iChannel0,fract(pixOffset)).rgba;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_DIST 99999999999.\n#define CLOUD_HEIGHT 4.5\n\nstruct PlaneDef\n{\n    vec3 norm;\n    vec3 pos;\n};\n\nstruct HeightMapDef\n{\n    PlaneDef plane;\n    vec3 xAxis;\n    vec3 yAxis;\n    vec2 zxyScale;\n};\n\nstruct PointLightDef\n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\n// Camera\nstruct CameraDef\n{\n    vec3 pos;\n    vec3 lookAt;\n    float yaw;\n};\n\nstruct Ray\n{\n    vec3 dir;\n    vec3 orig;\n};\n\nstruct HitInfo\n{\n    float dist;\n    vec3 albedo;\n    vec2 uv;\n};\n\nCameraDef sceneCam;\nHeightMapDef sceneHmap;\nHeightMapDef skyHmap;\n\nmat3 constructCameraMat(CameraDef cam) {\n\tvec3 cw = normalize(cam.lookAt-cam.pos);\n    vec3 cp;\n    if(abs(cw.x) > 0. || abs(cw.z) > 0.)\n    {\n        cp = vec3(sin(cam.yaw), cos(cam.yaw), 0.);\n    }\n    else\n    {\n        cp = vec3(sin(cam.yaw), 0., cos(cam.yaw));\n    }\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 rayHitPos(Ray ray, float t)\n{\n    return ray.orig + t*ray.dir;\n}\n\n\nfloat planeIntersect(Ray ray, PlaneDef plane)\n{   \n    float pr = dot(plane.norm, ray.dir);\n    if(abs(pr) > 0.0001)\n    {\n        return dot(plane.norm, plane.pos-ray.orig)/pr;\n    }\n    else\n    {\n        return MAX_DIST;\n    }\n}\n\nHeightMapDef createHeightMap(PlaneDef plane, vec2 scale)\n{\n    vec3 xAxis;\n    vec3 yAxis;\n    if(plane.norm.z >= 0.98)\n    {\n        xAxis = normalize(cross(plane.norm, vec3(0.,1.,0.)));\n    }\n    else\n    {\n        xAxis = normalize(cross(plane.norm, vec3(0.,0.,1.)));\n    }\n    \n    yAxis = cross(xAxis, plane.norm);\n    \n    return HeightMapDef(plane, xAxis, yAxis, scale);\n}\n\nfloat heightMapAO(vec2 fOffset, HeightMapDef hmap, vec2 delta, sampler2D samp)\n{\n    float rad = 3.;\n    float vol = (4./3.)*3.14159256*rad*rad*rad;\n    float sum = 0.;\n    float s0 = hmap.zxyScale.x*texture(samp, fract(fOffset)).a;\n    for (float rx = -rad; rx <= rad + .1; rx = rx + 1.)\n    {\n        for (float ry = -rad; ry <= rad + .1; ry = ry + 1.)\n        {\n            float lsqr = rad*rad - (rx*rx + ry*ry);\n            if (lsqr >= 0.)\n            {\n                vec2 offxy = vec2(rx, ry);\n                float ss = hmap.zxyScale.x*texture(samp, fract(fOffset + offxy*delta*15.)).a;\n                float zz = sqrt(lsqr);\n                float zmin = s0 - zz;\n                float zmax = s0 + zz;\n                float val = clamp(ss, zmin, zmax) - zmin;\n                sum += val;\n            }\n        }\n    }\n    return (1. - clamp(10.*(sum/vol-0.45), 0.0, 1.0));\n}\n\nvec3 heightMapNorm(vec2 fOffset, HeightMapDef hmap, vec2 delta, sampler2D samp)\n{\n    vec2 size = vec2(1./hmap.zxyScale.y, 0.)*delta;\n    const vec3 off = vec3(-1., 0, 1.);\n    float s01 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.xy*delta)).a;\n    float s21 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.zy*delta)).a;\n    float s10 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.yx*delta)).a;\n    float s12 = hmap.zxyScale.x*texture(samp, fract(fOffset + off.yz*delta)).a;\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    vec3 vc = normalize(cross(va,vb));\n    return vc;\n}\n\nvec3 orientMapNormToWorld(vec3 mapNorm, HeightMapDef hmap)\n{\n    return mapNorm.x*hmap.xAxis + mapNorm.y*hmap.yAxis + mapNorm.z*hmap.plane.norm;\n}\n\nbool heightMapShadow2D(vec3 worldLightDir, vec2 fOffset, vec2 delta, HeightMapDef hmap, sampler2D samp)\n{\n    // this won't work. should be multiplied by transpose instead\n    //vec3 lightDir = worldLightDir.x*hmap.xAxis + worldLightDir.y*hmap.yAxis + worldLightDir.z*hmap.plane.norm;\n    vec3 lightDir = worldLightDir; // generalize this later\n    float dd = length(delta);\n    vec3 stepDel = lightDir*dd;\n    \n    ivec2 iprev = ivec2(0, 0);\n    vec2 isum = vec2(0.,0.);\n    ivec2 icurr;\n    \n    vec3 currOffset = vec3(fOffset, hmap.zxyScale.x*texture(samp, fract(fOffset)).a);\n    float currHt;\n    \n    int maxIter = 1000;\n    \n    bool isHit = false;\n    for(int ii = 0; ii < maxIter; ++ii) \n    {\n        isum = isum + lightDir.xy;\n        icurr = ivec2(floor(isum));\n        currOffset = currOffset + stepDel;\n        // preventing oversampling the height\n        if((iprev.x != icurr.x) || (iprev.y != icurr.y))\n        {\n            currHt = hmap.zxyScale.x*texture(samp, fract(currOffset.xy)).a;\n            if(currOffset.z < currHt)\n            {\n                isHit = true;\n                break;\n            }   \n        }\n    }\n    \n    return isHit;\n}\n\nHitInfo heightMapIntersect(Ray ray, HeightMapDef hmap, sampler2D samp, float maxDist)\n{\n    PlaneDef toppdef = hmap.plane;\n    toppdef.pos = hmap.plane.pos + hmap.plane.norm*hmap.zxyScale.x;\n    float t0 = planeIntersect(ray, toppdef);\n    float t1 = planeIntersect(ray, hmap.plane);\n    if(min(t0,t1) >= maxDist)\n    {\n        HitInfo rMaxHit;\n        rMaxHit.dist = MAX_DIST;\n        rMaxHit.albedo = vec3(0.0);\n        rMaxHit.uv = vec2(-1.);\n        return rMaxHit;\n    }\n    const int maxIter = 100;\n    float dt = 1./float(maxIter);\n    float rstep = 0.;\n    if(t1 < t0)\n    {\n        dt = -dt;\n        rstep = 1.;\n        if(t1 < 0. && t0 > 0.)\n        {\n            rstep = abs(t0/(t0-t1));\n        }\n    }\n    vec3 pos0 = rayHitPos(ray, t0) - toppdef.pos;\n    vec3 pos1 = rayHitPos(ray, t1) - hmap.plane.pos;\n    vec2 uv0 = vec2(dot(hmap.xAxis, pos0), dot(hmap.yAxis, pos0));\n    vec2 uv1 = vec2(dot(hmap.xAxis, pos1), dot(hmap.yAxis, pos1));\n    \n    vec4 bsamp = vec4(0.);\n    bool isHit = false;\n    vec2 fOffset = vec2(0.);\n    for(int ii = 0; ii <= maxIter; ++ii) \n    {\n        fOffset = (uv0 + rstep*(uv1-uv0))*hmap.zxyScale.y;\n        float dht = texture(samp, fract(fOffset)).a;\n        float currHt = 1.-rstep;\n        if(dht > currHt)\n        {\n            isHit = true;\n            float r0 = rstep - dt;\n            for(int jj = 0; jj < 4; ++jj)\n            {\n                float rmid = 0.5*(r0 + rstep);\n                fOffset = (uv0 + rmid*(uv1-uv0))*hmap.zxyScale.y;\n                bsamp = texture(samp, fract(fOffset));\n                if(bsamp.a > 1.0-rmid) rstep = rmid;\n                else r0 = rmid;\n            }\n            break;\n        }\n        else\n        {\n            rstep = rstep + dt;\n        }\n    }\n    \n    HitInfo rval;\n    if(isHit)\n    {\n        rval.dist = t0 + rstep*(t1-t0);\n        rval.albedo = bsamp.rgb;\n        rval.uv = fOffset;\n    }\n    else\n    {\n        rval.dist = MAX_DIST;\n        rval.albedo = vec3(0.0);\n        rval.uv = vec2(-1.);\n    }\n    return rval;\n}\n\n\nvec3 getSunDirection(float time)\n{\n    float s = 0.02;\n    return normalize(vec3(cos(s*time), sin(s*time), 1. + 0.5*cos(0.5*s*time)));\n}\n\nvoid constructScene(float time)\n{\n    sceneHmap = createHeightMap(PlaneDef(vec3(0.,1.,0.), vec3(0.,0.,0.)), vec2(1.2, 0.1));\n    skyHmap = createHeightMap(PlaneDef(vec3(0.,-1.,0.), vec3(0.,CLOUD_HEIGHT,0.)), vec2(0.5, 0.05));\n    sceneCam = CameraDef(vec3(10. - 2.*time, 2.5-sin(0.2*time), 4.*sin(0.2*time)), vec3(-2.*time, -cos(0.2*time), 4.*cos(0.2*time)), 0.);\n}\n\nvec3 TonemapACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ground color+heightmap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lowerSection = 0.3;\n    vec2 fOffset = (fragCoord.xy)/(iResolution.xy);// - 0.5*iResolution.xy\n    vec4 b0 = textureLod(iChannel1, fOffset, 0.);\n    vec4 b1 = textureLod(iChannel1, 6.0*fOffset, 0.);\n    vec4 col = 0.7*textureLod(iChannel0, 6.0*fOffset, 0.);\n    col += 0.3*textureLod(iChannel0, fOffset, 0.);\n    \n    float mixRatio = clamp(0.45*b0.r, 0.05, lowerSection)/lowerSection;\n    float height = mix(0.15*(b1.r + 1.5), b0.r, mixRatio);\n    col.rgb = mix(col.rgb, vec3(0., 0.17, 0.04), 1.0-0.6*mixRatio);\n    fragColor = vec4(col.rgb,height);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// sky color+heightmap\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fOffset = fragCoord.xy/iResolution.xy;\n    vec4 b0 = textureLod(iChannel0, fract(1.0*fOffset + 0.01*iTime),0.)*(2. + cos(2.*3.141592*(fOffset.y - fOffset.x) + 0.1*iTime))*0.5;\n    vec4 b1 = textureLod(iChannel0, fract(3.0*fOffset + 0.1*iTime),0.)*(2. + cos(2.*3.141592*(fOffset.y + fOffset.x) + 0.4*iTime))*0.5;\n    float height = (0.8*b0.r+0.2*b1.r);\n    vec3 col = mix(vec3(0.7,0.7,1.0), vec3(0.9,0.9,1.0), height);\n    fragColor = vec4(col,height);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// this buffer computes the shading on the ground\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 fOffset = fragCoord.xy/iResolution.xy;\n    vec3 sunDir = getSunDirection(iTime);\n    vec4 ground = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    float groundHeight = ground.a;\n    \n    constructScene(iTime);\n\n    vec2 skyOffset = fract(fOffset + (CLOUD_HEIGHT)*sunDir.xy);\n    float skyShade = 1.0 - 0.8*texture(iChannel1, vec2(1.0-skyOffset.x, skyOffset.y)).a;\n    \n    // cheating by sampling two \"random\" locations and taking the min\n    // since we know the clouds blend near 1.,1.,1.\n    // for ambient color\n    vec3 skyColorAvg = min(texture(iChannel1, vec2(0.,0.)).rgb, texture(iChannel1, vec2(0.5,0.5)).rgb);\n    \n    HitInfo hitInfo;\n    hitInfo.dist = MAX_DIST;\n    vec3 surfaceColor = vec3(0.);\n    \n    vec2 delta = vec2(1.,1.)/iChannelResolution[0].xy;\n    \n    const float ambientCoeff = 0.7;\n    vec3 surfaceNorm = heightMapNorm(fOffset, sceneHmap, delta, iChannel0);\n    float ambientOccl = ambientCoeff*heightMapAO(fOffset, sceneHmap, delta, iChannel0);\n    bool inShadow = heightMapShadow2D(sunDir, fOffset, delta, sceneHmap, iChannel0);\n    \n    surfaceColor = ground.rgb*ambientOccl;\n    if(!inShadow)\n    {\n        surfaceColor = ground.rgb*1.8*vec3(max(ambientOccl,dot(surfaceNorm,sunDir)));\n    }\n    \n    surfaceColor += 0.05*skyColorAvg;\n    \n    fragColor = vec4(TonemapACES(surfaceColor), groundHeight).rgba;\n    //fragColor = vec4(vec3(ambientOccl), groundHeight).rgba;\n    //fragColor = vec4(ground.rgb, groundHeight).rgba;\n}","name":"Buffer C","description":"","type":"buffer"}]}