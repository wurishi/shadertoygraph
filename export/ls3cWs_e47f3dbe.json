{"ver":"0.1","info":{"id":"ls3cWs","date":"1520548826","viewed":265,"name":"Forest Temple","username":"Flopine","description":"J-22 !","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modulo","shapes","zeldainspiration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind and leon for teaching me! :)\n\n\n#define ITER 80.\n#define PI 3.141592\n#define TAU 2.*PI\n\n/////////////////// UTILITIES\nmat2 rot (float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2 (c,s,-s,c);\n}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n// iq's palette\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n/////////////////// PRIMARY SHAPES\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat cylY (vec3 p, float r)\n{\n    return length(p.xz)-r;\n}\n\n/////////////////// PRIMITIVES\nfloat prim1(vec3 p)\n{\n    p.yz *= rot(PI/2.);\n    return max(-sphe(vec3(p.x,p.y,p.z*0.9),1.06),sdHexPrism (p, vec2 (1.,0.5)));\n}\n\nfloat prim2 (vec3 p)\n{\n    p.xz *= rot(iTime+p.y);\n    p.xz = moda(p.xz, TAU/6.);\n    p.x -= .6;\n\n    return cylY(p,.1);\n}\n\nfloat gear1 (vec3 p, float per)\n{\n\n    p.y = mod(p.y-per/2.,per)-per/2.;\n    p.xz *= rot(iTime);\n    return prim1(p);\n}\n\nfloat gear2 (vec3 p, float per)\n{\n    p.y -= per/2.;\n    p.y = mod(p.y-per/2.,per)-per/2.;\n    p.xz *= rot(-iTime);\n    return prim1(p);\n}\n\nfloat pattern (vec3 p)\n{\n   return min(gear2(p,4.),min(gear1(p, 4.),prim2(p)));  \n}\n\n\n//////////////////// Raymarching field\nfloat SDF (vec3 p)\n{\n    float per = 2.;\n    \n    p.xy *= rot(iTime*0.3+(p.z*0.2));\n    p.z = mod(p.z-per/2.,per)-per/2.;\n    p.xy = moda(p.xy, TAU/4.);\n    p.x -= 4.;\n   return pattern(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (0.001,0.001,iTime);\n    vec3 dir = normalize(vec3 (uv*2.,1.));\n    \n    float shad = 0.;\n    vec3 col = vec3 (0.);\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            col = vec3(1.-shad)*palette(dir.z,\n                          vec3 (0.,0.5,0.),\n                          vec3 (0.,0.2,0.1),\n                          vec3 (0.2),\n                          vec3(iTime*0.3));;\n            break;\n        }\n\n        p+=d*dir*0.7;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}