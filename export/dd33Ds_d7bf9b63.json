{"ver":"0.1","info":{"id":"dd33Ds","date":"1691675300","viewed":61,"name":"MyDragonCurve","username":"Lemlog","description":"Build dragon curve using iterations method","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dragoncurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct int2\n{\n    int X, Y;\n};\nstruct edge_t\n{\n    int2 v, u;\n};\n\n\nconst int2 zero = int2(0,0);\nconst edge_t no_edge = edge_t(zero, zero);\nconst edge_t up_edge = edge_t(zero, int2(0,1));\n\n\nfloat line_dist(vec2 p, vec2 a, vec2 b)\n{\n    if (dot(p-a, b-a) < 0.0) return length(p - a);\n    if (dot(p-b, a-b) < 0.0) return length(p - b);\n    vec2 co = dot(p-a, b-a)/(length(b-a) * length(b-a)) * (b-a);\n    return length(a - p + co);\n}\n\nvec2 to_vec2(int2 p)\n{\n    return vec2(float(p.X), float(p.Y));\n}\n\nint2 to_int2(vec2 p)\n{\n    return int2(int(floor(p.x)), int(floor(p.y)));\n}\n\nfloat edge_dist(vec2 p, edge_t edge)\n{\n    vec2 a = to_vec2(edge.v);\n    vec2 b = to_vec2(edge.u);\n    return line_dist(p, a, b);\n}\n\nedge_t to_edge(vec2 point, float thickness)\n{\n    int2 ld = to_int2(point);\n    int2 lu = int2(ld.X, ld.Y + 1);\n    int2 ru = int2(ld.X + 1, ld.Y + 1);\n    int2 rd = int2(ld.X + 1, ld.Y);\n    int2 corns[] = int2[4](ld, lu, ru, rd);\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        edge_t edge = edge_t(corns[i], corns[(i+1)%4]);\n        if (edge_dist(point, edge) < thickness)\n            return edge;\n    }\n    \n    return no_edge;\n}\n\nvoid exctract_ct(out int2 corn, out int2 tail, edge_t edge)\n{\n    int2 v = edge.v;\n    if ((v.X + v.Y)% 2 == 0)\n    {\n        tail = edge.v;\n        corn = edge.u;\n    }\n    else\n    {\n        tail = edge.u;\n        corn = edge.v;\n    }\n}\n\nint2 rot_point(int2 point)\n{\n    return int2((point.X - point.Y)/2 , (point.X + point.Y)/2);\n}\n\nedge_t collapse_edge(edge_t edge)\n{\n    int2 corn, tail;\n    exctract_ct(corn, tail, edge);\n    \n    int centerX = corn.X;\n    int centerY = corn.Y;\n    \n    tail.X = tail.X - centerX;\n    tail.Y = tail.Y - centerY;\n    \n    // rebuild edge\n    \n    int miu = (centerX % 2);\n    corn.X = (miu == 0)? -tail.Y : tail.Y;\n    corn.Y = (miu == 0)? -tail.X : tail.X;\n    \n    // move back\n    \n    tail.X = tail.X + centerX;\n    tail.Y = tail.Y + centerY;\n    corn.X = corn.X + centerX;\n    corn.Y = corn.Y + centerY;\n    \n    // rotate\n    \n    tail = rot_point(tail);\n    corn = rot_point(corn);\n    \n    return edge_t(corn, tail);\n}\n\nbool int2_equal(int2 a, int2 b)\n{\n    return (a.X == b.X) && (a.Y == b.Y);\n}\n\nbool edge_equal(edge_t a, edge_t b)\n{\n    bool var1 = int2_equal(a.u, b.u) && int2_equal(a.v, b.v);\n    bool var2 = int2_equal(a.u, b.v) && int2_equal(a.v, b.u);\n    return var1 || var2;\n}\n\nfloat dragon_curve(vec2 v, int iter_max, float thickness)\n{\n    edge_t edge = to_edge(v, thickness);\n    if (edge == no_edge) return 1.0;\n    \n    for (int i = 0; i < iter_max; ++i)\n    {\n        edge = collapse_edge(edge);\n    }\n    if (edge_equal(edge, up_edge))\n        return 0.0;\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float scale = 1000.;\n    int iter_max = 32;\n    \n    vec2 center = vec2(0.8, 0.65);\n    \n    vec3 col = vec3(1.0);\n    \n    float thickness = 0.5;\n    float dc = dragon_curve((uv - center)*scale, iter_max, thickness);\n    if (dc < 1.0)\n        col = vec3(0.0);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}