{"ver":"0.1","info":{"id":"Xlc3zH","date":"1467840778","viewed":123,"name":"Box Density","username":"richardlee","description":"Box fog test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat plnIntersect( in vec3 ro, in vec3 rd, vec4 pln )\n{\n    return (pln.w - dot(ro,pln.xyz))/dot(rd,pln.xyz);\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nvec2 boxIntersect( vec3 ro, vec3 rd, mat4 txx, vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0, -1.0);\n\t\n\treturn vec2(tN, tF);\n}\n\nfloat boxDensity(vec3 ro, vec3 rd, mat4 txx, vec3 rad, float dbuffer)\n{\t\n    // ray and ray-box intersection in box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 tA = -n - k;\n    vec3 tB = -n + k;\n\tfloat tN = max( max( tA.x, tA.y ), tA.z );\n\tfloat tF = min( min( tB.x, tB.y ), tB.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    \n    // box behind camera or past dbuffer\n    if( tN > dbuffer || tF < 0.0) return -1.0;\n    \n    // clip integration segment from camera to dbuffer\n    tN = max( tN, 0.0 );\n    tF = min( tF, dbuffer );\n    \n    // move ray to start from tN\n    roo += tN*rdd;\n    tF -= tN;\n    tN = 0.0;\n    \n#if 1\n    // density calculation. density is of the form\n    //\n    // d(x,y,z) = [1-(x/rx)^2] * [1-(y/ry)^2] * [1-(z/rz)^2];\n    //\n    // this can be analytically integrable (it's a degree 6 polynomial):\n    vec3 a = rad * rad - roo * roo;;\n    vec3 b = -2.0 * roo * rdd;\n    vec3 c = -(rdd * rdd);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    float t4 = t2*t2;\n    float t5 = t2*t3;\n    float t6 = t3*t3;\n    float t7 = t3*t4;\n    \n    float i2 = (t1/1.0) *(a.x*a.y*a.z) + \n              (t2/2.0) *(a.x*a.y*b.z + a.x*b.y*a.z + b.x*a.y*a.z) + \n              (t3/3.0) *(a.x*a.y*c.z + a.x*b.y*b.z + a.x*c.y*a.z + b.x*a.y*b.z + b.x*b.y*a.z + c.x*a.y*a.z) +\n              (t4/4.0) *(a.x*b.y*c.z + a.x*c.y*b.z + b.x*a.y*c.z + b.x*b.y*b.z + b.x*c.y*a.z + c.x*a.y*b.z + c.x*b.y*a.z) + \n              (t5/5.0) *(a.x*c.y*c.z + b.x*b.y*c.z + b.x*c.y*b.z + c.x*a.y*c.z + c.x*b.y*b.z + c.x*c.y*a.z) + \n              (t6/6.0) *(b.x*c.y*c.z + c.x*b.y*c.z + c.x*c.y*b.z) + \n              (t7/7.0) *(c.x*c.y*c.z);\n    float fog = i2 / (rad.x * rad.x * rad.y * rad.y * rad.z * rad.z);\n    \n\treturn fog / (length(rad));\n#else\n    vec3 a = rad * rad - roo * roo;;\n    vec3 b = -2.0 * roo * rdd;\n    vec3 c = -(rdd * rdd);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    \n    float i2 = a.x * t1 + b.x * t2/2.0 + c.x * t3/3.0;\n    float fog = i2 / (rad.x * rad.x);\n    \n\t// return tF - tN;\n\t//return roo.x; \n\treturn fog / (2.0 * rad.x) ;\n#endif\n}\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y; //-1 to 1\n    \n\tvec3 ro = vec3(0.0, 1.0, 3.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n    // sphere\n    vec4 sph = vec4( cos( iTime*vec3(1.0,1.1,1.3) + vec3(2.0,1.5,1.5) + 0.0 )*vec3(1.5,0.3,0.7) + vec3(0.0,0.2,0.5), 1.0 );\n    // planes\n    vec4 pl1 = vec4(  0.0, 1.0, 0.0, 0.0 );\n    vec4 pl2 = vec4(  1.0, 0.0, 0.0, 1.0 );\n    vec4 pl3 = vec4( -1.0, 0.0, 0.0, 1.0 );\n    vec4 pl4 = vec4(  0.0, 0.0,-1.0, 1.0 );\n    \n    \n    vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n\n\t\n    \n    float t2 = plnIntersect( ro, rd, pl1 );\n    float t3 = plnIntersect( ro, rd, pl2 );\n    float t4 = plnIntersect( ro, rd, pl3 );\n    float t5 = plnIntersect( ro, rd, pl4 );\n    \n    float tmin = 1000.0;\n    vec4  omin = vec4(0.0);\n    if( t2>0.0 && t2<tmin ) { tmin=t2; omin=pl1; }\n    if( t3>0.0 && t3<tmin ) { tmin=t3; omin=pl2; }\n    if( t4>0.0 && t4<tmin ) { tmin=t4; omin=pl3; }\n    if( t5>0.0 && t5<tmin ) { tmin=t5; omin=pl4; }\n\n    vec3 col = vec3(0.0);\n    \n    //Draw walls\n    vec3 pos = ro + tmin*rd;\n    col = vec3(0.1,0.15,0.2);\n    col *= 0.8 + 0.4*dot(omin.xyz,lig);\n    vec3 w = abs(omin.xyz);\n    col = (texture( iChannel0, 0.5*pos.zx ).xyz*w.y+\n           texture( iChannel0, 0.5*pos.xy ).xyz*w.z+\n           texture( iChannel0, 0.5*pos.yz ).xyz*w.x)/(w.x+w.y+w.z);\n    col *= 0.3;\n    float occ = 1.0;\n    occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2( 1.0, 0.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2(-1.0, 0.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.yz-vec2( 0.0,-1.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2( 1.0,-1.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2(-1.0,-1.0)));\n    col *= vec3(0.4,0.3,0.2) + vec3(0.6,0.7,0.8)*occ;\n    \n    /*float h = sphDensity(ro, rd, sph.xyz, sph.w, tmin );\n    if( h>0.0 )\n    {\n        //col = mix( col, vec3(0.2,0.5,1.0), h );\n        col = vec3(1.0, 0.5, 0.4);\n    }*/\n    \n    // rotate and translate box\t\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 1.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n    vec3 box = vec3(1.2 , 1.2, 0.8) ;\n    //vec3 box = vec3(1.0, 0.4, 0.4) ;\n    vec2 res = boxIntersect( ro, rd, txx, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\t//col = vec3(0.5, 1.0, 0.4);\n        float hBox = boxDensity( ro, rd, txx, box, tmin);\n    //if (hBox > 0.0) {\n        \n        col = mix( col, vec3(0.2,0.5,1.0), hBox );\n        if (hBox > 1.0) {\n         \tcol = vec3(1.0, 0.0, 0.0);   \n        }\n    //}\n\t}\n    \n    col = sqrt( col );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}