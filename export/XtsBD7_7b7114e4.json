{"ver":"0.1","info":{"id":"XtsBD7","date":"1512107731","viewed":132,"name":"Mushrooms","username":"kvanttiapina","description":"Mushrooms moving about on a surface of a sphere.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mushrooms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mushrooms by JUkka Sirkka\n// \n// Credits: early versions based on this tutorial:\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// shadow mapping, ambient occlusion, sky gradient from \n// https://www.shadertoy.com/view/ldl3zn (P_Malin: TimeWarp)\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 600.0;\nconst float EPSILON = 0.0001;\nconst float NORMAL_DELTA = 0.1;\nconst float PI = 3.1415926535897932384626433832795;\nconst float MUSHROOM_RADIUS = 10.;\nconst float EARTH_RADIUS = 200.;\n\n\n\nconst int NO_HITS = -1;\nconst int THING = 1;\nconst int SKY = 3;\nconst int EARTH = 4;\n\nstruct Ray {\n    vec3 eye;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    int object;\n    float dist;\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n\n// ramp function with period = 2\nfloat ramp(float x) {\n    return 2. * mod(x, 1.) - 1.;\n}\n\n// square function with on/off values a & b, period 2\nfloat square(float a, float b, float x) {\n    return mix(a, b, step(ramp(x), 0.));\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(a, b, h) + k * h * (1. - h);\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nHitInfo intersectH(const in HitInfo a, const in HitInfo b) {\n    if (a.dist > b.dist) return a;\n    return b;\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nHitInfo unionH(const in HitInfo a, const in HitInfo b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n\nHitInfo unionSH(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist < b.dist ? a.object : b.object, smin(a.dist, b.dist, .5));\n}\n\nHitInfo unionS1(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist < b.dist ? a.object : b.object, smin(a.dist, b.dist, 1.));\n}\n\nHitInfo unionS2(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist < b.dist ? a.object : b.object, smin(a.dist, b.dist, 2.));\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nHitInfo differenceH(const in HitInfo a, const in HitInfo b) {\n    if (a.dist > - b.dist) return a;\n    return HitInfo(b.object, -b.dist);\n}\n\nHitInfo differenceSH(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist > - b.dist ? a.object : b.object, smax(a.dist, -b.dist, .5));\n}\n\nHitInfo differenceS1(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist > - b.dist ? a.object : b.object, smax(a.dist, -b.dist, 1.));\n}\n\nHitInfo differenceS2(const in HitInfo a, const in HitInfo b) {\n    return HitInfo(a.dist > - b.dist ? a.object : b.object, smax(a.dist, -b.dist, 2.));\n}\n\n\nfloat sphereSDF(const in vec3 p) {\n    return length(p) - 1.0;\n}\n\n\nfloat plateSDF(const in vec2 p, const in vec2 dim) {\n    vec2 d = (abs(p) - dim);\n    return max(d.x, d.y);\n}\n\nfloat cylinderSDF(const in vec3 p, const in vec2 h) {\n    return plateSDF(vec2(length(p.xy), p.z), h);\n}\n\n\nvec3 rotateX(const in vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y*c - p.z*s, p.y*s + p.z*c);\n}\n\nvec3 rotateZ(const in vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x*c - p.y*s, p.x*s + p.y*c, p.z);\n}\n\nvec3 repeatE(const in vec3 p) {\n    float a = mod(atan(p.y, p.z) + PI, PI / 8.) - PI / 16.;\n    float r = length(p.yz);\n    return vec3(p.x, r*sin(a), r*cos(a));\n}\n\n\nvec3 moveTo(const vec3 p, vec2 pos) {\n    vec3 coe = vec3(0, 0, -EARTH_RADIUS);\n    // 0: latitude, 1: longitude\n    return repeatE(rotateX(rotateZ(p - coe, radians(pos[1])), radians(90. - pos[0]))) + coe;\n}\n\n\nHitInfo mushroom(in HitInfo ground, const in vec3 p, const in vec2 p0) {\n    vec3 q;\n    const float rob = MUSHROOM_RADIUS;\n    const float rou = .5 * MUSHROOM_RADIUS;\n    const float rol = .6 * MUSHROOM_RADIUS;\n    const vec2 cdim = vec2(.5, 6.);\n\n    q = moveTo(p, p0)  + vec3(.0, .0, .6 * rob - cdim[1]);\n    HitInfo mc = HitInfo(THING, cylinderSDF(q, cdim));\n    ground = unionS2(ground, mc);\n\n    q += vec3(.0, .0, -cdim[1] + rou * .95);\n    HitInfo mhu = HitInfo(THING, sphereSDF(q / rou) * rou);\n    q += vec3(.0, .0, mix(1.5, 2.0, 1. + sin(2.*iTime)));\n    HitInfo mhl = HitInfo(THING, sphereSDF(q / rol) * rol);\n\n    return unionH(ground, differenceSH(mhu , mhl));\n\n}\n\n\nHitInfo ground(in HitInfo earth, const in vec3 p, const in vec2 p0) {\n    vec3 q;\n    const float rob = MUSHROOM_RADIUS;\n\n    q = moveTo(p, p0)  - vec3(.0, .0, .4 * rob);\n    HitInfo mb = HitInfo(EARTH, sphereSDF(q / rob) * rob);\n\n    return differenceS2(earth, mb);\n}\n\nHitInfo sceneH(const in vec3 p) {\n    vec3 q;\n\n    vec3 coe = vec3(0., 0., -EARTH_RADIUS);\n\n    vec2 p1 = vec2(70, 90) + iTime * vec2(-3.3, 3.4);\n    vec2 p2 = vec2(70, -30) + iTime * vec2(3.9, -3.4);\n    vec2 p3 = vec2(70, 60) + iTime * vec2(3.6, 3.2);\n\n    q = p - coe;\n    HitInfo earth = HitInfo(EARTH, sphereSDF(q / EARTH_RADIUS) * EARTH_RADIUS);\n\n    earth = ground(earth, p, p1);\n    earth = ground(earth, p, p2);\n    earth = ground(earth, p, p3);\n\n    earth = mushroom(earth, p, p1);\n    earth = mushroom(earth, p, p2);\n    earth = mushroom(earth, p, p3);\n\n    float sky_radius = 2. * EARTH_RADIUS;\n    HitInfo sky = HitInfo(SKY, - sphereSDF(p / sky_radius) * sky_radius);\n\n    return unionH(sky, earth);\n\n}\n\nfloat sceneSDF(const in vec3 samplePoint) {\n    HitInfo hit = sceneH(samplePoint);\n    return hit.dist;\n}\n\nHitInfo raymarch(const in Ray ray, float start, float end) {\n    float depth = start;\n    HitInfo hit;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        hit = sceneH(ray.eye + depth * ray.dir);\n        if (hit.dist < EPSILON) {\n            return HitInfo(hit.object, depth);\n        }\n        depth += hit.dist;\n        if (depth >= end) {\n            return HitInfo(NO_HITS, 0.);\n        }\n    }\n    return HitInfo(NO_HITS, 0.);\n}\n\n\n\n\nvec3 estimateNormal(vec3 p) {\n    // assuming we are on the surface where sceneSDF ~ 0\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + NORMAL_DELTA, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + NORMAL_DELTA, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + NORMAL_DELTA))\n    ));\n}\n\n\nvec3 getColorGeom(const in Light light, vec3 p, vec3 N, vec3 V, const in Material mat) {\n\n    vec3 c = vec3(0., 0., 0.);\n\n    vec3 L = normalize(light.pos - p);\n\n    float d = dot(L, N);\n\n    if (d < 0.) return c;\n\n    c += d * light.color * mat.diffuse;\n\n    // Blinn-Phong\n    vec3 H = normalize(L + V);\n    float k = dot(H, N);\n    if (k < 0.) return c;\n\n    c += pow(k, mat.shininess) * light.color * mat.specular;\n\n    return c;\n}\n\n\n\nMaterial getMaterial(int object, vec3 p, vec3 n) {\n    Material mat;\n    mat.ambient = vec3(.1, .1, .1);\n    mat.specular = vec3(.6, .6, .6);\n    mat.shininess = 10.;\n    if (object == THING) {\n        mat.diffuse = square(1., 2., p.x * 10.) * square(.5, 1., p.z * 10.) * vec3(.2, .9, .1);\n    } else if (object == SKY) {\n        mat.diffuse = vec3(.1, .1, .3);\n    } else if (object == EARTH) {\n        mat.diffuse = square(.5, 1.4, p.x) * square(.5, .7, p.y) * vec3(.56, .09, .03);\n    } else {\n        mat.diffuse = vec3(.0, .0, .0);\n    }\n\n    return mat;\n}\n\nvec3 getSkyGradient(const in vec3 dir)\n{\n    const vec3 sky = .15 * vec3(13./255., 214./255., 208./255.);\n    float blend = dir.z * 0.5 + 0.5;\n    return mix(vec3(.0), sky, blend);\n}\n\n// use distance field to evaluate ambient occlusion\nfloat getAmbientOcclusion(const in vec3 p, const in vec3 n)\n{\n    float occl = 1.;\n    float dist = 0.;\n\n    for (int i = 0; i < 5; i++) {\n        dist += .1;\n        float sdist = sceneSDF(p + n * dist);\n        occl *= 1. - max(0., (dist - sdist) * .4 / dist);\n    }\n    return occl;\n}\n\nfloat getShadow(const in vec3 l, const in vec3 p) {\n    float dist = length(p - l);\n\n    Ray ray;\n    ray.dir = (p - l) / dist;\n    ray.eye = l;\n\n    HitInfo hit = raymarch(ray, MIN_DIST, MAX_DIST);\n    if (hit.object == NO_HITS) {\n        return 0.;\n    }\n\n    return mix(.2, 1., step(dist - 0.01, hit.dist));\n}\n\n\n\nvec3 getColor(const in Ray ray, const in HitInfo hit) {\n\n    if (hit.object == SKY) {\n        vec3 c = getSkyGradient(ray.dir);\n        return pow(10. * c, vec3(1.8));\n    }\n\n    Light light;\n    vec3 baseColor = vec3(.8);\n\n    vec3 p = ray.eye + hit.dist * ray.dir;\n    vec3 n = estimateNormal(p);\n\n    Material mat = getMaterial(hit.object, p, n);\n\n    float ambientOcclusion = getAmbientOcclusion(p, n);\n    vec3 c = getSkyGradient(n) * ambientOcclusion;\n\n    c += getSkyGradient(reflect(ray.dir, n)) * ambientOcclusion;\n\n    // light.pos = vec3(4*sin(iTime), 4*cos(iTime), 2);\n    // c += getColorGeom(light, p, n, -ray.dir, mat);\n\n    light.pos = vec3(4.*sin(.37 * iTime), 4.*cos(.37 * iTime), 20.);\n    light.color = getShadow(light.pos, p) * baseColor;\n    c += getColorGeom(light, p, n, -ray.dir, mat);\n\n    return c;\n}\n\nmat4 windowToView(const in vec2 dim) {\n\tmat4 m = mat4(1.);\n\n    const float ct = 1. / tan(radians(22.5));\n    const float n = 1.;\n    const float f = 500.;\n    const float d = (n + f) / (n - f);\n    const float e = 2. * n * f / (n - f);\n\n    float a = dim.x / dim.y;\n\n    m[0][0] = a / ct;\n    m[1][1] = 1. / ct;\n    m[2][2] = 0.;\n    m[3][3] = d / e;\n    m[3][2] = -1.;\n    m[2][3] = 1. / e;\n    \n    return m;\n}\n\nmat4 viewToWorld(const in vec3 eye) {\n    const vec3 up = vec3(0., -1., 1.);\n    const vec3 center = vec3(0.);\n    \n    vec3 z = normalize(eye - center);\n    vec3 y = normalize(up - dot(z, up) * z);\n    vec3 x = cross(y, z);\n    \n    return mat4(vec4(x, 0.),\n                vec4(y, 0.),\n                vec4(z, 0.),\n                vec4(eye, 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    mat4 inv_proj = windowToView(iResolution.xy);\n    vec4 p1 = vec4(2. * fragCoord / iResolution.xy - 1., 1., 1.);\n    vec3 p2 = (inv_proj * p1).xyz;\n\n    vec3 eye = vec3(50., 70., 10.);\n    float zoom = .6;\n    mat4 inv_cam = viewToWorld(zoom * eye);\n\n    Ray ray;\n    ray.dir = normalize((inv_cam * vec4(p2, .0)).xyz);\n    ray.eye = inv_cam[3].xyz;\n\n    HitInfo hit = raymarch(ray, MIN_DIST, MAX_DIST);\n\n    if (hit.object == NO_HITS) {\n        // Didn't hit anything\n        fragColor = vec4(0., 0., .0, .0);\n        return;\n    }\n\n    fragColor = vec4(getColor(ray, hit), 1);\n}\n","name":"Image","description":"","type":"image"}]}