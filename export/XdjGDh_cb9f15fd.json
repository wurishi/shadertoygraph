{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define STEPS 128.0\n#define FIXED_STEP 0.01\n#define EPSILON 0.005\n\n#define CUBEMAP iChannel0\n#define TIME iTime\n#define TRACK iChannel3\n\nconst float tau = 6.28318530717958647692;\nconst vec3 camPos = vec3(0.0, 4.0, -2.6);\nconst vec3 camLook = vec3(0.0, 0.0, 0.0);\n\n// STRUCTURE DEFINITIONS\n\nstruct Hit {\n\tbool intersect;\n\tvec3 point;\n\tvec3 color;\n\tvec3 normal;\n};\n\t\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\n\t\n// ROTATIONS\n\t\nmat3 rotate3DX(float a) { \n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a));\n}\n\nmat3 rotate3DY(float a) {\n\treturn mat3(cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a));\n}\n\nmat3 rotate3DZ(float a) {\n\treturn mat3(cos(a), -sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n}\n\nmat3 rotate3D(float x,float y,float z) {\n\treturn rotate3DX(x)*rotate3DY(y)*rotate3DZ(z);\n}\n\n\n// DISTANCE FUNCTION PRIMITIVES\n\nfloat sdPlane(vec3 p, vec4 n) {\n   \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCross(vec3 p) {\n\tfloat da = sdBox(p.xy, vec2(1.0));\n\tfloat db = sdBox(p.yz, vec2(1.0));\n\tfloat dc = sdBox(p.zx, vec2(1.0));\n\treturn min(da, min(db, dc));\n}\n\n// RAY MARCHING FUNCTIONS\n\nvec4 map(vec3 p) {\n\t// Rotate and zoom\n\t//mat3 rotation = rotate3D(TIME/3.0, TIME/2.0, TIME);\n\t//p.z -= 3.22;\n\t//p *= rotation;\n\t\n\t// Twist\n\tfloat c = cos((sin(TIME)/(2.12))*p.y);\n    float si = sin((sin(TIME)/(2.12))*p.y);\n    mat2  m = mat2(c,-si,si,c);\n    vec3  q = vec3(m*p.xz,p.y);\n\tvec3 temp = p;\n\tp = q;\n\t\n\t// Box\n\t//float d = sdBox(p, vec3(1.0));\n\tfloat d = sdBox(p, vec3(0.5+pow(texture(TRACK,vec2(0.0,0.0)).x,2.0)/2.0));\n\tvec4 res = vec4(d, 1.0, 0.0, 0.0);\n    float s = 2.0;\n\t\n\t// Menger sponge\n\tfor (int m = 0; m<4; ++m) {\n\t\tvec3 a = mod (p*s, 2.0)-1.0;\n\t\ts *= 4.0;\n\t\tvec3 r = abs(1.0 - 3.0*abs(a));\n\t\t\n\t\tfloat da = max(r.x, r.y);\n\t\tfloat db = max(r.y, r.z);\n\t\tfloat dc = max(r.z, r.x);\n\t\tfloat c = ( min( da, min(db,dc) ) - 1.0)/s;\n\t\t\n\n\t\tif(c > d)\n      \t{\n\t\t\td = c;\n\t\t\tres = vec4(d, vec3(0.3*da*db*dc, 0.2*da, 0.2*db));\n       \t}\n\t}\n\t\n//\tif (res.x > sdPlane(temp, vec4(0.0, 1.0, 0.0, 1.0))) {\n//\t\tres.x = sdPlane(temp, vec4(0.0, 1.0, 0.0, 1.0));\n//\t\tres.yzw = vec3(1.0, 1.0, 1.0);\n//\t}\n\t\n\treturn res;\n}\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.01, 0.01, 0.0);\n\tvec3 n;\n\tn.x = map(p + e.xyy).x - map(p - e.xyy).x;\n\tn.y = map(p + e.yxy).x - map(p - e.yxy).x;\n\tn.z = map(p + e.yyx).x - map(p - e.yyx).x;\n\treturn normalize(n);\n}\n\n// Parameters: \tr - ray\n//\t\t\t\ts - stepping multiplier\n//\t\t\t\tt - threshold\nHit intersect(Ray r, float s, float t) {\n\tvec3 p = r.origin;\n\tvec3 q = r.origin;\n\t\n\tvec4 res;\n\tfloat l, i;\n\tHit hit;\n\t\n\tfor (float j=0.0; j<1.0; j+=1.0/STEPS) {\n\t\ti = j;\n\t\tres = map(p);\n\t\tl = res.x;\n\t\tp += l*r.direction*s;\n\t\t\n\t\tif (abs(l) < t) {\n\t\t\thit.intersect = true;\n\t\t\thit.point = vec3(i, length(q-p), l);\n\t\t\thit.normal = normal(hit.point);\n\t\t\thit.color = res.yzw;\n\t\t\treturn hit;\n\t\t}\n\t\t\n\t\tif (abs(l) > 80.0) {\n\t\t\tbreak;\n\t\t}\n\t};\n\t\n\thit.intersect = false;\n\treturn hit;\n}\n\n\n// CAMERA FUNCTIONS\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 getRay(vec3 dir, float zoom, vec2 uv)\n{\n\tuv = uv - 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn dir + right*uv.x + up*uv.y;\n}\n\n\n// MAIN FUNCTION\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n\t\n\t// Rotate and zoom camera\n\tvec3 camPos = camPos;\n\tvec3 camLook = camLook;\n\t\n\tvec2 camRot = vec2(iTime*.1,0)+.5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(1,-1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tRay ray = Ray(camPos, getRay(camLook-camPos, 1.0, pixel));\n\tHit hit = intersect(ray, 0.35, 0.001);\n\t\n\tvec3 color;\n\tvec3 hdr;\n\t\n\tif (hit.intersect) {\n\t\t// Refraction\n\t\t//vec3 refractVector = refract(ray.direction, hit.normal, 0.5);\n\t\t//Ray refractRay = Ray(hit.point+refractVector*0.35, refractVector);\n\t\t//Hit refractHit = intersect(refractRay, -0.35, 0.001);\n\t\t//vec3 refractColor = mix(hit.color, refractHit.color, distance(refractHit.point, hit.point)/2.0);\n\t\t\n\t\t// Reflection\n\t\tvec3 reflectVector = reflect(ray.direction, hit.normal);\n\t\tvec3 reflectColor = texture(CUBEMAP, reflectVector).xyz;\n\t\tRay reflectRay = Ray(hit.point+reflectVector*0.1, reflectVector);\n\t\tHit reflectHit = intersect(reflectRay, 0.35, 0.001);\n\t\t\n\t\tif (reflectHit.intersect) {\n\t\t\tcolor = hit.color * 0.35;\n\t\t}\n\t\telse {\n\t\t\tvec3 hdr = 1.0/(1.2-reflectColor) - 1.0/1.2;\n\t\t\tcolor = mix(hit.color, hdr, 0.15);\n\t\t\t//hit.color * ((reflectColor.x+reflectColor.y+reflectColor.z)/3.0);\n\t\t\t//color = mix(refractColor, reflectColor, 0.5);\n\t\t}\n\t\t\t\t\n\t}\n\telse {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjGDh","date":"1387194518","viewed":244,"name":"Simple ray marcher","username":"Zerphed","description":"A draft of a simple ray marcher shader visualising a Menger sponge.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mengersponge"],"hasliked":0,"parentid":"","parentname":""}}