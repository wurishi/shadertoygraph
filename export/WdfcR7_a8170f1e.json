{"ver":"0.1","info":{"id":"WdfcR7","date":"1584352862","viewed":264,"name":"Comic book halftone","username":"voax","description":"CMYK halftone effect","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["halftone","cmyk","comic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float size = 7.0; // length of edges of grid\nfloat angle = 0.0;\n#define SEPERATE_CHANNELS\n\nconst float sin30 = 0.5;\nconst float cos30 = 0.86602540378; // = sin60 = sqrt(3) / 2.0\nconst float sqrt3 = sqrt(3.0);\n\nbool feq(float a, float b) { return abs(a-b) < 1e-5; }\nfloat lengthSq(vec2 v) { return dot(v,v); }\n\nvec2 triangleCell(vec2 xy) {\n    vec2 pos = xy / vec2(size * sin30, size * cos30);\n    vec2 i = floor(pos);\n    vec2 r = fract(pos);\n    if(feq(mod(i.x, 2.), 1.) ^^ feq(mod(i.y, 2.), 1.)) { \n        if (r.x + r.y < 1.0)\n            i.x--; \n    } \n    else { \n        if(r.x - r.y < 0.0)\n            i.x--; \n    }\n    return i;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvec2 findNearest(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 nearest = a;\n    float best_distSq = lengthSq(p-a);\n    float f;\n    if ( (f=lengthSq(p-b)) < best_distSq) {\n    \tbest_distSq = f;\n        nearest = b;\n    }\n    if ( (f=lengthSq(p-c)) < best_distSq) {\n    \tbest_distSq = f;\n        nearest = c;\n    }\n    return nearest;\n}\n\nvec2 nearestTriangleVertex(vec2 xy) {\n    vec2 i = triangleCell(xy);\n    \n    vec2 origin = vec2(i) * vec2(size * sin30, size * cos30);\n    vec2 x = origin;\n    vec2 y = origin + vec2(size, 0);\n    vec2 z = origin + vec2(size * 0.5, 0);\n    \n    if (feq(mod(i.y, 2.), 1.) ^^ feq(mod(i.x, 2.), 1.))\n    {\n        x.y += size * cos30;\n        y.y += size * cos30;\n    }\n    else\n        z.y += size * cos30;\n    \n    vec2 nearest_vertex = findNearest(xy, x, y, z);\n    return nearest_vertex;\n}\n\nvec4 rgb2cmyk(vec3 rgb) {\n    float k = 1. - max(rgb.r, max(rgb.g, rgb.b));\n    return vec4(vec3((1.-rgb.r-k),\n            \t \t (1.-rgb.g-k),\n                 \t (1.-rgb.b-k)) / (1.-k),\n        \t\t k);\n}\n\nvec3 cmyk2rgb(vec4 cmyk) {\n    return vec3((1.-cmyk.x)*(1.-cmyk.w),\n                (1.-cmyk.y)*(1.-cmyk.w),\n                (1.-cmyk.z)*(1.-cmyk.w));\n}\n\nvec4 halftone_dist(vec2 xy, mat2 m) {\n    vec2 rxy = m * xy;\n    \n    vec2 triangle_xy = nearestTriangleVertex(m * xy) * m;\n    \n    float dSq = lengthSq(xy - triangle_xy);\n    \n    vec2 uv = triangle_xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(2.2));\t// convert texture to linear gamma\n    vec4 cmyk = rgb2cmyk(col);\n    float maxCircleSizeSq = 0.25 * size * size; // max circle size = 0.5 * size\n    // radius = sqrt(linear color) * maxCircleSize\n    vec4 radiusSq = cmyk * maxCircleSizeSq;\n    return dSq / radiusSq; // return ratio distance^2 / radius^2\n}\n\n\nvec4 sobel(vec2 texCoord) {\n\tvec2 invTexSize = 2.0 / iChannelResolution[0].xy;\n\n    vec4 nxny = texture(iChannel0, texCoord + invTexSize * vec2(-1, -1));\n    vec4 nxby = texture(iChannel0, texCoord + invTexSize * vec2(-1,  0));\n    vec4 nxpy = texture(iChannel0, texCoord + invTexSize * vec2(-1,  1));\n\n    vec4 bxny = texture(iChannel0, texCoord + invTexSize * vec2( 0, -1));\n    vec4 bxby = texture(iChannel0, texCoord + invTexSize * vec2( 0,  0));\n    vec4 bxpy = texture(iChannel0, texCoord + invTexSize * vec2( 0,  1));\n\n    vec4 pxny = texture(iChannel0, texCoord + invTexSize * vec2( 1, -1));\n    vec4 pxby = texture(iChannel0, texCoord + invTexSize * vec2( 1,  0));\n    vec4 pxpy = texture(iChannel0, texCoord + invTexSize * vec2( 1,  1));\n\n/*\n    vec4 sobelx = -nxny - 2*nxby - nxpy + pxny + 2 * pxby + pxpy;\n    vec4 sobely = -nxny - 2*bxny - pxny + nxpy + 2 * bxpy + pxpy;\n    vec4 sobel = sqrt(sobelx*sobelx + sobely*sobely);\n*/\n\n    vec3 vScale = vec3(0.3333); // average color values:\n    // vec3 vScale = vec3(0.2126, 0.7152, 0.0722); // 'luma' weights\n    float fnxny = dot(nxny.rgb, vScale);\n    float fnxby = dot(nxby.rgb, vScale);\n    float fnxpy = dot(nxpy.rgb, vScale);\n\t\t\n    float fbxny = dot(bxny.rgb, vScale);\n    float fbxby = dot(bxby.rgb, vScale);\n    float fbxpy = dot(bxpy.rgb, vScale);\n\t\t\n\tfloat fpxny = dot(pxny.rgb, vScale);\n\tfloat fpxby = dot(pxby.rgb, vScale);\n\tfloat fpxpy = dot(pxpy.rgb, vScale);\n\n    vec2 fsobel;\n    fsobel.x = -fnxny - 2.0*fnxby - fnxpy + fpxny + 2.0 * fpxby + fpxpy;\n    fsobel.y = -fnxny - 2.0*fbxny - fpxny + fnxpy + 2.0 * fbxpy + fpxpy;\n    float sobelf = sqrt(fsobel.x*fsobel.x + fsobel.y*fsobel.y);\n    \n    return vec4(sobelf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.5) {\n        size = mix(3., 100., iMouse.y / iResolution.y);\n        angle = 360.0 * iMouse.x / iResolution.x;\n    }\n    \n    mat2 my = rotm(radians( 0.0 + angle));\n    \n    vec4 ratio;\n#ifdef SEPERATE_CHANNELS\n    mat2 mc = rotm(radians(15.0 + angle));\n    mat2 mm = rotm(radians(75.0 + angle));\n    mat2 mk = rotm(radians(45.0 + angle));\n\n    ratio.x = halftone_dist(fragCoord, mc).x;\n    ratio.y = halftone_dist(fragCoord, mm).y;\n    ratio.z = halftone_dist(fragCoord, my).z;\n    ratio.w = halftone_dist(fragCoord, mk).w;\n#else\n    ratio = halftone_dist(fragCoord, my);\n#endif\n    \n    vec4 col = vec4(1.);\n    if (ratio.x > 1.0) col.x = 0.;\n    if (ratio.y > 1.0) col.y = 0.;\n    if (ratio.z > 1.0) col.z = 0.;\n    if (ratio.w > 1.0) col.w = 0.;\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 cmyk = rgb2cmyk(texture(iChannel0, uv).xyz);\n    col.w = cmyk.w; // use original key value\n    vec3 rgb = cmyk2rgb(col);\n\n    // add simple outline\n    vec4 edge = sobel(uv);\n    if (edge.a > 0.25) \n    {\n        float s = edge.a;\n        s = 1.0 - pow(1.0 - s, 0.5);\n        rgb = vec3(0.) * s + rgb * (1.0 - s);\n    }\n    \n    fragColor = vec4(rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}