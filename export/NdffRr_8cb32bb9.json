{"ver":"0.1","info":{"id":"NdffRr","date":"1644401304","viewed":128,"name":"Metaball slime waterfall","username":"tachiweasel","description":"A waterfall of metaball slime. Inspired by Doom (and could be used as a replacement for the appropriate textures in the game, if your source port supports it).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","fluid","slime","nukage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Waterfall of metaball slime/nukage, inspired by Doom.\n//\n// Plenty of improvements are possible. For example, we could precompute all the\n// metaball positions for each frame and store them in a texture instead of\n// regenerating them for every pixel.\n\n// Constants\n\nconst float PI = 3.14159;\nconst float EPSILON = 0.01;\n\n// This is the major thing that affects performance...\nconst float STEP_SIZE = 0.25;\n\n// Metaballs\nconst int DROPS = 28;\nconst float METABALL_SPEED = 11.0;\nconst float CHARGE_THRESHOLD = 0.25;\n\n// Fluid\nconst int LOWER_WAVE_COUNT = 3;\nconst float MAX_AMPLITUDE = 0.5;\nconst float FLUID_SPEED = 5.0;\n\n// Background\nconst vec3 GLOW = vec3(0.05, 0.3, 0.05);\nconst vec3 SHADOW = vec3(0.04, 0.25, 0.04);\n\n// Utilities\n\nfloat linstep(float fromMin, float fromMax, float toMin, float toMax, float from) {\n    float value = toMin + (from - fromMin) / (fromMax - fromMin) * (toMax - toMin);\n    return clamp(value, min(toMin, toMax), max(toMin, toMax));\n}\n\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//\tSimplex 3D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    //  x0 = x0 - 0. + 0.0 * C\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                         + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0 / 7.0; // N=7\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\n// Metaballs\n\nvec3 setupMetaball(int i) {\n    float normX = rand(vec2(float(i), 0.0));\n    vec2 origin = vec2(mix(-2.25, 2.25, normX), 7.0);\n\n    float time = iTime - float(i) * 0.10;\n    float loop = floor(time / 2.0);\n    time = mod(time, 2.0);\n\n    vec2 pos;\n    float radius;\n    if (time <= 0.0) {\n        radius = 0.0;\n        pos = vec2(99.0);\n    } else {\n        radius = mix(0.1, 0.5, rand(vec2(float(i), 500.0 + loop)));\n        float y = origin.y - time * METABALL_SPEED;\n        pos = vec2(origin.x, y);\n    }\n\n    return vec3(pos, radius);\n}\n\n// FIXME: These formulas seem dubious... Are they right?\n\nfloat metaball(vec3 pos, vec3 center, float radius, out vec3 normal) {\n    normal = normalize(center - pos);\n    float dist = length(center - pos) / radius;\n    if (dist < 0.001)\n        return 1.0;\n    return 1.0 / (dist * dist);\n}\n\nfloat metacube(vec3 pos, vec3 center, vec3 radius, out vec3 normal) {\n    normal = normalize(vec3(0.25)); // TODO\n    vec3 terms = (center - pos) / radius;\n    terms *= terms;\n    float dist = pow(dot(terms, terms), 0.25);\n    if (dist < 0.001)\n        return 1.0;\n    return 1.0 / (dist * dist);\n}\n\n// Prevent metaballs from ending up in places we don't want them to go.\nfloat envelope(vec3 pos) {\n    float factor = 1.0;\n    factor *= 1.0 - smoothstep(1.76, 2.25, pos.y);\n    factor *= 1.0 - smoothstep(2.75, 3.25, abs(pos.x));\n    return factor;\n}\n\nfloat metaballs(vec3 pos, out vec3 outNormal) {\n    float sum = 0.0;\n    float threshold = 0.0;\n\n    vec3 normalSum = vec3(0.0);\n\n    // Top metacube\n    vec3 normal;\n    float charge = metacube(pos, vec3(0.0, 6.0, 0.0), vec3(1.5, 0.2, 1.0), normal);\n    sum += charge;\n    normalSum += normal * charge;\n\n    // Slime blobs\n    for (int i = 0; i < DROPS; i++) {\n        vec3 ball = setupMetaball(i);\n        vec3 normal;\n        float charge = metaball(pos, vec3(ball.xy, 0.0), ball.z, normal);\n        sum += charge;\n        normalSum += normal * charge;\n    }\n    \n    sum *= envelope(pos);\n\n    if (length(normalSum) != 0.0)\n        outNormal = normalize(normalSum);\n    return sum;\n}\n\nvec3 shadeSlime(vec3 pos, vec3 normal, vec3 scale, vec3 offset) {\n    vec3 baseColor = mix(vec3(0.1, 0.8, 0.1), vec3(0.1, 1.0, 0.1), snoise((pos + offset) * scale));\n    return baseColor * (vec3(0.6) + vec3(0.4) * dot(normalize(vec3(0.25, 0.25, 0.25)), normal));\n}\n\nbool probeMetaballs(vec3 pos, vec3 lastPos, out vec3 outColor, inout float inoutShadow, inout float inoutLastCharge) {\n    if (pos.x < -3.5 || pos.x > 3.5 || pos.y > 2.25 || pos.y < -5.0 || pos.z < -1.0 || pos.z > 1.0) {\n        outColor = vec3(0.0);\n        return false;\n    }\n    vec3 normal;\n    float charge = metaballs(pos, normal);\n    if (charge < CHARGE_THRESHOLD) {\n        inoutShadow = max(inoutShadow, charge / CHARGE_THRESHOLD);\n        inoutLastCharge = charge;\n        outColor = vec3(0.0);\n        return false;\n    }\n    \n    pos = mix(lastPos, pos, linstep(inoutLastCharge, charge, 0.0, 1.0, CHARGE_THRESHOLD));\n    outColor = shadeSlime(pos, normal, vec3(1.0, 0.1, 1.0), vec3(0.0, METABALL_SPEED * iTime, 0.0));\n    return true;\n}\n\n// Fluid\n\nfloat basicWave(vec2 pos, int level, float maxWavelength, vec2 offset, float seed, float angle, float speed) {\n    if (angle < 0.0)\n        angle = mix(0.0, 2.0 * PI, rand(vec2(seed + 0.0, level)));\n    vec2 dir = vec2(cos(angle), sin(angle));\n    float wavelength = maxWavelength / float(level * level);\n    float freq = 2.0 * PI / wavelength;\n    if (speed < 0.0)\n        speed = rand(vec2(seed + 1.0, level)) * METABALL_SPEED;\n    float phase = speed * freq;\n    float amplitude = MAX_AMPLITUDE / float(level);\n    float extent = dot(dir, pos) * freq + iTime * phase;\n    return amplitude * sin(extent);\n}\n\nfloat lowerWaves(vec2 pos) {\n    float height = 0.0;\n    for (int i = 1; i <= LOWER_WAVE_COUNT; i++)\n        height += basicWave(pos, i, 40.0, vec2(0.0), 100.0, i == 1 ? PI : -1.0, -1.0);\n\n    for (int i = 0; i < DROPS; i++) {\n        vec3 ball = setupMetaball(i);\n        if (ball.y >= -2.0)\n            continue;\n        vec2 impact = vec2(ball.x, 0.0);\n        float dist = length(pos - impact);\n        float amp = min(1.0, 1.0 / (dist * 0.5)) * smoothstep(0.0, 1.0, linstep(-20.0, -2.0, 0.0, 1.0, ball.y));\n        height += sin(dist * 1.5 - iTime * 15.0) * 0.1 * amp;\n    }\n\n    // Make it fade away a bit toward the viewer so they aren't just looking at a weird slice.\n    float base = -4.0 - (1.0 - smoothstep(-15.0, 0.0, pos.y)) * 4.0;\n\n    return height + base;\n}\n\n// iq's finite differences method.\nvec3 lowerWavesNormal(const vec2 p) {\n    return normalize(vec3(lowerWaves(p - vec2(EPSILON, 0.0)) - lowerWaves(p + vec2(EPSILON, 0.0)),\n        2.0 * EPSILON,\n        lowerWaves(p - vec2(0.0, EPSILON)) - lowerWaves(p + vec2(0.0, EPSILON))));\n}\n\nfloat upperWaves(vec2 pos) {\n    float height = 0.0;\n    height += basicWave(pos, 1, 15.0, vec2(0.0), 300.0, PI * 0.5, 8.0);\n    height += basicWave(pos, 2, 15.0, vec2(0.0), 300.0, PI * 0.6, 3.2);\n    height += basicWave(pos, 3, 15.0, vec2(0.0), 300.0, PI * 0.4, 4.6);\n    float base = 4.5 - (1.0 - smoothstep(2.0, 16.0, pos.y)) * 2.25;\n    return height + base;\n}\n\nvec3 upperWavesNormal(const vec2 p) {\n    const float eps = 0.01;\n    return normalize(vec3(upperWaves(p - vec2(EPSILON, 0.0)) - upperWaves(p + vec2(EPSILON, 0.0)),\n        2.0 * EPSILON,\n        upperWaves(p - vec2(0.0, EPSILON)) - upperWaves(p + vec2(0.0, EPSILON))));\n}\n\nbool probeLowerFluid(vec3 pos, out vec3 outColor, inout float inoutGlow) {\n    // Quick check to early out.\n    if (pos.y >= -2.0) {\n        outColor = vec3(0.0);\n        return false;\n    }\n    float height = lowerWaves(pos.xz);\n    if (pos.y >= height) {\n        inoutGlow = max(inoutGlow, clamp(1.0 - (pos.y - height) / 1.0, 0.0, 1.0));\n        outColor = vec3(0.0);\n        return false;\n    }\n    vec3 normal = lowerWavesNormal(pos.xz);\n    outColor = shadeSlime(pos, normal, vec3(0.3), vec3(0.0));\n    return true;\n}\n\nfloat sdCage(vec2 pos);\n\nfloat upperFluidAO(vec3 pos, float cageDist) {\n    return linstep(0.0, 1.0, 1.0, 0.65, smoothstep(-0.5, 0.0, cageDist)) *\n        linstep(0.0, 1.0, 1.0, 0.0, smoothstep(3.0, 4.5, pos.z));\n}\n\nbool probeUpperFluid(vec3 pos, out vec3 outColor) {\n    float cageDist = sdCage(pos.xy);\n    if (cageDist >= 0.0 || pos.z < 1.0 || pos.y >= upperWaves(pos.xz)) {\n        outColor = vec3(0.0);\n        return false;\n    }\n    vec3 normal = upperWavesNormal(pos.xz);\n    outColor = upperFluidAO(pos, cageDist) * shadeSlime(pos, normal, vec3(0.3), vec3(0.0));\n    return true;\n}\n\n// Cage\n\n// From iq.\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Ibid.\nfloat sdCage(vec2 pos) {\n    return sdBox(pos - vec2(0.0, 5.0), vec2(3.0, 3.0)) - 0.25;\n}\n\n// Ibid.\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.yz), p.x)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nbool probeBars(vec3 pos, vec3 rd, out vec3 outColor) {\n    const float RADIUS = 0.3;\n    for (int i = -1; i <= 1; i++) {\n        vec3 center = vec3(float(i) * 1.75, 4.75, 1.0);\n        float dist = sdCappedCylinder(pos - center, 3.0, RADIUS);\n        if (dist > 0.0) {\n            continue;\n        }\n        // Don't try to compute the normal the usual way.\n        // We have no idea where in the bar we hit and due to the orthographic\n        // projection it'll probably be in the same place for every pixel.\n        // Instead calculate the normal *exactly* since we precisely know the x\n        // component, solving the equation of a circle for y given x.\n        float x = center.x - pos.x;\n        vec3 normal = normalize(vec3(x, 0.0, sqrt(RADIUS * RADIUS - x * x)));\n        vec2 uv = vec2(acos(pos.x), pos.y + float(i) * 3.19) * 0.4; // acos is not fun.\n        vec3 color = texture(iChannel0, uv).rgb * 0.8;\n        outColor = dot(normal, normalize(vec3(0.25))) * color;\n        return true;\n    }\n    return false;\n}\n\n\nvec3 background(vec2 pos, float shadow, float glow) {\n    if (sdCage(pos) <= 0.0) {\n        return vec3(0.0);\n    }\n    vec3 color = texture(iChannel0, pos * 0.1).rgb * 0.8;\n    color += GLOW * smoothstep(0.0, 1.0, glow);\n    float shadowAlpha = linstep(0.8, 1.0, 1.0, 0.5, shadow);\n    color = mix(SHADOW, color, shadowAlpha);\n    return color;\n}\n\n// Entry point\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = mix(vec2(-5.0), vec2(5.0), gl_FragCoord.xy / iResolution.xy);\n    p.x *= iResolution.x / iResolution.y;\n\n    // Orthographic projection.\n    vec3 ro = vec3(p, -6.0 + mix(-0.5, 0.5, rand(600.0)));\n    vec3 rd = vec3(0.0, 0.0, 1.0);\n\n    // Raymarch.\n    vec3 lastPos = ro;\n    float t = 2.0;\n    vec3 color = vec3(0.0);\n    float shadow = 0.0, glow = 0.0, lastCharge = 0.0;\n    for (int i = 0; i < 50; i++) {\n        vec3 pos = ro + rd * float(t);\n        if (probeLowerFluid(pos, color, glow))\n            break;\n        if (probeMetaballs(pos, lastPos, color, shadow, lastCharge))\n            break;\n        if (probeBars(pos, rd, color))\n            break;\n        if (probeUpperFluid(pos, color))\n            break;\n        t += STEP_SIZE;\n        lastPos = pos;\n        if (pos.z > 4.0) {\n            // Why do we have to do this here? I suspect a compiler bug!\n            color = background(p, shadow, glow);\n            break;\n        }\n    }\n\n    // Output to screen.\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}