{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Public domain\n\nconst int   MAX_ITER = 50;\nconst float MAX_DIST = 10.0;\n\t\nstruct Distance\n{\n\tfloat field;\n\tint materialId;\n\tvec4 materialParam;\n};\n\t\nstruct Hit\n{\n\tvec3 pos;\n\tDistance dist;\n};\n\t\nfloat distbox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nDistance distfunc(vec3 p)\n{\n\tDistance d;\n\td.materialId = 1;\n\t\n\tp += 1.0;\n\tfloat h = 0.0;\n\tfloat c = 1.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tp = abs(p - s);\n\t\ts *= 0.4;\n\t\tfloat di = distbox(p, vec3(s));\n\t\tif (di < c) {\n\t\t\tc = di;\n\t\t\th = float(i) / 6.0;\n\t\t}\n\t\t\n\t}\n\t\n\td.materialParam = vec4(h, p);\n\td.field = c;\n\treturn d;\n}\n\nHit intersect(in vec3 rayOrigin, in vec3 rayDir)\n{\n\tfloat total_dist = 0.0;\n\tvec3 p = rayOrigin;\n\tDistance d;\n\tbool hit = false;\n\t\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\n\t\td = distfunc(p);\n\t\tif (d.field < 0.001)\n\t\t{\n\t\t\thit = true;\n\t\t\t//break;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttotal_dist += d.field;\n\t\tif (total_dist > MAX_DIST) {\n\t\t\t//break;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tp += d.field * rayDir;\n\t}\n\t\n\tHit h;\n\tif (hit)\n\t{\n\t\th.pos = p;\n\t\th.dist.field = total_dist;\n\t\th.dist.materialId = d.materialId;\n\t\th.dist.materialParam = d.materialParam;\n\t}\n\telse\n\t{\n\t\th.dist.materialId = 0;\n\t}\n\treturn h;\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 getmaterial(in int materialId, in vec4 materialParam) {\n\tif (materialId == 1)\n\t{\n\t\treturn hsv(materialParam.x, 1.0, 1.0);\n\t}\n\treturn vec3(0.0);\n}\n\nvec3 getnormal(in vec3 p) {\n\tvec2 e = vec2(0.0, 0.001);\n\t\n\treturn normalize(vec3(\n\t\tdistfunc(p + e.yxx).field - distfunc(p - e.yxx).field,\n\t\tdistfunc(p + e.xyx).field - distfunc(p - e.xyx).field,\n\t\tdistfunc(p + e.xxy).field - distfunc(p - e.xxy).field));\n}\n\nvec3 getlighting(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n\tfloat b = max(0.0, dot(normal, lightDir));\n\treturn (b * color + pow(b, 32.0));// * softshadow(pos, lightDir, 0.01, 10.0, 16.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec3 upDirection = vec3(0, 1, 0);\n\tconst vec3 cameraTarget = vec3(0, 0, 0);\n\tfloat r = 1.25;\n\tfloat theta = iTime * 0.334543;\n\tfloat phi = -iTime * 0.2345436;\n\tvec3 cameraOrigin = vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) * r;\n\t//vec3 cameraOrigin = vec3(sin(iTime), sin(iTime*0.5), cos(iTime));\n\t\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n\tvec3 u = normalize(cross(upDirection, cameraOrigin));\n\tvec3 v = cross(cameraDir, u);\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tvec3 rayDir = normalize(u * screenPos.x + v * screenPos.y + cameraDir);\n\t\n\tHit h = intersect(cameraOrigin, rayDir);\n\tif (h.dist.materialId != 0)\n\t{\n\t\tvec3 materialColor = getmaterial(h.dist.materialId, h.dist.materialParam);\n\t\tvec3 normal = getnormal(h.pos);\n\t\tvec3 lightDir = -rayDir;\n\t\tvec3 color = getlighting(h.pos, normal, lightDir, materialColor);\n\t\n\t\tfragColor = vec4(color, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(0);\t\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsXGzS","date":"1373686122","viewed":714,"name":"T-cube fractal","username":"gleurop","description":"The T-square fractal in 3 dimensions!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}