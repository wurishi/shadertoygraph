{"ver":"0.1","info":{"id":"4Xj3Wc","date":"1709234234","viewed":107,"name":"Simple Torus cut","username":"gimulnautti","description":"Cut torus, spheres, texture mapping","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture"],"hasliked":0,"parentid":"4XB3Wy","parentname":"sin clip"},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 polarCoordinates(in vec3 p, in vec3 up, in vec3 right, in vec3 fwd)\n{\n    vec3 rfPlane = vec3(p.x, 0.0, p.z);\n    vec3 n = normalize(rfPlane);\n \n    float dotnright = dot(n, right);\n    float dotnfwd = dot(n, fwd);\n    \n    float angle = acos(dotnright);\n    if (dotnfwd < 0.0) angle = 6.28 - angle;\n    return vec2(angle / 6.28, p.y + 0.5);\n}\n\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdInvTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return -(length(q) - t.y);\n}\n\nvec2 sdTorusMapped(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fwd = vec3(0.0, 0.0, 1.0);\n    \n    return vec2(polarCoordinates(p, up, right, fwd).x, polarCoordinates(vec3(q.x, 0.0, q.y), up, right, fwd).x);\n}\n\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p) - s;\n}\n\nvec2 sdSphereMapped(in vec3 p, in float s)\n{\n    return polarCoordinates(p, vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nvec3 repeat(in vec3 pos, in vec3 s)\n{\n    return pos - s*round(pos / s);\n}\n\nfloat opUnion(in float d1, in float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSubtraction(in float d1, in float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat opIntersection(in float d1,in float d2)\n{\n    return max(d1,d2);\n}\n\nfloat opXor(in float d1, in float d2)\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nfloat map(in vec3 pos )\n{\n    //vec3 s = vec3(1.5, 1.3, 1.3);\n    vec3 s = vec3(6.0,5.0,6.0);\n    vec3 s2 = vec3(6.0,2.5,6.0);\n    float d1 = sdInvTorus(repeat(pos, s), vec2(2.5, 2.1));\n    \n    //d1 *= sin(pos.x) * sin(pos.y) * sin(pos.z);\n\n    float size1 = 6.0 + sin(iTime * 0.4) * 2.0;\n    float size2 = 2.5 + sin(iTime * 0.2) * 2.0;\n    float d2 = sdTorus(pos + vec3(sin(iTime * 0.5) * 4.0, 0.0, 0.0), vec2(size1, size2));\n    d1 = opSubtraction(d1, d2);\n    \n    \n    float dd1 = sdSphere(repeat(pos + vec3(sin(iTime) * 1.6, 0.0, cos(iTime) * 1.6), s), 0.7);\n    float dd2 = sdSphere(repeat(pos + vec3(-1.0, cos(iTime*0.5) * 1.0, 0.0), s), 0.4);\n    d1 = opUnion(d1, dd1);\n    d1 = opUnion(d1, dd2);\n    return d1;\n        \n    //return sdTorus(repeat(pos, s), vec2(0.4, 0.21));\n    //return sdSphere(repeat(pos, s), 0.5);\n}\n\nvec2 texMap(in vec3 pos)\n{\n    //vec3 s = vec3(1.5, 1.3, 1.3);   \n    vec3 s = vec3(6.0,5.0,6.0);\n    return sdTorusMapped(repeat(pos, s), vec2(2.5, 2.1));\n    //return sdTorusMapped(pos, vec2(2.5, 2.0));\n    //return sdTorusMapped(repeat(pos, s), vec2(0.4, 0.21));\n    //return sdSphereMapped(repeat(pos, s), 0.5);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n//Random number [0:1] without sine\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}    \n    \nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    float ao = 0.0;\n    const int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = n*l;\n\n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao/float(nbIte), 0.1, 1.);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.15*(iTime-10.0);\n\tvec3 ro = vec3( 4.*cos(an), 0.6, 2.4*sin(an) );\n    vec3 ta = vec3( 0.0, sin(iTime * 0.5) * 1.0, 0.0 );\n    \n    //ro = vec3(-1.0,0.0,-1.9);\n    \n    // camera matrix\n    vec3 up = vec3(0.0,0.6,0.5);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, up) );\n    vec3 vv = normalize( cross(uu, ww) );\n    \n    // fragment position  \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n\t// create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // uv coordinates\n    vec2 uv = vec2(0.0, 0.0);\n\n    // raymarch\n    const float tmax = 50.0;\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.0001) {\n            // calculate texture lookup on hit\n            uv = texMap(pos);\n            break;\n        }\n        else if ( t > tmax)\n        {\n            break;\n        }\n        t += h;\n    }     \n    \n    // shading\n    vec3 col = vec3(0.0);\n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        float dif = clamp( dot(nor,vec3(0.7,1.6,0.4)), 0.0, 1.0 );\n        dif *= dif;\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n        \n        col = ( vec3(0.2,0.3,0.5)*amb + vec3(0.9,0.8,0.6)*dif ); \n        col *= ambientOcclusion(pos, nor, 1.9, 2.0);\n        col *= texture(iChannel0, uv).rgb;\n    }\n\n    // gamma        \n    col = sqrt( col );\n\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}