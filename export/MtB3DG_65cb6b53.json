{"ver":"0.1","info":{"id":"MtB3DG","date":"1674855898","viewed":78,"name":"Ray marcher 2","username":"ostkaka","description":"Ray marcher","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define ITERATIONS 128\n#define EPSILON 0.0001\n#define MAXDISTANCE 250.0\n#define PI 3.1415926535897932384626\n\nfloat torus(in vec3 pos, in float r1, in float r2)\n{\n    return length(vec2(length(pos.xz)-r1,pos.y))-r2;\n}\n\nvec3 repetition(in vec3 p, in vec3 c )\n{\n   return mod(p-0.5*c,c)-0.5*c;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 torusPos = repetition(pos, vec3(5, 20, 5));\n    \n    float distance = pos.y+0.5;// + 0.5*sin(iTime);\n    \n    distance = min(distance, torus(torusPos, 1.0, 0.25));\n\n    \n    \n    for (int i = 0; i < 1; ++i)\n    {\n        float j = 1.0*pow(2.0, float(i));\n        distance += 0.1/j*texture(iChannel0, pos.xz*j/2.0).r;\n    }\n    \n    return distance;\n}\n\nvec3 calcNormal(vec3 pos, float epsilon)\n{\n\tvec3 epsilonVec = vec3( epsilon, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    map(pos+epsilonVec.xyy) - map(pos-epsilonVec.xyy),\n\t    map(pos+epsilonVec.yxy) - map(pos-epsilonVec.yxy),\n\t    map(pos+epsilonVec.yyx) - map(pos-epsilonVec.yyx) );\n\treturn normalize(normal);\n}\n\n// AO using cubic interpolation\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    vec4 distances = vec4(0.0);\n    vec4 distances2 = vec4(0.0);\n    //vec4 \n    \n    float factor = 8.0;\n    \n    float stepDis = 0.005;\n    \n    distances = vec4(0.0, 1.0/factor/factor, 1.0/factor, 1.0) * map(pos + nor*stepDis);\n    distances2 = vec4(0.0, stepDis/factor/factor, stepDis/factor, stepDis);\n        \n    stepDis *= factor;\n    \n    float ao = 1.0;\n    \n    for (int i = 0; i < 8; ++i) {\n        float distance = map(pos + nor*stepDis);\n            \n        //distances = vec4(distances.y, distances.z, distances.w, distance);\n        //distances2 = vec4(distances2.y, distances2.z, distances2.w, stepDis);\n        \n        //float integrate = (distances2.w-distances2.z)*(distances.z*+0.5*(distances.w-distances.z));\n        //float integrate2 = (distances2.w-distances2.z)*(distances2.z*+0.5*(distances2.w-distances2.z));\n        \n        ao -= 0.1*cos(PI*atan(distance,stepDis));//*(stepDis/(stepDis-stepDis/factor));//256.0*abs(10.5*integrate-integrate2)*pow(0.5, float(i));\n        \n        stepDis *= factor;\n    }\n    \n    return clamp(ao, 0.0, 1.0);\n}\n\nvec4 castRay(in vec3 pos, in vec3 direction)\n{\n    vec3 rayPos = pos+0.25*direction;\n    vec3 rayDirection = direction;\n    float distance = map(rayPos);\n    float rayDistance = distance;\n    \n    float epsilon = EPSILON;\n    float maxDistance = MAXDISTANCE;\n    \n    float iterations = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        iterations += 1.0;\n        \n        rayPos += distance*rayDirection;\n        rayDistance += distance;\n        distance = map(rayPos);\n        \n        if (distance < epsilon) break;\n        if (rayDistance  > maxDistance) break;\n        \n    }\n    \n    float iteration_glow = iterations/float(ITERATIONS);\n    \n    vec3 normal = calcNormal(rayPos, epsilon);\n    float ao = calcAO(rayPos, normal);\n    \n    //return vec4(normal, 1.0);\n    return vec4(vec3(ao) * (0.5 + 0.5 * iteration_glow) * (1.0 - rayDistance / maxDistance), 1.0);\n    \n    return vec4(vec3(iterations/float(ITERATIONS)), 1.0);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(-1.0) + 2.0*fragCoord.xy / iResolution.xy;\n    vec2 mouse = 8.0 * (iMouse.xy / iResolution.xy-0.5);\n    mouse.y = clamp(mouse.y, -0.49*PI, 0.49*PI);\n\n    if (iMouse.y == 0.0)\n        mouse.y = 0.0;\n    \n\tfloat time = 1.0 + 0.0625*iTime;\n    \n    // camera\t\n\tvec3 pos = vec3(0.0, 2.0, 0.0);\n\tvec3 target = pos + vec3( cos(mouse.x + time), tan(mouse.y), sin(mouse.x + time) );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( pos, target, 0.0 );\n    \n    // ray direction\n\tvec3 direction = ca * normalize( vec3(0.5*uv.xy,1.0) );\n    \n    \n\tfragColor = castRay(pos, direction);\n}","name":"Image","description":"","type":"image"}]}