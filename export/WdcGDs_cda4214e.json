{"ver":"0.1","info":{"id":"WdcGDs","date":"1577228990","viewed":158,"name":"texture repetition","username":"kaminate","description":"technique 3 from https://iquilezles.org/articles/texturerepetition/texturerepetition.htm","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool showBaseUvs           = false;\nbool showTerrain           = false;\nbool showTerrainModulation = false;\nbool showNoise             = false;\nbool showNoiseModulation   = false;\nbool showDomain            = true;\nbool showNoiseScroll       = true;\nbool showTiledResult       = true;\n\nvec3 finalColor = vec3( 0, 0, 0 );\n\nvoid ShowModulation( vec2 uvs )\n{\n    vec2 uvModded = mod( uvs, 1.0 );\n    float exponent = 120.0;\n    finalColor.x += pow( uvModded.x, exponent );\n    finalColor.y += pow( uvModded.y, exponent );\n    finalColor.xy += uvModded / 5.;\n}\n\n// turns a number into a random direction\nvec2 Hash( float i )\n{\n    return sin( vec2( 3.0, 7.0 ) * i );\n}\n\nfloat sum( vec3 v ) { return v.x + v.y + v.z; }\n\nvoid mainImage(\n    out vec4 fragColor,\n    \n    // { [ 0 - iResolution.x ),\n    //   [ 0 - iResolution.y ) }\n    in vec2 fragCoord )\n{\n    float vertRepetitionCount = 3.0f;\n    float scrollSpeed = 0.1;\n    vec2 scrollDir = vec2( 1, 1 );\n    vec2 uv = fragCoord\n            / iResolution.y\n            * vertRepetitionCount\n            - scrollDir * ( iTime * scrollSpeed );\n    \n    if( showTerrainModulation )\n        ShowModulation( uv );\n    \n    float noiseVertRepetitionCount = 2.1f;\n    noiseVertRepetitionCount /= iChannelResolution[1].y;\n    //vec2 noiseuv = ( fragCoord * noiseVertRepetitionCount ) / iResolution.y;\n    vec2 noiseuv = uv * 2.1f / iChannelResolution[1].y;\n    float noiseSample = texture( iChannel1, noiseuv ).x;\n    float noiseIndex = noiseSample * 8.0; // we have 8 texture domains [0-7]\n    float noiseIndexWhole = floor( noiseIndex );\n    float noiseIndexFract = fract( noiseIndex );\n\n    vec3 sampledTerrain = texture( iChannel0, uv ).xyz;\n    \n    if( showTerrain )\n        finalColor += sampledTerrain;\n    \n    if( showBaseUvs )\n        finalColor.xy += vec2( fragCoord.x / iResolution.x,\n                               fragCoord.y / iResolution.y );\n    \n    if( showNoise )\n        finalColor += vec3( noiseSample );\n    \n    if( showNoiseModulation )\n        ShowModulation( noiseuv );\n    \n    vec3 domainColor=vec3(0.,0.,0.);\n    if( showDomain )\n    {\n        vec3 domainColors[ 8 ] = vec3[](vec3( 0, 0, 0 ),\n                                        vec3( 0, 0, 1 ),\n                                        vec3( 0, 1, 0 ),\n                                        vec3( 0, 1, 1 ),\n                                        vec3( 1, 0, 0 ),\n                                        vec3( 1, 0, 1 ),\n                                        vec3( 1, 1, 0 ),\n                                        vec3( 1, 1, 1 ));\n        vec3 domainColor = domainColors[ int( noiseIndexWhole ) ];\n        \n        for(float border = 1.0; border <= 8.0; border += 1.0 )\n        {\n            if( noiseIndex < border )\n            {\n                finalColor += domainColor * 0.1;\n                break;\n            }\n        }\n\t\t\n        finalColor += pow(1.-noiseIndexFract, 10.0) * domainColor;\n    }\n    \n    \n    vec2 offa = Hash( noiseIndexWhole + 0.0 );\n    vec2 offb = Hash( noiseIndexWhole + 1.0 );\n    \n    // the variable 'v' controls how much we add the offset direction to our sample\n    float v = 69420.0;\n    if(showNoiseScroll)\n    \tv = iTime / 5.;\n    \n\tvec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n    vec3 cola = textureGrad( iChannel0, uv + v * offa, duvdx, duvdy ).xyz;\n    vec3 colb = textureGrad( iChannel0, uv + v * offb, duvdx, duvdy ).xyz;\n    \n    if( showTiledResult )\n    {\n        finalColor += mix(\n            cola,\n            colb,\n            // magic\n            smoothstep( 0.2, 0.8, noiseIndexFract - 0.1 * sum( cola - colb ) ) );\n    }\n    \n    fragColor = vec4( finalColor, 1.0 );\n    //fragColor = vec4( cola, 1.0 );\n    //fragColor = vec4( colb, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}