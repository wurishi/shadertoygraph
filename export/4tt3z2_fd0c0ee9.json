{"ver":"0.1","info":{"id":"4tt3z2","date":"1470341454","viewed":475,"name":"Bitwise Operators","username":"rkevingibson","description":"Visualizing a handful of bitwise operators. Each pixel is colored according to OP(x, y), where OP is one of bitwise and, or, xor, & nand. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","visualization","bitwise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tVisualizing bitwise operations.\n\tThis is my first shader here, just trying out some of the viz shown in this article:\n\thttps://medium.com/biffures/part-2-the-beauty-of-bitwise-and-or-cdf1d8d87891\n\tJust because I thought they looked nice. \n\tGonna try using them as a heightfield for a landscape next, to practice some ray tracing\n*/\n\n//Uncomment one of these to visualize.\n\n//#define OP bitwiseAND\n//#define OP bitwiseOR\n#define OP bitwiseNAND\n//#define OP bitwiseXOR\n\nfloat bitwiseAND(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x*a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nfloat bitwiseOR(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x,2.0) + mod(a.y,2.0) - mod(a.x*a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nfloat bitwiseNAND(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += 1.0 - mod(a.x*a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nfloat bitwiseXOR(in vec2 p)\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x+a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\nvec3 hsv_to_rgb(in vec3 hsv)\n{\n    return mix(vec3(1.0),clamp((abs(fract(hsv.x+vec3(3.0, 2.0, 1.0)/3.0)*6.0-3.0)-1.0), 0.0, 1.0),hsv.y)*hsv.z;\n}\n\nvec4 map_color(in float x)\n{\n\t//Map value to color gradient.\n    float t = x; \n    vec3 a =\tvec3(0.5*sin(0.5*iTime + 0.6) + 0.5,0.1,0.1);\n    vec3 b =\tvec3(0.5*sin(0.5*iTime) + 0.5,0.5,0.8);\n    \n    vec3 result = mix(a, b, t);\n    \n    float d = b.x - a.x;\n    float delta = d + ((abs(d) > 180.0) ? ((d < 0.0) ? 360.0 : -360.0) : 0.0);\n    \n    result.x = mod(a.x + (t)*delta + 360.0, 360.0);\n    \n    return vec4(hsv_to_rgb(result),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 point = 128.0*fragCoord/min(iResolution.x, iResolution.y) + 5.0*iTime;\n    float val = OP(point);\n    //float val = bitwiseNAND(point) + bitwiseAND(point);\n    fragColor = map_color(val);\n}","name":"Image","description":"","type":"image"}]}