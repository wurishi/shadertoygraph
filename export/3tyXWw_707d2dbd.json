{"ver":"0.1","info":{"id":"3tyXWw","date":"1582888548","viewed":540,"name":"Wythoff Uniform Tilings +Duals","username":"fizzer","description":"All of the Wythoff-constructible Euclidean uniform tilings (10 out of 11), constructed with the Wythoff method of reflecting a base triangle through its edges across the plane. Drag the mouse to see all the tilings. Hold LMB to see the dual tiling.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["tilings","tessellation","uniform","wythoff","semiregular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"   \nconst float pi = acos(-1.);\nfloat vertex_dot_radius = .06;\n\nvec2 triangleCircumcenter(vec2 A, vec2 B, vec2 C)\n{\n    float a = distance(C, B);\n    float b = distance(C, A);\n    float c = distance(A, B);\n    vec3 bary = vec3(a * a * (b * b + c * c - a * a),\n                     b * b * (c * c + a * a - b * b),\n                     c * c * (a * a + b * b - c * c));\n    bary /= bary.x + bary.y + bary.z;\n    return A * bary.x + B * bary.y + C * bary.z;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    uv *= 9.;\n\n    float w = length(fwidth(uv)) * 2.;\n\n    vec3 col = vec3(0);\n\n    // https://en.wikipedia.org/wiki/Wythoff_symbol\n    // wythoff_symbol.w indicates the position of the vertical bar in the symbol\n    ivec4 wythoff_symbol;\n\n    float md = 1. / 10. * iResolution.x;\n\n    // https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings\n    // Select tiling via mouse X position\n    if(iMouse.x < md * 1.)\n    {\n        wythoff_symbol = ivec4(3, 6, 2, 2); // 3.4.6.4\n    }\n    else if(iMouse.x < md * 2.)\n    {\n        wythoff_symbol = ivec4(2, 4, 4, 3); // 4.8.8 (Wikipedia suggests 2 | 4 4 but that is surely incorrect..)\n    }\n    else if(iMouse.x < md * 3.)\n    {\n        wythoff_symbol = ivec4(3, 3, 3, 3); // 6.6.6\n    }\n    else if(iMouse.x < md * 4.)\n    {\n        wythoff_symbol = ivec4(2, 6, 3, 1); // 3.6.3.6\n    }\n    else if(iMouse.x < md * 5.)\n    {\n        wythoff_symbol = ivec4(2, 3, 6, 2); // 3.12.12\n    }\n    else if(iMouse.x < md * 6.)\n    {\n        wythoff_symbol = ivec4(3, 3, 3, 1); // 3.3.3.3.3.3\n    }\n    else if(iMouse.x < md * 7.)\n    {\n        wythoff_symbol = ivec4(4, 2, 4, 1); // 4.4.4.4\n    }\n    else if(iMouse.x < md * 8.)\n    {\n        wythoff_symbol = ivec4(2, 6, 3, 3); // 4.6.12\n    }\n    else if(iMouse.x < md * 9.)\n    {\n        wythoff_symbol = ivec4(6, 3, 2, 0); // 3.3.3.3.6\n    }\n    else if(iMouse.x < md * 10.)\n    {\n        wythoff_symbol = ivec4(4, 4, 2, 0); // 3.3.4.3.4\n    }\n\n    vec3 angles = vec3(pi) / vec3(wythoff_symbol.xyz);\n    vec3 sins = sin(angles);\n\n    // Law of sines (c is defined to be 1.0)\n    float a = sins.x / sins.z;\n    float b = sins.y / sins.z;\n\n    // Triangle corners (ta is defined to be vec2(0))\n    vec2 tb = vec2(1, 0);\n    vec2 tc = vec2(cos(angles.x), sin(angles.x)) * b;\n\n    float sinzx = sin(angles.z + angles.x);\n\n    // Triangle edge planes\n    vec3 dirs[3] = vec3[3](vec3(-sin(angles.x), cos(angles.x), 0.), vec3(0., -1., 0.),\n                           vec3(sinzx, -cos(angles.z + angles.x), sinzx));\n\n    vec2 incenter = (tb * b + tc) / (a + b + 1.);\n    vec2 sidecenter = (tb * b) / (a + b);\n\n    int reflcount = 0;\n\n    // This is not the fastest way, but it certainly is the simplest.\n    for(int i = 0; i < 32; ++i)\n    {\n        int j = 0;\n        while(j < 3)\n        {\n            vec2 dir = dirs[j].xy;\n            float d = dot(uv, dir) - dirs[j].z;             \n            if(d > 0.)\n            {\n                // Reflect\n                uv -= dir * d * 2.;\n                ++reflcount;\n                break;\n            }\n            ++j;\n        }\n        if(j == 3)\n            break;\n    }\n\n    col = vec3(0);\n\n    // Fermat point in trilinear coordinates\n    vec3 fermat_tril = vec3(1) / cos(angles - pi/6.);\n    vec3 fermat_bary = fermat_tril * vec3(a, b, 1.);\n    vec2 fermat_point = (fermat_bary.y * tb + fermat_bary.z * tc) / (fermat_bary.x + fermat_bary.y + fermat_bary.z);\n\n    // Calculate the generator for snub tilings\n    vec2 refppa = fermat_point - dirs[0].xy * (dot(fermat_point, dirs[0].xy) - dirs[0].z) * 2.;\n    vec2 refppb = fermat_point - dirs[1].xy * (dot(fermat_point, dirs[1].xy) - dirs[1].z) * 2.;\n    vec2 refppc = fermat_point - dirs[2].xy * (dot(fermat_point, dirs[2].xy) - dirs[2].z) * 2.;\n    vec2 snubpoint = triangleCircumcenter(refppa, refppb, refppc);\n\n    int poly = 0;\n    float outline = 0.;\n\n    if(wythoff_symbol.w == 0)\n    {\n        // Snub tiling\n        if((reflcount & 1) == 0)\n        {\n            float sides[6];\n            float linedist = 1e4;\n            \n            for(int i = 0; i < 3; ++i)\n            {\n                vec2 pp2 = snubpoint;\n                vec2 dir = dirs[i].xy;\n                float d = dot(pp2, dir) - dirs[i].z;             \n                pp2 -= dir * d * 2.;\n                for(int j = 0; j < 2;++j)\n                {\n                    vec2 pp3 = pp2;\n                    vec2 dir2 = dirs[(1 + i + j) % 3].xy;\n                    float d2 = dot(pp3, dir2) - dirs[(1 + i + j) % 3].z;             \n                    pp3 -= dir2 * d2 * 2.;\n                    sides[i * 2 + j] = dot(uv - snubpoint, normalize((pp3 - snubpoint).yx * vec2(1, -1)));\n                    linedist = min(linedist, segment(uv, snubpoint, pp3));\n                }\n\n            }\n\n            if(sides[0] > 0. && sides[3] < 0.)\n            {\n                poly = 0;\n            }\n            else if(sides[1] > 0. && sides[2] < 0.)\n            {\n                poly = 2;\n            }\n            else if(sides[0] < 0. && sides[5] < 0. && sides[2] > 0.)\n            {\n                poly = 1;\n            }\n            else\n            {\n                poly = 2;\n            }\n\n            outline = mix(outline, 1., 1. - smoothstep(0., w, linedist));\n            outline = mix(outline, 1., 1. - smoothstep(0., w, length(uv - snubpoint) - vertex_dot_radius));\n        }\n        else\n        {\n            float sides[3];\n            float linedist = 1e4;\n            \n            for(int i = 0; i < 3; ++i)\n            {\n                vec2 pp2 = snubpoint;\n                vec2 dir = dirs[i].xy;\n                float d = dot(pp2, dir) - dirs[i].z;             \n                pp2 -= dir * d * 2.;\n\n                vec2 pp3 = snubpoint;\n                vec2 dir2 = dirs[(i + 1) % 3].xy;\n                float d2 = dot(pp3, dir2) - dirs[(i + 1) % 3].z;             \n                pp3 -= dir2 * d2 * 2.;\n\n                sides[i] = dot(uv - pp2, normalize((pp3 - pp2).yx * vec2(1, -1)));\n                linedist = min(linedist, abs(sides[i]));\n            }\n\n            if(sides[0] > 0.)\n            {\n                poly = 0;\n            }\n            else if(sides[0] < 0. && sides[1] < 0.)\n            {\n                poly = 2;\n            }\n            else\n            {\n                poly = 1;\n            }\n\n            outline = mix(outline, 1., 1. - smoothstep(0., w, linedist));\n        }\n    }\n    else\n    {\n        vec2 pp = wythoff_symbol.w == 1 ? vec2(0) : wythoff_symbol.w == 2 ? sidecenter : incenter;\n\n        float side[3];\n\n        // Point classification and distance to edges\n        for(int i = 0; i < 3; ++i)\n        {\n            side[i] = dot(uv - pp, dirs[i].yx * vec2(-1, 1));\n            if(dot(uv - pp, dirs[i].xy) > 0.)\n                outline = mix(outline, 1., 1. - smoothstep(0., w, abs(side[i])));\n        }\n\n        outline = mix(outline, 1., 1. - smoothstep(0., w, length(uv - pp) - vertex_dot_radius));\n        poly = (side[0] > 0. && side[1] < 0.) ? 0 : (side[1] > 0. && side[2] < 0.) ? 1 : 2;\n    }\n\n    vec3 polycol = (poly == 0) ? vec3(1, .25, .25) : (poly == 1) ? vec3(.25, 1, .25) : vec3(.25, .25, 1);\n\n    polycol *= mix(.85, 1., float(reflcount & 1));\n\n    col = mix(polycol, vec3(.05), outline);\n    \n    // Dual / Laves\n    // Interestingly, this is also the voronoi diagram of the vertices\n    if(iMouse.z > 0.5)\n    {\n        float dual_outline_dist = 1e4;\n        if(wythoff_symbol.w == 3)\n        {\n            dual_outline_dist = min(dual_outline_dist, abs(dot(uv, dirs[2].xy) - dirs[2].z));\n            dual_outline_dist = min(dual_outline_dist, abs(dot(uv, dirs[1].xy) - dirs[1].z));\n            dual_outline_dist = min(dual_outline_dist, abs(dot(uv, dirs[0].xy) - dirs[0].z));\n        }\n        else if(wythoff_symbol.w == 2)\n        {\n            dual_outline_dist = min(dual_outline_dist, abs(dot(uv, dirs[2].xy) - dirs[2].z));\n            dual_outline_dist = min(dual_outline_dist, abs(dot(uv, dirs[0].xy) - dirs[0].z));\n        }\n        else if(wythoff_symbol.w == 1)\n        {\n            dual_outline_dist = min(dual_outline_dist, abs(dot(uv, dirs[2].xy) - dirs[2].z));\n        }\n        else if(wythoff_symbol.w == 0)\n        {\n            if((reflcount & 1) == 1)\n            {\n                dual_outline_dist = min(dual_outline_dist, segment(uv, fermat_point, vec2(0)));\n                dual_outline_dist = min(dual_outline_dist, segment(uv, fermat_point, tb));\n                dual_outline_dist = min(dual_outline_dist, segment(uv, fermat_point, tc));\n            }\n            else\n            {\n                for(int i = 0; i < 3; ++i)\n                {\n                    vec2 uv2 = uv;\n                    vec2 dir = dirs[i].xy;\n                    float d = dot(uv2, dir) - dirs[i].z;             \n                    uv2 -= dir * d * 2.;\n                    dual_outline_dist = min(dual_outline_dist, segment(uv2, fermat_point, vec2(0)));\n                    dual_outline_dist = min(dual_outline_dist, segment(uv2, fermat_point, tb));\n                    dual_outline_dist = min(dual_outline_dist, segment(uv2, fermat_point, tc));\n                }\n            }\n        }\n        col = mix(col / 2., vec3(.9), 1. - smoothstep(0., w, dual_outline_dist));\n    }\n\t\n    \n    fragColor = vec4(pow(clamp(col, 0., 1.), vec3(1. / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}