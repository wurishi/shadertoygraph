{"ver":"0.1","info":{"id":"MsfBWs","date":"1498773538","viewed":150,"name":"Fake menger","username":"SudoNhim","description":"Attempt to make something that looks like a menger with only one loop and very low iterations.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxels","menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Some code swiped and mangled from fb39ca4 :)\n\nconst int MAX_RAY_STEPS = 10;\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int actualRaySteps = 4 + int(iTime) % 10;\n    \n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    screenPos.y += 0.01;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    rayDir = normalize(rayDir);\n\tvec3 rayPos = vec3(0.5*sin(iTime * 0.17), 0.5 * sin(iTime * 0.23), 0.5 * sin(iTime * 0.3));\n\trayDir.xz = rotate2d(rayDir.xz, 1.5+3.3*sin(iTime*0.03));\n    rayPos += vec3(1.5);\n    \t\n    // This is just the basic voxel marching setup used throughout shadertoy, developed by fb39ca4 and others\n\tvec3 mapPos = vec3(floor(rayPos));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\tvec3 rayStep = sign(rayDir);\n\tvec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\tvec3 mask;\n    \n    // Additionally, keep track of...\n    int spacefilling=0; // How many empty voxels were marched through\n    bool filled=false;  // Was the final voxel filled\n    \n    // This is the only loop, and it marches 4-10 steps depending on how deep the menger should be drawn\n    // The actual steps taken will be some mix of:\n    //    a] Step forwards into an empty voxel\n    // and\n    //    b] Move down the hierarchy of the menger\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        if (i > actualRaySteps) break;\n        mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        \n        // This checks the current map position to see if it intersects the menger\n        ivec3 relPos = ((ivec3(mapPos)+3333) % 3)-1;\n        bvec3 bb= bvec3(relPos);\n        bool isHit = (bb.x && bb.y) || (bb.y && bb.z) || (bb.x && bb.z);\n        \n        if (!isHit) { // No intersect - march forward one voxel\n            sideDist += mask * deltaDist;\n            mapPos += mask * rayStep;\n            \n            spacefilling++;\n            filled=true;\n            \n            ivec3 esc = ivec3(mask)*relPos;\n            if (esc.x + esc.y + esc.z != 0) {\n\n                // Set the new ray origin just slightly back of where the voxel would have been hit\n                rayPos = dot(mask, sideDist-sign(rayPos)*0.001)*rayDir + rayPos;\n\n                    // Scale ray origin up by 3x. This is equivalent to moving down-hierarchy\n                rayPos /= 3.;\n\n\n                // Reset the voxel marching\n                mapPos = vec3(floor(rayPos));\n                sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n            }\n            \n    \t} else {// Intersect - move down-hierarchy instead of marching forward\n\t\t\t\n            // Set the new ray origin just slightly back of where the voxel would have been hit\n            rayPos = dot(mask, sideDist-sign(rayPos)*0.001)*rayDir + rayPos;\n            \n            // Scale ray origin up by 3x. This is equivalent to moving down-hierarchy\n            rayPos *= 3.;\n            \n            // Reset the voxel marching\n            mapPos = vec3(floor(rayPos));\n            sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n            \n            filled = false;\n        } \n\t}\n\t\n    if (!filled) spacefilling++;\n    float f = float(spacefilling); \n\tfloat brightness = max(0.0, 1.0-float(f)/20.0);\n    vec3 color = vec3(sin(float(f)/3.0), 1.0, cos(float(f)/2.0));\n\n\tfragColor.rgb = color*brightness;\n}","name":"Image","description":"","type":"image"}]}