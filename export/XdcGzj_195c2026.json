{"ver":"0.1","info":{"id":"XdcGzj","date":"1451074888","viewed":281,"name":"Tamby's first Raymarch test","username":"TambakoJaguar","description":"This is my first raymarching test! I tried to find out most of the formulas, with some help from what I found online. But it's very slow, especially the shadows. I'd be happy to get some help to optimize it! :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test","reflection","texture","sphere","fog","floor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Basic code from https://www.youtube.com/watch?v=yxNnRSefK94\n/*\n   ToDo\n   * Use cubic mapping for reflection\n   * Blur texture\n   * Shadows\n   * Lamp attenuation\n   * Camera position\n   * Floor with reflection\n   * Fog\n   - Iridescence?\n   - Optimize speed\n*/\n\n#define specular\n#define shadows\n#define object_color\n#define floor_ref\n#define fog\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n    \nLamp lamps[3];\n\nvec3 campos;\nconst vec3 camdir = vec3(0., 0.4, -1.);\nconst float fov = 3.3;\n\nconst vec3 ambientColor = vec3(0.58, 0.62, 0.65);\nconst vec3 flcolor1 = vec3(0.25);\nconst vec3 flcolor2 = vec3(0.95);\nconst float ambientint = 0.15;\nconst vec3 objcolor = vec3(0.1, 0.55, 0.22);\nconst float specint = 0.25;\nconst float specshin = 32.;\n\nfloat normdelta = 0.0025;\n\nconst float fogdens = 0.07;\n\nfloat hfh;\n\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nconst float btdist = 0.0018;\nconst int btns = 4;\n\nfloat getBlurredTexture(vec2 uv)\n{\n    float v = 0.;\n    for (int j=0;j<btns ;j++)\n    {\n       float oy = float(j)*btdist/max(float(aasamples-1), 1.);\n       for (int i=0;i<btns ;i++)\n       {\n          float ox = float(i)*btdist/max(float(aasamples-1), 1.);\n          v+= dot(texture(iChannel1, uv + vec2(ox, oy)).rgb, vec3(1./3., 1./3., 1./3.));\n       }\n    }\n    return v/float(btns*btns);\n}\n\nfloat map_obj(vec3 pos)\n{\n    float angle = mod(iTime*.2, 2.*pi);\n    vec3 posr = vec3(pos.x*cos(angle) + pos.z*sin(angle), pos.y, pos.x*sin(angle) - pos.z*cos(angle));\n    float theta = atan(posr.x, posr.z);\n    hfh = smoothstep(0.15, 1.05, getBlurredTexture(vec2(theta, posr.y)/pi))*(1. - smoothstep(0.85, 1.38, abs(posr.y)));\n    //hfh = getBlurredTexture(vec2(theta, posr.y)/pi);\n    return length(pos) - 1.35 - 0.3*hfh;\n    //return pow(1.1-sqrt(pow(posr.x, 2.)+pow(posr.y, 2.)), 2.) + pow(posr.z, 2.) - 0.05 - 0.27*hfh;\n    //return length(pos) - 1.35;\n}\n\nfloat map_floor(vec3 pos)\n{\n    return pos.y + 1.5;   \n}\n\nvec2 trace(vec3 cam, vec3 ray, bool onlyobj, float maxdist) \n{\n    float t = 0.0;\n    int o = 0;\n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tvec3 pos = cam + ray*t; \n    \tfloat dist = onlyobj?map_obj(pos):min(map_obj(pos), map_floor(pos));\n        if (dist<0.005 || dist>maxdist)\n        {\n            if (dist==map_floor(pos))\n                o = 1;\n            break;\n        }\n        t+= dist*0.7;\n  \t}\n  \treturn vec2(t, o);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, float o)\n{\n    vec2 q = vec2(0, e);\n    if (o==0.) return normalize(vec3(map_obj(pos + q.yxx) - map_obj(pos - q.yxx),\n                          map_obj(pos + q.xyx) - map_obj(pos - q.xyx),\n                          map_obj(pos + q.xxy) - map_obj(pos - q.xxy)));\n    else return normalize(vec3(map_floor(pos + q.yxx) - map_floor(pos - q.yxx),\n                          map_floor(pos + q.xyx) - map_floor(pos - q.xyx),\n                          map_floor(pos + q.xxy) - map_floor(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n\t#ifdef object_color\n    vec3 ocol = texture(iChannel0, reflect(campos, norm)).rgb;\n    ocol = mix(objcolor, ocol, smoothstep(0.13, 0.19, hfh))*(0.45 + 0.55*smoothstep(0.02, 0.13, hfh));\n    return ocol;\n    #else\n    return vec3(0.6);\n    #endif\n}\n\nvec3 floor_color(vec3 norm, vec3 pos)\n{\n\tvec3 ocol = mix(flcolor1, flcolor2, mod(floor(pos.x)+floor(pos.z), 2.));\n    return ocol;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Shadows\n    #ifdef shadows\n    col*= smoothstep(0.03, 0.0, (dlp - trace(lamp.position, -pl, true, 27. + campos.z).x)/dlp); \n    //col = vec3(0.25*smoothstep(0.03, 0.0, (distance(lamp.position, pos) - trace(lamp.position, normalize(pos - lamp.position)))/distance(lamp.position, pos))); \n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(1., 4., -10.), vec3(1., 1., 1.), 4.5, .05);\n  lamps[1] = Lamp(vec3(8., 0.1, 4.), vec3(0.5, 0.8, 1.0), 4., 0.01);\n  lamps[2] = Lamp(vec3(-10., -1.4, -6.), vec3(1., 0.95, 0.6), 3.6, 0.05);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  //vec3 ray = normalize(vec3(uv, 0.) - camdir*fov);\n  vec3 ray = GetCameraRayDir(uv, camdir*vec3(1., -1., -1.), fov);\n    \n  vec2 t = trace(campos, ray, false, 5.);\n  float tx = t.x;\n  vec3 col;\n  if (tx<30.)\n  {\n      vec3 pos = campos + tx*ray;\n      vec3 norm = getNormal(pos, normdelta, t.y);\n      if (t.y==0.) // Sphere object\n      {\n          col = obj_color(norm, pos);\n          col = ambientColor*ambientint + lampsShading(norm, pos, col);\n      }\n      else // Floor\n      {\n          col = floor_color(norm, pos);\n          col = ambientColor*ambientint + lampsShading(norm, pos, col);\n          \n          // Fog\n          #ifdef fog\n          float fogd = clamp(exp(-pow(fogdens*tx, 2.)), 0., 1.);\n          //float fogd = clamp(exp(-fogdens*tx), 0., 1.);\n          #endif\n          \n          #ifdef floor_ref\n          vec3 col_ref;\n\n          if (map_obj(pos)<4.)\n          {\n                        ray = reflect(ray, norm);\n          \t  tx = trace(pos, ray, true, 7.).x;\n  \t\t      if (tx<4.5)\n          \t  {\n            \t  pos = pos + tx*ray;\n              \t  norm = getNormal(pos, normdelta, 0.);\n              \t  col_ref = obj_color(norm, pos);\n              \t  col_ref = lampsShading(norm, pos, col_ref);\n          \t  }\n          \t  else\n           \t     col_ref = ambientColor;\n           }\n           else\n              col_ref = ambientColor;\n\n          col = mix (col, col_ref, 0.3);\n          //col = col_ref; //vec3(tx/10., 0., 0.);\n          #endif\n          \n          // Mix fog\n          #ifdef fog\n          col = mix (ambientColor, col, fogd);\n          #endif\n      }\n      \n  }\n  else\n  {\n      // \"Sky\"\n      col = ambientColor;\n  }\n      \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    campos = vec3(0., 2.5, -9.7 + iTime*0.08);\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);       \n}","name":"Image","description":"","type":"image"}]}