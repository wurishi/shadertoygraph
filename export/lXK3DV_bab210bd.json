{"ver":"0.1","info":{"id":"lXK3DV","date":"1718286433","viewed":69,"name":"3D City Test","username":"aridoliss","description":"This is a work in progress city I am creating.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","workinprogress","meshtest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotmat3(float a, float b, float c) {\n    float ca = cos(a), sa = sin(a);\n    float cb = cos(b), sb = sin(b);\n    float cc = cos(c), sc = sin(c);\n\n    return mat3(\n        cb * cc, cc * sa * sb - ca * sc, ca * cc * sb + sa * sc,\n        cb * sc, ca * cc + sa * sb * sc, -cc * sa + ca * sb * sc,\n        -sb,     cb * sa,                ca * cb\n    );\n}\n\nvec3 palette(float t) {\n    return .5 + .5 * cos(6.28318 * (t + vec3(0.5,0.5,0.5)));\n}\n\nfloat sdCube(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdf(vec3 p) {\n    float b1 = sdCube(p - vec3(0.0, -1.0, 0.0), vec3(4.0, 0.5, 10.0)); //Base\n    float b2 = sdCube(p - vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5)); //Center Building\n    float b3 = sdCube(p - vec3(2.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5)); // Left Building\n    float b4 = sdCube(p - vec3(-2.0, 0.25, 0.0), vec3(0.5, 0.75, 0.5)); // Right Building\n    float s1 = sdCube(p - vec3(0.65,-.25,0.0), vec3(0.02,0.25,0.02)); // Sign Pole 1\n    float s2 = sdCube(p - vec3(1.4,-.25,0.0), vec3(0.02,0.25,0.02)); // Sign Pole 2\n    float s3 = sdCube(p - vec3(1.05,-0.025,0.0), vec3(.35,0.025,0.02)); // Sign Bar\n    float r1 = sdCube(p - vec3(1.05,-0.48,0.0), vec3(.01,0.005,5)); // Road Line\n    float sw1 = sdCube(p - vec3(0.0,-0.5,-4.35), vec3(0.45, 0.05, 5)); // Side Walk\n    return min(b1, \n    min(b2, \n    min(b3, \n    min(b4, \n    min(s1, \n    min(s2, \n    min(s3,\n    min(r1, sw1\n    ))))))));\n}\n\nvec3 normals(vec3 k) {\n    float vert = .01;\n    return normalize(vec3(\n        sdf(k+vec3(vert+1.,0,0))-sdf(k-vec3(vert+1.,0,0)),\n        sdf(k+vec3(0,vert+1.,0))-sdf(k-vec3(0,vert+1.,0)),\n        sdf(k+vec3(0,0,vert+1.))-sdf(k-vec3(0,0,vert+1.))\n    ));\n}\n\nfloat ambientOcclusion(vec3 k, vec3 j) {\n    float ao = 0.0;\n    float scale = 1.0;\n    for (int i = 1; i <= 5; i++) {\n        float dist = float(i) * 0.125;\n        ao += (dist - sdf(k+j*dist))*scale;\n        scale *= 0.2;\n    }\n    return clamp(1.0-ao,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float angle = 0.75;\n    float radius = 1.5;\n    vec3 ro = vec3(sin(angle) * radius, 0.0, cos(angle) * radius);\n    vec3 target = vec3(0.5, 0.2, -0.7);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 3.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward);\n\n    vec3 col = vec3(0.459,0.663,0.702);\n    float t = 0.0;\n\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        t += d;\n        if (d < 0.01) {\n            vec3 n = normals(p);\n            float ao = ambientOcclusion(p, n);\n            col = palette(t * .15 + float(i) * 1.);\n            col *= ao;\n            break;\n        } else if (t > 2.94) {\n            break;\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}