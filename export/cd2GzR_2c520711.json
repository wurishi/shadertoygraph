{"ver":"0.1","info":{"id":"cd2GzR","date":"1667130475","viewed":184,"name":"Viscosity LBM","username":"lyxnb2333","description":"Fluid simulation using the Lattice Boltzmann Method. 4 texels are used to store 9 distribution functions in one lattice. Click the mouse to interact with the fluid. Tau is viscosity, feel free to change it. \nTODO: boundaries conditions like bound-back","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["fluid","lbm","latticeboltzmannmethod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define distortion 0.25\n//fancy function to compute a color from the velocity\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 1.0/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 70.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 219.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //only one pixel out of 4 stores the moments\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    \n    // look here\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 offset = vec3(1.0 / iResolution.xy, 0.0);\n    vec4 c00 = texture(iChannel0, uv);\n    vec4 c01 = texture(iChannel0, uv + offset.zy);\n    vec4 c10 = texture(iChannel0, uv + offset.xz);\n    vec4 c11 = texture(iChannel0, uv + offset.xy);\n    vec4 tmp = 0.25 * (c00 + c01 + c10 + c11);\n    \n    vec3 m = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).xyz;\n    float rho = m.x;\n    float vx  = m.y;\n    float vy  = m.z;\n    float U = sqrt(vx*vx+vy*vy);\n    \n    // look here\n    vec3 normal = normalize(vec3(vx, vy, distortion));\n    vec4 temp = texture(iChannel1, uv + normal.xy);\n    fragColor = rho * temp + (1.0 - rho) * tmp;\n    fragColor = temp;\n    //fragColor = vec4(normal, 0.0);\n    \n    //fragColor = computeColor(U/0.2);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 0.51\n//map distribution functions to texture coordinates\n//4 texels are used to store 9 distribution functions in one lattice\n// | f6,f7,f8   rho,ux,uy |\n// | f0,f1,f2   f3,f4,f5  |\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int width = int(iResolution.x / 2.0); // width of lattices\n    int height = int(iResolution.y / 2.0); // height of lattices\n    \n    // direction vectors\n    vec2 e[9];\n    e[0] = vec2( 0.0, 0.0);\n    e[1] = vec2( 1.0, 0.0);\n    e[2] = vec2( 0.0, 1.0);\n    e[3] = vec2(-1.0, 0.0);\n    e[4] = vec2( 0.0,-1.0);\n    e[5] = vec2( 1.0, 1.0);\n    e[6] = vec2(-1.0, 1.0);\n    e[7] = vec2(-1.0,-1.0);\n    e[8] = vec2( 1.0,-1.0);\n\n    // direction weights\n    float w[9];\n    w[0] = 4.0/9.0;\n    w[1] = 1.0/9.0;\n    w[2] = 1.0/9.0;\n    w[3] = 1.0/9.0;\n    w[4] = 1.0/9.0;\n    w[5] = 1.0/36.0;\n    w[6] = 1.0/36.0;\n    w[7] = 1.0/36.0;\n    w[8] = 1.0/36.0;\n    \n    \n    // lattice index, 4 pixels in one lattice do the same computations later\n    int ix = int(floor(fragCoord.x / 2.0));\n    int iy = int(floor(fragCoord.y / 2.0));\n    if (ix >= width || iy >= height){\n        return;\n    }\n    \n    // | . . |\n    // | . . |\n    // relative coordinate in one lattice\n    int rx = int(fragCoord.x) - 2*ix;\n    int ry = int(fragCoord.y) - 2*iy;\n    \n    // what we need to calculate in each frame\n    float f[9]; // fluid distribution on this lattice\n    float rho;\n    vec2 u = vec2(0.0, 0.0);\n    f[0] = f0(ix, iy);\n    if(iFrame == 0 || f[0] == 0.0){\n        // initialize\n        rho = 1.0;\n        u.x = 0.08;\n        u.y = 0.06;\n        float uu_dot = dot(u,u);\n        for(int i = 0; i < 9; i++){\n            float eu_dot = dot(e[i], u);\n            f[i] = w[i] * rho * (1.0 + 3.0*eu_dot + 4.5*eu_dot*eu_dot - 1.5*uu_dot);\n        }\n    }else {\n        // streaming step\n        int xp = ix == width-1 ? 0 : ix + 1; // x positive\n        int xn = ix == 0 ? width-1 : ix - 1; // x negative\n        int yp = iy == height-1 ? 0 : iy + 1; // y positive\n        int yn = iy == 0 ? height-1 : iy - 1; // y negative\n        f[0] = f0(ix,iy);\n        f[1] = f1(xn,iy);\n        f[2] = f2(ix,yn);\n        f[3] = f3(xp,iy);\n        f[4] = f4(ix,yp);\n        f[5] = f5(xn,yn);\n        f[6] = f6(xp,yn);\n        f[7] = f7(xp,yp);\n        f[8] = f8(xn,yp);\n        \n        // collision step\n        rho = 0.0;\n        for(int i = 0; i < 9; i++)\n            rho += f[i];\n            \n        u = vec2(0.0, 0.0);\n        for(int i = 0; i < 9; i++)\n            u += f[i] * e[i];\n        u /= rho;\n        \n        vec2 center = iMouse.w > 0.01 ? iMouse.xy / 2.0 : vec2(iResolution.x/6.0, iResolution.y/4.0);\n        if( distance(center,vec2(ix,iy)) < 10.0 )\n        {\n            rho = 1.0;\n            u.x = 0.0;\n            u.y = 0.0;\n        }\n        \n        float uu_dot = dot(u,u);\n        for(int i = 0; i < 9; i++){\n            float eu_dot = dot(u,e[i]);\n            float feq = w[i] * rho * (1.0 + 3.0*eu_dot + 4.5*eu_dot*eu_dot - 1.5*uu_dot);\n            f[i] = f[i] + (feq - f[i]) / TAU;\n        }\n        \n    }\n    \n    if(rx==0&&ry==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f[0],f[1],f[2]);\n    else if(rx==1&&ry==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f[3],f[4],f[5]);\n    else if(rx==0&&ry==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f[6],f[7],f[8]);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,u.x,u.y);\n    \n    \n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}