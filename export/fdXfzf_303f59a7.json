{"ver":"0.1","info":{"id":"fdXfzf","date":"1645202950","viewed":155,"name":"Analytic 2d sphere shadows","username":"Langwedocjusz","description":"An experiment to draw beautiful penumbras without raycasting (so no noise), but for spheres only. Naive and not optimized at all.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["penumbra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n\nstruct Sphere{\n    vec2 pos;\n    float r;\n};\n\n//Find the length of intersection of two intervals\nfloat intersect(vec2 ix, vec2 iy){\n    if (ix.y < iy.x || iy.y < ix.x)\n        return 0.0;\n    else\n        return min(abs(ix.y-iy.x), abs(ix.x-iy.y)); \n}\n\n//Find the length of intersection of two intervals on a circle\nfloat circularIntersect(vec2 ix, vec2 iy){\n    vec2 x = vec2(min(ix.x, ix.y), max(ix.x, ix.y));\n    vec2 y = vec2(min(iy.x, iy.y), max(iy.x, iy.y));\n    \n    vec2 x1=x, x2=x, y1=y, y2=y;\n    float prefactor = 0.25;\n    \n    if (x.y-x.x>PI) {\n        x1 = vec2(0.0, x.x);\n        x2 = vec2(x.y, 2.0*PI);\n        prefactor *= 2.0;\n    }\n    \n    if (y.y-y.x>PI) {\n        y1 = vec2(0.0, y.x);\n        y2 = vec2(y.y, 2.0*PI);\n        prefactor *= 2.0;\n    }\n    \n    float sum = 0.0;\n    sum += intersect(x1, y1);\n    sum += intersect(x1, y2);\n    sum += intersect(x2, y1);\n    sum += intersect(x2, y2);\n    return prefactor*sum;\n}\n\nfloat CalcLight(vec2 pos, Sphere source, Sphere occluder) {\n    vec2 s_dif = source.pos - pos;\n    float s_d = length(s_dif);\n    \n    if (s_d<source.r) return 1.0;\n    \n    vec2 o_dif = occluder.pos - pos;\n    float o_d = length(o_dif);\n    \n    if (o_d<occluder.r) return 0.0;\n\n    float s_alpha = asin(source.r/s_d);\n    float len = 0.0;\n    \n    if (o_d < s_d){\n        float s_phi = atan(s_dif.y, s_dif.x) + PI;\n    \n        vec2 s_limits = vec2(s_phi - s_alpha, s_phi + s_alpha);\n        s_limits += vec2(PI);\n        s_limits = mod(s_limits, 2.0*PI);\n    \n        float o_alpha = asin(occluder.r/o_d);\n        float o_phi = atan(o_dif.y, o_dif.x) + PI;\n    \n        vec2 o_limits = vec2(o_phi - o_alpha, o_phi + o_alpha);\n        o_limits += vec2(PI);\n        o_limits = mod(o_limits, 2.0*PI);\n    \n        len = circularIntersect(s_limits, o_limits);\n    }\n\n    return max(0.0, (2.0*s_alpha-len)/(2.0*PI));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(1.0);\n    \n    float phi = iTime;\n    Sphere sphere1 = Sphere(0.6*vec2(cos(phi), sin(phi)), 0.15);\n    phi += 2.0*PI/3.0;\n    Sphere sphere2 = Sphere(0.6*vec2(cos(phi), sin(phi)), 0.15);\n    phi += 2.0*PI/3.0;\n    Sphere sphere3 = Sphere(0.6*vec2(cos(phi), sin(phi)), 0.15);\n    \n    Sphere light = Sphere(vec2(0.0), 0.25);\n    \n    col = min(col, CalcLight(uv, light, sphere1) * vec3(1.0));\n    col = min(col, CalcLight(uv, light, sphere2) * vec3(1.0));\n    col = min(col, CalcLight(uv, light, sphere3) * vec3(1.0));\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}