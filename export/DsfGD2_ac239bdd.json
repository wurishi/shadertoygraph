{"ver":"0.1","info":{"id":"DsfGD2","date":"1666790985","viewed":131,"name":"Snowy terrain","username":"Proger","description":"Regular terrain rendered with Perlin noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["terrain","rocks","mountains","snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nconst float PI = 3.1415926535;\nfloat Scale = 0.5;\nfloat Offset = 1.;\nfloat shadowI = 0.2;\nvec3 colorO = vec3(1);\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 800./freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\nmat2 mrot(float a){\n float c = cos(a);\n float s = sin(a);\n return mat2(c,-s,s,c);\n}\nfloat getDist(vec3 p){\n  p /= 4.;\n  float n = pNoise(p.xz*38.+iTime*50., 7) * 10.;\n  colorO = vec3(82, 64, 51)/255.;\n  if(n < 0.4) { colorO = vec3(0.5,0.5,0.7)/1.5; n = 0.4;}\n  return p.y - n;\n}\nvec3 getNormal(vec3 p){\n vec2 e = vec2(0.001,0);\n float d = getDist(p);\n vec3 n = vec3(\n  d - getDist(p-e.xyy),\n   d - getDist(p-e.yxy),\n   d - getDist(p-e.yyx)\n );\n return normalize(n);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd){\n float dO = 0.0;\n while(true){\n   vec3 p = ro + rd*dO;\n  float ds = getDist(p);\n  dO += ds;\n  if(dO > 300.) break;\n  if(ds < 0.01) return vec3(p);\n  }\n  return vec3(0);\n}\n\nfloat getLight(vec3 p, vec3 lp){\n vec3 l = normalize(lp-p);\n  l = normalize(lp);\n return dot(l, getNormal(p));\n}\n\nfloat shadow(vec3 light, vec3 p){\n float r = 1.;\n vec3 rm = RayMarch(p+getNormal(p)*0.01, normalize(light));\n if(length(rm) != 0.)r=shadowI;\n return r;\n}\nvec3 sky = vec3(0.4);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float m = min(iResolution.y,iResolution.x);\n  vec2 uv = ((fragCoord.xy-.5*iResolution.xy) / m);\n  vec3 color = vec3(1);\n  vec3 light = vec3(1, 1, 0);\n  vec3 ro = vec3(0, 0, -70);\n  vec3 rd = normalize(vec3(uv.xy, 1.));\n  float ay = iMouse.y / iResolution.y * PI * 3. - PI * 1.5;\n  float ax = iMouse.x / iResolution.x * PI * 3. - PI * 1.5;\n  if(iMouse.z <= 0.){ \n      ax = iTime/10.;\n      ay = -0.6;\n  }\n  rd.yz *= mrot(-ay);\n  rd.xz *= mrot(-ax);\n  ro.yz *= mrot(-ay);\n  ro.xz *= mrot(-ax);\n  vec3 d = RayMarch(ro,rd);\n  float df = max(getLight(d, light) * shadow(light,d),shadowI);\n  float sn = max(pow(dot(normalize(vec3(0,1,0)), getNormal(d)) , 2.) * 20., 1.);\n  vec3 snc = vec3(sn);\n  snc = max(mix(snc, colorO, 10./d.y), colorO);\n  float a = d.y / 10.;\n  color = vec3(df) * colorO * snc * 5.;\n if(d!=vec3(0))fragColor = vec4(color, 1.0);\n else fragColor = vec4(sky,1);\n}","name":"Image","description":"","type":"image"}]}