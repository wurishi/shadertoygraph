{"ver":"0.1","info":{"id":"slScRW","date":"1649540702","viewed":282,"name":"laser in a mirror box","username":"batersy","description":"Try to implement an easily scalable 2D laser simulation, including reflection and refraction and various shapes. \nClick mouse to change direction, have fun.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["2d","reflection","refraction","laser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * laser in a mirror box by batersy\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// inspired by these two works:\n// colorspace reference on https://www.shadertoy.com/view/llVSDz\n// rendering reference on https://www.shadertoy.com/view/Ndc3DN\n// and special thanks for davidar's improvement\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // cumulative average color in CIE XYZ linear color space\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    // convert to linear RGB color space \n    col = xyzToLinearRgb(col);\n    // gamma Correction to sRGB color space\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TYPE_EDGE 0\n#define TYPE_SHAPE 1\n\nfloat laserThickness = .0001;\nfloat shapeThickness = .005;\nint maxBounceCount = 20;\n\n// transmittance config\n#define ENABLE_ATTENUATION 1\nfloat sigmaAir = 0.1;\nfloat sigmaShape = 0.5;\nfloat transmittanceStop = .1;\n\n// set to 1 for a more physically right result\n// set to 0 make light softer, which sometimes looks better\n#define USE_BLACK_BODY 1\n\n// ------shape definition-----------\n// screen edge\nvec2 edge = vec2(16.,9.) / 9.;\n// circle define as format vec3(x, y, radius)\nvec3[] circles = vec3[](vec3(.3, .5, .2),\n                          vec3(1.4, .7, .1));\nstruct triangle {vec2 a, b, c;};\n// vertex should be given in anti-clockwise order\ntriangle[] triangles = triangle[](triangle(vec2(.9, .7),\n                                           vec2(.65, .25),\n                                           vec2(1.15, .25)));\nstruct quadrangle {vec2 a, b, c, d;};\n// vertex should be given in anti-clockwise order\nquadrangle[] quadrangles = quadrangle[](quadrangle(vec2(1.3, .5),\n                                                   vec2(1.3, .1),\n                                                   vec2(1.5, .1),\n                                                   vec2(1.5, .5)));\n\n\n// ------screen edge definition-----------\nfloat rayIntersectBox(vec2 ro, vec2 rd, vec2 size, out vec2 normal) {\n    float xDis, ydis;\n    if(rd.x > 0.) xDis = (size.x - ro.x) / rd.x;\n    else xDis = abs(ro.x / rd.x);\n    if(rd.y > 0.) ydis = (size.y - ro.y) / rd.y;\n    else ydis = abs(ro.y / rd.y);\n    \n    float t = min(xDis, ydis);\n    vec2 pos = ro + t * rd;\n    float buffer = .01;\n    if(pos.x <= buffer) normal = vec2(1.,0.);\n    if(pos.y <= buffer) normal = vec2(0.,1.);\n    if(pos.x >= size.x - buffer) normal = vec2(-1.,0.);\n    if(pos.y >= size.y - buffer) normal = vec2(0.,-1.);\n    return t;\n}\n\n// ------circle shape definition-----------\nfloat rayIntersectCircle(vec2 ro, vec2 rd, vec3 circle, out vec2 normal) {\n\tvec2 oc = ro - circle.xy;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - circle.z*circle.z;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n    float x1 = -b - sqrt( h ), x2 = -b + sqrt( h );\n    float t = (x1 > 0.)? x1 : x2;\n    vec2 pos = ro + t * rd;\n    normal = normalize(pos - circle.xy);\n\treturn t;\n}\nfloat sdfCircle(vec2 p, vec3 circle) {\n    return length(p - circle.xy) - circle.z;\n}\n\n// ------line segment definition-----------\nfloat rayIntersectLine(vec2 ro, vec2 rd, vec2 from, vec2 to, out vec2 normal) {\n    vec2 rofrom = from - ro;\n    vec2 tofrom = from - to;\n    // solve equation t * rd + k * tofrom = rofrom\n\tfloat det = determinant(mat2(rd.x,tofrom.x,\n                                 rd.y,tofrom.y));\n    if(abs(det) < 0.00001) return -1.0;\n    float k = determinant(mat2(rd.x,rofrom.x,\n                               rd.y,rofrom.y)) / det;\n    if(k < 0.0 || k > 1.0) return -1.0;\n    float t = determinant(mat2(rofrom.x,tofrom.x,\n                               rofrom.y,tofrom.y)) / det;\n    if(t < 0.0) return -1.0;\n    // rotate 90 degress clockwise to get normal\n    vec2 fromto = normalize(to - from);\n    normal = vec2(fromto.y, -fromto.x);\n    return t;\n}\nfloat sdfLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// ------triangle definition-----------\nfloat rayIntersectTriangle(vec2 ro, vec2 rd, triangle tri, out vec2 normal) {\n    float t = -1.0, tmp_t;\n    vec2 tmp_normal;\n\n    tmp_t = rayIntersectLine(ro, rd, tri.a, tri.b, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, tri.b, tri.c, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, tri.c, tri.a, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n\n    return t;\n}\nfloat sdfTriangle(vec2 p, triangle tri) {\n    float sdf1 = sdfLine(p, tri.a, tri.b);\n    float sdf2 = sdfLine(p, tri.b, tri.c);\n    float sdf3 = sdfLine(p, tri.c, tri.a);\n    return min(min(sdf1, sdf2), sdf3);\n}\n\n// ------quadrangle definition-----------\nfloat rayIntersectQuadangle(vec2 ro, vec2 rd, quadrangle quad, out vec2 normal) {\n    float t = -1.0, tmp_t;\n    vec2 tmp_normal;\n\n    tmp_t = rayIntersectLine(ro, rd, quad.a, quad.b, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, quad.b, quad.c, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, quad.c, quad.d, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, quad.d, quad.a, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    return t;\n}\nfloat sdfQuadrangle(vec2 p, quadrangle quad) {\n    float sdf1 = sdfLine(p, quad.a, quad.b);\n    float sdf2 = sdfLine(p, quad.b, quad.c);\n    float sdf3 = sdfLine(p, quad.c, quad.d);\n    float sdf4 = sdfLine(p, quad.d, quad.a);\n    return min(min(sdf1, sdf2), min(sdf3, sdf4));\n}\n\n// ------common things-----------\nfloat random(float seed) {\n    return fract(sin(seed * iTime)*43758.5453 + float(iFrame) * seed);\n}\nvec3 drawLine(vec2 ro, vec2 rd, float dis, vec2 p, in vec3 color, in vec2 trans) {\n    vec2 pnew = p - ro;\n    float d = dot(pnew, rd);\n    float lineDis = dot(pnew, pnew) - d * d;\n    if(d > 0. && d < dis && lineDis < laserThickness) {\n        float tran = 1.0;\n#if ENABLE_ATTENUATION\n        tran = mix(trans.x, trans.y, d / dis);\n#endif\n        return color * tran * smoothstep(1., 0., lineDis / laserThickness);\n    }\n    return vec3(0);\n}\nfloat getNearestShape(vec2 ro, vec2 rd, out int type, out vec2 normal) {\n    float t = rayIntersectBox(ro, rd, edge, normal);\n    type = TYPE_EDGE;\n\n    float tmp_t;\n    vec2 tmp_normal;\n    for(int i = 0; i < circles.length(); i++) {\n        tmp_t = rayIntersectCircle(ro, rd, circles[i], tmp_normal);\n        if(tmp_t > 0. && tmp_t < t) {\n            type = TYPE_SHAPE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    }\n\n    for(int i = 0; i < triangles.length(); i++) {\n        triangle tri = triangles[i];\n        tmp_t = rayIntersectTriangle(ro, rd, tri, tmp_normal);\n        if(tmp_t > 0. && tmp_t < t) {\n            type = TYPE_SHAPE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    }\n    \n    for(int i = 0; i < quadrangles.length(); i++) {\n        quadrangle quad = quadrangles[i];\n        tmp_t = rayIntersectQuadangle(ro, rd, quad, tmp_normal);\n        if(tmp_t > 0. && tmp_t < t) {\n            type = TYPE_SHAPE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    }\n    return t;\n}\nvoid paintShape(vec2 p, inout vec3 color) {\n    float sdf, dis;\n    for(int i = 0; i < circles.length(); i++) {\n        vec3 circle = circles[i];\n        sdf = abs(sdfCircle(p, circle));\n        if(sdf < shapeThickness)\n            color += vec3(.2) * smoothstep(shapeThickness, 0., sdf);\n    }\n    for(int i = 0; i < triangles.length(); i++) {\n        triangle tri = triangles[i];\n        sdf = abs(sdfTriangle(p, tri));\n        if(sdf < shapeThickness)\n            color += vec3(.2) * smoothstep(shapeThickness, 0., sdf);\n    }\n    for(int i = 0; i < quadrangles.length(); i++) {\n        quadrangle quad = quadrangles[i];\n        sdf = abs(sdfQuadrangle(p, quad));\n        if(sdf < shapeThickness)\n            color += vec3(.2) * smoothstep(shapeThickness, 0., sdf);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.y;\n    vec2 ro = vec2(0);\n    vec2 rd = normalize(iMouse.xy / iResolution.y);\n    if(iMouse.xy == vec2(0)) rd = normalize(vec2(1,1.4));\n    vec3 color = vec3(0);\n\n    // remember when the mouse moved\n    vec4 persistentState = texelFetch(iChannel0, ivec2(0), 0);\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = persistentState;\n        if (iFrame == 0) fragColor = vec4(0);\n        if (iMouse.z > 0.) fragColor.w = float(iFrame);\n        return;\n    }\n\n    uint state = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x) + uint(iFrame) * uint(iResolution.x) * uint(iResolution.y);\n    float w = mix(380.0, 750.0, pcg(state));\n    vec3 rayColor = xyzFit_1931(w);\n    rayColor *= 1e-13 * BlackBody(5000.0, w);\n\n    float t, f, sigma;\n    int count = 0, type;\n    vec2 pos, normal;\n    const float A = 1.2280;\n    const float B = 0.09;\n    float n1 = 1.0;\n    float n2 =  A + B/(w*w*1e-6);\n    float outside = 1.0;\n    float transmittance = 1.0, transmittanceNew;\n    vec2 rdTmp;\n    while(transmittance > transmittanceStop && count < maxBounceCount) {\n        // find nearest sdf\n        t = getNearestShape(ro, rd, type, normal);\n        sigma = (outside > 0.) ? sigmaAir : sigmaShape;\n        transmittanceNew = transmittance * exp(-sigma * t);\n        \n        // paint path and update transmittance\n        color += drawLine(ro, rd, t, p, rayColor, vec2(transmittance,transmittanceNew));\n        transmittance = transmittanceNew;\n\n        // update ray\n        pos = ro + t * rd;\n        ro = pos;\n        normal = outside * normal;\n        if(type == TYPE_EDGE) f = 1.;\n        else if(outside > 0.) f = fresnel(n1, n2, dot(-rd, normal));\n        else f = fresnel(n2, n1, dot(-rd, normal));\n        //if(random(dot(pos, rd)) < f) {\n        if(pcg(state) < f) {\n            rd = reflect(rd, normal);\n        } else {\n            rd = refract(rd, normal, pow(n2, -outside));\n            outside = -outside;\n        }\n        // prevent chaos when checking whether ro inside sdf\n        ro += rd * 0.00001;\n        count++;\n    }\n\n    paintShape(p, color);\n    if( iFrame!=0 ) {\n        vec3 lastColor = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n        //color = mix(color, lastColor, .99);\n        color = mix(lastColor, color, 1./(float(iFrame) - persistentState.w));\n    }\n    fragColor = vec4(color, 1.0);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Spectrum to xyz approx function from Sloan\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave ) {\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\n\nfloat yFit_1931( float wave ) {\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\n\nfloat zFit_1931( float wave ) {\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) )\n\nvec3 xyzToLinearRgb(vec3 XYZ) {\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );     \n}\n\nfloat remap(const float originalValue, const float originalMin, const float originalMax, const float newMin, const float newMax) {\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat fresnelSchlick(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float R0 = (n1 - n2)/(n1 + n2); R0 *= R0;\n    float cosin = (n1 < n2) ? cosi : cost;\n    return R0 + (1.0 - R0) * pow(1.0 - cosin, 5.0);\n}\nfloat fresnel(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float n1cosi = n1 * cosi;\n    float n1cost = n1 * cost;\n    float n2cosi = n2 * cosi;\n    float n2cost = n2 * cost;\n    float Rs = (n1cosi - n2cost) / (n1cosi + n2cost); Rs *= Rs;\n    float Rp = (n1cost - n2cosi) / (n1cost + n2cosi); Rp *= Rp;\n    return 0.5 * (Rs + Rp);\n}\n\n// https://www.pcg-random.org/\nfloat pcg(inout uint state) {\n\tstate = state * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float((word >> 22u) ^ word) / float(0xffffffffu);\n}\n\nfloat BlackBody( float t, float w_nm ) {\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}","name":"Common","description":"","type":"common"}]}