{"ver":"0.1","info":{"id":"ftfczf","date":"1648396983","viewed":101,"name":"Not so basic audio visualiser","username":"tipounlogick","description":"Feel free to tweak modifiers as you see fit.\nHowever be aware that at low values behavior can be unpredictable. \n\nport to Panon: https://github.com/DimonNeAdekvat/myPanonShaders","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AAlvl 1.;\n\n//uv modifiers\n#define parts 1.\n#define mirror false\n#define rotation 0.\n#define offset_x 0.\n#define offset_y 0.\n#define scale_x 1.\n#define scale_y 1.\n//visualiser modifiers\n#define flip false\n#define even false\n#define decor false\n#define body true\n#define rnded false\n#define angle_drift 0.\n//arc modifiers\n#define radius .6\n#define arc_begin_g 0.\n#define arc_endin_g 360.\n#define angle_2fill 10.\n#define angle_empty 2.\n//that's all for definitions\n\n\n//credit for this function goes to rbn42\nvec4 mean(float _from,float _to) {\n\n    if(_from>1.0)\n        return vec4(0);\n\n    _from=iChannelResolution[1].x*_from;\n    _to=iChannelResolution[1].x*_to;\n\n    vec4 v=texelFetch(iChannel1, ivec2(_from,0),0) * (1.0-fract(_from)) ;\n\n    for(float i=ceil(_from); i<floor(_to); i++)\n        v+=texelFetch(iChannel1, ivec2(i,0),0) ;\n\n    if(floor(_to)>floor(_from))\n        v+=texelFetch(iChannel1,ivec2(_to,0),0)* fract(_to);\n    else\n        v-=texelFetch(iChannel1,ivec2(_to,0),0)*(1.0- fract(_to));\n\n    return v/(_to-_from);\n\n}\n\nvec2 uv_old(vec2 p,float part){\n    if(mirror && mod(part,2.)>0.) p.x = 360./parts - p.x;\n    p.x += 360.*part/parts;\n    p = p.y*vec2(sin(radians(p.x-180.)),cos(radians(p.x-180.)));\n    p.y *= -1.;\n    return p;\n}\n\nvec4 fC( in vec2 fragCoord )\n{\n    vec4 fragColor;\n    //making uv aka uv hell begins here\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv= fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n\n    //scaling according to screen size\n    if(iResolution.x>iResolution.y)\n        uv.x *= aspect;\n    if(iResolution.x<iResolution.y)\n        uv.y /= aspect;\n\n    //rOtAtE\n    float c=cos(radians(rotation));\n    float s=sin(radians(rotation));\n    uv = mat2(c,-s,s,c)*uv;\n\n    //Scale + offset\n    uv = (uv+vec2(offset_x,offset_y))*vec2(1./scale_x,1./scale_y)*2.;\n\n    //going polar\n    vec2 uvc = uv;\n    uv = vec2(degrees(radians(180.)+atan(uv.x,-uv.y)),length(uv));\n\n    //dividing into parts\n    float part = 0.;\n    if(parts >1.){\n        part = floor(uv.x*parts/360.);\n        uv.x = mod(uv.x,360./parts);\n        if(mirror && mod(part,2.)>0.) uv.x = 360./parts - uv.x;\n    }\n\n    //uv hell ends here\n    fragColor = vec4(0.);\n\n    //basic stuff\n    float height = 1. - radius;\n    float unit = angle_2fill+angle_empty;\n\n    //arc correction\n    float arc_begin = arc_begin_g;\n    float arc_endin = arc_endin_g;\n    if(arc_begin < 0.) arc_begin = 0.;\n    if(arc_begin > 360./parts) arc_begin = 360./parts;\n\n    //straitning lines\n    float ang_begin = 0.;\n    float ang_endin = angle_2fill;\n    if(even) ang_endin *= radius/uv.y;\n    ang_begin += (unit-ang_endin)/2.;\n    ang_endin += ang_begin;\n\n    //point drift goes brrrr\n    float drift = mod(iTime * angle_drift,unit);\n\n    //Let's draw this\n    if (mod(uv.x - arc_begin - drift,unit) > ang_begin && uv.x > arc_begin &&\n        mod(uv.x - arc_begin - drift,unit) < ang_endin && uv.x < arc_endin){\n\n        float id = floor((uv.x - arc_begin - drift)/unit);\n\n        float arc = arc_endin - arc_begin + unit;\n\n        //gettin color\n        vec3 rgb = vec3(1.);\n\n        //gettin height\n        vec4 sound = mean(((id+1.)*unit+drift)/arc,((id+2.)*unit+drift)/arc);\n        height *= (sound.r +sound.g)*1.;\n\n        float xoc = unit*(id+.5)+arc_begin+drift;\n        float t;\n\n        //main body draw\n        if(flip){\n            if(uv.y >= 1.-height && uv.y <= 1. && body) fragColor=vec4(rgb,1.);\n        }else{\n            if(uv.y>=radius && uv.y<=radius+height && body) fragColor=vec4(rgb,1.);\n        }\n\n        //gettin ready for decorators\n        if(flip){\n            t = 1.;\n            if(uv.y < 1.-height) t = 1. -height;\n            if(uv.y > 1.) t = 1.;\n        }else{\n            t = radius;\n            if(uv.y < radius) t = radius;\n            if(uv.y > radius+height) t = radius+height;\n        }\n        float rad = t*sin(radians((ang_endin-ang_begin)/2.));\n\n        //not rounded decorators\n        if(flip){\n            if(uv.y >= 1.- rad && uv.y <= 1.+ rad && decor && !rnded) fragColor=vec4(rgb,1.);\n            if(uv.y >= 1.- height- rad && uv.y <= 1.- height && decor && !rnded) fragColor=vec4(rgb,1.);\n        }else{\n            if(uv.y>=radius -rad && uv.y<=radius +rad && decor && !rnded) fragColor=vec4(rgb,1.);\n            if(uv.y>=radius+ height && uv.y<=radius+ height +rad && decor && !rnded) fragColor=vec4(rgb,1.);\n        }\n\n\n        //rounded decorators\n        if(decor && rnded && uv.y > radius*(1.- sin(radians(angle_2fill)))){\n            if(length(uv_old(vec2(xoc,t),part)-uvc)<rad) fragColor = vec4(rgb,1.);\n        }\n    }\n    \n    return fragColor;\n}\n\n\n//AA solution found here https://www.shadertoy.com/view/wtjfRV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A=AAlvl;\n    float s = 1./A;\n    float  x, y;\n    if(A>1.){\n        for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n        fragColor /= A*A;\n    }else{\n    fragColor = fC(fragCoord);\n    }\n}\n","name":"Image","description":"","type":"image"}]}