{"ver":"0.1","info":{"id":"csf3Rr","date":"1665514205","viewed":55,"name":"DiscoLights2","username":"AliAbdulKareem","description":"Just Playing with ray tracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat Tmin = 0.0001;\nfloat Tmax = 1000.0;\n\n#define MAX_SPHERE_COUNT 16\n\nint GlobalSphereCount = 0;\n\nstruct camera \n{\n\n    float AspectRatio;\n    float VFOV;\n    float HFOV;\n    vec3 WorldUpVec;\n    vec3 Origin;\n    vec3 DirX;\n    vec3 DirY;\n    vec3 DirZ;\n};\n\nstruct film //camera Film, in the pinhole camera model\n{\n    vec3 Center;\n    \n    float W;\n    float H;\n    float HalfW;\n    float HalfH;\n    \n    float Dist;\n\n};\n\n\nstruct ray\n{\n    vec3 Origin;\n    vec3 Dir;\n};\n\n\nstruct sphere\n{\n    float R;\n    vec3 Center;\n    vec3 Color;\n \n};\n\n\nsphere Spheres[MAX_SPHERE_COUNT];\n\nstruct plane\n{\n    vec3 N;  //normal\n    float D; //distance from origin\n};\n\nstruct light_ambient \n{\n    vec3 Color;\n    float Intensity;\n};\n\nstruct light_point\n{\n    vec3 Color;\n    vec3 Pos;\n    float Intensity;\n};\n\nstruct light_directional\n{\n    vec3 Color;\n    vec3 Dir;\n    float Intensity;\n};\n\nstruct light_specular\n{\n    vec3 Color;\n    vec3 Pos;\n    float Intensity;\n    float Power;\n};\n\nstruct scene_light\n{\n    light_directional DirectionalLights[5];\n    light_point PointLights[5];\n    light_ambient AmbientLights[5];\n    \n    int AbientCount;\n    int DirectionalCount;\n    int PointCount;\n\n};\n\nstruct world\n{\n    sphere Spheres[10];\n    plane  Planes [10];\n    \n    scene_light Lights;\n    \n    int SphereCount;\n    int  PlaneCount;\n};\n\n\nvec3 NOZ(vec3 V)\n{\n    return (normalize(V));\n}\n\nfloat Inner(vec3 V, vec3 U)\n{\n    return dot(V,U);\n}\n\nvec3 Cross(vec3 V,vec3 U)\n{\n    return cross(V,U);\n}\n\nfloat MagnitudeSquared(vec3 V)\n{\n    return (V.x * V.x) + (V.y * V.y) + (V.z * V.z);\n}\n\n\n\nfloat RayIntersectSphere(ray Ray, sphere S)\n{\n   \n    float T = Tmax;\n\n    vec3 X = Ray.Origin - S.Center;\n\n    float B = Inner(X, Ray.Dir);\n    float C = Inner(X,X) - (S.R * S.R);\n\n\n    float Disc = B*B - C;\n\n    if(Disc < 0.0f) \n    {\n        return T;\n    }\n    T = -B - sqrt(Disc);\n    if (T < Tmin)\n    {\n        T = -B + sqrt(Disc);\n    }\n\n    return T;\n}\n\nfilm CreateFilm(vec3 Center, float W, float H)\n{\n    film Film;\n    Film.W = W;\n    Film.H = H;\n    Film.HalfH = Film.H * 0.5;\n    Film.HalfW = Film.W * 0.5;\n    Film.Center = Center;\n    \n    return Film;\n}\n\ncamera CreateCam(film Film, float AspectRatio, vec3 Origin ,vec3 UpVec)\n{\n    camera Cam;\n    Cam.AspectRatio = AspectRatio;\n    \n    \n    Cam.Origin = Origin;\n    Cam.WorldUpVec = UpVec;\n    Cam.DirZ = NOZ(Film.Center - Cam.Origin);\n    Cam.DirX = NOZ(Cross(Cam.DirZ, Cam.WorldUpVec));\n    Cam.DirY = Cross(Cam.DirX, Cam.DirZ); //both Z, X are orthogonal so the result is unit vector\n    \n    Cam.VFOV = 1.0; //just for simplicity\n    Cam.HFOV = 1.0;\n    \n    return Cam;\n    \n}\n\nvoid AddSphere(float Radius, vec3 Origin, vec3 Color)\n{\n    sphere tempS = sphere(Radius, Origin, Color);\n    Spheres[GlobalSphereCount++] = tempS; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy = (uv.xy * 2.0) - 1.0;\n    \n    \n    //--------------- Film and Camera Setup -------------//\n    float AspectRatio = iResolution.x / iResolution.y;\n    \n                                \n    // -------------------------   Film Center    Width Hight ---------------------//\n    film Film = CreateFilm(vec3 (0.0, 0.0, -1.0), 2.0, 2.0);\n\n    \n    //-------------------------------------------   Origin          World Up Vector ---------//\n    camera Cam = CreateCam(Film, AspectRatio, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    Film.Dist = distance(Cam.Origin, Film.Center);\n    Film.HalfW *= Cam.AspectRatio;    \n    \n    //-------------- World Object Setup ----------------//\n    \n\n    sphere S1 = sphere ( 1.0 ,    vec3( 0.0, -1.0, -3.0), vec3(1.0, 0.0, 0.0) );\n    sphere S2 = sphere ( 0.8  ,   vec3(-2.0,  0.0, -4.0),  vec3(0.0, 1.0, 0.0) );\n    sphere S3 = sphere ( 0.8  ,   vec3( 2.0,  0.0, -4.0),  vec3(0.0, 0.0, 1.0) );\n    sphere S4 = sphere ( 5000.0 , vec3( 0.0, -5001.0, 0.0), vec3(1.0, 1.0, 0.0) );\n    sphere S5 = sphere ( 1.5 , vec3( 0.0, 0.0, -5.0), vec3(0.3, 0.7, 0.0) );\n\n\n    \n\n    \n    AddSphere(1.0, vec3( 0.0, -1.0, -3.0), vec3(1.0,0.0,0.0));\n    AddSphere(0.8, vec3(-2.0,  0.0, -4.0), vec3(0.0,1.0,0.0));\n    AddSphere(0.8, vec3( 2.0,  0.0, -4.0), vec3(0.0,0.0,1.0));\n    \n    AddSphere(5000.0, vec3( 0.0, -5001.0, -.0), vec3(1.0,1.0,0.0));\n    \n    \n    int SphereCount = GlobalSphereCount;\n    //---------- Light Setup --------------//\n    \n    scene_light Lights;\n    light_ambient ALight = light_ambient(vec3(1.0, 1.0, 1.0), 0.1); \n    light_point   PLight = light_point (vec3(1.0, 1.0, 1.0), vec3(-0.5, 2.0, 0.0), 0.6); \n    light_directional DLight = light_directional(vec3(-0.5, 0.0, 1.0), vec3( 0.5, 0.5, 0.5), 0.6);   \n    \n    light_specular SLight = light_specular( vec3(1.0), vec3(2.5, 1.0, -1.5), 1.0, 10.0);\n    \n    //-------- Shooting Rays -------------//\n    \n    Cam.HFOV = 0.5;\n    Cam.VFOV = 0.5;\n    ray Ray;\n    Ray.Origin = Cam.Origin;\n    Ray.Dir = (Cam.DirZ * Film.Dist) + (Film.HalfW * uv.x * Cam.DirX *  Cam.HFOV) + (Film.HalfH * Cam.DirY * uv.y * Cam.VFOV);\n    Ray.Dir = NOZ(Ray.Dir);\n    \n    \n    float TClosest = Tmax;\n    int ClosestIndex = 0;\n    for(int SphereIndex = 0; SphereIndex < SphereCount; ++SphereIndex)\n    {\n        sphere CurrentSphere = Spheres[SphereIndex];\n        float T = RayIntersectSphere(Ray,CurrentSphere);\n        if(T > Tmin && T < TClosest) \n        {\n            TClosest = T;\n            ClosestIndex = SphereIndex;\n        }\n    }\n    \n    \n    \n    \n    //----------- Moving the lights ---------//\n    \n    \n    float CircleRadius = 5.0;\n    vec3 LightPos;\n    LightPos.x = sin(iTime) * CircleRadius;\n    LightPos.y = 0.0;\n    LightPos.z = cos(iTime) * CircleRadius;\n   \n       \n\n    PLight.Pos = LightPos;\n    DLight.Dir.y = sin(2.5*iTime);\n    SLight.Pos = Cross(PLight.Pos,DLight.Dir) * Inner(PLight.Pos, DLight.Dir); \n    \n  //-------- Coloring the closest object --------// \n  float T = TClosest;\n  \n  vec3 col = vec3(1.0);\n  if(T < Tmax)\n    {\n       //---- Current Object -------//\n       \n       sphere S = Spheres[ClosestIndex];\n       \n        //Intersection Point\n        vec3 IP = T*Ray.Dir + Ray.Origin;\n        \n        \n        vec3 Norm = (IP - S.Center)/S.R;\n        \n        \n        //------ Directional Light Effect -----------//\n        \n        float DCosAngle = Inner(NOZ(DLight.Dir), Norm);\n        float PCosAngle = Inner(NOZ(PLight.Pos - IP), Norm);\n        \n        col = S.Color;\n        vec3 LightColors = vec3(0.0);\n          \n        \n       //------- Diffuse Point Light -------//\n        if(PCosAngle > 0.0)\n        {\n          LightColors += PLight.Color * PLight.Intensity * PCosAngle;\n        }\n        \n        \n        //-------- Diffuse Directional Light ------//\n        \n        if(DCosAngle>0.0)\n        {\n            LightColors += (DLight.Color * DLight.Intensity * DCosAngle);\n        }\n        \n        \n        //--------- Specular Light -------//\n        \n        vec3 V = NOZ(Cam.Origin - IP);\n        vec3 L = NOZ(SLight.Pos - IP);\n        vec3 R = 2.0 * Inner(Norm,L) * Norm - L;\n        \n        float SCosAngle = Inner(R,L);\n        \n        \n        if(SCosAngle > 0.0)\n        {\n            LightColors += SLight.Intensity * SLight.Color * pow(SCosAngle, SLight.Power);\n        }\n        \n        \n        col *= LightColors;\n\n    }\n    \n  else\n  \n    {\n        col = vec3(0.1);\n    }\n    \n    \n       col += ALight.Intensity*ALight.Color;\n    \n    \n    //------ Light Effects --------// \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}