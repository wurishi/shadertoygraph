{"ver":"0.1","info":{"id":"stByzh","date":"1649149984","viewed":120,"name":"longexposure","username":"joa","description":"long exposure testing\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["light","exposure","reuben"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// reuben wu style long exposure raymarched\n//\n//\n// 1. disable animation / alt+up\n// 2. set AA to 2\n// 3. set numLights to 300 :>\n//\n// i can't take credit for any as most is stuff from iq and many other fine people.\n//\n\n#define AA 0\n\nconst int numLights = 3;\n\nconst int MaxSteps = 80;\nconst float MaxDist = 32.0;\nconst vec2 Eps = vec2(0.001, 0);\n\nconst float kSand = 1.0;\nconst float kBox = 2.0;\nconst float kNone = -1.0;\n\nconst float exposure = 11.0 / float(numLights);\n\nfloat mapHeight(in vec3 pos) {\n    return terrainH(pos.xz);\n}\n\nvec3 dronePos(in int index, in float tt) {\n    float t = 2.0 * PI * float(index + 1) / float(numLights);\n    return vec3(4.0 * sin(t+tt), 4.5, 4.0 * cos(t+tt));\n}\n\nvec3 map(in vec3 pos, in float t, in float tt) {\n    float base = mapHeight(pos);\n    \n    float d = MaxDist;\n    float m = kNone;\n    \n    float dFloor = MaxDist;\n    {\n        dFloor = pos.y - base;\n        if (dFloor < d) {\n            d = dFloor;\n            m = kSand;\n        }\n    }\n    \n    float dBox = MaxDist;\n    {   \n        vec3 pp = pos - vec3(0.0, 1.9, 0.0);\n        pp.xz *= rot(0.5);\n        dBox = sdBox(pp, vec3(1.0, 1.0, 1.0));\n        \n        if (dBox < d) {\n            d = dBox;\n            m = kBox;\n        }\n    }\n    \n    dBox = MaxDist;\n    {   \n        vec3 pp = pos - vec3(1.5, 0.2, 0.0);\n        pp.xz *= rot(-0.5);\n        dBox = sdBox(pp, vec3(1.0, 1.0, 1.0));\n        \n        if (dBox < d) {\n            d = dBox;\n            m = kBox;\n        }\n    }\n    \n    dBox = MaxDist;\n    {   \n        vec3 pp = pos - vec3(0.2, 0.0, 1.0);\n        pp.xz *= rot(0.21);\n        dBox = sdBox(pp, vec3(1.0, 1.0, 1.0));\n        \n        if (dBox < d) {\n            d = dBox;\n            m = kBox;\n        }\n    }\n    \n    \n    return vec3(d, m, 1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time, in float realtime )\n{\n    float ao = 0.0;\n    float sca = 15.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = (0.01 + 0.01*float(i*i));\n        float dd = map( pos + hr*nor, time, realtime ).x;\n        ao += (hr-dd)*sca;\n        sca *= 0.85;\n    }\n    return 1.0 - clamp( ao*0.3, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float time, in float realtime )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time, false ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time, false ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time, false ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time, false ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time,realtime).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\nvec3 rayMarch(in vec3 ro, in vec3 rd, in float t, in float realtime) {\n    float d = 0.0;\n    vec3 p = ro + d * rd;\n    \n    vec3 dd;\n    \n    for (int i = 0; i < MaxSteps; i++) {\n        p = ro + d * rd;\n        dd = map(p, t, realtime);\n        \n        if (abs(dd.x) < d * 0.0001) {\n            break;\n        }\n        \n        d += dd.x;\n        \n        if (d > MaxDist) {\n            break;\n        }\n    }\n    \n    if (d > MaxDist) {\n        return vec3(-1.0);\n    }\n    \n\treturn vec3(d, dd.y, dd.z);\n}\n\nvec3 renderSky(in vec3 ro, in vec3 rd) {\n    vec3 col = (0.5 * sin(rd.x) * vec3(0.11, 0.14, 0.3)+0.2*cos(rd.x) * vec3(0.21, 0.14, 0.1)+0.8*vec3(0.14, 0.14, 0.3));\n    col += vec3(0.0, 0.1, 0.0);\n    \n    // stars from tribute to journey\n    // https://www.shadertoy.com/view/ldlcRf\n    \n    float stars  = 0.0;\n\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * 200.0);\n    starPos.xyz += iTime*0.01 + noise(starPos.xy) * 3.0;\n\n    float c = 1.75;\n    starPos      = mod( starPos, 2.0 * c) - c;\n    stars  \t\t = length(starPos);\n\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\n\tstars = starsA + starsB;\n\n    stars = step( 0.01, stars) * stars * 2.0;\n\n    col = col + stars;\n    col *= rd.y;\n    \n    \n    return col;\n}\n\nvec3 lightCol = 25.0 * vec3(0.7, 0.7, 0.9);\n\nvec3 render(in vec3 ro, in vec3 rd, in float t, in float realtime) {\n    vec3 col = vec3(0.0);\n    vec3 res = rayMarch(ro, rd, t, realtime);    \n    float d = res.x;\n    float matSel = res.y;\n    \n    if (matSel > kNone) {\n        vec3 pos = ro + d * rd;\n        vec3 nor = calcNormal(pos, t, realtime);\n        vec3 mat = vec3(0.0);\n        float ao = calcAO(pos, nor, t, realtime);\n        vec3 lin = 0.03*ao*vec3(0.25,0.20,0.20)*(0.5+0.5*nor.y);\n        \n        if (matSel <= kSand) {\n            mat = vec3(0.9, 0.87, 0.3);\n        } else if (matSel <= kBox) {\n            mat = vec3(0.7, 0.99, 0.95);\n        }\n        \n        col = mat;\n        \n        vec3 moonCol = vec3(0.24, 0.21, 0.28);\n        vec3 moonDir = normalize(vec3(0.8, 0.4, 0.2));    \n        float moonSha = step(rayMarch(pos + nor * 0.001, moonDir, t, realtime).x, 0.0);\n        float moonDiff = clamp(dot(nor, moonDir), 0.0, 1.0);\n        lin += moonCol * moonDiff * moonSha;\n        \n        vec3 skyCol = vec3(0.0, 0.005, 0.1);\n        float skyBias = 0.3;\n        float skyDiff = clamp(skyBias + (1.0 - skyBias) * dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        lin += skyCol * skyDiff;\n        \n        vec3 spe = vec3(0.0);\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float ke = 0.0;\n        float ks = 1.0;\n\n        for (int i = 0; i < numLights; i++) {\n            vec3 lightPos = dronePos(i, t);\n            vec3 lightCol2 = exposure * 0.05 * vec3(0.12, 0.01, 0.2);\n            vec3 lightDir = normalize(lightPos);\n            vec3 lightAngle = normalize(lightPos - rd);\n            float lightSha = step(rayMarch(pos + nor * 0.001, lightDir, t, realtime).x, 0.0);\n            float lightDiff = clamp(dot(nor, lightDir), 0.0, 1.0);\n            float lightSpe = pow(clamp(dot(nor, lightAngle), 0.0, 1.0), 16.0) * lightDiff * (0.04 + 0.96 * pow(clamp(1.0 + dot(lightAngle,rd), 0.0, 1.0), 5.0));\n            lin += ao * lightCol2 * lightDiff * lightSha;\n            lin += exposure * 0.04 * ao * lightSpe * vec3(0.54, 0.56, 0.999);\n\n            vec3 lig = lightPos - vec3(0.0,1.4,0.0) - pos; // fake it till you make it -> move lights closer to ground plane :)\n            vec4 lcol = vec4(lightCol.x, lightCol.y, lightCol.z, exposure * 100.0);\n            float llig = dot( lig, lig);\n            float im = inversesqrt( llig );\n            lig = lig * im;\n\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float at = 2.0*exp2( -2.3*llig )*lcol.w;\n            dif *= at;\n            float at2 = exp2( -0.35*llig );\n            \n            float sh = 0.0;\n            float dif2 = clamp( dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 );\n\n            lin += 2.50*dif*lcol.xyz;\n            lin += 0.10*dif2*vec3(0.35,0.20,0.10)*at2*ao*vec3(1.5,1.0,0.5);\n            lin += fre*fre*col*ao*ke*10.0*clamp(0.5+0.5*dot(nor,lig),0.0,1.0)*sh;\n\n            vec3 hal = normalize(lig-rd);\n            float pp = clamp( dot(nor,hal), 0.0, 1.0 );\n            pp = pow(pp,1.0+ke*3.0);\n            spe += ks*(5.0)*lcol.xyz*at*dif*(0.04+0.96*pow(1.0-clamp(dot(hal,-rd),0.0,1.0),5.0))*(pow(pp,16.0) + 0.5*pow(pp,4.0));\n        }\n        \n        col = col*lin + 2.0*spe + 4.0*ke*fre*col*col*ao;\n        col = mix(col, length(col) * vec3(0.7,0.7,0.95), 1.0 - exp(-0.0001 * d * d *d));\n        col *= exp(-0.0001 * d * d *d);\n    } else {\n        col = renderSky(ro, rd);\n        d = MaxDist;\n    }\n    \n\n    for (int i = 0; i < numLights; i++) {\n        vec3 lightPos = dronePos(i, t);\n        vec3 lv = lightPos - ro;\n        float ll = length(lv);\n        if(ll < d) {\n            vec3 lcol = lightCol;\n            float dle = clamp(dot(rd, lv/ll), 0.0, 1.0);\n            dle = 1.0 - smoothstep(0.0, 0.14 * (0.7 + 0.3 * 1.9), acos(dle)*ll);\n            col += (dle * dle * dle * 1.9 * exp(-0.01 * ll * ll));\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime*0.5;\n    \n    vec3 ro = vec3(0, 2.0, 8.0);\n    vec3 ta = vec3(0.0, 2.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n\tvec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n        vec3 rd = ca * normalize(vec3(p, 1.0));\n        vec3 col = render(ro, rd, t, t);\n        \n        // gamma & color grade\n        col = pow( clamp(col*1.1-0.02,0.0,1.0), vec3(0.4545) );\n        col = col*col*(3.0-2.0*col);            \n        col *= vec3(1.02,0.99,0.9 );\n        col.z = col.z+0.1;\n    \n\t\tcol *= 1.0 - 0.125*length(p); // vignette\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ZERO (min(iFrame,0))\n#define PI 3.14159265359\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\n// iq stuff\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// desert - wachel\n// https://www.shadertoy.com/view/ltcGDl\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat terrainH( in vec2 p)\n{\n\n    //small\n\tfloat valS = noise(p * 0.5) + 0.5;//0~1\n    valS = 1.0 - abs(valS - 0.5) * 2.0;\n    valS = pow(valS,2.0);\n\n    //middle\n    float valM = noise(p * 0.26) + 0.5;//0~1\n    valM = 1.0 - abs(valM - 0.5) * 2.0;\n    valM = pow(valM,2.0);\n    \n    //big\n    float valB = smoothstep(0.0,1.0,noise(p * 0.2) + 0.5);//0~1\n\n    float val = valS * 0.01 + valM * 0.19 + valB * 0.8;\n\n    return val * 1.3 - 0.3;\n}\n","name":"Common","description":"","type":"common"}]}