{"ver":"0.1","info":{"id":"tlBBR1","date":"1598344450","viewed":102,"name":"Miniprojekt RR","username":"Yohavier","description":"Miniprojekt Realtime Rendering","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["volumetriclight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Quelle = https://www.arnoldrenderer.com/research/egsr2012_volume.pdf\n\n//Miniprojekt Jonas Knohl 710050\n\n//importance sample\n//homogeneous media\n//can be integrated into ray tracing based renderers\n//Equi-angular Sampling\n\n#define PI\t\t\t\t3.1415926535\n//Extinction coefficient\n#define Extinction_Coefficient\t.1\n//Akzeptabel ab 8 Steps \n#define Max_Steps\t    100\n#define DIST_MAX\t\t10.0\n//Helligkeit\n#define Light_Intensity 12.0\n\n#define Sphere_Albedo\t.9\n\n//Kamera Position\nvoid Camera(vec2 fragCoord, vec2 u, out vec3 rayOrigin, out vec3 rayDir)\n{\n\tvec2 filmUv = (fragCoord.xy + u)/iResolution.xy;\n\t\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\t\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = normalize(vec3(tx, ty, tz) - rayOrigin);\n}\n\n//Sphere\nvoid intersectSphere(vec3 rayOrigin,vec3 rayDir,vec3 sphereCentre,float sphereRadius,inout float rayT,inout vec3 intersectionNormal)\n{\n\tvec3 toSphere = rayOrigin - sphereCentre;\n\tvec3 dir = rayDir;\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0*dot(toSphere, dir);\n\tfloat c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;\n\tfloat q = b*b - 4.0*a*c;\n\tif (q > 0.0) \n    {\n\t\tfloat denom = 0.5/a;\n\t\tfloat z1 = -b*denom;\n\t\tfloat z2 = abs(sqrt(q)*denom);\n\t\tfloat t1 = z1 - z2;\n\t\tfloat t2 = z1 + z2;\n\t\tbool intersected = false;\n        \n\t\tif (0.0 < t1 && t1 < rayT) \n        {\n\t\t\tintersected = true;\n\t\t\trayT = t1;\n\t\t} \n        else if (0.0 < t2 && t2 < rayT) \n        {\n\t\t\tintersected = true;\n\t\t\trayT = t2;\n\t\t}\n        \n\t\tif (intersected) \n        {\n\t\t\tintersectionNormal = normalize(toSphere + dir*rayT);\n\t\t}\n\t}\n}\n\n//Szene erstellen\nvoid intersectScene(vec3 rayOrigin,vec3 rayDir,inout float rayT,inout vec3 intersectionNormal)\n{\n\tintersectSphere(rayOrigin, rayDir, vec3(-1.,  0.5, 0.3), 0.25, rayT, intersectionNormal);\n\tintersectSphere(rayOrigin, rayDir, vec3(-0.5, 0.8*sin(iTime*7.0/4.0), 0.3), 0.25, rayT, intersectionNormal);\n\tintersectSphere(rayOrigin, rayDir, vec3( 0.25,  0.5, 0.3), 0.25, rayT, intersectionNormal);\n    intersectSphere(rayOrigin, rayDir, vec3( 1.,  0., 0.3), 0.25, rayT, intersectionNormal);\n}\n\nvoid sampleUniform(float u,float maxDistance,out float dist,out float pdf)\n{\n\tdist = u*maxDistance;\n\tpdf = 1.0/maxDistance;\n}\n\nvoid EquiAngularSampling(float u,float maxDistance,vec3 rayOrigin,vec3 rayDir,vec3 lightPos,out float dist,out float pdf)\n{\n    //Koord von n채hstem Punkt auf dem ray\n\tfloat delta = dot(lightPos - rayOrigin, rayDir);\n\t\n\t//Entfernung Punkt-Licht\n\tfloat D = length(rayOrigin + delta*rayDir - lightPos);\n\n\t//Enpunkt Winkel\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t//sample\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n\tdist = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Licht Informationen\n\tvec3 lightPos = vec3(0.5, -0.5, 0.0);\n\tvec3 lightIntensity = vec3(Light_Intensity);\n\tvec3 surfIntensity = vec3(Sphere_Albedo/PI);\n\tvec3 particleIntensity = vec3(1.0/(6.0*PI));\n\t\n    //Kamera Positionsdaten speichern\n\tvec3 rayOrigin, rayDir;\n\tCamera(fragCoord, vec2(0.5, 0.5), rayOrigin, rayDir);\n\t\n\tvec3 col = vec3(0.0);\n\tfloat dist = DIST_MAX;\n\n    //Normal intersected Punkt\n\tvec3 normal;\n\tintersectScene(rayOrigin, rayDir, dist, normal);\n\t\t\n    if (dist < DIST_MAX)\n    {\n        //y=mx+b finden; Finden der Oberfl채che\n        vec3 surfPos = rayOrigin + dist*rayDir;\n        vec3 lightVec = lightPos - surfPos;\n        vec3 lightDir = normalize(lightVec);\n        vec3 cameraDir = -rayDir;\n        float nDotL = dot(normal, lightDir);\n        float nDotC = dot(normal, cameraDir);\n\t\t\t\n        // BRDF bei gleicher Hemisphere\n        if (nDotL*nDotC > 0.0) {\n            float dirLenght = length(lightVec);\n            float t2 = dirLenght;\n            vec3 normal2;\n            vec3 rayDir = normalize(lightVec);\n            intersectScene(surfPos + 0.01*rayDir, rayDir, t2, normal2);\n\n            // Oberfl채che, wenn nicht verdeckt \n            if (t2 == dirLenght) \n            {\n                float trans = exp(-Extinction_Coefficient*(dirLenght + dist));\n                float geomTerm = abs(nDotL)/dot(lightVec, lightVec);\n                col = surfIntensity*lightIntensity*geomTerm*trans;\n            }\n        }\n    }\n\n\n\tfor (int stepIndex = 0; stepIndex < Max_Steps; ++stepIndex) \n    {\n\t\tfloat relativeStep = (float(stepIndex))/float(Max_Steps);\n\t\t\n\t\t// Von Kamera zu oberfl채che sampeln\n\t\tfloat x;\n\t\tfloat pdf;\n\n\t\tEquiAngularSampling(relativeStep, dist, rayOrigin, rayDir, lightPos, x, pdf);\n\t\t\n        // An Raysteps anpassen\n        //Probability density function\n\t\tpdf *= float(Max_Steps);\n\t\t\n\t\t// connect to light and check shadow ray\n\t\tvec3 particlePos = rayOrigin + x*rayDir;\n\t\tvec3 lightVec = lightPos - particlePos;\n\t\tfloat dirLenght = length(lightVec);\n\t\tfloat t2 = dirLenght;\n\t\tvec3 normal2;\n        \n        //Shadow volume\n\t\tintersectScene(particlePos, normalize(lightVec), t2, normal2);\n\t\t\n\t\t//Partikel homogene interaktion\n\t\tif (t2 == dirLenght) \n        {\n\t\t\tfloat trans = exp(-Extinction_Coefficient*(dirLenght + x));\n\t\t\tfloat geomTerm = 1.0/dot(lightVec, lightVec);\n\t\t\tcol += Extinction_Coefficient*particleIntensity*lightIntensity*geomTerm*trans/pdf;\n\t\t}\n\t}\n\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}