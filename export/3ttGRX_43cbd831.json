{"ver":"0.1","info":{"id":"3ttGRX","date":"1577064854","viewed":234,"name":"Wizard Morph (Outline/glow demo)","username":"onlinerocker","description":"Simple outline: see if you barely missed the object, draw the outline if so ;p\n\nLine 280\n\n->The effect is calculated the same way as softshadows, but being used to create a border \"glow\" effect.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheretracing","magic","easy","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define VIEW_DIST 70.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    float minDist;\n    float glowAmt;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n//iq\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\n//iq\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//slightly modified, but IQ\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.dist = 1000.0;\n    o.normEps = 0.00001;\n    o.color = vec3(0);\n    \n    float yOff = 0.05*sin(5.0*iTime);\n    vec3 offset = vec3(0, yOff, 0);\n    \n    //ground\n    /*vec3 boardPos = pos;\n    boardPos.z = mod(boardPos.z, 10.0);\n    boardPos.x = mod(boardPos.x, 12.0);\n\tfloat dBoard = sdRoundBox(boardPos - vec3(0,-3,0), vec3(12, 0.5, 10.0), 0.1);\n    if(dBoard < o.dist)\n    {\n        o.dist = dBoard;\n        o.difVal = 0.9;\n        \n        //checker board\n        vec3 col;\n        float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n\n        col = vec3(1.0);\n        col *= (round(step((modi)*sin(pos.x*1.0*PI), 0.0)));\n        \n        o.color = col;\n        o.specVal = 200.0;\n        o.specKs = 0.5;\n    }*/\n    \n    vec3 objPos = pos - vec3(0, 1.5, 0);\n    float ang = PI/4.0;\n    vec2 objPosXZ = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * objPos.xz;\n    objPos = vec3(objPosXZ.x, objPos.y, objPosXZ.y);\n    \n    float dCube = sdRoundBox(objPos, vec3(0.5), 0.1);\n    float dSphere = sdSphere(objPos, 1.0);\n    float dElip = sdEllipsoid(objPos, vec3(0.5, 1.0, 0.5));\n    //float dCube1 = sdRound\n    \n    float mixVal = (1.0+sin((PI*(iTime + 0.1)) / 3.0));\n        \n    float dMix = mix(dSphere, dCube, mixVal) * step(mixVal, 1.0001)\n        \t\t + mix(dCube, dElip, mixVal - 1.0) * step(mixVal, 2.0) * step(1.0, mixVal);\n    if(dMix < o.dist){\n        o.dist = dMix;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;\n    }\n        \n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    res.minDist = 100000.0;\n    res.glowAmt = 1.0;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        res.glowAmt = min(res.glowAmt, 0.5*o.dist/(0.02+abs(0.02*sin(iTime))*res.totalDist));\n        if(abs(o.dist) < 0.00001)\n        {\n            res.minDist = o.dist;\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        if(o.dist < res.minDist)\n            res.minDist = o.dist;\n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    res.glowAmt = max(res.glowAmt, 0.0);\n    res.glowAmt = smoothstep(0.0, 1.0, res.glowAmt);// res.glowAmt*res.glowAmt*(3.0-2.0*res.glowAmt);\n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0, 2.4,3.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = -0.2;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    vec2 camXZ = rotCam * camEye.xz;\n    //camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirZY = rotCamX * dir.yz;\n    dir = vec3(dir.x, dirZY.xy);\n    \n    Light light;\n    light.intensity = 1.00;\n    light.pos = vec3(0, 10, 10);\n    light.color = vec3(1);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n    //add bounce light\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    /*float timeMod = 1.0 - sqrt(pow(uv.x, 2.0) + pow(uv.y, 2.0));\n    float time = iTime * timeMod;\n    vec2 newUv = mat2(cos(time), sin(time), -sin(time), cos(time)) * uv;\n    //newUv.y -= timeMod;\n    float y = newUv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);*/\n    vec2 newUv = uv;\n\t//newUv *= 100.0;\n    vec3 uv3D = vec3(newUv, iTime/3.0);\n    uv3D.z = mod(uv3D.z, 1.0);\n    uv3D.xy = -0.25 + mod(uv3D.xy, 0.5);\n    uv3D.xy = uv3D.xy/uv3D.z;\n    \n    \n    float y = uv.y + 2.3;\n    y = y / 1.62;\n    vec3 col = (vec3(0.3, 0.0, 0.75)*(y) + vec3(0.8)*(1.7 - y));\n\tcol += step(sqrt(pow(uv3D.x, 2.0) + pow(uv3D.y, 2.0)), 0.5) \n        * step(0.45, sqrt(pow(uv3D.x, 2.0) + pow(uv3D.y, 2.0))) * vec3(1,0,0);\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        col += calcSpecLight(res.obj, light,pos, camEye);\n        col = applyFog(col, sqrt(pow(pos.x,2.0) + pow(pos.y,2.0) + pow(pos.z,2.0)), normalize(pos), normalize(light.pos - pos)); \t\n    }else{\n     \tif(res.minDist < 0.3) //check if we barely missed the surface, if so, draw an outline :)\n            col = mix(vec3(0.2, 0.5, 0.75), col, res.glowAmt);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}