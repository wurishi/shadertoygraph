{"ver":"0.1","info":{"id":"4tsBzN","date":"1511198563","viewed":824,"name":"testing warps - fragSniffer","username":"FabriceNeyret2","description":"The frame rate doubles if bufA::offset falls in a different warp than (0,0).\napplication: Divergence is a problem only if in the same warp.\n\nAllows to test warp size and placing. nVidia: warp = 4x8, aligned with window.\nAuto adjust to you GPU power","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["fps","gpu","perfmeter","compilation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// more GPU reverse engineering (aka fragSniffing) here: https://hal.inria.fr/hal-01643579\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tO = texelFetch(iChannel0, ivec2(U), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Warp tester. Warps are 4x8 pixels (on nvidia), aligned with window coordinates\n\n//#define offset vec2(3,7) // this one falls in same warp than (0,0)\n  #define offset vec2(9,7) // this one falls in another warp than (0,0)\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{                                       // N will adjust depending on your GPU power\n    int N = iFrame==0 ? 300000 : int( texelFetch(iChannel0, ivec2(0),0).a );\n                                 \n    U -= .5;\n    if ( U==vec2(0) ) \n        for(int i = 0; i< N; i++) \n            O.b += sin(iTime);\n        \n    else if ( U==offset && iFrame>30)   // diverging costly branch...\n        for(int i = 0; i< N; i++)       // ...only if offset is in the same warp than (0,0)\n            O.b += cos(iTime);\n    \n    else {                              // draw performance curve\n        O = texelFetch(iChannel0, ivec2(U-vec2(1,0)), 0);\n        O += float(U.x==0. && U.y < iResolution.y/(iTimeDelta*65.) ); // top = 65 fps\n        if (mod(U.y,10.*iResolution.y/65.) < 1.) O = vec4(1,0,0,0);   // red line every 10 fps\n    }\n    \n    O.a = iFrame<30 && U==vec2(0) && iResolution.y>200.  // use 30 frames to adjust to your computer\n        ? float(N) * (.8 + .2*(1./31.)/iTimeDelta ) // relaxation towards 30fps goal.\n        : float(N);\n}","name":"Buf A","description":"","type":"buffer"}]}