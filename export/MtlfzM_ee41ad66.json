{"ver":"0.1","info":{"id":"MtlfzM","date":"1511476547","viewed":312,"name":"WaveLife","username":"huwb","description":"Simple/dumb waves shader. LMB to make waves and maybe even excite a harmonic or two..","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["waves","fluid","1d","waveequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// render\n\n// lo-fi rendering\n\nfloat downsample = 32.;\n// returns (current height, last height, height before last, unused)\nvec3 waterHeights( vec2 fragCoord )\n{\n    vec4 water = texture(iChannel0,vec2(fragCoord.x/downsample,0.5)/iResolution.xy);\n    return water.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 hs = waterHeights(fragCoord);\n    \n    if( fragCoord.y < hs.x )\n    {\n        // foam - measure based on acceleration\n        float accelDown = -((hs.x-hs.y)-(hs.y-hs.z))*.25;\n        float bp = 0.2;\n        accelDown = clamp((accelDown - bp)/(1.-bp),0.,1.);\n        fragColor = mix(vec4(0.1,0.2,1.,0.),vec4(1.),accelDown);\n    }\n    else\n    {\n        // sky\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t    fragColor = vec4(mix(vec3(.9,.4,.5),.8*vec3(.7,.6,1.),floor(uv.y*4.)/4.),0.);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// wave sim\n\n// adapted from sibaku's shader: https://www.shadertoy.com/view/Ms3SWH\n\nfloat downsample = 32.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // dynamics simulated in a section of the first image row\n    if( fragCoord.y > 0.5 || fragCoord.x >= iResolution.x/downsample )\n        return;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 D = vec2(1./iResolution.x, 0.);\n    float c = 8./downsample;\n    \n    // sample this and neighbour values\n    // (current height, last height, height before last, unused)\n    vec4 f = texture(iChannel0, uv); \n    vec4 fxm = texture(iChannel0, uv - D.xy);\n    vec4 fxp = texture(iChannel0, uv + D.xy);\n    \n    // boundary conditions - clamp at sea level\n    vec4 baseHeight = vec4(.33 * iResolution.y);\n    if( fragCoord.x + 1. >= iResolution.x/downsample )\n    {\n        fxp = mix( baseHeight, f, 0.975 );\n        //fxp = baseHeight;\n    }\n    if( fragCoord.x - 1. <= 0. )\n    {\n        fxm = mix( baseHeight, f, 0.975 );\n        //fxm = baseHeight;\n    }\n\n    // Discrete wave pde\n    // Taken from http://www.mtnmath.com/whatrh/node66.html\n    float f_next = c*c*(fxp.x + fxm.x - 2.0*f.x) - f.y + 2.0*f.x;\n    // friction\n    f_next =  mix( baseHeight.x, f_next, 0.995 );\n\n    /*\n    // open boundary condition, from: http://hplgit.github.io/wavebc/doc/pub/._wavebc_cyborg002.html\n    if( fragCoord.x + 1. >= iResolution.x/downsample )\n    {\n        // dudt + c*dudx = 0\n        // f_next - f.x   +   c*(f.x-fxm.x) = 0.\n        f_next = -c*(f.x - fxm.x) + f.x;\n    }\n\t*/\n\n    if( iMouse.z > 0. )\n    {\n        float amp = iResolution.y / 180.;\n        float rad = iResolution.x / 640.;\n        f_next -= amp*(smoothstep(1.5,0.,abs(iMouse.x/downsample-fragCoord.x)/rad )-.07);\n    }\n\n    fragColor = vec4(f_next, f.x, f.y, 0.0);\n\n    if( iFrame == 0 )\n    {\n        fragColor = baseHeight + 20. * cos(.2*fragCoord.x);\n    }\n}\n","name":"Buf A","description":"","type":"buffer"}]}