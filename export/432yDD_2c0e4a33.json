{"ver":"0.1","info":{"id":"432yDD","date":"1727290802","viewed":16,"name":"Fork Sunrise - Cyberpunk Sky","username":"MercyMay","description":"Fork Sunrise - Cyberpunk Sky","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["clouds","pink","cyberpunk"],"hasliked":0,"parentid":"XsBXDc","parentname":"Sunrise, sunset"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\nfloat map(vec3 p) {\n    vec3 q = p + 0.2*vec3(3.0, 0.3, 5.0)*mod(iTime,3600.0)*2.0;\n    float n = 0.0, f = 0.5;\n    n += f*noise(q); q *= 3.001; f *= 0.333;\n    n += f*noise(q); q *= 3.002; f *= 0.332;\n    n += f*noise(q);\n    return n;\n}\n\nfloat scene(vec3 p)\n{\n    return p.y+2.0-0.003*map(vec3(p.x, 0.0, p.z));\n}\n\nvec3 normal(vec3 p, float d)\n{\n    float e = 0.05;\n    float dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n    float dy = scene(vec3(0.0, e, 0.0) + p) - d;\n    float dz = scene(vec3(0.0, 0.0, e) + p) - d;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n    vec3 bgLight = normalize(vec3(\n        sin(iTime*0.5)*0.1,\n        cos(iTime*0.1)*0.6-0.3,\n        -1.0\n    ));\n    float sunD = dot(bgLight, nml) > 0.995 ? 1.0 : 0.0;\n    vec3 sun = vec3(8.0, 2.0, 6.0); // Adjusted sun color for more pink/purple\n    float skyPow = dot(nml, vec3(0.0, -1.0, 0.0));\n    float centerPow = 0.0;\n    float horizonPow = pow(1.0-abs(skyPow), 3.0)*(5.0+centerPow);\n    float sunPow = dot(nml, bgLight);\n    float sp = max(sunPow, 0.0);\n    float scattering = clamp(1.0 - abs(2.0*(-bgLight.y)), 0.0, 1.0);\n    vec3 bgCol = max(0.0, skyPow)*2.0*vec3(0.9, 0.5, 0.8); // More pink sky base\n    bgCol += 0.5*vec3(1.0, 0.4, 0.8)*(horizonPow); // Pink horizon\n    bgCol += sun*(sunD+pow( sp, max(128.0, abs(bgLight.y)*512.0) ));\n    bgCol += vec3(0.6, 0.2, 0.5)*(pow( sp, 8.0) + pow( sp, max(8.0, abs(bgLight.y)*128.0) )); // Purple glow\n    bgCol *= mix(vec3(0.9, 0.5, 0.8), vec3(1.0, 0.2, 0.6), scattering); // Pink-purple scattering\n    bgCol *= 1.0 - clamp(bgLight.y*3.0, 0.0, 0.6);\n    float cloudFac = pow(abs(skyPow), 0.8)*1.0;\n    \n    float ufCloudCover = 0.3; // Adjusted for less cloud cover\n    float cc = 0.4 + 0.1 * (ufCloudCover - 0.2)/0.1;\n    float cloud = 0.0;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*1.03/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*3.0/nml.y)))) * 0.3;\n    bgCol *= 1.0+cloudFac*cloud;\n\n    // Add some cyberpunk-style grid lines\n    vec2 gridUV = fragCoord.xy / iResolution.xy;\n    float gridIntensity = 0.05 * (sin(gridUV.x * 50.0) + sin(gridUV.y * 50.0));\n    bgCol += vec3(0.0, 1.0, 1.0) * gridIntensity; // Cyan grid lines\n\n    return pow(max(vec3(0.0), bgCol), vec3(2.2)); // Adjusted gamma for more vibrant colors\n}\n\nmat3 rotationXY( vec2 angle ) {\n    float cp = cos( angle.x );\n    float sp = sin( angle.x );\n    float cy = cos( angle.y );\n    float sy = sin( angle.y );\n\n    return mat3(\n         cy, -sy, 0.0,\n         sy,  cy, 0.0,\n        0.0, 0.0, 1.0\n    ) * mat3(\n        cp, 0.0, -sp,\n        0.0, 1.0, 0.0,\n        sp, 0.0, cp\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (2.0 * (fragCoord.xy / iResolution.xy) - 1.0) * aspect;\n    mat3 rot = rotationXY( vec2( 0.2+0.2*cos(0.5*iTime), -0.15*sin(0.5+0.5*iTime) ) );\n    vec3 d = rot * normalize(vec3(uv, 1.0));\n    vec3 p = vec3(uv*-2.0, -9.5);\n    vec3 tr = vec3(1.0);\n    if (d.y < 0.0) {\n        float dist = -2.0 / d.y - p.y / d.y;\n        p += d * dist;\n        vec3 nml = normal(p, 0.0);\n        float f = pow(1.0-dot(d, -vec3(0.0, 1.0, 0.0)), 5.0);\n        nml = mix(nml, vec3(0.0, 1.0, 0.0), f);\n        d = reflect(d, nml);\n        tr *= mix(0.5*vec3(0.8, 0.5, 0.9), vec3(1.0), f); // Adjusted reflection color\n    }\n    \n    vec3 col = tr * shadeBg(-d, fragCoord);\n    \n    // Add some digital noise\n    vec4 noise = (texture(iChannel0, mod(fragCoord.xy/256.0, 1.0))-0.5) / 64.0;\n    \n    // Add a subtle scanline effect\n    float scanline = sin(fragCoord.y * 0.5 + iTime * 10.0) * 0.02;\n    col += vec3(scanline);\n\n    fragColor = pow(vec4(noise.rgb + (1.0 - exp(-1.3 * col.rgb)), 1.0), vec4(1.2)); // Adjusted final gamma\n    \n    // Add a subtle vignette effect\n    vec2 vignetteUV = fragCoord.xy / iResolution.xy;\n    float vignette = smoothstep(0.5, 0.35, max(abs(vignetteUV.x - 0.5), abs(vignetteUV.y - 0.5)));\n    fragColor.rgb *= vignette;\n}","name":"Image","description":"","type":"image"}]}