{"ver":"0.1","info":{"id":"tls3zX","date":"1557179162","viewed":556,"name":"[twitch] Jewel Surface","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nYou can also try the color and shape options","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nYou can also try the color and shape options\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/JewelSurface.glsl\nInspired by https://www.shadertoy.com/view/ttl3R2\n*/\n\n#define MARCH_STEPS 100\n\n#define COLOR_GEM 1\n#define RED_GEM 0\n#define CHROMATIC 0\n\n#define SHAPE sphere\n//#define SHAPE box\n//#define SHAPE diamon\n//#define SHAPE cylinder\n\n#define time iTime\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*724.355)*685.655);\n}\n\nfloat bx(vec3 p) {\n  p=abs(p);\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n}\n\nfloat mat=1.;\nfloat id=0.;\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  float s=5.;\n  float mm=10000.;\n  id=0.;\n  for(int i=0; i<4; ++i) {\n    \n    float t=rnd1(float(i)+12.7)*75.842 + 122.845;\n    //t += time*(.1+i*.05);\n    p.xy *= rot(t);\n    p.yz *= rot(t*.7);\n    \n    id += dot(sign(p), vec3(1.72,3.84,12.94)*(float(i)+1.));\n    p=abs(p);\n    \n    float mp=min(p.x, min(p.y,p.z));\n    mm=min(mm,mp);\n    \n    p-=s;\n    \n    s*=0.7;\n  }\n    \n  \n  float d = mm;\n  \n  float dist=0.6;\n  vec3 rp=(fract(p/dist-.5)-.5)*dist;\n  float d3 = length(rp);\n  \n  float sphere = length(bp)-20.;\n  float box = bx(bp)-14.;\n  float diamon = box;\n  bp.xy *= rot(3.141592*.25);\n  bp.xz *= rot(3.141592*.25);\n  diamon = max(diamon, bx(bp)-12.);\n  \n  float cylinder = max(length(bp.xz)-14., length(bp.xy)-18.);\n  //shape = smin(length(bp+7 * sin(time*.5))-12, length(bp-7)-12, 12);\n  \n  float shape = SHAPE;\n    \n  float d4 = length(vec2(d, shape));\n  d = d4-0.17;\n  \n  d3 = length(vec2(d3, d4))-0.39;\n  \n  \n  \n  d = min(d,d3);\n  \n  \n  float d2 = abs(shape) - min(mm-.2, 1.0) * .7;\n  \n  \n  \n  mat=(d<d2)?1.:0.;\n  \n  d=min(d, d2);\n  \n  //d*=0.7;\n  \n  return d;\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd1(floor(g)), rnd1(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvoid cam(inout vec3 p) {\n  float t=time*.15 + curve(time+97.4, 2.5*4.)*2.;\n  p.yz *= rot(sin(t)*.5);\n  p.xz *= rot(sin(t*1.3)*.9);\n}\n\nvec3 rnd(float t) {\n  return fract(sin(t*vec3(423.745,384.912,542.877))*725.945);\n}\n\nvec3 sky(vec3 r) {\n  \n  vec3 col=vec3(0.3);\n  \n  float dist=0.3;\n  vec2 amask=abs(fract(r.yz/dist-.5)-.5)*dist;\n  float mask=clamp(((1.3-(max(amask.x,amask.y))*10.))*2.,0.,1.);\n  \n  col = mix(col, vec3(7), pow(max(0.,-r.y),12.));\n  col = mix(col, vec3(7), pow(max(0.,-r.z),12.));\n  col = mix(col, mask * vec3(10), pow(abs(r.x),10.));\n  \n  return col * 1.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  #if CHROMATIC\n  float fsize=1.0;\n  float fringe = fract(floor(gl_FragCoord.y/fsize)*fsize/3.);\n  vec3 fcol = (1.-abs(fringe*3.-vec3(0,1,2)))*3.;\n  #else\n  float fringe = 0.;\n  vec3 fcol = vec3(1.0);\n  #endif\n  \n  //uv *= 2.0/(1.0+length(uv));\n\n  float delay=2.5;\n  float zoom=curve(time, delay);\n  vec3 s=vec3((curve(time+12.75, delay)-.5)*13., (curve(time+37.15, delay)-.5)*12.,-27.-zoom*10.);\n  vec3 r=normalize(vec3(-uv, 0.9 - zoom * 0.4));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 col=vec3(0);\n  vec2 off=vec2(0.01,0);\n  \n  vec3 p=s;\n  float side=1.;\n  vec3 prevhit=s;\n  vec3 prod=vec3(1);\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p)*side;\n    if(abs(d)<0.001) {\n      \n      float curmat=mat;\n      float curid=id;\n      \n      vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))) * side;\n              \n      vec3 rn = reflect(r,n);\n      \n      float fre=pow(1.-abs(dot(n,r)), 2.);\n      \n      if(curmat<0.5) {\n        #if RED_GEM\n        vec3 diff=vec3(1,0,0.2);\n        #elif COLOR_GEM\n        vec3 diff=rnd(curid);\n        diff=1.-step(diff, vec3(0.8));\n        if(dot(diff,vec3(1))<0.2) diff=vec3(1);\n        #else\n        vec3 diff=vec3(1);\n        #endif\n        \n        vec3 depth = exp(-distance(prevhit,p) / diff*0.04);\n        \n        col += diff * sky(rn) * fre * prod;\n        \n        float ior=1.2 - fringe*0.1;\n        vec3 ref = refract(r,n, side<0.0? ior : 1.0/ior);\n        if(dot(ref,ref)>0.1) {\n          \n          r=ref;\n        } else {\n          \n          r=rn;\n        }\n        prod *= depth;\n        prod *= 1.-fre;\n        \n        side = -side;\n        p-=n*0.1;\n      } else {\n        r=rn;\n        \n        prod *= pow(fre,0.5);\n        //prod *= pow(1-fre,10);\n        //prod *= 0.0;\n        p+=n*.1;\n        //break;\n      }\n      \n      d = 0.1;\n      prevhit = p;\n      //break;\n    }\n    if(d>50.) break;\n    p+=r*d;\n  }\n  \n  col *= fcol;\n  \n  col += sky(r)*prod;\n  \n  //col *= 1.2-length(uv);\n  \n  col *= pow(col, vec3(0.4545));\n  \n  col=clamp(col, 0.,1.);\n  col *= 1.2-length(uv)*1.1;\n    \n  fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}