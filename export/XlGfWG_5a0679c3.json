{"ver":"0.1","info":{"id":"XlGfWG","date":"1543855926","viewed":304,"name":"Devoxelizer","username":"Falko","description":"I used the buffer as Volume buffer and to compute the trajectory of the ball. The raytracing doesnt work faultlessly from all sides and the rendering could be a lot nicer.\nUse mouse to rotate.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["multipass","voxelizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 v;\nvec3 lightSource = vec3(20.0, 0.0, 6.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\nfloat specular(vec3 normal, vec3 p, vec3 rCamera){\n            vec3 dir_light = normalize(p-lightSource);\n            vec3 dir_reflect = reflect(dir_light, normal);\n            float spec = pow(max(0.0, dot(rCamera, dir_reflect)), 100.0);\n            return spec;\n            \n    }\n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    vec3 v0 = 5.0*vec3(1.0, 0.4, 0.5);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nbool inSquare(vec2 p){\n  vec2 pAbs = abs(p);\n  return (max(pAbs.x, pAbs.y)<1.0);\n}\n\nint intersectCube(vec3 pFrag, vec3 rView){\n \tvec3 p = pFrag;\n    \n    vec3 sig = sign(rView);\n    vec3 a = -(sig+p)/rView;\n    \n    vec3 normal = vec3(0.0);\n    vec3 pSurface;\n    vec2 p2D;\n    int ii;\n    for(int i=0; i<3; i++){\n        \n        \n        pSurface = p+a[i]*rView;\n        p2D = vec2(pSurface[int(mod(float(i)+1.0, 3.0))],\n                   pSurface[int(mod(float(i)+2.0, 3.0))]);\n        \n        if(inSquare(p2D)){\n            \n            \n            return i;\n        }\n       }\n     return   -1;  \n}\n\nivec2 spaceToBuffer(ivec3 ijk, int N){\n \tivec2 nm = ivec2((ijk.z*N+ijk.x)/2,\n                    ijk.y/2);\n    return nm;\n}\n\nbool isEmpty(vec3 lowerCorner, int N){\n    ivec2 nm = spaceToBuffer(ivec3(lowerCorner), N);\n    vec4 texel = texelFetch(iChannel0, nm, 0);\n    //return (texel.x<0.5);\n    if(mod(lowerCorner.x, 2.0)<0.001){\n        if(mod(lowerCorner.y, 2.0)<0.001){\n            return (texel.x<0.5);\n        }\n        else{\n            return (texel.z<0.5);\n        }\n    }\n    else{\n        if(mod(lowerCorner.y, 2.0)<0.001){\n            return (texel.y<0.5);\n        }\n        else{\n            return (texel.w<0.5);\n        }\n    }\n}\n\n\n\nvec3 getNext(vec3 p, vec3 rView){\n    \n    vec3 pf = fract(p);\n    vec3 sig = sign(rView);\n    vec3 a = (floor(1.0+0.5*sig)-sig*pf)/abs(rView);\n    a = max(-pf/rView+0.0005, (1.0-pf)/rView);\n    float aMin = 4.0;\n    \n    for(int i; i<3; i++){\n        aMin = min(aMin, a[i]);\n    }\n    return p+aMin*rView;\n}\n\nbool inCube(vec3 p, int N){\n \tvec3 pAbs = abs(2.0*p/float(N)-1.0);\n    float pMax = max(pAbs.x, max(pAbs.y, pAbs.z));\n    return (pMax<1.0);\n}\n\nvec4 CubeMarch(vec3 pCenteredCube, vec3 rView, vec3 normalStart,int N){\n\tvec3 p = float(N)*0.5*(pCenteredCube+1.0)+0.5*rView;\n    \n    \n    \n    vec3 normal = normalStart;\n    vec3 current = floor(p);\n    \n    int i = 0;\n    while(i<10*int(sqrt(2.0))*N && inCube(p+0.5*rView, N)){\n        \n    \tif(isEmpty(current, N)){\n            p = getNext(p,  rView)+0.0005*rView;\n            normal = current;\n            current = floor(p);\n            normal = normal-current;\n        }\n        else{\n            //return vec4(vec3(0.0), 1.0);\n            vec3 pSurface = 2.0*p/float(N)-1.0;\n            float bd = diffuse(pSurface, normal);\n            float spec = specular(normal, pSurface, normalize(v-pSurface));\n           \t\n        \tvec3 color = mix(vec3(1.0), (ba+bd)*vec3(1.0), 1.0-spec);\n            return vec4(color, length(v-pSurface));\n        }\n        i = i + 1;\n     \t   \n    }\n    \n    return vec4(vec3(0.76, 0.57, 0.5), 1000.0);\n    //return colorBall(pBall);\n    \n}\n\nvec2 intersectBall(vec3 cp, vec3 rView){\n    //compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nvec3 cBall(){\n    return texelFetch(iChannel0,\n                     \tivec2(0, 39+5),\n                           0).xyz;\n}\n\nvec4 computeBall(vec3 p, vec3 rView){\n    //compute intersection of viewing ray with sphere\n    //calculate color\n    vec3 center = cBall();\n    float radius =  0.2;\n    vec3 cLemon = vec3(1.0, 0.88, 0.0);\n    vec2 sol = intersectBall(center-p, rView);\n    \n    float r2 = pow(radius, 2.0)+sol.y;\n    if(r2>0.0){\n        \n        \tfloat temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n           \tvec3 p1 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/temp;\n           \tvec3 normal = normalize(p-center);\n        \tfloat bd = diffuse(p1, normal);\n        \tfloat spec = specular(normal, p1, normalize(v-p1));\n           \t\n        \tvec3 color = mix(vec3(1.0), (ba+bd)*cLemon, 1.0-spec);\n        \treturn vec4(color, length(p1-v));\n           \t//return vec4(cLemon, radius-sqrt(r2));\n    }\n    else{\n           \treturn vec4(vec3(0.76, 0.57, 0.5), 1000.0);\n    }        \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n    //vec3 v = 10.0*vec3(1.0, 0.0, 1.0);\n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n\t\n    int iIntersect = intersectCube(pFrag, rView);\n    vec4 color;\n    \n    if(iIntersect>=0){\n        vec3 sig = sign(rView);\n    \tvec3 a = -(sig+pFrag)/rView;\n        vec3 pSurface = pFrag+a[iIntersect]*rView;\n        vec3 normalStart = vec3(0.0);\n        normalStart[iIntersect] = -sig[iIntersect];\n        color = CubeMarch(pSurface, rView, normalStart, 39);\n        //color = vec4(vec3(0.0), 1.0);\n    }\n    else{\n     \tcolor = vec4(vec3(0.76, 0.57, 0.5), 1000.0);\n    }\n    vec4 colorBall = computeBall(pFrag, rView);\n    \n    //show buffer\n    ivec2 texelCoord = ivec2(fragCoord-0.5);\n    //fragColor = texelFetch(iChannel0, texelCoord, 0);\n    // Output to screen\n   \tfragColor = vec4(mix(color.xyz, colorBall.xyz,\n                        step(0.0, color.w-colorBall.w)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ball start\n\nvec3 random3(){\n    //hash function to generate noise\n    vec3 st = iTime * vec3(127.1, 311.7, 269.5);\n              \n    return normalize(-1.0 + 2.0*fract(sin(st)*43758.177));\n    }\n\nvec4 initBall(){\n return vec4(vec3(2.0, 0.0, 0.0), 1.0);   \n}\n\n\n\n\nvec4 cBall(ivec2 fragCoord){\n    if(iFrame<50){\n        \n        return initBall();\n    }\n    else{\n     \tvec3 current = texelFetch(iChannel0,\n                     \t\tivec2(0, 39+5),\n                           0).xyz;\n        \n        vec3 currentDir = texelFetch(iChannel0,\n                     \t\tivec2(1, 39+5),\n                           0).xyz;\n        vec3 next = current + 0.2*currentDir;\n        \n        if(length(next)>2.0){\n            currentDir = reflect(currentDir,\n                                 -normalize(next));\n           \tnext = current+\n                0.2*currentDir;\n                \n        }\n        return vec4(next, 0.0);\n    }\n}\n\nvec4 initDir(){\n \treturn vec4(normalize(vec3(-1.0, 0.0, 0.0))\n                , 0.0);   \n}\n\nvec4 dirBall(ivec2 fragCoord){\n if(iFrame<50){\n        \n        return initDir();\n    }\n    else{\n     \tvec3 current = texelFetch(iChannel0,\n                     \t\tivec2(0, 39+5),\n                           0).xyz;\n        \n        vec3 currentDir = texelFetch(iChannel0,\n                     \t\tivec2(1, 39+5),\n                           0).xyz;\n        vec3 next = current + 0.2*currentDir;\n        \n        if(length(next)>2.0){\n            currentDir = reflect(currentDir,\n                                 -normalize(next))\n                \t\t\t\t+0.2*random3();\n           \t\n                \n        }\n        return vec4(normalize(\n            \t\tcurrentDir), 0.0);\n    }\n}\n\n\n\n//ball end\n\n//voxelizer start\nivec2 spaceToBuffer(ivec3 ijk, int N){\n \tivec2 nm = ivec2((ijk.z*N+ijk.x)/2,\n                    ijk.y/N);\n    return nm;\n}\n\nivec3 bufferToSpace(ivec2 nm, int N){\n \tint k = 2*nm.x/N;\n    ivec3 ijk = ivec3(2*nm.x-(k*N),\n                      2*nm.y,\n                      k);\n    return ijk;\n}\n\n\nvec4 readTexel(ivec2 texCoord){\n \treturn texelFetch(iChannel0, texCoord, 0); \n}\n\nfloat readBuffer(ivec3 ijk, int N){\n \tivec2 nm = spaceToBuffer(ijk, N);\n    vec4 texel = texelFetch(iChannel0, nm, 0);\n    \n    ivec2 inner = ivec2(ijk.x, ijk.y);\n    inner = inner-inner/2;\n    \n    return texel[inner.x+inner.y*2];\n}\n\nfloat oldVoxelValue(ivec2 texCoord, int pos){\n \tvec4 oldTexel =  texelFetch(iChannel0,\n                     \t\ttexCoord,\n                           0);\n    return oldTexel[pos];\n    \n}\n\n\nfloat newVoxelValue(ivec3 ijk, int N, ivec2 texCoord, int pos){\n \t   vec3 p = 2.0*vec3(ijk)/float(N)-1.0;\n    vec3 center = texelFetch(iChannel0,\n                     \t\tivec2(0, N+5),\n                           0).xyz;\n    if(length(p-center)<0.2){\n        return 0.0;\n    }\n    else{\n        return min(1.0, oldVoxelValue(texCoord, pos));\n    }\n}\n\nfloat newVoxelValue1(ivec3 ijk, int N, ivec2 texCoord){\n \t   vec3 p = 2.0*vec3(ijk)/float(N)-1.0;\n    vec3 center = texelFetch(iChannel0,\n                     \t\tivec2(0, N+5),\n                           0).xyz;\n    if(length(p-center)<0.5){\n        return 1.0;\n    }\n    else{\n        return 0.0;\n    }\n}\n\nvec4 newTexelValue(ivec2 texCoord, int N){\n    ivec3 ijk = bufferToSpace(texCoord, N);\n    \n    vec4 value = vec4(0.0);\n    \n    value.x = newVoxelValue(ijk, N, texCoord, 0);\n    value.y = newVoxelValue(ijk+ivec3(1, 0, 0), N, texCoord, 1);\n    value.z = newVoxelValue(ijk+ivec3(0, 1, 0), N, texCoord, 2);\n    value.w = newVoxelValue(ijk+ivec3(1, 1, 0), N, texCoord, 3);\n    \n    return value;\n    \n}\n\nbool inVolume(ivec2 texelCoord, int N){\n \t  return (texelCoord.x<N*N/2 &&\n              texelCoord.y<N/2);\n}\n\n//voxelizer end\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    ivec2 texCoord = ivec2(fragCoord-0.5);\n    int N = 39;\n    if(texCoord.x == 0 && texCoord.y == N+5){\n        fragColor = cBall(texCoord);\n        //fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n    else if(texCoord.x == 1 && texCoord.y == N+5){\n        fragColor = dirBall(texCoord);\n    }\n    else if(!inVolume(texCoord, N)){\n        fragColor = vec4(0.0);\n    }\n    else{\n        if(iFrame<50){\n            fragColor = vec4(1.0);\n        }\n        else{\n     \t\tfragColor = newTexelValue(texCoord, N);\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}