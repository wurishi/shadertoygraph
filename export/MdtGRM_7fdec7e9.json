{"ver":"0.1","info":{"id":"MdtGRM","date":"1448692150","viewed":274,"name":"Terrain by Perlin Noise","username":"battal","description":"Procedurally generated terrain using Perlin Noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* ----- Constants ----- */\n\n#define PI 3.14159265359\n\n#define AUTO_REPEAT 256.0\n#define TERRAIN_OCTAVES 5\n\n#define FAR_PLANE 100.0\n\n#define MIN_T 0.5\n#define MAX_T 50.0\n\n#define EPS 0.001\n\n\n/* ----- Specification ----- */\n\n/* Noise functions */\nfloat hash(float x, float y);\nfloat fade(float t);\n\nint get_gradient(float xi, float yi, int repeat);\nfloat get_dot(int gradient, float x, float y);\n\nfloat noise(float x, float y, int repeat);\nfloat octave_noise(float x, float y, int repeat, float frequency, float max_amplitude, float persistence);\n\n/* Distance fields and ray marching */\nfloat terrain(vec3 p);\nfloat sphere(vec3 p);\n\nfloat castRay(vec3 eye, vec3 ray);\n\n/* Lighting */\nfloat get_shadow(vec3 terrain_p, vec3 light_ray);\nvec4 get_terrain_color(vec3 eye, vec3 ray, float t, vec3 sun_dir);\n\nvec4 get_fog_color(vec3 ray, vec3 sun_dir);\nfloat get_fog_amount(vec3 eye, vec3 ray, float t);\nfloat get_fog_amount_const(float t);\n\nvec4 get_lighting(vec3 eye, vec3 ray, float t);\n\n/* Transformation */\nmat4 inverse_view_matrix(vec3 look, vec3 up, vec3 pos);\nmat4 inverse_projection_matrix(float width_angle, float height_angle, float far);\n\n\n/* ----- Functions ----- */\n\n/* Pseudo-random number generator */\nfloat hash(float x, float y) {\n    return fract(sin(floor(x) * 127.1 + floor(y) * 311.7) * 43758.5453123);\n}\n\n/* Interpolation function */\nfloat fade(float t)\n{\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n/* Integer representation of the gradient */\nint get_gradient(float xi, float yi, int repeat)\n{\n    /* Take modulus to wrap overflowed numbers */\n    if(repeat > 0)\n    {\n    \txi = mod(xi, float(repeat));\n    \tyi = mod(xi, float(repeat));\n    }\n    \n    xi = mod(xi, AUTO_REPEAT);\n    yi = mod(yi, AUTO_REPEAT);\n    \n    /* Random gradient in last four bits */\n    float val = hash(xi, yi);\n\treturn int(mod(val * 256.0, 256.0));\n}\n\n/* Dot product between gradient and location vector */\nfloat get_dot(int gradient, float x, float y)\n{\n\tint grad_bits = int(mod(float(gradient), 4.0));\n    \n    if(grad_bits == 0x0)\n    {\n    \treturn x + y;\n    }\n    else if(grad_bits == 0x1)\n    {\n    \treturn x - y;\n    }\n    else if(grad_bits == 0x2)\n    {\n    \treturn -x + y;\n    }\n    else if(grad_bits == 0x3)\n    {\n    \treturn -x - y;\n    }\n}\n\n/* Perlin noise function */\nfloat noise(float x, float y, int repeat)\n{   \n    /* Get inputs */\n    if(repeat > 0)\n    {\n    \tx = mod(x, float(repeat));\n        y = mod(y, float(repeat));\n    }\n    \n    \n    /* Closest integral coordinates */\n    float xi = mod(floor(x), AUTO_REPEAT);\n    float yi = mod(floor(y), AUTO_REPEAT);\n    \n    /* Coordinates within unit box */\n    float xf = fract(x);\n    float yf = fract(y);\n    \n    /* Interpolation factors */\n    float u = fade(xf);\n    float v = fade(yf);\n    \n    /* Calculate gradients */\n    int aa = get_gradient(xi, yi, repeat);\n    int ab = get_gradient(xi + 1.0, yi, repeat);\n    int ba = get_gradient(xi, yi + 1.0, repeat);\n    int bb = get_gradient(xi + 1.0, yi + 1.0, repeat);\n    \n    /* Calculate influence */\n    float g1 = get_dot(aa, xf, yf);\n    float g2 = get_dot(ab, xf - 1.0, yf);\n    float g3 = get_dot(ba, xf, yf - 1.0);\n    float g4 = get_dot(bb, xf - 1.0, yf - 1.0);\n    \n    return mix(mix(g1, g2, u), mix(g3, g4, u), v);\n}\n\n/* Perlin noise with octaves, adjustable frequency and amplitude */\nfloat octave_noise(float x, float y, int repeat, float frequency, float max_amplitude, float persistence)\n{\n    float total = 0.0;\n    float amplitude = max_amplitude;\n    \n    for(int i = 0; i < TERRAIN_OCTAVES; i++)\n    {\n        /* Accumulate noise */\n        total += amplitude * noise(x * frequency, y * frequency, repeat);\n        \n        /* Update frequency, amplitude */\n        frequency = frequency * 2.0;\n        amplitude = amplitude * persistence;\n    }\n    \n    return total;\n}\n\n/* Terrain height function */\nfloat terrain(vec3 p)\n{\n\treturn octave_noise(p.x, p.z, 0, 1.0 / 4.0, 1.5, 0.4);\n}\n\n/* Sphere distance function */\nfloat sphere(vec3 p)\n{\n\treturn length(p - vec3(0.0, 1.0, -10.0)) - 0.5;\n}\n\n/* Ray march, return time of intersection */\nfloat castRay(vec3 eye, vec3 ray)\n{   \n    float t = MIN_T;\n    \n    vec3 p = eye + t * ray;\n    float h;\n    \n    for(int i = 0; i < 400; i++)\n    {\n        /* Get height to terrain */\n        h = p.y - terrain(p);\n        \n        /* Return t if close enough */\n        if(h < 0.001)\n        {\n        \treturn t;\n        }\n        \n        if(t > MAX_T)\n            return -1.0;\n        \n        /* Decrease precision */\n        t += h * 0.75;\n        \n        /* Calculate next point */\n        p = eye + ray * t;\n    }\n    \n    return -1.0;\n}\n\n\n/* Get shadow from terrain point and light ray to point*/\nfloat get_shadow(vec3 op, vec3 light_ray)\n{\n\tfloat t = MIN_T;\n    \n    vec3 p = op + light_ray * t;\n    float h;\n    float shadow = 1.0;\n    \n    for(int i = 0; i < 400; i++)\n    {\n    \th = p.y - terrain(p);\n        \n        if(h < 0.001)\n        {\n            return 0.0;\n        }\n        \n        if(t > MAX_T)\n        {\n            return shadow;\n        }\n        \n        shadow = min(shadow, 10.0 * h / t);\n        \n        t += h * 0.75;\n        p = op + light_ray * t;\n    }\n    \n    return shadow;\n}\n\n/* Get terrain color */\nvec4 get_terrain_color(vec3 eye, vec3 ray, float t, vec3 sun_dir)\n{    \n    float shadow = get_shadow(eye + ray * t, -sun_dir);\n    \n    /* Base terrain color (brown) */\n    vec3 base_color = vec3((150.0 / 256.0),\n                            (126.0 / 256.0),\n                            (109.0 / 256.0));\n    \n    /* Normal */\n    vec3 p = eye + ray * t;\n    vec3 normal = normalize(vec3(terrain(p + vec3(-EPS, 0.0, 0.0)) - terrain(p + vec3(EPS, 0.0, 0.0)),\n                       2.0 * EPS,\n                       terrain(p + vec3(0.0, 0.0, -EPS)) - terrain(p + vec3(0.0, 0.0, EPS))));\n    \n    /* Ambient lighting */\n    float ka = 0.2;\n    vec3 ambient_color = base_color;\n        \n    /* Diffuse lighting */\n    float kd = 0.6;\n    float diffuse_dot = dot(normal, -sun_dir);\n    vec3 diffuse_color = base_color;\n    \n    /* Specular lighting */\n    float ks = 0.2;\n    vec3 specular_color = base_color;\n    \n    return vec4(ka * ambient_color + kd * shadow * diffuse_dot * diffuse_color, 1.0);\n}\n\n/* Get fog color */\nvec4 get_fog_color(vec3 ray, vec3 sun_dir)\n{\n    vec4 blue_fog = vec4(0.5, 0.6, 0.7, 1.0);\n    vec4 yellow_fog = vec4(1.0, 0.9, 0.7, 1.0);\n    \n    float sun_amount = max(dot(ray, -sun_dir), 0.0);\n    return mix(blue_fog, yellow_fog, pow(sun_amount, 8.0));\t\n}\n\n/* Non-constant fog density (varying with height) */\nfloat get_fog_amount(vec3 eye, vec3 ray, float t)\n{\n    float a = 0.09;\n    float b = 1.0;\n\treturn a * exp(-b * eye.y) * (1.0 - exp(-b * ray.y * t)) / (b * ray.y);\n}\n\n/* Constant fog density */\nfloat get_fog_amount_const(float t)\n{\n    float b = 0.05;\n\treturn 1.0 - exp(-b * t);\n}\n\n/* Get lighting for pixel */\nvec4 get_lighting(vec3 eye, vec3 ray, float t)\n{\n    vec3 sun_dir = normalize(vec3(1.0, -0.3, -1.0));\n    vec4 terrain_color = get_terrain_color(eye, ray, t, sun_dir);\n    vec4 fog_color = get_fog_color(ray, sun_dir);\n    \n    return mix(terrain_color, fog_color, get_fog_amount(eye, ray, t));\n}\n\n/* Inverse of the view matrix */\nmat4 inverse_view_matrix(vec3 look, vec3 up, vec3 pos)\n{\n\tvec3 w = -normalize(look);\n    vec3 v = normalize(up - w * dot(up, w));\n    vec3 u = cross(v, w);\n    return mat4(\n    \tu.x, v.x, w.x, 0.0,\n        u.y, v.y, w.y, 0.0,\n       \tu.z, v.z, w.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n/* Inverse projection matrix */\nmat4 inverse_projection_matrix(float width_angle, float height_angle, float far)\n{\n    return mat4(\n    \tfar * tan(width_angle / 2.0), 0.0, 0.0, 0.0,\n        0.0, far * tan(height_angle / 2.0), 0.0, 0.0,\n        0.0, 0.0, far, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* Set up camera */\n \tvec3 look = normalize(vec3(0.0, 0.01, -1.0));\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 worldCameraPos = vec3(0.0, 3.0, 0.0);\n\n    /* Get point on film plane */\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 normalizedFilmPoint = vec3(2.0 * uv.x - 1.0, uv.y * 2.0 - 1.0, -1.0);\n    normalizedFilmPoint.x *= iResolution.x / iResolution.y;\n\n    /* Transform to world space */\n    mat4 ivm = inverse_view_matrix(look, up, worldCameraPos);\n    mat4 ipm = inverse_projection_matrix(PI / 4.0, PI / 4.0, FAR_PLANE);\n    vec3 filmPoint = vec3(ivm * ipm * vec4(normalizedFilmPoint, 1.0));\n    \n    /* Get ray */\n    vec3 eye = vec3(worldCameraPos.xy, -iTime);\n    vec3 ray = normalize(filmPoint - worldCameraPos);\n    \n    /* Ray march */\n    float t = castRay(eye, ray);\n    \n    /* Lighting */\n    if(t > 0.0)\n    {\n    \tfragColor = get_lighting(eye, ray, t);\n    }\n    else\n    {\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }    \n}","name":"","description":"","type":"image"}]}