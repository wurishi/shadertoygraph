{"ver":"0.1","info":{"id":"3d2cWz","date":"1586456412","viewed":640,"name":"charged solitons cubemap","username":"Carandiru","description":"original awesome shader : https://www.shadertoy.com/view/3syGzG\n\nthis variant extends the beautiful simulation to be inside a cubemap with spherical projection","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["waves","simulation","particles","cubemap","physics","nonlinear","classicalfieldtheory","electromagnetic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original shader borrowed from Fabrice Neyret @ https://www.shadertoy.com/view/wtGXzc (thank u)\n// as the template and base of this shader\n\n// original awesome shader : https://www.shadertoy.com/view/3syGzG\n// this variant extends the beautiful simulation to be inside a cubemap with spherical projection\n    \n\n// carandiru\n// http://bit.ly/supersinfulsilicon\n\n\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 uv = u.xy / R.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n    vec3 rayDir = normalize(vec3(uv, 1.0));\n\trayDir.xz *= rot(PI*.5);   \n    \n    vec2 rotv = vec2(0);\n    if (iMouse.z > 0.0) {\n        rotv = vec2((iMouse.xy - iResolution.xy*0.5)*0.01);\n    } else {\n        rotv = vec2(iTime*0.1, sin(iTime*0.3)*0.3);\n    }\n    \n    mat2 rot1 = rot(rotv.x);\n    mat2 rot2 = rot(-rotv.y);\n    rayDir.xy *= rot2;\n    rayDir.xz *= rot1;\n    \n \t//O.rgb = mix(royal_purple, royal_blue, .5-.5*rayDir.y);\n\n   // O.b = .7 * ( .5+.5*rayDir.y );       // background env\n    //O.r = .3 * ( .5-.5*rayDir.y );\n\n    vec4 T = texture(iChannel0, rayDir); // dynamic env\n    O = T;// * mix(O, T, T.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// original shader borrowed from Fabrice Neyret @ https://www.shadertoy.com/view/wtGXzc (thank u)\n// as the template and base of this shader\n\n// looking inside of the cube map, with what would be faces of a view \n// into the \"rain\" in that particular direction. \n\n// carandiru\n// http://bit.ly/supersinfulsilicon\n\n\nvec3 cartToSphere(vec3 cart) {\n    \n    float r = dot(cart,cart);\n    vec3 n = cart / (r);\n    return vec3(atan(n.x, n.z), asin(n.y), 1.0/(1.0+r*r));\n}\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 rayOri, vec3 rayDir )\n{\n    vec4 prev = texture(iChannel2, rayDir);\n    O = prev * .95; // faded past\n    \n    vec2 pos = cartToSphere(rayDir).xy;// * 0.5f + 0.5f;\n    pos *= exp(-1e-3f * R.xy) * R.xy;\n   // pos = face_uv * R.xy;\n    \n    vec4 UU = SAMPLR(BF, pos);\n    vec4 dU_dt = SAMPLR(AF, pos);\n    \n    float A = 2.*PI*length(UU.xy); //the complex field A module\n    float B = 2.*PI*length(UU.zw); //the complex field B module\n    float charge = 50.*(UU.z*dU_dt.w - UU.w*dU_dt.z); //charge in this frame of reference\n    \n    vec3 color;\n    color = vec3(0.1,0.3,0.7)*charge - vec3(0.8,0.1,0.)*charge + 0.3*vec3(0.1,0.8,0.1)*A*A - 0.3*vec3(0.1,0.8,0.1)*B*B;\n    \n    //float checker = step(0.5f, texture( iChannel1, (ruv) ).r);\n    //color += checker * 0.95;\n    //color += mix(color * sqrt(royal_blue), color, color * length(uv));\n    \n    //#define gradient (ruv)\n    //color *= vec3(gradient.x, 0.0f, gradient.y);\n    \n    O = vec4(mix(O.rgb, color, 0.5f),rayDir.z);\n    \n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"\n#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820)\n\n    \n#define R         iResolution.xy\n\n//#define rot(a)    mat2 ( cos(a+vec4(0,11,33,0)) )\n#define hash12(p) fract(sin((p)*vec2(127.1,311.7)) *43758.5453123)\n#define viewAngle texelFetch(iChannel1, ivec2(0), 0)\n#define viewDir   ray(vec2(0))\n#define drop(i)   texelFetch(iChannel1, ivec2(i,0), 0)\n#define zoom      texelFetch(iChannel1, ivec2(2), 0).x\n\n#define sq(x) (x*x)\n\n// rgb(0.222f,0.222f,1.0f) (far depth color) - royal blue (cooler)\nconst vec3 royal_blue = vec3(0.222f,0.222f,1.0f); // components are maximized\n// rgb(0.80f,0.65f,1.0f) (near depth color) - royal purle (warmer) \nconst vec3 royal_purple = (mix(royal_blue, vec3(0.80f,0.65f,1.0f), 0.5f)); // components are maximized\n\n/*\nvec3 dir;\n\n#define ray(U) (                     \\\n    dir = normalize(vec3(U,zoom)),   \\\n    dir.xz *= rot(viewAngle.x),      \\\n    dir.yz *= rot(viewAngle.y),      \\\n    dir )\n*/\n\n// 2D Weyl hash 32-bit XOR  - https://www.shadertoy.com/view/4dlcR4\n\n#define _W0 0x3504f335u   \n#define _W1 0x8fc1ecd5u  \n#define _W2 0xbb67ae85u\n#define _W3 0xf1bbcdcbu\n\n// 741103597u, 1597334677u, 204209821u, 851723965u  // MLCG constants\n#define _M0 741103597u    \n#define _M1 1597334677u\n#define _M2 204209821u\n#define _M3 851723965u\n\n#define _FSCALE 256.0f\n#define _FNORM (1.0f/16777216.0f/_FSCALE)\n\nuvec2 base_hash_2D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n\n  return( (n.x * uvec2(_M0, _M1)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nvec2 hash22(in vec2 xy)\n{\n\treturn vec2(base_hash_2D(uvec2(_FSCALE * xy))) * _FNORM;\n}\n\nvec2 V;\n#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n\n// begin soliton //\n#define size iResolution.xy\n#define SAMPLR(a, pos) texture((a), (pos)/size)\n#define AF iChannel0\n#define BF iChannel1\n//scales\n#define dt 0.28\n#define dx 0.5\n#define border 0.01\n//nonlinearity\n#define K 0.03\n\n\n//how charges interact (+ to -)\n#define polarity -1.\n//-1 is the correct one, but is sometimes unstable\n//-1 is + is attracted to -\n//1 is + is attracted to +\n\n//vacuum noise cancelling \n#define noise_cancl 0.002\n\n//distance between particles in the initial condition\n#define distance 120.\n\n#define charge_coupling .15\n#define interaction_field_frequency  0.07\n\nfloat FieldPotential(vec4 fval)\n{\n    float A = 2.*PI*length(fval.xy); //the complex field A module\n    float B = 2.*PI*length(fval.zw); //the complex field B module\n    return K*(cos(A) + polarity*charge_coupling*(cos(A)*cos(B) - cos(B))) // the long range interaction potential  and the particle core\n        \t- polarity*interaction_field_frequency*dot(fval.zw,fval.zw) ; // the mass of the interaction field, without this everything is unstable\n    //basically A is the core field of the particle\n\t//and B is the charge field that is coupled to A in such a way that if A = 0 then B is just a wave field\n    //or in other words this potential is = to 1, which is a constant thus the force is zero\n\t//that makes B behave like a long-range interaction field \n}\n\n\n    \n\nvec4 SpinnerU(vec2 pos)\n{\n    float d = dot(pos,pos)*dx*dx/20.;\n    float ampl = 0.5*exp(-d);\n    return vec4(ampl,0,0.15/(1. + 0.1*d),0);\n}\n\nvec4 SpinnerdUdt(vec2 pos)\n{\n    float d = dot(pos,pos)*dx*dx/20.;\n    float ampl = 0.5*exp(-dot(pos,pos)*dx*dx/10.);\n    return vec4(0,ampl,0,0.15/(1. + 0.1*d));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//the value of the field is iChannel1, time derivative is iChannel0\n#define eps (iTimeDelta * 2.0f) // 0.005\n\nvec4 FieldForce(vec4 fval)\n{\n    vec2 d = vec2(eps,  0.);\n    //numerical gradient of the field potential\n    return 0.5*vec4( FieldPotential(fval+d.xyyy)-FieldPotential(fval-d.xyyy),\n                 FieldPotential(fval+d.yxyy)-FieldPotential(fval-d.yxyy),\n                 FieldPotential(fval+d.yyxy)-FieldPotential(fval-d.yyxy),\n                 FieldPotential(fval+d.yyyx)-FieldPotential(fval-d.yyyx) )/eps;\n}\nvec4 Laplacian(sampler2D F, vec2 pos)\n{\n    vec4 a = SAMPLR(F, pos);\n\tvec4 x0 = SAMPLR(F, pos + vec2(-1,0));\n    vec4 x1 = SAMPLR(F, pos + vec2(1,0));\n    vec4 y0 = SAMPLR(F, pos + vec2(0,1));\n    vec4 y1 = SAMPLR(F, pos + vec2(0,-1));\n \n\treturn (x0+x1+y0+y1-4.f*a)/(dx*dx);\n}\n\nvoid mainImage( out vec4 dU_dt, in vec2 pos)\n{   \n    vec4 U = SAMPLR(BF, pos);\n    dU_dt = SAMPLR(AF, pos);\n    \n    dU_dt += dt*(Laplacian(BF, pos) + FieldForce(U)*vec4(1,1,polarity,polarity));\n    \n    //eraser\n    //if(iMouse.z>0.)\n    //    dU_dt *= 1.-0.4*exp(-pow(length(iMouse.xy-pos)/30.,2.));\n    \n    //initial conditions\n    if(iFrame <1) {\n        float charge = 2.*floor(mod((pos.y+pos.x + 0.5*distance)/distance,2.))  - 1.;\n    \tdU_dt = charge*SpinnerdUdt(mod(pos,vec2(distance,distance)) -0.5*vec2(distance,distance));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 U, in vec2 pos)\n{   \n    U = SAMPLR(BF, pos);\n    vec4 dU_dt = SAMPLR(AF, pos);\n    \n    U += dt*dU_dt;\n    \n    //mouse interaction\n    //if(iMouse.z>0.)\n       // U += SpinnerU(pos-iMouse.xy);\n    \n    //border conditions\n   // U *= 0.9+0.1*clamp(pos.x/size.x, 0., border)*clamp(pos.y/size.y, 0., border)/(border*border);\n   // U *=  0.9+0.1*clamp(1.-pos.x/size.x, 0., border)*clamp(1.-pos.y/size.y, 0., border)/(border*border);\n    \n    \n     //vacuum noise cancelling, also kills the particles after some time\n    {\n        float f_energy = dot(U,U) + dot(dU_dt,dU_dt);\n        if(f_energy < noise_cancl)\n        {\n            float k = (1.-0.001*f_energy/noise_cancl);\n            U *= k;\n        }\n    }\n    \n    //initial conditions\n    if(iFrame <1) {\n    \tU = SpinnerU(mod(pos,vec2(distance,distance)) -0.5*vec2(distance,distance));\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}