{"ver":"0.1","info":{"id":"7dVXRG","date":"1667355101","viewed":173,"name":"[phreax] observed","username":"phreax","description":"Modelling & Procedural texturing","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","proceduraltexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU PI*2.\n#define SQR2 1.4152135\n#define ISQR2 1./SQR2\n#define SIN(x) (sin(x)*.5+.5)\n//#define BUMPMAP\n\nfloat g_mat = 0.;\nfloat eyeAnim;\nfloat eyeMorph;\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 15.));\n}\n\nfloat rnd(float t) {\n\treturn fract(sin(t * 6974.685) * 347.542);\n}\n\nfloat curveRnd(float t, float d) {\n\tfloat g = t / d;\n\treturn mix(rnd(floor(g)), rnd(floor(g) + 1.0), pow(smoothstep(0.0, 1.0, fract(g)), 15.));\n}\n\nvec2 moda(vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\nfloat cylcap( vec2 p2, float p1, float r, float h )\n{\n  vec2 d = abs(vec2(length(p2),p1)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat tt;\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat substractRound(float a, float b, float r) \n{\n\tvec2 u = max(vec2(r + a,r - b), vec2(0));\n\treturn min(-r, max (a, -b)) + length(u);\n}\n\nfloat octah( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat axes(vec3 p) {\n    \n\tfloat xz = cylcap(p.xz, p.y, 4., .01);\n    float xy = cylcap(p.xy, p.z, 4., .01);\n    float yz = cylcap(p.yz, p.x, 4., .01);\n    return min(min(xz, xy), yz);\n}\n\nfloat sdEylidCut(vec3 p) {\n\n\n    p.y = abs(p.y*eyeAnim) + .5;\n    float d = length(p.xy) - 1.;\n    \n    return d;\n   // vec2 w = vec2( d, abs(p.z) - .5 );\n    //return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec2 eye(vec3 p) {\n\n    vec3 q = p;\n    q.x *= .8;\n    \n    float eyeBall = sph(p, .8);\n    float eyeLid = sph(q, 1.55);\n    \n    \n    float mat = 1.;\n    eyeLid = smax(-sph(p + vec3(0, 0, 1.2), .9), eyeLid, 2.);\n\n    eyeLid = smin(eyeLid, sph(q, .9), .09);\n\n   \n    eyeLid = smax(-sdEylidCut(p), eyeLid, .09);\n    mat = eyeLid < eyeBall ? 30. : 31.;\n    \n    float d = min(eyeLid, eyeBall);\n    \n    d = mix(d, length(p) - .8, eyeMorph);\n    \n    //d = min(d, axes(p));\n    return vec2(mat, d);\n}\n\nvoid transformEye(inout vec3 p, float size) {\n       p.y -= 1. + sin(eyeMorph);\n       p.z += 1.7;\n       p *= size;\n}\n\nfloat map(vec3 p) {\n\n\n   vec3 bp =p;\n   \n   float obj =100.;\n   \n   float flor;\n   float wall;\n   float eyed;\n   vec2 eyev;\n   {\n     //p.x += 1.;\n     //p.y += .1*sin(1.5*p.z)+(.0*sin(tt))*sin(1.6*p.x) + .2*sin(3.*p.y+tt);\n     flor = p.y + .5;\n   }\n   \n   {\n       p = bp;\n       p.x = abs(p.x) -1.5;\n       p.x += .2*sin(p.z) + .3*sin(3.*p.y+tt) + .1*sin(10.*p.y+tt);;\n       \n       wall = box(p, vec3(.2, 3, 1000));\n   }\n   \n   {\n       p = bp;\n       \n       float s = mix(3., 1000., eyeMorph);\n       transformEye(p, s);\n\n       eyev = eye(p);\n       eyed = eyev.y/s;\n   }\n   \n\n   if(flor < wall) {\n       g_mat = 0.;\n   } else {\n       g_mat = 1.;\n   }\n\n   float d = min(flor, wall);\n   \n   if(eyed < d) g_mat = eyev.x\n   ;\n \n   return min(d, eyed);\n}\n\n\nvec3 eyeTex(vec3 p) {\n    float s = mix(3., 5., eyeMorph);\n    transformEye(p, s); \n    \n    vec3 q = p;\n    p.xy += .2*vec2(sin(1.5*PI*curve(.8*tt, 1.)), 0.3*cos(2.*tt));\n    float r = length(p.xy) + 0.005;\n    vec3 col = vec3(.42);\n    float a = atan(p.y,p.x);\n    \n    float iris = 0.3;\n    iris = mix(0.3, iris, smoothstep(0.14, 0.25, r));\n    iris += iris*3.0*(1.0-smoothstep(0.0,1.0, abs((a+3.14159)-2.5) ));\n    iris *= 0.35+0.4*texture(iChannel0,vec2(-0.005*tt+r/8.,a/6.2831/1.3)).x;\n    \n    iris *= 1.5;\n\n    col += mix(.0, 1., smoothstep(0.33,0.334,r));\n    col += mix( 0., iris, 1.-smoothstep(0.3,0.33,r) );\n    col *= smoothstep(0.15,0.16,r);\n\n    col += 0.6*(1.-smoothstep(0.0, 0.04, length(p.xy-vec2(.16))));\n    \n    // fake occulusion\n    q.y = abs(q.y*eyeAnim) + .5;\n    float dc = length(q.xy) - 1.;\n    float focc = smoothstep(0.1, .2, abs(dc)+.14);\n    col *= focc;\n    return  mix(col, vec3(1), eyeMorph);\n}\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 stripesTex(vec2 uv, bool pole, float rows, float t) {\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    \n    uv *= uv.x;\n    uv *= rot(tt*.3);\n    uv.y -= .1*tt;\n\n    uv = fract(uv*rows);\n    \n    float aa = iResolution.y * 0.002 * 0.005*t; \n    col += smoothstep(.25 - aa, .25 + aa, length(uv.y-.5));\n\n    return col;\n}\n\n\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod( q.x+q.y, 2.0 );            // xor pattern\n}\n\nvec3 stripesTex2(vec2 uv, float t) {\n    vec3 col = vec3(0);\n   \n    uv.y += mod(.1*tt, 100.);\n    uv = fract((pow(uv*.4, vec2(1.0))))-.5;\n  \n    float aa = iResolution.y * 0.002 * 0.005*t; \n    \n    col += smoothstep(.5-aa, .5+aa, .5+.5*sin(100.*length(uv)-3.*tt));\n\n    return col;\n}\n\n\nfloat st;\n\nvoid cam(inout vec3 p, vec2 m) {\n    p.xz *= rot(PI/2.*m.x);\n    p.yz *= rot(PI/2.*m.y);\n}\n\nvec3 mapTexture(vec3 p, vec3 n, float t) {\n    \n    vec2 uv;\n  \n  \n    float x = abs(dot(n, vec3(1, 0, 0)));\n    float y = abs(dot(n, vec3(0, 1, 0)));\n    \n    //p.xy = abs(p.xy);\n    p.x += sin(.1*tt);\n      \n    //uv = mix(p.xz, p.yz, pow(x, 10.));\n    uv = (p.xz+p.yz)/2.;\n    return stripesTex2(uv, t);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tt = iTime;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 ro = vec3(0, .6, -5),\n         rd = normalize(vec3(uv,.7)),\n         lp = vec3(0., 4., -3),\n         lp2 = vec3(0., 1., -3);\n\n   // cam(ro, mouse);\n   // cam(rd, mouse+vec2(.5, 0.25));\n   // cam(lp, mouse+vec2(.5, 0.25));\n    \n    eyeAnim = 1.+29.*0.01/(1.-expImpulse(mod(tt, 3.), 3.));\n    \n    vec3 col = vec3(0);\n    float i, t, d = 0.1;\n\n    vec3 p = ro;\n    float mat = 0.;\n    \n    eyeMorph = SIN(.5*PI+PI*curve(tt, 2.));\n    \n    for(i=0.; i<150.; i++) {\n    \n        d = map(p);\n        mat = g_mat;\n        \n        if(d < 0.001 || t > 20.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    \n    vec3 lightKeyCol = vec3(1.000,0.996,0.922);\n    vec3 eyeLidCol = vec3(0.102,0.357,0.325);\n    vec3 baseCol = vec3(1);\n    if(d < 0.001) {\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        #ifdef BUMPMAP\n        if(mat == 0.) {\n          \n          n = doBumpMap( iChannel1,  vec3(p.xy+skinAnim, p.z), n, 0.04);\n        \n        }\n        #endif\n       \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n        \n        float difAmb2 =  max(dot(n, normalize(vec3(-lp.xy, lp.z)-p)), 0.);\n        col +=  baseCol*dif*lightKeyCol + .4*spe + 0.6*difAmb2*vec3(0.878,0.933,1.000);\n          \n        if(mat == 0. ) col *= stripesTex2(p.xz*.2, t);  // floor\n        if(mat == 1. ) col *= mapTexture(p, n, t);      // walls\n        if(mat >= 31.) col *= getGrey(eyeTex(p));       // eye\n        //col *= 1.1;\n    } else {\n    \tcol = vec3(.0);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}