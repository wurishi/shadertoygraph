{"ver":"0.1","info":{"id":"MtV3DD","date":"1474796464","viewed":243,"name":"LoD Calculation Demo","username":"soma_arc","description":"Calculate Level of Detail for perspective camera and primary ray. Red area is LOD = 0;\nReference: Tracing Ray Differentials by Homan Igehy http://graphics.stanford.edu/papers/trd/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","differentials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tCreated by soma_arc - 2016\n\tThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\nconst vec3 BLACK = vec3(0);\nconst float EPSILON = 0.001;\n\nconst vec2 TEXTURE_SIZE = vec2(512);\n\n\nvec4 intersectXZRect (vec2 minXZ, vec2 maxXZ,\n\t\t\t           float y, bool flip,\n                       vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float t = (y - rayOrigin.y) / rayDir.y;\n    if(EPSILON < t && t < isect.x){\n    \tvec3 p = rayOrigin + t * rayDir;\n        if(minXZ.x < p.x && p.x < maxXZ.x &&\n\t\t\tminXZ.y < p.z && p.z < maxXZ.y ){\n            if(flip){\n   \t        \treturn vec4(t, vec3(0, -1, 0));\n            }else{\n                return vec4(t, vec3(0, 1, 0));\n            }\n        }\n    }\n    return isect;\n}\n\nvec2 texCoordXZRect(vec2 minXZ, vec2 maxXZ, vec3 p){\n    vec2 size = maxXZ - minXZ;\n\treturn (p.xz - minXZ) / size; \n}\n\nvec3 getLodColor(int lod){\n    if(lod == 0)\n        return vec3(1, 0, 0);\n     else if(lod == 1)\n        return vec3(0, 1, 0);\n     else if(lod == 2)\n        return vec3(0, 0, 1);\n     else if(lod == 3)\n        return vec3(1, 1, 0);\n     else if(lod == 4)\n        return vec3(0, 1, 1);\n     else if(lod == 5)\n        return vec3(1, 0, 1);\n     return vec3(1, 1, 1);\n}\n\nvec3 calcColor(vec3 eye, vec3 ray, vec3 rayX, vec3 rayY){\n  vec4 result = vec4(99999.);\n\n  vec2 minXZ = vec2(-30);\n  vec2 maxXZ = vec2(30);\n  result = intersectXZRect(minXZ, maxXZ, 0., false, eye, ray, result);\n\n  vec3 matColor = vec3(1.);\n\n  if(result.x != 99999.){\n    vec3 intersection = eye + ray * result.x;\n    vec3 normal = result.yzw;\n\n    vec3 ddxPos = eye - rayX * dot(eye-intersection,\n                                    normal)/dot(rayX,normal);\n\tvec3 ddyPos = eye - rayY * dot(eye-intersection,\n                                     normal)/dot(rayY,normal);\n    vec2 uv = texCoordXZRect(minXZ, maxXZ, intersection);\n    vec2 uvX = texCoordXZRect(minXZ, maxXZ, ddxPos);\n    vec2 uvY = texCoordXZRect(minXZ, maxXZ, ddyPos);\n    vec2 dTx = (uvX - uv) * TEXTURE_SIZE;\n    vec2 dTy = (uvY - uv) * TEXTURE_SIZE;\n    float lod = clamp(log2(max(length(dTx), length(dTy))),\n                     0., 16.);\n    int iLod1 = int(lod);\n    int iLod2 = iLod1 + 1;\n    float fraction = fract(lod);\n    vec3 c1 = getLodColor(iLod1);\n    vec3 c2 = getLodColor(iLod2);\n    matColor = mix(c1, c2, fraction);\n \n    return matColor;\n  }\n  return BLACK;\n}\n\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n\t      (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n\t      (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n\t      const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 focalXAxis = normalize(cross(v, up));\n  vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 eye = vec3(50. + 10. * sin(iTime) , 20. + 20. * sin(iTime), 0.);\n\tvec3 up = vec3(0, 1, 0);\n\tfloat fov = radians(45.);\n\tvec3 target = vec3(0., 0., 0);\n    \n    vec2 coordOffset = vec2(0.5);\n    vec3 ray = calcRay(eye, target, up, fov,\n\t\t       iResolution.x, iResolution.y,\n\t\t       gl_FragCoord.xy + coordOffset);\n    vec3 rayX = calcRay(eye, target, up, fov,\n\t\t\tiResolution.x, iResolution.y,\n\t\t\tgl_FragCoord.xy + vec2(1, 0) + coordOffset);\n    vec3 rayY = calcRay(eye, target, up, fov,\n\t\t\tiResolution.x, iResolution.y,\n\t\t\tgl_FragCoord.xy + vec2(0, 1) + coordOffset);\n\n\n    fragColor = vec4(gammaCorrect(calcColor(eye, ray, rayX, rayY)), 1.);\n  \n}","name":"Image","description":"","type":"image"}]}