{"ver":"0.1","info":{"id":"lX3XWf","date":"1719674951","viewed":117,"name":"basic 3d editor","username":"jorge2017a2","description":"basic 3d editor\n//referencia https://iquilezles.org/\n//por jorge flores P.\n//basic 3d editor\n//29-jun-2024","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","basic","editor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//referencia https://iquilezles.org/\n//por jorge flores P.\n//basic 3d editor\n//29-jun-2024\n\n#define PI 3.14159265\n#define MAX_STEPS 45\n#define MAX_DIST 105.0\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nvec3 Arrcolores[] = vec3[](\n    vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0)\n);\n\nvec3 getColor(int i) {\n    return i > -1 ? Arrcolores[i] : vec3(0.0,0.0,0.0);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{ vec3 d = abs(p) - b;  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);}\n\n\nfloat Sdf_I(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Sdf_U(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Sdf_D(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{ float k0 = length(p/r);  float k1 = length(p/(r*r));  return k0*(k0-1.0)/k1;}\n\n\nvec2 ojoIzq(vec3 p, vec2 res, float dcabeza)\n{\nvec3 A;\nfloat r1;\nfloat dfin;\n\nA=vec3(0.27937,0.40992,0.0);\nr1=0.11488;\nfloat d1ci=sdSphere(p-A,r1);\nfloat d1cy=sdCylinderXY(p-A,vec2(r1, 2.0));\n\nA=vec3(0.27415,0.59791,0.0);\nr1=0.21149;\nfloat d2ci=sdSphere(p-A,r1);\nfloat d2cy=sdCylinderXY(p-A,vec2(r1, 0.5));\n\n//ojo\nfloat dfinci=Sdf_I(d1ci,d2ci);\nfloat dfincy=Sdf_I(d1cy,d2cy);\n\n//interseccion con cabeza\ndfincy=Sdf_I(dfincy,dcabeza);\ndfincy=Sdf_I(dfincy,dfinci);\n\nfloat dojo=dfincy;\nres = opU2(res, vec2(dfincy, 1.0));\n\n//pupila\nA=vec3(0.31332,0.45692,0.0);\nr1=0.06005;\n float d4cy=sdCylinderXY(p-A,vec2(r1, 2.0));\n dfin=Sdf_I(dojo,d4cy);\nres = opU2(res, vec2(dfin, 4.0));\n\n\n\n///iris\nA=vec3(0.3107,0.46997,0.0);\nr1=0.03133;\n float d3cy=sdCylinderXY(p-A,vec2(r1, 2.0));\ndfin=Sdf_I(dojo,d3cy);\nres = opU2(res, vec2(dfin, 2.0));\n   return res; \n}\n\n\nvec2 ojoDer(vec3 p, vec2 res, float dcabeza)\n{   \nvec3 A,B;\nvec2 med,pr;\nfloat dfin;\nfloat  r1 ;\n\n//ojo\nA=vec3(0.67102,0.62402,0.0);\nr1=0.21149;\nfloat d1ci=sdSphere(p-A,r1);\nfloat d1cy=sdCylinderXY(p-A,vec2(r1, 0.125));\n\nA=vec3(0.72063,0.40209,0.0);\nr1=0.14099;\nfloat d2ci=sdSphere(p-A,r1);\nfloat d2cy=sdCylinderXY(p-A,vec2(r1, 0.125));\n\nfloat dfinci=Sdf_I(d1ci,d2ci);\nfloat dfincy=Sdf_I(d1cy,d2cy);\n\n//interseccion con cabeza\ndfincy=Sdf_I(dfincy,dcabeza);\ndfincy=Sdf_I(dfincy,dfinci);\n\n\nfloat dojo=dfincy;\nres = opU2(res, vec2(dfincy, 1.0));\n\n\n\nA=vec3(0.70496,0.4752,0.0);\nmed=vec2(0.08355,0.06005);\n\n//pupila\nA=vec3(0.6893,0.48042,0.0);\nr1=0.06266;\nfloat d4ci=sdSphere(p-A,r1);\nfloat d4cy=sdCylinderXY(p-A,vec2(r1, 0.25));\n\n dfin=Sdf_I(dojo,d4cy);\nres = opU2(res, vec2(dfin, 4.0));\n\n//iris\nA=vec3(0.6893,0.48042,0.0);\nr1=0.03133;\nfloat d5ci=sdSphere(p-A,r1);\nfloat d5cy=sdCylinderXY(p-A,vec2(r1, 0.25));\n dfin=Sdf_I(dojo,d5cy);\n res = opU2(res, vec2(dfin, 2.0));\n    return res;\n}\n\n\nvec2 cabeza(vec3 p, vec2 res)\n{\nvec3 A,B;\nvec2 med,pr;\nfloat dfin;\nfloat  r1;\nA=vec3(0.49347,0.48825,0.5);\n\nmed=vec2(0.4712,0.46214);\nfloat d1= sdEllipsoid(p-A, vec3(med.x, med.y,0.5) );\nA=vec3(0.48042,0.59269,0.5);\nmed=vec2(0.4512,0.46214);\n\nfloat d2= sdEllipsoid(p-A, vec3(med.x, med.y,0.5) );\n \nvec3 pr2=rotate_x(p-vec3(0.5,0.12,0.305),radians(90.0));\nfloat d2a= sdHexPrism( pr2, vec2(0.25,0.12) );\n dfin=smin(d1,d2,0.015);\n dfin=smin(dfin, d2a,0.05);\n res = opU2(res, vec2(dfin, 2.0));\n    return res;\n}\n\nvec2 nariz(vec3 p, vec2 res)\n{\nvec3 A,B;\nvec2 med,pr;\nfloat dfin;\nfloat  r1 ;\n\n\nfloat d0= sdBox(p-vec3(0.5,0.3,0.1), vec3(0.125,0.125,0.125));\nfloat r2,he;\nr1=0.02; r1=0.05;he=0.05;\n\nfloat d0a= sdCone( p-vec3(0.5,0.52,0.02), vec2(0.01,0.03), 0.25 );\n\nA=vec3(0.46475,0.25587,0.0);\nr1=0.01305;\nfloat d1=sdSphere(p-A,r1);\n\nA=vec3(0.52219,0.25587,0.0);\nr1=0.01305;\nfloat d2=sdSphere(p-A,r1);\n\nA=vec3(0.49347,0.33159,0.0);\nmed=vec2(0.02872,0.08355);\n\nfloat d3dos= sdEllipse(p.xy-A.xy,med);\n\ndfin=Sdf_I(d0,d3dos);\ndfin=Sdf_I(dfin,d0a);\n\ndfin= smin( dfin,d1, 0.008 );\ndfin= smin( dfin,d2, 0.008 );\nres = opU2(res, vec2(dfin,3.0));\n\n\nfloat d3=sdEllipsoid(p-A,vec3(med.x, med.y,0.015));\nA=vec3(0.49347,0.25849,0.0);\nmed=vec2(0.05222,0.0235);\n    return res;\n}\n\n\nvec2 boca(vec3 p, vec2 res)\n{\nvec3 A,B;\nvec2 med,pr;\nfloat dfin;\nfloat  r1 ;\n\nA=vec3(0.49608,0.16449,0.0);\nmed=vec2(0.05222,0.01044);\nfloat d1=sdEllipsoid(p-A,vec3(med.x, med.y,0.015));\nres = opU2(res, vec2(d1,2.0));\n\nA=vec3(0.49608,0.14099,0.0);\nmed=vec2(0.05222,0.01044);\nfloat d2=sdEllipsoid(p-A,vec3(med.x, med.y,0.015));\nres = opU2(res, vec2(d2,2.0));\n    return res;\n}\n\nvec2 mcabeza(vec3 p,vec2 res)\n{   res=cabeza(p,res);\n    float dhead=res.x;\n    res=ojoIzq(p,res ,dhead);\n    res=ojoDer(p,res, dhead);\n    res=nariz(p,res);\n    res=boca(p,res);\n    return res;\n}\n\nvec2 GetDist(vec3 p) {\n    vec2 res = vec2(9999.0, -1.0);\n    //p.y += 10.0;\n    \n    vec3 p1= rotate_x(p, radians(45.0));\n    vec3 p2= rotate_y(p, radians(90.0));\n     res= mcabeza(p-vec3(0.05,0.0, -1.0),res);\n     res= mcabeza(p1-vec3(1.25,0.0,-0.25),res);\n     res= mcabeza(p2-vec3(-1.2,0.0,0.0),res);\n    return res;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(GetDist(p - e.xyy).x, GetDist(p - e.yxy).x, GetDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps) {\n    vec3 p;\n    vec2 hit, object = vec2(0.1, 0.0);\n    for (int i = 0; i <= PMaxSteps; i++) {\n        p = ro + rd * object.x;\n        hit = GetDist(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec3 lighting(vec3 normal, vec3 p, vec3 lightPos, vec3 lightColor, vec3 rd, vec3 ro) {\n    vec3 L = normalize(lightPos - p);\n    float diff = max(dot(normal, L), 0.0);\n    vec3 diffuse = lightColor * diff;\n    return diffuse;\n}\n\nvec3 Render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 hit = RayMarch(ro, rd, MAX_STEPS);\n    if (hit.x < MAX_DIST) \n    {\n        p = ro + rd * hit.x;\n        vec3 nor = GetNormal(p);\n        vec3 colobj = getColor(int(hit.y));\n        vec3 r1,r2,r3,r4;\n        \n        r1 = lighting(nor, p, vec3(-10.0, 50.0, -15.0), vec3(1.0), rd, ro);\n        r2 = lighting(nor, p, vec3(0.0, -20.0, 20.0*sin(4.0)), vec3(1.0), rd, ro);\n        r3 = lighting(nor, p, vec3(10.0, 20.0, -20.0), vec3(1.0), rd, ro);\n        r4 = lighting(nor, p, vec3(0.0, 0.0, 10.0), vec3(1.0), rd, ro);\n        vec3 result=(r1+r2+r3+r4)/2.0;\n        \n        \n        col= result*colobj;\n     }\n    else\n    {\n        col=vec3(0.5);\n    }\n    return col;\n}\n\n\n//https://www.shadertoy.com/view/7dKfRt\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat3 cameraToWorld(vec3 ro,vec3 lookAt){\n    vec3 a = normalize(lookAt - ro);\n    vec3 b = cross(vec3(0.,1.,0),a);\n    vec3 c = cross(a,b);\n    return mat3(b,c,a);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{ vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{   vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n    vec3 ro = vec3(0.45, 0.35, -2.5);\n    //ro= getMouse(ro);  \n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = Render(ro, rd);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\n// exponential\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}","name":"Common","description":"","type":"common"}]}