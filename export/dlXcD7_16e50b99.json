{"ver":"0.1","info":{"id":"dlXcD7","date":"1691685377","viewed":96,"name":"fluid surface w/ fake trochoidal","username":"jolle","description":"2D fluids surface graph from sum of trochoidal looking waves","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sin","fluid","graph","trochoidal"],"hasliked":0,"parentid":"WttyWH","parentname":"Simple Graph Viewer"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat wave(float x)\n{\n    float v = -abs(sin(x));\n    v = v > -0.1 ? cos(v * 3.14159) - 1.05 : v; // Round of sharp top (optional)\n    v += 1.; // Move to positive\n    v = pow(v, 1.33); // Make a bit more dramatic/trochoidal (optional)\n    return (v - .33) * 1.5; // Center somewhat and scale\n}\n\n// List of waves as x, time, and magnitude scales\nvec3 waves[] = vec3[](\n    vec3(.5, 1, .5),\n    vec3(1.05, -1.9, .25),\n    vec3(2.83, -4.1, .125),\n    vec3(4.21, 6.3, .0625),\n    vec3(8.15, -8.4, .03125),\n    vec3(16.35, 16.5, .015625));\n\n// Graph 0, summed waves\nfloat f0(float x)\n{\n    float v = 0.;\n    for (int i = 0; i < waves.length(); ++i)\n        v += wave(x * waves[i].x + iTime * waves[i].y) * waves[i].z;\n    return v + 1.;\n}\nvec3 graph0Color = vec3(0.0, 0, 1);\n\n// Graph 1, cycle through individual waves\nfloat f1(float x)\n{\n    int i = int(iTime * .5) % waves.length();\n    return wave(x * waves[i].x + iTime * waves[i].y) * waves[i].z - 1.;\n}\nvec3 graph1Color = vec3(.75, 0, 0);\n\n// Below is just graph viewer\nvec2 viewportMin = vec2(-7.0, -4.);\nvec2 viewportMax = vec2(7.0, 4.);\n\nvec3 backgroundColor = vec3(1.0);\nvec3 gridColor = vec3(0.9);\nvec3 axisColor = vec3(0.25);\n\nfloat lineWidth = 1.5;\n\nfloat f(int i, float x)\n{\n    return i == 0 ? f0(x) : f1(x);\n}\n\nfloat sq(vec2 x)\n{\n    return dot(x, x);\n}\n\nvec2 getClosestPointOnGraph(vec2 p, float x0, float x1, int i)\n{\n    // Bin search (not Newtonâ€“Raphson because requires proper gradient)\n    for (int n = 0; n < 4; n++)\n    {\n        float d0 = sq(p - vec2(x0, f(i, x0)));\n        float d1 = sq(p - vec2(x1, f(i, x1)));\n        float mid = (x0 + x1) * 0.5;\n        if (d0 < d1)\n            x1 = mid;\n        else\n            x0 = mid;\n    }\n    // Get closest point on line for result\n    vec2 p0 = vec2(x0, f(i, x0));\n    vec2 p1 = vec2(x1, f(i, x1));\n    vec2 v = normalize(p1 - p0);\n    return p0 + v * dot(p - p0, v);\n}\n\nbool isClosestToZero(float x, float d)\n{\n    return abs(x) < abs(x - d) && abs(x) < abs(x + d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixelSize = (viewportMax - viewportMin) / iResolution.xy;\n    vec2 position = (fragCoord - 0.5) * pixelSize + viewportMin;\n\n    // Background\n    vec3 color = backgroundColor;\n\n    // Grid\n    vec2 gd = 1.0 - abs(0.5 - fract(position)) * 2.0;\n    if (isClosestToZero(gd.x, pixelSize.x * 2.0) ||\n        isClosestToZero(gd.y, pixelSize.y * 2.0))\n        color = gridColor;\n\n    // Axis notches\n    if (abs(position.y) < pixelSize.y * 2.5 && isClosestToZero(gd.x, pixelSize.x * 2.0) ||\n        abs(position.x) < pixelSize.x * 2.5 && isClosestToZero(gd.y, pixelSize.y * 2.0))\n        color = axisColor;\n\n    // Axis\n    if (isClosestToZero(position.x, pixelSize.x) || \n        isClosestToZero(position.y, pixelSize.y))\n        color = axisColor;\n\n    // Graph 0\n    vec2 p = getClosestPointOnGraph(position, position.x - pixelSize.x, position.x + pixelSize.x, 0);\n    float d = length((p - position) / pixelSize);\n    color = mix(color, graph0Color, clamp(lineWidth - d, 0.0, 1.0));\n\n    // Graph 1\n    p = getClosestPointOnGraph(position, position.x - pixelSize.x, position.x + pixelSize.x, 1);\n    d = length((p - position) / pixelSize);\n    color = mix(color, graph1Color, clamp(lineWidth - d, 0.0, 1.0));\n\n    fragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}