{"ver":"0.1","info":{"id":"XcjXRD","date":"1706703458","viewed":177,"name":"Still life (...not)","username":"_pwd_","description":"A still life not standing still.\n\nRendering glass, metal, reflections with raymarched springs, elogated torus and some other wobbly melting forms.","likes":10,"published":1,"flags":40,"usePreview":1,"tags":["3d","raymarching","reflection","raytracer","ray","refraction","raymarcher","glass","metal","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//\n//\n// Still life (...yet not standing still)\n//\n// A few weeks ago I saw this nice composition on Instagram - Roger Kilimanjaro:\n// https://www.instagram.com/p/CpfnUcVop-6/?img_index=2\n// \n// Well its far from being same same or even close, but I decided to tinker and doodle bit in the same direction.\n// Playing around with metal and glass and add kinda wobbly behaviours to it + I never ever added GPU-Sound here...\n// ...so it was perfect to fail on that one too. :) Thanks to \"athibaul\" and his great tutorial(s) on Youtube diving\n// into how to GPU-Sound with Shadertoy -> https://www.youtube.com/watch?v=9XeE0v5JLiQ&t=4s , this shader has some\n// blings, beeps and clonks which gave sort of sound atmosphere\n//\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT\n//\n//\n// Still counts as part of my diorama series...\n// Tiny Hideout -> https://www.shadertoy.com/view/DlKBDh\n// Return of the blob -> https://www.shadertoy.com/view/ctVBzt\n//\n//\n//\n//\n//\n//\n//\n// Related examples\n//\n// IQ´s article for sure\n// https://iquilezles.org/articles/distfunctions/\n//\n// FXAA Postpro taken from\n// https://www.shadertoy.com/view/mtScRc\n//\n// Athibaul´s low pass filtered saw\n// https://www.shadertoy.com/view/wsGyWm\n//  \n// Glass\n// https://www.shadertoy.com/view/msS3Dt\n//\n//\n\n\n\n\n\n\n\n// CC0: Inside the mandelbulb II\n//  Received some \"complaints\" about the old mandelbulb suffering from \n//  alias effects. So thought I make a quick try to apply the FXAA\n//  thing I learnt from XorDev. It did improve it but not perfect still.\n\n// When experimenting with this shader I realized this entire shader is \n// basically just a lucky bug (apart from the aliasing)\n\n#define RESOLUTION      iResolution\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n    // See this blog\n    // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n    // Maximum texel span\n    const float span_max    = 8.0;\n    // These are more technnical and probably don't need changing:\n    // Minimum \"dir\" reciprocal\n    const float reduce_min  = (1.0/128.0);\n    // Luma multiplier for \"dir\" reciprocal\n    const float reduce_mul  = (1.0/32.0);\n\n    const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n    // Sample center and 4 corners\n    vec3 rgbCC = texture(tex, uv).rgb;\n    vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n    vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n    vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n    vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n    //Get luma from the 5 samples\n    float lumaCC = dot(rgbCC, luma);\n    float luma00 = dot(rgb00, luma);\n    float luma10 = dot(rgb10, luma);\n    float luma01 = dot(rgb01, luma);\n    float luma11 = dot(rgb11, luma);\n\n    // Compute gradient from luma values\n    vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n    // Diminish dir length based on total luma\n    float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n    // Divide dir by the distance to nearest edge plus dirReduce\n    float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    // Multiply by reciprocal and limit to pixel span\n    dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n    // Average middle texels along dir line\n    vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n    // Average with outer texels along dir line\n    vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n    // Get lowest and highest luma values\n    float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n    float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n    // Get average luma\n    float lumaB = dot(B.rgb, luma);\n\n    //If the average is outside the luma range, using the middle average\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord/RESOLUTION.xy;\n    fragColor = fxaa(iChannel0, q, sqrt(1.0)/RESOLUTION.xy);\n\n    // vignette\n    fragColor.rgb *= clamp(pow(64. * q.x*q.y*(1.-q.x)*(1.-q.y), .12), 0., 1.);   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_RECURSION 8 // max ray bounces\n#define REFRACTION_IDX 1.5 // index of refraction\n\n\n// materials idx\n#define MAT_WOOD 0.\n#define MAT_BACKGROUND 1.\n#define MAT_GLASS 2.\n#define MAT_METAL 3.\n#define MAT_ENVREFL 4.\n#define MAT_GOLD 5.\n#define PI 3.14159265\n#define HALFPI 1.570796325\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// utility functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\n    mat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans * vec4(pos, 1.0));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\n    mat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans2 * vec4(pos, 1.0));\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float n) {\n    return fract(sin(n * 12.9898) * 43758.5453);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf blend & displace functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat displace(vec3 p) {\n    return ((cos(14. *p.z)*sin(14. * cos(iTime) * 0.5 *p.y)*sin(14.*p.z))*cos(130.1))*sin(iTime);\n}\n\nvec4 opElongate( in vec3 p, in vec3 h ) {    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n//HG\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat opSubtraction( float d1, float d2 ) { \n    return max(-d1,d2); \n}\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// basic sdf shapes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat rBox( vec3 p, vec3 b, float r ){\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n// Beware -> it´s a trap!!! Its not a sphere ´cause a \n// rounded box worked better on the displace-function \nfloat sdSphere( vec3 p, float s ) {\n   \n    p.y = p.y + sin(iTime) * 0.1;\n\n    vec3 q = rotateY(rotateX(p, iTime),iTime);\n    float d = displace(q);\n\n    return rBox(q,vec3(0.00005), .15) + d * 0.3;\n}\n\n// Beware -> this is a sphere now :)\nfloat sdSphere1( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Euclidean distance function (same as builtin length(p)?)\nfloat length2( vec2 p ) {\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// Non-Euclidean distance function, so the sphere \"length8(p) = k\" is more squarish.\nfloat length8( vec2 p ) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// A torus with a squarish minor cross section, using non-Euclidean distance function.\nfloat sdTorus82( vec3 p, vec2 t ) {\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// here goes the glass aka elongated torus\nfloat sdGlass(vec3 p) {\n    vec3 q = p - vec3(0.0,-0.54,0.0);\n    vec4 w = opElongate( q, vec3(0.001,0.25,0.025) );\n    return  w.w+sdTorus( w.xyz, vec2(0.27,0.027) );\n}\n\n// here goes the spring\nvec3 closestPointOnCylinder(vec3 p, vec2 dim) {\n    return vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n}\n\nfloat profileSphere(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat spring(vec3 p) {\n\n    vec3 p1 = p;\n    \n    p1.z -= 0.05;\n    //p1.z = p1.z * sin(iTime) * 0.2;\n\n    float radius = 0.19;\n    float height = 0.38 + sin(iTime) * 0.25 + 0.35; /*+ sin(iTime  * 0.5) * 0.25 + 0.35*/;\n    float coils = 4.0/(height/3.141);\n\n    vec3 pc = closestPointOnCylinder(p1, vec2(radius, height));\n\n    float distToCyl = distance(p1, pc);\n\tfloat distToCoil = asin(sin(p1.z*coils + 0.5*atan(p1.x,p1.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    return profileSphere(springCoords, 0.031);\n}\n\n\nfloat sdPyramid( in vec3 p, in float h ) {\n    float m2 = h*h + 0.25;\n\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.15;\n\t\n    vec3 q = vec3( p.z, h*p.y-0.5*p.x, h*p.x+0.5*p.y);\n        \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*q.x)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = max(-q.y,q.x*m2+q.y*0.5) < 0.0 ? 0.0 : min(a,b);\n    \n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// main sdf\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p) {\n    \n    vec2 d = vec2(10000.);\n    p.y += 0.4;\n   \n    // add plane\n    d = opU(d, vec2(p.y+.80+.0005*sin(9.*p.x)*sin(9.*p.z), MAT_BACKGROUND));\n\n    // add spring\n    vec3 q = p;\n    q.y -= -0.06 + sin(iTime) * 0.25;\n    vec3 springDomain = rotateX(q,HALFPI);\n    d = opU(d, vec2( spring(springDomain), MAT_METAL));\n    \n    // add glass\n    vec3 q1 = p;\n    float glass = sdGlass(q1)*0.75;\n    vec3 tp = vec3(0.0,-0.80 + sin(iTime * 0.5) * 0.8, 0.0);\n    glass = fOpUnionRound(glass,sdTorus82( (p-tp), vec2(0.33,0.05) ),0.015);\n    d = opU( d, vec2( glass, MAT_GLASS));\n   \n    // add wobbly sphere\n    d = opU(d, vec2(sdSphere(p-vec3(.0,.56,.0), .15), MAT_ENVREFL));\n\n    // add melting pyramid \n    q = p;\n    float rad = 0.09*(0.5-0.45*0.1);\n    float d2, d3;\n    d2 = 10000.0;\n    vec3 tempPos = p + vec3(0.0, -0.9, -0.15);\n    \n    for(int i = 0; i < 16; i++) {\n        vec3 pos1;\n        float ltime = iTime*0.09 + float(i)*20.134;\n\n        float r = rand(float(i)*1.33);\n        float y = 0.08+mod(ltime*(r + 0.5), 1.0);\n\n        pos1 = vec3(0.2*mod(float(i), 3.0) - 0.2, y, 0.210*floor(float(i)/12.0) - 0.48 + rand(float(i)) * 0.5);\n        d3 = sdSphere1(tempPos - pos1, 0.06);\n        if (d3 < d2) {\n            d2 = d3;\n\n        }         \n    }    \n \n    d2 += sin(30.*p.x)*sin(30.*p.y)*sin(30.*p.z) * 0.01;  \n    float pyramid = sdPyramid(q - vec3(0.0, 0.82, 0.0), .87) -rad/*- edgeDist * 0.01*/;\n    pyramid = fOpUnionRound(pyramid,d2,0.115);\n    \n    d = opU(d, vec2(pyramid, MAT_GOLD));\n\n    return d;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching loop\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float s = sign(map(ro).x); // inside and outside the surface\n    \n    for (int i=0; i<256 && t<16.; i++) {\n        vec3 p = ro + rd*t;\n        vec2 h = map(p);\n        h.x *= s;\n        if (abs(h.x)<.0001*t) return vec2(t,h.y);\n        t += h.x;\n    }\n    return vec2(t,-1);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// calculate normals https://iquilezles.org/articles/normalsSDF\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// calculate glass-ao\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat calcGlassAO(vec3 p, vec3 n, float k) {\n    float res = clamp(.5+.5*map(p+n*k).x/k,0.,1.);\n    return res;  \n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// calculate ao\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat calcAO(vec3 p, vec3 n, float k) {\n\n    \n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  n * hr + p;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );     \n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching softshadows (https://iquilezles.org/articles/rmshadows)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=.01; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p).x*2.;\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// set: sky-texture\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 skyTex(vec3 rd) {\n    vec3 col = pow(texture(iChannel1, rd).rgb,vec3(2.));\n    return col+2.*pow(col,vec3(3.));\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    //return p*p; // Rough sRGB to RGB.\n    p = p*sqrt(p);\n    return smoothstep(0., 1., p*1.35); // Fake color enhancing. Just for this example.\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// set: background\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 background(vec3 p, vec3 n, vec3 rd) {\n    vec3 r = reflect(rd, n);\n    \n    float occ = .5+.5*calcAO(p, n, .1);\n    occ = occ*occ*(3.-2.*occ);\n    float ref = shadow(p, r, 8., 24.); // reflection (specular)\n    \n    vec3 col = vec3(0.60, 0.57, 0.80 );\n    col += (.3+.7*skyTex(r))*.1*ref; // skybox reflection\n    col *= occ;\n        \n    return col;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// pathtracing function\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 pathtrace(vec3 ro, vec3 rd, bool ref) {\n    vec3 col = vec3(1);\n    \n    for (int i=0; i<MAX_RECURSION; i++) { // ray bounces\n        vec2 tmat = intersect(ro, rd);\n        float t = tmat.x; // distance\n        float mat = tmat.y; // material\n        if (t<16.) {\n            vec3 p = ro + rd*t;\n            vec3 n = calcNormal(p);\n\n            if (mat==MAT_GLASS) {\n                if (ref) {\n                    ro = p+n*.005;\n                    rd = reflect(rd, n);\n                } else {\n                    // refraction\n                    float fre = dot(rd, n);\n                    float s = sign(fre);\n                    vec3 m = -n*s;\n                    float ior = REFRACTION_IDX;\n                    float v = (.5-.5*s)/ior+ior*(.5+.5*s);\n\n                    ro = p-m*.005;\n                    rd = refract(rd, m, v);\n                }\n            } else if (mat==MAT_METAL){\n                // reflection\n                ro = p+n;\n                rd = reflect(rd, n);\n            } else if (mat==MAT_ENVREFL){\n                // reflection\n                ro = p+n;\n                rd = reflect(rd, n);                \n            } else if (mat==MAT_BACKGROUND){\n                col *= background(p, n, rd);\n                return col;\n            }\n        } else {\n            break;\n        }\n    }\n    \n    return col*skyTex(rd);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Compact, self-contained version of IQ's 3D value noise function.\n// from Shane´s: https://www.shadertoy.com/view/ltySRt\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nvec3 eMap(vec3 rd, vec3 sn){\n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.15;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// rendering function\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.60, 0.57, 0.80 );\n    \n    vec2 tmat = intersect(ro, rd);\n    float t = tmat.x; // distance\n    float mat = tmat.y; // material\n    vec3 l;\n    if (t<16.) {\n        vec3 p = ro + rd*t;\n        l -= p;\n        vec3 n = calcNormal(p);\n        vec3 r = reflect(rd, n); // reflected ray\n        \n        // lighting and coloring\n        vec3 refl = pathtrace(ro, rd, true); // reflected color\n        vec3 refr = pathtrace(ro, rd, false); // refracted color\n        \n        // ambient occlusion\n        float occ = .4+.6*calcAO(p, n, .1);\n        occ = occ*occ*(3.-2.*occ);\n        \n        float occ1 = .4+.6*calcGlassAO(p, n, .1);\n        occ1 = occ1*occ1*(3.-2.*occ);\n        \n        // glass\n        if (mat==MAT_GLASS) {\n            // schlick aproximation\n            float fre = 1.+dot(rd, n);\n            float r0 = (1.-REFRACTION_IDX)/(1.+REFRACTION_IDX);\n            r0 = r0*r0;\n            float schlick = r0 + (1.-r0)*pow(fre, 5.);\n            col = mix(refr, refl, schlick) * vec3(1.0,1.0,0.5); // blending the reflected ray with the refracted ray\n            col *= occ1;\n        // metal\n        } else if (mat==MAT_METAL){\n            vec3 final_col = vec3(0.06, 0.00, 0.25);\n            vec3 col_metal = mix( final_col, refr, 0.5);\n            vec3 oCol = tex3D(iChannel0, p, n);\n            col = mix( oCol , refl, 0.5);\n            col *= sqrt(occ);\n        // gold (sort-of)\n        } else if (mat==MAT_GOLD) {\n            col = vec3(0.03, 0.27, 0.55);\n            float ndotl = abs(dot( -rd, n ));\n            float rim = pow(1.0-ndotl, 6.0);\n            col = tex3D(iChannel0, p, n);\n            col = mix( col, vec3(1., .7, .4), rim+0.5 );\n            vec3 envRefl = texture(iChannel1, vec3(r.x, r.y, r.z)).rgb;\n            col += 0.65 * envRefl;\n            col += rim;\n            col *= sqrt(occ);\n        // background\n        } else if (mat==MAT_BACKGROUND) {\n           col = background(p, n, rd);\n        // reflected environment\n        } else if (mat==MAT_ENVREFL) {\n           col = vec3(0.03, 0.27, 0.55);\n           vec3 envRefl = texture(iChannel2, vec3(r.x, r.y, r.z)).rgb;\n           col += 0.65 * envRefl;\n           // diffuse\n           float diff = max(dot(l, n), 0.);\n           // specular\n           float spec = pow(max(dot(reflect(l, n), rd), 0.), 6.);\n           vec3 tx = tex3D(iChannel3, p, n);\n           // Applying the lighting.\n           vec3 sCol = tx*(diff + .5) + vec3(1, .6, .2)*spec*3.;\n           col += 0.25 * sCol;\n           col += ((col) * eMap(reflect(rd, n), n) * 3.5) * 0.2;    \n           col *= occ;\n        }\n    }\n    \n    return col;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// camera matrix\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    vec2 uv = 1.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n  \n    vec3 ro = vec3(0,1.5,-3.5); // ray origin\n    ro.xz *= rot(-.2*iTime * 0.5+3.141592*m.x-.7); // ray origin rotation\n    vec3 ta = vec3(0,-.2,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.6)); // ray direction\n\n    vec3 col = render(ro, rd);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define TWOPI (2.*3.1415926)\n#define bpm 100.\n#define beatdur (60./bpm)\n#define N(nn) 440.*exp2(((nn)-9.)/12.)\n#define emix(a, b, x) exp(mix(log(a), log(b), x))\n#define exprange(x, a, b) emix(a, b, 0.5+0.5*x)\n\n\n// ========== BASS ==========\n\nfloat filteredSaw(float f, float fc, float t)\n{\n    // f frequency\n    // fc cutoff frequency\n    // t time\n    float x = f*t;\n    float w = 0.5*f/fc;\n    w = min(w, 0.5);\n    x -= round(x);\n    return mix(-2.*x-1., -2.*x+1., smoothstep(-w, w, x));\n}\n\nvec2 bassSynth(float f, float t)\n{\n    // Classic 80's \"saw stab\" bass\n    vec2 sig = vec2(0);\n    float fc = 15000.*exp(-80.*t) +100.; // cutoff envelope of the sub\n    float fc2 = 15000.*exp(-40.*t) +100.; // cutoff envelope of the higher components\n    //float fc = 5000.;\n    sig += 0.1*filteredSaw(f/2., fc, t); // filtered sub-oscillator\n    sig += 0.05*sin(TWOPI*fract(f/2.*t)); // some more sub\n    sig += 0.1*filteredSaw(f+1.618, fc2, t+1.) * vec2(1.,0.2); // higher components\n    sig += 0.1*filteredSaw(f-1., fc2, t+1.7) * vec2(0.2,1.); // with stereo + detuning\n    return sig;\n}\n\nvec2 bassSynthPattern(float t)\n{\n    // Classic 80's bass pattern: just play eighth notes!\n    t = max(t, 0.);\n    t = mod(t, 16.*beatdur);\n    float nn = \n        (t < 4.*beatdur) ?-3. :\n        (t < 8.*beatdur) ? 2. :\n        (t < 12.*beatdur) ? 5. :\n        (t < 14.*beatdur) ? 0. :\n                            -5.;\n    float f = N(nn)/2.;\n    t = mod(t, 0.5*beatdur);\n    return bassSynth(f, t);\n}\n\n\n\n#define wave lpfSaw3\n\nfloat lpfSaw3(float t, float f, float fc, float Q) {\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    float omega_c = 1.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\nvec2 mainSound( in int samp, float time ) {\n    vec2 snd = vec2(0);\n    float pumping = smoothstep(0.,0.2,mod(time,beatdur)) * smoothstep(beatdur, beatdur-0.01, mod(time,beatdur));\n\n    vec2 bass;\n    bass += bassSynthPattern(time) * mix(pumping, 1.2, 0.2);\n    \n    \n    vec2 f = vec2(35., 35.2);\n    vec2 cutoff = exprange(asin(cos(time)), vec2(100., 200.), vec2(2000., 3000.));\n    vec2 Q = exprange(sin(10.52*time), 5., 50.) * vec2(.1,0.5);\n    // We can switch between the three versions of lpfSaw.\n    // In comparison with the first two approximate versions,\n    // the exact version exhibits stronger\n    // resonance on the first few harmonics when using a high quality factor,\n    // whereas lpfSaw2 smoothes them out (and lpfSaw even more).\n    return vec2(0.03) * vec2(\n        wave(time, f.x, cutoff.x, Q.x),\n        wave(time, f.y, cutoff.y, Q.y)\n    ) + bass * 0.7;\n}","name":"Sound","description":"","type":"sound"}]}