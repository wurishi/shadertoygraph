{"ver":"0.1","info":{"id":"ssGGRd","date":"1631944287","viewed":112,"name":"Anime Water 1","username":"HaleyHalcyon","description":"a","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\nconst int permutation[256] = int[]( \n44,\n157,\n6,\n193,\n149,\n195,\n168,\n24,\n227,\n224,\n12,\n240,\n91,\n50,\n27,\n101,\n86,\n39,\n150,\n58,\n114,\n18,\n203,\n69,\n53,\n245,\n13,\n110,\n16,\n189,\n219,\n134,\n54,\n56,\n35,\n7,\n71,\n76,\n242,\n68,\n237,\n0,\n154,\n236,\n226,\n204,\n14,\n231,\n23,\n67,\n216,\n126,\n100,\n59,\n1,\n38,\n167,\n194,\n243,\n255,\n235,\n22,\n133,\n225,\n117,\n109,\n45,\n173,\n246,\n89,\n205,\n108,\n140,\n186,\n52,\n120,\n49,\n181,\n5,\n9,\n85,\n73,\n153,\n84,\n98,\n143,\n161,\n218,\n66,\n63,\n78,\n28,\n170,\n94,\n184,\n230,\n92,\n221,\n228,\n31,\n131,\n174,\n115,\n87,\n47,\n199,\n223,\n190,\n248,\n175,\n2,\n138,\n142,\n137,\n217,\n166,\n40,\n95,\n151,\n141,\n111,\n80,\n104,\n214,\n252,\n220,\n212,\n75,\n90,\n172,\n197,\n127,\n164,\n232,\n21,\n253,\n17,\n88,\n156,\n207,\n165,\n125,\n102,\n182,\n145,\n147,\n206,\n105,\n26,\n124,\n82,\n229,\n169,\n179,\n196,\n30,\n215,\n99,\n60,\n96,\n191,\n72,\n25,\n213,\n148,\n159,\n160,\n128,\n136,\n208,\n139,\n43,\n83,\n130,\n211,\n249,\n163,\n113,\n70,\n250,\n4,\n183,\n32,\n36,\n178,\n188,\n247,\n77,\n10,\n93,\n20,\n135,\n187,\n238,\n180,\n152,\n65,\n55,\n29,\n62,\n200,\n146,\n144,\n33,\n251,\n48,\n176,\n64,\n107,\n34,\n8,\n201,\n3,\n42,\n119,\n210,\n103,\n41,\n79,\n233,\n106,\n254,\n11,\n222,\n209,\n171,\n46,\n234,\n118,\n81,\n37,\n162,\n61,\n177,\n132,\n202,\n244,\n116,\n123,\n158,\n122,\n192,\n155,\n121,\n51,\n74,\n15,\n57,\n198,\n97,\n239,\n129,\n185,\n112,\n241,\n19);\nint rand(int x) {\n    return permutation[x & 255];\n}\nfloat randxy(vec2 xy, float t) {\n    return float(\n    rand(\n      rand(\n        rand(\n          int(floor(xy.x))\n        ) + int(floor(xy.y))\n      ) + int(floor(t))\n    )\n    ) / 255.0;\n}\n//  0   8   2  10\n// 12   4  14   6\n//  3  11   1   9\n// 15   7  13   5\n\n// 0000 1000 0010 1010\n// 1100 0100 1110 0110\n// 0011 1011 0001 1001\n// 1111 0111 1101 0101\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return float(\n        1 +\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    )/ 16.;\n}\n\nvec3 ease(vec3 t) {\n    t = clamp(t, 0., 1.);\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 posterize(vec3 col, float thres) {\nconst float steps = 2.;\n    return (floor(\n        col * steps\n    ) + step(\n        vec3(thres), fract(col * steps)\n    )) / steps;\n}\n\nfloat ease(float t) {\n    t = clamp(t, 0., 1.);\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat zigzag(float t) {\n    return 1. - abs(1. - fract(t) * 2.);\n}\n\nfloat ripple(vec2 uv, vec2 lightDir, float scale, float time) {\n    \n    return ease(zigzag(\n        length(uv) * scale - time\n    )) * 0.5 * dot(\n        lightDir,\n        normalize(uv) *\n        ease(length(uv) * scale * 0.25)\n    );\n}\n\nvec2 angleVec(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\n// does pseudo overexposure filter\nvec3 deepfry(vec3 rgb, float x) {\n    rgb *= x;\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime /4.);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    float lightAngle = 1.7 + 0.45 * sin(2. * uv.x * TAU);\n    const float centerSep = 0.1;\n    const float centerSpeed = -0.;\n    float centerOfs = 2.5;\n    vec2 center0 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time));\n    vec2 center1 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time+1./3.));\n    vec2 center2 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time-1./3.));\n    \n    const float sizeScale = 8.;\n    const float timeScale = 7.;\n    \n    uv += ripple(\n            uv, angleVec(lightAngle),\n            sizeScale, 0. + time * timeScale\n        ) * vec2(0.05, 0.2) * length(uv);\n    \n    //uv.x += 0.02 * sin(uv.y * 150.5 + time * 7. * TAU);\n    //uv.y += 0.002 * sin(uv.x * 14.7 + time * 11. * TAU + 0.2);\n   \n    float colorSep = 0.1;\n    vec3 col = vec3(0);\n    col +=\n        ripple(\n            uv - center0, angleVec(lightAngle + colorSep),\n            sizeScale, time * timeScale\n        ) * vec3(0.5,0.5,-1);\n    col +=\n        ripple(\n            uv - center1, angleVec(lightAngle),\n            sizeScale, time * timeScale\n        ) * vec3(-1,0.5,0.5);\n    col +=\n        ripple(\n            uv - center2, angleVec(lightAngle - colorSep),\n            sizeScale, time * timeScale\n        ) * vec3(0.5,-1,0.5);\n    // normalize luminance\n    //col -= vec3(col.r * 0.3 + col.g * 0.59 + col.b * 0.11);    \n    /*col +=\n        ripple(\n            uv, angleVec(lightAngle),\n            sizeScale, 0. + time * timeScale\n        ) * vec3(0.5);//*/\n    col = posterize(\n        col * 1.3 + 0.5,\n        crosshatch(fragCoord + mod(iTime * 50., 2.) * vec2(1, 2))\n        //randxy(fragCoord, (60. * iTime))\n    );\n    col = vec3(0.6,0.76,0.8) + (col - 0.5) * vec3(0.3, 0.3, 0.3);\n    // overexpose\n    //col = deepfry(col, 1.2);\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}","name":"Image","description":"","type":"image"}]}