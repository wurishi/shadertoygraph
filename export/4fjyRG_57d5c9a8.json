{"ver":"0.1","info":{"id":"4fjyRG","date":"1722777705","viewed":72,"name":"Zero Gravitas Asm24 4k intro","username":"gimulnautti","description":"Shader source code for Assembly Summer '24 4k intro: Zero Gravitas\nFull windows source code with music available from https://github.com/gimulnautti/asm24-4k\nIdea based on old-school demoscene \"twister\" effect, where camera matrix changes by row","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["4k","mandelbox","boolean","composhader"],"hasliked":0,"parentid":"Mc2yDh","parentname":"Fork MandelTorus bloom asm24"},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//mat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\n//mat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\n//mat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n#define px (vec2(7.) / iResolution.xy)\n\nvec4 GetBloom ( in vec2 uv )\n{\n\tfloat numSamples = 1.;\n    vec4 color = vec4(0.);\n\n\tfor (float x = -5.; x <= 5.; x += 1.)\n\t{\n\t\tfor (float y = -5.; y <= 5.; y += 1.)\n\t\t{\n\t\t\tvec4 addColor = texture(iChannel0, uv + (vec2(x, y) * px));\n\t\t\tif (max(addColor.r, max(addColor.g, addColor.b)) > .8)\n\t\t\t{\n\t\t\t\tfloat dist = length(vec2(x,y))+1.;\n\n\t\t\t\tvec4 glowColor = max((addColor * 128.) / pow(dist, 2.), vec4(0.));\n\n                if (max(glowColor.r, max(glowColor.g, glowColor.b)) > .9)\n\t\t\t\t{\n\t\t\t\t\tcolor += glowColor;\n\t\t\t\t\tnumSamples += 1.;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    \n\treturn color / numSamples;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 box = texture(iChannel0, uv);\n    fragColor = box + .05 * GetBloom(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// nice times 2223\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\nvec3 mandelboxPosition;\n\n#define BPM 119.\n#define BPS (60. / BPM)\n#define DEL -0.05\n#define TT iTime - DEL\n\nfloat revsaw(float beats)\n{\n    float wavel = BPS * beats;\n    return smoothstep(0., 1., 1. - mod(TT, wavel) / wavel);\n}\n\nfloat square(float beats)\n{\n    float wavel = BPS * beats;\n    return (mod(TT, wavel) / wavel) < .5 ? 0. : 1.;\n}\n\nfloat beatstep(float beats)\n{\n    float wavel = BPS * beats;\n    return (TT) < wavel ? 0. : 1.;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 repeat(in vec3 pos, in vec3 s)\n{\n    return pos - s*round(pos / s);\n}\n\nfloat opUnion(in float d1, in float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSubtraction(in float d1, in float d2)\n{\n    return max(d1,-d2);\n}\n\n//http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    //float minRadius2 = 0.;\n    float fixedRadius2 = 1.7;\n\n\n    float r2 = dot(z,z);\n    if (r2<fixedRadius2) { \n      // this is the actual sphere inversion\n      float temp =(fixedRadius2/r2);\n      z *= temp;\n      dz*= temp;\n    }\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n    float boxSize = 1.;\n    z = clamp(z, -boxSize, boxSize) * 2. - z;\n}\n\n//http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nfloat mandelbox_de(vec3 z)\n  {\n    if (beatstep(138.) > .9 && beatstep(160.) < .9)\n        return 10000.;\n  \n    mandelboxPosition = z;\n\n    //Change for different look\n    float Scale = -0.85 - sin(iTime * .002) * .45;\n\n    vec3 offset = z;\n    float dr = 20.;\n    for (int n = 0; n < 13; n++) {\n      boxFold(z,dr);       // Reflect\n      sphereFold(z,dr);    // Sphere Inversion\n\n      z=Scale*z + offset;  // Scale & Translate\n      dr = dr*abs(Scale)+1.;\n    }\n    float r = length(z);\n    return r/abs(dr);\n}\n\nfloat sailing_boxes(in vec3 pos)\n{\n    if ((beatstep(124.) > .9 && beatstep(160.) < .9) ||\n        (beatstep(232.) > .9 && beatstep(240.) < .9) ||\n        (beatstep(256.) > .9 && beatstep(272.) < .9) ||\n        (beatstep(336.) > .9 && beatstep(376.) < .9) ||\n        (beatstep(336.) > .9 && beatstep(380.) < .9))\n    {\n        vec3 bPos = vec3(6., 0., 0.);\n        float rOfs = 6.28 / 10. + sin(iTime * .6) * .2;\n        float d = 10000.;\n        \n        for (float i=0.; i<3.; i+=1.)\n        {\n            for (float j=0.; j<10.; j+=1.)\n            {\n                vec3 layerSpace = pos - vec3(0., -2. + i * 2., 0.);\n                vec3 ringSpace = layerSpace - rotate_y(j * rOfs + iTime * .5) * bPos;\n                vec3 boxSpace = rotate_y(-rOfs) * ringSpace;\n                d = min(d, sdBox(boxSpace, vec3(.4)));\n            }\n        }\n        return d;\n    }\n    else\n    {\n        return 10000.;\n    }\n}\n\nfloat scene(in vec3 pos )\n{\n    vec3 s = vec3(6.0,5.0,6.0);\n    vec3 s2 = vec3(6.0,2.5,6.0);\n  \n    float d1 = mandelbox_de((pos + vec3(30., cos(iTime*0.0025) * 30., 1.)) * (sin(iTime* 0.025) + 1.5) * 0.025);\n    \n    float size1 = 6.0 + beatstep(140.) * 2.;\n    float size2 = 2.5 + beatstep(128.) * 3. - beatstep(140.) * 2.;\n    float d2 = sdTorus(pos, vec2(size1, size2));\n    d1 = opSubtraction(d1, d2);\n    \n    \n    float dd1 = sdSphere(repeat(pos + vec3(sin(iTime) * 1.6, 1.5, cos(iTime) * 1.6), s), 0.7);\n    d1 = min(d1, dd1);\n   \n   \n    vec3 rep2 = vec3(10.0,10.0,10.0);\n    vec3 bsize = vec3(6.,6.,2.) * (1.5 - square(32.) * .5);\n    vec3 boffset = vec3(0., 0., 5. * sin(iTime * .1));\n    \n    float d3 = sdBox(repeat(boffset + pos * rotate_x(iTime * 0.1), rep2), bsize);\n    float d = opSubtraction(d1, d3);\n    \n    d = min(d, sailing_boxes(pos));\n   \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.,-1.)*.5773;\n    const float eps = .0005;\n    return normalize( e.xyy*scene( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx*eps ) );\n}\n    \nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}    \n    \nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    float ao = 0.;\n    for( int i=0; i<9; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = n*l;\n\n        ao += (l - max(scene( p + rd ),0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao/9., .05, 1.);\n}\n\nvec3 stripes(vec3 pos)\n{\n    float stripe = sin(pos.x * 7.) * .4 + .6;\n    return vec3(1., stripe, stripe * .75);\n}    \n\nint numRibbons()\n{\n    return 4 + int(beatstep(128.)) * 3;\n}\n\nint numRibbonStacks()\n{\n    return 1 + int(beatstep(124.)) * 4 - int(beatstep(160.)) * 3;\n}\n\nfloat ribbonSpacing()\n{\n    return 6. - beatstep(124.) * 2.5;\n}\n\nfloat ribbonLength()\n{\n    return 4. + beatstep(120.) * 6.;\n}\n\nvec3 ribbonColor( float n )\n{\n    return vec3(mod(n, 7.) / 14., mod(n, 5.) / 5., .5 + mod(n, 3.) / 6.);\n}\n\nvec2 ribbonscene( vec3 p )\n{\n   float size = revsaw(1.) * .05 + .05 + beatstep(120.) * .05;\n   float d = 10000.;\n   float ld = d;\n   float ribbonStart = float(-numRibbons()) * ribbonSpacing() / 2. + 6.;\n   float n = 0.;\n   for (int i=0; i<numRibbons(); ++i)\n   {\n       float fi = float(i);\n       for (int j=0; j<numRibbonStacks(); ++j)\n       {\n           float fj = float(j+1);\n           d = min(d, sdBox(p + vec3(fj * ribbonSpacing() + 3. * sin(iTime * 0.2 * fj) + cos(p.z * .5), ribbonStart + ribbonSpacing() * fi + sin(p.z * .5), ribbonStart + fi * ribbonSpacing() * 2. * sin(iTime*.25*fj)), vec3(size, size, ribbonLength())));\n           if (d < ld)\n           {\n               n = float(numRibbonStacks()) * fj + fi;\n               ld = d;\n           }           \n       }\n   }\n   return vec2(d, n);\n}\n\nvec3 ribbons( in vec3 rd, in vec3 ro, in float boxDepth )\n{\n    // raymarch\n    const float tmax = 15.;\n    float t = 0.0;\n    vec3 pos;\n    float n = 0.;\n    for( int i=0; i<64; i++ )\n    {\n        pos = ro + t*rd;\n        vec2 ribbonResult = ribbonscene(pos);\n        float h = ribbonResult.x;\n        if( h<0.0001) {\n            n = ribbonResult.y;\n            break;\n        }\n        else if ( t > tmax)\n        {\n            break;\n        }\n        t += h;\n    }     \n    \n    // color\n    if(t<tmax && t < boxDepth)\n    {\n        return ribbonColor(n);\n    }\n    return vec3(0.);\n}    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position  \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera movement\t\n\tfloat an = 0.05*(iTime) + sin(iTime * 0.1) * p.y * sin(iTime * 0.05) * 2.;\n    an *= square(32.) * 2. - 1.;\n\tvec3 ro = vec3( 8.*cos(an), 0.6, 8.*sin(an));\n    vec3 ta = vec3( 0.0, sin(iTime * 0.5) * 1.0, 0.0 );\n    \n    //ro = vec3(-1.0,0.0,-1.9);\n    \n    // camera matrix\n    vec3 up = vec3(0.0,0.6,0.5);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, up) );\n    vec3 vv = normalize( cross(uu, ww) );\n      \n\t// create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // uv coordinates\n    //vec2 uv = vec2(0.0, 0.0);\n\n    // raymarch\n    const float tmax = 35.0;\n    float t = 0.0;\n    float ribsDist = 100000.0;\n    vec3 pos;\n    float n = 0.;\n    for( int i=0; i<128; i++ )\n    {\n        pos = ro + t*rd;\n        float h = scene(pos);\n        if( h<0.00015) {\n            vec2 ribResult = ribbonscene(pos);\n            ribsDist = ribResult.x;\n            n = ribResult.y;\n            break;\n        }\n        else if ( t > tmax)\n        {\n            break;\n        }\n        t += h;\n    }     \n    \n    // shading\n    vec3 col = vec3(0.0);\n    if( t<tmax )\n    {\n        vec3 nor = calcNormal(pos);\n        \n        float dif = clamp( dot(nor,vec3(0.7,1.2,0.4)), 0.0, 1.2 );\n        dif *= dif;\n        dif *= dif;\n        dif *= revsaw(16.);\n        \n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,-0.6));\n        amb *= revsaw(16.);\n        \n        col = ( vec3(0.2,0.3,0.5)*amb + stripes(mandelboxPosition)*vec3(0.9,0.8,0.6)*dif );    \n             \n        col *= ambientOcclusion(pos, nor, 2.5, 2.5);\n        \n        if ( ribsDist < 2. )\n        {\n            float f = (2. - ribsDist) / 2.;\n            col += f * f * f * ribbonColor(n) * (revsaw(1.) * .5 + .5);\n        }\n    \n        col /= max(1.0, pos.z * .5);\n    }\n\n    // gamma        \n    col = sqrt( col );\n\n    //grading\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\n    vec3 ribs = ribbons( rd, ro, t );\n\n\tfragColor = vec4( col, t ) + vec4(ribs, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}