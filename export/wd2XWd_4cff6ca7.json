{"ver":"0.1","info":{"id":"wd2XWd","date":"1555408046","viewed":126,"name":"Menger sponge maze","username":"edo_m18","description":"Menger sponge maze.\n\nThis post purpose a menger sponge maze analyzing.\nRefer to this post: https://www.shadertoy.com/view/ldyGWm","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///\n/// This post purpose a menger sponge maze analyzing.\n///\n/// Refer to this post: https://www.shadertoy.com/view/ldyGWm\n///\n\n#define FAR 40.\n\nfloat map(vec3 q)\n{   \n    // Layer one.\n \tfloat s = 3.0;\n    \n    vec3 p = abs(fract(q / s) * s - s * 0.5);\n    \n    // Cross distance function.\n    float a1 = max(p.x, p.y);\n    float a2 = max(p.y, p.z);\n    float a3 = max(p.x, p.z);\n    \n \tfloat d = min(a1, min(a2, a3)) - 1.0 + 0.05;\n    \n    float s2 = 1.0;\n    \n    // Layer two.\n    p = abs(fract(q / s2) * s2 - s2 * 0.5);\n    \n    float b1 = max(p.x, p.y);\n    float b2 = max(p.y, p.z);\n    float b3 = max(p.x, p.z);\n    float d2 = min(b1, min(b2, b3)) - 1.0 / 3.0 + 0.05;\n \td = max(d, d2);\n    \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    float s3 = 2.0;\n    p = abs(fract(q * s3) / s3 - (1.0 / s3 * 0.5));\n    \n    float c1 = max(p.x, p.y);\n    float c2 = max(p.y, p.z);\n    float c3 = max(p.x, p.z);\n    float d3 = min(c1, min(c2, c3)) - 0.5 / 3.0 - 0.015;\n \td = max(d, d3);\n\n    // Layer four. The little holes, for fine detailing.\n    float s4 = 3.0 / 0.5;\n    p =  abs(fract(q * s4) / s4 - (1.0 / s4 * 0.5));\n    \n    float e1 = max(p.x, p.y);\n    float e2 = max(p.y, p.z);\n    float e3 = max(p.x, p.z);\n    float d4 = min(e1, min(e2, e3)) - 1.0 / 18.0 - 0.015;    \n    d = max(d, d4);\n\n    return d;\n}\n\n// Very basic raymarching equation. Menger Sponge objects raymarch reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd)\n{    \n    float t = 0., d;\n    \n    for(int i = 0; i < 64; i++)\n    {        \n        d = map(ro + rd * t);\n        \n        if (d <.0025 * t || t>FAR) break;\n        \n        t += d;\n    } \n    \n    return t;\n}\n\nvec3 normal(in vec3 p)\n{\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Unit direction ray vector: Note the absence of a divide term. I came across this via a comment \n    // Shadertoy user \"Coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); // Normalizing below.\n    \n    // Barrel distortion. Looks interesting, but I like it because it fits more of the scene in.\n    // If you comment this out, make sure you normalize the line above.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(0, 1.57079632) + iTime / 4.0);\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\n    \n    // Ray origin, set off in the Z direction.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    \n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Scene hit, so do some lighting.\n    if(t < FAR)\n    {\n        vec3 sp = ro + rd * t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        col = sn;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}