{"ver":"0.1","info":{"id":"mlfyzj","date":"1690938273","viewed":94,"name":"Hex shaped radial progress bar","username":"VL","description":"someone's request.\nmethod : [url]https://www.desmos.com/calculator/ywn1f9irvp[/url]","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n#define PI 3.1415926535898\n#define DOUBLE_PI 6.2831853071796\n#define AA 1. / iResolution.y\n#define FLT_MAX 3.402823466e+38\n\nbool relative = false;\nfloat size = 225.;\nfloat roundness = 75.;\nfloat thickness = 10.;\nvec3 hexColor = vec3(0.35);\nvec3 cirColor = vec3(1., 0., 0.);\n\nbool angle_clockwise = true;\nfloat angle_rot = radians(180.);\nfloat angle_start = DOUBLE_PI * 1.;\nfloat angle_end = DOUBLE_PI;\n\n// source code for the sdHexagon: https://iquilezles.org/articles/distfunctions2d/\n// cos(PI / 6), sin(PI / 6), tan(PI / 6)\nconst vec3 k = vec3(-0.86602540378444, 0.5, 0.5773502691896);\nfloat sdHexagon(in vec2 uv, in float size)\n{\n    uv = abs(uv);\n    uv -= 2.0 * min(dot(k.xy, uv), 0.0) * k.xy;\n    uv -= vec2(clamp(uv.x, -k.z * size, k.z * size), size);\n    return length(uv) * sign(uv.y);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nvec2 rot2D(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    \n    return vec2(c * p.x + s * p.y, -s * p.x + c * p.y);\n}\n\nfloat lineCircle(float s, float r, float phi)\n{\n    float a = s - r;\n    float b = a * tan(PI / 6.);\n    float c = tan(PI / 2. + phi);\n    \n    float cc1 = c * c + 1.;\n    float acb = a * c - b;\n    \n    return (-acb + sqrt(acb * acb - cc1 * (a * a + b * b - r * r))) / sqrt(cc1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ar = iResolution.x / iResolution.y;\n   \n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= ar;\n    vec2 center = vec2(ar * .5, .5);\n    uv -= center;\n  \n    float scale_factor = (!relative) ? 1. / iResolution.y : 1.;\n    float s = scale_factor * size;\n    float r = scale_factor * roundness;\n    float t = scale_factor * thickness;\n    \n    r = mix(0., s, sin(iTime * .5) * .5 + .5);\n    \n    float hex = sdHexagon(uv , s - r) - r;  \n    hex = abs(hex + t) - t;       \n    \n    float progress = iTime * PI * 0.125;\n\n    float total_angle = mod(atan(uv.x , uv.y) + angle_rot, angle_end);\n    float to = cos(progress) * angle_end * .5 + angle_end * .5;\n    float angle = step(to, total_angle);\n    angle = (angle_clockwise) ? 1. - angle : angle;   \n    \n    int idx = int(to / (PI / 6.));\n    float phi = mod(to, PI / 6.);\n    phi = bool(idx & 1) ? PI / 6. - phi : phi;  \n    uv = rot2D(uv, -to);    \n    s -= t;\n    r -= t; \n    float y = phi> 0. ? -tan(PI / 2. + phi) * (s - r) * tan(PI / 6.) : FLT_MAX; \n    uv.y += s > y ? lineCircle(s, r, phi) : s / cos(phi);\n    \n    float circle = sdCircle(uv ,t+ sin(iTime*3.0)*t*0.5);\n    hex = max(hex, -circle);  \n    circle = abs(circle + t * 0.125) - t * 0.125;    \n    \n    vec3 col = vec3(0.);\n    col = mix(col, hexColor, smoothstep(fwidth(hex), 0., hex) * angle);\n    col = mix(col, cirColor, smoothstep(fwidth(circle), 0., circle));\n   \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}