{"ver":"0.1","info":{"id":"4f3fDX","date":"1733524786","viewed":68,"name":"Loupiotes","username":"Peregrine","description":"Livecoding during the Shader Royale online jam at Inercia 2024 demoparty.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","refraction","domainrepetition","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define EPSILON 0.001\n#define MAX_DIST 100.\n#define REPETITION 7.5\n\n#define AMBER vec3(1., .25, 0.)\n#define BLACK vec3(0.)\n\n#define ID_FILAMENT 1\n#define ID_CAP 2\n#define ID_WIRE 3\n#define ID_BULB 4\n\n#define min2(a, b) (a.x < b.x ? a : b)\n#define pos(x) ((x) * .5 + .5)\n#define rep(p, r) (mod(p + .5 * (r), r) - .5 * (r))\n#define repid(p, r) floor((p + .5 * (r))/(r))\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sat(x) clamp(x, 0., 1.)\n\n#define time iTime\n\nfloat hash11(float seed) {\n  return fract(sin(seed * 123.456) * 123.456);\n}\n\nfloat _seed;\nfloat rand(void) {\n  return hash11(_seed++);\n}\n\nfloat sd_sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// from iq\nfloat sd_capsule(vec3 p, float h, float r) {\n  p.y -= clamp(p.y, 0., h);\n  return length(p) - r;\n}\n\nfloat sd_cylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\n// from blackle\nfloat sd_spring(vec3 p, float r, float h, float n) {\n  vec2 base = normalize(p.xz) * r;\n  vec3 pc = vec3(base.x, clamp(p.y, -h/2., h/2.), base.y);\n  float d2cyl = distance(p, pc);\n  float d2coil = asin(sin(p.y * n + .5 * atan(p.x, p.z))) / n;\n  vec3 ps = vec3(d2cyl, d2coil, 0.);\n  return sd_sphere(ps, .01);\n}\n\n// signed hashes from Lygia library\nfloat shash21(in vec2 st) {\n  return -1. + 2. * fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 shash22(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec2 sd_lightbulb(vec3 p, vec2 id) {\n  vec2 di = vec2(MAX_DIST, -1.);\n  float rnd = shash21(id + vec2(5.));\n  vec2 rnd2 = shash22(id);\n  \n  p.y -= 5. * rnd;\n  p += .99 * vec3(rnd2.x * sin(time), 0., rnd2.y * cos(time));\n  \n  float radius = mix(.05, .25, abs(rnd));\n  float height = 1.5;\n  float coils = (2. + mod(floor(rnd2.y * 10.), 5.)) / (height / PI);\n  float filament = sd_spring(p, radius, height, coils);\n  di = min2(di, vec2(filament, float(ID_FILAMENT)));\n  \n  float cap = sd_cylinder(p - vec3(0., 1.1, 0.), .3, .3);\n  di = min2(di, vec2(cap, float(ID_CAP)));\n  \n  float wire = sd_capsule(p - vec3(0., 1.1, 0.), MAX_DIST, .05);\n  di = min2(di, vec2(wire, float(ID_WIRE)));\n  \n  float bulb = abs(sd_sphere(p, 1.)) - .01;\n  di = min2(di, vec2(bulb, float(ID_BULB)));\n  return di;\n}\n\nvec2 sd_scene(vec3 p, float hollow) {\n  vec2 di = vec2(MAX_DIST, -1.);\n  vec2 dr = vec2(REPETITION);\n  vec2 drid = repid(p.xz, dr);\n  p.xz = rep(p.xz, dr);\n  for (float j = -1.; j <= 1.; j++)\n    for (float i = -1.; i <= 1.; i++) {\n      vec2 cell = vec2(i, j);\n      vec3 pc = p;\n      pc.xz -= REPETITION * cell;\n      di = min2(di, sd_lightbulb(pc, drid + cell));\n    }\n  return vec2(di.x * hollow, di.y);\n}\n\nvec3 normal(vec3 p, float hollow) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * sd_scene(p + e.xyy, hollow).x +\n    e.yxy * sd_scene(p + e.yxy, hollow).x +\n    e.yyx * sd_scene(p + e.yyx, hollow).x +\n    e.xxx * sd_scene(p + e.xxx, hollow).x\n  );\n}\n\nstruct Raymarching {\n  bool hit;\n  vec3 rd, p, n, acc;\n  float td, id;\n};\n\nRaymarching march(vec3 ro, vec3 rd, float n_steps, float hollow) {\n  Raymarching r;\n  r.hit = false;\n  r.rd = rd;\n  r.p = ro;\n  r.td = 0.;\n  r.acc = vec3(0.);\n  \n  for (float i = 0.; i < n_steps && r.td < MAX_DIST; i++) {\n    vec2 di = sd_scene(r.p, hollow);\n    if (di.x < EPSILON) {\n      r.hit = true;\n      r.id = di.y;\n      r.n = normal(r.p, hollow);\n      break;\n    }\n    if (int(di.y) == ID_FILAMENT)\n      r.acc += AMBER * (1. - sat(di.x/.03))\n               * pos(sin(.5 * time)) \n               * 2. * texture(iChannel1, vec2(0.)).x;\n    r.p += di.x * rd;\n    r.td += di.x;\n  }\n  \n  return r;\n}\n\nvec3 shade(Raymarching r) {\n  vec3 lo = vec3(0.);\n  vec3 ld = normalize(lo - r.p);\n  \n  float fresnel = sat(1. - dot(-r.rd, r.n)),\n        diffuse = sat(dot(ld, r.n));\n  \n  // fake!\n  float specular;\n  for (float j = -1.; j <= 1.; j++)\n    for (float i = -1.; i <= 1.; i++) {\n      lo = REPETITION * vec3(i, 0., j);\n      ld = normalize(lo - r.p);\n      specular += pow(sat(dot(normalize(ld - r.rd), r.n)), 10000.);\n    }\n  \n  switch (int(r.id)) {\n    case ID_FILAMENT: return AMBER * (3. + r.acc);\n    case ID_CAP: return AMBER * (.5 * diffuse + .5 * specular);\n    case ID_WIRE: return vec3(.05) * (.5 * diffuse + .5 * specular);\n    case ID_BULB: return AMBER * (.025 * fresnel + .001 * diffuse + .5 * specular);\n    default: return BLACK;\n  }\n}\n\nvec3 raydir(vec2 uv, vec3 ro, vec3 rt) {\n  vec3 f = normalize(rt - ro),\n       r = cross(vec3(0., 1., 0.), f),\n       u = cross(f, r);\n  return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 offset_dof(vec3 ro, vec3 rd) {\n  vec3 r = normalize(cross(vec3(0., 1., 0.), rd)),\n       u = cross(rd, r);\n  float k = .005;\n  return ro + (rand() - .5) * k * r + (rand() - .5) * k * u;\n}\n\nvec3 render(vec2 uv) {\n  vec3 color = BLACK;\n  vec3 ro = 2. * vec3(sin(.2 * time), 0., cos(.2 * time));\n  ro = offset_dof(ro, normalize(-ro));\n  vec3 rd = raydir(uv, ro, vec3(0.));\n  \n  \n  Raymarching r = march(ro, rd, 128., 1.);\n  \n  if (r.hit) {\n    color = shade(r);\n    if (int(r.id) == ID_BULB) {\n      float ior = 1./1.5, hollow = -1.; // glass refractive index\n      for (int i = 1; i < 7; i++) {\n        ro = r.p - 2. * EPSILON * r.n;\n        rd = refract(rd, r.n, ior);\n        r = march(ro, rd, 64., hollow);\n        if (r.hit)\n          color += shade(r) / float(i);\n        if (i % 4 == 2)\n          color += r.acc;\n        ior = 1./ior;\n        hollow *= -1.;\n      }\n    }\n  }\n  \n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n  _seed = time + texture(iChannel0, uv).x;\n  vec3 color = render(uv);\n  color *= 1.75 - length(uv);\n  color = smoothstep(0., 1., color);\n  color = pow(color, vec3(1./2.2));\n  fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}