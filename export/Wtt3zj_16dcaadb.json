{"ver":"0.1","info":{"id":"Wtt3zj","date":"1576889240","viewed":794,"name":"3D Grid with movable camera","username":"jaszunio15","description":"I created this template for learning and testing purposes.\nUnity-like camera movement:\nWASDEQ + mouse click  - movement\nShift key - faster movement\nMouse - look around\nG - enable/disable grid\n\nLicense: CC BY 3.0\nJan Mróz (jaszunio15)","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["3d","test","grid","template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n/*\n\tAll code for grid and camera is in Buffer A and Common tabs. Here is just camera and grid usage with very simple raymarching. :)\n\n\tHow to use:\n\tiChannel0 - sampler with Buffer A\n\tgetCameraPositionFromBufferA(iChannel0) - returns camera coordinates in 3D space\n\tgetCameraRotationFromBufferA(iChannel0, iResolution.xy) - return rotation matrix for camera.\n\tisGridVisible(iChannel0) - returns true if grid is enabled, false - otherwise.\n\tgetGrid(rayOrigin, rayDirection) - returns the grid color (vec4).\n\n\n\tI made camera to move just like camera in the Unity editor:\n\tW A S D Q E keys - Camera movement\n\tShift key - Adds more speed to camera movement\n\tMouse - Look around\n\tG - enable/disable grid view\n*/\n\n#define CAMERA_FOV 1.1\n\n\nvec3 uvToCastPlane(vec2 uv)\n{\n \treturn vec3(uv.x, uv.y, CAMERA_FOV);   \n}\n\nfloat sphereSDF(vec3 coord, vec3 sphereCenter, float radius)\n{\n \treturn distance(coord, sphereCenter) - radius;\n}\n\nfloat objectSDF(vec3 coord)\n{\n\tfloat obj = sphereSDF(coord, vec3(0.0), 1.0);\n    obj = min(obj, sphereSDF(coord, vec3(-1.0, 2.0, 1.4), 0.5));\n    return obj;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 objectNormal(vec3 coord)\n{\n    float eps = 0.001;\n \tfloat v000 = objectSDF(coord);\n    float v100 = objectSDF(coord + vec3(eps, 0.0, 0.0));\n    float v010 = objectSDF(coord + vec3(0.0, eps, 0.0));\n    float v001 = objectSDF(coord + vec3(0.0, 0.0, eps));\n    \n    return normalize(vec3(v100 - v000, v010 - v000, v001 - v000));\n}\n\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n \tfor (int i = 0; i < 40; i++)\n    {\n     \tfloat sdf = objectSDF(rayOrigin);\n        rayOrigin += sdf * rayDirection * 0.8;\n    }\n    \n    return rayOrigin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    //Getting camera properties from buffer A\n    vec3 cameraPos = getCameraPositionFromBufferA(iChannel0);\n    mat3 cameraRotation = getCameraRotationFromBufferA(iChannel0, iResolution.xy);\n                            \n\t//Creating ray\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDirection = normalize(cameraRotation * uvToCastPlane(uv));\n    vec4 col = vec4(0.0);\n    \n    \n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection);\n    float sdf = objectSDF(hitPoint);\n    \n    bool isObject = sdf < 0.01;\n    if (isObject)\n    {\n        vec3 normal = objectNormal(hitPoint);\n        col.rgb += normal;\n    }\n    else\n    {\n        //Adding grid to the final image\n        bool gridVisibility = isGridVisible(iChannel0);\n        if (gridVisibility)\n        {\n            vec4 grid = getGrid(rayOrigin, rayDirection) * 0.3 + 0.1;\n            col += grid;\n        }\n    }\n\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_G 71\n#define KEY_SHIFT 16\n\n#define GET_KEY(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.1) ).x)\n#define GET_TOGGLE(k) (texture(iChannel0, vec2(float(k) / 256.0, 0.9) ).x)\n#define PI 3.1419\n\n#define MOVE_SPEED 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1) //Camera start position and rotation\n    {\n     \tif (fragCoord.x <= 2.0)\n        {\n            if (fragCoord.x < 1.0)\n            {\n\t\t\t\tfragColor = vec4(1.5, 1.1, -1.5, 0.0);\n            }\n            else fragColor = vec4(0.0);\n        }\n    }\n    else if (fragCoord.y < 1.0 && fragCoord.x <= 2.0)\n    {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n        \n        if (iMouse.x < 1.0 && iMouse.y < 1.0) mousePos = vec2(0.0); \n\n        float yaw = mousePos.x * PI * 4.0;\n        float pitch = mousePos.y * PI;\n\n        //Same matrix construction as in common tab\n        mat3 cameraRotation = mat3(cos(yaw), 0.0, -sin(yaw),\n                                0.0, 1.0, 0.0,\n                                sin(yaw), 0.0, cos(yaw)) *\n            \t\t\t\tmat3(1.0, 0.0, 0.0,\n                                  0.0, cos(pitch), -sin(pitch),\n                                  0.0, sin(pitch), cos(pitch));\n                            \n\n        vec3 forward = cameraRotation * vec3(0, 0, 1);\n        vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n        vec3 up = normalize(cross(forward, right));\n\n        float keyW = GET_KEY(KEY_W);\n        float keyA = GET_KEY(KEY_A);\n        float keyS = GET_KEY(KEY_S);\n        float keyD = GET_KEY(KEY_D);\n        float keyQ = GET_KEY(KEY_Q);\n        float keyE = GET_KEY(KEY_E);\n        float toggleG = GET_TOGGLE(KEY_G);\n        float keyShift = GET_KEY(KEY_SHIFT);\n        \n        if (fragCoord.x < 1.0)\n        {\n            float speedBoost = (1.0 + keyShift * 3.0);\n            vec3 cameraPos = texture(iChannel1, vec2(0.0, 0.0)).xyz;\n            cameraPos += forward * (keyW - keyS) * iTimeDelta * MOVE_SPEED * speedBoost;\n            cameraPos += right * (keyD - keyA) * iTimeDelta * MOVE_SPEED * speedBoost;\n            cameraPos += up * (keyE - keyQ) * iTimeDelta * MOVE_SPEED * speedBoost;\n            fragColor = vec4(cameraPos, toggleG);\n        }\n        else\n        {\n            vec2 cameraRotation = vec2(yaw, pitch);\n            fragColor = vec4(cameraRotation, 0.0, 0.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BASE_WIDTH 0.006\n#define AXIS_WIDTH 0.05\n\nfloat hash12(vec2 point)\n{\n    return fract(sin(dot(point, vec2(129.45658, 37.6323))) * 3178.2563);\n}\n\nvec3 getCameraPositionFromBufferA(sampler2D bufferA)\n{\n \treturn texture(bufferA, vec2(0.0, 0.0)).xyz;\n}\n\nmat3 getCameraRotationFromBufferA(sampler2D bufferA, vec2 resolution)\n{\n \t\n    vec2 cameraAngle = texture(bufferA, vec2(1.2, 0.0) / resolution.xy).xy;\n    \n    mat3 cameraRotation = mat3(cos(cameraAngle.x), 0.0, -sin(cameraAngle.x),\n                                0.0, 1.0, 0.0,\n                                sin(cameraAngle.x), 0.0, cos(cameraAngle.x)) *\n        \t\t\t\t  mat3(1.0, 0.0, 0.0,\n                                  0.0, cos(cameraAngle.y), -sin(cameraAngle.y),\n                                  0.0, sin(cameraAngle.y), cos(cameraAngle.y));\n    \n    return cameraRotation;\n}\n\nbool isGridVisible(sampler2D bufferA)\n{\n\treturn (1.0 - texture(bufferA, vec2(0.0, 0.0)).w) > 0.5;\n}\n\n//xy - plane uv, z - visibility, w - distance\nvec4 castXZPlane(vec3 rayOrigin, vec3 rayDirection)\n{\n    float mul = 1.0;\n    if (rayOrigin.y < 0.0) mul = -1.0;\n    \n    vec3 castRayOrigin = rayOrigin;\n \tfloat distToPlane = abs(castRayOrigin.y);\n    vec3 castRayDirection = rayDirection / rayDirection.y;\n    castRayDirection *= distToPlane;\n    \n    castRayOrigin -= mul * castRayDirection;\n    \n    return vec4((castRayOrigin).xz, (dot(rayDirection * mul, castRayDirection) < 0.0 ? 1.0 : 0.0), length(castRayDirection));\n}\n\nfloat planeToLines(vec4 plane)\n{\n \tvec2 uv = fract(plane.xy + 0.5);\n    float width = BASE_WIDTH * (plane.w);\n    float fade = smoothstep(100.0, -20.0, plane.w);\n\treturn min((smoothstep(width, 0.0, abs(uv.x - 0.5)) + smoothstep(width, 0.0, abs(uv.y - 0.5))) * plane.z, 1.0) * fade;\n}\n\n//x - x axis, y - y axis\nvec2 planeToAxis(vec4 plane)\n{\n \tfloat width = AXIS_WIDTH * (plane.w);\n    float fade = smoothstep(100.0, -20.0, plane.w);\n    float xAxis = smoothstep(width, 0.0, abs(plane.x)) * smoothstep(0.0, 0.01, plane.y);\n    float yAxis = smoothstep(width, 0.0, abs(plane.y)) * smoothstep(0.0, 0.01, plane.x);\n    return vec2(xAxis, yAxis) * plane.z * fade;\n}\n\nvec4 getGrid(vec3 rayOrigin, vec3 rayDirection)\n{\n    vec4 xzPlane = castXZPlane(rayOrigin.zyx, rayDirection.zyx);\n    float xzLines = planeToLines(xzPlane);\n    vec2 xzAxis = planeToAxis(xzPlane);\n    \n    vec4 xyPlane = castXZPlane(rayOrigin.yzx, rayDirection.yzx);\n    float xyLines = planeToLines(xyPlane);\n    vec2 xyAxis = planeToAxis(xyPlane);\n    \n    vec4 yzPlane = castXZPlane(rayOrigin.zxy, rayDirection.zxy);\n    float yzLines = planeToLines(yzPlane);\n    vec2 yzAxis = planeToAxis(yzPlane);\n\n    vec4 grid = vec4(0.0);\n    \n    grid += xzLines + vec4(xzAxis.x, 0.0, xzAxis.y, 0.0);\n    grid += xyLines + vec4(xyAxis.x, xyAxis.y, 0.0, 0.0);\n    grid += yzLines + vec4(0.0, yzAxis.x, yzAxis.y, 0.0);\n    \n    return grid;\n}","name":"Common","description":"","type":"common"}]}