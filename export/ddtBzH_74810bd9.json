{"ver":"0.1","info":{"id":"ddtBzH","date":"1696889983","viewed":79,"name":"Navier-Stokes 2","username":"athibaul","description":"Some incorrect fluid dynamics simulation. It's got a glitchy behavior where it creates some emerging structures, I don't know where that comes from but it looks kind of cool. Mouse enabled.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["fluid","navier","stokes"],"hasliked":0,"parentid":"mstBR8","parentname":"Navier-Stokes simulation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 pal(float x) {\n    return vec4(1,0.5,0.1,0) * max(x,0.) + vec4(0.05,0.2,1.0,0)*max(-x,0.);\n}\n\nMain {\n    //Q = A(U) - vec4(0,0,1,1);\n    float rho = A(U).z;\n    float p = A(U).w;\n    //Q = abs(Q.zzzz);\n    Q = pal(p - 1.0);\n    //Q = 0.5+A(U).xyyx;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Main {\n    Q = A(U);\n    \n    // Navier-Stokes equations\n    \n    // 1.   drho/dt = -div(rhoV)\n    // 2.   rho * dV/dt = -dot(V, grad V) - grad p + mu * Lapl V + mu/3 * grad div V + rho*g\n    // 3.   d(rhoE)/dt = -div(rhoE*V) + div(p*V) + rho*g*V + kappa * Lapl(rhoE)\n    \n    // System is closed by the state equations of an ideal gas\n    // Temperature = Cv*E\n    // pressure = rho*R*T = R*Cv*rhoE\n    \n    // I did not bother using any units, so this is all very unphysical.\n    \n    // Components of Q are\n    // Q.x : Vx\n    // Q.y : Vy\n    // Q.z : rho\n    // Q.w : rhoE\n    // We consider Vx to be the flow across the bottom edge,\n    // Vy to be the flow across the top edge\n    // and rho and rhoE to be the total mass or energy inside the cell.\n    \n    vec4 c = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    vec4 e = A(U+vec2(1,0));\n    vec4 nw = A(U+vec2(-1,1));\n    vec4 se = A(U+vec2(1,-1));\n    \n    \n    // 1.   drho/dt = -div(rhoV)\n    // -------------------------\n    // Upstream calculation of the flow:\n    // use the value in the cell the flow is coming from\n    float rhoV_n = (n.y > 0.) ? c.z*n.y : n.z*n.y;\n    float rhoV_s = (c.y > 0.) ? s.z*c.y : c.z*c.y;\n    float rhoV_w = (c.x > 0.) ? w.z*c.x : c.z*c.x;\n    float rhoV_e = (e.x > 0.) ? c.z*e.x : e.z*e.x;\n    \n    Q.z += dt * (rhoV_s + rhoV_w - rhoV_n - rhoV_e);\n    Q.z = max(Q.z, 0.001);\n    \n    \n    // 2.   rho * dV/dt = -dot(V, grad V) - grad p + mu * Lapl V + mu/3 * grad div V + rho*g\n    // -------------------------------------------------------------------------------------\n    vec2 VxdVdx = vec2(c.x, (e.x+c.x+s.x+se.x)*0.25) * 0.5*(e.xy - w.xy);\n    vec2 VydVdy = vec2((c.y+n.y+w.y+nw.y)*0.25, c.y) * 0.5 * (n.xy-s.xy);\n    vec2 VdotgradV = VxdVdx + VydVdy;\n    vec2 gradP = RCv * vec2(c.w-w.w, c.w-s.w);\n    vec2 laplV = 0.25 * (n+s+w+e-4.*c).xy;\n    float divV_c = n.y-c.y+e.x-c.x;\n    float divV_s = c.y-s.y+se.x-s.x;\n    float divV_w = nw.y-w.y+c.x-w.x;\n    vec2 graddivV = vec2(divV_c-divV_w, divV_c-divV_s);\n    //vec2 rhoG = c.z * gravity; // we assume it is compensated by the hydrostatic pressure gradient\n    vec2 force = vec2(0,0.01) * (c.w-1.);\n    \n    Q.xy += dt * (-VdotgradV -gradP + mu*laplV + mu/3.0*graddivV + force);\n    // TODO Add the convection term\n    \n    \n    // 3.   d(rhoE)/dt = -div(rhoE*V) + div(p*V) + rho*g*V + kappa * Lapl(rhoE)\n    // ------------------------------------------------------------------------\n    // Upstream calculation\n    float rhoEV_n = (n.y > 0.) ? c.w*n.y : n.w*n.y;\n    float rhoEV_s = (c.y > 0.) ? s.w*c.y : c.w*c.y;\n    float rhoEV_w = (c.x > 0.) ? w.w*c.x : c.w*c.x;\n    float rhoEV_e = (e.x > 0.) ? c.w*e.x : e.w*e.x;\n    // The terms rhoE*V and p*V are proportional, so we only put one\n    float divrhoEV = (rhoEV_n - rhoEV_s + rhoEV_e - rhoEV_w);\n    // Except that we include a small gravity term in the pressure, to compensate for the\n    // hydrodynamic pressure gradient\n    \n    float pV_n = (n.y > 0.) ? RCv*c.w*n.y : (RCv*n.w+gravity.y)*n.y;\n    float pV_s = (c.y > 0.) ? (RCv*s.w-gravity.y)*c.y : RCv*c.w*c.y;\n    float pV_w = (c.x > 0.) ? RCv*w.w*c.x : RCv*c.w*c.x;\n    float pV_e = (e.x > 0.) ? RCv*c.w*e.x : RCv*e.w*e.x;\n    float divpV = (pV_n - pV_s + pV_e - pV_w);\n    \n    //float divpV = RCv * divrhoEV + gravity.y * (n.y-s.y);\n    /*\n    float pV_n = mix(RCv*c.w*n.y, RCv*n.w+gravity.y*n.y, 0.5);\n    float pV_s = mix((RCv*s.w-gravity.y)*c.y , RCv*c.w*c.y, 0.5);\n    float pV_w = mix(RCv*w.w*c.x,  RCv*c.w*c.x, 0.5);\n    float pV_e = mix(RCv*c.w*e.x, RCv*e.w*e.x, 0.5);\n    float divpV = (pV_n - pV_s + pV_e - pV_w);\n    */\n    \n    float rhogV = c.z * dot(c.xy, gravity);\n    float laplrhoE = 0.25 * (n.w+s.w+w.w+e.w-4.*c.w);\n    \n    Q.w += dt * (-divrhoEV + divpV + kappa*laplrhoE);\n    Q.w = max(Q.w, 0.001);\n    \n    // To avoid explosions, we clamp the values (unphysical but practical)\n    //Q.xy = clamp(Q.xy, -1., 1.);\n    Q.xy /= max(1.0, length(Q.xy)/1.);\n    //Q.zw = clamp(Q.zw, 0., 1.);\n    \n    vec2 u = uu(U);\n    \n    if(iFrame==0) {\n        Q = vec4(0,0,1,1);\n        //Q.xy += exp(-300.*dot(u,u));\n        Q.w += 0.1 * (hash12(U) - 0.5); // random initialization\n    }\n    \n    if(iMouse.z > 0.) {\n        vec2 d = U - iMouse.xy;\n        Q.w += exp(-0.1 * dot(d,d));\n    }\n    if(U.x < 2. || U.y < 2. || U.x >= R.x-2. || U.y >= R.y-2.) {\n        Q = vec4(0,0,1,1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define R (iResolution.xy)\n#define uu(U) (2.*U-R)/R.y\n#define dt 0.1\n#define gravity vec2(0, 0)\n#define mu 0.1\n#define kappa 0.01\n#define RCv 0.4\n\n// Hash function by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}","name":"Common","description":"","type":"common"}]}