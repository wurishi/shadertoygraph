{"ver":"0.1","info":{"id":"wdcXR8","date":"1571575969","viewed":61,"name":"Supervision 1 Work","username":"gcorso","description":"SDF exercise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define RENDER_DEPTH 800\n#define CLOSE_ENOUGH 0.00001\n\n#define GRADIENT(pt, func) vec3( \\\n    func(vec3(pt.x + 0.0001, pt.y, pt.z)) - func(vec3(pt.x - 0.0001, pt.y, pt.z)), \\\n    func(vec3(pt.x, pt.y + 0.0001, pt.z)) - func(vec3(pt.x, pt.y - 0.0001, pt.z)), \\\n    func(vec3(pt.x, pt.y, pt.z + 0.0001)) - func(vec3(pt.x, pt.y, pt.z - 0.0001)))\n\n//Array of lights in our scene\nconst vec3 LIGHT_POS[] = vec3[](vec3(5.0));\n\n//---------------------------------------------------------------------------------------\n// Transformations\n//---------------------------------------------------------------------------------------\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1.0, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0.0, 1.0, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1.0)\n    );\n}\n\n//---------------------------------------------------------------------------------------\n// Signed Distance Functions\n//---------------------------------------------------------------------------------------\n\nfloat cone(vec3 p, vec3 o, float r, float h) {\n    if(dot(o, p)<0.0){\n    \tfloat v_d = -dot(o,p);\n        float h_d = max(length(p + v_d*o)-r, 0.0);\n        return sqrt(h_d*h_d+v_d*v_d);\n    } else {\n    \tvec3 H = o*h;\n        vec3 R = normalize(p - dot(p,o)*o)*r;\n        if(dot(H-R, p-R) < 0.0) return length(p-R);\n        if(dot(R-H, p-H) < 0.0) return length(p-H);\n        return length(cross(H-p, R-p))/length(R-H);\n    }\n}\n\nfloat hemisphere(vec3 p, vec3 up, float r){\n\tif(dot(up, p)<0.0){\n    \tfloat v_d = -dot(up,p);\n        float h_d = max(length(p + v_d*up)-r, 0.0);\n        return sqrt(h_d*h_d+v_d*v_d);\n    } else {\n    \treturn length(p)-r;\n    }\n}\n\nfloat semicylinder(vec3 p, vec3 axis, vec3 up, float radius, float height){\n    if(dot(up, p)<0.0){\n        float vertical = -dot(up, p);\n        vec3 rem = p +vertical*up;\n        float horizontal = max(max(-dot(rem, axis), dot(rem, axis)-height), \n                               abs(dot(cross(up,axis), rem))-radius);\n        return sqrt(vertical*vertical+horizontal*horizontal);\n\t} else {\n        if(dot(axis, p)<0.0){\n        \treturn max(-dot(axis, p), length(p-dot(axis, p)*axis)-radius);\n        } else if(dot(axis, p)>height){\n            return max(dot(axis, p)-height, length(p-dot(axis, p)*axis)-radius);\n        } else {\n            return length(p-dot(axis, p)*axis)-radius;\n        }\n    }\n}\n\nfloat igloo(vec3 p, vec3 up, vec3 front, float R, float r, float door_R, float door_r){\n    return max(min(hemisphere(p,up,R), semicylinder(p-2.0*front, front, up, door_R, 2.5*(R-r))), \n               -min(hemisphere(p,up,r), semicylinder(p-2.0*front, front, up, door_r, 2.5*(R-r))));\n}\n\n\nfloat tetrahedron(vec3 p, vec3 v[4]){\n   \tfloat min_signed_dist = 1e10;\n    \n    for(int i = 0; i<4; i++){\n        vec3 perp = normalize(cross(v[(i+1)%4]-v[i], v[(i+2)%4]-v[i]));\n        if(dot(perp, v[(i+3)%4]-v[i])<0.0) perp = -perp;\n        \n        float dist = dot(perp, p-v[i]);\n        min_signed_dist = min(min_signed_dist, dist);\n    }\n    return min_signed_dist;\n}\n\n\nfloat cylinderY(vec3 p, vec3 c, float r){\n   \tp = p-c;\n    return length(p.xz)-r;\n}\n\nfloat spiralY(vec3 p, vec3 c, float r){\n    //p.x = p.x-2.0;\n    return cylinderY(vec3(p.x*cos(p.y*2.0)-p.z*sin(p.y*2.0), \n                          p.y, p.x*sin(p.y*2.0)+p.z*cos(p.y*2.0)), \n                     vec3(1.0,0.0,0.0), r);\n}\n    \n\n\n\nfloat scene(vec3 p) {\n    \n    //return cone(p, vec3(1.0,0.0,0.0), 2.0, 3.0);\n    /*vec3 t[4];\n    t[0] = 2.5*vec3(1.0,0.0,0.0);\n    t[1] = 2.5*vec3(1.0,1.5,0.0);\n    t[2] = 2.5*vec3(-1.0,1.0,0.0);\n    t[3] = 2.5*vec3(1.0,1.0,1.0);\n    return tetrahedron(p, t);*/\n    //return igloo(p, vec3(0.0,1.0,0.0), vec3(1.0,0.0,0.0), 3.0, 2.5, 1.5, 1.0);\n    //return semicylinder(p, vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), 2.0, 3.0);\n    \n    return spiralY(p, vec3(1.0,0.0,0.0), 0.4);\n    \n}\n\n//---------------------------------------------------------------------------------------\n// Auxiliary helper functions\n//---------------------------------------------------------------------------------------\n\nvec3 getNormal(vec3 pt) {\n    return normalize(GRADIENT(pt, scene));\n}\n\n//---------------------------------------------------------------------------------------\n// Illumination and Shading\n//---------------------------------------------------------------------------------------\n\nfloat shade(vec3 eye, vec3 pt, vec3 n) {\n    float val = 0.0;\n\n    //Ambient Lighting\n    val += 0.2;\n\n    //Cast ray towards our light sources and add it to the illumination depending\n    //on the angle with the normal to the surface\n    for (int i = 0; i < LIGHT_POS.length(); i++) {\n        vec3 l = normalize(LIGHT_POS[i] - pt); \n        val += max(dot(n, l), 0.0);\n    }\n\n    return val;\n}\n\nvec3 illuminate(vec3 camPos, vec3 rayDir, vec3 pt) {\n    vec3 c, n;\n    //Using the SDF normal approximation\n    n = getNormal(pt);\n\t\n    //Everything is white\n    c = vec3(1.0);\n    return shade(camPos, pt, n) * c ;\n}\n\n//---------------------------------------------------------------------------------------\n// Ray Marching Algorithm\n//---------------------------------------------------------------------------------------\n\nvec3 castRay(vec3 camPos, vec3 rayDir) {\n    //Using the ray marching approach\n    int step = 0;\n    float t = 0.0;\n    \n    for (float d = 1000.0; step < RENDER_DEPTH && abs(d) > CLOSE_ENOUGH; t += abs(d)) {\n        d = scene(camPos + t * rayDir)/2.0;\n        step++;\n    }\n    \n    if (step == RENDER_DEPTH) {\n        return vec3(0.0, 0.0, 0.0); //getBackground(rayDir);\n    } else {\n        return illuminate(camPos, rayDir, camPos + t * rayDir);\n    }\n}\n\n//---------------------------------------------------------------------------------------\n// Set-up\n//---------------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    //The direction in which the camera is pointing\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n//---------------------------------------------------------------------------------------\n// Output\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the 2d coordinates [-1, 1]\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    //Fix the x axis to original resolution\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Setting the camera - origin, lookat\n    vec3 origin = vec3(10.0*sin(iTime), 1.8, 10.0*cos(iTime));\n    vec3 look = vec3(0.0);\n    \n    \n    mat3 camera = setCamera(origin, look, 0.0);\n    vec3 direction = camera * normalize(vec3(p.xy, 2.0));\n    \n    vec3 color = castRay(origin, direction);\n    \n    fragColor = vec4(color, 0.0);\n}","name":"Image","description":"","type":"image"}]}