{"ver":"0.1","info":{"id":"Wt2Szt","date":"1566823996","viewed":216,"name":"Skeleton Helix","username":"holtsetio","description":"Reiterating on the helix distance function. Completely unoptimized.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","helix","neon","bones"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Parameters\n#define outerT 2.9\n#define FUZZ 0.75\n#define PHASELENGTH 30.0\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define EPSILON 0.005\n#define KEPLER_MAXITER 2\n#define MAXSTEPS 150\n#define MAXDIST 95.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n\n\nvec3 glow = vec3(0);\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 buildtransform(vec3 point, float off, vec3 trans, bool isNeg) {\n    vec3 zaxis = normalize(point);\n    vec3 xaxis = normalize(vec3(zaxis.z, 0.0, -zaxis.x));\n    if (!isNeg && zaxis.x < 0.0) {\n        xaxis *= -1.0;\n    }\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0,\n                xaxis.y, yaxis.y, zaxis.y, 0,\n                xaxis.z, yaxis.z, zaxis.z, 0,\n                dot(xaxis,trans),dot(yaxis,trans),dot(zaxis,trans)+off,1);\n}\n\n   \nfloat solveKeplerHalley(float e,float M) {\n    float E =clamp(M+PI,0.00,PI);\n    int i=0;\n    while(i<KEPLER_MAXITER) {\n        float esinE = e*sin(E);\n        float k0mM = (E-esinE)-M;\n        float k1 = (1.0-e*cos(E));\n        E -= (2.0*k0mM*k1)/(2.0*k1*k1-k0mM*(esinE));\n        i++;\n    }\n    return E;\n}\n\nfloat solveKepler(float e, float M) {\n    //http://www.jgiesen.de/kepler/kepler.html\n    if (e >= 1.0) {\n        return solveKeplerHalley(e,M);\n    }\n    float E = (e < 0.8 ? M : PI);\n    float F = E - e*sin(M)-M;\n    int i = 0;\n    while (i < KEPLER_MAXITER) {\n    \tE -= F/(1.0 - e*cos(E));\n        F = E - e*sin(E) - M;\n        i++;\n    }\n\treturn E;\n}\n\nstruct HelixHit {\n\tvec4 p;\n    float strand;\n    float theta;\n    vec4 stepped_p;\n    float stepped_theta;\n};\n\n// Computes the closest point to p on a Helix (R,T) with n strands.\n// The returned struct contains the closest point, the strand and the point Theta on the helix.\nHelixHit ClosestPointHelixStep(vec4 p, float R, float T, float n_helices, float stepsize,float offset,float offsetoffsetlol) {\n    // Nievergelt 2009\n    // doi: 10.1016/j.nima.2008.10.006\n    \n    //Helix: H(Theta) = [R*cos(Theta), R*sin(Theta), T*Theta]\n    //Point: D = (u, v, w) = [r * cos(delta), r * sin(delta), w]\n    HelixHit res;\n    float delta = atan(p.y, p.x);\n    float r = length(p.yx);\n    float kt = ((p.z/T)-delta)/TWOPI;\n    float inv_n_helices = 1.0/n_helices;\n    float n = floor((fract(kt) + 0.5*inv_n_helices)/inv_n_helices -0.5);\n    float s_offset = -(n+0.5)*inv_n_helices*TWOPI;\n    float dktp = delta + round(kt-(n+0.5)*inv_n_helices) * TWOPI; \n    float M = PI + (p.z/T) + s_offset - dktp;\n    float e = (r*R)/(T*T);\n    float E = solveKepler(e,M);\n    float Theta = E - PI + dktp;\n    \n    res.theta = (Theta-s_offset);\n    res.strand=n;\n    res.p = vec4(R*cos(Theta), R*sin(Theta), res.theta*T,1.0);\n        \n    offset *= sign(n-0.5);\n    offset += offsetoffsetlol;\n    Theta = round((Theta-s_offset+offset)/stepsize)*stepsize+s_offset-offset;\n    \n    res.stepped_theta = (Theta-s_offset);\n    res.strand=n;\n    res.stepped_p = vec4(R*cos(Theta), R*sin(Theta), res.stepped_theta*T,1.0);\n    res.stepped_theta += s_offset;\n    \n    \n    return res;\n}\n\nstruct TorusHit {\n  \tvec4 p;\n  \tfloat angle;\n};\n\nTorusHit sdTorus(vec4 pos, float r1)\n{\n  \tTorusHit hit;\n  \thit.angle = atan(pos.y,pos.x);\n  \thit.p = vec4(normalize(pos.xy)*r1,0,1);\n    return hit;\n}\n\nstruct Result {\n\tfloat dist;\n    vec4 n;\n};\n    \n    \n    float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nResult ED(vec4 p) {\n    vec3 col = pal( PHASE, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \n    p = rotationZ(-PHASE*TWOPI*1.0)*p;\n    float T = outerT;\n    HelixHit hit = ClosestPointHelixStep(p,4.0,T,2.0,PI/3.0,2.0*PHASE*TWOPI,-(PHASE*TWOPI)*0.5*2.0);\n    \n    float dh = distance(p,hit.p)-0.25;\n    vec3 nh = normalize(p-hit.p).xyz;\n    \n    //vec3 col = pal( PHASE, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //glow += normalize(col) * pow(max(0.0,(1.0-1.0*dh)),3.0) * 0.05;\n\n    Result res;\n    \n    vec3 lookDir = (vec3(hit.stepped_p.y,-hit.stepped_p.x,-T));\n    mat4 transform = buildtransform(lookDir.xyz,0.0,-hit.stepped_p.xyz,true);\n    TorusHit hit2 = sdTorus(transform*p,1.7);\n    \n    /*mat4 invt = inverse(transform);\n    float dt = distance(p,invt*hit2.p)-0.1;\n    vec3 nt = (invt*normalize(transform*p-hit2.p)).xyz;\n    vec3 colt = pal( mod(PHASE+0.5,1.0), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if (dt < dh) {\n      \tdh = dt;\n      \tnh = nt;\n        //col = pal( mod(PHASE+0.5,1.0), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }*/\n    \n    vec3 lookDir2 = (vec3(hit2.p.y,-hit2.p.x,0));\n    transform = buildtransform(lookDir2.xyz,-hit2.angle*1.7,-hit2.p.xyz,false) * transform;\n    float T2 = 1.7/5.0;\n    HelixHit hit3 = ClosestPointHelixStep(transform*p,0.6,T2,2.0,PI/1.5,-PHASE*TWOPI*5.0,0.0);\n    \n    \n    \n    //glow += normalize(vec3(0.8 + 0.4*sin(2.0*PHASE*TWOPI+0.75*PI),1.0,0.6+0.4*sin(PHASE*TWOPI))) * pow(max(0.0,(1.0-1.0*length(hit3.p - transform*p))),2.0) * 0.031;\n    //glow += normalize(vec3(1.0,1.0,1.0)) * pow(max(0.0,(1.0-0.5*length(hit3.p - transform*p))),1.0) * 0.021;\n    \n    \n    mat4 inv0 = inverse(transform);\n    float d0 = distance(p,inv0*hit3.p)-0.043*2.00;\n    vec4 n0 = inv0*normalize(transform*p-hit3.p);\n    \n    vec3 lookDir3 = (vec3(hit3.stepped_p.y,-hit3.stepped_p.x,-T2));\n    transform = buildtransform(lookDir3.xyz,0.0,-hit3.stepped_p.xyz,true) * transform;\n    TorusHit hit4 = sdTorus(transform*p,0.15+0.05*hit3.strand*0.0+0.05*sin(15.0*PHASE*PI*2.0+hit3.stepped_theta*2.0+1.0*hit3.strand*3.14159));\n    \n    \n    mat4 inv = inverse(transform);\n    res.dist = distance(p,inv*hit4.p)-0.043*1.00;\n    res.n = inv*normalize(transform*p-hit4.p);\n    \n    res.dist = opSmoothUnion(d0,res.dist,0.35);\n    \n    glow += normalize(vec3(1.0,1.0,1.0)) * pow(max(0.0,(1.0-1.0*res.dist)),2.0) * 0.021;\n    \n    res.dist = min(dh,res.dist);\n\n    /*if (d0 < res.dist) {\n    \tres.dist = d0; \n       \tres.n = n0;\n    }*/\n    \n    \n    \n    float glowmult = 1.0;\n    \n    if (res.dist < EPSILON) {\n      if (dh > res.dist) {\n        glowmult = max(0.0,-dot(n0.xyz,nh)) * pow(max(0.0,(1.0-0.3*dh)),2.0) *40.0;\n      } else {\n      \tglowmult = 20.0;  \n      }\n    } else {\n        glowmult = pow(max(0.0,(1.0-0.5*dh)),1.0) * 1.0;\n    }\n    glow += normalize(col)  * 0.01 * glowmult;\n    \n\treturn res;\n}\n\nvec3 raymarch(vec4 orig, vec4 dir) {\n    float dist = 0.0;\n    float minDist = 1e9;\n    int steps = 0;\n    vec4 pos = orig;\n    Result res;\n    res.dist = 1e9;\n    \n    while (dist < MAXDIST && steps < MAXSTEPS && res.dist >= EPSILON) {\n    \tres = ED(pos);\n        minDist = min(minDist,res.dist);\n        \n        dist += FUZZ*res.dist;\n        \n        pos = orig + dist*dir;\n    \tsteps++;\n    }\n    glow = pow(glow,vec3(1.2));\n    return 1.0-glow;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x * PI * 0.5;\n    \n    vec4 raydir = normalize(vec4(sin(uv.x),1.0,-sin(uv.y),0.0));\n    vec4 rayorig = vec4(15.0,0.0,0.0,1);\n    \n    vec2 rot = (iMouse.xy / iResolution.xy - 0.5) * 2.0 * PI;\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n    \trot = vec2(0,0);\n    rot += vec2(-0.5,-0.5)*PI;\n    \n    mat4 m = rotationY(-rot.x) * rotationX(rot.y) * rotationY(0.5);\n    raydir = m * raydir;\n\n    fragColor = vec4(raymarch(rayorig, raydir),1.0);\n}","name":"Image","description":"","type":"image"}]}