{"ver":"0.1","info":{"id":"ttf3Rs","date":"1557381088","viewed":373,"name":"Playable Endless Maze","username":"zackpudil","description":"WASD (or ZQSD) + mouse to move around.  Hold space to cheat, if you that kinda person.  It is \"beatable\" without cheating. By beating I mean touching the glowing sphere in the distance.\n\nIt's all probably broken.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","sdf","glow","ibl","pbr","fps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 trace(vec3 o, vec3 d, float mx) {\n    float t = 0.0, m = -1.0;\n    for(int i = 0; i < 200; i++) {\n        vec2 d = de(o + d*t);\n        if(d.x < 0.001 || t >= mx) break;\n        t += d.x;\n        m = d.y;\n    }\n    return vec2(t, t < mx ? m : -1.0);\n}\n\nvec3 tex3D(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    m /= dot(vec3(1), m);\n    \n    vec3 x = texture(s, p.yz).rgb;\n    vec3 y = texture(s, p.xz).rgb;\n    vec3 z = texture(s, p.xy).rgb;\n    \n    return m.x*x*x + m.y*y*y + m.z*z*z;\n}\n\nvec3 bump(vec3 p, vec3 n, sampler2D s, float bf) {\n    vec2 h = vec2(0.004, 0.0);\n    vec3 g = mat3(\n        tex3D(p + h.xyy, n, s) - tex3D(p - h.xyy, n, s),\n        tex3D(p + h.yxy, n, s) - tex3D(p - h.yxy, n, s),\n        tex3D(p + h.yyx, n, s) - tex3D(p - h.yyx, n, s)\n    )*vec3(0.299, 0.584, 0.114);\n    \n    g -= n*dot(g, n);\n    return normalize(n + bf*g);\n}\n\nvec3 parallax(vec3 p, vec3 n, vec3 rd, sampler2D s) {\n    vec3 tgt = n*dot(rd, n) - rd;\n    tgt /= abs(dot(tgt, rd)) + 2.0;\n    \n    float ss = dot(tex3D(p, n, s), vec3(0.299, 0.583, 0.114));\n    ss = smoothstep(0.2, 0.7, ss);\n    \n    return p + tgt*ss*0.4;\n}\n\nvec3 pbr(vec3 p, vec3 n, vec3 l, vec3 rd,\n         vec3 a, float r, float m,\n         inout vec3 f, inout float hov, inout float nov) {\n    vec3 v = normalize(-rd);\n    vec3 h = normalize(l + v);\n    \n    float nol = clamp(dot(n, l), 0.0, 1.0);\n    float noh = clamp(dot(n, h), 0.0, 1.0);\n    nov = clamp(dot(n, v), 0.0, 1.0);\n    hov = dot(h, v);\n    \n    f = mix(vec3(0.04), a, m);\n    vec3 F = f + (1.0 - f)*pow(1.0 - hov, 5.0);\n    \n    float a2 = pow(r, 4.0);\n    float D = a2/pow(noh*noh*(a2 - 1.0) + 1.0, 2.0);\n    \n    float k = 0.5*pow(0.5*r + 0.5, 2.0);\n    float kl = nol*(1.0 - k) + k;\n    float kv = nov*(1.0 - k) + k;\n    float V = 1.0/(4.0*kl*kv);\n    \n    vec3 spe = F*V*D;\n    vec3 dif = (1.0 - F)*(1.0 - m);\n    \n    return (dif*a/3.141 + spe)*nol;\n}\n\nvec3 ibl(vec3 p, vec3 n, vec3 rf, vec3 a, float r, float m,\n         vec3 f, float hov, float nov) {\n    \n    vec3 F = f + (max(vec3(1.0 - f), f) - f)*pow(1.0 - hov, 5.0);\n    vec3 irr = textureLod(iChannel0, n, 10.0).rgb;\n    vec3 dif = (1.0 - F)*(1.0 - m)*irr*a;\n    \n    vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    vec4 c1 = vec4(1, 0.0525, 1.04, -0.04);\n    \n    vec4 cr = c0*r + c1;\n    float a4 = min(cr.x*cr.x, exp2(-9.28*nov))*cr.x + cr.y;\n    vec2 ab = vec2(-1.04, 1.04)*a4 + cr.zw;\n    \n    vec3 pre = textureLod(iChannel0, rf, 10.0*r).rgb;\n    \n    vec3 spe = pre*(F*ab.x + ab.y);\n    \n    float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*0.05).x/0.05), 2.0));\n    \n    return (dif + spe)*occ;\n}\n\nvoid material(float mid, vec3 rd,\n              inout vec3 p, inout vec3 n,\n              inout vec3 a, inout float r, inout float m) {\n    \n    if(mid == 1.0) {\n\n        n = bump(p, n, iChannel2, 0.5);\n        a = tex3D(p, n, iChannel2);\n        r = 0.5 - dot(a, a);\n        a = vec3(1);\n        m = 1.0;\n    } else if(mid == 2.0) {\n        p = parallax(p, n, rd, iChannel1);\n        n = bump(0.5*p, n, iChannel1, 1.0);\n        a = tex3D(0.5*p, n, iChannel1);\n        r = 0.2 + smoothstep(0.2, 0.21, dot(a, vec3(0.299, 0.548, 0.114)));\n        m = 0.0;\n    } else if(mid == 3.0) {\n        p = parallax(p, n, rd, iChannel2);\n        n = bump(p, n, iChannel2, 1.5);\n        a = vec3(1);\n        r = 0.2;\n        m = 0.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float at = 0.4*iTime;\n    \n    vec3 ro = texture(iChannel3, vec2(0)).xyz;\n    vec3 rd = normalize(cameraMatrix(iMouse)*vec3(uv, 1));\n    \n    vec3 bg = texture(iChannel0, rd).rgb;\n    vec3 col = bg;\n    \n    vec2 t = trace(ro, rd, 50.0);\n    if(t.y > 0.0) {\n        vec3 p = ro + rd*t.x;\n        vec3 n = normal(p);\n        vec3 l = normalize(vec3(0.8, 0.7, -0.6));\n \n        vec3 a = vec3(1);\n        float r = 0.2, m = 1.0;\n        \n        material(t.y, rd, p, n, a, r, m);\n        \n        vec3 f;\n        float nov, hov;\n        \n        col = pbr(p, n, l, rd, a, r, m, f, nov, hov);\n        \n        vec3 rf = reflect(rd, n);\n        col += ibl(p, n, rf, a, r, m, f, hov, nov);\n        \n    }\n \tcol += vec3(1.0, 0.9, 0.8)*glow;\n    col = mix(col, bg, 1.0 - exp(-0.02*t.x));\n    col = 1.0 - exp(-0.5*col);\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash(vec2 n) {\n    return hash(dot(n, vec2(12.232, 39.343)));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(q.x, max(q.y, q.z));\n}\n\nvec2 un(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 fractal(vec3 p) {\n    vec4 q = vec4(p, 1);\n    //q.xyz -= 1.0;\n    for(int i = 0; i < 3; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q *= 1.02/clamp(dot(q.xyz, q.xyz), 0.2, 1.0);\n    }\n    \n    return q;\n}\n\nfloat glow = 0.0;\n\nfloat goal(vec3 p) {\n    p -= vec3(1, 0, 13);\n    float v = length(p) - 1.0;\n    \n    if(v < 1.5) glow += 0.01*hash(40.0*p.xz) + 0.1/(0.1 + v*v*20.0);\n    \n\treturn v;\n}\n\n\nvec2 de(vec3 p) {\n    vec3 op = p;\n    vec2 f = floor(p.xz);\n    \n    p.xz = fract(p.xz) - 0.5;\n    p.x *= 2.0*floor(fract(hash(f))*1.8) - 1.0;\n    \n    float d = abs(1.0 - 2.0*abs(dot(p.xz, vec2(1))))/(2.0*sqrt(5.0));\n    \n    float a = max(d - 0.3/4.0, p.y + 0.0);\n    float b = max(d - 0.35/4.0, p.y + 0.01);\n    \n    vec4 fr = fractal(p);\n    b = max(b, -max(d - 0.5/4.0, box(fr.xyz, vec3(1))/fr.w));\n    \n    vec2 s = vec2(a, 1.0);\n    vec2 t = vec2(b, 3.0);\n    vec2 u = vec2(p.y + 1.0, 3.0);\n    vec2 v = vec2(goal(op), 2.0);\n    \n    \n    return un(s, un(u, un(t, v)));\n}\n\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy).x - de(p - h.xyy).x,\n        de(p + h.yxy).x - de(p - h.yxy).x,\n        de(p + h.yyx).x - de(p - h.yyx).x);\n    return normalize(n);\n}\n\n\nmat3 cameraMatrix(vec4 mouse) {\n    vec2 mo = -0.5+ 1.0*(mouse.xy - abs(mouse.zw));\n    mo.y = -mo.y;\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float KEY_W     = 87.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\n\nconst float KEY_Z \t  = 90.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\n\nconst float KEY_SP    = 32.5/256.0;\n\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.0) ).x;\n}\n\nvec4 cameraPosition() {\n    vec4 p =  texture(iChannel0, vec2(0));\n    if(iFrame == 0) return vec4(0.0, 6, -3.4, 0);\n   \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 cp = cameraPosition();\n    mat3 cm = cameraMatrix(iMouse);\n    \n    float speed = 0.02;\n    \n    if(isKeyPressed(KEY_W) == 1.0 || isKeyPressed(KEY_Z) == 1.0) cp.xz += cm[2].xz*speed;\n    if(isKeyPressed(KEY_S) == 1.0) cp.xz -= cm[2].xz*speed;\n    if(isKeyPressed(KEY_A) == 1.0 || isKeyPressed(KEY_Q) == 1.0) cp.xz -= cm[0].xz*speed;\n    if(isKeyPressed(KEY_D) == 1.0) cp.xz += cm[0].xz*speed;\n    \n    if(de(cp.xyz).x < 0.001) {\n        cp.xyz += speed*2.0*normal(cp.xyz);\n    }\n    \n    if(isKeyPressed(KEY_SP) == 1.0) cp.y = 3.0;\n\t\n    if(de(cp.xyz - vec3(0, 0.5, 0)).x < 0.01)\n        cp.y += speed*5.0*abs(de(cp.xyz - vec3(0, 0.5, 0)).x);\n    else\n\t\tcp.y -= speed*5.0;\n    \n    fragColor = cp;\n}","name":"Buffer A","description":"","type":"buffer"}]}