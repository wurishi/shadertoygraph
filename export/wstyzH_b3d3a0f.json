{"ver":"0.1","info":{"id":"wstyzH","date":"1600892727","viewed":902,"name":"Baking Tangent Space Normal Maps","username":"GCScholar","description":"Define LOW_DETAIL_MODEL 1 if is it too slow. \nA normal map is backed from a high detail model to the low details model tangent space, then applied to it. The normal map is shown in the bottom both in world and tangent space.","likes":20,"published":1,"flags":32,"usePreview":1,"tags":["map","normal","maps","baking","tangentspace","bake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here I demonstrate the process of backing the normal maps from a high detailed (HD) object \n// to the tangent space of a low detailed (LD) object.\n//\n// Rays are casted from outside the objects, normal are sampled from the HD model and mapped to the LD one. \n// This mapping then transformed in the LD tangent space. \n// The HD object is dynamic changing and the normal are sampled in real time, \n// so you can see how the changes in the HD model affect the LD. \n   \n\n// Print char tnx https://www.shadertoy.com/view/ltcXzs\nvec4 char(vec2 p, int C) \n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n   //return texture   ( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) );\n  //return textureLod( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n  //                   log2(length(fwidth(p/16.*iResolution.xy))) );\n    return textureGrad( iChannel2, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n\nvec4 printText(in int asciiCodes[21], in vec2 U) \n{\n\tvec4 color;\n    for(int i=0; i<21; i++)\n    {\n        color += vec4(char(U, asciiCodes[i]).x);  U.x-=0.5; // H\n    \n    }\n    return color;\n}\n\nvec4 sampleNormalMap(vec3 N) \n{\n    float u = 1.-(atan(N.x, N.z)+PI)/(2.*PI);\n\tfloat v = (acos(N.y)/PI);\t// 1.- becouse the coordinates origin is in the bottom-left, but I backed from top-left\n    return texture(iChannel0, vec2(u, v));   \n}\n\n// Schlick approximation of the Fresnel reflectance\n// R0 \tthe\n// N \tthe normal to the surface\n// L \tthe light direction from the point on the surface\nvec3 SchlickFresnel(vec3 R0, vec3 N, vec3 L){\n\t\n\tfloat f0 = 1.0f - max(dot(N, L), 0.0);\n    return R0 + (1.0f - R0)*(f0*f0*f0*f0*f0);\n}\n\n// Blinn-Phong model: ambient + diffuse + specular\n// lightStrength\tthe RGB light intensity\n// L \t\t\t\tthe light direction from the point on the surface\n// N \t\t\tthe normal to the surface at the point\n// V\t\t\tthe viewer direction from the point on the surface\n// albedo\t\tthe material albedo\n// shininess\thow much the material is shine or rough\n// R0\t\t\t\nvec3 BlinnPhong(vec3 lightStrength, vec3 L, vec3 N, vec3 V, Material mat)\n{\n    vec3 H = normalize(L+V);\t// Half vector between View and Light vector\n\t\n    float m = mat.shininess * 256.0;\n    float roughnessFactor = ((m + 8.0)*pow(max(dot(H,N),0.0), m))/8.0;\t// Controls how much smooth is the material, taking into account normalization for energy conservation    \n\tvec3 fresnelFactor = SchlickFresnel(mat.fresnelR0, H, L);\n    vec3 specAlbedo = fresnelFactor*roughnessFactor;\n    specAlbedo = specAlbedo / (specAlbedo + 1.0f);\t// the formula goes outside [0,1]\n    return (mat.diffuseAlbedo.rgb + specAlbedo) * lightStrength;\n}\n\n// N \t\tis the surface normal, \n// P \t\tis the point to shade\n// R_F0 i \tthe amount of reflected (specular) light at the 0 angle \n//\t\t\t that is the lowest value for specular reflection that is maximum at PI angles.\n// \t\t\t More the material is metallic, higher is the reflection at 0\n// roughness        controls the roughness (low values) - smoothness (high values) of the surface\nvec4 render(int objId, vec3 Eye, vec3 P, vec3 N)\n{\n    // Material properties\n    \n    Material mat = material(objId);\n    if(objId == 0) mat.diffuseAlbedo = vec3(checkers(vec2(P.x, P.z))); // Floor checkboard\n    vec3 ambientLight = vec3(0.1,0.1,0.1);\n   \t\n    vec3 V = Eye - P;\t\t\t// Vector from surface point to the camera\n\t\n    //vec3 R = 2.0*dot(N,V)*N;\t// Refleted light vector respect to N\n    //vec4 cubeMapSampleDiff = texture(iChannel2, R);\n    //vec4 cubeMapSampleSpec = texture(iChannel3, R);\n    \n    // Light 1\n    vec3 toLight1Dir = normalize(vec3(-0.2, 0.4, -0.2));\n    vec3 light1Color = vec3(0.6, 0.6, 0.6);\n    \n    // Lambert-law attenuation\n    vec3 light1Strength = max(dot(toLight1Dir,N),0.0)*light1Color;\n    vec3 C_light1 = BlinnPhong(light1Strength, toLight1Dir, N, V, mat);\n\n    // Light 2 floor reflex\n    vec3 toLight2Dir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 light2Color = vec3(0.1, 0.2, 0.6);\n    \n    // Lambert-law attenuation\n    vec3 light2Strength = max(dot(toLight2Dir,N),0.0)*light2Color;\n    vec3 C_light2 = BlinnPhong(light2Strength, toLight2Dir, N, V, mat);\n\n    return vec4(C_light1 + C_light2 ,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 iRes = iResolution;  \n    vec2 U = (2.*fragCoord-iRes.xy)/(iRes.y);   \n    \n    // Handle quadrants\n    vec2 ar = iRes.xy/iRes.y;\n    U = U*2.;\n    vec4 colorQ1, colorQ2, colorQ3, colorQ4;\n    int quad;\n    if(fragCoord.x < iRes.x/2. && fragCoord.y > iRes.y*1./3.) { quad=1; U += vec2(ar.x, -ar.y*0.7);  }\n    else if(fragCoord.x > iRes.x/2. && fragCoord.y > iRes.y*1./3.) { quad=2; U += vec2(-ar.x, -ar.y*0.7); }\n    else if(fragCoord.x < iRes.x/2. && fragCoord.y < iRes.y*1./3.) { quad=3;}\n    else if(fragCoord.x > iRes.x/2. && fragCoord.y < iRes.y*1./3.) { quad=4;}\n    \n    // Camera\n   \tvec3 P_eye;\n   \tvec2 camAngle = iMouse.xy/iResolution.xy;\n    P_eye = vec3(4.*cos(iTime/5.+10.*camAngle.x),0.5+0.5*camAngle.y,4.*sin(iTime/5.+10.*camAngle.x));\n    \n    vec3 P_target = vec3(0.,0.,0.);\n    \n    // Right handed camera reference\n    vec3 ww = normalize(P_eye - P_target);\n    vec3 vv = normalize(cross(vec3(0.,1.,0.), ww));;;\n    vec3 uu = normalize(cross(ww, vv));\n    \n    // Ray through pixel\n    vec3 dir = normalize(U.x*vv + U.y*uu - FOCAL_LENGTH*ww);\n    \n    Hit hit;\n    vec3 N;\n    \n    // High detail model with normal map applied\n    if(quad ==1) \n    {\n        // Background \n        fragColor = vec4(vec3(0.5, 0.7, 0.9) - max(U.y,0.0)*0.1, 1.0);\n        \n        float d = MAX_MARCHING_DISTANCE;\n        \n        // Raytrace floor\n        if(LOW_DETAIL_MODEL == 0)\n        {\n            // Raytrace floor\n            float d = (-1.5-P_eye.y)/dir.y;\n            if( d>0.0 && d < MAX_MARCHING_DISTANCE)\n            {\n                d = min(10., d);\n                vec3 P = P_eye + d*dir;\n                vec3 toLight1Dir = normalize(vec3(-0.2, 0.4, -0.2));\n                vec3 toLight2Dir = normalize(vec3(0.2, 0.4, 0.2));\n\n                fragColor = render(0, P_eye, P, vec3(0.0,1.0,0.0));\n                fragColor = vec4(applyFog(fragColor.xyz,d),1.0);\n\n                Hit hit = RayMarchHighDetailModel(P, toLight1Dir);\n                if(hit.objId == 1) \n                {\n                    fragColor = render(0, P_eye, P, vec3(0.0,1.0,0.0));\n                    fragColor = vec4(applyFog(fragColor.xyz,d),1.0);\n                    fragColor*=0.8;\n                }\n            } else d = MAX_MARCHING_DISTANCE;\n        }\n        \n \t\thit = RayMarchHighDetailModel(P_eye, dir);\n        if(hit.d < d)\n        {\n            if(hit.objId == -1) fragColor = vec4(vec3(0.5, 0.7, 0.9) - max(U.y,0.0)*0.1, 1.0);\n            else \n            {\n                N = hit.normal;\n                fragColor = render(1, P_eye, hit.point, N);\n            }\n        }\n        \n        // gamma\n        fragColor = vec4(pow( fragColor.xyz, vec3(0.4545)),1.0);\n        \n        // Print \"High detail model\"\n        U *= 4.;\n    \tU -= vec2(-4.5,4.0);\n        int text[21] = int[21](72, 105, 103, 104, 32, 100, 101, 116, 97, 105, 108, 115, 32, 109, 111, 100, 101, 108, 32, 32, 32);\n        fragColor -= printText(text, U);\n    }\n    \n    // Low detail model with normal map applied\n    else if (quad == 2) \n    {\n        // Background \n        fragColor = vec4(vec3(0.5, 0.7, 0.9) - max(U.y,0.0)*0.1, 1.0);\n        float d = MAX_MARCHING_DISTANCE;\n        \n        // Raytrace floor\n        if(LOW_DETAIL_MODEL == 0)\n        {\n            d = (-1.5-P_eye.y)/dir.y;\n            if( d>0.0 && d < MAX_MARCHING_DISTANCE)\n            {\n                d = min(10., d);\n                vec3 P = P_eye + d*dir;\n                vec3 toLight1Dir = normalize(vec3(-0.2, 0.4, -0.2));\n                vec3 toLight2Dir = normalize(vec3(0.2, 0.4, 0.2));\n\n                fragColor = render(0, P_eye, P, vec3(0.0,1.0,0.0));\n                fragColor = vec4(applyFog(fragColor.xyz,d),1.0);\n\n                Hit hit = RayMarchLowDetailModel(P, toLight1Dir);\n                if(hit.objId == 1) \n                {\n                    fragColor = render(0, P_eye, P, vec3(0.0,1.0,0.0));\n                    fragColor = vec4(applyFog(fragColor.xyz,d),1.0);\n                    fragColor*=0.8;\n                }\n            } else d = MAX_MARCHING_DISTANCE;\n        }\n        \n        hit = RayMarchLowDetailModel(P_eye, dir);\n       \tif(hit.d < d)\n        {\n            if(hit.objId == 1) \n            {\n                if(abs(sin(iTime/5.0)) < 0.3) \n                {\n                \t// Don't apply normal maps\n                \tfragColor = render(1, P_eye, hit.point, hit.normal);\n                }\n                else \n                {\n                \t// Apply normal maps\n                    // Get normal from normal map\n                    vec3 N_ts = sampleNormalMap(hit.normal).xyz;\t\t\t\t// Tangent space normal map\n                    N_ts = 2.*N_ts-1.;\t\t\t\t\t\t\n                    mat3 M_ts_ws = mat3(hit.binormal,hit.tangent,hit.normal);\t// Tangent to world space transform matrix\n                    vec3 N_ws = M_ts_ws*N_ts;\n                    N = N_ws; // The normal is taken from normal map\n\n                    // Lighting \n                    fragColor = render(1, P_eye, hit.point, N);\n                }\n            }\n        }\n        \n        // gamma\n        fragColor = vec4(pow(fragColor.xyz, vec3(0.4545)),1.0);\n        \n        // Print \"Low detail model\"\n        U *= 4.;\n        U -= vec2(-4.5,4.0);\n        int text[21] = int[21](76, 111, 119, 32, 100, 101, 116, 97, 105, 108, 115, 32, 109, 111, 100, 101, 108, 32, 32, 32, 32);\n        fragColor -= printText(text, U);\n    }\n    \n    // Normal map in world space\n    else if(quad == 3) \n    {\n        vec2 UV = (fragCoord*vec2(2.,3.))/iRes.xy;\n    \tfragColor = texture(iChannel1, UV); \n        // Print \"World space normals\"\n        UV *= vec2(24.0, 12.0);\n       \tUV -= vec2(6.5,10.0);\n        int text[21] = int[21](87, 111, 114, 108, 100, 32, 115, 112, 97, 99, 101, 32, 110, 111, 114, 109, 97, 108, 115, 32, 32);\n        fragColor -= printText(text, UV);\n    }\n    \n    // Normal map in tangent space\n    else if(quad == 4) \n    {\n    \tvec2 UV = (fragCoord-vec2(iRes.x/2.,0.))*vec2(2.,3.)/iRes.xy;\n    \tfragColor = texture(iChannel0, UV); \n        // Print \"Tangent space normals\"\n        UV *= vec2(24.0, 12.0);\n       \tUV -= vec2(6.5,10.0);\n        int text[21] = int[21](84, 97, 110, 103, 101, 110, 116, 32, 115, 112, 97, 99, 101, 32, 110, 111, 114, 109, 97, 108, 115);\n        fragColor -= printText(text, UV);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"                            // See https://www.shadertoy.com/view/ttf3R4\n\t\t\t\t\t\t\t// Header: Enable access to inputs from Common tab\n                            // See https://www.shadertoy.com/view/ttf3R4\n                                #if __LINE__<17          // Must be on line 3!\n                                #define _ST_TAB_COMMON\n                                #endif\n                                #if __LINE__<25\n                                #define _ST_TAB_SOUND\n                                uniform vec3 iResolution; // Sound tab\n                                uniform float iTime;  // never defines these\n                                #endif\n                                #ifdef _ST_TAB_COMMON\n                                #undef _ST_TAB_SOUND\n                                uniform float iTimeDelta;\n                                uniform int iFrame;\n                                uniform float iChannelTime[4];\n                                uniform vec3 iChannelResolution[4];\n                                uniform vec4 iMouse;\n                                // iDate and iSampleRate: Alread have them.\n                                uniform sampler2D iChannel0;\n                                uniform sampler2D iChannel1; // Change type to\n                                uniform sampler2D iChannel2; // samplerCube\n                                uniform sampler2D iChannel3; // if Cube input\n                                #endif\n                            // End header\n\n// define LOW_DETAIL_MODEL to 1 if the rendering is too slow\n#define LOW_DETAIL_MODEL 0\n\n#define PI 3.14 \n#define FOCAL_LENGTH 1.5\n#define MAX_MARCHING_DISTANCE 10.\n\n// Translate \nmat4 Translate(float Tx, float Ty, float Tz) \n{\n\treturn mat4(\n  \t\t1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        Tx, Ty, Tz, 1.\n    );\n}\n\n// Rotate a vector of an angle around the x-axis\nmat4 RotateX(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n        1., 0., 0., 0.,\n        0., c,  s, 0.,\n        0., -s,  c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\n// Rotate a vector of an angle around the x-axis\nmat4 RotateY(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n         c, 0., -s, 0.,\n        0., 1., 0., 0.,\n         s, 0.,  c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\n// Rotate a vector of an angle around the x-axis\nmat4 RotateZ(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n         c,  s, 0., 0,\n        -s,  c, 0., 0,\n        0., 0., 1., 0,\n        0., 0., 0., 1\n    );\n}\n\n// Scale a vector along the x, y or z axis\nmat4 Scale(float Sx, float Sy, float Sz) \n{\n    return mat4(\n        Sx, 0., 0., 0,\n        0., Sy, 0., 0,\n        0., 0., Sz, 0,\n        0., 0., 0., 1\n    );\n}\n\n// Signed Distance Fields function (tnx https://iquilezles.org/articles/distfunctions)\nfloat SD_OpUnion( float d1, float d2 ) \n{  \n    return min(d1,d2); \n}\n\nfloat SD_OpSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat SD_OpSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat SD_Sphere(vec3 P, float r) \n{\n\treturn length(P) - r;\n}\n\nfloat SD_Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// checkers, tnx https://iquilezles.org/articles/checkerfiltering\nfloat checkers( in vec2 p )\n{\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n\n// fog, tnx https://iquilezles.org/articles/fog\nvec3 applyFog(vec3 rgb, float distance) \n{\n    float fogAmount = 1.0 - exp( -(distance)*0.05);\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n// Stores the info about a ray hit\nstruct Hit\n{\n    int objId;\n    float d;\n    vec3 point;\n    vec3 normal;\n    vec3 tangent;\n    vec3 binormal;\n};\n    \n// Signed Distance Function of the high detail model\nHit SD_HighDetailModel(vec3 P) \n{\n    Hit hit;\n    hit.point = P;\n    \n    float d = SD_Sphere(P, 2.);\n    hit.d = d; hit.objId = 1;\n    \n    vec4 P_t;\n    float d1;\n    float sinTime = sin(iTime);\n    P_t = Translate(0., 0., 1.9)*RotateY(PI/2.0)*vec4(P,1.);\n    mat4 M = RotateX(PI/2.0)*Translate(0., 0., 2.0);\n    for(int i=0; i<4; i++)\n    {\n        P_t = M*RotateY(PI/2.0*float(i))*vec4(P,1.);\n        float t = sinTime;\n        if(t>0.0) \n        {\n            d1 = SD_Torus(P_t.xyz, vec2(0.3*t, 0.1*t));\n            d = SD_OpSmoothUnion(d1, d, 0.1);\n        }\n        else\n        {\n            d1 = SD_Torus(P_t.xyz, vec2(0.3*-t, 0.1*-t));\n            d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        }\n    }\n    for(int i=0; i<4; i++)\n    {\n        P_t = M*RotateY(PI/4.0+PI/2.0*float(i))*vec4(P,1.);\n        float t = sinTime;\n        if(t>0.0) \n        {\n            d1 = SD_Torus(P_t.xyz, vec2(0.3*t, 0.1*t));\n            d = SD_OpSmoothUnion(d1, d, 0.1);\n        }\n        else\n        {\n            d1 = SD_Torus(P_t.xyz, vec2(0.3*-t, 0.1*-t));\n            d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        }\n    }\n    \n    \n    if(LOW_DETAIL_MODEL == 0) \n    {\n        float c = sinTime/20.0+0.2;\n        M = M*RotateX(PI/8.0+PI/4.0*float(3));\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(1))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(2))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(3))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(4))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(5))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(6))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(7))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(8))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n\n        M = M*RotateX(PI/8.0+PI/4.0*float(4));\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(1))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(2))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(3))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(4))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(5))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(6))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(7))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(8))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothUnion(d1, d, 0.1);\n        \n        M = M*RotateX(PI/8.0+PI/4.0*float(7));\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(1))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(2))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(3))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(4))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(5))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(6))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(7))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n        P_t = M*RotateY(PI/8.0+PI/4.0*float(8))*vec4(P,1.);\n        d1 = SD_Sphere(P_t.xyz, c );\n        d = SD_OpSmoothSubtraction(d1, d, 0.1);\n    }\n    \n    hit.d = d; hit.objId = 1;\n    return hit;\n}\n\n// Signed Distance Function of the low detail model\nHit SD_LowDetailModel(vec3 P) \n{\n    Hit hit;\n    hit.point = P;\n    \n    float d = SD_Sphere(P, 2.);\n    hit.d = d; hit.objId = 1; \n    \n    return hit;\n}\n\n// Compute the normals at P for the high detail model\nvec3 normalHighDetailModel(vec3 P)\n{\n\tvec2 eps = vec2(0.,0.001);\n    return normalize(vec3(\n        SD_HighDetailModel(P+eps.yxx).d - SD_HighDetailModel(P-eps.yxx).d, \n\t\tSD_HighDetailModel(P+eps.xyx).d - SD_HighDetailModel(P-eps.xyx).d, \n        SD_HighDetailModel(P+eps.xxy).d - SD_HighDetailModel(P-eps.xxy).d));\n}\n\n// Compute the normals at P for the low detail model\nvec3 normalLowDetailModel(vec3 P)\n{\n\tvec2 eps = vec2(0.,0.001);\n    return normalize(vec3(\n        SD_LowDetailModel(P+eps.yxx).d - SD_LowDetailModel(P-eps.yxx).d, \n\t\tSD_LowDetailModel(P+eps.xyx).d - SD_LowDetailModel(P-eps.xyx).d, \n        SD_LowDetailModel(P+eps.xxy).d - SD_LowDetailModel(P-eps.xxy).d));\n}\n\n// Compute the tangent (i.e. the vector perpendicular to the normal vector N)\n// The tangent is used to build the basis of the tangent space along with the normal and the binormal.\nvec3 tangent(vec3 N) \n{\n    vec3 T, B;\n\tif(N.x == .0 && N.z == .0) T = vec3(0.,0.,.1);\n    if(N.z == .0) T = vec3(0.,0.,-1.);\n    else \n    {\n        float l = sqrt(N.x*N.x+N.z*N.z);\n    \tT.x = N.z/l;\n        T.y = .0;\n        T.z = -N.x/l;\n    }\n    return T;\n}\n\n\n// A material specification\nstruct Material \n{\n\tfloat shininess; \n    vec3 fresnelR0;\n    vec3 diffuseAlbedo;\n};\n\n// Get the material for the mesh with the corresponding id\nMaterial material(int id) \n{\n    Material mat;\n    if(id == 0) \n    { \n        // Background\n    \tmat.shininess = 0.1;\n    \tmat.fresnelR0 =\tvec3(0.08,0.08,0.08);\n        mat.diffuseAlbedo = vec3(1.0,1.0,1.0);\n    }\n    if(id == 1)\n    {\n    \t// Object\n    \tmat.shininess = 0.4;\n    \tmat.fresnelR0 =\tvec3(0.95,0.64,0.54);\n        mat.diffuseAlbedo = vec3(0.9,0.9,0.90);\n    }\n\t\n\n    return mat;\n}\n\n// Ray march the high detailed model.\nHit RayMarchHighDetailModel(vec3 ro, vec3 dir) \n{\n    vec3 P = vec3(0.,0.,0.);\n    float t = 0.;\n    Hit hit;\n    while(t < MAX_MARCHING_DISTANCE) \n    {\n        P = ro + t*dir;\n        hit = SD_HighDetailModel(P);\n        if((hit.d)<0.01) break;\n        t+=hit.d;\n    }\n    \n    if(t < MAX_MARCHING_DISTANCE) \n    {\n        hit.normal = normalHighDetailModel(P);\n        hit.tangent = tangent(hit.normal);\n        hit.binormal = normalize(cross(hit.normal, hit.tangent));\n    }\n    else\n    {\n        hit = Hit(-1, MAX_MARCHING_DISTANCE,vec3(0.),vec3(0.),vec3(0.),vec3(0.));\n    }\n        \n    return hit;\n}\n\n// Ray march the low detailed model.\nHit RayMarchLowDetailModel(vec3 ro, vec3 dir) \n{\n    vec3 P = vec3(0.,0.,0.);\n    float t = 0.;\n    Hit hit;\n    while(t < MAX_MARCHING_DISTANCE) \n    {\n        P = ro + t*dir;\n        hit = SD_LowDetailModel(P);\n        if((hit.d)<0.01) break;\n        t+=hit.d;\n    }\n    \n    if(t < MAX_MARCHING_DISTANCE)\n    {\n            hit.normal = normalLowDetailModel(P);\n            hit.tangent = tangent(hit.normal);\n            hit.binormal = normalize(cross(hit.normal, hit.tangent));\n    }\n    else \n    {\n        hit = Hit(-1, MAX_MARCHING_DISTANCE,vec3(0.),vec3(0.),vec3(0.),vec3(0.));\n    }\n    \n    return hit;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 BakeNormalTangentSpace(float theta, float phi) \n{   \n    vec3 dir = vec3(sin(theta)*sin(phi), cos(phi), -sin(phi)*cos(theta));\n    vec3 ro = dir*10.;\t// The ray starts outside the models\n    //vec3 ro = vec3(0.,0.,0.);\n    Hit hP = RayMarchHighDetailModel(ro, -dir);\n    Hit lP = RayMarchLowDetailModel(ro, -dir);\n\n    vec3 N_ts; \n    mat3 M_ts_ws = mat3(lP.binormal,lP.tangent,lP.normal);\n    N_ts = inverse(M_ts_ws)*hP.normal;\n    return vec4(normalize(N_ts) * 0.5 + 0.5, .1);\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepTheta = (2.*PI)/iResolution.x;\n    float stepPhi = (PI/iResolution.y);\n\tfloat theta = fragCoord.x * stepTheta;\n    float phi = fragCoord.y * stepPhi;\n\n    fragColor = BakeNormalTangentSpace(theta, phi);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Saving the normals in wolrd space is made only for visualization purpouses\nvec4 BakeNormalWorldSpace(float theta, float phi) \n{   \n    vec3 dir = vec3(sin(theta)*sin(phi), cos(phi), -sin(phi)*cos(theta));\n    vec3 ro = dir*10.;\t// The ray starts outside the models\n    Hit hP = RayMarchHighDetailModel(ro, -dir);\n    \n    return vec4(normalize(hP.normal) * 0.5 + 0.5, .1);\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepTheta = (2.*PI)/iResolution.x;\n    float stepPhi = (PI/iResolution.y);\n\tfloat theta = fragCoord.x * stepTheta;\n    float phi = fragCoord.y * stepPhi;\n\n    fragColor = BakeNormalWorldSpace(theta, phi);\n}","name":"Buffer B","description":"","type":"buffer"}]}