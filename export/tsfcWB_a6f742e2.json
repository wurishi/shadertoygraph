{"ver":"0.1","info":{"id":"tsfcWB","date":"1585512729","viewed":192,"name":"Solaris (atz)","username":"ilyaev","description":"Solaris","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define FAR_DISTANCE 4.\n#define MIN_DISTANCE 0.0001\n#define SPEED .2\n#define SHOW_FRAME true\n#define SHOW_FULL_PLANET false\n#define PLANET_LAND_COLOR vec3(0.3, .3, .1)\n#define PLANET_OCEAN_COLOR vec3(0., 0., .5)\n#define PLANET_SNOW_COLOR vec3(.5, .2, .1)\n#define PLANET_CLOUD_COLOR vec3(1., 1., 1.) * .6\n#define PLANET_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define SPACE_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define PLANET_DEEP_COLOR vec3(0., 0., 0.3)\n#define PI 3.14\n#define SUN_COLOR vec3(0.9, .3, .1)\n#define ECLIPSE_COLOR vec3(0., 1., 0.)\n#define SECOND_SUN_COLOR vec3(0.5, 0.2, .90)\n\nstruct sEclipse {\n    vec3 color;\n    float d;\n    float shift;\n};\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898 + .00019, 4.1414))) * 43759.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nfloat noise(vec2 p){\n    // p += iTime;\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm2( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p); p = m2*p*2.02;\n    f += 0.2500*noise( p); p = m2*p*2.03;\n    f += 0.1250*noise( p); p = m2*p*2.01;\n    f += 0.0625*noise( p);\n\n    return f/0.9375;\n}\n\nvec3 getOceanTexture(vec2 uv) {\n    return fbm2(uv*4. * fbm2(uv*4. * fbm2(uv*2. + vec2(0., iTime/10.)) + iTime/10.)) * PLANET_OCEAN_COLOR * 5.;\n    // return PLANET_OCEAN_COLOR;\n}\n\n\nvec3 getPlanetTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n    float size = 450.;\n\n    vec2 guv = uv;\n\n    uv *= size;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    // float n = noise(id/500. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED), 5) * .6;\n    float n = fbm2(id/150. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED));//* clamp(sin(iTime) * .5 + .5, .7, 1.);\n    n *= 1.3;\n    // n = fract(n * 1.);\n    float deep = smoothstep(.12, .13, n*.8);\n    float snow = smoothstep(0.57, 0.58, n);\n    float ocean = clamp(n-.1, 0., 1.);\n\n    vec3 oceanTexture = getOceanTexture(guv);\n\n    vec3 land = mix(oceanTexture, PLANET_LAND_COLOR, smoothstep(0.4, 0.41, n));\n\n    col += mix(\n        PLANET_SNOW_COLOR,\n        mix(land, land * 6., pow(abs(n - .35), .4))/2.5,\n        1. -snow\n    );\n\n    col = (1. - step(0.001, col)) * oceanTexture + col;\n\n    col = mix(PLANET_DEEP_COLOR, col, deep);\n\n    if (n < .4 && n > .12) {\n        col *= .6;\n    }\n\n    vec2 cuv = vec2(atan(guv.x*2., guv.y*4.), length(guv) ) ;\n    float aa = iTime/512.;\n    vec2 cid = floor((cuv*mat2(vec2(sin(aa), cos(aa)), vec2(-cos(aa), sin(aa))))*450.);\n\n    float cloudN = noise(cid/150. + iTime/16. * SPEED, 5);\n    vec3 cloudColor = PLANET_CLOUD_COLOR;\n\n    if (n < .12) {\n        cloudColor *= 1.1;\n        cloudColor.rb *= 1.2;\n    }\n\n\n    // col = vec3(0.);\n    col = mix(cloudColor, col, smoothstep(.2, .6 + sin(iTime/32. + cos(iTime*SPEED*cuv.x + sin(iTime/32.)))*.2, cloudN));\n    // col = oceanTexture;\n\n    return col;\n}\n\nsEclipse getEclipse(vec2 uv, vec2 center, float stage) {\n    vec3 col = vec3(0.);\n\n    float size = .1;\n\n    vec2 moonPosition = vec2(stage * size * 2. + sin(iTime*.0)*.1, 0.) + center;\n    vec2 sunPosition = vec2(0., 0.) + center;\n\n    float moonD = length(uv - moonPosition);\n    float sunD = length(uv - sunPosition);\n\n    float shift = length(moonPosition - sunPosition);\n\n\n    vec3 sun_color = mix(ECLIPSE_COLOR, SUN_COLOR, pow(shift/.2, .3));\n\n    float a = atan(uv.x - center.x, uv.y - center.y)*1.;\n\n    float n = fbm2((vec2(sin(a), cos(a)) + iTime/12.) * mix(.5, 3.5, shift/.2)) * clamp(mix(1., 3.5, shift/.2), 1., 2.);\n\n    float sunSize = size + clamp(n*(.2*(1. - pow(shift/.08, .3))), 0., 10.);\n\n    vec3 sun = pow(sunSize/sunD, 11. - clamp((shift * 30.), 0., 10.)) * sun_color;\n\n    vec3 moon = step(moonD, size * .98) * vec3(.0);\n\n    col = mix(moon, sun, smoothstep(size*.9, size, moonD));\n    sEclipse res;\n    res.color = col;\n    res.d = sunD;\n    res.shift = shift;\n    return res;\n}\n\nvec3 getStars(vec2 guv) {\n    float a = iTime / 50.;\n    guv -= .2;\n    guv *= mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n    guv += .2;\n    guv *= 15.;\n    vec2 uv = fract(guv) - .5;\n    vec2 id = floor(guv);\n    vec3 col = vec3(0.);\n\n    for(int x = -1 ; x <= 1 ; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 cid = id + offset;\n            float n = n21(cid);\n            vec2 shift = vec2(n, fract(n * 123.43))-.5;\n            float d = length(uv - offset - shift);\n            if (fract(n * 5543.234) > .8) {\n                col = max(col, smoothstep(.1, .9, (.005 + .02 * fract(n*32342.22))/d)) * (.7 + 0.3 * fract(n*4443322.33));\n            }\n        }\n    }\n\n\n    return col;\n}\n\nvec3 getSecondSun(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float d = pow(.1/length(uv), 1.9) * .3;\n\n    col += d;\n\n    return col * SECOND_SUN_COLOR;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 guv = uv;\n\n    float wobble = sin(iTime + cos(iTime/2.))*.005;\n\n    if (!SHOW_FULL_PLANET) {\n        uv.y += 1.35 + wobble;\n    }\n\n\n    vec3 col = vec3(0.0);\n\n    float a = 2.5;\n    vec3 ro = vec3(0. + sin(a), 0.+cos(a), -1);\n    vec3 lookat = vec3(0.05, .0, 0.);\n\n    float zoom = 22.;\n\n    if (SHOW_FULL_PLANET) {\n         zoom = 4.;\n         ro = vec3(0., 0., -1);\n         lookat = vec3(0.);\n    }\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0., 0., 0.);\n\n    float d = length(cross(rd, p - ro))/length(rd);\n\n    vec3 ds, dt;\n    float sd;\n    int steps;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n        steps += 1;\n\n        sd = length(p) - .0999;\n\n        ds += sd;\n\n        if (sd < MIN_DISTANCE || sd > FAR_DISTANCE) {\n            break;\n        }\n    }\n\n    vec3 globe = vec3(0.);\n    vec2 wuv = guv + vec2(0., wobble);\n\n    sEclipse eclipse = getEclipse(wuv * 2., vec2(-0.6, .65), 1. - sin(iTime/10.));\n\n    vec3 spaceGlowColor = mix(PLANET_GLOW_COLOR, vec3(SUN_COLOR), eclipse.shift / .1);\n\n    if (sd < MIN_DISTANCE) {\n        float x = acos(p.y/length(p));\n        float y = atan(p.z, p.x);\n        vec2 uv = vec2(x, y);\n        globe += smoothstep(.0, 1., clamp(float(steps)/40., 0., 1.))* .3 * spaceGlowColor * .8;\n        globe += getPlanetTexture(uv);\n    } else {\n\n        if (!SHOW_FULL_PLANET) {\n            col += eclipse.color;\n            col += getStars(wuv) * clamp(eclipse.d*2., 0., 1.);\n            col += getSecondSun(wuv + vec2(-0.4, .1));\n        }\n    }\n\n    float glowMask = 1. - mix(smoothstep(.20, .02, d*1.5), .0, step(d, .1)) * .8;\n    float planetGlowMask = (1. - smoothstep(.1, .11, d*1.07))*smoothstep(.1, .11, d*1.02)*3.;\n\n    globe += (1. - glowMask) * mix(PLANET_GLOW_COLOR, spaceGlowColor, eclipse.shift / .4) + (planetGlowMask * PLANET_GLOW_COLOR);\n\n    col += globe;\n\n    if (SHOW_FRAME) {\n        d = length(guv);\n        col *= step(d, .7);\n        vec3 frame = (step(d, .71) - step(d, .70)) * vec3(.8);\n        col += frame;\n    }\n\n    fragColor = vec4(col, 1.);\n\n}","name":"Image","description":"","type":"image"}]}