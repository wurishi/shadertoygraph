{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 computeLocalSphereLighting(vec3 p, vec3 n) {\n    vec3 col = vec3(0.0);\n\n    vec3 voxelPos = worldToVoxel(p.xyzz).xyz; \n    ivec3 basePos = ivec3(floor(voxelPos));\n\n    vec4 distances = vec4(FLOAT_INF);     \n    uvec4 indices = uvec4(uint(-1));   \n\n    for(int z = -1; z <= 1; z++) {\n        for(int y = -1; y <= 1; y++) {\n            for(int x = -1; x <= 1; x++) {\n                \n                ivec3 sampleCoord = basePos + ivec3(x, y, z);\n                uvec4 fetchedClosest = fetchClosest3D(vec3(sampleCoord), iChannel1);\n\n                for(int j = 0; j < 4; j++) {\n                    uint sphereIdx = fetchedClosest[j];\n                    if (sphereIdx == uint(-1) || any(equal(indices, uvec4(sphereIdx)))) {\n                        continue;\n                    } \n\n                    vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n                    vec3 sphereCenter = e.xyz;\n                    float sphereRadius = e.w;\n\n                    float dist = length(sphereCenter - p) - sphereRadius;\n\n                    if(dist < distances.x) {\n                        distances = vec4(dist, distances.x, distances.y, distances.z);\n                        indices = uvec4(sphereIdx, indices.x, indices.y, indices.z);\n                    }\n                    else if(dist < distances.y) {\n                        distances = vec4(distances.x, dist, distances.y, distances.z);\n                        indices = uvec4(indices.x, sphereIdx, indices.y, indices.z);\n                    }\n                    else if(dist < distances.z) {\n                        distances = vec4(distances.x, distances.y, dist, distances.z);\n                        indices = uvec4(indices.x, indices.y, sphereIdx, indices.z);\n                    }\n                    else if(dist < distances.w) {\n                        distances.w = dist;\n                        indices.w = sphereIdx;\n                    }\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < 4; i++) {\n        uint sphereIdx = indices[i];\n        if(sphereIdx == uint(-1)) continue; \n\n        vec3 ballCol = vec3(\n            xorshiftFloat(sphereIdx * 12345u), \n            xorshiftFloat(sphereIdx * 34567u), \n            xorshiftFloat(sphereIdx * 56789u)\n        );\n\n        vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n        vec3 sphereCenter = e.xyz;\n        float sphereRadius = e.w;\n\n        vec3 emissionColor = ballCol;\n        float emissionPower = 0.00175; \n\n        vec3 L = sphereCenter - p + n * 0.03;\n        float dist = length(L);\n        if(dist < 0.0001) continue;\n        vec3 lDir = L / dist;\n\n        float NoL = max(dot(n, lDir), 0.0);\n        float falloff = 1.0 / (dist * dist);\n        col += emissionColor * emissionPower * NoL * falloff;\n    }\n\n    return col;\n}\n\n\n\nfloat getSpheres(vec3 p) {\n    vec3 voxelPos = worldToVoxel(p.xyzz).xyz;\n    ivec3 basePos = ivec3(floor(voxelPos));\n    uint index = 0u;\n    float vol = 0.0;\n    float shapeD = 999.0;\n\n                ivec3 sampleCoord = basePos;\n                uvec4 fetchedClosest = fetchClosest3D(vec3(sampleCoord), iChannel1);\n                for (int j = 0; j < 4; j++) {\n                    uint sphereIdx = fetchedClosest[j];\n                    if(sphereIdx == uint(-1)) { continue; }\n\n                    vec4 e = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n                    e.w *= 0.5;\n                    float dist = length(p - e.xyz) - e.w;\n                    shapeD = min(dist, shapeD);\n\n  \n    }\n\n\n\n    return shapeD;\n}\n\n\nfloat fullScene(vec3 p) {\n    return smin(scene2(p), getSpheres(p), 0.01);\n}\n\n\nfloat raymarchMapStart(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 24; i++) {\n        vec3 p = ro + rd * t;\n        float shapeD = scene0(p);\n                \n        if(shapeD < 0.01)  return t;\n        t += shapeD;\n        if(t > 6.0)  break;  \n    }\n \n    return t;\n}\n\nfloat raymarchMap(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 32; i++) {\n        vec3 p = ro + rd * t;\n        float shapeD = fullScene(p);\n                \n        if(shapeD < 0.005)  return t;\n        t += shapeD;\n        if(t > 6.0)  break;  \n    }\n \n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = fullScene(p);\n    vec2 e = vec2(.002, 0);\n    \n    vec3 n = d - vec3(\n        fullScene(p-e.xyy),\n        fullScene(p-e.yxy),\n        fullScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x  *= aspect;\n\n\n    bool groundTruth = true;\n\n    vec2 uvCam = uv;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 rd = normalize(vec3(uvCam, -1.05));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\n    float yrot = 0.0;\n    float zrot =  iTime * 0.25;\n    if (iMouse.z > 0.0) {\n        yrot += -4.0 * mouse.y;\n        zrot = 4.0 * mouse.x;\n    }\n    rd = rotate(rd, vec3(1, 0, 0), yrot);\n    ro = rotate(ro, vec3(1, 0, 0), yrot);\n    rd = rotate(rd, vec3(0, 1, 0), zrot);\n    ro = rotate(ro, vec3(0, 1, 0), zrot);\n    \n    \n    float t0 = raymarchMapStart(ro, rd);\n    float t = raymarchMap(ro + rd * t0, rd);\n    vec4 background =  vec4(0.5, 0.5, 1.0, 1.0) * pow(length(uvCam), 0.33) * 0.5 * (hash(uvCam) * 0.1 + 0.9);\n\n    if(t > 6.0) {\n        fragColor = vec4(0.02);\n        return;\n    }\n\n\n    vec3 p = ro + rd * (t + t0);\n    vec3 nor = getNormal(p);  \n    vec3 lp =  vec3(1.0);\n    vec3 green = vec3(0.2, 0.6, 0.2);\n\tvec3 diff = max(dot(nor, normalize(lp)), 0.0) * green * mix(0.1, 0.0, smoothstep(-0.5, -0.6, p.y));\n    diff += computeLocalSphereLighting(p, nor);\n    //diff = nor;\n   \n    vec3 col = max(diff, 0.02);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define N_SPHERES 800\n#define MIN_RADIUS 0.01\n#define PI 3.14159265359\n\nint seed = 93726;\nint randInt() { seed = seed*0x343fd + 0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(randInt())/32767.0; }\n\nvoid srand( ivec2 p, int frame ) {\n    int n = frame;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589; \n    n += p.y;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\nvec3 randomOnSphere( void ) {\n    float theta = (6.283185 / 32767.0) * float(randInt());\n    float u = (2.0 / 32767.0) * float(randInt()) - 1.0;\n    return vec3(sqrt(max(0.0, 1.0 - u * u)) * vec2(cos(theta), sin(theta)), u);\n}\n\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);   \n}\n\n\nfloat hash(float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nfloat xorshiftFloat(uint state) {\n    return float(xorshift(state)) / float(0xffffffffU);\n}\n\nfloat smin(float a, float b, float k) \n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h*h*k*0.25;\n}\n\n\nfloat dot2(vec2 a) { return dot(a, a); }\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb ) {\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat scene2(vec3 pp) {\n    vec3 p = pp;\n    p.y += 0.6;\n    float stepSize = 0.25;\n    vec3 q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    float repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    float scaleFactor = 0.2;\n\n    float scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    float a = sdCappedCone(q - vec3(0.0, 0.1, 0.0), 0.7, 1.0 * (scale * 0.75 + 0.25), 0.001) - 0.05;\n\n    float noiseScale = 40.0;     \n    float noiseAmplitude = 0.05;\n    float r = atan(q.x, q.z);\n    float noise1 = noise(vec2(r * scale, p.y) * noiseScale);\n    float noise2 = noise(vec2(r * scale, p.y) * noiseScale * 1.5);\n    float dis = sin(r * 8.0  * PI + repIndex * PI) * (length(p.xz) / scale);\n    \n    p.y += 0.1;\n    q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    // q.y += length(q.xz) * 0.075;\n    repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    a = smin(a, sdRoundedCylinder(q, 0.365 * (scale * 0.6 + 0.4), 0.01, 0.01), 0.1);\n\n    a = a + (dis * 0.02 + noise1 * noiseAmplitude + noise2 * noiseAmplitude * 0.5);\n    a = smin(a, ((p.y) + 0.1), 0.05);\n\n    return a;\n}\n\nfloat scene0(vec3 pp) {\n    vec3 p = pp;\n    p.y += 0.6;\n    float stepSize = 0.25;\n    vec3 q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    float repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    float scaleFactor = 0.2;\n\n    float scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    float a = sdCappedCone(q - vec3(0.0, 0.1, 0.0), 0.7, 1.0 * (scale * 0.75 + 0.25), 0.01) - 0.05;\n\n    p.y += 0.1;\n    q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    // q.y += length(q.xz) * 0.075;\n    repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    a = smin(a, sdRoundedCylinder(q, 0.365 * (scale * 0.6 + 0.4), 0.01, 0.01), 0.1);\n\n    a *= smoothstep(0.0, 0.4, p.y);\n    a = smin(a, ((p.y) + 0.1), 0.1);\n    a -= 0.04;\n    \n    return a;\n }\n \n\nfloat scene(vec3 pp) {\n    vec3 p = pp;\n    p.y += 0.6;\n    float stepSize = 0.25;\n    vec3 q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    float repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    float scaleFactor = 0.2;\n\n    float scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    float a = sdCappedCone(q - vec3(0.0, 0.1, 0.0), 0.7, 1.0 * (scale * 0.75 + 0.25), 0.001) - 0.05;\n\n    p.y += 0.1;\n    q = opRepLim(p, stepSize, vec3(0.0), vec3(0.0, 4.0, 0.0));\n    q.xz = abs(q.xz);\n    // q.y += length(q.xz) * 0.075;\n    repIndex = floor(max(p.y + stepSize * 0.5, 0.0) / stepSize);\n    scale = 1.0 - min(repIndex, 4.0) * scaleFactor;\n    scale = mix(scale, smoothstep(2.0, 0.0, p.y), 0.25);\n    a = smin(a, sdRoundedCylinder(q, 0.365 * (scale * 0.6 + 0.4), 0.01, 0.01), 0.1);\n\n    a = max(a, -((p.y) + 0.01));\n\n    a -= 0.02;\n    a = abs(a) - 0.02;\n    \n    return a;\n }\n \n\n\n#define PI2      6.28318531\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\nconst ivec3 iResolution3D = ivec3(64);\n\n\nconst uint PARTICLE_COUNT = uint(N_SPHERES);\nconst int slicesPerRow = 8;\n\nvec4 worldToVoxel(vec4 raw) {\n    return (raw + 3.0) * (1.0 / 6.0) * vec4(iResolution3D.x);\n}\n\nvec4 decodeEntity3D(sampler2D sampler, uint particleIndex)  {\n    ivec2 texCoord = ivec2(particleIndex, 0);\n    vec4 raw = texelFetch(sampler, texCoord, 0);\n\n    return worldToVoxel(raw);\n}\n\nivec3 to3D(uint flatId, ivec3 volumeSize) {\n    int x = int(flatId % uint(volumeSize.x));\n    int yz = int(flatId / uint(volumeSize.x));\n    int y = yz % volumeSize.y;\n    int z = yz / volumeSize.y;\n    return ivec3(x, y, z);\n}\n\nuint to1D(ivec3 coord, ivec3 volumeSize) {\n    return uint(coord.x) \n         + uint(coord.y) * uint(volumeSize.x)\n         + uint(coord.z) * uint(volumeSize.x * volumeSize.y);\n}\n\n\nivec2 to2D(uint flatId, ivec3 volumeSize) {\n    ivec3 c3D = to3D(flatId, volumeSize);\n    int sliceIndex = c3D.z;\n    int row = sliceIndex / slicesPerRow;\n    int col = sliceIndex % slicesPerRow;\n    return ivec2(c3D.x + col * volumeSize.x, c3D.y + row * volumeSize.y);\n}\n\n\nivec3 from2D(ivec2 texCoord, ivec3 volumeSize) {\n    int col = texCoord.x / volumeSize.x;\n    int x = texCoord.x % volumeSize.x;\n    int y = texCoord.y % volumeSize.y;\n    int z = col + (texCoord.y / volumeSize.y) * slicesPerRow;\n    return ivec3(x, y, z);\n}\n\n\nuvec4 fetchClosest3D(vec3 position, sampler2D voroBuffer) {\n    ivec3 ipos = ivec3(clamp(floor(position), vec3(0.0), vec3(iResolution3D) - 1.0));\n    \n    uint flatId = to1D(ipos, iResolution3D);\n    ivec2 texCoord2D = to2D(flatId, iResolution3D);\n    \n    return floatBitsToUint(texelFetch(voroBuffer, texCoord2D, 0));\n}\n\nvoid sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec3 center,\n        sampler2D iChannel0\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    vec4 e = decodeEntity3D(iChannel0, index);\n    float dist = length(center - e.xyz) - e.w;\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle) {\n    return mix(dot(p, axis) * axis, p, cos(angle)) + sin(angle) * cross(axis, p);\n}\n\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float getAvailableSpaceSDF(vec3 p, int currentIndex) {\n    float shapeSDF = scene(p);\n    \n    uvec4 fetchedClosest = fetchClosest3D(worldToVoxel(p.xyzz).xyz, iChannel1);\n\n    for(int i = 0; i < 4; i++) {\n        uint sphereIdx = fetchedClosest[i];\n        if(sphereIdx == uint(-1)) { continue; }\n        vec4 circle = texelFetch(iChannel0, ivec2(sphereIdx, 0), 0);\n        if(circle.w <= 0.0) continue;\n\n        float currentCircleSDF = length(p - circle.xyz) - circle.w * 4.0;\n        shapeSDF = max(-currentCircleSDF, shapeSDF);\n    }\n    \n    \n    for(int i = 0; i < (currentIndex % 4); i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(i, 0), 0);\n        if(circle.w <= 0.0) continue;\n        \n        float currentCircleSDF = length(p - circle.xyz) - circle.w * 4.0;\n        \n        shapeSDF = max(-currentCircleSDF, shapeSDF);\n    }\n    \n    return shapeSDF;\n}\n\nvec4 gtSDG(vec3 pos) {\n    float eps = 0.02;\n    vec3 n;\n    float d = scene(pos);\n    n.x = scene(vec3(pos.x + eps, pos.y, pos.z)) - d;\n    n.y = scene(vec3(pos.x, pos.y + eps, pos.z)) - d;\n    n.z = scene(vec3(pos.x, pos.y, pos.z + eps)) - d;\n\n    return vec4(n, d);\n}\n\nvec3 availableSpaceSDG(vec3 pos, int currentIndex) {\n    float eps = 0.02;\n    vec3 n;\n    float d = getAvailableSpaceSDF(pos, currentIndex);\n    n.x = getAvailableSpaceSDF(vec3(pos.x + eps, pos.y, pos.z), currentIndex) - d;\n    n.y = getAvailableSpaceSDF(vec3(pos.x, pos.y + eps, pos.z), currentIndex) - d;\n    n.z = getAvailableSpaceSDF(vec3(pos.x, pos.y, pos.z + eps), currentIndex) - d;\n\n    return n;\n}\n\nvec3 snapToMedialAxis(vec3 candidate, int currentIndex) {\n    vec3 pos = candidate;\n    float s = 0.1;   \n    float alpha = 0.1;  \n    float beta = 0.5;    \n\n    for(int iter = 0; iter < 32; iter++) {\n        vec3 g = gtSDG(pos).xyz; \n        float mg = length(g);        \n        if(mg < 1e-4) break; \n        \n        vec3 dir = g / mg;\n        \n        float currentSDF = getAvailableSpaceSDF(pos, currentIndex);        \n        float stepSize = s;\n        bool stepAccepted = false;\n\n        while(stepSize > 1e-4) {\n            vec3 newPos = pos - stepSize * dir;            \n            float newSDF = getAvailableSpaceSDF(newPos, currentIndex);\n            \n            if(newSDF <= currentSDF - alpha * stepSize * mg) {\n                pos = newPos;\n                stepAccepted = true;\n                break;\n            }\n            \n            stepSize *= beta;\n        }\n        \n        if(!stepAccepted) {\n            break;\n        }\n        \n        s = stepSize;\n    }\n    \n    return pos;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    if(fragCoord.y > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    int circleIndex = int(fragCoord.x);\n    \n    if(circleIndex >= N_SPHERES) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 oldData = texelFetch(iChannel0, ivec2(circleIndex, 0), 0);\n    vec3 center = oldData.xyz;\n    float radius = oldData.w;\n    \n    if(circleIndex > iFrame) {\n        fragColor = oldData;\n        return;\n    }\n    \n    srand(ivec2(fragCoord), iFrame);\n    if(circleIndex == iFrame && iFrame < N_SPHERES) {\n        float bestScore = -1.0;\n        vec3 bestPos = randomOnSphere() * frand();\n        \n        for(int c = 0; c < 16; c++) {\n            vec3 candidate;\n            float spaceSDF = 0.0;\n            \n            candidate = bestPos + randomOnSphere() * frand() * frand() * mix(0.05, 1.0, float(c) / 7.0);\n            spaceSDF = getAvailableSpaceSDF(candidate, circleIndex);\n\n            if(spaceSDF > 0.1) {\n                vec3 g = availableSpaceSDG(candidate, circleIndex);\n                candidate -= g * spaceSDF * 1.001;\n            }\n                        \n            float score = -spaceSDF;\n            \n            vec3 snapped = snapToMedialAxis(candidate, circleIndex);\n            float snappedSpaceSDF = getAvailableSpaceSDF(snapped, circleIndex);\n            float snappedScore = -snappedSpaceSDF;\n            \n            if(snappedSpaceSDF < 0.0 && snappedScore > score) {\n                candidate = snapped;\n                score = snappedScore;\n            }\n            \n            \n            if(score > bestScore) {\n                bestScore = score;\n                bestPos = candidate;\n            }\n        }\n        \n        if(bestScore > MIN_RADIUS) {\n            center = bestPos;\n            radius = max(bestScore, MIN_RADIUS);\n        } else {\n            center = vec3(0.0);\n            radius = 0.0;\n        }\n    }\n    fragColor = vec4(center, radius);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nvoid fetchAndSortClosest3D(\n    inout vec4 distances, \n    inout uvec4 indices,\n    in vec3 samplePoint,\n    in vec3 voxelCenter\n) {\n    uvec4 ids = fetchClosest3D(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, indices, ids[i], voxelCenter, iChannel0);\n    }\n}\n\n\nfloat randomFloat(inout uint state) {\n    state ^= state >> 16;\n    state *= 0x7feb352dU;\n    state ^= state >> 15;\n    state *= 0x846ca68bU;\n    state ^= state >> 16;\n    return float(state) / 4294967296.0;\n}\n\nvec3 randomDir3D(inout uint state) {\n    float z  = randomFloat(state) * 2.0 - 1.0;  // range [-1,1]\n    float az = randomFloat(state) * PI2;\n    float r  = sqrt(1.0 - z * z);\n    float x  = r * cos(az);\n    float y  = r * sin(az);\n    return vec3(x, y, z);\n}\n\nuint rngSeed = 314159265u;\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(fragCoord);\n    ivec2 maxSize = ivec2(slicesPerRow * iResolution3D.x);\n    if (any(greaterThanEqual(fc, maxSize))) {fragColor = vec4(0.0); return; }\n  \n    ivec3 cellCoord = from2D(fc, iResolution3D); \n    vec3 voxelCenter = vec3(cellCoord) + 0.5; \n    \n    vec4 bestDistances = vec4(FLOAT_INF);\n    uvec4 closestIndices = uvec4(uint(-1));\n    \n    if (iFrame == 0) {\n        closestIndices = uvec4(nextUint(), nextUint(), nextUint(), nextUint()) % 63u;\n    }\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    float rad = 3.0;\n\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n    fetchAndSortClosest3D(bestDistances, closestIndices, voxelCenter + randomDir3D(seed) * rad, voxelCenter);\n\n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, nextUint() % PARTICLE_COUNT, voxelCenter, iChannel0);\n    }\n    \n\n    fragColor = uintBitsToFloat(closestIndices);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 getNormal(vec3 p) {\n\tfloat d = scene2(p);\n    vec2 e = vec2(.05, 0);\n    \n    vec3 n = d - vec3(\n        scene2(p-e.xyy),\n        scene2(p-e.yxy),\n        scene2(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int j = int(fragCoord.x);\n    vec4 lastCircle = texelFetch(iChannel1, ivec2(j, 0), 0);\n    vec4 circle = texelFetch(iChannel0, ivec2(j, 0), 0);\n    float fun = 0.05;\n    vec3 n = getNormal(circle.xyz);\n    vec3 t = cross(n, rotate(vec3(1, 0, 0), vec3(0, 1, 0), iTime + float(j)));\n\n    \n    vec3 animation = t * 0.025;\n    circle.xyz += animation;\n    fragColor = circle;\n}","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"X3tyW7","date":"1735179964","viewed":267,"name":"Christmas Tree Packing","username":"luckyballa","description":"merry christmas!","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","christmas","sdf","light","sphere","particles","tree","point","packing","medialaxis","medial"],"hasliked":0,"parentid":"","parentname":""}}