{"ver":"0.1","info":{"id":"WljBWy","date":"1642775405","viewed":110,"name":"Lab 2 Sebastian Meredith","username":"smeredith116","description":"Learning shaders yayyyyyyy!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define colorRGB vec3\n#define colorRGBA vec4\n//Color \nvec4 colorScale(in vec2 fragCoord, in vec2 resolution)\n{\n    //return vec4(0.1,0.2,0.3,0.3);\n    // color is 0 to 1 and coord is 0 to res\n    // R and B -> horiz\n    // G and A -> vert\n    //return vec4(fragCoord, 0.0,1.0);\n   \n    // R  horiz\n    // G  vert\n    // return vec4(fragCoord, 0.0,1.0);\n    // final: red-green gradient\n    vec2 uv = fragCoord / resolution;\n    //return vec4(uv, 0.5 , 1.0);\n    //return vec4(uv, 0.25 , 1.0);\n    vec3 color = vec3(uv,0.25);\n    float alpha = 1.0;\n    return colorRGBA(color, alpha);\n}\n\nconst float lineScale = 40.0;\n//Got inspiration/learning from this guys effect. \n//I took time to learn how he did/what he did and tried to make a simplifed version that I could actually make without just copy pasting his work \n//Still Credits to:TheOnlyaaa\n//http://glslsandbox.com/e#40822.0\n//Full Screen Effect\nfloat Cube(vec2 pos)\n{\n    float radius = atan(pos.x, pos.y);\nfloat num = abs(pos.x) + abs(pos.y);\n    //float num = length(pos);\n    float curLine = floor(num * lineScale);\n    float speed = sin(curLine * 24.3);\n    float offset = fract(sin(speed));\n   \n    float c = step(.4, tan(radius + offset + speed * iTime ));\n   \n    float rnd = offset;\n    return c * rnd;\n}\n\n vec4 rotatingDiamonds(float a,float b,out vec4 fragColor, in vec2 fragCoord)\n {\n     vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n     vec4 finalOutput = vec4(Cube(uv), Cube(uv - a), Cube(uv), b);\n     return finalOutput;\n }\n\n//Circle\n vec4 circleEffect(out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float radius = 0.5;\n   \n    vec4  color = vec4(r,0.1+0.3*sin(iTime),1.0);\n//vec4 pixel;\n    //if((uv.x*uv.x)+(uv.y*uv.y) < (radius*radius))\n    //{\n    //  pixel = color;\n//fragColor = pixel;\n    vec4 white = vec4(0.0);\n    vec4 pixel;\n    pixel = white;\n    if(length(r) < radius*radius)\n    {\n        pixel =  color;\n    }\n   \n \n    fragColor = pixel;\n    return vec4(fragColor);\n}\n\n//CheckerBoard\nvec4 checkerBoard(out vec4 fragColor, in vec2 fragCoord)\n{\n    float sizeOf = 10.0;\n    vec2 Pos = floor(fragCoord/sizeOf);\n    float checker = mod(Pos.x + mod(Pos.y,2.0),2.0);\n    fragColor = checker * vec4(1.0,1.0,1.0,1.0);\n    return fragColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    //fragColor = colorScale(fragCoord,iResolution.xy);\n    //fragColor = checkerBoard(fragColor, fragCoord);\n    //fragColor = circleEffect(fragColor, fragCoord);\n    fragColor = rotatingDiamonds(0.003,1.0, fragColor, fragCoord);\n}\n\n\n// R, G, B, A = [0, 1]\n//fragColor = vec4(1.0,1.0,1.0,1.0);\n \n// Normalized pixel coordinates (from 0 to 1)\n//vec2 uv = fragCoord/iResolution.xy;\n\n// Time varying pixel color\n//vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n// Output to screen\n//fragColor = vec4(col,1.0);","name":"Image","description":"","type":"image"}]}