{"ver":"0.1","info":{"id":"DscGzr","date":"1676879828","viewed":89,"name":"Fork xor encryp ZhuElly 895","username":"ZhuElly","description":"xor encryption/hash variant/fork of shader \"Inverse Hash\" by PrzemyslawZaworski \n\nLeft Side: original textures (data in)\nCenter: hashed textures (data encrypted)\nRight Side: unhashed textures (data out)\n\nusing inherent properties of xor and some bluenoise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","inverse","hash","encode","rgba","seed","decode","reverse","uint","unhash"],"hasliked":0,"parentid":"mtl3R8","parentname":"xor encryption/hash demo"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// xor encryption/hash variant/fork of shader \"Inverse Hash\" by PrzemyslawZaworski @ https://www.shadertoy.com/view/Dts3z8\n// using inherent properties of xor, time and some bluenoise\n\nvec2 Hash(vec2 uv) \n{\n    return encry(uv);\n}\n// unhash = hash //\nvec2 Unhash(vec2 uv) \n{\n    return decry(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec4 color = vec4(0.0f);\n    vec4 og = textureLod(iChannel0, uv, 0.0f);\n    vec4 buffer = textureLod(iChannel1, uv, 0.0f);\n    \n    //vec2 k_uv = Hash(uv);\n    //color = textureLod(iChannel0, k_uv, 0.0f);\n    //uv.y = 1.0 - uv.y;\n    uv = Unhash(uv);\n    //uv.y = 1.0 - uv.y;\n    //color = vec4(uv.xy, 0.0, 0.0);\n    color = textureLod(iChannel0, uv + vec2(0.05), 0.0f);\n    \n    fragColor = vec4(uv.xy, 0.0, 0.0);\n    //fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float hw = 12.0;\nconst float hh = 6.0;\nconst int grid[72] = int[72](18,49,33,25,16,64,15,3,23,35,30,14,71,27,68,1,8,57,11,39,26,45,24,42,10,47,60,4,34,48,41,51,9,67,22,28,63,56,6,72,54,17,62,55,38,2,59,40,69,50,32,20,43,44,61,52,7,70,5,13,66,58,53,31,36,29,46,65,21,37,12,19);\n\nvec2 encry(vec2 uv)\n{\n    // The local length of each grid element, range [0, 1]\n    vec2 local_uv = vec2(fract(uv * vec2(hw, hh)));\n    // For example, 13 is selected\n    // p = (0, 1), range [0-11] [0-5]\n    ivec2 p = ivec2(floor(uv.x * hw), floor(uv.y * hh));\n    // length of single grid\n    vec2 leng = vec2(1.0/hw, 1.0/hh);\n    // index = 12, index is start from 0\n    int index = (p.y * int(hw) + p.x);\n    // Target switch index\n    int t_index = grid[index] - 1;\n    // Trying to convert index value to position vector2\n    ivec2 tp = ivec2(mod(float(t_index), hw), int(float(t_index) / hw));\n    return vec2(float(tp.x) * leng.x, float(tp.y) * leng.y) + (local_uv * leng);\n}\n\nvec2 decry(vec2 uv){\n    // The local length of each grid element, range [0, 1]\n    vec2 local_uv = vec2(fract(uv * vec2(hw, hh)));\n    // For example, 13 is selected\n    // p = (0, 1), range [0-11] [0-5]\n    ivec2 p = ivec2(int(uv.x * hw), int(uv.y * hh));\n    // length of single grid\n    vec2 leng = vec2(1.0/hw, 1.0/hh);\n    // index = 12, index is start from 0\n    int index = (p.y * int(hw) + p.x);\n    // 0 is just the initial value\n    int select_k = 0;\n    for(int k = 0; k < 72; k++){\n        if(grid[k] -1 == index){\n            select_k = k;\n            break;\n        }\n    }\n    // Trying to convert index value to position vector2\n    ivec2 tp = ivec2(mod(float(select_k), hw), int(float(select_k) / hw));\n    //return vec2(float(p.x) * leng.x, float(p.y) * leng.y) + (local_uv * leng);\n    return vec2(float(tp.x) * leng.x, float(tp.y) * leng.y) + (local_uv * leng);\n}","name":"Common","description":"","type":"common"}]}