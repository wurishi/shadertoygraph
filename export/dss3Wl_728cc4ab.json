{"ver":"0.1","info":{"id":"dss3Wl","date":"1667653451","viewed":78,"name":"Raymarching first touch","username":"KhanhThai","description":"FirstTouch = length(MyPosition + MyView * MySteps - ShaderToy.xyz) - ShaderToy.w < 0.0001;","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","displacement","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define MAX_DIST 100.\n#define SURF_EPS 0.001\n\n#define LIGHT_SIZE 0.1\n#define LIGHT_POWER 2000.\n\n#define FOG_COLOR vec3(.5,.5,.5)\n#define FOG_DENSITY 0.25\n#define FOG_START 3.5\n#define FOG_END 7.0\n\n#define TIME_SCALE .5\n\n//OBJECTS IN SCENE\n\nvec4 Plane = vec4(0., 1., 0., 0.);\nvec4 Sphere = vec4(0., 1.5, 3., 1.);\nvec3 Camera = vec3(0., 1.0, -1.);\nvec3 Light = vec3(2,3,0);\n\nfloat scene(vec3 p);\n\n//GENERAL FUNCTIONS copied from various sources\n\nvec3 rotateX( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 rotateY( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.zx = mat2(co,-si,si,co)*p.zx;\n    return p;\n}\n\nvec3 rotateZ( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat plane(vec3 p, vec4 n) // n.xyz must be normalized\n{\n    return dot(p, n.xyz) + n.w;\n    //vec3 v = p - normalize(n.xyz)*n.w;\n    //return length(v) * dot(v, n.xyz);\n}\n\nfloat sphere(vec3 p, vec4 s)\n{\n    vec3 d = p - s.xyz;\n    return length(d) - s.w;\n}\n\nfloat hash( float n )\n{ return fract(sin(n)*43758.5453); }\n\n// The Perlin Noise function returns a value in the range -1.0f -> 1.0f\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat noise2(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = scene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n//MATERIALS\n\nfloat bump(vec2 p, float scale) //random noise height map\n{\n    return noise(vec3(p*scale,0.));\n}\n\nfloat sphereBump(vec2 uv)\n{\n    float d1 = bump(uv, 30.);\n    float d2 = bump(uv, 200.) * 0.1;\n    float d = max(d1+d2, 0.5);\n    return d*0.02;\n    //return smoothstep(0.5, 1.2, d) * 0.02;\n}\n\nfloat planeBump(vec2 uv)\n{\n    float d1 = bump(uv, 1.)*0.5;\n    float d2 = bump(uv, 200.) * 0.001;\n    float contour = smoothstep(0.9, 1., fract(d1*20.))*0.005;\n    return d1+max(d2,contour);\n}\n\nvec2 sphereUV(vec3 p, vec4 s)\n{\n    vec3 r = normalize(p-s.xyz);\n    r = rotateZ(r, 0.4);\n    r = rotateY(r, iTime*TIME_SCALE*0.5);\n    vec2 uv = vec2(atan(r.z,r.x), asin(r.y));\n    return uv;\n}\n\nfloat sphereDisp(vec3 p, vec4 s)\n{\n    s.y += 0.2*sin(iTime*TIME_SCALE*2.);\n    vec2 uv = sphereUV(p, s);\n    float d1 = sphere(p, s);\n    float d2 = sphereBump(uv);\n    return d1+d2;\n}\n\nfloat planeDisp(vec3 p, vec4 n)\n{\n    float d1 = plane(p, n);\n    vec3 uv = p - normalize(n.xyz)*d1;\n    float d2 = planeBump(uv.xz);\n    return d1+d2;\n}\n\nvec3 calcNormal( vec3 p ) // for function f(p)\n{\n    const float h = 0.00001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\n//SCENE\n\nfloat scene(vec3 p)\n{\n\n    float dp = planeDisp(p, Plane);   //distance to Plane\n    float ds = sphereDisp(p, Sphere); //distance to Sphere surface\n    \n    return min(dp, ds);\n    //return dp; //hide the sphere\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n\tfloat r = 0.;\n    float d = 0.;\n    \n\tfor(int i=0; i<MAX_STEPS; i++)\n\t{\n\t\tvec3 p =  ro + rd*r;\n        d = scene(p);\n        if (r > MAX_DIST || d < SURF_EPS) break;\n\t\tr += d;\n\t}\n       \n\treturn r;\n}\n\nfloat ilumination(float d)\n{\n    float I = 1.0f + max(d-LIGHT_SIZE, 0.0) / LIGHT_SIZE;\n\tI = clamp(LIGHT_POWER / (I*I), 0. , 1.);\n    return I;\n}\n\nvec4 light(vec3 p, vec3 lightPos)\n{\n    float r = length(p - Sphere.xyz);\n    bool ball = p.y > 0.1;\n    vec4 C;\n    if (ball)\n        C = vec4(.9,.9,1., 1.);\n    else\n        C = vec4(1.,.9,.8, 1.);    \n\n    vec3 N = calcNormal(p);\n    vec3 V = normalize(Camera - p);\n    vec3 L = lightPos - p;    \n    \n    float I = ilumination(length(L));\n\n    L = normalize(L);\n\n    float shadow = softshadow(p+N*0.2, L, 0.1, 100., 16.);\n    shadow = clamp(shadow, .2, 1.);\n\n    //diffuse\n    float D = clamp(dot(N, L), 0., 1.);\n    \n    //specular, except shadowed area\n    float S = 0.;    \n    if (shadow==1.) {\n        vec3 H = normalize(L + V);\n        S = clamp(dot(N, H), 0., 1.);\n        S = pow(S, (ball?30.:1.));\n    }\n    float rougness = ball ? 0.3 : 0.7;\n\n    //ambient, dot(N,V) to avoid flat looking in no-lighted area\n    float A = clamp(dot(N, V), 0., 1.);\n    \n    I *= clamp(A*0.1 + D*rougness*shadow + S*(0.9-rougness), 0., 1.);\n\n    //I = pow(I,.9); // gamma correction\n\n    C.rgb *= I;\n    \n    return C;\n}\n\nfloat fog(float depth)\n{\n    float f = 10. * FOG_DENSITY * clamp((depth-FOG_START)/(FOG_END-FOG_START), 0., 1.);\n    f = 1.0f/exp(f*f);\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*TIME_SCALE;\n    vec3 lightPos = Light;\n    lightPos.xz += vec2(5.*cos(t), 2.*sin(t));\n\n    vec3 ro = Camera; //ray origin, camera position\n    vec3 rd = normalize(vec3(uv, 1.)); //ray direction\n    float r = raymarch(ro, rd);\n    ro += rd * r;\n       \n    if (r < MAX_DIST)\n    {\n        fragColor = light(ro, lightPos);\n    }\n    else\n        fragColor = vec4(0.);\n\n    //float I = ilumination(length(lightPos-ro));\n    //fragColor.rgb = mix(FOG_COLOR*I, fragColor.rgb, fog(r));   \n}","name":"Image","description":"","type":"image"}]}