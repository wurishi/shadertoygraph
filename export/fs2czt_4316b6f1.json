{"ver":"0.1","info":{"id":"fs2czt","date":"1644000256","viewed":361,"name":"TT remastr: athibaul Techno Song","username":"ttg","description":"TTG Remaster: Use fixed-precision (DSP sample) time representation.","likes":14,"published":1,"flags":8,"usePreview":1,"tags":["2d","sound","song","techno","vinyl"],"hasliked":0,"parentid":"sls3WM","parentname":"Techno Song (sound)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ********************************\n// Techno Song - by Alexis THIBAULT\n// 29/05/2021\n// ********************************\n\n// See the \"Common\" tab for sound design and song structure.\n\n/*\n    Rights to all modifications herein are hereby assigned to Alexis Thibault in\n    hopes that they are found useful and may be reintegrated freely.\n    - Theron Tarigo (ttg)\n*/\n\n#define dot2(x) dot(x,x)\n#define hypot(x, y) sqrt((x)*(x) + (y)*(y))\n\nfloat onRing(vec2 p, float r1, float r2, float eps)\n{\n    float d1 = length(p);\n    return smoothstep(r1-eps,r1+eps,d1) * smoothstep(r2+eps,r2-eps,d1);\n}\n\nfloat borromeanRings(vec2 p, float eps)\n{\n    p = p.yx;\n    // rotate p back to the two slices around the positive x axis\n    float th = TAU/3.*round(atan(p.y,p.x)/TAU*3.);\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float rings = 0.;\n    float d = 0.65;\n    if(p.y > 0.)\n    {\n        rings += onRing(p-d*vec2(-0.5,-0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(1,0), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(1,0), 0.9, 1.1, eps);\n    }\n    else\n    {\n        rings += onRing(p-d*vec2(1,0), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,-0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,-0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,0.866), 0.9, 1.1, eps);\n    }\n    \n    return rings;\n}\n\nvec4 turningDisk(vec2 p, vec3 baseCol, float eps)\n{\n    float th = -iTime * TAU * 33./60.;\n    \n    float th0 = atan(p.y, p.x);\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float d1 = length(p);\n    float th1 = atan(p.y, p.x);\n    float r1 = 0.6, r2 = 0.65;\n    float relAngle = mod(th1,TAU)-TAU/2.;\n    float onEdge = onRing(p, 0.6, 0.65, eps);\n    // Thin stripe on the outer edge\n    float w = 0.02;\n    onEdge *= smoothstep(w-eps,w+eps, abs(p.y)+step(0.,p.x));\n    \n    // Inner circle\n    onEdge += onRing(p, 0.02, 0.18, eps);\n    \n    // Black logo on the inner circle\n    onEdge -= borromeanRings((p - vec2(0.09,0.0))*25., eps*25.);\n    \n    \n    // Flashing color\n    vec3 edgeCol = baseCol;\n    edgeCol = pow(edgeCol, 1.5*vec3(2. - sin(3.*p.y + p.x +iTime)));\n    \n    \n    vec4 col = vec4(edgeCol, onEdge);\n    \n    // Vinyl part\n    \n    float onDisk = onRing(p, 0.18, 0.58, eps);\n    float albedo = clamp(6.+6.*sin(d1*80.), 0., 1.) * (0.8+0.1*noise(2.*th1+0.5*d1/eps)*sin(th1)+0.1*noise(0.5*d1/eps));\n    float lighting = pow(abs(sin(th0+1.0)), 5.);\n    \n    col += albedo*lighting*onDisk * 0.4;\n    \n    return col;\n    \n}\n\nfloat onBox(vec2 p, vec2 r, float rounded, float eps)\n{\n    vec2 q = abs(p) - r + rounded;\n    float d = length(max(q,0.)) - rounded;\n    return smoothstep(1.5*eps,0.,d);\n}\n\nvec4 squarePad(vec2 p, vec2 r, vec3 baseCol, float eps)\n{\n    float onSquare = onBox(p, r, 0.02, eps);\n    vec3 col = pow(baseCol, vec3(2.- sin(iTime)) + 2.*dot2(p/r));\n    return vec4(col, onSquare);\n}\n\nvec4 waveform(vec2 p, vec3 baseCol, float eps)\n{\n    float t = p.x + iTime;\n    float envSq = exp(-10.*mod(t,0.5));\n    envSq += 0.2*exp(-20.*mod(t,0.25)) * (1.+sin(t*4.));\n    envSq += window(0.1,0.2,mod(t,0.25)) * (1.-sin(3.*t)) * 0.02;\n    float envenv = 0.9 + 0.1*smoothstep(0.,0.5,mod(t,0.5)) * 0.8*window(0.,4.,mod(t,8.));\n    envenv *= step(0.,t);\n    envenv *= smoothstep(0.,2.,t);\n    envSq *= envenv;\n    float env = sqrt(envSq) * 0.7;\n    vec3 col = pow(baseCol, 3.*vec3(abs(p.y) + 3.*(1.-envenv)));\n    return vec4(col, smoothstep(env+eps,env-eps,abs(p.y)));\n}\n\nvec4 turntableArm(vec2 p, float eps)\n{\n    p -= vec2(0.65,0.55);\n    float th0 = atan(p.y, p.x);\n    float thMin = -0.2, thMax = -0.6;\n    float th = mix(thMin, thMax, clamp(iTime/146., 0., 1.));\n    \n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    vec4 col = vec4(0);\n    \n    float len = 0.42;\n    float wid = 0.02;\n    vec4 shadow = vec4(0,0,0, onBox(p-vec2(0,-len), vec2(wid,len), 0.1, 0.1) * 0.9);\n    col = mix(col, shadow, shadow.a);\n    float rect = onBox(p-vec2(0.,-len), vec2(wid,len), eps, eps);\n    vec3 armcol = vec3(clamp(0.1 - sin(2.*p.x / sqrt(max(wid*wid - p.x*p.x, 0.0002)) - p.y), 0.07, 1.));\n    col = mix(col, vec4(armcol, 1), rect);\n    \n    \n    float d = length(p);\n    vec3 chromeBrush = vec3(0.8+0.1*noise(5. + 0.5*d/eps));\n    float lighting = mix(0.07, 1., pow(abs(sin(th0+1.0)), 8.));\n    col = mix(col, vec4(chromeBrush*lighting, 1), onRing(p, 0.,0.1, eps));\n    \n    p -= vec2(0,-2.*len);\n    float head1 = onBox(p, vec2(0.03,0.05), eps, eps);\n    col = mix(col, vec4(0.7 - 10.*p.x,0,0,1), head1);\n    float head2 = onBox(p-vec2(0,0.02), vec2(0.04,0.05), eps, eps);\n    float head2sh = onBox(p-vec2(0,0.02), vec2(0.04,0.05), 0.02, 0.02);\n    col = mix(col, vec4(0,0,0,1), head2sh*0.7);\n    vec3 headCol = vec3(0.4);\n    float rings = borromeanRings(50.*(p-vec2(0,0.02)), 50.*eps);\n    headCol = mix(headCol, vec3(0.1,0.1,0.1), rings);\n    headCol *= smoothstep(0.1,-0.1,p.x)*2.;\n    \n    col = mix(col, vec4(headCol, 1), head2);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float eps = 1.5/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float t = mod(iTime, 0.5);\n    float kickin = (iTime > 2.) ? exp(-t*10.) : 0.;\n    vec3 baseCol = mix(vec3(0.5,0.75,1.000), vec3(1.), kickin);\n    \n    vec2 p = uv - vec2(0.7,-0.2);\n    vec4 diskCol = turningDisk(p, baseCol, eps);\n    col = mix(col, diskCol.xyz, diskCol.a);\n    vec4 armCol = turntableArm(p, eps);\n    col = mix(col, armCol.xyz, armCol.a);\n    \n    \n    p = uv - vec2(-1.0,-0.5);\n    vec2 padC = clamp(round(p/0.2),-1.,4.)*0.2;\n    baseCol = mix(pow(normalize(0.5 + 0.4*cos(iTime+padC.xyx*3.+vec3(0,2,4))), vec3(0.3)), vec3(1.), kickin);\n    vec4 padCol = squarePad(p - padC, vec2(0.092), baseCol, eps);\n    col = mix(col, padCol.xyz, padCol.a);\n    \n    baseCol = mix(vec3(0.95,0.8,0.2), vec3(1.), kickin);\n    vec4 waveformCol = waveform((uv-vec2(0,0.8)) * 5., baseCol, eps * 5.);\n    col = mix(col, waveformCol.xyz, waveformCol.a);\n    \n    //col = vec3(1)*borromeanRings(uv*2.0, 2.*1.5/iResolution.y);\n    \n    \n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// See \"Common\" tab","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\n/*\n    Rights to all modifications herein are hereby assigned to Alexis Thibault in\n    hopes that they are found useful and may be reintegrated freely.\n    - Theron Tarigo (ttg)\n*/\n\n\n// The code below is split into several parts.\n// UTILS - Constants and hash functions and stuff\n// WAVEFORMS - Basic noise and tone generators\n// INSTRUMENTS - Stuff that makes notes\n// PHRASES AND SONG PARTS - What to play, how to play it, up to the final mix.\n\n\n///////////////////////////////\n/////////// UTILS /////////////\n///////////////////////////////\n\n#define TAU 6.2831855\n\nfloat intfract(int s, float n) {\n  // Implements fract(s/n)\n  // Explanation and copyright: shadertoy.com/view/4ltfRN\n  // Given sample number and period, calculate phase with high accuracy.\n  // Uses integer overflow for modulo.\n  int sn = int(n), a = s%sn, b = (s/sn);\n  const float MAXF = float(uint(-1))+1.;\n  return fract(  (float(a)/n) + float((uint(b)*uint(MAXF*float(sn)/n)))/MAXF );\n}\n\nfloat oscfr(int s, float f) {\n  return intfract(s, iSampleRate/f);\n}\n\nfloat oscph(int s, float f) {\n  return TAU*oscfr(s,f);\n}\n\nvec2 oscfr(int s, vec2 f) {\n  return vec2(oscfr(s,f.x),oscfr(s,f.y));\n}\n\nvec2 oscph(int s, vec2 f) {\n  return TAU*oscfr(s,f);\n}\n\nvec2 osc(int s,float f) {float p=oscph(s,f);return vec2(cos(p),sin(p));}\nfloat osccos(int s,float f) {return osc(s,f).x;}\nfloat oscsin(int s,float f) {return osc(s,f).y;}\n\nint S(float t) {return int(round(t*iSampleRate));}\nivec4 S(vec4 t) {return ivec4(round(t*iSampleRate));}\nfloat T(int s) {return float(s)/iSampleRate;}\nvec4 T(ivec4 s) {return vec4(s)/iSampleRate;}\n\nint modsi(int a,int b){ int m=(a<0?~a:a)%b; return a<0?b-1-m:m; }\nivec4 modsi(ivec4 a,int b){\n  ivec4 r; for(int i=0;i<4;i++) r[i]=modsi(a[i],b); return r; }\n\nint smod(int samp,float offset,float period) {return modsi(samp-S(offset),S(period));}\nivec4 smod(int samp,vec4 offset,float period) {return modsi(samp-S(offset),S(period));}\n\n// Convert MIDI note number to cycles per second\n#define midicps(n) (440.*exp(log(2.)*(n-69.)/12.))\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 rand2(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n////////////////////////////////////\n/////////// WAVEFORMS //////////////\n////////////////////////////////////\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\n    // see https://iquilezles.org/articles/texture\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nvec2 noise2(float s){\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand2(float(si)), rand2(float(si+1)), sf) * 2. - 1.;\n}\n\nfloat coloredNoise(int s, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    //float n1 = noise(t*df);\n    //float n2 = noise(t*df - 100000.);\n    //vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    // original:\n    // return sin(TAU*fc*fract(t))*noise(t*df);\n    // was fc*fract(t) a mistake? : fract(fc*t)\n    return oscsin(s,fc)*noise(T(s)*df);\n}\n\nvec2 coloredNoise2(int s, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    vec2 noiz = noise2(T(s)*df);\n    vec2 modul = osc(s,fc);\n    return modul*noiz;\n}\n\n\nfloat window(float a, float b, float t)\n{\n    return smoothstep(a, (a+b)*0.5, t) * smoothstep(b, (a+b)*0.5, t);\n}\n\nfloat formantSin(float phase, float form)\n{\n    // Inspired by the wavetable \"formant\" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*fract(phase));\n}\nvec2 formantSin2(vec2 phase, vec2 form)\n{\n    // Inspired by the wavetable \"formant\" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*fract(phase));\n}\n\nvec2 lpfSaw(int samp, vec2 f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are samp, frequency, cutoff frequency, and resonance quality factor\n    vec2 omega_c = 2.*3.14159*fc/f; // relative\n    vec2 t2 = oscfr(samp,f);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    vec2 alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    vec2 tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    vec2 phi = atan(tanphi);\n    vec2 A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    vec2 v = 1.-2.*t2 + A*exp(-alpha*t2) * cos(omega_c*t2+phi);\n    return v;\n}\n\nfloat lpfSaw(int samp, float f, float fc, float Q)\n{\n    return lpfSaw(samp,vec2(f),fc,Q).x;\n}\n\n\n///////////////////////////////////\n//////// INSTRUMENTS //////////////\n///////////////////////////////////\n\nvec2 hat1(int s)\n{\n    // Smooth hi-hat, almost shaker-like\n    float t = T(s);\n    return coloredNoise2(s, 10000., 5000.) * smoothstep(0.,0.02,t) * smoothstep(0.06,0.01,t) * 0.1;\n}\n\nvec2 hat2(int s, float fc)\n{\n    // Short hi-hat with tuneable center frequency\n    float t = T(s);\n    return coloredNoise2(s, fc, fc-1000.) * smoothstep(0.,0.001,t) * smoothstep(0.03,0.01,t) * 0.1;\n}\n\nvec2 snare1(int s)\n{\n    // Composite snare\n    float t = T(s);\n    float body = (oscsin(s,250.) + oscsin(s,320.)) * smoothstep(0.1,0.0,t) * 1.;\n    vec2 timbre = coloredNoise2(s, 1000., 7000.) * exp(-12.*t) * smoothstep(0.5,0.,t) * 8.;\n    vec2 sig = (body+timbre) * smoothstep(0.,0.001,t);\n    sig = sig/(1.+abs(sig)); // distort\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    return sig * 0.1;\n}\n\nvec2 snare2(int s)\n{\n    // Basic noise-based snare\n    float t = T(s);\n    float noi = coloredNoise(s, 4000., 1000.) + coloredNoise(s, 4000., 3800.) + coloredNoise(s,8000.,7500.) * 0.5;\n    float env = smoothstep(0.,0.001,t) * smoothstep(0.2,0.05,t);\n    env *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    env *= (1. - 0.5*window(0.02,0.1,t)); // fake compression\n    vec2 sig = vec2(noi) * env;\n    sig = sig/(1.+abs(sig));\n    return sig * 0.1;\n}\n\nfloat kick1(int s)\n{\n    // Composite kick\n    \n    // Kick is composed of a decaying sine tone, and a burst of noise,\n    // all of it distorted and shaped with a nice envelope.\n    \n    // frequency is assumed to be f0 + df*exp(-t/dftime);\n    float t = T(s);\n    float f0 = 50., df=500., dftime=0.02;\n    float phase = TAU * (f0*t - df*dftime*exp(-t/dftime));\n    float body = sin(phase) * smoothstep(0.15,0.,t) * 2.;\n    float click = coloredNoise(s, 8000., 2000.) * smoothstep(0.01,0.0,t);\n    //float boom = sin(f0*TAU*t) * smoothstep(0.,0.02,t) * smoothstep(0.15,0.,t);\n    float sig = body + click;\n    sig = sig/(1.+abs(sig));\n    //sig += boom;\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    sig *= (1. + window(0.05,0.15,t)); // increase tail\n    return sig * 0.2;\n}\n\nvec2 bass1(int s, float f, float cutoff)\n{\n    // Composite bass\n    // (I'm very happy about this one!)\n    \n    // \"Cutoff\" is not actually the cutoff frequency of a filter,\n    // but it controls the amount of high frequencies\n    // we bring in using the \"formantSin\" waveform.\n    float t = T(s);\n    cutoff *= exp(-t*5.);\n    float formant = max(cutoff/f, 1.);\n    // Pure sine tone\n    float funda = oscsin(s,f);\n    // Phase-modulated sine gives more \"body\" to the sound\n    float body = sin(oscph(s,2.*f) + (0.2*formant)*oscsin(s,f));\n    // Gritty attack using a truncated sinusoid waveform\n    // (dephased for stereo effect)\n    vec2 highs = formantSin2(oscfr(s,f) + vec2(0,0.5), vec2(formant)) * exp(-t*10.);\n    vec2 sig = body + highs + funda;\n    // Two-rate envelope with a strong transient and long decay\n    sig *= (2.*exp(-t*20.) + exp(-t*2.));\n    sig *= (1. + 0.3*smoothstep(0.05,0.0,t)); // increase transient\n    \n    // Finally, add some distortion\n    //sig = sig / (1. + abs(sig)); // Feel free to try how this one sounds.\n    sig = sin(sig); // This one gives lovely sidebands when pushed hard.\n    return sig * 0.1;\n}\n\nvec2 pad1(int s, vec4 f, float fc, float Q)\n{\n    // Filtered sawtooth-based pad, playing four-note chords\n    \n    // f: frequencies of the four notes\n    // fc, Q: cutoff frequency and quality factor of the 12dB/octave lowpass filter\n    vec2 sig = vec2(0);\n    sig += lpfSaw(s, f.x+vec2(-2,2), fc, Q);\n    sig += lpfSaw(s, f.y+vec2(1.7,-1.7), fc, Q);\n    sig += lpfSaw(s, f.z+vec2(-0.5,0.5), fc, Q);\n    sig += lpfSaw(s, f.w+vec2(1.5,-1.5), fc, Q);\n    return sig * 0.02;\n}\n\nvec2 arp1(int s, vec4 f, float fc, float dur)\n{\n    // Plucky arpeggiator, playing 16th notes.\n    \n    // dur: decay time of the notes (amplitude and filter)\n    vec2 sig = vec2(0);\n    ivec4 ss = smod(s,vec4(0,0.125,0.25,0.375), 0.5);\n    vec4 ts = T(ss);\n    sig += lpfSaw(s, f.x, fc*exp(-ts.x/dur), 10.) * smoothstep(0.0,0.01,ts.x) * exp(-ts.x/dur);\n    sig += lpfSaw(s, f.y, fc*exp(-ts.y/dur), 10.) * smoothstep(0.0,0.01,ts.y) * exp(-ts.y/dur);\n    sig += lpfSaw(s, f.z, fc*exp(-ts.z/dur), 10.) * smoothstep(0.0,0.01,ts.z) * exp(-ts.z/dur);\n    sig += lpfSaw(s, f.w, fc*exp(-ts.w/dur), 10.) * smoothstep(0.0,0.01,ts.w) * exp(-ts.w/dur);\n    return sig * 0.04;\n}\n\nvec2 marimba1(int s, float f)\n{\n    // Simple phase-modulation based marimba\n    float t = T(s);\n    vec2 sig = vec2(0);\n    // Super basic marimba sound\n    sig += sin(oscph(s,f) + exp(-50.*t)*sin(7.*oscph(s,f))) * exp(-5.*t) * step(0.,t);\n    // Fake reverb effect: long-decay, stereo-detuned fundamental\n    sig += sin(oscph(s,f+vec2(-2,2))) * exp(-1.5*t) * 0.5;\n    return vec2(sig) * 0.05;\n}\n\nvec2 pad2(int s, vec4 f, float fres)\n{\n    // Four-note, phase-modulation-based pad.\n    \n    // fres: center frequency of the faked \"spectral aliasing\"\n    \n    vec2 sig = vec2(0);\n    // Index of modulation\n    // https://en.wikipedia.org/wiki/Frequency_modulation#Modulation_index\n    vec4 iom1 = 2.+0.5*sin(T(s) + vec4(0,1,2,3));\n    // Play an octave lower than asked\n    f *= 0.5;\n    // Modulator has frequency 2f -> odd harmonics only\n    sig += sin(oscph(s,f.x) + iom1.x * sin(2.*oscph(s,f.x+vec2(-1,1)))) * vec2(1,0);\n    sig += sin(oscph(s,f.y) + iom1.y * sin(2.*oscph(s,f.y+vec2(-1.2,0.8)))) * vec2(0.7,0.3);\n    sig += sin(oscph(s,f.z) + iom1.z * sin(2.*oscph(s,f.z+vec2(-0.5,1.5)))) * vec2(0.3,0.7);\n    sig += sin(oscph(s,f.w) + iom1.w * sin(2.*oscph(s,f.w+vec2(-1.3,0.7)))) * vec2(0,1);\n    \n    // Fake spectral aliasing, to add some high-end\n    vec2 warped = vec2(0);\n    warped += sin(oscph(s,fres) + 5.*sin(oscph(s,f.x))) * vec2(1,0);\n    warped += sin(oscph(s,fres) + 5.*sin(oscph(s,f.y))) * vec2(0.7,0.3);\n    warped += sin(oscph(s,fres) + 5.*sin(oscph(s,f.z))) * vec2(0.3,0.7);\n    warped += sin(oscph(s,fres) + 5.*sin(oscph(s,f.w))) * vec2(0,1);\n    \n    // Mix to taste\n    sig = (sig + 0.01*warped) * 0.02;\n    // Reduce stereo image\n    sig = mix(sig.xy, sig.yx, 0.1);\n    return sig;\n}\n\n\n////////////////////////////////////////////\n/////// PHRASES AND SONG PARTS /////////////\n////////////////////////////////////////////\n\n\nfloat leadphrasenote(int s)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // MIDI note number (or 0. if silence)\n    float t = T(s);\n    float note =\n        (t<0.5) ? 69. : (t<1.) ? 71. : (t<1.5) ? 72. : (t<1.75) ? 76. :\n        (t<3.0) ? 74. : (t<3.25) ? 0. : (t<3.5) ? 72. : (t<3.75) ? 74. :\n        (t<5.5) ? 76. : (t<5.75) ? 79. : (t<7.5) ? 71. : 0.;\n    return note;\n}\n\nvec2 leadphrase1(int s, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    \n    float note = leadphrasenote(s);\n    // Add some vibrato\n    float t = T(s);\n    float vibStrength = window(2.,3.,t) + window(4.,5.5,t) + window(6.,8.,t);\n    float f = midicps(note + vibStrength*0.01*oscsin(s,5.)/(T(s)+0.1));\n    // Cut silence\n    float env = (note > 0.) ? 1. : 0.;\n    \n    // \"Super-saw\" lead\n    vec2 sig = lpfSaw(s, f+vec2(-2,2), fc, 1.);\n    sig += lpfSaw(s, f+vec2(3.2,-3.2), fc, 1.);\n    sig += lpfSaw(s, f, fc, 1.);\n    \n    // Distort\n    sig *= 2.;\n    sig = sig/(1.+abs(sig));\n    \n    return sig * 0.05 * env;\n}\n\nvec2 leadchorus(int s, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // Add delay effect\n    vec2 sig = leadphrase1(s, fc);\n    sig = mix(sig, sig.yx, 0.3);\n    sig += leadphrase1(smod(s,0.25,8.), fc*0.7).yx * vec2(0.5,-0.5);\n    sig += leadphrase1(smod(s,1., 8.), 1000.) * 0.5;\n    return sig;\n}\n\nvec2 basschorus(int s, float fc)\n{\n    // Bass of the final chorus:\n    // Simply play the fundamental of each bar, with octave jumps\n    \n    // Every second 8th note is an octave above\n    float t = T(s);\n    float octave = 12.*step(0.25,mod(t,0.5));\n    // Fundamental of each of the four bars\n    float note = (t<2.) ? 69.-36.+octave : \n                 (t<4.) ? 62.-36.+octave :\n                 (t<6.) ? 60.-36.+octave :\n                 67.-36.+octave;\n    \n    int s1 = smod(s,0., 0.25);\n    vec2 sig = bass1(s1, midicps(note), fc);\n    \n    return sig;\n}\n\nvec2 padchorus(int s, float fc, float Q)\n{\n    // Pad part for the final chorus\n    // Simply play the (slightly rich) chords\n    // ||: Am(add9) | Dm7 | C(add9) | G(add9) :||\n    float t = T(s);\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    \n    vec2 pad = pad1(s, midicps(chord), fc, Q);\n    return pad;\n}\n\n\nvec2 arpchorus(int s, float fc, float dur)\n{\n    // Arpeggiator part for the final chorus\n    // Simply arpeggiate the four chords\n    float t = T(s);\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    vec2 arp = arp1(s, midicps(chord+12.), fc, dur);\n    return arp;\n}\n\n\nvec2 fullChorus(int samp)\n{\n    // Full mix for the final chorus\n    samp = smod(samp, 0., 8.);\n    vec2 v = vec2(0);\n    \n    // Percussions (with a slight 16th-note swing)\n    v += hat1(smod(samp, 0., 0.25)) * vec2(0.8,1.0);\n    v += hat1(smod(samp, 0.14, 0.25)) * vec2(0.3,-0.2);\n    v += snare1(smod(samp, 0.5, 1.));\n    v += kick1(smod(samp, 0., 0.5));\n    \n    // Low-frequency oscillator on a macro control\n    float cutoff = 300. + 200.*oscsin(samp,1./TAU);\n    \n    float t = T(smod(samp,0., 0.5));\n    // Another LFO for fake sidechain compression (\"pumping\" effect)\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    \n    v += basschorus(smod(samp,0.,8.), cutoff) *mix(pumping, 1.,0.3);\n    \n    vec2 pads = padchorus(smod(samp,0., 8.), 8000.-1000.*oscsin(samp,1./TAU), 2.);\n    pads *= mix(pumping, 1., 0.1);\n    v += pads;\n    \n    // A third LFO to vary the note length of the arpeggiator\n    float dur = 0.2 * exp(0.2*oscsin(samp,0.6/TAU));\n    vec2 arp = arpchorus(smod(samp,0., 8.), 5000.-1000.*osccos(samp,0.7/TAU), dur);\n    v += arp * mix(pumping, 1.,0.2);\n    \n    v += leadchorus(smod(samp,0.,8.), 10000.) * mix(pumping,1.,0.5);\n    \n    return v;\n}\n\nvec2 padPhraseVerse(int samp, float fc)\n{\n    // Pad during the verse: play three chords in four bars\n    // ||: Am(add11) | FMaj7 | Em7 | Em7 :||\n    int s = smod(samp,0., 8.);\n    float t = T(s);\n    vec4 chord = (t<2.) ? vec4(57,60,62,64) : (t<4.) ? vec4(53,57,60,64) : vec4(52,55,62,64);\n    // Smoothe out the transitions from one chord to the next,\n    // as they are not masked by percussion.\n    float env = 1. - window(-0.1,0.1,t) - window(1.9,2.1,t) - window(3.9,4.1,t) - window(7.9,8.1,t);\n    // Add some movement with volume automation\n    env *= 1. + 0.2*window(0.25,0.5,mod(t,0.5));\n    return pad1(s, midicps(chord), fc*0.7, 2.) * env;\n}\n\nvec2 padVerse(int samp, float fc)\n{\n    // Verse pad with delay effect\n    return padPhraseVerse(samp, fc) + 0.5*padPhraseVerse(samp-S(0.5),fc).yx + 0.2*padPhraseVerse(samp-S(1.5),fc);\n}\n\nvec2 marimbaVerse(int s, float fc)\n{\n    // Marimba part for the verse:\n    // just a few notes, always the same.\n    vec2 v = vec2(0);\n    v += marimba1(smod(s,0.00,8.), midicps(72.));\n    v += marimba1(smod(s,0.75,8.), midicps(71.));\n    v += marimba1(smod(s,1.50,8.), midicps(69.));\n    v += marimba1(smod(s,2.25,8.), midicps(64.));\n    v += marimba1(smod(s,7.50,8.), midicps(69.));\n    v += marimba1(smod(s,7.75,8.), midicps(71.));\n    return v;\n}\n\nvec2 arpVerse(int samp, float fc, float dur)\n{\n    // Verse arpeggiator: just arpeggiate the chords\n    // (different notes than the pad this time).\n    // Cutoff frequency and note duration will be varied for tension.\n    int s = smod(samp,0., 8.);\n    float t = T(s);\n    vec4 chord = (t<2.) ? vec4(57,64,69,71) : (t<4.) ? vec4(57,64,65,72) : vec4(59,64,69,74);\n    return arp1(s, midicps(chord), fc, dur);\n}\n\nvec2 fullVerse(int samp)\n{\n    vec2 v = vec2(0);\n    // Cutoff frequency: dark sound initially,\n    // but with a riser in the last four bars.\n    float fc = 400. - 100.*osccos(samp,1./TAU) + 10000. * pow(clamp((T(samp)-24.)/(32.-24.),0.,1.), 4.);\n    v += padVerse(samp, fc) * 0.5;\n    v += marimbaVerse(samp, fc);\n    if(samp > S(16.))\n    {\n        // Arpeggiator comes in after 8 bars, and note duration increases\n        // during the riser.\n        float dur = mix(0.05,0.5, smoothstep(24.,32.,T(samp)));\n        v += arpVerse(samp, fc, dur) * smoothstep(16.,18.,T(samp));\n    }\n    return v;\n}\n\nvec2 bassDrop1(int samp)\n{\n    // Groovy four-bar phrase of the bass during the drop.\n    \n    // (In fact, it is the only part of this song with\n    // some melodic/rhythmic complexity and variation.\n    // The rest is extremely mechanical.)\n    \n    vec2 v = vec2(0);\n    \n    samp = smod(samp,0., 8.);\n    \n    int sx = samp / S(0.125); // sixteenth note number\n    int st = samp % S(0.125);\n    bool isShort = true; // True for 16th note, false for 8th note\n    vec2 nn = vec2(0.,0.); // note number, trigger short note\n    nn = (sx == 0 || sx == 5 || sx==8) ? vec2(33,1) : \n         (sx == 2) ? vec2(48,1) :\n         (sx == 3) ? vec2(45,1) :\n         (sx == 14) ? vec2(35,1) :\n         (sx == 15 || sx == 35) ? vec2(36,1) :\n         (sx == 16 || sx == 21 || sx == 24 || sx == 30 || sx == 31) ? vec2(26,1) :\n         (sx == 18) ? vec2(41,1) :\n         (sx == 19) ? vec2(38,1) :\n         (sx == 32 || sx == 37 || sx == 38 || sx == 40) ? vec2(24,1) :\n         (sx == 34) ? vec2(40,1) :\n         (sx == 46) ? vec2(28,1) :\n         (sx == 47) ? vec2(29,1) :\n         (sx == 48 || sx == 53 || sx == 54 || sx == 56 || sx == 57) ? vec2(31,1) :\n         (sx == 50) ? vec2(47,1) :\n         (sx == 51 || sx == 58) ? vec2(43,1) :\n         (sx == 60 || sx == 61) ? vec2(32,1) :\n         (sx == 62) ? vec2(44,1) :\n         vec2(0,0);\n    \n    \n    if(sx == 30 || sx == 56 || sx == 60)\n    { // First half of 8th notes\n        isShort = false;\n    }\n    if(sx == 31 || sx == 57 || sx == 61)\n    {  // Second half of 8th notes\n        st += S(0.125);\n        isShort = false;\n    }\n    \n    \n    float fc = 400. + 50.*oscsin(samp,1.);\n    v += bass1(st, midicps(nn.x), fc) * nn.y;\n    \n    // Decay end of note to avoid clicks\n    if(isShort) v *= smoothstep(0.125,0.12,T(st));\n    else v *= smoothstep(0.125,0.12,T(st)-0.125);\n    \n    return v;\n}\n\nvec2 padDrop1(int samp, float fres)\n{\n    // Pad part for the drop : uses pad2 (the phase-modulation based pad)\n    vec2 v = vec2(0);\n    \n    int s = smod(samp,0., 8.);\n    // Very sparse choice of notes.\n    // Chord transitions happen after the start of the bar.\n    float t = T(s);\n    vec4 chord = (t < 2.75) ? vec4(69,72,69,72) : \n    (t < 4.75) ? vec4(69,72,69,74) : (t < 6.75) ? vec4(69,72,67,72) : vec4(69,72,69,71);\n    // Funky automation to avoid boredom\n    float env = (0.05 + window(0.,4.,t) + window(4.,8.,t)) * exp(-5.*mod(-t, 0.25));\n    v += pad2(samp, midicps(chord), fres) * env;\n    \n    return v;\n}\n\nvec2 fullDrop1(int samp)\n{\n    // Full mix of the bass drop.\n    vec2 v = vec2(0);\n    int s = smod(samp,0., 0.5);\n    // Fake sidechain compression again\n    float pumping = mix(smoothstep(0.0,0.25,T(s)), smoothstep(0.0,0.5,T(s)), 0.2);\n    // Hi-hat timbre rises from \"dull\" to \"harsh\"\n    float fhat = 5000. + 3000.*smoothstep(24.,32.,T(samp));\n    \n    v += bassDrop1(samp) * mix(pumping, 1., 0.8);\n    v += kick1(smod(samp,0., 0.5) + S(0.008));\n    \n    v += padDrop1(samp, 8000.) * mix(pumping, 1., 0.05);\n    \n    if(samp > S(8.))\n    {\n        // Snare comes in after 4 bars.\n        v += snare2(smod(samp,0.5, 1.));\n    }\n    if(samp > S(16.))\n    {\n        // Hi-hat comes in after 8 bars\n        // Short hi-hat sound with fast attack and decay. Slight swing.\n        v += hat2(smod(samp,0., 0.25), fhat) * vec2(0.8,1.0) * 0.7;\n        v += hat2(smod(samp,0.14, 0.25), fhat) * vec2(0.3,-0.2) * 0.7;\n    }\n    return v;\n}\n\nvec2 fermata1(int samp)\n{\n    // 2-bar fermata after verse\n    vec2 v = vec2(0);\n    // Let the last marimba note decay\n    v += marimba1(samp, midicps(69.));\n    // Let the pad go from bright to dark\n    float time = T(samp);\n    float fc = 10000. * exp(-5.*smoothstep(0.,4.,time));\n    v += pad1(samp, midicps(vec4(57,60,62,64)), fc, 2.) * smoothstep(0.,0.1,time) * smoothstep(4.,0.,time);\n    \n    // Riser before drop:\n    // Lots of low-frequency noise + a bit of high-frequency\n    vec2 noise = (coloredNoise2(samp, 250., 250.) + 0.1*coloredNoise2(samp, 8000., 2000.)) * 0.2 * exp(-6.*smoothstep(4.,1.,time)) * smoothstep(4.,3.99,time);\n    v += noise;\n    \n    return v;\n}\n\n\nvec2 teller1(int samp)\n{\n    // 1-bar riser before chorus\n    vec2 v = vec2(0);\n    int s = smod(samp,0., 0.5);\n    float time = T(samp);\n    float fc = 10000.*exp(2.*(time-2.));\n    // Noise riser\n    vec2 riser = coloredNoise2(samp, fc*0.3, fc*0.3);\n    v += riser * smoothstep(0.,2.,time) * 0.3 * exp((time-2.)*3.);\n    // Announce the \"middle A\" played by the lead synth on the chorus\n    vec2 teller = pad1(samp, midicps(vec4(69)), fc, 2.);\n    v += teller;\n    return v;\n}\n\n\nvec2 verseTeller(int samp)\n{\n    // Pre-announce the first note played by the marimba.\n    float fC5 = midicps(72.);\n    return (sin(oscph(samp,fC5+vec2(-2,2))) + 0.5*sin(oscph(samp,fC5+vec2(3,-3)))) * 0.1 * exp(-5.*(2.-T(samp)));\n    \n}\n\nvec2 fullSong(int samp)\n{\n    // Combine all parts of the song into a structured whole.\n    \n    vec2 v = vec2(0);\n    \n    if(0<samp && samp < S(2.))\n    {\n        v += verseTeller(samp);\n    }\n    \n    samp -= S(2.);\n    \n    if(0 < samp && samp < S(32.))\n    {\n        v += fullVerse(samp);\n    }\n        \n    samp -= S(32.);\n    \n    if(0 < samp && samp < S(4.))\n    {\n        v += padVerse(samp, 10000.) * smoothstep(0.5,0.,T(samp));\n        v += fermata1(samp);\n    }\n    \n    samp -= S(4.);\n    \n    if(0 < samp && samp < S(32.))\n    {\n        v += fullDrop1(samp);\n    }\n    \n    samp -= S(32.);\n    \n    if(0 < samp && samp < S(4.))\n    {\n        v += bass1(samp, midicps(33.), 400.);\n        v += pad2(samp, midicps(vec4(69,71,69,72)), 8000.) * (0.5 + 0.3*osccos(samp,1.)) \n             * smoothstep(0.,0.5,T(samp)) * smoothstep(4.,0.,T(samp));\n        v += verseTeller(samp-S(2.));\n    }\n    \n    samp -= S(4.);\n    \n    if(0 < samp && samp < S(16.))\n    {\n        v += fullVerse(samp+S(16.));\n    }\n    \n    samp -= S(16.);\n    \n    if(0 < samp && samp < S(4.))\n    {\n        v += fermata1(samp);\n        v += teller1(samp-S(2.)) * smoothstep(2.,4.,T(samp));\n    }\n    \n    samp -= S(4.);\n    \n    if(0 < samp)\n    {\n        v += fullChorus(samp) * smoothstep(48.,32.,T(samp)); // fade out on chorus\n    }\n    \n    return v;\n}\n\nvec2 mainSound( int samp, float _stt )\n{\n    vec2 v = vec2(0);\n    float t = T(samp);\n    v = fullSong(samp);\n    \n    //v = fullChorus(samp - 20., 10000.);\n    //v = vec2(kick1(mod(samp, 0.5)));\n    \n    //v = fullDrop1(samp);\n    \n    //v = fermata1(samp);\n    \n    // Avoid clicks at the beginning\n    return v * smoothstep(0.,0.01,t);\n}\n","name":"Common","description":"","type":"common"}]}