{"ver":"0.1","info":{"id":"tssfzs","date":"1588974020","viewed":135,"name":"Totoro Bus Stop Scene","username":"susanxie","description":"Based on https://lumiere-a.akamaihd.net/v1/images/image_b9660bcf.jpeg","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["raymarch","rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAIN_WIDTH 2.2\n#define FALLING_SPEED 0.25\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    vec4 unblurredColor = texture(iChannel0, uv);    \n    \n    // Rain: based on https://www.shadertoy.com/view/lscBRf\n    vec2 clamped_uv = (round(fragCoord / RAIN_WIDTH) * RAIN_WIDTH) / iResolution.xy;\n    float value = fract(sin(clamped_uv.x) * 35098.123);\n    vec3 col = vec3(1.0 - mod(uv.y * 0.5 + (iTime * (FALLING_SPEED + value / 5.0)) + value, 0.2));\n    col *= vec3(exp(-pow(abs(uv.y - 0.5), 6.0) / pow(2.0 * 0.05, 2.0)));\n    \n    //fragColor = unblurredColor;\n    fragColor = unblurredColor += vec4(col, 0.) * 0.1;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int RAY_STEPS = 70;\nconst float PI = 3.14159;\n\n// primitive locations\nconst vec3 treePos = vec3(0.0, -1.5, 3.0);\nconst vec3 floorPos = vec3(0.0, 4.0, 0.0);\nconst vec3 leafPos = vec3(0.0, 3.0, 8.0);\nconst vec3 bushPos = vec3(-5.0, 3.7, 4.0);\n\n// primitive forward declarations\nfloat plane(vec3 p, vec4 n);\nfloat sphere(vec3 p, float r, vec3 c);\nfloat box(vec3 p, vec3 b);\nfloat cylinder(vec3 p, float h, float r);\nfloat ellipse(vec3 p, vec3 r);\nfloat cone(vec3 p, float r1, float r2, float h);\n\n// define primitives and constants\n#define TREES 0\n#define FLOOR 1\n#define PLANTS 2\n\n#define TREES_SDF repeatTree(pos + treePos, vec3(9.0, 0.0, 0.0), 1.5, 7.5)\n#define PLANT_HEAD ellipse(pos + leafPos, vec3(0.1, 0.2, 0.1))\n#define PLANT_BASE ellipse(pos + leafPos + vec3(-0.2, -0.3, 0.1), vec3(0.3, 0.2, 0.1))\n#define LEAF_SDF unionSmooth(PLANT_HEAD, PLANT_BASE, 0.8)\n#define PLANTS_SDF plants(pos + bushPos)\n\n#define FLOOR_SDF plane(pos + floorPos, vec4(0.0, 1.0, 0.0, 1.0))\n#define LIGHT_POS vec3(9.0, 0., -14)\n\n#define FOVY 38.0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \n// ROTATION TRANSFORMS\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {   \n    eye = vec3(0.0, -2.0, -50.0);\n    ref = vec3(0.0, 3.0, 30.0);\n    \n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * iResolution.x / iResolution.y;\n    \n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\n// GEOMETRY PRIMITIVES\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat cylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat ellipse(vec3 p, vec3 r)\n{\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfloat cone(vec3 p, float r1, float r2, float h)\n{\n  vec2 q = vec2(length(p.xz), p.y);\n    \n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n    \n  if(k < 0.0) {\n      return length(q) - r1;\n  }\n  if(k > a * h) {\n      return length(q - vec2(0.0, h)) - r2;\n  }\n        \n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat capsule(vec3 p, float h, float r)\n{\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\nfloat plants(in vec3 p)\n{\n    const vec3 c = vec3(3.5, 0., 0.);\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    \n    float d1 = cylinder(rotateZ(q, -PI / 2.), 2., 2.);\n    vec3 p2 = rotateZ(q, PI / 2.2 + 0.2 * length(p - q));\n    float d2 = ((sin(10. * p2.x) - 1.0) * 0.5) * ((sin(4. * p2.y) - 1.0) * 0.5)\n        * ((sin(1.9 * p2.z) - 1.0) * 0.5);\n    return d1 + 2. * d2;\n}\n\n\n// CSG OPERATIONS\nfloat unionOp(float d1, float d2) {  \n    return min(d1, d2); \n}\n\nfloat subOp(float d1, float d2) { \n    return max(-d1, d2); \n}\n\nfloat intersectOp(float d1, float d2) { \n    return max(d1, d2); \n}\n\n\n// BLENDSHAPE OPERATIONS\nfloat unionSmooth(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h *(1.0 - h); \n}\n\nfloat intersectSmooth(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0-h); \n}\n\n\n// SDF REPETITION \nfloat repeatTree(in vec3 p, in vec3 c, float r, float h)\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return cylinder(q, r, h);\n}\n\nvec3 skyColor(vec3 dir) {\n    return vec3(1.0, 1.0, 1.0);\n}\n\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = FLOOR_SDF;\n    t = min(t, TREES_SDF);\n    t = min(t, PLANTS_SDF);\n    \n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = FLOOR_SDF;\n    obj = FLOOR;\n    \n    float t2;\n    \n    if ((t2 = TREES_SDF) < t) {\n        t = t2;\n        obj = TREES;\n    }\n    \n    if (pos.y < 1.9) {\n        if ((t2 = PLANTS_SDF) < t) {\n            t = t2;\n            obj = PLANTS;\n        }\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\n// fractal brownian motion\nfloat random2D(vec2 p) {\n  return fract(sin(dot(p, vec2(45.123, 23456.3459))) * 234.235);\n}\n\nfloat interpNoise2D(vec2 p) {\n    float intX = floor(p.x);\n    float fractX = fract(p.x);\n    float intY = floor(p.y);\n    float fractY = fract(p.y);\n\n    float v1 = random2D(vec2(intX, intY));\n    float v2 = random2D(vec2(intX + 1., intY));\n    float v3 = random2D(vec2(intX, intY + 1.));\n    float v4 = random2D(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise2D(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\nvec3 genFBMColor(float t) {\n    vec3 a = vec3(0.1, 1.0, 0.5);\n    vec3 b = vec3(1.0, 0.5, 0.5);\n    vec3 c = vec3(0.9, 0.9, 1.0);\n    vec3 d = vec3(0.0, 0.5, 0.66);\n    \n    return a + b * cos(2. * PI * (t * c * d));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float t;\n    switch(hitObj) {        \n        case TREES:\n        vec3 brown = 0.6 * vec3(0.9, 0.7, 0.62) * max (0.0, dot(n, light));\n        brown += 0.3 * vec3(0.5, 0.48, 0.42);\n        \n        float fbm1 = fbm(vec2(interpNoise2D(vec2(p.x, p.y)), interpNoise2D(vec2(p.y, p.x))), 4.0);\n        vec3 color1 = genFBMColor(fbm1) * max(0.0, dot(n, light));        \n        return color1 * brown;\n        break;\n        \n        case FLOOR:\n        vec3 white = vec3(1.0, 1.0, 1.0) * max(0.0, dot(n, light));\n        return white;\n        break;\n        \n        case PLANTS:\n        vec3 darkGreen = vec3(0.6, 0.9, 0.7) * max(0.0, dot(n, light));\n        return darkGreen += 0.5 * vec3(0.5, 0.7, 0.5);\n        break;\n        \n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    if(t == -1.0) {\n        return Intersection(t, skyColor(dir), vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, LIGHT_POS);\n        }\n    }\n    \n    // set focal length and range\n    float focalLength = 1.0;\n\tfloat focalRange = 5.0;\n        \n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - focalLength) / focalRange);\n    dofZ = pow(dofZ, 0.5);\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    int objHit = aaIsects[0].object;\n    \n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    \n    float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.05, 0.08, 0.05), fogT);\n        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int RAY_STEPS = 100;\nconst float PI = 3.14159;\nconst float AO_DIST = 0.6;\nconst float FIVETAP_K = 1.0;\n\n// primitive locations\nconst vec3 floorPos = vec3(0.0, 5.1, 12.0);\n\nconst vec3 totoroHeadPos = vec3(5.0, -1.9, 9.5);\nconst vec3 totoroBodyPos = vec3(5.0, 0.5, 9.5);\nconst vec3 totoroLLegPos = vec3(2.55, 3.4, 9.5);\nconst vec3 totoroLFootPos = vec3(3.0, 4.8, 9.5);\nconst vec3 totoroRLegPos = vec3(7.45, 3.4, 9.5);\nconst vec3 totoroRFootPos = vec3(7.0, 4.8, 9.5);\nconst vec3 totoroLArmPos = vec3(1.6, 0.4, 8.5);\nconst vec3 totoroRArmPos = vec3(8.4, 0.4, 8.5);\nconst vec3 totoroLEarPos = vec3(3.6, -4.3, 10.);\nconst vec3 totoroREarPos = vec3(6.4, -4.3, 10.);\nconst vec3 totoroMarkTopPos = vec3(4.2, -0.9, 12.2);\nconst vec3 totoroMarkBottomPos = vec3(4.7, 0.5, 12.3);\n\nconst vec3 signPolePos = vec3(-7.0, 1., 9.0);\nconst vec3 signBasePos = vec3(-7.0, 4.6, 9.0);\nconst vec3 signMidPos = vec3(-7.0, 0.4, 9.2);\nconst vec3 signTopPos = vec3(-7.0, -2.8, 9.0);\n\n// primitive forward declarations\nfloat sphere(vec3 p, float r, vec3 c);\nfloat box(vec3 p, vec3 b);\nfloat cylinder(vec3 p, float h, float r);\nfloat ellipse(vec3 p, vec3 r);\nfloat cone(vec3 p, float r1, float r2, float h);\n\n// define primitives and constants\n#define FLOOR 1\n#define TOTORO 3\n#define TOTORO_FUR 4\n#define EYE 5\n#define FACE_DETAIL 6\n#define SIGN 7\n#define SIGN_POST 8\n\n#define TOTORO_HEAD ellipse(pos + totoroHeadPos, vec3(2.8, 2.7, 2.5))\n#define TOTORO_BASE ellipse(pos + totoroBodyPos, vec3(3.6, 4.5, 2.8))\n#define TOTORO_LLEG ellipse(rotateZ(pos + totoroLLegPos, 20. * PI / 180.), vec3(1., 1.7, 1.))\n#define TOTORO_LFOOT unionSmooth(ellipse(pos + totoroLFootPos, vec3(0.8, 0.3, 0.4)), TOTORO_LLEG, 0.2)\n#define TOTORO_RLEG ellipse(rotateZ(pos + totoroRLegPos, -20. * PI / 180.), vec3(1., 1.7, 1.))\n#define TOTORO_RFOOT unionSmooth(ellipse(pos + totoroRFootPos, vec3(0.8, 0.3, 0.4)), TOTORO_RLEG, 0.2)\n#define TOTORO_LARM ellipse(rotateZ(pos + totoroLArmPos, 80. * PI / 180.), vec3(1.95, 0.6, 1.4))\n#define TOTORO_RARM ellipse(rotateZ(pos + totoroRArmPos, -80. * PI / 180.), vec3(1.95, 0.6, 1.4))\n#define TOTORO_LOWER unionSmooth(unionSmooth(TOTORO_BASE, TOTORO_LFOOT, 0.8), TOTORO_RFOOT, 0.8)\n#define TOTORO_BODY unionSmooth(unionSmooth(TOTORO_LARM, TOTORO_LOWER, 0.3), TOTORO_RARM, 0.3)\n#define TOTORO_LLEAR cylinder(rotateZ(pos + totoroLEarPos, PI / 12.), 0.2, 0.2)\n#define TOTORO_RLEAR cylinder(rotateZ(pos + totoroREarPos, -PI / 12.), 0.2, 0.2)\n#define TOTORO_LUEAR cone(rotateZ(pos + totoroLEarPos + vec3(-0.1, -0.7, 0.), PI / 24.), 0.34, 0.16, 0.9)\n#define TOTORO_RUEAR cone(rotateZ(pos + totoroREarPos + vec3(0.1, -0.7, 0.), -PI / 24.), 0.34, 0.16, 0.9)\n#define TOTORO_LEAR unionSmooth(TOTORO_LLEAR, TOTORO_LUEAR, 0.5)\n#define TOTORO_REAR unionSmooth(TOTORO_RLEAR, TOTORO_RUEAR, 0.5)\n#define TOTORO_UPPER unionSmooth(unionSmooth(TOTORO_LEAR, TOTORO_HEAD, 0.3), TOTORO_REAR, 0.3)\n\n#define TOTORO_STOMACH bend(rotateX(pos + totoroBodyPos + vec3(-0.3, 0.7, 1.85), PI / 2.), 3., 1.05)\n#define TOTORO_TDETAILS repeatMark(pos + totoroMarkTopPos, 3. * PI / 4.2, 5. * PI / 3.9, 0.2, 0.14, 0.4)\n#define TOTORO_BDETAILS repeatMark(pos + totoroMarkBottomPos, 3. * PI / 4.2, 5. * PI / 3.9, 0.2, 0.14, 0.4)\n#define TOTORO_MARKINGS subOp(TOTORO_BDETAILS, subOp(TOTORO_TDETAILS, TOTORO_STOMACH))\n\n#define TOTORO_MARKINGS1 intersectSmooth(TOTORO_BDETAILS, TOTORO_STOMACH, 0.02)\n#define TOTORO_MARKINGS2 intersectSmooth(TOTORO_TDETAILS, TOTORO_STOMACH, 0.02)\n#define TOTORO_MARKINGSCUT unionOp(TOTORO_MARKINGS1, TOTORO_MARKINGS2)\n#define TOTORO_SDF unionOp(unionSmooth(TOTORO_UPPER, TOTORO_BODY, 0.5), TOTORO_MARKINGSCUT)\n\n#define TOTORO_LEYE cylinder(rotateX(pos + totoroHeadPos + vec3(0.9, -1.17, 2.5), PI / 2.), 0.26, 0.1)\n#define TOTORO_REYE cylinder(rotateX(pos + totoroHeadPos + vec3(-1.3, -1.12, 2.5), PI / 2.), 0.28, 0.1)\n#define TOTORO_LPUPIL cylinder(rotateX(pos + totoroHeadPos + vec3(0.85, -1.2, 2.51), PI / 2.), 0.12, 0.1)\n#define TOTORO_RPUPIL cylinder(rotateX(pos + totoroHeadPos + vec3(-1.25, -1.15, 2.51), PI / 2.), 0.12, 0.1)\n#define TOTORO_NOSE nose(rotateZ(pos + totoroHeadPos + vec3(-0.35, -1.1, 2.3), -PI / 2.2), 0.4, 0.13)\n\n#define SIGN_POLE cylinder(pos + signPolePos, 0.11, 3.2)\n#define SIGN_BASE cylinder(pos + signBasePos, 1.08, 0.4)\n#define SIGN_MID_BASE box(pos + signMidPos, vec3(0.4, 0.75, 0.2))\n#define SIGN_MID_SIDE cylinder(pos + signMidPos + vec3(0.3, -0.2, -0.2), 0.14, 0.8)\n#define SIGN_MID_BUMP ellipse(pos + signMidPos + vec3(0.14, -0.55, 0.1), vec3(0.12, 0.3, 0.2))\n#define SIGN_MID unionSmooth(SIGN_MID_BASE, SIGN_MID_BUMP, 0.1)\n#define SIGN_MID_ROUNDED cylinder(rotateX(pos + signMidPos + vec3(0.15, 0.0, -0.1), PI / 2.), 0.9, 0.8)\n#define SIGN_MID_SDF unionSmooth(intersectSmooth(SIGN_MID, SIGN_MID_ROUNDED, 0.1), SIGN_MID_SIDE, 0.2)\n#define SIGN_SDF unionOp(unionOp(SIGN_POLE, SIGN_BASE), SIGN_MID_SDF)\n\n#define SIGN_TOP cylinder(rotateX(pos + signTopPos, PI / 2.), 1.0, 0.25)\n\n#define FLOOR_SDF box(pos + floorPos, vec3(12., 0.1, 5.))\n#define LIGHT_POS vec3(6.0, -1.5, -15)\n\n#define FOVY 38.0\n#define SHADOW_HARDNESS 6.0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \n// ROTATION TRANSFORMS\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {   \n    eye = vec3(0.0, -2.0, -50.0);\n    ref = vec3(0.0, 3.0, 30.0);\n    \n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * iResolution.x / iResolution.y;\n    \n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\n// GEOMETRY PRIMITIVES\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat cylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat ellipse(vec3 p, vec3 r)\n{\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfloat cone(vec3 p, float r1, float r2, float h)\n{\n  vec2 q = vec2(length(p.xz), p.y);\n    \n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n    \n  if(k < 0.0) {\n      return length(q) - r1;\n  }\n  if(k > a * h) {\n      return length(q - vec2(0.0, h)) - r2;\n  }\n        \n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat capsule(vec3 p, float h, float r)\n{\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\n\n// CSG OPERATIONS\nfloat unionOp(float d1, float d2) {  \n    return min(d1, d2); \n}\n\nfloat subOp(float d1, float d2) { \n    return max(-d1, d2); \n}\n\n\n// BLENDSHAPE OPERATIONS\nfloat unionSmooth(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h *(1.0 - h); \n}\n\nfloat intersectSmooth(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0-h); \n}\n\nfloat bend(in vec3 p, float h, float r)\n{\n    const float k = -0.1;\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2  m = mat2(c, -s , s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return cylinder(q, h, r);\n}\n\nfloat nose(in vec3 p, float h, float r)\n{\n    const float k = 0.4;\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    mat2  m = mat2(c, -s , s, c);\n    vec3  q = vec3(m * p.xy, p.z);\n    return capsule(q, h, r);\n}\n\n\n// SDF REPETITION\nfloat repeatMark(in vec3 p, float rotZ1, float rotZ2, float r1, float r2, float h)\n{\n    vec3 c = vec3(1.2, 0., 0.);\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    vec3 ref = vec3(4.7, 0.5, 0.1);\n    float refVar = abs(length(q - ref));\n    vec3 offset = q;\n    if (p.x > 2.3) {\n        offset += vec3(0., length(q - p) * 0.1, -0.6);\n    } else if (p.x > 1.7) {\n        offset += vec3(0., length(q - p) * 0.1, -0.23);\n    } else if (p.x < -1.7) {\n        offset += vec3(0., length(q - p) * 0.1, -0.33);\n    } else if (p.x > 0.5) {\n        offset += vec3(0., length(q - p) * 0.1, -0.12);\n    } else {\n        offset += vec3(0., length(q - p) * 0.1, 0.035);\n    }\n    float lmark = cone(rotateZ(offset, rotZ1), r1, r2, h);\n    float rmark = cone(rotateZ(offset, rotZ2), r1, r2, h);\n    float mark = unionOp(lmark, rmark);\n    return mark - 0.005 * refVar;\n}\n\n// for ambient occlusion\nfloat sceneMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    \n    if (pos.x > 5.0 && pos.x < 8.5 && pos.y > -5. && pos.y < 1.9) {\n    \tt = min(t, SIGN_SDF);\n    }\n    if (pos.x > 5.0 && pos.x < 8.5 && pos.y >= 1.6 && pos.y < 4.0) {\n        t = min (t, SIGN_TOP);\n    }\n    \n    if (pos.x < -0.8 && pos.x > -9. && pos.y < 6.0 && pos.y > -5.0) {\n        t = min(t, TOTORO_SDF);\n        if (pos.x < -1.4 && pos.x > -8.2 && pos.y < 2.0 && pos.y > -4.5) {\n        \tt = min(t, TOTORO_MARKINGS);\n        }\n        if (pos.x < -1.4 && pos.x > -8.2 && pos.y > 1.9 && pos.y < 5.0) {\n            t = min(t, TOTORO_LEYE);\n            t = min(t, TOTORO_REYE);\n            t = min(t, TOTORO_LPUPIL);\n            t = min(t, TOTORO_RPUPIL);\n            t = min(t, TOTORO_NOSE);\n        }\n    }\n\t\n    return t;\n}\n\n// for lambert\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = FLOOR_SDF;\n    \n    if (pos.x > 5.0 && pos.x < 8.5 && pos.y > -5. && pos.y < 1.9) {\n    \tt = min(t, SIGN_SDF);\n    }\n    if (pos.x > 5.0 && pos.x < 8.5 && pos.y >= 1.6 && pos.y < 4.0) {\n        t = min (t, SIGN_TOP);\n    }\n    \n    if (pos.x < -0.8 && pos.x > -9. && pos.y < 6.0 && pos.y > -5.0) {\n        t = min(t, TOTORO_SDF);\n        if (pos.x < -1.4 && pos.x > -8.2 && pos.y < 2.0 && pos.y > -4.5) {\n        \tt = min(t, TOTORO_MARKINGS);\n        }\n        if (pos.x < -1.4 && pos.x > -8.2 && pos.y > 1.9 && pos.y < 5.0) {\n            t = min(t, TOTORO_LEYE);\n            t = min(t, TOTORO_REYE);\n            t = min(t, TOTORO_LPUPIL);\n            t = min(t, TOTORO_RPUPIL);\n            t = min(t, TOTORO_NOSE);\n        }\n    }\n\t\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = FLOOR_SDF;\n    obj = FLOOR;\n    \n    float t2;\n    \n    if (pos.x > 5.0 && pos.x < 8.5 && pos.y > -5. && pos.y < 1.9) {\n        if ((t2 = SIGN_SDF) < t) {\n        \tt = t2;\n        \tobj = SIGN;\n        }\n    }\n    \n    if (pos.x > 5.0 && pos.x < 8.5 && pos.y >= 1.6 && pos.y < 4.0) {\n        if ((t2 = SIGN_TOP) < t) {\n            t = t2;\n            obj = SIGN_POST;\n        }\n    }\n            \n    if (pos.x < -0.8 && pos.x > -9. && pos.y < 6.0 && pos.y > -5.0) {\n        if ((t2 = TOTORO_SDF) < t) {\n            t = t2;\n            obj = TOTORO;\n        }\n        if (pos.x < -1.4 && pos.x > -8.2 && pos.y < 2.0 && pos.y > -4.5) {\n            if ((t2 = TOTORO_MARKINGS) < t) {\n                t = t2;\n                obj = TOTORO_FUR;\n            }            \n        }\n        if (pos.x < -3.3 && pos.x > -6.4 && pos.y > 2.4 && pos.y < 3.6) {\n            if ((t2 = TOTORO_LEYE) < t) {\n                t = t2;\n                obj = EYE;\n            }\n            if ((t2 = TOTORO_REYE) < t) {\n                t = t2;\n                obj = EYE;\n            }\n            if ((t2 = TOTORO_LPUPIL) < t) {\n                t = t2;\n                obj = FACE_DETAIL;\n            } \n            if ((t2 = TOTORO_RPUPIL) < t) {\n                t = t2;\n                obj = FACE_DETAIL;\n            }\n            if ((t2 = TOTORO_NOSE) < t) {\n                t = t2;\n                obj = FACE_DETAIL;\n            }\n        }\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\nvec2 random1(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(324.1, 21.7)),\n                 dot(p, vec2(45.5,234.3))))\n                 * 345.098);\n}\n\nfloat WorleyNoise1(vec2 uv) {\n    const float dimen = 10.0; // dimension\n    uv[0] *= dimen;\n    float ratio = iResolution.y / iResolution.x;\n    uv[1] *= dimen * ratio; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n        \n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n                vec2 point = random1(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n                vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    \n    return minDist;\n}\n\nfloat WorleyNoise2(vec2 uv) {\n    const float dimen = 10.0; // dimension\n    uv[0] *= dimen;\n    float ratio = iResolution.y / iResolution.x;\n    uv[1] *= dimen * ratio; \n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; \n        \n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec2 neighbor = vec2(float(x), float(y)); \n                vec2 point = random2(uvInt + neighbor); \n                vec2 diff = neighbor + point - uvFract; \n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    \n    return minDist;\n}\n\nfloat WorleyNoise3(vec2 uv) {\n    const float dimen = 8.0; // dimension\n    uv[0] *= dimen;\n    float ratio = iResolution.y / iResolution.x;\n    uv[1] *= dimen * ratio; \n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; \n        \n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec2 neighbor = vec2(float(x), float(y)); \n                vec2 point = random2(uvInt + neighbor); \n                vec2 diff = neighbor + point - uvFract; \n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    \n    return minDist;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float t;\n    switch(hitObj) {\n        \n        case SIGN:\n        vec3 red = vec3(0.8, 0.8, 0.7) * max(0.0, dot(n, light));\n        // specular\n        vec3 l = normalize(light - p);\n        vec3 refl = reflect(-l, n);\n        float spec = pow(dot(normalize(view - p), refl), 5.);\n        red += 0.09 * 10. * spec;\n        red = clamp(red, vec3(0., 0., 0.), vec3(1., 1., 1.));\n        return red;\n        break;\n        \n        case SIGN_POST:\n        vec3 blue = vec3(0.5, 0.6, 1.0) * max(0.0, dot(n, light));\n        if (p.y > 2.4 && p.y < 3.1) {\n            blue = vec3(0.9, 0.9, 1.0) * max(0.0, dot(n, light));\n        }\n        return blue;\n        break;\n        \n        case FACE_DETAIL:\n        vec3 black = vec3(0.2, 0.2, 0.2) * max(0.0, dot(n, light));\n        return black;\n        \n        case TOTORO:\n        vec3 gray = vec3(0.6, 0.65, 0.525) * max(0.0, dot(n, light));\n        gray += 0.2 * vec3(0.45, 0.55, 0.425);\n        return gray;\n        break;\n        \n        case TOTORO_FUR:\n        vec3 yellow = vec3(1., 0.95, 0.725) * max(0.0, dot(n, light));\n        yellow += vec3(1., 1., 0.225) * 0.25;\n        return yellow;\n        break;\n        \n        // better view of this noise function here: https://www.shadertoy.com/view/wslBW2\n        case FLOOR:\n        vec3 col = vec3(0.8, 0.8, 0.8) * max(0.0, dot(n, light));\n        float noise1 = WorleyNoise1(p.xz);\n        float noise2 = WorleyNoise2(p.xz);\n        float noise3 = WorleyNoise2(p.xz);\n        float diam1 = 0.1 * (sin((iTime + 9.) * 0.5) / cos((iTime + 9.) * 0.5));\n        float diam2 = 0.1 * (sin(iTime * 0.5) / cos(iTime * 0.5));\n        float diam3 = 0.1 * (sin((iTime + 4.) * 0.5) / cos((iTime + 4.) * 0.5));\n        float diam4 = 0.1 * (sin((iTime - 5.) * 0.5) / cos((iTime - 5.) * 0.5));\n        float diam5 = 0.1 * (sin((iTime + 2.) * 0.5) / cos((iTime + 2.) * 0.5));\n    \tfloat diam6 = 0.1 * (sin(iTime - 9. * 0.5) / cos(iTime - 9. * 0.5));\n\n        if (noise1 >= diam1 && noise1 <= diam1 + 0.016) {\n            col += vec3(0.7);\n        } else {\n            col += vec3(0.);\n        }\n\n        if (noise1 >= diam2 && noise1 <= diam2 + 0.015) {\n            col += vec3(0.7);\n        } else {\n            col += vec3(0.);\n        }\n\n        if (noise2 >= diam3 && noise2 <= diam3 + 0.013) {\n            col += vec3(0.7);\n        } else {\n            col += vec3(0.);\n        }\n\n        if (noise2 >= diam4 && noise2 <= diam4 + 0.014) {\n            col += vec3(0.7);\n        } else {\n            col += vec3(0.);\n        }\n        \n        if (noise3 >= diam5 && noise3 <= diam5 + 0.01) {\n            col += vec3(0.7);\n        } else {\n            col += vec3(0.);\n        }\n        if (noise3 >= diam6 && noise3 <= diam6 + 0.01) {\n            col += vec3(0.7);\n        } else {\n            col += vec3(0.);\n        }\n\n        return col;\n        break;\n        \n        case EYE:\n        vec3 pureWhite = vec3(1.0, 1.0, 1.0);\n        return pureWhite;\n        break;\n        \n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    float ao = fiveTapAO(isect + vec3(1.5, 0., 0.), nor, FIVETAP_K);\n    \n    if (hitObj == FLOOR) {\n        surfaceColor *= ao;\n    }\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, LIGHT_POS);\n        }\n    }\n    \n    if (aaIsects[0].object != -1) {\n        \n        vec3 avgColor = vec3(0.0);\n        for(int i = 0; i < 4; ++i) {\n            avgColor += aaIsects[i].color;\n        }\n        avgColor *= 0.25;\n        fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n        float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n        \n\n    } else {\n        \n        // from https://www.shadertoy.com/view/XdfGDH\n        const int mSize = 11;\n        const int kSize = (mSize-1)/2;\n        float kernel[mSize];\n        vec3 final_color = vec3(0.0);\n\n        //create the 1-D kernel\n        float sigma = 20.0;\n        float Z = 0.0;\n        for (int j = 0; j <= kSize; ++j) {\n            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n        }\n\n        //get the normalization factor (as the gaussian has been clamped)\n        for (int j = 0; j < mSize; ++j) {\n            Z += kernel[j];\n        }\n\n        //read out the texels\n        for (int i= -kSize; i <= kSize; ++i) {\n            for (int j=-kSize; j <= kSize; ++j) {\n                final_color += kernel[kSize+j] * kernel[kSize+i] * \n                    texture(iChannel0, (fragCoord.xy + vec2(float(i),float(j))) / iResolution.xy).rgb;\n            }\n        }\n        \n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 uv2 = 2.0 * uv - vec2(1.0);\n        vec4 unblurredColor = texture(iChannel0, uv);\n        fragColor = unblurredColor;\n        fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n\n    }        \n}","name":"Buffer B","description":"","type":"buffer"}]}