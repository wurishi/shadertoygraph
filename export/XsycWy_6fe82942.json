{"ver":"0.1","info":{"id":"XsycWy","date":"1523064395","viewed":220,"name":"The obligatory pathtracer","username":"dpiponi","description":"Fixed bug.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 cube[6] = vec4[6](\n    vec4(0.0, 0.0, -1.0, -1.0),      // -z-1 < 0 i.e. z > -1\n    vec4(0.0, 0.0, 1.0, -1.0),       // \n    vec4(-1.0, 0.0, 0.0, -1.0),      // \n    vec4(1.0, 0.0, 0.0, -1.0),\n    vec4(0.0, -1.0, 0.0, -1.0),\n    vec4(0.0, 1.0, 0.0, -1.0));     // \n\nfloat rand(inout float seed) {\n    seed = seed+0.63;\n    float s = 1000.0*(seed+cos(17.0*seed-22.1*seed*seed));\n    seed = 11.37*seed+1.2;\n    seed = seed-floor(seed);\n    return s-floor(s);\n}\n\nfloat pi = 3.1415926;\n\nvec3 pointOrthoToPlane(inout float seed, vec3 n) {\n    float z = -1.0+2.0*rand(seed);\n    float rxy = sqrt(1.0 - z*z);\n    float phi = 2.0*pi*rand(seed);\n    float x = rxy * cos(phi);\n    float y = rxy * sin(phi);\n    vec3 d = vec3(x, y, z);\n    return dot(n, d) < 0.0 ? -d : d;\n}\n\nmat4 rotateX(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c, s, 0.0,\n                0.0, -s, c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 invRotateX(float theta) {\n    return rotateX(-theta);\n}\n\nmat4 rotateY(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat4(c, 0.0, -s, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                s, 0.0, c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 invRotateY(float theta) {\n    return rotateY(-theta);\n}\n\nmat4 translate(vec3 p) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\n\nmat4 invTranslate(vec3 p) {\n    return translate(-p);\n}\n\nmat4 scale(float s) {\n    return mat4(s, 0.0, 0.0, 0.0,\n                0.0, s, 0.0, 0.0,\n                0.0, 0.0, s, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 invScale(float s) {\n    return scale(1.0/s);\n}\n\nbool intersectConvex(out float near, out vec3 normal, vec4 cube[6], vec3 p, vec3 d) {\n    near = -1000.0;\n    float far = 1000.0;\n    for (int i = 0; i < 6; ++i) {\n        vec4 n = cube[i];\n        float np = dot(n, vec4(p, 1.0)); // 4\n        float nd = dot(n, vec4(d, 0.0)); // -1\n        if (nd == 0.0) {\n            // Parallel\n            if (np > 0.0) {\n                // All outside\n                return false;\n            }\n        } else {\n            // Find t at intersection\n            float t = -np/nd; // -p.z/d.z\n            if (nd < 0.0) {\n                // Entering\n                if (t > near) {\n                    normal = n.xyz;\n                    near = t;\n                }\n            } else {\n                // Exiting\n                far = min(far, t);\n            }\n        }\n    }\n    if (near > 0.0 && near < far) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool intersectScene(out float near, out vec3 normal, vec4 cube[6], vec3 p, vec3 d) {\n    bool did = false;\n    near = 1e8;\n\n    mat4 m = translate(vec3(0.6, 0.4, 0.0));\n    mat4 im = invTranslate(vec3(0.6, 0.4, 0.0));\n    m = m*rotateX(0.2*iTime);\n    im = invRotateX(0.2*iTime)*im;\n    m = m*rotateY(0.25*iTime);\n    im = invRotateY(0.25*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    vec3 new_p = (im*vec4(p, 1.0)).xyz;\n    vec3 new_d = (im*vec4(d, 0.0)).xyz;\n    float new_near;\n    vec3 new_normal;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    m = translate(vec3(0.6, -0.4, 0.0));\n    im = invTranslate(vec3(0.6, -0.4, 0.0));\n    m = m*rotateY(0.35*iTime);\n    im = invRotateY(0.35*iTime)*im;\n    m = m*rotateX(0.3*iTime);\n    im = invRotateX(0.3*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    new_p = (im*vec4(p, 1.0)).xyz;\n    new_d = (im*vec4(d, 0.0)).xyz;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    m = translate(vec3(-0.6, 0.4, 0.0));\n    im = invTranslate(vec3(-0.6, 0.4, 0.0));\n    m = m*rotateY(0.2*iTime);\n    im = invRotateY(0.2*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    new_p = (im*vec4(p, 1.0)).xyz;\n    new_d = (im*vec4(d, 0.0)).xyz;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    m = translate(vec3(-0.6, -0.4, 0.0));\n    im = invTranslate(vec3(-0.6, -0.4, 0.0));\n    m = m*rotateY(0.5*iTime);\n    im = invRotateY(0.5*iTime)*im;\n    m = m*rotateX(0.6*iTime);\n    im = invRotateX(0.6*iTime)*im;\n    m = m*scale(0.5);\n    im = invScale(0.5)*im;\n    new_p = (im*vec4(p, 1.0)).xyz;\n    new_d = (im*vec4(d, 0.0)).xyz;\n    if (intersectConvex(new_near, new_normal, cube, new_p, new_d)) {\n        did = true;\n        if (new_near < near) {\n            normal = (m*vec4(new_normal, 0.0)).xyz;\n            near = new_near;\n        }\n    }\n\n    return did;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n\n    vec3 p = vec3(0.0, 0.0, -3.0);\n    vec3 d = vec3(0.5*uv, 1.0);\n    float seed = uv.x+uv.y;\n    seed = rand(seed)+uv.y-uv.x;\n    seed = rand(seed)+iTime;\n    seed = rand(seed);\n\n    vec3 normal;\n    float near;\n    if (intersectScene(near, normal, cube, p, d)) {\n        p = p+near*d;\n        vec3 color = vec3(0.0, 0.0, 0.0);\n        float gain = 1.0/float(64);\n        for (int i = 0; i < 64; ++i) {\n            vec3 secondary = pointOrthoToPlane(seed, normal);\n            vec3 new_p = p+0.00001*secondary;\n            vec3 ignore;\n            float ignore2;\n            bool did = intersectScene(ignore2, ignore, cube, new_p, secondary);\n            if (did) {\n                color += vec3(0.0, 0.0, 0.0);\n            } else {\n                color += vec3(0.8, 0.8, 0.8);\n            }\n        }\n        fragColor = vec4(gain*color, 1.0);\n    } else {\n        fragColor = vec4(0, 0, 0, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}