{"ver":"0.1","info":{"id":"DscBWn","date":"1697013852","viewed":50,"name":"Quad Bézier real-time gradient","username":"dragostis","description":"This example draws a partially analytical real-time gradient following the distance to a segment of the x^2 parabola. This is basically a real-time SDF and can be trivially extended (by finding the right affine transform, x0, x1) to any quadratic Bézier.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradientbeziersdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Increase for higher accuracy.\n// 2u for error < 0.01\n// 3u for error < 0.002\n// 4u for error < 0.0004\n#define NEWTON_ROUNDS 2u\n\n// Fast cbrt function copied from:\n// https://www.shadertoy.com/view/ssyyDh\nfloat fastCbrt(float x) {\n    float y = uintBitsToFloat(709973695u + floatBitsToUint(x) / 3u);\n    \n    y = y * (2.0 / 3.0) + (1.0 / 3.0) * x / (y * y);\n    y = y * (2.0 / 3.0) + (1.0 / 3.0) * x / (y * y);\n    \n    return y;\n}\n\nvec3 fastCbrt(vec3 v) {\n    return vec3(fastCbrt(v.x), fastCbrt(v.y), fastCbrt(v.z));\n}\n\n// Oklab color mixing copied from:\n// https://www.shadertoy.com/view/ttcyRS\nvec3 oklabMix(vec3 colA, vec3 colB, float m) {\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n\n    vec3 lmsA = fastCbrt(kCONEtoLMS*colA);\n    vec3 lmsB = fastCbrt(kCONEtoLMS*colB);\n    // lerp\n    vec3 lms = mix(lmsA, lmsB, m);\n    // cone to rgb\n    return kLMStoCONE * (lms * lms * lms);\n}\n\n// Find the distance to the x^2 parabola partially analytically.\n// For a point (a, b), the minimal distance to x^2 is one of roots\n// of:\n//\n// 2 * x^3 + (1 - 2 * b) * x - a = 0\n//\n// For the case when b < 0, there is only one root that can be\n// computed using roots as in findOneRoot.\n//\n// For the case when b > 0, the Newton–Raphson method is used with\n// 4 rounds of refinement. The initial guesses used are the\n// solutions to b = x^2.\n//\n// Clamping the distance to x0 and x1 is trivial in the first case,\n// while, in the second, the distance is the minimum between the\n// two roots clamped between x0 and x1.\n\nfloat findOneRoot(float s, float a, float b, float c) {\n    float squareRoot = sqrt(s);\n    float cubicRoot = fastCbrt((-27.0 / 4.0) * a + 0.5 * squareRoot);\n    \n    return -(1.0 / 3.0) * cubicRoot - c / (3.0 * cubicRoot);\n}\n\nfloat newtonRound(float x, float a, float b) {\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float c = 1.0 - 2.0 * b;\n    \n    float num = 2.0 * x3 + c * x - a;\n    float denom = 6.0 * x2 + c;\n    \n    return x - num / denom;\n}\n\nfloat dist(vec2 p0, vec2 p1) {\n    vec2 d = p1 - p0;\n    return sqrt(d.x * d.x + d.y * d.y);\n}\n\nfloat distToParabola(vec2 pos, float x0, float x1) {\n    float d;\n    \n    // Flipping the problem avoids having to compute cubic\n    // root too close to 0 where accuracy is problematic.\n    if (pos.x > 0.0) {\n        pos.x = -pos.x;\n        float temp = x0;\n        x0 = -x1;\n        x1 = -temp;\n    }\n    \n    float c = 3.0 * pos.y - 3.0 / 2.0;\n    float s = (729.0 / 4.0) * pos.x * pos.x - 4.0 * c * c * c;\n    \n    if (s > 0.0) {\n        float x = findOneRoot(s, pos.x, pos.y, c);\n        x = clamp(x, x0, x1);\n        \n        d = dist(pos, vec2(x, x * x));\n    } else {\n        float s0 = sqrt(pos.y);\n        float s1 = -s0;\n        \n        for (uint i = 0u; i < NEWTON_ROUNDS; i++) {\n            s0 = newtonRound(s0, pos.x, pos.y);\n        }\n        \n        for (uint i = 0u; i < NEWTON_ROUNDS; i++) {\n            s1 = newtonRound(s1, pos.x, pos.y);\n        }\n        \n        s0 = clamp(s0, x0, x1);\n        s1 = clamp(s1, x0, x1);\n        \n        d = min(dist(pos, vec2(s0, s0 * s0)), dist(pos, vec2(s1, s1 * s1)));\n    }\n    \n    return d;\n}\n\nfloat animationLoop2Way(float totalAnimationTime) {\n    float halfAnimationTime = 0.5 * totalAnimationTime;\n    float animationTime = mod(iTime, totalAnimationTime);\n    \n    float t;\n    if (animationTime < halfAnimationTime) {\n        t = animationTime / halfAnimationTime;\n    } else {\n        animationTime -= halfAnimationTime;\n        t = 1.0 - animationTime / halfAnimationTime;\n    }\n    \n    return t;\n}\n\nfloat easeInOut(float t) {\n    return t < 0.5 ?\n        2.0 * t * t :\n        1.0 - (-2.0 * t + 2.0) * (-2.0 * t + 2.0) * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = fragCoord - iResolution.xy * 0.5;\n    \n    float x0 = -1.5;\n    float x1 = 0.2;\n    float dx = -x0 - x1;\n    float scale = 0.002;\n    \n    pos *= scale;\n    pos.y += 0.5;\n    \n    float t = easeInOut(animationLoop2Way(1.6));\n\n    x0 += dx * t;\n    x1 += dx * t;\n    \n    float d = distToParabola(pos, x0, x1);\n    \n    float r = 1.0 - d / (iResolution.x * scale);\n    // Cubed for a stronger gradient contrast.\n    float m = r * r * r;\n    \n    fragColor = vec4(oklabMix(vec3(0.02, 0.12, 0.87), vec3(0.7, 0.8, 1.0), m), 1.0);\n}","name":"Image","description":"","type":"image"}]}