{"ver":"0.1","info":{"id":"7dXcD7","date":"1642182581","viewed":88,"name":"Complex function visualisation 1","username":"Envy24","description":"source: https://www.youtube.com/watch?v=0hiWbdc8QEk\nMapping with complex functions.\n\nIn BufferA unmapped image.\nIn BufferB mapped image.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["function","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define AR                     ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define CENTER_NDC(SC)         ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n\n// x must be in TEX_COORDS.\n#define TEX0(TC)              ( texture(iChannel0, (TC)) )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float color = TEX0(TEX_COORDS(SC)).r;\n\n    O = vec4(color);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float circleSDSDF(\n    in vec2 S,           // sample coordinates\n    in vec2 C,           // circle center\n    in float r,          // circle radius\n    in float smoothness) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of areas (squared distancies).\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Returns cosine modulated value in range [min, max]. */\nfloat cosOSC(in float min, in float max, in float T)\n{\n    float v = (cos(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                       iResolution\n#define AR                     ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define CENTER_NDC(SC)         ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define CENTER_RC(SC)          ( ((SC)+(SC)-R.xy) )               // in range x=[-R.x*0.5; R.x*0.5] y=[-R.y*0.5; R.y*0.5]\n#define INITIALLY_LARGE         9e30\n#define NZMX                   ( floor(iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                   ( floor(iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n\nfloat sceneA(in vec2 SC)\n{\n    return circleSDSDF(CENTER_NDC(SC) * 2.0, vec2(0.0, 0.0) + vec2(sinOSC(-1.0, 1.0, iTime)), 0.08, 0.04);\n}\n\nfloat sceneB(in vec2 SC)\n{\n    vec2 NDC = CENTER_NDC(SC) * 2.0;\n\n    float minX = (CENTER_NDC(vec2(0.0,0.0)) * 2.0).x;\n    float minY = (CENTER_NDC(vec2(0.0,0.0)) * 2.0).y;\n\n    float r = 0.02;\n    float aa = 0.02;\n\n    float gray = INITIALLY_LARGE;\n\n    vec2 O = vec2(NZMX, NZMY); // offset point\n\n    float xStep = (-minX * 2.0) / floor(R.x);\n    float yStep = (-minX * 2.0) / floor(R.y);\n\n    /* horizontal line */\n    for (float x = minX; x <= -minX; x += xStep)\n    {\n        gray = min(gray, circleSDSDF(vec2(x, NDC.y) + cosOSC(-1.0, 1.0, iTime), O, r, aa));\n    }\n    /**/\n    \n    /* vertical line */\n    for (float y = minY; y <= -minY; y += yStep)\n    {\n        gray = min(gray, circleSDSDF(vec2(NDC.x, y) + sinOSC(-1.0, 1.0, iTime), O, r, aa));\n    }\n    /**/\n    \n    return gray;\n}\n\nfloat sceneC(in vec2 SC)\n{\n    vec2 NDC = CENTER_NDC(SC) * 4.0;\n\n    float r = 0.08;\n    float aa = 0.04;\n    \n    float xOffs = sinOSC(-1.0, 1.0, iTime) + NZMX;\n    float yOffs = cosOSC(-1.0, 1.0, iTime) + NZMY;\n\n    float gray = circleSDSDF(NDC, vec2(1.0 + xOffs, 0.5 + yOffs), r, aa);\n    gray = min(gray, circleSDSDF(NDC, vec2(1.25 + xOffs, 0.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.5 + xOffs, 0.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.75 + xOffs, 0.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(2.0 + xOffs, 0.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.0 + xOffs, 0.75 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.0 + xOffs, 1.0 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.0 + xOffs, 1.25 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.0 + xOffs, 1.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.25 + xOffs, 1.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.5 + xOffs, 1.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(1.75 + xOffs, 1.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(2.0 + xOffs, 1.5 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(2.0 + xOffs, 1.25 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(2.0 + xOffs, 1.0 + yOffs), r, aa));\n    gray = min(gray, circleSDSDF(NDC, vec2(2.0 + xOffs, 0.75 + yOffs), r, aa));\n    \n    return gray;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    //O = vec4(sceneA(SC));\n    //O = vec4(sceneB(SC));\n    O = vec4(sceneC(SC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R                       iResolution\n#define AR                     ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define CENTER_NDC(SC)         ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMY                   ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n\n// x must be in TEX_COORDS.\n#define TEX0(TC)              ( texture(iChannel0, (TC)) )\n\nstruct complex\n{\n    float re;\n    float im;\n};\n\ncomplex csqrt(in complex c)\n{\n    float signOfIm =\n        c.im >= 0.0 ?\n            1.0 : -1.0;\n\n    float innerSqRoot = sqrt(c.re * c.re + c.im * c.im);\n\n    return complex(\n        sqrt((innerSqRoot + c.re) * 0.5),\n        signOfIm * sqrt((innerSqRoot - c.re) * 0.5));\n}\n\ncomplex cmul(in complex z, in complex w)\n{\n    return complex(\n        z.re * w.re - z.im * w.im,\n        z.re * w.im + w.re * z.im);\n}\n\ncomplex func(complex z)\n{\n    //return cmul(z, z); // f(z) = z^2;\n    //return cmul(cmul(z, z), z); // f(z) = z^3;\n    return cmul(cmul(cmul(z, z), z), z); // f(z) = z^3;\n    // .. etc\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = CENTER_NDC(SC);\n    \n    complex z; z.re = NDC.x; z.im = NDC.y;\n\n    z = func(z);\n    \n    float color = TEX0((vec2(z.re, z.im) + vec2(1.0, 1.0)) * 0.5).r;   \n\n    O = vec4(color);\n}","name":"Buffer B","description":"","type":"buffer"}]}