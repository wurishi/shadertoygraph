{"ver":"0.1","info":{"id":"lctcRB","date":"1730840866","viewed":33,"name":"My first bad shader","username":"Relayx","description":"Simple shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS    90\n#define MAX_DIST     10.0\n#define SHADOW_STEPS 20\n#define EPS          0.003\n\nconst vec3 eye   = vec3(0, 1, 5);\nconst vec3 light = vec3(2, 5, 5);\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nfloat planeSDF(vec3 p) {\n    return p.y + EPS;\n}\n\n\nfloat scene(vec3 point, out int objectID) {\n    float shpereY = sin(iTime) * 1.0 + 2.0;\n    float sphereDist = sphereSDF(point, vec3(0, shpereY, 0), 1.0);\n    float planeDist = planeSDF(point);\n\n\n    if (sphereDist < planeDist) {\n        objectID = 1;\n        return sphereDist;\n    } else {\n        objectID = 2;\n        return planeDist;\n    }\n}\n\nvec3 generateNormal(vec3 z, float d) {\n    float e = max(d * 0.5, EPS);\n    int temp;\n    \n    float dx1 = scene(z + vec3(e, 0, 0), temp);\n    float dx2 = scene(z - vec3(e, 0, 0), temp);\n    float dy1 = scene(z + vec3(0, e, 0), temp);\n    float dy2 = scene(z - vec3(0, e, 0), temp);\n    float dz1 = scene(z + vec3(0, 0, e), temp);\n    float dz2 = scene(z - vec3(0, 0, e), temp);\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvec3 trace(vec3 from, vec3 dir, out bool hit, out int objectID) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    hit = false;\n\n    for (int step = 0; step < MAX_STEPS; ++step) {\n        float dist = abs(scene(p, objectID));\n        if (dist < EPS) {\n            hit = true;\n            break;\n        }\n\n        totalDist += dist;\n\n        if (totalDist > MAX_DIST)\n            break;\n\n        p += dir * dist;\n    }\n    \n    return p;\n}\n\nfloat softShadow(vec3 from, vec3 dir, float minDist, float maxDist) {\n    float shadowFactor = 1.0;\n    float totalDist = minDist;\n\n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        int objID;\n        float dist = scene(from + dir * (totalDist + EPS), objID);\n\n        if (dist < EPS) {\n            return 0.0;\n        }\n\n        shadowFactor = min(shadowFactor, dist / totalDist);\n        totalDist += dist;\n\n        if (totalDist > maxDist) {\n            break;\n        }\n    }\n    \n    return shadowFactor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool hit;\n    int objectID;\n    vec3 color;\n    \n    vec2 scale = 8.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2(0.5));\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec3 p = trace(eye, dir, hit, objectID);\n    \n    if (hit) {\n        vec3 l   = normalize(light - p);\n        vec3 v   = normalize(eye - p);\n        vec3 n   = generateNormal(p, EPS);\n        float nl = max(0.0, dot(n, l));\n        vec3 h  = normalize(l + n);\n        float hn = max(0.0, dot(h,n));\n        float sp = pow(hn, 100.0);\n        \n        float shadow = softShadow(p + n * EPS, l, EPS, 10.0);\n        \n        if (objectID == 1) {\n            color = color = 0.7 * vec3(nl) + 0.3 * cos(iTime+uv.xyx+vec3(0,2,4)) + sp * vec3(1.0, 1.0, 1.0);\n        } else if (objectID == 2) {\n            color = vec3(0.4, 0.5, 0.5) * nl * shadow;\n        }\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}