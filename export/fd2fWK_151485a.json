{"ver":"0.1","info":{"id":"fd2fWK","date":"1647103402","viewed":99,"name":"Rings with Cube","username":"formographik","description":"rings with a cube","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  p.xy *= Rot(T);\n  p.yx *= Rot(-T);\n  p.yz *= Rot(-T);\n  \n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) - r + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat GetDist(vec3 p) {\n    vec3 p2 = p;\n    \n    p2.yz *= Rot(3.14159/2.);\n\n    vec3 orbit = vec3(p.x+sin(T)*3.,p.y+cos(T)*3.,p.z+.25);\n     \n    float t = sdTorus(vec3(p2.x,p2.y-.5,p2.z)*.25, vec2(0.75,0.15));\n    float b = sdRoundBox(orbit*1.5, vec3(1), 0.);\n    float res = smin(t,b,0.75);\n    \n    float g = p2.y+.5;\n    \n    return min(res, g );\n    \n}\n\n\nfloat castShadow (in vec3 ro, vec3 rd) {\n\n    float res = 1.0;\n    float t = 0.001;\n    \n    for ( int i = 0; i < 100; i++) {\n        vec3 pos = ro + t*rd;\n        float h = GetDist( pos );\n        \n        res = min( res, 16.0*h/t );\n        if (res<0.0001) break;\n        \n        t += h;\n        if (t>20.) break;\n    }\n\n    return clamp(res,0.,1.0);\n}\n\n\nfloat RayMarch(in vec3 ro, vec3 rd) {\n    float t = 0.01;\n    for (int i=0; i<MAX_STEPS; i++) {\n        vec3 pos = ro + t*rd;\n        \n        float h = GetDist( pos );\n        \n        if (h<0.001) break;\n        t += h;\n        if( t>20.0 ) break;\n        \n    }\n    return t;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.yy;\n\n    vec3 ro = vec3(0, 0, -5.25);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = vec3(0.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n       vec3 p = ro + d * rd;\n       vec3 n = GetNormal(p);\n       vec3 r = reflect(rd, n);\n\n       vec3 sun_dir = normalize( vec3(0.,0.0,-.001) )*.175;\n       float sun_sha = castShadow( p+n*0.001, sun_dir );\n\n       vec2 uv = p.yx*.5;\n       float f = smoothstep(uv.y, cos(T * .66 + length(uv * 1.25)), cos(length(uv * 1.75) * 66.));\n        \n       col  = vec3(f)*sun_sha;      \n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n\n// easy adaptive sampling\n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    render(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++; // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}