{"ver":"0.1","info":{"id":"XlBBDV","date":"1517170170","viewed":355,"name":"Opposing Temperatures","username":"AustinSpafford","description":"Visualizing the larger context of \"There's at least two opposing points on every great circle with equal temperatures.\" by generating random temps using 4D-noise, and then highlighting the areas with matched temperatures on the opposite side.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["noise","planet","raytrace","temperature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define square(x) ((x) * (x))\n\nconst float k_pi = 3.14159265359;\nconst float k_tau = 6.28318530718;\n\n//vec3 u_lightDirection = normalize(vec3(1.0));\n\nvec2 s_mouseFractions;\n\nfloat LinearStep(\n    float edge0,\n    float edge1,\n    float value)\n{\n    float unboundedResult =\n        (edge0 != edge1) ?\n            ((value - edge0) / (edge1 - edge0)) :\n            step(value, edge1);\n    \n\treturn clamp(unboundedResult, 0.0, 1.0);\n}\n\nmat3 RotationMatrixX(\n\tfloat theta)\n{\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    return mat3(\n    \t1.0, 0.0, 0.0, // x-basis\n        0.0, cosTheta, sinTheta, // y-basis\n        0.0, (-1.0 * sinTheta), cosTheta); // z-basis\n}\n\nmat3 RotationMatrixY(\n\tfloat theta)\n{\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    return mat3(\n    \tcosTheta, 0.0, (-1.0 * sinTheta), // x-basis\n        0.0, 1.0, 0.0, // y-basis\n        sinTheta, 0.0, cosTheta); // z-basis\n}\n\nmat3 RotationMatrixZ(\n\tfloat theta)\n{\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    return mat3(\n    \tcosTheta, sinTheta, 0.0, // x-basis\n        (-1.0 * sinTheta), cosTheta, 0.0, // y-basis\n        0.0, 0.0, 1.0); // z-basis\n}\n\nvec3 HsbToRgb(\n    vec3 hsbColor)\n{\n    //  From: IÃ±igo Quiles \n    //  https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod((hsbColor.x * 6.0) + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = (rgb * rgb * (3.0 - (2.0 * rgb)));\n    return (hsbColor.z * mix(vec3(1.0), rgb, hsbColor.y));\n}\n\nfloat Random(\n\tvec4 testCoord)\n{\n\treturn fract(\n\t\tsin(dot(testCoord, vec4(127.1, 311.7, 269.5, 183.3))) * \n\t\t43758.5453123);\n}\n\nvec4 Random4(\n\tvec4 testCoord)\n{\n\tvec4 testPointInGeneratorSpace = vec4(\n\t\tdot(testCoord, vec4(127.1, 311.7, 295.2, 97.5)),\n\t\tdot(testCoord, vec4(269.5, 183.3, 529.1, 361.3)),\n\t\tdot(testCoord, vec4(419.2, 371.9, 284.9, 532.7)),\n\t\tdot(testCoord, vec4(810.5, 235.0, 792.1, 427.5)));\n\n\treturn fract(sin(testPointInGeneratorSpace) * 43758.5453);\n}\n\n#if 0\nfloat AbsurdlyExpensiveVoroNoise(\n\tvec4 testCoord)\n{\n\t// Based on: https://iquilezles.org/articles/voronoise\n    \n    // Performance: Yes, 4D voronoise is a terrible idea performance-wise, but I just wanted something\n    // that's trivial to implement, rather than tackling 4D simplex noise while tired.\n\n\tvec4 testWhole = floor(testCoord);\n\tvec4 testFraction = fract(testCoord);\n\n\tfloat accumulator = 0.0;\n\tfloat totalWeight = 0.0;\n\n\tfor (int xIndex = -2; xIndex <= 2; xIndex++)\n\t{\n\t\tfor (int yIndex = -2; yIndex <= 2; yIndex++)\n\t\t{\n            for (int zIndex = -2; zIndex <= 2; zIndex++)\n            {\n                for (int wIndex = -2; wIndex <= 2; wIndex++)\n                {\n                    vec4 cellRelative = vec4(float(xIndex), float(yIndex), float(zIndex), float(wIndex));\n                    vec4 cellCoord = (testWhole + cellRelative);\n\n                    vec4 cellJitter = Random4(cellCoord);\n                    float cellValue = Random(cellCoord);\n\n                    vec4 selfToCell = ((cellRelative + cellJitter) - testFraction);\n                    float cellWeight = smoothstep(1.414, 0.0, length(selfToCell));\n\n                    accumulator += (cellWeight * cellValue);\n                    totalWeight += cellWeight;\n                }\n            }\n\t\t}\n\t}\n\n\treturn (accumulator / totalWeight);\n}\n#endif\n\nfloat TextureNoise3D(\n    vec3 x)\n{\n    // From: https://www.shadertoy.com/view/4sfGzS\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat HackyTextureNoise4D(\n\tvec4 testCoord)\n{\n    // Warp the w-dimension to avoid synchronizing changes across xyz.    \n    float wShifted = (\n        testCoord.w + \n\t\tTextureNoise3D(testCoord.xyz + vec3(0.5)));\n    \n    vec3 layeringAxis = vec3(1.274, 2.832, 3.233);\n\n    float prevValue = TextureNoise3D(testCoord.xyz + fract(layeringAxis * floor(wShifted)));    \n    float nextValue = TextureNoise3D(testCoord.xyz + fract(layeringAxis * ceil(wShifted)));\n    \n    float rawBlendingFraction = fract(wShifted);\n    float blendingFraction = mix(rawBlendingFraction, smoothstep(0.0, 1.0, rawBlendingFraction), 0.5);\n    \n    return mix(prevValue, nextValue, blendingFraction);\n}\n\nvec2 GetAspectRatioCorrectionScalars(\n\tvec2 textureResolution)\n{\n    vec2 result = vec2(1.0);\n    \n\tfloat textureAspectRatio = (textureResolution.x / textureResolution.y);\n        \n    // Perform basic aspect-ratio correction.\n\tresult.x *= max(1.0, textureAspectRatio);\n    result.y *= max(1.0, (1.0 / textureAspectRatio));\n    \n    // Crop down until the artwork is touching at least one pair of edges.\n    {\n        float artworkAspectRatio = 1.0;\n        \n        //artworkAspectRatio = textureAspectRatio; // Zoom in until the artwork fills the frame.\n        \n        if ((artworkAspectRatio > 1.0) && (textureAspectRatio > 1.0))\n        {\n            result /= min(artworkAspectRatio, textureAspectRatio);\n        }\n        else if ((artworkAspectRatio < 1.0) && (textureAspectRatio < 1.0))\n        {\n            result *= max(artworkAspectRatio, textureAspectRatio);\n        }\n    }\n    \n    return result;\n}\n\nbool TryIntersectSphere(\n    vec3 sphereCenter,\n    float sphereRadius,\n    bool useNearSurface,\n    vec3 rayOrigin,\n    vec3 rayDirection,\n    inout float inoutHitDistance,\n\tinout vec3 inoutNormalLazy)\n{\n    bool result = false;\n    \n    vec3 rayOriginToSphereCenter = (sphereCenter - rayOrigin);\n    float rayOriginToSphereCenterDistanceSquared = dot(rayOriginToSphereCenter, rayOriginToSphereCenter);\n    \n    float rayOriginToIntersectionCenterDistance = dot(rayOriginToSphereCenter, rayDirection);\n    float sphereCenterToIntersectionCenterDistanceSquared = (rayOriginToSphereCenterDistanceSquared - square(rayOriginToIntersectionCenterDistance));\n    float intersectionRadiusSquared = (square(sphereRadius) - sphereCenterToIntersectionCenterDistanceSquared);\n    \n    // If the line of the ray intersects the sphere at all.\n    if (intersectionRadiusSquared >= 0.0)\n    {\n        float intersectionRadius = sqrt(intersectionRadiusSquared);\n        \n        float hitDistance = \n            useNearSurface ?\n            \t(rayOriginToIntersectionCenterDistance - intersectionRadius) :\n        \t\t(rayOriginToIntersectionCenterDistance + intersectionRadius);\n                            \n        if ((0.0 <= hitDistance) && (hitDistance < inoutHitDistance))\n        {\n            vec3 hitPosition = (rayOrigin + (hitDistance * rayDirection));\n                                                                \n            inoutHitDistance = hitDistance;\n            inoutNormalLazy = ((useNearSurface ? 1.0 : -1.0) * (hitPosition - sphereCenter));\n        \tresult = true;\n        }\n    }\n    \n    return result;\n}\n\nfloat CalcTemperatureFraction(\n    vec3 testPoint)\n{\n    float noiseValue = \n        mix(\n            mix(\n                mix(\n                    HackyTextureNoise4D(vec4((32.0 * testPoint), (0.65 * iTime))),\n                    HackyTextureNoise4D(vec4((16.0 * testPoint), (0.5 * iTime))),\n                    0.66),\n                HackyTextureNoise4D(vec4((8.0 * testPoint), (0.35 * iTime))),\n                0.66),\n            HackyTextureNoise4D(vec4((4.0 * testPoint), (0.2 * iTime))),\n            0.66);\n\n    //temperatureFraction = mix(temperatureFraction, smoothstep(-1.0, 1.0, cos(k_tau * temperatureFraction * abs(testPoint.y))), 0.8);\n    //temperatureFraction *= (1.1 - abs(testPoint.y));\n    float temperatureFraction =\n        //mix(0.75, 0.25, abs(testPoint.y)) +\n        mix(0.25, 0.75, pow(smoothstep(-1.0, 1.0, cos(k_pi * testPoint.y)), 2.0)) +\n        mix(-0.25, 0.25, smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, noiseValue)));\n    temperatureFraction = mix(0.0, mix(1.0, 0.5, abs(testPoint.y)), temperatureFraction); // Chill the ice caps.\n    //temperatureFraction = square(temperatureFraction);\n    //temperatureFraction = noiseValue; // Debug.\n    \n    return temperatureFraction;\n}\n\nvec3 CalcSceneColor(\n    vec2 fragCoord,\n    vec2 textureResolution,\n    bool displayTemperatureEquality)\n{\n    vec3 result = vec3(0.0);\n    \n\tvec2 fragUv = (\n        mix(vec2(-1.0), vec2(1.0), (fragCoord.xy / textureResolution)) *\n        GetAspectRatioCorrectionScalars(textureResolution));\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(fragUv, -1.5));\n    \n    // Camera-pitch.\n    {     \n        float pitchFraction = mix(0.25, -0.25, ((s_mouseFractions.xy == vec2(0.0)) ? 0.5 : s_mouseFractions.y));\n        mat3 transform = RotationMatrixX(pitchFraction * k_tau);\n        rayOrigin *= transform;\n        rayDirection *= transform;\n    }\n    \n    // Camera-yaw.\n    {     \n        float yawFraction = mix(-0.5, 0.5, ((s_mouseFractions.xy == vec2(0.0)) ? 0.5 : s_mouseFractions.x));\n        mat3 transform = RotationMatrixY(yawFraction * k_tau);\n        rayOrigin *= transform;\n        rayDirection *= transform;\n    }\n    \n    float sceneHitDistance = 1000.0;\n    vec3 sceneNormalLazy = vec3(0.0);\n    bool hitScene = TryIntersectSphere(\n        vec3(0.0), // sphereCenter\n        1.0, // sphereRadius\n        true, // useNearSurface\n        rayOrigin,\n        rayDirection,\n        sceneHitDistance,\n    \tsceneNormalLazy);\n    \n    if (hitScene)\n    {\n        vec3 scenePosition = (rayOrigin + (rayDirection * sceneHitDistance));\n        vec3 sceneNormal = normalize(sceneNormalLazy);\n        \n        float temperatureFraction = CalcTemperatureFraction(scenePosition);\n        \n        float brightness = 0.9;\n        if (displayTemperatureEquality)\n        {\n            float opposingTemperatureFraction = CalcTemperatureFraction(-1.0 * scenePosition);\n            float temperatureDifference = (temperatureFraction - opposingTemperatureFraction);\n            \n            float samenessFraction = smoothstep(0.98, 1.0, (1.0 - abs(temperatureDifference)));\n            \n            brightness = mix(0.1, 1.0, samenessFraction);\n        }\n        \n        vec3 temperatureColor = HsbToRgb(vec3(\n            mix(0.65, 0.02, smoothstep(0.0, 1.0, temperatureFraction)),\n            1.0,\n            brightness));\n        \n        float lightingFraction = pow(\n            LinearStep(-0.6, 1.0, dot(sceneNormal, (-1.0 * rayDirection))),\n            2.0);\n        \n        result = temperatureColor;\n        result *= lightingFraction;\n    }\n    \n    return result;\n}\n    \n\nvoid mainImage(\n    out vec4 outFragColor, \n    in vec2 fragCoord)\n{\n\ts_mouseFractions = (iMouse.xy / iResolution.xy);\n    \n    bool isLeftPanel = (fragCoord.x < (0.5 * iResolution.x));\n        \n    outFragColor.rgb = CalcSceneColor(\n        (fragCoord + (vec2((isLeftPanel ? 0.0 : -0.5), 0.0) * iResolution.xy)), // fragCoord\n        (iResolution.xy * vec2(0.5, 1.0)), // textureResolution\n        !isLeftPanel); // displayTemperatureEquality\n    \n    outFragColor.rgb = sqrt(outFragColor.rgb); // Convert linear-color to gamma-color.\n\toutFragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}