{"ver":"0.1","info":{"id":"tstcDH","date":"1600898982","viewed":160,"name":"water V2","username":"danhel95","description":"water attempt !","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","tutorial","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// learning tutorial 10 ! or 11 !?\n// attempt water by testing a noise function by Del https://www.shadertoy.com/view/Ws3yWn\n// seems working :)\n\n#define ZERO min(iFrame,0)\n\n\n\nobj scene(vec3 p) {\n\n\n\n    float w = 2.9, h1 = .1 ,h2 = .3;\n    vec3 p0 = vec3(0, h1, 0); \n\n    float a = 4., b = 1. , k = -.2 , h = .25;\n\n    vec3 q = p;\n    q.xz += a*((p.y)) - b ;\n    float dw =  eau(q,.5*iTime ) ;\n    float dp = box(p , p0, vec3(w , h2 + .4*sqrt(dw), w))  ;\n    spheres(p );\n    obj sph = ob_s;\n    float db = bassin(p);\n    //dp  +=  h*dw + k;\n\n    obj pln = obj(dp ,vec3(.059, .059, .875),vec3(0.), .3, 1., 3., 10.,1., 3.,pl_bs_geo);\n    obj bsn = obj(db,vec3(1.),vec3(0.),  .5, 1., 3., 100.,.1, 4.,pl_bs_geo);\n\n    obj r = uop(pln,bsn);\n    r = uop(r,sph);\n\n    return r;\n\n\n}\n\n\n\n\n\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z,2.);\n}\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    if(ob.id < 2.) {\n        float f = checkerboard(p);\n        ob.material *= 0.1 + f*vec3(1.);\n    }\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi*2. ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    float a = max(abs(dot(normalize(lp), rd)), 0.1);\n    float foff = smoothstep(FAR/15. , .0, (l - s.rad) /d ) ;\n    //float foff = step( (l - s.rad)/d , FAR/15. ) ;\n    float g = pow(a,5000.) * foff ;\n   return s.col * g * i;\n}\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        if(ob.id < 4. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ms = iMouse.xy/iResolution.xy ;\n    vec3 color = vec3(.0),tot;\n\t\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    update(iTime);\n    ray r = raydir(uv,ms);\n    color = render(r);\n\n    color = sqrt( color );\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-5\n#define FAR 60.\n#define REFSTEP 4.\n#define pow(a,b) pow(abs(a),(b))\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct obj_geo\n{\n    vec3 c;\n    vec3 oc;\n    vec3 acc;\n    float m;\n    float mi;\n    vec3 t_ax;\n    float ang;\n    float ang_v;\n    float ang_acc;\n    vec3 sz;\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n    obj_geo geo;\n\n};\n\nobj ob_s = obj(FAR ,vec3(.86,.3,.1),vec3(0.), .5, 1., 3., 100.,1.,2. ,\nobj_geo(vec3(0., .5  , 0.),vec3(0.),vec3(0.),1.,.5,vec3(.0),.0,.0,.0 ,vec3(.5,.2,.5)));\n\nobj_geo pl_bs_geo = obj_geo(vec3(0., 1.  , 0.),vec3(0.),vec3(0.),1.,.5,vec3(.0),.0,.0,.0 ,vec3(1.));\n\nfloat st = 0., et = 0.;\n\n\nfloat rand(vec2 co){\n    float realRandom = iDate.w;\n    return fract(sin(realRandom+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) -0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\n\n\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;\n    return k/scale;\n}\n\n\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    float w = 3., h1 = 1.7,h2 = 2.;\n    vec3 p1 = p  - vec3(0, h1, 0);\n    float db2 = box(p1, vec3(w, h2, w));\n    float dp2 = plane(p1,vec4(0, 1., 0, 1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2);\n    return db2;\n\n}\n\nfloat torus( in vec3 p, vec3 pos, vec2 rad )\n{\n    p = p - pos ;\n    float d = length( vec2(length(p.xz)-rad.x,p.y) )-rad.y;\n\n    return d;\n}\n\n\nvoid spheres(vec3 p) {\n\n    //float ds = sphere(p,ob_s.geo.c , ob_s.geo.sz.x);\n    float ds = torus(p,ob_s.geo.c , ob_s.geo.sz.xy);\n    ob_s.d = ds ;\n}\n\n\n\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/4. + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\nfloat eau( vec3 pos, float t )\n{\n    float rad =  (1.0/(3.141*2.0)*100.);\n    vec3 dp =  vec3(pos.z, atan(pos.x, pos.y) * rad, rad-length(pos.xy));\n    float n1 = noise(dp+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);\n    float n2 = noise(dp+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);\n\n    n1 = smax(n1,n2,.5);\n    float n3 = noise(pos+vec3(0.0,t*2.0,0.0),1.0,3.57,1.83)*2.0;\n    float disp = (sin(pos.z*1.3+t*1.1+pos.x*0.4)+cos(n3+t*1.3+pos.z*1.5+sin(t*2.2+pos.x*1.25)))*0.1;\n\n    float d2 = dot(pos,vec3(.0,1.0,.0)) + 2.*  disp;\n    d2 = smin(n1,d2,.5);\n    return clamp(d2,0.,1.);\n}\n\n\nvoid update(float dt) {\n\n \tfloat t  = dt;\n    float tx = mod( t ,4. * 2.6);\n    float ty = mod(t,1.);\n    obj_geo og = ob_s.geo;\n    vec3 pos = og.c;\n    float px = abs( tx - 2.*2.6)-2.6;\n    float pz = cos( .1*t);\n    pos.xz  = vec2(px,pz);\n    pos.y = .1+ 5.0*ty - 0.5*9.8*ty*ty;\n    pos  *= exp(-.05*t);\n    if (t > 15.) pos.y = .5*eau(pos,.5*t);\n    pos.y = max(og.sz.x+.2,abs(pos.y));\n    ob_s.geo.c = pos;\n\n}\n\n","name":"Common","description":"","type":"common"}]}