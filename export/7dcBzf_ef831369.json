{"ver":"0.1","info":{"id":"7dcBzf","date":"1656914885","viewed":83,"name":"checkerboard cubes","username":"a2aaron","description":"Remixed from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\nmy first shader :DDD","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"llt3R4","parentname":"Ray Marching: Part 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Part 1 Challenges\n * - Make the circle yellow\n * - Make the circle smaller by decreasing its radius\n * - Make the circle smaller by moving the camera back\n * - Make the size of the circle oscillate using the sin() function and the iTime\n *   uniform provided by shadertoy\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926;\n\n\nconst vec3 UNIT_X = vec3(1.0, 0.0, 0.0);\nconst vec3 UNIT_Y = vec3(0.0, 1.0, 0.0);\nconst vec3 UNIT_Z = vec3(0.0, 0.0, 1.0);\n\nfloat opOr( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opAnd( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(d1, -d2); }\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint, float radius) {\n    return length(samplePoint) - radius;\n}\n\nfloat cubeSDF(vec3 samplePoint, float radius) {\n    vec3 p = abs(samplePoint);\n    return max(max(p.x, p.y), p.z) - radius;\n}\n\nfloat pSin(float x) { return (sin(x) + 1.0) / 2.0; }\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float cube = cubeSDF(samplePoint, 1.0);\n    float sphere = sphereSDF(samplePoint, mix(1.1, 1.5, pSin(iTime)));\n    float sphere2 = sphereSDF(samplePoint - mix(-2.0 * UNIT_Y, 2.0 * UNIT_Y, pSin(iTime * 1.3)), mix(0.5, 0.7, pSin(iTime / 1.3)));\n    \n    return opOr(opSub(cube, sphere), sphere2);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 rayDirection2(vec3 look, vec3 up, float fov, vec2 size, vec2 fragCoord) {\n    vec3 image_right = normalize(cross(look, up));\n    vec3 image_up = normalize(cross(image_right, look));\n    \n    vec3 p = rayDirection(fov, size, fragCoord);\n    \n    mat3x3 camera = mat3x3(image_right, image_up, -normalize(look));\n    vec3 ray_direction = camera * p;\n    return normalize(ray_direction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mouse = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    float x = cos(iTime / 1.5);\n    float z = sin(iTime / 1.2);\n    float y = cos(iTime / 2.0) * 2.0;\n\n    vec3 eye = normalize(vec3(x, y, z)) * 13.0;\n    vec3 look = -eye;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 dir = rayDirection2(look, up, 45.0, iResolution.xy, fragCoord);\n\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 pos = eye + dir * dist;\n    pos = tan(pos * mouse.x * 10.0 * PI);\n    vec3 color = vec3(pos.x * pos.y, pos.y * pos.z, pos.z * pos.x);\n    vec3 color2 = smoothstep(vec3(0.0), vec3(0.1), color);\n    fragColor = vec4(color2, 1.0);\n}","name":"Image","description":"","type":"image"}]}