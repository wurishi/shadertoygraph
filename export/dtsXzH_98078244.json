{"ver":"0.1","info":{"id":"dtsXzH","date":"1674328503","viewed":152,"name":"rounded rect sharp border","username":"holoy","description":"Rounded rectangle with pixel perfect sharp border, meant for building UIs, with explanations/tutorial.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["border"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Are CSS' RGB color codes in sRGB ?? It's way too bright with gamma correction!\n//\n// case solved: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\n//   \"\"Using the RGB cubic-coordinate system (via the #-hexadecimal or the rgb() \n//     functional notation). These always specify a color in the sRGB color space.\"\"\n\n// thanks to @iq!\nvec3 decodeSRGB( vec3 s )\n{\n    return vec3( \n     s.r<0.0522614 ? s.r/12.92 : pow((s.r+0.055)/1.055,2.4),\n     s.g<0.0522614 ? s.g/12.92 : pow((s.g+0.055)/1.055,2.4),\n     s.b<0.0522614 ? s.b/12.92 : pow((s.b+0.055)/1.055,2.4)\n     );\n}\n//#define RGB(r,g,b) vec4(r/255.0, g/255.0, b/255.0, 1.); // Original that caused the problem.\n#define sRGB(r,g,b) vec4(decodeSRGB(vec3(r/255.0, g/255.0, b/255.0)), 1.);\n\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( in vec2 p, in vec2 halfDim, in vec4 r_corners )\n{\n    r_corners.xy = (p.x>0.0)?r_corners.xy : r_corners.zw;\n    r_corners.x  = (p.y>0.0)?r_corners.x  : r_corners.y;\n    vec2 q = abs(p)-halfDim+r_corners.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r_corners.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Time function flattened at the tops, gives time to see it fill the screen.\n    // link: https://math.stackexchange.com/questions/100655/cosine-esque-function-with-flat-peaks-and-valleys\n    vec2  timeOffset  = iResolution.yx*(0.05+0.05*sin(1.57*cos(iTime*0.8)));\n    \n    // Emulate an OpenGl desktop app feeding rectangles at integer pixel coords/size.\n    #define SNAP2(xy) (round(xy))\n    #define SNAP1(x)  (round(x))\n    /* shader inputs */\n    vec2  cornerPos   = SNAP2(timeOffset);\n    vec2  dimensions  = SNAP2(iResolution.xy - 2.*timeOffset);\n    float borderWidth = SNAP1(iResolution.y*(0.05+0.05*cos(iTime*1.1)));\n    float radius      = 0.2*iResolution.y*pow(cos(iTime*1.4), 2.);\n    \n    // palette: https://lospec.com/palette-list/apollo decoded to linear RGB\n    vec4 borderColor = sRGB(37., 58., 94.)\n    vec4 color       = sRGB(79., 143., 186.)\n    \n    /* computed */\n    vec2  pos    = fragCoord;\n    vec2  center = cornerPos + dimensions/2.;\n\n    /*\n       h───┬───┐  Legend:\n       │   │   │    o cornerPosition; w,h dimensions; c center\n       │ x-│-x │    x fragCoord pixel center\n       │ | │ | │    ─ Sdf contour\n       ├───c───┤    - Sdf contour +0.5\n       │ | │ | │    \n       │ x-│-█▓▒░x <= sharp 1px smoothstep area, 1 inside and 0 outside\n       │   │   │\n       o───┴───w\n       sdf_outer is shrunk by 0.5 to align the sdf contour to the fragment centers,\n       Because the sdf was defined from the rectangle size (in pixels) and the\n       geometric center of the shape, yet we are sampling the sdf at `fragCoord`.\n       This gives us sharp edges with a smoothing zone of 1px(pad) projected outside\n       the shape for smooth corners. \n    */\n\n    float sdf_outer = +0.5 + sdRoundedBox(pos-center, dimensions/2., vec4(1.0)*radius);\n    float sdf_inner = sdf_outer + borderWidth;\n    \n    /* pad is the variation of SDF across 1px,\n       since we are using 2D integer pixel coords it is 1.,\n       but we could have used the gradient `pad=fwidth(sdf)`\n         or better yet `pad=length(vec2(dFdx(sdf),dFdy(sdf)))`, src: https://www.shadertoy.com/view/wsjfRd\n    */\n    float pad = 1.;  \n    float is_outer = 1.0 - smoothstep(0.0, pad, sdf_outer); // smoothing area projected 1px outisde the shape,\n    float is_inner = 1.0 - smoothstep(0.0, pad, sdf_inner); // \\ because negative sdf means inside shape, sdf=0 is the contour, positive sdf means outside the shape. \n    \n    /*\n       NOTE: We could have defined `sdf_outer` without the `+0.5`, then computed\n       `1.0 - smoothstep(-0.5, 0.5, sdf_outer);`, this would achieve the same effect\n       of shifting the 1px smoothing area from the contour sdf=0 over to `fragCoord`.\n                      \n    (in shape) -2  -1 SDF0  1 (outside shape)\n                        |\n                ┼───┼───|───┼\n        from:   │ x │ x █▓▒░_  // blurry edge █▒ , smoothstep( 0.,1.,SDF) => the third x is blurry. \n                │   │ ^ | ^ │                 ^^\n                ┼───┼───|───┼\n          to:   │ x │ █▓▒░_ │  // sharp edge  █_ , smoothstep(-.5,.5,SDF) becomes 1 on the second 'x' and 0 on the third. \n                │   │ ^ | ^ │                 ^^\n    */\n    \n    \n    vec4 bg = vec4(1., 1., 1., 0.);\n    fragColor = mix(bg, mix(borderColor, color, is_inner), is_outer);\n    \n    \n    // gamma correction\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}\n\n","name":"Image","description":"","type":"image"}]}