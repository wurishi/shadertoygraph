{"ver":"0.1","info":{"id":"l3XSD2","date":"1710003102","viewed":149,"name":"Triquadratic SDF Caverns","username":"spalmer","description":"pre-bake SDF to buffer with multi-16-bit channels distributed along the height axis, effectively volume texture with height 8.\nuses triquadratic smooth interpolation.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["volume","texture","voxel","distance","triquadratic","smoothsdf"],"hasliked":0,"parentid":"WtdSzs","parentname":"Multi Level SDF"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of \"Multi Level SDF\"  http://www.shadertoy.com/view/WtdSzs\n// which forks \"Pyramid City\"  http://shadertoy.com/view/WtcXzs\n// the triquadratic derives from  http://shadertoy.com/view/WdBcDG\n// which was originally inspired by http://shadertoy.com/view/wtXXDl\n\n// the idea is to cache complex SDF to a buffer\n// then use smooth filter sampling to reconstruct\n\n// if you ever tried this with trilinear, \n// or with hardware sampling, you'd know this usually\n// turns out exhibiting nasty grid artifacts.\n\n// Image actually draws the scene\n\n#define BufferA iChannel0\n#define BufASize iChannelResolution[0].xy\n#define BufferC iChannel2\n// blue noise is best\n#define DitherNoise iChannel3\n\nconst vec3 L = normalize(vec3(0, .4, 1));\n    \nvec3 skyColor(vec3 d)\n{\n    return vec3(.9,.6,.3) * .1\n    // sun doesn't work for this \"underground\" scene\n        //+ vec3(.5,.3,.1) * 20. * pow(max(0., dot(d, L)), 64.)\n        ;\n}\n\nfloat VT(ivec3 q)\n{\n//    return texelFetch(BufferA, q.xz, 0)[q.y]; // uncompressed (NLAYERS=4)\n    return NORMRANGE * unpackSnorm2x16(floatBitsToUint(texelFetch(BufferA, q.xz, 0)[q.y>>1]))[q.y&1]; // decompress 2xunorm16 packed (NLAYERS=8)\n}\n\nfloat vtriquadraticLooped(vec3 q)\n{\n\tivec3 r = ivec3(BufASize, 1);\n\tvec3 p = floor(q),\n        f = q - p;\n\tivec3 j = ivec3(p);\n\tfloat d;\n    // since this loop typically gets inlined, the switch and all should get optimized\n\tfor (int c = 0; c < 27; ++c) {\n\t\tivec3 k = ivec3(c % 3, (c / 3) % 3, c / 9) - 1;\n\t\tfloat m = .125;\n        switch (k.x) {\n            case -1: m *=    (1.-f.x)*(1.-f.x);      break;\n            case  0: m *= 2.*(1.-f.x)*(   f.x) + 1.; break;\n            case  1: m *=    (   f.x)*(   f.x);      break;\n        }\n        switch (k.y) {\n            case -1: m *=    (1.-f.y)*(1.-f.y);      break;\n            case  0: m *= 2.*(1.-f.y)*(   f.y) + 1.; break;\n            case  1: m *=    (   f.y)*(   f.y);      break;\n        }\n\t\tswitch (k.z) {\n            case -1: m *=    (1.-f.z)*(1.-f.z);      break;\n            case  0: m *= 2.*(1.-f.z)*(   f.z) + 1.; break;\n            case  1: m *=    (   f.z)*(   f.z);      break;\n        }\n\t\td += m * VT(j + k);\n\t}\n\treturn d;\n}\n// gives nice quality on round SDFs. \n// many taps is what modern gpus are made for.\n\n// choose filter/fetch method\nfloat SDFbuf(vec3 p)\n{\n  #if 0\n    // HACK use original SDF for sanity check\n\treturn SDF(p); // from Common\n    // could even re-add the noise and re-clip the flightpath\n  #endif\n    p.y *= yscale;\n\tvec3 q = p;\n    // not wrapping this buffer lookup\n    //q += vec3(BufASize, 0).xzy; // damn mod of negatives!\n    //q = mod(q, vec3(BufASize, 2560).xzy); //mod(q, vec3(BufASize, 1e6).xzy); //\n    q = clamp(q, vec3(0), vec3(BufASize - 1.0001, float(NLAYERS) - 1.01).xzy);\n    float d = vtriquadraticLooped(q);\n  #if 1\n    float gridlines = clamp(\n      fract(q.x) * fract(1. - q.x) *\n       fract(q.y) * fract(1. - q.y)\n      * fract(q.z) * fract(1. - q.z)\n      * 64. //* 4. //\n      , 0., 1.);\n    gridlines = clamp(gridlines * 32., 0., 1.); //1. - pow(gridlines, .125);\n    //gridlines *= max(0., cos(iTime * .5) * 3. - 2.);  // blink gridlines every few seconds\n    gridlines *= step(.1, iMouse.z); // show gridlines when mouse down\n    d -= .015 * gridlines; // show gridlines for debugging\n  #endif\n    return d;    \n}\n// TODO add fine detail like voronoise or something\n// except the point of this is kind of to show off the smoothness.\n/*\nvec3 Gradient(vec3 q, float e)\n{\n\tvec2 z = vec2(0, e);\n\treturn vec3(\n\t\tSDFbuf(q + z.yxx),\n\t\tSDFbuf(q + z.xyx),\n\t\tSDFbuf(q + z.xxy)\n\t) - SDFbuf(q);\n}\n*/\n// http://shadertoy.com/view/NscXR4\nvec3 Gradient(vec3 q, float h)\n{\n\tvec3 n, e;\n\tfor (float i = min(0., iTime) + 4.; i-- > 0.; ) {\n\t\te = mod(floor(.5 * (i + vec3(3, 0, i))), 2.) * 2. - 1.;\n\t\tn += SDFbuf(h * e + q) * e;\n\t}\n\treturn n;\n}\n\nconst float tmax = 128.;\n\nfloat RayMarch(vec3 ro, vec3 rd, int niter) \n{\n\tfloat l = 0.;\n    for (int j = niter; j-- > 0; ) {\n\t\tfloat d = SDFbuf(l * rd + ro);\n\t\tl += d;\n        if (l >= tmax) {\n            l = tmax; break; \n        }\n        if (d < .001 * l)\n            break;\n\t}\n\treturn l;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, vec3 cf, float time, out float d)\n{\n    d = RayMarch(ro, rd, 384 + IZERO);\n    if (d <= 0.) return vec3(1,0,0);\n    vec3 n = normalize(Gradient(d * rd + ro, .0004 * d));\n    if (d >= tmax) n = -L;\n    // spotlight\n    float spot = pow(max(0., dot(rd, cf)), 16.) / (1. + .04 * d * d);\n    vec3 csky = skyColor(rd);\n    //float ambient = .003;\n    vec3 c;\n    //c = vec3(mix(dot(n, L), 1., ambient));\n    c += 1.1 * pow(max(0., -dot(n, rd)), 1.) * spot;\n    // specular should exhibit artifacts diffuse won't\n    vec3 h = normalize(-rd + L);\n    float sp = 32.;\n    c += .4 * 8. / pi * (sp + 2.) * pow(max(0., dot(n, h)), sp) * spot * spot; //;//sqrt(spot*spot*spot); //\n    float dfade = exp2(-.01 * d);\n    c = mix(csky, c, dfade); // fog\n\treturn c;\n}\n\nvoid ViewRay(vec2 p, vec2 r, out vec3 ro, out vec3 rd, out vec3 vd, out vec3 cf)\n{\n    vec2 q = StoQ(p, r);\n    vec3 eye_pos = flightPath(iTime), //vec3(0), //\n        eye_future = flightPath(iTime+.1), //vec3(0,0,1), //\n        look_dir = normalize(eye_future - eye_pos);\n    mat3 M = cameraMatrix(look_dir);\n    cf = look_dir;\n    const float hfovy = pi / 7.;\n    vd = normalize(vec3(q, 1. / tan(hfovy)));\n    ro = eye_pos, rd = normalize(M * vd);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec3 ro, rd, vd, cf;\n    ViewRay(p, R, ro, rd, vd, cf);\n    float d;\n    vec3 c = RenderScene(ro, rd, cf, iTime, d);\n    //c = vec3(1. - exp2(-.08 * d)); // debug depth fog\n    //c = texelFetch(BufferA, ivec2(p), 0).rgb * .02 + .5; // debug BufferA\n    c = 1.0 * c / (c + .1); // tonemap \n    o = vec4(pow(c, vec3(.4545)), 1); // OETF to sRGBish gamut\n    o.rgb += exp2(-8.) * (texelFetch(DitherNoise, ivec2(p) % textureSize(DitherNoise, 0), 0).r - .5); // dither\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define IZERO min(0, iFrame)\n\nconst float pi = acos(-1.); //3.141592;\n\n// PARENT toy simply used a 16:9 buffer\n// to store a 4-layer tall volume,\n// one plane per channel.\n\n// this toy splits BufA float channels up into\n// packed 16-bit snorms instead to obtain\n// 8 total layers, at expense of SDF precision.\n \nconst int NLAYERS = 8; //4; //\nconst float yscale = .325 * float(NLAYERS) / 4.;\nconst float NORMRANGE = 4.;\n\n// TODO try divide 16:9 buffer in half horizontally\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\n// cheap rotation transform on p by s=(cos(a),sin(a))\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n} // then can rot(q.xz, vec2(cos(a),sin(a)))\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd),\n         u = normalize(cross(vec3(0, 1, 0), w)),\n         v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\n// just use a torus and circular flightpath for simplicity\n\nconst vec3 fpmid = vec3(155, 4.75, 115); //vec3(0, 1, 8); //\nconst float fprad = 80., fpwid = 2.25;\n\nfloat dFlightPath(vec3 p)\n{\n    p -= fpmid;\n    p /= fprad;\n    return length(abs(vec2(length(p.xz) - 1., p.y))) * fprad - fpwid;\n    //return 9e9;\n}\n\nvec3 flightPath(float time)\n{\n    float t = .02 * time;\n    return fprad * vec3(sin(t), 0, cos(t)) + fpmid;\n    //return vec3(100.*sin(t) + 110., 11., 80.*cos(t) + 85.);\n}\n\nfloat SDF(vec3 p)\n{\n    //return p.y + .2; //length(p - vec3(3,1,15)) - 5.; //\n    float dt = dFlightPath(p); // + vec3(0,fpwid + 2.04,0));\n    const float scale = 32.;\n    p.xz /= scale * .5 / pi;\n    float df = p.y + 0.5 - .55 * (sin(p.x) * sin(p.z) * .5 + .5) * scale * yscale,\n        dc = (sin(1.7*p.x) * sin(1.8*p.z) * .5 + .5) * scale * yscale * .5 - p.y + 5.5;\n    df *= .75; // HACK because the sinewaves weren't perfect SDFs to begin with\n    dc *= .75;\n    //return min(df, dc);\n    return max(min(df, dc), -dt); // no access to noise in Common, must clip out flightpath again in Buffer A anyway\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// how much vertical detail can we get out of one buffer?\n\n// see NLAYERS in Common\n\n#define BufferA iChannel0\n        \n\n\nfloat SDFLevel(vec2 p, float y)\n{\n    y += .5; // center sample in voxel vertically; p already had .5 from fragCoord\n    vec3 q = vec3(p.x, y / yscale, p.y);\n    //return SDF(q); // simpler, no noise\n    //return max(SDF(q),\n    //    -dFlightPath(q)); // clip flightpath\n    return max(\n        SDF(q) \n        + texture(iChannel3, .7 * q / vec3(textureSize(iChannel3, 0))).x * 1. - .5,\n        -dFlightPath(q));\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    // fill double buffer at start and periodically (in case res changes etc.)\n    // FIXME res pixel would be better, this might hitch periodically.\n    // at least it doesn't do the work every frame!\n    // TODO can build zone around the current camera location\n    if ((iFrame & 511) >= 2) {\n        c = texelFetch(BufferA, ivec2(p), 0);\n        return;\n    }\n    vec4 d;\n    //for (int i = 0; i < NLAYERS; ++i)\n    //    d[i] = SDFLevel(p,float(i));\n    for (int i = 0; i < NLAYERS / 2; ++i)\n        d[i] = uintBitsToFloat(packSnorm2x16(\n            1. / NORMRANGE * vec2(SDFLevel(p, float(i * 2)), SDFLevel(p, float(i * 2 + 1)))));\n    c = d;\n}\n\n// TODO dropoff near border so wrapping doesn't chop objects\n","name":"Buffer A","description":"","type":"buffer"}]}