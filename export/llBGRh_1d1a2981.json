{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*TEXTURE_FORMAT:OutputFormat(1280, 720, GL_RGB, GL_UNSIGNED_BYTE, GL_NEAREST, GL_NEAREST)\n\nCALL:FORMAT_TO_CONSTANT(OutputFormat, OutputFormatSize)\n\nSHADER_SOURCE:HackathonShader\n{*/\n\t//#version 130\n\t//#define SINGLE_UNIT\t// Single unit, for tests purpose.\n\t//#define MULTI_SIMPLE\t// Showing the repitition bug, comment to see the solved version.\n\t#define FAST_METHOD\t\t// If this is commented, the method used is exact. Uncomment for speed.\n\t//#define NO_EFFECTS\t// Remove the image effects.\n\t#define INFINITE\t\t// Infinite animation.\n\n\t//INSERT(OutputFormatSize)\n\n\t/*uniform vec3\teyePos\t\t= vec3(0, 0, 4),\n\t\t\t\t\teyeTarget\t= vec3(0, 0, 0),\n\t\t\t\t\tlightDir\t= vec3(1, 0, 0);\n\tuniform\tfloat\tfocalLength\t= 0.5,\n\t\t\t\t\tlightFlux\t= 1.0;*/\n\tvec3\t\teyePos\t\t= vec3(4.0, 3.0, 4.0),\n        \t\teyeTarget\t= vec3(0.0, 0.0, 0.0);\n\tconst vec3\tlightDir\t= vec3(1.0, 0.0, 0.2);\n\tconst float\tfocalLength\t= 0.5,\n\t\t\t\tlightFlux\t= 4.0,\n                volumeSide \t= 10.0,\n        \t\tduration\t= 30.0;\n\n\tfloat blockHash(vec3 p)\n\t{\n\t\t//return sin(123.0*p.x)*sin(456.0*p.y)*sin(789.0*p.z)*241432439.0;\n        return sin(123.0*p.x)*sin(456.0*p.y)*sin(789.0*p.z)*2769.32;\n\t}\n\n\tfloat smin(float a, float b)\n\t{\n\t\tconst float k = 0.1;\n\t\tfloat h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\t\treturn mix(b, a, h) - k*h*(1.0-h);\n\t}\n\n\tfloat absSq(float x)\n    {\n        return x*x;\n    }\n\n\tfloat getUnitDistance(float idx, vec3 p)\n\t{\n\t\tvec3 \tbumps1 \t\t= sin(idx*vec3(2.542, 1.564, 3.342))+1.0,\n\t\t\t\tbumps2\t\t= sin(idx*vec3(-1.432, 8.788, 9.453))+1.0,\n\t\t\t\ttranslation\t= sin(idx*vec3(0.345, 8.342, 3.324))/1.5;\n        bumps1 = max(abs(bumps1), vec3(1.0))*sign(bumps1); // avoid 0.0, avoid the spheres...\n        bumps2 = max(abs(bumps2), vec3(1.0))*sign(bumps2);\n\t\t\n\t\tp += sin(idx*vec3(0.234, 0.736, 0.213))*3.0;\n        \n\t\tfloat\ts1 \t= length(p) + sin(bumps1.x*p.x)*sin(bumps1.y*p.y)*sin(bumps1.z*p.z)/1.5 + sin(bumps1.x*p.x*4.0)*sin(bumps1.y*p.y*4.0)*sin(bumps1.z*p.z*4.0)/16.0 - 1.0,\n\t\t\t\ts2\t= distance(p, translation) + sin(bumps2.x*p.x)*sin(bumps2.y*p.y)*sin(bumps2.z*p.z)/1.5  + sin(bumps2.x*p.x*4.0)*sin(bumps2.y*p.y*4.0)*sin(bumps2.z*p.z*4.0)/16.0 - 1.0;\n\t\treturn  smin(s1, s2);\n    }\n\n\t/*float getUnitDistance(vec3 block, vec3 p)\n\t{\n\t\tvec3 \tbumps1 \t\t= fract(block*vec3(0.2342, 0.4564, 0.3342))*2.0,\n\t\t\t\tbumps2\t\t= fract(block*vec3(-0.7432, 0.8788, 0.9453))*2.0,\n\t\t\t\ttranslation\t= (fract(block*vec3(0.3450, 0.8342, -0.8324))*2.0-1.0)/1.5;\n        bumps1 = max(abs(bumps1), vec3(1.0))*sign(bumps1);\n        bumps2 = max(abs(bumps2), vec3(1.0))*sign(bumps2);\n\t\n\t\tp = p + (fract(block*vec3(0.2334, 0.5365, 0.4353))*2.0-1.0)*4.0;\n\n\t\tfloat\ts1 \t= length(p) + sin(bumps1.x*p.x)*sin(bumps1.y*p.y)*sin(bumps1.z*p.z)/1.5 + sin(bumps1.x*p.x*4.0)*sin(bumps1.y*p.y*4.0)*sin(bumps1.z*p.z*4.0)/16.0 - 1.0,\n\t\t\t\ts2\t= distance(p, translation) + sin(bumps2.x*p.x)*sin(bumps2.y*p.y)*sin(bumps2.z*p.z)/1.5  + sin(bumps2.x*p.x*4.0)*sin(bumps2.y*p.y*4.0)*sin(bumps2.z*p.z*4.0)/16.0 - 1.0;\n        \n\t\treturn  smin(s1, s2);\n    }*/\n\n\tfloat getUnitDistanceSimple(vec3 p)\n    {\n        return length(p)-4.8; // The coefficient is a bit ad-hoc here. The goal is to quickly catch a \"leaking ray\".\n    }\n\n\tvec2 sceneMap(vec3 p, vec3 dir)\n\t{\n\t\t#ifdef SINGLE_UNIT\n        \tconst float bidx = 43578.4534;\n\t\t\treturn vec2(getUnitDistance(bidx, p), 1.0+abs(bidx));\n\t\t#else \n        #ifdef MULTI_SIMPLE\n        \tvec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0;\n        \tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;\n\t\t\tfloat\tbidx0 = blockHash(v);\n       \t\t\n        \treturn vec2(getUnitDistance(bidx0, m0), 1.0+abs(bidx0));\n        \n        \t/*vec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0;\n        \tvec3\tblock = floor(p/volumeSide) + vec3(24.32, 32.4324, 63.6548);\n        \treturn vec2(getUnitDistance(block, m0), 1.0);*/\n        #else\n        #ifdef FAST_METHOD\n        \tvec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,\n                \tm1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,\n\t\t\t\t\tm2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,\n\t\t\t\t\tm4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,\n\t\t\t\t\tm6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,\t\t\t\n\t\t\t\t\tm7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;\t\n        \tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;\n            float\tbidx0 = blockHash(v);\n        \tfloat \td = min(getUnitDistance(bidx0, m0),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m1),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m2),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m3),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m4),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m5),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m6),\n\t\t\t\t\t\t\tgetUnitDistanceSimple(m7) )))))));\n        \treturn vec2(d, 1.0+abs(bidx0));\n        #else\n\t\t\tvec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,\n\t\t\t\t\tm1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,\n\t\t\t\t\tm2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,\n\t\t\t\t\tm4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,\n\t\t\t\t\tm6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,\t\t\t\n\t\t\t\t\tm7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;\t\n\t\t\tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;\n\t\t\tfloat\tbidx0 = blockHash(v),\n\t\t\t\t\tbidx1 = blockHash(v + vec3(sign(dir.x), 0.0, 0.0)),\n\t\t\t\t\tbidx2 = blockHash(v + vec3(0.0, sign(dir.y), 0.0)),\n\t\t\t\t\tbidx3 = blockHash(v + vec3(0.0, 0.0, sign(dir.z))),\n\t\t\t\t\tbidx4 = blockHash(v + vec3(sign(dir.x), sign(dir.y), 0.0)),\n\t\t\t\t\tbidx5 = blockHash(v + vec3(0.0, sign(dir.y), sign(dir.z))),\n\t\t\t\t\tbidx6 = blockHash(v + vec3(sign(dir.x), 0.0, sign(dir.z))),\t\t\t\n\t\t\t\t\tbidx7 = blockHash(v + vec3(sign(dir.x), sign(dir.y), sign(dir.z)));\t\t\n\t\t\tfloat \td = min(getUnitDistance(bidx0, m0),\n\t\t\t\t\t\tmin(getUnitDistance(bidx1, m1),\n\t\t\t\t\t\tmin(getUnitDistance(bidx2, m2),\n\t\t\t\t\t\tmin(getUnitDistance(bidx3, m3),\n\t\t\t\t\t\tmin(getUnitDistance(bidx4, m4),\n\t\t\t\t\t\tmin(getUnitDistance(bidx5, m5),\n\t\t\t\t\t\tmin(getUnitDistance(bidx6, m6),\n\t\t\t\t\t\t\tgetUnitDistance(bidx7, m7) )))))));\n        \t/*vec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,\n\t\t\t\t\tm1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,\n\t\t\t\t\tm2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,\n\t\t\t\t\tm4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,\n\t\t\t\t\tm6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,\t\t\t\n\t\t\t\t\tm7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;\t\n\t\t\tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0,\n        \t\t\tblock1 = v + vec3(sign(dir.x), 0.0, 0.0),\n\t\t\t\t\tblock2 = v + vec3(0.0, sign(dir.y), 0.0),\n\t\t\t\t\tblock3 = v + vec3(0.0, 0.0, sign(dir.z)),\n\t\t\t\t\tblock4 = v + vec3(sign(dir.x), sign(dir.y), 0.0),\n\t\t\t\t\tblock5 = v + vec3(0.0, sign(dir.y), sign(dir.z)),\n\t\t\t\t\tblock6 = v + vec3(sign(dir.x), 0.0, sign(dir.z)),\t\t\t\n\t\t\t\t\tblock7 = v + vec3(sign(dir.x), sign(dir.y), sign(dir.z));\n        \tfloat \td = min(getUnitDistance(v, m0),\n\t\t\t\t\t\tmin(getUnitDistance(block1, m1),\n\t\t\t\t\t\tmin(getUnitDistance(block2, m2),\n\t\t\t\t\t\tmin(getUnitDistance(block3, m3),\n\t\t\t\t\t\tmin(getUnitDistance(block4, m4),\n\t\t\t\t\t\tmin(getUnitDistance(block5, m5),\n\t\t\t\t\t\tmin(getUnitDistance(block6, m6),\n\t\t\t\t\t\t\tgetUnitDistance(block7, m7) )))))));*/\n\t\t\treturn vec2(d, 1.0+abs(bidx0));\n        #endif\n\t\t#endif\n        #endif\n\t}\n\n\tvec4 renderMaterial(vec2 fragCoord, vec3 p, vec3 n, float m)\n\t{\n        float d = distance(eyePos, p);\n\t\tvec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n\n\t\tif(m>=1.0)\n\t\t\tc.rgb = vec3(1.0, 1.0, 1.0) * (0.03 + max(dot(normalize(lightDir), n), 0.0) * max(dot(normalize(eyePos-p), n), 0.0) * lightFlux);\n        \n        #ifndef NO_EFFECTS\n        if(floor(mod(m,10.0))==0.0 && d<50.0)\n\t\t\tc.rg += vec2(1.0, 0.25)*max(0.9 + sin(fragCoord.y/iResolution.y*100.0-iTime*10.0)/2.0, 0.0);\n        #endif\n            \n        const float cFloor = 0.01,\n            \t\ttau = 20.0;\n        \n        c.rgb = c.rgb*exp(-d/tau)*(1.0-cFloor)+cFloor*(1.0-exp(-d/tau));\n        \n\t\treturn c;\n\t}\n\n\t// Core of the Ray-marcher :\n\tmat3 computeCameraMatrix(in vec3 p, in vec3 target, float roll)\n\t{\n\t\tvec3 \tvForward = normalize(target-p),\n\t\t\t\tvUpAlign = vec3(sin(roll), cos(roll), 0.0),\n\t\t\t\tvLeftReal = normalize(cross(vForward, vUpAlign)),\n\t\t\t\tvUpReal = normalize(cross(vLeftReal, vForward));\n\t   \treturn mat3(vLeftReal, vUpReal, vForward);\n\t}\n\n\tvec3 castRay(in vec3 rayOrigin, in vec3 rayDirection)\n\t{\n\t\tconst int \tnumSteps = 128;\n\t\tconst float\tdMin = 0.0,\n\t\t\t\t\tdNear = 0.000001,\n\t\t\t\t\tdMax = 100.0;\n\t\tfloat\t\td = dMin,\n\t\t\t\t\tdLast = dMin,\n\t\t\tm = -1.0;\n\t\tfor(int i=0; i<numSteps; i++)\n\t\t{\n\t\t\tvec3 p = rayOrigin+rayDirection*d;\n\t\t\tvec2 res = sceneMap(p, rayDirection);\n\n\t\t\tdLast = res.x;\n\t\t\td += res.x;\n\t\t\tm = res.y;\n\n\t\t\tif(res.x<dNear || d>dMax)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(d>dMax)\n\t\t\tm = -1.0;\n\n\t\treturn vec3(d, m, dLast);\n\t}\n\n\tvec3 calcNormal(in vec3 pos, in vec3 dir)\n\t{\n\t\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n\t\tvec3 n = vec3(\tsceneMap(pos+eps.xyy, dir).x - sceneMap(pos-eps.xyy, dir).x,\n\t\t\t\t\t\tsceneMap(pos+eps.yxy, dir).x - sceneMap(pos-eps.yxy, dir).x,\n\t\t\t\t\t\tsceneMap(pos+eps.yyx, dir).x - sceneMap(pos-eps.yyx, dir).x );\n\t\treturn normalize(n);\n\t}\n\n\tvec4 renderScene(vec2 fragCoord, const ivec2 formatSize, const vec3 eyePos, const vec3 eyeTarget, const float focalLength)\n\t{\n\t\tmat3 camera = computeCameraMatrix(eyePos, eyeTarget, 0.0);\n\t\tvec2 o = (fragCoord - vec2(formatSize)/2.0)/max(float(formatSize.x),float(formatSize.y));\n\t\tvec3 rayOrigin = vec3(o, 0.0) + eyePos,\n\t\t     rayDirection = normalize(camera*vec3(o, focalLength));\n\t\tvec3 res = castRay(rayOrigin, rayDirection);\n\t\tvec3 p = rayOrigin + rayDirection * res.x;\n\t\tvec3 n = calcNormal(p, rayDirection);\n\t\treturn renderMaterial(fragCoord, p, n, res.y);\n\t}\n\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n\t{\n        eyePos = eyePos + vec3(sin(iTime/10.0)/2.0, sin(iTime/10.0)/2.0, iTime*1.4);\n        eyeTarget = eyePos + vec3(sin(iTime/2.0)/10.0, 0.0, 1);\n        \n        #ifndef NO_EFFECTS\n        \tvec2 fragCoordMod = fragCoord + sin(iTime/2.0+fragCoord.y/5.0)*100.0*exp(-absSq(fragCoord.y/iResolution.y-sin(iTime)-0.5)*800.0);\n        #else\n        \tvec2 fragCoordMod = fragCoord;\n        #endif\n        \n\t\t// Render the scene :\n        vec4 c = renderScene(fragCoordMod, ivec2(iResolution.xy), eyePos, eyeTarget, focalLength);\n        \n        // Effects :\n        #ifndef NO_EFFECTS\n        \tc.rgb *= max(cos(3.14*length(fragCoord.xy/iResolution.xy - vec2(0.5,0.5))*0.85), 0.0);\n    \t\tc.rgb *= (iTime<=0.0) ? 1.0 : (1.0-exp(-iTime/4.0));\n        \tc.rgb *= (floor(mod(fragCoord.y,4.0))<=1.0) ? 1.5 : 1.0;\n        \n        \t#ifndef INFINITE\n        \tif(iTime>duration)\n            {\n                float \ty = abs(fragCoord.y/iResolution.y - 0.5),\n               \t\t\tylim = exp(-(iTime-duration)*10.0);\n           \t\tc.rgb *= float(y<ylim) + 100.0*exp(-absSq(y-ylim)*(10000.0*iTime));\n                c.rgb *= float(iTime<duration + 0.5);\n            }\n        \t#endif\n    \t\n       \t \t// hud 1 :\n       \t\tvec2 v = fragCoord/max(iResolution.x,iResolution.y);\n        \tc.r += 0.4*smoothstep(0.012, 0.010, distance(v,vec2(0.95, 0.53)))*float(mod(iTime,2.0)<=1.0);\n        \n        \t// hud 2 :\n        \t/*float p1 = max(abs(v.x-0.5), abs(v.y-0.05)*3.0);\n        \tc.r += 0.4*float(p1<0.05 && p1>0.04)*float(mod(iTime,0.5)<=0.25);\n        \tfloat p2 = max(abs(v.x-0.555)*3.0, abs(v.y-0.05));\n        \tc.r += 0.4*float(p2<0.01)*float(mod(iTime,0.5)<=0.25);*/\n    \t#endif\n        \n        fragColor = vec4(pow(c.rgb, vec3(1.0, 1.0, 1.0)/2.2), 1.0);\n    }\n/*}\n\nFILTER_LAYOUT:HackathonFilter(OutputFormat, HackathonShader)\n\nPIPELINE_MAIN:HackathonPipeline\n{\n\tOUTPUT_PORTS(outputTexture)\n\n\tFILTER_INSTANCE:HackathonFilter\n}\n*/","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llBGRh","date":"1426796217","viewed":6254,"name":"[NV15] Lost In the Field","username":"RK","description":"Some piecewise distance field testing.\nThe goal is to create a random field of asteroids without experiencing too many glitches due to the nature of the distance function (rays could leak past a surface under some conditions).","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","randomfield","piecewisedistancefield"],"hasliked":0,"parentid":"","parentname":""}}