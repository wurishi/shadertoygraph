{"ver":"0.1","info":{"id":"DdyBWR","date":"1698089578","viewed":171,"name":"Hillocks","username":"stb","description":"Made with a low-iteration fractal.","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","parallax","particles","landscape","25d","hills","motes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// hash without sine: https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975, 397.2973, 491.1871));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x+p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// for the hill shapes\nfloat Fractal(vec2 p, vec2 off, float l, float L) {\n    // 'unroll' p horizontally (complex exp)\n    p = vec2(exp(-p.y)*cos(p.x), exp(-p.y)*sin(p.x));// + vec2(.1*sin(.2*iTime), .1*cos(.2*iTime));\n    \n    // a bit of complex sine for variation\n    p *= .831;\n    p = .05 + vec2(sin(p.x)*cosh(p.y), cos(p.x)*sinh(p.y));\n    \n    // iterate\n    for(int i=0; i<6; i++) {\n        // standard Julia\n        p = vec2(p.x*p.x-p.y*p.y, 2.*p.x*p.y) - off;\n        \n        // pinned inversion\n        p = p / dot(p, p) + vec2(-.000085, 0.);\n        p = p / dot(p, p);\n    }\n\n    return length(p) + p.x / 1.05; // + p.y * .25;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = (fc-res/2.) / res.y;\n\tfloat t = .5 * iTime;\n    \n    // shift everything down a tad\n    p.y += .1;\n    \n\t// original p\n    vec2 op = p;\n    \n    // shift camera\n    vec2 offs =\n        vec2(.33 * t, .3+.2*sin(.178*t)) // scrolling\n        + (iMouse.xy-res/2.) / res.y * float(iMouse.z>0.); // panning\n    \n    // sun pos\n    vec2 spos = vec2(.6, 0.) - p;\n    \n    // background\n    vec3 bg =\n        mix(\n            // sun\n            vec3(1.7, 1.3, 1.),\n            // fog & sky\n            mix(\n                vec3(1.),\n                vec3(.3, .5, 1.),\n                clamp(p.y+.4, 0., 1.)\n            ),\n            // sun shape and position\n            .3 + .5 * length(p-spos)\n        );\n    \n    // initial color\n    vec3 col = bg;\n    \n    // number of layers\n    const float L = 9.;\n    \n    // hill layers\n    for(float l=1.; l<L; l++) {\n        // original p\n        p = op;\n        \n        // scale layer\n        p /= pow(2., l) / 10. / L;\n    \n        // scrolling and panning\n        p += offs;\n        \n        // move horizontally at each layer\n        p.x += 1.7 * l;\n        \n        // hill shape\n        vec2 fo = vec2(1., fract(-l*.25));\n        float fr = clamp(-2.+.005*Fractal(p, fo, l, L), 0., 1.);\n        \n        // hill shading\n        //float fr2 = clamp(-2.+.005*Fractal(p+.02*spos, fo, l, L), 0., 1.);\n    \n        // mix col with bg & previous layers\n        col =\n            mix(\n                col,\n                // mix bg with hill color\n                mix(\n                    bg,\n                    // mix in ground fog \n                    mix(\n                        bg, // fog color\n                        vec3(.1, .5, .1) - .4 * fr + .1, // hill color\n                        //vec3(.1, .5, .1) - .4 * fr2 + .1, // hill color\n                        clamp((p.y+4.)/4., 0., 1.)\n                    ),\n                    (l-.5)/L\n                    //1.-exp(-(l-.5)/L)\n                ),\n                min(1., fr/.1)\n            );\n            \n        // general movement of motes\n        p += t * vec2(.5, .15);\n        \n        // scrolling and panning / 2.0 (makes them appear to exist between hill layers when mousing)\n        p += .5 * offs;\n        \n        // hash for motes\n        vec3 rnd = hash32(floor(p));\n        \n        // set mote size\n        rnd.z = mix(.02, .25, rnd.z);\n        \n        // set mote position within its cell\n        rnd.xy =\n            .5 + (.5-rnd.z) * vec2(\n                cos(.9*t+7.*rnd.x),\n                sin(.7*t+5.*rnd.y)\n            );\n        \n        // mix col with motes\n        col =\n            mix(\n                col,\n                mix(\n                    bg,\n                    // mote color and shading\n                    //vec3(.8, 1., .7) - .65 * smoothstep(0., 1., 1.-length(fract(p+.2*rnd.z)-rnd.xy)/rnd.z),\n                    vec3(1.5, 1.3, .9) - .65 * smoothstep(0., 1., 1.-length(fract(p+.33*spos*rnd.z)-rnd.xy)/rnd.z),\n                    l/L\n                ),\n                min(1., rnd.z * 4. * smoothstep(0., 1., 1.-length(fract(p)-rnd.xy)/rnd.z))\n            );\n    }\n    \n\tfo = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}