{"ver":"0.1","info":{"id":"4scSDN","date":"1459277807","viewed":307,"name":"Estimate difference beziers","username":"JohanKohler","description":"Showing the estimated vs real distance to a bezier","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["bezier","distance","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A comparison between the quadratic bezier estimate distance and\n// a more costly rootsolver one.\n//\n// https://www.shadertoy.com/view/ltXSDB\n// https://www.shadertoy.com/view/XsX3zf\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n//  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  float t=(ap+bp)/(2.0*a+b+d); // ð‘¡Ì…\n  return t;\n\n}\n\nfloat sq(float v)\n{\n    return v*v;\n}\nfloat sqlen(vec2 v)\n{\n    return dot(v,v);\n}\nfloat bezlen(vec2 a, vec2 b, vec2 c, float t)\n{\n    \n    return sqlen(b+sq(1.0-t)*(a-b)+sq(t)*(c-b));\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n\tfloat t = get_distance_vector(b0, b1, b2);\n\n    float l0 = bezlen(b0,b1,b2,t);\n        \n        \n        \n        \n//        length(mix(mix(b0,b1,t),mix(b1,b2,t),t));\n#if 0\n    for(int  i=0;i<4;i++)\n    {\n    \tvec2 f = mix(mix(b0,b1,t),mix(b1,b2,t),t);\n    \tvec2 d = 2.0*(1.0-t)*(b1-b0)+2.0*t*(b2-b1);\n        float sqlf = dot(f,f);\n    \tfloat sqld = dot(d,d);\n    \n    \tt = t - f/d;\n    }\n    float ln = length(mix(mix(b0,b1,t),mix(b1,b2,t),t));\n#endif\n\n    return l0; // ð‘£ð‘–= ð‘(ð‘¡Ì…)\n}\n\n// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq, T21, and demofox\n// \n// I needed the -signed- distance to a quadratic bezier\n// curve but couldn't find any examples online that\n// were both fast and precise. This is my solution.\n//\n// v1 - Initial release\n// v2 - Faster and more robust sign computation\n//\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n//    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec3 t = solveCubic(k.x, k.y, k.z);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, cos(iTime / 4.0)*0.5), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.3, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    \n   \tvec2 ang = vec2(cos(iTime * 1.4),sin(iTime * 1.4));\n    // Get the signed distance to bezier curve\n    float dsolve = sdBezier(A, B, C, p);\n    if(dot(ang,p)<0.0)\n        d = sdBezier(A, B, C, p);\n    else\n    {\n        d = abs(dsolve-approx_distance( p, A,B,C));\n    }\n    \n    // Visualize the distance field using iq's orange/blue scheme\n    fragColor = vec4(1.0) - sign(d)*vec4(0.1,0.4,0.7,1.0);\n    fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}","name":"Image","description":"","type":"image"}]}