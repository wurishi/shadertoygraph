{"ver":"0.1","info":{"id":"7ty3R3","date":"1638054866","viewed":166,"name":"Blob Lamp","username":"twyblade","description":"Messing around with raymarching by making a lava lamp","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","blob","lamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLOOM_STEPS 10.\n#define BLOOM_STRENGTH 0.474419\n\nvoid mainImage(out vec4 fragColor, in vec2 pos )\n{\n    pos = pos/iResolution.xy;\n    \n    vec4 col = texture(iChannel0, pos);\n    vec4 sum = vec4(0);\n    for (float x = -BLOOM_STEPS; x <= BLOOM_STEPS; ++x)\n        for (float y = -BLOOM_STEPS; y <= BLOOM_STEPS; ++y)\n            sum += texture(iChannel0, pos + vec2(x / iResolution.x, y / iResolution.y));\n    col += sum / ((BLOOM_STEPS*2.+1.) * (BLOOM_STEPS*2.+1.)) * BLOOM_STRENGTH;\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEP_SIZE 0.001\n#define MAX_STEPS 1000\n#define MAX_DIST 100.0\n\n// ------------ Shapes --------------\nfloat sdPlane(vec3 p, vec3 n) { return dot(p, n); }\n\nfloat sdCube(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2,k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot(ca,ca), dot(cb,cb)));\n}\n\n// ------------ Operations --------------\n\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\n\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec2 minM(vec2 a, vec2 b)\n{\n    float d = min(a.x, b.x);\n    if (d == a.x)\n        return vec2(d, a.y);\n    return vec2(d, b.y);\n}\n\n// ------------ Utility --------------\nvec2 adjustAspectRatio(vec2 p)\n{\n    vec2 screenSize = iResolution.xy;\n    vec2 screenPoint = (p - vec2(0.5)) * 2.0;\n    screenPoint.x *= screenSize.x / screenSize.y;\n    return screenPoint;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n\n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n    return vDir;\n}\n\nmat2 rot2D(float a)\n{\n    vec2 t = vec2(cos(a), sin(a));\n    return mat2(t.x, t.y, -t.y, t.x);\n}\n\nfloat s(float mult, float offset) { return sin(iTime *mult + offset); }\n\nfloat c(float mult, float offset) { return cos(iTime *mult + offset); }\n\nfloat ss(float mult, float offset)\n{\n    float v = sin(iTime *mult + offset);\n    v = v*.5+.5;\n    v = v*v;\n    v = v*2.0-1.0;\n    return v;\n}\n\n//---------------------------------------------------------\nvec3 colorRamp(float m) \n{;\n    if (m == 0.0) return vec3(1.0,1.0,1.0); // plane\n    if (m == 1.0) return vec3(.5,.5,.5); // Lamp\n    return vec3(1.0,1.0,1.0);\n}\n\nfloat sdfLight(vec3 p)\n{\n    float lamp = min(min(\n        sdCappedCone(p-vec3(0,1.45,0), .55, .25, .1 ),\n        sdCappedCone(p-vec3(0, .7 ,0), .2 , .15, .25)),\n        sdCappedCone(p-vec3(0, .25,0), .25, .3 , .15)\n    );\n\n    float holeCube = sdCube(p - vec3(0,1.2,0),vec3(.3,.5,.3));\n    float lampIn   = opIntersection(holeCube, lamp);\n    float lampOut  = opSubstraction(holeCube, lamp);\n\n    return min(\n        lampOut,\n        sdPlane(p - vec3(0.0, 0, 0.0), vec3(0.0, 1.0, 0.0))\n    );\n}\n\nvec2 sdf(vec3 p)\n{\n    float lamp = min(min(\n        sdCappedCone(p-vec3(0,1.45,0), .55, .25, .1 ),\n        sdCappedCone(p-vec3(0, .7 ,0), .2 , .15, .25)),\n        sdCappedCone(p-vec3(0, .25,0), .25, .3 , .15)\n    );\n\n    float holeCube = sdCube(p - vec3(0,1.2,0),vec3(.3,.5,.3));\n    float lampIn   = opIntersection(holeCube, lamp);\n    float lampOut  = opSubstraction(holeCube, lamp);\n\n    float lava = opSmoothUnion( opSmoothUnion(  opSmoothUnion( opSmoothUnion( opSmoothUnion( opSmoothUnion( opSmoothUnion(  opSmoothUnion(   opSmoothUnion( \n        sdSphere(p - vec3(.1   * c(.2 ,3.5 ),1.2 + s(.2 ,3.5 ) * .5,.05 * s(.2 ,3.5 )), .03),\n        sdSphere(p - vec3(.02  * c(.15,5.14),1.2 + s(.15,5.14) * .5,.01 * s(.15,5.14)), .07), .07),\n        sdSphere(p - vec3(.01  * c(.15,1.  ),1.2 + s(.15,1.  ) * .5,-.02* s(.15,1.  )), .07), .07),\n        sdSphere(p - vec3(.05  * c(.2 ,0.  ),1.2 + s(.2 ,0.  ) * .5,.04 * s(.2 ,0.  )), .05), .05),\n        sdSphere(p - vec3(-.03 * c(.1 ,0.  ),1.2 + s(.15,2.7 ) * .5,.05 * s(.1 ,0.  )), .02), .05),\n        sdSphere(p - vec3(-.02 * c(.1 ,3.  ),1.2 + s(.1 ,3.  ) * .5,.01 * s(.1 ,3.  )), .08), .08),\n        sdSphere(p - vec3(-.06 * c(.2 ,2.  ),1.2 + s(.2 ,2.  ) * .5,.03 * s(.2 ,2.  )), .01), .02),\n        sdSphere(p - vec3(.04  * c(.2 ,6.  ),1.2 + s(.2 ,6.  ) * .5,.04 * s(.2 ,6.  )), .01), .02),\n        sdSphere((p - vec3(0, .7 ,0)) * vec3(1,4,1), .16), .12),\n        sdSphere((p - vec3(0,1.72,0)) * vec3(1,5,1), .1 ), .15);\n\n    return minM(minM(\n        vec2(lava, 4),\n        vec2(lampOut,1)),\n        vec2(sdPlane(p - vec3(0.0, 0, 0.0), vec3(0.0, 1.0, 0.0)),0)\n    );\n}\n\nvec3 surfaceNormal(vec3 p) \n{\n    float d = sdf(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = d - vec3(\n            sdf(p - e.xyy).x, \n            sdf(p - e.yxy).x, \n            sdf(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec2 castRay(vec3 p, vec3 dir) \n{\n    float rayLength = 0.;\n    vec2 minDist = vec2(0.);\n    int i = 0;\n    float m = 0.;\n    while (i < MAX_STEPS && rayLength < MAX_DIST) \n    {\n        minDist = sdf(p + rayLength * dir);\n        if (minDist.x < STEP_SIZE) break;\n        rayLength += minDist.x;\n        ++i;\n    }\n    if (rayLength >= MAX_DIST) minDist.y = -1.;\n    return vec2(rayLength, minDist.y);\n}\n\nfloat castRayLight(vec3 p, vec3 dir) \n{\n    float rayLength = 0.;\n    float minDist = 0.;\n    int i = 0;\n    float m = 0.;\n    while (i < MAX_STEPS && rayLength < MAX_DIST) \n    {\n        minDist = sdfLight(p + rayLength * dir);\n        if (minDist < STEP_SIZE) break;\n        rayLength += minDist;\n        ++i;\n    }\n    if (rayLength >= MAX_DIST) minDist = -1.;\n    return rayLength;\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{ \n    vec3 col = vec3(1.0, 0.0, 0.0);\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n    if (m > -0.5)\n    {\n        vec3 hitPos = ro + rd * d;\n        vec3 normal = surfaceNormal(hitPos);\n        if (m < 3.0) col = colorRamp(m);\n        if (m == 4.) col = mix(vec3(.0,.8,.5), vec3(0.917, 1, 0.160), dot(normal, vec3(0,1,0))*.5 + .5 );\n\n        vec3 ambientColor;\n        vec3 diffuseColor = col;\n        if (m != 4.)\n        {\n            vec3 sunDir = normalize(vec3(0.,-1.,0.));\n            vec4 sunLight = vec4(0.0, 1.0, 1.0, 0.2);\n            ambientColor = sunLight.xyz * sunLight.w * clamp(dot(normal, -sunDir), 0., 1.) * clamp(1.-length(hitPos.xz)/3.,0.,1.);\n        }\n\n        vec3 lightColor = vec3(1.0,1.0,1.0);\n        float lumen = 1.0f;\n        if (m != 4.)\n        {\n            lightColor = vec3(.4,0.0,.8);\n            lumen = 0.;\n            vec3 lightPos = vec3(0.,1.6,0.);\n            vec3 lightDelta = lightPos-hitPos;\n            float lightHitDist = length(lightDelta);\n            float lightDist = castRayLight(hitPos + normal * STEP_SIZE, lightDelta / lightHitDist);\n            float lightMinRange = 1.;\n            float lightMaxRange = 3.;\n            if (lightDist >= lightHitDist) lumen = clamp(1. - (lightHitDist-lightMinRange )/(lightMaxRange-lightMinRange),0.,1.);\n        }\n\n        col = ambientColor + diffuseColor * lightColor * lumen;\n    }\n    else\n        col = vec3(0);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 p )\n{\n    p = p/iResolution.xy;\n    p = adjustAspectRatio(p);\n    vec3 camPos = vec3(0, 1.5, -2.5);\n    camPos.z += (iMouse.y / iResolution.y) * 2.;\n    camPos.xz *= rot2D(iMouse.x / iResolution.x * 10. - iTime * 0.);\n    vec3 camDir = getCameraRayDir(p, camPos, vec3(0,1,0));\n    vec3 col = render(camPos, camDir);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}