{"ver":"0.1","info":{"id":"3ttGDH","date":"1576192790","viewed":194,"name":"[TWITCH] Peaceful","username":"Flopine","description":"Sahder made during a live stream, you can see all of them here: https://www.twitch.tv/flopine","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","colors","toonshading","twitchstream"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\n#define PI 3.141592\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(13.4,18.5)))*1478.5);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat scenery (vec3 p)\n{\n    p.y += cos((p.z+sin(p.x)*0.2)*5.)*0.05;\n    p.y += texNoise(p.xz*.15).g*0.15;\n    p.y += 15.8;\n\n    float b1 = box(p,vec3(4.,15.,15.));\n    p.z += 3.;\n    float b2 = box(p,vec3(18.,15.,5.));\n    return min(b2,b1);  \n}\n\nfloat lantern (vec3 p)\n{\n    vec3 pp = p;\n    float c1 = cyl(p.xzy, 0.1+(abs(p.y-0.5)-0.1)*0.15, .6);\n    p.y -= 0.85;\n    float c2 = cyl(p.xzy+vec3(0.,0.,cos(p.x*3.)*0.1), 0.3, 0.02);\n    p.y -= 0.1;\n    float c3 = max(-box(p,vec3(0.1,0.1,10.))+0.05,cyl (p.xzy, 0.25,0.18));\n    p.y -= 0.5;\n    float c4 = cyl(p.xzy, 0.01-p.y, 0.3);\n    float c5 = cyl(p.xzy, 0.05, 0.05);\n    return stmin(c1,min(c2,min(c3,stmin(c4,c5,0.1,2.))),0.3,2.);\n}\n\nfloat lanterns (vec3 p)\n{\n    float per = 1.5;\n    p.z += 3.;\n    p.x = abs(p.x)-4.;\n    p.z = abs(p.z)-1.;\n    return lantern(p);\n}\n\nfloat fence (vec3 p)\n{\n    p.y += .25;\n    p.x = abs(p.x)-1.5;\n    float b1 = min(box(p, vec3(0.06,0.7,0.06)),length(p-vec3(0.,.8,0.))-.15);\n    float b2 = box(p-vec3(-1.,.4,0.),vec3(1.,0.06,0.06));\n    float b3 = box(p-vec3(-1.,0.,0.),vec3(1.,0.06,0.06));\n    float b4 = box(p-vec3(-1.,-0.1,0.),vec3(0.06,0.6,0.06));\n    return min(b1,min(b2,min(b3,b4)));\n}\n\nfloat fences (vec3 p)\n{\n    vec3 pp = p;\n    p.z -= 8.;\n    p.x = abs(p.x)-2.;\n    float f1 = fence(p);\n\n    p = pp;\n    p.z -= 4.;\n    p.xz *= rot(PI/2.);\n    p.xz = abs(p.xz)-vec2(1., 3.6);\n    float f2 = fence(p);\n\n    p = pp;\n    p.z -= 1.;\n    p.x = abs(p.x)-6.8;\n    p.x = abs(p.x)-1.5;\n    float f3 = fence(p);\n\n    return min(f3,min(f2,f1));\n}\n\nfloat water (vec3 p)\n{\n    p.y += (texNoise(p.xz*0.1+time*0.05).r + texNoise(p.xz*0.05-time*0.04).r)*0.4;\n    return p.y;\n}\n\nfloat prim1 (vec3 p)\n{\n    p.xz *= rot(sin(p.y*2.-time));\n    p.x = abs(p.x)-.5;\n\n    p.x += sin(p.y*5.+time)*0.3;\n    p.y += cos(p.x+time)*0.5;\n    float s = cyl(p.xzy, 0.1+p.y*0.5, 10.);\n    return s;\n}\n\nfloat pool (vec3 p)\n{\n    p.z -= 4.;\n    float b1 = max(-box(p,vec3(2.,10.,1.5)),box(p,vec3(2.5,.4,2.)))-0.05;\n    float w = max(water(p-vec3(0.,0.5,0.)),\n                  box(p,vec3(2.5,.6,2.)));\n    return min(smin(w,prim1(p),1.),b1);\n}\n\nfloat SDF (vec3 p)\n{\n    return min(water(p+vec3(0.,1.,0.)),min(fences(p),min(lanterns(p),stmin(scenery(p),pool(p),.7,3.))));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f*0.85 + l*uv.x + u*uv.y);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.05,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return max(dot(n,l),0.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.001,3.,-8.),\n        p = ro,\n        tar = vec3(0.,0.5,0.),\n        rd = getcam(ro,tar, uv),\n        l = normalize(vec3(0.,0.5, -3.)),\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad =  i/64.;\n            break;\n        }\n        d *= 0.5+dither*0.1;\n        p += d*rd;\n    }\n    \n    float t = length(ro-p);\n    vec3 n = getnorm(p);\n    float fre = clamp(pow(1.-dot(n,-rd),2.5),0.,1.);\n    float light = pow(floor(lighting(n,l)*4.)/4., 0.5);\n    \n    col = mix(vec3(0.,0.3,0.7), vec3(0.8,0.4,0.7), light)*(1.-fre);\n    col += fre*vec3(1.,0.8,0.2);\n\n    col = mix(col, vec3(0.7,0.8,0.6), 1.-exp(-0.003*t*t));\n\n    fragColor = vec4(sqrt(col),1.);\n}","name":"Image","description":"","type":"image"}]}