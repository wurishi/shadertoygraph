{"ver":"0.1","info":{"id":"3djfzG","date":"1590285136","viewed":252,"name":"Outline 2020 shader showdown 1","username":"lovelyH","description":"Coded live in 25min during shader showdown at Outline 2020 demoparty in round me against Monsieur Soleil.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["showdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 410 core\n\n/// there were few details that I was planing to implement on competition, but didn't make it in time.\n/// uncoment this like to see as I it was on compeitition when time runned out. (except for texture)\n//#define CONFIG_AS_ON_COMPETITION\n\n#define E 0.001\n#define INF 1000.0\n#define MAX_DIST 700.0\n//#define iTime fGlobalTime\n\nvec2 rot( vec2 p, float l ){\n  return vec2(\n    p.x*cos(l) - p.y*sin(l),\n    p.x*sin(l) + p.y*cos(l)\n  );\n}\n\nfloat cube( vec3 p, vec3 s ){\n  p= abs(p) - s;\n  return length(vec3(\n    max(0.0,p.x),\n    max(0.0,p.y),\n    max(0.0,p.z)\n  ));\n}\n\n\n\n//uniform float fGlobalTime; // in seconds\n//uniform vec2 v2Resolution; // viewport resolution (in pixels)\n//uniform sampler1D texFFT; // towards 0.0 is bass / lower freq, towards 1.0 is higher / treble freq\n//uniform sampler1D texFFTSmoothed; // this one has longer falloff and less harsh transients\n//uniform sampler1D texFFTIntegrated; // this is continually increasing\n//uniform sampler2D texChecker;\n//uniform sampler2D texNoise;\n//uniform sampler2D texTex1;\n//uniform sampler2D texTex2;\n//uniform sampler2D texTex3;\n//uniform sampler2D texTex4;\n//layout(location = 0) out vec4 out_color; // out_color must be written in order to see anything\n\n\nint mmid=0;\nvec3 mlight;\n\nfloat map(vec3 p){\n  mmid= 0;\n  mlight= vec3(INF);\n  float r=p.z, rc;\n  vec3 ph,ph2;\n  \n  /// blue ball\n  ph= p;\n  ph.x -= sin(iTime);\n  ph.y= mod( ph.y-1.8*iTime, 400.0 ) - 200.0;\n  ph.z -= 0.7-0.4*abs(sin(iTime));\n  rc= length(ph)-0.3;\n  if( rc < r ){ r=rc; mmid= 2; }\n  mlight=  min( mlight, vec3(INF,INF,rc) );\n  \n  /// gray statues\n  ph= p;\n  ph.x= abs(ph.x) - 3.0;\n  ph.y= mod( ph.y, 10.0 ) - 5.0;\n  rc= cube( ph, vec3(.5) )-0.01;\n  rc= min( rc, cube( ph-vec3(0,0,.75), vec3(.25,.25,.1) )-0.05);\n#ifdef CONFIG_AS_ON_COMPETITION\n  \trc= min( rc, cube( ph-vec3(-.4,0,.98), vec3(.1,.1,.05) )-0.05); /// that's how I made it during compeition\n#else\n\trc= min( rc, cube( ph-vec3(-.4,0,.95), vec3(.1,.1,.05) )-0.05); /// that's how I was plaing to make it\n    ph2=ph-vec3(-.35,0,1.05);ph2.x= abs(ph2.x)-0.05;rc= min( rc, length(ph2)-0.05 ); /// and this is another line that I was planing to put, but didn't make it in time\n#endif\n  ph.xy= abs(ph.xy)-0.3;\n  rc= min( rc, cube( ph-vec3(0,0,.6), vec3(.1,.1,.05) )-0.05);\n  if( rc < r ){ r= rc; mmid= 1; }\n\n  /// light red balls\n  ph= p;\n  ph.x= abs(ph.x);\n  ph.z -= 2.0;\n  ph.y= mod( ph.y, 10.0 ) - 5.0;\n  ph.xz= rot( ph.xz, -0.5-0.5*sin(3.0*iTime+0.01*p.y) );\n  ph.x -= 2.0;\n  ph.z -= sin(iTime+0.1*p.y);\n  //ph.z -= texture( texTTF, ph.y ).x;\n  \n  rc= length(ph)-0.5;\n  if( rc < r ){r= rc; mmid=3;}\n  mlight= min( mlight, vec3(rc,INF,rc) );\n  \n  /// yellow lights\n  ph=p;\n  ph.z -= 2.5;\n  ph.y= mod( ph.y, 10.0 ) - 5.0;\n  ph.xz= rot( ph.xz, iTime+0.01*p.y);\n  ph.z -= 4.0;\n  rc= length(ph);\n  r= min( r, rc );\n  mlight= min( mlight, vec3(rc,rc,INF) );\n\n  /// light blue lights\n  ph=p;\n  ph.z -= 2.5;\n  ph.y= mod( ph.y, 10.0 ) - 5.0;\n  ph.xz= rot( ph.xz, -iTime-0.01*p.y);\n  ph.z -= 4.0;\n  rc= length(ph);\n  r= min( r, rc );\n  mlight= min( mlight, vec3(INF,rc,rc) );\n  \n  return r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n  vec3 r= vec3(0);\n  float rp= 1.0, nrp=0.0;\n  for(int ra=0;ra<2;ra++){\n    vec3 p= sp;\n    float t= 0.0;\n    float dis= map(p);\n    vec3 light=vec3(INF);\n    for(int a=0;a<0x200;a++){\n      t += dis;\n      p= sp+dir*t;\n      dis= map(p);\n      if( dis < E || MAX_DIST < t )break;\n      light= min( light, mlight );\n    }\n    vec3 plight= mlight;\n    vec3 nor;\n    int matId= mmid;\n    \n    if( t < MAX_DIST ){\n      nor= normalize(vec3(\n        map(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n        map(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n        map(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n      ));\n      \n      vec3 color;\n      switch(matId){\n        //case 0: color=vec3(.2,.2,.7); nrp=0.5; nor= normalize(texture(texTex4,0.01*p.xy).xyz-0.5+vec3(0,0,5)); break;\n        case 0: color=vec3(.2,.2,.7); nrp=0.5; nor= normalize(texture(iChannel0,0.02*p.xy).xyz-0.5+vec3(0,0,5)); break; /// during competition I was using different texture, that one is not that good but it does the job\n        case 1: color=vec3(.5); break;\n        case 2: color=vec3(0,0,1); break;\n        case 3: color=vec3(1,0,1); break;\n      }\n      \n      r = rp*color\n        * (0.6+0.4*dot(nor,-dir))\n        * (0.6+0.4*dot(nor,vec3(0,0,1)))\n        * (1.0 / (1.0 +0.1*t))\n        * (1.0 / (1.0 +0.1*t))\n      ;\n      r += rp*(1.0 / (1.0 + 3.0*plight));\n    }\n    \n    r += rp*(1.0 / (1.0 + 5.0*light));\n    \n    rp *= nrp;\n    if( rp < 0.1 )break;\n    \n    dir= reflect( dir, nor );\n    sp= p + 20.0*E*dir;\n    \n  }\n  return r;\n}\n\n\n\n\n//vec4 plas( vec2 v, float time )\n//{\n//  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n//  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n//}\n//void main(void)\n//{\n//  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n//  uv -= 0.5;\n//  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  \n//  vec3 dir= normalize( vec3(uv.x, 4, uv.y) );\n\n//  //out_color.xyz= vec3(0);\n//  out_color.xyz= render( vec3(0,30.0*(mod(iTime,120.0)-60.0),1), dir );\n//}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 dir= normalize( vec3(uv.x, 4, uv.y) );\n\n  fragColor.xyz= render( vec3(0,30.0*(mod(iTime,120.0)-60.0),1), dir );\n}","name":"Image","description":"","type":"image"}]}