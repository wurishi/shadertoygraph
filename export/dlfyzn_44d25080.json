{"ver":"0.1","info":{"id":"dlfyzn","date":"1731898653","viewed":20,"name":"plane and sphere","username":"nenuser","description":"sphere checkerboard, plane","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","checkerboard","plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n} sphere;\n\nstruct Light\n{\n    vec3 direction;    \n} light;\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n} material;\n\n\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n} plane;\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0.2, 1.5);\n    camera.direction = vec3(2., 1., 0.);\n    camera.zoom = 1.0;\n    \n    sphere.position = vec3(-0.4, 0., 0.);\n    sphere.radius = 0.3;\n    sphere.color = vec3(0.2, 0.9, 0.3);  // Update sphere color to green\n    \n    plane.position = vec3(0., -0.5, 0.); // You can set the position as you want\n    plane.normal = vec3(0., 1., 0.); // This means that the plane is horizontal\n    plane.color = vec3(0.5, 0.5, 0.5); // The color of the plane is gray\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n    \n    material.ambience = 0.2;\n    material.diffuse = 0.7;\n    material.specular = 1.9;\n    material.shininess = 100.0;    \n}\n\nbool intersectPlane(vec3 direction, out vec3 surfaceNormal)\n{\n    float denom = dot(plane.normal, direction);\n    \n    if (abs(denom) > 1e-6)\n    {\n        float t = dot((plane.position - camera.position), plane.normal) / denom;\n        if(t >= 0.0) // use 0.0 instead of 0\n        {\n            surfaceNormal = normalize(plane.normal);\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\n\n\nbool intersectSphere(vec3 direction, out vec3 surfaceNormal)\n{\n    vec3 L = sphere.position - camera.position;\n    float tca = dot(L, direction);\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > sphere.radius * sphere.radius) return false;\n    float thc = sqrt(sphere.radius * sphere.radius - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    if (t0 > t1) \n    {\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    if (t0 < 0.0)\n    {\n        t0 = t1;\n        if (t0 < 0.0) return false;\n    }\n    \n    vec3 Phit = camera.position + t0 * direction;\n    surfaceNormal = normalize(Phit - sphere.position);\n    return true;\n}\n\nvec3 getPlaneColor(vec3 hitPoint)\n{\n    float scale = 1.0; // Adjust this to change the scale of the checkerboard\n    float checker = mod(floor(hitPoint.x * scale) + floor(hitPoint.z * scale), 2.0);\n    vec3 color1 = vec3(1.0, 1.0, 1.0); // Color of one part of the checker\n    vec3 color2 = vec3(0.0, 0.0, 0.0); // Color of the other part\n    return mix(color1, color2, checker);\n}\n\nbool intersectPlane(vec3 direction, out vec3 surfaceNormal, out vec3 hitPoint)\n{\n    float denom = dot(plane.normal, direction);\n    \n    if (abs(denom) > 1e-6)\n    {\n        float t = dot((plane.position - camera.position), plane.normal) / denom;\n        if(t >= 0.0)\n        {\n            surfaceNormal = normalize(plane.normal);\n            hitPoint = camera.position + t * direction; \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    vec3 hitPoint;\n    \n    if (intersectSphere(direction, surfaceNormal))\n    {\n        float coeff = -dot(light.direction, surfaceNormal);                          \n        \n        vec3 ambient = material.ambience * sphere.color;\n        vec3 diffuse = material.diffuse * max(coeff, 0.) * sphere.color;\n        \n        float shininess = pow(max(-dot(direction, reflect(light.direction, surfaceNormal)), 0.), material.shininess);\n        vec3 specular = material.specular * shininess * sphere.color;\n        \n        return ambient + diffuse + specular;\n    }\n    \n    if (intersectPlane(direction, surfaceNormal, hitPoint))\n    {\n        vec3 planeColor = getPlaneColor(hitPoint);\n        \n        float coeff = -dot(light.direction, surfaceNormal);                          \n        \n        vec3 ambient = material.ambience * planeColor;\n        vec3 diffuse = material.diffuse * max(coeff, 0.) * planeColor;\n        \n        float shininess = pow(max(-dot(direction, reflect(light.direction, surfaceNormal)), 0.), material.shininess);\n        vec3 specular = material.specular * shininess * planeColor;\n        \n        return ambient + diffuse + specular;\n    }\n    \n    return vec3(0., 0., 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n        vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n\n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n\n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}