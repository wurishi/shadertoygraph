{"ver":"0.1","info":{"id":"ttfGRM","date":"1556036682","viewed":97,"name":"First assignment - halgraf","username":"szadam12","description":"First assignment","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\nconst float perszaznyolcvan = 0.00555555555555555555555555555556;\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nstruct Ray\n{\n\tvec3 P;\n    float Tmin;\n\tvec3 V;\n    float Tmax; \n    \n};\n    \nstruct TraceResult\n{\n    float T;\n    int flags;\n    int iterations;\n    int material;\n};\n    \nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n///SDF\n\nvec2 sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    int flag;\n    float f = sdTorus(p-vec3(2,4,0), vec2(3,1));\n    float g = sdVerticalCapsule(p-vec3(2,0,0), 10., 1.);\n    float h = sdBox(p-vec3(5,4,0),vec3(2,1,1));\n    float m = max(f,-h);\n    float minimum = min(min(g,m),p.y+1.);\n    if(f == minimum) flag = 1;\n    else if(g == minimum) flag = 2;\n    else if(p.y+1. == minimum) flag = 3;\n        \n    return vec2(minimum, flag);\n}\n\nvec2 _sdf(in vec3 p)\n{\n    //p-=vec3(0,0,2);\n    float balls[45];\n    float i;\n    for(i=0.; i < 45.; i++)\n    {\n        p-=vec3(0,0,2);\n        if(int(i)%9 == 0)\n        {\n            p+=vec3(4,2,6);\n        }\n        else if(int(i)%3 == 0)\n        {\n            p+=vec3(-2,0,6);\n        }\n        balls[int(i)] = sdSphere(p,1.);\n    }\n    float minimum = balls[0];\n    for(int b=1; b < 45; b++)\n        minimum = min(minimum,balls[b]);\n    minimum = min(minimum,p.y+1.);\n    int flag = 1;\n    return vec2(minimum, flag);\n}\n\nvec2 sdf25(in vec3 p)\n{\n    //p-=vec3(0,0,2);\n    float balls[50];\n    float i;\n    for(i=0.; i < 50.; i++)\n    {\n        p-=vec3(0,0,2);\n        if(int(i)%25 == 0)\n        {\n            p+=vec3(8,2,10);\n        }\n        else if(int(i)%5 == 0)\n        {\n            p+=vec3(-2,0,10);\n        }\n        balls[int(i)] = sdSphere(p,1.);\n    }\n    float minimum = balls[0];\n    for(int b=1; b < 50; b++)\n        minimum = min(minimum,balls[b]);\n    minimum = min(minimum,p.y+1.);\n    int flag = 1;\n    return vec2(minimum, flag);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---- SPHERE TRACING ----\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,0,0);\n    float dist;\n    vec2 sdf_ret;\n    int material;\n    int i = 0; do\n    {\n        vec3 pointInRay = ray.P+ret.T*ray.V;\n        sdf_ret = sdf(pointInRay);\n        dist = sdf_ret.x;\n        material = int(sdf_ret.y);\n        ret.T+=dist;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&\n\t\tdist  > params.epsilon * ret.T &&\n\t\ti     < params.maxiters\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(dist <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    ret.iterations = i;\n    ret.material = material;\n    return ret;\n}\n\n// --------------- Accelerating sphere tracing ---------------\n\nTraceResult relaxed_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,0,3);\n    float r = 0.0;\n    float newR = 99999999.0;\n    vec2 sdf_ret;\n    \n    int i = 0; do\n    {\n        float stepSize = r + 0.6*r;\n        vec3 pointInRay =  ray.P+(ret.T+stepSize)*ray.V;\n        sdf_ret = sdf(pointInRay); \n        newR = sdf_ret.x; \n        if (newR + r < stepSize) { // Ket kor nem metszi egymast\n            stepSize = r;\n            vec3 pointInRayBack = ray.P+(ret.T+stepSize)*ray.V;\n            sdf_ret = sdf(pointInRayBack);\n            newR = sdf_ret.x;\n        } \n        r = newR;\n        ret.T += stepSize;\n        ++i;\n        \n    } while (\n\t\tret.T < ray.Tmax &&\n\t\tr  > params.epsilon * ret.T &&\n\t\ti     < params.maxiters\n\t);\n    \n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(r <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    ret.iterations = i;\n    return ret;\n}\n\nTraceResult enhanced_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,0,3);\n    float r = 0.0;\n    float newR = 99999999.0;\n    float oldR = 0.0;\n    float stepSize = 0.0;\n    vec2 sdf_ret;\n    \n    int i = 0; do\n    {\n        stepSize = r + 0.9*r*(stepSize-oldR+r/max(stepSize+oldR-r, 999.));\n       \n        vec3 pointInRay =  ray.P+(ret.T+stepSize)*ray.V;\n        sdf_ret = sdf(pointInRay); \n        newR = sdf_ret.x; \n        if (newR + r < stepSize) {\n            stepSize = r;\n            vec3 pointInRayBack = ray.P+(ret.T+stepSize)*ray.V;\n            sdf_ret = sdf(pointInRayBack); \n        \tnewR = sdf_ret.x; \n        } \n        oldR = r;\n        r = newR;\n        ret.T += stepSize;\n        ++i;\n        \n    } while (\n\t\tret.T < ray.Tmax &&\n\t\tr  > params.epsilon * ret.T &&\n\t\ti     < params.maxiters\n\t);\n    \n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(r <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    ret.iterations = i;\n    return ret;\n}\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).x,sdf(p+vec3(0,eps,0)).x,sdf(p+vec3(0,0,eps)).x);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).x,sdf(p-vec3(0,eps,0)).x,sdf(p-vec3(0,0,eps)).x);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    vec3 texColor = texture(iChannel2, ray.V).xyz;\n    return vec4(texColor,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 hitPos = ray.P+ray.V*t;\n    vec3 n = normal(hitPos);\n    \n\n    vec3 lightPos=vec3(10.,10.,10.);\n    \n    // to - from\n    vec3 hitToLight = normalize(lightPos - hitPos);\n    \n\n    Ray shadowRay = Ray(hitPos,0.05,hitToLight,distance(hitPos,lightPos));\n    SphereTraceDesc params = SphereTraceDesc(0.01, 64);\n    TraceResult result = sphere_trace(shadowRay, params);\n    \n    vec3 color;\n    if(bool(result.flags & 1)) {\n        vec3 objectColor = vec3(1,1,0);\n        float fenyerosseg = dot(n,hitToLight); \n        color = objectColor * max(fenyerosseg,0.);\n    } else if(bool(result.flags & 2))\n        color = vec3(0,0,0);\n    else\n    \tcolor = vec3(1,0,0); // HIBA\n    \n    return vec4(color,1.);\n}\n\n// --------------- Cook-Torrance BRDF ---------------\n\nfloat DistributionGGX(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = pi * denom * denom;\n\t\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\n  \nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec4 hitColorCookTorr(Ray ray,float t, int material)\n{\n    vec3 lightPos=vec3(10.,10.,10.);\n    vec3 p = ray.P + ray.V*t;\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 F0;\n    \n    if(material==3)\n    {\n    albedo = vec3(0.1,0.7,0.3);\n    metallic = 0.1;\n    roughness = 0.2;\n    F0 = vec3(0.6);\n    }\n    else if(material==2)\n    {\n    albedo = vec3(0.5,0.5,0.5);\n    metallic = 0.9;\n    roughness = 0.2;\n    F0 = vec3(0.25);\n    }\n    else if(material==1)\n    {\n    albedo = vec3(0.3,0.2,0.6);\n    metallic = 0.1;\n    roughness = 0.9;\n    F0 = vec3(0.05);\n    }\n\tvec3 N = normalize(normal(ray.P+ray.V*t));\n    vec3 V = normalize(ray.V * -1.0);\n\n    F0 = mix(F0, albedo, metallic);\n\t           \n    vec3 Lo = vec3(0.0);\n    vec3 L = normalize(lightPos - p);\n    vec3 H = normalize(V + L);\n   \n    // Pont fenyforrasunk van akkor tavolsaggal gyengul\n    float distance2    = length(lightPos - p); \n    float attenuation = 1.0 / (distance2 * distance2 * 0.1);\n    vec3 radiance     = vec3(20) * attenuation;   // Gyengitessel beszorozzuk a fenyforras szinet.     \n    \n    // cook-torrance brdf\n    float NDF = DistributionGGX(N, H, roughness);        \n    float G   = GeometrySmith(N, V, L, roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n        \n    vec3 kS = F; // Ez az amit visszaver\n    vec3 kD = vec3(1.0) - kS; // Ez meg amit elnyel.\n    kD *= 1.0 - metallic;\t  \n        \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);  \n\n    float NdotL = max(dot(N, L), 0.0);                \n    Lo += (kD * albedo / pi + specular) * radiance * NdotL;\n  \n    vec3 ambient = vec3(0.03) * albedo; // Arnyekban levo szin.\n    vec3 color = ambient + Lo;\n\t\n    \n    // Gamma korrekcio/Tone mapping\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));  \n   \n    return vec4(color, 1.0);\n}\n\n// ---- CAMERA and EVENTs ----\n\n// Common key codes (WASD instead of arrows)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n\t\t\tpixelRandom = (r,g,b, DISTANCE)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\n    if (isKeyHeld(KeyLeft )) eye -= u;\n    if (isKeyHeld(KeyRight)) eye += u;\n    if (isKeyHeld(KeyUp   )) eye += w;\n    if (isKeyHeld(KeyDown )) eye -= w;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\n               0.5,\n               normalize(w+px.x*u+px.y*v),\n               500.);\n}\n\n// --------------- INTERACTIVE ---------------\n\nbool isCameraMoved() {\n    vec2 data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\n    return (iMouse.z>0. || data2.x >= 0.) ||\n \t (isKeyHeld(KeyLeft )) ||\n     (isKeyHeld(KeyRight)) ||\n     (isKeyHeld(KeyUp   )) ||\n     (isKeyHeld(KeyDown ));\n}\n\nvec3 lights(float frame){\n    return vec3(sin(frame) + frame /100.0 + 5.0,sin(frame) + 5.0,cos(frame) + 15.0);\n}\n\nvec4 colorIncremental(Ray ray,float t){\n\tvec3 hitPos = ray.P+ray.V*t;\n    vec3 n = normal(hitPos);\n    \n    float prevFrameNum = texelFetch(iChannel0, ivec2(0,0), 0).x;\n    vec3 lightPos = lights(prevFrameNum);\n    vec3 lightColor = vec3(1,1,1);\n    \n    vec3 hitToLight = normalize(lightPos - hitPos);\n    \n    Ray shadowRay = Ray(hitPos,0.05,hitToLight,distance(hitPos,lightPos));\n    SphereTraceDesc params = SphereTraceDesc(0.01, 64);\n    //TraceResult result = relaxed_sphere_trace(shadowRay, params);\n    TraceResult result = sphere_trace(shadowRay, params);\n    \n    vec3 color;\n    if(bool(result.flags & 1)) {\n        vec3 objectColor = vec3(1,1,0);\n        float lightDistance = length(lightPos - hitPos);\n        float fenyerosseg = dot(n,hitToLight) / (lightDistance*lightDistance + 0.1);\n        color = objectColor * max(fenyerosseg,0.) * lightColor;\n    } else if(bool(result.flags & 2))\n        color = vec3(0,0,0);\n    else\n    \tcolor = vec3(1,0,0);\n    \n    return vec4(color,1.);\n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    \n    if(isCameraMoved()){\n        SphereTraceDesc params = SphereTraceDesc(0.01, 64);\n\n        // Raytrace\n\n        float continueCone = texelFetch(iChannel3, ivec2(fragCoord / 2.), 0).x;\n    \tray.Tmin = continueCone;\n\n        //TraceResult result = relaxed_sphere_trace(ray, params);\n        //TraceResult result = enhanced_sphere_trace(ray, params);\n        TraceResult result = sphere_trace(ray, params);\n\n         //Debug\n\n        fragColor=vec4(0.,0.,0.,1.); //debug\n        if(bool(result.flags & 1)) fragColor.b=1.;\n        if(bool(result.flags & 2)) fragColor.g=1.;\n        if(bool(result.flags & 4)) fragColor.r=1.;\n\n\n\n        if(bool(result.flags & 1))    fragColor = missColor(ray);    \n        //else if(bool(result.flags&2)) fragColor = hitColorCookTorr(ray, result.T, result.material);\n        else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n        else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n        vec4 prevcolor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor = 0.0*prevcolor + 1.0*fragColor;\n        fragColor.w = result.T;\n        //fragColor = vec4(0,0,float(result.iterations) / 64.0,1);\n    } else {\n        vec4 prevcolor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        \n        vec3 newColor = colorIncremental(ray, prevcolor.w).xyz;\n        vec3 blendedColor = prevcolor.xyz + newColor;\n        fragColor = vec4(blendedColor,prevcolor.w);\n    }\n   \n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5){ // pixel (0,0)\n        fragColor.yzw = eye;\n        if (iFrame <= 1){\n\t        fragColor.x = 1.0;\n        }\n        else if(isCameraMoved()){\n        \tfragColor.x = 1.0;\n        }\n        else{\n            float prevFrameNum = texelFetch(iChannel0, ivec2(0,0), 0).x;\n        \tfragColor.x = prevFrameNum+1.0;\n        }\n    }\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"TraceResult cone_trace(in Ray ray, in SphereTraceDesc params, float tanAlfa)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0, 0);\n    float dist;\n    \n    int i = 0; \n    do\n    {\n        dist = sdf(ray.P+ret.T*ray.V).x;\n        ret.T+=dist;\n        ++i;\n    } while ( \n        \n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\tdist > ret.T * tanAlfa &&\t        // Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(dist <= ret.T * tanAlfa)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\n    if (isKeyHeld(KeyLeft )) eye -= u;\n    if (isKeyHeld(KeyRight)) eye += u;\n    if (isKeyHeld(KeyUp   )) eye += w;\n    if (isKeyHeld(KeyDown )) eye -= w;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if(!(fragCoord.x < iResolution.x / 2. && fragCoord.y < iResolution.y /2.))\n        discard;\n    \n    vec3 eye; vec2 data;\n    Ray ray = Camera(fragCoord*2., eye, data);\n    SphereTraceDesc params = SphereTraceDesc(0.001, 64);\n    \n    float openingAngle = 45.0 * pi * perszaznyolcvan;;\n    float tanAlfa = sqrt(2.) * tan(openingAngle) / length(iResolution);\n    TraceResult result = cone_trace(ray, params, tanAlfa*2.);\n    \n    fragColor = vec4(result.T,result.T,result.T,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}