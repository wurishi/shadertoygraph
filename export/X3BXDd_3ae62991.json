{"ver":"0.1","info":{"id":"X3BXDd","date":"1711206653","viewed":272,"name":"Improved Branchless Voxel DDA","username":"chronos","description":"from scratch re-derived 'branchless' voxel DDA ray marching to handle tie-breaks, precision artifacts, infs, and nans!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycast","voxel","dda","branchless","cast","diagram","improved","fixed"],"hasliked":0,"parentid":"XXBSDt","parentname":"Compact Lode DDA 3D Derivation"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n        Improved Branchless Voxel DDA by chronos\n    \n    --------------------------------------------------------------------------------------\n    \n        Branchless version of the previous shader!\n\n        This from scratch re-derived 'branchless' voxel DDA ray marching shader\n        should correctly handle tie-breaks, precision artifacts, infs, and nans! :D\n\n        Let me know if you spot any issues!\n\n        // self link: https://www.shadertoy.com/view/X3BXDd\n*/\n\nfloat voxelmap(vec3 p) // voxel map\n{\n    p = floor(p) + 0.5 - vec3(0, 10., 0);\n    float result = (length(vec2(p.x, abs(length(p.yz) - 10.))) - 4.);\n    return float(result>0.);\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 proj = dot(p, axis) * axis;\n    return proj + cos(angle) * (p-proj) + sin(angle) * cross(axis, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    // Camera setup\n    \n    float focal = 1.;\n    \n    vec3 pos = vec3(0., 0, 0.);          // Start / camera position\n    vec3 rayDir = (vec3(uv,-focal));     // Direction to cast ray    \n    \n    float angle = iTime;\n    \n    rayDir = rot(rayDir, vec3(0,0,1), angle/2.);\n    \n    pos -= vec3(0., 10., 0.);\n    pos = rot(pos, vec3(1,0,0), angle);\n    pos += vec3(0., 10., 0.);\n    \n    rayDir = rot(rayDir, vec3(1,0,0), angle);\n    \n    // DDA setup\n\n    vec3 map = floor(pos);           // integer cell coordinate of initial / current cell\n\n    vec3 stepDir=vec3(0);            // step sign +/- 1\n    vec3 sideDist=vec3(9e9);         // initial distance to cell sides, then relative difference between traveled sides\n    \n    // Note the use of un-normalized rayDir here! using normalized rayDir or length() here gives ragged edges artifact!\n    vec3 deltaDist = 1./abs(rayDir); // ray length required to step from one cell border to the next in x, y and z directions\n    \n    float side=0.;\n\n    vec3 S = step(0., rayDir); // S is rayDir non-negative? 0 / 1\n    stepDir = 2.*S-1.;\n    \n    // if 1./abs(rayDir[i]) is inf, then rayDir[i] is 0., but then S = step(0., rayDir[i]) is 1\n    // so S cannot be 0. while deltaDist is inf, and stepDir * fract(pos) can never be 1.\n    // Therefore we should not have to worry about getting NaN here :)\n    \n    sideDist = (S-stepDir * fract(pos)) * deltaDist;   // alternative: //sideDist = (S-stepDir * (pos - map)) * deltaDist;\n    \n    // DDA marching \n    \n    for(int i = 0; i < 50; i++)\n    {\n        // Decide which way to go!\n        vec4 conds = step(sideDist.xxyy, sideDist.yzzx); // same as vec4(sideDist.xxyy <= sideDist.yzzx);\n        \n        // This mimics the if, elseif and else clauses\n        // * is 'and', 1.-x is negation\n        vec3 cases = vec3(0);\n        cases.x = conds.x * conds.y;                 // if       x dir\n        cases.y = (1.-cases.x) * conds.z * conds.w;  // else if  y dir\n        cases.z = (1.-cases.x) * (1.-cases.y);       // else     z dir\n        \n        // usually would have been:     sideDist += cases * deltaDist;\n        // but this gives NaN when  cases[i] * deltaDist[i]  becomes  0. * inf \n        // This gives NaN result in a component that should not have been affected,\n        // so we instead give negative results for inf by mapping 'cases' to +/- 1\n        // and then clamp negative values to zero afterwards, giving the correct result! :)\n        sideDist += max((2.*cases-1.) * deltaDist, 0.);\n        \n        map += cases * stepDir;\n        \n        if(voxelmap(map) > 0.) // Did we hit anything? if so, we are done!\n        {\n            side = cases.y + 2. * cases.z;\n            break;\n        }\n    }\n\n#if 0\n    color[int(side)] = 1.; // voxel face debug\n    color = color * (0.25 + 0.5 * float(float(mod(map.x,2.) != mod(map.y,2.))!=mod(map.z,2.)) );\n#else\n    vec3 n = vec3(side==0., side==1., side==2.);     // Axis plane normal. Alternatively: vec3 n = vec3[3](vec3(1,0,0), vec3(0,1,0), vec3(0,0,1))[int(side)];\n    vec3 p = map + .5 - stepDir*.5; // Point on axis plane\n\n    // Solve ray plane intersection equation: dot(n, ro + t * rd - p) = 0.\n    // for t :\n    float t = (dot(n, p - pos)) / dot(n, rayDir);\n    vec3 hit = pos + rayDir * t;\n    vec3 uvw = hit - map; // fract(hit) causes UV artifacts sometimes, so using this instead. Don't apply fract after!\n    vec2 texCoord = vec2[3](uvw.yz, uvw.zx, uvw.xy)[int(side)];\n    \n    if(side == 0.)\n        color = pow(texture(iChannel0, texCoord).rgb, vec3(2.2));\n    else if(side == 1.)\n        color = pow(texture(iChannel1, texCoord).rgb, vec3(2.2));\n    else\n        color = pow(texture(iChannel2, texCoord).rgb, vec3(2.2));\n        \n    #if 0\n    // Check UVs\n    color*=0.; color.rg += texCoord.rg;\n    #endif\n#endif\n        \n    color = pow(clamp(color, 0., 1.), vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}