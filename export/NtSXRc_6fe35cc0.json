{"ver":"0.1","info":{"id":"NtSXRc","date":"1628180734","viewed":672,"name":"Foldable French fancy","username":"evvvvil","description":"Foldable French fancy - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n","likes":38,"published":1,"flags":0,"usePreview":1,"tags":["demoscene","glow","unwrap","lights","rotation","fold","fancy","french","neat","reveal","structure"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Foldable French fancy\" - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"The french are no good at war: they're too busy painting and fornicating.\" - Some British general who obviously didn't get laid much\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,e=vec2(.00035,-.00035);float t,tt,b,bb,g,gg,gr,gt;vec3 np,pp,op,po,no,al,ld,rp; //GLOBAL VARIABLES\nfloat bo(vec3 p, vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //CHEAP BOX FUNCTION\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //ROTATE FUNCTION\nconst mat2 deg45 = mat2(.7071,.7071,-.7071,.7071); //OPTIMIZE ROTATIONS IN LOOP THAT USE FIXED 45 DEG ROTATION\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p ,float ga){ \n  op=p; //REMEMBER ORIGINAL POSITION BEFORE WE FUCK WITH IT\n  p.z=mod(p.z-tt*2.,30.)-15.; //MAKE WHOLE SCENE INFINIT AND MOVE FORWARD\n  pp=p;   //SETUP MAIN POSITION\n  b=smoothstep(0.,1.,sin(op.z*.05+tt*.2+3.5)*.5+.5); //ANIM VARIABLE  \n  pp.xy=vec2(abs(abs(pp.x)-8.2)-(1.+4.*b),abs(pp.y));    //CLONE MAIN POS A COUPLE OF TIMES\n  pp.z=mod(pp.z,2.)-1.; //INFINITE MODULO MAIN POS TO REPEAT FOLDABLE BIT ALONG Z \n  rp=pp; //ROTATE POSITION BASED ON MAIN POSITION\n  rp.y-=4.*b+1.;  //SHIFT UP AND DOWN\n  rp.xy*=r2(b*6.28); //ROTATE MAIN POSITION\n  gr=gt=1.; //SETUP GREEBLES DETAILS\n  vec2 sca=vec2(0.5,1);  //SETUP SCALER\n  vec4 gp=vec4(p.xz*.5,rp.xy); //PACK BOTH GREEBLE DETAILS POSITIONS INTO ONE VEC4 - THIS IS TO OPTIMIZE AND REDUCE CODE LENGTH\n  for(int i=0;i<3;i++){ //FRACTAL GREEBLE BULLSHIT\n    gp=abs(gp)-1.5; //SYMETRY MOVE EACH ITER\n    gp.xy*=deg45; //ROTATE EACH ITER 45 DEG POSITION 1\n    gp.zw*=deg45;//ROTATE EACH ITER 45 DEG POSITION 2\n    gp*=.85;sca*=0.85; //EACH ITER WE SCALE DOWN A BIT\n    gr=min(gr,clamp(sin(gp.x*5.),-.25,.25)*.5*sca.x); //ADD ITERATION GREEBLE TO PREVIOUS GREEBLE DETAIL FOR GREEBLE ON FLOOR\n    gt=min(gt,clamp(sin(gp.z*5.),-.25,.25)*.5*sca.y); //ADD ITERATION GREEBLE TO PREVIOUS GREEBLE DETAIL FOR GREEBLE ON ROTATING OBJECTS\n  }\n  vec2 h,t=vec2(.75*bo(rp,vec3(1.,1.,1.-b*.2)),3);   //BLACK BOX\n  np=rp; np.xz*=r2(b*.785);  //BLACK BOX CUTTER POSITION\n  t.x=max(t.x,.7*bo(np-gt*.7*b,vec3(1.,1.,1.-b*.2))); //BLACK BOX CUTER    \n  vec3 sp=rp;sp.y-=2.6-sin(b*3.14)*7.25+b*3.; //SPHERE POSITON\n  t.x=min(t.x,0.7*max(length(rp.xz)-.1,abs(sp.y+1.-sin(b*3.14)*2.1)-1.)); //THIN BLACK CYLINDER  \n  float whiteCyl=0.6*max(abs(abs(length(rp.xz)-.5-gt*.5)-.1)-.05,abs(rp.y)-1.1-b*3.4);//WHITE CYLINDERS\n  h=vec2(whiteCyl,6); //ADD WHITE CYLINDER TO MATERIAL ID 6\n  h.x=min(h.x,length(rp.xy)-.2); //LONG Z WHITE CYLINDER\n  h.x=min(h.x,max(abs(length(abs(rp.yz)-.0)-.2*b)-.1,abs(rp.x)-1.1)); //LONG Z WHITE CYLINDER    \n  float spheres=0.7*(length(sp)-.1);  //GLOW SPHERES\n  h.x=min(h.x,spheres); //ADD GLOW SPHERES  TO MATERIAL ID 6\n  g+=1.0/(0.1+spheres*spheres*100.)*ga; //MAKE SPHERES GLOW\n  np=abs(p)-vec3(0,7,0); np.xy*=deg45;//GROUND DIGGER POSITION\n  pp=p;pp.y=abs(pp.y)-21.; //GROUND AND CEILING POSITION\n  float ter=0.8*bo(pp,vec3(50,10,200)-gr*2.); //GROUND AND CEILING\n  ter=max(ter,-0.9*bo(np,vec3(8,8,200)-gr*2.));//DIG TRIANGULAR SHAPE INTO GROUND\n  float vertCyl=length(rp.xz)-.15; //VERTICAL GLOW CYLINDER\n  bb=max(0.,(b-.9)*10.); //animation variable\n  vertCyl=max(vertCyl,abs(rp.y+5.*bb)-1.); //VERTICAL GLWO CYLINDER\n  vertCyl=min(vertCyl,0.7*max(length(rp.yz),abs(rp.x-1.)-2.2*bb)); //VERTICA GLOW CYLINDER CUT\n  gg+=1.0/(0.1+vertCyl*vertCyl*(200.-sin(bb+op.z*.2+tt*2.)*180.))*ga*bb; //GLOW CYLINDERS\n  h.x=min(h.x,vertCyl);  //ADD CYLINDER TO SCENE MATERIAL ID 6\n  t=t.x<h.x?t:h;//MERGE T AND H MATERIAL ID GEOMETRIES INTO SCENE\n  h=vec2(ter,7); //ADD GROUND / CEILING TO MATERIAL ID 7\n  t=t.x<h.x?t:h; //MERGE T AND H MATERIAL ID GEOMETRIES INTO SCENE\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )//RAYMARCHING LOOP\n{\n  vec2 h,t=vec2(.1);//NEAR PLANE\n  for(int i=0;i<128;i++){//LOOOP MAX 128 STEPS\n  h=mp(ro+rd*t.x,1.);//GET DISTANCE TO GEOM\n    if(h.x<.0001||t.x>80.) break; //IF WE CLOSE ENOUGH OR IF WE TOO FAR, BREAK\n    t.x+=h.x;t.y=h.y;//BIG JUMP TO GEOMETRY IN NEXT ITERATION, REMEMBER MATERIAL ID\n  }  \n  if(t.x>80.) t.y=0.;//IF WE TOO FAR RETURN 0 MAT ID\n  return t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ //LINES ABOVE ARE ambient ollcusion and sss\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);   //GET UVS  \n  tt=mod(iTime,57.973)+8.;//MOD TIME TO AVOID ARTIFACT\n  b=smoothstep(0.,1.,sin(tt*.2)*.5+.5); //ANIMATION VARIABLE\n  vec3 ro=mix(vec3(0,15.-15.*b,20.),vec3(-18.*sin(tt*.2),(10.-20.*ceil(sin(tt*.2)))*sign(sin(tt*.1)),15.),ceil(cos(tt*.2))),//RAY ORIGIN = CAMERA POSITION\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //CAMERA STUFF\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo; //CAMERA STUFF...\n  co=fo=vec3(.1,.15,.2)-length(uv)*.18+texNoise(rd.xz,iChannel0).r*.2; //BACKGROUND COLOUR\n  ld=normalize(vec3(-.2,.3,-.3));//LIGHT DIRECTION\n  z=tr(ro,rd);t=z.x; //RAYMARCH PIXEL\n  if(z.y>0.){//IF WE HIT SOMETHING THEN DO LIGHTING\n    po=ro+rd*t;//GET WHERE WE AT\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x); //DERIVE NORMALS FROM WEHERE WE AT    \n    al=vec3(.05); //DEFAULT MATERIAL IS BLACK\n    if(z.y>5.)al=vec3(1.); //MATERIAL ID 6 IS WHITE\n    if(z.y>6.)al=mix(vec3(1.5),vec3(.05,.2,.5),sin(gr*60.)*.5+.5);//MATERIAL ID 7 IS WHITE + GREEBLE COLOUR\n    float dif=max(0.,dot(no,ld)), //DIFFUSE\n    fr=pow(1.+dot(no,rd),4.), //FRESNEL\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.); //SPECULAR\n    co=mix(sp+al*(a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));//FINAL LIGHTING RESULT\n    co=mix(fo,co,exp(-.00001*t*t*t)); //FOG\n  }\n  co+=g*.2*mix(vec3(.7,.3,0),vec3(1,.2,.1),1.-b)+gg*.2*vec3(.05,.2,.5);//ADD GLOWS\n  co=mix(co,co.zyx,length(uv)*.5); //CHEAP RADIAL UV SHADING\n  fragColor = vec4(pow(co,vec3(.55)),1); //GAMME CORRECTION\n}","name":"Image","description":"","type":"image"}]}