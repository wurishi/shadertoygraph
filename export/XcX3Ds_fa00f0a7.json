{"ver":"0.1","info":{"id":"XcX3Ds","date":"1703664924","viewed":39,"name":"Signed distances function","username":"Bertani545","description":"Practice with signed distance functions","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Constantes para el rayo\nconst vec3 r0 = vec3(0.0, 0.0, -5.0);\nconst vec3 global_light = vec3(0.1, 0.1, 0.1);\nconst float EPS = 0.0001;\n\nconst float MAX = 100.;\n\n\nvec3 rotation3D(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\n\n\nfloat toro(vec3 p, float R, float r)\n{\n    float temp = R - sqrt(p.x*p.x + p.y*p.y);\n    return temp*temp + p.z*p.z - r*r;\n    \n}\n\nfloat sphere(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nfloat piso(vec3 p){\n    return p.y + 0.75;\n}\n\n\nfloat dist_Function(vec3 p)\n{\n  vec3 p_toro = p;\n    //Traslacion\n  p_toro += vec3(.0, 0.0, .0);\n    //Rotar\n  p_toro = rotation3D(p_toro, vec3(1.0, 0.0, 0.0), iTime);\n  \n\n  return min(toro(p_toro, .4, .1), piso(p));\n  return sphere(p);\n}\n\n\nvec3 get_normal(vec3 p)\n{\n    \n    float f_p = dist_Function(p);\n    \n    return normalize(vec3(  dist_Function(vec3(p.x + EPS, p.y, p.z)) - dist_Function(vec3(p.x - EPS, p.y, p.z)),\n                            dist_Function(vec3(p.x, p.y + EPS, p.z)) - dist_Function(vec3(p.x, p.y - EPS, p.z)),\n                            dist_Function(vec3(p.x, p.y, p.z + EPS)) - dist_Function(vec3(p.x, p.y, p.z - EPS))));\n}\n\n\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float k = 10.; //Control the softness of the shadows\n    \n    float res = 1.0;\n    float distance_traveled = 2.*EPS; //Getting away from the object\n    \n    for( int i=0; i<255 && distance_traveled < MAX; i++ )\n    {\n        float d = dist_Function(ro + rd*distance_traveled);\n        if( d < EPS ) //Very dark shadow\n            return 0.0;\n        res = min( res, k * d/distance_traveled ); //Ratio of miss / distance traveled\n        distance_traveled += d;\n    }\n    return res;\n    \n    /*float distance_traveled = 2.*EPS; //Getting away from the object\n    float d = 0.0;\n    \n    \n    //Ray marching\n    for(float i = 0.0; i < 255.; i++){\n        vec3 p = ro + rd * distance_traveled;\n        \n        d = dist_Function(p);\n        \n        distance_traveled += d; //March the ray\n        \n        if(distance_traveled > 100.0) return false; //Infinity\n        \n        if(d < EPS) return true; //Close enough\n    }\n    return false;*/\n}\n\n\nvec3 phong_Model(vec3 p, vec3 light_position, vec3 light_Intensity, vec3 k_d, vec3 k_s, float alpha)\n{\n   //Get normal estimation\n   vec3 N = get_normal(p);\n   \n   //Parameters for the model\n   vec3 L = normalize(light_position - p);\n   vec3 V = normalize(r0 - p);\n   vec3 R = normalize(reflect(-L, N)); //How the vector -L reflects at the normal N\n   \n   float dotLN = dot(L, N);\n   float dotRV = dot(R, V);\n   \n   \n   \n   //Get color from phong\n   vec3 color = vec3(0., 0., 0.);\n        \n   //Global ilumination\n   color += global_light;\n   \n   //Check for shadows\n   float shadow_Val = shadow(p + N*0.1, L);\n        \n   //Direct light   \n   if(dotLN < 0.0) return pow(color, vec3(2.2)); //No extra light from light source  \n   color += shadow_Val * light_Intensity * k_d * dotLN;\n   \n   \n   //Phong reflection\n   if (dotRV < 0.0 || shadow_Val < 1.0) return pow(color, vec3(2.2)); //No reflection\n   color += light_Intensity * k_s * pow(dotRV ,alpha);\n   \n   \n   //Gamma correction\n   color = pow(color, vec3(2.2));\n   \n   return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 0) - r0);\n\n    float distance_traveled = 0.0;\n    \n    \n    //Ray marching\n    for(float i = 0.0; i < 255.; i++){\n        vec3 p = r0 + rd * distance_traveled;\n        \n        float d = dist_Function(p);\n        \n        distance_traveled += d; //March the ray\n        \n        if(distance_traveled > 100.0) break; //FOV\n        \n        if(d < EPS) break; //Resolution\n    }\n    \n    vec3 final_color;\n    if(distance_traveled < 100.)\n    {\n        final_color = phong_Model(r0 + rd * distance_traveled, vec3(cos(iTime), 10., 0. + sin(iTime)),\n                                    vec3(.5, .8, .5), vec3(0.8), vec3(1.), 10.);\n\n    }else\n    {\n        final_color = vec3(0.412, 0.741, 0.8);\n    }\n    \n    // Output to screen\n    fragColor = vec4(final_color, 1.0);\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}