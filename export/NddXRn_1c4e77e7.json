{"ver":"0.1","info":{"id":"NddXRn","date":"1632499747","viewed":389,"name":"Geometric Altar","username":"Flopine","description":"Trying the clean domain repetition presenting by Blackle on Perfect Pistons <3\nhttps://youtu.be/I8fmkLK1OKg\nhttps://www.shadertoy.com/view/WtXcWB","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","repetition","animation","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n\n// Trying the clean domain repetition \n// presenting by Blackle on Perfect Pistons <3\n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n#define PI acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x<0.)?-1.:1., 0.);\n    else return vec2(0., (p.y<0.)?-1.:1.);\n}\n\nfloat box (vec3 p , vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    vec2 center = floor(p.xz)+.5;\n    vec2 neighbour = center + edge(p.xz-center);    \n    float py = sin(length(center)+iTime)*1.5;\n    \n    float me = box(p-vec3(center.x, 0., center.y), vec3(.4,2.+py,.4))-.05;\n    float next = box(p-vec3(neighbour.x, 0., neighbour.y), vec3(.4, 3.5, .4))-.05;\n    float set = min(me,next);\n    \n    return set;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv*3.,-30.), rd=vec3(0.,0.1,1.),p=ro,\n    col=vec3(0.),l=normalize(vec3(1.,2.,-2.));\n\n    bool hit=false;\n    for (float i=0.; i<100.; i++)\n    {\n        float d= SDF(p);\n        if (d<0.001)\n        {hit=true;break;}\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,l)*.5+.5;\n        float ao = AO(0.1,p,n)+AO(0.35,p,n)+AO(0.75,p,n);\n        col = vec3(1.)*light*(ao/2.);\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}