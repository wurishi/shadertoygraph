{"ver":"0.1","info":{"id":"3df3zl","date":"1549887674","viewed":211,"name":"Ray refraction test","username":"mskr","description":"Visualizing a ray crossing a boundary of two materials with different refractive indices, and the refracted ray.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TRANSPARENT vec4(0)\n#define BLACK vec4(0,0,0,1)\n#define WHITE vec4(1)\n#define BLUE vec4(0,0,1,1)\n#define GREEN vec4(0,1,0,1)\n#define ORANGE vec4(1,.6,.3,1)\n\n// Drawing helpers\n\nvec4 drawPoint(vec2 p, vec3 point) {\n    const float SIZE = .014;\n    float d = SIZE - length(p - point.xy);\n    float a = smoothstep(.0, .005, d);\n    return mix(TRANSPARENT, WHITE, a);\n}\n\nvec4 drawVector(vec2 p, vec3 origin, vec3 vector) {\n    const float SIZE = 0.014;\n    float d = SIZE + dot(normalize(p-origin.xy), normalize(vector.xy)) - 1.0 - length(p-origin.xy) *.05;\n    float a = smoothstep(.0, .005, d);\n    return mix(drawPoint(p, origin), ORANGE, a);\n}\n\nvec4 drawPlane(vec2 p, vec3 middle, vec3 normal) {\n\t// sdf for a 2d cross section of the 3d plane\n    //TODO now crosssecting at z=0, make it variable\n    //TODO even better: show plane as checkerboard or grid\n    float d = abs(dot((p - middle.xy), normal.xy));\n    float a = smoothstep(.0, .009, .01-d);\n    return mix(TRANSPARENT, BLUE, a);\n}\n\nvec4 drawAngle(vec2 p, vec3 where, float angrad) {\n    vec2 ploc = p-where.xy;\n    float dcircle = length(ploc)-.014*3.;\n    float dring = abs(dcircle);\n    float polarCos = normalize(ploc).y;\n    float dang = angrad<3.14159265359? cos(angrad)-polarCos : polarCos-cos(angrad);\n    float dangmask = -ploc.x;\n    float d = min(dring, max(dcircle, angrad<3.14159265359? max(dang, dangmask) : min(dang, dangmask)));\n    return mix(GREEN, TRANSPARENT, smoothstep(.0, .005, d));\n}\n\n// An intersection routine for rays and planes\nfloat intersectPlane(vec3 pos, vec3 dir, vec3 middle, vec3 normal) {\n\tfloat a = dot(dir, normal);\n\tif (a > -1e-6) return -1.0; // facing away\n\tfloat b = dot(middle - pos, normal);\n    if (b > -1e-6) return -1.0; // behind plane\n\treturn b / a;\n}\n\nvec3 rotatePointAroundVector(float angle, vec3 vector, vec3 point) {\n    float cs = cos(angle), ics = 1.0 - cs, sn = sin(angle);\n    vec3 u = normalize(vector);\n    return vec3(\n        point.x * (cs+u.x*u.x*ics) + point.y * (u.x*u.y*ics-u.z*sn) + point.z * (u.x*u.z*ics+u.y*sn),\n        point.x * (u.y*u.x*ics+u.z*sn) + point.y * (cs+u.y*u.y*ics) + point.z * (u.y*u.z*ics-u.x*sn),\n        point.x * (u.z*u.x*ics-u.y*sn) + point.y * (u.z*u.y*ics+u.x*sn) + point.z * (cs+u.z*u.z*ics));\n}\n\n// Rotate p clockwise around origin\nvec2 rotate2D(vec2 p, float a) {\n    return vec2(\n        p.x * cos(a) - p.y * sin(a),\n        p.y * cos(a) + p.x * sin(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinate system\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Refractive indices\n    float n0=1.0, n1=1.47; // vacuum, oil\n\n    // A plane\n    vec3 middle=vec3(0.5, 0.5, 0.0), normal=normalize(vec3(0.0, 1.0, 0.0)); fragColor=drawPlane(uv, middle, normal);\n\n    vec3 p1=vec3(1.4, 0.9, 0.0), d1=normalize(vec3(-1.0, -1.0, 0.0)); fragColor+=drawVector(uv, p1, d1);\n    \n    vec3 p2=p1+d1*intersectPlane(p1, d1, middle, normal); fragColor+=drawPoint(uv, p2);\n    float cosIn=dot(normal, -d1); fragColor+=drawAngle(uv, p2, acos(cosIn));\n    float angOut=asin(n0/n1*sin(acos(cosIn))); fragColor+=drawAngle(rotate2D(uv,3.14), vec3(rotate2D(p2.xy,3.14),0), angOut);\n    vec3 d2=rotatePointAroundVector(acos(cosIn)-angOut, cross(normal,d1), d1);\n    fragColor+=drawVector(uv, p2, d2);\n}","name":"Image","description":"","type":"image"}]}