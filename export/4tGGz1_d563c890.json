{"ver":"0.1","info":{"id":"4tGGz1","date":"1472992243","viewed":124,"name":"Falling Through Hoops","username":"joe_thomas490","description":"Raymarching practice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Distance field functions found here : https://iquilezles.org/articles/distfunctions\n\n//-----------------Operation functions--------------------\n\n//Union operation (d1 + d2)\nfloat opU(float d1, float d2)\n{\n  \treturn min(d1,d2);   \n}\n\n//Subtraction operation (d1 - d2)\nfloat opS(float d1, float d2)\n{\n   return max(-d1,d2);   \n}\n\n//Intersection operation (only shows the primitives that intersect)\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n//Changes the colour based on it's distance from the camera\nfloat opFog(float p)\n{\n  return 1.0 / (1.0 * p * p * 0.25);   \n}\n\n//Repeats the primitive across the coordinate space (p = point along ray, c = dimensions of repetition)\nvec3 opRepeat(vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c) - 0.5 * c;\n    return q;\n}\n\n\n//-----------------Distance field functions--------------------\n\n//Distance field function for a sphere (p = point along ray, r = radius of sphere)\nfloat rSphere(vec3 p, float r)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n   \treturn length(q) - r;\n}\n\n//Distance field function for a rounded box (p = point along ray, d = dimensions of box, r = radius of roundness)\nfloat rRoundedBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    return length(max(abs(q)-b,0.0))-r;\n}\n\n//Distance field function for a torus primitive (p = point along ray, t = dimesions of torus (inner radius, outer radius))\nfloat rTorus(vec3 p, vec2 t)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    vec2 s = vec2(length(q.xz) - t.x,q.y);\n    return length(s)-t.y;\n}\n\n\n//-----------------Main functions--------------------\n\n//Main tracing function that maps the distances of each pixel\nfloat trace(vec3 ro, vec3 rt)\n{\n    float t = 0.0;\n    \n    //Loop through (in this case 32 times)\n    for(int i = 0; i < 32; ++i)\n    {\n        //Get the point along the ray\n        vec3 p = ro + rt * t;\n        \n        //Get the value for the distance field\n        \n        //float d = rSphere(p, (sin(iTime) + 1.0) * 0.25);\n        //float d = rRoundedBox(p, vec3(0.25,0.1,0.25), 0.1);\n        float d = rTorus(p, vec2(1.0,(sin(iTime)+ 1.25) * 0.1));\n        \n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Make the coordinate space between -1 and 1\n    uv = uv * 2.0 - 1.0;\n    \n    //Sort out the aspect ratio so the shapes aren't deformed\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Create the ray\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = 90.;\n        \n    r.yz *= mat2(cos(the),sin(the),-sin(the),cos(the));\n    \n    //Create where the ray is going towards\n    vec3 o = vec3(0.0, iTime + (sin(iTime)+1.0),0.0);\n    \n    //Call the main trace function and get a value\n    float t = trace(o,r);\n    \n    //Call the fogging function to apply some depth to the image\n    t = opFog(t);\n    \n    fragColor = vec4(t,0.0,0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}