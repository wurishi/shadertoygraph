{"ver":"0.1","info":{"id":"7lsyRH","date":"1647536622","viewed":94,"name":"Packing Industry","username":"RedWool","description":"Welcome","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Noise Algorithm but with negatives to make my life easier\nfloat noise(float t)\n{\n    return sin(sin(t*938.2)*92839.258);\n}\n\n//Create a simple box outline\nfloat box(vec2 uv, float s)\n{\n    return step(s, abs(uv.x)) * step(s, abs(uv.y));\n}\n\n//Subdivide sections\nfloat bricks(vec2 uv, vec2 p, float xt, float st)\n{\n    uv.y+=st*0.05;\n    uv *= p;\n    \n    float i = floor(uv.y);\n    uv.x += xt*(noise(i)*3.);\n    \n    uv = fract(uv);\n    \n    return box(uv, 0.1);\n}\n\n//Convert to polar form for circle appearence\nvec2 polar(vec2 uv)\n{\n    return vec2(atan(uv.y,uv.x)/3.1415926,distance(vec2(0.),uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.xy;\n    \n    //Convert to polar\n    //x is now the angle\n    //y is now the radii\n    uv = polar(uv);\n    \n    //p determines how many many boxes are in a ring, while creating \n    //two seperate type of rings\n    float p = sin(iTime*0.2+floor(uv.y*10.+iTime*4.)*91.393)*3.+4.;\n    float pct = bricks(uv, vec2(p, 10), iTime, (sin(iTime*0.5)*2.0)+iTime*2.);\n    \n    p = (p-1.)*0.16667;\n    \n    //Set Pixel size for black noise background\n    uv *= 100.;\n    \n    // Determine whether to be black background or rings\n    vec3 col = (pct*(mix(vec3(1.,0.4,0.4),vec3(0.8,0.6,0.4),p)))+\n    (1.-pct)*(vec3(noise(floor(uv.x)*floor(uv.y)-p*0.0001+iTime*0.000001)-0.6));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}