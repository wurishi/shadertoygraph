{"ver":"0.1","info":{"id":"stBXWt","date":"1632303596","viewed":177,"name":"Raymarching WaterScene","username":"Famousghost","description":"Simple water scene (Still in development)\nMy first project prepared via raymarching algorithm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingwaterreflectionphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 255\n#define MIN_DIST 0.005\n#define MAX_DIST 100.0\n#define START_VALUE 0.0\n\n#define M_PI 3.141592653589793238462643383279502884197169399375105820974944\n\n#define OCTAVES 5\n#define SCALE 8.0\n\n\nstruct MaterialValues\n{\n    vec3 ro;\n    vec3 rd;\n    vec3 normal;\n    float diffuse;\n    float specular;\n    vec3 p;\n};\n\nmat3 rotationeX(float angle)\n{\n    float a = radians(angle);\n    mat3 rX = mat3(vec4(1.0f, 0.0f, 0.0f, 0.0f),\n                   vec4(0.0f, cos(a), -sin(a), 0.0f),\n                   vec4(0.0f, sin(a), cos(a), 0.0f));\n                   \n    return rX;\n}\n\nmat3 rotationeY(float angle)\n{\n    float a = radians(angle);\n    mat3 rY = mat3(vec4(cos(a), 0.0f, sin(a), 0.0f),\n                   vec4(0.0f, 1.0f, 0.0f, 0.0f),\n                   vec4(-sin(a), 0.0f, cos(a), 0.0f));\n                   \n    return rY;\n}\n\nmat3 rotationeZ(float angle)\n{\n    float a = radians(angle);\n    mat3 rZ = mat3(vec4(cos(a), -sin(a), 0.0f, 0.0f),\n                   vec4(sin(a), cos(a), 0.0f, 0.0f),\n                   vec4(0.0f, 0.0f, 1.0f, 0.0f));\n                   \n    return rZ;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\n\treturn mat3(-cr, cu, -cd);\n}\n\n\nstruct Object\n{\n    float dist;\n    int materialId;\n};\n\nObject sdPlane( in vec3 p, in vec3 n, float h, int id)\n{\n  return Object(dot(p,n) + h, id);\n}\n\nObject sdBox( in vec3 p, in vec3 b , in vec3 offset, int id)\n{\n  vec3 q = abs(p - offset) - b;\n  return Object(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), id);\n}\n\n\nObject sdSphere(in vec3 p, in float radius, in vec3 offset, int id)\n{\n    return Object(length(p - offset) - radius, id);\n}\n\nObject minValue(in Object a, in Object b)\n{\n    if(a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nObject sdScene(in vec3 p)\n{\n    Object sphere1 = sdSphere(p, 1.0f, vec3(3.0f, 1.0f, 0.0f), 1);\n    Object sphere2 = sdSphere(p, 1.0f, vec3(-3.0f, 1.0f, -2.0f), 2);\n    Object res = minValue(sphere1, sphere2);\n    res = minValue(res, sdBox(p, vec3(1.0f, 1.0f, 2.0f), vec3(0.0f, 1.0f, 0.0f), 4));\n    res = minValue(res, sdPlane(p, vec3(0.0f, 1.0f, 0.0f), 1.0f, 3));\n    return res;\n}\n\nObject rayMarch(in vec3 ro, in vec3 rd)\n{\n    float depth = START_VALUE;\n    Object obj;\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ro + rd * depth;\n        obj = sdScene(p);\n        depth += obj.dist;\n        if(obj.dist < MIN_DIST || obj.dist > MAX_DIST)\n            break;\n    }\n    return Object(depth, obj.materialId);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    float e = 0.005f;\n    return normalize(\n                    vec3(\n                        sdScene(vec3(p.x + e, p.y, p.z)).dist - sdScene(vec3(p.x - e, p.y, p.z)).dist,\n                        sdScene(vec3(p.x, p.y + e, p.z)).dist - sdScene(vec3(p.x, p.y - e, p.z)).dist,\n                        sdScene(vec3(p.x, p.y, p.z + e)).dist - sdScene(vec3(p.x, p.y, p.z - e)).dist\n                    ));\n}\n\nfloat diff(in vec3 p, in vec3 normal, in vec3 lightPos)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    float diff = clamp(dot(lightDir, normal), 0.0f, 1.0f);\n    if((rayMarch(p + normal * MIN_DIST * 3.0f, lightDir)).dist < length(lightPos - p))\n    {\n        diff *= 0.5f;\n    }\n    return diff;\n}\n\nfloat spec(in vec3 p, in vec3 normal, in vec3 lightPos, in vec3 rd)\n{\n    vec3 lightRefl = reflect(normalize(lightPos - p), normal);\n    return pow(clamp(dot(lightRefl, rd), 0.0f, 1.0f), 32.0f);\n}\n\nvec3 materialColor(in int id, in vec3 backgroundColor, inout MaterialValues materialValues, in vec3 p, in vec3 normal, in vec3 lightPos, in vec3 rd)\n{\n    float phong = materialValues.diffuse + materialValues.specular;\n    vec3 refl = reflect(materialValues.rd, materialValues.normal);\n    vec3 col = texture(iChannel0, refl).rgb;\n    if(id == 1)\n    {\n        return vec3(1.0f, 0.0f, 0.0f) * col * phong;\n    }\n    if(id == 2)\n    {\n        return vec3(0.0f, 1.0f, 0.0f) * col * phong;\n    }\n    if(id == 3)\n    {\n        vec2 uv = materialValues.p.xz * 0.5f + 0.5f;\n        float time = iTime * 0.05f;\n        vec2 norm0 = texture(iChannel2, (uv / 5.0f + vec2(time, -time))).rr * 0.1f;\n        vec2 norm1 = texture(iChannel2, (uv / 5.0f + vec2(-time, time))).rr * 0.1f;\n        vec3 planeCol1 = texture(iChannel1, vec2(uv.x, uv.y) + norm0 * 2.0f).rgb;\n        vec3 planeCol2 = texture(iChannel1, vec2(-uv.x, uv.y) + norm1 * 2.0f).rgb;\n        vec3 planeColRes = planeCol1 + planeCol2;\n        vec3 col0 = texture(iChannel0, vec3(refl.x, refl.y, refl.z) + vec3(norm0.x, 0.0f, norm0.y) * 0.4f).rgb;\n        vec3 col1 = texture(iChannel0, vec3(refl.x, refl.y, refl.z) + vec3(-norm0.x, 0.0f, -norm0.y) * 0.4f).rgb;\n        vec3 distP = p + vec3(norm0.x, 0.0f, norm0.y);\n        float d = diff(distP, normal, lightPos);\n        float s = spec(distP, normal, lightPos, rd);\n\n        return vec3(1.0f, 1.0f, 1.0f) * planeColRes * clamp((col0 + col1) * 0.5f, 0.0f, 1.0f) * (d + s);\n    }\n    if(id == 4)\n    {\n        return vec3(1.0f, 1.0f, 1.0f) * col * phong;\n    }\n    return backgroundColor;\n}\n\nvec3 render(in int id, in vec3 backgroundColor, inout vec3 ro, inout vec3 rd, vec3 lightPos)\n{\n    Object obj = rayMarch(ro, rd);\n    if(obj.dist < MAX_DIST)\n    {\n        vec3 p = ro + rd * obj.dist;\n        vec3 normal = calcNormal(p);\n        float diffuse = diff(p, normal, lightPos);\n        float specular = spec(p, normal, lightPos, rd);\n        float phong = (diffuse + specular);\n        MaterialValues materialValues = MaterialValues(ro, rd, normal, diffuse, specular, p);\n        ro = p + normal * MIN_DIST * 3.0f;\n        rd = reflect(rd, normal);\n        return materialColor(obj.materialId, backgroundColor, materialValues, p, normal, lightPos, rd);\n    }\n    return backgroundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0f, 4.0f, 6.0f);\n    vec3 lp = vec3(0.0f, 1.5f, 0.0f);\n\n    \n    float cameraRadius = 8.0f;\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    ro.x = cameraRadius * sin(mouse.x * 2.0f * M_PI) + lp.x; // convert x-component to polar and add offset \n    ro.z = cameraRadius * cos(mouse.x * 2.0f * M_PI) + lp.z; // convert z-component to polar and add offset\n    \n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1.0f));\n\n    Object obj = rayMarch(ro, rd);\n    \n    vec3 backgroundColor = texture(iChannel0, rd).rgb; \n    \n    vec3 col = backgroundColor;\n    vec3 lightPos = vec3(2.0f, 8.0f, 5.0f);\n    col = render(obj.materialId, backgroundColor, ro, rd, lightPos);\n    \n    col += render(obj.materialId, backgroundColor, ro, rd, lightPos) * 0.1f;\n    \n    col += render(obj.materialId, backgroundColor, ro, rd, lightPos) * 0.1f;\n    \n    col += render(obj.materialId, backgroundColor, ro, rd, lightPos) * 0.1f;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}