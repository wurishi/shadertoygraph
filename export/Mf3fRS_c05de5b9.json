{"ver":"0.1","info":{"id":"Mf3fRS","date":"1733217386","viewed":95,"name":"My Christmas tree","username":"gest","description":" ","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float time;\n#define FAR 10.\n#define ID_NONE -1.\n\n#define ID_GROUND 0.\n#define ID_TRUNK 1.\n#define ID_BRANCH 2.\n#define ID_LEAF 3.\n#define ID_TINSEL 4.\n#define ID_STAR 5.\n#define ID_PRESENT_BOX 6.\n#define ID_PRESENT_LINE 7.\n#define ID_LAMP 8.\n\nfloat glowLamp = 0.;\nfloat glowStar = 0.;\n\nObject Presents(vec3 p) {\n\t\n\tTF_REPLICA_ANGLE(p.xz, 4., 0.);\n\tp.z -= 0.25;\n\tfloat sc = 0.07;\n\tp/= sc;\n\tObject object = Object(FAR, ID_NONE, p);\n\t{\n\t\tfloat d1 = TF_BOX_ROUND(p, 1., 0.5);\n\t\tfloat d2 = TF_CROSS_ROUND(p, 0.2, 0.1);\n\t\tfloat d = TF_ROUND(vec2(d1,d2), 0.1);\n\t\tobject.distance = d * sc;\n\t\tobject.id = d1<d2 ? ID_PRESENT_BOX : ID_PRESENT_LINE;\n\t}\n\treturn object;\n}\n\nObject Star(vec3 p) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_STAR, p);\n\t{\n\t\tTF_REPLICA_ANGLE(p.xy, 5., 0.);\n\t\td = TF_BALL(p.xz, 0.03 - 0.3*p.y);\n\t\tobject.distance = d*0.8;\n\t}\n\n\tglowStar += 1./pow(object.distance*(1000.), 2.-0.9);\n\t\n\treturn object;\n\t\n}\n\nObject Tree(vec3 p) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_NONE, p);\n\n\t//Фактор уменьшения размера ствола или веток в завизимости от высоты\n\tfloat f = TF_SMOOTHSTEP_BEFORE(p.y, 0., 1.5) - 0.01;\n\t\n\t//Ствол\n\tObject OBJ1 = Object(FAR, ID_TRUNK, p);\n\t{\n\t\td = AND(TF_BALL(p.xz, 0.03 * f), TF_BETWEEN2(p.y, 0., 1.5));\n\t\tOBJ1.distance = d;\n\t}\n\tobject = OR(object, OBJ1);\n\t\n\t//Винт из веток\n\tq = p;\n\tTF_REPLICA_SPIN_Y(q, 1., 0.0, 0.2, 11.);\n\t\n\t//Длина ветки\n\tfloat L = (0.6)*f;\n\t//Пространство между стволом и окончанием ветки\n\tfloat d_bet = TF_BETWEEN2(q.x, 0., L);\n\t\n\tObject OBJ2 = Object(FAR, ID_BRANCH, q);\n\t{\n\t\td = TF_BALL(q.yz, 0.005-q.x*0.005); //уменьшаем размер ветки\n\t\td = AND(d, d_bet);\n\t\td = AND(d, TF_BETWEEN2(p.y, 0.2, 1.5));\n\t\tOBJ2.distance = d;\n\t}\n\tobject = OR(object, OBJ2, 0.01);\n\n\t//Гирлянда\n\tObject OBJ3 = Object(FAR, ID_LAMP, q);\n\t{\n\t\td = OR(d, TF_BALL(q - vec3(L,0,0), 0.015));\n\t\td = AND(d, TF_BETWEEN2(p.y, 0.2, 1.3));\n\t\tOBJ3.distance = d;\n\t}\n\tobject = OR(object, OBJ3);\t\n\t\n\t//Винт из иголок вдоль веток\t\n\tq = q.yxz;\n\tTF_REPLICA_SPIN_Y(q, 1., 0.0, 0.06, 8.);\n\n\t//Иголки\n\tObject OBJ4 = Object(FAR, ID_LEAF, q);\n\t{\n\t\td = AND(TF_BALL(q.yz, 0.005), TF_BETWEEN2(q.x, 0., 0.04));\n\t\td = AND(d, d_bet);\n\t\td = AND(d, TF_BETWEEN2(p.y, 0.2, 1.5));\n\t\tOBJ4.distance = d;\n\t}\n\tobject = OR(object, OBJ4);\n\t\n\tglowLamp += 1./pow(OBJ3.distance*1000., 2.);\n\t\n\tif (object.id!=ID_NONE) object.distance *= 0.8;\n\n\treturn object;\t\n}\n\nObject Tinsel(vec3 p) {\n\tvec3 q;\n\tfloat d;\n\t\n\tObject object = Object(FAR, ID_TINSEL, p);\n\t{\n\t\tq = p;\n\t\t\n\t\tfloat R = 0.5 -abs(q.y)*0.5;\n\t\tfloat step = 0.15;\n\t\t\n\t\tTF_HELIX_Y(q, 2., R, step, 2.)\n\t\td = TF_BALL(q.xz, 0.006);\n\t\t\n\t\tTF_REPLICA(q.y, 2.*PI*R / 80.);\n\t\tTF_REPLICA_ANGLE(q.xz, 6., 0.);\n\t\tfloat d1 = AND(TF_BOXE(q.xy, 0.005), TF_BEFORE(q.z, 0.05));\n\t\td = min(d, d1);\n\t\td = AND(d, TF_BETWEEN2(p.y, -0.3, 1.1));\n\t\tobject.distance = d*0.5;\n\t}\n\treturn object;\n}\n\nfloat map( vec3 p, inout Object object ) {\n\t\n\tobject = Object(FAR, ID_NONE, p);\n\n\tobject = OR(object, Tree(p - vec3(0,-0.7,0)));\n\tobject = OR(object, Tinsel(p - vec3(0,-0.4,0)));\n\tobject = OR(object, Star(p - vec3(0,0.7,0)));\n\tobject = OR(object, Presents(p - vec3(0,-0.6,0)));\n\n    return object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal (vec3 p, float eps) {\n\tvec2 e = vec2 (eps, -eps);\n\tvec4 v = vec4 (\n\t\tmap (p + e.xxx), \n\t\tmap (p + e.xyy),\n\t \tmap (p + e.yxy), \n\t\tmap (p + e.yyx)\n\t);\n\treturn normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = abs(ray.object.distance) < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nstruct Material {\n\tvec3 color;\n\tfloat spec;\n};\n\nMaterial getMaterial(Ray ray) {\n\tMaterial m = Material(vec3(1), 0.1);\n\tif (ray.object.id==ID_GROUND) {\n\t\tm.color = vec3( 1, 0.9, 0.4);\n\t} else if (ray.object.id==ID_TRUNK) {\n\t\tm.color = vec3(0.5,0.1,0.0);\n\t} else if (ray.object.id==ID_BRANCH) {\n\t\tm.color = vec3(0.8,0.4,0.0);\n\t} else if (ray.object.id==ID_LEAF) {\n\t\tm.color = vec3(0.6,0.9,0.2);\n\t} else if (ray.object.id==ID_TINSEL) {\t\n\t\tm.color = vec3(1);\n\t\tm.spec = 1.;\n\t} else if (ray.object.id==ID_STAR) {\n\t\tm.color = vec3(0.8,0.2,0.2);\t\n\t\tm.spec = 0.5;\n\t} else if (ray.object.id==ID_PRESENT_BOX) {\n\t\tm.color = vec3(0,0.75,1.0);\t\n\t} else if (ray.object.id==ID_PRESENT_LINE) {\n\t\tm.color = vec3(1,0.75,0.8);\n\t} else if (ray.object.id==ID_LAMP) {\n\t\t//m.color = vec3 (1., 0.4, 0.2);\n\t\tm.color = vec3( .5, .7, .9 );\n\t}\n\treturn m;\n}\n\nvec3 lighting(Ray ray, vec3 lightDir, Material m) {\n\tfloat sh = 1.;\n\tfloat diff = max( dot( lightDir, ray.normal ), 0.);\n\tfloat spec = pow( max( dot( reflect(ray.direction, ray.normal), lightDir ), 0.), 128. );\n\treturn m.color * (0.3 + diff * 0.7 * sh)  + spec * m.spec * sh;\n}\n\nvec3 render(Ray ray) {\n    vec3 col;\n\n\trayMarch(ray);\n\n    if( ray.distance < FAR ) { \n        ray.normal = mapNormal( ray.position, 0.001);\n\t\tMaterial m = getMaterial(ray);\n\t\t\n\t\tvec3 lightDir = -ray.direction;\n\t\tcol = lighting(ray, lightDir, m);\n    } else {\n        col = vec3( .5, .7, .9 );\n    }\n\t\n\tfloat glowPeriod;\n\tTF_TIMER(time, 2., 1., glowPeriod);\n\tcol += glowPeriod * glowLamp * vec3 (1., 0.4, 0.2);\n\tcol += (1.-glowPeriod) * glowStar * vec3 (0.5, 0.0, 0.0);\n\treturn col;\n}\n\nvoid main() {\n\ttime = u_time;\n\t\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv*2. - 1.;\n\n\tvec2 mouse = u_mouse.xy / u_canvas.xy - 0.5;\n\tif (u_mouse.xy==vec2(0)) mouse = vec2(0);\n\n\tvec2 ori = vec2(\n\t\tu_mouse.z==0. ? radians(-00.) : mouse.y*PI*2.,\n\t\tu_mouse.z==0. ? 0.0*time : mouse.x*PI*2.\n\t);\n\n\t#if 1\n\t\tori.x = clamp(ori.x, -PI/2., PI/2.);\n\t#else\n\t\tori.x = clamp(ori.x, -radians(20.), radians(20.));\n\t#endif\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\t//cam.origin  = vec3( 0, 0.0, -2.2);\n\t\tcam.origin  = vec3( cos(time*0.5) + 0., 0.5*sin(time*0.1), sin(time*0.25)*2. );\n\t\tcam.target  = vec3( 0, cam.origin.y, 0. );\n\t\tcam.up \t\t= vec3(0,1,0);\n\t\tcam.vMat \t= mat3(1);//TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t\tcam.mMat\t= mat3(1);//TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t}\n\t\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 150.;\n\t}\n\tvec3 ro = ray.origin;\n\tvec3 rd = ray.direction;\n\n    vec3 col = render(ray);\n    \n    gl_FragColor = vec4( col, 1. );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define textureCube texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n\t#define u_textureCube0 iChannel0\n\t#define u_textureCube1 iChannel1\n#endif\n\n\n//#define SUPER_GRAPHIC_CARD\n\n#ifdef SUPER_GRAPHIC_CARD\n\t#define SOFT_SHADOW\n\t#define MODEL_HARD\n#endif\n\nconst float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\tmat3 vMat, mMat;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n\tmat3 pMat, uMat;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 \tposition;\t//Координатв поверхности объекта\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//\"+\" -колебание в найденной точке, \"-\"\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor\t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right*cam.aspect + uv.y * cam.up;\n\tcam.pMat \t\t= mat3(cam.right, cam.up, cam.forward);\n\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.mMat * cam.origin;\n\t\tray.direction \t= cam.mMat * normalize( cam.pMat * cam.vMat * vec3(uv.x*cam.aspect, uv.y, cam.factor));\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов) 1./min(u_canvas.x, u_canvas.y)\nfloat EPS = 0.01;\n//Скругление по верхней границе\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)\n#define TF_BOX_ROUND1(p, S, R) TF_ROUND(abs(p)-(S) + R, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_BOX_ROUND(p, S, 0.)\n#define TF_BOX1(p, S) TF_BOX_ROUND(p, S, EPS)\n#define TF_BOXE(p, S) TF_BOX_ROUND(p, S - EPS, EPS)\n#define TF_BOX3D(p, S) max(abs((p).x)-vec3(S).x, max(abs((p).y)-vec3(S).y, abs((p).z)-vec3(S).z))\n#define TF_BOX2D(p, S) max(abs((p).x)-vec2(S).x, abs((p).y)-vec2(S).y)\n#define TF_BOX3D_SD(p, S) TF_BOX(p, S) + min(TF_BOX3D(p, S), 0.)\n#define TF_BOX2D_SD(p, S) TF_BOX(p, S) + min(TF_BOX2D(p, S), 0.)\n\n//Скругление по нижней границе\n#define TF_ROUND_MIN(d, R) (-length(min(d, 0.)) + (R))\n#define TF_CROSS_ROUND(p, S, R) TF_ROUND_MIN(abs(p)-(S), R)\n#define TF_CROSS(p, S) TF_CROSS_ROUND(p, S, 0.)\n#define TF_CROSS3D(p, S) min(abs((p).x)-vec3(S).x, min(abs((p).y)-vec3(S).y, abs((p).z)-vec3(S).z))\n#define TF_CROSS2D(p, S) min(abs((p).x)-vec2(S).x, abs((p).y)-vec2(S).y)\n#define TF_CROSS3D_SD(p, S) TF_CROSS(p, S) + max(TF_CROSS3D(p, S), 0.)\n#define TF_CROSS2D_SD(p, S) TF_CROSS(p, S) + max(TF_CROSS2D(p, S), 0.)\n\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Эллипс\n#define TF_ELLIPSE3D(p, r) min ((r).x, min((r).y, (r).z)) * TF_BALL((p)/(r), 1.)\n#define TF_ELLIPSE2D(p, r) min ((r).x, (r).y) * TF_BALL((p)/(r), 1.)\n//Отрезок от a до b радиусом r\n#define TF_SEGMENT(p, a, b, r) TF_BALL((p)-(a) - ((b)-(a)) * clamp( dot((p)-(a),(b)-(a))/dot((b)-(a),(b)-(a)), 0.0, 1.0 ), r)\n\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) (p - (p1))\n#define TF_BEFORE_EPS(p, p1) TF_ROUND(p - (p1) + EPS, EPS)\n//Функция расстояния до пространства ДО normal с отступом p1\n#define TF_BEFORE_PLANE(p, normal, off) dot(p, normal) - (off)\n//Функция расстояния до пространства ДО p.x c предварительным вращением плоскости p.xy на угол ang и последующим отступом off\n#define TF_BEFORE_ROTATE(p, ang, off) dot((p).xy, cos ((ang) + vec2 (0, 0.5 * PI))) - (off)\n\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) (-p + (p1))\n#define TF_AFTER_EPS(p, p1) TF_ROUND(-p + (p1) + EPS, EPS)\n//Функция расстояния до пространства ПОСЛЕ normal с отступом p1\n#define TF_AFTER_PLANE(p, normal, off) dot(-p, normal) + (off)\n//Функция расстояния до пространства ПОСЛЕ p.x c предварительным вращением плоскости p.xy на угол ang и последующим отступом off\n#define TF_AFTER_ROTATE(p, ang, off) dot((-p).xy, cos ((ang) + vec2 (0, 0.5 * PI))) + (off)\n\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n//#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)\n#define TF_BETWEEN(p, p1) (abs(p) - (p1))\n#define TF_BETWEEN_EPS(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n//#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1) + EPS, EPS)\n#define TF_BETWEEN2(p, p1, p2) (abs(p - 0.5*((p1)+(p2))) - 0.5*((p2)-(p1)))\n//Функция расстояния до симметричного пространства МЕЖДУ двумя симметричными нормалями толщиной off\n#define TF_BETWEEN_PLANE(p, normal, off) AND(TF_AFTER_PLANE(p, normal, -off), TF_BEFORE_PLANE(p, normal, off))\n//Функция расстояния до симметричного пространства МЕЖДУ двумя симметричными нормалями толщиной off\n#define TF_BETWEEN_ROTATE(p, ang, off) AND(TF_AFTER_ROTATE((p).xy, ang, -0.5*off), TF_BEFORE_ROTATE((p).xy, ang, 0.5*off))\n\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Масштаб\n#define TF_SCALE(p, s) p /= s\n//Преобразование в цилиндрическую систему координат\n#define TF_CYL(p, R) p = vec2((R)*atan(p.x,p.y), TF_BALL(p.xy, R))\n\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n#define TF_ROTATE_MAT2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TF_ROTATE_X(a) mat3(1.0,    0.0, 0.0,       0.0, cos(a), -sin(a),   0.0, sin(a), cos(a))\n#define TF_ROTATE_Y(a) mat3(cos(a), 0.0, -sin(a),   0.0, 1.0, 0.0,   \t    sin(a), 0.0, cos(a))\n#define TF_ROTATE_Z(a) mat3(cos(a), -sin(a), 0.0,   sin(a), cos(a), 0.0,   \t0.0, 0.0, 1.0)\n#define TF_ROTATE_X_90(p) p.xyz = p.xzy\n#define TF_ROTATE_Y_90(p) p.xyz = p.zyx\n#define TF_ROTATE_Z_90(p) p.xyz = p.yxz\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - (d)\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = mod((p) + 0.5*(d), d) - 0.5*(d)\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), ida, idb)\n#define TF_REPLICA_LIMIT_MIRROR(p, d, id) \\\n\tfloor((p=p-0.5*(d))/(d) + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), -id, id-1.)\n\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p в полярной системе координат\n//Возвращает id сектора\t\n#define TF_REPLICA_ANGLE_POLAR(p, n, off)\\\n\tfloor(mod(atan(p.x, p.y) + off + PI /(n), 2.*PI)/(2.*PI/(n)));\\\n\tp = vec2(atan(p.x, p.y) + off, length(p.xy));\\\n\tp.x = mod(p.x + 0.5*(2.*PI/(n)), (2.*PI/(n))) - 0.5*(2.*PI/(n))\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p в декартовой системе координат\n//Возвращает id сектора\t\n#if 1\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + off + PI /(n), 2.*PI)/(2. * PI/(n)));\\\n\t\tTF_ROTATE(p.xy, -off + (2.*PI/(n)) * floor(mod(atan(p.x, p.y) + off + PI /(n), 2.*PI)/(2.*PI/(n))))\n#else\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tTF_REPLICA_ANGLE_POLAR(p, n, off);\\\n\t\tp = p.y * vec2(sin(p.x), cos(p.x))\n#endif\n\n//Преобразование пространства в винт радиусом R с числом заходов n с шагом step и с закручиванием вдоль спирали nRot\n#define TF_HELIX_Y(p, n, R, step, nRot)\\\n\tTF_CYL(p.xz, R);\\\n\t{\\\n\t\tfloat a = floor(n)*p.x/(R)/(2.*PI);\\\n\t\tTF_TRANSLATE(p.y, (step)*a);\\\n\t\tTF_REPLICA(p.y, (step));\\\n\t\tTF_ROTATE(p.yz, (nRot) * PI * a);\\\n\t}\\\n\tp = p.zxy;\n\n//Преобразование пространства в псевдовинт радиусом R, с числом заходов n, с шагом step и с числом секторов на один оборот sect\n#define TF_REPLICA_SPIN_Y(p, n, R, step, sect) \\\n\t{\\\n\t\tfloat a = atan(p.x, p.z)/(2.*PI);\\\n\t\tp.y -= a * (n) * (step);\\\n\t\tTF_REPLICA(p.y, step);\\\n\t\tTF_REPLICA_ANGLE(p.xz, sect, 0.);\\\n\t\tp.z -= R;\\\n\t}\\\n\tp = p.zxy;\n\t\t\n\n//По p2.xy формирует координату винта c числом заходов n вдоль p1 с шагом step \n#define TF_REPLICA_SPIN(p1, p2, n, step) \\\n\tp1 -= (atan((p2).x,(p2).y)/(2. * PI))*(n)*(step);\\\n\tTF_REPLICA(p1, (step))\n#define TF_REPLICA_SPIN_LIMIT(p1, p2, n, step, ida, idb) \\\n\tp1 -= (atan((p2).x,(p2).y)/(2. * PI))*(n)*(step);\\\n\tTF_REPLICA_LIMIT(p1, (step), ida, idb)\n\n//Формирование в плоскости p.xy n ветвей равномерной бесконечной спирали.\n//Возвращает в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL(p, n, k)\\\n\t\tlength(p.xy);\\\n\t\t{\\\n\t\t\tvec2 p0 = p.xy;\\\n\t\t\tp.y = atan(p.x,p.y)*(n)/(2.*PI);\\\n\t\t\tp.x = p.y - (k) * length(p0.xy);\\\n\t\t\tp.x += -floor(p.x + 0.5);\\\n\t\t}\n#else\n\t#if 1\n\t\t#define TF_SPIRAL(p, n)\\\n\t\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - length(p.xy) - 0.5;\\\n\t\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n\t#else\n\t\t#define TF_SPIRAL(p, n)\\\n\t\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n\t#endif\n#endif\n//Формирование в плоскости p.xy n ветвей равномерной спирали с ограничением количества витков \n//Возвращает в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL_LIMIT(p, n, k, ida, idb)\\\n\t\tlength(p.xy);\\\n\t\t{\\\n\t\t\tvec2 p0 = p.xy;\\\n\t\t\tp.y = atan(p.x,p.y)*(n)/(2.*PI);\\\n\t\t\tp.x = p.y - (k) * length(p0.xy);\\\n\t\t\tp.x += clamp(-floor(p.x + 0.5), ida, idb);\\\n\t\t}\n#else\n\t#if 1\n\t\t#define TF_SPIRAL_LIMIT(p, n, ida, idb)\\\n\t\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - length(p.xy) - 0.5;\\\n\t\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n\t#else\n\t\t#define TF_SPIRAL_LIMIT(p, n, ida, idb)\\\n\t\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n\t#endif\n#endif\n//Формирование в плоскости p.xy n ветвей расширяющейся бесконечной спирали.\n//Возвращает масштаб для корректировки профиля и в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL_LOG(p, n, k)\\\n\t\tlength(p.xy);\\\n\t\t{\\\n\t\t\tvec2 p0 = p.xy;\\\n\t\t\tp.y = atan(p.x,p.y)*(n)/(2.*PI);\\\n\t\t\tp.x = p.y - (k) * log(length(p0.xy));\\\n\t\t\tp.x += -floor(p.x + 0.5);\\\n\t\t}\n#else\n\t#if 1\n\t\t#define TF_SPIRAL_LOG(p, n)\\\n\t\t\tlength(p.xy);\\\n\t\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - log(length(p.xy)) - 0.5;\\\n\t\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n\t#else\n\t\t#define TF_SPIRAL_LOG(p, n)\\\n\t\t\tlength(p.xy);\\\n\t\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\t\t\tp.y = log(p.y);\\\n\t\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\t\tp.x -= 1. * floor(p.x/1. + 0.5)\n\t#endif\n#endif\n//Формирование в плоскости p.xy n ветвей расширяющейся спирали с ограничением количества витков.\n//Возвращает масштаб для корректировки профиля и в p.x расстояние до спирали.\n#if 1\n\t#define TF_SPIRAL_LOG_LIMIT(p, n, k, ida, idb)\\\n\t\tlength(p.xy);\\\n\t\t{\\\n\t\t\tvec2 p0 = p.xy;\\\n\t\t\tp.y = atan(p.x,p.y)*(n)/(2.*PI);\\\n\t\t\tp.x = p.y - (k) * log(length(p0.xy));\\\n\t\t\tp.x += clamp(-floor(p.x + 0.5), ida, idb);\\\n\t\t}\n#else\n\t#if 1\n\t\t#define TF_SPIRAL_LOG_LIMIT(p, n, ida, idb)\\\n\t\t\tlength(p.xy);\\\n\t\t\tp.x = atan(p.x,p.y)*(n)/(2.*PI) - log(length(p.xy)) - 0.5;\\\n\t\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n\t#else\n\t\t#define TF_SPIRAL_LOG_LIMIT(p, n, ida, idb)\\\n\t\t\tlength(p.xy);\\\n\t\t\tp.xy = vec2(atan(p.x,p.y), length(p.xy));\\\n\n\t\t\tp.y = log(p.y);\\\n\t\t\tp.x = p.x*(n)/(2.*PI) - p.y - 0.5;\\\n\t\t\tp.x -= 1. * clamp(floor(p.x/1. + 0.5), ida, idb);\n\t#endif\n#endif\n\n//Преобразует пространство p в n сферических сегментов. Возырвщвет id сегментв \n#define TF_REPLICA_ANGLE_SPHERIC(p, nx, nz, id)\\\n\tp = vec3( atan (p.x, p.z)*(nx)/(2. * PI), length (p), asin (p.y / length (p))*(nz)/PI );\\\n\tif (mod(nz, 2.)==0.) p.z -= 0.5;\\\n\tid = TF_REPLICA(p.xz, 1.)\n\n//------------------------------------------------------------------------------------------------------\n//Возвращает 0 или 1 в зависимоти от знячения p относительно a или b\n//Операция ИЛИ(OR) \t: step1 + step2 (сложение)\n//Операция И(AND) \t: step1 * step2 (умножение)\n//Операция NOT \t\t: 1. - step\n//------------------------------------------------------------------------------------------------------\n//Возвращает 1 если p > a\n//    1-----\n//    |\n//    |\n//----0\n//    a\n#define TF_STEP_AFTER(p, a) step(a, p)\n\n//Возвращает 1 если p < a\n//----1\n//    |\n//    |\n//    0-----\n//    a\n#define TF_STEP_BEFORE(p, a) step(p, a)\n\n//Возвращает 1 если -a < p < a\n//    1------1\n//    |      |\n//    |      |\n//----0      0--------\n//   -a      +a\n#define TF_STEP_BETWEEN(p, a) TF_STEP_BEFORE(abs(p), a)\n//Возвращает 1 если a < p < b\n//    1------1\n//    |      |\n//    |      |\n//----0      0--------\n//    a      b\n#define TF_STEP_BETWEEN2(p, a, b) TF_STEP_AFTER(p, a)*TF_STEP_BEFORE(p, b)\n\n//------------------------------------------------------------------------------------------------------\n//Возвращает 0 или 1 в зависимоти от знячения p относительно a или b со сглаживанием [-0.5*eps, 0.5*eps]\n//Операция ИЛИ(OR) \t: smoothstep1 + smoothstep2 (сложение)\n//Операция И(AND) \t: smoothstep1 * smoothstep2 (умножение)\n//Операция NOT \t\t: 1. - smoothstep\n//------------------------------------------------------------------------------------------------------\n//Возвращает \n//\t0 если p < a-eps/2; \n//\t1 если p > a+eps/2;\n//  сглаживание от 0 до 1  между a-0.5*eps и a+0.5*eps\n//        1-----\n//       /      \n//      /       \n//     /        \n//----0         \n//    |eps|\n//      a \n//\n//        1-----\n//       /      \n//      /       \n//     /        \n//----0         \n//    a   b \n//      \n#define TF_SMOOTHSTEP_AFTER_EPS(p, a, eps) smoothstep(a-0.5*eps, a+0.5*eps, p)\n#define TF_SMOOTHSTEP_AFTER(p, a, b) smoothstep(a, b, p)\n//Возвращает \n//\t1 если p < a-eps/2; \n//\t0 если p > a+eps/2;\n//  сглаживание от 1 до 0  между a-eps/2 и a+eps/2\n//-----1\n//      \\\n//       \\\n//        \\\n//         0------\n//     |eps|\n//       a \n//\n//-----1\n//      \\\n//       \\\n//        \\\n//         0------\n//    a    b \n//       \n#define TF_SMOOTHSTEP_BEFORE_EPS(p, a, eps) (1.-smoothstep(a-0.5*eps, a+0.5*eps, p))\n#define TF_SMOOTHSTEP_BEFORE(p, a, b) (1.-smoothstep(a, b, p))\n\n//Возвращает \n//\t1 если p > -a+eps/2  и  p < a-eps/2; \n//\t0 если p < -a-eps/2 или p > a+eps/2; \n//  сглаживание от 0 до 1  между -a-eps/2 и -a+eps/2\n//  сглаживание от 1 до 0  между  a-eps/2 и  a+eps/2\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//    |eps|     |eps|\n//     -a         +a\n//\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//   -b  -a    +a  +b\n//\n#define TF_SMOOTHSTEP_BETWEEN_EPS(p, a, eps) TF_SMOOTHSTEP_BEFORE_EPS(abs(p), a, eps)\n#define TF_SMOOTHSTEP_BETWEEN(p, a, b) TF_SMOOTHSTEP_BEFORE(abs(p), a, b)\n//Возвращает \n//\t1 если p > a+eps/2  и  p < b-eps/2; \n//\t0 если p < a-eps/2 или p > b+eps/2; \n//  сглаживание от 0 до 1  между a-eps/2 и a+eps/2\n//  сглаживание от 1 до 0  между b-eps/2 и b+eps/2\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//    |eps|     |eps|\n//      a         b\n//\n//        1-----1\n//       /       \\\n//      /         \\\n//     /           \\\n//----0             0------\n//   a1   b1    a2  b2\n//\n#define TF_SMOOTHSTEP_BETWEEN2_EPS(p, a, b, eps) TF_SMOOTHSTEP_AFTER_EPS(p, a, eps)*TF_SMOOTHSTEP_BEFORE_EPS(p, b, eps)\n#define TF_SMOOTHSTEP_BETWEEN2(p, a1, b1, a2, b2) TF_SMOOTHSTEP_AFTER(p, a1, b1)*TF_SMOOTHSTEP_BEFORE(p, a2, b2)\n\n//Возвращает значени для uv0 и в intervalId номер отрезка времени 0,1,2... для момента u_time\n//                -------\n//               |\n//        -------\n//       |\n//-------\n//   0       1       2\n#define TF_TIMER(u_time, intervalCount, intervalDuration, intervalId) \\\n\tmod(u_time, intervalDuration*intervalCount)/(intervalDuration*intervalCount);\\\n\tintervalId = mod(floor(u_time/(intervalDuration)), (intervalCount))\n//Выводит диаграмму процесса\n#define TF_TIMER_VIEW(col, pix, uv0_value) \\\n\t{\\\n\t\tvec2 uv0 = gl_FragCoord.xy/u_canvas.xy;\\\n\t\tif (uv0.y<pix/u_canvas.y && uv0.x<uv0_value) col = vec3(1,0,0);\\\n\t}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn min(distA, distB);\n\t//if (distB<distA) return distB; return distA;\n\t//return mix(distA, distB, step(distB, distA)); \n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn max(distA, distB);\n\t//if (distB>distA) return distB; return distA;\n\t//return mix(distA, distB, step(distA, distB)); \n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\n\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\n#if 0\n\tfloat AND( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) + k*h*(1.-h);\n\t}\n#else\n\tfloat AND( float distA, float distB, float k ) {\n\t\treturn - OR (- distA, - distB, k);\n\t}\n#endif\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n\n//Сложение / Объединение / ИЛИ\n//object = OR(objectA, objectB)\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Сложение / Объединение / ИЛИ  \n//object = OR(objectA, objectB, k)\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Умножение / Пересечение / И\n//object = AND(objectA, objectB)\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Умножение / Пересечение / И\n//object = AND(objectA, objectB, k)\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\n//object = NOT(objectA)\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}