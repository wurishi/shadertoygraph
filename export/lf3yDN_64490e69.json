{"ver":"0.1","info":{"id":"lf3yDN","date":"1730661051","viewed":59,"name":"Julia Set (supersampling)","username":"zubetto","description":"Visualization of the Julia sets using supersampling. You can zoom using the mouse (zooming is controlled by horizontal mouse movement while holding down the left mouse button).\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","math","mandelbrot","zoom","supersampling","complex"],"hasliked":0,"parentid":"M3jfzd","parentname":"Mandelbrot Set (supersampling)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // PARAMETERS : Initial region of the complex plane\n    vec2 regionMin = vec2(-2.0, -1.15);\n    float rangeRe = 4.0; // the range of real numbers\n    \n    // Initial region of the complex plane\n    float rangeIm = rangeRe * (iResolution.y / iResolution.x);\n    vec2 ratioXtoU = vec2(rangeRe, rangeIm); \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 viewportUV = fragCoord / iResolution.xy;\n    \n    // Normalized pixel coordinates after zooming\n    ZoomData currentZoom;\n    fetchZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom);\n    \n    vec2 zoomedUV = zoomUV(currentZoom, viewportUV);\n    vec2 ratioDXtoDU = currentZoom.scale * ratioXtoU;  \n    \n    // Complex number corresponding to normalized pixel coordinates\n    vec2 z1 = zoomedUV * ratioXtoU + regionMin;\n    \n    // PARAMETERS : setting c for the quadratic polinomial z^2 + c\n    vec2 cInitial = absArgDeg2complex(0.75, 155.0);\n    float cAbsTimeRate = 0.0;\n    float cArgTimeRate = 1.0 / 10.0; // degrees per second;\n    \n    // animating c\n    float cAbsInitial = sqrt(complexAbsSq(cInitial));\n    float cArgInitial = complexArgDeg(cInitial);\n    float cAbs = cAbsInitial + cAbsTimeRate * iTime;\n    float cArgDeg = cArgInitial + cArgTimeRate * iTime;\n    vec2 c = absArgDeg2complex(cAbs, cArgDeg);\n    \n    // PARAMETERS : Number of iterations\n    vec2 numIters = vec2(400.0, 2000.0); // at min and max zoom levels\n    float maxZoom = 50.0 * 1000.0; // min zoom level is assumed to be 1\n    \n    // dAlphaMax defines the max difference in tone (color) in a pixel;\n    // has effect only if the number of samples per pixel is greater than one\n    float dAlphaMax = 0.1; \n    \n    // Number of iterations\n    float itersAlpha = linearStep(1.0, maxZoom, 1.0 / currentZoom.scale);\n    itersAlpha = pow(itersAlpha, 0.5);\n    int numIterations = int(mix(numIters.x, numIters.y, itersAlpha));\n    int maxGap = int(dAlphaMax * float(numIterations)); // max difference in the number of iterations in a pixel\n    \n    // the closer alpha to 0, the faster the sequence corresponding to z1 diverges\n    float alpha = JuliaAlphaSS(c, z1, ratioDXtoDU, iResolution.xy, numIterations, maxGap);\n    \n    // PARAMETERS : colors for rendering alpha values\n    vec3 colorA = hsv2rgb(vec3(120.0 / 360.0, 0.85, 0.25));\n    vec3 colorB = hsv2rgb(vec3(60.0 / 360.0, 0.2, 1.0));\n    vec3 colorC = hsv2rgb(vec3(20.0 / 360.0, 0.5, 0.25));\n    vec3 colorM = mix3colors(colorA, colorB, colorC, 0.33, alpha);\n    \n    // Output to screen\n    fragColor = vec4(colorM, 1.0);\n    \n    //-------------------------------------------------------------------------------------\n    // Diagnostics and debug\n    float h = 1.0 / (50.0 * 1000.0);\n    vec3 zoomBarBack = hsv2rgb(vec3(220.0 / 360.0, 0.25, 0.25));\n    vec3 zoomBarFore = hsv2rgb(vec3(220.0 / 360.0, 1.0, 1.0));\n    vec3 zoomBarColor = mix(zoomBarBack, zoomBarFore, step(viewportUV.y, h / currentZoom.scale));\n    float zoomBarAlpha = 0.5 * step(0.95, viewportUV.x);\n    \n    fragColor = mix(fragColor, vec4(zoomBarColor, 1.0), zoomBarAlpha);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// MATH : CONSTANTS //////////////////////////////////\nconst float pi = acos(-1.0);\nconst float MR = 2.0;\nconst float MRSQ = MR * MR;\n\n// MATH : COMPLEX NUMBERS : PURE FUNCTIONS //////////\nvec2 absArg2complex(float r, float arg)\n{\n    return r * vec2(cos(arg), sin(arg));\n}\n\nvec2 absArgDeg2complex(float r, float arg)\n{\n    return absArg2complex(r, (pi / 180.0) * arg);\n}\n\nvec2 complexMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 complexConj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nfloat complexArgDeg(vec2 a)\n{\n    return (180.0 / pi) * atan(a.y, a.x);\n}\n\nfloat complexAbsSq(vec2 a)\n{\n    return complexMul(a, complexConj(a)).x;\n}\n\nvec2 MandelbrotIterator(vec2 c, vec2 z, float threshold, int n, out int i)\n{\n    float h = threshold * threshold;\n    \n    for (i = 0; i < n; ++i)\n    {\n        if (complexAbsSq(z) >= h)\n            break;\n        \n        z = complexMul(z, z) + c;\n    }\n    \n    return z;\n}\n\n// GENERAL : PURE FUNCTIONS //////////\nfloat linearStep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// SUPERSAMPLING : CONSTANTS ///////////////////////////////////////\nconst int SS_NUM = 5;\n\n// Offsets are specified relative to a pixel (fragment) center as a fraction of the pixel size;\n// an entry with zero or minimum offset must be the array element with index 0;\nconst vec3 SS_OFFSETS_WEIGHTS[SS_NUM] = vec3[]\n(\n    vec3( 0.00,  0.00, 4.0), // {pixelOffsetU, pixelOffsetV, sampleWeight}\n    vec3(-0.25, -0.25, 1.0), \n    vec3(-0.25,  0.25, 1.0),\n    vec3( 0.25,  0.25, 1.0),\n    vec3( 0.25, -0.25, 1.0)\n);\n\n// SUPERSAMPLING : STRUCTURES ///////////////////////////////////////\nstruct SampleData\n{\n    bool isActive;\n    vec2 z;\n    vec2 absSq;\n    int numIterations;\n    float weight;\n};\n\n// SUPERSAMPLING : FUNCTIONS ///////////////////////////////////\n\nfloat ssTotalWeight()\n{\n    float sum = 0.0;\n    \n    for (int i = 0; i < SS_NUM; ++i)\n        sum += SS_OFFSETS_WEIGHTS[i].z;\n    \n    return sum;\n}\n\nSampleData[SS_NUM] iniSampleData(vec2 z1, vec2 uvScale, vec2 resolution)\n{\n    float pixelSideLength = uvScale.x / resolution.x;\n    SampleData sdata[SS_NUM];\n    \n    for (int i = 0; i < SS_NUM; ++i)\n    {\n        vec3 ow = SS_OFFSETS_WEIGHTS[i];\n        vec2 z1offset = z1 + pixelSideLength * ow.xy;\n        \n        sdata[i] = SampleData(true, z1offset, vec2(0.0, 0.0), 1, ow.z);\n    }\n    \n    return sdata;\n}\n\nfloat JuliaAlphaSS(vec2 c, vec2 z1, vec2 uvScale, vec2 resolution, int maxNum, int maxGap)\n{\n    SampleData sdataArr[SS_NUM] = iniSampleData(z1, uvScale, resolution);\n    \n    int minIteration = 2 * maxNum;\n    int i = 1;\n    \n    for ( ; i < maxNum; ++i)\n    {\n        bool noActiveSamples = true;\n        \n        for (int j = 0; j < SS_NUM; ++j)\n        {\n            SampleData sdata = sdataArr[j];\n            \n            if (sdata.isActive)\n            {\n                sdata.numIterations = i;\n                sdata.z = complexMul(sdata.z, sdata.z) + c;\n                float zAbsSq = complexAbsSq(sdata.z);\n                \n                if (zAbsSq > MRSQ)\n                {\n                    sdata.isActive = false;\n                    sdata.absSq.y = zAbsSq;\n                    \n                    minIteration = i < minIteration ? i : minIteration;\n                }\n                else\n                {\n                    noActiveSamples = false;\n                    sdata.absSq.x = zAbsSq;\n                }\n                \n                sdataArr[j] = sdata;\n                \n            } // end if (sdata.isActive)\n        }\n        \n        if (noActiveSamples || (i - minIteration) > maxGap)\n            break;\n    }\n    \n    float alpha;\n    \n    if (i == minIteration)\n    {\n        vec2 belowAbove = sqrt(sdataArr[0].absSq);\n        alpha = (MR - belowAbove.x) / (belowAbove.y - belowAbove.x) + float(i - 1);\n    }\n    else\n    {\n        float wsum = 0.0;\n        \n        for (int j = 0; j < SS_NUM; ++j)\n            wsum += sdataArr[j].weight * float(sdataArr[j].numIterations);\n        \n        alpha = wsum / ssTotalWeight();\n    }\n    \n    return alpha / float(maxNum);\n}\n\n// COLOR : PURE FUNCTIONS //////////////////////////////////////////\n\n// source: https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 complex2rgb(vec2 z, float maxAbs)\n{\n    float h = complexArgDeg(z) / 360.0;\n    float v = clamp(sqrt(complexAbsSq(z)) / maxAbs, 0.0, 1.0);\n    \n    return hsv2rgb(vec3(h, 1.0, v));\n}\n\nvec3 mix3colors(vec3 color0, vec3 colorMid, vec3 color1, float midAlpha, float alpha)\n{\n    bool isInFirstHalf = alpha < midAlpha;\n    \n    vec3 colorA = isInFirstHalf ? color0 : colorMid;\n    vec3 colorB = isInFirstHalf ? colorMid : color1;\n    vec2 ab = isInFirstHalf ? vec2(0.0, midAlpha) : vec2(midAlpha, 1.0);\n    \n    return mix(colorA, colorB, linearStep(ab.x, ab.y, alpha));\n}\n\n//---------------------------------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////\n// ZOOMING WITH MOUSE //////////////////////////////////////\n\n// STRUCTURES //////////////////////////////////////////////\n// Zooming is controlled by horizontal mouse movement while holding down the left mouse button (LMB);\n// Zoom center is determined by the mouse position at the moment the LMB is pressed;\n// ZoomOptions:\n//\n// zoomOutToClampedUV : if true, then the current zoom center may be adjusted\n//                      to keep the UV coordinates of the zoomed area in the range [0, 1]\n//                      (for this adjustment to have a meaningful effect, zoomMin should be set to 1.0);\n//\n// zoomBase           : the zoom level multiplier is defined as zoomBase raised to the power\n//                      corresponding to the mouse movement (actual or by inertia),\n//                      for example, a zoomBase value of 4 means that the zoom level changes\n//                      by a factor of 2 when the mouse moves half the length of the viewport\n//\n// inertiaThreshold   : the minimum horizontal mouse speed (in normalized coordinates per second)\n//                      that causes the zoom level to change by inertia after the LMB is released\n//\n// inertiaDamping     : determines how quickly the speed of the mouse moving by inertia decreases over time\n//                      (0 - speed remains constant; \n//                      the larger the absolute value, the faster the speed decreases)\nstruct ZoomOptions\n{\n    bool zoomOutToClampedUV;\n    float zoomBase;\n    float zoomMin;\n    float zoomMax;\n    float inertiaThreshold;\n    float inertiaDamping;\n};\n\nstruct ZoomData\n{\n    vec2 offset;\n    float scale;\n    float controlInputRate;\n    float controlInputPrev;\n};\n\n// CONSTANTS ///////////////////////////////////////////////////\nconst ZoomOptions DFLT_ZOOM_OPTIONS = ZoomOptions(true, 8.0, 1.0, exp2(20.0), 0.033, 0.05);\nconst ZoomData    INI_ZOOM_DATA = ZoomData(vec2(0,0), 1.0, 0.0, 0.0);\n\nconst ivec4 ZOOM_DATA_TEXELS = ivec4(0,0,0,1);\n\n// COMMON VARIABLES ///////////////////////////////////////////\nZoomOptions zoomOptions = DFLT_ZOOM_OPTIONS;\n\n// PURE FUNCTIONS ///////////////////////////////////////////\nvoid fetchZoomData(sampler2D buf, ivec4 dataTexels, inout ZoomData target)\n{\n    vec4 dataSet1 = texelFetch(buf, dataTexels.xy, 0);\n    vec4 dataSet2 = texelFetch(buf, dataTexels.zw, 0);\n    \n    target.offset = dataSet1.xy;\n    target.scale = dataSet1.z;\n    target.controlInputRate = dataSet1.w;\n    \n    target.controlInputPrev = dataSet2.x;\n}\n\nvoid writeZoomData(sampler2D buf, ivec4 dataTexels, ZoomData source, ivec2 fragTexel, inout vec4 fragColor)\n{\n    if (fragTexel == dataTexels.xy)\n    {\n        fragColor.xy = source.offset;\n        fragColor.z = source.scale;\n        fragColor.w = source.controlInputRate;\n    }\n    \n    if (fragTexel == dataTexels.zw)\n    {\n        fragColor.x = source.controlInputPrev;\n    }\n}\n\nvec2 zoomUV(ZoomData zData, vec2 uv)\n{\n    return uv * zData.scale + zData.offset;\n}\n\nvoid updateZoomData(inout ZoomData zData, ZoomOptions zOptions, vec4 mouseUV, float dt)\n{\n    vec2 scaleCenter = zoomUV(zData, abs(mouseUV.zw));\n    float scaleFactor = 1.0;\n    \n    if (mouseUV.z > 0.0)\n    {\n        float ciCurr = mouseUV.x - mouseUV.z;\n        float ciDelta = ciCurr - zData.controlInputPrev;\n        float ciRate = ciDelta / dt;\n        \n        scaleFactor = pow(zOptions.zoomBase, -ciDelta);\n        zData.controlInputRate = abs(ciRate) < zOptions.inertiaThreshold ? 0.0 : ciRate;\n        zData.controlInputPrev = ciCurr;\n    }\n    else\n    { \n        zData.controlInputRate *= max(0.0, 1.0 - abs(zOptions.inertiaDamping) * dt);\n        zData.controlInputPrev = 0.0;\n        scaleFactor = pow(zOptions.zoomBase, -zData.controlInputRate * dt);\n    }\n    \n    float sfMin = 1.0 / (zData.scale * zOptions.zoomMax);\n    float sfMax = 1.0 / (zData.scale * zOptions.zoomMin);\n    scaleFactor = clamp(scaleFactor, sfMin, sfMax);\n    \n    zData.scale *= scaleFactor;\n    zData.offset = (zData.offset - scaleCenter) * scaleFactor + scaleCenter;\n    \n    zData.offset = zOptions.zoomOutToClampedUV ? clamp(zData.offset, vec2(0,0), vec2(1.0 - zData.scale)) : zData.offset;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Buffer_A is used to store the contents of the ZoomData structure\n    // and thereby to convey the zoom state between frames;\n    ZoomData currentZoom;\n    \n    if (iFrame == 0)\n        currentZoom = INI_ZOOM_DATA;\n    else\n        fetchZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom);\n    \n    updateZoomData(currentZoom, zoomOptions, iMouse/iResolution.xyxy, iTimeDelta);\n    \n    writeZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom, ivec2(fragCoord), fragColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}