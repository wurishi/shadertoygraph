{"ver":"0.1","info":{"id":"4t3BRH","date":"1538523012","viewed":387,"name":"Uniform color interpolation","username":"castano","description":"These are just some tests to see what's the best way to interpolate colors and produce perceptually uniform gradients.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["color","interpolation","srgb","perceptual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Approximate sRGB interpolation by using gamma2 space. When the to and from transform\n// are combined some of the sqrt terms cancel.\nvec3 color_mix(vec3 a, vec3 b, float t) {\n    //return a * (1.0-t)*(1.0-t) + 2 * sqrt(a*b) * t * (1.0-t) + b * t*t;\n\n    float omt = 1.0-t;\n    float t2 = t * t;\n    vec3 bt2 = b * t2;\n    vec3 abt2 = a * bt2;\n    return (a * omt + 2.0 * sqrt(abt2)) * omt + bt2;\n}\n\n// This is a variation of the above with the square root term removed. No good reason\n// to do that, other than making it cheaper, but looks surprisingly OK.\nvec3 color_mix2(vec3 a, vec3 b, float t) {\n    float omt = 1.0-t;\n    return a * omt*omt + b * t*t;\n}\n\nvec3 color_mix3(vec3 a, vec3 b, float t) {\n    float omt = 1.0-t;\n    return a * omt*omt + b * t*t;\n}\n\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, (1./2.4)) - 0.055, 12.92*x, step(x,(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,(2.4)), x / 12.92, step(x,(0.04045)));\n}\n\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\nfloat yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return srgb_linear(tuple) * m;\n}\n\nfloat L(vec3 c) {\n    // How do you compute the luma only makes a very small difference, so use the cheapest method.\n\t//return yToL(rgbToXyz(c).y);\n    return dot(c, vec3(0.299, 0.587, 0.114));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // left and right colors\n    vec3 left = 0.5 + 0.5*cos(iTime*vec3(0.17,0.23,0.61));\n    vec3 right = 0.5 + 0.5*cos(iTime*vec3(0.49,0.27,0.15));\n    //left = vec3(1.0, 0.0, 1.0);\n    //right = vec3(0.0, 1.0, 0.0);\n    //left = vec3(1.0, 0.0, 0.0);\n    //right = vec3(0.0, 1.0, 1.0);\n    //left = vec3(1.0, 1.0, 1.0);\n    //right = vec3(0.0, 0.0, 0.0);\n    \n    left = srgb_linear(left);\n    right = srgb_linear(right);\n    \n    vec3 col0 = srgb_linear(mix(linear_srgb(left), linear_srgb(right), uv.x));\n    vec3 col1 = mix(left, right, uv.x);\n    vec3 col2 = color_mix(left, right, uv.x);\n    vec3 col3 = color_mix2(left, right, uv.x);\n\n    float luma0 = srgb_linear(mix(linear_srgb(L(left)), linear_srgb(L(right)), uv.x));\n    float luma1 = mix(L(left), L(right), uv.x);\n\n    vec3 col = col0;\t\t\t\t\t// sRGB interpolation.\n    //if (uv.y < 0.75) col = col1;\t\t// Linear interpolation.\n    if (uv.y < 0.5) col = col2;\t\t\t// Quick gamma2 interpolation.\n    //if (uv.y < 0.25) col = col3;\t\t// Same, but with sqrt term removed.\n\n    // Luma correction.\n    // One idea is to interpolate the luma in sRGB space, use a quick interpolation for the color,\n    // but normalize it, so that the luma of the resulting color matches the sRGB-interpolated luma.\n    //if (uv.y < 0.5) col *= L(col0) / L(col);\n    \n    // Visualize luma:\n    //col = vec3(L(col));\n    \n    // Output to screen\n    fragColor = vec4(linear_srgb(col),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}