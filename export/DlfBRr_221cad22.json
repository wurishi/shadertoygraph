{"ver":"0.1","info":{"id":"DlfBRr","date":"1692498040","viewed":112,"name":"cartoon kid","username":"MonterMan","description":"cartoon kid I made to practice character modelling","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["cartoon","human"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T_MAX 20.0\n#define TWEAK1 (iMouse.y/iResolution.y)\n#define TWEAK2 (-iMouse.z/iResolution.x)\n#define TWEAK3 (-iMouse.w/iResolution.y)\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat bilat(float x)\n{\n    return 2.0 * x - 1.0;\n}\n\nmat2 rot2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return min(a, b) - 0.25/k*term*term;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return max(a, b) + 0.25/k*term*term;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float l = length(p/r);\n    float grad = length(p/(r*r))/l;\n    return (l-1.0)/grad;\n}\n\nfloat sdBox(vec3 p, vec3 dim, float bevel)\n{\n    p = max(vec3(0.0), abs(p)-0.5*dim);\n    return length(p) - bevel;\n}\n\nfloat sdSegment2(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    return length(ap - t * ab) - r;\n}\n\nfloat sdSegment(vec3 p, float h, float r)\n{\n    p.y = abs(p.y);\n    p.y = max(0.0, p.y - 0.5*h);\n    return length(p) - r;\n}\n\n// credit to inigo quilez\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nvec2 cs(float theta)\n{\n    return vec2(sin(theta), cos(theta));\n}\n\nstruct Query\n{\n    float dist;\n    int matId;\n};\n\nvoid update(inout Query query, float dist, int matId)\n{\n    if (dist < query.dist)\n    {\n        query.dist = dist;\n        query.matId = matId;\n    }\n}\n\nQuery map(vec3 p)\n{\n    Query query;\n    query.dist = T_MAX;\n    query.matId = 0;\n        \n    float head = sdSphere(p, 1.0);\n    float jaw = sdEllipsoid(p-vec3(0,-0.56,-0.3), vec3(0.7, 0.4, 0.7));\n    float dist = smin(head, jaw, 0.25);\n        \n    // symmetrical features\n    {\n        float time = 2.0*iTime;\n        float itime = floor(time);\n        float ftime = fract(time);\n        bool shouldBlink = hash11(itime+32.23) < 0.2;\n        float blink = shouldBlink? (0.5-0.5*cos(3.14*4.0*ftime)): 0.0;\n\n        vec3 q = p;\n        q.x = abs(q.x);\n        \n        // eye socket\n        q.x -= 0.38;\n        float socket = sdEllipsoid(q-vec3(0.0,-0.13,-0.85),\n                                   vec3(0.27,0.18,0.15));\n        socket = smax(socket, -q.y-0.25, 0.1); // socket bottom\n        socket = smax(socket, q.y-0.06 + 0.12*blink, 0.1); // socket ceiling\n        dist = smax(dist, -socket, 0.05);\n        \n        q.x += 0.1;\n        // eyeball\n        {\n            vec3 eq = q;\n            eq.xz *= rot2d(0.1);\n            float eyes = sdEllipsoid(eq-vec3(0,-0.1,-0.6), vec3(0.4, 0.35, 0.35));\n            update(query, eyes, 2);\n            \n            // eyelid\n            float dEyeLid = sdEllipsoid(eq-vec3(0,-0.1,-0.6),\n                                        1.04*vec3(0.4, 0.35, 0.35));\n            float lidY = mix(-0.015, 0.23, blink);\n            dEyeLid = smax(dEyeLid, -p.y-lidY, 0.02);\n            dist = smin(dist, dEyeLid, 0.01);\n        }\n      \n        // eyebrow\n        float temp = q.x - 0.15;\n        float browOffset = mix(0.0, -0.007, blink);\n        float eyeBrow = sdSegment2(q - (0.01 - 1.0*temp*temp),\n                                  vec3(0.05, 0.25+browOffset, -0.91),\n                                  vec3(0.25, 0.22+browOffset, -0.827), 0.008);\n        eyeBrow = min(eyeBrow, sdSegment2(q - (0.01 - 1.0*temp*temp),\n                                  vec3(0.07, 0.225+browOffset, -0.915),\n                                  vec3(0.22, 0.2+browOffset, -0.85), 0.006));                        \n        update(query, eyeBrow, 3);\n        \n        // ears\n        temp = q.x-0.05;\n        vec3 earR = vec3(0.3,0.3-0.1*temp*temp,0.1);\n        float dEar = sdEllipsoid(q-vec3(0.7,-0.3+0.2*q.x*q.x,-0.2), earR);\n        dEar = smax(dEar, -sdEllipsoid(q-vec3(0.7,-0.28+0.2*q.x*q.x,-0.27), 0.8*earR), 0.03);\n        dist = smin(dist, dEar, 0.02);\n        \n        // cheek\n        dist = smin(dist, sdEllipsoid(q-vec3(0.0,-0.45,-0.62), vec3(0.3, 0.2, 0.2)), 0.2);\n    }\n    \n    // nose\n#if 1\n    dist = smin(dist, sdEllipsoid(p-vec3(0.0,-0.28+0.05*p.z,-0.98), vec3(0.05, 0.05, 0.08)), 0.08);\n#else\n    vec3 np = p;\n    np.yz *= rot2d(-0.4);\n    dist = smin(dist, sdCone(np-vec3(0,-0.4,-0.78), cs(0.2), 0.3)-0.023, 0.05);\n#endif\n\n    // mouth\n    dist = smax(dist, -sdEllipsoid(p-vec3(0.0,-0.55-0.8*p.x*p.x,-1.0), 0.35*vec3(0.3, 0.07, 0.15)), 0.02);\n\n    update(query, dist, 1);\n\n    // hair\n    float hair = sdSphere(p-vec3(0.0, 0.2, 0.05), 1.08);\n    hair = smax(hair, -dot(p, normalize(vec3(0.0, 0.5, 0.2)))-0.08+0.15*fract(-1.8*p.x), 0.03);\n    update(query, hair, 4);\n    \n    return query;\n}\n\nvec3 calc_normal(vec3 p)\n{\n    vec2 e = vec2(0, 0.0001);\n    return normalize(vec3(map(p+e.yxx).dist - map(p-e.yxx).dist,\n                          map(p+e.xyx).dist - map(p-e.xyx).dist,\n                          map(p+e.xxy).dist - map(p-e.xxy).dist));\n}\n\nfloat calc_shadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.001;\n    for (int i = 0; i < 256 && t < T_MAX; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float dist = map(p).dist;\n        if (dist < 0.0001)\n        {\n            return 0.0;\n        }\n        res = min(res, k*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nfloat calc_ao(vec3 p, vec3 n)\n{\n    float sample_interval = 0.07;\n\n    float res = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; ++i)\n    {\n        float sample_dist = sample_interval * float(i+1);\n        vec3 sample_p = p + sample_dist * n;\n        res += amp * map(sample_p).dist / sample_dist;\n        amp /= 2.0;\n    }\n    return res;\n}\n\nfloat wrapLighting(float n_dot_l, float softness)\n{\n    return mix(n_dot_l, 1.0, softness);\n}\n\nvec3 render(vec2 uv)\n{\n    float cam_angle = 0.0;//6.28 * iMouse.x / iResolution.x;\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = 2.3*vec3(sin(cam_angle), -0.0, -cos(cam_angle));\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.3 * cam_z);\n    \n    float t = 0.0;\n    int matId = -1;\n    for (int i = 0; i < 256 && t < T_MAX; ++i)\n    {\n        vec3 p = ro + t * rd;\n        Query query = map(p);\n        if (abs(query.dist) < 0.001)\n        {\n            matId = query.matId;\n            break;\n        }\n        t += query.dist;\n    }\n    \n    vec3 col = vec3(0.02+0.03*rd.y);\n    if (matId != -1)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = calc_normal(p);\n        vec3 l = normalize(vec3(0.5, 0.5, -0.3));\n        \n        float specPower = 4.0;\n        vec3 albedo = vec3(0.5);\n        if (matId == 1)\n        {\n            // skin\n            albedo = vec3(0.790-0.177, 0.645-0.2275, 0.494-0.175);\n            // red smudge on face\n            vec3 q = p;\n            q.x = abs(q.x);\n            float dist = length(q - vec3(0.4, -0.5, -0.8));\n            albedo = mix(albedo, vec3(0.8,0.1,0.1), pow(0.025/dist, 1.0));\n            \n            specPower = 16.0;\n        }\n        if (matId == 2)\n        {\n            // eyeball\n            albedo = vec3(0.9);\n            // add eye color\n            {\n                vec3 q = p;\n                q.x = abs(q.x);\n                \n                float eyeBlackT = smoothstep(0.199, 0.19, length(q - vec3(0.35,-0.13,-1.0)));\n                albedo = mix(albedo, vec3(0.01), eyeBlackT);\n                \n                float eyeWhiteT = smoothstep(0.063, 0.058, length(q - vec3(0.29,-0.08,-1.0)));\n                albedo = mix(albedo, vec3(0.9), eyeWhiteT);\n            }\n            \n            specPower = 16.0;\n        }\n        if (matId == 3)\n        {\n            // eyebrow\n            albedo = vec3(0.349,0.204,0.114);\n            albedo = albedo * albedo;\n        }\n        if (matId == 4)\n        {\n            // hair\n            albedo = vec3(0.02);\n        }\n        if (matId == 5)\n        {\n            albedo = vec3(0.24, 0.1, 0.3);\n        }\n        \n        float ao = calc_ao(p, n);\n        \n        // key light\n        float shadow = calc_shadow(p+0.001*n, l, 16.0);\n        col = albedo * vec3(1.0) * max(0.0, dot(n, l)) * shadow;\n        // subsurface by adding faint wrap shading\n        if (matId == 1)\n        {\n            col += 0.1 * albedo * vec3(1.0, 0.2, 0.1) * wrapLighting(dot(n, l), 0.6);\n        }\n        // bounced light from below\n        col += 0.06 * albedo * (0.5 - 0.5 * n.y) * ao;\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 pixelSize = vec2(2.0*iResolution.x/iResolution.y,2.0) / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    int sampleCount = 4;\n    for (int i = 0; i < sampleCount; ++i)\n    {\n        vec2 jitter = hammersley(i, sampleCount) - 0.5;\n        col += render(uv + jitter * pixelSize);\n    }\n    col /= float(sampleCount);\n    \n    // Output to screen\n    col = pow(col, vec3(0.4545));\n    col += 1.0/255.0 * bilat(texture(iChannel0, uv).r); // dither\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float radicalInverse(int x, float base)\n{\n    int baseI = int(base);\n    float result = 0.0;\n    float b = 1.0 / base;\n    while (x > 0)\n    {\n        result += float(x % baseI) * b;\n        x /= baseI;\n        b /= base;\n    }\n    return result;\n}\n\nvec2 halton23(int index)\n{\n    return vec2(radicalInverse(index, 2.0), radicalInverse(index, 3.0));\n}\n\nvec2 hammersley(int index, int N)\n{\n    return vec2(float(index)/float(N), radicalInverse(index, 2.0));\n}","name":"Common","description":"","type":"common"}]}