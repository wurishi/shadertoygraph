{"ver":"0.1","info":{"id":"WdKSRm","date":"1629979625","viewed":555,"name":"ATMOSPHERE: CHAPMAN","username":"alro","description":"Use mouse to look around.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["sun","sky","scattering","atmosphere","beer","rayleigh","mie","ozone","chapman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n    Atmospheric scattering using Schüler's approximation of the Chapman function\n    \n    Based on:\n    \n    \"An approximation to the chapman grazing-incidence function for the atmospheric scattering\"\n    by Christian Schüler\n    https://books.google.co.uk/books?id=epxYDwAAQBAJ&pg=PA175\n\n    http://www.thetenthplanet.de/archives/4519\n    https://www.shadertoy.com/view/MdGfDG (Long compilation time)\n\n    https://www.shadertoy.com/view/XlBfRD\n*/\n\n#define PLANET_RADIUS 6371e3\n#define ATMOSPHERE_THICKNESS 100e3\n#define ATMOSPHERE_RADIUS float(PLANET_RADIUS + ATMOSPHERE_THICKNESS)\n\n// Camera height above the ground\nconst float ELEVATION = 20.0;\n\nconst int STEPS = 32;\n\nconst float power = 10.0;\nconst float mieStrength = 0.5;\n\nconst float SCALE_HEIGHT_RAYLEIGH = float(0.085 * ATMOSPHERE_THICKNESS);\nconst float SCALE_HEIGHT_MIE = float(0.012 * ATMOSPHERE_THICKNESS);\n\n// \"A Scalable and Production Ready Sky and Atmosphere Rendering Technique\"\n// With single scattering and low step count, a higher ozone coefficient look better\nconst vec3 BETA_RAYLEIGH = vec3(5.802, 13.558, 33.1) * 1e-6;\nconst vec3 BETA_OZONE = vec3(0.650, 1.881, 0.085) * 3e-6;\nconst float BETA_MIE = 3.996e-6;\n\nconst vec3 SCATTERING_COEFF = BETA_RAYLEIGH;\nconst vec3 EXTINCTION_COEFF = BETA_RAYLEIGH + BETA_OZONE;\n\nconst vec3 SCATTERING_COEFF_MIE = vec3(BETA_MIE);\nconst vec3 EXTINCTION_COEFF_MIE = vec3(1.101 * BETA_MIE);\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\t\n}\n\n//-------------------------- Camera ---------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution.xy / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n\n//---------------------- Intersection -----------------------\n\n//Return the near and far intersections of an infinite ray and a sphere. \n//Assumes sphere at origin. No intersection if result.x > result.y\nvec2 sphereIntersect(vec3 start, vec3 dir, float radius){\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0){\n    \treturn vec2(1e5, -1e5);\n    }\n    return vec2((-b - sqrt(d))/(2.0*a), (-b + sqrt(d))/(2.0*a));\n}\n\n//----------------------- Atmosphere ------------------------\n\nfloat chapmanApproximation(float X, float h, float cosZenith){\n\tfloat c = sqrt(X + h);\n\tfloat cExpH = c * exp(-h);\n\n\tif (cosZenith >= 0.0){\n\t\treturn cExpH / (c * cosZenith + 1.0);\n\t}else{\n\t\tfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\n\t\tfloat c0 = sqrt(x0);\n\n\t\treturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n\t}\n}\n\nfloat getOpticalDepth(float h, float H, float earthRadius, float cosZenith){\n\treturn H * chapmanApproximation(earthRadius / H, h / H, cosZenith);\n}\n\nfloat computeOpticalDepth(vec3 pos, vec3 dir, float H){\n    return getOpticalDepth(length(pos) - PLANET_RADIUS, H, PLANET_RADIUS, dot(normalize(pos), dir));\n}\n\n\n//Return colour of the atmosphere or black, if the ray points to space\nvec3 getSkyColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, inout vec3 totalOpticalDepth, float end){\n\n    vec3 col = vec3(0);\n    \n    vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, ATMOSPHERE_RADIUS);\n    vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, PLANET_RADIUS);  \n    \n    //Does the ray point into the atmosphere and the planet\n    bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;  \n    bool hitsPlanet = end != 0.0;\n    \n    //Is the camera inside the atmosphere\n    bool inAtmosphere = length(cameraPos) < ATMOSPHERE_RADIUS;\n    \n    //If the ray hits the atmosphere or if the camera is in the atmosphere\n    if(hitsAtmosphere || inAtmosphere){\n\n        //The start and end points of the ray \n    \tfloat start;\n        \n    \tif(inAtmosphere){\n            //In the atmosphere, the ray starts at the camera\n    \t\tstart = 0.0;\n   \t \t}else{\n            //In space, the ray starts at the near intersection with the atmosphere \n    \t\tstart = rayAtmosphereIntersect.x;\n    \t}\n        \n        //The ray ends at either the near intersection with the planet \n        //or the far intersection with the atmosphere\n        if(hitsPlanet){ \n     \t\tend = end;\n     \t}else{\t\n    \t\tend = rayAtmosphereIntersect.y;\n        }\n\n    \tfloat rayLength = end - start;\n    \tfloat stepSize = rayLength / float(STEPS);\n    \n        //Total Rayleigh and Mie scattering\n    \tvec3 totalRayleigh = vec3(0.0);\n    \tvec3 totalMie = vec3(0.0);\n\n        vec3 samplePoint = cameraPos + rayDir * end;\n        \n        float lastOpticalDepth = computeOpticalDepth(samplePoint, rayDir, SCALE_HEIGHT_RAYLEIGH);\n        float lastOpticalDepthMie = computeOpticalDepth(samplePoint, rayDir, SCALE_HEIGHT_MIE);\n        float opticalDepthLight;\n        \n        // The multiplier is used to control the segment accumulation.\n        // When looking at the sky, we use an infinite ray starting at the camera and intersecting the atmosphere.\n        // When looking at geometry, we are after the segment between the camera and the ray end point but the\n        // formulation deals with infinite rays pointing into space. We find the overlapping segments of infinite rays.\n        // This would greatly benefit from a diagram explaining the simple geometry.\n        float multiplier = hitsPlanet ? -1.0 : 1.0;\n        \n        vec3 scattering = vec3(0);\n        vec3 inscatter;\n        vec3 transmittance;\n        \n        vec3 scatteringMie = vec3(0);\n        vec3 inscatterMie;\n        vec3 transmittanceMie;\n        \n        vec3 totalOpticalDepthMie = vec3(1);\n        \n        for (int i = 0; i < STEPS; i++){\n\n            samplePoint -= stepSize * rayDir;\n            \n            // --------- Rayleigh scattering ---------\n            \n            float opticalDepth = multiplier * computeOpticalDepth(samplePoint, rayDir * multiplier, SCALE_HEIGHT_RAYLEIGH);\n            \n        \n            // Avoid artefacts from inf optical depth for light rays through the planet\n            if(dot(normalize(samplePoint), lightDir) > -0.3){\n                opticalDepthLight = computeOpticalDepth(samplePoint, lightDir, SCALE_HEIGHT_RAYLEIGH);\n                inscatter = exp(-(SCATTERING_COEFF) * opticalDepthLight);\n            }else{\n                inscatter = vec3(0);\n            }\n            \n            transmittance = exp(-EXTINCTION_COEFF * max(0.0, (opticalDepth - lastOpticalDepth)));\n\n            // Attenuate accumulated light\n            scattering *= transmittance;\n            // Add inscattering for segment\n            scattering += exp(-(length(samplePoint) - PLANET_RADIUS) / SCALE_HEIGHT_RAYLEIGH) * inscatter;\n\n            totalOpticalDepth *= transmittance;\n            lastOpticalDepth = opticalDepth;\n            \n            \n            // ------------ Mie scattering ------------\n            \n            float opticalDepthMie = multiplier * computeOpticalDepth(samplePoint, rayDir * multiplier, SCALE_HEIGHT_MIE);\n            \n            if(dot(normalize(samplePoint), lightDir) > -0.3){\n                opticalDepthLight = computeOpticalDepth(samplePoint, lightDir, SCALE_HEIGHT_MIE);\n                inscatterMie = clamp(exp(-(SCATTERING_COEFF_MIE) * opticalDepthLight), 0.0, 1e5);\n            }else{\n                inscatterMie = vec3(0);\n            }\n            \n            transmittanceMie = exp(-EXTINCTION_COEFF_MIE * max(0.0, (opticalDepthMie - lastOpticalDepthMie)));\n\n            // Attenuate accumulated light\n            scatteringMie *= transmittanceMie;\n            // Add inscattering for segment\n            scatteringMie += exp(-(length(samplePoint) - PLANET_RADIUS) / SCALE_HEIGHT_MIE) * inscatterMie;\n\n            totalOpticalDepthMie *= transmittanceMie;\n            lastOpticalDepthMie = opticalDepthMie;\n\t\t}\n        \n        totalRayleigh = scattering * stepSize;\n        totalMie = scattering * scatteringMie * stepSize;\n        \n\t\t//Stop Mie scattering from shining through the planet\n\t\tif(hitsPlanet){\n\t\t  totalMie = vec3(0.0);\n\t\t}\n        \n        float mu = dot(rayDir, lightDir);\n    \tfloat mumu = mu * mu;\n    \tfloat phaseRayleigh = 0.05968310365 * (1.0 + mumu);\n        float g = 0.7;\n        float gg = g * g;\n    \tfloat phaseMie = 0.11936620731 * ((1.0 - gg) * (mumu + 1.0)) / \n                                (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\n\n        col = phaseRayleigh * BETA_RAYLEIGH * totalRayleigh + mieStrength * phaseMie * BETA_MIE * totalMie;\n    }\n    return col;\n}\n\n\n\n//----------------------- Tonemapping and render ------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    if(fragCoord.x > iResolution.x || fragCoord.y > iResolution.y){\n        fragColor = vec4(0);\n    }else{\n        //Get the default direction of the ray (along the negative Z direction)\n        vec3 rayDir = rayDirection(60.0, fragCoord, iResolution.xy);\n   \n   \n       //----------------- Define a camera -----------------\n\n        vec3 cameraPos = vec3(10.0, (PLANET_RADIUS + ELEVATION), 10.0);\n        vec3 targetDir = -texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n        vec3 up = vec3(0.0, 1.0, 0.0);\n\n        //Get the view matrix from the camera orientation\n        mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n        //Transform the ray to point in the correct direction\n        rayDir = normalize(viewMatrix * rayDir);\n\n        //---------------------------------------------------\n\n        float t = iTime * 0.15;\n        vec3 L = normalize(vec3( 0.0, sin(t), -cos(t)));\n        vec3 col = vec3(0);\n        \n        vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, PLANET_RADIUS);  \n        bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;  \n        float dist;\n\n        if(hitsPlanet){\n            dist = rayPlanetIntersect.x;\n            vec3 p = cameraPos + rayDir * dist;\n            vec3 normal = normalize(p);\n            \n            // Attenuate light arriving on the planet surface by the atmosphere\n            float opticalDepth = computeOpticalDepth(p, L, SCALE_HEIGHT_RAYLEIGH);\n            vec3 transmittance = exp(-EXTINCTION_COEFF * max(0.0, (opticalDepth)));\n            col = transmittance * clamp(dot(normal, L), 0.0, 1.0);\n        }else{\n            dist = 0.0;\n            float mu = 0.5 + 0.5 * dot(rayDir, L);\n            col = vec3(1) * getGlow(1.0-mu, 2e-4, 4.6);\n        }\n      \n        vec3 opticalDepth = vec3(1.0);\n        vec3 skyCol = power * getSkyColour(cameraPos, rayDir, L, opticalDepth, dist);\n        \n        // Mix planet surface colour and atmosphere based extinction\n        col = skyCol + col * opticalDepth;\n\n        col = ACESFilm(col);\n        col = gamma(col);        \n\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Track mouse movement and resolution change between frames and set camera position.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(-HALF_PI, 1.7);\n                mouse = vec2(0);\n            }\n            \n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        //Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2021 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n#define HALF_PI (0.5 * PI)\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\n","name":"Common","description":"","type":"common"}]}