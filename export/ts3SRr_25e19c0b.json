{"ver":"0.1","info":{"id":"ts3SRr","date":"1571296884","viewed":239,"name":"1-Component Circular DOF - Brack","username":"ahmadierfan","description":"1-Component Circular DOF","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["depthoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define KERNEL_COMPONENTS 1\n\nconst int KERNEL_RADIUS = 13;\nconst int KERNEL_COUNT = 27;\n\nconst vec2 Kernel0Weights_RealX_ImY = vec2(0.767583,1.862321);\n\n//(Pr+Pi)*(Qr+Qi) = (Pr*Qr+Pr*Qi+Pi*Qr-Pi*Qi)\nvec2 multComplex(vec2 p, vec2 q)\n{\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\nvec4 getFilters(int x)\n{\n    float u = (float(x)/iResolution.x);\n    return texture(iChannel3, vec2(u,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepVal = 1.0/iResolution.xy;\n  \n    vec4 valR = vec4(0,0,0,0);\n    vec4 valG = vec4(0,0,0,0);\n    vec4 valB = vec4(0,0,0,0);\n    \n    float filterRadius = texture(iChannel3, uv).a;\n\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 coords = uv + stepVal*vec2(0.0,float(i))*filterRadius;\n        vec4 imageTexelR = texture(iChannel0, coords);  \n        vec4 imageTexelG = texture(iChannel1, coords);  \n        vec4 imageTexelB = texture(iChannel2, coords);  \n        \n        //unpack\n        vec2 imageTexelRR = imageTexelR.xy * brackets_scale + imageTexelR.zw;  \n        vec2 imageTexelGG = imageTexelG.xy * brackets_scale + imageTexelG.zw;  \n        vec2 imageTexelBB = imageTexelB.xy * brackets_scale + imageTexelB.zw;  \n        \n        vec2 c0 = getFilters(i+KERNEL_RADIUS).xy;\n\n        valR.xy += multComplex(imageTexelRR.xy,c0);\n        valG.xy += multComplex(imageTexelGG.xy,c0);\n        valB.xy += multComplex(imageTexelBB.xy,c0);   \n    }\n\n    float redChannel   = dot(valR.xy,Kernel0Weights_RealX_ImY);\n    float greenChannel = dot(valG.xy,Kernel0Weights_RealX_ImY);\n    float blueChannel  = dot(valB.xy,Kernel0Weights_RealX_ImY);\n    fragColor = vec4(sqrt(vec3(redChannel,greenChannel,blueChannel)),1.0);   \n   \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Circular DOF by Kleber Garcia \"Kecho\" - 2017\n// Click mouse in image and move to test circle dof size.\n// Big circles can get achieved in linear time.\n// Publication & Filter generator: https://github.com/kecho/CircularDofFilterGenerator\n// yehar's blog: http://yehar.com/blog/?p=1495\n\n// Test knobs:\n#define ANIMATE_FILTER_SIZE\n#define SLIDE_SHOWs\n//filter size can be bigger than 1, but then undersampling will occur.\n#define MAX_FILTER_SIZE 1.0\n\n\n// Prenormalization step available in siggraph publication. Can be generated by an offline tool, or passed as a cbuffer.\n// Small slideshow to show effect on multiple images.\n\n//Filter values:\n/********************************************************************/\n/********************************************************************/\n/*         Generated Filter by CircularDofFilterGenerator tool      */\n/*     Copyright (c)     Kleber A Garcia  (kecho_garcia@hotmail.com)*/\n/*       https://github.com/kecho/CircularDofFilterGenerator        */\n/********************************************************************/\n/********************************************************************/\n/**\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n**/\nconst int KERNEL_RADIUS = 13;\nconst int KERNEL_COUNT = 27;\nconst vec2 Kernel0Weights_RealX_ImY = vec2(0.767583,1.862321);\nconst vec4 Kernel0_RealX_ImY_RealZ_ImW[] = vec4[](\n        vec4(/*XY: Non Bracketed*/-0.000894,0.016530,/*Bracketed WZ:*/0.000000,0.054357),\n        vec4(/*XY: Non Bracketed*/0.003484,0.018480,/*Bracketed WZ:*/0.006447,0.060773),\n        vec4(/*XY: Non Bracketed*/0.008380,0.019416,/*Bracketed WZ:*/0.013658,0.063851),\n        vec4(/*XY: Non Bracketed*/0.013473,0.019303,/*Bracketed WZ:*/0.021157,0.063477),\n        vec4(/*XY: Non Bracketed*/0.018461,0.018218,/*Bracketed WZ:*/0.028503,0.059908),\n        vec4(/*XY: Non Bracketed*/0.023098,0.016327,/*Bracketed WZ:*/0.035332,0.053693),\n        vec4(/*XY: Non Bracketed*/0.027210,0.013860,/*Bracketed WZ:*/0.041387,0.045577),\n        vec4(/*XY: Non Bracketed*/0.030695,0.011070,/*Bracketed WZ:*/0.046520,0.036403),\n        vec4(/*XY: Non Bracketed*/0.033522,0.008216,/*Bracketed WZ:*/0.050683,0.027019),\n        vec4(/*XY: Non Bracketed*/0.035710,0.005537,/*Bracketed WZ:*/0.053905,0.018208),\n        vec4(/*XY: Non Bracketed*/0.037310,0.003237,/*Bracketed WZ:*/0.056262,0.010643),\n        vec4(/*XY: Non Bracketed*/0.038390,0.001477,/*Bracketed WZ:*/0.057851,0.004857),\n        vec4(/*XY: Non Bracketed*/0.039009,0.000375,/*Bracketed WZ:*/0.058763,0.001233),\n        vec4(/*XY: Non Bracketed*/0.039210,0.000000,/*Bracketed WZ:*/0.059060,0.000000),\n        vec4(/*XY: Non Bracketed*/0.039009,0.000375,/*Bracketed WZ:*/0.058763,0.001233),\n        vec4(/*XY: Non Bracketed*/0.038390,0.001477,/*Bracketed WZ:*/0.057851,0.004857),\n        vec4(/*XY: Non Bracketed*/0.037310,0.003237,/*Bracketed WZ:*/0.056262,0.010643),\n        vec4(/*XY: Non Bracketed*/0.035710,0.005537,/*Bracketed WZ:*/0.053905,0.018208),\n        vec4(/*XY: Non Bracketed*/0.033522,0.008216,/*Bracketed WZ:*/0.050683,0.027019),\n        vec4(/*XY: Non Bracketed*/0.030695,0.011070,/*Bracketed WZ:*/0.046520,0.036403),\n        vec4(/*XY: Non Bracketed*/0.027210,0.013860,/*Bracketed WZ:*/0.041387,0.045577),\n        vec4(/*XY: Non Bracketed*/0.023098,0.016327,/*Bracketed WZ:*/0.035332,0.053693),\n        vec4(/*XY: Non Bracketed*/0.018461,0.018218,/*Bracketed WZ:*/0.028503,0.059908),\n        vec4(/*XY: Non Bracketed*/0.013473,0.019303,/*Bracketed WZ:*/0.021157,0.063477),\n        vec4(/*XY: Non Bracketed*/0.008380,0.019416,/*Bracketed WZ:*/0.013658,0.063851),\n        vec4(/*XY: Non Bracketed*/0.003484,0.018480,/*Bracketed WZ:*/0.006447,0.060773),\n        vec4(/*XY: Non Bracketed*/-0.000894,0.016530,/*Bracketed WZ:*/0.000000,0.054357)\n);\n\n\n\nvec4 fetchImage(vec2 coords, sampler2D tex)\n{\n    vec4 colorImg = texture(tex, coords);    \n    \n    //luma trick to mimic HDR, and take advantage of 16 bit buffers shader toy provides.\n    float lum = dot(colorImg.rgb,vec3(0.2126,0.7152,0.0722))*1.8;\n    colorImg = colorImg *(1.0 + 0.2*lum*lum*lum);\n    return colorImg*colorImg;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec4 colors1 = fetchImage(uv, iChannel0);\n    vec4 colors2 = fetchImage(uv, iChannel1);\n    \n    #ifdef SLIDE_SHOW    \n    float t = clamp(4.0*sin(0.2*iTime),-1.0,1.0)*0.5+0.5;\n    #else\n    float t = 0.0;\n    #endif\n    \n    vec3 finalCol = mix(colors1, colors2, t).rgb;\n\n    #ifdef ANIMATE_FILTER_SIZE\n    float filterSize = MAX_FILTER_SIZE*clamp(abs(4.0*sin(iTime * 0.7)),0.0,1.0);\n    #else\n    float filterSize = MAX_FILTER_SIZE;\n    #endif\n    \n    vec2 mouseCoords = (iMouse.xy/iResolution.xy);\n    filterSize = 3.0 * MAX_FILTER_SIZE * (mouseCoords.x);\n    \n    if (int(fragCoord.x) < KERNEL_COUNT && int(fragCoord.y) == 0)\n    {\n        //Store the filters in the first row\n        vec2 c0 = (Kernel0_RealX_ImY_RealZ_ImW[int(fragCoord.x)].zw);\n        fragColor = vec4(c0.x,c0.y,0.0,0.0);        \n    }\n    else\n    {\n    \tfragColor = vec4(finalCol, filterSize);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Circular DOF: Kleber \"Kecho\" Garcia (c) 2017\n\nconst int KERNEL_RADIUS = 13;\nconst int KERNEL_COUNT = 27;\n\nvec4 fetchImage(vec2 coords)\n{\n    return texture(iChannel0, coords);    \n}\n\nvec4 getFilters(int x)\n{\n    float u = (float(x)/iResolution.x);\n    return texture(iChannel0, vec2(u,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepVal = 1.0/iResolution.xy;\n    \n    vec4 val = vec4(0,0,0,0);\n    float filterRadius = fetchImage(uv).a;\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 coords = uv + stepVal*vec2(float(i),0.0)*filterRadius;\n        float imageTexelR = fetchImage(coords).r;\n        vec2 c0 = (getFilters(i+KERNEL_RADIUS).xy);\n        val.xy += imageTexelR * c0;\n        val.zw += imageTexelR * brackets.xz;\n        \n    }\n    fragColor = val;\n    \n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Circular DOF: Kleber \"Kecho\" Garcia (c) 2017\n\nconst int KERNEL_RADIUS = 13;\nconst int KERNEL_COUNT = 27;\n\nvec4 fetchImage(vec2 coords)\n{\n    return texture(iChannel0, coords);    \n}\n\nvec4 getFilters(int x)\n{\n    float u = (float(x)/iResolution.x);\n    return texture(iChannel0, vec2(u,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepVal = 1.0/iResolution.xy;\n    \n    vec4 val = vec4(0,0,0,0);\n    float filterRadius = fetchImage(uv).a;\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 coords = uv + stepVal*vec2(float(i),0.0)*filterRadius;\n        float imageTexelG = fetchImage(coords).g;\n        vec2 c0 = (getFilters(i+KERNEL_RADIUS).xy);\n        val.xy += imageTexelG * c0;\n        val.zw += imageTexelG * brackets.xz;\n        \n    }\n    fragColor = val;\n    \n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Circular DOF: Kleber \"Kecho\" Garcia (c) 2017\n\nconst int KERNEL_RADIUS = 13;\nconst int KERNEL_COUNT = 27;\n\nvec4 fetchImage(vec2 coords)\n{\n    return texture(iChannel0, coords);    \n}\n\nvec4 getFilters(int x)\n{\n    float u = (float(x)/iResolution.x);\n    return texture(iChannel0, vec2(u,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 stepVal = 1.0/iResolution.xy;\n    \n    vec4 val = vec4(0,0,0,0);\n    float filterRadius = fetchImage(uv).a;\n    for (int i=-KERNEL_RADIUS; i <=KERNEL_RADIUS; ++i)\n    {\n        vec2 coords = uv + stepVal*vec2(float(i),0.0)*filterRadius;\n        float imageTexelB = fetchImage(coords).b;\n        vec2 c0 = (getFilters(i+KERNEL_RADIUS).xy);\n        val.xy += imageTexelB * c0;\n        val.zw += imageTexelB * brackets.xz;\n        \n    }\n    fragColor = val;\n    \n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec4 brackets = vec4(-0.000894,0.679045,0.000000,0.304091); // o[0] s[0] o[1] s[1]\nconst vec2 brackets_scale = brackets.yw;\nconst vec2 brackets_offset = brackets.xz;","name":"Common","description":"","type":"common"}]}