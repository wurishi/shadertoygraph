{"ver":"0.1","info":{"id":"WdsBzl","date":"1589316868","viewed":217,"name":"Edd's chair","username":"friol","description":"The chair doesn't exist.","likes":11,"published":1,"flags":96,"usePreview":1,"tags":["raymarching","shadow","arealight","chair","rietveld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n// friol 2o2o\n// sdf functions by iq\n// arealight code by tsone https://www.shadertoy.com/view/lsfGDN\n// beautiful and fast glitch effect by airtight https://www.shadertoy.com/view/MtXBDs\n// and ofcoz credit goes to the famous flatshading scener g.rietveld\n// music by Gridlok & Optiv\n// please watch with music ON & in sync (hit |< it music didn't start)\n// this is vaguely inspired by fizzer&noby's \"Oscar's chair\"\n// a demoscene 4k that I suggest you to watch -> https://www.pouet.net/prod.php?which=75721\n// A lot of time was spent optimizing compilation times (4.8s on my machine now)\n// works in the iOS app (not in Safari browser)\n//\n\nfloat random2d(vec2 n) { \n    return fract(sin(dot(n, vec2(12.989, 4.1414))) * 43758.5453);\n}\n\nfloat randomRange (in vec2 seed, in float min, in float max) {\n\t\treturn min + random2d(seed) * (max - min);\n}\n\nfloat insideRange(float v, float bottom, float top) {\n   return step(bottom, v) - step(top, v);\n}\n\nfloat AMT = 0.05;\nfloat SPEED = 0.23;\n\nvec3 doTheGlitch(vec4 fragColor, in vec2 fragCoord)\n{\n    float time = floor(iTime * SPEED * 60.0);    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 outCol = texture(iChannel3, uv).rgb;\n    \n    float maxOffset = AMT/2.0;\n    for (float i = 0.0; i < 10.0*AMT; i += 1.0) {\n        float sliceY = random2d(vec2(time , 2345.0 + float(i)));\n        float sliceH = random2d(vec2(time , 9035.0 + float(i))) * 0.25;\n        float hOffset = randomRange(vec2(time , 9625.0 + float(i)), -maxOffset, maxOffset);\n        vec2 uvOff = uv;\n        uvOff.x += hOffset;\n        if (insideRange(uv.y, sliceY, fract(sliceY+sliceH)) == 1.0 ){\n        \toutCol = texture(iChannel3, uvOff).rgb;\n        }\n    }\n    \n    float maxColOffset = AMT/6.0;\n    float rnd = random2d(vec2(time , 9545.0));\n    vec2 colOffset = vec2(randomRange(vec2(time , 9545.0),-maxColOffset,maxColOffset), \n                       randomRange(vec2(time , 7205.0),-maxColOffset,maxColOffset));\n    if (rnd < 0.33){\n        outCol.r = texture(iChannel3, uv + colOffset).r;\n        \n    }else if (rnd < 0.66){\n        outCol.g = texture(iChannel3, uv + colOffset).g;\n        \n    } else{\n        outCol.b = texture(iChannel3, uv + colOffset).b;  \n    }\n    \n    return outCol;\n}\n\n//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 outCol = texture(iChannel3, uv).rgb;\n    \n    if ((iTime>=5.0)&&(iTime<7.0))\n    {\n        AMT = 0.05;\n        SPEED = 0.18;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=12.0)&&(iTime<14.0))\n    {\n        AMT = 0.04;\n        SPEED = 0.1;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=16.6)&&(iTime<17.2))\n    {\n        AMT = 0.03;\n        SPEED = 0.1;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=14.5)&&(iTime<15.5))\n    {\n        AMT = 0.104;\n        SPEED = 0.3;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=32.0)&&(iTime<33.0))\n    {\n        AMT = 0.07;\n        SPEED = 0.12;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=46.0)&&(iTime<47.0))\n    {\n        AMT = 0.04;\n        SPEED = 0.1;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=55.0)&&(iTime<63.0))\n    {\n        AMT = 0.03;\n        SPEED = 0.12;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if ((iTime>=63.0)&&(iTime<66.0)) // I want you to destroY\n    {\n        AMT = 0.44;\n        SPEED = 0.21;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n    else if (iTime>=66.0)\n    {\n        AMT = 0.24*sin(iTime);\n        SPEED = 0.11;\n    \toutCol=doTheGlitch(fragColor,fragCoord);\n    }\n       \n\tfragColor = vec4(outCol,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//\n// area light\n//\n\n#define PI\t\t\t3.141592653589793\n#define SQRT2\t\t1.414213562373095\n#define INVSQRT2\t0.707106781186548\n#define HDR_MAX 7.0\n\nstruct Material\n{\n    float roughness;\n    float tailamount;\n    float tailtheta;\n    float F0;\n    vec3 basecolor;\n  \tvec3 specularcolor;\n};\n\nstruct RectLight\n{\n    vec3 position;\n    mat3 basis;\n    vec2 size;\n    vec3 intensity;\n    float attenuation;\n};\n    \nMaterial roomMat = Material(\n    0.163, // Roughness.\n    0.577, // Tail amount.\n    PI/142.0/3.0, // Specular cone tail theta angle.\n    0.0000205, // Schlick Fresnel coefficient for zero viewing angle.\n    vec3(0.57), // Base color.\n    vec3(0.545,0.545,0.3) // Specular color.\n);\n\nRectLight arealight1 = RectLight(\n    vec3(0.0, 2., .00), // Light position (center).\n    mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, -1.0\n    ),\n    vec2(.23, 3.0), // Light size.\n    vec3(10.0), // Light intensity.\n    1.13 // Constant attenuation at 0 distance.\n);\n\n\n\nfloat sqr(float x) { return x*x; }\n\nfloat RectLight_calcWeight(in vec3 P, in vec3 R, in RectLight light, float theta)\n{\n    float RoPlN = dot(R, light.basis[2]);\n    float d = dot(light.basis[2], light.position - P) / RoPlN;\n    if (d < 0.0 || RoPlN > 0.0) \n    {\n    \treturn 0.0;\n    }\n    vec3 PlC = P + d*R - light.position;\n    vec2 PlUV = vec2(dot(PlC, light.basis[0]), dot(PlC, light.basis[1]));\n    float r = d * tan(theta);\n    vec2 s = max(light.size - 0.5*r, 0.0);\n    float h = length(max(abs(PlUV) - s, 0.0));\n    float sr = 2.0*PI * (1.0 - cos(theta));\n    return exp(-sqr((3.0*INVSQRT2/2.0) * (h/r))) / (light.attenuation + sqr(d)*sr);\n}\n\nvec3 RectLight_shade(in RectLight light, in Material material, in vec3 P, in vec3 N, in vec3 R, float NoR)\n{\n    float Fr = material.F0 + (1.0-material.F0) * pow(1.0 - NoR, 5.0);\n    \n    float theta = mix(PI*0.003, PI/2.0/3.0, material.roughness);\n    float Cs = RectLight_calcWeight(P, R, light, theta);\n    float Cst = RectLight_calcWeight(P, R, light, material.tailtheta);\n    vec3 W = normalize(N - light.basis[2]);\n    float Cd = RectLight_calcWeight(P, W, light, PI/4.0);\n    return light.intensity * mix(\n        (Cd * max(dot(N, W), 0.0)) * material.basecolor,\n        (mix(Cs, Cst, material.tailamount) * NoR) * material.specularcolor,\n        Fr);\n}\n\n//\n// noise\n//\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xtj3Ry","filepath":"https://soundcloud.com/blackoutmusicnl/gridlok-cold-world-feat-optiv?in=gridlokdnb/sets/z3r0-h0u2","previewfilepath":"https://soundcloud.com/blackoutmusicnl/gridlok-cold-world-feat-optiv?in=gridlokdnb/sets/z3r0-h0u2","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst int iterationAmount=256;\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdLamp( vec3 p, vec3 b )\n{\n  float a2=PI+0.2*sin(iTime);\n  p=rotz(p,-a2);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSymzBox( vec3 p, vec3 b, float zshift )\n{\n  p.z = -p.z+zshift*clamp(round(p.z),-1.,0.);\n  vec3 q1 = abs(p) - b;\n  return length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0);\n}\n\nfloat sdAreaLight( vec3 p, vec3 b )\n{\n    p=rotx(p,PI/2.0);\n    float a2=PI+0.2*sin(iTime);\n    p=roty(p,a2);\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdAreaLight2( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//\n//\n//\n\nvec2 SDFcorridor(vec3 r)\n{\n    float t=10000.0;\n    float mat=0.0;\n\n    vec3 domainrep=vec3(19.0,11.0,16.0);\n\tr = mod(r+0.5*domainrep,domainrep)-0.5*domainrep;\n    \n    vec3 origR=r;\n\n    float doorspace=sdBox(r-vec3(0.0,0.1,8.0),vec3(0.7,1.1,0.2));\n\n    float roombox=sdInvertedBox(r-vec3(0.0,1.45,0.0),vec3(3.4,2.5,8.0));\n    roombox=opSubtraction(doorspace,roombox);\n    t=min(t,roombox);\n\n    float doorContour=sdBox(r-vec3(0.0,0.1,8.0),vec3(0.8,1.2,0.1));\n    doorContour=opSubtraction(doorspace,doorContour);\n    t=min(t,doorContour);\n\n    arealight1.position.x=sin(iTime+3.141592);\n    float a=PI/2.0;\n    arealight1.basis=mat3(\n            1.0, 0.0, 0.0,\n            0.0,-cos(a), -sin(a),\n            0.0,-sin(a), cos(a)\n        );\n\n    float a2=3.141592+0.1*sin(iTime);\n    mat3 zlightrot=mat3(\n        \t cos(a2),0.0,sin(a2),\n        \t0.0,1.0,0.0,\n        \t-sin(a2),0.0,-cos(a2));\n    arealight1.basis*=zlightrot;\n    \n    float alight=sdAreaLight(r-vec3(arealight1.position.x,arealight1.position.y,arealight1.position.z),\n                       vec3(arealight1.size.x,\n                            arealight1.size.y,\n                            0.01));\n    t=min(t,alight);\n    \n    float lampTop=sdLamp(r-vec3(arealight1.position.x,arealight1.position.y+0.06,arealight1.position.z),\n                       vec3(arealight1.size.x,\n                            0.05,\n                            arealight1.size.y));\n    t=min(t,lampTop);\n\n    // chair spalliera with lateral camera\n    const float spallheight=1.;\n    const float spallwidth=0.5;\n    const float woodThickness=0.02;\n    float spalliera=1000.0;\n    float seduta=1000.0;\n    vec3 rotVec=rotz(r,iTime/2.0);\n    if ((iTime>=33.0)&&(iTime<44.0))\n    {\n\t\tspalliera=sdBox(rotVec-vec3(0.0,0.1,-8.8+(iTime*1.1)-34.0),vec3(woodThickness,spallwidth,spallheight));\n        t=min(t,spalliera);\n    }\n    else if ((iTime>=44.0)&&(iTime<55.0)) // chair seduta with corridor camera\n    {\n\t\tseduta=sdBox(rotVec-vec3(0.0,0.01,-2.62+(iTime-44.0)),vec3(woodThickness,spallheight*0.55,spallwidth));\n        t=min(t,seduta);\n    }\n    \n    if (t==roombox) mat=1.0;\n    else if (t==alight) mat=0.1;\n    else if ((t==seduta)||(t==lampTop)) mat=3.0;\n    else if (t==spalliera) mat=2.0;\n    return vec2(t,mat);\n}\n\nvec2 SDFDoorScene(vec3 r)\n{\n    float t=10000.0;\n    float mat=0.0;\n    vec3 origR=r;\n    float asdt=abs(sin(iTime/16.0001));\n\n    if (iTime<22.0)\n    {\n        float roombox=sdInvertedBox(r-vec3(0.0,1.45,0.0),vec3(3.4,2.5,8.0));\n        t=min(t,roombox);\n\n        float doorspace=sdBox(r-vec3(0.0,0.1,0.0),vec3(0.7,1.4,0.3));\n        float doorContour=sdBox(r-vec3(0.0,0.1,0.0),vec3(.9,1.5,0.1));\n        doorContour=opSubtraction(doorspace,doorContour);\n        t=min(t,doorContour);\n\n        float centralWall=sdBox(r-vec3(0.0,0.0,0.0),vec3(3.4,5.0,0.09));\n        centralWall=opSubtraction(doorspace,centralWall);\n        centralWall=opSubtraction(doorContour,centralWall);\n        t=min(t,centralWall);\n\n        vec3 doorr2=r-vec3(0.8,0.0,0.0);\n        vec3 doorr=r-vec3(0.8,0.0,abs(noise2d(vec2(r.x*23.0,r.y*23.0)))*0.0055);\n        doorr=roty(doorr,0.9*asdt+PI);\n        doorr2=roty(doorr2,0.9*asdt+PI);\n        float door=sdBox(doorr-vec3(0.8,0.0,0.0),vec3(0.8,1.5,0.04));\n\n        float bump0=sdRoundBox(doorr2-vec3(0.5,-0.4,0.07),vec3(0.23,.5,0.02),0.02);\n        door=opSubtraction(bump0,door);\n        float bump1=sdRoundBox(doorr2-vec3(1.1,-0.4,0.07),vec3(0.23,.5,0.02),0.02);\n        door=opSubtraction(bump1,door);\n        float bump3=sdRoundBox(doorr2-vec3(0.5,0.8,0.07),vec3(0.23,.5,0.02),0.02);\n        door=opSubtraction(bump3,door);\n        float bump4=sdRoundBox(doorr2-vec3(1.1,0.8,0.07),vec3(0.23,.5,0.02),0.02);\n        door=opSubtraction(bump4,door);\n        t=min(t,door);\n\n        float handle=sdSphere(doorr-vec3(1.5,0.1,0.1),0.04);\n        t=min(t,handle);\n\n        if (t==roombox) mat=6.0;\n        else if (t==centralWall) mat=7.0;\n        else if (t==door) mat=8.0;\n        else if (t==doorContour) mat=9.0;\n        else if (t==handle) mat=10.0;\n\n    \treturn vec2(t,mat);\n    }\n    \n    return SDFcorridor(r);\n} \n\nvec2 SDF(vec3 r)\n{\n    float t=10000.0;\n    float mat=0.0;\n    vec3 origR=r;\n    float fft = texture( iChannel2, vec2(0.0,0.0) ).x;\n\n    if (iTime<66.0)\n    {\n        return SDFDoorScene(r);\n    }\n\n    //\n    // chair scene\n\t//\n\n    float roombox=sdInvertedBox(r-vec3(0.0,0.0,-0.5),vec3(4.4));\n    t=min(t,roombox);\n\n    arealight1.position=vec3(0.0,0.0,1.5);\n    arealight1.size.x=2.5;\n    arealight1.basis=mat3(\n            1.0, 0.0, 0.0,\n            0.0,1.0,0.0,\n            0.0,0.0,-1.0\n        );\n\tarealight1.intensity=vec3(fft*10.0);\n\n    float alight=sdAreaLight2(r-vec3(arealight1.position.x,arealight1.position.y,arealight1.position.z),\n                       vec3(arealight1.size.x,\n                            arealight1.size.y,\n                            0.01));\n    t=min(t,alight);\n    \n    r=r-vec3(0.0,-3.4,0.0);\n    r=roty(r,3.141592/2.0);\n    origR=r;\n\n    const float spallheight=1.; \n    const float spallwidth=0.5;\n    const float woodThickness=0.02;\n    const float armThickness=0.03;\n\n    vec3 rr=rotz(r,-0.41);\n    \n\tfloat spalliera=sdBox(rr-vec3(0.12,0.1,0.),vec3(woodThickness,spallheight,spallwidth));\n    t=min(t,spalliera);\n    \n    rr=origR;\n    rr=rotz(rr,1.32);\n    \n    float seduta=sdBox(rr-vec3(-0.6,0.61,0.0),vec3(woodThickness,spallheight*0.55,spallwidth));\n    t=min(t,seduta);\n    \n    //\n\n    rr=origR;\n    \n    float armleft=sdSymzBox(rr-vec3(-spallwidth*0.6,-0.15,0.75),vec3(spallheight*0.5,armThickness,spallwidth*0.25),1.5);\n    t=min(t,armleft);\n    \n    // base\n    \n    float basequadl=sdSymzBox(rr-vec3(-spallwidth*1.2,-.9,0.68),vec3(spallheight*0.8,armThickness,armThickness),1.35);\n    t=min(t,basequadl);\n\n    float basequadfront=sdBox(rr-vec3(-spallwidth*2.2,-.8,0.0),vec3(armThickness,armThickness,spallheight*0.85));\n    float basequadrear=sdBox(rr-vec3(-spallwidth*.32,-.8,0.0),vec3(armThickness,armThickness,spallheight*0.85));\n    float seatrear=sdBox(rr-vec3(spallwidth*.2,-.23,0.0),vec3(armThickness,armThickness,spallheight*0.85));\n    /*float midbase=sdBox(rr-vec3(-spallwidth*.52,-.65,0.0),vec3(armThickness,armThickness,spallheight*0.85));*/\n    float subseduta=sdBox(rr-vec3(-spallwidth*2.22,-.4,0.0),vec3(armThickness,armThickness,spallheight*0.85));\n\n    t=min(t,subseduta);\n    //t=min(t,midbase);\n    t=min(t,seatrear);\n    t=min(t,basequadrear);\n    t=min(t,basequadfront);\n\n    // yellow parts\n    \n    /*float ypsubsedutal=sdSymzBox(rr-vec3(-spallwidth*2.22,-.4,.85),vec3(armThickness,armThickness,0.01),1.5);\n    t=min(t,ypsubsedutal);\n\n    float ypmidbasel=sdSymzBox(rr-vec3(-spallwidth*.52,-.65,.85),vec3(armThickness,armThickness,0.01),1.5);\n    t=min(t,ypmidbasel);*/\n        \n    // legs\n    \n    float backlegl=sdSymzBox(rr-vec3(0.04,-0.6,0.8),vec3(armThickness,.45,armThickness),1.6);\n    t=min(t,backlegl);\n\n    float midlegl=sdSymzBox(rr-vec3(-0.2,-0.6,0.75),vec3(armThickness,.45,armThickness),1.5);\n    t=min(t,midlegl);\n\n    float frontlegl=sdSymzBox(rr-vec3(-1.17,-0.7,0.75),vec3(armThickness,.35,armThickness),1.5);\n    t=min(t,frontlegl);\n\n    \n    // mats \n    \n    if (t==spalliera) mat=2.0;\n    else if (t==seduta) mat=3.0;\n    else if ((t==armleft)||(t==basequadl)||(t==backlegl)||(t==midlegl)||(t==frontlegl)) mat=4.0;\n\telse if ((t==basequadfront)||(t==basequadrear)||(t==seatrear)||/*(t==midbase)||*/(t==subseduta)) mat=4.0;\n    /*else if ((t==ypsubsedutal)||(t==ypmidbasel)) mat=5.0;*/\n    else if (t==roombox) mat=11.0;\n    else if (t==alight) mat=0.1;\n    return vec2(t,mat);\n}\n\n//\n//\n//\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t=0.0;\n    vec3 rd=rayDir;\n    for (int i=0;i<iterationAmount;i++)\n    {\n        vec2 res = SDF(rayOrigin + rd * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n\n        t+=res[0];\n    }\n    \n    return vec2(-1.0,-1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.;\n\n    float dd = SDF( nor * .02 + pos )[0];\n\n    for( int i=0; i<1; i++ )\n    {\n        float hr = .01 + .15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        occ += -(dd-hr)*sca;\n        sca *= 0.94;\n    }\n    return clamp( 1. - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nfloat calcAO2( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.;\n\n    for( int i=0; i<1; i++ )\n    {\n        float hr = .01 + .15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n    \tfloat dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.94;\n    }\n    return clamp( 1. - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec4 reflekkt(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.33,0.0,-1.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    vec3 N=calcNormal(pHit);\n    float dotprod=abs(dot(N,L));\n\n    float NoR = -dot(N, rayDir);\n    NoR = max(NoR, 0.0);    \n    \n    if (mat==0.1) // arealight1 \n    {\n        col=vec3(1.0);\n    }\n    else if (mat==1.0) // room\n    {\n        col=RectLight_shade(arealight1, roomMat, pHit, N, reflect(rayDir,N), NoR);\n        col=pow(col, vec3(1.0/2.2));\n        col+=dotprod*0.35;\n    }\n    else if (mat==2.0) // chair spalliera\n    {\n        col=vec3(dotprod,0.0,0.0);\n    }\n    else if (mat==3.0) // chair seduta\n    {\n        col=vec3(0.0,dotprod*0.1,dotprod*0.4);\n    }\n    else if (mat==4.0) // chair wood\n    {\n        col=vec3(dotprod*0.1,dotprod*0.1,dotprod*0.1);\n    }\n    else if (mat==5.0) // chair yellow parts\n    {\n        col=vec3(dotprod*0.7,dotprod*0.7,0.0);\n    }\n    \n    col=pow(col,vec3(1.68));\n    return vec4(col.xyz,1.0);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    float asdt=abs(sin(iTime/16.0));\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.33,0.0,-1.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    \n    //if (iTime<66.0) pHit.z=(mod(pHit.z+8.0,16.0))-8.0;\n    pHit.z=(mod(pHit.z+8.0,16.0))-8.0;\n        \n    vec3 N=calcNormal(pHit);\n    float dotprod=abs(dot(N,L));\n\n    float NoR = -dot(N, rayDir);\n    NoR = max(NoR, 0.0);    \n    vec3 R=reflect(rayDir,N);\n    vec4 ref=reflekkt(pHit,R,uv,fragCoord);\n\n    if (mat==0.1) // arealight1\n    {\n        col=vec3(1.0);\n    }\n    else if (mat==1.0) // corridor\n    {\n        roomMat.basecolor=vec3(0.39,0.5,0.75);\n        vec3 kol=RectLight_shade(arealight1, roomMat, pHit, N, R, NoR);\n        col=pow(kol, vec3(1.0/1.2));\n        col+=vec3(0.01);\n        \n        if (abs(N.x)>0.1) //lateral walls\n        {\n            float fbm1=noise2d(pHit.yz*0.20);\n            pHit.x-=fbm1;\n            pHit.y+=fbm1;\n            col*=calcAO(pHit,R)*8.0;\n            col=mix(col,ref.xyz,0.05)*dotprod;\n        }\n        else if (N.y>0.10) // floor\n        {\n            float fbm1=noise2d(pHit.xz*.72);\n            float fbm2=noise2d(vec2(fbm1,fbm1));\n            vec4 displ=texture(iChannel0,vec2(pHit.x,pHit.z));\n            N.x+=displ.x+fbm1;\n            N.z+=displ.z+fbm2;\n            vec3 hitDir=arealight1.position-pHit;\n            dotprod=max(dot(normalize(N),normalize(hitDir)),0.0)/2.0;\n\n            float lightAdder=2.0/abs(pHit.x-arealight1.position.x);\n            if (pHit.z>=3.0) lightAdder*=1.0-abs(pHit.z-3.0);\n            if (pHit.z<=-3.0) lightAdder*=1.0-abs(-pHit.z-3.0);\n\n            vec2 shadow=castRay(pHit, normalize(hitDir));\n            if (shadow[1]>1.0) \n            {\n                col/=1.7;\n                lightAdder=1.0;\n            }\n            \n            vec3 adder=mix(col,ref.xyz,0.5)*dotprod*lightAdder;\n            if (fbm1>-0.015)\n            {\n                col+=adder;\n            }\n            else\n            {\n                col+=mix(vec3(.01,0.01,0.01),adder,1.0-min(-fbm1,1.0));\n            }\n        }\n    }\n    else if (mat==2.0) // chair spalliera\n    {\n        col=mix(vec3(dotprod,0.0,0.0),ref.xyz,0.2);\n    }\n    else if (mat==3.0) // chair seduta\n    {\n        col=mix(vec3(0.0,dotprod*0.1,dotprod*0.4),ref.xyz,0.2);\n    }\n    else if (mat==4.0) // chair wood\n    {\n        col=vec3(dotprod*0.1,dotprod*0.1,dotprod*0.1);\n    }\n    else if (mat==5.0) // chair yellow parts\n    {\n        col=vec3(dotprod*0.7,dotprod*0.7,0.0);\n    }\n    else if (mat==6.0) // room door scene - walls\n    {\n    \tconst vec3 frontL=normalize(vec3(2.0,1.5,0.5));\n\n        if ((N.y>0.1))\n        {\n            float fbm1=noise2d(pHit.xz*.72);\n            float fbm2=noise2d(vec2(fbm1,fbm1));\n            vec4 displ=texture(iChannel0,vec2(pHit.x,pHit.z+4.0));\n            N.x+=displ.x+fbm1;\n            N.z+=displ.z+fbm2;\n            vec3 hitDir=frontL-pHit;\n            dotprod=max(dot(normalize(N),normalize(hitDir)),0.0)/2.0;\n\n            float lightAdder=3.0/abs(pHit.x-pHit.z+.6);\n            lightAdder*=asdt;\n            if (pHit.z>=0.) lightAdder-=pHit.z*2.0;\n            \n            ref=vec4(0.5,0.5,0.5,1.0);\n\n            if (fbm1>-0.015)\n            {\n                col+=mix(col,ref.xyz,0.5)*dotprod*lightAdder;\n            }\n            else\n            {\n                vec3 adder=mix(col,ref.xyz,0.5)*dotprod*lightAdder/1.0;\n                col+=mix(vec3(.01,0.01,0.01),adder,1.0-min(-fbm1,1.0));\n            }\n\n            vec2 shadow=castRay(pHit, normalize(frontL-pHit));\n            if ((shadow[1]==9.0)||(shadow[1]==7.0)||(shadow[1]==8.0)) \n            {\n                col/=8.7;\n            }\n            else\n            {\n                float d=distance(pHit,frontL);\n                col/=d*0.5;\n            }\n            \n            //col+=calcAO(pHit,reflect(rayDir,N))*.05;\n            col*=vec3(asdt);\n            col*=vec3(0.42,0.65,0.9);\n        }\n        else if (abs(N.x)>0.1)\n        {\n            float fbm1=noise2d(pHit.yz*20.422);\n            pHit.y+=0.61*(fbm1/pHit.y);\n            pHit.z+=fbm1;\n            col=vec3(calcAO(pHit,R)*.1);\n            col*=vec3(0.2,0.65,0.90);\n        }\n        else\n        {\n        \tcol=vec3(dotprod*0.05)*vec3(0.42,0.75,0.95);\n        }\n    }\n    else if (mat==7.0) // door wall\n    {\n        float fbm1=noise2d(pHit.xy*20.422);\n        pHit.y+=0.61*(fbm1/pHit.y);\n        pHit.x+=fbm1;\n        col=vec3(calcAO2(pHit,R)*.1);\n        col*=vec3(0.2,0.65,0.9);\n    }\n    else if (mat==8.0) // door\n    {\n    \tconst vec3 backL=normalize(vec3(2.0,1.5,-1.5));\n\n        vec3 doorr=pHit-vec3(0.8,0.0,0.0);\n        doorr=roty(pHit,0.9*asdt+3.141592);\n        N.x+=noise2d(doorr.xy*.52);\n        N.y+=noise2d(doorr.xy*.62);\n        N.z+=noise2d(doorr.xy*.32);\n        \n        float dp2=dot(normalize(N),backL);\n        dp2=pow(dp2,16.0);\n        col=vec3(dp2*asdt);\n\n        vec4 wood=texture(iChannel1,vec2(doorr.xy));\n        col*=vec3(wood.xyz/1.3);\n        col*=vec3(0.08,0.08,0.08);\n    }\n    else if (mat==9.0)\n    {\n        col=vec3(0.0);\n    }\n    else if (mat==10.0) // door handle\n    {\n        col=vec3(0.1)*dotprod*asdt;\n    }\n    else if (mat==11.0) // chair scene wall\n    {\n        roomMat.basecolor=vec3(0.39,0.5,0.75);\n        col+=mix(RectLight_shade(arealight1, roomMat, pHit, N, R, NoR)+vec3(0.01),ref.xyz,0.5);\n    }\n    \n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    float fov=2.0;\n    if ((iTime>=63.0)&&(iTime<66.0)) fov=2.0+(iTime-63.0)*3.0;\n    else if (iTime>=66.0) fov=4.0;\n    vec2 result = fov*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime;\n    if (iTime<20.0) myTime/=10.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    float fft = texture( iChannel2, vec2(0.0,0.00) ).x;\n\n    // walk in\n    camPos=vec3(0.0,0.12,-5.0+myTime);\n    camTarget=vec3(0.0,0.0,myTime);\n\n    if ((iTime>11.2)&&(iTime<=20.0)) // camera from above, door scene\n    {\n        camPos=vec3(0.0,3.5,-4.2+myTime-1.12);\n        camTarget=vec3(0.0,0.1,-1.2+myTime-1.12);\n    }\n    else if ((iTime>20.0)&&(iTime<22.0)) // black\n    {\n        fragColor=vec4(vec3(0.0), 1.0);\n        return;\n    }    \n    else if ((iTime>22.0)&&(iTime<33.0)) // camera from above\n    {\n        camPos=vec3(0.0,3.5,5.0+myTime-2.2);\n        camTarget=vec3(0.0,0.1,5.9+myTime-2.2);\n    }\n    else if ((iTime>=33.0)&&(iTime<44.0)) // lateral camera\n    {\n        camPos=vec3(3.2,0.1,-4.0+myTime-1.15);\n        camTarget=vec3(0.0,0.5,-4.0+myTime-1.15);\n    }\n    else if ((iTime>=44.0)&&(iTime<55.0)) // corridor camera\n    {\n        camPos=vec3(0.2,0.12,-5.0+iTime-44.0);\n        camTarget=vec3(0.2,0.0,iTime-44.0);\n    }\n    else if ((iTime>=55.0)&&(iTime<66.0))\n    {\n        camPos=vec3(0.7*sin(iTime),0.12+0.5*cos(iTime),-5.0+iTime*(iTime-55.0)*0.1);\n        camTarget=vec3(0.2,0.0,iTime*(iTime-55.0)*0.1);\n    }\n    else if (iTime>=66.0)\n    {\n        if (iTime<77.0) camPos=vec3((cos(iTime*4.0)*sin(-iTime)*1.9)+(fft*0.7),-2.0,-2.0*sin(iTime)*cos(-iTime));\n        else if (iTime<89.6) camPos=vec3((cos(iTime*4.0)*sin(-iTime)*1.9)+(fft*0.7),2.0-(iTime-77.0)/2.0,-2.0*sin(iTime)*cos(-iTime));\n\t\telse camPos=vec3((sin(iTime*3.0)*cos(-iTime)*1.9)+(fft*0.7),-2.0,-1.5*cos(iTime/2.0)*sin(-iTime));\n        camTarget=vec3(0.0,-3.3,0.0);\n    }\n\n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n\n    if (iTime>=55.0) finalCol+=vec4(vec3(pow(fft,4.0)/8.0),0.0);\n    \n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}