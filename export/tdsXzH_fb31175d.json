{"ver":"0.1","info":{"id":"tdsXzH","date":"1550654601","viewed":480,"name":"Order from Chaos","username":"dfreeman","description":"A Life-like cellular automaton using the ruleset B45/S12345, which leads to regions of ordered lines of living cells separated by chaotic borders. Click to randomize an area.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["life","conway","multipass","cellularautomaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 offset = iResolution.xy / 2. - iResolution.xy / scale / 2.;\n    vec4 cell = texelFetch(iChannel0, ivec2(offset + fragCoord / scale), 0);;\n    \n    // Swap this to see straight black and white for cell state\n    // float value = cell.x;\n    float value = max(cell.x, cell.z * .6);\n    \n    fragColor = vec4(value, value, value, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Adjust this to 'zoom' in and out\nconst float scale = 2.;\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 cell(vec2 coord) {\n    ivec2 ires = ivec2(iResolution.xy);\n    return texelFetch(iChannel0, (ivec2(coord) + ires) % ires, 0);\n}\n\nbool willLive(bool wasAlive, float neighbors) {\n    return (wasAlive && neighbors > 0. && neighbors < 6.)\n        || (!wasAlive && neighbors == 4. || neighbors == 5.);\n}\n\nvec2 mouseLocation() {\n    vec2 offset = iResolution.xy / 2. - iResolution.xy / scale / 2.;\n    return iMouse.xy / scale + offset;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = cell(fragCoord); \n\tfragColor.z = min((fragColor.z + fragColor.x) * 0.95, 1.);\n    \n\n    if (iFrame == 0 || (iMouse.z > 0. && length(mouseLocation() - fragCoord) < 20.)) {\n        fragColor.x = rand(fragCoord * iTime) > 0.33 ? 0.0 : 1.0;\n    } else {\n\t\tvec4 u = vec4(0.);\n        \n        u += cell(fragCoord + vec2(-1, 0));\n        u += cell(fragCoord + vec2(-1, -1));\n        u += cell(fragCoord + vec2(0, -1));\n        u += cell(fragCoord + vec2(1, -1));\n        u += cell(fragCoord + vec2(1, 0));\n        u += cell(fragCoord + vec2(1, 1));\n        u += cell(fragCoord + vec2(0, 1));\n        u += cell(fragCoord + vec2(-1, 1));\n        \n        fragColor.x = willLive(fragColor.x == 1., u.x) ? 1.0 : 0.0;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}