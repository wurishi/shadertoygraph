{"ver":"0.1","info":{"id":"WlSczh","date":"1594487434","viewed":1187,"name":"Enamel Pin","username":"blackle","description":"enamel pin of the transgender symbol (with a pentagram inside)\n4k exegfx for solskogen 2020\nbased on an actual pin: https://www.etsy.com/listing/728263195/trans-symbol-pentacle-enamel-pin-lapel","likes":38,"published":3,"flags":48,"usePreview":0,"tags":["trans","pentagram","transgender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//blessed be mattz for posting the code to fit garbor functions to arbitrary images!\n//from https://www.shadertoy.com/view/4ljSRR\n//this is used to hardcode the bloom >:3\nfloat gabor(vec2 p, float u, float v, float r, float ph, float l, float t, float s, float h) {\n    float cr = cos(r);\n    float sr = sin(r);\n        \n    vec2 st = vec2(s,t);\n\n    p = mat2(cr, -sr, sr, cr) * vec2(p.x-u,-p.y-v);    \n    return h * exp(dot(vec2(-0.5), p*p/(st*st))) * cos(p.x*6.2831853/l+ph);\n    \n}\n\nfloat hash(float a, float b) {\n    int x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n    int y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y/ZOOM;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.xyz /= fragColor.w;\n    float k = 0.0;\n\n\tfloat sd = hash(uv.x,uv.y);\n#ifdef HARD_CODED_BLOOM\n\tk+=gabor(uv, 0.07, 0.03, 1.89, 1.08, 3.65, 0.13, 0.12, 1.82);\n\tk+=gabor(uv, -0.52, 0.94, 3.26, 2.84, 3.72, 0.53, 0.53, 0.21);\n\tk+=gabor(uv, 0.05, -0.16, 1.60, 1.52, 3.12, 0.09, 0.09, 1.50);\n\tk+=gabor(uv, 0.45, 0.94, 6.28, 2.33, 4.00, 0.48, 0.48, 0.17);\n\tk+=gabor(uv, 0.30, 0.03, 4.39, 6.27, 0.36, 0.13, 0.13, 0.11);\n\tk+=gabor(uv, 0.07, -0.08, 3.17, 1.22, 0.41, 0.16, 0.05, 0.15);\n\tk+=gabor(uv, 0.94, -0.55, 4.75, 4.04, 1.14, 1.06, 0.14, 0.18);\n\tk+=gabor(uv, -0.88, -0.18, 4.03, 3.94, 1.29, 0.49, 0.49, 0.05);\n\tk+=gabor(uv, 0.16, -0.05, 1.60, 6.28, 0.21, 0.05, 0.05, 0.18);\n\tk+=gabor(uv, -0.42, 0.45, 5.45, 1.03, 0.76, 0.35, 0.35, 0.05);\n    \n    \n    float bloom = k*.9+.2;\n    vec4 bbright = vec4(0xaf,0x84,0x6a,0)/128.;\n    vec4 bmid = vec4(0x15,0x17,0x19,0)/60.;\n    fragColor = mix(fragColor,mix(bmid, bbright,(max(bloom,0.1)-.1)/.9)*sqrt(bloom),0.6);\n#endif\n    fragColor += sd*sd*.02;\n\tfragColor *= (1.0 - dot(uv,uv)*0.30); //vingetting lol\n\tfragColor = (smoothstep(vec4(-.34),vec4(1.), log(fragColor+1.0))-.2)/.8; //colour grading\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat super(vec2 p) { return sqrt(length(p*p));}\nfloat super(vec3 p) { return sqrt(length(p*p));}\nfloat box(vec2 p, vec2 d) {\n    vec2 q = sqrt(p*p+0.005)-d;\n    return super(max(q,0.))+min(0.,max(q.x,q.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat pin_sdf(vec2 p) {\n    //p+=sin(p.y*10.)*sin(p.x*10.)*.005;\n    p+=sin(p.y*15.)*sin(p.x*15.)*.002;\n    float inner = length(p)-.73;\n    float angl = atan(p.y,p.x);\n    float angl2 = asin(sin(angl*5.-1.4)*.995)/5.;\n    angl = asin(sin(angl*1.3)*.99)/1.3;\n    vec2 p2 = vec2(cos(angl),sin(angl))*length(p);\n    vec2 p3 = vec2(cos(angl2),sin(angl2))*length(p);\n    float pentagram = linedist(p3, vec2(0.67,0.22),vec2(0.25,-0.07));\n    pentagram = smin(pentagram, linedist(p3, vec2(0.23,-0.07),vec2(0,0.60)) ,.05 );\n    float arms = box(p2-vec2(1.4,0), vec2(.6,.1));\n    \n    mat2 rot = mat2(.7,-.7,.7,.7);\n    float cplane1 = p.x;\n    float cplane2 = p.y*.95-p.x*.32-.1;\n    \n    float bars = min(box(p2-vec2(1.45,0), vec2(.1,.35)), box((abs(p2)-vec2(1.45,.35))*rot, vec2(.13)));\n\tarms = smin(arms, max(cplane2,bars),.05);\n    \n    float arrow = box((p2-vec2(1.9,0))*vec2(.6,1)*rot, vec2(.2,.2));\n    arrow = -smin(-arrow, p2.x-1.9, .03);\n    arms = smin(arms, max(cplane1,arrow),.05);\n\n    //bar on bottom of bottom leg\n    arms = smin(arms, box((p2-vec2(1.95,0))*rot, vec2(.12,.12)),.05);\n    \n    float body = smin(arms-.05,min(max(length(p)-1.,-inner),inner),.1);\n    body = -smin(-body,pentagram,0.05);\n    return body;\n}\n\nfloat hash(float a, float b) {\n    int x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n    int y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec2 hash2(float a, float b) {\n    float s1 = hash(a,b);\n    float s2 = hash(s1,a);\n    return vec2(s1,s2);\n}\n\nfloat pin_edge;\nfloat fabric;\nfloat scene(vec3 p) {\n    vec3 p2 = erot(p,vec3(1,0,0),2.7),p3 = p;\n    p.y=p.y/1.5+1.2;\n    p.yz = asin(sin(p.yz/20.)*.6)*20.;\n    //weird space folding for the fabric texture.\n    mat2 rot = mat2(cos(2.6),-sin(2.6),sin(2.6),cos(2.6)); //erot is powerful, but slower here\n    for(int i = 0; i < 8; i++) {\n        p.yz-=float(i);\n    \tp.yz*=rot;\n    \tp.y = sqrt(p.y*p.y+float(i/2+1))-.5;\n    }\n    \n    vec3 edg = normalize(vec3(-1,1.,1.));\n    p2.yz += asin(sin(p.yz)*.9);\n    p2.yz=asin(sin(p2.yz*vec2(5.,8.))*.85)/vec2(5.,8.);\n    fabric = dot(p,edg);\n\n    p2.x=fabric/1.;\n    p2+=.005*dot(sin(p3.yz*8.4),cos(p3.xy*6.));\n    p2+=.001*dot(sin(p3.yz*50.),cos(p3.xy*40.));\n\n    fabric = smin(fabric,(mix(length(p2),super(p2),.7)-0.2),.2);\n    \n    p3.x-=6.;\n    p3=erot(p3,vec3(.997,0,-.075),2.45);\n    float pinsdf = pin_sdf(p3.yz/13.)*13.;\n    p3 += p2/30.;\n\tp3 += sin(p.yxz*10.)/1000.;\n    float ln = dot(p3.yz,p3.yz)/14.;\n    float bump = smoothstep(1.1,1.5,sin(p.y*60.+sin(p.y*4.6)*1.35)+sin(p.z*50.+sin(p.z*5.6)*1.5));\n    bump += smoothstep(1.1,1.3,sin(p.y*90.+sin(p.y*5.6)*1.45)+sin(p.z*80.+sin(p.z*7.6)*1.55));\n\tfloat pin_inside = box(vec2(pinsdf+2., p3.x-sqrt(sqrt(smoothstep(0.,-1.7,pinsdf)))*.1), vec2(2.,.85-ln*.005))-.2;\n\n    pin_edge = box(vec2(pinsdf, p3.x), vec2(.12+cos(p3.y/20.)*0.05-ln*.001,1.-ln*.005))-.12+bump/1500.;\n    pin_edge = mix(pin_edge, linedist(vec2(pinsdf, p3.x), vec2(0.5,1),vec2(0,-1))-.3,0.005);\n    return min(fabric,min(pin_edge,pin_inside));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nconst vec3 suncol = vec3(1.5,1.0,0.7);\nconst vec3 skycol = vec3(0.4,0.75,1.0);\nconst vec3 sundir = normalize(vec3(-1,0.,1.2));\nvec3 skybox(vec3 angle) {\n\treturn mix(vec3(1),skycol, angle.x*angle.x) \n        + pow(max(dot(angle, sundir),0.0),350.0)*suncol*15.0;\n}\n\nvec3 pixel_color( vec2 uv )\n{\n    uv/=ZOOM;\n    uv.y-=.02;uv.x+=.02;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec2 h2 = tan(hash2(uv.x,uv.y));\n    vec3 cam = normalize(vec3(2.5,uv+h2*.02));\n    vec3 init = vec3(-120,-h2);\n    float yrot = -.6;\n    float xrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        xrot = 4.*mouse.x;\n    }\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam, vec3(1,0,0), xrot);\n    init = erot(init, vec3(1,0,0), xrot);\n    vec3 p = init;\n    bool hit = false;\n    float atten = 1.;\n    float dist;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-7;\n        if (hit && dist == pin_edge) {\n            vec3 n = norm(p);\n    \t\tatten *= 1.-abs(dot(cam,n))*.5;\n            cam = reflect(cam,n);\n            dist = .1;\n            hit = false;\n        }\n        p += cam * dist;\n        if (distance(p,init) > 1000.)break;\n    }\n    float mat = dist == fabric ? 1. : 0.;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float spec = max(0.,dot(r,sundir));\n    float fres = 1.-abs(dot(cam,n))*.9;\n    float ao = smoothstep(-1.,2.,scene(p+n*.5+sundir*3.));\n    vec3 col = (spec*.3*skycol*(ao*.2+.7) + \n        ((pow(spec,8.)*.1*suncol+ pow(spec,20.))*4.)*mat+\n         (mat*.8+.2)*(pow(spec,80.)*3.+ step(0.999-mat*.01,spec)*10.))*fres*ao;\n    return (hit ? col : skybox(cam))*atten;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //press space to reset the rendering.\n    if (texelFetch(iChannel1, ivec2(32,1), 0).x > 0. || iMouse.z > 0.) fragColor = vec4(0);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float sd = hash(uv.x,uv.y);\n    vec2 h2 = tan(hash2(sd, float(iFrame)));\n#ifndef HARD_CODED_BLOOM\n    if (iFrame %5!=0)h2=tan(h2)*iResolution.y/15.;\n#endif\n    vec2 uv2 = uv + h2/iResolution.y;\n    fragColor += vec4(pixel_color(uv2), 1)\n#ifndef HARD_CODED_BLOOM\n        *(iFrame%5!=0?.3:1.)\n#endif\n    ;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//comment out to get \"real\" bloom instead of the hardcoded gabor image.\n//make sure to reset the time when you do.\n#define HARD_CODED_BLOOM\n#define ZOOM 1.","name":"Common","description":"","type":"common"}]}