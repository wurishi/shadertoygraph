{"ver":"0.1","info":{"id":"cdlXzl","date":"1669946224","viewed":141,"name":"[phreax] breakthrough","username":"phreax","description":"Based on my earlier experiment: https://www.shadertoy.com/view/msXXzs\nand n-fold symmetry addition from mla: https://www.shadertoy.com/view/cdlSzl\n\nSee epic music-synced version here: https://www.instagram.com/reel/ClpX8-Do-N8/?igshid=YmMyMTA2M2Y=","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["mandala","multipass","zucconi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n\n// Based on https://www.shadertoy.com/view/msXXzs\n// and addtion from mla: https://www.shadertoy.com/view/cdlSzl\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define SIN(x) (sin(x)*.5+.5)\n#define BEND .8     \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 120.\n#define DISTORT 1.5\n#define COLOR 1.\n#define SPIRAL 3.\n\nfloat tt;\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nfloat triangle(vec2 uv, float w, float blur) {   \n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulate the distance\n  float d = 1.-cos(floor(.5+a/r)*r-a)*length(uv);\n  return smoothstep(blur, .0, abs(d)-w)*(0.4/blur);\n}\n\nvec3 spiral(vec2 uv, float z) {  \n\n    float fadeOut = .25*smoothstep(20., 60., iTime);\n    uv *= rot((z*TAU-.2*tt)*(SPIRAL*.3));\n\n    float soundMod = (3.*sqrt(z)+.2);\n    float dist = DISTORT * sin(.5*PI+2.*PI*fadeOut);\n    uv *= 1.3*dist*sin(vec2(5)*uv.yx+.8*tt);\n   // uv += soundMod;\n    float blur = exp(-19.*z);\n    float luma = exp(-22.5*z);\n    return triangle(uv, 0.05, blur)*spectral_zucconi6(fract(2.*z+.2*tt+uv.x*.2))*luma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec4 tex = texture(iChannel0, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0);\n    tt = iTime*.2;\n\n    uv *= .9;\n\n    float N = 12.0;\n    float a = atan(uv.x, - uv.y) + .5*tt;\n    a = mod(a+PI/N, TAU/N)- PI/N;\n    \n    // log scale\n    float tz = log(tt/2.)*2.;\n    uv = length(uv)*vec2(cos(a),sin(a))*tz;\n    uv = abs(uv)-0.25;\n    uv = abs(uv)-0.15;\n\n    uv *= 30.0;\n\n    float s = 1./COUNT;\n    \n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(1., .9, z);\n        vec2 UV = uv;\n        col += spiral(UV*z, z)*fade;\n        \n    }\n    \n    col = pow(col, vec3(0.5));\n    \n    // before the breakthrough\n    if(tt < 2.){\n        col = 1.05-col;\n        col = pow(col, vec3(2.2));\n        col = clamp(col, vec3(0), vec3(1));\n    }\n    \n    col = mix(col, tex.rgb, 0.7);\n    \n   \n    // Output to screen\n    fragColor = vec4(col, iResolution.x);\n}","name":"Buffer A","description":"","type":"buffer"}]}