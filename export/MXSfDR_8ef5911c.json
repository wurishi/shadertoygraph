{"ver":"0.1","info":{"id":"MXSfDR","date":"1729322185","viewed":57,"name":"Betanuri_RMarch_Test","username":"sobayaOnJupiter","description":"ray marching exercise of sobaya special","likes":3,"published":1,"flags":4,"usePreview":0,"tags":["sobayaspecial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.141592;\n\nvec3 ex = vec3(1.0,0.0,0.0);\nvec3 ey = vec3(0.0,1.0,0.0);\nvec3 ez = vec3(0.0,0.0,1.0);\nvec3 one3 = vec3(1.0);\n\nfloat atan2(in float y, in float x){\n    return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nvec3 rotate3d (vec3 v, vec3 n, float a) {\n\treturn v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n// 球の距離関数\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sobayaSDF(vec3 p, float radius){\n    float dist = 99999.0;\n    for(float i0 = 0.0; i0<8.0; i0++){\n        vec3 pos = vec3(sin(iTime*1.34 + pow(i0,1.1)),\n                sin(iTime*1.44 + 44.9*pow(i0,1.13)),\n                sin(iTime*1.57 + 13.5*pow(i0,1.17)));\n        dist = smin(sphereSDF(p-pos, radius),dist,0.15);\n    }\n    dist = min(dist, sdBoxFrame(rotate3d(p,vec3(cos(iTime),0.0,sin(iTime)),iTime),vec3(3.5),0.2));\n    dist = min(dist, sdBoxFrame(rotate3d(p,vec3(cos(iTime),sin(iTime),0.0),iTime),vec3(3.5),0.2));\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(0.0, -7.0, -15.0);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 1.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n    \n    // レイマーチングのループ\n    float t = 0.0;\n    vec3 currPos = cp;\n    int maxSteps = 18;\n    bool hit = false;\n    float maxDistance = 20.0;\n    float epsilon = 0.001;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 currentPos = cp + t * rd;\n        float distance = sobayaSDF(currentPos, 1.1 + 2.0*pow(sin(iTime*12.4)*0.5+0.5, 0.13)); // 半径1.0の球体\n        if (distance < epsilon) {\n            hit = true;\n            break;\n        }\n        t += distance;\n        if (t > maxDistance) break;\n    }\n    \n    // ヒットしたかどうかで色を決定\n    if (hit) {\n        col = vec3(1.0, 0.0, 0.0); // 赤色\n    } else {\n        col = vec3(0.0); // 黒色\n    }\n    \n    // フラグメントカラーを設定\n    fragColor = vec4(col, 1.0);\n}\n\n\nvoid mainImage1019( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // 時間を取得\n    float time = iTime * 8.0;\n    \n    float coeffDelete = max(0.0, (sin(uv.y*48.0) + sin(uv.y*51.10) + sin(uv.y*31.20) + sin(uv.y*27.0))/4.0 -2.3 + 8.0*texture(iChannel0, vec2(0.6, 0.0)).r);\n    float distortF = max(0.0, sin(sin(uv.y*7.0)*0.5 + uv.y*10.0 + time + 0.2*sin(time*1.6))) * 0.3 * coeffDelete;\n    vec3 distort = vec3(distortF);\n    \n    vec2 p = uv;\n    vec3 pD = p.x + distort* vec3(0.6, 1.0, 1.4);\n\n    // 時間に基づいて色を計算\n    float valX = 0.5 + 0.5 * sin(time + sin(time + 0.8*sin(1.2*time + sin(time*0.3)*0.4)*0.8) + 7.0 * pD.x * 3.14);\n    float valY = 0.5 + 0.5 * sin(time + sin(time + 0.8*sin(1.2*time + sin(time*0.3)*0.4)*0.8) + 7.0 * pD.y * 3.14);\n    float valZ = 0.5 + 0.5 * sin(time + sin(time + 0.8*sin(1.2*time + sin(time*0.3)*0.4)*0.8) + 7.0 * pD.z * 3.14);\n    vec3 color = vec3(valX,valY,valZ);\n\n    // ピクセルに色を適用\n    fragColor = vec4(color, 1.0);\n}\n\n/*\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p-0.5.xx;\n    float PI = 3.141592;\n\n    // Time varying pixel color\n    float angleThre = mod(iTime,2.*PI)/(2*PI);  \n    float myAngle = atan2(p.y,p.x);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}