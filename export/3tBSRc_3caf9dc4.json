{"ver":"0.1","info":{"id":"3tBSRc","date":"1566520274","viewed":174,"name":"Sphere in a Mirrored Torus","username":"Xerxes314","description":"Move the camera with WASD+QE+Space+Shift+Mouse. Modified from https://www.shadertoy.com/view/WljSW1 by Gijs","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","reflection","mirror","donut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec4 buf = texture(iChannel0,fragCoord.xy / iResolution.xy);\n \n  vec3 col = buf.xyz/buf.w;\n  col = pow(col,vec3(1./GAMMA)); \n    \n  fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Render\n#define DETAIL       0.125\n#define MAX_STEPS    512\n#define MAX_DEPTH    16\n#define MAX_MARCH    30.\n\n// Torus\n#define TORUS_MAJOR_RADIUS      2.\n#define TORUS_MINOR_RADIUS      1.\n#define MIRROR_COLOR            vec3(.85);\n#define RIM_COLOR               vec3(.55,.15,.15);\n#define TORUS_SURFACE_THICKNESS 0.05\n\n// Ball\n#define BALL_POSITION vec3(0,0,TORUS_MAJOR_RADIUS)\n#define BALL_RADIUS   TORUS_MINOR_RADIUS/2.\n#define BALL_COLOR    vec3(.75,.25,.25)\n#define BALL_COLOR2   vec3(.15,.45,.15)\n#define BALL_COLOR3   vec3(.25,.25,.75)\n#define BALL_COLOR4   vec3(.15,.15,.15)\n\n// Lighting\n#define SUN_VECTOR    vec3(0.57735026919)\n#define SUN_COLOR     vec3(1)\n#define AMBIENT_COLOR vec3(.1)\n#define SKY_COLOR     vec3(.45,.56,1.) \n\n// Camera\n#define MOVEMENT_SPEED 10.\n#define MAX_SPEED      8.\n#define MIN_SPEED      1e-4\n\n// Post\n#define GAMMA 2.2\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v) {\n  float c = cos(angle);\n  vec3 s = sin(angle) * v;\n  vec3 d =  (1.0 - c) * v;\n  return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\nvec3 project(vec3 p) {\n  return vec3(p.x, 0, p.z);\n}\n\nfloat torusmirror(vec3 p) {\n  vec3 q = project(p);\n  q = TORUS_MAJOR_RADIUS*normalize(q);\n  return max(abs(length(q - p) - TORUS_MINOR_RADIUS), p.x);\n}\n\nfloat torusrim(vec3 p) {\n  vec3 q = project(p);\n  q = TORUS_MAJOR_RADIUS*normalize(q);\n  return max(abs(length(q - p) - (TORUS_MINOR_RADIUS + TORUS_SURFACE_THICKNESS)), p.x);\n}\n\nfloat ball(vec3 p) {\n  return length(p-BALL_POSITION) - BALL_RADIUS;\n}\n\nfloat getDistance(vec3 p) {\n  return min(min(torusmirror(p), torusrim(p)), ball(p));\n}\n\nvec3 getNormal(vec3 p) {\n  if (ball(p) < 1e-3) return normalize(p - BALL_POSITION);\n  vec3 q = project(p);\n  q = TORUS_MAJOR_RADIUS*normalize(q);\n  if (torusmirror(p) < 1e-3)   return normalize(q - p);\n  return normalize(p - q);\n}\n\nvec4 getMaterial(vec3 p) {\n  float distance = 100.;  // visibility horizon\n  vec3  color    = vec3(1);\n  int   material = 0;\n    \n  float ballDistance = ball(p);\n  if (ballDistance < distance) {\n    distance = ballDistance;\n    if ((p-BALL_POSITION).y > 0.0) {\n      if ((p-BALL_POSITION).z > 0.0) {\n        color = BALL_COLOR;\n      } else {\n        color = BALL_COLOR3;\n      } } else {\n      if ((p-BALL_POSITION).z > 0.0) {\n        color = BALL_COLOR2;\n      } else {\n        color = BALL_COLOR4;\n      } }\n    if ((p-BALL_POSITION).x > 0.0)\n      color /= 4.0;\n    material = 0;\n  }\n    \n  float mirrorDistance = torusmirror(p);\n  if (mirrorDistance < distance){\n    distance = mirrorDistance;\n    color    = MIRROR_COLOR;\n    material = 1;\n  }\n  \n  float rimDistance = torusrim(p);\n  if (rimDistance < distance){\n    distance = rimDistance;\n    color    = RIM_COLOR;\n    material = 0;\n  }\n\n  return vec4(material, color);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ray-marching algorithm\n\nfloat hash(uint n) {\n  n = (n << 13U) ^ n;\n  n = n * (n * n * 15731U + 789221U) + 1376312589U;\n  return uintBitsToFloat((n >> 9U) | 0x3f800000U) - 1.0;\n}\n\nvoid raymarch(in vec3 p, in vec3 d, float eps, inout int steps, inout float dis, inout float meps, inout float t) {\n  for (; steps < MAX_STEPS; steps++) {\n    dis = getDistance(p + d*t);\n    t += dis;\n    meps = abs(t)*eps;\n\n    if (dis < meps) {\n      t -= (meps-dis);\n      break;\n    }\n\n    if (t > MAX_MARCH) break;\n  }\n}\n\nvec3 raymarcher(vec3 p, vec3 d, float eps) {\n  vec3 a = vec3(1.);\n\n  for (int depth = 0; depth < MAX_DEPTH; depth++) {\n    int steps = 0;\n    float dis = 0.;\n    float meps = 0.;\n    float t = 0.;\n    raymarch(p, d, eps, steps, dis, meps, t);\n    vec3 hitPos = p + d * t;\n\n    if (dis < meps) {\n      vec4 hitMaterial = getMaterial(hitPos);\n      vec3 hitColor = hitMaterial.yzw;\n      vec3 hitNormal = getNormal(hitPos);\n      vec3 reflectDir = reflect(d, hitNormal);\n\n      if (hitMaterial.x == 0.) {\n        float diffuse = max(dot(hitNormal, SUN_VECTOR), 0.);\n        float specular =\n            diffuse > 0. ? pow(max(dot(reflectDir, SUN_VECTOR), 0.), 32.) : 0.;\n        vec3 c = hitColor * SUN_COLOR * diffuse + hitColor * AMBIENT_COLOR\n                 + SUN_COLOR * specular * .3;\n        return a *= c;\n      } else if (hitMaterial.x == 1.) {\n        a *= hitColor;\n        p = hitPos;\n        d = reflectDir;\n      }\n    } else {\n      return a*SKY_COLOR;\n    }\n  }\n  return a;\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragCoord) {\n  float minResolution = min(iResolution.x, iResolution.y);\n  float eps = DETAIL/minResolution;\n\n  // Camera\n  vec3 cameraPosition = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n  vec3 cameraForward = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n  vec3 cameraRight = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n  vec3 cameraUpward = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n\n  // Seed\n  uvec2 up = uvec2(fragCoord);\n  uvec2 res = uvec2(iResolution);\n  uint seed = up.x + res.x*up.y + res.x*res.y*uint(iFrame);\n\n  // Anti-aliasing\n  vec2 p = fragCoord + vec2(hash(seed++),hash(seed++)) - 0.5;\n  // Scaling\n  vec2 sp = (p*2.-iResolution.xy)/minResolution;\n\n  // Pixel Ray\n  vec3 direction = normalize(cameraForward+sp.x*cameraRight+sp.y*cameraUpward);\n\n  // Final\n  fragcolor = vec4(raymarcher(cameraPosition, direction, eps), 1.0);\n\n  // Keep previous frame if no movement detected\n  if(!(texture(iChannel1,vec2(0)).w > .0)) {\n    fragcolor += texture(iChannel0,fragCoord/iResolution.xy);\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {    \n  ivec2 p = ivec2(fragCoord);\n    \n  if (p.x > 3 || p.y > 0) return;\n    \n  vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  vec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n  vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n  vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    \n  if (iFrame==0) {\n    cameraPosition = vec3( 1, 0, -TORUS_MAJOR_RADIUS);\n    cameraForward  = vec3( -1, 0, 0);\n    cameraRight    = vec3( 0, 0, 1);\n    cameraUpward   = vec3( 0, 1, 0);\n  } \t\t\n    \n  bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n  bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n  bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n  bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n  bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n  bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n  bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n  bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n  bool mouseLeft   = iMouse.z>0.;\n  bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n  float stepSize = clamp(\n    getDistance(cameraPosition)*MOVEMENT_SPEED,\n    MIN_SPEED,\n    MAX_SPEED)*iTimeDelta;\n    \n  cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n                     cameraRight  *(float(right)   - float(left)    ) +\n                     cameraUpward *(float(up)      - float(down)    )\n                    )*stepSize;\n    \n  float r = (float(rollleft)-float(rollright))*0.01;\n  cameraRight  = rotate(cameraRight , r, cameraForward);\n  cameraUpward = rotate(cameraUpward, r, cameraForward);\n    \n  if (mouseLeft) {\n    vec2 s = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n      \n\tcameraForward = rotate(cameraForward, s.x*0.02, cameraUpward);\n    cameraRight  = normalize(cross(cameraUpward, cameraForward));\n        \n\tcameraForward = rotate(cameraForward,-s.y*0.02, cameraRight);\n\tcameraUpward = normalize(cross(cameraForward, cameraRight));\t\t\n  }\n    \n  if (p.x==0){\n    fragColor.rgb = cameraPosition;\n  } else if (p.x==1) {\n    fragColor.rgb = cameraForward;\n  } else if(p.x==2) {\n    fragColor.rgb = cameraRight;\n  } else if(p.x==3) {\n    fragColor.rgb = cameraUpward;\n  }  \n  fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"}]}