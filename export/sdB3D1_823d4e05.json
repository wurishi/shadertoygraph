{"ver":"0.1","info":{"id":"sdB3D1","date":"1617325490","viewed":92,"name":"julia set or something, idk","username":"peabrainiac","description":"my attempt at rendering a fractal I thought of months ago - a hybrid of the mandelbrot and mandelbar sets, generated by applying both formulas each iteration and then seeing which takes longer to diverge.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fractal","juliaset","mandelbrotset","mandelbarset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 255\n\n/* See the other buffer. Turns out I didn't need this one, lol. */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ITER 72\n#define ZOOM 0.14\n\n/*\n * The idea for this fractal is to, instead of applying a single formula like z'=z^2+c or z'=(z^2)*+c to z each iteration,\n * just apply both and see which one of these takes longer to diverge when continuing the same way,\n * applying both formulas each iteration. Iterating it this way would of course be super slow,\n * with O(2^n)-complexity regarding the iteration count, making the fractal far less than ideal to explore.\n * \n * This is my attempt at speeding up this process at least for the julia sets by storing the iterations for each pixel\n * in a buffer and updating it one iteration at a time; however, this sadly of course comes with sacrifices\n * when it comes to detail and the ability to zoom in. Maybe someone else can think of a solution?\n */\n\nfloat getIter(vec2 z);\nivec2 fractalToPixel(in vec2 fractal);\nvec2 pixelToFractal(in vec2 pixel);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 c;\n    if (iMouse.xy==vec2(0.0)){\n        float theta = iTime*0.5;\n        c = 1.25*vec2(sin(theta)-0.25,cos(theta));\n    }else{\n        c = pixelToFractal(iMouse.xy);\n    }\n    c *= min(1.0,2.0/length(c));\n    vec2 z = pixelToFractal(fragCoord);\n    if (dot(z,z)>4.0){\n        fragColor = vec4(vec3(0.0),1.0);\n    }else{\n        vec2 z1 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+c;\n        float iter1 = getIter(z1);\n        float iter2 = getIter(z2);\n        float iter = max(iter1,iter2)+1.0/float(ITER);\n        fragColor = vec4(vec3(iter),1.0);\n    }\n}\n\nfloat getIter(vec2 z){\n    return texelFetch(iChannel0,fractalToPixel(z),0).x;\n}\n\nivec2 fractalToPixel(in vec2 fractal){\n    return ivec2(fractal*length(iResolution)*ZOOM+iResolution.xy*0.5);\n}\n\nvec2 pixelToFractal(in vec2 pixel){\n    return (pixel-iResolution.xy*0.5)/ZOOM/length(iResolution);\n}","name":"Buffer A","description":"","type":"buffer"}]}