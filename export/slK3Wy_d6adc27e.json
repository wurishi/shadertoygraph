{"ver":"0.1","info":{"id":"slK3Wy","date":"1638335161","viewed":320,"name":"contradiction","username":"Carandiru","description":"cellular automata","likes":3,"published":3,"flags":48,"usePreview":0,"tags":["automata","cellular","ca"],"hasliked":0,"parentid":"NldGzN","parentname":"ca "},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// contradiction by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 t = textureLod(iChannel0, uv, 0.0f);\n    \n    \n    vec3 color;\n\n    color = vec3(t.xyz) * 0.5f + 0.5f;\n    color = color * (t.w * 0.5f + 0.25f);\n    \n    float overlay = textureLod(iChannel1, fragCoord.xy / iResolution.xy, 0.0f).r;\n    \n    color += overlay;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// contradiction by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nvec2 rotate( in vec2 p, in float angle )\n{\n    #define fma(a,b,c) (a*b+c)\n    \n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\n\n\nvoid unpack_rule(out float rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = float(bool(r & (1u << 7u)));\n    rule[1] = float(bool(r & (1u << 6u)));\n    rule[2] = float(bool(r & (1u << 5u)));\n    rule[3] = float(bool(r & (1u << 4u)));\n    rule[4] = float(bool(r & (1u << 3u)));\n    rule[5] = float(bool(r & (1u << 2u)));\n    rule[6] = float(bool(r & (1u << 1u)));\n    rule[7] = float(bool(r & (1u << 0u)));\n}\n\nvec2 state(in float rule[directions], in vec2 p, in vec2 c, in vec2 n)\n{\n    uvec2 d = uvec2(0u);\n    \n    d |= uvec2(bvec2(p)) << 2u;\n    d |= uvec2(bvec2(c)) << 1u;\n    d |= uvec2(bvec2(n)) << 0u;\n    \n    return vec2(rule[7u - d.x], rule[7u - d.y]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 auto = vec4(0);\n    \n    vec2 rr = textureLod(iChannel2, uv, 0.0f).ba;\n    \n    float rule[directions];\n    unpack_rule(rule, rr.y);\n    \n    uint frame = uint(rr.x * convert_length);\n    \n    if (frame < 4u) {\n    \n        uvec2 uuv = uvec2(fragCoord.xy);\n        \n        auto.xy = vec2(rule[uuv.x & (bits - 1u)], - rule[uuv.y & (bits - 1u)]);\n        auto.zw = vec2(- rule[uuv.x & (bits - 1u)], rule[uuv.y & (bits - 1u)]);\n        \n        auto += textureLod(iChannel1, fragCoord/1024.0f, 0.0f) * 2.0f - 1.0f;\n        \n        auto *= 0.5f;\n    }\n        \n    vec2 c = textureLod(iChannel0, uv, 0.0f).rg;\n    \n    vec4 ypi = textureLodOffset(iChannel0, uv, 0.0f, ivec2(0, 1));\n    vec2 yp = abs(ypi.rg - ypi.ba);\n    \n    vec4 yni = textureLodOffset(iChannel0, uv, 0.0f, ivec2(0,-1));\n    vec2 yn = abs(yni.rg - yni.ba);\n    \n    vec4 xpi = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1, 0));\n    vec2 xp = abs(xpi.rg - xpi.ba);\n    \n    vec4 xni = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 0));\n    vec2 xn = abs(xni.rg - xni.ba);\n\n    auto.xy += state(rule, xp, c, xn);\n    auto.zw += state(rule, yp, c, yn);\n    \n    auto.x = abs(auto.x - auto.y);\n    auto.y = abs(auto.y - auto.z);\n    auto.z = abs(auto.z - auto.w);\n    auto.w = abs(auto.w - auto.x);\n    \n    uv = uv - 0.5;\n    uv = uv * 3.0f;\n    \n    float t = 1.0f;\n    \n    {\n        vec4 ii_iv = vec4(0);\n        ii_iv.xy += mix(yp, auto.xy, uv.y - t / iResolution.y);\n        ii_iv.yz += mix(xp, auto.yz, uv.x - t / iResolution.x);\n        ii_iv.zw += mix(yn, auto.xy, -(uv.y - t / iResolution.y));\n        ii_iv.wx += mix(xn, auto.yz, -(uv.x - t / iResolution.x));\n        vec4 i_iii = vec4(0);\n        i_iii.xy += mix(yp, auto.xy, uv.y - t / iResolution.y);\n        i_iii.yz += mix(xp, auto.yz, uv.x - t / iResolution.x);\n        i_iii.zw += mix(yn, auto.xy, -(uv.y - t / iResolution.y));\n        i_iii.wx += mix(xn, auto.yz, -(uv.x - t / iResolution.x));\n\n        auto.x = min(ii_iv.x, ii_iv.z) + min(ii_iv.y, ii_iv.w);\n        auto.y = min(i_iii.x, i_iii.z) + min(i_iii.y, i_iii.w);\n    }\n    \n    {\n        vec4 ii_iv = vec4(0);\n        ii_iv.xy += mix(yp, auto.zw, uv.y - t / iResolution.y);\n        ii_iv.yz += mix(xp, auto.wx, uv.x - t / iResolution.x);\n        ii_iv.zw += mix(yn, auto.zw, -(uv.y - t / iResolution.y));\n        ii_iv.wx += mix(xn, auto.wx, -(uv.x - t / iResolution.x));\n        vec4 i_iii = vec4(0);\n        i_iii.xy += mix(yp, auto.zw, uv.y - t / iResolution.y);\n        i_iii.yz += mix(xp, auto.wx, uv.x - t / iResolution.x);\n        i_iii.zw += mix(yn, auto.zw, -(uv.y - t / iResolution.y));\n        i_iii.wx += mix(xn, auto.wx, -(uv.x - t / iResolution.x));\n\n        auto.z = min(ii_iv.x, ii_iv.z) + min(ii_iv.y, ii_iv.w);\n        auto.w = min(i_iii.x, i_iii.z) + min(i_iii.y, i_iii.w);\n    }\n    \n    auto *= 0.5f;\n        \n    fragColor = vec4(auto);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// contradiction by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define bits 8u\n#define PI (3.141592654f)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n#define directions (8)\n#define convert_length 4.294967295e9f\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// contradiction by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nint rule[directions] = int[directions]( 1, 1, 1, 0, 1, 1, 1, 0 );\n// 0001 0111\n// 0110 1111\n// 0110 1110\n\nfloat pack_rule()\n{\n    int r = 0;\n    r = (rule[0] << 7) | \n        (rule[1] << 6) |\n        (rule[2] << 5) |\n        (rule[3] << 4) |\n        (rule[4] << 3) |\n        (rule[5] << 2) |\n        (rule[6] << 1) |\n        (rule[7] << 0);\n        \n    return(float(uint(r)) / 255.0f);\n\n}\n\nvoid unpack_rule(out int rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = int(bool(r & (1u << 7u)));\n    rule[1] = int(bool(r & (1u << 6u)));\n    rule[2] = int(bool(r & (1u << 5u)));\n    rule[3] = int(bool(r & (1u << 4u)));\n    rule[4] = int(bool(r & (1u << 3u)));\n    rule[5] = int(bool(r & (1u << 2u)));\n    rule[6] = int(bool(r & (1u << 1u)));\n    rule[7] = int(bool(r & (1u << 0u)));\n}\n\n// Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\nconst int CHARS[41] = int[](\n    0x00000000, \n    0x00E8FE31, \n    0x01E8FA3E, \n    0x00F8420F, \n    0x01E8C63E,\n    \n    0x01F87A1F, \n    0x01F87A10, \n    0x00F84E2F, \n    0x0118FE31, \n    0x00421084,\n    \n    0x01F0862F, \n    0x01197251, \n    0x0108421F, \n    0x01BAD6B1, \n    0x011CD671,\n    \n    0x00E8C62E, \n    0x01E8FA10, \n    0x00E8D66E, \n    0x01E8FA31,\n    0x00F8383E,\n    \n    0x0000001F, \n    0x0118C62E, \n    0x0118C544, \n    0x0118C6AA, \n    0x01151151,\n    \n    0x0118A884, \n    0x01F9113F, \n    0x00ECD66E, \n    0x0046509F, \n    0x00E8991F, \n    \n    0x00E89A2E, \n    0x00232BE2, \n    0x01F8383E, \n    0x00F87E3E, \n    0x01F11108, \n    \n    0x00E8BA2E, \n    0x00F8FC3E, \n    0x00000004, \n    0x00000088, \n    0x00421004, \n    0x00E11004\n);\n\nfloat character(float color, float background, int character, vec2 position, float size, vec2 uv)\n{\n    if((uv.x > position.x && uv.x < position.x + size) && (uv.y > position.y && uv.y < position.y + size))\n    {\n        ivec2 pixel = ivec2(ceil((uv.x-position.x)/size*5.0)-1.0, ceil((1.0-(uv.y-position.y)/size)*5.0)-1.0);\n        int bit_index = pixel.y*5 + pixel.x;\n        int bit = (CHARS[character] >> (24 - bit_index))&1;\n        if(bit > 0)\n            return color;\n    }\n    return background;\n}\n\n#define EOL 0\n#define _ 0,\n#define A 1,\n#define B 2,\n#define C 3,\n#define D 4,\n#define E 5,\n#define F 6,\n#define G 7,\n#define H 8,\n#define I 9,\n#define J 10,\n#define K 11,\n#define L 12,\n#define M 13,\n#define N 14,\n#define O 15,\n#define P 16,\n#define Q 17,\n#define R 18,\n#define S 19,\n#define T 20,\n#define U 21,\n#define V 22,\n#define W 23,\n#define X 24,\n#define Y 25,\n#define Z 26,\n\n#define DOT 37,\n#define COMMA 38,\n#define BANG 39,\n#define QUESTION 40,\n\n#define EOL1 0\n#define EOL2 EOL1,EOL1\n#define EOL3 EOL2,EOL1\n#define EOL4 EOL3,EOL1\n#define EOL5 EOL4,EOL1\n#define EOL6 EOL5,EOL1\n#define EOL7 EOL6,EOL1\n#define EOL8 EOL7,EOL1\n#define EOL9 EOL8,EOL1\n#define EOL10 EOL9,EOL1\n#define EOL11 EOL10,EOL1\n#define EOL12 EOL11,EOL1\n#define EOL13 EOL12,EOL1\n#define EOL14 EOL13,EOL1\n#define EOL15 EOL14,EOL1\n#define EOL16 EOL15,EOL1\n#define EOL17 EOL16,EOL1\n#define EOL18 EOL17,EOL1\n#define EOL19 EOL18,EOL1\n#define EOL20 EOL19,EOL1\n#define EOL21 EOL20,EOL1\n#define EOL22 EOL21,EOL1\n#define EOL23 EOL22,EOL1\n#define EOL24 EOL23,EOL1\n#define EOL25 EOL24,EOL1\n#define EOL26 EOL25,EOL1\n#define EOL27 EOL26,EOL1\n#define EOL28 EOL27,EOL1\n#define EOL29 EOL28,EOL1\n#define EOL30 EOL29,EOL1\n\n#define LEN0 EOL30\n#define LEN1 EOL29\n#define LEN2 EOL28\n#define LEN3 EOL27\n#define LEN4 EOL26\n#define LEN5 EOL25\n#define LEN6 EOL24\n#define LEN7 EOL23\n#define LEN8 EOL22\n#define LEN9 EOL21\n#define LEN10 EOL20\n#define LEN11 EOL19\n#define LEN12 EOL18\n#define LEN13 EOL17\n#define LEN14 EOL16\n#define LEN15 EOL15\n#define LEN16 EOL14\n#define LEN17 EOL13\n#define LEN18 EOL12\n#define LEN19 EOL11\n#define LEN20 EOL10\n#define LEN21 EOL9\n#define LEN22 EOL8\n#define LEN23 EOL7\n#define LEN24 EOL6\n#define LEN25 EOL5\n#define LEN26 EOL4\n#define LEN27 EOL3\n#define LEN28 EOL2\n#define LEN29 EOL1\n#define LEN30 EOL0\n\nvec2 uv = vec2(0);\nfloat text_color = float(0.0);\nconst float TEXT_COLOR = float(0.95);\nconst float TEXT_SIZE = 0.03;\nconst float TEXT_SIZE2 = 0.03 + 0.04/5.0;\nvec2 TEXT_POSITION = vec2(0.0);\n\nvoid text(int LINE[directions*2]) {\n \tfor(int i = 0; i < (directions*2); i++)\n        text_color = character(TEXT_COLOR, text_color, LINE[i], vec2(0,1) + TEXT_POSITION*vec2(1,-1) + vec2(TEXT_SIZE2 * float(i), 0.), TEXT_SIZE, uv);\n}\n\n#define TEXT(x,y) text(int[](x y));\n#define TEXT2(x) text(x);\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 10) {\n        fragColor = vec4(vec2(0), float(uint(iFrame)) / convert_length, pack_rule());\n        return;\n    }\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 last = textureLod(iChannel0, uv, 0.0f).gb;\n    uint frame = uint(last.y * convert_length);\n        \n    int bit = int( last.x * 7.0f );\n    \n    bit = max(0, bit - int(texelFetch( iChannel1, ivec2(KEY_LEFT,1),0 ).x)); // press\n    bit = min(directions - 1, bit + int(texelFetch( iChannel1, ivec2(KEY_RIGHT,1),0 ).x)); // press\n    \n    // selector\n    TEXT_POSITION = vec2(0.195f, 0.9925f);\n    {\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        binary[bit * 2] = 20;\n\n        TEXT2(binary);\n        \n        text_color *= 1.0f - max(sin(iTime * 9.0f), 0.0f);\n    }\n    \n    float frame_next = 0.0f;\n    \n    // digits\n    TEXT_POSITION = vec2(0.195f, 0.97f);\n    {\n        float r = textureLod(iChannel0, uv, 0.0f).a;\n        unpack_rule(rule, r);\n        \n        int dir = 0, reset = 0;\n        dir = int(texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x);\n        //reset |= dir & ~rule[bit];\n        rule[bit] |= dir;\n                \n        dir = int(texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x);\n        //reset |= dir & rule[bit];\n        rule[bit] &= ~dir;\n        \n        if (0 == reset) {\n        \n            bool moused = bool((iMouse.z * iTimeDelta) >= 0.5f);\n            frame_next = float(frame) + float(!moused) * (1.0f + iTimeDelta);\n            \n        }\n        \n        const int select[2] = int[2]( 15, 9 );\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        for (int n = 0 ; n < directions ; ++n) {\n            binary[n+n] = select[rule[n]];\n        }\n\n        TEXT2(binary);\n    }\n    \n    fragColor = vec4(text_color, float(bit) / 7.0f, frame_next / convert_length,\n                     pack_rule());\n}","name":"Buffer B","description":"","type":"buffer"}]}