{"ver":"0.1","info":{"id":"WdfSRX","date":"1551898295","viewed":126,"name":"GreeD3X is a retard","username":"GreeD3X","description":"RayMarching of some basic figures. Controls: WASD to move around, Z to go upper X to to move down, E to make speed higher, Q to slow down, click and drag to change view direction.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","mashgraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define CLOSEST .0001\n//#define CLOSEST   .01\n#define txCameraPos ivec2(0, 0)\n#define txMouse ivec2(0, 1)\n\nvec3 ROTATE(vec3 p, vec3 around, float angle){\n\tmat3 rotate = mat3(cos(angle)+around.x*around.x*(1.0-cos(angle)),around.x*around.y*(1.0-cos(angle))-around.z*sin(angle),around.x*around.z*(1.0-cos(angle))+around.y*sin(angle),\n                  around.y*around.x*(1.0-cos(angle))+around.z*sin(angle),cos(angle)+around.y*around.y*(1.0-cos(angle)),around.y*around.z*(1.0-cos(angle))-around.x*sin(angle),\n                  around.z*around.x*(1.0-cos(angle))-around.y*sin(angle),around.z*around.y*(1.0-cos(angle))+around.x*sin(angle),cos(angle)+around.z*around.z*(1.0-cos(angle)));\n    return rotate*p;\n}\n\nfloat length2( vec2 p )  // sqrt(x^2+y^2) \n{\n  return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )  // (x^6+y^6)^(1/6)\n{\n  p = p*p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )  // (x^8+y^8)^(1/8)\n{\n  p = p*p; \n  p = p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c ){\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCone( in vec3 p, in vec3 c ){\n  vec2 q = vec2( length(p.xz), p.y );\n  #if 0\n    return max( max( dot(q, c.xy), p.y), -p.y -c.z );\n  #else\n    float d1 = -p.y - c.z;\n    float d2 = max( dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz)+n.w;//sin(p.x)*cos(p.z);//\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ){\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat atan2(float a, float b){\n\treturn atan(a/b);\n}\n/*\nfloat sdMandel(in vec3 p, float powa, float c){\n    float r = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n\tfloat theta = atan2( sqrt(p.x*p.x+p.y*p.y), p.z );\n\tfloat phi = atan2(p.y,p.x);\n\n\t vec3 r_n = pow(r,powa)*vec3(sin(theta*powa) * cos(phi*powa),\n                              sin(theta*powa) * sin(phi*powa),\n                              cos(theta*powa));\n    return r_n - c;\n}\n*/\n\n\n//distance formulas from wikipedia and http://blog.hvidtfeldts.net/index.php/category/mandelbulb/\n//and some info from https://www.researchgate.net/publication/234777691_Ray_tracing_deterministic_3-D_fractals\n//http://www.skytopia.com/project/fractal/2mandelbulb.html\nfloat DE(vec3 pos, float Power, int steps, float trap) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < steps ; i++) {\n\t\tr = length(z);\n\t\tif (r>trap) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec2 opU( vec2 d1, vec2 d2 ){\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opS( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 ){\n    return max(d1,d2);\n}\n\nfloat opTx( vec3 p, mat3 m ){\n    vec3 q = inverse(m)*p;\n    return sdTorus(q, vec2(1,1));\n}\n\nfloat opScale( vec3 p, float s ){\n    return sdTorus(p/s, vec2(1,1))*s;\n}\n\nfloat opTwist( vec3 p ){\n    float c = cos(10.0/360.0*3.14*p.y + 3.0*iTime);\n    float s = sin(10.0/360.0*3.14*p.y + 2.0*iTime);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, vec2(1.5,0.4));\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n  return mod(p, c)-0.5*c;\n}\n\n// Twist: \nvec3 opTwist( vec3 p, float angle ){\n  float  c = cos(2.0*p.y + angle);\n  float  s = sin(2.0*p.y + angle);\n  mat2   m = mat2(c, -s, s, c);\n  return vec3(m*p.xz, p.y);\n}\n\nfloat smin( float a, float b, float k ){\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec2 opBlend( vec3 p ){\n    vec2 d1 = vec2(opS(sdCapsule(p, vec3(0, 2.5, 8), vec3(0, 2.5, 10), .15),\n                                 sdCappedCylinder(p - vec3(0,2.5,9), vec2(0.5,0.5))),17);\n    vec2 d2 = vec2(sdCone((1.0/8.0)*(p - vec3(0,4.,9.4)),(normalize(vec3(6.0, 1.5, 0.9)))),60);\n    vec2 res;\n    res.x = smin(d1.x,d2.x,52.2);\n    res.y = abs(d1.x - res.x) <= 1e-2 ? d1.y : d2.y;\n    return res;\n}\n\nvec2 map(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    vec2 discol = vec2(sdPlane(p, normalize(vec4(0.0,1.0,0.0,.0))),1.0);\n    \n    //discol = opU(discol, vec2(sdCapsule(p, vec3(3, .5, 6), vec3(3, 2.5, 6), .5),1.0)); \n    \n    //This one is moving MandelBulb activate if you feel lucky)\n    //discol = opU(discol, vec2(DE(ROTATE(p - vec3(5.0,2.0,6.0),vec3(0,1,0),1.6)\n    //                             ,8.0*(1.0+abs(cos(0.5*iTime)+sin(0.5*iTime))),300,210.0), 20));\n    \n    //Static MandelBulb\n    discol = opU(discol, vec2(DE(ROTATE(p - vec3(5.0,2.0,6.0),vec3(0,1,0),-1.6)\n                                 ,8.0,12, 2.1), \n                              4.0 + p.z*p.y*6.0*abs(cos(0.25*p.x*( 6.0*abs(cos(0.45*iTime)))))));\n    \n    discol = opU(discol, vec2(sdTorus(ROTATE(p-vec3(0.6,2.0,6),normalize(vec3(1.0,-1.0,-0.7)), (10.0*iTime)), vec2(1.5, .4)),25));\n    //td = opTwist(p - vec3(0,1.5,6));\n    discol = opU(discol, vec2(udRoundBox(p-vec3(-3.5, 1, 6), vec3(1,.75,1),0.2),40));\n    //discol = opU(discol, vec2(opS(sdCapsule(p, vec3(0, 2.5, 8), vec3(0, 2.5, 10), .15),\n    //                             sdCappedCylinder(p - vec3(0,2.5,9), vec2(0.5,0.5))),17));\n    //discol = opU(discol, vec2(sdCone((1.0/8.0)*(p - vec3(0,3.5,9.0)),(normalize(vec3(6.0, 1.5, 0.9)))),60));\n    discol = opU(discol, opBlend(p));\n    discol = opU(discol, vec2(opS(sdSphere(p-vec3(0.6,2.0,6), 0.8+0.02*(sin(10.5*iTime)+1.0)),\n                                  udRoundBox(p-vec3(0.6,2.0,6), vec3(0.5,.5,0.5),0.25)),210.4));\n\t//discol = opU(discol, vec2(0.25*sdTorus( opTwist(p-vec3(0.6,2.0,6.0),4.0*sin(iTime)), vec2(1.30, 0.15)), 6));\n    return discol;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);  \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 dO=vec2(0.);\n    float err = CLOSEST;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        vec2 dS = map(p);\n        if(dO.x>MAX_DIST || dS.x<err) break;\n        dO.y  = dS.y;\n        dO.x += dS.x;\n        err = 0.1*CLOSEST*length(p);//error gets higher with distance from origin\n    }\n    return dO;\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 n )\n{\n  float occ = 0.0;\n  float scale = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    //we are moving in the direction of normal from pos and are checking if there is any object closer then pos\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  n * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*scale;\n    scale *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k ){\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<28; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.025, 1.0 );\n\t\tif( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat GetDifLight(vec3 p, vec3 lightPos, vec3 n) {\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*CLOSEST*2., l).x;\n    if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    dif = dif/ pow(length(lightPos - p),2.0);\n    return dif;\n}\n\nvec3 SetLight(float m,vec3 pos, vec3 rd, vec3 n, vec3 lig, vec3 ref){\n\tvec3 nl = normalize(lig);\n    float occ = calcAO( pos, n );\n    float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n    float dif = clamp( GetDifLight(pos,lig,n), 0.0, 1.0 );\n    float bac = clamp( dot( n, normalize(vec3(-nl.x, 0.0, -nl.z))), 0.0, 1.0 )\n   \t\t       *clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(n, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, nl ), 0.0, 1.0 ), 16.0);\n\t\n    dif *= softshadow( pos, nl, 0.02, 15.5 );\n    dom *= softshadow( pos, ref, 0.02, 20.0 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 12.0*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 12.9*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.06*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.12*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.50*fre*vec3(1.00, 1.00, 1.00)*occ;\n    //brdf += 0.102;\n    return brdf;\n}\n\n//basically is the same as previous light\nvec3 SetGlobalLight(float m,vec3 pos, vec3 rd, vec3 n, vec3 ref){\n    //\"sunlight\" vector\n    vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n    float occ = calcAO( pos, n );\n    float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n    float dif = clamp( dot(lig,n), 0.0, 1.0 );\n    float bac = clamp( dot( n, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 )\n   \t\t       *clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(n, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n\t\n    dif *= softshadow( pos, lig, 0.02, 15.5 );\n    dom *= softshadow( pos, ref, 0.02, 20.0 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 12.0*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 12.9*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.06*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.12*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.50*fre*vec3(1.00, 1.00, 1.00)*occ;\n    //brdf += 0.102;\n    return brdf;\n}\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    \n    //base col\n  \tvec3 col = vec3(0.8, 0.9, 1.0);\n  \tvec2 res = RayMarch(ro, rd);\n  \tfloat dist = res.x;\n  \tfloat mat = res.y;\n  \tif ( mat>-0.5 )\n  \t{\n    \tvec3 pos = ro + dist*rd;\n    \tvec3 n = GetNormal( pos );\n    \tvec3 ref = reflect( rd, n );\n\n    \t// material        \n    \tcol = 0.45 + 0.3*sin( vec3(0.05, 0.18, 0.10)*(mat-1.0) );\n\n    \tif ( mat<1.5 ){\n            //floor\n    \t  \t//the commented code is for checkers-like floor  \n    \t\tfloat f = mod(floor(5.0*cos(pos.z)+5.0*sin(pos.x)),9.0);//mod( floor(5.0*cos(pos.z)) + floor(5.0*sin(pos.x)), 2.0);\n    \t\tcol = 0.25 + 0.1*(f+3.0)*\n            vec3(0.3+0.2*sin(iTime),\n                 0.2+abs(0.3*cos(0.025*(3.0*(pos.x - 0.6)*(pos.x - 0.6) + (pos.z - 6.0)*(pos.z - 6.0)))),\n                 0.6+0.15*sin(0.5*iTime));\n    \t} \n\n    \t// lighting        \n    \t//ambient occlusion doesnt rely on light source just normals\n    \tvec3  lig = vec3(cos(iTime), 3.0+2.0*sin(3.0*iTime), 2.0*sin(iTime)) ;\n        vec3 brdf = 0.06 + 0.5*SetLight(mat,pos, rd, n, lig, ref) \n            +0.4*SetLight(mat,pos, rd, n, vec3(0.6,2,6), ref) \n            +0.1*SetGlobalLight(mat,pos, rd, n, ref);\n\n    \tcol = col*brdf;\n    \tcol = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.005*dist*dist ) );\n\t}\n \treturn vec3( clamp(col, 0.0, 1.0) );\n}\n\n\nvec4 loadValue( in ivec2 re ){\n    return texelFetch( iChannel0, re, 0 );\n}\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {\n    ro = loadValue(txCameraPos).xyz;\n    vec2 m = loadValue(txMouse).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \t\n   \tvec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    \n    Camera(fragCoord, ro, rd);\n    \n    float d = RayMarch(ro, rd).x;\n    \n    vec3 p = ro + rd * d;\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lightPos1 = vec3(0.6,2.0,6);\n\n    vec3 col = render(ro,rd);\n    \n    \n  \tcol = pow( col, vec3(2.4545) );\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//frame setup is from https://www.shadertoy.com/view/XtXyW4\n//Nice mouse from https://www.shadertoy.com/view/4lVXRm\n#define Is(x) (ivec2(fragCoord) == x)\n\n#define txCameraPos ivec2(0,0)\n#define Vmouse ivec2(0,1)\n#define Pmouse ivec2(0,2)\n#define txTarget ivec2(0,3)\n#define txSpeed ivec2(0,4)\n\nconst float Key_W            = 87.5 / 256.0;\nconst float Key_E            = 69.5 / 256.0;\nconst float Key_Q            = 81.5 / 256.0;\nconst float Key_A            = 65.5 / 256.0;\nconst float Key_S            = 83.5 / 256.0;\nconst float Key_D            = 68.5 / 256.0;\nconst float Key_LEFT         = 37.5 / 256.0;\nconst float Key_UP           = 38.5 / 256.0;\nconst float Key_RIGHT        = 39.5 / 256.0;\nconst float Key_DOWN         = 40.5 / 256.0;\nconst float Key_Z            = 88.5 / 256.0;\nconst float Key_X            = 90.5 / 256.0;\n\nvec3 GetLastPos(){\n\treturn texelFetch(iChannel0, txCameraPos, 0).xyz;\n}\n\nbool ReadKey( float key ){//, bool toggle \n\tbool toggle = true;\n\tfloat keyVal = textureLod( iChannel1, vec2( key, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat IsKeyPressed(float key){\n    return texture(iChannel1, vec2(key, 0.0)).r;\n}\n\nvec3 SetSpeed(){\n\t\n\tfloat forward = IsKeyPressed(Key_W) - IsKeyPressed(Key_S);\n\tfloat right = -IsKeyPressed(Key_A) + IsKeyPressed(Key_D);\n\tfloat up = - IsKeyPressed(Key_X) + IsKeyPressed(Key_Z);\n    \n    return normalize(vec3(forward, right, up));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * SetSpeed().yzx;\n}\n\nvoid updatePos(inout vec4 pos){\n    vec3 prevPos = GetLastPos().xyz;\n   \tvec3 velo = SetSpeed(); \n    vec4 vm = (texelFetch(iChannel0, Vmouse,0));\n    vec3 move = normalize(CameraDirInput(vm.xy));\n    float speed = (texelFetch(iChannel0, txSpeed,0)).x;\n    \n    float delta     = speed * iTimeDelta * step(0.001, length(move));\n    \n    if(delta > 0.0)//Why do i even need a delta there?\n    \tpos.xyz = prevPos + delta*move*8.0;//prevPos + speed*move;//\n\treturn;\n}\n\nvoid SetupFirstFrame(in vec2 fragCoord, inout vec4 fragColor){\n    if(Is(txCameraPos))\n    {\n        fragColor.xyz = vec3(0.0, 4.0, 0.0);\n        return;\n    }\n    if(Is(Vmouse))\n    {\n        fragColor.xyz = vec3(0.0, 0.0, 0.0);\n        return;\n    }    \n    if(Is(Pmouse))\n    {\n        fragColor.xyz = vec3(0.0, 0.0, 0.0);\n        return;\n    }\n    if(Is(txTarget))\n    {\n        fragColor.xyz = vec3(0.0, 5.0, 0.0);\n    \treturn;\n    }\n    if(Is(txSpeed)){\n    \tfragColor.x = 1.0;\n        return;\n    }\n}\n\nvoid updateMouse(in vec2 fragCoord, inout vec4 fragColor){\n    vec2 pm = texelFetch(iChannel0, Pmouse, 0).xy;\n    vec3 vm = texelFetch(iChannel0, Vmouse, 0).xyz;\n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n        if(Is(Vmouse)){\n            fragColor = vec4(pm + (iMouse.zw - iMouse.xy), 1.0, 0.0);\n            return;\n        }\n    }\n    else if (vm.z != 0.0) {\n        if(Is(Pmouse)){\n            fragColor =  vec4(vm.xy, 0.0, 0.0);\n            return;\n        }\n    }\n    \n}\n\nvoid updateTarget(inout vec4 fragColor){\n    vec3 vm          = texelFetch(iChannel0, Vmouse, 0).xyz;\n\tfragColor.xyz += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n}\n\nvoid updateSpeed(inout vec4 fragColor){\n\tfloat speedChange = IsKeyPressed(Key_E) - IsKeyPressed(Key_Q);\n    fragColor.x += speedChange*0.3*fragColor.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iFrame <= 1){\n\t\tSetupFirstFrame(fragCoord, fragColor);\n        return;\n    }\n    \n    if(Is(txTarget)){\n    \tupdateTarget(fragColor);\n        return;\n    }\n    if(Is(txCameraPos)){\n    \tupdatePos(fragColor);\n    \treturn;\n    }   \n    if(Is(Pmouse) || Is(Vmouse)){\n    \tupdateMouse(fragCoord, fragColor);\n    \treturn;\n    }\n    if(Is(txSpeed)){\n    \tupdateSpeed(fragColor);\n        return;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}