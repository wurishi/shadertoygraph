{"ver":"0.1","info":{"id":"DdVXRy","date":"1681322801","viewed":55,"name":"Inquisition Start Point - WIP","username":"foodini","description":"I want to use graphics as a start point for engineering interviews. A basic raymarch is probably a good place to start. I'll see how it goes.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","interview"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Intro discussion:\n// * This is a RIGHTHANDED coordinate system. If you were looking from the Z-axis, X is\n//   to your RIGHT, Y is UP, and Z is TOWARD YOU.\n// * A vec3 is used for two purposes, as a 3D \"xyz\" vector, or as an \"rgb\" color tripple.\n//   If you see a 3D vector constructed as vec3(a, b, c), x is a, y is b, z is c. If a\n//   color vector is constructed that way, red is a, green is b, and blue is c. \n\n// Things to have a student do:\n// * Explain why the ground plane has blinking band in the distance. Why does it bend\n//   toward the object? How might it be reduced? How might it be elimininated entirely\n//   with minimal computational cost?\n// * Draw a shadow on the ground plane. \n//   * Easy: just make the ground plane black if there's object above it. \n//   * Harder: choose a point in space where the \"light\" comes from.\n// * Write a function that can be used to recenter any object to <0.5, 0.5, 0.5>\n//   * Use this function to get rid of the hard-coded offset in map_ground_plane\n//   * Instance the recentered object. (In-person only.)\n// * Making the object reflective. There's an \"easy\" (somewhat challenging) solution that\n//   produces iffy results and a hard way that looks great but is more difficult and \n//   more expensive to compute - possibly VERY expensive, depending upon scene complexity.\n// * How would you support lots of unrelated objects, each with their own shading \n//   functions? What are the advantages/drawbacks of doing a trace of the whole world\n//   in one loop, versus having one loop for each compound object?\n\nconst float PI = 3.141592657;\n\n// The \"signed distance function\" for a box with rounded corners. \nfloat sdf_rounded_box( in vec3 p, in vec3 r, in float radius) {\n    return length(max(abs(p) - r, 0.0)) - radius;\n}\n\nfloat sdf_sphere( in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat map_composite_object( in vec3 p) {\n\treturn smooth_subtraction(\n        sdf_rounded_box(p, vec3(1.0), 0.425),\n        sdf_sphere(p, 1.74),\n        0.2);\n}\n\nfloat map_ground_plane( in vec3 p) {\n    return p.y + 2.0;\n}\n\nvec3 calc_normal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map_composite_object(p+h.xyy) - map_composite_object(p-h.xyy),\n             map_composite_object(p+h.yxy) - map_composite_object(p-h.yxy),\n             map_composite_object(p+h.yyx) - map_composite_object(p-h.yyx) ) );\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // We want 0,0 to be the center of the screen, so rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Rescale\n    // in the y direction to compensate:\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Set up the camera:\n    float camera_distance_from_origin = 8.0;\n    vec3 camera_position = vec3(\n        sin(iTime/2.0) * camera_distance_from_origin,\n        1.0,\n        cos(iTime/2.0) * camera_distance_from_origin);\n    vec3 camera_lookat_point = vec3(0.0, 0.0, 0.0);\n    \n    // Setting up the camera takes a bit of magic. The cross product of two vectors gives\n    // you a third vector at right angles to both of the input vectors. Our camera is at \n    // some arbitrary point in space, pointing at some other arbitrary point in space. To\n    // figure out which way is up and which way is right, we have to do some assuming. We\n    // want the camera to be level, so the right vector must be perpendicular to <0, 1, 0>\n    // AND the look direction, so let's start with that:\n    // !!!!NOTE!!!!\n    // This all goes to hell if your camera is directly above or below the lookat point,\n    // because the cross product of the look vector and <0, 1, 0> is undefined. Don't.\n    vec3 look_direction = normalize(camera_lookat_point - camera_position);\n    vec3 right = normalize(cross(look_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, look_direction));\n    \n    // To get the direction a reverse photon travels from the eyepoint, we put the uv \n    // \"screen\" in front of the eyepoint and find the vector from the eyepoint through\n    // the pixel we're currently processing:\n    float eyepoint_to_screen_distance = 2.0;\n    vec3 pixel_location = camera_position + eyepoint_to_screen_distance * look_direction +\n        right * uv.x + up * uv.y;\n    vec3 ray_direction = normalize(pixel_location - camera_position);\n    \n    // 1) Start at the camera position.\n    // 2) Check to see how far current_position is from object(s).\n    // 3) Move along the camera->pixel direction by that distance.\n    // 4) goto 2, until you've either gone too far from objects to expect to ever hit them,\n    //    or, you're so close to one that we'll assume you've hit the object.\n    // 5) If you hit the compound object, find its normal and just use that as its color,\n    //    otherwise, you hit the ground plane and choose a color that paints the grid.\n    // 6) If you've iterated too many times, give up and return blinking green to draw\n    //    attention to the issue.\n    vec3 current_position = camera_position;\n    int iterations = 0;\n    for(; iterations<250; iterations++) {\n        float comp_dist = map_composite_object(current_position);\n        float plane_dist = map_ground_plane(current_position);\n        float dist = min(comp_dist, plane_dist);\n        current_position += dist * ray_direction;\n        if(dist < 0.001) {\n            if(comp_dist < plane_dist) {\n                fragColor.rgb = calc_normal(current_position);\n            } else {\n                // Compute the ground plane color intensity:\n                float gp_col = \n                    pow(cos(current_position.x * PI), 180.0) +\n                    pow(cos(current_position.z * PI), 180.0);\n                fragColor.rgb = vec3(1.0, 0.0, 0.0) - vec3 (gp_col, gp_col, 0.0);\n                //fragColor.rgb = vec3(0.0);\n            }\n            return;\n        } else if (dist > 10.0) {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n    }\n    \n    // This is our error case. We didn't hit anything, but we iterated so long that we\n    // had to give up. \n    fragColor.g = fract(iTime) < 0.5 ? 1.0 : 0.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float smooth_union( float d0, float d1, float k ) {\n    float h = clamp( 0.5 + 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) - k*h*(1.0-h); }\n\nfloat smooth_subtraction( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0+d1)/k, 0.0, 1.0 );\n    return mix( d0, -d1, h ) + k*h*(1.0-h); }\n\nfloat smooth_intersection( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) + k*h*(1.0-h); }\n\n// glsl doesn't support unions, but it's still a reserved word:\n#define union Union\nfloat union(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat intersection(float d0, float d1) {\n    return max(d0, d1);\n}\n\nfloat subtraction(float d0, float d1) {\n    return intersection(d0, -d1);\n}\n","name":"Common","description":"","type":"common"}]}