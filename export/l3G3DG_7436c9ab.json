{"ver":"0.1","info":{"id":"l3G3DG","date":"1718140179","viewed":120,"name":"spacetime gravity bending","username":"fen1kz","description":"help needed - Trying to do basic grid gravity bending, example: https://science.nasa.gov/universe/how-gravity-warps-light/\nno idea how to disable \"reflections\" and why gravity seems stronger in the top/right corner","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["help","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI    3.14159265358\n#define PI2   6.28318530718\nfloat width = 0.05;\n\n// Unused, alternate way of doing grid?\nfloat rect(vec2 p, vec2 size) {  \n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\n// Unused, alternate way of doing grid?\nvec3 matrix(in vec2 st){\n    float rows = 20.0;\n    \n    vec2 ipos = floor(st * rows);\n\n    ipos += vec2(.0,floor(20.));\n\n\n    vec2 fpos = fract(st * rows);\n    vec2 center = (.5-fpos);\n\n    float pct = 1.0;\n    float glow = (1.-dot(center,center)*3.)*2.0;\n\n    return vec3(2.0 * glow);\n}\n\n\nfloat getAngle(vec2 v1, vec2 v2) {\n    vec2 d = v1 - v2;\n    return (atan(d.y, d.x) + PI);\n    //return atan(v1.x,v1.y) -atan(v2.x,v2.y);\n    //return mod( atan(v1.x,v1.y) -atan(v2.x,v2.y), TWOPI); //0 ... TWOPI\n    //return mod( atan(v1.x,v1.y) -atan(v2.x,v2.y), TWOPI) - PI; //-pi to +pi \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    muv.x *= iResolution.x/iResolution.y;\n\n    // Base color\n    vec3 color = vec3(0.8);\n    \n    // Grid\n    float fraction = 15.0;\n\n    // Gravity center is mouse or animation\n    vec2 gravity = muv.xy;\n    if (length(iMouse.xy) == 0.) {\n      gravity = .5 + .3 * vec2(cos(iTime * 2.), sin(iTime * 2.));\n    }\n    \n    // calculate distance from grav. center\n    float dist = 0.5 * fraction * distance(uv, gravity);\n    \n    // More distance = less refraction\n    // various experiments tryint to get dist -> rr (from 0 => âˆž (dist) to ~0.5 => 0.0 (rr) )\n    // rr means \"refraction rate\"\n    //dist = 1. + 1. / (3. + 1. * dist + dist * dist);\n    //float rr = 1. / (1. + dist + dist * dist);\n    float rr = 0.5 / ( 1.0 + dist + dist * dist) - .1;\n    //float rr = .5 - .1 * dist * dist;\n    //float rr = .1 - .05 * dist;\n    //float rr = 1. - 0.3 * dist; // debug for color\n    rr *= .2;\n    rr = clamp(rr, 0., 1.);\n    //rr *= 0.05;\n    \n    float angle = getAngle(gravity, uv);\n    vec2 bend = rr * vec2(cos(angle), sin(angle));\n    //vec2 bend = rr * vec2(cos(PI*.5), sin(PI*.5));\n    //bend = floor(bend * 2.) / 2.;\n    \n    //color *= abs(bend.x); // just debug\n    //color *= angle / PI2;\n    \n    uv += bend;\n    \n    // Actual grid    \n    vec2 uvf = fract(uv * fraction);    \n    vec4 rect = vec4(width, width, 1.0-width, 1.0-width);\n    vec2 hv = step(rect.xy, uvf) * step(uvf, rect.zw);\n    float onOff = hv.x * hv.y;\n    color *= vec3( onOff );\n    \n    // Maybe this grid will do better\n    //color = matrix(uv);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}