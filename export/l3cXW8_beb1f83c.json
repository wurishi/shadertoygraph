{"ver":"0.1","info":{"id":"l3cXW8","date":"1718923999","viewed":32,"name":"albers","username":"Aman","description":"inspired by a josef albers drawing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["albers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat vmax(vec3 x) {\n    return max(max(x.x, x.y), x.z);\n}\n\nvec2 min2(vec2 x, vec2 y) {\n    if(x.x < y.x) { return x; } else { return y; }\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.0))) + vmax(min(d, vec3(0.0)));\n}\n\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nvec2 sdf(vec3 p) {\n    float plane = fBox(p + vec3(0.0, 1.0, 0.0), vec3(100.0, 0.1, 100.0));\n    float planemat = 0.5;\n    float cellx = pMod1(p.x, 0.5);\n    float cellz = pMod1(p.z, 0.5);\n    p.y -=  - 0.1 * sin(iTime + cellx * 10.0 * cos(cellz * 0.342));\n    float sphere = length(p) - 0.14;\n    float spheremat = -1.0;\n    //if(cellx > 5.0) sphere = 100.0;\n    return min2(vec2(plane, planemat), vec2(sphere, spheremat));\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n        k.xyy * sdf(p + k.xyy * h).x\n      + k.yxy * sdf(p + k.yxy * h).x\n      + k.yyx * sdf(p + k.yyx * h).x\n      + k.xxx * sdf(p + k.xxx * h).x\n    );\n}\n\nbool march(vec3 ro, vec3 rd, out vec3 hitPos, out float hitMat, out bool intersect) {\n    float total = 0.0;\n    float prevmat = 0.0;\n    for(int i = 0; i < 120; i++) {\n        vec2 dm = sdf(ro);\n        total += dm.x;\n        ro += dm.x * rd;\n        if(dm.y > 0.0 && dm.x < 0.001 * total) {\n            hitPos = ro;\n            hitMat = dm.y;\n            return true;\n        }\n        if(dm.y < 0.0 && dm.x < 0.01) {\n            vec3 normal = calcNormal(ro);\n            float a = abs(dot(normal, rd));\n            ro += 2.0 * -normal * 0.149;\n            rd = rd * a + (1.0 - a) * refract(rd, normal, 1.0/1.01);\n            \n            intersect = true;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    float nsq = 10.0;\n    float insq = 1.0 / nsq;\n    // Time varying pixel color\n    vec3 colour = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = vec3(0.0, 0.0, 1.0);\n    ro.xy += uv * 1.0;\n    rd.yz *= rot2(3.14159 / 4.0);\n    rd.xz *= rot2(3.14159 / 4.0);\n    ro.yz *= rot2(3.14159 / 4.0);\n    ro.xz *= rot2(3.14159 / 4.0);\n    vec3 hitPos;\n    float hitMat;\n    bool intersect = false;\n    if(march(ro, rd, hitPos, hitMat, intersect)) {\n        vec3 normal = calcNormal(hitPos);\n        colour = normal * 0.5 + 0.5;\n        if(true) {\n            float row = hitPos.z;\n            float col = hitPos.x;\n            vec2 squv = mod(vec2(col, row) - vec2(insq) * 0.5, vec2(insq)) * nsq;\n            vec2 idx = round(vec2(col, row) * nsq);\n            vec2 midx = mod(idx, vec2(2.0));\n            if((intersect == true && midx.x == midx.y)\n               || (intersect == false && midx.x != midx.y)) {\n                colour = vec3(1.0);\n            } else {\n                colour = vec3(1.3, 0.0, 0.1) * 0.7 + 0.3 * texture(iChannel0, hitPos.zx, 2.0).rbb;\n            }\n            if((idx.x + 5.0) == idx.y\n               || (idx.x + 21.0) == idx.y \n               || -(idx.x + 11.0) == idx.y\n               || -(idx.x - 11.0) == idx.y) {\n                \n                colour = vec3(1.0);\n                if(squv.x > 0.99 || squv.y > 0.99 || squv.x < 0.01 || squv.y < 0.01) {\n                    colour = vec3(1.0, 0.0, 0.0);\n                }\n            }\n        }\n        \n    }\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}