{"ver":"0.1","info":{"id":"3tj3R1","date":"1558511904","viewed":2235,"name":"ColorPicker","username":"lingel","description":"Color Picker","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["colorpicker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//QQ3977270\n//使用权重插值颜色并可进行三角形排除，\nvec4 lerpWithWeight(in vec3 weight,in vec3 sourceColor1,in vec3 sourceColor2,in vec3 sourceColor3)\n    \n{\n    float alpha=min(min(weight.x,weight.y),weight.z);//如果权重小于0顶点不在三角形内\n    alpha=smoothstep(-FEATHER*0.5,FEATHER*0.5,alpha);\n    return vec4(weight.x*sourceColor1+weight.y*sourceColor2+weight.z*sourceColor3,alpha);\n}\n//绘制一标记，一个小圆点\nvec4 drawPoint(in vec2 uv,in vec2 p)\n{\n    float alpha=smoothstep(0.008,0.002,abs(length(uv-p)-0.02));\n    return vec4(vec3(1.0),alpha);\n}\n\n//通过三角形内的点计算出对应的sv值\nvec2 position2sv(in vec2 p,in vec2 v1,in vec2 v2,in vec2 v3)\n{\n    //v1是色相所指的点，逆时针依次为v2,v3\n    vec2 baseS=v1-v3;\n    vec2 baseV=baseS*0.5-(v2-v3);\n    vec2 baseO=v3-baseV;\n         p-=baseO;\n    float s=dot(p,baseS)/pow(length(baseS),2.0);\n    float v=dot(p,baseV)/pow(length(baseV),2.0);\n    s-=0.5;\n    s/=v;\n    s+=0.5;\n    return vec2(s,v);\n}\n//三角形转换函数通过sv值计算出在三角形内的位置\nvec2 hsv2Position(in vec3 hsvColor,in vec2 v1,in vec2 v2,in vec2 v3)\n{\n    //\n    vec2 baseS=v1-v3;\n    vec2 baseV=baseS*0.5-(v2-v3);\n    vec2 baseO=v3-baseV;\n    float S=hsvColor.g;\n    float V=hsvColor.b;\n    S-=0.5;\n    S*=V;\n    S+=0.5;\n    vec2 ret=baseO+baseS*S+baseV*V;\n    return ret;\n    \n}\n//通过外截圆半径和旋转角度（角度即色相）算三角形的顶点\nvoid calcTriangle(in float Raidus,in float degree,inout vec2 v1,inout vec2 v2,inout vec2 v3)\n{\n    float r=PI/180.0;\n    //每间隔120度一个顶点\n    float radian=degree*r;\n    v1.x=cos(radian)*Raidus;\n    v1.y=sin(radian)*Raidus;\n    radian+=120.0*r;\n    v2.x=cos(radian)*Raidus;\n    v2.y=sin(radian)*Raidus;\n    radian+=120.0*r;\n    v3.x=cos(radian)*Raidus;\n    v3.y=sin(radian)*Raidus;\n}\n//绘制线段\nvec4 drawLine(in vec2 uv,in vec2 p1,in vec2 p2,in vec4 color,in float thickness)\n{\n    thickness*=0.5;\n    vec2 lineDirection=p2-p1;\n    float lineLength=length(lineDirection);\n    lineDirection=normalize(lineDirection);\n    vec2 toUv=uv-p1;\n    float projectLength=dot(lineDirection,toUv);\n    float p2LineDistance=length(toUv-lineDirection*projectLength);\n    p2LineDistance=smoothstep(thickness+FEATHER,thickness,p2LineDistance);\n    float p2EndDistance=projectLength<=0.0? abs(projectLength):projectLength-lineLength;\n    //float rr=projectLength<=0.0? 0.0:1.0;\n    //float rr=floor(projectLength/abs(floor(projectLength)))+1.0;\n    //float p2EndDistance=abs(projectLength)-lineLength*rr;\n    //修改颜色加黑边\n    p2EndDistance=smoothstep(thickness,thickness-FEATHER*0.5,p2EndDistance);\n    color.xyz*=mix(p2LineDistance,0.0,00.01);\n    //应用透明度\n    color.a*=min(p2LineDistance,p2EndDistance);\n    return color;\n}\n//绘制色环\nvec4 drawColorRing(in vec2 uv,in float exteriorRaidus,in float interiorRaidus){\n  //绘制色环\n    //float radian=uv.y>0.0? atan(uv.y,uv.x): 2.0*PI+atan(uv.y,uv.x);//弧度\n    float xiangxian=floor(1.0-uv.y );\n    float radian=xiangxian*2.0*PI+atan(uv.y,uv.x);\n    \n    float degree=radian/(2.0*PI)*360.0;//角度\n    vec4 ringColor=vec4(hsv2rgb(vec3(degree,1.0,1.0)),0.0);//色环颜色\n    float psitionRaidus=length(uv);//当前点到圆心的距离\n    //float s=psitionRaidus/exteriorRaidus;//饱和度\n    //色环的透明度\n    float interiorMask=smoothstep(interiorRaidus,interiorRaidus+FEATHER,psitionRaidus);//内\n    float outeriorMask=smoothstep(exteriorRaidus,exteriorRaidus-FEATHER,psitionRaidus);//外\n    ringColor.a=min(interiorMask,outeriorMask);  \n    return ringColor;\n}\n\n//绘制三角形,提供三个点位以及色相\nvec4 drawTriangle(in vec2 uv,in vec2 v1,in vec2 v2,in vec2 v3,in float H)\n{\n   vec4 triangleColor;\n   triangleColor.xyz=hsv2rgb(vec3(H,position2sv(uv,v1,v2,v3)));\n   vec3 weight=calcTriangleWeight(v1,v2,v3,uv);\n   triangleColor.a=min(min(weight.x,weight.y),weight.z);//如果权重小于0顶点不在三角形内\n   triangleColor.a=smoothstep(-FEATHER*0.5,FEATHER*0.5,triangleColor.a);\n   return triangleColor;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 规格化坐标系为0-1,原点在中心\n\tfragCoord-=iResolution.xy*vec2(0.5);\n    vec2 ndc=fragCoord/(iResolution.y*0.5);\n    //鼠标位置\n    vec2 mousePosition=iMouse.xy-iResolution.xy*vec2(0.5);\n    mousePosition/=(iResolution.y*0.5);\n    \n    //公共参数\n    float exteriorRaidus=1.0;//环外半径\n    float thickness=0.2;//环厚度\n    float interiorRaidus=exteriorRaidus-thickness;//环内半径\n \n    \n    //vec3 sampleColor=vec3(H,sin(iTime*0.5)*0.5+0.5,1.0);\n    vec3 sampleColor=rgb2hsv(vec3(0.0,.6,0.6));//当前颜色\n    //色相由鼠标确定,也是角度\n    sampleColor.x=mod(atan(mousePosition.y,mousePosition.x)/PI*180.0,360.0);//改色相\n\n    \n    ///////////////////////////////////////////////////////////////////////\n    //开始绘制三角\n    //等边三角形顶点\n    vec2 p1;\n    vec2 p3;\n    vec2 p2;\n    calcTriangle(interiorRaidus,sampleColor.x,p1,p2,p3);//填充顶点数据\n   \n    ////绘制三解形\n    vec4 triangleColor=drawTriangle(ndc,p1,p2,p3,sampleColor.x);\n \n    //绘制色环\n    vec4 ringColor=drawColorRing(ndc,exteriorRaidus,interiorRaidus);\n    \n    //绘制色环刻度 \n    vec4 lineColor=drawLine(ndc,p1+normalize(p1)*FEATHER*0.5,p1+normalize(p1)*(thickness-FEATHER*0.5),vec4(1.0,1.0,1.0,0.5),0.02);\n    \n    //绘制颜色位置标记\n    vec4 marker=drawPoint(ndc,hsv2Position(sampleColor,p1,p2,p3));\n    ///////////////////////////////////////////////////////////////////////////////\n    //混合最终输出\n    fragColor=vec4(0.15,0.15,0.15,1.0);//背景\n    fragColor=fragColor*(1.0-ringColor.a)+ringColor*ringColor.a;//色环\n    fragColor=fragColor*(1.0-triangleColor.a)+triangleColor*triangleColor.a;//三角形\n    fragColor=fragColor*(1.0-lineColor.a)+lineColor*lineColor.a;//色环刻度 \n    fragColor=fragColor*(1.0-marker.a)+marker*marker.a;//颜色位置标记\n   \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n#define FEATHER 0.01\n//HSV to RGB 色相落在不同的区间\nvec3 hsv2rgb_(in vec3 hsvColor){\n    hsvColor=max(hsvColor,0.1);\n    float H=hsvColor.x;\n    H=mod(H,360.0);\n    float C=hsvColor.b*hsvColor.g;\n    float X=C*(1.0-abs(mod(H/60.0,2.0)-1.0));\n    float m=hsvColor.b-C;\n    vec3 rgb;\n    if(0.0<=H && H<=60.0)\n    {\n        rgb=vec3(C,X,0.0);\n    }else if(60.0<H && H<=120.0)\n    {\n        rgb=vec3(X,C,0.0);\n    }else if(120.0<H && H<=180.0)\n    {\n        rgb=vec3(0.0,C,X);\n    }else if(180.0<H && H<=240.0)\n    {\n        rgb=vec3(0.0,X,C);\n    }else if(240.0<H && H<=300.0)\n    {\n        rgb=vec3(X,0.0,C);\n    }else if(300.0<H && H<=360.0)\n    {\n        rgb=vec3(C,0.0,X);\n    }\n    else\n    {\n        return vec3(1.0);\n    }\n    return rgb+m;\n    \n}\n//RGB to HSV Reference：http://mattlockyer.github.io/iat455/documents/rgb-hsv.pdf\n//与三原色哪个更接近，进行相应的偏移\nvec3 rgb2hsv(in vec3 rgbColor)\n{\n    float H_scale=60.0;//最多能偏+-60度\n    float Cmax=max(max(rgbColor.x,rgbColor.y),rgbColor.z);//最亮的通道\n    float Cmin=min(min(rgbColor.x,rgbColor.y),rgbColor.z);//最暗的通道\n    float delta=Cmax-Cmin;//最大偏向，若值大，颜色饱和\n    float H=0.0;\n    float S=0.0;\n    if(delta!=0.0)//注意分母不能为0\n    {\n        if(Cmax==rgbColor.r)//最接近红色\n       {\n           //另外两个分量取差值\n           //分母代表了红色的权重，分子代表偏绿色的趋势有多少，这个值可正可负，负偏向蓝色，正偏向绿色\n           H=(rgbColor.g-rgbColor.b)/delta;\n       }else if (Cmax==rgbColor.g)//最接近绿色\n       {\n           H=(rgbColor.b-rgbColor.r)/delta+2.0;//偏蓝色的趋势有多少\n       }else if(Cmax==rgbColor.b)//最接近蓝色\n       {\n           H=(rgbColor.r-rgbColor.g)/delta+4.0;//偏红色的趋势有多少\n       }\n    }\n    \n    if(Cmax!=0.0)\n    {\n        S=delta/Cmax;//饱和度\n    }\n    \n    H*=H_scale;\n    return vec3(H,S,Cmax);\n}\n//性能更高 https://zhuanlan.zhihu.com/p/61520731\nvec3 hsv2rgb(in vec3 c)\n{\n  c.x/=360.0;//归化到1\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx,0.0,1.0), c.y);\n}\n//计算三角形三个顶点的权重Reference https://codeplea.com/triangular-interpolation\nvec3 calcTriangleWeight(in vec2 v1,in vec2 v2,in vec2 v3,in vec2 p)\n{\n    vec3 weight;\n    weight.x=((v2.y-v3.y)*(p.x-v3.x)+(v3.x-v2.x)*(p.y-v3.y)) / ((v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y));\n    weight.y=((v3.y-v1.y)*(p.x-v3.x)+(v1.x-v3.x)*(p.y-v3.y)) / ((v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y));\n    weight.z=1.0 - weight.x- weight.y;\n    return weight;\n}","name":"Common","description":"","type":"common"}]}