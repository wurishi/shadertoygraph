{"ver":"0.1","info":{"id":"MtcSRs","date":"1481230187","viewed":299,"name":"rayPlane","username":"nyu","description":"a simple raytraced plane","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Pi 3.14159265359\n//#define USE_QUATERNION\n\nvec3 planeInt(vec3 normal, vec3 rayorg, vec3 raydir) {\n\treturn rayorg + (raydir * (dot(-rayorg, normal) / dot(normal, raydir)));\n}\n\nvec4 eulerToQuat(vec3 a) {\n    float c1 = cos(a.x/2.);\n    float s1 = sin(a.x/2.);\n    float c2 = cos(a.y/2.);\n    float s2 = sin(a.y/2.);\n    float c3 = cos(a.z/2.);\n    float s3 = sin(a.z/2.);\n    float c1c2 = c1*c2;\n    float s1s2 = s1*s2;\n    return vec4(c1c2*s3 + s1s2*c3,\n                s1*c2*c3 + c1*s2*s3,\n                c1*s2*c3 - s1*c2*s3,\n                c1c2*c3 - s1s2*s3);\n}\n\nvec3 rotateEuler(vec3 position, vec3 a) {\n    mat4 rx = mat4(1., 0., 0., 0.,\n                  0., cos(a.x), -sin(a.x), 0.,\n                  0., sin(a.x), cos(a.x), 0.,\n                  0., 0., 0., 1.);\n    mat4 ry = mat4(cos(a.y), 0., sin(a.y), 0.,\n                  0.,        1., 0., \t  0.,\n                  -sin(a.y), 0., cos(a.y),0.,\n                  0.,\t\t 0., 0.,\t  1.);\n    mat4 rz = mat4(cos(a.z), -sin(a.z), 0., 0.,\n                  sin(a.z),  cos(a.z),  0., 0.,\n                  0.,\t\t 0.,\t\t1., 0.,\n                  0.,\t\t 0.,\t\t0., 1.);\n    mat4 r = rx * ry * rz;\n    return (vec4(position, 1.) * r).xyz;\n}\n\nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotateQuat(vec3 p, vec4 q) {\n  vec4 qr_conj = vec4(-q.x, -q.y, -q.z, q.w);\n  vec4 q_pos = vec4(p.x, p.y, p.z, 0);\n  \n  vec4 q_tmp = quat_mult(q, q_pos);\n  q = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(q.x, q.y, q.z);\n}\n\n/*\nvec3 project(vec3 v, vec3 lb, vec3 le) {\n    vec3 a = v - lb;\n    vec3 b = le - lb;\n    float d = dot(a, b);\n    float q = b.x * b.x + b.y * b.y + b.z * b.z;\n    //float q = pow(distance(b,vec3(0.,0.,0.)),2.);\n    \n    vec3 p = (d/q) * b;\n    //return vec3(lb.x + p.x, lb.y + p.y, lb.z + p.z);\n    return lb + p;\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 eye = vec3(0.,0.,15.);\n    vec3 dir = normalize(vec3(-1.0 + 2.0 * fragCoord.xy / iResolution.xy, 5.));\n\n    float v = sin(iTime);\n    float x = v * Pi;\n    float y = v * Pi;\n    vec3 r = vec3(0., x, y);\n#ifdef USE_QUATERNION\n    vec4 q = eulerToQuat(r);\n    vec3 pNormal = rotateQuat(vec3(0.,0.,1.), q);\n    vec3 pTangent = rotateQuat(vec3(0.,1.,0.), q);\n#else\n    vec3 pNormal = rotateEuler(vec3(0.,0.,1.), r);\n    vec3 pTangent = rotateEuler(vec3(0.,1.,0.), r);\n#endif\n    vec3 pBitangent = cross(pTangent, pNormal);\n    vec3 i = planeInt(pNormal, eye, dir);\n    float sideT = dot(i, pTangent) - (Pi / 2.);\n    float sideBiT = dot(i, pBitangent) - (Pi / 2.);\n\tvec2 uv = (- 0.33) * (vec2(sideT, sideBiT));\n    if (uv.x < 1. && uv.y < 1. && uv.x > 0. && uv.y > 0.) {\n        fragColor = texture(iChannel0, uv);\n    } else {\n         fragColor = vec4(0., 0.1, .1, 0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}