{"ver":"0.1","info":{"id":"ll23Rc","date":"1431128958","viewed":255,"name":"Manhattan IFS","username":"avi","description":"Putting back the cubes...","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","ifs","manhattan","koch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* Modified by Avi Levy (c) 2015\n *\n * This is a Manhattan surface,\n * rendered using an IFS.\n *\n * IFS equations due to Brent Werness\n *\n * Instructions:\n *      Click and drag the fractal\n *          - Upwards zooms in\n *          - Left/right rotates\n *\n * \n * \n * Original by inigo quilez - iq/2013\n */\n\nconst int iterations = 8;\nfloat scale = 3.;\nfloat colorScale = 9.;\n\nconst vec3 v1 = vec3(  2./3.,  0.,  0. );\nconst vec3 v2 = vec3(  -2./3.,  0.,  0. );\nconst vec3 v3 = vec3(  0.,  2./3.,  0. );\nconst vec3 v4 = vec3(  0.,  -2./3.,  0. );\nconst vec3 v5 = vec3(  0.,  0.,  2./3. );\nconst vec3 v6 = vec3(  0.,  0.,  -2./3. );\n\nconst vec3 a1 = vec3(  1./3.,  1./3., 0. );\nconst vec3 a2 = vec3(  -1./3.,  1./3., 0. );\nconst vec3 a3 = vec3(  1./3.,  -1./3., 0. );\nconst vec3 a4 = vec3(  -1./3.,  -1./3., 0. );\n\nconst vec3 b1 = vec3(  0.,  1./3., 1./3. );\nconst vec3 b2 = vec3(  0.,  -1./3., 1./3. );\nconst vec3 b3 = vec3(  0.,  1./3., -1./3. );\nconst vec3 b4 = vec3(  0.,  -1./3., -1./3. );\n\nconst vec3 c1 = vec3(  1./3.,  0., 1./3. );\nconst vec3 c2 = vec3(  -1./3.,  0., 1./3. );\nconst vec3 c3 = vec3(  1./3.,  0., -1./3. );\nconst vec3 c4 = vec3(  -1./3.,  0., -1./3. );\n\nconst vec3 x1 = vec3(  1./3.,  1./3., 1./3. );\nconst vec3 x2 = vec3(  -1./3.,  1./3., 1./3. );\nconst vec3 x3 = vec3(  1./3.,  -1./3., 1./3. );\nconst vec3 x4 = vec3(  -1./3.,  -1./3., 1./3. );\nconst vec3 x5 = vec3(  1./3.,  1./3., -1./3. );\nconst vec3 x6 = vec3(  -1./3.,  1./3., -1./3. );\nconst vec3 x7 = vec3(  1./3.,  -1./3., -1./3. );\nconst vec3 x8 = vec3(  -1./3.,  -1./3., -1./3. );\n\nfloat rect(vec3 p, vec3 radius) {\n    return length(max(abs(p) - radius, 0.));\n}\n\n// return distance and address\nvec2 map(vec3 p) {\n    float cube = rect(p, vec3(1./3.));\n\n    float a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for(int i=0; i < iterations; i++) {\n        float d, t;\n        d = dot(p-v1,p-v1);\n        //if( d<dm ) {\n            v=v1; dm=d; t = 0.;\n        //}        \n        d = dot(p-v2,p-v2);\n        if( d<dm ) {\n            v=v2; dm=d; t = 1.;\n        }\n        d = dot(p-v3,p-v3);\n        if( d<dm ) {\n            v=v3; dm=d; t = 2.;\n        }\n        d = dot(p-v4,p-v4);\n        if( d<dm ) {\n            v=v4; dm=d; t = 3.;\n        }\n        d = dot(p-v5,p-v5);\n        if( d<dm ) {\n            v=v5; dm=d; t = 4.;\n        }\n        d = dot(p-v6,p-v6);\n        if( d<dm ) {\n            v=v6; dm=d; t = 5.;\n        }\n\n        d = dot(p-a1,p-a1);\n        if( d<dm ) {\n            v=a1; dm=d; t = 6.;\n        }\n        d = dot(p-a2,p-a2);\n        if( d<dm ) {\n            v=a2; dm=d; t = 7.;\n        }\n        d = dot(p-a3,p-a3);\n        if( d<dm ) {\n            v=a3; dm=d; t = 8.;\n        }\n        d = dot(p-a4,p-a4);\n        if( d<dm ) {\n            v=a4; dm=d; t = 9.;\n        }                        \n        \n        d = dot(p-b1,p-b1);\n        if( d<dm ) {\n            v=b1; dm=d; t = 10.;\n        }\n        d = dot(p-b2,p-b2);\n        if( d<dm ) {\n            v=b2; dm=d; t = 11.;\n        }\n        d = dot(p-b3,p-b3);\n        if( d<dm ) {\n            v=b3; dm=d; t = 12.;\n        }\n        d = dot(p-b4,p-b4);\n        if( d<dm ) {\n            v=b4; dm=d; t = 13.;\n        }\n\n        d = dot(p-c1,p-c1);\n        if( d<dm ) {\n            v=c1; dm=d; t = 14.;\n        }\n        d = dot(p-c2,p-c2);\n        if( d<dm ) {\n            v=c2; dm=d; t = 15.;\n        }\n        d = dot(p-c3,p-c3);\n        if( d<dm ) {\n            v=c3; dm=d; t = 16.;\n        }\n        d = dot(p-c4,p-c4);\n        if( d<dm ) {\n            v=c4; dm=d; t = 17.;\n        }\n\n        d = dot(p-x1,p-x1);\n        if( d<dm ) {\n            v=x1; dm=d; t = 18.;\n        }\n        d = dot(p-x2,p-x2);\n        if( d<dm ) {\n            v=x2; dm=d; t = 19.;\n        }\n        d = dot(p-x3,p-x3);\n        if( d<dm ) {\n            v=x3; dm=d; t = 20.;\n        }\n        d = dot(p-x4,p-x4);\n        if( d<dm ) {\n            v=x4; dm=d; t = 21.;\n        }\n        d = dot(p-x5,p-x5);\n        if( d<dm ) {\n            v=x5 ; dm=d; t = 22.;\n        }\n        d = dot(p-x6,p-x6);\n        if( d<dm ) {\n            v=x6; dm=d; t = 23.;\n        }\n        d = dot(p-x7,p-x7);\n        if( d<dm ) {\n            v=x7; dm=d; t = 24.;\n        }\n        d = dot(p-x8,p-x8);\n        if( d<dm ) {\n            v=x8; dm=d; t = 25.;\n        }        \n        p = v + scale * (p - v);\n        r *= scale;\n        s *= colorScale;\n        a = t + colorScale * a;\n    }\n    \n    float manhattan = (sqrt(dm)-0.5)/r;\n    if(cube < manhattan) {\n        return vec2(cube, 0.);\n    } else {\n        return vec2(manhattan, a/s);\n    }\n}\n\nconst float precis = 0.000001;\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n    vec3 res = vec3(1e20, 0.0, 0.0);\n    \n    float maxd = 5.0;\n\n    // sierpinski\n    float h = 1.0;\n    float t = 0.5;\n    float m = 0.0;\n    vec2 r;\n    for(int i=0; i<100; i++) {\n        r = map( ro+rd*t );\n        if( r.x<precis || t>maxd ) break;\n        m = r.y;\n        t += r.x;\n    }\n\n    if(t < maxd && r.x < precis) {\n        res = vec3(t, 2., m);\n    }\n\n    return res;\n}\n\nvec3 light = normalize(vec3(1., .7, .9));\n\nvec4 render(in vec3 ro, in vec3 rd) {\n    // raymarch\n    vec3 tm = intersect(ro,rd);\n    if(tm.y < 0.5) {\n        return vec4(0., 0., 0., 1.);\n    }\n    // Position vector\n    vec3 position = ro + tm.x * rd;\n    \n    // Normal vector calculation\n    vec3 epsilon = vec3(precis, 0., 0.);\n    vec3 normal = normalize(\n        vec3(\n            map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n            map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n            map(position + epsilon.yyx).x - map(position - epsilon.yyx).x\n        )\n    );\n\n    // Occlusion calculation\n    float ao = 0.;\n    float sca = 1.;\n    for(int i=0; i<8; i++) {\n        float h = 0.001 + 0.5*pow(float(i)/7.0,1.5);\n        float d = map(position + h * normal).x;\n        ao += -(d-h)*sca;\n        sca *= 0.95;\n    }\n\n    // surface-light interacion\n    vec3 color = (\n        .5 + .5 * cos(\n            6.2831 * tm.z + vec3(0., 1., 2.)\n        )\n    )\n    * (0.5 + 0.5 * normal.y) // ambient lighting\n    * clamp(1.0 - 0.8*ao, 0.0, 1.0) // occlusion\n    * 1.5 * vec3(1);\n\n    return vec4(\n        pow(clamp(color, 0., 1.), vec3(.45)) // gamma\n    , 1.);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if(iMouse.z>0.0) {\n        m = iMouse.xy/iResolution.xy/10.;\n        m.y = pow(2., 150. * m.y - 3.);\n    }\n\n    // camera\n    float an = 3.2 + 0.5*iTime - 6.2831*(m.x-0.5);\n\n    vec3 ro = vec3(2.5*sin(an),0.,2.5*cos(an));\n    vec3 ta = vec3(0.0,0.,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 5.0*ww*m.y );\n\n    color = render(ro, rd);\n}","name":"","description":"","type":"image"}]}