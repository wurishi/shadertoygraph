{"ver":"0.1","info":{"id":"3syXzV","date":"1574397639","viewed":369,"name":"Planet Jet and Black Hole","username":"JohnShadow","description":"A planet named \"Jet\" and black hole I made for fun FULL SCREEN for best effect.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["simulation","space","planet","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float G = 6.67408e-11;\nconst float mass = 1.0e10;\nconst vec3 bhpos = vec3(0, 0, 0); \nconst float planetRadius = 4.0;\nconst vec3 planetPosition = vec3(0, 0, 20.0);\nconst float sdc = 300.0;\nconst float hsdc = 150.0;\nconst float bhrad = 2.0 * G * mass;\n\nstruct RayHit\n{\n    vec3 pos;\n    float dist;\n};\n\n\n// Noise 3D\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n// SDFS\nfloat sphere(vec3 x, vec3 c, float r)\n{\n    return length(x-c)-r;             \n}\nfloat sdDisc( vec3 position, vec3 n, float r )\n{\n    position = abs(position);\n    float dl = length(position) - r;\n\tfloat d = dot(position, n);\n\treturn max(dl, d);\n}\n\n// Xy axis rotation\nvec3 xzRotate(vec3 position, float theta)\n{\n    float dx = position.x * cos(theta) - position.z * sin(theta);\n    float dz = position.x * sin(theta) + position.z * cos(theta);\n\treturn vec3(dx, position.y, dz);\n}\n\n// Planet \"Jet\"\nfloat map(vec3 position)\n{\n\tfloat theta = iTime * 0.25;\n\tposition = xzRotate(position, theta);\n    vec3 spos = position - planetPosition;\n    \n\tfloat s1 = (fbm(position) + fbm(position*2.0) * 0.25) * 0.75;\n    return sphere(spos, vec3(0), planetRadius) + s1;\n}\nfloat getao (vec3 pos, vec3 normal)\n{\n\treturn clamp(map(pos+normal*0.2)/0.2, 0.0, 1.0);\n}\nvec3 getnormal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\n\n\n// Blackhole (BH)\nfloat blackhole(vec3 position)\n{\n    return distance(position, bhpos) - 1.0;\n}\nvec3 holefeild (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( blackhole(p + vec3(eps, 0, 0) ) - blackhole(p - vec3(eps, 0, 0)),\n \t  blackhole(p + vec3(0, eps, 0) ) - blackhole(p - vec3(0, eps, 0)),\n\t  blackhole(p + vec3(0, 0, eps) ) - blackhole(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat calcGrav(float r, float m)\n{\n\treturn G * m/(r * r);\n}\n\n// Ray march\nRayHit marchDisc(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori;\n\tfor(int i = 0; i < 250; ++i)\n    {\n        float bh = blackhole(pos); //get bh distance\n        if(bh <= bhrad) //check if we are under the schwarzchildradius\n            return RayHit(vec3(1.0), 0.0);\n\t\tvec3 bhdir = holefeild(pos); //get the normal in space towards the BH\n        float grav = calcGrav(bh, mass); //calc the gavitation at a point\n        \n        float dd = sdDisc(pos, vec3(0, 1.0, 0), 14.0); //make acceleration disc\n        \n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * min((bh - bhrad), dd); //get new position with BH gravity bending\n        if(dd < 0.001) //check if we hit \n            return RayHit(pos, dd);\n        if(dd > 120.0)\n            return RayHit(vec3(0.0), 0.0);\n    }\n    return RayHit(vec3(0.0), 0.0);\n}\nRayHit marchPlanet(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori;\n    float dmin = 1.0;\n\tfor(int i = 0; i < 250; ++i)\n    {\n        float bh = blackhole(pos); //get bh distance\n        if(bh <= bhrad) //check if we are under the schwarzchildradius\n            return RayHit(vec3(1.0, dmin, float(i)), 0.0);\n\t\tvec3 bhdir = holefeild(pos); //get the normal in space towards the BH\n        float grav = calcGrav(bh, mass); //calc the gavitation at a point\n        \n        float cs = map(pos);\n        dmin = min(dmin, cs);\n        \n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * min((bh - bhrad), cs); //get new position with BH gravity bending\n        if(cs < 0.001) //check if we hit \n            return RayHit(pos, cs);\n        if(cs > 120.0)\n            return RayHit(vec3(0.0, dmin, float(i)), 0.0);\n    }\n    return RayHit(vec3(0.0), 0.0);\n}\nRayHit bhwarp(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori;\n\tfor(int i = 0; i < 10; ++i)\n    {\n        float bh = blackhole(pos); //get bh distance\n        if(bh <= bhrad) //check if we are under the schwarzchildradius\n            return RayHit(vec3(0.0), bh);\n\t\tvec3 bhdir = holefeild(pos); //get the normal in space towards the BH\n        float grav = calcGrav(bh, mass); //calc the gavitation at a point\n        \n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * (bh - bhrad); //get new position with BH gravity bending\n    }\n    return RayHit(dir, 0.0);\n}\n\n// Night sky\nfloat nightsky(vec3 dir)\n{\n    return noise(dir * 500.0) > 0.9 ? 0.65 : 0.0;\n}\n\n//ray marching view stuff\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(40.0, 10.0, 40.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec3 normal, color;\n\t\n    // Ray march the scene\n    RayHit hitDisc = marchDisc(eye, worldDir);\n\tRayHit hitPlanet = marchPlanet(eye, worldDir);\n\tif(hitDisc.dist != 0.0)\n\t{\n\t\tfloat distinv = 1.0/(length(hitDisc.pos.xz) - 0.5); \n\t\tfloat distinv2 = 2.0 * distinv * distinv * distinv;\n\t\tRayHit warp = bhwarp(eye, worldDir);\n\t\tvec3 sky = vec3(nightsky(warp.pos));\n\t\tvec3 cdist = vec3(sdc, hsdc, hsdc);\n\t\tvec3 disc = abs(fbm(xzRotate(hitDisc.pos, iTime * distinv * 5.0))) * cdist;\n\t\tcolor = disc * distinv2 + sky * (1.0-distinv2);\n\t}\n\tif(hitPlanet.dist != 0.0)\n\t{\n\t\tfloat theta = iTime * 0.25;\n\t\tvec3 position = xzRotate(planetPosition, theta);\n\t\tvec3 planetPos = position - planetPosition;\n\t\tfloat angle = dot(planetPos, vec3(1.0, 0.0, -1.0));\n\t\tnormal = getnormal(hitPlanet.pos);\n\t\tfloat ao = max(getao(hitPlanet.pos, normal), 0.1);\n\t\tif(angle > 0.0) //dumb transparancy ordering\n\t\t\tcolor += 0.8*vec3(1.0, 1.0, 1.0) * ao * max(dot(normal, normalize(bhpos - hitPlanet.pos)), 0.2);\n\t\telse\n\t\t\tcolor = 0.8*vec3(1.0, 1.0, 1.0) * ao * max(dot(normal, normalize(bhpos - hitPlanet.pos)), 0.2);\n\t}\n    if(hitDisc.dist == 0.0 && hitPlanet.dist == 0.0 && hitPlanet.pos.x == 0.0)\n    {\n        RayHit warp = bhwarp(eye, worldDir);\n        color = vec3(nightsky(warp.pos));\n    }\n    if(hitPlanet.pos.y < 1.0 || hitPlanet.dist != 0.0) //fake atmosphere\n    {\n        float dist = hitPlanet.dist != 0.0 ? abs(hitPlanet.dist) : hitPlanet.pos.y;\n        dist = 0.5*(2.0-(dist+1.0));\n        float redshift = 0.5*(2.0-((hitPlanet.pos.z/250.0)+1.0));\n        redshift *= redshift * 2.0;\n        if(hitPlanet.dist != 0.0)\n            color += 0.2*vec3(0.25, dist*(redshift * 1.5), dist*redshift * 1.5);\n        else\n        \tcolor += 0.7*vec3(dist*(1.0-redshift), dist*(redshift * 1.5), dist*redshift * 1.5);\n    }\n\t// Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}