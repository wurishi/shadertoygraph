{"ver":"0.1","info":{"id":"ltBfzR","date":"1525559155","viewed":113,"name":"plot polynomial function","username":"dahart","description":"plot a polynomial function. use mouse to zoom.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["function","plot","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define S(a,b,t) smoothstep(a,b,t)\n#define L(a,b,t) S(a,b,t*2.)*S(a,b,2.-t*2.)\n\nvec2 Cmul(vec2 a, vec2 b) {\n    return vec2(dot(a,vec2(b.x,-b.y)), dot(a.yx,b));\n}\n\n\nbool axes(vec2 p, vec2 dx, inout vec4 color) {\n    if (abs(p.y) < dx.y*5.0) {\n        if (abs(p.y) < dx.y) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n        if (abs(mod(p.x, 1.0)) < dx.x) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n    }\n    if (abs(p.x) < dx.x*5.0) {\n        if (abs(p.x) < dx.x) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n        if (abs(mod(p.y, 1.0)) < dx.y) {\n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            return true;\n        }\n    }\n    return false;\n}\n\n\n#define MAX_ORDER_PLUS_ONE 7\n\nbool testRoots(\n    int order, \n    float[MAX_ORDER_PLUS_ONE] realCoeffs, \n    vec2 p, \n    vec2 dx, \n    inout vec4 color\n) {\n    int iters = 0;\n    vec2[MAX_ORDER_PLUS_ONE] coeffs;\n    for (int i = 0; i <= order; i++) {\n        coeffs[i] = vec2(realCoeffs[i], 0.0);\n    }\n    \n    vec2 x = vec2(p.x, 0.0);\n    vec2 b = coeffs[order];  // value\n    float err = length(b);\n    vec2 d = vec2(0.0, 0.0); // 1st deriv\n    vec2 f = vec2(0.0, 0.0); // 2nd deriv\n    float abx = length(x);\n    for (int j = order - 1; j >= 0; j--) {\n        // Efficient computation of the polynomial and\n        // its first two derivatives. f stores P''/2\n        f = Cmul(x, f) + d;\n        d = Cmul(x, d) + b;\n        b = Cmul(x, b) + coeffs[j];\n    }\n\n    // plot our polynomial\n    //b.r = L(0., 2., p.x);\n    //d.r = 0.1;\n    \n    // derivative of the polynomial tells us how many vertical pixels to draw\n    //if (abs(p.y - b.r) < dx.y * 0.5 * max(abs(d.r),1.0)) {\n\n    float ddx = length(fwidth(vec2(x.x, b.r)));\n    if (abs(p.y - b.r) < 1.*ddx) {\n        float val = L(-ddx, ddx, p.y-b.r);\n        color = vec4(0.0, 1.0, 0.0, 1.0);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float aspect = iResolution.x / iResolution.y;\n    float scale = 1.0 * (1.0 + 10.0 * iMouse.y / iResolution.y);\n        \n    mat3x3 pixel2Screen = inverse\n        (\n        mat3x3(\n            vec3(iResolution.x / aspect, 0.0, 0.0),\n            vec3(0.0, iResolution.y, 0.0),\n            vec3(0.0, 0.0, 1.0)\n        )\n        );\n\n\n    mat3x3 offset = inverse\n        (\n        mat3x3(\n            vec3(1.0, 0.0, 0.0),\n            vec3(0.0, 1.0, 0.0),\n            vec3(0.5 * aspect - 0.25, 0.5, 1.0)\n    \t));\n    \n    mat3x3 screen2World = \n        mat3x3(\n        vec3( scale, 0.0, 0.0 ),\n        vec3( 0.0, scale, 0.0 ),\n        vec3(0.0, 0.0, 1.0)\n    );\n\n    mat3x3 xform = screen2World * offset * pixel2Screen;\n    \n    vec3 hWorld = xform * vec3(fragCoord, 1.0);\n    vec2 world = hWorld.xy / hWorld.z;\n    vec3 hDx = xform * vec3(1.0, 1.0, 0.0);\n    vec2 dx = hDx.xy;\n\n    float[MAX_ORDER_PLUS_ONE] coeffs = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    \n    /*\n    coeffs[1] = 1.0;\n    coeffs[0] = 2.0;\n    \n    if (testRoots(\n        1, \n        coeffs, \n        world, \n        dx, \n        fragColor\n    )) return;\n\t//*/\n    \n    \n    /*\n    // 3xx + x - 2\n    coeffs[2] = 3.0;\n    coeffs[1] = 1.0;\n    coeffs[0] = -2.0;\n\n    if (testRoots(\n        2, \n        coeffs, \n        world, \n        dx, \n        fragColor\n    )) return;\n\t//*/\n\n    //*\n    // Poly((x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6),x).coeffs()\n    // testRoots([1, -21, 175, -735, 1624, -1764, 720], [1,2,3,4,5,6]);\n\n    coeffs[6] = 0.1 * 1.0;\n    coeffs[5] = 0.1 * -21.0;\n    coeffs[4] = 0.1 * 175.0;\n    coeffs[3] = 0.1 * -735.0;\n    coeffs[2] = 0.1 * 1624.0;\n    coeffs[1] = 0.1 * -1764.0;\n    coeffs[0] = 0.1 * 720.0;\n    \n    if (testRoots(\n        6, \n        coeffs, \n        world, \n        dx, \n        fragColor\n    )) return;\n\t//*/\n\n    \n    if (axes(world, dx, fragColor)) return;\n}\n","name":"Image","description":"","type":"image"}]}