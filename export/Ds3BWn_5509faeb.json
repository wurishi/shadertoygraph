{"ver":"0.1","info":{"id":"Ds3BWn","date":"1698130902","viewed":32,"name":"Rolling Sphere by zma","username":"zma","description":"My first step to 3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .0, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\nfloat sphsoftshadow(vec3 ro, vec3 rd, in vec4 sph, float k)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    return b>0.? step(-0.0001, c) : smoothstep(0., 1., h*k/b);\n\n}\nfloat sphocclusion(in vec3 pos,in vec3 norm,in vec4 sph){\n    vec3 r = pos - sph.xyz;\n    float l = length(r);\n    return dot(r, norm)*(sph.w*sph.w)/(l*l*l);\n\n}\n\nfloat iPlane(vec3 ro, vec3 rd){\n    return (-1. - ro.y)/rd.y;\n}\n\nfloat square(float a){\n    return a*a;\n}\n\nmat3 rotate3D(float a, float b){\nreturn mat3(a, a*a, -b*a, 0., a, b, b, -b*a, a*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0., 1., -4.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 green = vec3(0., 0.9, 0.);\n        \n    float t = iTime;\n    float ct = cos(t);\n    float st = sin(t);\n    \n    mat2 rotate2 = mat2(ct, -st, st, ct);\n    vec3 lig = normalize(vec3(0.5, 0.5, -0.5));\n    vec3 m = 1.5*vec3(-cos(t), 0., -sin(t)); \n    vec4 sph = vec4(0., 0., 0., 1.) + vec4(m, 0.);\n    vec3 norm;\n    vec3 pos;\n    vec3 col = vec3(0.);\n    float occ = 1.;\n       \n    \n    \n    //t1:distance factor of plane and origin\n    \n    float t1 = iPlane(ro, rd);\n    float tmin = 1e10;\n    if(t1 > 0.){\n        tmin = t1;\n        norm = vec3(0., 1., 0);\n        pos = ro + tmin*rd;\n        vec2 tuv = pos.xz;\n        col = green;\n        col *= sphsoftshadow(pos, lig, sph, 2.);\n        occ = 1. - sphocclusion(pos, norm, sph);  //plane ambient occlusion\n        col += 0.15*occ*green ;\n        \n       \n    }\n    float t2 = sphIntersect(ro, rd, sph.xyz, sph.w).x;\n    if(t2 > 0. && t2 < tmin){\n        tmin = t2;\n        pos = ro + tmin*rd;\n        norm = (pos - sph.xyz);\n        \n        //vec3 tpos = rotate3D(ct, st)*norm;\n       vec3 tpos = norm; \n       tpos.zx *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n       tpos.yz *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));       \n       \n        \n        col = tex3D(iChannel0, tpos, norm); \n        col *= clamp(dot(norm, lig), 0., 1.);\n        occ = 0.5 + 0.5*norm.y;\n        col += 0.05*occ*tex3D(iChannel0, tpos, norm);\n              \n    }\n    col = 0.68*sqrt(col);  \n       \n    col *= exp(-0.05*tmin);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}