{"ver":"0.1","info":{"id":"Mst3DX","date":"1452585482","viewed":159,"name":"gloopy ladder","username":"hypothete","description":"Distorting the infinite spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","brdf","cooktorrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define minStep 0.1\n#define maxStep 10.0\n#define delta 0.01\n#define damping 0.9\n#define numSteps 100\n#define randseed  173.0\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n    \nstruct pointLight {\n\tvec3 position;\n    float intensity;\n    vec3 color;\n};\n\nconst vec3 worldUp = vec3(0.0,1.0,0.0);\n\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k) // position, direction, worldUp\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = -normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s ) //sphere distf\n{\n  return length(p)-s;\n}\n\nfloat sykari(in float seed)\n{\n  float x = sin(seed++) * 10000.0;\n  return clamp(fract(x), 0.0, 1.0);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float c = cos(10.*p.x+iTime);\n    float s = sin(10.*p.z+iTime);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.yx,p.z);\n    return q;\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere(opTwist(q), 0.1);\n}\n\n\nfloat distf (vec3 pos) //scene distance function\n{\n    float dist = opRep(pos,normalize(vec3(2.)));\n\treturn dist;\n}\n\nvec3 normal (vec3 p) //borrowed from https://www.shadertoy.com/view/ltfXDM\n{\n    vec2 h = vec2(delta, -delta);\n\treturn normalize (\n\t\th.xxx * distf(p + h.xxx) +\n\t\th.xyy * distf(p + h.xyy) +\n\t\th.yxy * distf(p + h.yxy) +\n\t\th.yyx * distf(p + h.yyx)\n\t);\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\nfloat lum (vec3 rgb){\n\treturn 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nvec4 render(in vec2 xy)\n{\n    camera myCam = camera( \n    \tvec3(100.*sin(iTime*0.01),\n             50.*cos(iTime*0.01),\n             100.*cos(iTime*0.01)\n            ),\n    \tvec3(sin(iTime*0.2),\n             cos(iTime*0.8+0.4),\n             cos(iTime*0.2)\n            )\n\t);\n\n    vec3 spherePos = vec3(0);\n    \n    //BDRF stuff adapted from http://ruh.li/GraphicsCookTorrance.html\n    float roughness = 0.1;\n    float f0 =1.; //dilectric fresnel\n    float k = 0.7; //diffuse reflection strength\n    float specular = 0.6;\n    vec3 diffuseColor = vec3(0.99);\n    \n    //camera\n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec4 colToRtn = vec4(0,0,1.,1.);\n    float histDistanceFunction = castRay(myCam.position, rayDir, ro);\n    vec3 nml = normal(ro);\n    \n    //more BDRF\n    vec3 lightDir = vec3(0,1.,-0.6);\n    float NdotL = max(dot(nml, lightDir),0.);\n    \n    vec4 rLight = vec4(1.);\n    float rLightIntensity = lum(rLight.xyz);\n    \n    if(NdotL > 0.){\n        vec3 eyeDir = -normalize(rayDir);\n        vec3 halfVector = normalize(lightDir+eyeDir);\n    \tfloat NdotH = max(dot(nml,halfVector),0.);\n        float NdotV = max(dot(nml,eyeDir),0.);\n        float VdotH = max(dot(eyeDir, halfVector),0.);\n        float mSquared = roughness * roughness;\n        \n        //geometric attenuation\n        float NH2 = 2. * NdotH;\n        float g1 = (NH2 * NdotV) / VdotH;\n        float g2 = (NH2 * NdotL) / VdotH;\n        float geoAtt = min(1., min(g1, g2));\n        \n        //roughness\n        float r1 = 1. / (4. * mSquared * pow(NdotH, 4.));\n        float r2 = (NdotH * NdotH - 1.) / (mSquared * NdotH * NdotH);\n        float finalRough =  r1 * exp(r2);\n        \n        //fresnel\n        float fresnel = pow(1. - VdotH, 5.);\n        fresnel *= 1. - f0;\n        fresnel += f0;\n        \n        specular = (fresnel * geoAtt * finalRough) / (NdotV * NdotL * 3.14); \n        diffuseColor = vec3(NdotL, NdotV,VdotH);\n        diffuseColor = clamp(vec3(0),vec3(1.),diffuseColor);\n    }\n    \n    vec3 finalBDRF = diffuseColor * rLight.xyz * rLightIntensity * NdotL * (k + specular * (1. - k));\n    \n    //choose which sampler we use based on our distf result\n    if(histDistanceFunction < maxStep){\n        \n\t\tcolToRtn.xyz = finalBDRF;\n    }\n    else{\n        colToRtn = vec4(vec3(0.1618),1.);\n    }\n    return colToRtn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    fragColor = render(uv);\n}","name":"","description":"","type":"image"}]}