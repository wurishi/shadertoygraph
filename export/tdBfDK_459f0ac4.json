{"ver":"0.1","info":{"id":"tdBfDK","date":"1590827018","viewed":155,"name":"MengerSponge Lightning Base","username":"TAKUSAKU","description":"MengerSponge Lightning Base","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lightning","fold","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\nconst float PI = 3.14159265;\nconst float HARF_PI = 1.57079632;\n\n// Background shader based on : \n// https://www.shadertoy.com/view/4sVBDm\n// ---------------------------------------------------------------------\n\n//noise background\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(-0.950,-0.910))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ){\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv ){\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;    \n\tf = 0.1 + .5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv ){\n    float velocity = time * 0.5;\n    float intensity = sin(uv.x*noise(uv)*7.+velocity*3.)*noise(uv*10.)*1.0+.3;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp);\n\n    //bazooca line\n    rz *= sin(uv.x*0.1+velocity*0.8);\n    \n    //lightning\n    rz *= 5.*sin(uv.x*0.1+velocity*sin(time));\n    \n    vec3 bgColor = vec3(cos(time),0.45 * sin(time*0.2),sin(time*0.3));\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n// IFS MengerSponge is based on gam0022.net\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\n// ---------------------------------------------------------------------\nvec3 trans(vec3 p){\n    return mod(p, 4.0) -2.0;\n}\n\n#define ITERATIONS 4\n\nvec3 _MengerOffset = vec3(1.000,0.072,0.414);\nfloat _MengerFold = 3.;\n\n// IFS MengerSpongeã€€DistanceFunction\nfloat dMenger(vec3 z0, vec3 offset, float scale) {\n    vec4 z = vec4(z0, 1.0);\n    for (int n = 0; n < ITERATIONS; n++) {\n        z = abs(z);\n\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// Deformation used folding\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);// PI/s = offset, atan(p.x, p.y) : XY to Polar coordinates\n    float n = PI*2. / s;// Unit angle\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n// Final DistanceFunction\nfloat map(vec3 pos) {\n    pos.xy = foldRotate(pos.xy, _MengerFold);\n    pos.yz = foldRotate(pos.yz, _MengerFold);\n    vec3 p = trans(pos);\n    float _MengerScale = -(1.1 +0.7*smoothstep(0.0,2.0,1.-cos(time*0.1)));\n    return dMenger(p, _MengerOffset, _MengerScale);\n}\n\n// Normal and Camera\n// baced on Kazuya Hiruma @edo_m18\n// https://qiita.com/edo_m18/items/1532aceb9d470174caaf#%E3%83%90%E3%83%AA%E3%83%A5%E3%83%BC%E3%83%8E%E3%82%A4%E3%82%BA\n// ---------------------------------------------------------------------\n// Normal\nvec3 getNormal(vec3 p){\n    const vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Camera\nmat3 camera(vec3 ro, vec3 ta){\n    vec3 cw = normalize(ta - ro);// camera forward, ro = Ray origin, ta = Target\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n// lighting\nvec3 getMetalColor(vec3 n, vec3 rd, vec2 p, vec2 uv){\n\n    vec3 refDir = reflect(rd, n);// reflect direction\n    float specular = max(0.0, dot(refDir, vec3(-0.017,0.473,-0.617)));// light position\n    vec3 SPECULAR_COLOR = 30.0*pow(specular, 1.5)*(vec3(0.195,0.157,0.144));// light color\n    vec3 bgCol = bg(p)*(2.-abs(uv.y*2.));\n    vec3 spCol = mix(bgCol, SPECULAR_COLOR, 0.5);\n    \n    return mix(spCol, refDir, 0.2);\n}\n\n// fog\n// based on Atsushi Asakura @aa_debdeb\n// https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat exp2Fog(float d, float density) {\n\tfloat dd = d * density;\n\treturn exp(-dd * dd);\n}\n\n// ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;// background\n    \n    // Wide-angle lens is baced on Menger Sponge Variation\n    // https://www.shadertoy.com/view/ldyGWm\n    // background\n    vec3 st = (vec3(2.0 * fragCoord - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *4.*sin(time*0.4),0.))));\n    \n    // camera  \n    vec3 ta1 = vec3(0.0,0.0,-1.0);// target1\n    vec3 ta2 = vec3(cos(time*0.4+HARF_PI),0.0,time+sin(time*0.4+HARF_PI));// target2\n    \n    float moveSwitch =  step(0.942, smoothstep(0.0,2.0,1.-cos(time*0.1)));\n    vec3 ta = mix(ta1, ta2, moveSwitch);//if(smooth...<=0.942){ta1} else {ta2}\n    \n\tvec3 ro = vec3(0.0, 0.0, time);// ray origin = camera position\n    \n\tmat3 c = camera(ro, ta);\n     \n    // ray\n    float fl = 1.0;// focalLength\n\tvec3 rd = c * normalize(vec3(p, fl));// ray direction = normalize(vec3(cu*p.x + cv*p.y + cw*fl));\n    \n    // marching loop\n    float d;\n    float t = 0.0;\n    vec3  rPos = ro;\n    for(int i = 0; i < 64; i++){\n        d = map(rPos);\n        t += d;\n        rPos = ro + rd * t;\n    }\n    \n    //color\n    vec3 normal = getNormal(rPos);\n    vec3 col1 = getMetalColor(normal, rd, st.xy, uv);\n    vec3 col2 = getMetalColor(normal, rd, p, uv);\n    vec3 color = mix(col1, col2, moveSwitch);//if(smooth...<=0.942){col1} else {col2}\n    \n    //fog\n    vec3 fogColor = vec3(1.000,0.976,0.822);\n    float f = exp2Fog(d, 8.);\n\t\tcolor = mix(fogColor, color, f);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}