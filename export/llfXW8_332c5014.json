{"ver":"0.1","info":{"id":"llfXW8","date":"1436264672","viewed":706,"name":"Butterfly Flock","username":"kuvkar","description":"Flock of butterflies flying around. Mouse to look around.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["butterflies","flock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst float mouseRotateSpeed = 5.0;\n\nstruct sdObject\n{\n    vec3 pos;\n    float rad;\n    int index;\n};\n\n// Amount of butterflies    \n#define OBJECTS 40\n    \nsdObject sdObjects[OBJECTS];    \n\n// objects that will be potentially hit, found at prestep\n#define CACHED 5\nsdObject cachedObjects[CACHED];\n\nint maxCacheIndex = 0;\n    \n// distance functions from https://iquilezles.org/articles/distfunctions\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n//// \n\nconst float MATERIAL_BODY = 0.0;\nconst float MATERIAL_WING = 1.0;\n\n\nconst float OBJECT_SIZE = 0.5;    \nvec2 getModel(in vec3 pos, int index)\n{\n    float phase = float(index);\n    float l = length(pos);\n\t\n    float bl = (sin(pos.z * 12.0 - 5.0) * 0.5 + 0.5) + 0.3;\n    float body = sdHexPrism(pos - vec3(0.0, 0.0, 0.), vec2(OBJECT_SIZE * 0.04 * bl, OBJECT_SIZE * 0.2));         \n\n    float wx = max(abs(l * 6. + .2) - .4, 0.0);\n    float sl = 1.5* abs(sin(wx)) + 0.05;\n    \n    vec3 wing = vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0.01, OBJECT_SIZE * 0.25 * sl);\n    \n    float w1 = udBox(rotz(sin(iTime * 22.0 + phase)) * pos - vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0., 0.0), wing);\n    float w2 = udBox(rotz(-sin(iTime * 22.0 + phase)) * pos + vec3(OBJECT_SIZE * 0.5, OBJECT_SIZE * 0., 0.0), wing);\n    \n    float id = MATERIAL_BODY;\n    if(w1 < body || w2 < body)\n    {\n        id = MATERIAL_WING;\n    }\n    \n    float m = min(body, w1);\n    m = min(m, w2);\n    \n    return vec2(m, id);\n            \n}\n\n\nvec2 map(in vec3 rp, in sdObject[CACHED] objects, inout vec3 localPos, inout int index)\n{\n    float m = 9999.0;\n    vec2 ret = vec2(m, 0.0);\n    \n    for (int i = 0; i < CACHED; ++i)\n    {\n        if ( i <= maxCacheIndex)\n        {\n            vec3 lp = rp - objects[i].pos;\n            vec2 mat = getModel(lp, objects[i].index);     \n            float a = min(mat.x, m);\n            if (a < m)\n            {\n                m = a;\n                ret = mat;\n                localPos = lp;\n                index = objects[i].index;\n            }\n        }\n    }\n    return ret;\n}\n\n/**\n * In the pre-step function I find objects that will be potentially hit.\n * I will check only against these objects at later steps.\n */\nfloat prestep(in vec3 ro, in vec3 rp, in vec3 rd, in vec3 rd90degXAxis, in vec3 rd90degYAxis)\n{\n    maxCacheIndex = -1;\n    float m = 99999.0;\n    for (int i = 0; i < OBJECTS; ++i)\n    {\n        vec3 sp = -ro + sdObjects[i].pos;\n        \n        float distToPlaneY = abs(dot(rd90degYAxis, sp));\n    \tfloat distToPlaneX = abs(dot(rd90degXAxis, sp));\n        \n        float distanceToPlanes = max(distToPlaneY, distToPlaneX);\n        distanceToPlanes = distanceToPlanes - sdObjects[i].rad;\n\n        vec2 mat = getModel(rp - sdObjects[i].pos * (1.0 + distanceToPlanes), sdObjects[i].index);\n        float l = mat.x;\n        m = min(m, l);\n        \n        if(distanceToPlanes <= 0.0 && ++maxCacheIndex < CACHED)\n        {\n            if (maxCacheIndex == 0) cachedObjects[0] = sdObjects[i];\n            else if (maxCacheIndex == 1) cachedObjects[1] = sdObjects[i];\n            else if (maxCacheIndex == 2) cachedObjects[2] = sdObjects[i];\n            else if (maxCacheIndex == 3) cachedObjects[3] = sdObjects[i];\n            else if (maxCacheIndex == 4) cachedObjects[4] = sdObjects[i];\n            else return m;    \n            \n        }\n    }\n    \n    return m;\n}\n\n\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 ro = rp;\n    float travel = 0.0;\n    const int STEPS = 50;\n    // build orthonormal frame to get right and up vectors to be used in distance calculations \n    vec3 tmp = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(rd, tmp));\n    vec3 right = cross(rd, up);\n    \n    // pre-step and move ray\n    travel = prestep(ro, rp, rd, right, up);\n    rp += travel * rd;\n    \n    vec3 local = vec3(0.0);\n    int hitindex = 0;\n    \n    for (int i = 0; i < STEPS; ++i)\n    {\n       vec2 mat = map(rp, cachedObjects, local, hitindex);\n       float dist = mat.x;\n        \n       if(dist <= 0.0)\n       {\n           float id = mat.y;\n           float indx = float(hitindex);\n           float c1 = sin(indx * 0.1) * 0.5 + 0.5;\n           float c2 = abs(cos(abs(local.z * 15.0)) + sin(abs(local.x) * 15.0));\n           float c3 = cos(indx * 0.4);\n           color = vec4(mat.y, c2 * mat.y, c1 * mat.y, 1.0) * abs(sin(indx * 0.1));\n           color.a = 1.0;\n               \n           return;\n       }\n       float dst = max(0.01, dist);\n       travel += dst;\n       rp += rd * dst;\n       if(travel > 30.0) return;\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(0.5);\n    \n    if(mouse.xy == vec2(-0.5))\n    {\n        mouse = vec2(0.0);\n    }\n    \n    mouse *= mouseRotateSpeed;\n    \n    for (int i = 0; i < OBJECTS; ++i)\n    {\n        vec3 p = (texture(iChannel0, sin(iTime * 0.001) + 0.21 * vec2(float(i))) - vec4(0.5)).rgb;\n        p *= roty(iTime * 2.0);\n        p.z += (sin(iTime) * 0.5 + 0.5) * 1.0;\n        p.x *= 1.0 + (sin(iTime * 0.1) * 0.5 + 0.5) * 0.25;\n        p.y *= 1.0 + (cos(iTime * 0.1) * 0.5 + 0.5) * 0.25;\n        sdObjects[i] = sdObject(p * 10.0, OBJECT_SIZE * 1. , i);\n    }\n    \n    vec3 rp = vec3(0.0, .0, 1.0);\n    vec3 rd = normalize(vec3(uv, 0.3));\n    \n    rd *= rotx(mouse.y);\n    rd *= roty(mouse.x);\n    \n    trace(rp, rd, fragColor);\n    fragColor = mix(fragColor, texture(iChannel1, rd * roty(3.14159 * 0.5)), 1.0 - fragColor.a);\n    \n    float luma = (fragColor.r + fragColor.g + fragColor.b) * 0.33;\n    fragColor -= (luma) * vec4(.9, .5, .0, 1.) * clamp(rd.y - 0.05, 0.0, 1.0);\n    \n    fragColor += vec4(.2, 0.4, 0.0, 0.0) * abs(clamp(rd.y, -1.0, .0));\n\t\n    // frame\n    fragColor = mix(fragColor, vec4(0.0), 1.0 - smoothstep(0.5, 0.45, abs(uv.x)));\n    fragColor = mix(fragColor, vec4(0.0), 1.0 - smoothstep(0.28, 0.2, abs(uv.y)));\n    \n}","name":"","description":"","type":"image"}]}