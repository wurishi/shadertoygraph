{"ver":"0.1","info":{"id":"DtdSz7","date":"1693922317","viewed":12239,"name":"STELLAR CLOUDS","username":"alro","description":"Where stars go to hang out.","likes":241,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","clouds","light","space","glow","stars","nebula","scattering","haze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Volumetric nebula rendered in tiles. Use mouse to move camera.\n    Wait for blue noise texture to load.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n// \\0/ Shader of the Week!\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n// Distance of camera from the centre. Try value 20 and spin around the scene volume.\n#define CAMERA_DIST 0.01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 1){\n                polarAngles = vec2(-1.96, 2.0);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Volumetric clouds with gyroid noise\n    See https://www.shadertoy.com/view/3sffzj for more detailed comments on clouds.\n*/\n\n// Different step counts for full and interactive states\n#define STEPS_PRIMARY 75\n#define STEPS_PRIMARY_LOW 7\n\n#define STEPS_LIGHT 32\n#define STEPS_LIGHT_LOW 7\n\n// Offset the sample point by blue noise to get rid of banding\n#define DITHERING\nconst float goldenRatio = 1.61803398875;\n\n// Scattering coefficient based on Earth's atmosphere but tweaked for this look\nconst vec3 BETA_RAYLEIGH = 100.0*vec3(0.05802, 0.14558, 0.331);\nconst vec3 BETA_OZONE = vec3(0.650, 1.881, 0.085);\n\n// Scattering\nconst vec3 sigmaS = 2.0*(BETA_RAYLEIGH);\n// Absorption\nconst vec3 sigmaA = 4.0*(BETA_RAYLEIGH + 3.0*BETA_OZONE);\n// Extinction\nconst vec3 sigmaE = sigmaA; // + sigmaS\n\nconst float sunLocation = -1.0;\nconst float sunHeight = 0.5;\n        \n// Main light power\nconst float power = 200.0;\n\n// For size of AABB\n#define CLOUD_EXTENT 10.0\nconst vec3 minCorner = vec3(-CLOUD_EXTENT, -CLOUD_EXTENT, -CLOUD_EXTENT);\nconst vec3 maxCorner = vec3(CLOUD_EXTENT, CLOUD_EXTENT, CLOUD_EXTENT);\n\n//-------------------------------- Camera --------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//-------------------------------- Intersection --------------------------------\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p){\n    float eps = 1e-4;\n\treturn  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n\t\t\t(p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\nbool getCloudIntersection(vec3 org, vec3 dir, out float distToStart, out float totalDistance){\n\tvec2 intersections = intersectAABB(org, dir, minCorner, maxCorner);\n\t\n    if(insideAABB(org)){\n        intersections.x = 1e-4;\n    }\n    \n    distToStart = intersections.x;\n    totalDistance = intersections.y - intersections.x;\n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n// https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn max(0.0, pow(radius/max(dist, 1e-5), intensity));\t\n}\n\n//-------------------------------- Random --------------------------------\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\n//-------------------------------- Shape --------------------------------\n\n// https://en.wikipedia.org/wiki/Gyroid\n// https://www.shadertoy.com/view/wddfDM\nfloat gyroid(vec3 p, float thickness, float bias, float frequency){\n    return clamp(abs(dot(sin(p*0.5), cos(p.zxy*1.23) * frequency) - bias) - thickness, 0.0, 3.0)/3.0;\n}\n\n// Gyroid noise based on https://www.shadertoy.com/view/3l23Rh\nfloat fbm(vec3 p){\n\n    const int octaves = 12;\n    const float fbmScale = 1.95;\n\n    // Rotation of the gyroid every iteration to produce a noise look\n    const float a = PI / float(octaves);\n    const mat3 m3 = fbmScale * mat3(cos(a), sin(a), 0, -sin(a), cos(a), 0, 0, 0, 1);\n\n\n    float weight = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float res = 0.0;\n    \n    \n    for(int i = min(0, iFrame); i < octaves; i++){\n        res += amplitude * gyroid(p, 0.1, 0.0, frequency);\n        p *= m3;\n        weight += amplitude;\n        amplitude *= (i < 4 ? 0.9 : 0.7);\n        frequency *= (i < 3 ? 0.65 : 0.78);\n    }\n    \n    return saturate(res / weight);\n}\n\nfloat clouds(vec3 p){\n    if(!insideAABB(p)){\n        return 0.0;\n    }\n    float noise = fbm(0.25*p);\n    float structure = smoothstep(3.0, 5.0, length(p)) * smoothstep(0.05, 0.1, noise);\n    float haze = smoothstep(2.0, 10.0, length(p)) * smoothstep(0.02, 0.5, noise);\n    return 3e-4+(0.5*haze + 0.75 * structure);\n\n}\n\n\n//-------------------------------- Stars --------------------------------\n\n// https://iquilezles.org/articles/palettes/\nvec3 getColour(float t){\n    vec3 a = vec3(0.65);\n    vec3 b = 1.0 - a;\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.15,0.5,0.75);\n\n    return pow(a + b * cos(TWO_PI * (c * t + d)), vec3(2.2));\n}\n\n\n// Stars with random placement and strength\nvec3 getStars(vec3 p){\n    p *= 0.2;\n    vec3 rand;\n    float d = 1e10;\n    vec3 cell;\n    \n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            for(int z = -1; z <= 1; z++){\n                vec3 c = floor(p) + vec3(x, y, z);\n                vec3 h = hash(c);\n                vec3 f = c + 0.5 + 0.5 * h;\n                float dd = length(p - f);\n                if(dd < d){\n                    d = dd;\n                    rand = h;\n                    cell = c;\n                }\n            }\n        }\n    }\n    rand = clamp(0.5 + 0.5 * rand, 0.0, 1.0);\n    vec3 rand2 = clamp(0.5 + 0.5 * hash(cell+vec3(3.12, 104.9, -9.5)), 0.0, 1.0);\n    return vec3(0.05) * rand.z * step(0.45, rand2.z) * mix(vec3(1), getColour(rand.y), 0.3) * smoothstep(0.5, 0.0, d) * getGlow(d, 0.25, 2.0);\n}\n\n//-------------------------------- Lighting --------------------------------\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n// https://twitter.com/FewesW/status/1364629939568451587/photo/1\nvec3 multipleOctaves(float extinction, float mu, float stepL){\n\n    vec3 luminance = vec3(0);\n    const float octaves = 6.0;\n    \n    // Attenuation\n    float a = 1.0;\n    // Contribution\n    float b = 1.0;\n    // Phase attenuation\n    float c = 1.0;\n    \n    float phase;\n    \n    for(float i = 0.0; i < octaves; i++){\n        // Two-lobed HG\n        phase = mix(HenyeyGreenstein(-0.1 * c, mu), HenyeyGreenstein(0.3 * c, mu), 0.7);\n        luminance += b * phase * exp(-stepL * extinction * sigmaE * a);\n        // Lower is brighter\n        a *= 0.3;\n        // Higher is brighter\n        b *= 0.5;\n        c *= 0.5;\n    }\n    return luminance;\n}\n\n// Get the amount of light that reaches a sample point.\nvec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection, bool low){\n\n\tfloat lightRayDistance = CLOUD_EXTENT*0.25;\n    float distToStart = 0.0;\n    \n    getCloudIntersection(p, sunDirection, distToStart, lightRayDistance);\n        \n    float stepL = lightRayDistance/float(low ? STEPS_LIGHT_LOW : STEPS_LIGHT);\n\n\tfloat lightRayDensity = 0.0;\n\n\t// Collect total density along light ray.\n\tfor(int j = 0; j < (low ? STEPS_LIGHT_LOW : STEPS_LIGHT); j++){\n\t\tlightRayDensity += clouds(p + sunDirection * float(j) * stepL);\n\t}\n    \n\tvec3 beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\n\t\n    // Return product of Beer's law and powder effect depending on the \n    // view direction angle with the light direction.\n\treturn mix(beersLaw * 2.0 * (1.0 - (exp( -stepL * lightRayDensity * 2.0 * sigmaE))), \n               beersLaw, \n               0.5 + 0.5 * mu);\n}\n\n\n//-------------------------------- Raymarching --------------------------------\n\n// Get the colour along the main view ray.\nvec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, out vec3 totalTransmittance, float offset, bool low){\n    \n\t// Variable to track transmittance along view ray. \n    // Assume clear sky and attenuate light when encountering clouds.\n\ttotalTransmittance = vec3(1.0);\n\n\t// Default to black.\n\tvec3 colour = vec3(0.0);\n    \n    // The distance at which to start ray marching.\n    float distToStart = 0.0;\n    \n    // The length of the intersection.\n    float totalDistance = 0.0;\n\n    // Determine if ray intersects bounding volume.\n\t// Set ray parameters in the cloud layer.\n\tbool renderClouds = getCloudIntersection(org, dir, distToStart, totalDistance);\n   \n\tif(!renderClouds){\n\t\treturn colour;\n    }\n\n\t// Sampling step size.\n    float stepS = totalDistance / float(low ? STEPS_PRIMARY_LOW : STEPS_PRIMARY); \n    \n    // Offset the starting point by blue noise.\n    distToStart += stepS * offset;\n    \n    // Track distance to sample point.\n    float dist = distToStart;\n\n    // Initialise sampling point.\n    vec3 p = org + dist * dir;\n    \n    float mu = dot(dir, sunDirection);\n    // Combine backward and forward scattering to have details in all directions.\n\tfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n    \n    vec3 sunLight = vec3(1) * power;\n\n\tfor(int i = 0; i < (low ? STEPS_PRIMARY_LOW : STEPS_PRIMARY); i++){\n\n        float density = clouds(p);\n\n        vec3 sampleSigmaS = sigmaS * density;\n        vec3 sampleSigmaE = sigmaE * density;\n\n        // If there is a cloud at the sample point.\n        if(density > 0.0 ){\n\n            // Stars in the clouds\n            vec3 ambient = 1.0*getStars(p) + \n                           2.0*getStars(1.5*p + 17.51) + \n                           1.0*getStars(2.4*p - 6.2) +\n                           getStars(3.7*p + 109.9);\n            \n            // Scale starlight by the density at the sample point\n            ambient *= smoothstep(1e-3, 2e-3, density);\n\n            // Amount of sunlight that reaches the sample point through the cloud \n            // is the combination of ambient light and attenuated direct light.\n            vec3 luminance = ambient + sunLight * phaseFunction * \n                                        lightRay(org, p, phaseFunction, mu, sunDirection, low);\n\n            // Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            // Beer-Lambert.\n            vec3 transmittance = exp(-sampleSigmaE * stepS);\n\n            // Better energy conserving integration\n            // \"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            // by Sebastian Hillaire.\n            colour += \n                totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            // Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            // If ray combined transmittance is close to 0, nothing beyond this sample \n            // point is visible, so break early.\n            if(length(totalTransmittance) <= 0.001){\n                totalTransmittance = vec3(0.0);\n                break;\n            }\n        }\n\n        dist += stepS;\n\n\t\t// Step along ray.\n\t\tp = org + dir * dist;\n\t}\n\n\treturn colour;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float tileSize = iResolution.x < 2000.0 ? 256.0 : 128.0;\n    float framesToDraw = ceil(iResolution.x / tileSize);\n    \n    float framesDrawn = texelFetch(iChannel1, ivec2(0.5, 0.5), 0).x;\n    bool blueNoiseNotLoaded = iChannelResolution[2].xy != vec2(1024);\n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).x > 0.0;\n    \n    bool renderPreview = resolutionChanged || blueNoiseNotLoaded || iFrame == 0 || iMouse.z > 0.0;\n    bool renderFull = framesDrawn < framesToDraw && !renderPreview;\n    \n    float tileStart = framesDrawn * tileSize;\n    bool renderThisFrame = fragCoord.x > tileStart && fragCoord.x < tileStart + tileSize;\n    \n    if(renderPreview || (renderFull && renderThisFrame)){\n\n        //----------------- Define a camera -----------------\n\n        // Get the default direction of the ray (along the negative Z direction)\n        vec3 rayDir = rayDirection(55.0, fragCoord);\n        \n        vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n        vec3 targetDir = -cameraPos;\n\n        vec3 up = vec3(0.0, 1.0, 0.0);\n\n        // Get the view matrix from the camera orientation\n        mat3 viewMatrix = lookAt(targetDir, up);\n\n        // Transform the ray to point in the correct direction\n        rayDir = normalize(viewMatrix * rayDir);\n\n        //---------------------------------------------------\n        \n        vec3 sunDirection = normalize(vec3(cos(sunLocation), sunHeight, sin(sunLocation)));\n\n        vec3 background = 0.05 * vec3(0.09, 0.33, 0.81);\n\n        float mu = 0.5+0.5*dot(rayDir, sunDirection);\n        background += getGlow(1.0-mu, 0.00015, 0.9);\n\n        vec3 totalTransmittance = vec3(1.0);\n\n        float offset = 0.0;\n\n        #ifdef DITHERING\n        // Sometimes the blue noise texture is not immediately loaded into iChannel2\n        // leading to jitters.\n        if(iChannelResolution[2].xy == vec2(1024)){\n            // From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n            float blueNoise = texture(iChannel2, fragCoord / 1024.0).r;\n            offset = fract(blueNoise + float(iFrame%32) * goldenRatio);\n        }\n        #endif\n\n        vec3 col = mainRay(cameraPos, rayDir, sunDirection, totalTransmittance, offset, renderPreview); \n        \n        col += background * totalTransmittance;\n\n        // Tonemapping\n        col = ACESFilm(col);\n        // Gamma\n        col = pow(col, vec3(0.4545));\n\n        fragColor = vec4(col, 1.0);\n        \n    }else{\n        vec4 oldData = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        fragColor = oldData;\n    }\n    \n    // Store the number of full resolution frames which have been drawn for the current view\n    if(fragCoord == vec2(0.5, 0.5)){\n        if(renderPreview){\n            fragColor = vec4(vec3(0.0), 1.0);\n        }else{\n            fragColor = vec4(framesDrawn + 1.0, 0.0, 0.0, 1.0);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}