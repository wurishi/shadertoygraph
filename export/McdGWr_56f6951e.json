{"ver":"0.1","info":{"id":"McdGWr","date":"1711730699","viewed":60,"name":"Closest Tangent Pt - Box","username":"natevm","description":"Minimal tangent cone to an axis aligned box. Optimized by culling back faces and edges. \n\nMore closest tangency point queries here: https://www.shadertoy.com/playlist/NcKBDV","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","cone","box","aabb","tangent","closest"],"hasliked":0,"parentid":"XfcGR7","parentname":"Closest Tangent Pt - Rectangle"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// More closest tangency point queries here\n// https://www.shadertoy.com/playlist/NcKBDV\n\n// The logic for the code below is to consider the great circles containing the arcs of the box's edges. \n// We leverage symmetry of the box to focus our efforts on just one of the six possible faces.\n// From there, we determine what side of a great circle that the conic's direction lies to identify and cull back facing edges.\n// What's left is one to three edge tests, which use a simplified version of my closest tangent point to segment code here: https://www.shadertoy.com/view/4XBXzz\n\n// Returns the max angular similarity to the box relative to the cone, as well as the closest tangent point.\n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  a  - the apex of the cone\n//  d  - the direction of the cone, perpendicular to it's base.\n//  b  - the radius of the box (half extents) \nvec4 ctpBoxQuery( vec3 a, vec3 d, vec3 b)\n{               \n    // Transform the line direction to the first octant using reflections.\n    bvec3 reflected = lessThan(d, vec3(0.));\n    a = mix(a, -a, reflected);\n    d = mix(d, -d, reflected);\n    \n    // below checks if ray intersects planes X, Y or Z first\n    vec3 PmE = a - b;\n    int axis = 0;\n    if (d[1] * PmE[0] >= d[0] * PmE[1]) \n         axis = (d[2] * PmE[0] >= d[0] * PmE[2]) ? 0 : 2;\n    else axis = (d[2] * PmE[1] >= d[1] * PmE[2]) ? 1 : 2;\n    \n    bvec3 check = bvec3(0 == axis, 1 == axis, 2 == axis);\n    \n    // Determine face normal\n    vec3 N = mix(vec3(0.0), vec3(1.0), check);\n    \n    // Determine face center\n    vec3 C = mix(vec3(0.0), b, check);\n    \n    // Dot product to determine face orientation\n    float ddotN = dot(C - a, N);\n\n    // Check the four edges to determine which is closest.\n    // Project direction onto the shadow volume triangles which subtend these edges.\n    vec3 ctp = a + d;\n    float maxSimilarity = -1.f;\n    for (int i = 0; i < 4; ++i)\n    {\n        // Compute edge vertices of the rectangle in a counterclockwise fashion.\n        // Bit twiddling to return signs indicating direction of edge\n        // First bit pattern produces +1, -1, +1, -1, +1, -1, +1, -1, ...\n        // Second bit pattern produces +1, -1, -1, +1, +1, -1, -1, +1, ...\n        int i0 = i, i1 = i + 1;\n        vec3 sv0 = vec3(1.0, (1 - 2 * ((i0>>1) & 1)), (1 - 2 * ((i0 + (i0>>1)) & 1)));\n        vec3 sv1 = vec3(1.0, (1 - 2 * ((i1>>1) & 1)), (1 - 2 * ((i1 + (i1>>1)) & 1)));\n\n        // Swizzle sign adjustments by axis \n        if (axis == 1) {sv0 = sv0.zxy; sv1 = sv1.zxy;}\n        if (axis == 2) {sv0 = sv0.yzx; sv1 = sv1.yzx;}\n\n        // ∆0 and ∆1 subtending the counterclockwise edge\n        vec3 d0 = b * sv0 - a, d1 = b * sv1 - a;\n        \n        // Vector perpendicular to triangle from edge to apex, scaled by parallelogram.\n        // Equivalent to great circle normal connecting ∆0 and ∆1, but scaled.        \n        vec3 n = cross(d0, d1); // |∆0x∆1| = |∆0||∆1|sin(γ)\n        float dnn = dot(n, n);  // |N|^2\n        float ddn = dot(d, n);  // |D||N|cos(θ)\n        \n        // Cull back facing edges\n        if (ddn * ddotN < 0.0) continue; \n        \n        float dd00 = dot(d0, d0); // |∆0|^2\n        float dd11 = dot(d1, d1); // |∆1|^2\n        float dd01 = dot(d0, d1); // |∆0||∆1|cos(γ)\n\n        // By construction, this plane is tangent to the cone and lies on the great circle.\n        // Using \"Perpendicular to a chord theorem\", projecting d onto \n        // the face (which itself projects spherically to a chord) defines a line bisecting the arc. \n        // ∆2 = D - (D·N)/(N·N) * N\n        vec3 d2 = d - (ddn / dnn) * n;\n        \n        // Projection falls on the triangle / within the arc.\n        // Compute the barycentrics to recover t.\n        float d20 = dot(d2,d0);\n        float d21 = dot(d2,d1);\n        float area = (dd00*dd11 - dd01*dd01);\n        float v = ((dd11*d20) - (dd01*d21)) / area;    \n        float w = ((dd00*d21) - (dd01*d20)) / area;\n        float u = 1.f - v - w;    \n        float t = w / (w + v);\n        vec3 p = mix(d0, d1, clamp(t, 0.0, 1.0)); \n\n        float dp = dot(d, p);\n        float dpp = dot(p, p);    \n        float s = dp * abs(dp) / dpp;\n        if (s < maxSimilarity) continue;\n        \n        maxSimilarity = s;\n        ctp = p + a;\n    }\n    \n    // Account for previously applied reflections.\n    ctp.xyz = mix(ctp.xyz, -ctp.xyz, reflected);    \n    \n    // If all edges are back facing, the ray intersects the face\n    if (maxSimilarity == -1.0) maxSimilarity = 1.f;\n    return vec4(maxSimilarity, ctp);\n}\n\n//------------------------------------------------------------\n\n// Useful for illustrating which edges are culled and which are tested\nivec4 getRelevantEdges(vec3 a, vec3 d, vec3 b, out vec3 c0, out vec3 c1, out vec3 c2, out vec3 c3) \n{               \n    ivec4 edges = ivec4(-1);\n    \n    // Transform the line direction to the first octant using reflections.\n    bvec3 reflected = lessThan(d, vec3(0.));\n    a = mix(a, -a, reflected);\n    d = mix(d, -d, reflected);\n    \n    // below checks if ray intersects planes X, Y or Z first\n    vec3 PmE = a - b;\n    int axis = 0;\n    if (d[1] * PmE[0] >= d[0] * PmE[1]) \n         axis = (d[2] * PmE[0] >= d[0] * PmE[2]) ? 0 : 2;\n    else axis = (d[2] * PmE[1] >= d[1] * PmE[2]) ? 1 : 2;\n    \n    bvec3 check = bvec3(0 == axis, 1 == axis, 2 == axis);\n    \n    // Determine face normal\n    vec3 N = mix(vec3(0.0), vec3(1.0), check);\n    \n    // Determine face center\n    vec3 C = mix(vec3(0.0), b, check);\n    \n    // Dot product to determine face orientation\n    float ddotN = dot(C - a, N);\n\n    // Check the four edges to determine which is closest.\n    // Project direction onto the shadow volume triangles which subtend these edges.\n    vec3 ctp = a;\n    float maxSimilarity = -1.f;\n    for (int i = 0; i < 4; ++i)\n    {\n        // Compute edge vertices of the rectangle in a counterclockwise fashion.\n        // (bit twiddling, but essentially returns bottom left, bottom right, top right, top left.\n        int i0 = i, i1 = i + 1;\n        vec3 sv0 = vec3(1.0, (1 - 2 * ((i0>>1) & 1)), (1 - 2 * ((i0 + (i0>>1)) & 1)));\n        vec3 sv1 = vec3(1.0, (1 - 2 * ((i1>>1) & 1)), (1 - 2 * ((i1 + (i1>>1)) & 1)));\n\n        // Swizzle sign adjustments by axis \n        if (axis == 1) {sv0 = sv0.zxy; sv1 = sv1.zxy;}\n        if (axis == 2) {sv0 = sv0.yzx; sv1 = sv1.yzx;}\n\n        if (i == 0) c0 = b * sv0;\n        if (i == 1) c1 = b * sv0;\n        if (i == 2) c2 = b * sv0;\n        if (i == 3) c3 = b * sv0;\n        \n        // ∆0 and ∆1 subtending the counterclockwise edge\n        vec3 d0 = b * sv0 - a, d1 = b * sv1 - a;\n        \n        // Vector perpendicular to triangle from edge to apex, scaled by parallelogram.\n        // Equivalent to great circle normal connecting ∆0 and ∆1, but scaled.        \n        vec3 n = cross(d0, d1); // |∆0x∆1| = |∆0||∆1|sin(γ)\n        float dnn = dot(n, n);  // |N|^2\n        float ddn = dot(d, n);  // |D||N|cos(θ)\n        \n        // Cull back facing edges\n        if (ddn * ddotN < 0.0) continue; \n        edges[i] = i;\n    }\n    \n    // Account for previously applied reflections.\n    c0 = mix(c0, -c0, reflected);\n    c1 = mix(c1, -c1, reflected);\n    c2 = mix(c2, -c2, reflected);\n    c3 = mix(c3, -c3, reflected);\n    \n    return edges;\n}\n\n\n// cheaper alternative to acos intrinsic\n// https://developer.download.nvidia.com/cg/acos.html\nfloat swacos(float x) {\n  float negate = float(x < 0.f);\n  x = abs(x);\n  float ret = -0.0187293f;\n  ret = ret * x;\n  ret = ret + 0.0742610f;\n  ret = ret * x;\n  ret = ret - 0.2121144f;\n  ret = ret * x;\n  ret = ret + 1.5707288f;\n  ret = ret * sqrt(1.f-x);\n  ret = ret - 2.f * negate * ret;\n  return negate * 3.14159265358979f + ret;\n}\n\n// Given an angular similarity, returns the corresponding angle in radians. \n//   s - the similarity measure, s = (dot(d, ∆) |dot(d, ∆)| / |∆|^2)\nfloat similarityToAngle(float s) {\n    if (0.f <= s && s <= 1.f) {\n        return swacos(2.f * s - 1.0) / 2.0;\n    }\n    else if (-1.f <= s) {\n        return (swacos(2.f * s + 1.0) / 2.0) + radians(90.);\n    }\n}\n\n// Returns the angular similarity between two directions. \n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  d - the direction of a ray\n//  ∆ - a vector relative to ray's origin. (∆ = p - o)\nfloat angularSimilarity(vec3 d, vec3 delta) {    \n    // length squared of delta\n    float deltaNorm2 = dot(delta, delta);\n    \n    // proportional to cos(theta) between d and ∆\n    float dDotDelta = dot(d, delta);\n    \n    // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n    return dDotDelta * abs(dDotDelta) / deltaNorm2;\n}\n\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nvec3 angleAxis(float angle, vec3 axis, vec3 v) {\n    vec3 k = normalize(axis); // Ensure the axis is a unit vector\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    // Rodrigues' rotation formula\n    vec3 rotated = v * cosTheta + \n                   cross(k, v) * sinTheta + \n                   k * dot(k, v) * (1.0 - cosTheta);\n\n    return rotated;\n}\n\n//https://www.shadertoy.com/view/NttcW8\nfloat sdArrow(vec3 position, vec3 start, vec3 end, float baseRadius, float tipRadius, float tipHeight) {\n    vec3 t = start - end;\n    float l = length(t);\n    t /= l;\n    l = max(l, tipHeight);\n\n    position -= end;\n    if (t.y + 1.0 < 0.0001) {\n        position.y = -position.y;\n    } else {\n        float k = 1.0 / (1.0 + t.y);\n        vec3 column1 = vec3(t.z * t.z * k + t.y, t.x, t.z * -t.x * k);\n        vec3 column2 = vec3(-t.x, t.y, -t.z);\n        vec3 column3 = vec3(-t.x * t.z * k, t.z, t.x * t.x * k + t.y);\n        position = mat3(column1, column2, column3) * position;\n    }\n \n    vec2 q = vec2(length(position.xz), position.y);\n    q.x = abs(q.x);\n   \n    // tip\n    vec2 e = vec2(tipRadius, tipHeight);\n    float h = clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d1 = q - e * h;\n    vec2 d2 = q - vec2(tipRadius, tipHeight);\n    d2.x -= clamp(d2.x, baseRadius - tipRadius, 0.0);\n    \n    // base\n    vec2 d3 = q - vec2(baseRadius, tipHeight);\n    d3.y -= clamp(d3.y, 0.0, l - tipHeight);\n    vec2 d4 = vec2(q.y - l, max(q.x - baseRadius, 0.0));\n\n    float s = max(max(max(d1.x, -d1.y), d4.x), min(d2.y, d3.x));\n    return sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4))) * sign(s);\n}\n\nfloat sdSolidAngle(vec3 p, vec3 a, vec3 d, vec3 b) {\n    // Length of the side of the solid angle conic\n    float ra = distance(a, b);    \n    \n    // The angle between the direction of the conic and a point\n    // on the base.\n    float s = angularSimilarity(d, b-a);\n    float ang = similarityToAngle(clamp(s, 0.0, 1.0));\n    \n    // Transform query point s.t. apex is origin\n    p = p-a;\n    \n    // Rotate query point such that conic direction is aligned to \"y\"\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 rotAxis = cross(d, yAxis);\n    float rotAngle = acos(dot(yAxis, d));\n    vec3 pRot = angleAxis(rotAngle, rotAxis, p);\n\n    // Now compute the SDF as before with the rotated point\n    vec2 q = vec2( length(pRot.xz), pRot.y );\n    \n    vec2 c = vec2(sin(ang), cos(ang)); \n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdSolidAngle(vec3 p, vec3 a, vec3 d, float ra, float ang) {\n    // Length of the side of the solid angle conic\n    //float ra = length(d); // distance(a, b);    \n    \n    // The angle between the direction of the conic and a point\n    // on the base.\n    //float s = angularSimilarity(d, b-a);\n    //float ang = similarityToAngle(clamp(s, 0.0, 1.0));\n    \n    // Transform query point s.t. apex is origin\n    p = p-a;\n    \n    // Rotate query point such that conic direction is aligned to \"y\"\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 rotAxis = cross(d, yAxis);\n    float rotAngle = acos(dot(yAxis, d));\n    vec3 pRot = angleAxis(rotAngle, rotAxis, p);\n\n    // Now compute the SDF as before with the rotated point\n    vec2 q = vec2( length(pRot.xz), pRot.y );\n    \n    vec2 c = vec2(sin(ang), cos(ang)); \n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n//------------------------------------------------------------\nconst vec3 pa = vec3(-0.7,-0.2,0.4);\nconst vec3 pb = vec3( 0.7,0.2,-0.1);\n\nconst vec3 box_rad = vec3(0.5,0.4,0.3);\n\n\n\nvec2 map( in vec3 pos, bool showBox, bool showSolidAngle, in vec3 apex, in vec3 dir )\n{\n    vec2 res = vec2(1e38f);\n    \n    vec4 sxyz = ctpBoxQuery(apex, dir, box_rad);\n    \n    vec3 p = sxyz.yzw;\n    float s = sxyz[0];\n\n    \n    // closest point on query surface\n    if (sxyz[0] > 0.f) {\n    float d = sdSphere( pos, p, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n   \n    // Arrow representing the ray\n    {\n    float d = sdArrow(pos, apex, apex+dir, .01, .06, .08);\n    if( d<res.x ) res =  vec2( d, 0.0 );\n    }\n    \n    // Query cone   \n    if (showSolidAngle) {   \n    float angle = similarityToAngle(s);\n    float d = sdSolidAngle(pos, apex, dir, 3.f, angle);\n    if( d<res.x ) res =  vec2( d, 1.0);\n    }\n    \n    // box (semi-transparent)    \n    if( showBox )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    // Visualize the edges tested\n    {\n    vec3 c0, c1, c2, c3;\n    ivec4 edges = getRelevantEdges(apex, dir, box_rad, c0, c1, c2, c3);\n    if (edges[0] != -1) {\n        float d = sdCapsule( pos, c0, c1, 0.02 );\n        if( d<res.x ) res = vec2( d, 2.0 );\n    }\n    if (edges[1] != -1) {\n        float d = sdCapsule( pos, c1, c2, 0.02 );\n        if( d<res.x ) res = vec2( d, 2.0 );\n    }\n    if (edges[2] != -1) {\n        float d = sdCapsule( pos, c2, c3, 0.02 );\n        if( d<res.x ) res = vec2( d, 2.0 );\n    }\n    if (edges[3] != -1) {\n        float d = sdCapsule( pos, c3, c0, 0.02 );\n        if( d<res.x ) res = vec2( d, 2.0 );\n    }\n    \n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, bool showBox, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showBox, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showBox, showCapsule, sampleLineStart, sampleLineStop).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n       // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 1.5*cos(an), 0.7, 1.5*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate the tangent cone\n        vec3 start = 1.5*-sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0)); //* vec3(0.0, 1.0, 1.0) + vec3(0.0, 0.0, 0.0);\n        vec3 stop  = 1.5*-cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));// * vec3(0.0, 1.0, 1.0) + vec3(0.0, 0.0, 0.0);\n        vec3 apex = start;\n        vec3 dir = normalize(stop - start);\n        \n        // Make bounding capsule transparent\n        bool showBox = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showCapsule = ((samp.x+samp.y+1)&1)==0; \n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, showBox, showCapsule, apex, dir);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, showBox, showCapsule, apex, dir);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            vec4 sxyz = ctpBoxQuery(apex, dir, box_rad);\n            float angle = similarityToAngle(sxyz.x);\n            vec3 p = sxyz.yzw;\n            \n            // show distance isolines on surface\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = sdBox( p, box_rad);\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-2.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // Show distance isolines on query\n            if( abs(m-1.0)<0.6 )\n            {     \n                \n                float dref = sdSolidAngle(p, apex, dir, p);\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-2.0*(dsam-dref)*(dsam-dref));\n            }\n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, showBox, showCapsule, apex, dir);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}