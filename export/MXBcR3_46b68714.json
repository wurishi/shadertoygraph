{"ver":"0.1","info":{"id":"MXBcR3","date":"1727530750","viewed":57,"name":"stage 0 migraine","username":"Insimplexia","description":"HW 1","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reactive","distortion","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SCALECOUNT = 150.0;\nconst float INVSC = 1.0 / SCALECOUNT;\nconst float RSPEED = 4.0;\nconst float NV = 0.2;\n\n\n\nvec4 freqs = vec4(0.0);\n\nvec4 freqAnalysis() { // extracting frequency for noise\n  \n    vec4 samp = vec4(0.0);    \n    samp.x = texture(iChannel0, vec2(0.0, 0.0)).x;\n\tsamp.y = texture(iChannel0, vec2(0.33, 0.0)).x;\n    samp.z = texture(iChannel0, vec2(0.66, 0.0)).x;\n    samp.w = texture(iChannel0, vec2(1.0, 0.0)).x;\n    return samp;\n}\n\n\nvec3 rgb2hsv(in vec3 c) {\n    vec4 colConst = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 compOrd = mix(vec4(c.bg, colConst.wz), vec4(c.gb, colConst.xy), step(c.b, c.g));\n    vec4 hueVal = mix(vec4(compOrd.xyw, c.r), vec4(c.r, compOrd.yzx), step(compOrd.x, c.r));\n\n    float sat = hueVal.x - min(hueVal.w, hueVal.y);\n    float epsilon = 1.0e-10;\n    return vec3(abs(hueVal.z + (hueVal.w - hueVal.y) / (6.0 * sat + epsilon)), sat / (hueVal.x + epsilon), hueVal.x);\n}\n\n\nvec3 hsv2rgb(in vec3 c) {\n    vec4 colConst = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 hueComp = abs(fract(c.xxx + colConst.xyz) * 6.0 - colConst.www);\n    return c.z * mix(colConst.xxx, clamp(hueComp - colConst.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat sin3(in vec3 p) {\n\treturn (sin(p.x) + sin(p.y) + sin(p.z));\n}\n\n\nfloat noise(in vec3 p) {\n    float tf = iTime * 0.05; // time factor\n    float noiseVal = (sin3((p + vec3(tf * 7.0, tf * 2.3, tf * 1.0)) * 10.0) * freqs.w +\n                      sin3((p + vec3(tf * 8.0, tf * 1.2, tf * 8.4)) * 8.0) * freqs.z +\n                      sin3((p + vec3(tf * 2.4, tf * 2.3, tf * 2.6)) * 6.0) * freqs.y +\n                      sin3((p + vec3(tf * 5.4, tf * 5.8, tf * 1.9)) * 4.0) * freqs.x) * NV;\n    \n    noiseVal = abs(noiseVal);\n    float f = noiseVal * 10.0;\n    \n    noiseVal = clamp((smoothstep(0.0, 1.0, mix(0.1, 0.9, noiseVal*10.0-f)) + f)* 0.1, 0.0, 1.0);\n    return noiseVal;\n}\n\n\nvec3 colorPaletteGeneration(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d));\n}\n\n\nbool sdSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out vec3 p1, out vec3 p2) {\n    p1 = vec3(0.0); // first intersection point\n    p2 = vec3(0.0); // second\n    \n    vec3 oc = ro - c;\n    float b = dot(rd, oc);\n    float c2 = dot(oc, oc) - r * r;\n    float disc = b * b - c2;\n    if (disc < 0.0) return false;\n    float sqrtDisc = sqrt(disc);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    p1 = ro + t1 * rd;\n    p2 = ro + t2 * rd;\n    return true;\n}\n\n\nvec3 sphereNormal(in vec3 dir, in float r, in float e) {\n    float theta = atan(dir.y,dir.x) ;\n    float phi = acos(dir.z);\n    \n    vec3 dx0 = vec3(cos(theta)*sin(phi+e), sin(theta)*sin(phi+e), cos(phi+e));\n    vec3 dx1 = vec3(cos(theta)*sin(phi-e), sin(theta)*sin(phi-e), cos(phi-e));\n    vec3 dy0 = vec3(cos(theta+e)*sin(phi), sin(theta+e)*sin(phi), cos(phi));\n    vec3 dy1 = vec3(cos(theta-e)*sin(phi), sin(theta-e)*sin(phi), cos(phi));\n\n    float nx0 = noise(dx0*r);\n    float nx1 = noise(dx1*r);\n    float ny0 = noise(dy0*r);\n    float ny1 = noise(dy1*r);\n    \n    dx0 *= r + nx0;\n    dx1 *= r + nx1;    \n    dy0 *= r + ny0;\n    dy1 *= r + ny1;\n\n    return normalize(cross(dy0 - dy1, dx1 - dx0));\n}\n\n\nbool sdDistortedSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, in float br, out vec3 n, out vec3 sd) {\n    n = vec3(0.0);\n    sd = vec3(0.0);\n    \n    vec3 bp1 = vec3(0.0); // bounding points for larger sphere assuming it's distorted all over\n    vec3 bp2 = vec3(0.0);\n    bool bres = sdSphere(ro, rd, c, br, bp1, bp2);\n    if (!bres) return false;\n    \n    vec3 p1 = vec3(0.0); // actual intersection points\n    vec3 p2 = vec3(0.0);\n    bool res = sdSphere(ro, rd, c, r, p1, p2); \n    \n    float dist = float(res) * length(p1 - bp1) + (1.0 - float(res)) * length(bp1 - bp2);\n    \n    const float inv_sc = 1.0 / SCALECOUNT;\n    float scdist = dist * inv_sc;\n    \n    bool isHit = false;\n    vec3 pn = vec3(0.0); // potential normal\n    for (float i = 0.0; i < SCALECOUNT; i++) {\n    \tpn = (bp1 + i * scdist * rd) - c;\n        sd = normalize(pn) * r;\n        float h = length(pn) - r - scdist;\n        \n        float h0 = noise(sd); // distortion height\n        if (h0 > h) {\n            isHit = true;\n            break;\n        } \n    }\n    \n    n = sphereNormal(normalize(pn), r, scdist);\n    return isHit;\n}\n\n       \nfloat shadowFactor(in vec3 surfdir, in vec3 ld, in vec3 c, in float r, in float br) {\n    float nv = noise(surfdir);\n    vec3 ro = c + (normalize(surfdir) * (nv + r));\n    \n    vec3 bp1 = vec3(0.0);\n    vec3 bp2 = vec3(0.0);\n    bool bres = sdSphere(ro, -ld, c, br, bp1, bp2);\n    \n    vec3 p1 = vec3(0.0);\n    vec3 p2 = vec3(0.0);\n    bool res = sdSphere(ro, -ld, c, r, p1, p2);\n    \n    float dist = min(length(ro - bp1)+ float(!bres) * 1000.0, \n                     length(ro - p1) + float(!res) * 1000.0);\n    \n    float scd = dist * INVSC;\n    \n    float mindinst = 1.0;\n    \n    for (float i = 0.0; i < SCALECOUNT; i++) {\n    \tvec3 pn = (ro + i* scd * -ld) - c;\n\t\t\n        surfdir = normalize(pn) * r;\n        \n        float h = length(pn) - r + scd;\n        \n        float h0 = noise(surfdir);\n        if (h0 > h) {\n            mindinst = 0.0;\n            break;\n        }\n        \n        mindinst = min(mindinst, 4.0 * (h - h0) / (i * scd));\n    }\n    \n    return clamp(mindinst, 0.0, 1.0);\n    \n}\n\n\nvec3 GetColor(vec3 sd) {\n    float n = noise(sd);\n    vec3 c = colorPaletteGeneration(n, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.7, 0.4), vec3(0.0, 0.15, 0.20));\n    \n    c = rgb2hsv(c);\n    c.y += 0.30;\n    c.z += 0.1;\n    c = hsv2rgb(c);\n    \n    return c;\n}\n\n\nvec3 cameraRay(vec2 fragCoord, float n) {\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    return normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n}\n\n\nmat3 rotAx(vec3 axis, float phi) {\n    float c = cos(phi);\n    float s = sin(phi);\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    return mat3(vec3(c + (1.0 - c) * x * x, (1.0 - c) * x * y - s * z, (1.0 - c) * x * z + s * y),\n                vec3((1.0 - c) * y * x + s * z, c + (1.0 - c) * y * y, (1.0 - c) * y * z - s * x),\n                vec3((1.0 - c) * z * x - s * y, (1.0 - c) * z * y + s * x, c + (1.0 - c) * z * z)\n    );\n}\n\nmat3 rotX(float phi) {\n    return rotAx(vec3(1.0, 0.0, 0.0), phi);\n}\n\nmat3 rotY(float phi) {\n    return rotAx(vec3(0.0, 1.0, 0.0), phi);\n}\n\nmat3 rotZ(float phi) {\n    return rotAx(vec3(0.0, 0.0, 1.0), phi);\n}\n\n\nstruct cam {\n    vec3 p;\n    vec3 d;\n    vec3 ang;\n    float fov;\n};\n\ncam mainCam = cam(vec3(0.0, 0.0, 5.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), 90.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseAng = (iMouse.xy * 2.0 - iResolution.xy) * RSPEED / iResolution.x;\n    float phi = mouseAng.x;\n    float theta = mouseAng.y;\n    vec3 fCamPos = rotY(phi) * mainCam.p;\n    vec3 fCamDir = rotY(phi) * mainCam.d;\n    vec3 fCamT = mainCam.ang;\n    vec3 fCamR = cross(fCamDir, fCamT);\n    float camD = 1.0 / tan(radians(mainCam.fov / 2.0));    \n    fCamPos = rotAx(fCamR, -theta) * fCamPos;\n    fCamDir = rotAx(fCamR, -theta) * fCamDir;\n    fCamT = rotAx(fCamR, -theta) * fCamT;\n   \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec3 rd = normalize(fCamDir * camD + fCamR * uv.x + fCamT * uv.y);\n\n    vec3 sc = vec3(0.0, 0.0, 10.0);\n    float sr = 1.0;\n    vec3 n = vec3(0.0);\n    vec3 sd = vec3(0.0);\n    \n    if (sdSphere(vec3(0.0), rd, fCamPos, sr + 1.0, n, sd)) {\n        freqs = freqAnalysis();\n    }\n    \n    bool hit = sdDistortedSphere(vec3(0.0), rd, fCamPos, sr, sr + 1.0, n, sd);\n    \n    vec3 color = vec3(0.01);\n    \n    if (hit) {\n        float w = max(max(freqs.x,freqs.y) , max(freqs.z, freqs.w));\n        vec2 nMult = vec2(sin(iTime * 1.4), cos(iTime * 1.2));\n        vec3 l = normalize(vec3(-(nMult.x * 2.0 - 1.0), -(nMult.y * 2.0 - 1.0), -0.9 + w * 3.0));\n        float sf = shadowFactor(sd, l, sc, sr, sr + 1.0);\n        \n        color = GetColor(sd);\n        vec3 diff = color * max(dot(-l, n), 0.0 ) * 0.95;\n        vec3 amb = color * 0.5;\n        \n        color = diff;\n        color += amb;\n        color *= diff;\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.55)), 1.0);\n}","name":"Image","description":"","type":"image"}]}