{"ver":"0.1","info":{"id":"XdKSWm","date":"1464779829","viewed":129,"name":"IchBinBlauTest","username":"Draedrus","description":"Shader effect for being sick","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n#define CAMDIST 8.0\n#define CAMROTSPEED 0.2\n#define FAR 100.0\n#define NEAR 0.002\n\n#define OCTAVES 2\n\n#define VAR_FRESNEL_BIAS 0.2\n#define VAR_FRESNEL_SCALE 1.0\n#define VAR_FRESNEL_POW 2.0\n\n// old\n//#define VAR_MOONRADIUS 1.0\n#define VAR_MOONRADIUS 200.0\n\n#define CAMPOS vec3(-5.0, 0.0, 0.0)\n#define TARGETPOS vec3(0.0, 1.0, 0.0)\n\n#define TYPE_TERRAIN 0.0\n#define TYPE_WATER 1.0\n#define TYPE_TREES 2.0\n#define TYPE_MOUNTAIN 3.0\n\n#define USE_ANIMBLAU\n#define BLUR_EPS 0.01\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\n/*******************\n * TOOLS\n *******************/\n\nvec2 UVTwist(in vec2 uv, float a) {\n    float cA = cos(a+iTime);\n    float sA = sin(a+iTime);\n\treturn uv*mat2(cA, -sA, sA, cA);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat Fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(dot(I,N), E);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash1D(float x) {\n\treturn fract(((x+124.2394943)*134.400594)*((x+7.13571113)*1.13497));\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(0.4955, 490.4294, 0.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n/**\n * noise and smoothNoise function were inspired by common knowledge found in internet.\n **/\nfloat hash2(float x) {\n    return fract(sin(x)*556858.4905705783);\n}\n\n/**\n * Inspired from a noisy function in \"Seascape\" by TDM\n **/\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash2(wx+0.0)     , hash2(wx+1.0), f.x),\n                mix(hash2(wx+0.0+winy), hash2(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash2(wx+0.0+winz)     , hash2(wx+1.0+winz), f.x),\n                mix(hash2(wx+0.0+winy+winz), hash2(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat noise1D(float x) {\n    float p = floor(x);\n    float n = fract(x);\n    float f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 2.0;\n    \n    return mix(\n                mix(hash1D(p)     , hash1D(p+winx), f),\n                mix(hash1D(p+winy), hash1D(p+winx+winy), f),\n                f);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += iTime*CLOUDSPEED;\n    #endif\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p) {\n    float total = 0.0;\n    /*total += 0.5000*smoothNoise(p*2.0);\n    total += 0.2500*smoothNoise(p*2.01);\n    total += 0.1250*smoothNoise(p*2.02);\n    total += 0.0625*smoothNoise(p*2.04);*/\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += iTime*CLOUDSPEED;\n    #endif\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3DTerrain(vec3 p) {\n    float total = 0.0;\n    #ifdef USE_HD_TERRAIN_NOISE\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    #else\n    \t#ifdef USE_FAST_HD_TERRAIN_NOISE\n        p*=0.8;\n        total  = 0.5000* snoise(p.xz); p = p*2.0;\n        total += 0.2500* snoise(p.xz); p = p*2.0;\n        total += 0.1250* snoise(p.xz); p = p*2.0;\n        total += 0.0625* snoise(p.xz); p = p*2.0;\n   \t \t#else\n        total  = 0.5000* noise3D(p); p = p*2.0;\n        total += 0.2500* noise3D(p); p = p*2.0;\n        total += 0.1250* noise3D(p); p = p*2.0;\n        total += 0.0625* noise3D(p); p = p*2.0;\n    \t#endif\n    #endif\n    return total;\n}\n\nfloat fbm3DMountain(vec3 p) {\n    float total = 0.0;\n    #ifdef USE_HD_MOUNTAIN_NOISE\n    p*=2.0;\n    total  = 0.5000* voronoi3D(p); p = p*2.0;\n    total += 0.2500* voronoi3D(p); p = p*2.0;\n    total += 0.1250* voronoi3D(p); p = p*2.0;\n    total += 0.0625* voronoi3D(p); p = p*2.0;\n    #else\n    \t#ifdef USE_FAST_HD_MOUNTAIN_NOISE\n        p*=2.0;\n        total  = 0.5000* voronoi2D(p.xz); p = p*2.0;\n        total += 0.2500* voronoi2D(p.xz); p = p*2.0;\n        total += 0.1250* voronoi2D(p.xz); p = p*2.0;\n        total += 0.0625* voronoi2D(p.xz); p = p*2.0;\n   \t \t#else\n        total  = 0.5000* waterNoise(p.xz); p = p*2.0;\n        total += 0.2500* waterNoise(p.xz); p = p*2.0;\n        total += 0.1250* waterNoise(p.xz); p = p*2.0;\n        total += 0.0625* waterNoise(p.xz); p = p*2.0;\n    \t#endif\n    #endif\n    return total;\n}\n\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES+2;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\n/************************\n * RENDERING\n ************************/\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 n = vec3(0.0);\n    vec3 color = vec3(0.0);\n    rd.y = -rd.y;\n    //float D = min(1.0, max(0.0, pow(0.5+length(uv-vec2(0.5, 0.5)), 2.0)-1.0));\n    float D = (4.0*pow(length(uv-vec2(0.5, 0.5)), 3.0)+0.5);\n    \n    vec3 uvo = RotYV3(rd, 0.1*dot(rd, vec3(1.0, 0.0, 0.0)));\n\n    // base color\n    color = texture(iChannel0, ro+rd).rgb;\n    vec3 blurColor = vec3(0.0);\n    blurColor = texture(iChannel0, ro+rd+uvo+vec3(-BLUR_EPS, 0.0, 0.0)).rgb;\n    blurColor += texture(iChannel0, ro+rd+uvo+vec3(BLUR_EPS, 0.0, 0.0)).rgb;\n    blurColor += texture(iChannel0, ro+rd+uvo+vec3(0.0, -BLUR_EPS, 0.0)).rgb;\n    blurColor += texture(iChannel0, ro+rd+uvo+vec3(0.0, BLUR_EPS, 0.0)).rgb;\n    blurColor += texture(iChannel0, ro+rd+uvo+vec3(0.0, 0.0, -BLUR_EPS)).rgb;\n    blurColor += texture(iChannel0, ro+rd+uvo+vec3(0.0, 0.0, BLUR_EPS)).rgb;\n    blurColor *= 0.12;\n    \n    //D = min(1.0, Fresnel(rd, vec3(0.0, 0.0, 1.0), 0.1, 4.0, 2.0));\n    \n    color = mix(color, blurColor, D);\n    \n    #ifdef USE_ANIMBLAU\n    float greenAdditiveColor = texture(iChannel0, ro+rd+vec3(0.1, sin(iTime)*0.1, 0.1)).g;\n    color.g += greenAdditiveColor*(D-0.4);\n    #endif\n    //color = vec3(D);\n    return clamp(color, 0.0, 1.0);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;\n\trd = normalize(rdi*rotY);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    lPos = lPos*rotZ*rotX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    float T = sin(iTime);\n    float a = .5*(1.+T);\n    vec3 mx, my, mz;\n    mat3 vm;\n    {\n        mz = normalize(TARGETPOS-ro);\n        {\n            my = vec3(0., 1., 0.);\n            mx = cross(my, mz);\n         \tvm = mat3(mx, my, mz);\n        }\n        my = vm*normalize(vec3(mix(-0.2, 0.2, a), mix(1., 0.8, a), 0.));\n    \tro += vm*vec3(T, .2*sin(2.*iTime), 0.);\n        mx = cross(my, mz);\n    }\n    vm = mat3(mx, my, mz);\n    \n    rd = vm*rd;\n    \n    /*#ifdef SET_CAMERA_TARGET_ROTATION\n    ro.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    \n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    #else\n    \t#ifdef USE_MARCH\n    \tvec3 campath = vec3(\n            cos(iTime*CAMROTSPEED)*CAMDIST,\n            0.0,\n            sin(iTime*CAMROTSPEED)*CAMDIST+Time*30.0);\n        ro += campath;\n        mat3 ca = setCamera(ro, ro+campath, vec3(0.0, 1.0, 0.0));\n        rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \t#else\n            mat3 ca = setCamera(ro, ro+vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n            rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \t#endif\n    #endif\n    #ifdef SET_CAMERA_DEFAULT_ROTATION\n        rd = RotYV3(rd, Time*CAMROTSPEED);\n    #endif\n    #ifdef SET_CAMERA_SUNDOWN\n    \trd = RotYV3(rd, -1.0);\n    #endif\n    #ifdef SET_CAMERA_SUNRISE\n    \trd = RotYV3(rd, 3.10);\n    #endif\n    rd = RotYV3(rd, mv.x);\n    rd = RotZV3(rd, -mv.y);\n    #ifdef USE_ANIMBLAU\n    rd = RotXV3(rd, sin(iTime)*0.2);\n    #endif\n\n    rd = RotYV3(rd, length(rd)*dot(pixel, vec2(-1.0, 0.0)));*/\n    vec3 color = rendering(ro, rd, uv);\n    \n    /*float d = fract(iTime*0.1)*dot(abs(pixel), vec2(1.0, 0.0));\n    color = vec3(uv*mat2(cos(d), -sin(d), sin(d), cos(d)), 0.0);*/\n    //color = vec3(uv, 0.0);\n    \n    //color = RotYV3(rd, dot(rd, vec3(1.0, 0.0, 0.0)));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}