{"ver":"0.1","info":{"id":"ltcSzs","date":"1481488226","viewed":771,"name":"Christmas 2016 orbs","username":"TambakoJaguar","description":"After a long time without being on Shadertoy, here is my contribution for Christmas 2016!\nMove the view around with the mouse.\nYou can change the number of lamps on line 93.\n\nI had a hard time to give a 2D star form to the orbs!","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["christmas","colorful","stars","ball","rotating","snow","orbs","gold","lamps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Christmas 2016 orbs\" by Emmanuel Keller aka Tambako - December 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define show_gold\n#define gold_bump\n#define specular\n#define star_orbs\n#define orbs_rings\n#define reflections\n#define ss_scatering\n#define show_snow\n\n//#define antialias\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ      0\n#define BALL_OBJ     1\n\nLamp lamps[3];\n\n// Campera parameters\nvec3 campos = vec3(0., -0., 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 5.0;\n\n// Ambient light parameters\nconst vec3 ambientColor = vec3(0.5);\nconst float ambientint = 0.05;\n\n// Shading parameters\nconst float ssstrmr = 0.85;\nconst float sssInt = 0.39;\nconst vec3 sssColor = vec3(0.85, 0.92, 1.);\nconst float specint = 0.4;\nconst float specshin = 60.;\n\n// Gold parameters\nconst vec3 goldColor = vec3(1.1, 0.91, 0.52);\nconst vec3 goldColor2 = vec3(1.1, 0.97, 0.68);\nconst vec3 goldColor3 = vec3(1.06, 0.86, 0.55);\nconst float goldRef = 0.99;\nconst float goldTreshold = 0.8;\nconst float goldFrequency = 40.;\nconst float goldBump = 0.013;\n\n// Ball parameters\nconst vec3 ballColor = vec3(1.0, 0.97, 0.94);\nconst float ballRadius = 1.12;\nconst float ballIOR = 2.2;\n\n// Snow parameters\nconst vec3 snowColor = vec3(0.9, 0.95, 1.0);\nconst float snowHeight = 0.44;\nconst float snowHeightDist = 0.12;\nconst float snowPosVar = 0.28;\nconst float snowPosVarFreq = 2.5;\nconst float snowPosPow = 0.27;\nconst float snowThicknessFactor = 0.12;\nconst float snowBumpBig = 0.36;\nconst float snowBumpBigFreq = 3.2;\nconst float snowBumpSmall = 0.011;\nconst float snowBumpSmallFreq = 185.;\n\n// Tracing parameters\nconst float normdelta = 0.001;\nconst float maxdist = 40.;\n\nconst float stLampsInt = 0.55;\n// Rotating lamps parameters\nconst int nbLamps = 16;\nconst float lampsGenInt = 0.5;\nconst float lampsAttenuation = 0.6;\nconst float lampsMinRadius = 1.3;\nconst float lampsMaxRadius = 1.7;\nconst float lampsMinSpeed = 1.0;\nconst float lampsMaxSpeed = 4.7;\nconst float lampsMinIntensity = 0.7; \nconst float lampsMaxIntensity = 1.0;\nconst float lampsMinIntensityVariation = 0.25; \nconst float lampsMaxIntensityVariation = 0.65;\nconst float lampsMinIntensityFrequency = 8.; \nconst float lampsMaxIntensityFrequency = 42.;\n\n// Some parameters of the star of orbs\nconst float starRad = 30000.;\nconst float starRingRad = 0.028;\nconst float starNbBranches = 6.;\nconst float starPow = 3.;\nconst float starStrength = 0.5;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvec3 speccol = vec3(0.);\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-500., 300., -500.), vec3(0.81, 0.89, 1.), 2.9, 0.001);\n    lamps[1] = Lamp(vec3(150., 400., 200.), vec3(0.74, 0.82, 1.), 2.2, 0.001);\n    lamps[2] = Lamp(vec3(250., -400., 100.), vec3(0.6, 0.73, 1.), 1., 0.001);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat noisePattern(vec3 pos)\n{\n    return noise(normalize(pos)*2.5);\n}\n\nvec3 snowPos(vec3 pos)\n{\n    return pos + snowPosVar*noise(pos*snowPosVarFreq);\n}\n\nfloat snowValue(vec3 pos)\n{\n    #ifdef show_snow\n    return smoothstep(snowHeight - 0.004, snowHeight, snowPos(pos).y);\n    #else\n    return 0.;\n    #endif\n}\n\nfloat snowThickness(vec3 pos)\n{\n    #ifdef show_snow\n    vec3 pos2 = pos + 0.5*noise(pos*snowBumpSmallFreq*1.743);\n    float st = pow(smoothstep(snowHeight, snowHeight + snowHeightDist, snowPos(pos).y), snowPosPow);\n    return st*(1. + snowBumpBig*noise(pos*snowBumpBigFreq))*(1. + snowBumpSmall*noise(pos2*snowBumpSmallFreq));\n    //return st*(1. + snowBumpBig*noise(pos*snowBumpBigFreq));\n    #else\n    return 0.;\n    #endif\n}\n\nfloat goldValue(vec3 pos)\n{\n    #ifdef show_gold\n    vec3 pos2 = pos + 0.1*noise(pos*12.);\n    return (1. - snowValue(pos))*smoothstep(goldTreshold, goldTreshold + 0.01, sin(noisePattern(pos2)*goldFrequency));\n    #else\n    return 0.;\n    #endif\n}\n\nfloat map_ball(vec3 pos)\n{\n    float snow = snowThicknessFactor*snowThickness(pos);\n    float df = length(pos) - ballRadius - snow;\n    \n    #ifdef show_gold\n    #ifdef gold_bump\n    vec3 pos2 = pos + 0.1*noise(pos*12.);\n    df+= goldBump*(1. - snowValue(pos))*smoothstep(goldTreshold + 0.15, goldTreshold + 0.01, sin(noisePattern(pos2)*goldFrequency));\n    #endif\n    #endif\n    \n    return df;\n}\n\nvec2 map(vec3 pos)\n{\n    float ball = map_ball(pos);\n    vec2 res = vec2(ball, BALL_OBJ);\n    \n    return res;\n}\n\n// Main tracing function\nfloat lastDist;\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.005)\n            break;\n        t+= dist*0.5;\n        objnr = abs(res.y);\n  \t}\n    lastDist = t;\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\nvec3 colorRamp3(vec3 col1, vec3 col2, vec3 col3, float v)\n{\n   return mix(mix(col1, col2, smoothstep(0.0, 0.5, v)), col3, smoothstep(0.5, 1.0, v));   \n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    //float r = texture(iChannel0, ray).r;\n    ray+= 0.35*noise(ray*6.2);\n    ray+= 0.05*noise(ray*21.5);\n    ray+= 0.02*noise(ray*72.5);\n    float r = 2.*ray.y;\n    vec3 col1 = vec3(0.0, 0.15, 0.35);\n    vec3 col2 = vec3(0.2, 0.3, 0.5);\n    vec3 col3 = vec3(0.5, 0.6, 0.7);\n    return colorRamp3(col1, col2, col3, r);\n}\n\nvec3 getGoldColor(vec3 pos)\n{\n    pos+= 0.4*noise(pos*24.);\n    float t = noise(pos*30.);\n    vec3 col = mix(goldColor, goldColor2, smoothstep(0.55, 0.95, t));\n    col = mix(col, goldColor3, smoothstep(0.45, 0.25, t));\n    return col;\n}\n\nvec3 getBallColor(vec3 pos)\n{\n\tvec3 col1 = mix(ballColor, getGoldColor(pos), pow(goldValue(pos), 4.));\n    return mix(col1, snowColor, snowValue(pos));\n}\n  \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   return objnr==BALL_OBJ?getBallColor(pos):sky_color(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n    \n    lamp.intensity*=stLampsInt;\n      \n    // Diffuse shading\n    vec3 col;\n    col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n \n    float specint2 = specint*(1. - snowValue(pos));\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        speccol+= lamp.color*lamp.intensity*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n\n \t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef ss_scatering\n    float transmission = map(pos + pl*ssstrmr).x/ssstrmr;\n\tvec3 sssLight = sssColor*lamp.color*smoothstep(0.0,1.0, transmission);\n    float sssInt2 = sssInt*snowValue(pos);\n    col = col*(1. - sssInt2) + sssInt2*sssLight;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all static lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\nfloat getLampIntensity(int lampNr, float t)\n{\n    float li = lampsMinIntensity + (lampsMaxIntensity - lampsMinIntensity)*hash(float(lampNr*156 + 541));\n    float liv = lampsMinIntensityVariation + (lampsMaxIntensityVariation - lampsMinIntensityVariation)*hash(float(lampNr*674 + 247));\n    float lif = lampsMinIntensityFrequency + (lampsMaxIntensityFrequency - lampsMinIntensityFrequency)*hash(float(lampNr*842 + 617));\n    return lampsGenInt*(li + liv*(sin(t*lif)*0.5 + 0.5));\n}\n\nvec3 getLampColor(int lampNr)\n{\n    float hue = hash(float(lampNr*621 + 127));\n    vec3 hsv = vec3(hue, 1.0, 1.0);\n    return hsv2rgb(hsv);\n}\n\nvec3 getLampPosition(int lampNr, float t)\n{\n    t+= 15.*hash(float(lampNr*541 + 315));\n    float r = lampsMinRadius + (lampsMaxRadius - lampsMinRadius)*hash(float(lampNr*348 + 173));\n    float s = lampsMinSpeed + (lampsMaxSpeed - lampsMinSpeed)*hash(float(lampNr*447 + 914));\n    float a1 = 2.*pi*hash(float(lampNr*519 + 327));\n    float a2 = 2.*pi*hash(float(lampNr*864 + 616));\n    vec3 pos = vec3(0, rotateVec(vec2(r, 0), s*t));\n    pos.xz = rotateVec(pos.xz, a1);\n    pos.xy = rotateVec(pos.xy, a2);\n    return pos;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading2(float lintensity, vec3 lcolor, vec3 lpos, vec3 norm, vec3 pos, vec3 ocol)\n{   \n    vec3 pl = normalize(lpos - pos);\n    float dlp = distance(lpos, pos);\n    vec3 pli = pl/pow(1. + lampsAttenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col;\n    col = ocol*lcolor*lintensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    float specint2 = 1.7*specint*(1. - snowValue(pos));\n    speccol+= lcolor*lintensity*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all static lamps\nvec3 lampsShading2(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    float lintensity;\n    vec3 lcolor;\n    vec3 lpos;\n        \n    for (int l=0; l<nbLamps; l++)\n    {\n        lintensity = getLampIntensity(l, iTime);\n        lcolor = getLampColor(l);\n        lpos = getLampPosition(l, iTime);\n        col+= lampShading2(lintensity, lcolor, lpos, norm, pos, ocol);\n    }\n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    float lintensity;\n    vec3 lcolor;\n    vec3 lpos;\n    \n    for (int l=0; l<nbLamps; l++)\n    {\n        lintensity = getLampIntensity(l, iTime);\n        lcolor = getLampColor(l);\n        lpos = getLampPosition(l, iTime);    \n        \n        if (distance(campos, lpos)<lastDist)\n        {\n            float lp = pow(max(0.0, dot(ray, normalize(lpos - campos))), 20000.);\n            #ifdef orbs_rings\n            float lp2 = 0.08*smoothstep(starRingRad*0.85, starRingRad, lp)*smoothstep(starRingRad*1.8, starRingRad, lp);\n            #endif\n            \n            #ifdef star_orbs\n            // Complicated stuff to calculate the projection of the lamp position on the image plane\n            // From: http://stackoverflow.com/questions/23472048/projecting-3d-points-to-2d-plane\n            vec3 v3 = (lpos - campos) - dot((lpos - campos), ray) * ray;\n            vec3 vx = vec3(0., 1., 0.);\n            vx = normalize(vx - dot(vx, ray)*ray);\n            //vec3 vy = cross(ray, vx);\n            vec3 vy = vec3(ray.y*vx.z - ray.z*vx.y, ray.z*vx.x - ray.x*vx.z, ray.x*vx.y - ray.y*vx.x);\n            float a = atan(dot(v3, vx)/dot(v3, vy));\n            // Gives the angle a star look\n            float spp = starRad*(1. + starStrength*pow(sin(a*starNbBranches), starPow));\n            lp = pow(max(0.0, dot(ray, normalize(lpos - campos))), spp);\n            #endif\n            \n            #ifdef orbs_rings\n            lp+= lp2;\n            #endif\n            \n            rc+= 5.5*clamp(normalize(mix(lcolor, vec3(1.), 0.55*pow(lp, 1.5)))*lintensity*specint*lp, 0., 1.);\n        }\n    }\n    return rc;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 4.;\nconst float aym = 1.5;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, -iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, -iMouse2.x*axm);\n\n   camtarget = vec3(0.);\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr) + lampsShading2(norm, pos, col);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n    speccol = vec3(0.);\n    \n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \t//vec3 col = screen(traceinf.col, getFlares(ray);\n    vec3 col = traceinf.col;\n    vec3 refray;\n\n    if (traceinf.objnr==BALL_OBJ)\n    {\t \n        float gv = goldValue(traceinf.pos);\n            \n        #ifdef reflections\n        refray = reflect(ray, traceinf.norm);\n        float rf = fresnel(ray, traceinf.norm, ballIOR)*(1. - snowValue(traceinf.pos)); \n        vec3 colBa = mix(col, sky_color(refray), rf);\n        vec3 goldColor = getGoldColor(traceinf.pos);\n        vec3 colGo = mix(col, goldColor*sky_color(refray), goldRef);\n        col = mix(colBa, colGo, gv);\n        col+= speccol*mix(vec3(1.), goldColor*goldColor, gv);\n        #endif\n    }\n    if (traceinf.objnr==SKY_OBJ)\n    col+= sky_color(ray);\n    col+= getFlares(ray);\n\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}