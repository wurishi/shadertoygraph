{"ver":"0.1","info":{"id":"4lBXWW","date":"1443499119","viewed":1834,"name":"Procedural SkyBox","username":"Passion","description":"A procedurally generated skybox with a bumpy raymarched sphere.\nShaders used at top of code.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ------- Shaders Used ---------\n\t\n\tfbm noise and hash functions\n\tfrom 'Apple' by iq\n\thttps://www.shadertoy.com/view/XdfGRn\n\n\tblending of the fbm and saturate function \n    from '2D Fast Clouds' by Sinuousity \n\thttps://www.shadertoy.com/view/XsjSRt\n\n   ------------------------------\n*/\n\n//2d Fast Clouds const\n//SETTINGS//\nconst float timeScale = 20.;\nconst float softness = 0.28;\nconst float brightness = 1.0;    \nconst float cover = 0.55;\n//SETTINGS//\n\nconst float eps = 0.001;\n#define time iTime\n\nmat2 rot(float deg){    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\n\nfloat distanceFunction(vec3 pos){\n    \n    float disp = sin(pos.x*9.)*sin(pos.y*9.)*sin(pos.z*9.);\n    disp*=.05;\n    \n    //pos.y+=sin(time);\n    float sph = (length(pos) - 2.2);\n   \n    return sph+disp;\n}\n \nvec3 getNormal(vec3 p){\n    const float d = eps;\n    return normalize(vec3(distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n                          distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n                          distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))));\n}\n\nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 -iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, -4.8);\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t//float time = iTime;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //Fisheye lens effect from 'Cypher'\n\t//https://www.shadertoy.com/view/MlsGRS - dila\n    vec3 rayDir = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.3)); \n    \n    camPos.xz*=rot(time*.6); \n    camPos.zy*=rot(time*.4);\n    rayDir.xz*=rot(time*.6); \n    rayDir.zy*=rot(time*.4);\n    \n    float t = 0.0, d;\n    vec3 posOnRay = camPos;\n    float dense = 16.0;\n    //light*=ry*rx;\n    //sun-sunIntensity from 'Kepler 256o'\n    //https://www.shadertoy.com/view/XsjGRd - otaviogood\n    vec3 localRay = normalize(rayDir);\n    vec3 light = normalize(vec3(1.2,.8,.1));\n    float sunIntensity = 1.0 - (dot(localRay, light) * 0.5 + 0.5);\n    sunIntensity = 0.2 / sunIntensity;\n    sunIntensity = min(sunIntensity, 40000.0);\n    sunIntensity = max(0.0, sunIntensity - 3.0);\n    //////////////////////////////////////////////////\n    \n    for(int i=0; i<32; ++i){\n        d = distanceFunction(posOnRay);\n        t += d;\n        posOnRay = camPos + t*rayDir;\n        //if(d < eps){ break; }\n    }\n    \n  \n    vec3 normal = getNormal(posOnRay);\n\t\n    float bright = brightness*(1.8-cover);\n    \n    //cloud coverage from '2d Fast Clouds' \n    //https://www.shadertoy.com/view/XsjSRt - Sinuousity\n    float color1 = fbm((rayDir*3.5)-0.5+iTime*0.02*timeScale);  //xz\n    float color2 = fbm((rayDir*7.2)-10.5+iTime*0.01*timeScale); //yz\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    vec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\n\n    vec4 skyCol = vec4(0.6,0.8,1.0,1.0);\n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);\n    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);\n    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));\n    vec4 clouds = vec4(0.0);\n\tclouds = mix(skyCol,cloudColComb,cloudsFormComb);\n    \n    fragColor=vec4(0.0);\n    \n    float c1 = fbm(posOnRay*1.5);\n    float c2 = fbm(posOnRay*2.0);\n    float c3 = fbm(posOnRay);\n    \n    vec3 noiseCol = sqrt((vec3(cos(c1*c1)/c1, cos(c2*c2)/c2,cos(c3*c3*c3)/c3))*.25);\n    \n    if(abs(d) < eps){\n        float diffuse = clamp( dot(normal, light), 0.15, 1.);\n        //Blinn-Phong half vector\n        vec3 h = normalize(-rayDir + light);\n        //Specular\n        float spe1 = pow(clamp(dot(h, normal), 0.0, 1.0), 33.0*4.);\n        vec3 brdf = 1.5*vec3(.10, .11, .11);\n        float fre = 0.1*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n        brdf += 1.30*diffuse*vec3(1., .9, .75);\n        vec3 spe = vec3(skyCol.rgb)*spe1;\n        fragColor = vec4(vec3(noiseCol)*diffuse+spe+brdf*fre, 1.0);  \n    } else {\n        fragColor = vec4(0.0);\n        fragColor.rgb+=clouds.rgb;           //; //.4\n        fragColor.rgb += sunCol*(sunIntensity*.00075);        \n    }\n}","name":"Image","description":"","type":"image"}]}