{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Tweak these to get different results\nconst int   NUM_CIRCLES \t= 17;\nconst float TIME_MULTIPLIER = 3.0;\nconst float CONSTANT_N\t    = 3.0;\n\nconst float N = CONSTANT_N;\n\n// Actual code below\n\n#define TWO_PI 6.28318530718\n#define TWO_THIRDS_PI 2.09439510239\n\n\nvec2 curUV;\n\nvec3 drawCircle(vec2 p, vec2 center, float radius, float edgeWidth, vec3 color)\n{\n    float dist = length(p - center);\n   \t\n    vec3 ret;\n\tret = color * (1.0 - smoothstep(radius, radius+edgeWidth, abs(dist-0.35) ));\n   \n    return ret;\n} \n\nvec3 draw(mat3 mat) {\n  // get center\n    return drawCircle(curUV, vec2(mat[2][0], mat[2][1]), 0.001, 0.01, vec3(1,1,1));\n}\n\n\n\nmat3 t1,t2;\n\n// shadertoy gives unknown error on try of recursion, thus\n// duplication...\n\nvec3 rec5(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    //col += rec5(tt1,iter-1);\n    //col += rec5(tt2,iter-1);\n    \n    return col;\n}\n\n\nvec3 rec4(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec5(tt1,iter-1);\n    col += rec5(tt2,iter-1);\n    \n    return col;\n}\n\nvec3 rec3(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec4(tt1,iter-1);\n    col += rec4(tt2,iter-1);\n    \n    return col;\n}\n\nvec3 rec2(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec3(tt1,iter-1);\n    col += rec3(tt2,iter-1);\n    \n    return col;\n}\n\n\nvec3 rec(mat3 t, int iter) {\n    if(iter < 1)\n        return vec3(0.);\n    \n    vec3 col;\n    \n    mat3 tt1 = t * t1;\n    mat3 tt2 = t * t2;\n    \n    col += draw(tt1);\n    col += draw(tt2);\n    \n    col += rec2(tt1,iter-1);\n    col += rec2(tt2,iter-1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Map coordinates into a small window around [-1, 1]\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\tuv *= 1.2;\n\t\n    t1 = mat3(0.9,-.2,0.0,sin(iTime),0.9,0,-0.4,.3 + cos(iTime * 0.2),0);\n    t2 = mat3(0.5,-0.3 + cos(iTime * 0.8 + 0.1),0.1,0.2 + sin(iTime * 1.3),0.8,0,0.1,-0.2,0);\n    \n    \n\tvec3 color = vec3(0.0);\n\tfloat angleIncrement = TWO_PI / float(NUM_CIRCLES);\n    \n    mat3 tcur = mat3(1,0,0,0,1,0,0, 0,0);\n    \n    curUV = uv;\n\tcolor += rec(tcur,5);\n    \n    /*\n\tfor (int i = 0; i < NUM_CIRCLES; ++i) {\n\t\tfloat t = angleIncrement*(float(i));\n\t\tfloat r = sin(float(N)*t+iTime*TIME_MULTIPLIER);\n\t\tvec2 p = vec2(r*cos(t), r*sin(t));\n\n\t\tvec3 circleColor = vec3(sin(t),\n\t\t\t\t\t\t\t\tsin(t+TWO_THIRDS_PI),\n\t\t\t\t\t\t\t\tsin(t+2.0*TWO_THIRDS_PI))*0.5+0.5;\n\n        float radius = 0.06;\n       color += drawCircle(curUV, p, radius, 0.01, circleColor);\n\t}\n\t*/\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssXWs","date":"1407871016","viewed":2650,"name":"SIG2014_HERBST","username":"herbst","description":"should become an deterministic ifs renderer.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ifs"],"hasliked":0,"parentid":"","parentname":""}}