{"ver":"0.1","info":{"id":"DsKSzG","date":"1681303518","viewed":69,"name":"Shiny Pawn","username":"xor_swap","description":"Shiny pawn, not much to say.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Cristian A. aka @swap_xor on twitter\n// I make cool stuff, follow me and checkout\n// https://github.com/cristian-5\n\n// materials:\n\n#define obj vec2\n\nconst int GOLD = 7;\nconst int SILVER = 9;\nconst int BLACK_GOLD = 0;\n\n// primitives:\n\nfloat sphere(vec3 p, vec3 o, float r) {\n\treturn length(p - o) - r;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - r;\n}\n\nfloat cylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0)); // exterior distance\n\tfloat i = min(max(x, y), 0.0); // interior distance\n\treturn e + i;\n}\n\nfloat cylinder(vec3 p, vec3 b, float h, float r) {\n\treturn cylinder(p, b, vec3(b.x, b.y + h, b.z), r);\n}\n\n// objects:\n\nobj pawn(vec3 p, vec3 b) {\n    float y = b.y + 1.5 - p.y;\n    float base = cylinder(p, vec3(b.x, b.y, b.z), 0.05, 0.365) / 2.2;\n    float belly = cylinder(p, vec3(b.x, b.y + 0.3, b.z), - 0.3,\n        0.35 * (sin(y * 6.0 - 0.1) + 0.03)\n    );\n    float neck = cylinder(p, vec3(b.x, b.y + 0.775, b.z), - 0.04, 0.26 * y);\n    float separator = cylinder(p, vec3(b.x, b.y + 0.33, b.z), vec3(b.x, b.y + 0.29, b.z), 0.275);\n    float body = capsule(p, vec3(b.x, b.y + 1.0, b.z), vec3(b.x, b.y + 0.3, b.z),\n        (p.y < b.y || p.y > b.y + 1.5) ? 0.0 : clamp(0.25 * pow(y * 0.8, 2.4), 0.0, 1.5)\n\t);\n    float head = sphere(p, vec3(b.x, b.y + 1.0, b.z), 0.22);\n    float m = min(base, min(head, min(neck, min(separator, min(body, belly)))));\n    if (m == head) return obj(m, BLACK_GOLD);\n    else return obj(m, SILVER);\n}\n\n// scene:\n\nobj scene(vec3 p) {\n    return pawn(p, vec3(0.0, 0, 0));\n}\n\nconst int   MAX_STEPS = 100;\nconst float MAX_DIST  = 100.0;\nconst float SURF_DIST = 0.01;\n\nobj march(in vec3 ro, in vec3 rd) {\n\tfloat d0 = 0.0;\n    obj ds = obj(0.0);\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * d0;\n\t\tds = scene(p);\n\t\td0 += ds[0];\n\t\tif (d0 >= MAX_DIST || abs(ds[0]) <= SURF_DIST) break;\n\t}\n\treturn obj(d0, ds[1]);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = scene(p)[0];\n\tvec2 e = vec2(0.01, 0.0);\n\tvec3 n = d - vec3(\n\t\tscene(p - e.xyy)[0],\n\t\tscene(p - e.yxy)[0],\n\t\tscene(p - e.yyx)[0]\n\t); // n is a point close to p;\n\treturn normalize(n);\n}\n\nvec3 direction(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 fragment(in vec2 uv) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 3, - 4);\n    ro.yz *= rotation(- m.y * 3.14 - 0.5);\n    ro.xz *= rotation(- m.x * 6.2831 + sin(iTime / 9.5) * 3.0);\n    vec3 rd = direction(uv, ro, vec3(0, 0.5, 0), 2.0);\n    vec3 color = texture(iChannel0, rd).rgb;\n    obj d = march(ro, rd);\n    if (d[0] < MAX_DIST) {\n        vec3 p = ro + rd * d[0];\n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n        vec3 reflection = texture(iChannel0, r).rgb;\n        float dif = dot(n, normalize(vec3(1, 2, 3))) * 0.5 + 0.5;\n        color = vec3(dif) * reflection;\n        switch (int(d[1])) {\n            case BLACK_GOLD: color *= 0.08; break;\n            case GOLD: color *= vec3(1, 1, 0); break;\n            case SILVER: color *= vec3(0.8, 0.8, 0.8); break;\n        }\n    }\n    color = pow(color, vec3(0.4545)); // gamma correction\n\treturn color;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\tvec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\tcolor = vec4(fragment(uv), 1.0);\n}\n\n#undef obj\n","name":"Image","description":"","type":"image"}]}