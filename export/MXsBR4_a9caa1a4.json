{"ver":"0.1","info":{"id":"MXsBR4","date":"1728157904","viewed":14,"name":"Light vs Darkness vs Chaos","username":"hyndryn","description":"Have Fun letting Darkess, Light and Chaos fight each other. This Shader emerged from Trying to see the inner of Ouroboros.\nLight vs Darkness vs Chaos , God vs Ego vs \"idk\"\nTry to find out how to beat the Chaos. \n","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["simple","chaos","god","ego","darkness","ight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 PrintChar(vec2 uv, int char, vec2 pos, float size)\n{\n    vec2 BoxUV = (uv - pos) / size;\n    bool inBox = (BoxUV.x >= 0. && BoxUV.x <= 1. && BoxUV.y >= 0. && BoxUV.y <= 1.);\n    \n    if(!inBox)\n    {\n        return vec4(0);\n    }\n    \n    BoxUV *= numberTexResFac ;\n    BoxUV.x += float(char%16)*numberTexResFac;\n    BoxUV.y += (15. - floor(float( char/16)))*numberTexResFac;\n       \n    return texture(iChannel1, BoxUV) ;  \n}\n\nvec4 PrintLine(vec2 uv, int[LineLength] line, vec2 pos, float size)\n{\n    vec4 rlt = vec4(0);\n    float cachedSpacing = size*SPACING;\n    vec2 currPos = pos;\n    currPos.x -= cachedSpacing*0.5;\n    for(int i = 0; i < LineLength; i++)\n    {\n         rlt += PrintChar(uv, line[i], currPos, size);\n         currPos.x += cachedSpacing;\n    }\n    return rlt;\n}\n\nfloat GetValAtKey(int key)\n{    \n   return texelFetch(iChannel0, ivec2(key, 0), 0).x; \n}\n\nfloat GetStateAtKey(int key)\n{    \n   return texelFetch(iChannel0, ivec2(key, 0), 0).y; \n}\n\nfloat GetTimeReset()\n{\n    return texelFetch(iChannel0, ivec2(KEY_n, 0), 0).z; \n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //Admin: Press \"N\" to reset Time\n    const float speedOfLight_And_Darkness = 1.00;  \n    float FightingTime = speedOfLight_And_Darkness * (iTime - GetTimeReset());\n    float gravitiy = 0.5/pow(1.2,FightingTime);\n    \n    \n    //Camera \n    //vec2 USER_Offset = vec2(-(GetValAtKey(KEY_RIGHT) - GetValAtKey(KEY_LEFT)), GetValAtKey(KEY_DOWN) - GetValAtKey(KEY_UP));\n    vec2 midOffset = vec2(gravitiy*sin(FightingTime),gravitiy*cos(FightingTime));    \n    vec2 ScreenMidUv = (uv - 0.5) * 2.;\n    vec2 MidUv = midOffset + ScreenMidUv;\n\n    \n    //Snake Distance\n    // You can see the Winner of the Fight only with enough distance to the Snake\n    float USER_SnakeDistance =(GetValAtKey(KEY_a) - GetValAtKey(KEY_q));\n    MakeBar(uv, USER_SnakeDistance);  \n    float SnakeDistance = 66.6 + USER_SnakeDistance * 666.; \n    \n    //Chaos - do whatever you want with the 2 factors\n    //If you don't go to the snake you won't recognize the Effect, \n    //The higher You set this though the more Chaos remains in the end\n    float USER_SenselessChaos = (GetValAtKey(KEY_w) - GetValAtKey(KEY_s));\n    MakeBar(uv, USER_SenselessChaos);   \n    float SenselessChaos = 88. + USER_SenselessChaos * 333.;\n    \n    float normalizedChaos = 1./SenselessChaos;\n    \n    float USER_ChaosImportance = (GetValAtKey(KEY_e) - GetValAtKey(KEY_d));\n    MakeBar(uv, USER_ChaosImportance);\n\n    float w_Chaos = 3.8 + USER_ChaosImportance * 111.;\n  \n  \n    //Choose One Side\n    float USER_Importance = (GetValAtKey(KEY_r) - GetValAtKey(KEY_f));\n    MakeBar(uv, USER_Importance);\n   \n     const float LuziferConstant = 0.01;\n     const float LuziferFactor = 1.01;\n     \n     float w_ligthImportance = 0.5 + LuziferConstant + LuziferFactor* USER_Importance;\n     float w_selfImportance = 0.5 - USER_Importance;\n     /* ---comment out----- w_ligthImportance = 0.5; \n     w_selfImportance = 0.5; -----------\n     */\n        \n     w_ligthImportance *= SnakeDistance;\n     w_selfImportance *= SnakeDistance;\n    \n     \n    for(float chaos = 0.; chaos < SenselessChaos; chaos++)\n    {\n        float distance = 1.0 - length(MidUv);\n        float myDistance = 1.0 - length(ScreenMidUv);       \n        float currentDistance = pow(distance, w_ligthImportance) - pow(myDistance, w_selfImportance);\n        col = vec3(fract(currentDistance*chaos), fract(w_Chaos * currentDistance*(chaos -chaos*normalizedChaos)), fract(w_Chaos*currentDistance*(chaos - 2.* chaos*normalizedChaos)));\n    }\n    \n    col = clamp(col, 0.00001, 1.);\n    fragColor = vec4(col + bar, 1.0);\n    \n\n    float temp = 0.;\n    float lStart = 0.99 - pLineLength;\n    fragColor += PrintLine(uv, Line1, vec2(lStart, temp), FONTSIZE).xxxx;\n    temp += FONTSIZE;\n    fragColor += PrintLine(uv, Line2, vec2(lStart, temp), FONTSIZE).xxxx;\n    temp += FONTSIZE;\n    fragColor += PrintLine(uv, Line3, vec2(lStart, temp), FONTSIZE).xxxx;\n    temp += FONTSIZE;\n    fragColor += PrintLine(uv, Line4, vec2(lStart, temp), FONTSIZE).xxxx;\n     temp += FONTSIZE;\n    fragColor += PrintLine(uv, Line5, vec2(lStart, temp), FONTSIZE).xxxx;\n}\n\n/*PS auf deutsch: \nIch habe ChatGPT das Ganze interpretieren lassen \nund ich fand die mechanische Art wie ChatGPT versuchte das Ganze zu begreifen, ziemlich lustig:\nhttps://chatgpt.com/share/6701a53b-8c14-8012-8a9f-fe7678785cee\n\nSo schwer ist es auch nicht zu interpretieren - das weiß ich.\nAber die LuziferKonstante \nund das \"Spiel\" mit der Schlange hat ChatGPT nicht richtig interpretiert.\nChatGPT konnte ja auch nicht tatsächlich spielen, also kann es dahingehend schon nicht alles richtig erfahren und begreifen.\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst int KEY_RESET_n = 78;     // 0x4E\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    ivec2 iFragCoord = ivec2(fragCoord);    \n    float raise = 0.001;   \n    \n    vec3 val = texelFetch(iChannel0, iFragCoord, 0).xyz;\n    float keypressed = texelFetch(iChannel1, iFragCoord, 0).x;\n    val.x += keypressed * raise;\n    val.y = keypressed;\n    \n    fragColor = vec4(val, 0);\n    if(iFragCoord.x == KEY_RESET_n && bool(keypressed))\n    {\n        fragColor.z = iTime;\n    }\n   \n   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*Quite common commons in Common here but they should be more common, imo ... the same for everyone ...\nBut quite hard to achieve this with so many different languages ...\nobviously political here */\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_a = 65;     // 0x41\nconst int KEY_b = 66;     // 0x42\nconst int KEY_c = 67;     // 0x43\nconst int KEY_d = 68;     // 0x44\nconst int KEY_e = 69;     // 0x45\nconst int KEY_f = 70;     // 0x46\nconst int KEY_g = 71;     // 0x47\nconst int KEY_h = 72;     // 0x48\nconst int KEY_i = 73;     // 0x49\nconst int KEY_j = 74;     // 0x4A\nconst int KEY_k = 75;     // 0x4B\nconst int KEY_l = 76;     // 0x4C\nconst int KEY_m = 77;     // 0x4D\nconst int KEY_n = 78;     // 0x4E\nconst int KEY_o = 79;     // 0x4F\nconst int KEY_p = 80;     // 0x50\nconst int KEY_q = 81;     // 0x51\nconst int KEY_r = 82;     // 0x52\nconst int KEY_s = 83;     // 0x53\nconst int KEY_t = 84;     // 0x54\nconst int KEY_u = 85;     // 0x55\nconst int KEY_v = 86;     // 0x56\nconst int KEY_w = 87;     // 0x57\nconst int KEY_x = 88;     // 0x58\nconst int KEY_y = 89;     // 0x59\nconst int KEY_z = 90;     // 0x5A\n\nconst float barWidth = 0.015;\nfloat currentBar = 0.;\nvec3 bar = vec3(0.);\nint currentBarIndex = 0;\nint currentBarRev = 0;\nvoid MakeBar(vec2 uv, float val)\n{\n    if(uv.x < 0.5 + val  && uv.y < (currentBar + barWidth) && uv.y > currentBar)\n    {\n       bar[currentBarIndex] += 1.0;\n       bar[currentBarIndex + currentBarRev] += 1.0;\n    }\n    currentBar+= barWidth;\n    currentBarIndex++;\n    if(currentBarIndex > 2)\n    {\n    currentBarIndex = 0;\n    currentBarRev++;\n    }\n}\n\n\n\n\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\n\nconst int A = 65;\nconst int B = 66;\nconst int C = 67;\nconst int D = 68;\nconst int E = 69;\nconst int F = 70;\nconst int G = 71;\nconst int H = 72;\nconst int I = 73;\nconst int J = 74;\nconst int K = 75;\nconst int L = 76;\nconst int M = 77;\nconst int N = 78;\nconst int O = 79;\nconst int P = 80;\nconst int Q = 81;\nconst int R = 82;\nconst int S = 83;\nconst int T = 84;\nconst int U = 85;\nconst int V = 86;\nconst int W = 87;\nconst int X = 88;\nconst int Y = 89;\nconst int Z = 90;\n\nconst int ff = 32;\n\nconst int _equals = 61;\nconst int _plus = 43;\nconst int _minus = 45;\n\nconst float numberTexResFac = (1./16.);  \nconst int LineLength = 16;\n\nconst int Line1[LineLength] = int[](s,e,a,r,c,h, ff, s, n, a, k, e, ff, q, _minus, a);\nconst int Line2[LineLength] = int[](c,h,a,o,s, R, e, s, ff, w, _minus, s, ff, ff, ff, ff);\nconst int Line3[LineLength] = int[](c,h,a,o,s, P, o, w, ff, e, _minus, d, ff, ff, ff, ff);\nconst int Line4[LineLength] = int[](l,i,g,h,t, ff, d, a, r, k, ff, r, _minus, f, ff, ff);\nconst int Line5[LineLength] = int[](r,e,s,t,a,r, t, ff, N, ff, ff, ff, ff, ff, ff, ff);\nconst float SPACING = 0.45;\nconst float FONTSIZE = 0.023;\nconst float pLineLength = (float(LineLength) * FONTSIZE)*SPACING;\n","name":"Common","description":"","type":"common"}]}