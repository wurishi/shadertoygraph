{"ver":"0.1","info":{"id":"ld33DX","date":"1452446899","viewed":586,"name":"Pixel Terrain","username":"polkm","description":"Pixel art terrain","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fbm","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float noise(vec2 co) {\n  return texture(iChannel0, co - floor(co)).r;\n}\n\nvec3 noised( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\tfloat a = noise((p + vec2(0.5, 0.5)) / 512.0);\n\tfloat b = noise((p + vec2(1.5, 0.5)) / 512.0);\n\tfloat c = noise((p + vec2(0.5, 1.5)) / 512.0);\n\tfloat d = noise((p + vec2(1.5, 1.5)) / 512.0);\n\treturn vec3(a + (b - a) * u.x + (c - a) * u.y + (a - b - c + d) * u.x * u.y,\n\t\t\t\t6.0 * f * (1.0 - f) * (vec2(b - a, c - a) + (a - b - c + d) * u.yx));\n}\n\nfloat fbmd(vec2 co, int octaves, float amp, float gain, float freq, float lac) {\n\tfloat sum = 0.0;\n\tfloat dx = 0.0;\n\tfloat dz = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec3 n = noised(co * freq);\n\t\tdx += n.y;\n\t\tdz += n.z;\n\t\tsum += amp * n.x / (1.0 + dx*dx + dz*dz);\n\t\tamp *= gain;\n\t\tco *= lac;\n\t}\n\treturn sum;\n}\n\n\nfloat waterHeight(vec2 pos)\n{\n\treturn 5.6 + cos(iTime * 3.0) * 0.3;\n}\n\nfloat terrainHeight(vec2 pos)\n{\n    float h = 0.0;\n\tfloat amp = 32.0;\n\th += fbmd(pos, 7, amp, 0.4, 0.015, 2.8);\n\th -= amp * 0.6;\n\tif (h > waterHeight(pos)) {\n\t\th = mix(h, floor(h / 3.0) * 3.0, 0.2);\n\t\th = mix(h, floor(h / 5.0) * 5.0, 0.2);\n\t}\n\treturn h;\n}\n\nfloat height(vec2 pos)\n{\n\treturn max(terrainHeight(pos), waterHeight(pos));\n}\n\nfloat normDelta = 2.0;\nvec3 normal(vec3 pos) {\n\tvec3 org = vec3(pos.x, pos.y, (height(pos.xy)));\n\tvec3 adx = vec3(pos.x - normDelta, pos.y, (height(vec2(pos.x - normDelta, pos.y)))) - org;\n\tvec3 bdx = vec3(pos.x, pos.y - normDelta, (height(vec2(pos.x, pos.y - normDelta)))) - org;\n\n\treturn normalize(cross(adx, bdx));\n}\n\nvec3 calcNormal( in vec3 pos) {\n\tvec2 eps = vec2(normDelta, 0.0);\n\treturn normalize(vec3(\n\t\theight(pos.xy - eps.xy) - height(pos.xy + eps.xy),\n\t\theight(pos.xy - eps.yx * vec2(1, 2)) - height(pos.xy + eps.yx * vec2(1, 2)),\n\t\t2.0 * eps.x\n\t));\n}\n\nvec3 darkWater = vec3(41.0, 84.0, 126.0) / 256.0;\nvec3 lightWater = vec3(57.0, 143.0, 147.0) / 256.0;\n\nvec3 sand = vec3(164.0, 162.0, 94.0) / 256.0;\nvec3 grass = vec3(67.0, 133.0, 53.0) / 256.0;\n\nvec3 black = vec3(0, 0, 0);\n\nvec3 sundir = normalize(vec3(0.2, -0.5, 0.8));\nvec3 sunColor = vec3(240.0, 240.0, 137.0) / 256.0;\nvec3 ambLight = vec3(20.0, 30.0, 46.0) / 256.0;\n\nvec3 sunDir() {\n    float time = iTime;\n    return normalize(vec3(cos(time), sin(time), abs(sin(time)) * 0.5 + 0.5));\n}\n                     \nvec4 volume(vec3 pos)\n{\n\tfloat h = terrainHeight(pos.xy);\n\tfloat wh = waterHeight(pos.xy);\n\tfloat rh = max(h, wh);\n\tfloat roundH = floor(rh);\n\tif (rh > pos.z)\n\t{\n        vec3 diffuse = vec3(1, 1, 1);\n\t\tif (h > wh) {\n\t\t\tvec3 sandComp = mix(black, sand, clamp((1.0 + rh) / 2.0, 0.0, 1.0));\n\t\t\tvec3 grassComp = mix(grass, sandComp, clamp(abs(rh - 10.0) / 10.0, 0.0, 1.0));\n            diffuse = grassComp;\n\t\t} else {\n\t\t\tfloat t = clamp(1.0 - ((wh - h) / 10.0), 0.0, 1.0);\n\t\t\tfloat thres = 0.80;\n\t\t\tif (t > thres) {\n\t\t\t\tt = (t - thres) / (1.0 - thres);\n\t\t\t\tdiffuse = vec3(mix(lightWater, vec3(0.70, 0.99, 0.99), t * t));\n            } else {\n                diffuse = vec3(mix(darkWater, lightWater, (t - (1.0 - thres)) / thres));\n            }\n\t\t}\n        \n        vec3 lightComp = diffuse * sunColor * clamp(dot(calcNormal(pos), sunDir()), 0.1, 0.8);\n        return vec4(ambLight + lightComp, 1);\n\t}\n\treturn vec4(0, 0, 1, 0);\n}\n\nconst float maxHeight = 64.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 pos = floor(fragCoord / 2.0) * 2.0 + vec2(iTime * 20.0, -iTime * 10.0);\n\n\tfor (float i = 0.0; i < maxHeight; i++)\n\t{\n\t\tvec3 testPoint = vec3(pos.x, pos.y + i * 2.0 - maxHeight, maxHeight - i);\n\t\tvec4 diffuse = volume(testPoint * vec3(1, 2, 1));\n\t\tif (diffuse.w > 0.0) {\n\t\t\tfragColor = vec4(diffuse.rgb, 1);\n            return;\n\t\t}\n\t}\n    \n    //fragColor = vec4(fragCoord.x / iResolution.x, 0, 0, 1);\n}","name":"","description":"","type":"image"}]}