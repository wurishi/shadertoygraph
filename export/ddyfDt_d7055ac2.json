{"ver":"0.1","info":{"id":"ddyfDt","date":"1698762461","viewed":55,"name":"Fork самый вкус agentodess 418","username":"agentodessa","description":"what I miss in Limassol","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["delivery"],"hasliked":0,"parentid":"msGfDt","parentname":"самый вкусный"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n#define PHI 1.6180339\n#define INV_PHI 0.61803398\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime) {\n    vec2 init = vec2(0.55, 0.62);\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\nfloat opUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSubstr(float d2, float d1, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat smin(float d1, float d2) {\n    const float e = -6.;\n    return log(exp(d1*e)+exp(d2*e))/e;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return length(max(d,0.)) - rb;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 ) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k = vec2(.1,.15);\n  vec2 l = vec2(-.4,.3);\n  vec2 m = vec2(q.x-min(q.x,q.y<0.?.5:.1),\n  abs(q.y)-.15);\n  k-=q;\n  float c = clamp( dot(k,l)/dot(l,l), 0.0, 1.0 );\n  vec2 n = l*c-k;\n  float s = (n.x<0.0 && m.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(m,m),dot(n,n)) );\n}\nvec3 opRepLim( in vec3 p, in float c, in vec3 l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\n#define AA 1.\nvec3 background(vec3 d) {\n    float light = dot(d,sqrt(vec3(.3,.5,.2)));\n    return vec3(max(light*.5+.5,.0));\n}\nvec4 hexcoord(vec2 uv, float r) {\n    uv /= r;\n    vec2 h = vec2(1., sqrt(3.)) * .5;\n    vec2 a = mod(uv, 2. * h) - h;\n    vec2 b = mod(uv - h, 2. * h) - h;\n    vec2 gv = length(a) < length(b) ? a : b;\n    return vec4(gv, uv - gv) * r;\n}\nfloat map(vec3 p) {\n    vec4 h = hexcoord(p.xz, 1.4);\n    p.xz = h.xy;\n    p.y += .05*sin(.5*h.z+iTime)*sin(.5*h.w+iTime);\n    float r = length(p);\n    float phi = atan(p.z / p.x);\n    float tetha = acos(p.y / r);\n    float di = cos(12. * (phi + .5*tetha))\n        * smoothstep(.4, .55, length(p + vec3(0,.35,0)));\n    float d = sdCappedCone(p, .15, .5, .1);\n    d -= .09 - .02 * di;\n    d = min(d,sdRoundedCylinder(p - vec3(0,.2,0), .08, .04, .2));\n    return d;\n}\nvec3 normal(vec3 p) {\n    vec2 e = vec2(1,-1)*.01;\n    return normalize(map(p-e.yxx)*e.yxx+map(p-e.xyx)*e.xyx+\n    map(p-e.xxy)*e.xxy+map(p-e.y)*e.y);\n}\nvec4 march(vec3 p, vec3 d) {\n    vec4 m = vec4(p,0);\n    for(int i = 0; i<99; i++) {\n        float s = .85*map(m.xyz);\n        m += vec4(d,1)*s;\n        if (s<.001 || m.w>20.) break;\n    }\n    return m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec3 col = vec3(0);\n    vec3 pos = vec3(0,0,-2);\n    vec3 lig = sqrt(vec3(.3,.5,.2));\n    vec4 mouse = qmouse(iMouse, iResolution, iTime);\n    for(float x = 0.;x<AA;x++)\n    for(float y = 0.;y<AA;y++)\n    {\n        vec3 ray = normalize(vec3(fragCoord-res/2.+vec2(x,y)/AA,res.y));\n        ray = rotate(ray, mouse);\n        pos = rotate(pos, mouse);\n        vec4 mar = march(pos,ray);\n        vec3 nor = normal(mar.xyz);\n        vec3 ref = refract(ray,nor,.75);\n        float r = smoothstep(.8,1.,dot(reflect(ray,nor),lig));\n        float l = 1.-dot(ray,nor);\n        vec3 mat = background(ref)+.5*r*l*l;\n        vec3 bac = background(ray)*.5+.5;\n        float fade = pow(min(mar.w/10.,1.),.3);\n        col += mix(mat,bac,fade);\n    }\n    col /= AA*AA;\n    fragColor = vec4(col*col,1);\n}","name":"Image","description":"","type":"image"}]}