{"ver":"0.1","info":{"id":"fdyGzK","date":"1631781998","viewed":68,"name":"Volume exp","username":"green92","description":"Volume","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Inter {\n    float t;\n    vec3 n;\n    vec3 c;\n};\n\nuint hash(uint x) {\n    x = x * 0xA789BCFDu;\n    x = (x ^ (x >> 16)) * 0xA789BCFDu;\n    return x;\n}\n\nfloat rand01(uint seed) {\n    return float(hash(seed) & 0x7FFFFFFFu) / float(0x7FFFFFFFu);\n}\n\nvec3 randvec3m11(uint seed) {\n    uint h = hash(seed);\n    return vec3(\n        float(h & 0xFFFFFFu),\n        float((h >> 1) & 0xFFFFFFu),\n        float((h >> 2) & 0xFFFFFFu)\n    ) / float(0xFFFFFFu) * 2.0 - 1.0;\n}\n\nfloat WorleyNoise(vec3 p, uint seed) {\n    ivec3 currentCell = ivec3(floor(p));\n    float minDistSq = 1e38;\n    for (int x=-1; x<=1; x++)\n    for (int y=-1; y<=1; y++)\n    for (int z=-1; z<=1; z++) {\n        ivec3 cell = currentCell + ivec3(x, y, z);\n        uint cellId = uint(cell.z * 0xF54B6267 + cell.y * 0xDE54 + cell.x) + seed;\n        vec3 offset = 0.5 + randvec3m11(cellId) * 0.5;\n        vec3 p2cp = vec3(cell) + offset - p;\n        float distSq = dot(p2cp, p2cp);\n        minDistSq = min(minDistSq, distSq);\n    }\n    return minDistSq;\n}\n\nRay CameraRay(vec2 pix, vec3 camPos, vec3 camTarget) {\n    vec2 pixm11 = 2.0 * pix / iResolution.xy - 1.0;\n    vec3 f = normalize(camTarget - camPos);\n    vec3 r = cross(f, vec3(0, 0, 1));\n    vec3 up = cross(r, f);\n    float ar = iResolution.y / iResolution.x;\n    return Ray(camPos, normalize(pixm11.x * r + pixm11.y * ar * up + f));\n}\n\nfloat SphereDist(vec3 center, float r, vec3 p) {\n    return length(p - center) - r;\n}\n\nfloat AABBDist(vec3 lower, vec3 upper, vec3 p) {\n    p -= (lower+upper) * 0.5;\n    vec3 b = upper - lower;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat OpSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SpheresUnion(vec3 p) {\n    vec3 s1c = vec3(0, sin(iTime / 2.0), cos(0.5*iTime));\n    vec3 s2c = vec3(0, cos(iTime / 10.0), sin(iTime));\n    vec3 s3c = vec3(sin(iTime), sin(iTime), 0.5);\n    float r = 1.0;\n    float d1 = SphereDist(s1c, 1.0, p);\n    float d2 = SphereDist(s2c, 1.0, p);\n    float d3 = SphereDist(s3c, 0.8, p);\n    float d4 = AABBDist(vec3(-0.25, -0.25, 0.25), vec3(0.25, 0.25, 0.75), p);\n    return OpSmoothUnion(OpSmoothUnion(OpSmoothUnion(d1, d2, 0.5), d3, 0.5), d4, 0.5)\n        + WorleyNoise(p * 10.0, 1u) * 0.05;\n}\n\n#define f(p) SpheresUnion(p)\n\n//https://iquilezles.org/articles/normalsSDF\nvec3 CalcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\n\nInter RayMarch(Ray r) {\n    const int maxIter = 50;\n    vec3 p = r.o;\n    float t = 0.0;\n    float prevMinDist = 1e9;\n    for (int i=0; i<maxIter; i++) {\n        p = r.o + t * r.d;\n        float minDist = SpheresUnion(p);\n        if (minDist < 1e-2) {\n            return Inter(t, CalcNormal(p), vec3(0, 1, 0));\n        }\n        if (minDist - prevMinDist > 10.0) {\n            return Inter(1e9, vec3(0), vec3(0));\n        }\n        prevMinDist = minDist;\n        t += minDist;\n    }\n    return Inter(1e9, vec3(0), vec3(0));\n}\n\nvec4 RayMarchVolume(Ray r, Inter i, vec3 alb, float absCoef) {\n    const int maxIter = 30;\n    vec3 p = r.o + i.t * r.d;\n    float stepSize = 0.01;\n    float prevMinDist = 1e9;\n    vec3 col = vec3(0);\n    float transmittance = 1.0;\n    float prevTransmittance = 0.0;\n    for (int i=0; i<maxIter; i++) {\n        float t = float(i) * stepSize;\n        p += t * r.d;\n        float minDist = SpheresUnion(p);\n        if (minDist < 0.0) {\n            prevTransmittance = transmittance;\n            transmittance *= exp(-absCoef * stepSize);\n            float currentTr = prevTransmittance - transmittance;\n            col += alb * currentTr * 3.0 * (10.0 / length(r.o - p));\n        }\n        if (minDist - prevMinDist > 10.0) {\n            vec4(col, clamp(transmittance, 0.0, 1.0));\n        }\n    }\n    return vec4(col, clamp(transmittance, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(vec2(cos(iTime), sin(iTime)) * 5.0, 10);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 L = normalize(camTarget - camPos);\n    const vec3 E = vec3(0.9, 0.9, 0.9);\n    Ray r = CameraRay(fragCoord, camPos, camTarget);\n\n    Inter i = RayMarch(r);\n    vec3 col = vec3(0);\n    \n    if (i.t < 1e9) {\n        vec4 volumeCol = RayMarchVolume(r, i, vec3(1.0, 1.0, 1.0), 2.0);\n        col = volumeCol.rgb * volumeCol.a;\n        //col = dot(-L, i.n) * E * i.c;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //uint seed = uint(fragCoord.x + fragCoord.y * iResolution.x);\n    //fragColor = vec4(randvec3m11(seed), 1.0);\n}","name":"Image","description":"","type":"image"}]}