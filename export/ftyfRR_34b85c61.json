{"ver":"0.1","info":{"id":"ftyfRR","date":"1663873704","viewed":78,"name":"trigovoxeltry","username":"Mcthouacbb","description":"raytraced voxels","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","voxel","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThanks to https://iquilezles.org/articles/voxellines/\nhttps://www.shadertoy.com/view/wdSBzK\nhttps://www.shadertoy.com/view/4dfGzs\nand https://stackoverflow.com/a/28095165\nfor help with this project\n*/\n\nconst float FOV = 135.0;\nconst float FOV_CONST = tan(FOV * PI / 360.0);\nconst vec3 INV_LIGHT_DIR = normalize(vec3(0.5, 1.5, 0.75));\n\n\n\nmat3 rotateX(float rotationAngle)\n{\n    float sinAng = sin(rotationAngle);\n    float cosAng = cos(rotationAngle);\n    return mat3(\n        1,      0,       0,\n        0, cosAng, -sinAng,\n        0, sinAng,  cosAng\n    );\n}\n\nmat3 rotateY(float rotationAngle)\n{\n    float sinAng = sin(rotationAngle);\n    float cosAng = cos(rotationAngle);\n    return mat3(\n         cosAng, 0, sinAng,\n              0, 1,      0,\n        -sinAng, 0, cosAng\n    );\n}\n\nmat3 rotateZ(float rotationAngle)\n{\n    float sinAng = sin(rotationAngle);\n    float cosAng = cos(rotationAngle);\n    return mat3(\n        cosAng, -sinAng, 0,\n        sinAng,  cosAng, 0,\n             0,       0, 1\n    );\n}\n\nfloat groundHeight(vec3 pos)\n{\n    return sin(pos.x / 50.0) * 6.0 + sin(pos.z / 50.0) * 12.0;\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 posRot1 = rotateY(1.0) * pos;\n    vec3 posRot2 = rotateY(0.5) * pos;\n    vec3 posRot3 = rotateY(2.5) * pos;\n    float ground1 = groundHeight(pos) * 2.0;\n    float ground4 = groundHeight(posRot1 * 1.8) * 1.5;\n    float ground2 = groundHeight(posRot2 * 8.0) / 3.0;\n    float ground3 = groundHeight(posRot3 * 8.0) / 5.0;\n    \n    float sky11 = groundHeight(pos + vec3(350.0, 0.0, -245.0)) * 2.0 + 100.0;\n    float sky12 = groundHeight(posRot1 * 2.4 + vec3(250.4, 0.0, -127.9));\n    float sky21 = groundHeight(posRot2 + vec3(-190.0, 0.0, 277.0)) * 2.0 + 130.0;\n    float sky22 = groundHeight(posRot3 + vec3(147.4, 0.0, 194.3));\n    \n    return max(ground1 + ground2 + ground3 + ground4 - pos.y, min(sky11 + sky12 - pos.y, pos.y - sky21 - sky22));\n}\n\nfloat map(vec3 pos)\n{\n    return step(0.5 - noise(pos), 0.5);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection, out vec3 fPos, out vec3 tMin, out vec3 normal)\n{\n    vec3 invDir = 1.0 / rayDirection;\n    vec3 stepSize = sign(rayDirection);\n    vec3 tDelta = stepSize * invDir;\n    vec3 fr = fract(rayOrigin);\n    vec3 tMax = vec3(\n        tDelta.x * (rayDirection.x > 0.0 ? 1.0 - fr.x : fr.x),\n        tDelta.y * (rayDirection.y > 0.0 ? 1.0 - fr.y : fr.y),\n        tDelta.z * (rayDirection.z > 0.0 ? 1.0 - fr.z : fr.z)\n    );\n    vec3 pos = floor(rayOrigin);\n    vec3 scale;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (clamp(length(pos - rayOrigin) - MIN_DIST, 0.0, 1.0) * map(pos) == 1.0)//sin(pos.x) * 3.0 + cos(pos.z) * 3.0)\n        {\n            float t = min(min(tMax.x, tMax.y), tMax.z);\n            fPos = pos;\n            normal = scale * -stepSize;\n            tMin = scale;\n            vec3 mini = (pos - rayOrigin + 0.5 - 0.5 * vec3(stepSize)) * invDir;\n            return max(mini.x, max(mini.y, mini.z));\n        }\n        \n        scale = step(tMax.xyz, tMax.yzx) * step(tMax.xyz, tMax.zxy);\n        \n        tMax += scale * tDelta;\n        pos += scale * stepSize;\n    }\n    \n    return -1.0;\n}\n\nfloat shadowCast(vec3 rayOrigin, vec3 rayDirection)\n{\n    vec3 stepSize = sign(rayDirection);\n    vec3 tDelta = stepSize / rayDirection;\n    vec3 fr = fract(rayOrigin);\n    vec3 tMax = vec3(\n        tDelta.x * (rayDirection.x > 0.0 ? 1.0 - fr.x : fr.x),\n        tDelta.y * (rayDirection.y > 0.0 ? 1.0 - fr.y : fr.y),\n        tDelta.z * (rayDirection.z > 0.0 ? 1.0 - fr.z : fr.z)\n    );\n    vec3 pos = floor(rayOrigin);\n    vec3 scale;\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++)\n    {\n        if (map(pos) == 1.0)\n        {\n            return 0.0;\n        }\n        \n        scale = step(tMax.xyz, tMax.yzx) * step(tMax.xyz, tMax.zxy);\n        \n        tMax += scale * tDelta;\n        pos += scale * stepSize;\n    }\n    \n    return 1.0;\n}\n\nvec3 getRay(vec2 screenPos, mat3 cameraRot)\n{\n    vec3 originRay = normalize(vec3(screenPos * FOV_CONST, 1.0));\n    return cameraRot * originRay;\n}\n\n\nvec2 getAttribPos0(int i) {\n    vec2 xy = vec2(mod(float(i), iChannelResolution[0].x), floor(float(i) / iChannelResolution[0].x));\n    xy += vec2(0.5);\n    xy /= iChannelResolution[0].xy;\n    return xy;\n}\n// from https://iquilezles.org/articles/voxellines/\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge(in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd, float hitT)\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep(0.85, 0.99 * exp(pow(hitT * 0.01, 0.8)), vec4(uv.x,\n                                          st.x,\n                                          uv.y,\n                                          st.y)) * ( 1.0 - va + va * vc);\n    // corners\n    vec4 wc = smoothstep(0.85, 0.99 * exp(hitT * 0.01), vec4(uv.x * uv.y,\n                                          st.x * uv.y,\n                                          st.x * st.y,\n                                          uv.x * st.y)) * (1.0 - vb + vd * vb);\n    return maxcomp(max(wb, wc));\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection)\n{\n    vec3 col = rayDirection.y > 0.0 ?\n        mix(vec3(0.11, 0.76, 1.0), vec3(0.4, 0.6, 0.9), vec3(rayDirection.y)) :\n        mix(vec3(0.1, 0.2, 0.4), vec3(0.11, 0.76, 1.0), vec3(rayDirection.y + 1.0));\n    vec3 fPos, tMin, normal;\n    float hitT = raycast(rayOrigin, rayDirection, fPos, tMin, normal);\n    if (hitT > 0.0)\n    {\n        vec3 pos = rayOrigin + hitT * rayDirection;\n        vec3 rPos = pos - fPos;\n        \n    #if SHADOW_PASS\n        float shadowHit = shadowCast(pos + normal * EPSILON, INV_LIGHT_DIR);\n    #endif\n    \n\t\tvec3 v1 = fPos + normal + tMin.yzx;\n\t    vec3 v2 = fPos + normal - tMin.yzx;\n\t    vec3 v3 = fPos + normal + tMin.zxy;\n\t    vec3 v4 = fPos + normal - tMin.zxy;\n\t\tvec3 v5 = fPos + normal + tMin.yzx + tMin.zxy;\n        vec3 v6 = fPos + normal - tMin.yzx + tMin.zxy;\n\t    vec3 v7 = fPos + normal - tMin.yzx - tMin.zxy;\n\t    vec3 v8 = fPos + normal + tMin.yzx - tMin.zxy;\n\t    vec3 v9 = fPos + tMin.yzx;\n\t    vec3 v10 = fPos - tMin.yzx;\n\t    vec3 v11 = fPos + tMin.zxy;\n\t    vec3 v12 = fPos - tMin.zxy;\n \t    vec3 v13 = fPos + tMin.yzx + tMin.zxy; \n\t    vec3 v14 = fPos - tMin.yzx + tMin.zxy;\n\t    vec3 v15 = fPos - tMin.yzx - tMin.zxy;\n\t    vec3 v16 = fPos + tMin.yzx - tMin.zxy;\n\n\t\tvec4 vc = vec4(map(v1), map(v2), map(v3), map(v4));\n\t    vec4 vd = vec4(map(v5), map(v6), map(v7), map(v8));\n\t    vec4 va = vec4(map(v9), map(v10), map(v11), map(v12));\n\t    vec4 vb = vec4(map(v13), map(v14), map(v15), map(v16));\n        \n        vec2 uv = vec2(dot(tMin.yzx, rPos), dot(tMin.zxy, rPos));\n        \n        float diffuse = max(0.0, dot(normal, INV_LIGHT_DIR));\n        float amb = clamp(0.8 + pos.y / 100.0, 0.1, 0.8);\n        float occ = calcOcc(uv, va, vb, vc, vd);\n        occ = 1.0 - occ / 2.0;\n        occ = occ * occ;\n        occ = occ * occ * amb + 0.3;\n        \n        vec3 light = vec3(0.0);\n        light += occ;\n    #if SHADOW_PASS\n        light += shadowHit * 3.5 * diffuse * vec3(1.0, 0.9, 0.7) * (0.5 + 0.5 * occ);\n    #else\n        light += 3.5 * diffuse * vec3(1.0, 0.9, 0.7) * (0.5 + 0.5 * occ);\n    #endif\n        float lineGlow = 0.0;\n        lineGlow += smoothstep(0.4, 1.0, uv.x)*(1.0 - va.x * (1.0 - vc.x));\n        lineGlow += smoothstep(0.4, 1.0, 1.0 - uv.x) * (1.0-va.y*(1.0 - vc.y));\n        lineGlow += smoothstep(0.4, 1.0, uv.y) * (1.0 - va.z * (1.0 - vc.z));\n        lineGlow += smoothstep(0.4, 1.0, 1.0 - uv.y) * (1.0 - va.w * (1.0 - vc.w));\n        lineGlow += smoothstep(0.4, 1.0, uv.y * uv.x) * (1.0 - vb.x * (1.0 - vd.x));\n        lineGlow += smoothstep(0.4, 1.0, uv.y * (1.0 - uv.x)) * (1.0 - vb.y * (1.0 - vd.y));\n        lineGlow += smoothstep(0.4, 1.0, (1.0 - uv.y) * (1.0 - uv.x)) * (1.0 - vb.z * (1.0 - vd.z));\n        lineGlow += smoothstep(0.4, 1.0, (1.0 - uv.y) * uv.x) * (1.0 - vb.w * (1.0 - vd.w));\n        \n        lineGlow *= 3.0 * max(sign(-35.5 - pos.y), 0.0);\n        \n        vec3 linCol = 2.0 * vec3(5.0, 0.6, 0.0);\n        linCol *= (0.5 + 0.5 * occ) * 0.5;\n        light += 3.0 * lineGlow * linCol;\n        \n        \n        float edge = pos.y > -35.5 ? 0.0 : isEdge(uv, va, vb, vc, vd, hitT);\n        \n        vec3 grassCol = mix(vec3(0.98, 0.76, 0.39), vec3(0.7, 1.3, 0.9), max(normal.y, 0.0));\n        vec3 stoneCol = vec3(0.50, 0.59, 0.54);\n        vec3 snowCol = sign(normal.y) == 1.0 ? vec3(3.0, 3.0, 3.0) : grassCol;\n        vec3 bedrockCol = vec3(0.15, 0.2, 0.15);\n        \n        col = bedrockCol;\n        col = pos.y > -35.5 ? stoneCol : col;\n        col = pos.y > -10.5 ? grassCol : col;\n        col = pos.y > 40.5 ? snowCol : col;\n        \n        \n        col *= light;\n        col += 8.0 * linCol * vec3(1.0,2.0,3.0) * edge;\n        col += 0.1 * lineGlow * linCol;\n        //col *= exp(-0.01 * hitT);\n        col *= 0.1;//min(0.1, exp(-0.008 * hitT));\n        //col = vec3(shadowHit);\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    return col;\n}\n\n// Thanks to https://stackoverflow.com/a/28095165 for the function\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = ((fragCoord - iResolution.xy / 2.0) / iResolution.x);\n    \n    vec3 cameraRot = vec3(texture(iChannel0, getAttribPos0(1)).xy, 0.0);\n    vec3 cameraPos = texture(iChannel0, getAttribPos0(0)).xyz;\n    \n#if AA == 0\n    vec3 dir = getRay(screenPos, rotateY(cameraRot.y) * rotateX(cameraRot.x));\n    vec3 col = render(cameraPos, dir);\n#elif AA == 1\n    mat3 rot = rotateY(cameraRot.y) * rotateX(cameraRot.x);\n    vec2 randOffset = vec2(gold_noise(fragCoord, 69.4246483), gold_noise(screenPos, -4387.247387));\n    randOffset = (abs(randOffset) * 0.25 + 0.25) / iResolution.x;\n    vec3 dir1 = getRay(screenPos + randOffset * vec2(1.0, -1.0), rot);\n    vec3 dir2 = getRay(screenPos + randOffset * vec2(-1.0, 1.0), rot);\n    vec3 col1 = render(cameraPos, dir1);\n    vec3 col2 = render(cameraPos, dir2);\n    vec3 col = (col1 + col2) / 2.0;\n#else\n    mat3 rot = rotateY(cameraRot.y) * rotateX(cameraRot.x);\n    vec2 randOffset = vec2(gold_noise(fragCoord, 69.4246483), gold_noise(screenPos, -4387.247387));\n    randOffset = (abs(randOffset) * 0.25 + 0.25) / iResolution.x;\n    vec3 dir1 = getRay(screenPos + randOffset, rot);\n    vec3 dir2 = getRay(screenPos + randOffset.yx * vec2(1.0, -1.0), rot);\n    vec3 dir3 = getRay(screenPos + randOffset * vec2(-1.0, -1.0), rot);\n    vec3 dir4 = getRay(screenPos + randOffset.yx * vec2(-1.0, 1.0), rot);\n    vec3 col1 = render(cameraPos, dir1);\n    vec3 col2 = render(cameraPos, dir2);\n    vec3 col3 = render(cameraPos, dir3);\n    vec3 col4 = render(cameraPos, dir4);\n    vec3 col = (col1 + col2 + col3 + col4) / 4.0;\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626\n#define EPSILON 0.001\n#define MAX_STEPS 192 // CHANGE THIS VALUE TO INCREASE/DECREASE RENDER DISTANCE\n#define MAX_SHADOW_STEPS 384 // 512 MAY BE A MORE STABLE VALUE\n#define MIN_DIST 4.5\n#define BACKGROUND_COLOR vec3(0.5, 0.5, 0.5) // THIS DOES NOTHING\n#define SHADOW_PASS 0 // SET TO 1 TO ENABLE SHADOWS\n#define AA 0 // 0 = NO AA, 1 = 2x AA, 2 = 4x AA","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int saveNum(vec2 xy) {\n    xy *= iChannelResolution[0].xy;\n    xy = floor(xy);\n    return int(xy.x + xy.y * iChannelResolution[0].x);\n}\n\nfloat moveSpeed = 20.0;\n\nfloat mouseLookSpeed1 = 0.9;\nfloat mouseLookSpeed2 = 1.4;\n\nvec2 getAttribPos0(int i) {\n    vec2 xy = vec2(mod(float(i), iChannelResolution[0].x), floor(float(i) / iChannelResolution[0].x));\n    xy += vec2(0.5);\n    xy /= iChannelResolution[0].xy;\n    return xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    int save = saveNum(uv);\n    if(save == 0) {\n        float cameraYaw = texture(iChannel0, getAttribPos0(1)).y;\n        vec3 cameraPos = texture(iChannel0, uv).xyz;\n        float xMove = moveSpeed * iTimeDelta * (-texelFetch(iChannel1, ivec2(65, 0), 0).r + texelFetch(iChannel1, ivec2(68, 0), 0).r);\n        float zMove = moveSpeed * iTimeDelta * (texelFetch(iChannel1, ivec2(87, 0), 0).r - texelFetch(iChannel1, ivec2(83, 0), 0).r);\n        float yMove = moveSpeed * iTimeDelta * (texelFetch(iChannel1, ivec2(69, 0), 0).r - texelFetch(iChannel1, ivec2(81, 0), 0).r);\n        cameraPos += vec3(xMove * cos(cameraYaw) - zMove * sin(cameraYaw), yMove, zMove * cos(cameraYaw) + xMove * sin(cameraYaw));\n        fragColor = vec4(cameraPos, 0);\n    } else {\n        if(save == 1) {\n            vec3 cameraLook = texture(iChannel0, uv).xyz;\n            float cameraYawDelta = mouseLookSpeed1 * iTimeDelta * (texelFetch(iChannel1, ivec2(38, 0), 0).r - texelFetch(iChannel1, ivec2(40, 0), 0).r);\n            float cameraPitchDelta = mouseLookSpeed2 * iTimeDelta * (texelFetch(iChannel1, ivec2(37, 0), 0).r - texelFetch(iChannel1, ivec2(39, 0), 0).r);\n            cameraLook += vec3(cameraYawDelta, cameraPitchDelta, 0);\n            fragColor = vec4(clamp(cameraLook.x, -PI / 2.0, PI / 2.0), mod(cameraLook.y, 2.0 * PI), mod(cameraLook.z, 2.0 * PI), 0);\n        } else {\n            discard;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}