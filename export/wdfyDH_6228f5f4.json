{"ver":"0.1","info":{"id":"wdfyDH","date":"1584674707","viewed":100,"name":"Chess Demo cs 180 Project","username":"ncduncan111","description":"Chess pieces created by implicit geometry","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["implicitchess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" \n// Making chess pieces using raymarching and constructive solid geometry\n// Copy + paste all of this code into shadertoy and run it\n\n// Defines\n#define STEP_MAX 100\n#define DIST_MAX 10.0\n#define EPSILON 0.02\n\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n// Get color based on which distance function was intersected with\nvec3 get_color(float key){\n    if(key == WHITE){\n        return vec3(.55, .55, .55);\n    } else if(key == BLACK){\n        return vec3(.25, .25, .25);\n    } else if(key == FLOOR){\n        return vec3(.4,.4,.4);   \n    } else{\n        return vec3(.6, .8, .9);\n    }\n}\n\n// Get material for phong reflectance \nvec3 get_mat(float key){\n    if(key == WHITE || key == BLACK){\n        return vec3(.8);\n    }else{\n        return vec3(.05);\n    }\n}\n\nfloat sphere_sdf( vec3 p, float r)\n{\n  return length(p) - r;\n}\n\n// Signed distance functions defined here:\nfloat sphere_sdf( vec3 p, vec3 c, float r)\n{\n  return length(p - c) - r;\n}\n\n// Distance function for the floor\nfloat floor_sdf(vec3 p){\n    vec4 plane = vec4(0, 1, 0, 0);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nfloat wall_sdf(vec3 p){\n    vec4 plane = vec4(0, 0, -1, -9.0);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nfloat rounded_cylinder_sdf( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)- 2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat rounded_cone_sdf( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nvec2 opUnionVec2(vec2 d1, vec2 d2){\n    if(d1.x < d2.x){\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h, vec3 offset )\n{\n  p = p-offset;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat rhombus_sdf(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r, vec3 offset )\n{\n  p = p-offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2,vec3 offset)\n{\n  p = p - offset;\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat bishop_base(vec3 p){\n    float base = rounded_cylinder_sdf(p, .45, .08, .18);\n    float ring = rounded_cylinder_sdf(p - vec3(0,0.1,0), .25,.003,.08);\n    return base;\n   \n}\nfloat bishop_shaft(vec3 p){\n    float ring = rounded_cylinder_sdf(p - vec3(0,2.5,0), .35,.005,.1);\n    float ring2 = rounded_cylinder_sdf(p - vec3(0,2.7,0), .25,.003,.08);\n    float ring3 = rounded_cylinder_sdf(p - vec3(0,2.9,0), .2,.001,.06);\n    float shaft_tip = opUnion(opUnion(ring, ring2), ring3);   \n    \n    float cone = rounded_cone_sdf(p, .4,.1, 3.5);\n    float ring4 = rounded_cylinder_sdf(p - vec3(0,0.4,0), .25,.003,.08);\n    float shaft_base = opUnion(opSmoothUnion(cone, ring4, 0.3), ring4);\n    return opSmoothUnion(shaft_base, shaft_tip,0.5);\n}\n\nfloat bishop_tip(vec3 p){\n    float big_sphere = sphere_sdf(p, 0.50);\n    float top_sphere = sphere_sdf(p - vec3(0,0.65,0),0.25);\n    float spheres = opSmoothUnion(big_sphere, top_sphere, 0.1);\n    vec3 rot = rotateZ(40.0) * (p - vec3(-0.55,0.35,0));\n    float rhombus = rhombus_sdf(rot,0.5, 0.5, 0.08,0.4);\n    //float t_prism = tri_prism_sdf(rot, vec2(0.55,0.5));\n    return opSubtraction(rhombus,spheres);\n    \n}\n\nvec2 bishop_sdf(vec3 point, vec3 offset, float color, float scale){\n    vec3 p = point/scale;\n    vec3 BISHOP_POS = offset/scale;\n \n    float tip = bishop_tip(p-vec3(BISHOP_POS.x, BISHOP_POS.y + 5.0, BISHOP_POS.z));\n    \n    float base = bishop_base(p-vec3(BISHOP_POS.x, BISHOP_POS.y + 0.5, BISHOP_POS.z));\n   \n    float shaft = bishop_shaft(p - vec3(BISHOP_POS.x, BISHOP_POS.y + 1.0, BISHOP_POS.z));\n    \n    float peen = opSmoothUnion(opSmoothUnion(base, shaft,.65),tip,0.5);\n    \n    return vec2(peen*scale, color);\n}\n\nvec2 pawn(vec3 point, float base_h, float stem_h,  vec3 off, float color, float scale){\n    vec3 p = point/scale;\n    vec3 offset = off/scale;\n    float init_base = sdCappedCylinder(p, 1.2,0.3, offset);\n    offset = offset+vec3(0,0.3,0);\n    float rounded_base = sdRoundedCylinder(p,0.7, 0.7, base_h, offset);\n    offset = offset+vec3(0., 0.6, 0.);\n    \n    float flat_base = sdCappedCylinder(p, 1. ,0.1, offset);\n    offset = offset+vec3(0., 0.1, 0.);\n    float rounded_base2 = sdRoundedCylinder(p,0.5, 0.4, base_h, offset);\n    offset = offset+vec3(0,0.25,0);\n    float flat_base2 = sdCappedCylinder(p, 0.95 ,0.1, offset);\n    offset = offset+vec3(0., 0.1, 0.);\n    float base2 = opSmoothUnion(flat_base2, opSmoothUnion(flat_base,rounded_base2,0.1), 0.1);\n\n    float stem  = sdCappedCone(p,stem_h,1.2, 0.25, offset);\n    offset = offset+vec3(0., stem_h, 0.);\n    float head = sphere_sdf(p, offset, 1.);\n    float neck = sdCappedCylinder(p, 1.0,0.05, offset-vec3(0,1.0,0));\n\n    float base = opSmoothUnion(init_base, opSmoothUnion(rounded_base,base2,0.01),0.01);\n    float body = opUnion(neck, opUnion(stem,head));\n    return vec2(opSmoothUnion( body, base, 0.1)*scale, color);     \n}\nfloat king_shaft(vec3 p){\n    float ring = rounded_cylinder_sdf(p - vec3(0,3.1,0), .35,.005,.1);\n    float ring2 = rounded_cylinder_sdf(p - vec3(0,3.3,0), .25,.003,.08);\n    float ring3 = rounded_cylinder_sdf(p - vec3(0,3.5,0), .2,.003,.06);\n    float shaft_tip = opUnion(opUnion(ring, ring2), ring3);   \n    \n    float cone = rounded_cone_sdf(p, .4,.07, 4.5);\n    float ring4 = rounded_cylinder_sdf(p - vec3(0,0.4,0), .20,.003,.08);\n    float shaft_base = opUnion(opSmoothUnion(cone, ring4, 0.3), ring4);\n    return opSmoothUnion(shaft_base, shaft_tip,0.5);\n}\n\nfloat king_tip(vec3 p){\n    float head = sdCappedCone(p,0.5, 0.1,0.55,vec3(0.,0.,0.));\n    float h_rect1 = sdRoundBox(p-vec3(0.,0.8,0.), vec3(0.1,0.4,0.05),0.01);\n    float h_rect2 = sdRoundBox(p-vec3(0., 0.9,0.), vec3(0.3,0.1,0.05),0.01);\n    float cross =  opSmoothUnion(h_rect1, h_rect2, 0.07);\n    return opUnion(head,cross);\n   \n}\n\nvec2 king_sdf(vec3 point,vec3 offset, float color, float scale){\n    vec3 p = point/scale;\n    vec3 KING_POS = offset/scale;\n    float base = bishop_base(p-vec3(KING_POS.x, KING_POS.y + 0.5, KING_POS.z));\n   \n    float shaft = king_shaft(p - vec3(KING_POS.x, KING_POS.y + 1.0, KING_POS.z));\n    float head = king_tip(p-vec3(KING_POS.x, KING_POS.y + 5.5, KING_POS.z));\n    return vec2(opSmoothUnion(opSmoothUnion(base, shaft,.65),head,0.5)*scale, color);\n}\n\n\n// Combine all the distance functions for the scene in this function\nvec2 scene_sdf(vec3 p){\n    vec2 curr = bishop_sdf(p, vec3(-2.,0,5), WHITE, 0.35);\n    vec2 bishop_1 = bishop_sdf(p, vec3(2.,0,5), WHITE, 0.35);\n    vec2 pawn_1 = pawn(p, 0.009 , 3.50, vec3(-4.,-0.0009, 6), BLACK, 0.2);\n    vec2 king = king_sdf(p, vec3(0, 0, 4.5), BLACK, 0.4);\n    vec2 plane = vec2(floor_sdf(p), 2); \n    vec2 pawn_2 = pawn(p, 0.009 , 3.50, vec3(4.,-0.0009, 6), BLACK, 0.2);\n    //vec2 wall = vec2(wall_sdf(p), 2);\n    \n    \n    curr = opUnionVec2(curr, pawn_1);\n    curr = opUnionVec2(curr, pawn_2);\n    curr = opUnionVec2(curr, bishop_1);\n    curr = opUnionVec2(curr, king);\n    curr = opUnionVec2(curr, plane);\n    //curr = opUnionVec2(curr, wall);\n    \n    return curr;\n}\n\n\n// Perform ray marching by finding the min distance ray can travel without hitting anything and iterating\nvec2 ray_march(vec3 cam_pos, vec3 cam_dir){\n    float t_near = 0.0;\n    for(int i = 0; i < STEP_MAX; i++){\n        vec3 p = cam_pos + cam_dir * t_near; // t_near is how far we can go along ray without hitting object\n        vec2 dist = scene_sdf(p);\n        t_near += dist.x;\n        // Check if we missed entirely or hit something\n        // > DIST_MAX then we missed all objects, less than EPSILON, we hit an object \n        if(t_near > DIST_MAX){ \n            return vec2(-1., -1);\n        }else if(dist.x < EPSILON){\n            return vec2(t_near, dist.y); \n        }\n    }\n    \n    return vec2(-1., -1);\n}\n\n\n\n\n// Get normal by approximating the gradient at some point in the scene\nvec3 normal_at(vec3 p){\n    float dist = scene_sdf(p).x;\n    return normalize(dist - vec3( \n        scene_sdf(p - vec3(0.01, 0, 0)).x,\n        scene_sdf(p - vec3(0, 0.01, 0)).x,\n        scene_sdf(p - vec3(0, 0, 0.01)).x\n    ));\n}\n\n\n\n// Add simple point lights to illuminate the scene\nvec3 get_light(vec3 p, vec3 color, vec3 mat, vec3 cam_pos){\n    vec3 l2_intensity = vec3(1.,.9,.8) * 2.0;\n    vec3 l2 = vec3(0, 3, 3.5);\n    vec3 l2_dir = normalize(l2 - p);  // Direction vector from the point to light\n    l2_dir.x = sin(iTime);\n    float decay_l2 = (1. / length(p - l2));\n    vec3 l_a = vec3(0.1);\n    \n    float p_s = 30.;\n    \n    vec3 norm = normal_at(p);  // Get the normal at the point\n    \n    // Coefficients for specular/diffuse\n    vec3 kd = vec3(color);\n    vec3 ks = vec3(mat);\n    \n    // Set up view direction\n    vec3 v = cam_pos - p;\n    v = normalize(v);\n    \n    //vec3 half_vec_l1 = (l1_dir + v) / (length(l1_dir + v));\n    vec3 half_vec_l2 = (l2_dir + v) / (length(l2_dir + v));\n    half_vec_l2 = normalize(half_vec_l2);\n\n    \n    \n    float ndotl2 = dot(norm, l2_dir);  // Calculating dot for second light\n    ndotl2 = clamp(ndotl2, 0.0, 1.0);\n    \n    float shadow = ray_march(p + norm * EPSILON * 2., l2_dir).x;  // MUST ADD Epsilon to ensure don't accidently hit the floor\n    if(shadow < length(l2 - p) && shadow != -1.){  // Hit something between light and point so we're in a shadow\n        l2_intensity *= .1;\n    }\n    color += kd * (ndotl2 * l2_intensity * decay_l2);\n    //vec3 spec = pow(dot(half_vec_l1, norm),p_s) * ks * (l1_intensity * decay_l1);\n    vec3 spec = pow(dot(half_vec_l2, norm), p_s) * ks * (l2_intensity * decay_l2);\n    return color + l_a + spec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (0.5) * iResolution.xy)/iResolution.y;\n\n    vec3 cam_pos = vec3(0,1,0);\n    vec3 cam_dir = vec3(uv.x, uv.y, 1);\n    vec2 t = ray_march(cam_pos, cam_dir);\n    vec3 col;\n    if(t.x == -1.){\n        col = get_color(t.y) * (1. - (uv.y));\n    }else{\n        vec3 point = cam_pos + cam_dir * t.x;  // Point in the scene (for shading purposes)\n        vec3 new_col = get_light(point, get_color(t.y), get_mat(t.y), cam_pos);\n        // Rendering to screen\n        col = vec3(new_col);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}