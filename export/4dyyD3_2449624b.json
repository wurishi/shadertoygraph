{"ver":"0.1","info":{"id":"4dyyD3","date":"1561038555","viewed":105,"name":"Ryetracer","username":"csterea","description":"Tracer in the rye with an attempt at edge antialiasing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","tracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define M_INV_SQRT2 0.7071067811865475244008443621048490\n#define MAX_INSIDE_DIST 0.1\n#define MIN_OPACITY 0.0\n#define MAX_OPACITY 1.0\n\n\nvec3 RotX(in vec3 v, in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return vec3(\n        v.x, \n    \tv.y * c - v.z * s,\n    \tv.y * s + v.z * c);\n}\nvec3 RotY(in vec3 v, in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return vec3(\n    \tv.x * c - v.z * s,\n        v.y, \n    \tv.x * s + v.z * c);\n}\nvec3 RotZ(in vec3 v, in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return vec3(\n    \tv.x * c - v.y * s,\n    \tv.x * s + v.y * c,\n    \tv.z);\n}\n\n// plane = (normal, distToOrigin)\n// Plane from normal, point and additional distance to origin.\nvec4 PlaneFromNPD(vec3 n, vec3 p, float additionalDist) {\n    return vec4(n, dot(n, p) + additionalDist);\n}\nfloat DistToPlane(vec3 p, vec4 plane) {\n    return dot(p, plane.xyz) - plane.w;\n}\nfloat RayIntersectPlane(vec3 rayO, vec3 rayD, vec4 plane) \n{\n    float t = dot(rayD, plane.xyz);\n    if(t == 0.0)\n        return 0.0;\n    return (plane.w - dot(plane.xyz, rayO)) / t;\n}\n\nvec2 SphereNormalToUv(vec3 normalForTex) {\n    return vec2(\n    \tacos(normalForTex.z),// atan2(normalForTex.y / sin(theta), normalForTex.z);\n        atan(normalForTex.y, normalForTex.x)\n    ) / M_PI;\n}\n\n// Returns the opacity factor between [0..1].\n// The opacity factor is < 1 at the edge of the object.\nfloat RayIntersectSphere(\n    vec3 ray, // Normalized ray direction\n    vec3 sphereCenter, float sphereRadius, mat3 sphereRot, \n    out vec3 out_point, out vec3 out_normal, out vec2 out_uv,\n\tout float out_rayDist)\n{\n    // Solve a quadratic sphere equation passing the ray distance as the unknown.\n    // a*x^2 + b*x + c = 0\n    // a = dot(ray, ray) = 1.0\n    // b = -2 * dot(ray, sphereCenter) (used as negated in 'bCoefNeg')\n    // c = length(sphereCenter) - sphereRadius^2\n    float bCoefNeg = 2.0 * dot(ray, sphereCenter);\n    float cCoef = dot(sphereCenter, sphereCenter) - sphereRadius * sphereRadius;\n    float det = bCoefNeg * bCoefNeg - 4.0 * cCoef;\n    if(det < 0.0)\n        return MIN_OPACITY;\n    float sqDet = sqrt(det);\n    \n    out_rayDist = 0.5 * (bCoefNeg - sqDet);\n    out_point = ray * out_rayDist;\n    out_normal = normalize(out_point - sphereCenter);\n    \n    vec3 localNormal = out_normal * sphereRot;\n    vec3 normalForTex = vec3(localNormal.x, -localNormal.z, localNormal.y); // localNormal.RotateX(M_PI / 2)\n    out_uv = SphereNormalToUv(normalForTex);\n    \n    // Compute an approximation of the inside distance for edge opacity (antialiasing).\n    float insideDist = 0.5 * det;\n    \n    return smoothstep(0.0, MAX_INSIDE_DIST, insideDist);\n}\n\n// Returns the opacity factor between [0..1].\n// The opacity factor is < 1 at the edge of the object.\nfloat RayIntersectBox(\n    vec3 rayO, vec3 rayD, // Normalized ray direction\n    vec3 boxCenter, vec3 boxExt, mat3 boxRot, \n    out vec3 out_point, out vec3 out_normal, out vec2 out_uv,\n\tout float out_rayDist)\n{\n\tvec3 ox = boxRot[0];\n    vec3 oy = boxRot[1];\n    vec3 oz = boxRot[2];\n    \n    float rayDist1, rayDist2;\n    vec3 intersPt1, intersPt2, intersNormal1, intersNormal2;\n    int intersCount = 0;\n    \n    vec4 boxPlanes[6];\n    boxPlanes[0] = PlaneFromNPD(-ox, boxCenter, boxExt.x);\n    boxPlanes[1] = PlaneFromNPD(ox, boxCenter, boxExt.x);\n    boxPlanes[2] = PlaneFromNPD(-oy, boxCenter, boxExt.y);\n    boxPlanes[3] = PlaneFromNPD(oy, boxCenter, boxExt.y);\n    boxPlanes[4] = PlaneFromNPD(-oz, boxCenter, boxExt.z); \n    boxPlanes[5] = PlaneFromNPD(oz, boxCenter, boxExt.z);\n    \n    for(int i=0; i<6; ++i)\n    {\n        vec4 crtPlane = boxPlanes[i];\n        \n        float crtRayDist = RayIntersectPlane(rayO, rayD, crtPlane);\n        vec3 crtIntersPt = rayO + rayD * crtRayDist;\n        \n        bool intersContained = true;\n        for(int j=0; j<6; ++j)\n        {\n            if(i != j && DistToPlane(crtIntersPt, boxPlanes[j]) > 0.0)\n            {\n                intersContained = false;\n                break;\n            }\n        }\n        \n        if(intersContained)\n        {\n            ++intersCount;\n            if(intersCount == 1)\n            {\n                rayDist1 = crtRayDist;\n                intersPt1 = crtIntersPt;\n                intersNormal1 = crtPlane.xyz;\n            }\n            else \n            {\n                rayDist2 = crtRayDist;\n                intersPt2 = crtIntersPt;\n                intersNormal2 = crtPlane.xyz;\n                // We reached two intersection points, stop searching.\n                break;\n            }\n        }\n    }\n    \n    if(intersCount != 2)\n        return MIN_OPACITY;\n    \n    if(rayDist1 < rayDist2)\n    {\n        if(rayDist1 < 0.0)\n            return MIN_OPACITY;\n        out_point = intersPt1;\n        out_normal = intersNormal1;\n        out_rayDist = rayDist1;\n    }\n    else\n    {\n        if(rayDist2 < 0.0)\n            return MIN_OPACITY;\n        out_point = intersPt2;\n        out_normal = intersNormal2;\n        out_rayDist = rayDist2;\n    }\n    \n    vec3 localNormal = normalize(out_point - boxCenter) * boxRot;\n    vec3 normalForTex = vec3(localNormal.x, -localNormal.z, localNormal.y); // localNormal.RotateX(M_PI / 2)\n    out_uv = SphereNormalToUv(normalForTex);\n    \n    // Compute an approximation of the inside distance for edge opacity (antialiasing).\n    float d = abs(rayDist1 - rayDist2);\n    float cosa = min(abs(dot(rayD, intersNormal1)), abs(dot(rayD, intersNormal2)));\n    //float sina = sqrt(1.0 - cosa * cosa);\n    float insideDist = 10.0 * d * cosa;\n    \n    //return clamp(insideDist, MIN_OPACITY, MAX_OPACITY);\n    return smoothstep(0.0, MAX_INSIDE_DIST, insideDist);\n}\n\nvec3 GetCombinedNormal(vec3 baseNormal, vec2 uv, sampler2D normalMap, float normalMapIntensity)\n{\n    float normalMapDensity = 2.0;\n    \n    vec2 normalMapValue = texture(normalMap, normalMapDensity * uv).xy;\n    vec2 ldudv = dFdx(normalMapValue) + dFdy(normalMapValue);\n    //vec3 ldudv = vec3(normalMapValue, 0.0);\n\n    vec3 dudv = vec3(ldudv, 0.0) - baseNormal * dot(ldudv, baseNormal.xy);\n    float lenDudv = length(dudv);\n    if(lenDudv != 0.0)\n    \tdudv /= lenDudv;\n    dudv *= length(ldudv);\n    \n    return normalize(baseNormal + normalMapIntensity * dudv);\n}\n\nvec3 GetLightingColor(\n    vec3 matColor, vec3 baseNormal, float normalMapIntensity,\n\tvec2 uv, sampler2D baseTexture, sampler2D normalMap)\n{\n    vec3 light = normalize(\n        RotX(RotY(vec3(-0.0, 0.0, 0.5),\n        \t\tiTime  * 0.0),\n        \tiTime * 0.0));\n    float phongSaturation = 2.0;    \n    \n    vec3 normal = (normalMapIntensity != 0.0\n        ? GetCombinedNormal(baseNormal, uv, normalMap, normalMapIntensity)\n        : baseNormal);\n    \n    float reflection = pow(max(dot(normal, -light), 0.0), phongSaturation);    \n   \n    return 0.5 * (matColor + texture(baseTexture, uv).xyz) \n        * reflection;\n}\n\nvec3 GetLightingColorEnv(\n    vec3 matColor, vec3 baseNormal, mat3 envMapRot,\n\tvec2 uv, sampler2D baseTexture, sampler2D normalMap, samplerCube envMap)\n{\n    float matColorIntensity = 0.2;\n    float baseTextureIntensity = 1.0 - matColorIntensity;\n    float normalMapIntensity = 1.0;\n    \n    vec3 normal = GetCombinedNormal(baseNormal, uv, normalMap, normalMapIntensity);\n    \n    vec3 reflection = texture(envMap, envMapRot * RotY(normal, -M_PI/2.0)).xyz;    \n    \n    return (matColorIntensity * matColor + baseTextureIntensity * texture(baseTexture, uv).xyz)\n        * reflection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool showReflectiveSphere = true;\n    vec3 matColor = vec3(0.99, 0.99, 0.99);    \n  \n    vec3 sphereCenter = vec3(0, 0, 5);\n    float sphereRadius = 3.0;\n    float sphereNormalMapIntensity = 2.0;\n    \n    vec3 boxCenter = vec3(0.0,0.0,1.5);\n    vec3 boxExtents = vec3(0.3, 0.6, 0.3);\n    float boxNormalMapIntensity = 0.0;\n    mat3 rot = mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n    mat3 envRot = mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n\n\t// Perform the animations.\n    for(int i=0 ; i<3; ++i)\n    {\n    \trot[i] = RotY(rot[i], iTime * 0.6);\n        envRot[i] = RotY(envRot[i], iTime * 0.2);\n    }\n    boxCenter = RotY(boxCenter - sphereCenter, -iTime * 0.5) + sphereCenter;\n\n    // Create a 3D rendering ray from the user point of view to a 3D point containing the current pixel.\n    float aspect = iResolution.x / iResolution.y;\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 renderRayDir = normalize(vec3(\n        aspect * (fragCoord.x/(0.5 * iResolution.x) - 1.0),\n        fragCoord.y/(0.5 * iResolution.y) - 1.0,\n        1.25));\n        \n    // Get the intersection point with the box.\n    vec3 point1, normal1;\n    vec2 uv1;\n    float rayDist1;\n    float opacity1 = RayIntersectBox(\n        origin, renderRayDir,\n        boxCenter, boxExtents, rot, \n        point1, normal1, uv1,\n        rayDist1);\n    \n    // Get the intersection point with the sphere.\n    vec3 point2, normal2;\n    vec2 uv2;\n    float rayDist2;\n    float opacity2 = RayIntersectSphere(\n        renderRayDir, \n        sphereCenter, sphereRadius, rot, \n        point2, normal2, uv2, \n        rayDist2);\n\n    // Test depth occlusion.\n    if(opacity1 == MAX_OPACITY && opacity2 != MIN_OPACITY && rayDist1 < rayDist2)\n        opacity2 = MIN_OPACITY;\n    else if(opacity2 == MAX_OPACITY && opacity1 != MIN_OPACITY && rayDist2 < rayDist1)\n        opacity1 = MIN_OPACITY;\n    \n    // Handle the reflection of the box on the sphere.\n    vec3 point3, normal3;\n    vec2 uv3;\n    float rayDist3;\n    float opacity3 = MIN_OPACITY;\n    if(showReflectiveSphere && opacity2 != MIN_OPACITY)\n    {\n        vec3 rayProj = renderRayDir - normal2 * dot(renderRayDir, normal2);\n        vec3 rayRefl = -(renderRayDir - 2.0 * rayProj);\n        opacity3 = RayIntersectBox(\n            point2, rayRefl,\n            boxCenter, boxExtents, rot, \n            point3, normal3, uv3,\n            rayDist3);\n    }\n    \n    // Get the lighting colors.\n    vec3 col = vec3(0,0,0);\n    float colWeight = 0.0;\n\tif(opacity1 != MIN_OPACITY)\n    {\n        col += opacity1 * GetLightingColor(\n            matColor, normal1, boxNormalMapIntensity,\n        \tuv1, iChannel0, iChannel0);\n        colWeight += opacity1;\n    }\n    if(opacity2 != MIN_OPACITY)\n    {\n        if(showReflectiveSphere)\n            col += opacity2 * GetLightingColorEnv(\n                matColor, normal2, envRot,\n                uv2, iChannel0, iChannel1, iChannel2);\n        else\n            col += opacity2 * GetLightingColor(\n                matColor, normal2, sphereNormalMapIntensity, \n                uv2, iChannel0, iChannel1);\n        colWeight += opacity2;\n    }\n    if(opacity3 != MIN_OPACITY)\n    {\n        col += opacity3 * GetLightingColor(\n            matColor, normal3, boxNormalMapIntensity,\n        \tuv3, iChannel0, iChannel0);\n        colWeight += opacity3;\n    }\n    \n    // Handle background.\n    if(opacity1 != MAX_OPACITY && opacity2 != MAX_OPACITY)\n    {\n        col += texture(iChannel2, envRot * renderRayDir).xyz;\n        colWeight += 1.0;\n    }\n        \n\t// Combine the lighting colors into the final color.\n    if(colWeight != 0.0)\n        col /= colWeight;\n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}