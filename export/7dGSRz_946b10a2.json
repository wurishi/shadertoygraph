{"ver":"0.1","info":{"id":"7dGSRz","date":"1634242869","viewed":86,"name":"Fractal Try one","username":"J3r3m13","description":"Small fractal code thanks to rubenalexander.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 N(float angle){\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center the origin\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //creating mouse\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    //zoom back\n    //uv *= 3.;\n    \n    vec3 col = vec3(0,0,0);\n    \n    //controlling angle via x position of mouse\n    float angle = mouse.x*3.1415;\n    uv *= 2.;\n    //float angle = (2./3.)*3.1415;\n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.)*3.1415)*.75;\n    //creating the first angled line\n    //vec2 n = N((sin(iTime)+1.)*3.1415/2.); //0->1\n    vec2 n = N((5./6.)*3.1415);\n    float d = dot(uv-vec2(3./4.,0), n);\n    uv -= n*max(0.,d)*2.;\n    \n    //col += smoothstep(.01, .0, abs(d));\n    \n    n = N((2./3.)*3.1415);\n    /*\n    //getting the distance between any point and my line n\n    float d = dot(uv, n);\n    //symmetry relative to n. min in order not to reflect negative. only one side\n    uv -= n*min(0.,dot(uv, n))*2.;\n    col.gb += sin(uv*10.);\n    col += smoothstep(.01, .0, abs(d));\n    \n    */\n    uv.x += .5;\n    \n    float scale = 1.;\n    for (float i = 0.; i < mouse.x*5.+1.; i += 1.){\n        //make 1 unit 3 units long\n        uv *= 3.;\n        scale *= 3.;\n        //put origin in the middle of right segment\n        uv.x -= 1.5;\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n*min(0.,dot(uv, n))*2.;\n        \n        uv.x = abs(uv.x);\n        //lengthen the line\n        uv.x -= .5;\n        //symmetry relative to n. min in order not to reflect negative. only one side\n        uv -= n*min(0.,dot(uv, n))*2.;\n    }\n    \n    \n    \n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    \n    //unblurr the line\n    col += smoothstep(1./iResolution.y, .0, d/scale);\n    \n    uv /= scale;\n    \n    col += texture(iChannel0, uv*2.-iTime*.1).rgb;\n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}