{"ver":"0.1","info":{"id":"4fSBW1","date":"1724851055","viewed":147,"name":"Delaunay Love Letter","username":"luckyballa","description":"Using Voronoi cell clipping by Bruno Levy and the team to get Voronoi vertices and corners\nhttps://inria.hal.science/hal-01596553/file/CAD17.pdf","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","collision","simulation","particles","specular","edges","jelly","corners","voronoitracking","xpbd","selfcollision"],"hasliked":0,"parentid":"XcBBDz","parentname":"Voronoi Love Letter"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const uint PARTICLE_COUNT = 500u;\nconst float MAX_VEL = 10.0;\nconst float MOUSE_BRUSH_RADIUS = 96.0;\nconst float DAMPING = 0.5;\nconst float RADIUS = 20.0;\n\nconst int MAX_VORONOI_VERTICES = 4; \n\n#define MAX_VELOCITY (MAX_VEL + MAX_VEL * (iMouse.z > 0.0 ?  0.1 : 0.0))\n\n#define pi 3.14159265359\n#define pi2 2.0 * pi\n\nuint hash(inout uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    \n    return x;\n}\n\nfloat randomFloat(inout uint state) {\n    return float(hash(state)) / 4294967296.0;\n} \n\nvec2 randomDir(inout uint state) {\n    float z = randomFloat(state) * 2.0 - 1.0;\n    float a = randomFloat(state) * pi2;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\n#define PI 3.14159265\n\nstruct Entity {\n    vec2 position;\n    vec2 oldPosition;\n};\n\nconst Entity INVALID_ENTITY = Entity(vec2(-FLOAT_INF), vec2(0));\n\n\nuint wrap1d(uint flatId) {\n    return flatId % PARTICLE_COUNT;\n}\n\nvec2 wrap2d(vec2 id, vec2 resolution) {\n    return fract(id / resolution) * resolution;\n}\n\nuint to1d(vec2 id, vec2 resolution) {\n    return uint(id.x + id.y * resolution.x);\n}\n\nivec2 to2d(uint flatId, ivec2 resolution) {\n    return ivec2(flatId, flatId / uint(resolution.x)) % resolution;\n}\n\nEntity decodeEntity(sampler2D sampler, ivec2 id) {\n    vec4 raw = texelFetch(sampler, id, 0);\n    Entity entity;\n    entity.position = raw.rg;\n    entity.oldPosition = raw.ba;\n    return entity;\n}\n\nEntity decodeEntity(sampler2D sampler, uint flatId) {\n    return decodeEntity(sampler, to2d(flatId, textureSize(sampler, 0)));\n}\n\nvec4 encodeEntity(Entity entity) {\n    return vec4(entity.position, entity.oldPosition);\n}\n\nuvec4 fetchClosest(vec2 position, sampler2D voroBuffer) {\n    return floatBitsToUint(texelFetch(voroBuffer, ivec2(wrap2d(position, vec2(textureSize(voroBuffer, 0)))), 0));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\nuint rngSeed = 314159265u;\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nfloat xorshiftFloat(uint state) {\n    return float(xorshift(state)) / float(0xffffffffU);\n}\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\n\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat  dot2(vec2 v) { return dot(v, v); }\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat sdHeart(vec2 uv) { \n    return length(vec2(uv.x,uv.y - pow(abs(uv.x) * 0.45, 0.8)));\n}\n\nvec2 gsdHeart(vec2 p) {\n    const float h = 0.0001;\n    return vec2(\n        sdHeart(vec2(p.x + h, p.y)) - sdHeart(vec2(p.x - h, p.y)),\n        sdHeart(vec2(p.x, p.y + h)) - sdHeart(vec2(p.x, p.y - h))\n    ) / (2.0 * h);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint flatID = to1d(floor(fragCoord), vec2(textureSize(iChannel0, 0)));\n    fragColor = encodeEntity(INVALID_ENTITY);\n    if (flatID >= PARTICLE_COUNT)\n        return;\n\n    uint flatSeed = murmur3(flatID); \n    rngSeed = flatSeed;\n\n    Entity current;\n    if (iFrame <= 8) {\n        float count = float(PARTICLE_COUNT);\n        current.position += vec2(nextFloat(), nextFloat()) * iResolution.xy;\n        current.oldPosition = current.position + vec2(nextFloat(), nextFloat()) * ((current.position / iResolution.xy) - 0.5) * iResolution.xy * 0.1;\n    } else {\n        current = decodeEntity(iChannel0, flatID);\n    }\n\n    vec2 p = current.position / iResolution.xy; p -= 0.5;\n    \n    float time = mod(iTime, 1.2);\n    float animation = pow(time, 0.75) * 0.5;\n    animation += sin(time * PI * 2.0 * -(p.y + 0.5) + dot2(p)) * exp(-time * 6.0);\n\n    float RADIUS = RADIUS * 0.5 + RADIUS * animation * 0.75;\n    RADIUS *= mix(1.0, 0.75, step(0., iMouse.z));\n    \n    vec2 force = -gsdHeart(p).xy  * 60.0 * pow(abs(sdHeart(p)), 0.5) * (iMouse.z > 0.0 ?  0.444 : 1.0);\n    force += vec2(sin(float(flatID) + iTime + fragCoord.x), cos(float(flatID) + iTime + fragCoord.y)) * 4.0;\n\n    if (sign(iMouse.z) > 0.) {\n        vec2 diff = iMouse.xy - current.position;\n        float strength = 1.0 - length(diff) / MOUSE_BRUSH_RADIUS;\n        if (strength > 0.0) {\n            force += vec2(diff.y, -diff.x) * smoothstep(0., 1., strength) * 4.0;\n        }\n    }\n\n    vec2 velocity = current.position - current.oldPosition;\n    float v = length(velocity);\n    vec2 normalizedVelocity = velocity / max(v, 0.00001);\n    float dv = -v * DAMPING * iTimeDelta;\n    velocity += normalizedVelocity * dv;\n    velocity = clamp(velocity, -MAX_VELOCITY, MAX_VELOCITY);\n    \n    vec2 oldPosition = current.position;\n    current.position = clamp(current.position, vec2(RADIUS), iResolution.xy - vec2(RADIUS));\n    current.position += velocity + 0.3 * force * iTimeDelta;\n\n    uvec4 closest = fetchClosest(current.position, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        if (closest[i] == flatID || closest[i] == -1u) {\n            continue;\n        }\n\n        Entity other = decodeEntity(iChannel0, closest[i]);\n\n        float r2 = RADIUS * 2.0;\n        vec2 delta = current.position - other.position;\n        float dist = length(delta);\n\n        if (dist < r2) {\n            float cost = (r2 - dist);\n            vec2 grad = delta / dist;\n            vec2 correction = grad * -cost;\n            \n            current.position -= correction * 0.05;\n        }\n    }\n\n    current.oldPosition = oldPosition;\n\n    fragColor = encodeEntity(current);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec2 center\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    Entity e = decodeEntity(iChannel0, index);\n    float dist = length(center - e.position);\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvoid fetchAndSortClosest( inout vec4 distances, inout uvec4 idList, in vec2 samplePoint, in vec2 cellCenter ) {\n    uvec4 ids = fetchClosest(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, idList, ids[i], cellCenter);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 closestIndices = uvec4(-1);\n    vec4 bestDistances = vec4(FLOAT_INF);\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    float rad = 4.0;\n\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    \n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, wrap1d(nextUint()), fragCoord);\n    }\n\n    fragColor = uintBitsToFloat(closestIndices);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"struct Line {\n    vec2 midpoint;\n    vec2 normal;\n};\n\nstruct VoronoiCell {\n    vec2 vertices[MAX_VORONOI_VERTICES];\n    int vertexCount;\n    float Rk;\n    vec2 triangle[3];\n};\n\n\nvec2 intersectLines(Line l1, Line l2) {\n    vec2 p1 = l1.midpoint;\n    vec2 p2 = l2.midpoint;\n    vec2 d1 = l1.normal;\n    vec2 d2 = l2.normal;\n    \n    float det = d1.x * d2.y - d1.y * d2.x;\n    if (abs(det) < 1e-6) {\n        return vec2(-1);\n    }\n    \n    float t = ((p2.x - p1.x) * d2.y - (p2.y - p1.y) * d2.x) / det;\n    return p1 + d1 * t;\n}\n\nLine computeBisector(vec2 p1, vec2 p2) {\n    vec2 midpoint = (p1 + p2) * 0.5;\n    vec2 dir = normalize(p2 - p1);\n    vec2 normal = vec2(-dir.y, dir.x);\n    return Line(midpoint, normal);\n}\n\n\nVoronoiCell computeVoronoiCell(vec2 site, uint siteIndex, uvec4 candidates) {\n    VoronoiCell cell;\n    cell.vertexCount = 0;\n    cell.Rk = 0.0; \n    \n    Line bisectors[4];\n    for (int i = 1; i < 4; i++) {\n        vec2 neighbor = decodeEntity(iChannel0, candidates[i]).position;\n        bisectors[i - 1] = computeBisector(site, neighbor);\n    }\n    \n    bisectors[3] = Line(vec2(0), vec2(0, 1));\n    \n    \n    for (int i = 0; i < 3; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            vec2 intersection = intersectLines(bisectors[i], bisectors[j]);\n            if (intersection.x != -1.0) {\n                cell.vertices[cell.vertexCount++] = intersection;\n                if (cell.vertexCount >= MAX_VORONOI_VERTICES) break;\n\n                float distance = length(intersection - site);\n                cell.Rk = max(cell.Rk, distance);\n                \n                uvec4 corenerIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(intersection), 0));\n                uvec3 triangeCandidates = uvec3(candidates[i + 1], candidates[((j + 1) % 4)], siteIndex);\n                if (\n                any(equal(uvec3(corenerIndices[0]),triangeCandidates)) &&\n                any(equal(uvec3(corenerIndices[1]), triangeCandidates)) &&\n                any(equal(uvec3(corenerIndices[2]), triangeCandidates))\n                ) {\n                    cell.triangle[0] = decodeEntity(iChannel0, triangeCandidates.x).position;\n                    cell.triangle[1] = decodeEntity(iChannel0, triangeCandidates.y).position;\n                    cell.triangle[2] = site;\n\n                } \n            }\n        }\n   \n        \n        if (cell.vertexCount >= MAX_VORONOI_VERTICES) break;\n    }\n    \n    return cell;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y); p *= 2.0;\n    uvec4 closestIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(fragCoord), 0));\n    uint seedId = closestIndices[0];\n    vec2 closestPos = decodeEntity(iChannel0, seedId).position;\n    \n    VoronoiCell cell = computeVoronoiCell(closestPos, seedId, closestIndices);\n\n    float mdist = 99999.0;\n    for (int i = 0; i < cell.vertexCount; i++) {\n        vec2 current = cell.vertices[i];\n        vec2 next = cell.vertices[(i + 1) % cell.vertexCount];\n    }\n    \n    mdist = min(mdist, sdSegment(fragCoord, cell.triangle[0], cell.triangle[1]) - 1.0);\n    mdist = min(mdist, sdSegment(fragCoord, cell.triangle[1], cell.triangle[2]) - 1.0);\n    mdist = min(mdist, sdSegment(fragCoord, cell.triangle[2], cell.triangle[0]) - 1.0);\n    \n    vec3 col = vec3(0.8 * 0.9);\n    col = mix(col, vec3(1.0, 0.2, 0.0),  smoothstep(3.5, 3.0, length(closestPos - fragCoord)));\n    col = mix(col, vec3(0.2), smoothstep(0.2, 0.0, mdist));\n    col += vec3(1.0) * smoothstep(0.6, 0.5, abs(mdist - 1.0));\n\n    fragColor = mix(texelFetch(iChannel2, ivec2(fragCoord), 0), vec4(col, 1.0), 0.98);\n}","name":"Buffer C","description":"","type":"buffer"}]}