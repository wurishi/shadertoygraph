{"ver":"0.1","info":{"id":"7syGzD","date":"1631183440","viewed":119,"name":"Tekno Visual 02.","username":"julianlumia","description":":octopusballoon:\nPlease don't mind my quick n dirty hacked together coding here;)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["visuals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 25\n#define MAX_DIST 50.\n#define SURF_DIST .15\n#define PI 3.14159265359\nfloat smin( float a, float b, float k ) {\nfloat h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 point, vec3 sphereCenter, float radius)\n{\n \tfloat dist = distance(point, sphereCenter);\n    return dist - radius;\n}\n\nfloat extrudeSDF(float sdf, float radius)\n{\n \treturn sdf - radius;   \n}\n\nfloat ringSDF(vec3 point, float radius, float width, float height)\n{\n    float ring2D = abs(length(point.xy) - radius) - width;\n    vec2 w = vec2( ring2D, abs(point.z) - height );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat torusSDF(vec3 point, float ringPosition, float ringRadius, float lineRadius)\n{\n    point.z -= ringPosition;\n \tvec2 flattedUV = vec2(length(point.xy) - ringRadius, point.z);\n    return length(flattedUV) - lineRadius;\n}\n\nfloat torusSDFRescaled(vec3 point, float ringPosition, float ringRadius, float lineRadius, vec3 scale)\n{\n    point.z -= ringPosition;\n    point *= scale;\n \tvec2 flattedUV = vec2(length(point.xy) - ringRadius, point.z);\n    return length(flattedUV) - lineRadius;\n}\n\nfloat planeSDF(vec3 point, float planeZPos)\n{\n \treturn point.z - planeZPos;   \n}\n\nfloat cylinderSDF(vec3 point, float radius)\n{\n \treturn length(point.xy) - radius;   \n}\n\nfloat coneSDF( vec3 point, vec3 coneCenter, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec3 pos = point - coneCenter;\n    \n    return dot(c, vec2(length(pos.xy), pos.z));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\nfloat fractal(vec3 p)\n{\n const int iterations = 15;\n float d = 0.;\n float scale = 2.;\n float l = 0.;\t\n  for (int i=0; i<iterations; i++) {\n   p.xy = abs(p.xy-0.)-sin(iTime*.5)*.5-1.5;\n   p.xz = abs(p.xz-.0)-3.5;\n   p = p*scale + vec3(-12.,-5.0,-8);        \n   pR(p.xy,sin(iTime*.7)*.3+0.5-12.2-d);\n//pR(p.yz,+92.5*.25+d);\t\t\n//pR(p.yz,+228.*.25+d);\t\t\n   pR(p.yz,+38.5*.25+d);\t\t\n\nl =length6(p);\n  }\n return l*pow(scale, -float(iterations))-0.08;\n}\n\nvec2 GetDist(vec3 p) {\n vec2 d = vec2(0);\n vec3 p6 = p;\n p6-=vec3(cos(iTime)*0.,sin(iTime)*1.,-14.);\n float the = 1.6; \n p6.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = sin(iTime*.5)*.5; \n p6.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = cos(iTime*.5)*.5; \n p6.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p6.x = abs(p6.x)-5.3;\n// float s = sphereSDF(p6,vec3(-0.,0.,0.),2.1);\n// float s2 = ringSDF(p6,.5,4.5,0.5);\n// float waves = smoothstep(0.1, 0.45, abs(length(p6.xy) -0.8));\n// s2 += max(sin(length(p6.xy * 11.0)), +0.0) * 0.9* waves;\n// float s3 = torusSDF(p6+vec3(0,0,0.4),1.5,5.4,.5);\n \n float s = sphereSDF(p6,vec3(-0.,0.,0.),1.5);\n float s2 = ringSDF(p6,.5,3.26,0.5);\n float waves = smoothstep(0.1, 0.45, abs(length(p6.xy) -0.8));\n s2 += max(sin(length(p6.xy * 15.0)), +0.0) * 0.9* waves;\n float s3 = torusSDF(p6+vec3(0,0,0.4),1.5,4.4,.5);\n \n vec3 p4 = p;\n vec3 p5 = p;\n p4 -=vec3(-.0,.0,0.);\n p5 -=vec3(cos(iTime)*1.,sin(iTime)*1.,-25.);\n d = vec2((sdBox(p4, vec3(-10))),0.);\n the = 1.6; \n p5.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = sin(iTime*.5)*.5; \n p5.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = cos(iTime*.5)*.5; \n p5.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 d3 = vec2(fractal(p5-vec3(0,-.0,0.0)),3);\n d = condmin(d,d3);\n s = min(s,s2);\n s = min(s,s3);\n\nd.x = min(d.x,s);\n\n\nreturn vec2(d);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=100.;\nt.x +=h.x*1.;\nreturn t;\n}\n\nfloat marchCount;\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 1; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>10.) break;\n  marchCount+= 100./d*1.;\n }    \n return t;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 Tunnel(vec2 uv){\n float f = 9. / length(uv);\n f += atan(uv.x, uv.y) / acos(0.);\n f += iTime*.5;\n f = 1. - clamp(sin(f * PI * 2.) * dot(uv, uv) * iResolution.y / 200. + .5, 0., 1.);\n f *= sin(length(uv) - .2);\t\n return vec3(f, f, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\nuv *= vec2(3.2);\nvec3 eye = 1.0*vec3(0.,3.,6.);\nvec3 col;\nvec2 d;\nvec3 hoek = vec3(0,2.,0.);  \nfloat the = (iTime*1.);\nmat3 camera = setCamera( eye, hoek,0.);\nfloat fov = cos(iTime)*.3+2.0;\nvec3 dir = camera * normalize(vec3(uv, fov));\nvec3 p;\nvec3 n;\nvec3 focalPoint = eye + (dir * 1.);\nvec3 shiftedRayOrigin = eye;\nvec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n d = RayMarch(shiftedRayOrigin, shiftedRay);\nfloat t =d.x *1.;\nvec3  shiftedRayOrigin2 = shiftedRayOrigin;\nvec3  shiftedRay2= shiftedRay;\nif(t<MAX_DIST) {\n shiftedRayOrigin2 += shiftedRay2 * t;\n if(d.y==3.) traceRef(shiftedRayOrigin2 +  shiftedRay2*.2, shiftedRay2);\n  if(d.y==3.) col =vec3(0);\n\n col += marchCount;\n }\nvec3 T = Tunnel(uv);\nvec3 sky = vec3(0.);\ncol = mix( T, col, 1./(d.x*d.x/1./1.*.0005+1.0)); \nfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}