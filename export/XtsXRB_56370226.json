{"ver":"0.1","info":{"id":"XtsXRB","date":"1437608382","viewed":385,"name":"Raymarch Visualizer","username":"AlainGalvan","description":"A quick tool I built to help visualize raymarching based off this presentation from iq. (page 31)\nhttp://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\npurple means more iterations.\nForked from this shadertoy: https://www.shadertoy.com/view/lslSRf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","visualize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching Visualizer\n// By Alain Galvan - Based of a presentation by iq.\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n#define GR 1.61803398\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// GLOBALS\n\nvec3 g_camPointAt = vec3(0.);\nvec3 g_camOrigin = vec3(0.);\nfloat g_time = 0.;\nvec3 g_ldir = vec3(.8, 1., 0.8);\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis(vec3 point, float cosangle, float sinangle)\n{\n    return vec3(point.x * cosangle + point.z * sinangle, point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis(vec3 point, float cosangle, float sinangle)\n{\n    return vec3(point.x, point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n// convert a 3d point to two polar coordinates.\n// First coordinate is elevation angle (angle from the plane going through x+z)\n// Second coordinate is azimuth (rotation around the y axis)\n// Range of outputs - ([PI/2, -PI/2], [-PI, PI])\nvec2 cartesianToPolar(vec3 p)\n{\n    return vec2(PI / 2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec2 scenedf(vec3 p)\n{\n    vec2 obj = vec2(sdBox(p, vec3(1.)), 1.);\n    return obj;\n}\n\n#define DISTMARCH_STEPS 32\n#define DISTMARCH_MAXDIST 30.\n\nvec2 distmarch(vec3 ro, vec3 rd, float maxd)\n{\n\n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    float iterations = 0.;\n\n    for (int i = 0; i < DISTMARCH_STEPS; i++)\n    {\n        iterations = float(i);\n        if (abs(dist) < epsilon || t > maxd ||\n            (float(i) > mod(8. * (iTime + 15.), 30.)))\n            break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf(ro + t * rd);\n        dist = dfresult.x;\n    }\n\n    if (t > maxd) iterations = -1.0;\n    return vec2(t, iterations);\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera(in vec2 fragCoord)\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize(g_camPointAt - g_camOrigin);\n    vec3 ix = normalize(cross(iz, iu));\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize(st.x * ix + st.y * iy + .7 * iz);\n\n    return CameraData(g_camOrigin, dir, st);\n}\n\nvoid animateGlobals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;\n    click = 2.0 * click - 1.0;\n\n    g_time = .8 * iTime - 10.;\n\n    // camera position\n    g_camOrigin = vec3(4.5, 0.0, 4.5);\n\n    float rotx = -1. * PI * (.5 * click.y + .45) + .05 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n\n    float roty = TWO_PI * click.x + .05 * g_time;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt = vec3(0., 0., 0.);\n\n    float lroty = .9 * g_time;\n    float coslroty = cos(lroty);\n    float sinlroty = sin(lroty);\n\n    // Rotate the light around the origin\n    g_ldir = rotateAroundYAxis(g_ldir, coslroty, sinlroty);\n}\n\n// **************************************************************************\n// Visualize Functions (Mind the mess!)\n\n/*\n * Returns a component based on luminocity p, saturation q, and hue h.\n */\nfloat hueToRgb(float p, float q, float h)\n{\n    if ((h * 6.) < 1.)\n        return p + (q - p) * h * 6.;\n    else if ((h * 2.) < 1.)\n        return q;\n    else if ((h * 3.) < 2.)\n        return p + (q - p) * ((2. / 3.) - h) * 6.;\n    else\n        return p;\n}\n/*\n * Returns a vec4 with components r,g,b,a, based off vec4 col with components\n * h,s,l,a.\n */\nvec3 hslToRgb(vec3 col)\n{\n    vec3 outColor = vec3(0.);\n    float p, q, tr, tg, tb;\n\n    if (col.b <= .5)\n        q = col.b * (1. + col.g);\n    else\n        q = col.b + col.g - (col.b * col.g);\n\n    p = 2. * col.b - q;\n    tr = col.r + (1. / 3.);\n    tg = col.r;\n    tb = col.r - (1. / 3.);\n\n    outColor.r = hueToRgb(p, q, tr);\n    outColor.g = hueToRgb(p, q, tg);\n    outColor.b = hueToRgb(p, q, tb);\n\n    return outColor;\n}\n\n// https://www.shadertoy.com/view/WlfXRN\nvec3 viridis(float t)\n{\n\n    const vec3 c0 =\n        vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 =\n        vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 =\n        vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 =\n        vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 =\n        vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 =\n        vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 =\n        vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Animate globals\n    animateGlobals();\n\n    // Setup Camera\n    CameraData cam = setupCamera(fragCoord);\n\n    // Scene Marching\n    vec2 scenemarch = distmarch(cam.origin, cam.dir, DISTMARCH_MAXDIST);\n\n    // Visualizer\n    vec3 scenecol = vec3(0.);\n\n    if (scenemarch.y > SMALL_FLOAT)\n        scenecol = viridis(scenemarch.y / float(DISTMARCH_STEPS));\n\n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}