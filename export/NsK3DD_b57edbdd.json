{"ver":"0.1","info":{"id":"NsK3DD","date":"1631890604","viewed":62,"name":"Linas Sphere Grid","username":"itslinaaaa","description":"Lotsa spheres","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sphereSDF ( vec3 position, vec3 center, float radius ) {\n    float distance = length(center - position) - radius;\n    return distance;\n}\n\n\nfloat SDF (vec3 position) {\n    float r = 1.3;\n    float d = 5.0 * r;\n    float i = floor(position.x / d);\n    float j = floor(position.y / d);\n    vec3 pos = vec3(mod(position.xy, d), position.z) - vec3(0, 0, iMouse.x / 20.);\n    vec3 spherePos = vec3(d / 2.0, d / 2.0, 20.0 + 5.0 * sin(10.0 * iTime + length(vec2(i, j))));\n    float sphere = sphereSDF(pos, spherePos, r);\n    return sphere;\n}\n\n\nvec3 normal (vec3 position) {\n    float dt = 0.0001;\n    float dx = SDF(position + vec3(dt, 0, 0)) - SDF(position - vec3(dt, 0, 0));\n    float dy = SDF(position + vec3(0, dt, 0)) - SDF(position - vec3(0, dt, 0));\n    float dz = SDF(position + vec3(0, 0, dt)) - SDF(position - vec3(0, 0, dt));\n    vec3 normal = normalize(vec3(dx, dy, dz));\n    return normal;\n}\n\n\nfloat raymarch (vec3 start, vec3 direction) {\n    #define maxSteps 100\n    #define converged 0.001\n    vec3 position = start;\n    float totalDistance = 0.0;\n    for (int i = 0; i < maxSteps; i++ ) {\n        // Step forward by the SDF distance\n        float currentDistance = SDF(position);\n        totalDistance += currentDistance;\n        position += direction * currentDistance;\n        \n        // If we are close to a surface, stop iterating\n        if ( currentDistance < converged ) break;\n    }\n    return totalDistance;\n}\n\n\nvec3 lighting ( vec3 surface ) {\n    // Define the lighting parameters\n    vec3 light = vec3(0, 5, 18) + 15.0 * vec3(cos(iTime), 0, sin(iTime));\n    float strength = 0.6;\n    vec3 specular = vec3(0.96, 0.74, 0.08);\n    vec3 diffuse = vec3(0.62, 0.46, 0.12);\n    \n    // Calculate the sphere's brightness\n    vec3 lightDelta = light - surface;\n    vec3 N = normal(surface);\n    vec3 L = normalize(lightDelta);\n    float lightDistance = raymarch(surface + 0.2 * N, L);\n    float brightness = strength * dot(N, L);\n    \n    // Add a reflection\n    \n    \n    // Add a Shadow color\n    float straightLightDistance = length(lightDelta);\n    bool occluded = straightLightDistance < 300.0\n        && straightLightDistance + 0.3 > lightDistance;\n    vec3 shadow = occluded\n        ? 0.5 * vec3(1, 1, 1)\n        : vec3(1, 1, 1);\n    \n    // Calculate the color\n    if ( brightness < 0.0 ) return diffuse;\n    vec3 color = brightness * specular * shadow + diffuse ;\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Setup the camera and the pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 start = vec3(uv, 0);\n    vec3 camera = vec3(0, 0, -1.0);\n    vec3 direction = normalize(start - camera);\n   \n    \n    // Get the distance to the nearest object\n    float distance = raymarch(start, direction);\n    if ( distance > 100.0 ) {\n        fragColor = vec4(87, 66, 245, 0)/255.0;\n        return;\n    }\n    \n    // Find the surface point and the corresponding normal \n    vec3 surface = start + distance * direction;\n    vec3 color = lighting(surface);\n    fragColor = vec4(color, 0.0);    \n    \n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"}]}