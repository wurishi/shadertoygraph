{"ver":"0.1","info":{"id":"cdKfzK","date":"1698418959","viewed":330,"name":"pixelshader","username":"wuerzig","description":"inspired by how the world looks through a patterned glass door. There is no fresnel and thus also no total internal reflection, so this is not physically correct. Try changing the texture to britney, the webcam input is pretty fun as well","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","grid","sdf","refraction","glass","glassbricks","glasswindow","glassdoor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* \n*\n* SDF functions by iq (https://iquilezles.org/articles/distfunctions/)\n* \n*\n*/\n\n\n\n#define PI 3.141592\n\nfloat sdSphere( vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec3 hash33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 rotateX(vec3 p, float phi) {\n    return p = p * mat3(\n        vec3(1., 0., 0.),\n        vec3(0, cos(phi), -sin(phi)),\n        vec3(0, sin(phi), cos(phi)));\n}\n\nfloat sdNuppi2(vec3 p, vec3 noize) {\n   //p = rotateX(p, -PI/3.);\n    float a = 0.2;\n    float b = 0.15;\n    \n    float dist11 = sdCutSphere(\n        p,\n        a + b,\n        0.2+abs(noize.x)*0.08);\n\n    float dist12 = sdRoundBox(p, vec3(a, 0.06, a), b);\n    float dist13 = sdBox(p, vec3(a+b, 0.16, a+b));\n    //return smin(smin(dist11, dist12, 0.01), dist13, 0.01);\n    return min(smin(dist11, dist12, 0.35), dist13);\n}\n\n// p ... point in space\n// c ... repetition period\nfloat opRepLim2( in vec3 p, float c, vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    q = rotateX(q, -PI / 2.0);\n    vec3 noize = hash33(round(p/c));\n    return sdNuppi2(q, noize);\n}\n\nfloat sdf(vec3 p, out int hit) {\n    //float dist1 = sdNuppi2(p);\n    float dist1 = opRepLim2(p, 0.66, vec3(15.0, 15.0, 0.001));\n    float dist2 = sdPlane(p, vec3(0.0, 0.0, 1.0), 2.0); \n    if (abs(dist1) < abs(dist2))\n        hit = 0;\n    else\n        hit = 1;\n    \n    return min(abs(dist1), abs(dist2));\n}\n\nfloat sdf(vec3 p) {\n    int hit;\n    return sdf(p, hit);\n}\n\n#define EPSILON 0.00001\n\nfloat march(in vec3 rayStart, in vec3 rayDir, out int hit) {\n    int hit_;\n    float t = 0.0f;\n    vec3 tp;\n    for (int i = 0; i < 128; i++) {\n    \tvec3 p = rayStart + t*rayDir;\n        \n        float dist = sdf(p, hit_);\n        hit = hit_;\n        \n        if (dist < EPSILON * 10.0)\n            break;\n        t += dist * 0.5;\n    }\n    return t;\n\n}\n\n// calculate normal in distance field\nvec3 dfNormal( in vec3 p ) {\n\tvec3 eps = vec3(EPSILON, 0.0, 0.0);\n\tvec3 res = vec3(\n\t    sdf(p+eps.xyy) - sdf(p-eps.xyy),\n\t    sdf(p+eps.yxy) - sdf(p-eps.yxy),\n\t    sdf(p+eps.yyx) - sdf(p-eps.yyx));\n\treturn normalize(res);\n}\n\nmat3 makeCam( in vec3 origin, in vec3 target) {\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 lookVec = normalize(target-origin);\n\tvec3 right = normalize(cross(lookVec, worldUp));\n\tvec3 camUp = normalize(cross(right, lookVec));\n    return mat3(right, camUp, lookVec);\n}\n\nfloat phong(vec3 p) {\n    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n    vec3 n = dfNormal(p);\n    vec3 d = normalize(lightPos - p); \n    float diff = max(dot(n, d), 0.0);\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    vec3 rayStart;\n    vec3 rayDirection;\n    vec3 camTarget;\n    vec2 point;\n    \n    vec3 col = vec3(0.0, 0.0, 1.0);\n\n \n    point = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n    rayStart = vec3(sin(iTime)*1.0, cos(iTime)*1.0, 10.0);\n    \n    \n    camTarget = vec3(0.0f, 0.0f, 0.0f);\n    mat3 cameraMatrix = makeCam(rayStart, camTarget);\n    rayDirection = cameraMatrix * normalize(vec3(point.xy,3.0 /*fov*/));\n\n    int hit = -1;\n    bool finished = false;\n    bool insideSphere = false;\n    vec3 p = rayStart;\n    vec3 intersection;\n    vec3 n;\n    \n    int bounces = 0;\n    \n    while (!finished) {\n\n        float t = march(p, rayDirection, hit);\n        intersection = p + t * rayDirection;\n\n        if (hit == 0) {\n            // sphere\n            if (true) {// set to false to see glass as solid object\n                // glass\n                insideSphere = !insideSphere;\n\n                n = dfNormal(intersection);\n                // ior\n                float IOR = 1.5;\n                float eta = insideSphere ? 1.0 / IOR : (IOR);\n\n                rayDirection = refract(\n                    normalize(rayDirection),\n                    normalize(n), eta);\n\n                rayDirection = normalize(rayDirection);\n                p = intersection + 0.1 * rayDirection;\n            } else {\n                p = intersection;\n                col = vec3(0.7, 0.8, 0.9) * phong(p); \n                finished = true;\n            }\n        }\n        if (hit == 1) {\n            p = intersection;\n            // background plane\n            col = texture(iChannel0, p.xy*vec2(0.08, 0.08) + vec2(0.5, 0.6)).xyz;\n            \n            vec3 ambient = vec3(0.3, 0.3, 0.3);\n            col = (phong(p) + ambient) * col;\n            \n            finished = true;\n        }\n        \n        bounces++;\n        \n        if (bounces > 3) {\n            // catch odd bugs\n            col = vec3(1.0, 0.0, 0.0);\n            finished = true;\n        }\n   }\n   fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}