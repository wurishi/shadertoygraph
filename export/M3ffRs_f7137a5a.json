{"ver":"0.1","info":{"id":"M3ffRs","date":"1728771839","viewed":84,"name":"Quantum Entanglement Operator","username":"nbardy","description":"Uses orbit trapping trapping and quaternions to render some fractals.\n\nNovel fractal generated by claude + ChatGPT with <web-of-thought>","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["quaternions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Using 4D quaternion space, Hopf fibration, and orbit traps\n\n#define MAX_ITERATIONS 200\n#define EPSILON 0.0001\n#define PI 3.14159265359\n\n// Quaternion multiplication\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz),\n        a.w * b.w - dot(a.xyz, b.xyz)\n    );\n}\n\n// Quaternion exponentiation\nvec4 qexp(vec4 q) {\n    float r = length(q.xyz);\n    vec3 n = q.xyz / r;\n    return exp(q.w) * vec4(sin(r) * n, cos(r));\n}\n\n// Hopf fibration projection\nvec3 hopfProjection(vec4 q) {\n    float d = 1.0 / (1.0 + q.w);\n    return vec3(\n        2.0 * (q.x * q.z + q.y * q.w) * d,\n        2.0 * (q.y * q.z - q.x * q.w) * d,\n        (q.x * q.x + q.y * q.y - q.z * q.z - q.w * q.w) * d\n    );\n}\n\n// Quantum Entanglement Operator (simplified representation)\nvec4 quantumEntangle(vec4 q, float t) {\n    vec4 entangled = qexp(qmul(q, vec4(sin(t), cos(t), sin(2.0*t), cos(2.0*t))));\n    return qmul(entangled, qmul(q, entangled));\n}\n\n// Orbit trap calculation\nfloat orbitTrap(vec4 q) {\n    vec3 trap1 = vec3(0.5, 0.5, 0.5);\n    vec3 trap2 = vec3(-0.5, -0.5, -0.5);\n    vec3 projected = hopfProjection(q);\n    return min(length(projected - trap1), length(projected - trap2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Initialize quaternion based on pixel position and time\n    vec4 q = vec4(uv, 0.0, 0.0);\n    q.z = 0.5 * sin(iTime * 0.1);\n    q.w = 0.5 * cos(iTime * 0.1);\n    \n    float minDist = 1e10;\n    vec3 color = vec3(0.0);\n    \n    // Iterate to apply Quantum Entanglement Operator\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        q = quantumEntangle(q, float(i) * 0.1 + iTime * 0.05);\n        \n        float dist = orbitTrap(q);\n        minDist = min(minDist, dist);\n        \n        // Accumulate color based on iteration and distance\n        color += vec3(float(i) / float(MAX_ITERATIONS), dist, 1.0 - dist) * 0.1;\n        \n        // Break if we're close to a trap or if the quaternion magnitude is too large\n        if (dist < EPSILON || length(q) > 2.0) break;\n    }\n    \n    // Apply some post-processing for better visualization\n    color = pow(color, vec3(0.4545));\n    color *= 1.0 - minDist;\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}