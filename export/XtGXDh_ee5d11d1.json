{"ver":"0.1","info":{"id":"XtGXDh","date":"1484046895","viewed":254,"name":"Raytraced box","username":"andrewww1","description":"A so so algorithm to get a box's normals. The unsimplified maths looks like this:\nif(abs(dot(hit,xAxis)-dot(bMin,xAxis))<eps) {return -xAxis;}\nif(abs(dot(hit,xAxis)-dot(bMax,xAxis))<eps) {return xAxis;}\nI want to try get it branchless though.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["normal","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ANTIALIAS 1\n\n#define BMIN vec3(1.0)\n#define BMAX vec3(5.0,5.0,5.0)\n#define GROUND vec4(0.0,1.0,0.0,-1.0)\n\nbool collidePlane(vec3 P,vec3 V,vec4 plane, out float t) {    \n    float NPd=dot(plane.xyz,P)+plane.w;\n    float NV=dot(plane.xyz,V);\n    t=-NPd/NV;\n    return (NPd>0.0 && NV<0.0); //P not below/on or V not parallel/away\n}\n\nbool collideBox(vec3 P,vec3 V,vec3 bMin,vec3 bMax, out float t,out vec3 nor) {\n\tvec3 invRay=1.0/V;\n\tvec3 tmin = (bMin - P) * invRay;\n\tvec3 tmax = (bMax - P) * invRay;\n\tvec3 tnear = min(tmin, tmax);\n\tvec3 tfar = max(tmin, tmax);\n\n\tfloat enter = max(tnear.x, max(tnear.y, tnear.z)); //max(tnear.x, 0.0)\n\tfloat exit = min(tfar.x, min(tfar.y, tfar.z));\n\n\tt=enter;\n    \n    //from shadertoy.com/view/ld23DV\n\tnor = -sign(V)*step(tnear.yzx,tnear.xyz)*step(tnear.zxy,tnear.xyz);\n    \n    //\n\treturn exit > max(enter, 0.0); //exit>0.0 && enter<exit\n}\n\nbool collideBoxP(vec3 P,vec3 V,vec3 bMin,vec3 bMax, out float t) {\n\t//from gamedev.net/topic/682750-problem-with-raybox-intersection-in-glsl/#entry5313405\n\t//from gamedev.net/resources/_/technical/math-and-physics/intersection-math-algorithms-learn-to-derive-r3033\n\t//from tavianator.com/fast-branchless-raybounding-box-intersections-part-2-nans\n\n\tvec3 invRay=1.0/V;\n\tvec3 tmin = (bMin - P) * invRay;\n\tvec3 tmax = (bMax - P) * invRay;\n\tvec3 tnear = min(tmin, tmax);\n\tvec3 tfar = max(tmin, tmax);\n\tfloat enter = max(tnear.x, max(tnear.y, tnear.z)); //max(tnear.x, 0.0)\n\tfloat exit = min(tfar.x, min(tfar.y, tfar.z));\n\tt=enter;\n\treturn exit > max(enter, 0.0); //exit>0.0 && enter<exit\n}\n\nvec3 calcPtLightCol(vec3 pos, vec3 nor, vec3 lightPos,vec3 lightAtten,\n\t\t\t\t\tvec3 lightCol,vec3 mtrlCol,float shininess,\n\t\t\t\t\tfloat strength) {\n\tvec3 lightDir=lightPos.xyz-pos;\n\tfloat lightDist=length(lightDir);\n\tlightDir=lightDir/lightDist;\n\n\t//\n\tfloat a = 1.0/(lightAtten.x+lightAtten.y*lightDist+lightAtten.z*lightDist*lightDist);\n\n\tvec3 reflectVec=reflect(-lightDir,nor);\n\tfloat NdotL = max(0.0,dot(nor,lightDir));\n\tfloat spec=0.0;\n\n\tif(NdotL > 0.0) {\n\t\tfloat NdotR = max(0.0, dot(nor, reflectVec));\n\t\tspec = pow(NdotR, shininess*128.0) * strength*a;\n\t}\n\n\tfloat diffuse=NdotL*a;\n\treturn lightCol*(mtrlCol*diffuse+spec);\n}\n\nfloat calcFlare(vec3 ro,vec3 rd,vec3 lightPos,float size) {\n\tvec3 viewLightDir=normalize(lightPos-ro);\n\tfloat viewLightDist=length(lightPos-ro);\n\tfloat q = dot(rd,viewLightDir)*0.5+0.5;\n\tfloat o = (1.0/viewLightDist)*size;\n\treturn clamp(pow(q,900.0/o)*1.0,0.0,2.0);\n}\n\nbool collideScene(vec3 ro,vec3 rd,out vec3 colPt, out vec3 nor) {\n\tfloat t=9999999.0,t2;\n\tbool hit=false;\n\n\tvec3 bMin=BMIN;\n\tvec3 bMax=BMAX;\n\tvec4 plane=GROUND;\n    \n\tif(collidePlane(ro,rd,plane,t2) && t2 < t) {\n\t\tt=t2;\n\t\tcolPt=ro+rd*t;\n\t\tnor=plane.xyz;\n\t\thit=true;\n\t} \n\t    \n\tvec3 nor2;\n    \n\tif(collideBox(ro,rd,bMin,bMax,t2,nor2)) {\n\t\tt=t2;\n\t\tcolPt=ro+rd*t;\n\t\tnor=nor2;\n\t\thit=true;\n\t}\n\t\n\treturn hit;\n}\n\nbool collideSceneP(vec3 ro,vec3 rd,out float t) {\n\tt=9999999.0;\n\tfloat t2;\n\tbool hit=false;\n\n\tvec3 bMin=BMIN;\n\tvec3 bMax=BMAX;\n\tvec4 plane=GROUND;\n\t\n\tif(collidePlane(ro,rd,plane,t2) && t2 < t) {\n\t\tt=t2;\n\t\thit=true;\n\t} \n\t\n\tif(collideBoxP(ro,rd,bMin,bMax, t2) && t2 < t) {\n\t\tt=t2;\n\t\thit=true;\n\t}\n\t\n\treturn hit;\n}\n\nvec3 checkerCol(vec3 texc, vec3 color0, vec3 color1) {\n    float q=clamp(mod(dot(floor(texc),vec3(1.0)),2.0),0.0,1.0);\n    return color1*q+color0*(1.0-q);\n}\n\nfloat sdBox(vec3 p,vec3 b) {\n\tvec3 d=abs(p)-b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nfloat sdPlane(vec3 p,vec4 n) {\n\treturn dot(p,n.xyz)+n.w;\n}\n\nfloat distScene(vec3 p) {\n\tvec3 bh=(BMAX-BMIN)*0.5,bp=BMIN+bh;\n\tfloat rs=min(sdBox(p-bp,bh),sdPlane(p,GROUND));\n\treturn rs;\n}\n\nfloat ambOccl(vec3 p, vec3 n) {\n  //shadertoy.com/view/4ssGzS\n  float step = 0.4;\n  float ao = 0.0;\n  float dist;\n  \n  for(float i=1.0;i<=7.0;i++) {\n    dist = step*i;\n    ao += max(0.0, (dist - distScene(p + n * dist)) / dist);  \n  }\n  \n  return 1.0 - ao * 0.1;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 lightCol=vec3(1.0,0.9,0.8);\n\tvec3 lightAtten=vec3(0.75,0.001,0.0001);\n\tvec3 lightPos=vec3(cos(iTime)*13.0,7.0,sin(iTime)*13.0);\n\n\tvec3 col=vec3(0.0);\n\tvec3 pt,nor;\n\tbool hasHit=false;\n\t\n\tif(collideScene(ro,rd, pt,nor)) {\n\t\tvec3 matCol=checkerCol(pt*0.5,vec3(0.5),vec3(0.8));\n\t\tfloat tt,shd=1.0;\n        shd=(collideSceneP(lightPos,normalize(pt-lightPos),tt) && tt<length(pt-lightPos)-0.0001)?0.01:1.0;\n        vec3 light=calcPtLightCol(pt,nor,lightPos,lightAtten,lightCol,matCol,1.0,0.2);\n        vec3 amb=clamp(light,0.0,0.05)*matCol;\n        float occl=ambOccl(pt,nor);\n\t\tcol+=light*shd*occl+amb;\n\t\thasHit=true;\n\t}\n\n\n\tif(!hasHit || length(ro-lightPos)<length(ro-pt)) {\n\t\tcol=mix(col,lightCol*1.5,calcFlare(ro,rd,lightPos,0.3));\n\t}\n\t\n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n\tfloat d=1.0/tan(fovy/2.0);\n\tvec3 v=vec3(screen.x*aspect,screen.y,-d);\n\tv=normalize(v);\n\treturn v;\n}\n\nmat3 orbitViewRot(float yaw,float pitch) {\n\tvec2 s=vec2(sin(pitch),sin(yaw));\n\tvec2 c=vec2(cos(pitch),cos(yaw));\n\treturn mat3(c.y,0.0,-s.y, s.y*s.x,c.x,c.y*s.x, s.y*c.x,-s.x,c.y*c.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat fovy=0.7854;\n\tfloat aspect=iResolution.x/iResolution.y;\n\t\n\tvec2 ms = iMouse.xy / iResolution.xy;\n\tvec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;\n\n\tfloat pitch=(ms2.y-0.5)*5.0-0.7;\n\tfloat yaw=(ms2.x-0.5)*5.0;\n    mat3 viewRot=orbitViewRot(yaw,pitch);\n\tvec3 ro=viewRot*vec3(0.0,2.0,25.0);\n    \n    vec3 col=vec3(0.0);\n    \n    #if defined(ANTIALIAS) && ANTIALIAS!=0\n    \tfloat g=1.0;\n    \n        for(float x=-1.0;x<=1.0;x++) {\n            for(float y=-1.0;y<=1.0;y++) {\n                vec2 uv = (fragCoord+vec2(x*g,y*g)*0.25) / iResolution.xy;\n                vec2 scr = uv*2.0-1.0;\n                vec3 rd=normalize(viewRot*calcPrimaryRay(scr,fovy,aspect));\n                col+=render(ro,rd);\n            }\n        }\n\n\t\tcol/=9.0;\n    #else\n        vec2 uv = fragCoord / iResolution.xy;\n\t\tvec2 scr = uv*2.0-1.0;\n        vec3 rd=normalize(viewRot*calcPrimaryRay(scr,fovy,aspect));\n\t\tcol=render(ro,rd);\n    #endif\n\t\n\n\tif(length(fragCoord-iMouse.xy) < 4.0) {\n\t\tcol=mix(col,vec3(1.0),0.2);\n\t}\n\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}