{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//these options seem to be too much for Windows: turn on for moar fun.\r\n//#define MOAR_CSG\r\n//#define BUILD_UP_AND_DOWN\r\n\r\n//Please turn on!! looks soo much better!\r\n//#define REFLECTIONS\r\n\r\n//turn these off to be cheaper...\r\n#define SHADOWS\r\n#define COLORS\r\n#define AO\r\n\r\n//OMG!! text due to mmalex!!\r\n#define LOGO\r\n\r\n//select one of these\r\n//#define NICE_NORMALS\r\n#define MEDIUM_NORMALS\r\n//#define NASTY_NORMALS\r\n\r\n#define pi 3.1415927\r\n\r\n\r\nfloat Box( vec3 p, vec3 b )\r\n{\r\n  vec3 d = abs(p) - b;\r\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 BoxY( vec3 p, vec3 b ) //euclidean & directed y distance only\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\tfloat mxz = max(d.x,d.z);\r\n\tfloat c = min(max(d.y,mxz),0.) + length(max(d,0.0));\r\n\t\t\r\n\treturn vec2(c, mxz < 0. ? d.y : 1e10 );\r\n}\r\n\r\nvec4 Box4( vec4 p_x, vec4 p_y, vec4 p_z, vec4 b_x, vec4 b_y, vec4 b_z )\r\n{\r\n\tvec4 d_x = abs(p_x) - b_x;\r\n\tvec4 d_y = abs(p_y) - b_y;\r\n\tvec4 d_z = abs(p_z) - b_z;\r\n\t\r\n\tvec4 mdx = max(d_x,0.);\r\n\tvec4 mdy = max(d_y,0.);\r\n\tvec4 mdz = max(d_z,0.);\r\n\t\r\n\tvec4 len = sqrt( mdx*mdx+mdy*mdy+mdz*mdz );\r\n\t\t\r\n\treturn min(max(d_x,max(d_y,d_z)),vec4(0)) + len;\r\n}\r\n\r\nvec4 Box4Y( vec4 p_x, vec4 p_y, vec4 p_z, vec4 b_x, vec4 b_y, vec4 b_z, out vec4 Y )\r\n{\r\n\tvec4 d_x = abs(p_x) - b_x;\r\n\tvec4 d_y = abs(p_y) - b_y;\r\n\tvec4 d_z = abs(p_z) - b_z;\r\n\t\r\n\tvec4 mdx = max(d_x,0.);\r\n\tvec4 mdy = max(d_y,0.);\r\n\tvec4 mdz = max(d_z,0.);\r\n\t\r\n\tvec4 len = sqrt( mdx*mdx+mdy*mdy+mdz*mdz );\r\n\t\r\n\tvec4 max_dxz = max(d_x,d_z);\r\n\r\n#if 0\t\r\n\tY = mix(vec4(1e10), d_y, vec4(lessThan(max_dxz, vec4(0.))) );\t//select y dist if inside ow. far out\r\n#else\t\r\n\tY.x = max_dxz.x < 0. ? d_y.x : 1e10;\r\n\tY.y = max_dxz.y < 0. ? d_y.y : 1e10;\r\n\tY.z = max_dxz.z < 0. ? d_y.z : 1e10;\r\n\tY.w = max_dxz.w < 0. ? d_y.w : 1e10;\r\n#endif\r\n\t\r\n\treturn min( max(d_y,max_dxz), vec4(0)) + len;\r\n}\r\n\t\r\nfloat CylinderXZ( vec3 p, vec3 c ) {\r\n\treturn length(p.xz-c.xy)-c.z;\r\n}\r\n\r\nvec3 RotX(vec3 p, float t) {\r\n\tfloat c = cos(t); float s = sin(t);\r\n\treturn vec3(p.x,\r\n\t\t\t\tp.y*c+p.z*s,\r\n\t\t\t\t-p.y*s+p.z*c);\r\n}\r\n\r\nvec3 RotY(vec3 p, float t) {\r\n\tfloat c = cos(t); float s = sin(t);\r\n\treturn vec3(p.x*c+p.z*s,\r\n\t\t\t\tp.y,\r\n\t\t\t\t-p.x*s+p.z*c);\r\n}\r\n\r\nvec3 RotZ(vec3 p, float t) {\r\n\tfloat c = cos(t); float s = sin(t);\r\n\treturn vec3(p.x*c+p.y*s,\r\n\t\t\t\t-p.x*s+p.y*c,\r\n\t\t\t\tp.z);\r\n}\r\n\r\nfloat Rep(float x, float t) { return mod(x,t)-0.5*t; }\r\nvec2 Rep(vec2 x, vec2 t) { return mod(x,t)-0.5*t; }\r\nvec3 Rep(vec3 x, vec3 t) { return mod(x,t)-0.5*t; }\r\nfloat U(float a,float b) { return min(a,b); }\r\nfloat U4(vec4 da) {\r\n\tda.xy = min(da.xy,da.zw);\r\n\treturn U(da.x,da.y);\t\r\n}\r\nfloat U8(vec4 da, vec4 db) {\r\n\tda = min(da,db);\r\n\treturn U4(da);\r\n}\r\n\r\nfloat I(float a,float b) { return max(a,b); }\r\nvec2 IY(vec2 a, vec2 b) { return max(a,b); }\r\n\r\nfloat S(float a,float b) { return max(a,-b); }\r\n\r\nvec2 UY(vec2 a,vec2 b) { return min(a,b); }\r\nvec2 U4Y(vec4 da, vec4 daY) {\r\n\tda.xy = min(da.xy,da.zw);\r\n\tdaY.xy = min(daY.xy,daY.zw);\r\n\treturn UY(vec2(da.x,da.y),vec2(daY.x,daY.y));\t\r\n}\r\n\r\nvec2 SY(vec2 a,vec2 b) { return max(a,-b); }\r\n\r\nfloat ClipX(float d, vec3 p, float x) { return I(d,p.x-x); }\r\nfloat ClipXX(float d, vec3 p, float x) { return I(d,abs(p.x)-x); }\r\n\r\nfloat ClipY(float d, vec3 p, float x) { return I(d,p.y-x); }\r\n\r\nvec2 ClipY(vec2 d, vec3 p, float x) { return vec2( I(d.x,p.y-x), I(d.y,p.y-x)) ; }\r\n\r\nfloat ClipNY(float d, vec3 p, float x) { return I(d,-p.y-x); }\r\n\r\nfloat ClipYY(float d, vec3 p, float x) { return I(d,abs(p.y)-x); }\r\n\r\nfloat ClipZ(float d, vec3 p, float x) { return I(d,p.z-x); }\r\nfloat ClipZZ(float d, vec3 p, float x) { return I(d,abs(p.z)-x); }\r\n\r\nfloat floor_height = -1.0;\r\nfloat floor_mat_bodge = 0.05;\r\n\r\nvec3 ss_grad(vec3 X)\r\n{\r\n\treturn cross(dFdx(X),dFdy(X));\r\n}\r\n\r\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\r\nfloat bias(float x, float b) {\r\n\treturn  x/((1./b-2.)*(1.-x)+1.);\r\n}\r\n\r\nfloat gain(float x, float g) {\r\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\r\n}\r\n\r\nvec2 gain(vec2 x, float g) {\r\n\tvec2 t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn vec2(\tx.x < 0.5 ? (x.x/(t.x+1.)) : (t.x-x.x)/(t.x-1.),\r\n\t\t\t\t\tx.y < 0.5 ? (x.y/(t.y+1.)) : (t.y-x.y)/(t.y-1.) );\r\n}\r\n\r\n//http://www.robertcailliau.eu/Lego/Dimensions/zMeasurements-en.xhtml\r\n/*\r\nThere are five basic dimensions:\r\nThe horizontal pitch, or distance between knobs:  8mm.\r\nThe vertical pitch, or height of a classic brick:  9.6mm.\r\nThe horizontal tolerance:  0.1mm\r\nThis is half the gap between bricks in the horizontal plane.  The horizontal tolerance prevents friction between bricks during building.\r\nThe knob diameter:  4.8mm\r\nThis is also the diameter of axles and holes.  Actually a knob must be slightly larger and an axle slightly smaller (4.85 and 4.75 respectively, otherwise axles would not turn in bearing holes and knobs would not stick in them) but we will ignore this difference here.\r\nThe height of a knob:  1.8mm\r\n*/\r\n#define brick_h 9.6\r\n#define brick_w\t(8./brick_h)\r\n#define knob_h\t(1.8/brick_h)\r\n#define knob_r\t(2.4/brick_h)\r\n\r\n//brick being +/-1 high is useful for floor fn.\r\n\r\nvec2 BrickSDFY(vec3 p)\r\n{\r\n#if 0\t\r\n\t//bricks\t\r\n\tvec3 r = p;\r\n\tr.x = Rep(r.x-brick_w,6.0*brick_w);\r\n\tvec2 d = BoxY(r,vec3(brick_w,1.,brick_w*3.));\r\n\t\r\n\td = UY(d,BoxY(p,vec3(brick_w,5.,brick_w*3.)));\r\n\td = SY(d,BoxY(p-vec3(0.,2.,0.),vec3(brick_w*2.,1.,brick_w*1.)));\r\n#endif\r\n\t\r\n#if 1\t\r\n\tfloat h = 13.;\r\n\t\t\r\n\tp.x += brick_w;\r\n\tp.x = abs(p.x);\r\n\t\r\n\t\t\t\t//bastion\t\tcolumn\tmain\ttower\r\n\tvec4 px = p.x - vec4(15.0, \t8.,\t\t20., \t22.)*brick_w;\r\n\tvec4 py = vec4(p.y);// + vec4(0., \t0.,\t\t0., \t0.);\r\n\tvec4 pz = p.z + vec4(0.0, \t1.,\t\t28., \t21.)*brick_w;\r\n\tvec4 bx = \t\tvec4(5.,\t2.,\t\t8.,\t\t6.)*brick_w;\r\n\tvec4 by = \t\tvec4(h,\t\t19.,\th,\t\t25.);\r\n\tvec4 bz = \t\tvec4(5.,\t2.,\t\t27.,\t6.)*brick_w;\t\r\n\t\t\r\n\tvec4 daY;\r\n\tvec4 da = Box4Y(px,py,pz,bx,by,bz,daY);\r\n\t\r\n\t\tpx = p.x - vec4(15.0, \t20.,\t17., \t22.)*brick_w;\r\n\t//\tpy = vec3(p.y);// + vec4(0., \t0.,\t\t0., \t0.);\r\n\t\tpz = p.z + vec4(1.0, \t21.,\t26., \t21.)*brick_w;\r\n\t\tbx = \t\tvec4(3.,\t6.,\t\t9.,\t\t4.)*brick_w;\r\n\t\tby = \t\tvec4(h+2.,\t13.,\th+2.,\t11.);\r\n\t\tbz = \t\tvec4(4.,\t2.,\t\t23.,\t7.)*brick_w;\t\r\n\t\t\r\n\tvec4 dbY;\r\n\tvec4 db = Box4Y(px,py,pz,bx,by,bz,dbY);\r\n\r\n\tvec2 d = U4Y(da, daY);\r\n\t\r\n\td = SY(d,vec2(db.x,dbY.x));\r\n\td = SY(d,vec2(db.z,dbY.z));\r\n\td = SY(d,vec2(db.w,dbY.w));\r\n\r\n\t\t\t\t\t  \r\n\t//bast+main - bast-main + tower - tower ? \r\n\td = SY( UY(vec2(da.x,daY.x),vec2(da.z,daY.z)), UY(vec2(db.x,dbY.x),vec2(db.z,dbY.z)) );\r\n\td = UY(d, vec2(da.y,daY.y) );\r\n\t\t\t\r\n\tvec3 q;\r\n\tq.x = Rep(p.x+0.*brick_w,10.*brick_w);\r\n\tq.y = Rep(p.y-1.,8.);\r\n\tq.z = Rep(p.z-1.*brick_w,6.*brick_w);\r\n\t\r\n\t\t//front windows&crenels\t\tside crenels \r\n\tpx = vec4(q.x,p.xxx) -  \tvec4(0.0, \t23.,\t22., \t22.)*brick_w;\r\n\tpy = vec4(q.yy,p.yy) -  \tvec4(0., \t0.,\t\t18., \t18.);\r\n\tpz = vec4(p.z,q.z,p.zz) + \tvec4(1.0, \t2.,\t\t21., \t21.)*brick_w;\r\n\tbx = \t\t\t\t\t\tvec4(1.,\t7.,\t\t7.,\t\t4.)*brick_w;\r\n\tby = \t\t\t\t\t\tvec4(2.,\t2.,\t\t3.,\t\t5.);\r\n\tbz = \t\t\t\t\t\tvec4(8.,\t1.,\t\t2.,\t\t7.)*brick_w;\t\r\n\t\r\n\tvec4 holesY;\r\n\tvec4 holes = Box4Y( px, py, pz, bx, by, bz, holesY );\r\n\t\t\r\n\td = SY(d,vec2(holes.x,holesY.x));\r\n\t\r\n\td = SY(d,vec2(holes.y,holesY.y));\r\n\r\n\t//add towers now to not cut holes in them!\r\n\td = UY(d, SY(vec2(da.w,daY.w),vec2(db.w,dbY.w)));\t\r\n\r\n\td = SY( d, vec2(db.y,dbY.y) );\r\n#ifdef MOAR_CSG\t\r\n\td = SY( d, vec2(holes.w,holesY.w) );\r\n\td = SY( d, vec2(holes.z,holesY.z) );\r\n#endif\t\r\n#endif\t\r\n\t\r\n\treturn d;\r\n}\r\n\r\nvec2 RedBrickSDFY(vec3 p)\r\n{\r\n\tvec2 d = BoxY(p+vec3(1.*brick_w,-1./3.,-11.*brick_w),vec3(6.*brick_w,2./3.,14.*brick_w));\r\n\tp.x = abs(p.x+1.*brick_w);\r\n\td = UY(d, BoxY(p-vec3(5.*brick_w,1.,0.),vec3(brick_w*1.,2.,brick_w*3.) ));\r\n\treturn d;\r\n}\r\n\r\nfloat AddStuds(vec2 D, vec3 p)\r\n{\r\n\tfloat d = D.x;\r\n\t\r\n\t//studs\r\n\tvec3 q = p;\r\n\tq.xz = Rep(q.xz-brick_w,vec2(2.*brick_w));\r\n\tfloat c = CylinderXZ(q,vec3(0.,0.,knob_r*2.));\r\n\r\n\tif (D.y > -0.0) //outside in Y dir\r\n\t{\t\t\r\n\t\tc = ClipY(c,p,floor((p.y-D.y))+knob_h*2.); //clip knob off at knob height above surface height\r\n\t\td = U(d,c);\r\n\t}\r\n\t\r\n\treturn d;\r\n}\r\n\r\nfloat sdf(vec3 p)\r\n{\r\n\t//floor!\r\n\tfloat f = p.y-floor_height;\r\n\tvec2 D = vec2(f);\r\n\r\n\t//bricks\r\n\t//vec2 D = BrickSDFY(p) );\r\n \tD = UY(D,BrickSDFY(p) ); \r\n\tD = UY(D,RedBrickSDFY(p));\r\n#ifdef BUILD_UP_AND_DOWN\t\r\n\t//build up and down\r\n\tfloat t = mod(iTime,20.);\r\n\tt = t > 10. ? 20.-t : t;\r\n\tt *= 2.;\r\n\tt = floor(t);\r\n\tfloat bh = 1.+2.*floor(t);\r\n\tD.x = ClipY(D.x,p,bh-0.08);\r\n\tD.y = ClipY(D.y,p,bh);\r\n#endif\t\r\n\treturn AddStuds(D,p);\r\n}\r\n\r\nfloat bb( vec2 p, vec2 b )\r\n{\r\n  return length(max(abs(p)-b,0.0));\r\n}\r\n\r\n//lego logo by mmalex!!\r\n//https://www.shadertoy.com/view/MsX3W2\r\nfloat lego(vec2 uv) { // x is -2 to 2\r\n\tuv.x+=uv.y*-0.1; // italic\r\n\tfloat oldx=uv.x;\r\n\tuv.x=fract(uv.x)-0.5; // letter repeat\r\n\tif (abs(oldx)>2.0) return 0.0; // clip!\r\n\tfloat l;\r\n\tif( oldx<0.0) {\r\n\t\t// l and e\r\n\t\tfloat e0=bb(uv-vec2(-0.15,0.0),vec2(0.2,0.0)); // cross of e \r\n\t\tif (oldx>-1.0) uv.y=-abs(uv.y); else e0=1.0;\r\n\t\tfloat l0=bb((uv)-vec2(0.0,-0.75),vec2(0.35,0.0)); // bottom of l\r\n\t\tfloat l1=bb((uv)-vec2(-0.35,0.0),vec2(0.0,0.75)); // left of l                                              \r\n\t\tl0=min(l0,e0);\r\n\t\tl=min(l0,l1);                                        \r\n\t} else {\r\n\t\tl=abs(bb(uv,vec2(0.2,0.6))-0.15); // round o\r\n\t\tif (oldx<1.0) {\r\n\t\t\t// g - ugh nasty\r\n\t\t\tif (uv.x>0.0 && uv.y>0.0 && uv.y<0.5)                                    \r\n\t\t\t\tl=bb((uv)-vec2(0.35,0.6),vec2(0.0,0.1));\r\n\t\t\tfloat e0=bb(uv-vec2(0.2,0.0),vec2(0.15,0.0));\r\n\t\t\tl=min(l,e0);\r\n\t\t}\r\n\t}              \r\n\treturn smoothstep(0.2,0.05,l);   \r\n}\r\n\r\nfloat nsdf(vec3 p)\r\n{\r\n//\treturn sdf(p); \r\n\t\r\n\t//for normals, add small bump displacements\r\n\tfloat d = sdf(p);\r\n\t\r\n\tfloat stripe = mod(p.y,2.);\r\n\td -= smoothstep(0.,0.04,abs(stripe-1.)*0.5)*0.01;\r\n\t\t\r\n#ifdef LOGO\t\r\n \td -= lego(10.*(fract(p.xz*vec2(0.5/brick_w)+0.5)-0.5))*.05;\r\n#endif\r\n\t\r\n\treturn d;\r\n}\r\n\r\nvec3 ss_nor(vec3 X)\r\n{\r\n\treturn normalize(cross(dFdx(X),dFdy(X)));\r\n}\r\n\t\r\nvec3 nor(vec3 X)\r\n{\r\n#ifdef NICE_NORMALS\t\r\n\t//expensive... kills windows shader compilers\r\n\tvec2 e = vec2(0.01,0.0); //fatter filter looks like bevelled edges on hard CSG shapes\r\n\tvec3 N = vec3(nsdf(X-e.xyy),nsdf(X-e.yxy),nsdf(X-e.yyx)) -\r\n\t\t\t vec3(nsdf(X+e.xyy),nsdf(X+e.yxy),nsdf(X+e.yyx));\r\n\treturn -normalize(N);\r\n#endif\t\r\n\t\r\n#ifdef MEDIUM_NORMALS\r\n\t//less expensive\t\r\n\tfloat e = 0.01;\r\n\tfloat d = nsdf(X);\r\n\tvec3 D;\r\n\tD.x = nsdf(vec3(X.x+e,X.y,X.z));\r\n\tD.y = nsdf(vec3(X.x,X.y+e,X.z));\r\n\tD.z = nsdf(vec3(X.x,X.y,X.z+e));\r\n\treturn normalize(D-vec3(d));\t\r\n#endif\t\r\n\r\n#ifdef NASTY_NORMALS\t\r\n\treturn -ss_nor(X); //cheap and nasty\r\n#endif\t\r\n}\r\n\r\n\r\n//thanks again iq https://iquilezles.org/articles/rmshadows\r\nfloat shadow( in vec3 X, in vec3 n, in vec3 L )\r\n{\r\n\tfloat mint = 0.001;\r\n\tfloat maxt = 20.0;\r\n\t\r\n\tX += n*.01;\r\n\t\r\n\tfloat h=0.4;\r\n\tfloat sharpness = 25.;\r\n\tfloat soft=1.0;\r\n\tfloat t = mint;\r\n\tfor (int i=0; i<32; i++)\r\n    {\r\n        float d = sdf(X + L*t);\r\n        if( d<-0.1 )\r\n            return h; //t*h;\r\n\t\t\r\n\t\tsoft = min( soft, (sharpness*d)*(1./t));\r\n\t\t\r\n\t\tif (t > maxt) break;\r\n        t += d * 0.9;\r\n    }\r\n    return clamp(soft,h,1.0);\r\n}\r\n\r\nfloat Ao(vec3 p, vec3 n) {\r\n\tfloat vis = 0.0;\r\n\tp += n*0.035;\r\n\tfloat t = 0.;//0.035;\r\n\tfor (int i=0; i<9; i++)\r\n\t{\r\n\t\tfloat d = sdf(p);\r\n\r\n\t//\th^2 = d^2+L^2\r\n\t\tfloat h = inversesqrt( d*d + t*t );\r\n\t\tvis += abs(d) * h;\t//cos angle of clear area?\r\n\r\n\t\tp += n * d * 0.9;\r\n\t\tt += d * 0.9;\r\n\t}\r\n\tvis *= 0.1;\r\n\tvis = bias(vis,0.125)*4.;\r\n\treturn vis; \r\n}\r\n\r\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\r\n{\r\n\tvec2 ooR = 1./iResolution.xy;\r\n    vec2 q = fragCoord.xy * ooR;\r\n    vec2 p =  2.*q -1.;\r\n    p.x *= iResolution.x * ooR.y;\r\n\t\r\n    vec3 lookAt = vec3(0.,0.,0.);\r\n\tfloat t = iTime*0.1;\r\n//\tt=0.;\r\n\tt = mod(t,3.);\r\n\tif (t < 1.)\r\n\t{\r\n\t\teye = vec3(10.,10.,10)*4.;\r\n\t\teye = RotY(eye,smoothstep(0.,1.,t)*-0.5*pi);\r\n\t\r\n\t}\r\n\telse if (t < 2.)\r\n\t{\r\n\t\tt -= 1.;\r\n\t\tfloat s = smoothstep(0.,1.,t);\r\n\t\teye = vec3(50.+s*10.,90.*(1.-s*0.5),50.);\r\n\t\tlookAt = vec3(5.,0.,-10.);\t\t\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt -= 2.;\r\n\t\tfloat s = smoothstep(0.,1.,t);\r\n\t\teye = vec3(-10.*(s*2.-1.),60. - s*30. ,-25.);\r\n\t\tlookAt = vec3(-20.*s,s,s*10.);\r\n\t}\r\n\t\r\n    // camera frame\r\n    vec3 fo = normalize(lookAt-eye);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    float fov = .25;\r\n\t\r\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n}\r\n\r\nfloat Trace(vec3 viewP, vec3 viewD, float max_t)\r\n{\r\n\tfloat t = 0.;\r\n\tfloat d;\r\n\r\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\r\n\t\r\n\tvec3 neighViewD = dFdy(viewD)+viewD;\t\r\n\t\t\t\t\r\n\tfor (int i=0; i<48; i++)\r\n\t{\r\n\t\tvec3 X = viewP + viewD * t;\r\n\t\td = sdf(X);\r\n\t\t\r\n\r\n\t\tvec3 nX = viewP + neighViewD*t;\r\n\t\tfloat r = length(X-nX);\t\t\t\t\r\n\t\tif (abs(d) < r*(0.25)) break; //less sparkly crap on silhouette edges?\r\n\t\t\t\t\r\n//\t\tif (abs(d) < 0.00001) break; //near enough surface for normals to look OK.\r\n\t\r\n#if 1\t\r\n\t\tif (t>max_t) //too far - won't converge: just go to ground plane.\r\n\t\t{\r\n\t\t\tt = floor_intersect_t;\r\n\t\t\tbreak;\r\n\t\t}\r\n#endif\t\t\r\n\t\tt += d*0.9; //bounding volumes make the distance a bit wrong so slow down\r\n\t}\r\n\r\n\treturn t;\t\r\n}\r\n\r\nfloat TraceR(vec3 viewP, vec3 viewD, float max_t)\r\n{\r\n\tfloat t = 0.;\r\n\tfloat d;\r\n\r\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\r\n\t\r\n\tvec3 neighViewD = dFdy(viewD)+viewD;\t\r\n\t\t\t\t\r\n\tfor (int i=0; i<32; i++)\r\n\t{\r\n\t\tvec3 X = viewP + viewD * t;\r\n\t\td = sdf(X);\r\n\t\t\r\n\r\n\t\tvec3 nX = viewP + neighViewD*t;\r\n\t\tfloat r = length(X-nX);\t\t\t\t\r\n\t\tif (abs(d) < r*(0.25)) break; //less sparkly crap on silhouette edges?\r\n\t\t\t\t\r\n//\t\tif (abs(d) < 0.001) break; //near enough surface for normals to look OK.\r\n\t\r\n#if 1\t\r\n\t\tif (t>max_t) //too far - won't converge: just go to ground plane.\r\n\t\t{\r\n\t\t\tt = floor_intersect_t;\r\n\t\t\t//t = viewD.y < 0. ? floor_intersect_t : max_t;\r\n\t\t\tbreak;\r\n\t\t}\r\n#endif\t\t\r\n\t\tt += d*0.9; //bounding volumes make the distance a bit wrong so slow down\r\n\t}\r\n\r\n\treturn t;\t\r\n}\r\n\r\nvec3 Light(vec3 X, vec3 n, vec3 V)\r\n{\r\n\tvec3 lightDir = normalize(vec3(-3,8,-5));\r\n\r\n\tvec3 c = vec3( max(dot(lightDir, n), 0.) );\r\n\r\n\tc = pow(texture(iChannel0,n).xyz,vec3(2.2));\r\n\t\r\n\t\t\r\n#ifdef SHADOWS\t\r\n\tfloat sha = shadow(X,n,lightDir);\r\n\tc *= sha;\r\n#endif\r\n\r\n\tc += 0.3;\r\n\t\r\n#ifdef AO\t\r\n\tfloat ao = Ao(X, normalize(n) );\r\n//\treturn vec3(ao);\r\n\tc *= ao;\r\n#endif\t\r\n\t\r\n#ifdef COLORS\t\r\n\tvec2 aX = abs(X.xz+vec2(1.*brick_w,23.*brick_w));\r\n\tfloat mX = max(aX.x,aX.y);\r\n\t\r\n\tconst float mat_test = 0.08;\r\n\tif (AddStuds(BrickSDFY(X),X) < mat_test)\r\n\t\tc *= pow(vec3(245./255.,205./255.,47./255.),vec3(2.2));  //yellow\r\n\telse if (AddStuds(RedBrickSDFY(X),X) < mat_test)\r\n\t\tc *= pow(vec3(196./255.,40./255.,27./255.),vec3(2.2)); //red\r\n\telse if (mX < 30.*brick_w)\r\n\t\tc *= pow(vec3(161./255.,165./255.,162./255.),vec3(2.2)); //gray\r\n\telse if (mX < 44.*brick_w)\t\t\r\n\t\tc *= pow(vec3(13./255.,105./255.,171./255.),vec3(2.2));  //blue\r\n\telse\r\n\t\tc *= pow(vec3(40./255.,127./255.,70./255.),vec3(2.2));  //green\r\n#endif\t\r\n\t\t\r\n\t//vec3 h = normalize(V+lightDir);\r\n\t//c += ao * sha *pow(max(dot(n,h),0.),80.0); //*2.5;\r\n\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 viewP, viewD;\r\n\tMakeViewRay(viewP, viewD, fragCoord);\r\n\t\r\n\tfloat t = Trace(viewP,viewD, 200.);\r\n\t\t\t\r\n\tvec3 X = viewP + viewD * t;\r\n\tvec3 n = nor(X);\r\n\t\r\n\tvec3 c = Light(X,n, viewD)*.7;\r\n\t\r\n#ifdef REFLECTIONS\t\r\n\tvec3 R = reflect(viewD,n);\r\n\tR = normalize(R);\r\n\tt = TraceR(X,R, 200.);\r\n\t\t\t\r\n\tX = X + R * t;\r\n\tn = nor(X);\r\n//\tn = ss_nor(X);\r\n\t\r\n\tc += Light(X,n, R)*clamp(1.-t*0.0125,0.,1.)*.1;\r\n#endif\r\n\t\r\n//\tc += Light(X,n);\r\n\t\r\n//\tc = vec3(glo);\r\n\t\t\t\t\r\n\tfloat gamma = 2.2;\r\n\tc = pow(c, vec3(1./gamma));\r\n\t\t\r\n#if 0\t\r\n//\tfloat debug_height = sin(iTime)*10.0;\r\n\tfloat debug_height = sin(iTime);\r\n\tfloat debug_intersect_t = (-viewP.y + debug_height) / (viewD.y);\t\r\n\tif (debug_intersect_t < t)\r\n\t{\r\n\t\tvec3 X = viewP + viewD * debug_intersect_t;\r\n\t\tfloat d = sdf(X);\r\n\t\tc = vec3(max(d,0.),max(-d,0.),0.);\r\n\t}\r\n#endif\r\n\t\r\n//\tc = n*0.5+0.5;\r\n//\tc = vec3(sha);\r\n//\tc = vec3(ao);\r\n\tfragColor = vec4(c,1.0);\r\n}\r\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sXGDj","date":"1379062976","viewed":6780,"name":"Lego Castle","username":"Antonalog","description":"The original little plastic voxels, and still the best.. I would do more but shader compiler will explode!!\nHah! now with Lego logo courtesy of mmalex!! <3 <3 <3","likes":113,"published":1,"flags":0,"usePreview":0,"tags":["lego"],"hasliked":0,"parentid":"","parentname":""}}