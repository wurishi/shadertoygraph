{"ver":"0.1","info":{"id":"mlKfDy","date":"1703875689","viewed":57,"name":"Vol. Pathtracing test","username":"Toiture","description":"Volumetric Pathtracing\nDiffuse only surface. ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["volume","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n\n    vec3 col = vec3(0.);\n    \n    col = texture(iChannel0,uv).rgb ;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray {\n    vec3 o ;\n    vec3 dir ;\n};\n\n//--------------------------------defines-----------------------------\n//#define CORNELL_BOX\n#define cubeA vec3(-2.,-2.,-4.)\n#define cubeB vec3(2.,2.,4.)\n\n#define lightA vec3(-0.5,1.5,-0.5)\n#define lightB vec3(0.5,2.,0.5)\n\n#define sphereA vec4(0.,0.,0.,0.5)\n\n#define Bounces 3.\n#define ScatteringEvents 3\n#define RGB_NOISE\n\nconst float e = 0.0005 ;\nconst float PI2 = 3.141592*2. ;\n\nconst float sigmaA = 0.01 ;\nconst float sigmaS = 0.5;\nconst float sigmaT = sigmaA+sigmaS ;\n\n//--------------------------------!defines-----------------------------\n\n\n//--------------------------------utility-------------------------------\nuint wang_hash(inout uint seed)\n\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * PI2;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n//--------------------------------!utility-------------------------------\n\n//--------------------------------intersections-------------------------------\n//https://iquilezles.org/articles/intersectors/\nvec2 sphereIntersection(Ray ray, vec4 sph)\n{\n    vec3 oc = ray.o - sph.rgb;\n    float b = dot( oc, ray.dir );\n    vec3 qc = oc - b*ray.dir;\n    float h = sph.a*sph.a - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.) ; // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h ); ;\n}\nvec3 SphereNormal( in vec3 pos, in vec4 sph ) {\n\treturn ((pos - sph.xyz) / sph.w) ;\n}\n//https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\nvec2 boxAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if (tNear > tFar) return vec2(-1.,-1.) ;\n    return vec2(tNear,tFar) ;\n}\n//https://gist.github.com/Shtille/1f98c649abeeb7a18c5a56696546d3cf\nvec3 boxNormal(vec3 boxMin,vec3 boxMax , vec3 point)\n{\n\tvec3 center = (boxMax + boxMin) * 0.5;\tvec3 size = (boxMax - boxMin) * 0.5;\n\tvec3 pc = point - center;\n\t// step(edge,x) : x < edge ? 0 : 1\n\tvec3 normal = vec3(0.0);\n\tnormal += vec3(sign(pc.x), 0.0, 0.0) * step(abs(abs(pc.x) - size.x), e);\n\tnormal += vec3(0.0, sign(pc.y), 0.0) * step(abs(abs(pc.y) - size.y), e);\n\tnormal += vec3(0.0, 0.0, sign(pc.z)) * step(abs(abs(pc.z) - size.z), e);\n\treturn normalize(normal);\n}\n\n//--------------------------------!intersections-------------------------------\n\n//--------------------------------map------------------------------------------\nstruct Hit {\n    float d ;\n    vec3 albedo ;\n    vec3 normal ;\n    float emissive;\n} ;\n\nHit map(Ray ray) {\n    Hit point ;\n    \n    float d = 4000.;\n    float cube = boxAABB(ray.o,ray.dir,cubeA,cubeB).y ;\n    float light = boxAABB(ray.o,ray.dir,lightA, lightB).x ;\n    float sphA = sphereIntersection(ray, sphereA).x ;\n    \n    #ifdef CORNELL_BOX\n    if(cube>0.)d = min(d, cube) ;\n    #endif\n    if(light>0.)d=min(d,light);\n    if(sphA>0.)d=min(d,sphA) ;\n    \n    vec3 normal = vec3(0.);\n    vec3 albedo = vec3(0.);\n    float emissive = 0. ;\n    \n    vec3 pos = ray.o+ray.dir*d ;\n    \n    if(d ==cube) {\n        normal = -boxNormal(cubeA, cubeB,pos) ;\n        \n        float r = max(0.,normal.r);\n        float g = max(0.,-normal.r);\n        albedo = mix(mix(vec3(1.),vec3(1.,0.,0.),r),vec3(0.,1.,0.),g);\n    } \n    if(d==light) {\n        normal = boxNormal(lightA, lightB, pos) ;\n        albedo = vec3(1.);\n        emissive = 15. ;\n    } \n    if(d==sphA) {\n        normal = SphereNormal(pos, sphereA) ;\n        albedo = vec3(0.,0.,1.);\n        emissive = 0. ;\n    } \n    \n    point.d = d ;\n    point.albedo = albedo ;\n    point.normal = normal ;\n    point.emissive = emissive ;\n    return point ;\n} \n\nvec3 skyBox(Ray ray) {\n    return ray.dir.y<-0. ? vec3(0.) : vec3(0.);\n} \n//--------------------------------!map------------------------------------------\n\n//--------------------------------volume----------------------------------------\nfloat fbm2(vec3 x, int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < octaves; ++i) {\n        v += a * texture(iChannel1, x).r;\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\nvec4 getVdens(vec3 pos){\n    return vec4(1.);\n    //return vec4(vec3(1.),smoothstep(0.5,0.51,texture(iChannel1, pos/3.).a)) ;\n    //return vec4(vec3(1.),length(pos-sphereA.rgb) <1.? 15. : 0.) ;\n    float point = length(pos-sphereA.rgb)-0.5;\n    point = clamp(point/0.5, 0.,1.);\n    \n    float d = exp(-point*10.)*(1.-point)*800. ;\n    //return vec4(vec3(1.),d);\n    //return vec4(vec3(1. ),pos.x>0.25?10.:0.);\n    return vec4(vec3(1.),1.);\n}\n//-------------------------------!volume----------------------------------------\n\n//--------------------------------phase function--------------------------------\nfloat gauss(float x,float pos){\n    x-=pos;\n    return (1.)/(1.+x*x*10000.);\n}\nfloat HG( float g, float sundotrd) {\n\tfloat gg = g * g;\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\n}\nfloat phase(float f, float b, float costh) {\n    return mix(HG(f, costh),HG(b,costh ),1. ); \n}\nfloat CornetteShanks(float g, float costh)\n{\n    return (3.0 * (1.0 - g * g) * (1.0 + costh * costh)) / (4.0 * 3.141592 * 2.0 * (2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n\n}\nfloat evalDraine(in float u, in float g, in float a)\n{\n    return ((1. - g*g)*(1. + a*u*u))/(4.*(1. + (a*(1. + 2.*g*g))/3.) * 3.141592 * pow(1. + g*g - 2. *g*u,1.5));\n\n}\nfloat phaseDraine(float f, float b, float costh) {\n    return mix(evalDraine(costh,f,0.25),evalDraine(costh,b,0.25),0.5 ); \n}\nfloat phaseShanks(float f, float b, float costh) {\n    return mix(CornetteShanks(f, costh),CornetteShanks(b,costh ),0.5 ); \n}\nvec3 phaseRGB(float costh){\n    float r = phase(0.9,-0.5,costh);\n    float g = phase(0.9,-0.5,costh);\n    float b = phase(0.9,-0.5,costh);\n    \n    r=gauss(costh,0.2)*50.;\n    g+=gauss(costh,0.1)*50.;\n    b+=gauss(costh,0.)*50.;\n    return vec3(r,g,b);\n}\n\n//--------------------------------raytracing------------------------------------\nfloat delta(Ray ray, uint state,float dist){\n    float t = 0. ;\n    for(int i = 0 ; i<10 ; i++){\n        t+= -log(1.-RandomFloat01(state))/sigmaT ;\n        \n        if(t>dist) break ;\n        vec3 try = ray.o+ray.dir*t ;\n        \n        vec4 de = getVdens(try) ;\n        float local = exp(-de.a*t*sigmaT);\n        \n        if(local<RandomFloat01(state)){\n            return t ;\n            \n        }\n    }\n    return t ;\n}\nvec3 volPath(Ray ray, uint state ) {\n    vec3 light = vec3(0.);\n    vec3 rayCol = vec3(1.);\n    \n    int channel = int(3.*RandomFloat01(state));\n    \n    vec3 mult = vec3(0.66);\n    #ifdef RGB_NOISE\n    switch(channel){\n    case 0 :\n        mult = vec3(1.,0.,0.);\n        break ;\n    case 1 :\n        mult = vec3(0.,1.,0.);\n        break ;\n    case 2 :\n        mult = vec3(0.,0.,1.);\n        break ;\n    };\n    #endif\n    \n    for(float b =0. ; b<Bounces ;b++) {\n        Hit hitInfo = map(ray) ;\n        \n        \n        /////////////////////volumetric pathtracing ////////////////////////\n        \n        for(int i = 0 ; i <ScatteringEvents ; i++) {\n            float wc = delta(ray, state, hitInfo.d) ;\n        \n            if(wc<hitInfo.d){\n                vec3 try = ray.o+ray.dir*wc;\n        \n                vec4 de = getVdens(try) ;\n\n                float local = exp(-de.a*wc*sigmaT);\n        \n        \n                if(local<RandomFloat01(state) ){\n                    vec3 old = ray.dir ;\n                    ray.dir = RandomUnitVector(state);\n                    ray.o = try ;\n                    rayCol*= phase(0.9,-0.5,dot(old,ray.dir))*de.rgb*mult;\n                    //rayCol*=phaseRGB(dot(old,ray.dir))*de.rgb*mult ;\n                }\n            } else {\n                break ;\n            } \n       \n            hitInfo = map(ray) ;\n        } \n        \n        hitInfo = map(ray) ;\n        /////////////////////////////////////////////////////////////////\n        \n        if(hitInfo.d>=4000.)light += skyBox(ray)*rayCol*mult;\n        ray.o+=ray.dir*hitInfo.d ;\n        \n        vec3 dir = normalize(hitInfo.normal+RandomUnitVector(state)) ;\n        if(hitInfo.d<4000.)\n        ray.dir= dir ;\n        \n        light+=hitInfo.emissive*rayCol*mult ;\n        \n        rayCol*=hitInfo.albedo*mult ;\n        \n        \n    } \n    \n    \n    return light*3. ;\n} \n//main \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y ;\n\n    vec3 col = vec3(0.);\n    \n    Ray cam ;\n    cam.o = vec3(0., 0.,3.);\n    cam.dir = normalize(vec3(uv,-1.));\n    \n    Hit info = map(cam) ;\n    \n    col = volPath(cam,rngState) ;\n    \n    vec3 oldCol = texture(iChannel0,fragCoord.xy/iResolution.xy).rgb ;\n    col = mix(oldCol,col,1./float(iFrame+1));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}