{"ver":"0.1","info":{"id":"MfSyDw","date":"1725397922","viewed":79,"name":"Test SDF for Rendering","username":"TheBen27","description":"A PS4-esque game controller that can be used for testing rendering techniques.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"M3sXDS","parentname":"Fidget Cube"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test SDF for Rendering Experiments\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n// Inigo Quilez 3D SDF Functions\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb = sqrt(Tonemap_ACES(col.rgb));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define MAT_METAL -1.0\n\nvec3 Tonemap_ACES(vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat fresnelFactor(float r0, vec3 dir, vec3 normal) {\n    float f = 1.0 - dot(normal, dir);\n    return r0 + (1.0 - r0) * (f * f * f * f * f);\n}\n\nvec3 skyLight(vec3 dir, vec3 col, vec3 center, float size, float smoothness) {\n    float falloff = max(0.0, dot(dir, normalize(center)));\n    float sizeMin = 1.0 - size;\n    falloff = smoothstep(sizeMin, mix(sizeMin, 1.0, smoothness), falloff);\n    // energy correction - smaller lamps should be brighter\n    return col * falloff / size;\n}\n\nvec3 sky(vec3 dir) {\n    vec3 top = vec3(0.4, 0.4, 0.6);\n    vec3 bottom = vec3(0.3, 0.3, 0.5);\n    vec3 ambient = mix(top, bottom, -dir.y);\n    return ambient;\n}\n\nfloat rand(float p)\n{\n    p = fract(p * .1031);\n    p += 0.1;\n    p *= p + 33.33;\n    p *= p + p;\n    p -= 0.1;\n    return fract(p);\n}\n\nfloat rand2(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(rand(i+1.), rand(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// Mirror\nvec3 mirrorX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\n// Rotation\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec3 rotX(vec3 p, float r) {\n    p.yz *= rot(r);\n    return p;\n}\n\nvec3 rotY(vec3 p, float r) {\n    p.xz *= rot(r);\n    return p;\n}\n\nvec3 rotZ(vec3 p, float r) {\n    p.xy *= rot(r);\n    return p;\n}\n\n// SDF\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 sdfMin(vec2 s1, vec2 s2) {\n    if (s1.x < s2.x) {\n        return s1;\n    }\n    return s2;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DEPTH 8.0\n#define CUBE_COUNT 8\n\nconst float minDepth = 0.01;\nconst float matchEps = 0.0001;\n\n// 0 - diffuse and sky spec only\n// 1 - phong\n// 2 - blinn-phong\n#define LIGHT_MODEL 2\n\n// Global vars\nfloat time;\n\nvec3 light(vec3 el, vec3 n, vec3 dir, vec3 col, vec3 alb) {\n    // diffuse\n    float diff = max(0.0, dot(n, dir));\n#if LIGHT_MODEL==0\n    float spec = 0.0;\n#elif LIGHT_MODEL==1\n    // Phong\n    vec3 r = -reflect(el, n);\n    float spec = pow(max(0.0, dot(r, el)), 64.0);\n#elif LIGHT_MODEL==2\n    // Since el is pointing towards the surface, not away from it,\n    // we need to invert it\n    vec3 h = normalize(dir - el);\n    float spec = pow(max(0.0, dot(h, n)), 256.0);\n#endif\n    return col * (alb * diff + spec);\n}\n\nfloat controllerSDF(vec3 pos) {\n    pos.y -= 0.21;\n    pos.yz *= rot(0.52);\n    float depth = 0.0;\n    \n    vec3 mx = mirrorX(pos);\n    // body\n    depth = sdRoundBox(pos, vec3(0.5,0.1,0.2), 0.05);\n    // handles\n    depth = smin(\n        depth,\n        sdCapsule(mx - vec3(0.4, 0.0, 0.0), vec3(0.0, 0.0, -0.1), vec3(0.1, -0.1, 0.1), 0.2),\n        0.1\n    );\n    // ergonomic curve along bottom of controller\n    depth = ssub(\n        length(pos.zy - vec2(-0.2, -0.3)) - 0.1,\n        depth,\n        0.25\n    );\n    // touchpad depression\n    vec3 touchpadPos = pos - vec3(0.0, 0.1, -0.1);\n    float touchpadCutout = sdRoundBox(touchpadPos, vec3(0.155, 0.05, 0.125), 0.001);\n    depth = max(-(abs(touchpadCutout) - 0.005), depth);\n    // thumbstick holders\n    vec3 stickHolder = mx - vec3(0.26, 0.03, 0.175);\n    depth = smin(\n        depth,\n        sdCappedCylinder(stickHolder, 0.05, 0.07) - 0.05,\n        0.1\n    );\n    vec3 stick = stickHolder - vec3(0.0, 0.025, 0.0);\n    // holes in thumbsticks\n    depth = ssub(\n        sdSphere(stick, 0.06) - 0.05,\n        depth,\n        0.01\n    );\n    // stick ball\n    depth = min(\n        sdSphere(stick, 0.06) - 0.05,\n        depth\n    );\n    // stick\n    depth = min(\n        depth,\n        sdCappedCylinder(stick - vec3(0.0, 0.1, 0.0), 0.05, 0.035)\n    );\n    // stick caps\n    depth = smin(\n        depth,\n        sdCappedCylinder(stick - vec3(0.0, 0.15, 0.0), 0.01, 0.06) - 0.01,\n        0.01\n    );\n    // flatten button areas\n    depth = ssub(\n        sdCappedCylinder(mx - vec3(0.42, 0.25, -0.1), 0.1, 0.2),\n        depth,\n        0.01\n    );\n    // face buttons\n    vec3 rbs = pos;\n    rbs.x = abs(rbs.x);\n    rbs += vec3(-0.4, -0.15, 0.075);\n    rbs.xz *= rot(PI / 4.0);\n    rbs.xz = abs(rbs.xz);\n    rbs.xz -= 0.055;\n    float rbd = sdSphere(rbs, 0.045);\n    rbd = ssub(\n        sdCappedCylinder(rbs - vec3(0.0, 0.1, 0.0), 0.085, 0.05),\n        rbd,\n        0.01\n    );\n    depth = min(\n        depth,\n        rbd\n    );\n    \n    return depth;\n}\n\nvec2 sceneSDF(vec3 pos) {\n    float ground = pos.y;\n    float controller = controllerSDF(pos);\n    \n    return vec2(min(ground, controller), 0.0);\n}\n\nvec3 sceneNormal( in vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h).x + \n                      k.yyx*sceneSDF( p + k.yyx*h).x + \n                      k.yxy*sceneSDF( p + k.yxy*h).x + \n                      k.xxx*sceneSDF( p + k.xxx*h).x );\n}\n\nvec2 getDepthAndMaterial(vec3 eye, vec3 dir) {\n    float depth = 0.0;\n    float sdf = matchEps;\n    float mat = 0.0;\n    for (int steps = 0;\n         sdf >= matchEps && depth < MAX_DEPTH && steps < 120;\n         steps++) {\n        vec2 sdf = sceneSDF(eye + depth * dir);\n        depth += sdf.x;\n        mat = sdf.y;\n    }\n    depth = min(depth, MAX_DEPTH);\n    \n    return vec2(depth, mat);\n}\n\nfloat occ( in vec3 p, in vec3 n)\n{\n    const float maxDist = 0.015;\n    const float falloff = 1.0;\n    const int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = rand(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal for self occlusion problems!\n\n        ao += (l - max(sceneSDF( p + rd).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 base_uv = fragCoord/iResolution.xy;\n    // time remapping/distortion here\n    time = iTime;\n    \n    vec3 eye, dir;\n    vec2 uv = base_uv;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = -1.75;\n    mat2 rx = rot(PI / 16.0);\n    mat2 ry = rot(PI * 0.25);\n    if (iMouse.z > 0.0) {\n        rx *= rot(0.5 * PI * (1.0 - iMouse.y / iResolution.y));\n        ry *= rot(2.0 * -PI * (iMouse.x / iResolution.x - 0.5));\n    }\n    eye = vec3(0.12, 0.25, dist);\n    eye.yz *= rx;\n    eye.xz *= ry;\n    dir = normalize(vec3(uv, 1.0));\n    dir.yz *= rx;\n    dir.xz *= ry;\n   \n    vec3 col = vec3(0.0);\n    \n    vec2 sdf = getDepthAndMaterial(eye, dir);\n    float depth = sdf.x;\n    float mat = sdf.y;\n    \n    if (depth < MAX_DEPTH || mat == -1.0) {\n        vec3 pos = eye + dir * depth;\n        vec3 norm;\n        \n        norm = sceneNormal(pos);\n        pos += norm * 0.001;\n        \n        vec3 alb = vec3(1.0);\n        if (pos.y > 0.01) {\n            alb = vec3(0.1);\n        }\n        \n        // diffuse ambient light\n        col += sky(norm) * alb;\n        \n        // specular ambient light\n        float fresnel = 0.4 * fresnelFactor(1.2, dir, norm);\n        vec3 spec = sky(reflect(dir, norm));\n        col = mix(col, spec, max(0.0, fresnel));\n        \n        // diffuse lighting\n        col += light(dir, norm, normalize(vec3(1.0, 1.0, 0.0)), vec3(0.7), alb);\n        col += light(dir, norm, normalize(vec3(-1.0, 1.0, 0.0)), vec3(0.3), alb);\n        col += light(dir, norm, normalize(vec3(0.0, 1.0, 0.0)), vec3(0.1), alb);\n        // fake bounce\n        col += 0.3 * (1.0 - smoothstep(0.0, 0.5, pos.y)) * max(0.0, -norm.y);\n        \n        // fake occlusion\n        if (pos.y <= 0.01) {\n            float c = controllerSDF(pos);\n            c = smoothstep(0.0, 0.15, c);\n            c = 0.3 + 0.7 * c;\n            col *= vec3(c);\n        }\n        \n        // occlusion\n        float occ = occ(pos, norm);\n        \n        col *= occ;\n        \n        // Sky fade-out\n        float skyFade = dot(pos.xz, pos.xz);\n        skyFade = smoothstep(0.0, 6.0, skyFade);\n        col = mix(col, sky(dir), skyFade);\n    } else {\n        col = sky(dir);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,depth);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}