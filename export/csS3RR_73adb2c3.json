{"ver":"0.1","info":{"id":"csS3RR","date":"1667058086","viewed":117,"name":" BaseTeroid","username":"BearSafari","description":"A classic arcade Asteroid game remake with actions taking place near a Black Hole","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["blackholearcaderetroremake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Create the player object(Piramid) and handle input transformation and rotation\n*/\nfloat createPlayer(vec3 point, vec3 originPos, vec3 offset) {\n\n    /// Get Rotation radians and matrix\n    float rotationRad = texelFetch(iChannel0, ivec2(P_ROTATION_COL, PLAYER_LAYER_ROW), 0).x;\n    mat2 rotationMat = Rotate(rotationRad);\n\n    /// Player body\n    Piramid body = Piramid(originPos, PLAYER_HEIGHT);\n    float playerHeight = body.height / 2.;\n\n    /// Handle body rotation and body movement\n    vec3 bodyPos = point - body.pos;\n    bodyPos -= offset;\n\n    // Triangle from the ass\n    vec3 trianglePos = point - body.pos;\n    trianglePos -= offset;\n\n    mat2 rotate180 = Rotate(PI);\n    mat3 rotationMat2 = RotateOffset(rotationRad, 0., -PLAYER_HEIGHT);\n    mat3 translationMat = Translate3(0., -PLAYER_HEIGHT);\n    float prevZ = trianglePos.z;\n    trianglePos.z = 1.;\n    trianglePos.xy *= rotate180;\n    trianglePos *= translationMat;\n    trianglePos *= rotationMat2;\n    trianglePos.z = prevZ;\n\n\n    bodyPos.xy *= rotationMat;\n\n    /// Flatten the piramid\n    bodyPos *= vec3(1., 1., 2.);\n    trianglePos *= vec3(1., 1., 2.);\n\n    vec2 controls = texelFetch(iChannel0, ivec2(P_CONTROLS_COL, PLAYER_LAYER_ROW), 0).xy;\n\n    if(controls.y != 1.){\n        return sdPyramid(bodyPos, playerHeight, body.height / 10., body.height / 1.5) / 2.;\n    }\n    else{\n        return min(sdPyramid(trianglePos, playerHeight/2.5, body.height / 25., body.height / 3.75) / 2., \n                   sdPyramid(bodyPos, playerHeight, body.height / 10., body.height / 1.5) / 2.);\n    }\n}\n\n\n\nfloat createAsteroids(vec3 point) {\n    float distToSphere = 99999.;\n\n    vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n\n    int num_asteroids = int(NUM_ASTEROIDS);\n    for (int i = 0; i < num_asteroids; ++i) {\n        Sphere sph = Sphere(vec3((\n            texelFetch(iChannel0, ivec2(i, 0), 0).xy * 2. - 1.\n        ) * screenSize, 0.), 1.);\n        if (POTATO == 1) {\n            distToSphere = min(distToSphere, sdAsteroid(point - sph.pos, sph, i));    \n        } else {\n            distToSphere = min(distToSphere, sdSphere(point - sph.pos, sph));\n        }\n    }\n\n    return distToSphere;\n}\n\nfloat createProjectiles(vec3 point) {\n    float distToProjectiles = 99999.;\n\n    vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n\n    int num_projectiles = int(NUM_PROJECTILES);\n    for (int i = 0; i < num_projectiles; ++i) {\n        Sphere sph = Sphere(vec3((\n            texelFetch(iChannel0, ivec2(i, PROJECTILE_LAYER_ROW), 0).xy * 2. - 1.\n        ) * screenSize, 0.), PROJECTILE_RADIUS);\n        distToProjectiles = min(distToProjectiles, sdSphere(point - sph.pos, sph));\n    }\n\n    return distToProjectiles;\n}\n\n\n/* Get minimal distance to each object, objects are generated here for now */\nvec4 getColAndDist(vec3 point) {\n    // vec3 bp = vec3(5., 0., 0.);\n    // float distToBox = sdBox(point - bp, Box(1., 1., 1., bp));\n\n    vec2 offset = texelFetch(iChannel0, ivec2(0, 1), 0).xy;\n    float distPiramid = createPlayer(point, vec3(0.), vec3(offset, 0.));\n\n    float distAsteroids = createAsteroids(point);\n    float distProjectiles = createProjectiles(point);\n\n    /// Use respective colors for respective objects\n    float hp = 0.3 - texelFetch(iChannel0, ivec2(P_COLLISION_COL, PLAYER_LAYER_ROW), 0).x;\n    vec3 player_color = vec3(0.);\n    if(hp == 0.3) {player_color = PLAYER_COLOR_3;}\n    if(abs(hp - 0.2) < 0.01) {player_color = PLAYER_COLOR_2;}\n    if(abs(hp - 0.1) < 0.01) {player_color = PLAYER_COLOR_1;}\n    vec3 projectile_color = player_color;\n\n    vec4 colDist = minSd(vec4(player_color, distPiramid), vec4(ASTEROID_COLOR, distAsteroids));\n    colDist = minSd(vec4(projectile_color, distProjectiles), colDist);\n\n    /// render event horizon\n    colDist = minSd(vec4(vec3(0.), length(point - BH_pos) - BH_R), colDist);\n\n    return colDist;\n}\n\n/* Function for getting a normal to the plane */\nvec3 getNormal(vec3 point) {\n    float dist = getColAndDist(point).w;\n    vec2 offset = vec2(.01, 0);\n\n    vec3 normal = dist - vec3(\n        getColAndDist(point - offset.xyy).w,\n        getColAndDist(point - offset.yxy).w,\n        getColAndDist(point - offset.yyx).w\n    );\n\n    return normalize(normal);\n}\n\n/*\n * Handle lighting and shadows\n * Takes current light level, new light position and a point\n * Takes color\n */\nvec3 getLighting(vec3 point, vec3 lightPos, vec3 color) {\n    vec3 lightDir = normalize(lightPos - point);\n    vec3 normal = getNormal(point);\n    float lightIntencity = clamp(dot(normal, lightDir)*.5+.5, 0., 1.);\n    // Get shadows\n    // Use a point a bit off so the loop does not immediately end\n    // vec3 stopColor = vec3(0.);\n    // vec3 lightStopPoint = blackHoleRender(point + normal * SURF_DIST * 2., lightDir, stopColor).xyz;\n    // if (length(point - lightStopPoint) > SURF_DIST) { lightIntencity *= .3; }\n    return color * lightIntencity;\n}\n\n\n\n\n/// returns 0 when fetch is at border of black hole reached\nfloat fetchPrecomputed(vec2 fragCoord, inout vec3 position, inout vec3 velocity) {\n    /// interpolate position and velocity\n    vec2 flooredfragCoord = floor(fragCoord);  // remove possible .5\n    vec4 currentPositionAndMode = vec4(0.);\n    vec4 rayVelocityAndMode = vec4(0.);\n    float mode = 1.;\n    if (\n        flooredfragCoord.x <= 1. || flooredfragCoord.y <= 0. ||\n        flooredfragCoord.x >= (iResolution.x-1.) || flooredfragCoord.y >= (iResolution.y-1.)\n    ) {\n        return 0.;  /// we are at border, so inteprpolation is not possible\n    } else {\n        bool is_velocity = (flooredfragCoord.x-2.*floor(flooredfragCoord.x/2.)) == 0.;\n        if (is_velocity) {\n            rayVelocityAndMode = texelFetch(iChannel2, ivec2(flooredfragCoord), 0);\n            mode = rayVelocityAndMode.w;\n            currentPositionAndMode = (\n                texelFetch(iChannel2, ivec2(flooredfragCoord-vec2(1., 0.)), 0) * .5 +\n                texelFetch(iChannel2, ivec2(flooredfragCoord+vec2(1., 0.)), 0) * .5\n            );\n        } else {\n            currentPositionAndMode = texelFetch(iChannel2, ivec2(flooredfragCoord), 0);\n            mode = currentPositionAndMode.w;\n            rayVelocityAndMode = (\n                texelFetch(iChannel2, ivec2(flooredfragCoord-vec2(1., 0.)), 0) * .5 +\n                texelFetch(iChannel2, ivec2(flooredfragCoord+vec2(1., 0.)), 0) * .5\n            );\n        }\n        /// if we reached black hole in any of them, return 0\n        if ((rayVelocityAndMode.w + currentPositionAndMode.w) < 2.) {\n            return 0.;\n        }\n    }\n    position = currentPositionAndMode.xyz;\n    velocity = rayVelocityAndMode.xyz;\n    return mode;\n}\n\n\n/// returns 0 when fetch is at border of black hole reached\nfloat fetchPrecomputed1(vec2 fragCoord, inout vec3 position, inout vec3 velocity) {\n    /// interpolate position and velocity\n    vec2 flooredfragCoord = floor(fragCoord);  // remove possible .5\n    vec4 currentPositionAndMode = vec4(0.);\n    vec4 rayVelocityAndMode = vec4(0.);\n    float mode = 1.;\n    if (\n        flooredfragCoord.x <= 1. || flooredfragCoord.y <= 0. ||\n        flooredfragCoord.x >= (iResolution.x-1.) || flooredfragCoord.y >= (iResolution.y-1.)\n    ) {\n        return 0.;  /// we are at border, so inteprpolation is not possible\n    } else {\n        bool is_velocity = (flooredfragCoord.x-2.*floor(flooredfragCoord.x/2.)) == 0.;\n        if (is_velocity) {\n            rayVelocityAndMode = texelFetch(iChannel3, ivec2(flooredfragCoord), 0);\n            mode = rayVelocityAndMode.w;\n            currentPositionAndMode = (\n                texelFetch(iChannel3, ivec2(flooredfragCoord-vec2(1., 0.)), 0) * .5 +\n                texelFetch(iChannel3, ivec2(flooredfragCoord+vec2(1., 0.)), 0) * .5\n            );\n        } else {\n            currentPositionAndMode = texelFetch(iChannel3, ivec2(flooredfragCoord), 0);\n            mode = currentPositionAndMode.w;\n            rayVelocityAndMode = (\n                texelFetch(iChannel3, ivec2(flooredfragCoord-vec2(1., 0.)), 0) * .5 +\n                texelFetch(iChannel3, ivec2(flooredfragCoord+vec2(1., 0.)), 0) * .5\n            );\n        }\n        /// if we reached black hole in any of them, return 0\n        if ((rayVelocityAndMode.w + currentPositionAndMode.w) < 2.) {\n            return 0.;\n        }\n    }\n    position = currentPositionAndMode.xyz;\n    velocity = rayVelocityAndMode.xyz;\n    return mode;\n}\n\n\n/// current_position is the ray origin\n/// color is the resulting color\nvec4 blackHoleRender(vec2 fragCoord, vec3 currentPosition, vec3 rayVelocity, inout vec3 color) {\n    // 4th coord is whether we found a point or diverged\n    // 0 for diverged\n    // 1 for converged on a point\n    vec4 currentLocationAndMode = vec4(0.);\n    float ray_dt = dt / ray_dt_divisor;\n    for (int i = 0; i < MAX_STEPS * int(ray_dt_divisor); ++i) {\n        vec4 colAndDist = getColAndDist(currentPosition);\n\n        rayVelocity += blackHoleNullParticleAccl(currentPosition) * ray_dt;\n\n        vec3 positionDelta = rayVelocity * ray_dt;\n        float dist_to_travel = length(positionDelta);\n        if (dist_to_travel > colAndDist.w) {\n            positionDelta *= colAndDist.w / dist_to_travel;\n        }\n\n        currentPosition += positionDelta;\n\n        // check that we got past height of second precomputed region\n        if (currentPosition.z >= 1.02) {\n            float mode = fetchPrecomputed1(fragCoord, currentPosition, rayVelocity);\n            if (mode == 0.) {  // reached below event horison\n                color = vec3(0.);\n                currentLocationAndMode = vec4(currentPosition, 1.);\n                break;\n            }\n            if (mode == 2.) {  // diverged\n                currentLocationAndMode = vec4(currentPosition, 2.);\n                break;\n            }\n        }\n\n        // check that we got below event horizon\n        if (distance(BH_pos, currentPosition) < BH_R) {\n            color = vec3(0.);\n            currentLocationAndMode = vec4(currentPosition, 1.);\n            break;\n        }\n\n        // check that we landed on a point\n        if (abs(colAndDist.w) < SURF_DIST) {\n            color = colAndDist.rgb;\n            currentLocationAndMode = vec4(currentPosition, 1.);\n            break;\n        }\n    }\n    if (currentLocationAndMode.w != 1.) {\n        color = 0.2 * normalize(rayVelocity);\n    }\n    return currentLocationAndMode;\n}\n\n\n/// color is the resulting color\nvec4 blackHoleRenderPrecomputed(vec2 fragCoord, inout vec3 color) {\n    vec3 position = vec3(0.);\n    vec3 velocity = vec3(0.);\n    float mode = fetchPrecomputed(fragCoord, position, velocity);\n    if (mode == 0.) {  // reached event horison\n        color = vec3(0.);\n        return vec4(vec3(0.), 1.);\n    }\n    if (mode == 2.) {  // diverged\n        color = 0.2 * normalize(velocity);\n        return vec4(vec3(0.), 2.);\n    }\n    return blackHoleRender(fragCoord, position, velocity, color);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    // vec3 outCol = vec3(0.2666, 0.2784, 0.3529);\n\n    float die = texelFetch(iChannel0, ivec2(P_COLLISION_COL, PLAYER_LAYER_ROW), 0).x;\n    if (die > 0.2) {\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n        return;\n    }\n\n    // get ray origin & direction\n    vec3 outCol = vec3(0.);\n    vec4 renderEndPointAndMode = blackHoleRenderPrecomputed(fragCoord, outCol);\n\n    if (renderEndPointAndMode.w == 1.) {\n        vec3 diffusedLighting = 1.354 * getLighting(renderEndPointAndMode.xyz, vec3(10, 10, -5), outCol);\n        outCol = diffusedLighting;\n    }\n    // Color correction\n    outCol = pow(min(outCol, 1.0), vec3(.99));\n\n    // Output to screen\n    fragColor = vec4(outCol, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Create the player object(Piramid) and handle input transformation and rotation\n*/\nfloat createPlayer(vec3 point, vec3 originPos, vec3 offset) {\n\n    /// Get Rotation radians and matrix\n    float rotationRad = texelFetch(iChannel0, ivec2(P_ROTATION_COL, PLAYER_LAYER_ROW), 0).x;\n    mat2 rotationMat = Rotate(rotationRad);\n\n    /// Player body\n    Piramid body = Piramid(originPos, PLAYER_HEIGHT);\n    float playerHeight = body.height / 2.;\n\n    /// Handle body rotation and body movement\n    vec3 bodyPos = point - body.pos;\n    bodyPos -= offset;\n\n    // Triangle from the ass\n    vec3 trianglePos = point - body.pos;\n    trianglePos -= offset;\n\n    mat2 rotate180 = Rotate(PI);\n    mat3 rotationMat2 = RotateOffset(rotationRad, 0., -PLAYER_HEIGHT);\n    mat3 translationMat = Translate3(0., -PLAYER_HEIGHT);\n    float prevZ = trianglePos.z;\n    trianglePos.z = 1.;\n    trianglePos.xy *= rotate180;\n    trianglePos *= translationMat;\n    trianglePos *= rotationMat2;\n    trianglePos.z = prevZ;\n\n\n    bodyPos.xy *= rotationMat;\n\n    /// Flatten the piramid\n    bodyPos *= vec3(1., 1., 2.);\n    trianglePos *= vec3(1., 1., 2.);\n\n    vec2 controls = texelFetch(iChannel0, ivec2(P_CONTROLS_COL, PLAYER_LAYER_ROW), 0).xy;\n\n    if(controls.y != 1.){\n        return sdPyramid(bodyPos, playerHeight, body.height / 10., body.height / 1.5) / 2.;\n    }\n    else{\n        return min(sdPyramid(trianglePos, playerHeight/2.5, body.height / 25., body.height / 3.75) / 2., \n                   sdPyramid(bodyPos, playerHeight, body.height / 10., body.height / 1.5) / 2.);\n    }\n}\n\n\n/*\n * Calculate offset for the ship including rotation\n * Calculate and apply acceleration and deceleration to the ship\n*/\nvec2 calcOffset(vec2 offset, inout vec2 inertia, float rotationRad) {\n    // get controls\n    vec2 controls = texelFetch(iChannel0, ivec2(P_CONTROLS_COL, PLAYER_LAYER_ROW), 0).xy;\n\n    /// Control values\n    float turnSpeed = 0.1 / 100.;\n    float velocity = 20. / 100.;\n    /// Inertia values\n    float maxSpeed = .1;\n\n    bool isThrottle = controls.y > 0.;      /* Get if throttling */\n\n    controls.x *= turnSpeed;\n    controls.y *= velocity;\n\n    mat2 rotationMat = Rotate(rotationRad);\n    controls *= rotationMat;\n    controls.x *= -1.;\n\n    /// Acceleration/deceleration\n    if (isThrottle && length(inertia) < maxSpeed) {\n        inertia.x = mix(inertia.x, controls.x, acceleration);\n        inertia.y = mix(inertia.y, controls.y, acceleration);\n    } else {\n        inertia.x = mix(inertia.x, 0., acceleration);\n        inertia.y = mix(inertia.y, 0., acceleration);\n    }\n\n    vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n    screenSize -= 1.0;\n    offset += inertia * speed;\n\n    if(offset.x > screenSize.x){\n        offset.x -= screenSize.x * 2.;\n    }\n    else if(offset.x < -1. * screenSize.x){\n        offset.x += screenSize.x * 2.;\n    }\n    if(offset.y > screenSize.y){\n        offset.y -= screenSize.y * 2.;\n    }\n    else if(offset.y < -1. * screenSize.y){\n        offset.y += screenSize.y * 2.;\n    }\n\n    return offset;\n}\n\n/*\n * Player movement wrapper for the data channel\n * Handles ofsset and inetria\n * outFrag ///< [in/out]\n * .xy - offset\n * .zw - inertia\n*/\nvoid handleMovement(inout vec4 outFrag) {\n    outFrag = texelFetch(iChannel0, ivec2(P_MOVEMENT_COL, PLAYER_LAYER_ROW), 0);\n    float rotationTexel = texelFetch(iChannel0, ivec2(P_ROTATION_COL, PLAYER_LAYER_ROW), 0).x;\n\n    /// Handle offset\n    outFrag.xy = calcOffset(outFrag.xy, outFrag.zw, rotationTexel);\n}\n\n/*\n * Player rotation wrapper for the data channel\n * outFrag ///< [in/out]\n * .x - rotation\n*/\nvoid handleRotation(inout vec4 outFrag) {\n    vec2 controls = texelFetch(iChannel0, ivec2(P_CONTROLS_COL, PLAYER_LAYER_ROW), 0).xy;\n    outFrag = texelFetch(iChannel0, ivec2(P_ROTATION_COL, PLAYER_LAYER_ROW), 0);\n    outFrag.x += controls.x * .1;\n}\n\n\n\n/*\n * Capture keyboard input\n*/\nvec3 handleKeyboard() {\n    vec3 direction = vec3(0.);\n\n    if (texelFetch(iChannel3, ivec2(KEY_UP, 0), 0).x == 1.\n     || texelFetch(iChannel3, ivec2(KEY_W, 0), 0).x == 1.) {\n        direction.xy += vec2(0., 1.);\n    }\n    \n    if (texelFetch(iChannel3, ivec2(KEY_DOWN, 0), 0).x == 1.\n     || texelFetch(iChannel3, ivec2(KEY_S, 0), 0).x == 1.) {\n        direction.xy += vec2(0., -1.);\n    }\n\n    if (texelFetch(iChannel3, ivec2(KEY_LEFT, 0), 0).x == 1.\n     || texelFetch(iChannel3, ivec2(KEY_A, 0), 0).x == 1.) {\n        direction.xy += vec2(-1., 0.);\n    }\n\n    if (texelFetch(iChannel3, ivec2(KEY_RIGHT, 0), 0).x == 1.\n     || texelFetch(iChannel3, ivec2(KEY_D, 0), 0).x == 1.) {\n        direction.xy += vec2(1., 0.);\n    }\n    if (texelFetch(iChannel3, ivec2(KEY_E, 0), 0).x == 1.\n     || texelFetch(iChannel3, ivec2(KEY_SPACE, 0), 0).x == 1.){\n        direction.z = 1.;\n    \n    }\n    \n    return direction;\n}\n\nuint hash(uint x) {\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n    return x;\n}\n// taken from https://stackoverflow.com/a/17479300/16471208\nfloat random(vec3 v) {\n    uvec3 uiv = floatBitsToUint(v);\n    uint m = hash(uiv.x ^ hash(uiv.y) ^ hash(uiv.z));\n    m &= 0x007FFFFFu; // keep mantissa\n    m |= 0x3F800000u; // add 1.0\n    return uintBitsToFloat(m) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 outFrag = vec4(0., 0., 0., 0.);\n    // if (iTime == 0.) {fragColor = outFrag; return;}\n\n    vec2 die = texelFetch(iChannel0, ivec2(P_COLLISION_COL, PLAYER_LAYER_ROW), 0).xy;\n\n    /*\n    * Pseudorandom generator for asteroid coordinate\n    */\n    if (int(fragCoord.y) == ASTEROID_LAYER_ROW && fragCoord.x < NUM_ASTEROIDS && int(die.x) != 1) {\n        outFrag = texelFetch(iChannel0, ivec2(fragCoord.x, ASTEROID_LAYER_ROW), 0);\n        if (outFrag.x > 1. || outFrag.y > 1. || outFrag.x <= 0. || outFrag.y <= 0.) {\n            float d = random(vec3(fragCoord, iTime));\n            outFrag.zw = vec2(\n                random(vec3(fragCoord, iTime+1.)),\n                random(vec3(fragCoord, iTime+2.))\n            );\n            outFrag.zw = outFrag.zw * 2. - 1.;\n            if (d < 0.25) {\n                outFrag.x = 0.001;\n                outFrag.y = random(vec3(fragCoord, iTime+3.));\n                if (outFrag.z < 0.) { outFrag.z = -outFrag.z; }\n            } else if (d < 0.50) {\n                outFrag.x = random(vec3(fragCoord, iTime+3.));\n                outFrag.y = 0.001;\n                if (outFrag.w < 0.) { outFrag.w = -outFrag.w; }\n            } else if (d < 0.75) {\n                outFrag.x = 0.999;\n                outFrag.y = random(vec3(fragCoord, iTime+3.));\n                if (outFrag.z > 0.) { outFrag.z = -outFrag.z; }\n            } else {\n                outFrag.x = random(vec3(fragCoord, iTime+3.));\n                outFrag.y = 0.999;\n                if (outFrag.w > 0.) { outFrag.w = -outFrag.w; }\n            }\n        } else {\n            outFrag.xy += outFrag.zw * ASTEROID_SPEED;\n        }\n\n        // Destroy asteroid if there is a collision with a projectile\n        vec4 projectileCollision = texelFetch(iChannel0, ivec2(fragCoord.x, PROJECTILE_COLLISION_ROW), 0);\n        if (projectileCollision.x > 0.) {\n            outFrag = vec4(0.);\n        }\n    }\n    /*\n     * Player shenanigans\n    */\n    else if (int(fragCoord.y) == PLAYER_LAYER_ROW) {\n        if (die.x > 0.2) {\n            if (int(fragCoord.x) == P_COLLISION_COL) {\n                if (iTime - die.y > 2.) {\n                    fragColor = vec4(0.);\n                } else {\n                    fragColor = vec4(die, 0., 0.);\n                }\n            } else {\n                fragColor = vec4(0.);\n            }\n            return;\n        }\n        /// Handle Player movement\n        if (int(fragCoord.x) == P_MOVEMENT_COL) {\n            handleMovement(outFrag);\n        }\n        else if(int(fragCoord.x) == P_CONTROLS_COL){\n            vec3 controls = handleKeyboard().xyz;\n            outFrag.xyz = controls;\n        }\n        /// Handle player rotation\n        else if (int(fragCoord.x) == P_ROTATION_COL) {\n            handleRotation(outFrag);\n        }\n        else if (int(fragCoord.x) == P_COLLISION_COL) {\n            \n            if (die.x > 0. && iTime - die.y < 1.) {\n                fragColor = vec4(die.x, die.y, 0., 0.);\n                return;\n            }\n\n            vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n            vec2 offset = texelFetch(iChannel0, ivec2(P_MOVEMENT_COL, PLAYER_LAYER_ROW), 0).xy;\n            bool collided = false;\n            /// Collision detection with asteroids\n            for (int i = 0; i < int(NUM_ASTEROIDS); ++i) {\n                vec2 asteroidCoords = (texelFetch(iChannel0, ivec2(i, int(ASTEROID_LAYER_ROW)), 0).xy * 2. - 1.) * screenSize;\n                if (distance(offset.xy, asteroidCoords) < PLAYER_HEIGHT / 2. + ASTEROID_RADIUS &&\n                    (length(offset.xy) != 0. && length(asteroidCoords) != 0.)) {\n                    outFrag.x = 0.1 + die.x;\n                    outFrag.y = iTime;\n                    collided = true;\n                }\n            }\n            if(!collided){\n                outFrag.xy = die;\n            }\n        }\n        else {\n            discard;\n        }\n    }\n    /*\n     * Camera properties(constant)\n    */\n    else if (int(fragCoord.y) == CAMERA_LAYER_ROW) {\n        if (int(fragCoord.x) == C_OPTIONS_COL) {\n            // camera position is constant for now\n            outFrag.xy = vec2(0., 0.);\n            // height is constant for now\n            outFrag.z = 20.;\n            // zoom is constant for now\n            outFrag.w = 0.5;\n            // vec2 mos = iMouse.xy/iResolution.xy;\n        } else if (int(fragCoord.x) == C_SCREEN_SIZE_COL) {\n            /// Screen size calculation -> this is scary\n            vec2 upRightUV = .5 * iResolution.xy / iResolution.y;\n            vec4 camera_props = texelFetch(iChannel0, ivec2(0., CAMERA_LAYER_ROW), 0);\n            vec3 ro = getRo(camera_props);\n            vec3 upRightRD = getRd(upRightUV, ro, camera_props);\n            float cosAngle = dot(-1. * ro, upRightRD) / length(ro);\n            float dist = length(ro) / cosAngle;\n            vec2 screenSize = (ro + upRightRD * dist).xy;\n            screenSize += 1.;\n\n            outFrag.xy = screenSize;\n        } else {\n            discard;\n        }\n    }\n    /*\n     * Projectile creation\n    */\n    else if (int(fragCoord.y) == PROJECTILE_CREATION_ROW && fragCoord.x < NUM_PROJECTILES && int(die.x) != 1) {\n        vec4 controls = texelFetch(iChannel0, ivec2(P_CONTROLS_COL, PLAYER_LAYER_ROW), 0);\n        vec4 currentProjectile = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y), 0);\n        float lastShootTime = texelFetch(iChannel0, ivec2(NUM_PROJECTILES, PROJECTILE_CREATION_ROW), 0).x;\n        outFrag = currentProjectile;\n\n        if (int(currentProjectile.x) == 1) {\n            outFrag.x = 2.;\n        }\n\n        bool wasAlreadyCreated = false;\n        for (int i = 0; i < int(NUM_PROJECTILES); ++i) {\n            float projectileStatus = texelFetch(iChannel0, ivec2(i, PROJECTILE_CREATION_ROW), 0).x;\n            if (projectileStatus > 0. && projectileStatus < 2.) {\n                wasAlreadyCreated = true;\n                break;\n            }\n        }\n\n        if (!wasAlreadyCreated && controls.z > 0. && currentProjectile.x < 1.) {\n            outFrag.x = 1.;\n        }\n\n        vec4 projectilePos = texelFetch(iChannel0, ivec2(fragCoord.x, PROJECTILE_LAYER_ROW), 0);    \n        vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n        if (projectilePos.x > 1. || projectilePos.x < 0. || projectilePos.y > 1. || projectilePos.y < 0.) {\n            outFrag.x = 0.;\n        }\n\n        for (int i = 0; i < int(NUM_ASTEROIDS); ++i) {\n            vec2 projectileCollision = texelFetch(iChannel0, ivec2(i, PROJECTILE_COLLISION_ROW), 0).xy;\n            if (projectileCollision.x > 0.) {\n                outFrag.x = 0.;\n            }\n        }\n    }\n    /*\n     * Projectile position calculation\n    */\n    else if (int(fragCoord.y) == PROJECTILE_LAYER_ROW && fragCoord.x < NUM_PROJECTILES && int(die.x) != 1) {\n        float creationValue = texelFetch(iChannel0, ivec2(fragCoord.x, PROJECTILE_CREATION_ROW), 0).x;\n        bool isJustCreated = creationValue > 0. && creationValue < 2.;\n        bool isCreated = creationValue > 1.;\n        vec4 currentProjectile = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y), 0);\n        if (isJustCreated) {\n            vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n            vec2 position = texelFetch(iChannel0, ivec2(P_MOVEMENT_COL, PLAYER_LAYER_ROW), 0).xy;\n            float rotationRad = texelFetch(iChannel0, ivec2(P_ROTATION_COL, PLAYER_LAYER_ROW), 0).x;\n            vec2 direction = vec2(sin(rotationRad), cos(rotationRad));\n\n            currentProjectile.xy = (position / screenSize + 1.) / 2.;\n            currentProjectile.zw = direction;\n        } else if (!isCreated) {\n            currentProjectile = vec4(0.);\n        }\n\n        if (isCreated) {\n            currentProjectile.xy += currentProjectile.zw * PROJECTILE_SPEED;\n        }\n\n        outFrag = currentProjectile;\n    }\n    /*\n     * Projectile collision with asteroids\n    */\n    else if (int(fragCoord.y) == PROJECTILE_COLLISION_ROW && fragCoord.x < NUM_ASTEROIDS) {\n        outFrag = vec4(0.);\n        vec2 screenSize = texelFetch(iChannel0, ivec2(C_SCREEN_SIZE_COL, CAMERA_LAYER_ROW), 0).xy;\n        vec2 asteroidCoords = (texelFetch(iChannel0, ivec2(fragCoord.x, int(ASTEROID_LAYER_ROW)), 0).xy * 2. - 1.) * screenSize;\n        for (int i = 0; i < int(NUM_PROJECTILES); ++i) {\n            bool isCreated = texelFetch(iChannel0, ivec2(i, PROJECTILE_CREATION_ROW), 0).x > 0.;\n            if (isCreated) {\n                vec2 projectilePos = (texelFetch(iChannel0, ivec2(i, PROJECTILE_LAYER_ROW), 0).xy * 2. - 1.) * screenSize;\n\n                if (distance(projectilePos.xy, asteroidCoords) < PROJECTILE_RADIUS / 2. + ASTEROID_RADIUS\n                    && (length(projectilePos.xy) != 0. && length(asteroidCoords) != 0.)) {\n\n                    outFrag.x = 1.;\n                }\n            }\n        }\n    }\n    /*\n     * Discard all other pixels\n    */\n    else {\n        discard;\n    }\n\n    fragColor = outFrag;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* POTATO TYPE (asteroid type) */\n/* IF LOW PERFORMANCE - CHANGE TO 0 !!!!! */\n#define POTATO 1\n\n/* Layers of data in pixels - basically Y coordinates */\n#define ASTEROID_LAYER_ROW 0\n#define PLAYER_LAYER_ROW 1\n#define CAMERA_LAYER_ROW 2\n#define PROJECTILE_CREATION_ROW 3\n#define PROJECTILE_LAYER_ROW 4\n#define PROJECTILE_COLLISION_ROW 5\n\n#define P_MOVEMENT_COL 0\n#define P_ROTATION_COL 1\n#define P_CONTROLS_COL 2\n#define P_COLLISION_COL 3\n\n#define C_OPTIONS_COL 0\n#define C_SCREEN_SIZE_COL 1\n\n\n/* Asteroid properties */\n#define NUM_ASTEROIDS 5.\n#define ASTEROID_SPEED 0.007\n#define ASTEROID_RADIUS 1.\n\n\n/* keyboard keys values*/\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n\n#define KEY_E     69\n#define KEY_SPACE 32\n\n\n/* Projectiles properties */\n#define NUM_PROJECTILES 1.\n#define PROJECTILE_SPEED .0125\n#define PROJECTILE_RADIUS .7\n\n/* Player Properties */\n#define PLAYER_HEIGHT 1.5\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define PI 3.14159\n\n#define ASTEROID_LAYER_ROW 0\n#define PLAYER_LAYER_ROW 1\n\n#define P_MOVEMENT_COL 0\n#define P_ROTATION_COL 1\n\n#define ASTEROID_DIST 5.\n#define SCALE 10.\n\n\n#define speed 3.5\n#define maxInertia .07\n#define acceleration 0.008\n\n\n#define MAX_STEPS_PRECOMPUTE 512\nconst float precompute_dt_divisor = 10.;\n\n\nconst float dt = 0.15;\n\nconst vec3 PLAYER_COLOR_3 = vec3(0.313, 0.784, 0.47);\nconst vec3 PLAYER_COLOR_2 = vec3(1., 0.7215, 0.4235);\nconst vec3 PLAYER_COLOR_1 = vec3(1., 0.3333, 0.3333);\n\nconst vec3 ASTEROID_COLOR = vec3(0.54, 0.52, 0.45);\n\nconst vec3 BH_pos = vec3(-.5, 2.5, -5.);\nconst float BH_R = 1.;                     // event horizon radius\n\nconst float ray_dt_divisor = 1.;\n\n\n\n\n/*\n* Rotate object in one plane:\n* use obj.xy *= Rotate(val);\n* to rotate the object by some value on the xy plane\n*/\nmat2 Rotate(float val) {\n    float s = sin(val);\n    float c = cos(val );\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotateOffset(float rotate, float x, float y){\n    mat3 rotateMat;\n    float s = sin(rotate);\n    float c = cos(rotate);\n    rotateMat[0] = vec3(c, -s, -x*c+y*s+x);\n    rotateMat[1] = vec3(s, c, -x*s-y*c+y);\n    rotateMat[2] = vec3(0., 0., 1.);\n    return rotateMat;\n}\n\nmat3 Translate3(float x, float y){\n    mat3 translateMat;\n    translateMat[0] = vec3(1., 0., x);\n    translateMat[1] = vec3(0., 1., y);\n    translateMat[2] = vec3(0., 0., 1.);\n    return translateMat;\n}\n\n\n\n/* A Capsule has position of the top and bottom spheres and their radius */\nstruct Capsule {\n    vec3 top;\n    vec3 bot;\n    float rad;\n};\n\n/* A Cylinder is the same as Capsule but the algorithms are different */\nstruct Cylinder {\n    vec3 top;\n    vec3 bot;\n    float rad;\n};\n\n/* A Torus has a main radius and the thickness of the tube and position */\nstruct Torus {\n    float radBig;\n    float radSmol;\n    vec3 pos;\n};\n\n/*\n* A box has width height and depth(all calculated from center to sides)\n* and position\n*/\nstruct Box {\n    // width, height, depth can be put in a vec3\n    float wid;\n    float hig;\n    float dep;\n    vec3 pos;\n};\n\n/*\n * A fucking sphere, idk\n*/\nstruct Sphere {\n    vec3 pos;\n\tfloat rad;\n};\n\n\nstruct Piramid {\n    vec3 pos;\n    float height;\n};\n\n\n\n\n\n\n/*\n * Get the min distance vec4 from vec4(rgb, dist)\n*/\nvec4 minSd(vec4 first, vec4 second) {\n    return first.w < second.w? first : second;\n}\n//-----------------------------------------------------------------------------\n/*\n * Distance functions -> give us the distanсe to said object type\n * NEGATIVE return on the inside and POSITIVE on the outside\n * * vec3 point: origin point - the position you want your object to be at\n * * Object: obj to find distance to\n */\n\n/* Get distance to the Box and put it in proper position */\nfloat sdBox(vec3 point, Box box) {\n    /// By default the scale is inversed\n\n    point = abs(point) - vec3(box.wid, box.hig, box.dep);\n    /// Account for inner position for there not to be distorted black dots\n    return (length(max(point, 0.)) + min(max(point.x, max(point.y, point.z)), 0.));\n}\n\nfloat sdRoundBox( vec3 p, Box box, float r )\n{\n    vec3 d = abs(p) - vec3(box.wid, box.hig, box.dep);\n    return min(max(d.x,max(d.y,d.z)), 0.0) + length(max(d,0.0)) - r;\n}\n\n\n/* Get distance to the Torus and put it in proper position */\nfloat getDistTorus(vec3 point, Torus tor) {\n    /// Projected distance to the outside layer of a torus\n    float projDistToOut = length(point.xz) - tor.radBig;\n    return length(vec2(projDistToOut, point.y)) - tor.radSmol;\n}\n\n/* Get distance to the Capsule */\nfloat sdCapsule(vec3 point, Capsule cap) {\n    vec3 edge = cap.bot - cap.top;\n    vec3 distToCapsule = point - cap.top;\n\n    float distToHit = dot(edge, distToCapsule) / dot(edge, edge);\n    distToHit = clamp(distToHit, 0., 1.);\n\n    vec3 pointHit = cap.top + distToHit*edge;\n    return length(point - pointHit) - cap.rad;\n}\n\n/* Get distance to the Cylinder */\nfloat sdCylinder(vec3 point, Cylinder cap) {\n    vec3 edge = cap.bot - cap.top;\n    vec3 distToSide = point - cap.top;\n\n    float distToHit = dot(edge, distToSide) / dot(edge, edge);\n    // distToHit = clamp(distToHit, 0., 1.);\n\n    vec3 pointHit = cap.top + distToHit*edge;\n    // X-axis dist to cylinder\n    float xDist = length(point - pointHit) - cap.rad;\n    float yDist = (abs(distToHit - .5) - .5) * length(edge);\n\n    float exteriorDist = length(max(vec2(xDist, yDist), 0.));\n    float interiorDist = min(max(xDist, yDist), 0.);\n    return exteriorDist + interiorDist;\n}\n\n/* Get distance to the Sphere - The fastest! */\nfloat sdSphere(vec3 point, Sphere sphere) {\n    return length(point) - sphere.rad;\n}\n\nfloat sdSmoothUnion(float d1, float d2) {\n    float k = 0.25;\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n// Yeah, right, this somehow works\nfloat sdAsteroid(vec3 point, Sphere sphere, int astrIdx) {\n    float boxDecreaseRad = 2.1 + float(astrIdx) * 0.1;\n\n    Box b1 = Box(sphere.rad / boxDecreaseRad, sphere.rad / boxDecreaseRad, sphere.rad / boxDecreaseRad, vec3(0.0, 0.0, 0.0));\n\n    vec3 boxPos = point - b1.pos;\n\n    boxPos.xz *= Rotate(PI / 4.0);\n    boxPos.yz *= Rotate(PI / 4.0);\n\n    Box b2 = Box(sphere.rad / boxDecreaseRad, sphere.rad / boxDecreaseRad, sphere.rad / boxDecreaseRad, vec3(0.0, 0.0, 0.0));\n    return sdSmoothUnion(sdRoundBox(point, b2, 0.4 + 0.5 * float(astrIdx) * 0.1),\n        sdRoundBox(boxPos, b1, 0.4 + 0.5 * float(astrIdx) * 0.1));\n}\n\n/* Get distance to the Plane */\nfloat sdPlane(vec3 point, vec3 plane) {\n    return dot(point, normalize(plane));\n}\n\n/*\n * Get distance to the Piramid - for now used only in player creation\n * Code \"borrowed\" from https://www.shadertoy.com/view/Ntd3DX\n */\nfloat sdPyramid(vec3 position, float halfWidth, float halfDepth, float halfHeight) {\n    position.xz = abs(position.xz);\n\n    // bottom\n    float s1 = abs(position.y) - halfHeight;\n    vec3 base = vec3(max(position.x - halfWidth, 0.0), abs(position.y + halfHeight), max(position.z - halfDepth, 0.0));\n    float d1 = dot(base, base);\n\n    vec3 q = position - vec3(halfWidth, -halfHeight, halfDepth);\n    vec3 end = vec3(-halfWidth, 2.0 * halfHeight, -halfDepth);\n    vec3 segment = q - end * clamp(dot(q, end) / dot(end, end), 0.0, 1.0);\n    float d = dot(segment, segment);\n\n    // side\n    vec3 normal1 = vec3(end.y, -end.x, 0.0);\n    float s2 = dot(q.xy, normal1.xy);\n    float d2 = d;\n    if (dot(q.xy, -end.xy) < 0.0 && dot(q, cross(normal1, end)) < 0.0) {\n        d2 = s2 * s2 / dot(normal1.xy, normal1.xy);\n    }\n    // front/back\n    vec3 normal2 = vec3(0.0, -end.z, end.y);\n    float s3 = dot(q.yz, normal2.yz);\n    float d3 = d;\n    if (dot(q.yz, -end.yz) < 0.0 && dot(q, cross(normal2, -end)) < 0.0) {\n        d3 = s3 * s3 / dot(normal2.yz, normal2.yz);\n    }\n    return sqrt(min(min(d1, d2), d3)) * sign(max(max(s1, s2), s3));\n}\n\n\nvec3 getRo(vec4 camera_props) {\n    vec3 ro = vec3(-camera_props.x, camera_props.y, camera_props.z);\n    ro.xz *= Rotate(PI);\n    return ro;\n}\n\n// lookat - central point of the camera\n// zoom - zoom  ==  distance from camera to the screen\n// c - center point on the screen = ro + forward * zoom factor z\n// ro = ray origin\n// right - if we look straight from the camera on screen, it is x offset\n// up - if we look straight from the camera on screen, it is y offset\n// intersection - the point on the screen where ray passes through it\nvec3 getRd(vec2 uv, vec3 ro, vec4 camera_props) {\n    // variables to control camera if we need it\n    vec3 lookat = vec3(camera_props.xy, 0.);\n    float zoom = camera_props.w;\n\n    vec3 forward = normalize(lookat - ro),\n        right = normalize(cross(vec3(0, 1, 0), forward)),\n        up = cross(forward, right),\n        c = ro + forward * zoom,\n        intersection = c + uv.x * right + uv.y * up,\n        d = normalize(intersection - ro);\n    return d;\n}\n\n\n\nvec3 blackHoleNullParticleAccl(vec3 p) {\n    vec3 r = (p - BH_pos);\n    return 10. * -1.5 * BH_R * r / pow(length(r), 5.0);\n}\n\nfloat heightprecompute(inout vec3 current_position, inout vec3 ray_velocity, float aim_height) {\n    // mode is whether we reached height 1 (1.) or got below event horison (0.)\n    // or did not converge (2.)\n    float mode = 2.;\n    float precompute_dt = dt / precompute_dt_divisor;\n    for (int i = 0; i < MAX_STEPS_PRECOMPUTE * int(precompute_dt_divisor); ++i) {\n        float dist = abs(current_position.z - aim_height);\n\n        ray_velocity += blackHoleNullParticleAccl(current_position) * precompute_dt;\n\n        vec3 position_delta = ray_velocity * precompute_dt;\n        float dist_to_travel = length(position_delta);\n        if (dist_to_travel > dist) {\n            position_delta *= dist / dist_to_travel;\n        }\n        current_position += position_delta;\n\n        // check that we got below event horizon\n        if (distance(BH_pos, current_position) < BH_R) {\n            mode = 0.;\n            break;\n        }\n\n        // check that we landed on a plane\n        if (abs(dist) < SURF_DIST) {\n            ray_velocity = ray_velocity;\n            mode = 1.;\n            break;\n        }\n    }\n    return mode;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n        // TODO: I couldn't use the data channel for some reason.\n        // texelFetch(iChannel0, ...) works if we #include <player.glsl>, but\n        // then texelFetch(iChannel1, ...) doesn't work. Since camera position\n        // is a constant currently, I just pasted it here for a temporary fix\n        vec4 camera_props = vec4(0., 0., 20., 0.5);// texelFetch(iChannel0, ivec2(C_OPTIONS_COL, CAMERA_LAYER_ROW), 0);\n        vec3 position = getRo(camera_props);\n        vec3 velocity = getRd(uv, position, camera_props);\n        float mode = heightprecompute(position, velocity, -1.);\n        if (mode == 0.) {\n            fragColor = vec4(0.);\n        } else {\n            /// put velocity if fragCoord.x is divisible by 2\n            float flooredfragCoordx = floor(fragCoord.x);  // remove possible .5\n            if ((flooredfragCoordx-2.*floor(flooredfragCoordx/2.)) == 0.) {\n                fragColor = vec4(velocity, mode);\n            } else {\n                fragColor = vec4(position, mode);\n            }\n        }\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/// returns 0 when fetch is at border of black hole reached\nfloat fetchPrecomputed(vec2 fragCoord, inout vec3 position, inout vec3 velocity) {\n    /// interpolate position and velocity\n    vec2 flooredfragCoord = floor(fragCoord);  // remove possible .5\n    vec4 currentPositionAndMode = vec4(0.);\n    vec4 rayVelocityAndMode = vec4(0.);\n    float mode = 1.;\n    if (\n        flooredfragCoord.x <= 1. || flooredfragCoord.y <= 0. ||\n        flooredfragCoord.x >= (iResolution.x-1.) || flooredfragCoord.y >= (iResolution.y-1.)\n    ) {\n        return 0.;  /// we are at border, so inteprpolation is not possible\n    } else {\n        bool is_velocity = (flooredfragCoord.x-2.*floor(flooredfragCoord.x/2.)) == 0.;\n        if (is_velocity) {\n            rayVelocityAndMode = texelFetch(iChannel1, ivec2(flooredfragCoord), 0);\n            mode = rayVelocityAndMode.w;\n            currentPositionAndMode = (\n                texelFetch(iChannel1, ivec2(flooredfragCoord-vec2(1., 0.)), 0) * .5 +\n                texelFetch(iChannel1, ivec2(flooredfragCoord+vec2(1., 0.)), 0) * .5\n            );\n        } else {\n            currentPositionAndMode = texelFetch(iChannel1, ivec2(flooredfragCoord), 0);\n            mode = currentPositionAndMode.w;\n            rayVelocityAndMode = (\n                texelFetch(iChannel1, ivec2(flooredfragCoord-vec2(1., 0.)), 0) * .5 +\n                texelFetch(iChannel1, ivec2(flooredfragCoord+vec2(1., 0.)), 0) * .5\n            );\n        }\n        /// if we reached black hole in any of them, return 0\n        if ((rayVelocityAndMode.w + currentPositionAndMode.w) < 2.) {\n            return 0.;\n        }\n    }\n    position = currentPositionAndMode.xyz;\n    velocity = rayVelocityAndMode.xyz;\n    return mode;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n        vec3 position = vec3(0.);\n        vec3 velocity = vec3(0.);\n        float mode = fetchPrecomputed(fragCoord, position, velocity);\n        if (mode == 0.) {\n            fragColor = vec4(0.);\n        } else {\n            mode = heightprecompute(position, velocity, 1.02);\n            if (mode == 0.) {\n                fragColor = vec4(0.);\n            } else {\n                mode = heightprecompute(position, velocity, 1.);\n                if (mode == 0.) {\n                    fragColor = vec4(0.);\n                } else {\n                    /// put velocity if fragCoord.x is divisible by 2\n                    float flooredfragCoordx = floor(fragCoord.x);  // remove possible .5\n                    if ((flooredfragCoordx-2.*floor(flooredfragCoordx/2.)) == 0.) {\n                        fragColor = vec4(velocity, mode);\n                    } else {\n                        fragColor = vec4(position, mode);\n                    }\n                }\n            }\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}