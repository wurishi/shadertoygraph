{"ver":"0.1","info":{"id":"wsVBRm","date":"1606845477","viewed":283,"name":"Pencil sketched Voronoi","username":"Serge55","description":"Generated pencil sketch pattern applied to Voronoi tesselation","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pencil sketched Voronoi\n\n// Voronoi tesselation implementation borrowed from Inigo Quilez\n// https://www.shadertoy.com/view/ldl3W8\n// Pencil sketch borrowed from Shane \n// https://www.shadertoy.com/view/3dtBWX\n// \n// Modifications were made to assign color and some kind of \n// identificator to each cell so they could be textured differently\n//\n// Look and feel inspired by my daughter's drawings\n\n#define ANIMATE\n#define PI 3.14159265\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\nvec3 pencil(in vec3 col, in vec2 p, in float a){\n    //Borrowed from Shane https://www.shadertoy.com/view/3dtBWX\n    //Modified strokes to be more directional\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    float ang = a * 2.73543 * PI;\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(ang);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*16.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    ang += PI * 0.2;\n    q *= rot2(ang);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*4.*sc)*.34);\n    ns2 = gr - ns2;\n    ang += PI * 0.1;\n    q *= rot2(ang);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    //ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n\nvec4 voronoi( in vec2 x )\n{\n    // borrowed from IQ\n    // modified to return index into color wheel \n    // and cell identifier to apply cell specific texture\n    \n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    float col = 0.5;\n    vec2 globg;\n    float t = iTime * 0.5;\n    t = 0.;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin(iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            col = o.x;\n            globg = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, globg, col);\n}\n\nfloat rootstep(in float A, in float B, in float t) {\n    return A + sqrt(sqrt(t)) * (B - A);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - iResolution.xy * 0.5)/iResolution.xx;\n\n    vec4 c = voronoi( 7.0*p );\n    \n    float q = 0.69;\n\n    //rainbow pastel colors\n    vec3 rnbCol = q + (1. - q)*cos(2. * PI *c.w + vec3(0, 1, 2)*1.5);\n\n    vec3 col;\n    col = sqrt(rnbCol);\n    col = mix(rnbCol *.9, col, rootstep(0., 1., c.x));\n    \n    // pencil pattern\n    col = clamp((0.8 + 0.3 * pencil(col,p * 12., 0.53141 * c.y + c.z)) * col, 0., 1.);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}