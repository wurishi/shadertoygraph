{"ver":"0.1","info":{"id":"ctS3Dt","date":"1674085710","viewed":182,"name":"ChatGPT Raymarching scene 1","username":"Patan77","description":"Raymarching generated using chatGPT","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ai","chatgpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Generated using openAI ChatGPT, using mutiple steps of prompts + some manual code fixes.\n// Prompt #1 > Create shadertoy code of a basic 3D raymarching shader\n// Prompt #2 > also add a ground plane for the scene\n// Prompt #3 > also add a ambient light\n// Prompt #4 > create a sky colored gradient for the background environment \n// Prompt #5 > Animate the sphere \n// Prompt #6 > make the sphere reflective \n// Prompt #7 > how would I create a SDF of a infinite number of spheres\n// Prompt #8 > how would I make it so the spheres have different animation motions for each other \n\n\nvec3 lightDirection = normalize(vec3(10.0, 8.0, -8.0));\nvec3 ambientColor = vec3(0.25, 0.35, 0.5);\nvec3 skyColorTop = vec3(0.5, 0.7, 1.0);\nvec3 skyColorBottom = vec3(1.0, 1.0, 1.0);\nfloat sphereRefractiveIndex = 2.0;\n\nint quality = 100; \n\nfloat fresnel(vec3 ray, vec3 normal, float refractiveIndex)\n{\n    float cosi = dot(normal, ray);\n    float etai = 1.0;\n    float etat = refractiveIndex;\n    if (cosi > 0.0) \n    {\n    // swap\n        float etaiCopy = etai;\n        etai = etat;\n        etat = etaiCopy;\n    }\n    float sint = etai/etat * sqrt(max(0.0, 1.0 - cosi*cosi));\n    if (sint >= 1.0) {\n        return 1.0;\n    } else {\n        float cost = sqrt(max(0.0, 1.0 - sint*sint));\n        cosi = abs(cosi);\n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n        return (Rs * Rs + Rp * Rp) / 2.0;\n    }\n}\n\n\n\n\nfloat scene(vec3 pos)\n{\n    float sphere = 1.0;\n    float radius = 0.5;\n    int n = 2;\n    for (int x = -n; x <= n; x++) {\n        for (int y = -n; y <= n; y++) {\n            for (int z = -n; z <= n; z++) {\n                vec3 offset = vec3(x, y, z) * 1.2 + vec3(1,1,0);\n                vec3 spherePos = offset + vec3(\n                sin(offset.x + iTime * 0.5) * cos(offset.y + iTime * 3.0) * 0.3,\n                cos(offset.y + iTime * 0.8) * sin(offset.z + iTime * 3.0) * 0.3,\n                sin(offset.z + iTime * 1.2) * cos(offset.x + iTime * 3.0) * 0.3);\n                sphere = min(sphere, length(pos - spherePos) - radius);\n            }\n        }\n    }\n    \n      // ground plane SDF\n    float plane = pos.y + 1.0;\n    \n        // combine the sphere and plane SDFs\n    return min(sphere, plane);\n\n}\n\n\n\n\n\nvec3 getNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        scene(pos + eps.xyy) - scene(pos - eps.xyy),\n        scene(pos + eps.yxy) - scene(pos - eps.yxy),\n        scene(pos + eps.yyx) - scene(pos - eps.yyx));\n    return normalize(nor);\n}\n\n\n\nfloat getAmbientOcclusion(vec3 pos, vec3 norm)\n{\n    float occlusion = 0.0;\n    float samples = 5.0;\n    float scale = 1.0;\n    for(float i = 0.0; i < samples; i++)\n    {\n        vec3 samplePos = pos + norm * (cos(i/samples * 3.14159265359 * 2.0) * scale);\n        float dist = scene(samplePos);\n        occlusion += (0.5 - dist) / samples;\n    }\n    return occlusion;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy / iResolution.y) * 2.0 - 1.0;\n    vec3 ray = normalize(vec3(p, 1.0));\n    vec3 pos = vec3(0.0, 0.0, -5.0);\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < quality; i++)\n    {\n        d = scene(pos + ray * t);\n        if(d < 0.001) break;\n        t += d;\n    }\n    if(d < 1.0) \n    {\n        vec3 normal = normalize(getNormal(pos + ray * t));\n        float light = dot(lightDirection, normal) * 0.5;\n        float occlusion = getAmbientOcclusion(pos + ray * t, normal);\n        \n        // calculate reflection\n        float fresnelTerm = fresnel(ray, normal, sphereRefractiveIndex);\n        vec3 reflectionDirection = reflect(ray, normal);\n        vec3 reflectionColor = texture(iChannel0, reflectionDirection).rgb;\n\n        vec3 diffuse = (ambientColor + light) * (1.5 - occlusion);\n        vec3 reflection = reflectionColor * fresnelTerm;\n       \n        fragColor = vec4( diffuse + reflection ,1.0);\n\n    }\n    else\n    {\n        vec3 color = mix(skyColorBottom, skyColorTop, ray.y + 1.0);\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}