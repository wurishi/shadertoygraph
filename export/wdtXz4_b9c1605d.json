{"ver":"0.1","info":{"id":"wdtXz4","date":"1571607678","viewed":656,"name":"ShaderTober - Sling","username":"Flopine","description":"A small doodle with inktober's theme \"Sling\". \nAlso my participation in the third fanzine from the Cookie Collective :) <3","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","anaglyph","inktober","cookiefanzine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// fix image for fanzine\n//#define dt 19.6\n\n#define dt (iTime*5.)\n#define PI 3.141592\n#define ITER 120.\n\nfloat hash11 (float x)\n{return fract(sin(x)*1245.5);}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.45,23.5)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n} \n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat twist (vec3 p, float w)\n{\n    p.xz *= rot(p.y*0.8);\n    moda(p.xz,7.);\n    p.x -= w*2.;\n    return cyl(p.xz, w);\n}\n\nfloat twists (vec3 p, float w)\n{\n    float per = 7.;\n    float id = floor(p.y/per);\n\tif (mod(id,2.) == 0.) p.xz *= rot(PI/6.);\n    p.y = mod(p.y, per)-per*0.5;\n    \n    p.y += sin(p.x+iTime)*0.5;\n    p.x += cos(p.z+iTime)*0.4;\n    p.xy *= rot(PI/2.);\n    moda(p.yz, 6.);\n    return twist(p, w);\n}\n\nfloat room (vec3 p)\n{return -sdHexPrism(p.xzy, vec2(15.,1e10));}\n\nfloat SDF (vec3 p)\n{\n    return min(smin(twist(p,0.5),twists(p,0.2),0.8),max(-twists(p, 1.),room(p)));\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 forward = normalize(target - ro);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross (forward, left));\n    return normalize(forward*fov+ left*uv.x + up*uv.y);\n}\n\nfloat raymarch (vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 p = ro;\n    float dither = hash21(uv);\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            float shad = i/ITER;\n            return 1.-shad;\n        }\n        d *= 0.7+dither*0.1;\n        p += d*rd;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n \n    vec3 ro = vec3(3.,-4.+dt,-10.),\n        p = ro,\n        tar = vec3(0., dt, 0.),\n        rd = get_cam(ro, tar, uv, 1.),\n        col = vec3(0.);\n    \n    // anaglyph technique from leon/ponk \n    float red  = raymarch(ro-vec3(.2,0.,0.),rd,uv);\n    float cyan = raymarch(ro+vec3(.2,0.,0.),rd,uv);\n    \n    col = vec3(red,vec2(cyan));\n\n    fragColor = vec4(pow(col,vec3(2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}