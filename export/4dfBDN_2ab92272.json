{"ver":"0.1","info":{"id":"4dfBDN","date":"1496158032","viewed":209,"name":"0x576861743f","username":"slerpy","description":"Those are some cubes, which are stuck inside each other while rotating independently from each other, with a glitched background and an interesting screen effect...\n\nYeah...","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube","wtf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318530718\n\n#define FAR 32.\n#define ITER 128\n#define QUA .001\n\n#define NORK 5e-4\n#define SMNK 1.\n\n#define GRDW 2.\n#define CDIST 8.\n#define NCBS 3\n\n///// Utility\n\nfloat rand(vec2 co){\n    return cos(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat3 rx(float a){ float sa = sin(a), ca = cos(a); return mat3(1.,0.,0.,0.,ca,sa,0.,-sa,ca); }\nmat3 ry(float a){ float sa = sin(a), ca = cos(a); return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca); }\nmat3 rz(float a){ float sa = sin(a), ca = cos(a); return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.); }\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\n///// Map\n\nfloat randBox(vec3 p, float seed)\n{\n    vec3 axis = vec3(rand(vec2(seed,1.)),rand(vec2(seed,2.)),rand(vec2(seed,3.)));\n    float ctime = .5 * rand(vec2(seed,4.)) * iTime + rand(vec2(seed,5.));\n    p = abs(p*rx(axis.x*ctime)*ry(axis.y*ctime)*rz(axis.z*ctime));\n    return max(max(p.x,p.y),p.z) - 1.0;\n}\n\nfloat map(vec3 p)\n{\n    float d = FAR;\n    for (int i=0; i<NCBS; i++)\n    \td = smin(d, randBox(p, float(i)), SMNK);\n\treturn d;\n}\n\n///// Rendering\n\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p);\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tm - map(p - e.yxx),\n\t\tm - map(p - e.xyx),\n\t\tm - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t || t > FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n///// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    bool alt = fract(fragCoord.y / GRDW) < .5;\n    if (alt) uv.x = -uv.x;\n    \n\tvec3 ro = vec3(vec2(0.), -CDIST);\n    vec3 rd = normalize(vec3(uv,2));\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n    \n\tvec3 sn = normal(sp,NORK);\n    vec3 ld = normalize(vec3(vec2(1.),-2.));\n\tfloat a = dot(sn,ld);\n    \n    vec3 col = vec3(1.);\n    col *= (1.+a)/2.;\n    col -= .5 * pow(t/FAR, 3.);\n    \n    if (t < FAR) col.r = alt ? 1.0 : 0.0;\n    \n\tfragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}