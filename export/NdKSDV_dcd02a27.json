{"ver":"0.1","info":{"id":"NdKSDV","date":"1636379225","viewed":120,"name":"Gaussian Weierstrass Piecewise","username":"spalmer","description":"Applying a gaussian filter to a piecewise linear function.  Based on oneshade's toy.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["filter","antialias","1d","graph","plot","linear","gaussian","golf","segments","piecewise","weierstrass"],"hasliked":0,"parentid":"NdKSWV","parentname":"Gaussian Filtered Segments"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Weierstrass transform (https://en.wikipedia.org/wiki/Weierstrass_transform)\n// of piecewise linear function\n// filter by summing S for each segment\n\n// original was 864 characters, is now 825.\n// but I guess I've made progress!\n\n// save a few ch\n#define R float\n#define V vec2\n\n// oneshade's error function approximation\nR erf(R x)\n{\n    return sign(x) * sqrt(1. - exp2(-1.787776 * x * x));\n}\n\n// an integration.\n// the Weierstrass transform?\n// Gaussian filtered segment\nR S(R x, V A, V B, R w) \n{\n    const R k = sqrt(1. / acos(-1.));\n    R h = B.x - A.x // one of two interleaved terms\n    , m = k * w * (B.y - A.y) / h // variance?\n    , v = mix(A.y, B.y, (x - A.x) / h) // where on segment vertically by linear interpolation?\n    , a = (x - A.x) / w\n    , b = (x - B.x) / w;\n    return (\n        (erf(a) - erf(b)) * v +\n        (exp(-a * a) - exp(-b * b)) * m\n        ) * .5;\n}\n// unsure have actually improved it, perhaps easier to read.\n// Someone who is actually well trained in calculus\n// shall have to take it from here.  My brain hurts!\n\nR F(R x, R w)\n{\n    // example from Wikipedia\n    return (S(x, V(-5, 1), V( 0, 1), w)\n          + S(x, V( 0, 1), V( 5,-1), w)) * 4.25;\n}\n    // example animated wave, may work better with w fixed\n//#define P(i) vec2(10. * (i) - 5., cos(iTime + 6. * (i)))\n//    float z = 0.; float nr = 1./6.; vec2 p1 = P(1.), p2; //vec2(5., 0.);\n//    for (float i = 1.; (i -= nr) >= 0.; p1 = p2)\n//        z += S(x, p1, p2 = P(i), w);\n//    return z;\n\n\nvoid mainImage(out vec4 o, V q) \n{\n    V r = iResolution.xy;\n    R u = 10. / r.y;\n    q = (q - .5 * r) * u;\n    R w = mix(2.5005, 5., -cos(.5 * iTime)) //mix(.001, 5., .5 - .5 * cos(.5 * iTime)) // Filter width\n    , y = F(q.x, w)\n    , d = dFdx(y);\n    o = vec4(sqrt(abs(q.y - y) / sqrt(u * u + d * d))); // antialias plot, gamma\n}\n\n\n// oneshade's erf is top-notch.\n// missing a 2/sqrt(pi) factor mentioned on Wikipedia\n// but is VERY close to true value at 1.0;\n// I failed to improve it.\n\n// Wolfram Alpha uses Gamma to compute erf, and says erf(1.0) = .84270079\n\n// btw the slope of erf at zero is 2/sqrt(pi) or about 1.1283792\n// but if you match the slope there, will be worse approx elsewhere.\n\n\n// Maxima says\n// (%i)\tintegrate(e^(-x*x), x);\n// (%o)\t(sqrt(%pi)*erf(sqrt(log(e))*x))/(2*sqrt(log(e)))\n// (%i)\tintegrate(e^(-x*x), x, 0, z);\n// (%o)\t(sqrt(%pi)*erf(sqrt(log(e))*z))/(2*sqrt(log(e)))\n// once you grok erf, please let me know!\n// https://en.wikipedia.org/wiki/Error_function\n\n// closely related to  normal cumulative distribution function\n\n\n// How was S derived from what Wikipedia says about Weierstrass?\n// Had a 2/sqrt(pi) factor.\n// Guess they divided entire equation \n// by 2/sqrt(pi) and got sqrt(pi)/2\n// where the /2 factored out completely\n\n\n// these two can easily be inlined TODO\n// FIXME precise sqrt(1/pi) is wordy\n//, v = sqrt(1./acos(-1.)) * w //1./sqrt(acos(-1.)) * w // w/sqrt(pi) = .56418958354*w\n//, slope = (B.y - A.y) / bx;\n //* slope * v\n\n//, dY = (F(q.x + .001, w) - y) / .001 // dydx derivative of F at q.x, approximately dx*u\n//, dw = fwidth(y)\n//, dy = dFdy(y) // *should* be approximately dY * u or dY / r.y or something\n//, dx = dFdx(y) // approximately dY * u\n\n// this antialiasing method is superb!  sure beats what I was using prior.\n// trying to grok why circularizing works for AA... sin to cos\n// I guess it makes some sense; like rotating the line flat!\n// but why can't I express it in terms of dFdx or dFdy?\n//, aa = // antialiasing\n    //1./u // only handles flat parts\n    //1. / u / sqrt(1. + dY * dY) // perfect!\n    //1. / u / sqrt(1. + dx * dx / u / u) // imperfect! damn close\n    //1. / sqrt(u * u + dx * dx) // optimized?  Cool!!\n    //1. / length(vec2(u,      dx)) // longer :(\n    //inversesqrt(1. + dY * dY) / u // bit longer\n    //pow(abs(dY), -2.) / u\n    //1. / abs(dy + 1.001)\n    //1. / u / abs(dy*dy + 1.001)\n    //10. / sqrt(dy*dy+.1)\n    //1. / sqrt(dx*dx+1e-3)\n    //2./(abs(dx) + .1)\n    //pow(abs(dy), -2.)\n    //.5 / (abs(dx) + 1.01/r.y) // close-ish, has issues with even resolutions\n    //1./(dw + 1./r.y)\n    //1./sqrt(1.+dx*dx)/u\n    //1./u*(1.-1.06*abs(dx)) // close?! meh\n    //1. / sqrt(dw*dw+.00010001)\n//, d = abs(q.y - y) * aa\n\n//o = vec4(.5 + .5 * (dx/u - dY)); // debugging\n\n// see also https://desmos.com/calculator/mfzpsbbyqn","name":"Image","description":"","type":"image"}]}