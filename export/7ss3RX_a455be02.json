{"ver":"0.1","info":{"id":"7ss3RX","date":"1616401052","viewed":374,"name":"wiggle functions","username":"pronce","description":"just a few nice handy wiggle functions for animation and procedural content creation. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["animation","wiggle","toolbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  \n    hey, just adding a few nice wiggle operators that come in super handy for animating\n    or generating stuff in shaders.  \n    \n    i really love adding toolbox functions, stay tuned for more!\n    \n    the wiggle expression is one of the most common used expression in motion graphics\n    and just produces a nice and stable curve over time without the need to integrate.\n    \n    there are 3 functions:\n    \n    green: simple wiggle function with hard edges\n      red: smooth version of the same curve\n     blue: a wiggle version with details in the curve\n     \n     parameters: \n         t is the time (basically, can be any sampling point)\n         frequency defines how often it oscillates\n         [octaves] adds details\n         \n         the amplitude is just a simple multiplication of the output value!\n         \n     the result of the function(of t) just results in a perfectly stable wiggle value\n     that you can use to animate objects for example, camera shakes, and so on\n     \n*/\n\n// pseudorandom canonical function from 'On generating random numbers, \n// with help of y= [(a+x)sin(bx)] mod 1\", W.J.J. Rey, 22nd European\n// Meeting of Statisticians and the 7th Vilnius Conference on Probability\n// Theory and Mathematical Statistics, August 1998'\n// aka the random generator everyone uses :)\n#define R(x) fract(sin(dot(x,vec2(12.9898,78.233))) * 43758.5453)\n#define PI 3.14159265\n\n// linear wiggle function\nfloat wiggle(float t, float frequency, float seed)\n{\n    t *= frequency;\n    float a = R(vec2(floor(t), seed)) * 2.0 - 1.0;\n    float b = R(vec2(ceil(t), seed)) * 2.0 - 1.0;\n    \n    t -= floor(t);\n    \n    return mix(a, b, t);\n}\n\n// linear wiggle function that allows details by increasing the octaves parameter\nfloat wiggle(float t, float frequency, int octaves, float seed)\n{\n    float w = 0.0;\n    \n    for(int i = 1; i <= octaves; i++)\n    {\n        float f = float(i * i);\n        w += wiggle(t, frequency * f, seed) / f;\n    }\n    \n    return w;\n}\n\n// smooth wiggle version, super handy!\nfloat smoothwiggle(float t, float frequency, float seed)\n{\n    t *= frequency;\n    float a = R(vec2(floor(t), seed)) * 2.0 - 1.0;\n    float b = R(vec2(ceil(t), seed)) * 2.0 - 1.0;\n    \n    t -= floor(t);\n    \n    return mix(a, b, sin(t * t * PI / 2.0)); // fake smooth blend\n}\n\nvec3 zeroline(vec2 uv, float h)\n{\n    return vec3(smoothstep(2.0 / iResolution.y, 0.0, abs(uv.y - h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // quick drawing test\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    // we sample the wiggle function at this point\n    float sampleTime = uv.x + iTime;\n    \n    // a constant value can be passed to the wiggle functions to produce unique looks\n    const float seed = 128.0;\n    \n    // the oscillation of each wiggle function can be controlled with the frequency\n    const float frequency = 10.0;\n    \n    // calculate the hard curve, this is just linear and has a rough appearance\n    vec2 hard = uv;\n    hard.y += wiggle(sampleTime, frequency, seed) * 0.1;\n    hard.y -= 0.35; // drawing offset\n    col.y = smoothstep(2.0 / iResolution.y, 0.0, abs(hard.y));\n        \n    // draw the smooth curve, this does some cheap smooth linear interpolation\n    vec2 soft = uv;\n    soft.y += smoothwiggle(sampleTime, frequency, seed) * 0.1;\n    soft.y -= 0.; // drawing offset\n    col.x = smoothstep(2.0 / iResolution.y, 0.0, abs(soft.y));\n        \n    // draw the hard curve with octaves (combination of multiple wiggles)\n    vec2 hard_oct = uv;\n    hard_oct.y += wiggle(sampleTime, frequency, 5, seed) * 0.1;\n    hard_oct.y += 0.35; // drawing offset\n    col.z = smoothstep(2.0 / iResolution.y, 0.0, abs(hard_oct.y));\n    \n    \n    // a few guides\n    col += zeroline(uv, 0.45) * 0.15;\n    col += zeroline(uv, 0.35) * 0.3;\n    col += zeroline(uv, 0.25) * 0.15;\n     \n    col += zeroline(uv, 0.1) * 0.15;\n    col += zeroline(uv, 0.0) * 0.3;\n    col += zeroline(uv, -0.1) * 0.15;\n    \n    col += zeroline(uv, -0.45) * 0.15;\n    col += zeroline(uv, -0.35) * 0.3;\n    col += zeroline(uv, -0.25) * 0.15;\n  \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}