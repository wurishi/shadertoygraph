{"ver":"0.1","info":{"id":"MtsyWM","date":"1505125444","viewed":260,"name":"Double pendulum attractor","username":"nr4","description":"This shader solves the system of nonlinear differential equations for the double pendulum with the runge-kutta-4 method.\nThe animation shows the attractor for different masses and lengths.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","chaotic","nonlinearsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Double pendulum fractal shader\n    Copyright (C) 2017  Alexander Kraus <nr4@z10.info>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n//lengths\nfloat L1 = 2.;\nfloat L2 = 1.;\n\n//masses\nfloat M1 = 3.5;\nfloat M2 = 0.1;\n\n//constants\nfloat G = 9.81;\n\n//runge kutta params\nfloat h = 1.e-1;\nfloat tmax = 3.;\n\n//math params\nfloat PI = 3.14159;\n\n/**eval system of differential equations\nparams:\ntp[0]: theta1\ntp[1]: theta2\ntp[2]: ptheta1\ntp[3]: ptheta2\n*/\nvec4 f(vec4 tp)\n{\n    float p0w = (L1*L2*(M1+M2*pow(sin(tp[0]-tp[1]),2.)));\n    float C1 = tp[2]*tp[3]*sin(tp[0]-tp[1])/p0w;\n    float C2 = (L2*L2*M2*tp[2]*tp[2]+L1*L1*(M1+M2)*tp[3]*tp[3]-L1*L2*M2*tp[2]*tp[3]*cos(tp[0]-tp[1]))*sin(2.*(tp[0]-tp[1]))/(2.*p0w*p0w);\n    \n    vec4 ret;\n    \n    ret[0] = (L2*tp[2]-L1*tp[3]*cos(tp[0]-tp[1]))/(L1*p0w);\n    ret[1] = (L1*(M1+M2)*tp[3]-L2*M2*tp[2]*cos(tp[0]-tp[1]))/(L2*M2*p0w);\n    ret[2] = -(M1+M2)*G*L1*sin(tp[0])-C1+C2;\n    ret[3] = -M2*G*L2*sin(tp[1])+C1-C2;\n    \n    return ret;    \n}\n\nvec4 step_rk4(vec4 tp)\n{\n    vec4 k1 = f(tp);\n    vec4 k2 = f(tp + h/2.*k1);\n    vec4 k3 = f(tp + h/2.*k2);\n    vec4 k4 = f(tp + h*k3);\n    return tp + h/6.*(k1+2.*k2+2.*k3+k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    M1 = 2.+1.*sin(iTime);\n    M2 = 2.+1.*cos(2.*iTime);\n    \n    L1 = 2.+.1*sin(iTime);\n    L2 = 1.+.1*cos(3.*iTime);\n    \n    vec4 state = vec4(uv*2.*PI/0.62-vec2(PI/2.,PI/2.), 0, 0);\n    float time = 0.;\n    while(time < tmax) \n    {\n        state = step_rk4(state);\n        time += h;\n    }\n    \n    /*\n    vec4 start = vec4(49./255., 255./255., 4./255., 1.);\n    vec4 end = vec4(232./255., 14./255., 18./255., 1.);\n    if(d<.5)\n        fragColor = mix(start, vec4(0.,0.,0.,1.), d);\n    else \n        fragColor = mix(vec4(0.,0.,0.,1.), end, d);*/\n    \n    \n    const int ncolors = 10;\n    vec4 color_list[ncolors] = vec4[ncolors]( vec4(1.,156./255., 19./255.,1.), vec4(232./255., 98./255., 12./255., 1.), vec4(1.,53./255., 0., 1.), vec4(232./255.,16./255.,12./255.,1.), vec4(1., 10./255., 150./255., 1.), vec4(1., 235./255., 10./255., 1.), vec4(195./255.,232./255., 12./255., 1.), vec4(97./255., 1., 0., 1.), vec4(12./255., 232./255., 25./255., 1.), vec4(13./255., 1. ,117./255., 1.) );\nfragColor = vec4(0.,0.,0.,1.0);\n    \n    if(state[1] < 20.*PI)\n    {\n        //float scale = state[1]/20.*PI;\n        float scale = state[1]/state[3]/2.*tmax;\n        vec4 start = vec4(49./255., 255./255., 4./255., 1.);\n        vec4 end = vec4(232./255., 14./255., 18./255., 1.);\n        fragColor=sin(scale)*start+cos(scale)*end;\n    }\n}\n","name":"Image","description":"","type":"image"}]}