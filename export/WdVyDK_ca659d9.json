{"ver":"0.1","info":{"id":"WdVyDK","date":"1603866122","viewed":88,"name":"Utils_BarycentricInterpolation","username":"bigt","description":"Barycentric Interpolation\n重心坐标插值","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["barycentricinterpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROTATE 1\n\nmat2 rotateZ(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nconst float PI = 3.1415926535;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c1 = vec3(1.0,0.0,0.0);// O\n    vec3 c2 = vec3(0.0,1.0,0.0);// A\n    vec3 c3 = vec3(0.0,0.0,1.0);// B\n    \n    // rotate\n    \n    //     A(p2)\n    //     /\\\n    //    /  \\\n    //   /____\\\n    // O(p1)   B(p3)\n    //vec2 O = vec2(0.25,0.2);\n    //vec2 A = vec2(0.5,0.9);\n    //vec2 B = vec2(0.7,0.3);\n    //vec2 C = uv;\n    \n    vec2 O = vec2(90.0,100.0);\n    vec2 A = vec2(230.0,180.0);\n    vec2 B = vec2(280.0,60.0);\n    vec2 C = fragCoord;\n    \n#if ROTATE == 1\n      vec2 center = (O+A+B)/3.0;\n      C = C-center;\n\t  C *= rotateZ(sin(iTime*0.5) * PI * 2.0);\n      C = C+center;\n#endif\n    \n    vec2 OA = A - O;\n    vec2 OB = B - O;\n    vec2 OC = C - O;\n    \n    vec2 AC = C - A;\n    vec2 AB = B - A;\n    \n    // 用叉乘计算平行四边形面积\n    float s = abs(OA.y*OB.x-OA.x*OB.y);// 总面积\n    float s2 = abs(OC.y*OB.x-OC.x*OB.y) / s;\n    float s3 = abs(OC.y*OA.x-OC.x*OA.y) / s;\n    //float s1 = 1.0 - s2 - s3;\n    float s1 = abs(AC.y*AB.x-AC.x*AB.y) / s;\n \n    vec3 col = c1*s1 + c2*s2 + c3*s3;\n    float t = 1.0-smoothstep(1.0, 1.02, s1+s2+s3);// 在三角形里为1\n    col *= vec3(t);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}