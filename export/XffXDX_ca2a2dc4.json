{"ver":"0.1","info":{"id":"XffXDX","date":"1705947869","viewed":69,"name":"Calc3Sphere","username":"mwolak","description":"Basic shaded sphere for calc III","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Signed distace to the surface of a sphere. If the distance is negative,\n// you're inside the sphere!\nfloat sphere_sd(in vec3 p, in vec3 center, float r){\n    return length(p - center) - r;\n}\n\n\n// specialize to one particular sphere. Centered at (0,0,2), with radius 1\nfloat world_sd(in vec3 p){\n    \n    return sphere_sd(p,vec3(0.0,0.0,2.0),1.0);\n    \n}\n\n\n// This function starts at ro, and steps in a given direction until it hits\n// something\nfloat ray_march (in vec3 ro, in vec3 rd){\n    float total_distance_traveled = 0.0; // keep track of how far we've gone\n    const int NUMBER_OF_STEPS = 512; // give up after this many steps\n    const float MIN_HIT_DIST = 0.00001; // If we get this close to something, we've basically hit it \n    const float MAX_TRACE_DIST = 1000.0; // give up if we go this far\n    vec3 curr_pos = ro; // start at the starting point\n    float sdf = 0.0; // initialize this variable\n    for(int i = 0; i < NUMBER_OF_STEPS;i++){ // one step at a time\n        vec3 curr_pos = ro + total_distance_traveled*rd; //calculate current position\n        sdf = world_sd(curr_pos); // Find the distance to the nearest surface\n        if(sdf < MIN_HIT_DIST*total_distance_traveled){ //If we've hit something\n            return total_distance_traveled; // return this distance traveled\n        }\n        if(total_distance_traveled > MAX_TRACE_DIST){ // we've gone too far!\n            return -1.0;\n        }\n        total_distance_traveled += sdf; // the closest surface is sdf units away, so we're safe to march\n    }\n    return -2.0;\n}\n\n// Calculate a unit vector pointing perpendicularly *out* from a surface\n// This is done by calculating the gradient of the SDF. Only valid if p is on a surface!\nvec3 calc_unit_normal(in vec3 p){\n// we calculate the gradient the dumbest possible way: via finite differences\n    const vec3 delta = vec3(0.0001,0.0,0.0);\n    float partial_x = world_sd(p + delta) - world_sd(p - delta);\n    float partial_y = world_sd(p + delta.yxz) - world_sd(p - delta.yxz);\n    float partial_z = world_sd(p + delta.zyx) - world_sd(p - delta.zyx);\n    vec3 normal = vec3(partial_x,partial_y,partial_z);\n    return normalize(normal); // we don't divide by delta, since we normalize anyway!\n    \n}\n\nvec3 shade_point(in vec3 p, in vec3 rd){\n    vec3 normal = calc_unit_normal(p); // surface normal to point\n    vec3 light_pos = vec3(10.0*sin(iTime/2.0),0.0,2.0 + 10.0*cos(iTime/2.0)); // light position\n    vec3 direction_to_light = normalize(light_pos - p); //unit vector pointing towards the light\n    vec3 refl_dir = rd - 2.0*dot(normal,rd)*normal; // reflect the incoming ray\n    vec3 tex = texture(iChannel0,p.xy).xyz; // Get a nice texture for the surface\n    //vec3 tex = vec3(1.0); // plain gray\n    vec3 ambient = 0.01*tex; //vec3(0.01,0.01,0.01); //ambient light\n\n    \n\n// the diffusely reflected light. Brighter if the surface is perpendicular to the light\n    vec3 diffuse = 0.8*max(0.0,dot(normal,direction_to_light))*tex;\n  \n  //these lines switch diffuse to positive = red, negative = blue\n    //vec3 diffuse = 0.8*max(0.0,dot(normal,direction_to_light))*vec3(1.0,0.0,0.0);\n    //diffuse += 0.8*max(0.0,-1.0*dot(normal,direction_to_light))*vec3(0.0,0.0,1.0);\n  \n    \n// shiny reflections. Brighter if light would reflect into the camera\n    vec3 specular = pow(max(0.0,dot(refl_dir,direction_to_light)),100.0)*tex;\n    \n    vec3 col = vec3(0.0,0.0,0.0); // initialze return variable\n    \n    col += ambient; // add in ambient light\n    col += diffuse; // add in diffuse shading\n    col += specular; // add in specular highlights\n    \n    return pow(col,vec3(0.45)); //gamma correction\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float ar = iResolution.x/iResolution.y;                                 //figure out aspect ratio\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5))*vec2(ar,1.0);      //put the screen into worldspace\n    vec3 camera_position = vec3(0.0,0.0, -0.5);\n    vec3 ro = camera_position;  // ray origin is camera position\n    vec3 rd = normalize(vec3(uv,1.0)); // calculate the direction from the camera to the pixel of the screen\n    float rm_res = ray_march(ro,rd);    // find out how far surface is in this direction\n    vec3 shaded_color = vec3(0.0,0.0,0.0); //default color\n    if(rm_res > 0.0){\n        shaded_color = shade_point(ro + rm_res*rd, rd); // color it in if we hit something\n    }\n    fragColor = vec4(shaded_color,1.0); // return this color\n}","name":"Image","description":"","type":"image"}]}