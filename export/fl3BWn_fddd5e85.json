{"ver":"0.1","info":{"id":"fl3BWn","date":"1663029170","viewed":64,"name":"Optical disillusion","username":"buddyboyb","description":"Homework assignment.\n\nIf you stare at this long enough, you might become self-aware.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n\n    //set background pattern\n    vec3 col = vec3(0.0);\n    if (mod(fragCoord.x+(iResolution.x * cos(iTime/8.0)), 32.0) - 1.0 <= 4.0 * cos(iTime) + 4.001 && mod(fragCoord.y+(iResolution.y * sin(iTime/8.0)), 32.0) - 1.0 <=  4.0 * cos(iTime) + 4.001) {\n        col = vec3(1.0);\n    }\n    \n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.001, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.001, 5));\n    vec3 eye = vec3(0, 0, -100);\n    \n    // move the light semi-randomly\n    vec3 lightDir = normalize(vec3(sin(iTime/2.0), cos(iTime/3.0),1));\n    \n       \n    for( int i = 0; i < 60; i++){\n        //calc positions from view rays\n        vec3 pos = (eye + dir * t - vec3(0.0, 1.4, 0.0))*rotateX(-0.3);\n        vec3 posdx = (eye + dirdx * tdx - vec3(0.0, 1.4, 0.0))*rotateX(-0.3);\n        vec3 posdy = (eye + dirdy * tdy - vec3(0.0, 1.4, 0.0))*rotateX(-0.3);\n        \n        // set box and cone arguments\n        vec3 dimensions = vec3(2.0, 4.0, 2.0);        \n        float height = 8.0;\n        vec2 angle = vec2(1.0, 3.9);\n        \n        //get distance from positions to object\n        float dist = min(opSmoothUnion(sdCone(pos, angle, height), sdSphere(pos, 2.2), 0.6), sdBoxFrame((pos  + vec3(0.0, 1.4, 0.0))*rotateY(iTime), dimensions, 0.25));\n        float distdx = min(opSmoothUnion(sdCone(posdx, angle, height), sdSphere(posdx, 2.2), 0.6), sdBoxFrame((posdx  + vec3(0.0, 1.4, 0.0))*rotateY(iTime), dimensions, 0.25));\n        float distdy = min(opSmoothUnion(sdCone(posdy, angle, height), sdSphere(posdy, 2.2), 0.6), sdBoxFrame((posdy  + vec3(0.0, 1.4, 0.0))*rotateY(iTime), dimensions, 0.25));\n      \n        if(dist < 0.01 && distdx < 0.01 && distdy < 0.01){\n        \n            //find vector direction slightly downward on surface\n            vec3 CA = normalize(posdy - pos);\n            \n            //find vector direction slightly to the right on the surface\n            vec3 BA = normalize(posdx - pos);\n            \n            vec3 normal = cross(CA, BA);\n            // Apply texture and shadows\n            col = texture(iChannel0, uv*4.0 - vec2(-iTime/5.0, 0)).xyz*dot(-lightDir,normal);\n            // Do the weird color thing (I don't know what is going on here, I just kept adding stuff until it looked cool)\n            col *= cross(vec3(uv.x, uv.y, 1.0), 1.5*vec3(sin(iTime)));\n            \n        }\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n    }\n    \n    // vignette/darken\n    col *= 0.8 - (abs(uv.x) + abs(uv.y));\n    \n    //noise\n    col += texture(iChannel1, 0.1*uv - vec2(0,-iTime/20.0)).ggr/3.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}