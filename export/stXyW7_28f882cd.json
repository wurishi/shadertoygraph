{"ver":"0.1","info":{"id":"stXyW7","date":"1648122586","viewed":112,"name":"Chomatic_Smiley","username":"leamlld","description":"chromatic smiley","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["eval1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"MllSWs","filepath":"https://soundcloud.com/whosdady/alice-in-wonderland-remix?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/whosdady/alice-in-wonderland-remix?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define sound (texture(iChannel1, vec2(0.001,0.25)).x)\n\n\n\n// OPERATIONS BOOLEANS \n\n\nfloat opUnion (float d1,float d2){return min (d1,d2);}\nfloat opSubstraction (float d1,float d2){return max (-d1,d2);}\nfloat opIntersection (float d1,float d2){return max (d1,d2);}\n\n\n// REPETITION\n\nvec3 opRep(in vec3 position, in vec3 amplitude)\n{\n\n    return mod(position+0.5*amplitude,amplitude)-0.5*amplitude;\n}\n\n// ROTATION \n\n\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n        0.0,                                0.0,                                0.0,                                1.0\n    );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n    return (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n}\n\n//LES FORMES\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )//vec3 offset,mat3 transform\n{\n  \n  // (p - offset) * transform;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//MATERIAUX \n\n\nvec2 opU2(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\nvec2 opSu2 (vec2 d1, vec2 d2){return max (-d1,d2);}\n\n\n\n//VIGN\nfloat vignette(vec2 uv, float radius, float smoothness) {\n\tfloat diff = radius - distance(uv, vec2(0.5, 0.5));\n\treturn smoothstep(-smoothness, smoothness, diff);\n}\n\n\n\n\n\n\nvec2 map(vec3 pos) // position 3d de la marche\n{\n\n\n    //pos= opRep(pos, vec3(2.,5.,10.));\n    //vec2 volume = 0.0;// volume du defaut nul\n    pos= rotate(pos, vec3 (0.,0.,1.) ,-80.);\n    pos= rotate(pos, vec3 (1.,0.,0.) ,sin(iTime)*0.2+0.1);\n    \n    \n    pos= opRep(pos,vec3(3.,10.,3.));\n    //pos= rotate(pos, vec3 (0.,0.,1.) ,iTime);\n    //pos.z+=sound;\n    pos.z+=sin(pos.z*1.-clamp(sound,0.49,0.5)*iTime*5.)/2.;//WIGGLE\n    pos.x+=sin(pos.z*2.+iTime*5.+clamp(sound,0.3,0.5))/6.;//WIGGLE\n    vec2 cylindre1 =vec2(sdCappedCylinder( pos, 0.9, 0.3),0.0);\n    vec2 cylindre2 =vec2( sdCappedCylinder( pos, 0.8, 0.8),0.0); //CORPS\n    \n    vec2 cylindre3 =vec2 (sdCappedCylinder( pos + vec3(-0.1,0,-0.3), 0.2, 0.3),0.0);\n    vec2 cylindre4 =vec2 (sdCappedCylinder( pos + vec3(-0.1,0,0.3), 0.2, 0.3),0.0); //YEUX\n    \n    \n    //bouche\n    pos.x+=sin(pos.z*5.+iTime*5.)*0.15;//WIGGLE\n    vec2 bouche = vec2 (sdBox (pos + vec3(0.4,0.,0.), vec3 (0.05,0.3,0.5)),0.0);\n    \n    \n    \n    vec2 volume= opU2(cylindre1,cylindre2);\n    \n    volume = opSu2(cylindre2,cylindre1);\n    \n    volume = opU2(volume,cylindre3);\n    volume = opU2(volume,cylindre4);\n    volume = opU2(volume,bouche);\n   \n    \n    return volume;\n}\n\n\n\n\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n\n\n    float c = 0.0; // contact\n    for (int i = 0; i<40;i++)\n    { // nombre de pas du ray \n        vec2 ray = map(ro+rd*c); \n        if(ray.x<(0.0001*c))// distance min = contact\n        {\n            return vec2(c,ray.y);\n        }\n        \n        c+= ray.x;\n    }\n    \n    return vec2(-1.0,0.0);\n\n}\n\n\n\nvec3 GetNormal(vec3 p )\n{\n\n    float c = map(p).x;\n    vec2 e = vec2 (0.001,0.);\n    return normalize(vec3 (map(p+ e.xyy).x,map(p+ e.yxy).x,map(p+ e.yyx).x)-c);\n\n}\n\n\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\n    \n    vec2 contact = CastRay(ro,rd); // appel du raycast\n    \n    \n    vec3 nor = GetNormal(ro+rd*contact.x);\n    vec3 col = nor; // couleur de base du pixel \n    \n    \n    //LAMBERT\n    \n    vec3 lightPos = vec3 (5.,1.,2.);\n    //lightPos*=rotateZ(iTime);\n    vec3 lightTar = vec3(1.,1.,1.);\n    vec3 lightDir= normalize(lightTar-lightPos);\n    \n    \n    vec3 ref = reflect(rd,nor);\n    vec3 cub = texture (iChannel0,ref).xyz;\n    \n    \n    float lambert=dot(nor,lightDir);\n    float blinn = pow(lambert,100.);\n    //float toon = step(lambert,.5);\n    \n    \n    \n    \n    \n    \n    \n    if (contact.x ==-1.)// sil ny a pas de contact\n    {\n    \n        col=vec3(0.)+ (abs(rd.y)*0.5);// couleur du fond\n    \n    }\n    else \n    {\n        \n        \n        if(contact.y==0.0)\n        {\n            col=vec3 (0.6,0.5,0.8);\n            col=vec3 (0.,sin(iTime)*0.1+0.1,sin(iTime)*0.2+0.2);\n            col+=cub*2.;\n        }\n         else \n         {\n            col=vec3 (0.0);\n         }\n     col*=(lambert*.8)+.5;\n     col +=blinn*20.;\n    }\n    \n    return col;   \n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = 2.* fragCoord/iResolution.xy -1.;\n    //vec2 uv = 2.* fragCoord/iResolution.xy -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    \n    \n    // parametres camera \n    \n    vec3 cameraPos = vec3(cos(iTime)-5.,0.,0.);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.);\n    \n    // vecteur de direction depuis la cam\n    \n    vec3 forward= normalize(cameraTar- cameraPos);\n    vec3 right = normalize (cross(vec3(0.,-1.,0.),forward));\n    vec3 up = normalize (cross(right,forward));\n    vec3 viewDir = normalize (uv.x* right + uv.y * up + 2. * forward);\n    \n    \n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    \n    \n    //affichage des uv \n    vec3 col = render(cameraPos,viewDir);\n    \n    vec2 postprocuv = fragCoord/iResolution.xy;\n    col*= vignette(postprocuv, 0.3, 0.3);\n    fragColor =vec4 (col,1.);\n    \n\n\n}\n\n\n","name":"Image","description":"","type":"image"}]}