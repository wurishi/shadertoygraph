{"ver":"0.1","info":{"id":"WtBXDy","date":"1566905537","viewed":117,"name":"Old Monitors","username":"paperweight86","description":"Learning about SDF and things - hence code/math mess.","likes":0,"published":1,"flags":8,"usePreview":0,"tags":["sdf","tv","monitor","vhs","tape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based off iq dist functions/primatives example https://iquilezles.org/articles/distfunctions\n\n// Performance\n#define REFLECT_MONITOR 1\n#define AA 1\n\n// Settings\n#define STATIC_CAMERA 0\n#define DEV 0\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRibbon( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a, \n         ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2(length( pa - ba*h ),h);\n}\n\nvec4 sdEllipsoid( in vec3 p, in vec3 r, in vec3 signPos ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n\n    float u =  0.5*(p.x/r.x)/(p.z/r.z)*signPos.x*signPos.z;\n    float v =  0.5*-(p.y/r.y)/(p.z/r.z)*signPos.y;\n\n    return vec4(k0*(k0-1.0)/k1, 200.0, u, v);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n   return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec4 sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, \n         ba = b-a;\n    vec3 hb = a + (ba / 2.0);\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n\treturn vec4(length( pa - ba*h ) - r, 2.0, dot(pa,pa)/dot(hb,hb), (cross(ba, pa).z));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\n\n//------------------------------------------------------------------\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 opS( vec4 d1, vec4 d2 )\n{\n\treturn (-d1.x<d2.x) ? d2 : -d1;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\nfloat box(vec3 p, vec3 pos, vec3 size)\n{\n\treturn max(max(abs(p.x-pos.x)-size.x,abs(p.y-pos.y)-size.y),abs(p.z-pos.z)-size.z);\n}\n\nvec4 sdOldMonitor(vec3 pos, vec3 signPos, float toff)\n{\n    // Scales the mirror to debug\n    const float scale = 1.0;\n    vec4 res1 = vec4( sdRoundBox( pos-vec3(0.0,0.25, 0.35), vec3(0.2,0.2,0.2), 0.02 ), 3.0, 0.0, 1.0 );\n    vec4 res = opS( vec4( sdRoundBox( pos-vec3(0.0,0.25, 0.06), scale*vec3(0.14, 0.14, 0.05), 0.05 ), 3.0, 0.0, 1.0 ), res1);\n    res.y = 3.0;\n    res = opU( res, vec4( sdEllipsoid( pos-vec3(0.0,0.25, 0.17), scale*vec3(0.15, 0.15, 0.03), signPos )) );\n    \n    // Cassette eject\n    float \tt = iTime - toff;\n    vec3 pd = vec3(0.0,0.0,0.0),\n         pc = vec3(0.0,0.0,0.0);\n    \n    if(t < 1.0)\n    {\n        pd.y = t;\n        pc.y = 0.0;\n    }\n    else if( t < 2.0 )\n    {\n        pd.y = 1.0;\n        pc.z = (t-1.0)*25.0;\n        pc.y = 1.0;\n        res = opU(res, vec4( sdRoundBox( pos-vec3(0.0,0.41 + (0.1*pc.y), 0.37 - 0.1*pc.z), vec3(0.08,0.02,0.08), 0.015 ), 2.0, 0.0, 1.0 ));\n    }\n    else if ( t < 3.0 )\n    {\n\t\tpd.y = 1.0-(t-2.0);\n        pc.y = 0.0;\n    }\n\n    if(t > 0.0 && t < 4.0)\n    {\n\t\tres = opU(res, vec4( sdRoundBox( pos-vec3(0.0,0.40 + (0.1*pd.y), 0.37), vec3(0.1,0.04,0.1), 0.01 ), 3.0, 0.0, 1.0 ));\n    \tres = opS(vec4( sdBox( pos-vec3(0.0,0.41+ (0.1*pd.y), 0.27), vec3(0.105,0.03,0.1) ), 2.0, 0.0, 1.0 ), res);\n    }\n    \n    // Tape trail\n    if(pc.y > 0.0)\n    {\n        vec3 p = pos-vec3(0.0, 0.41 + (0.1*pc.y), 0.37 - 0.1*pc.z+1.1);\n        vec3 size = vec3(0.025,0.005,1.0);\n        //p.y += 0.25*sin( 3.0*p.z + t*10.0 );\n        p.y += 0.25*sin( 3.0*p.z + t*10.0 )*(-p.z-p.z*p.z);\n        float seg = sdBox(p, size);\n        res = opU(res, vec4(seg, 2.0, 1.0, 0.0));\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nvec2  sincos( float x ) { return vec2( sin(x), cos(x) ); }\n\nvec4 map( in vec3 pos, in vec3 cam )\n{\n    vec4 res = vec4( 1e10, 0.0, 1.0, 0.0 );\n    \n    /*\n\t// TODO: Sparks\n\tfloat mt = iTime;\n    float ut = mt*TAU;\n    float dh = 1.0 - mt;\n    float bn = 0.5;\n    vec3 capPos = pos - vec3(mt, abs(cos(mt*TAU))*dh*max(((1.0-floor(mt/0.25))),bn), 1.0);\n    mt += 0.05;\n    ut = mt*TAU;\n    dh = 1.0 - mt;\n    vec3 capPos2 = pos - vec3(mt, abs(cos(mt*TAU))*dh*max(((1.0-floor(mt/0.25))),bn), 1.0);\n    vec4 capSD = sdCapsule( vec3(0.0,0.0,0.0), capPos, capPos2, 0.005 );\n    capSD.y = 201.0;\n    res = opU( capSD, res);*/\n    \n    const float num_monitors = 3.0;\n\tfloat angleY = TAU / 10.0;\n    float angleX = angleY / 2.0;\n    const float num_stacks = 2.0;\n    for(int i = 0; i < int(num_monitors * num_stacks); ++i)\n    {\n        int k = i / int(num_monitors);\n        vec3 posMon = vec3(abs(pos.x), pos.y, abs(pos.z));\n        vec3 signPos = vec3(sign(pos.x), 1.0, sign(pos.z));\n\n        float cur_angle = angleY*float((i+1)%3);\n        mat3 rotY = mat3(vec3(cos(cur_angle), 0.0, -sin(cur_angle)),\n                         vec3(0.0, \t\t  1.0, 0.0),\n                         vec3(sin(cur_angle),  0.0, cos(cur_angle) ));\n        posMon *= rotY;\n        posMon -= vec3(0.0, 0.55 + float(k)*0.5, 1.5);\n        cur_angle = angleX*float(k+1);\n        mat3 rotX = mat3(vec3(1.0, 0.0,      0.0),\n                         vec3(0.0, cos(cur_angle), -sin(cur_angle)),\n                         vec3(0.0, sin(cur_angle), cos(cur_angle) ));\n        posMon *= rotX;\n\t\t\n        vec4 mon = sdOldMonitor(posMon, signPos, float(i)*3.0);\n        if(mon.y > 199.5 && mon.y < 210.5)\n        {\n            mon.y = 200.0 + float(i);\n        }\n\t\tres = opU( mon, res);\n    }\n   \t\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0,-1.0,-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec4( tp1, 1.0, 0.0, 0.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(2.0,2.0,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec4 h = map( ro+rd*t, rd );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec4(t,h.y, h.z, h.w); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, rd ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in vec3 rd )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e, rd).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, nor ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nvec3 render( in mat3 ca, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    float matte = 0.0;\n    float didmir = 0.0;\n\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos, rd );\n        vec3 ref = reflect( rd, nor );\n        \n        vec3 ogp = pos;\n        vec3 ogr = ro;\n        vec3 ord = rd;\n        vec3 onr = nor;\n        \n\t\tvec3 scrcol = vec3(0.15, 0.15, 0.1);\n        if(m > 1.5 && m < 2.5)\n        {\n            col = vec3(0.01, 0.01, 0.01);\n            matte = 0.8;\n        }\n        else if(m > 199.5 && m < 210.5)\n        {\n            didmir = 1.0;\n            int i = 0;\n            float scrType = m - 200.0;\n\t\t\tfloat noise = texture( iChannel1, (res.zw + vec2(1.0,1.0)) / 2.0 + vec2(iTime*100.0, iTime*100.0)).x;\n            if(scrType < 0.5 && scrType > -0.5)\n            {\n                // Just plain noise (fast scrolling noise texture)\n                scrcol = vec3(noise, noise, noise);\n            }\n            else if(scrType > 0.5 && scrType < 1.5)\n            {\n                // Ad sliding around rapidly with noise interupting at regular intervals\n                float t = iTime;\n                vec2 uv = (res.zw + vec2(1.0,1.0)) / 2.0 + vec2(\n                    (cos(fract(sin(t+1560.0)))-0.5)*2.0*((sin(t*cos(t-605.0))+1.0)/2.0), \n                    (cos(fract(sin(t-150.0)))-0.5)*2.0*((sin(t*cos(t+100.0))+1.0)/2.0));\n                scrcol = texture( iChannel0, uv ).xyz;\n                float amountNoise = float(int(sin(iTime + 222.0) + 1.0 / 2.0));\n                noise = clamp(noise, 0.0 ,1.0);\n                scrcol = vec3(noise, noise, noise) * amountNoise + scrcol * (1.0-amountNoise);\n            }\n            else if(scrType > 1.5 && scrType < 2.5)\n            {\n                // Myst-y Van Dam\n                vec2 uv = (res.zw + vec2(1.0,1.0)) / 2.0;\n                vec3 vd = texture( iChannel2, uv ).xyz;\n                vec3 green = vec3(0.157, 0.576, 0.129);\n                if(   (vd.x > green.x - 0.15 && vd.x < green.x + 0.15)\n                   && (vd.y > green.y - 0.15 && vd.y < green.y + 0.15)\n                   && (vd.z > green.z - 0.15 && vd.z < green.z + 0.15))\n                {\n                   vd = vec3(noise, noise, noise);\n                }\n                float vdn = (sin(iTime)+cos(iTime*5.0+50.0) + 2.0) / 4.0;\n                vd = vd * vdn + vec3(noise, noise, noise) * (1.0-vdn);\n                float vdg = vd.x * 0.3 + vd.y * 0.39 + vd.z * 0.3;\n                scrcol = vec3(vdg, vdg, vdg);\n            }\n            else if(scrType > 2.5 && scrType < 3.5)\n            {\n                // Ad sliding with a static amount of noise on top\n                vec2 uv = (res.zw + vec2(1.0,1.0)) / 2.0 + vec2(iTime/1.2, iTime/2.0+10.0);\n                scrcol = texture( iChannel0, uv ).xyz;\n                const float amountNoise = 0.3;\n                noise = clamp(noise, 0.0 ,1.0);\n                scrcol = vec3(noise, noise, noise) * amountNoise + scrcol * (1.0-amountNoise);\n            }\n            else if(scrType > 3.5 && scrType < 4.5)\n            {                \n                // TODO: \"Room\" inside a screen\n            }\n            else if(scrType > 4.5 && scrType < 5.5)\n            {\n                // Vam Dam infront of london with vhs tracking effect\n\t\t\t\tvec2 uv = (res.zw + vec2(1.0,1.0)) / 2.0;\n                float offPos = 0.5+sin(iTime/3.0)/10.0;//0.5;//fract(iTime/3.0);\n                float offIn = floor(uv.y*50.0)/50.0;\n                float offWrp = abs(sin(clamp(offIn-offPos,0.0,0.1)*10.0*PI)/10.0);\n                float off = offWrp+offWrp*noise*8.0;\n                float noisey = texture( iChannel1, vec2(0.5,0.8) + vec2(iTime/1000.0, iTime/1000.0)).x;\n                // TODO: Better version of this where the y position changes\n                float lost = 1.0;\n                if(uv.y > 0.75)\n                {\n                \tlost = (floor(noisey+0.5));\n                }\n                \n                uv = vec2(uv.x+off, uv.y);\n                vec3 vd = texture( iChannel2, uv ).xyz;\n                vec3 green = vec3(0.157, 0.576, 0.129);\n                if(   (vd.x > green.x - 0.15 && vd.x < green.x + 0.15)\n                   && (vd.y > green.y - 0.15 && vd.y < green.y + 0.15)\n                   && (vd.z > green.z - 0.15 && vd.z < green.z + 0.15))\n                {\n                   vd = texture(iChannel3, uv).xyz;\n                }\n                float vdg = vd.x * 0.3 + vd.y * 0.39 + vd.z * 0.3;\n                scrcol = vec3(vdg, vdg, vdg) * lost;\n            }\n            // All others show as off\n            //else\n            //{\n                \n            //}\n            \n            #if REFLECT_MONITOR == 1\n            while(m > 199.5 && m < 210.5 && i++ < 1)\n            {\n                vec3 nrd = normalize(reflect(rd, nor));\n                res = castRay(pos, nrd);\n                t = res.x;\n                m = res.y;\n                ro = pos;\n                rd = nrd;\n                pos = ro + t*rd;\n                nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos, rd );\n                ref = reflect( rd, nor );\n                if(m<-0.5)\n                {\n                    col = vec3(0,0,0);\n                    //return (vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3 ) * scrcol;\n                }\n                else if(m<1.5)\n                {\n\t\t\t\t\tvec3 dpdx = vec3(0.0,0.0,0.0);\n                    vec3 dpdy = vec3(0.0,0.0,0.0);\n\n                    calcDpDxy( ro, rd, rdx, rdy, t, nor, dpdx, dpdy );\n\n                    float f = checkersGradBox( 5.0*pos.xz, 5.0*dpdx.xz, 5.0*dpdy.xz );\n                    col = 0.15 + f*vec3(0.05);\n                }\n                else if(m < 199.5)\n                {\n                    col = vec3(0.2, 0.2, 0.2);\n                    matte = 0.7;\n                }\n            } // while reflecting \n            #endif // REFLECT_MONITOR\n        }\n        else\n        {\n            col = vec3(0.2, 0.2, 0.2);\n            matte = 0.7;\n        }\n        if( m<1.5 && didmir < 0.5 )\n        {\n            vec3 dpdx = vec3(0.0,0.0,0.0);\n            vec3 dpdy = vec3(0.0,0.0,0.0);\n\n            calcDpDxy( ro, rd, rdx, rdy, t, nor, dpdx, dpdy );\n\n            float f = checkersGradBox( 5.0*pos.xz, 5.0*dpdx.xz, 5.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n        }\n        \n        // lighting\n        float occ = calcAO( pos, nor );\n        #if DEV == 1\n        vec3  lir = vec3(-0.5, 0.4, -0.6);\n        #else\n        vec3  lir = vec3(0.0, 1.2, 0.0) - pos;\n        #endif\n\t\tvec3  lig = normalize( lir );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        //float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        //float dom = smoothstep( -0.2, 0.2, ref.y );\n        //float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n       \tdif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        \n        float sql = pow(lir.x,2.0) + pow(lir.y,2.0) + pow(lir.z,2.0);\n        dif *= (pow(2.0,2.0)-sql)/ pow(2.0,2.0);\n        //dif *= ;\n        //dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\t\tspe *= 1.0 - matte;\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.80*dif*vec3(1.30,1.00,0.70);\n        //lin += 0.15*amb*vec3(0.40,0.60,1.15)*occ;\n        //lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        //lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        //lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n        if(didmir > 0.5)\n        {\n            float fresnel = max(0.1, min(0.8, 0.15+10.0*pow(1.0 + dot(ord,onr),3.0)));\n            float screen = 1.0-fresnel;\n            float reflec = 1.0-screen;\n            col = clamp(col, 0.0, 1.0) * reflec + scrcol * screen;\n        }\n\n        // Some horizon blur/highlight\n        //col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    \n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    // camera\t\n    #if STATIC_CAMERA==1\n   \tfloat time = 15.0 + 6.58*10.5;\n\tvec3 ta = vec3( 0.8, 0.8 , 0.0 );\n    #else\n    float time = 15.0 + iTime*10.5;\n    vec3 ta = vec3( 0.0, 0.6 , 0.0 );\n    #endif\n    vec3 ro = ta + vec3( 1.0*cos(0.05*time + 6.0*mo.x), 0.0, 1.0*sin(0.05*time + 6.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.0) );\n\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution. xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        \n        vec3 rdx = ca * normalize( vec3(px,2.0) );\n        vec3 rdy = ca * normalize( vec3(py,2.0) );\n        \n        // render\t\n        vec3 col = render( ca, ro, rd, rdx, rdy );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Graph Toy\n//frac(min(x,1.0)/(2.0*PI/6.0))-frac((min(max(x,2.1),3.1)/(2.0*PI/6.0)))\n    \n#define DEV 0\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 mainSound( in int samp, float time )\n{    \n    float mono = 0.0;\n    \n    //mono = fract(time*sin(80.0*fract(time))) * fract(sin(time*10.0));\n    \n    //float noise = 0.0;//hash13(vec3(fract(time),0.0,0.0));\n    \n    //float noise = sin((time+100.0)*200.0*6.0)*sin(time+1000.0*100.0*6.0);\n    \n    //float noise = texture(iChannel0, vec2(0.0,time)).x;\n    //noise = noise * 2.0 - 1.0;\n  \n    float noise = texture(iChannel0, vec2(time,fract(time)*iChannelResolution[0].x)).x;  \n//  \tfloat noise = texture(iChannel0, vec2(sin((time+10.0)*10.0)*sin((time+1050.0)*15.0)*sin((time+16623.0)*20.0)*sin((time-12350.0)*110.0),0.0)).x;  \n    //mono = noise*(sin((time-10.0)/10.0));\n//    float noise = texture(iChannel0, vec2(time/sin(time/10.0)*sin(time/100.0),time)).x;\n    // wind\n    //noise = sin(noise*80.0);\n    // distorted fire?\n    //noise = fract(sin(noise*80.0));\n    \n    // Lazer wub and UFO!!!\n    //mono += sin(tan(time*2.5)*10.0)/3.0;\n    // UFO\n    //mono += sin(tan(time*20.0)*100.0)/3.0;\n    \n    // Wubwubwubs\n    float wub = (sin(time*20.0)+1.0/2.0)*sin(time*700.0);\n    if(mod(floor(time),2.0) < 0.1)\n    {\n        wub *= (sin(time*20.0)+1.0/2.0)*sin(time*350.0);\n    \tif(mod(floor(time),4.0) < 0.1)\n        {\n            wub *= (sin(time*20.0)+1.0/2.0)*sin(time*175.0);\n    \t\tif(mod(floor(time),6.0) < 0.1)\n            {\n    \t\t\twub *= (sin(time*20.0)+1.0/2.0)*sin(time*87.0);\n            }\n        }\n    }\n    #if DEV == 1\n    mono += wub;//*(sin(time/10.0));\n    \n    //mono += noise*sin(time*10.0);\n    mono = mono* 0.8 + noise*floor(mod(time*8.0,2.0)) * 0.2;\n    \n    //mono = sin(6.0*110.0*time)*float(int(sin(time/2.0)+1.0/2.0));\n    //mono = sin(6.0*20.0*time)*round(sin(time*20.0)+0.5)*10.0;\n    \n    //                                   _\n    // ADSR but it's not really working / \\____... etc. so far \n    float t1 = mod(time*8.0, 4.0);\n    mono =  sin(6.2831*440.0*time)*(fract(min(t1,1.0)/(2.0*PI/6.0))-fract((min(max(t1,2.1),3.1)/(2.0*PI/6.0))));\n    \n    #endif\n    \n    return vec2(mono, mono);//vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// Constants\n#define PI 3.1415926\n#define TAU 6.2831853\n","name":"Common","description":"","type":"common"}]}