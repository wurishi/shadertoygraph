{"ver":"0.1","info":{"id":"msdfRH","date":"1696982563","viewed":42,"name":"Tit party de cimeti√®re","username":"dominionxvii","description":"booOooOoOoOh\nYou can comment off #define FAST for better quality volumetric light\n","likes":0,"published":1,"flags":40,"usePreview":1,"tags":["raymarching","volumetriclight","musicsynched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define HD\n#define FAST\n\n#define DEBUG\n#define DEBUG_TOMB 0\n#define STARS\n\n#define VOLLIGHT_DENSITY 0.007\n\n#ifdef FAST\n    #define RAYMARCH_STEPS 100\n    #define VOLLIGHT_STEPS 20\n    #define VOLLIGHT_STEPSIZE 0.5\n#else\n    #define RAYMARCH_STEPS 1000\n    #define VOLLIGHT_STEPS 50\n    #define VOLLIGHT_STEPSIZE 0.1\n#endif\n\n\n\n#define TOMB_ID 0\n#define GROUND_ID 1\n#define MOON_ID 2\n#define MOONSTRING_ID 3\n#define WATER_ID 4\n\n#define WATER_LEVEL -0.19\n#define WATER_WAVEHEIGHT 0.002\n\n#define GROUND_LEVEL 0.04\n\n#define BPM 130.\nconst int numberTomb = 2;\n\nconst float beatDuration = 120. / BPM;\nconst float beatPerMesure = 2.;\n\nvec3 moonAnchor = vec3(0., 15., 35.);\nfloat moonStringLength = 10.;\nvec3 moonPos = vec3(0., 2., 15.);\nvec3 lightDir;\n\nfloat onBeat;\nfloat onCrocheBeat;\nfloat onDoubleCrocheBeat;\n\nfloat time;\n\nstruct RayPrimHit\n{\n    float dist;\n    int materialID;\n    float extra;\n    float reflection;\n};\n\nstruct RayHit \n{\n    bool hasHit;\n    vec3 hitPos;\n    float dist;\n    vec3 normal;\n    vec3 reflPos;\n    vec3 reflDir;\n    vec2 screenuv;\n    vec2 uv;\n    vec3 rd;\n    int steps;\n    RayPrimHit primHit;\n};\n\n\nRayPrimHit SelectPrimHit(RayPrimHit hit1, RayPrimHit hit2)\n{\n    if(hit1.dist < hit2.dist)\n        return hit1;\n    else\n        return hit2;\n}\n\nRayPrimHit MixPrimHit(RayPrimHit hit1, RayPrimHit hit2, float t)\n{\n    RayPrimHit hit = hit1;\n    hit.dist = mix(hit1.dist, hit2.dist, t);\n    return hit;\n}\n\nfloat BevelCube(vec3 pos, vec3 offset, vec3 size, vec2 bevelRatio)\n{\n    vec3 sizebevel = vec3(size.x * bevelRatio.x, size.y * bevelRatio.x, size.z * bevelRatio.y);\n    float d1 = sdBox(pos - offset, size);\n    float d2 = sdBox(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nRayPrimHit TombSDF0(vec3 pos)\n{    \n    float repeat = 5.;\n\n    pos.z += 2.8;\n\n\n    float id = floor((pos.z + repeat / 2.0) / repeat);\n    \n    pos.x = abs(pos.x);\n    pos.x -= 2.5;   \n    \n    \n    \n    pos.z = mod(pos.z + repeat / 2., repeat) - repeat / 2.;\n    //pos = Quantize(pos, 25.);\n    //pos = RotateY(pos, id);\n\n    //pos = RotateY(pos, PI/4.);\n\n    float timeOffset = fract(time) + id * .1;\n    //float destornillador = mix(0., pos.y * 2., easeOutCubic(sin(TAU * timeOffset) * 0.5 + 0.5));\n    //float destornillador = mix(0., TAU * pos.y * 0.55, DASRCurve(easeOutCubic(timeOffset), 0.0, 0.5, 0.8, 1.0));\n    float destornillador = mix(0., Quantize(pos.y * 2.3 * 2., 4.), onBeat);\n\n    pos = RotateY(pos, destornillador);\n    \n    //dance\n    pos = RotateZ(pos, -pos.y * sin(TAU * time + PI/2.) * 0.05);\n\n\n    //pos.x += 0.;\n\n    RayPrimHit hit;\n    hit.dist = 999999.;\n    vec2 bevel = vec2(0.9, 0.9);\n\n    hit.dist = min(hit.dist, Box(pos, vec3(0, 0.9, 0.0), vec3(0.3, 2.3, 0.3)));\n    hit.dist = min(hit.dist, Box(pos, vec3(0, 1.45, 0.0), vec3(1.0, 0.3, 0.3)));\n    hit.dist = min(hit.dist, Box(pos, vec3(0, 0.2, 0.0), vec3(0.5, 0.5, 0.5)));\n    hit.dist = min(hit.dist, Box(pos, vec3(0, -0.1, 0.0), vec3(0.8, 0.8, 0.8)));\n\n\n    hit.materialID = TOMB_ID;\n    hit.reflection = 0.;\n\n    return hit;\n}\n\nRayPrimHit TombSDF1(vec3 pos)\n{    \n    RayPrimHit hit;\n    hit.dist = 999999.;\n    \n    pos.z = mod(pos.z, 5.0);\n    if(pos.z > 10.)\n    {\n        return hit;       \n    }\n       \n    pos = Quantize(pos, 25.);\n    pos.x = abs(pos.x);\n    pos = RotateY(pos, 0.35);\n\n    hit.dist = min(hit.dist, BevelCube(pos, vec3(2, 0.4, 1), vec3(1., 1.6, 0.3), vec2(1, 1.5)));\n    hit.dist = min(hit.dist, BevelCube(pos + vecY(pow(pos.x * 0.5, 2.0)), vec3(0, 1.7, 1), vec3(3., 0.3, 0.3), vec2(1, 1.5)));\n\n\n    hit.materialID = TOMB_ID;\n    hit.reflection = 0.;\n\n    return hit;\n}\n\nRayPrimHit TombSDF2(vec3 pos)\n{    \n    RayPrimHit hit;\n    hit.dist = 999999.;\n      \n    pos = Quantize(pos, 25.);\n\n    pos = RotateZ(pos, -pos.y * sin(TAU * time + PI/2.) * 0.5);\n    \n \n    hit.dist = min(hit.dist, BevelCube(pos, vec3(0, 0.9, 2), vec3(0.5, 2.3, 0.5), vec2(1, 1.5)));\n    hit.dist = min(hit.dist, BevelCube(pos, vec3(0, 1.25, 2), vec3(1.5, 0.5, 0.5), vec2(1, 1.5)));\n\n    hit.materialID = TOMB_ID;\n    hit.reflection = 0.;\n\n    return hit;\n}\n\n\nRayPrimHit GetTombSDF(vec3 pos, int id)\n{\n    switch(id)\n    {\n        case 0: return TombSDF0(pos);\n        //case 1: return TombSDF1(pos);\n        //case 1: return TombSDF2(pos);\n\n    }\n    RayPrimHit hit;  \n    return hit;\n}\n\n\nRayPrimHit GroundSDF(vec3 pos)\n{\n    RayPrimHit hit;  \n    vec2 uv = pos.xz;\n  \n    float hills = snoise(vec2(0.3, 52.) + uv * 0.2);\n\n    hills = mix(hills, Quantize(hills, 10.), 0.5);\n    hills = max(GROUND_LEVEL, hills);\n    \n    float groundOffset = hills > 0.55 ? 10. : 0.;\n \n    vec2 groundUv = pos.xz * 2.;\n    groundUv = DiamondUV(groundUv);\n    hit.extra = mod(floor(groundUv.x) + floor(groundUv.y), 2.); \n\n    float ground = sdPlane(pos, vecY(1.), GROUND_LEVEL - groundOffset) + hills * 0.55;\n    ground += hit.extra * 0.03 - hit.extra * 0.05 * sin(TAU * time * 4. + floor(groundUv.y - 1.) * 0.15) * onDoubleCrocheBeat;\n    ground -= (1.0 - hit.extra) * 0.08 * sin(TAU * time * 4. + floor(groundUv.y - 1.) * 0.15) * onCrocheBeat;\n\n    //hit.extra = 0.;\n    hit.dist = ground;\n    hit.materialID = GROUND_ID;\n    hit.reflection = 0.;\n\n\n    return hit;\n}\n\nRayPrimHit WaterSDF(vec3 pos)\n{\n    RayPrimHit hit;  \n    hit.reflection = 0.95;\n    hit.materialID = WATER_ID;\n    hit.dist = sdPlane(pos, vecY(1.), WATER_LEVEL) +\n        onBeat * sin(pos.z * 15. - pos.x * pos.x * 2.5 + time * 12.) * WATER_WAVEHEIGHT + \n        onBeat * sin(pos.x * 0.5 + pos.z * 27.25 - (pos.x * pos.x * 3.5) + time * 15.) * WATER_WAVEHEIGHT * 0.5 + \n        onBeat * sin(pos.x + 0.13 + pos.z * 31.27 - (pos.x * pos.x * 4.5) + time * 18.) * WATER_WAVEHEIGHT * 0.25; \n    return hit;\n}\n\n\nRayPrimHit MoonSDF(vec3 pos)\n{\n    RayPrimHit hit;\n    hit.dist = 999999.;\n\n    float onBeatSin = sin(TAU * time * 50.) + 0.5 * sin(TAU * time * 100.) + 0.25 * sin(TAU * time * 200.);\n    float onBeatGrow = 0.2 * onBeat * (onBeatSin * 0.5 + 0.5);\n    hit.reflection = 0.;\n\n    hit.dist = Sphere(pos, moonPos, 1.75 + onBeatGrow);\n    hit.materialID = MOON_ID;\n\n    return hit;\n}\n\nRayPrimHit MoonStringSDF(vec3 pos)\n{\n    RayPrimHit hit;\n    hit.dist = 999999.;\n   \n    pos -= moonAnchor;\n    vec3 moonDiff = moonPos - moonAnchor;\n    float moonAngle = atan(moonDiff.y, moonDiff.x);\n\n\n    pos = RotateZ(pos, moonAngle + PI / 2.);\n       \n    pos = RotateY(pos, pos.y * 1.5 + time);\n    hit.extra = pos.x > 0. ? 1. : 0.;\n\n\n    hit.dist = min(hit.dist, Box(pos, -vecY(moonStringLength / 2.0), vec3(0.1, moonStringLength, 0.3)));\n    hit.dist = min(hit.dist, Sphere(pos, vec3(0.0), 0.4));\n    hit.reflection = 0.;\n    \n    hit.materialID = MOONSTRING_ID;\n    return hit;\n}\n\nRayPrimHit DistanceFunction(vec3 pos)\n{\n    RayPrimHit hit; \n    float duration = 4.0 * beatDuration * beatPerMesure;\n    float speed = 1.0 / duration;\n       \n    float morphTime = iTime * speed + 0.5;\n    int tombIDprev = int(mod(floor(morphTime), float(numberTomb)));\n    int tombIDnext = int(mod(floor(morphTime + 1.0), float(numberTomb)));\n    float morphOffset = 0.4;\n\n    float remapMorph = Remap(morphOffset, 1.0 - morphOffset, 0., 1., fract(morphTime)); \n    remapMorph = easeInOutCubic(remapMorph);\n\n#ifdef DEBUG\n    //testing individual \n    RayPrimHit mixedHit = GetTombSDF(pos, DEBUG_TOMB);\n#else\n\n    RayPrimHit tombPrev = GetTombSDF(pos, tombIDprev);\n    RayPrimHit tombNext = GetTombSDF(pos, tombIDnext);\n    \n    \n    RayPrimHit mixedHit = MixPrimHit(tombPrev, tombNext, remapMorph); \n#endif\n   \n    RayPrimHit groundHit = GroundSDF(pos);\n    RayPrimHit waterHit = WaterSDF(pos);\n\n    RayPrimHit moonHit = MoonSDF(pos);\n    RayPrimHit moonStringHit = MoonStringSDF(pos);\n\n    RayPrimHit finalHit = SelectPrimHit(moonHit, SelectPrimHit(groundHit, waterHit));\n    finalHit = SelectPrimHit(finalHit, moonStringHit);\n    finalHit = SelectPrimHit(finalHit, mixedHit);\n\n    return finalHit;\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.2;\n    const vec2 h = vec2(eps,0);\n    \n    float distX1 = DistanceFunction(p+h.xyy).dist;\n    float distX2 = DistanceFunction(p-h.xyy).dist;\n    \n    float distY1 = DistanceFunction(p+h.yxy).dist;\n    float distY2 = DistanceFunction(p-h.yxy).dist;\n    \n    float distZ1 = DistanceFunction(p+h.yyx).dist;\n    float distZ2 = DistanceFunction(p-h.yyx).dist;\n\n    return normalize( vec3(distX1 - distX2,\n                           distY1 - distX2,\n                           distZ1 - distZ2));\n}\n\n\nRayHit SetupRayHit(vec3 ro, vec3 rd, bool hasHit, float dist, vec3 normal, vec2 screenuv, int steps, RayPrimHit primHit)\n{\n    RayHit rayHit;\n    rayHit.hasHit = hasHit;\n    rayHit.hitPos = ro + rd * dist;\n    rayHit.dist = dist;\n    rayHit.normal = normal; \n    rayHit.reflDir = reflect(rd, rayHit.normal);\n    rayHit.reflPos = rayHit.hitPos + rayHit.reflDir * 0.01;\n    rayHit.screenuv = screenuv;\n    rayHit.rd = rd;\n    //rayHit.uv = project(rayHit.hitPos, normal).;\n\n    rayHit.steps = steps;\n    rayHit.primHit = primHit;\n\n    return rayHit;\n}\n\nRayHit Raymarch(vec3 ro, vec3 rd, vec2 screenuv)\n{\n    float currentDist = 0.;\n    bool hasHit = false;\n    RayPrimHit primHit;\n    int i;\n    for(i = 0; i < RAYMARCH_STEPS; i++)\n    {\n        vec3 pos = ro + rd * currentDist;\n        primHit = DistanceFunction(pos);\n        float dist = primHit.dist;\n        currentDist += dist;\n      \n        if(dist < 0.001)\n        {    \n            hasHit = true;\n            break;\n        }\n        else if(currentDist > 100.0)\n        {\n            break;\n        }\n    }\n\n    vec3 normal = calcNormal(ro + rd * currentDist);\n    return SetupRayHit(ro, rd, hasHit, currentDist, normal, screenuv, i, primHit); \n}\n\nfloat CalculateShadow(RayHit hit)\n{\n    RayHit shadowHit = Raymarch(hit.hitPos + hit.normal * 0.01, normalize(moonPos - hit.hitPos), hit.screenuv);    \n    return (shadowHit.hasHit && shadowHit.primHit.materialID != MOON_ID) ? 0.75 : 1.;    \n}\n\nfloat CalculateMoonLight(RayHit hit)\n{\n     return saturate(dot(-hit.normal, lightDir) + 0.4 + 0.2 * onBeat);\n}\n\nfloat CalculateInDirectLight(RayHit hit)\n{\n    vec3 indirectLightDir = normalize(vec3(0, 1, 2));\n     return saturate(dot(hit.normal, indirectLightDir)) * 0.2;\n}\n\nvec4 TombColor(inout RayHit hit)\n{\n    float fresnel = 1.0 - pow(saturate(dot(-hit.normal, hit.rd)), 0.5);\n    vec4 fresnelCol = fresnel * mix(GetCol(196, 63, 26), vec4(1.), onBeat);\n    vec4 textCol = texture(iChannel1, hit.uv);\n    return vec4(0.5) * CalculateMoonLight(hit) + fresnelCol * 0.3;\n}\n\n\nvec4 GroundColor(inout RayHit hit)\n{\n    vec4 orangeBeatCol = mix(GetCol(196, 63, 26), vec4(1.), onBeat);\n    vec4 ground = mix(GetCol(41, 41, 41), orangeBeatCol, float(hit.primHit.extra));\n    \n    return ground * saturate(CalculateMoonLight(hit) + CalculateInDirectLight(hit)) * CalculateShadow(hit);\n}\n\nvec4 WaterColor(inout RayHit hit)\n{\n    vec4 water = GetCol(66, 135, 245);  \n    return water * saturate(CalculateMoonLight(hit) + CalculateInDirectLight(hit)) * CalculateShadow(hit);\n}\n\n\nvec4 MoonColor(inout RayHit hit)\n{\n    vec2 uv = hit.hitPos.xy - moonPos.xy;\n    uv *= length(uv);\n    float text = Remap(0., 1., 0.7, 1., texture(iChannel0, uv * 0.2).r);\n    float fakeLight = Remap(0.0, 1.0, 0.3, 1.0, saturate(dot(hit.normal, vec3(0., 0., -1.))));\n    return 2.2 * GetCol(255, 255, 255) * text * fakeLight;\n}\n\nvec4 MoonStringColor(inout RayHit hit)\n{\n    return GetCol(200, 200, 200) * saturate(0.5 + CalculateMoonLight(hit) + CalculateInDirectLight(hit));\n    //return hit.primHit.extra == 0 ? vec4(1) : vec4(0);\n}\n\n\nfloat ComputeStars(vec2 uv, vec2 offset, vec2 rotOffset, float speed, float shine)\n{\n    vec2 starUv = offset + RotateZ(uv + rotOffset, time * speed);\n    float scale = 5.0;\n    vec2 cell = floor(starUv * scale);\n    float starsDist1 = PeriodicalCellularNoise(starUv, scale, 0.5, 0.0);\n    float starsDist2 = PeriodicalCellularNoise(starUv, scale, 2., 0.0);\n    \n    float mixedDist = mix(starsDist1, starsDist2, 0.5 + 0.2 * sin(time * 2.));\n    \n    float sinOffset = cell.x * 17. + cell.y * 23.;\n    float shine2 = Remap(-1., 1., 0.3, 1., sin(time * 5. + sinOffset));\n    \n    return (1.0 - smoothstep(mixedDist, 0.0, (1. / shine))) * shine2;\n}\n\nfloat UvToSamplingValue(vec2 uv, float t)\n{\n    t += uv.y * 0.02 + sin(uv.x * 155. + t * 5.) * 0.005 + sin(uv.y * 100. + t * 5.) * 0.0075;\n    return t;\n}\n\nvec4 ComputeSky(vec2 uv)\n{\n#ifndef STARS\n    return vec4(0.0);\n#endif\n\n    float starSum = 0.;\n\n    int starStackCount = 8;\n    for(int i = 0; i < starStackCount; i++)\n    {\n        float x = float(i);\n        float speed =  0.005 - (x * 0.001);\n        float shine = 100. * (x + 1.0); \n        float amp = 1. / (x + 1.); \n        starSum += ComputeStars(uv, -vec2(x * 5.), vec2(-5.0, 10.), speed, shine) * amp;\n    }\n    return vec4(starSum) * Remap(0., 1., 0.2, 1.0, 1. - onBeat);\n}\n\n\nvec4 HitToColor(inout RayHit hit)\n{\n    if(!hit.hasHit)\n    {\n        return ComputeSky(hit.screenuv);\n    }\n    \n    switch(hit.primHit.materialID)\n    {\n        case TOMB_ID: return TombColor(hit);\n        case GROUND_ID: return GroundColor(hit);\n        case MOON_ID: return MoonColor(hit);\n        case MOONSTRING_ID: return MoonStringColor(hit);\n        case WATER_ID: return WaterColor(hit);\n    }\n}\n\nvec4 SampleVolumetricBuffer(vec3 pos)\n{\n    vec3 bufferSize = vec3(64.); //must match Buffer A size's value\n\n    float x = Convert3DTo1D(pos,  bufferSize);\n    vec2 channelResolution = iChannelResolution[0].xy;\n    vec2 uv3D = Convert1DTo2D(x, channelResolution.xy) / channelResolution.xy; //must match buffer A resolution\n    vec4 sampleColor = vec4(texture(iChannel0, uv3D));\n    return sampleColor;\n}\n\nfloat VolumetricLight(vec3 ro, vec3 rd, float maxDist)\n{\n    float sum = 0.;\n    for(int i = 0; i < VOLLIGHT_STEPS; i++)\n    {\n        vec3 pos = ro + rd * float(i) * VOLLIGHT_STEPSIZE;\n        vec3 moonDiff = moonPos - pos;\n        float moonDist = length(moonDiff);\n        vec3 moonDir = moonDiff / moonDist;\n        \n        RayHit shadowHit = Raymarch(pos, moonDir, vec2(0.0));    \n        bool hitIsValid = (shadowHit.hasHit && shadowHit.primHit.materialID == MOON_ID) || !shadowHit.hasHit;\n        \n        float lightBoost = 0.;\n\n        float volumetricnoise = Remap(0., 1.0, 0.5, 1.0, SampleVolumetricBuffer(32. + pos * 5.0).x);\n        float onBeatGlow = (onBeat * 0.05);\n        sum += (hitIsValid ? 1. : 0.) * VOLLIGHT_STEPSIZE * (VOLLIGHT_DENSITY + lightBoost + onBeatGlow) * volumetricnoise;\n        \n    }\n    return sum;\n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\nvec3 gamma(vec3 color)\n{\n    return pow(color, 1. / vec3(2.2));\n}\n\nvec4 RenderAtUv(vec3 camPos, vec4 camRot, vec2 uv)\n{\n    vec3 ro, rd;\n    PerspectiveCam(camPos, camRot, uv, ro, rd);\n    \n    RayHit result = Raymarch(ro, rd, uv);\n    vec4 hitColor = HitToColor(result) + VolumetricLight(ro, rd, result.dist);\n    vec4 hitColorRefl = vec4(0.0);\n    \n    if(result.hasHit && result.primHit.reflection > 0.)\n    {\n       vec3 relfRo = result.hitPos + result.normal * 0.01;\n       RayHit resultRefl = Raymarch(relfRo, result.reflDir, uv);\n       hitColorRefl = HitToColor(resultRefl) + VolumetricLight(relfRo, result.reflDir, result.dist);\n    }\n    else\n    {\n        result.primHit.reflection = 0.;\n    }\n    \n    float distFadeOff = result.hasHit ? Remap(0., 15., 1., 0.55, result.dist) : 1.;   \n    vec4 finalCol = mix(hitColor, hitColorRefl, result.primHit.reflection) * distFadeOff;\n    return finalCol;\n}\n\n\n\n#ifdef HD  \nvec4 RenderAtUvAntiAliasing(vec3 camPos, vec4 camRot, vec2 uv, vec2 fragCoord)\n{\n    vec4 colorSum = vec4(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n    colorSum += RenderAtUv(camPos, camRot, uv);\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, nextUv, 0.5));\n    colorSum /= 4.0;\n    return colorSum;\n}\n#endif\n\nvec3 CalculatePendulum(vec3 point, float stringLength)\n{\n    /* real formula ... screw this\n    float pi2 = 2. * PI;\n    float l = stringLength;\n    float g = 9.81;\n    float t = pi2 * sqrt(l / g);\n\n    float theta = cos(pi2 / t * time );    \n    return point + RotateZ(vecY(l), PI + theta);\n    */\n    \n    float theta = cos(TAU * time);    \n    return point + RotateZ(vecY(stringLength), PI + theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //uv = Quantize(uv, 200.);\n    \n    float timeScale = BPM / (120. * 4.);\n    time = iTime * timeScale;\n    \n    vec3 camPos = vec3(0., 0.5, -2.0);\n    vec4 camRot = vec4(0.0, 0.0, 0.0, 1.0); \n       \n    onBeat = Remap(0., 0.4, 1., 0., fract(time * 2.0));\n    onCrocheBeat = Remap(0., 0.4, 1., 0., fract(time * 4.0)); \n    onDoubleCrocheBeat = Remap(0., 0.4, 1., 0., fract(time * 8.0)); \n\n    onBeat = easeInOutCubic(onBeat);\n    moonPos = CalculatePendulum(moonAnchor, moonStringLength);\n    lightDir = -normalize(moonPos);\n       \n#ifdef HD  \n    fragColor = RenderAtUvAntiAliasing(camPos, camRot, uv, fragCoord);  \n#else\n    fragColor = RenderAtUv(camPos, camRot, uv); \n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n#define TAU 6.2831\n\n//[-1, 1] -> [0, 1]\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nvec3 project(vec3 a, vec3 b)\n{\n    return (dot(a, b)/dot(b,b))*b;\n}\n\nvec3 reject(vec3 a, vec3 b)\n{\n    return a - project(a, b);\n}\n\nvec3 RotateAroundAxis(vec3 p, vec3 axis, float a)\n{\n    vec3 parallel = project(p, axis);\n    vec3 orthogonal = reject(p, axis);\n    vec3 vcross = cross(p, axis);\n    return parallel + orthogonal * cos(a) + vcross * sin(a);\n}\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\nfloat Quantize(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nvec2 Quantize(vec2 v, float resolution)\n{\n    return vec2(Quantize(v.x, resolution), Quantize(v.y, resolution));\n}\nvec3 Quantize(vec3 v, float resolution)\n{\n    return vec3(Quantize(v.x, resolution), Quantize(v.y, resolution), Quantize(v.z, resolution));\n}\nfloat Luminance(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722; \n}\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\nvec2 RotateZ(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c);\n}\n\nvec2 DiamondUV(vec2 uv)\n{    \n    vec2 diamondUV = RotateZ(uv, radians(45.));\n    diamondUV = Quantize(diamondUV, 25.);\n    diamondUV = RotateZ(diamondUV, -radians(45.));\n    \n    return diamondUV;\n}\n\n\nvec4 GetCol(int r, int g, int b)\n{\n    return vec4(r, g, b, 1.) / 255.;\n}\n\n//Ease, https://easings.net\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad(float x) {\n    return x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n\n    if (x < 1.0 / d1) {\n        return n1 * x * x;\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 5.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nfloat easeInOutBack(float x) \n{\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n      : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat easeInBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\n\nfloat easeInCirc(float x)\n{\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\nfloat easeInOutQuint(float x)\n{\n    return x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\n\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\n\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x,\n        p.y * c - p.z * s,\n        p.y * s + p.z * c\n      );\n}\n\n\nvec3 RotateZ45(vec3 pos)\n{\n    return RotateZ(pos, radians(45.));\n}\nvec3 RotateY45(vec3 pos)\n{\n    return RotateY(pos, radians(45.));\n}\nvec3 RotateX45(vec3 pos)\n{\n    return RotateX(pos, radians(45.));\n}\n\n//Quaternions\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x * s,axis.y * s,axis.z * s,c);\n}\n///\n\n\n\n//SDF\n///https://iquilezles.org/articles/distfunctions\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b * 0.5;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) - h;\n}\n\nfloat Box(vec3 p, vec3 boxPos, vec3 boxSize)\n{\n    return sdBox(p - boxPos, boxSize);\n}\nfloat Sphere(vec3 p, vec3 spherePos, float sphereRadius)\n{\n    return length(p - spherePos) - sphereRadius;\n}\n\nfloat Capsule(vec3 p, vec3 start, vec3 end, float radius)\n{\n    return sdCapsule(p, start, end, radius);\n}\n\nfloat Cone(vec3 p, vec3 conePos, vec2 c, float height)\n{\n    return sdCone(p - conePos, c, height);\n}\n\n\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n///\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return t;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec2 NextVec2(vec2 rmin, vec2 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    return vec2(x, y);\n}\n\nvec2 NextVec2(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\nvec3 NextVec3(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n\n    return vec3(x, y, z);\n}\n\nvec4 NextVec4(vec4 rmin, vec4 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    float w = NextFloat(rmin.w, rmax.w, state);\n\n    return vec4(x, y, z, w);\n}\n\nvec4 NextVec4(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n    float w = NextFloat(state);\n\n    return vec4(x, y, z, w);\n}\n\n//my own noise (im proud)\n\n\nfloat Repeat(float t, float len)\n{\n    return clamp(t - floor(t / len) * len, 0., len);\n}\n\nvec2 Repeat(vec2 t, float len)\n{\n    return vec2(Repeat(t.x, len), Repeat(t.y, len));\n}\nvec2 Repeat(vec2 t, vec2 size)\n{\n    return vec2(Repeat(t.x, size.x), Repeat(t.y, size.y));\n}\n\nvec3 Repeat(vec3 t, float len)\n{\n    return vec3(Repeat(t.x, len), Repeat(t.y, len), Repeat(t.z, len));\n}\nvec3 Repeat(vec3 t, vec3 size)\n{\n    return vec3(Repeat(t.x, size.x), Repeat(t.y, size.y), Repeat(t.z, size.z));\n}\n\nvec4 Repeat(vec4 t, float len)\n{\n    return vec4(Repeat(t.x, len), Repeat(t.y, len), Repeat(t.z, len), Repeat(t.w, len));\n}\nvec4 Repeat(vec4 t, vec4 size)\n{\n    return vec4(Repeat(t.x, size.x), Repeat(t.y, size.y), Repeat(t.z, size.z), Repeat(t.w, size.w));\n}\n\n//Convert functions based on https://www.shadertoy.com/view/XddXW7\n\nfloat Convert2DTo1D(vec2 p, vec2 s) \n{\n    //p = Repeat(p, s);\n    p = mod(p, s);\n    return floor(p.y) * s.x + p.x;\n}\n\nvec2 Convert1DTo2D(float p, vec2 size)\n{\n    float x = mod(p, size.x);\n    float y = (p - x) / size.x + 0.5;\n    return vec2(x, y);\n}\n\nfloat Convert3DTo1D(vec3 p, vec3 size)\n{\n    //p = Repeat(p, size);\n    p = mod(p, size);\n    return floor(p.z) * size.x * size.y + floor(p.y) * size.x + p.x;\n}\n\nvec3 Convert1DTo3D(float p, vec3 size)\n{\n    float x = mod(p, size.x);\n    float y = mod((p - x) / size.x, size.y);\n    float z = (p - x - floor(y) * size.x) / (size.x * size.y);\n    return vec3(x, y + 0.5, z + 0.5);\n}\n\nfloat PeriodicalCellularNoise(vec2 p, float scale, float distancePow, float rotation)\n{\n    p *= scale;\n    vec2 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 cellIndex = mainCell + vec2(x, y);\n\n        uint seed = uint(1327. + cellIndex.x * 3. + cellIndex.y * 7.);\n        uint state = WangHash(seed);\n        \n        vec2 loopOverIndex = Repeat(cellIndex, scale);\n        \n        //vec2 offset = 0.5 + NextVec2(vec2(-0.5), vec2(0.5), state);\n        //vec2 cellPos = cellIndex + offset;\n        vec2 cellPoint = cellIndex + 0.5 + NextVec2(vec2(-0.5), vec2(0.5), state);\n        \n        vec2 diff = abs(p - cellPoint);\n        diff = RotateZ(diff, rotation);\n        \n        float dist = pow(pow(diff.x, distancePow) + pow(diff.y, distancePow), 1. / distancePow);\n        \n        minDist = min(minDist, dist);\n    }\n\n    return minDist;\n}\n\nfloat PeriodicalCellularNoise(vec2 p, float scale)\n{\n   return PeriodicalCellularNoise(p, scale, 2.0, 0.0);\n}\n\nfloat PeriodicalCellularNoise(vec3 p, float scale, vec3 size)\n{\n    p *= scale;\n    vec3 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 cellIndex = mainCell + vec3(x, y, z);\n        \n        vec3 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(137. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17. + repeatCellIndex.z * 13.);\n        uint state = WangHash(seed);\n        \n        vec3 cellPoint = cellIndex + NextVec3(state);\n        float dist = distance(p, cellPoint);\n        minDist = min(minDist, dist);\n    }\n\n    return minDist;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 size = vec3(64.);\n    float zoom = 1.0 / 16.;\n    \n    float i = Convert2DTo1D(fragCoord, iResolution.xy);\n    vec3 pos = Convert1DTo3D(i, size.xyz);\n    \n    float noise = PeriodicalCellularNoise(pos, zoom, size);\n    fragColor = vec4(1. - noise, 0, 0 ,0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BASE_FREQ 666.\n#define NOTE_PER_OCT 12.\n\nint melody1[16] = int[16](0, 8, 7, 8, 0, 8, 7, 8, -1, 8, 7, 8, -4, 7, 6, 7);\nint drum[16] = int[16](1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0);\n\nint currentSample;\nfloat iTime;\n\nfloat NoteToFreq(int n)\n{\n    return BASE_FREQ * pow(2., float(n) / NOTE_PER_OCT);\n}\n\nfloat GetTime(float freq)\n{\n    int seconds = currentSample / int(iSampleRate);\n    float secondFrac = mod(float(currentSample), iSampleRate) / iSampleRate;\n    \n    seconds = seconds % 8;\n    float t = float(seconds) + secondFrac;\n    return freq * t; \n}\n\nfloat Envelope(float t)\n{\n    return DASRCurve(fract(t), 0., 0.2, 0.7, 1.0);\n}\n\nfloat Sine(float t)\n{\n    return sin(TAU * fract(t));\n}\n\nfloat Tri(float t)\n{\n    return abs(mod(fract(t) + 0.5, 1.)- 0.5) * 4. - 1.;\n}\n\nfloat Square(float t)\n{\n    return step(fract(t), 0.5);\n}\n\nfloat VST1(int note, float noteT)\n{\n    float freq = GetTime(NoteToFreq(note) * 0.5);\n    float melody = 0.;\n    int harmonics = 5;\n    float harmonicFadeOff = 0.7;\n    for(int i = 1; i <= harmonics; i++)\n    {\n        melody += Tri(freq * float(i)) * exp(-float(i) * harmonicFadeOff);\n    }\n    \n    float envelope = Envelope(noteT);\n    return melody * envelope;\n}\n\nfloat VST2(int note, float noteT)\n{    \n    float t = mix(GetTime(NoteToFreq(note)), GetTime(NoteToFreq(note + 1)), 0.1 * (sin(GetTime(2.0)) * 0.5 + 0.5));\n    float melody = 0.;\n    int harmonics = 3;\n    float harmonicFadeOff = 1.2;\n    float harmonicSkip = 2.;\n    \n    for(int i = 0; i < harmonics; i++)\n    {\n        melody += Tri(t + t * float(i) * harmonicSkip) * exp(-float(i) * harmonicFadeOff);\n    }\n    \n    float envelope = Envelope(noteT);\n    return melody * envelope;\n}\n\nfloat KickNoise(int note, float noteT)\n{\n    float freq = GetTime(NoteToFreq(note));\n    float tri = Tri(freq);\n    \n    uint seed = WangHash(uint(currentSample));\n    float noise = NextFloat(seed) * 2. - 1.;\n    \n    int soundKickFrame = 4;\n    bool triOn = ((currentSample / soundKickFrame) % soundKickFrame) == 0;\n    \n    float envelope = DASRCurve(fract(noteT), 0.0, 0.1, 0.7, 1.0);;\n    return ((triOn ? tri : 0.) + noise) * envelope;\n}\n\nvec2 mainSound( int samp, float time)\n{\n    return vec2(0);\n    \n    iTime = time;\n\n    currentSample = samp;\n    float crocheSpeed = 4.;\n\n    int note = int(floor(time * crocheSpeed));\n    int melodyNote = melody1[note % 16];\n    float melody = VST1(melodyNote, time * crocheSpeed);\n    float drone = VST2(-24, 0.5);\n        \n    float kick = float(drum[note % 16]) * KickNoise(-24, time * crocheSpeed);\n        \n    float total = melody + drone + kick; \n    return vec2(total * 0.5);\n}","name":"Sound","description":"","type":"sound"}]}