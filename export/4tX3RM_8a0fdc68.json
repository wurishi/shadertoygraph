{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define MAX_STEPS  128 // try to experiment with numb of steps\n#define THRESHOLD .01\n#define NUM_BALLS  30.\n\n#define OCTAVES  8.0\n\nconst float fogDensity = 0.17;\n\nstruct objectInfo{\n    float hill;\n    vec2 id;\n    float timeOffset;\n    int numBumps;\n    float inBump;\n};\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat object11(vec3 a, vec3 c, float r) {\n    return length(a - c) - r;\n}\n\nfloat valueNoiseSimple(vec2 vl) {\n   float minStep = 1.0 ;\n\n   vec2 grid = floor(vl);\n   vec2 gridPnt1 = grid;\n   vec2 gridPnt2 = vec2(grid.x, grid.y + minStep);\n   vec2 gridPnt3 = vec2(grid.x + minStep, grid.y);\n   vec2 gridPnt4 = vec2(gridPnt3.x, gridPnt2.y);\n\n    float s = rand2(grid);\n    float t = rand2(gridPnt3);\n    float u = rand2(gridPnt2);\n    float v = rand2(gridPnt4);\n    \n    float x1 = smoothstep(0., 1., fract(vl.x));\n    float interpX1 = mix(s, t, x1);\n    float interpX2 = mix(u, v, x1);\n    \n    float y = smoothstep(0., 1., fract(vl.y));\n    float interpY = mix(interpX1, interpX2, y);\n    \n    return interpY;\n}\n\nfloat fractalNoise(vec2 vl) {\n    float persistance = 2.0;\n    float amplitude = 1.;\n    float rez = 0.0;\n    vec2 p = vl;\n    \n    for (float i = 0.0; i < OCTAVES; i++) {\n        rez += amplitude * valueNoiseSimple(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez;\n}\n\nfloat getTLow(float y0, float v0, float g) {\n    \n    // First solution is 0, second one is 2 * v0 / g\n    return 2. * v0 / g;\n}\n\nfloat physTest3D(vec3 coord, vec3 start, float v0, float g, float r,\n                out int numBumps, out float inBump) {\n\tfloat Gclr = 0.;\n    float lowerPnt = getTLow(start.y, v0, g);\n    float time = iTime / 3.;\n    \n    int attenuation = int(time / lowerPnt);\n\n    attenuation = int(mod(float(attenuation), 3.));\n    \n    vec3 center = start;\n    float y_offset = 0.;\n    \n    if (v0 > 0.5) {\n        v0 /= float(attenuation + 1);\n        lowerPnt = getTLow(start.y, v0, g);\n    \ttime = mod(time, lowerPnt);\n        \n       \ty_offset = v0 * time - (g * time * time) / 2.;\n        \n   \t\tcenter.y = start.y + y_offset;\n    }\n    \n    center.y += r;\n    \n    numBumps = attenuation;\n    inBump = time;\n    \n    return object11(coord, center, r);\n}\n\nfloat sceneSimple(vec3 a) {\n    float res = 10.;\n    float Floor = -0.98;\n    float Step = 20. / NUM_BALLS;\n    \n    float idxX = floor(a.x / Step);\n    float idxZ = floor(a.z / Step);\n    a.x = mod(a.x, Step);\n    a.z = mod(a.z, Step);\n    \n    float r = 0.1;\n    \n    float offsetX = Step / 2. + (rand(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n    float offsetZ = Step / 2. + (rand2(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n\n    int tmp1;\n    float tmp2;\n    \n    res = physTest3D(a,\n                     vec3(offsetX, Floor, offsetZ), \n                     4. + 2. * (rand(vec2(idxX / 10., idxZ/ 10.)) * 2. - 1.),\n                     9.8,\n                     r,\n                     tmp1,\n                     tmp2);\n    \n    \n    return min(res, a.y - Floor);\n}\n\nfloat scene(vec3 a, out objectInfo inf) {\n    float res = 10.;\n    float Floor = -0.98;\n    float Step = 20. / NUM_BALLS;\n    \n    float idxX = floor(a.x / Step);\n    float idxZ = floor(a.z / Step);\n    a.x = mod(a.x, Step);\n    a.z = mod(a.z, Step);\n    \n    float r = 0.1;\n    \n    float offsetX = Step / 2. + (rand(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n    float offsetZ = Step / 2. + (rand2(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n                          \n    res = physTest3D(a,\n                     vec3(offsetX, Floor, offsetZ), \n                     4. + 2. * (rand(vec2(idxX / 10., idxZ/ 10.)) * 2. - 1.),\n                     9.8,\n                     r,\n                     inf.numBumps,\n                     inf.inBump);\n    \n    if (res > (a.y - Floor)) {\n        res = a.y - Floor;\n        inf.id = vec2(0.);\n    } else {\n        inf.id.x = idxX + 1.;\n        inf.id.y = idxZ + 1.;\n    }    \n    \n    return res;\n}\n\nvec3 snormal(vec3 a) {\n   vec2 e = vec2(.0001, 0.);\n   float tmp1;\n   float tmp2;\n   float w = sceneSimple(a);\n\n    return normalize(vec3(\n       sceneSimple(a+e.xyy) - w,\n       sceneSimple(a+e.yxy) - w,\n       sceneSimple(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D, out objectInfo inf) {\n    \n    float L = 0.;\n    int steps = 0;\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = scene(O + D*L, inf);\n        d = clamp(d, 0., .15);\n        L += d;\n        \n        if (d < THRESHOLD * L) // Adaptive threshold \n            break;\n    }\n    \n    inf.hill = d;\n    return L;\n}\n\nfloat occluded(vec3 p, float len, vec3 dir) {\n    return max(0., len - sceneSimple(p + len * dir));\n}\n\nfloat occlusion(vec3 p, vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.xz);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    float dst = .2;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    return (1. - min(rez, 1.));\n}\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos, objectInfo inf) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    \n    vec3 color;\n    float specMat = 0.3;\n    \n    if (inf.id.x == 0. && inf.id.y == 0.) {\n        vec3 txtP = p;\n        txtP.z += .75 * inf.timeOffset;\n        color = texture(iChannel0, txtP.xz *.5 + .5).rgb;\n    } else {\n        float threshold = 0.15;\n        float bumps = float(inf.numBumps) / 3.;\n        \n        color.r = mod(rand(vec2(inf.id.x / 1000.)) + bumps, 1.);\n        color.g = mod(rand(vec2(inf.id.y / 1000.)) + bumps, 1.);\n        color.b = mod(rand(vec2((inf.id.x + inf.id.y) / 1000.)) + bumps, 1.);\n\n        specMat = clamp(rand(vec2((inf.id.x + inf.id.y) / 1000.)), 0.01, 1.);\n        \n        float rnd = rand(inf.id / 1000.);\n\n        vec3 offset = vec3(rand(p.xz) * 2. -1.,\n                           rand(p.xy) * 2. -1.,\n                           rand2(p.xz)* 2. -1.);\n\n        if (rnd > 0.75) {\n            float noise = fractalNoise(p.xy * 50. + rnd * 10.);\n            color *= noise;\n            normal *= noise;\n        } else {\n            normal *= clamp(rnd + 0.5, .5, 1.);\n        }\n\n        if (inf.inBump < threshold) {\n            \n            color = mix(vec3(.5, .0, .0),\n                        color,\n                        inf.inBump / threshold);\n        }\n    }\n    \n    vec3 ambient = color;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    diffuse = clamp(diffuse, 0., 1.) * 0.5;\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n    \n    spec = pow(spec, specMat * 60.);\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * vec3(1.0, 1.0, 1.0);\n    \n    return Ispec + diffuse + ambient * occlusion(p, normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    float timeOffset = iTime * 2.;\n    \n    vec3 O = vec3(0., 0.1, 2. - timeOffset);\n    vec3 D = normalize(vec3(centered_uv, -3.5)); //fov\n    \n    objectInfo inf;\n    float path = trace(O, D, inf);\n    vec3 coord = O + path * D;\n    inf.timeOffset = timeOffset;\n    \n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157);\n    vec3 color = mix(skyBlueColor, vec3(1.), clamp(centered_uv.y, 0., 1.));\n    \n    if (inf.hill >= 0.15) {\n        fragColor = vec4(color , 1.);\n    } else {\n        vec3 lightPos = vec3(0., 10., -4. - timeOffset);\n        vec3 normal = snormal(coord);\n\n        vec3 resColor = enlight(coord, normal, O, lightPos, inf);\n        // Calc some fog\n    \tfloat fogFactor = exp(-pow(abs(fogDensity * (coord.z - 1. + timeOffset)), 4.0));\n    \tfogFactor = clamp(fogFactor, 0.0, 1.0);\n    \tresColor = mix(color, resColor, fogFactor);\n        \n        fragColor = vec4(resColor,\n            \t\t\t\t1.0);\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tX3RM","date":"1421444420","viewed":532,"name":"BallsJumps","username":"FatumR","description":"Simple demonstration of the jumping ball","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","physics"],"hasliked":0,"parentid":"","parentname":""}}