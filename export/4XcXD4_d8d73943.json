{"ver":"0.1","info":{"id":"4XcXD4","date":"1718996223","viewed":47,"name":"simple (BAD) gaussian blur","username":"int_45h","description":"VERY basic implementation of gaussian blur, no precomputed matrix, just a horizontal and vertical blur applied.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define KERNEL_SIZE 9\n#define MATRIX_SIZE KERNEL_SIZE*KERNEL_SIZE*4\n\n#define SIGMA (float(KERNEL_SIZE)*.5)*(sin(iTime)*.5+.5)\n//#define SIGMA (float(KERNEL_SIZE)*.5)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 gauss_h(vec2 fc, float s)\n{\n    vec2 uv = fc / iResolution.xy;\n    float kf = float(KERNEL_SIZE);\n    \n    s = clamp(s, 1., kf*.5);\n    float q = 2.*s*s;\n    \n    vec4 c = vec4(0);\n    for (int x=-KERNEL_SIZE; x<KERNEL_SIZE; x++)\n    {\n        vec2 o = vec2(x,0);\n        vec4 p = texture(iChannel0, uv+o/iResolution.xy);\n        c += p*exp(-(o.x*o.x)/q) / sqrt(q*PI);\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = gauss_h(fragCoord, SIGMA);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 gauss_v(vec2 fc, float s)\n{\n    vec2 uv = fc / iResolution.xy;\n    float kf = float(KERNEL_SIZE);\n    \n    s = clamp(s, 1., kf*.5);\n    float q = 2.*s*s;\n    \n    vec4 c = vec4(0);\n    for (int y=-KERNEL_SIZE; y<KERNEL_SIZE; y++)\n    {\n        vec2 o = vec2(0,y);\n        vec4 p = texture(iChannel0, uv+o/iResolution.xy);\n        c += p*exp(-(o.y*o.y)/q) / sqrt(q*PI);\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = gauss_v(fragCoord, SIGMA);\n}","name":"Buffer B","description":"","type":"buffer"}]}