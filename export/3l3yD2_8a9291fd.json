{"ver":"0.1","info":{"id":"3l3yD2","date":"1609947459","viewed":113,"name":"metaball raytracer","username":"siffo","description":"Reflecting, refracting metaballs with shadows.\nHold mouse button and move mouse on the view to change light direction.\nThere's adjustable values at the top of the shader to play with.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["shadows","raytrace","metaball","reflect","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// number of reflection steps (default = 3, adjust between 0-3)\nconst int g_reflectionSteps = 3;\n\n// number of refraction steps (default = 2, adjust between 0-3)\nconst int g_refractionSteps = 2;\n\n// number of reflected refraction steps (default = 1, adjust between 0-3)\nconst int g_reflectedRefractionSteps = 1;\n\n// enable shadows (default = true)\nconst bool g_shadows = true;\n\n// enable diffuse light (default = true)\nconst bool g_diffuseLight = true;\n\n// enable specular light (default = true)\nconst bool g_specularLight = true;\n\n// enable cube map (default = true)\nconst bool g_cubeMap = true;\n\nconst float g_epsilon = 0.0001;\nconst float g_offset = 0.001;\nconst float g_step = 0.6;\nvec3 g_lightDir = vec3( 0.0, 0.0, -1.0 );\nvec3 g_pos1;\nvec3 g_pos2;\nvec3 g_pos3;\n\nfloat sdfFloor( in vec3 position )\n{\n    return 0.1 / abs( position.y + 0.7 );\n}\n\nfloat sdfMeta( in vec3 center, in float radius, in vec3 position )\n{\n    return radius / length( position - center );\n}\n\nfloat sdf( in vec3 position )\n{\n    float f0 = sdfFloor( position );\n    float f1 = sdfMeta( g_pos1, 0.3, position );\n    float f2 = sdfMeta( g_pos2, 0.3, position );\n    float f3 = sdfMeta( g_pos3, 0.1, position );\n    \n    return 1.0 - ( f0 + f1 + f2 + f3 );\n}\n\nvec3 sdfColor( in vec3 position )\n{\n    if( ( position.y + 0.7 ) < g_epsilon )\n        return vec3( 0.1, 0.05, 0.02 );\n        \n    float f1 = sdfMeta( g_pos1, 0.3, position );\n    float f2 = sdfMeta( g_pos2, 0.3, position );\n    float f3 = sdfMeta( g_pos3, 0.1, position );\n    \n    vec3 color = f1 * vec3( 1, 0, 0 ) + f2 * vec3( 0, 1, 0 ) + f3 * vec3( 0, 0, 1 );    \n    return color;\n}\n\nvec3 sdfNormal( in vec3 position )\n{\n    vec2 d = vec2( 0.001, 0.0 );\n    return normalize( vec3( sdf( position + d.xyy ) - sdf( position - d.xyy ),\n        sdf( position + d.yxy ) - sdf( position - d.yxy ),\n        sdf( position + d.yyx ) - sdf( position - d.yyx ) ) ); \n}\n\nbool intersect( in vec3 rayOrigin, in vec3 rayDirection, out vec3 position )\n{\n    position = rayOrigin;\n            \n    for( int i = 0; i < 1024; ++i )\n    {\n        float distance = sdf( position );\n        position += rayDirection * distance * g_step;\n        if( distance < g_epsilon )\n            return true;\n    }\n    return false;\n}\n\nbool intersectInside( in vec3 rayOrigin, in vec3 rayDirection, out vec3 position )\n{\n    position = rayOrigin + rayDirection * g_offset;\n        \n    for( int i = 0; i < 1024; ++i )\n    {\n        float distance = sdf( position );\n        position -= rayDirection * distance * g_step;\n        if( distance >= -g_epsilon )\n            return true;\n    }\n    return false;\n}\n\nvec3 light( in vec3 position, in vec3 normal, in vec3 rayDirection )\n{\n    vec3 color = sdfColor( position );\n    float fDiffuse = g_diffuseLight ? max( dot( g_lightDir, normal ), 0.0 ) : 0.0;\n    vec3 halfway = normalize( g_lightDir - rayDirection );\n    float fSpecular = g_specularLight ? pow( max( dot( halfway, normal ), 0.0 ), 10.0 ) : 0.0;\n    vec3 temp;\n    if( g_shadows && intersect( position + g_offset * normal, g_lightDir, temp ) )\n    {\n        fDiffuse = 0.0;\n        fSpecular = 0.0;\n    }\n    color *= fDiffuse;\n    color += fSpecular * vec3( 1, 1, 1 );\n    return color;\n}\n\nbool rayTrace( in vec3 rayOrigin, in vec3 rayDirection, out vec3 position, out vec3 normal, out vec3 color )\n{\n    if( intersect( rayOrigin, rayDirection, position ) )\n    {\n        normal = sdfNormal( position );\n        color = light( position, normal, rayDirection );                \n        return true;\n    }\n    else\n    {\n        color = g_cubeMap ? texture( iChannel0, rayDirection ).xyz : vec3( 0 );\n        return false;\n    }\n}\n\nbool rayRefract( inout vec3 rayOrigin, inout vec3 rayDirection, inout vec3 refractNormal, out vec3 color )\n{\n    vec3 refraction = refract( rayDirection, refractNormal, 0.8 );\n    color = texture( iChannel0, refraction ).xyz;\n    return false;\n    \n    vec3 outPosition;\n    if( intersectInside( rayOrigin, refraction, outPosition ) )\n    {\n        vec3 position;\n        if( intersect( outPosition + g_offset * refraction, refraction, position ) )\n        {\n            vec3 normal = sdfNormal( position );\n            color = light( position, normal, refraction );\n            rayOrigin = position;\n            rayDirection = refraction;\n            refractNormal = normal;\n            return true;\n        }\n        else\n        {\n            color = g_cubeMap ? texture( iChannel0, refraction ).xyz : vec3( 0 );\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    // light direction from mouse position\n    float rotX = (iMouse.x / iResolution.x) * 2.0 * 3.14;\n    float rotY = (iMouse.y / iResolution.y) * 3.14 * 0.5f;\n    g_lightDir = vec3(cos(rotX), cos(rotY), sin(rotX));\n    \n    // ball positions\n    g_pos1 = vec3( sin( iTime * 1.4 ), 0.3 + cos( iTime * 0.4 ) * 0.5, 2.5 );\n    g_pos2 = vec3( -sin( iTime ), 0.2 + sin( iTime * 0.8 ) * 0.5, 2.5 );\n    g_pos3 = vec3( cos( iTime * 4.0 ) * 0.1, sin( iTime ) + 0.5, cos( iTime ) * 0.5 + 2.5 );\n    \n    // camera\n    vec3 camera = vec3( 0.0, 0.0, 0.0 );\n    vec3 direction = normalize( vec3( uv, 1.0 ) );\n    \n    vec3 finalColor;\n    \n    float reflectionInensity = 1.0;\n    for( int i = 0; i < ( g_reflectionSteps + 1 ); ++i )\n    {\n        // cast ray\n        vec3 position;\n        vec3 normal;\n        vec3 color;\n        if( rayTrace( camera, direction, position, normal, color ) )\n        {\n            finalColor += color * reflectionInensity;\n            \n            // calc refraction\n            if( i < g_reflectedRefractionSteps )\n            {\n                float refractionIntensity = 0.5 * reflectionInensity;\n                vec3 refractPos = position;\n                vec3 refractDir = direction;\n                vec3 refractNormal = normal;\n                for( int j = 0; j < ( g_refractionSteps ); ++j )\n                {                 \n                     if( rayRefract( refractPos, refractDir, refractNormal, color ) )\n                     {\n                         finalColor += color * refractionIntensity;\n                     }\n                     else\n                     {\n                         finalColor += color * refractionIntensity;\n                         break;\n                     }\n                     refractionIntensity *= 0.5;\n                }\n            }\n                \n            // calc next reflection\n            direction = reflect( direction, normal );\n            camera = position + g_offset * normal;\n        }\n        else\n        {\n            // ray missed, add background cubemap color and break\n            finalColor += color * reflectionInensity;\n            break;\n        }\n        reflectionInensity *= 0.5;\n    }\n    \n    fragColor = vec4( finalColor, 1 );\n}","name":"Image","description":"","type":"image"}]}