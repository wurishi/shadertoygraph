{"ver":"0.1","info":{"id":"NttGD7","date":"1680385662","viewed":149,"name":"spiralled sun","username":"Carandiru","description":"just feedback from .... cellular automata","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["sun","spiral","maze"],"hasliked":0,"parentid":"NtcGW7","parentname":"Maze Micro Tile"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0);\n    \n    for (float l = 2.0f; l < 10.0f; ++l) {\n        vec4 h = textureLod(iChannel1, uv, l);\n\n        vec3 col = h.xyz - abs(h.xyz - h.x);\n\n        color += col * (1.0f / ((10.0f - l)));\n    }\n    \n    color = clamp(color, vec3(0.0), vec3(1.0));\n\n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float square(in float valx, in float valy, in float eps1, in float eps2)\n{\n    vec2 comp = vec2(0.0);\n    if (valx < eps1 && valx > -eps1) comp.x = 1.0;\n    if (valy < eps2 && valy > -eps2) comp.y = 1.0;\n\n    return comp.x*comp.y;\n}\n\nfloat noise(in vec2 uv, in float seed)\n{\n    float gr = 1.618;\n    return fract(tan(distance(uv*gr, uv)*seed)*uv.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec2 p = vec2(-1.0 +2.0*uv);\n    \n    // pram\n    float Tile = 1.0;\n    float lScale = 1.0;\n    float bias = 0.5 ;\n    \n    float rotate1 = 0.707;\n    float rotate2 = -rotate1;\n    p = fract(p*Tile)-0.5;\n    vec2 p1  = p*0.5;\n    vec2 p2  = p*0.5;\n    p1 *= mat2 (cos(rotate1), -sin(rotate1),\n                sin(rotate1), cos(rotate1));\n    p2 *= mat2 (cos(rotate2), -sin(rotate2),\n                sin(rotate2), cos(rotate2));\n    \n    vec2 res = vec2 ((iResolution.x/iResolution.y)+0.02, 1.00);\n    \n    float seed = ceil(2.0*iTime+1.0);\n    float scale = Tile;\n    \n    \n    vec2 newUV = ceil(vec2 (uv.x, uv.y)*scale);\n    float pix = float(noise(newUV, seed));\n    \n    float sq1 = square(p1.x, p1.y, lScale*0.01, 1.0);\n    float sq2 = square(p2.x, p2.y, lScale*0.01, 1.0);\n    \n    \n    vec4 col = vec4(0.0);\n    col = vec4(smoothstep(0.0f, 0.9f, max(0.0f, pix - bias)));\n    //if (pix > bias) col = vec4(1.0);\n    \n    float t = GOLDEN_RATIO * PI * float(uint(1 << 3));\n    col.xy = uv - 0.5f;\n    col.xy = col.xy * mat2 (cos(t), -sin(t),\n                            sin(t), cos(t));\n    col.xy = col.xy + 0.5f;\n    \n    col.xy = col.xy * 0.5f + 0.5f;\n    col.z = mix(sq1, sq2, 0.5f);\n    col.w = 1.0f;\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n#define directions 8\n\nconst float rule[directions] = float[directions]( 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 1.0, 0.1 );\n\nconst vec4 balance = vec4(0.249999f, 0.24999f, 0.2499f, 0.249f);\n\nfloat state(in float rule[directions], in vec3 s)\n{\n    uint d = 0u;\n    \n    d |= uint(bool(round(s.x))) << 2u;\n    d |= uint(bool(round(s.y))) << 1u;\n    d |= uint(bool(round(s.z))) << 0u;\n    \n    return rule[7u - d];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2) {\n        fragColor = textureLod(iChannel0, fragCoord/1024.0f, 0.0f);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 maze = textureLod(iChannel0, uv, 0.0f);\n    \n    vec2 nuv = (maze.xy * 2.0f - 1.0f) + pow(maze.z, 13.0);\n    \n    mat3 nn[3];\n\n    // tl\n    nn[0][0] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2(-1,-1)).xyz;\n    // t\n    nn[0][1] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2( 0,-1)).xyz;\n    // tr\n    nn[0][2] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2( 1,-1)).xyz;\n       \n    // l\n    nn[1][0] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2(-1, 0)).xyz;\n    // c\n    nn[1][1] = textureLod(iChannel1, nuv, 0.0f).xyz;\n    // r\n    nn[1][2] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2( 0, 1)).xyz;\n        \n    // bl    \n    nn[2][0] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2(-1, 1)).xyz;\n    // b\n    nn[2][1] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2( 0, 1)).xyz;\n    // br\n    nn[2][2] = textureLodOffset(iChannel1, nuv, 0.0f, ivec2( 1, 1)).xyz;\n    \n    nn[0] = transpose(nn[0]);\n    nn[1] = transpose(nn[1]);\n    nn[2] = transpose(nn[2]);\n    \n    mat3 s;\n    s[0] = vec3(state(rule, nn[0][0]), state(rule, nn[0][1]), state(rule, nn[0][2]));\n    s[1] = vec3(state(rule, nn[1][0]), state(rule, nn[1][1]), state(rule, nn[1][2]));\n    s[2] = vec3(state(rule, nn[2][0]), state(rule, nn[2][1]), state(rule, nn[2][2]));\n    \n    s = transpose(s);\n    \n    mat3 nna;\n     \n    nna[0] = s[0] * nn[0] * s[0] * nn[1] * s[0] * nn[2];\n    nna[1] = s[1] * nn[0] * s[1] * nn[1] * s[1] * nn[2];\n    nna[2] = s[2] * nn[0] * s[2] * nn[1] * s[2] * nn[2];\n    \n    s = transpose(s);\n    \n    float h = 0.0f;\n    h += (s[0].x + s[0].y + s[0].z)/3.0f;\n    h += (s[1].x + s[1].y + s[1].z)/3.0f;\n    h += (s[2].x + s[2].y + s[2].z)/3.0f;\n\n        \n    h = h * (1.0f - nn[1][1].x);\n    h = h * (1.0f - nn[1][1].y);\n    h = h * (1.0f - nn[1][1].z);\n    \n    mat4 hm;\n    hm[0] = textureLod(iChannel1, uv, 0.0f);\n    hm[1] = textureLod(iChannel1, uv, 1.0f);\n    hm[2] = textureLod(iChannel1, uv, 2.0f);\n    hm[3] = textureLod(iChannel1, uv, 3.0f);\n    \n    hm = transpose(hm);\n       \n    vec4 bhm = vec4(dot(balance, hm[0]), \n                    dot(balance, hm[1]),\n                    dot(balance, hm[2]),\n                    dot(balance, hm[3]));\n                    \n    h = h + dot(balance, bhm) * balance.x;\n    \n    mat4 hn = transpose(mat4(nna));\n    \n    vec4 bhn = vec4(dot(balance, hn[0]), \n                    dot(balance, hn[1]),\n                    dot(balance, hn[2]),\n                    dot(balance, hn[3]));\n                    \n    vec3 n = mix(bhm.xyz, bhn.xyz, 0.4999f);\n    \n    fragColor = vec4(h, n);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI (3.141592654f)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}","name":"Common","description":"","type":"common"}]}