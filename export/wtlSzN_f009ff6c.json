{"ver":"0.1","info":{"id":"wtlSzN","date":"1562319963","viewed":1114,"name":" GPU hacks #11 - DX11 Compute","username":"PrzemyslawZaworski","description":"Constant step raymarching and two functions to check whether input point is inside tetrahedron (second version is faster). Comment contains DirectX 11 framework for compute shaders - with working example, visually equivalent to visible shader.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","tetrahedron","science","directx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCode tested with Windows 10 and RTX 2070.\nSave file as tetrahedron.c and compile with Visual Studio command line:\ncl.exe tetrahedron.c d3d11.lib dxguid.lib user32.lib kernel32.lib gdi32.lib d3dcompiler.lib\n*/\n\n/*\n#include <Windows.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n\n#define WIDTH 1280 \n#define HEIGHT 720\n\nconst unsigned char ComputeShader[] =\n{\n\t\"RWTexture2D<float4> image : register (u0);\"\n\n\t\"cbuffer Constants : register(b0)\"\n\t\"{\"\n\t\t\"float iTime;\"\n\t\"};\"\n\n\t\"float3x3 rotationX(float x) \"\n\t\"{\"\n\t\t\"return float3x3(1.0,0.0,0.0,0.0,cos(x),sin(x),0.0,-sin(x),cos(x));\"\n\t\"}\"\n\n\t\"float3x3 rotationY(float y) \"\n\t\"{\"\n\t\t\"return float3x3(cos(y),0.0,-sin(y),0.0,1.0,0.0,sin(y),0.0,cos(y));\"\n\t\"}\"\n\n\t\"bool InsideTetrahedron(float3 a, float3 b, float3 c, float3 d, float3 p, out float3 color)\"\n\t\"{\"\n\t\t\"p=mul(rotationY(iTime),mul(rotationX(iTime),p));\"\n\t\t\"float3 vap = p - a;\"\n\t\t\"float3 vbp = p - b;\"\n\t\t\"float3 vab = b - a;\"\n\t\t\"float3 vac = c - a;\"\n\t\t\"float3 vad = d - a;\"\n\t\t\"float3 vbc = c - b;\"\n\t\t\"float3 vbd = d - b;\"\n\t\t\"float va6 = dot(vbp, cross(vbd, vbc));\"\n\t\t\"float vb6 = dot(vap, cross(vac, vad));\"\n\t\t\"float vc6 = dot(vap, cross(vad, vab));\"\n\t\t\"float vd6 = dot(vap, cross(vab, vac));\"\n\t\t\"float v6 = 1.0 / dot(vab, cross(vac, vad));\"\n\t\t\"float4 k =  float4(va6*v6, vb6*v6, vc6*v6, vd6*v6);\"\n\t\t\"if ((k.x >= 0.0) && (k.x <= 1.0) && (k.y >= 0.0) && (k.y <= 1.0) && (k.z >= 0.0) && (k.z <= 1.0) && (k.w >= 0.0) && (k.w <= 1.0))\"\n\t\t\"{\"\n\t\t\t\"color = k.rgb;\"\n\t\t\t\"return true;\"\n\t\t\"}\"\n\t\t\"else\"\n\t\t\"{\"\n\t\t\t\"color = float3(0.0,0.0,0.0);\"\n\t\t\t\"return false;\"\n\t\t\"}\"          \n\t\"}\"\n\n\t\"float4 raymarch (float3 ro, float3 rd)\"\n\t\"{\"\n\t\t\"float3 color = 0..xxx;\"\n\t\t\"for (int i = 0; i < 512; i++)\"\n\t\t\"{\"\n\t\t\t\"bool hit = InsideTetrahedron(float3(0.943, 0, -0.333 ),float3( -0.471, 0.816, -0.333), float3( -0.471, -0.816, -0.333), float3(0, 0, 1 ),ro,color);\"\n\t\t\t\"if (hit) return float4(color,1.0);\"\n\t\t\t\"ro += rd * 0.01;\"\n\t\t\"}\"\n\t\t\"return float4(0,0,0,1);\"\n\t\"}\"\n\n\t\"[numthreads(8, 8, 1)]\"\n\t\"void main (uint3 id : SV_DispatchThreadID)\"\n\t\"{\"\n\t\t\"float2 uv = (2.*id.xy - float2(1280, 720)) / 720.0;\"\n\t\t\"image[id.xy] = raymarch(float3(0,0.0,-2.5), normalize(float3(uv,2.)));\"\n\t\"}\"\n};\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif ((uMsg == WM_KEYUP && wParam == VK_ESCAPE) || uMsg==WM_CLOSE || uMsg==WM_DESTROY)\n\t{\n\t\tPostQuitMessage(0); return 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"DirectX 11\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"DirectX 11\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, WIDTH, HEIGHT, 0, 0, 0, 0);\t\n\tID3D11Device *device;\n\tIDXGISwapChain *surface;\n\tID3D11DeviceContext *context;\n\tID3D11Buffer *buffer;      \n\tID3D11UnorderedAccessView *uav; \n\tID3D11Texture2D *image;\t\n\tID3D11ComputeShader *shader;\n\tD3D11_MAPPED_SUBRESOURCE resource;\t\n\tDXGI_SWAP_CHAIN_DESC sd = {{WIDTH, HEIGHT, 0, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 0 }, {1, 0}, (1L << (1 + 4)) | (1L << (6 + 4)) | (1L << (0 + 4)), 1, hwnd, 1, 1, 0};\n\tD3D11CreateDeviceAndSwapChain(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, 0, 0, D3D11_SDK_VERSION, &sd, &surface, &device, 0, &context);\n\tsurface->lpVtbl->GetDesc(surface, &sd); \t\n\tsurface->lpVtbl->GetBuffer(surface, 0, (REFIID) &IID_ID3D11Texture2D, ( LPVOID* )&image );\n\tD3D11_BUFFER_DESC desc = {16, D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE, 0, 0};\t\n\tdevice->lpVtbl->CreateBuffer(device, &desc, NULL, &buffer);\n\tdevice->lpVtbl->CreateUnorderedAccessView(device,(ID3D11Resource*)image, NULL, &uav );\t\n\tID3DBlob* blob;\n\tD3DCompile(&ComputeShader, sizeof ComputeShader, 0, 0, 0, \"main\", \"cs_5_0\", 1 << 15, 0, &blob, 0);\t\t\n\tdevice->lpVtbl->CreateComputeShader(device, blob->lpVtbl->GetBufferPointer(blob), blob->lpVtbl->GetBufferSize(blob), NULL, &shader);\n\twhile (!exit)\n\t{\n\t\twhile (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif (msg.message == WM_QUIT) exit = 1;\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\t\t\n\t\tcontext->lpVtbl->Map(context,(ID3D11Resource*)buffer, 0, D3D11_MAP_WRITE_DISCARD, 0,  &resource);\n\t\tfloat time[] = {GetTickCount() * 0.001f};\n\t\tmemcpy(resource.pData, time, sizeof(float));\t\t\n\t\tcontext->lpVtbl->Unmap(context, (ID3D11Resource *)buffer, 0);\n\t\tcontext->lpVtbl->CSSetShader(context, shader, NULL, 0 );\n\t\tcontext->lpVtbl->CSSetUnorderedAccessViews(context, 0, 1, &uav, NULL );\n\t\tcontext->lpVtbl->CSSetConstantBuffers(context, 0, 1, &buffer );\t\t\t\n\t\tcontext->lpVtbl->Dispatch(context, WIDTH  / 8, HEIGHT  / 8, 1 );\n\t\tsurface->lpVtbl->Present( surface, 0, 0 );\n\t}\n\tcontext->lpVtbl->ClearState(context);\n\tdevice->lpVtbl->Release(device);\n\tsurface->lpVtbl->Release(surface);\t \n\timage->lpVtbl->Release(image);\t\n\tbuffer->lpVtbl->Release(buffer);\n\tuav->lpVtbl->Release(uav);\n\treturn 0; \n}\n*/\n\nmat3 rotationX( float x) \n{\n\treturn mat3(1.0,0.0,0.0,0.0,cos(x),sin(x),0.0,-sin(x),cos(x));\n}\n\nmat3 rotationY( float y) \n{\n\treturn mat3(cos(y),0.0,-sin(y),0.0,1.0,0.0,sin(y),0.0,cos(y));\n}\n\nbool InsideTetrahedronI(vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 p, out vec3 color)\n{\n    p=rotationY(iTime)*rotationX(iTime)*p;\n\tmat4 D0 = mat4(v1[0],v1[1],v1[2],1.0f,v2[0],v2[1],v2[2],1.0f,v3[0],v3[1],v3[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D1 = mat4(p[0],p[1],p[2],1.0f,v2[0],v2[1],v2[2],1.0f,v3[0],v3[1],v3[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D2 = mat4(v1[0],v1[1],v1[2],1.0f,p[0],p[1],p[2],1.0f,v3[0],v3[1],v3[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D3 = mat4(v1[0],v1[1],v1[2],1.0f,v2[0],v2[1],v2[2],1.0f,p[0],p[1],p[2],1.0f,v4[0],v4[1],v4[2],1.0f);\n\tmat4 D4 = mat4(v1[0],v1[1],v1[2],1.0f,v2[0],v2[1],v2[2],1.0f,v3[0],v3[1],v3[2],1.0f,p[0],p[1],p[2],1.0f);\n\tfloat a = determinant(D0);\n\tfloat b = determinant(D1);\n\tfloat c = determinant(D2);\n\tfloat d = determinant(D3);\n\tfloat e = determinant(D4);\n\tif ( (sign(a)==sign(b)) &&  (sign(a)==sign(c)) && (sign(a)==sign(d)) && (sign(a)==sign(e)) )\n    {\n        color = 0.33-p;\n        return true;\n    }  \n    else\n    {\n        color = vec3(0.0);\n        return false;\n    }    \n}\n\nbool InsideTetrahedronII(vec3 a, vec3 b, vec3 c, vec3 d, vec3 p, out vec3 color)\n{\n    p=rotationY(iTime)*rotationX(iTime)*p;\n    vec3 vap = p - a;\n    vec3 vbp = p - b;\n    vec3 vab = b - a;\n    vec3 vac = c - a;\n    vec3 vad = d - a;\n    vec3 vbc = c - b;\n    vec3 vbd = d - b;\n    float va6 = dot(vbp, cross(vbd, vbc));\n    float vb6 = dot(vap, cross(vac, vad));\n    float vc6 = dot(vap, cross(vad, vab));\n    float vd6 = dot(vap, cross(vab, vac));\n    float v6 = 1.0 / dot(vab, cross(vac, vad));\n    vec4 k =  vec4(va6*v6, vb6*v6, vc6*v6, vd6*v6);\n    if ((k.x >= 0.0) && (k.x <= 1.0) && (k.y >= 0.0) && (k.y <= 1.0) && (k.z >= 0.0) && (k.z <= 1.0) && (k.w >= 0.0) && (k.w <= 1.0))\n    {\n        color = k.rgb;\n        return true;\n    }\n    else\n    {\n        color = vec3(0.0);\n        return false;\n    }         \n}\n\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n\tfor (int i = 0; i < 512; i++)\n\t{\n \t\tbool hit = InsideTetrahedronII(vec3(0.943, 0, -0.333 ),vec3( -0.471, 0.816, -0.333), vec3( -0.471, -0.816, -0.333), vec3(0, 0, 1 ),ro,color);\n \t\tif (hit) return vec4(color,1.0); \n    \tro += rd * 0.01;\n     }\n\treturn vec4(0,0,0,1);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\tvec2 uv = (2. * f.xy - iResolution.xy) / iResolution.y;\n\to = raymarch(vec3 (0,0.0,-3.),normalize(vec3(uv,2.)));\n}","name":"Image","description":"","type":"image"}]}