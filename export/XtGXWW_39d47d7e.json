{"ver":"0.1","info":{"id":"XtGXWW","date":"1484630834","viewed":222,"name":"SandRose","username":"balkhan","description":"a little experiment","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// raymarching defines\n\n#define I_MAX\t150\n#define EPSIL\t0.00001\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n// these defines change the shapes\n\n#define MAGIC\n#define INVERSION\n#define FIRST\n\n//change the colors\n\n//#define COLOR_AO\n#define COLOR_SAHARA\n#define COLOR_SINS\n\nfloat\tde(vec3 pos);\nmat4\tlookat(vec3 eye, vec3 target, vec3 up);\nvec2 \tcmult(vec2 a, vec2 b);\nvec4\tmarch(vec3 pos, vec3 dir);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\tcol = vec4(0.0);\n\tvec3\tdir = normalize(vec3(fragCoord.xy - iResolution.xy/2.0, -iResolution.y));\n    vec3\tpos = vec3(-2.0, 0.0, 2.0);\n    mat4\tlook = lookat(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    dir = vec3(dot(dir, look[0].xyz), dot(dir, look[1].xyz), dot(dir, look[2].xyz));\n   \tvec4 inter = (march(pos, dir));\n\n    #ifdef COLOR_AO\n    col.xyz = vec3(1.0-inter.w/float(I_MAX));\n    #elif defined COLOR_SAHARA\n    col.z += (sin(      inter.w/float(I_MAX)));\n  \tcol.x += (sin(1.57+ inter.w/float(I_MAX)));\n    col.y += (sin(0.78+ inter.w/float(I_MAX)));\n    #else\n    col.z += (1. * (0. + sin(inter.w/float(I_MAX))));\n    col.y += (1. * ( + sin(sin(iTime)*.05+inter.w/float(I_MAX))));\n \tcol.x += pow(sin(inter.x*(0.+sin(iTime+3.14+inter.w/float(I_MAX)))/5.), 20.);\n    #endif\n   \tfragColor = col;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = de(p)*.5;\n        dist.y += dist.x;\n        if (dist.x < EPSIL)\n        {\n            step.y=dist.x;\n            break;\n        }\n        step.w++;\n    }step.x = dist.y;\n    return (step);\n}\n\nfloat\tde(vec3 pos)\n{\n    pos.yz*=mat2(cos(iTime), sin(iTime),-sin(iTime),cos(iTime));\n\tvec3 z = pos;\n\tfloat r = 0.0;\n\t\tr = length(z);\n #ifdef FIRST\n\t\tfloat theta = asin( z.z/r );\n #else\n \t\tfloat theta = asin((z.x/r+z.y/r)*z.z/r);//2nd\n #endif\n\t\tfloat phi = atan((z.y/r), (z.x/r));\n\t\ttheta = theta * 5.0;\n\t\tphi = phi * 10.0;\n #ifdef INVERSION\n        theta = cmult(vec2(theta), vec2(r,1.0/r)).x;\n #endif\n #ifdef FIRST\n\t\tz = vec3(z.x+sin(theta), z.y-cos(theta+(iTime/2.)*20.), cos(-phi)*(z.z)*(sin(phi)/1.) );\n #else\n\t\tz = vec3(z.x+sin(z.z+theta), z.y-cos(z.z+theta+(iTime/2.)*20.), (z.z) );\n #endif\n #ifdef MAGIC\n \t\tz*=pos+length(z)/5.;\n #endif\n \tr = r-length(z)/4.-.2025;\n\treturn r-.3;\n}\n\nmat4\tlookat(vec3 e, vec3 ta, vec3 up)\n{\n    vec3 z = normalize(e - ta);    \n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);     \n\n    mat4 orientation = mat4(\n       \t\t\t\t\t\tx.x, y.x, z.x, 0.0,\n       \t\t\t\t\t\tx.y, y.y, z.y, 0.0,\n       \t\t\t\t\t\tx.z, y.z, z.z, 0.0,\n       \t\t\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\n    mat4 translation = mat4(\n         \t\t\t\t\t1.0, 0.0, 0.0, 0.0,\n         \t\t\t\t\t0.0, 1.0, 0.0, 0.0, \n         \t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t-e.x,-e.y,-e.z, 1.0);\n\n    return (orientation * translation);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n","name":"Image","description":"","type":"image"}]}