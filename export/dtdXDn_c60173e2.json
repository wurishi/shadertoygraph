{"ver":"0.1","info":{"id":"dtdXDn","date":"1685294054","viewed":74,"name":"[apathyhill] My Logo","username":"apathyhill","description":"Recreation of my logo using distance fields.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* [CONSTANTS] */\n\n// Coordinates\nconst vec2 P_STAR_0    = vec2(5.70633909777, -1.8541019662496845);\nconst vec2 P_STAR_1    = vec2(3.526711513754839, 4.854101966249685);\nconst vec2 P_STAR_2    = vec2(-3.526711513754839, 4.854101966249685);\nconst vec2 P_STAR_TIP  = vec2(0.0, 15.70820393249937);\nconst vec2 OFFSET_STAR = vec2(-12.835484859184442, 0.0);\n\n// Angles\nconst float A_90  = 1.5707963267948966;\nconst float A_180 = 3.141592653589793;\nconst float A_270 = 4.71238898038469;\nconst float A_360 = 6.283185307179586;\nconst mat2  ROT   = mat2(\n    vec2(0.30901699437494745, 0.9510565162951535), \n    vec2(-0.9510565162951535, 0.30901699437494745)\n);\n\n// Sizing\nconst float BBOX_L = -23.670969718368884;\nconst float BBOX_W = 91.67096971836888;\n\n// Styling\nconst float W_STROKE  = 1.0;\nconst float W_EDGE    = 0.1;\nconst float R_TEXT    = 3.0;\nconst float R_STAR    = 6.0;\nconst vec3  COL_BG    = vec3(0.0625);\nconst vec3  COL_MAIN  = floor(vec3(0.25, 0.75, 0.75)*255.0)/255.0;\nconst vec3  COL_WHITE = vec3(1.0);\n\n/* [DISTANCE FUNCTIONS] */\n\n// Point\nfloat DistPoint(vec2 p, vec2 a) {\n    return length(p - a);\n}\n\n// Line Segment\nfloat DistSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b - a;\n    float lSqr = dot(ba, ba);\n    if (lSqr == 0.0) return distance(p, a);\n    float t = clamp(dot(p - a, ba) / lSqr, 0.0, 1.0);\n    vec2 pLine = a + t * ba;\n    return distance(p, pLine);\n}\n\n// Quadratic Bezier Approximation\nfloat DistBezier(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    vec2 p01 = p0 - p1;\n    vec2 p21 = p2 - p1;\n    \n    vec2 pLine1 = p0;\n    float d = DistPoint(p, pLine1);\n    \n    for (float t = 0.0; t <= 1.0; t += 0.03125) {\n        vec2 pLine2 = p1 + (1.0 - t) * (1.0 - t) * p01 + t * t * p21;\n        d = min(d, DistSegment(p, pLine1, pLine2));\n        pLine1 = pLine2;\n    }\n    \n    return d;\n}\n\n// Circular Arc Approximation \nfloat DistArc(vec2 p, vec2 c, float r, float a0, float a1) {\n    float a10 = a1 - a0;\n    \n    vec2 pLine1 = c + vec2(cos(a0), sin(a0)) * r;\n    float d = DistPoint(p, pLine1);\n    \n    for (float t = 0.0; t <= 1.0; t += 0.03125) {\n        float a = a0 + t * a10;\n        vec2 pLine2 = c + vec2(cos(a), sin(a)) * r;\n        d = min(d, DistSegment(p, pLine1, pLine2));\n        pLine1 = pLine2;\n    }\n    \n    return d;\n}\n\n\n// \"Main\"\nfloat DistMain(vec2 p) {\n    p.x = abs(p.x);\n    \n    float d = DistBezier(p, P_STAR_2, P_STAR_TIP, P_STAR_1);\n    d = min(d, DistSegment(p, P_STAR_1, P_STAR_0));\n    d = min(d, DistSegment(p, vec2(3.5, 3), vec2(0, 3)));\n    \n   return d - W_STROKE; \n}\n\n// Star\nfloat DistStar(vec2 p) {\n    p.x = abs(p.x);\n    \n    float d = DistBezier(p, P_STAR_2, P_STAR_TIP, P_STAR_1);\n    p = ROT * p;\n    d = min(d, DistBezier(p, P_STAR_2, P_STAR_TIP, P_STAR_1));\n    p = ROT * p;\n    d = min(d, DistBezier(p, P_STAR_2, P_STAR_TIP, P_STAR_1));\n\n    return d - W_STROKE;\n}\n\n\nfloat DistText(vec2 p) {\n    // p\n    float d = DistSegment(p, vec2(1, -7), vec2(1, 0));\n    d = min(d, DistArc(p, vec2(4, 0), R_TEXT, -A_90, A_180));\n    // a\n    d = min(d, DistArc(p, vec2(14, 0), R_TEXT, 0.0, A_270));\n    d = min(d, DistSegment(p, vec2(17, 0), vec2(17, -3)));\n    // t\n    d = min(d, DistSegment(p, vec2(23, -3), vec2(23, 7)));\n    d = min(d, DistSegment(p, vec2(21, 3), vec2(25, 3)));\n    // h\n    d = min(d, DistSegment(p, vec2(29, -3), vec2(29, 7)));\n    d = min(d, DistArc(p, vec2(32, 0), R_TEXT, 0.0, A_180));\n    d = min(d, DistSegment(p, vec2(35, -3), vec2(35, 0)));\n    // y\n    d = min(d, DistSegment(p, vec2(45, 3), vec2(45, -7)));\n    d = min(d, DistArc(p, vec2(42, 0), R_TEXT, A_180, A_360));\n    d = min(d, DistSegment(p, vec2(39, 3), vec2(39, 0)));\n    // h\n    d = min(d, DistSegment(p, vec2(49, -3), vec2(49, 7)));\n    d = min(d, DistArc(p, vec2(52, 0), R_TEXT, 0.0, A_180));\n    d = min(d, DistSegment(p, vec2(55, -3), vec2(55, 0)));\n    // i\n    d = min(d, DistSegment(p, vec2(59, -3), vec2(59, 3)));\n    d = min(d, DistPoint(p, vec2(59, 7)));\n    // ll\n    d = min(d, DistSegment(p, vec2(63, -3), vec2(63, 7)));\n    d = min(d, DistSegment(p, vec2(67, -3), vec2(67, 7)));\n    \n    return d - W_STROKE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Map UV\n    vec2 uv = (fragCoord - vec2(0.0, iResolution.y * 0.5)) / iResolution.x * BBOX_W;\n    uv += vec2(BBOX_L, sin(iTime * 4.0) * 0.5);\n  \n    // Get distances\n    float dMain = DistMain(uv - OFFSET_STAR);\n    float dWhite = min(DistStar(uv - OFFSET_STAR), DistText(uv));\n    dWhite = smoothstep(0.0, -W_EDGE, dWhite) * smoothstep(-W_EDGE, 0.0, dMain-W_STROKE);\n    dMain = smoothstep(0.0, -W_EDGE, dMain);\n    \n    // Draw shapes\n    vec3 col = COL_BG;\n    col = mix(col, COL_WHITE, dWhite);\n    col = mix(col, COL_MAIN, dMain);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}