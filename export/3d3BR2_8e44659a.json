{"ver":"0.1","info":{"id":"3d3BR2","date":"1605653847","viewed":96,"name":"PAC-MAN Hallway","username":"Firal","description":"Day 3 of my 30 days of shaders (not all are going to be public).\nThis is a short animation of PAC-MAN going down a 'hallway' in his game, re-imagined in 3D by utilizing the SDF I derived yesterday for a partial sphere.\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["retro","pacman","firal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://www.shadertoy.com/view/3d3BR2\nMade by Firal (Zack Misso)\n*/\n\nvoid map_walls(vec3 p,\n               inout float global_dist,\n               inout int render_type)\n{\n    float dist = -sdBox(p, vec3(200.0, 6.0, 6.0));\n    if (dist < global_dist)\n    {\n        global_dist = dist;\n        render_type = 0;\n    }\n}\n\nvoid map_pac(vec3 p,\n             inout float global_dist,\n             inout int render_type)\n{\n    float dist = sdPartialSphere(p + vec3((140.0 - mod(iTime * 10.0, 10.0 * 5.5 * 2.f * PI / 2.1f)), 0.0, 0.0), 3.f, PI / 2.6 * abs(cos(iTime * 2.1 + PI / 2.0)));\n    if (dist < global_dist)\n    {\n\t\tglobal_dist = dist;\n        render_type = 1;\n    }\n}\n\nvoid map_orbs(vec3 p,\n              inout float global_dist,\n              inout int render_type)\n{\n    float freq = 2.f * PI / 2.1f;\n    float anim_length = 5.5 * 2.f * PI / 2.1f;\n \tfloat dist = 1000000000.0;\n    \n    if (mod(iTime, anim_length) < 1.0 * freq)\n    \tdist = min(dist, sdSphere(p + vec3(110.0, 0.0, 0.0), 0.7));\n    if (mod(iTime, anim_length) < 2.0 * freq)\n    \tdist = min(dist, sdSphere(p + vec3(80.0, 0.0, 0.0), 0.7));\n    if (mod(iTime, anim_length) < 3.0 * freq)\n    \tdist = min(dist, sdSphere(p + vec3(50.0, 0.0, 0.0), 0.7));\n    if (mod(iTime, anim_length) < 4.0 * freq)\n    \tdist = min(dist, sdSphere(p + vec3(20.0, 0.0, 0.0), 0.7));\n    if (mod(iTime, anim_length) < 5.0 * freq)\n    \tdist = min(dist, sdSphere(p + vec3(-10.0, 0.0, 0.0), 0.7));\n    \n    if (dist < global_dist)\n    {\n\t\tglobal_dist = dist;\n        render_type = 2;\n    }\n}\n\nfloat map(vec3 p, inout int render_type)\n{\n    float dist = 1.0e10;\n    map_walls(p, dist, render_type);\n    map_pac(p, dist, render_type);\n    map_orbs(p, dist, render_type);\n    return dist;\n}\n\n\nvec3 computeNormal(vec3 p)\n{\n    vec3 eps = vec3(EPSILON,0.0,0.0);\n    int tmp = 0;\n    vec3 normal = normalize( vec3(\n        map(p+eps.xyy, tmp) - map(p-eps.xyy, tmp),\n        map(p+eps.yxy, tmp) - map(p-eps.yxy, tmp),\n        map(p+eps.yyx, tmp) - map(p-eps.yyx, tmp)));\n    \n    return normal;\n}\n\nvec3 computeNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon,0.0,0.0);\n    int tmp = 0;\n    vec3 normal = normalize( vec3(\n        map(p+eps.xyy, tmp) - map(p-eps.xyy, tmp),\n        map(p+eps.yxy, tmp) - map(p-eps.yxy, tmp),\n        map(p+eps.yyx, tmp) - map(p-eps.yyx, tmp)));\n    \n    return normal;\n}\n\nbool sphere_tracing(ray r,\n               \t\tint max_iter,\n               \t\tout int render_type,\n               \t\tout vec3 hit_loc,\n               \t\tout int iters)\n{\n    hit_loc = r.origin;\n    bool hit = false;\n    int r_type = -1;\n    \n    float dist = 0.0;\n    int i = 0;\n    \n    for (; i < max_iter; ++i)\n    {\n        vec3 p = r.origin + r.direction * dist;\n\t\t        \n        float next_step = map(p, r_type);\n        \n        if (next_step < EPSILON)\n        {\n            hit_loc = p;\n            iters = i;\n            render_type = r_type;\n            return true;\n        }\n        \n        dist += next_step;\n    }\n    \n    iters = i;\n    \n    return false;\n}\n\nvec3 shade(vec3 p, int iters, int render_type)\n{\n    vec3 shade_color = vec3(0.0);\n    \n    if (render_type == 0)\n    {\n        vec3 eps = vec3(EPSILON,0.0,0.0);\n        vec3 actual_normal = computeNormal(p);\n        vec3 blurred_normal = computeNormal(p, 0.4);\n        \n        shade_color = vec3(0.002) + vec3(0.1, 0.1, 1.0) * (1.0 - pow(abs(dot(actual_normal, blurred_normal)), 2.f));\n    }\n    else if (render_type == 1)\n    {\n        vec3 eps = vec3(0.05,0.0,0.0);\n        vec3 normal = computeNormal(p);\n        \n        vec3 normal_1 = computeNormal(p + eps.xyy);\n        vec3 normal_2 = computeNormal(p - eps.xyy);\n        vec3 normal_3 = computeNormal(p + eps.yxy);\n        vec3 normal_4 = computeNormal(p - eps.yxy);\n        vec3 normal_5 = computeNormal(p + eps.yxy);\n        vec3 normal_6 = computeNormal(p - eps.yyx);\n        \n        float diff = abs(dot(normal, normal_1));\n        diff = min(diff, abs(dot(normal, normal_2)));\n        diff = min(diff, abs(dot(normal, normal_3)));\n        diff = min(diff, abs(dot(normal, normal_4)));\n        diff = min(diff, abs(dot(normal, normal_5)));\n        diff = min(diff, abs(dot(normal, normal_6)));\n        \n        vec3 dir_to_light = normalize(vec3(1.0, 1.0, 0.0));\n        vec3 two_tone_color_a = vec3(0.5, 0.5, 0.0);\n        vec3 two_tone_color_b = vec3(0.00, 0.00, 0.00);\n        \n        vec3 eye = vec3(20.0, 0.0, 4.0);\n        vec3 eye2p = normalize(p - eye);\n        \n        float theta = acos(dot(dir_to_light, normal));\n        vec3 result = vec3(0.0);\n        \n        if (theta < PI * 0.5)\n        {\n            result = (1.0 - sin(theta) * 0.5) * two_tone_color_a +\n                     sin(theta) * 0.5 * two_tone_color_b;\n        }\n        else\n        {\n            result = (1.0 - sin(theta) * 0.5) * two_tone_color_b +\n                     sin(theta) * 0.5 * two_tone_color_a;\n        }\n        \n        vec3 fresnel_normal = clamp(normal, 0.f, 1.f);\n        \n        shade_color = result + vec3(1.0, 1.0, 0.0) * pow(1.0 - diff, 2.0f) +\n            \t\t\t\t   vec3(1.0, 1.0, 0.0) * pow(1.0 - abs(dot(eye2p, fresnel_normal)), 10.f);\n    }\n    else if (render_type == 2)\n    {\n        vec3 dir_to_light = normalize(vec3(1.0, 1.0, 0.0));\n        vec3 two_tone_color_a = vec3(0.5, 0.5, 0.5);\n        vec3 two_tone_color_b = vec3(0.00, 0.00, 0.00);\n        \n        vec3 normal = computeNormal(p);\n        vec3 eye = vec3(20.0, 0.0, 4.0);\n        vec3 eye2p = normalize(p - eye);\n           \n        float theta = acos(dot(dir_to_light, normal));\n        vec3 result = vec3(0.0);\n        \n        if (theta < PI * 0.5)\n        {\n            result = (1.0 - sin(theta) * 0.5) * two_tone_color_a +\n                     sin(theta) * 0.5 * two_tone_color_b;\n        }\n        else\n        {\n            result = (1.0 - sin(theta) * 0.5) * two_tone_color_b +\n                     sin(theta) * 0.5 * two_tone_color_a;\n        }\n        \n        shade_color = 1.3*result + vec3(0.1, 0.1, 1.0) * pow(1.0 - dot(eye2p, normal), 2.f);\n    }\n    else\n    {\n        shade_color = vec3(0.0);\n    }\n    \n    vec3 eye = vec3(20.0, 0.0, 4.0);\n    \n    return shade_color * exp(-0.02 * length(eye - p));\n}\n\nvec3 render(vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    camera cam;\n    \n    float anim_length = 5.5 * 2.f * PI / 2.1f * 2.f;\n    \n    float sgn = sign(1.0 - mod(iTime, anim_length) / (anim_length / 2.0));\n    \n    cam = camera_const(vec3(20.0, 1.0, sgn * 4.0),\n    \t\t\t\t   vec3(4.0, 0.0, 0.0),\n                       vec3(0.0, 1.0, 0.0),\n                       18.0,\n                       1280.0 / 720.0,\n                       0.0,\n                       sqrt(27.0));\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    ray r = camera_get_ray(cam, uv);\n    \n    int max_iter = 800;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc;\n    int iters;\n    bool hit;\n    int render_type = -1;\n    \n    if (sphere_tracing(r, max_iter, render_type, hit_loc, iters))\n    {\n        col = shade(hit_loc, iters, render_type);\n    }\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nhttps://www.shadertoy.com/view/3d3BR2\nMade by Firal (Zack Misso)\nTwitter: @ossim_zack\n*/\n\n// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n    \n//\n// Ray\n//\n    \nstruct ray\n{\n    vec3 origin;            // this is the origin of the ray\n    vec3 direction;         // this is the direction the ray is pointing in\n};\n    \n//\n// Camera\n//\n    \nstruct camera\n{\n    vec3 origin;            // this is the origin of your camera\n    vec3 lower_left_corner; // this is the location of the lower-left corner of the image in relation to the origin\n    vec3 horizontal;        // this is the horizontal extents of the image the camera sees\n    vec3 vertical;          // this is the vertical extents of the image the camera sees\n    vec3 u;\n    vec3 v;\n    float lens_radius;      // the radius of the lens\n};\n    \ncamera camera_const(vec3 lookfrom,\n                    vec3 lookat,\n                    vec3 up,\n                    float fov,\n                    float aspect,\n                    float aperture,\n                    float focal_dist)\n{\n    camera cam;\n    \n    vec3 w;\n    \n    cam.lens_radius = aperture / 2.0;\n    \n    float theta = fov * PI / 180.0;\n    float half_height = tan(theta / 2.0);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(up, w));\n    cam.v = cross(w, cam.u);\n    cam.lower_left_corner = cam.origin - half_width * cam.u * focal_dist - half_height * cam.v * focal_dist - w * focal_dist;\n    cam.horizontal = 2.0 * half_width * cam.u * focal_dist;\n    cam.vertical = 2.0 * half_height * cam.v * focal_dist;\n    \n    return cam;\n}\n\nray camera_get_ray(camera cam, vec2 uv)\n{\n    ray r;\n    \n    r.origin = cam.origin;\n    r.direction = normalize(cam.lower_left_corner + uv.x * cam.horizontal +\n                            uv.y * cam.vertical - cam.origin);\n    \n    return r;\n}\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n// returns the signed distance to a box from position p\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// The sdf for a sphere which is partially rendered. It is computed as the combined sdf\n// between a sphere, and two planes intersecting the sphere according to the angle which\n// is passed in as a parameter.\nfloat sdPartialSphere(vec3 p, float r, float max_angle)\n{\n    // hard coding axis and normal for now. The normal is the direction tangential to\n    // both of the lips. Axis is where the lips start\n    vec3 axis = vec3(1.0, 0.0, 0.0);\n    vec3 norm = vec3(0.0, 0.0, 1.0);\n    //max_angle = 0.1;\n    \n    // compute the tanget vector\n    vec3 tang = cross(norm, axis);\n    \n    // we want the angle between the projection onto the tangent\n    float angle = acos(dot(normalize(vec3(p.x, p.y, 0.0)), axis));\n    \n    // hack because if a value is perfectly along the axis, there are some artifacts\n    if (abs(p.x) < 1.0e-4) return length(p) - r;\n    \n    if (angle < max_angle)\n    {\n        // compute the closest lip, the other can be ignored\n        float max_a = max_angle * sign(dot(tang, p));\n        \n        // direction of the closest 'lip'\n        vec3 dir = vec3(axis.x * cos(max_a) - axis.y * sin(max_a),\n                        axis.x * sin(max_a) + axis.y * cos(max_a),\n                        0.f);\n\n        \n        // normal vector for the plane of the 'lip'\n        vec3 norm_dir = cross(norm, dir);\n        \n        // project the point onto the infinite plane\n        vec3 plane_point = p - norm_dir * dot(p, norm_dir);\n        \n        // project the point back onto the intersection between the sphere and the plane.\n        plane_point = max(sign(dot(dir, plane_point)), 0.0) * \n            \t\t  min(length(plane_point), r) * \n            \t\t  normalize(plane_point);\n        \n        // project the point onto the base line of the sphere\n        vec3 base_p = p;\n        base_p.z = 0.0;\n\n        // return the min of the projected point and the distance to the center line.\n        return min(length(base_p), length(p-plane_point));\n    }\n    \n    // compute distance to the sphere\n    float dist = length(p) - r;\n    \n    // TODO: there is probably some optimization I can do to avoid these if statements, but\n    //       I'll look into that later.\n    // if the point is inside the sphere, we need to correctly account for the 'lips'\n    if (dist < 0.0 && max_angle != 0.0)\n    {\n        // compute the closest lip, the other can be ignored\n        float max_a = max_angle * sign(dot(tang, p));\n        \n        // direction of the closest 'lip'\n        vec3 dir = vec3(axis.x * cos(max_a) - axis.y * sin(max_a),\n                        axis.x * sin(max_a) + axis.y * cos(max_a),\n                        0.f);\n        \n        // normal vector for the plane of the 'lip'\n        vec3 norm_dir = cross(norm, dir);\n        \n        // project the point onto the infinite plane\n        vec3 plane_point = p - norm_dir * dot(p, norm_dir);\n        \n        // project the point back onto the intersection between the sphere and the plane.\n        plane_point = max(sign(dot(dir, plane_point)), 0.0) * \n            \t\t  min(length(plane_point), r) * \n            \t\t  normalize(plane_point);\n        \n        // project the point onto the base line of the sphere\n        vec3 base_p = p;\n        base_p.z = 0.0;\n\n        // return the min of the projected point and the distance to the center line. Returns\n        // the negative since the point is inside the sdf.\n        return -min(length(base_p), min(-dist, length(p-plane_point)));\n    }\n    \n    \n    return dist;\n}","name":"Common","description":"","type":"common"}]}