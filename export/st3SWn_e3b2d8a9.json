{"ver":"0.1","info":{"id":"st3SWn","date":"1639592649","viewed":171,"name":"Bezier SDF 7.0","username":"CasanovaI","description":"Distancia a una curva de Bezier cuadrática. Inspirado por videos de Íñigo Quilez","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//SDF of a quadratic Bezier curve\n\nfloat tSDF(vec2 p, float t, vec2 A, vec2 B, vec2 C){ //distancia a curva basada en t\n    vec2 S;\n    S += (t*t - 2.*t + 1.) * A;\n    S += (-2.*t*t + 2.*t) * B;\n    S += (t*t) * C;\n    \n    return length(S-p);\n}\n\nfloat cubicNewton(float g, float a, float b, float c, float d){ //método de newton para encontrar raíces, g es la primera estimación\n    float m = 1.;\n    \n    for(int i = 0; i < 200; i++){//límite de precisión\n        float func = a*(g*g*g) + b*(g*g) + c*(g) + d; //función evaluada\n        float der = 3.*a*(g*g) + 2.*b*(g) + c;        //derivada evaluada\n        \n        if(der == 0.0){\n            g += 0.1;//evitar dividir entre 0\n        }else{\n            m = -func/der;\n            g += m;\n        }\n    }\n    return g;\n}\n\nfloat SDF(vec2 p, vec2 A, vec2 B, vec2 C){ //Función final\n\n    //Coeficientes para la función de distancia basada en t\n    vec2 alpha = -A + 2.*B - C;\n    vec2 beta = 2.*A -2.*B;\n    vec2 gamma = -A + p;\n    \n    //coeficientes de la segunda función de distancia\n    float a = alpha.x * alpha.x + alpha.y * alpha.y; \n    float b = 2. * (alpha.x * beta.x + alpha.y * beta.y);\n    float c = 2. * (alpha.x * gamma.x + alpha.y * gamma.y) + beta.x * beta.x + beta.y * beta.y;\n    float d = 2. * (beta.x * gamma.x + beta.y * gamma.y);\n    float e = gamma.x * gamma.x + gamma.y * gamma.y;\n    \n    //primera aproximación de la raíz para el método de newton\n    float discr = 36.*b*b - 4.*24.*a*c;\n    if(discr > 0.0){\n        discr = sqrt(discr);\n    }\n    float pE = -(12.*b)/(24.*a);\n    float dE = 4.*a*pE*pE*pE + 3.*b*pE*pE + 2.*c*pE + d; \n    \n    float fGuess0 = pE - discr - 10.1;\n    float fGuess1 = pE + discr + 10.1;\n    \n    \n    float dist = min( tSDF(p, clamp(cubicNewton(fGuess0, 4. * a, 3. * b, 2. * c, d), 0.0, 1.0), A, B, C),\n                      tSDF(p, clamp(cubicNewton(fGuess1, 4. * a, 3. * b, 2. * c, d), 0.0, 1.0), A, B, C));//las fallas parecen estar en el método de newton\n\n    \n    return dist;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //puntos que definen la curva\n    vec2 A = vec2(0.5*cos(0.88*iTime), 0.4*sin(iTime));\n    vec2 B = vec2(0.7*cos(1.02*iTime), -0.4*sin(0.31*iTime));\n    vec2 C = vec2(0.6*sin(0.7*iTime), -0.4*sin(0.4*iTime));\n\n    // coordenadas normalizadas de 0 a 1 en x y lo corespondiente en y\n    vec2 u = fragCoord/iResolution.xy;\n    u.x *= iResolution.x/iResolution.y;\n    u -= vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n    vec2 p = u;\n    \n    \n    float dist = SDF(p, A, B, C);\n    dist -= 0.04;\n    \n    //coloreado\n    vec3 col = vec3(0.70, 0.38, 0.05);\n    if(dist < 0.0){\n        col = vec3 (0.15, 0.4, 0.63);\n        float th = 0.03;\n        float m = mod(dist + 0.5 * th, 2.0 * th);// bodge + 0.5 th\n        float ramp = (0.5/th * m) * (2.0 * -smoothstep(th, th, m) + 1.0) + smoothstep(th, th, m) * 1.0;\n        float blur = 0.02;\n        col *= 0.7 + 0.3 * smoothstep(0.25 - blur, 0.25 + blur, ramp);\n        \n    }else{\n        float th = 0.03;\n        float m = mod(dist + 0.5 * th, 2.0 * th);// bodge + 0.5 * th\n        float ramp = (0.5/th * m) * (2.0 * -smoothstep(th, th, m) + 1.0) + smoothstep(th, th, m) * 1.0;\n        float blur = 0.03;\n        col *= 0.7 + 0.3 * smoothstep(0.25 - blur, 0.25 + blur, ramp);\n    }\n    float inter = 0.005;\n    if(abs(dist) < inter){\n        col = mix(vec3(1), col, abs(dist)/inter);\n    }\n    if(length(A-p) < 0.02){\n        col = mix(vec3(1), col, length(A-p)/0.1);\n    }\n    if(length(B-p) < 0.02){\n        col = mix(vec3(1), col, length(B-p)/0.1);\n    }\n    if(length(C-p) < 0.02){\n        col = mix(vec3(1), col, length(C-p)/0.1);\n    }\n    \n    // Output\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}