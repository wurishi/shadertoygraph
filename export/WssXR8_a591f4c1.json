{"ver":"0.1","info":{"id":"WssXR8","date":"1550595047","viewed":68,"name":"Mirror Cubes C0x61","username":"Confession","description":"A repeating grid of reflecting waving cubes with reflective floor ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOV 0.7\n#define ZFAR 1000.0\n#define MAX_ITER 64\n#define MIN_DISTANCE 0.005\nstruct ray \n{\n\tvec3 d;\n    float pd;\n    vec3 p;\n    float min_d;\n    float i;\n};\n    \nstruct camera\n{\n\tvec3 p;\n    vec3 f;\n    vec3 u;\n    vec3 r;\n    vec3 lu;\n};\n\nfloat plane(vec3 p)\n{\n\treturn p.y;\n}\n    \nfloat sphere(vec3 p)\n{\n\treturn length(p) - 1.0;\n}\n\nfloat cube(vec3 p)\n{\n    vec3 m = vec3(abs(p.x)-1.0, abs(p.y)-1.0, abs(p.z)-1.0);\n    if(m.x < 1.0 && m.y < 1.0 && m.z < 1.0) \n    {\n    return max(m.x, max(m.y, m.z));\n    }\n\treturn length(vec3(max(m.x, 0.0), max(m.y, 0.0), max(m.z, 0.0)));\n}\n\nfloat thorus(vec3 p, float r, float r1)\n{\n\treturn length(p - vec3(normalize(p.xy)*r, 0.0)) - r1;\n}\n\nfloat cylinder(vec3 p, float h, float r)\n{\n    float ah = abs(p.y) - h;\n\treturn max(ah, length(p.xz)-r);\n}\n\nfloat capsule(vec3 p, float h, float r)\n{\n\treturn min(length(vec3(p.x, abs(p.y) - h, p.z))-r, cylinder(p, h, r));\n}\n\nfloat sub(float a, float b)\n{\nreturn max(a, -b);\n}\n\nfloat DE(vec3 p)\n{\n    float sc = sin(iTime)+1.0;\n    vec3 pfc = p;\n    pfc.xz = mod(abs(p.xz+1.5), 3.0)-1.5;\n    pfc.y -= sin(iTime + length(floor(p/3.0+1.5)))/2.0+0.5-1.0;\n\treturn min(cube(pfc), plane(p));\n}\n    \nvec3 N(vec3 p, float d)\n{\n\tvec2 e = vec2(MIN_DISTANCE/2.0, 0.0);\n    \n    return normalize(d - vec3(DE(p - e.xyy), DE(p - e.yxy), DE(p - e.yyx)));\n}\n\nray march(ray r, float d)\n{\n\tr.p += r.d * d;\n    r.pd += d;\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float h = 0.0;\n\tcamera c;\n    c.p = vec3(sin(iTime*0.1)*3., 2.0, cos(iTime*0.1)*3.);\n    c.f = normalize(vec3(-c.p.x, -1.0, -c.p.z));\n    c.p.xz -=vec2(3.0);\n    c.u = vec3(0.0, 1.0, 0.0);\n    c.r = normalize(cross(c.u, c.f));\n    c.lu = normalize(cross(c.f, c.r));\n    \n    ray r;\n    r.min_d = ZFAR;\n    r.p = c.p;\n    r.d = normalize(c.r * uv.x*FOV + c.lu * uv.y*FOV + c.f);\n    r.pd = 0.0;\n    float d = MIN_DISTANCE;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n       \n        \n    \tr = march(r, d);\n        vec3 p = r.p;\n    \td = DE(p);\n        if(d < MIN_DISTANCE || r.pd > ZFAR) \n        {\n        \tcol += 0.1/float(MAX_ITER);\n            //col = vec3(dot(c.p - r.p,N(p, d)))/2.0;\n            r.d = reflect(r.d,  N(p, d));\n            //break;\n            r.min_d = ZFAR;\n   \t\t\tr.pd = 0.0;\n            r = march(r, MIN_DISTANCE*2.0);\n         \t\n        }\n        if(d > r.min_d)h += 0.01/pow(d, 1.0)/float(MAX_ITER); \n        if(r.min_d > d) \n        {\n        r.min_d = d;  \n        }\n        \n    } \n    //col = vec3(r.min_d);\n    col += h;\n   \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}