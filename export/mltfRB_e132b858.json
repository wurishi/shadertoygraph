{"ver":"0.1","info":{"id":"mltfRB","date":"1701380365","viewed":29,"name":"Voronoi (Varying powers test)","username":"roey_shap","description":"Always wanted to see what Voronoi would look like with the distance function changing as well. \nChange the border chunkiness with the mouse's X COORDINATE.\n\nWould've thought it too slow but ¯\\_(ツ)_/¯","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUMPOINTS 15\n#define SEED_RADIUS 0.005\n#define BORDER_THRESHOLD_EPSILON 0.005\n#define SCREEN_BOUND vec2(0.6, 0.45)\n#define MINCHUNKY 1.0\n#define MAXCHUNKY 7.0\n#define WHITE vec3(1.0)\n#define BORDERS_ON 1\nvec2 points[NUMPOINTS];\n\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nfloat dist(vec2 position){\n    float mappedMouse = map(0.1, 0.9, iMouse.x / iResolution.x, MINCHUNKY, MAXCHUNKY);\n    //float mappedTime = map(-1.0, 1.0, sin(iTime), 1.1, 5.9);\n    float n = clamp(mappedMouse, MINCHUNKY, MAXCHUNKY);\n    float x1 = pow(abs(position.x), n);\n    float x2 = pow(abs(position.y), n);\n   \n    return pow(x1 + x2, 1.0/float(n));\n}\n\nvec3 colorFromPoint(int index)\n{\n    float p = float(index)/float(NUMPOINTS);\n    return vec3(map(0.0, 1.0, p, 0.4, 1.0), \n                map(0.0, 1.0, p, 0.2, 0.4), \n                map(0.0, 1.0, 1.0 - p, 0.6, 1.0));\n}\n\n//vec3 colorFromPoint(vec2 position){\n//\treturn vec3(0.65 + 0.35*cos(10.0 * position.xyx + vec3(0,1,2)));\n//}\n\nvec3 getDominatingColor(vec2 position){\n    float bigNumber = max(iResolution.x, iResolution.y) * 2.0;\n\tfloat bestDistance = bigNumber * 2.0;\n    float secondBestDistance = bigNumber;\n    \n    bool beatClosestDistance = false;\n    \n\tvec3 closestSeedColor = colorFromPoint(0);\n    //vec2 defaultPoint = vec2(1.5);    \n\tfor (int i = 0; i < NUMPOINTS; i++) {\n        beatClosestDistance = false;\n\t\tfloat delta = dist(points[i] - position);\n        \n\t\tif (delta < SEED_RADIUS) {\n            return WHITE; //colorFromPoint(defaultPoint);\n        }\n        \n\t\tif (delta < bestDistance){\n\t\t\tclosestSeedColor = colorFromPoint(i);\n\t\t\tbestDistance = delta;\n            beatClosestDistance = true;\n\t\t}\n        else if (delta < secondBestDistance)\n        {\n            secondBestDistance = delta;\n        }\n\t}\n    \n    #if BORDERS_ON\n    if (abs(bestDistance - secondBestDistance) <= BORDER_THRESHOLD_EPSILON)\n    {\n        return WHITE;\n    }\n    #endif\n    \n\treturn closestSeedColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for (int i = 0; i < NUMPOINTS; i++)\n    {\n        float percentage = float(i) / float(NUMPOINTS);\n        float v1 = map(-1.0, 1.0, sin(float(8 + 2 * i) * percentage + 0.85 * iTime), -SCREEN_BOUND.x, SCREEN_BOUND.x);\n        float v2 = map(-1.0, 1.0, 0.5 * sin(cos(float(4 + 3 * i)) * (1.0 - percentage) + (0.4 * iTime)) + 0.5 * cos(10.0 + 5.0 * float(i) / (map(-1.0, 1.0, sin(iTime), 10.0, 25.0) + 1.0)), -SCREEN_BOUND.y, SCREEN_BOUND.y);\n        points[i] = vec2(v1, v2);\n    }\n    \n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\tfragColor = vec4(getDominatingColor(uv), 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}