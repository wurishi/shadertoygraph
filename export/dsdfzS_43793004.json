{"ver":"0.1","info":{"id":"dsdfzS","date":"1697331610","viewed":86,"name":"gabor triangle","username":"altunenes","description":"drag with the mouse, kind of \"reverse phi effect\". :) \n\nthough I'm still not sure if it's an illusion or not.. (n=1 only me ) :D \npush to space for alternative rotation...","likes":8,"published":1,"flags":16,"usePreview":0,"tags":["illusion","gabor","perception"],"hasliked":0,"parentid":"cs3BWM","parentname":"gabor patch"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nfloat toggleValue = 2.0; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.0 * (fragCoord/iResolution.xy) - 1.0;\n    vec4 spaceKey = texture(iChannel0, vec2(32.5/255.0, 0.5/255.0));\n    if(spaceKey.r > 0.5) {\n        toggleValue = 1.0;\n    } else {\n        toggleValue = 2.0;\n    }\n    float lambda = 0.06;\n    float sigma = 0.02;  \n    float gamma = 1.0;\n    \n    vec3 col = vec3(0.5);\n    int basePatches = 16;  // Num of patches in the base row...\n    \n    for(int j = 0; j < basePatches; ++j)\n    {\n        int patchesInRow = basePatches - j; \n        for(int i = 0; i < patchesInRow; ++i)\n        {\n           float xOffset = float(i) * 0.2 - 0.6 + float(j) * 0.2;\n            float yOffset = float(j) * 0.2 - 0.6;\n            \n            float theta = (iMouse.x / iResolution.x + float(i) * 0.1) * PI;\n            if (j % int(toggleValue) == 1) { \n                theta = -theta;\n            }\n             \n            float psi = iTime * 5.5 + float(j) * PI/5.0 + float(i) * PI/10.0;\n            \n            vec2 uvPatch = vec2(uv.x - xOffset, uv.y - yOffset);\n            \n            float xp = 2.0*uvPatch.x * cos(theta) - uvPatch.y * sin(theta);\n            float yp = 2.0*uvPatch.x * sin(theta) + uvPatch.y * cos(theta);\n            \n            float envelope = exp(-((xp*xp) + (gamma*gamma * yp*yp)) / (2.0 * sigma * sigma));\n            float carrier = cos(2.0 * PI * xp / lambda + psi);\n            float gabor = envelope * carrier;\n            //color\n            //vec3 colorModulation = vec3(0.5) + vec3(3.5) * cos(1.9 * PI * xp / lambda + vec3(0, 2, 4));  \n            col += 0.5 * gabor ; // * colorMod for colros...\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}