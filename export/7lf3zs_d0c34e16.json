{"ver":"0.1","info":{"id":"7lf3zs","date":"1622726991","viewed":110,"name":"Spinning Quadric Snowman","username":"Klark007","description":"Quadrics, Rotation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["quadricintersection"],"hasliked":0,"parentid":"7tfGzf","parentname":"Class 3: Many objects"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 1000000.0\n#define PI 3.1415926535897932384626433832795\n#define DEBUG false\n\n// the code is based of the introduction to raytracing course by siggraph\n// and the quadric intersection code from https://education.siggraph.org/static/HyperGraph/raytrace/rtinter4.htm\n\nfloat seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\nstruct Quadric {\n    float a,b,c;\n    float d,e,f;\n    float g,h,i;\n    float j;\n    \n    vec3 origin; // is also in parameters a..j but can't be reconstructed without more information\n    \n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = MAXX; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\nfloat rayQuadricIntersect(in Ray ray, in Quadric q) {\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n    \n    float Aq = q.a*(d.x*d.x) + q.b*(d.y*d.y) + q.c*(d.z*d.z)\n              + q.d*(d.x*d.y) + q.e*(d.x*d.z) + q.f*(d.y*d.z);\n    \n    float Bq = 2.0*q.a*(o.x*d.x) + 2.0*q.b*(o.y*d.y) + 2.0*q.c*(o.z*d.z)\n              + q.d*(o.x*d.y + o.y*d.x) + q.e*(o.x*d.z + o.z*d.x) + q.f*(o.y*d.z + o.z*d.y)\n              + q.g*d.x + q.h*d.y + q.i*d.z;\n              \n    float Cq = q.a*(o.x*o.x) + q.b*(o.y*o.y) + q.c*(o.z*o.z)\n              + q.d*(o.x*o.y) + q.e*(o.x*o.z) + q.f*(o.y*o.z)\n              + q.g*o.x + q.h*o.y + q.i*o.z + q.j;\n    \n    if (Aq == 0.0) {\n        return -Cq / Bq;\n    } else {\n        float disc = Bq*Bq -  4.0*Aq*Cq;\n        \n        if (disc < -0.00001) { // no intersection\n            return MAXX+2.0;\n        } else {\n            float t = (-Bq - sqrt(disc)) / (2.0*Aq);\n            if (t > 0.00001) {\n                return t;\n            }\n            t = (-Bq + sqrt(disc)) / (2.0*Aq);\n            if (t > 0.00001) {\n                return t;\n            }\n            return MAXX+1.0;\n        }\n    }\n}\n\nQuadric quadricSphere(in float radius, in vec3 pos, in vec3 color) {\n    return Quadric(\n        1.0/radius,1.0/radius,1.0/radius,\n        0.0,0.0,0.0,\n        -2.0*pos.x/radius,-2.0*pos.y/radius,-2.0*pos.z/radius,\n        -radius + (pos.x*pos.x + pos.y*pos.y + pos.z*pos.z)/radius,\n        pos,\n        color\n    );\n}\n\n\nQuadric quadricEllipse(in vec3 radia, in float radius, in vec3 pos, in vec3 color) {\n    float a = radia.x*radia.x;\n    float b = radia.y*radia.y;\n    float c = radia.z*radia.z;\n    \n    return Quadric(\n        1.0/a/radius,1.0/b/radius,1.0/c/radius,\n        0.0,0.0,0.0,\n        -2.0*pos.x/a/radius,-2.0*pos.y/b/radius,-2.0*pos.z/c/radius,\n        -radius + (pos.x*pos.x/a + pos.y*pos.y/b + pos.z*pos.z/c)/radius,\n        pos,\n        color\n    );\n}\n\nQuadric quadricCircularCylinder(in float radius, in vec3 pos, in vec3 color) {\n    return Quadric(\n        1.0/radius,0.0,1.0/radius,\n        0.0,0.0,0.0,\n        -2.0*pos.x/radius,0.0,-2.0*pos.z/radius,\n        -radius + (pos.x*pos.x + pos.z*pos.z)/radius,\n        pos,\n        color\n    );\n}\n\n// pre: pos lies on quadrics surface\nvec3 normalOfQuadric(in Quadric quadric, in vec3 pos) { // partial derivative of x,y,z\n    float x = 2.0*quadric.a*pos.x + quadric.d*pos.y + quadric.e*pos.z + quadric.g;\n    float y = 2.0*quadric.b*pos.y + quadric.d*pos.x + quadric.f*pos.z + quadric.h;\n    float z = 2.0*quadric.c*pos.z + quadric.e*pos.x + quadric.f*pos.y + quadric.i;\n    \n    return normalize(vec3(x,y,z));\n}\n\n\nmat4 getRotY(in float theta) {\n    return mat4(\n        vec4(cos(theta), 0.0, -sin(theta), 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(sin(theta), 0.0, cos(theta),0.0),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\n\nmat4 getRotZ(in float theta) {\n    return mat4(\n        vec4(cos(theta), sin(theta), 0.0, 0.0),\n        vec4(-sin(theta), cos(theta), 0.0, 0.0),\n        vec4(0.0,0.0,1.0,0.0),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\n\nmat4 matrixFromQuadric(in Quadric q) {\n    return mat4(\n        vec4(q.a,q.d/2.0,q.e/2.0,q.g/2.0),\n        vec4(q.d/2.0,q.b,q.f/2.0,q.h/2.0),\n        vec4(q.e/2.0,q.f/2.0,q.c,q.i/2.0),\n        vec4(q.g/2.0,q.h/2.0,q.i/2.0,q.j)\n    );\n}\n\nQuadric quadricFromMatrix(in mat4 m, in vec3 origin, in vec3 color) {\n    float a = m[0][0];\n    float b = m[1][1];\n    float c = m[2][2];\n    float d = 2.0*m[1][0];\n    float e = 2.0*m[2][0];\n    float f = 2.0*m[2][1];\n    float g = 2.0*m[3][0];\n    float h = 2.0*m[3][1];\n    float i = 2.0*m[3][2];\n    float j = m[3][3];\n    \n    return Quadric(\n        a,b,c,d,e,f,g,h,i,j,\n        origin,\n        color\n    );\n}\n\nQuadric constructRotatedQuadric(in Quadric q, in mat4 rot, in mat4 rot_inv) {\n    mat4 A = matrixFromQuadric(q);\n    \n    mat4 new = rot_inv * A * rot;\n    \n    return quadricFromMatrix(new, (rot*vec4(q.origin,0.0)).xyz, q.color);\n}\n\nQuadric constructRotatedYQuadric(in Quadric q, in float theta) {\n    mat4 rot = getRotY(theta);\n    mat4 rot_inv = getRotY(-theta);\n    \n    return constructRotatedQuadric(q, rot, rot_inv);\n}\n\nQuadric constructRotatedZQuadric(in Quadric q, in float theta) {\n    mat4 rot = getRotZ(theta);\n    mat4 rot_inv = getRotZ(-theta);\n    \n    return constructRotatedQuadric(q, rot, rot_inv);\n}\n\n\n\nconst int NUM_QUADRIC = 16;\nconst float offset = 7.5;\nQuadric quadrics[NUM_QUADRIC];\nLight  lights[1];\n\nvoid makeScene(int f) {\n    \n    // red curtains\n    quadrics[0] = quadricCircularCylinder(0.8, vec3(2.5,0.0,2.0), vec3(1.0, 0.0, 0.2));\n    quadrics[1] = quadricCircularCylinder(0.8, vec3(-2.5,0.0,2.0), vec3(1.0, 0.0, 0.2));\n    \n    // wooden floor\n    vec3 wood_color = vec3(255.0/255.0, 162.0/255.0, 0.0);\n    quadrics[2] = quadricEllipse(vec3(100.0,1.0,100.0), 1.0, vec3(0.0,-2.0,-0.5), wood_color);\n    \n    // body\n    vec3 body_color = vec3(1.0,1.0,1.0);\n    float theta = float(f)/50.0;\n    Quadric tempQuadric = quadricEllipse(vec3(1.0,1.5,0.7), 0.5, vec3(0.0,-1.1,0.0), body_color);\n    quadrics[3] = constructRotatedYQuadric(tempQuadric, theta);\n    tempQuadric = quadricEllipse(vec3(1.0,1.5,0.7), 0.35, vec3(0.0,-0.2, 0.0), body_color);\n    quadrics[4] = constructRotatedYQuadric(tempQuadric, theta);\n    quadrics[5] = quadricSphere(0.3, vec3(0.0,0.4, 0.0), body_color);\n    \n    // arms\n    tempQuadric = quadricEllipse(vec3(1.0,0.05,0.05), 0.35, vec3(0.65,0.0, 0.0), wood_color);\n    quadrics[6] = constructRotatedYQuadric(tempQuadric, theta);\n    tempQuadric = quadricEllipse(vec3(1.0,0.05,0.05), 0.35, vec3(-0.65,0.0, 0.0), wood_color);\n    quadrics[7] = constructRotatedYQuadric(tempQuadric, theta);\n    \n    // buttons\n    vec3 coal_color = vec3(0.1, 0.1, 0.1);\n    tempQuadric = quadricSphere(0.05, vec3(0.0,0.0, 0.2), coal_color);\n    quadrics[8] = constructRotatedYQuadric(tempQuadric, theta);\n    tempQuadric = quadricSphere(0.05, vec3(0.0,-0.12, 0.21), coal_color);\n    quadrics[9] = constructRotatedYQuadric(tempQuadric, theta);\n    tempQuadric = quadricSphere(0.05, vec3(0.0,-0.24, 0.205), coal_color);\n    quadrics[10] = constructRotatedYQuadric(tempQuadric, theta);\n    \n    // eyes\n    tempQuadric = quadricSphere(0.055, vec3(0.2,0.42, 0.25), coal_color);\n    quadrics[11] = constructRotatedYQuadric(tempQuadric, theta);\n    tempQuadric = quadricSphere(0.055, vec3(-0.2,0.42, 0.25), coal_color);\n    quadrics[12] = constructRotatedYQuadric(tempQuadric, theta);\n    \n    tempQuadric = quadricSphere(0.055, vec3(0.0,0.35, 0.25), coal_color);\n    quadrics[13] = constructRotatedYQuadric(tempQuadric, theta);\n    \n    float radius = 4.5;\n    lights[0] = Light(vec3(0.0, 10.0 + radius*sin(float(f)/50.0), 10.0+offset), vec3(1, 1, 1));\n}\n\n// samples per pixel\nint numSamples = 2;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = +vec3(0.0, 0.0, offset);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection); // can change ray origin to translate camera\n       float t = MAXX;\n       float minT = MAXX;\n       int iQuadric = -1;\n       // traverse the scene (all spheres)\n       for (int i=0; i < NUM_QUADRIC; i++) {\n           Quadric quadric = quadrics[i];\n       \n           t = rayQuadricIntersect(ray, quadric);\n         \n           if (t < minT) {\n               // keep track of the closest sphere and intersection\n               iQuadric = i;\n               minT = t;\n           }\n       }\n       if (iQuadric > -1) {\n          Quadric quadric = quadrics[iQuadric];\n           // hit coordinates\n           vec3 hit = ray.origin + minT*ray.direction;\n           // normal at the point of ray-sphere intersection\n           vec3 norm = normalOfQuadric(quadric, hit);\n           vec3 hitPointNormal = normalize(hit-quadric.origin);\n           // vector from eye to the intersection point\n           //vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           // using the light source. Only considers the first one and no coloring\n           vec3 hitPointLight = normalize(lights[0].location-hit);\n           // cosine of the angle between ray and nornal\n           float angle = dot(hitPointNormal, hitPointLight);\n           // use the cosine of the angle to modulate color for \n           // a simple diffuse shading effect\n           if (DEBUG && angle*quadric.color.x < 0.001 && angle*quadric.color.y < 0.001 && angle*quadric.color.z < 0.001) {\n               samp = samp + vec3(1.0,1.0,1.0);\n           } else {\n              samp = samp + max(angle, 0.15)*quadric.color; // ambiant lighting hack\n           }\n          \n       }\n       //Quadric quadric = quadricCircularCylinder(1.0, vec3(0.0,0.0,-8.0), vec3(0.5, 0.3, 0.0));\n       //Quadric quadric = quadricEclipse(vec3(0.8, 2.0, 1.0), 1.0, vec3(0.0,0.0,-8.0), vec3(0.0, 0.0, 1.0));//quadricSphere(1.5, vec3(0.0, 0.0, -8.0), vec3(0.0, 0.0, 1.0));\n       \n   }\n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}