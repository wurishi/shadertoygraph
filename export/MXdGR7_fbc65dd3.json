{"ver":"0.1","info":{"id":"MXdGR7","date":"1716295828","viewed":130,"name":"The Plastic Ratio","username":"chronos","description":"Low discrepancy sequence based on a D-dimensional version of the golden ratio, the \"Plastic Ratio\".","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["sequence","fibonacci","low","plastic","golden","discrepancy","ratio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    The Plastic Ratio by chronos\n    --------------------------------------------------------\n    \n    Low discrepancy sequence based on a D-dimensional version of the golden ratio,\n    the \"Plastic Ratio\".\n    \n    In this case 2D\n    \n    The \"Harmonious numbers\", x, are the solution to:\n    \n        x^(x+1) = x + 1\n    \n    for d = 1, it is the golden ratio.\n    for d = 2, it is the plastic ratio, p.\n    \n    The low discrepancy sequence is based on the factors 1/p and 1/p^2\n    \n    and generated by \n            \n        x_i = fract(i/p)\n        \n        y_i = fract(i/(p^2))\n        \n    This sequence has a number of good/optimal properties.\n    It's not the best for *everything* but then again, nothing is.\n    For example if you alternate n colors every iteration (e.g n=3, red, green, blue, red ... ),\n    you will see diagonal bands. But, it has very even spacing of points, and doesn't require any tuning.\n    This sequence if fairly easy to remember how to generate, so it seems to make for a good default quasirandom sequence\n    when you need an even distribution.\n    \n    The consecutive red, green and blue sequences each have low discrepancy, as well as the entire combined sequence,\n    similarly to the distribution of rods and cones in our eyes.\n    \n    See the references for more info.\n    \n    --------------------------------------------------------\n    \n    self link:\n    \n        https://www.shadertoy.com/view/MXdGR7\n\n    references:\n    \n        https://en.wikipedia.org/wiki/Plastic_ratio\n        https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences\n        https://math.stackexchange.com/questions/2360055/combining-low-discrepancy-sets-to-produce-a-low-discrepancy-set\n\n*/\n\nconst float max_num_points = 250.;\n\n\n#define COLOR_SCHEME 0\n\n#define USE_AREA_FIT 1\n\n#define SHOW_VORONOI 0\n\nconst float PI = 3.14159265;\n\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    float ps = 2. / iResolution.y;\n    \n    vec2 UV = uv * .5 + .5;\n    float PS = 1. / iResolution.y;\n    \n    vec3 color = vec3(0);\n\n    // Plastic ratio for d = 2:\n    // x^(d+1) = x + 1\n    // x^3 = x + 1\n    // x â‰ˆ 1.32471795724475\n    \n    float p1 = 0.7548776662466927; // reciprocal of plastic number\n    float p2 = 0.5698402909980532; // reciprocal of squared plastic number\n    \n    // Check errors\n    //color += float(10000000. * abs(p1 - 1./1.32471795724475));\n    //color += float(10000000. * abs(p2 - 1./(1.32471795724475 * 1.32471795724475)));\n    \n    vec2 plastic = vec2(p1, p2);\n\n    // At 60 fps, the duration is about 12.5 seconds\n    // the number of frames = 3 * num_points = 3 * 250 = 750\n    float duration = 12.5; // 750f / (60 f/s) = 12.5s;\n    float time = mod(iTime, duration); \n    \n    float speed = 1./(4.+1./6.); // At 60 fps, 250 points are reached at 250/60 = 25/6 = 4 + 1/6\n    float animation = min( min((duration-time)*speed, time*speed), 1.);\n    \n    float N = floor(animation * max_num_points);\n    \n    float r = 0.005; // radius\n#if USE_AREA_FIT\n    // Area = 1\n    // disc area = pi * r^2\n    // num discs * disc area = 1\n    // num discs * pi * r^2 = 1\n    // r = sqrt(1./(num_discs * pi))\n    r = 1./sqrt(N * PI);\n\n    float radius_scale = .6;\n\n    r *= radius_scale;    \n#endif\n\n    float min_dist = 9e9;\n\n    for(float i = 0.; i < N; i++)\n    {   \n        vec2 pos = fract(i * plastic);\n\n        float d = length(pos-UV);\n\n        float f = i/(max_num_points-1.);\n\n    #if COLOR_SCHEME || SHOW_VORONOI\n        vec3 point_color = vec3((1.-f)*(1.-f), 2.*(1.-f)*f , f*f);\n    #else\n        vec3 point_color = vec3(\n            step(f, 1./3.), \n            step(1./3., f) * step(f, 2./3.),\n            step(2./3., f)\n            );\n    #endif\n\n    #if SHOW_VORONOI\n        if(d < min_dist)\n        {\n            min_dist = d;\n            color = point_color;\n        }\n    #else\n        float alpha = smoothstep(r+PS, r-PS, d);\n        color = mix(color, point_color, alpha);\n    #endif\n    }\n\n    vec2 mask = step(-1., uv) * step(-1., -uv);\n    color *= min(mask.x, mask.y);\n\n    fragColor = vec4(sRGBencode(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}