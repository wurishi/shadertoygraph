{"ver":"0.1","info":{"id":"MldfzB","date":"1540267985","viewed":781,"name":"FBM noise","username":"dust","description":"Short, perlin-based fbm().","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","2d","fractal","noise","noise","perlinnoise","fbm","perlin","fbmnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adjustable palette tones\n#define PALETTE_TONE_A vec3(0.25f, 0.5f, 1.0f)\n#define PALETTE_TONE_B vec3(1.0f)\n\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv)); \n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))));\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n    \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n// Show a ridged pattern by highlighting areas where [f == 0]\n//#define RIDGE_NOISE\n\n// Show a tangled, glowing pattern by highlighting areas where\n// [f == 0], inverting them, and applying them back into\n// themselves\n//#define GLOWY_WIRES\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    const float cellSize = 0.0825f;\n    vec2 uv = (fragCoord / iResolution.y) / cellSize;\n            \n    // Generate fractional noise\n    const uint depth = 5u;\n    const vec2 dFreq = vec2(1.01f, 1.08f);\n    const float dAmpl = 1.1f;\n    vec2 freq = vec2(1.1f); // Starting noise frequency\n    float ampl = 0.25f; // Starting noise intensity\n    float f = 0.0f;\n    for (uint i = 0u; i < depth; i += 1u)\n    {\n        #ifndef RIDGE_NOISE \n        \t#ifndef GLOWY_WIRES\n               \tf += ampl * Perlin(uv);\n        \t#endif\n        #endif\n        #ifdef RIDGE_NOISE\n        \tf += ampl * abs(Perlin(uv));\n        #endif\n        #ifdef GLOWY_WIRES\n        \t#ifndef RIDGE_NOISE\n        \t\tf += ampl * abs(Perlin(uv));\n        \t#endif\n        \tf = 1.0f - f; \n        \tf *= f;\n        #endif\n        uv *= freq;\n        freq *= dFreq + vec2(0.1f * float(i));\n        ampl *= dAmpl;\n    }\n    \n    // Drive blending between palette colors with final noise values\n    vec3 rgb = mix(PALETTE_TONE_A,\n                   PALETTE_TONE_B,\n                   f);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}