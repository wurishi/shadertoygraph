{"ver":"0.1","info":{"id":"DdcGDH","date":"1677180103","viewed":98,"name":"Nippon will rise again","username":"Mojomajor","description":"https://en.wikipedia.org/wiki/Imperial_Japanese_Army üç£ üéé ","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["flag","angular","nippon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtjSWc","filepath":"https://soundcloud.com/lee-scratch-perry/silver-edit","previewfilepath":"https://soundcloud.com/lee-scratch-perry/silver-edit","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define WITH_TEXTURE 1\n#define WITH_GRADIENT 1\n#define FUZZ_RAYS 0\n#define VIGNETTE 1\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\n#define pi acos(-1.)\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //neighbors\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\n\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      st.x += iTime/10.;\n  }\n  return ret;\n  \n}\n\nfloat turningRays(vec2 uv,float noOfRays,float speed, float fuzz) {\n    // polar coordinates\n    vec2 st = vec2(atan(uv.x,uv.y), length(uv));\n    vec2 lUv = vec2(st.x/(2.*PI*fuzz*3.) + iTime * speed ,st.y);\n    \n    float x = lUv.x * noOfRays;\n    // zigzag\n    float m = min(fract(x),fract(1.-x));\n    \n    //float c = smoothstep(.25/fuzz,.26*fuzz,m);\n    float c = smoothstep(.25,.26,m);\n    return c;\n}\n\nfloat smooth_circle_using_length(vec2 position, float radius, float smoothness) {\n    vec2 d = position - vec2(0.5);\n    return 1.0 - smoothstep(radius-smoothness, radius, length(d));\n}\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float t = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, t);\n}\nvec3 vignette(vec2 uv) {\n  float distFromCenter = length(abs(uv));\n\n  float vignette = 1.3 - distFromCenter;\n  vignette = smoothstep(0.0, 0.8, vignette);\n  vignette = remap(vignette, 0., 1., 0.3, 1.0);\n\n  return vec3(vignette);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) / centered\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    // mini swing left/right\n    uv.x+=sin(iTime/3.)*0.0236;\n    // zoom\n    uv*=1.;\n    \n    float noOfRays = 16.;\n    float speed = 0.0236;\n    \n    float fuzz = fbm(uv,2.,1.);\n    #if FUZZ_RAYS == 0\n    float fuzzRays = 1./3.;\n    #endif\n    #if FUZZ_RAYS == 1\n    float fuzzRays = mix(fuzz,1./3., sin(iTime)*0.5+0.5);\n    #endif\n    \n    float raysSdf = turningRays(uv,noOfRays,speed,fuzzRays);\n\n    vec3 red = vec3(1.,0.,0.);\n    vec3 white = vec3(1.);\n    \n    #if WITH_GRADIENT == 0\n    vec3 colBg = white; //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    #endif\n    \n    #if WITH_GRADIENT == 1\n    // pink to azure\n    vec3 pinkToAzure= mix(vec3(1.0, 1.0, 1.0), vec3(.0, 1.0, 1.0), -1.*uv.y);\n    // gold to blueish\n    vec3 goldToBlueish= mix(vec3(1.0, 1.0, 1.0), vec3(1.0, .85, 0.0), uv.y+0.2);\n    // green to pink\n    vec3 greenToPink= mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 1., 0.0), uv.y+0.2);\n    // golden orange to pink\n    vec3 goldenorangeToPink= mix(vec3(90.0, 1.0, 1.0), vec3(0.0, 1., 0.0), uv.y+0.2);\n    \n    float zeroToOne = remap(sin(iTime/3.), -1.,1.,0.,1.);\n    float percent = mod(zeroToOne+1., 4.0) / 4.0; // calculate the percentage of time that has passed (mod 4.0 to repeat every 4 seconds)\n\n    float blend = smoothstep(0.25/fuzz, 0.5-fuzz*zeroToOne, percent);\n    vec3 color1 = pinkToAzure;\n    vec3 color2 = goldToBlueish;\n\n    vec3 colBg =  mix(color1, color2, blend);\n    #endif\n    \n    vec3 col = colBg;\n\n    float smoothness = 0.005;\n    float radius = 0.3+fuzz*sin(iTime)*0.1;\n    float circleSdf = smooth_circle_using_length(uv+vec2(0.5,0.5),radius, smoothness);\n    \n    col = mix(red,colBg,max(0.,raysSdf-circleSdf));\n    #if WITH_TEXTURE == 1\n    vec3 texColor = texture( iChannel0, uv ).rgb;\n    col-=texColor;\n    #endif\n    \n    \n    vec3 vig = vec3(1.);\n    #if VIGNETTE == 1\n    vig = vignette(uv);\n    #endif\n    \n    vec3 extraBrightness = vec3(.1);\n\n    fragColor = vec4(vig*(col+fuzz*.5)+extraBrightness,1);\n}","name":"Image","description":"","type":"image"}]}