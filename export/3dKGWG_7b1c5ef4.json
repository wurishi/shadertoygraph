{"ver":"0.1","info":{"id":"3dKGWG","date":"1572371510","viewed":780,"name":"Spherical harmonics solver","username":"Roninkoi","description":"Spherical harmonics solved in real time from Legendre polynomials using the Clenshaw algorithm. Unlike naive implementations, this algorithm can get to high values for L and M.\n\nRendering by iq: [url]https://www.shadertoy.com/view/lsfXWH[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","spherical","physics","harmonics","polynomials","legendre","legendrepolynomials","clenshaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Roni Koitermaa - Roninkoi/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Uses Chenshaw algorithm to solve spherical harmonics from Legendre polynomials\n// A review of methods can be found in arXiv:1410.1748 [physics.chem-ph]\n// Rendering originally by iq: https://www.shadertoy.com/view/lsfXWH\n// Thanks to TimoKinnunen and jeyko for suggestions\n\n#define PI 3.1415926535898\n\n// Clenshaw Legendre normalized\nfloat Pgn(int l, int m, float x)\n{\n    float p0 = 0., p1 = 0., p2 = 0.;\n    \n    for (int k = l; k >= 0; k--)\n\t{\n\t\tfloat k1 = float(k + 1);\n\t\tfloat m1 = float(2 * m) + k1;\n        float m2 = float(2 * (m + k) + 1);\n        \n\t\tp2 = p1;\n        p1 = p0;\n        \n\t\tp0 = 0.;\n        if (l == m + k)\n            p0 = 1.;\n        \n        float u0 = sqrt(\n\t\t\t(m2 * (m2 + 2.0)) /\n\t\t\t(k1 * m1)\n\t\t);\n        \n        float u1 = sqrt(\n            (k1 * m1 * (m2 + 4.0)) / \n\t\t\t((k1 + 1.0) * (m1 + 1.0) * m2)\n        );\n        \n        p0 += p1 * u0 * x;\n        p0 -= u1 * p2;\n\t}\n\n    for (int k = 1; k <= m; k++)\n\t{\n\t\tp0 *= sqrt(\n            (1.0 - 0.5/float(k)) * (1.0 - x) * (1.0 + x)\n        );\n\t}\n    \n    p0 *= sqrt((0.5 * float(m) + 0.25)/PI);\n    \n    return p0;\n}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\nprecision highp float;\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{\n    vec3 ns = normalize(s);\n    \n    if (m < 0) {\n        float c = ns.x;\n        ns.x = ns.z;\n        ns.z = c;\n        m = -m;\n    }\n    \n    // spherical coordinates\n    float thetax = ns.y;\n    float phi = atan(ns.z, ns.x)+PI/2.;\n    \n    float pl = Pgn(l, m, thetax);\n    \n    float r = (m - (2 * (m/2)) == 0 ? 1. : -1.) * cos(float(m) * phi) * pl;\n    \n    return r;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p;\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n    \n    int lmax = 16;\n    float t = mod(3.*iTime, float(lmax * (lmax + 1) / 2));\n    int l = int(sqrt(2.*t + 0.25)-0.5);\n    int m = int(t) - (l + l*l)/2;\n    \n\td=length(p00); n=p00/d; r = SH(l, m, n ); s = SHAPE; res = s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 4.0;\n    float h = 1.0;\n    float t = 0.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<2000; i++ )\n    {\n        if( h<0.01||t>maxd ) break;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n        m = res.yz;\n        t += h*0.1;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x + iTime;\n    float am = 2.*iMouse.y/iResolution.y - 1.;\n    vec3  ro = vec3(1.5*sin(an),1.5*sin(am),1.5*cos(an)) * 1.0;\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.4,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}