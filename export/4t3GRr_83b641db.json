{"ver":"0.1","info":{"id":"4t3GRr","date":"1467646091","viewed":328,"name":"[SH16A] Neper's Minimal Shader","username":"Neper","description":"Shadertoy Competition 2016, 1st challenge, size coding.\n\nFor future reference, the original shader: https://www.shadertoy.com/view/MdKXD3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["competition","size"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Note: Although I have done the reduction line by line\n//       from the reference shader, I have got ideas from others,\n//       and I have tried to mention that in the list below.\n//       When I saw that some approach was going to be more\n//       fruitful, I changed the structure of my shader in\n//       that direction. Most notable changes were:\n//          - replacing the inner loop for sphere test\n//            with a modulo repetition approach\n//          - merging main and shadow tracing loops\n//          - simpler expression for the fake AO term\n\n// My original reduced code made public \t\t\t\t[2016-Jul-4]\n// Changes: Applied iq's comment \t\t\t984 -> 941\t[2016-Jul-5]\n//\t\t\tTexture sampling modified \t\t941 -> 917\n//\t\t\tGet rid of function params\t\t917 -> 898\n// \t\t\tRe-arrange color computation\t898 -> 880\n//\t\t\tRe-arrange lighting computation,\n//\t\t\tremove unnecessary if()\t\t\t880 -> 866\n//\t\t\tmax(...,0.) unnecessary, because\n//\t\t\tof shadow term\t\t\t\t\t866 -> 858\n//\t\t\tSimplify texture sampling\t\t858 -> 837\n//\t\t\tCamera position initialization\n//\t\t\tfrom P_Malin's shader\t\t\t837 -> 836\n//\t\t\tModifying sphere mapping code\t836 -> 829\n//\t\t\tSimplifying direction vector\t829 -> 817\n//\t\t\tRay marcher code re-write, \t\t\n//\t\t\tusing floats and a new trick\n//\t\t\tfor sphere radia\t\t\t\t817 -> 790\t[2016-Jul-6]\n//\t\t\tRefactor lighting equations\t\t790 -> 783\n//\t\t\tRe-wrote checker pattern code\t783 -> 779\n// \t\t\tChanged constant color \n//\t\t\tcalculations\t\t\t\t\t779 -> 775\n// \t\t\tRe-wrote the ray marcher to\n//\t\t\tupdate position at every step\t775 -> 761\n// \t\t\tRemoved test for max distance\n//\t\t\ttraced, because the ray will stop\n//\t\t\tafter 64 iteration anyway;\n// \t\t\tsimplifying code after that\t\t761 -> 716\n//\t\t\tRemove variable w\t\t\t\t716 -> 714\n// \t\t\tMove initialization of u inside\n// \t\t\tits first use\t\t\t\t\t714 -> 712\n//\t\t\tUse define instead of function\t712 -> 709\n//\t\t\tMoving global varibles into\n// \t\t\tlocal scope\t\t\t\t\t\t709 -> 705\n//          A trick with r to move the\n//          initialization out of the loop\t705 -> 703\n//\t\t\tReplace light vector with\n//\t\t\tdirection vector\t\t\t\t703 -> 697\n//\t\t\tChanged the condition for AO term\n//\t\t\tvisibility to use max()\t\t\t697 -> 695\t[2016-Jul-7]\n//\t\t\tReplacing the loop-based approach\n//\t\t\twith mod-repetition-based one,\n//\t\t\tsimilar to P_Malin & others\t\t695 -> 716\t(!)\n//\t\t\tGetting rid of index variable k\t716 -> 705\n//\t\t\tPost-poning normal calculations\t705 -> 703\n//\t\t\tSimplifying code after changes\t703 -> 693\n//\t\t\tRemoving braces with combined\n//\t\t\texpression\t\t\t\t\t\t693 -> 691\n//\t\t\tReplace 2. with Z\t\t\t\t691 -> 687\n//\t\t\tRemove unnecessary (x) in define\n//\t\t\tfor normalize\t\t\t\t\t687 -> 682\n//\t\t\tRemove initilization of r, \n//\t\t\treplace .5 with h\t\t\t\t682 -> 677\n//\t\t\tRe-using variables\t\t\t\t677 -> 673\n//\t\t\tComputed approximations for sin\n//\t\t\tand cos in camera position\t\t673 -> 666\n//\t\t\tRemoved one .y in define\t\t666 -> 664\n//\t\t\tBusy at work\t\t\t\t\t\t\t\t[2016-Jul-8]\n//\t\t\tCombine main and shadow ray\t\t\t\t\t[2016-Jul-9]\n//\t\t\tloops like many others\t\t\t664 -> 684\t(!)\n//\t\t\tGet rid of floats\t\t\t\t684 -> 684\n//\t\t\tRemove temporary variables\t\t684 -> 669\n// \t\t\tRemove the last if-statement\t669 -> 661\n//\t\t\tSimplify initialization, remove\n//\t\t\tone extra variable\t\t\t\t661 -> 659\n// \t\t\tInitialization of n with cross\n//\t\t\tproduct\t\t\t\t\t\t\t659 -> 656\n//\t\t\tInspired by fb39ca4's trick,\n//\t\t\ta simpler expression for AO\t\t656 -> 624\n//\t\t\tReplaced (1. + n.y) with ++n.y\t624 -> 621\n//\t\t\tCombined two conditionals with\n//\t\t\to.y < .01 in one statement\t\t621 -> 615\n//\t\t\tEliminated an extra variable q\t615 -> 613\n//\t\t\tChanged the order or color\n//\t\t\tcomponents so that y-vector can\n//\t\t\tbe used in color computation\t613 -> 609\n//\t\t\tDuplicated the last dot product,\n//\t\t\tbecause it takes less space\t\t609 -> 606\n//\t\t\tNegated direction vector and\n//\t\t\tflipped a few signs\t\t\t\t606 -> 605\n//\t\t\tChanged y * 2. to y + y\t\t\t605 -> 604\n//\t\t\tCalculating and storing earlier\n//\t\t\tdot products used in lighting\t604 -> 603\n//\t\t\tUtilizing y-vector to get rid\n//\t\t\tof y-component in AO term, like\n//\t\t\tin fb39ca4's shader\t\t\t\t603 -> 602\n\n#define U normalize\n#define V vec3\n\n// c - output color, alpha channel for temporary scalar values\n// i - pixel position\n// y - first up vector, later albedo\n// o - ray origin\n// s - first one of camera base vectors, then sphere center\n// n - first one of camera base vectors, then normal\n// d - first resolution, then ray direction, and temporarily used for checker pattern condition\n// e - stored initial ray direction\n// f - dot product of ray direction and normal multiplied by the shadow term\n// j - loop counter\nvoid mainImage(out vec4 c, vec2 i)\n{\n    V \ty = V(0, 1, 0),\n    \to = V(.851, 2, -2.87677),\n        s = U(y + 5. * o),\n        n = U(cross(s, y)),\n        d = iResolution, e, f;\n    e = d = mat3(n, cross(s, n), s) * U(2. * V(i, d.y + .5) - d);\t// Camera direction vector calculation\n    \n    for (int j = -64; j < 64; j++)\t\t\t\t\t\t\t\t\t// Combined loop, values of j don't really matter\n        s \t= clamp(ceil(o - .5), -2., 2.),\t\t\t\t\t\t\t// Modulo repetition and clamped to [-2, 2] range\n        s.y\t= .4 - .3 * fract(c.a = s.x * 2.5 + s.z * .5),\t\t\t// Sphere radius calculation, store the sphere index in c.a\n        f \t= dot(-d, n) * V(o.y > 2.),\t\t\t\t\t\t\t\t// In the end, this will contain N dot L and shadow term\n    \to \t-= j == 0 ?\t\t\t\t\t\t\t\t\t\t\t\t// I wish there was implicit conversion between types, so !j would be possible\n            n = U(o - s),\t\t\t\t\t\t\t\t\t\t\t// Normal for spheres\n            d = mod(o, 2.) - 1.,\t\t\t\t\t\t\t\t\t// For checker pattern test\n    \t\ty = o.y < .01 ?\n                n = y,\t\t\t\t\t\t\t\t\t\t\t\t// Normal for the plane, set here to avoid another ? : -thing\n    \t\t\tV(d.x * d.z > 0. ? .8 : \t\t\t\t\t\t\t// Checker pattern test\n      \t\t\t\ttexture(iChannel0, o.xz * .1).x)\t\t\t\t\t\t\n            \t\t\t* smoothstep(.0, .5, length(o - sign(s - s * y))) :\t// Fake AO term\n                y + y + floor(c.a + 6.) * V(3, -8, 6) * .02,\t\t\t\t// Sphere albedo calculation\n            d = U(V(6, -7, 5)),\t\t\t\t\t\t\t\t\t\t\t\t// Change tracing direction towards the light\n    \t\t.01 * d :\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Small offset the avoid shadow acne\n        \tmin(length(o - s) - s, o).y * d;\t\t\t\t\t\t\t\t// Ray marching step forward\n\n    c.yxz = sqrt((y * V(.51, .6, .33) + \t\t\t\t\t\t\t\t\t// Diffuse\n    \t\t\t  pow(max(dot(d + 2. * f * n, e), 0.), 16.)) * f\t\t\t// Specular, without reflect()\n        \t\t + y * V(.7, .5, 1) / 8. * ++n.y);\t\t\t\t\t\t\t// Ambient\n}\n\n/*\n#define Y for (int i = 0; i < 64; i++) s = clamp(ceil(o - h), -Z, Z), s.y = .4 - .15 * mod(r = s.x * 5. + s.z, Z), T = min(length(o - s) - s, o).y, o += T * d;\n\nvoid mainImage(out vec4 c, vec2 i)\n{   \n    float r, T, h = .5, Z = 2.;\n    V \tq = iResolution,\n        y = V(0, 1, 0),\n    \to = V(.851, Z, -2.87677),//V(cos(5.), 1, sin(5.)) * 3. - y,\n        s = -U(y + 5. * o),\n        u = U(V(-s.z, 0, s.x));\n    V\td = mat3(u, cross(u, s), s) * U(Z * V(i, q.y + h) - q);\n    Y \t\t\t\t\t// Writes: o, s, T, r\tReads: o, d\n    \n    u = mod(o, Z) - 1.;\n    q = o * o;    \n    q = T < o.y ?\n        y.yxx * Z + floor(r / Z + 6.) * V(-8, 3, 6) * .02 :\n    \tV(u.x * u.z > 0. ? .8 : \n      \t\ttexture(iChannel0, o.xz * .1).x)\n            * smoothstep(.0, h,\n                         length(fract(o.xz + h) - h)\n                         + V(max(q.x, q.z) > 2.25));\n    \n    y = T < o.y ? U(o - s) : y;\n    u = d;\n    \n    d = U(V(-6, 7, -5));\n    o += .01 * d;\n    Y \t\t\t\t\t// Writes: o, s, T, r\tReads: o, d\n\n    r = dot(d, y);\n    c.xyz = sqrt(q * V(h, .7, 1) / 8. * (1. + y.y) \n                 + (q * V(.6, .51, .33)\n        \t\t \t+ pow(max(dot(d - Z * r * y, u), 0.), 16.)) * r * V(o.y > Z));\n}\n*/","name":"Image","description":"","type":"image"}]}