{"ver":"0.1","info":{"id":"tlG3WK","date":"1579863223","viewed":700,"name":"Kiss actions.","username":"Logos","description":"Circles kissing each other :)\n\nBig thanks knighty for solving my problem with exact inner circles radiuses!!","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circle","aa","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 24.01.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n//--- program parameters ---//\n\nconst int\tK\t\t\t= 100;\t\t\t// inversion count\n\nconst float\tSPEED\t\t= 1.0;\t\t\t// speed of circles animation\nconst float ZOOM_SPEED\t= 0.35;\t\t\t// speed of zoom pulse\n\n\n//--- constants ---//\n\nconst float IK\t\t= 1.0 / float(K);\n\nconst float\tPI\t\t= 3.14159265358979323846;\nconst float\tHALF_PI\t= 1.57079632679489661923;\n\n\n//--- inversion of a circle encoded by vec3(x, y, r^2) pattern\n        \nvec2 circleInverse(vec2 p, vec3 circle)\n{\n\tvec2 d = p - circle.xy;\n    \n    return d * (circle.z / dot(d, d)) + circle.xy;\n}\n\n\n//--- calculate pixel color ---//\n\nvec3 calculateColor(vec2 p, float r, float r_squared, float ct, float st)\n{\n    \n    //--- calculate fractal in unit circle only ---//\n\n    float q = dot(p, p);\n\n    if (q > 1.0) return vec3(1.0 / q);\n\n    \n    //--- 6 circles encoded by vec3(x, y, r^2) pattern ---//\n    \n\tvec3 circles[6] = vec3[6]\n\t(\n        vec3( 1.0,  1.0, 1.0),\n        vec3( 1.0, -1.0, 1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0,  1.0, 1.0),\n    \tvec3( ct,   st,  r_squared),\n        vec3(-ct,  -st,  r_squared)\n    );\n\n    \n    //--- do K inversions of this circles ---//\n            \n    int k = 0;\n    for (; k < K; k++)\n    {\n        bool inversion_is_present = false;\n\n        for (int i = 0; i < 6; i++)\n        {\n            vec2 d = p - circles[i].xy;\n            \n            if (dot(d, d) < circles[i].z)\n            {\n                p.xy = circleInverse(p, circles[i]);\n                inversion_is_present = true;\n                \n                break;\n            }\n        }\n\n        if (false == inversion_is_present) break;\n    }\n\n    \n    //--- return color by iteration count ---//\n    \n    float f = 1.0 - float(k)*IK;\n\n    return k%2 == 1? vec3(f) : vec3(0.0, 0.5*f, f);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- calculate point coordinates ---//\n    \n\tfloat\tZOOM = 1.1 + sin(ZOOM_SPEED*iTime);\n    vec2\tp    = ZOOM * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    \n    //--- calculate some helpers ---//\n    \n    float time = SPEED * iTime;\n    \n    float r  = 0.5 / (1.0 + abs(cos(time)) + abs(sin(time)));\n    float r2 = r*r;\n\n    float ct = r*cos(time);\n    float st = r*sin(time);\n\n    \n    //--- set final antialiased pixel color by accumulating samples ---//\n    \n    float a  = 2.0;\n    float o  = 1.0 / (4.0*a*a);\n    float e  = 0.5 / min(iResolution.x, iResolution.y);    \n    float ea =   e / a;\n    \n    vec3 col = vec3(0.0);\n    \n    for (float j = -a; j < a; j++)\n        for (float i = -a; i < a; i++)\n\n            col += o*calculateColor(p + ea*ZOOM*vec2(i, j), r, r2, ct, st);\n\n        \n\tfragColor = vec4(col, 1.0);  \n    \n}\n","name":"Image","description":"","type":"image"}]}