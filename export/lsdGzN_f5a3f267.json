{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//Will it blend by nmz (twitter: @stormoid)\n\n/*\n\tIdea from: http://www.stuartdenman.com/improved-color-blending/\n\n\tMost people will tell you that blending in rgb space is a bad,\n\tbut why is it so bad?\n\n\tHere's an unlisted shader to show and explain the issue: \n\thttps://www.shadertoy.com/view/XddGRN\n\n\n\tThis shader is about different solutions to this problem:\n\n\tThe left gradient is plain RGB Linear interpolation, showing nice\n\tbehavior when the interploated colors are close to each other\n\t(especially when close in hue) but prone to large changes in color\n\tsaturation along the gradient when the hues are further\tapart.\n\n\tThe second gradient from the left is HSV space blending, this\n\tcompletely solves the problem of avoiding low saturation colors\n\twhen the two interpolated colors are of high saturation\tbut of\n\tdifferent hues, but it creates other problems by not accounting\n\tfor human perception of lightness, resulting in gradients with \n\tpotentially large changes in percieved color \"brightness\". This \n\tmethod is also much costlier than plain rgb\tinterpolation (see \n\tbottom of comment).\n\n\tThe third gradient from the left is Lch space blending, it uses a \n\tcylindrical space with circular hues, just like HSV space, but it\n\ttakes into account human perception of color and results in\tvery\n\tnatural and smooth gradients.  The main issue with this method is \n\tthat the complete computation is quite expensive.\n\n\tThe fourth gradient is a method I developed to provide an alternative\n\tto the costly methods while improving the quality of the gradients\n\tcompared to simple rgb linear interpolation. The idea comes from\n\tobservation of the rgb colorspace's cube and where the low saturation\n\tarea is located within it.  The result is a rgb blending function that\n\tprovides decent quality gradients (you be the judge) at a very\n\tacceptable computational cost.  One thing that could be improved about\n\tthe algortihm is the behavior when the hues are very close to opposite\n\t(180 degrees apart), ideally the path would make the gradient hue\n\tshifted towards its\tside of the main diagonal, but I couldn't find a\n\tway to achieve this cheaply enough...\n\t\n\n\tComparison of the relative costs:\n\tOn Radeon HD 5670 (using GPU ShaderAnalyzer)\n\t\nFrom Left to Right:\n\t1st method (Lerp): 3 Instructions,  1 cycle\n\t2nd Method (HSV) : 34 Instructions, 7 cycles\n\t3rd Method (Lch) : 57 Instructions, 11.60 cycles\n\t4th Method (Mine): 15 Instructions, 3.20 cycles\n\n\nLch Blending documentation:\n\tColor space matrices from: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tEquations from: https://en.wikipedia.org/wiki/Lab_color_space\n*/\n\n\n//Allows to scale the saturation and Value/Lightness of the 2nd color\nconst float SAT2MUL = 1.0;\nconst float L2MUL = 1.0;\n\n\n//const vec3 wref =  vec3(.950456, 1.0, 1.089058); \nconst vec3 wref =  vec3(1.0, 1.0, 1.0); \n\n#define SMOOTH_HSV\n\n#define ITR 50\n#define FAR 8.\n#define time iTime\n\nconst float fov = 1.5;\nvec2 mo;\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n//---------------------------------------------------------------------------------\n//--------------------------------Color Functions----------------------------------\n//---------------------------------------------------------------------------------\n\n#define PI 3.14159365\n#define TAU 6.28318531\n\n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n//-----------------Lch-----------------\n\nfloat xyzF(float t){ return mix(pow(t,1./3.), 7.787037*t + 0.139731, step(t,0.00885645)); }\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\nvec3 rgb2lch(in vec3 c)\n{\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n    c.x = xyzF(c.x/wref.x);\n\tc.y = xyzF(c.y/wref.y);\n\tc.z = xyzF(c.z/wref.z);\n\tvec3 lab = vec3(max(0.,116.0*c.y - 16.0), 500.0*(c.x - c.y), 200.0*(c.y - c.z)); \n    return vec3(lab.x, length(vec2(lab.y,lab.z)), atan(lab.z, lab.y));\n}\n\nvec3 lch2rgb(in vec3 c)\n{\n    c = vec3(c.x, cos(c.z) * c.y, sin(c.z) * c.y);\n    \n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n    \t\t\t\twref.y*xyzR(lg),\n    \t\t\t\twref.z*xyzR(lg - 0.005*c.z));\n    \n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t        -0.9689,  1.8758, 0.0415,\n                \t     0.0557,  -0.2040, 1.0570);\n    \n    return rgb;\n}\n\n//cheaply lerp around a circle\nfloat lerpAng(in float a, in float b, in float x)\n{\n    float ang = mod(mod((a-b), TAU) + PI*3., TAU)-PI;\n    return ang*x+b;\n}\n\n//Linear interpolation between two colors in Lch space\nvec3 lerpLch(in vec3 a, in vec3 b, in float x)\n{\n    float hue = lerpAng(a.z, b.z, x);\n    return vec3(mix(b.xy, a.xy, x), hue);\n}\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//Linear interpolation between two colors in normalized (0..1) HSV space\nvec3 lerpHSV(in vec3 a, in vec3 b, in float x)\n{\n    float hue = (mod(mod((b.x-a.x), 1.) + 1.5, 1.)-0.5)*x + a.x;\n    return vec3(hue, mix(a.yz, b.yz, x));\n}\n\n//---------------Improved RGB--------------\n\n/*\n\tThe idea behind this function is to avoid the low saturation area in the\n\trgb color space. This is done by getting the direction to that diagonal\n\tand displacing the interpolated\tcolor by it's inverse while scaling it\n\tby saturation error and desired lightness. \n\n\tI find it behaves very well under most circumstances, the only instance\n\twhere it doesn't behave ideally is when the hues are very close\tto 180 \n\tdegrees apart, since the method I am using to find the displacement vector\n\tdoes not compensate for non-curving motion. I tried a few things to \n\tcircumvent this problem but none were cheap and effective enough..\n*/\n\n//Changes the strength of the displacement\n#define DSP_STR 1.5\n\n//Optimizaton for getting the saturation (HSV Type) of a rgb color\n#if 0\nfloat getsat(vec3 c)\n{\n    c.gb = vec2(max(c.g, c.b), min(c.g, c.b));\n\tc.rg = vec2(max(c.r, c.g), min(c.r, c.g));   \n\treturn (c.r - min(c.g, c.b)) / (c.r + 1e-7);\n}\n#else\n//Further optimization for getting the saturation\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n#endif\n\n//Improved rgb lerp\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    //Interpolated base color (with singularity fix)\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    \n    //Saturation difference from ideal scenario\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    \n    //Displacement direction\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    //Simple Lighntess\n    float lgt = dot(vec3(1.0), ic);\n    \n    //Extra scaling factor for the displacement\n    float ff = dot(dir, normalize(ic));\n    \n    //Displace the color\n    ic += DSP_STR*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\n\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n\nfloat sbox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cyl( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xz *= mm2(-time*0.4);\n    float d = max(cyl(p, vec2(1.,1.)), -sbox(p2 - vec3(1,1.,0), vec3(1.1+mo.x*0.6, 0.8 - mo.y*2.2, 1.2)));\n    return max(d, -cyl(p + vec3(0.,-2.2-mo.y*2.2,0), vec2(0.75+sin(time)*0.2,2.)));\n}\n\nvec3 shade(in vec3 pos, in vec3 rd)\n{\n    vec3 col = vec3(0);\n    vec2 plr = vec2(length(pos.xz), atan(pos.z,pos.x));\n    \n    vec3 colLch = lch2rgb(vec3(pos.y*50.+50.,plr.x*100. , plr.y));\n    vec3 colHsv = hsv2rgb(vec3(plr.y/6.2831853, plr.x, pos.y*0.5+0.5));\n    \n    col = mix(colLch, colHsv, smoothstep(0.5,0.5, sin(time*0.5+0.1)));\n    \n    return col;\n}\n\n//From eiffie: https://www.shadertoy.com/view/XsSXDt\nvec3 marchAA(in vec3 ro, in vec3 rd, in vec3 bgc, in float px, in mat3 cam)\n{\n    float precis = px*.1;\n    float prb = precis;\n    float t=map(ro);\n\tvec3 col = vec3(0);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0,d=0.;\n\tfor(int i=0;i<ITR;i++) {\n\t\td=map(ro+rd*t);\n\t\tif(df==50.0) {\n\t\t\tif(d>od) {\n\t\t\t\tif(od<px*(t-od)) {\n\t\t\t\t\tdf=od;tf=t-od;\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tt+=d;\n\t\tif(t>FAR || d<precis)break;\n\t}\n\tcol=bgc;\n    \n\tif(dm<px*tm)\n        col=mix(shade((ro+rd*tm) - rd*(px*(tm-dm)) ,rd),col,clamp(dm/(px*tm),0.0,1.0));\n    \n\tfloat qq=0.0;\n\t\n    if((df==100.0 || tm==tf) && t < FAR) {\n        ro+=cam*vec3(0.5,0.5,0.)*px*tm*1.;\n        tf=tm;\n        df=dm;\n        qq=.01;\n\t}\n    return mix(shade((ro+rd*tf) - rd*(px*tf-df),rd),col,clamp(qq+df/(px*tf),0.0,1.0));\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n//2d Box\nfloat box(in vec2 p, in vec2 b) \n{\n    return length(max(abs(p)-b,0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px= 2./(iResolution.y*fov);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n    vec2 pp = p;\n\tp.x*=iResolution.x/iResolution.y;\n\tmo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.12,0.15):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(1.1,0.,5.);\n    vec3 rd = normalize(vec3(p,-1.6)); \n    float rx = 0.45;\n    float ry = time*0.4+1.1+cos(time)*0.1;\n    \n    mat3 cam = rot_x(rx)*rot_y(ry);\n   \tro *= cam;\n\trd *= cam;\n    \n    //vec3 col = mix(vec3(0.9,.9,.95),vec3(0.2,0.2,0.27),(-1.-rd.y)*1.0+.8);\n    vec3 col = vec3(0.9);\n    col = marchAA(ro, rd, col, px, cam);\n    \n    \n    //-------------------------2D stuff------------------------------\n    \n    vec3 col1 = vec3(0.26-time*0.0638 + mo.x*0.1, .8 + sin(time)*0.2, clamp(mo.y+0.6,0.,1.));\n    vec3 col2 = vec3(.75-time*0.0638 - mo.x*0.1, (.8 + sin(time)*0.2) * SAT2MUL, clamp(mo.y+0.6,0.,1.)*L2MUL);\n    \n    float gradient = clamp((p.y+0.42)*1.25,0.,1.);\n    \n    vec3 gradHSV = lerpHSV(col2, col1, gradient);\n    \n    col1 = hsv2rgb(col1);\n    col2 = hsv2rgb(col2);\n    gradHSV = hsv2rgb(gradHSV);\n    \n    vec3 col1Lch = rgb2lch(col1);\n    vec3 col2Lch = rgb2lch(col2);\n    \n    vec3 gradLch = lerpLch(col1Lch, col2Lch, gradient);\n    gradLch = lch2rgb(gradLch);\n    vec3 gradRGB = mix(col2, col1, gradient);\n    \n    vec3 gradDSP = iLerp(col2, col1, gradient);\n    \n    float h = clamp(mo.y,-.45,.4);\n    float h2 = clamp(mo.x,-.7,1.);\n    float b1 = smoothstep(0.01, .0, box(p - vec2(-0.67-h*0.15 + sin(-h2*1.1-1.6)*0.12,h*0.8 + h2*0.13),\n                                        vec2(0.02,0.02))-0.015);\n    col = col*(1.-smoothstep(0.,.5,b1)) + vec3(col1)*b1;\n    \n    float b2 = smoothstep(0.01, .0, box(p - vec2(-0.16-h*0. + sin(h2*1.1+1.9)*0.2, 0.15 + h*0.55 + h2*0.13),\n                                        vec2(0.02,0.02))-0.015);\n    col = col*(1.-smoothstep(0.,.5,b2)) + vec3(col2)*b2;\n    \n    float b3 = smoothstep(0.01, 0., box(p - vec2(0.18,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b3)) + vec3(gradRGB)*b3;\n    \n    float b4 = smoothstep(0.01, 0., box(p - vec2(0.36,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b4)) + vec3(gradHSV)*b4;\n    \n    float b5 = smoothstep(0.01, 0., box(p - vec2(0.54,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b5)) + vec3(gradLch)*b5;\n    \n    float b6 = smoothstep(0.01, 0., box(p - vec2(0.73,0.0), vec2(0.06,0.4)));\n    col = col*(1.-smoothstep(0.,.5,b6)) + vec3(gradDSP)*b6;\n    \n    \n    //Light and sharp vignette so that the colors don't get influenced\n    vec2 pp3 = pp*pp*pp;\n    col *= pow(smoothstep(12., .05, dot(pp3*pp3,pp3*pp3)*1000.),1000.)*0.4+0.6;\n    \n    col = sRGB(col);\n    \n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsdGzN","date":"1448472609","viewed":21289,"name":"Will it blend","username":"nmz","description":"From left to right: RGB Lerp, HSV bledning, CIE Lch Blending, My blending function\nMouse lets you change interpolated colors, the cylinder switches between HSV and Lch over time (Lch is the smooth one).\n\nThe new blending method is at line 200.","likes":236,"published":1,"flags":0,"usePreview":0,"tags":["blending","lab","lch","colortheory"],"hasliked":0,"parentid":"","parentname":""}}