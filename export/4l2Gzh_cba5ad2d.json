{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec3 sphericalNormal(float yaw, float pitch) {\n\treturn vec3(cos(pitch) * cos(yaw), sin(pitch), sin(pitch) * cos(yaw));\n}\n\nmat3 sphericalMatrix(float yaw, float pitch) {\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(pitch), -sin(pitch),\n\t\t0.0, sin(pitch), cos(pitch)\n\t)\n\t* mat3(\n\t\tcos(yaw), 0.0, -sin(yaw),\n\t\t0.0, 1.0, 0.0,\n\t\tsin(yaw), 0.0, cos(yaw)\n\t);\n}\n\n// Returns the location of the current fragment relative to the center of the screen, where 0.5 is the distance to the nearest screen border.\n// This will return values > +-0.5 on the X axis in widescreen, and the Y axis in portrait.\nvec2 pixelCoord(vec2 fragCoord) { \n\treturn ((fragCoord - (iResolution.xy / 2.0)) / min(iResolution.x, iResolution.y)); \n}\n\nstruct ray {\n\tvec3 start;\n\tvec3 normal;\n};\n\t\nray lens(vec2 fragCoord) {\n\treturn ray(vec3(0.0, 0.0, -3.0), normalize(vec3(pixelCoord(fragCoord), 0.5)) * sphericalMatrix(sin(iTime * 0.8) * 0.1, sin(iTime * 1.6) * 0.025));\n}\n\n// Returns how long along a ray in world units the nearest point to a given point is.\n// May return negative values.\nfloat along(ray from, vec3 point) {\n\treturn dot(point - from.start, from.normal);\n}\n\t\t\nvec3 nearest(ray from, vec3 point) {\n\treturn from.start + from.normal * along(from, point);\n}\n\nfloat radial(vec3 origin, float rate) {\n\treturn 1.0 / (1.0 + length(origin) * rate);\n}\n\nfloat directional(vec3 origin, vec3 normal, float focus) {\n\treturn pow(max(0.0, dot(normalize(origin), normal)), focus);\n}\n\nfloat hideWhenBehind(float distance) {\n\treturn distance > 0.0 ? distance : 1.0 / 0.0;\n}\n\nstruct plane {\n\tvec3 normal;\n\tfloat distance;\n};\n\nfloat occlusionPlane(ray line, plane surface) {\n    return dot(surface.normal, surface.normal * surface.distance - line.start) / dot(surface.normal, line.normal);\t\n}\n\nstruct sphere {\n\tvec3 origin;\n\tfloat radius;\n};\n\nfloat occlusion(ray from, sphere sphere) {\n\tfloat _along = along(from, sphere.origin);\n\tfloat distance = distance(from.start + from.normal * _along, sphere.origin) / sphere.radius;\n\tif(distance > 1.0) return 1.0 / 0.0;\n\treturn _along - cos(asin(distance));\n}\n\nfloat occlusion(ray from) {\n\treturn \n\t\tmin(\n\t\t\thideWhenBehind(occlusion(from, sphere(vec3(1.0, sin(iTime * 1.5) * 0.1 - 0.125, 1.0), 0.5))),\n\t\t\tmin(\n\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(0.0, -1.0, 0.0), -2.2))),\n\t\t\t\tmin(\n\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(0.0, 1.0, 0.0), -0.3))),\n\t\t\t\t\tmin(\n\t\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(1.0, 0.0, 0.0), -4.0))),\n\t\t\t\t\t\tmin(\n\t\t\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(-1.0, 0.0, 0.0), -4.0))),\n\t\t\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(0.0, 0.0, -1.0), -4.0)))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n}\n\nvec3 closest(ray from, vec3 origin, float occlusionAlong, out float closeFade) {\n\tfloat dist = min(occlusionAlong, hideWhenBehind(along(from, origin)));\n\tcloseFade = 1.0 - (1.0 / pow(1.0 + dist, 0.3));\n\treturn from.start + from.normal * dist - origin;\n}\n\nfloat closestPlane(ray from, plane plane, float occlusionAlong) {\n\treturn\n\t\tdot(\n\t\t\tplane.normal,\n\t\t\tfrom.start + from.normal * min(\n\t\t\t\tocclusionAlong,\n\t\t\t\t// If the ray is pointing away from the plane...\n\t\t\t\tdot(from.normal, plane.normal) > 0.0 \n\t\t\t\t\t// The closest point must be the start.\n\t\t\t\t\t? 0.0\n\t\t\t\t\t// Else, it's where the ray intersects the surface.\n\t\t\t\t\t: occlusionPlane(from, plane)\n\t\t\t)\n\t\t) + plane.distance;\t\t\t\n}\n\nfloat falloffFromPlane(vec3 at, plane surface, float rate) {\n\tfloat loc = dot(at, surface.normal) - surface.distance;\n\treturn loc < 0.0 ? 0.0 : 1.0 / (1.0 + loc * rate);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tray from = lens(fragCoord);\n\tfloat occlusionAlong = occlusion(from);\n\tvec3 color = vec3(0.0);\n\tfloat dist;\n\tvec3 difference;\n\tfloat intensity = 0.0;\n\t\n\t#define overheadLamp(x, z) difference = closest(from, vec3(x, 2.0, z), occlusionAlong, dist); intensity += dist * radial(difference, 16.0) * 5.0 * directional(difference, vec3(0.0, -1.0, 0.0), 4.0) + radial(difference, 512.0) * 20.0;\t\n\t\n\toverheadLamp(2.5, 2.5)\n\toverheadLamp(-2.5, 2.5)\n\toverheadLamp(2.5, -2.5)\n\toverheadLamp(-2.5, -2.5)\t\n\tcolor += vec3(0.7, 0.6, 0.0) * intensity;\n\t\t\n\tintensity = 0.0;\n\tvec3 spin = vec3(0.0, cos(iTime * 5.0), sin(iTime * 5.0));\n\tdifference = closest(from, vec3(4.0, 1.0, 0.0), occlusionAlong, dist);\n\tintensity += dist * radial(difference, 32.0) + radial(difference, 8.0) * directional(difference, spin, 8.0);\t\t\n\tdifference = closest(from, vec3(-4.0, 1.0, 0.0), occlusionAlong, dist);\n\tintensity += dist * radial(difference, 32.0) + radial(difference, 8.0) * directional(difference, -spin, 8.0);\t\t\t\n\tcolor += vec3(1.0, 0.0, 0.0) * intensity;\n\t\n\t// Lava plane.\n\tcolor += vec3(0.7, 0.0, 0.0) * falloffFromPlane(from.start + from.normal * occlusionAlong, plane(vec3(0.0, 1.0, 0.0), -0.31), 8.0);\n\t\n\tintensity = 0.0;\n\t#define lavaFlare(x, z) difference = closest(from, vec3(x, sin(iTime * 1.2 + x + z) * 0.1 - 0.15, z), occlusionAlong, dist); intensity += dist * radial(difference, 32.0 + sin(iTime * 3.0 + x + z) * 16.0);\n\t\n\tlavaFlare(-0.7, -2.5)\n\tlavaFlare(0.5, -2.0)\n\tlavaFlare(-0.5, 0.0)\n\tlavaFlare(-1.3, 2.0)\n\tlavaFlare(-1.9, -0.3)\n\t\n\tcolor += vec3(1.0, 1.0, 0.0) * intensity;\n\t//color -= 0.1;\n    color *= pow(from.normal.z, 3.0);\n    color *= 2.0;\n\tcolor = clamp(color, 0.0, 1.0);\n\t\n\tfragColor = vec4( pow(color, vec3(1.0 / 2.2)), 0.0 );\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4l2Gzh","date":"1426879956","viewed":515,"name":"I Cannot Self Terminate","username":"jameswilddev","description":"AKA False Volumetrics IV.  Experimenting with infinite decay falloff rather than radiuses + occluders.  Currently has some issues with light clipping when near the camera.  Needs some cleanup as there's the remnants of a lot of experimentation in there.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fake","lava","false","volumetrics"],"hasliked":0,"parentid":"","parentname":""}}