{"ver":"0.1","info":{"id":"7syXDW","date":"1634722510","viewed":179,"name":"Color Inspector","username":"zznewclear13","description":"A color Inspector, left click to inspect color values.\nAny advice would be greatly appreciated!\n\nInspired by https://www.shadertoy.com/view/Mt2GWD.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["font","inspector","debugger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspectable color ranges from -99999.99 to 99999.99, with two decimals,\n//and the its value may has some bias due to float/int conversion.\n\n\n//Some basic settings.\n#define SAMPLE_WINDOW_SIZE 80\n#define SAMPLE_RESOLUTION 2.0\n#define FONT_SIZE ivec2(1, 1)\n#define TEXT_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n#define TEXT_BACKGROUND_COLOR vec4(0.2, 0.2, 0.2, 0.5)\n\n\n//Check if in rectangle, given its bottom left corner and upper right corner.\nbool CheckInRectangle(ivec2 currentCoord, ivec2 bottomLeft, ivec2 upperRight, out bool onBorder)\n{\n    onBorder = any(equal(currentCoord, bottomLeft)) || any(equal(currentCoord, upperRight));\n    return all(greaterThanEqual(currentCoord, bottomLeft)) && all(lessThanEqual(currentCoord, upperRight));\n}\n\n//Basically a magnifier\nvec4 GetSampleColor(ivec2 currentCoord, ivec2 samplePosition, float sampleResolution)\n{\n    ivec2 sampleOffset = currentCoord - samplePosition;\n    ivec2 sampleCoord = ivec2(floor(vec2(sampleOffset) / sampleResolution));\n    vec4 sampleColor = texture(iChannel0, vec2(samplePosition + sampleCoord) / iResolution.xy);\n    return sampleColor;\n}\n\n//Check if in text window, given its upper left corner and font size.\n//With textColRowIndex, we know exactly which character we are going to draw.\n//With characterColRowIndex, we know which pixel in a character we are going to draw.\nbool CheckInTextWindow(ivec2 currentCoord, ivec2 textWindowUpperLeft, ivec2 fontSize, out ivec2 textColRowIndex, out ivec2 characterColRowIndex)\n{\n    ivec2 offset = currentCoord - textWindowUpperLeft;\n    offset.y = -offset.y;\n    \n    textColRowIndex = ivec2(floor(vec2(offset) / vec2(fontSize)));\n    characterColRowIndex = (offset - textColRowIndex * fontSize) / FONT_SIZE;\n    \n    int rowLimit = 3;\n    int colLimit = int(texelFetch(iChannel0, ivec2(1, textColRowIndex.y + 1), 0).a - texelFetch(iChannel0, ivec2(1, textColRowIndex.y), 0).a);\n    bool inTextWindow = (textColRowIndex.y >= 0) && (textColRowIndex.y <= rowLimit) && (textColRowIndex.x >= 0) && (textColRowIndex.x <= colLimit - 1);\n    return inTextWindow;\n}\n\n//Get certain bit from characterInt.\nfloat GetBit(uint characterInt, int bitIndex)\n{\n    return float((characterInt >> bitIndex) & 1u);\n}\n\n//Draw text and its background.\nvec4 GetTextWindowColor(ivec2 currentCoord, ivec2 textColRowIndex, ivec2 characterColRowIndex)\n{\n    int characterIndex = int(texelFetch(iChannel0, ivec2(1, textColRowIndex.y), 0).a) + textColRowIndex.x;\n    uvec4 character = characterSet[int(texelFetch(iChannel0, ivec2(2, characterIndex), 0).a)];\n    characterColRowIndex = ivec2(7, 11) - characterColRowIndex;\n    \n    int bitIndex = characterColRowIndex.x + characterColRowIndex.y * 8;\n    int bracketIndex = bitIndex / 24;\n    float characterWeight = GetBit(character[3 - bracketIndex], bitIndex - bracketIndex * 24);\n    return mix(TEXT_BACKGROUND_COLOR, TEXT_COLOR, characterWeight);\n}\n\n//Compose everything.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    ivec2 samplePosition = ivec2(0.5 * iResolution.xy);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 mainTex = texture(iChannel0, uv);\n    \n    vec4 finalColor = mainTex;\n        \n    if(iMouse.z > 0.0)\n    {\n        samplePosition = ivec2(iMouse.xy);\n    }\n    \n    int sampleWindowSize = SAMPLE_WINDOW_SIZE;\n    int halfSampleWindowSize = sampleWindowSize >> 1;\n    int halfSampleWindowSizePlus = (sampleWindowSize ++) >> 1;\n\n    //Draw sample window.\n    bool onBorder = false;\n    bool inColorWindow = CheckInRectangle(iFragCoord, samplePosition - halfSampleWindowSize, samplePosition + halfSampleWindowSizePlus, onBorder);\n    vec4 sampleColor = GetSampleColor(iFragCoord, samplePosition, SAMPLE_RESOLUTION);\n    sampleColor = mix(sampleColor, fract(sampleColor + 0.5), float(onBorder));//A distinguishable frame.\n\n    //Draw text window.\n    ivec2 fontSize = ivec2(8, 12) * FONT_SIZE;\n    ivec2 textColRowIndex = ivec2(0, 0);\n    ivec2 characterColRowIndex = ivec2(0, 0);\n\n    ivec2 textUpperLeftCorner = samplePosition + halfSampleWindowSizePlus + ivec2(1, 0);\n    bool inTextWindow = CheckInTextWindow(iFragCoord, textUpperLeftCorner, fontSize, textColRowIndex, characterColRowIndex);\n    vec4 textWindowColor = GetTextWindowColor(iFragCoord, textColRowIndex, characterColRowIndex);\n\n    //Mix main texture, sample window and text window.\n    finalColor = mix(finalColor, sampleColor, float(inColorWindow));\n    finalColor.rgb = mix(finalColor.rgb, textWindowColor.rgb, textWindowColor.a * float(inTextWindow));\n\n    \n    fragColor = finalColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//(0, 0), vec4: sampleColor\n//(1, 0) - (1, 5), alpha channel, int: index offset (like a pointer, with which we can find characters)\n//(2, 0) - (2, x), alpha channel, int: index (used to index characterSet and retrive real characters)\n\n\n//Check if our current coord is target address\nbool CheckAddress(ivec2 currentCoord, ivec2 address)\n{\n    return all(equal(currentCoord, address));\n}\n\n//Save value to a certain coord\nvoid SaveValue(ivec2 currentCoord, ivec2 address, int value, inout vec4 color)\n{\n    if(CheckAddress(currentCoord, address))\n    {\n        color.a = float(value);\n    }\n}\n\n//Calculate each digit of a float number and save them to the alpha channel of coord (2, 0) - (2, x).\nvoid FloatToCharacterIndex(ivec2 currentCoord, float floatValue, inout int totalLength, inout vec4 color)\n{\n    float signValue = sign(floatValue);\n    floatValue = signValue * floatValue;\n    \n    //Handle negetive numbers.\n    if(signValue == -1.0)\n    {\n        SaveValue(currentCoord, ivec2(2, totalLength), 13, color);\n        totalLength ++;\n    }\n    \n    if(signValue == 0.0)\n    {\n        SaveValue(currentCoord, ivec2(2, totalLength), 16, color);\n        totalLength ++;\n    }\n    else\n    {\n        int valueLength = int(max(floor(logE * log(floatValue)) + 1.0, 1.0));\n        \n#if defined(GLSL_UNROLL)\n        //For some mysterious reasons, the compiler cannot unroll this properly.\n        //I tried replacing valueLength with a const number, 5 for example, does not work either.\n        for (int i = 0; i < valueLength; i++)\n        {\n            int digit = (int(floatValue) / int(pow(10.0, float(valueLength - i - 1)))) % 10 + 16;\n            SaveValue(currentCoord, ivec2(2, totalLength), digit, color);\n            totalLength ++; \n        }\n#else\n        //Unroll 5 times, hard coded\n        int i = 0;\n        if(i < valueLength)\n        {\n            int digit = (int(floatValue) / int(pow(10.0, float(valueLength - i - 1)))) % 10 + 16;\n            SaveValue(currentCoord, ivec2(2, totalLength), digit, color);\n            totalLength ++; \n        }\n        i ++;\n        if(i < valueLength)\n        {\n            int digit = (int(floatValue) / int(pow(10.0, float(valueLength - i - 1)))) % 10 + 16;\n            SaveValue(currentCoord, ivec2(2, totalLength), digit, color);\n            totalLength ++; \n        }\n        i ++;\n        if(i < valueLength)\n        {\n            int digit = (int(floatValue) / int(pow(10.0, float(valueLength - i - 1)))) % 10 + 16;\n            SaveValue(currentCoord, ivec2(2, totalLength), digit, color);\n            totalLength ++; \n        }\n        i ++;\n        if(i < valueLength)\n        {\n            int digit = (int(floatValue) / int(pow(10.0, float(valueLength - i - 1)))) % 10 + 16;\n            SaveValue(currentCoord, ivec2(2, totalLength), digit, color);\n            totalLength ++; \n        }\n        i ++;\n        if(i < valueLength)\n        {\n            int digit = (int(floatValue) / int(pow(10.0, float(valueLength - i - 1)))) % 10 + 16;\n            SaveValue(currentCoord, ivec2(2, totalLength), digit, color);\n            totalLength ++; \n        }\n#endif\n    }\n    \n    //Handle two decimals.\n    float fracValue = fract(floatValue);\n    SaveValue(currentCoord, ivec2(2, totalLength), 14, color);\n    totalLength ++;\n    SaveValue(currentCoord, ivec2(2, totalLength), int(fracValue * 10.0) % 10 + 16, color);\n    totalLength ++;\n    SaveValue(currentCoord, ivec2(2, totalLength), int(fracValue * 100.0) % 10 + 16, color);\n    totalLength ++;\n}\n\n//Pre-calculate character indexes, read by Image later.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseInput = iMouse.xy / iResolution.xy;\n    vec2 samplePosition = vec2(0.5, 0.5);\n    if(iMouse.z > 0.0)\n    {\n        samplePosition = mouseInput;\n    }\n    vec4 sampleColor = texture(iChannel0, samplePosition);  \n    vec4 mainTex = texture(iChannel0, uv);\n    vec4 finalColor = mainTex;\n    \n    bool isSampleColor = all(equal(iFragCoord, ivec2(0, 0)));\n    finalColor = mix(finalColor, sampleColor, float(isSampleColor));    \n    \n    int totalLength = 0;\n    SaveValue(iFragCoord, ivec2(1, 0), 0, finalColor);\n    \n    //Save index offset to (1, x).\n    //And save index to (2, x).\n    FloatToCharacterIndex(iFragCoord, sampleColor.r, totalLength, finalColor);\n    SaveValue(iFragCoord, ivec2(1, 1), totalLength, finalColor);\n    \n    FloatToCharacterIndex(iFragCoord, sampleColor.g, totalLength, finalColor);\n    SaveValue(iFragCoord, ivec2(1, 2), totalLength, finalColor);\n    \n    FloatToCharacterIndex(iFragCoord, sampleColor.b, totalLength, finalColor);\n    SaveValue(iFragCoord, ivec2(1, 3), totalLength, finalColor);\n    \n    FloatToCharacterIndex(iFragCoord, sampleColor.a, totalLength, finalColor);\n    SaveValue(iFragCoord, ivec2(1, 4), totalLength, finalColor);\n    \n    fragColor = finalColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define logE 0.434294481903252\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\n#define character_spc characterSet[0]\n#define character_exc characterSet[1]\n#define character_quo characterSet[2]\n#define character_hsh characterSet[3]\n#define character_dol characterSet[4]\n#define character_pct characterSet[5]\n#define character_amp characterSet[6]\n#define character_apo characterSet[7]\n#define character_lbr characterSet[8]\n#define character_rbr characterSet[9]\n#define character_ast characterSet[10]\n#define character_crs characterSet[11]\n#define character_com characterSet[12]\n#define character_dsh characterSet[13]\n#define character_per characterSet[14]\n#define character_lsl characterSet[15]\n#define character_0 characterSet[16]\n#define character_1 characterSet[17]\n#define character_2 characterSet[18]\n#define character_3 characterSet[19]\n#define character_4 characterSet[20]\n#define character_5 characterSet[21]\n#define character_6 characterSet[22]\n#define character_7 characterSet[23]\n#define character_8 characterSet[24]\n#define character_9 characterSet[25]\n#define character_col characterSet[26]\n#define character_scl characterSet[27]\n#define character_les characterSet[28]\n#define character_equ characterSet[29]\n#define character_grt characterSet[30]\n#define character_que characterSet[31]\n#define character_ats characterSet[32]\n#define character_A characterSet[33]\n#define character_B characterSet[34]\n#define character_C characterSet[35]\n#define character_D characterSet[36]\n#define character_E characterSet[37]\n#define character_F characterSet[38]\n#define character_G characterSet[39]\n#define character_H characterSet[40]\n#define character_I characterSet[41]\n#define character_J characterSet[42]\n#define character_K characterSet[43]\n#define character_L characterSet[44]\n#define character_M characterSet[45]\n#define character_N characterSet[46]\n#define character_O characterSet[47]\n#define character_P characterSet[48]\n#define character_Q characterSet[49]\n#define character_R characterSet[50]\n#define character_S characterSet[51]\n#define character_T characterSet[52]\n#define character_U characterSet[53]\n#define character_V characterSet[54]\n#define character_W characterSet[55]\n#define character_X characterSet[56]\n#define character_Y characterSet[57]\n#define character_Z characterSet[58]\n#define character_lsb characterSet[59]\n#define character_rsl characterSet[60]\n#define character_rsb characterSet[61]\n#define character_pow characterSet[62]\n#define character_usc characterSet[63]\n#define character_a characterSet[64]\n#define character_b characterSet[65]\n#define character_c characterSet[66]\n#define character_d characterSet[67]\n#define character_e characterSet[68]\n#define character_f characterSet[69]\n#define character_g characterSet[70]\n#define character_h characterSet[71]\n#define character_i characterSet[72]\n#define character_j characterSet[73]\n#define character_k characterSet[74]\n#define character_l characterSet[75]\n#define character_m characterSet[76]\n#define character_n characterSet[77]\n#define character_o characterSet[78]\n#define character_p characterSet[79]\n#define character_q characterSet[80]\n#define character_r characterSet[81]\n#define character_s characterSet[82]\n#define character_t characterSet[83]\n#define character_u characterSet[84]\n#define character_v characterSet[85]\n#define character_w characterSet[86]\n#define character_x characterSet[87]\n#define character_y characterSet[88]\n#define character_z characterSet[89]\n#define character_lpa characterSet[90]\n#define character_bar characterSet[91]\n#define character_rpa characterSet[92]\n#define character_tid characterSet[93]\n#define character_lar characterSet[94]\n\nconst uvec4 characterSet[95] = uvec4[95]\n(\n    uvec4(0x000000,0x000000,0x000000,0x000000),\n    uvec4(0x003078,0x787830,0x300030,0x300000),\n    uvec4(0x006666,0x662400,0x000000,0x000000),\n    uvec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000),\n    uvec4(0x30307C,0xC0C078,0x0C0CF8,0x303000),\n    uvec4(0x000000,0xC4CC18,0x3060CC,0x8C0000),\n    uvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000),\n    uvec4(0x003030,0x306000,0x000000,0x000000),\n    uvec4(0x000C18,0x306060,0x603018,0x0C0000),\n    uvec4(0x006030,0x180C0C,0x0C1830,0x600000),\n    uvec4(0x000000,0x663CFF,0x3C6600,0x000000),\n    uvec4(0x000000,0x18187E,0x181800,0x000000),\n    uvec4(0x000000,0x000000,0x000038,0x386000),\n    uvec4(0x000000,0x0000FE,0x000000,0x000000),\n    uvec4(0x000000,0x000000,0x000038,0x380000),\n    uvec4(0x000002,0x060C18,0x3060C0,0x800000),\n    uvec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000),\n    uvec4(0x001030,0xF03030,0x303030,0xFC0000),\n    uvec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000),\n    uvec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000),\n    uvec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000),\n    uvec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000),\n    uvec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000),\n    uvec4(0x00FEC6,0xC6060C,0x183030,0x300000),\n    uvec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000),\n    uvec4(0x0078CC,0xCCCC7C,0x181830,0x700000),\n    uvec4(0x000000,0x383800,0x003838,0x000000),\n    uvec4(0x000000,0x383800,0x003838,0x183000),\n    uvec4(0x000C18,0x3060C0,0x603018,0x0C0000),\n    uvec4(0x000000,0x007E00,0x7E0000,0x000000),\n    uvec4(0x006030,0x180C06,0x0C1830,0x600000),\n    uvec4(0x0078CC,0x0C1830,0x300030,0x300000),\n    uvec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000),\n    uvec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000),\n    uvec4(0x00FC66,0x66667C,0x666666,0xFC0000),\n    uvec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000),\n    uvec4(0x00F86C,0x666666,0x66666C,0xF80000),\n    uvec4(0x00FE62,0x60647C,0x646062,0xFE0000),\n    uvec4(0x00FE66,0x62647C,0x646060,0xF00000),\n    uvec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000),\n    uvec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000),\n    uvec4(0x007830,0x303030,0x303030,0x780000),\n    uvec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000),\n    uvec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000),\n    uvec4(0x00F060,0x606060,0x626666,0xFE0000),\n    uvec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000),\n    uvec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000),\n    uvec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000),\n    uvec4(0x00FC66,0x66667C,0x606060,0xF00000),\n    uvec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00),\n    uvec4(0x00FC66,0x66667C,0x6C6666,0xE60000),\n    uvec4(0x0078CC,0xCCC070,0x18CCCC,0x780000),\n    uvec4(0x00FCB4,0x303030,0x303030,0x780000),\n    uvec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000),\n    uvec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000),\n    uvec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000),\n    uvec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000),\n    uvec4(0x00CCCC,0xCCCC78,0x303030,0x780000),\n    uvec4(0x00FECE,0x981830,0x6062C6,0xFE0000),\n    uvec4(0x003C30,0x303030,0x303030,0x3C0000),\n    uvec4(0x000080,0xC06030,0x180C06,0x020000),\n    uvec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000),\n    uvec4(0x10386C,0xC60000,0x000000,0x000000),\n    uvec4(0x000000,0x000000,0x000000,0x00FF00),\n    uvec4(0x000000,0x00780C,0x7CCCCC,0x760000),\n    uvec4(0x00E060,0x607C66,0x666666,0xDC0000),\n    uvec4(0x000000,0x0078CC,0xC0C0CC,0x780000),\n    uvec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000),\n    uvec4(0x000000,0x0078CC,0xFCC0CC,0x780000),\n    uvec4(0x00386C,0x6060F8,0x606060,0xF00000),\n    uvec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78),\n    uvec4(0x00E060,0x606C76,0x666666,0xE60000),\n    uvec4(0x001818,0x007818,0x181818,0x7E0000),\n    uvec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78),\n    uvec4(0x00E060,0x60666C,0x786C66,0xE60000),\n    uvec4(0x007818,0x181818,0x181818,0x7E0000),\n    uvec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000),\n    uvec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000),\n    uvec4(0x000000,0x0078CC,0xCCCCCC,0x780000),\n    uvec4(0x000000,0x00DC66,0x666666,0x7C60F0),\n    uvec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E),\n    uvec4(0x000000,0x00EC6E,0x766060,0xF00000),\n    uvec4(0x000000,0x0078CC,0x6018CC,0x780000),\n    uvec4(0x000020,0x60FC60,0x60606C,0x380000),\n    uvec4(0x000000,0x00CCCC,0xCCCCCC,0x760000),\n    uvec4(0x000000,0x00CCCC,0xCCCC78,0x300000),\n    uvec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000),\n    uvec4(0x000000,0x00C66C,0x38386C,0xC60000),\n    uvec4(0x000000,0x006666,0x66663C,0x0C18F0),\n    uvec4(0x000000,0x00FC8C,0x1860C4,0xFC0000),\n    uvec4(0x001C30,0x3060C0,0x603030,0x1C0000),\n    uvec4(0x001818,0x181800,0x181818,0x180000),\n    uvec4(0x00E030,0x30180C,0x183030,0xE00000),\n    uvec4(0x0073DA,0xCE0000,0x000000,0x000000),\n    uvec4(0x000000,0x10386C,0xC6C6FE,0x000000)\n);","name":"Common","description":"","type":"common"}]}