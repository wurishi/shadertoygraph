{"ver":"0.1","info":{"id":"flSGRy","date":"1624075103","viewed":166,"name":"Nested Cell Maze Generator","username":"MazeMason","description":"Similar to Recursive Division Algorithm,  this algorithm divides a cell (with state defined only by top and left openings) in four inner cells with states dictated from parent's openings. A novel rule has been added to reduce the squared texture.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["mazerecursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int level = 6;\nivec2 wall = ivec2(2); // wall thickness in pixels \n\nivec2 cellSize = ivec2(3); // wall plus corridor \nbool  fitScreen = true;   // If true corridor is recalculated for maze to fit screen\n\nfloat aspect = 1.0;\n \n\nfloat refresh = .1; // seconds between new mazes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    /*\n        Initialization code that should be precalculated outside shader\n    */\n    // How many cells\n    int cells = 1 << level;\n\n    // How much space on the screen\n    vec2 emptyCanvas = iResolution.xy - vec2((cells + 1) * wall);\n    vec2 roomSpace = (emptyCanvas / vec2(cells) + vec2(wall));\n    \n    // Then which size (or precalculated)\n    ivec2 cellSize = fitScreen ? ivec2(mix(roomSpace,vec2(min(roomSpace.x,roomSpace.y)),aspect)) : cellSize;\n    ivec2 mazeSize = cellSize * cells + wall;\n    /* End of initialization */\n    \n    \n    // Center the maze on screen\n    ivec2 uv = ivec2(fragCoord - (iResolution.xy - vec2(mazeSize))/2.0);\n    \n    /*\n    float a = 3.14159265359/6.0;\n    mat2 rot = mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    \n    vec2 uvf = fragCoord - iResolution.xy/2.0;\n    uvf = (rot * uvf);\n    uv = ivec2(cos(-a) * uvf.x - sin(-a) * uvf.y, uvf.y)+ mazeSize / 2;\n    */\n    \n    float brick;\n  \n    // Build only inside the maze\n    if(all(lessThan(uv, mazeSize)) && all(greaterThanEqual(uv, ivec2(0)))) {\n\n        // To build maze bricks are needed\n        ivec2 brickCoord = uv % cellSize;  \n            \n        \n        //Don't worry about external wall nor corner\n        if(any(greaterThanEqual(uv, mazeSize - wall)) || all(lessThan(brickCoord, wall))){\n            brick = 1.0;\n\n        } else if(all(greaterThanEqual(brickCoord, wall))){\n            // central cell always empty\n            brick = 0.0;\n\n        } else {\n\n             bvec2 blockType = iterateCell(uv, level, cellSize, vec2( float(mazeSize) * floor(iTime / refresh )* refresh));\n             \n             // Build only on final iteration    \n             brick = float(blockType.x && brickCoord.y < wall.y || \n                             blockType.y && brickCoord.x < wall.x);\n        } \n    }\n\n    // Output to screen, play with colors here\n    fragColor = vec4(1.0 - brick);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n\n}\n\n\n// Texture control\nfloat leftRight = .5;\nfloat upDown = .5;\n\nfloat inset = .4;\nfloat horizontalVertical = .5;\n\nbool topDoor = false;\nbool leftDoor = false;\n\n\n\n\n\n\nbvec2 iterateCell(ivec2 uv, int level, ivec2 cellSize, vec2 seed) {\n\n\n    // initial maze, only one cell\n    bvec2 blockType = bvec2(!topDoor, !leftDoor); \n\n    bvec2 cellType;\n    vec4 rnd = hash42(seed);\n\n    // Divide the cell in 4 inner cells, those cells in 4 and so on \n    for(int i = 1; i <= level; ++i) {\n\n        // the random door inside the cell\n        int inner = int(rnd.x < leftRight) * 2 +\n                    int(rnd.y < upDown); \n\n\n        int l = int(pow(2.0, float(level - i)));\n        ivec2 cellCoord = uv / (cellSize * l); \n        bvec2 blockCoord = bvec2(cellCoord % 2);\n        cellType = blockType;\n\n        // Only calculate one inner cell,\n        // the one for the fragment/pixel,\n        // but at all levels of recursion\n        if(rnd.z > inset|| cellCoord.x <= 1 || cellCoord.y <= 1) {\n            blockType.x = !any(blockCoord) && (rnd.x < leftRight || cellType.x && rnd.x >= leftRight) ||\n                              blockCoord.x && !blockCoord.y  && (rnd.x >= leftRight || cellType.x && rnd.x < leftRight)||\n                              all(blockCoord) && inner == 1 ||\n                              !blockCoord.x && blockCoord.y && inner == 3; \n\n            blockType.y = !any(blockCoord) && (rnd.y < upDown || cellType.y && rnd.y >= upDown) ||\n                              blockCoord.y  && !blockCoord.x && (rnd.y >= upDown || cellType.y && rnd.y < upDown)|| \n                              blockCoord.x && !blockCoord.y && inner == 0||\n                              blockCoord.x && blockCoord.y && inner == 2;\n        } else {\n            blockType.x = !any(blockCoord) && rnd.w <= horizontalVertical ||\n                              blockCoord.x && !blockCoord.y && cellType.x ||\n                              !blockCoord.x && blockCoord.y; \n\n            blockType.y = !any(blockCoord) && rnd.w > horizontalVertical ||\n                              blockCoord.y  && !blockCoord.x && cellType.y|| \n                              blockCoord.x && !blockCoord.y;\n\n        }\n\n\n        // next pseudo random, linked to the coordinates of parent cell\n        rnd = hash42(vec2(cellCoord) + seed);\n    }\n\n    return blockType;\n}\n","name":"Common","description":"","type":"common"}]}