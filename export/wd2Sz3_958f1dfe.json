{"ver":"0.1","info":{"id":"wd2Sz3","date":"1554583948","viewed":413,"name":"On Track","username":"Passion","description":"Enjoy","likes":17,"published":1,"flags":64,"usePreview":0,"tags":["raymarch","sky","life","track"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtX3D7","filepath":"https://soundcloud.com/allmau5/deadmau5-all-i-have","previewfilepath":"https://soundcloud.com/allmau5/deadmau5-all-i-have","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 128\n#define FUDGE_AMOUNT 0.75\n#define EPS 0.001\n#define FAR 50.0\n\n#define PI 3.1415926535898\n\n\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\nfloat surfFunc(in vec3 p){\n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.777));\n}\n\nvec2 path(in float z){ float s = sin(z/34.)*cos(z/12.)*cos(sin(z/20.)); return vec2(s*12.+sin(s)*6.1, s*15.); }\n\nmat3 lookAtMatrix(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c, s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat trackPlanks(vec3 tp){\n    tp.xy = (tp.xy - path(tp.z))*vec2(0.5, 0.47071);\n    tp.z = mod(tp.z, 1.) -0.5;\n    float bmp2 = texture(iChannel1, tp.xz/4.).r*.015;\n    return sdBox(vec3(tp.x,tp.y+1.4,tp.z), vec3(1., .05152, .2))+bmp2;\n}\nfloat trackRails(vec3 tp){\n    tp.xy = (tp.xy - path(tp.z))*vec2(0.5, 0.47071);\n    tp.z = mod(tp.z, 1.) -0.5;\n    tp.x = abs(tp.x)-1.;\n    return sdRoundBox(vec3(tp.x, tp.y+1.3, tp.z), vec3(.015, .015, .5), .12);\n}\nfloat map(vec3 p){\n    //float ground = p.y+2.5+surfFunc(p)-tri(p).y;\n    float ground = p.y + (sin(sin(p.z*0.1253) - p.x*0.311)*1.31 + cos(p.z*0.53 + sin(p.x*0.127))*0.12)*1.7 + 0.2;\n    ground += tri(p).y;\n    //float bmp = texture(iChannel0, p.xz/10.).r*.1;\n    //float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.0).x;\n\n    //ground+=bmp;\n    // Round tunnel.\n    // For a round tunnel, use the Euclidean distance: length(tun.y)\n    vec2 tun = (p.xy - path(p.z))*vec2(0.5, 0.47071);\n    float n = 1.- length(tun) + (0.5);\n    n += surfFunc(p/2.);\n    //n+=bmp;\n    vec3 tp = p;\n    \n    tp.xy = tun;\n    \n    \n    float planks = trackPlanks(p);\n    float rails = trackRails(p);\n        \n    return min(min(max(ground, n), planks), rails);\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++){\n        float d = map(o+r*t);\n        t += d * FUDGE_AMOUNT;\n        if(abs(d) < EPS || t > FAR) break;\n    }\n    return t;\n}\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x + eps, p.y, p.z)) - map(vec3(p.x - eps, p.y, p.z)),\n\t\tmap(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n\t\tmap(vec3(p.x, p.y, p.z + eps)) - map(vec3(p.x, p.y, p.z - eps))\n\t));\n\n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * .33));\n    vec3 o = vec3(0.0, 0.0, iTime*22.0);\n    \n    vec3 lookAt = o + vec3(0.0, -0.05,.245);\n    o.xy += path(o.z);\n    lookAt.xy +=path(lookAt.z);    \n    \n    mat3 camMat = lookAtMatrix(o, lookAt, -o.x/15.);  //clamp(o.x/3.,-.3,.3));\n    r = normalize(camMat * r);\n    \n\n    \n    float hit = trace(o, r);\n    vec3 surfPos = o + r * hit;\n    vec3 n = getNormal(surfPos);\n    vec4 bg = vec4(0.0);\n    vec3 l = normalize(vec3(-0.1, 0.38, -0.2));\n    //l.xz *= r2(iTime*3.);\n    float diff = max(dot(n,l), 0.5);\n\tbg = pow(vec4(.1, .7, .8, 1), vec4(4.*max(r.y,-0.141)+1.5)); //+(dot(r,l)*.315+.215);\n    float fog = smoothstep(0.75, 01.75, hit*0.03);\n    fragColor=vec4(0.0);\n    \n    float d = map(surfPos);\n    float d2 = trackRails(surfPos);\n    float d3 = trackPlanks(surfPos);\n    \n    if(abs(d) < EPS+.4){\n        vec3 tx = tex3D(iChannel2, surfPos/8., n);\n        fragColor = mix(vec4(1.0*diff), bg, fog);        //+ hit* -.04;\n        if(abs(d2)<EPS+.01){\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0)*diff;\n        }\n        else if(abs(d3) < EPS+0.1){\n            vec4 tx = texture(iChannel1, surfPos.xz);\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0)*diff;\n        }\n    }\n    else\n        fragColor = vec4(bg);\n}","name":"Image","description":"","type":"image"}]}