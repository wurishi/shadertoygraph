{"ver":"0.1","info":{"id":"Wtfczs","date":"1592826362","viewed":172,"name":"Noise Blue Procedural","username":"spalmer","description":"trying to construct proper blue noise procedurally.  Left: blue noise from texture.  Center Left:  procedural blue noise.  Center Right:  proc violet noise.  Right:  white noise.\nsee [url=http://shadertoy.com/view/tllcR2]Fabrice's toy[/url]\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","dither","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// an experiment\n// http://en.wikipedia.org/wiki/Colors_of_noise#Blue_noise\n// apparently violet noise is differentiated white noise\n// (the derivative/gradient of a white noise field)\n// so my theory is that one may obtain blue noise\n// by twice-differentiating white noise!\n// Alas, I had no way to verify one way or the other.\n// thanks again to Fabrice, now I *do* have a way!\n// see Noise DFT Analysis at http://shadertoy.com/view/3tlczs\n\n// Hoskins hash without sine from http://shadertoy.com/view/4djSRW\nfloat hash21(vec2 p)\n{\n\tvec3 q = fract(vec3(p.xyx) * .1031);\n    q += dot(q, q.yzx + 19.19);\n    return fract((q.x + q.y) * q.z);\n}\n\n// I had no tool for frequency analysis handy!\n// well Fabrice pointed me at his stuff so \n// I made http://shadertoy.com/view/3tlczs from it\n\n//float diff(float x)\n//{\n//    return .5 + .5 * (dFdx(x) + dFdy(x)); //fwidth(x);\n//}\n// 1st derivative in direction, central difference\n// f'(x) = (f(x+y) - f(x-y)) / (2|y|)\n#define diff2(f, x, y) (((f((x) + (y))) - (f((x) - (y)))) / (2.*length(y)))\n\n// 2nd derivative\n// f''(x) = ((f'(x+y) - f'(x)) / (|y|) \n//         - (f'(x) - f'(x-y)) / (|y|)) / (|y|)\n#define diff3(f, x, y) (((f((x) + (y))) + (f((x) - (y))) - 2.*(f((x)))) / dot(y,y))\n    // N.B. in 2D, this winds up being a plus-pattern high-pass filter\n    // with center coeff -.5 and all the rest .125\n    // after being normalized and all\n\nfloat whitenoise(vec2 p)\n{\n    return hash21(p);\n}\n/*\nfloat smooth1(float v) \n{\n    return (3. - 2.*v)*v*v;\n}\n\nfloat smooth2(float v)\n{\n    return ((6.*v - 15.)*v + 10.)*v*v*v;\n}\n*/\n    // with coordinate scale of 2., looks more like blue noise should.\n    // value samples looks gaussian distributed to me;  some averaging happened somehow.\n    // perhaps due to combination of two dimensional axes?\n    // h2 histogram in GIMP looks gaussian bell curve shaped if the gamma is correct\n    // but that apparently signifies nothing about the frequency distribution?!\n\t// since the original white noise range is 0 to 1,\n    // the deltas can be -1 to 1, and there's 2 of them, so they need averaged,\n    // which apparently gives us gaussian value distribution, bunched near mid-gray.\n// h2 is violet noise, from what I understand\n/*float violetnoiseslow(vec2 p)\n{\n    p *= 2.; // without, the resolution seems halved, pixels doubled  -- or used to! fine, now, but comes out more distorted, smeared, without\n    float s = .5; //sqrt(.5); //\n    float h2 = .5 + s * (\n          diff2(hash21, p, vec2(1,0))\n        + diff2(hash21, p, vec2(0,1))\n        );\n    h2 = h2 * 2. - .5; // rescale\n    return h2;\n}*/\n// can \"fix\" the gaussian value distribution by spreading the values back out in the range, but not necessary?\n    //h2 = smooth1(h2);\n    //h2 = smooth1(h2);\n// I suspect that the perlin quintic higher-order smoothing would be better than two smoothsteps -- not quite though!\n    //h2 = smooth2(h2);\nfloat violetnoise(vec2 p)\n{\n    p *= 2.;\n    return .5 \n        + diff2(hash21, p, vec2(1,0))\n        + diff2(hash21, p, vec2(0,1));\n}\n\n// h3 should be blue noise\n/*float bluenoiseslow(vec2 p)\n{\n    float s = .125;\n    float h3 = .5 + s * (\n          diff3(hash21, p, vec2(1,0)) \n        + diff3(hash21, p, vec2(0,1))\n        );\n    h3 = h3 * 2. - .5; // rescale\n    return h3;\n}*/\n//    p *= 2.; //1.; I think scale should match the violet - no, just breaks everything!  leave it!\n //1./6.; //.25; //2./6.;    // I'm pretty sure I need the coeff s to be 1./8. due to how I weighted the diff3 filter\n//    h2 = smooth1(h2);\nfloat bluenoise(vec2 p)\n{\n    return 1./4. * (\n          diff3(hash21, p, vec2(1,0)) \n        + diff3(hash21, p, vec2(0,1))\n        ) + .5;\n}\n\nfloat bluenoisetex(vec2 p)\n{\n    // Has a characteristic mottled appearance.  Made from void and cluster method I think?\n    float g = texelFetch(iChannel3, ivec2(p) % textureSize(iChannel3, 0), 0).x;\n    return g; //pow(g, 2.2); //\n}\n\n// was thinking about trying to be clever with quadding and dFdx/dFdy, but... nah.\n//    vec2 q = p + mod(floor(p), 2.) * 2. - 1.;\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 R = iResolution.xy\n    , uv = p/R;\n    float n = .5;\n    switch (int(uv.x * 4.)) {\n        case 0: n = bluenoisetex(p); break;\n        case 1: n =    bluenoise(p); break;\n        case 2: n =  violetnoise(p); break;\n        default:\n        case 3: n =   whitenoise(p); break;\n    }\n    // TODO should put histograms on the bottom half of image\n    //n = pow(n, 1./2.2); // srgb gamut - messes up GIMP histogram somehow\n    o = vec4(n,n,n,1); // grayscale\n}\n\n","name":"Image","description":"","type":"image"}]}