{"ver":"0.1","info":{"id":"7scczs","date":"1653925055","viewed":139,"name":"Escher Spirals","username":"nbardiuk","description":"Animation of M.C. Escher Spirals","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sdf","spiral","escher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Animation of Escher Spirals\n// https://www.wikiart.org/en/m-c-escher/spirals\n\n//Credit:\n// https://www.shadertoy.com/view/ttXBzB\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License https://creativecommons.org/licenses/by-nc-sa/3.0\n\nuniform vec2 u_resolution;\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat3 rotate3d(in vec3 axis, in float radians) {\n  axis = normalize(axis);\n  float s = sin(radians);\n  float c = cos(radians);\n  float oc = 1.0 - c;\n\n  return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n              oc * axis.z * axis.x + axis.y * s,\n              oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,\n              oc * axis.y * axis.z - axis.x * s,\n              oc * axis.z * axis.x - axis.y * s,\n              oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat spiral(in vec3 p, in float torus_thickness, in float faze) {\n  float df = iTime * .1;\n  float f0 = 1. / 5. * faze + df;\n  float f1 = 2. / 5. * faze + df;\n  float f2 = 3. / 5. * faze + df;\n  float f3 = 4. / 5. * faze + df;\n  float torus_radius = 1.;\n  float torus_circle = length(vec2(length(p.xz) - torus_radius, p.y));\n  float fr = 3.;\n  float a = atan(p.x, p.z);\n  torus_thickness *= 1. + .6 * sin(.5 * a);\n\n  vec3 c = torus_radius * vec3(sin(a), 0., cos(a));\n  vec3 b = vec3(c.z, 0., -c.x); // c rot 90 in xz plane\n  vec3 r = torus_thickness * vec3(sin(a), 0., cos(a));\n  vec3 s0 = c + r * rotate3d(b, fr * (a + f0));\n  vec3 s1 = c + r * rotate3d(b, fr * (a + f1));\n  vec3 s2 = c + r * rotate3d(b, fr * (a + f2));\n  vec3 s3 = c + r * rotate3d(b, fr * (a + f3));\n  float pc = length(p - c);\n  float d = min(p.y + 1.2,\n                max(max(-(pc - torus_thickness * .9), pc - torus_thickness),\n                    min(min(length(p - s0), length(p - s1)),\n                        min(length(p - s2), length(p - s3))) -\n                        torus_thickness * .4));\n  return d;\n}\n\nfloat GetDist(in vec3 p) {\n  float faze = 2.6;\n  return min(spiral(p, .4, faze), spiral(p, .1, faze)) * .4;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = GetDist(p);\n    dO += dS;\n    if (dO > MAX_DIST || abs(dS) < SURF_DIST)\n      break;\n  }\n\n  return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n  float d = GetDist(p);\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n\n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p), r = normalize(cross(vec3(0, 1, 0), f)),\n       u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u,\n       d = normalize(i);\n  return d;\n}\n\nfloat GetLight(vec3 p) {\n  vec3 lightPos = vec3(-30., 0., -5.);\n  vec3 l = normalize(lightPos - p);\n  vec3 n = GetNormal(p);\n\n  float dif = clamp(dot(n, l) * .5 + .5, 0., 1.);\n  float d = RayMarch(p + n * SURF_DIST * 2., l);\n  if (p.y < .01 && d < length(lightPos - p))\n    dif *= .5;\n\n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(2., 3., -2.);\n\n  vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n  float d = RayMarch(ro, rd);\n  if (d < MAX_DIST) {\n    vec3 p = ro + rd * d;\n    vec3 n = GetNormal(p);\n    float dif = dot(n, normalize(vec3(-10., -2., 5.))) * .5 + .5;\n    col = vec3(dif);\n  }\n\n  col = pow(col, vec3(.4545)); // gamma correction\n\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}