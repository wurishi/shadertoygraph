{"ver":"0.1","info":{"id":"ftSczK","date":"1649899581","viewed":108,"name":"Julia escape distances","username":"Kneebiter","description":"Based on an academic paper I've long since lost reference to. Various colorizations of the Julia set based on distances seen while calculating whether the initial point escapes or not. Visualizations split into red, green, and blue channels.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 0.001;\n\n// Complex multiply\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, 2. * a.x * b.y);\n}\n\n// Advances j through one iteration of Julia fractal escape calculation.\nvec2 julia_step(vec2 j) {\n    vec2 ret = cmul(j, j);\n    ret += vec2(sin(iTime*0.8) - 1.4, sin(iTime*0.73) * 1.8);\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.);\n    uv *= 2.5;\n\n    vec2 uv2 = uv;\n    vec2 d = uv + vec2(epsilon);\n    float traveled = 0.;\n    float pTraveled = 0.;\n    float traveled2 = 0.;\n    float pTraveled2 = 0.;\n    float uvLength = length(uv);\n\n    int i = 0;\n    while ( i < 100 && length(uv) < 4.) {\n        i++;\n        vec2 t = julia_step(uv);\n\n        pTraveled2 = traveled2;\n        pTraveled = traveled;\n        vec2 s = t - uv2;\n        float sLength = length(s);\n        float inter = abs(sLength - uvLength);\n        traveled += abs((length(t) - inter)/(uvLength - inter));\n        traveled2 += abs((length(t) - inter)/(sLength - inter));\n        uv = t;\n    }\n\n    // Reduces some of the terracing seen, especially in the blue color channel\n    float overage = abs(length(uv) / 40.);\n    if (overage < epsilon) {\n        overage = epsilon;\n    }\n\n    for (int y = 0; y < 15; y++) {\n        uv2 = julia_step(uv2);\n        d = julia_step(d);\n    }\n\n    float dist = length(uv2 - d);\n    float ldist = log(log(dist));\n\n    float tia = traveled / float(i);\n    float pTia = pTraveled / float(i - 1);\n    float tia2 = traveled2 / float(i);\n    float pTia2 = pTraveled2 / float(i - 1);\n\n    fragColor = vec4(\n        1. - 1./ldist,\n        1. - (1. / tia + (pTia - tia) * fract(overage)),\n        1. - (1. / tia2 + (pTia2 - tia2) * fract(overage)),\n        1);\n}","name":"Image","description":"","type":"image"}]}