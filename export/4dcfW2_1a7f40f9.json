{"ver":"0.1","info":{"id":"4dcfW2","date":"1526697541","viewed":395,"name":"Twisted Domain","username":"Plento","description":"Playing with domain repetition and general sdf modeling. starting to get a feel for glsl and raymarching","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","domain","twist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define MAX_MARCH_STEPS 128\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.7\n\n// Change some parameters here!!\n#define SPIN_SPEED 0.6\n#define MOVE_SPEED 2.5\n\n#define BEAM_WIDTH 0.4     \n\n\n\nmat2 rotmat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 mouse()\n{\n    vec2 m = iMouse.xy / iResolution.xy-.5; // mouse input\n    m.x *= iResolution.x/iResolution.y;\n    \n\treturn m;\n}\n\t\n// distance functions: https://iquilezles.org/articles/distfunctions\nfloat opS( float d1, float d2 ) {return max(-d1,d2);}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 ) { return min(d1,d2);}\n\n\n\nfloat sdBuilding(vec3 p) //my function that describes the \"building\" structure before its bent \n{\n \t\n    vec3 b = vec3(0.0, 2.0, 0.0);\n    vec3 b2 = vec3(1.1, 1.1, 1.1);\n\n    vec3 translate = vec3(0.0, 0.0, 16.0);\n    \n    vec3 pos = p - translate; \n    vec3 pos2 = pos;\n    vec3 pos3 = pos; \n    \n    //rotate\n    pos.xz *= rotmat(iTime * SPIN_SPEED);\n    pos2.xz *= rotmat(iTime * SPIN_SPEED);\n    pos3.xz *= rotmat(iTime * SPIN_SPEED);\n    \n    // translate down\n    pos.y += iTime * MOVE_SPEED;\n    pos2.y += iTime * MOVE_SPEED;\n    pos3.y += iTime * MOVE_SPEED;\n    \n    pos = mod(pos, b) - 0.5 * b;\n    float distance_1 = sdBox(pos, vec3(5.5, 1.0, 3.5)); // visible box\n    \n    pos2 = mod(pos2, b2) - 0.5 * b2;\n    float distance_2 = sdBox(pos2, vec3(1.5, BEAM_WIDTH, BEAM_WIDTH)); // subtracting block\n    \n    pos3 = mod(pos3, b2) - 0.5 * b2;\n    float distance_3 = sdBox(pos3, vec3(BEAM_WIDTH, BEAM_WIDTH, 1.5)); //subtracting block\n    \n    float distance_4 = opU(distance_2, distance_3); // union the two subtracting blocks\n    \n    float distance_5 = opS(distance_4, distance_1); // final\n    \n    \n    return distance_5;\n}\n\nfloat Bend( vec3 p ) // modified version of the bend function from Iq's website\n{\n    float c = cos( length(p) * 0.07) ;\n    float s = sin( length(p) * 0.07);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    return sdBuilding(q);\n}\n\nvec2 sdScene(vec3 position) // my scene\n{\n\t\n    vec3 translate = vec3(0.0, 0.0, 16.0);\n    \n    vec3 pos = position - translate; \n   \n    float mat_id = 1.0;\n    \n    float distance_5 = Bend(pos);\n     \n    return vec2 (distance_5, mat_id);\n    \n}\n\nvec2 raymarch(vec3 position, vec3 direction) // MARCH\n{ \n    float depth = NEAR_CLIPPING_PLANE; \n    \n    for(int i = 0; i < MAX_MARCH_STEPS; i++)\n    {\n     \tvec2 result = sdScene(position + direction * depth); \n        \n        if(result.x < EPSILON) \n        {\n         \treturn vec2(depth, result.y);   \n        }\n        \n        depth += result.x * DISTANCE_BIAS; \n        \t\t\t\t\t\t\t\t    \n        if(depth > FAR_CLIPPING_PLANE) \n        \tbreak;  \n    }\n    return vec2(FAR_CLIPPING_PLANE, 0.0);\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t  \n}\n\n\nvec3 normal(vec3 ray_hit_position, float smoothness) //Thanks MacSlow\n{  \n    vec3 n;\n    vec2 dn = vec2(smoothness, 0.0);\n    float d = sdScene(ray_hit_position).x;\n    n.x = sdScene(ray_hit_position + dn.xyy).x - d;\n    n.y = sdScene(ray_hit_position + dn.yxy).x - d;\n    n.z = sdScene(ray_hit_position + dn.yyx).x - d;\n    return normalize(n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n    \n    vec3 camera = vec3(0.0, 0.0, 0.0); \n  \n    vec3 ray_direction = normalize(vec3(uv, 2.0));\n    \n    vec2 result = raymarch(camera, ray_direction);\n    \t\t\t\t\t\t\t\t\t\t   \n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    \n    if(result.x != FAR_CLIPPING_PLANE) \n    \tmaterialColor = vec3(0.9, 0.9, 0.9);\n    \n  \n    float fog = pow(0.4 / (0.4 + result.x), 0.3);\n   \n    \n    vec3 intersection = camera + ray_direction * result.x;  \t\t\t\t\t\t\t\t\t\t\t\t\t  \n    vec3 nrml = normal(intersection, 0.001); // get normals\n    \n    vec3 light_dir = normalize(vec3(0.1, 0.1, -1.0)); \n    \n    float diffuse = dot(light_dir, nrml); \n    \n    diffuse = max(0.3, diffuse);\n    \n    vec3 light_color = vec3(1.6, 1.2, 0.7) * 2.55; \n    vec3 ambient_color = vec3(0.2, 0.45, 0.5) * 1.6; \n    \n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color); // final color for scene object\n    \n    if(result.x == FAR_CLIPPING_PLANE) \n    {\n    \t fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n    }\n    else\n    {\n    \tfragColor = vec4(diffuseLit, 1.0) * fog; \n    }\n        \n    \n    \n}","name":"Image","description":"","type":"image"}]}