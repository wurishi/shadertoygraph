{"ver":"0.1","info":{"id":"MlKSWR","date":"1485201697","viewed":424,"name":"deadmau5","username":"Kastor","description":"Playing around with signed depth functions","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ray marching\nconst int max_iterations = 512;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\naxis = normalize(axis);\nfloat s = sin(angle);\nfloat c = cos(angle);\nfloat oc = 1.0 - c;\nreturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\noc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\noc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n0.0, 0.0, 0.0, 1.0);\n}\n\n// iq's distance function\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r, float angle )\n{\n   \tfloat x = p.x;\n    float y = p.y;\n    x = x * cos(angle) - y * sin(angle);\n    y = x * sin(angle) + y * cos(angle);\n    vec3 p2 = vec3(x, y, p.z);\n    return (length( p2/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    float angle = PI * 0.5;\n   \tfloat x = p.x;\n    float z = p.z;\n    x = x * cos(angle) - z * sin(angle);\n    z = x * sin(angle) + z * cos(angle);\n    vec3 p2 = vec3(x, p.y, z) ;\n    vec4 p3 = vec4(p2, 1.0) * rotationMatrix(vec3(0.0, 0.0, 1.0), 0.90);\n    p2 = vec3(p3.x, p3.y, p3.z);\n    vec3 q = abs(p2);\n    return max(q.z-h.y,max(q.x*0.866025+p2.y*0.5,-p2.y)-h.x*0.5);\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ear left\n    float v =  sdEllipsoid( pos + vec3(0.35, -0.3, 0.0), vec3(0.32, 0.22, 0.5), 0.5 );\n   \t// ear right\n    v = min(v, sdEllipsoid( pos + vec3(-0.35, -0.3, 0.0), vec3(0.32, 0.22, 0.5), -0.5 ));\n    // flatten ears\n    v = max(v, sdBox(pos, vec3(1.0, 1.0, 0.03)));\n    // head\n    v = min(v,sdSphere( pos, 0.3 ));\n    v = min(v,sdSphere( pos + vec3(-0.14, -0.10, -0.20), 0.1 ));\n    v = min(v,sdSphere( pos + vec3(0.14, -0.10, -0.20), 0.1 ));\n    v = max(v, -sdTriPrism( pos + vec3(0.46, 0.18, -0.18), vec2(0.2, 0.3)));\n    return v;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec3 p = origin + dir * depth;\n\t\tfloat dist = dist_field( p ) / length( gradient( p ) );\n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 1.8 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.035, 0.02 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = vec4( 0.3, 0.4, 0.5, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}