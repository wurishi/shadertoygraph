{"ver":"0.1","info":{"id":"tlcBWS","date":"1613340223","viewed":125,"name":"PID Controller","username":"spalmer","description":"demonstration of a basic PID controller, responding to varying set-point over time.  Tunable for many different applications.  Use mouse to adjust bias dynamically to watch it respond.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["controller","pid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// told https://shadertoy.com/user/FabriceNeyret2 I'd make a demo of a PID controller  :)\n\n// draws white dot (current control value) as it tries to match\n// the moving blue dot (current set point or target, a wiggling function over time)\n// while being pushed by the mouse bias (red dot) to represent a \"load\".\n\nvoid DrawDot(inout vec4 cpixel, vec3 c, vec2 ppixel, vec2 p, float r)\n{\n    float blend = clamp(.5 - (distance(ppixel, p) - r), 0., 1.);\n    cpixel.rgb = mix(cpixel.rgb, c, blend);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    //c = T(p/R.xy);\n    float t = iTimeDelta\n    , bias = iMouse.z < 0. ? 0. : iMouse.x / R.x;\n    vec4 d0 = T(ivec2(0,0))\n    , d1 = T(ivec2(1,0)); // data pixels\n    PIDControllerFloat pid = LoadPIDController(d0);\n    // draw moving dots\n    c = vec4(0,0,0,1);\n    DrawDot(c, vec3(1,1,1),  p, vec2(R.x * pid.control, R.y/2.), R.y/20.);\n    DrawDot(c, vec3(0,.5,1), p, vec2(R.x * pid.target , R.y/2.), R.y/30.);\n    if (iMouse.z >= 0.)\n    DrawDot(c, vec3(.5,0,0), p, vec2(R.x * bias       , R.y/3.), R.y/40.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// t is delta time, likely in seconds\n// v is current value of thing we're controlling\n// target is current target value, set point\nvoid AdvancePIDController(float t\n    , PIDControllerSettings settings\n    , inout PIDControllerFloat pid) // outputs the new control value to set to and the new state\n{\n    float error = pid.target - pid.control;\n    float integral = pid.integral += error * t; // accumulate error\n    float derivative = (error - pid.prevErr) / t; // not stored\n    pid.prevErr = error; // maintain error state for next run\n    pid.control += settings.Kp * error\n        + settings.Ki * integral\n        + settings.Kd * derivative; // sum up\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    c = vec4(0);\n    if (int(p.y) != 0) \n        return;\n    float t = iTimeDelta\n    , bias = iMouse.z < 0. ? 0. : (2.*iMouse.x - R.x) / R.x;\n    vec4 d0 = T(ivec2(0,0))\n    , d1 = T(ivec2(1,0)); // data pixels\n    PIDControllerSettings settings = PIDControllerSettings(.1, 1., .001);\n    PIDControllerFloat pid = LoadPIDController(d0);\n    pid.target = signal(iTime);\n    // add an error bias controlled by mouse to\n    // push off-course so can see how it responds\n    AdvancePIDController(t, settings, pid);\n    if (iFrame == 0) {\n        pid.control = .5;\n        pid.prevErr = 0.;\n        pid.integral = 0.;\n    }\n    pid.control += bias * t; // add fake bias to mess up equilibrium for demonstration purposes\n    // just in case something really goes wrong\n    pid.control = clamp(pid.control, -5., 5.);\n    pid.integral = clamp(pid.integral, -5e3, 5e3);\n    switch (int(p.x)) {\n        case 0: // PID controller state\n            c = vec4(pid.control, pid.target, pid.prevErr, pid.integral);\n            break;\n        case 1: // other stuff to communicate with Image tab or future iteration\n            c = vec4(0);\n            break;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define T(x) texelFetch(iChannel0, ivec2(x), 0)\n\n// https://en.wikipedia.org/wiki/PID_controller\n\n// basic PID, not standard form\n\nstruct PIDControllerSettings\n{\n    float Kp // proportional\n    , Ki     // integral\n    , Kd;    // derivative\n};\n\n// some people factor out Kp so Ki and Kd are proportions of it.\n\n// controller internal state (must store to data pixel)\nstruct PIDControllerFloat\n{\n    float control;\n    float target;   // aka the set point\n    float prevErr;  \n    float integral;\n};\n\n// example signal\nfloat signal(float t)\n{\n    return sin(.1*t) * cos(2.*t) * .45 + .5;\n}\n\n// load from data pixel d0\nPIDControllerFloat LoadPIDController(vec4 d0)\n{\n    PIDControllerFloat pid;\n    pid.control  = d0.x;\n    pid.target   = d0.y;\n    pid.prevErr  = d0.z;\n    pid.integral = d0.w;\n    return pid;\n}","name":"Common","description":"","type":"common"}]}