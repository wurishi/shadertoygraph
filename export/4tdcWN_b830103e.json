{"ver":"0.1","info":{"id":"4tdcWN","date":"1532692606","viewed":387,"name":"errf error function statistics","username":"ollj","description":"somehow there is no SIMPLE errorFunction standartDeviation shader.\n\nblue line has a first antiderivative of =1 from -infinity.x to +infinity.x (surface area of 1), and its local extrema is set by the mouse.\nwhich somehow does work fine for m.y=0.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["error","statistics","errf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ViewZoom 2.\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n#define dd(a)dot(a,a)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(vec2(-a.y,a.x),b)\nv0 suv(vec2 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}//return max domain of vector.\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nvec4 minx(vec4 a,vec4 b){return mix(b,a,step(a.x,b.x));}//return the vec4 with the smaller .x\n#define min2dd(a)min(dd(a.xy),dd(a.zw))\n#define equals(a,b,c)   mix(b,a,step(c,0.)+step(0.,c)-1.)\n#define equals2(a,b,c)   mix(b,a,step(c.x,0.)+step(0.,c.x)+step(c.y,0.)+step(0.,c.y)-3.)\nvec2 perp(vec2 a){return vec2(-a.y,a.x);}\nbool rea(float s,float b,float e){b-=s;return(abs(s-.5*b)*e<abs(b));}//return(abs(b-a*.5)<a*e);//return(s<b-e||s>b+e);\nv0 segment2(v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}\nv0 segment(v1 p,v1 a,v1 b){return sqrt(segment2(p,a,b));}\nv0 lie(v1 u,v1 a,v1 b\n){float c=dd(a-u);float d=segment2(u,a,b);a.x=equals2(c,d,(a-b));return sqrt(a.x);}\n//return distacne from [u] to intersection of ray [ut] and plane [n] trough origin. //[n]PlaneNormal,[u]RayOrigin,[t]RayDirection\n//float gPRxZ(vec3 n,vec3 u,vec3 t){return -(dot(n,u)/dot(n,t));}\nfloat gPRxZ(vec2 n,vec2 u,vec2 t){return -(dot(n,u)/dot(n,t));}//second life wiki geometric,is a generalization of segment():\n//lazy fast div0 avoidance.\n// Solve cubic equation for roots\nvec3 solveCubic(vec3 a){float p=a.y-a.x*a.x/3.,p3=p*p*p,q=a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z,d=q*q+4.*p3/27.,o=-a.x/3.\n;if(d>=.0){vec2 v=(vec2(1,-1)*sqrt(d)-q)/2.;return vec3(o+suv(sign(v)*pow(abs(v),vec2(1./3.))));}\n;float v=acos(-sqrt(-27./p3)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);return vec3(m+m,-n-m,n-m)*sqrt(-p/3.)+o;}\nvec2 solveCubic2(vec3 a)\n{float p=a.y-a.x*a.x/3.\n;float b=p*p*p,q=a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z\n;float d=q*q+4.*b/27.\n;float o=-a.x/3.\n;if(d>=.0){vec2 v=(vec2(1,-1)*sqrt(d)-q)/2.;return vec2(o+suv(sign(v)*pow(abs(v),vec2(1./3.))));}\n;float v=acos(-sqrt(-27./b)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);return vec2(m+m,-n-m)*sqrt(-p/3.)+o;}\nfloat sdBezier(vec2 A,vec2 B,vec2 C,vec2 u){\n;if(!(rea(A.y,C.y,.001)))return lie(u,A,C);\n;vec4 b=A.xyxy-vec4(u,B*2.-C);vec2 a=B-A,t=sat(solveCubic2(vec3(3.*dot(a,b.zw),2.*dd(a)+dot(b.xy,b.zw),dot(b.xy,a))/dd(b.zw)))\n;vec4 c=a.xyxy*2.;A-=u;b=A.xyxy+vec4(a.xy*2.+b.zw*t.x,a.xy*2.+b.zw*t.y)*t.xxyy;return sqrt(min2dd(b));}\n\nconst float tiny=1e-7;//smallest denormalNumber>0_16bit_float is pow(2,-24)\n#define if0(a)if(a==0.)a=tiny\n\n\n\n#define pi acos(-1.)\n#define eul 2.718281828459\n\n//for https://en.wikipedia.org/wiki/Normal_distribution\n//good gamma curves rely on a gamma distribution function,which is hard to estimate,people tried anyways,with 9th degree curve approximations:\n//https://rosettacode.org/wiki/Gamma_function#Java\n\n//https://en.wikipedia.org/wiki/Error_function //Horner 5th degree approximation of [2.*integralfrom0toX(pow(e,-(t*t))/pi] \nfloat erf(float x){//if(abs(x)<1e-3)return 1.1283791670955126*x;//option for even smaller RELATIVE error.\n ;float t=1./(1.+.3275911*abs(x))//Handbook of Mathematical Functions by Abramowitz and Stegun\n ;float y=1.-(((((1.061405429*t-1.453152027)*t)+1.421413741)*t-.284496736)*t+.254829592)*t*exp(-x*x)\n ;return sign(x)*y;}//https://www.johndcook.com/blog/cpp_erf/   //maximum error<1.5e-7\n\n//u=mean median mode expectation\n//o= standard deviation(sigma)\n//oo=\"variance\"=CUBED(!)standard deviation(sigma*sigma)\nfloat distNorm(float x,float u,float oo){ return 1./sqrt(2.*pi*oo)*pow(eul,((x-u)*(x-u)/2.*oo));}\n\n\n//area under curve=1. //maximum at 1./sqrt(2*pi)<->distNormStandard\nfloat distNormStandardA(float x){return pow(eul,-.5*x*x)/sqrt(pi);}//==return distNorm(x,0.,1.);\n//other \"standart\"s are simpler,but less usefull to statistics.\nfloat distNormStandardB(float x){return pow(eul,-(x*x)/sqrt(pi));}//==return distNorm(x,0.,.5);\nfloat distNormStandardC(float x){return pow(eul,-(x*x) *pi);}//==return distNorm(x,0.,1./tau);\nfloat distNormGen(float x,float u,float o){return distNormStandardA(x/o-u/o)/o;}//scale by 1./o to make surface area ==1\n\n//\"stable distribution\" is a thing,but it involves an integral from -inf to +inf,and that is pretty excessive.\n\nvoid mainImage(out vec4 O,vec2 I){//;int a=34%3\n ;vec2 u=fra(I);\n ;vec2 m=fra(iMouse.xy);\n ;vec2 n=(iMouse.zw-.5)*ViewZoom;\n ;m.y*=5.\n ;m.x*=5.*.5\n ;u*=5.\n     //scaling canvases sucks\n //;if(iMouse.z>0.)m=n;\n ;m.x*=iResolution.x/iResolution.y\n ;n.x*=iResolution.x/iResolution.y\n\n ;vec3 c=vec3(0);\n //;c.x=distNormStandardA(u.x)-u.y\n ;c.x=distNormGen(u.x,m.x,.55/m.y)-u.y\n ;c.y=distNormStandardB(u.x)-u.y\n ;c.z=distNormStandardC(u.x)-u.y\n ;c=smoothstep(-.01,.01,abs(c)-.05)\n //;c=fract(c);\n ;O=vec4(c,1)\n ;}\n\n","name":"Image","description":"","type":"image"}]}