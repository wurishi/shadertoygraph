{"ver":"0.1","info":{"id":"stGXRy","date":"1640952235","viewed":176,"name":"Happy new year 2022","username":"arwey7","description":"Hmmm...","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["newyear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parokhod of Arwey\n// Little shader that makes really no sense\n// Christmas tree implementation idea took from user Tetane\n// Anyway, happy new year 2022!\n\n#define NOMBRE_PARTICULES 80.\n#define NOMBRE_POINTS_ARBRE 100.\n#define pi 3.1415926535\n\n// fireworks\n\n// direction giving \nvec2 RandomDirectionPolar(float x) // polar coordinates\n{\n    float angle = fract(sin(x * 312.4) * 342.52) * 2. * pi; // pseudorandomizer\n    float dist = fract(sin(x * 512.2) * 524.24);\n    return vec2(sin(angle), cos(angle)) * dist;\n}\n\n// explosion effect\nfloat FireworkExplosion(vec2 uv, float t, vec2 position, vec2 scale)\n{\n    uv -= position;\n    uv *= scale;\n    float sparks = 0.;\n    for(float i = 0.; i < NOMBRE_PARTICULES; i++)\n    {\n        vec2 direction = RandomDirectionPolar(i);\n        float time = fract(iTime);\n        float point = length(uv - direction * time);\n    \n        float brightness = mix(.0008, .002, smoothstep(.1, 0., time));\n        brightness *= sin(time * 20. + i) * .5 + .5;\n        sparks += brightness/point;\n    }\n    return sparks;\n}\n\n// rectangle base code\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1*step2;\n}\n\nfloat Rectangle(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1 * band2;\n}\n\n// circle base code\nfloat Circle(vec2 uv, vec2 position, float radius, float blur)\n{\n    float dist = length(uv - position);\n    float c = smoothstep(radius, radius-blur, dist);\n    return c;\n}\n\n// stars\nvec3 Star(vec2 uv, vec2 position, float intensity)\n{\n    uv -= position;\n    vec3 star = vec3(0);\n    float p = length(uv);\n    star += intensity/p;\n    return star;\n}\n\n// HSV to RGB code\nvec3 hsv2rgb (vec3 hsv) { \n\thsv.yz = clamp (hsv.yz, 0., 1.);\n\treturn hsv.z * (1. + .63 * hsv.y * (cos (2. * 3.14159 * (hsv.x + vec3 (0., 2. / 3., 1. / 3.))) - 1.));\n}\n\n// christmas tree code\nvec3 ChristmasTree(vec2 uv, vec2 position, float size){\n    uv -= position; // translation\n    uv *= size;     // scale\n    \n    float lightintensity = 1. / 1500.;\n    float mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n    vec2 dotpos  = vec2(0.);\n    vec3 col = vec3(0.);\n    float time = iTime;\n    \n    // tree\n    float angle = NOMBRE_POINTS_ARBRE * 1.8; // angle for the conus\n    for(float i = 0. ; i < NOMBRE_POINTS_ARBRE ; i++)\n    {\n\t\tdotpos = vec2(scrs.x / 2. + sin(i / 2. - time * .2)/(3. / (i + 1.0) * angle), scrs.y * ( (i) / NOMBRE_POINTS_ARBRE + .22) * .9);\n\t\tcol += hsv2rgb(vec3(1.5 * i / NOMBRE_POINTS_ARBRE + fract(time / 4.), distance(uv, dotpos) * (1. / lightintensity), lightintensity / distance(uv,dotpos)));\n\t}\n    \n    return col;\n}\n\n// rendering stuff to the screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 mask = vec3(0.);\n    \n    // silhouettes\n    mask += Rectangle(uv, -.1, 0., -.26, -.18, .02) * vec3(0.196, 0.207, 0.192);\n    mask += Rectangle(uv, .1, .24, -.1, -.02, .02) * vec3(0.196, 0.207, 0.192);\n    mask += Rectangle(uv, .42, .48, -.1, -.02, .02) * vec3(0.196, 0.207, 0.192);\n    mask += Rectangle(uv, .5, .6, -.1, -.06, .02) * vec3(0.196, 0.207, 0.192);\n    mask += Rectangle(uv, .6, .7, -.5, -.06, .02) * vec3(0.196, 0.207, 0.192);\n\n    // city buildings\n    mask += Rectangle(uv, 0., .24, -.4, -.1, .002) * vec3(0.623, 0.627, 0.513);\n    mask += Rectangle(uv, .24, .4, -.3, .05, .002) * vec3(0.420, 0.388, 0.352);\n    mask += Rectangle(uv, .4, .6, -.3, -.1, .002) * vec3(0.360, 0.388, 0.352);\n    \n    // windows\n    float heightIncrement = .02;\n    \n    // building 1\n    vec3 windowColor = vec3(0.960, 0.968, 0.372) * cos(iTime+uv.xyx+vec3(0,2,4));\n    mask += Rectangle(uv, .01, .09, -.22, -.21, .002) * windowColor;\n    for(float k = 0.; k < 5.; k++)\n    {\n        mask += Rectangle(uv, .01, .23, -.2 + k * heightIncrement, -.19 + k * heightIncrement, .002) * windowColor;\n    }\n    \n    // building 2\n    vec3 windowColor2 = vec3(0.960, 0.968, 0.372) * sin(iTime+uv.xyx+vec3(0,2,4));\n    mask += Rectangle(uv, .25, .39, -.18, -.17, .002) * windowColor2;\n    for(float j = 0.; j < 11.; j++)\n    {\n        mask += Rectangle(uv, .25, .39, -.18 + j * heightIncrement, -.17 + j * heightIncrement, .002) * windowColor2;\n    }\n    \n    // building 3\n    vec3 windowColor3 = vec3(0.960, 0.968, 0.372) * tan(iTime+uv.xyx+vec3(0,2,4));\n    mask += Rectangle(uv, .41, .59, -.18, -.17, .002) * windowColor3;\n    for(float l = 0.; l < 4.; l++)\n    {\n        mask += Rectangle(uv, .41, .59, -.18 + l * heightIncrement, -.17 + l * heightIncrement, .002) * windowColor3;\n    }\n    \n    // snow hill (yes, I know it's pure govnokod, no time to think of some better solution)\n    mask += Circle(uv, vec2(0.5,-2), 1.8, 0.02) * vec3(0.937, 0.937, 0.901);\n    mask += Circle(uv, vec2(0.,-.42), 0.2, 0.02) * vec3(0.925, 0.925, 0.894);\n    mask += Circle(uv, vec2(-.3,-.58), 0.2, 0.02) * vec3(0.925, 0.925, 0.874);\n    mask += Circle(uv, vec2(-.2,-.52), 0.2, 0.02) * vec3(0.909, 0.909, 0.850);\n    mask += Circle(uv, vec2(-.1,-.45), 0.2, 0.02) * vec3(1., 1., 1.);\n    mask += Circle(uv, vec2(.1,-.42), 0.2, 0.02) * vec3(0.968, 0.960, 0.933);\n    mask += Circle(uv, vec2(.2,-.39), 0.2, 0.02) * vec3(0.964, 0.956, 0.894);\n    mask += Circle(uv, vec2(.3,-.38), 0.2, 0.02) * vec3(0.862, 0.858, 0.815);\n    mask += Circle(uv, vec2(.4,-.38), 0.2, 0.02) * vec3(0.952, 0.952, 0.949);\n    mask += Circle(uv, vec2(.5,-.38), 0.2, 0.02) * vec3(0.972, 0.960, 0.866);\n    mask += Circle(uv, vec2(.6,-.38), 0.2, 0.02) * vec3(0.999, 0.999, 0.999);\n    mask += Circle(uv, vec2(.7,-.40), 0.2, 0.02) * vec3(0.952, 0.952, 0.945);\n    \n    // christmas tree\n    mask += ChristmasTree(-uv, vec2(.1, -.2), .9);\n    \n    // fireworks\n    mask += FireworkExplosion(uv, fract(iTime), vec2(-.1, .1), vec2(3.)) * vec3(0.176, 0.329, 0.901);\n    mask += FireworkExplosion(uv, fract(iTime), vec2(.3, .2), vec2(3.)) * vec3(0.019, 1, 0.184);\n    mask += FireworkExplosion(uv, fract(iTime), vec2(.7, .1), vec2(4.)) * vec3(1, 0.149, 0.019);\n    \n    // stars (govnokod)\n    mask += Star(uv, vec2(-.75, .32), .001);\n    mask += Star(uv, vec2(-.1, .2), .001);\n    mask += Star(uv, vec2(.8, .45), .002);\n    mask += Star(uv, vec2(.1, .45), .0005);\n    mask += Star(uv, vec2(.6, .2), .002);\n    mask += Star(uv, vec2(-.2, 0.), .002);\n    mask += Star(uv, vec2(-.1, .56), .002);\n    mask += Star(uv, vec2(-.4, .24), .001);\n    mask += Star(uv, vec2(.5, .53), .001);\n    mask += Star(uv, vec2(.4, .2), .002);\n    \n    // moon\n    mask += Circle(uv, vec2(-.6, .3), .05, .05) * 1./mask;\n\n    fragColor = vec4(mask,1.);\n}","name":"Image","description":"","type":"image"}]}