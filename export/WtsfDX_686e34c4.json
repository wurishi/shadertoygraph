{"ver":"0.1","info":{"id":"WtsfDX","date":"1598281789","viewed":117,"name":"PentrSSe","username":"TomCat","description":"Prototype DOS VESA SSE RTRT","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","dos","svga"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Emulating DOS SVGA enviroment - code by TomCat/Abaddon\n#define RESX 640\n#define RESY 480\n\n#define LG2 0.30102999566\n#define LN2 0.69314718056\n#define BIGNUM 0x3f000000\n\n// distance of the light source\n#define L 65535.\n// constant for perspective correction\n#define P 500.\n\n// x86 registers\nint AX,BX,CX,DX,SI,DI,BP,SP;\n// x87 registers\nfloat ST0,ST1,ST2,ST3,ST4,ST5,ST6,ST7;\n// SSE registers\nvec4 XMM0,XMM1,XMM2,XMM3,XMM4,XMM5,XMM6,XMM7;\n\nstruct object\n{\n\tint Type;\n    vec4 Vector;\n    float Distance;\n    vec4 Color;   \n};\n\n#define OBJECTS 3\nobject Object[OBJECTS];   \n\nvoid InitScene()\n{   \n\tBX = OBJECTS;\n    \n    BX--;\n    Object[BX].Type = 0;\n    Object[BX].Vector = vec4(0.,0.,90.*cos(iTime),0.);\n    Object[BX].Distance = 60.*(P-Object[BX].Vector.z)/P;\n    Object[BX].Color = vec4(.60,.70,.45,.0);\n    BX--;\n\tObject[BX].Type = 0;\n    Object[BX].Vector = vec4(90.,-50.*sin(iTime),-10.,.0);\n    Object[BX].Distance = 40.;\n    Object[BX].Color = vec4(.33,.60,.68,.0);\n    BX--;\n\tObject[BX].Type = 0;\n    Object[BX].Vector = vec4(75.*sin(iTime),-50.,-70.,.0);\n    Object[BX].Distance = 15.;\n    Object[BX].Color = vec4(.70,.40,.20,.0);\n}\n\nvoid TestScene()\n{   \n    for (BX=1; BX<=OBJECTS; BX++)\n    {\n\t\t// selftest\n        if (BX != AX)\n        {    \n        \t// V = C-P\n    \t\tXMM1 = Object[BX-1].Vector - XMM6;\n       \t\t// b = V.D\n       \t\tST0 = dot(XMM1,XMM5);\n\t    \tif (ST0 > 0.)\n        \t{\n\t        \t// d2 = b2+r2-V.V\n\t        \tST0 = ST0*ST0 + Object[BX-1].Distance*Object[BX-1].Distance - dot(XMM1,XMM1);\n    \t    \tif (ST0 > 0.)\n\t        \t{\n\t        \t\t// shadow ray?\n                    if (CX == 0)\n                    {\n                        // blocked, early out\n                        break;\n                    }\n                    else\n                    {\n                    \t// b - d\n    \t        \t\tST0 = dot(XMM1,XMM5) - sqrt(ST0);\n                \t\tif (ST0 < ST1)\n                \t\t{\n\t    \t           \t\t// new hit\n    \t    \t           \tDX = BX;\n                    \t\t// new mimimum distance\n                        \tST1 = ST0;\n                    \t}\n                    }\n            \t}\n        \t}\n    \t}\n\t}\n}\n\nvoid Lights()\n{   \n    // Shading\n\n    // S = L-I\n    XMM5 = XMM0 - XMM6;\n    XMM5 = normalize(XMM5);\n    // Shadow vector in XMM5\n    CX = 0;\n\t// backup hit\n    AX = BX;\n    // Ambient\n    ST1 = LN2;\n\tTestScene();\n    \n\tif (BX > OBJECTS)\n    {\n    \t// Diffuse = N.S\n    \tST0 = dot(XMM4,XMM5);\n    \tif (ST0 > 0.)\n    \t{\n        \t// Ambient+Diffuse\n        \tST1 += ST0;\n        \t// Specular = R.S\n        \tST0 = dot(XMM3,XMM5);\n        \tST0 *= ST0;\n        \tST0 *= ST0;\n        \tST0 *= ST0;\n        \t// Color += level*Specular\n        \tXMM2 += ST2*ST0;\n    \t}\n    }\n\t// restore hit\n    BX = AX;\n    // Intensity = level*(Ambient+Diffuse)\n    XMM1 = vec4(ST2*ST1,ST2*ST1,ST2*ST1,0.);\n    // Color += Intesity*TexColor \n    XMM2 += XMM1 * Object[BX-1].Color;\n}\n\nvoid Trace()\n{   \n    // not a shadow test\n    CX = -1;\n\t// no hit yet\n    DX = 0;\n    // minimum distance\n    ST1 = float(BIGNUM);\n    TestScene();\n\n    if (DX > 0)\n    {\n    \t// Intersection\n        BX = DX;\n        // I = P+min*D\n        XMM6 += ST1*XMM5;\n        // N = -sqrt(2)/r*(C-I)\n        XMM4 = Object[BX-1].Vector - XMM6;\n        XMM4 *= -sqrt(2.)/Object[BX-1].Distance;\n        // R = D-2*N.D*N\n        XMM3 = XMM5 - dot(XMM4,XMM5) * XMM4;\n           \n\t\t// Light1\n        XMM0 = vec4(-L,-L,-L,0.);\n        Lights();\n\t\t// Light2\n        XMM0 = vec4(L,L,L,0.);\n        Lights();\n\n        // Prepareing for Reflection\n\n        // factor of level/2\n   \t\tST2 *= 0.5028877;\n        // D = R\n        XMM5 = XMM3;\n        // No recursive call :-(\n        // Tarce();\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Initial values\n    SI = 256;\n    \n    InitScene();\n    \n    // X world coordinate\n    CX = int(uv.x*float(RESX))-RESX/2;\n    // Y world coordinate\n    AX = int(uv.y*float(RESY))-RESY/2;\n\n    // Pixel color = Black\n    XMM2 = vec4(0);\n\n    // Very cheap orthogonal projection\n\n    // Point = x,y,neg_val,0\n    XMM6 = vec4(CX,AX,1,0);\n    // Aspect ratio correction\n    XMM6 *= vec4(0.5028877,0.39081812,-8260.683,0.);\n    // Direction = 0,0,1,0\n\tXMM5 = vec4(0,0,1,0);\n\n    // no previous hit\n    AX = 0;\n    // factor of level\n    ST2 = LG2;\n\tTrace();\n\n    // Reflections\n\tif (DX > 0)\n    {\n        // level 1\n        Trace();\n\t\tif (DX > 0)\n    \t{\n        \t// level 2\n\t\t\tTrace();\n\t\t\tif (DX > 0)\n    \t\t{\n        \t\t// level 3\n\t\t\t\tTrace();\n            }\n        }\n    }\n \n    // Output to screen\n    fragColor = XMM2;\n}","name":"Image","description":"","type":"image"}]}