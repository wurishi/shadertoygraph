{"ver":"0.1","info":{"id":"McsXWB","date":"1705683608","viewed":180,"name":"Heart monitor","username":"chronos","description":"wip for another shader: [url=https://www.shadertoy.com/view/MflXDj]TRIOPTIMUM[/url]","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["heart","monitor","ecg","ekg","rate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat linesegdist(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, clamp(dot(p-a, b-a)/dot(b-a,b-a), 0., 1.) * (b-a) + a);\n}\n\nfloat gaussian(float x) { return exp(-x*x); }\nfloat gaussian(float x, float std) { return gaussian(x/std); }\nfloat gaussian(float x, float std, float mean) { float z = (x-mean)/std; return gaussian(z); }\n\nvec3 debug_grid(vec3 color, vec2 uv, float subdivs)\n{\n    float pix_size = subdivs * 2. / iResolution.y;\n    vec2 f = fract(uv * subdivs); // centered on zero, linear from -0.5 to 0.5\n    f = min(f, 1.-f);\n    float s = min(f.x, f.y);\n    float alpha = 0.25 * smoothstep(pix_size, .5*pix_size, s);\n    return mix(color, vec3(1), alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    vec3 linecolor = vec3(1./255.,1.,0.075);\n    vec3 dotcolor = vec3(1./255.,1.,0.075);\n    \n    float mask = gaussian(length(uv / vec2(.8, .5)), 1.);\n    \n    color = mask * 0.1 * linecolor * debug_grid(color, uv, 10.);\n    \n    float mindist = 9e9;\n    \n    vec2 points[13] = vec2[13]\n    (\n        vec2( -2.0,  0.0),\n        vec2( 2.5,  0.0),\n        vec2( 4.5,  1.0),\n        vec2( 6.0,  0.0),\n        vec2( 7.7,  0.0),\n        vec2( 8.3, -1.4),\n        vec2( 9.0,  9.0),\n        vec2( 9.6, -2.7),\n        vec2(10.0, 0.),\n        vec2(12.8, 0.),\n        vec2(15.0, 1.5),\n        vec2(16.0, 0.),\n        vec2(20.0, 0.)\n    );\n    \n    for(int i = 1; i < 13; i+=1)\n    {\n        vec2 a = points[i-1]; \n        vec2 b = points[i-0];\n        \n        a /= 18.;\n        b /= 18.;\n        \n        a.x = 2. * (a.x) - 1.;\n        b.x = 2. * (b.x) - 1.;\n        \n        mindist = min(mindist, linesegdist(uv, a, b));\n    }\n    \n    const float percent = 0.01;\n    float pix_size = 2. / iResolution.y;\n    float line_blur = 0. * percent;\n    float linethickness = 1. * percent;\n    float alpha = smoothstep(line_blur + pix_size + linethickness/2., linethickness/2., mindist);\n    \n    float time = iTime * .91+0.01;\n    \n    float pulse_pos  = mod(1.6 + uv.x - time, 1.6)-1.6;\n    float grid_pulse = smoothstep(-0.1, -.15,pulse_pos) * gaussian(pulse_pos, .5);\n\n    vec3 pulse_color = mix(linecolor, vec3(1), 0.5*pow(smoothstep(.5,0.16, abs(pulse_pos)), 20.));\n    \n    color = mix(color, pulse_color, alpha * grid_pulse * mask);\n    \n    vec2 dotpos0 = vec2(mod(time-1.6-0.1,3.2)-1.6, 0.);\n    vec2 dotpos1 = vec2(mod(time    -0.1,3.2)-1.6, 0.);\n    \n    for(int i = 1; i < 13; i+=1)\n    {\n        vec2 a = points[i-1]; \n        vec2 b = points[i-0];\n        \n        a /= 18.;\n        b /= 18.;\n        \n        a.x = 2. * (a.x) - 1.;\n        b.x = 2. * (b.x) - 1.;\n        \n        if(dotpos0.x >= a.x && dotpos0.x < b.x)\n        {\n            dotpos0.y = mix(a.y, b.y, (dotpos0.x - a.x) / (b.x-a.x));\n        }\n        if(dotpos1.x >= a.x && dotpos1.x < b.x)\n        {\n            dotpos1.y = mix(a.y, b.y, (dotpos1.x - a.x) / (b.x-a.x));\n        }\n    }\n    \n    \n    \n    float dot_radius = 2. * percent;\n    float dotdist = length(uv - dotpos0);\n    \n    dotcolor = mix(vec3(1), dotcolor, 0.5*smoothstep(0., 1., 3.*dotdist));\n    float dotalpha =  gaussian(uv.x, 1.)/(12. + 400.* dotdist);\n    color += dotcolor * dotalpha * mask;\n    \n    dotdist = length(uv - dotpos1);\n    \n    dotcolor = mix(vec3(1), dotcolor, 0.5*smoothstep(0., 1., 3.*dotdist));\n    dotalpha =  gaussian(uv.x, 1.)/(12. + 400.* dotdist);\n    color += dotcolor * dotalpha * mask;\n    \n    //float trackeralpha = smoothstep(pix_size, 0., abs(uv.x-dotpos.x));\n    //color = mix(color, dotcolor, trackeralpha);\n    \n    color = tanh(color);\n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}