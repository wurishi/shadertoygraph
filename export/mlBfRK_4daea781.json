{"ver":"0.1","info":{"id":"mlBfRK","date":"1694226023","viewed":44,"name":"Lorentz gas","username":"zenzicubic","description":"The Lorentz gas model from statistical mechanics","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","chaos","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nProgrammed by Zenzicubic, 2023.\nSPDX-License-Identifier: MIT\n\nThis program demonstrates the Lorentz gas model from\nstatistical mechanics. This consists of rigid balls \nbouncing elastically in a cubic lattice with a bigger\nrigid ball in the center of each cell. For simplicity's\nsake, all collisions are taken to be elastic.\n\nWe simulate this by raytracing inside a cube with\nmirrored walls and a mirrored ball in the middle, \nsort of like a 3D version of the 2D Sinai billiard\nsystem.\nTry changing NBOUNCES.\n\nBased on work of Linas Vepstas: \nhttps://linas.org/art-gallery/billiards/billiards.html\n*/\n\nstruct Hit {\n    bool hit;\n    float t;\n    vec3 pt, normal;\n    int objIdx;\n};\n\n/*\nConstants.\n*/\n\n// Constants\n#define R iResolution\n#define EPS 1e-5\n\n// Camera/rendering\n#define NBOUNCES 4\n#define FOCAL_LEN .7\n#define MAX_DIST 50.\n#define EYE vec3(0., 0., 1.9)\n\n// Scene\n#define SPHERE_RAD .75\n#define PLN_D 2.\nvec3[6] colors = vec3[](\n    vec3(.7, .2, .2),\n    vec3(.4, .7, .2),\n    vec3(.2, .2, .7),\n    vec3(.7, .7, .2),\n    vec3(.5, .4, .9),\n    vec3(1., .4, .1));\n\n/*\nRay-object intersectors.\n*/\n\n// Ray-sphere intersector\nHit hitSphere(vec3 ro, vec3 rd, float tMax) {\n    Hit hit;\n    hit.hit = false;\n    \n    // Compute coeffs and discriminant\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - SPHERE_RAD * SPHERE_RAD;\n    \n    float D = b * b - a * c;\n    if (D < 0.) return hit;\n    \n    // Solve and test solution\n    D = sqrt(D);\n    float t = min(-b - D, D - b) / a;\n    \n    if (t < 0. || t > tMax) return hit;\n    \n    // Compute hit point and normal\n    vec3 pt = ro + t * rd;\n    vec3 nrm = pt / SPHERE_RAD;\n    return Hit(true, t, pt, nrm, 0);\n}\n\n// Ray-plane intersector\nHit hitPlane(vec3 ro, vec3 rd, vec3 n, float h, int objIdx, float tMax) {\n    Hit hit;\n    hit.hit = false;\n    \n    // Test for solution\n    float den = dot(rd, n);\n    if (abs(den) < EPS) return hit;\n    \n    // Solve and test solution\n    float t = (h - dot(ro, n)) / den;\n    if (t < 0. || t > tMax) return hit;\n    \n    // Compute hit point and normal\n    vec3 pt = ro + t * rd;\n    vec3 nrm = n * -sign(dot(rd, n));\n    return Hit(true, t, pt, nrm, objIdx);\n}\n\n/*\nRay-scene intersector.\n*/\n\nHit hitScene(vec3 ro, vec3 rd) {\n    // Sphere\n    float tMax = MAX_DIST;\n    Hit hit, tmpHit = hitSphere(ro, rd, tMax);\n    hit.hit = false;\n    \n    if (tmpHit.hit) {\n        hit = tmpHit;\n        tMax = hit.t;\n    }\n    \n    // Planes\n    tmpHit = hitPlane(ro, rd, vec3(1., 0., 0.), PLN_D, 1, tMax);\n    if (tmpHit.hit) {\n        hit = tmpHit;\n        tMax = hit.t;\n    }\n    \n    tmpHit = hitPlane(ro, rd, vec3(0., 1., 0.), PLN_D, 2, tMax);\n    if (tmpHit.hit) {\n        hit = tmpHit;\n        tMax = hit.t;\n    }\n    \n    tmpHit = hitPlane(ro, rd, vec3(0., 0., 1.), PLN_D, 3, tMax);\n    if (tmpHit.hit) {\n        hit = tmpHit;\n        tMax = hit.t;\n    }\n    \n    tmpHit = hitPlane(ro, rd, vec3(1., 0., 0.), -PLN_D, 4, tMax);\n    if (tmpHit.hit) {\n        hit = tmpHit;\n        tMax = hit.t;\n    }\n    \n    tmpHit = hitPlane(ro, rd, vec3(0., 1., 0.), -PLN_D, 5, tMax);\n    if (tmpHit.hit) {\n        hit = tmpHit;\n        tMax = hit.t;\n    }\n    \n    tmpHit = hitPlane(ro, rd, vec3(0., 0., 1.), -PLN_D, 6, tMax);\n    if (tmpHit.hit)\n        hit = tmpHit;\n        \n    return hit;\n}\n\n/*\nColoring.\n*/\n\n\n// Gets a ray from a given point in screenspace.\nvec3 getRay(vec2 p) {\n    vec2 xy = (p - .5 * R.xy) / R.y;\n    return normalize(vec3(xy, -FOCAL_LEN));\n}\n\n// Computes the reflected ray direction.\nvoid computeNewDir(Hit hit, out vec3 ro, inout vec3 rd) {\n    vec3 N = hit.normal;\n    ro = hit.pt + EPS * N;\n    rd = reflect(rd, N);\n}\n\n// Gets the color at a given ray.\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    Hit hit;\n    for (int i = 0; i < NBOUNCES; i ++) {\n        hit = hitScene(ro, rd);\n        if (hit.objIdx == 0) {\n            // We've hit the sphere, bounce and trace again\n            computeNewDir(hit, ro, rd);\n            hit = hitScene(ro, rd);\n        }\n        \n        computeNewDir(hit, ro, rd);\n    }\n    return colors[hit.objIdx - 1];\n}\n\n/*\nMain function.\n*/\n\nvoid mainImage(out vec4 k, vec2 p) {\n    vec3 rd = getRay(p);\n    \n    vec3 col = getColor(EYE, rd);\n    k = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}