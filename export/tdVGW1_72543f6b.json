{"ver":"0.1","info":{"id":"tdVGW1","date":"1570138389","viewed":1681,"name":"led area light matrix","username":"Carandiru","description":"A simulated led matrix of area lights animated by animated blue noise derived variant I call tullynoise\noriginal shader/source code by yx: https://www.shadertoy.com/view/lsyyzc\n\nwhat do your eyes see?\n\n","likes":72,"published":1,"flags":32,"usePreview":0,"tags":["light","area","analytical","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// carandiru 2019\n// supersinfulsilicon.com\n// original shader/source by yx: https://www.shadertoy.com/view/lsyyzc\n// A simulated led matrix of area lights animated by \n// animated blue noise derived variant I call tullynoise\n//\n// what do your eyes see?\n//\n//\nconst float PANEL_SZ = 2.0f; // watch-out!\nconst float COL = 16.0f * PANEL_SZ;\nconst float HCOL = COL * 0.5f;\nconst int   ICOL = int(COL);\nconst float ROW = 9.0f * PANEL_SZ;\nconst int\tIROW = int(ROW);\nconst float LED_SZ = 0.09f; // ok\nconst float LED_SPRITE = 0.666f; // ok\nconst vec3 LUMA = vec3(0.2126f, 0.7152f, 0.0722f);\n#define SEED (slow_time * GOLDEN_RATIO * 10.0f)\n\n\n// iq goodness\nvec2 rndC(in vec2 pixel) // good function, works with any texture sampling that uses interpolation\n{\n    pixel = pixel + 0.5f;\n    vec2 ipixel = floor( pixel );\n    vec2 fpixel = fract( pixel );\n    \n\tpixel = ipixel + fpixel*fpixel*(3.0f-2.0f*fpixel); \n \n\treturn(pixel - 0.5f);  // returns in same unit as input, pixels\n}\n\nfloat tullynoise(in vec2 uv)\n{\n\tvec2 pixel = uv * iChannelResolution[1].xy;\n    return( texture(iChannel1, rndC(pixel) / iChannelResolution[1].xy).r );\n}\n\nvec2 rotate(vec2 a,float b) {\n    return vec2(a.x*cos(b)-a.y*sin(b),a.x*sin(b)+a.y*cos(b));\n}\n\nvec4 light(int index, in float luma){\n\tfloat x = mod(float(index),COL)-(HCOL);\n\tfloat y = floor(float(index)/COL);\n    x*=LED_SZ * 2.0f;;\n    y*=LED_SZ * 2.0f;\n    y+=LED_SZ;\n    \n    float led = 2.0f * tullynoise(vec2(x + SEED,y) / vec2(COL,ROW)) * (LED_SZ + luma * LED_SZ);\n    \n    return vec4(x-led,x+led,y+led,y-led);\n}\nvec4 light(int index, in float luma, out float led, out vec4 ledll){\n\tfloat x = mod(float(index),COL)-(HCOL);\n\tfloat y = floor(float(index)/COL);\n    x*=LED_SZ * 2.0f;\n    y*=LED_SZ * 2.0f;\n    y+=LED_SZ;\n    \n    led = tullynoise(vec2(x + SEED,y) / vec2(COL,ROW)) * (LED_SZ + luma * LED_SZ);\n    float sprite = led * LED_SPRITE;\n    ledll = vec4(x-sprite,x+sprite,y+sprite,y-sprite);\n    \n    return vec4(x-LED_SZ,x+LED_SZ,y+LED_SZ,y-LED_SZ);\n}\nvec3 lum(int index, out float luma){\n\tfloat x = mod(float(index),COL)-(HCOL);\n\tfloat y = floor(float(index)/COL);\n    \n    vec2 uv = vec2(x + iTime * 0.5f,y);\n     \n    vec3 rgb = texture(iChannel0,uv*0.125f).rgb;\n        \n    rgb /= max(rgb.x,max(rgb.y,rgb.z));\n    rgb.x=pow(rgb.x,3.3f);\n    rgb.y=pow(rgb.y,3.3f);\n    rgb.z=pow(rgb.z,3.3f);\n    \n    luma = dot(rgb, LUMA);\n    \n    return rgb * pow(tullynoise(vec2(x + SEED,y) / vec2(COL,ROW)) * 1.5f, 2.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float pi=acos(-1.);\n    vec2 uv=fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float time=iTime*.1;\n    vec3 cam=vec3(sin(time)*4.,1,-5);\n    vec3 dir=normalize(vec3(uv,1));\n    dir.xz=rotate(dir.xz,sin(time)*.6);\n    \n    float tw=-cam.z/dir.z;\n    float tf=-cam.y/dir.y;\n\tconst float PI = acos(-1.);\n    \n    vec3 color=vec3(0);\n    if(tf<tw&&tf>.0)\n    {\n    \tvec3 hit=cam+dir*tf;\n        for(int i=0;i<ICOL;++i)\n        {\n            float luma;\n            vec3 col1 = lum(i, luma);\n            vec4 l1 = light(i, luma);\n            \n        \tvec4 i1 = atan(hit.zzzz,vec4(hit.xxyy-l1.xyzw));\n        \tfloat w1 = max(0.,((i1.x-i1.y)*(i1.w-i1.z)));\n\t\t\tcolor += w1*col1;\n        }\n\t\tcolor /= PI*PI*.5;\n    }\n    else\n    {\n\t\tvec3 hit=cam+dir*tw;\n        for(int i=0;i<(ICOL*IROW);++i){\n            float led;\n            vec4 ledll;\n            \n            float luma;\n            vec3 col1=lum(i, luma);\n            vec4 l1 = light(i, luma, led, ledll);\n            \n            \n            vec2 mid=(l1.xz+l1.yw)*.5;\n            vec2 rad=(l1.yz-l1.xw)*.5;\n            vec2 a=(rad-abs(hit.xy-mid))*iResolution.y*.25+.5;\n            \n            vec2 midled=(ledll.xz+ledll.yw)*.5;\n            vec2 radled=(ledll.yz-ledll.xw)*.5;\n            vec2 aled=(radled-abs(hit.xy-midled))*iResolution.y*.25+.5;\n            \n            float ledmin = clamp(min(aled.x,aled.y),0.,1.);\n            float ledmax = clamp(min(a.x,a.y),0.,1.);\n           \n            float scalar = mix(ledmin, ledmax, smoothstep(0.0f, 1.0f, (ledmax-ledmin) * 0.5f) );\n            float pressure = pow((ledmax * (1.0f - length(hit.xy-midled))), 9.0f) * ledmin;\n            color += (pressure + scalar * pressure) * col1;\n        }\n    }\n    \n    // add some regular blue noise to hide the banding\n    fragColor = vec4(color,1) + texelFetch(iChannel2,ivec2(fragCoord)&1023, 0) * (17.0f/255.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// carandiru 2019 - creative commons Attribution 4.0 International (CC BY 4.0)\n// supersinfulsilicon.com\n\nconst int BNOISE_SZ = 1024;\nconst int BNOISE_MOD = int(BNOISE_SZ) - 1;\nconst float GOLDEN_RATIO = 1.6180339887498948f;\n\n\n#define slow_time (iTime * 0.001f)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// carandiru 2019 - creative commons Attribution 4.0 International (CC BY 4.0)\n// tullynoise\n// supersinfulsilicon.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bnoise0 = 0.0f, bnoise1 = 0.0f;\n    \n    const int iterations = int(sqrt(float(BNOISE_SZ)));\n    \n    for ( int perm = 0 ; perm < iterations ; ++perm ) {\n        \n        float sampling = texelFetch(iChannel0, (ivec2(fragCoord.xy) & BNOISE_MOD), 0).r;\n        \n        // horizontal\n    \tbnoise0 += fract( sampling\n                  + slow_time + GOLDEN_RATIO * float(int(fragCoord.x) & (BNOISE_SZ * BNOISE_SZ - 1)));\n        \n        // vertical\n        bnoise1 += fract( sampling \n                  + slow_time + GOLDEN_RATIO * float(int(fragCoord.y) & (BNOISE_SZ * BNOISE_SZ - 1)));\n    \n    \t\n        // diagonal - can be omitted (quality changes)\n        float bnoise = fract( sampling \n                  + slow_time + GOLDEN_RATIO * float(int(fragCoord.x*fragCoord.y) & (BNOISE_SZ * BNOISE_SZ - 1)));\n        \n        if (bool(perm & 1)) {\n            bnoise1 += bnoise;\n        }\n        else {\n            bnoise0 += bnoise;\n        }\n    }\n    \n    \n    fragColor = vec4(vec3(bnoise0 * bnoise1), 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// carandiru 2019 - creative commons Attribution 4.0 International (CC BY 4.0)\n// tullynoise\n// supersinfulsilicon.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frame = texelFetch(iChannel0, ivec2(fragCoord.xy) & (BNOISE_SZ * BNOISE_SZ - 1), 0).r;\n\n    float nnoise = texelFetch(iChannel0, ivec2(frame / iChannelResolution[0].xy), 0).r;\n\t\n    float noise = fract(nnoise + GOLDEN_RATIO * float( int(fragCoord.x*fragCoord.y) & (BNOISE_SZ * BNOISE_SZ - 1)));\n     \n    // Output to screen\n    fragColor = vec4(vec3(noise),1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}