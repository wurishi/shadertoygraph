{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// This shadertoy implements the four interpolation methods from \"Local divergence-free\n// polynomial interpolation on MAC grids\" by Schroeder, Chowdhury, and Shinar. They are\n// not particularly optimized. Uncomment DIV_DEBUG to verify correctness by ploting the\n// numerically computed divergence. Uncomment FIELD_DEBUG to plot isolevels of the\n// interpolated velocity components.\n//\n// The checkerboard is not actually advected but is plotted by starting at a given point\n// and integrating backward in time, then carrying value of the checkerboard back to the\n// initial point.\n//\n// For context, see: https://bsky.app/profile/vassvik.bsky.social/post/3lcthtwil2t2w\n#define CHECKERBOARD\n#define GRID\n#define VECTORS\n#define DIV_DEBUG\n#define FIELD_DEBUG\n\n// Select a scheme\n// 0: Linear interpolation\n// 1: C0  (C0 continuity, non-interpolating)\n// 2: C0i (C0 continuity, interpolating)\n// 3: C1  (C1 continuity, non-interpolating)\n// 4: C1i (C1 continuity, interpolating)\n#define SCHEME 3\n\nconst float V_SCALE = 1.0;\nconst float VECTOR_SCALE = 0.2;\nconst int INTEGRATION_STEPS = 4;\nconst float VIEW_RADIUS = 2.5;\n\n// A silly, awful field I hard-coded that's discretely divergence-free near the origin\n// Accepts integer coordinates which are offset by a half-cell in the x-direction.\nfloat fu_impl (ivec2 ij, float t) {\n    //return sin(float(ij.x) + 2.0) * sin(float(ij.y) + 4.0);\n    if (ij.y == 0) {\n        if (ij.x == 0) return 4.0;\n        if (abs(ij.x) == 1) return 2.0;\n        if (abs(ij.x) == 3) return 2.0;\n        if (abs(ij.x) == 4) return 1.0;\n        return 0.0;\n    } else if (abs(ij.y) == 1) {\n        if (ij.x == 0) return -2.0;\n        if (abs(ij.x) == 1) return -1.0;\n        if (abs(ij.x) == 3) return -1.0;\n        return 0.0;\n    } else if (abs(ij.y) == 2) {\n        if (ij.x == 0) return 2.0;\n        if (abs(ij.x) == 1) return 1.0;\n        if (abs(ij.x) == 2) return 0.5;\n        if (abs(ij.x) == 4) return -0.5;\n        return 0.0;\n    }\n    return 0.0;\n}\n\nfloat fv_impl (ivec2 ij, float t) {\n    //return cos(float(ij.x) + 2.0) * cos(float(ij.y) + 4.0);\n    if (ij.x == 0 && ij.y == -2) return -1.0;\n    if (ij.x == -1 && ij.y == -2) return 1.0;    \n    if (ij.x == 0 && ij.y == 3) return 1.0;\n    if (ij.x == -1 && ij.y == 3) return -1.0;\n    if (ij.y == -2 && (ij.x == -3 || ij.x == -2)) return 0.5;\n    if (ij.y == -2 && (ij.x == 1 || ij.x == 2)) return -0.5;\n    if (ij.y == 3 && (ij.x == -3 || ij.x == -2)) return -0.5;\n    if (ij.y == 3 && (ij.x == 1 || ij.x == 2)) return 0.5;\n    if (ij.x == 0 || ij.x == 1) {\n        if (ij.y == 1) return 1.0;\n        if (ij.y == 0) return -1.0;\n    } else if (ij.x == -2 || ij.x == -1) {\n        if (ij.y == 1) return -1.0;\n        if (ij.y == 0) return 1.0;\n    } else if (ij.x == -3) {\n        if (ij.y == 1) return 1.0;\n        if (ij.y == 0) return -1.0;\n    } else if (ij.x == 2) {\n        if (ij.y == 1) return -1.0;\n        if (ij.y == 0) return 1.0;\n    } else if (ij.x == -4 || ij.x == 3) {\n        if (ij.y == 0 || ij.y == 1 || ij.y == -1 || ij.y == 2) return (ij.y % 2 == 0 ? -0.5 : 0.5) * float(sign(ij.x));\n    }\n    return 0.0;\n}\n\n// Oscillate in time so there's something pretty to look at\nfloat fu (ivec2 ij, float t) { return fu_impl(ij, t) * cos(iTime); }\nfloat fv (ivec2 ij, float t) { return fv_impl(ij, t) * cos(iTime); }\n\nfloat fu_interp (vec2 xy, float t) {\n#if (SCHEME == 0)\n    ivec2 ij = ivec2(floor(xy + vec2(0.5, 0)));\n    vec2 s = fract(xy + vec2(0.5, 0));\n    float u00 = fu(ij + ivec2(0, 0), t);\n    float u10 = fu(ij + ivec2(1, 0), t);\n    float u01 = fu(ij + ivec2(0, 1), t);\n    float u11 = fu(ij + ivec2(1, 1), t);\n    return mix(mix(u00, u10, s.x), mix(u01, u11, s.x), s.y);\n#elif (SCHEME == 1)\n    ivec2 ij = ivec2(floor(xy));\n    vec2 s = fract(xy);\n    float u00 = fu(ij + ivec2(0, 0), t);\n    float u10 = fu(ij + ivec2(1, 0), t);\n    float u20 = fu(ij + ivec2(2, 0), t);\n    float u01 = fu(ij + ivec2(0, 1), t);\n    float u11 = fu(ij + ivec2(1, 1), t);\n    float u21 = fu(ij + ivec2(2, 1), t);\n    float b0 = B2_0(s.x), b1 = B2_1(s.x), b2 = B2_2(s.x);\n    return (u00 * b0 + u10 * b1 + u20 * b2) * B1_0(s.y) +\n           (u01 * b0 + u11 * b1 + u21 * b2) * B1_1(s.y);\n#elif (SCHEME == 2)\n    ivec2 ij = ivec2(floor(xy));\n    vec2 s = fract(xy);\n    float u00 = fu(ij + ivec2(0, 0), t);\n    float u10 = fu(ij + ivec2(1, 0), t);\n    float u20 = fu(ij + ivec2(2, 0), t);\n    float u01 = fu(ij + ivec2(0, 1), t);\n    float u11 = fu(ij + ivec2(1, 1), t);\n    float u21 = fu(ij + ivec2(2, 1), t);\n    \n    float b0 = B2_0(s.x), b1 = B2_1(s.x), b2 = B2_2(s.x);\n    float c0 = C3_0(s.x), c1 = C3_1(s.x), c2 = C3_2(s.x);\n    float d0 = D4_0(s.x), d1 = D4_1(s.x), d2 = D4_2(s.x);\n    \n    return (u00 * b0 + u10 * b1 + u20 * b2) * B1_0(s.y) +\n           (u01 * b0 + u11 * b1 + u21 * b2) * B1_1(s.y) -\n           4.0 * (\n               (u00 * c0 + u10 * c1 + u20 * c2) * D3_0(s.y) +\n               (u01 * c0 + u11 * c1 + u21 * c2) * D3_1(s.y) +\n               (u00 * d0 + u10 * d1 + u20 * d2) * C2_0(s.y) +\n               (u01 * d0 + u11 * d1 + u21 * d2) * C2_1(s.y)\n               \n           );\n#elif (SCHEME == 3)\n    ivec2 ij = ivec2(floor(xy + 0.5));\n    vec2 s = fract(xy + 0.5);\n    float u00 = fu(ij + ivec2(-1, -1), t);\n    float u10 = fu(ij + ivec2( 0, -1), t);\n    float u20 = fu(ij + ivec2( 1, -1), t);\n    float u30 = fu(ij + ivec2( 2, -1), t);\n\n    float u01 = fu(ij + ivec2(-1, 0), t);\n    float u11 = fu(ij + ivec2( 0, 0), t);\n    float u21 = fu(ij + ivec2( 1, 0), t);\n    float u31 = fu(ij + ivec2( 2, 0), t);\n\n    float u02 = fu(ij + ivec2(-1, 1), t);\n    float u12 = fu(ij + ivec2( 0, 1), t);\n    float u22 = fu(ij + ivec2( 1, 1), t);\n    float u32 = fu(ij + ivec2( 2, 1), t);\n    \n    float b0 = B3_0(s.x), b1 = B3_1(s.x), b2 = B3_2(s.x), b3 = B3_3(s.x);\n    \n    return (u00 * b0 + u10 * b1 + u20 * b2 + u30 * b3) * B2_0(s.y) +\n           (u01 * b0 + u11 * b1 + u21 * b2 + u31 * b3) * B2_1(s.y) +\n           (u02 * b0 + u12 * b1 + u22 * b2 + u32 * b3) * B2_2(s.y);\n#elif (SCHEME == 4)\n    ivec2 ij = ivec2(floor(xy + 0.5));\n    vec2 s = fract(xy + 0.5);\n    float u00 = fu(ij + ivec2(-1, -1), t);\n    float u10 = fu(ij + ivec2( 0, -1), t);\n    float u20 = fu(ij + ivec2( 1, -1), t);\n    float u30 = fu(ij + ivec2( 2, -1), t);\n\n    float u01 = fu(ij + ivec2(-1, 0), t);\n    float u11 = fu(ij + ivec2( 0, 0), t);\n    float u21 = fu(ij + ivec2( 1, 0), t);\n    float u31 = fu(ij + ivec2( 2, 0), t);\n\n    float u02 = fu(ij + ivec2(-1, 1), t);\n    float u12 = fu(ij + ivec2( 0, 1), t);\n    float u22 = fu(ij + ivec2( 1, 1), t);\n    float u32 = fu(ij + ivec2( 2, 1), t);\n    \n    float b0 = B3_0(s.x), b1 = B3_1(s.x), b2 = B3_2(s.x), b3 = B3_3(s.x);\n    float f0 = F5_0(s.x), f1 = F5_1(s.x), f2 = F5_2(s.x), f3 = F5_3(s.x);\n    float c0 = C4_0(s.x), c1 = C4_1(s.x), c2 = C4_2(s.x), c3 = C4_3(s.x);\n    float d0 = D5_0(s.x), d1 = D5_1(s.x), d2 = D5_2(s.x), d3 = D5_3(s.x);\n    \n    return (u00 * b0 + u10 * b1 + u20 * b2 + u30 * b3) * B2_0(s.y) +\n           (u01 * b0 + u11 * b1 + u21 * b2 + u31 * b3) * B2_1(s.y) +\n           (u02 * b0 + u12 * b1 + u22 * b2 + u32 * b3) * B2_2(s.y) +\n           (8.0 / 35.0) * (\n               (u00 * f0 + u10 * f1 + u20 * f2 + u30 * f3) * C3_0(s.y) +\n               (u01 * f0 + u11 * f1 + u21 * f2 + u31 * f3) * C3_1(s.y) +\n               (u02 * f0 + u12 * f1 + u22 * f2 + u32 * f3) * C3_2(s.y) +\n               (u00 * c0 + u10 * c1 + u20 * c2 + u30 * c3) * F4_0(s.y) +\n               (u01 * c0 + u11 * c1 + u21 * c2 + u31 * c3) * F4_1(s.y) +\n               (u02 * c0 + u12 * c1 + u22 * c2 + u32 * c3) * F4_2(s.y)\n           ) -\n           4.0 * (\n               (u00 * d0 + u10 * d1 + u20 * d2 + u30 * d3) * B2_0(s.y) +\n               (u01 * d0 + u11 * d1 + u21 * d2 + u31 * d3) * B2_1(s.y) +\n               (u02 * d0 + u12 * d1 + u22 * d2 + u32 * d3) * B2_2(s.y) +\n               (u00 * b0 + u10 * b1 + u20 * b2 + u30 * b3) * D4_0(s.y) +\n               (u01 * b0 + u11 * b1 + u21 * b2 + u31 * b3) * D4_1(s.y) +\n               (u02 * b0 + u12 * b1 + u22 * b2 + u32 * b3) * D4_2(s.y)\n           );\n\n#endif\n}\n\nfloat fv_interp (vec2 xy, float t) {\n#if (SCHEME == 0)\n    ivec2 ij = ivec2(floor(xy + vec2(0, 0.5)));\n    vec2 s = fract(xy + vec2(0, 0.5));\n    float u00 = fv(ij + ivec2(0, 0), t);\n    float u10 = fv(ij + ivec2(1, 0), t);\n    float u01 = fv(ij + ivec2(0, 1), t);\n    float u11 = fv(ij + ivec2(1, 1), t);\n    return mix(mix(u00, u10, s.x), mix(u01, u11, s.x), s.y);\n#elif (SCHEME == 1)\n    ivec2 ij = ivec2(floor(xy));\n    vec2 s = fract(xy);\n    float v00 = fv(ij + ivec2(0, 0), t);\n    float v01 = fv(ij + ivec2(0, 1), t);\n    float v02 = fv(ij + ivec2(0, 2), t);\n    float v10 = fv(ij + ivec2(1, 0), t);\n    float v11 = fv(ij + ivec2(1, 1), t);\n    float v12 = fv(ij + ivec2(1, 2), t);\n    float b0 = B2_0(s.y), b1 = B2_1(s.y), b2 = B2_2(s.y);\n    return (v00 * b0 + v01 * b1 + v02 * b2) * B1_0(s.x) +\n           (v10 * b0 + v11 * b1 + v12 * b2) * B1_1(s.x);\n#elif (SCHEME == 2)\n    ivec2 ij = ivec2(floor(xy));\n    vec2 s = fract(xy);\n    float v00 = fv(ij + ivec2(0, 0), t);\n    float v01 = fv(ij + ivec2(0, 1), t);\n    float v02 = fv(ij + ivec2(0, 2), t);\n    float v10 = fv(ij + ivec2(1, 0), t);\n    float v11 = fv(ij + ivec2(1, 1), t);\n    float v12 = fv(ij + ivec2(1, 2), t);\n    \n    float b0 = B2_0(s.y), b1 = B2_1(s.y), b2 = B2_2(s.y);\n    float c0 = C3_0(s.y), c1 = C3_1(s.y), c2 = C3_2(s.y);\n    float d0 = D4_0(s.y), d1 = D4_1(s.y), d2 = D4_2(s.y);\n    \n    return (v00 * b0 + v01 * b1 + v02 * b2) * B1_0(s.x) +\n           (v10 * b0 + v11 * b1 + v12 * b2) * B1_1(s.x) -\n           4.0 * (\n               (v00 * c0 + v01 * c1 + v02 * c2) * D3_0(s.x) +\n               (v10 * c0 + v11 * c1 + v12 * c2) * D3_1(s.x) +\n               (v00 * d0 + v01 * d1 + v02 * d2) * C2_0(s.x) +\n               (v10 * d0 + v11 * d1 + v12 * d2) * C2_1(s.x)\n               \n           );\n#elif (SCHEME == 3)\n    ivec2 ij = ivec2(floor(xy + 0.5));\n    vec2 s = fract(xy + 0.5);\n    float v00 = fv(ij + ivec2(-1, -1), t);\n    float v01 = fv(ij + ivec2(-1,  0), t);\n    float v02 = fv(ij + ivec2(-1,  1), t);\n    float v03 = fv(ij + ivec2(-1,  2), t);\n\n    float v10 = fv(ij + ivec2(0, -1), t);\n    float v11 = fv(ij + ivec2(0,  0), t);\n    float v12 = fv(ij + ivec2(0,  1), t);\n    float v13 = fv(ij + ivec2(0,  2), t);\n\n    float v20 = fv(ij + ivec2(1, -1), t);\n    float v21 = fv(ij + ivec2(1,  0), t);\n    float v22 = fv(ij + ivec2(1,  1), t);\n    float v23 = fv(ij + ivec2(1,  2), t);\n    \n    float b0 = B3_0(s.y), b1 = B3_1(s.y), b2 = B3_2(s.y), b3 = B3_3(s.y);\n    \n    return (v00 * b0 + v01 * b1 + v02 * b2 + v03 * b3) * B2_0(s.x) +\n           (v10 * b0 + v11 * b1 + v12 * b2 + v13 * b3) * B2_1(s.x) +\n           (v20 * b0 + v21 * b1 + v22 * b2 + v23 * b3) * B2_2(s.x);\n#elif (SCHEME == 4)\n    ivec2 ij = ivec2(floor(xy + 0.5));\n    vec2 s = fract(xy + 0.5);\n    float v00 = fv(ij + ivec2(-1, -1), t);\n    float v01 = fv(ij + ivec2(-1,  0), t);\n    float v02 = fv(ij + ivec2(-1,  1), t);\n    float v03 = fv(ij + ivec2(-1,  2), t);\n\n    float v10 = fv(ij + ivec2(0, -1), t);\n    float v11 = fv(ij + ivec2(0,  0), t);\n    float v12 = fv(ij + ivec2(0,  1), t);\n    float v13 = fv(ij + ivec2(0,  2), t);\n\n    float v20 = fv(ij + ivec2(1, -1), t);\n    float v21 = fv(ij + ivec2(1,  0), t);\n    float v22 = fv(ij + ivec2(1,  1), t);\n    float v23 = fv(ij + ivec2(1,  2), t);\n    \n    float b0 = B3_0(s.y), b1 = B3_1(s.y), b2 = B3_2(s.y), b3 = B3_3(s.y);\n    float f0 = F5_0(s.y), f1 = F5_1(s.y), f2 = F5_2(s.y), f3 = F5_3(s.y);\n    float c0 = C4_0(s.y), c1 = C4_1(s.y), c2 = C4_2(s.y), c3 = C4_3(s.y);\n    float d0 = D5_0(s.y), d1 = D5_1(s.y), d2 = D5_2(s.y), d3 = D5_3(s.y);\n    \n    return (v00 * b0 + v01 * b1 + v02 * b2 + v03 * b3) * B2_0(s.x) +\n           (v10 * b0 + v11 * b1 + v12 * b2 + v13 * b3) * B2_1(s.x) +\n           (v20 * b0 + v21 * b1 + v22 * b2 + v23 * b3) * B2_2(s.x) +\n           (8.0 / 35.0) * (\n               (v00 * f0 + v01 * f1 + v02 * f2 + v03 * f3) * C3_0(s.x) +\n               (v10 * f0 + v11 * f1 + v12 * f2 + v13 * f3) * C3_1(s.x) +\n               (v20 * f0 + v21 * f1 + v22 * f2 + v23 * f3) * C3_2(s.x) +\n               (v00 * c0 + v01 * c1 + v02 * c2 + v03 * c3) * F4_0(s.x) +\n               (v10 * c0 + v11 * c1 + v12 * c2 + v13 * c3) * F4_1(s.x) +\n               (v20 * c0 + v21 * c1 + v22 * c2 + v23 * c3) * F4_2(s.x)\n           ) -\n           4.0 * (\n               (v00 * d0 + v01 * d1 + v02 * d2 + v03 * d3) * B2_0(s.x) +\n               (v10 * d0 + v11 * d1 + v12 * d2 + v13 * d3) * B2_1(s.x) +\n               (v20 * d0 + v21 * d1 + v22 * d2 + v23 * d3) * B2_2(s.x) +\n               (v00 * b0 + v01 * b1 + v02 * b2 + v03 * b3) * D4_0(s.x) +\n               (v10 * b0 + v11 * b1 + v12 * b2 + v13 * b3) * D4_1(s.x) +\n               (v20 * b0 + v21 * b1 + v22 * b2 + v23 * b3) * D4_2(s.x)\n           );\n#endif\n}\n\nvec2 uv_interp (vec2 xy, float t) {\n     return vec2(fu_interp(xy, t), fv_interp(xy, t));\n}\n\n// Sample the checkerboard at a point integrated backwards with respect to velocity\n// so that it creates the appearance of advection\nvec2 derivative(vec2 xy, float t) {\n    return -uv_interp(xy, t);\n}\n\nvec2 rk4(vec2 y, float t, float dt) {\n    vec2 k1 = derivative(y, t);\n    vec2 k2 = derivative(y + 0.5 * dt * k1, t + 0.5 * dt);\n    vec2 k3 = derivative(y + 0.5 * dt * k2, t + 0.5 * dt);\n    vec2 k4 = derivative(y + dt * k3, t + dt);\n    return y + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0, 0, 0, 1);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n\n    mat3 view = ortho2Dinverse(-aspect * VIEW_RADIUS - 0.5, aspect * VIEW_RADIUS - 0.5, -VIEW_RADIUS, VIEW_RADIUS);\n    vec2 xy = (view * vec3(uv, 1)).xy;\n    \n    float pixel = VIEW_RADIUS * 2.0 / iResolution.y;\n    \n    // Integrate\n    vec2 p = xy;\n    float t = 0.0;\n    float tmax = 1.0;\n    float dt = tmax / float(INTEGRATION_STEPS) * V_SCALE;\n    for (int i = 0; i < INTEGRATION_STEPS; i++) {\n        p = rk4(p, t, dt);\n        t += dt;\n    }\n\n\n#ifdef CHECKERBOARD\n    vec2 c = (p - 0.5) * 6.0;\n    onTop(fragColor, vec4(mix(vec3(0.15), vec3(0.25), checkersTextureGradBox(c, dFdx(c), dFdy(c))), 1));\n#endif\n\n#ifdef GRID\n    onTop(fragColor, mix(vec4(0), vec4(vec3(1), 0.2), grid(xy - 0.5, 1.0, 1.0)));\n#endif\n    \n    const vec2 ARROW_SC = vec2(sin(PI / 3.0), cos(PI / 3.0));\n    float ARROW_HLEN = 10.0 * pixel;\n    float RADIUS = 3.0 * pixel;\n    float BORDER_WIDTH = 1.0;\n    \n\n#ifdef FIELD_DEBUG\n    {\n        const float freq = 2.0;\n        float u = fu_interp(xy, t);\n        float v = fv_interp(xy, t);\n        float opac = 0.5;\n        onTop(fragColor, vec4(1, 0, 0, opac * grid(freq * u, 1.0, 1.0)));\n        onTop(fragColor, vec4(0, 0.5, 0, opac * grid(freq * v, 1.0, 1.0)));\n        //onTop(fragColor, vec4(1, 0, 0, 0.5 * sqrt(sqrt(abs(u))) * fract(4.0 * u)));\n        //onTop(fragColor, vec4(0, 0.5, 0, 0.5 * sqrt(sqrt(abs(v))) * fract(4.0 * v)));\n    }\n#endif\n\n#ifdef DIV_DEBUG\n    {\n        const float eps = 0.001;\n        float dudx = (fu_interp(xy + vec2(eps, 0), t) - fu_interp(xy - vec2(eps, 0), t)) / (2.0 * eps);\n        float dvdy = (fv_interp(xy + vec2(0, eps), t) - fv_interp(xy - vec2(0, eps), t)) / (2.0 * eps);\n        float div = dudx + dvdy;\n        onTop(fragColor, vec4(max(-sign(div), 0.0), 0, max(sign(div), 0.0), 0.5 * (1.0 - exp(-5.0 * abs(div)))));\n    }\n#endif\n    \n    \n#ifdef VECTORS\n    // Increase the radius of this loop if the vectors get too long to fit in a\n    // single cell.\n    for (float ii = -0.0; ii < 0.5; ii++) {\n        for (float jj = -0.0; jj < 0.5; jj++) {\n            // u-velocity vectors\n            {\n                const vec4 FILL = vec4(1, 0, 0, 0.5);\n                const vec4 BORDER = vec4(1, 0.5, 0.5, 1.0);\n                vec2 ij = vec2(floor(xy.x) + 0.5, floor(xy.y + 0.5)) + vec2(ii, jj);\n                float u = fu(ivec2(ij + vec2(0.5, 0)), t);\n                vec2 d = vec2(u, 0) * VECTOR_SCALE * 0.5;\n                onTop(fragColor, sdFill(\n                    sdArrow(xy, ij - d, ij + d, ARROW_HLEN, ARROW_SC) - RADIUS,\n                    FILL, BORDER, BORDER_WIDTH));    \n            }\n\n            // v-velocity vectors\n            {\n                const vec4 FILL = vec4(0, 0.75, 0, 0.5);\n                const vec4 BORDER = vec4(0.5, 1, 0.5, 0.75);\n                vec2 ij = vec2(floor(xy.x + 0.5), floor(xy.y) + 0.5) + vec2(ii, jj);\n                float v = fv(ivec2(ij + vec2(0, 0.5)), t);\n                vec2 d = vec2(0, v) * VECTOR_SCALE;\n                onTop(fragColor, sdFill(\n                    sdArrow(xy, ij - d, ij + d, ARROW_HLEN, ARROW_SC) - RADIUS,\n                    FILL, BORDER, BORDER_WIDTH));    \n            }\n        }\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define PI 3.14159265358979\n#define SQR(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n\nfloat B0_0 (float x) { return 1.0; }\n\nfloat B1_0 (float x) { return 1.0 - x; }\nfloat B1_1 (float x) { return x; }\n\nfloat B2_0 (float x) { return 0.5 * SQR(x - 1.0); }\nfloat B2_1 (float x) { return -x * x + x + 0.5; }\nfloat B2_2 (float x) { return 0.5 * x * x; }\n\nfloat B3_0 (float x) { return (x * ((3.0 - x) * x - 3.0) + 1.0) / 6.0; }\nfloat B3_1 (float x) { return (x * x * (3.0 * x - 6.0) + 4.0) / 6.0; }\nfloat B3_2 (float x) { return (x * ((3.0 - 3.0 * x) * x + 3.0) + 1.0) / 6.0; }\nfloat B3_3 (float x) { return x * x * x / 6.0; }\n\n\nfloat C2_0 (float x) { return (x - 1.0) * (3.0 * x - 1.0); }\nfloat C2_1 (float x) { return x * (3.0 * x - 2.0); }\n\nfloat C3_0 (float x) { return -x * SQR(x - 1.0); }\nfloat C3_1 (float x) { return -x * (x - 1.0); }\nfloat C3_2 (float x) { return x * x * (x - 1.0); }\n\nfloat C4_0 (float x) { return (3.0 * x + 1.0) * CUBE(x - 1.0) / 12.0; }\nfloat C4_1 (float x) { return (x * x * ((12.0 - 3.0 * x) * x - 12.0) + 2.0) / 12.0; }\nfloat C4_2 (float x) { return (x * x * (6.0 - 3.0 * x * x) - 1.0) / 12.0; }\nfloat C4_3 (float x) { return x * x * x * (3.0 * x - 4.0) / 12.0; }\n\n\nfloat D2_0 (float x) { return 6.0 * x * (x - 1.0) + 1.0; }\n\nfloat D3_0 (float x) { return -x * (2.0 * x - 1.0) * (x - 1.0); }\nfloat D3_1 (float x) { return x * (2.0 * x - 1.0) * (x - 1.0); }\n\nfloat D4_0 (float x) { return 0.5 * x * x * SQR(x - 1.0); }\nfloat D4_1 (float x) { return -x * x * SQR(x - 1.0); }\nfloat D4_2 (float x) { return 0.5 * x * x * SQR(x - 1.0); }\n\nfloat D5_0 (float x) { return -(6.0 * x * x + 3.0 * x + 1.0) * CUBE(x - 1.0) / 60.0; }\nfloat D5_1 (float x) { return (x * x * x * ((18.0 * x - 45.0) * x + 30.0) - 2.0) / 60.0; }\nfloat D5_2 (float x) { return (x * x * x * ((45.0 - 18.0 * x) * x - 30.0) + 1.0) / 60.0; }\nfloat D5_3 (float x) { return x * x * x * (6.0 * x * x - 15.0 * x + 10.0) / 60.0; }\n\n\nfloat F4_0 (float x) { return SQR(x - 1.0) * (25.0 * x * x - 4.0 * x - 3.0); }\nfloat F4_1 (float x) { return x * (x * (x * (130.0 * x - 260.0) + 132.0) - 2.0) - 3.0; }\nfloat F4_2 (float x) { return x * x * (25.0 * x * x - 46.0 * x + 18.0); }\n\nfloat F5_0 (float x) { return -0.5 * (2.0 * x + 1.0) * (5.0 * x - 1.0) * CUBE(x - 1.0); }\nfloat F5_1 (float x) { return (x * x * (x * ((103.0 - 42.0 * x) * x - 68.0) + 4.0) + 2.0) / 2.0; }\nfloat F5_2 (float x) { return (x * (x * (x * (x * (42.0 * x - 107.0) + 76.0) - 2.0) - 6.0) - 1.0) / 2.0; }\nfloat F5_3 (float x) { return 0.5 * x * x * x * (5.0 * x - 4.0) * (2.0 * x - 3.0); }\n\n\n// Analytically filtered checkerboard, source: https://iquilezles.org/articles/checkerfiltering/\nfloat checkersTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nfloat outline (float parameter, float width, float feather) {\n  float w1 = width - feather * 0.5;\n  float d = length(vec2(dFdx(parameter), dFdy(parameter)));\n  float fudge = parameter > -0.01 && parameter < 0.01 ? 1.0 : 0.0;\n  return smoothstep(d * (w1 + feather), d * w1, abs(parameter)) * fudge;\n}\n\nfloat grid (float parameter, float width, float feather) {\n  float w1 = width - feather * 0.5;\n  float d = length(vec2(dFdx(parameter), dFdy(parameter)));\n  float looped = 0.5 - abs(mod(parameter, 1.0) - 0.5);\n  return smoothstep(d * (w1 + feather), d * w1, looped);\n}\n\nfloat grid (vec2 parameter, float width, float feather) {\n  float w1 = width - feather * 0.5;\n  vec2 d = vec2(\n      length(vec2(dFdx(parameter.x), dFdy(parameter.x))),\n      length(vec2(dFdx(parameter.y), dFdy(parameter.y)))\n  );  vec2 looped = 0.5 - abs(mod(parameter, 1.0) - 0.5);\n  vec2 a2 = smoothstep(d * (w1 + feather), d * w1, looped);\n  return max(a2.x, a2.y);\n}\n\nmat3 ortho2Dinverse(float l, float r, float b, float t) {\n    return mat3(r - l, 0, 0, 0, t -  b, 0, l, b, 1);\n}\n\nfloat checkerboard(vec2 uv) {\n    bvec2 o = greaterThan(mod(uv, vec2(2)), vec2(1));\n    return float(o.x ^^ o.y);\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArrow(vec2 p, vec2 a, vec2 b, float le, vec2 sc) {\n    vec2 pa = p-a, ba = b-a;\n    float l = length(b - a);\n    le = min(l, le);\n    float h0 = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    vec2 q0 = pa - ba*h0;\n    vec2 d = ba / l;\n    vec2 q = mat2(d.x,-d.y,d.y, d.x) * (b-p);\n    q.y = abs(q.y);\n    float h1 = clamp(dot(le*sc-q, sc)/le, 0., 1.);\n    vec2 q1 = q + sc*le*(h1 - 1.);\n    return sqrt(min(dot(q0,q0), dot(q1,q1)));\n}\nvec4 sdFill (float value, vec4 fillColor, vec4 borderColor, float borderWidth) {\n    return mix(value < 0.0 ? fillColor : vec4(0), borderColor, outline(value, borderWidth, 1.5));\n}\n\nvoid onTop (inout vec4 dst, vec4 src) {\n    dst = mix(dst, src, src.a);\n}\n\n\n\n/*\n// Adaptive RK45\nconst float SAFETY = 0.95;\nconst float MAX_DECREASE = 0.02;\nconst float MAX_INCREASE = 50.0;\nconst float TOLERANCE = 1e-4;\nconst float TOL2 = TOLERANCE * TOLERANCE;\nvec2 rk45 (vec2 y, inout float t, inout float dt) { \n    vec2 k1 = derivative(y);\n    vec2 k2 = derivative(y + dt * 0.2 * k1);\n    vec2 k3 = derivative(y + dt * (0.075 * k1 + 0.225 * k2));\n    vec2 k4 = derivative(y + dt * (0.3 * k1 - 0.9 * k2 + 1.2 * k3));\n    vec2 k5 = derivative(y + dt * (-0.203703703703703703 * k1 + 2.5 * k2 - 2.592592592592592592 * k3 + 1.296296296296296296 * k4));\n    vec2 k6 = derivative(y + dt * (0.029495804398148148 * k1 + 0.341796875 * k2 + 0.041594328703703703 * k3 + 0.400345413773148148 * k4 + 0.061767578125 * k5));\n    vec2 tmp = dt * (0.004293774801587301 * k1 - 0.018668586093857832 * k3 + 0.034155026830808080 * k4 + 0.019321986607142857 * k5 - 0.039102202145680406 * k6);\n    float err2 = dot(tmp, tmp);\n    bool accept = err2 <= TOL2;\n    if (accept) {\n        y += dt * (0.097883597883597883 * k1 + 0.402576489533011272 * k3 + 0.210437710437710437 * k4 + 0.289102202145680406 * k6);\n        t += dt;\n    }\n    dt *= clamp(SAFETY * pow(TOL2 / err2, accept ? 0.125 : 0.1), MAX_DECREASE, MAX_INCREASE);\n    return y;\n}\n*/","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfKBDR","date":"1734416695","viewed":124,"name":"Divergence-free advection test","username":"rreusser","description":"Implements the four 2D divergence-free interpolation methods from \"Local divergence-free polynomial interpolation on MAC grids\" by Schroeder, Chowdhury, and Shinar.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["math","fluid","divergence"],"hasliked":0,"parentid":"","parentname":""}}