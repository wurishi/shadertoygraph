{"ver":"0.1","info":{"id":"lddSDl","date":"1462260087","viewed":160,"name":"Acid fractal stuff","username":"mlavik1","description":"Started out as an implementation of mandelbrot fractals, but ended up as something slightly different","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float minR = -2.0;\nconst float maxR = 1.0;\nconst float minI = -1.0;\nconst float maxI = 1.0;\nconst int maxIterations = 40;\n\nstruct complexNumber\n{\n\tfloat r;\n\tfloat i;\n};\n\t\ncomplexNumber c_add(complexNumber a, complexNumber b)\n{\n\tcomplexNumber ret;\n\tret.r = a.r + b.r;\n\tret.i = a.i + b.i;\n\treturn ret;\n}\n\ncomplexNumber c_subtract(complexNumber a, complexNumber b)\n{\n\tcomplexNumber ret;\n\tret.r = a.r - b.r;\n\tret.i = a.i - b.i;\n\treturn ret;\n}\n\ncomplexNumber c_divide(complexNumber a, float d)\n{\n\tcomplexNumber ret;\n\tret.r = ret.r / d;\n\tret.i = ret.i / d;\n\treturn ret;\n}\n\ncomplexNumber c_pow(complexNumber a, const int p)\n{\n\tcomplexNumber ret = a;\n\tint iCount = 1;\n\tfor(int i = 1; i < 5; i++)\n\t{\n\t\tret.r = ret.r*ret.r - ret.i*ret.i;\n\t\tret.i = 2.0*a.r*a.i;\n\t\tif(++iCount == p)\n\t\t\tbreak;\n\t}\n\t\n\treturn ret;\n}\n\n\n\nfloat c_abs(complexNumber a)\n{\n\tfloat absVal = sqrt(a.r*a.r + a.i*a.i);\n\treturn absVal;\n}\n\ncomplexNumber c_exp(complexNumber a)\n{\n\tcomplexNumber ret =  c_add(complexNumber(1.0,0.0), a); // not really exp, but it looks nice\n\t//ret = c_add(ret, c_divide(c_pow(ret,2), 2.0));\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n\tvec2 pos = ( fragCoord.xy / iResolution.xy );\n\tvec3 col = vec3(0.0,0.0,0.0);\n\n\tcomplexNumber c = complexNumber(0.0,0.0);\t\n\tc.r = minR + (cos(pos.x*16.0)/2.0+1.0)*(maxR-minR);\n\tc.i = minI + (cos(pos.y*16.0)/2.0+1.0)*(maxI-minI);\n\t\n\tcomplexNumber z = c;\n\tint iterations = -1;\n\tfor(int i = 0; i < maxIterations; i++)\n\t{\n\t\tif(c_abs(z) > 50.0)\n\t\t{\n\t\t\titerations = i;\n\t\t\tbreak;\n\t\t}\n\t\tz = c_add(c_exp(c_pow(z,3)), complexNumber(-2.0*sin(time+(pos.x - sin(pos.y)))-2.0, 0.0));\n\t\t\n\t}\n\t\n\tif(iterations >= 0)\n\t{\n\t\tfloat i = float(iterations)/float(maxIterations);\n\t\tcol.r = smoothstep(0.0,0.5+(0.5*sin(time)/2.0), i);\n\t\tcol.g = smoothstep(0.0,1.0,i);\n\t\tcol.b = smoothstep(0.4,1.0, i);\n\t}\n\telse\n\t{\n\t\tcol.g = 0.3*cos(iResolution.x*length(vec2(0.5,0.5) - pos)) * cos(iResolution.x*length(vec2(0.8,0.2) - pos));\n\t\tcol.b = cos(sin(time)*10.0+10.0*length(vec2(0.2,0.6) - pos));\n\t}\n\t\n\tfragColor.rgb = col;\n\tfragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}