{"ver":"0.1","info":{"id":"msKfRd","date":"1698719673","viewed":85,"name":"Binary Stargate","username":"Carandiru","description":"an infinite mirror, with a star approaching","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["tunnel","triangles","oscillation","stairs"],"hasliked":0,"parentid":"XlGSRW","parentname":"Triangle Wobble Stairs"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// an infinite mirror, with a star approaching\n\n\n\n#define TIME_SCALE 0.5\n\n\n\nconst float TWO_PI = 6.28318530718;\nconst int steps = 96;\nconst int stars = 4;\n\nvec2 rotate( in vec2 p, in float angle )\n{\n\t#define fma(a,b,c) (a*b+c)\n    #define c_ x\n\t#define s_ y\n\t\n    vec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n    #undef fma\n}\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n   return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat triangle(vec2 p, float size) {\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + p.y * 0.5, -p.y * 0.5) - size * 0.5;\n}\n\nfloat hexagon(vec2 p, float radius) {\n    vec2 q = abs(p);\n    return max(abs(q.y), q.x * 0.866025 + q.y * 0.5) - radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * TIME_SCALE;\n    time = (33.0f + 1.0f) + time * (time - iTimeDelta * TIME_SCALE);\n\n    vec2 st = fragCoord.xy/iResolution.xy * 2.0f - 1.0f;\n    st.x *= 0.5f * iResolution.x/iResolution.y;\n    \n    float col = 0.; \n    float sizeStart = 1.0f / (1.0f + (time)*(time));\n    float sizeEnd = 0.000000001f; \n    float stepSize = 0.1212121212f * sizeStart / float(steps); \n    \n    vec2 bn = textureLod(iChannel0, (st * iResolution.xy)/1024.0f, 0.0f).rg;\n    vec2 bt = st + (bn * 2.0f - 1.0f) * stepSize * length(st);\n    \n    for(int j = 0; j < stars; j++) {\n        \n        float light = 0.0f;\n        float t = 1.0f;\n        for(int i = 0; i < steps; i++) {\n            float curStepSize = float(i) * stepSize;\n            float stepColor = map(curStepSize, sizeStart, sizeEnd, 1.0, 0.05);\n            vec2 stMoved = sizeStart * vec2(0, 666.36363f * sin((float(i) / float(steps) + (time) / float(j + 1)) * 3.14)); // offset wobble y down the tunnel, 3x faster than main oscillation\n            \n            stMoved += bt + mod(st, bt*(time*3.14) * float(steps) * float(stars)) * 11.0f * ( 1.0f - 1.0f / (time*time + 1.0f) );\n\n            float dt = exp(-1.521212e4f * t * length(stMoved) * curStepSize);\n\n            if(triangle(stMoved, curStepSize) > 0.) {\n                light += stepColor * t;     \n                t *= dt;\n            }\n        }\n        \n        col += (col * float(j+1) * t*0.001019191f*bn.x + 1.0f - exp(-1.909521212e4f * 2.0f * (1.0f - t) * length(bt))) * light / float(stars);\n        col = col * col;\n        \n        bt *= (abs(st) / (1.11111f*(1.0f - t)) * (0.9949494f + t + (bn * 0.5f + 0.5f) * 0.99919191f * 0.0061616f*(1.0f-t)) + bn * stepSize) * sqrt(float(steps) * stepSize * (1.0f - t)) * (1.0f - t);\n    }\n\tfragColor = vec4(vec3(pow(col, 1.0f/2.2f)), 1.0);\n}","name":"Image","description":"","type":"image"}]}