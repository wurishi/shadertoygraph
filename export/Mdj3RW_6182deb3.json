{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Cheng-Tso Lin, https://github.com/otaku690\n// GPU Programming and Architecture Hackathon, University of Pennsylvania\n// http://www.seas.upenn.edu/~cis565/\n\n//This pseudo-rand is from:\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 2d noise function based on 3d noise from \n// https://iquilezles.org/articles/morenoise\nvoid dnoise2f( out vec3 vout, in vec2 pp ) \n{  \n\tvec2 p = pp;\n    float i = floor(p.x), j = floor(p.y);\n    float u = fract(p.x), v = fract(p.y);\n\n    float du = 30.*u*u*(u*(u-2.)+1.);\n    float dv = 30.*v*v*(v*(v-2.)+1.);\n\n    u=u*u*u*(u*(u*6.-15.)+10.);\n    v=v*v*v*(v*(v*6.-15.)+10.);\n \n    float a = rand( vec2( i*2., j*2.) );\n    float b = rand( vec2( i*2.+1.0*2.,j*2.) );\n    float c = rand( vec2( i*2., j*2.+1.0*2.) );\n    float d = rand( vec2(i*2.+1.0*2., j*2.+1.0*2.) );\n\t//float a = texture( iChannel0, vec2(i,j)*8.0 ).r;\n\t//float b = texture( iChannel0, vec2(i+1.0,j)*8.0 ).r;\n\t//float c = texture( iChannel0, vec2(i,j+1.0)*8.0 ).r;\n    //float d  =  texture( iChannel0, vec2(i+1.0,j+1.0)*8.0 ).r;\n\t\t\n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = a-b-c+d;\n\n    vout.x = k0 + k1*u + k2*v + k3*u*v;\n    vout.y = du * (k1 + k3*v);\n    vout.z = dv * (k2 + k3*u);\n\n}\n\nvoid fbm( in float x, in float y, out float f, out float dx, out float dz )\n{\n    f = 0.0;\n    float w = 0.5; \n    dx = 0.0;\n\tdz = 0.0;\n    for( int i=0; i < 5 ; i++ )\n    {\n        vec3 n;\n        dnoise2f( n, vec2(x,y) );\n\t\tdx += n[1];\n        dz += n[2];\n        f += w * n[0]; // replace with \"w * n[0]\" for a classic fbm()\n        w *= 0.5;\n        x *= 2.0;\n        y *= 2.0;\n    }\n}\n\nvoid getNormal( in vec3 pos, out vec3 normal )\n{\n    normal = vec3(0,1,0);\n}\n\nvec3 fogging( in vec3 color, in float distance )\n{\n    float intensity = exp( distance);\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( color, fogColor, intensity );\n}\n\nint castRay(  in vec3  ro, in vec3  rd, in float  resT, out vec3 hitP, out vec3 N )\n{\n    vec3 po = ro;\n    int find = 0;\n    \n    float height, dx, dz, dy, tmpx, tmpz;\n\tvec3 ng1, ng2;\n    for( float t = 0.0; t < 0.05; t += 0.0005 )\n    {\n        po += rd*t;\n            \n         //dnoise2f( noise, q*ctime );\n        fbm( po.x, po.z, height, dx, dz );\n        if( po.y < height )\n        {\n            //resT = t - 0.5*1.0;\n            hitP = po;\n\t\t\thitP.y = height;\n\t\t\t\n\t\t\tfbm( po.x + dx, po.z, height, tmpx, tmpz );\n\t\t\tng1 = vec3( po.x + dx, height, po.z );\n\t\t\tfbm( po.x, po.z+dz, height, tmpx, tmpz );\n\t\t\tng2 = vec3( po.x, height, po.z+dz );\n\t\t\tN = normalize( cross( ng1 - hitP, ng2-hitP ) );\n            find = 1;\n        }\n    }\n\t\n    \n    return find;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    float ctime = iTime;\n\n    //light\n    vec3 light = vec3( 0, 3.0, -2.0 );\n    //camera\n        \n\n    vec3 ro = vec3( 0, 1.4, 4.0-ctime*0.51 );\n    vec3 ta = vec3( 0.0, .0, -ctime*0.51 );\n\n    // camera matrix construct(from https://www.shadertoy.com/view/MsXGWr)\n    vec3 ww = normalize( ta -ro ); //z\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) ); //x\n    vec3 vv = normalize( cross(uu,ww)); //y\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv +2.1*ww );\n\n    vec3 hitP, N;\n    int hit = castRay( ro, rd, 0.1, hitP, N );\n    \n    \n    if( hit == 1 )\n    {\n        fragColor = vec4(N, 1);\n\t    \n        //fragColor = vec4( L, 1 );\n    }\n    else\n\t{\n\t   \n\t\tfragColor = vec4( 0, 0, 1, 1);\n\t}\n    \n    fragColor.xyz = fogging( fragColor.xyz, hitP.z );\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdj3RW","date":"1384664116","viewed":259,"name":"FBMTest","username":"otaku690","description":"This shader intends create procedural terrain using fBM (Fractional Brownian Motion)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrian"],"hasliked":0,"parentid":"","parentname":""}}