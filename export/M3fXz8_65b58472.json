{"ver":"0.1","info":{"id":"M3fXz8","date":"1709131346","viewed":54,"name":"0sharder6","username":"seven_bin","description":"sharder sharder","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sharder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int u_octaves = 2;\n\nconst float seed2 = 73156.8473192;\n// const float seed = 43758.5453123;\n\n\nvec2 random2(vec2 st, float seed){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*seed);\n}\n\nfloat noise(vec2 st, float seed) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0), seed ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0), seed ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0), seed ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0), seed ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm1(in vec2 _st, float seed) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                  -sin(0.5), cos(0.50));\n    for (int i = 0; i < u_octaves; ++i) {\n      v += a * noise(_st, seed);\n      _st = rot * _st * 2.0 + shift;\n      a *= length(iMouse.xyz) * 0.0002;\n    }\n    return v + .4 ;\n}\n\nfloat pattern(vec2 uv, float seed, float time, inout vec2 q, inout vec2 r) {\n\n    q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\n                 fbm1( uv + vec2(5.2,1.3), seed ) );\n\n    r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - time / 2.,9.2), seed ),\n                 fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8), seed ) );\n\n    float rtn = fbm1( uv + 4.0*r, seed );\n\n    return rtn;\n}\n\nfloat bumpMap(vec2 uv, inout vec2 q, inout vec2 r) {\n    mat2 rotation = mat2(\n    cos(iTime / 50.), -sin(iTime / 50.),\n    sin(iTime / 50.), cos(iTime / 50.)\n    );\n\n    /* 密度 \n    uv -= .5;\n    */\n    uv -= .5;\n    uv *= rotation;\n    /* 密度 \n    uv *= 5.;\n    */\n    uv *= 1.5;\n\n    float colour = pattern(uv, seed2, iTime / 3., q, r);\n    colour = smoothstep(0., 1., colour);\n\n    return length(vec2(colour))*.8;\n}\n\nvec4 renderPass(vec2 uv, vec2 uvoffset) {\n    vec3 surfacePos = vec3(uv, 0);\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 lightPos = vec3(0., 0., -3.);\n    vec3 normal = vec3(0., 0., -1);\n\n    vec2 sampleDistance = vec2(1. / iResolution.y, 0.);\n\n    vec2 q = vec2(0.,0.);\n    vec2 r = vec2(0.,0.);\n\n    float fx = bumpMap(surfacePos.xy-sampleDistance.xy + uvoffset, q, r);\n    float fy = bumpMap(surfacePos.xy-sampleDistance.yx + uvoffset, q, r);\n    float f = bumpMap(surfacePos.xy + uvoffset, q, r);\n    fx = (fx-f)/sampleDistance.x;\n    fy = (fy-f)/sampleDistance.x;\n    normal = normalize( normal + vec3(fx, fy, 0.) * 0.2 );\n\n    vec3 lightV = lightPos - surfacePos;\n    float lightDist = max(length(lightV), 0.001);\n    lightV /= lightDist;\n\n    vec3 lightColour = vec3(r.r * f * 3., r.g * f * 3., r.g * f * 3.);\n\n    float falloff = 0.05;\n    float attenuation = 1./(1.0 + lightDist*lightDist*falloff);\n\n    float diffuse = max(dot(normal, lightV), 0.);\n    float specular = pow(max(dot( reflect(-lightV, normal), -ray), 0.), 22.);\n    //这里调颜色\n    vec3 texCol = vec3(0.15, .15, 1.5);\n    texCol = smoothstep(0.05, .75, pow(texCol*texCol, vec3(.55, .99, .85)));\n    // texCol = vec3(f * .5, f, f * .2);\n\n    vec3 colour = (texCol * (diffuse*vec3(1, .97, .92)*2. + 0.5) + lightColour*specular * f * 2.)*attenuation;\n\n    return vec4(sqrt(colour), 1.);\n}\n\n\nvec3 renderPass3(vec2 uv, vec2 uvoffset)\n{\n    vec3 surfacePos = vec3(uv, 0);\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 lightPos = vec3(0., 0., -3.);\n    vec3 normal = vec3(0., 0., -1);\n\n    vec2 sampleDistance = vec2(1. / iMouse.x, 0.);\n\n    vec2 q = vec2(0., 0.);\n    vec2 r = vec2(0., 0.);\n\n    float fx = bumpMap(surfacePos.xy - sampleDistance.xy + uvoffset, q, r);\n    float fy = bumpMap(surfacePos.xy - sampleDistance.yx + uvoffset, q, r);\n    float f = bumpMap(surfacePos.xy + uvoffset, q, r);\n    fx = (fx - f) / sampleDistance.x;\n    fy = (fy - f) / sampleDistance.x;\n    normal = normalize(normal + vec3(fx, fy, 0.) * 0.2);\n\n    vec3 lightV = lightPos - surfacePos;\n    float lightDist = max(length(lightV), 0.001);\n    lightV /= lightDist;\n\n    // 高亮颜色\n    vec3 lightColour = vec3(r.r * f * 1., r.g * f * 13., r.g * f * 33.);\n\n    float falloff = 0.05;\n    float attenuation = 1. / (1.0 + lightDist * lightDist * falloff);\n\n    float diffuse = max(dot(normal, lightV), 0.);\n    float specular = pow(max(dot(reflect(-lightV, normal), -ray), 0.), 22.);\n\n    // 波纹颜色\n    \n    vec3 texCol = vec3(0.15, .15, 1.5);\n    \n    texCol = smoothstep(0.05, .75, pow(texCol * texCol, vec3(.55, .99, .85)));\n    //texCol = vec3(f * .5, f, f * .2);\n\n    // 混色\n    vec3 colour = (texCol * (diffuse * vec3(.1, .57, .2) * 2. + 0.5) + lightColour * specular * f * 2.) * attenuation;\n\n    return colour;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n    vec2 uv = fragCoord / iResolution.xy;\n\n    \n    vec4 render = renderPass(uv, vec2(1.));\n    \n    vec3 col = vec3(0.01, .15, 0.15);\n\n\n    vec2 uv0 = uv;\n    vec3 finalColor = renderPass3(uv, vec2(1.));\n    for(float i=0.0; i< 1.0; i++){ \n    \n        uv = fract(uv * 0.2)- (pow(i*0.3, 0.8));\n\n        float d = pow(length(uv), 2.2) * exp(length(uv0));\n        d *= cos(d);\n        //d = iMouse.x + iMouse.y;\n        //d -= pow(length(iMouse.x + iMouse.y), .9);\n        d -= length(iMouse.xy) * 0.00005;\n        //d = iMouse.x + iMouse.y;\n        \n        //vec3 col = palette(length(uv0) + exp(i*7.2) + -iTime*0.4);\n        //vec3 col = palette(length(uv0) + exp(i*7.2) + sin(-iTime*0.4)*1.2);\n\n        d = sin(d*18. + iTime)/18.;\n        d = abs(d);\n        //d += length(pow(sin(iTimeDelta*6.), 1.67));\n        d = pow(0.01/d, 0.6);\n        \n        \n        finalColor += col *d;\n        \n    }\n    \n    \n    //fragColor = render;\n    fragColor = vec4(finalColor, .1);\n}","name":"Image","description":"","type":"image"}]}