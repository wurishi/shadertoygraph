{"ver":"0.1","info":{"id":"XlVBRy","date":"1542974048","viewed":133,"name":"Ray intersections","username":"gest","description":"Ray intersection with spheres and plane/ Reflection and shadow onboard.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["intersectsphereplanereflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Адаптер\nfloat u_time;\n\n\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n\nstruct Material {\n    vec3  colorDiffuse;\n\tvec3  colorAmbient;\n\tvec3  colorSpecular;\n    float factorSpecular;\n\tfloat reflectFactor;\n};\nconst Material metal_reflect= Material(vec3(0.4,0.4,0.4),vec3(0.3,0.3,0.3),vec3(0.99),120., 0.75);\n\nconst Material red_reflect \t= Material(vec3(0.6,0.2,0.2),vec3(0.4,0.1,0.1),vec3(0.99), 80., 0.75);\nconst Material green_reflect= Material(vec3(0.2,0.6,0.2),vec3(0.1,0.4,0.1),vec3(0.99), 80., 0.75);\nconst Material blue_reflect = Material(vec3(0.2,0.2,0.6),vec3(0.1,0.1,0.4),vec3(0.99), 80., 0.75);\n\nconst Material red_mat \t\t= Material(vec3(0.6,0.2,0.2),vec3(0.4,0.1,0.1),vec3(0.99), 80., 0.00);\nconst Material green_mat \t= Material(vec3(0.2,0.6,0.2),vec3(0.1,0.4,0.1),vec3(0.99), 80., 0.00);\nconst Material blue_mat \t= Material(vec3(0.2,0.2,0.6),vec3(0.1,0.1,0.4),vec3(0.99), 80., 0.00);\n//----------------------------------------------------------\n//Шар\nstruct Sphere {\n\tvec3  \t\tcenter;\n    float \t\tradius;\n};\n//Плоскость\nstruct Plane {\n    vec3 \t\tcenter;\n\tvec3 \t\tnormal;\n};\n//----------------------------------------------------------\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Mapdata {\n\tfloat   \tdistance;\t//Дистанция до элемента сцены\n\tint \t\tid;\t\t\t//id элемента сцены\n    Material \tmaterial;\t//Материал шара или плоскости\n\tSphere\t\tsphere;\t\t//Искомый шар\n\tPlane\t\tplane;\t\t//Искомая плоскость\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n//\tfloat epsilon;\t\t//Точность\n//\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\t\t//Нормаль в точке пересечения\n\tMapdata mapdata;\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n//---------------------------------------------------------\n//Освещение\nstruct Light {\n    vec3 position;\n\tvec3 direction;\n\tvec3 color;\n};\nLight light = Light(vec3(50,50,50), vec3(0), vec3(0.99, 0.99, 0.99));\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n//Перечсечение луча с шаром\n/*\nfloat intersect (Ray ray, Sphere sphere) {\n\n    vec3 toCamDir = ray.origin - sphere.center;\n    \n    float a = dot (ray.direction, ray.direction);\n    float b = 2.*dot(toCamDir, ray.direction);\n    float c = dot(toCamDir, toCamDir) - sphere.radius*sphere.radius;\n    float d = b*b - 4.*a*c;\n\t\n    if (d<0.) return ray.far;\n\t\n\td = sqrt(d);\n\td = min(max(0.,-b-d), max(0.,-b+d));\n\tif (d<0.) return ray.far;\n\tfloat dist = d/(2.*a);\n\t\n\tif (dist < ray.near) return ray.far;\n\t\n\treturn dist;\n}\n*/\nfloat intersect (Ray ray, Sphere sphere){\n    vec3 toCamDir = ray.origin - sphere.center;\n\t\n    float proj = dot(toCamDir, ray.direction);\n    float d = proj * proj - dot(toCamDir, toCamDir) + sphere.radius * sphere.radius;\n    \n    if (d < 0.0) return ray.far;\n\t\n\tfloat dist = -proj - sqrt(d);\n\tif (dist < 0.0)  dist = -proj + sqrt(d);\n\t\n\tif (dist < ray.near) return ray.far;\n\t\n\treturn dist;\n} \n//Пересечение луча с плоскостью\nfloat intersect(Ray ray, Plane plane) {\n\t\n    float dist = dot(plane.normal, ray.direction);\n\tif (dist==0.) return ray.far;\n\t\n\tdist = dot(plane.center - ray.origin, plane.normal) / dist;\n\t\n\tif (dist < ray.near) return ray.far;\n\t\n\treturn dist;\n}\n//Карта расстояний до объектов сцены\nfloat map (in Ray ray, out Mapdata mapdata) {\n\tmapdata.distance = Infinity;\n\t\n\tfloat d;\n\tvec3 p; //Центр\n\tPlane plane;\n\tSphere sphere;\n\t\n\t//Центральный шар\n\tp = vec3(0,0,0);\n\tsphere = Sphere(p, 3.);\n\td = intersect(ray, sphere);\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance \t= d;\n\t\tmapdata.sphere \t\t= sphere;\n\t\tmapdata.material \t= metal_reflect;\n\t\tmapdata.id \t\t\t= 1;\n\t}\n\t\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(0,7,7));\n\trotate(p, vec3(1,0,0)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//Материал шара\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_mat;\n\t\tif (mod(i,3.)==1.) material = green_mat;\n\t\tif (mod(i,3.)==2.) material = blue_mat;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\t\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(7,-7,0));\n\trotate(p, vec3(0,0,1)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//Материал шара\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_reflect;\n\t\tif (mod(i,3.)==1.) material = green_reflect;\n\t\tif (mod(i,3.)==2.) material = blue_reflect;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(7,7,0));\n\trotate(p, vec3(0,0,1)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//Материал шара\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_reflect;\n\t\tif (mod(i,3.)==1.) material = green_reflect;\n\t\tif (mod(i,3.)==2.) material = blue_reflect;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(0,-7,7));\n\trotate(p, vec3(1,0,0)*(u_time/2.));\n\tfor (float i=0.; i<6.; i++) {\n\t\t//Материал шара\n\t\tMaterial material;\n\t\tif (mod(i,3.)==0.) material = red_mat;\n\t\tif (mod(i,3.)==1.) material = green_mat;\n\t\tif (mod(i,3.)==2.) material = blue_mat;\n\t\trotate(p, vec3(0,1,0)*(PI/3.));\n\t\tsphere = Sphere(p, 2.);\n\t\td = intersect(ray, sphere);\n\t\tif (mapdata.distance > d) {\n\t\t\tmapdata.distance \t= d;\n\t\t\tmapdata.sphere \t\t= sphere;\n\t\t\tmapdata.material \t= material;\n\t\t\tmapdata.id \t\t\t= 1;\n\t\t}\n\t}\n\n\t//Плоскость\n\tp = vec3(0,0,0);\n\ttranslate(p, vec3(0,4,0));\n\tplane = Plane(p, vec3(0,1,0));\n    d = intersect(ray, plane);\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance \t= d;\n\t\tmapdata.plane \t\t= plane;\n\t\tmapdata.material \t= metal_reflect;\n\t\tmapdata.id = 2;\n    }\n\t\n\treturn mapdata.distance;\n}\n//Нормаль в точке пересечения\nvec3 mapNormal (Ray ray) {\n\tif (ray.mapdata.id==1) {\n\t\t//Сфера\n\t\treturn (ray.position - ray.mapdata.sphere.center)/ray.mapdata.sphere.radius;\n\t} else if (ray.mapdata.id==2) {\n\t\t//Плоскость\n//\t\treturn ray.mapdata.plane.normal;\n\n\t\t//Нормаль поверхности воды\n\t\tfloat lambda = 5.0;\n\t\tfloat ptx = ray.position.x - cos(ray.position.y );\n\t\tfloat ptz = ray.position.z - sin(ray.position.z );\n\t\treturn normalize(vec3(  \n\t\t\t0.020 * sin( ptx * lambda * 0.5 + u_time * 7.1) +  \n\t\t\t0.010 * sin( (ptx + ptz * 0.3) * lambda + u_time * 8.0) + \n\t\t\t0.005 * sin( (ptx - ptz * 0.9) * lambda*2.1 + u_time * 5.2),\n\t\t\t1.0, \n\t\t\t0.020 * cos( ptz * lambda * 0.5 + u_time * 7.6) + \n\t\t\t0.010 * cos( ptz * lambda + u_time * 8.0) + \n\t\t\t0.005 * cos( ptz * lambda *1.9 + u_time * 5.6)\n\t\t));\n\t}\n}\n//Поиск пересечения луча с поверхностью\nvoid rayMarch(inout Ray ray){\n    ray.origin += ray.near * ray.direction;\n\t//Флаг успешности\n\tray.hit\t\t = false;\n\t//Нормаль\n\tray.normal\t = vec3(0);\n\t//Дистанция\n    ray.distance = map(ray, ray.mapdata);\n\t//Точка пересечения\n\tray.position = ray.origin + ray.distance * ray.direction;\n\t\n\tif (ray.distance>=ray.near && ray.distance<ray.far) {\n\t\tray.hit\t\t\t= true;\n\t\t//Определение нормали\n\t\tray.normal = mapNormal(ray);\n\t}\n}\n//Освещение\nvec3 lighting (vec3 p, vec3 normal, vec3 camPos, Light light, Material material, float shadow) {\n\n    vec3 toLightDir = normalize(light.position - p);\n    vec3 toCamDir \t= normalize(camPos - p);\n    vec3 toLightDir_reflect = reflect (-toLightDir, normal);\n\n\tfloat diffuse \t= max(0., dot(toLightDir, normal));\n\tfloat spcFac \t= max(0., dot(toLightDir_reflect, toCamDir));\n\tfloat specular \t= pow(spcFac, material.factorSpecular);\n\n    vec3 color = vec3(0.);\n    color += material.colorAmbient;\n\tcolor += diffuse * material.colorDiffuse * (1. - shadow);\n\tcolor += specular * material.colorSpecular * (1. - shadow);\n    color *= light.color;\n\treturn color;\n}\n\nfloat softShadow(vec3 p, Light light, float k) {\n\tfloat res=1.;\n\tconst float N=10.;\n\tconst float eps = 0.005;\n\tfloat L = distance(p, light.position);\n\tfor (float i=0.; i<N; i++) {\n\t\tfloat angle = 2.*PI/N*i;\n\t\tvec3 dir = normalize(vec3(sin(angle), 0., cos(angle)));\n\t\tvec3 pos = p + 0.5 * dir;\n\t\tfloat l = distance(pos, light.position);\n\t\tRay ray1;\n\t\t{\n\t\t\tray1.origin \t= pos;\n\t\t\tray1.direction \t= normalize(light.position - pos);\n\t\t\tray1.near \t\t= eps;\n\t\t\tray1.far\t\t= L;\n\t\t}\n\t\trayMarch(ray1);\n\t\t\n\t\tif (ray1.hit) {\n\t\t\tres -= clamp(k * (L-l)/N, 0., 1.);\n\t\t}\n\t}\n\treturn clamp(res, 0., 1.);\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n\t//Адаптер\n    u_time = iTime;\n\tvec2 u_canvas = iResolution.xy;\n\tvec3 u_mouse = iMouse.xyw;    \n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = -1. + 2. * uv;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n\n    rotate(light.position, vec3(0,1,0)*(-u_time/2.));\n\n    Camera cam;\n    {\n        cam.fov     = 30.;\n        cam.aspect  = aspect;\n//        cam.origin  = vec3(0, 8, 40. + mouse.z);\n        cam.origin  = vec3(0, 8, 40.);\n\n        rotate(cam.origin, vec3(1,1,1)*u_time/6.);\n\n        cam.target  = vec3(0.,0.,0.);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.001;\n        ray.far  \t= Infinity;\n    }\n\n    //Фон\n    vec3 color = clamp(vec3(0.45, 0.76, 0.98) * sin(u_time/6.), 0., 1.) ;\n\n    //Общий фактор отражения\n    float reflectFactor = 1.0;\n\n    for (int i=0; i<3; i++) {\n        //Расчет пересечения луча\n        rayMarch(ray);\n\n        if (ray.hit) {\n/*\n            //Расчет тени\n            Ray ray1 = ray;\n            {\n                ray1.origin \t= ray.position;\n                ray1.direction \t= normalize(light.position - ray.position);\n            }\n            rayMarch(ray1);\n\n            float shadow = 0.;\n\n            if (ray1.hit) {\n                shadow = (ray.mapdata.id==2) ? (0.2) : (0.7); //Поверхность воды - 0.2\n            }\n*/\n            float shadow = 1. - softShadow(ray.position, light, 4.0);\n            //Освещение\n            vec3 col = lighting(ray.position, ray.normal, ray.origin, light, ray.mapdata.material, shadow);\n            //Добавляем отраженный свет\n            color += col*(1.0 - ray.mapdata.material.reflectFactor)*reflectFactor;\n            //Гамма-коррекия\n            color *= pow(col,vec3(1./2.2));\n            //Учитываем отражение материалы\n            reflectFactor *= ray.mapdata.material.reflectFactor;\n            if (reflectFactor < 0.1 ) break;\n            //Отражаем луч от поверхности\n            ray.origin \t\t= ray.position;\n            ray.direction \t= reflect(ray.direction, ray.normal);\n        }\n    }\n\n    GL_FragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}