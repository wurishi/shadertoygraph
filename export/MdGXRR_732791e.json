{"ver":"0.1","info":{"id":"MdGXRR","date":"1462482863","viewed":1147,"name":"Animated candle","username":"TambakoJaguar","description":"My try at a realistic candle with a realistic animated flame. Take some time to observe it, it's worth it! ;)\nUse your mouse to move around the scene.\nIf you know some way to improve it, please tell me, thanks!","likes":54,"published":1,"flags":0,"usePreview":1,"tags":["subsurfacescattering","flame","fire","animated","burning","wood","candle","metal","table","plate","wax","volumesampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Animalted candle\" by Emmanuel Keller aka Tambako - May 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them, but be careful, some options can crash your browser!\n#define specular\n//#define reflections\n#define shadow\n//#define test_shadow\n#define ambocc\n//#define test_ambocc\n#define ss_scatering\n#define show_table\n#define show_candle\n#define show_flame\n#define flame_movement\n#define burning_candle\n#define show_plate\n//#define antialias\n//#define dev_mode\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define TABLE_OBJ      1\n#define CANDLE_OBJ     2\n#define WICK_OBJ       3\n#define FLAME_OBJ      4\n#define PLATE_OBJ      5\n\nLamp lamps[3];\n\n// Campera options\nvec3 campos = vec3(0., -0.4, 10.);\nvec3 camtarget = vec3(0., 0.3, 0.);\nvec3 camdir;\nfloat fov = 11.;\nfloat angle;\nfloat angle2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.;\n\n// Color options\nconst vec3 candleColor_out = vec3(0.85, 0.3, 0.5);\nconst vec3 candleColor_in = vec3(1.05, 0.7, 0.85);\nconst vec3 wickColor1 = vec3(0.1, 0.1, 0.1);\nconst vec3 wickColor2 = vec3(1.9, 0.6, 0.1);\nconst vec3 flameColor1 = vec3(1.25, 0.9, 0.55);\nconst vec3 flameColor2 = vec3(0.12, 0.08, 0.94);\nconst vec3 plateColor = vec3(1.05, 1.09, 1.14);\n\n// Shading options\nconst float specint_table = 0.22;\nconst float specshin_table  = 15.;\nconst float specint_candle = 0.1;\nconst float specshin_candle = 1.;\nconst float specint_plate = 0.35;\nconst float specshin_plate = 7.;\nconst float shi = 0.85;\nconst float shf = 0.11;\nconst float aoint = 0.65;\nconst float sssInt = 0.25;\nconst float ssstrmr = 1.8;\n\n// Flame parameters\nconst float flameIntensity = 1.05;\nconst float flameStep = 0.005;\nfloat flameBias = -0.002;\nconst float flameMovInt = 2.2;\nconst float flameMovSpeed = 0.37;\n    \n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 30.;\nconst int nbref = 1;\n\n// Other perameters\nconst float woodSize = 0.4;\nconst float plateSize = 1.18;\nconst float plateThickness = 0.037;\n\n#ifdef show_flame\n#ifdef burning_candle\nconst float burningSpeed = 0.001;\n#else\nconst float burningSpeed = 0.;\n#endif\n#else\nconst float burningSpeed = 0.;\n#endif\nfloat burnPos;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nfloat aaindex;\nbool traceFlame = true;\n\nfloat SoftMaximum(float x, float y, float fact)\n{\n    x*= fact;\n    y*= fact;\n    \n\tfloat maximum = max(x, y);\n\tfloat minimum = min(x, y);\n\treturn (maximum + log(1.0 + exp(minimum - maximum)))/fact;\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat map_plate(vec3 pos)\n{\n    #ifdef show_plate\n    pos = rotateVec2(pos);\n    pos.y+= 0.971 + plateThickness;\n    \n    float l = length(pos.xz)/plateSize;\n    pos.y-= 0.13*smoothstep(0.58, 0.75, l);\n    pos.y-= 0.05*smoothstep(0.7, 1.1, l);\n    pos.y-= 0.06*smoothstep(-1., 0.6, cos(l*3.));\n    pos.y/= (1. + 0.45*smoothstep(0.96, 1.02, l));\n    float df = sdCylinder(pos, vec2(plateSize*1.1, plateThickness*1.03));\n    df = SoftMaximum(df, sdCylinder(pos, vec2(plateSize, plateThickness*2.)), 55.);\n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif   \n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_candle(vec3 pos)\n{\n    #ifdef show_candle\n    pos = rotateVec2(pos);\n    pos.y+= 0.644;\n    float rc = sdTorus82(pos, vec2(0.23, 0.27));\n    float cs = length(pos*vec3(1. + burnPos*0.4, 1., 1. + burnPos*0.4) - vec3(0., 0.65 - burnPos, 0.)) - 0.45;\n    float df = SoftMaximum(rc, -cs, 150.);\n    \n    df+= 0.011*noise(pos*6.);\n    df+= 0.0004*noise(pos*70.)*smoothstep(0.25, 0.3, length(pos.xz));\n    \n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif\n    return df;\n    #else\n    return 10.;\n    #endif   \n}\n\nfloat map_wick(vec3 pos)\n{\n    #ifdef show_candle\n    pos = rotateVec2(pos);\n    pos.y+= 0.345 + burnPos;\n    pos.z*= 1.6;\n    float dy = pow(abs(pos.y + 0.1), 3.);\n    pos.xz-= dy*vec2(5., 12.);\n    \n    float df = sdCylinder(pos, vec2(0.018, 0.1));\n\n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif\n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nvec3 getFlameMovement(vec3 pos)\n{\n    #ifdef flame_movement\n    float t = iTime*flameMovSpeed;\n    vec3 nf = vec3(0.5*(noise(0.3*pos + vec3(0.4, 4.5, 0.5)*t) - 0.5),\n                   0.4*(noise(0.1*pos + vec3(0.5, 2.8, 0.3)*(t + 100.)) - 0.5),\n                   0.5*(noise(0.3*pos + vec3(0.6, 3.2, 0.4)*(t + 200.)) - 0.5));  \n    nf = sign(nf)*smoothstep(0.07, 1., abs(nf));\n    nf*= flameMovInt*smoothstep(-0.17, 0.25, pos.y);\n    return nf;\n    #else\n    return vec3(0.);\n    #endif\n}\n\nfloat map_flame(vec3 pos)\n{\n    #ifdef show_candle\n    #ifdef show_flame\n    if (!traceFlame)\n        return 10.;\n    pos = rotateVec2(pos);\n    pos+= vec3(-0.01, 0.1 + burnPos, -0.035);\n    pos*= 0.75 + 5.*smoothstep(0.44, 0.47, burningSpeed*iTime);\n    vec3 fm = getFlameMovement(pos);\n    vec3 pos2 = pos - fm; \n    \n    float is = length(pos2*vec3(1., 0.5, 1.) + vec3(0., 0.04, 0.)) - 0.04;\n    pos2.xz*= 1. + pos2.y*1.7;\n    pos2.y/= 0.6 + 1.8/pow(abs(pos2.y), 0.2 + 1.3*pos2.y);\n    \n    float df = length(pos2) - 0.07;\n    df = max(df, -is);\n\n    #ifdef dev_mode\n    df = max(df, -pos.x);\n    #endif\n    return df;\n    #else\n    return 10.;\n    #endif\n    #else\n    return 10.;\n    #endif\n}\n\nfloat map_table(vec3 pos, bool btext)\n{\n    #ifdef show_table\n    pos = rotateVec2(pos);\n    #ifdef show_plate\n    pos.y+= 1.129 + plateThickness*2.;\n    #else\n    pos.y+= 1.115;\n    #endif\n    \n    float df = sdCylinder(pos, vec2(5., 0.2));\n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\nvec2 map(vec3 pos, bool btext)\n{\n    vec2 res;\n\n    float candle = map_candle(pos);\n    float wick = map_wick(pos);\n    float flame = map_flame(pos);\n    float table = map_table(pos, btext);\n    float plate = map_plate(pos);\n\n    res = vec2(candle, CANDLE_OBJ);\n    res = opU(vec2(wick, WICK_OBJ), res);\n    res = opU(vec2(flame, FLAME_OBJ), res);\n    res = opU(res, vec2(table, TABLE_OBJ));\n    res = opU(res, vec2(plate, PLATE_OBJ));\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.02;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.65;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx, true).x - map(pos - q.yxx, true).x,\n                          map(pos + q.xyx, true).x - map(pos - q.xyx, true).x,\n                          map(pos + q.xxy, true).x - map(pos - q.xxy, true).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return clamp(vec3(0., 0.05*ray.y, 0.05 + 0.2*ray.y), 0., 0.3);\n}\n\nvec3 getCandleColor(vec3 pos)\n{\n    vec3 col = mix(candleColor_in, candleColor_out, pow(length(pos.xz)/0.45, 5.));\n    return col;\n}\n\nvec3 getWickColor(vec3 pos)\n{\n    vec3 col;\n    //col = mix(wickColor1, 1.6*candleColor_in*(0.3 + 0.8*lamps[1].color), smoothstep(-0.35, -0.42, pos.y));\n    col = mix(wickColor1, candleColor_in*1.15, smoothstep(-0.35, -0.42, pos.y + burnPos));\n    #ifdef show_flame\n    col = mix(col, mix(wickColor2, wickColor1, smoothstep(0.46, 0.47, burningSpeed*iTime)), smoothstep(-0.28, -0.24, pos.y + burnPos));\n    #endif\n    return col;\n}\n\nvec3 getFlameColor(vec3 pos)\n{\n    return mix(flameColor2, flameColor1, smoothstep(-0.3, -0.10, pos.y + burnPos));\n}\n\nvec3 getTableColor(vec3 pos)\n{\n    return mix(1.1*texture(iChannel0, woodSize*pos.xz).xyz, vec3(0.65), 0.15);\n}\n\nvec3 getPlateColor(vec3 pos)\n{\n    float l = length(pos.xz)/plateSize;\n    \n    vec3 col = plateColor - 0.15 + 0.2*l;\n    col-= 0.3*smoothstep(0.48, 0.57, l)*smoothstep(0.62, 0.57, l);\n    col-= 0.1*smoothstep(0.63, 0.71, l)*smoothstep(0.78, 0.71, l);\n    col-= 0.18*smoothstep(0.9, 1.01, l);\n    \n    col+= 0.12*noise(pos*5.3);\n    col = pow(col, vec3(1, 0.9, 0.8));\n    \n    return col;\n}\n\nvec3 getFlameDensColor(vec3 pos, vec3 ray, float s, float fi)\n{\n    float d = 1.;\n    float f;\n    vec3 scol = vec3(0.);\n    for (int i=0; i<30; i++)\n    {\n    \tpos+= ray*s;\n        f = -map_flame(pos);\n        flameBias-= 0.005*smoothstep(0.45, 0.48, burningSpeed*iTime);\n    \td = clamp(f + flameBias, 0., 10.);\n        if (d<-0.1)\n            break;\n        scol+= d*getFlameColor(pos);\n    }\n    \n    return scol*fi;\n}\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   pos = rotateVec2(pos);\n   return (objnr==CANDLE_OBJ?getCandleColor(pos):\n          (objnr==WICK_OBJ?getWickColor(pos):\n          (objnr==FLAME_OBJ?getFlameDensColor(pos, ray, flameStep, flameIntensity):\n          (objnr==TABLE_OBJ?getTableColor(pos):getPlateColor(pos)))));\n}\n\n// Gets the flares of the lamps (kind of non-reflective specular...)\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    #ifdef show_candle\n    #ifdef show_flame\n    rc = 0.65*clamp(normalize(lamps[1].color)*lamps[1].intensity*pow(max(0.0, dot(ray, normalize(lamps[1].position - campos))), 250.), 0., 1.);\n    #endif\n    #endif\n    return rc;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n    traceFlame = false;\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<14; i++)\n    {\n    \tfloat h = map(ro + rd*t, false).x;\n        res = min(res, 7.0*h/t + 0.01*float(i));\n        t += 0.3*clamp(h, 0.01, 0.25);\n        if( h<0.001 || t>tmax ) break;\n    }\n    traceFlame = true;\n    return clamp( res, 0.0, 1.0 );\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<6; i++)\n    {\n        float hr = 0.01 + 0.17*float(i)/9.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos, false).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.81;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col;\n    if (objnr==FLAME_OBJ)\n        col = ocol;\n    else if (objnr==PLATE_OBJ)\n        col = ocol*lamp.color*lamp.intensity*clamp(sign(dnp)*pow(abs(dnp), 1.8), 0., 1.);\n    else\n        col = ocol*lamp.color*lamp.intensity*clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    float specint;\n    float specshin;\n    if (objnr==TABLE_OBJ)\n    {\n        specint = specint_table;\n        specshin = specshin_table;       \n    }\n    if (objnr==CANDLE_OBJ)\n    {\n        float sc = pow(smoothstep(0.28 + burnPos*1.05, 0.05 + burnPos*1.15, length(pos.xz)), 2.);\n        sc*= smoothstep(0.54, 0.47, burningSpeed*iTime);\n        specint = specint_candle + 0.6*sc;\n        specshin = specshin_candle + 280.*sc;       \n    }\n    if (objnr==WICK_OBJ)\n    {\n        specint = specint_candle;\n        specshin = specshin_candle;       \n    }\n    if (objnr==FLAME_OBJ)\n    {\n        specint = 0.;\n        specshin = 10.;       \n    }\n    if (objnr==PLATE_OBJ)\n    {\n        specint = specint_plate;\n        specshin = specshin_plate;       \n    }\n\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    if (objnr!=CANDLE_OBJ && objnr!=FLAME_OBJ)\n        #ifdef test_shadow\n        col = vec3(1.)*softshadow(pos, normalize(lamp.position - pos), shf, 100.);\n        #else\n        col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 100.) + 1. - shi;\n        #endif\n    #endif\n    \n\t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef ss_scatering\n    if (objnr==CANDLE_OBJ || objnr==WICK_OBJ)\n    {\n       vec3 sssColor = (objnr==CANDLE_OBJ?getCandleColor(pos):getWickColor(pos)*1.4);\n\t   float transmission = map_candle(pos + pl*ssstrmr)/ssstrmr;\n\t   vec3 sssLight = sssColor*lamp.color*smoothstep(0.0,1.0,transmission);\n       //col = col*(1. - sssInt) + sssInt*sssLight;\n       col = mix(col, sssLight, sssInt);\n    }\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(10.*cos(4.*iMouse2.x/iResolution.x)*(1. - 0.5*iMouse2.y/iResolution.y),\n                 15.*(iMouse2.y/iResolution.y),\n                 10.*sin(4.*iMouse2.x/iResolution.x)*(1. - 0.5*iMouse2.y/iResolution.y));\n   camtarget = vec3(0., -1.2*iMouse2.y/iResolution.y - 0.3, 0.);\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    #ifdef show_flame\n    //vec3 flamepos = vec3(0.); //vec3(0., 0.2 - burnPos, 0.);\n    vec3 fm = getFlameMovement(vec3(0., 0.2 - burnPos, 0.));\n    vec3 flamepos = vec3(0., 0.2 - burnPos, 0.) + 0.8*fm;\n    float flameint = flameIntensity + 2.5*fm.y;\n    flameint*= smoothstep(0.46, 0.45, burningSpeed*iTime);\n    lamps[0] = Lamp(vec3(-2., 8., 10.), vec3(1., 1., 1.), 0.3, 0.01);\n    lamps[1] = Lamp(flamepos, 0.9*flameColor1, flameint, 0.3); // Flame\n    #else\n    lamps[0] = Lamp(vec3(-2., 8., 10.), vec3(1., 1., 1.), 2.1, 0.01);\n    lamps[1] = Lamp(vec3(0., 0, 0.), vec3(0., 0., .0), 0., 0.3); // Flame (off)\n    #endif\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        #ifdef test_ambocc\n        col = vec3(calcAO(pos, norm));\n        #else\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n        #endif\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf0 = trace0(campos, ray, maxdist);\n    RenderData traceinf = traceinf0;\n  \tvec3 col = traceinf.col;\n    vec3 refray;\n    \n    #ifndef dev_mode\n    #ifdef reflections\n    if (traceinf.objnr==TABLE_OBJ)\n    {\t               \n        refray = reflect(ray, traceinf.norm);\n\n        RenderData traceinf_ref = trace0(traceinf.pos, refray, 20.);\n        float rf = fresnel(ray, traceinf.norm, 3.);\n\n        col+= mix(traceinf_ref.col, col, rf);\n    }\n    #endif\n    if (traceinf.objnr==FLAME_OBJ)\n    {\n        traceFlame = false;\n        traceinf = trace0(traceinf.pos, ray, maxdist);\n        traceFlame = true;\n        col = pow(pow(col, vec3(2.)) + pow(clamp(traceinf.col, 0., 1.), vec3(2.)), vec3(1./2.));\n    }\n    #endif\n\n    col+= sky_color(ray);\n    col+= getFlares(ray0);\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    burnPos = 0.45*smoothstep(0., 0.45, burningSpeed*iTime) - 0.04;\n    \n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}  ","name":"Image","description":"","type":"image"}]}