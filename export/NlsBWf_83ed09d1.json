{"ver":"0.1","info":{"id":"NlsBWf","date":"1651989974","viewed":137,"name":"cmykglassrotation","username":"HaleyHalcyon","description":"a","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"7lfBWX","parentname":"Fork rotating g haleyhalcy 266"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.141592653589)\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n#define COLOR_SMOOTHING 0.75\nvec3 color(float x) {\n    float factor = fract(x) * 4.;\n    float f0 = smoothstep(0., COLOR_SMOOTHING, factor);\n    float f1 = smoothstep(0., COLOR_SMOOTHING, factor - 1.);\n    float f2 = smoothstep(0., COLOR_SMOOTHING, factor - 2.);\n    float f3 = smoothstep(0., COLOR_SMOOTHING, factor - 3.);\n    return (\n        HEX(0x009BE8) * (f0 - f1) +\n        HEX(0xfff100) * (f1 - f2) +\n        HEX(0xEB0072) * (f2 - f3) +\n        HEX(0x000000) * (f3 - f0 + 1.)\n    );\n}\n\nvec2 rotate(vec2 uv, float theta) {\n    return vec2(\n        uv.x * cos(theta) - uv.y * sin(theta),\n        uv.y * cos(theta) + uv.x * sin(theta)\n    );\n}\n\n#define FADE_THRES 0.65\nfloat steppedFade(float t) {\n    float ft = floor(t);\n    t -= ft;\n    return ft + smoothstep(0.0, 1.0,\n        t/FADE_THRES * t/FADE_THRES\n    );\n}\n\nvec2 rotEffect(vec2 uv, float t) {\n    float scale = exp2(-t * 0.5);\n    return rotate(\n        floor(\n            rotate(\n                uv * scale, t * PI / 4.\n            )\n        ) + 0.5,\n        -t * PI / 4.\n    ) / scale;\n}\n\nfloat zigzag(float x) {\n    return 1. - abs(1. - fract(x) * 2.);\n}\n\n// returns two floats for hue, one float for saturation\nvec3 spiral(vec2 uv, float t) {\n    vec2 rt = vec2(log(0.2 + length(uv)), atan(uv.y, uv.x) / PI / 2.);\n    vec2 hueVec = rotate(\n        vec2(1.0, 0.0),\n        PI * 2. * (\n            0.5 * steppedFade(1. * rt.x + 2. * t)\n            - 1. * rt.y\n            + 0.08 * sin(2. * t * PI)\n        )\n    );\n    return vec3(hueVec, zigzag(5.8 * uv.x + 11.0 * rt.y + 0.8 * rt.x) * 2.0 - 1.0);\n}\n\n#define LAYERS 6.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 8.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 36.;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    uv *= 1. + 0.03 * sin(6.2 * length(uv) + 2. * t * PI * 2.);\n    \n    // each layer is added up as an angle vector, then the angle of the resultant vector is taken\n    // this is to make averaging over the 0deg line better\n    vec3 abv = vec3(0.);\n    \n    for (float i = 0.; i < LAYERS; i++) {\n        float ti = t + i;\n        vec2 uv0 = rotEffect(uv * scale, ti);\n        abv += spiral(\n            uv0 / scale, t\n        ) *\n        // fade the first and last layers\n        min(min(ti, LAYERS - ti), 1.) / (LAYERS - 1.);\n    }\n    vec3 col = color(atan(abv.y, abv.x) / PI / 2.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}