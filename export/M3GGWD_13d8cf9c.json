{"ver":"0.1","info":{"id":"M3GGWD","date":"1723061074","viewed":42,"name":"lookup table based blinn-phong!","username":"subzerocatalyst","description":"yay! :3\nslightly based on a technique used by the 3ds\nfeaturing EXTREMELY CURSED tbn matrix for (probably wrong) normal mapping! :3","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","shiny","blinnphong","lookuptable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float specularLut[] = float[256]( \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.0, \n0.00392157, \n0.0156863, \n0.0470588, \n0.129412, \n0.364706, \n1.0\n);\n\n\n\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal, out vec2 uv)\n{\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tfloat t;\n\tif(h < 0.0) \n\t\tt = -1.0;\n\telse\n\t\tt = (-b - sqrt(h)); //Again a = 1.\n    normal =((ro+(rd*t)) - sph.xyz) / sph.w;\n    uv = vec2(atan(normal.x/normal.z) / 3.14159265 + 0.5, normal.y * 0.5 + 0.25);\n    return t;\n}\n\nfloat iCube(in vec3 ro, in vec3 rd, in vec4 cub, out vec3 normal, out vec2 uv){\n    vec3 m = 1.0/rd;\n    vec3 n = m*( (ro) -cub.xyz);\n    vec3 k = abs(m)*(cub.w/1.5);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    if(tN > tF || tF < 0.0) return -1.0;\n    normal = (tN > 0.0) ? step(vec3(tN),t1) : step(t2,vec3(tF));\n    normal *= -sign(rd);\n    if(abs(normal.x) > 0.0){\n        uv = ((ro-cub.xyz) + (rd*tN)).zy/2.0 * sign(normal.x);\n    }else if(abs(normal.y) > 0.0){\n        uv = ((ro-cub.xyz) + (rd*tN)).xz/2.0 * sign(normal.y);\n    }else{\n        uv = ((ro-cub.xyz) + (rd*tN)).xy/2.0 * sign(normal.z);\n    }\n    return tN;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    mat3 rotation = mat3(cos(-iTime*.25),0.0,sin(-iTime*.25),0.0,1.0,0.0,-sin(-iTime*.25),0.0,cos(-iTime*.25));\n    \n    vec3 rayDir = normalize(vec3(uv.xy*1.0,1.0))*-rotation*vec3(1.0,-1.0,1.0);\n    vec3 light = normalize(vec3(sin(iTime*0.25),1.0,cos(iTime*0.25)));\n    vec4 ball = vec4(0.0,0.0,0.0,1.0);\n    vec3 normal;\n    vec2 uvs;\n    float shine = sin(iTime * 0.5) * 0.5 + 0.5;\n    float inter = iSphere(vec3(0.0,0.0,2.0)*rotation,rayDir,ball,normal,uvs);\n    if(inter < 0.0){\n        fragColor.rgb = texture(iChannel0,rayDir).rgb;\n    }else{\n        uvs *= 1.0;\n        // absolutely cursed, don't know how this works\n        mat3 tbn = mat3(normal.yzx,normal.zxy,normal.xyz);\n    \n        normal = ((texture(iChannel2,uvs).rgb * 2.0) - 1.0) * tbn;\n        vec3 hvec = normalize((light)-rayDir);\n        vec2 lit = vec2(clamp(dot(normal,light),0.0,1.0),dot(normal,hvec));\n        lit.y = 1.0-((1.0-lit.y)/mix(64.0,0.25,shine));\n        lit.y *= 256.0;\n        vec3 ref = normalize(rayDir - 2.0*dot(rayDir,normal) * normal);\n        //lit.x += texture(iChannel0,normal).r;\n        float spec = mix(specularLut[int(lit.y)],specularLut[int(lit.y+1.0)],fract(lit.y));\n        fragColor.rgb = mix(texture(iChannel0,ref).rgb, lit.x * texture(iChannel1,uvs).rgb,1.0-shine) + spec * shine;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float off = 0.0005;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float sample0 = dot(texture(iChannel0,uv+vec2(-off,-off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * 3.0;\n    sample0 += dot(texture(iChannel0,uv+vec2(off,-off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * -3.0;\n    sample0 += dot(texture(iChannel0,uv+vec2(-off,0.0)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * -10.0;\n    sample0 += dot(texture(iChannel0,uv+vec2(off,0.0)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * 10.0;\n    sample0 += dot(texture(iChannel0,uv+vec2(-off,off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * 3.0;\n    sample0 += dot(texture(iChannel0,uv+vec2(off,off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * -3.0;\n    \n    float sample1 = dot(texture(iChannel0,uv+vec2(-off,-off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * 3.0;\n    sample1+= dot(texture(iChannel0,uv+vec2(-off,off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * -3.0;\n    sample1 += dot(texture(iChannel0,uv+vec2(0.0,-off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * -10.0;\n    sample1 += dot(texture(iChannel0,uv+vec2(0.0,off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * 10.0;\n    sample1 += dot(texture(iChannel0,uv+vec2(off,-off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * 3.0;\n    sample1 += dot(texture(iChannel0,uv+vec2(off,off)).rgb,vec3(0.2126, 0.7152, 0.0722 )) * -3.0;\n    fragColor = vec4((normalize(vec3(sample0,sample1,1.0))*0.5) + 0.5,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}