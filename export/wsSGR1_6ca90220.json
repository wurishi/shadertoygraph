{"ver":"0.1","info":{"id":"wsSGR1","date":"1548152657","viewed":92,"name":"Cloudy Planet by Dmitry Egorov","username":"dima_lanski","description":"Cloudy planet shader by Dmitry Egorov\n\nClick and drag the mouse to look around.\nWait for a while to see a sunset and a sunrise.\nComment the line '#define CLOSESHOT' to get a far shot of the planet.\nFeel free to experiment with other parameters.\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cloudy planet shader by Dmitry Egorov\n// \n// Click and drag the mouse to look around.\n// Wait for a while to see a sunset and a sunrise.\n// Comment the line '#define CLOSESHOT' to get a far shot of the planet.\n// Feel free to experiment with other parameters.\n//\n// The program is a fragment shader, so each pixel's color is decided locally.\n// Everything is procedurally generated, except for a single texture to speed up random noise generation.\n\n\n//----PARAMETERS----\n#define CLOSESHOT // close shot of the planet. Far short if the parameter is not defined\n\n//#define SKIP_OPAQUE\n//#define SKIP_TRANSPARENT\n#define CLOUDS_ONLY\n\nconst v3 _SunDirection = normalize(vec3(0., 0, -1.0));\nconst v3 _PlanetCenter = vec3(0.0,0.0,0.0);\nconst v1 _PlanetRadius = 1.0;\n\n#ifdef CLOSESHOT\n\n#define MOUSELOOK\n\nconst v1 _CameraDistance = _PlanetRadius * 1.06;\nconst v1 _CameraFov = pi/6.;\nconst v1 _CameraStartingAngle = -1.;\nconst v1 _CameraRotationSpeed = pi*0.002;\nconst v1 _CameraTilt = pi / 4.;\n\nconst v3 _BackgroundColor = vec3(0.0, 0.0, 0.0);\n\nconst v3 _DiffuseMargin = 0.1 * vec3(0.12, 0.110, 0.10);\nconst v3 _DiffuseFalloffStart = .2*vec3(0.94, 0.98, 0.99);\nconst v3 _DiffuseSmoothing = 0.35*vec3(0.4, 0.6, 0.85);\nconst v1 _DiffuseBoost = -0.3;\nconst v1 _FresnelIntensity = 0.;\n\nconst v1 _SunAngularRadius = 0.0005;\nconst v3 _SunColor = 1.1*vec3(220.0, 213.0, 150.0) / 255.0;\nconst v1 _SunIntensity = 5.;\nconst v3 _SunGlowColor = 1.1*vec3(180.0, 218.0, 150.0) / 255.0;\n\nconst v1 _StarsDimmingBySun = 0.9;\n\nconst v3 _OceanColor = 0.4*vec3(0.14, 0.34, 0.88);\n//const v3  _OceanColor = 0.45*vec3(0.447, 0.698, 0.180);\nconst v1 _OceanSpecularIntensity = 5.8;\nconst v1 _OceanShiness = 32.;\n\nconst v1 _CloudsCoverage  = .01;\nconst v1 _CloudsRigidness = 2.3;\nconst i1 _CloudsResolution = 11;\nconst i1 _CloudsUnwarpedDetail = 3;\nconst v1 _CloudsPolarBias = 1.30;\nconst v1 _CloudsDetailFalloff = 0.66;\nconst v1 _CloudsSharpness  = 0.125;\nconst v1 _CloudsTextureIntesity = .8;\nconst v1 _CloudsRidgesSharpness = 0.2;\nconst v1 _CloudsSpecularIntensity = .6;\nconst v1 _CloudsShiness = 64.;\nconst v1 _CloudsShadeSharpness = 0.2;\nconst v1 _CloudsShadeSpecularSharpness = 0.05;\nconst v1 _CloudsShadowPower = 1.2;\nconst v1 _CloudsHeight = 0.0013;\nconst v1 _CloudsDistanceDetailFalloff = 0.5;\nconst v1 _CloudsDistanceDetailCutoff = 0.1;\nconst v1 _CloudsScale = 10.;\nconst v1 _CloudsSquosh = 1.2;\nconst v1 _CloudsPreWarp = 2.3;\nconst v1 _CloudsWarp = 1.8;\nconst v1 _CloudsHighlightBoost = 0.6;\nconst v1 _CloudsHighlightBoostThreashold = 0.2;\nconst v3 _CloudsBrightColor = vec3(.94,0.94,0.96);\nconst v3 _CloudsDarkColor = 1.0*vec3(0.66,0.72,0.80);\nconst v3 _CloudsShadeColor = vec3(25, 24, 28) / 255.;\nconst v3 _CloudsHighlightColor = 1.2*vec3(1., 1., 1.);\nconst v4 _CloudsShadowColor = vec4(0.2 * vec3(25, 24, 28) / 255., 0.6);\nconst v1 _CloudsMorphOffset = 1.5;\nconst v1 _CloudsMorphSpeed = 0.0004;\n\nconst v1 _AtmosphereRadius = 0.05;\nconst v1 _AtmosphereInnerFalloff = 2.8;\nconst v1 _AtmosphereInnerSharpness = 0.6;\nconst v1 _AtmosphereInnerSmoothness = 0.05;\nconst v1 _AtmosphereInnerMargin = 0.06;\nconst v1 _AtmosphereOuterSharpness = 0.9;\nconst v1 _AtmosphereOuterSmoothness = 0.4;\nconst v1 _AtmosphereOuterMargin = 0.2;\nconst v1 _AtmosphereIntensity = 0.35;\nconst v1 _AtmosphereZenithIntensity = 1.5;\nconst v1 _AtmosphereSunsetIntensity = 0.2;\nconst v1 _AtmosphereOuterPeakOffset = 0.7;\nconst v1 _AtmosphereSunsetWidth = 0.8;\nconst v1 _AtmosphereSunsetPeakWidth = 0.3;\nconst v3 _AtmosphereInnerColor = vec3(13., 30., 68.) / 255.;\nconst v3 _AtmosphereOuterColor = 2.*vec3(13., 23., 68.) / 255.;\nconst v3 _AtmosphereSunsetColor = 1.5*vec3(52., 160., 232.) / 255.;\nconst v3 _AtmosphereSunsetPeakColor = v3(0.95,0.25,0.00);\n\n#else //----FAR SHOT----\n\n#define MOUSETIME\n\nconst v1 _CameraDistance = _PlanetRadius * 2.5;\nconst v1 _CameraFov = pi/8.;\nconst v1 _CameraStartingAngle = -1.5;\nconst v1 _CameraRotationSpeed = pi*0.001;\nconst v1 _CameraTilt = pi / 3.5;\n\nconst v3 _BackgroundColor = vec3(0.0, 0.0, 0.0);\n\nconst v3 _DiffuseMargin = 0.3*vec3(0.06, 0.053, 0.05);\nconst v3 _DiffuseFalloffStart = .2*vec3(0.97, 0.98, 0.99);\nconst v3 _DiffuseSmoothing = vec3(0.15);\nconst v1 _DiffuseBoost = -0.2;\nconst v1 _FresnelIntensity = 0.;\n\nconst v1 _SunAngularRadius = 0.00004;\nconst v3 _SunColor = 1.1*vec3(220.0, 213.0, 150.0) / 255.0;\nconst v1 _SunIntensity = 5.;\nconst v3 _SunGlowColor = 1.1*vec3(180.0, 218.0, 150.0) / 255.0;\n\nconst v1 _StarsDimmingBySun = 0.9;\n\nconst v3 _OceanColor = 0.4*vec3(0.14, 0.34, 0.88);\n//const v3  _OceanColor = 0.45*vec3(0.447, 0.698, 0.180);\nconst v1 _OceanSpecularIntensity = 5.8;\nconst v1 _OceanShiness = 32.;\n\nconst v1 _CloudsCoverage  = .07;\nconst v1 _CloudsRigidness = 1.5;\nconst int  _CloudsResolution = 9;\nconst int  _CloudsUnwarpedDetail = 4;\nconst v1 _CloudsPolarBias = 1.30;\nconst v1 _CloudsDetailFalloff = 0.6;\nconst v1 _CloudsSharpness = 0.3;\nconst v1 _CloudsRidgesSharpness = 0.2;\nconst v1 _CloudsTextureIntesity = 1.5;\nconst v1 _CloudsSpecularIntensity = 0.25;\nconst v1 _CloudsShiness = 16.;\nconst v1 _CloudsShadeSharpness = 0.7;\nconst v1 _CloudsShadeSpecularSharpness = .7;\nconst v1 _CloudsShadowPower = 1.2;\nconst v1 _CloudsHeight = 0.003;\n//const v1 _CloudsMorphSpeed = 0.0004;\nconst v1 _CloudsMorphSpeed = 0.0002;\nconst v1 _CloudsDistanceDetailFalloff = 0.8;\nconst v1 _CloudsDistanceDetailCutoff = 0.1;\nconst v1 _CloudsScale = 2.;\nconst v1 _CloudsSquosh = 1.2;\nconst v1 _CloudsMorphOffset = 1.5;\nconst v3 _CloudsBrightColor = vec3(.94,0.94,0.96);\nconst v3 _CloudsDarkColor = 0.8*vec3(0.66,0.72,0.80);\nconst v1 _CloudsPreWarp = 2.3;\nconst v1 _CloudsWarp = 1.3;\nconst v3 _CloudsShadeColor = vec3(25, 24, 28) / 255.;\nconst v3 _CloudsHighlightColor = 1.2*vec3(1., 1., 1.);\nconst v4 _CloudsShadowColor = vec4(0.2 * vec3(25, 24, 28) / 255., 0.6);\nconst v1 _CloudsHighlightBoost = 0.4;\nconst v1 _CloudsHighlightBoostThreashold = 0.6;\n\nconst v1 _AtmosphereRadius = 0.08;\nconst v1 _AtmosphereInnerFalloff = 2.7;\nconst v1 _AtmosphereInnerSharpness = 0.6;\nconst v1 _AtmosphereInnerSmoothness = 0.2;\nconst v1 _AtmosphereInnerMargin = 0.1;\nconst v1 _AtmosphereOuterSharpness = 1.4;\nconst v1 _AtmosphereOuterSmoothness = 0.5;\nconst v1 _AtmosphereOuterMargin = 0.1;\nconst v1 _AtmosphereIntensity = 0.8;\nconst v1 _AtmosphereZenithIntensity = 1.1;\nconst v1 _AtmosphereSunsetIntensity = 0.5;\nconst v1 _AtmosphereOuterPeakOffset = 0.6;\nconst v1 _AtmosphereSunsetWidth = 0.3;\nconst v1 _AtmosphereSunsetPeakWidth = 0.1;\nconst v3 _AtmosphereInnerColor = vec3(13., 30., 68.) / 255.;\nconst v3 _AtmosphereOuterColor = 2.*vec3(13., 23., 68.) / 255.;\nconst v3 _AtmosphereSunsetColor = 1.5*vec3(52., 160., 232.) / 255.;\nconst v3 _AtmosphereSunsetPeakColor = v3(0.95,0.25,0.00);\n#endif\n\n//----NOISE----\nfloat noise(in v3 pos) { return noise(pos, iChannel0); }\nfloat ridged_noise(in v3 pos) { return ridged_noise(pos, iChannel0); }\nfloat mixed_noise(in v3 pos) { return mixed_noise(pos, iChannel0); }\nfloat fbm(v3 point, int octaves, v1 lacunarity, v1 gain) { return fbm(point, octaves, lacunarity, gain, iChannel0); }\nfloat ridged_fbm(v3 point, int octaves, v1 lacunarity, v1 gain) { return ridged_fbm(point, octaves, lacunarity, gain, iChannel0); }\n\n//----TIME----\nvec1 time()\n{\n#ifdef MOUSETIME\n    return iTime + 500. * (iMouse.x/iResolution.x);\n#else\n    return iTime;\n#endif\n}\n\n// ----CAMERA----\nvec2 look_angles()\n{\n#ifdef MOUSELOOK\n    v2 m  = screen_point(iMouse.xy, iResolution.xy);\n    v2 m2 = screen_point(iMouse.zw, iResolution.xy);\n    \n    return m.yx * v2(-(pi / 2.) * 0.99, 0.6*pi);\n#else\n    return v2(-0.08, 0.);\n#endif\n}\n\nvoid camera\n(\n       in v1 t // time\n    , out v3 o // origin\n    , out m3 C // camera transform\n)\n{\n    v2 rsl = iResolution.xy;\n    v2 la = look_angles();\n    \n    // camera movement\n    v1 sa = _CameraStartingAngle;\n    v1 rs = _CameraRotationSpeed;\n    m3 tl = rotationZ(_CameraTilt); // tilt\n    v1 ra = sa - t * rs; // rotation angle\n    m3 rt = rotationY(ra); // rotation\n    \n    m3 wt = rt * tl; // world transform\n    vec1 d = _CameraDistance;\n    o = wt * vec3(0.0, 0.0, -d);\n    C = wt * rotationY(la.y) * rotationX(la.x);\n}\n\n//----STARS----\nv4 stars\n(\n      in v3 rd // ray direction\n    , in v1 ps // pixel size\n    , in v1 sv // sun visibility\n)\n{\n    v1 sd = _StarsDimmingBySun;\n    \n    //TODO: parametrize!!!\n    v3 sp = (iResolution.y / 6.)*rd; // sampling point\n    v1 shape = fbm(sp, 3, 2.01, 0.55) ;\n    v3 color = hsv2rgb(vec3(noise(2.*sp), 3.*(1. - shape), 0.8));\n    return vec4(color, (1. - sd*sqrt(sv)) * sstep(0.86, shape, ps));\n}\n\n\n// ----PLANET----\nv1 clouds_shape\n(\n      in v3 rd // ray direction\n    , in v3  n // normal\n    , in v3 sp // sampling point\n    , in v1  w // warp\n    , in v1  r // raise\n)\n{\n    v1 l = 2.01; // lacunarity\n\n    int uo  = _CloudsUnwarpedDetail; // unwarped octaves\n    int wo  = _CloudsResolution - uo; // warped octaves\n    v1  wof = float(wo);\n    \n    v1 df = _CloudsDetailFalloff;\n    v1 ns = fbm(sp + w, wo, l, df); // noise\n    \n    v3 rsp = sp * pow(l, wof); // rescaled point\n    v1 rsg = pow(df, wof); // rescaled gain\n    \n    v1 ddf = _CloudsDistanceDetailFalloff;\n    v1 ddc = _CloudsDistanceDetailCutoff;\n    v1 d = pow(wdot(n, -rd, -ddc), ddf); // detail\n    if(d > 0.0)\n    {\n        ns +=  rsg * fbm(rsp, uo, l, d * df);\n    }\n    \n    v1 bnns = sbands(from01to11(ns), 10., _CloudsSharpness);// banded noise of the shape\n    \n    v1 rg = 20. * _CloudsRigidness; // rigidness\n    return rg*0.23*bnns + _CloudsCoverage + _CloudsPolarBias * r;\n}\n\nv1 clouds_texture\n(\n      in v3 rd // ray direction\n    , in v3  n // normal\n    , in v3 sp // sampling point\n    , in v1  w // warp\n    , in v1  r // raise\n)\n{\n    v1  l = 2.01; // lacunarity\n    v3 wsp = sp + w; // warped sampling point\n    v1 mn = 0.0; // main noise \n    mn +=  0.5*pow(ridged_noise(wsp*0.5), 1.1);\n    mn +=      pow(ridged_noise(wsp), 1.1);\n    mn +=  0.5*pow(ridged_noise(wsp * 2.0 + v3(1.)), 1.1);\n    mn += 0.25*noise(wsp * 4.0 + v3(3.));\n    mn += 0.13*noise(wsp * 8.0 + v3(7.));\n    mn -= 0.12*noise(wsp * 16.0 + v3(023.));\n    mn += 0.06*noise(wsp * 32.0 + v3(111.));\n    \n#ifdef FARSHOT\n    mn += 0.08*noise(wsp * 64.0 + v3(283.));\n    mn += 0.04*noise(wsp * 128.0 + v3(283.));\n    mn = sbands(mn, 4., 0.4);\n#else\n    \n    v3 mfsp = (sp + 0.3*w) * 64.0 + v3(283.); // mid frequency warped sampling point\n    v1 mfn = 0.0; // mid frequency noise\n    mfn +=     noise(mfsp);\n    mfn += 0.4*noise(mfsp * 2. + v3(583.));\n    mfn *= 0.06;\n\n    v1 hfn = 0.0; // high frequency noise\n    \n    v1 f = pow(wdot(-rd, n, 0.2), 0.6);\n    \n    if(f > 0.0)\n    {\n        v3 hfsp = (sp + 0.2*w) * 256.0 * 1.1 + v3(203.); // high frequency warped sampling point\n        hfn +=      noise(hfsp);\n        hfn += 0.30*noise(hfsp * 2. + v3(1022.));\n        hfn += 0.15*noise(hfsp * 4. + v3(1022.));\n        hfn = pow(hfn, 2.);\n        hfn *= f*0.005;\n    }\n    \n    mn += 0.6*mfn + -2.0*hfn;\n    mn = sbands(mn, 4., 0.18);\n    mn += 1.*mfn + 2.*hfn;\n#endif\n    \n    mn *= _CloudsTextureIntesity;\n    return mn;\n}\n\nv3 sampling_point\n(\n      in v3 n // normal\n    , in v1 t // time\n)\n{\n    v1 ddf = _CloudsDistanceDetailFalloff;\n    v1 ddc = _CloudsDistanceDetailCutoff;\n    \n    v1 rg = 20. * _CloudsRigidness; // rigidness\n    \n    v3 sp = n;\n    sp *= vec3(1.0, _CloudsSquosh, 1.0) *_CloudsScale;\n    sp += _CloudsMorphOffset + t*_CloudsMorphSpeed;\n    \n    return sp;\n}\n\nv1 warp\n(\n    in v3 sp // sampling point\n)\n{\n#if 0\n    v1 ww = _CloudsPreWarp * fbm(sp, 4, 2.01, 0.6); // warp's warp offset\n    return _CloudsWarp * fbm(sp + ww, 4, 2.01, 0.4); // warp offset\n#elif 1\n    v1 pw = 0.0;\n    pw += 0.4 * ridged_noise(sp*1.5);\n    pw += 0.1 * noise(sp*4.);\n    pw *= _CloudsPreWarp;\n    v1 w = 0.0;\n    w += 0.4*noise(sp*1.5 + pw);\n    w += 0.15*noise(sp*4. + pw);\n    w += 0.1*noise(sp*8. + pw);\n    \n    return _CloudsWarp * w; // warp offset\n#else\n    return 0.;\n#endif\n}\n\n//returns color and specular reduction\nv4 shade\n(\n      in v3  rd // ray direction\n    , in v3   n // normal\n    , in v3  sd // sun direction\n    , in v3 shd // shadow direction\n    , in v1   t // time\n    , in v1   r // raise\n    , in v1  tx // texture\n)\n{\n    v1 eps  = 0.0001;\n    v3 son = normalize(n + eps*normalize(-shd)); // shade offset sample point\n    v3 osp = sampling_point(son, t);\n    v1  sw = warp(osp);\n    v1 shtx = clouds_texture(rd, son, osp, sw, r); // shader texture\n\n    v1 shr  = 0.0015*_CloudsShadeSharpness;\n    v1 sshr = 0.0015*_CloudsShadeSpecularSharpness;\n\t\n    v1 d = from_to(tx, shtx) / eps; // derivative in the direction of the sun\n    d = -d;//invert high low;\n\n    v1 hbi = _CloudsHighlightBoost;\n    v1 hbt = _CloudsHighlightBoostThreashold;\n    v1 hb = 1.; // highlight boost\n    hb += hbi*(0.8 - smoothstep(0., hbt, wdot(sd, n, 0.1)));\n    \n    v3 shdc = v3(0.);\n    shdc += 0.15*step(d, 0.0)*(1. - _CloudsShadeColor)*d; // shade\n    shdc += step(0.0, d)*_CloudsHighlightColor*hb*d; // highlight\n    shdc *= shr;\n    \n    v1 shds = d * sshr;\n    return v4(shdc, shds);\n}\n\nvoid clouds\n(\n     in v3  rd, // ray direction\n     in v3   n, // normal \n     in v1   t, // time\n    out v4   c,\n    out v2 spc,\n    out v4  sh\n)\n{\n    v1  r = smoothstep(0.85, 1.0, abs(sbands(n.y, 2., 0.4))); // raise\n    v3 sp = sampling_point(n, t); // sampling point\n    v1  w = warp(sp); // warp\n    \n    v3 sd  = _SunDirection;\n    v3 shd = plane_project(sd, n); // shadow direction\n\n    v1 shp; // shape\n    sh = vec4(0.0);\n#ifdef CLOUDS_ONLY \n    shp = 1.0;\n#else\n    shp = clouds_shape(rd, n, sp, w, r);\n    if (shp < 1.0)\n    {\n        v3 son = normalize(n + _CloudsHeight*shd); // shadow offset point\n        v3 osp = sampling_point(son, t);\n        v1  sw = warp(osp);\n        v1  ss = clouds_shape(rd, son, osp, sw, r);\n        shd = v4(_CloudsShadowColor.xyz, _CloudsShadowColor.w*pow(sat(ss), _CloudsShadowPower));\n    }\n#endif\n    \n    //project the sun direction to the surface\n    \n    spc = vec2(_CloudsSpecularIntensity, _CloudsShiness);\n    c = v4(0.0);\n    if (shp > 0.0)\n    {\n        v1 tx = clouds_texture(rd, n, sp, w, r); // texture\n        v3 cl = mix(_CloudsDarkColor, _CloudsBrightColor, tx);\n    \n        //shade\n        v4 shd = shade(rd, n, sd, shd, t, r, tx);\n        cl += shd.rgb;\n        spc.x += shd.w;\n        c = vec4(cl, sat(shp));\n    }\n}\n\nvoid surface\n(\n     in v3 point, \n    out v3 color, \n    out v2 specular\n)\n{\n    color = _OceanColor;\n    specular = vec2(_OceanSpecularIntensity, _OceanShiness);\n}\n\nvec3 light\n(\n      in v3 n  // normal\n    , in v3 rd // ray direction\n    , in v3 dc // diffuse color\n    , in v2 sp // specular intensity and shiness\n)\n{\n\n    v3 sd = _SunDirection;\n    v1 si = sp.x; // specular intensity\n    v1 ss = sp.y; // specular shiness\n    \n    // diffuse\n    v3 dm = _DiffuseMargin; // light margin\n    v3 df = _DiffuseFalloffStart;\n    vec3 d = wdot(n, sd, dm);\n    d = smoothstep(v3(0.), df, d);\n    d = smoothout(d, _DiffuseSmoothing);\n    d *= 1. + _DiffuseBoost;\n\n    // specular\n    v3 sc = _SunColor;\n    v1 fi = _FresnelIntensity;\n\n    v3 h = normalize(from_to(rd, sd)); // half vector\n    v1 fr = fi*pow(sat1(1. + dot(h, rd)), 5.0); // fresnel\n    v3 s = dc*sc*si*pow(sat0(dot(n, h)), ss);\n    \n    return (dc + s + fr) * d;\n}\n\nvec4 planet\n(\n      in v3 ro // ray origin\n    , in v3 rd // ray direction\n    , in v1 t  // time\n    , in v1 ps // pixel size\n)\n{\n    v3 pc = _PlanetCenter;\n    v1 pr = _PlanetRadius;\n\n    v3 inn; // intersection normal\n    v1 hit = sphere_intersection_normal_aa(ro, rd, pc, pr, ps, inn);\n    if(hit <= 0.0)\n    {\n        return vec4(0.0);\n    }\n    \n    v4 cc;  // clouds color\n    v2 cs;  // clouds specular\n    v4 csh; // clouds shadow\n    clouds(rd, inn, t, cc, cs, csh);\n\n    v3 fd; // final diffuse\n    v2 fs; // final specular\n\n#ifdef CLOUDS_ONLY\n    fd = cc.xyz;\n    fs = cs;\n#else\n    v3 sc; // surface color\n    v2 ss; // surface specular\n    surface(inn, sc, ss);\n    \n    fd = mix(sc, csh.xyz, csh.w);\n    fd = mix(fd, cc.xyz, cc.w);\n    fs = mix(ss, vec2(0.), csh.w);\n\tfs = mix(fs, cs, cc.w);\n#endif\n    \n    v3 c; // final color\n    c = light(inn, rd, fd, fs);\n    \n    return v4(c, hit);\n}\n\n// ----ATMOSPHERE----\nvec1 outer_atmosphere_density\n(\n      in v1  h // height\n    , in v1 po // peak offset\n)\n{\n    return 0.1 * pow2(((1. + po) / (h + po) - 1.));\n}\n\nvec3 outer_atmosphere_sun_glow\n(\n      in v3 rd // ray direction\n    , in v1  d // density\n    , in v3 sd // sun direction\n    , in v3 sc // sun color\n)\n{\n    //TODO!!!!! Extract parameters\n    return 20.0*sc*smoothstep(0.995, 1.0, pow(sat0(dot(rd, sd)), pow(d, 1.)));\n}\n\nvec3 inner_atmosphere_color\n(\n    in v3 rd,  // ray direction\n    in v3 inn, // sphere intersection normal\n    in v3 col, // atmosphere color\n    in v1 f    // falloff\n)\n{\n    v1 d = 0.97 + dot(rd, inn);// angle of viewing\n    v1 x = f * (1. - pow2(d));\n    return sat(pow(col, vec3(x)));\n}\n\nvec1 inner_atmosphere_visibility\n(\n      v3 n   // sphere intersection normal\n    , v3 sd  // sun direction\n    , v1 sh  // sharpness\n    , v1 m   // margin\n    , v1 sm  // smoothness\n)\n{\n    vec1 d = wdot(n, sd, m);\n    d = smoothstep(0., sh, d);\n    return smoothout(d, sm);\n}\n\nvec1 outer_atmosphere_visibility\n(\n      v3 fn // furthest sphere intersection normal\n    , v3 sd // sun direction\n    , v1 sh // sharpness\n    , v1  m // margin\n    , v1 sm // smoothness\n\n)\n{\n    vec1 d = wdot(fn, sd, m);\n    d = sat0(d);\n    return smoothout(pow(d, sh), sm);\n}\n\nvec1 atmosphere_zenith\n(\n      in v3 rd  // ray direction\n    , in v3 sd  // sun direction\n    , in v1 zi  // zenith intensity\n)\n{\n    vec1 crs  = dot(rd, sd); // cosine between the view ray and the sun\n    \n    return zi*pulse3(crs, -1., 1.4); // zenith\n}\n\nvec3 atmosphere_sunset\n(\n      in v3 rd   // ray direction\n    , in v3 fn   // furthest intersection normal\n    , in v3 sd   // sun direction\n    , in v1 ssi  // sunset intensity\n    , in v1 ssw  // sunset width\n    , in v1 sspw // sunset peak width\n    , in v3 ssc  // sunset color\n    , in v3 sspc // sunset peak color\n    \n)\n{\n    v1 crs = dot(rd, sd); // cosine between the view ray and the sun\n    v1 csrs = dot(normalize(rd - 0.4 * fn), sd); // cosine between the offset view ray and the sun\n    \n    v1 l = 0.0;\n    l += 1.*pulse3(csrs, 1.,  ssw); // sunset\n    l += 2.*pulse3( crs, 1., sspw); // direct sunset\n    \n    v3 c = mix(ssc, sspc, pow2(crs));\n    return ssi*c*l;\n}\n\nvec1 outer_atmosphere_height\n(\n      in v3 ro // ray origin\n    , in v3 rd // ray direction\n    , in v3 pc // planet center\n    , in v1 pr // planet radius\n    , in v1 ar // atmosphere radius\n)\n{\n    v3 oc = from_to(ro, pc);\n    v1 cpsi = dot(rd, normalize(oc));\n    if (cpsi <= 0.)\n        return 1.0;\n    v1 tpsi = sqrt(1. - sqr(cpsi)) / cpsi;\n    v1 a = sqrt(dot(oc, oc) - pr*pr); //distance to surface\n    v1 h = a * (a*tpsi - pr) / (a + pr*tpsi); // absolute height above surface\n    return h / (ar - pr);\n    \n}\n\nvec3 atmosphere\n(\n      in v3 ro // ray origin\n    , in v3 rd // ray direction\n    , in v1 ps // pixel size\n)\n{\n    v1 oh; // normalized height of the outer atmosphere\n    v1 od; // density of the outer atmosphere\n    v3 ci; // inner color\n    v1 vi; // inner visibility\n    v3 co; // outer color\n    v1 vo; // outer visibility\n    v1  z; // zenith\n\tv3 ss; // sunset\n    v3 sg; // sun glow\n    v3  c; // resulting atmosphere color\n    \n    v3  bic = _AtmosphereInnerColor;\n    v3  boc = _AtmosphereOuterColor;\n    v1  ssi = 50.*_AtmosphereSunsetIntensity;\n    v3  ssc = _AtmosphereSunsetColor;\n    v3 sspc = _AtmosphereSunsetPeakColor;\n    v1  ssw = _AtmosphereSunsetWidth;\n    v1 sspw = _AtmosphereSunsetPeakWidth;\n    v1   af = _AtmosphereInnerFalloff;\n    v1   ai = _AtmosphereIntensity;\n    v3   sd = _SunDirection;\n    v3   sc = _SunColor;\n    v3  sgc = _SunGlowColor;\n    v1  shi = _AtmosphereInnerSharpness;\n    v1  smi = _AtmosphereInnerSmoothness;\n    v1   mi = _AtmosphereInnerMargin;\n    v1  sho = _AtmosphereOuterSharpness;\n    v1  smo = _AtmosphereOuterSmoothness;\n    v1   mo = _AtmosphereOuterMargin;\n    v1   zi = _AtmosphereZenithIntensity;\n    v1   po = 0.1*_AtmosphereOuterPeakOffset;\n    v3   pc = _PlanetCenter;\n    v1   pr = _PlanetRadius;\n    v1   ar = pr + _AtmosphereRadius;\n\n    v3 nn; // atmosphere nearest intersection normal\n    v3 fn; // atmosphere furthest intersection normal\n    v1 ah; // atmosphere hit sin of the angle toward hit center\n    ah = intersect_sphere_for_normals(ro, rd, pc, ar, ps, nn, fn);\n    if (ah <= 0.0)\n    {\n        return vec3(0.);\n    }\n    \n    v3 pn; // planet intersection normal\n    v1 ph = sphere_intersection_normal_aa(ro, rd, pc, pr, ps, pn);\n\n    vi = inner_atmosphere_visibility(pn, sd, shi, mi, smi);\n    oh = outer_atmosphere_height(ro, rd, pc, pr, ar);\n    od = outer_atmosphere_density(oh, po);\n    co = boc * od;\n    sg = outer_atmosphere_sun_glow(rd, od, sd, sgc);\n\tvo = outer_atmosphere_visibility(fn, sd, sho, mo, smo);\n    ss = atmosphere_sunset(rd, fn, sd, ssi, ssw, sspw, ssc, sspc);\n     z = atmosphere_zenith(rd, sd, zi);\n    \n    ci = inner_atmosphere_color(rd, pn, bic, af);\n    c = ai*(ss + sg + z + 1.0)*mix(co*vo, ci*vi, ph);\n    \n    return mix(v3(0.0), (c), ah);\n}\n\n//----SUN----\nv3 suns_horizon\n(\n    in v3 ro // ray origin\n)\n{\n    v3 sd  = _SunDirection;\n    v3 pc  = _PlanetCenter;\n    v1  r  = _PlanetRadius;\n    \n    v3   c = from_to(ro, pc); // distance vector to planet center\n    v1  cd = length(c); // distance to the center\n    v3  cn = c / cd; // direction to the center\n    v3 sdp = normalize(plane_project(sd, c / cd)); // creating an ortonormal basis for the plane formed by c and sd\n                    \n    v1 r2 = sqr(r);  // squared radius\n    v1 rc = -r2 / cd; // c component of the rh\n    v1 rs = sqrt(r2 - sqr(rc)); // sdp component of the rh\n    \n    v3 rh = rc * cn + rs * sdp; // radius vector to the horizon\n    v3 h = c + rh; // vector to the horizen\n    \n    return normalize(h);\n}\n\nvoid sun_visibility\n(\n       in v3 ro  // ray origin\n    ,  in m3 C   // camera\n    ,  in v1 ft  // FOV tangent\n    ,  in v1 ar  // aspect ratio (x / y)\n    , out v1 ov  // overall visibility\n    , out v1 ssd // degree of the sunset\n    , out v2 fsp // flare screen position\n)\n{\n    v3 sd  = _SunDirection;\n    v3 pc  = _PlanetCenter;\n    v1 pr  = _PlanetRadius;\n    v1 atr = pr + _AtmosphereRadius;\n    v1 ho  = 0.13; // extra height (TODO: calculate from sun size)\n    \n    ov = 0.0;\n    \n    v1  h = outer_atmosphere_height(ro, sd, pc, pr, atr);\n    v1 eh = sat((h + ho) / (1. + ho)); // extended height\n    if (eh <= 0.)\n        return;\n    \n    v3  sfd = h > 0.0 ? _SunDirection : suns_horizon(ro); // sun flare direction\n    v3 rfsp = ray_to_screen(sfd, C, ft); // sun flare screen position\n    \n    \n    v1 sm = 0.2; // screen visibility margin\n    v1 sv = step(0.0, rfsp.z) * sat(sstep(abs(rfsp.x), ar + sm, sm) * sstep(abs(rfsp.y), 1.0 + sm, sm)); // screen visibility\n    if (sv <= 0.)\n        return;\n    \n    ssd = eh; // degree of sunset\n    ov = sv*pow(eh, 0.7);\n    fsp = rfsp.xy;\n}\n\nv4 sun\n(\n    in v3 rd // ray direction\n)\n{\n    v3 d = _SunDirection;\n    v1 r = _SunAngularRadius;\n    v1 pixel_area = intersect_billboard_circle(rd, d, r);\n    if (pixel_area <= 0.0)\n    {\n        return vec4(0.0);\n    }\n    \n    v1 i = 10.*_SunIntensity*sat(pow8(pixel_area));//intensity\n    return vec4(_SunColor * i, sat(i));\n}\n\n//----LENS FLARE----\nv1 fins\n(\n      in v2 sp // screen point\n    , in v1 rt // rotation\n    , in v1 sc // scale\n    , in v1  n // number of fins\n    , in v1  f // falloff\n    , in v1  l // length\n    , in v1 rn // range\n)\n{\n    v1 r,a;\n    polar(sp, r, a);\n    a += rt;\n    r /= sc;\n    \n    v1 rs = abs(2.*fract(n*a / (2.*pi)) - 1.);\n    rs = rn * rs;\n    rs = pow(rs, f);\n    rs = rs / pow(r, l);\n    rs = sstep(0.07, rs, 0.0175) * rs;\n    \n    return rs;\n}\n\nv1 halo\n(\n      in v2  o // offset\n    , in v1 rt // rotation\n    , in v1 sc // scale\n)\n{\n    v1 r,a;\n    polar(o, r, a);\n    a += rt;\n    r /= sc;\n    \n    v1  s = 1.;  // size\n    v1  g = 2.;   // glow\n    v1  i = 0.02; // intensity\n    v1 rg = 0.34; // rays glow\n    v1 rn = 5.2;  // number of rays \n    v1 ro = 8.1;  // rays offset\n    \n    return (i / pow(r, g)) * (s + rg*abs(cos(rn*a + sin(ro*a))));\n}\n\nv1 glow\n(\n      in v2  o // offset\n    , in v1 sc // scale\n)\n{\n    v1 r,a;\n    polar(o, r, a);\n    r /= sc;\n    \n    v1  f = 1.3; // fallof\n    v1 rn = 0.6; // range\n\n    return exp(-rn*pow(r, f));\n}\n\nv3 lens_flare\n(\n      in v2  sp // screen point\n    , in v2  cn // center\n    , in v1  rt // rotation\n    , in v1  sc // scale\n    , in v1  fn // number of fins\n    , in v1  fi // fins intensity\n    , in v1  ff // fins falloff\n    , in v1  fl // fins length\n    , in v1  fr // fins range\n    , in v1  fa // fins abberation\n    , in v1 cfb // central fin boost\n    , in v1 efb // extra fins boost\n    , in v3  mc // main color\n    , in v3 cs1 // first color shift\n    , in v3 cs2 // second color shift\n)\n{\n    v2  o = from_to(cn, sp);// offset\n    \n    v3 c = vec3(0.0);\n    c += mc*halo(o, rt, sc);\n    c += fi*cfb*fins(o, rt, sc, fn, ff, fl, fr);\n    c += fi*cs1*efb*fins(o + v2(+fa, +fa), rt, sc, fn, ff, fl, fr);\n    c += fi*cs2*efb*fins(o + v2(-fa, -fa), rt, sc, fn, ff, fl, fr);\n    c += fi*cs1*efb*fins(o + v2(+fa, -fa), rt, sc, fn, ff, fl, fr);\n    c += fi*cs2*efb*fins(o + v2(-fa, +fa), rt, sc, fn, ff, fl, fr);\n    c += 0.1*mc;\n    c *= glow(o, sc);\n    \n    return c;\n}\n\nv3 sun_lens_flare\n(\n      in v2 sp // screen point\n    , in v1 ov  // overall visibility\n    , in v1 ssd // degree of the sunset\n    , in v2 fsp // flare screen position\n)\n{\n    v3   mc = v3(0.856,0.919,1.000); // main color\n    v3   rc = v3(0.900,0.508,0.342); // red shift\n    v3   bc = v3(0.135,0.305,0.940); // blue shift\n    v1   fn = 10.;\n    v1  mfi = 1.3;   // main fins intensity\n    v1  mff = 4.3;   // main fins falloff\n    v1  mfl = 0.4;   // main length\n    v1  mfr = 0.65;  // main range\n    v1 mcfb = 2.5;   // main central fin boost\n    v1  mfa = 0.012; // main abberation\n \tv1  sfi = 0.3;   // sunset fins intensity\n\tv1  sff = 8.;    // sunset fins falloff\n    v1  sfl = 1.;    // sunset length\n    v1  sfr = 0.55;  // sunset range\n    v1 scfb = 1.;    // sunset central fin boost\n    v1  sfa = 0.003; // sunset abberation\n    v3  ssc = v3(0.856,0.5,0.100); // sunset color\n    v3 ssrc = mix(rc, ssc, 0.3);\n    v3 ssbc = mix(bc, ssc, 0.3);\n    \n    ssd = gain(pow(ssd, 0.5), 128.);\n    \n    v3   c = mix( ssc,   mc, ssd);\n    v3 sc1 = mix(ssrc,   rc, ssd);\n    v3 sc2 = mix(ssbc,   bc, ssd);\n    v1  fi = mix( sfi,  mfi, ssd);\n    v1  ff = mix( sff,  mff, 0.5*(ssd + ov));\n    v1  fl = mix( sfl,  mfl, 0.5*(ssd + ov));\n    v1  fr = mix( sfr,  mfr, 0.5*(ssd + ov));\n    v1 cfb = mix(scfb, mcfb, 0.5*(ssd + ov));;\n    v1  fa = mix( sfa,  mfa, ssd);\n    v1  rt = pi / 3.; // rotation\n    v1  sc = 0.6; // scale\n    v1 efb = 1.2;\n    \n\treturn ov * lens_flare(sp, fsp, rt, sc, fn, fi, ff, fl, fr, fa, cfb, efb, c, sc1, sc2);\n}\n\n// ----MAIN----\nvec3 opaque_objects\n(\n      in v3 ro // ray origin\n    , in v3 rd // ray direction\n    , in v1 t  // time\n    , in v1 ps // pixel size\n    , in v1 sv // sun visibility\n)\n{\n\tv3 final_color = _BackgroundColor;\n    \n    v4 planet = planet(ro, rd, t, ps);\n    if(planet.w >= 1.)\n    {\n        return planet.xyz;\n    }\n    \n    v4 sun = sun(rd);\n    if (sun.w < 1.0)\n    {\n        v4 stars = stars(rd, ps, sv);\n        final_color = mix(final_color, stars.xyz, stars.w);\n    }\n    \n    if (sun.w > 0.0)\n    {\n        final_color = mix(final_color, sun.xyz, sun.w);\n    }\n    \n    if (planet.w > 0.0)\n    {\n        final_color = mix(final_color, planet.xyz, planet.w);\n    }\n    \n    return final_color;\n}\n\nvec3 transparent_objects\n(\n      in v3 ro // ray origin\n    , in v3 rd // ray direction\n    , in v1 ps // pixel size\n    , in v2 sp // screen point\n    , in v1 sov // sun overall visibility\n    , in v1 ssd // degree of the sunset\n    , in v2 fsp // flare screen position\n)\n{\n    v3 c = v3(0.0);\n    c += atmosphere(ro, rd, ps);\n    c += sun_lens_flare(sp, sov, ssd, fsp);\n    return c;\n}\n\nvoid mainImage\n(\n    out v4 fragColor,\n     in v2 fragCoord\n)\n{\n    v1 t = time();\n    v2 rs = iResolution.xy;\n    v1 ft = tan(_CameraFov);\n    \n    v3 o; // camera origin\n    m3 C; // camera transform\n    camera(t, o, C);\n    \n    v2  p = screen_point(fragCoord, rs); // normalized point\n    v3  d = screen_to_ray(p, C, ft); // ray direction\n    v1 ps = angular_pixel_size(rs, ft); // pixel size\n    \n    v1 sov; // sun's overall visibility\n    v1 ssd; // degree of the sunset\n    v2 fsp; // sun flare screen position\n    sun_visibility(o, C, ft, rs.x / rs.y, sov, ssd, fsp);\n        \n    v3 c = v3(0.0); // final color\n#ifndef SKIP_OPAQUE\n    c += opaque_objects(o, d, t, ps, sov);\n#endif\n#ifndef SKIP_TRANSPARENT\n    c += transparent_objects(o, d, ps, p, sov, ssd, fsp);\n#endif\n    \n    c = pow(c, v3(1./2.2));\n    c += dither(fragCoord, t, 100.);\n    fragColor = v4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// ----TOOLS----\n\n#define vec1 float\n#define i1 int\n#define v1 float\n#define v2 vec2\n#define v3 vec3\n#define v4 vec4\n#define m3 mat3\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\nconst float inf         = 1.0 / 1e-10;\n\n//sat -> saturate\nvec1 sat (vec1 v) { return clamp(v, 0., 1.); }\nvec2 sat (vec2 v) { return clamp(v, 0., 1.); }\nvec3 sat (vec3 v) { return clamp(v, 0., 1.); }\nvec4 sat (vec4 v) { return clamp(v, 0., 1.); }\nvec1 sat0(vec1 v) { return max(v, 0.); }\nvec2 sat0(vec2 v) { return max(v, 0.); }\nvec3 sat0(vec3 v) { return max(v, 0.); }\nvec4 sat0(vec4 v) { return max(v, 0.); }\nvec1 sat1(vec1 v) { return min(v, 1.); }\nvec2 sat1(vec2 v) { return min(v, 1.); }\nvec3 sat1(vec3 v) { return min(v, 1.); }\nvec4 sat1(vec4 v) { return min(v, 1.); }\n\nfloat sfloor(float v, float w) { return floor(v) + smoothstep(0.5 - w, 0.5 + w, fract(v)); }\nfloat sbands(float v, float n, float w) { return sfloor(v * n, w) / n; }\n\nfloat from11to01(float v) { return 0.5*(v + 1.0); }\nvec2  from11to01(vec2 v) { return 0.5*(v + 1.0); }\nfloat from11to(float v, float min, float max) { return (max - min)*from11to01(v) + min; }\nfloat from01to11(float v) { return 2.*(v - 0.5); }\nvec2  from01to11(vec2 v) { return 2.*(v - 0.5); }\nfloat from01to(float v, float min, float max) { return (max - min)*v + min; }\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nvec1 from_to(vec1 from, vec1 to) { return to - from; }\nvec2 from_to(vec2 from, vec2 to) { return to - from; }\nvec3 from_to(vec3 from, vec3 to) { return to - from; }\n\nfloat  sqr(float v) { return v * v; }\nfloat pow2(float v) { return v * v; }\nfloat pow3(float v) { return v*pow2(v); }\nfloat pow4(float v) { return pow2(pow2(v)); }\nfloat pow5(float v) { return v*pow4(v); }\nfloat pow6(float v) { return pow2(v)*pow4(v); }\nfloat pow7(float v) { return v*pow6(v); }\nfloat pow8(float v) { return pow2(pow4(v)); }\nfloat pow9(float v) { return v*pow8(v); }\nfloat pow10(float v) { return pow2(v)*pow8(v); }\n\nfloat vsqr(vec2 v) { return dot(v,v); }\nfloat vsqr(vec3 v) { return dot(v,v); }\n\nfloat sstep(float min, float max, float width) { return smoothstep(min - width, min + width, max); }\nfloat estep(float x, float k, float n) { return exp(-k*pow(x,n)); }\n\n\t\nfloat pulse3(float x, float c, float w)\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat pulse6(float x, float c, float w)\n{\n    return pow2(pulse3(c, w, x));\n}\n\nfloat almost_identity(float x, float m, float n)\n{\n    if( x>m ) return x;\n\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n\n    return (a*t + b)*t*t + n;\n}\n\nfloat smoothout(float x, float m)\n{\n    float n = m / 2.;\n    return (almost_identity(x, m, n) - n) / (1. - n);\n}\n\nvec3 smoothout( vec3 v, vec3 m)\n{\n    return vec3\n    (\n        smoothout(v.x, m.x),\n        smoothout(v.y, m.y),\n        smoothout(v.z, m.z)\n    );\n}\n\t\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n\nvec1 wdot\n(\n      in vec3 n // normal\n    , in vec3 l // direction to the light\n    , in vec1 w // wrapping factor\n)\n{\n    return sat0((dot(n, l) + w) / (1. + w));\n}\n\nvec3 wdot\n(\n      in vec3 n // normal\n    , in vec3 l // direction to the light\n    , in vec3 w // wrapping factor\n)\n{\n    return vec3\n    (\n        wdot(n, l, w.r),\n        wdot(n, l, w.g),\n        wdot(n, l, w.b)\n    );\n}\n\n//----COLOR----\nvec3 rgb2hsl(vec3 color) {\n \tvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n \tfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n \tfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n \tfloat delta = fmax - fmin; //Delta RGB value\n\n \thsl.z = (fmax + fmin) / 2.0; // Luminance\n\n \tif (delta == 0.0) //This is a gray, no chroma...\n \t{\n \t\thsl.x = 0.0; // Hue\n \t\thsl.y = 0.0; // Saturation\n \t} else //Chromatic data...\n \t{\n \t\tif (hsl.z < 0.5)\n \t\t\thsl.y = delta / (fmax + fmin); // Saturation\n \t\telse\n \t\t\thsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n \t\tfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n \t\tif (color.r == fmax)\n \t\t\thsl.x = deltaB - deltaG; // Hue\n \t\telse if (color.g == fmax)\n \t\t\thsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n \t\telse if (color.b == fmax)\n \t\t\thsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n \t\tif (hsl.x < 0.0)\n \t\t\thsl.x += 1.0; // Hue\n \t\telse if (hsl.x > 1.0)\n \t\t\thsl.x -= 1.0; // Hue\n \t}\n\n \treturn hsl;\n }\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 dither(v2 sp, v1 t, v1 d)\n{\n    vec3 c = vec3(dot(vec2(131.0, 312.0), sp + t));\n    c = fract(c / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);\n    return (c / d) * 0.375;\n}\n\n//----DEBUG----\n\nvec4 debug(vec1 v, vec1 b)\n{\n    vec1 sv = v * b;\n    vec1 f  = fract(sv);\n    vec1 df = abs(fwidth(sv));\n\n    vec1 g = smoothstep(0.0, 2.0*df, f);\n        \n    vec1 cv = clamp(v, -1., 1.);\n    return g*vec4\n    (\n        step(0.0, v)*cv*(vec3(0.323,0.915,0.340)) \n      - step(v, 0.0)*cv*(vec3(0.895,0.311,0.217))\n      + step(1.0, v)*(v - 1.) * vec3(0.5, 0., 1.)\n      + step(v, -1.)*(v + 1.) * vec3(0., 1., 0.5),\n        1.0\n    );\n}\n\nvec4 debug(vec1 v) { return debug(v, 1.); }\n\nvec4 debug(vec2 v)\n{\n    return vec4\n    (\n        (v.x*normalize(vec3(0.323,0.915,0.340))\n      + v.y*normalize(vec3(0.895,0.311,0.217)))* 0.5\n      , 1.0\n    );\n}\n\nvec4 debug(vec3 v)\n{\n    return vec4(v, 1.0);\n}\n\nvec4 isolines\n(\n      in vec1 v // value\n    , in vec1 s // scale\n)\n{\n    vec1 sv = v * s;\n    vec1 f  = fract(sv);\n    vec1 n  = floor(sv) / s;\n    vec1 df = abs(fwidth(sv));\n\n    vec1 g = -1. + smoothstep(0.0, 2.0*df, f) + n;\n\n    return vec4(vec3(g), 1.0);\n}\n\nfloat graph(vec2 p, float f, float w)\n{\n    return smoothstep(f - w, f, p.y) - smoothstep(f, f + w, p.y);\n}\n\nvec3 graph_color(vec2 sc, vec3 c, float w)\n{\n    vec3 result = vec3(0.0);\n    float h = graph(sc , rgb2hsv(c.xyz).x, w);\n    float s = graph(sc, rgb2hsv(c.xyz).y, w);\n    float l = graph(sc, rgb2hsv(c.xyz).z, w);\n    result += vec3(h, h,  0.);\n    result += vec3(s,  0., s);\n\tresult += vec3(0., l, l);\n    \n    float r = graph(sc, c.xyz.r, w);\n    float g = graph(sc, c.xyz.g, w);\n    float b = graph(sc, c.xyz.b, w);\n    result += vec3(r, 0.,  0.);\n    result += vec3(0.,  g, 0.);\n\tresult += vec3(0., 0., b);\n    \n    return result;\n}\n\n//----PROJECTION----\nv3 plane_project(vec3 vector, vec3 plane_normal)\n{\n    v3 n = plane_normal;\n    v3 v = vector;\n    \n    return from_to(dot(v, n)*n, v);\n}\n\n//----ROTATION----\nmat3 rotationQ(vec3 axis, float rad) \n{\n    float hr = rad / 2.0;\n    float  s = sin( hr );\n    vec4   q = vec4(axis * s, cos( hr ));\n    vec3  q2 = q.xyz + q.xyz;\n    vec3 qq2 = q.xyz * q2;\n    vec2  qx = q.xx  * q2.yz;\n    float qy = q.y   * q2.z;\n    vec3  qw = q.w   * q2.xyz;\n\n    return mat3\n    (\n        1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,\n        qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,\n        qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)\n    );\n}\n\nmat3 rotationX(float rad) \n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3\n    (\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\n\nmat3 rotationY(float rad) \n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3\n    (\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nmat3 rotationZ(float rad) \n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3\n    (\n        c, s, 0.0,\n        -s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n//----CAMERA----\nvec2 screen_point\n(\n      in vec2 fc // frag coordinate\n    , in vec2  r // resolution \n)\n{\n    return (2.0*fc.xy - r.xy) / r.y;\n}\n\nvec1 pixel_size(in vec2 r)\n{\n    return 1./r.y;\n}\n\nvoid polar\n(\n       in vec2 sp // screen point\n    , out vec1  r // distance\n    , out vec1  a // angle\n)\n{\n    a = atan(sp.y, sp.x);\n    r = length(sp);\n}\n\n//----RAYCAST----\nvec3 screen_to_ray\n(\n      in v2 p  // point on the screen (-1, 1)\n    , in m3 C  // camera transform\n    , in v1 ft // FOV tangent\n)\n{\n    return normalize(C*vec3(p, 1.0 / ft));\n}\n\n// w component has 1.0 if ray is in front of the camera, -1.0 otherwise\nv3 ray_to_screen\n(\n      in v3 v  // ray direction\n    , in m3 C  // camera transform\n    , in v1 ft // FOV tangent\n)\n{\n    v3 p = v*C;\n    return vec3(p.xy / (p.z * ft), sign(p.z));\n}\n\nvoid basis_from_angles\n(\n       in v3 a, //angles\n      out v3 f // forward direction\n    , out v3 u // up direction\n    , out v3 r // right direction\n)\n{\n    const v3 br = vec3(1.0, 0.0, 0.0); // base right\n    const v3 bf = vec3(0.0, 0.0, 1.0); // base forward\n    const v3 bu = vec3(0.0, 1.0, 0.0); // base up\n    \n    m3 rt  = rotationZ(a.z) * rotationY(a.y) * rotationX(a.x); // rotation\n\n    f = rt * bf;\n    u = rt * bu;\n    r = rt * br;\n}\n\nvec3 ray_looking_at\n(\n    in v2 p, // point on the screen (-1, 1)\n    in v3 o, // camera origin\n    in v3 t, // camera target\n    in v3 u, // up\n    in v1 ft // FOV tangent\n)\n{\n    vec3 ww = normalize(from_to(o, t));\n    vec3 uu = normalize(cross(ww, u));\n    vec3 vv = normalize(cross(uu, ww));\n    \n\t// create view ray\n    return normalize(-p.x*uu + p.y*vv + ww / ft);\n}\n\nv1 angular_pixel_size\n(\n      in v2 s  // screen size\n    , in v1 ft // FOV tangent\n)\n{\n    return 2.0 * ft / s.y;\n}\n\n// returns half the distance between intersection points\nfloat intersect_sphere\n(\n       in vec3 ro // ray origin\n    ,  in vec3 rd // ray direction, normalized\n    ,  in vec3 sc // sphere center\n    ,  in vec1 sr // sphere radius\n    ,  in vec1 px // pixel size\n    , out vec1 t1 // t-value 1, signed distance to the first intersection point\n    , out vec1 t2 // t-value 2, signed distance to the second intersection point\n    , out vec3 p1 // point 1, 1st intersection point (closest in the positive direction)\n    , out vec3 p2 // point 2, 2nd intersection point (farthest in the positive direction)\n)\n{\n    vec3 co; // from sphere's center to ray's origin\n\tfloat b, c, h; // solving the quadratic equation\n    \n    co = from_to(sc, ro);\n    b = dot(rd, co);\n\tc = dot(co, co) - sr*sr;\n\th = b*b - c;\n\t\n    if (h <= 0.0) // miss\n    {\n        return 0.0;\n    }\n    \n    h = sqrt(h);\n\t\n    t1 = -b - h;\n    t2 = -b + h;\n\n    p1 = ro + t1*rd;\n    p2 = ro + t2*rd;\n    \n    return h;\n}\n\n//returns pixel coverage\nfloat sphere_intersection_normal_aa\n(\n       in vec3 ro // ray origin\n    ,  in vec3 rd // ray direction, normalized\n    ,  in vec3 sc // sphere center\n    ,  in vec1 sr // sphere radius\n    ,  in vec1 ps // pixel size\n    , out vec3 n  // normal vector of the sphere at the nearest intersection point\n)\n{\n    vec3 oc = ro - sc;\n    vec1 b = dot( oc, rd );\n    vec1 c = dot( oc, oc ) - sr*sr;\n    vec1 h2 = b*b - c; // square of the distance between intercestion center and a point\n    \n    vec1 d = sqrt(sat0(sr*sr-h2)) - sr;\n    vec1 d1 = -b - sqrt(sat0(h2)); // distance to the closest point\n    \n    if (d1 <= 0.0)\n        return 0.0;\n    \n    vec1 s = sat0(d/d1);\n    if (s >= ps)     // too far from an intersection\n    \treturn 0.0;\n\n    n = from_to(sc, ro + rd*d1) / sr;\n    return 1.0 - sat0(s/ps); // pixel coverage\n}\n\nfloat intersect_sphere_aa\n(\n       in vec3 ro // ray origin\n    ,  in vec3 rd // ray direction, normalized\n    ,  in vec3 sc // sphere center\n    ,  in vec1 sr // sphere radius\n    ,  in vec1 px // pixel size\n)\n{\n    vec3 _;\n    return sphere_intersection_normal_aa(ro, rd, sc, sr, px, _);\n}\n\nfloat intersect_sphere_for_normals\n(\n       in vec3 ro // ray origin\n    ,  in vec3 rd // ray direction, normalized\n    ,  in vec3 sc // sphere center\n    ,  in vec1 sr // sphere radius\n    ,  in vec1 ps // pixel size\n    , out vec3 n1 // normal vector of the sphere at the nearest intersection point \n    , out vec3 n2 // normal vector of the sphere at the farthest intersection point \n)\n{\n    vec3 oc = ro - sc;\n    vec1 b = dot( oc, rd );\n    vec1 c = dot( oc, oc ) - sr*sr;\n    vec1 h2 = b*b - c; // square of the distance between intercestion center and a point\n    \n    vec1 d = sqrt(sat0(sr*sr-h2)) - sr;\n    vec1 h = sqrt(sat0(h2));\n    vec1 d1 = -b - h; // distance to the closest point\n    \n    if (d1 <= 0.0)\n        return 0.0;\n    \n    vec1 s = sat0(d/d1);\n    if (s >= ps)     // too far from an intersection\n    \treturn 0.0;\n\n    vec1 d2 = -b + h; // distance to the farthest point\n    \n    n1 = from_to(sc, ro + rd*d1) / sr;\n    n2 = from_to(sc, ro + rd*d2) / sr;\n    return 1.0 - sat0(s/ps); // pixel coverage\n}\n\nfloat intersect_billboard_circle\n(\n       in vec3 ro // ray origin\n    ,  in vec3 rd // ray direction, normalized\n    ,  in vec3 c  // center\n    ,  in vec1 r  // radius\n    ,  in vec1 ts // transition size, size of the transition of the returned value\n    , out vec3 p  // intersection point\n)\n{\n    //oc - ray origin to circle center\n    //oi - ray origin to intersection\n    //ci - circle center to intersection\n    //o  - offset from the circle edge\n    \n    vec3  oc = from_to(ro, c);\n    vec3  oi = rd * vsqr(oc) / dot(rd, oc);\n    vec3  ci = from_to(oc, oi);\n    float ci_sqr = vsqr(ci);\n    float r_sqr = sqr(r);\n    if (ci_sqr > r_sqr)\n    \treturn 0.0;\n    \n    p = ro + oi;\n    return 1. - smoothstep(1. - ts, 1.0, sqrt(ci_sqr / r_sqr));\n}\n\nfloat intersect_billboard_circle\n(\n     in vec3 ray_direction,\n     in vec3 circle_direction, \n     in vec1 cosine_width\n)\n{\n     vec3 rd = ray_direction;\n     vec3 cd = circle_direction;\n    float w  = cosine_width;\n    \n    return sat((dot(rd, cd) + w - 1.) / w);\n}\n\n//----SHAPES 2D----\nvec1 circle\n(\n      in vec2 sp // screen point\n    , in vec2 c  // center\n    , in vec1 r  // radius\n    , in vec1 ps // pixel size\n)\n{\n    return sstep(vsqr(from_to(c, sp)), sqr(r), sqr(ps));\n}\n\n//----NOISE----\n#if 1\nfloat noise(in vec3 pos, in sampler2D channel)\n{\n  #if 0\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( channel, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n  #else\n    ivec3 p = ivec3(floor(pos));\n    vec3 f = fract(pos);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy + ivec2(37,17)*p.z;\n\tvec2 rgA = texelFetch( channel, (uv+ivec2(0,0))&255, 0 ).yx;\n    vec2 rgB = texelFetch( channel, (uv+ivec2(1,0))&255, 0 ).yx;\n    vec2 rgC = texelFetch( channel, (uv+ivec2(0,1))&255, 0 ).yx;\n    vec2 rgD = texelFetch( channel, (uv+ivec2(1,1))&255, 0 ).yx;\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                   mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, f.z );\n  #endif\n}\n#else\nfloat noise( in vec3 pos, in sampler2D channel )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(pos);\n    vec3 Pf = pos - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n#endif\nfloat ridged_noise(in vec3 p, in sampler2D channel) { return abs(from01to11(noise(p, channel))); }\nfloat mixed_noise(in vec3 p, in sampler2D channel) \n{ \n    v1 n = noise(p, channel);\n    v1 rn = abs(from01to11(n));\n    return n * rn; \n}\n\nconst mat3 fbm_octave_rotation = \n    mat3( 0.00,  0.80,  0.60,\n         -0.80,  0.36, -0.48,\n         -0.60, -0.48,  0.64 );\n\nfloat fbm\n(\n     vec3 point,\n      int octaves,\n    float lacunarity,\n    float gain, \n    in sampler2D channel\n)\n{\n    float\n    total = 0.0,\n    amplitude = gain,\n    sum_amplitude = 0.0\n    ;\n    \n    vec3 p = point;\n    \n\tfor (int i = 0; i < octaves; i++) \n    {\n\t\ttotal += noise(p, channel) * amplitude;\n\t\tp = fbm_octave_rotation * p * lacunarity;\n        sum_amplitude += amplitude;\n\t\tamplitude *= gain;\n\t}\n    \n\treturn total / sum_amplitude;\n}\n\nfloat ridged_fbm\n(\n     vec3 point,\n      int octaves,\n    float lacunarity,\n    float gain, \n    in sampler2D channel\n) \n{\n    float\n    total = 0.0,\n    amplitude = gain,\n    sum_amplitude = 0.0\n    ;\n    \n    vec3 p = point;\n    \n\tfor (int i = 0; i < octaves; i++) \n    {\n\t\ttotal += ridged_noise(p, channel) * amplitude;\n\t\tp = fbm_octave_rotation * p * lacunarity;\n        sum_amplitude += amplitude;\n\t\tamplitude *= gain;\n\t}\n    \n\treturn total / sum_amplitude;\n}","name":"Common","description":"","type":"common"}]}