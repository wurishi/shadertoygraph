{"ver":"0.1","info":{"id":"432XWV","date":"1711105690","viewed":59,"name":"landscape-2024","username":"leborgnekevin","description":"landscape go vrouuum","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["newlandscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.004;\nconst float EPSILON = 0.005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nvec2 hash22b(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return 2.0 * fract((p3.xx+p3.yz)*p3.zy) - 1.0;\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    float a = dot(hash22b(ip+vec2(0,0)), fp-vec2(0,0));\n    float b = dot(hash22b(ip+vec2(1,0)), fp-vec2(1,0));\n    float c = dot(hash22b(ip+vec2(0,1)), fp-vec2(0,1));\n    float d = dot(hash22b(ip+vec2(1,1)), fp-vec2(1,1));\n\n    vec2 t = smoothstep(vec2(0), vec2(1), fp);\n    float res =mix(mix(a, b, t.x),\n                   mix(c, d, t.x),\n                   t.y);\n    return 0.5 + 0.5 * res;\n}\n\nfloat fbm(vec2 p)\n{\n    float res = 0.0;\n    float amp = 0.9;\n    float freq = 0.9;\n    for (int i = 0; i < 10; ++i)\n    {\n        res += amp * noise(freq*p);\n        //p *= rot2d(0.37);\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nSurface sdFloor(vec3 p) {\n    vec3 col;\n    float d = p.y + 2.;\n\n    // Add some noise\n    d += 2. * fbm(p.xz * 0.5);\n    d += 15. * fbm(p.xz * 0.08);\n    d += 15. * fbm(p.xz * 0.08);\n\n    vec4 texColor = texture(iChannel0, vec2(p.x, p.z));\n    col = texColor.rgb;\n\n    return Surface(d, col);\n}\nSurface sdSea(vec3 p, vec3 col) {\n    float d = p.y + 18.0;\n   d += 0.003 * sin(10.0 * p.x+iTime) *cos(10.0 * p.z +iTime)+ 0.14;\n    col = vec3(0.0, 0.0, 0.7);\n    // col = mix(vec3(0.0, 0.2, 0.5), vec3(0.0, 0.6, 1.0), smoothstep(0., 3.0, p.y*0.5));\n    // col = mix(col, vec3(0.0, 0.8, 1.0), smoothstep(0., 100.0, p.y));\n    return Surface(d, col);\n\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface sdPandora(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    vec4 texColor = texture(iChannel1, vec2(p.x, p.z));\n    col = texColor.rgb;\n    return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n\n    Surface floor = sdFloor(p + vec3(0., -4., 0.)); // Floor\n    Surface sea = sdSea(p + vec3(0., 10., 0.), vec3(0.0, 0.0, 0.5)); // Sea\n\n    // Combine the floor and sea surfaces\n    Surface combinedSurface = opUnion(floor, sea);\n\n    // Add the Pandora sphere\n    float t = iTime / 3.; // Timer\n    vec3 sphereOffset = vec3(-5.0 + 5.0 * sin(iTime / 24.0), -10.0 + 5.0 * cos(iTime / 24.0), -20.0); // Offset the sphere position with timer\n    combinedSurface = opUnion(combinedSurface, sdPandora(p, .5, sphereOffset, vec3(1.0, 1.0, 0.0))); // Pandora sphere\n\n    // Add the Giant Blue sphere\n\n    return combinedSurface;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvoid drawStars(vec2 uv, inout vec3 background) {\n    float threshold = 0.998; // density\n    float randValue = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n\n    if(randValue > threshold) {\n        vec3 starColor = vec3(1.0);\n\n        float sizeRand = fract(sin(dot(uv, vec2(4.789, 9.123))) * 7543.6542);\n        float starSize = mix(.5, 3.0, sizeRand);\n\n        background += starColor / (starSize * starSize);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   vec3 rd = normalize(vec3(uv, -1));\n\n\n  vec3 topColor = vec3(1., 0.25, 0.0); // Color at the top of the gradient (orange)\n  vec3 bottomColor = vec3(0.000,0.000,0.000); // Color at the bottom of the gradient (black)\n  vec3 backgroundColor = mix(bottomColor, topColor, rd.y );\n  vec3 fogColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, -21., -2.);\n  // ray origin that represents camera position\n\n\n\n\n\n\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n\n  rd *= rotateY(mouse.x) * rotateX(mouse.y); // apply yaw and pitch\nSurface co = rayMarch(ro, rd); // closest object\n\nif (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n    drawStars(uv, col);\n} else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(10., 0., 10.);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\n    float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n\n    col = dif * co.col * softShadow;\n\n    // Check if the color of the closest object matches the color of the sea\n    vec3 seaColor = vec3(0.0, 0.0, .70); // Replace with the actual color of the sea\n    if (length(co.col - seaColor) < 0.01) {\n        // Calculate the reflected ray\n        vec3 reflection = reflect(rd, normal);\n\n        // Perform a second ray march along the reflected ray\n        float t2 = 0.0;\n        for(int i=0; i<256; i++) {\n            vec3 p2 = p + t2*reflection;\n            Surface co2 = rayMarch(p2, reflection);\n            if(co2.sd < 0.00001 || t2>5.0) break;\n            t2 += co2.sd;\n        }\n\n        // If the second ray march hit something, add the reflection color\n        if(t2 < 5.0) {\n            vec3 reflectionColor = vec3(1.0, 1.0, 1.0); // Color of the reflection\n            float reflectionStrength = 0.5; // Strength of the reflection\n            col = mix(col, reflectionColor, reflectionStrength);\n        }\n    }\n}\n\nfloat fogHeightStart = 0.0; // Set the starting height of the fog\nfloat fogHeightEnd = 2.0; // Set the ending height of the fog\nfloat fogDensity = 0.00004; // Set the desired fog density\n\nfloat fogFactor = .5 - exp(-fogDensity * co.sd * co.sd * co.sd);\nfogFactor = clamp(fogFactor, 0.0, 1.0); // Clamp the fog factor between 0 and 1\n\nvec3 p; // Declare the variable 'p' as a vector or structure\nif (p.y > fogHeightStart && p.y < fogHeightEnd) {\n    fogFactor = 0.0; // Disable fog within the specified height range\n}\n\ncol = mix(col, fogColor, fogFactor); // Apply fog using the fog color\ncol = pow(col, vec3(1.0/2.2)); // Gamma correction\nfragColor = vec4(col, 1.0); }","name":"Image","description":"","type":"image"}]}