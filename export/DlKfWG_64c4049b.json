{"ver":"0.1","info":{"id":"DlKfWG","date":"1702482080","viewed":317,"name":"Porygon2","username":"SL0ANE","description":"你可以通过拖动鼠标来旋转多边兽。\n\n晚点给死鸭子做戏法空间","likes":25,"published":1,"flags":32,"usePreview":1,"tags":["procedural","3d","raymarching","distancefield","sdf","cartoon","pokemon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define MAX_DISTANCE 1024.0\n# define MIN_STEP 64\n# define MAX_STEP 256\n# define BACKGROUND_COLOR vec4(0.28, 0.24, 0.32, 1.0)\n# define SLOANE_COLOR vec4(0.98, 0.52, 0.52, 1.0)\n\n# define LIGHT_DIRECTION vec3(-2.0, -4.0, 3.0)\n# define LIGHT_COLOR vec4(1.0, 0.98, 0.94, 1.0)\n# define LIGHT_THRESHOLD 0.28\n# define LIGHT_STRENGTH 1.0\n# define LIGHT_SPREAD 1.2\n# define SHADOW_COLOR vec4(0.8, 0.60, 0.84, 1.0)\n# define DIFFUSE_STEP 2.0\n# define SPECULAR_STEP 2.0\n\n# define BODY_SHAPE vec3(1.36, 1.0, 1.55)\n# define HEAD_SHAPE vec3(1.0, 0.874, 1.0)\n# define NECK_THICKNESS 0.28\n# define EYE_SIZE vec3(0.36, 0.42, 0.38)\n# define SURFACE_OUTLINE 0.03\n# define EYEBALL_SIZE vec3(0.09, 0.15, 0.1)\n# define EYE_HIGHLIGHT_SIZE vec3(0.03, 0.05, 0.03)\n# define BEAK_SHAPE vec3(0.5, 0.24, 1.6)\n# define HAND_FRONT_SHAPE vec3(0.56, 0.56, 1.25)\n# define HAND_BACK_SHAPE vec3(0.44, 0.44, 1.25)\n# define HAND_DISTANCE vec3(0.0, 0.0, 0.3)\n# define HAND_MIX 0.2\n# define BELLY_SIZE vec3(1.08, 1.08, 1.8)\n# define TAIL_FRONT_SHAPE vec3(0.18, 0.18, 0.8)\n# define TAIL_BACK_SHAPE vec3(0.36, 0.36, 1.08)\n# define TAIL_DISTANCE vec3(0.0, 0.0, 1.8)\n# define TAIL_MIX 0.2\n\n# define IDLE_SPEED 1.5\n# define FLOAT_STRENGTH 0.125\n# define HAND_WAVE_ANGLE 16.0 / 180.0 * PI\n# define PROYGEN_ORIGIN vec3(0.0, -1.0, 16.0)\n\n# define BODY_COLOR vec4(223.0, 87.0, 111.0, 255.0) / 255.0\n# define BEAK_COLOR vec4(114.0, 184.0, 220.0, 255.0) / 255.0\n# define EYE_COLOR vec4(255.0, 255.0, 255.0, 255.0) / 255.0\n# define OUTLINE_COLOR vec4(64, 32, 32, 255.0) / 255.0\n\n# define EYE_ANGLE 36.0 / 180.0 * PI\n# define EYEBALL_ANGLE -32.0 / 180.0 * PI\n# define BELLY_ANGLE 4.0 / 180.0 * PI\n# define TAIL_ANGLE -45.0 / 180.0 * PI\n\n# define OUTLINE_STRENGTH 0.06\n# define OUTLINE_THRESHOLD 1.0\n\n// Pre\nfloat sceneMap(vec3 point);\nvec4 quaternionMul(vec4 left, vec4 right);\n\n// Camera Config\nfloat cameraFov = 60.0f;\n\n// Bone\n\nvec3 positionLocal_Root = vec3(0.0, -1.0, 16.0);\nvec4 rotationLocal_Root = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Root;\nvec4 rotationWorld_Root;\n\nvec3 positionLocal_Head = vec3(0.0, 2.42, 1.04);\nvec4 rotationLocal_Head = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Head;\nvec4 rotationWorld_Head;\n\nvec3 positionLocal_Neck = vec3(0.0, 0.0, 0.5);\nvec3 positionWorld_Neck;\n\nvec3 positionLocal_LeftEye = vec3(-0.66, 0.025, 0.34);\nvec4 rotationLocal_LeftEye = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_LeftEye;\nvec4 rotationWorld_LeftEye;\n\nvec3 positionLocal_LeftEyeball = vec3(-0.18, -0.12, 0.2);\nvec4 rotationLocal_LeftEyeball = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_LeftEyeball;\nvec4 rotationWorld_LeftEyeball;\n\nvec3 positionLocal_LeftEyeHighlight = vec3(0.01, 0.0, 0.02);\nvec4 rotationLocal_LeftEyeHighlight = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_LeftEyeHighlight;\nvec4 rotationWorld_LeftEyeHighlight;\n\nvec3 positionLocal_RightEye = vec3(0.66, 0.025, 0.34);\nvec4 rotationLocal_RightEye = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_RightEye;\nvec4 rotationWorld_RightEye;\n\nvec3 positionLocal_RightEyeball = vec3(0.18, -0.12, 0.2);\nvec4 rotationLocal_RightEyeball = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_RightEyeball;\nvec4 rotationWorld_RightEyeball;\n\nvec3 positionLocal_RightEyeHighlight = vec3(-0.01, 0.0, 0.02);\nvec4 rotationLocal_RightEyeHighlight = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_RightEyeHighlight;\nvec4 rotationWorld_RightEyeHighlight;\n\nvec3 positionLocal_Beak = vec3(0.0, -0.2, 1.0);\nvec4 rotationLocal_Beak = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Beak;\nvec4 rotationWorld_Beak;\n\nvec3 positionLocal_LeftHand = vec3(-1.55, -0.36, 0.0);\nvec4 rotationLocal_LeftHand = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_LeftHand;\nvec3 positionWorld_LeftFrontHand;\nvec3 positionWorld_LeftBackHand;\nvec4 rotationWorld_LeftHand;\n\nvec3 positionLocal_RightHand = vec3(1.55, -0.36, 0.0);\nvec4 rotationLocal_RightHand = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_RightHand;\nvec3 positionWorld_RightFrontHand;\nvec3 positionWorld_RightBackHand;\nvec4 rotationWorld_RightHand;\n\nvec3 positionLocal_Belly = vec3(0.0, -0.5, 0.0);\nvec4 rotationLocal_Belly = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Belly;\nvec4 rotationWorld_Belly;\n\nvec3 positionLocal_Tail = vec3(0.0, 0.9, -1.6);\nvec4 rotationLocal_Tail = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Tail;\nvec3 positionWorld_FrontTail;\nvec3 positionWorld_BackTail;\nvec4 rotationWorld_Tail;\n\n\n// Util\nvec3 getNormal(vec3 point)\n{\n    vec3 deltaX = vec3(TOLERANCE, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, TOLERANCE, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, TOLERANCE);\n    \n    float x = sceneMap(point + deltaX) - sceneMap(point - deltaX);\n    float y = sceneMap(point + deltaY) - sceneMap(point - deltaY);\n    float z = sceneMap(point + deltaZ) - sceneMap(point - deltaZ);\n    \n    return normalize(vec3(x, y, z));\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for(float t = mint; t < maxt;)\n    {\n        float h = sceneMap(ro + rd * t);\n        if(h < TOLERANCE)\n            return 0.0;\n        res = min(res, k * h/t);\n        t += h;\n    }\n    return res;\n}\n\n// Shape\nfloat sdSphere(vec3 p, vec3 sdf_pos, float sdf_rad)\n{\n    return distance(p, sdf_pos) - sdf_rad;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 sdf_pos, vec4 sdf_rot, vec3 sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    transPoint = rotatePoint(transPoint, vec3(0), quaternionInverse(sdf_rot));\n    float k0 = length(transPoint / sdf_rad);\n    float k1 = length(transPoint / (sdf_rad * sdf_rad));\n    return k0 * (k0-1.0) / k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 sdf_pos_0, vec3 sdf_pos_1, float sdf_rad)\n{\n    vec3 pa = p - sdf_pos_0, ba = sdf_pos_1 - sdf_pos_0;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length( pa - ba*h ) - sdf_rad;\n}\n\n// Project\n\nfloat sceneMap(vec3 point)\n{\n    float distance = 0.0;\n    distance = smin(min(min(min(min(min(\n    sdEllipsoid(point, positionWorld_Root, rotationWorld_Root, BODY_SHAPE),\n    smin(sdEllipsoid(point, positionWorld_RightFrontHand, rotationWorld_RightHand, HAND_FRONT_SHAPE), sdEllipsoid(point, positionWorld_RightBackHand, rotationWorld_RightHand, HAND_BACK_SHAPE), HAND_MIX)),\n    smin(sdEllipsoid(point, positionWorld_LeftFrontHand, rotationWorld_LeftHand, HAND_FRONT_SHAPE), sdEllipsoid(point, positionWorld_LeftBackHand, rotationWorld_LeftHand, HAND_BACK_SHAPE), HAND_MIX)),\n    smin(sdEllipsoid(point, positionWorld_FrontTail, rotationWorld_Tail, TAIL_FRONT_SHAPE), sdEllipsoid(point, positionWorld_BackTail, rotationWorld_Tail, TAIL_BACK_SHAPE), TAIL_MIX)),\n    sdEllipsoid(point, positionWorld_Beak, rotationWorld_Beak, BEAK_SHAPE)),\n    sdEllipsoid(point, positionWorld_Head, rotationWorld_Head, HEAD_SHAPE)),\n    sdCapsule(point, positionWorld_Head, positionWorld_Neck, NECK_THICKNESS), 0.25\n    );\n    return distance;\n}\n\nvoid march(vec3 start, vec3 ray, inout vec3 pos, inout vec3 normal, inout float len, inout int outline)\n{\n    len = 0.0;\n    outline = 0;\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    int hit = 0;\n    float lenWhenHit;\n    float disWhenHit;\n    int stepCount = 0;\n    \n    while(len < MAX_DISTANCE && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        \n        dis = sceneMap(curPos);\n        pos = curPos;\n        \n        if(dis <= TOLERANCE)\n        {\n            normal = getNormal(curPos);\n            if(hit == 2)\n            {\n                if(mix(0.0, TOLERANCE + OUTLINE_STRENGTH, clamp((len - lenWhenHit) / OUTLINE_THRESHOLD, 0.0, 1.0)) >= disWhenHit) outline = 1;\n            }\n            else if(hit == 1)\n            {\n                // if(disWhenHit <= dis + OUTLINE_STRENGTH) outline = 1;\n            }\n            return;\n        }\n        \n        if(hit == 0)\n        {\n            // 第一次到范围内\n            if(dis <= TOLERANCE + OUTLINE_STRENGTH) hit = 1;\n            lenWhenHit = len;\n            disWhenHit = dis;\n        }\n        else if(hit == 1)\n        {\n            if(dis <= TOLERANCE + OUTLINE_STRENGTH)\n            {\n                // 持续在描边范围内，记录最小距离\n                if(disWhenHit > dis)\n                {\n                    disWhenHit = dis;\n                    lenWhenHit = len;\n                }\n            }\n            else hit = 2;\n        }\n        \n        len += dis;\n        stepCount += 1;\n    }\n    normal = getNormal(curPos);\n    if(hit == 2)\n    {\n        if(mix(0.0, TOLERANCE + OUTLINE_STRENGTH, clamp((len - lenWhenHit) / OUTLINE_THRESHOLD, 0.0, 1.0)) >= disWhenHit) outline = 1;\n    }\n    return;\n}\n\nvoid sceneBaseMaterial(vec3 point, out vec4 baseColor, out int materialIndex)\n{\n    if(min(sdEllipsoid(point, positionWorld_LeftEyeHighlight, rotationWorld_LeftEyeHighlight, EYE_HIGHLIGHT_SIZE), sdEllipsoid(point, positionWorld_RightEyeHighlight, rotationWorld_RightEyeHighlight, EYE_HIGHLIGHT_SIZE)) <= TOLERANCE)\n    {\n        // 眼高光\n        baseColor = EYE_COLOR;\n        materialIndex = 1;\n        return;\n    }\n    if(min(sdEllipsoid(point, positionWorld_LeftEyeball, rotationWorld_LeftEyeball, EYEBALL_SIZE), sdEllipsoid(point, positionWorld_RightEyeball, rotationWorld_RightEyeball, EYEBALL_SIZE)) <= TOLERANCE)\n    {\n        // 眼珠\n        baseColor = OUTLINE_COLOR;\n        materialIndex = 0;\n        return;\n    }\n    if(min(sdEllipsoid(point, positionWorld_LeftEye, rotationWorld_LeftEye, EYE_SIZE), sdEllipsoid(point, positionWorld_RightEye, rotationWorld_RightEye, EYE_SIZE)) <= TOLERANCE)\n    {\n        // 眼白\n        baseColor = EYE_COLOR;\n        materialIndex = 1;\n        return;\n    }\n    if(min(sdEllipsoid(point, positionWorld_LeftEye, rotationWorld_LeftEye, EYE_SIZE + vec3(SURFACE_OUTLINE)), sdEllipsoid(point, positionWorld_RightEye, rotationWorld_RightEye, EYE_SIZE + vec3(SURFACE_OUTLINE))) <= TOLERANCE)\n    {\n        // 眼框\n        baseColor = OUTLINE_COLOR;\n        materialIndex = 0;\n        return;\n    }\n    if(min(sdEllipsoid(point, positionWorld_Beak, rotationWorld_Beak, BEAK_SHAPE), \n       smin(sdEllipsoid(point, positionWorld_FrontTail, rotationWorld_Tail, TAIL_FRONT_SHAPE), sdEllipsoid(point, positionWorld_BackTail, rotationWorld_Tail, TAIL_BACK_SHAPE), TAIL_MIX))\n    <= TOLERANCE)\n    {\n        // 蓝色但不应用高光\n        baseColor = BEAK_COLOR;\n        materialIndex = 2;\n        return;\n    }\n    if(min(smin(sdEllipsoid(point, positionWorld_RightFrontHand, rotationWorld_RightHand, HAND_FRONT_SHAPE), sdEllipsoid(point, positionWorld_RightBackHand, rotationWorld_RightHand, HAND_BACK_SHAPE), HAND_MIX),\n           smin(sdEllipsoid(point, positionWorld_LeftFrontHand, rotationWorld_LeftHand, HAND_FRONT_SHAPE), sdEllipsoid(point, positionWorld_LeftBackHand, rotationWorld_LeftHand, HAND_BACK_SHAPE), HAND_MIX))\n    <= TOLERANCE)\n    {\n        // 蓝色\n        baseColor = BEAK_COLOR;\n        materialIndex = 0;\n        return;\n    }\n    if(sdEllipsoid(point, positionWorld_Belly, rotationWorld_Belly, BELLY_SIZE) <= TOLERANCE)\n    {\n        baseColor = BEAK_COLOR;\n        materialIndex = 0;\n        return;\n    }\n    if(sdEllipsoid(point, positionWorld_Belly, rotationWorld_Belly, BELLY_SIZE + vec3(SURFACE_OUTLINE)) <= TOLERANCE)\n    {\n        baseColor = OUTLINE_COLOR;\n        materialIndex = 0;\n        return;\n    }\n    \n    baseColor = BODY_COLOR;\n    materialIndex = 0;\n    return;\n}\n\nvoid updateBone()\n{\n    float angle;\n    \n    // 根\n    positionWorld_Root = positionLocal_Root;\n    angle = -PI / 32.0 + PI / 16.0 * (1.0 + 0.75 * sin(IDLE_SPEED * 0.5 * PI * iTime)) * sin(IDLE_SPEED * PI * iTime);\n    // angle = 0.0; \n    rotationLocal_Root = quaternionMul(vec4(sin(angle / 2.0), 0.0, 0.0, cos(angle / 2.0)), rotationLocal_Root);\n    angle = 1.0 * iTime;\n    angle = PI * 1.2; \n    rotationLocal_Root = quaternionMul(load(POINTER_ROT), quaternionMul(vec4(0.0, sin(angle / 2.0), 0.0, cos(angle / 2.0)), rotationLocal_Root));\n    rotationWorld_Root = rotationLocal_Root;\n    positionLocal_Root = PROYGEN_ORIGIN + FLOAT_STRENGTH * vec3(0.0, sin(IDLE_SPEED * 0.5 * PI * iTime), 0.0);\n    positionWorld_Root = positionLocal_Root ;\n    \n    // 头\n    positionWorld_Head = rotatePoint(positionLocal_Head + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    rotationWorld_Head = quaternionMul(rotationWorld_Root, rotationLocal_Head);\n    \n    // 鼠\n    positionWorld_Neck = rotatePoint(positionLocal_Neck + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    \n    // 左眼\n    rotationLocal_LeftEye = quaternionMul(vec4(sin(EYE_ANGLE / 2.0), 0.0, 0.0, cos(EYE_ANGLE / 2.0)), vec4(0.0, 0.0, 0.0, 1.0));\n    positionWorld_LeftEye = rotatePoint(positionLocal_LeftEye + positionWorld_Head, positionWorld_Head, rotationWorld_Head);\n    rotationWorld_LeftEye = quaternionMul(rotationWorld_Head, rotationLocal_LeftEye);\n    \n    rotationLocal_LeftEyeball = quaternionMul(vec4(sin(EYEBALL_ANGLE / 2.0), 0.0, 0.0, cos(EYEBALL_ANGLE / 2.0)), vec4(0.0, 0.0, 0.0, 1.0));\n    positionWorld_LeftEyeball = rotatePoint(positionLocal_LeftEyeball + positionWorld_LeftEye, positionWorld_LeftEye, rotationWorld_LeftEye);\n    rotationWorld_LeftEyeball = quaternionMul(rotationWorld_LeftEye, rotationLocal_LeftEyeball);\n    \n    positionWorld_LeftEyeHighlight = rotatePoint(positionLocal_LeftEyeHighlight + positionWorld_LeftEyeball, positionWorld_LeftEyeball, rotationWorld_LeftEyeball);\n    rotationWorld_LeftEyeHighlight = quaternionMul(rotationWorld_LeftEyeball, rotationLocal_LeftEyeHighlight);\n    \n    // 右眼\n    rotationLocal_RightEye = quaternionMul(vec4(sin(EYE_ANGLE / 2.0), 0.0, 0.0, cos(EYE_ANGLE / 2.0)), vec4(0.0, 0.0, 0.0, 1.0));\n    positionWorld_RightEye = rotatePoint(positionLocal_RightEye + positionWorld_Head, positionWorld_Head, rotationWorld_Head);\n    rotationWorld_RightEye = quaternionMul(rotationWorld_Head, rotationLocal_RightEye);\n    \n    rotationLocal_RightEyeball = quaternionMul(vec4(sin(EYEBALL_ANGLE / 2.0), 0.0, 0.0, cos(EYEBALL_ANGLE / 2.0)), vec4(0.0, 0.0, 0.0, 1.0));\n    positionWorld_RightEyeball = rotatePoint(positionLocal_RightEyeball + positionWorld_RightEye, positionWorld_RightEye, rotationWorld_RightEye);\n    rotationWorld_RightEyeball = quaternionMul(rotationWorld_RightEye, rotationLocal_RightEyeball);\n    \n    positionWorld_RightEyeHighlight = rotatePoint(positionLocal_RightEyeHighlight + positionWorld_RightEyeball, positionWorld_RightEyeball, rotationWorld_RightEyeball);\n    rotationWorld_RightEyeHighlight = quaternionMul(rotationWorld_RightEyeball, rotationLocal_RightEyeHighlight);\n    \n    // 喙\n    positionWorld_Beak = rotatePoint(positionLocal_Beak + positionWorld_Head, positionWorld_Head, rotationWorld_Head);\n    rotationWorld_Beak = quaternionMul(rotationWorld_Head, rotationLocal_Beak);\n    \n    // 左手\n    angle = HAND_WAVE_ANGLE * sin(IDLE_SPEED * PI * iTime + PI / 4.0);\n    rotationLocal_LeftHand = vec4(sin(angle / 2.0), 0.0, 0.0, cos(angle / 2.0));\n    rotationWorld_LeftHand = quaternionMul(rotationWorld_Root, rotationLocal_LeftHand);\n    positionWorld_LeftHand = rotatePoint(positionLocal_LeftHand + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    positionWorld_LeftFrontHand = rotatePoint(positionWorld_LeftHand + HAND_DISTANCE / 2.0, positionWorld_LeftHand, rotationWorld_LeftHand);\n    positionWorld_LeftBackHand = rotatePoint(positionWorld_LeftHand - HAND_DISTANCE / 2.0, positionWorld_LeftHand, rotationWorld_LeftHand);\n    \n    // 右手\n    angle = HAND_WAVE_ANGLE * sin(IDLE_SPEED * PI * iTime + PI / 4.0 * 5.0);\n    rotationLocal_RightHand = vec4(sin(angle / 2.0), 0.0, 0.0, cos(angle / 2.0));\n    rotationWorld_RightHand = quaternionMul(rotationWorld_Root, rotationLocal_RightHand);\n    positionWorld_RightHand = rotatePoint(positionLocal_RightHand + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    positionWorld_RightFrontHand = rotatePoint(positionWorld_RightHand + HAND_DISTANCE / 2.0, positionWorld_RightHand, rotationWorld_RightHand);\n    positionWorld_RightBackHand = rotatePoint(positionWorld_RightHand - HAND_DISTANCE / 2.0, positionWorld_RightHand, rotationWorld_RightHand);\n    \n    // 肚子\n    rotationLocal_Belly = quaternionMul(vec4(sin(BELLY_ANGLE / 2.0), 0.0, 0.0, cos(BELLY_ANGLE / 2.0)), vec4(0.0, 0.0, 0.0, 1.0));\n    positionWorld_Belly = rotatePoint(positionLocal_Belly + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    rotationWorld_Belly = quaternionMul(rotationWorld_Root, rotationLocal_Belly);\n    \n    // 尾巴\n    rotationLocal_Tail = quaternionMul(vec4(sin(TAIL_ANGLE / 2.0), 0.0, 0.0, cos(TAIL_ANGLE / 2.0)), vec4(0.0, 0.0, 0.0, 1.0));\n    rotationWorld_Tail = quaternionMul(rotationWorld_Root, rotationLocal_Tail);\n    positionWorld_Tail = rotatePoint(positionLocal_Tail + positionWorld_Root, positionWorld_Root, rotationWorld_Root);\n    positionWorld_FrontTail = rotatePoint(positionWorld_Tail + TAIL_DISTANCE / 2.0, positionWorld_Tail, rotationWorld_Tail);\n    positionWorld_BackTail = rotatePoint(positionWorld_Tail - TAIL_DISTANCE / 2.0, positionWorld_Tail, rotationWorld_Tail);\n}\n\nvec4 mainLightShading(vec3 lightDir, float rimSpread, float rimThreshold, float strength, vec4 lightColor, vec4 shadowColor, float diffuseStep, float specularStep, vec4 baseColor, int material, vec3 pos, vec3 normal, vec3 view)\n{\n    float smoothness = 0.15;\n    \n    if(material == 1) return baseColor;\n    if(material == 2) smoothness = 0.0;\n    // float lightLevel = min(dot(-normal, lightDir), softshadow(pos, -lightDir, TOLERANCE * 8.0, MAX_DISTANCE, 1024.0));\n    float shodow = clamp(softshadow(pos, -lightDir, TOLERANCE * 64.0, MAX_DISTANCE, 1024.0), 0.0, 1.0 - TOLERANCE / diffuseStep);\n    float lightLevel = min(clamp(dot(-normal, lightDir), 0.0, 1.0), shodow);\n    \n    vec4 diffuse = baseColor * mix(shadowColor, lightColor, multiStep(lightLevel, diffuseStep, 0.0, 0.5)) * strength;\n    \n    vec3 halVec = normalize(mix(lightDir, view, 0.33));\n    vec3 triVec = normalize(mix(lightDir, view, 0.67));\n    \n    float res_0 = dot(halVec, -normal);\n    float res_1 = dot(triVec, -normal);\n    lightLevel = max(pow(clamp(res_0, 0.0, 1.0), pow(2.7, 10.0 * smoothness + 1.0)), pow(clamp(res_1, 0.0, 1.0), pow(2.7, 10.0 * smoothness + 1.0)) * 0.66);\n    \n    // rim和specula融为一体\n    float power = dot(normalize(-normal - dot(-normal, view) * view), normalize(lightDir - dot(lightDir, view) * view));\n    power = clamp(1.0 - 1.0 / (power + rimSpread), 0.0, 1.0);\n    power *= (1.0 - abs(dot(view, normal))) / rimThreshold - 1.0;\n    power = clamp(power, 0.0, 1.0 - TOLERANCE);\n    \n    vec4 specular = lightColor * multiStep(max(lightLevel, power), specularStep, 0.0, 0.0) * shodow * pow(smoothness, 1.25) * strength;\n    \n    return diffuse + specular;\n}\n\nvec4 rimLightShading(vec3 lightDir, float rimSpread, float rimThreshold, float strength, vec4 lightColor, float lightStep, vec4 baseColor, int material, vec3 pos, vec3 normal, vec3 view)\n{\n    float power = dot(normalize(-normal - dot(-normal, view) * view), normalize(lightDir - dot(lightDir, view) * view));\n    power = clamp(1.0 - 1.0 / (power + rimSpread), 0.0, 1.0);\n    power *= (1.0 - abs(dot(view, normal))) / rimThreshold - 1.0;\n    power = clamp(power, 0.0, 1.0 - TOLERANCE);\n    \n    power = multiStep(power, lightStep, 0.0, 0.0);\n    \n    return vec4(mix(baseColor.rgb, baseColor.rgb + power * lightColor.rbg, strength), baseColor.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    updateBone();\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.x;\n    float delta = 1.0 / iResolution.x;\n    float tanFov = tan(cameraFov / 360.0 * PI);\n    vec3 ray = normalize(vec3(uv, 0.5 / tanFov));\n    \n    vec3 pos;\n    vec3 normal;\n    float len;\n    int outline;\n    \n    \n    march(vec3(0.0), ray, pos, normal, len, outline);\n    \n    if(outline > 0)\n    {\n        fragColor = OUTLINE_COLOR;\n        return;\n    }\n    else if(len >= MAX_DISTANCE)\n    {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n        return;\n    }\n    \n    \n    vec4 baseColor;\n    int mIndex;\n    sceneBaseMaterial(pos, baseColor, mIndex);\n    \n    vec4 outputColor = mainLightShading(normalize(LIGHT_DIRECTION), LIGHT_SPREAD, LIGHT_THRESHOLD, LIGHT_STRENGTH, LIGHT_COLOR, SHADOW_COLOR, DIFFUSE_STEP, SPECULAR_STEP, baseColor, mIndex, pos, normal, ray);\n    // outputColor = rimLightShading(normalize(RIMLIGHT_DIRECTION), RIMLIGHT_SPREAD, RIMLIGHT_STRENGTH, RIMLIGHT_COLOR, outputColor, mIndex, pos, normal, ray);\n    // fragColor = vec4(normal, 1.0);\n    fragColor = outputColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define BACKGROUND_COLOR vec4(62.0, 67.0, 80.0, 1.0) / 255.0\n\n# define SPIN_SPEED 0.5\n\n# define CENTER_COLOR vec4(93.0, 96.0, 114.0, 1.0) / 255.0\n# define CENTER_CIRCLE_RANGE 0.2\n# define LOGO_THICKNESS 0.024\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b, vec2 offset)\n{\n    vec2 d = abs(p - offset) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvec4 sceneColor(vec2 p)\n{\n    if(sdCircle(p, CENTER_CIRCLE_RANGE - LOGO_THICKNESS * 1.0) <= TOLERANCE)\n    {\n        if(sdCircle(p, 3.0 * LOGO_THICKNESS) <= TOLERANCE)\n        {\n            if(sdCircle(p, 2.0 * LOGO_THICKNESS) <= TOLERANCE)\n            {\n                return CENTER_COLOR;\n            }\n            return BACKGROUND_COLOR;\n        }\n        \n        if(sdCircle(p, CENTER_CIRCLE_RANGE - LOGO_THICKNESS * 2.0) <= TOLERANCE)\n        {\n            if(sdBox(p, vec2(CENTER_CIRCLE_RANGE, LOGO_THICKNESS / 2.0)) <= TOLERANCE)\n            {\n                return BACKGROUND_COLOR;\n            }\n            \n            if(sdBox(p, vec2(CENTER_CIRCLE_RANGE, CENTER_CIRCLE_RANGE)) <= TOLERANCE)\n            {\n                return CENTER_COLOR;\n            }\n            \n        }\n        \n        \n        return BACKGROUND_COLOR;\n    }\n    \n    if(sdCircle(p, CENTER_CIRCLE_RANGE) <= TOLERANCE)\n    {\n        return CENTER_COLOR;\n    }\n    \n    return BACKGROUND_COLOR;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    float rotate = iTime * SPIN_SPEED;\n    uv = vec2(uv.x * cos(rotate) + uv.y * cos(rotate + PI / 2.0), uv.x * sin(rotate) + uv.y * sin(rotate + PI / 2.0));\n    fragColor = sceneColor(uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 4.0\n# define SENSITIVE 0.33\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x);\n        time = 0.0;\n        curRot = quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0)));\n\n    }\n    else\n    {\n        press = 0.0;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(time / RECOVER_TIME, 0.0, 1.0));\n        time += iTimeDelta;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"# define PI 3.1415926535897932384626433832795\n# define TOLERANCE 0.0001\n\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Util\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\nfloat multiStep(float value, float level, float minValue, float offset)\n{\n    if(level <= 1.0) return 1.0;\n    \n    float curLevel = value * level;\n    float curOffset = floor(curLevel) / (level - 1.0);\n    curLevel = floor(curLevel + mix(offset, 0.0, curOffset));\n    \n    curOffset = curLevel / (level - 1.0);\n    curLevel += mix(minValue, 1.0, curOffset);\n    \n    return curLevel / level;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}","name":"Common","description":"","type":"common"}]}