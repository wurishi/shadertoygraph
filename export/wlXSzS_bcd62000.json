{"ver":"0.1","info":{"id":"wlXSzS","date":"1563349025","viewed":184,"name":"Transcendental Dance","username":"Dain","description":"Making funky graphics from approximate versions of transcendentals rcp, sqrt, rsqrt-- uses relative error compared to GLSL versions to colorize--\n\nApprox fxns from https://github.com/michaldrobot/ShaderFastLibs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sqrt","rcp","rsqrt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Fast transcendentals from https://github.com/michaldrobot/ShaderFastLibs\n\n// Derived from batch testing\n// TODO : Should be improved\n#define IEEE_INT_RCP_CONST_NR0              0x7EF311C2  \n#define IEEE_INT_RCP_CONST_NR1              0x7EF311C3 \n#define IEEE_INT_RCP_CONST_NR2              0x7EF312AC  \n\n// Derived from batch testing\n#define IEEE_INT_SQRT_CONST_NR0             0x1FBD1DF5   \n\n// Biases for global ranges\n// 0-1 or 1-2 specific ranges might improve from different bias\n// Derived from batch testing\n// TODO : Should be improved\n#define IEEE_INT_RCP_SQRT_CONST_NR0         0x5f3759df\n#define IEEE_INT_RCP_SQRT_CONST_NR1         0x5F375A86 \n#define IEEE_INT_RCP_SQRT_CONST_NR2         0x5F375A86  \n\n//\n// Normalized range [0,1] Constants\n//\n#define IEEE_INT_RCP_CONST_NR0_SNORM_01        0x7EEF370B\n#define IEEE_INT_SQRT_CONST_NR0_SNORM_01      0x1FBD1DF5\n#define IEEE_INT_RCP_SQRT_CONST_NR0_SNORM_01   0x5F341A43\nint asint(float a){\n return floatBitsToInt(a);   \n}\nfloat asfloat(int a){\n return intBitsToFloat(a);   \n}\n\nfloat rcpIEEEIntApproximation(float inX, const int inRcpConst)\n{\n\tint x = asint(inX);\n\tx = inRcpConst - x;\n\treturn asfloat(x);\n}\n// Approximate guess using integer float arithmetics based on IEEE floating point standard\nfloat rcpSqrtIEEEIntApproximation(float inX, const int inRcpSqrtConst)\n{\n\tint x = asint(inX);\n\tx = inRcpSqrtConst - (x >> 1);\n\treturn asfloat(x);\n}\n\nfloat fastRcpNR0(float inX)\n{\n\tfloat  xRcp = rcpIEEEIntApproximation(inX, IEEE_INT_RCP_CONST_NR0);\n\treturn xRcp;\n}\nfloat fastRcpNR0_01(float inX)\n{\n\tfloat  xRcp = rcpIEEEIntApproximation(inX, IEEE_INT_RCP_CONST_NR0_SNORM_01);\n\treturn xRcp;\n}\nfloat rcpNewtonRaphson(float inX, float inRcpX)\n{\n\treturn inRcpX * (-inRcpX * inX + 2.0f);\n}\nfloat fastRcpNR1(float inX)\n{\n\tfloat  xRcp = rcpIEEEIntApproximation(inX, IEEE_INT_RCP_CONST_NR1);\n\txRcp = rcpNewtonRaphson(inX, xRcp);\n\treturn xRcp;\n}\nfloat fastRcpSqrtNR0(float inX)\n{\n\tfloat  xRcpSqrt = rcpSqrtIEEEIntApproximation(inX, IEEE_INT_RCP_SQRT_CONST_NR0);\n\treturn xRcpSqrt;\n}\nfloat fastRcpSqrtNR0_01(float inX)\n{\n\tfloat  xRcpSqrt = rcpSqrtIEEEIntApproximation(inX, IEEE_INT_RCP_SQRT_CONST_NR0_SNORM_01);\n\treturn xRcpSqrt;\n}\nfloat sqrtIEEEIntApproximation(float inX, const int inSqrtConst)\n{\n\tint x = asint(inX);\n\tx = inSqrtConst + (x >> 1);\n\treturn asfloat(x);\n}\n\nfloat fastSqrtNR0(float inX)\n{\n\tfloat  xRcp = sqrtIEEEIntApproximation(inX, IEEE_INT_SQRT_CONST_NR0);\n\treturn xRcp;\n}\nfloat sqr(float a){\n    return a;\n}\n//The reference\nfloat get_rsqrt(float a){\n    return (1.0/sqrt(a));\n}\n//The approximation\nfloat get_rsqrt_approx(float a){\n    return (fastRcpSqrtNR0(a));\n}\nvec2 get_rsqrt(vec2 a){\n return vec2(get_rsqrt(a.x), get_rsqrt(a.y));   \n}\nvec2 get_rsqrt_approx(vec2 a){\n return vec2(get_rsqrt_approx(a.x), get_rsqrt_approx(a.y));   \n}\n//The reference\nfloat get_sqrt(float a){\n    return (sqrt(a));\n}\n//The approximation\nfloat get_sqrt_approx(float a){\n    return(fastSqrtNR0(a));\n}\nvec2 get_sqrt(vec2 a){\n return vec2(get_sqrt(a.x), get_sqrt(a.y));   \n}\nvec2 get_sqrt_approx(vec2 a){\n return vec2(get_sqrt_approx(a.x), get_sqrt_approx(a.y));   \n}\n//The reference\nfloat get_rcp(float a){\n    return 1.0/a;\n}\n//The approximation\nfloat get_rcp_approx(float a){\n    return fastRcpNR0(a);\n}\nvec2 get_rcp(vec2 a){\n return vec2(get_rcp(a.x), get_rcp(a.y));   \n}\nvec2 get_rcp_approx(vec2 a){\n return vec2(get_rcp_approx(a.x), get_rcp_approx(a.y));   \n}\n\n\n\nfloat max3(float a, float b, float c){\n    return max(a, max(b,c));\n}\nfloat min3(float a, float b, float c){\n    return min(a, min(b,c));\n}\nfloat mul3(float a, float b, float c){\n    return a*b*c;\n}\nfloat add3(float a, float b, float c){\n    return a+b+c;\n}\nfloat med3(float a, float b, float c){\n\t\treturn max( min(a, b), \n\t\t\t\t\tmin(max(a, b), \n\t\t\t\t\t\tc));\n}\n\nfloat GetV(vec2 reference, vec2 approx){  \n    vec2 relative_error = abs(approx-reference)/reference;  \n    return max(relative_error.x, relative_error.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float music = texture(iChannel0,vec2(0.0,0.0)).r;\n    music *= 0.05;\n    fragCoord += 50.0;//*1000.0;\n   // fragCoord = abs(fragCoord - iResolution.xy*0.5);\n    vec2 uv = fragCoord*abs(sin(iTime*0.01+.10 + music*0.01 ));///iResolution.xy;\n//\tuv.x += pow(music,10.0)*100.0;\n    vec3 col = vec3(0.0,0.0,0.0);\n\n   \n    \n   vec3 sinMove =  15.0*(sin(vec3(0.2+music*sin(iTime*0.033)*0.01, 0.21+music*0.1*sin(iTime*0.15), 0.3)*( iTime*1.0)));// - music*1.0;\n    \n    //vec3 movement = 10.0*(music*(3.0*vec3(0.2, 0.21, 0.3)));;\n    \n    float uvmusic = music;\n    uvmusic = 0.0;\n    vec2 uv1 = uv + uvmusic*2.3;\n    col.x = GetV(get_rsqrt(uv1), get_rsqrt_approx(uv1));\n    vec2 uv2 = uv + uvmusic*3.0;\n    col.y = GetV(get_rcp(uv2), get_rcp_approx(uv2));\n    vec2 uv3 = uv;\n    uv3.y += uvmusic*sin(iTime*0.05)*10.0;\n    col.z = GetV(get_sqrt(uv3), get_sqrt_approx(uv3));\n    \n   // music = clamp(music,0.0,1.0)*1.;\n\n    vec3 weights = vec3(25.0, 15.0, 35.0) + sinMove;\n    col *= weights;\n  #if 1\n    col.x = med3(col.x, col.y, col.z)-min3(col.x, col.y, col.z);\n     col.y = max3(col.x, col.y, col.z)-med3(col.x, col.y, col.z);\n  //  col.x = med3(col.x, col.y, col.z);\n    //col.y = 0.0;//mul3(col.x, col.y, col.z);\n    col.z =mul3(col.x, col.y, col.z)*(4.0+music);// + min3(col.x, col.y, col.z)*music;\n   \n  //  col = mix(col, col.zyx,abs(sin(iTime*0.2)*music));\n\n   #else\n    vec3 o;\n     o.x = med3(col.x, col.y, col.z)-min3(col.x, col.y, col.z);\n     o.y = max3(col.x, col.y, col.z)-med3(col.x, col.y, col.z);\n  //  col.x = med3(col.x, col.y, col.z);\n    //col.y = 0.0;//mul3(col.x, col.y, col.z);\n    o.z =mul3(col.x, col.y, col.z)*4.0;// + min3(col.x, col.y, col.z)*music;\n        col = o;\n   // o.z = max3(col.x, col.y, col.z) -min3(col.x, col.y, col.z);\n #endif\n\n   // col.x*=0.3;\n  //  o = min3(col.x, col.y, col.z)*music;\n    fragColor = vec4((col),1.0);\n}\n","name":"Image","description":"","type":"image"}]}