{"ver":"0.1","info":{"id":"M3fBWB","date":"1728836191","viewed":18,"name":"Cartesian Cross","username":"MackFitz","description":"A morphing, spinning structure based on line segments placed along the XYZ axes. Hold LMB & move around to change view.\nStill learning about shading but had fun with colors. Also went haywire with minifying the code. 1st time I tried smoothmin & mix.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["interactive","shading","animation","rotation","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define RES iResolution\n#define PT iMouse\n#define smin smoothmin\n\n// Signed distance function for a 3D line segment\nfloat sdSeg(in vec3 p, in vec3 a, in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n  float h = max(k - abs(d1 - d2), 0.) / k;\n  return min(d1, d2) - h * h * k * (1. / 4.);\n}\n\nfloat map(vec3 p) {\n  float rAdd = .5 * (1. + cos(-iTime)), \n        r0 = (.25 * (1. - rAdd));\n\n  vec3 aX = vec3(0.), aY = aX, aZ = aX,\n       bX = aX, bY = aX, bZ = aX; // setting default coord vectors for all 3 segments\n  aX.x = .5, aY.y = aX.x, aZ.z = aX.x; // changing the start coordinates for each\n  bX.x = -aX.x, bY.y = -aX.x, bZ.z = -aX.x; // making the end coordinates the opposite of that\n\n\n  float rX = (r0 + abs(p.x) * rAdd) / 2.,\n        rY = (r0 + abs(p.y) * rAdd) / 2.,\n        rZ = (r0 + abs(p.z) * rAdd) / 2., // radii of the line segments\n\n        dX = sdSeg(p, aX, bX) - rX,\n        dY = sdSeg(p, aY, bY) - rY,\n        dZ = sdSeg(p, aZ, bZ) - rZ,\n\n        b = 0.05*(1. - cos(iTime)); // smoothness factor\n\n  return smin(smin(dX, dY, b), dZ, b);\n}\n\nvec3 norm(vec3 p) {\n  float h = 1e-3;\n  vec2 k = vec2(-1, 1);\n  return normalize(\n    k.xyy * map(p + k.xyy * h) +\n    k.yxy * map(p + k.yxy * h) +\n    k.yyx * map(p + k.yyx * h) +\n    k.xxx * map(p + k.xxx * h)\n  );\n}\n\nfloat raymarch(inout vec3 p, vec3 rd) {\n  float dd = 0.0;\n  for (float i = 0.0; i < 100.0; i++) {\n    float d = map(p);\n    if (d < 1e-3 || dd > 5.) break;\n    p += rd * d;\n    dd += d;\n  }\n  return dd;\n}\n\nvec3 render(vec3 p, vec3 rd) {\n  float d = raymarch(p, rd);\n  vec3 col = vec3(0);\n\n  if (d < 5.) {\n    vec3 n = norm(p),\n         lp = vec3(-1, 2, -5),\n         l = normalize(lp - p);\n    float diffuse = clamp(dot(l, n), 0., 1.),\n          reflective = clamp(dot(reflect(rd, n), l), .0, 1.0);\n    col += diffuse + pow(reflective, 8.); // that last number defines the size of light: the smaller, the greater it is\n    col = mix(col, vec3(-1.5,-.5,-.75), .5);\n  } else {\n    col += mix(-vec3(.5, 2.5, 1.25), vec3(1., .02, .03), .5 - rd.z*1.5);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 uv = (fragCoord.xy - .5 * RES.xy) / RES.y;\n\nfloat angleX = PT.z > 0. ? (PT.x / RES.x * 2. - 1.)*PI : 1.75*PI + iTime/5.,\n      angleY = PT.z > 0. ? (PT.y / RES.y * 2. - 1.)*PI*-.5 : cos(-PI + iTime/5.)*-.5,\n      camR = 3.;  // Rotate around the x- and y-axis based on mouse position\nvec3 target = vec3(0.0); // Center of the cube\n\nvec3 ro = vec3(\n  sin(angleX)*cos(angleY),\n  sin(angleY),\n  cos(angleX)*cos(angleY)\n)*camR;\n\n// Calculate the ray direction\nvec3 fwd = normalize(target - ro), // fwd direction\n     right = normalize(cross(vec3(0., 1., 0.), fwd)), // Right direction\n     up = cross(fwd, right), // Up direction\n     rd = normalize(fwd + uv.x * right + uv.y * up); // Ray direction\n\nfloat t = 0.0; // Total distance travelled\nvec3 p = ro, col = render(ro, rd);\nfragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}