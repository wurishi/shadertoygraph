{"ver":"0.1","info":{"id":"ml3czj","date":"1699410423","viewed":32,"name":"messing with ray marching","username":"FrederickAmpsUp","description":"just to mess around and make cool SDFs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AMBIENT vec3(.1)\n\n#define LIGHT_POS vec3(3,5,-3)\n#define LIGHT_COL vec3(1.0)\n\n// Different maps. Uncommenting these will show different components of the final render.\n//#define AO_MAP\n//#define SHADOW_MAP\n//#define LIGHT_MAP\n//#define COLOR_MAP\n//#define NORMAL_MAP\n//#define POS_MAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime; // get time in common without errors\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    MarchParams p = MarchParams(256, 0.0001, 1000.0);\n    Ray r = Ray(vec3(0.0, 1.0, -10.0), rayDir);\n    Material mat;\n    \n    float dist = march(p, r,\n        Interval(0.0, 1000.0), mat);\n        \n    bool hit = dist < p.miss;\n    if (!hit) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPos = at(r, dist);\n    vec3 hitNorm = normal(hitPos);\n    \n    vec3 col = AMBIENT * mat.col;\n    \n    vec3 dirToLight = normalize(LIGHT_POS - hitPos);\n    \n    float lighting = max(dot(hitNorm, dirToLight), 0.0);\n    float shadows  = shadow(p, Ray(hitPos, dirToLight), Interval(p.surf, 1000.0), 0.5);\n    col += LIGHT_COL * mat.col * lighting * shadows;\n    float ao = max(pow(ambientOcc(hitPos, hitNorm, .006, 20.0), 40.0), 0.1);\n    col *= ao;\n\n    fragColor = vec4(col, 1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n    \n#ifdef AO_MAP\n    fragColor = vec4(ao);\n#endif\n\n#ifdef SHADOW_MAP\n    fragColor = vec4(shadows);\n#endif\n\n#ifdef LIGHT_MAP\n    fragColor = vec4(lighting);\n#endif\n\n#ifdef COLOR_MAP\n    fragColor = vec4(mat.col, 1.0);\n#endif\n\n#ifdef NORMAL_MAP\n    fragColor = vec4(hitNorm, 1.0);\n#endif\n\n#ifdef POS_MAP\n    fragColor = vec4(hitPos, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n// Data structures\n\nstruct MarchParams {\n    int steps;\n    float surf,miss;\n};\n\nstruct Ray {\n    vec3 o,d;\n};\nvec3 at(Ray r, float t) { return r.o+r.d*t; }\n\nstruct Interval {\n    float start,end;\n};\n\nstruct Material {\n    vec3 col;\n};\n\n// Signed distance functions / ray-marching utils\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(p-c)-r;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 translate(in vec3 p, in vec3 t) {\n    return p-t;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\n\nfloat smin(float a, float b, float k) {\n    return 0.5 * ((a + b) - sqrt((a-b)*(a-b)+k));\n}\n\nfloat time;\n\n// RNG stuff\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// Scene SDF\nfloat map(in vec3 p, out Material mat) {\n    mat.col = vec3(1.0);\n    \n    float ground = p.y + 1.0;\n    float sphere = sdSphere(repeatX(repeatY(p-.5, 1.0), 1.0), vec3(0,0.0,1), 0.5);\n    float wall = sdBox(translate(repeatX(p, 1.0), vec3(0,0,0)), vec3(0.5, 1.0, 1.0));\n    float terrace = sdBox(translate(repeatX(p, 1.0), vec3(0, 1, 1)), vec3(0.25, 0.25, 1.0));\n    wall = min(wall, terrace);\n    \n    float dist = ground;\n    dist = smin(ground, mix(wall, sphere, sin(time-.5*PI)*.5+.5), .2);\n    \n    return dist;\n}\n\n// Marching function\nfloat march(in MarchParams p, in Ray r, in Interval i, out Material mat) {\n    vec3 pos;\n    float t = i.start;\n    for (int stp = 0; stp < p.steps; ++stp) {\n        pos = at(r,t);\n        float scene = map(pos, mat);\n        \n        if (scene < p.surf || scene > p.miss || t > i.end) return t;\n        t += scene;\n    }\n    \n    return t;\n}\n\n// Soft shadows\nfloat shadow(in MarchParams p, in Ray r, in Interval i, in float lightSize) {\n    float res = 1.0;\n    float t = i.start;\n    float maxt = i.end; // field selectors don't work in for loops ig\n    for( int i=0; i<p.steps && t<maxt; i++ ) {\n        Material _col;\n        float h = map(at(r,t), _col);\n        res = min( res, h/(lightSize*t) );\n        t += clamp(h, 0.005, 0.50);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return 1.0;\n    float final = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    return final;\n}\n\n// Ambient occlusion\nfloat ambientOcc(vec3 point, vec3 normal, float step_dist, float step_nbr)\n{\n    float occlusion = 1.0f;\n    while(step_nbr > 0.0) {\n        Material _mat;\n        occlusion -= pow(step_nbr * step_dist - (map( point + normal * step_nbr * step_dist, _mat)),2.0) / step_nbr;\n        step_nbr--;\n    }\n\n    return occlusion;\n}\n\n// Get a normal\nvec3 normal(in vec3 pos) {\n    float epsilon = 0.001;\n    Material _col;\n    return normalize(\n        vec3(\n            map(pos + vec3(epsilon, 0, 0), _col) - map(pos - vec3(epsilon, 0, 0), _col),\n            map(pos + vec3(0, epsilon, 0), _col) - map(pos - vec3(0, epsilon, 0), _col),\n            map(pos + vec3(0, 0, epsilon), _col) - map(pos - vec3(0, 0, epsilon), _col)\n        )\n    );\n}","name":"Common","description":"","type":"common"}]}