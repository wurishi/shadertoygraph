{"ver":"0.1","info":{"id":"ws2BRm","date":"1589765178","viewed":108,"name":"Isoparty","username":"jahnertz","description":"The result of some live-programming on https://shawnlawson.github.io/The_Force/ during our end-of-isolation party","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","smooth","stripe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise implementation\nvec2 hash( vec2 p )\n{\n    p = vec2( dot( p, vec2( 127.1, 311.7 )), dot( p, vec2( 269.5, 183 )) );\n    return -1.0 + 2.0 * fract( sin( p ) * 43758.5453123 );\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x + p.y) * K1 );\n    vec2 a = p - i + ( i.x + i.y) * K2;\n    float m = step( a.y, a.x );\n    vec2 o = vec2( m, 1.0 - m );\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max( 0.5 - vec3( dot( a, a ), dot( b, b ), dot( c, c ) ), 0.0 );\n    vec3 n = h*h*h*h*vec3( dot( a, hash( i + 0.0 )), dot( b, hash( i + o )), dot( c, hash( i + 1.0)));\n    return dot( n, vec3( 70.0 ) );\n}\n\n// Draw a diagonal division\nfloat tri(vec2 st, float pct){\n    return 1.0 - smoothstep( pct, pct+0.05, st.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (fraom 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    // Center coordinates a\n    uv -= vec2( 0.5 );\n    // coordinates circular oscilation\n    uv.x += sin( iTime / 5.0 );\n    uv.y -= cos( iTime / 5.0 );\n    // Set scale/zoom\n    float s = 2.0 + sin(iTime / 10.0) * 15.0;\n    // TODO: noise displacement\n    uv += noise(uv);\n    // spherical distortion\n    uv *= vec2( cos( length( uv ) * cos( iTime / 10.0 ) * 10.0 ));\n    // apply scale\n    uv *= s;\n    \n    // set colors\n    vec3 color_a = vec3( 0.2, 0.2, cos( iTime / 20.0 ));\n    vec3 color_b = vec3( 1.0, sin( iTime / 10.0 ), 0.2 + cos( iTime / 2.0 ) * 0.2);\n    \n    float y1 = mod( uv.x, 1.0 ) + ( sin( uv.x / s + iTime * 1.0 )) + cos( uv.y / s + iTime );\n    \n    vec3 color = color_a;\n    color -= vec3( tri( uv, y1 ));\n    color += vec3( tri( uv + 0.5, y1));\n    color += vec3( 1.0 );\n    color *= color_b;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}