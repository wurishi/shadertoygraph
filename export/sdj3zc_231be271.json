{"ver":"0.1","info":{"id":"sdj3zc","date":"1633624192","viewed":87,"name":"sierpinski - fast normals final","username":"nbardy","description":"Defines two functions. sierpinski and sierpinski inverse\n\nThey use scaling and folding via `abs` to compute fast distance fields via triangle for sierpinski pyramid and returns an efficient normal for scene decoration.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","distance","pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// from iq\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec3 fold(vec3 p) { \n    return vec3(abs(p.x),p.y, abs(p.z));\n}\n\nfloat sdPyramid(in vec3 p, float h) {\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    \n    float final = 100.0;\n    p = fold(p);\n\n        corner = vec3(base.x + h/2.0, base.y, base.z + h/2.0);\n        cornerx = vec3(base.x - h/2.0, base.y, base.z + h/2.0);\n        cornerz = vec3(base.x + h/2.0, base.y, base.z - h/2.0);\n        float d1 = sdTriangle(p.xy, top.xy, cornerx.xy, corner.xy);\n        float d2 = sdTriangle(p.zy, top.zy, cornerz.zy, corner.zy);\n        float d = max(d1, d2);\n        \n        return d;\n\n}\n float D;\n void initD() {\n    D = iResolution.y > 400. ? 4. : 3.;\n }\n \n// calc normal\n// signed distance to a pyramid of base 1x1 and height h\n\n// TO speed up:\n// replace sdtriangle with wave functions.\nvec4 sdSerp( in vec3 p, in float h )\n{\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    vec3 norm;\n    \n    float d1;\n    float d2;\n    \n    float final = 100.0;\n    vec3 prefold = p;\n    p = fold(p);\n    for(float i = 0.0;  i < D; i++) {\n        float h2 = h/2.0 + 0.;\n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        cornerx = vec3(base.x - h2, base.y, base.z + h2);\n        cornerz = vec3(base.x + h2, base.y, base.z - h2);\n        d1 = sdTriangle(p.xy, top.xy, cornerx.xy, corner.xy);\n        d2 = sdTriangle(p.zy, top.zy, cornerz.zy, corner.zy);\n        float d = max(d1, d2);\n        \n        if( d > epsilon) { \n            return vec4(d, vec3(0.0));\n        }\n        \n        float topd = length(p-top);\n        float cornerd = length(p-corner);\n        \n        final = min(final,d);\n            // calc normal\n        if(final < 0.0001) {\n             if(abs(p.y-base.y)- 0.00005 < 0.0001 ) {\n               norm = vec3(0.0,1.0,0.0);              \n              } else {\n              if(p.x > p.z) {\n                  norm = normalize(vec3(sign(prefold.x)*1.0,-1., 0.));          \n              } else {\n                  norm = normalize(vec3(0.0,-1.0,sign(prefold.z)*1.0));\n              }\n           }\n        }\n         \n        // TODO matmin instead of if\n        if( topd < cornerd) {\n           top = top;\n           h /= 2.0;\n           base = top + vec3(0.0,h,0.0);\n        } else {\n           h /= 2.0;\n           top = top + vec3(h/2.0, h, h/2.0);\n           base = top + vec3(0.0,h,0.0);\n           \n           p = fold(p - top) + top;\n        }\n        \n        prefold = p;\n    }\n    \n    return vec4(final, norm);\n    \n\n}\n\n// sierpinski inverted\nvec4 sdSerpInv( in vec3 p, in float h )\n{\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    vec3 norm;\n    \n    float d1;\n    float d2;\n    \n    float final = 100.0;\n    vec3 prefold = p;\n    p = fold(p);\n    for(float i = 0.0;  i < D - 1.; i++) {\n        float h2 = h/2.0 + 0.;\n        float h4 = h2/2.0;\n        \n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        vec3 base2 = base - vec3(0.,h2,0.);\n        \n        vec3 midcorner = vec3(base2.x + h4, base2.y, base2.z + h4);\n        cornerx = vec3(base2.x - h4, base2.y, base2.z + h4);\n        cornerz = vec3(base2.x + h4, base2.y, base2.z - h4);\n        float d1 = sdTriangle(p.xy, base.xy, cornerx.xy, midcorner.xy);\n        float d2 = sdTriangle(p.zy, base.zy, cornerz.zy, midcorner.zy);\n        float d = max(d1, d2);\n             \n        float topd = length(p-top);\n        float cornerd = length(p-corner);\n        \n        final = min(final,d);\n        \n        // calc normal\n           if( d < epsilon) { \n                if(abs(p.y-base2.y) -0.00005 < 0.0001 ) {\n                    norm = vec3(0.0,-1.0,0.0);              \n                } else {\n                // TODO(gold edition): round corners with banded equality and rounded normal\n                    if(p.x > p.z) {\n                        norm = normalize(vec3(sign(p.x),1., 0.));          \n                    } else {\n                        norm = normalize(vec3(0.0,1.0,sign(p.z)));\n                    }\n                }\n                           \n           return vec4(d,norm);\n        }\n\n        norm = vec3(1.);\n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        // TODO matmin instead of if\n        if( topd < cornerd) {\n           top = top;\n           h /= 2.0;\n           base = top + vec3(0.0,h,0.0);\n        } else {\n           h /= 2.0;\n           top = top + vec3(h/2.0, h, h/2.0);\n           base = top + vec3(0.0,h,0.0);\n           prefold = p;\n           p = fold(p - top) + top;\n        }\n\n\n    }\n    norm = vec3(0.,0.,0.);\n    \n    return vec4(final, norm);\n}\n\n// does the less distance of two d+norm vecs)\nfloat[5] dmin(vec4 v1, vec4 v2) {\n    if(v2.x < v1.x) {\n        return float[5](v2.x, v2.y, v2.z, v2.w, 2.0);\n    } else {\n        return float[5](v1.x, v1.y, v1.z, v1.w, 1.0);\n    }\n}\n\nfloat[5] withN(vec4 v2, float N) {\n     return float[5](v2.x, v2.y, v2.z, v2.w, N);\n}\n\nfloat H = 2.1;\n\nfloat swing(float x) {\n    return (3.*(x/0.8)*(x/0.8)- 2.*pow(x/0.8, 3.))*1.2;\n}\n\nconst float pi = atan(1.0)*4.0;\n\nfloat spring(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return 1.0 - cos(t*pi*6.0) * exp(-t*6.5);\n}\n\n\nfloat[5] map( in vec3 pos ,vec3 ro)\n{\n    float t = iTime;\n    vec3 p = pos;\n    \n        float starty = 1.2;\n        vec2 m = (iMouse.xy - iResolution.xy/2.0)/iResolution.xy;\n        \n        p = RotateX(p, -0.05*m.x);\n        p = RotateZ(p, -0.05*m.x);\n        p = RotateZ(p, 0.05*m.y);\n        p = RotateY(p, 0.05*m.x);\n    float stillT = 0.3;\n    if(t < stillT ) {\n        D = 1.;\n\n      //  pos = RotateY(pos, 0.1*(iMouse.x - iResolution.x)/iResolution.x);\n        \n        vec4 r1 = sdSerp(p+vec3(0.0,starty,0.), H);\n        \n        return withN(r1, 3.0);\n    }\n    \n    \n    \n    float pct =  spring(1.5, 2.2, t);\n\n    \n    vec3 rs1 = vec3(0.,starty - pct*H/2.,0.);   \n    vec3 rs2 = vec3(0.,starty + pct*H/2.,0.); \n\n    // Pyramid Paths\n    \n    vec4 r1 = sdSerp(p + rs1, H);\n    vec4 r2 = sdSerpInv(p + rs2, H);\n    \n    vec3 nor = r1.yzw;\n\n    // This is a hack to remove stray plane intersection rays.\n    if(nor.y == 1.0 && nor.x == 0. && nor.z == 0.) {\n                 if(ro.y < pos.y) {\n                      r1.z = -1.0;\n                 }\n            }\n    nor = r2.yzw;\n               if(nor.y == -1.0 && nor.x == 0. && nor.z == 0.) {\n                 if(ro.y > pos.y) {\n                      r2.z = 1.0;\n                 }\n            }\n    \n    float[5] final;\n    final =  dmin(r1,r2);\n    //return dmin(dmin(r1, r2), vec4(length(pos - vec3(1.5,0.0,0.0)) - 0.2, 0., 0.,0.));\n    return final;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n\n#define AA 2\n\nvec3 up = vec3(0.,1.,0.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\t//vec3 ro = vec3( 3.0*cos(an), 3.4*sin(iTime), 3.0*sin(an) );\n    //vec3 ro = vec3( 3.0*cos(an), 1.8*sin(0.2*iTime), 3.0*sin(an) );\n    vec3 ro = vec3(3.0, 2.12, 3.0)*1.3;\n    vec3 ta = vec3( 0.0, 0.44, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float time = iTime;\n    \n    initD();\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n        float[5] result;\n\n        // raymarch\n        const float tmax = 60.0;\n        float t = 0.0;\n        for( int i=0; i<1024; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            result = map(pos, ro);\n            //unpack\n            float h = result[0];\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            \n            vec3 light = normalize(vec3(1.2,0.7,1.5));\n            vec3 nor = vec3(result[1], result[2], result[3]);\n \n            vec3 gold = vec3(1.0,0.3,0.02);\n            vec3 mate = 0.12*gold*1.0;\n            ;\n\n            vec3 base = vec3(0.380,0.380,0.380);\n            \n            vec3 A = vec3(255./255.,0./255.,96./255.);\n            vec3 B = vec3(255./255.,243./255.,10./255.);\n            vec3 C = vec3(215./255.,0./255.,255./255.);\n            \n            vec3 D = vec3(10.,255.,27.)/255.;\n            vec3 E = vec3(92.,0.,255.)/255.;\n            \n            float ID = result[4];\n            \n            if (ID == 3.0) {\n               float diff = dot(nor,light);\n               base = vec3(0.01);\n               base += diff*0.7;\n               \n               \n            }  else if(ID == 1.0 && nor.x > 0.) {\n                 // top right\n                 base = B;            \n            }  else if(nor == vec3(0.0,1.0,0.0)) {\n               base = D;\n            }  else if(nor.z > 0. && ID == 1.0) {\n               base = C;\n            }  else if(nor.x > 0.) {\n               base = E;\n            }  else {\n               base = A;\n            }   \n            \n            \n            col = base;       \n\n            //col = vec3(nor.x);\n            //col = vec3(occ);\n        }\n        // vignetting\n       // col *= 1.0-0.1*dot(p,p);\n        \n        // gamma        \n\t  //  tot += pow(col,vec3(0.45) );\n      \n        // background\n        if(length(col) < 0.01) {\n            col= vec3(0.322,0.322,0.322);\n        }\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}