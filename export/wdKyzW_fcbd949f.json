{"ver":"0.1","info":{"id":"wdKyzW","date":"1602362952","viewed":358,"name":"cityfolding","username":"jj99","description":"space folding","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["sdf","folding","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\n\n#define AA 2\n\nfloat box(vec3 r, vec3 p, vec3 size)\n{\n    r = abs(r-p) - size;\n    return max(max(r.x,r.y),r.z);\n}\n\nfloat sphere(vec3 r,vec3 p, float radius)\n{\n    return length(r-p) - radius;\n}\n\nfloat cylinder(vec3 r,vec3 p, float radius, float height)\n{\n    return max(length(r.xy-p.xy) - radius, abs(r.z-p.z)-height);\n}\nmat2 rot(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n\nvec3 Folding(vec3 p)\n{\n    p *= -0.3;\n    \n    \n    float f = 2.65;\n    float ic = 0.0;\n    if (iMouse.z>0.5)\n    {\n        f+=sin(iTime*0.7);\n        ic  = sin(iTime*1.2)*0.1;\n    }\n    \n    \n    \n    float s=3.;\n\tfor(int i=0;i<10;i++)\n    {\n\t\tp.xy=abs(p).xy-s;\n        p.xy *= rot(f*0.1);\n\t    p.xz *= rot(ic*0.1);\n\t\ts=s/1.3;\n\t}\n    \n    return p;\n}\n\n\nfloat map( in vec3 p )\n{\n    \n\tfloat d = cylinder(p.xzy,vec3(0.0),4.75,1.0);\n    \n    p.yz*=rot(3.14*0.5);\n    \n    \n    p = Folding(p);\n    p += .05;\n    \n    vec3 pos1 = p;\n    pos1.x = abs(p.x);\n    vec3 pos2 = p;\n    \n    p.xy = abs(p.xy);\n    \n    \n\tfloat sdf = 0.;\n    sdf = box(p,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n\tsdf = min(sdf,box(p,vec3(0.08,0.08,0.0),vec3(0.05,0.05,0.004)));\n\tsdf = max(sdf,-box(p,vec3(0.08,0.08,0.0),vec3(0.045,0.045,0.0025)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n\n    vec3 b1 = p;\n\tb1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.0,.5*p.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.008);\n    sdf = min(sdf,box(b1,vec3(-0.0,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    sdf = max(sdf,-box(b1,vec3(0.0,0.0,0.052),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    sdf = min(sdf,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.007)));\n\tsdf = min(sdf,box(b1,vec3(0.04,0.02,0.05),vec3(0.004,0.002,0.006)));\n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n\tsdf = max(sdf,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n\tb0=abs(b0);\n    sdf = min(sdf,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    sdf = max(sdf,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n    float noise = 1.+0.05*length(sin(p*2000.0))+0.2*length(sin(p*900.0)); \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    sdf = min(sdf,cylinder(b0,vec3(0.,0.,-0.015),0.001,0.009));\n    b0*=noise;\n    sdf = min(sdf,sphere(b0,vec3(0.),0.007));\n    sdf = min(sdf,sphere(b0,vec3(0.,0.,-.006),0.011));\n\n    vec3 b2 = p;\n    b2.xy -= 0.22;\n    b2 = abs(b2);\n\tsdf =  min(sdf,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.03,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.04),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.07),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.1),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.05),vec3(0.02,0.02,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.03),vec3(0.03,0.04,0.1)));\n\tsdf = max(sdf,-box(b2,vec3(0.,0.,0.025),vec3(0.03,0.025,0.1)));\n\n    vec3 b3 = pos2;\n    b3.xy -=  vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n\tsdf = min(sdf,box(b3,vec3(0.,0.,0.053),vec3(0.045,0.045,0.008)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.033),vec3(0.04,0.04,0.033)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.0,0.064),vec3(0.04,0.04,0.006)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.033),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.033),vec3(0.051,0.01,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.053),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.053),vec3(0.051,0.01,0.003)));\n\tsdf = max(sdf,-box(b3,vec3(0.,0.016,0.003),vec3(0.051,0.01,0.003)));\n    sdf = min(sdf,box(b3,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    sdf = min(sdf,box(b4,vec3(0.,0.,0.003),vec3(0.051,0.051,0.003)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    sdf = min(sdf,box(b4,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b4,vec3(0.05,0.05,0.04),vec3(0.005,0.001,0.001)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.052,0.01,0.004)));\n    vec3 cone = b4;\n    vec3 stairs = b4;\n    sdf = min(sdf,cylinder(b4,vec3(0.008,0.008,0.015),0.0005,0.006));\n    cone.xy += (cone.z-0.021);\n    sdf = min(sdf,cylinder(cone,vec3(0.,0.,0.026),0.015,0.006));\n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n\tsdf = min(sdf,box(stairs,vec3(0.008,0.008,0.0),vec3(0.02,0.02,0.01)));\n\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n\tb5 = abs(b5);\n    sdf = min(sdf,box(b5,vec3(0.014,0.0018,0.0),vec3(0.002,0.001,0.03)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.03),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.02,0.0018,0.032),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.024),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.04,0.01,0.0),vec3(0.01,0.016,0.01)));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.004),0.004));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.010),0.006));\n    sdf = min(sdf,box(b5,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b5,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\n    sdf = max(sdf,d);\n    \n    return sdf;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.125*iTime;\n\tvec3 ro = vec3( 6.0*cos(an), .8+sin(iTime)*0.4, 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 ldir = normalize(vec3(0.5,0.2,0.4));\n            \n            float dif = clamp( dot(nor,ldir), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.2,0.2)*amb + vec3(0.8,0.7,0.5)*dif;\n   \t\t\tcol+= pow(dif, 40.);\n\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}