{"ver":"0.1","info":{"id":"XsjBWt","date":"1502877618","viewed":304,"name":"Implicit vs parametric curve","username":"etale_cohomology","description":"If we have the implicit form of a curve C, then we can draw all of C at once (via iq's gradient formula).\nBut if we have the parametric form of C, then I can't do it without sampling points in C in a brute-force loop!\n\nIs there a way without brute-force?","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","tutorial","curve","implicit","parametric","question","calculus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The blue curve is given by its implicit representation.\n// The white particle is 1 sample of the curve in its parametric representation.\n\n// Ideally, we'd use the parametric representation to draw a white curve that looks just like the\n// blue one, but I don't know how (without sampling a zillion points).\n\n// The obvious way to do it is to circumvent the problem and convert the parametric representation\n// to the implicit representation. As far as I know, this requires calling forth\n// the algebraic-geometry heavy-duty machinery of Grobner bases\n// (math.stackexchange.com/questions/341863).\n// Who wants to do *that*? How do you even compute Grobner bases... in a *shader*?\n\n#define PARTICLE_RADIUS .03\n#define PARTICLE_SPEED  1.\n\n#define ANTIZOOM  1.6\n#define PI        3.14159\n\n#define RGB_DARK  vec3(.06)\n#define RGB_LIGHT vec3(.94)\n#define RGB_BLUE  vec3(.0, .5, 1.)\n\n// ------------------------------------------------------------------------------------------------\n// How do we draw a particle moving along a parametric path?\n// The particle is a small disk. So, the first thing we need is the sdf for a disk.\n// Then, the *position* of the particle is a parametric function of a parameter `t`.\n\n// Miscellaneous utility to draw a particle/disk\nfloat sdf_disk(vec2 uv, vec2 center, float radius){\n    return distance(uv, center) - radius;\n}\n\n// Miscellanous utility to draw a grid, based on abs(sin(uv))\nfloat draw_grid(vec2 uv){\n    vec2 grid_2D = smoothstep(length(fwidth(uv)) * 2., .0, abs(sin(PI * uv)));\n    return max(grid_2D.x, grid_2D.y);\n}\n\n// ------------------------------------------------------------------------------------------------\n// In this section we give 2 representations of the same curve (an ellipse).\n\n// Here's the parametric representation of the curve.\n// In parametric form, the curve is given by the *values* of a function from 1D space to 2D space.\n// This function returns a 2D vector! Every value returned is a point in the curve!\nvec2 parametric_curve(float parameter){\n\tvec2 center = vec2(0);\n    vec2 radius = vec2(2., 1.);\n\n    vec2 point = radius * vec2(cos(parameter), sin(parameter)) + center;\n    return point;\n}\n\n// Here's the implicit representation of the curve.\n// In implicit form, the curve is given by the *zeros* of a function from 2D space to 1D space.\n// This function returns a float! The value returned is 0 iff the point `uv` is in the curve!\nfloat implicit_curve(vec2 uv){\n\tvec2 center = vec2(0);\n    vec2 radius = vec2(2., 1.);\n\n    float x = (uv.x - center.x) / radius.x;\n    float y = (uv.y - center.y) / radius.y;\n\n    float f = x * x + y * y - 1.;\n    vec2 grad_f = vec2(2. * x, 2. * y);  // Hopefully this is the correct gradient of f!\n\n    float distance_estimation = length(f) / length(grad_f);  // I think this is iq's gradient formula!\n    return distance_estimation;\n}\n\n// ------------------------------------------------------------------------------------------------\n// The *position* of the particle takes the value of a parametric function!\nfloat sdf_particle(vec2 uv){\n    vec2 particle_position = parametric_curve(iTime * PARTICLE_SPEED);\n\n    float sdist_particle = sdf_disk(uv, particle_position, PARTICLE_RADIUS);\n    return sdist_particle;\n}\n\n// ------------------------------------------------------------------------------------------------\n// The \"parametric movement\" of the particle is simply making the *center* of the particle\n// the image of a parametric function!\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = ANTIZOOM * (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float grid     = draw_grid(uv);\n    float particle = sdf_particle(uv);\n    float path     = implicit_curve(uv);  // The implicit form is a quasi-sdf, I think!\n\n    float antialias = length(fwidth(uv));  // I have no idea what I'm doing\n    particle = smoothstep(+antialias, .0, particle);\n\tpath     = smoothstep(+antialias, .0, path);// *\n               //smoothstep(-antialias, .0, path);\n\n    // Now we compose the scene!\n    // Surely we can imagine drawing tons of white particles to draw a parametric curve,\n    // but here we draw 1 particle, for simplicity.\n    vec3 scene = RGB_DARK;                    // Add the background color to the scene!\n    scene = mix(scene, RGB_LIGHT, grid);\n    scene = mix(scene, RGB_BLUE,  path);      // Add the path to the scene!\n    scene = mix(scene, RGB_LIGHT, particle);  // Add the particle to the scene!\n\n    fragColor.rgb = scene;\n}\n","name":"Image","description":"","type":"image"}]}