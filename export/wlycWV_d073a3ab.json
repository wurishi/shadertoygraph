{"ver":"0.1","info":{"id":"wlycWV","date":"1612613678","viewed":180,"name":"Refraction Attempt #1","username":"m1ke","description":"My raytracing code modified to use refraction instead of reflection. Can product some cool effects.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//VARS\nvec3 CameraPosition = vec3(-1.5f,2.1f,-1.0f);\nvec4 Light = vec4(1,1,0,1);\nfloat GroundHeight = 0.0f;\nvec2 Pixel;\nfloat Seed = 1141.0f;\nfloat PI = 3.14f;\n\n//NOISE\nfloat rand3D(in vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n//END OF NOISE\n\nstruct Ray \n{\n  vec3 origin;\n  vec3 direction;\n  vec3 energy;\n};\nRay newRay(vec3 origin, vec3 direction)\n{\n  Ray ray;\n  ray.origin = origin;\n  ray.direction = normalize(direction);\n  ray.energy = vec3(1,1,1);\n  return ray;\n}\nstruct Hit \n{\n  float distance;\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n  vec3 specular;\n};\nHit newHit()\n{\n  Hit hit;\n  hit.distance = 100.0f;\n  hit.point = vec3(0.0f,0.0f,0.0f);\n  hit.normal = vec3(0.0f,0.0f,0.0f);\n  hit.colour = vec3(0.0f,0.0f,0.0f);\n  hit.specular = vec3(0,0,0);\n  return hit;\n}\nRay CameraRay(vec2 uvCoord)\n{\n    vec3 origin = CameraPosition; //cameras position\n    vec3 direction = normalize(vec3(uvCoord.x, uvCoord.y, -1.0));\n    \n    float rotX = (0.5f) * 3.14;\n    float rotY = (0.3f) * 3.14;\n    vec2 uv = 2.5 * (uvCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR,camD);\n    \n    direction = normalize(uv.x * camR + uv.y * camU + camD);;\n    \n    return newRay(origin, direction);\n}\nstruct Sphere\n{\n  vec3 position;\n  float radius;\n  vec3 colour;\n  vec3 specular;\n};\nvoid IntersectGround(Ray ray, inout Hit hit)\n{\n    float t = -(ray.origin.y+GroundHeight)/ray.direction.y;\n    if (t > 0.0f && t < hit.distance)\n    {\n        hit.distance = t;\n        hit.point = ray.origin + ray.direction*t;\n        hit.normal = vec3(0,1,1);\n        hit.colour = vec3(0.8f, 0.8f, 0.8f);\n        hit.specular = vec3(0.0f, 0.05f, 0.05f);\n    }\n}\nvoid IntersectSphere(Ray ray, inout Hit hit, Sphere sphere)\n{\n  //make sure the intersection isnt calculated if the ray is refracted\n  //(points very close to the sphere will be ingored)\n  if (length(ray.origin-sphere.position) < sphere.radius+0.003f)\n      return;\n  vec3 d = ray.origin - sphere.position;\n  float p1 = -dot(ray.direction, d);\n  float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n  if (p2sqr < 0.0f)\n  {\n    return;\n  }\n  float p2 = sqrt(p2sqr);\n  float t = p1 - p2 > 0.0f ? p1 - p2 : p1 + p2;\n  if (t > 0.0f && t < hit.distance)\n  {\n      hit.distance = t;\n      hit.point = ray.origin + t * ray.direction;\n      hit.normal = normalize(hit.point - sphere.position);\n      hit.colour = sphere.colour;\n      hit.specular = sphere.specular;\n  }\n}\nHit CalculateRay(Ray r)\n{\n    Hit h = newHit();\n    Sphere a = Sphere(vec3(-1.5f,1,-3), 1.0f, vec3(0.0f,0.0f,0.0f), vec3(1.0f,1.0f,1.0f));\n    Sphere b = Sphere(vec3(-1.5f + sin(iTime)*3.0f, 0.0 ,-5), 0.2f, vec3(1,0,0), vec3(0.0f,0.0f,0.0f));\n    IntersectSphere(r, h, a);\n    IntersectSphere(r,h,b);\n    //IntersectGround(r,h);\n    return h;     \n}\nvec3 SampleSkybox(Ray r)\n{\n    vec4 t = texture(iChannel0, r.direction);\n    return vec3(t.x,t.y,t.z);\n}\nvec3 ShadeRay(inout Ray r, Hit h, inout bool breakL)\n{\n    float Angle = acos(dot(r.direction, h.normal));\n    bool DoRefract = true;//Angle > 2.2f;\n    if (h.distance == 100.0f)\n    {\n        //ray shoots off\n        vec3 outC = SampleSkybox(r);\n        r.energy = vec3(0,0,0);\n        breakL = true;\n        return outC;\n    }\n    else\n    {\n        vec3 newO = h.point + h.normal*0.001f;\n        vec3 refractO = h.point;\n        Ray shadowRay = newRay(newO, Light.xyz);\n        Hit shadowHit = CalculateRay(shadowRay);\n        \n        float newDirF = rand3D(h.point) * 0.05f;\n        vec3 newDir = vec3(newDirF);\n        \n        if (shadowHit.distance == 100.0f)\n        {\n            //unobstruced\n            if (DoRefract)\n            {\n                r.origin = refractO;\n                r.direction = refract(r.direction,h.normal, 0.1f);\n            }\n            else \n            {\n                r.origin = newO;\n                r.direction = reflect(r.direction,h.normal); //+ newDir;\n            }\n            r.energy *= h.specular;\n            return h.colour*dot(h.normal, normalize(Light.xyz)) * Light.w;\n        }\n        else\n        {\n            //in shadow\n            r.energy = vec3(0,0,0);\n            breakL = true;\n            return vec3(0,0,0);\n        }       \n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    Pixel = fragCoord;\n\n    // Time varying pixel color\n    Ray r = CameraRay(fragCoord);\n    vec3 col = vec3(0,0,0);\n    bool breakL = false;\n   \n    \n    for (int i = 0; i < 10; i++)\n    {\n        Hit h = CalculateRay(r);\n        vec3 energy = r.energy;\n        col += energy*ShadeRay(r,h, breakL);\n        if (breakL)\n            break;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}