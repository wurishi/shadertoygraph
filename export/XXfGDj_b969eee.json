{"ver":"0.1","info":{"id":"XXfGDj","date":"1707917625","viewed":171,"name":"[phreax] platonic gems","username":"phreax","description":"Revisiting old experiments with crystal shaders\n\nbased on: https://shadertoy.com/view/fl23Ww","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"[phreax] gemification\" by phreax. https://shadertoy.com/view/fl23Ww\n// 2024-02-14 12:07:48\n\n/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2024\n*/\n\n#define PI 3.141592\n#define TAU PI*2.\n#define SIN(x) (sin(x)*.5+.5)\n\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n#define SQR2 1.4152135\n#define ISQR2 1./SQR2\n\n\nfloat tt;\n\n// Million thanks to https://mercury.sexy/hg_sdf\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1, 0, 0)),\n\tnormalize(vec3(0, 1, 0)),\n\tnormalize(vec3(0, 0, 1)),\n\n\tnormalize(vec3(1, 1, 1 )),\n\tnormalize(vec3(-1, 1, 1)),\n\tnormalize(vec3(1, -1, 1)),\n\tnormalize(vec3(1, 1, -1)),\n\n\tnormalize(vec3(0, 1, PHI+1.)),\n\tnormalize(vec3(0, -1, PHI+1.)),\n\tnormalize(vec3(PHI+1., 0, 1)),\n\tnormalize(vec3(-PHI-1., 0, 1)),\n\tnormalize(vec3(1, PHI+1., 0)),\n\tnormalize(vec3(-1, PHI+1., 0)),\n\n\tnormalize(vec3(0, PHI, 1)),\n\tnormalize(vec3(0, -PHI, 1)),\n\tnormalize(vec3(1, 0, PHI)),\n\tnormalize(vec3(-1, 0, PHI)),\n\tnormalize(vec3(PHI, 1, 0)),\n\tnormalize(vec3(-PHI, 1, 0))\n);\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\n// from iq\nfloat octahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat dodecahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 13, 18);\n}\n\n\nfloat icosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 12);\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat cube(vec3 p, float r) {\n    return box(p, vec3(r));\n}\n\n\nfloat tetrahedron(vec3 p, float r) {\n    \n    // basically cutting a cube at the diagonal and scaling/centering it.\n    p.yz *= rot(PI/2.);\n    \n    p.z -= ISQR2*r;\n    vec3 bp = p;\n    p.z *=  0.5;\n    p.z -= ISQR2*r;\n    \n    p.yz *= rot(atan(ISQR2)*PI*.5);\n    p.xy *= rot(PI/4.);\n\t\n    return max(cube(p, r), bp.z);\n}\n\n\nfloat smoothrect(float x) {\n    return smoothstep(0., .25, mod(x, 1.5))*smoothstep(.25, 0., mod(x, 1.5)-.75);\n}\n\n\n\nvec3 kalei(vec3 p) {\n    for(int i=0; i<4; i++) {\n        p = abs(p) - .1;\n        p.xy *= rot(TAU*1./3.);\n        p.yz *= rot(TAU*1./16.+(tt-7.5)*.2);\n    }\n    return p;\n}\n\nvec3 fold(vec3 p) {\n\n    float c = cos(PI/5.), s = sqrt(.75 - c*c);\n    \n    vec3 n = vec3(-.5, -c, s);\n    \n    p = abs(p);;\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    return p;\n}\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n    \n    bp.xy *= rot(tt * .75);\n    bp.zy *= rot(tt * .5);\n    \n\n   // float db = box(bp, vec3(1.0));\n    //float dc = box(fold(bp), vec3(1.0));\n    \n    p = bp;\n   // p = fold(p);\n    \n    float iv = 0., d1 = 0., d2 = 0., it = 0., ts = 0.;\n    \n    \n    float il = 1.5;\n    \n    ts = mod(tt, il*5.);\n    iv = floor(ts/il);\n    it = mod(ts, il);\n    \n    float s = 1.5;\n    \n    if(iv < 1.) {\n        d1 = tetrahedron(p, 1.*s);\n        d2 = cube(p, 0.8*s);\n    } else if(iv < 2.) {\n        d1 = cube(p, 0.8*s);\n        d2 = octahedron(p, 1.5*s);\n    } else if(iv < 3.) {\n        d1 = octahedron(p, 1.5*s);\n        d2 = dodecahedron(p, 1.*s);\n     } else if(iv < 4.) {\n        d1 = dodecahedron(p, 1.*s);\n        d2 = icosahedron(p, 1.0*s);;\n    } else {\n        d1 = icosahedron(p, 1.0*s);;\n       // p = kalei(p);\n        d2 = tetrahedron(p, 1.*s);\n    }\n\n    float d = mix(d1, d2, smoothstep(.5, 1., it));\n    return d;\n\n}\n\nvec3 getNormal(vec3 p) {\n    \n    float eps = 0.007;\n    vec2 e = vec2(eps, -eps);\n    return normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n\n    \n    // camera system\n    vec3 f = normalize(l - p),  // forward vector\n         r = normalize(cross(vec3(0, 1, 0), f)), // right vector\n         u = cross(f, r), // up vector\n         c = p + f * z, // center of virtual screen\n         i = c + uv.x * r + uv.y * u, // intersection with screen\n         rd = normalize(i - p);  // ray direction\n         \n    return rd;\n    \n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p, float sig) {\n    float i, t, d = 0.1;\n\n    p = ro;\n    \n    for(i=0.; i<100.; i++) {\n    \n        d = sig*map(p);\n        \n        if(abs(d) < 0.001 || t > 50.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    return d;\n\n}\n\nvec3 refractCol(vec3 p, vec3 rd, vec3 n, float ior) {\n\n        vec3 rdIn = refract(rd, n, 1./ior);\n        \n        vec3 pEnter = p - n * 0.003;\n        \n        vec3 pExit;\n        float dIn = rayMarch(pEnter, rdIn, pExit, -1.0);\n        \n        vec3 nExit = -getNormal(pExit);\n        vec3 rdOut = refract(rdIn, nExit, ior);\n        \n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n\n        return texture(iChannel0, rdOut).rgb;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tt = iTime;\n    tt = mod(tt, 30.0);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(.1, 5., -7.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 ls = vec3(1, .5, -1.0);\n        \n    ro.yz *= rot(-m.y*PI+1.);\n    ro.xz *= rot(-m.x*TAU);\n    \n    vec3 rd = getRayDir(uv, ro, lookat, .8);\n\n    vec3 col, p;\n    \n    float d = rayMarch(ro, rd, p, 1.0);\n    \n    \n    if(d < 0.001) {\n        \n        vec3 n = getNormal(p);\n        vec3 l = normalize(ls);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        vec3 colR, colG, colB;\n        \n        float roff = 0.02;\n        colR = refractCol(p, rd, n, 1.45);\n        colG = refractCol(p, rd, n, 1.45+roff);\n        colB = refractCol(p, rd, n, 1.45+2.*roff);\n        \n        col.r = colR.r;\n        col.g = colG.g;\n        col.b = colB.b;\n        \n        vec3 tex = texture(iChannel0, reflect(rd, n)).rgb;\n        tex = pow(tex, vec3(2.2));\n   \n        col = mix(col, tex*(normalize(n))+spe+dif, .4*SIN((tt-6.)*.25));\n   \n        col *= 0.7;\n        \n    } else {\n    \tcol = texture(iChannel0, rd).rgb;\n        col = pow(col, vec3(2.2));\n    }\n    \n\n    col = pow(col, vec3(0.4545)); \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}