{"ver":"0.1","info":{"id":"XfKSDh","date":"1715174496","viewed":67,"name":"Antenna","username":"oramy","description":"Hello! This shader is about space tiling.\nWhen applying space repetition to polar coordinates, UVs are stretched far from the center.\nI wanted to create a circular tiling of the space that deforms UVs as little as possible.\nWhat do you think of it?","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation","uvs","antenna"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 segmentedRingUVs(vec2 p, float s, float t) {\n    float yId = max(0.,round(p.y / s)- t);\n    float xScale = s * yId;\n    float q = xScale * 3.141592*2.;\n    vec2 r = vec2(p.x * xScale, p.y);\n    r = opRepetition(r, vec2(s * s * 3.141592*2., s));\n    return r;\n}\nvec2 segmentedRingUVs2(vec2 p, float s, float t) {\n    float yId = max(0.,round(p.y / s)- t);\n    float xScale = s * yId;\n    float q = xScale * 3.141592*2.;\n    vec2 r = vec2(p.x * xScale  + iTime / pow(yId + 1., 1.5) * 1., p.y);\n    r = opRepetition(r, vec2(s * s * 3.141592*2., s));\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    float ratio = iResolution.x/iResolution.y;\n    \n    \n    // Scaled UVs\n    float scale =  mix(3., 1./2., (cos(fract(iTime/30.) * PI * 2.) + 1.)/2.);\n    vec2 scaledUV = uv * scale; \n    float aa = fwidth(scaledUV.x);\n    \n    // Polar coordinates\n    vec2 uvr = vec2(atan(scaledUV.x, scaledUV.y), length(scaledUV));\n    \n    \n    float tileSizeForeground = 1./5.;\n    float centerSphere = sdCircle(scaledUV, tileSizeForeground);\n    float t = 1.-fract(iTime/2.);\n    \n    vec2 uva = segmentedRingUVs(uvr + vec2(0., t * tileSizeForeground), tileSizeForeground, t);\n    float closeToSeam = smoothstep(PI-2.,PI-.1, abs(uvr.x));\n    float tileSize =  mix(0.,tileSizeForeground, 1.-closeToSeam);\n    float triangle = sdEquilateralTriangle(uva, tileSize*.3);\n    \n    // Bottom Rectangle\n    vec2 halfSize = vec2(.015, 3.); \n    float line = sdBox(scaledUV + vec2(0., halfSize.y), halfSize);\n    \n    \n    // Circles inside rectangle\n    float tileSize3 = 1./20.;\n    \n    vec2 uvc = opLimitedRepetition(scaledUV + vec2(0., halfSize.y - fract(iTime*3.)*tileSize3), tileSize3, vec2(0., halfSize.y/tileSize3));\n    float line2 = sdCircle(uvc , .2*tileSize3);\n    \n    float finalDF = min(max(line, -line2 -.01+ length(scaledUV)*.01), min(triangle, centerSphere));\n    float fgAA = smoothstep(aa, -aa, finalDF);\n    \n    // Glow\n    fgAA += smoothstep(.05 * (1. - length(scaledUV)*1.5), 0., min(triangle, centerSphere)) * (1. - closeToSeam*closeToSeam * smoothstep(-aa, aa, centerSphere)) * max(0., (1. - length(scaledUV)*1.5));\n    \n    \n    // Background triangles\n    float bgTileSize = 1./10.;\n    vec2 uvb = segmentedRingUVs2(uvr + vec2(iTime / 100., 0.), bgTileSize, 0.);\n    float bg = sdEquilateralTriangle(uvb, bgTileSize*.3);\n    float bgAA = clamp(0., 1., smoothstep(aa, -aa, max(bg, -centerSphere)) * (1.-length(uv)/scale/3.));\n\n    // Adding a vignette to the border of the screen\n    float vignette = .7 + .3 * smoothstep(1., .2,max(abs(uv.x)/ratio, abs(uv.y)));\n    \n    vec3 a = vec3(.5,.5,.5), b = vec3(.5,.5,.5), e = vec3(.7,.3, .1), d = vec3(.3,.7,.5), f = vec3(.5,.7,.9);\n    // Output to screen\n    fragColor = vec4(mix(.5*palette(length(scaledUV)/15., a, b, d, e) * (1. - .15 * bgAA), palette(length(scaledUV)/15., a, b, d, f), fgAA),1.)*vignette;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592\n\n// IQ\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n// IQ\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// IQ\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// IQ\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// IQ\nvec2 opRepetition( in vec2 p, in vec2 s)\n{\n    vec2 q = p - s*round(p/s);\n    return q;\n}\n\n// IQ\nvec2 opLimitedRepetition( in vec2 p, in float s, in vec2 l)\n{\n    vec2 q = p - s*clamp(round(p/s),-l,l);\n    return q;\n}","name":"Common","description":"","type":"common"}]}