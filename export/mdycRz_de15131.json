{"ver":"0.1","info":{"id":"mdycRz","date":"1695758743","viewed":90,"name":"Box/line coverage","username":"mrboggieman","description":"Splitting a box using a line and calculating the coverage of the split volume. Note: not a line segment. The two points can be moved via drag/drop","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["line","box","coverage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// related shader: https://www.shadertoy.com/view/NddGRH\nstruct Line {\n   vec2 a;\n   vec2 b;\n};\n\nstruct Aabb {\n    vec2 min;\n    vec2 max;\n};\n\nconst int MAX_LINES = 5;\n\n// UTILS\nfloat det2(in vec2 a, in vec2 b) {\n    return determinant(mat2(a, b));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 closestPointOnLine(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nfloat lineSegmentArea(in Line line) {\n    return det2(line.a, line.b) / 2.0;\n}\n\nfloat lineSegmentsArea(in Line[MAX_LINES] lines, in int num_lines) {\n    float area = 0.0;\n\n    for (int i=0; i<num_lines; i++) {\n        area += lineSegmentArea(lines[i]);\n    }\n    \n    return area;\n}\n\n// COLLISIONS\nbool pointInsideLine(in Line line, in vec2 pos) {\n    return det2(pos - line.a, line.b - line.a) < 0.0;\n}\n\nvec2 intersectLines(in Line line1, in Line line2) {\n    float c = det2(line1.a, line1.b);\n    float d = det2(line2.a, line2.b);\n    float e = det2(line1.a - line1.b, line2.a - line2.b);\n    \n    return vec2(\n        det2(vec2(c, line1.a.x - line1.b.x), vec2(d, line2.a.x - line2.b.x)) / e,\n        det2(vec2(c, line1.a.y - line1.b.y), vec2(d, line2.a.y - line2.b.y)) / e\n    );\n}\n\n\n//TODO: optimise this!\nint splitBox(in Aabb box, in Line line, inout Line[MAX_LINES] lines) {\n    //determine which box vertices are inside or out of the line based on direction\n    vec2 top_left = vec2(box.min.x, box.max.y);\n    vec2 top_right = box.max;\n    vec2 bottom_left = box.min;\n    vec2 bottom_right = vec2(box.max.x, box.min.y);\n    \n    Line top = Line(top_right, top_left);\n    Line left = Line(top_left, bottom_left);\n    Line bottom = Line(bottom_left, bottom_right);\n    Line right = Line(bottom_right, top_right);\n    \n    //bit shift and add the four points so we can use a switch statement\n    int verticesInside = (\n        (int(pointInsideLine(line, top_left)) << 3) +\n        (int(pointInsideLine(line, top_right)) << 2) +\n        (int(pointInsideLine(line, bottom_left)) << 1) +\n        int(pointInsideLine(line, bottom_right))\n    );\n\n    //determine the shape based on the vertices covered\n    vec2 collPoint1;\n    vec2 collPoint2;\n    \n    //TODO: rotate the vertices to minimize the number of combinations?\n    switch (verticesInside) {\n        // 1 point inside cases - produce a triangle\n        case 1:\n            //bottom right only\n            collPoint1 = intersectLines(right, line);\n            collPoint2 = intersectLines(bottom, line);\n\n            lines[0] = Line(bottom_right, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, bottom_right);\n\n            return 3;\n        case 2:\n            //bottom left only\n            collPoint1 = intersectLines(bottom, line);\n            collPoint2 = intersectLines(left, line);\n\n            lines[0] = Line(bottom_left, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, bottom_left);\n\n            return 3;\n        case 4:\n            //top right only\n            collPoint1 = intersectLines(top, line);\n            collPoint2 = intersectLines(right, line);\n\n            lines[0] = Line(top_right, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, top_right);\n\n            return 3;\n        case 8:\n            //top left only\n            collPoint1 = intersectLines(left, line);\n            collPoint2 = intersectLines(top, line);\n\n            lines[0] = Line(top_left, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, top_left);\n\n            return 3;\n        \n        // 2 points inside cases - produce a polygon with 4 sides\n        case 12:\n            //top\n            collPoint1 = intersectLines(left, line);\n            collPoint2 = intersectLines(right, line);\n\n            lines[0] = Line(top_left, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, top_right);\n            lines[3] = Line(top_right, top_left);\n            \n            return 4;\n        case 5:\n            //right\n            collPoint1 = intersectLines(top, line);\n            collPoint2 = intersectLines(bottom, line);\n\n            lines[0] = Line(top_right, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, bottom_right);\n            lines[3] = Line(bottom_right, top_right);\n            \n            return 4;\n        case 3:\n            //bottom\n            collPoint1 = intersectLines(right, line);\n            collPoint2 = intersectLines(left, line);\n\n            lines[0] = Line(bottom_right, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, bottom_left);\n            lines[3] = Line(bottom_left, bottom_right);\n            \n            return 4;\n        case 10:\n            //left\n            collPoint1 = intersectLines(bottom, line);\n            collPoint2 = intersectLines(top, line);\n\n            lines[0] = Line(bottom_left, collPoint1);\n            lines[1] = Line(collPoint1, collPoint2);\n            lines[2] = Line(collPoint2, top_left);\n            lines[3] = Line(top_left, bottom_left);\n\n            return 4;\n\n        // 3 points inside cases - produce a polygon with 5 sides\n        case 14:\n            //excl bottom right\n            collPoint1 = intersectLines(bottom, line);\n            collPoint2 = intersectLines(right, line);\n\n            lines[0] = Line(top_left, bottom_left);\n            lines[1] = Line(bottom_left, collPoint1);\n            lines[2] = Line(collPoint1, collPoint2);\n            lines[3] = Line(collPoint2, top_right);\n            lines[4] = Line(top_right, top_left);\n            \n            return 5;\n        case 11:\n            //excl top right\n            collPoint1 = intersectLines(right, line);\n            collPoint2 = intersectLines(top, line);\n\n            lines[0] = Line(bottom_left, bottom_right);\n            lines[1] = Line(bottom_right, collPoint1);\n            lines[2] = Line(collPoint1, collPoint2);\n            lines[3] = Line(collPoint2, top_left);\n            lines[4] = Line(top_left, bottom_left);\n            \n            return 5;\n        case 7:\n            //excl top left\n            collPoint1 = intersectLines(top, line);\n            collPoint2 = intersectLines(left, line);\n\n            lines[0] = Line(bottom_right, top_right);\n            lines[1] = Line(top_right, collPoint1);\n            lines[2] = Line(collPoint1, collPoint2);\n            lines[3] = Line(collPoint2, bottom_left);\n            lines[4] = Line(bottom_left, bottom_right);\n            \n            return 5;\n        case 13:\n            //excl bottom left\n            collPoint1 = intersectLines(left, line);\n            collPoint2 = intersectLines(bottom, line);\n\n            lines[0] = Line(top_right, top_left);\n            lines[1] = Line(top_left, collPoint1);\n            lines[2] = Line(collPoint1, collPoint2);\n            lines[3] = Line(collPoint2, bottom_right);\n            lines[4] = Line(bottom_right, top_right);\n            \n            return 5;\n        \n        // 4 points inside cases\n        case 15:\n            lines[0] = left;\n            lines[1] = bottom;\n            lines[2] = right;\n            lines[3] = top;\n            \n            return 4;\n    }\n    \n    //must be outside\n    return 0;\n}\n\n// DRAWING\nfloat distanceToLine(in Line line, in vec2 pos) {\n    return distance(closestPointOnLine(line, pos), pos);\n}\n\nfloat distanceToLineSegment(in Line line, in vec2 pos) {\n    return distance(clamp(closestPointOnLine(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n\nfloat distanceToBox(in Aabb box, in vec2 pos) {\n    // modification of sdBox (https://iquilezles.org/articles/distfunctions2d/)\n    vec2 p = pos - mix(box.min, box.max, 0.5);\n    vec2 size = (box.max - box.min) / 2.0;\n\n    vec2 d = abs(p)-size;\n    return abs(length(max(d,0.0)) + min(max(d.x,d.y),0.0));\n}\n\nbool pointInsideLineSegments(in Line[MAX_LINES] lines, in int num_lines, in vec2 pos) {\n    for (int i=0; i<num_lines; i++) {\n        if (!pointInsideLine(lines[i], pos)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float fragSize = 1.0 / iResolution.y;\n    \n    Aabb box = Aabb(vec2(0.4, 0.2), vec2(0.9, 0.7));\n    vec2 boxSize = box.max - box.min;\n    float boxArea = boxSize.x * boxSize.y;\n    float pointSize = 0.01;\n    \n    Line line = Line(getVec2(storedLine.a), getVec2(storedLine.b));\n\n    //determine the new lines that make up the split box\n    Line[MAX_LINES] new_lines;\n    int num_new_lines = splitBox(box, line, new_lines);\n\n    //draw the line points\n    if (distance(line.a, uv) < dragRadius) {\n        fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n        return;\n    }\n    \n    if (distance(line.b, uv) < dragRadius) {\n        fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    //draw the new lines for our shape\n    for (int i=0; i<num_new_lines; i++) {\n        Line line = new_lines[i];\n  \n        if (distance(line.a, uv) < pointSize || distance(line.b, uv) < pointSize) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n            return;\n        }\n\n        if (distanceToLineSegment(line, uv) < fragSize) {\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n            return;\n        }\n    }\n    \n    //highlight the inside of our new shape\n    if (num_new_lines > 0 && pointInsideLineSegments(new_lines, num_new_lines, uv)) {\n        float coverage = clamp(lineSegmentsArea(new_lines, num_new_lines) / boxArea, 0.0, 1.0);\n        fragColor = vec4(vec3(coverage), 1.0);\n        return;\n    }\n\n    //draw the line\n    if (distanceToLine(line, uv) < fragSize) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    //draw the box\n    if (distanceToBox(box, uv) < fragSize) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        return;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//must be macros to be used in constants\n#define setFloat(value) vec4(value, 0.0, 0.0, 0.0)\n#define setVec2(value) vec4(value, 0.0, 0.0)\n#define setVec3(value) vec4(value, 0.0)\n#define setVec4(value) value\n#define setBool(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setBvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setBvec3(value) vec4(vec3(value), 0.0)\n#define setBvec4(value) vec4(value)\n#define setUint(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setUvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setUvec3(value) vec4(vec3(value), 0.0)\n#define setUvec4(value) vec4(value)\n#define setInt(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setIvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setIvec3(value) vec4(vec3(value), 0.0)\n#define setIvec4(value) vec4(value)\n\n//used across persistance and rendering\n#define fromIndex(index) ivec2(index % int(iResolution.x), floor(float(index) / iResolution.x))\n#define toIndex(uv) int(floor(uv.x) + floor(uv.y) * iResolution.x)\n#define get(item) texelFetch(iChannel0, fromIndex(item.index), 0).rgba\n#define getBool(item) bool(get(item).r)\n#define getBvec2(item) bvec2(get(item).rg)\n#define getBvec3(item) bvec3(get(item).rgb)\n#define getBvec4(item) bvec4(get(item).rgba)\n#define getUint(item) uint(get(item).r)\n#define getUvec2(item) uvec2(get(item).rg)\n#define getUvec3(item) uvec3(get(item).rgb)\n#define getUvec4(item) uvec4(get(item).rgba)\n#define getInt(item) int(get(item).r)\n#define getIvec2(item) ivec2(get(item).rg)\n#define getIvec3(item) ivec3(get(item).rgb)\n#define getIvec4(item) ivec4(get(item).rgba)\n#define getFloat(item) get(item).r\n#define getVec2(item) get(item).rg\n#define getVec3(item) get(item).rgb\n#define getVec4(item) get(item).rgba\n\n//just a wrapper around a value we want to persist and the index where it should be saved\nstruct Item {\n    vec4 value;\n    int index;\n};\n\n//demo\n#define newStoredLine(a, b, index) \n\nstruct StoredLine {\n    Item a;\n    Item b;\n};\n\nconst StoredLine storedLine = StoredLine(Item(setVec2(vec2(0.1, 0.1)), 0), Item(setVec2(vec2(0.8, 0.8)), 1));\n\nconst Item dragPosition = Item(setVec2(vec2(0.0)), 2);\n\nconst Item dragIndex = Item(setInt(-1), 3);\n\nconst Item[] dragPoints = Item[](\n    storedLine.a, \n    storedLine.b\n);\n\nconst float dragRadius = 0.03;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool mouseIsDown() {\n    return iMouse.z > 0.0;\n}\n\nvec2 getMousePos() {\n    return iMouse.xy / iResolution.y;\n}\n\nvoid calcDragPosition(inout vec4 nextValue, in Item item) {\n    if (mouseIsDown()) {\n        nextValue = setVec2(getMousePos());\n    }\n}\n\nvoid calcDragIndex(inout vec4 nextValue, in Item item) {\n    if (mouseIsDown()) {\n        int prevDragIndex = getInt(dragIndex);\n        \n        //not already dragging an item\n        if (prevDragIndex == -1) {\n            vec2 mousePos = getMousePos();\n            \n            for (int i=0; i<dragPoints.length(); i++) {\n                Item dragPoint = dragPoints[i];\n                \n                //go through the points in order\n                if (distance(mousePos, getVec2(dragPoint)) < dragRadius) {\n                    nextValue = setInt(i);\n                    return;\n                }\n            }\n        }\n    } else {\n        nextValue = setInt(-1);\n    }\n}\n\nvoid calcPos(inout vec4 nextValue, in Item item, in int index) {\n    if (mouseIsDown()) {\n        int draggedIndex = getInt(dragIndex);\n        \n        //this is the circle we are dragging\n        if (draggedIndex == index) {\n            vec2 prevDragPos = getVec2(dragPosition);\n            vec2 prevPos = getVec2(item);\n            vec2 mousePos = getMousePos();\n\n            nextValue = setVec2(prevPos + mousePos - prevDragPos);\n        }\n    }\n}\n\n#define init_or(item, func) if (index == item.index) { if (iFrame == 0) { fragColor = item.value; } else { func; }}\n#define store(item, func) init_or(item, func(fragColor, item))\n#define store_indexed(item, func, i) init_or(item, func(fragColor, item, i))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = toIndex(fragCoord);\n    \n    //default to the previous frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    \n    //store each value (only calculates/stores if the index matches)\n    for (int i=0; i<dragPoints.length(); i++) {\n        Item point = dragPoints[i];\n        store_indexed(point, calcPos, i);\n    }\n\n    store(dragIndex, calcDragIndex);\n    store(dragPosition, calcDragPosition);\n}","name":"Buffer A","description":"","type":"buffer"}]}