{"ver":"0.1","info":{"id":"WdV3WG","date":"1628648829","viewed":727,"name":"Starship","username":"mhnewman","description":"Mash up of three previous shaders:\nExoplanets - https://www.shadertoy.com/view/3scXR7\nFly by Night - https://www.shadertoy.com/view/XlXGD7\nStarhopper - https://www.shadertoy.com/view/wdjGRz\n","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sdf","rings","space","planet","rocket","spacex","starship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 starshipCenter = vec3(0.0, 12.0, 1.0);\nconst vec3 starshipNose = normalize(vec3(0.2, -1.0, -0.3));\nconst float wiggle = 0.05;\nconst float tankLength = 8.0;\nconst float noseLength = 3.0;\nconst float noseRadius = 0.15;\nconst float frontFinCenter = 2.0;\nconst float frontFinWidth = 1.6;\nconst float frontFinLength = 0.8;\nconst float frontFinAngle = 1.4;\nconst float aftFinWidth = 1.8;\nconst float aftFinLength = 1.8;\nconst float aftFinAngle = 2.5;\nconst float finThickness = 0.05;\nconst float finSmooth = 0.2;\nconst float ripple = 0.04;\n\nconst vec3 planetCenter = vec3(0.8, 1.5, 1.0);\nconst vec3 planetPole = normalize(vec3(-1.0, -1.0, 2.1));\nconst float planetSpeed = -0.04;\nconst vec3 planetColor = vec3(0.6, 0.2, 0.2);\nconst vec3 planetAccentX = vec3(0.6, 0.6, 0.6);\nconst vec3 planetAccentY = vec3(0.0, 0.0, 0.7);\nconst vec3 planetAccentZ = vec3(0.0, 0.7, 0.7);\nconst float planetTurbulence = 0.1;\nconst float planetBands = 15.0;\n\nconst float ringMin = 1.2;\nconst float ringMax = 1.9;\nconst float ringOffset = 12.0;\nconst vec3 ringColor = vec3(0.8, 0.6, 0.4);\nconst vec3 ringAccent = vec3(0.0, 0.2, 0.4);\n\nconst vec3 moonCenter = vec3(0.0, 0.6, -0.95);\nconst vec3 moonPole = normalize(vec3(0.0, -1.0, 2.0));\nconst vec2 moonVel = vec2(0.01, -0.02);\nconst vec3 landColor = vec3(0.1, 0.07, 0.0);\nconst vec3 seaColor = vec3(0.0, 0.05, 0.1);\nconst vec3 cloudColor = vec3(0.5, 0.5, 0.5);\n\nconst vec3 sunDir = normalize(vec3(-4.0, 0.0, -1.0));\n\n\n\nconst int marchIter = 200;\nconst float marchDist = 50.0;\nconst float epsilon = 0.001;\n\n\nconst vec3 planetX = normalize(cross(vec3(0.0, 1.0, 0.0), planetPole));\nconst vec3 planetY = cross(planetPole, planetX);\nconst mat3 planetRot = inverse(mat3(planetX, planetY, planetPole));\n\nconst vec3 moonX = normalize(cross(vec3(0.0, 1.0, 0.0), moonPole));\nconst vec3 moonY = cross(moonPole, moonX);\nconst mat3 moonRot = inverse(mat3(moonX, moonY, moonPole));\n\n\n// As always, David Hoskins's Hash without Sine, shadertoy.com/view/4djSRW \n\nfloat hash1(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz)*p3.zyx);\n}\n\nfloat hash1(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec3 p3) {\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise1(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash1(i), hash1(i + 1.0), u);\n}\n\n\nvec3 noise3(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash3(i), hash3(i + 1.0), u);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec2 noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash2(i + vec2(0.0, 0.0)), \n                   hash2(i + vec2(1.0, 0.0)), u.x),\n               mix(hash2(i + vec2(0.0, 1.0)), \n                   hash2(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec3 noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(mix(hash3(i + vec3(0.0, 0.0, 0.0)), \n                                   hash3(i + vec3(1.0, 0.0, 0.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 0.0)), \n                                   hash3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                           mix(mix(hash3(i + vec3(0.0, 0.0, 1.0)), \n                                   hash3(i + vec3(1.0, 0.0, 1.0)), u.x),\n                               mix(hash3(i + vec3(0.0, 1.0, 1.0)), \n                                   hash3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\nfloat fbm1(float p) {\n    float f = noise1(p); p = 2.0 * p;\n    f += 0.5 * noise1(p); p = 2.0 * p;\n    f += 0.25 * noise1(p); p = 2.0 * p;\n    f += 0.125 * noise1(p); p = 2.0 * p;\n    f += 0.0625 * noise1(p); p = 2.0 * p;\n    f += 0.03125 * noise1(p);\n    return f / 1.96875;\n}\n\nvec3 fbm3(float p) {\n    vec3 f = noise3(p); p = 2.0 * p;\n    f += 0.5 * noise3(p); p = 2.0 * p;\n    f += 0.25 * noise3(p);\n    return f / 1.75;\n}\n\nconst mat2 m2 = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p) {\n    float f = noise1(p); p = m2 * p;\n    f += 0.5 * noise1(p); p = m2 * p;\n    f += 0.25 * noise1(p); p = m2 * p;\n    f += 0.125 * noise1(p); p = m2 * p;\n    f += 0.0625 * noise1(p);\n    return f / 1.9375;\n}\n\nvec2 fbm2(vec2 p) {\n    vec2 f = noise2(p); p = m2 * p;\n    f += 0.5 * noise2(p); p = m2 * p;\n    f += 0.25 * noise2(p); p = m2 * p;\n    f += 0.125 * noise2(p); p = m2 * p;\n    f += 0.0625 * noise2(p);\n    return f / 1.9375;\n}\n\nconst mat3 m3 = mat3( 0.51162, -1.54702,  1.15972,\n                    -1.70666, -0.92510, -0.48114,\n                     0.90858, -0.86654, -1.55678);\n\nvec3 fbm3(vec3 p) {\n    vec3 f = noise3(p); p = m3 * p;\n    f += 0.5 * noise3(p); p = m3 * p;\n    f += 0.25 * noise3(p); p = m3 * p;\n    f += 0.125 * noise3(p); p = m3 * p;\n    f += 0.0625 * noise3(p);\n    return f / 1.9375;\n}\n\nbool hit(vec3 eye, vec3 ray, out float dist, out vec3 pos) {\n    float b = dot(eye, ray);\n    float c = dot(eye, eye) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0)\n        return false;\n\n    dist = -b - sqrt(h);\n    if (dist < 0.0)\n        return false;\n        \n    pos = eye + dist * ray;\n    return true;\n}\n\nfloat ndot(vec2 a, vec2 b) { return a.x * b.x - a.y * b.y; }\n\nfloat rhombusSdf(vec3 p, float la, float lb) {\n    p = abs(p);\n    vec2 b = vec2(la, lb);\n    float f = clamp((ndot(b, b - 2.0 * p.xy)) / dot(b, b), -1.0, 1.0);\n\tvec2 q = vec2(length(p.xy - 0.5 * b * vec2(1.0 - f, 1.0 + f)) * sign(p.x * b.y + p.y * b.x - b.x * b.y), p.z);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\nfloat rectangleSdf(vec3 p, float x, float y) {\n    vec3 q = abs(p) - vec3(x, y, 0.0);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat tankSdf(vec2 p) {\n\tconst float halfTank = 0.5 * (tankLength);\n    vec2 q = abs(p - vec2(0.0, halfTank)) - vec2(1.0, halfTank);\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat noseSdf(vec2 p) {\n    const float a = noseLength - noseRadius;\n    const float b = 1.0 - noseRadius;\n    const float r = 0.5 * (a * a + b * b) / b;\n    vec2 q = vec2(1.0 - r - noseRadius, tankLength);\n    vec2 d = p - q;\n    d = d / length(d);\n\tq += r * d;    \n    q.x = max(0.0, q.x);\n    q.y = min(tankLength + noseLength - noseRadius, q.y);\n    return length(p - q) - noseRadius;\n}\n\nfloat starshipSdf(vec3 pos) {\n    const float totalLength = tankLength + noseLength;\n    pos.x += 0.5 * totalLength;\n\n    vec2 p = vec2(length(pos.yz), pos.x);\n    float body = tankSdf(p);\n    body = min(body, noseSdf(p));\n    \n    vec3 q = pos;\n    q.x -= totalLength - frontFinCenter;\n    float fins = rhombusSdf(q, frontFinAngle, frontFinWidth);\n\n    const float frontFinHalf = 0.5 * frontFinLength;\n    q.x += frontFinHalf;\n    fins = min(fins, rectangleSdf(q, frontFinHalf, frontFinWidth));\n\n    q = pos;\n    q.x -= aftFinLength;\n    fins = min(fins, rhombusSdf(q, aftFinAngle, aftFinWidth));\n\n    const float aftFinHalf = 0.5 * aftFinLength;\n    q.x += aftFinHalf;\n    fins = min(fins, rectangleSdf(q, aftFinHalf, aftFinWidth));\n    \n    fins -= finThickness;\n    float h = clamp(0.5 + 0.5 * (body - fins) / finSmooth, 0.0, 1.0);\n    return mix(body, fins, h) - finSmooth * h * (1.0 - h);\n}\n\nbool starshipMarch(vec3 eye, vec3 ray, out vec3 pos) {\n    float dist = 0.0;\n    for (int i = 0; i < marchIter; ++i) {\n        pos = eye + dist * ray;\n        float sdf = starshipSdf(pos);\n        dist += sdf;\n        if (sdf < epsilon)\n            return true;\n        if (dist >= marchDist)\n            return false;\n    }\n    return true;\n}\n\nvec3 starshipNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * starshipSdf(pos + e.xyy*eps) + \n                     e.yyx * starshipSdf(pos + e.yyx*eps) + \n                     e.yxy * starshipSdf(pos + e.yxy*eps) + \n                     e.xxx * starshipSdf(pos + e.xxx*eps) +\n                     ripple * eps * fbm3(3.0 * pos.x));\n}\n\nvec3 hitStarship(vec3 ray) {\n    vec3 starshipX = normalize(starshipNose + wiggle * fbm3(0.1 * iTime));\n    vec3 starshipY = normalize(cross(vec3(0.0, 0.0, 1.0), starshipX));\n    vec3 starshipZ = cross(starshipX, starshipY);\n    mat3 starshipNormRot = mat3(starshipX, starshipY, starshipZ);\n    mat3 starshipRot = inverse(starshipNormRot);\n\n    vec3 pos;\n    if (starshipMarch(starshipRot * -starshipCenter, starshipRot * ray, pos)) {\n        vec3 norm = starshipNormRot * starshipNormal(pos);\n        return reflect(ray, norm);\n    }\n    return ray;\n}\n\nfloat hitRing(vec3 eye, vec3 ray, out float dist, out float radius) {\n    dist = dot(-eye, planetPole) / dot(ray, planetPole);\n    vec3 pos = eye + dist * ray;\n    radius = length(pos);\n    \n    float a = smoothstep(ringMin, ringMin + 0.1, radius) * smoothstep(ringMax, ringMax - 0.1, radius);\n    a *= smoothstep(-0.5, 1.0, fbm1(8.0 * radius + ringOffset));\n    return clamp(a, 0.0, 1.0) * step(0.0, dist);\n}\n\nvec3 renderPlanet(vec3 color, vec3 ray) {\n    vec3 pos;\n    float dist;\n    float t = planetSpeed * iTime;\n    float s = sin(t);\n    float c = cos(t);\n    mat3 rev = mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n    if (hit(-planetCenter, ray, dist, pos)) {\n        vec3 p = rev * planetRot * pos;\n        \n        p += planetTurbulence * fbm3(10.0 * p + 0.01 * iTime);\n\n        vec3 bands = fbm3(planetBands * vec3(0.05, 0.05, 1.0) * p);\n        vec3 planetC = planetColor;\n        planetC += planetAccentX * bands.x;\n        planetC += planetAccentY * bands.y;\n        planetC += planetAccentZ * bands.z;\n        float d, r;\n        float ringShadow = 1.0 - hitRing(pos, sunDir, d, r);\n        color = clamp(planetC, 0.0, 1.0) * clamp(dot(pos, sunDir) * ringShadow, 0.0, 1.0);\n    } else {\n        dist = 100.0;\n    }\n    \n    float ringDist, radius;\n    float ringAlpha = hitRing(-planetCenter, ray, ringDist, radius);\n    vec3 ringC = ringColor + ringAccent * fbm1(15.0 * radius);\n    color = mix(color, ringC, ringAlpha * step(ringDist, dist));\n    return color;\n}\n\nvec3 renderMoon(vec3 color, vec3 ray) {\n    vec3 pos;\n    float dist;\n    if (hit(-moonCenter, ray, dist, pos)) {\n        vec3 xy = moonRot * pos;\n        vec2 p = xy.xy + iTime * moonVel;\n        \n        color = mix(landColor, seaColor, smoothstep(0.49, 0.5, fbm1(6.0 * p)));\n        \n        float weather = fbm1(40.0 * (p + 0.1 * fbm2(10.0 * p)));\n        color = mix(color, cloudColor, smoothstep(0.4, 0.8, weather));\n    }\n    \n    float d = dot(moonCenter, ray);\n    if (d > 0.0) {\n        vec3 altitude = moonCenter - ray * d;\n        float horizon = sqrt(dot(altitude, altitude));\n\n        float atmosphere = clamp(pow(horizon, 20.0), 0.0, 1.0);\n        atmosphere *= smoothstep(1.01, 1.0, horizon);\n        color = mix(color, vec3(0.1, 0.2, 0.3), atmosphere);\n\n        vec3 glow = vec3(0.0);\n        glow = mix(glow, vec3(0.04, 0.06, 0.1), smoothstep(0.995, 1.005, horizon));\n        glow = mix(glow, vec3(0.1, 0.0, 0.0), smoothstep(1.005, 1.015, horizon));\n        glow = mix(glow, vec3(0.2, 0.17, 0.1), smoothstep(1.015, 1.02, horizon));\n        glow = mix(glow, vec3(0.0, 0.0, 0.0), smoothstep(1.02, 1.025, horizon));\n        color += glow;\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(vec3(xy.x, 2.5 * iResolution.y, xy.y));\n    \n    ray = hitStarship(ray);\n\n    vec3 color = vec3(0.0);\n    \n    color = renderPlanet(color, ray);\n    color = renderMoon(color, ray);\n\n    float flare = max(0.0, dot(ray, sunDir));\n    color += pow(flare, 20.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}