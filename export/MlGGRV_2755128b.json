{"ver":"0.1","info":{"id":"MlGGRV","date":"1475509465","viewed":322,"name":"Accurate sierpinski triangle WIP","username":"deadmanswitch","description":"I use this tetrahedron formula, to generate the fractal: https://www.shadertoy.com/view/ltVGzy\n\nThere is no need to decrease your step during raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","triangle","wip","sierpinski","accurate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tetrahedron: https://www.shadertoy.com/view/ltVGzy\n\n#define FOV 60.0\n\n#define MAX_STEP   32\n#define MAX_STEP_F 32.0\n\n// constants\nconst float infinity = 1.0/0.000000001;\nconst float PI = asin(1.0)*2.0;\n\n\n// min/max vec\nfloat max4(in vec4 v4) {\n    return max( max(v4.x, v4.y), max(v4.z, v4.w) );\n}\n\nfloat min4(in vec4 v4) {\n    return min( min(v4.x, v4.y), min(v4.z, v4.w) );\n}\n\n// rotations\nvec3 rotateX(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0],\n        vec[1]*cos(rad) - vec[2]*sin(rad),\n        vec[1]*sin(rad) + vec[2]*cos(rad)\n    );\n        \n}\n\nvec3 rotateY(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[2]*sin(rad) + vec[0]*cos(rad),\n        vec[1],\n        vec[2]*cos(rad) - vec[0]*sin(rad)\n    );\n}\n\nvec3 rotateZ(in vec3 vec, in float rad) {\n    \n    return vec3(\n        vec[0]*cos(rad) - vec[1]*sin(rad),\n        vec[0]*sin(rad) + vec[1]*cos(rad),\n        vec[2]\n    );\n}\n\n// return the vector closest to `p`\nvec3 closestTo(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    \n    vec4 ll = vec4(\n    \tdistance(a,p),\n        distance(b,p),\n        distance(c,p),\n        distance(d,p)\n    );\n    \n    float sh = min4(ll);\n    \n    vec4 eq = vec4(equal(ll, vec4(sh)));\n    \n    //return mix(a, mix( b, mix(c, d, eq.z ), eq.y ), eq.x ); !! with notEqual\n    return eq.x*a + eq.y*b + eq.z*c + eq.w*d;\n    \n}\n\n\n/***************\n\nTetrahedron start\n\n***************/\n\n// normals\nconst vec3 norm1 = vec3(\n\t0.4714045226573944,\n    0.3333333432674408,\n    -0.8164966106414795\n);\nconst vec3 norm2 = vec3(\n\t-0.9428090453147888,\n    0.3333333432674408,\n    0.0\n);\nconst vec3 norm3 = vec3(\n\t0.4714045524597168,\n    0.3333333432674408,\n    0.8164966106414795\n);\n\n// points\nconst vec3 point0 = vec3( 0.0,                 1.0,                 0.0);\nconst vec3 point1 = vec3( 0.9428090453147888, -0.3333333432674408,  0.0);\nconst vec3 point2 = vec3(-0.4714045226573944, -0.3333333432674408, -0.8164966106414795);\nconst vec3 point3 = vec3(-0.4714045226573944, -0.3333333432674408,  0.8164966106414795);\n\nfloat planedist(in vec3 point, in vec3 norm) {\n\n    return dot(point, norm) - norm.y;\n\n}\n\nfloat tet(in vec3 point, in float size) {\n    \n    point = point/size;\n\n    // subtracting the planes from a sphere\n    float dist = max4(vec4(\n        planedist(point, norm1),\n        planedist(point, norm2),\n        planedist(point, norm3),\n        -(1.0/3.0+point.y)\n    ));\n\n    // the sphere has a `size` radius\n    dist = max(length(point)-1.0, dist)*size;\n\n    return dist;\n    \n}\n\n/***************\n\nTetrahedron end\n\n***************/\n\n// the distance estimator function\nconst int STEPS = 8;\nfloat DE(in vec3 pos) {\n    \n    // rotation\n    float rot = (iTime*0.25)*PI*2.0;\n    pos = rotateY(pos, rot);\n    \n    // steps\n    vec3 p = pos;\n    for(int i=0; i<STEPS; i++) {\n        \n        // scale the current point, and find the closest point vertex\n        p *= 2.0;\n        p = p-closestTo(p, point0, point1, point2, point3);\n        \n    }\n    \n    // calculate the distance to the last found tetrahedron ( for STEPS=0 -> tet(pos, 1.0) )\n    return tet(p, 1.0)/exp2(float(STEPS));\n    \n}\n\nconst vec3 shadowColor = vec3(0.1, 0.05, 0.0);\nconst vec3 backColor = vec3(0.2, 0.25, 0.2);\nconst vec3 tetColor = vec3(0.2, 0.75, 0.95);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n\tvec2 view = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    float a = tan(FOV * (PI/180.0) / 2.0);\n    vec2 ab = vec2(a * aspect, a);\n    \n    // the start point, and the direction of the ray\n    vec3 dir = normalize(vec3(ab*view, -1.0));\n    vec3 point = vec3(0.0, 0.0, 1.5+sin(iTime)*1.5);\n    \n    // ray-march\n    float closest = infinity;\n\n    for(int i = 0; i<MAX_STEP; i++) {\n\n        vec3 pos = point;\n\n        float dist = DE(pos);\n\n        if(dist < 0.0025) {\n            fragColor = vec4(mix(\n                tetColor,\n                shadowColor,\n                sqrt(float(i)/MAX_STEP_F)\n            ), 1.0);\n            return;\n        }\n\n        closest = min(closest, dist);\n\n        point += dir*dist;\n\n    }\n\n    fragColor = vec4(mix(\n        shadowColor,\n        backColor,\n        sqrt(clamp(closest/0.5, 0.0, 1.0))\n    ), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}