{"ver":"0.1","info":{"id":"Mtlfzf","date":"1512795551","viewed":239,"name":"Bezier triangle","username":"JohanKohler","description":"Render  a bezier triangle, no signed distance im afraid.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS  .01\nfloat cross2d(vec3 a, vec3 b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\nvec3 bary(in vec3 a, in vec3 b, in vec3 c, in vec3 p)\n{\n    // The cross product of two vectors has a magnitude\n    // equal to twice the area of the triangle formed by \n    // the two vectors.\n    float n = cross2d(b - a, c - a);    \n\tfloat area = n * n;\n\t\n\tif(area < 0.0001) return vec3(0);\n\t\n\tvec3 v0 = a - p;\n\tvec3 v1 = b - p;\n\tvec3 v2 = c - p;\n\t\n\tvec3 asub = vec3(cross2d(v1, v2) * n,\n\t\t\t\t\t cross2d(v2, v0) * n,\n\t\t\t\t\t cross2d(v0, v1) * n);\n    \n\treturn asub / vec3(area);\n}\n\nvec3 bary2D( vec2 A, vec2 B, vec2 C, vec2 p )\n{\n    return bary(vec3(A,0.),vec3(B,0.),vec3(C,0.),vec3(p,0.));\n}\n\nbool testTri(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    vec3 v = bary2D( A, B, C, p );\n    return v.x > 0. && v.y > 0. && v.z > 0.;\n}\n\nbool testQuatBez(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    vec3 v = bary2D( A, B, C, p );\n    float t = v.y * 0.5 + v.x;\n    return v.y >= 0. && t*t - v.x < 0.;\n}\n\nbool testBezTri( vec2 a, vec2 ab, vec2 b, vec2 bc, vec2 c, vec2 ca, vec2 p )\n{\n    bool r = testTri(a,b,c,p);\n    r = testQuatBez(a,ab,b,p) != r;\n    r = testQuatBez(b,bc,c,p) != r;\n    r = testQuatBez(c,ca,a,p) != r;\n    return r;\n}\n\n// The rest is not testing related.\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL2 vec3(.1, .6, .3)\n#define COL3 vec3(.1)\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat df_bounds(in vec2 uv,in vec2 a, in vec2 b, in vec2 c)\n{\n    float cp = 0.;\n    \n    float c0 = sharpen(df_circ(uv, a, \n                       (.03 *.01))\n                       , EPS * 1.);\n    float c1 = sharpen(df_circ(uv, b, \n                       (.03 *.01))\n                       , EPS * 1.);\n    float c2 = sharpen(df_circ(uv, c, \n                       (.03 *.01))\n                       , EPS * 1.);\n\n    cp = max(c0, max(c1, c2));\n\n    return cp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ar = iResolution.x / iResolution.y;\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(ar, 1.);\n    vec2 mc = (iMouse.xy    / iResolution.xy * 2. - 1.) * vec2(ar, 1.);\n\n    vec2 a = vec2( .73,  .75);\n    vec2 b = vec2(-.85,  .15);\n    vec2 c = vec2( .25, -.75);\n\t\n    vec2 ab = (a + b) / 2. + vec2(cos(iTime * 1.2) * 0.3, cos(iTime * 2.2) * 0.3);\n    vec2 bc = (b + c) / 2. + vec2(cos(iTime * 1.6) * 0.3, cos(iTime * 2.3) * 0.3);\n    vec2 ca = (c + a) / 2. + vec2(cos(iTime * 1.7) * 0.3, cos(iTime * 2.4) * 0.3);\n    \n\n    float l = df_bounds(uv, a, b, c);\n    l = max( l, df_bounds(uv, ab, bc, ca) );\n\n    // Extrapolate the controllpoints so they touch the spline.\n    // This is just so things look good.\n    ab = (4.0 * ab - a - b) / 2.0;\n    bc = (4.0 * bc - b - c) / 2.0;\n    ca = (4.0 * ca - c - a) / 2.0;\n    \n    bool t = testBezTri(a,ab,b,bc,c,ca,uv);\n    \n    vec3 col = l > 0. ? COL3 : (t ? COL0 : COL2);        \n        \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}