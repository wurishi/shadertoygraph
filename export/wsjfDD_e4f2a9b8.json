{"ver":"0.1","info":{"id":"wsjfDD","date":"1590212367","viewed":301,"name":"PBR Monte Carlo Pt.5","username":"fluxatron","description":"A back to theory attempt at a PBR BRDF!  Drag to move cam.\n\nThis resolves terribly. Any tips? \nMy guess is better noise for starters and some form of importance sampling?","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","interactive","montecarlo","pbr","unbiased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat DecodeFrame()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823,  0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475,-0.10208,-0.00327,   -0.53108, 1.10813,-0.07276,   -0.07367, -0.00605, 1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = texture(iChannel0, uv).rgb / float(DecodeFrame()+1.); // Divide accumulation buffer by num frames\n    col *= 1.;\n    col = ACESFitted(col); // Tonemap\n    col = pow(col, vec3(0.4545)); // Gamma 1/2.2\n   \t//col = vec3(0.2126*col.r + 0.7152*col.g + 0.0722*col.g); // Luminance\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define APERTURE 0.2      /* diameter of the lens */\n#define VERTICAL_FOV 25.  /* degrees */\n\n#define MAX_BOUNCES 7\n#define SAMPLES_PER_PIXEL 8\n\n// Feature flags\n#define DIFFUSE 1\n#define SPECULAR 1\n#define EMISSIVE 1\n#define SKY 1\n\n\n#define SRGB_TO_LINEAR(R,G,B) pow(vec3(R,G,B) / vec3(255,255,255), vec3(2.2))\nconst vec3 _gold   = SRGB_TO_LINEAR(255,226,115);\nconst vec3 _silver = SRGB_TO_LINEAR(252,250,245);\nconst vec3 _copper = SRGB_TO_LINEAR(250,208,192);\n\nconst float _skyBrightness = .3;\nvec3 _skyColor;\n\nconst int _numSpheres = 8;\nSphere[_numSpheres] _spheres;\n\nvoid InitScene()\n{\n    vec3 v = vec3(.15,.5,.85);\n    \n    // Ground\n\t_spheres[0].Center = vec3(0,-1000,0);\n    _spheres[0].Radius = 1000.;\n    _spheres[0].Mat.BaseColor = v.bbb;\n    _spheres[0].Mat.Metalness = 0.;\n    _spheres[0].Mat.Roughness = 0.33;\n    _spheres[0].Mat.Emissive = 0.;\n    _spheres[0].Mat.IsCheckerHack = true;\n    \n    // Light    \n\t_spheres[1].Center = vec3(20);\n    _spheres[1].Radius = 10.;\n    _spheres[1].Mat.BaseColor = vec3(1);\n    _spheres[1].Mat.Metalness = 0.;\n    _spheres[1].Mat.Roughness = 0.;\n    _spheres[1].Mat.Emissive = 15.;\n    \n    \n    // Metal balls\n    _spheres[2].Center = vec3(-5,2.,2.5);\n    _spheres[2].Radius = 2.;\n    _spheres[2].Mat.BaseColor = _silver;\n    _spheres[2].Mat.Metalness = 1.;\n    _spheres[2].Mat.Roughness = 0.1;\n    _spheres[2].Mat.Emissive = 0.;\n    \n\t_spheres[3].Center = vec3(0,2.,2.5);\n    _spheres[3].Radius = 2.;\n    _spheres[3].Mat.BaseColor = _gold;\n    _spheres[3].Mat.Metalness = 1.;\n    _spheres[3].Mat.Roughness = 0.2;\n    _spheres[3].Mat.Emissive = 0.;\n    \n    _spheres[4].Center = vec3(5.,2.,2.5);\n    _spheres[4].Radius = 2.;\n    _spheres[4].Mat.BaseColor = _copper;\n    _spheres[4].Mat.Metalness = 1.;\n    _spheres[4].Mat.Roughness = 0.5;\n    _spheres[4].Mat.Emissive = 0.;\n    \n    \n    // RGB balls\n    _spheres[5].Center = vec3(-5.,2,-2.5);\n    _spheres[5].Radius = 2.;\n    _spheres[5].Mat.BaseColor = v.brr;\n    _spheres[5].Mat.Metalness = 0.;\n    _spheres[5].Mat.Roughness = .5;\n    _spheres[5].Mat.Emissive = 0.;\n    \n\t_spheres[6].Center = vec3(0,2,-2.5);\n    _spheres[6].Radius = 2.;\n    _spheres[6].Mat.BaseColor = v.rbr;\n    _spheres[6].Mat.Metalness = 0.;\n    _spheres[6].Mat.Roughness = 0.2;\n    _spheres[6].Mat.Emissive = 5.;\n    \n    _spheres[7].Center = vec3(5.,2.,-2.5);\n    _spheres[7].Radius = 2.;\n    _spheres[7].Mat.BaseColor = v.rrb;\n    _spheres[7].Mat.Metalness = 0.;\n    _spheres[7].Mat.Roughness = .1;\n    _spheres[7].Mat.Emissive = 0.;\n    \n}\n\n\n// OTHER //////////////////////////////////////////////////////////////////////////////////\n    \nvec4 EncodeNumFramesAccumulated(float frame)\n{\n    return vec4(frame,0,0,0);\n}\n\nfloat DecodeNumFramesAccumulated()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\nmat3 ViewLookAtMatrix(vec3 eye, vec3 target, float roll)\n{\n\tvec3 rollVec = vec3(sin(roll), cos(roll), 0.);\n\tvec3 w = normalize(eye-target); // right handed TODO Change all math to left handed? \n\tvec3 u = normalize(cross(rollVec,w));\n\tvec3 v = normalize(cross(w,u));\n    return mat3(u, v, w);\n}\n      \n\n// SCENE //////////////////////////////////////////////////////////////////////////////////\n           \nbool HitSphere(Sphere sph, Ray ray, float tMin, float tMax, inout Hit outHit)\n{\n    vec3 oc = ray.Origin - sph.Center;\n    \n    float a = dot(ray.Dir, ray.Dir);\n    float half_b = dot(oc, ray.Dir);\n    float c = length2(oc) - sph.Radius*sph.Radius;\n    float discriminant = half_b*half_b - a*c;\n    \n    \n    if (discriminant > 0.) \n    {\n        float root = sqrt(discriminant);\n        float temp = (-half_b - root)/a;\n       \n        if (temp > tMin && temp < tMax) \n        {\n            outHit.LengthAlongRay = temp;\n            outHit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            outHit.Normal = (outHit.Pos - sph.Center) / sph.Radius;\n            outHit.Mat = sph.Mat;\n        \treturn true;\n        }\n        \n        temp = (-half_b + root)/a;\n        if (temp > tMin && temp < tMax)\n        { \n            outHit.LengthAlongRay = temp;\n            outHit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            outHit.Normal = (outHit.Pos - sph.Center) / sph.Radius;\n            outHit.Mat = sph.Mat;\n        \treturn true;\n        }\n    }\n    \n    return false;\n}\n\nbool FindClosestHit(Ray ray, inout Hit outHit)\n{\n    float tMin = 0.0001;\n    float closestSoFar = BIG_FLOAT;\n    \n    bool hitAnything = false;\n\n    Hit tempHit;\n    for (int i = 0; i < _numSpheres; i++)\n    {\n        Sphere sph = _spheres[i];\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = tempHit.LengthAlongRay;\n            outHit = tempHit;\n        }\n    }\n    \n    return hitAnything;\n}\n\nvec3 ColorPBR(Ray ray, float seed)\n{\n\tconst float epsilon = 0.001;\n    \n    vec3 accumulatedLight = vec3(0);\n\tvec3 attenuation = vec3(1);\n    Hit hit;\n    \n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)\n    {\n\t\tif (FindClosestHit(ray, hit))\n        {\n            // Quick hack to add some checkery goodness\n            if (hit.Mat.IsCheckerHack) \n            {\n            \tvec3 fragPos = 0.3 * (ray.Origin + ray.Dir*hit.LengthAlongRay); \n                \n                 // xor checker pattern from iq\n                vec2 q = floor(vec2(fragPos.x, fragPos.z));\n    \t\t\tfloat f = mod(q.x+q.y, 2.0); \n                \n                hit.Mat.BaseColor = mix(_copper, vec3(0.12), f);\n                hit.Mat.Metalness = mix(0., 0., f);\n                hit.Mat.Roughness = mix(0.5, 0.1, f);\n            }\n            \n            \n        \tfloat raySeed = seed + 7.1*float(iFrame) + 5681.123 + float(bounce)*92.13;\n            \n            // Inputs\n            vec3 X = ray.Origin + ray.Dir*hit.LengthAlongRay; \t// x   - The location in space\n            vec3 O = normalize(ray.Origin - X); \t\t\t\t// wo - Direction of the outgoing light\n            vec3 I = hit.Normal + RandomUnitVector(raySeed); \t// wi - Degative direction of the incoming light\n            vec3 N = hit.Normal;\t\t\t\t\t\t\t\t// n   - The surface normal at x\n                \n            float NdotI = max(dot(N,I), 0.0);\n            \n            \n            // Emissive term - L_e(x, wo, lambda, t) - the light emitted from this object\n            vec3 emissive = vec3(0);\n            #if EMISSIVE\n            if (hit.Mat.Emissive > 0.0001)\n            {\n                emissive = hit.Mat.Emissive * vec3(hit.Mat.BaseColor);\n            \taccumulatedLight += attenuation * emissive;\n                \n                // TODO TODO TODO!\n                \n                // Confirm this iterative algo actually solves the rendering equation. I fear emissive and radiance aren't factored in correctly.\n                \n                // Idea: On paper, plot expected values for a few bounces of diff colours and emissivity as though run through a recursive algo\n                //   then compare with results from this iterative algo.\n                \n                // Example scene. Ray path from camera hits red(1,.5,.5), blu_emissive(0,0,1), green(.5,1,.5), sky_emissive(.3,.3,.3)\n                \n                // TODO TODO TODO!\n                \n                \n                // Reset the attenuation\n                //attenuation = hit.Mat.BaseColor;\n            }\n            #endif\n            \n\t\t\t// BRDF term - fr(x, wi, wo, lambda, t) - the material response to light\n            vec3 brdf;\n            {\n                vec3 H = normalize(O + I); // half vec\n                float NdotH = max(dot(N,H), 0.0);\n            \tfloat NdotO = max(dot(N,O), 0.0);\n                float HdotO = max(dot(H,O), 0.0);\n                \n                // Fresnel term\n                vec3 F0 = vec3(0.04); // Good average 'Fresnel at 0 degrees' value for common dielectrics\n                F0 = mix(F0, hit.Mat.BaseColor, vec3(hit.Mat.Metalness));\n                vec3 F = Fresnel_Schlick(HdotO, F0);\n                \n                // BRDF - Cook-Torrance\n                float NDF = Distribution_GGX(NdotH, hit.Mat.Roughness);\n                float G = Geometry_Smith(NdotO, NdotI, hit.Mat.Roughness);\n                float denominator = 4.0 * NdotO * NdotI;\n                vec3 specular = NDF*G*F / max(denominator, 0.0000001); // safe guard div0\n\n                // Diffuse vs Specular contribution\n                //vec3 kS = F;                      // Specular contribution\n                vec3 kD = vec3(1.0) - F;           \t// Diffuse contribution - Note: 1-kS ensures energy conservation\n                kD *= 1.0 - hit.Mat.Metalness; \t\t// Remove diffuse contribution for metals\n\n                vec3 diffuse = kD*hit.Mat.BaseColor/PI;\n                \n                #if DIFFUSE == 0\n                diffuse = vec3(0);\n                #endif\n                \n                #if SPECULAR == 0\n                specular = vec3(0);\n                #endif\n              \n                brdf = diffuse + specular;\n            }\n            \n            \n            // Incoming Radiance - Li(x, wi, lambda, t) - the loop solves this part!\n            vec3 radiance = vec3(1);\n            \n            \n            // The weakening term that scales incoming light by the angle it hits the surface\n            float cosTheta = NdotI;\n           \n            \n            // Outgoing Radiance - Lo = Le + fr*Li*cosTheta\n            vec3 Lo = emissive + brdf*radiance*cosTheta;\n            \n            \n            attenuation *= Lo;\n            ray.Dir = normalize(I);  // Not 100% if ray must be unit length, but it gives me peace of mind.\n        \tray.Origin = hit.Pos + hit.Normal * epsilon; // Slightly off the hit surface stops self intersection\n        }\n        else\n        {\n            // We hit sky!\n            #if SKY\n            accumulatedLight += attenuation * _skyColor;\n            #endif\n            break; // End tracing\n        }\n    }\n    \n    return accumulatedLight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    //vec2 uv = (2.*(fragCoord) - iResolution.xy) / iResolution.yy; // -(aspect,1) -> (aspect,1)\n    vec2 uvNorm = (fragCoord) / iResolution.xy;                     //       (0,0) -> (1,1)\n\tvec2 m = iMouse.xy == vec2(0) \n        ? vec2(.16,-0.2)                                            // Put default cam somewhere perdy\n        : (2.*iMouse.xy - iResolution.xy) / iResolution.yy;         // -(aspect,1) -> (aspect,1)\n    \n    \n    vec3 oldCol = vec3(0);\n    \n    // HandleState\n    float numFramesAccumulated = DecodeNumFramesAccumulated();\n    {\n        oldCol = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;       \n        \n        if(iFrame == 0 || numFramesAccumulated == 0.) {\n            oldCol = vec3(0,0,0);\n        }\n\n        // Track accumulated frames\n        if (ivec2(fragCoord) == ivec2(0,0))\n        {\n            numFramesAccumulated++;\n\n             // Get mouse state\n            bool mousePressed = iMouse.z > 0.0;\n            if (mousePressed) { \n                numFramesAccumulated = 0.; \n            }\n\n            fragColor = EncodeNumFramesAccumulated(numFramesAccumulated);\n            return;\n        }\n    }\n \n    \n    InitScene();\n    \n    \n    vec3 newCol = vec3(0);\n    for (int sampleId = 0; sampleId < SAMPLES_PER_PIXEL; sampleId++) // TODO Test if stratifying samples improves convergence\n    {\n    \tfloat seed = hash11( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*hash11(numFramesAccumulated*float(sampleId)) );\n    \n        // Camera ray\n        Ray ray;\n        {\n            // Position the camera\n            vec3 camPos = 24. * vec3(\n                sin(-m.x*PI), \n                mix(0.05, 2., smoothstep(-.75,.75,m.y)), \n                cos(m.x*PI));\n            vec3 camTarget = vec3(0,1,0);\n\n            \n            // Compute ray at origin from lens\n            vec3 rayStart = APERTURE * 0.5 * vec3(RandomInUnitCircle(seed + 84.123), 0.);\n            vec3 lensRay;\n            {\n                // Sub pixel offset\n                vec2 pixelOffset = hash21(seed+13.271) / iResolution.xy;\n                float s = uvNorm.x + pixelOffset.x;\n                float t = uvNorm.y + pixelOffset.y;\n\n                // Calc point in target image plane\n\t            float focalDist = length(camTarget - camPos);\n                float vertical = focalDist* 2.*tan(radians(VERTICAL_FOV/2.));\n                float horizontal = vertical*aspect;\n                vec3 lowerLeftCorner = -vec3(horizontal/2., vertical/2., focalDist);\n                vec3 rayEnd = lowerLeftCorner + vec3(s*horizontal, t*vertical, 0.);\n                \n                lensRay = normalize(rayEnd - rayStart);\n            }\n\n            \n            // Aim the ray\n            mat3 viewMat = ViewLookAtMatrix(camPos, camTarget, 0.);\n            ray.Origin = camPos + viewMat * rayStart;\n            ray.Dir = viewMat * lensRay;\n        }\n\n        _skyColor = _skyBrightness*mix(vec3(1.), 2.*vec3(.5,.7,1.), 0.5*uvNorm.y + .5);\n        \n    \tnewCol += clamp(ColorPBR(ray, seed), 0., 500.);\n    }\n    newCol /= float(SAMPLES_PER_PIXEL);\n    \n    fragColor = vec4(oldCol + newCol, 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BIG_FLOAT 9999999.\n#define SMOL_FLOAT 0.0000001\n#define PI 3.1415926\n#define TAU 6.2831853\n\n// TYPES //////////////////////////////////////////////////////////////////////////////////\n\nstruct Material\n{\n    vec3 BaseColor; // IsMetal ? Reflectance : Albedo\n\tfloat Metalness;\n    float Roughness;\n    float Emissive; // Emissive strength. Set light color with BaseColor\n    bool IsCheckerHack;\n};\nstruct Sphere\n{\n    vec3 Center;\n    float Radius;\n    Material Mat;\n};\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\nstruct Hit \n{\n    vec3 Pos; // point in space\n    vec3 Normal; // normal of hit surface\n    float LengthAlongRay; // length along ray of hit\n   //bool IsFrontFace; // whether we hit the outside or inside of the surface\n    //int MatId;\n    Material Mat;\n    //bool IsMetal;\n    //bool BaseColor; // IsMetal ? Reflectance : Albedo\n};\n    \n    \nfloat length2(vec2 v) { return dot(v,v); }\nfloat length2(vec3 v) { return dot(v,v); }\n    \n\n// RANDOM /////////////////////////////////////////////////////////////////////////////////\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio - https://www.shadertoy.com/view/WsXBzl\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat randff() { return float(rand())/32767.0; }\n/* usage\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n*/\n\n\n// 1 out, 1 in... https://www.shadertoy.com/view/4djSRW\nfloat hash11(float seed)\n{\n    seed = fract(seed * .1031);\n    seed *= seed + 33.33;\n    seed *= seed + seed;\n    return fract(seed);\n}\n//  1 out, 2 in...  https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 seed)\n{\n\tvec3 p3  = fract(vec3(seed.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// 2 out, 1 in... https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float seed)\n{\n\tvec3 p3 = fract(vec3(seed) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 RandomUnitVector(float seed) \n{\n    vec2 rand = hash21(seed);\n    float a = rand.x*TAU;     //  0 to TAU\n    float z = rand.y*2. - 1.; // -1 to 1\n    float r = sqrt(1. - z*z);\n    return vec3(r*cos(a), r*sin(a), z);\n}\n\nvec3 RandomInUnitSphere(float seed)\n{\n    vec3 hash = hash31(seed);\n    \n    float theta = hash.x * TAU;\n    float v = hash.y;\n    float r = pow(hash.z, 0.333333);\n    \n    float phi = acos((2.*v)-1.);\n    float sinphi = sin(phi);\n    \n    vec3 p;\n    p.x = r * sinphi * cos(theta);\n    p.y = r * sinphi * sin(theta);\n    p.z = r * cos(phi); \n    \n    return p;\n}\n\nvec3 RandomInHemisphere(float seed, vec3 normal) \n{\n    vec3 p = RandomInUnitSphere(seed);\n    return (dot(p, normal) > 0.0) ? p : -p;\n}\n\nvec2 RandomInUnitCircle(float seed)\n{\n    // https://programming.guide/random-point-within-circle.html\n    vec2 rand = hash21(seed);\n    float angle = rand.x*TAU;\n    float radius = sqrt(rand.y);\n    return radius * vec2(cos(angle), sin(angle));\n}\n\n\n\n\n\n// PBR /////////////////////////////////////////////////////////////////////////////////////\n\nvec3 Fresnel_Schlick(float cosTheta, vec3 F0)\n{\n\tcosTheta = min(cosTheta,1.); // fixes issue where cosTheta is slightly > 1.0. a floating point issue that causes black pixels where the half and view dirs align\n\treturn F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n/*vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n\tcosTheta = min(cosTheta,1.); // fixes issue where cosTheta is slightly > 1.0. a floating point issue that causes black pixels where the half and view dirs align\n\tvec3 factor = max(vec3(1.0 - roughness), F0); // make rough surfaces reflect less strongly on glancing angles\n\treturn F0 + (factor - F0) * pow(1.0 - cosTheta, 5.0);\n}*/\nfloat Distribution_GGX(float NdotH, float roughness)\n{\n\tfloat a = roughness*roughness; // disney found rough^2 had more realistic results\n\tfloat a2 = a*a;\n\tfloat NdotH2 = NdotH*NdotH;\n\tfloat numerator = a2;\n\tfloat denominator = NdotH2 * (a2-1.0) + 1.0;\n\tdenominator = PI * denominator * denominator;\n\treturn numerator / max(denominator, SMOL_FLOAT);\n    \n}\nfloat GeometrySchlick_GGX_Direct(float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0; \n\tfloat k = (r*r) / 8.; // k computed for direct lighting. we use a diff constant for IBL\n\treturn NdotV / (NdotV * (1.0-k) + k); // bug: div0 if NdotV=0 and k=0?\n}\nfloat Geometry_Smith(float NdotV, float NdotL, float roughness)\n{\n\tfloat ggx2 = GeometrySchlick_GGX_Direct(NdotV,roughness);\n\tfloat ggx1 = GeometrySchlick_GGX_Direct(NdotL,roughness);\n\treturn ggx1*ggx2;\n}\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}