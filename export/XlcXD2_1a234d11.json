{"ver":"0.1","info":{"id":"XlcXD2","date":"1481572939","viewed":712,"name":"Non Local Means Filter","username":"vsvsv","description":"Straightforward implementation of NLM filter.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["filter","image","denoise","local","nlmeans","non","means"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nconst int kernel = 4;\nconst int window = 2;\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec3 rgb2yuv(vec3 rgb) {\n    return rgb * mat3(0.299, 0.587, 0.114,\n                     -0.147,-0.289, 0.436,\n                      0.615,-0.515,-0.100);\n}\n\nvec3 yuv2rgb(vec3 yuv) {\n    return yuv * mat3(1.0,    0.0,  1.14,\n                      1.0, -0.395,   0.0,\n                      1.0,  2.032,   0.0);\n}\n\nfloat luminocity(vec4 color) {\n    return dot(color.rgb, vec3(0.299, 0.587, 0.114)); //according to michaelm's comment\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat distribute(float x, float dev, float sigma) {\n    return exp(-(x-dev) * (x-dev) / (2.0 * sigma * sigma)) / (sqrt(2.0 * M_PI) * sigma);\n}\n\nfloat comparePatches(vec2 patch_, vec2 original, float sigma) {\n    float w = 0.0;\n    for(int i = -window; i < window; i++) {\n        for(int j = -window; j < window; j++) {\n            vec2 offset = vec2(float(i), float(j)) / iChannelResolution[0].xy;\n            float pCurrent = luminocity(texture(iChannel0, patch_ + offset));\n            float oCurrent = luminocity(texture(iChannel0, original + offset));\n            w = distribute(pCurrent, oCurrent, sigma);\n        }\n    }\n    return w / ((2.0 * float(window) + 1.0) * (2.0 * float(window) + 1.0));\n}\n\nfloat nlmeans(vec2 coords, float sigma) {\n    float processed = 0.0;\n    float weights = 0.0;\n    for(int i = -kernel; i < kernel; i++) {\n        for(int j = -kernel; j < kernel; j++) {\n            vec2 patchCoord = coords + vec2(float(i), float(j)) / iChannelResolution[0].xy;\n            float w = comparePatches(patchCoord, coords, sigma);\n            processed += w * luminocity(texture(iChannel0, patchCoord));\n            weights += w;\n        }\n    }\n    return processed / weights;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float sigma = 0.2 * sin(iTime / 2.0) + 0.2;\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec3 yuv = rgb2yuv(texture(iChannel0, pos).rgb);\n    yuv.x = nlmeans(pos, sigma);\n\tfragColor = vec4(yuv2rgb(yuv), 1.0);\n}","name":"Image","description":"","type":"image"}]}