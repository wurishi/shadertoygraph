{"ver":"0.1","info":{"id":"XlycWK","date":"1566671607","viewed":73,"name":"The End of the Road","username":"dreamur","description":"Never finished this. Figured I might as well share what little has been done.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["road","sidewalk","hopscotch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nvec2 perspective_project( in vec2 _st )\n{\n    float pct = 0.0;\n\t_st += vec2(-1.0, 0.0);\t\t\t\t\t\t// perspective\n    pct  = smoothstep( -2.5, 1.5, -_st.y );\t\n    _st /= pct; \n    \n    return _st;\n}\n\nfloat rect( in vec2 _st, in vec2 w, in vec2 h )\n{\n    vec2 bl = step( vec2(w.x, h.x),_st);       // bottom-left\n\tvec2 tr = step( vec2(w.y, h.y),1.0 - _st);   // top-right\n\treturn bl.x * bl.y * tr.x * tr.y;\n}\n\nfloat circle( in vec2 _st, in float radius, in float inner, in float outer )\n{\n\tvec2 dist = _st - vec2(0.5);\n    return 1.0 - smoothstep( radius * inner, radius * outer, dot(dist, dist) * 4.0 );  \n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat tk_baha(in vec2 st, in float c) {\n    float amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(st.x * frequency);\n    float t = 0.01 * (-iTime * 150.0);\n    y += sin(st.x + t * c)*2.5;\n    y *= amplitude * 0.06;\n    \n    return y;\n}\n\n// 2D Noise from Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 rotate( in vec2 _st, in float angle ) {\n\treturn mat2( cos(angle * PI), -sin(angle * PI),\n                 sin(angle * PI), cos(angle * PI) ) * _st;    \n}\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n// from \"The Book of Shaders\"\n//  Chapter 9: Patterns\n//  https://thebookofshaders.com/09/\nvec2 brickTile(vec2 _st, float _zoom) {\n    _st *= _zoom;\n    _st.x += step(1., mod(_st.y,2.0)) * 0.5;\n    return fract(_st);\n}\n\n// based off of lines() from \"The Book of Shaders\"\n//  https://thebookofshaders.com/edit.php#11/wood.frag\nfloat grafitti(in vec2 pos, float b) {\n    float scale = 10.0;\n    pos *= scale;    \n    return smoothstep(0.0, 1.25 + b * 0.5, abs((sin(pos.x*3.1415)+b*2.2)) * 0.25);\n}\n\n// https://thebookofshaders.com/06/\n// Also...\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ) { \n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat decay(in vec2 st, in float coef_x, in float coef_y)\n{\n    vec2 scalar = vec2(2.5 + noise(st * coef_x), 2.5 + noise(st * coef_y));\n    vec2 shift = vec2(2.6 + noise(st), -6.95 + noise(st) );\n    return rect( (rotate(st, 0.33) * scalar - shift), vec2(0.01), vec2(0.05) );\n}\n\nfloat hopscotch(in vec2 st)\n{\n    float pct = 0.0, res = 0.0;\n    for(int i = 0; i < 6; i++)\n    {\n        if(res == 0.6)\n        {\n            pct += rect( st - vec2(res, 0.1), vec2(0.4), vec2(0.4) );\n            pct -= rect( st - vec2(res, 0.1), vec2(0.415), vec2(0.415) );\n            pct += rect( st - vec2(res, -0.1), vec2(0.4), vec2(0.4) );\n            pct -= rect( st - vec2(res, -0.1), vec2(0.415), vec2(0.415) );    \n        }\n        else\n        {\n            pct += rect( st - vec2(res, 0.0), vec2(0.4), vec2(0.4) );\n            pct -= rect( st - vec2(res, 0.0), vec2(0.415), vec2(0.415) );\n        }\n\n        res += 0.2;\n    }\n    \n    return pct;\n}\n\nfloat seams(in vec2 st)\n{\n    float pct = 0.0, res = 0.0;\n    for(int i = 0; i < 5; i++)\n    {\n        pct += rect( (st * vec2(85.0, 7.75)) + vec2(14.5 - res, -0.6), vec2(0.175), vec2(0.05) );\n        res += 60.0 + clamp(float(i), 0.0, 1.0);\n    }\n    \n    st = perspective_project(st);\n    \n    res = 0.0;\n    for(int i = 0; i < 6; i++)\n    {\n        pct += rect( (st * vec2(60.0, 2.0)) + vec2(185.0 - res, -0.6), vec2(0.175), vec2(0.05) );\n        res += 70.0;\n    }\n    res = 0.0;\n    for(int i = 0; i < 5; i++)\n    {\n        pct += rect( (st * vec2(60.0, 1.0)) + vec2(140.0 - res, 1.35), vec2(0.175), vec2(0.05) );\n        res += 70.0;\n    }\n    \n    return pct;\n}\n    \nfloat lamp_shadow(in vec2 _st)\n{\n    float res = 0.0, pct = 0.0;\n    res = step(0.5, mod(iTime, 2.0) * mod(iTime, 3.5));\n    pct = rect( (_st * vec2(3.2, 0.35)) - vec2(4.65, 0.0945), vec2(0.2), vec2(0.05) ); \n\n    //tmp2_2 = tmp2;\t\t\t\t\t\t\t\t\t// perspective (for shadow bits)\n    _st = perspective_project(_st);\n    \n    pct += rect( (_st * vec2(2.0, 7.0)) + vec2(-1.55, -3.6), vec2(0.2), vec2(0.05));\n    pct += rect( (_st * vec2(1.2, 7.0)) - vec2(0.7, 2.70), vec2(0.2), vec2(0.05));\n    pct += rect( (_st * vec2(3.0, 4.35)) - vec2(2.70, 2.5), vec2(0.2), vec2(0.05));\n    \n    return pct * res;\n}\n\nfloat lamp(in vec2 _st)\n{\n    float pct = 0.0;\n    pct = rect( (_st * vec2(1.75, 12.0)) + vec2(-2.35, -2.7), vec2(0.2), vec2(0.05) );\n    pct += rect( (_st * vec2(2.5, 12.0)) + vec2(-3.58, -3.5), vec2(0.2), vec2(0.05) );\n    pct += rect( (_st * vec2(4.1, 0.35)) + vec2(-6.2, -0.078), vec2(0.2), vec2(0.05) );\n    return pct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n\n    st  \t-= 0.5;\n    st.x \t*= iResolution.x / iResolution.y;\n    st \t+= 0.5;\n    \n    float pct = 0.0, res = 0.0;\n    vec2 tmp2;\n    vec3 col = vec3(0.0, 0.059, 0.286), tmp3;\t\n    \n    tmp2 = st * 2.0 - 1.0;\n    tmp2 += vec2(1.0, 0.5);\n   \t\n    // brick wall + inlay\n    vec2 tmp2_2 = tmp2;\n    pct = rect( (tmp2_2 * vec2(0.25, 0.5)) + vec2(0.25, 0.0), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.765, 0.898, 0.831), pct );\n    tmp2_2 /= vec2(2.15,0.65) / 1.5;\n    tmp2_2 = brickTile(tmp2_2 - vec2(0.0, -0.08), 5.0);\n    pct *= rect(tmp2_2, vec2(0.0125), vec2(0.0375));\n    col = mix( col, vec3(0.427, 0.0, 0.0), pct );\n    \n    // grafitti 1  \n    tmp2_2 = tmp2;\n    tmp2_2 += tk_baha(tmp2, 4.1);\t\t// wind animation (for grafitti)\n    tmp2_2 -= tk_baha(tmp2_2, 4.1) / 2.0; \n    tmp3 = hsb2rgb(vec3(tmp2_2.x * 0.2 - 0.29, 1.0, tmp2_2.y)); \n    \n    tmp2_2 = vec2(0.85) - tmp2_2;\n    float r = length(tmp2_2)*2.0;\n    float a = atan(tmp2_2.y,tmp2_2.x);\n    float f = cos(a * 3.0);\n    \n    pct = circle(tmp2 - vec2(1.35, 0.5), noise(tmp2_2.yx * r - tmp2_2.y + a * a - f), 1.0, 2.00); \n    col = mix(col, tmp3, pct);\n    \n    // road\n\tfloat rd = rect( (tmp2 * vec2(0.25, 2.20)) + vec2(0.25, 0.76), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.039, 0.039, 0.039), rd );\n    \n    // sidewalk\n    pct = rect( (tmp2 * vec2(0.25, 2.80)) + vec2(0.25, -0.20), vec2(0.01), vec2(0.05) );\n    pct += rect( (tmp2 * vec2(0.25, 2.80)) + vec2(0.25, 1.85), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.345), pct );\n    pct = rect( (tmp2 * vec2(0.25, 8.0)) + vec2(0.25, -0.65), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.184), pct );\n       \n    // street lamp + shadow    \n    col = mix( col, vec3(0.0), lamp_shadow(tmp2));    \n    col = mix( col, vec3(0.075, 0.063, 0.0), lamp(tmp2) );   \n        \n    // lamp glow\n    res = step(0.5, mod(iTime, 2.0) * mod(iTime, 3.5));\n    pct\t= circle(tmp2 - vec2(1.25, 1.2), res, -2.65, 2.00);\n    col\t= mix(col, vec3(3.5), pct);\n    \n    tmp2_2 = tmp2;\n    \n    \n    tmp2 = perspective_project(tmp2); \n       \n    \n    // road-stripes\t\n    pct = 0.0;\n    res = 0.0;\n    pct += rect( (tmp2 * vec2(0.125, 14.0)) + vec2(0.5 - res, 2.2), vec2(0.01), vec2(0.05) );\n    pct += rect( (tmp2 * vec2(0.125, 14.0)) + vec2(0.5 - res, 3.4), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.592, 0.765, 0.0), pct );\n    \n    // sidewalk seams    \n    col = mix( col, vec3(0.0), seams(tmp2_2) );\n    col = mix( col, vec3(0.0), 0.8 );\n    \n    \n    // starfield\n    pct = rd;\n    pct = decay(tmp2_2, 48.0, 32.0);\n    res = decay(tmp2_2 * vec2(1.0, 1.0) - vec2(0.15, 0.25), 10.0, 10.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(1.0, 1.0) - vec2(0.15, 0.25), 10.0, 10.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.7, 0.7) - vec2(-0.4, -0.25), 10.0, 10.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.35, 0.4) - vec2(-1.45, -0.10), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.35, 0.4) - vec2(-1.35, 0.1), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.56, 0.56) - vec2(-0.85, 0.25), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.75, 0.75) - vec2(-0.4, 0.35), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.75, 0.75) - vec2(-0.50, 0.0), 10.0, 10.0);\n    pct += res - pct * res;\n    pct *= rd;\n    col = mix( col, vec3(0.0, 0.0, 0.421), pct);\n      \n    tmp2_2.x = random(tmp2 * 3512.0);\n    tmp2_2.y = random(tmp2 * 8461.0);\n    tmp2_2.x = pow(tmp2_2.x, 21.0);\n    tmp2_2.y = pow(tmp2_2.y, 16.0);\n       \n    pct *= tmp2_2.x * tmp2_2.y * sin((tmp2.x - 21.0 - (iTime / 3.85) + cos(tmp2.y * 14.0 + 31.0)) * 13.0);\n    col += pct;\n    \n    \n    \n    tmp2 += tk_baha(tmp2, 4.78);\t\t// wind animation\n    tmp2 -= tk_baha(tmp2, 2.78) / 1.5;   \t\n    \n    // hop scotch\n    tmp2 = (tmp2 * vec2(0.5, 1.1)) - vec2(-1.8, 0.10);    \n    col = mix(col, vec3(0.2), hopscotch(tmp2));\n    \n    // wind\n    tmp2_2 = vec2(st * 1.5 + vec2(3.0 - iTime * 2.5, 4.0));\n    pct = noise(tmp2_2);\n    col += vec3(pct) / 3.0;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}