{"ver":"0.1","info":{"id":"WsyczG","date":"1603071851","viewed":320,"name":"Convolution (Blur/Sharpen/Blob)","username":"BGrater","description":"Study of single-pass image convolution with symmetrical filters.\n\nMouse (hold left click):  [x] Radius/Strength, [y] Mip Level\nKeys (hold):  [Default] Blur (Gaussian), [1] Blur (Tent), [2] Blur (Box), [3] Sharpen (+LoG), [4] Blob (-LoG), [0] None","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["2d","blur","filter","blob","convolution","gaussian","sharpen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Requires WebGL 2.0/GLSL ES 3.00 */\nconst float PI = 3.1415926;\nconst float epsilon = 0.00001;\n\nconst float MIPMAP_DEFAULT_LEVEL = 2.0;\nconst float MIPMAP_MAX_LEVEL = 3.0;\nconst int KERNEL_DEFAULT_RADIUS = 5;\nconst int KERNEL_MAX_RADIUS = 9;\nconst int KERNEL_MAX_SIZE = KERNEL_MAX_RADIUS * KERNEL_MAX_RADIUS;\nconst int FILTER_TYPE_NONE = -1;\nconst int FILTER_TYPE_GAUSSIAN = 0;\nconst int FILTER_TYPE_TENT = 1;\nconst int FILTER_TYPE_BOX = 2;\nconst int FILTER_TYPE_LAPLACIAN = 3;\nconst int FILTER_TYPE_NEGLAPLACIAN = 4;\nconst float FILTER_SIGMA = 0.4;\n\n\nstruct Kernel\n{\n    int filterType;\n    int radius;\n    float sum;\n    float[KERNEL_MAX_SIZE] data;\n};\n\n\nfloat gaussian2d(vec2 i, float s)\n{\n    float ss2 = s * s * 2.0;\n    return 1.0 / (PI * ss2) * exp(-dot(i, i) / ss2);\n}\n\nfloat tent2d(vec2 i)\n{\n    return max(1.0 - abs(i.x), 0.0) * max(1.0 - abs(i.y), 0.0);\n}\n\nvoid generateKernel(out Kernel kernel, int radius, int filterType)\n{\n    // Symmetrical quarter kernels.  In an application this would be passed in as a uniform.\n    int radiusSq = radius * radius;\n    float sum = 0.0;\n    float sumRec = 0.0;\n    float[KERNEL_MAX_SIZE] data;\n    \n    switch(filterType) // Same value for all invocations each frame (no thread divergence).\n    {\n        case FILTER_TYPE_GAUSSIAN:\n        {\n            float s = 1.0 / float(radius);\n            \n            for(int i = 0; i < radiusSq; i++)\n            {\n                float r = float(i / radius);\n                float c = float(i % radius);\n                \n                float v = gaussian2d(vec2(c * s, r * s), FILTER_SIGMA);\n                data[i] = v;\n                \n                \n                float rMirror = float(r != 0.0);\n                float cMirror = float(c != 0.0);\n                \n                sum += v;\n                sum += cMirror * v;\n                sum += rMirror * v;\n                sum += rMirror * cMirror * v;\n            }\n            \n            sumRec = 1.0 / sum;\n        }\n        break;\n        \n        case FILTER_TYPE_TENT:\n        {\n            float s = 1.0 / float(radius);\n            \n            for(int i = 0; i < radiusSq; i++)\n            {\n                float r = float(i / radius);\n                float c = float(i % radius);\n                \n                float v = tent2d(vec2(c * s, r * s));\n                data[i] = v;\n                \n                float rMirror = float(r != 0.0);\n                float cMirror = float(c != 0.0);\n                \n                sum += v;\n                sum += cMirror * v;\n                sum += rMirror * v;\n                sum += rMirror * cMirror * v;\n            }\n            \n            sumRec = 1.0 / sum;\n        }\n        break;\n        \n        case FILTER_TYPE_BOX:\n        {\n            int width = radius * 2 - 1;\n            sum = float(width * width);\n            sumRec = 1.0 / sum;\n            \n            for(int i = 0; i < radiusSq; i++)\n                data[i] = 1.0;\n        }\n        break;\n        \n        case FILTER_TYPE_LAPLACIAN:\n        {\n            radius = 2;\n            \n            data[0] = 4.0;\n            data[1] = -1.0;\n            data[2] = -1.0;\n            data[3] = 0.0;\n        }\n        break;\n        \n        case FILTER_TYPE_NEGLAPLACIAN:\n        {\n            radius = 2;\n            \n            data[0] = -4.0;\n            data[1] = 1.0;\n            data[2] = 1.0;\n            data[3] = 0.0;\n        }\n        break;\n        \n        default:\n        {\n            radius = 1;\n            data[0] = 1.0;\n        }\n    }\n    \n    \n    // Normalize\n    for(int i = 0; i < int(sumRec > 0.0) * radiusSq; i++)\n    {\n        data[i] *= sumRec;\n    }\n    \n    \n    kernel.sum = sum;\n    kernel.filterType = filterType;\n    kernel.radius = radius;\n    kernel.data = data;\n}\n\n\n\nvec4 convolution(sampler2D image, vec2 uv, vec2 scale, const Kernel kernel, float mipLevel)\n{\n    // Single-pass symmetric kernel convolution\n\tvec4 col = vec4(0.0);\n\tint radius = kernel.radius;\n\tint radiusSq = radius * radius;\n    float tileSize = float(mipLevel < 1.0) + float(int(mipLevel) << 1);\n    \n    for(int i = 0; i < radiusSq; i++)\n    {\n    \tfloat v = kernel.data[i];\n    \t\n    \tfloat r = float(i / radius) * tileSize;\n    \tfloat c = float(i % radius) * tileSize;\n    \tfloat rMirror = float(r > 0.0);\n    \tfloat cMirror = float(c > 0.0);\n    \t\n        // 4x texture fetches (discrete pixel sampling)\n    \tcol += textureLod(image, uv + vec2(-c, r) * scale, mipLevel) * v;\n    \tcol += cMirror * textureLod(image, uv + vec2(c, r) * scale, mipLevel) * v;\n    \tcol += rMirror * textureLod(image, uv + vec2(-c, -r) * scale, mipLevel) * v;\n    \tcol += rMirror * cMirror * textureLod(image, uv + vec2(c, -r) * scale, mipLevel) * v;\n    }\n    \n    return col;\n}\n\n\n\nvec4 drawKernelUI(vec2 uv, const Kernel kernel, float radiusStrength, float mipLevel)\n{\n    vec4 uiCol = vec4(0.0, 0.2, 0.9, 0.6);\n    \n    // Mip bar\n    const float mipBarScale = 0.1;\n    vec4 mipBarRect = vec4(0.35, mipLevel / (MIPMAP_MAX_LEVEL + epsilon) * mipBarScale, 0.365, 0.03);\n    float mipBar = float(uv.x > mipBarRect.x && uv.x < mipBarRect.z && uv.y > mipBarRect.w && uv.y < (mipBarRect.y + mipBarRect.w));\n    mipBar *= float(fract((uv.y - mipBarRect.w) * MIPMAP_MAX_LEVEL / mipBarScale) < 0.9);\n    \n    // Function graph\n    const float vRange = 0.25;\n    const float graphBottom = 0.03;\n    const float graphMax = 0.25;\n    const vec2 graphScale = vec2(0.25, 0.4);\n    const float fMaxRadiusRec = 1.0 / (float(KERNEL_MAX_RADIUS) - 0.5);\n    float xCenter = (uv.x - 0.5) * 2.0;\n    \n    float fX = (xCenter / graphScale.x) / ((float(kernel.radius) - 0.5) * fMaxRadiusRec);\n    float f = 0.0;\n    f += float(kernel.filterType == FILTER_TYPE_GAUSSIAN) * gaussian2d(vec2(fX, 0.0), FILTER_SIGMA);\n    f += float(kernel.filterType == FILTER_TYPE_TENT) * tent2d(vec2(fX, 0.0));\n    f += float(kernel.filterType == FILTER_TYPE_BOX) * float(abs(fX) <= 1.0);\n    f -= float(kernel.filterType >= FILTER_TYPE_LAPLACIAN);\n    f *= graphScale.y;\n    \n    float funcLine = float(abs(xCenter) < graphMax && uv.y > (f * vRange + graphBottom) && uv.y < (f * vRange + graphBottom + 0.005));\n    \n    // Kernel graph (unnormalized)\n    int i = int(abs(xCenter / graphScale.x * (float(KERNEL_MAX_RADIUS) - 0.5)) + 0.5);\n    float k = float(i < kernel.radius) * kernel.data[i] * kernel.sum * graphScale.y;\n    \n    float kernelBars = float(uv.y > graphBottom && uv.y < (k * vRange + graphBottom));\n    \n    float kernelColFade = 1.0 - (float(i) / float(KERNEL_MAX_RADIUS)) * 0.5;\n    vec4 kernelCol = vec4(0.0, kernelColFade, kernelColFade, 0.7) * kernelBars;\n    \n    // Radius bar\n    float radiusStrengthBar = float(uv.y < 0.02 && abs(xCenter) < (floor(radiusStrength) - 0.5) * fMaxRadiusRec * graphScale.x);\n    \n    // Combine UI elements\n    return mix(uiCol * (mipBar + radiusStrengthBar + funcLine), kernelCol, kernelCol.a);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input\n    float mouseEnable = float(iMouse.xy != vec2(0.0));\n    \n    float mipLevel = MIPMAP_DEFAULT_LEVEL;\n    mipLevel += mouseEnable * floor(mix(-MIPMAP_DEFAULT_LEVEL, MIPMAP_MAX_LEVEL - MIPMAP_DEFAULT_LEVEL, min(iMouse.y / iResolution.y * 1.3, 1.0)));\n    \n    float radiusStrength = float(KERNEL_DEFAULT_RADIUS);\n    radiusStrength += mouseEnable * mix(float(1 - KERNEL_DEFAULT_RADIUS), float(KERNEL_MAX_RADIUS - KERNEL_DEFAULT_RADIUS), min(abs(iMouse.x / iResolution.x - 0.5) * 2.5, 1.0));\n    \n    int filterType = FILTER_TYPE_GAUSSIAN;\n    filterType += int(texelFetch(iChannel1, ivec2(48,0), 0).x) * FILTER_TYPE_NONE;\t\t\t\t\t\t\t\t\t// '0'\n    filterType += int(filterType == 0) * int(texelFetch(iChannel1, ivec2(49,0), 0).x) * FILTER_TYPE_TENT;\t\t\t// '1'\n    filterType += int(filterType == 0) * int(texelFetch(iChannel1, ivec2(50,0), 0).x) * FILTER_TYPE_BOX;\t\t\t// '2'\n    filterType += int(filterType == 0) * int(texelFetch(iChannel1, ivec2(51,0), 0).x) * FILTER_TYPE_LAPLACIAN;  \t// '3'\n    filterType += int(filterType == 0) * int(texelFetch(iChannel1, ivec2(52,0), 0).x) * FILTER_TYPE_NEGLAPLACIAN;\t// '4'\n    \n    \n    // Generate kernel\n    Kernel kernel;\n    generateKernel(kernel, int(radiusStrength), filterType);\n    \n    \n    // Image\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = convolution(iChannel0, uv, 1.0 / iChannelResolution[0].xy, kernel, mipLevel);\n    \n    // Sharpen strength\n    col *= float(filterType != FILTER_TYPE_LAPLACIAN) + (float(filterType == FILTER_TYPE_LAPLACIAN) * radiusStrength * 0.3);\n    col += float(filterType == FILTER_TYPE_LAPLACIAN) * textureLod(iChannel0, uv, mipLevel);\n    \n    // Edge strength\n    col *= 1.0 + (float(filterType == FILTER_TYPE_NEGLAPLACIAN) * radiusStrength * 0.5);\n    \n    // UI\n    vec4 uiCol = drawKernelUI(uv, kernel, radiusStrength, mipLevel);\n    \n    col = mix(col, uiCol, uiCol.a);\n    \n    \n    // Output to screen\n    fragColor = clamp(vec4(col.rgb,1.0), 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}