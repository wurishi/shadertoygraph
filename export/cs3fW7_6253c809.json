{"ver":"0.1","info":{"id":"cs3fW7","date":"1697218754","viewed":63,"name":"ex001","username":"opqa","description":"Playing with a modified perlin generator.\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define M_PI2 6.2831853071795864769252867675590\nprecision highp float;\n\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float MIN_DIST = 1.;\nconst float MAX_DIST = 250.0;\nconst float EPSILON = 0.03;\n\n\n\nvec2 grad( ivec2 z)  {\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    float nn = float(n);\n    return vec2(cos(nn),sin(nn));\n}\n\nfloat noise(vec2 p)\n{\n    ivec2 i = ivec2(floor( p ));\n    ivec2 ri = ivec2(1,0);\n    vec2 rf = vec2(1.,0.);\n    vec2 f = fract( p );\n    //vec2 u = .5*(1.-cos(M_PI*f));\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix(\n        mix(\n            dot(grad( i + ri.yy), f - rf.yy),\n            dot(grad( i + ri.xy), f - rf.xy),\n            u.x\n        ),\n        mix(\n            dot(grad( i + ri.yx), f - rf.yx),\n            dot(grad( i + ri.xx), f - rf.xx),\n            u.x\n        ),\n        u.y\n    );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat planeSDF( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat baseNoise(vec3 p)\n{\n    vec2 tp = p.xz * .02;\n    float n = noise(tp) + .5;\n    float bn = noise(tp + vec2(.01, .01)) + .5;\n    if (bn < n) {\n        n += (bn - n) * 50.;\n        float bbn = noise(tp + vec2(.02, .02)) + .5;\n        if (bbn < bn) {\n            n += (bbn - bn) * 20.;\n        }\n    }\n    return (n - .5) * .15;\n\n}\n\nfloat smoothPlane(vec3 p)\n{\n    float np = baseNoise(p);\n    float h = np * 60.;\n    return planeSDF(p, normalize(vec3(0., 1., 0.)), h);\n}\n\nfloat mapPlane(vec3 p)\n{\n    return smoothPlane(p);\n    float np = baseNoise(p);\n    float h = np * 60.;\n    h += noise(p.xz*(1.-np*100.))*(sin(p.x*.5+p.z*np*.1)*(np*100.)*.04)*.1;\n    return planeSDF(p, normalize(vec3(0., 1., 0.)), h);\n}\n\nfloat map(vec3 p) {\n    return mapPlane(p);\n}\n\n\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float w )\n{\n    float res = 1.0;\n    float t = 0.01;\n    float maxt = 5.2;\n\n    for( int i=0; i<127 && t < maxt; i++ )\n    {\n        float h = map(ro + rd*t);\n        res = min( res, h/(w*t));\n        t += clamp( h, 0.1, 0.1);\n\t\tif( res< -1. || t > maxt) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n float sceneSDF(vec3 p) {\n    return map(p);\n}\n\n\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON * 5.) {\n\t\t\treturn vec2(depth, float(i) / float(MAX_MARCHING_STEPS));\n        }\n        depth += dist;\n        if (depth >= end) {\n            return vec2(end, float(i) / float(MAX_MARCHING_STEPS));\n        }\n    }\n    return vec2(end, 1.);\n}\n\nfloat shortestDistanceToFloorPlane(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float max = float (MAX_MARCHING_STEPS) / 10.;\n    for (float i = 0.; i < max - depth; i++) {\n        float dist = smoothPlane(eye + depth * marchingDirection);\n        if (dist < EPSILON / depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = vec3(0.8);\n    vec3 color = ambientLight * k_a;\n    vec3 light1Pos = vec3(-1.0 ,\n                          7.0,\n                          2.0 + iTime + -3.);\n    vec3 light1Intensity = vec3(0.8, 0.7, 0.5) * 1.3;\n    vec3 light = phongContribForLight(k_d, k_s, alpha, p, eye,\n    light1Pos,\n        light1Intensity)\n        * (calcSoftShadow(p, light1Pos, 130.) * 30.);\n    return color += light;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord.xy);\n\n    vec3 pos3D = vec3(cos(iTime * .05) * 500., 20., sin(iTime * .05) * 500.);\n    float groundY = shortestDistanceToFloorPlane(pos3D, vec3(0., -1., 0.), MIN_DIST, MAX_DIST);\n    pos3D.y = 25. - groundY;\n    //pos3D.y = groundY + 1.;\n    float fwAng = atan(pos3D.z, pos3D.x) - M_PI * .5 + .2;\n    vec3 fw = normalize(vec3(cos(fwAng), 0., sin(fwAng)));\n    vec3 eye = pos3D + fw;\n    vec3 center = pos3D;\n    mat4 viewToWorld = viewMatrix(eye, center, vec3(0.0, 1.0, 0.0));\n\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n    vec2 dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    if (dist.x > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.3, 0.5, 1.0) + uv.y * .5;\n\t\treturn;\n    }\n\n    vec3 p = eye + dist.x * worldDir;\n\n    fragColor = vec4(\n        vec3(dist.x * .01, dist.y * 2., .4),1.0);\n    return;\n\n\n    vec3 K_a = vec3(0.2275, 0.1922, 0.1176) * 1.;\n    vec3 K_d = vec3(0.2902, 0.2588, 0.1333) * 1.;\n    vec3 K_s = vec3(0.6941, 0.6588, 0.8784);\n    float shininess = 1.1;\n\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}