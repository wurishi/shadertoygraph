{"ver":"0.1","info":{"id":"wtGXRw","date":"1582461109","viewed":440,"name":"ShaderDojo 045","username":"antonOTI","description":"Reproduction of \nhttps://twitter.com/antonkudin/status/1231193061738328069","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["raymarch","remix","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderDojo045 By Anton\n// cc by\n\n// source inspiration : twitter.com/antonkudin/status/1231193061738328069\n// by @antonkudin\n\n// ------------------------------------------------------- //\n// Sea distance function taken from Seascape shader by TDM\n// shadertoy.com/view/Ms2SD1\n// sea\nconst int ITER_GEOMETRY = 5;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 3.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\n#define SEA_TIME (1.25 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    \n    // Faking an horizon.\n    p.y += pow(length(p.xz) * .05, 2.);\n    \n    return p.y - h;\n}\n\n// ---------------- End of Seascape part ----------------- //\n// ------------------------------------------------------- //\n\nvec3 normal(vec3 p)\n{\n    // Intentionally skewing the normals so the sea reflection appear smoother than the sea.\n    vec2 e = vec2(1.2,.0);\n    return normalize(vec3(\n    \tmap(p + e.xyy) - map(p - e.xyy),\n    \tmap(p + e.yxy) - map(p - e.yxy),\n    \tmap(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid ray(inout vec3 cp,in vec3 rd,out float st,out float cd,out float d)\n{\n    for(st = 0.; st < 1.; st += 1. / 256.)\n    {\n        cd = map(cp);\n        if(abs(cd) < .01 || cd > 10.)\n        {\n           break;\n        }\n        \n        d += cd;\n        cp += rd * cd ;\n    }\n}\n\nvec3 lookAt(vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 fd = normalize(ta - ro);\n    vec3 up = cross(fd, vec3(1.,0.,0.));\n   \tvec3 ri = cross(fd, up);\n    \n   return normalize(fd - ri * uv.x + up * uv.y); \n}\n\nvec3 blueSky = vec3(.0001, .00002, .005) ;\nvec3 sunCol = vec3(.006,.002,.2);\nvec3 darkBlue = vec3(.00005,.00001,.00015);\nvec3 riseUp = vec3(.15,.12,.3);\nvec3 starCol = vec3(.15,.025,.5) * 1.5;\nvec3 seaCol = vec3(.004,.012,.032);\n\nvec3 sunDir = normalize(vec3(0.,.4,1.));\nfloat sunRadius = .01;\n\nfloat rotSpeed = .0002;\nfloat starWidth = .005; // overriden at the start of mainImage.\n\nvec3 skyCol(vec3 rd)\n{\n    float sky = dot(rd, sunDir);\n    \n    vec3 up = cross(-sunDir, vec3(0.,1.,0.));\n    vec3 ri = cross(up, -sunDir);\n    vec2 dp = vec2(dot(rd, ri), dot(rd,up));\n    \n    float sunRim = sky - 1. + sunRadius;\n    float circle = 1. - smoothstep(.0005,.0014, abs(sunRim));\n    \n    float innerFactor = smoothstep(sky-1.01,sky-1., -sunRadius);\n    vec3 col = sunCol * pow(sky, 16.) * innerFactor;\n    circle *= circle;\n    sky = pow(sky, 19.);\n    sky = clamp(sky *2.2, 0.,1.);\n    col = mix(col, blueSky, 1. - sky);\n    float t = -.4;\n    float d = .5;\n    col = mix(riseUp, col, smoothstep(t, t + d, rd.y));\n    \n    col += circle + pow(1. - abs(sunRim), 512.) * innerFactor;\n    \n    return col;\n}\n\nvec3 skyStars(vec3 rd)\n{\n    \n    float sky = dot(rd, sunDir);\n    \n    \n    vec3 up = cross(-sunDir, vec3(0.,1.,0.));\n    vec3 ri = cross(up, -sunDir);\n    vec2 dp = vec2(dot(rd, ri), dot(rd,up));\n    float a = atan(-dp.y, dp.x) / TAU + .5;\n\n\tfloat starSpace = length(vec2(dot(up,rd),dot(ri,rd)));\n    float starId = floor(starSpace / starWidth);\n   \tfloat starY = abs(mod(starSpace, starWidth)/starWidth - .5) * 2.;\n    float hashedId = hash11(starId);\n    a = fract(a + hashedId * 100. + (iTime * starId * (1. + hashedId * .2)) * -rotSpeed);\n    float star = length(vec2((max(a- .5,.0)) / starWidth, starY));\n    star = (1.-smoothstep(.0,2.,star)) * smoothstep(.05,.25,a) * (hashedId * .2 + .8);\n    \n    float circle = 1. - step(.0025,abs(sky - 1. + sunRadius));\n    \n    circle *= circle;\n    star *= max(step(sky -1., -sunRadius) - circle, 0.);\n    \n    return starCol * pow(star, 8.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\tvec3 col = vec3(0.);\n    \n    float len = length(uv - vec2(0.,.2));\n    float a = (atan(uv.y, uv.x) + PI) / TAU;\n    \n    \n    starWidth = 2.5 / iResolution.y;\n    float bobAmp = .5;\n    float bobTime = iTime * .125;\n    vec3 cp = vec3(0. + cos(bobTime) * bobAmp,2. + sin(bobTime * 2.) * bobAmp,-8. + sin(bobTime * .33));\n    vec3 ta = vec3(0.,2.5,0.);\n    vec3 rd = lookAt(cp,ta,uv);\n    \n    float st, cd, dist;\n    ray(cp, rd, st, cd, dist);\n    \n    col = skyCol(rd) + skyStars(rd);\n        \n    if(cd < .01)\n    {\n        vec3 norm = normal(cp);\n        float si = clamp(dot(norm, -rd), 0.,1.);\n        \n        float skyUpI = clamp(dot(norm, vec3(0.,1.,0.)),0.,1.);\n        col = mix(seaCol, darkBlue, pow(skyUpI, 3.));\n        \n        vec3 refl = reflect(rd, norm);\n        \n        float skyFdI = dot(refl, normalize(vec3(0.,1.,1.)));\n        \n        vec3 skyFdCol = skyCol(refl);\n        col += skyFdCol * pow(skyFdI, 16.) * .95;\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define TAU  6.28319\n\n// Hashes from https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}","name":"Common","description":"","type":"common"}]}