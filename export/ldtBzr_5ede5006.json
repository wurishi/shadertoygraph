{"ver":"0.1","info":{"id":"ldtBzr","date":"1538624471","viewed":320,"name":"Iso Explosion Shockwave","username":"Carandiru","description":"copy of 2D dispersion shader. changed some styff for speed and ... this was prototyping for software rendering on STM32 F7 MCU graphics","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["shockwave","isometric","dispersion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wave-despersion 2d with implicit-surface ray-tracer by Jakob Thomsen\n// Waves-dispersion function by FabriceNeyret2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define M_PI 3.1415926\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float DisplacementScalar = 8.0f;\nconst float InvDisplacementScalar = 1.0f / DisplacementScalar;\n\nfloat localtime;\n\n//float sfract(float val, float scale)\n//{\n//    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n//}\n\nfloat singlewave(float x, float c, float t)\n{\n    float X = x - t * t;\n    return -cos(c * X) * exp(-X * X);\n}\nfloat wave(float x, float k, float c, float t)\n{\n    float X = x - c * t;\n    return -cos(k * X) * exp(-X * X);\n}\n\nfloat sdTorus( vec2 p, float t )\n{\n  vec2 q = vec2(length(p)-t,sqrt(p.x*p.x+p.y*p.y));\n  return length(q)*exp(-t)+sin(t);\n}\nfloat sdSphere( vec2 p, float s )\n{\n  return length(p)-s;\n}\nfloat udBox( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nvec2 opRep( vec2 p, vec2 c )\n{\n    vec2 q = mod(p,c)-0.5*c;\n    return q;\n}\n\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p, float t)\n{\n    float n = -mod(t * 0.2,-2.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p, float r, float t)\n{\n    R(p.yx, iMouse.x*0.008*M_PI+t*0.1);\n\tp = p/1.5f;\n\t//float VolExplosion = VolumetricExplosion(p/0.5)*0.5; // scale\n    \n    \n    float final = sdSphere(p.xy,t-r) * 0.25f;\n   // final += noise(p*12.5)*.2;\n\t//final *= 0.5f-perlin_noise(vec3(p.xy,t));\n    final += SpiralNoiseC(p.zxy*0.4132+333., t)*(4.0f-r); //1.25;\n\n    return (1.0f-final) * 0.25f;\n}\nfloat dispersion2d(vec2 v, float t) // testing FabriceNeyret2's waves dispersion function (source: https://www.shadertoy.com/view/MtBSDG)\n{\n   // float r = ((InvDisplacementScalar/(t))*(((v.x*v.x+v.y*v.y))));\n    float r = length(v.xy);\n    /*\n    const float n = 3.0;\n    float sum = 0.0;\n    for (float k = 1.0; k < n; k++)\n    {\n       // sum += wave(r, k, sqrt(k), t) / k + wave(-r, k, sqrt(k), t) / k; // dispersion for capillary waves (no-\"kink\"-tweak)\n       sum += wave((r), k, (1.0 / (k/t)), t) / k;// dispersion for gravity waves (original)\n       //sum -= wave(abs(r), k, (k/t), t) / k; // dispersion for capillary waves (original)\n       \n        // sum += wave(r, k, 1.0 / sqrt(k), t) / k + wave(-r, k, 1.0 / sqrt(k), t) / k;// dispersion for gravity waves (no-\"kink\"-tweak)\n    }\n    \n    //return v.y < 0.0 ? n * sum / r : sum; // comparing variant *1 with variant *n/d looks rather similar in this scale\n    //return sum; // NOTE: using the simple 1d variant instead of the correct 2d variant here (looks similar in this scale)\n\t*/\n   // return wave(abs(r), 1.0f, (1.0f/t), t);\n\t//single wave\n    //return(texture(iChannel0, ((v.xy*0.065f)-1.0f)*0.5f).r*t);\n    //return( VolumetricExplosion(vec3(v,r), r, t*2.0f) \n     //      );\n    //return(max(sdSphere(v, t-r),perlin_noise(vec3(v.xy*0.5f+t,t))));\n   // return(sdTorus(v, t));\n    //return( (sdSphere(opRep(v, vec2(1.0f,1.0f)), sin(t-r))) );\n                     // return max(-udBox(v, vec2(t,t)), sdSphere(0.5f*v, t));\n   // return();\n    //return (r*t - InvDisplacementScalar*sqrt(v.x*v.x+v.y*v.y))*t;\n    return singlewave(r, 0.1f, mod(t, 4.0));// dispersion for gravity waves (original)\n       \n}\n\nfloat fn(vec3 v)\n{\n    v *= DisplacementScalar;\n    return (v.z) + clamp(dispersion2d(v.xy, localtime), -1.0, 1.0);\n}\n\n//vec3 nrm(vec3 v)\n//{\n//    v *= 10.0;\n//    float d = 0.01;\n//    vec2 grad;\n//    grad.x = dispersion2d(v.xy + vec2(d, 0.0), localtime) - dispersion2d(v.xy + vec2(-d, 0.0), localtime);\n //   grad.y = dispersion2d(v.xy + vec2(0.0, d), localtime) - dispersion2d(v.xy + vec2(0.0, -d), localtime);\n//    return normalize(vec3(-grad, d));\n//}\n\nfloat comb(float v)\n{\n    return 4.5f - 0.05f / pow(0.5 + 0.5 * cos(v * 2.0 * M_PI), 10.0);\n}\n\nfloat texGrid(vec3 v)\n{\n    v.x = fract(v.x * 8.0);\n    v.y = fract(v.y * 8.0);\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return q;\n}\n\nvec2 texHeight(vec3 v)\n{\n    v = 0.5 + 0.5 * clamp(v, -1.0, 1.0);\n    return vec2(v.z, 1.0f - v.z) ; //(v.z + (1.0 - v.z)) * 0.5f;\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    //float phi = iTime * 0.0;\n    //float phi = 2.0 * iMouse.x / iResolution.x - 1.0;\n    vec3 v = vec3(uv, depth);\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    //iso.xy = uv.xy;\n    //iso.z = depth;\n    return iso;\n}\n\nvec3 illinois(vec3 a, vec3 b) // faster root finder but more complicated math\n{\n    float fa = fn(a);\n    float fb = fn(b);\n    const int n = 5;\n    int side = 0;\n    \n    vec3 c;\n    \n    for(int i = 0; i < n; i++)\n    {\n        c = (a + b) * 0.5;\n        c = (fa*b - fb*a) / (fa - fb);\n        float fc = fn(c);\n        \n        if(fc * fa > 0.0)\n        {\n            a = c;\n            fa = fc;\n            if (side>0) \n                fb *= 0.5;\n         \tside = -1;\n        }\n        else if (fc * fb > 0.0)\n        {\n            b = c;\n            fb = fc;\n            if (side<0) \n                fa *= 0.5;\n         \tside = +1;\n        }\n        else\n            break;\n    }\n    \n   // return (a + b) * 0.5; // one more convergence\n    return (fa*b - fb*a) / (fa - fb);\n}\n\nvec3 bisection(vec3 a, vec3 b) // slow root-finder, but simple & stable\n{\n    float fa = fn(a);\n    float fb = fn(b);\n    const int n = 11;\n    for(int i = 0; i < n; i++)\n    {\n        vec3 c = (a + b) / 2.0;\n        float fc = fn(c);\n        if(fc * fa > 0.0f)\n        {\n            a = c;\n            fa = fc;\n        }\n        else if (fc * fb > 0.0f)\n        {\n            b = c;\n            fb = fc;\n        }\n        else\n            break;\n    }\n    \n    return (a + b) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localtime = iTime;//fract(iTime / 12.0f) * 16.0f;\n\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv /= 2.0;\n\t\n    vec3 a = camera(uv.xy,0.5);\n    vec3 b = camera(uv.xy,-0.5);\n    \n    float shade = 0.0f;\n \n        vec3 v = illinois(a, b);\n\n        vec2 height = texHeight(v);\n        \n        \t//color = vec3(0);\n    \tshade = mix(((height.x + (1.0 - height.y)) * 0.5f) + 0.09, texGrid(v),\n                           ((height.x - height.y)) * 0.5f);\n    \n    //fragColor = vec4(color * vec3(v*4.), 1.0);\n    fragColor = vec4(shade, shade, shade, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\n\n    const float B_WEIGHT = 0.114;\n\tconst float G_WEIGHT = 0.587;\n\tconst float R_WEIGHT = 0.299;\nfloat lastTime = 0.0;\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat SawTooth(float t) {\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = .17;\n    float rate = 4.0;\n    \n    float t = iTime/rate;\n    \n    float result = 0.0;\n    \n    //octaves\n    for (float i = 0.0; i < 3.0; i++){\n    \tresult += snoise(vec3((uv.x*2.0)/scale, (uv.y - t)/scale, t*5.0))/pow(2.0, i);\n        scale /= 2.0;\n    }\n    result = (result + 2.0)/4.0;\n   \n    //powers for steeper curves\n    float p1 = pow(fragCoord.y/iResolution.y, 1.0);\n    float p2 = (-SawTooth(19.0*(cos(uv.y+iTime)-cos(iTime))*0.09))*(1.0 - p1);\n    result = pow(result, (-SawTooth(20.0)) - p2) - SawTooth(201.0) * 0.25;\n    \n    //power for coloring\n    float g = pow(result, 9.0);\n    float b = pow(result, 4.0);\n    result = pow(result, 1.1);\n        \n    float col = (result * R_WEIGHT) + (g * G_WEIGHT) + (b * B_WEIGHT);\n    fragColor = vec4(col, col, col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}