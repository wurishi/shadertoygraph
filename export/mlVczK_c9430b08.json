{"ver":"0.1","info":{"id":"mlVczK","date":"1700448626","viewed":7,"name":"Rasterization with Anti-aliasing","username":"Centerwing","description":"A rasterization sample","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","clipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SOLUTION_PROJECTION\n#define SOLUTION_RASTERIZATION\n#define SOLUTION_CLIPPING\n#define SOLUTION_INTERPOLATION\n#define SOLUTION_ZBUFFERING\n#define SOLUTION_AALIAS\n\nprecision highp float;\n\n// Polygon / vertex functionality\nconst int MAX_VERTEX_COUNT = 8;\n\nstruct Vertex {\n    vec4 position;\n    vec3 color;\n};\n\nstruct Polygon {\n    // Numbers of vertices, i.e., points in the polygon\n    int vertexCount;\n    // The vertices themselves\n    Vertex vertices[MAX_VERTEX_COUNT];\n};\n\n// Appends a vertex to a polygon\nvoid appendVertexToPolygon(inout Polygon polygon, Vertex element) {\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i == polygon.vertexCount) {\n            polygon.vertices[i] = element;\n        }\n    }\n    polygon.vertexCount++;\n}\n\n// Copy Polygon source to Polygon destination\nvoid copyPolygon(inout Polygon destination, Polygon source) {\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        destination.vertices[i] = source.vertices[i];\n    }\n    destination.vertexCount = source.vertexCount;\n}\n\n// Get the i-th vertex from a polygon, but when asking for the one behind the last, get the first again\nVertex getWrappedPolygonVertex(Polygon polygon, int index) {\n    if (index >= polygon.vertexCount) index -= polygon.vertexCount;\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i == index) return polygon.vertices[i];\n    }\n}\n\n// Creates an empty polygon\nvoid makeEmptyPolygon(out Polygon polygon) {\n  polygon.vertexCount = 0;\n}\n\n\n// SOLUTION_RASTERIZATION and culling part\n\n#define INNER_SIDE 0\n#define OUTER_SIDE 1\n\n// Assuming a clockwise (vertex-wise) polygon, returns whether the input point \n// is on the inner or outer side of the edge (ab)\nint edge(vec2 point, Vertex a, Vertex b) {\n#ifdef SOLUTION_RASTERIZATION\n    // TODO\n\t\n\t// assumed vertex a is the starting point\n\t// we have a -> b and a -> point\n\t//       a\n\t//     /  \t//    / -> \t//   b      point\n\t// if z is pointing out of the screen: < 0 then it is shown above\n\t// else point is at left of the b which means it is outside\n\tvec2 ab = b.position.xy - a.position.xy;\n\tvec2 ap = point.xy - a.position.xy;\n\tfloat z = ab.x * ap.y - ab.y * ap.x;  // z component of the cross product\n\tif (z < 0.0) {\n\t\treturn INNER_SIDE;\n\t}\n\t\n#endif\n    return OUTER_SIDE;\n}\n\n// Clipping part\n\n#define ENTERING 0\n#define LEAVING 1\n#define OUTSIDE 2\n#define INSIDE 3\n\nint getCrossType(Vertex poli1, Vertex poli2, Vertex wind1, Vertex wind2) {\n#ifdef SOLUTION_CLIPPING\n    // TODO\n\t\n\t// check the position of both vertex poli1 -> poli2 with respect to the side defined by wind1 -> wind2\n\tint side1 = edge(poli1.position.xy, wind1, wind2);\n\tint side2 = edge(poli2.position.xy, wind1, wind2);\n\t\n\tif (side1 == INNER_SIDE && side2 == INNER_SIDE) {\n\t\treturn INSIDE;\n\t} else if (side1 == OUTER_SIDE && side2 == OUTER_SIDE) {\n\t\treturn OUTSIDE;\n\t} else if (side1 == INNER_SIDE && side2 == OUTER_SIDE) {\n\t\treturn LEAVING;\n\t} else {\n\t\treturn ENTERING;\n\t}\n\t\n#else\n    return INSIDE;\n#endif\n}\n\n// This function assumes that the segments are not parallel or collinear.\nVertex intersect2D(Vertex a, Vertex b, Vertex c, Vertex d) {\n#ifdef SOLUTION_CLIPPING\n    // TODO\n\t\n\t// line equation 1\n\tfloat m1 = (b.position.y - a.position.y) / (b.position.x - a.position.x);\n\tfloat c1 = b.position.y - (m1 * b.position.x);\n\t\n\t// line equation 2\n\tfloat m2 = (d.position.y - c.position.y) / (d.position.x - c.position.x);\n\tfloat c2 = d.position.y - (m2 * d.position.x);\n\t\n\t// intersection\n\tfloat intersect_x = (c2 - c1) / (m1 - m2);\n\tfloat intersect_y = m1 * intersect_x + c1;\n\t\n\t// calculate the z depth\n\tfloat s = length(a.position.xy - b.position.xy);\n\tfloat z1 = a.position.z;\n\tfloat z2 = b.position.z;\n\tfloat zt = 1.0 / ((1.0/z1) + s * ((1.0/z2) - (1.0/z1)));\n\t\n\treturn Vertex(vec4(intersect_x, intersect_y, zt, 1), a.color);\n\t\n#else\n    return a;\n#endif\n}\n\nvoid sutherlandHodgmanClip(Polygon unclipped, Polygon clipWindow, out Polygon result) {\n    Polygon clipped;\n    copyPolygon(clipped, unclipped);\n\n    // Loop over the clip window\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i >= clipWindow.vertexCount) break;\n\n        // Make a temporary copy of the current clipped polygon\n        Polygon oldClipped;\n        copyPolygon(oldClipped, clipped);\n\n        // Set the clipped polygon to be empty\n        makeEmptyPolygon(clipped);\n\n        // Loop over the current clipped polygon\n        for (int j = 0; j < MAX_VERTEX_COUNT; ++j) {\n            if (j >= oldClipped.vertexCount) break;\n            \n            // Handle the j-th vertex of the clipped polygon. This should make use of the function \n            // intersect() to be implemented above.\n\t\t\t\n#ifdef SOLUTION_CLIPPING\n            // TODO\n\t\t\tVertex wind1 = getWrappedPolygonVertex(clipWindow, i);\n\t\t\tVertex wind2 = getWrappedPolygonVertex(clipWindow, i+1);\n\t\t\tVertex poli1 = getWrappedPolygonVertex(oldClipped, j);\n\t\t\tVertex poli2 = getWrappedPolygonVertex(oldClipped, j+1);\n\t\t\t\n\t\t\tint crossType = getCrossType(poli1, poli2, wind1, wind2);\n\t\t\t\n\t\t\t// handle the poli1 and intersection but not poli2, as it will be handled in the next iteration\n\t\t\tif (crossType == INSIDE) {\n\t\t\t\tappendVertexToPolygon(clipped, getWrappedPolygonVertex(oldClipped, j));\n\t\t\t} else if (crossType == LEAVING) {\n\t\t\t\tappendVertexToPolygon(clipped, getWrappedPolygonVertex(oldClipped, j));\n\t\t\t\tappendVertexToPolygon(clipped, intersect2D(poli1, poli2, wind1, wind2));\n\t\t\t} else if (crossType == ENTERING) {\n\t\t\t\tappendVertexToPolygon(clipped, intersect2D(poli1, poli2, wind1, wind2));\n\t\t\t}\n#else\n            appendVertexToPolygon(clipped, getWrappedPolygonVertex(oldClipped, j));\n#endif\n        }\n    }\n\n    // Copy the last version to the output\n    copyPolygon(result, clipped);\n}\n\n\n\n// Returns if a point is inside a polygon or not\nbool isPointInPolygon(vec2 point, Polygon polygon) {\n    // Don't evaluate empty polygons\n    if (polygon.vertexCount == 0) return false;\n    // Check against each edge of the polygon\n    bool rasterise = true;\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n#ifdef SOLUTION_RASTERIZATION\n            // TODO\n\t\t\tVertex a = getWrappedPolygonVertex(polygon, i);\n\t\t\tVertex b = getWrappedPolygonVertex(polygon, i+1);\n\t\t\t// if any edge rejected, return false immediately\n\t\t\tif (edge(point, a, b) == OUTER_SIDE) {\n\t\t\t\treturn false;\n\t\t\t}\n#else\n            rasterise = false;\n#endif\n        }\n    }\n    return rasterise;\n}\n\nbool isPointOnPolygonVertex(vec2 point, Polygon polygon) {\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n          \tivec2 pixelDifference = ivec2(abs(polygon.vertices[i].position.xy - point) * vec2(iResolution));\n          \tint pointSize = int(iResolution.x / 200.0);\n            if( pixelDifference.x <= pointSize && pixelDifference.y <= pointSize) {\n              return true;\n            }\n        }\n    }\n    return false;\n}\n\nfloat triangleArea(vec2 a, vec2 b, vec2 c) {\n    // https://en.wikipedia.org/wiki/Heron%27s_formula\n    float ab = length(a - b);\n    float bc = length(b - c);\n    float ca = length(c - a);\n    float s = (ab + bc + ca) / 2.0;\n    return sqrt(max(0.0, s * (s - ab) * (s - bc) * (s - ca)));\n}\n\nVertex interpolateVertex(vec2 point, Polygon polygon) {\n    vec3 colorSum = vec3(0.0);\n    vec4 positionSum = vec4(0.0);\n    float weight_sum = 0.0;\n\tfloat weight_corr_sum = 0.0;\n    \n\tfor (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n#if defined(SOLUTION_INTERPOLATION) || defined(SOLUTION_ZBUFFERING)\n            // TODO\n \t\t\tVertex v = getWrappedPolygonVertex(polygon, i);\n\t\t\tVertex v1 = getWrappedPolygonVertex(polygon, i+1);\n\t\t\tVertex v2 = getWrappedPolygonVertex(polygon, i+2);\n\t\t\tfloat weight = triangleArea(point, v1.position.xy, v2.position.xy);\n\t\t\tfloat area = triangleArea(v.position.xy, v1.position.xy, v2.position.xy);\n\t\t\tweight_sum += weight;\n\t\t\tweight_corr_sum += weight / v.position.z;\n#endif\n\n#ifdef SOLUTION_ZBUFFERING\n            // TODO\n\t\t\t\n\t\t\t// without divide is closer to pdf result, but should probably be used\n\t\t\t//positionSum += v.position * weight / v.position.z;\n\t\t\tpositionSum += v.position * weight;\n#endif\n\n#ifdef SOLUTION_INTERPOLATION\n            // TODO\n\t\t\tcolorSum += v.color * weight / v.position.z;\n#endif\n        }\n    }\n    Vertex result = polygon.vertices[0];\n  \n#ifdef SOLUTION_INTERPOLATION\n    // TODO\n\tresult.color = colorSum / weight_corr_sum;\n#endif\n\t\n#ifdef SOLUTION_ZBUFFERING\n    // TODO\n\t\n\t// weight_sum is closer to pdf result, but weight_corr_sum should probably be used\n\tresult.position = positionSum / weight_sum;\n#endif\n\n  return result;\n}\n\n// Projection part\n\n// Used to generate a projection matrix.\nmat4 computeProjectionMatrix() {\n    mat4 projectionMatrix = mat4(1);\n  \n  \tfloat aspect = float(iResolution.x) / float(iResolution.y);  \n  \tfloat imageDistance = 2.0;\n\n\tfloat xMin = -0.5;\n\tfloat yMin = -0.5;\n\tfloat xMax = 0.5;\n\tfloat yMax = 0.5;\n\n#ifdef SOLUTION_PROJECTION\n\n\tfloat w = xMax - xMin;\n\tfloat h = yMax - yMin;\n\tfloat x = xMax + xMin;\n\tfloat y = yMax + yMin;\n\tfloat d = imageDistance;\n\t\n\t// scale to match aspect\n\tw *= aspect;\n\t\n\t// matrix below are tranposed as glsl is column major\n\t\n\t// step 1 & 2\n\tmat4 translate = mat4(\n\t\t  1, 0, 0, -x,\n\t\t  0, 1, 0, -y,\n\t      0, 0, 1, -d,\n\t\t  0, 0, 0, 1\n\t);\n\n\t// step 3\n\tmat4 sheer = mat4(\n\t\td/w,   0,-x/w, 0,\n\t\t  0, d/h,-y/h, 0,\n\t      0,   0,   1, 0,\n\t\t  0,   0,   0, 1\n\t);\n\n\t// step 4\n\tmat4 scale = mat4(\n\t\t  1.0/d,     0,     0, 0,\n\t\t      0, 1.0/d,     0, 0,\n\t          0,     0, 1.0/d, 0,\n\t\t      0,     0,     0, 1\n\t);\n\t\n\t// perspective\n\tmat4 perspective = mat4(\n\t\t  1, 0,    0, 0,\n\t\t  0, 1,    0, 0,\n\t      0, 0,    1, 0,\n\t\t  0, 0,1.0/d, 1\n\t);\n\t\n\t// apply from left to right\n\tprojectionMatrix = translate * sheer * scale * perspective;\n#endif\n\n    return projectionMatrix;\n}\n\n// Used to generate a simple \"look-at\" camera. \nmat4 computeViewMatrix(vec3 VRP, vec3 TP, vec3 VUV) {\n    mat4 viewMatrix = mat4(1);\n\n#ifdef SOLUTION_PROJECTION\n    // TODO\n\t\n\t// find the \"look at\" vector\n\tvec3 VPN = TP - VRP;\n\t\n\t// compute n, u, v that define the camera position \n\tvec3 n = normalize(VPN);\n\tvec3 u = normalize(cross(VUV, n));\n\tvec3 v = cross(n, u);\n\tfloat qu = dot(VRP, u);\n\tfloat qv = dot(VRP, v);\n\tfloat qn = dot(VRP, n);\n\t\n\tviewMatrix = mat4(\n\t\tu[0], u[1], u[2],-qu,\n\t\tv[0], v[1], v[2],-qv,\n\t\tn[0], n[1], n[2],-qn,\n\t\t   0,    0,    0,  1\n\t);\n\t\n#endif\n    return viewMatrix;\n}\n\nvec3 getCameraPosition() {  \n    //return 10.0 * vec3(sin(iTime * 1.3), 0, cos(iTime * 1.3));\n\treturn 10.0 * vec3(sin(0.0), 0, cos(0.0));\n}\n\n// Takes a single input vertex and projects it using the input view and projection matrices\nvec4 projectVertexPosition(vec4 position) {\n\n    // Set the parameters for the look-at camera.\n    vec3 TP = vec3(0, 0, 0);\n  \tvec3 VRP = getCameraPosition();\n    vec3 VUV = vec3(0, 1, 0);\n\n    // Compute the view matrix.\n    mat4 viewMatrix = computeViewMatrix(VRP, TP, VUV);\n\n    // Compute the projection matrix.\n    mat4 projectionMatrix = computeProjectionMatrix();\n  \n#ifdef SOLUTION_PROJECTION\n    // TODO\n\t\n\t// view first then projection\n\tposition = position * viewMatrix * projectionMatrix;\n\t\n\t// perspective division\n\tposition = position / position.w;\n\t\n\treturn position;\n#else\n    return position;\n#endif\n}\n\n// Projects all the vertices of a polygon\nvoid projectPolygon(inout Polygon projectedPolygon, Polygon polygon) {\n    copyPolygon(projectedPolygon, polygon);\n    for (int i = 0; i < MAX_VERTEX_COUNT; ++i) {\n        if (i < polygon.vertexCount) {\n            projectedPolygon.vertices[i].position = projectVertexPosition(polygon.vertices[i].position);\n        }\n    }\n}\n\n// Draws a polygon by projecting, clipping, ratserizing and interpolating it\nvoid drawPolygon(\n  vec2 point, \n  Polygon clipWindow, \n  Polygon oldPolygon, \n  inout vec3 color, \n  inout float depth)\n{\n    Polygon projectedPolygon;\n    projectPolygon(projectedPolygon, oldPolygon);  \n  \n    Polygon clippedPolygon;\n    sutherlandHodgmanClip(projectedPolygon, clipWindow, clippedPolygon);\n\n    if (isPointInPolygon(point, clippedPolygon)) {\n      \n        Vertex interpolatedVertex = interpolateVertex(point, projectedPolygon);\n\n#if defined(SOLUTION_ZBUFFERING)\n        // TODO: Put your code to handle z buffering here\n\t\tif (depth > interpolatedVertex.position.z) {\n\t\t\t// we found a interpolatedVertex nearer to the screen\n\t\t\tcolor = interpolatedVertex.color;\n\t\t\tdepth = interpolatedVertex.position.z;\n\t\t}\n#else\n      color = interpolatedVertex.color;\n      depth = interpolatedVertex.position.z;      \n#endif\n   }\n  \n   if (isPointOnPolygonVertex(point, clippedPolygon)) {\n        color = vec3(1);\n   }\n}\n\n// Main function calls\n\nvoid drawScene(vec2 pixelCoord, inout vec3 color) {\n    color = vec3(0.3, 0.3, 0.3);\n  \n  \t// Convert from GL pixel coordinates 0..N-1 to our screen coordinates -1..1\n    vec2 point = 2.0 * pixelCoord / vec2(iResolution) - vec2(1.0);\n\n    Polygon clipWindow;\n    clipWindow.vertices[0].position = vec4(-0.65,  0.95, 1.0, 1.0);\n    clipWindow.vertices[1].position = vec4( 0.65,  0.75, 1.0, 1.0);\n    clipWindow.vertices[2].position = vec4( 0.75, -0.65, 1.0, 1.0);\n    clipWindow.vertices[3].position = vec4(-0.75, -0.85, 1.0, 1.0);\n    clipWindow.vertexCount = 4;\n\n  \t// Draw the area outside the clip region to be dark\n    color = isPointInPolygon(point, clipWindow) ? vec3(0.5) : color;\n\n    const int triangleCount = 2;\n    Polygon triangles[triangleCount];\n  \n    triangles[0].vertices[0].position = vec4(-3, -2, 0.0, 1.0);\n    triangles[0].vertices[1].position = vec4(4, 0, 3.0, 1.0);\n    triangles[0].vertices[2].position = vec4(-1, 2, 0.0, 1.0);\n    triangles[0].vertices[0].color = vec3(1.0, 1.0, 0.2);\n    triangles[0].vertices[1].color = vec3(0.8, 0.8, 0.8);\n    triangles[0].vertices[2].color = vec3(0.5, 0.2, 0.5);\n    triangles[0].vertexCount = 3;\n  \n    triangles[1].vertices[0].position = vec4(3.0, 2.0, -2.0, 1.0);\n  \ttriangles[1].vertices[2].position = vec4(0.0, -2.0, 3.0, 1.0);\n    triangles[1].vertices[1].position = vec4(-1.0, 2.0, 4.0, 1.0);\n    triangles[1].vertices[1].color = vec3(0.2, 1.0, 0.1);\n    triangles[1].vertices[2].color = vec3(1.0, 1.0, 1.0);\n    triangles[1].vertices[0].color = vec3(0.1, 0.2, 1.0);\n    triangles[1].vertexCount = 3;\t\n\t\n    float depth = 10000.0;\n    // Project and draw all the triangles\n    for (int i = 0; i < triangleCount; i++) {\n        drawPolygon(point, clipWindow, triangles[i], color, depth);\n    }   \n}\n\nvec3 drawOffsetedPixel(in float xOffset, in float yOffset) {\n\tvec2 coord = gl_FragCoord.xy;\n\tcoord.x += xOffset;\n\tcoord.y += yOffset;\n\tvec3 color;\n\tdrawScene(coord, color);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color = vec3(0);\n\t\n#ifdef SOLUTION_AALIAS\n\t\n\t// This is the \"sample rate\" for each side\n\t// as it need to be a square. Use this to trade quality and speed.\n\t// samplesPerSide = 1: no antialias\n\t// samplesPerSide < 1: undefined\n\t// samplesPerSide > 1: antialias that control the samples per side, so the actual number of samples is samplesPerSide * samplesPerSide\n\tconst int samplesPerSide = 3;\n\t\n\t// use the following code for averging the neighboring pixels\n\tfloat stepSize = 1.0 / float(samplesPerSide);\n\t\n\tvec3 colorSum = vec3(0);\n\tfor (int i = 0; i < samplesPerSide; i++) {\n\t\tfloat xLocal = float(i) * stepSize + stepSize / 2.0;\n\t\tfor (int j = 0; j < samplesPerSide; j++) {\n\t\t\tfloat yLocal = float(j) * stepSize + stepSize / 2.0;\n\t\t\tcolorSum += drawOffsetedPixel(xLocal-0.5, yLocal-0.5);\n\t\t}\n\t}\n\t\n\tcolor = colorSum / (float(samplesPerSide) * float(samplesPerSide));\n\t\n\t\n#else\n    drawScene(fragCoord.xy, color);\n#endif\n\t\n\tfragColor.rgb = color;\t\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}