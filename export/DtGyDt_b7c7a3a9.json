{"ver":"0.1","info":{"id":"DtGyDt","date":"1700765182","viewed":21,"name":"Factored Matrix Interpolation","username":"ArthMax","description":"Sequence of the 3 factored interpolations between consecutive matrices:\n M0=S0*T0 --> M1=S1*R1*T1,   \n          M1=S1*R1*T1 --> M2=K2*S2*R2*T2 ,   \n                    M2=K2*S2*R2*T2    -->  M0=S0*T0","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"ctGcD1","parentname":"Simple Matrix Interpolation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visit my tutorial to learn how this works: https://inspirnathan.com/posts/50-shadertoy-tutorial-part-4\n\n        vec3 getBackgroundColor(vec2 uv) {\n            uv += 0.5 ;// remap uv from <-0.5,0.5> to <0.,1.>\n            vec3 gradientStartColor = vec3(0., 0., 0.5);\n            vec3 gradientEndColor = vec3(0., 1., 1.);\n            vec3 gradientEnd2Color = vec3(95, 0.5, 0.5);\n             vec3 colorMix1 = mix(gradientStartColor, gradientEndColor, uv.y);\n            //  vec3 colorMix3 = mix(colorMix1,gradientEnd2Color, uv.x);\n               return colorMix1; // gradient mix\n        }\n        \n        float sdSquare(vec2 p, float size, vec2 offset) {\n            float x = p.x - offset.x;\n            float y = p.y - offset.y;\n        \n             return max(abs(x), abs(y)) - size;\n        }\n        \n        float sdCircle(vec2 p, float r, vec2 offset) {\n            float x = p.x - offset.x;\n            float y = p.y - offset.y;\n            \n             return length(vec2(x, y)) - r;\n        }\n        \n        float sdHeart (vec2 p, float size, vec2 offset) { // Credit: https://mathworld.wolfram.com/HeartCurve.html\n            float x = p.x - offset.x;\n            float y = p.y - offset.y;\n            float  xx = x * x;\n            float  yy = y * y;\n            float   yyy = yy * y;\n            float    group = xx + yy - size;\n            \n             return group * group * group - xx * yyy;\n        }\n        \n        float sdStar5 (vec2 p, float r, float rf, vec2 offset) // Credit: https://iquilezles.org/articles/distfunctions2d\n        {\n            p -= offset;\n            const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n            const vec2 k2 = vec2(-k1.x,k1.y);\n             p.x = abs(p.x);\n              p -= 2.0*max(dot(k1,p),0.0)*k1;\n               p -= 2.0*max(dot(k2,p),0.0)*k2;\n                p.x = abs(p.x);\n                p.y -= r;\n              vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n               float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n        \n                return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n        }\n\n    vec3 drawScene(vec3 p) {\n         vec2 uv = p.xy;\n         \n        float heart  = sdHeart (uv, 0.01,       vec2(-0.5, 0.));\n        float square = sdSquare(uv, 0.025,        vec2(-0.6, 0.15));\n        float circle = sdCircle(uv, 0.05,        vec2(-0.5, 0.));\n        float star   = sdStar5 (uv, 0.05, 0.32, vec2(-0.4, 0.15));\n        \n        \n        vec3 heartColor  = vec3(1, 0, 0.5);\n        vec3 squareColor = vec3(0, 1, 0);\n        vec3 circleColor = vec3(0.5, 1, 0);\n        vec3 starColor   = vec3(0, 0, 1);\n        \n         vec3 resultColor = getBackgroundColor(uv);\n         resultColor = mix(heartColor,  resultColor, step(0.0000001, heart));\n          resultColor = mix(squareColor, resultColor, step(0., square));\n           resultColor = mix(circleColor, resultColor, step(0., circle));\n            resultColor = mix(starColor,   resultColor, step(0., star));\n        \n              return resultColor;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n vec2 m = iMouse.xy/iResolution.xy *20.0;\n  float size = max(1.0,m.x); ;\n    vec2 uv =2.0*size*fragCoord/iResolution.xy; // <0, size>\n          uv -= size; // <-size, size>\n           uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n           vec3 p = vec3(uv,1.0);               // make homogenious vector from uv\n           float t = mod(iTime / 10.0, 3.0);\n           float t_ = 1.0;\n           //mat3 ArrayOfMatrices[4] ;\n           mat3 M ;\n           \n               // 0 and 3 frame\n               \n            mat3 I = mat3(1.0);     \n\n             \n                          \n                          \n            mat3 M0 = mat3(\n                           1.1,    0. ,    1., // \n                           0.,  1.1 ,      1., // \n                          //------------\n                            0.,   0.,     1.0   // \n                          );\n                  \n              // 1 frame             \n           mat3 M1 = mat3(\n                           0.,    -2. ,   0.,  // \n                           1.,    0. ,    0.,  // \n                          //------------\n                           0.0,  0.0 ,   1.0   // \n                          );\n                          \n                //  M1 =             \n              // 2 frame                                       \n           mat3 M2 = mat3(\n                           -2.,    2. ,    -1., // \n                           0.,    -2. ,    -1., // \n                          //------------\n                           0.,     0. ,   1.0 // \n                          ); \n                          \n              //get t_ from t\n              if(0.0<=t && t<1.0){t_ = t-0.0;}\n              if(1.0<=t && t<2.0){t_ = t-1.0;} \n              if(2.0<=t && t<3.0){t_ = t-2.0;} \n               float _t = 1.-t_;\n                 if(_t < 0.)_t=0.;\n              \n               // matrix S0^_t \n               mat3 S0 = mat3(pow(2.1,_t), 0.0,      0.0,\n                              0.0,       pow(2.1,_t), 0.0,\n                              0.0,        0.0,       1.0);\n               // matrix T0^_t \n               mat3 T0 = mat3(\n                           1.,    0. ,   2.*_t, // \n                           0.,    1. ,   1.*_t, // \n                          //------------\n                           0.,   0.,     1.0   // \n                          );\n                      M0 = S0*T0;        // initial frame factorized by scale and translate\n                      \n                      \n              // matrix R1^t_  \n                float c=cos(t_);\n                float s=sin(t_);\n            mat3 R1 = mat3(c, -s, 0., // \n                           s,  c, 0., // \n                           //----------\n                           0.,0.,1.0  // \n                          );              \n                    \n                          \n              if(0.0<=t && t<1.0)M = M0*_t + M1*t_; // simple linear interpolation between M0 and M1    \n              if(1.0<=t && t<2.0)M = M1*_t + M2*t_; // simple linear interpolation between M1 and M2    \n              if(2.0<=t && t<3.0)M = M2*_t + M0*t_; // simple linear interpolation between M2 and M3    \n              \n             // M = M0;\n              \n               M = inverse(M);\n                fragColor = vec4(drawScene(p*M),1.0); // Output to screen\n}\n","name":"Image","description":"","type":"image"}]}