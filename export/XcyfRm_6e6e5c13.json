{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"vec3 colorGradients(vec2 fragCoord, vec3 iResolution) {\n    float h = floor(1.0 + 24.0 * fragCoord.y / iResolution.y) / 24.0 * 3.141592 * 2.;\n    float L = floor(fragCoord.x * 24.0 / iResolution.y) / (24.0 / iResolution.y) / iResolution.x - 0.4;\n    vec3 color = cos(h + vec3(0.0, 1.0, 2.0) * 3.141592 * 2.0 / 3.0);\n    float maxRGB = max(color.r, max(color.g, color.b));\n    float minRGB = min(color.r, min(color.g, color.b));\n\n    return exp(15.0 * L) * (color - minRGB) / (maxRGB - minRGB);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 color = colorGradients(fragCoord, iResolution);\n\n    //color = to_linear(color);\n\n    color = tone_mapping(color);\n    \n    color = from_linear(color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// In practice, there is still debate and confusion around whether sRGB data\n// should be displayed with pure 2.2 gamma as defined in the standard,\n// or with the inverse of the OETF.\n// https://en.wikipedia.org/wiki/SRGB\n#define BT709_OETF\n\n#if defined(PURE_GAMMA)\nvec3 to_linear(vec3 sRGB) {\n    return pow(sRGB, vec3(2.2));\n}\n\nvec3 from_linear(vec3 linearRGB) {\n    return pow(linearRGB, vec3(1.0 / 2.2));\n}\n\n#elif defined(BT709_OETF)\nvec3 to_linear(vec3 sRGB) {\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055)) / vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB / vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 from_linear(vec3 linearRGB) {\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055) * pow(linearRGB, vec3(1.0 / 2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n#endif\n\nvec3 linear_srgb_to_oklab(vec3 c) {\n    vec3 lms = vec3(0.4122214708, 0.2119034982, 0.0883024619) * c.r + vec3(0.5363325363, 0.6806995451, 0.2817188376) * c.g + vec3(0.0514459929, 0.1073969566, 0.6299787005) * c.b;\n    vec3 lms_ = pow(lms, vec3(1.0 / 3.0));\n    return vec3(0.2104542553, 1.9779984951, 0.0259040371) * lms_.x + vec3(0.7936177850, -2.4285922050, 0.7827717662) * lms_.y + vec3(-0.0040720468, 0.4505937099, -0.8086757660) * lms_.z;\n}\n\nvec3 oklab_to_linear_srgb(vec3 c) {\n    vec3 lms_ = c.x + vec3(0.3963377774, -0.1055613458, -0.0894841775) * c.y + vec3(0.2158037573, -0.0638541728, -1.2914855480) * c.z;\n    vec3 lms = lms_ * lms_ * lms_;\n    return vec3(4.0767416621, -1.2684380046, -0.0041960863) * lms.x + vec3(-3.3077115913, 2.6097574011, -0.7034186147) * lms.y + vec3(0.2309699292, -0.3413193965, 1.7076147010) * lms.z;\n}\n\nfloat soft_clip(float x) {\n    const float s = -0.875;\n    return (1.0 + x - sqrt(1.0 - 2.0 * s * x + x * x)) / (1.0 + s);\n}\n\nvec3 tone_mapping(vec3 color) {\n    const vec3 oklab_white = vec3(1.0, 0.0, 0.0);\n\n    float max_rgb = max(max(color.r, color.g), color.b);\n\n    vec3 oklab = linear_srgb_to_oklab(color);\n    vec3 oklab_anchor = linear_srgb_to_oklab(color / max_rgb);\n\n    if(oklab.x > oklab_anchor.x) {\n        float k = soft_clip(oklab.x - oklab_anchor.x);\n        oklab = mix(oklab_anchor, oklab_white, k);\n    }\n\n    color = oklab_to_linear_srgb(oklab);\n\n    return vec3(color);\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcyfRm","date":"1733898566","viewed":129,"name":"Oklab_based_tonemap","username":"bWFuanVzYWth","description":"Experimental. Please do NOT use it, it still has many defects.\nCover 100% sRGB.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["tonemapping","tonemapping","tonemap","tonemap","oklab"],"hasliked":0,"parentid":"","parentname":""}}