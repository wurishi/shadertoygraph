{"ver":"0.1","info":{"id":"ltfBzH","date":"1510968082","viewed":209,"name":"Checkerboard Raymarching","username":"Assossa","description":"Click and drag!\n\nAttempt at a checkerboard rendering technique similar to what is found in Rainbow Six Siege.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxRender = 10.0;\nconst vec2 offsets[4] = vec2[4](\n    vec2( 0.0, -1.0),\n    vec2(-1.0,  0.0),\n    vec2( 1.0,  0.0),\n    vec2( 0.0,  1.0)\n);\n\nvec2 getUV(vec2 fragCoord) {\n    return fragCoord / iResolution.xy;\n}\n\nvec4 getPixel(vec2 fragCoord) {\n    return texture(iChannel0, getUV(fragCoord));\n}\n\nvec4 interpolate(vec2 fragCoord) {\n    vec4 outCol = vec4(0.0);\n    float size = 0.0;\n    for(int i = 0; i < 4; i++) {\n        vec4 pix = getPixel(fragCoord + offsets[i]);\n        float temp_size = max(0.5, 1.0 - (pix.w / maxRender));\n        \n        outCol += pix * temp_size;\n        size += temp_size;\n    }\n    return outCol / size;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool doInterpolate  = fragCoord.x < iMouse.x;\n    bool doCheckerboard = fragCoord.y < iMouse.y;\n    bool verticalLine   = int(fragCoord.x) == int(iMouse.x);\n    bool horizontalLine = int(fragCoord.y) == int(iMouse.y) && doInterpolate;\n    \n    if(verticalLine || horizontalLine) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if(doInterpolate && mod(fragCoord.x, 2.0) == mod(fragCoord.y, 2.0)) {\n        if(!doCheckerboard)\n        \tfragColor = interpolate(fragCoord);\n    }\n    else\n    \tfragColor = getPixel(fragCoord);\n    \n    //fragColor = vec4(fragColor.w / maxRender);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float maxRender = 10.0; // Max distance to ray march\nconst float epsilon = 0.001; // Margin of error\nconst vec3 light = vec3(0.0, 4.0, 0.0); // Light position\n\n// Find distance between sphere and ray\nfloat sphereDistance(vec3 p, vec3 center, float radius) {\n    return distance(p, center) - radius;\n}\n\n// Find normal of sphere from hit location\nvec3 sphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\n// Get the hit location for a sphere and ray\nvec3 sphereHit(vec3 o, vec3 d, vec3 center, float radius) {\n    // Keep track of the distance we have traveled\n    float dist = 0.0;\n    \n    // Kill the marching if we go too far\n    while(dist <= maxRender) {\n        // Get distance to sphere\n        float tempDist = sphereDistance(o, center, radius);\n        \n        // Add it to our distance counter and update the ray origin\n        dist += tempDist;\n        o += d * tempDist;\n        \n        // If we hit a sphere, then return the hit\n        if(tempDist <= epsilon) return o;\n    }\n    \n    // We didn't hit anything\n    return vec3(maxRender);\n}\n\nvec4 findHit(vec3 ray, vec3 origin) {\n    // Find a hit\n    vec3 hit = sphereHit(origin, ray, vec3(0.0), 1.0);\n    \n    // If no hit, then use the sky color\n    if(hit == vec3(maxRender)) {\n        return vec4(texture(iChannel0, ray).xyz, maxRender);\n    }\n    \n    // Find the normal of the sphere and the diffuse lighting from the normal\n    vec3 nml = sphereNormal(hit, vec3(0.0));\n    float diffuse = max(dot(nml, (light - hit)) + 0.75, 0.45) * 0.95;\n    vec3 tex = texture(iChannel0, reflect(ray, nml)).xyz;\n    \n    return vec4(tex * vec3(diffuse), distance(origin, hit));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 lookAt(vec3 dir, vec3 pos) {\n    mat4 viewToWorld = viewMatrix(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0));\n    return (viewToWorld * vec4(dir, 0.0)).xyz;\n}\n\nvec3 cameraDir(vec2 fc) {\n    vec2 uv = fc / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    return normalize(vec3(uv, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x < iMouse.x && mod(fragCoord.x, 2.0) == mod(fragCoord.y, 2.0)) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Create ray for current pixel\n    vec3 origin = vec3(cos(iTime * 0.5) * 2.0, 0.0, sin(iTime * 0.5) * 2.0);\n    vec3 ray = -lookAt(cameraDir(fragCoord), origin);\n  \n    fragColor = findHit(ray, origin);\n//    fragColor = vec4(findHit(ray, origin).w) / maxRender;\n}","name":"Buf A","description":"","type":"buffer"}]}