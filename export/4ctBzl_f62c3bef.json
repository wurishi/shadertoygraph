{"ver":"0.1","info":{"id":"4ctBzl","date":"1733438658","viewed":19,"name":"lights and mirrors","username":"bloodnok","description":"Messing around. Mouse to rotate.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","refraction"],"hasliked":0,"parentid":"flS3zy","parentname":"cloud in a bubble"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n/*\n\t@geofftnz\n\n    Scratchpad for experimentation.\n    \n    TODO:\n    - Break apart sphere raytracing, merge into strace.\n    - Will need to track current IOR in stack frame\n    - wavelength-dependent refraction\n    - generic refraction/reflection dispersion based on surface curvature radius?\n    - turn rayLights into generic media contribution for ray segment.\n    \n    FUTURE:\n    - ray-casting intersection.\n\n*/\n\n// a sphere\nvec4 sph1 = vec4 (0.0,0.0,0.0,0.75);\nvec4 sph2 = vec4 (0.0,0.0,-(0.75+0.202),0.2);\n\n\n\n//------------------------------------------------------------------------------\n// Colour space transform\n//------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Academy_Color_Encoding_System#Converting_ACES2065-1_RGB_values_to_CIE_XYZ_values\nvec3 RGBtoXYZ(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(0.9525523959,0.3439664498,0.0),\n        \tvec3(0,0.7281660966,0.0),\n        \tvec3(0.0000936786,-0.0721325464,1.0088251844)\n        );\n    return x * col;\n}\n\nvec3 XYZtoRGB(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(1.0498110175,-0.4959030231,0.0),\n        \tvec3(0.0,1.3733130458,0.0),\n        \tvec3(-0.0000974845,0.0982400361,0.9912520182)\n        );\n    return x * col;\n}\n\n\n\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\t//if (cosvu<0.0) return -1.0; //length(p-ro);\n    if (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\nfloat pointRayDistance(vec3 ro, vec3 rd, float rlen, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\n    if (cosvu<=0.0) return length(p-ro);\n    if (cosvu>=rlen) return length(p-(ro+rd*rlen));\n    \n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n\n// intersection through participating media (like atmospheres)\nstruct iMediaIntersection\n{\n    float tnear;   // first intersection\n    float tfar;    // last intersection\n    uint mnear;    // material first hit (atmosphere?)\n    uint mfar;     // material on second hit (atmosphere or ground)\n    vec3 nor;      // normal at first intersection\n};\n\n\n// intersect ray ro+rd with sphere sph, calculates both entry and exit points.\niMediaIntersection mSphere(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.tfar = -1.0;\n    res.mnear = 0u;\n    res.mfar = 0u;\n    \n    // sphere intersection\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n    \n\tif (h >= 0.0)\n    {\n        float hsqrt = sqrt(h);\n        res.tnear = (-b - hsqrt) / 2.0;\n        res.mnear = 1u;  // atmospheric hit\n        \n        res.nor = normalize(ro + rd * res.tnear - sph.xyz);\n        \n        res.tfar = (-b + hsqrt)/2.0;\n        res.mfar = 1u;  // atmospheric exit\n    }\n\n    return res;\n}\n\n// unified raytrace hit structure\nstruct iRayHit\n{\n    float tnear;   // distance along ray of hit, -1 if miss.\n    vec3 nor;      // normal at first intersection\n    \n    // refraction result\n    vec3 exitPos;  // exit position\n    vec3 exitDir;  // exit direction\n    vec3 exitNor;  // normal at second intersection\n};\n\n// glass sphere intersection details\nstruct iGlassSphereIntersection\n{\n    float tnear;   // first intersection parameter\n    vec3 nor;      // normal at first intersection\n    vec3 exitPos;  // exit position\n    vec3 exitDir;  // exit direction\n    vec3 exitNor;  // normal at second intersection\n};\n\niGlassSphereIntersection glassSphere(in vec3 ro, in vec3 rd, in vec4 sph, in float IORratio)\n{\n    iGlassSphereIntersection res;\n    res.tnear = -1.0;\n    \n    // first intersection\n    iMediaIntersection first = mSphere(ro, rd, sph);\n\n    res.tnear = first.tnear;\n    if (res.tnear <= 0.0) return res; // miss\n    \n    // we've hit.\n    res.nor = first.nor;\n    \n    // second intersection\n    vec3 internalDir = refract(rd, first.nor, 1.0 / IORratio);\n    vec3 firstHitPos = ro + rd * first.tnear;\n    iMediaIntersection second = mSphere(firstHitPos, internalDir, sph);\n    \n    float tfar = max(second.tnear,second.tfar);\n    \n    if (tfar > 0.0)\n    {\n        // we've intersected the back of the sphere\n        res.exitPos = firstHitPos + internalDir * tfar;\n        res.exitNor = normalize(res.exitPos - sph.xyz);\n        res.exitDir = refract(internalDir, -res.exitNor, IORratio);\n    }\n    \n    return res;\n}\n\n\nfloat iSphere (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\n\nfloat iSphere2 (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b + sqrt(h))/2.0;\n\treturn t;\n}\n\nvec3 nSphere (in vec3 pos, in vec4 sph){\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n\t//eq. of a plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\n\nvec3 nPlane( in vec3 pos){\n\treturn vec3(0.0,1.0,0.0);\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere (ro, rd, sph1); //intersect with sphere\n\tfloat tpla = iPlane (ro,rd); //intersect with plane\n\tif (tsph > 0.0){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\tif (tpla > 0.0 && tpla < resT){\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\treturn id;\n}\n\n\niMediaIntersection mediaIntersect( in vec3 ro, in vec3 rd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.mnear = 0u;\n    res.tfar = -1.0;\n    res.mfar = 0u;\n    \n    iMediaIntersection res2 = mSphere(ro,rd,sph1);\n    res = res2;\n    \n    return res;\n}\n\nvec3 environment(vec3 rd)\n{\n    return texture(iChannel0,rd).rgb; //*0.0 + vec3(0.2);\n}\n\nvec3 rayLights(in vec3 ro, in vec3 rd, in float dlimit)\n{\n    vec3 c = vec3(0.0);\n    vec3 lcol = normalize(vec3(0.1,0.7,1.5));\n    \n    mat4 rot = rotationMatrix(vec3(sin(iTime * 0.7),sin(iTime * 0.07),cos(iTime * 0.6)),0.05);\n    \n    // background hit\n    if (dlimit > 1e5){\n        c = environment(rd);\n    }\n\n    float r = 1.05;\n    \n    // determine closest distance between ray and light\n    \n    for (int i=0;i<100;i++)\n    {\n        float ii = (float(i) * 0.01) + iTime*0.01;\n        ii *= 2.0 * PI;\n        vec3 lpos = vec3(sin(ii) * r, cos(ii) * r, sin(ii*1.7) * r);\n        \n        // closest ray-light distance\n        float d = pointRayDistance(ro, rd, dlimit, lpos);\n        \n        if (d >= 0.0)\n        {        \n            c += ((lcol * 0.7 + vec3(0.1)) * 4.0 / (1.0 + d*d*2000.));\n        }\n        \n        lcol = (rot * vec4(lcol - vec3(0.5),1.0)).xyz + vec3(0.5);\n    }\n    \n    return c;\n}\n\n\nstruct StackFrame\n{\n    vec3 ro;   // ray origin\n    vec3 rd;   // ray direction\n    vec3 att;  // accumulated attentuation factor    \n};\n\n#define STACKSIZE 16\nStackFrame stack[STACKSIZE];\nint stackPointer = 0;\n\nbool stackPush(StackFrame frame)\n{\n    if (stackPointer >= STACKSIZE) return false;  // stack full\n    \n    //stack[stackPointer] = frame;\n    //stackPointer++;\n    \n    stack[stackPointer].ro = frame.ro;\n    stack[stackPointer].rd = frame.rd;\n    stack[stackPointer].att = frame.att;\n    stackPointer++;\n    \n    return true;\n}\n\nbool stackCanPop()\n{\n    return stackPointer > 0;\n}\n\nStackFrame stackPop()\n{\n    if (stackPointer <= 0) // stack empty\n    {\n        return StackFrame(vec3(0.0), vec3(0.0), vec3(1.0));\n    }\n    stackPointer--;\n    return stack[stackPointer];\n}\n\n\n\nvec3 strace(vec3 ro, vec3 rd, vec3 att);\nvec3 trace(vec3 ro, vec3 rd);\nvec3 trace2(vec3 ro, vec3 rd);\n\n// \"Recursive\" raytrace using a stack\nvec3 stacktrace(vec3 ro, vec3 rd)\n{\n\n    stackPointer = 0;\n    \n    // accumulated colour to return\n    vec3 col = vec3(0.0); \n    \n    // ray attenuation modifier\n    vec3 att = vec3(1.0);\n    \n    // push initial ray to stack\n    stackPush(StackFrame(ro,rd,vec3(1.0)));\n    \n    int rayCount = 0;\n\n    // loop while our stack has items\n    while(stackCanPop() && rayCount < 100)\n    {\n        StackFrame ray = stackPop();\n        rayCount++;\n        \n        col += strace(ray.ro, ray.rd, ray.att);\n    }\n    return col;\n}\n\n\nvec3 strace(vec3 ro, vec3 rd, vec3 att)\n{\n    vec3 col = vec3(0.0);\n    float IOR = 1.8;\n    \n    float hitsphr = 0.0001;\n    \n    // If we've attenuated this ray too far, then early-exit.\n    // This reduces the number of rays cast for reflection\n    if (dot(att,att) < 1e-4) return vec3(0.0,0.0,0.0);\n    \n    \n    \n    // trace the scene. Intersect the glass sphere, reflect and refract. \n    // call rayLights to gather contributions\n    \n    iGlassSphereIntersection hit = glassSphere(ro,rd,sph1,IOR);\n    hitsphr = sph1.w;\n    \n    for (int i = 0; i < 6; i++)\n    {\n        // sphere positions\n        float ii = (float(i) * 2.0 * PI) / 6.0;\n        ii += iTime * 0.2;\n        \n        sph2.w = 0.2;\n        float sph2r = sph1.w + sph2.w + 0.02;\n\n        sph2.x = sin(ii) * sph2r;\n        sph2.y = sin(ii*0.3) * cos(ii*0.13) * sph2r;\n        sph2.z = cos(ii) * sph2r;\n        \n        iGlassSphereIntersection hit2 = glassSphere(ro,rd,sph2,IOR);\n        if (hit2.tnear > 0.0 && (hit.tnear < 0.0 || hit2.tnear < hit.tnear))\n        {\n            hit = hit2;\n            hitsphr = sph2.w;\n        }\n    }\n    \n    if (hit.tnear > 0.0)\n    {\n        // hit something.\n        vec3 hitpos = ro + rd * hit.tnear;\n        \n        // add lights between ray origin and hit\n        col += rayLights(ro, rd, hit.tnear);\n\n\n        //float disp = rd.y > 0.0 ? 0.0 : computeRayDispersion(rd,hit.nor,hitsphr,IOR);\n        float disp = computeRayDispersion(rd,hit.nor,hitsphr,IOR);\n\n        vec3 internalAbsorb = vec3(1.0 - disp);\n\n        // add lights between entry and exit\n        col += rayLights(hitpos, normalize(hit.exitPos - hitpos), length(hit.exitPos - hitpos)) * internalAbsorb;\n       \n        // Reflect and trace lights\n        float reflAmount = FresnelReflectAmount(1.0,IOR,hit.nor,rd); // calculate Fresnel\n        stackPush(StackFrame(hitpos, reflect(rd,hit.nor),att * vec3(reflAmount)));\n        \n        // Refract and trace lights\n        stackPush(StackFrame(hit.exitPos, hit.exitDir,att * internalAbsorb));\n        \n    }\n    else\n    {\n        // ray missed\n        col += rayLights(ro,rd,1e6);\n    }\n    \n    return col * att;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n    vec3 mse = iMouse.xyz;\n    if (mse.z <= 0.0){  // default view\n        mse.x = iResolution.x * 0.5;\n        mse.y = iResolution.y * 0.5;\n    }\n\n    // turn mouse into spherical coords\n\tvec2 nMouse = (mse.xy / iResolution.xy)* PI;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n    \n    vec3 ro;\n    float camdist = 2.0;\n\tro.x = sin(th) * cos(ph) * camdist;\n\tro.z = sin(th) * sin(ph) * camdist;\n\tro.y = cos(th) * camdist;\n\n\tvec3 lookAt = sph1.xyz;\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd0 = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n    vec3 col = vec3(0.0);\n    \n    // intersect with scene\n    //col += rayLights(ro,rd0);\n    //col += trace(ro,rd0);\n    col += stacktrace(ro,rd0);\n\t\n    //iMediaIntersection hit = mediaIntersect(ro,rd0);\n\n    //col = XYZtoRGB(col);\n\n// reinhardt HDR tonemapping\n\tfloat whitelevel = 2.0;\n\tcol = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n\n// gamma\t\n\tcol = pow(col,vec3(1.0/2.2));\n    \n    // fps graph\n    if (fragCoord.y < 8.)\n    {    \n        float fps = 1./iTimeDelta;\n        float posFPS = fragCoord.x * 0.5;\n    \n        if (posFPS < fps)\n        {\n            if (posFPS > 120.)\n            {\n                col = vec3(0.,1.,1.);\n            }\n            else if (posFPS > 60.)\n            {\n                col = vec3(0.,1.,0.);\n            }\n            else if (posFPS > 30.)\n            {\n                col = vec3(1.,1.,0.);\n            }\n            else \n            {\n                col = vec3(1.,0.,0.);\n            }\n            \n            if (fract(posFPS/10.)<0.05)\n            {\n                col *= 0.9;\n            }\n        }\n    }\n    \n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(float dist, vec3 col, float f)\n{\n    vec3 Kr = vec3(0.05,0.7,0.9);\n    vec3 c = col;    \n    c *= (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.05,0.7,0.9), vec3(f / max(dist*0.5,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.01,0.85,0.9), vec3(f / max(dist*0.1,0.0000000001))));\n    return c;\n}\n\n//============================================================\n// credit: demofox https://www.shadertoy.com/view/4tyXDR\n#define OBJECT_REFLECTIVITY 0.0 // How reflective the object is. regardless of fresnel.\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    // Ensure axis is normalized\n    axis = normalize(axis);\n    \n    // Sine and cosine of the angle\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    // Rotation matrix calculation using Rodrigues' rotation formula\n    return mat4(\n        vec4(\n            oc * axis.x * axis.x + c,\n            oc * axis.x * axis.y - axis.z * s,\n            oc * axis.x * axis.z + axis.y * s,\n            0.0\n        ),\n        vec4(\n            oc * axis.x * axis.y + axis.z * s,\n            oc * axis.y * axis.y + c,\n            oc * axis.y * axis.z - axis.x * s,\n            0.0\n        ),\n        vec4(\n            oc * axis.x * axis.z - axis.y * s,\n            oc * axis.y * axis.z + axis.x * s,\n            oc * axis.z * axis.z + c,\n            0.0\n        ),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n\n// Credit: https://claude.ai/chat/f83e94c0-06f6-4ca4-868f-fa27b2c47567\n// Function to compute ray dispersion through a sphere\nfloat computeRayDispersion(\n    vec3 rd,      // Ray direction\n    vec3 nor,     // Surface normal\n    float r,      // Sphere radius\n    float ior     // Index of refraction\n) \n{\n    // Compute incident angle\n    float cosIncident = abs(dot(rd, nor));\n    \n    // Compute refraction angle using Snell's law\n    // sin(theta1) / sin(theta2) = n2 / n1\n    // Where n1 is the refractive index of the first medium (typically air = 1.0)\n    // and n2 is the refractive index of the sphere material\n    float n1 = 1.0;  // Air\n    float n2 = ior;  // Material's index of refraction\n    \n    // Compute sin of refraction angle using Snell's law\n    float sinRefraction = (n1 / n2) * sqrt(1.0 - cosIncident * cosIncident);\n    \n    // Check for total internal reflection\n    if (sinRefraction > 1.0) {\n        // Total internal reflection occurs\n        return 0.0;\n    }\n    \n    // Compute cosine of refraction angle\n    float cosRefraction = sqrt(1.0 - sinRefraction * sinRefraction);\n    \n    // Compute dispersion (angular spread of rays)\n    // This is approximated by the difference between incident and refraction angles\n    float dispersionAngle = abs(acos(cosIncident) - acos(cosRefraction));\n    \n    // Optional: Add chromatic aberration effect\n    // Different wavelengths have slightly different refractive indices\n    // We'll use a simple approximation\n    float wavelengthDispersion = 0.02 * (n2 - n1);\n    \n    // Combine angle-based and wavelength-based dispersion\n    float totalDispersion = dispersionAngle + wavelengthDispersion;\n    \n    // Normalize and scale dispersion for more intuitive values\n    return totalDispersion / (0.5 * 3.14159);\n}\n","name":"Common","description":"","type":"common"}]}