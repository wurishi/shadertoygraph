{"ver":"0.1","info":{"id":"tdtSWX","date":"1573349940","viewed":223,"name":"Overwatch - Round Ended","username":"LilBensson","description":"I wanted to try making the effect that shows up when a round is ended in Overwatch. So here is my take on it! :D","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","fire","overwatch","roundended"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n\nfloat PI = acos(-1.0);\n\nfloat Noise(float n)\n{\n    return fract(sin(n*4616.5451 + 566.163) * 7624.564);\n}\n\nfloat Noise21(vec2 n)\n{\n\treturn fract(sin(n.x*1265.63265 + n.y*7427.8432 + 654.163) * 6432.564);\n}\n\nfloat BetterNoise21(vec2 n)\n{\n    float decimalScale = 1000.0;\n    n = round(n*decimalScale)/decimalScale;\n    \n\tn = fract(n*vec2(573.721, 853.712));\n    n += dot(n, n+64.853);\n    \n    return fract(n.x*n.y);\n}\n\nvec2 BetterNoise22(vec2 n)\n{\n\tfloat p = BetterNoise21(n);\n    \n    return vec2(p, BetterNoise21(p+n));\n}\n\nfloat PerlinNoiseLayer(vec2 p)\n{\n\tfloat offsetStep = 1.0;\n    float gridSize = 10.0;\n    \n    vec2 st = smoothstep(0.0, 1.0, fract(p * gridSize));\n    vec2 id = floor(p * gridSize);\n    \n    float upperLeft  = Noise21(id + vec2(0.0, 0.0));\n    float upperRight = Noise21(id + vec2(offsetStep, 0.0));\n    float lowerLeft  = Noise21(id + vec2(0.0, offsetStep));\n    float lowerRight = Noise21(id + vec2(offsetStep, offsetStep));\n    \n    float upperMix = mix(upperLeft, upperRight, st.x);\n    float lowerMix = mix(lowerLeft, lowerRight, st.x);\n    \n    float finalMix = mix(upperMix, lowerMix, st.y);\n    \n\treturn finalMix;\n}\n\nfloat PerlinNoise(vec2 p)\n{\n    float currentNoise = 0.0;\n    \n    currentNoise += PerlinNoiseLayer(p*4.0)/2.0;\n    currentNoise += PerlinNoiseLayer(p*8.0)/4.0;\n    currentNoise += PerlinNoiseLayer(p*16.0)/8.0;\n    currentNoise += PerlinNoiseLayer(p*32.0)/16.0;\n    currentNoise += PerlinNoiseLayer(p*64.0)/32.0;\n    \n    // Returns value from 0 to 0.96875    \n    return currentNoise;\n}\n\nmat2 Rot(float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat Circle(vec2 uv, vec2 position, float radius)\n{\n\tfloat dist = length(uv - position);\n    \n    dist = smoothstep(radius+0.01, radius, dist);\n    \n    return dist;\n}\n\nvec3 MiddleCircles(vec2 uv, vec3 middleBoxColor)  \n{\n    vec3 col = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 50.0; i++)\n    {\n        float movementSpeed = 0.15;\n        float pt = fract(Noise(i*7412.51 + 742.74) + t*movementSpeed);\n        \n    \tvec2 p = vec2(Noise(i*612.63), Noise(i*137.11 + 467.32));\n        p = p * 2.0 - 1.0;\n        p.y *= 0.15;\n        \n        // Slow down as it comes towards the window edge\n        p.x = (1.0 - pow(pt-1.0, 2.0));\n        \n        // Flip back again\n        p.x *= Noise(i*626.31) < 0.5 ? -1.0 : 1.0;\n        \n        float circleSize = Noise(i*213.74) * 0.028;\n        \n        float c = Circle(uv, p, circleSize);\n        float fade = smoothstep(0.9, 0.0, abs(p.x));\n        fade = clamp(fade, 0.0, 1.0);\n        \n        vec3 circleCol = vec3(c) * middleBoxColor * fade;\n        circleCol = circleCol * pow(fade+1.0, 3.0);\n        \n        col += circleCol;\n    }\n    \n    return col;\n}\n\nvec3 MiddleBox(vec2 uv)\n{\n    vec2 distances = abs(uv);\n\tfloat d = distances.y;\n    \n    float height = 0.2;\n    d = smoothstep(height+0.08, height-0.01, d);\n    d *= 0.8;\n    d = pow(d, 5.0);\n    d *= pow((1.0 - abs(uv.y))*1.5, 2.3);\n    \n    float r = d*clamp(uv.x, 0.0, 1.0);\n    float b = d*clamp(-uv.x, 0.0, 1.0);\n    \n    float lineHeight = 60.0;\n    float horizontalLine = Noise(round(uv.y * lineHeight)/lineHeight);\n    horizontalLine = 1.0 - horizontalLine*0.1;\n    \n    vec3 mainBoxCol = vec3(r, 0.0, b) * horizontalLine;\n    vec3 edges = vec3(1.0);\n    edges *= smoothstep(height-0.08, height+0.01, d);\n    edges *= smoothstep(height+0.2, height+0.15, d);\n    edges *= 0.3;\n    \n    return mainBoxCol + edges;\n}\n\nvec3 ThreeMiddleLights(vec2 uv)\n{\n    float toThePower = 3.0;\n    \n\tfloat currentDistance = 0.0;\n    currentDistance += pow(1.0 - length(uv), toThePower);\n    currentDistance += pow(1.0 - length(uv + vec2(0.9, 0.0)), toThePower);\n    currentDistance += pow(1.0 - length(uv - vec2(0.9, 0.0)), toThePower);\n    \n    return vec3(currentDistance*0.8);\n}\n\nvec3 Smoke(vec2 uv)\n{\n    vec3 finalCol = vec3(0.0);\n    \n    for(float layer = 0.0; layer < 3.0; layer++)\n    {\n        float perl = PerlinNoise(uv*0.3 + vec2(0.04 * layer, 0.0) * iTime * sign(uv.x));\n\n        perl *= pow(abs(uv.x), 2.0) * pow((1.0 - abs(uv.y)) * 0.9, 1.0);\n\n        float r = perl * clamp(uv.x, 0.0, 1.0) * 4.0;\n        float b = perl * clamp(-uv.x, 0.0, 1.0) * 4.0;\n\n        float alpha = 0.3;\n        \n        finalCol += vec3(perl) * vec3(r, 0.0, b) * alpha;\n    }\n    \n    \n\treturn finalCol;\n}\n\nvec3 Fire(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    for(float layers = 0.0; layers < 4.0; layers++)\n    {\n        // The fire\n        vec2 speed = vec2(0.0, -0.6) * t  * (1.0 + 0.1*layers);\n        vec2 layerOffset = vec2(632.763, 1631.631) * layers;\n        \n        float n = PerlinNoise(uv + speed + layerOffset);\n\n        // Decrease alpha the further away it is\n        n *= pow(1.0 - length(uv*vec2(1.0, 0.3)), 7.0)*1.2;\n\n        // Decrease alpha below y = 0.0\n        n *= uv.y > 0.0 ? 1.0 : pow(1.0-abs(uv.y), 10.0); \n\n        float threshold = 0.3 * (1.0 - pow(abs(uv.y), 4.0));\n        n *= smoothstep(threshold-0.06, threshold, n);\n        \n        // Actual fire color\n        //col += vec3(n*n, n*n*n, 0.0)*3.0;\n        col += vec3(n)*1.3;\n    }\n    \n\treturn col;\n}\n\nvec3 MiddleFire(vec2 uv)\n{\n    uv *= Rot(-0.2);\n    uv.x *= 2.5;\n    \n    vec3 f = vec3(0.0);\n    f += Fire(uv);\n    f += Fire(-uv);\n    \n    float middleOffset = 0.1;\n    float r = smoothstep(-middleOffset, -middleOffset+0.3, uv.x);\n    float b = smoothstep(middleOffset, middleOffset-0.3, uv.x);\n    \n    float g = smoothstep(middleOffset, 0.05, abs(uv.x));\n    \n    r += g;\n    b += g;\n    \n\treturn f * vec3(r, g, b);\n}\n\nvec2 ClosestPointLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pb = p-b;\n    vec2 ab = a-b;\n    \n\tfloat t = dot(pb, ab) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec2 closestPoint = t*a + (1.0 - t)*b;\n    \n    return closestPoint;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 closestPoint = ClosestPointLine(p, a, b);\n    float d = length(closestPoint - p);\n    \n    float radius = 0.01;\n    \n    float c = smoothstep(radius, radius*0.98, d);\n    return c;\n}\n\nvec2 VoroGetDotPos(vec2 id, vec2 offset)\n{\n    vec2 voroTime = BetterNoise22(id+offset);\n    \n    return sin(voroTime)*0.45 + offset;\n}\n\n// This part was a combination between the voronoi created by The Art Of Code (BigWings)\n// and some of own methods.\nvec3 Voronoi(vec2 uv)\n{\n    float gridSize = 5.0;\n    \n    uv *= gridSize;\n    \n    vec2 st = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 dotGrid = st;\n    \n    vec2 dotPos = VoroGetDotPos(id, vec2(0.0));\n    \n    float dotRadius = 0.1;\n    \n    float l = length(dotGrid - dotPos);\n    float d = smoothstep(dotRadius, dotRadius-0.01, l);\n    \n    vec2 closestNeighbor = vec2(0.0);\n    float closestNeighborDist = 1000.0;\n    \n    float lineCol = 0.0;\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n    \tfor(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 currentPos = VoroGetDotPos(id, vec2(x, y));\n            \n            // Find best neighbor\n            if(length(currentPos-st) < closestNeighborDist)\n            {\n                closestNeighborDist = length(currentPos-st);\n                closestNeighbor = id + vec2(x, y);\n            }\n            \n        \tlineCol += Line(st, dotPos, currentPos);\n        }\n    }\n    \n    // Take the sides into consideration\n    vec2 up = VoroGetDotPos(id, vec2( 0.0,  1.0));\n    vec2 down = VoroGetDotPos(id, vec2( 0.0, -1.0));\n    vec2 right = VoroGetDotPos(id, vec2( 1.0,  0.0));\n    vec2 left = VoroGetDotPos(id, vec2(-1.0,  0.0));\n    \n    lineCol += Line(st, up, right);\n    lineCol += Line(st, up, left);\n    lineCol += Line(st, down, right);\n    lineCol += Line(st, down, left);\n    \n    float randCol = BetterNoise21(closestNeighbor);\n    \n    vec3 col = vec3(randCol);\n    //col += vec3(lineCol);\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized uv coordinates\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y; \n    \n    vec3 col = vec3(0.0);\n    \n    // Voronoi\n    col += Voronoi(uv)*0.20 * pow(length(uv), 3.0);\n    \n    // Red/Blue box in the background\n    vec3 b = MiddleBox(uv);\n    col += b;\n    \n    // Circles\n    col += MiddleCircles(uv, b);\n    \n    // Smoke from the sides\n    col += Smoke(uv);\n    \n    // Three middle lights\n    col += ThreeMiddleLights(uv) * (b+0.3);\n    \n    // Fire in the middle\n    col += MiddleFire(uv);\n    \n    //col = Fire(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}