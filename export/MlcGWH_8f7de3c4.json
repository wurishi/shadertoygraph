{"ver":"0.1","info":{"id":"MlcGWH","date":"1469025094","viewed":2289,"name":"[Test] simple advection","username":"Ultraviolet","description":"Move the smoke ball !\n\noriginally inspired from https://www.shadertoy.com/view/4sc3DB for the channel setup\nand https://www.shadertoy.com/view/Xt33Dn for the velocity noise(buff C)\n","likes":54,"published":1,"flags":32,"usePreview":0,"tags":["2d","smoke","advection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  __  __       _         _____                            \n |  \\/  |     (_)       |_   _|                           \n | \\  / | __ _ _ _ __     | |  _ __ ___   __ _  __ _  ___ \n | |\\/| |/ _` | | '_ \\    | | | '_ ` _ \\ / _` |/ _` |/ _ \\\n | |  | | (_| | | | | |  _| |_| | | | | | (_| | (_| |  __/\n |_|  |_|\\__,_|_|_| |_| |_____|_| |_| |_|\\__,_|\\__, |\\___|\n                                                __/ |     \n                                               |___/      \n*/\n\nvec2 screen2uv(in vec2 fragCoord)\n{\n    return fragCoord / iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = screen2uv(fragCoord);\n    fragColor = texture(iChannel0,  uv);\n    //fragColor = abs(texture(iChannel1,  uv)*100.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n   _____                           _             _   _              \n  / ____|                         | |           | | (_)            \n | |     ___  _ __   ___ ___ _ __ | |_ _ __ __ _| |_ _  ___  _ __  \n | |    / _ \\| '_ \\ / __/ _ \\ '_ \\| __| '__/ _` | __| |/ _ \\| '_ \\ \n | |___| (_) | | | | (_|  __/ | | | |_| | | (_| | |_| | (_) | | | |\n  \\_____\\___/|_| |_|\\___\\___|_| |_|\\__|_|  \\__,_|\\__|_|\\___/|_| |_|\n                                                                           \n                                                                           \n*/\n\n#define Dt (1.0)\n\n// number of iteration for implicit solving\n#define NITER\t100\n\nvec2 screen2world(in vec2 fragCoord)\n{\n    return (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n}\n\nvec2 world2screen(in vec2 pos)\n{\n    return (pos*iResolution.y + iResolution.xy) * 0.5;\n}\n\nvec2 screen2uv(in vec2 fragCoord)\n{\n    return fragCoord / iResolution.xy;\n}\n\nvec2 uv2screen(in vec2 uv)\n{\n    return uv * iResolution.xy;\n}\n\nvec2 world2uv(in vec2 pos)\n{\n    return world2screen(pos) / iResolution.xy;\n}\n\nvec2 uv2world(in vec2 uv)\n{\n    return screen2world(uv2screen(uv));\n}\n\nvec2 implicitSolveV(vec2 pos)\n{\n    vec2 posInit = pos;\n    for(int i=0; i<NITER; i++)\n    {\n        pos = posInit - Dt*texture(iChannel1,  world2uv(pos)).xy;\n    }\n    \n    return pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 pos = screen2world(fragCoord);\n    if (iMouse.x < 10.0) \n    {\n        if (length(vec2(cos(iTime), 0.7*sin(2.0*iTime))*vec2(1.2,0.6) - pos) < .06) \n        {\n            fragColor = vec4(1.,1.,1.,1.);\n        \treturn;\n        }\n    } \n    else \n    {\n        if(iMouse.z > 0.0)\n        if (length(screen2world(iMouse.xy)-pos) < .06) \n        {\n            fragColor = vec4(1.,1.,1.,1.);\n            return;\n        }\n    }\n    \n/*    \n    vec2 speed = texture(iChannel1, world2uv(pos)).xy;\n    //speed = 0.5*(speed + texture(iChannel1, world2uv(pos - speed*Dt)).xy);\n    fragColor = vec4(0.99, 0.99, 1.0, 1.0) * texture(iChannel0, world2uv(pos - speed*Dt))*.99;\n/*/\n\n    vec2 advPos = implicitSolveV(pos);\n    vec4 newVal = texture(iChannel0, world2uv(advPos));\n    fragColor = vec4(0.99, 0.99, 1.0, 1.0) * newVal *.99;\n    //fragColor = vec4(world2uv(advPos), 0.0, 0.0);\n    \n//*/\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n   _____                     _ \n  / ____|                   | |\n | (___  _ __   ___  ___  __| |\n  \\___ \\| '_ \\ / _ \\/ _ \\/ _` |\n  ____) | |_) |  __/  __/ (_| |\n |_____/| .__/ \\___|\\___|\\__,_|\n        | |                    \n        |_|                    \n*/\n\nmat3 m = mat3( 0.00,  0.90,  0.60,\n              -0.90,  0.36, -0.48,\n              -0.60, -0.48,  0.34 );\n\nfloat hash21(vec2 p)\n{\t\n    float h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33( vec3 p )\n{\t\n    #if 0\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\t#else\n    \tp = m*p;\n    #endif\n\treturn -1.+2.*fract(sin(p)*43758.5453123);\n}\n\nfloat hash31(vec3 p)\n{\t\n    #if 0\n    p = m*p;\n    #endif\n\tfloat h =  dot(p,vec3(127.1,311.7, 74.7));\n    return -1.+2.*fract(sin(h)*43758.5453123);\n}\n\n//2d traditional gradient noise\nfloat noise_perlin(vec2 p)\n{\n\tvec2 ni = floor(p);\n    vec2 nf = fract(p);\n    \n    vec2 w = nf*nf*(3.-2.*nf);\n    \n    float f1 = dot(hash22(ni),nf);\n    float f2 = dot(hash22(ni+vec2(1.,0.)),nf-vec2(1.,0.));\n    float f3 = dot(hash22(ni+vec2(1.,1.)),nf-vec2(1.,1.));\n    float f4 = dot(hash22(ni+vec2(0.,1.)),nf-vec2(0.,1.));\n    \n    float f12 = mix(f1,f2,w.x);\n    \n    float f34 = mix(f4,f3,w.x);\n    \n    float f=mix(f12,f34,w.y);\n    \n    return f;\n    \n}\n//3d traditional gradient noise\nfloat noise_perlin1(vec3 p)\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\t\n    vec2 zo = vec2(0.,1.);\n    float f000 = dot(hash33(i),f-zo.xxx);\n    float f010 = dot(hash33(i+zo.yxx),f-zo.yxx);\n    float f001 = dot(hash33(i+zo.xyx),f-zo.xyx);\n    float f011 = dot(hash33(i+zo.yyx),f-zo.yyx);\n    \n    float hx1 = mix(f000,f010,u.x);\n    float hx2 = mix(f001,f011,u.x);\n    float hy1 = mix(hx1,hx2,u.y);\n    \n    float f100 = dot(hash33(i+zo.xxy),f-zo.xxy);\n    float f110 = dot(hash33(i+zo.yxy),f-zo.yxy);\n    float f101 = dot(hash33(i+zo.xyy),f-zo.xyy);\n    float f111 = dot(hash33(i+zo.yyy),f-zo.yyy);\n    \n    hx1 = mix(f100,f110,u.x);\n    hx2 = mix(f101,f111,u.x);\n    float hy2 = mix(hx1,hx2,u.y);\n    \n    float h = mix(hy1,hy2,u.z);\n    \t\n    return h;\n}\n\n//2d traditional value noise\nfloat noise_value( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash21( i + vec2(0.0,0.0) ), \n                     hash21( i + vec2(1.0,0.0) ), u.x),\n                mix( hash21( i + vec2(0.0,1.0) ), \n                     hash21( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//3d traditional value noise\nfloat noise_value1( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\t\n    vec2 zo = vec2(0.,1.);\n    float f000 = hash31(i);\n    float f010 = hash31(i+zo.yxx);\n    float f001 = hash31(i+zo.xyx);\n    float f011 = hash31(i+zo.yyx);\n    \n    float hx1 = mix(f000,f010,u.x);\n    float hx2 = mix(f001,f011,u.x);\n    float hy1 = mix(hx1,hx2,u.y);\n    \n    float f100 = hash31(i+zo.xxy);\n    float f110 = hash31(i+zo.yxy);\n    float f101 = hash31(i+zo.xyy);\n    float f111 = hash31(i+zo.yyy);\n    \n    \n     hx1 = mix(f100,f110,u.x);\n     hx2 = mix(f101,f111,u.x);\n    float hy2 = mix(hx1,hx2,u.y);\n    \n    float h = mix(hy1,hy2,u.z);\n    \t\n    return h;\n}\n\n// shadertoy's 3d noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.-1.;\n}\n//-------------------------------------------------------------------------------------\n//fbm 2d traditional gradient noise\nfloat map5_perlin(vec2 p)  \n{\t\n    float r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_perlin(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n//fbm 3d traditional gradient noise\nfloat map5_perlin1(vec3 p)  \n{\t\n    float r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_perlin1(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n//fbm 2d traditional value noise\nfloat map5_value(vec2 p)\n{\n\tfloat r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_value(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n//fbm 3d traditional value noise\nfloat map5_value1(vec3 p)\n{\n\tfloat r = 0.;\n    float s = 1.;\n    float f = 1.;\n    \n    float w = 0.;\n    for(int i = 0;i < 5;i++){\n        r += s*noise_value1(p*f); w += s;\n        s /= 2.;\n        f *= 2.;\n    }\n    return r/w;\n}\n\n\nvec2 screen2world(in vec2 fragCoord)\n{\n    return (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n}\n\nvec2 fractalNoise2d(vec2 p, float t, float scale)\n{\n    return vec2(map5_value1(vec3(p*scale, t)), \n                map5_value1(vec3(p*scale+ vec2(100.0*scale), t)));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = screen2world(fragCoord);\n    fragColor = -vec4(fractalNoise2d(pos, iTime, 10.0)*0.01, 0.0, 0.0);\n}\n","name":"Buf C","description":"","type":"buffer"}]}