{"ver":"0.1","info":{"id":"WsS3zG","date":"1549469658","viewed":1521,"name":"My First Raymarching (terrain)","username":"jaszunio15","description":"My very first raymarching approach. Inspired by Inigo Quilez \"Elevated\": https://www.shadertoy.com/view/MdX3Rr\nUse mouse to rotate the camera, Z key - zoom, U - ultra zoom.\n\nVideo in Full HD: https://youtu.be/nbwu3dSHSgY\n\nEnjoy the view ;)","likes":26,"published":1,"flags":16,"usePreview":0,"tags":["procedural","raymarching","terrain","sunset","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)\n\nfloat hash(vec2 v)\n{\n \treturn fract(sin(dot(v, vec2(51.2838, 8.4117))) * 2281.2231); \n}\n\nfloat getNoise(vec2 v)\n{\n \tvec2 rootV = floor(v);\n    vec2 f = smoothstep(0.0, 1.0, fract(v));\n\n    vec4 n;\n    n.x = hash(rootV);\n    n.y = hash(rootV + vec2(0.0, 1.0));\n    n.z = hash(rootV + vec2(1.0, 0.0));\n    n.w = hash(rootV + vec2(1.0, 1.0));\n    \n    n.xy = mix(n.xz, n.yw, f.y);\n    return mix(n.x, n.y, f.x);\n}\n\n//Mountain height\nfloat getTerrainNoise(vec2 v, int layers)\n{\n    float bigNoise = (getNoise(v * 0.16));\n    \n    float smallNoise = smoothstep(0.7, 1.0, getNoise(v * 30.0));\n    smallNoise *= POW4(smallNoise) * 0.003 * bigNoise;\n    \n \tfloat noise = 0.0;\n    float noiseStrength = 1.0;\n    \n    for(int i = 0; i < layers; i++)\n    {\n     \tnoise += pow(getNoise(v), 2.5 - noiseStrength) * noiseStrength * sqrt(bigNoise);\n        v *= NOISE_MUL;\n        noiseStrength *= NOISE_Q;\n    }\n    \n    noise *= (1.0 - NOISE_Q)/(1.0 - pow(NOISE_Q, float(NOISE_LAYERS)));\n\n    bigNoise *= bigNoise;\n    bigNoise *= (MAX_HEIGHT - 1.0);\n    return (noise + bigNoise + smallNoise);\n}\n\nvec3 getNormal(vec2 p, int noiseLayers)\n{\t\n \tfloat v00 = getTerrainNoise(p, noiseLayers);\n    float v10 = getTerrainNoise(p + vec2(EPSILON, 0.0), noiseLayers);\n    float v01 = getTerrainNoise(p + vec2(0.0, EPSILON), noiseLayers);\n    \n    return normalize(cross(vec3(EPSILON, 0, v10 - v00), vec3(0, EPSILON, v01 - v00)));\n}\n\n//just for clear code\nfloat terrainDist(vec3 p, vec2 rayDir)\n{\n    return p.z - getTerrainNoise(p.xy, NOISE_LAYERS);\n}\n\n//xyz - hit point, w distance\nvec4 rayMarch(vec3 startPoint, vec3 direction, int iterations, float maxStepDist)\n{\n \tvec3 point = startPoint;\n    direction = normalize(direction);\n    float distSum = 0.0;\n    float shadowData = 1.0;\n    float dist = 10.0;\n    \n    int i;\n    for (i = 0; i < iterations && distSum < MAX_VIEW_DISTANCE && abs(dist) > EPSILON; i++)\n    {\n     \tdist = terrainDist(point, direction.xy);\n        dist = min(dist, maxStepDist) * 0.4;\n        distSum += dist;\n        point += direction * dist;\n    }\n    \n    return vec4(point.xyz, distSum);\n}\n\n//x - hard shadows, y - smooth shadows\nvec2 shadowMarch(vec3 startPoint, vec3 direction, int iterations, float maxStepDist)\n{\n    vec3 point = startPoint;\n    direction = normalize(direction);\n    float dist = 10.0;\n    float distSum = 0.0;\n    float shadowData = 0.0;\n    float shadow = 0.0;\n    \n    int i;\n    for (i = 0; i < SHADOW_RAYS_COUNT && distSum < MAX_SHADOW_DISTANCE && abs(dist) > EPSILON * 0.5; i++)\n    {\n     \tdist = terrainDist(point, direction.xy);\n        \n        shadow = dot(normalize((point - vec3(0.0, 0.0, dist)) - startPoint), direction);\n        if(shadow > shadowData) shadowData = shadow;\n        \n        dist = min(dist, 1.0);\n        distSum += dist;\n        point += direction * dist;     \n    }\n    \n    return vec2(smoothstep(MAX_SHADOW_DISTANCE - EPSILON, MAX_SHADOW_DISTANCE, distSum), shadowData);\n}\n\n//Poor but works\nfloat getClouds(vec2 v)\n{\n    v += vec2(iTime * TIME_SCALE * 5.0);\n    return getNoise(v.xy * vec2(0.1, 0.2)) * pow(getNoise(v.xy * vec2(0.3, 0.24)), 2.0) * getNoise(v.xy * 0.05);\n}\n\nfloat getZoom()\n{\n \treturn texture(iChannel0, ZOOM_KEY_COORD).r * 2.0 + texture(iChannel0, ULTRA_ZOOM_KEY_COORD).r * 10.0;\n}\n\n//converts uv point (from (-1,-1) to (1,1)) to view space\nvec3 renderPlanePoint(vec2 uv, float zoom) \n{ \n    return vec3(uv.x, A_LA_FOV + zoom, uv.y);\n}\n\n//Blending lens flares with screen\nvec3 mixLens(vec3 screen, vec3 lens)\n{\n    float brightness = min(max(lens.r, max(lens.g, lens.b)), 1.0);\n \treturn screen * (1.0 - brightness) + lens * 2.4;   \n}\n\n//Rotation matrices\nmat4x4 getYawMatrix(float yaw)\n{\n \tfloat c = cos(yaw);\n    float s = sin(yaw);\n    return mat4x4(c, s, 0.0, 0.0,\n                  -s, c, 0.0, 0.0, \n                  0.0, 0.0, 1.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0); \n}\n\nmat4x4 getPitchMatrix(float pitch)\n{\n\tfloat c = cos(pitch);\n    float s = sin(pitch);\n\treturn mat4x4(1.0, 0.0, 0.0, 0.0,\n                  0.0, c, s, 0.0, \n                  0.0, -s, c, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n}\n\nmat4x4 getOffsetMatrix(vec3 offset)\n{\n    return mat4x4(1.0, 0.0, 0.0, 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  0.0, 0.0, 1.0, 0.0,\n                  offset.x, offset.y, offset.z, 1.0);\n}\n\n//ACTION!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse;\n    if(length(iMouse.xy) >= 1.0) mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n    else mouse = vec2(0.0);\n    \n    float time = (iTime * TIME_SCALE) + TIME_OFFSET;\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    float zoom = getZoom();\n    vec3 camPos;\n    camPos.x = cos(-time * CAMERA_MOVEMENT_SPEED) * 300.0;\n    camPos.y = sin(-time * CAMERA_MOVEMENT_SPEED) * 300.0;\n    camPos.z = getTerrainNoise(camPos.xy, 1) + 1.2 + sin(time * 0.22) * 0.7;\n\n    //Rotation around Z (world up) axis\n    float zAngle = -time * CAMERA_ROTATION_SPEED + -mouse.x * PI * 3.0;\n    float xAngle = sin(time * 0.17) * 0.1 - camPos.z / MAX_HEIGHT * 0.3 + mouse.y * PI * 0.5;\n\n    //Final matrices\n    mat4x4 viewToWorld = getOffsetMatrix(camPos) * getYawMatrix(zAngle) * getPitchMatrix(xAngle);\n    mat4x4 worldToView = getPitchMatrix(-xAngle) * getYawMatrix(-zAngle) * getOffsetMatrix(-camPos);\n    \n    //Rays\n\tvec3 rayDir = normalize(mat3x3(viewToWorld) * renderPlanePoint(uv, zoom));\n    vec3 centerRayDir = normalize(mat3x3(viewToWorld) * renderPlanePoint(vec2(0.0), zoom));\n    \n    //Raymarching\n\tvec4 rayMarched = rayMarch(camPos, rayDir, RAYS_COUNT, 1.5);\n    vec3 hitPoint = rayMarched.xyz;\n    float height = rayMarched.z / MAX_HEIGHT; //terrain height from 0 to 1\n    \n    //Initialize light variables\n    float fog = smoothstep(0.0, MAX_VIEW_DISTANCE, rayMarched.w);\n    fog = POW2(fog);\n    vec3 lightDir = normalize(vec3(-sin(-time * 0.1), -cos(-time * 0.1), cos(time * 0.09 + 0.5) * 0.4 + LIGHT_HEIGHT));\n    vec3 sunDir = normalize(lightDir + vec3(0, 0, FAKE_SUN_LIFT));\n    float sunset = 1.0 - smoothstep(-1.4, 0.5, dot(rayDir, lightDir) + abs(rayDir.z) * 2.0);\n    \n    //Initialize colors\n   \tvec3 col = vec3(0.0);\t//main color that will be placed on screen   \n    vec3 skyColor = mix(SKY_COLOR, SUNSET_COLOR * 0.3, (1.0 - lightDir.z));\n    skyColor = mix(skyColor, SUNSET_COLOR, min(sunset * (1.0 - lightDir.z), 1.0));\n    vec3 lightColor = mix(LIGHT_COLOR, SUNSET_COLOR, clamp((1.0 - lightDir.z), 0.0, 1.0));\n\n    if (rayMarched.w < MAX_VIEW_DISTANCE)\n    {\n        //Terrain\n        vec3 normal = getNormal(hitPoint.xy, NORMAL_NOISE_LAYERS);\n        \n\t\t//Terrain color\n        vec3 groundCol = GROUND_COLOR * (0.8 + getNoise(hitPoint.xy * 1000.0) * 0.2) * 0.8;\n        vec3 mountainCol = MOUNTAIN_COLOR * (0.4 + getTerrainNoise(hitPoint.xy * 20.0, 3) / MAX_HEIGHT * 0.6);\n        vec3 ground = mix(groundCol, mountainCol, smoothstep(0.0, 0.4, height)); \n        col = ground;\n        \n        float snowTresh = getNoise(hitPoint.xy * 0.31) * 0.15 + 0.1;\n        vec3 snowCol = mix(GRASS_COLOR, vec3(1.5), smoothstep(snowTresh, snowTresh + 0.07, height));\n        float snow = smoothstep(0.6 - height * 0.5, 1.0, getNormal(hitPoint.xy, 3).z * getNormal(hitPoint.xy, 7).z);\n    \tcol = mix(col, snowCol, sqrt(snow));\n        \n        \n        //Lighting\n        float light = max(dot(normal, lightDir), 0.0);\n        vec3 halfWay = normalize((-rayDir + lightDir) * 0.5);\n        float specLight = pow(max(dot(halfWay, normal), 0.0), 2.0);\n        \n        float energyConservation = (snow * height + 1.0) * 0.5;\n        \n        float cloudShadow = smoothstep(0.7, 1.7, 1.0 - getClouds(hitPoint.xy + lightDir.xy * 10.0)) + 0.7;\n        vec2 shadowData = shadowMarch(hitPoint + normal * EPSILON * 4.0, lightDir, SHADOW_RAYS_COUNT, 1.0);\n        float shadow = smoothstep(0.0, 1.0, 1.0 - smoothstep(SHADOW_BLUR_ANGLE, 1.0, shadowData.y)) * shadowData.x;\n\n        col = col * (light * (1.0 - energyConservation) + specLight * energyConservation) * shadow * cloudShadow * 0.8 * lightColor \n            + col * skyColor * 0.2 + light * 0.02 * lightColor;\n        col = mix(col, skyColor, fog);\n    }\n    else\n    {\n        //Sky\n        col = mix(col, skyColor, fog);\n        float sun = max(dot(rayDir, sunDir), 0.0);\n        sun = smoothstep(0.9985, 0.9999, sun) + smoothstep(0.95, 1.1, sun) * 0.2;\n        \n        vec2 skyPoint = camPos.xy + (rayDir.xy / -rayDir.z) * -10.0;\n        float cloud = getClouds(skyPoint.xy);\n        cloud = mix(cloud, 0.0, smoothstep(0.2, -0.0, rayDir.z));\n        col = mix(col, vec3(skyColor + 1.0) * 0.5, cloud);\n        \n        col = mix(col, max(lightColor, vec3(0.0)), sun);\n    }\n    \n    //Lens flares\n    vec2 shadowData = shadowMarch(camPos, lightDir, RAYS_COUNT, 1.0);\n    float lensFlare = clamp(1.0 - smoothstep(SHADOW_BLUR_ANGLE, 1.0, shadowData.y), 0.0, 1.0) * shadowData.x;\n    if(lensFlare > 0.01)\n    {   \n\n        //Calculating sun position on the screen\n        vec3 viewSunDir = (worldToView * vec4(sunDir, 0.0)).xyz;\n        vec2 sunUV = (viewSunDir.xz / viewSunDir.y) * (A_LA_FOV + zoom);\n\n        float centerLight = dot(lightDir, centerRayDir);\n\t\tfloat lensStrength = smoothstep(0.5, 1.0, centerLight) * 0.15 * lensFlare;\n        \n        vec3 lensCol = vec3(0.0);\n        \n        lensCol += skyColor * 0.5;\n        \n        //Around the sun\n        lensCol += (1.0 - smoothstep(0.0, 0.18, distance(uv, sunUV))) * vec3(1.0, 0.12, 0.12) * 4.0;\n        lensCol += (1.0 - smoothstep(0.0, 0.013, abs(distance(uv, sunUV) - 0.16))) * vec3(1.0, 0.12, 0.12) * 1.5;\n        \n        \n        lensCol += (1.0 - smoothstep(0.035, 0.043, distance(uv, sunUV * 0.3))) * vec3(1.0, 0.4, 0.12) * 1.0; //Yellow disc\n        lensCol += (1.0 - smoothstep(0.0, 0.008, distance(uv, sunUV * 0.13))) * vec3(0.4, 1.0, 0.6) * 3.0; //Small green dot\n        lensCol += (1.0 - smoothstep(0.0, 0.015, distance(uv, sunUV * -0.13))) * vec3(0.4, 1.0, 0.6) * 3.0; //Bigger small green dot\n        lensCol += (1.0 - smoothstep(0.07, 0.09, distance(uv, sunUV * -0.3))) * vec3(1.0, 0.5, 0.12) * 0.5; //Big yellow disc\n        lensCol += (1.0 - smoothstep(0.00, 0.05, abs(distance(uv, sunUV * -0.3) - 0.11))) * vec3(1.0, 0.5, 0.12) * 0.5; //Big yellow disc\n\t\tlensCol += (1.0 - smoothstep(0.00, 0.05, distance(uv, sunUV * -0.5))) * vec3(0.1, 0.1, 1.0) * 0.7; //Blue dot\n        lensCol += (1.0 - smoothstep(0.05, 0.09, distance(uv, sunUV * -0.5))) * vec3(0.1, 0.9, 0.8) * 0.4; //Green disc\n        lensCol += (1.0 - smoothstep(0.01, 0.05, abs(distance(uv, sunUV * -0.75) - 0.15))) * vec3(0.4, 0.9, 0.1) * 0.2; //Green circle\n        \n        \n        col = mixLens(col, lensCol * lensStrength * skyColor);\n    }\n    \n    col = pow(col, vec3(0.45));\n    \n    //postprocess\n    float avgCol = max(col.r, max(col.g, col.b));\n    col = smoothstep(0.05, 0.95, col);\n    col = mix(col, vec3(avgCol), 0.3);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//terrain generation\n#define NOISE_LAYERS 5\n#define NOISE_Q 0.32\n#define NOISE_MUL 2.6\n#define NORMAL_NOISE_LAYERS 6\n#define MAX_HEIGHT 8.0\n\n//rendering settings\n#define RAYS_COUNT 180\n#define SHADOW_RAYS_COUNT 90\n#define MAX_VIEW_DISTANCE 30.0\n#define MAX_SHADOW_DISTANCE 30.0\n#define SHADOW_BLUR_ANGLE 0.99\n#define FAKE_SUN_LIFT -0.1\n\n//lighting\n#define LIGHT_HEIGHT 0.55\n#define SUN_SIZE 4.0\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n\n//camera\n#define CAMERA_MOVEMENT_SPEED 0.0014\n#define CAMERA_ROTATION_SPEED 0.1\n#define A_LA_FOV 0.8\n#define ZOOM_KEY_COORD vec2(90.0 / 256.0, 0.0)\n#define ULTRA_ZOOM_KEY_COORD vec2(85.0 / 256.0, 0.0)\n\n//Constant variables\n#define EPSILON 0.001\n#define TWO_PI 6.28\n#define PI 3.14\n#define INV_SQRT2 0.7072\n\n//Colors\n#define SKY_COLOR vec3(0.5, 0.8, 1.0)\n#define SUNSET_COLOR vec3(0.9, 0.3, 0.2)\n\n#define GROUND_COLOR vec3(0.7, 0.5, 0.3)\n#define MOUNTAIN_COLOR vec3(0.4, 0.35, 0.3)\n#define GRASS_COLOR vec3(0.2, 0.28, 0.16)\n\n//Time\n#define TIME_OFFSET 39.0\n#define TIME_SCALE 1.0\n\n//Useful functions\n#define POW4(x) x*x*x*x\n#define POW2(x) x*x\n","name":"Common","description":"","type":"common"}]}