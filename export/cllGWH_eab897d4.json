{"ver":"0.1","info":{"id":"cllGWH","date":"1671784396","viewed":124,"name":"Poison gas","username":"jianinz","description":"Modify the code based on work from Ben Wheatley. Perlin noise based fire; each octave of the Perlin noise has a slightly different speed than the others, y ~ f(log2(octive_scale)*time)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","perlinnoise","fire"],"hasliked":0,"parentid":"MsdyDN","parentname":"Perlin noise fire"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Poison Gas\" by Jianing Zhang 2022\n *  Based on work from Ben Wheatley\n */\n \n/*\n * \"Fire\" by Ben Wheatley - 2018\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\n// constants\nconst int MAX_OCTAVE = 8;\nconst float PI = 3.14159265359;\n\nfloat cosineInterpolate(float a, float b, float x) {\n\tfloat ft = x * PI;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\n\treturn a*(1.0-f) + b*f;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat seededRandom(float seed) {\n    int x = int(seed);\n    x = x << 13 ^ x;\n    x = (x * (x * x * 15731 + 789221) + 1376312589);\n    x = x & 0x7fffffff;\n    return float(x)/1073741824.0;\n}\n\n// The magic constants are essentially arbitary:\n// they define the scale of the largest component of the Perlin noise\nfloat perlinNoise(float x_arg, float y_arg, float time_arg) {\n    float sum = 0.0;\n    for (int octave=0; octave<MAX_OCTAVE; ++octave) {\n        float sf = pow(2.0, float(octave));\n        float x = x_arg*sf;\n    \tfloat y = (y_arg*sf) + (1.5*time_arg*log2(sf));\n    \tfloat y_scale = 1.0*sf;\n        \n\t\tfloat x_floor = floor(x);\n\t\tfloat y_floor = floor(y);\n\t\tfloat fraction_x = x - x_floor;\n\t\tfloat fraction_y = y - y_floor;\n        \n        float t1 = random( vec2(x_floor\t+\ty_scale *  y_floor      ));\n\t\tfloat t2 = random( vec2(x_floor\t+\ty_scale * (y_floor+1.0) ));\n        \n        x_floor += 1.0;\n        float t3 = random( vec2(x_floor\t+\ty_scale *  y_floor      ));\n\t\tfloat t4 = random( vec2(x_floor\t+\ty_scale * (y_floor+1.0) ));\n        \n\t\tfloat i1 = cosineInterpolate(t1, t2, fraction_y);\n\t\tfloat i2 = cosineInterpolate(t3, t4, fraction_y);\n        \n        sum += cosineInterpolate(i1, i2, fraction_x)/sf;\n    }\n    return 2.0*sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float dx = 0.5 - uv.x;\n    float dy = 0.5 - uv.y;\n    dy *= iResolution.y / iResolution.x;\n    \n    float c = perlinNoise(dx, dy, iTime);\n    c -= 0.4;\n    c *= cos(dx*PI);\n    c *= 2. - 2. * ((uv.y/iResolution.y)*256.0);\n    \n    float red = c*0.045;\n    float green =  c*(dy+0.95);\n   \n    vec4 original = texture(iChannel0, uv);\n    vec4 heat = vec4(red,green,0.133,0);\n    fragColor = original + heat;\n}","name":"Image","description":"","type":"image"}]}