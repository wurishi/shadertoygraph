{"ver":"0.1","info":{"id":"dtyfWD","date":"1702066299","viewed":73,"name":"pine cone","username":"Efim","description":"it is first work in series \"pine cone\"","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","displacement","cone","pine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159265359\n#define TAU 6.28318530718\n\nconst float dist_infin = 5.0;\n#define nn 128\nconst float eps = 0.001;\nfloat sdCosNp(vec2 p, float a) {\n    \n    float fi = atan(p.y, p.x);\n    float L = length(p.xy);\n    float d = dist_infin;\n    float r = a * cos(2. * fi);\n    if(p.x < 0.)\n        r = -.5;\n    d = min(abs(L - r), d);\n    float f = acos(L / a) / 2.;\n    d = min(2.0 * abs(sin((fi - f) / 2.0)) * L, d);\n    d = min(2.0 * abs(sin((fi + f) / 2.0)) * L, d);\n    return d;\n}\n\nfloat scale5(float x, float y)\n{\n    float r = (1.-asin(abs((x - 0.5)*2.))*2./PI)*0.6 + 0.4 -y;\n    float f = smoothstep(-0.05, 0.05, r);\n    f *= y*y*0.5;\n    f *= (1. + 6.0*cos((x-0.5)*PI)*cos((y-0.5)*PI));\n    float dl = f*0.01;\n    return dl;   \n}\n\n\nfloat toorow(float x, float y, float step)\n{\n    float x1 = x;\n    float y1 = y*0.5 + 0.5;\n    float x2 = mod(x + step, 1.0);\n    float y2 = y*0.5;\n    float dl1 = scale5(x1, y1);\n    float dl2 = scale5(x2, y2);\n    return max(dl1, dl2);\n}\n\nfloat sdConePine(vec3 p, float a)\n{\n    float l = length(p.xy);\n    float h = -p.z + a/2.;\n    float d = sdCosNp(vec2(h, l), a);\n    \n    float n = 10.;\n    float m = 8.;\n    float step = 0.5;\n    float y = 1.0 - h/a;\n    float x = mod(atan(p.y, p.x), TAU)/TAU;\n    float row = floor(y*n);\n    y = y*n - row;\n    float shift = mod(step*row, 1.0);\n    x = mod(x - shift/m, 1.0);\n    x = fract(x*m);\n    //float dl = displ(x, y);\n    float dl = toorow(x, y, step);\n    d*=0.3;\n    d -= dl;\n    return d;\n}\n\n\nfloat map( in vec3 pos )\n{\n    \n    return sdConePine(pos, 2.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map(pos + k.xyy*h ) + \n                      k.yyx*map(pos + k.yyx*h ) + \n                      k.yxy*map(pos + k.yxy*h ) + \n                      k.xxx*map(pos + k.xxx*h ) );\n}\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n\nHIT giper3D(vec3 ro, vec3 rd)\n{\n    float t  = 0.;\n    for (int i = 0; i < nn; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        if (h < eps || t >= dist_infin)\n            break;\n        t += h;  \n    }    \n\n    if (t >= dist_infin)\n        return hit_inf;\n      \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n    return HIT(t, nor, pos);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvec3 calccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.3, 1.0);\n    return col;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(0.0, 1.0, 2.5)); //light\n    vec3 light2 = normalize(vec3(0.0, -1.0, -2.5)); //light\n    float t = iTime;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n        t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 2.0); // camera\n    ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    \n    \n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    mat3 rota  = rotateX(-PI/2.0)*rotateZ(t)*rotateX(-t);\n    mat3 rota_1  = rotateX(t)*rotateZ(-t)*rotateX(PI/2.0);\n    \n    vec3 tot = vec3(0.0);\n    \n    \n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n        vec3 col = vec3(1.); // background  \n        \n        HIT giper = giper3D(rota*ro, rota*rd);\n        if (giper.dist < dist)\n        {\n            vec3 nor = rota_1*giper.nor;\n            col = vec3(184./255., 216./255., 135./255.);\n            col = calccolor(col, col, -rd, light, light2, nor);\n            col = pow( col, vec3(0.7));\n        }\n\t    tot += col;\n    }\n    //antiblick\n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}