{"ver":"0.1","info":{"id":"cdsXDn","date":"1668719412","viewed":176,"name":"Hyperbolic Point Journey Cosine","username":"PhDFractal","description":"The journey of a hyperbolic component in the Elephant Cosine Absolute vs. Julia Set. The seed shifts down, backtracks 2½ iterations, up, retracks 2½ iteratons, and down in a rectangle. The hyperbolic point is at initial and final seed.","likes":13,"published":1,"flags":16,"usePreview":0,"tags":["fractal","juliaset","cosine","morph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Splitting\n//\n// Analyzing the Trajectory of a Hyperbolic Component 2½ Iterations in the Valley\n//\n// Created by PhdFractal, 8/18/2022\n//\n// EDIT (11/19/22 at 2:07 pm): A better version with Absolute vs. Julia Set (cosine).\n// Makes nontriviality of component looping much clearer at the expense of resolution.\n// Absolute Julia Set uses approximant cos(z)≈1-z²/2 to preserve precision.\n//\n// Press 'p' to show all stopping points. There are 2²×5=20 points of the component.\n// The point journey without highlights may be hard to see, as the image of the\n// component shrinks when around smaller sub-components of the large minijulia.\n//\n// Since the horizontal slide is 2½ Iterations, there will be 2² sets of paths of the\n// hyperbolic component, one corresponding to each large minijulia sub-component. Each\n// path is 5 points long, the path of the seed. In general if we backtrack p+½ iterations\n// then there will be 2ᵖ cycles. For 1≤i≤2ᵖ each path will end q inverse iterations from\n// the -q level sub-component, where q is the largest power of 2 which divides i. Such a\n// component may appear outside the spiral pinch if we backtrack ≥P/2+½ iterations where\n// P was the original period, but always close to the minijulia.\n//\n// This happens within the vicinity of every parabolic point, e.g. the minijulia set\n// with revolving seed by a minibrot may split the next minijulia set if the varying seed\n// is ≥1 parabolic iteration away with respect to the next minibrot, in a parabolic valley.\n// \n// This shows hyperbolic components don't uniquely correspond to minibrots, and vice-versa.\n//\n// The cosine elephant valley was used since the tiny Julia filaments are largest possible.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by PhdFractal: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal (@Fractal MathPro)\".\n\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }    //for switching modes\nfloat abs2(vec2 z){ return sqrt(z.x*z.x+z.y*z.y); }                                  //absolute (complex)\nvec2 times(vec2 z1,vec2 z2){ return vec2(z1.x*z2.x-z1.y*z2.y,z1.x*z2.y+z1.y*z2.x); } //times\nvec2 cosine(vec2 z){ return vec2(cos(z.x)*cosh(z.y),-sin(z.x)*sinh(z.y)); }          //complex cosine\nvec4 rainbow(int i,float density){                                                   //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    int r=int(float(i)*density+5.)%100;\n    if(r<16){ float R=float(r)/16.; return R*red+(1.-R)*black; }\n    else if(r>=16 && r<31){ float R=float(r-16)/15.; return R*yellow+(1.-R)*red; }\n    else if(r>=31 && r<45){ float R=float(r-31)/14.; return R*green+(1.-R)*yellow; }\n    else if(r>=45 && r<62){ float R=float(r-45)/17.; return R*cyan+(1.-R)*green; }\n    else if(r>=62 && r<78){ float R=float(r-62)/16.; return R*blue+(1.-R)*cyan; }\n    else{ float R=float(r-78)/22.; return R*black+(1.-R)*blue; }\n}\nvec2 c=vec2(0.,0.);              //Seed initialized to (0,0).\nvec2 z=vec2(0.,0.);              //Values initialized to 0.\nfloat pi=3.14159265359;          //π\nvec4 wh=vec4(1.,1.,1.,1.);       //white\nfloat op=0.; float fix=1.;       //opacity and fix\nfloat ao=0.; float a1=0.1;       //dummy floats\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    bool showPoints=keypress(80);//Press key 'p' for points\n    vec4 color=vec4(0.,0.,0.,1.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n    float mod10=(iTime-10.*floor(iTime/10.)); float mod40=(iTime-40.*floor(iTime/40.));\n    float amp10=cos(pi/2.*mod10); float amp40=cos(pi/2.*mod40);\n\n    vec2 seed0=vec2(-2.9652315,0.); vec2 seed1=vec2(-2.9652315,-0.00042); vec2 seed2=vec2(-2.9641665,-0.00053);\n    vec2 seed3=vec2(-2.9641665,0.00053); vec2 seed4=vec2(-2.9652315,0.00042);\n\n    if(mod10>=0.&&mod10<2.){ c=(1.+amp10)/2.*seed0+(1.-amp10)/2.*seed1; }\n    else if(mod10>=2.&&mod10<4.){ c=(1.+amp10)/2.*seed2+(1.-amp10)/2.*seed1; }\n    else if(mod10>=4.&&mod10<6.){ c=(1.+amp10)/2.*seed2+(1.-amp10)/2.*seed3; }\n    else if(mod10>=6.&&mod10<8.){ c=(1.+amp10)/2.*seed4+(1.-amp10)/2.*seed3; }\n    else{ c=(1.+amp10)/2.*seed4+(1.-amp10)/2.*seed0; }\n    \n    vec2 cdiff=c-seed0; vec2 ca=vec2(-0.25,0.); vec2 cj=vec2(0.25,0.);\n    \n    if(pix.x<=0.){\n    vec2 pixa=pix-ca; vec2 z0=vec2(0.,0.); pixa=0.05*times(pixa,pixa);\n    for(int i=0; i<500; i++){\n        z=times(cosine(z0),pixa+c); //MUST use cos(z)≈1-z²/2 to preserve precision\n        if(dot(z,z)>7e3){ color=rainbow(i,3.); break; }\n        else{ z0=z; } }\n    }\n    else{ vec2 z0=2.5*(pix-cj);\n    for(int i=0; i<500; i++){\n        z=times(cosine(z0),c);\n        if(dot(z,z)>7e3){ color=rainbow(i,3.); break; }\n        else{ z0=z; } }\n    }\n\n    if(!showPoints){\n    if(abs2(0.05*times(pix-ca,pix-ca)+cdiff)<=0.0001) { op=fix*0.7; } //Absolute path case\n    else if(abs2(pix-cj)<=0.05&&(mod40<1.||mod40>=39.)) { op=fix*amp40; }                         //Initial\n    else if(abs2(pix-cj-0.5*vec2( 0.274,0.397))<=0.0025&&mod40>=9.&&mod40<11.) { op=-fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2( 0.000,0.386))<=0.0075&&mod40>=19.&&mod40<21.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.274,0.398))<=0.0025&&mod40>=29.&&mod40<31.) { op=-fix*amp40; } \n    else if(abs2(pix-cj-0.5*vec2( 0.135,0.096))<=0.0125&&mod40>=1.&&mod40<3.) { op=-fix*amp40; }  //Phase 1\n    else if(abs2(pix-cj-0.5*vec2( 0.271,0.405))<=0.0025&&mod40>=11.&&mod40<13.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.030,0.400))<=0.005&&mod40>=21.&&mod40<23.) { op=-fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.282,0.390))<=0.0025&&mod40>=31.&&mod40<33.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2( 0.252,0.206))<=0.010&&mod40>=3.&&mod40<5.) { op=fix*amp40; }    //Phase 2\n    else if(abs2(pix-cj-0.5*vec2( 0.240,0.430))<=0.004&&mod40>=13.&&mod40<15.) { op=-fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.115,0.432))<=0.0075&&mod40>=23.&&mod40<25.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.298,0.354))<=0.004&&mod40>=33.&&mod40<35.) { op=-fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2( 0.298,0.354))<=0.004&&mod40>=5.&&mod40<7.) { op=-fix*amp40; }   //Phase 3\n    else if(abs2(pix-cj-0.5*vec2( 0.115,0.432))<=0.0075&&mod40>=15.&&mod40<17.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.240,0.430))<=0.004&&mod40>=25.&&mod40<27.) { op=-fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.252,0.206))<=0.010&&mod40>=35.&&mod40<37.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2( 0.282,0.390))<=0.0025&&mod40>=7.&&mod40<9.) { op=fix*amp40; }   //Phase 4\n    else if(abs2(pix-cj-0.5*vec2( 0.030,0.400))<=0.005&&mod40>=17.&&mod40<19.) { op=-fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.271,0.405))<=0.0025&&mod40>=27.&&mod40<29.) { op=fix*amp40; }\n    else if(abs2(pix-cj-0.5*vec2(-0.135,0.096))<=0.0125&&mod40>=37.&&mod40<39.) { op=-fix*amp40; }\n\n    else if(abs2(pix-cj+0.5*vec2( 0.274,0.397))<=0.0025&&mod40>=9.&&mod40<11.) { op=-fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2( 0.000,0.386))<=0.0075&&mod40>=19.&&mod40<21.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.274,0.398))<=0.0025&&mod40>=29.&&mod40<31.) { op=-fix*amp40; } \n    else if(abs2(pix-cj+0.5*vec2( 0.135,0.096))<=0.0125&&mod40>=1.&&mod40<3.) { op=-fix*amp40; }  //Phase 1\n    else if(abs2(pix-cj+0.5*vec2( 0.271,0.405))<=0.0025&&mod40>=11.&&mod40<13.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.030,0.400))<=0.005&&mod40>=21.&&mod40<23.) { op=-fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.282,0.390))<=0.0025&&mod40>=31.&&mod40<33.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2( 0.252,0.206))<=0.010&&mod40>=3.&&mod40<5.) { op=fix*amp40; }    //Phase 2\n    else if(abs2(pix-cj+0.5*vec2( 0.240,0.430))<=0.004&&mod40>=13.&&mod40<15.) { op=-fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.115,0.432))<=0.0075&&mod40>=23.&&mod40<25.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.298,0.354))<=0.004&&mod40>=33.&&mod40<35.) { op=-fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2( 0.298,0.354))<=0.004&&mod40>=5.&&mod40<7.) { op=-fix*amp40; }   //Phase 3\n    else if(abs2(pix-cj+0.5*vec2( 0.115,0.432))<=0.0075&&mod40>=15.&&mod40<17.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.240,0.430))<=0.004&&mod40>=25.&&mod40<27.) { op=-fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.252,0.206))<=0.010&&mod40>=35.&&mod40<37.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2( 0.282,0.390))<=0.0025&&mod40>=7.&&mod40<9.) { op=fix*amp40; }   //Phase 4\n    else if(abs2(pix-cj+0.5*vec2( 0.030,0.400))<=0.005&&mod40>=17.&&mod40<19.) { op=-fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.271,0.405))<=0.0025&&mod40>=27.&&mod40<29.) { op=fix*amp40; }\n    else if(abs2(pix-cj+0.5*vec2(-0.135,0.096))<=0.0125&&mod40>=37.&&mod40<39.) { op=-fix*amp40; }\n    }\n    else{ fix=1.;\n    if(abs2(0.05*times(pix-ca,pix-ca)+cdiff)<=0.0001) { op=fix; }     //Absolute path case\n    else if(abs2(pix-cj)<=0.05) { op=fix; }                           //Initial\n    else if(abs2(pix-cj-0.5*vec2( 0.274,0.397))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2( 0.000,0.386))<=0.0075) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.274,0.398))<=0.0025) { op=fix; } \n    else if(abs2(pix-cj-0.5*vec2( 0.135,0.096))<=0.0125) { op=fix; }  //Phase 1\n    else if(abs2(pix-cj-0.5*vec2( 0.271,0.405))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.030,0.400))<=0.005) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.282,0.390))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2( 0.252,0.206))<=0.010) { op=fix; }   //Phase 2\n    else if(abs2(pix-cj-0.5*vec2( 0.240,0.430))<=0.004) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.115,0.432))<=0.0075) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.298,0.354))<=0.004) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2( 0.298,0.354))<=0.004) { op=fix; }   //Phase 3\n    else if(abs2(pix-cj-0.5*vec2( 0.115,0.432))<=0.0075) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.240,0.430))<=0.004) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.252,0.206))<=0.010) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2( 0.282,0.390))<=0.0025) { op=fix; }  //Phase 4\n    else if(abs2(pix-cj-0.5*vec2( 0.030,0.400))<=0.005) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.271,0.405))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj-0.5*vec2(-0.135,0.096))<=0.0125) { op=fix; }\n\n    else if(abs2(pix-cj+0.5*vec2( 0.274,0.397))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2( 0.000,0.386))<=0.0075) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.274,0.398))<=0.0025) { op=fix; } \n    else if(abs2(pix-cj+0.5*vec2( 0.135,0.096))<=0.0125) { op=fix; }  //Phase 1\n    else if(abs2(pix-cj+0.5*vec2( 0.271,0.405))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.030,0.400))<=0.005) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.282,0.390))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2( 0.252,0.206))<=0.010) { op=fix; }  //Phase 2\n    else if(abs2(pix-cj+0.5*vec2( 0.240,0.430))<=0.004) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.115,0.432))<=0.0075) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.298,0.354))<=0.004) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2( 0.298,0.354))<=0.004) { op=fix; }  //Phase 3\n    else if(abs2(pix-cj+0.5*vec2( 0.115,0.432))<=0.0075) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.240,0.430))<=0.004) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.252,0.206))<=0.010) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2( 0.282,0.390))<=0.0025) { op=fix; }  //Phase 4\n    else if(abs2(pix-cj+0.5*vec2( 0.030,0.400))<=0.005) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.271,0.405))<=0.0025) { op=fix; }\n    else if(abs2(pix-cj+0.5*vec2(-0.135,0.096))<=0.0125) { op=fix; }\n    }\n\n    fragColor=(1.-op)*color+op*wh;\n}","name":"Image","description":"","type":"image"}]}