{"ver":"0.1","info":{"id":"cdGSzV","date":"1681298085","viewed":53,"name":"Moteur de rendu de lancer de ray","username":"xiongjian","description":"Shaders de lancer de rayons","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Constantes et structures\n\n/*\ncameraPos : position de la caméra.\ncameraTarget : la position de la cible d'observation de la caméra.\ncameraFovY : L'angle de vue de la caméra.\nspherePos : La position de la sphère, devant la position cible de la caméra.\nsphereRadius : Le rayon de la sphère.\nsphereCol : la couleur de la sphère.\nsphereMat : la propriété matérielle de la sphère.\nsphereId : ID de la sphère, utilisé pour identifier différents objets dans le lancer de rayons.\nambianteCol : couleur de la lumière ambiante.\nlightCol : La couleur de la source lumineuse.\nlightPos : La position de la source de lumière.\nskyCol : couleur du ciel.\nskyId : ID du ciel.\nplanePos : la position de l'avion.\nplaneNormal : le vecteur normal du plan.\nplaneCol1 : La première couleur du plan.\nplaneCol2 : la deuxième couleur du plan.\nplaneMat : la propriété matérielle du plan.\nplaneId : ID de l'avion.\n*/\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\nconst vec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; \nconst vec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\nconst vec3 ambiantCol = vec3(0,0,1);\nconst vec3 lightCol = vec3(1,1,1);\nconst vec3 lightPos = vec3(8,10,-12);\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\n//transformer le système de coordonnées\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\n/*\nLorsqu'un rayon coupe une sphère,\nle point d'intersection du rayon et de la sphère et le vecteur normal au point d'intersection sont calculés, \net la distance entre le point d'intersection du rayon et de la sphère et le point de départ du rayon est renvoyée\n*/\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n/*intersection de la lumière et du plan*/\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\n/*La position et la direction du rayon émis depuis la position de la caméra aux coordonnées pixel pixCoord*/\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n//Ce code implémente le modèle d'éclairage Phong\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V)\n{\n    vec3 A = sphereMat.Ka * ambiantCol;\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n/*Calcule l'intersection la plus proche d'un rayon \nà partir de la position de la caméra avec tous les objets (sphères et plans) de la scène \net renvoie la distance de l'intersection la plus proche à la caméra\n*/\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if(distSphere > 0.0 && distPlane > 0.0)\n    {\n        float distMin = min(distSphere,distPlane);\n        objectId = (distSphere == distMin) ? sphereId : planeId; \n        intersecI = (distSphere == distMin) ? intersecS : intersecP; ;\n        normalI = (distSphere == distMin) ? normalS : normalP; ;\n        return distMin;\n    }\n    else\n    {\n        if(distSphere > 0.0)\n        {\n            objectId = sphereId;\n            intersecI = intersecS;\n            normalI = normalS;\n            return distSphere;\n        }\n        else if (distPlane > 0.0)\n        {\n            objectId = planeId;\n            intersecI = intersecP;\n            normalI = normalP;\n            return distPlane;\n        }\n        else\n        {\n           \tobjectId = skyId;\n            return -1.0;\n        }\n    }\n}\n//définit la couleur de chaque boule\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n//Obtenez la couleur du point spécifié sur le plan et jugez de la couleur du point en fonction du fait que la ligne et la colonne où se trouve le point sont des nombres pairs.\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        \tbreak;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        \tbreak;\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        \tbreak;\n    }\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n/*\nUn simple shader de lancer de rayons implémenté à l'aide du modèle d'éclairage Phong. \nCe shader utilise la fonction computeCameraRayFromPixel pour calculer le rayon de la position de la caméra à la position du pixel, \net la fonction computeNearestIntersection pour trouver l'intersection du rayon avec l'objet le plus proche dans la scène. \nEnsuite, selon le matériau de l'objet à l'intersection, utilisez la fonction getObjectColorAtPoint pour obtenir la couleur de l'objet, \net utilisez la fonction computePhongShading pour calculer l'intensité lumineuse de Phong à ce point, y compris la lumière ambiante, \nla lumière diffuse et la lumière spéculaire. , et utilisez la fonction getShadowFactorAtPoint pour calculer le facteur d'ombre .\nEnfin, l'intensité lumineuse calculée est stockée dans un tampon de couleur pour le rendu de l'image.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragCoord = transform_to_apply(fragCoord.xy);\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    int objId;\n    vec3 intersec, normal;\n   \tfloat dist = computeNearestIntersection(rayPos, rayDir, objId, intersec, normal);\n    Material objMat;\n    vec3 col = getObjectColorAtPoint(objId, intersec, objMat);\n    \n    if(dist > 0.0)\n    {        \n    \t\n    \tvec3 L = normalize(lightPos - intersec);\n        \n    \t\n    \tvec3 R = normalize(2.0*dot(normal,L)*normal - L);\n        \n    \t\n    \t\n    \tvec3 V = -rayDir;\n        \n        float Ldist = distance(intersec,lightPos);\n        \n        float shadowFactor = getShadowFactorAtPoint(intersec, normal, objMat, L, Ldist);\n        \n    \t\n    \tfragColor = vec4(computePhongShading(col, objMat, shadowFactor, normal, L, R, V), 1);\n    }\n    \n    else \n        fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}