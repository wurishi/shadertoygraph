{"ver":"0.1","info":{"id":"llSGWR","date":"1427991599","viewed":163,"name":"superblob","username":"such","description":"superblob","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define RM_MAX_ITER 30\n#define DISTANCE 8\n#define NBLOBf 3.\n\nconst float eps = 0.01;\n\nvec3 rand3(float co){\n    return fract(sin(co*vec3(12.9898,78.233,43.2311)) * 43758.5453);\n}\n\nfloat multisphere(in vec3 p)\n{\n    float x = cos(iTime);\n    \n    const float N = 2.;\n    float l = 0.;\n    vec3 f = rand3(1.);\n    for (float i=1.; i<=NBLOBf; ++i)\n    {\n        vec3 q = sin(f*i*iTime);\n        q = (q - 0.5)*0.75;\n        l += 1./distance(p,q);\n    }\n    float r = 0.3;\n    return 1./l - r;\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(in vec3 p)\n{\n//    float s1 = sphere(p,0.3);\n//    float s2 = sphere(p+vec3(sin(iTime)*1.0,0.,0.),0.5);\n    // return sqrt(s1*s1 + s2*s2);\n//    return min(s1,s2);\n    //return (s1+s2)*0.5;\n    float s3 = multisphere(p);\n//    return min(s1,s3);\n    return s3;\n}\n\n// gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz) - scene(p - ep.xyz);\n    normal.y = scene(p + ep.yxz) - scene(p - ep.yxz);\n    normal.z = scene(p + ep.yzx) - scene(p - ep.yzx);\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    float a = 0.4*iTime;\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    float dist;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        dist = scene(p);\n\t\tt += dist;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    //vec3 normal = vec3(0,0,1);\n    vec3 light1 = vec3(sin(iTime),cos(iTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    //            finalColor = normal;\n    //            finalColor = vec3(1,0,1) *\n    //                dot(vec3(1.,sin(iTime ),cos(iTime )),normal);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n   /*         if (dist>1.*eps)\n{\ndiffuse1 *= 0.1;\ndiffuse2 *= 0.1;\n}*/\n\n    //float specular = 0.;\n    float ambient = 0.2;\n    finalColor = vec3(1,0,1) *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-dist) + length(finalColor)));\n    \n    fragColor = mix(vec4(pow(texture (iChannel0,fragCoord/iResolution.xy).r,21.)), fragColor, fragColor.a);\n}","name":"","description":"","type":"image"}]}