{"ver":"0.1","info":{"id":"mljyzt","date":"1692194447","viewed":25,"name":"Potts model","username":"chaddon","description":"Monte Carlo Potts model","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// number of orientations\nint q = 10;\n\nfloat pi = 3.14159;\n\nvec3 rgb(float h, float s, float v) {\n    float c = v * s;\n    h = mod(h, 2.0 * pi);\n    float h_p = h / (pi / 3.0);\n    float x = c * (1.0 - abs(mod(h_p, 2.0) - 1.0));\n    \n    vec3 rgb;\n    if(h_p < 1.0) {\n        return vec3(c, x, 0.0);\n    } else if(h_p < 2.0) {\n        return vec3(x, c, 0.0);\n    } else if(h_p < 3.0) {\n        return vec3(0.0, c, x);\n    } else if(h_p < 4.0) {\n        return vec3(0.0, x, c);\n    } else if(h_p < 5.0) {\n        return vec3(x, 0.0, c);\n    } else {\n        return vec3(c, 0.0, x);\n    }\n    \n    float m = v - c;\n    return rgb + vec3(m);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float s = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    fragColor = vec4(rgb(s / float(q) * 2.0 * pi, 1.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// temperature\nfloat t = 0.2;\n\n// number of orientations\nint q = 10;\n\n// right xorshift\nuint xorshr(uint b, uint x) {\n    return x ^ (x >> b);\n}\n\n// take the b highest bits of x\nuint hi(uint b, uint x) {\n    return x >> (32u - b);\n}\n\n// take the b lowest bits of x\nuint lo(uint b, uint x) {\n    return (x << (32u - b)) >> (32u - b);\n}\n\n// controlled right xorshift\n// xorshift by a value depending on the b highest bits of x\nuint cxorshr(uint b, uint x) {\n    uint c = hi(b, x) + 1u;\n    uint r = lo(32u - b, x);\n    return c | xorshr(c, r);\n}\n\nuint hash(uint x) {\n    // single lcg step\n    x = x * 0x5897f487u + 0x55e2f1d0u;\n    \n    // output function\n    x = cxorshr(2u, x);\n    x *= 0x5897f487u;\n    x = xorshr(16u, x);\n    return x;\n}\n\nfloat s(ivec2 x) {\n    return texelFetch(iChannel0, x % ivec2(iChannelResolution[0].xy), 0).x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 x = ivec2(floor(fragCoord));\n    \n    float r = float(hash(\n        uint(x.x) + \n        uint(x.y) * uint(iChannelResolution[0].x) + \n        uint(iFrame) * uint(iChannelResolution[0].x) * uint(iChannelResolution[0].y)\n    )) / float(0xffffffffu);\n        \n    if(iFrame == 0) {\n        fragColor = vec4(round(r * float(q)), 0.0, 0.0, 0.0); // why does floor introduce bias?\n    } else if((x.x + x.y + iFrame) % 2 == 0) {\n        float s_start = s(x);\n        float s_other = round(r * float(q)); // why does floor introduce bias?\n        \n        float e_start =\n            (s_start == s(x + ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_start == s(x - ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_start == s(x + ivec2(0, 1)) ? -1.0 : 0.0) +\n            (s_start == s(x - ivec2(0, 1)) ? -1.0 : 0.0);\n            \n        float e_other =\n            (s_other == s(x + ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_other == s(x - ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_other == s(x + ivec2(0, 1)) ? -1.0 : 0.0) +\n            (s_other == s(x - ivec2(0, 1)) ? -1.0 : 0.0);\n            \n        if(e_other < e_start) {\n            fragColor = vec4(s_other, 0.0, 0.0, 0.0);\n        } else {\n            if(r < exp(-(e_other - e_start) / t)) {\n                fragColor = vec4(s_other, 0.0, 0.0, 0.0);\n            } else {\n                fragColor = vec4(s_start, 0.0, 0.0, 0.0);\n            }\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, x, 0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}