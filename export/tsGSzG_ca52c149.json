{"ver":"0.1","info":{"id":"tsGSzG","date":"1574262551","viewed":106,"name":"Voronoi Planets","username":"denosya","description":"planets","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float zNear = 1.0;\nconst float zFar  = 400.0;\nconst float NB_COLORS = 10.0;\nconst float CELL_SCALE = 0.085;\nconst int   NB_LAND_POINTS = 20;\n\n#define COL(r,g,b) vec4(r/255.,g/255.,b/255.,1.0)\n\n//IQ\nvec2 rand22(vec2 p) {\n\tconst vec3 HASHSCALE3 = vec3(.1031, .1030, .0973);    \n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//IQ\nvec2 rand12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 voronoi(vec2 uv, float scale, out vec2 cellCenter) {\n    \n    vec2 ij = floor(uv / scale);\n    \n    float minDist = 2.0;\n    vec2  closestCell;\n    \n    for(float x=-1.0;x<=1.0;x+=1.0) {\n        for(float y=-1.0;y<=1.0;y+=1.0) {\n            vec2 cell = ij+vec2(x, y);\n            vec2 rand = rand22(cell); //[0.-1.]\n        \tfloat d = length(uv - (cell+rand)*scale);\n            \n            if(d<minDist) {\n            \tminDist = d;\n            \tclosestCell = cell;\n                cellCenter = (cell+rand)*scale;\n            }\n        }\n\t}\n\n    return closestCell;\n}\n\nfloat blockDist(vec2 target, vec2 p) {\n    \n    float LIMIT = 6.28;\n    \n    if(target.x<0.) target.x += LIMIT;\n    if(p.x<0.) p.x += LIMIT;\n    \n    float dx=abs(target.x-p.x);\n    float dy=abs(target.y-p.y);    \n    \n    if(dx>LIMIT/2.0) {\n        dx -= LIMIT;\n    }\n    \n\treturn length(vec2(dx,dy));\n}\n\nconst float LAND_CORE_TH = 0.10;\nconst float END_OF_LAND_TH = 0.4;\nconst float END_OF_SAND_TH = 0.45;\nconst float END_OF_LIGHT_SEA_TH = 0.55;\nconst float START_OF_DEEP_SEA_TH = 0.65;\n\nconst vec4 COLOR_LAND1 = COL(56.,79.,56.);\nconst vec4 COLOR_LAND2 = COL(13.,164.,13.);\nconst vec4 COLOR_SAND  = COL(195.,177.,129.);\nconst vec4 COLOR_SEA1  = COL(0.,0.,218.);\nconst vec4 COLOR_SEA2  = COL(0.,0.,127.);\n\n\nvec2 getRandomLandPoint(int i) {\n    const float H_AMP = 6.28;\n    const float V_AMP = 2.;\n    \n    return (rand12(float(i)) + vec2(0.0, -V_AMP/4.0))*vec2(H_AMP, V_AMP);\n}\n\n\nvec4 getPlanetColor(vec2 cell, out bool water) {\n    \n    float minDist = 99.0;\n    \n    for(int i=0; i<NB_LAND_POINTS; i++){\n        minDist = min(minDist, blockDist(cell*CELL_SCALE, getRandomLandPoint(i)));\n    }\n    \n    float dist = minDist;\n \n    if(dist<LAND_CORE_TH) return COLOR_LAND1;\n    if(dist<END_OF_LAND_TH) return mix(COLOR_LAND1, COLOR_LAND2, (dist-LAND_CORE_TH) / (END_OF_LAND_TH-LAND_CORE_TH));\n    if(dist<END_OF_SAND_TH) return COLOR_SAND;\n    \n    water = true;\n    \n    if(dist<END_OF_LIGHT_SEA_TH) return COLOR_SEA1;    \n    \n    float seaRatio = min((dist-END_OF_LIGHT_SEA_TH)/(START_OF_DEEP_SEA_TH-END_OF_LIGHT_SEA_TH), 1.0);\n    \n    return mix(COLOR_SEA1, COLOR_SEA2, seaRatio);\n}\n\n\nvec4 getPlanetTexture(vec2 uv, out vec2 cellCenter, out bool water) {\n    \n    if(uv.x<0.) return vec4(1,0,0,1);\n    \n \tvec2 cell = voronoi(uv, CELL_SCALE, cellCenter);\n    return getPlanetColor(cell, water);    \n}\n\n\nfloat bounceAnim(float amplitude, float amorti, float shift) {\n\n    float sequenceTime = mod(iTime*4.0 + shift, 15.0) / 15.0;\n    \n    float a = 3.1415 *(amorti*sequenceTime-1.0);\n    return sin(a)/a * amplitude;\n}\n\n\nfloat ovoid(in vec3 m) {\n    \n    vec3 center = vec3(0,0,20);\n    float radius = 0.85;\n    vec3 scale = vec3(5.,5.0,5.0);\n    \n\tvec3 dist = (m-center) / scale;    \n    \n    return length(dist) - radius;\n}\n\n\n#define SUB(a,b) max(a,-b)\n#define ADD(a,b) min(a,b)\n#define INTER(a,b) max(a,b)\n\n    \nfloat map(in vec3 m) {\n\n    return ovoid(m);\n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<500; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n//IQ\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvec3 test;\n\nvec4 render(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n\n    vec2 uv;\n    \n    float rotation = iTime*0.125;\n    float alpha = mod(atan(normal.z, normal.x) + 6.28 + rotation, 6.28);\n    \n    uv.x = alpha;\n    uv.y = -acos(normal.y) + 1.57;    \n    \n    vec2 cellCenter;\n    bool isWater;\n    vec4 pixel = getPlanetTexture(uv, cellCenter, isWater);\n    \n    vec3 cellNormal;\n    \n    cellNormal.y = cellCenter.y;\n    cellNormal.x = cos(cellCenter.x-rotation);\n    cellNormal.z = sin(cellCenter.x-rotation);\n\n    float xzExpectedLen = sqrt(1.-cellCenter.y*cellCenter.y);\n    \n    float localNormalization = length(cellNormal.xz);\n    cellNormal.xz /= localNormalization / xzExpectedLen;\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = max(0.0, dot(cellNormal, -lightRay));\n    float ambiant = 0.5;       \n    vec3 reflectedLight  = reflect(lightRay, cellNormal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 2.0) * 0.25;\n    \n    vec4 envmap = texture(iChannel0, reflect(ray, normal)); \n    \n    \n    //vec3 refraction = refract(ray, normal, 1.0/1.33);\n    //vec4 refr = texture(iChannel1, refraction); \n    diffuse=pow(diffuse, 0.5);\n     \n    float envmapmix = isWater ? 0.:0.;\n    \n    return mix(pixel*(diffuse+ambiant) + hilight, envmap, envmapmix);\n    \n    //return vec4(mix(refr.rgb, envmap.rgb, 0.15), 1.0) * (diffuse+ambiant) + hilight;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t= iResolution.x/iResolution.y;\n    vec3 \tuv \t\t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), 0.);\n    \n    vec3\teye\t\t= vec3(0.0, 0.0, -2.15);\n    vec3\tray\t\t= normalize(uv-eye);\n    vec3\tlight\t= vec3(21., 0.0, 8.0);\n    \n    vec3\tm;\n    vec4 \tpixel;\n    \n    if(rayMarching(eye, ray, m)) {\n        vec3 normal = computeNormal(m);\n        pixel = render(ray, m, normal, light, eye);\n        //pixel = vec4(test,1);\n    }\n    else {\n     \tpixel = COL(89.,127.,109.);\n    }\n\n    float d = abs(length(uv.xy) - 0.425);\n    float alias = clamp((d - 0.005) / 0.0025, 0.0, 1.0);\n    \n    fragColor = mix(vec4(1), pixel, alias);\n}\n    \n    \n","name":"Image","description":"","type":"image"}]}