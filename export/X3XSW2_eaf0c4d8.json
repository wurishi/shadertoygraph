{"ver":"0.1","info":{"id":"X3XSW2","date":"1709962820","viewed":48,"name":"shabola","username":"amusement","description":"shabola","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["shabola"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 adjustBrightness(vec3 color, float brightness) {\n    return color + brightness;\n}\n\nvec3 adjustContrast(vec3 color, float contrast) {\n    return (color - 0.5) * contrast + 0.5;\n}\n\nvec3 adjustSaturation(vec3 color, float saturation) {\n    float luma = dot(color, vec3(0.3, 0.6, 0.1));\n    return mix(vec3(luma), color, saturation);\n}\n\nvec3 adjustHue(vec3 color, float hue) {\n    vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle);\n}\n\nfloat smoothSquareLFO(float t, float offset, float mult, float smoothing) {\n    float val = fract((t + offset) * mult);\n    return smoothstep(0.99 - smoothing, 0.88 + smoothing, val);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    float smoothing = 0.1;\n    float brightnessLFO = smoothSquareLFO(iTime, 1.0, 2.0, smoothing) * 0.5 - 0.25;\n    float contrastLFO = smoothSquareLFO(iTime, 1.5, 1.5, smoothing) * 0.5 + 0.75;\n    float saturationLFO = smoothSquareLFO(iTime, 1.7, 1.8, smoothing) * 2.0;\n    float hueLFO = smoothSquareLFO(iTime, 1.3, 1.5, smoothing) * 6.28;\n    \n    color = adjustBrightness(color, brightnessLFO);\n    color = adjustContrast(color, contrastLFO);\n    color = adjustSaturation(color, saturationLFO);\n    color = adjustHue(color, hueLFO);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n// Camera movement parameters\n#define UP 0.0\n#define DOWN 0.0\n#define AHEAD 5.0\n#define BACK 0.0\n#define ROTATE_LEFT 0.0\n#define ROTATE_RIGHT 0.0\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCross(vec3 p, float s) {\n    // Rotate the point on all axes\n    float angleX = iTime * 0.5;\n    float angleY = iTime * 0.3;\n    float angleZ = iTime * 0.7;\n    p = rotateX(angleX) * rotateY(angleY) * rotateZ(angleZ) * p;\n    \n    float da = sdBox(p.xyz, vec3(s, s, s));\n    float db = sdBox(p.yzx, vec3(s, s, s));\n    float dc = sdBox(p.zxy, vec3(s, s, s));\n    return min(da, min(db, dc));\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdCross(p, 1.0);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return vec3(dO, dO, dO);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 cameraPos = vec3(ROTATE_RIGHT - ROTATE_LEFT, UP - DOWN, AHEAD - BACK);\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(rotateX(radians(UP - DOWN)) * rotateY(radians(ROTATE_RIGHT - ROTATE_LEFT)) * vec3(uv, -1.0));\n    \n    vec3 d = rayMarch(ro, rd);\n    \n    vec3 backgroundColor = texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    \n    vec3 color = backgroundColor;\n    if (d.x < MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec2 uv = vec2(atan(p.x, p.z) / (2.0 * 3.14159265) + 0.5, asin(p.y) / 3.14159265 + 0.5);\n        color = texture(iChannel0, uv).rgb;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Earthquake shake effect\n    float shakeMagnitude = 0.05;\n    float shakeFrequency = 20.0;\n    float shakeTime = iTime * shakeFrequency;\n    \n    vec2 shakeOffset = vec2(\n        noise(vec2(shakeTime, uv.y * 0.5)),\n        noise(vec2(shakeTime, uv.x * 0.5 + 100.0))\n    ) * shakeMagnitude;\n    \n    uv += shakeOffset;\n    \n    // Glitch effect\n    float glitchThreshold = 0.9;\n    float glitchIntensity = 0.1;\n    float glitchTime = iTime * 10.0;\n    \n    vec2 glitchOffset = vec2(\n        step(glitchThreshold, random(vec2(glitchTime, uv.y))),\n        step(glitchThreshold, random(vec2(glitchTime, uv.x)))\n    ) * glitchIntensity;\n    \n    uv += glitchOffset;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // Invert the colors\n    color = vec3(1.0) - color;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}