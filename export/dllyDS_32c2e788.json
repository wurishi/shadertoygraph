{"ver":"0.1","info":{"id":"dllyDS","date":"1693217881","viewed":62,"name":"Floortiles 3D Waves + Lighting","username":"Aleksandr73591","description":"Tiled Floor with the Waves and Lighting. Raymarching technique applied in order to calculate 3D scene. All done here in Fragment shader. No textures.\n\nWritten by Aleksandr Pogosov","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waves","floortiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Written by ALEKSANDR POGOSOV\n\nconst float MAXDIST = 400.0;\n\nstruct pointInfo\n{\n    float sd;\n    vec3 col;\n    float depth;\n};\n\n\nmat3 rotation_x (float angle)\n{\n\treturn mat3\n\t(1.,0.,0.,\n\t0.,cos(angle), -sin(angle),\n\t0., sin(angle),cos(angle)\n\n\t);\n\n}\n\nmat3 rotation_y (float angle)\n{\n\treturn mat3\n\t(cos(angle),0.,-sin(angle),\n\t0.,1., 0.,\n\tsin(angle), 0.,cos(angle)\n\n\t);\n\n}\n\n\nvec3 ripples3d(vec3 p)\n{\n\np.y += 5.;\nfloat length = length(p);\n\n\nfloat outerEdgeRing = 0.;\nfloat innerEdgeRing = 50.;\nfloat outerRing = smoothstep(length + outerEdgeRing,\nlength + innerEdgeRing, fract(iTime/5.0) * 200.0);\nfloat innerRing = 1.0 - outerRing;\nfloat finalRing = innerRing * outerRing;\n\n\nvec3 ripples = vec3(\np.x - finalRing * innerEdgeRing,\np.y - finalRing * innerEdgeRing,\np.z - finalRing * innerEdgeRing);\nreturn ripples;\n}\n\n\npointInfo customFloor(vec3 point)\n{\n   \n  float sd = point.y  + .5;\n  vec3 col = vec3(mod(floor(point.x) - floor(point.z), 2.));\n  pointInfo pI;\n  pI.sd = sd;\n  pI.col = col;\n  \n  return pI;\n}\n\n\npointInfo closestObject(pointInfo object_1, pointInfo object_2)\n{\n    if(object_1.sd < object_2.sd) return object_1;\n    else return object_2;\n}\n\npointInfo sdScene(vec3 point)\n{\n    \n  pointInfo sdFloor = customFloor(point);\n    vec3 spherePos = vec3(0.);\n    vec3 spherePoint = point;\n    vec3 sphereCol = vec3(0.3,1.0,0.);\n    \n        \n        return sdFloor;\n}\n\npointInfo rayMarch(vec3 camPos, vec3 rayDir, float startDist,\nfloat maxDist)\n{\n    float depth = startDist;\n    pointInfo pointInfo;\n    for(int i = 0; i < 255; i++)\n    {\n        \n        vec3 currentPosOfRay = camPos + rayDir * depth;\n        currentPosOfRay = ripples3d(currentPosOfRay);\n        currentPosOfRay*= rotation_y(iTime/4.);\n        pointInfo = sdScene(currentPosOfRay);\n        depth += pointInfo.sd;\n        \n        if(depth > maxDist || pointInfo.sd < 0.0001)\n        {\n        break;\n        }\n    }\n    \n    pointInfo.sd = depth;\n    return pointInfo; \n    \n}\n\n\n\nvec3 calcNormals(vec3 p)\n{\n\tfloat epsilon =0.0005;\n    float sd_x_1 = sdScene(vec3(p.x + epsilon, p.y, p.z)).sd;\n    float sd_x_2 = sdScene(vec3(p.x - epsilon, p.y, p.z)).sd;\n    float sd_x_final = sd_x_1 - sd_x_2;\n    \n    float sd_y_1 = sdScene(vec3(p.x, p.y + epsilon, p.z)).sd;\n    float sd_y_2 = sdScene(vec3(p.x, p.y - epsilon, p.z)).sd;\n    float sd_y_final = sd_y_1 - sd_y_2;\n    \n    float sd_z_1 = sdScene(vec3(p.x, p.y, p.z + epsilon)).sd;\n    float sd_z_2 = sdScene(vec3(p.x, p.y, p.z - epsilon)).sd;\n    float sd_z_final = sd_z_1 - sd_z_2;\n\n    return normalize(vec3(sd_x_final, sd_y_final, sd_z_final));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(1.);\n    \n    vec3 camPos = vec3(0.,20., 70.0) ;\n    vec3 rayDir = normalize(vec3(uv, -1.) * rotation_x(iMouse.y/50.) * \n    rotation_y(iMouse.x/50.));\n    \n    pointInfo rayMarchPointInfo = \n    rayMarch(camPos, rayDir, 0.0,MAXDIST);\n    \n    if(rayMarchPointInfo.sd > MAXDIST)\n        col = (vec3(1.0));\n    \n    else \n    {\n        vec3 fragCalcNormal = camPos + rayDir * rayMarchPointInfo.sd;\n        vec3 normals = calcNormals(vec3(0.0,0.0,0.0));\n        \n        vec3 lightPos = vec3(80.,15., 10.);\n        vec3 lightDir =  normalize(lightPos - fragCalcNormal);\n        \n        float dotProduct = dot(normals, lightDir) * 5.;\n        float ambientLight = 0.1;\n        float finalLight = clamp(dotProduct, ambientLight,2.0);\n        \n        col = rayMarchPointInfo.col * finalLight;\n    }\n\n\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}