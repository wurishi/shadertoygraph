{"ver":"0.1","info":{"id":"4XjBzK","date":"1729696625","viewed":189,"name":"spirals^n","username":"pb","description":"mandelbrot version of sunbursted with different weights for the 2 functions and different color frequencies","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","exponentialfunction"],"hasliked":0,"parentid":"lXjfRy","parentname":"sunbursted"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// philip.bertani@gmail.com\n\n//an incredible golfing by FabriceNeyret2, this replaces lines 33-110\nvoid mainImage0( out vec4 O, vec2 u )\n{\n    vec2  R =  iResolution.xy, z,\n          U = ( u+u - R )/ R.y *  vec2( .008, .00723) + vec2(-1.469,-.278);\n    float i = -2.;\n    \n    for ( O *= 0. ; i++ < 1e3 && dot(z,z) < 1e9 ; )\n        z = mix( max(min(exp(z.x),1e9),1e-9) * vec2( cos(z.y), sin(z.y) ), // exp(z)\n                 mat2(z,-z.y,z.x) * z,                           // zÂ²\n                .666 )\n            + U,\n        O[ int(z.x<0.)*2 + int(z.y<0.) ]++;          \n    \n    O = cos( O.xzww * vec4(36,26,65,0) / i  );\n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.b++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n/*\nvec2 zz( in vec2 z ) {\n    //classic z squared iteration here\n    return vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y);\n}\n\nvec2 expz( in vec2 z ) {\n    //exponential function here\n    return vec2( exp(z.x)*cos(z.y), exp(z.x)*sin(z.y) );\n}\nvoid mainImagex( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;    \n        \n    //we want to start in a particular rectangle in complex plane\n    vec2 center = vec2(-1.469,-.278);\n    vec2 width  = vec2( .008, .00723);\n    \n    vec2 final_uv = uv * width + center ; \n    \n    float max_iter=1200., mix_factor=.666, infinity=1e10;\n    vec3  julia_freq = vec3(  36.,\n                              -26,\n                              65. );\n\n    vec4 qq = vec4(0); //counts orbit in 4 quadrants\n    \n    vec2 wgt=vec2(mix_factor, 1.-mix_factor);\n    \n    vec2 iter=vec2(0), new_iter;     \n    \n    float escape_value = 0.;\n    for ( float i=0.; i<max_iter; i++ ) {\n    \n        new_iter = wgt.x * zz(iter) + wgt.y*expz(iter) + final_uv;\n        iter = new_iter;\n        \n        float distance = new_iter.x*new_iter.x + new_iter.y*new_iter.y;\n\n        //keep track if how many times the orbit is in \n        //the various 4 quadrants (for coloring)\n        if (new_iter.x >= 0.0) {\n            if (new_iter.y >= 0.0) {\n                qq[0] ++;\n            }\n            else {\n                qq[1] ++;\n            }\n        }\n        else {\n            if (new_iter.y >= 0.0) {\n                qq[2] ++;\n            }\n            else {\n                qq[3] ++;\n            }\n        }\n        \n        //the usual distance bigger than some large number check\n        //NOT using distance estimator here\n        if ( distance > infinity ) {\n            escape_value = i;\n            break;\n        }\n         \n    }\n    \n    if ( escape_value != 0. ) {\n        vec3 qx = vec3( qq[0]*julia_freq[0], \n                        qq[2]*julia_freq[1],\n                        qq[3]*julia_freq[2]\n                       );\n        \n        fragColor = vec4( cos( qx / escape_value ), 1. ); \n    }\n    else {\n        fragColor = vec4( vec3(0.), 1. );\n    }\n    \n\n}\n*/","name":"Image","description":"","type":"image"}]}