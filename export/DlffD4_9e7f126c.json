{"ver":"0.1","info":{"id":"DlffD4","date":"1692906208","viewed":160,"name":"mysterious rotation","username":"Elsio","description":"Os fios brancos giram em torno dos fios azuis. Os azuis giram em torno dos vermelhos. Os vermelhos giram em torno do caminho (Path). Seria esse um tipo de fractal? ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"cs2BWK","parentname":"raymarch minimal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*    relateds\n        https://www.shadertoy.com/view/ctSfRV\n        https://www.shadertoy.com/view/ml2fRV \n        https://www.shadertoy.com/view/mlBBzK\n        https://www.shadertoy.com/view/dtSfRc\n        https://www.shadertoy.com/view/DlffD4 *\n        https://www.shadertoy.com/view/DlXfzj\n    \n*/ \n\n#define res iResolution.xy\n#define rot(a) mat2 (cos(a), sin(a), -sin(a), cos(a))\n#define T iTime * 1.5\n\nvec3 cor;\nvec2 path(float z) {\n    return 2.3 * vec2(\n        sin(z * .4), \n        cos(z * .3) \n    );\n}\n\n/* Found this world warping technique\n   somewhere but forgot which shader :(\n                           -- mrange\n*/\n\nfloat cableNest(vec3 p, float d){\n    // colors\n    vec3[] cr = vec3[](\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(1, 1, 1),\n        vec3(0, 0, 1)\n    );\n    \n    cor = cr[3];\n    float ss = 1.5, s = .8;\n    mat2 rotate = ss * rot(p.z);\n    \n    for (float i = 0.; i < 3.; i++){\n\n        p.xy = abs(p.xy * rotate) - 3.5 * s;\n\n        s /= ss;\n\n        float dd = (length(p.xy) - .04 * (3.-i * .2)) * s;\n        if (dd < d){\n            d = dd;\n            cor = cr[int(i)];\n        }\n    }\n    return d;\n}\n\nfloat objs(vec3 p){\n    p.z = 4. * (cos(T) + p.z - T - 4.);\n    float bola = length(p) - .85;\n    p.z += 5. * cos(T*4.);\n    float torus = length(vec2(length(p)-4., p.z)) - .1;\n    return min(torus, bola);\n}\n\nfloat map(vec3 p){\n    // tunnel stuff\n    p.z += T;\n    p.xy -= path(p.z) - path(T);\n      \n    return cableNest(p, objs(p));\n}\n\nvoid mainImage(out vec4 O, vec2 u){\n    // resolution\n    vec2 uv = (2. * u - res) / res.y;\n\n    // camera\n    vec3 ro = vec3(0, 0, -1.),\n         rd = normalize(vec3(uv, 1));\n         \n    // raymarch\n    float s, i, d, far = 102.;\n    while(i++ < 8e2) {\n        s = map(ro + d * rd);\n        d += s * .1;\n        if(d > far || s < .02) break;\n    }\n\n    vec3 col;\n    if(d < far) {\n        // normal\n        vec2 e = vec2(.01, 0);\n        vec3 p = ro + rd * d,\n             n = normalize(\n                 map(p) - vec3(\n                     map(p-e.xyy), \n                     map(p-e.yxy),\n                     map(p-e.yyx)));\n        // colors\n        col = cor;\n        col *= -dot(reflect(n, rd), n) * .09 + .2;\n        col *= 1. - d * d / far;\n        col = pow(abs(col), vec3(.6)) * 3.5 - .7;\n    }\n    \n    else{\n        // background\n        col *= 0.;\n    }\n    \n    O = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}