{"ver":"0.1","info":{"id":"XcsyRM","date":"1720952312","viewed":132,"name":"Alibaba Cloud's mascot Yun Xiao ","username":"letbonsaibe","description":"learn material \n1. https://www.shadertoy.com/view/Wl2SRw\n2. iq youtube https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n3. the art of code youtube raymarching for dummy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n#define NORMAL_DELTA 0.01\n#define AA 2\n#define PI 3.1415926\n\n\n// all sdf from iq articles https://iquilezles.org/articles/distfunctions/\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nvec2 smin(vec2 a, vec2 b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * 0.25 / k;\n}\n\n\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opSUnion(vec2 d1, vec2 d2, float k) {\n    return vec2(smin(d1.x, d2.x, k), (d1.x < d2.x) ? d1.y : d2.y);\n}\n\nfloat bendSdEllipsoid(vec3 p, vec3 r, float k)\n{\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m * p.xy, p.z);\n    return sdEllipsoid(q, r);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat bendSdRoundBoxd(vec3 p, vec3 b, float r, float k)\n{\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m * p.xy, p.z);\n    return sdRoundBox(q, b, r);\n}\nfloat sdRing(in vec2 p, in vec2 n, in float r, in float th)\n{\n    p.x = abs(p.x);\n\n    p = mat2(n.x, n.y, -n.y, n.x) * p;\n\n    return max(abs(length(p) - r) - th * 0.5,\n               length(vec2(p.x, max(0.0, abs(r - p.y) - th * 0.5))) * sign(p.x));\n}\n\nfloat extrusionRing(in vec3 p, in vec2 n, in float r, in float th, in float h)\n{\n    float d = sdRing(p.xy, n, r, th);\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nvec2 r2d(vec2 p, float angle) {\n    return mat2(\n        cos(angle), sin(angle),\n        -sin(angle), cos(angle)\n    ) * p;\n}\n\nfloat squareWare(float time) {\n    return sign(fract(time * .5) - .5);\n}\n\nvec2 srandom2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\n\n\nvec2 map(vec3 pos, float time) {\n    float idx = 0.5;\n    vec2 result = vec2(-1.0);\n\n\n    float t = fract(time);\n    //t = .0;\n\n    // parabola jumping\n    float y = 4.0 * t * (1.0 - t);  // from 0-1\n    float dy = 4.0 * (1.0 - 2.0 * t); // directive of y\n\n    // forward\n    // wiggle\n    float wiggleAngle = 0.1 * PI * y * squareWare(time);\n    // forward\n    float mz = time;\n    float mx = 0.0 * (t - .5) * squareWare(time);\n    float my = 3.0 * y + .4;\n    vec3 center = vec3(mx, my, mz);\n\n\n    // Fell on the ground then got flattened\n    float flattenedRatio = abs(dy) * abs(dy) * abs(dy);\n    float sz = 0.002 * flattenedRatio;\n    float sx = sz;\n    float sy = -2. * sz;\n\n    vec3 qos = pos - center;\n    qos.xz = r2d(qos.xz, wiggleAngle);\n\n    // body\n    {\n        float face = sdCapsule(\n            qos - vec3(0.0, 0.0, 0.0),\n            vec3(-.3, .0, 0.0),\n            vec3(.3, .0, 0.0),\n            0.32 + sz\n        );\n        float hair = sdEllipsoid(\n            qos - vec3(0.0, 0.25, 0.0),\n            vec3(0.5, .4 + sy, .33)\n        );\n        \n        float face2 = sdEllipsoid(\n            qos - vec3(0.3, -0.1, 0.0), \n            vec3(.4 + sz, .4 + sy, .4 + sz)\n        );\n        float face3 = sdEllipsoid(\n            qos - vec3(-0.3, -0.1, 0.0),\n            vec3(.4 + sz, .4 + sy, .4 + sz)\n        );\n        float face4 = sdEllipsoid(\n            qos - vec3(-0., -0.1, 0.0),\n            vec3(.4 + sz, .4 + sy, .4 + sz)\n        );\n        \n        float head = smin(face, hair, 0.2);\n        head = smin(head, face2, 0.1);\n        head = smin(head, face3, 0.1);\n        head = smin(head, face4, 0.1);\n\n        // head wiggle\n        //head += sin(qos.y) * y * 0.3;\n        \n        result = vec2(head, ++idx);\n    }\n\n    // eye\n    {\n        vec3 qos2 = vec3(abs(qos.x), qos.yz);\n        float eye = sdSphere(qos2 - vec3(0.20, 0.25, 0.32 + sz), 0.06);\n        result = opUnion(result, vec2(eye, ++idx));\n    }\n\n    // mouth\n    {\n        vec3 qos2 = qos;\n        float mouth = bendSdEllipsoid(qos2 - vec3(0., -0.12, .35), vec3(0.2, 0.09, 0.2), 2. - sz * 0.);\n        result.x = smax(result.x, -mouth, 0.1);\n    }\n\n    // teeth\n    {\n        vec3 qos2 = vec3(abs(qos.x), qos.yz);\n        float teeth = bendSdRoundBoxd(\n            qos2 - vec3(0.07, -.02, 0.38),\n            vec3(.06, .03, .01), \n            0.001, \n            0.2\n        );\n        result = opUnion(result, vec2(teeth, ++idx));\n    }\n\n    // ground\n    {\n        float groundHeight =  0.05 * (sin(2. * pos.x) + sin(3. * pos.z));\n        float t5 = fract(time+0.05);\n        float k = length(pos.xz-center.xz);\n        float tt = t5*15.0-6.2831 - k*3.0;\n        groundHeight -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5);\n        float ground = pos.y - groundHeight;\n\n        vec3 qos = vec3(\n            mod(abs(pos.x), 4.0) - 2.,\n            pos.y,\n            mod(pos.z + 1.5, 3.0) - 1.5);\n        vec2 id = vec2(\n            floor(abs(pos.x / 4.0)),\n            floor((pos.z + 1.5) / 3.0)\n        );\n        vec2 rr = srandom2(id);\n        vec3 radius = vec3(1.0, 1.5 + rr.x * rr.y, .7);\n        float tree = sdEllipsoid(qos, radius);\n        \n        ground = smin(tree, ground, 1.0);\n        result = opUnion(result, vec2(ground, .5));\n    }\n\n\n    \n    \n    return result;\n}\n\n\nvec3 calcNormal(vec3 p, float time) {\n    vec2 e = vec2(NORMAL_DELTA, 0.);\n    return normalize(vec3(\n                         map(p + e.xyy, time).x - map(p - e.xyy, time).x,\n                         map(p + e.yxy, time).x - map(p - e.yxy, time).x,\n                         map(p + e.yyx, time).x - map(p - e.yyx, time).x\n                     ));\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, float time)\n{\n    vec2 res = vec2(-1.0, -1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for (int i = 0; i < MAX_STEPS && t < tmax; i++)\n    {\n        vec2 h = map(ro + rd * t, time);\n        if (h.x < SURFACE_DIST || h.x > MAX_DIST)\n        {\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n\nvoid calcLight(\ninout vec3 col,\n      float dist,\n      vec3 rayDirection,\n      vec3 sunLightDirection,\n      vec3 position,\n      float time\n) {\n\n    vec3 surfaceNormal = calcNormal(position, time);\n    float kSpecular = 1.0;\n\n    float sunDiffuse = clamp(dot(surfaceNormal, sunLightDirection), 0.0, 1.0);\n    vec3 halfVector = normalize(sunLightDirection - rayDirection);\n    float isBocked = castRay(position + SURFACE_DIST * surfaceNormal, sunLightDirection, time).y;\n    float sunShadow = step(isBocked, 0.0);\n\n    float blinnSpecular = kSpecular * pow(clamp(dot(surfaceNormal, halfVector), 0.0, 1.0), 8.0);\n    float fresnelSchlick = 0.04 + (1. - 0.04) * pow(clamp(1.0 + dot(halfVector, rayDirection), 0.0, 1.0), 5.0);\n    float sumSpecular = blinnSpecular * fresnelSchlick * sunDiffuse;\n\n    float skyDiffuse = sqrt(clamp(0.5 + 0.5 * surfaceNormal.y, 0.0, 1.0));\n    float faceToLand = sqrt(clamp(0.1 - 0.9 * surfaceNormal.y, 0.0, 1.0));\n    float nearToLand = clamp(1.0 - 0.1 * position.y, 0.0, 1.0);\n    float bounceDiffuse = faceToLand * nearToLand;\n\n    vec3 light = vec3(0.0);\n    light += skyDiffuse * vec3(0.50, 0.70, 1.00) * 1.5;          // sky is blue    蓝天\n    light += bounceDiffuse * vec3(0.40, 1.00, 0.40) * .6;       // land is green  绿地\n    light += sunDiffuse * vec3(8.10, 6.00, 4.20) * sunShadow * 0.6;// sun is red     红日\n\n    col = col * light;\n    col += sumSpecular * vec3(8.10, 6.00, 4.20) * sunShadow;\n\n    col = mix(col, vec3(0.5, 0.7, 0.9), 1.0 - exp(-0.0001 * dist * dist * dist));\n\n}\n\n\nmat3 setCamera(vec3 ro, vec3 ta, float a) {\n    vec3 forward = normalize(ta - ro);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(forward, up);\n\n    // pitch\n    mat3 pitchMat = mat3(\n        cos(a), sin(a), 0.0,\n        -sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n\n    vec3 newForward = forward * pitchMat;\n    vec3 newUp = up * pitchMat;\n    vec3 newRight = cross(newForward, newUp);\n\n    return mat3(newRight, newUp, newForward);\n}\n\n// triangular signal\nvec2 tri(in vec2 x)\n{\n    vec2 h = fract(x * .5) - .5;\n    return 1. - 2. * abs(h);\n}\n\nfloat checkersGrad(in vec2 uv)\n{\n    vec2 w = fwidth(uv);    // filter kernel\n    vec2 i = (tri(uv + 0.5 * w) - tri(uv - 0.5 * w)) / w;   // analytical integral (box filter)\n    return 0.5 - 0.5 * i.x * i.y;                   // xor pattern\n}\n\nfloat checkers(in vec2 uv) {\n    vec2 q = floor(uv);\n    float f = mod(q.x + q.y, 2.);\n    return f;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, float time) {\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y, 0.0) * 0.5;\n\n    vec2 uv =  1.8 * rd.xz/abs(rd.y + 0.2);\n    float cl =  sin(uv.x) + sin( uv.y ) + 0.3*(sin(3. * uv.x) + sin(3. * uv.y));\n    col += 0.2 * smoothstep(-.1, .1, -0.7 - cl)  ;\n    col = mix( col, vec3(0.5, 0.7, .9), exp(-20.0*max(rd.y+0.2 - 0.08,0.0)) );   \n    // float cl  = 3.0*(sin(uv.x)+sin(uv.y));\n    // uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n    // cl += 0.5*(sin(uv.x)+sin(uv.y));\n    // col += 0.1*(-1.0+2.0*smoothstep(-0.2,0.2,cl-0.4));\n\t// col = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y+0.05,0.0)) );    \n\n    vec2 res = castRay(ro, rd, time);\n    vec3 p = ro + rd * res.x;\n\n    if (res.y > 3.0) {\n        col = vec3(0.8); // teeth\n    } else if (res.y > 2.0) {\n        col = vec3(0.0); // eye\n    } else if (res.y > 1.0) {\n        col = vec3(0.4); // body\n    } else if (res.y > 0.0) {\n        col = vec3(0.1, 0.2, 0.02); // land\n        float f = smoothstep(-0.2, 0.2, sin(18.0 * p.x) + sin(18.0 * p.y) + sin(18.0 * p.z));\n        col += f * vec3(0.1, 0.1, 0.02) * 0.6;\n    }\n\n    const float gammer = 2.2;\n    col = pow(col, vec3(gammer));\n\n    if (res.y > -0.5) {\n        calcLight(\n            col,\n            res.x,\n            rd,\n            normalize(vec3(0.6, 0.35, 0.5)),\n            p,\n            time\n        );\n    }\n\n    col = pow(col, vec3(1.0 / gammer));\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec3 tot = vec3(0.0);\n    float time = iTime * 1.0;\n\n    #if AA > 1\nfor (int m = 0; m < AA; m++) {\n    for (int n = 0; n < AA; n++) {\n        // pixel coordinates\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n        #else\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n        #endif\n    vec3 col = vec3(0.0);\n\n\n    // camera 1\n    float cl = sin(0.5*time);\n    float theta =  mix( \n        0.4 * PI * (iMouse.x - iResolution.x * .5)/ iResolution.x + 0.5 * PI, // mouse control\n        .5 * PI + 0.7*sin(0.15*time),  // auto rotate\n        step(iMouse.z, 0.) // when mouse press\n    );\n    \n    float pitch =  0.2 * PI * (iMouse.y - iResolution.y * .5)/ iResolution.y;\n\n    float radius = 5.;\n    vec3 target = vec3(0.0, .65, time-0.4*cl-0.6);\n    vec3 rayOrigin  = target + vec3( radius * cos(theta), 1.0+ cos(pitch), radius*sin(theta) + 1. );\n\n    // camera bounce\n    float t4 = abs(fract(time*0.5)-0.5)/0.5;\n    float bounce = -1.0 + 2.0*t4;\n    rayOrigin += 0.06*sin(time*12.0+vec3(0.0,1.0,2.0) * 2.0)*smoothstep( 0.85, 1.0, abs(bounce) );\n\n    //target = vec3(rayOrigin.x, 10.0, 0.0);\n     mat3 camera = setCamera( rayOrigin, target, pitch );\n    vec3 rayDirection = normalize(camera * vec3(uv, 1.8) );\n\n        col = render(rayOrigin, rayDirection, time);\n\n\n        tot += col;\n        #if AA > 1\n    }}\n    tot /= float(AA * AA);\n    #endif\n\n    fragColor = vec4(tot, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}