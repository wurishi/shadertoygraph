{"ver":"0.1","info":{"id":"mlS3Rz","date":"1672753074","viewed":130,"name":"Fork CPE v1.2 debug","username":"kshitijgangwar","description":"Camera Preview Enhancements\nInteractive Demo for Simple Ehancements v1\n\nEnhancements as follows:\nBrightness\nContrast\nSaturation\nSharpnrning\nColor Temperature\nNoise Reduction\nSmoothening\n","likes":0,"published":1,"flags":34,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"Ds2SzR","parentname":"CPE v1.2 Smoothening+Sharpening"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = float(3.14159);\n\n//----------------------------------------Sharpness Parameters----------------------------------------\n#define curve_height    1.0                  // Main control of sharpening strength [>0]\n        // 0.3 <-> 2.0 is a reasonable range of values\n\n#define overshoot_ctrl  false                // Allow for higher overshoot if the current edge pixel\n// is surrounded by similar edge pixels\n\n// Defined values under this row are \"optimal\" DO NOT CHANGE IF YOU DO NOT KNOW WHAT YOU ARE DOING!\n\n#define curveslope      0.5                  // Sharpening curve slope, high edge values\n\n#define L_compr_low     0.167                // Light compression, default (0.167=~6x)\n#define L_compr_high    0.334                // Light compression, surrounded by edges (0.334=~3x)\n\n#define D_compr_low     0.250                // Dark compression, default (0.250=4x)\n#define D_compr_high    0.500                // Dark compression, surrounded by edges (0.500=2x)\n\n#define scale_lim       0.1                  // Abs max change before compression [>0.01]\n#define scale_cs        0.056                // Compression slope above scale_lim\n\n#define pm_p            1.0                  // Power mean p-value [>0-1.0]\n\n#define max4(a,b,c,d)  ( max(max(a, b), max(c, d)) )\n\n// Soft if, fast linear approx\n#define soft_if(a,b,c) ( sat((a + b + c + 0.056/2.5)/(maxedge + 0.03/2.5) - 0.85) )\n\n// Soft limit, modified tanh approx\n#define soft_lim(v,s)  ( sat(abs(v/s)*(27.0 + pow(v/s, 2.0))/(27.0 + 9.0*pow(v/s, 2.0)))*s )\n\n// Weighted power mean\n#define wpmean(a,b,w)  ( pow(w*pow(abs(a), pm_p) + abs(1.0-w)*pow(abs(b), pm_p), (1.0/pm_p)) )\n\n// Get destination pixel values\n#define get(a,b)       ( texture(iChannel1, vuv + vec2(a,b)/size).rgb )\n#define gett(v_uv)     ( texture(iChannel1, v_uv).rgb )\n#define sat(x)         ( clamp(x, 0.0, 1.0) )\n#define dxdy(val)      ( length(fwidth(val)) ) // =~1/2.5 hq edge without c_comp\n\n#ifdef LUMA_tex\n#define CtL(RGB)       RGB.x\n#else\n#define CtL(RGB)       ( sqrt(dot(sat(RGB)*sat(RGB), vec3(0.2126, 0.7152, 0.0722))) )\n#endif\n\n#define b_diff(pix)    ( (blur-luma[pix])*(blur-luma[pix]) )\n//----------------------------------------------------------------------------------------------------\n\nvec3 sharpen(float uSharpenAmount, vec3 tex, vec2 vuv, vec2 size){\n\n    vec3 c[25] = vec3[](get( 0, 0), get(-1,-1), get( 0,-1), get( 1,-1), get(-1, 0),\n                        get( 1, 0), get(-1, 1), get( 0, 1), get( 1, 1), get( 0,-2),\n                        get(-2, 0), get( 2, 0), get( 0, 2), get( 0, 3), get( 1, 2),\n                        get(-1, 2), get( 3, 0), get( 2, 1), get( 2,-1), get(-3, 0),\n                        get(-2, 1), get(-2,-1), get( 0,-3), get( 1,-2), get(-1,-2));\n\n    float e[13] = float[](dxdy(c[0]),  dxdy(c[1]),  dxdy(c[2]),  dxdy(c[3]),  dxdy(c[4]),\n                        dxdy(c[5]),  dxdy(c[6]),  dxdy(c[7]),  dxdy(c[8]),  dxdy(c[9]),\n                        dxdy(c[10]), dxdy(c[11]), dxdy(c[12]));\n\n    // RGB to luma\n    float luma[25] = float[](CtL(c[0]), CtL(c[1]), CtL(c[2]), CtL(c[3]), CtL(c[4]), CtL(c[5]), CtL(c[6]),\n                            CtL(c[7]),  CtL(c[8]),  CtL(c[9]),  CtL(c[10]), CtL(c[11]), CtL(c[12]),\n                            CtL(c[13]), CtL(c[14]), CtL(c[15]), CtL(c[16]), CtL(c[17]), CtL(c[18]),\n                            CtL(c[19]), CtL(c[20]), CtL(c[21]), CtL(c[22]), CtL(c[23]), CtL(c[24]));\n\n    float c0_Y = luma[0];\n\n    // Blur, gauss 3x3\n    float  blur   = (2.0 * (luma[2]+luma[4]+luma[5]+luma[7]) + (luma[1]+luma[3]+luma[6]+luma[8]) + 4.0 * luma[0]) / 16.0;\n\n    // Contrast compression, center = 0.5\n    float c_comp = sat(0.266666681f + 0.9*exp2(blur * blur * -7.4));\n\n    // Edge detection\n    // Relative matrix weights\n    // [          1          ]\n    // [      4,  5,  4      ]\n    // [  1,  5,  6,  5,  1  ]\n    // [      4,  5,  4      ]\n    // [          1          ]\n\n    float edge = ( 1.38*b_diff(0)\n                + 1.15*(b_diff(2) + b_diff(4) + b_diff(5) + b_diff(7))\n                + 0.92*(b_diff(1) + b_diff(3) + b_diff(6) + b_diff(8))\n                + 0.23*(b_diff(9) + b_diff(10) + b_diff(11) + b_diff(12)) ) * c_comp;\n\n    vec2 cs = vec2(L_compr_low,  D_compr_low);\n\n    if (overshoot_ctrl) {\n        float maxedge = max4( max4(e[1],e[2],e[3],e[4]), max4(e[5],e[6],e[7],e[8]),\n                            max4(e[9],e[10],e[11],e[12]), e[0] );\n\n        // [          x          ]\n        // [       z, x, w       ]\n        // [    z, z, x, w, w    ]\n        // [ y, y, y, 0, y, y, y ]\n        // [    w, w, x, z, z    ]\n        // [       w, x, z       ]\n        // [          x          ]\n        float sbe = soft_if(e[2],e[9], dxdy(c[22]))*soft_if(e[7],e[12],dxdy(c[13]))  // x dir\n            + soft_if(e[4],e[10],dxdy(c[19]))*soft_if(e[5],e[11],dxdy(c[16]))  // y dir\n            + soft_if(e[1],dxdy(c[24]),dxdy(c[21]))*soft_if(e[8],dxdy(c[14]),dxdy(c[17]))  // z dir\n            + soft_if(e[3],dxdy(c[23]),dxdy(c[18]))*soft_if(e[6],dxdy(c[20]),dxdy(c[15])); // w dir\n\n        cs = mix(cs, vec2(L_compr_high, D_compr_high), sat(2.4002*sbe - 2.282));\n    }\n\n    // Precalculated default squared kernel weights\n    const vec3 w1 = vec3(0.5,           1.0, 1.41421356237); // 0.25, 1.0, 2.0\n    const vec3 w2 = vec3(0.86602540378, 1.0, 0.54772255751); // 0.75, 1.0, 0.3\n\n    // Transition to a concave kernel if the center edge val is above thr\n    vec3 dW = pow(mix( w1, w2, sat(2.4*edge - 0.82)), vec3(2.0));\n\n    // Use lower weights for pixels in a more active area relative to center pixel area\n    // This results in narrower and less visible overshoots around sharp edges\n    float modif_e0 = 3.0 * e[0] + 0.02/2.5;\n\n    float weights[12]  = float[](( min(modif_e0/e[1],  dW.y) ),\n                                ( dW.x ),\n                                ( min(modif_e0/e[3],  dW.y) ),\n                                ( dW.x ),\n                                ( dW.x ),\n                                ( min(modif_e0/e[6],  dW.y) ),\n                                ( dW.x ),\n                                ( min(modif_e0/e[8],  dW.y) ),\n                                ( min(modif_e0/e[9],  dW.z) ),\n                                ( min(modif_e0/e[10], dW.z) ),\n                                ( min(modif_e0/e[11], dW.z) ),\n                                ( min(modif_e0/e[12], dW.z) ));\n\n    weights[0] = (max(max((weights[8]  + weights[9])/4.0,  weights[0]), 0.25) + weights[0])/2.0;\n    weights[2] = (max(max((weights[8]  + weights[10])/4.0, weights[2]), 0.25) + weights[2])/2.0;\n    weights[5] = (max(max((weights[9]  + weights[11])/4.0, weights[5]), 0.25) + weights[5])/2.0;\n    weights[7] = (max(max((weights[10] + weights[11])/4.0, weights[7]), 0.25) + weights[7])/2.0;\n\n    // Calculate the negative part of the laplace kernel and the low threshold weight\n    float lowthrsum   = 0.0;\n    float weightsum   = 0.0;\n    float neg_laplace = 0.0;\n\n    for (int pix = 0; pix < 12; ++pix)\n    {\n        float lowthr = sat((20.*4.5*c_comp*e[pix + 1] - 0.221));\n\n        neg_laplace += luma[pix+1] * luma[pix+1] * weights[pix] * lowthr;\n        weightsum   += weights[pix] * lowthr;\n        lowthrsum   += lowthr / 12.0;\n    }\n\n    neg_laplace = sqrt(neg_laplace / weightsum);\n\n    // Compute sharpening magnitude function\n    float sharpen_val = uSharpenAmount/(uSharpenAmount*curveslope*edge + 0.625);\n\n    // Calculate sharpening diff and scale\n    float sharpdiff = (c0_Y - neg_laplace)*(lowthrsum*sharpen_val + 0.01);\n\n    // Calculate local near min & max, partial sort\n    float temp;\n\n    for (int i1 = 0; i1 < 24; i1 += 2)\n    {\n        temp = luma[i1];\n        luma[i1]   = min(luma[i1], luma[i1+1]);\n        luma[i1+1] = max(temp, luma[i1+1]);\n    }\n\n    for (int i2 = 24; i2 > 0; i2 -= 2)\n    {\n        temp = luma[0];\n        luma[0]    = min(luma[0], luma[i2]);\n        luma[i2]   = max(temp, luma[i2]);\n\n        temp = luma[24];\n        luma[24] = max(luma[24], luma[i2-1]);\n        luma[i2-1] = min(temp, luma[i2-1]);\n    }\n\n    float min_dist  = min(abs(luma[24] - c0_Y), abs(c0_Y - luma[0]));\n    min_dist = min(min_dist, scale_lim*(1.0 - scale_cs) + min_dist*scale_cs);\n\n    // Soft limited anti-ringing with tanh, wpmean to control compression slope\n    sharpdiff = wpmean(max(sharpdiff, 0.0), soft_lim( max(sharpdiff, 0.0), min_dist ), cs.x )\n        - wpmean(min(sharpdiff, 0.0), soft_lim( min(sharpdiff, 0.0), min_dist ), cs.y );\n\n    float sharpdiff_lim = sat(c0_Y + sharpdiff) - c0_Y;\n\n    return sharpdiff_lim + c[0];\n}\n\nvoid DrawScene(inout vec3 color)\n{\n    vec2 uv = F.xy/R.xy;\n    \n    #ifdef MIRROR_CAM\n       uv.x = 1.0 - uv.x;\n    #endif\n\n\n    vec4 tex = texture(iChannel1, uv);\n    vec2 tex_size = vec2(textureSize(iChannel1, 0));\n    color = tex.rgb;\n\n    //Sharpness\n    color = sharpen(uSharpenAmount, tex.rgb, uv, tex_size);\n\n \n    if (F.x < iMouse.x)\n        color = tex.rgb;\n    \n        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 color = vec3(0.);    \n    \n    DrawScene(color);\n    fragColor = vec4(color, 1.);\n    \n    if(abs(F.x - iMouse.x) < 2.)\n        if(F.x > iMouse.x)\n            fragColor = vec4(0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIRROR_CAM\n\n#define F gl_FragCoord\n#define R iResolution\n#define v_uv (R.xy/R.xy)\n#define uInputTexture iChannel1 // cam\n// #define uInputTexture iChannel2 // britney\n\n#define T iTime\n\n//Change parameters here:\n//------------------------PARAMETERS---------------------------//\nfloat uHue              = 1.00;  // Hue\nfloat uSaturation       = 1.00;  // Saturation\nfloat uValue            = 1.00;  // Value (Brightness)\nfloat uTonemapping      = 0.00;  // Tonemapping\nfloat uContrast         = 1.00;  // Contrast\n\n//Color Temperature Parameters\nfloat uTemp             = 4500.0;// Temp (Warm - Cool Image)\nfloat uTempAmount       = 0.00;  // Temp Change Factor\n\n//Noise Reduction Parameters\nfloat uNRAmount         = 0.00;  // Noise Reduction Opacity \nfloat uGamma            = 1.00;  // Gamma\nfloat uIntensitySigma   = 1.30;  // Noise Reduction\nfloat uSpatialSigma     = 1.65;  // Noise Reduction Sampler\n\n//Smoothening Parameters\nfloat uSmoothenBlurIntensity= 1.00;  // Smoothen Blur Quality\nfloat uSmoothenOverlayBlend = 1.00; // Smoothen Blur Sampling Directions\nconst float radius = 2.0;\nfloat onlyBlur          = 0.00;  // Toggle to compare against basic gaussian blur\n\n//Sharpening Parameters\nfloat uSharpenAmount    = 00.00; // Sharpening Strength\n\n\n//------------------------PARAMETERS---------------------------//\n\nfloat kEps = 0.01;\n\nmat3 YUVFromRGB = mat3(\n    vec3( 0.299, -0.14713,  0.615  ),\n    vec3( 0.587, -0.28886, -0.51499),\n    vec3( 0.114,    0.436, -0.10001)\n);\n\nmat3 RGBFromYUV = mat3(\n    vec3( 1.0,      1.0,   1.0    ),\n    vec3( 0.0,     -0.394, 2.03211),\n    vec3( 1.13983, -0.580, 0.0    )\n);\n\nfloat LumaFromRGB(vec3 c)\n{\n    return c.r * 0.299 + c.g * 0.587 + c.b * 0.114;\n}\n\n// Will it blend by nmz: https://www.shadertoy.com/view/lsdGzN\n// From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 HSVFromRGB( vec3 c )\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 RGBFromHSV( vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// by P Malin https://www.shadertoy.com/view/4lcyD8\nvec3 inverse_tonemap_mul(vec3 vCol )\n{\n    vec3 color = vCol * vCol;\n    float kEnvmapExposure = 0.999;\n    return -log2(1.0 - color * kEnvmapExposure);\n}\n\n// src: https://64.github.io/tonemapping/\n// by K Narkowicz\nvec3 tonemap_aces_approx(vec3 v)\n{\n    v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// TODO: make sure uInputTexture sampler is CLAMP_TO_EDGE\nvec2 kOffsets[8] = vec2[](\n    vec2( -1.0,  1.0), vec2(  0.0,  1.0), vec2(  1.0,  1.0),\n    vec2( -1.0,  0.0),                    vec2(  1.0,  0.0),\n    vec2( -1.0, -1.0), vec2(  0.0, -1.0), vec2(  1.0, -1.0)\n);\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float PI = float(3.14159);\n//----------------------------------------Noise Reduction Parameters----------------------------------\n#define LUMINANCE_PRESERVATION 0.75\n#define EPSILON 1e-10\n\n#define KERNELSIZE (max(int(ceil(uSpatialSigma * 2.0)), 1) * 2 + 1) //Kernel size, must be an positive odd integer.\n#define KERNELHALFSIZE (int(KERNELSIZE/2)) //Half of the kernel size without remainder. Must be equal to trunc(KERNELSIZE/2).\n#define KERNELLEN (KERNELSIZE * KERNELSIZE) //Total area of kernel. Must be equal to KERNELSIZE * KERNELSIZE.\n\n//----------------------------------------------------------------------------------------------------\n\n\nvec4 gaussian_vec(vec4 x, vec4 s, vec4 m) {\n    vec4 scaled = (x - m) / s;\n    return exp(-0.5 * scaled * scaled);\n}\n\nfloat gaussian(float x, float s, float m) {\n    float scaled = (x - m) / s;\n    return exp(-0.5 * scaled * scaled);\n}\n\nvec4 noiseReduction(float uGamma, float uIntensitySigma, float uSpatialSigma, vec4 vc, vec2 size, vec2 vuv){\n    vec4 sum = vec4(0.0);\n    vec4 n = vec4(0.0);\n    \n    vec4 is = pow(vc + 0.0001, vec4(uGamma)) * uIntensitySigma;\n    float ss = uSpatialSigma;\n\n    for (int i = -1 * KERNELHALFSIZE; i <= KERNELHALFSIZE; i++) {\n        for (int j = -1 * KERNELHALFSIZE; j <= KERNELHALFSIZE; j++){\n    \n            vec4 v = texture(iChannel1, vuv + vec2(i,j)/size);\n            \n            vec4 d = gaussian_vec(v, is, vc) * gaussian(length(vec2(float(i),float(j))), ss, 0.0);\n            sum += d * v;\n            n += d;\n        }\n    }\n    \n    return sum / n;\n}\n\nvoid DrawScene(inout vec3 color)\n{\n\n    vec2 uv = F.xy/R.xy;\n\n\n    vec4 tex = texture(iChannel1, uv);\n    vec2 tex_size = vec2(textureSize(iChannel1, 0));\n    color = tex.rgb;\n\n    //NoiseReduction\n    color = noiseReduction(uGamma, uIntensitySigma, uSpatialSigma, tex, tex_size, uv).rgb;\n    color = mix(tex.rgb, color, uNRAmount);\n\n    if (F.x > iResolution.x - iMouse.x)\n        color = tex.rgb;\n        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 color = vec3(0.);    \n    fragColor = vec4(color, 1.);\n    DrawScene(color);\n    fragColor = vec4(color, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = float(3.14159);\n//----------------------------------------Noise Reduction Parameters----------------------------------\n#define LUMINANCE_PRESERVATION 0.75\n#define EPSILON 1e-10\n\n#define KERNELSIZE (max(int(ceil(uSpatialSigma * 2.0)), 1) * 2 + 1) //Kernel size, must be an positive odd integer.\n#define KERNELHALFSIZE (int(KERNELSIZE/2)) //Half of the kernel size without remainder. Must be equal to trunc(KERNELSIZE/2).\n#define KERNELLEN (KERNELSIZE * KERNELSIZE) //Total area of kernel. Must be equal to KERNELSIZE * KERNELSIZE.\n\n//----------------------------------------------------------------------------------------------------\n\n\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2  saturate(vec2  v) { return clamp(v, vec2(0.0), vec2(1.0)); }\nvec3  saturate(vec3  x) { return clamp(x, vec3(0.0), vec3(1.0)); }\nvec4  saturate(vec4  v) { return clamp(v, vec4(0.0), vec4(1.0)); }\n\nvec3 ColorTemperatureToRGB(float temperatureInKelvins)\n{\n    vec3 retColor;\n\n    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;\n\n    if (temperatureInKelvins <= 66.0)\n    {\n        retColor.r = 1.0;\n        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);\n    }\n    else\n    {\n        float t = temperatureInKelvins - 60.0;\n        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n    }\n\n    if (temperatureInKelvins >= 66.0)\n        retColor.b = 1.0;\n    else if(temperatureInKelvins <= 19.0)\n        retColor.b = 0.0;\n    else\n        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);\n\n    return retColor;\n}\n\nfloat Luminance(vec3 color)\n{\n    float fmin = min(min(color.r, color.g), color.b);\n    float fmax = max(max(color.r, color.g), color.b);\n    return (fmax + fmin) / 2.0;\n}\n\nvec3 HUEtoRGB(float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + vec3(HSL.z);\n}\n\nvec3 RGBtoHCV(vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSL(vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\nvec3 colorTempWrapper(float uTemp, float uFactor, vec3 col){\n    vec3  colorTempRGB = ColorTemperatureToRGB(uTemp);\n    float originalLuminance = Luminance(col);\n    vec3  blended = mix(col, col * colorTempRGB, uFactor);\n    vec3  resultHSL = RGBtoHSL(blended);\n    vec3  luminancePreservedRGB = HSLtoRGB(vec3(resultHSL.x, resultHSL.y, originalLuminance));        \n    col = mix(blended, luminancePreservedRGB, LUMINANCE_PRESERVATION);\n    return col;\n}\n\n\nvoid DrawScene(inout vec3 color)\n{\n\n    vec2 uv = F.xy/R.xy;\n\n    vec4 tex = texture(iChannel1, uv);\n    vec2 tex_size = vec2(textureSize(iChannel1, 0));\n    color = tex.rgb;\n\n    //ColorTemperature\n    color = colorTempWrapper(uTemp, uTempAmount, tex.rgb);\n\n    // Tonemmaping\n    vec3 ldr = color;\n    if (abs(uTonemapping) > kEps) {\n        vec3 hdr = inverse_tonemap_mul(color);\n        ldr = tonemap_aces_approx(hdr);\n        color = mix(color, ldr, uTonemapping);\n    }\n\n    // HSV correction\n    vec3 col = ldr;\n    // HOTFIX: uHue ignored for now, it is causing noise on adjacent near white pixels.\n    vec3 hsvFactors = vec3(1.0, uSaturation, uValue);\n    if (abs(dot(hsvFactors, hsvFactors) - 1.) > kEps) {\n        vec3 hsv = HSVFromRGB(color);\n        hsv *= hsvFactors;\n        color = RGBFromHSV(hsv);\n        color = clamp(color, 0.0, 1.0);\n    }\n\n    // Contrast\n    if (abs(uContrast - 1.0) > kEps) {\n        color = pow(color, vec3(uContrast));\n        color = clamp(color, 0.0, 1.0);\n    }\n\n    color = clamp(color, 0.0, 1.0);\n\n    if (F.x > iResolution.x - iMouse.x)\n        color = tex.rgb;\n        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 color = vec3(0.);    \n    \n    DrawScene(color);\n    fragColor = vec4(color, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int kHalfSamples = 1; // (kHalfSamples + 1) x (kHalfSamples + 1) samples total; TODO: use mipmaps\nconst float kWeightSigma[5] = float[5](1.0, 0.98, 0.923, 0.835, 0.726);\n\nfloat gaussian(int x) {\n    // return exp(-(x*x) / (2.0 * sigma*sigma));\n    return x > kHalfSamples\n        ? 0.0\n        : kWeightSigma[x];\n}\nvec3 gaussianBlur(vec2 uv) {\n    \n    vec2 texSize = vec2(textureSize(iChannel1, 0));\n    vec2 pixelSize = 1.0 / texSize;\n    float total = 0.0;\n    vec3 ret = vec3(0);\n    for (int iy = -kHalfSamples; iy <= kHalfSamples; iy++) {\n        float fy = gaussian(abs(iy));\n        float offsety = float(iy) * pixelSize.y * radius;\n        for (int ix = -kHalfSamples; ix <= kHalfSamples; ++ix) {\n            float fx = gaussian(abs(ix));\n            float offsetx = float(ix) * pixelSize.x * radius;\n            total += fx*fy;\n            ret += fx*fy * texture(iChannel1, uv + vec2(offsetx, offsety)).rgb;\n        }\n    }\n    return ret / total;\n}\n\nfloat process_channel_overlay(float a, float b){\n\n    if(a >= 0.5)\n        return 1. - 2. * (1. - a) * (1. - b);\n    else\n        return 2. * a * b;\n}\n\nvec3 blendOverlay(vec3 base_frame, vec3 high_pass){\n\n    vec3 blended;\n    blended.r = process_channel_overlay(base_frame.r, high_pass.r);\n    blended.g = process_channel_overlay(base_frame.g, high_pass.g);\n    blended.b = process_channel_overlay(base_frame.b, high_pass.b);\n\n    return blended;\n}\n\nvec3 smoothen(vec2 uv) {\n    vec3 tex = texture(iChannel1, uv).rgb;\n    vec3 gaussian = mix(tex, gaussianBlur(uv), min(uSmoothenBlurIntensity, 1.0));\n    vec3 gaussian_inv = 1.0 - gaussian;\n    vec3 high_pass = (vec3(1.) - tex) - gaussian_inv + vec3(0.5);\n    vec3 blended = blendOverlay(tex, high_pass);\n    return mix(tex, blended, uSmoothenOverlayBlend);\n}\n\nvoid DrawScene(inout vec3 color)\n{\n    vec2 uv = F.xy/R.xy;\n\n    vec4 tex = texture(iChannel1, uv);\n    vec2 tex_size = vec2(textureSize(iChannel1, 0));\n    color = tex.rgb;\n    \n    //Smoothening\n    if(onlyBlur == 0.00)\n        tex.rgb = smoothen(uv);\n    else{\n        tex.rgb = gaussianBlur(uv);\n    }\n    \n    if (F.x < iResolution.x - iMouse.x)\n        color = tex.rgb;\n        \n        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 color = vec3(0.);    \n    \n    DrawScene(color);\n    fragColor = vec4(color, 1.);\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}