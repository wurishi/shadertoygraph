{"ver":"0.1","info":{"id":"ldBBDR","date":"1500020041","viewed":189,"name":"lit cloud","username":"loganz","description":"bad perlin noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat grad(float hash, vec3 pos) {\n    float h = floor(mod(hash, 16.0));\n    float u = h<8.0 ? pos.x : pos.y,\n          v = h<4.0 ? pos.y : h==12.0||h==14.0 ? pos.x : pos.z;\n    return (mod(h, 2.0) == 0.0 ? u : -u) + (mod(h, 4.0) == 0.0 ? v : -v);\n}\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat hash(float x) {return rand(vec2(x, x * 1.121)) * 256.0;}\nfloat hashx(float x) {return mod(x * 15531.13513 + x * x * 24.98981, 256.0);}\nfloat lerp(float t, float a, float b) {return a+t*(b-a);}\n\nfloat cnoise(vec3 pos){\n    vec3 ipos = mod(floor(pos), 256.0);\n    pos = fract(pos);\n    vec3 faded = fade(pos);\n    \n    float A = hash(ipos.x)+ipos.y, AA = hash(A)+ipos.z, AB = hash(A+1.0)+ipos.z;\n    float B = hash(ipos.x+1.0)+ipos.y, BA = hash(B)+ipos.z, BB = hash(B+1.0)+ipos.z;\n\n    //gradient values\n    float g0 = grad(hash(AA), pos);\n    float g1 = grad(hash(BA), pos-vec3(1.0,0.0,0.0));\n    float g2 = grad(hash(AB), pos-vec3(0.0,1.0,0.0));\n    float g3 = grad(hash(BB), pos-vec3(1.0,1.0,0.0));\n    float g4 = grad(hash(AA+1.0), pos-vec3(0.0,0.0,1.0));\n    float g5 = grad(hash(BA+1.0), pos-vec3(1.0,0.0,1.0));\n    float g6 = grad(hash(AB+1.0), pos-vec3(0.0,1.0,1.0));\n    float g7 = grad(hash(BB+1.0), pos-vec3(1.0,1.0,1.0));\n    return lerp(faded.z, lerp(faded.y, lerp(faded.x, g0, g1), lerp(faded.x, g2, g3)), lerp(faded.y, lerp(faded.x, g4, g5), lerp(faded.x, g6, g7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dim = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 mpos = vec3(iMouse.xy / iResolution.xy, 0.0);\n    \n    int i = 0;\n    vec3 val;\n    for (float f=0.0; f<6.282; f+=0.3) {\n    \tfloat x = f + iTime;\n        vec2 pos = vec2(cos(x), sin(x*2.0)) * 0.25 + 0.5;\n        vec2 dx = pos - uv;\n        float idist = sqrt(dx.x*dx.x + dx.y*dx.y)*1024.0;\n        idist = log(idist+1.0)/log(1024.0);\n        idist = max(0.0, 1.0 - idist);\n        idist *= idist * 0.5;\n        val += idist;\n\t\tif (i == 0)\n            val.r += idist;\n        else if (i == 1)\n            val.g += idist;\n        else\n            val.b += idist;\n        i++;\n        if (i>2)\n            i=0;\n    }\n    \n    vec3 color;\n    vec2 co = vec2(iTime, 0);\n    float intensity = 1.0;\n    float scale = 2.0;\n    for (int i=0; i<7; i++) {\n        vec2 relPos = uv * scale + co;\n    \tfloat cr = cnoise(vec3(relPos, 1.0) + mpos) + 0.5;\n        float cg = cnoise(vec3(relPos, 1.2) + mpos) + 0.5;\n        float cb = cnoise(vec3(relPos, 1.4) + mpos) + 0.5;\n        color += vec3(cr,cg,cb) * intensity;\n        scale *= 2.0;\n        intensity /= 2.0;\n    }\n    \n\tfragColor = vec4(color * val, 1.0);\n}","name":"Image","description":"","type":"image"}]}