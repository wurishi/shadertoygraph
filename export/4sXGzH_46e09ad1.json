{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"vec2 complex_mul(vec2 factorA, vec2 factorB){\n   return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 torus_mirror(vec2 uv){\n\treturn vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n\nfloat circle(vec2 uv, float scale){\n\treturn clamp( 1. - length((uv-0.5)*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n\treturn 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, float radius, float sharpness){\n\treturn 0.5 - sigmoid( ( length( (uv - 0.5)) - radius) * sharpness) * 0.5;\n}\n\nfloat border(vec2 domain, float thickness){\n   vec2 uv = fract(domain-vec2(0.5));\n   uv = min(uv,1.-uv)*2.;\n   return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\tvec2 uv = 0.5 + (fragCoord.xy * vec2(1./iResolution.x,1./iResolution.y) - 0.5)*aspect;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat mouseW = atan((mouse.y - 0.5)*aspect.y, (mouse.x - 0.5)*aspect.x);\n\tvec2 mousePolar = vec2(sin(mouseW), cos(mouseW));\n\tvec2 offset = (mouse - 0.5)*4.;\n\toffset =  - complex_mul(offset, mousePolar) + iTime*0.05;\n\tvec2 uv_distorted = uv;\n\n\t// original loop that caused problems with different GPUs\n\t/*\n\tfor (float i = 0.; i < 4.; i++){\n\t\tfloat filter = smoothcircle(uv_distorted, 0.12, 24.);\n\t\tuv_distorted = torus_mirror(0.5 + complex_mul(((uv_distorted - 0.5)*mix(2., 16., filter)), mousePolar) + offset);\n\t}\n\t*/\n\t\n\t//manually unrolled loop\n\tfloat _filter;\n\t_filter = smoothcircle(uv_distorted, 0.12, 24.);\n\tuv_distorted = torus_mirror(0.5 + complex_mul(((uv_distorted - 0.5)*mix(2., 16., _filter)), mousePolar) + offset);\n\t_filter = smoothcircle(uv_distorted, 0.12, 24.);\n\tuv_distorted = torus_mirror(0.5 + complex_mul(((uv_distorted - 0.5)*mix(2., 16., _filter)), mousePolar) + offset);\n\t_filter = smoothcircle(uv_distorted, 0.12, 24.);\n\tuv_distorted = torus_mirror(0.5 + complex_mul(((uv_distorted - 0.5)*mix(2., 16., _filter)), mousePolar) + offset);\n\t_filter = smoothcircle(uv_distorted, 0.12, 24.);\n\tuv_distorted = torus_mirror(0.5 + complex_mul(((uv_distorted - 0.5)*mix(2., 16., _filter)), mousePolar) + offset);\n\n\t\n\tfragColor = vec4(circle(uv_distorted, 1.4));\n\n\t//fragColor.zw = vec2(0);\n\t//fragColor.xy = uv_distorted; // domain map\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sXGzH","date":"1362144226","viewed":642,"name":"4th Iteration","username":"Flexi","description":"Interactive sigmoid-based plane deformation fractal. Originally designed for a render-to-texture feedback loop, here fixed depth of 4 iterations. Click and drag mouse.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["planedeformation"],"hasliked":0,"parentid":"","parentname":""}}