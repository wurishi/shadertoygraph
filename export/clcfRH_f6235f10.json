{"ver":"0.1","info":{"id":"clcfRH","date":"1700928170","viewed":32,"name":"[WIP] Micro Planet 1.3","username":"codeforger","description":"pixel shaded planet","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pixel","planet"],"hasliked":0,"parentid":"Dlcfz8","parentname":"[WIP] Micro Planet 1.2"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 planet = vec4(1024/2,576/2,300, 1);\nconst float PLANET_SIZE = 200.;\nconst vec3 sunVector = vec3(1, 1, -1);\n//const vec3 sunVector = vec3(1, 0, 0);\nconst int MARCH_MAX = 100;\nconst float DST_MAX = 600.;\nconst float DST_THRESHOLD = .1;\nconst float CONTINENT_SCALE = 1.;\nconst float CONTINENT_HEIGHT = 9.;\nconst float MOUNTAIN_SCALE = 4.;\nconst float MOUNTAIN_HEIGHT = 50.;\nconst float HILL_SCALE = 6.;\nconst float HILL_HEIGHT = 50.;\n\nconst float ATMO_STEP_MIN = 5.;\nconst float ATMO_THICKNESS = 60.;\n\nvec3[] colors = vec3[] (\n\n        vec3( 1.0, 0.0, 0.0 ), // error color\n        vec3( 0.2, 0.5, 0.2 ), // planet grass color\n        vec3( .0, 0., 1. ),    // water color\n        vec3( 0.5, 1.0, 0.5 ),\n        vec3( 0.5, 0.5, 1.0 ),\n        vec3( 0.5, 1.0, 1.0 ),\n        vec3( 1.0, 0.5, 1.0 ),\n        vec3( 1.0, 1.0, 0.5 )\n);\n\nfloat Pseudo3dNoise(vec3 pos) {\n    return 1.-texture(iChannel0, pos/15.).r*2.;\n}\n\nfloat getNoiseHeight(vec3 vecToPlanet) {\n\n    float ang = atan(vecToPlanet.x / vecToPlanet.z) + iTime/3.;\n    float noise = (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * CONTINENT_SCALE))/CONTINENT_HEIGHT;\n    noise += (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * MOUNTAIN_SCALE))/MOUNTAIN_HEIGHT;\n    noise += (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * HILL_SCALE))/HILL_HEIGHT;\n    \n    return noise;\n}\n\nvec4 colorAndDistanceToScene(vec3 point){\n\n    vec4 retPlanet = vec4(colors[int(planet.a)], 0);\n    vec3 vecToPlanet = planet.xyz - point;\n    float noise = getNoiseHeight(vecToPlanet);\n    float planetRawDst = distance(point, planet.xyz + noise * vecToPlanet) - PLANET_SIZE;\n    retPlanet.a = planetRawDst; // + (Pseudo3dNoise(vec3((point.x)/60. + iTime, point.y/60.,0))*20.);\n    retPlanet.xyz += (distance(point, planet.xyz) - PLANET_SIZE) / 20.;\n    if(abs(vecToPlanet.y) > 150.) {\n        retPlanet.xyz = clamp(retPlanet.xyz + (vec3(1)*((abs(vecToPlanet.y)-150.)/50.)), vec3(0), vec3(1));\n    }\n\n    if((distance(point, planet.xyz) - PLANET_SIZE) / 20. > .5) {\n        retPlanet.xyz = (vec3(1));\n    }\n\n    vec4 retSea = vec4(colors[2], 0);\n    retSea.a = distance(point, planet.xyz) - PLANET_SIZE;\n    \n    retSea.xyz -= planetRawDst / 60.;\n\n    return retPlanet.a < retSea.a ? retPlanet: retSea;\n}\n\nfloat distanceToAtmosphere(vec3 point){\n    return distance(point, planet.xyz) - (PLANET_SIZE + ATMO_THICKNESS);\n}\nconst vec4 vec4Zero = vec4(0); \n\n\nvec2 marchToSun(vec3 uv) {\n    vec3 uv2 = vec3(uv.xy, uv.z - DST_THRESHOLD*4.);\n    float dst = 0.;\n    float dstInAtmo = 0.;\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec4 colAndDist = colorAndDistanceToScene(vec3(uv2 + (sunVector * dst)));\n        float dstToAtmo = distanceToAtmosphere(vec3(uv2 + (sunVector * dst)));\n        if (dstToAtmo < 0.) {\n            dstInAtmo += min(colAndDist.a, ATMO_STEP_MIN);\n            dst += min(colAndDist.a, ATMO_STEP_MIN);\n        } else {\n            dst += dstToAtmo + ATMO_STEP_MIN;\n        }\n        if(dst > DST_MAX) {\n            return vec2(1., dstInAtmo);\n        }\n        \n        if(colAndDist.a < DST_THRESHOLD){\n            return vec2(0., 0);\n        }\n        \n    }\n    \n    return vec2(0, 0);\n}\n\n\nconst float SUN_SCALING = 1.;\nconst vec3 scatterAmmount = vec3(.2, .5, .8);\n\nvec3 atmoDstToColor(vec2 sunInfo, float stepDst) {\n    //return vec3(.529, .808, .922) * stepDst * ;\n    return vec3(\n        ((ATMO_THICKNESS-sunInfo.y/SUN_SCALING*scatterAmmount.r)*(stepDst/300.)/ATMO_THICKNESS) * sunInfo.x,\n        ((ATMO_THICKNESS-sunInfo.y/SUN_SCALING*scatterAmmount.g)*(stepDst/300.)/ATMO_THICKNESS) * sunInfo.x,\n        ((ATMO_THICKNESS-sunInfo.y/SUN_SCALING*scatterAmmount.b)*(stepDst/300.)/ATMO_THICKNESS) * sunInfo.x\n    );\n            \n}\n\nvec3 scatter(vec3 lightFromSun) {\n    //return vec3(.529, .808, .922) * stepDst * ;\n    return lightFromSun * scatterAmmount;\n            \n}\n\nvec4[2] march(vec2 uv) {\n    float dst = 0.;\n    vec3 lightFromAtomsphere = vec3(0);\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec4 colAndDist = colorAndDistanceToScene(vec3(uv, dst));\n        float dstToAtmo = distanceToAtmosphere(vec3(uv, dst));\n        if (dstToAtmo < 0.) {\n            vec2 sunInfo = (marchToSun(vec3(uv, dst)));\n            lightFromAtomsphere += scatter(atmoDstToColor(sunInfo, min(colAndDist.a, ATMO_STEP_MIN)));\n            dst += min(colAndDist.a, ATMO_STEP_MIN);\n        } else {\n            dst += dstToAtmo + ATMO_STEP_MIN;\n        }\n        if(dst > DST_MAX) {\n            return vec4[2](vec4Zero, vec4(i, lightFromAtomsphere));\n        }\n        \n        if(colAndDist.a < DST_THRESHOLD){\n            return vec4[2](vec4(colAndDist.xyz, dst), vec4(i, lightFromAtomsphere));\n        }\n        \n    }\n    \n    return vec4[2](vec4Zero, vec4(100, lightFromAtomsphere));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    planet = vec4(iResolution.xy/2.,300, 1);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - vec2(ivec2(fragCoord)%8);\n    //vec2 uv = fragCoord;\n\n\n    vec4[2] marchInfo = march(uv);\n    vec4 colorAndDist = marchInfo[0],\n        hitInfo = marchInfo[1];\n    //float itrs = clamp(float(hitInfo.x)/float(MARCH_MAX), 0., .5);\n    vec2 sunLightRaw = marchToSun(vec3(uv, colorAndDist.a));\n    //float sunLightPlanet = (colorAndDist.a == DST_MAX ? 0. : sunLightRaw);\n    //float sunLightAtmos =  (((sunLightRaw) *marchToSun(vec3(uv, planet.z - sunVector.z*length(planet.xy-uv)))) / 4. * 3. + .25);\n    // Output to screen\n    fragColor = vec4(clamp(\n    colorAndDist.xyz * atmoDstToColor(sunLightRaw, 300.) + hitInfo.gba,\n    vec3(0,0,0),\n    vec3(1,1,1)\n    ) ,1.0);\n    //fragColor = vec4(vec3(.7, .7, 1) * itrs * sunLightAtmos,1.0);\n    //fragColor = vec4(colorAndDist.aaaa);\n    //fragColor = vec4(colorAndDist.xyz, 0);\n    //fragColor = vec4(hitInfo.gba, 0);\n}","name":"Image","description":"","type":"image"}]}