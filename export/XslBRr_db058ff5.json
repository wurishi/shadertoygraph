{"ver":"0.1","info":{"id":"XslBRr","date":"1494629319","viewed":203,"name":"Torus : Spiral","username":"JCDjcd","description":"A spiral on a torus.\n(Cocorico!)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["torus","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n#define torus_R \t\t0.6\n#define torus_r \t\t0.5\n\n//--------------------------------------------------------------------------\n// complex multiplication (ax + i*ay) * (bx + i*by)\nvec2 complex_mul(vec2 a,vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n} // complex_mul()\n\n//--------------------------------------------------------------------------\n// square root\nvec2 complex_sqrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return sqrt(sqrt(r2))*vec2(cos(0.5*theta),sin(0.5*theta));\n} // complex_sqrt()\n\n//--------------------------------------------------------------------------\n// cubic root\nvec2 complex_cbrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return pow(r2,1.0/6.0)*vec2(cos(theta/3.0),sin(theta/3.0));\n} // complex_cbrt()\n\n//--------------------------------------------------------------------------\nvec2 complex_conj(vec2 z)\n{\n    return vec2(z.x,-z.y);\n} // complex_conj()\n\n//--------------------------------------------------------------------------\n// solve the equation A*u^3 + B*u^2 + C*u + D = 0\nvoid solve3(float A,float B,float C,float D,out vec2 u1,out vec2 u2,out vec2 u3)\n{\n    // First step consists on shifting u = v-B/(3*A)\n    // in order to write the equation v^3 + p*v + q = 0\n    // (no second term)\n    float p \t= (-B*B/(3.0*A)+C)/A;\n    float q \t= (2.0*B*B*B/(27.0*A*A)-B*C/(3.0*A)+D)/A;\n\n    float delta = q*q/4.0+p*p*p/27.0;\n    vec2 j  \t= vec2(cos(TWOPI/3.0),sin(TWOPI/3.0)); // j^3=1\n    vec2 j2 \t= complex_conj(j);\n    \n    if(delta < 0.0) // three real roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q,0.0)+complex_sqrt(vec2(delta,0.0)));\n\t\tu1 \t\t= vec2(2.0*(\t\t\t\tx).x\t,0.0);\n\t\tu2 \t\t= vec2(2.0*(complex_mul(j,\tx)).x\t,0.0);\n\t\tu3 \t\t= vec2(2.0*(complex_mul(j2,\tx)).x\t,0.0);\n    }\n    else if(delta > 0.0) // one real root and two (conjugated) complex roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q+sqrt(delta),0.0));\n        vec2 y  = -p/3.0*complex_conj(x)/dot(x,x);\n        u1 \t\t= \t\t\t\t\tx\t+\t\t\t\t\ty\t;\n        u2 \t\t= complex_mul(j,\tx)\t+\tcomplex_mul(j2,\ty)\t;\n        u3 \t\t= complex_mul(j2,\tx)\t+\tcomplex_mul(j,\ty)\t;\n    }\n    else // trivial cases\n    {\n        if(0.0 == p && 0.0 == q)\n        {\n            u1 \t= vec2(0.0,0.0);\n            u2 \t= vec2(0.0,0.0);\n            u3 \t= vec2(0.0,0.0);\n        }\n        else\n        {\n            u1 \t= vec2( 3.0*q/p,0.0);\n            u2 \t= vec2(-1.5*q/p,0.0);\n            u3 \t= vec2(-1.5*q/p,0.0);\n        }\n    }\n    \n    // From v to u:\n    u1.x -= B/(3.0*A);\n    u2.x -= B/(3.0*A);\n    u3.x -= B/(3.0*A);\n\n} // solve3()\n\n\n//--------------------------------------------------------------------------\n// solve the equation a*u^3 + b*u^2 + c*u + d = 0\nvoid solve4(float A,float B,float C,float D,float E,out vec2 t1,out vec2 t2,out vec2 t3,out vec2 t4)\n{\n    // We need to find the roots of the polynomial of degree 4.\n    // First step consists on shifting t = s - B/(4.0*A) such that\n    // s^4 + p*s^2 + q*s + r = 0 (no cubic terms)\n    float p = (-3.0*B*B/(8.0*A)+C)/A;\n    float q = (B*B*B/(8.0*A*A)-B*C/(2.0*A)+D)/A;\n    float r = (-3.0*B*B*B*B/(256.0*A*A*A)+B*B*C/(16.0*A*A)-B*D/(4.0*A)+E)/A;\n\n    // Now we must solve u^3 + 2*p*u^2 + (p^2-4*r)*u - q^2 = 0\n\tvec2 u1,u2,u3;\n    solve3(1.0,2.0*p,p*p-4.0*r,-q*q,u1,u2,u3);\n    \n    // Before finalizing, we need to compute the square root of u1, u2, and u3\n    // such that sqrt(u1)*sqrt(u2)*sqrt(u3) = -s\n    vec2 v1 = complex_sqrt(u1);\n    vec2 v2 = complex_sqrt(u2);\n    vec2 v3 = complex_sqrt(u3);\n    if(complex_mul(v1,complex_mul(v2,v3)).x*q > 0.0)\n    {\n        v3 = -v3; // take the other square root of u3\n    }\n    \n    // We finally got our four roots:\n    t1 = 0.5*( v1+v2+v3);\n    t2 = 0.5*( v1-v2-v3);\n    t3 = 0.5*(-v1+v2-v3);\n    t4 = 0.5*(-v1-v2+v3);\n    \n    // From s to t:\n    t1.x -= B/(4.0*A);\n    t2.x -= B/(4.0*A);\n    t3.x -= B/(4.0*A);\n    t4.x -= B/(4.0*A);\n\n} // solve4()\n\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t) = P + t.d\nvec4 compute(vec3 P,vec3 d)\n{\n    // Parametrization of the torus by phi and theta angles.\n    // x = (R+r*cos(theta))*cos(phi)\n    // y = (R+r*cos(theta))*sin(phi)\n    // z = r*sin(theta)\n    \n    // U*t^2 + V*t + W = 2*r*R*cos(theta)\n\tfloat U = dot(d,d);\n    float V = 2.0*dot(P,d);\n    float W = dot(P,P) - (torus_R*torus_R+torus_r*torus_r);\n    \n    // A*t^4 + B*t^3 + C*t^2 + D*t + E = 0\n    float A = U*U;\n    float B = 2.0*U*V;\n    float C = V*V + 2.0*U*W + 4.0*torus_R*torus_R*d.z*d.z;\n    float D = 2.0*V*W + 8.0*torus_R*torus_R*P.z*d.z;\n    float E = W*W + 4.0*torus_R*torus_R*(P.z*P.z-torus_r*torus_r);\n\n    vec2 t[4]; // complex roots\n    solve4(A,B,C,D,E,t[0],t[1],t[2],t[3]);\n\n    float sorted_t[4];\n    int   nb_intersection = 0;\n    for(int i=0;i<4;i++)\n    {\n        if(abs(t[i].y)<0.005) // if the root is real, we got an intersection\n        {\n            nb_intersection ++;\n            sorted_t[nb_intersection-1] = t[i].x;\n            for(int j=nb_intersection-2;j>=0;j--)\n            {\n                if(sorted_t[j] > sorted_t[j+1])\n                {\n                    float tmp \t\t= sorted_t[j];\n                    sorted_t[j] \t= sorted_t[j+1];\n                    sorted_t[j+1] \t= tmp;\n                }\n            } // for()\n        }\n    } // for()\n    \n    // colorization\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    for(int i=0;i<nb_intersection;i++)\n    {\n        vec3 \tM \t\t= P+sorted_t[i]*d;\n        float \tphi \t= atan(M.y,M.x);\n        float   theta   = atan(M.z,sqrt(M.x*M.x+M.y*M.y)-torus_R);\n        \n        float a = 5.0*phi+15.0*theta+iTime*TWOPI/0.75;\n        // make sure the angle is between 0 and 2.pi\n\t\ta = mod(TWOPI+mod(a,TWOPI),TWOPI);\n        \n        vec4 c;\n        if(a < TWOPI/6.0)\n            c = vec4(1.0,0.0,0.0,1.0);\n        else if(a < 2.*TWOPI/6.0)\n            c = vec4(1.0,1.0,1.0,1.0);\n        else if(a < 3.*TWOPI/6.0)\n            c = vec4(0.0,0.0,1.0,1.0);\n        else\n            continue; // be transparent\n            \n        color = c;\n        break; // don't do translucidity\n    } // for()\n    \n    \n    return vec4(color.rgb,1.0);\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= ((fragCoord.xy - 0.5*iResolution.xy) / m)*1.6;\n    vec3 P \t\t\t= vec3(uv,-5.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    \n    float alpha1\t= TWOPI*0.2;\n    float alpha2\t= TWOPI*0.2;\n    P.xy\t\t   *= ROTATION(alpha2);\n    P.zx\t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n\t\n\tfragColor \t\t= compute(P,d);\n\n} // mainImage()\n\n","name":"Image","description":"","type":"image"}]}