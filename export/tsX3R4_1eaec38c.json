{"ver":"0.1","info":{"id":"tsX3R4","date":"1545116359","viewed":110,"name":"menger city","username":"DarkWyvren","description":"interact with mouse","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["personal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float EPSILON = 0.005;\nconst int max_iter = 230;\nconst float MAXDIST = 900.0;\nconst float PI = 3.141592;\nconst int Mlevel = \t4\n    ;\n\nfloat k = 0.1;\nfloat rot = 0.1;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\nfloat sphereSDF(vec3 pos, float r){\n\treturn length(pos)-r;\n}\nfloat boxSDF( vec3 pos, vec3 bounds )\n{\n  vec3 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat boxSDF( vec2 pos, vec2 bounds )\n{\n  vec2 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,d.y),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat roundEdge(float sdf,float rad){\n\treturn sdf+rad;\n}\n\nfloat sub(float sdf,float sdf2){\n\treturn max(-sdf,sdf2);\n}\nfloat Ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat add(float sdf,float sdf2){\n\treturn min(sdf,sdf2);\n}\nfloat Sadd(float sdf,float sdf2){\n\treturn smin(sdf,sdf2,k);\n}\n\nvec3 opRep( in vec3 p, in vec3 peroid)\n{\n    vec3 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\nvec2 opRep( in vec2 p, in vec2 peroid)\n{\n    vec2 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\n\nfloat getcrossSDFSUB(vec3 pos,vec3 offset, float scale, int level,float prevsdf){\n    if(level==0){\n    \treturn prevsdf;\n    }\n    pos-=offset;\n\tprevsdf = Sadd(boxSDF(pos.xy,vec2(1.0,1.0)/scale),prevsdf);\n    prevsdf = Sadd(boxSDF(pos.xz,vec2(1.0,1.0)/scale),prevsdf);\n    prevsdf = Sadd(boxSDF(pos.yz,vec2(1.0,1.0)/scale),prevsdf);\n    \n    \n    //prevsdf = Sadd(getcrossSDFSUB(pos*3.0,vec3(-1.0,-1.0,-1.0)*scale,scale/3.0,level-1,prevsdf)/3.0,prevsdf);\n    \n    return prevsdf;\n    \n}\n\nfloat getcrossSDF(vec3 pos, float scale\t){\n    vec3 opos = pos;\n\tfloat sdf = 999999999.0;\n    for(int i = 0;i<Mlevel;i++){\n        float factor = pow(3.0,float(i));\n        float gap = 6.0;\n       \n    \tsdf = add(getcrossSDFSUB(opRep(pos*factor,vec3(gap)),vec3(0.0,0.0,0.0),scale,Mlevel,sdf)/factor,sdf);\n        pos = (rotationMatrix(normalize(vec3(1.,1.,1.)),rot)*vec4(pos,1.0)).xyz;\n    }\n    //return sdf;\n    float biggening = texture(iChannel2,mod(round(opos.xy*0.1)/(256.0),1.0)).x;\n    sdf = Ssub(sdf,boxSDF(vec3(opRep(opos.xy,vec2(10.0,10.0)),opos.z),vec3(scale*3.0)+vec3(0.0,0.0,biggening*25.0)),k);\n    sdf = add(sdf,-opos.z+15.0);\n    return sdf;\n}\n\n\n\nvec3 getNormal(vec3 pos, float scale){\n\treturn normalize(vec3(getcrossSDF(pos+vec3(EPSILON,0,0),scale)-getcrossSDF(pos-vec3(EPSILON,0,0),scale),  \n               \tgetcrossSDF(pos+vec3(0,EPSILON,0),scale)-getcrossSDF(pos-vec3(0,EPSILON,0),scale),  \n                getcrossSDF(pos+vec3(0,0,EPSILON),scale)-getcrossSDF(pos-vec3(0,0,EPSILON),scale)  \n               ));\n}\n\nfloat getLightIntense(vec3 normal,vec3 lightdir,vec3 viewdir,float spec,float expo,float diff){\n\tvec3 ref = reflect(viewdir,normal);\n    return spec*pow(clamp(dot(ref,lightdir),0.0,1.0),expo) + max(0.0,dot(normal,lightdir)*diff);\n}\n\n\nfloat constDIV = 0.6;\n\nfloat getDist(vec3 rayPos, vec3 raydir){\n    float totalDist = 0.0;\n    float sdfRN = 0.0;\n\tfor(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        rayPos += sdfRN*raydir;\n        totalDist += sdfRN;\n        if(sdfRN<EPSILON*2.0){\n            return totalDist;\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return float(MAXDIST);\n        \tbreak;\n        }\n    }\n    return float(MAXDIST);\n\n}\n\nvec2 getClosestDist(vec3 rayPos, vec3 raydir){\n    \n    float ph = 1e20;\n    float  k =64.0;\n    \n    float closest = MAXDIST;\n    float totalDist = 0.0;\n    float res = 1.0;\n    float prevSDF = 0.;\n    float sdfRN = 0.;\n\tfor(int i = 0;i<max_iter;i++){\n        prevSDF = sdfRN;\n    \tsdfRN = getcrossSDF(rayPos,1.0)*constDIV;\n        closest = min(sdfRN,closest);\n        rayPos += sdfRN*raydir;\n        totalDist += sdfRN;\n        \n        \n        float y = sdfRN*sdfRN/(2.0*ph);\n        float d = sqrt(sdfRN*sdfRN-y*y);\n            \n        res = min(res, k*d/max(0.0,totalDist-y) );\n        \n        \n        if(sdfRN<EPSILON*2.0 && prevSDF>sdfRN){\n            return vec2(0,res);\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return vec2(closest,res);\n        \tbreak;\n        }\n    }\n    return vec2(closest,res);\n\n}\n\nvec4 getBG(vec3 dir){\n    return vec4(texture(iChannel0,dir).xyz,1.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    k = iMouse.x/iResolution.x + 0.0;\n    rot = iMouse.y/iResolution.y-0.5;\n    \n    k += sin(iTime*0.01)*0.2;\n    rot += cos(iTime*0.01)*0.2;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col;\n    vec3 camray ;\n     vec3 rayPos;\n    vec3 raydir;\n    if(mod(iTime,10.0)<5.0){\n        vec2 uv = 1.0*(fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5));\n\n        col = vec3(1.0);\n        \n        //uv.y = 1.0-uv.y;\n\n        camray = normalize(vec3(uv,-1.0+pow(length(uv),2.0)));\n        ;\n        ;\n        float k = 2.15/4.0;\n        float r = sin(2.0*PI*iTime/k + PI)*0.18*k+iTime;\n        vec3 off = vec3(0.9*r,2.1*r,0.0);\n        //camray = normalize((rotationMatrix(vec3(0,1,0),uv.x) * vec4(camray, 0.0)).xyz);\n        //camray = normalize((rotationMatrix(vec3(1,0,0),uv.y) * vec4(camray, 0.0)).xyz);\n        vec3 lookPos = vec3(0,0,0);//vec3(15.0*sin(iTime),-20.0*cos(0.25*iTime)*sin(iTime),0);\n        rayPos = vec3(0.,0.,-18.)+off;\n\t\t\n        mat4 camProj  = viewMatrix(rayPos, lookPos+off,vec3(0,1,0));\n        raydir = normalize((camProj * vec4(camray, 0.0)).xyz);\n        \n        \n    }else{\n    \tvec2 uv = 1.0*(fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5));\n\n        col = vec3(1.0);\n        \n        //uv.y = 1.0-uv.y;\n\n        camray = normalize(vec3(-1.0,uv.xy));\n       \n        vec3 off = vec3(0.0*iTime,2.1*iTime,0.0);\n        //camray = normalize((rotationMatrix(vec3(0,1,0),uv.x) * vec4(camray, 0.0)).xyz);\n        //camray = normalize((rotationMatrix(vec3(1,0,0),uv.y) * vec4(camray, 0.0)).xyz);\n        vec3 lookPos = vec3(0,0,0);//vec3(15.0*sin(iTime),-20.0*cos(0.25*iTime)*sin(iTime),0);\n        rayPos = vec3(1.0,0.,-18.)+off;\n\t\t\n        mat4 camProj  = viewMatrix(rayPos, lookPos+off,vec3(0,1,0));\n        raydir = normalize((camProj * vec4(camray, 0.0)).xyz);\n        \n    \n    }\n    // Time varying pixel color\n    \n    float cast1 = getDist(rayPos,raydir);\n    if(cast1>MAXDIST-EPSILON*2.0){\n    \tfragColor = getBG(raydir); //inital cast\n    }else{\n    \tvec3 norm= getNormal(rayPos+raydir*cast1, 1.0);\n        vec3 ref = reflect(raydir,norm);\n        vec3 surPos = rayPos+raydir*(cast1-EPSILON*5.0);\n        fragColor = vec4(vec3(0.0),1.0);\n        \n       // if(getDist(surPos,ref)>MAXDIST-EPSILON){\n       // \tfragColor += vec4(texture(iChannel0,ref).xyz*0.5,1.0); //reflection\n        //}\n        vec3 lightdir = normalize(vec3(0.3,0.4,-1));\n        vec2 shadowOut = getClosestDist(surPos ,lightdir);\n        float h = shadowOut.x;\n        if(h>EPSILON){\n            \n            \n        \tfragColor += shadowOut.y*getLightIntense(norm, lightdir,raydir,1.0,40.0,0.5  ); //shadow\n        }\n        float lightZ = -10.0+25.0*texture(iChannel2,mod(round(surPos.xy*0.1)/(256.0),1.0)).x;\n        fragColor += 1.0/abs(lightZ-surPos.z) * vec4(1.0,0.9,0.8,1.0);\n        fragColor = mix(fragColor,getBG(raydir),clamp(cast1*0.01,0.0,1.0));\n    }\n   //\n    \n\n    // Output to screen\n    \n}\n\n\n","name":"Image","description":"","type":"image"}]}