{"ver":"0.1","info":{"id":"4cBBDR","date":"1725882214","viewed":37,"name":"mySphere ray tracing","username":"boblareleve","description":".","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define LENGHT(a) sqrt((a).x * (a).x + (a).z * (a).z + (a).y * (a).y)\n#define PI 3.14159265358979323846\n#define remap(a, b, f) ( ((f)-(a)) / ((b)-(a)) )\n#define FLT_MAX 3.402823466e+38\n#define time (iTime/6.)\n#define VOID_COLOR vec3(0.)\n\nstruct sphereData \n{\n    vec3 origin;\n    vec3 v1;\n    vec3 v2;\n};\nstruct vec32\n{\n    vec3 a, b;\n};\nstruct rayres\n{\n    vec3 a, b;\n    int index;\n};\n\n\n\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// give intersection point sphere/ray\nvec32 sphere(vec3 rayO, vec3 rayD, sphereData obj) //, vec3 lightSource)\n{\n    float k = dot(obj.origin - rayO, rayD);\n    vec3  p = rayO + k * rayD;\n    float y = distance(obj.origin, p);\n    float r = length(obj.v1);\n    \n    \n    if (y < r && k > 0.)\n    {\n        float x = sqrt(r*r - y*y);\n        float k1 = k-x;\n        float k2 = k+x;\n\n        // float d = dot(lightSource, k2*rayD+rayO - so) ;//remap(so.z, so.z - r, dot(lightSource, -so+k2*rayD))/4.;\n        vec3 tmp1 = k1*rayD + rayO;\n        vec3 tmp2 = k2*rayD + rayO;\n        vec3 tmp = (distance(rayO, tmp1) > distance(rayO, tmp2) ? tmp2 : tmp1);\n        return vec32(tmp - rayO, tmp    -obj.origin);\n    }            //  .a relatif à la cam .b relatif à l'origine\n    return vec32(vec3(.5),vec3(.5));\n}\n\nmat3 getRotMatrix(vec3 angles)\n{\n    return\n    \n    mat3(1, 0,             0,\n         0, cos(angles.x), -sin(angles.x),\n         0, sin(angles.x), cos(angles.x))\n         *\n    mat3(cos(angles.y), -sin(angles.y),  0.,\n         sin(angles.y), cos(angles.y), 0.,\n         0,             0,              1.)\n         *\n    mat3(cos(angles.z), 0., sin(angles.z),\n         0.,            1., 0.,\n         -sin(angles.z),0., cos(angles.z));                          \n}\n\n/*vec4 getSphereTexture(vec3 p)\n{\n    return (texture(iChannel0, vec2(p.x)));\n}*/\n\n#define N 10\n#define Nf float(N)\n// draw N Spheres\nrayres drawSpheres(vec3 ro, vec3 rd, sphereData objs[N])\n{\n    rayres nearest = rayres(vec3(FLT_MAX), vec3(FLT_MAX), 0); // stack\n    float nearestDis = distance(nearest.a, ro);\n\n    for (int i = 0; i < N; i++)\n    {\n        vec32 pp = sphere(ro, rd, objs[i]);\n        rayres tmp = rayres(pp.a, pp.b, i);\n        float tmpDis = distance(tmp.a, ro);\n        if (tmp.a != vec3(.5) && tmpDis < nearestDis)\n        {\n            nearestDis = tmpDis;\n            nearest = tmp;\n        }\n    }\n    return (nearest);\n}\n\n// index -> hole sphere\nsphereData makeSphere(int i)\n{\n    return sphereData(\n        vec3(sin(2.*PI*mod(float(i)+time*1.5,Nf) / Nf)*1., \n             cos(2.*PI*mod(float(i)+time*1.5,Nf) / Nf)*1., \n             0.), \n        vec3(1.,0.,0.),\n        vec3(1.,0.,0.) // for later\n    );\n}\n\nvec3 getBgColor(vec3 rayD)\n{\n    return (//texture(iChannel0, rayD.xyz*10.).xyz);\n        texture(iChannel0, rayD.xyz*5.).x > .1 ?\n             VOID_COLOR : vec3(1.)\n        //rand(rayD.xy) < .995 \n          //  ? VOID_COLOR : vec3(mix(rand(vec2(iTime)*rayD.xy), rand(rayD.xy), 0.5))\n            //? VOID_COLOR : vec3(mix(rand(vec2(iTime)*uv), rand(uv), 0.5))\n    );\n}\n\nvec3 bounceSphere(vec3 rayIn, rayres res, sphereData[N] ss)\n{\n    vec3 n = normalize(res.b - ss[res.index].origin);\n    \n    // vec3 rayout = 2.*(rayIn + dot(-rayIn, n)*n) + rayIn;\n    \n    rayres result = drawSpheres(n, res.b, ss);\n    //if (result.b == vec3(FLT_MAX))\n      //  return (vec3(FLT_MAX));\n        \n    return (result.b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col;\n    \n    \n    vec3 lightSource = normalize(vec3(-0.5, 0., 0.));\n    lightSource = normalize(vec3(-1., -4., -1.));\n\n    float rayonCamPos = 10.;\n    vec3 camPos = vec3(0., -rayonCamPos*sin(time), -rayonCamPos*cos(time));\n    //camPos = vec3(.0, sin(iTime), -30.);\n    vec3 camDir = vec3(mod(time,  2.*PI), 0., .0);\n    //camDir = vec3(0., 0., sin(iTime));\n    //camDir = vec3(0., PI/2.1, 0.);//, 0., -sin(iTime));\n    \n    \n    \n    mat3 rotMatrix = getRotMatrix(camDir);\n    vec3 rayD = normalize(rotMatrix * vec3(uv, 1.));\n    vec3 rayO = camPos;\n   \n    sphereData ss[N];\n    for (int i = 0; i < N; i++)\n        ss[i] = makeSphere(i);\n\n    rayres s = drawSpheres(rayO, rayD, ss);\n    if (s.b == vec3(FLT_MAX))\n        col = getBgColor(rayD);\n    else \n    {\n        vec3 bounce1 = bounceSphere(rayD, s, ss);\n        if (bounce1 != vec3(FLT_MAX))\n            col = VOID_COLOR;//mix(s.b, bounce1, .5);\n        else col = abs(s.b);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}