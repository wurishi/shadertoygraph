{"ver":"0.1","info":{"id":"cdVcRV","date":"1696412212","viewed":52,"name":"ringsdtd","username":"bailesdtd","description":"dirty code","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"cdVyzK","parentname":"Fork cubetube bailesdtd 084"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float GAMMA = 2.2;\nconst vec3 UP = vec3(0.0,1.0,0.0);\n\nstruct Light {\n    float str;\n    vec3 diff;\n    vec3 spec;\n    vec3 dir;\n};\n\nvec2 smin2( in float a, in float b, in float k )\n{\n    float f1 = exp2( -k*a );\n    float f2 = exp2( -k*b );\n    return vec2(-log2(f1+f2)/k,f2);\n}\nfloat smin( in float a, in float b, in float k )\n{\n    float f1 = exp2( -k*a );\n    float f2 = exp2( -k*b );\n    return -log2(f1+f2)/k;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 map(vec3 p) {\n    float rings = 5.0;\n    float k = 0.5;\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    vec3 c1 = vec3(1,0,0);\n    vec3 q = p.xzy;\n    vec2 dmin = vec2(1e10,0.0);\n    for(float i = rings; i > 0.0; i--) {\n        q.xy = mat2(cos(k*iTime),-sin(k*iTime), sin(k*iTime), cos(k*iTime)) * q.xy;\n        float r1 = i/rings;\n        float r2 = 1.0/(rings*2.0);\n        r1 -= r2;\n        dmin = smin2(sdTorus(q.xyz-vec3(1,0,0), vec2(r1,r2)), dmin.x,30.0);\n        col += vec4(palette(r1+iTime*0.1, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67)\n                                     )*dmin.y,dmin.y);\n    }\n    col.xyz /= col.w;\n    return vec4(col.xyz,dmin);\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 norm( in vec3 p )\n{\n#if 0    \n    float e = 0.00001;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return -normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001).w;\n    }\n    return -normalize(n);\n#endif    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + rd*t).w;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat inverse_lerp(float a, float b, float v){\n    return (v-a) / (b-a);\n}\n\nvec3 lighting(vec3 p, vec3 ro, vec3 col) {\n    float ks = 0.3;\n    vec3 kd = col;\n    float ka = 0.001;\n    float a = 100.0;\n    const int n_lights = 3;\n    Light lights[n_lights] = Light[n_lights](\n        Light(\n            1.0,\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            normalize(vec3(-0.6, -0.5, 0.4))\n        ),\n        Light(\n            1.0,\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            normalize(vec3(0.6, -0.5, 0.4))\n        ),\n        Light(\n            1.0,\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 0.9, 1.0),\n            normalize(vec3(-0.6, -0.5, -0.4))\n        )\n    );\n    float sh = 0.0;\n    vec3 am = vec3(0.0,0.0,0.0);\n    vec3 I = vec3(0.0);\n    vec3 n = -norm(p);\n    vec3 v = normalize(ro - p);\n    for (int i = 0; i < n_lights; i++) {\n        vec3 l = -lights[i].dir;\n        vec3 s = lights[i].spec*lights[i].str;\n        vec3 d = lights[i].diff*lights[i].str;\n        vec3 r = 2.0 * dot(l, n) * n - l;\n        am += d / float(n_lights);\n        sh = softshadow(p, l, 0.1, 16.0, 32.0);\n        I += sh * (kd * max(0.0, dot(l, n)) * d + ks * pow(max(0.0, dot(r, v)), a) * s);\n    }\n    float t = clamp(inverse_lerp(15.0, 30.0, length(p)),0.0,1.0);\n    return mix(I + am * ka, vec3(0,0,0), t);\n    //vec3(0.714,0.827,0.937)\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    float s = 0.0;\n    const int N = 256;\n    const float MIN = 0.001;\n    const float MAX = 100.0;\n    vec3 p = vec3(0.0);\n    for (int i = 0; i < N; ++i) {\n        p = ro + s * rd;\n        vec4 d = map(p);\n        if (d.w < MIN) {\n             return lighting(p, ro,d.rgb);\n         }\n        if (s > MAX) {\n             break;\n         }\n         s += d.w;\n     }\n    return lighting(p, ro, vec3(0,0,0));\n }\nvec3 dir(vec2 uv) {\n     return normalize(vec3(uv, 1.0));\n}\n\nvec3 col(vec2 uv) {\n     float l = 0.7;\n     vec3 ro = vec3(l*uv,-2.5);\n     vec3 rd = dir(uv-l*uv);\n     vec3 c = march(ro, rd);\n     return c;\n }\n \n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n     vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n     vec3 c = col(uv);\n     //c = pow(c, vec3(1));\n     c = clamp(c,0.0,1.0);\n     c = rgb2hsv(c);\n     c.y *= 1.4;\n     c.z *= 0.8;\n     c = hsv2rgb(c);\n     c = gamma(c, 1.0/GAMMA);\n     vec3 c2 = palette(abs(uv.x), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n     fragColor = vec4(c, 1.0);\n }","name":"Image","description":"","type":"image"}]}