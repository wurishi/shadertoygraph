{"ver":"0.1","info":{"id":"3t23Wc","date":"1561385837","viewed":162,"name":"Basic blobs","username":"Naiw","description":"Playing around with sphere tracing.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nJust playing around.\n*/\n\nfloat sphere(vec3 pos, vec3 sp, float radius) \n{\n    return length(sp-pos)-radius;\n}\n\nfloat blend(float a, float b, float alpha) {\n\tfloat ramp = clamp(0.5+0.5*(b-a)/alpha,0.,1.0);\n    return mix(b,a,ramp)-alpha*ramp*(1.-ramp);\n}\n\nfloat distanceFunction(vec3 pos) {\n    float td = 100.0;\n    for(int i=10;i<30;i+=2) {\n        float ip = float(i)/50.0;\n        vec3 newP = vec3(pos.y,pos.y,pos.z);\n\t    td = blend(td,\n         sphere(newP,vec3(sin(ip)*.5-cos(iTime*ip+sin(ip)),cos(ip)*.5+sin(iTime*ip+cos(ip)),4.0),0.2),0.3);\n    }    \n    for(int i=11;i<30;i+=2) {\n        float ip = float(i)/50.0;\n        vec3 newP = vec3(pos.x,pos.x,pos.z);\n\t    td = blend(td,\n         sphere(newP,vec3(sin(ip)*.5-cos(iTime*ip+sin(ip)),cos(ip)*.5+sin(iTime*ip+cos(ip)),4.0),0.2),0.3);\n    }    \n    for(int i=1;i<30;i++) {\n        float ip = float(i)/50.0;\n\t    td = blend(td,\n         sphere(pos,vec3(sin(ip)*.5-cos(iTime*ip+sin(ip)),cos(ip)*.5+sin(iTime*ip+cos(ip)),4.0),0.2),0.3);\n    }    \n    return td;\n}\n\nstruct traceResult {\n\tfloat total_dist;\n    float dist;\n    vec3 position;\n};\n\n\nfloat trace(vec3 ro, vec3 rd) {\n\tfloat d = 0.0;\n    float td = 0.0;\n    vec3 rp;\n    for(int x=0;x<20;x++) {\n\t\trp = ro + rd * d;\n        td = distanceFunction(rp);\n        if(td < 0.001) {\n            break;\n        } else if(td > 10.0) {\n            return 0.;\n        }\n        d += td;\n    }\n    \n    traceResult tr = traceResult(d, td, rp);\n    vec3 light = vec3(sin(-iTime*.5)*10.,cos(iTime*.6)*10.,-4.);\n    vec3 l = normalize(light - tr.position);\n    vec2 e = vec2(0.01,0);\n    vec3 n = normalize(tr.dist - vec3(distanceFunction(tr.position-e.xyy),\n                            distanceFunction(tr.position-e.yxy),\n                            distanceFunction(tr.position-e.yyx)));\n    return clamp(dot(n,l),0.,1.);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,0,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    \n    float color = trace(ro, rd);\n    \n    vec3 col = vec3(color);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}