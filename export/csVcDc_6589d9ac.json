{"ver":"0.1","info":{"id":"csVcDc","date":"1696696817","viewed":66,"name":"Twisted Columns (with notes)","username":"reast","description":"Forked to include personal notes.\nBased on Flyguy's \"Ring Teister\" [url=https://www.shadertoy.com/view/Xt23z3]Xt23z3[/url]. I didn't write this effect since around 1999. Only now it's antialiased, motion blurred, texture filtered and high resolution.","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["2d","twist","columns"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Fork of \"Twisted Columns\" by iq. https://shadertoy.com/view/Xl2GRc\n// 2023-10-07 16:39:29\n// Forked in order to add personal notes for learning purposes.\n// Removed the original code comments and commented out lines for simplicity.\n// Recommend starting reading at mainImage(...) method.\n\n// Original header comment:\n//    // Created by inigo quilez - iq/2015\n//    // https://www.youtube.com/c/InigoQuilez\n//    // https://iquilezles.org/\n//\n//    // Based on Flyguy's \"Ring Teister\" https://www.shadertoy.com/view/Xt23z3. I didn't write \n//    // this effect since around 1999. Only now it's antialiased, motion blurred, texture \n//    // filtered and high resolution.\n\n\n// Function to generate the color for a specific segment for the current pixel.\n//   float x0 - Starting point in radians of the curent segment.\n//   float x1 - Ending point in radians of the current segment.\n//   vec2 uv - Polar coordinates of the current pixel, but with x coordinate (distance) wrapped from -1 to 1.\n//   float id - Integer value that is roughly half the total radial distance of the current pixel.\n//   float time - Current iTime value.\n//   float f - Can be thought of as the fraction of the current segment divided by the final segment.\n//             So first segment is 1/5, third segment is 3/5, last segment is 5/5.\nvec4 segment( float x0, float x1, vec2 uv, float id, float time, float f )\n{\n    // Distance of the current pixel as a percent of the total segment width.\n    float u = (uv.x - x0)/(x1 - x0);\n    \n    // Float used to apply rotational visual movement to the face of each segment.\n    float v = 0.;\n    \n    // Add the polar coordinate angle converted to fall between -2 and 2.\n    v += 2.0*uv.y/3.141593;\n    \n    // Add the fraction of the current segment * 2.0 (falls between 0 and 2).\n    v += f*2.0;\n    \n    // Add adjustment for time to apply a rotation effect.\n    // Higher id means further from origin, so rotating faster.\n    v += -1.0*(id + 0.5)*time;\n    \n    // Size in radians of the current segment.\n    float w = (x1 - x0);\n    \n    // Sample texture to get initial coloring.\n    vec3 col = texture( iChannel0, vec2(u,v) ).xyz;\n    \n    // Modify coloring based on combination of segment piece and distance from origin.\n    col += 0.3*sin( 2.0*f + 2.0*id + vec3(0.0,1.0,2.0) );\n\n    // Add dark spot pattern on 2 specific faces (face 2 out of 5 and face 4 out of 5).\n    col *= mix( 1.0, smoothstep(-0.8,-0.7, sin(80.0*v)*sin(20.0*u) ), smoothstep(0.4,0.5,sin(f*17.0)) );\n    \n    // Turns any pixels located less than 1% of the distance to the segment edge black (color is multiplied by 0).\n    // Turns pixels located within 1% to 3% of the distance to the segment edge a color between grey and black.\n    // All other pixels remain their existing color.\n    col *= smoothstep( 0.01, 0.03, 0.5-abs(u-0.5) );\n    \n    // Add colored lighting.\n    col *= vec3(0.0,0.1,0.3) + w*vec3(1.1,0.7,0.4);\n    \n    // Add shadowed lighting.\n    col *= mix(1.0-u,1.0,w*w*w*0.45);\n\n    // Logic to pass color back with a weight.\n    // Only segment colors where the segment end point is greater than the segment start point\n    // are given a weight (see: step(x0, x1)).\n    // Pixels falling near the edge of a segment are given a partial weight which results in a\n    // shadow effect (see: smoothstep( 0.5,0.5+0.02/w, abs(u-0.5)).\n    float edge = 1.0-smoothstep( 0.5,0.5+0.02/w, abs(u-0.5) );\n    return vec4(col, edge * step(x0,x1));\n}\n\n// Number of supersampling samples to take.\n// Higher number means smoother frames but higher computational cost.\nconst int numSamples = 6;\n\n// Shader main function.\n// Function is called once per viewport pixel per rendered frame.\n//   vec2 fragCoord - Pixel coordinate within the viewport where (0,0) is the top left pixel.\n//   out vec4 fragColor - Output variable for the pixel color as calculated by the shader execution.\n//                        Vector is in (r,g,b,a) format where each value is between 0.0 and 1.0 (inclusive).\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // EX: say fragCoord = (80,360)\n    //     say iResolution = (1280,720,0)\n    \n    // Get world space coordinate to render for the current pixel. \n    // The viewport's center pixel ends up as world coordinate 0,0.\n    vec2 uv = (-iResolution.xy+2.0*fragCoord.xy) / max(iResolution.x,iResolution.y);\n\n    // EX: uv = ((-1280, -720) + 2 * (80, 360)) / max(1280,720)\n    // EX: uv = ((-1280, -720) + (160, 720)) / 1280\n    // EX: uv = (-1120,0) / 1280\n    // EX: uv = (-0.875,0)\n\n    // Multiply world space coordinate so that more of the world is shown in the viewport.\n    uv *= 5.0;\n    \n    // EX: uv = (-4.375,0)\n    \n    // Get the polar coordinate of the current pixel.\n    vec2 st = vec2( length(uv), atan(uv.y, uv.x) );\n    \n    // EX: st = len((-4.375,0), atan(0, -4.375))\n    // EX: st = (-4.375, -1.57) \n    //      ie. (-4.375, -pi/2)\n    \n    // Get an integeter value of half the radial distance to be used for coloring and rotational velocity\n    float id = floor((st.x)/2.0);\n\n    // EX: id = floor(-4.375/2.0)\n    // EX: id = floor(-2.1875)\n    // EX: id = -3\n    \n    // Initialize final output color for pixel.\n    vec3 tot = vec3(0.0);\n    \n    // Loop through each pixel multiple times to get multiple sample colors with minute time shifts in each sample.\n    // This is an anti-aliasing technique called \"supersampling\" that helps reduce jagged edges of individual frames.\n    // It also tends to lead to smoother feeling animations as well due to each frame feeling smoother.\n    for( int j=0; j<numSamples; j++ )\n    {\n        // Establishing the time shift for each sample.\n        // Notice that time is very slightly shifted for each iterative sample,\n        // with 1/30 of a second being the max shifted sample.\n        float h = float(j)/float(numSamples);\n        float time = iTime + h*(1.0/30.0);\n        \n        // This starting point is a subtle grey gradiant where points further from the origin are slightly darker.\n        vec3 col = vec3(0.2) *(1.0-0.08*st.x);\n        //vec3 col = vec3(0.2);\n\n        // Modified version of polar coordinates where the radial distance (st.x) \n        // is repeatedly wrapped from -1 to 1, centered around 0.\n        vec2 uvr = vec2( mod( st.x, 2.0 ) - 1.0, st.y );\n        \n        // Define an angle initiated as the pixel's polar coordinate radial angle.\n        float a = uvr.y;\n        \n        // Add rotation around the origin based on time.\n        a += (id+0.5) * 1.0*time;\n        \n        // Add a distortion based on radial angle and time, which results in an inline twisting effect.\n        a += 0.2*sin(3.0*uvr.y)*sin(2.0*time);\n        \n        // Multiplier to adjust size of radial slices generated in below loop.\n        float r = 0.9;\n        \n        // Starting point in radians of first slice.\n        float x0 = r * sin(a);\n        \n        // Loop through 5 radial segments/slices.\n        for(int i=0; i<5; i++ )\n        {\n            // Determine end point in radians of current slice.\n            float f = float(i+1)/5.0;\n            float x1 = r*sin(a + 6.2831*f );\n\n            // Segment function is used to build up the actual shape of the current slice for the current pixel.\n            vec4 seg = segment(x0, x1, uvr, id, time, f );\n            \n            // Interpolate between last segments color and this segments color based on the returned segment weight.\n            // NOTE: seg.a is not used for transparency here but weight of the returned segment.\n            col = mix( col, seg.rgb, seg.a );\n            \n            // Set starting point in radians of next slice to the end point of current slice.\n            x0 = x1;\n        }\n        \n        // Apply a subtle lightening gradiant where origin is lightened and further points are darkened\n        col *= (1.6-0.1*st.x);\n        \n        // Add the sample's color to the total color (final color will be the average of this total). \n        tot += col;\n    }\n    \n    // Get the average supersampled value for the final output color.\n    tot = tot / float(numSamples);\n    \n    // Return the final output color with full opacity.\n \tfragColor = vec4( tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}