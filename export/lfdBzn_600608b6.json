{"ver":"0.1","info":{"id":"lfdBzn","date":"1732650652","viewed":144,"name":"Rubik-esque + Motion Blur","username":"incre_ment","description":"Rubik-esque cube with some motion blur I was experimenting with previously, here:\nhttps://www.shadertoy.com/view/msVGWK","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["blur","rubik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rubik-esque cube with some motion blur I was experimenting with previously, here:\n// https://www.shadertoy.com/view/msVGWK\n// Original here (now unlisted):\n// https://www.shadertoy.com/view/MfyyWG\n\nconst float dim = .45;\n\nvec3 boxSize = vec3(.99*dim,.99*dim,.99*dim);\nvec3 frameSize = vec3(dim,dim,dim);\n\nstruct sdfData\n{\n    float closest;\n    float dist;\n    vec2 uv;\n    vec3 id;\n};\n\nsdfData SDF(vec3 p, float t){\n\n  sdfData sd;\n\n  // Overall rotation\n  p.xz *= rotation(TAU*t);\n  p.xy *= rotation(TAU*t);\n  \n  // Check each box + frame\n  float closest;\n  float minVal_Box = 1E20;\n  float minVal_Frame = 1E20;\n  vec3 q, r, rr;\n  for(float i = -1.;i <= 1.;i++)    \n  for(float j = -1.;j <= 1.;j++)\n  for(float k = -1.;k <= 1.;k++)\n  {\n    vec3 rid = vec3(i,j,k);\n    r = p - rid;\n\n    float tt = 4.*t; // .4*iTime;\n    float turn = floor(mod(tt,4.));\n\n    // I could of streamlined the rotations here, but decided to just hard\n    // code them.  Sometimes you just want to move on and work on something else!  \n    if (rid.x == 1. && (turn == 0.)){\n      r.yz = r.yz + rid.yz;\n      r.yz = r.yz * rotation(PI/2.*fract(tt))\n      r.yz = r.yz - rid.yz;\n    }\n\n    else if (rid.x == -1. && (turn == 1.)){\n      r.yz = r.yz + rid.yz;\n      r.yz = r.yz * rotation(PI/2.*fract(tt))\n      r.yz = r.yz - rid.yz;\n    }\n        \n    else if (abs(rid.z) == 1. && (turn == 2.)){\n      r.xy = r.xy + rid.xy;\n      r.xy = r.xy * rotation(PI/2.*fract(tt))\n      r.xy = r.xy - rid.xy;\n    }\n        \n\n    else if (abs(rid.y) == 1. && (turn == 3.)){\n      r.xz = r.xz + rid.xz;\n      r.xz = r.xz * rotation(PI/2.*fract(tt))\n      r.xz = r.xz - rid.xz;\n    }\n        \n    else if(rid.z == 0. && (turn == 4.)){\n      r.xy = r.xy + rid.xy;\n      r.xy = r.xy * rotation(PI/2.*fract(tt))\n      r.xy = r.xy - rid.xy;\n    }\n            \n    float frame = sdBoxFrame(r, frameSize, .015);\n    float box = sdBox(r, boxSize);\n        \n    if (box < minVal_Box){\n      rr = r;\n      sd.id = vec3(i,j,k);\n      minVal_Box = box;\n    }\n      \n    minVal_Frame = min(minVal_Frame,frame);\n        \n  }\n     \n  q = rr;\n  \n  if (minVal_Box < minVal_Frame){\n\n    sd.closest = 1.;\n    sd.dist = minVal_Box;\n  \n    // Thanks to lz for this bit of logic\n    vec3 qq = abs(q);  \n    if (qq.x > qq.y && qq.x > qq.z) sd.uv = q.yz;\n    else if (qq.y >= qq.x && qq.y > qq.z) sd.uv = q.xz;\n    else sd.uv = q.xy;\n  }\n  if (minVal_Frame <= minVal_Box){ \n    sd.closest = 0.;\n    sd.dist = minVal_Frame;\n  }\n\n  return sd;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  // Blur Parameters\n  float samples = 10.0;\n  float spacingFactor = .008;\n\n  vec3 result = vec3(0.);\n  float fracTime = fract(.2 * iTime);\n  // Loop Over the number of samples\n  for(float sa = 0.; sa < samples; sa++)\n  {\n    float tt = fracTime + sa*spacingFactor/samples;\n  \n    vec3 col = vec3(0);\n    //  float tt = .4*iTime;   \n    vec3 camPos = vec3(0., 0., 6.); \n    vec3 rayDir = normalize(vec3(uv, -1));\n    float depth = 0.0;\n    float closest;\n    vec3 p = vec3(0);\n    vec3 id;\n    sdfData sdf;\n  \n    // Raymarching\n    for(int numIter = 0; numIter < 40; numIter++){\n      p = camPos + depth * rayDir; \n      sdf = SDF(p, tt);\n      depth += sdf.dist;\n      if (sdf.dist < .01 || depth > 10.0) break;\n    }\n  \n    if (depth > 10.) {\n      col = vec3(0.);  \n    } \n    else if (sdf.closest == 1.){\n      // If box, draw the dots\n      vec2 side = sdf.uv;\n      vec2 star_uv =  5.*side;\n      vec2 starID = floor(star_uv);\n      star_uv = fract(star_uv) - .5;\n      float star_rad = .2;\n      float star = length(star_uv) - star_rad;\n     \n      col += smoothstep(0.,-fwidth(star),star);\n    } \n    else if (sdf.closest == 0.){\n      //if frame, draw the frame\n      col += vec3(1.);  \n    }\n  \n    // Add each sample into the into the result\n    result += col;                \n  }\n  \n  // Divide the results by the number of samples\n  vec3 colOut = result*1.0/samples;\n \n  fragColor = vec4(colOut, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ for the SDF functions!\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n","name":"Common","description":"","type":"common"}]}