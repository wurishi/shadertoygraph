{"ver":"0.1","info":{"id":"Xlt3Wl","date":"1472522378","viewed":267,"name":"RayTriangleIntersect","username":"albertelwin","description":"Practicing ray-triangle intersection :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting","triangle","intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SUPERSAMPLING 1\n\n#define TAU 6.28318530717958647692\n#define TO_RAD 0.01745329251\n#define GAMMA 2.2\n#define MAX_DIST 1000.0\n\nfloat dither(vec2 xy, float t) {\n    float s = (xy.x * 12.9898) + (xy.y * 78.2330);\n    float r = fract(sin((t * 12.9898) + s) * 43758.5453) + fract(sin((t * 78.2330) + s) * 43758.5453);\n    return (r * 0.00392156886) - 0.00196078443;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = 90.0;\n    float tan_fov = tan(fov * 0.5 * TO_RAD);\n    vec2 image_plane = vec2(tan_fov, tan_fov * (iResolution.y / iResolution.x));\n\n#define MAX_SAMPLE_COUNT 8\n    vec2 sample_offsets[MAX_SAMPLE_COUNT];\n\tsample_offsets[0] = vec2(0.125, 0.875);\n    sample_offsets[1] = vec2(0.625, 0.875);\n    sample_offsets[2] = vec2(0.375, 0.625);\n    sample_offsets[3] = vec2(0.875, 0.625);\n    sample_offsets[4] = vec2(0.125, 0.375);\n    sample_offsets[5] = vec2(0.625, 0.375);\n    sample_offsets[6] = vec2(0.375, 0.125);\n    sample_offsets[7] = vec2(0.875, 0.125);\n\n#if SUPERSAMPLING\n    #define SAMPLE_COUNT MAX_SAMPLE_COUNT\n#else\n    #define SAMPLE_COUNT 1\n#endif\n\n    float a = iTime * 0.5 + 2.9;\n    float cos_a = cos(a);\n    float sin_a = sin(a);\n\n#if 1\n    //NOTE: Just baking the y-rotation into the vertices :)\n    vec3 A = vec3(-cos_a - sin_a, 1.0, sin_a - cos_a) * 0.8;\n    vec3 B = vec3( sin_a - cos_a,-1.0, sin_a + cos_a) * 0.8;\n    vec3 C = vec3( cos_a + sin_a, 1.0, cos_a - sin_a) * 0.8;\n    vec3 D = vec3( cos_a - sin_a,-1.0,-sin_a - cos_a) * 0.8;\n\n#define VERTEX_COUNT 12\n    vec3 v[VERTEX_COUNT];\n    v[ 0] = A; v[ 1] = B; v[ 2] = C;\n    v[ 3] = C; v[ 4] = B; v[ 5] = D;\n    v[ 6] = D; v[ 7] = A; v[ 8] = C;\n    v[ 9] = A; v[10] = D; v[11] = B;\n#else\n#define VERTEX_COUNT 3\n    vec3 v[VERTEX_COUNT];\n    v[0] = vec3( 0.0,-1.0, 0.0);\n    v[1] = vec3(-0.866 * cos_a, 0.5, 0.866 * sin_a);\n    v[2] = vec3( 0.866 * cos_a, 0.5,-0.866 * sin_a);\n#endif\n\n    vec3 color = vec3(0.0);\n\n    for(int sample_index = 0; sample_index < SAMPLE_COUNT; sample_index++) {\n        vec2 sample_pos = fragCoord.xy + sample_offsets[sample_index];\n        vec3 image_point = vec3((2.0 * sample_pos / iResolution.xy - 1.0) * image_plane, -2.0);\n\n        vec3 ro = vec3(0.0, 0.0, -3.0);\n        vec3 rd = normalize(image_point - ro);\n\n        for(int i = 0; i < VERTEX_COUNT; i += 3) {\n            vec3 v0 = v[i + 0];\n            vec3 v1 = v[i + 1];\n            vec3 v2 = v[i + 2];\n\n            vec3 e0 = v1 - v0;\n            vec3 e1 = v2 - v0;\n\n            vec3 n = cross(e0, e1);\n            float d2 = dot(n, n);\n            vec3 m = n * (1.0 / d2);\n            n = m * sqrt(d2);\n\n          \tfloat dot_nd = dot(n, rd);\n            float t = dot(v0 - ro, n) / dot_nd;\n            vec3 p = ro + t * rd;\n            \n            vec3 b;\n            b.y = dot(cross(p - v2, e1), m);\n            b.z = dot(cross(e0, p - v0), m);\n            b.x = 1.0 - (b.y + b.z);\n\n            if(b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {\n                color += b;\n            }\n        }\n    }\n\n    color *= (1.0 / float(SAMPLE_COUNT));\n    color += dither(fragCoord.xy, fract(iTime));\n    color = pow(color, vec3(1.0 / GAMMA));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}