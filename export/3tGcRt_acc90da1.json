{"ver":"0.1","info":{"id":"3tGcRt","date":"1611687725","viewed":498,"name":"Curvature via Dual Numbers","username":"fizzer","description":"A remake of \"Cheap curvature\" by Nimitz: https://www.shadertoy.com/view/Xts3WM, except that the SDF divergence is calculated analytically using dual numbers. So there is no need for epsilon tweaking, and fewer trigonometric calculations are performed.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["sdf","curvature","laplacian","divergence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is a remake of \"Cheap curvature\" by Nimitz: https://www.shadertoy.com/view/Xts3WM\n// Using higher-order automatic differentiation via dual numbers, based on this blog post:\n// http://blog.jliszka.org/2013/10/24/exact-numeric-nth-derivatives.html\n//\n// The cheap curvature method is to sample the SDF at a bunch of locations and estimate the\n// Laplacian. Here, I have attempted to calculate the Laplacian analytically by using dual numbers.\n//\n// In my tests I found that this is about the same performance or slightly (~5%) slower than the 5-tap\n// cheap curvature norcurv() method from Nimitz's shader.\n//\n\n// I mostly applied this idea using the chain rule rather than alebraically working through using ε and ε².\n\n// 1st-order chain rule:\n//      d/dx f(g(x)) = f'(g(x)) g'(x)\n// 2nd-order chain rule:\n//      d²/dx² f(g(x)) = f''(g(x)) g'(x)² + f'(g(x)) g''(x)\n//\n// I arrived at the 2nd-order chain rule by using Faà di Bruno's formula\n// https://en.wikipedia.org/wiki/Fa%C3%A0_di_Bruno's_formula\n//\n\n// From the 2nd-order derivatives resulting from the dual number calculations, the Laplacian\n// of the SDF is calculated:\n//      Δf = d²f/dx² + d²f/dy² + d²f/dz²\n\n\n// See also:\n//      https://www.shadertoy.com/view/ldVyD1 - Laplacian of SDF texture by mattz\n//      https://www.shadertoy.com/view/4djyzK - Laplacian by iq\n//      https://www.shadertoy.com/view/Mdl3Ws - Dual Real Numbers by iq\n\n\n// This is maybe not a real 'dual' number anymore, but I don't know what the proper name for it is.\nstruct Dual\n{\n   float  f; // SDF value\n   mat3x2 d; // Partial first and second derivatives:\n             //     df/dx, d²f/dx², df/dy, d²f/dy², df/dz, d²f/dz²\n};\n\nDual dMul(Dual a, Dual b)\n{\n   Dual res;\n   res.f = a.f * b.f;\n   for(int i = 0; i < 3; ++i)\n      res.d[i] = vec2(a.d[i].x * b.f + a.f * b.d[i].x,\n                      a.f * b.d[i].y + a.d[i].y * b.f + 2. * a.d[i].x * b.d[i].x);\n   return res;\n}\n\nDual dSin(Dual a)\n{\n   Dual res;\n   float c = cos(a.f);\n   res.f = sin(a.f);\n   for(int i = 0; i < 3; ++i)\n      res.d[i] = vec2( c * a.d[i].x,\n                      -res.f * a.d[i].x * a.d[i].x + c * a.d[i].y );\n   return res;\n}\n\nDual dSqrt(Dual a)\n{\n   Dual res;\n   res.f = sqrt(a.f);\n   for(int i = 0; i < 3; ++i)\n      res.d[i] = vec2( 0.5 / res.f * a.d[i].x,\n                      ( 0.25 / res.f ) / a.f * a.d[i].x * a.d[i].x + 0.5 / res.f * a.d[i].y );\n   return res;\n}\n\nDual dSqr(Dual a)\n{\n    return dMul(a, a);\n}\n\nDual dAdd(Dual a, Dual b)\n{\n   return Dual(a.f + b.f, a.d + b.d);\n}\n\nDual dSub(Dual a, Dual b)\n{\n   return Dual(a.f - b.f, a.d - b.d);\n}\n\nDual dConst(float x)\n{\n    return Dual(x, mat3x2(0));\n}\n\nDual dLength(Dual dualX, Dual dualY, Dual dualZ)\n{\n    return dSqrt(dAdd(dSqr(dualX), dAdd(dSqr(dualY), dSqr(dualZ)))); \n}\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nfloat map(vec3 p)\n{\n    p.x += sin(p.y*4.+time+sin(p.z))*0.15;\n    float d = length(p)-1.;\n    float st = sin(time*0.42)*.5+0.5; \n    const float frq = 10.;\n    d += sin(p.x*frq + time*.3 + sin(p.z*frq+time*.5+sin(p.y*frq+time*.7)))*0.075*st;\n    \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\n// The SDF map function from Nimitz's shader, machine-rewritten for dual numbers using this C++ code:\n// http://amietia.com/dual_gen.cpp\nfloat mapNormCurv(vec3 p, out vec3 n, out float c)\n{\n    Dual dualX = Dual(p.x, mat3x2(1, 0, 0, 0, 0, 0));\n    Dual dualY = Dual(p.y, mat3x2(0, 0, 1, 0, 0, 0));\n    Dual dualZ = Dual(p.z, mat3x2(0, 0, 0, 0, 1, 0));\n    \n    Dual d = dAdd(dSub(dLength(dAdd(dualX, dMul(dSin(dAdd(dAdd(dMul(dualY, dConst(4.000000)),\n                dConst(time)), dSin(dualZ))), dConst(0.150000))), dualY, dualZ), dConst(1.000000)),\n                dMul(dMul(dSin(dAdd(dAdd(dMul(dAdd(dualX, dMul(dSin(dAdd(dAdd(dMul(dualY, dConst(4.000000)),\n                dConst(time)), dSin(dualZ))), dConst(0.150000))), dConst(10.000000)), dMul(dConst(time),\n                dConst(0.300000))), dSin(dAdd(dAdd(dMul(dualZ, dConst(10.000000)), dMul(dConst(time),\n                dConst(0.500000))), dSin(dAdd(dMul(dualY, dConst(10.000000)), dMul(dConst(time),\n                dConst(0.700000)))))))), dConst(0.075000)), dAdd(dMul(dSin(dMul(dConst(time),\n                dConst(0.420000))), dConst(0.500000)), dConst(0.500000))));\n                \n    n = normalize(vec3(d.d[0].x, d.d[1].x, d.d[2].x));\n\n    c = d.d[0].y + d.d[1].y + d.d[2].y;\n    \n    return d.f;\n}\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n    vec3 ro = vec3(0.,0.,4.);\n    ro.xz *= mm2(time*0.05+mo.x*3.);\n\tvec3 ta = vec3(0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.,1.,0.), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n    \n    vec3 col = vec3(0);\n    \n    vec3 n = vec3(0);\n    float c = 0.;\n    \n    float rz = march(ro,rd);\n    \n    col = texture(iChannel0, rd).rgb;\n    \n    if(rz < FAR)\n    {\n        vec3 pos = ro+rz*rd;\n        float d=mapNormCurv(pos, n, c);\n        float crv;\n        vec3 nor = n;\n        crv = c / 500.;\n        vec3 ligt = normalize( vec3(.0, 1., 0.) );\n        float dif = clamp(dot( nor, ligt ), 0., 1.);\n        float bac = clamp( dot( nor, -ligt), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),400.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = vec3(0.10,0.11,0.13);\n        brdf += bac*vec3(0.1);\n        brdf += dif*vec3(1.00,0.90,0.60);\n        col = abs(sin(vec3(0.2,0.5,.9)+clamp(crv*80.,0.,1.)*1.2));\n        col = mix(col,texture(iChannel0,reflect(rd,nor)).rgb,.5);\n        col = col*brdf + col*spe +.3*fre*mix(col,vec3(1),0.5);\n        col *= smoothstep(-1.,-.9,sin(crv*200.))*0.15+0.85;\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}