{"ver":"0.1","info":{"id":"WldGWB","date":"1577454066","viewed":222,"name":"Sci-Fi (unfinished)","username":"Tara","description":"Unfinished\nThis is based on some artwork I forgot where to find.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","scifi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: Use the actual distance fields for advancing the ray!\n\n//#define RENDER_DEPTH\n#define ENABLE_FOG\n//#define ANIMATE_CUBES\n\nconst int max_shadow_ray_samples = 32;\nconst int max_ray_samples = 512;\t// TODO: Rename to \"max_view_ray_samples\".\nconst float max_view_distance = 12.0;\t// TODO: Adjust!\nconst float wall_distance = 0.3;\n\nconst vec3 light_color_blue = vec3(0.2, 0.275, 1.0) * 40.0;\nconst vec3 light_color_pink = vec3(1.0, 0.325, 0.35) * 10.0;\n\n//const vec3 fog_color = vec3(0.2, 0.2, 1.0) * 1.7;\nconst vec3 fog_color = light_color_blue * 0.1;\n\n// Perlin noise:\nfloat mod289(float x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod289(vec4 x)\n{\n\treturn(x - floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 perm(vec4 x)\n{\n\treturn(mod289(((x * 34.0) + 1.0) * x));\n}\n\nfloat perlin_2d(vec2 p)\n{\n    vec2 a = floor(p);\n    vec2 d = p - a.xy;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = vec4(a.x, a.x + 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.yyyy;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.y + o1 * (1.0 - d.y);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return(o4.y * 0.0 + o4.x * 1.0);\n}\n\nfloat calculate_height(vec3 position)\n{\n    vec2 p = round(position.yz * 3.0) / 3.0;\t// Round the coordinates so we get a blocky heightmap.\n     \n\tfloat n = //perlin_2d(p) +\n              //0.5 * perlin_2d(p * 2.0) +\n                0.25 * perlin_2d(p * 4.0) +\n                0.125 * perlin_2d(p * 8.0) +\n                0.0625 * perlin_2d(p * 16.0) +\t// TODO: PERFORMANCE: How detailed does the noise function need to be?\n                0.03125 * perlin_2d(p * 32.0);\n              //+ 0.015625 * perlin_2d(p * 64.0);\n    \n    \n    \n   \n    \n    // TODO: Instead of calculating an offset for the noise every frame,\n    //       how about simply transforming the ray instead?\n    \n    /*\n#ifdef ANIMATE_CUBES\n    float noise_value = wall_distance + max(n * sin(n * 31.42 + iTime * 2.0) * 0.5, 0.0);\n        \n#else\n    float noise_value = wall_distance + n * 0.3;\n#endif\n    */\n    float noise_value = n;\n    \n    return(noise_value);\n    \n    /*\n    float offset_y = step(mod(uv.y * 4.0, 7.0), 1.0);\n    offset_y += step(mod(uv.x * 40.0, 3.0), 1.0);\n    offset_y *= step(mod(uv.x * 40.0, 3.0), 1.0);\n\n\treturn(offset_y); \n\t*/\n}    \n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat repeated_box(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    //return primitve(q);\n    return(0.0);\n}\n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat signed_distance_box_repeating(vec3 p, vec3 box_position, vec3 box_dimensions, vec3 spacing)\n{\n    // Translation:\n    p -= box_position;\n    \n    // Repetition:\n    //const vec3 c = vec3(0.0, 0.0, 2.5);\n    //p = mod(p, c) - 0.5 * c;\n    p = mod(p, spacing) - 0.5 * spacing;\n    \n    \n\tvec3 d = abs(p) - box_dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Source: https://iquilezles.org/articles/distfunctions\nfloat signed_distance_box(vec3 p, vec3 box_position, vec3 box_dimensions)\n{\n    // Translation:\n    p -= box_position;\n        \n\tvec3 d = abs(p) - box_dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat signed_distance_plane(vec3 p, vec3 plane_normal, float plane_distance)\n{\n    // Project the point onto the plane:\n    return(dot(plane_normal, p) + plane_distance);\n}\n\nvec3 get_surface_color(vec3 point_of_intersection, float surface_height)\n{\n    \n    if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(vec3(0.1, 0.17, 1.0) * 5.0);\n    }\n    else if(abs(point_of_intersection.x) - surface_height > 0.01)\n    {\n        return(vec3(0.5, 0.2, 0.2) * 5.0);\n    }\n\n    // TODO: Fix the coordinate offset!\n    float cube_corner_step_z = step(mod(point_of_intersection.z - 0.48, 1.0 / 3.0), 0.025);\n    float cube_corner_step_y = step(mod(point_of_intersection.y - 0.48, 1.0 / 3.0), 0.025);\n\n    vec3 cube_corner_glow = vec3(0.0);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.08, 0.08) * 3.0, cube_corner_step_z);\n    cube_corner_glow = mix(cube_corner_glow, vec3(0.5, 0.08, 0.08) * 3.0, cube_corner_step_y);\n\n    return(cube_corner_glow);\n\n    return(vec3(0.0));\n    return(vec3(surface_height));\n}\n\n\nfloat get_wall_distance(vec3 p, vec3 eye_position)\n{\n    //const float floor_position_y = -2.0;\n    \n    const vec3 wall_left_normal = normalize(vec3(2.0, -1.0, 0.0));\n    const float wall_left_distance = -1.5;\n    \n    const vec3 wall_right_normal = normalize(vec3(-2.0, -1.0, 0.0));\n    const float wall_right_distance = -1.5;\n    \n    const vec3 floor_normal = normalize(vec3(0.0, 1.0, 0.0));\n    const float floor_distance = -3.0;\n    \n    // Project the point onto the plane:\n    float smallest_distance = dot(wall_left_normal, p) - wall_left_distance;\n    smallest_distance = min(smallest_distance, dot(wall_right_normal, p) - wall_right_distance);\n    //smallest_distance = min(smallest_distance, dot(floor_normal, p) - floor_distance);\t// TODO: This one could be simplified.\n\n    \n    \n    \n    const vec3 bottom_wall_left_normal = normalize(vec3(1.0, 0.0, 0.0));\n    const float bottom_wall_left_distance = -3.0;\n    \n    const vec3 bottom_wall_right_normal = normalize(vec3(-1.0, 0.0, 0.0));\n    const float bottom_wall_right_distance = -3.0;\n    \n    smallest_distance = min(smallest_distance, dot(bottom_wall_left_normal, p) - bottom_wall_left_distance);\n    smallest_distance = min(smallest_distance, dot(bottom_wall_right_normal, p) - bottom_wall_right_distance);\n    \n    \n    const vec3 wall_ceiling_left_normal = normalize(vec3(2.5, -1.0, 0.0));\n    const float wall_ceiling_left_distance = -0.5;\n    \n    const vec3 wall_ceiling_right_normal = normalize(vec3(-2.5, -1.0, 0.0));\n    const float wall_ceiling_right_distance = -0.5;\n    \n    \n    //smallest_distance = 999.9;\n    \n    float wall_ceiling_distance = dot(wall_ceiling_left_normal, p) - wall_ceiling_left_distance;\n    wall_ceiling_distance = max(wall_ceiling_distance, dot(wall_ceiling_right_normal, p) - wall_ceiling_right_distance);\n    \n    \n\tsmallest_distance = min(smallest_distance, wall_ceiling_distance);\n    \n    \n    // Blocks near the walls:\n    const vec3 block_dimensions = vec3(0.3, 2.0, 0.3);\n    const vec3 block_spacing = vec3(0.0, 0.0, 7.0);\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -4.2, 0.0), block_dimensions, block_spacing));\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(2.6, -4.2, 0.0), block_dimensions, block_spacing));\n\n    // Block sticking out of the walls below the above blocks:\n    smallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.3, -5.1, 0.0), block_dimensions, block_spacing));\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(2.3, -5.1, 0.0), block_dimensions, block_spacing));\n\n    // \"ladders\" going across:\n    float ladder_thickness = 0.035;\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -3.5, 0.3 - ladder_thickness), vec3(5.0, ladder_thickness, ladder_thickness), block_spacing));\n\tsmallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -3.5, -0.3), vec3(5.0, ladder_thickness, ladder_thickness), block_spacing));\n    \n    // \"ladders\" steps:\n    smallest_distance = min(smallest_distance, signed_distance_box_repeating(p, vec3(-2.6, -3.5, 0.0 - ladder_thickness), vec3(ladder_thickness, ladder_thickness, block_dimensions.z), vec3(0.5, 0.0, block_spacing.z)));\n\n    // Long bars along the walls:\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(-2.6, -13.0, -5.0), vec3(0.3, 10.0, 1000000.0)));\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(2.6, -13.0, -5.0), vec3(0.3, 10.0, 1000000.0)));\n\n    \n    // Moving platform:\n\tsmallest_distance = min(smallest_distance, signed_distance_box(p, vec3(0.0, -1.45, -0.5) + eye_position, vec3(0.5, 0.1, 1.5)));\n\n    \n    \n    \n    // TODO: Add cubes.\n\n    \n    return(smallest_distance);\n    \n    //return(p.y - floor_position_y);\n    //return(distance(vec3(p.x, 0.0, p.z), vec3(0.0)));\t// TODO: Use signed distance!\n    \n    //return(false);\n}    \n\nfloat compute_ambient_occlusion(vec3 position, vec3 normal, float max_distance, int samples, vec3 eye_position)\n{\n    const float surface_offset = 0.001;\n    const float sample_distance = 0.08;\n    \n    float occlusion = 0.0;\n    \n    //float sample_sum = 0.0;\n    \n    for(int i=0; i<8; ++i)\n    { \n        float sample_offset_distance = surface_offset + float(i) * sample_distance;\n        vec3 sample_position = position + normal * sample_offset_distance;\n        float sample_weight = 1.0 / float(i + 1);\n        //sample_sum += sample_weight;\n        \n        //occlusion += sample_weight * sample_offset_distance - get_wall_distance(sample_position, eye_position);\n\t\tocclusion += sample_weight * max(sample_offset_distance - get_wall_distance(sample_position, eye_position), 0.0);\n    }\n    \n    return(1.0 - occlusion);\n}\n\nfloat calculate_shadow(vec3 p, vec3 light_position, vec3 eye_position)\n{    \n    vec3 p_to_light = light_position - p;\n    float p_to_light_distance = length(p_to_light);\n    vec3 n_ray_direction = normalize(p_to_light);\n    \n    p += n_ray_direction * 0.05;\t// Offset\t// TODO: Offset using the normal.\n    \n    float travelled_distance = 0.0;\n    \n    float step_size = p_to_light_distance / float(max_shadow_ray_samples - 1);\t// Incrase the step size so we step over the light.\n        \n    for(int i=0; i<max_shadow_ray_samples; ++i)\n    {\n        travelled_distance += step_size;\n        vec3 sample_point = p + n_ray_direction * travelled_distance;\n        \n        if(get_wall_distance(sample_point, eye_position) < 0.0)\n        {\n            return(0.0);\n        }\n        \n        if(travelled_distance > p_to_light_distance)\n        {\n            return(1.0);\n        }  \n    }\n    \n    return(0.0);\n}\n\nvec3 calculate_lighting(vec3 p, vec3 eye_position, vec3 light_position, vec3 light_color, vec3 n_normal)\n{\n    float ambient_occlusion = compute_ambient_occlusion(p, n_normal, 0.01, 8, eye_position);\n\n    vec3 p_to_light = light_position - p;\n    vec3 n_light_direction = normalize(p_to_light);\n    vec3 direct_lighting_diffuse = light_color * max(dot(n_light_direction, n_normal), 0.0);\n    float squared_p_to_light_distance = dot(p_to_light, p_to_light);\n    direct_lighting_diffuse /= squared_p_to_light_distance;\t// Inverse square falloff.\n    \n    // TODO: Add specular.\n    \n    float shadow = 1.0;\n    \n    //if(1.0 / squared_p_to_light_distance > 0.01)\n    {\n    \tshadow = calculate_shadow(p, light_position, eye_position);\n    }\n            \n    \n    return(shadow * ambient_occlusion * direct_lighting_diffuse);\n\n}  \n\n// Parallax mapping basically:\nvec3 trace_ray(vec3 ray_origin, vec3 n_ray_direction, inout float depth)\n{\n    vec3 eye_position = ray_origin;\n    \n    /*\n    // TODO: Use dot product between Z and X axis only!\n    //float dot_product = max(dot(n_ray_direction, vec3(0.0, 0.0, -1.0)), 0.0);\n    float dot_product = max(dot(normalize(n_ray_direction.xz), vec2(0.0, -1.0)), 0.0);\n    \n    \n    //dot_product = 1.0 - pow(1.0 - dot_product, 2.0);\t// Make the value go bigger towards the center of the screen.\n    dot_product = pow(dot_product, 10.0);\t// Make the value go bigger towards the center of the screen.\n    //return vec3(dot_product);\n    \n    dot_product *= 0.1;\n  \n    \n    // TODO: Do a binary search?\n    \n    float step_size = max(dot_product, 0.01);\n    */\n    \n    \n    /*\n    float intersection_distance = max_view_distance;\n    vec3 bounding_plane_point_of_intersection = intersect_wall_bounding_plane(ray_origin, n_ray_direction, intersection_distance);\n    \n    if(intersection_distance >= max_view_distance)\n    {\n    \treturn(fog_color);\n    }    \n    \n    // Offset the ray to the intersection of the bounding plane to speed up the parallax mapping.\n    ray_origin = bounding_plane_point_of_intersection;\n    \n    */\n        \n    \n    //float step_size = 0.001;\t// TODO: Base step size on something proper.\n    float step_size = max_view_distance / float(max_ray_samples);\t// TODO: Base step size on something proper.\n    float min_step_size = max_view_distance / float(max_ray_samples);\t// TODO: Base step size on something proper.\n        \n    for(int i=0; i<max_ray_samples; ++i)\n    {\n        float distance_to_nearest_surface = get_wall_distance(ray_origin, eye_position);\n        //step_size = max(distance_to_nearest_surface, min_step_size * 0.01);\n        \n        //ray_origin += n_ray_direction * 0.01;\n        ray_origin += n_ray_direction * step_size;\n        \n        //depth = distance(ray_origin, eye_position);\t// TODO: Calculate this differently?\n        \n        \n        if(distance_to_nearest_surface < 0.0)\n        {\n            depth = abs(ray_origin.z - eye_position.z);\n            \n            const float offset = 0.0001;\t// Small enough to hide artifacts but still be correct.\n            \n            vec3 n_normal;\n\t\t\tn_normal.x = get_wall_distance(ray_origin + vec3(offset, 0.0, 0.0), eye_position) - get_wall_distance(ray_origin - vec3(offset, 0.0, 0.0), eye_position);            \n\t\t\tn_normal.y = get_wall_distance(ray_origin + vec3(0.0, offset, 0.0), eye_position) - get_wall_distance(ray_origin - vec3(0.0, offset, 0.0), eye_position);            \n\t\t\tn_normal.z = get_wall_distance(ray_origin + vec3(0.0, 0.0, offset), eye_position) - get_wall_distance(ray_origin - vec3(0.0, 0.0, offset), eye_position);            \n            n_normal = normalize(n_normal);\n            \n            \n            /*\n            float brightness = (sin(ray_origin.z * 10.0) * 0.5 + 0.5) *\n                 \t\t\t   (sin(ray_origin.y * 10.0) * 0.5 + 0.5) *\n                \t\t\t   (sin(ray_origin.x * 10.0) * 0.5 + 0.5);\n            */\n            float wire_texture = step(sin(abs(ray_origin.z) * 10.0), 0.9) *\n                 \t\t\t   step(sin(abs(ray_origin.y) * 10.0), 0.9) *\n                \t\t\t   step(sin(abs(ray_origin.x) * 10.0), 0.9);\n            //brightness = pow(brightness, 2.0);            \n\t\t\t//brightness = step(brightness, 0.5);\n            wire_texture = clamp(1.0 - wire_texture, 0.0, 1.0);\n            \n            //vec3 light_direction = normalize(vec3(0.5, 0.5, 0.5));\n            //vec3 light_direction = normalize(vec3(0.0, 0.0, -1.0));\n            //vec3 light_position = eye_position - vec3(1.0, 0.0, 3.0);\n            \n            vec3 albedo = vec3(wire_texture);\n            //vec3 light_position_pink = eye_position - vec3(0.0, 1.0, 2.0);\n            vec3 light_position_pink = eye_position + vec3(0.0, -4.5, -2.0);\n            \n            vec3 light_position_blue = eye_position + vec3(0.0, -1.0, -10.0);\n            \n            \n            vec3 lighting = vec3(0.0);\n            \n            lighting += calculate_lighting(ray_origin, eye_position, light_position_pink, light_color_pink, n_normal);\n           \tlighting += calculate_lighting(ray_origin, eye_position, light_position_blue, light_color_blue, n_normal);\n           \n            //float ambient_occlusion = compute_ambient_occlusion(ray_origin, normal, 0.01, 8, original_ray_origin);\n            //return(vec3(ambient_occlusion));\n            \n            if(ray_origin.y > -2.0)\n            {\n                lighting += vec3(step(calculate_height(ray_origin * vec3(10.0, 10.0, 5.0)), 0.15)) * \n                    step(sin(0.5 + ray_origin.y * 3.0), 0.0) * \n                    step(sin(ray_origin.z * 2.0), 0.0) *\n                    (sin(iTime * 10.0 + ray_origin.y * 10.0 + ray_origin.z * 10.0 + ray_origin.x * 10.0) * 0.5 + 0.5);\n            }\n            \n            //return vec3(shadow);\n            \n            return(lighting);\n            \n            return(albedo * lighting);\n            \n            //return ray_origin;            \n            \n            //return vec3(max(dot(vec3(0.0, 1.0, 0.0), normal), 0.0));\n            \n            //return normal;\n\n            //return vec3(mod(distance(ray_origin, light_position), 1.0));\n            \n\n            return vec3(wire_texture);\n            \n    \t\treturn(vec3(wire_texture + 0.5)) * 0.25;\n            \n    \t\treturn(vec3(0.0, 0.5, 0.0));\n        }\n        \n        /*\n        float surface_height = calculate_height(ray_origin);\n        //surface_height = 0.1;\n        if(abs(ray_origin.x) > surface_height)\t// TODO: Do the ABS before entering this loop!\n        {\n            depth = distance(ray_origin, eye_position);\t// TODO: Calculate this differently?\n\n            if(depth >= max_view_distance)\n            {\n                depth = max_view_distance;\n                return(fog_color);\n            }\n\n            return(get_surface_color(ray_origin, surface_height));\n        }\n        */\n    }\n    \n    depth = max_view_distance;\n\n    return(vec3(0.0));\n    return(fog_color);\n    return(vec3(0.0, 1.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 clean_uv = fragCoord / iResolution.xy;\n    \n    //vec2 half_resolution = vec2(iResolution.x * 0.5, iResolution.y);\n    //vec2 half_resolution = iResolution.xy * 0.5;\n    //vec2 distance_to_screen_center = abs(fragCoord.xy - half_resolution);\n    \n    //float dist = 0.075 + 0.9 * (distance_to_screen_center.x / half_resolution.x);\n    /*\n\tvec2 uv;\n    uv.x = (distance_to_screen_center.x / dist) / iResolution.x;\n    uv.y = ((fragCoord.y - half_resolution.y) / dist) / iResolution.x;\n    \n    uv.x -= iTime * 0.1;\n    */\n    // TODO: Reset camera position so it loops (because we are getting precsion issues!).\n    \n    vec3 ray_origin = vec3(0.0, 0.0, 0.0);\n    ray_origin.z -= iTime * 3.0;\n    //vec3 n_ray_direction = normalize(vec3(clean_uv * 2.0 - vec2(1.0), -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    vec3 n_ray_direction = (vec3(clean_uv * 3.0 - vec2(1.5), -1.0));\t// OpenGL coordinate system. Z pointing outside the screen.\n    \n    /*\n    // TODO: Why doesn't the rotation work?\n    // TODO: Add the ability to look around using the mouse.\n    float angle = iTime;\n    n_ray_direction.x = cos(angle) * n_ray_direction.x - sin(angle) * n_ray_direction.z;\n    n_ray_direction.z = sin(angle) * n_ray_direction.x + cos(angle) * n_ray_direction.z;\n    //n_ray_direction = normalize(n_ray_direction);\n    */\n    \n    // TODO: Use view plane depth or actual distance?\n    float depth = max_view_distance;\n    vec3 trace_result = trace_ray(ray_origin, n_ray_direction, depth);\n    \n    float normalized_depth = depth / max_view_distance;\n    \n    \n#ifdef RENDER_DEPTH\n    fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    return;\n#endif\n    \n    \n\t///fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t//fragColor = vec4(uv.xy, 0.5, 1.0);\n    \n    \n    //fragColor.rgb = calculate_texture(uv);\n    \n    //fragColor.rgb =  trace_result * n_ray_direction;\n    fragColor = vec4(trace_result, 1.0);\n    \n    //fragColor = vec4(normalized_depth, normalized_depth, normalized_depth, 1.0);\n    //return;\n    \n\t//fragColor.rgb = mix(vec3(0.0), fog_color, clamp((1.0 - pow(1.0 - normalized_depth, 2.0)) * 1.0, 0.0, 1.0));\n    //return;\n    \n#ifdef ENABLE_FOG\n    //float inverse_depth = 1.0 - dist;\n    //inverse_depth = 1.0 - normalized_depth;\n\n    //fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(inverse_depth, 1.8) * 1.2, 0.0, 1.0));\n\t//fragColor.rgb = mix(fragColor.rgb, fog_color, clamp(pow(normalized_depth, 1.0) * 1.25, 0.0, 1.0));\n    \n    //float mix_factor = 1.0 - pow(1.0 - normalized_depth, 5.0);\n    float mix_factor = pow(normalized_depth, 1.0);\n    mix_factor = max((mix_factor - 0.25) * 1.5, 0.0);\n    fragColor.rgb = mix(fragColor.rgb, fog_color, mix_factor);\n#endif    \n    \n    //fragColor.rgb = vec3(detailed_noise_flat(uv * 50.0));\n    \n    \n   \t//fragColor = vec4(0.0);\n    \n}","name":"Image","description":"","type":"image"}]}