{"ver":"0.1","info":{"id":"Dt2cRR","date":"1691407187","viewed":35,"name":"Gradient shaping","username":"bkeenan","description":"Simple linear gradient with animated midpoint.\nCompares two shaping functions used to mix the gradient.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Experiment to understand the difference between exponential ease and bias ease.\n *\n * Includes a plot() function to draw a curve, that maintains a constant thickness\n * even as the steepness of the curve varies.\n */\n\n// #extension GL_OES_standard_derivatives : enable\n\n// Use medium precision on mobile devices\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TAU (2.*PI)\n\n// Size of one pixel in normalized texture coordinates (0-1)\nfloat pixel_size;\n\nvec3 color_background = vec3(0.0);\nvec3 color_gradient = vec3(0.0, 0.7, 1.0);\n\n// Duration of the animation in seconds\nfloat animation_duration = 6.0;\n\n/**\n * Plot a function y = f(x) as a curve.\n *\n * e.g. 'fx' is the result of the rhs of a curve equation:\n * y = x;           // linear\n * y = pow(x, 2.0); // exponential\n * y = sin(x);      // sine\n *\n * @param  {float} uv               Current fragment point (x,y)\n * @param  {float} fx               Result of the rhs of a curve equation\n * @param  {vec3}  background_color Current color of this fragment\n * @param  {vec3}  line_color       Color to use for the line\n * @param  {float} thickness        Thickness of the line in pixels\n * @return {vec3}                   New color of the fragment (on or off the line).\n */\nvec3 plot(vec2 uv, float fx, vec3 background_color, vec3 line_color, float thickness) {\n  // Naive distance to curve\n  float vertical_distance_to_curve = abs(uv.y - fx);\n\n  // Refine the distance https://iquilezles.org/articles/distance\n  vec2 gradient = vec2(dFdx(vertical_distance_to_curve), dFdy(vertical_distance_to_curve));\n  float gradient_magnitude = length(gradient) / pixel_size;\n  float distance_to_curve = vertical_distance_to_curve / gradient_magnitude;\n\n  thickness = thickness * pixel_size;\n  float anti_alias = 3.0 * pixel_size; // must be greater than 0.0\n\n  // Line has half total thickness on either side of the curve\n  float inner_edge = thickness / 2.0;\n  float outer_edge = thickness / 2.0 + anti_alias;\n\n  // Line color falls-off slightly to give anti-aliasing\n  float intensity = smoothstep(outer_edge, inner_edge, distance_to_curve);\n\n  return mix(background_color, line_color, intensity);\n}\n\n/**\n * Exponential Ease-In and Ease-Out\n *\n * @param  {float} x       The value to Ease (the input value to interpolate)\n * @param  {float} control Control parameter to vary the function from ease-out (0.0) to ease-in (1.0). \n *                         The default is linear, no easing (0.5).\n */\nfloat exponential_ease(float x, float midpoint) {\n  // Clamp a to ensure it remains within the range of [0.00001, 0.99999]\n  // This is to avoid issues with very small or very large values that could cause problems with floating-point precision.\n  float epsilon = 0.00001;\n  midpoint = clamp(midpoint, 0.0 + epsilon, 1.0 - epsilon);\n\n  if(midpoint < 0.5) {\n    // emphasis\n    midpoint = 2.0 * (midpoint);\n    float y = pow(x, midpoint);\n    return y;\n  } else {\n    // de-emphasis\n    midpoint = 2.0 * (midpoint - 0.5);\n    float y = pow(x, 1.0 / (1.0 - midpoint));\n    return y;\n  }\n}\n\n/**\n * Bias Ease-In and Ease-Out\n * Smoother curve than exponential ease\n * \n * @param  {float} x      The value to Ease (the input value to interpolate)\n * @param  {float} bias   Control parameter to vary the function from ease-out (0.0) to ease-in (1.0).\n *                        The midpoint is linear, no easing (0.5).\n * @param  {bool}  invert Invert the curve, e.g. to switch direction of interpolation.\n */\nfloat bias(float x, float bias, bool invert) {\n  if(invert)\n    bias = 1.0 - bias;\n\n  return x / ((1.0 / bias - 2.0) * (1.0 - x) + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Current fragment position in normalized coordinates (0-1)\n  vec2 uv = fragCoord / iResolution.xy;\n  // maintain aspect ratio\n  // uv.x *= iResolution.x / iResolution.y;\n\n  // Size of one pixel in normalized texture coordinates (0-1)\n  pixel_size = 1.0 / iResolution.y;\n\n  // Calculate the normalized time in the range [0, 1]\n  float normalized_time = mod(iTime, animation_duration) / animation_duration;\n  float oscillating_time = (0.5 + 0.5 * sin(2.0 * PI * normalized_time));\n\n  vec3 color = color_background;\n\n  // Shaping functions y=f(x)\n  // float ease_expo = exponential_ease(uv.x, 0.4);\n  // float ease_bias = bias(uv.x, 0.6, true);\n\n  // Animated shaping functions y=f(x)\n  float ease_expo = exponential_ease(uv.x, oscillating_time);\n  float ease_bias = bias(uv.x, oscillating_time, true);\n\n  // Mix a gradient with bias\n  color = mix(color, color_gradient, ease_bias);\n\n  // Plot the curves\n  color = plot(uv, ease_expo, color, vec3(0.57, 0.13, 0.13), 2.0);\n  color = plot(uv, ease_bias, color, vec3(0.0, 0.8, 0.0), 2.0);\n\n  // Output to screen\n  fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}