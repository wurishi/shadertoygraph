{"ver":"0.1","info":{"id":"DsKyRm","date":"1695914269","viewed":98,"name":"Cubemap Debug Helper","username":"UbuniX","description":"Cubemap Debug Helper","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","helper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//formula for transformation are taken from 16.5.4. Cube Map Face Selection\n//and 16.5.5. Cube Map Coordinate Transformation of vulkan specification.\n//I assume further, that WebGL has the same transformations.\n\nvec3 debugCubemapEquirectangular()\n{\n    float pi = 3.14159f;\n    vec2 uv = gl_FragCoord.xy/vec2(800, 400); // width and hight\n    \n    float alpha = 2.0f*pi * uv.x;\n    float beta = pi*uv.y - pi*0.5f;\n    float x = sin(beta) * cos(alpha);\n    float y = sin(beta) * sin(alpha);\n    float z = cos(beta);\n    \n    vec3 direction = vec3(x,y,z);\n    return texture(iChannel0, direction).xyz; //iChannel0 your cube map texture\n}\n\nvec3 debugCubemapUnfolded(float quadSize)\n{\n\n    //   Y+\n    //Z- X+ Z+ X-\n    //   Y-\n\n    float pi = 3.14159f;\n    \n    vec2 uv = mod(gl_FragCoord.xy, quadSize)/quadSize;\n    ivec2 grid = ivec2(gl_FragCoord.xy/quadSize);\n    \n    uv *= -1.0;\n    uv += 1.0;\n    \n    if(grid.x == 1 && grid.y == 2)\n    {\n        uv.xy = uv.yx;\n        uv.y *= -1.0;\n        uv.y += 1.0;\n    }\n    \n    if(grid.x == 1 && grid.y == 0)\n    {\n        uv.xy = uv.yx;\n        uv.x *= -1.0;\n        uv.x += 1.0;\n    }\n\n    \n    vec2 uv2 = (uv - vec2(0.5))*2.0f;\n    float a = length(uv2);\n    float rc = (1.0 - a)* sqrt(2.0f) + a;\n    \n    vec2 st = uv2* abs(rc);\n    vec3 direction = vec3(0.0f); \n    \n    if(grid.x == 1 && grid.y == 1)\n    {\n        direction = vec3(rc, -st.t, -st.s);\n    }\n    \n    if(grid.x == 0 && grid.y == 1)\n    {\n        direction = vec3(-st.s, -st.t, -rc);\n    }\n    if(grid.x == 2 && grid.y == 1)\n    {\n        direction = vec3(st.s, -st.t, rc);\n    }\n    if(grid.x == 3 && grid.y == 1)\n    {\n        direction = vec3(-rc, -st.t, st.s);\n    }\n    if(grid.x == 1 && grid.y == 2)\n    {\n        direction = vec3(st.s, rc, st.t);\n    }\n    if(grid.x == 1 && grid.y == 0)\n    {\n        direction = vec3(st.s, -rc, -st.t);\n    }\n    \n    return texture(iChannel0, direction).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float quadSize = min(iResolution.x/4.0, iResolution.y/3.0);\n    fragColor = vec4(debugCubemapUnfolded(quadSize), 1.0);\n}","name":"Image","description":"","type":"image"}]}