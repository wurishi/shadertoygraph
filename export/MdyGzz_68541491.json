{"ver":"0.1","info":{"id":"MdyGzz","date":"1453324138","viewed":407,"name":"Cellular creature","username":"TambakoJaguar","description":"I played with Voronoi pattern and used it to create a disgusting fantasy creature. It's just a bit slow because of the complexity, but still cool! :)\nUse your mouse to rotate the creature.\nHelp is welcome for optimization.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ugly","voronoi","subsurfacescattering","alien","cells","pulsating","creature","being","slimy","disgusting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\"Cellular creature\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nLamp lamps[3];\n\nvec3 campos = vec3(0., -0.5, 9.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 3.3;\n\nconst vec3 ambientColor = vec3(0.2);\nconst float ambientint = 0.16;\nconst vec3 speccolor = vec3(1., 0.75, 0.73);\n\nvec3 colors[3];\n\n//#define shadow\n#define ambocc\n#define specular\n#define ss_scatering\nconst float specint1 = 0.08;\nconst float specshin1 = 2.5;\nconst float specint2 = 0.6;\nconst float specshin2 = 100.;\nconst float aoint = 0.17;\nconst float shi = 0.8;\nconst float shf = 0.9;\nconst float ssstrmr = 1.35;\nconst float sssInt1 = 0.39;\nconst float sssInt2 = 0.55;\nconst vec3 sssColor1 = vec3(1.0, 0.55, 0.5);\nconst vec3 sssColor2 = vec3(0.25, 0.8, 0.35);\n\nconst float normdelta = 0.001;\nconst float maxdist = 15.;\n\nvec3 voronoiv;\nvec3 posr;\n\nfloat angle;\nfloat angle2;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\n// From https://www.shadertoy.com/view/ldl3Dl\nvec3 hash(vec3 x)\n{\n\tx = vec3(dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43356.5453123);\n}\n\n// From https://www.shadertoy.com/view/ldl3Dl and https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n\tfloat id = 0.0;\n    vec3 mg;\n    vec3 mr;\n    float res = 10.0;\n    for(int k=0; k<=1; k++)\n    for(int j=0; j<=1; j++)\n    for(int i=0; i<=1; i++)\n    {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = b - f + 0.45*hash(p + b);\n        float d = dot(r, r);\n\n        if(d < res)\n        {\n\t\t\tid = dot(p + b, vec3(1.0,57.0,113.0));\n            res = d;\t\n            mg = b;\n            mr = r;\n        }\n    }\n    \n    float md2 = 8.0;\n    for(int k=-1; k<=1; k++)\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=2; i++)\n    {\n        vec3 b = mg + vec3(float(i),float(j),float(k));;\n        vec3 r = b - f + 0.45*hash(p + b);\n\n        if(dot(mr-r,mr-r)>0.00001)\n            md2 = 1./(1./md2 + 0.53/dot((mr + r*1.07), normalize(r*1.07 - mr)));\n    }\n\n    return vec3(res, md2, abs(id));\n}\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\nvec3 creaturePulse(vec3 posr)\n{\n    posr*= vec3(1. - 0.08*sin(posr.x*2.3 + iTime*0.754) + 0.03*sin(posr.x*4.3 + iTime*0.12), 1. - 0.08*sin(posr.y*2.5 + iTime*0.982) + 0.03*sin(posr.x*4.1 + iTime*0.725), 1. - 0.08*sin(posr.y*2.8 + iTime*1.0843) + 0.03*sin(posr.x*4.9 + iTime*0.15));    \n    return posr;\n}\n\nvec3 creaturePulse2(vec3 posr)\n{\n    posr*= vec3(1.3 - 0.1*sin(posr.x*2.4 + iTime*0.765) + 0.04*sin(posr.x*4.34 + iTime*0.176), 0.95 - 0.12*sin(posr.y*2.66 + iTime*0.927) + 0.06*sin(posr.x*4.15 + iTime*0.648) + 0.02*sin(posr.z*8.02 + iTime*0.648), 1.3 - 0.1*sin(posr.y*2.72 + iTime*1.125) + 0.04*sin(posr.x*5.4+ iTime*0.18));    \n    posr.y-= 0.45;\n    return posr;\n}\n\nfloat map_s(vec3 pos)\n{    \n    vec3 posr = rotateVec2(pos);\n    posr = creaturePulse(posr);\n    return length(posr) -1.85;   \n}\n\nfloat map_s2(vec3 pos)\n{    \n    vec3 posr = rotateVec2(pos);\n    posr = creaturePulse2(posr);\n    return length(posr) -1.85;   \n}\n\nfloat map(vec3 pos)\n{   \n    posr = rotateVec2(pos);\n    \n    vec3 posr0=posr;\n    voronoiv = voronoi(4.*normalize(posr0));\n    posr = creaturePulse(posr);\n    \n    float cd = sign(mod(voronoiv.z, 2.)-0.5);\n    return length(pos) -1.8 - 0.15*(smoothstep(0.033, 0.067, voronoiv.y) + 5.*cd*smoothstep(0.065, 0.15, voronoiv.y))\n           - 0.008*texture(iChannel0, posr0.xy*4.3).r;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 3.5;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = min(map_s(pos), map_s2(pos));\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.98;\n  \t}\n    \n  \tfor (int i = 0; i < 18; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = min(map(pos), map_s2(pos));\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.12;\n  \t}\n\n    float o = smoothstep(0.1, 0.0, (map_s2(pos)-dist));\n        \n  \treturn vec2(t, o);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n    return norm;\n}\n\nvec3 getNormal2(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map_s2(pos + q.yxx) - map_s2(pos - q.yxx),\n                          map_s2(pos + q.xyx) - map_s2(pos - q.xyx),\n                          map_s2(pos + q.xxy) - map_s2(pos - q.xxy)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec3 fleshcol = vec3(.9, .2, .1);\n    vec3 col2 = mod(voronoiv.z, 10.)<9.?fleshcol:vec3(.1, .4, .3);\n    vec3 col_out = mix(vec3(1., .63, .42), col2, 4.*smoothstep(0.058, 0.11 + 0.008*sin(iTime*0.75 + voronoiv.z*5.), voronoiv.y));\n    return mix(col_out, fleshcol*0.5, 4.*smoothstep(0.073, 0., voronoiv.y));\n}\n\nvec3 obj_color2(vec3 norm, vec3 pos)\n{\n    return vec3(.25 + 0.3*dot(norm.xy, pos.yz) - 0.2*pos.y - 0.3*sin(iTime*0.927),\n                .5 - 0.2*pos.y + 0.2*sin(iTime*0.927),\n                .3 - 0.2*dot(norm.zx, pos.yx))*(0.7 + 0.3*texture(iChannel1, posr.xz*0.18 + vec2(0.01*iTime, 0.003*iTime)).rgb);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro + rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float specint = mix(specint1, specint2, pow(objnr, 6.));\n    float specshin = mix(specshin1, specshin2, pow(objnr, 5.));\n    float sssInt = mix(sssInt1, sssInt2, objnr);\n    vec3 sssColor = mix(sssColor1, sssColor2, objnr);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 6.) + 1. - shi;\n    #endif\n    \n\t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef ss_scatering\n\tfloat transmission = mix(map(pos + pl*ssstrmr), map_s2(pos + pl*ssstrmr), objnr)/ssstrmr;\n\tvec3 sssLight = sssColor*nlcol*smoothstep(0.0,1.0,transmission);\n    col = col*(1. - sssInt) + sssInt*sssLight;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = mix(getNormal(pos, normdelta), getNormal2(pos, normdelta), objnr);\n\n        // Coloring\n        col = mix(obj_color(norm, pos), obj_color2(norm, pos), objnr);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. + aoint*vec3(calcAO(pos, norm)) - aoint;\n        //col = vec3(calcAO(pos, norm));\n        #endif\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-1., 4.5, 10.), vec3(1., 1., 1.), 8.2, 0.1);\n  lamps[1] = Lamp(vec3(9., -3.5, 6.), vec3(0.93, 0.98, 1.0), 4.8, 0.1);\n  lamps[2] = Lamp(vec3(-5., 1.8, -5.), vec3(1.0, 0.75, 0.75), 10., 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    angle = 2.*pi*(iMouse.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse.y/iResolution.y - 0.5);\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}","name":"","description":"","type":"image"}]}