{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//globals\nconst vec3 background  = vec3(0.1, 0.1, 0.7);\nconst vec3 light_1     = vec3(4.0, 8.0,  3.0);\nconst vec3 light_2     = vec3(-4.0, 8.0, -7.0);\nconst vec2 eps         = vec2(0.001, 0.0);\nconst int maxSteps     = 64;\n\nvec3 shade(vec3 color, vec3 point, vec3 normal, vec3 rd)\n{\n\t\n\tvec3 dtl       = normalize(light_1 - point);\n\tfloat diffuse  = dot(dtl, normal); //diffuse\n\tfloat specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular\n\tvec3 c = (diffuse + specular) * color * 0.85;\n\t\n\tdtl      =  normalize(light_2 - point);\n\tdiffuse  = dot(dtl, normal); //more diffuse\n\tspecular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular\n\treturn clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);\n}\n\n// estimates the distance from Point p to implicit given geometry\nfloat distanceEstimator(vec3 p)\n{\n\tfloat t = mod(iTime, 70.0);\n\tvec3 holeP = p - vec3(0.5, 0.5, -3.0);\n\tp = p - vec3(t, t * 0.5, t * 0.3);\n\t\n\tfloat rpm = 1.0;\n\tvec3 repeater = mod(p, vec3(rpm * 1.6, rpm, rpm)) - 0.5 * vec3(rpm * 1.6, rpm, rpm);\n\t//vec3 repeater = fract(p) - vec3(0.5);\n\tfloat sphere = length(repeater) - 0.06 * rpm;\n\t\n\tfloat cylinder = length(repeater.xz) - 0.015 * rpm;\n\tcylinder =  min(cylinder, length(repeater.zy) - 0.015 * rpm);\n\tcylinder =  min(cylinder, length(repeater.xy) - 0.015 * rpm);\n\t\n\tfloat grid = min(cylinder, sphere);\n\t\n\t// just a big sphere, everything outside the sphere is not shown\n\tfloat eater  = length(holeP) - 3.3;\n\treturn max(grid, eater);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tfloat ratio  = iResolution.x / iResolution.y;\n\tvec2 fragment = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 uv = -1.0 + 2.0 * fragment;\n\tuv.x *= ratio;\n\t\n\t//camera setup taken from iq's raymarching box: https://www.shadertoy.com/view/Xds3zN\n\tvec3 ta = vec3( 0.0, 0.0, -3.5 );\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*iTime + 6.0), 3.0, 0.5 + 3.2*sin(0.1*iTime + 6.0) );\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 2.5*cw );\n\t\n\tvec3 col             = background;\n\tfloat t              = 0.0;\n\tvec3 p               = vec3(0.0);\n\t\n\t// march\n\tfloat steps  = 0.0;\n\tfloat addAll = 0.0;\n\tfor ( int i = 0; i < maxSteps; i++) {\n\t\tp = ro + t * rd;\n\t\tfloat distanceEstimation = distanceEstimator(p);\n\t\tif (distanceEstimation > 0.005) {\n\t\t\tt += distanceEstimation;\n\t\t\taddAll += smoothstep(0.0, 1.0, distanceEstimation);\n\t\t\tsteps += 1.0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//float c = float(i) / float(maxSteps);\n\t//c = pow(c, 0.25);\n\t//col  = vec4(c, c, c, 1.0);\n\t\n\tvec3 c = vec3(0.35, 0.05, 0.0);//(cos(p * 0.5) + 1.0) / 2.0;\n\tvec3 normal = normalize(vec3(distanceEstimator(p + eps.xyy) - distanceEstimator(p - eps.xyy),\n\t\t\t\t\t\t\t\t distanceEstimator(p + eps.yxy) - distanceEstimator(p - eps.yxy),\n\t\t\t\t\t\t\t\t distanceEstimator(p + eps.yyx) - distanceEstimator(p - eps.yyx)));\n\t\n\tcol = shade(c, p, normal, rd);\n\tcol = mix(col, background, steps / float(maxSteps));\n\tcol = pow(col, vec3(0.8));\n\t\n\tfloat glow = smoothstep(steps, 0.0, addAll) * 1.4;\n\tcol = vec3(glow) * col;\n\tfragColor = vec4(col, 1.0); \n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsXGWN","date":"1370186076","viewed":1678,"name":"Glowing Grid","username":"bekre","description":"Raymarching with some csg (only the inner part of the sphere is shown) and glow effect.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","glow"],"hasliked":0,"parentid":"","parentname":""}}