{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Copyright Per Bloksgaard, 2014 - https://perbloksgaard.dk\n\n#define PI 3.14159265358979\n\n// Convert HSL colorspace to RGB. http://en.wikipedia.org/wiki/HSL_and_HSV\nvec3 HSLtoRGB(in vec3 c)\n{\n\tvec3 rgb = clamp(abs(mod(c.x+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n\treturn c.z+c.y*(rgb-0.5)*(1.-abs(2.*c.z-1.));\n}\n\nvec3 HSL2RGB_CubicSmooth(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb*rgb*(3.0-2.0*rgb); // iq's cubic smoothing.\n    return c.z+ c.y*(rgb-0.5)*(1.-abs(2.*c.z-1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.+2.*fragCoord.xy/iResolution.xy)*vec2(iResolution.x/iResolution.y,1.);\n\tfloat fAngle = iTime*0.4;\n\tfloat h = atan(uv.x,uv.y) - fAngle;\n\tfloat x = length(uv);\n\tfloat a = -(0.6+0.2*sin(iTime*3.1+sin((iTime*0.8+h*2.0)*3.0))*sin(iTime+h));\n\tfloat b = -(0.8+0.3*sin(iTime*1.7+sin((iTime+h*4.0))));\n\tfloat c = 1.25+sin((iTime+sin((iTime+h)*3.0))*1.3)*0.15;\n\tfloat l = a*x*x + b*x + c;\n\t//vec3 hsl_standard = HSLtoRGB(vec3(h*3./PI,1.,l));\n\tvec3 hsl_cubic = HSL2RGB_CubicSmooth(vec3(h*3.0/PI,1.,l));\n\tfragColor = vec4(hsl_cubic,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sS3Dc","date":"1394131615","viewed":2314,"name":"HSL ColorSpace","username":"bloxard","description":"I needed to investigate and understand the HSL colorspace for a computer-vision image filter and I thought to myself 'How can I visualize this quickly?' and then this shader just sort of happened. :)","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["plasma","hsl","colorspectrum"],"hasliked":0,"parentid":"","parentname":""}}