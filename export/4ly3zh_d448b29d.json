{"ver":"0.1","info":{"id":"4ly3zh","date":"1472941458","viewed":178,"name":"[OLD] Simple shading ","username":"Sabouh","description":"Displaying a light and applying shading to the objects accordingly.\n+ cheap Anti-aliasing\n\nYou can move the camera using your mouse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Inspired by inigo quilez's articles \n https://iquilezles.org/articles/distfunctions\n + Romain Vergne's lectures http://maverick.inria.fr/~Romain.Vergne/blog/\n Shader : Simple Shading\n Author Sabouh\n*/\n \n//to get a higher float precision\nprecision highp float;\nconst float PI = 3.1415926535897932384626433832795;\nconst int PLANE_NB = 3;\nconst int SPHERE_NB = 2;\nconst int OBJ_NB = PLANE_NB + SPHERE_NB;\nconst int LIGHT =  OBJ_NB+1;\nconst int MAX_NB = 10;\nconst float MAX_VALUE = 100.;\nconst int MAX_INT_VALUE = 100;\nconst vec4 background = vec4(1.,1.,1.,1.);\n\n//*******************************Tools**************************\n//Structures definition\n\n//Light\nstruct Light{\n\tvec3 p;//position\t\n};\n\n//MarchingPack\nstruct MarchingPack{\n\tfloat dist;\n\tfloat index;\n\tbool hit;\n\t\n};\n\n//Ray\nstruct Ray{\n\tvec3 o; //origin\n\tvec3 d; //direction\n};\n\n//Camera\nstruct Camera{\n\tvec3 e;//eye\n    vec3 r;//right\n    vec3 u;//up\n    vec3 v;//view\n\t\n};\n\nstruct Color{\n\tvec4 c;\n};\n\n//Plane\nstruct Plane{\n\tvec3 n; //normal\n\tfloat d; //offset\n};\n\n//Sphere\nstruct Sphere{\n\tvec3 c; //center\n\tfloat r; //rayon\n};\n\n//Distance operations\n\n//union\nvec2 opU(vec2 d1,vec2 d2){\n\treturn d1.x<d2.x ? d1 : d2; //if d1.x < d2.x return d1 else d2\n}\n\n//substraction\nfloat opS(float d1, float d2){\n\treturn max(-d1,d2);\n}\n\n//intersection\nfloat opI(float d1,float d2){\n\treturn max(d1,d2);\n}\n\n\n//------------------\nfloat fPlane(Ray r,float t,vec4 n){\n    vec3 norma = normalize(n.xyz);\n    vec3 norm = n.xyz;\n    vec3 pos = r.o +r.d*t;\n    vec3 Q = norma*n.w ; //Q is in Plane\n    \n    if(dot(r.d,norm ) == 0.){\n       if(dot(r.o-Q,norm)==0.){\n        \treturn 0.;\n       }else{\n        \treturn MAX_VALUE;\n       }\n    }else{\n        if(dot(Q-r.o,norm)  /dot(r.d,norm) < 0.){\n            return MAX_VALUE;\n        }else if(dot(Q-pos,norm) == 0.){\n            return 0.;\n        }else{\n    \t\treturn  ( dot(Q-r.o,norm)  /dot(r.d,norm) ) -t;\n        }\n    }\n        \n}\n\nfloat fSphere(Ray r, float t,vec4 o){\n    vec3 pos = r.o+r.d*t;\n    if(dot(o.xyz-pos,r.d) >=0.){\n        return distance(o.xyz,pos) - o.w ;\n    }else{\n        if(length(o.xyz-pos) <= o.w ){\n            return distance(o.xyz,pos) - o.w ;\n        }else{\n            return MAX_VALUE;\n        }\n    }\n}\n\n//----------\n\n//intersection Ray-Sphere\nvec2 intersectSphere(Ray r, vec4 o, float index){\n\tfloat a,b,c;\n\ta = dot(r.d,r.d);\n\tb = dot(2.*(r.o-o.xyz),r.d);\n\tc =(dot(r.o-o.xyz,r.o-o.xyz)) - pow(o.w,2.) ;\n\t\n\tfloat delta =  pow(b,2.)-4.*a*c ;\n\tif(delta <0.){\n\t\treturn vec2(MAX_VALUE,-1);\n\t}else{\n\t\tfloat t1,t2;\n\t\tt1 = (-b + sqrt(delta) )/(2.*a);\n\t\tt2 = (-b - sqrt(delta) )/(2.*a);\n\t\tif(t1 <0.){\n\t\t\treturn vec2(t2,index);\n\t\t}else if(t2<0.){\n\t\t\treturn vec2(t1,index);\n\t\t}else{\n\t\t\treturn t1<t2 ? vec2(t1,index) : vec2(t2,index);\n\t\t}\n\t}\n}\n\n//intersection Ray-Plane\nvec2 intersectPlane(Ray r, vec4 n,float index){\n    vec3 norm = normalize(n.xyz);\n\tfloat t = -( n.w + dot(r.o,norm)) / dot(r.d,norm);\n\tif(t>=0.){\n\t\treturn vec2(t,index);\n\t\t\n\t}else{\n\t\treturn vec2(MAX_VALUE,-1);\n\t}\n}\n\n//manage intersections \nvec2 checkIntersection(Ray r, vec4 o, float index){\n\tif(index <= float(PLANE_NB) ){\n\t\treturn intersectPlane(r,o,index);\n\t}else{\n\t\treturn intersectSphere(r,o,index);\n\t}\n}\n\n//Init\nvec4 getColor(float index){\n\tif(index == 1.){\n\t\treturn vec4(0.,1.,1.,1.); //cyan\n\t}else if(index == 2.){\n\t\treturn vec4(0.,1.,0.,1.); //green\n\t}else if(index == 3.){\n\t\treturn vec4(0.,0.,1.,1.); //blue\n\t}else if(index == 4.){\n\t\treturn vec4(1.,0.,0.,1.); //red\n\t}else if(index == 5.){ \n\t\treturn vec4(1.,0.,1.,0.); //magenta\n\t}else if(index == float(LIGHT)){ \n\t\treturn vec4(1.,1.,0.,0.); //yellow\n\t}else{\n\t\treturn background;//ERROR WHITE\n\t\t\n\t}\n}\n\nvec4 createSphere(vec3 c, float r, float phi, float teta){\n\tfloat x,y,z;\n\tx = c.x + r*sin(phi)*cos(teta);\n\ty = c.y + r*sin(phi)*sin(teta);\n\tz = c.z + r*cos(phi);\n    return vec4(x,y,z,r);\n    \n}\n\nvec4 getObject(float index){\n    vec4 res ;\n\tif(index == 1.){\n\t\tres =  vec4(0.,0.,1.,0.); //Plane (x,y)\n\t}else if(index == 2.){\n\t\tres = vec4(1.,0.,0.,0.); //Plane (y,z)\n\t}else if(index == 3.){\n\t\tres = vec4(0.,1.,0.,0.); //Plane (x,z)\n\t}else if(index == 4.){\n\t\tres = createSphere(vec3(2.,2.,2.),1., PI/2., PI/2.*iTime); \n\t}else if(index == 5.){ \n\t\tres = createSphere(vec3(2.,2.,2.), 0.8, PI/2.*iTime, PI); \n\t}else if(index == float(LIGHT)){ \n\t\tres = createSphere(vec3(2.,1.,4.), 1., PI*iTime, PI); \n\t}else{\n\t\tvec4 res = vec4(MAX_VALUE,MAX_VALUE,MAX_VALUE,MAX_VALUE);//ERROR \n\t\t\n\t}\t\n    return res;\n}\n\n\n\nvec2 map(Ray r,float t){\n\tvec2 res =  vec2(  fPlane(r,t,getObject(1.)  ),1.) ;\n\tfor(int i = 2;i<= OBJ_NB;i++){\n\t\tif(i<=PLANE_NB){\n\t\t\tres = opU(res, vec2(  fPlane(r,t,getObject(float(i))) ,float(i)) );\n\t\t}else{\n\t\t\tres = opU(res, vec2( fSphere(r,t,getObject(float(i)) ),float(i)) );\t\t\n\t\t}\n\t}\n\treturn res;\n}\n\nvec4 directIllumination(Light l,vec3 pos,float dist, float index,float D){\n\t//compute the normale\n\tvec3 n;\n    if(index <= float(PLANE_NB)){\n       \tn = normalize( getObject(index).xyz );\n    }else{\n       \tn = normalize( pos - getObject(index).xyz );\n    }\n\t//compute intensity\n\tfloat intensity =   dot(normalize(l.p -pos),n) ;\n\t//float intensity = min(1., max(0.,dot(l.p -pos,n)));\n\t\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\tvec3 color = getColor(index).xyz;\n\t\treturn vec4(intensity*color,1.0);\n    }else if(mod(iTime,9.) <6. ){\n    \t//height map\n        float h = intensity* (dist/(D));\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4(intensity*n,1.0) ;\n    \t}else{\n\t\t\treturn vec4(intensity*n,1.0);\n    \t}\n    }\n}\n\nvec4 displayColor(vec3 pos,float dist, float index,float D){\n\t\n\t\n    if(mod(iTime,9.) <3.){\n    \t//color map\n\t\treturn getColor(index);\n    }else if(mod(iTime,9.) <3. ){\n    \t//height map\n        float h = dist/(D);\n     \treturn vec4(h,h,h,1.);\n    }else{\n    \t//normal map\n    \tif(index <= float(PLANE_NB)){\n        \treturn vec4((getObject(index)).xyz,1.0) ;\n    \t}else{\n        \tvec3 n = pos - getObject(index).xyz;\n\t\t\treturn vec4(n,1.0);\n    \t}\n    }\n\t\n}\n\n//ray Marching Algorithme\nMarchingPack rayM(Ray r){\n\t\n\tfloat j;\n\tfloat t = 0.00;\n\tvec2 d;\n\tfloat epsilon = 0.0017;\n\tvec3 pos;\n\tfor(int i = 0; i< MAX_INT_VALUE;i++){\n        pos = r.o+ r.d*t;\n\t\td = map(r,t);\n\t\t\n        if( d.x <= epsilon){\n\t\t\tMarchingPack mp = MarchingPack(t,d.y,true);\n\t\t\treturn mp;\n        }\n        \n\t\t\n\t\tt = t + d.x;\t\n\t}\n    \n\tMarchingPack mp = MarchingPack(t,d.y,false);\n\treturn mp;\t\n\t\n\t\n}\n//RayMarching\nvec4 rayMarching(vec2 fragCoord){\n\t//cast a ray w/ camera\n\t\n\t//(x,y) in range [-1;1] \n\tfloat x = (2.*fragCoord.x - iResolution.x )/iResolution.x;\n\tfloat y = (2.*fragCoord.y - iResolution.y )/iResolution.y;\n    \n\tfloat x1 = (2.*fragCoord.x+1. - iResolution.x )/iResolution.x;\n\tfloat y1 = (2.*fragCoord.y+1. - iResolution.y )/iResolution.y;\n    \n\tfloat x2 = (2.*fragCoord.x+1. - iResolution.x )/iResolution.x;\n\tfloat y2 = (2.*fragCoord.y-1. - iResolution.y )/iResolution.y;\n    \n\tfloat x3 = (2.*fragCoord.x-1. - iResolution.x )/iResolution.x;\n\tfloat y3 = (2.*fragCoord.y+1. - iResolution.y )/iResolution.y;\n    \n\tfloat x4 = (2.*fragCoord.x-1. - iResolution.x )/iResolution.x;\n\tfloat y4 = (2.*fragCoord.y-1. - iResolution.y )/iResolution.y;\n    \n\tfloat xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;\n\tfloat yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;\n\t\n\t//camera\n\tCamera c;\n    vec3 u1;\n\tc.e = vec3(xMouse*-10.,yMouse*-10.,5.);//camera\n\tc.v = normalize(-c.e);\n\tu1 = vec3(0.,1.,0.);\n\tc.r = normalize(cross(c.v,u1));\n\tc.u = normalize(cross(c.r,c.v));\n\t\n\t//Ray\n\tRay r;\n\tfloat D = 1./tan(PI/4.);\n\tr.o = c.e;\n\tvec3 rd = x*c.r + y *c.u+ D*c.v;\n\tr.d = normalize(rd);\n\t\n\tRay r1,r2,r3,r4;\n\tr1.o = c.e;\n\tr2.o = c.e;\n\tr3.o = c.e;\n\tr4.o = c.e;\n\tvec3 rd1 = x1*c.r + y1 *c.u+ D*c.v;\n\tr1.d = normalize(rd1);\n\tvec3 rd2 = x2*c.r + y2 *c.u+ D*c.v;\n\tr2.d = normalize(rd2);\n\tvec3 rd3 = x3*c.r + y3 *c.u+ D*c.v;\n\tr3.d = normalize(rd3);\n\tvec3 rd4 = x4*c.r + y4 *c.u+ D*c.v;\n\tr4.d = normalize(rd4);\n    \n\tLight l = Light( getObject(float(LIGHT)).xyz );\n\tvec4 color,color1,color2,color3,color4;\n\tMarchingPack rmp = rayM(r);\n    vec3 pos = r.o+r.d*rmp.dist;\n\tif(rmp.hit){\n        //return\n\t\tcolor= directIllumination(l,pos,rmp.dist,rmp.index,c.e.z*2.);\n\t}else{\n        //return\n\t\tcolor= background;\n\t}\n    \n\tMarchingPack rmp1 = rayM(r1);\n    vec3 pos1 = r1.o+r1.d*rmp1.dist;\n\tif(rmp1.hit){\n\t\tcolor1= directIllumination(l,pos1,rmp1.dist,rmp1.index,c.e.z*2.);\n\t}else{\n\t\tcolor1= background;\n\t}\n    \n\tMarchingPack rmp2 = rayM(r2);\n    vec3 pos2 = r2.o+r2.d*rmp2.dist;\n\tif(rmp2.hit){\n\t\tcolor2= directIllumination(l,pos2,rmp2.dist,rmp2.index,c.e.z*2.);\n\t}else{\n\t\tcolor2= background;\n\t}\n    \n\tMarchingPack rmp3 = rayM(r3);\n    vec3 pos3 = r3.o+r3.d*rmp3.dist;\n\tif(rmp3.hit){\n\t\tcolor3= directIllumination(l,pos3,rmp3.dist,rmp3.index,c.e.z*2.);\n\t}else{\n\t\tcolor3= background;\n\t}\n    \n\tMarchingPack rmp4 = rayM(r4);\n    vec3 pos4 = r4.o+r4.d*rmp4.dist;\n\tif(rmp4.hit){\n\t\tcolor4= directIllumination(l,pos4,rmp4.dist,rmp4.index,c.e.z*2.);\n\t}else{\n\t\tcolor4= background;\n\t}\n    \n    //AA\n    //return color;\n    return (color+ (color1+color2+color3+color4)/4.)/2.;\n}\n\n\n\n//************************Application********************************************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t  \n\tfragColor = rayMarching(fragCoord);\n    \n}","name":"Image","description":"","type":"image"}]}