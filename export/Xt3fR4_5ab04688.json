{"ver":"0.1","info":{"id":"Xt3fR4","date":"1538701433","viewed":90,"name":"Dandelion-Nature","username":"jkashimura","description":"HW","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n//sphere\nfloat distSphere(vec3 v, float r){ //distance of sphere\n\treturn length(v) - r;\n}\n\nfloat sphere(vec3 v, float r){\n   //tiny sphere that goes in and out\n  float minDist = distSphere(v + vec3(cos(iTime), 0., 0.), 0.3);\n  float dist = distSphere(v - vec3(.7, 0.15, 0.), 0.05) + 0.005 * sin(iTime);\n    minDist = min(minDist, dist);\n  return minDist;\n}\n\nvec4 yay(vec2 v){\n    vec4 col = vec4(.9,.65,.1, 1.);\n    \n    float d = length(v); \n    d = length(v-vec2(.25,-.2));\n    \n    return col;\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\n// Converts v to Polar Coordinates, then repeat based on r\nvoid pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n}\n//=======================\n\n\nShape orbs(vec3 c){\n  Shape shape;\n  float s;\n  shape.dist = 2000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n\n\n  vec3 i = c;\n    i.x = abs(i.x)-(2.5+cos(iTime)*.001);\n    i.zx *= rot(c.x*0.1+iTime*0.5); // Twist Coord Sys\n    i.yz *= rot(c.z*0.2+iTime*0.5);\n    //i.xy *= rot(c.z*0.1+iTime*0.5);\n    pModPolar(i.xy, 18.); // Twist Repeat\n    i.x -= abs(cos(iTime*0.5))*3.; // Offset from origin\n    i.y -= abs(cos(iTime)*.01);\n    i.z -= abs(sin(iTime)*.01);\n    //pMod1(i.z, 3.);\n  \ts = sphere(i, 10.); // Create sphere\n\n    // Plug-in distance to object and color\n    vec4 color = vec4(1.,1.,.95+(sin(iTime)*0.1),.5);\n  \tshape.dist = s;\n  \tshape.color = color;\n\t\n  return shape;\n}\n\n\n// Map all objects within scene\nShape map(vec3 c){\n  Shape orb = orbs(c);\n  return orb;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(cos(iTime), sin(iTime), -10.); // Setup Camera\n  vec3 f = normalize(vec3(v, 1.)); // Frustrum\n    \n  vec3 scene = cam;\n  fragColor = vec4(0.); // Background Color\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(cos(z)); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist; // Step to SDF\n     \n      \n\n    // Output to screen\n    fragColor = vec4(.7+cos(iTime)*0.1,0.7+cos(iTime)*.1,1.,1.0);\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}