{"ver":"0.1","info":{"id":"l3tGRl","date":"1716901343","viewed":68,"name":"rt_practice_3","username":"Mooooonk","description":"added glass and emission material","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Author: Mooooonk\n*/\n\nprecision highp float;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Author: Mooooonk\n*/\n\nprecision highp float;\n\n#define MAXITER 1500\n#define MAXSTEP 8\n#define MAXDIST 10000.0\n#define SCALE 1000.0\n#define VIEWPOINT 0.5\n#define EPSILON 0.00001\n#define LOSS 0.9\n#define SAMPLES 1\n#define MATCOUNT 5\n#define OBJCOUNT 19 \n#define OBJ_SPHERE_ 1\n#define OBJ_PLANE_ 2\n#define MAT_GLOSSRY 1\n#define MAT_DIFFUSE 2\n#define MAT_TRANSPARENT 3\n\n#define BLACK vec4(0.0,0.0,0.0,1.0)\n#define RED vec4(1.0, 0.0, 0.0, 1.0)\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define NULL vec4(0.0, 0.0, 0.0, 0.0)\n#define GRAY vec4(0.2706, 0.2706, 0.2706, 1.0)\n\nvec2 Coord;\nvec2 Center;\nvec3 Center_3d;\n\nuint global_seed;\n\nstruct Ray {\n    vec3 origin_;\n    vec3 target_;\n};\n\nstruct HittenObj {\n    int id_;\n    vec3 position_;\n    vec3 normal_;\n    vec3 in_;\n    bool in_out_;\n};\n\nstruct RayResult {\n    int iter_;\n    int id_;\n    float dist_;\n    vec3 position_;\n    vec3 normal_;\n    vec4 color_;\n};\n\nstruct DistRecord {\n    int id_;\n    float dist_;\n};\n\nstruct HitRecord {\n    Ray ray_;\n    int id_;\n    vec3 normal_;\n    int type_;\n    bool in_out_;\n};\n\nstruct Material {\n    vec4 base_color_;\n    vec4 reflect_color_;\n    vec4 emission_color_;\n    vec4 transprant_color_;\n    float roughness_;\n    float diffusion_;\n    float emission_;\n    float absorbtion_;\n    float ior_;\n    float transparency_;\n};\n\nstruct Object {\n    int type_;\n    int material_;\n    vec3 center;\n    float para_1;\n    vec3 vec_1;\n    vec3 vec_2;\n};\n\nstruct World {\n    vec4 color_;\n    vec3 sun_;\n    vec4 sun_color_;\n    float sun_size_;\n    float lux_;\n};\n\nMaterial materials[MATCOUNT];\nObject objects[OBJCOUNT];\nWorld world;\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 hsva2rgba(vec4 hsva) {\n    vec3 rgb = hsv2rgb(hsva.xyz);\n    return vec4(rgb, hsva.a);\n}\n\nfloat fresnelSchlick(float cosTheta, float refIdx) {\n    float R0 = (1.0 - refIdx) / (1.0 + refIdx);\n    R0 = R0 * R0;\n    return R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat calculateFresnel(vec3 i, vec3 n, float ior) {\n    float cosTheta = dot(- i, n);\n    float eta = ior;\n    if(cosTheta < 0.0) {\n        cosTheta = - cosTheta;\n        eta = 1.0 / ior;\n    }\n\n    float sinTheta2 = eta * eta * (1.0 - cosTheta * cosTheta);\n    if(sinTheta2 > 1.0) {\n        return 1.0;\n    }\n    float cosTheta2 = sqrt(1.0 - sinTheta2);\n\n    float reflectance = fresnelSchlick(cosTheta, eta);\n\n    return reflectance;\n}\n\nuint wang_hash(uint seed) {\n    seed = (seed ^ 61U) ^ (seed >> 16U);\n    seed *= 9U;\n    seed = seed ^ (seed >> 4U);\n    seed *= 0x27d4eb2dU;\n    seed = seed ^ (seed >> 15U);\n    return seed;\n}\n\nfloat hash() {\n    uint n = wang_hash(global_seed);\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    global_seed = n;\n    return float(n & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat hash(float p) {\n    p = fract(p * 0.1031);\n    p += p + 19.19;\n    uint n = uint(fract(p * 95.4453) * 4294967295.0);\n    n = wang_hash(n);\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    global_seed = n;\n    return float(n & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 randomUnitVector() {\n    float u = hash();\n    float v = hash();\n\n    float theta = u * 6.28318530718;\n    float phi = acos(2.0 * v - 1.0);\n\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    float x = sinPhi * cosTheta;\n    float y = sinPhi * sinTheta;\n    float z = cosPhi;\n\n    return vec3(x, y, z);\n}\n\nvec3 ray_at_(Ray ray_, float len_) {\n    return ray_.origin_ + len_ * ray_.target_;\n}\n\nMaterial mat_base_diffuse(vec4 color_, float diffusion_) {\n    return Material(color_, color_, NULL, NULL, 0.0, diffusion_, 0.0, 0.2, 1.0, 1.0);\n}\n\nMaterial mat_base_glossry(vec4 color_, float roughness_) {\n    return Material(color_, color_, NULL, NULL, roughness_, 0.0, 0.0, 0.2, 1.0, 1.0);\n}\n\nMaterial mat_base_matte_plastic(vec4 color_, float roughness_, float diffusion_) {\n    return Material(color_, color_, NULL, NULL, roughness_, diffusion_, 0.0, 0.2, 1.0, 1.0);\n}\n\nMaterial mat_emission(vec4 color_, float emission_) {\n    return Material(NULL, NULL, color_, NULL, 0.0, 0.0, emission_, 0.2, 1.0, 1.0);\n}\n\nMaterial mat_glass(vec4 color_, float roughness_, float ior_, float trans_) {\n    return Material(NULL, color_, NULL, color_, roughness_, 0.0, 0.0, 0.0, ior_, trans_);\n}\n\nObject obj_sphere(int id_, vec3 center_, float radius) {\n    return Object(OBJ_SPHERE_, id_, center_, radius, vec3(0.0), vec3(0.0));\n}\n\nObject obj_plane(int id_, vec3 center_, vec3 orient_) {\n    return Object(OBJ_PLANE_, id_, center_, 0.0, center_, orient_);\n}\n\nfloat dist_sphere(Object obj, vec3 pos_) {\n    float radius = obj.para_1;\n    return abs(length(pos_ - obj.center) - radius);\n}\n\nfloat dist_plane(Object obj, vec3 pos_) {\n    return abs(dot(pos_ - obj.vec_1, obj.vec_2));\n}\n\nvec3 norm_sphere(Object obj, vec3 pos_, vec3 in_) {\n    vec3 norm = normalize(pos_ - obj.center);\n    return norm;\n}\n\nvec3 norm_plane(Object obj, vec3 pos_,vec3 in_) {\n    vec3 norm = obj.vec_2;\n    if(dot(norm, in_) <= 0.0) return norm;\n    else return - norm; \n}\n\nfloat compute_dist(Object obj, vec3 pos_) {\n    if(obj.type_ == OBJ_SPHERE_)\n        return dist_sphere(obj, pos_);\n    else if(obj.type_ == OBJ_PLANE_)\n        return dist_plane(obj, pos_);\n    else\n        return MAXDIST;\n}\n\nDistRecord dist_field(vec3 pos_) {\n    int i = 0;\n    float min_ = MAXDIST;\n    int id_ = - 1;\n    while(i < OBJCOUNT) {\n        float curr_ = compute_dist(objects[i], pos_);\n        if(curr_ < min_) {\n            min_ = curr_;\n            id_ = i;\n        }\n        i ++;\n    }\n    return DistRecord(id_, min_);\n}\n\nvec3 compute_norm(Object obj, vec3 pos_, vec3 in_) {\n    if(obj.type_ == OBJ_SPHERE_)\n        return norm_sphere(obj, pos_, in_);\n    else if(obj.type_ == OBJ_PLANE_)\n        return norm_plane(obj,pos_ ,in_);\n    else\n        return vec3(1.0, 0.0, 0.0);\n}\n\nHitRecord ray_gen(HittenObj last_) {\n    Material mat = materials[objects[last_.id_].material_];\n    HitRecord comp_;\n    Ray ans_;\n    ans_.origin_ = last_.position_;\n    vec3 norm = compute_norm(objects[last_.id_], last_.position_, last_.in_);\n    if(mat.transparency_ == 1.0) {\n        if(hash() < mat.diffusion_) {\n            vec3 diff = randomUnitVector();\n            if(dot(diff, last_.normal_) < 0.0) {\n                ans_.target_ = - diff;\n            } else {\n                ans_.target_ = diff;\n            }\n            comp_.type_ = MAT_DIFFUSE;\n        } else {\n            ans_.target_ = normalize(reflect(last_.in_, norm) + mat.roughness_ * randomUnitVector());\n            comp_.type_ = MAT_GLOSSRY;\n        }\n    } else {\n        if(last_.in_out_ == true) {\n            float p_reflect = calculateFresnel(last_.in_, norm, 1.0 / mat.ior_);\n            if(hash() < p_reflect || hash() < mat.transparency_) {\n                ans_.target_ = normalize(reflect(last_.in_, norm) + mat.roughness_ * randomUnitVector());\n                comp_.type_ = MAT_GLOSSRY;\n            } else {\n                ans_.target_ = normalize(refract(last_.in_, norm, 1.0 / mat.ior_) + mat.roughness_ * randomUnitVector());\n                comp_.type_ = MAT_TRANSPARENT;\n            }\n        } else {\n            float p_reflect = calculateFresnel(last_.in_, - norm, mat.ior_);\n            if(hash() < p_reflect) {\n                ans_.target_ = normalize(reflect(last_.in_, - norm) + mat.roughness_ * randomUnitVector());\n                comp_.type_ = MAT_GLOSSRY;\n            } else {\n                ans_.target_ = normalize(refract(last_.in_, - norm, 1.0 / mat.ior_) + mat.roughness_ * randomUnitVector());\n                comp_.type_ = MAT_TRANSPARENT;\n            }\n        }\n    }\n    comp_.normal_ = norm;\n    comp_.id_ = last_.id_;\n    comp_.ray_ = ans_;\n    return comp_;\n}\n\nvec4 mat_shade(HitRecord rec_, vec4 color_) {\n    Material mat = materials[objects[rec_.id_].material_];\n    float lumi = color_.w * (1.0 - mat.absorbtion_);\n    if(rec_.type_ == MAT_DIFFUSE) {\n        if(objects[rec_.id_].type_ == OBJ_PLANE_) {\n            if((int(rec_.ray_.origin_.x) + int(rec_.ray_.origin_.y)) % 2 == 0) {\n                color_ += WHITE * lumi;\n            } else color_ += BLACK * lumi;\n        } else color_ += mat.base_color_ * lumi;\n    }\n    if(rec_.type_ == MAT_GLOSSRY) {\n        if(objects[rec_.id_].type_ == OBJ_PLANE_) {\n            if((int(rec_.ray_.origin_.x) + int(rec_.ray_.origin_.y)) % 2 == 0) {\n                color_ += WHITE * lumi;\n            } else color_ += BLACK * lumi;\n        } else color_ += mat.reflect_color_ * lumi;\n    }\n    if(rec_.type_ == MAT_TRANSPARENT) {\n        color_ += mat.transprant_color_ * lumi;\n    }\n    color_ += mat.emission_color_ * mat.emission_;\n    color_.w = lumi;\n    return color_;\n}\n\nvec4 world_shade(HitRecord rec_) {\n    vec4 color_ = world.color_;\n    float angle = dot(rec_.ray_.target_, world.sun_);\n    if(angle < 0.0 && - angle > world.sun_size_) {\n        color_ += - angle * world.sun_color_;\n        color_.w = - angle * world.lux_;\n    } else {\n        color_.w = 0.0;\n    }\n    return color_;\n}\n\nvec4 compute_color_(HitRecord record[int(MAXSTEP)], int step_) {\n    vec4 ans_ = NULL;\n    do {\n        HitRecord curr_ = record[step_];\n        if(curr_.id_ == - 1) {\n            ans_ = world_shade(curr_);\n        } else {\n            ans_ = mat_shade(curr_, ans_);\n        }\n        step_ -= 1;\n    } while(step_ >= 0);\n    ans_.w = 1.0;\n    return ans_;\n}\n\nRayResult hit_(Ray ray_) {\n    float prog_ = 0.0;\n    HittenObj curr_;\n    curr_.id_ = - 1;\n    curr_.position_ = ray_.origin_;\n    curr_.normal_ = vec3(1.0, 0.0, 0.0);\n    curr_.in_ = ray_.target_;\n    int iter_ = 0;\n    int step_ = 1;\n    HitRecord record[int(MAXSTEP)];\n    while(step_ <= MAXSTEP) {\n        DistRecord dist_;\n        while(iter_ <= MAXITER) {\n            dist_ = dist_field(ray_at_(ray_, prog_));\n            prog_ += dist_.dist_;\n            iter_ += 1;\n            if(dist_.dist_ >= MAXDIST)\n                break;\n            if(dist_.dist_ <= EPSILON)\n                break;\n        }\n        curr_.id_ = dist_.id_;\n        curr_.position_ = ray_at_(ray_, prog_);\n        curr_.in_ = ray_.target_;\n        curr_.normal_ = compute_norm(objects[curr_.id_], curr_.position_, curr_.in_);\n        if(dot(curr_.normal_, curr_.in_) < 0.0)\n            curr_.in_out_ = true;\n        else\n            curr_.in_out_ = false;\n        record[step_ - 1] = ray_gen(curr_);\n        record[step_ - 1].in_out_ = curr_.in_out_;\n        ray_ = record[step_ - 1].ray_;\n        prog_ = 2.0 * EPSILON;\n        if(curr_.id_ == - 1) {\n            break;\n        }\n        if(step_ > 2 && hash() > LOSS) {\n            break;\n        }\n        step_ += 1;\n    }\n    RayResult ans_;\n    ans_.iter_ = iter_;\n    ans_.id_ = curr_.id_;\n    ans_.dist_ = prog_;\n    ans_.position_ = ray_at_(ray_, prog_);\n    ans_.normal_ = curr_.normal_;\n    ans_.color_ = compute_color_(record, step_);\n    return ans_;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    global_seed = uint(fragCoord.x * fragCoord.y * (1.0 + iTime));\n    Coord = fragCoord / SCALE;\n    Center = iResolution.xy / SCALE / 2.0;\n    Coord = Center * 2.0 - Coord;\n    Center_3d = vec3(0, Center.x, Center.y);\n    world = World(BLACK, normalize(vec3(1.0, 5.0, 5.0)), WHITE, 0.0, 1.2);\n    materials[0] = mat_glass(vec4(1.0, 0.8627, 0.3059, 1.0), 0.0, 1.4, 0.2);\n    materials[1] = mat_base_matte_plastic(vec4(0.55, 0.75, 1.0, 1.0), 0.3, 0.5);\n    materials[2] = mat_base_matte_plastic(vec4(1.0), 0.0, 0.4);\n    materials[3] = mat_emission(vec4(1.0), 1.0);\n    int i = 0;\n    int j = 0;\n    while(i < 3) {\n        while(j < 3) {\n            objects[i * 3 + j] = obj_sphere((i * 3 + j) % 2, vec3(- 40.0, 2.0 * (float(i) - 1.0), 2.0 * (float(j) - 1.0)), 1.0);\n            j ++;\n        }\n        j = 0;\n        i ++;\n    }\n    i = 0;\n    j = 0;\n    while(i < 3) {\n        while(j < 3) {\n            objects[i * 3 + j + 9] = obj_sphere((i + j + 1) % 3, vec3(- 36.0, 2.0 * (float(i) - 1.0), 2.0 * (float(j) - 1.0)), 1.0);\n            j ++;\n        }\n        j = 0;\n        i ++;\n    }\n    objects[18] = obj_plane(2, vec3(0.0, 0.0, - 3.0), vec3(0.0, 0.0, 1.0));\n    objects[17].material_ = 3;\n    objects[3].material_ = 3;\n\n    vec3 ori = Center_3d;\n    Ray ray_;\n    ray_.origin_ = vec3(10.0, Coord.x, Coord.y) - ori;\n    ray_.origin_.y /= VIEWPOINT;\n    ray_.origin_.z /= VIEWPOINT;\n    ray_.target_ = normalize(- ray_.origin_);\n    fragColor = vec4(0.0);\n    int count_ = 0;\n    while(count_ < SAMPLES) {\n        fragColor += hit_(ray_).color_ / float(SAMPLES);\n        count_ += 1;\n    }\n    float accu = texture(iChannel0, fragCoord.xy / iResolution.xy).w;\n    if(iTime == 0.0) accu = 1.0;\n    else accu = accu + 1.0;\n    vec4 color_new = fragColor;\n    vec4 color_old = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = mix(color_new ,color_old, 1.0 - 1.0 / accu);\n    fragColor.w = accu;\n}","name":"Buffer A","description":"","type":"buffer"}]}