{"ver":"0.1","info":{"id":"7sX3Wl","date":"1616712568","viewed":110,"name":"Interference pattern simulation","username":"HetSmiecht","description":"This shader simulates the interference pattern caused by a laser moving through a grating of 200 slits spaced 3 wavelengths apart (and then mirrored). It was inspired by:  http://physics.bu.edu/~duffy/HTML5/diffraction_grating.html","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interferencepattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by:  http://physics.bu.edu/~duffy/HTML5/diffraction_grating.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Y coordinates normalized between 0 and 1, but kept the aspect ratio\n    vec2 uvy = fragCoord/iResolution.y;\n    \n    float width = iResolution.x / iResolution.y;\n    \n    float pi2 = 2.0 * 3.14159265358979323846264338327950288;\n    \n    // the distance between the bottom and top slit\n    // use this value to zoom in or out\n    float gratingSize = 0.01;\n    \n    // total number of slits\n    int total = 200;\n    \n    // the distance between two slits, counted in wavelengths\n    float waveLengthsPerSlit = 3.0;\n    \n    // the waveLength of the light is actually calculated sort of backwards,\n    // but it means that you can zoom in by changing 'gratingSize'\n    float waveLength = gratingSize / float(total-1) / waveLengthsPerSlit;\n    \n    // the thing which actually counts the interference\n    vec2 brightness = vec2(0.0);\n    for (int i = 0; i < total; i++)\n    {\n        // the coordinates are shifted to be around 0.0 instead of around 0.5,\n        // so the distance is calculated more accurately (hopefully)\n        float phase = distance(uvy-vec2(width*0.5, 0.5), vec2(0.0, gratingSize*(float(i)/float(total-1)-0.5)) );\n        phase /= waveLength;\n        // take the remainder of one because of slight errors when inputting large numbers into sin and cos\n        phase = mod(phase, 1.0);\n        \n        // add a unit vector to the thing which actually counts the interference\n        brightness.x += sin(pi2 * phase);\n        brightness.y += cos(pi2 * phase);\n    }\n    // set the brightness equal to the length of the thing\n    // which counts the interference (scaled by some constant)\n    brightness *= 3.0/float(total);\n    vec3 col = vec3(length(brightness));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}