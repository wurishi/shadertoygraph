{"ver":"0.1","info":{"id":"fdBGWw","date":"1617612779","viewed":74,"name":"Duckstazy backgrounds","username":"eliasku","description":"Try draw cool backgrounds with SDF for Duckstazy Game","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["duckstazy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getHueColor(float h, float v, float s) {\n    float h6 = 6.0 * h;\n    int hi = int(h6);\n    float f = fract(h6);\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - (s * f));\n    float t = v * (1.0 - (s * (1.0 - f)));\n    vec4 rgba;\n    if (hi == 0) {\n        rgba = vec4(v, t, p, 1.0);\n    } else if (hi == 1) {\n        rgba = vec4(q, v, p, 1.0);\n    } else if (hi == 2) {\n        rgba = vec4(p, v, t, 1.0);\n    } else if(hi == 3) {\n        rgba = vec4(p, q, v, 1.0);\n    } else if (hi == 4) {\n        rgba = vec4(t, p, v, 1.0);\n    } else {\n        rgba = vec4(v, p, q, 1.0);\n    }\n    return rgba;\n}\n\nvec2 cells(vec2 position, vec2 period){\n    position = mod(position, period);\n    //negative positions lead to negative modulo\n    position += period;\n    //negative positions now have correct cell coordinates, positive input positions too high\n    position = mod(position, period);\n    //second mod doesn't change values between 0 and period, but brings down values that are above period.\n    return position;\n}\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat horDist(float y, float halfSize)\n{\n\treturn abs(y) - halfSize;\n}\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nfloat fillMaskSoft(float dist, float w) {\nreturn clamp(-dist / w, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////\n///////////////\n// The scene //\n///////////////\nfloat effect1(vec2 p)\n{\n    p.y += 160.0 * iTime;\n    p.y = mod(p.y, 160.0);\n    p = rotateCW(p, sin(iTime) * 0.05);\n    \n    float m = horDist(p.y - 40.0 - (80.0 * cos(0.05)) * (0.5 + 0.5 * sin(iTime)), 40.0);\n    \n\treturn m;\n}\n///////////////\nfloat effect2(vec2 p)\n{\n    float r1 = 22.5 + 12.5 * sin(6.28 * iTime);\n    float r2 = 22.5 - 12.5 * sin(6.28 * iTime);\n    vec2 gridSize = vec2(80.0, 80.0);\n    vec2 gridHalfSize = 0.5 * gridSize;\n    \n    vec2 c1 = cells(p, gridSize);\n    c1 = translate(c1, gridHalfSize);\n\tfloat c1d = circleDist(c1, r1);\n    \n    vec2 c2 = cells(translate(p, gridHalfSize), gridSize);\n    c2 = translate(c2, gridHalfSize);\n    float c2d = circleDist(c2, r2);\n\tfloat m = merge(c1d, c2d);\n\treturn m;\n}\n\n///////////////\nfloat effect3(vec2 p)\n{\n    return abs(mod(length(p - 0.5 * iResolution.xy)+ 100.0 * iTime, 100.0) - 50.0) * 2.0 -50.0;\n    //return mod(length(p - 0.5 * iResolution.xy)+ 100.0 * iTime, 100.0) - 50.0;\n}\n\n\n///////////////\n\nfloat effect4(vec2 p)\n{\n    p = p - 0.5 * iResolution.xy;\n    float an = 6.28 / 30.0;\n    float a = -iTime + atan(p.x, p.y);\n    float d = length(p);\n    float angleDist = abs(mod(a, 2.0 * an) - an) * 2.0 - an;\n    return angleDist * d + 10.0;\n}\n\nfloat scene(vec2 p) {\n    float effectTime = mod(iTime / 5.0, 4.0);\n    int effectIndex = int(effectTime);\n    int prevIndex = effectIndex - 1;\n    float interp = min((effectTime - float(effectIndex)) * 4.0, 1.0);\n    if (prevIndex < 0) prevIndex = 3;\n    if (effectIndex > 3) effectIndex = 0;\n    float e[4];\n     e[0] = 0.0;\n     e[1] = 0.0;\n     e[2] = 0.0;\n     e[3] = 0.0;\n\n    e[prevIndex] = 1.0 - interp;\n    e[effectIndex] = interp;\n    \n\tfloat dist = e[0] * effect1(p) + \n    e[1] * effect2(p) + \n    e[2] * effect3(p) + \n    e[3] * effect4(p);\n    return fillMaskSoft(dist, 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float power = 1.0;\n    float power = 0.5 + 0.5 * sin(0.1 * iTime);\n    float vignetteAlpha = power * 0.5;\n    \n    \n    vec4 skyColor1 = vec4(0.17647058823529413, 0.6196078431372549, 0.9019607843137255, 1);\n    vec4 skyColor2 = vec4(0.8235294117647058, 0.8862745098039215, 0.9647058823529412, 1);\n    vec4 powerColor1 = getHueColor(fract(0.1 * iTime), 1.0, 1.0);\n    vec4 powerColor2 = getHueColor(fract(0.1 * iTime + 1.0 / 6.0), 1.0, 1.0);\n    vec4 powerColor3 = getHueColor(fract(0.1 * iTime + 1.0 / 6.0), 1.0, 1.0);\n    vec4 powerColor4 = getHueColor(fract(0.1 * iTime + 2.0 / 6.0), 1.0, 1.0);\n    \n    vec4 color1 = mix(skyColor1, powerColor1, power);\n    vec4 color2 = mix(skyColor2, powerColor2, power);\n    vec4 color3 = mix(skyColor1, powerColor2, power);\n    vec4 color4 = mix(skyColor2, powerColor4, power);\n    \n    vec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n    vec2 iInvTextureSize = vec2(1.0);\n    float vk = length(c - p) / max(c.x, c.y);\n    float blurRadius =  8.0 * vk * vk;\n\n    float offX = blurRadius * iInvTextureSize.x * 1.3333333333333333;\n    float offY = blurRadius * iInvTextureSize.y * 1.3333333333333333;\n    float v = scene(p) * 0.29411764705882354 +\n            scene(p + vec2(-offX, 0.0)) * 0.5 * 0.35294117647058826 +\n            scene(p + vec2(offX, 0.0)) * 0.5 * 0.35294117647058826+\n            scene(p + vec2(0.0, -offY)) * 0.5 * 0.35294117647058826+\n            scene(p + vec2(0.0, offY)) * 0.5 * 0.35294117647058826;\n    \n    //dist = effect4(p);\n    \n\t// gradient\n\tvec4 col = mix(color2, color1, fragCoord.y / iResolution.y);\n    vec4 col2 = mix(color4, color3, fragCoord.y / iResolution.y);\n\t// shape fill\n\tcol = mix(col, col2, v);\n    // vignett\n    col *= (1.0 - vignetteAlpha * vk * vk);\n    \n\tfragColor = clamp(col, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}