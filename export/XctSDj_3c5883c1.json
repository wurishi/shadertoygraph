{"ver":"0.1","info":{"id":"XctSDj","date":"1714469952","viewed":67,"name":"layered hex prisms","username":"akr51","description":"I use my ray marching template and a hex prism is rotated centre scene. No real lighting is used just pow functions on the distance from the initial march which if misses I march a different ray as a trig function of time and is done in a for while loop","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX 90.0\n#define SRF 0.01\n#define ITR 128\n\nvec3 palette(float t)\n{\n\n    vec3 a = vec3(0.75, 0.5, 0.25);\n    vec3 b = vec3(2.0, 2.5, 3.0);\n    vec3 c = vec3(2.0, 5.0, 3.0);\n    vec3 d = vec3(4.0, 3.0, 5.0);\n    return a + b * cos((c * d + t) * 3.141592 * 2.0);\n    \n\n}\n\nmat2 r2(float t)\n{\n\n    \n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n    \n\n}\n\n\n// Thanks Inigo Quilez for the amazing resource\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat map(vec3 sp)\n{\n\n    sp.xy *= r2(iTime);\n    sp.xz *= r2(iTime);\n    return sdHexPrism(sp, vec2(0.2, 0.05));\n    \n\n}\n\n\n\nfloat mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n\n        vec3 sp = ro + rd * d0;\n        float ds = map(sp);\n        \n        d0 += ds;\n        if (d0 > MAX || abs(ds) < SRF) break;\n\n    }\n    \n    \n    return d0;\n    \n\n}\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n    \n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n\n    \n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n\n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 fx = vec3(0.0, 0.0, 0.0);\n    \n    vec3 rd = dir(uv, ro, fx);\n    float f = 1.5 - length(uv) * 5.0;\n    \n   \n    float d0 = mrch(ro, rd);\n    float f0 = 0.0;\n   \n    if (d0 < MAX)\n    {\n    \n        d0 = pow(d0, 19.0) * 2.1;\n    \n    } else {\n    \n        vec3 ror = ro;\n        \n        for (float j = 0.0; j < 3.0; j += 0.19)\n        {\n        \n            d0 = mrch(ror + vec3(cos(iTime + j), sin(iTime + j), tan(iTime + j)) * (0.05 + j * 0.25), rd);\n            \n            if (d0 < MAX)\n            {\n\n                f0 += d0 * d0 * 0.1 * f;\n\n            } else {\n\n                d0 = 0.0;\n\n            }\n           \n        \n        }\n        \n    \n    }\n    d0 += f0;\n    vec3 cl = palette(d0 * 1.1 + iTime * 0.25) * d0;\n   \n    c_out = vec4(vec3(cl), 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}