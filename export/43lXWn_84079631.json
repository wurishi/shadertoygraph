{"ver":"0.1","info":{"id":"43lXWn","date":"1731677784","viewed":229,"name":"Importance sampling Lights","username":"playbyan1453","description":"Sampling one light and randomly at pixel space. I'm looking forward to do more of these. Also I had to find a way how to use these new low discrepancy hashes I found, I hope it's a good one.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","mis","montecarlo","owen","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Credits\n// Monterman : https://www.shadertoy.com/view/4dyBRK\n// bwrensch : https://www.shadertoy.com/view/cd3XWr\n// troy_s : https://www.shadertoy.com/view/mdcSDH\n// koiava : https://www.shadertoy.com/view/4sSXWt\n#define quality 1\n#define look 0\n\n#if quality == 0\n// Mean^2 error: 3.67051410e-6\nvec3 agxDefaultContrastApprox(vec3 x) {\n    vec3 x2 = x * x;\n    vec3 x4 = x2 * x2;\n    \n    return + 15.49767102 * x4 * x2\n           - 40.13685015 * x4 * x\n           + 31.96452418 * x4\n           -  6.86791234 * x2 * x\n           +  0.42984457 * x2\n           +  0.11905766 * x\n           -  0.00232016;\n}\n#elif quality == 1\n// Mean error^2: 1.85907662e-6\nvec3 agxDefaultContrastApprox(vec3 x) {\n    vec3 x2 = x * x;\n    vec3 x4 = x2 * x2;\n    \n    return -  17.85928646 * x4 * x2 * x\n           +  78.00517364 * x4 * x2\n           - 126.68218312 * x4 * x\n           +  92.05910007 * x4\n           -  28.71568988 * x2 * x\n           +   4.36068629 * x2\n           -   0.17181985 * x\n           +   0.00285696;\n}\n#endif\n\nvec3 agx(vec3 val) {\n    const mat3 agx_mat = mat3(\n        0.842479062253094 , 0.0423282422610123, 0.0423756549057051,\n        0.0784335999999992, 0.878468636469772 , 0.0784336         ,\n        0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n    const float min_ev = -12.47393;\n    const float max_ev =  4.026069;\n    \n    // Input transform\n    val = agx_mat * val;\n    \n    // Log2 space encoding\n    val = clamp(log2(val), min_ev, max_ev);\n    val = (val - min_ev) / (max_ev - min_ev);\n    \n    // Apply sigmoid function approximation\n    val = agxDefaultContrastApprox(val);\n    \n    return val;\n}\n\nvec3 agxEotf(vec3 val) {\n    const mat3 agx_mat_inv = mat3(\n       1.19687900512017  ,-0.0528968517574562,-0.0529716355144438,\n      -0.0980208811401368, 1.15190312990417  ,-0.0980434501171241,\n      -0.0990297440797205,-0.0989611768448433, 1.15107367264116);\n    \n    // Undo input transform\n    val = agx_mat_inv * val;\n    \n    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n    // val = pow(val, vec3(2.2));\n    \n    return val;\n}\n\nvec3 agxLook(vec3 val) {\n    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n    float luma = dot(val, lw);\n    \n    vec3 offset = vec3(0);\n    vec3 slope  = vec3(1);\n    vec3 power  = vec3(1);\n    float sat   = 1.0;\n    \n#if look == 1\n    // Golden\n    slope = vec3(1.0, 0.9, 0.5);\n    power = vec3(0.8);\n    sat   = 0.8;\n#elif look == 2\n    // Punchy\n    slope = vec3(1.0);\n    power = vec3(1.35, 1.35, 1.35);\n    sat   = 1.4;\n#endif\n    \n    // ASC CDL\n    val = pow(val * slope + offset, power);\n    return mix(vec3(luma), val, sat); // luma + sat * (val - luma);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    col = max(col, 0.0);\n    col.xyz = agxEotf(agxLook(agx(col.xyz)));\n    // col.xyz = tanh(pow(col.xyz, vec3(0.4545)));\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define tfar  1e20\n#define tnear 1e-4\n\n#define cameraBounces 4\n#define transparentDepth 4\n\n// #define depthOfField\n#define importanceSampleLights\n\n// Great peformance in my Intel IGPU.\n#ifdef importanceSampleLights\n    #define binarySearch\n#endif\n\n#ifdef depthOfField\n    #define apertureBlades 0\n    #define arpetureRotation 0.0\n    #define anamorphicRatio 1.0\n    #define focusDistance 6.0\n    #define bokehSize 100.0\n#endif\n\nfloat time;\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    float transmission;\n    vec3 emit;\n    float alpha;\n};\n\nstruct Hit {\n    float dist;\n    vec3 nor;\n    Material mat;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\nfloat dot2(vec3 x) { return dot(x, x); }\n\n// Source : https://www.shadertoy.com/playlist/l3KXR1\nfloat checkersTexture(vec2 p) {\n    vec2 q = floor(p);\n    return mod(q.x + q.y, 2.0);\n}\n\nfloat gridTexture(vec2 p) {\n    vec2 i = 1.0 - step(fract(p), vec2(1.0 / 10.0));\n    return i.x * i.y;\n}\n\n// sphere of size r centered at point p\n// Projection and Pythagoras' theorem combined\n// some gpu's has some precision issues on projection method\nfloat sphere(Ray ray, vec3 p, float r) {\n    vec3 o = p - ray.ori;\n    float b = dot(o, ray.dir);\n    float c = dot(o, o) - r * r;\n    vec3 qc = o - ray.dir * b;\n    float d = min(b * b - c, r * r - dot(qc, qc));\n    if(d < 0.0) return -1.0; // no intersection\n    d = sqrt(d);\n    return b - d;\n}\n\nfloat plane(Ray ray, float h, vec3 n) {\n    return (dot(ray.ori, n) - h) / dot(-ray.dir, n);\n}\n\nfloat triangle(Ray ray, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 v0v1 = v0 - v1;\n    vec3 v0v2 = v0 - v2;\n    vec3 v0ro = v0 - ray.ori;\n    vec3  n = cross(v0v1,    v0v2);\n    vec3  q = cross(v0ro,-ray.dir);\n    float d = 1.0 / dot(-ray.dir, n);\n    vec3 h = vec3(dot(-n, v0ro),\n                  dot(-q, v0v2),\n                  dot( q, v0v1)) * d;\n    return min(h.y, h.z) >= 0.0 && (h.y + h.z) <= 1.0 ? h.x : -1.0;\n}\n\nvec3 stepRayOrigin(Ray ray, vec3 offset, float dist) {\n    vec3 point = ray.ori + ray.dir * dist;\n    vec3 absPoint = abs(point);\n    float maxPoint = max(absPoint.x, max(absPoint.y, absPoint.z));\n    return point + offset * (maxPoint + 1.0) * tnear;\n}\n\n// Main hash is in the common\nuvec3 seed;\n\nfloat hash1() {\n    float x = SobolBurley1D(seed.x, 0u, seed.y, seed.z);\n    seed.x = OwenScrambleBase2(seed.x, 0xbff95bfeu);\n    return x;\n}\n\nvec2 hash2() {\n    vec2 x = SobolBurley2D(seed.x, 0u, seed.y, seed.z);\n    seed.x = OwenScrambleBase2(seed.x, 0xf8ade99au);\n    return x;\n}\n\nvec3 hash3() {\n    vec3 x = SobolBurley3D(seed.x, 0u, seed.y, seed.z);\n    seed.x = OwenScrambleBase2(seed.x, 0xcaa726acu);\n    return x;\n}\n\nvec4 hash4() {\n    vec4 x = SobolBurley4D(seed.x, 0u, seed.y, seed.z);\n    seed.x = OwenScrambleBase2(seed.x, 0xc2c1a055u);\n    return x;\n}\n\n// Sampling Functions\nvec2 sampleTriangle(vec2 a, vec2 b, vec2 c, vec2 r) {\n    // get the edges of the triangle and the diagonal across the\n    // center of the parallelogram\n    vec2 e1 = a - b;\n    vec2 e2 = c - b;\n    vec2 diag = normalize(e1 + e2);\n\n    // pick the point in the parallelogram\n    if(r.x + r.y > 1.0) r = 1.0 - r;\n    return e1 * r.x + e2 * r.y;\n}\n\nvec2 sampleRegularPolygon(int sides) {\n    sides = max(sides, 3);\n    \n    vec3 r = hash3();\n    float anglePerSegment = twopi / float(sides);\n    float segment = floor(float(sides) * r.x);\n    \n    float angle1 = anglePerSegment * segment;\n    float angle2 = angle1 + anglePerSegment;\n    vec2 a = vec2(sin(angle1), cos(angle1));\n    vec2 b = vec2(0);\n    vec2 c = vec2(sin(angle2), cos(angle2));\n    \n    return sampleTriangle(a, b, c, r.yz);\n}\n\nvec2 sampleDisk() {\n    vec2 uv = hash2() * vec2(1, twopi);\n    return vec2(sin(uv.y), cos(uv.y)) * sqrt(uv.x);\n}\n\nvec3 randomSphere() {\n    vec2 uv = hash2() * vec2(2.0, twopi) - vec2(1, 0);\n    return vec3(sqrt(1.0 - uv.x * uv.x) * vec2(cos(uv.y), sin(uv.y)), uv.x);\n}\n\nvec3 cosineHemisphere(vec3 nor) {\n    return normalize(nor + randomSphere());\n}\n\nvec3 uniformDirectionWithinCone(vec3 d, float phi, float sina, float cosa) {    \n    vec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n    return (u * cos(phi) + v * sin(phi)) * sina + w * cosa;\n}\n\n#if 1\nLight lights[] = Light[](\n    Light(vec3( 0,    2,-1  ), vec3(1, 0, 0) * 25.0, 0.25),\n    Light(vec3( 0.87, 2, 0.5), vec3(0, 1, 0) * 25.0, 0.25),\n    Light(vec3(-0.87, 2, 0.5), vec3(0, 0, 1) * 25.0, 0.25)\n);\n#else\nLight lights[] = Light[](\n    Light(vec3( 0,    2,-1  ), vec3(1, 0, 0) * 16.7, 0.25),\n    Light(vec3( 0.87, 2,-0.5), vec3(1, 1, 0) * 8.3, 0.25),\n    Light(vec3( 0.87, 2, 0.5), vec3(0, 1, 0) * 16.7, 0.25),\n    Light(vec3( 0,    2, 1  ), vec3(0, 1, 1) * 8.3, 0.25),\n    Light(vec3(-0.87, 2, 0.5), vec3(0, 0, 1) * 16.7, 0.25),\n    Light(vec3(-0.87, 2,-0.5), vec3(1, 0, 1) * 8.3, 0.25)\n);\n#endif\n\n/*Light lights[] = Light[](\n    Light(vec3(-1, 0, 0), vec3(1), 1.0),\n    Light(vec3( 1, 0, 0), vec3(1), 0.5)\n);*/\n\nvoid sampleSphereLight(Light li, Ray ray, out vec3 dir, out float pdf, out float d) {\n    vec3 w = li.pos - ray.ori;  // direction to light center\n    float dc2 = dot2(w);        // squared distance to light center\n    float dc = sqrt(dc2);       // distance to light center\n    float lr2 = li.rad * li.rad;\n    vec2 x = hash2();\n    \n    if(dc2 > lr2) {\n        float sin_theta_max_2 = lr2 / dc2;\n        float cos_theta_max = sqrt(1.0 - clamp(sin_theta_max_2, 0.0, 1.0));\n        float cos_theta = mix(cos_theta_max, 1.0, x.x);\n        float sin_theta_2 = 1.0 - cos_theta * cos_theta;\n        float sin_theta = sqrt(sin_theta_2);\n        dir = uniformDirectionWithinCone(w, twopi * x.y, sin_theta, cos_theta);\n        pdf = 1.0 / (twopi * (1.0 - cos_theta_max));\n        \n        // Calculate intersection distance\n        // http://ompf2.com/viewtopic.php?f=3&t=1914\n        d = dc * cos_theta - sqrt(lr2 - dc2 * sin_theta_2);\n        return;\n    } else {\n        dir = randomSphere();\n        pdf = invfourpi;\n        d = sphere(Ray(ray.ori, dir), li.pos, li.rad);\n        return;\n    }\n}\n\nvoid anyHit(Ray ray, inout Hit res) {\n    float t = res.dist;\n    vec3 tp = vec3(0);\n    \n    for(int i = 0; i < lights.length(); i++) {\n        Light li = lights[i];\n        t = sphere(ray, li.pos, max(li.rad - tnear, 0.0));\n        if(t > tnear && res.dist > t) {\n            res.dist = t;\n            res.nor = normalize((ray.ori + ray.dir * t) - li.pos);\n            res.mat = Material(vec3(0), 0.0, 0.0, 0.0, li.col, 1.0);\n        }\n    }\n    \n    // t = triangle(ray, vec3(-1,-1, 0), vec3(0, 1, 0), vec3(1,-1, 0));\n    tp = vec3(0);\n    t = sphere(ray, tp, 1.0);\n    if(t > tnear && res.dist > t) {\n        res.dist = t;\n        res.nor = normalize(ray.ori + ray.dir * t);\n        // res.nor = vec3(0, 0,-1);\n        res.mat = Material(vec3(0.95), 0.25, 0.0, 0.0, vec3(0), 1.0); // vec3(0.95, 0.15, 0.05)\n    }\n    tp = vec3(0, 1, 0);\n    t = plane(ray,-1.0, tp);\n    if(t > tnear && res.dist > t) {\n        res.dist = t;\n        res.nor = tp;\n        res.mat = Material(vec3(mix(0.55, 0.95, checkersTexture((ray.ori + ray.dir * t).xz))), 0.25, 0.0, 0.0, vec3(0), 1.0);\n    }\n}\n\nvoid closestHit(Ray ray, inout Hit res) {\n    Hit t;\n    float x = hash1();\n    for(int i = 0; i < transparentDepth; i++) {\n        Hit h = res;\n        anyHit(ray, h);\n        t.dist += h.dist + tnear;\n        if(t.dist > tnear && t.dist < res.dist) {\n            if(x < h.mat.alpha) {\n                res = Hit(t.dist, h.nor, h.mat);\n                return;\n            } else {\n                ray.ori = stepRayOrigin(ray,-h.nor, h.dist);\n                continue;\n            }\n        } else return;\n    }\n}\n\nvoid getLights(Ray ray, Hit res, out float pdf, out Light li) {\n    const int lightCount = lights.length();\n    float x = hash1();\n    #ifdef importanceSampleLights\n    float cdf[lightCount];\n    float tot;\n    \n    for(int i = 0; i < lightCount; i++) {\n        Light li = lights[i];\n        float lw = max(dot2(li.pos - ray.ori) - li.rad * li.rad, 1e-28);\n        pdf = dot(li.col, vec3(1)) / lw;\n        tot += pdf;\n        cdf[i] = tot;\n    }\n    \n    x *= tot;\n    tot = 1.0 / tot;\n    \n    #ifdef binarySearch\n    int i = 0, j = lightCount - 1;\n    while(i < j) {\n        int m = (i + j) >> 1;\n        if(x < cdf[m]) {\n            j = m;\n        } else {\n            i = m + 1;\n        }\n    }\n    #else\n    int i = 0;\n    while(i < lightCount) {\n        if(x < cdf[i]) break;\n        i++;\n    }\n    #endif\n    \n    pdf = (cdf[i] - (i == 0 ? 0.0 : cdf[i - 1])) * tot;\n    li = lights[i];\n    return;\n    \n    #else\n    // naive, too uniform\n    // not accounting the distance to light\n    // and light luminance\n    pdf = 1.0 / float(lightCount);\n    li = lights[int(h * float(lightCount))];\n    return;\n    #endif\n}\n\nvoid rayBRDF(inout Ray ray, inout Hit res) {\n    ray.ori = stepRayOrigin(ray, res.nor, res.dist);\n    // ray.dir = reflect(ray.dir, res.nor);\n    ray.dir = cosineHemisphere(res.nor);\n    return;\n}\n\nvec3 skyCol(vec3 p) {\n    return vec3(0);\n}\n\nvec4 pathTrace(Ray ray) {\n    vec3 fcol = vec3(1);\n    vec3 tcol = vec3(0);\n    bool mask = true;\n    \n    for(int i = 0; i < cameraBounces; i++) {\n        Material mat;\n        Hit res = Hit(tfar, -ray.dir, mat);\n        closestHit(ray, res);\n        \n        if(res.dist > tnear && res.dist < tfar) {\n            float emit = dot(res.mat.emit, vec3(0.2126, 0.7152, 0.0722));\n            if(i == 0 && emit > 0.0) {\n                tcol += fcol * res.mat.emit;\n                break;\n            }\n            \n            rayBRDF(ray, res);\n            \n            fcol *= res.mat.albedo;\n            \n            if(dot(res.nor, ray.dir) > 0.0) {\n                Light li;\n                float lpdf;\n                getLights(ray, res, lpdf, li);\n                vec3 nld;\n                float ln, lipdf;\n                sampleSphereLight(li, ray, nld, lipdf, ln);\n                Ray shadow = Ray(ray.ori, nld);\n                Hit resShadow;\n                resShadow.dist = ln;\n                closestHit(shadow, resShadow);\n                if(!(resShadow.dist < ln)) {\n                    float brdf = max(dot(res.nor, nld), 0.0) * invpi;\n                    float pdf = lpdf * lipdf / brdf;\n                    tcol += fcol * li.col / pdf;\n                }\n            }\n        } else {\n            tcol += fcol * skyCol(ray.dir);\n            break;\n        }\n    }\n    \n    return vec4(tcol, mask);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = vec4(0);\n    \n    uint frame = uint(iFrame);\n    uvec2 px = uvec2(fragCoord);\n    \n    const uint N = 3u;\n    const uint M = (1u << (2u * N)) - 1u;\n    uint h = EvalHilbertCurve(px, N) + WeylHash(px >> N);\n    seed.x = OwenScrambleBase4(MortonIndex(px), 0u);\n    seed.x = (seed.x & (~M)) ^ (h & M);\n    seed.x += frame * (M + 1u);\n    seed.yz = uvec2(0u, 0xffffffffu);\n    \n    vec2 rnd   = sampleDisk();\n    vec2 uv    = (fragCoord + rnd) / iResolution.xy - 0.5;\n         uv.x *= iResolution.x / iResolution.y;\n    \n    float o = hash1() * 2.0 - 1.0;\n    time = 0.0 + o * 0.0;\n    mat3 ca  = rot(vec3(0.0 * deg2rad, 0, 0));\n    Ray ray  = Ray(vec3(0, 0, 6), vec3(0));\n    perspective(ray, uv, 90.0);\n    ray.dir = ca * ray.dir;\n    \n    // Depth of Field\n    #ifdef depthOfField\n    // Get the aperture sample\n    // if blades == 0 then we assume a circle\n    int apSide = apertureBlades;\n    vec2 apSp = apSide == 0 ? sampleDisk() : sampleRegularPolygon(apSide);\n         apSp *= bokehSize * 0.5 * 1e-3;\n    \n    #if apertureBlades\n    // Rotate the aperture shape\n    apSp *= rot(arpetureRotation * deg2rad) *\n            clamp(vec2(anamorphicRatio, 1.0 / anamorphicRatio), 0.0, 1.0);\n    #endif\n    \n    // Create the new ray\n    vec3 fp = ray.ori + (ray.dir / dot(ray.dir, ca * vec3(0, 0,-1))) * focusDistance;\n    ray.ori += ca * vec3(apSp, 0);\n    ray.dir = normalize(fp - ray.ori);\n    #endif\n    \n    if(dot(ray.dir, ray.dir) < 1.0 - 1e-4) return;\n    \n    vec4 col = pathTrace(ray);\n    vec4 prev_col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    col = mix(prev_col, col, 1.0 / float(frame + 1u));\n    \n    if(all(isnan(col)) || all(isinf(col))) col = vec2(0, 1).xxxy;\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi         3.141592653589793\n#define invpi      0.318309886183791\n#define twopi      6.283185307179586\n#define invtwopi   0.159154943091895\n#define fourpi    12.566370614359172\n#define invfourpi  0.079577471545948\n#define deg2rad    0.017453292519943\n#define rad2deg    57.29577951308232\n\n// Utilities\nstruct Ray {\n    vec3 ori;\n    vec3 dir;\n};\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s, s, c);\n}\n\nmat3 rot(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);\n    mat3 x = mat3(\n        vec3(   1,   0,   0),\n        vec3(   0, c.x,-s.x),\n        vec3(   0, s.x, c.x)\n    );\n    mat3 y = mat3(\n        vec3( c.y,   0, s.y),\n        vec3(   0,   1,   0),\n        vec3(-s.y,   0, c.y)\n    );\n    mat3 z = mat3(\n        vec3( c.z, s.z,   0),\n        vec3(-s.z, c.z,   0),\n        vec3(   0,   0,   1)\n    );\n    return x * y * z;\n}\n\nvoid perspective(inout Ray ray, vec2 p, float a) {\n    ray.dir = normalize(vec3(p, -1.0 / tan(a * 0.5 * deg2rad)));\n}\n\nvoid equirectangular(inout Ray ray, vec2 p) {\n    p *= vec2(twopi, pi);\n    ray.dir = normalize(vec3(sin(p.x), tan(p.y), -cos(p.x)) * cos(p.y));\n}\n\nvoid cubemapface(inout Ray ray, vec2 p) {\n    ray.dir = normalize(vec3(tan(p * 0.25 * twopi - fourpi), -1));\n}\n\nvoid mirrorball(inout Ray ray, vec2 p) {\n    p *= 2.0;\n    if(dot(p, p) > 1.0) ray.dir = vec3(0);\n    vec3 n = normalize(vec3(p,-sqrt(max(1.0 - dot(p, p), 0.0))));\n    ray.dir = reflect(vec3(0, 0, 1), n);\n}\n\n// Some codes are from Blender Cycles\n// Sobol table and hash : https://github.com/blender/cycles/blob/main/src/kernel/sample/sobol_burley.h\nuvec4 SobolBurleyTable[] = uvec4[](\n    uvec4(0x00000001u, 0x00000001u, 0x00000001u, 0x00000001u), uvec4(0x00000002u, 0x00000003u, 0x00000003u, 0x00000003u), uvec4(0x00000004u, 0x00000005u, 0x00000006u, 0x00000004u), uvec4(0x00000008u, 0x0000000fu, 0x00000009u, 0x0000000au),\n    uvec4(0x00000010u, 0x00000011u, 0x00000017u, 0x0000001fu), uvec4(0x00000020u, 0x00000033u, 0x0000003au, 0x0000002eu), uvec4(0x00000040u, 0x00000055u, 0x00000071u, 0x00000045u), uvec4(0x00000080u, 0x000000ffu, 0x000000a3u, 0x000000c9u),\n    uvec4(0x00000100u, 0x00000101u, 0x00000116u, 0x0000011bu), uvec4(0x00000200u, 0x00000303u, 0x00000339u, 0x000002a4u), uvec4(0x00000400u, 0x00000505u, 0x00000677u, 0x0000079au), uvec4(0x00000800u, 0x00000f0fu, 0x000009aau, 0x00000b67u),\n    uvec4(0x00001000u, 0x00001111u, 0x00001601u, 0x0000101eu), uvec4(0x00002000u, 0x00003333u, 0x00003903u, 0x0000302du), uvec4(0x00004000u, 0x00005555u, 0x00007706u, 0x00004041u), uvec4(0x00008000u, 0x0000ffffu, 0x0000aa09u, 0x0000a0c3u),\n    uvec4(0x00010000u, 0x00010001u, 0x00010117u, 0x0001f104u), uvec4(0x00020000u, 0x00030003u, 0x0003033au, 0x0002e28au), uvec4(0x00040000u, 0x00050005u, 0x00060671u, 0x000457dfu), uvec4(0x00080000u, 0x000f000fu, 0x000909a3u, 0x000c9baeu),\n    uvec4(0x00100000u, 0x00110011u, 0x00171616u, 0x0011a105u), uvec4(0x00200000u, 0x00330033u, 0x003a3939u, 0x002a7289u), uvec4(0x00400000u, 0x00550055u, 0x00717777u, 0x0079e7dbu), uvec4(0x00800000u, 0x00ff00ffu, 0x00a3aaaau, 0x00b6dba4u),\n    uvec4(0x01000000u, 0x01010101u, 0x01170001u, 0x0100011au), uvec4(0x02000000u, 0x03030303u, 0x033a0003u, 0x030002a7u), uvec4(0x04000000u, 0x05050505u, 0x06710006u, 0x0400079eu), uvec4(0x08000000u, 0x0f0f0f0fu, 0x09a30009u, 0x0a000b6du),\n    uvec4(0x10000000u, 0x11111111u, 0x16160017u, 0x1f001001u), uvec4(0x20000000u, 0x33333333u, 0x3939003au, 0x2e003003u), uvec4(0x40000000u, 0x55555555u, 0x77770071u, 0x45004004u), uvec4(0x80000000u, 0xffffffffu, 0xaaaa00a3u, 0xc900a00au)\n);\n\nuint EvalHilbertCurve(uvec2 p, uint n) {\n    uint d = 0u;\n    for(uint i = 0u; i < n; i++) {\n        uint j = n - i - 1u;\n        uvec2 r = (p >> j) & 1u;\n        d += ((3u * r.x) ^ r.y) << (2u * j);\n        uint a = r.y, b = r.x;\n        p = p * a + (((1u << j) - 1u - p.yx) * b + p.yx * (1u - b)) * (1u - a);\n    }\n    return d;\n}\n\nuint MortonIndex(uvec2 p) {\n    uint n = 8u;\n    p = (p ^ (p << n)) & 0x00ff00ffu; n >>= 1u;\n    p = (p ^ (p << n)) & 0x0f0f0f0fu; n >>= 1u;\n    p = (p ^ (p << n)) & 0x33333333u; n >>= 1u;\n    p = (p ^ (p << n)) & 0x55555555u; n >>= 1u;\n    return (p.x << 1u) | p.y;\n}\n\nuint ReverseBits(uint x) {\n    x = ((x & 0xaaaaaaaau) >> 1u) | ((x & 0x55555555u) << 1u);\n    x = ((x & 0xccccccccu) >> 2u) | ((x & 0x33333333u) << 2u);\n    x = ((x & 0xf0f0f0f0u) >> 4u) | ((x & 0x0f0f0f0fu) << 4u);\n    x = ((x & 0xff00ff00u) >> 8u) | ((x & 0x00ff00ffu) << 8u);\n    return (x >> 16u) | (x << 16u);\n}\n\nuint CountLeadingZeros(uint x) {\n    if(x == 0u) return 32u;\n    uint n = 0u;\n    if((x & 0xffff0000u) == 0u) { n += 16u; x <<= 16u; }\n    if((x & 0xff000000u) == 0u) { n +=  8u; x <<=  8u; }\n    if((x & 0xf0000000u) == 0u) { n +=  4u; x <<=  4u; }\n    if((x & 0xc0000000u) == 0u) { n +=  2u; x <<=  2u; }\n    if((x & 0x80000000u) == 0u) { n +=  1u; }\n    return n;\n}\n\n// from: https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\nuint OwenHashBase2(uint x, uint seed) { // seed is any random number\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16u) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\nuint OwenHashBase4(uint x, uint seed) {\n    x ^= x * 0x3d20adeau;\n    x ^= (x >> 1u) & (x << 1u) & 0x55555555u;\n    x += seed;\n    x *= (seed >> 16u) | 1u;\n    x ^= (x >> 1u) & (x << 1u) & 0x55555555u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) {\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nuint HashHpUint(uint i) {\n    i ^= i >> 16u;\n    i *= 0x21f0aaadu;\n    i ^= i >> 15u;\n    i *= 0xd35a2d97u;\n    i ^= i >> 15u;\n    return i ^ 0xe6fe3bebu;\n}\n\nuint OwenScrambleBase2(uint p, uint seed) {\n    return ReverseBits(OwenHashBase2(ReverseBits(p), seed));\n}\n\nuint OwenScrambleBase4(uint p, uint seed) {\n    return ReverseBits(OwenHashBase4(ReverseBits(p), seed));\n}\n\nfloat SobolBurley(uint rev_bit_index, uint dimension, uint scramble_seed) {\n    uint result = 0u;\n    \n    if(dimension == 0u) {\n        result = ReverseBits(rev_bit_index);\n    } else {\n        uint i = 0u;\n        while(rev_bit_index != 0u) {\n            uint j = CountLeadingZeros(rev_bit_index);\n            result ^= SobolBurleyTable[i + j][dimension];\n            i += j + 1u;\n            \n            rev_bit_index <<= j + 1u;\n        }\n    }\n    \n    result = ReverseBits(OwenHashBase2(result, scramble_seed));\n    \n    return float(result) / float(0xffffffffu);\n}\n\nfloat SobolBurley1D(uint index, const uint dimension, uint seed, uint shuffled_index_mask) {\n    seed ^= HashHpUint(dimension);\n    index = OwenHashBase2(ReverseBits(index), seed ^ 0xbff95bfeu);\n    index &= shuffled_index_mask;\n    return SobolBurley(index, 0u, seed ^ 0x635c77bdu);\n}\n\nvec2 SobolBurley2D(uint index, const uint dimension, uint seed, uint shuffled_index_mask) {\n    seed ^= HashHpUint(dimension);\n    index = OwenHashBase2(ReverseBits(index), seed ^ 0xf8ade99au);\n    index &= shuffled_index_mask;\n    return vec2(SobolBurley(index, 0u, seed ^ 0xe0aaaf76u),\n                SobolBurley(index, 1u, seed ^ 0x94964d4eu));\n}\n\nvec3 SobolBurley3D(uint index, const uint dimension, uint seed, uint shuffled_index_mask) {\n    seed ^= HashHpUint(dimension);\n    index = OwenHashBase2(ReverseBits(index), seed ^ 0xcaa726acu);\n    index &= shuffled_index_mask;\n    return vec3(SobolBurley(index, 0u, seed ^ 0x9e78e391u),\n                SobolBurley(index, 1u, seed ^ 0x67c33241u),\n                SobolBurley(index, 2u, seed ^ 0x78c395c5u));\n}\n\nvec4 SobolBurley4D(uint index, const uint dimension, uint seed, uint shuffled_index_mask) {\n    seed ^= HashHpUint(dimension);\n    index = OwenHashBase2(ReverseBits(index), seed ^ 0xc2c1a055u);\n    index &= shuffled_index_mask;\n    return vec4(SobolBurley(index, 0u, seed ^ 0x39468210u),\n                SobolBurley(index, 1u, seed ^ 0xe9d8a845u),\n                SobolBurley(index, 2u, seed ^ 0x5f32b482u),\n                SobolBurley(index, 3u, seed ^ 0x1524cc56u));\n}","name":"Common","description":"","type":"common"}]}