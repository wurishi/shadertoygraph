{"ver":"0.1","info":{"id":"tslXR2","date":"1551752686","viewed":106,"name":"shadow study 1","username":"mindtree","description":"shadowy ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadowraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// 0.0 no lights, 1.0 all lights.\n#define LIGHTS_AMP 1.0\n\n// 0.0 no light, 10.0 powerful light.\n#define LIGHT1_AMP 5.0\n#define LIGHT2_AMP 2.0\n#define LIGHT3_AMP 0.\n\n// 0.0 no pillar, 1.0 default.\n#define PILLAR_WIDTH 1.0\n// 0.0 no pillar, 30.0 can't see top.\n//#define PILLAR_HEIGHT 30.0\n#define PILLAR_HEIGHT 1.0\n// 0.0 no pillar, 6.0 fully sealed.\n#define PILLAR_LENGTH 3.7\n\n// Multiplier for the subtle humanish gimble movement.\n// 0.0 is none, 5.0 is max.\n#define GIMBLE_MOVEMENT 1.0\n// 0.0 is none, 10.0 is weird shakey.\n#define GIMBLE_FREQ 1.0\n\n\n// Light RGBs\n#define LIGHT1_COL vec3(0.2, 0.5, 0.8)\n#define LIGHT2_COL vec3(0.0, 1.0, 1.0)\n#define LIGHT3_COL vec3(1.0)\n\n#define MODULO_STEP_Z 10.0\n#define MODULO_STEP_X 20.0\n\nconst float PI = 3.1457;\n\nfloat bpm() { return 126.0; }\nfloat beats_per_bar() { return 4.; }\nfloat bar() { return iTime * bpm() / 60.0 / beats_per_bar(); }\nfloat bar_phase() { return mod(bar(), 1.0); }\nfloat bar4_phase() { return mod(bar(), 4.0) / 4.0; }\nfloat bar8_phase() { return mod(bar(), 8.0) / 8.0; }\nfloat bar16_phase() { return mod(bar(), 16.0) / 16.0; }\nfloat beat() { return iTime * bpm() / 60.0; }\nfloat beat_phase() { return mod(beat(), 1.0); }\nfloat minim_phase() { return mod(beat()*0.5, 1.0); }\nfloat quaver_phase() { return mod(beat()*2.0, 1.0); }\nfloat semiquaver_phase() { return mod(beat()*4.0, 1.0); }\n\nfloat light1_z_phase() { return bar_phase(); }\nfloat light2_z_phase() { return bar4_phase(); }\nfloat light_z_max() { return MODULO_STEP_Z * 16.0; }\nfloat cam_z_phase() { return bar16_phase(); }\n\n#define NUM_SHAPES 2\nfloat shape_shift_phase() { return minim_phase(); }\nint shape_index() { return int(floor(shape_shift_phase() * float(NUM_SHAPES))); }\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    vec3 c = a + t*ab;\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat sdSphere(vec4 s) {\n    return length(s.xyz) - s.w;\n}\n\n\nfloat GetDist(vec3 p) {\n    float plane_dist = p.y;\n    \n    // Position modulo for box.\n    vec3 p_for_box = p;\n    p_for_box.z = mod(p.z, MODULO_STEP_Z);\n    p_for_box.x = mod(p.x, MODULO_STEP_X);\n    p_for_box.y = mod(p.y, 2.0);\n    vec3 pillar_dim = vec3(PILLAR_WIDTH, PILLAR_HEIGHT, PILLAR_LENGTH);\n    vec3 pillar_pos = vec3(MODULO_STEP_X*0.5, 1.0, 6);\n    float pillar_dist = dBox(p_for_box-pillar_pos, pillar_dim);\n    \n    // Position modulo for shape.\n    vec3 p_for_shape = p;\n    p_for_shape.z = mod(p.z, light_z_max() * 0.5);\n    float shape_dist = 0.0;\n    int shape_ix = shape_index();\n    if (shape_ix == 0) {\n      \tvec4 s = vec4(0, 1, 6, 0.5);\n        shape_dist = sdSphere(vec4(p_for_shape-s.xyz, s.w));\n    } else if (shape_ix == 1) {\n        vec3 bpos = vec3(0, 1, 6);\n        vec3 bdim = vec3(1, 1, 1) * 0.5;\n        shape_dist = dBox(p_for_shape-bpos, bdim);\n    } else {\n        // TODO: Add more shapes?\n        //float cd = sdCapsule(p, vec3(3, .5, 6), vec3(3, 2.5, 6), .5); \n    \t//float td = sdTorus(p-vec3(0,.5,6), vec2(1.5, .4));\n    \t//float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, .3, 5), .3);\n    }    \n    \n    \n    float d = plane_dist;\n    d = min(d, pillar_dist);\n    d = min(d, shape_dist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat shadow_march(vec3 ro, vec3 rd, float min_light, float light_dist, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=min_light; t < light_dist; ) {\n        vec3 p = ro + rd*t;\n        float h = GetDist(p);\n        if(h<SURF_DIST)\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 GetNormal(vec3 p) {\n        //p.z = mod(p.z, 10.0);\n\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 light1() {\n    //vec3 pos = vec3(-.625*MODULO_STEP_X, 6, -0.5*MODULO_STEP_Z);\n    vec3 pos = vec3(-.625*MODULO_STEP_X, 6, 0.0);\n    pos.z += light1_z_phase() * light_z_max();\n\treturn pos;\n}\n\nvec3 light1_col() {\n    return LIGHT1_COL;\n}\n\nvec3 light2() {\n    vec3 pos = vec3(.625*MODULO_STEP_X, 10, 0.0);\n    pos.z += light2_z_phase() * light_z_max();\n\treturn pos;\n}\n\nvec3 light2_col() {\n    return LIGHT2_COL;\n}\n\nvec3 light3() {\n    vec3 pos = vec3(1, 4, light_z_max()*0.5+2.);\n    pos.xz += vec2(sin(iTime), cos(iTime))*2.;\n\treturn pos;\n}\n\nvec3 light3_col() {\n    return LIGHT3_COL;\n}\n\nfloat GetLight(vec3 p, vec3 light_p) {\n    p.z = mod(p.z, light_z_max());\n    vec3 l = normalize(light_p-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(light_p-p)) dif *= .1;\n\n    float s = shadow_march(p+n*SURF_DIST*2., l, 0.1, 1., 0.5);\n    //s = 1.;\n\n    return dif*s;\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec3 cam_pos = vec3(0, 2, 0);\n    cam_pos.xyz += vec3(sin(iTime*0.4*GIMBLE_FREQ), cos(iTime*0.37*GIMBLE_FREQ), sin(iTime*GIMBLE_FREQ)*0.5)*0.25*GIMBLE_MOVEMENT;\n    \n    cam_pos.z += cam_z_phase() * light_z_max();\n    \n    \n    float cam_yaw = uv.x-.07;\n    float cam_pitch = uv.y-.2;\n    \n    //cam_yaw += iMouse.x * PI * 4.0 / iResolution.x - PI * 2.0;\n    //cam_pitch += iMouse.y * PI * 2.0 / iResolution.y - PI;\n    \n    vec3 rd = normalize(vec3(cam_yaw, cam_pitch, 1));\n\n    float d = RayMarch(cam_pos, rd);\n    \n    vec3 p = cam_pos + rd * d;\n    \n    vec3 l1 = light1_col() * GetLight(p, light1());\n    vec3 l2 = light2_col() * GetLight(p, light2());\n    vec3 l3 = light3_col() * GetLight(p, light3());\n\n    float fade_dist = 1.0 - pow(d / MAX_DIST, 2.);\n    col = (l1*LIGHT1_AMP + l2*LIGHT2_AMP + l3*LIGHT3_AMP) * LIGHTS_AMP * fade_dist;\n    return col;\n}\n\nvec3 render_msaa(vec2 uv, int samples) {\n    int samples_per_side = samples / 2;\n    int half_samples_per_side = samples_per_side / 2;\n    int loop_end = samples_per_side - half_samples_per_side;\n    int loop_start = loop_end - samples_per_side;\n    float sample_step = 1.0 / iResolution.x;\n    vec3 acc = vec3(0.0);\n    for (int x = loop_start; x < loop_end; x++) {\n        for (int y = loop_start; y < loop_end; y++) {\n            vec2 coords = uv + vec2(float(x) * sample_step, float(y) * sample_step);\n            acc += render(coords);\n        }\n    }\n    return acc / float(samples_per_side * 2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    //fragColor = vec4(render_msaa(uv, 4),1.0);\n    fragColor = vec4(render(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}