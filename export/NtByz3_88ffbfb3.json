{"ver":"0.1","info":{"id":"NtByz3","date":"1649992223","viewed":108,"name":"spiral happy place","username":"pb","description":"good ole fashioned 2d julia sets","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","juliasets","hybridfunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//trying some cheap antialiasing here\n//by averaging pixels instead of casting more rays\n//seems to work ok in this case\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    total_color.rgb = pow(total_color.rgb,vec3(1.2));\n   \n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//morphing julia sets of w1*z^2+w2*exp(z)+c as c and other things change\n\nvec2 zz( in vec2 z ) {\n    //classic z squared iteration here\n    return vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y);\n}\n\nvec2 expz( in vec2 z ) {\n    //exponential function here\n    return vec2( exp(z.x)*cos(z.y), exp(z.x)*sin(z.y) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float myTime = iTime;\n    //we want to start in a particular rect in complex plane\n    vec2 center = vec2(0., 2.+.5*sin(iTime/4.));\n    vec2 width  = vec2( .8, .5);\n    \n    vec2 final_uv = (uv - center) * width ; \n    \n    float max_iter=120., mix_factor=.3, infinity=1.e3;\n    vec3  julia_freq = vec3( -3.+sin(myTime),\n                              1.+.5*sin(myTime),\n                             -3.);\n    vec2  polar_param = \n        vec2(.30*(1.+max((.2+sin(myTime/5.)),.2)*sin(myTime/2.)), 3.3);\n    \n    vec2  jc = vec2( polar_param.x*cos(polar_param.y),\n                     polar_param.x*sin(polar_param.y) );\n                         \n    vec4 qq = vec4(0.); //counts orbit in 4 quadrants\n    vec2 wgt=vec2(mix_factor, 1.-mix_factor);\n    \n    vec2 iter=final_uv, new_iter;\n    float escape_value = 0.;\n    for ( float i=0.; i<max_iter; i++ ) {\n    \n        new_iter = wgt.x * zz(iter) + wgt.y*expz(iter) + jc;\n        iter = new_iter;\n        \n        float distance = new_iter.x*new_iter.x + new_iter.y*new_iter.y;\n\n        //keep track if how many times the orbit is in \n        //the various 4 quadrants (for coloring)\n        if (new_iter.x >= 0.0) {\n            if (new_iter.y >= 0.0) {\n                qq[0] ++;\n            }\n            else {\n                qq[1] ++;\n            }\n        }\n        else {\n            if (new_iter.y >= 0.0) {\n                qq[2] ++;\n            }\n            else {\n                qq[3] ++;\n            }\n        }\n        \n        //the usual distance bigger than some large number check\n        //NOT using distance estimator here\n        if ( distance > infinity ) {\n            escape_value = i;\n            break;\n        }\n         \n    }\n    \n    if ( escape_value != 0. ) {\n        vec3 qx = vec3( qq[3]*julia_freq[0], \n                        qq[0]*julia_freq[1],\n                        qq[1]*julia_freq[2]\n                       );\n        \n        fragColor = vec4( cos(qx / escape_value), 1. ); \n    }\n    else {\n        fragColor = vec4( vec3(0.), 1. );\n    }\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n\n","name":"Common","description":"","type":"common"}]}