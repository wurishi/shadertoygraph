{"ver":"0.1","info":{"id":"ftjcWW","date":"1649792851","viewed":83,"name":"Floating Chrystals","username":"Amirk","description":"Testing if I can do some multiple refractions and reflections.  Edit: I made the torus is hollow now...","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raymarch","refraction"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX 1000\n#define MAX_DIST 100.\n#define SURF 0.0001\n#define dens .4\n#define abb  0.  //abberration\n#define REFRACTIONS 4 //how many iterations of refrations we trace\n\n\nfloat td=0.; //torus distance\nfloat sd=.0; //sphere distance\nfloat cd=.0; //capsule distance\nfloat rhombicd=0.; //rhombic distance\nfloat rhombic2d=0.; //another rhombic distance\nfloat bd= 0.; //box dist\nvec3 color;\nvec3 color2;\n\nfloat IOR=  1.45; //index of refraction\nfloat reflectivity=.1;\n\nconst int DIAMOND = 1;\nconst int EMERALD = 2;\nconst int RUBY = 3;\nconst int SAPHIRE =4;\nconst int GLASS = 5;\nconst int MIRROR = 6;\nconst int BACKGROUND =0;\n\n\n\nmat2 Rot(float a){\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p , vec3 s){\n//p.xz*=Rot(-iTime*.1);\n p= abs(p)-s;\n\nreturn length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.); //signed distance is needed here\n}\n\nfloat sdTorus(vec3 p, float r1,float r2){\np.xy*=Rot(-iTime*.3);\nfloat px= length(p.xz)-r1;\n\nreturn length(vec2(px,p.y))-r2;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius){\nreturn length(p-center)-radius;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\np.xz*=Rot(iTime*.3);\nvec3 ab= b-a;\nvec3 ap=p-a;\n\nfloat t=dot(ab,ap)/dot(ab,ab);\nt=clamp(t,.0,1.);\n\nvec3 c= a+t*ab;\n\nreturn length(c-p)-r; //same as length(t*ab);\n}\n\nfloat sdRhombic(vec3 p){\n  float c=cos(3.1415/5.);\n  float s= sqrt(0.75-c*c);\n  vec3 n= vec3(-.5,-c,s);\n  p=abs(p);\n  \n  p-=2.*min(0.,dot(p,n))*n;\n\n  p.xy=abs(p.xy);\n  p-=2.*min(0.,dot(p,n))*n;\n  \n  p.xy=abs(p.xy);\n  p-=2.*min(0.,dot(p,n))*n;\n  \n  float d=p.z-1.;\n  \n  return d;\n}\n//hollow torus:\nfloat sdTorus2(vec3 p, float r1, float r2, float r22){\n  \n  return  max(sdTorus(p, r1, r2),-sdTorus(p, r1, r22));\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= cross(vec3(0,1,0),f);\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    \n    return normalize( i-ro);\n}\n\n\n\nfloat getDist(vec3 p){\n\n  bd=sdBox(p-vec3(0,2,2.5), vec3(1.5));\n  sd= sdSphere(p, vec3(0,2,-.1), 1.);\n  \n  p.xz*=Rot(iTime*.1);\n\n  td=sdTorus2(p-vec3(0,-2,5),1.5,.9,.7);\n  \n  p.xz*=Rot(-iTime*.6);\n\n  cd= max(sdCapsule(p, vec3(-2,-2,-1),vec3(-1,-3,-1),.7),-sdCapsule(p, vec3(-3,-1,-1),vec3(0,-4,-1),.6));\n  \n  rhombicd=sdRhombic(p);\n  \n  p.xz*=Rot(iTime*.5);\n\n  rhombic2d=sdRhombic(p-vec3(1.5,0,-2)); \n\n  \n  return min(min(min(min(min(rhombicd,bd),sd),cd),td),rhombic2d);\n}\n\nint getMaterial(vec3 p){\n\n if(td<SURF*1.)\n      return EMERALD;\n  else if(rhombicd<SURF*1.)\n      return DIAMOND;// DIAMOND;\n  else if(rhombic2d<SURF*1.)\n      return MIRROR;\n  else if(sd<SURF*1.)\n      return SAPHIRE;\n  else if(cd<SURF*1.)\n      return RUBY;\n  else  if(bd<SURF*1.)\n      return GLASS;\n  else return BACKGROUND;\n}\n\nvec3 getColor(vec3 p){\n  int m= getMaterial(p);\n  reflectivity=.0;\n\n  if(m==DIAMOND){\n      IOR=2.;\n      return vec3(1,1,1);  \n  }\n\n  else if(m==EMERALD){\n      IOR=1.6;\n      return vec3(.1,1,.4);  \n  }\n\n  else if(m==SAPHIRE){\n       IOR=1.8;\n      return vec3(.3,.1,1);  \n  }\n\n   else if(m==RUBY){\n       IOR=1.8;\n      return vec3(1.,.1,.3);   \n   }\n\n   else if(m==GLASS){\n       IOR=1.4;\n      return vec3(1.,1,1);    \n   }\n    \n   else if(m==MIRROR){\n       reflectivity=1.;\n       IOR= 1.;\n      return vec3(1,.7,.3);    \n   }else if(m==BACKGROUND){\n       IOR=1.;\n       return vec3(1);  \n   }\n \n      \n}\n\n\n//if side=-1 we are marching inside the object\nfloat RayMarch(vec3 ro, vec3 rd, float side){\nfloat dO=0.;\n\nfor(int i=0; i<MAX; i++){\n  vec3 pp= ro+dO*rd;\n  \n  float dS=getDist(pp)*side;\n\n  dO+=dS;\n  \n  if(dO>MAX_DIST||dS<SURF) break;\n}\n\nreturn dO;\n\n}\n\n\nvec3 getNormal(vec3 p){\n  vec2 e= vec2(0.02,0); //by not making this super small we smooth out the corners.\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyy),getDist(p- e.yxy),getDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\n   //for the 2nd total internal reflection\nvoid scatter3(inout vec3 p,inout vec3 rd, inout float dIn){\n        \n        dIn+= RayMarch(p, rd, -1.);\n    \n        vec3 pExit= p+ dIn*rd;  //exit point\n    \n        vec3 nExit= -getNormal(pExit);\n        color=min(color, getColor(pExit));\n\n        vec3 rdOut= refract(rd, nExit, IOR+abb);\n        //rdOut==0 means total internal reflection. we only count it once for simplicity\n         if(dot(rdOut,rdOut)==.0){\n        rd = rdOut;  \n        p=pExit;\n        }else\n             p= pExit -nExit*SURF*3.;  rd = rdOut;  \n}   \n   \n//for the 1st total internal reflection\nvoid scatter2(inout vec3 p, inout vec3 rd, inout float dIn){\n        \n        dIn+= RayMarch(p, rd, -1.);\n    \n        vec3 pExit= p+ dIn*rd;  //exit point\n    \n        vec3 nExit= -getNormal(pExit);\n        \n        color=min(color, getColor(pExit));\n\n        vec3 rdOut= refract(rd, nExit, IOR+abb);\n        //rdOut==0 means total internal reflection. we only count it once for simplicity\n        if(dot(rdOut,rdOut)==.0){\n        rdOut =reflect(rd, nExit); \n        rd=rdOut;\n        p=pExit+nExit*SURF*2.;\n        scatter3(p, rd,dIn);\n        }\n        else\n             p= pExit -nExit*SURF*3.;  rd=rdOut;\n}\n\n\nvoid scatter(inout vec3 p, inout vec3 rd, inout float dIn){\n      // getColor(p); //sets IOR right;\n       if(reflectivity==1.){\n            vec3 n= getNormal(p);\n            rd=reflect(rd,n);\n             p+= n*SURF*1.;\n\n        }else{\n            vec3 n= getNormal(p);\n    \n            vec3 rdIn= refract(rd, n, 1./ (IOR+abb)); //direction as we enter the object\n        \n            vec3 pEnter=p-n*SURF*3.; //start a bit deeper so the march wont terminate immediately\n        \n             dIn+= RayMarch(pEnter, rdIn, -1.);\n        \n            vec3 pExit= pEnter+ dIn*rdIn;  //exit point\n        \n            vec3 nExit= -getNormal(pExit);\n            color=min(color, getColor(pExit));        \n    \n            rd= refract(rdIn, nExit, IOR+abb);\n            //rdOut==0 means total internal reflection. we only count it once for simplicity\n            if(dot(rd,rd)==.0){\n            rd =reflect(rdIn, nExit);\n            p=pExit+nExit*SURF*2.;\n            scatter2(p,rd, dIn);//we trace a new scattering along the internal reflection\n            }       \n            else\n                 p= pExit -nExit*SURF*3.;\n                 \n             }\n}\n\n//This scatter function is for tracing the reflected part.\nvoid Qscatter(inout vec3  q, inout vec3 qd, inout float dIn){\n\n        vec3 n= getNormal(q);\n\n        vec3 qdIn= refract(qd, n, 1./ (IOR+abb)); //direction as we enter the object\n    \n        vec3 qEnter=q-n*SURF*3.; //start a bit deeper so the march wont terminate immediately\n    \n        dIn+= RayMarch(qEnter, qdIn, -1.);\n    \n        vec3 qExit= qEnter+ dIn*qdIn;  //exit point\n        color2=color2* getColor(qExit);        \n\n        vec3 nExit= -getNormal(qExit);\n\n        qd= refract(qdIn, nExit, IOR+abb);\n        //rdOut==0 means total internal reflection. we only count it once for simplicity\n        if(dot(qd,qd)==.0){\n        qd =reflect(qdIn, nExit);\n        } else\n             q= qExit -nExit*SURF*3.;\n        \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n\n    \n    //camera: \n    float zoom= .6;\n    vec3 ro= vec3(-3,3,-3);\n    \n    ro.yz*=Rot(-m.y*6.28);\n    ro.xz*=Rot(-m.x*6.28);\n    \n    vec3 lookAt=vec3(0,0,0);\n    \n    vec3 rd= getRayDir(uv, ro, lookAt,zoom);\n\n    vec3 col = vec3(0);\n    float d= RayMarch(ro,rd,1.);\n    vec3 p=ro;\n    \n    if(d<MAX_DIST){//if we hit the object:\n   \n        p+=d*rd; float dIn=0.;\n        vec3 q=p; //q tracts the reflected component\n        vec3 qd=rd; //qd for the reflected direction\n        color= getColor(p);\n        color2=getColor(q);\n        vec3 refraction, reflection;\n        int  mirror= getMaterial(p)==MIRROR ? 1:0;\n\n        \n        //first trace the refracted component if not mirror:\n        if(mirror==0){\n            for(int i=0;i<REFRACTIONS; i++){ //how many objects we refract from\n                if(d<10.){\n                    scatter(p, rd, dIn);\n                    \n                    //march to the next object:\n                    d= RayMarch(p,rd,1.);\n                    p+=d*rd;\n                    color=min(color,getColor(p));\n                }\n             }\n        \n      //absorbtion:\n      float optDist= exp(-dIn*dens);\n      refraction = texture(iChannel0,rd).rgb*optDist*color;\n      }\n      \n      \n        //next trace the reflected component:\n         dIn=0.;\n         vec3 n= getNormal(q); \n         float fresnel= pow(1.+ dot(n, qd),3.); \n         qd= reflect(qd,n);\n\n         for(int i=0;i<REFRACTIONS; i++){\n            float d2=RayMarch(q+n*SURF*2., qd,1.);\n            if(d2<10.){\n              q+=d2*qd;  //go to next object\n              color2=color2*getColor(q); //sets IOR for the material\n              if(reflectivity!=1.)\n                  Qscatter(q, qd, dIn);\n              else{\n                  n= getNormal(q);\n                  qd=reflect(qd,n);\n                  dIn+=.1;\n               }\n             }\n           }\n        float optDist= exp(-dIn*dens);\n        reflection = texture(iChannel0, qd).rgb*optDist*color2;\n        \n        \n      //mix reflected and refracted components:\n      if(mirror==1) \n        col=reflection;\n      else\n        col=mix(refraction, reflection, fresnel); \n\n\n    } else{\n        col = texture(iChannel0,rd).rgb;  // background with cube map\n    }\n\n    col=pow(col, vec3(.4545));//gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}