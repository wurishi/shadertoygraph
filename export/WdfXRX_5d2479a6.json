{"ver":"0.1","info":{"id":"WdfXRX","date":"1552066321","viewed":90,"name":"Task 1 Raymarching","username":"TrickyFox","description":"Задание №1\nОсновная часть 15 баллов\n+ поворот мышкой 2 балла\n+ мягкие тени 3 балла\n+ туман 1 балл\n+ фрактал 2 балла\n\nВсего: 23 балла\n\nPress F  ̶t̶o̶ ̶p̶a̶y̶ ̶r̶e̶s̶p̶e̶c̶t̶  to watch fractal","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 300\n#define MIN 0.0\n#define MAX 100.0\n#define EPS 0.0001\n#define M_PI 3.14159265359\nvec3 c = vec3(0.0, 0.0, 0.1);\n\nvec4 unite(float first, float second, vec3 c1, vec3 c2){\n    return first < second ? vec4(c1, first) : vec4(c2, second);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat box(vec3 p, vec3 r){\n \tvec3 d = abs(p) - r;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat plane(vec3 p, float r){\n    return  p.y + r;\n}\n\nfloat mandelbox(vec3 p){\n    vec3 np = p;\n    float d = 1.0;\n    float r;\n    int i;\n    for(i = 0; i < 9; ++i){\n        np = clamp(np, -1.0, 1.0) * 2.0 - np;\n        r = dot(np, np);\n    \tif(r < EPS){\n            np *= 20.0;\n            d *= 20.0;\n        } else if(r < 2.0){\n            np *= 2.0 / r;\n            d *= 2.0 / r;\n        }\n        np*= -1.8;\n        np += p;\n        d *= 1.8;\n        d += 1.0;\n    }\n    return length(np) / abs(d);\n}\n\nfloat scene(vec3 p){\n    vec4 ret;\n    vec3 c1 = vec3(0.0, 0.0, 0.1);\n    vec3 c2 = vec3(0.0, 0.1, 0.0);\n    vec3 c3 = vec3(0.1, 0.0, 0.1);\n    vec3 c4 = vec3(0.0, 0.1, 0.1);\n    vec3 c5 = vec3(0.1, 0.0, 0.0);\n    vec3 c6 = vec3(0.1, 0.1, 0.1);\n    vec3 c7 = vec3(0.2, 0.1, 0.0);\n    if(texture(iChannel0, vec2(70.5/256.0, 0.75)).x > 0.0){\n        ret = unite(mandelbox(vec3(p.x, p.y, p.z)), plane(p, 5.0), c7, c6);\n    } else {\n        ret = unite(torus(p, vec2(2.0 + 0.8 * sin(1.2 * iTime), 0.1)), sphere(p, 0.9), c2, c1);\n        ret = unite(torus(p, vec2(2.5 + 0.8 * sin(1.2 * iTime), 0.1)), ret.w, c3, ret.xyz);\n        ret = unite(torus(p, vec2(3.0 + 0.8 * sin(1.2 * iTime), 0.1)), ret.w, c4, ret.xyz);\n        ret = unite(capsule(p, vec3(0.1, -1.9, 0.6), vec3(-0.2, 1.75, -0.75), 0.1), ret.w, c5, ret.xyz);\n        ret = unite(plane(p, 5.0), ret.w, c6, ret.xyz);\n        ret = unite(box(vec3(p.x, p.y + 4.0, p.z + 15.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n        ret = unite(box(vec3(p.x - 15.0, p.y + 4.0, p.z - 2.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n        ret = unite(box(vec3(p.x + 15.0, p.y + 4.0, p.z - 2.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n        ret = unite(box(vec3(p.x + 15.0, p.y + 4.0, p.z + 13.0), vec3(1.0, 1.0, 1.0)), ret.w, c1, ret.xyz);\n    }\n    c = ret.xyz;\n    return ret.w;\n}\n\nfloat raymarching(vec3 eye, vec3 dir, float beg, float end){\n    float dep = beg;\n    int i;\n    for(i = 0; i < STEPS; ++i){\n        float dist = scene(eye + dep * dir);\n        dep += dist;\n        if(dep >= end || dist < EPS){\n            return dep;\n        }\n    }\n    return end;\n}          \n\nvec3 illumination(vec3 c, float shine, vec3 p, vec3 eye, vec3 pos){\n    vec3 ints = vec3(1.7, 1.7, 1.7);\n    vec3 f = normalize(vec3(\n        scene(vec3(p.x + EPS, p.y, p.z)) - scene(vec3(p.x - EPS, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPS, p.z)) - scene(vec3(p.x, p.y - EPS, p.z)),\n        scene(vec3(p.x, p.y, p.z + EPS)) - scene(vec3(p.x, p.y, p.z - EPS))\n    ));\n    vec3 s = normalize(pos - p);\n    float tmp1 = dot(s, f);\n    float tmp2 = dot(normalize(reflect(-s, f)), normalize(eye - p));\n    return (tmp1 < 0.0) ? vec3(0.0, 0.0, 0.0) : \n    \t((tmp2 < 0.0) ? ints * c * tmp1 : ints * c * (tmp1 + pow(tmp2, shine)));\n}\n\nfloat shadow(vec3 p, vec3 light, float mn, float mx, float sft){\n    float r = 1.0;\n    float h;\n    vec3 np = normalize(light - p);\n    float t;\n    for(t = mn; t < mx; t += h){\n        h = scene(p + np * t);\n        if(h < EPS){\n            return 0.0;\n        }\n        r = min(r, sft * h / t);\n    }\n    return r;\n}\n\nvec3 fog(vec3 c, vec3 fc, float d){\n    float b = 0.07;\n    float am = (1.0 - exp(-d * b)) * 0.9;\n    return mix(c, fc, am);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y) * M_PI;\n    float x = fragCoord.x - iResolution.x / 2.0;\n    float y = fragCoord.y - iResolution.y / 2.0;\n    float z = -iResolution.x;\n    \n    vec3 eye = vec3(14.0 * cos(m.y) * cos(m.x), 11.0 * sin(m.y), 13.0 * cos(m.y) * sin(m.x));\n\n    vec3 v1 = normalize(vec3(0.0, 0.0, 0.0) - eye);\n    vec3 v2 = normalize(cross(v1, vec3(0.0, 1.0, 0.0)));\n    vec3 v3 = cross(v2, v1);\n    \n    vec3 wdir = mat3(v2, v3, -v1) * normalize(vec3(x, y, z));\n    \n    float dist = raymarching(eye, wdir, MIN, MAX);\n    \n    if(dist > MAX - EPS){\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * wdir;\n    float shine = 60.0;\n\n    vec3 fpos = vec3(5.0 * sin(iTime), 2.0, 5.0 * cos(iTime));\n    vec3 spos = vec3(2.0 * sin(0.5 * iTime), 2.0, 3.0 * cos(0.5 * iTime));\n    vec3 color1 = c, color2 = c;\n\n    color1 += illumination(c * 2.0, shine, p, eye, fpos);\n    color2 += illumination(c * 2.0, shine, p, eye, spos);\n\n    color1 *= shadow(p, fpos, 0.1, distance(fpos, p), 30.3);\n    color2 *= shadow(p, spos, 0.1, distance(spos, p), 30.3);\n    \n    if(p.y < -3.4){\n        color1 = fog(color1, vec3(0.5, 0.6, 0.7), distance(fpos, p));\n        color2 = fog(color2, vec3(0.5, 0.6, 0.7), distance(spos, p));\n    }\n    \n    fragColor = vec4(color1 + color2, 1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}