{"ver":"0.1","info":{"id":"WsKXDw","date":"1580404906","viewed":95,"name":"Graph Waveform","username":"spalmer","description":"helps visualize function shape; designed for [-1,1] range and slides display across 4 integers by default, but can be tuned various ways.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["wave","graph","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if 0 \n// anyway these functions are merely examples at this point\n// designed to stress test the grapher in various ways\n\n// idk why osctri should necessarily be this period;\n// I have one where it's all 0..1 like it seems would make more sense.\n// this is from my rand testbed where I did it for a particular reason.\nfloat osctri(float x) \n{\n\tfloat i = floor(x); \n\tx -= i; // now mirror the odd ones to preserve local contiguity\n\tfloat o = float(int(i) & 1);\n    return o + x - 2.*o*x; // branchless, eval to either 0 + x - 2*0*x = x, or 1 + x - 2*1*x = 1 - x; one conversion\n}\n// a half-turns units sinewave?  wtf man... but it matches osctri period\nfloat sinus(float x)\n{\n    return sin(x * 3.141592) * .5 + .5;\n}\n\nfloat sqsg(float x) \n{\n    x = x * 2. - 1.;\n    x *= abs(x);\n    return x * .5 + .5;\n}\n#endif\n\nfloat f(float x)\n{\n//    return fract(x);\n//    return sinus(x);\n//    return osctri(x);\n//    return sqsg(fract(x));\n//    return sqsg(sinus(x));\n//    return sqsg(osctri(x));\n    return sin(x*.2*3.141592);\n}\n\nfloat graphf(float x, float w, float y, float thick)\n{\n//    return graphAA(.5, f(x-w) - y, f(x+w) - y, thick);\n    return graph(f(x) - y, thick, 1./iResolution.y);\n}\n\n// FIXME at this point the shader's working well,\n// but seriously could use rewritten and optimized.\n// the coordinate manipulation is egregious.\n// It barely supports thick lines at all.\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy, uv = p/R;\n    float s = 4. //24. //6.; //12. // x units to squeeze into view\n\t, x = (uv.x-1.) * s \n        + (length(iMouse.xy) > .9 ? 4.-2.*iMouse.x/R.y : iTime * .02)\n    , w = .5 * s / R.x\n    , y = mix(-1.1,1.1,uv.y) //mix(-.1,1.1,uv.y) // choose vertical range; should be config constants\n    , th = 25.;\n    // black on white\n    vec3 col = vec3(1.-graphf(x, w, y, th/R.y));\n    \n\t// FIXME The grid coloration is a poor example, hard to tune colors.\n   #if 1 // antialiased grid lines\n    vec2 gp = (fract(vec2(x,y)+.5)-.5)*R/vec2(s,1);    \n    float gd = min(abs(gp.x),abs(gp.y));\n    float grid = 1.-exp2(-1.5*gd);\n    col.b *= mix(.1,1.,grid); // coloration is a lame channel HACK though\n   #endif\n\n   #if 1 // antialiased axis lines\n    vec2 ap = vec2(x,y)*R.xy/vec2(s,1);    \n    float ad = min(abs(ap.x),abs(ap.y));\n    float axes = 1.-exp2(-1.5*ad);\n    col.r *= mix(.1,1.,axes);\n   #endif\n\n    col = pow(col, vec3(1./2.2)); // to approx sRGB gamut\n    c = vec4(col, 1.);\n}\n\n\n/*\nvec2 magnify(vec2 p)\n{\n    if (dot(p, p) < 80.*80.)\n        p = floor(p * 1./8.) + .5;\n    return p;\n}\n\n//    if (iMouse.z >= 0.) p = magnify(p - iMouse.xy) + iMouse.xy;\n*/\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// see https://www.shadertoy.com/view/WlcXW8\n// for one that checks line segment distance\n\n// this one works off automatic derivatives.\n// seriously I'm ready to give up on them!\n\nfloat aa(float e)\n{\n    return clamp(1. - max(e, 0.), 0., 1.);\n}\n\nfloat graphOld(float v, float thick)\n{\n    float a = abs(dFdx(v));\n    a = min(a, .125); // limit length of broken derivatives\n    float s = 1.*a + thick;\n    return aa(abs(v) / s);\n}\n\n// actually *not* working so perfectly, here, and it's driving me nuts why not!\nfloat graphPerfect(float v, float thick)\n{\n    float y = dFdx(v);\n    // little trick I learned from oneshade https://shadertoy.com/view/NdKSWV\n    // I guess it works by \"rotating\" the derivative flat?\n    // the thickness doesn't even work\n    // wah wah wah\n    return clamp(1. - abs(v)/sqrt(thick*thick*1. + y*y), 0., 1.);\n} // still trying to grok it though... I feel like it's equivalent to:\n\nfloat graphTrig(float v, float thick, float aa)\n{\n// was thinking about this elsewhere and decided if derivative is a tangent,\n// when tangent is 0, line is flat, we have a pure vertical delta, \n// properly aligned already but in view units, not pixels.\n// when tangent is infinite, line is vertical, our delta isn't meaningful.\n// when tangent is 1, line is 45 degrees, we have a sine when we need \n// to rotate it back flat again, or in such case, divide by sqrt(.5)\n// so we need to divide by the sine of the angle?\n// can obtain the angle using atan, or at least abs(atan(y))\n// then obviously /sin .. worth a shot!\n// visually I can't distinguish it from graphPerfect so maybe it's good!  just expensive.\n    float y = dFdx(v); // FIXME don't have the correct scale factor to get back to pixels\n    //y *= aa; // maybe? doesn't help.\n    //return clamp(.5 - (abs(v) - thick) / sin(abs(atan(y))), 0., 1.);\n    return clamp(1. - (abs(v) - thick) / sin(abs(atan(y))), 0., 1.);\n    //return clamp(1. - (abs(v) - thick) * cos(abs(atan(y))), 0., 1.);\n}\n\n// I swear if I ever solve this I'm gonna go back and\n// install the \"correct\" solution into every single toy I ever made\nfloat graph(float v, float thick, float w)\n{\n//    return graphOld(v, thick);\n//    return graphTrig(v, thick, w);\n    return graphPerfect(v, thick);\n}\n\n// while certainly better than not using it, this\n// still doesn't completely solve the fundamental \n// problems with plotting discontinuities using\n// automatic window derivatives\n/*float graphAA(float xf, float v0, float v1, float thick)\n{\n    float g0 = graph(v0,thick);\n    float g1 = graph(v1,thick);\n    return mix(g0,g1,xf);\n}*/\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}