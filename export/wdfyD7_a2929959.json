{"ver":"0.1","info":{"id":"wdfyD7","date":"1584897501","viewed":152,"name":"Dicey Grid","username":"Passion","description":"spacing experiment.","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["noise","grid","raymarch","index"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4ljGDR","filepath":"https://soundcloud.com/zeki-erg-z/deadmau5-clockwork-original","previewfilepath":"https://soundcloud.com/zeki-erg-z/deadmau5-clockwork-original","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2020 Passion\n// Timothy Michael Walsh\n\n#define NUM_STEPS 48\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s,-c,c,s);\n}\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat hash31(vec3 p){\n    p = fract(p*vec3(123.34, 456.21, 768.78));\n    p += dot(p, p+45.32);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 color = vec3(0.0);\n\nfloat map(vec3 p){\n    vec3 id = floor(p);\n    float r = hash31(id.xzx);\n    \n    float sn = sin(noise(vec2(iTime))+1.5);\n    float spacing = clamp(sn, .5, 1.725);//+.1;\n    id = floor(p*spacing);\n    float rrr = hash31(id);\n    float fastSlow = (rrr<.49) ? 1.0 : 3.0;\n\n    p = mod(clamp(p, -2.0/spacing, 2.0/spacing),1.0/spacing)-.5/spacing;\n    \n    float circle =  0.0; \n    float d = circle;\n\n    float rr = hash31(id);//*(spacing*.0025);\n    p.xy *= r2( spacing*rr*fastSlow*13.0 ); //(rr*iTime*4.0*fastSlow)*(spacing*.0725));\n    p.zx *= r2( spacing*rr*fastSlow*14.0 ); //(fract(rr*34.45)*iTime*3.5*fastSlow)*(spacing*.0725));\n    \n    circle = udRoundBox(p, vec3(.2), .02);\n    float n1x = hash31(id.yzy);\n    float n1y = hash31(id.xzx);\n    float n1z = hash31(id.yxy);\n    color = clamp(vec3(n1x,n1y,n1z),.5,.95)*1.5;\n    \n    return circle;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++){\n        float d = map(o+r*t);\n        if(abs(d) < 0.01 || t > 15.) break;\n        t += d*0.75; \n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0, 0.01);\n    return normalize((vec3(map(p+e.yxx),map(p+e.xyx),map(p+e.xxy))-map(p))/e.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord/iResolution.xy)-1.0;\n    //uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float t = iTime*.5;\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*.325));\n    //float spacing = clamp((sin(iTime)+1.0), .5, 1.25);\n    vec3 o = vec3(0.0, 0.0, -3.5);   //+iTime\n    o.zy *= r2(t*1.5);\n    \n    r.zy *= r2(t*1.5);\n    o.xz *= r2(-t*.75);\n    r.xz *= r2(-t*.75);\n    float ht = trace(o, r);\n    vec3 sp = o+r*ht;\n    float d = map(sp);\n    vec3 l = normalize(vec3(0.2,0.8,0.1));\n\tvec3 n = getNormal(sp);\n    \n    vec3 viewDir = normalize(r);\n\n    // this is blinn phong\n    vec3 halfDir = normalize(l - viewDir);\n    float specAngle = max(dot(halfDir, n), 0.0);\n    float specular = pow(specAngle, 80.0);\n    \n    float ss = texture(iChannel1, vec2(0.0,0.75)).r;\n    \n    vec4 bg = mix(vec4(0.94)*r.y, vec4(0.0), smoothstep(.071,0.83,sin(ss+r.y*29.)));\n    float fog = smoothstep(0.63, 0.01, ht*.03);\n    vec3 rf = reflect(r,n);\n    vec4 tx = texture(iChannel0, rf)+.5;\n\n    fragColor = (abs(d) < 0.01) ? mix(bg, tx*vec4(color, 1.0)*clamp(dot(n,l),0.2,1.0)+specular, fog) : vec4(bg);\n \n}","name":"Image","description":"","type":"image"}]}