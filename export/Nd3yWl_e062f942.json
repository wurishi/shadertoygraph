{"ver":"0.1","info":{"id":"Nd3yWl","date":"1666722493","viewed":119,"name":"Merging Balls","username":"UwUCoder","description":"They are merging :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","test","metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAXMARCH = 255;\nconst float START = 0.0;\nconst float MAXDIST = 100.0;\nconst float PRECISION = 0.001;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nstruct Surface {\n    float sd;\n    vec3 col;\n};\n\nSurface opSmoothUnion(Surface d1, Surface d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n  return Surface(mix( d2.sd, d1.sd, h ) - k*h*(1.0-h), mix( d2.col, d1.col, h));\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 color)\n{\n    float d = length(p - offset) - r;\n    return Surface(d, color);\n}\n\nSurface minColor(Surface a, Surface b)\n{\n    if (a.sd < b.sd) return a;\n    return b;\n}\n\nSurface sdScene(vec3 p)\n{\n    Surface sphereLeft = sdSphere(p, 1., vec3(-2. * cos(iTime), 0, 0.), vec3(1., 1., 0.));\n    Surface sphereRight = sdSphere(p, 1., vec3(2. * cos(iTime), 0, 0.), vec3(0., 1., 1.));\n    Surface spheremiddle = sdSphere(p, 1., vec3(0, -2. * cos(iTime), 0), vec3(0., 1., 0.));\n    Surface spheremiddleup = sdSphere(p, 1., vec3(0, 2. * cos(iTime), 0), vec3(1., 0.65, 0.));\n    Surface co = opSmoothUnion(sphereLeft, sphereRight, 1.);\n    co = opSmoothUnion(co, spheremiddle, 1.);\n    co = opSmoothUnion(co, spheremiddleup, 1.);\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end)\n{\n    float depth = start;\n    Surface co;\n    for (int i = 0; i < MAXMARCH; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    float e = 0.0005;\n    float r = 1.;\n    return normalize(vec3(\n        sdScene(vec3(p.x + e, p.y, p.z)).sd - sdScene(vec3(p.x - e, p.y, p.z)).sd,\n        sdScene(vec3(p.x, p.y + e, p.z)).sd - sdScene(vec3(p.x, p.y - e, p.z)).sd,\n        sdScene(vec3(p.x, p.y, p.z + e)).sd - sdScene(vec3(p.x, p.y, p.z - e)).sd\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1.0);\n    \n    vec3 ro = vec3(0., 0., 7.);\n    vec3 rd = vec3(uv, -1.0);\n    \n    Surface co = rayMarch(ro, rd, START, MAXDIST);\n    \n    if (co.sd > MAXDIST) {\n        col = vec3(0.);\n    } else {\n        vec3 norm = calcNormal(vec3(ro + rd * co.sd));\n        vec3 lightPos = vec3(0, 0, 10.);\n        vec3 lightNorm = normalize(lightPos - (ro + rd * co.sd));\n        float dif = clamp(dot(lightNorm, norm), 0.3, 1.);\n        col = dif * co.col;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}