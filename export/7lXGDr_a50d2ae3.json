{"ver":"0.1","info":{"id":"7lXGDr","date":"1621889052","viewed":203,"name":"Diffuse Lighting Model","username":"trigophers","description":"Direct light path tracer","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracer","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 tonemap2(vec3 inc) {\n    vec3 addon=vec3(pow(max((inc.y-1.0)/2.0, 0.0), 2.0)+pow(max((inc.z-1.0)/2.0, 0.0), 2.0),\n                    pow(max((inc.x-1.0)/2.0, 0.0), 2.0)+pow(max((inc.z-1.0)/2.0, 0.0), 2.0),\n                    pow(max((inc.x-1.0)/2.0, 0.0), 2.0)+pow(max((inc.y-1.0)/2.0, 0.0), 2.0));\n    return addon + inc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, vec2(uv));\n    vec3 dispc = col.xyz/col.w;\n    dispc = tonemap2(dispc);\n    \n    fragColor = vec4(pow(dispc, vec3(.4545)), 1.0); // gamma correction\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define maxDist 10000.\n#define pi 3.14159265359\nvec3 center;\nvec3 ray;\nfloat rdist;\nvec3 color;\nvec3 normal;\nvec3 temp;\nbool inside;\n\n// visual studios rand()\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// hash to initialize the random seed (copied from Hugo Elias)\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand()*2.0-1.0;\n    float a = frand()*2.0*pi;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n\nvec2 randCircle(float rad) {\n    float d = frand()*2.0*pi;\n    float m = sqrt(frand())*rad;\n    return m*vec2(cos(d), sin(d));\n}\n\nfloat surfaceArea(vec3 i, vec3 n) {\n    return max(cos(pi*(1.0-dot(i, n))/2.0), 0.0);\n}\n\nvoid setVec(vec3 cP, vec3 cR) {\n    center = cP;\n    ray = normalize(cR);\n}\n\nvoid dirVec(vec2 cD) {\n    temp.x = ray.z;\n    ray.z = ray.z * cos(cD.y) - ray.y * sin(cD.y);\n    ray.y = ray.y * cos(cD.y) + temp.x * sin(cD.y);\n    temp.x = ray.z;\n    ray.z = ray.z * cos(cD.x) - ray.x * sin(cD.x);\n    ray.x = ray.x * cos(cD.x) + temp.x * sin(cD.x);\n}\n\nvoid sphere(vec4 posRad, vec3 sColor) {\n    vec3 obj = posRad.xyz - center;\n    vec3 temp = vec3(dot(obj, ray), dot(obj, obj), 0.);\n    if ((temp.x>0.0) && (posRad.w*posRad.w > (temp.y - temp.x*temp.x))) {\n        temp.z = sqrt(posRad.w*posRad.w - (temp.y - temp.x*temp.x));\n        if ((temp.y > posRad.w*posRad.w) && rdist > temp.x - temp.z) {\n            rdist = temp.x - temp.z;\n            normal = normalize(center+ray*rdist-posRad.xyz);\n            color = sColor;\n        }\n    }\n}\n\nvoid iSphere(vec3 ce, float ra, vec3 sColor) {\n    vec3 temp1 = center - ce;\n    float temp0x = dot( temp1, ray );\n    float temp0y = dot( temp1, temp1 ) - ra*ra;\n    float temp0z = temp0x*temp0x - temp0y;\n    if(temp0z >= 0.0) {\n        temp0z = sqrt(temp0z);\n        bool hit = false;\n        float d;\n        if (dot(temp1, temp1) < ra*ra) {\n            d = -temp0x+temp0z;\n            if (d < rdist && d > 0.0) \n                hit = inside = true;\n        } else {\n            d = -temp0x-temp0z;\n            if (d < rdist && d > 0.0) {\n                hit = true; inside = false;\n            }\n        }\n        if (hit) {\n            rdist = d;\n            normal = (center+ray*rdist-ce)/ra;\n            if (inside) normal *= -1.0;\n        \n            color = sColor;\n        }\n    } \n}\n\nvoid scene() {\n    iSphere(vec3(-4, 5, 0), 5.0, vec3(1, 0.1, 0.1));\n    iSphere(vec3(5, 4, 0), 4.0, vec3(0.1, 1, 0.1));\n    iSphere(vec3(0, -1000000, 30), 1000000.0, vec3(0.3, 0.5, 0.5));\n}\n\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_2PI 0.15915494309189535\n\nvec3 modifiedPhongBRDF(vec3 lightDir, vec3 viewDir, vec3 normal, \n                vec3 phongDiffuseCol, vec3 phongSpecularCol, float phongShininess) {\n  vec3 color = phongDiffuseCol * RECIPROCAL_PI;\n  vec3 reflectDir = reflect(-lightDir, normal);\n  float specDot = max(dot(reflectDir, viewDir), 0.001);\n  float normalization = (phongShininess + 2.0) * RECIPROCAL_2PI; \n  color += pow(specDot, phongShininess) * normalization * phongSpecularCol;\n  return color;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat D_GGX(float NoH, float roughness) {\n  float alpha = roughness * roughness;\n  float alpha2 = alpha * alpha;\n  float NoH2 = NoH * NoH;\n  float b = (NoH2 * (alpha2 - 1.0) + 1.0);\n  return alpha2 * RECIPROCAL_PI / (b * b);\n}\n\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n  float alpha = roughness * roughness;\n  float k = alpha / 2.0;\n  return max(NoV, 0.001) / (NoV * (1.0 - k) + k);\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n  return G1_GGX_Schlick(NoL, roughness) * G1_GGX_Schlick(NoV, roughness);\n}\n\nfloat fresnelSchlick90(float cosTheta, float F0, float F90) {\n  return F0 + (F90 - F0) * pow(1.0 - cosTheta, 5.0);\n} \n\nfloat disneyDiffuseFactor(float NoV, float NoL, float VoH, float roughness) {\n  float alpha = roughness * roughness;\n  float F90 = 0.5 + 2.0 * alpha * VoH * VoH;\n  float F_in = fresnelSchlick90(NoL, 1.0, F90);\n  float F_out = fresnelSchlick90(NoV, 1.0, F90);\n  return F_in * F_out;\n}\n\nvec3 brdfMicrofacet(in vec3 L, in vec3 V, in vec3 N,\n                        in float metallic, in float roughness, in vec3 baseColor, in float reflectance) {\n\n  vec3 H = normalize(V + L);\n  \n  float NoV = clamp(dot(N, V), 0.0, 1.0);\n  float NoL = clamp(dot(N, L), 0.0, 1.0);\n  float NoH = clamp(dot(N, H), 0.0, 1.0);\n  float VoH = clamp(dot(V, H), 0.0, 1.0);\n  \n  vec3 f0 = vec3(0.16 * (reflectance * reflectance));\n  f0 = mix(f0, baseColor, metallic);\n  \n  vec3 F = fresnelSchlick(VoH, f0);\n  float D = D_GGX(NoH, roughness);\n  float G = G_Smith(NoV, NoL, roughness);\n  \n  vec3 spec = (F * D * G) / (4.0 * max(NoV, 0.001) * max(NoL, 0.001));\n  \n  vec3 rhoD = baseColor;\n  \n  // optionally\n  rhoD *= vec3(1.0) - F;\n  //rhoD *= disneyDiffuseFactor(NoV, NoL, VoH, roughness);\n  \n  rhoD *= (1.0 - metallic);\n  \n  vec3 diff = rhoD * RECIPROCAL_PI;\n  \n  return diff + spec;\n}\n\nvec3 circleLight(vec3 pos, float r, vec3 power, vec3 intersection, vec3 n) {\n    vec2 temp2 = randCircle(r);\n    vec3 light = pos+vec3(temp2.x, 0.0, temp2.y);\n    vec3 li = light-intersection;\n    vec3 lightVec = normalize(li);\n    float invSq = dot(li, li);\n    float area = surfaceArea(-lightVec, vec3(0, -1, 0))*pi*r*r;\n    center = intersection+n/10.; //no shadow acne\n    ray = lightVec;\n    rdist = maxDist;\n    scene();\n    if (rdist<maxDist) return vec3(0);\n    return surfaceArea(lightVec, n)/invSq*power*area;\n}\n\nvec3 pointLight(vec3 light, vec3 power, vec3 intersection, vec3 n) {\n    //vec3 li = light-intersection;\n    vec3 li = light;\n    vec3 lightVec = normalize(li);\n    float invSq = dot(li, li);\n    float area = surfaceArea(-lightVec, vec3(0, -1, 0))*pi;\n    center = intersection+n/10.; //no shadow acne\n    ray = lightVec;\n    rdist = maxDist;\n    scene();\n    if (rdist<maxDist) return vec3(0);\n    return surfaceArea(lightVec, n)/invSq*power*area;\n}\n\nvec3 cLightPosition(vec3 pos, float r) {\n    vec2 temp2 = randCircle(r);\n    return pos + vec3(temp2.x, 0.0, temp2.y);\n}\n\nvec3 cookTorrance(vec3 light, vec3 intrs, vec3 colrs, vec3 norms, vec3 rays) {   \n    vec3 brdf = brdfMicrofacet(normalize(light - intrs), -rays, norms, 0.0, 0.4, colrs, 0.8);   \n    return brdf;\n}\n\nvec3 raytrace(vec2 uv) {\n    const int maxR = 8;\n    vec3 intrs[maxR]; vec3 colrs[maxR]; vec3 norms[maxR]; vec3 rays[maxR];\n    vec3 CamPos = vec3(0., 5., -20.);\n    setVec(CamPos, vec3(uv, 1.0));\n    int i;\n    for (i = 0; i < maxR; i++) {\n        rdist = maxDist;\n        scene();\n        if (rdist<maxDist) {\n            //return circleLight(vec3(20, 40, -10), 10.0, vec3(4.0), center+rdist*ray, color);\n            intrs[i] = center+rdist*ray;\n            colrs[i] = color;\n            norms[i] = normal;\n            rays[i] = ray;\n            center = center+rdist*ray+normal/100.0;\n            ray = cosineDirection(normal);\n        } else {\n            //return vec3(0.0);\n            break;\n        }\n    }\n    vec3 accuC = vec3(0);\n    for (int j = i-1; j >= 0; j--) {\n        vec3 light = cLightPosition(vec3(20, 40, -10), 10.0);\n        accuC += pointLight(light, 4.0*vec3(512.0), intrs[j], norms[j]);\n        //accuC += circleLight(vec3(20, 40, -10), 10.0, vec3(4.0), intrs[j], norms[j]);\n        accuC *= cookTorrance(light, intrs[j], colrs[j], norms[j], rays[j]);/*modifiedPhongBRDF(normalize(intrs[j]-light), rays[j], norms[j], colrs[j], vec3(0.1), 128.0);*/\n    }\n    return accuC;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    vec3 col = vec3(0);\n    \n    for (int i = 0; i < 16; i++) {\n        vec2 uv = (fragCoord.xy-iResolution.xy/2.+vec2(frand(), frand()))/iResolution.yy;\n        col += raytrace(uv+vec2(1./iResolution.x/2., -1./iResolution.x/2.));\n    }\n    \n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    vec4 data = texture(iChannel0, uv2);\n    if (texelFetch(iChannel1,ivec2(32,0),0).x==1.0 || iMouse.z > 0.0) data = vec4(0.0);\n    data += vec4(col/16.0, 1.0); // accumulate\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}