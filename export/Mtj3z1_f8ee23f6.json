{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec3 nSphere(in vec3 pos, in vec4 sph) {\n    return (pos - sph.xyz) / sph.w;\n}\n\nvec3 nPlane(in vec3 pos) {\n    return vec3(0.0, 1.0, 0.0);\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph) {\n    /*\n      So a sphere centered at the origin has an equation |xyz| = r\n      meaning |xyz| ^ 2 = r^2 , meaning <xyz, xyz> = r^2\n      now xyz = ro + t * rd, therefore |ro| ^ 2 + t^2 + 2<ro, rd>t - r ^ 2 = 0\n    */\n    vec3 oc = ro - sph.xyz;\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - 4.0  * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sqrt(h)) / 2.0;\n    return t;\n}\n\nvec4 sph1 = vec4(0.0, 1.0, 0.0, 1.0);\nfloat iPlane(in vec3 ro, in vec3 rd) {\n    // equation of a plane, y = 0 = ro.y + t * rd.y\n    return -ro.y/rd.y;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT) {\n    resT = 1000.0;\n    float id = -1.0;\n    float tsph = iSphere(ro, rd, sph1); // intersect with a sphere\n    float tpla = iPlane(ro, rd); //intersect with a plane\n    if (tsph > 1.0) {\n        id = 1.0;\n        resT = tsph;\n    }\n    \n    if (tpla > 0.0 && tpla < resT) {\n      id = 2.0;\n      resT = tpla;\n    }\n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 light = normalize(vec3(0.57703));\n    // uv are the pixel coordinates from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    sph1.x = 0.5 * cos(iTime);\n    sph1.z = 0.5 * sin(iTime);\n    \n    // we generate a ray with origin ro and direction rd\n    vec3 ro = vec3(0.0, 0.5, 3.0);\n    vec3 rd = normalize(vec3((-1.0 + 2.0 * uv) * vec2(1.78, 1.0), -1.0));\n    \n    // we intersect the ray with the 3d scene\n    float t;\n    float id = intersect(ro, rd, t);\n    \n    // We need to do some lighting\n    // and for that we need normals\n    \n    vec3 col = vec3(0.7);\n    \n    if (id > 0.5 && id < 1.5) {\n      // if we hit the sphere\n      vec3 pos = ro + t * rd;\n      vec3 nor = nSphere(pos, sph1); \n      float dif = clamp(dot(nor, light), 0.0, 1.0);\n      float ao = 0.5 + 0.5  * nor.y;\n      col = vec3(0.9, 0.8, 0.6) * dif * ao + vec3(0.1, 0.2, 0.4) * ao;\n    } else if (id > 1.5) {\n        // we hit the plane\n        vec3 pos = ro + t * rd;\n        vec3 nor = nPlane(pos);\n        float dif = clamp(dot(nor, light), 0.0, 1.0);\n        float amb = smoothstep(0.0, 2.0 * sph1.w, length(pos.xz - sph1.xz));\n        col = vec3(amb * 0.7);\n    \n    }\n    \n    col = sqrt(col);\n    \n\tfragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mtj3z1","date":"1427064739","viewed":441,"name":"Simple Raytracing Example","username":"seabre","description":"Just me going through this video with Inigo (iq) livecoding a raytracer and me porting to shadertoy as I followed along: https://www.youtube.com/watch?v=9g8CdctxmeU","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","iq"],"hasliked":0,"parentid":"","parentname":""}}