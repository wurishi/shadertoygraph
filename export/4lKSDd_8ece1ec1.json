{"ver":"0.1","info":{"id":"4lKSDd","date":"1486525031","viewed":179,"name":"Rorschach Test","username":"h3nnn4n","description":"A displacement map is used to make random symmetric shapes that resembles the Rorschach Test.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","displacement","random","rorschach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PRNG code\nfloat random( in vec2 ps ) {\n    float a = 192523.4;  // Change this 5 magic numbers to get different images!\n    float b = 421671.8;\n    float c = 368356.1;\n    float d = 4112.1;\n    float e = 5462346.0;\n\treturn fract(\n        sin(\n         dot(\n             vec2(fract(sin(ps * a) + cos(ps * b))),\n             vec2(d ,e)\n        \t)\n    \t   )\n    );\n}\n\n// A simple function that come close to perlin noise\nfloat noise( in vec2 ps ) {\n\tvec2 integer_part = floor(ps);\n    vec2 fract_part   = fract(ps);\n    \n    float a = random(integer_part);\n    float b = random(integer_part + vec2(1, 0));\n    float c = random(integer_part + vec2(0, 1));\n    float d = random(integer_part + vec2(1, 1));\n    \n    vec2 w = smoothstep(0.0, 1.0, fract_part);    \n    \n    return mix(mix(a, b, w.x), mix(c, d, w.x), w.y);\n}\n\n// Generates a color texture based on the noise function\n// where green is the x displacement and red is the y\nvec4 displacement(in vec2 ps ) {\n    float scale = floor(iTime * 0.5 + 6.0) / 24.0;\n    scale = fract(scale) * 24.0;\n    vec2 uv = ps * scale;\n    return vec4(noise(uv), noise(uv.yx), 0.0, 1.0);\n}\n\n\n// Draws a circle, 1.0 means inside and 0.0 outside\nfloat circle ( in vec2 ps, in vec2 centre, in float radius) {\n    return smoothstep(0., -5./iResolution.y, length(centre-ps)-radius);\n}\n\n\n// Draws a distorted circle based on the displacement map\nfloat distorted_circle ( in vec2 uv ) {\n    vec2 offset = displacement(uv).xy * 2.0 - 1.0; // Normalized to [-1.0, 1.0]\n    float timer = 0.5 - 0.5 * cos (iTime * 3.141592653 * 1.0);\n    float scale = timer;\n    offset *= 0.15 * scale;\n    float c = circle (uv + offset, vec2(0), 0.25);\n    \n    return c;\n}\n\n// A rotation matrix used to rotate the drawing 45 degrees\nmat2 rotate(float angle) {\n    return mat2(cos(angle),-sin(angle),\n                sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    fragColor = vec4(distorted_circle(rotate ( 3.141592653 * .25 ) * (uv - .5)));\n}\n","name":"Image","description":"","type":"image"}]}