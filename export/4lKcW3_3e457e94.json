{"ver":"0.1","info":{"id":"4lKcW3","date":"1538121387","viewed":303,"name":"Inverse Kinematics","username":"Ultraviolet","description":"Click to move the target.\nYou can play with the arm lengths (Common tab) and the optimization process (Buffer A).","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["optimization","inverse","kinematics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2018-09-27\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n\n#define CHANNEL iChannel0\n\n\n// The following 2 functions come from https://www.shadertoy.com/view/lt3GRj\n// Thank you TimoKinnunen !\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 X = SCREEN2WORLD(fragCoord);\n    vec2 M = TARGET;\n\n    vec3 col = vec3(1.);\n    \n    \n    DRAW_C(Grid(1.), X, vec3(.1), .5, col);\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), X, vec3(.0), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n    \n    DRAW_C(Circle(M, 0.1), X, vec3(0., 0., 1.), 1., col);\n    vec2 xm = vec2(.05, 0.), xM=vec2(.15, .0);\n    DRAW_C(Segment(M+xm, M+xM), X, vec3(0., 0., 1.), 1., col);\n    DRAW_C(Segment(M-xm, M-xM), X, vec3(0., 0., 1.), 1., col);\n    DRAW_C(Segment(M+xm.yx, M+xM.yx), X, vec3(0., 0., 1.), 1., col);\n    DRAW_C(Segment(M-xm.yx, M-xM.yx), X, vec3(0., 0., 1.), 1., col);\n    \n    \n    /*\n    DRAW_C(Circle(vec2(0.), l0         ), X, vec3(1., 0., 0.), 1., col);\n    DRAW_C(Circle(vec2(0.), l0+l1      ), X, vec3(1., 1., 0.), 1., col);\n    DRAW_C(Circle(vec2(0.), l0+l1+l2   ), X, vec3(0., 1., 0.), 1., col);\n    DRAW_C(Circle(vec2(0.), l0+l1+l2+l3), X, vec3(0., 1., 1.), 1., col);\n    //*/\n    \n    /*\n    DRAW_C(Circle(vec2(0.), l0+l1      ), X, vec3(1., 1., 0.)*.8, .15, col);\n    DRAW_C(Circle(vec2(0.), l0+l1+l2   ), X, vec3(0., 1., 0.)*.8, .15, col);\n    DRAW_C(Circle(vec2(0.), l0+l1+l2+l3), X, vec3(0., 1., 1.)*.8, .15, col);\n\t//*/\n    \n    vec4 v = texelFetch(CHANNEL, ivec2(0, 0), 0);\n    \n    \n    vec2 x0 = computeTarget0(v);\n    vec2 x1 = computeTarget1(v);\n    vec2 x2 = computeTarget2(v);\n    vec2 x3 = computeTarget3(v);\n    vec2 x4 = computeTarget(v);\n    \n    DRAW_C(Circle(vec2(0.), l0+l1+l2+l3), X, vec3(.6), .2, col);\n    \n    DRAW_C(Circle(x0, l0), X, vec3(1., 0., 0.)*.8, .2, col);\n    DRAW_C(Circle(x1, l1), X, vec3(1., 1., 0.)*.8, .2, col);\n    DRAW_C(Circle(x2, l2), X, vec3(0., 1., 0.)*.8, .2, col);\n    DRAW_C(Circle(x3, l3), X, vec3(0., 1., 1.)*.8, .2, col);\n        \n    vec2 d0 = normalize(x1-x0);\n    vec2 d1 = normalize(x2-x1);\n    vec2 d2 = normalize(x3-x2);\n    vec2 d3 = normalize(x4-x3);\n    \n    float width = 0.25;\n    vec2 n0 = width*d0.yx*vec2(-1., 1.)*l0;\n    vec2 n1 = width*d1.yx*vec2(-1., 1.)*l1;\n    vec2 n2 = width*d2.yx*vec2(-1., 1.)*l2;\n    vec2 n3 = width*d3.yx*vec2(-1., 1.)*l3;\n    \n    \n    DRAW_A(Triangle(x0-n0, x0+n0, x1), X, vec4(1., 0., 0., .2), col);\n    DRAW_C(Triangle(x0-n0, x0+n0, x1), X, vec3(1., 0., 0.), 2.0, col);\n    \n    DRAW_A(Triangle(x1-n1, x1+n1, x2), X, vec4(1., 1., 0., .2), col);\n    DRAW_C(Triangle(x1-n1, x1+n1, x2), X, vec3(1., 1., 0.), 2.0, col);\n    \n    DRAW_A(Triangle(x2-n2, x2+n2, x3), X, vec4(0., 1., 0., .2), col);\n    DRAW_C(Triangle(x2-n2, x2+n2, x3), X, vec3(0., 1., 0.), 2.0, col);\n    \n    DRAW_A(Triangle(x3-n3, x3+n3, x4), X, vec4(0., 1., 1., .2), col);\n    DRAW_C(Triangle(x3-n3, x3+n3, x4), X, vec3(0., 1., 1.), 2.0, col);\n    \n    \n    \n\tvec2 fontSize = vec2(4,5) * vec2(5,3);\n    vec2 vPixelCoord = vec2(-5.0, 5.0);\n\tfloat fDigits = 2.0;\n\tfloat fDecimalPlaces = 5.0;\n\tfloat fIsDigit = PrintValue(fragCoord, vPixelCoord, fontSize, length(M-x4), fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n\n#define PI\t3.1415926535\n\n/// Differentiation utils\nconst float epsilon = 1e-3;\nconst vec4 dx0 = vec4(epsilon, 0., 0., 0.);\nconst vec4 dx1 = dx0.yxyy;\nconst vec4 dx2 = dx0.yyxy;\nconst vec4 dx3 = dx0.yyyx;\n#define DIFF(FUNC, X) (vec4(FUNC(X+dx0)-FUNC(X-dx0), FUNC(X+dx1)-FUNC(X-dx1),FUNC(X+dx2)-FUNC(X-dx2),FUNC(X+dx3)-FUNC(X-dx3))/epsilon*.5)\n#define DIFF2(FUNC, X) (mat4(DIFF(FUNC,X+dx0)-DIFF(FUNC,X-dx0), DIFF(FUNC,X+dx1)-DIFF(FUNC,X-dx1),DIFF(FUNC,X+dx2)-DIFF(FUNC,X-dx2),DIFF(FUNC,X+dx3)-DIFF(FUNC,X-dx3))/epsilon*.5)\n\n\n#define SCREEN2WORLD(X)  ((X -iResolution.xy*.5)/iResolution.y*3.)\n//#define TARGET (length(iMouse.xy)<10. ? vec2(cos(iTime)*(.7+.3*cos(iTime*.5)), sin(iTime)*.7) : SCREEN2WORLD(iMouse.xy))\n#define TARGET (length(iMouse.xy)<10. ? square(iTime) : SCREEN2WORLD(iMouse.xy))\n\n\n/// Arm lengths\nconst float l0 = .5;\nconst float l1 = .4;\nconst float l2 = .3;\nconst float l3 = .25;\n\n\n\n/// Geometry utils\n\nvec2 square(float t)\n{\n    return vec2(sin(PI*.5*t), 1.);\n    \n    vec2 xy = vec2(mod(t, 4.), mod(t+1., 4.));\n    return sin(PI*.5*clamp(2.*(abs(xy-2.)-1.), -1., 1.));\n}\n\nmat2 rot(float alpha)\n{\n    return mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha));\n}\n\nvec2 computeTarget(vec4 alpha)\n{\n    return rot(alpha.x)*(vec2(l0, 0.) \n         + rot(alpha.y)*(vec2(l1, 0.) \n         + rot(alpha.z)*(vec2(l2, 0.) \n         + rot(alpha.w)*(vec2(l3, 0.)))));\n}\n\nvec2 computeTarget3(vec4 alpha)\n{\n    return rot(alpha.x)*(vec2(l0, 0.) \n         + rot(alpha.y)*(vec2(l1, 0.) \n         + rot(alpha.z)*(vec2(l2, 0.))));\n}\n\nvec2 computeTarget2(vec4 alpha)\n{\n    return rot(alpha.x)*(vec2(l0, 0.) + rot(alpha.y)*(vec2(l1, 0.)));\n}\n\n\nvec2 computeTarget1(vec4 alpha)\n{\n    return rot(alpha.x)* vec2(l0, 0.);\n}\n\nvec2 computeTarget0(vec4 alpha)\n{\n    return vec2(0.);\n}\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////\n//      ___  ____  __   _  _  ____  ____  ____  _  _      __    __  ____ \n//     / __)(  __)/  \\ ( \\/ )(  __)(_  _)(  _ \\( \\/ )    (  )  (  )(  _ \\\n//    ( (_ \\ ) _)(  O )/ \\/ \\ ) _)   )(   )   / )  /     / (_/\\ )(  ) _ (\n//     \\___/(____)\\__/ \\_)(_/(____) (__) (__\\_)(__/      \\____/(__)(____/\n//\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\n\n\n//---------------------------------------\n// Triangle\n\nstruct Triangle\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\nfloat dist(Triangle t, in vec2 p )\n{\n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n// O = object, P = point, C = drawing color, CC = original color\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the inside of the shape, with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))*C.a)\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*(1.-C.a))\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This tab implements the Newton method for optimizing the arm angles.\n\n\nfloat functionToOptimize(vec4 alpha)\n{\n    vec2 M = TARGET;\n    vec2 T = computeTarget(alpha);\n    float dist_cost = dot(M-T, M-T);\n    \n    float m_alpha = (alpha.y+alpha.z+alpha.w)/3.;\n    float angle_cost = (alpha.y-m_alpha)*(alpha.y-m_alpha) + (alpha.z-m_alpha)*(alpha.z-m_alpha) + (alpha.w-m_alpha)*(alpha.w-m_alpha);\n    \n    return dist_cost + angle_cost*.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // represents the current state in the 1st pixel of the buffer, the rest is discarded\n    \n    ivec2 coord = ivec2(floor(fragCoord));\n    if(coord.x > 0 || coord.y > 0)\n        discard;\n    \n    vec4 x0 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    if(iFrame  == 0)\n        x0 = vec4(0., 1., 0., 1.);\n    \n\n    \n    vec4 grad = DIFF(functionToOptimize, x0);\n    //grad = vec2(1.);\n    mat4 hess = DIFF2(functionToOptimize, x0);\n    //mat2 hess = rosenbrock_hes(x0);\n    vec4 dir = -inverse(hess)*grad;\n    \n    if(length(dir) > 1e-7)\n    \tdir = normalize(dir);\n    \n    if(dot(dir, grad)>0.)\n        dir *= -1.;\n    \n    \n    \n\n    float dt = 0.1;\n    float t = 0.;\n    \n    /*\n    float val = functionToOptimize(x0);\n    if(val > 1e-3 && length(grad) < 1e-2)\n    {\n        dir *= vec4(1., -1., 1., -1.);\n        t = 0.001;\n    }\n\t//*/\n\n    vec4 curPos = x0;\n    float curVal = functionToOptimize(curPos);\n\n\n    //*\n    for(int i=0; i<100; ++i)\n    {\n        vec4 nextPos = x0 + dir*(t+dt);\n        float nextVal = functionToOptimize(nextPos);\n        if(nextVal>=curVal)\n        {\n            dt /= 2.;\n            //break;\n        }\n        else\n        {\n            curPos = nextPos;\n            curVal = nextVal;\n            t += dt;\n            dt *= 1.05;\n        }\n    }\n\t/*/\n    \n    t = 0.1;\n    \n    //*/\n\n    \n    t = max(t, 0.0001);\n    x0 += dir*t;\n    \n    \n    \n    fragColor = x0;\n}","name":"Buffer A","description":"","type":"buffer"}]}