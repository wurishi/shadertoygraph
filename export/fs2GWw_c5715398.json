{"ver":"0.1","info":{"id":"fs2GWw","date":"1617554905","viewed":95,"name":"Surface Plotter V2","username":"arifr123","description":"FULL INTERACTIVE VERSION : [url=https://arifr1234.github.io/webglParametricSurfacePlotter/]link[/url]","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["surface","plotter","parametric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMIT License\n\nsee https://arifr1234.github.io/webglParametricSurfacePlotter/LICENSE.txt\n\nThis code is from this GitHub repo: https://github.com/arifr1234/webglParametricSurfacePlotter\n*/\n\n/*\nSurfaces:\n\n# Breather surface for a = 2/5\n# Breather surface for a = 3/5\n# Boy's surface\n*/\n\nmat3x3 axes;\nmat2x4 projMat;\n\n// precision highp float;\n\n\n// out vec4 fragColor;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    axes = AXIS_MATRIX;\n    projMat = PROJ_MAT;\n\n    ivec2 coord = ivec2(fragCoord);\n\n    vec4 val = texelFetch(bufferA, coord, 0);\n\n    // if(!ISNONE(val.z))\n    // {\n    //     fragColor = vec4(1, 0, 0, 1);\n    //     return;\n    // }\n\n    if(ISNONE(val.x))//(MODE(val) == NONE)\n    {\n        fragColor = vec4(1, 0, 1, 1);\n        return;\n    }\n\n    mat3x3 surfJacob = transpose(surface(VAL2(VAL(val.x, 1, 0), VAL(val.y, 0, 1)), iTime));\n\n    vec3 surfVal = surfJacob[0];  // surface(val.xy);\n\n    // if(maxVal(abs(gl_FragCoord.xy - proj(surfVal))) > 1.)\n    // {\n    //     fragColor = vec4(1, 1, 0, 1);\n    //     return;\n    // }\n\n\n    vec3 normal = normalize(cross(surfJacob[1], surfJacob[2]));\n\n    fragColor = vec4(shading(normal, val.xy, surfVal), 1);\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat3x3 axes;\nmat2x4 projMat;\n\n\n// precision highp float;\n\n// uniform int START_N;\n// uniform int MAX_N;\n// uniform int BLUE_JUMP;\n\n#define BLUE_JUMP 27\n\n// out vec4 fragColor;\n\n\n// mat2x2 projJacob(mat3x3 surfJacob)//(vec2 ts, vec3 pos)\n// {\n//     //     mat4x2 * mat2x4 = mat2x2\n//     // mat3x2 sj = surfaceJacob(ts);\n//     // return mat4x2(sj[0], sj[1], sj[2], vec2(1, 1)) * projMat;\n    \n//     //     mat3x2 * mat2x3 = mat2x2\n//     // return transpose(surfaceJacob(ts, pos)) * mat2x3(projMat);\n\n// }\n\n#define PROJJACOB(sj) (transpose(mat2x3(sj[1], sj[2])) * mat2x3(projMat))\n\nivec2 relSquare(int i)\n{\n    return clamp(abs((ivec2(0, 2) + i) % 8 - 3) - 2, -1, 1);\n}\n\nivec2 absSquare(int i, int n)\n{\n    if(n <= 0)\n    {\n        n++;  // weird\n        return ivec2(0);\n    }\n    return clamp(abs((ivec2(0, 2*n) + i) % (8*n) - 3*n) - 2*n, -n, n);\n}\n\nivec2 circle4(int i)\n{\n    i = (i%4 + 4) % 4;\n    return ivec2(abs(2-i)-1, 1-abs(i-1));\n}\n\nvec2 multI(vec2 z)\n{\n    return vec2(-z.y, z.x);\n}\n\nint lerp(int x, int y, int a) { return (1-a)*x + a*y; }\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nint jumpFunc(int n) { return n*n*n; }\n// n\n// n*n, sqi(n)\n// n*n*n\n// (1 << n)\n// sign(n) * (1 << (n - 1))\n// sign(n) * int(pow(3., float(n-1)))\n// sign(n) * (1 << (2*(n - 1)))\n// n*(1 << (n-1))\n\n\n// const int START_N = startN;\n// const int MAX_N = maxN;\n// #define BLUE_JUMP jumpFunc(MAX_N)  // MAX_N\n\nvoid handleNeighbour(ivec2 otherCoord, vec2 fcoord, bool onBlue, inout bool[2] lastSettled, inout float[2] minForward, inout vec4 fragColor)\n{\n    vec4 otherVal = texelFetch(bufferA, otherCoord, 0);\n\n    bool otherOnBlue = otherCoord % BLUE_JUMP == ivec2(0);\n\n    // bool zeroDet = false;\n\n    // Look at the blue value of 'other' only if(otherOnBlue).\n    for(int otherYellowBlue = 0; otherYellowBlue < 2 && (otherOnBlue || otherYellowBlue < 1); otherYellowBlue++)\n    {\n        vec2 ts = (otherYellowBlue == 0) ? otherVal.xy : otherVal.zw;\n\n        if(!ISNONE(ts.x))\n        {\n            vec3 surf = vec3(0);\n            vec2 surfProj = vec2(0);\n\n            mat3x3 sj = mat3x3(0);\n\n            // Newton's method iterations.\n            // Do more iterations when 'other' is blue.\n            // bool zeroDet = false;\n            for(int i = 0; i < (otherYellowBlue == 1 ? 5 : 2) && maxVal(abs(fcoord - surfProj)) > 0.5; i++) \n            {\n                sj = transpose(surface(VAL2(VAL(ts.x, 1, 0), VAL(ts.y, 0, 1)), iTime));\n\n                surf = sj[0];\n                surfProj = proj(surf);\n\n                mat2x2 pj = PROJJACOB(sj);\n                // if(abs(determinant(pj)) < 10. * 1000.)\n                // {\n                //     zeroDet = true;\n                //     // break;\n                // }\n\n                ts += (fcoord - surfProj) * inverse(pj);\n            }\n\n            if(any(isnan(ts)) || !inRange(ts, iTime)) continue;\n\n            surf = transpose(surface(VAL2(VAL(ts.x, 0, 0), VAL(ts.y, 0, 0)), iTime))[0];\n            surfProj = proj(surf);\n\n\n            bool newSettled = maxVal(abs(fcoord - surfProj)) <= 0.5;\n\n            if(newSettled)\n            {\n                float forwardDir = dot(axes[2], surf);\n\n                // Update the blue value only if(onBlue).\n                for(int yellowBlue = 0; yellowBlue < 2 && (onBlue || yellowBlue < 1); yellowBlue++)\n                {\n                    //                             if yellow: forwardDir < minForward[yellowBlue] == true\n                    //                             if blue:   forwardDir < minForward[yellowBlue] == false\n                    if(!lastSettled[yellowBlue] || (yellowBlue == 0) == (forwardDir < minForward[yellowBlue]))\n                    {\n                        if(yellowBlue == 0) fragColor.xy = ts;\n                        else fragColor.zw = ts;\n\n                        lastSettled[yellowBlue] = true;\n                        minForward[yellowBlue] = forwardDir;\n                    }\n                }\n            }\n        }\n    }\n\n    // return zeroDet;\n}\n\n//void main( void )\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    axes = AXIS_MATRIX;\n    projMat = PROJ_MAT;\n\n    ivec2 coord = ivec2(fragCoord);\n    vec2 fcoord = floor(fragCoord.xy);\n\n\n    if(fract(time / 7.) <= 0.01)\n    {\n        const vec2 initTS = vec2(0.5, 0.5);\n\n        //if(sqi(coord - ivec2(proj(transpose(surface(VAL2(VAL(initTS.x, 0, 0), VAL(initTS.y, 0, 0))))[0]))) < sqi(4))\n            fragColor = vec4(initTS, none, none);\n        //else\n        //    fragColor = vec4(none);\n\n        return;\n    }\n\n    bool onBlue = coord % BLUE_JUMP == ivec2(0);\n\n    bool[] lastSettled = bool[2](false, false);\n    float[] minForward = float[2](-1., -1.);\n\n\n    fragColor = vec4(none);\n\n    // Run once for otherCoord = coord\n    handleNeighbour(coord, fcoord, onBlue, lastSettled, minForward, fragColor);\n\n    // if(zeroDet) \n    // {\n    //     fragColor = vec4(none);\n    //     return;\n    // }\n\n    // int N = 1 + (int(343. * hash12(vec2(2 * frame + START_N, coord.x + resolution.x * coord.y) / 421.)) % 3);\n    for(int n = 1; n <= 3; n++)\n    {\n        int jf = jumpFunc(n);\n\n        // if(false && jf == 1)\n        // if(onBlue)\n        // if(true)\n        #ifdef DISABLE_STOCHASTIC\n        {\n            for(int i = 1; i < 8; i += 2 /* variable (1, 2) */)\n            {\n                ivec2 otherCoord = coord + jf * relSquare(i);\n\n\n                if(any(lessThan(otherCoord, ivec2(0))) || any(greaterThanEqual(otherCoord, resolution))) continue;\n\n\n                handleNeighbour(otherCoord, fcoord, onBlue, lastSettled, minForward, fragColor);\n            }\n        }\n        // else\n        #else\n        {\n            int i = 1 + 2 * (int(100. * hash12(vec2(2 * frame + 1, coord.x + resolution.x * coord.y) / 100.)) % 4);\n            // int i = 1 + 2 * (((3 * frame + START_N) + coord.x + resolution.x * coord.y) % 4);\n            {\n                ivec2 otherCoord = coord + jf * relSquare(i);\n\n\n                if(any(lessThan(otherCoord, ivec2(0))) || any(greaterThanEqual(otherCoord, resolution))) continue;\n\n\n                handleNeighbour(otherCoord, fcoord, onBlue, lastSettled, minForward, fragColor);\n            }\n        }\n        #endif\n    }\n}\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// precision highp float;\n\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define cis(t) vec2(cos(t), sin(t))\n\n// uniform float time;\n#define time iTime\n// uniform int frame;\n#define frame iFrame\n// uniform highp ivec2 resolution;\n#define resolution ivec2(iResolution.xy)\n\n// uniform sampler2D bufferA;\n#define bufferA iChannel0\n\n// uniform float none;\n#define none 100000.\n\n\n// uniform mat3x3 axes;\n// uniform mat2x4 projMat;\n\n/// Axes and Projection ///\n/*\n\n Z\n^\n|   ^ Y\n|  /\n| /\n|/_____> X\n\nX - Right\nY - Forward\nZ - UP\n\nRotation Format:\n    vec2({XY rotation}, {ZY rotation})\n*/\n\nvec2 timeRotation(float t)\n{\n    t *= 0.25 + 0.2 * mod(floor(t /7.), 3.);\n    return vec2(t, (PI/4.) * sin(t));\n}\n\nmat3x3 getAxisMatrix(vec2 rotation)\n{\n    vec2 xy = cis(rotation.x);\n    vec2 zy = cis(rotation.y);\n    \n    vec3 right = vec3(-xy[1], xy[0], 0);\n    vec3 up = vec3(-zy[1] * xy, zy[0]);\n    vec3 forward = cross(up, right);\n    \n    return mat3x3(right,\n                  up,\n                  forward);\n}\n#define AXIS_MATRIX getAxisMatrix(timeRotation(iTime))\n\n#define PROJ_MAT getProjMat(axes, iResolution, iTime)\nmat2x4 getProjMat(mat3x3 axes, vec3 iResolution, float iTime)\n{\n    float RADIUS = 2. + 1.5 * (2. - mod(floor(iTime/7.), 3.));\n    \n    float scale = (0.5 * min(iResolution.x, iResolution.y) / RADIUS);\n    return mat2x4(vec4(scale * axes[0], iResolution.x / 2.),\n                  vec4(scale * axes[1], iResolution.y / 2.));\n}\n\n///////////////\n\n\n\n\nint sqi(ivec2 v) { return v.x*v.x + v.y*v.y; }\nint sqi(int v) { return v*v; }\n#define sq(v) dot(v, v)\n\nfloat maxVal(vec2 v) { return max(v.x, v.y); }\n\n\n////////////////////\n///   AutoDiff   ///\n////////////////////\n\n/// Types ///\n\n#define VAL vec3\n#define VAL2 mat2x3\n#define VAL3 mat3x3\n\n\n/// Simple Functions/Operators ///\n\n#define c(a) VAL(a, 0, 0)\n\nVAL add(VAL a, VAL b) { return a + b; }\nVAL sub(VAL a, VAL b) { return a - b; }\n\n#if 0\nVAL mul(VAL a, VAL b) { return VAL(a.x*b.x, a.y*b.x + b.y*a.x, a.z*b.x + b.z*a.x); }\n#else\nVAL mul(VAL a, VAL b) { return VAL(a.x*b.x, dot(a.yx, b.xy), dot(a.zx, b.xz)); }\n#endif\n\nVAL recip(VAL b) { return VAL(1. / b.x, -b.yz / sq(b.x)); }  // reciprocal\n\n#if 0\nVAL div(VAL a, VAL b) { return mul(a, recip(b)); }\n#else\nconst vec2 negateY = vec2(1, -1);\nVAL div(VAL a, VAL b) { return VAL(a.x/b.x, vec2(dot(a.yx, b.xy*negateY), dot(a.zx, b.xz*negateY)) / sq(b.x)); }\n#endif\n\n\n/// Other Functions ///\n\nVAL d_sq(VAL a) { return VAL(sq(a.x), 2.*a.x*a.yz); }\nVAL d_sin(VAL a) { return VAL(sin(a.x), cos(a.x) * a.yz); }\nVAL d_cos(VAL a) { return VAL(cos(a.x), -sin(a.x) * a.yz); }\nVAL d_exp(VAL a) { return exp(a.x) * VAL(1, a.yz); }\nVAL d_log(VAL a) { return VAL(log(a.x), a.yz / a.x); }\n\n\n// TODO: maybe I can do the same thing I did with cross(VAL3, VAL3) for 'mul' and 'div'\n\nVAL2 mul(VAL  a, VAL2 b) { return VAL2(mul(a   , b[0]), mul(a   , b[1])); }\nVAL2 mul(VAL2 a, VAL  b) { return VAL2(mul(a[0], b   ), mul(a[1], b   )); }\nVAL2 mul(VAL2 a, VAL2 b) { return VAL2(mul(a[0], b[0]), mul(a[1], b[1])); }\n\nVAL3 mul(VAL  a, VAL3 b) { return VAL3(mul(a   , b[0]), mul(a   , b[1]), mul(a   , b[2])); }\nVAL3 mul(VAL3 a, VAL  b) { return VAL3(mul(a[0], b   ), mul(a[1], b   ), mul(a[2], b   )); }\nVAL3 mul(VAL3 a, VAL3 b) { return VAL3(mul(a[0], b[0]), mul(a[1], b[1]), mul(a[2], b[2])); }\n\n\nVAL2 div(VAL  a, VAL2 b) { return VAL2(div(a   , b[0]), div(a   , b[1])); }\nVAL2 div(VAL2 a, VAL  b) { return VAL2(div(a[0], b   ), div(a[1], b   )); }\nVAL2 div(VAL2 a, VAL2 b) { return VAL2(div(a[0], b[0]), div(a[1], b[1])); }\n\nVAL3 div(VAL  a, VAL3 b) { return VAL3(div(a   , b[0]), div(a   , b[1]), div(a   , b[2])); }\nVAL3 div(VAL3 a, VAL  b) { return VAL3(div(a[0], b   ), div(a[1], b   ), div(a[2], b   )); }\nVAL3 div(VAL3 a, VAL3 b) { return VAL3(div(a[0], b[0]), div(a[1], b[1]), div(a[2], b[2])); }\n\nVAL d_lenSq(VAL3 v) { return d_sq(v[0]) + d_sq(v[1]) + d_sq(v[2]); }\n\n#if 1\nVAL d_sqrt(VAL a) { float sqrtX = sqrt(a.x); return VAL(sqrtX, 0.5 * a.yz / sqrtX); }\n#else\nVAL d_sqrt(VAL a) { return sqrt(a.x) * VAL(1., 0.5 * a.yz / a.x); }\n#endif\n\n\nVAL3 d_cross(VAL3 a, VAL3 b) \n{\n    mat3 at = transpose(a);\n    mat3 bt = transpose(b);\n    \n    return transpose(mat3(cross(at[0], bt[0]), cross(at[1], bt[0]) + cross(at[0], bt[1]), cross(at[2], bt[0]) + cross(at[0], bt[2])));\n}\n\n\n\n/// Complex Functions ///\n\nVAL2 dc_mul(VAL2 a, VAL2 b) { return VAL2(mul(a[0], b[0]) - mul(a[1], b[1]), mul(a[1], b[0]) + mul(a[0], b[1])); }\nVAL2 dc_sq(VAL2 z) { return VAL2(d_sq(z[0]) - d_sq(z[1]), 2. * mul(z[0], z[1])); }\n\n#if 0\nVAL2 dc_conj(VAL2 z) { return VAL2(z[0], -z[1]); } // conjugate\n#else\nconst VAL2 c_negateY = mat2x3(vec3(1), vec3(-1));\nVAL2 dc_conj(VAL2 z) { return matrixCompMult(z, c_negateY); } // conjugate\n#endif\n\nVAL dc_absSq(VAL2 z) { return d_sq(z[0]) + d_sq(z[1]); }\n\nVAL2 dcr_div(VAL2 z, VAL b) { return VAL2(div(z[0], b), div(z[1], b)); }\nVAL2 dc_recip(VAL2 z) { return dcr_div(dc_conj(z), dc_absSq(z)); }\n\n\n///////////////////////////////////\n///   the Parametric Equation   ///\n///////////////////////////////////\n\n// USER CODE START\n\nVAL d_cosh(VAL a) { return VAL(cosh(a.x), a.yz * sinh(a.x)); }\nVAL d_sinh(VAL a) { return VAL(sinh(a.x), a.yz * cosh(a.x)); }\n\nVAL3 surface(VAL2 s, float iTime)\n{\n    float t = time / 7.;\n    \n    if(int(t) % 3 == 2)\n    {\n\n        const float sqrt5 = sqrt(5.);\n\n        VAL2 s2 = dc_sq(s);\n        VAL2 s3 = dc_mul(s2, s);\n        VAL2 s4 = dc_sq(s2);\n        VAL2 s6 = dc_sq(s3);\n\n        const VAL2 one = VAL2(c(1), c(0));\n\n        VAL2 denominator = dc_recip(s6 + sqrt5*s3 - one);\n\n        VAL3 g = VAL3(\n            -1.5 * dc_mul(dc_mul(s, one - s4), denominator)[1],\n            -1.5 * dc_mul(dc_mul(s, one + s4), denominator)[0],\n            dc_mul(one + s6, denominator)[1] - c(0.5)\n        );\n\n        VAL normalFactor = recip(d_sq(g[0]) + d_sq(g[1]) + d_sq(g[2]));\n\n        return VAL3(mul(g[0], normalFactor), mul(g[1], normalFactor), mul(g[2], normalFactor) + c(0.75));\n    }\n    else\n    {\n        float aa = (mod(floor(t), 3.) + 2.) / 5.;\n\n        float wsqr = 1. - sq(aa);\n        float w = sqrt(wsqr);\n\n        VAL v = s[0];\n        VAL u = s[1];\n\n        VAL denom = aa * (d_sq(w * d_cosh(aa * u)) + d_sq(aa * d_sin(w * v)));\n\n        return VAL3(-u, c(0), c(0)) + \n            div(VAL3(\n            2. * wsqr * mul(d_cosh(aa * u), d_sinh(aa * u)),\n            2. * w * mul(d_cosh(aa * u), -(w * mul(d_cos(v), d_cos(w * v))) - mul(d_sin(v), d_sin(w * v))),\n            2. * w * mul(d_cosh(aa * u), -(w * mul(d_sin(v), d_cos(w * v))) + mul(d_cos(v), d_sin(w * v)))), denom);\n    }\n}\n\nbool inRange(vec2 ts, float iTime)\n{\n    float t = time / 7.;\n    \n    if(int(t) % 3 == 2)\n    {\n        return sq(ts.x) + sq(ts.y) <= 1.;\n    }\n    else\n    {\n        return 0. <= ts.x && ts.x < 150. && -14. <= ts.y && ts.y < 14.;\n    }\n}\n\n#define DEFAULT_SHADING\n\n// USER CODE END\n\n#ifdef DEFAULT_SHADING\nvec3 shading(vec3 normal, vec2 ts, vec3 pos)\n{ \n    return vec3(dot(normal, vec3(1, 0, 0)) / 2. + 0.5);\n}\n#endif\n\n\n\n\n\n\n\n\n// // Complex functions\n// vec2 cMul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\n// vec2 cSq(vec2 z) { return vec2(sq(z.x) - sq(z.y), 2.*z.x*z.y); }\n// vec2 cCon(vec2 z) { return vec2(z.x, -z.y); }\n// float cSqAbs(vec2 z) { return sq(z.x) + sq(z.y); }\n// vec2 cRecip(vec2 b) { return cCon(b) / cSqAbs(b); }  // 1/b = cCon(b) / ( b*cCon(b) ) = cCon(b) / cSqAbs(b)\n\n\n// vec3 surface(vec2 s)\n// {\n//     const float sqrt5 = sqrt(5.);\n    \n//     vec2 s2 = cSq(s);\n//     vec2 s3 = cMul(s2, s);\n//     vec2 s4 = cSq(s2);\n//     vec2 s6 = cSq(s3);\n    \n//     const vec2 one = vec2(1, 0);\n    \n//     vec2 denominator = cRecip(s6 + sqrt5*s3 - one);\n    \n//     vec3 g = vec3(\n//         -1.5 * cMul(cMul(s, one - s4), denominator).y, \n//         -1.5 * cMul(cMul(s, one + s4), denominator).x, \n//         cMul(one + s6, denominator).y - 0.5\n//     );\n        \n//     return g / (sq(g.x) + sq(g.y) + sq(g.z));\n// }\n\n// x + y * i\n// mat2x3(x, dx/dt, dx/ds, y, dy/dt, dy/ds)\n// mat3x2(x, y, dx/dt, dy/dt, dx/ds, dy/ds)\n// mat3x2(ts.x, ts.y, 1, 0, 0, 1)\n\n\n// mat3x2 d_cMul(mat3x2 a, mat3x2 b) { return mat3x2(cMul(a[0], b[0]), cMul(a[1], b[0]) + cMul(a[0], b[1]), cMul(a[2], b[0]) + cMul(a[0], b[2])); }\n// mat3x2 d_cSq(mat3x2 z) { return mat3x2(cSq(z[0]), 2.*cMul(z[0], z[1]), 2.*cMul(z[0], z[2])); }\n// mat3x2 d_cCon(mat3x2 z) { return matrixCompMult(z, mat3x2(1, -1, 1, -1, 1, -1)); }\n// vec3 d_cSqAbs(mat3x2 z) { return vec3(sq(z[0].x) + sq(z[0].y), 2. * z[0] * mat2(z[1], z[2])); }\n\n// vec3 d_recip(vec3 b) { return vec3(1. / b.x, -b.yz / sq(b.x)); }\n\n// vec3 d_mul(vec3 a, vec3 b) { return vec3(a.x*b.x, a.yz*b.x + b.yz*a.x); }\n// mat3x2 d_rMul(mat3x2 a, vec3 b) { mat2x3 a_t = transpose(a); return transpose(mat2x3(d_mul(a_t[0], b), d_mul(a_t[1], b))); }\n\n// mat3x2 d_cRecip(mat3x2 b) { return d_rMul(d_cCon(b), d_recip(d_cSqAbs(b))); }  // 1/b = cCon(b) / ( b*cCon(b) ) = cCon(b) / cSqAbs(b)\n\n// vec3 d_sq(vec3 a) { return vec3(sq(a.x), 2.*a.x*a.yz); }\n\n\n\n// mat3x3 surface(mat3x2 s)\n// {\n//     const float sqrt5 = sqrt(5.);\n    \n//     mat3x2 s2 = d_cSq(s);\n//     mat3x2 s3 = d_cMul(s2, s);\n//     mat3x2 s4 = d_cSq(s2);\n//     mat3x2 s6 = d_cSq(s3);\n    \n//     const mat3x2 one = mat3x2(1, 0, 0, 0, 0, 0);\n    \n//     mat3x2 denominator = d_cRecip(s6 + sqrt5*s3 - one);\n    \n//     mat3x3 g = VAL3(\n//         -1.5 * transpose(d_cMul(d_cMul(s, one - s4), denominator))[1],\n//         -1.5 * transpose(d_cMul(d_cMul(s, one + s4), denominator))[0],\n//         transpose(d_cMul(one + s6, denominator))[1] - vec3(0.5, 0, 0)\n//     );\n\n//     vec3 normalFactor = d_recip(d_sq(g[0]) + d_sq(g[1]) + d_sq(g[2]));\n\n//     return mat3x3(d_mul(g[0], normalFactor), d_mul(g[1], normalFactor), d_mul(g[2], normalFactor));\n// }\n\n\n\n// const float dt = 0.01;\n\n\n// mat2x3 surfaceJacob(vec2 ts, vec3 pos)\n// {\n//     // return mat2x3((surface(ts + vec2(dt, 0)) - pos) / dt,    // d(surface(t, s))/dt\n//                 //   (surface(ts + vec2(0, dt)) - pos) / dt);   // d(surface(t, s))/ds\n\n//     // return mat2x3(transpose(surface(vec4(ts.x, 1, ts.y, 0)))[1],\n//     //               transpose(surface(vec4(ts.x, 0, ts.y, 1)))[1]);\n\n//     mat3x3 autodiffRes_t = transpose(surface(VAL2(VAL(ts.x, 1, 0), VAL(ts.y, 0, 1))));\n\n//     return mat2x3(autodiffRes_t[1], autodiffRes_t[2]);\n\n// }\n\n\n#if 0\nvec2 proj(vec3 v)  // TODO: define?\n{\n    return vec2(vec4(v, 1) * projMat);\n    // return v * mat2x3(projMat) + projMat[3]\n}\n#else\n#define proj(v) vec2(vec4(v, 1) * projMat)\n#endif\n\n#define ISNONE(x) (abs(x - none) < 0.01)\n","name":"Common","description":"","type":"common"}]}