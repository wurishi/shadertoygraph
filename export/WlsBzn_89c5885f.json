{"ver":"0.1","info":{"id":"WlsBzn","date":"1595857326","viewed":340,"name":"Hades","username":"kesson","description":"hades\n\n-\n\nFully-procedural surface computing. without textures.\nPorted from \"Seascape\" by Alexander Alekseev aka TDM\nOriginal: https://www.shadertoy.com/view/Ms2SD1","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","rays","marching","generative","depth","gyroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"hades\" by Giovanni Muzio - kesson | 2020\n * https://kesson.io | info@kesson.io\n *\n * Porting of \"Seascape\" by Alexander Alekseev aka TDM\n * Original: https://www.shadertoy.com/view/Ms2SD1\n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPSILON_NRM (0.1 / iResolution.x)\n#define FBM_OCTAVES 4\n#define NUM_BOXES 8.0\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\n\n// land\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float LAND_HEIGHT = 1.0;\nconst float LAND_CHOPPY = 32.0;\nconst float LAND_SPEED = 0.1;\nconst float LAND_FREQ = 0.1;\nconst vec3 LAND_BASE = vec3(0.0,0.,0.);\nconst vec3 LAND_COLOR = vec3(0.5,0.,0.);\nconst mat2 octave_m = mat2(1.5,1.2,-0.6,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(in vec2 _st) {\n  return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n  // Four corners in 2D of a tile\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n  // Simple 2D lerp using smoothstep envelope between the values.\n  // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n  //\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n  //\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n  // Same code, with the clamps in smoothstep and common subexpressions\n  // optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 x) {\n  float a = 0.3;\n  float t = 0.0;\n  for (int i = 0; i < FBM_OCTAVES; i++) {\n    t += a * noise(vec2(x));\n    x = x * 2.0;\n    a *= 0.4;\n  }\n  return t;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.);\n    //float nrm = (s + 32.0) / (PI * 32.);\n    return pow(max(dot(reflect(e,n),l), 0.0), s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    float amount = 2.;\n    vec2 st =\n        vec2(e.x * amount * 4.0,\n             e.y * amount * 2.0);\n    vec3 skyColor = vec3(0.0);\n    vec3 fCol = vec3(0.0);\n    vec2 q = vec2(fbm(st), fbm(st + vec2(1.0)));\n    vec2 r = vec2(fbm(st + q + vec2(1.7, 9.2) + 0.75 * iTime),\n                  fbm(st + q + vec2(8.3, 2.8) + 0.25 * iTime));\n    float f = fbm(st + r);\n    skyColor = mix(vec3(0.0), vec3(1.0, 0.0, 0.0),\n                clamp((f * f) * 4.0, 0.0, 1.0));\n    skyColor = mix(skyColor, vec3(1.0, 0.0, 0.0), clamp(length(r.x), 0.0, 1.0));\n    skyColor = pow(skyColor, vec3(2.0));\n    return skyColor;\n}\n\n// land\nfloat land_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = LAND_FREQ;\n    float amp = LAND_HEIGHT;\n    float choppy = LAND_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = land_octave((uv+(1.0 + iTime * LAND_SPEED))*freq,choppy);\n    \td += land_octave((uv-(1.0 + iTime * LAND_SPEED))*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    \n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = LAND_FREQ;\n    float amp = LAND_HEIGHT;\n    float choppy = LAND_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = land_octave((uv+(1.0 + iTime * LAND_SPEED))*freq,choppy);\n    \td += land_octave((uv-(1.0 + iTime * LAND_SPEED))*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 2.0; amp *= 0.2;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getLandColor(vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 2.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    //vec3 skyColor = pow(getSkyColor(eye), vec3(0.8));\n    vec3 reflected = pow(getSkyColor(reflect(eye,n)), vec3(0.45));    \n    vec3 refracted = LAND_BASE + diffuse(n,l,10.0) * LAND_COLOR * 0.2; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n        \n    color += vec3(specular(n,l,eye, 20.0)) * vec3(1.0, 0.25, 0.3);\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float time = iTime * 0.2;\n        \n    // ray\n    vec3 ang = vec3(sin(time)*0.1,sin(time)*0.+0.1,time*0.1);    \n    vec3 ori = vec3(0.0,4.5,time);\n    vec3 dir = normalize(vec3(uv.xy,-1.0)); dir.z += length(uv) * 0.915;\n    dir = normalize(dir) * fromEuler(ang);\n        \n    // tracing\n    vec3 p;\n    float d = heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 skyColor = getSkyColor(dir);\n    vec3 color = mix(\n        skyColor,\n        mix(getLandColor(n,light,dir,dist), skyColor, smoothstep(60.0, 100.0, d)),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n    \n    // depth\n    float a = smoothstep(5.0, 60.0, d);\n        \n    // post\n    vec4 col = vec4(pow(color,vec3(0.6)), 1.0);\n    fragColor = vec4(col.xyz, a);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//  Blur  effect\n//  Edited  from  https://www.shadertoy.com/view/XdfGDH\n\nfloat  normpdf(in float  x,  in float  sigma)  {\n    return  0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2  uv = fragCoord / iResolution.xy;\n    \n    vec3  c = texture(iChannel0, uv).rgb;\n    \n    vec2  center = vec2(0.5, 0.5);\n    center = vec2(0.5, 0.5);\n\n    float  d = smoothstep(0.3, 1.0, 0.1 + distance(center, uv));\n\n    //  grain  effect\n    float  strength = 25.0;\n    float  x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3  grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n    const int  mSize = 11;\n    const int  kSize = (mSize - 1) / 2;\n    float  kernel[mSize];\n    vec3  final_colour = vec3(0.0);\n\n    //create  the  1-D  kernel\n    float  sigma = 0.001 + texture(iChannel0, uv).w * 8.0;//7.0;\n    float  Z = 0.0;\n    for (int  j = 0; j <= kSize; ++j) {\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n    }\n\n    //get  the  normalization  factor  (as  the  gaussian  has  been  clamped)\n    for (int  j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n\n    //read  out  the  texels\n    for (int  i = -kSize; i <= kSize; ++i) {\n        for(int  j = -kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize + j] * kernel[kSize + i] * texture(iChannel0, (gl_FragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n                }\n    }\n\n    vec3  c_step_1 = final_colour / (Z * Z);\n\n    float  nd = 1.0 - d;\n    vec3 c_step_2 = clamp(c_step_1 * nd, 0.0, 1.0);\n\n    // I don't like the image too clean\n    c_step_2 += grain * 1.0;\n\n    fragColor = vec4(c_step_2, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}