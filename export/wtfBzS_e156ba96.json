{"ver":"0.1","info":{"id":"wtfBzS","date":"1597002991","viewed":143,"name":"NoiseMaker","username":"BlockMaster","description":"Simple tool for creating noise textures (in need of some optimization I guess :)).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","worley","value","spaghetti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// Simple tool for creating noise textures (in need of some optimization I guess :)).\n/// You can modify the noise in the section below.\n\n//CUSTOMIZE THE NOISE//\n//Main Options\nint noiseType = 2;\t//0 - value noise; 1 - perlin noise; 2 - spaghetti noise; 3 - worley (voronoi) noise\nint dimension = 1;\t//0 - 2D noise; 1 - 3D noise (a bit slower than 2D)\nfloat frequency = 10.;\nbool combineNoises = true;\t//specific noise values && their contribution to the main noise can be modified in the mainImage\n\n//Properties\nint octaves = 1;\nfloat lacunarity = 2.;\nfloat persistence = 0.5;\nint vectorSet = 2;\t//0 - normalized vector; 1 - horizontal-vertical vector; 2 - diagonal vector; 3 - 8-directional vector; 2D noises only\nint nNearest = 1;\t//worley noise only\n\n//Motion\nfloat time;\nfloat noiseSpeed = 0.05;\t//3D noise only\nbool motion = false;\t//worley noise only\n\n//Mapping\nfloat mapMin = - 0.4;\nfloat mapMax = 0.85;\nbool mapChange = false;\n\n//Colour\n/*vec3 colourMin = vec3(0.);\t//value\nvec3 colourMax = vec3(1.);*/\n/*vec3 colourMin = vec3(0.63, 0.22, 0.13);\t//spaghetti\nvec3 colourMax = vec3(0.91, 0.77, 0.39);*/\nvec3 colourMin = vec3(0.41, 0.84, 0.94) - 0.5;\t//blue\nvec3 colourMax = vec3(1.);\n\n\n//USEFUL FUNCTIONS//\n//Map\nfloat map(float value, float currentMin, float currentMax, float targetMin, float targetMax)\n{\n    return targetMin + (targetMax - targetMin) * ((value - currentMin) / (currentMax - currentMin));\n}\n\n//Smootherstep\nfloat smootherstep(float value)\n{\n    return 6.0 * pow(value, 5.) - 15. * pow(value, 4.) + 10. * pow(value, 3.);\n}\n\n//RNG Returning a Float (0. to 1.)\nfloat randomValue(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//RNG Returning a Vec2 (0. to 1.)\nvec2 randomVector(vec2 uv)\n{\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n//RNG Returning a Direction Limited Vec2 (- 1. to 1.)\nvec2 randomLimitedVector(vec2 uv, int type)\n{\n    vec2 randomVector = randomVector(uv);\n    \n    switch (type)\n    {\n        //Normalized Vector (Any Direction with Length 1)\n        case 0:\n        {\n            return normalize(randomVector + 0.0001) * 2. - 1.;\n        }\n        break;\n        \n        //Horizontal-Vertical Vector (Right, Down, Left, Up)\n        case 1:\n        {\n            \n            return vec2(float(randomVector.x > 0.333) - 2. * float(randomVector.x > 0.666),\n                        sign(randomVector.y * 2. - 1.) * float(randomVector.x < 0.333));\n        }\n        break;\n        \n        //Diagonal Vector (Right Down, Left Down, Left Up, Right Up)\n        case 2:\n        {\n            return vec2(float(randomVector.x > 0.5) * 2. - 1.,\n                        float(randomVector.y > 0.5) * 2. - 1.);\n        }\n        break;\n        \n        //8-Directional Vector (Rigth, Right Down, Down, Left Down, Left, Left Up, Up, Right Up)\n        case 3:\n        {\n            return vec2(float(randomVector.x > 0.333) - 2. * float(randomVector.x > 0.666),\n                        sign(randomVector.y * 2. - 1.) * float(randomVector.y < 0.666 || randomVector.x < 0.333));\n        }\n        break;\n    }\n}\n\n//Vector Lookup Table for 3D Noises\nvec3 vectorTable3D[] = vec3[] (vec3(1., 1., 0.), vec3(- 1., 1., 0.), vec3(1., - 1., 0.), vec3(- 1., - 1., 0.), \n                               vec3(1., 0., 1.), vec3(- 1., 0., 1.), vec3(1., 0., - 1.), vec3(- 1., 0., - 1.),\n                               vec3(0., 1., 1.), vec3(0., - 1., 1.), vec3(0., 1., - 1.), vec3(0., - 1., - 1.));\n\n\n//NOISES//\n//Value Noise\nfloat valueNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get the Value of the 4 Nearest Grid Points\n        float point1 = randomValue(cellPosition) * 2. - 1.0;\n        float point2 = randomValue(vec2(cellPosition.x + 1., cellPosition.y)) * 2. - 1.0;\n        float point3 = randomValue(vec2(cellPosition.x, cellPosition.y + 1.)) * 2. - 1.0;\n        float point4 = randomValue(vec2(cellPosition.x + 1., cellPosition.y + 1.)) * 2. - 1.0;\n\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(point1, point2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(point3, point4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation3 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//3D Value Noise\nfloat valueNoise3D(vec3 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec3 pixelPosition = fract(uv * frequency);\n        vec3 cellPosition = floor(uv * frequency);\n\n        //Get the Value of the 8 Nearest Grid Points\n        float point1 = randomValue(cellPosition.xy * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point2 = randomValue(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point3 = randomValue(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point4 = randomValue(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point5 = randomValue(cellPosition.xy * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        float point6 = randomValue(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        float point7 = randomValue(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        float point8 = randomValue(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        \n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec3 pixelPositionSmoothed = vec3(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y), smootherstep(pixelPosition.z));\n\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(point1, point2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(point3, point4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(point5, point6, pixelPositionSmoothed.x);\n        float interpolation4 = mix(point7, point8, pixelPositionSmoothed.x);\n        \n        float interpolation5 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        float interpolation6 = mix(interpolation3, interpolation4, pixelPositionSmoothed.y);\n        \n        float interpolation7 = mix(interpolation5, interpolation6, pixelPositionSmoothed.z);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation7 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Perlin Noise\nfloat perlinNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\t\t\n        //Get the Gradient Vector of the 4 Nearest Grid Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition, vectorSet);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y), vectorSet);\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.), vectorSet);\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.), vectorSet);\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\t\t\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\t\t\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation3 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//3D Perlin Noise\nfloat perlinNoise3D(vec3 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec3 pixelPosition = fract(uv * frequency);\n        vec3 cellPosition = floor(uv * frequency);\n\t\t\n        //Get the Gradient Vector of the 8 Nearest Grid Points\n        vec3 gradientVector1 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector2 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector3 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector4 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector5 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector6 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector7 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector8 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec3 distanceVector1 = vec3(pixelPosition.x, - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector2 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector3 = vec3(pixelPosition.x, 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector4 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector5 = vec3(pixelPosition.x, - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector6 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector7 = vec3(pixelPosition.x, 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector8 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n        float dotProduct5 = dot(gradientVector5, distanceVector5);\n        float dotProduct6 = dot(gradientVector6, distanceVector6);\n        float dotProduct7 = dot(gradientVector7, distanceVector7);\n        float dotProduct8 = dot(gradientVector8, distanceVector8);\n\t\t\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec3 pixelPositionSmoothed = vec3(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y), smootherstep(pixelPosition.z));\n\t\t\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(dotProduct5, dotProduct6, pixelPositionSmoothed.x);\n        float interpolation4 = mix(dotProduct7, dotProduct8, pixelPositionSmoothed.x);\n        \n        float interpolation5 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        float interpolation6 = mix(interpolation3, interpolation4, pixelPositionSmoothed.y);\n        \n        float interpolation7 = mix(interpolation5, interpolation6, pixelPositionSmoothed.z);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation7 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Spaghetti Noise\nfloat spaghettiNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get the Gradient Vector of the 4 Nearest Grid Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition, vectorSet);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y), vectorSet);\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.), vectorSet);\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.), vectorSet);\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += abs(interpolation3) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//3D Spaghetti Noise\nfloat spaghettiNoise3D(vec3 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec3 pixelPosition = fract(uv * frequency);\n        vec3 cellPosition = floor(uv * frequency);\n\t\t\n        //Get the Gradient Vector of the 8 Nearest Grid Points\n        vec3 gradientVector1 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector2 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector3 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector4 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector5 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector6 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector7 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector8 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec3 distanceVector1 = vec3(pixelPosition.x, - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector2 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector3 = vec3(pixelPosition.x, 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector4 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector5 = vec3(pixelPosition.x, - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector6 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector7 = vec3(pixelPosition.x, 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector8 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n        float dotProduct5 = dot(gradientVector5, distanceVector5);\n        float dotProduct6 = dot(gradientVector6, distanceVector6);\n        float dotProduct7 = dot(gradientVector7, distanceVector7);\n        float dotProduct8 = dot(gradientVector8, distanceVector8);\n\t\t\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec3 pixelPositionSmoothed = vec3(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y), smootherstep(pixelPosition.z));\n\t\t\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(dotProduct5, dotProduct6, pixelPositionSmoothed.x);\n        float interpolation4 = mix(dotProduct7, dotProduct8, pixelPositionSmoothed.x);\n        \n        float interpolation5 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        float interpolation6 = mix(interpolation3, interpolation4, pixelPositionSmoothed.y);\n        \n        float interpolation7 = mix(interpolation5, interpolation6, pixelPositionSmoothed.z);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += abs(interpolation7) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Worley Noise\nfloat worleyNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence, int nNearest)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get the n-Nearest Cell Point Position\n    \tfloat distances[9] = float[] (5., 5., 5., 5., 5., 5., 5., 5., 5.);\n        for (int i = - 1; i < 2; i ++)\n        {\n        \tfor (int j = - 1; j < 2; j ++)\n        \t{\n                //Get the Point Position Within Its Grid Cell\n        \t\tvec2 pointPosition = randomVector(vec2(cellPosition.x + float(j), cellPosition.y + float(i)));\n                pointPosition *= (sin(iTime * noiseSpeed * 5. + pointPosition.x * 20.) + 1.) * 0.5 * float(motion) + float(!motion);\t//noise motion\n                pointPosition += vec2(j, i);\n            \t\n                //Compare the Distance Between the Pixel && the Point with the Previous Distances\n                float distanceToCompare = distance(pixelPosition, pointPosition);\n                for (int k = 0; k < distances.length(); k ++)\n                {\n                    if (distanceToCompare < distances[k])\n                    {\n                    \tfloat tempDistance = distances[k];\n                        distances[k] = distanceToCompare;\n                        distanceToCompare = tempDistance;\n                    }\n                }\n        \t}\n        }\n        pixelValue += distances[nNearest - 1] * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Remap the Fragcoord\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.x /= aspectRatio;\n    \n    //Set the Time for Changing the z Noise Component\n    time = mod(iTime, 200.) + 1.;\t//the RNGs aren't functioning well on higher numbers ¯\\_(ツ)_/¯\n    \n    //Get the Noise Value && Set the Fragcolor\n    float noiseValue;\n    switch (noiseType)\n    {\n        case 0:\n        {\n            if (dimension == 0) noiseValue = valueNoise(uv, frequency, octaves, lacunarity, persistence);\n            if (dimension == 1) noiseValue = valueNoise3D(vec3(uv, noiseSpeed * time), frequency, octaves, lacunarity, persistence);\n        }\n        break;\n        \n        case 1:\n        {\n            if (dimension == 0) noiseValue = perlinNoise(uv, frequency, octaves, lacunarity, persistence);\n\t\t\tif (dimension == 1) noiseValue = perlinNoise3D(vec3(uv, noiseSpeed * time), frequency, octaves, lacunarity, persistence);\n        }\n        break;\n        \n        case 2:\n        {\n            if (dimension == 0) noiseValue = spaghettiNoise(uv, frequency, octaves, lacunarity, persistence);\n\t\t\tif (dimension == 1) noiseValue = spaghettiNoise3D(vec3(uv, noiseSpeed * time), frequency, octaves, lacunarity, persistence);\n        }\n        break;\n        \n        case 3:\n        {\n            noiseValue = worleyNoise(uv, frequency, octaves, lacunarity, persistence, nNearest);\n        }\n        break;\n    }\n\t\n    if (combineNoises)\n    {\n        noiseValue *= perlinNoise3D(vec3(uv, noiseSpeed * time), 20., 6, lacunarity, persistence) * 1.;\t//combine multiple noises\n        noiseValue += worleyNoise(uv, 5., 1, lacunarity, persistence, 1) * 1.;\n    }\n    \n    noiseValue = map(noiseValue, 0., 1., mapMin, mapMax) * float(!mapChange) +\t//normal\n        \t\t map(noiseValue, 0., 1., (sin(iTime) + 1.) * 0.5, 1. - (sin(iTime) + 1.) * 0.5) * float(mapChange);\t//changing\n    \n    fragColor = vec4(mix(colourMin, colourMax, clamp(noiseValue, - 0.5, 1.)), 2.);\n}\n","name":"Image","description":"","type":"image"}]}