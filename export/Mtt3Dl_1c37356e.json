{"ver":"0.1","info":{"id":"Mtt3Dl","date":"1544806369","viewed":434,"name":"Volume cloud","username":"olano","description":"Ray march through simplex noise\n- Common: constants, hash function, and functions to tile 3D texture into 2D target\n- BufferA: bake noise into texture (only 1st frame), flow in xyz, density in a\n- BufferB: render cloud, blend with previous frame to smooth","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","cloud","3dtexture","pcg3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // look up cloud\n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n\n    // camera pose from mouse location, or auto-rotate\n    vec2 angles = iMouse.xy / iResolution.xy;\n    if (angles == vec2(0)) {\n        float rtime = iTime * autorot;\n        vec2 angle0 = vec2(hash3(uvec3(rtime)+0u).xy) / float(0x10000);\n        vec2 angle1 = vec2(hash3(uvec3(rtime)+1u).xy) / float(0x10000);\n        angles = mix(angle0, angle1, fract(rtime));\n    }\n    angles *= vec2(6.28,3.14);\n\n    float Cx = cos(angles.x), Sx = sin(angles.x);\n    float Cy = cos(angles.y), Sy = sin(angles.y);\n    vec3 screenZ = vec3(-Sx*Sy, Cy, -Cx*Sy);\n    vec3 screenX = normalize(vec3(-screenZ.z,0,screenZ.x));\n    vec3 screenY = normalize(cross(screenX, screenZ));\n    \n\t// ray geometry\n    vec3 eye = eyedist * screenZ;\n    vec3 pixel = vec3(0); // look at 0,0,0 in world space\n    pixel += eyedist * screenX * (fragCoord.x - 0.5 * iResolution.x) / iResolution.y;\n    pixel += eyedist * screenY * (fragCoord.y - 0.5 * iResolution.y) / iResolution.y;\n    vec3 ray = normalize(pixel-eye);\n    vec3 raystep = ray * stepsize;\n\n    // blend with background\n    vec4 background = texture(iChannel2, ray);\n    fragColor = mix(background, fragColor, fragColor.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// build a 3D curl nosie into a 2D texture atlas\n\n// 3D simplex weights (& corners)\n// based on McEwan et al., Efficient computation of noise in GLSL, JCT 2011\nmat4x3 simplexCoords(vec3 p) \n{\n    // skew to tetrahedral coordinates\n    vec3 tetbase = floor(p + dot(p, vec3(1./3.)));\n    vec3 base = tetbase - dot(tetbase, vec3(1./6.));\n    vec3 tf = p - base;\n\n    // One of six tetrahedra: 100, 010, 001, 011, 101, 110\n    // since skew is along x=y=z axis, this works in Euclidean space too\n    vec3 g = step(tf.yzx, tf.xyz), h = 1. - g.zxy;\n    vec3 a1 = min(g, h) - 1./6., a2 = max(g, h) - 1./3.;\n\n    // four corners in Euclidean space\n    return mat4x3(base, base + a1, base + a2, base + 0.5);\n}\n\n// simplex smoothing function\nvec4 Smooth(mat4x3 f)\n{\n\tconst float scale = 1024. / 375.;       // scale factor to make noise -1..1\n\tvec4 d = vec4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));\n\tvec4 s = clamp(2. * d, 0., 1.);\n    \n\treturn (1. * scale + s*(-3. * scale + s*(3. * scale - s*scale)));\n}\n\n// derivative of simplex noise smoothing function\nmat3x4 dSmooth(mat4x3 f)\n{\n\tconst float scale = 1024. / 375.;       // scale factor to make noise -1..1\n\tvec4 d = vec4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));\n\tvec4 s = clamp(2. * d, 0., 1.);\n    \n\ts = -12. * scale + s*(24. * scale - s * 12. * scale);\n\n\treturn mat3x4(\n\t\ts * vec4(f[0][0], f[1][0], f[2][0], f[3][0]),\n\t\ts * vec4(f[0][1], f[1][1], f[2][1], f[3][1]),\n\t\ts * vec4(f[0][2], f[1][2], f[2][2], f[3][2]));\n}\n\n// Simplex noise, can seamlessly wrap at multiples of 3\nfloat Simplex(vec3 v, float wrap)\n{\n    const uvec3 GMask = uvec3(0x8000, 0x4000, 0x2000);\n    const vec3 GScale = 1. / vec3(0x4000, 0x2000, 0x1000);\n    \n\t// corners of tetrahedron\n\tmat4x3 T = simplexCoords(v), fv;\n\tvec4 grad;\n    \n    for(int i=0; i<4; ++i) {\n        fv[i] = v - T[i];\n        uvec3 rand = hash3(uvec3(mod(6. * T[i] + 0.5, wrap))).xyz;\n        vec3 gvec = vec3(rand.xxx & GMask) * GScale - 1.;\n        grad[i] = dot(gvec, fv[i]);\n    }\n\n\t// blend gradients\n\tvec4 sv = Smooth(fv);\n\treturn dot(sv, grad);\n}\n\n// Simplex curl noise, can seamlessly wrap at multiples of 3\nvec3 CurlSimplex(vec3 v, float wrap)\n{\n    const uvec3 GMask = uvec3(0x8000, 0x4000, 0x2000);\n    const vec3 GScale = 1. / vec3(0x4000, 0x2000, 0x1000);\n    \n\t// corners of tetrahedron\n\tmat4x3 T = simplexCoords(v), gvec[3], fv;\n\tmat3x4 grad;\n    \n    for(int i=0; i<4; ++i) {\n        fv[i] = v - T[i];\n        uvec3 rand = hash3(uvec3(mod(6. * T[i] + 0.5, wrap)));\n        gvec[0][i] = vec3(rand.xxx & GMask) * GScale - 1.;\n        gvec[1][i] = vec3(rand.yyy & GMask) * GScale - 1.;\n        gvec[2][i] = vec3(rand.zzz & GMask) * GScale - 1.;\n        grad[0][i] = dot(gvec[0][i], fv[i]);\n        grad[1][i] = dot(gvec[1][i], fv[i]);\n        grad[2][i] = dot(gvec[2][i], fv[i]);\n    }\n\n\t// blend gradients\n\tvec4 sv = Smooth(fv);\n\tmat3x4 ds = dSmooth(fv);\n\n    // compute Jacobian, rely on compiler to get rid of unneeded elements\n\tmat3x3 J;\n\tJ[0] = vec3((gvec[0] * sv) + (grad[0] * ds));\n\tJ[1] = vec3((gvec[1] * sv) + (grad[1] * ds));\n\tJ[2] = vec3((gvec[2] * sv) + (grad[2] * ds));\n\n    // curl from Jacobian\n\treturn vec3(J[1][2] - J[2][1], J[2][0]-J[0][2], J[0][1]-J[1][0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // initialize on first frame, or when \"r\" is pressed\n    if (iFrame == 0 || texture(iChannel1,vec2(Rkey,0.5)).x > 0.5) {\n    \tvec3 xyz = TileXYZ(uv, iResolution.xy);\n        \n        vec3 curl = CurlSimplex(xyz * 9., 9.);        \n        float noise = Simplex(xyz * 3., 3.)\n            + Simplex(xyz *  6.,  6.) / 2.\n            + Simplex(xyz * 12., 12.) / 4.\n            + Simplex(xyz * 24., 24.) / 8.;\n        \n        fragColor = vec4(curl / 8., noise * 0.5) + 0.5;\n    }\n    else\n        fragColor = texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// tweakable constants and common functions\n\n// keyboard texture letter position\nconst float Rkey = 82.5/256.;\n\n// sphere parameters\nconst float radius = 0.5, rsq = radius * radius;\nconst float cloudscale = 1.0;\nconst float maxdensity = 10.0;\nconst float opacitymin = 0.1;\nconst float opacitymax = 1.0;\n\n// view and light positions\nconst float eyedist = 1.0;\nconst vec3 lightpos = vec3(10,10,10);\nconst float autorot = 0.05;\n\n// flow parameters\nconst float flowspeed = 0.2;\nconst float flowscale = 0.3;\n\n// ray marching steps\nconst float stepsize = 0.15;\n\n// how much of new frame to blend (1.0 no temporal blending)\nconst float historyBlend = 0.1;\n\n\n\n// 3D to 3D hash function\nuvec3 hash3(uvec3 v) \n{\n\tv = v * 1664525u + 1013904223u;      \n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v >> 16u;\n}\n\n\n// single 0-1 float from hash\nfloat frand(uvec3 h) {\n    return float(h.x) / float(0x10000);\n}\n\n\n\n////////////////////////////////////////////////////////////////////////\n// Tiling 3D texture atlas stuff\n\n// TileXYZ and TileLookup pack slices of a 3D texture into a 2D texture\n// Tiles.x * Tiles.y total z slices of size texturesize/Tiles\n// at standard shadertoy 640x360, this is 60 tiles of 64x60\n// actually works OK even if the tiles don't work to exact integer texels\nconst vec2 Tiles = vec2(5,3);\n\n// 3D coordinate from texture UV for tiled 3D texture\n// texture is grid x grid array of tiles\nvec3 TileXYZ(vec2 uv, vec2 texsize) \n{\n    // scale so each unit in xy is one tile, z is tile number\n    vec3 p;\n    float numtiles = Tiles.x * Tiles.y;\n    p.xy = uv * Tiles;\n    p.z = (floor(p.x) / Tiles.x + floor(p.y)) / Tiles.y;\n    p.xy = fract(p.xy);\n\n    // add per-tile texel border to avoid tile artifacts\n    vec2 pixPerTile = texsize / Tiles;\n    p.xy += (p.xy - 0.5) / pixPerTile;\n\n    return p;\n}\n\n// Lookup in tiled 3D texture atlas\n// texture is grid x grid array of tiles\nvec4 TileLookup(sampler2D Texture, vec3 xyz) \n{\n    // adjust for tile border\n    vec2 pixPerTile = vec2(textureSize(Texture,0)) / Tiles;\n    xyz.xy = fract(xyz.xy);\n    xyz.xy = (xyz.xy * pixPerTile + 0.5) / (pixPerTile + 1.);\n\n    // xy scaled down to the size the slice will be in the texture\n\tvec2 tilexy = xyz.xy / Tiles;\n    \n    // z scaled up to slice number (with possible fraction between slices)\n    float numtiles = Tiles.x * Tiles.y;\n    float tilez0 = fract(xyz.z) * numtiles;\n    float tilez1 = fract(xyz.z + 1./numtiles) * numtiles;\n\n    // look up slice below current z\n    float z0 = floor(tilez0);\n    vec2 uv0 = tilexy + vec2(fract(z0 / Tiles.x), floor(z0 / Tiles.x) / Tiles.y);\n    vec4 tx0 = texture(Texture, uv0); \n\n    // look up slice above current z\n    float z1 = floor(tilez1);\n    vec2 uv1 = tilexy + vec2(fract(z1 / Tiles.x), floor(z1 / Tiles.x) / Tiles.y);\n    vec4 tx1 = texture(Texture, uv1);\n    \n    // blend slices\n    return mix(tx0, tx1, fract(tilez0));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ray march through some smoke\n\n// smoke density, advected by 3-phase flow with quadratic blending\nfloat density(vec3 p) {\n    float boundary = smoothstep(rsq, 0.5 * rsq, dot(p,p));\n    \n    // flow map\n    vec3 flow = TileLookup(iChannel0, flowscale * p + 0.5).xyz - 0.5;\n    flow *= flowspeed;\n    \n    // remove the normal component of the flow near the boundary\n    flow -= p*dot(p,flow)/rsq;\n    \n    // base timeline\n    float time = 0.5*iTime + 0.5;\n    float t = fract(time);\n    float s = 1. - t;\n\n    // weight for each of three phases\n    float w0 = 0.5*t*t;\n    float w1 = s*t + 0.5;\n    float w2 = 0.5*s*s;\n\n    // local time within each phase\n    float t0 = 2. * t - 3.;\n    float t1 = 2. * t - 1.;\n    float t2 = 2. * t + 1.;\n    \n    // how many times have we seen each phase\n    float T0 = floor(time);\n    float T1 = floor(time/3. + 1./3.);\n    float T2 = floor(time/3. + 2./3.);\n\n    // noise coordinate for each component\n    float offset = floor(time);\n    vec3 nc0 = cloudscale * p + t0 * flow + offset * vec3( 1, 2, 3);\n    vec3 nc1 = cloudscale * p + t1 * flow + offset * vec3( 5, 7,11);\n    vec3 nc2 = cloudscale * p + t2 * flow + offset * vec3(13,17,19);\n\n    \n    // noise value for each phase (noise in alpha of atlas texture)\n    float tx0 = TileLookup(iChannel0, nc0).w;\n    float tx1 = TileLookup(iChannel0, nc1).w;\n    float tx2 = TileLookup(iChannel0, nc2).w;\n\n    // blend to single combined noise value\n    float noise = smoothstep(0.3, 0.9, tx0 * w0 + tx1 * w1 + tx2 * w2);\n    noise = mix(opacitymin, opacitymax, noise);\n\n    // volume density, from noise, sphere shape, and overall scale\n\treturn boundary * noise * maxdensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera pose from mouse location, or auto-rotate\n    vec2 angles = iMouse.xy / iResolution.xy;\n    if (angles == vec2(0)) {\n        float rtime = iTime * autorot;\n        vec2 angle0 = vec2(hash3(uvec3(rtime)+0u).xy) / float(0x10000);\n        vec2 angle1 = vec2(hash3(uvec3(rtime)+1u).xy) / float(0x10000);\n        angles = mix(angle0, angle1, fract(rtime));\n    }\n    angles *= vec2(6.28,3.14);\n\n    float Cx = cos(angles.x), Sx = sin(angles.x);\n    float Cy = cos(angles.y), Sy = sin(angles.y);\n    vec3 screenZ = vec3(-Sx*Sy, Cy, -Cx*Sy);\n    vec3 screenX = normalize(vec3(-screenZ.z,0,screenZ.x));\n    vec3 screenY = normalize(cross(screenX, screenZ));\n    \n\t// ray geometry\n    vec3 eye = eyedist * screenZ;\n    vec3 pixel = vec3(0); // look at 0,0,0 in world space\n    pixel += eyedist * screenX * (fragCoord.x - 0.5 * iResolution.x) / iResolution.y;\n    pixel += eyedist * screenY * (fragCoord.y - 0.5 * iResolution.y) / iResolution.y;\n    vec3 ray = normalize(pixel-eye);\n    vec3 raystep = ray * stepsize;\n\n    // check for intersection against sphere at 0,0,0\n    fragColor = vec4(0);\n    float rsq = radius*radius;\n\tfloat b = dot(ray, eye);\n\tfloat d = b*b - dot(eye, eye) + rsq;\n    \n    if (d >= 0.) {\n        // cheat on intersection tests since we know sphere \n        // is in front of the eye\n        d = sqrt(d);\n        float near = -d-b, far = d-b;\n\n        // raymarch through volume\n        int steps = int(2. * radius / stepsize);\n        vec3 pos = eye + near * ray;\n\n        // randomize first step\n        uvec3 hash = hash3(uvec3(fragCoord,iFrame));\n        pos += frand(hash) * raystep;\n        \n        // trace into volume\n        for(float t=near; t < far; t += stepsize) {\n            // trace a ray toward the light for the shadow\n            float shadow = 0.;\n            vec3 Lray = normalize(lightpos - pos);\n            vec3 Lstep = Lray * stepsize;\n            vec3 Lpos = pos;\n            for(int j=0; j < steps && dot(Lpos,Lpos) < rsq; ++j) {\n                Lpos += Lstep;\n                shadow += (1. - shadow) \n                    * clamp(stepsize*density(Lpos), 0., 1.);\n            }\n            \n            // accumulate color and opacity\n            vec4 cloud = vec4(vec3(1. - shadow), 1.) \n                * clamp(stepsize*density(pos), 0., 1.);\n            fragColor += (1. - fragColor.a) * cloud;\n            \n            pos += raystep;\n        }\n    }\n    \n    // TAA-like blend with previous results\n    if (iFrame > 0) {\n        fragColor = mix(texture(iChannel1, fragCoord/iResolution.xy), \n                        fragColor, historyBlend);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}