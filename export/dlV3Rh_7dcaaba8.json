{"ver":"0.1","info":{"id":"dlV3Rh","date":"1690813303","viewed":46,"name":"Cubist Raymarching","username":"aidanwyber","description":"A composite of rotations around the scene constitutes a \"smooth\" version of the cubist approach to painting...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric","cubism","cubist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime*2.0\n\n#define PI 3.1415925359\n#define TAU 6.2831852\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .005\n\n#define mouse (iMouse.xy/iResolution.xy)\n\nstruct mat {\n    vec3 col;\n    float spec;\n};\n\nfloat sdfSphere(vec3 pos, vec4 sph) {\n    return length(sph.xyz - pos) - sph.w;\n}\n\nfloat sdfGround(vec3 pos, float y0) {\n    return pos.y - y0;\n}\n\nfloat sdfScene(vec3 pos) {\n    // w comp is radius\n    vec4 sphereA = vec4(0.15, 0.2, 0.2, 0.333);\n    vec4 sphereB = vec4(-0.1, -0.1, -0.1, 0.25);\n    sphereA.y += sin(time) * 0.11;\n    sphereB.y += cos(time * 1.3) * 0.17;\n    \n    float sd = min(sdfSphere(pos, sphereA), sdfSphere(pos, sphereB));\n    sd = min(sd, sdfGround(pos, -1.0));\n    return sd;\n}\n\nfloat rayMarch(vec3 camPos, vec3 rayDir) {\n    float camDist = 0.; //Distane Origin\n    for(int i=0; i < MAX_STEPS; i++) {\n        vec3 p = camPos + rayDir * camDist;\n        float dist = sdfScene(p); // ds is Distance Scene\n        camDist += dist;\n        \n        if (camDist > MAX_DIST || dist < SURFACE_DIST) break;\n    }\n    return camDist;\n}\n\nvec3 sdfNormal(vec3 pos) {\n    float d = sdfScene(pos);\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(d - vec3(sdfScene(pos + e.yxx),\n                              sdfScene(pos + e.xyx),\n                              sdfScene(pos + e.xxy)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy/2.) / iResolution.y;\n    vec2 m = vec2(cos(time), sin(time)) * 0.3; // iMouse.xy / iResolution.xy * 2. - 1.;\n    //vec2 screenUV = (uv);// * 2. - 1.) * 1.;\n    \n    int nPersps = 70;\n    vec3 avCol = vec3(0.);\n    for (int i = 0; i < nPersps; i++) {\n        // add iterator to rotate campos for compositing\n        float ti = float(i) / float(nPersps);\n        \n        //vec3 camPos = vec3(0.0, 1.0, -1.0);\n        vec3 camPos = vec3(cos(ti * TAU), 1.0, sin(ti * TAU));\n        //camPos.y = sin(time) * 0.2;\n        vec3 target = vec3(0.0, 0.0, 0.0);\n\n        vec3 lookAt = target - camPos;\n        lookAt += vec3(m, 0.);\n        vec3 ww = normalize(lookAt);\n        vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n        vec3 vv = normalize(cross(uu, ww));\n\n        vec3 fragPos = camPos + ww * 1. + uu * uv.x + vv * uv.y;\n        vec3 rayDir = normalize(fragPos - camPos);\n\n        float sd = rayMarch(camPos, rayDir);\n\n        vec3 sdPos = camPos + rayDir * sd;\n        vec3 normal = sdfNormal(sdPos);\n\n        vec3 lightDir = normalize(ww + normalize(vec3(0.2, -0.4, -0.2 + sin(time))));\n        float spec = dot(normal, -lightDir);\n        spec = clamp(spec, 0., 1.);\n\n        vec3 col = vec3(spec) * (1.-normal);\n        avCol += col;\n    }\n    avCol /= float(nPersps);\n    // Output to screen\n    fragColor = vec4(avCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}