{"ver":"0.1","info":{"id":"McKcWw","date":"1731974237","viewed":48,"name":"Wren's Mini Solar System","username":"BEN1JEN","description":"A little mini solar system, still very much a work-in-progress :)","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["planet","stars","solarsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand2(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat rand4(vec4 co) {\n    return rand2(co.xy + co.zw * 997.4846 + 765.5373);\n}\n\nfloat simplex3(vec3 co) {\n    co = co*3.1 + 0.2;\n    vec3 l = floor(co);\n    vec3 h = ceil(co);\n    vec3 d = co-l;\n    float lll = rand4(vec4(l.x, l.y, l.z, 1.0));\n    float llh = rand4(vec4(l.x, l.y, h.z, 1.0));\n    float lhl = rand4(vec4(l.x, h.y, l.z, 1.0));\n    float lhh = rand4(vec4(l.x, h.y, h.z, 1.0));\n    float hll = rand4(vec4(h.x, l.y, l.z, 1.0));\n    float hlh = rand4(vec4(h.x, l.y, h.z, 1.0));\n    float hhl = rand4(vec4(h.x, h.y, l.z, 1.0));\n    float hhh = rand4(vec4(h.x, h.y, h.z, 1.0));\n    float xll = lll*(1.0-d.x)+hll*d.x;\n    float xlh = llh*(1.0-d.x)+hlh*d.x;\n    float xhl = lhl*(1.0-d.x)+hhl*d.x;\n    float xhh = lhh*(1.0-d.x)+hhh*d.x;\n    float xyl = xll*(1.0-d.y)+xhl*d.y;\n    float xyh = xlh*(1.0-d.y)+xhh*d.y;\n    return xyl*(1.0-d.z)+xyh*d.z;\n}\n\nfloat layered3(vec3 co, float layers) {\n    float total = 0.0;\n    float divisor = 0.0;\n    for (float i = 1.0; i < layers; i++) {\n        float weight = 1.0/i;\n        divisor += weight;\n        total += simplex3(co*i)*weight;\n    }\n    return total/divisor;\n}\n\nfloat distSquared(vec3 a, vec3 b) {\n    vec3 c = a - b;\n    return dot(c, c);\n}\n\nfloat lineSphereIntersect(out vec3 pos, vec3 ray_pos, vec3 ray_direction, float sphere_rad) {\n    ray_pos /= sphere_rad;\n\n    float closest_along_ray = dot(ray_direction, -ray_pos);\n    float dist = distSquared(ray_direction*closest_along_ray, -ray_pos);\n    if (dist > 1.0) {\n        return -1.0;\n    }\n    float z = sqrt(1.0-dist);\n    pos = (ray_direction*(closest_along_ray-z)+ray_pos)*sphere_rad;\n    return z*2.0;\n}\n\nvec3 rotate_about(vec3 vec, vec3 about, float theta) {\n    vec3 up = about*dot(vec, about);\n    vec3 par = vec-up;\n    vec3 tangent = cross(par, about);\n    return par*cos(theta) + tangent*sin(theta) + up;\n}\n\nfloat earth_height(vec3 pos) {\n    pos = normalize(pos);\n    vec3 pos_rot = rotate_about(pos, normalize(vec3(-0.5, 1.0, -0.5)), iTime/2.0);\n    float height = layered3(pos_rot, 5.0);\n    return height;\n}\n\nfloat specular(vec3 normal, vec3 view_dir, vec3 light_dir, float hardness) {\n    vec3 reflection = 2.0*dot(light_dir, normal)*normal - light_dir;\n    return pow(clamp(dot(view_dir, reflection), 0.0, 1.0), hardness);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.yy*2.0;\n    vec3 ray = normalize(vec3(uv, 3.0));\n\n    const vec3 view_pos = vec3(0.0, 0.0, -3.0);\n    vec3 light_pos = rotate_about(vec3(1.0, 0.0, 0.5)*1.3, normalize(vec3(0.5, 1.0, -1.0)), iTime/3.5);\n\n    vec3 moon_orig = rotate_about(-vec3(1.0, 0.0, -0.5)*1.1, normalize(vec3(-0.5, 1.0, -1.0)), iTime/3.5);\n\n    vec3 sun_pos;\n    float sun_depth = lineSphereIntersect(sun_pos, view_pos-light_pos, ray, 0.3);\n    vec3 moon_pos;\n    bool moon_intersect = lineSphereIntersect(moon_pos, view_pos-moon_orig, ray, 0.2) > 0.0;\n    vec3 pos;\n    bool earth_intersect = lineSphereIntersect(pos, view_pos, ray, 0.5) > 0.0;\n    vec3 atmo_pos;\n    float atmo_thickness = max(lineSphereIntersect(atmo_pos, view_pos, ray, 1.1), 0.0);\n\n    atmo_thickness = atmo_thickness*atmo_thickness/2.0;\n    if (earth_intersect) {\n        atmo_thickness = abs(pos.z - atmo_pos.z);\n    }\n    float sun_dist = length(light_pos - (atmo_pos+ray*atmo_thickness/2.0));\n    float sun_closeness = 1.0/(pow(sun_dist, 3.0)+1.0);\n    vec4 atmo_colour = vec4(0.0, 0.5, 1.0, 0.0) * (1.0-sun_closeness) + vec4(1.0, 1.5, 1.5, 0.0) * sun_closeness;\n    atmo_colour *= pow(atmo_thickness, 2.0)/6.0;\n\n    if (moon_intersect\n        && (!earth_intersect || moon_pos.z+moon_orig.z < pos.z)\n        && (sun_depth <= 0.0 || moon_pos.z+moon_orig.z < sun_pos.z+light_pos.z)\n    ) {\n        vec3 light_direction = normalize(light_pos-moon_pos-moon_orig);\n        float moon_diffuse = pow(max(dot(normalize(moon_pos), light_direction), 0.0), 1.5);\n        vec3 dummy;\n        if (lineSphereIntersect(dummy, moon_pos+moon_orig, light_direction, 0.5) > 0.0) {\n            moon_diffuse = 0.0;\n        }\n        vec3 moon_color = vec3(0.7-pow(layered3(rotate_about(moon_pos*3.0, vec3(0.0, 1.0, 0.0), -iTime*0.5), 6.0), 2.5)*0.35);\n        fragColor = vec4(moon_color*0.5 + moon_color*vec3(1.0, 1.0, 0.7)*moon_diffuse*0.5, 1.0);\n        return;\n    }\n\n    if (sun_depth > 0.0 && (!earth_intersect || sun_pos.z+light_pos.z < pos.z)) {\n        vec3 sun_pos_1 = rotate_about(sun_pos, normalize(vec3(0, 1, 1)), iTime*1.0);\n        vec3 sun_pos_2 = rotate_about(sun_pos, normalize(vec3(-1, 1, 0)), -iTime*0.5);\n        float brightness = layered3(sun_pos_1*3.0, 3.0);\n        brightness += layered3(sun_pos_2*3.0, 3.0);\n        if (brightness < 0.7) {\n            fragColor = vec4(0.9, 0.7, 0.3, 1.0);\n        } else if (brightness < 1.0) {\n            fragColor = vec4(1.0, 0.9, 0.4, 1.0);\n        } else if (brightness < 1.3) {\n            fragColor = vec4(1.0, 0.95, 0.6, 1.0);\n        } else {\n            fragColor = vec4(1.0, 1.0, 0.9, 1.0);\n        }\n        fragColor += vec4(sun_depth > 1.0 ? 0.0 : 1.0-sun_depth);\n        fragColor += atmo_colour/4.0;\n        return;\n    }\n\n    if (!earth_intersect) {\n        float space_fade = layered3(ray*1.5, 3.0);\n        vec3 space_colour = vec3(0.0, 0.0, 0.05)*(1.0-space_fade) + vec3(0.15, 0.0, 0.25)*space_fade;\n        \n        float star_brightness = 0.0;\n        vec2 star_pos = uv*4.0 + 5.0;\n        vec2 box_pos = floor(star_pos);\n        star_pos -= box_pos;\n        for (float i = 0.0; i < 16.0; i++) {\n            vec2 offset_pos = vec2(rand2(box_pos + vec2(i, 2.0*i)), rand2(box_pos - vec2(3.0*i, -0.5*i) + vec2(-12.1291, 189.4892)));\n            float star_scale = pow(rand2(box_pos + i*vec2(-129.1023, -189.4892)), 3.0)/256.0;\n            float star_dist = length(star_pos-offset_pos);\n            star_brightness = max(star_brightness, star_scale/star_dist);\n        }\n        star_brightness = max(star_brightness, 0.1)-0.1;\n\n        fragColor = vec4(space_colour*(1.0-star_brightness) + star_brightness, 1.0) + atmo_colour;\n        return;\n    }\n\n    float height = earth_height(pos);\n    vec3 light_dir = normalize(light_pos-pos);\n\n    vec3 diffuse_colour = height > 0.5 ? vec3(0.0, 0.8, 0.0) : vec3(0.0, 0.5, 1.0);\n    diffuse_colour *= 1.0-floor(abs(0.5-height)*10.0)/10.0;\n\n    float diffuse = pow(max(dot(normalize(pos), normalize(light_pos-pos)), 0.0), 1.5);\n    float specular = specular(normalize(pos), normalize(view_pos-pos), light_dir, 2.0);\n\n    float spec_intensity = height > 0.5 ? 0.15 : 0.4;\n\n    fragColor = vec4(\n        diffuse_colour*0.3 +\n        (diffuse_colour+0.5)*diffuse*0.25 +\n        vec3(1.0, 1.0, 0.0)*specular*spec_intensity,\n    1.0) + atmo_colour;\n}","name":"Image","description":"","type":"image"}]}