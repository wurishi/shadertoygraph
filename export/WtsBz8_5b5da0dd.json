{"ver":"0.1","info":{"id":"WtsBz8","date":"1596013119","viewed":297,"name":"Saturn","username":"romeosoft","description":"Saturn, The most beautiful planet in the solar system except Earth!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["planet","saturn","astronom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\nconst float pi = 3.1415926;\n\nconst vec3 \n    c1 = vec3(0.04, 0.02, 0.3),\n\tc2 = vec3(0.12, 0.06,1.25);\nconst vec3 \n    c3 = vec3(0.06, 0.1, 0.5),\n\tc4 = vec3(0.10, 0.10,0.9);\n\nconst float R = 0.2;\nconst float R1 = R * 1.25;\n\nfloat time;\n\n//--------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\n// iq's noise\n//--------------------------------------------------------------\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//--------------------------------------------------------------\n// hsv and rgb\n//--------------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n//--------------------------------------------------------------\nbool shadow(vec3 p)\n{\n    vec3 v=vec3(0.,0.,-0.1);\n    for(int i = 0; i < 10; i ++)\n    {\n        p += v;\n        float r = length(p);\n        if(r<R)\n            return true;\n    }\n    return false;\n}\nvec3 getCor(float r, vec3 p)\n{\n    bool bshadow = shadow(p);\n    float d = (r - R1);\n    ROT(p.xz, (0.1) * (iTime + 15.0));\n    \n    vec3 cor0 = mix(c1,c2,0.5 * (0.75 + 2.0 * sin(r*35.0) + 0.5 * sin(r*188.0)+ 0.25 * sin(r*358.0) + 0.125 * sin(r*828.0)));\n    \n    vec3 cor = mix(cor0, vec3(0.), 0.05 * NebulaNoise(vec3(r,d,0)));\n    \n    return bshadow ? mix(vec3(0.),HSV2RGB(cor),0.25) : HSV2RGB(cor);\n}\nvec3 shadow2(vec3 p)\n{\n    if(p.y>0.)\n         return vec3(0.);\n    \n    vec3 v=vec3(0.,0.002,0.01);\n    for(int i = 0; i < 150; i ++)\n    {\n        p += v;\n        \n        float r = length(p);\n        if(r<R*0.9)\n            return vec3(0.);\n        \n        if(p.y>=0.)\n        {\n            if(r >= 0.275 && r <= 0.5)\n            {\n                vec3 cor = getCor(r, p); \n                if(cor.r > 0.7)\n                    return cor;\n            }\n            return vec3(0.);\n        }\n    }\n    return vec3(0.);\n}\nvec3 getSaturnCor(float r, vec3 p, vec3 camray, float dc)\n{\n    vec3 shadow = shadow2(p);\n    \n    float dr = (r - R1);\n    ROT(p.xz, (0.1) * (iTime + 15.0));\n    \n    float nz = (0.65 + 0.5 * sin(p.y*75.0));\n    \n    float h = dc * 0.08;\n    float h0 = 0.25;\n    float n = min(4., floor(log2(h0 / h)));\n    h=h0;\n    for(float i = 1.; i <= n; i +=1.0)\n    {\n        float w = i*100.;\n        nz += (noise(p*w) - 0.5) * h;\n        h /= 2.0;\n    }\n    vec3 cor0 = mix(c3,c4,nz);\n    \n    vec3 cor = mix(cor0, vec3(0.), dr / (1.-R1));\n    \n    return shadow.r >= 0.01 ? mix(shadow * 0.25,HSV2RGB(cor),0.6) : HSV2RGB(cor);\n}\n\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x - 120.5) / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.22) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n    //ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.75 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.005;\n    vec3 cor = vec3(0.0);\n    \n    \n    for(int i = 0; i < 800; i ++)\n    {\n\t\tfloat r = length(vec3(p.x,p.y*1.1,p.z));\n        \n        if(r > R)\n        { \n            dt = mix(0.002,0.005,smoothstep(0.,0.05,abs(p.y * r))); // To be smooth\n            vec3 np = p + (v) * dt;\n            \n            vec3 rp = np;\n            ROT(rp.xz, (0.1) * (iTime + 15.0));\n     \t\tvec3 dp1=rp-vec3(0.95,0.0,1.11);\n            vec3 dp2=rp-vec3(-0.85,0.0,1.11);\n            if(length(dp1) < 0.025)\n            {\n                cor = mix(mix(vec3(0.10, 0.10,0.0),vec3(0.80, 0.80,0.5),1.5 * noise(p*180.))*0.8*(-normalize(dp1).z), cor, cor.r * 2.); \n            \tbreak;\n            }\n            else if(length(dp2) < 0.025)\n            {\n                cor = mix(mix(vec3(0.20, 0.20,0.0),vec3(0.80, 0.80,0.85),1.5 * noise(p*900.))*0.8*(-normalize(dp2).z), cor, cor.r * 2.); \n            \tbreak;\n            }\n            \n            else if(r > R * 1.01)\n            {\n                if (p.y * np.y < 0.)\n                {\n                    if(r >= 0.25 && r <= 0.5)\n                    {\n                        cor = mix(cor, getCor(r, p),0.25);\n                    }\n                }\n            }\n            else\n            {\n                float a = smoothstep(0.05*R, 0.0, (r-R)) * (1.0-abs(dot(-front,-normalize(p))));\n                cor = cor + vec3(0.85,0.9,0.95)*(0.01*a);\n            }\n            p = np;\n        }\n        else\n        {\n            cor = mix(getSaturnCor(r, p, front,length(p-cam))*0.8*(-normalize(p).z), cor, cor.r * 2.); \n            break;\n        }\n    }\n    fragColor = vec4(cor,1.0);\n}","name":"Image","description":"","type":"image"}]}