{"ver":"0.1","info":{"id":"lXsGWX","date":"1708029765","viewed":166,"name":"Playable Hanoi Towers game","username":"Himred","description":"Controls:\nMouse: Click on a source pole and then the destination pole (somehow accurate)\nKeyboard: Use numpad 1,2,3, ie to move from pole #1 to #3 type: 1 3\nTo restart the game: Numpad 0\n","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["game","raymarch","tower","hanoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A Playable raymarched Hanoi Tower game\n\n// Controls:\n// Mouse: click on a source pole and then the destination pole\n// Keyboard: Use numpad 1,2,3, ie to move from pole #1 to #3 type: 1 3\n// To restart the game: Numpad 0\n\n// Misc:\n// When I saw https://www.shadertoy.com/view/XdjXz1 by vgs\n// I knew I'll have to make a playable version :)\n// Some of the functions I use here comes from that shader.\n//\n// THIS CODE IS NOT OPTIMIZED AT ALL\n// IT's MORE OF A PROOF OF CONCEPT, IT MAY LAG FULLSCREEN\n//\n// You can change the number of disks\n// by editing the define NDISC in common.\n\nfloat selected;\nfloat state;\nfloat sx, sy;\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy );\n}\n\nfloat base(vec3 p) {\n    p.y += 0.5;\n    return length(max(abs(p)-vec3(6.0, 0.01, 2.5), 0.0))-0.2;\n}\n\nfloat pole(vec3 p, float r, float h) {\n    vec3 q = vec3(0., h-r, 0.);\n    float alpha = clamp(dot(p,q)/dot(q,q), -1., 1.);\n    return length(p - alpha*q) - r;\n}\n\nfloat disk(vec3 p, float or, float ir, float h) {\n    float d = max(length(p*vec3(1., 2., 1.)) - or, abs(p.y)-0.5*h);\n    return max(d, -pole(p, .5, 3.));\n}\n\nmat3 lookAt(vec3 c, vec3 t) {\n    vec3 z = normalize(c - t);\n    vec3 x = cross(vec3(0.0, 1.0, 0.0), z);\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nvec2 scene(vec3 p) {\n    vec2 res; float d;\n\n    res.y = 1.;\n    res.x = pole(p, .3, 3.);   p.x -= 4.;\n    d = pole(p, .3, 3.); p.x += 8.;\n    if (d < res.x) res = vec2(d, 2.);\n    d = pole(p, .3, 3.); p.x -= 4.;\n    if (d < res.x) res = vec2(d, 0.);\n    \n    for (int x = 0; x < 3; x++)\n        for(int y = 0; y < NDISC; y++) {\n            float v = loadValue(vec2(x,y)).x;\n            if (v == 0.) continue;\n            vec3 pos = vec3 ((float(x)-1.)*4., float(y)*0.42, 0.);\n            float size = v * .25 + .5;\n            float dd = disk(p-pos, size, .65, .4);\n            if (dd < res.x) res = vec2(dd, 10.*v);\n            if (x == int(sx) && y == int(sy)) selected = v;\n        }\n    d = base(p);\n    if (d < res.x) res = vec2(d, 3.);\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(\n    scene(p+q.yxx).x-scene(p-q.yxx).x, \n    scene(p+q.xyx).x-scene(p-q.xyx).x,\n    scene(p+q.xxy).x-scene(p-q.xxy).x));\n}\n\nfloat cubeMap(vec3 p, vec3 n) {\n    vec3 gamma = vec3(2.2);\n    vec3 x = pow(texture(iChannel2, p.yz).rgb, gamma);\n    vec3 y = pow(texture(iChannel2, p.xz).rgb, gamma);\n    vec3 z = pow(texture(iChannel2, p.yx).rgb, gamma);\n    vec3 res = (abs(n.x)*x + abs(n.y)*y + abs(n.z)*z)/(abs(n.x)+abs(n.y)+abs(n.z));\n    return dot(vec3(1.0), res)/3.0;\n}\n\n\nfloat shadow(vec3 p, vec3 l) {\n    vec2 res; float t = 2.0*EPS, sha = 1.0;\n    for (int i = 0; i < 32; ++i) {\n        res = scene(p + l*t);\n        if (res.x < EPS || t > FAR) break;\n        sha = min(sha, 3.0*res.x/t);\n        t += min(0.5, 0.75*res.x);\n    }\n    return res.x < EPS ? 0.0 : clamp(sha, 0.0, 1.0);\n}\n\nfloat ambocc(vec3 p, vec3 n) {\n    float res = 0.0, delta = 5.0*EPS, power = 0.5;\n    for (int i = 1; i <= 5; ++i) {\n        res += power*(delta*float(i) - scene(p + delta*float(i)*n).x);\n        power *= 0.5;\n    }\n    return clamp(1.0 - 5.0*res, 0.0, 1.0);\n}\n\nvec3 getColor(int v)\n{\n    // base\n    if (v == 3) return vec3(.6,.6,.8);\n    \n    // bars (0 1 2)\n    if (v < 3 && state > WON && int(-sx) == v) return vec3(1., 0., 0.);\n    if (v == 0) return vec3(.7);\n    if (v == 1) return vec3(.7);\n    if (v == 2) return vec3(255, 0x80, 0. )/255.;\n    \n    // Discs\n    v = v / 10;\n    if (state == WAIT_DST && v == int(selected)) return vec3(1.,0.,0.);\n    v = v % 5;\n    if (v == 0) return vec3(0x86, 0xd5, 0xa5)/255.;\n    if (v == 1) return vec3(0xff, 0xef, 0xa4)/255.;\n    if (v == 2) return vec3(0xff, 0xaa, 0x9f)/255.;\n    if (v == 3) return vec3(0x86, 0xda, 0xd7)/255.;\n    if (v == 4) return vec3(0xe5, 0xa0, 0xcf)/255.;\n    return vec3(0);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t, float id) {    \n    vec3 mat = vec3(1.0), p = ro +t*rd;\n    vec3 n = normal(p);\n    \n    vec3 y = getColor(int(id));\n  \n    if (id == 3.0) mat = y*cubeMap(0.005*p, n);\n    else mat = y*cubeMap(0.05*p, n);\n    \n    vec3 l = normalize(vec3(0.25, 1.0, -0.25)), h = normalize(l-rd);\n    vec3 amb = vec3(.8);\n    float lamb = max(0.0, dot(n, l));\n    float phong = lamb > 0.0 ?  pow(max(0.0, dot(n, h)), 15.0) : 0.0;\n    float fog = exp(-0.005*t*t);\n    float sha = shadow(p, l);\n    float rim = smoothstep(0.0, 1.0, 1.0 - dot(-rd, n));\n    float ao = ambocc(p, n);\n    vec3 col = mat*fog*ao*(.7*(0.6*amb + sha*(0.5*lamb + .4*phong)) + .35*rim);\n    return col / (col + 1.0);\n}\n\n//----------------------------------------------------------------------------------------------        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res, uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    vec4 st = loadValue(STATE);\n    state = st.x;\n    sx = st.y;\n    sy = st.z;\n    \n    vec3 ro = vec3(0., 5., 5.);\n    vec3 rd = lookAt(ro, vec3(0., 0.0, -1.3))*vec3(uv, -1.0);\n    \n    float t = 0.0;\n    for (int i = 0; i < 96; ++i) {\n        res = scene(ro + t*rd);\n        if (res.x < EPS || t > FAR) break;\n        t += min(0.75*res.x, 0.5);\n    }\n    vec3 sh = shade(ro, rd, t, res.y);\n    vec3 col = (res.x < EPS) ? sh : vec3(0);\n    col = smoothstep(0.0, 0.1, col);\n    col = pow(col, vec3(0.45)); \n    if (state == WON && res.x > EPS) col = vec3(0., 0.4, 0.);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Number of disks\n#define NDISC 5\n\n#define STATE vec2(NDISC + 1)\n#define WAIT_SRC 0.\n#define WAIT_DST 1.\n#define WON 3.\n#define EPS 0.02\n#define FAR 11.0\n#define KEY0 96.\n#define KEY1 97.\n#define KEY2 98.\n#define KEY3 99.\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float data[3*NDISC];\nfloat state;\nfloat mouse;\nint sx = 1000;\nint sy = 1000;\n\nfloat isInside( vec2 p, vec2 c )\n{\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy );\n}\n\nvoid loadData(void)\n{\n    state = loadValue(STATE).x;\n    sx = int(loadValue(STATE).y);\n    sy = int(loadValue(STATE).z);\n    mouse = loadValue(STATE).a;\n\tfor (int x=0; x < 3; x++)\n\t\tfor (int y = 0;y < NDISC; y++)\n\t\t\tdata[3*y+x] = loadValue(vec2(x,y)).x;\n}\n\nvoid setData(int x,int y,float v)\n{\n\tdata[3*y+x]=v;\n}\n\nvoid initData(void)\n{\n    state = WAIT_SRC;\n\tfor (int x = 0;x < 3 * NDISC; x++)\n        data[x] = 0.;\n    \n    for (int y = 0; y < NDISC; y++)\n        setData(0, y, float(NDISC-y));\n}\n\nfloat getData(int x,int y)\n{\n\treturn data[3 * y + x];\n}\n\nint getRow(float key)\n{\n    return int(key - KEY1);\n}\n\nint getTop(int row)\n{\n    for (int y = NDISC - 1; y >= 0; y--)\n        if (getData(row, y) > 0.) return y;\n    return -1;\n}\n\nbool won()\n{ \n    for (int y = 0; y < NDISC; y++)\n        if (getData(2, y) == 0.) return false;\n    \n    return true;\n}\n\nfloat move(float key)\n{       \n    int x = getRow(key);\n    int y = getTop(x);\n    \n    if (state == WON || x == sx ) {\n        sx = 1000;\n        sy = 1000;\n        state = WAIT_SRC;\n        return 0.;\n    }\n    \n    if (y >= 0 && state == WAIT_SRC) {\n        sx = x;\n        sy = y;\n        state = WAIT_DST;\n        return 0.;\n    }\n    \n    if (y < 0 && state == WAIT_SRC) return 0.;\n    \n    float s = getData(sx, sy);\n    \n    if ((y >= 0 && s > getData(x, y))) {\n        state = float(iFrame);\n        sx = -x;\n        sy = 1000;\n        return 0.;\n    }\n    \n    setData(sx, sy, 0.);\n    setData(x, y + 1, s);\n    sx = 1000;\n    sy = 1000;\n    state = WAIT_SRC;\n    if (won()) state = WON;\n    return 0.;\n}\n\nint game()\n{\n    // Loading data\n    loadData();\n        \n    if (state > WON && iFrame - int(state) <= 8) return 0;\n    \n    if (state > WON && iFrame - int(state) > 8) state = WAIT_SRC;\n        \n    // check keyboard\n    if(texelFetch( iChannel1, ivec2(KEY1,1), 0 ).x>.5 ) move(KEY1);\n    if(texelFetch( iChannel1, ivec2(KEY2,1), 0 ).x>.5 ) move(KEY2);\n    if(texelFetch( iChannel1, ivec2(KEY3,1), 0 ).x>.5 ) move(KEY3);\n    if(texelFetch( iChannel1, ivec2(KEY0,1), 0 ).x>.5 ) initData();\n \n    \n    // check Mouse\n    if(mouse!=iMouse.z && iMouse.z>0.) {\n       if (state == WON) {\n           state = WAIT_SRC;\n           return 0;\n       }\n       \n       int x = int(3.*iMouse.x/iResolution.x);\n       float y = iMouse.y/iResolution.y;\n       \n       if (y < 0.3 || y > 0.7) return 0;\n       \n       if (x == 0) move(KEY1);\n       if (x == 1) move(KEY2);\n       if (x == 2) move(KEY3);\n    }\n    mouse = iMouse.z;\n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We init the color to black and exist if outside the pixel data\n    fragColor = vec4(1.0);\n    if( fragCoord.x > float(NDISC+10) || fragCoord.y> float(NDISC+10) ) discard;\n \n    // If first frame we init the data otherwise we play the game\n \tif(iFrame==0) initData(); else game();\n    \t\n    // Saving vars\n    storeValue(STATE,vec4(state, float(sx), float(sy), mouse),fragColor,fragCoord );\n\n    // Saving Array\n    for (int x = 0; x < 3; x++)\n\t\tfor(int y = 0;y < NDISC; y++)\n            storeValue(vec2(x,y),vec4(getData(x,y),0., 0., 0.),fragColor,fragCoord );          \n}","name":"Buffer A","description":"","type":"buffer"}]}