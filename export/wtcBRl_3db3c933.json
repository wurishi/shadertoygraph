{"ver":"0.1","info":{"id":"wtcBRl","date":"1613299430","viewed":121,"name":"SimpleCanvas1.0","username":"dimitr","description":"Sample. Buffer is used for data storing. For those beginners like me ;)","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["mouse","texture","blocks","canvas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nSimple canvas\nUse next defines to set color and canvas properties\nIt's additive, so do not choose bright background color\n*/\n\n#define CELL_SIZE        12.0, 12.0\n#define CELL_PAD         2.0, 2.0\n#define CANVAS_COLOR     0.4, 0.4, 0.4, 1.0\n#define BRUSH_COLOR      0.2, 0.8, 0.2, 1.0\n#define BRUSH_RADIUS     40.0\n\n\nvec4 getCellBounds(vec2 pixel, vec2 cellSize, vec2 cellPad)\n{\n    // returns 4 coordinates, that describe a single cell (including pad)\n    vec2 enlarged_cell = cellSize + cellPad;\n    vec2 index = floor(pixel / enlarged_cell);\n    vec2 cell_begin = enlarged_cell * index;\n    vec2 cell_end = enlarged_cell * (index + vec2(1.0, 1.0));\n    return vec4(cell_begin, cell_end);\n}\n\nvec2 getCellCenter(vec2 pixel, vec2 cellSize, vec2 cellPad)\n{\n    // cell center\n    vec4 cell_bounds = getCellBounds(pixel, cellSize, cellPad);\n    vec2 cell_begin  = cell_bounds.xy;\n    vec2 cell_end    = cell_bounds.zw;\n    return (cell_begin + cell_end) * 0.5;\n}\n\nfloat pixelInsideCell(vec2 pixel, vec2 cellSize, vec2 cellPad)\n{\n    // if outside do nothing\n    vec4 cell_bounds = getCellBounds(pixel, cellSize, cellPad);\n    vec2 cell_end = cell_bounds.zw;\n    float outside_cell = float((pixel.x > (cell_end.x - cellPad.x)) || \n                               (pixel.y > (cell_end.y - cellPad.y)));\n    float inside_cell = 1.0 - outside_cell;\n    return inside_cell;\n}\n\nvec2 cellInRadius(vec2 canvas_cell, vec2 cursor_cell, float radius)\n{\n    // brush affected cells\n    vec2 v = canvas_cell - cursor_cell;\n    float d2 = dot(v, v);\n    float rad2 = radius * radius;\n    float inside = 1.0 - step(rad2, d2);\n    // return d*d to more sharp color gradient (bicubic, not linear)\n    return vec2(inside, d2);\n}\n\nvec4 getDrawnColor(vec2 pixel, vec2 cellSize, vec2 cellPad, \n                   vec4 brushColor, float rad)\n{\n    // select with mouse cursor\n    \n    // not smooth, but according to block size\n    vec2 cell_center = getCellCenter(pixel, cellSize, cellPad);\n    vec2 mouse_cell_center = getCellCenter(iMouse.xy, cellSize, cellPad);\n    \n    // linear selected color grade\n    vec2 insideAndDistance = cellInRadius(cell_center, mouse_cell_center, rad);\n    float inside_rad = insideAndDistance[0]; // 1.0 - inside, 0.0 - not\n    float _distance2 = insideAndDistance[1]; // d*d\n    vec4 drawnColor = inside_rad * (1.0 - _distance2 / rad / rad) * brushColor;\n    \n    return drawnColor;\n}\n\nfloat isBgDrawn(vec4 prevColor, vec4 cellColor)\n{\n    vec4 colorDiff = prevColor - cellColor;\n    float isFilled = float(colorDiff.r > 1e-3 && colorDiff.g > 1e-3 &&\n                           colorDiff.b > 1e-3 && colorDiff.a > 1e-3);\n    return isFilled;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // tex coords for buffer\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // get texture color; remember that it contains not only background, but selection too\n    vec4 prevColor = texture(iChannel0, uv);\n    \n    // canvas setup\n    vec4 cellColor = vec4(CANVAS_COLOR);\n    vec4 brushColor = vec4(BRUSH_COLOR);\n    float brushRadius = BRUSH_RADIUS;\n    vec2 cellSize = vec2(CELL_SIZE);\n    vec2 cellPad = vec2(CELL_PAD);\n    \n    // currect pixel affiliation\n    float inside = pixelInsideCell(fragCoord, cellSize, cellPad);\n    // is bg already drawn on previous steps\n    float bgFilled = isBgDrawn(prevColor, cellColor);\n    // get previous selected\n    vec4 prevDrawn = bgFilled * (prevColor - cellColor);\n    \n    // find current selected color\n    vec4 curDrawnColor = getDrawnColor(fragCoord, cellSize, cellPad,\n                                       brushColor, brushRadius);\n    vec4 diffDrawnColor = curDrawnColor - prevDrawn;\n    diffDrawnColor *= float(diffDrawnColor.a > 0.0);\n    \n    // final color\n    fragColor = inside * (cellColor + prevDrawn + diffDrawnColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}