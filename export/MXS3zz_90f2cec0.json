{"ver":"0.1","info":{"id":"MXS3zz","date":"1708108106","viewed":157,"name":"White Noise LDS","username":"MartyMcFly","description":"Sobol-Owen     |    Roberts 2D     |     Proposed ","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["bayer","lowdiscrepancy","r2","qmc","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nSobol-Owen     |    Roberts 2D     |     Proposed \n\n\nNew type of low discrepancy sequence that mashes together bayer matrix and white noise of all things.\n\nIt is basically just stratified sampling, but the stratification index\nis chosen based on permuting the sample index by the 1D golden radio\nand then mapped to 2D using inverse bayer matrix which on its own ensures\na good distribution, albeit with directional bias. \nThe golden ratio shuffling solves this directional bias.\n\nUsing the most dense stratification possible and adding white noise,\nthis creates a surprisingly well-performing LDS that in an integration test\nperformed equally with both competitors, is faster to generate than sobol\nand does not have the obvious pattern of the R2 sequence.\n\n*/\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    o = texelFetch(iChannel0, ivec2(vpos), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z*mix(vec3(1.0),rgb,c.y);\n}\n\nvec3 gradient(float t) \n{\n    float h = 0.6666 * (1.0 - t*t);\n    float s = 0.75;\n    float v = 1.0 - 0.9*(1.0 - t) * (1.0 - t);\n\treturn hsv2rgb(vec3(h,s,v));    \n}\n\nvec3 viridis(float t) \n{\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    vec2 uv = vpos / iResolution.xy;\n    vec2 orig_uv = uv;   \n    o = vec4(0.0);\n    \n    float aspect = iResolution.x / iResolution.y;\n    uv.y += 0.5 * (aspect - 1.0);\n    uv = uv * 3.0 * vec2(1.0, 1.0 / aspect);\n    int mode = int(uv.x); \n    if(uv.y > 2.0 || uv.y < 1.0) {o = vec4(0); return;}    \n    uv = fract(uv);    \n    \n    uv = uv * 2.0 - 1.0;\n    uv *= 1.2;\n    uv = uv * 0.5 + 0.5;\n    \n    float border = step(0.5, max(abs(uv.x - 0.5), abs(uv.y - 0.5))) * \n                   step(max(abs(uv.x - 0.5), abs(uv.y - 0.5)), 0.5 + length(fwidth(uv)));\n    border *= max(abs(uv.x-0.5), abs(uv.y-0.5)) < 0.55 ? 1.0 : 0.0;   \n    \n    const uint N = 4u;\n    uint offset = uint(iFrame) * N;\n    float radius2 = 12.0 / iResolution.x; \n    \n    o = texelFetch(iChannel0, ivec2(vpos), 0);  \n    for(uint j = 1u; j <= N; j++)\n    {\n       vec2 p = vec2(0);\n       \n        if(mode == 0) p = shuffled_scrambled_sobol_2d(j + offset, 0xFFFFu);\n        if(mode == 1) p = r2(j + offset, uvec2(0xFFFFu)); \n        if(mode == 2) p = bayer_stratified_white_noise(j + offset, uvec2(0xFFFFu));  \n\n        float d = smoothstep(radius2, radius2*0.0, length(p - uv)); \n        \n        o.rgb = mix(o.rgb, viridis(fract(float(j + offset) / 1837.345)), vec3(d));\n    }\n    \n    o += vec4(border);\n     \n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"uint uint_hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x21f0aaadu;\n    x ^= x >> 15;\n    x *= 0xd35a2d97u;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec2 bayer_inv(uint i, uint level)\n{\n    uvec2 b = uvec2(0);\n    uvec2 t = uvec2(i, i ^ (i >> 1u));\n    \n    for(uint j = 0u; j < level; j++)\n    {\n        b += b;    \n        b += t & 1u;        \n        t >>= 2u;\n    }\n    \n    return b;\n}\n\nvec2 bayer_stratified_white_noise(uint idx, uvec2 useed)\n{\n   uint level = 15u;\n   uint stratification = 1u << level;   \n   uvec2 stratum = bayer_inv(idx, level).yx; \n\n   //1D golden ratio shuffle for qmc index, this (pseudo)randomizes the location of the stratum\n   uint order = (idx * 2654435769u) % (stratification*stratification);\n   \n   //inverse bayer matrix - bayer maximizes distance between consective samples\n   //this gets us a nicely distributed location of the current stratum bin\n   stratum = bayer_inv(order, level).xy;    \n   stratum <<= 32u - level;\n   \n   //prng\n   uvec2 urand = uvec2(uint_hash(idx + useed.x), uint_hash(idx + useed.y));\n   urand >>= level; \n   \n   //stratification with the same resolution as the bayer matrix     \n   vec2 randv = fract(vec2(urand + stratum)*exp2(-32.0)); \n   return randv;    \n}\n\nuint reverse_bits(uint x) {\n    x = ((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1);\n    x = ((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2);\n    x = ((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4);\n    x = ((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8);\n    return (x >> 16) | (x << 16);\n}\n\nuint OwenHash(uint x, uint seed) \n{\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\nuint nested_uniform_scramble(uint x, uint seed) {\n    x = reverse_bits(x);\n    x = OwenHash(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\n// lifted from boost\nuint hash_combine(uint seed, uint v) {\n    return seed ^ (v + 0x9e3779b9u + (seed << 6u) + (seed >> 2u));\n}\n\n// from https://www.shadertoy.com/view/3ldXzM\nuvec2 sobol_2d(uint index) {\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) {\n        if((index & 1u) != 0u) {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\nvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) {\n    index = nested_uniform_scramble(index, seed);\n    uvec2 p = sobol_2d(index);\n    p.x = nested_uniform_scramble(p.x, hash_combine(seed, 0u));\n    p.y = nested_uniform_scramble(p.y, hash_combine(seed, 1u));\n    return vec2(p)*exp2(-32.);\n}\n\nvec2 r2(in uint idx, in uvec2 useed)\n{\n    uvec2 phi = uvec2(3242174889u, 2447445413u);    \n    uvec2 p = phi * idx + useed;  \n    return vec2(p) * exp2(-32.0);  \n}","name":"Common","description":"","type":"common"}]}