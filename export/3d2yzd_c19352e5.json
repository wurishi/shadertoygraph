{"ver":"0.1","info":{"id":"3d2yzd","date":"1587181087","viewed":192,"name":"Day4: Stroke/Fill Tapered Lines","username":"fluxatron","description":"Yesterday I figured out how to draw a line. Last night my dreams plagued me with thoughts of tapered line maths D:\n\nSo I wrote a function that draws a tapered segment with an outline and/or fill :)\n\nBonus: All transform functions are now column major.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["line","stroke","fill","taper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Vertex\n{\n    vec2 pos;\n    float radius;\n};\n    \nfloat segment(in vec2 p, vec2 a, vec2 b, out float ratio)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tratio = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // Project ap onto ab. Clamp to edges of line if we project beyond it.\n\treturn length( ap - ab*ratio ); // finds length of vec from p to the projection of p onto ab\n}\n\n// returns the distance of p from the taped thicc boi line. negative length indicates p is within the shape\nfloat taperedSegment(vec2 p, vec2 ap, float ar, vec2 bp, float br)\n{\n    float ratio; // Where we are along the line [0,1]. 0 means at a and 1 means b\n    float len = segment(p, ap, bp, ratio); // Compute len from the center line running from point a to b\n    \n    float v = mix(ar, br, ratio);\n    float dist = len - v;\n        \n\treturn dist;\n}\n\n\n// Shape /////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 strokeCol = vec3(0.8,0.2,0.4);\nvec3 fillCol = vec3(0.7,0.3,0.6)*0.6;\nconst int numVerts = 7;\nVertex[numVerts] shape = Vertex[numVerts] (\n    Vertex(vec2(0.25,-0.1), 2.0), // bot left 2\n    Vertex(vec2( 0.0, 0.0), 4.0), // bot left\n    Vertex(vec2( 0.0, 1.0), 2.5), // top left\n    Vertex(vec2( 0.5, 0.5), 5.0), // pivot\n    Vertex(vec2( 1.0, 1.0), 2.5), // top right\n    Vertex(vec2( 1.0, 0.0), 4.0), // bot right\n    Vertex(vec2(0.75,-0.1), 2.0)  // bot right 2\n);\n\n// Finds the distance of P from the line A to B\nvec3 drawShape(vec2 p, mat3 tform, vec3 col, bool stroke, bool fill)\n{\n    float thicc = 0.01;\n    float strokeThicc = 0.008;\n    \n    for(int i = 1; i < numVerts; i++)\n    {\n        Vertex a = shape[i-1];\n        Vertex b = shape[i];\n    \tvec2 ap = (tform * vec3(a.pos, 1)).xy;\n    \tvec2 bp = (tform * vec3(b.pos, 1)).xy;\n        \n        float dist = taperedSegment(p, ap, thicc*a.radius, bp, thicc*b.radius);\n        if (dist < strokeThicc) \n        {\t\n            // stroke\n            col = mix(col, strokeCol, vec3(stroke));\n            \n            // fill\n            if (dist < 0.0) \n            {\n            \tcol = mix(col, fillCol, vec3(fill));\n            }\n        }\n    }\n     \n    return col;\n}\n\n// Move some verts around and scale radii for funsies\nvoid updateShape()\n{\n    shape[2].pos += 0.7 * vec2(0.2*sin(iTime), 0.1*cos(iTime));\n    shape[4].pos += 0.7 * vec2(0.2*-cos(iTime), 0.1*sin(iTime));\n    \n    for (int i = 0; i < numVerts; i++)\n    {\n        shape[i].radius += sin(float(i) + iTime * (1.0 + 0.5*shape[i].radius));\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n/** \n\tMatrix notes\n \t- These are column major.\n\t- Although written as rows, think of them transposed as columns.\n\t- Concatenate transformations in reverse order. Eg. M=T*R*S; Will evaluate left to right (duh) \n\t  but the transformation order will be Scale, Rotate then Translate.\n**/\nmat3 createTranslationMat(vec2 translation)\n{\n    return mat3(vec3(1,0,0), \n                vec3(0,1,0), \n                vec3(translation,1));\n}\nmat3 createScaleMat(vec2 scale)\n{\n    return mat3(scale.x, 0, 0,\n                0, scale.y, 0,\n                0, 0,       1);\n}\nmat3 createRotationMat(float rad)\n{\n    return mat3(cos(rad), sin(rad), 0,\n               -sin(rad), cos(rad), 0,\n                0,        0,        1);\n}\nmat3 createAffineMat(vec2 translation, float rotation, vec2 scale)\n{\n    mat3 S = mat3(createScaleMat(scale));\n    mat3 R = mat3(createRotationMat(rotation));\n    mat3 T = createTranslationMat(translation);\n    return T*R*S;\n}\n\nmat3 matTranslate(mat3 m, vec2 translation)\n{\n    return m * createTranslationMat(translation);\n}\nmat3 matRotate(mat3 m, float rad)\n{\n    return m * createRotationMat(rad);\n}\nmat3 matScale(mat3 m, float scale)\n{\n    return m * createScaleMat(vec2(scale));\n}\nmat3 matScale(mat3 m, vec2 scale)\n{\n    return m * createScaleMat(scale);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 uvNorm = fragCoord/iResolution.xy;\n\n    updateShape();\n    \n    // Shape tform - moves pivot to the middle of our shape\n    mat3 shapeMat = mat3(1);\n    shapeMat = matTranslate(shapeMat, vec2(-.5,-.5));\n    \n    // Model tform - moves/rotates and squishes our model\n    mat3 modelMat = mat3(1);\n\tmodelMat = matTranslate(modelMat, vec2(aspectRatio/2., 0.5));\n    modelMat = matRotate(modelMat, sin(iTime*0.7)*0.7);\n   \tmodelMat = matScale(modelMat, 0.5 + 0.08 * vec2(sin((iTime+3.0)*3.0), cos(iTime*3.0)));\n    \n    // View tform - pan the view about\n    mat3 viewMat = mat3(1);\n    viewMat = matTranslate(viewMat, 0.05 * vec2(2.0*sin(1.2*iTime+3.0), cos(iTime+5.0)) );\n    \n    // Draw\n    vec3 col = vec3(1);\n    col = viewMat * vec3(uvNorm,1)*0.2; // Draw background\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col, true, false); // fill\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col, false, true); // stroke. Done in 2 passes to hide interior strokes. Could be nicer :)\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}