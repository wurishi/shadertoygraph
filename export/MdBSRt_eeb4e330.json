{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*-----------------------------------------------------------------------------\nWritten by Alan Wolfe\nhttp://blog.demofox.org\n\nThis uses just the beginning of the taylor series of sin(x)\n\nhttp://www.wolframalpha.com/input/?i=taylor+series+sin+x\n\ny = x-(x^3)/6+(x^5)/120\n\nit's only very accurate from -PI/2 to +PI/2 so re-using those values.\n\nYou can leave off the x^5 term and get a cheaper aproximation, but that has an\nobvious discontinuity at every peak and valley.  That equation would be:\ny = x-(x^3)/6\n\nred = sin\ngreen = sin aproximation\nyellow = they overlap and are equal\n\n-----------------------------------------------------------------------------*/\n\n// graph settings\n#define POINTSIZE 0.05\n#define LINEWIDTH 0.1\n#define LINEHEIGHT 0.5\n#define LINEINTERVAL (PI*0.5)\n\n// constants\n#define PI 3.14159265359\n\n//-----------------------------------------------------------------------------\nfloat sinTaylor(float theta)\n{\n    // mod & reflect values.  Surely there's a nice branchless way to do this :P\n    theta = mod(theta+PI/2.0, PI*2.0)-PI/2.0;\n    if (theta > PI/2.0)\n        theta = PI - theta;\n    \n    // use Taylor series to aproximate\n    float x3 = (theta*theta*theta);\n    float x5 = (x3*theta*theta);\n    return theta - x3/6.0 + x5/120.0;\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // set up our coordinate system.\n    // x = 0 is the left side of the screen.\n    // y = 0 is the center of the screen\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.0,0.5));\n    percent *= 8.0;\n    percent.x *= aspectRatio;\n   \n    // draw the black graph markings and background\n    float bgColor = 0.3;\n    bgColor *= abs(percent.y) < LINEWIDTH ? 0.0 : 1.0;\n    if ((mod(percent.x, LINEINTERVAL) < LINEWIDTH * 0.5 || mod(percent.x, LINEINTERVAL) > (LINEINTERVAL - LINEWIDTH * 0.5))\n      &&(abs(percent.y) < LINEHEIGHT))\n        bgColor *= 0.0;\n    \n    // draw the sine values\n    vec3 color = vec3(bgColor);\n    \n    // real\n    if (abs(percent.y - sin(percent.x)) < POINTSIZE)\n        color.x = 1.0;\n    \n    // aproximated\n    if (abs(percent.y - sinTaylor(percent.x)) < POINTSIZE)\n         color.y = 1.0;\n        \n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdBSRt","date":"1414783246","viewed":544,"name":"Sin without trig II","username":"demofox","description":"This version of sin without trig uses a Taylor series.  Red = sin, Green = approximation.  Overlap (where they are the same) = yellow.\nThanks for telling me about this Yuval! (:","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sin"],"hasliked":0,"parentid":"","parentname":""}}