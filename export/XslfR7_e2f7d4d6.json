{"ver":"0.1","info":{"id":"XslfR7","date":"1495940415","viewed":93,"name":"Sphere Raytracer 0521","username":"zhe1994","description":"A basic sphere example: Ray tracing sphere with an rotating light source","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nvec3 planePos = vec3(1.0, -1.0, -2.0);\nvec3 planeNormal = normalize(vec3(0.0, 1.0, 0.0));\nvec3 spherePos = vec3(0.0, -0.3, -2.0);\nfloat sphereRadius = 0.7;\nvec3 sphereBPos = vec3(1.2, -0.5, -2.3);\nfloat sphereBRadius = 0.5;\n\nbool Sphere(vec3 ro, vec3 rd, vec3 pos, float radius, out float t){// Implicit surface\n#if 0\n    /*Geometric solution*/\n    vec3 oc = ro - pos;\n\tfloat c = dot(oc, oc) - (radius * radius);\n\tfloat b = 2.0 * dot(rd, oc);\n\tfloat d = b*b - 4.0 * c;\n\tt = -b - sqrt(abs(d));\n    if(step(0.0, min(d, t)) != 0.0) return true;\n    else\treturn false;\n#else\n    /*Better solution to avoid catastrophic cancellation*/\n    vec3 oc = ro - pos;\n    float b = 2.0 * dot(rd,oc);\n    float c = dot(oc, oc) - radius * radius;\n    float d = b * b - 4.0 * c;\n    if(d < 0.0)\treturn false;\n    else if(d == 0.0){\n    \tt = -0.5 * b;\n    }else{\n    \tfloat q = - 0.5 * (b + b/abs(b) * sqrt(abs(d)));\n        float cdq = c/q;\n        if(max(q, cdq) < 0.0) return false;\n        if(q < 0.0 && cdq > 0.0) t = cdq;\n        else if(q > 0.0 && cdq < 0.0) t = q;\n        else t = min(q, cdq);        \n    }\n    if(t < 0.0)\treturn false;\n    else\t\treturn true;\n#endif\n}\n\nbool Plane(vec3 ro, vec3 rd, vec3 pos, vec3 normal, out float t){\n    float denom = dot(normal, rd);\n    if(abs(denom) > 0.0001){\n        t = dot(pos - ro, normal) / denom;\n        return (t >= 0.0); \n    }\n    return false;\n}\n\nbool Trace(vec3 ro, vec3 rd, out vec2 t, out vec3 normal, out vec2 texCoord){\n    float tNear = 999999.0;\n    float tx = tNear + 1.0;\n    bool isHit = false;   \n       \n    if(Sphere(ro, rd, spherePos, sphereRadius, tx) && tx < tNear){\n    \tt = vec2(tx, 1.0);\n        tNear = tx;\n        isHit = true;\n    }\n    \n    if(Sphere(ro, rd, sphereBPos, sphereBRadius, tx) && tx < tNear){\n    \tt = vec2(tx, 3.0);\n        tNear = tx;\n        isHit = true;\n    }\n    \n    if(Plane(ro, rd, planePos, planeNormal, tx) && tx < tNear){\n    \tt = vec2(tx, 2.0);\n        tNear = tx;\n        isHit = true;\n    }\n    \n    if(t.y == 1.0 || t.y == 3.0)\t{\n        vec3 point = ro + t.x * rd;\n        texCoord.x = (1.0 + atan(point.z, point.x) / PI) * 0.5;\n        texCoord.y = acos(point.y) / PI;\n        normal = normalize(point - spherePos);\n    }\n    else if(t.y == 2.0)\t{\n        vec3 point = ro + t.x * rd;\n        normal = planeNormal;\n        vec3 u = normalize(vec3(normal.y, -normal.x, 0.0));\n        vec3 v = cross(normal, u);\n        texCoord = vec2(dot(u, point), dot(v, point));\n    }\n    \n    return isHit;\n}\n\nfloat Lighting(vec3 normal, vec3 sd){\n    return max(0.0, dot(sd, normal));\n}\n\nbool Shadow(float index, vec3 point, vec3 sd){\n    float temp;\n    if(index != 1.0 && Sphere(point, sd, spherePos, sphereRadius, temp)) return true;\n    if(index != 3.0 && Sphere(point, sd, sphereBPos, sphereBRadius, temp)) return true;\n}\n\nvec3 Render(vec3 rd, vec3 ro){\n    vec3 sd = normalize(vec3(sin(iTime + 2.26), 1.0 ,cos(iTime + 2.26)));\n    vec2 t, texCoord;\n    vec3 normal, col;\n    if(Trace(ro, rd, t, normal, texCoord)){\n        float kd = Lighting(normal,sd);\n        if(t.y == 1.0 || t.y == 3.0)\tcol = 2.0 * kd * texture(iChannel0, texCoord).rgb + 0.1 * vec3(0.6, 0.2, 0.2);\n        else if(t.y == 2.0){\n            col = 2.0 * kd * texture(iChannel1, texCoord).rgb;\n;\n        }\n        vec3 point = ro + rd * t.x;\n        bool hasShadow = Shadow(t.y, point, sd);\n        if(hasShadow) col *= 0.3;\n    }else{\n    \tcol = vec3(0.6, 0.6, 0.6);\n    }\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    vec3 col = vec3(0.0), ro = vec3(0.0, 0.0, 0.0), rd = normalize(vec3(uv, - 1.0) - ro);\n\n    col = Render(rd, ro);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}