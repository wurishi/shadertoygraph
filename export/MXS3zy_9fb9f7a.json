{"ver":"0.1","info":{"id":"MXS3zy","date":"1708967007","viewed":4980,"name":"Space At Home","username":"lz","description":"Representation of the items at home. Listening to the music I love.\nMain animation sequence is 150s then it's a sequence of 6 stills (It never gets fully repetitive, since the laptop does move).","likes":97,"published":1,"flags":32,"usePreview":1,"tags":["3d","table","bvh","chair","laptop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Space at home. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n    //--------------------------------------------------------//\n       Notes:\n       \n       Modeling my 'workspace' at home. Used real measurements for the items in inches (because started with the laptop).\n       \n       Tested on the following machines:\n            Windows with RTX 2060 (mobile). (Full HD 30 - 60 fps)\n            Windows with Intel Iris (mobile). (Full HD 15 - 35 fps)\n            MacBook Pro M2 (Arm). (3840x2160 10 - 25 fps)\n            \n        The deferred rendering style is mostly to save compilation time on windows chrome\n        which at one time peaked to 25s (without even having all the features). On windows \n        Firefox the compilation time is usually better (about half the time on chrome).\n        So I have been rebalancing the workload (compilation time) between the buffers.\n        \n        One of the consequnces of this was repacking [0 - 1] interval into 8 bit values\n        and passing several such values in one channel (see Buffer C). \n        \n        Used Cook-Torrance PBR model for lighting (at least for the main part). The N component produces some artifacts\n        on edges. A proper solution would probably be filtering (not made the cut)\n        \n        Heavily optimized for performance:\n        - All non-floor items used bounding volumes (not bounding boxes) on trace.\n        - Used shadow (and ao) mapping to trace only objects that can cast shadow on a specific object\n        - Used maps for normals to calculate the normal only on the hit subpart.\n        - When using patterns, calculated distance to nearest cell boundary to avoid\n          4 calculations of neighbors. \n        - Floor was calculated analytically (and then it could be filtered analytically as well) and\n          it improved performance of the whole trace.\n        - Shadows were downsampled and calculated on 1/2 of the resolution and upsampled on image integration.\n          The rays were cone-traced and the final result was later smoothed to alleviate artifatcs.\n    //--------------------------------------------------------//\n*/\n\nconst float MAX_KRN_SIZE = 1.;\n\n////\nvec3 laplace(in float _dist, in vec3 _val, \n    in sampler2D _ch, in vec2 _uv, in vec2 _eps)\n{\n  float krnSize = floor(smoothstep(0.35, 1., _dist) * MAX_KRN_SIZE);\n  vec3 scol;\n  float sw = 0.;\n  float w = 0.;\n  for (int i = -int(krnSize); i <= int(krnSize); i++)\n  {\n      for (int j = -int(krnSize); j <= int(krnSize); j++)\n      {\n         vec3 ncol = texture(_ch, _uv + _eps * vec2(i, j)).rgb;\n         w = 1.;\n         sw += w;\n         scol += w * ncol;\n      }\n  }\n  \n  scol /= sw;\n  \n  vec3 res = mix(_val, scol, krnSize/MAX_KRN_SIZE);\n\n  return scol;\n}\n\n////\nvec3 laplace_packed(in float _dist, in vec3 _val, \n    in sampler2D _ch, in ivec2 _crd)\n{\n  float krnSize = floor(smoothstep(0.35, 1., _dist) * MAX_KRN_SIZE);\n  vec3 scol;\n  float sw = 0.;\n  float w = 0.;\n  for (int i = -int(krnSize); i <= int(krnSize); i++)\n  {\n      for (int j = -int(krnSize); j <= int(krnSize); j++)\n      {\n         float nv = TF(_ch, _crd + ivec2(i, j)).r;\n         UNPACK_UINT_TO_CUI3(nv)\n         w = 1.;\n         sw += w;\n         scol += w * unpacked_cui3;\n      }\n  }\n  \n  scol /= sw;\n  \n  vec3 res = mix(_val, scol, krnSize/MAX_KRN_SIZE);\n\n  return scol;\n}\n\nvec2 toUV(in vec4 _plane, in vec2 _p, in vec2 _reverse, in vec4 _txcrd)\n{\n    vec2 tx = ((_p - _plane.xy) / _plane.zw); // 0 - 1 range\n    tx = mix(tx, vec2(1.) - tx, _reverse); // reverse axes if needed\n    return _txcrd.xy + tx * _txcrd.zw; // convert to texture coordinates\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos, in int _trace_flag, in float _eps ) // for function f(p)\n{\n    float h = _eps;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h, _trace_flag, iChannel3, true, false).x;\n    }\n    return normalize(n);\n}\n\nvec4 triplanar(in vec3 p, in vec3 scale, in vec3 _w)\n{  \n  vec4 dx = texture(iChannel2, p.yz*scale.yz);\n  vec4 dy = texture(iChannel2, p.zx*scale.zx);\n  vec4 dz = texture(iChannel2, p.xy*scale.xy);\n  \n  return dx * _w.x + dy *_w.y + dz * _w.z;\n}\n\nvec3 render_floor(in vec3 _p, in float _t, inout vec3 _n) {\n    vec2 st = _p.zx;\n    float mx = 0.4;\n    float dp = smoothstep(0., 1., length(fwidth(_p)));\n    float mscl = 0.1 - 0.1 * dp;\n    st.x *= mx;\n    float my = 0.03 + 0.05 * hash(floor(st.x) + 28.2);\n    st.y *= my;\n    st.y += hash(floor(st.x));\n    vec2 fst = fract(st);\n    vec2 vst = smoothstep(vec2(0.), mscl * vec2(mx, my), fst) - smoothstep(vec2(1.) - vec2(mx, my)*mscl, vec2(1.), fst);\n\n    // bump map the floor.\n    vec3 dx = vec3(0., 2.*dFdx(vst.x), 1.);\n    vec3 dy = vec3(1., 2.*dFdy(vst.y), 0.);\n    vec3 n = normalize(cross(dx, dy));\n    _n = mix(n, _n, dp);\n    \n    vec3 clr = (vec3(1., 1., 0.8) - vec3(0.12, 0.12, 0.05)*hash(floor(st)));\n    clr = mix(0.5*clr, clr, vst.x * vst.y);\n    clr = mix(clr, texture(iChannel2, fract(st*0.1)).rgb, 0.5);\n    \n    // fade out\n    float rst = length(_p.xz);\n    float ast = mod(PI + atan(_p.z, _p.x), PI2);\n    clr = mix(clr, 0.0 * clr, smoothstep(130., 160., rst));\n            \n    return clr;\n}\n\nvec3 render_laptop(in vec3 _p, in vec3 _n, in vec3 _d, in float _tdist,\n    in int _mtl, in float _scrRatio, out vec4 _mtlParams)\n{\n    vec4 dims = TF3(LAPTOP_H_DIMS);\n    const float lpWidth = 0.5;\n    const float lpRatio = 0.6965386; // This is laptop ratio\n    float lpHeight = lpRatio * lpWidth * _scrRatio;\n    \n    vec3 frame = vec3(0.55);\n    vec3 ldir = normalize(vec3(_d));\n    \n    // roughness, metalness, emmissive\n    _mtlParams = vec4(0.15, 1., 0., 0.);\n    \n    vec3 col = frame;\n    lpTrf = mat4(TF3(LAPTOP_BASE_TRF_0), TF3(LAPTOP_BASE_TRF_1), \n                 TF3(LAPTOP_BASE_TRF_2), TF3(LAPTOP_BASE_TRF_3));\n                 \n    scrTrf = mat4(TF3(LAPTOP_SCRN_TRF_0), TF3(LAPTOP_SCRN_TRF_1),\n                  TF3(LAPTOP_SCRN_TRF_2), TF3(LAPTOP_SCRN_TRF_3));\n                  \n    vec4 on = (lpTrf * vec4(_n, 0.));\n    vec3 op = (lpTrf * vec4(_p, 1.)).xyz;\n\n    if (_mtl == LAPTOP_MTL && on.y > 0.99) // keyboard and trackpad\n    {\n      col = vec3(1., 0., 0.) * dot(-ldir, _n);\n      vec2 tx = toUV(vec4(-dims.xz, 2.*dims.xz), op.xz, vec2(1., 1.), vec4(0.001, 1.-lpHeight, lpWidth - 0.001, lpHeight));\n      \n      vec2 tuv = toUV(vec4(-dims.xz, 2.*dims.xz), op.xz, vec2(1., 1.), vec4(0., 0., 1., 1.));\n       \n      // speaker section\n      float speakers = float(inBox(abs(vec2(0.5, 0.) - tuv), vec4(0.38, 0.462, 0.115, 0.436)));\n      tuv.x *= dims.x/dims.z;\n      float dtuv = length(fwidth(tuv));\n      vec2 grid = tuv * (iResolution.y) * 0.075;\n      float f_speakers = smoothstep(0.05, 0.18, length(fract(grid) - vec2(0.5)));\n      \n      f_speakers = mix(f_speakers, 0.9, smoothstep(0.001, 0.005, dtuv));\n      \n      vec4 clr = texture(iChannel3, tx);\n      \n      vec3 tn = (transpose(lpTrf) * vec4(normalize(vec3(clr.y, 0.0001, clr.z)), 0.)).xyz;\n      // sin phi angle\n      float sin_phi = (abs(_d.y)/length(_d));\n      float f_phi_dir = smoothstep(0., 1., 1. - abs(sin_phi - 0.5));\n      float f_btn_border = smoothstep(0., 0.01,length(clr.yz));\n      // button light\n      float f_button = step(1., clr.w);\n      float lf = max(1.,4.*noise(clr.w*sin_phi*0.5 + 30.)*f_phi_dir*f_button);\n      // trackpad and button light\n      float lf_key_press = float(int(clr.w) == int(TF3(LAPTOP_KEY_ANIM).r));\n      \n      // color - pressed button highlight color\n      col = clr.rrr - (1. - f_btn_border)*0.2*lf_key_press;\n      //col += clr.rrr * (f_button);\n      col += 0.25*max(dot(tn, _d), 0.)*step(0.5, clr.w)*lf*(1.-lf_key_press*f_btn_border);\n      col = mix(col, col * f_speakers, speakers);\n      \n      float button_light = mix(0., 0.1, 1.-smoothstep(0., 50., _tdist));\n      _mtlParams = vec4(0.1*f_button, (1.-f_button), button_light * f_btn_border * f_button, 0.);\n      col = mix(col, 0.25*col, smoothstep(0., 0.05, dtuv) * f_button);\n    }\n    else if (_mtl == (LAPTOP_SCREEN_MTL) && (scrTrf * on).y < -0.9) // screen\n    {\n        col = vec3(1., 1., 1.);\n        vec2 tx = toUV(vec4(-dims.xz, 2.*dims.xz), (scrTrf * vec4(op, 1.)).xz, vec2(1., 0.), vec4(lpWidth, 1.-lpHeight, lpWidth, lpHeight));\n        \n        vec4 scrCol = texture(iChannel3, tx);\n        scrCol.rgb -= scrCol.rgb * (1. - scrCol.a);\n        col = scrCol.rgb;\n        _mtlParams.rgb = vec3(0.001, 0., 1. * scrCol.a);\n        //col = (0.5 * scrTrf * on + vec4(0.5)).rgb;\n    }\n    else if (_mtl == (LAPTOP_MTL + 3)) // panel\n    {\n        col = vec3(0.3);\n    }\n    \n    else if (_mtl == (LAPTOP_MTL + 4)) // jacks\n    {\n        vec3 c = op - vec3(dims.x, 0., -dims.z + 1.075 + 0.14);\n        float fc = sdCapsule(c.yz, 0.5, 0.025);\n        float fp = 1. - (length(fract((c + vec3(0., 0.4, 0.25)) * 9.).yz - vec2(0.5)) - 0.2);\n        col = mix(col, 0.5*col, (1. - smoothstep(0., 0.08, fc)));\n        col += (1. - smoothstep(0., 0.02, fc)) * pow(fp, 64.) * vec3(1., 1., 0.2);\n    }\n    \n    if (_mtl == (LAPTOP_MTL + 2) && (scrTrf * on).z > 0.8) // the low normal direction is to account for blending\n    {\n        col = vec3(0.3);\n    }\n   \n    return vec3(col); \n}\n\nfloat cushion_pattern(in vec2 _st) {\n    vec2 grid0 = _st * vec2(1., 1.);\n    vec2 grid1 = grid0;\n    grid0.x += noise(grid0.y*0.5 + grid0.x)*0.3;\n    grid1.x += noise(grid0.y*0.3 + 3.*grid0.x + 2.)*0.5;\n    vec2 fgrid0 = fract(grid0);\n    vec2 fgrid1 = fract(grid1);\n    \n    float f = PULSE_T(fgrid0.x, 0.15, 0.4, 0.6);\n    f = max(f, PULSE_T(fgrid1.x, 0.1, 0.3, 0.4));\n    return f;\n}\nvec3 render_cushion(in vec3 _p, in vec3 _n, in vec3 _w) {\n    const float n_legs = float(N_CHAIRS);\n    vec4 fAng = sdAngularPattern(_p.xz, n_legs, 0.);\n    int chId = int(fAng.w*n_legs);\n    \n    vec2 trp = fAng.y*vec2(cos(fAng.z), sin(fAng.z));\n    \n    vec3 op = vec3(trp.x, _p.y, trp.y);\n    \n    float rotAng = TF(iChannel3, ivec2(chId/4, CHAIR_ROT))[chId % 4];\n    op.xz *= rot2D(rotAng);\n    \n    float dz = max(cushion_pattern(op.xy), cushion_pattern(op.yx));\n    float dy = max(cushion_pattern(op.zx), cushion_pattern(op.xz));\n    float dx = max(cushion_pattern(op.zy), cushion_pattern(op.yz));\n    \n    vec3 col = mix(vec3(1.5), vec3(0.9), (dx * _w.x + dy *_w.y + dz * _w.z));\n    float dpxz = length(fwidth(_p.xz));\n    col = mix(col, vec3(1.1), smoothstep(0., 1., dpxz));\n    return col;\n    //return vec3(0.9);\n}\n\nstruct MtlParams {\n    float roughness; // reflectance\n    float metalness;\n    float ao; //\n    vec3  norm;\n    vec3  fresnel_0;\n    float emissive;\n    vec3  clr;\n    vec3  p;\n    float t; // debug;\n};\n\nvec3 light_shade(const vec3 _p, const vec3 _d, const vec3 _n,\n           in int _il, const float _lshadow, \n           const MtlParams _params, const MtlParams _rflParams) {\n    vec4 lgeo = TF3(ivec2(LIGHT_GEO, _il));\n    vec4 lprop = TF3(ivec2(LIGHT_PROP, _il));\n    \n    vec3 ldir = (lgeo.xyz - _p);\n    vec3 nldir = mix(normalize(lgeo.xyz), normalize(ldir), lgeo.w);\n    \n    vec3 rfldir = (lgeo.xyz - _rflParams.p);\n    vec3 nrfldir = mix(normalize(lgeo.xyz), normalize(rfldir), lgeo.w);\n    \n    float intensity = mix(lprop.w, lprop.w / pow(0.1*length(ldir), 2.), lgeo.w);\n    intensity = max(0., intensity - _lshadow * (1. + length(_rflParams.norm)/(1. + 0.05*_rflParams.t)));\n    vec3 h = normalize(-_d + nldir);\n    vec3  ns = _params.norm.xyz; // norm for specular light.\n    float nh = max(dot(ns, h), 0.0);\n    float nv = max(dot(ns, -_d), 0.0);\n    float nl = max(dot(ns, nldir), 0.0);\n    float ndl = max(dot(_n, nldir), 0.0);\n    float hv = max(dot(h, -_d), 0.0);\n    float hl = max(dot(h, nldir), 0.0);\n    \n    \n    // cook torrance\n    // Normal alignment\n    float a = _params.roughness * _params.roughness;\n    float a2 = a * a;\n    float N = a/(PI*pow(nh*nh*(a-1.) + 1., 2.));\n    \n    // Geometrical occlusion \n    //float k = 0.125 * pow(_params.roughness + 1., 2.);\n    float k = 0.5 * a;\n    float gOut = nv / (nv * (1. - k) + k);\n    float gIn = nl / (nl * (1. - k) + k);\n    \n    // Fresnel shlick approximation\n    //vec3 specClr = mix(vec3(0.4), _params.clr, _params.metalness);\n    //specClr = vec3(0.6);\n    vec3 specClr = _params.fresnel_0;\n    vec3 light_clr = lprop.rgb  + _rflParams.clr * _rflParams.emissive;\n    //specClr = mix(specClr, mix(_params.rflClr.rgb, specClr, 1. - hv), _params.rflClr.w);\n    \n    vec3 fshlick = specClr + (1. - specClr) * pow(1. - hl, 5.);\n    float spec_denom = 4. * nv * nl + T_EPS;\n    vec3 spec = (1. - _lshadow) * N * gIn * gOut * fshlick / spec_denom;\n    \n    // reflection\n    float rfl_nl = (1.-_lshadow)*max(dot(_rflParams.norm, nrfldir), 0.1);\n    spec += fshlick * rfl_nl * _rflParams.clr / PI;\n\n    vec3 diffuse = (light_clr) * (1.-fshlick) * _params.ao * _params.clr / PI;\n    //return vec3(intensity);\n    //intensity = min(intensity, 1.);\n    // remove emissive from per light computation\n    return (spec * hl + diffuse * (ndl) ) * intensity;\n    //return (spec * hl) * intensity;\n    //return vec3(clamp(N, 0., 1.));\n    //return clamp(spec * hl * intensity, 0., 1.) + diffuse * nl * intensity;\n}\n\n// This is the color on reflection.\n// Basically the same function with some simplifications to\n// improve the compilation on windows.\nvoid get_rfl_mtl_color(in vec3 _p, inout vec3 _n, in vec3 _d, in int _mtl,\n    in float _t, in float _scr_res, inout MtlParams _params) {\n    vec3 base_col;\n    bool isMetalFrameMtl = is_metal_mtl(_mtl);\n    _params.roughness = 0.9;\n    _params.metalness = 0.0;\n    _params.emissive = 0.0;\n    _params.fresnel_0 = vec3(0.02);\n    _params.norm = _n;\n\n    // Because we use triplanar projection multiple times\n    // compute it here and use everywhere.\n    vec3  nw; // weights\n    vec3  n2 = _n * _n;\n    float sw = n2.x + n2.y + n2.z;\n    nw.x = n2.x/sw;\n    nw.y = n2.y/sw;\n    nw.z = n2.z/sw;\n    \n    vec3 wood_mtl = triplanar(_p, vec3(0.01, 0.1, 0.01), nw).rgb;\n    vec3 wood_ch_mtl = triplanar(_p, vec3(0.1), nw).rgb;\n    if (_mtl == CHAIR_CUSHION_MTL) {\n        base_col = vec3(1.1);\n        _params.roughness = 0.99;\n        _params.fresnel_0 = vec3(0.02);\n    }\n    else if (isMetalFrameMtl) {\n        base_col = vec3(0.84, 0.5, 0.3) * length(wood_ch_mtl);\n        _params.roughness = (_mtl == CHAIR_FRAME_MTL) ? 0.275 : 0.2;\n        _params.metalness = 1.;\n        _params.fresnel_0 = 0.5*base_col;\n    }\n    else if (_mtl == TABLE_TOP_MTL) {\n        base_col = 0.2*wood_mtl;\n        _params.roughness = 0.99;\n        _params.fresnel_0 = vec3(0.0);\n    }\n    else if (_mtl == CHAIR_BCK_LEG_MTL || _mtl == CHAIR_FRNT_LEG_MTL) {\n        base_col = 2.*wood_ch_mtl;\n        _params.roughness = 0.25;\n        _params.fresnel_0 = vec3(0.1);\n    }\n    else if (_mtl == CHAIR_BASE_MTL) {\n        base_col = 1.2*wood_ch_mtl;\n        _params.roughness = 0.35;\n        _params.fresnel_0 = vec3(0.35); // substitue with different parts\n    }\n    else if (_mtl == CHAIR_BACK_MTL) {\n        base_col = 1.2*wood_ch_mtl;\n        _params.roughness = 0.05;\n        _params.fresnel_0 = vec3(0.35); // substitue with different parts\n    }\n    else if (_mtl >= LAPTOP_MTL) {\n        vec4 mtl;\n        base_col = render_laptop(_p, _n, _d, _t, _mtl, _scr_res, mtl);\n        _params.roughness = mtl.x;\n        _params.metalness = mtl.y;\n        _params.emissive = mtl.z;\n        _params.fresnel_0 = vec3(0.25);\n    }\n    \n    _params.clr = base_col;\n}\n\nvoid get_mtl_color(in vec3 _p, inout vec3 _n, in vec3 _d, in int _mtl,\n    in float _t, in float _scr_res, inout MtlParams _params) {\n    vec3 base_col;\n    bool isMetalFrameMtl = is_metal_mtl(_mtl);\n    _params.roughness = 0.9;\n    _params.metalness = 0.0;\n    _params.fresnel_0 = vec3(0.02);\n    _params.norm = _n;\n    \n    // Because we use triplanar projection multiple times\n    // compute it here and use everywhere.\n    vec3  nw; // weights\n    vec3  n2 = _n * _n;\n    float sw = n2.x + n2.y + n2.z;\n    nw.x = n2.x/sw;\n    nw.y = n2.y/sw;\n    nw.z = n2.z/sw;\n    \n    vec3 wood_mtl = triplanar(_p, vec3(0.01, 0.1, 0.01), nw).rgb;\n    vec3 wood_ch_mtl = triplanar(_p, vec3(0.1), nw).rgb;\n    if (_mtl == CHAIR_CUSHION_MTL) {\n        base_col = render_cushion(_p, _n * _n, nw);\n        _params.roughness = 0.99;\n        _params.fresnel_0 = vec3(0.02);\n    }\n    else if (isMetalFrameMtl) {\n        base_col = vec3(0.84, 0.5, 0.3) * length(wood_ch_mtl);\n        _params.roughness = 0.2;\n        _params.metalness = 1.;\n        _params.fresnel_0 = 0.5*base_col;\n    }\n    else if (_mtl == TABLE_TOP_MTL) {\n        base_col = wood_mtl;\n        _params.roughness = 0.1 + 0.5*clamp((1. - length(base_col)), 0., 1.);\n        _params.fresnel_0 = vec3(0.35);\n    }\n    else if (_mtl == CHAIR_BCK_LEG_MTL || _mtl == CHAIR_FRNT_LEG_MTL) {\n        base_col = 2.*wood_ch_mtl;\n        _params.roughness = 0.25;\n        _params.fresnel_0 = vec3(0.1);\n    }\n    else if (_mtl == CHAIR_BASE_MTL) {\n        base_col = 1.2*wood_ch_mtl;\n        _params.roughness = 0.35;\n        _params.fresnel_0 = vec3(0.35); // substitue with different parts\n    }\n    else if (_mtl == CHAIR_BACK_MTL) {\n        base_col = 1.2*wood_ch_mtl;\n        _params.roughness = 0.05;\n        _params.fresnel_0 = vec3(0.35); // substitue with different parts\n    }\n    else if (_mtl >= LAPTOP_MTL) {\n        vec4 mtl;\n        base_col = render_laptop(_p, _n, _d, _t, _mtl, _scr_res, mtl);\n        _params.roughness = mtl.x;\n        _params.metalness = mtl.y;\n        _params.emissive = mtl.z;\n        _params.fresnel_0 = vec3(0.25);\n    }\n    \n    _params.clr = base_col;\n}\n\nMtlParams getReflectionClr(in float _t, in vec3 _p, in vec3 _d, in vec3 _n, \n    in int _mtl, in int _rfl_mtl, in float _scr_res) {\n    \n    vec3 rfl_dir = normalize(reflect(_d, _n));\n    int rfl_trace_flag = TRACE_NO_FLAG;\n    float eps = N_EPS;\n    \n    if (_mtl == FLOOR_MTL) {\n        rfl_trace_flag = TRACE_TABLE_FLAG | TRACE_CHAIRS_FLAG;\n    }\n    else if ((_mtl == TABLE_TOP_MTL && _n.y > 0.9) || _mtl >= LAPTOP_MTL) {\n        rfl_trace_flag = TRACE_LAPTOP_FLAG;\n    }\n    if (_mtl == LAPTOP_BASE_MTL && _n.y > 0.75)\n    {\n        rfl_dir = vec3(0., 1., 0.); // emissive light from screen.\n        rfl_dir.xz = 0.25*(0.5 - vec2(hash(_p.x), hash(_p.z)));\n        rfl_dir = normalize(rfl_dir);\n    }\n                    \n    vec3 rp = _p + (_t + T_EPS) * rfl_dir;\n#ifdef PACK_CUI_VALUES\n    int i_rfl_mtl = _rfl_mtl;\n#else\n    int i_rfl_mtl = int(map(rp, rfl_trace_flag, iChannel3, false, true).y);\n#endif \n    eps -= 0.9 * N_EPS * float(i_rfl_mtl == LAPTOP_SCREEN_MTL);\n    MtlParams params;\n    //params.norm = norm_forward(rp, rfl_trace_flag, eps);\n    params.norm = calcNormal(rp, rfl_trace_flag, eps);\n    params.p = rp;\n    params.t = _t;\n\n     get_rfl_mtl_color(rp, params.norm, rfl_dir, i_rfl_mtl, \n         _t, _scr_res, params);\n    \n    return params;\n}\n\nvec3 render_floor_high(in vec3 _o, in vec3 _d, in float _tract_t, \n                        vec2 _lshadows, in MtlParams _rflParams) \n{\n    vec3 p = _o + _d * _tract_t;\n    vec3 n = vec3(0., 1., 0.);\n    MtlParams params;\n    \n    vec3 base_col = render_floor(p, _tract_t, n);\n    params.metalness = 0.;\n    params.roughness = 0.3 + 0.7*clamp((1. - length(base_col)), 0., 1.);\n    params.fresnel_0 = vec3(0.2);\n    params.clr = base_col;\n    params.ao = 1.;\n    \n    vec3 col = vec3(0.);\n    for (int il = LIGHT_0; il < LIGHT_0 + N_LIGHTS; il++) {\n        col += light_shade(p, _d, n, il, _lshadows[il - LIGHT_0], params, _rflParams);\n    }\n    \n    return vec3(col);\n}\n\nvec3 render(in float _ao, in vec3 _o, in vec3 _d, in vec3 _n, \n    in int _mtl, in float _tract_t,  vec2 _lshadows, \n    const float _scr_res, in MtlParams _rflParams, out vec3 _emissive) {\n    vec3 p = _o + _d * _tract_t;\n    \n    vec3 col;\n    vec3 n = _n;\n    int i_mtl = _mtl;\n    vec3 base_col = vec3(1.);//m_cls[i_mtl];\n    MtlParams params;\n    params.roughness = 0.1;\n    params.metalness = 0.5;\n\n    params.ao = _ao;\n    get_mtl_color(p, n, _d, _mtl, _tract_t, _scr_res, params);\n\n    col = vec3(0.);\n    for (int il = LIGHT_0; il < LIGHT_0 + N_LIGHTS; il++) {\n        col += light_shade(p, _d, n, il, _lshadows[il - LIGHT_0], params, _rflParams);\n    }\n    \n    _emissive = params.clr * params.emissive;\n\n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/(iResolution.y);\n    vec2 muv = (2.*iMouse.xy - iResolution.xy)/(iResolution.y);\n    vec2 ruv = fragCoord/iResolution.xy;\n    float scr_resolution = iResolution.x / iResolution.y;\n\n    float full_pixel = 2./iResolution.y;\n    float half_pixel = 0.5 * full_pixel;\n    float quad_pixel = 0.5 * half_pixel;\n    \n    vec3 col;\n    vec3 n;\n    vec4 raycast = texture(iChannel0, ruv);\n    vec4 sec_cast = TF1(ivec2(fragCoord));\n    vec2 shadow; // entry for each light\n    float ao; // ambient occlusion\n    int i_mtl = DEFAULT_MTL;\n    int i_rfl_mtl = DEFAULT_MTL;\n    vec2 truv = ruv;\n    vec2 tcrd = fragCoord;\n    float tlfactor = 1.;\n    \n#ifdef DOWNSAMPLE_SHADOWS\n    truv = ruv * 0.5;\n    tcrd = fragCoord * 0.5;\n    tlfactor = 0.5;\n#endif\n\n#ifndef PACK_CUI_VALUES\n    sec_cast.rgb = texture(iChannel1, truv).rgb;\n    sec_cast.rgb = laplace(1., sec_cast.rgb, iChannel1,\n        truv, vec2(scr_resolution * tlfactor, tlfactor)/iResolution.y);\n    shadow = sec_cast.yz;\n    ao = sec_cast.x;\n#else\n    sec_cast.x = TF1(ivec2(tcrd)).x;\n    UNPACK_UINT_TO_CUI3(sec_cast.x)\n    unpacked_cui3.rgb = laplace_packed(1., unpacked_cui3.rgb, iChannel1, ivec2(tcrd));\n    shadow = unpacked_cui3.rg;\n    ao = unpacked_cui3.b;\n    i_mtl = int(sec_cast.y);\n    i_rfl_mtl = int(sec_cast.z);\n    \n#endif // PACK_CUI_VALUES\n    \n    float tfloor = 0.;\n    vec3 emit_col;\n    vec3 p;\n    float dot_p_xz;\n    MtlParams rflParams;\n    bool hitGeom = raycast.x > T_EPS;\n\n    // camera setup - defining o, d, trg (look at)\n    CAMERA_SETUP(uv)\n\n    float iter = MAX_SH_ITER;\n    float far = FAR;\n\n    if (hitGeom) {\n#ifndef PACK_CUI_VALUES\n        i_mtl = int(map(o + raycast.x * d, TRACE_NO_FLOOR, \n            iChannel3, false, true).y);\n#endif\n            n = normalize(raycast.yzw);\n            p = o + raycast.x * d;\n    }\n\n    tfloor = rayXFloor(o.y, d.y);\n    if (tfloor > 0. && !hitGeom && tfloor < FAR) {\n        i_mtl = FLOOR_MTL;\n        n = vec3(0., 1., 0.);\n        p = o + tfloor * d;\n        hitGeom = true;\n        ao = 1.;\n    }\n\n    dot_p_xz = dot(p.xz, p.xz);\n\n    if (hitGeom && dot_p_xz < FLOOR_BOUNDING_CIRCLE_SQR) {\n        if (sec_cast.w > T_EPS)\n            rflParams = getReflectionClr(sec_cast.w, p, d, n, i_mtl, i_rfl_mtl, scr_resolution);\n    }\n\n    if (i_mtl == FLOOR_MTL  && dot_p_xz < FLOOR_BOUNDING_CIRCLE_SQR) {\n        col = render_floor_high(o, d, tfloor, shadow.xy, rflParams);\n        for (float iy = quad_pixel; iy < full_pixel; iy += half_pixel) {\n            for(float ix = quad_pixel; ix < full_pixel; ix += half_pixel) {\n                vec4 trg = TF3(LOOKAT_SEQ);                   \\\n                vec3 dq = normalize(vec3((uv + vec2(ix, iy))*tan(trg.w), -1.)); \\\n                dq = lookAt(o, dq, trg.xyz);\n                float tf = rayXFloor(o.y, dq.y);\n                col += render_floor_high(o, dq, tf, shadow.xy, rflParams);\n            }\n        }\n        col /= 5.;\n        emit_col /= 5.;\n    }\n    else if (i_mtl == FLOOR_MTL) {\n        col = vec3(0.);\n    }\n    else if (hitGeom) {\n        col = render(ao, o, d, n, i_mtl, raycast.x, \n            shadow, scr_resolution, rflParams, emit_col);\n    }\n\n    // post processing\n    // tone mapping    \n    col *= 2.;\n    col /= (col*0.9 + 1.1);\n    col += emit_col;\n    col.rgb = pow(col.rgb, vec3(2.2)); \n\n    fragColor = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Space at home. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   \n*/\n\n// Control and texture buffer.\n// Camera sequence, laptop sequence, laptop animation and lighting are defined here.\n\n#define _0 vec2(0., 12.)\n#define _1 vec2(1., 12.)\n#define _2 vec2(2., 12.)\n#define _3 vec2(3., 12.)\n#define _4 vec2(4., 12.)\n#define _5 vec2(5., 12.)\n#define _6 vec2(6., 12.)\n#define _7 vec2(7., 12.)\n#define _8 vec2(8., 12.)\n#define _9 vec2(9., 12.)\n\n#define _P vec2(0., 10.)\n#define _Q vec2(1., 10.)\n#define _R vec2(2., 10.)\n#define _S vec2(3., 10.)\n#define _T vec2(4., 10.)\n#define _U vec2(5., 10.)\n#define _V vec2(6., 10.)\n#define _W vec2(7., 10.)\n#define _X vec2(8., 10.)\n#define _Y vec2(9., 10.)\n#define _Z vec2(10., 10.)\n#define _A vec2(1., 11.)\n#define _B vec2(2., 11.)\n#define _C vec2(3., 11.)\n#define _D vec2(4., 11.)\n#define _E vec2(5., 11.)\n#define _F vec2(6., 11.)\n#define _G vec2(7., 11.)\n#define _H vec2(8., 11.)\n#define _I vec2(9., 11.)\n#define _J vec2(10., 11.)\n#define _K vec2(11., 11.)\n#define _L vec2(12., 11.)\n#define _M vec2(13., 11.)\n#define _N vec2(14., 11.)\n#define _O vec2(15., 11.)\n\n#define _AT vec2(0., 11.)\n\n#define _EXM    vec2(1., 13.)\n#define _DQT    vec2(2., 13.)\n#define _SHARP  vec2(3., 13.)\n#define _DLR    vec2(4., 13.)\n#define _PRC    vec2(5., 13.)\n#define _AND    vec2(6., 13.)\n#define _QT     vec2(7., 13.)\n#define _OPN_RND_BRCK vec2(8., 13.)\n#define _CLS_RND_BRCK vec2(9., 13.)\n#define _STAR   vec2(10., 13.)\n#define _PLUS   vec2(11., 13.)\n#define _COMMA  vec2(12., 13.)\n#define _DASH   vec2(13., 13.)\n#define _DOT    vec2(14., 13.)\n#define _SLASH  vec2(15., 13.)\n\n#define _CLN  vec2(10., 12.)\n#define _SCLN vec2(11., 12.)\n#define _LST  vec2(12., 12.)\n#define _EQ   vec2(13., 12.)\n#define _GRT  vec2(14., 12.)\n#define _QM   vec2(15., 12.)\n\n#define _OPN_SQR_BRCK vec2(11., 10.)\n#define _BSLASH       vec2(12., 10.)\n#define _CLS_SQR_BRCK vec2(13., 10.)\n#define _CIRCUMFLEX   vec2(14., 10.)\n#define _LOW_DASH     vec2(15., 10.)\n\n#define _OPN_PRN_BRCK vec2(11., 8.)\n#define _PIPE         vec2(12., 8.)\n#define _CLS_PRN_BRCK vec2(13., 8.)\n#define _TILDA        vec2(14., 8.)\n\n#define _BCKTICK      vec2(0., 9.)\n\n#define _a vec2(4.,3.)\n\n#define tx(_x, _y, _ch) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + cgrid)).r\n#define txs(_x, _y, _ch) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + sgrid)).r\n#define txn(_x, _y, _ch) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + ngrid)).r\n\n#define tx_custom(_x, _y, _ch, _v) float(iigrid.x == _x && iigrid.y == _y) * texture(iChannel1, 0.0625 * (_ch + _v)).r\n\n#define normUV(_uv, _pln) clamp((_uv - _pln.xy)/(_pln.zw), vec2(0.01), vec2(0.99))\n\n#define ATF(_crd, _pos, _val) if (_crd.x == _pos.x && _crd.y == _pos.y) { col = _val; }\n\n// VISUALIZATION on LAPTOP\nconst vec2 vhex = normalize(vec2(1., 0.5));\nconst float hexh = 0.8660254037; // = sqrt(3) / 2;\nconst float inv_hexh = 1.15470053837;\nconst vec2 hexGrid = vec2(3., sqrt(3.));\n//https://iquilezles.org/articles/palettes/\n#define CL(_id, _noise)  0.5 + 0.5*cos(6.28 * (_noise * vec3(0.2, 0.8, 0.4) + vec3(2.3, 1.8, 6.1) * vec3(hash(_id))));\n\nvec4 hexgrid(in vec2 _uv)\n{\n  vec4 res;\n  vec2 a = mod(_uv + 0.5 * hexGrid, hexGrid) - 0.5 * hexGrid;\n  vec2 b = mod(_uv, hexGrid) - hexGrid * 0.5;\n  \n  vec2 fa = vec2(dot(abs(a), vhex), abs(a.y));\n  vec2 fb = vec2(dot(abs(b), vhex), abs(b.y));\n  \n  float ma = max(fa.x, fa.y);\n  float mb = max(fb.x, fb.y);\n  \n  vec2 bord;\n  vec2 id;\n  \n  if (ma < mb)\n  {\n    bord = fa;\n    id = floor((_uv + 0.5 * hexGrid) / hexGrid);\n  }\n  else\n  {\n    bord = fb;\n    id = floor(_uv/hexGrid) + vec2(123., 273.);\n  }\n  \n  res.x = min(ma, mb);\n  res.y = min(1. - bord.x, 1. - bord.y);\n  res.zw = id;\n  \n  return res;\n}\n\nvec4 hexThreeGrid(in vec2 _uv, in float _t) {\n    vec2 uv = 2.*_uv - 1.;\n    float gr_size = 4.;\n    vec4 hgrid = hexgrid(uv*gr_size);\n    float gid = hgrid.z * 1000. + hgrid.w;\n    \n    vec3 col1;\n    col1 = CL(gid, noise(0.97*iTime + 131.2));\n    col1 *= (0.3 + 0.5 * smoothstep(0.0, 0.4, hgrid.y));\n    //col1 *= ((0.5 + 0.5 * cos(6.28 * 3. * hgrid.x)));\n    \n    vec4 hgrid2 = hexgrid((uv + vec2(0.5, hexh)) * gr_size);\n    float gid2 = hgrid2.z * 1923. + hgrid2.w;\n    vec3 col2 = CL(gid2, noise(_t*0.95 + 113.1));\n    col2 *= (0.3 + 0.5 * smoothstep(0.0, 0.4, hgrid2.y));\n    //col2 *= ((0.5 + 0.5 * cos(6.28 * 3. * hgrid2.x)));\n    vec3 col = mix(col2, col1, 0.5 );\n    \n    // \n    col = 1.*pow(col, vec3(1.8));\n    return vec4(col, 1.);\n}\n\n///////\n\nfloat roundBox(in vec2 _uv, in vec4 _dims, in float _r)\n{\n    return sdBox(_uv - 0.5 * (2.*_dims.xy + _dims.zw), _dims.zw * (0.5 - 2.*_r)) - _r;\n}\n\nvec4 keyboardLayout(in vec2 _uv, in float _ratio)\n{\n    vec2 grid = _uv * vec2(15., 6.) - vec2(0.4, 0.);\n    vec2 igrid = floor(grid);\n    \n    grid.x -= 0.0 * step(igrid.y, 4.5) + 0.3 * step(igrid.y, 3.5) + 0.3 * step(igrid.y, 2.5)\n                + 0.5 * step(igrid.y, 1.5) + 0.3 * step(igrid.y, 0.5);\n\n    igrid = floor(grid);\n    vec2 fgrid = fract(grid);\n    vec2 cgrid = normUV(fgrid, vec4(0.25, 0.25, 0.5, 0.5)); // center (Letters)\n    vec2 sgrid = normUV(fgrid, vec4(0.3, 0.175, 0.4, 0.4)); // south\n    vec2 ngrid = normUV(fgrid, vec4(0.3, 0.5, 0.4, 0.4)); // north\n    \n    vec2 nlgrid = normUV(fgrid, vec4(0.35, 0.5, 0.3, 0.3)); \n    \n    ivec2 iigrid = ivec2(igrid);\n    \n    vec4 col = vec4(0.1, 0., 0., 0.);\n    float fb = roundBox(fgrid, vec4(vec2(0.03), vec2(0.97)), 0.05);\n    float fk = roundBox(_uv, vec4(vec2(0.001), vec2(0.999)), 0.01);\n    \n    float fkey = 0.;\n    \n    // digits\n    for (int id = 1; id <= 10; id++)\n        fkey += txs(id, 4, vec2(float(id % 10), 12.));\n    // symbols above digits\n    fkey += txn(1,4,_EXM) + txn(2,4,_AT) + txn(3,4,_SHARP) + txn(4,4,_DLR) + txn(5,4,_PRC) +\n            txn(6,4,_CIRCUMFLEX) + txn(7,4,_AND) + txn(8,4,_STAR) + \n            txn(9,4,_OPN_RND_BRCK) + txn(10,4,_CLS_RND_BRCK);\n    fkey += txn(12,4,_PLUS) + txs(12,4,_EQ);\n            \n    fkey += txs(0,4,_BCKTICK) + txn(0,4,_TILDA) + txs(11,4,_DASH) + txn(11,4,_DASH);\n    fkey += txs(11,3,_OPN_SQR_BRCK) + txn(11,3,_OPN_PRN_BRCK) + \n            txs(12,3,_CLS_SQR_BRCK) + txn(12,3,_CLS_PRN_BRCK);\n    fkey += txs(13,3,_BSLASH) + txn(13,3,_PIPE);\n    fkey += txs(10,2,_SCLN) + txn(10,2,_CLN) + txs(11,2,_QT) + tx_custom(11,2,_DQT, nlgrid);\n    \n    fkey += txs(8,1,_COMMA) + txn(8,1,_LST) + txs(9,1,_DOT) + txn(9,1,_GRT);\n    fkey += txs(10,1,_SLASH) + txn(10,1,_QM);\n    \n    // QWERTY\n    fkey += tx(1,3,_Q) + tx(2,3, _W) + tx(3,3,_E) + tx(4,3,_R) + tx(5,3,_T) + tx(6,3,_Y);\n    fkey += tx(7,3,_U) + tx(8,3, _I) + tx(9,3,_O) + tx(10,3,_P);\n    fkey += tx(1,2,_A) + tx(2,2, _B) + tx(3,2,_D) + tx(4,2,_F) + tx(5,2,_G) + tx(6,2,_H);\n    fkey += tx(7,2,_J) + tx(8,2, _K) + tx(9,2,_L);\n    fkey += tx(1,1,_Z) + tx(2,1, _X) + tx(3,1, _C) + tx(4,1,_V) + tx(5,1,_B) + tx(6,1,_N) + tx(7,1,_M);\n    \n    float ikey = float(iigrid.y == 4 && (iigrid.x >= 0 && iigrid.x <= 12));\n    ikey += float(iigrid.y == 3 && (iigrid.x >= 1 && iigrid.x <= 13));\n    ikey += float(iigrid.y == 2 && (iigrid.x >= 1 && iigrid.x <= 11));\n    ikey += float(iigrid.y == 1 && (iigrid.x >= 1 && iigrid.x <= 10));\n    \n    float in_key = float(iigrid.y == 4) + \n                14. * float(iigrid.y == 3) + \n                27. * float(iigrid.y == 2) +\n                38. * float(iigrid.y == 1) + igrid.x;\n    \n    col.r += fkey*2.;\n    fb = 1. - smoothstep(0.0, 0.05, fb);\n    fk = 1. - smoothstep(0.0, 0.02, -fk);\n    col.gb = -(vec2(dFdx(fb), dFdy(fb))) * ikey - vec2(dFdx(fk), dFdy(fk));\n    col.w = ikey * in_key;\n    \n    return vec4(col);\n}\n\nvec4 keyboardTexture(in vec2 _uv, in float _ratio)\n{\n    vec4 frame = vec4(vec3(0.9), 0.);\n    vec4 col = frame;\n    \n    const vec4 keyboard = vec4(0.115, 0.432, 0.77, 0.486);\n    const vec4 trackpad = vec4(0.2767, 0.026, 0.446, 0.3636);\n    \n    float ftrack = roundBox(_uv, trackpad, 0.02);\n    float fkeys = roundBox(_uv, keyboard, 0.02);\n    \n    if (inBox(abs(vec2(0.5, 0.) - _uv), vec4(0.38, 0.462, 0.115, 0.436)))\n    {\n        vec2 grid = _uv * (max(iResolution.x, iResolution.y) * 0.1);\n        grid.y *= _ratio;\n        float f = smoothstep(0.05, 0.15, length(fract(grid) - vec2(0.5)));\n        //col = mix(vec4(vec3(0.1), 0.), frame, f);\n    }\n\n    float ftr = 1. - smoothstep(0., 0.005, -roundBox(_uv, vec4(trackpad.xy + vec2(0.0001), trackpad.zw - vec2(0.001)), 0.025));\n    col.gb = -vec2(dFdx(ftr), dFdy(ftr));\n    col.w = 0.5*step(ftrack, 0.);\n    \n    if (step(fkeys, 0.) > 0.5)\n    {\n        col = keyboardLayout(normUV(_uv, keyboard), iResolution.x/iResolution.y);\n    }\n    \n    // trackpad\n    col.r = mix(col.r, ((0.77) + 0.1*smoothstep(0., 0.001, -ftrack)), step(ftrack, 0.));\n     \n    return col;\n}\n\nfloat key_press_sequence(const float _time) {\n    // key press sequence\n    float t120 = mod(_time, 120.);\n    float t180 = mod(_time, 180.);\n    const float hit_start = 0.;\n    float press_rate = 1.5+0.1*noise(t180);\n    // 47 keys added.\n    // 10% top row, 50% letters, 5% ></ and 35% no key is pressed\n    float key_hash = hash(floor(t180 * press_rate));\n    int key = 1 + int(13. * key_hash * step(key_hash, 0.1) + // top row\n    (13. + 30. * key_hash) * (step(0.1, key_hash) - step(0.6, key_hash)) +\n    (43. + 4. * key_hash) * (step(0.6, key_hash) - step(0.65, key_hash)) +\n    50. * step(0.65, key_hash));\n    \n    return float(key);\n}\n\nfloat func(in vec2 _uv, in vec3 _params, in float _tf) {\n    float lower = _params.x*pow(abs(_uv.x), 1./abs(_uv.x+0.01));\n    //float upper = _params.y - _params.z * _uv.x * _uv.x;\n    float upper = _params.y - atan(_params.z*_uv.x*_uv.x);\n    \n    float f = smoothstep(lower, lower+0.3,_uv.y) *\n               smoothstep(_uv.y - 0.2, _uv.y, upper);\n              \n    f += (0.75 + _tf)*ANIM_T(_uv.y, 0.05, upper) * step(lower, upper);\n    \n    return f;\n    //return step(lower, _uv.y) * step(_uv.y, upper);\n}\n\nvec4 welcome_visualization(in vec2 _ruv, in vec2 crd, in float _r) {\n    vec2 uvScale = vec2(_r, 1.);\n    \n    vec2 _uv = uvScale * (_ruv * 2. - 1.);\n    vec4 slens = vec4(0.6, 1.2, 1.2, 0.);\n    slens.w = 2. * _r - dot(vec3(1.), slens.xyz);\n    float time = iTime;\n    float s1 = in_box(_uv, vec4(-_r, -1., slens.x, 2.));\n    float s2 = in_box(_uv, vec4(-_r + slens.x, -1., slens.y, 2.));\n    float s3 = in_box(_uv, vec4(-_r + dot(vec2(1.), slens.xy), -1., slens.z, 2.));\n    float s4 = in_box(_uv, vec4(-_r + dot(vec3(1.), slens.xyz), -1., slens.w, 2.));\n    \n    vec3 c1 = vec3(1., 0., 0.75);\n    vec3 c2 = vec3(0.0, 1., 0.1);\n    vec3 c3 = vec3(0., 0., 1.);\n    vec3 c4 = vec3(0.75, 0., 1.);\n    float xtime = mod(time, 5.);\n    \n    float grad = _uv.y * 0.5 + 0.5;\n    grad *= 0.75;\n    float circ_mask = pow(length(_uv)/sqrt(_r * _r + 1.), 2.);\n    float bsx = ANIM_T(_uv.x, 0.01, -_r + slens.x) + \n                ANIM_T(_uv.x, 0.01, -_r + slens.x + slens.y) + \n                ANIM_T(_uv.x, 0.01, -_r + slens.x + slens.y + slens.z);\n    vec2 icell_y = vec2(floor(_uv.y * 10.), fract(_uv.y * 10.));\n    int  ycell_id = int(icell_y) + 10;\n    float bsy = 1.-PULSE_T(icell_y.y, 0.1, 0.1, 1. - 0.1);\n    \n    float amp_x = floor((100.*_ruv.x))*0.01;\n    float f_amp_x = fract(100.*_ruv.x);\n    \n    float key_pressed = key_press_sequence(time);\n    \n    ivec2 key_ij = ivec2(int(key_pressed) / 12, int(key_pressed) % 12);\n    float key_y_hit = float(key_ij.y == ycell_id - 7);\n    float f_key = float(key_ij.x == 0) * s1 * key_y_hit;\n    f_key += float(key_ij.x == 1) * s2 * key_y_hit;\n    f_key += float(key_ij.x == 2) * s3 * key_y_hit;\n    f_key += float(key_ij.x == 3) * s4 * key_y_hit;\n    f_key *= step(key_pressed, 49.);\n    \n    float samp = 0.;\n    const float krn = 3.;\n    for (float eq_step = -krn; eq_step <= krn; eq_step++)\n        samp += texture(iChannel0, vec2(floor((100.*_ruv.x) + eq_step)*0.01, 0.0)).x;\n    samp /= (2.*krn + 1.);\n    samp *= 0.5;\n        \n    float amp = 0.5 * texture(iChannel0, vec2(amp_x, .0)).x;\n    \n    float tf = ANIM_T(xtime, 0.1, _uv.x*0.5+_r) * step(0., _uv.y);\n    \n    vec2 fg1 = 1.8*(_uv - vec2(-1.6, -1.6));\n    vec2 fg2 = 1.9*(_uv - vec2(-.6, -2.1));\n    vec2 fg3 = 2.4*(_uv - vec2(.6, -2.3));\n    vec2 fg4 = 2.2*(_uv - vec2(1.5, -1.85));\n    \n    float f1 = func(fg1, vec3(2.6, 4., 1.), tf);\n    float f2 = func(fg2, vec3(2.5, 4.9, 0.4), tf);\n    float f3 = func(fg3, vec3(3.8, 6.4, 0.3), tf);\n    float f4 = func(fg4, vec3(2.6, 4.4, 0.3), tf);\n    \n    float scaled_y = smoothstep(0.3, 0.5, _uv.y*0.5 + 0.5);\n    float scy = _uv.y*0.5 + 0.5;\n    scaled_y += 2.*smoothstep(amp-0.1, amp, _uv.y + 0.2);\n    float scaled_x = PULSE_T(f_amp_x, 0.1, 0.1, 0.9);\n    \n    vec3 col;\n   \n    col += vec3(bsx*0.25 + 0.5*bsy*grad) + (c1 * s1 + c2 * s2 + c3 * s3 + c4 * s4) * circ_mask;\n    col += 0.75*(f1 * c1 + f2 * c2 + f3*c3 + f4*c4);\n    \n    col = mix(col*1., scaled_x*scaled_y*vec3(1.)*step(_uv.y+0.2, amp)*f3*f4, 0.25);\n    col = mix(col*1., scaled_x*scaled_y*vec3(1.)*step(_uv.y+0.2, amp)*f2*f3, 0.25);\n    col = mix(col*1., scaled_x*scaled_y*vec3(1.)*step(_uv.y+0.2, amp)*f1*f2, 0.25);\n    \n    col = mix(col, vec3(1., 0.9, 0.8) * (0.6 + amp), ANIM_T(_uv.y - 0.3 - 0.3*noise(_uv.x + iTime*0.35), 0.02, samp));\n\n    col += vec3(0.1, 0.8, 0.4) * 0.5 * (1. - smoothstep(0., 0.7, length(_uv - vec2(-0.75, 0.2))));\n    col += vec3(0.1, 0.6, 0.9) * 0.75 * (1. - smoothstep(0., 0.7, dot(_uv - vec2(0.7, 0.0),_uv - vec2(0.7, 0.0) ) ) );\n    \n    float fc = (1.-smoothstep(0., 0.0005, dot(_uv - vec2(-1.5, 0.75), _uv - vec2(-1.5, 0.75))));\n    fc += 1.-smoothstep(0., 0.0005, dot(_uv - vec2(-0.6, 0.55), _uv - vec2(-0.6, 0.55)));\n    fc += 1.-smoothstep(0., 0.0005, dot(_uv - vec2(0.5, 0.75), _uv - vec2(0.5, 0.75)));\n    fc += 1.-smoothstep(0., 0.0005, dot(_uv - vec2(1.3, 0.75), _uv - vec2(1.3, 0.75)));\n    //fc *= s2*(0.1+noise(iTime));\n    fc = clamp(fc, 0., 1.);\n    \n    col += 0.5*vec3(fc);\n    \n    col *= (1. + 0.5*f_key);\n    \n    col /= (col + vec3(1.));\n    col = 1.5*pow(col, vec3(1.5));\n    //col = vec3(step(_uv.y, amp));\n    //col = vec3(0.);\n    //col.x = _uv.x;\n    //col.y = _uv.y;\n    return vec4(col, 1.);\n}\n\nvec4 screenTexture(in vec2 _uv, in float _scrRatio, in vec2 _crd)\n{\n    bool inFrame = inBox(_uv, vec4(0.02, 0.025, 0.96, 0.95));\n    float f = sdBox(_uv - vec2(0.5), vec2(0.46, 0.45)) - 0.02;\n    vec4 col = vec4(1., 0., 0., 1.);\n    \n    vec4 frameCol = clamp(mix(vec4(0.05, 0.05, 0.05, 0.), vec4(0.15, 0.15, 0.15, 0.), sqrt(f/0.02)), 0., 1.);\n    vec2 st = _uv * 2. - vec2(1.);\n    st.x /= _scrRatio;\n    vec4 chex = mix(frameCol, hexThreeGrid(_uv, iTime), step(f, 0.));\n    vec4 cwlc = mix(frameCol, welcome_visualization(_uv, _crd, _scrRatio), step(f, 0.));\n    \n    col = mix(chex, cwlc, PULSE_T(iTime, 1., 23., 24.) +\n                 PULSE_T(iTime, 1., 109., 148.) +\n                 step(ANIM_SEQ, iTime)*PULSE_T(mod(iTime, 37.), 1., 15., 29.));\n    col = mix(col, vec4(vec3(0.05), 0.), step(sdBox(_uv - vec2(0.5, 0.05), vec2(1., 0.05)), 0.0));\n    \n    return col;\n}\n\n\nvoid getCamera(in vec2 _uv, in vec2 _muv, out vec3 _o, out vec4 _t) {\n    \n    float fov = 0.5;\n    float atime = ANIM_TIME;\n\n#ifndef DEBUG_HIT\n#ifdef DEBUG_CIRCULAR_MOTION\n    _o = getCameraPosition(atime);\n    _t = vec4(getCameraTarget(atime), fov);\n#endif // circular motion\n#else\n    {\n    #ifdef DEBUG_CIRCULAR_MOTION\n        _o = vec3(0., 30., -190.);\n        _t = vec4(/*getCameraPosition(atime)*/0., 0., 20., fov);\n    #else\n        _o = vec3(75., 25., -75.);\n        _o = rotX(_muv.y) * rotY(_muv.x*2.) * _o;\n        _t = vec4(0., 5., 1., fov);\n    #endif\n    }\n#endif\n}\n\nvoid prepareLaptopTransform(out mat4 _mainTrf, out mat4 _screenTrf) {\n    vec3 targetOrigin = vec3(10., 4.5, 10.);//vec3(16., 5., 12.);\n    vec2 screenRot = vec2(0.);\n    \n    // laptop screen.\n    float l_anim_t = mod(ANIM_TIME, ANIM_SEQ);\n    screenRot.y = mix(-PI,0.1*PI, smoothstep(4., 10., l_anim_t));\n    screenRot.y = mix(screenRot.y, -PI*0.2, smoothstep(133.,136., l_anim_t));\n    screenRot.y = mix(screenRot.y, -PI, smoothstep(140., 143., l_anim_t));\n    screenRot.x = 0.4*PULSE_T(l_anim_t, 5., 12.6, 105.);\n    screenRot.x = mix(screenRot.x, 0.5, smoothstep(140., 145., l_anim_t));\n    targetOrigin += vec3(-4., 0., 10.) * PULSE_T(l_anim_t, 4., 10.5, 105.5);\n    \n    _mainTrf = mat4(1.);\n    _mainTrf *= Rxz(screenRot.x*1.57);\n    _mainTrf[3].xyz -= targetOrigin;\n    \n    mat4 tmtx = mat4(1.);\n    // this is the screen offset relative to center of the laptop\n    vec3 scrOff = vec3(0., 0.175, 9.75 *0.5 - 0.125);\n    // the rotation anchor may differs from the screen attachment.\n    tmtx[3].xyz = scrOff - vec3(0., 0.15, 0.);\n    _screenTrf = Ryz(clamp(1.45 + 1.5*screenRot.y, 0., 2.2));\n    _screenTrf *= tmtx;\n    tmtx[3].xyz -= 2.*scrOff;\n    _screenTrf = tmtx * _screenTrf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/(iResolution.y);\n    vec2 muv = (2.*iMouse.xy - iResolution.xy)/(iResolution.y);\n    \n    vec2 ruv = fragCoord.xy / iResolution.y;\n    float scrRatio = iResolution.x / iResolution.y;\n    float lpWidth = scrRatio * 0.5;\n    const float lpRatio = 0.6965386; // this is a constant of a laptop --> width to height ratio.\n    float lpHeight = lpWidth * lpRatio;\n    vec2 keyStart = vec2(0.5*scrRatio - lpWidth, 1. - lpHeight);\n    vec2 scrStart = vec2(lpWidth, 1. - lpHeight);\n    vec4 col = vec4(vec3(0.5), 0.);\n    float fps;\n    float wide_screen_mode = WIDE_SCREEN_AR;\n    vec4 prev_res = TF2(RES_DATA);\n    vec4 fps_data = TF2(FPS_DATA);\n    float res_changed = 1.;\n    \n    if (inBox(ruv, vec4(keyStart, lpWidth, lpHeight)))\n    {\n        col = keyboardTexture((ruv - keyStart)/vec2(lpWidth, lpHeight), lpRatio);\n        //col = vec4(floor(5.*ruv/vec2(lpWidth, lpHeight)) / 5., 0., 1.);\n    }\n    else if (inBox(ruv, vec4(scrStart, lpWidth, lpHeight)))\n    {\n        col = screenTexture((ruv - scrStart)/vec2(lpWidth, lpHeight), scrRatio, fragCoord);\n        //col = vec4(0., floor(5.*(ruv - vec2(lpWidth, 0.))/vec2(lpWidth, lpHeight))/5., 1.);\n    }\n    \n    // CONTROL ZONE\n    ivec2 crd = ivec2(fragCoord);\n    if (crd.y < CTRL_ZONE && iFrame == 0) {\n        // mapping of casting shadows materials.\n        // DEFAULT_MTL, FLOOR_MTL, TABLE_FRAME_MTL, TABLE_TOP_MTL\n        ATF(crd, ivec2(0, GEOM_SHADOW_MAP), vec4(TRACE_NO_FLAG, TRACE_NO_FLOOR, TRACE_TABLE_LAPTOP,TRACE_TABLE_LAPTOP));\n        // CHAIR_BASE_MTL, CHAIR_BCK_LEG_MTL, CHAIR_FRNT_LEG_MTL, CHAIR_BACK_MTL\n        ATF(crd, ivec2(1, GEOM_SHADOW_MAP), vec4(TRACE_CHAIR_UPPER_W_CUSHION | TRACE_TABLE_TOP_FLAG, TRACE_CHAIR_UPPER_W_CUSHION | TRACE_TABLE_TOP_FLAG, TRACE_CHAIR_UPPER_W_CUSHION | TRACE_TABLE_TOP_FLAG, TRACE_NO_FLAG));\n        // CHAIR_FRAME_MTL, CHAIR_CUSHION_MTL, LAPTOP_BASE_MTL, LAPTOP_SCREEN_MTL\n        ATF(crd, ivec2(2, GEOM_SHADOW_MAP), vec4(TRACE_NO_FLAG, TRACE_TABLE_LAPTOP | TRACE_CHAIR_UPPER, TRACE_LAPTOP_SCREEN_FLAG, TRACE_NO_FLAG/* | TRACE_TABLE_TOP_FLAG*/));\n        \n        // mapping of AO\n        // DEFAULT_MTL, FLOOR_MTL, TABLE_FRAME_MTL, TABLE_TOP_MTL\n        ATF(crd, ivec2(0, GEOM_AO_MAP), vec4(TRACE_NO_FLAG, TRACE_NO_FLAG, TRACE_TABLE_FLAG,TRACE_TABLE_LAPTOP));\n        // CHAIR_BASE_MTL, CHAIR_BCK_LEG_MTL, CHAIR_FRNT_LEG_MTL, CHAIR_BACK_MTL\n        ATF(crd, ivec2(1, GEOM_AO_MAP), vec4(TRACE_CHAIRS_FLAG, TRACE_CHAIRS_FLAG, TRACE_CHAIRS_FLAG, TRACE_CHAIRS_FLAG));\n        // CHAIR_FRAME_MTL, CHAIR_CUSHION_MTL, LAPTOP_BASE_MTL, LAPTOP_SCREEN_MTL\n        ATF(crd, ivec2(2, GEOM_AO_MAP), vec4(TRACE_CHAIRS_FLAG, TRACE_CHAIRS_FLAG, TRACE_LAPTOP_FLAG, TRACE_LAPTOP_FLAG/* | TRACE_TABLE_TOP_FLAG*/));\n        \n        ATF(crd, ivec2(0, CHAIR_ROT), vec4(-0.9*PI -PI/1.1, 1. -PI/1.1, PI/3. -PI/1.1, PI/4. -PI/1.1 + + PI/1.8));\n        ATF(crd, ivec2(1, CHAIR_ROT), vec4(PI/4. -PI/1.1,0., 0., 0.));\n    \n        \n    }\n    else if (crd.y < CTRL_ZONE) {\n        vec4 ctrl = TF2(crd);\n        col = ctrl;\n        // LIGHTS\n        \n        float t_light_cycle = mod(ANIM_TIME, ANIM_SEQ);\n        float l0_i = PULSE_T(t_light_cycle, 4., 5., ANIM_SEQ-5.);\n        float l1_i = PULSE_T(t_light_cycle, 3., 25., ANIM_SEQ-3.);\n        vec3  l2_= normalize(vec3(0., -0.5, 1.));\n        float l2_i = ASYM_PULSE_T(t_light_cycle, 10., 10.5, 12., 56.);\n        \n        if (ANIM_TIME > ANIM_SEQ) {\n            t_light_cycle = mod(ANIM_TIME, 10.);\n            l0_i = PULSE_T(t_light_cycle, 2., 2., 8.);\n            l1_i = PULSE_T(t_light_cycle, 2.5, 2.5, 7.5);\n        }\n        \n        l1_i *= 1.2;\n        \n        ATF(crd, ivec2(LIGHT_GEO, LIGHT_0), vec4(vec4(-10, 70., 10., 1.)));\n        ATF(crd, ivec2(LIGHT_PROP, LIGHT_0), vec4(1,0.956863,0.898039,600.*l0_i));\n        \n        ATF(crd, ivec2(LIGHT_GEO, LIGHT_1), vec4(30., 70., -150., 1.));\n        ATF(crd, ivec2(LIGHT_PROP, LIGHT_1), vec4(1,0.839216,0.666667, 800.*l1_i));\n        \n        // LAPTOP\n        ATF(crd, LAPTOP_H_DIMS, 0.5 * vec4(14., 0.5, 9.75, 0.));\n        ATF(crd, LAPTOP_KEY_ANIM, vec4(key_press_sequence(iTime), vec3(0.)));\n        \n        mat4 lpTrf = mat4(1.);\n        mat4 lpScrTrf = mat4(1.);\n        \n        prepareLaptopTransform(lpTrf, lpScrTrf);\n        \n        ATF(crd, LAPTOP_BASE_TRF_0, lpTrf[0]);\n        ATF(crd, LAPTOP_BASE_TRF_1, lpTrf[1]);\n        ATF(crd, LAPTOP_BASE_TRF_2, lpTrf[2]);\n        ATF(crd, LAPTOP_BASE_TRF_3, lpTrf[3]);\n        \n        ATF(crd, LAPTOP_SCRN_TRF_0, lpScrTrf[0]);\n        ATF(crd, LAPTOP_SCRN_TRF_1, lpScrTrf[1]);\n        ATF(crd, LAPTOP_SCRN_TRF_2, lpScrTrf[2]);\n        ATF(crd, LAPTOP_SCRN_TRF_3, lpScrTrf[3]);\n        \n        // CAMERA\n        if (crd.y <= CAMERA_SETUP_ROW) {\n            vec3 o;\n            vec4 t;\n            getCamera(uv, muv, o, t);\n            ATF(crd, ORIG_SEQ, vec4(o, 1.));\n            ATF(crd, LOOKAT_SEQ, t);\n        }\n        \n        // FPS\n        //ATF(crd, RES_DATA, vec4(iResolution.xy, 0., 0.));\n        if (iFrame % 20 == 1) {\n          fps = 20. / (iTime - fps_data.x);\n          ATF(crd, FPS_DATA, vec4(iTime, fps, iResolution.y, 0.));\n        }\n    }\n\n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Space at home. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   \n\n    Buffer B - Main ray cast\n             - output: trace t and normal.\n*/\n\nvec3 norm_forward(in vec3 _p, in int _trace_flags, in float _eps, in float _f, in bool _use_f) {\n    vec2 e = vec2(_eps, 0.);\n    vec3 n;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    for (int i = ZERO; i < 3 && iFrame > 0; i++) {\n        n[i] = map(_p + vec3(i == 0, i == 1, i == 2)*_eps, _trace_flags, \n            iChannel3, true, false).x - _f;\n    }\n    \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/(iResolution.y);\n    vec2 muv = (2.*iMouse.xy - iResolution.xy)/(iResolution.y);\n    float scr_resolution = iResolution.x / iResolution.y;\n    float half_pixel = 1./iResolution.y;\n    vec3 col;\n    vec2 raycast = vec2(0., FAR);\n    vec3 norm;\n    float fmtl;\n    vec2 lshadows;\n    float n_eps = N_EPS;\n    \n    // camera setup - defining o, d, trg (look at)\n    CAMERA_SETUP(uv)\n\n    float iter = MAX_ITER;\n    float far = FAR;\n\n    int trace_flags = (sign(d.y) < 0.) ? TRACE_ALL : TRACE_NO_FLOOR;\n    raycast = trace(o, d, trace_flags, iChannel3, iter, far, T_EPS);\n\n    if (bool(isHit(raycast, T_EPS))) {\n        int i_mtl = int(map(o + raycast.x * d, trace_flags, \n            iChannel3, false, true).y);\n        n_eps = mix(N_EPS*10., T_EPS, float(i_mtl == LAPTOP_SCREEN_MTL));\n        norm = norm_forward(o + raycast.x * d, getNormMap(i_mtl), n_eps,raycast.y, !is_metal_mtl(i_mtl));\n    }\n\n    fragColor = vec4(raycast.x * float(isHit(raycast, T_EPS)),norm);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Space at home. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   \n\n    Buffer C - Shadow and AO\n             - input: Buffer B - hit objects.\n             - output: Shadows from each light source and AO.\n*/\n\nint getShadowMap(int _mtl, float _y) {\n    int mtl = min(_mtl, LAPTOP_SCREEN_MTL);\n    int _trace_flag = (_mtl == TABLE_TOP_MTL && _y > 2.5) ? \n        TRACE_LAPTOP_FLAG : int(TF3(ivec2(mtl/4,GEOM_SHADOW_MAP))[mtl % 4]);\n        \n    return _trace_flag;\n}\n\nint getAoMap(int _mtl) {\n    int mtl = min(_mtl, LAPTOP_SCREEN_MTL);\n    return int(TF3(ivec2(mtl/4,GEOM_AO_MAP))[mtl % 4]);\n}\n\nvec2 trace_sh(in vec3 _o, in vec3 _d, int _trace_flags, const float _fov,\n    in sampler2D _ch, const float _iter, const float _far, const float _eps) {\n    float t = 0.;\n    float mint = 10.;\n    vec2 res = vec2(10.);\n    float cf = (_fov * 2.) / iResolution.y; // cone tracing\n    g_dir = _d;\n\n    for (float fi = 0.; fi < _iter; fi++) {\n        vec3 p = _o + _d * t;\n\n        mint = map(p, _trace_flags, _ch, false, false).x;\n        \n        if (abs(mint) < t * (_eps + cf) || t > _far)\n            break;\n        if (dot(normalize(p.xz), _d.xz) > 0. \n            && dot(p.xz, p.xz) > GEOM_BOUNDING_CIRCLE_SQR)\n            break;\n        \n        t += mint;\n    }\n    \n    return vec2(t, mint);\n}\n\nvec2 calcShadow(in vec3 _p, int i_mtl) {\n    vec2 lshadows = vec2(0.);\n    for (int il = 0; il < N_LIGHTS; il++) {\n        vec4 lgeo = TF3(ivec2(LIGHT_GEO, LIGHT_0 + il));\n\n        vec3 ldir = normalize(lgeo.xyz - _p);\n        vec2 sh_ray = trace_sh(_p + ldir*0.001, ldir, getShadowMap(i_mtl, _p.y),\n        0.5, iChannel3, MAX_ITER, 0.5*FAR, TS_EPS);\n        float sh_cf = mix(isHit(sh_ray, TS_EPS + 0.5), 0.5 * isHit(sh_ray, TS_EPS + 0.5), pow(smoothstep(0., 1., sh_ray.x/75.), 4.));\n        lshadows[il] = sh_cf;\n    }\n    \n    return lshadows;\n}\n\n//https://www.shadertoy.com/view/4sSfzK\nfloat CalcAO(in vec3 _p, in vec3 _n, in int _mtl) {\n    float v0 = 0.276;\n    float v1 = 0.133;\n    float v2 = 0.179;\n    float v3 = 0.080;\n    float v4 = 0.772;\n    \n    float ao = 0.0;\n\tfloat s = 1.0;\n    #define ZERO float(min(iFrame,0)) // non-constant zero\n\tfor (float i = ZERO; i < 5.; ++i)\n\t{\n\t\tfloat off = v0 + v1 * i / 6.;\n\t\tfloat t = map(_n * off + _p, getAoMap(_mtl), iChannel3, \n        false, false).x;\n\t\tao += (off - t) * s;\n\t\ts *= v2;\n\t}\n    \n    ao = mix(1., smoothstep(0., 1., 1. - v3 * 20. * ao), v4);\n    return ao;\n}\n\nbool computeHitParamsFromRaycast(in vec4 _raycast, in vec2 _uv,\n    out vec3 _p, out vec3 _d, out vec3 _n, out int _mtl) {\n    float half_pixel = 1./iResolution.y;\n    \n    CAMERA_SETUP(_uv)\n    _d = d;\n    \n    float iter = MAX_SH_ITER;\n    float far = FAR;\n    bool hitGeom = _raycast.x > T_EPS;\n    \n    if (hitGeom) {\n        _mtl = int(map(o + _raycast.x * d, TRACE_NO_FLOOR, \n            iChannel3, false, true).y);\n            _n = normalize(_raycast.yzw);\n            _p = o + _raycast.x * d;\n    }\n    \n    float tfloor = rayXFloor(o.y, d.y);\n    if (tfloor > 0. && !hitGeom && tfloor < FAR) {\n        _mtl = FLOOR_MTL;\n        _n = vec3(0., 1., 0.);\n        _p = o + tfloor * d;\n        hitGeom = true;\n    }\n    \n    return hitGeom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/(iResolution.y);\n    vec2 muv = (2.*iMouse.xy - iResolution.xy)/(iResolution.y);\n    vec2 ruv = fragCoord/iResolution.xy;\n    float scr_resolution = iResolution.x / iResolution.y;\n\n    vec3 n, p, d;\n    vec4 raycast = texture(iChannel0, ruv);\n    int i_mtl = TRACE_NO_FLAG;\n    vec2 shadow; // entry for each light\n    float ao = 1.; // ambient occlusion\n    bool hitGeom = false;\n    \n#ifdef DOWNSAMPLE_SHADOWS\n    vec2 quad_ruv = ruv * 2.;\n    vec2 quad_uv;\n    if (quad_ruv.x < 1. && quad_ruv.y < 1.) { // lower left quadrant\n        vec4 q_raycast = texture(iChannel0, quad_ruv);\n        quad_ruv.x *= scr_resolution;\n        quad_uv = quad_ruv * 2. - vec2(scr_resolution, 1.);\n        hitGeom = computeHitParamsFromRaycast(q_raycast, quad_uv,\n            p, d, n, i_mtl);\n    }\n#else\n    hitGeom = computeHitParamsFromRaycast(raycast, uv,\n        p, d, n, i_mtl);\n#endif\n           \n    if (hitGeom && dot(p.xz, p.xz) < FLOOR_BOUNDING_CIRCLE_SQR) {\n        shadow = calcShadow(p, i_mtl);\n        ao = (i_mtl == FLOOR_MTL) ? 1. : CalcAO(p, n, i_mtl);\n    }\n    \n#ifdef PACK_CUI_VALUES\n    // Packing is done to reduce compilation time by saving more work\n    // on Buffer D and freeing the Image buffer.\n    \n    // packing closed unit interval to uint. Because we \n    // eventually pass the packed values as floats and precision is\n    // on the lower end, shadow passed first. The shadow values are packed\n    // to 255 bit values and ambient occlusion to 127 bit.\n    PACK_CUI3_TO_UINT(shadow.x, shadow.y, ao);\n    vec4 clr = vec4(float(packed_uint), vec3(0.));\n#else\n    vec4 clr = vec4(ao, shadow.xy, 0.);\n#endif\n    \n    fragColor = clr;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Space at home.\n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define MAX_DISTANCE 1000.\n#define FAR 300.0\n#define MAX_ITER 164.\n#define MAX_SH_ITER 64.\n\n#define CROSS_SECTION_FACTOR 5.\n\n#define T_EPS 0.0001\n#define TS_EPS 0.001\n\n#define N_EPS 0.0001\n#define NS_EPS 0.01\n\n#define RAD_45 0.785398163\n\n#define PI 3.14159265\n#define PI2 6.2831853\n\n#define GEOM_BOUNDING_CIRCLE 75.\n#define GEOM_BOUNDING_CIRCLE_SQR 5625.\n#define GEOM_BOUNDING_SHADOW_CIRCLE 100.\n#define GEOM_BOUNDING_SHADOW_CIRCLE_SQR 10000.\n#define FLOOR_BOUNDING_CIRCLE_SQR 28900.\n#define FLOOR_BOUNDING_CIRCLE 160.\n#define FLOOR_LEVEL -29.5\n\n//#define DEBUG_HIT\n#define DEBUG_CIRCULAR_MOTION\n//#define ANIM_TIME (iMouse.x/6.)\n#define ANIM_TIME iTime\n#define DOWNSAMPLE_SHADOWS\n\n#define ROT2(_alpha) mat2(cos(_alpha), sin(_alpha), -sin(_alpha), cos(_alpha))\n#define Ryz(_alpha) mat4(1., 0., 0., 0., \\\n                         0., cos(_alpha), sin(_alpha), 0., \\\n                         0., -sin(_alpha), cos(_alpha), 0., \\\n                         0., 0., 0., 1.)\n                         \n#define CAMERA_SETUP(_uv) vec3 o = TF3(ORIG_SEQ).xyz;                   \\\n                     vec4 trg = TF3(LOOKAT_SEQ);                   \\\n                     vec3 d = normalize(vec3((_uv + half_pixel)*tan(trg.w), -1.)); \\\n                     d = lookAt(o, d, trg.xyz);\n\n// packing closed unit interval values to uint\n#define PACK_CUI_VALUES\n\n#define PACK_CUI3_TO_UINT(_a, _b, _c)                \\\n        uint packed_uint = uint(_a * 255.);          \\\n        packed_uint += (uint(_b * 255.) << 8);       \\\n        packed_uint += (uint(_c * 127.) << 16);\n                \n#define UNPACK_UINT_TO_CUI3(_packed_val)                   \\\n        uint packed_uint = uint(_packed_val);              \\\n        vec3 unpacked_cui3;                                \\\n        unpacked_cui3.x = float(packed_uint % 256u) / 255.; \\\n        packed_uint /= 256u;                                \\\n        unpacked_cui3.y = float(packed_uint % 256u) / 255.; \\\n        packed_uint /= 256u;                                \\\n        unpacked_cui3.z = float(packed_uint % 128u) / 127.;\n\n#define Rxz(_alpha) mat4(cos(_alpha), 0., sin(_alpha), 0., 0., 1., 0., 0., -sin(_alpha), 0., cos(_alpha), 0., 0., 0., 0., 1.)\n\n\n#define ANIM_T(_t, _e, _p) (smoothstep(_p - _e, _p, _t) - smoothstep(_p, _p + _e, _t))\n#define ANIM_T_CF(_t, _p, _e0, _e1, _cf0, _cf1) (_cf0 * smoothstep(_p - _e0, _p, _t) - _cf1 * smoothstep(_p, _p + _e1, _t))\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ASYM_PULSE_T(_t, _ea, _pa, _eb, _pb) (smoothstep(_pa - _ea, _pa, _t) - smoothstep(_pb, _pb + _eb, _t))\n\n#define ANIM_SEQ 150.\n\n// aspect ratios\n#define WIDE_SCREEN_AR 0.5625\n#define ULTRA_WIDE_SCREEN_AR 0.428571\n#define SUPER_WIDE_SCREEN_AR 0.28125\n#define ASPECT_RATIO WIDE_SCREEN_AR\n\n//\n\n#define TRACE_NO_FLAG 0\n#define TRACE_FLOOR_FLAG 1\n\n#define TRACE_TABLE_FRAME_FLAG 2\n#define TRACE_TABLE_TOP_FLAG 4\n// sum of previous two\n#define TRACE_TABLE_FLAG 6\n\n#define TRACE_CHAIR_BASE_FLAG 8\n#define TRACE_CHAIR_BCK_LEG_FLAG 16\n#define TRACE_CHAIR_FRNT_LEG_FLAG 32\n#define TRACE_CHAIR_BACK_FLAG 64\n#define TRACE_CHAIR_FRAME_FLAG 128\n#define TRACE_CHAIR_CUSHION_FLAG 256\n// sum of previous six\n#define TRACE_CHAIRS_FLAG 504\n\n#define TRACE_LAPTOP_BASE_FLAG 512\n#define TRACE_LAPTOP_SCREEN_FLAG 1024\n// sum of prevoius two\n#define TRACE_LAPTOP_FLAG 1536\n\n#define TRACE_ALL TRACE_FLOOR_FLAG | TRACE_TABLE_FLAG | TRACE_CHAIRS_FLAG | TRACE_LAPTOP_FLAG\n#define TRACE_NO_FLOOR TRACE_TABLE_FLAG | TRACE_CHAIRS_FLAG | TRACE_LAPTOP_FLAG\n#define TRACE_TABLE_LAPTOP TRACE_TABLE_FLAG | TRACE_LAPTOP_FLAG\n#define TRACE_CHAIR_UPPER TRACE_CHAIR_BACK_FLAG | TRACE_CHAIR_FRAME_FLAG | TRACE_CHAIR_BCK_LEG_FLAG\n#define TRACE_CHAIR_UPPER_W_CUSHION TRACE_CHAIR_UPPER | TRACE_CHAIR_CUSHION_FLAG\n\n// colors\n\n#define N_CHAIRS 5\n\n#define DEFAULT_MTL 0\n#define FLOOR_MTL 1\n#define TABLE_FRAME_MTL 2\n#define TABLE_TOP_MTL 3\n#define CHAIR_BASE_MTL 4\n#define CHAIR_BCK_LEG_MTL 5\n#define CHAIR_FRNT_LEG_MTL 6\n#define CHAIR_BACK_MTL 7\n#define CHAIR_FRAME_MTL 8\n#define CHAIR_CUSHION_MTL 9\n#define LAPTOP_BASE_MTL 10\n#define LAPTOP_SCREEN_MTL 11\n\n#define LAPTOP_MTL LAPTOP_BASE_MTL\n\n#define is_metal_mtl(_mtl) (_mtl == CHAIR_FRAME_MTL || _mtl == TABLE_FRAME_MTL)\n\n#define TF0(crd) texelFetch(iChannel0, crd, 0)\n#define TF1(crd) texelFetch(iChannel1, crd, 0)\n#define TF2(crd) texelFetch(iChannel2, crd, 0)\n#define TF3(crd) texelFetch(iChannel3, crd, 0)\n#define TF(ch, crd) texelFetch(ch, crd, 0)\n\n// CONTROL ZONE - CTRL_ZONE first rows\n#define CTRL_ZONE 50\n#define FPS_DATA ivec2(0,0)\n#define RES_DATA ivec2(1,0)\n\n#define CAMERA_SETUP_ROW 3\n#define ORIG_SEQ_ROW 1\n#define ORIG_SEQ ivec2(0, ORIG_SEQ_ROW)\n#define ORIG_SEQ_1 ivec2(1, ORIG_SEQ_ROW)\n#define ORIG_SEQ_2 ivec2(4, ORIG_SEQ_ROW)\n#define ORIG_SEQ_3 ivec2(7, ORIG_SEQ_ROW)\n\n#define LOOKAT_SEQ ivec2(0, 3)\n\n// Lights\n#define N_LIGHTS 2\n#define LIGHT_0 4\n#define LIGHT_1 5\n\n// light position/direction and type (directional/point)\n#define LIGHT_GEO 0\n// rgb, intensity\n#define LIGHT_PROP 1\n\n#define LAPTOP_H_DIMS ivec2(0, 10)\n\n#define LAPTOP_BASE_TRF_0 ivec2(0, 11)\n#define LAPTOP_BASE_TRF_1 ivec2(1, 11)\n#define LAPTOP_BASE_TRF_2 ivec2(2, 11)\n#define LAPTOP_BASE_TRF_3 ivec2(3, 11)\n\n#define LAPTOP_SCRN_TRF_0 ivec2(4, 11)\n#define LAPTOP_SCRN_TRF_1 ivec2(5, 11)\n#define LAPTOP_SCRN_TRF_2 ivec2(6, 11)\n#define LAPTOP_SCRN_TRF_3 ivec2(7, 11)\n\n#define LAPTOP_KEY_ANIM ivec2(0, 12)\n\n#define CHAIR_ROT 13\n\n#define GEOM_SHADOW_MAP 20\n// not used\n#define GEOM_NORM_MAP 21 \n#define GEOM_AO_MAP 22\n\n// global variables\n// global casting direction accessible from 'everywhere'\nvec3 g_dir;\nmat4 lpTrf = mat4(1.);\nmat4 scrTrf = mat4(1.);\nfloat scrRndSide = 1.;\nconst float bvh_margin = 1.;\n\nint getNormMap(in int _mtl) { \n    int mtl = (_mtl >= LAPTOP_MTL && _mtl != LAPTOP_SCREEN_MTL) ? LAPTOP_MTL : _mtl;\n    return (1 << (mtl - 1)); \n}\nmat2 rot2D(in float _a) {\n    return mat2(cos(_a), sin(_a), -sin(_a), cos(_a));\n} \n\nmat3 rotY(in float _a) {\n    return mat3(cos(_a),  0., sin(_a),\n                0.,       1., 0.,\n                -sin(_a), 0., cos(_a));\n}\n\nmat3 rotX(in float _a) {\n    return mat3(1.,       0., 0.,\n                0., cos(_a),  sin(_a),\n                0., -sin(_a), cos(_a));\n}\n\nconst float a1 = 20.;\nconst float a2 = 80.;\nconst float a3 = 107.;\nconst float a4 = 112.;\nconst float a5 = 130.;\nconst float a6 = ANIM_SEQ;\n    \nvec3 getCameraTarget(in float _t) {\n    float atime = _t;\n\n    vec3 target = vec3(0., 5., 0.);\n    float cf;\n    if (atime < a1) {\n        cf = atime / a1;\n        target = mix(target, vec3(11.6, 6.77, 9.13), smoothstep(0.4, 0.6, cf));\n    }\n    else if (atime < a2) {\n        cf = (atime - a1) / (a2 - a1);\n        target = mix(vec3(11.6, 6.77, 9.13), vec3(-7., -11., -36.), \n            smoothstep(0.15, 0.21, cf));\n        target = mix(target, vec3(-21., -3.3, 43.4), smoothstep(0.34, 0.39, cf));\n        vec3 tanchor = vec3(10., 0., 0.);\n        float ta = -cf * PI2 * 8.;\n        tanchor.xz *= ROT2(ta);\n        target = mix(target, vec3(-67., -1., -3.5) + tanchor, smoothstep(0.4, 0.43, cf));\n        \n        target.y = mix(target.y, -30., PULSE_T(cf, 0.03, 0.57, 0.6));\n        target.xz = mix(target.xz, vec2(-16., -49.), smoothstep(0.62, 0.64, cf));\n        target = mix(target, vec3(0., -12., -19.), smoothstep(0.75, 0.8, cf));\n        target = mix(target, vec3(-22.7, -14., -31.8), smoothstep(0.8, 0.83, cf));\n        target = mix(target, vec3(-0., -20., 10.37), smoothstep(0.84, 0.9, cf));\n        target = mix(target, vec3(0., -10., 0.), smoothstep(0.9, 0.95, cf));\n    }\n    else if (atime < a3) {\n        cf = (atime - a2) / (a3 - a2);\n        target = vec3(0., -10., 0.);\n        float circ_targ = PULSE_T(cf, 0.1, 0.2, 0.6);\n        float circ_r = 60.*(cf - 0.2)/0.6;\n        target.xz = mix(target.xz, circ_r * vec2(cos(cf*PI2*4.),sin(cf*PI2*4.)), circ_targ);\n        target.y = target.y + ANIM_T_CF(cf, 0.4, 0.3, 0.3, 30., 10.);\n        target = mix(target, vec3(0., 5., 0.), smoothstep(0.75, 0.85, cf));\n    }\n    else if (atime < a4) {\n        cf = (atime - a3) / (a4 - a3);\n        target = mix(vec3(0., 5., 0.), vec3(12., 8., 7.), smoothstep(0., 1., sqrt(cf)));\n    }\n    else if (atime < a5) {\n        cf = (atime - a4) / (a5 - a4);\n        target = vec3(12., 8., 7.);\n        target.x += cos(cf * PI2) * smoothstep(0., 1., cf);\n        target.z += 0.3*cos(cf * PI * 0.5) * smoothstep(0., 1., cf);\n        target.y += 0.5*sin(cf * PI2 * 0.5) * smoothstep(0., 1., cf);\n    }\n    else if (atime < a6) {\n        cf = (atime - a5) / (a6 - a5);\n        target = vec3(13., 8., 7.);\n    }\n    else { // sequence of stills\n        int sti_time = int(mod(atime, 60.) / 10.);\n        target = mix(target, vec3(0., 5., 0.), float(sti_time == 0));\n        target = mix(target, vec3(-14.7, -12.3, -29.44), float(sti_time == 1));\n        target = mix(target, vec3(13.21, 7., 3.75), float(sti_time == 2));\n        target = mix(target, vec3(-0.3, -28., 25.), float(sti_time == 3));\n        target = mix(target, vec3(20.51, 4., 1.04), float(sti_time == 4));\n        target = mix(target, vec3(37., -22., -42.), float(sti_time == 5));\n    }\n    return target;\n}\n\nvec3 getCameraPosition(in float _t) {\n    float dist = 90.;\n    vec3 p;\n    p.xz = dist * vec2(-1., 0.);\n    p.y = 70.;\n    float cf;\n    float atime = _t;\n\n    vec2 ranchor = vec2(0.);\n    if (_t < a1) {\n        cf = atime / a1;\n        dist = 120. - cf * 40.;\n        p.xz = ROT2(cf * PI2) * vec2(dist, 0.);\n        p.y = 90. - ANIM_T_CF(cf, 0.5, 0.5, 0.45, 50., 30.);\n    }\n    else if (atime < a2) {\n        cf = (atime - a1) / (a2 - a1);\n        ranchor = mix(ranchor, vec2(30., -50.), ANIM_T(cf, 0.2, 0.2));\n        ranchor = mix(ranchor, vec2(200., 70.), ASYM_PULSE_T(cf, 0.2, 0.7, 0.1, 0.71));\n        dist = 80.;\n        dist = mix(dist, 80., ANIM_T(cf, 0.2, 0.2));\n        dist = mix(dist, 120., ANIM_T(cf, 0.1, 0.75));\n        dist = mix(dist, 60., smoothstep(0.75, 0.78, cf));\n        dist = mix(dist, 70., smoothstep(0.78, 0.82, cf));\n        //dist = mix(dist, 30., ANIM_T(cf, 0.05, 0.88));\n        p.xz = ROT2(cf * PI2 * 3.) * (vec2(dist, 0.) - ranchor);\n        p.y = mix(70., 0., smoothstep(0., 0.3, cf));\n        p.y = mix(p.y, -20., smoothstep(0.6, 0.7, cf));\n        p.y = mix(p.y, 5., smoothstep(0.85, 0.9, cf));\n    }\n    else if (atime < a3) {\n        cf = (atime - a2) / (a3 - a2);\n        float rcf = 1. - (1.-cf)*(1.-cf);\n        dist = 70.;\n        dist = mix(dist, 100., smoothstep(0.0, 0.2, cf));\n        dist = mix(dist, 32., smoothstep(0.6, 0.9, cf));\n        ranchor = 10.*vec2(cos(cf*PI2), sin(cf*PI2)) * PULSE_T(rcf, 0.1, 0.2, 0.8);\n        p.xz = ROT2(rcf * PI2 * 2.) * vec2(dist, 0.) - ranchor;\n        p.y = mix(5., 40., smoothstep(0.0, 0.2, cf));\n        //p.y = mix(p.y, sin(cf*PI2*2.)*5., PULSE_T(cf, 0.1, 0.3, 0.7));\n        p.y = mix(p.y, 10., smoothstep(0.8, 0.9, rcf));\n    }\n    else if (atime < a4) {\n        cf = (atime - a3) / (a4 - a3);\n        cf = smoothstep(0., 1., cf);\n        dist = 32.;\n        dist = mix(dist, 24., smoothstep(0.2, 1., cf));\n        p.xz = ROT2(cf * PI2 * 0.2) * dist * vec2(1., 0.);\n        p.y = mix(10., 18., smoothstep(0., 1., cf));\n    }\n    else if (atime < a5) {\n        cf = (atime - a4) / (a5 - a4);\n        dist = 24. - ANIM_T_CF(cf, 0.7, 0.7, 0.3, 14., 10.);\n        p.xz = dist * vec2(0.309017, 0.951057);\n        p.y = mix(18., 24., ANIM_T(cf, 0.5, 0.5));\n    }\n    else if (atime < a6) {\n        cf = (atime - a5) / (a6 - a5);\n        p.xz = 20. * vec2(0.309017, 0.951057);\n        p.xz = mix(p.xz, vec2(-20., 10.951057), smoothstep(0.1, 0.9, cf)); \n        p.y = 18.;\n    }\n    else {\n        int sti_time = int(mod(atime, 60.) / 10.);\n        p = mix(p, vec3(20., 48., 130.), float(sti_time == 0));\n        p = mix(p, vec3(-120., 35., 20.), float(sti_time == 1));\n        p = mix(p, vec3(23.21, 17., 23.75), float(sti_time == 2));\n        p = mix(p, vec3(20., -25., -65.), float(sti_time == 3));\n        p = mix(p, vec3(37.93, 9., -2.), float(sti_time == 4));\n        p = mix(p, vec3(57., -15., -62.), float(sti_time == 5));\n    }\n    \n    return p;\n}\n\n// A lot of basis features were taken from:\n// iq\n// https://iquilezles.org/articles/distfunctions2d\n// https://iquilezles.org/articles/distfunctions/\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smoothstep_c2( float x )\n{\n  return clamp(x*x*x*(x*(x*6.0-15.0)+10.0), 0., 1.);\n}\n\n// smooth\nfloat sdUnionSmooth( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*0.25;\n}\n\n\n// x - radius, y - x length\nfloat sdCylX(in vec3 _p, in vec2 _lr)\n{\n    return max(length(_p.yz) - _lr.x, abs(_p.x) - _lr.y);\n}\n\nfloat sdCapsule( vec2 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsuleZExtrusion(vec3 _p, float _h, float _r, float _d)\n{\n    float gzy = sdCapsule(_p.yz, _h, _r);\n    return max(gzy, abs(_p.x) - _d);\n}\n\n// bounded - not exact\nfloat sdTrapezoid(in vec2 _p, in vec2 _tb, in vec4 _vrl, in vec2 _rl)\n{\n    float fc0 = _p.y - _tb.x;\n    float fc1 = -_p.y - _tb.y;\n    float fc2 = -(dot(_p, normalize(_vrl.xy)) + _rl.x);\n    float fc3 = -(dot(_p, normalize(_vrl.zw)) + _rl.y);\n    \n    return max(max(max(fc0, fc1), fc2), fc3);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(in float _f1, in float _f2, in float _k)\n{\n  float df = _f1 - _f2;\n  return 0.5 * (_f1 + _f2 + sqrt(df * df + _k));\n}\n\n// y - axis cylinder\nfloat sdCylinder(in vec3 _p, in float _r, in float _h) {\n    float rf = length(_p.xz) - _r;\n    return max(rf, abs(_p.y) - _h);\n}\n\n#define sdPlane(_p, _v) dot(_p, _v)\n#define sdCircle(_p, _r) (length(_p) - _r)\n\nbool inBox(in vec2 _uv, in vec4 _box)\n{\n   vec2 v = step(_box.xy, _uv) - step(_box.xy + _box.zw, _uv);\n   return bool(v.x * v.y);\n}\n\nfloat in_box(in vec2 _uv, in vec4 _box)\n{\n   vec2 v = step(_box.xy, _uv) - step(_box.xy + _box.zw, _uv);\n   return (v.x * v.y);\n}\n\n\n#define sdMorph(_a, _b, _f) mix(_a, _b, _f)\n#define sdUnion(_f1, _f2) min(_f1, _f2)\n#define sdIntersect(_f1, _f2) max(_f1, _f2)\n#define isHit(_trace_res, _eps) (step(abs(_trace_res.y), _trace_res.x * _eps))\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxBound(in vec2 p, in vec2 sides)\n{\n    vec2 q = abs(p) - sides;\n    return max(q.x, q.y);\n}\n\n\nfloat sdBoxBound(in vec3 p, in vec3 sides)\n{\n    vec3 q = abs(p) - sides;\n    return max(max(q.x, q.y), q.z);\n}\n\nfloat spiralSdf(in vec2 _uv, in float _b, in float _ths, in float _the )\n{\n    float th = atan(_uv.y, _uv.x);\n    float r = length(_uv);\n    \n    float n = floor((r - th * _b)/(PI2 * _b));\n    \n    float th0 = clamp((PI2 * n + th), _ths, _the);\n    float th1 = clamp((PI2 * (n + 1.) + th), _ths, _the);\n    \n    float r0 = th0 * _b;\n    float r1 = th1 * _b;\n    \n    vec2  p0 = r0 * vec2(cos(th0), sin(th0));\n    vec2  p1 = r1 * vec2(cos(th1), sin(th1));\n    \n    float f = min(dot(_uv - p0, _uv - p0), dot(_uv - p1, _uv - p1));\n    \n    return sqrt(f);\n}\n\nfloat spiralWrapSDF(in vec2 _uv, in float _hx)\n{\n    float b = max(0.36, 0.);\n    float th_end = abs(8.8);\n    \n    vec2 e0 = vec2(_hx, 0.) + b * th_end * vec2(cos(th_end), sin(th_end));  \n    vec2 e1 = vec2(-_hx, 0.) - b * th_end * vec2(cos(th_end), sin(th_end));\n    \n    \n    vec2 st = vec2((abs(_uv.x) - _hx), sign(_uv.x)*_uv.y);\n    float f = spiralSdf(st, b, -0.5, th_end);\n    \n    float f2 = sdSegment(_uv, e0, e1);\n    \n    return min(f, f2);\n}\n\n// returns (distance from center of sections, radius, angle, ID)\nvec4 sdAngularPattern(in vec2 _uv, in float _N, in float _phase)\n{\n  float alpha = _phase + atan(_uv.y, _uv.x);\n  float r = length(_uv);\n  vec2 uvec = vec2(cos(-PI/_N), sin(-PI/_N));\n  alpha = mix(alpha, -PI-(PI-alpha), step(0., alpha));\n  \n  float ialpha = floor((-alpha / PI2) * _N) / _N;\n  float falpha = -mod(abs(alpha), PI2/_N);\n\n  return vec4(0., r, falpha, ialpha);\n}\n\nfloat hash(in float x)\n{\n  return fract(5313.235 * mod(x, 0.75182) * mod(x, 0.1242));\n}\n\nfloat hash(in vec2 st) {\n    return fract(sin(dot(st.xy,\n        vec2(113.9928,1178.243)))\n            * 4358.5475123);\n}\n\nfloat noise(in float s)\n{\n  float i = floor(s);\n  float f = fract(s);\n  \n  return mix(hash(i), hash(i + 1.0), f * f* (3.0 - 2.0 * f));\n}\n\n//\nvec3 lookAt(in vec3 _o, in vec3 _d, in vec3 _t) {\n    vec3 d = normalize(_o - _t);\n    vec3 r = normalize(cross(d, vec3(0., 1., 0.))); // fix if needed\n    vec3 u = normalize(cross(r, d));\n    \n    return mat3(r, u, d) * _d;\n}\n//\n// CHAIR SDF\n\n// half lengths of chair frame w1, w2, depth and height from floor (all in halfs)\nconst vec4 h_ch_frame = vec4(9., 8., 8., 6.75);\n\nfloat frame_base(in vec3 _p) {\n    vec3 fbase_dims = h_ch_frame.xyz + vec3(0.5);\n    float fbase = sdTrapezoid(_p.xz, h_ch_frame.x, h_ch_frame.y, h_ch_frame.z);\n    float fcut = sdTrapezoid(_p.xz, fbase_dims.x, fbase_dims.y, fbase_dims.z);\n    float f = sdBox(vec2(abs(fbase), _p.y), vec2(0.6, 1.25));\n    fcut = length(vec2(abs(fcut), _p.y + 1.)) - 0.15;\n    return sdIntersect(f, -fcut);\n}\n\nfloat front_legs(in vec3 _p) {\n    vec3 op = _p;\n    op = vec3(abs(op.x), op.y, op.z) - \n            vec3(h_ch_frame.x, -1.25, -h_ch_frame.z);\n\n    float fb = sdBox(op, vec3(0.8, 2.25, 0.8));\n    \n    op = vec3(abs(_p.x), _p.y, _p.z) - \n            vec3(h_ch_frame.x - 0.1, -h_ch_frame.w - 1.25, -h_ch_frame.z + 0.1);\n    \n    float h_frmw = 2. * h_ch_frame.w;\n    float ipleg = clamp((_p.y + 2. + h_frmw)/h_frmw, 0., 1.);\n    \n    // morphing coefficient\n    float ipmorph = smoothstep_c2((_p.y + 3.)/2.);\n    \n    // add leg curvature\n    op.xz -= 0.75*vec2(-1., 1.) * sin(ipleg * 6.28);\n    \n    // modify radius from bottom to top\n    float rad = mix(0.4, 1.5, ipleg);\n    float fl = sdCylinder(op, rad, h_ch_frame.w);\n    \n    // plane cuts\n    float fp1 = -op.x - 0.5;\n    float fp2 = op.z - 0.5;\n    fl = max(max(fp1, fp2), fl);\n    \n    // rotate 45 deg\n    float z_offset = mix(0.5, 1.2, ipleg);\n    op.xz = rot2D(RAD_45) * op.xz;\n    op.xy = rot2D(0.075) * op.xy;\n    float fcut = sdCylinder(vec3(op.x - 0.5, op.y + 1., abs(op.z) - z_offset), 0.1, h_ch_frame.w*0.825);\n    \n    float fmix = sdMorph(sdIntersect(0.66*fl, -fcut), fb, ipmorph); // morphing\n    return fmix;\n}\n\nfloat back_legs(in vec3 _p) {\n    vec3 op = _p;\n    \n    // this is the height from the base (y = zero) level to the floor.\n    float h_base = 2.*h_ch_frame.w + 1.25; \n    op = vec3(abs(_p.x), _p.y, _p.z) - \n            vec3(h_ch_frame.y + 0.2, -h_ch_frame.w - 1.25, h_ch_frame.z - 0.1);\n    \n    // one at the bottom of the leg and zero at the top of the leg.\n    float ip_hbase = 1. - clamp(((_p.y + h_base)/(2.*h_ch_frame.w)), 0., 1.);\n    \n    op.xz -= vec2(0.3, 1.7)*ip_hbase*ip_hbase;\n    op.xz *= rot2D((-1.-(ip_hbase))*0.1);\n    \n    float fl = sdBox(op, vec3(0.7, h_ch_frame.w, 0.8));\n    \n    op.y = _p.y;\n    \n    float fl2 = sdBox(op + vec3(0., 1., 0.), vec3(0.7, 1., 0.8));\n    \n    // upper extension of the legs\n    op = vec3(abs(_p.x), _p.y, _p.z) - \n            vec3(h_ch_frame.y + 0.2, 0., h_ch_frame.z - 0.1);\n    \n    op.xz *= rot2D((-1.-(ip_hbase))*0.1);\n    op.yz *= rot2D(0.11*smoothstep_c2(op.y*0.25));\n    float ful = sdBox(vec2(op.x, \n        sdUnionSmooth(sdCircle(op.yz - vec2(20., 0.5), 0.2), \n                sdSegment(op.yz, vec2(0.), vec2(20., 0.)), 0.5)), vec2(0.7, 0.8));\n    \n    return sdUnion(sdUnion(fl, fl2), ful);\n}\n\nfloat cushion(in vec3 _p) {\n    vec3 op = vec3(_p.x, _p.y - 2.0, _p.z + 1.);\n    float ip_cr = clamp((op.y + 1.25) * 0.25, 0., 1.);\n    float r = mix(0.35, 0.9, ip_cr);\n    \n    // cushion size coefficient\n    float cf = 0.78 + 0.15*ANIM_T_CF(ip_cr, 0.2, 0.2, 0.85, 1., 3.);\n    \n    // slight lateral variations\n    // Only on highest LOD.\n    op.x += 0.1*sin(op.z) + 0.025*(sin(op.z*2. + 11.345));\n    op.z += 0.05*cos(_p.x)*cos(_p.x*0.25);\n    \n    // \n    vec3 params = h_ch_frame.xyz;\n    params -= r;\n    params *= (cf);\n    float fbase = sdTrapezoid(op.xz, params.x, params.y, params.z);\n    \n    // h_factor can be 1 on low LOD.\n    float h_factor = cos(op.z*0.1);\n    vec2 q = max(vec2(0.5*fbase - r, abs(op.y) - h_factor*h_factor + r*0.5), vec2(0.));\n    float f = length(q) - r;\n    return f;\n}\n\n// back seat base coordinates\nvec4 back_coordinates(const vec3 _p) {\n    vec3 op = vec3(_p.x, _p.y - 5.0, _p.z + 15.);\n    op.yz *= rot2D(0.11*smoothstep_c2((op.y+4.)*0.25));\n    \n    // The seat back geometry is placed on a cylinder, and the\n    // fourth parameter is the distance to this cylinder.\n    return vec4(op, sdCircle(op.xz, 24.6));\n}\n\nfloat back(const vec3 _p) {\n    vec4 op = back_coordinates(_p);\n    \n    // bottom back panel\n    // the last parameter is the depth,height of the bottom panel\n    float f_lateral2 = sdCircle(vec2(op.x, op.z - 0.3), 24.6);\n    float f = sdBox(vec2(op.w, op.y), vec2(0.4, 1.)) - 0.1;\n    \n    op.y = _p.y - 19.25;\n    float rc = 0.5;\n    float cw = 0.7 * step(0., op.y) * smoothstep(0., 1., (5. - abs(op.x))/5.);\n    float fup = sdBox(vec2(op.w, op.y), vec2(0.1, 0.75 + cw)) - rc;\n    fup = sdUnionSmooth(fup, sdCircle(vec2(f_lateral2, op.y-cw-0.7), 0.5), 0.1);\n    f = sdUnion(f, fup);\n    \n    // second parameter is the cut vector.\n    float f_cut = sdPlane(vec2(abs(op.x), op.z), (vec2(3., -1.)));\n    f = sdIntersect(f, f_cut);\n    \n    return f;\n}\n\n// \nfloat back_sketch(in vec3 _p, in bool _normal) {\n    vec4 op = back_coordinates(_p);\n    \n    // center coordinates of chair back.\n    vec3 chp = vec3(_p.x, _p.y - 10.92, _p.z - 10.);\n    vec2 quart_p = abs(chp.yx) - vec2(3.025, 4.33);\n    quart_p *= rot2D(4.8);\n    float f_sketch = spiralSdf(quart_p.yx, 0.575, 1.2, 8.2);\n    f_sketch = sdUnion(f_sketch, abs(sdCircle(vec2(abs(chp.x) - 7., chp.y), 7.)));\n    f_sketch = sdUnion(f_sketch, abs(sdCircle(vec2(abs(chp.x) - 7.4, chp.y), 5.)));\n    \n    float f_cap = sdBox(vec2(op.w, chp.y), vec2(0.1, 7.));\n    float f = sdIntersect(f_cap, sdBox(vec2(f_sketch, chp.z), vec2(0.15, 8.)));\n    \n    // there is a repetition here, since the next two lines are\n    // identical to the cut in back\n    float f_cut = sdPlane(vec2(abs(op.x), op.z), (vec2(3., -1.)));\n    f = sdIntersect(f, f_cut);\n    \n    return f;\n}\n\nvec2 chair_sdf(in vec3 _p, int _trace_flags, in bool _normal, in bool _mtl) {\n    float f;\n    float fbs = bool(_trace_flags & TRACE_CHAIR_BASE_FLAG) ? frame_base(_p) : FAR;\n    float ffl = bool(_trace_flags & TRACE_CHAIR_FRNT_LEG_FLAG) ? front_legs(_p) : FAR;\n    float fbl = bool(_trace_flags & TRACE_CHAIR_BCK_LEG_FLAG) ? back_legs(_p) : FAR;\n    float fc = bool(_trace_flags & TRACE_CHAIR_CUSHION_FLAG) ? cushion(_p) : FAR;\n    float fb = bool(_trace_flags & TRACE_CHAIR_BACK_FLAG) ? back(_p) : FAR;\n    float fsk = bool(_trace_flags & TRACE_CHAIR_FRAME_FLAG) ? back_sketch(_p, _normal) : FAR;\n    \n    f = sdUnion(sdUnion(ffl, fbs), fbl);\n    f = sdUnion(f, fc);\n    f = sdUnion(f, fb);\n    f = sdUnion(f, fsk);\n    \n    // request for material\n    float m = 0.;\n    if (_mtl) {\n        m += float(CHAIR_BASE_MTL)*float(f == fbs);\n        m += float(CHAIR_BCK_LEG_MTL)*float(f == fbl);\n        m += float(CHAIR_FRNT_LEG_MTL)*float(f == ffl);\n        m += float(CHAIR_CUSHION_MTL)*float(f == fc);\n        m += float(CHAIR_BACK_MTL)*float(f == fb);\n        m += float(CHAIR_FRAME_MTL)*float(f == fsk);\n    }\n    \n    return vec2(f, m);\n}\n\n// laptop\n//\nfloat laptop_screen(in vec3 _op, in vec4 _dims, bool _norm)\n{\n    vec3 opc = (scrTrf * vec4(_op, 1.)).xyz;\n\n    // screen\n    float r = 0.5; // side rounds\n    float gs = sdBox(opc.xz, _dims.xz - vec2(r)) - r;\n    \n    // on normal calculation this radius must be constant for all the samples.\n    \n    mix(step(0., opc.y), scrRndSide, float(_norm));\n    r = 0.075 * scrRndSide; // top rounds\n    vec2 q = max(vec2(gs + r, abs(opc.y) - 0.5 * 0.25 + r), vec2(0.));\n    gs = length(q) - r;\n    return gs;\n}\n\nvec2 laptop(in vec3 _p, in vec4 _dims, int _trace_flags, bool _norm, bool _mtl)\n{\n    vec4 dims = _dims;\n    // --- origin location of the geometry\n    vec3 op = _p;\n    vec3 opc; // helper coordinates\n    // the transforms for laptop and screen must be initialized\n    // earlier.\n    op = (lpTrf * vec4(op, 1.)).xyz;\n    \n    //float dgeom = length(_p - targetOrigin) - 5.;\n    \n    float g = FAR;\n    float gpc = MAX_DISTANCE;\n    float gl = MAX_DISTANCE;\n    // bottom (keboard) plane\n    if (bool(_trace_flags & TRACE_LAPTOP_BASE_FLAG)) {\n        float r = 0.5;\n        g = sdBox(op, dims.xyz - vec3(r, 0., r));\n        g -= r;\n        g = max(g, op.y - 0.5 * r) - 0.01;\n\n        // front cut - no need on low LOD.\n        vec3 opc = op - vec3(0., dims.y, dims.z + r);\n        opc.yz = opc.yz * 0.707 + vec2(opc.z, -opc.y) * 0.707;    \n        float gc = sdBox(opc, vec3(1., 0.25, 0.25)) - 0.25;\n\n        g = max(g, -gc);\n\n        // back cut\n        opc = op - vec3(0., dims.y, -dims.z);\n        gc = sdBox(opc, vec3(11.*0.5, 0.5 * 1.5, 0.25));\n        g = max(g, -gc);\n\n        // pins don't draw on low LOD\n        opc = vec3(abs(op.x), op.yz) - vec3(dims.x - 1.5, 0.0, -dims.z + 0.25);\n        g = min(g, sdCylX(opc, vec2(0.125, 0.8)));\n\n        // jacks should be filtered according to sides;\n        vec3 right = transpose(lpTrf)[0].xyz;\n        float side = sign(dot(right, g_dir));\n        // left side jacks - no need on low LOD or shadows.\n        \n        // don't model if we're looking the other way\n        if (_mtl || side < 0.)\n        {\n            // power\n            gpc = sdCapsuleZExtrusion(op - vec3(dims.x, 0., -dims.z + 1.075), 0.75, 0.12, .05);\n\n            // usb-c\n            opc = op - vec3(dims.x, 0., -dims.z + 2.7);\n            gl = sdCapsuleZExtrusion(vec3(opc.xy, abs(opc.z)) - (vec3(0., 0., 0.175)), 0.33, 0.1, 0.262);\n            // headsets/mic\n            opc = op - vec3(dims.x, 0., -dims.z + 3.7);\n            gl = min(gl, max(length(opc.zy) - 0.137, abs(opc.x) - 0.3));\n        //\n        }\n\n        // right side jacks - no need on low LOD or shadows.\n        if (_mtl || side > 0.) \n        {\n            opc = op - vec3(-dims.x, 0., -dims.z + 2.675);\n\n            gl = min(gl, sdCapsuleZExtrusion(opc, 1., 0.1, 0.262));\n\n            opc = op - vec3(-dims.x, 0., -dims.z + 1.9);\n            gl = min(gl, sdCapsuleZExtrusion(opc, 0.33, 0.1, 0.262));\n\n            opc = op - vec3(-dims.x, 0.05,  -dims.z + 1.25);\n            float gct = max(sdBox(opc.zy, vec2(0.3, 0.05)), abs(opc.x) - 0.3) - 0.075;\n            opc = op - vec3(-dims.x, -0.1, -dims.z + 1.25);\n            gct = min(gct, \n                max(sdTrapezoid(opc.zy, vec2(0.075), vec4(1., 1., -1., 1.), vec2(0.21)), abs(opc.x) - 0.3));\n            gl = min(gct, gl);\n        }\n    }\n    // screen\n\n    // screen rotation\n    opc = (scrTrf * vec4(op, 1.)).xyz;\n\n    float gs = bool(_trace_flags & TRACE_LAPTOP_SCREEN_FLAG) ? laptop_screen(op, dims, _norm) : FAR;\n    \n    // connecting panel -- attached to screen\n    vec3 opp = opc - vec3(0., -0.25, -dims.z + 0.125);\n    \n    mat4 tmtx = mat4(1.);\n    mat4 opTrf = mat4(1.);\n    \n    opTrf = Ryz(-0.1);\n    opTrf *= tmtx;\n    opTrf = tmtx * opTrf;\n    \n    opp = (opTrf * vec4(opp, 1.)).xyz;\n    \n    float gp = sdBox(opp, vec3(dims.x - 1.5, 0.25, 0.05));\n    float gps = sdUnionSmooth(gs, gp, 0.1);\n    float gf = max(max(min(gps, g), -gl), -gpc);\n    \n    float mtl = 0.;\n    \n    if (_mtl)\n    {\n        // Works here, but won't work for organics (where smooth min and max are used)\n        // In the latter case maybe steps with epsilons will work.\n        mtl += float(LAPTOP_BASE_MTL) * float(g == gf);\n        mtl += float(LAPTOP_SCREEN_MTL) * float(gs == gf);\n        mtl += float(LAPTOP_MTL + 2) * float(gp == gf);\n        mtl += float(LAPTOP_MTL + 3) * float(-gl == gf);\n        mtl += float(LAPTOP_MTL + 4) * float(-gpc == gf);\n    }\n    \n    return vec2(gf, mtl);\n}\n\nvec2 sdLaptop(in vec3 _p, in sampler2D _s, in int _trace_flags, in bool _normal, in bool _mtl) {\n    vec3 op = _p;\n    vec4 dims = TF(_s, LAPTOP_H_DIMS);\n    \n    //prepareLaptopTransform(lpTrf, scrTrf);\n    lpTrf = mat4(TF(_s, LAPTOP_BASE_TRF_0), TF(_s, LAPTOP_BASE_TRF_1), \n                 TF(_s, LAPTOP_BASE_TRF_2), TF(_s, LAPTOP_BASE_TRF_3));\n                 \n    scrTrf = mat4(TF(_s, LAPTOP_SCRN_TRF_0), TF(_s, LAPTOP_SCRN_TRF_1),\n                  TF(_s, LAPTOP_SCRN_TRF_2), TF(_s, LAPTOP_SCRN_TRF_3));\n               \n    // bounding volume\n    vec4 opb = vec4(op, 1.);\n    vec3 bvh_size = dims.xyz + vec3(bvh_margin);\n    opb = lpTrf * opb;\n    float f_bound = -MAX_DISTANCE;\n    if (!_normal && !_mtl) {\n        f_bound = sdBox(opb.xyz, bvh_size);\n        f_bound = sdUnion(f_bound,\n            sdBox((scrTrf * opb).xyz, bvh_size));\n    }\n    \n    vec2 flp = laptop(op, TF(_s, LAPTOP_H_DIMS), _trace_flags, _normal, _mtl);\n    \n    return flp;\n}\n//\n\n// TABLE\nfloat hLowBeam(in vec2 _uv, in float _r, in float _h, in float _v)\n{\n    float f = abs(length(_uv) - _r);\n    vec2 v2 = normalize(vec2(-_v, _r - _h));\n    \n    // clamp the arc\n    float fup = _uv.x;\n    float fv = dot(vec2(-v2.y, v2.x), _uv);\n    \n    f = max(max(fup, f), fv);\n    \n    return f;\n}\n// _param.x -- table radius, _param.y -- table height\nfloat lowTableProfileSDF(in vec2 _uv, in vec3 _param, in bool _norm)\n{\n    float v = 0.75 * _param.x;\n    float h = _param.y * 0.2;\n    float r = (h * h + v * v) / (2. * h);\n    \n    float fh = hLowBeam(_uv - vec2(0., -_param.x - r + h), r, h, v);\n    float fv = hLowBeam(_uv.yx - vec2(-_param.x - r + h, 0.).yx, r, h, v);\n    //float fv = vLowBeam(_uv - vec2(-_param.y - r + h, 0.), r, h, v);\n    \n    //float fb = sdSegment(_uv, vec2(0., 0.), vec2(-_param.x, 0.));\n    float fb = sdBoxBound(_uv + vec2(_param.x * 0.5, 0.), vec2(_param.x*0.46, 0.));\n    \n    vec2 p = vec2(-v, -_param.x);\n\n    vec2 bc = 0.5 * (p + p.yx);\n    float fc = abs(length(_uv - bc) - 0.4975*(length(p - p.yx) + 0.));\n    fc = max(fc, dot(_uv - bc, normalize(vec2(1., 1.4))));\n    fc = max(fc, dot(_uv - bc, normalize(vec2(1.4, 1.))));\n    \n    float ang = 1.414;\n    vec2 ruv = mat2(cos(ang), sin(ang), -sin(ang), cos(ang)) * (_uv + vec2(16.5, 15.0));\n    // very expensive. Think about an LOD.\n    float fsp = spiralWrapSDF(ruv, 4.3);\n    \n    float f = smin(fc, min(min(fh, fv), fb), 0.1);\n    f = min(f, fsp);\n    \n    f = abs(f) - _param.z;\n       \n    //f = fv;\n    return f;\n}\n\nfloat tableTop(in vec3 _p)\n{\n    vec3 op = _p - vec3(0., 1.5, 0.);\n\n    float fa = sdBoxBound(vec3(abs(op.x), op.y - 0.5, (op.z)), vec3(26., .5, 4.));\n    float fb = sdBoxBound(vec3(op.x, op.y - 0.5, abs(op.z)) - vec3(0., 0., 15.4), vec3(4., .5, 10.8));\n    \n    op -= vec3(0., 1., 0.);\n    float op_xz_len = length(op.xz);\n    vec2 q = vec2(op_xz_len - 30., op.y);\n    q = abs(q) - vec2(0.5, 1.);\n    \n    op -= vec3(0., 1., 0.);\n    float dxz = op_xz_len - 31.;\n    float r = 0.25 * sign(op.y + 0.5);\n    float f = length(max(vec2(dxz + r, abs(op.y) - .5 + r), vec2(0.))) - r;\n      \n    return min(min(fa, fb), min(f, max(q.x, q.y)));\n}\n\nfloat tableMidBottom(in vec3 _p, in float _h, in float _th, in float _tv)\n{\n    vec3 op = _p - vec3(0., -_h + 1., 0.);\n    float len_op_xz = length(op.xz);\n    // bound cylinder\n    vec2 q = vec2(len_op_xz - 1., abs(op.y) -_h);\n    float fc = max(q.x, q.y);\n    \n    // limited repitition of central ellipsoid.\n    float sh = _h * 0.75;\n    vec3 qp = op;\n    qp.y = op.y - sh*clamp(round(op.y/sh),-1.,1.);\n    float fe = sdEllipsoid(qp, vec3(2., 1.0, 2.));\n    \n    \n    float fcyl = sdCappedCylinder(vec3(op.x, abs(abs(op.y) - _h*0.35) - _h*0.25, op.z), 1., 1.5);\n    \n    // Torus\n    vec2  qt = vec2(len_op_xz - 1.5, abs(abs(op.y) - _h*0.35) - _h*0.2);\n    float ftor = length(qt) - 0.25;\n    fcyl = smax(fcyl, -ftor, 0.3);\n    \n    // Torus 2\n    vec2 qt2 = vec2(len_op_xz - 1.1, abs(op.y) - 1.75);\n    float ftor2 = length(qt2) - 0.2;\n    fcyl = smin(fcyl, ftor2, 0.1);\n    \n    fe = smin(fcyl, fe, 0.1);\n    \n    // legs\n    vec3 lop = op;\n    lop.y -= 0.25;\n    lop.xz *= mat2(cos(PI*0.25), sin(PI*0.25), -sin(PI*0.25), cos(PI*0.25));\n    lop.xz = abs(lop.xz); \n    lop -= vec3(_tv * 0.62, -_th * 0.695, _tv * 0.62);\n    float fleg = sdEllipsoid(lop, vec3(2.5, 1.5, 2.5));\n    fc = min(fleg, fc);\n    \n    return min(fc, fe);\n}\n\nfloat tableFrame(in vec3 _p, in bool _norm) {\n    vec3 op = _p - vec3(0., -0.0, 0.);\n    op.x = -abs(op.x);\n    op.z = -abs(op.z);\n    \n    // the min/max is to apply the sdf to both z and x simultaneously\n    // and thus save a rather heavy call.\n    float dxy = lowTableProfileSDF(vec2(min(op.x, op.z), op.y), vec3(25., 27., 0.4), _norm);\n    //float dxz = lowTableProfileSDF(op.zy, vec3(25., 27., 0.4), _norm);\n    float d = max((dxy) - 0.2, (abs(max(op.z, op.x)) - 0.6));\n    \n    // Because the xz space is separated into 4 quad-regions, we fix the step\n    // (instead of fixing the SDF) so that we won't cross regions by much.\n    // We don't need to use maxStep.\n    float maxStep = 0.7 * (min(abs(_p.x), abs(_p.z)) + 1.);\n    //d = min(d, max((dxz) - 0.2, (abs(op.x) - 0.6)));\n    d = min(maxStep, d);\n \n    // the parameter should be fixed.\n    float dmid = tableMidBottom(_p, 27. * 0.8 * 0.5, 27., 25.);\n    \n    return min(dmid, d);\n}\nvec2 table(in vec3 _p, in int _trace_flags, in bool _norm, in bool _mtl)\n{\n    vec3 op = _p;\n    \n    float dframe = bool(_trace_flags & TRACE_TABLE_FRAME_FLAG) ? tableFrame(_p, _norm) : FAR;\n    float dtop = bool(_trace_flags & TRACE_TABLE_TOP_FLAG) ? tableTop(_p) : FAR;\n    float d = min(dtop, dframe);\n    \n    float fmtl = 0.;\n    \n    if (_mtl)\n    {\n        fmtl += float(d == dtop) * float(TABLE_TOP_MTL);\n        fmtl += float(d != dtop) * float(TABLE_FRAME_MTL);\n    }\n    \n    return vec2(d, fmtl);\n}\n\nvec2 sdfTable(in vec3 _p, in int _trace_flags, in bool _norm, in bool _mtl)\n{\n    // bounding volume\n    float f_bound = (!_norm && !_mtl) ? \n        sdCylinder(_p - vec3(0., -12., 0.), 32., 18.) : -FAR;\n    \n    return (f_bound > T_EPS) ? vec2(f_bound + 0.5, TABLE_TOP_MTL) \n            : table(_p, _trace_flags, _norm, _mtl);\n}\n\n// END TABLE\n\n//\n// CHAIR SDF\n\n// chair\n\nvec2 chairs(in vec3 _p, in sampler2D _ch, int _trace_flags, in bool _normal, in bool _mtl) {\n    const float n_legs = float(N_CHAIRS);\n    vec4 fAng = sdAngularPattern(_p.xz, n_legs, 0.);\n    int chId = int(fAng.w*n_legs);\n    \n    \n    vec2 trp = fAng.y*vec2(cos(fAng.z), sin(fAng.z));\n    float d_hash = 20. * hash(fAng.w + 14.);\n    float r_hash = hash(fAng.w + 20.);\n    vec2 loc = (40. + d_hash)*vec2(cos(-PI/n_legs), sin(-PI/n_legs));\n    \n    vec3 op = vec3(trp.x, _p.y, trp.y) - vec3(loc.x, -14.55, loc.y);\n    \n    // length to section.\n    // this can be calculated more precisely if we have direction\n    // but on the other hand, it works always, while analytic intersection\n    // would work only for the closest.\n    vec2 v0 = vec2(1., 0.);\n    vec2 v1 = vec2(cos(PI2/n_legs), sin(PI2/n_legs));\n    float d0 = length(_p.x * v0.y - _p.y * v0.x);\n    float d1 = length(_p.x * v1.y - _p.y * v1.x);\n    \n    // Analytic intersection //\n    // not used because it is slower (and the approximate, distance based\n    // solution doesn't seem to produce any additional artifacts);\n    // Keeping here for completenes.\n    float fchId = float(chId);\n    vec2 vc0 = vec2(cos(-fchId * PI2/n_legs), sin(-fchId * PI2/n_legs));\n    vec2 vc1 = vec2(cos(-(fchId + 1.) * PI2/n_legs), \n                    sin(-(fchId + 1.) * PI2/n_legs));\n                    \n    vec2 vn0 = normalize(vec2(-vc0.y/vc0.x, 1.));\n    vec2 vn1 = normalize(vec2(-vc1.y/vc1.x, 1.));\n    \n    float t0 = -dot(_p.xz, vn0) / dot(g_dir.xz, vn0);\n    float t1 = -dot(_p.xz, vn1) / dot(g_dir.xz, vn1);\n    float at = min(mix(t0, MAX_DISTANCE, step(t0, 0.)),\n                   mix(t1, MAX_DISTANCE, step(t1, 0.)));\n    //\n    \n    // chair rotation\n    float rotAng = TF(_ch, ivec2(chId/4, CHAIR_ROT))[chId % 4];\n    op.xz *= rot2D(rotAng);\n    \n    // chair bounding volume\n    bool trace_pass = !_normal && !_mtl;\n    float f_bound = -FAR;\n    f_bound = trace_pass ? \n        sdBox(op - vec3(0., -h_ch_frame.w, -2.), vec3(h_ch_frame.x + 3., h_ch_frame.w + 5., h_ch_frame.y + 1.)) : -FAR;\n    f_bound = trace_pass ? sdUnion(f_bound, sdBox(op - vec3(0., 0., h_ch_frame.y + 1.), vec3(h_ch_frame.x + 1., 23., 4.))) : -FAR;\n    \n    vec2 f_chair = (f_bound > 0.01) ? vec2(f_bound + 0.5, DEFAULT_MTL) : chair_sdf(op, _trace_flags, _normal, _mtl);\n\n    // the cross section factor is a safe margin distance for crossing\n    // patterned boundary\n    \n    float cross_section_factor = sdUnion(d0, d1) + CROSS_SECTION_FACTOR;\n    //float cross_section_factor = at + 1.;\n    f_chair.x = sdUnion(f_chair.x, cross_section_factor);\n    return f_chair;\n}\n\nvec2 sdFloor(in vec3 _p) {\n    return vec2(_p.y - (FLOOR_LEVEL), float(FLOOR_MTL));\n}\n\nfloat rayXFloor(in float _oy, in float _dy) {\n    if (_dy > T_EPS)\n        return FAR;\n    return (FLOOR_LEVEL - _oy) / _dy;\n}\n\nvec2 map(in vec3 _p, int _trace_flags, in sampler2D _ch, in bool _normal, in bool _mtl)\n{\n   int trace_flags = _trace_flags;\n   vec2 ft = bool(trace_flags & TRACE_TABLE_FLAG) ? sdfTable(_p, _trace_flags, _normal, _mtl) : vec2(FAR, 0.); \n   vec2 fch = bool(trace_flags & TRACE_CHAIRS_FLAG) ? chairs(_p, _ch, _trace_flags, _normal, _mtl) : vec2(FAR, 0.);\n   //vec2 ffl = bool(trace_flags & TRACE_FLOOR_FLAG) ? sdFloor(_p) : vec2(FAR, 0.);\n   vec2 flp = bool(trace_flags & TRACE_LAPTOP_FLAG) ? sdLaptop(_p, _ch, _trace_flags, _normal, _mtl) : vec2(FAR, 0.);\n   \n   float f;\n   f = fch.x;\n   f = sdUnion(f, ft.x);\n   //f = sdUnion(f, ffl.x);\n   f = sdUnion(f, flp.x);\n   \n   vec2 rf = vec2(f, 0.);\n   \n   if (_mtl)\n   {\n       rf.y += float(f == ft.x) * ft.y;\n       rf.y += float(f == fch.x) * fch.y;\n       //rf.y += float(f == ffl.x) * ffl.y;\n       rf.y += float(f == flp.x) * flp.y;\n   }\n   \n   return rf;\n}\n\nvec2 trace(in vec3 _o, in vec3 _d, int _trace_flags, \n    in sampler2D _ch, const float _iter, const float _far, const float _eps) {\n    float t = 0.;\n    float mint = 10.;\n    vec2 res = vec2(10.);\n    g_dir = _d;\n    int trace_flags = _trace_flags;\n    for (float fi = 0.; fi < _iter; fi++) {\n        vec3 p = _o + _d * t;\n\n        mint = map(p, _trace_flags, _ch, false, false).x;\n        \n        if (abs(mint) < t * _eps || t > _far || p.y < FLOOR_LEVEL)\n            break;\n        if (dot(normalize(p.xz), _d.xz) > 0. \n            && dot(p.xz, p.xz) > GEOM_BOUNDING_CIRCLE_SQR)\n            break;\n        \n        t += mint;\n    }\n    \n    return vec2(t, mint);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\n    Space at home. \n    Copyright © 2024 Leonid Zaides\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   \n\n    Buffer D - Reflection rays\n             - input: Buffer B (hit objects).\n             - output: trace t and normal.\n             \n    Buffer C here is a pass through buffer and only here because\n    we can't bind more than 4 buffers for the final image.\n*/\n\nfloat getReflectionHit(in vec3 _p, in vec3 _d, in vec3 _n, in int _mtl, \n    in float _scr_res, out float _rfl_mtl) {\n\n    vec3 rfl_dir = normalize(reflect(_d, _n));\n    int rfl_trace_flag = TRACE_NO_FLAG;\n    \n    float rfar = 12.;\n    if (_mtl == FLOOR_MTL) {\n        rfar = 40.;\n        rfl_trace_flag = TRACE_TABLE_FLAG | TRACE_CHAIRS_FLAG;\n    }\n    else if ((_mtl == TABLE_TOP_MTL && _n.y > 0.9) || _mtl >= LAPTOP_MTL) {\n        rfl_trace_flag = TRACE_LAPTOP_FLAG;\n    }\n    if (_mtl == LAPTOP_BASE_MTL && _n.y > 0.75)\n    {\n        rfl_dir = vec3(0., 1., 0.); // emissive light from screen.\n        rfl_dir.xz = 0.25*(0.5 - vec2(hash(_p.x), hash(_p.z)));\n        rfl_dir = normalize(rfl_dir);\n    }\n    \n    //\n    const float TR_EPS = T_EPS * 10.;\n    rfar = min(rfar / max(dot(rfl_dir, _n), 0.001), FAR);\n    vec2 rfl_trace = trace(_p + TR_EPS * rfl_dir,\n                    rfl_dir, rfl_trace_flag, iChannel3,\n                    64., rfar, TR_EPS);\n                    \n    float trace_t = 0.;\n    _rfl_mtl = float(DEFAULT_MTL);\n    \n    if (bool(isHit(rfl_trace, TR_EPS))) {\n         trace_t = rfl_trace.x;\n         vec3 rp = _p + (trace_t + T_EPS) * rfl_dir;\n         _rfl_mtl = (map(rp, rfl_trace_flag, iChannel3, false, true).y);\n    }\n    \n    return trace_t;\n}\n\nbool computeHitParamsFromRaycast(in vec4 _raycast, in vec2 _uv,\n    out vec3 _p, out vec3 _d, out vec3 _n, out int _mtl) {\n    float half_pixel = 1./iResolution.y;\n    \n    CAMERA_SETUP(_uv)\n    _d = d;\n    \n    float iter = MAX_SH_ITER;\n    float far = FAR;\n    bool hitGeom = _raycast.x > T_EPS;\n    \n    if (hitGeom) {\n        _mtl = int(map(o + _raycast.x * d, TRACE_NO_FLOOR, \n            iChannel3, false, true).y);\n            _n = normalize(_raycast.yzw);\n            _p = o + _raycast.x * d;\n    }\n    \n    float tfloor = rayXFloor(o.y, d.y);\n    if (tfloor > 0. && !hitGeom && tfloor < FAR) {\n        _mtl = FLOOR_MTL;\n        _n = vec3(0., 1., 0.);\n        _p = o + tfloor * d;\n        hitGeom = true;\n    }\n    \n    return hitGeom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/(iResolution.y);\n    vec2 ruv = fragCoord/iResolution.xy;\n    float scr_resolution = iResolution.x / iResolution.y;\n\n    vec3 n, p, d;\n    vec4 raycast = texture(iChannel0, ruv);\n    vec4 sec_cast = TF1(ivec2(fragCoord)); // pass through\n    int i_mtl = TRACE_NO_FLAG;\n    float rfl_trace_t = 0.;\n    bool hitGeom = false;\n    float rfl_mtl;\n    \n    hitGeom = computeHitParamsFromRaycast(raycast, uv,\n        p, d, n, i_mtl);\n\n    if (hitGeom && dot(p.xz, p.xz) < FLOOR_BOUNDING_CIRCLE_SQR) {\n        rfl_trace_t = getReflectionHit(p, d, n, i_mtl, scr_resolution, rfl_mtl);\n    }\n\n#ifdef PACK_CUI_VALUES\n    vec4 clr = vec4(sec_cast.x, float(i_mtl), rfl_mtl, rfl_trace_t);\n#else\n    vec4 clr = vec4(sec_cast.xyz, rfl_trace_t);\n#endif\n\n    fragColor = clr;\n}","name":"Buffer D","description":"","type":"buffer"}]}