{"ver":"0.1","info":{"id":"wtXGDB","date":"1557466170","viewed":234,"name":"Newton-Raphson fractal on sphere","username":"tpfto","description":"Newton-Raphson fractal for the polynomial z^3 - 1 embedded on the [url=https://en.wikipedia.org/wiki/Riemann_sphere]Riemann sphere[/url].","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","math","sphere","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Newton-Raphson fractal of z^3 - 1 embedded on the Riemann sphere\n\n// Newton-Raphson routines from https://www.shadertoy.com/view/wllGRB\n// sphere rendering forked from https://www.shadertoy.com/view/MssGRl by asalga\n\n// some constants\n#define PI 3.14159265359\n\n// range of the display\n#define SCALE 8.0 \n\n// from Fabrice Neyret, \n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n#define cis(a) vec2( cos(a), sin(a) )\n\n// modified DLMF coloring, from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// exponentiation using binary powering\nvec2 cpow( in vec2 z, in int n )\n{\n    if (n == 0) return vec2(1.0, 0.0);\n    if (n == 1) return z;\n    \n    if (n < 0) z = cinv(z);\n    n = abs(n);\n    \n    vec2 w = vec2(1.0, 0.0);\n    \n    for(int k = 0; k < 11; k++) { // should cover up to n == 1000\n        \n        if ((n & 1) == 1) w = cmul(w, z);\n\n        z = cmul(z, z);        \n        n >>= 1;\n\n        if (n < 2) break;\n    }\n        \n    return cmul(z, w);\n}\n\n// Newton-Raphson fractal for z^n - 1\nvec3 NewtonFractal(int n, vec2 z) {\n    \n    vec2 ld = vec2(0.0);\n    float k = 0.0;\n    \n    for(int i = 0; i < 20; i++) {\n        ld = cdiv(cpow(z, n) - vec2(1.0, 0.0), float(n) * cpow(z, n - 1));\n        if (dot(ld, ld) < 0.001) break;\n        z = z - ld;\n        k += 1.0;\n    }\n    \n    // multiplier highlights the positions of the roots\n    return pow((k + 0.16)/20.0, 0.18) * smooth_dlmf(0.3 + 0.5 * atan(z.y, z.x)/PI);\n\n}\n\n// sphere normal\n\nvec3 getNormal(in vec2 c, in float r, in vec2 point)\n{\n\treturn mix(vec3(0.0, 0.0, 1.0), normalize(vec3(point - c, 0.0)), length(point - c)/r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv *= SCALE;\n    float r = 3.0;\n\t\n\tif( length(uv) < r)\n    {\n\t\tvec3 sphereNormal = vec3(getNormal(vec2(0.0), r, uv));\n\t\tvec3 dirLight = normalize(vec3(0.0, 0.0, 1.0));\n\t\tvec3 col = normalize(vec3(1.0)) * dot(sphereNormal, dirLight);\n\t\t\n\t\tfloat xa = sphereNormal.x, ya = sphereNormal.y;\n        float s = sqrt((1.0 - ya) * (1.0 + ya)), sx = sqrt((s - xa) * (s + xa));\n\n        // Riemann sphere variable\n        vec2 zz = sqrt((1.0 + ya)/(1.0 - ya)) * normalize(vec2(xa, sx));\n        // animate the variable, anticlockwise rotation\n        zz = cmul(zz, cis(0.1 * PI * iTime));\n\t\t\n\t\tfragColor = vec4(0.2 + 3.0 * col * NewtonFractal(3, zz), 1.0);\n\n\t} else {\n\n\t\tfragColor = vec4(0.16, 0.14, 0.13, 1.0);\n\n\t}\n}","name":"Image","description":"","type":"image"}]}