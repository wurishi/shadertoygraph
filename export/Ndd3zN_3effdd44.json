{"ver":"0.1","info":{"id":"Ndd3zN","date":"1629314449","viewed":144,"name":"Luminary","username":"DrNoob","description":"Animated reproduction of \"Luminary\" by Ben Kovach:\nhttps://bendotk.com/#/luminary/","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","grid","circle","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage Ã  Ben Kovach 2 (\"Luminary\", 2021)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Animated reproduction of \"Luminary\" by Ben Kovach:\n// https://bendotk.com/#/luminary/\n//\n// Technical note: I didn't find a good solution for analytical\n// anti-aliasing so this piece does the unsatisfactory multipass\n// approach instead.\n\n// Constants\nconst int AA = 2; // Anti aliasing passes = AA^2\nconst int NCOLORS = 5;\nconst int NLAYERS = NCOLORS - 1;\nconst int GRIDSIZE = 9;\nconst vec2 GRID = vec2(GRIDSIZE);\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// SDF for a circle\nfloat sdCircle(in vec2 p, in vec2 c, in float r) {\n    return length(p - c) - r;\n}\n\n// Circles arranged in a grid\n// Returns the distance to a circle and its ID\nvec2 circleLayer(in vec2 p) {\n    p *= GRID;\n    vec2 uv = fract(p);\n    vec2 id = floor(p);\n\n    float d = sdCircle(uv, vec2(0.5), 0.5);\n    return (d < 0.0) ?\n        vec2(d, 1.0 + id.x + GRID.x * id.y) :\n        vec2(d, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 result = vec3(0.0);\n\n    // Anti-aliasing loop\n    for (int j = 0; j < AA; ++j) {\n    for (int i = 0; i < AA; ++i) {\n        // Screen coordinates\n        vec2 off = vec2(i,j) / float(AA);\n        vec2 st = (fragCoord.xy + off) / iResolution.xy;\n        st.x *= iResolution.x / iResolution.y;\n    \n        // Circle layer with specific offset\n        vec2 layers[NLAYERS];\n        layers[0] = circleLayer(st);\n        layers[1] = circleLayer(st + vec2(0.5, 0.0));\n        layers[2] = circleLayer(st + vec2(0.0, 0.5));\n        layers[3] = circleLayer(st + vec2(0.5));\n\n        // Principal color per layer\n        vec3 colors[NCOLORS];\n        colors[0] = vec3(251, 246, 223) / 255.0; // beige\n        colors[1] = vec3(247, 210,  73) / 255.0; // yellow\n        colors[2] = vec3(153, 164, 137) / 255.0; // green\n        colors[3] = vec3( 60,  62,  58) / 255.0; // brown\n        colors[4] = vec3( 19,  54, 131) / 255.0; // blue\n\n        // Time\n        float t = 0.5 * iTime;\n\n        // Bias the noise towards the right\n        float f = st.x;\n\n        // Noise value per pixel per layer\n        float noise[NCOLORS];\n        noise[0] = 1.0;\n        noise[1] = f * vnoise(1.0 * st + t);\n        noise[2] = f * vnoise(2.0 * st + t + 1.0);\n        noise[3] = f * vnoise(3.0 * st + t - 1.0);\n        noise[4] = f * vnoise(4.0 * st + t + 1.0);\n\n        // Combine the IDs to form one ID that represents a circle fragment\n        int id = int(layers[0].y) +\n                 int(layers[1].y) * GRIDSIZE +\n                 int(layers[2].y) * GRIDSIZE*GRIDSIZE +\n                 int(layers[3].y) * GRIDSIZE*GRIDSIZE*GRIDSIZE;\n\n        // Hash for the combined ID\n        float h = hash(float(id));\n\n        // Mix colors of all layers per circle fragment\n        vec3 col = colors[0];\n        for (int k = 1; k < NCOLORS; ++k) {\n            float w = h * step(h, noise[k]);\n            col = mix(col, colors[k], w);\n        }\n\n        // Accumulate result color\n        result += col;\n    }\n    }\n    result /= float(AA * AA);\n    \n    // Contrast stretching\n    result = pow(result, vec3(1.2));\n    \n    // Final color\n    fragColor = vec4(result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}