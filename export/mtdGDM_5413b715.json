{"ver":"0.1","info":{"id":"mtdGDM","date":"1682545742","viewed":104,"name":"Animated Lappronov Fractal Shade","username":"goooo","description":"Animated Lappronov Fractal Shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["animatedlappronovfractalshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Declare that the shader will use high precision floating-point numbers.\n// High precision is crucial for mathematical operations in shaders, as it\n// ensures accurate results for small or large numbers, preventing artifacts.\nprecision highp float;\n\n// Define constants to control the appearance and behavior of the Lappronov fractal.\n// These constants act like global variables, making it easier to adjust parameters.\n#define ANIMATION_SPEED_FACTOR 0.05\n#define FRACTAL_ITERATIONS 30\n#define FRACTAL_SEQUENCE_LENGTH 9\n\n// Declare an array of integers to store the sequence of steps for generating the Lappronov fractal.\n// This array, called the \"fractal sequence,\" defines the structure and complexity of the fractal.\nint fractalSequence[] = int[FRACTAL_SEQUENCE_LENGTH](0, 0, 1, 0, 0, 0, 1, 1, 1);\n\n// Define the \"computeColor\" function, which takes a 2D point \"pixelCoordinate\" as input\n// and returns a 3D color as output. This function calculates the color of each pixel\n// based on the properties and structure of the Lappronov fractal.\nvec3 computeColor(vec2 pixelCoordinate) {\n    // Initialize variables used in the function.\n    float currentTime = iTime * ANIMATION_SPEED_FACTOR; // Animate the fractal based on elapsed time.\n    float weights[20];  // Array of weights affecting the fractal's shape and appearance.\n    float x = 0.5;      // Variable used in the computation of the fractal.\n    float height = 0.0; // Stores the final height value for the current point \"pixelCoordinate\".\n\n    // Calculate the weights based on the current time.\n    // The weights determine the shape and appearance of the fractal.\n    // The weights are calculated using a sine function, which creates a smooth, periodic oscillation.\n    for (int i = 0; i < 20; i++) {\n        weights[i] = .97 + .028 * sin(float(i) + 4.001 + 0.76 * currentTime);\n    }\n\n    // Compute the Lappronov fractal using nested loops that update \"x\" and \"height\"\n    // based on the fractal sequence stored in the \"fractalSequence\" array.\n    // The nested loops allow the algorithm to explore different combinations of\n    // weights and sequence values, constructing the intricate fractal pattern.\n    for (int iteration = 0; iteration < FRACTAL_ITERATIONS; iteration++) {\n        for (int step = 0; step < FRACTAL_SEQUENCE_LENGTH; ++step) {\n            x = weights[step] * pixelCoordinate[fractalSequence[step]] * x * (1.0 - x);\n            height += log2(abs(weights[step] * pixelCoordinate[fractalSequence[step]] * (1.0 - 2.0 * x)));\n        }\n    }\n\n    // Normalize the height value by dividing it by the product of the constants\n    // \"FRACTAL_ITERATIONS\" and \"FRACTAL_SEQUENCE_LENGTH\". This ensures the resulting\n    // height value lies within a consistent range, regardless of the input parameters.\n    height /= float(FRACTAL_ITERATIONS) * float(FRACTAL_SEQUENCE_LENGTH);\n\n    // Compute the color shift based on the current time. This color shift is\n    // used to create an animated gradient effect in the fractal, making it more visually engaging.\n    vec3 colorShift = vec3(.8, .55, .00330) + currentTime * 0.74;\n\n    // Calculate the first color component using the cosine function, which creates a smooth, periodic oscillation.\n    // The input of the cosine function is a combination of the color shift and the absolute value of the height.\n    vec3 color1 = cos((colorShift + 2.5 * abs(height)) * 3.14159265) * 0.5 + 0.5;\n\n    // Calculate the second color component using the sine function, which also creates a smooth, periodic oscillation.\n    // The input of the sine function is a combination of a constant color offset, the absolute value of the height, and the current time.\n    vec3 color2 = vec3(0.5) + 0.5 * sin(vec3(0.3, 0.33, 0.3) + 2.5 * abs(height) + currentTime * 0.5);\n\n    // Blend the two colors \"color1\" and \"color2\" based on the height value.\n    // If the height is negative, mix the colors according to a power function, which creates a smooth gradient effect.\n    // Otherwise, use a solid black color (vec3(0.0)), resulting in regions of darkness within the fractal.\n    return (height < 0.0) ? mix(color1, color2, pow(abs(height), .625)) : vec3(0.0);\n}\n\n// Define the mainImage function that takes an input 2D coordinate \"pixelCoordinate\" and outputs a color \"finalColor\".\n// This function is the entry point of the shader and will be called for each pixel on the screen.\nvoid mainImage(out vec4 finalColor, in vec2 pixelCoordinate) {\n    // Calculate the color of the current pixel by calling the function \"computeColor\" with a normalized coordinate based on the resolution.\n    // The coordinate is scaled by a factor of 3.0 and translated by 1.0 to fit the fractal properly on the screen.\n    finalColor = vec4(computeColor(3.0 + (1.0 * pixelCoordinate.xy / iResolution.xy)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}