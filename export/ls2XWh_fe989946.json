{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float SPHERE_DISTANCE = 12.0;\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// distance from pos to the closest sphere's outline.\nfloat sphereMap( in vec3 pos ) {\n    vec3 actualPos = mod(pos, SPHERE_DISTANCE);\n    float spherePos = SPHERE_DISTANCE/2.0;// + 2.0 * cos((floor(pos.z / SPHERE_DISTANCE) + 1.0) * iTime / 4.0);\n    float radius = (1.0 +cos(iTime + pos.x / 60.0));\n    return length(actualPos - vec3(spherePos)) - radius;\n}\n\nfloat floorMap( in vec3 pos ) {\n    return pos.z + 10.0;\n}\n\nfloat map( in vec3 pos ) {\n    return min(sphereMap(pos), floorMap(pos));\n    // return sphereMap(pos);\n}\n\nvec3 normal( in vec3 pos, in float t) {\n    float e = 0.001 * t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 camPos( float t ) {\n    /*return vec3(0.3 * cos(t * 0.17),\n                -40.0 + 0.4 * sin(t * 0.4),\n                -12.0 + 1.9 * cos(t * 0.23)\n                );*/\n    float angle = iMouse.x / iResolution.x * 6.2831;\n    mat3 rotMatrix = rotationMatrix( vec3(0, 0.0, 1.0), angle);\n    return rotMatrix * vec3(60.0, 20.0, 0.0);\n}\n\nbool raycast( in vec3 rO, in vec3 rD, out float t ) {\n    bool hit = false;\n    for(int i = 0; i < 100; i++) {\n        float dist = map(rO + t * rD);\n        if(dist < 0.0) { // move outward in the normal's direction\n            vec3 norm = normal(rO+t*rD, t);\n            \n        }\n        if(dist < 0.01) {\n            hit = true;\n            break;\n        }\n        t += max(0.1, dist);\n    }\n    \n\treturn true;\n}\n\nfloat accumulateShadowFactor( in vec3 rO, in vec3 rD ) {\n    float strongestShadow = 0.0;\n    float t = 2.01 + 6.0;\n    for(int i = 0; i < 100; i++) {\n        float dist = map(rO + t*rD);\n        if(dist < 0.01) {\n            strongestShadow = max(strongestShadow, 100.0 / t);\n            break;\n        }\n        strongestShadow = max(strongestShadow, (1.0 / dist) / t);\n        t += max(0.1, dist);\n    }\n    return strongestShadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fovX = radians(60.0),\n          fovY = fovX * iResolution.y / iResolution.x;\n\tvec2 xy = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    vec3 camPosition = camPos(iTime);\n    vec3 camTarget = vec3(0.0, 0.0, iMouse.y / iResolution.y * 250.0 - 125.0);\n    vec3 up = vec3(0.0, .0, 1.0);\n    \n    vec3 camDirection = normalize(camTarget - camPosition),\n         camRight = cross(camDirection, up),\n    \t camUp = cross(camRight, camDirection);\n    \n    vec3 rO = camPosition;\n    \n    float angleX = -mix(0.0, fovX, xy.x);\n    float angleY = -mix(0.0, fovY, xy.y);\n    mat3 rotAroundUp = rotationMatrix(camUp, angleX);\n    // rotate camDirection to the correct X angle\n    vec3 rD = rotAroundUp * camDirection;\n    vec3 rotatedCamRight = rotAroundUp * camRight;\n    mat3 rotAroundRight = rotationMatrix(rotatedCamRight, angleY);\n    rD = rotAroundRight * rD;\n    \n    float t = 0.0;\n\tbool hit = raycast( rO, rD, t);\n    \n    vec3 dif1Dir = normalize(vec3(1.0, -1.0, 1.0));\n    vec3 ambientLight = vec3(0.2, 0.17, 0.14);\n    \n    vec3 fogColor = vec3(0.38, 0.40, 0.45);\n    float fogFactor = exp(-t / 200.0);\n    \n    vec3 col = vec3(0.0);\n    \n    if( hit ) {\n        vec3 norm = normal( rO + t*rD, t );\n        float dif1Comp = clamp(dot(dif1Dir, norm), 0.0, 1.0);\n        float shadowFactor = 0.0; //accumulateShadowFactor( rO + t*rD, dif1Dir);\n        \n    \tcol = ambientLight;\n        col += vec3(0.7, 0.75, 0.79) * dif1Comp * (1.0 - shadowFactor);\n        col = mix(col, fogColor, 1.0 - fogFactor);\n        \n        // col = vec3(clamp(abs(map(rO+t*rD)) * 100.0, 0.0, 1.0));\n    } else {\n        col = fogColor;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2XWh","date":"1413152571","viewed":167,"name":"Infinisphere","username":"hellochar","description":"First sketch, playing around with raycasting. Couldn't figure out how to do shadows correctly though :(","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","spheres"],"hasliked":0,"parentid":"","parentname":""}}