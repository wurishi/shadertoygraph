{"ver":"0.1","info":{"id":"3dVBRG","date":"1607664991","viewed":45,"name":"Pathtracer Test","username":"JesseF","description":"Pathtracer fun. Thanks to @Atrix256 for basically everything.\nhttps://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EXPOSURE 0.7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    col *= EXPOSURE;\n    col = ACESFilm(col);\n    col = LinearToSRGB(col);\n    fragColor = vec4(col, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAYS_PER_PIXEL 1\n#define BOUNCES_PER_RAY 8\n#define MIN_HIT_DISTANCE 0.001\n#define MAX_HIT_DISTANCE 10000.0\n#define FOV 75.0\n#define PI 3.14159265359f\n#define TAU PI*2.0\n\nuint wang_hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat randomUnilateral(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 randomUnitVector(inout uint state) {\n    float z = randomUnilateral(state) * 2.0f - 1.0f;\n    float a = randomUnilateral(state) * TAU;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct RayHitInfo {\n    float dist;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float specular;\n    vec3 specularColor;\n};\n\nfloat scalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool rayWithQuad(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = scalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = scalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > MIN_HIT_DISTANCE && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool rayWithSphere(in vec3 rayPos, in vec3 rayDir, in vec4 sphere, inout RayHitInfo info)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > MIN_HIT_DISTANCE && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid map(vec3 ro, vec3 rd, inout RayHitInfo info) {\n\n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 22.0f);\n        vec3 B = vec3( 12.6f, -12.6f, 22.0f);\n        vec3 C = vec3( 12.6f,  12.6f, 22.0f);\n        vec3 D = vec3(-12.6f,  12.6f, 22.0f);\n        if (rayWithQuad(ro, rd, info, A, B, C, D))\n        {\n            info.albedo = vec3(0.7f, 0.7f, 0.7f);\n            info.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}\n    \n    //floor\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 22.0f);\n        vec3 B = vec3( 12.6f, -12.6f, 22.0f);\n        vec3 C = vec3( 12.6f, -12.6f, 15.0f);\n        vec3 D = vec3(-12.6f, -12.6f, 15.0f);\n        if (rayWithQuad(ro, rd, info, A, B, C, D))\n        {\n            info.albedo = vec3(0.7f, 0.7f, 0.7f);\n            info.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.6f, 22.0f);\n        vec3 B = vec3( 12.6f, 12.6f, 22.0f);\n        vec3 C = vec3( 12.6f, 12.6f, 15.0f);\n        vec3 D = vec3(-12.6f, 12.6f, 15.0f);\n        if (rayWithQuad(ro, rd, info, A, B, C, D))\n        {\n            info.albedo = vec3(0.7f, 0.7f, 0.7f);\n            info.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}\n    // right wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 22.0f);\n        vec3 B = vec3(-12.6f, -12.6f, 15.0f);\n        vec3 C = vec3(-12.6f,  12.6f, 15.0f);\n        vec3 D = vec3(-12.6f,  12.6f, 22.0f);\n        if (rayWithQuad(ro, rd, info, A, B, C, D))\n        {\n            info.albedo = vec3(0.1f, 0.8f, 0.1f);\n            info.emissive = vec3(0.0f, 0.0f, 0.0f);\n\n        }\n\t}\n    // left wall\n    {\n        vec3 A = vec3( 12.6f, -12.6f, 22.0f);\n        vec3 B = vec3( 12.6f, -12.6f, 15.0f);\n        vec3 C = vec3( 12.6f,  12.6f, 15.0f);\n        vec3 D = vec3( 12.6f,  12.6f, 22.0f);\n        if (rayWithQuad(ro, rd, info, A, B, C, D))\n        {\n            info.albedo = vec3(0.8f, 0.1f, 0.1f);\n            info.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}    \n    \n\tif(rayWithSphere(ro, rd, vec4(0.0, -9.0, 20.0, 3.0), info)) {\n        info.albedo =   vec3(0.9, 0.9, 0.5);\n        info.emissive = vec3(0.0, 0.0, 0.0);\n        info.specular = 0.5;\n        info.specularColor = vec3(0.1, 0.1, 0.6);\n        info.roughness = 0.2;\n    }\n    \n    if(rayWithSphere(ro, rd, vec4(9.0, -9.0, 20.0, 3.0), info)) {\n        info.albedo =   vec3(0.5, 0.9, 0.9);\n        info.emissive = vec3(0.0, 0.0, 0.0);\n        info.specular = 0.9;\n        info.specularColor = info.albedo;\n        info.roughness = 0.1;\n    }\n    \n    if(rayWithSphere(ro, rd, vec4(-9.0, -9.0, 20.0, 3.0), info)) {\n        info.albedo =   vec3(0.9, 0.5, 0.9);\n        info.emissive = vec3(0.0, 0.0, 0.0);\n        info.specular = 0.1;\n        info.specularColor = info.albedo;\n        info.roughness = 0.9;\n    }\n    \n    vec3 startP = vec3(-5.0, -4.0, 20.0);\n    float fudge = 2.5;\n    for(int i = 0; i < 5; i++) {\n        for(int j = 0; j < 5; j++) {\n            if(rayWithSphere(ro, rd, vec4(startP + vec3(float(i)*fudge, float(j)*fudge, 0), 1.0), info)) {\n                info.albedo =   vec3(0.5, 0.5, 0.5);\n                info.emissive = vec3(0.0, 0.0, 0.0);\n                \n                float iFudge = float(i)/5.0;\n                float jFudge = float(j)/5.0;\n                info.specular = jFudge;\n                info.specularColor = vec3(iFudge, jFudge, 0.0);\n                info.roughness = iFudge;\n                \n            }\n        }\n    }\n    \n    \n    if(rayWithSphere(ro, rd, vec4(0.0, 9.0, 16.0, 2.0), info)) {\n        info.albedo =   vec3(0.0, 0.0, 0.0);\n        info.emissive = vec3(0.9, 0.5, 0.1) * 10.0f;\n    }\n}\n\nvec3 raycast(vec3 ro, vec3 rd, uint rngState, mat3 xForm) {\n\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n    vec3 throughput = vec3(1.0, 1.0, 1.0);\n    \n    vec3 rayP = ro;\n    vec3 rayDir = rd;\n    \n\tfor(int bounceIndex = 0; bounceIndex < BOUNCES_PER_RAY; bounceIndex++) {\n    \tRayHitInfo info;\n    \tinfo.dist = MAX_HIT_DISTANCE;\n        \n        map(rayP, rayDir, info);\n        \n        if(info.dist == MAX_HIT_DISTANCE) {\n            result += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput;\n            break;\n        }\n        \n        vec3 diffuseNormal = normalize(xForm * (info.normal + randomUnitVector(rngState)));\n        vec3 specularNormal = reflect(rayDir, info.normal);\n        specularNormal = normalize(mix(specularNormal, diffuseNormal, info.roughness));\n        \n        float useSpecular = (randomUnilateral(rngState) < info.specular) ? 1.0 : 0.0;\n        \n        rayP = (rayP + rayDir * info.dist) + info.normal * 0.01;\n        rayDir = mix(diffuseNormal, specularNormal, useSpecular);        \n\n        result += info.emissive * throughput;\n        throughput *= mix(info.albedo, info.specularColor, useSpecular);   \n    }\n    return result;\n}\n\nmat3 camera(vec3 camP, vec3 camDir, float rot) {\n    vec3 zAxis = normalize(camDir - camP);\n    vec3 up = normalize(vec3(sin(rot), cos(rot), 0.0));\n    vec3 xAxis = normalize(cross(zAxis, up));\n    vec3 yAxis = normalize(cross(xAxis, zAxis));\n    return mat3(xAxis, yAxis, zAxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(randomUnilateral(rngState)) - 0.5;\n    vec2 uv = 2.0*((fragCoord + jitter)/iResolution.xy) - 1.0;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    float cameraDistance = 1.0f / tan(FOV * 0.5f * PI / 180.0f); \n    \n#if 0\n    vec3 camP = vec3(0.0f, 0.0f, 0.0f);\n    vec3 camDir = vec3(0.0f, 0.0f, 4.0f);\n    mat3 xForm = camera(camP, camDir, 0.0);\n    vec3 rayOrigin = camP;\n    vec3 rayDir = xForm * normalize(vec3(uv, cameraDistance));\n#else\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayTarget = vec3(uv, cameraDistance);\n    vec3 rayDir = normalize(rayTarget - rayOrigin);\n    mat3 xForm = mat3(1.0);\n#endif\n    \n    vec3 col = vec3(0.0);\n    for(int rayIndex = 0; rayIndex < RAYS_PER_PIXEL; rayIndex++) {\n        col += raycast(rayOrigin, rayDir, rngState, xForm) / float(RAYS_PER_PIXEL);\n    }\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col = mix(lastFrameColor, col, 1.0 / float(iFrame+1));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}","name":"Common","description":"","type":"common"}]}