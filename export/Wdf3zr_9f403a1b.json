{"ver":"0.1","info":{"id":"Wdf3zr","date":"1545628502","viewed":188,"name":"Oofus Ultimatus","username":"scratch13764","description":"Some hash issues but other than that its working a lot better.\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["path","bigboi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = pow(texture(iChannel0,uv)*8., vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Roblox face shader, super simple.\n//A few circle SDFs with modifications\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec4 col = vec4(.95,.95,.01,0);\n    \n    if(\n    length(vec2(abs(uv.x)-.2,(uv.y/1.1)-.2)) <= .07 \n        || \n        length(vec2(max(0.,abs(uv.x)-.3),uv.y+.3-(uv.x*uv.x*.4))) <= .065\n        ) col *= .01;\n\n    fragColor = vec4(col.rgb, .5);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Main image\n#define Lim 10.\n#define MaxSteps 1000.\n#define Epsilon .001\n#define Pi 3.1415926535\nconst vec4 Light = vec4(.5,-.4,.3,0.1); //Position of light\n\nvec2 opU (vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\nvec3 CubeDiffuse(vec3 p, float s) //Crude way of diffusing reflections, but my PC can't compile a spherical one which would work better.\n{\n    vec3 n;\n    float a = p.x*3.135+p.y*2.2482+p.z*1.2346;\n        n = vec3(\n            fract(sin((iTime*174.2523+a)*207.23252)*2351.27935),\n            fract(sin((iTime*382.2466+a)*942.23757)*1824.13215),\n            fract(sin((iTime*128.9892+a)*268.25307)*9871.29084)\n            ) - .5;\n    n *= s*.5;\n    return n;\n}\n\nfloat SphereSDF (vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat SquareSDF (vec2 p, float a)\n{\n    return min(max(abs(p.x),abs(p.y))-a,.0)\n                          +\n           length(max(abs(p)-a,0.));\n}\n\nfloat Map(vec3 p)\n{\n    float m = 1000.;\n    m = min(m, SquareSDF(vec2(length(p.xy), p.z),.2)-.1);\n    m = min(m, -abs(p.z) +.8);\n    m = min(m, -abs(p.x) +.8);\n    m = min(m, -abs(p.y+.3) +1.2);\n    m = min(m, SphereSDF(p-Light.xyz,Light.w));\n    return m;\n}\n\nvec3 MarchRay (vec3 ro, vec3 rs)\n{\n    float t = .01;\n    for (float i = 0.; i <= MaxSteps; i++)\n    {\n        float m = Map(ro + (rs*t));\n        if(m <= Epsilon) break;\n        t += m;\n    }\n    return ro + (rs*t);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float E = Epsilon * 10.;\n    return normalize(vec3(\n        Map(vec3(p.x + E,p.y,p.z)) - Map(vec3(p.x - E,p.y,p.z)),\n        Map(vec3(p.x,p.y + E,p.z)) - Map(vec3(p.x,p.y - E,p.z)),\n        Map(vec3(p.x,p.y,p.z + E)) - Map(vec3(p.x,p.y,p.z - E))\n        ));\n}\n\nvec4 OofTexture (vec3 p)\n{\n    return texture(iChannel1, p.xz/.6+.5);\n}\n\nvec4 GetColor (vec3 p)\n{\n    if (SphereSDF(vec3(p-Light.xyz),Light.w) <= .01) return vec4(1.);\n    else if (SquareSDF(vec2(length(p.xy), p.z),.2)-.2 <= .05) return OofTexture(p);\n    else return vec4(0.8,0.8,0.8,45.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 TextureCoords = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    float Pxw = 1./iResolution.y;\n    vec2 Offset = vec2(\n    fract(sin(uv.x*531.1231+uv.y*2252.121+iTime*1221.59)*197.53)-.5,\n    fract(sin(uv.x*241.83451+uv.y*1531.124+iTime*1525.15)*122.81)-.5\n    )*Pxw *1.5;\n    //Conviniently, multipass makes it super easy to add antialaising - in this case I'm using random samples\n    uv += Offset;\n    vec4 OldColor = texture(iChannel0, TextureCoords);\n    vec4 NewColor = vec4(0);\n    //Fetching data from the previous frame and initializing coordinate variables\n    vec3 CamPos = vec3(0,-1.5,0);\n    vec2 CamDir = vec2(0,0);\n    vec2 RayDir = uv+CamDir;\n    vec3 RayStep = vec3(vec2(sin(RayDir.x),cos(RayDir.x))*cos(RayDir.y),sin(RayDir.y));\n    vec3 RayHit;\n    vec4 HitColor;\n    //Initializing ray\n    \n    RayHit = CamPos;\n    NewColor = vec4(1.);\n    \n    int r;\n    for(r = 0; r <= 10; r++)\n    {\n        RayHit = MarchRay(RayHit, RayStep);\n        HitColor =  GetColor(RayHit);\n        NewColor *= HitColor;\n        if (length(HitColor.rgb) >= 1.7) break;\n        RayStep = normalize(reflect(RayStep, GetNormal(RayHit)) + CubeDiffuse(RayHit, HitColor.a));\n    }\n    \n    if (r == 11) NewColor *= 0.;\n    \n    OldColor *= float(iFrame);\n    fragColor = (OldColor+NewColor)/float(iFrame+1);\n    //fragColor = NewColor;\n}","name":"Buffer B","description":"","type":"buffer"}]}