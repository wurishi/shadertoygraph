{"ver":"0.1","info":{"id":"csVXWm","date":"1681675550","viewed":62,"name":"balls attempt 2","username":"77Tigers","description":"balls","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BALLS 6\n\nstruct sphere {\n    vec3 pos;\n    float r;\n    vec3 bounce_col;\n    vec3 out_col;\n};\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nsphere FAR_AWAY = sphere(vec3(0.0,0.0,10000.0), 0.0, vec3(0.0), vec3(0.0));\nsphere[BALLS] balls;\n\nbool collides( ray r, sphere s ) {\n    vec3 v = s.pos - r.pos;\n    float d = dot(r.dir, v);\n    return d > 0.0 && d*d + s.r*s.r - dot(v,v) >= 0.0;\n}\n\nray bounce( ray r, sphere s ) {\n    vec3 v = s.pos - r.pos;\n    float d = dot(r.dir, v);\n    float discr = d*d + s.r*s.r - dot(v,v);\n    float dist = dot(r.dir, v) - sqrt(discr);\n    vec3 pos = r.pos + dist * r.dir;\n    vec3 dir = reflect(r.dir, normalize(s.pos - pos));\n    return ray(pos + 0.01*dir, dir);\n}\n\nvoid getClosest( ray r, out bool hit, out sphere closest ) {\n    hit = false;\n    float best_dist = 10000.0;\n    closest = FAR_AWAY;\n    for(int i=0; i<BALLS; i++) {\n        sphere s = balls[i];\n        vec3 v = s.pos - r.pos;\n        float d = dot(r.dir, v);\n        float discr = d*d + s.r*s.r - dot(v,v);\n        if (d > 0.0 && discr >= 0.0) {\n            float dist = dot(r.dir, v) - sqrt(discr);\n            if (dist <= best_dist) {\n                closest = s;\n                best_dist = dist;\n                hit = true;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 camera = vec3(0.0, 0.0, -5.0);//2.0*cos(iTime*0.56));\n    vec2 uv = 2.0*(fragCoord - vec2(iResolution.x/2.0, iResolution.y/2.0))/iResolution.y;\n    \n    ray r = ray(camera, normalize(vec3(uv, 1.0)));\n    vec3 strength = vec3(1.0);\n    vec3 colour = vec3(0.0);\n    \n    balls = sphere[BALLS](\n        sphere(vec3(0.0,-25.0, 5.0), 20.0, vec3(1.0), vec3(0.9)),\n        sphere(vec3(30.0, 0.0, 25.0), 20.0, vec3(0.6), vec3(0.0)),\n        sphere(vec3(-30.0, 0.0, 25.0), 20.0, vec3(0.05), vec3(0.0)),\n        sphere(vec3(0.0,25.0, 5.0), 20.0, vec3(0.9), vec3(0.0)),\n        sphere(vec3(1.5, cos(iTime), 5.0), 2.0, vec3(0.5, 0.4, 0.6), vec3(0.0)),\n        sphere(vec3(-1.5, 0.0, 5.0 + sin(iTime)), 1.0, vec3(0.4, 0.6, 0.5), vec3(0.0))\n    );\n\n    for (int i=0; i < 10; i++) {\n        bool hit;\n        sphere closest;\n        getClosest(r, hit, closest);\n        if (hit) {\n            r = bounce(r, closest);\n            colour += strength * closest.out_col * dot(r.dir, normalize(r.pos - closest.pos));\n            strength *= closest.bounce_col;\n        } else {\n            colour += strength * vec3(0.6 - 0.4*r.dir.y,0.7,0.8);\n            break;\n        }\n    }\n    // gamma correction\n    colour = sqrt(colour);\n    \n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}