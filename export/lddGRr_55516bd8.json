{"ver":"0.1","info":{"id":"lddGRr","date":"1541712887","viewed":157,"name":"Drop Drop","username":"TinyTexel","description":"a shader","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi / 2.0;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi2 = 1.0 / Pi2;\nconst float RcpPi05 = 1.0 / Pi05;\n\nfloat SDFtoMask(float sdf)\n{\n   return sdf / length(vec2(dFdx(sdf), dFdy(sdf))); \n}\n\nconst float hc0 = 12.9898;\nconst float hc1 = 27.3972;\nconst float hc2 = 33.7311;\n\n\nfloat Hash(float v)\n{\n    return fract(sin(v) * 43758.5453);\n}\n\nfloat Hash(vec2 v)\n{\n\treturn Hash(v.y + v.x * hc0);\n}\n\nfloat Hash(vec3 v)\n{\n\treturn Hash(v.y + v.x * hc0 + v.z * hc2);\n}\n\nfloat HashV2(vec3 v)\n{\n\treturn Hash(v.z + v.x * hc0 + v.y * hc1);\n}\n\nvec2 Hash2(vec2 v)\n{\n\treturn vec2(Hash(v.y + v.x * hc0), Hash(v.x + v.y * hc2));\n}\n\nvec2 Hash2(vec3 v)\n{\n\treturn vec2(Hash(v.y + v.x * hc0 + v.z * hc2), \n                Hash(v.z + v.x * hc1 + v.y * hc0));\n}\n\nvec3 Hash3(vec3 v)\n{\n\treturn vec3(Hash(v.y + v.x * hc0 + v.z * hc2), \n                Hash(v.x + v.y * hc2 + v.z * hc1),\n                Hash(v.z + v.x * hc1 + v.y * hc0));\n}\n\nfloat saturate(float v){return clamp(v, 0.0, 1.0);}\nvec2 saturate(vec2 v){return clamp(v, 0.0, 1.0);}\nvec3 saturate(vec3 v){return clamp(v, 0.0, 1.0);}\nvec4 saturate(vec4 v){return clamp(v, 0.0, 1.0);}\n\nfloat Pow2(float v){return v * v;}\nfloat Pow3(float v){return v * v * v;}\nfloat Pow4(float v){return Pow2(Pow2(v));}\nfloat Pow8(float v){return Pow2(Pow4(v));}\nfloat Pow16(float v){return Pow4(Pow4(v));}\nfloat Pow32(float v){return Pow16(Pow2(v));}\n\nfloat SqrLen(float v){return v * v;}\nfloat SqrLen(vec2 v){return dot(v, v);}\nfloat SqrLen(vec3 v){return dot(v, v);}\nfloat SqrLen(vec4 v){return dot(v, v);}\n\nfloat SCurveC1(float v){return v * v * (3.0 - 2.0 * v);}\nvec2 SCurveC1(vec2 v){return v * v * (vec2(3.0) - vec2(2.0) * v);}\n\nfloat Xor(float x, float y){return saturate((x * (1.0 - y)) + ((1.0 - x) * y));}\n\nfloat Mod(float v, float m){return fract(v / m) * m;}\n\nvec3 CheapNormal(float v, float s)\n{\n    return normalize(vec3(-dFdx(v), -dFdy(v), s));\n}\n\n//===============================================================================//\n//===============================================================================//\n\n\nfloat EvalWave(float t)\n{\n    float wave = sin(t);\n\n\tfloat falloff = Pow2(saturate(1.0 - t * 0.05));\n    \n    return wave * falloff;\n}\n\nfloat EvalWave(float d2, float t)\n{    \n\tfloat falloff =  Pow2(saturate(1.0 - d2 * d2));\n    //falloff =  SCurveC1(saturate(1.0 - d2));\n    //falloff = 1.0;\n    float st = t * 10.0 - d2 * 30.0;\n    \n    float sMask = float(st > 0.0);\n    //sMask = SCurveC1(saturate(st * 0.5));\n    \n    return sMask * EvalWave(st) * falloff * 0.005;\n}\n\nfloat EvalWave(vec2 uv, vec2 p, float t)\n{\n    float d2 = SqrLen((uv - p) * 2.0);\n    \n    //return d2;\n    return EvalWave(d2, t);\n}\n\nfloat EvalWave(vec2 uv, vec2 pOff, float t, float tOff)\n{\n    float tIval = 3.5;\n    tIval = 3.5 * 0.5;\n    //tIval = 7.0;\n    \n    float time = t / tIval;\n    \n    float ITime0 = floor(time) + tOff;\n    float fTime = fract(time) - tOff;\n    \n    //fTime *= tIval;\n    \n    vec2 iUV = floor(uv) + pOff;\n    vec2 fUV = fract(uv) - pOff;\n    \n    vec2 pos = Hash2(vec3(iUV, ITime0));\n    //pos = vec2(0.5);\n    \n    //float tp = fTime - 3.5 * Hash(vec3(ITime, iUV.yx));\n    //float tp = fTime + 0.5 * (Hash(vec3(ITime, iUV.yx)) * 2.0 - 1.0);\n    float tp = fTime + Hash(vec3(ITime0, iUV.yx));\n    \n    return EvalWave(fUV, pos, tp * tIval * 2.0);\n}\n\nfloat EvalVNoise(vec2 pos)\n{\n    vec2 iPos = floor(pos);\n    vec2 fPos = fract(pos);\n    \n    float v0  = Hash(iPos);\n    float vx  = Hash(iPos + vec2(1.0, 0.0));\n    float vy  = Hash(iPos + vec2(0.0, 1.0));\n    float vxy = Hash(iPos + vec2(1.0, 1.0));\n    \n    fPos = SCurveC1(fPos);\n    \n    return mix(mix(v0, vx, fPos.x), mix(vy, vxy, fPos.x), fPos.y);\n}\n\nfloat EvalFBM1(vec2 pos, float c, float speed)\n{\n    float count = 6.0;\n    float s = 1.0;\n    float fw = 0.0;\n    float r = 0.0;\n    \n    for(float i = 0.0; i < 4.0; ++i)\n    {\n        //r += EvalVNoise((pos) / vec2(s) + vec2(iTime * speed / s/s)) * s;\n        r += EvalVNoise((pos) / vec2(s) + vec2(iTime * speed * s)) * s;\n        fw += s;\n        \n        s *= 0.53;\n    }\n    \n    return mix(r / fw, 0.8, c);\n}\n\nvec3 EvalSky(vec3 dir)\n{\n    //dir = normalize(dir);\n    vec2 sp = dir.xy / dir.z;\n    vec3 clouds = vec3(EvalFBM1(sp, 0.75, 0.8));\n    \n\t//clouds = vec3(SCurveC1(saturate(mix(-6.0, 7.0, EvalFBM1(sp, 0.0, 0.15)))));\n    vec3 mdir = normalize(vec3(0.0, 0.0, 1.0));\n    mdir = normalize(vec3(1.0, -1.0, 1.0));\n    float foo = saturate(dot(dir, mdir) * 0.5 + 0.5);\n    //foo = Pow32(foo);\nfoo = saturate(foo + (clouds.x * 2.0 - 1.0) * 0.05);\n    //foo = saturate(dot(dir, mdir));\n     return vec3(Pow16(foo), Pow4(foo), Pow2(foo));\n    return vec3(foo);\n    return clouds;\n}\n\nvec3 EvalBokeh(vec2 uv, float time)\n{\n    vec3 result = vec3(0.0);\n    \n    for(float i = -1.0; i <= 1.0; ++i)\n    for(float j = -1.0; j <= 1.0; ++j)\n    {\n        vec2 off = vec2(i, j);\n        \n        vec2 iUV = floor(uv) + off;\n        vec2 fUV = fract(uv);\n\n        float lTime = time + Hash(iUV);\n\n        float ITime0 = floor(lTime);\n        float fTime = fract(lTime);\n\n        vec3 iSpaceTime = vec3(iUV, ITime0);\n\n        vec2 pos = vec2(Hash2(iSpaceTime)) + off;\n\n        float r = mix(0.2, 0.5, Hash(iSpaceTime));\n        float r2 = r * r;\n\n        float bokeh = 1.0 - Pow8(1.0 - saturate(1.0 - SqrLen(fUV - pos) / r2));\n        \n        float bright = max(0.0, mix(-3.0, 6.0, Pow2(Hash(iSpaceTime.yxz))));\n        float bCurve = Pow4(1.0 - Pow2(fTime * 2.0 - 1.0));\n        \n        bokeh *= bCurve * bright;\n        \n        vec3 col1 = vec3(1.0, 0.8, 0.2);\n        vec3 col2 = vec3(1.0, 0.01, 0.01);\n             //col1 = vec3(0.05, 0.2, 1.0);\n             //col2 = vec3(0.01, 0.8, 1.0);\n        vec3 colM = mix(col1, col2, SCurveC1(Hash(iSpaceTime.zyx)));\n        \n        result += vec3(bokeh) * colM;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 nUV = fragCoord.xy / iResolution.xx;\n    \n    //vec2 coord = fragCoord.xy * 0.25;   \n    \n    vec3 outCol = vec3(1.0, 1.0, 1.0);\n    \n    outCol = vec3(0.0);\n    \n    float tIval = 3.5;\n    tIval = 1.0;\n    \n    float time = float(iTime) / tIval;\n    \n    float ITime0 = floor(time);\n    float fTime = fract(time) * tIval;\n\n    float zoom = 1.0 / 100.0;\n\n    vec2 coord = fragCoord.xy * zoom;\n    coord = nUV * 6.0;\n    \n    vec2 iUV = floor(coord);\n    vec2 fUV = fract(coord);\n    \n   // vec2 uv = fract(fragCoord.xy * zoom);\n    float d = SqrLen(fUV * 2.0 - 1.0);\n    \n    float wave = EvalWave(fUV, vec2(0.5), fTime);\n    wave = EvalWave(fUV, Hash2(vec3(iUV, ITime0)), fTime - 3.5 * Hash(vec3(ITime0, iUV.yx)));\n\twave = EvalWave(coord, vec2(0.0), ITime0, 0.0);\n    \n    wave = 0.0;\n    vec2 dd = vec2(0.0);\n    for(float t =  0.0; t <= 1.0; ++t)\n    for(float i = -1.0; i <= 1.0; ++i)\n    for(float j = -1.0; j <= 1.0; ++j)\n    {\n        float o = 0.004;\n        float xn = EvalWave(coord + vec2(-o, 0.0), vec2(i, j), iTime, t);\n        float xp = EvalWave(coord + vec2( o, 0.0), vec2(i, j), iTime, t);\n        float yn = EvalWave(coord + vec2(0.0, -o), vec2(i, j), iTime, t);\n        float yp = EvalWave(coord + vec2(0.0,  o), vec2(i, j), iTime, t);\n        \n        dd += vec2(xp - xn, yp - yn) / o * 0.5;\n    }\n    \n    vec3 normal = normalize(vec3(-dd, 1.0));\n    //vec3 normal = CheapNormal(wave, zoom);\n    //normal.z = -normal.z;\n    \n    vec3 lightDir = normalize(vec3(0.25, 0.25, 1.0));\n    vec3 viewDir = normalize(vec3((fragCoord.xy - iResolution.xy * 0.5)/ iResolution.xx * 4.0, -1.0));\n    vec3 hVec = normalize(normal + viewDir);\n    vec3 rVec = 2.0 * dot(normal, viewDir) * normal - viewDir;\n    vec3 planeVec = viewDir - normal * dot(viewDir, normal);\n    vec3 reVec = -normalize(mix(normal, viewDir, 0.25));\n    reVec = -normalize(mix(planeVec, viewDir, 0.5));\n    vec3 rVec0 = 2.0 * dot(vec3(0.0,0.0,1.0), viewDir) * vec3(0.0,0.0,1.0) - viewDir;\n    outCol = vec3(pow(saturate(dot(hVec, lightDir)), 100.0));\n    \n    outCol = EvalSky(reVec);\n    \n   // vec2 tuv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n   // float tuvSL = SqrLen(tuv);\n   // float tuvM = float(tuvSL < 1.0);\n    //vec3 tuvDir = vec3(-tuv, sqrt(vec2(1.0) - tuvSL));\n    \n    //outCol = EvalBokeh(fragCoord.xy * 0.01, ITime0 * 0.1);\n    //outCol = EvalBokeh(rVec.xy / rVec.z * 4.0, ITime0 * 0.05);\n    \n    //outCol = EvalSky(tuvDir) * vec3(tuvM) + vec3(0.5 - tuvM * 0.5);\n    //outCol = vec3(mix(reflection, 1.0, EvalFBM1(coord.yx * 1.0, 0.2, 0.03) * 0.0));\n    //outCol = normal * 0.5 + 0.5;\n    //outCol = vec3(wave);\n    //outCol = vec3(d);\n    //outCol = vec3(0.20);\n    //fragColor = vec4(outCol.xyz, 1.0); return;\n    fragColor = vec4(pow(saturate(outCol.xyz), vec3(1.0 / 2.2)), 1.0); return;\n}","name":"Image","description":"","type":"image"}]}