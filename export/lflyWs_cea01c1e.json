{"ver":"0.1","info":{"id":"lflyWs","date":"1721900561","viewed":28,"name":"Sketch Balrog ","username":"zhangrm","description":"The dynamic version of prototype shader for Balrog - a 256 byte executable graphics for DOS by pestis /brainlez Coders.\nref:https://www.shadertoy.com/view/4XsGRr\n    https://www.shadertoy.com/view/ldlcWs","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","ifs","dip","kaleidoscopicifs","executablegraphics"],"hasliked":0,"parentid":"MXyXWG","parentname":"Balrog In The Lord of the Rings"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by sofiene71 - 2017\n//original idea by  flockaroo see https://www.shadertoy.com/view/XtVGD1\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemle some hand drawing style\n\n\n#define SHADERTOY\n#ifdef SHADERTOY\n#define Res0 iChannelResolution[0].xy\n#define Res1 iChannelResolution[1].xy\n#else\n#define Res0 textureSize(iChannel0,0)\n#define Res1 textureSize(iChannel1,0)\n#define iResolution Res0\n#endif\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\nfloat gaussian(float x, float sigma) {\n    return exp(-0.5 * (x * x) / (sigma * sigma)) / (sqrt(2.0 * 3.14159265358979) * sigma);\n}\n\nvec4 getGaussianCol(vec2 pos, float sigma, float radius) {\n    vec4 colorSum = vec4(0.0);\n    float weightSum = 0.0;\n    float step = max(radius / 5.0, 1.0); // avoid step be zero\n    float sigma2 = sigma * sigma;\n\n    // within our range\n    for (float x = -radius; x <= radius; x += step) {\n        for (float y = -radius; y <= radius; y += step) {\n            vec2 offset = vec2(x, y);\n            float dist = length(offset);\n            if (dist <= radius) {\n                float weight = gaussian(dist, sigma);\n                vec2 uv = pos / Res.xy + offset / Res.xy;\n                vec4 color = texture(iChannel0, uv);\n                colorSum += color * weight;\n                weightSum += weight;\n            }\n        }\n    }\n\n    return colorSum / weightSum;\n}\n\n\n\nvec4 getCol(vec2 pos) {\n    float sigma = 1.0; // standard deviation\n    float radius = 3.0; // sample radius\n\n    // Gauss blur\n    vec4 c1 = getGaussianCol(pos, sigma, radius);\n\n    // outside of the range area\n    vec4 e = smoothstep(vec4(-0.05), vec4(-0.0), vec4(pos / Res.xy, vec2(1) - (pos / Res.xy)));\n    c1 = mix(vec4(1, 1, 1, 0), c1, e.x * e.y * e.z * e.w);\n\n    float d = clamp(dot(c1.xyz, vec3(-.5, 1., -.5)), 0.0, 1.0);\n    vec4 c2 = vec4(.7);\n    return min(mix(c1, c2, 1.8 * d), .7);\n}\n\n\nvec4 getColHT(vec2 pos)\n{\n \treturn smoothstep(0.795,1.05,getCol(pos));\n}\n\nfloat getVal(vec2 pos)\n{\n    vec4 c=getCol(pos);\n \treturn pow(dot(c.xyz,vec3(.333)),1.)*1.;\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n   \tvec2 d=vec2(eps,0.);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx)\n    )/eps/2.;\n}\n\n\n  float lum( vec3 c) {\n              return dot(c, vec3(0.3, 0.59, 0.11));\n             }\n\n\n vec3 clipcolor( vec3 c) {\n                  float l = lum(c);\n                  float n = min(min(c.r, c.g), c.b);\n                  float x = max(max(c.r, c.g), c.b);\n                \n                 if (n < 0.0) {\n                     c.r = l + ((c.r - l) * l) / (l - n);\n                     c.g = l + ((c.g - l) * l) / (l - n);\n                     c.b = l + ((c.b - l) * l) / (l - n);\n                 }\n                 if (x > 1.25) {\n                     c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n                     c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n                     c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n                 }\n                 return c;\n             }\n\n vec3 setlum( vec3 c,  float l) {\n                 float d = l - lum(c);\n                 c = c + vec3(d);\n                 return clipcolor(0.85*c);\n }\n\n#define AngleNum 3\n\n#define SampNum 5\n\n#define PI2 6.28318530717959\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    float sum=0.;\n    \n    for(int i=0;i<AngleNum;i++)\n    {\n        float ang=(4.+sin(1.*-iTime))/float(AngleNum)*(float(i)+0.8);\n        vec2 v=vec2(cos(ang),sin(ang));\n        for(int j=0;j<SampNum;j++)\n        {\n            vec2 dpos  = v.yx*vec2(1,-1)*float(j)*iResolution.y/920.;\n            vec2 dpos2 = ( v.xy*float(j*i)/float(SampNum)*iResolution.y/900.);\n\t        vec2 g;\n            float fact;\n            float fact2;\n            float s=5.5;\n\n          \n            \n            vec2 pos2=pos+s*dpos+dpos2;\n                \n            g=getGrad(pos2,0.08);\n            fact=dot(g,v)-.5*abs(dot(g,v.yx*vec2(1,-1)));\n            fact2=dot(normalize(g+vec2(.0001)),v.yx*vec2(1,-1));\n                \n            fact=clamp(fact,0.,.05);\n            fact2=abs(fact2);\n                \n            fact*=1.-float(j)/float(SampNum);\n            col += fact;\n            col2 += fact2;\n            sum+=fact2;\n            \n        }\n    }\n    col/=float(SampNum*AngleNum)*0.65/sqrt(iResolution.y);\n    col2/=sum;\n    col.x*=1.6;\n    col.x=1.-col.x;\n    col.x =col.x*col.x;\n\n    vec2 s=sin(pos.xy*.1/sqrt(iResolution.y/720.));\n    float r=length(pos-iResolution.xy*.5)/iResolution.x;\n\tfragColor = vec4(vec3(col.x*col2 ),1);\n    vec4 origCol = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    vec4 overlayColor = vec4(0.3755,0.05,0.,0.0)*origCol;\n           \n    fragColor = vec4( setlum(1.25*overlayColor.rgb, lum(fragColor.rgb)) * 1.0, 0.);\n    fragColor.rgb -= 0.75- clamp (origCol.r + origCol.g + origCol.b , 0.0 , 0.75);\n    //fragColor += 0.077;\n    //fragColor = min(fragColor , 5.5*texture (iChannel0 , fragCoord/iResolution.xy));\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int STEPS = 20;\nconst float BIG = 403.;\nconst float BIGZ = BIG / 384. * 2.;\nconst int ITERS = 29;\nconst float MINDIST = .0001;\nconst float CAM_X = .00;\nconst float CAM_Y = .61;\nconst float CAM_Z = 36.7;\nconst float LEVEL = 1.;\nconst float XMULT_BASE = 1.5;\nconst float COLORMULT_BASE = 3.14592;\nconst float COLORSCALE = 0.0549857728183;\nconst float XDIV = 2.0006;\nconst float RSCALE = pow(2., 1. / 3.);\nconst float RDIV = pow(RSCALE, float(ITERS));\nconst float GLOWAMOUNT = 0.0549857728183;\nconst float GLOWDECAY = 1e4;\nconst float PI = 3.14;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ray = vec2((fragCoord - 0.5 * iResolution.xy) / iResolution.xy);\n    ray.y = -ray.y;\n    ray.xy *= vec2(512, 384); // this is actually what we have on DOS: the screen coordinates\n\n    vec3 p = vec3(CAM_X, CAM_Y, CAM_Z);\n    int i;\n    float glow = 0.0;\n\n    float timeFactor = (sin((1.*iTime - 23.0) * PI / 25.0) + 1.0) * 0.5; \n    float XMULT = XMULT_BASE * (1.0 + 0.5 * timeFactor);\n    float COLORMULT = COLORMULT_BASE * (1.0 + 0.5 * timeFactor);\n\n    for (i = 0; i < STEPS; i++) {\n        vec3 t = p;\n        // o is the amount of rotation in the kaleidoscopic IFS.\n        float o = cos(p.x * XMULT) / XDIV;\n        float r = 0.;\n\n        for (int j = 0; j < ITERS; j++) {\n            t.x = abs(t.x - round(t.x)); // abs is folding, t.x - round(t.x) is domain repetition\n            t.x += t.x; // domain scaling\n            r *= RSCALE;\n            r += t.x * t.x;\n            t.xyz = t.yzx; // shuffle coordinates so next time we operate on previous y etc.\n             t.x += t.z * o; // rotation, but using very poor math\n            t.z -= t.x * o;\n        }\n\n        float dist = sqrt(r / RDIV) - LEVEL;\n        glow += GLOWAMOUNT / (1. + dist * dist * GLOWDECAY);\n\n        p.xy += ray.xy * dist / BIG;\n        p.z += dist / BIGZ;\n        if (dist < MINDIST) break;\n    }\n\n    float s = float(i) * COLORSCALE;\n    vec3 col = vec3(s * s); //+ cos(p * COLORMULT) * glow; // s*s to adjust the contrast\n    col = mix(col, vec3(0.1, 0.1, 0.2), 0.3);\n    fragColor = vec4(abs(sin(col)), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}