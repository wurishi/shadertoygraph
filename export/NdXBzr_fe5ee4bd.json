{"ver":"0.1","info":{"id":"NdXBzr","date":"1644389979","viewed":345,"name":"fractal with cell shading","username":"c0rymcg","description":"A julia set with 'cell coloring', and some animated parameters to keep things interesting. \n\nThe development of this color method took place here: https://fractalforums.org/programming/11/cellular-coloring-of-mandelbrot-insides/3264","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","beans"],"hasliked":0,"parentid":"fdXBzr","parentname":"fractal code template"},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TAU 6.28318\n#define maxIterations 128\n#define AA 2\n\n\n\nvec2 cMult(vec2 c1, vec2 c2){\n   //complex mult\n    float newR = c1.x*c2.x - c1.y*c2.y;\n\tfloat newI = c1.y*c2.x + c1.x*c2.y;\n\treturn vec2(newR,newI);\n}\n\n\nvec2 f1(vec2 z, vec2 c) {\n    return mat2(z,-z.y,z.x)*z + c;///mandelbrot\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )//from iq\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat fTrap(vec2 z){\n    \n    vec2 center= vec2(sin(iTime)*(2.*sin(iTime/5.)+4.2), cos(iTime)*(2.5*sin(iTime/6.)+5.6)) - z;\n    float offset = 0.4*(sin(iTime/3.)+1.)+0.2;\n    return sdSegment(z,center+offset,center-offset);\n}\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    float time = iTime;\n    \n    //aa code here\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n    \n        \n        \n        vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xx;\n        uv -= 0.5;uv *= 1.3;uv += 0.5;\n        vec2 c=vec2(0);\n        c*=2.5;\n        c.x =(uv.x - 0.5) ;\n        c.y =(uv.y - 0.22);\n        \n        vec2 offset = vec2(1,0.1)*sin(iTime/7.)+vec2(-0.1,0.1)*cos(iTime/7.);\n        c+=offset;\n        \n        \n        vec2 z = c;//\n         c=vec2(-0.8,0.156);//âˆ’0.8 + 0.156i\n    \n        \n        float closest = 4.;\n        float closest2 = 4.;\n        int smallestI = 0;\n        \n        //vec2 dir = vec2(0);\n        //iterate\n        for (int i = 0; i < maxIterations; i++) {\n              z = f1(z,c);\n              \n              //vec2 p = fTrap(z);\n              //float dist = length(p);\n              float dist = fTrap(z);\n              if (dist < closest){\n                closest2 = closest;\n                closest = dist;\n                smallestI = i;\n                //dir=normalize(p);\n            }else if (dist < closest2){\n                closest2 = dist;\n                \n            }\n        }\n        vec3 col = vec3(palette(float(smallestI)/20., vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.0),vec3(0.3, 0.2, 0.2)));\n\n        float shadow = sqrt(clamp(sqrt(clamp(1.-closest/closest2,0.,1.))*1.5,0.,1.));\n        float highlight = clamp(4.* (0.2-(closest/closest2)),0.,1.);\n\n        col=col*shadow+highlight;\n        \n        /*\n        dir*=closest/closest2;\n        vec3 normal = vec3(dir.xy, sqrt(1. - dot(dir,dir)));\n    \n        col *= texture(iChannel0, (normal)).rgb*1.75;\n        */\n\t\tcol=col*(-1./float(maxIterations)*float(smallestI)+1.);\n        \n        aacol+=col;\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}