{"ver":"0.1","info":{"id":"XcSBRW","date":"1724795223","viewed":44,"name":"Fresnel Icosahedron ","username":"SolitonPacket","description":"I wanted to make something cool and glassy with the fresnel equations.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ray","raytrace","icosahedron","fresnel","trace","polyhedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCopyright 2024 Taylor Wampler\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), \nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// things to edit\n#define CAMERA_DISTANCE 5.0\n#define MAX_COLLISIONS 5\n#define SCENE_UP vec3(0.0, 0.0, 1.0)\n#define ICO_ABSORPTION vec3(2.5, 1.0, 1.0)\n#define ICO_SURFACE_FIRST_REFLECTION_COLOR vec3(1.0) \n#define ICO_INDEX 2.1\n#define AIR_INDEX 1.0003\n#define SQRT_SSA_SAMPLES 2\n\n// Give a little nudge to reflected and refracted rays.\n// I had to play around with this until the artifacts went away.\n#define RAY_NUDGE 10e-5\n\n// Tolerance for the triangle intersection test.\n#define INTERSECTION_TOL 10e-5\n\n// geometric constants\n#define ICO_HEIGHT (sqrt(5.0) / 5.0)\n#define PENT_R (2.0 * sqrt(5.0) / 5.0)\n\nstruct Camera       { vec3 eye, target; };\nstruct Ray          { vec3 point, direction; };\nstruct Triangle     { vec3 p1, p2, p3; };\nstruct Intersection { float t; vec3 normal; };\n\n// Think of the icosahedron as four shifted xz plane slices. \n// A and L are in the first and last slices respectively.\n// BCDEF and GHIJK are the pentagons, \n// they are reflections of each other about the x-axis in the plane of the slice.\n// Also note that the first and second slices are reflections \n// of the last and third slices about the xz plane.\n//\n// \n// front view       back view\n//       B            J       I\n//  F         C           L    \n//       A           K         H\n//   E       D            G        \n//\n// https://mathworld.wolfram.com/RegularIcosahedron.html\nconst vec3 pA = vec3(0.0,\n               -1.0, \n               0.0);\nconst vec3 pB = vec3(0.0, \n                -ICO_HEIGHT, \n                PENT_R);\nconst vec3 pC = vec3(PENT_R*sqrt(0.125*(5.0+sqrt(5.0))), \n                -ICO_HEIGHT, \n                PENT_R*0.25*(sqrt(5.0)-1.0));\nconst vec3 pD = vec3(PENT_R*sqrt(0.125*(5.0-sqrt(5.0))), \n                -ICO_HEIGHT, \n                PENT_R*0.25*(-sqrt(5.0)-1.0));\nconst vec3 pE = vec3(-PENT_R*sqrt(0.125*(5.0-sqrt(5.0))), \n                -ICO_HEIGHT, \n                PENT_R*0.25*(-sqrt(5.0)-1.0));\nconst vec3 pF = vec3(-PENT_R*sqrt(0.125*(5.0+sqrt(5.0))), \n                -ICO_HEIGHT, \n                PENT_R*0.25*(sqrt(5.0)-1.0));\nconst vec3 pG = vec3(0.0, \n                ICO_HEIGHT, \n                -PENT_R);\nconst vec3 pH = vec3(PENT_R*sqrt(0.125*(5.0+sqrt(5.0))), \n                ICO_HEIGHT, \n                PENT_R*0.25*(1.0-sqrt(5.0)));\nconst vec3 pI = vec3(PENT_R*sqrt(0.125*(5.0-sqrt(5.0))), \n                ICO_HEIGHT, \n                PENT_R*0.25*(sqrt(5.0)+1.0));\nconst vec3 pJ = vec3(-PENT_R*sqrt(0.125*(5.0-sqrt(5.0))), \n                ICO_HEIGHT, \n                PENT_R*0.25*(sqrt(5.0)+1.0));\nconst vec3 pK = vec3(-PENT_R*sqrt(0.125*(5.0+sqrt(5.0))), \n                ICO_HEIGHT, \n                PENT_R*0.25*(1.0-sqrt(5.0)));\nconst vec3 pL = vec3(0.0,\n               1.0, \n               0.0);\nTriangle triangles[20];\n\n//---------------------------------------------------------------\n\nRay cameraRay(in Camera c, in vec2 uv)\n{\n    vec3 forward = normalize(c.target - c.eye);\n    vec3 left    = normalize(cross(forward, SCENE_UP));\n    vec3 up      = cross(left, forward);\n    \n    vec3 dy = (iResolution.y / iResolution.x) * (uv.y - 0.5) * up ;\n    vec3 dx = (uv.x - 0.5) * left;\n    return Ray(c.eye, normalize(dy - dx + forward));\n}\n\nIntersection closerIntersection(in Intersection i1, in Intersection i2)\n{\n   if (i2.t >= 0.0 && (i1.t < 0.0 || i2.t < i1.t)) return i2;\n   else return i1;\n}\n\n// Real‐Time Rendering, 4th Edition by Tomas Akenine-Möller, Eric Haines, Naty Hoffman, \n// Angelo Pesce, Michał Iwanicki, and Sébastien Hillaire\nIntersection rayIntersectTriangle(in Ray ry, in Triangle tr)\n{\n    vec3 e1 = tr.p3 - tr.p1;\n    vec3 e2 = tr.p2 - tr.p1;\n    vec3 s = ry.point - tr.p1;\n    vec3 m = cross(s, ry.direction);\n    vec3 normal = cross(e1, e2);\n    \n    // normal\n    float dp = -dot(ry.direction, normal);\n    // check if ray is parallel to the plane\n    if (dp > -INTERSECTION_TOL && dp < INTERSECTION_TOL) \n        return Intersection(-1.0, vec3(0.0));\n    \n    float inv_dp = 1.0 / dp;\n    vec3 coord = inv_dp * vec3(dot(normal, s), dot(m, e2), -dot(m, e1));\n    if (coord.x < 0.0 || coord.y < 0.0 || coord.z < 0.0 || (coord.y + coord.z) > 1.0)\n        return Intersection(-1.0, vec3(0.0));\n        \n    // The normal returned should be a unit vector anti-aligned with the ray.\n    if (dp < 0.0) normal = -normal;\n    normal = normalize(normal);\n    \n    return Intersection(coord.x, normal);    \n}\n\nIntersection rayIntersectIcosahedron(in Ray ry)\n{\n    Intersection intersection;\n    intersection.t = -1.0;\n    intersection.normal = vec3(0.0);\n    for (int i = 0; i < 20; i++)\n    {\n        Intersection collide = rayIntersectTriangle(ry, triangles[i]);\n        intersection = closerIntersection(intersection, collide);\n    }\n    \n    return intersection;\n}\n\n// Use Schlick's model to approximate Fresnel reflectance.\n//\n// Real‐Time Rendering, 4th Edition by Tomas Akenine-Möller, Eric Haines, Naty Hoffman, \n// Angelo Pesce, Michał Iwanicki, and Sébastien Hillaire\nfloat reflectance(in float n1, in float n2, in Ray ry, in Intersection intersection)\n{\n    float cosTheta = clamp(-dot(ry.direction, intersection.normal), 0.0, 1.0);\n    \n    // check for total internal reflection\n    float sineThetaSquared = 1.0 - cosTheta * cosTheta;\n    float n1n2Squared = n1 / n2;\n    n1n2Squared *= n1n2Squared;\n    if (sineThetaSquared * n1n2Squared > 1.0) return 1.0;\n    \n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n    float f = 1.0 - cosTheta;\n    \n    return r0 + (1.0 - r0) * f * f * f * f * f;\n}\n\nvec3 getEnvironmentColor(in Ray ry)\n{\n    return texture(iChannel0, vec3(ry.direction.x, ry.direction.z, -ry.direction.y)).rgb;\n}\n\nvec3 getColor(Ray ry)\n{\n    vec3 color = vec3(0.0);\n    float multiplier = 1.0;\n    float totInternalPath = 0.0;\n    for (int i = 0; i < MAX_COLLISIONS; i++)\n    {\n        Intersection intersection = rayIntersectIcosahedron(ry);\n        if (intersection.t < 0.0 || intersection.t >= 1e2)\n            return color + multiplier * getEnvironmentColor(ry);\n        \n        // Move along the ray to the intersection point.\n        ry.point += ry.direction * intersection.t;\n        \n        // Determine the appropriate interface. The skybox and icosahedron are the only objects.\n        float n1, n2;\n        if (i > 0)\n        {\n            n1 = ICO_INDEX;\n            n2 = AIR_INDEX;\n        }\n        else\n        {\n            n1 = AIR_INDEX;\n            n2 = ICO_INDEX;\n        }\n        \n        // Fresnel reflectance and the Law of Reflection\n        float r = reflectance(n1, n2, ry, intersection);\n        vec3 reflectDirection = normalize(reflect(ry.direction, intersection.normal));\n        Ray ryReflect = Ray(ry.point + reflectDirection * RAY_NUDGE, reflectDirection);\n        // Fresnel transmittance and the Law of Refraction (Snell's Law)\n        float m = 1.0 - r;\n        vec3 refractDirection = normalize(refract(ry.direction, intersection.normal, n1 / n2));\n        Ray ryRefract = Ray(ry.point + refractDirection * RAY_NUDGE, refractDirection);\n        \n        // On the first intersection, add the reflection contribution and follow the refracted ray.\n        // On later intersections, add the refraction contribution and follow the internally reflected ray.\n        if (i > 0)\n        {\n            // Bouguer–Lambert / Beer-Lambert Law\n            totInternalPath += intersection.t;\n            vec3 absorption = exp(-ICO_ABSORPTION * totInternalPath);\n            \n            // refraction contribution from outside the icosahedron\n            vec3 environmentColor = getEnvironmentColor(ryRefract);\n            color += (m * multiplier * absorption) * environmentColor;\n            \n            ry = ryReflect;\n            multiplier *= r;\n        }\n        else\n        {\n            // reflection contribution from outside the icosahedron\n            vec3 environmentColor = getEnvironmentColor(ryReflect);\n            color += (r * ICO_SURFACE_FIRST_REFLECTION_COLOR) * environmentColor;\n            \n            ry = ryRefract;\n            multiplier *= m;\n        }\n    }\n    \n    return color;\n}\n\n//---------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // third-person camera\n    float azimuthal = 3.14 / 2.0 + iTime / 3.14;\n    float polar     = 3.14 / 2.0;\n    Camera camera;\n    camera.eye    = CAMERA_DISTANCE * vec3(sin(polar) * cos(azimuthal), sin(polar) * sin(azimuthal), cos(polar));\n    camera.target = vec3(0.0, 0.0, 0.0);\n\n    // triangles connecting the first and second slices\n    triangles[0]  = Triangle(pA, pB, pC);\n    triangles[1]  = Triangle(pA, pC, pD);\n    triangles[2]  = Triangle(pA, pD, pE);\n    triangles[3]  = Triangle(pA, pE, pF);\n    triangles[4]  = Triangle(pA, pF, pB);\n    // triangles connecting the second and third slices\n    triangles[5]  = Triangle(pB, pJ, pI);\n    triangles[6]  = Triangle(pB, pI, pC);\n    triangles[7]  = Triangle(pC, pI, pH);\n    triangles[8]  = Triangle(pC, pH, pD);\n    triangles[9]  = Triangle(pD, pH, pG);\n    triangles[10] = Triangle(pD, pG, pE);\n    triangles[11] = Triangle(pE, pG, pK);\n    triangles[12] = Triangle(pE, pK, pF);\n    triangles[13] = Triangle(pF, pK, pJ);\n    triangles[14] = Triangle(pF, pJ, pB);\n    // triangles connecting the third and last slices\n    triangles[15] = Triangle(pL, pJ, pI);\n    triangles[16] = Triangle(pL, pI, pH);\n    triangles[17] = Triangle(pL, pH, pG);\n    triangles[18] = Triangle(pL, pG, pK);\n    triangles[19] = Triangle(pL, pK, pJ);\n\n    // A basic SSA scheme. Shadertoy doesn't automatically antialias. \n    vec3 color = vec3(0.0);\n    for (int i = 0; i < SQRT_SSA_SAMPLES; i++)\n    {\n        for (int j = 0; j < SQRT_SSA_SAMPLES; j++) \n        {\n            // Calculate the color from a subpixel ray.\n            vec2 offset = vec2(i, j) / (iResolution.xy * float(SQRT_SSA_SAMPLES));\n            color += getColor(cameraRay(camera, uv + offset));\n         }\n    }\n    color /= float(SQRT_SSA_SAMPLES * SQRT_SSA_SAMPLES);\n    \n    // gamma correction\n    color = pow(max(color, 0.0), vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}