{"ver":"0.1","info":{"id":"cdyyzK","date":"1696285420","viewed":81,"name":"green fan","username":"Kirill456Z","description":".","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 90;\nconst float maxDist = 10.0;\nconst float eps      = 0.01;\nconst float pi       = 3.14159265359;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 rotateVector ( in vec3 p , in vec3 pivot , in mat3 m )\n{\n    vec3 relative = p - pivot;\n    vec3 res = relative * m;\n    return res + pivot;\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dSphere ( in vec3 p, in vec3 pos , in float s )\n{\n    return length ( p - pos  ) - s;\n}\n\nfloat dTorus ( vec3 p, vec2 t, vec3 s )\n{\n    vec3 sp = p - s;\n\tvec2 q = vec2 ( length ( sp.xz ) - t.x, sp.y );\n\t\n\treturn length ( q ) - t.y;\n}\n\nfloat dCyllinder8 ( vec3 p , vec2 t , vec3 pos )\n{\n    vec3 sp = p - pos;\n    if ( sp.y < t.y && sp.y > 0.0) {\n        return max ( max ( length8 ( vec2 ( sp.z , sp.x) ) - t.x , -sp.y ) , sp.y - t.y);\n    }\n    float distToSurface = max ( sp.y - t.y , -sp.y );\n    if ( length8 ( vec2 ( sp.x , sp.z ) ) > t.x ) {\n        vec2 diff = vec2 ( length8 ( vec2 ( sp.x , sp.z ) ) - t.x, distToSurface );\n        return length8 ( diff );\n    }\n    return distToSurface;\n}\n\nfloat dCyllinder ( vec3 p , vec2 t , vec3 pos )\n{\n    vec3 sp = p - pos;\n    if ( sp.y < t.y && sp.y > 0.0) {\n        return max ( max ( length ( vec2 ( sp.z , sp.x) ) - t.x , -sp.y ) , sp.y - t.y);\n    }\n    float distToSurface = max ( sp.y - t.y , -sp.y );\n    if ( length ( vec2 ( sp.x , sp.z ) ) > t.x ) {\n        vec2 diff = vec2 ( length ( vec2 ( sp.x , sp.z ) ) - t.x, distToSurface );\n        return length ( diff );\n    }\n    return distToSurface;\n}\n\nfloat dBox( vec3 p, vec3 b, vec3 pos )\n{\n  vec3 moved = p - pos;\n  vec3 q = abs(moved) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat dPlane( vec3 p, float yloc)\n{\n    return ( p.y - yloc );\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf1 ( in vec3 p , in mat3 m )\n{\n    float cyl1 = dCyllinder8 ( p , vec2 ( 0.8, 0.35 ), vec3 (0, -1, 0) );\n    float cyl2 = dCyllinder ( p , vec2 ( 0.2 , 2 ) , vec3 (0, -1 , 0 ) );\n    float res = smin ( cyl1 , cyl2 , 80.0 );\n    float sphere = dSphere ( p , vec3 ( 0 , 1 , 0 ), 0.3 );\n    res = smin ( res , sphere , 80.0 );\n   \n    vec3 q = rotateVector( p , vec3 ( 0, 1, 0 ) , rotateY(pi / 2.0) * rotateX(pi / 2.0) );\n    float cyl3 = dCyllinder ( q , vec2 ( 0.1 , 0.5 ) , vec3 (0, 1 , 0 ) );\n    res = min ( res, cyl3 );\n\n    return res;\n}\n\nfloat sdf2 ( in vec3 p , in mat3 m )\n{\n    float planeSdf = dPlane ( p, -1.0 );\n    return planeSdf;\n}\n\nfloat sdf3 ( in vec3 p , in mat3 m )\n{\n    float res = 10000.0;\n    vec3 lsize = vec3 (0.02, 0.05, 1);\n    vec3 lloc = vec3 ( 0.45, 1, 0 );\n    vec3 lpivot = lloc;\n    \n    mat3 mtime = rotateX(iTime * 5.0);\n    vec3 q = rotateVector( p , lpivot , mtime );\n    float l1 = dBox( q , lsize, lloc );\n    res = min ( res , l1 );\n    \n    mtime = rotateX(iTime * 5.0 + 2.0 * pi / 5.0);\n    q = rotateVector( p , lpivot , mtime );\n    l1 = dBox( q , lsize, lloc );\n    res = min ( res , l1 );\n    \n    mtime = rotateX(iTime * 5.0 + 2.0 * pi / 5.0 * 2.0);\n    q = rotateVector( p , lpivot , mtime );\n    l1 = dBox( q , lsize, lloc );\n    res = min ( res , l1 );\n    \n    mtime = rotateX(iTime * 5.0 + 2.0 * pi / 5.0 * 3.0);\n    q = rotateVector( p , lpivot , mtime );\n    l1 = dBox( q , lsize, lloc );\n    res = min ( res , l1 ); \n    \n    mtime = rotateX(iTime * 5.0 + 2.0 * pi / 5.0 * 4.0);\n    q = rotateVector( p , lpivot , mtime );\n    l1 = dBox( q , lsize, lloc );\n    res = min ( res , l1 );\n    \n    return res;\n}\n\nvec2 uwrapCyllinder( in vec3 p, in vec2 dim, in vec3 pos)\n{\n    float y_unwrapped = (p.y - pos.y) / (dim.y);\n    float l = length( p.xz );\n    float pcos = p.z / l;\n    float psin = p.x / l;\n    float angle = acos( pcos );\n    if (psin < 0.0) \n    {\n        angle = (2.0 * pi) - angle;\n    } \n    return vec2 (angle / (2.0 * pi), y_unwrapped);\n}\n\n\nfloat sdf ( in vec3 p , in mat3 m )\n{\n    vec3 q = m * p;\n    float sdf1Val = sdf1 ( q , m );\n    float sdf2Val = sdf2 ( q , m );\n    float res = min ( sdf1Val , sdf2Val );\n    float sdf3Val = sdf3 ( q , m );\n    return min ( res , sdf3Val );\n}\n\n\nvec3 trace ( vec3 from, vec3 dir, out bool hit, in mat3 m )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit = false;\n    \n    for (  int steps = 0; steps < maxSteps; steps++ )\n    {\n        float    dist = sdf ( p , m );\n        \n        if ( dist < eps )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        \n        if ( totalDist > maxDist )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\nvec3 c1 = vec3 ( 161.0 , 229.0 , 171.0 ) / vec3 (400.0);\nvec3 c2 = vec3 ( 255.0 , 151.0 , 112.0 ) / vec3(255.0);\nvec3 c3 = vec3 (212.0,250.0,213.0) / vec3 (255.0);\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit; \n    int  steps;\n    vec3 org   = eye;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    //mat3 m     = rotateX ( 0.0*mouse.y ) * rotateY ( 0.0*mouse.x);\n    //mat3 m     = rotateX ( 0.3*mouse.y ) * rotateY ( 6.0*mouse.x);\n    mat3 m     = rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec3 p     = trace ( org, dir, hit, m );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    \n    if ( hit )\n    {\n        vec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n        vec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 90.0 );\n\t\t\n        \n        vec3 q = m * p;\n        if ( dCyllinder ( q , vec2 ( 0.2 , 2 ) , vec3 (0, -1 , 0 )) < eps)\n        {\n            vec2 unwrapped = uwrapCyllinder( q, vec2 (0.2, 2), vec3 (0, -1, 0));\n            color = texture ( iChannel2, unwrapped.xy );\n        }\n        else if ( sdf1 ( q , m ) < eps ) {\n            color = vec4 ( c1 , 0 ) * vec4 ( nl );\n        }\n\t\telse if ( sdf2 ( q , m ) < eps ) {\n            vec4 cy = texture ( iChannel0, q.xz / 2.0 );\n            color = cy;\n            //color = vec4 ( c2 , 0 ) * vec4 ( nl );\n        }\n        else if ( sdf3 ( q , m ) < eps ) {\n            color = vec4 ( c3 , 0 ) * vec4 (nl );\n        }\n        color += 0.5 * sp * vec4 ( 1, 1, 1, 1 );\n    }\n\n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 c1 = vec4 ( 161.0 , 229.0 , 171.0, 0.0 ) / vec4 (400.0);\nvec4 c2 = vec4 ( 161.0 , 229.0 , 171.0, 0.0 ) / vec4 (600.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sum = fragCoord.x + fragCoord.y;\n    float r = sin( sum * 0.02 + iTime * 2.0 );\n    fragColor = r > 0.0 ? c1 : c2;\n}","name":"Buffer A","description":"","type":"buffer"}]}