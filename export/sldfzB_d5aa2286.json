{"ver":"0.1","info":{"id":"sldfzB","date":"1663316073","viewed":197,"name":"Laminar flow distorition","username":"Suslik","description":"Shader for simulating laminar flows with a surface that stretches due to viscosity like lava or mud","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tiling","interpolation","scrolling"],"hasliked":0,"parentid":"tsVGRd","parentname":"Fix texture tiling in 3 taps"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float stretchingFactor = 5.0f;\n\nconst float pi = 3.141592;\nconst vec2 hexRatio = vec2(1.0, sqrt(3.0));\n\n//credits for hex tiling goes to Shane (https://www.shadertoy.com/view/Xljczw)\n//center, index\nvec4 GetHexGridInfo(vec2 uv)\n{\n  vec4 hexIndex = round(vec4(uv, uv - vec2(0.5, 1.0)) / hexRatio.xyxy);\n  vec4 hexCenter = vec4(hexIndex.xy * hexRatio, (hexIndex.zw + 0.5) * hexRatio);\n  vec4 offset = uv.xyxy - hexCenter;\n  return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? \n    vec4(hexCenter.xy, hexIndex.xy) : \n    vec4(hexCenter.zw, hexIndex.zw);\n}\n\nfloat GetHexSDF(in vec2 p)\n{\n  p = abs(p);\n  return 0.5 - max(dot(p, hexRatio * 0.5), p.x);\n}\nstruct InterpNodes3\n{\n    vec2 positions[3];\n    uvec2 seeds[3];\n    vec3 weights;\n};\n\nInterpNodes3 GetTriangleInterpNodes(in vec2 pos, in float freq)\n{\n    InterpNodes3 interpNodes;\n    vec2 nodeOffsets[3] = vec2[](\n        vec2(0.0, 0.0),\n        vec2(1.0, 1.0),\n        vec2(1.0,-1.0));\n    for(uint nodeIndex = 0u; nodeIndex < 3u; nodeIndex++)\n    {\n        vec2 hexUv = pos * freq + nodeOffsets[nodeIndex] / hexRatio.xy * 0.5f;\n        vec4 hexInfo = GetHexGridInfo(hexUv);\n        interpNodes.positions[nodeIndex] = hexInfo.xy / freq;\n        interpNodes.seeds[nodeIndex] = uvec2(hexInfo.zw);\n        interpNodes.weights[nodeIndex] = GetHexSDF(hexUv - hexInfo.xy) * 2.0f;\n    }\n    return interpNodes;\n}\n    \n\nvec3 hash33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\nvec3 hash3u3f(uvec3 seed)\n{\n    uvec3 hash_uvec3 = hash33UintPcg(seed);\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nvec2 GetVelocity(vec2 pos)\n{\n    float ratio = abs(pos.y - iResolution.y * 0.5f) / (iResolution.y * 0.5f);\n    float scale = (1.0f - pow(clamp(pos.x / iResolution.x, 0.0f, 1.0f), 2.0f));\n    return vec2(100.0 * (1.0f - ratio * ratio), 0.0f) * scale;\n}\n\nmat2 GetVelocityTensor(vec2 pos)\n{\n    float eps = 1e-0f;\n    vec2 xp_velocity = GetVelocity(pos + vec2( eps, 0.0f));\n    vec2 xn_velocity = GetVelocity(pos + vec2(-eps, 0.0f));\n    vec2 yp_velocity = GetVelocity(pos + vec2(0.0f, eps));\n    vec2 yn_velocity = GetVelocity(pos + vec2(0.0f,-eps));\n    return mat2(xp_velocity - xn_velocity, yp_velocity - yn_velocity) / (2.0f * eps);\n}\n\n//from Qizhi Yu, et al [2011]. Lagrangian Texture Advection: Preserving Both Spectrum and Velocity Field. \n//IEEE Transactions on Visualization and Computer Graphics 17, 11 (2011), 1612â€“1623\nvec3 PreserveVariance(vec3 linearColor, vec3 meanColor, float moment2)\n{\n    return (linearColor - meanColor) / sqrt(moment2) + meanColor;\n}\n\n\nvec4 GetFlowImage(sampler2D tex, float tileFreq, vec2 coord, vec2 texSize, float phase, float stretchingFactor)\n{\n    vec4 color = vec4(0.0f);\n    InterpNodes3 interpNodes3 = GetTriangleInterpNodes(coord, tileFreq);\n    float moment2 = 0.0f;\n    for(uint i = 0u; i < 3u; i++)\n    {\n        vec2 velocity = GetVelocity(interpNodes3.positions[i]);\n        vec3 nodeHash = hash3u3f(uvec3(uvec2(interpNodes3.seeds[i]), 0));\n        mat2 stretchMat = mat2(1.0f, 0.0f, 0.0f, 1.0f) - GetVelocityTensor(interpNodes3.positions[i]) * stretchingFactor;\n        float randAng =2.0f * pi * nodeHash.z;\n        mat2 randomRotation = mat2(cos(randAng), sin(randAng), -sin(randAng), cos(randAng));\n        vec2 relUv = randomRotation * (stretchMat * (coord - interpNodes3.positions[i] - velocity * phase) / texSize);// + nodeHash.xy;\n        color += texture(tex, relUv) * interpNodes3.weights[i];\n        moment2 += interpNodes3.weights[i] * interpNodes3.weights[i];\n    }\n    return vec4(PreserveVariance(color.rgb, textureLod(tex, vec2(0.5f), 10.0f).rgb, moment2), 1.0f);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 normCoord = fragCoord / iResolution.xy;\n    ivec2 quadIndex2 = ivec2(normCoord * 2.0);\n    int quadIndex = quadIndex2.x + quadIndex2.y * 2;\n    \n    vec2 quadCoord = mod(fragCoord, iResolution.xy * 0.5) / (iResolution.x * 0.5);\n    \n    float texFreq = 10.0;\n    float tileFreq = 20.0;\n    fragColor = GetFlowImage(iChannel0, 0.03f, fragCoord, iResolution.xy * 0.1f, iTime, iMouse.z > 0.5f ? (iMouse.y / iResolution.y * 25.0f + 1.0f) : 25.0f);\n}","name":"Image","description":"","type":"image"}]}