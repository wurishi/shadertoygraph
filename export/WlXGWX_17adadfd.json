{"ver":"0.1","info":{"id":"WlXGWX","date":"1559093223","viewed":508,"name":"glitchscape","username":"ShnitzelKiller","description":"one man's garbage is also another man's garbage","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define LEVELS 3\n#define FDIST 0.5\n#define HEIGHT 5.5\n#define ITERS 20\n#define TOL 0.01\n#define SCALE 0.2\n#define GRADIENT_EPS 0.01\n#define REFLECTIONS 0\n#define n1 1.5\n#define n2 1.\n#define light_dir vec3(0.436436,0.872872,0.218218)\n#define ambient 0.5\n#define reflection_eps 0.01\n\nfloat R0 = (n1-n2)/(n1+n2);\n\nfloat cubemix(float a, float b, float t) {\n    float c = t*t*(3.-2.*t);\n    return mix(a, b, c);\n}\n\nfloat rand(vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nvec2 rand2d( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nvec2 unitvec(float ang) {\n    return vec2(cos(ang), sin(ang));\n}\n\n/*float perlin(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec3 offset = vec3(0.,1.,-1.);\n    vec2 grad00 = rand2d(iuv);\n    vec2 grad01 = rand2d(iuv+offset.xy);\n    vec2 grad10 = rand2d(iuv+offset.yx);\n    vec2 grad11 = rand2d(iuv+offset.yy);\n    vec2 disp = fract(uv);\n    float d00 = dot(disp, grad00);\n    float d01 = dot(disp+offset.xz, grad01);\n    float d10 = dot(disp+offset.zx, grad10);\n    float d11 = dot(disp+offset.zz, grad11);\n    float d0 = cubemix(d00, d01, disp.y);\n    float d1 = cubemix(d10, d11, disp.y);\n    return cubemix(d0, d1, disp.x);\n}\nfloat perlinfract(vec2 uv) {\n    float d = perlin(uv);\n    int i;\n    float fac = 1.;\n    for (i=0; i<LEVELS; i++) {\n        fac *= 0.5;\n        d += perlin(uv/fac)*fac;\n    }\n    return d;\n}*/\n\nfloat shitty(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec3 offset = vec3(0., 1.,-1.);\n    float rand00 = rand(iuv);\n    float rand01 = rand(iuv+offset.xy);\n    float rand10 = rand(iuv+offset.yx);\n    float rand11 = rand(iuv+offset.yy);\n    vec2 disp = fract(uv);\n    float d0 = cubemix(rand00, rand01, disp.y);\n    float d1 = cubemix(rand10, rand11, disp.y);\n    return cubemix(d0, d1, disp.x)-0.5;\n}\n\nfloat shittyfract(vec2 uv) {\n    float d = shitty(uv);\n    int i;\n    float fac = 1.;\n    for (i=0; i<LEVELS; i++) {\n        fac *= 0.5;\n        d += shitty(uv/fac)*fac;\n    }\n    return d;\n}\n\nfloat map(vec3 pos) {\n    float h = pos.y;\n    float heightmap = HEIGHT*shittyfract((pos.zx)*SCALE) + HEIGHT*shittyfract((pos.zx)*SCALE);\n    h -= heightmap;\n    h = cubemix(h, pos.y, h*0.1);\n    return h;\n}\n\nvec3 gradient(in vec3 pos) {\n    vec3 offset = vec3(-GRADIENT_EPS, 0.0, GRADIENT_EPS);\n    float dx0 = map(pos+offset.xyy);\n    float dxf = map(pos+offset.zyy);\n    float dy0 = map(pos+offset.yxy);\n    float dyf = map(pos+offset.yzy);\n    float dz0 = map(pos+offset.yyx);\n    float dzf = map(pos+offset.yyz);\n    //float ddd = map(pos);\n    return vec3(dxf - dx0, dyf - dy0, dzf - dz0)/(2.*GRADIENT_EPS);\n}\n\nfloat map2(vec3 pos) {\n    return map(pos)/length(gradient(pos));\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float d=0.;\n    int i;\n    for (i=0; i<ITERS; i++) {\n        float dist = map2(ro+d*rd);\n        d += dist;\n        if (abs(dist) < TOL) {\n\t\t\treturn vec2(d, 1.);\n        } /*else if (dist > MAXDIST) {\n            break;\n        }*/\n    }\n    return vec2(d, 0.);\n}\n\nfloat schlick(vec3 rd, vec3 n) {\n    return 1.-(R0+(1.-R0)*pow(max(dot(n.xyz, -rd), 0.), 5.0));\n}\n\nvec3 skycol(vec3 rd) {\n    return vec3(0.6, 0.7, 0.8)*(1.+pow(max(dot(rd, light_dir), 0.), 2.)) + pow(max(0.,dot(rd, light_dir)), 5.);\n}\n\nvec3 material(vec3 ro, vec3 rd, vec3 n, vec2 record) {\n    if (record.y > 0.5) {\n        vec3 color = vec3(0., 0.5, 0.9);\n        float fac = pow(max(ambient, dot(light_dir, n.xyz)), 3.);\n        return fac*color;\n    } else {\n        return skycol(rd);\n    }\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 n, vec2 record) {\n    vec3 shadedcolor = material(ro, rd, n, record);\n    if (record.y > 0.5) {\n        int i;\n        float final_albedo = 0.5;\n        for (i=0; i<REFLECTIONS; i++) {\n            if (record.y < 0.5) break;\n            final_albedo *= schlick(rd, n.xyz);\n            ro = ro+rd*record.x;\n            rd = reflect(rd, n.xyz);\n            ro += reflection_eps*rd;\n            record = raymarch(ro, rd);\n            n = normalize(gradient(ro+rd*record.x));\n            shadedcolor += final_albedo * material(ro, rd, n, record);\n        }\n        //compute last reflections with just envmap\n        if (record.y > 0.5) {\n            final_albedo *= schlick(rd, n.xyz);\n            shadedcolor += final_albedo * skycol(reflect(rd, n.xyz));\n        }\n    }\n    return shadedcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R0*=R0;\n    vec3 ro = vec3(0., 9., iTime);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 w = normalize(vec3(0., -0.2, 1.));\n    vec3 u = cross(w, up);\n    vec3 v = cross(u, w);\n    vec2 coord = fragCoord/iResolution.xy-0.5;\n    vec3 rd = normalize(w*FDIST+u*coord.x+v*coord.y);\n    \n    vec2 d = raymarch(ro, rd);\n    vec3 n = normalize(gradient(ro+d.x*rd));\n    vec3 col = shade(ro, rd, n, d);\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}