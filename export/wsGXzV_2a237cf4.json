{"ver":"0.1","info":{"id":"wsGXzV","date":"1574434785","viewed":170,"name":"don - Build SDF With Mouse","username":"koktszfung","description":"Esc: reset\nMouse: drag to add sdf\nKey (row): c - circle, r - rect, s - segment\n0 to 9 (col): choose layer\nshift: toggle add/sub mode(depends on layer's order)\nbackspace: delete selected cell (shape and layer number)","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["mouse","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n//\tray marching tools adapted from hughsk's 2D SDF Toy https://www.shadertoy.com/view/XsyGRW\n//\n\n#define TRACE_STEPS 20\n\n// 0 = BufferA\n// 1 = Distance Field Display\n// 2 = Raymarched Edges\n// 3 = Resulting Solid\n// 4 = Distance Field Polarity\n#define DISPLAY 1\nconst float PI = 3.14159265359;\nconst float MAX_D = 100.;\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  return coord/screenSize.y;\n}\n\nfloat add(float a, float b) {\n\treturn min(a, b);\n}\n\nfloat sub(float a, float b) {\n\treturn max(a, -b);\n}\n\n//\n// primitive signed distance function\n//\n\nfloat shape_circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat shape_rect(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) +  min(max(d.x, d.y), 0.0);  // out + in\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n  vec2 dir = b - a;\n  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n  if (length(b - a) == 0.) return length(p - a);\n  float d = shape_line(p, a, b);\n  float d0 = dot(p - b, b - a);\n  float d1 = dot(p - a, b - a);\n  return d1 < 0.0 ? length(a - p) : d0 > 0.0 ? length(b - p) : d;\n}\n\n\n//\n// create image using primitive sdf\n//\n\nfloat SAMPLER(vec2 p) {\n    float[30] ds;\n    for (int y = 0; y < 3; y++) {\n        for (int x = 0; x < 10; x++) {\n            int index = y * 10 + x;\n            vec4 ab = getPixel(iChannel0, x + 1, y + 1);\n            if (ab == COLOR_OFF) {\n            \tds[index] = MAX_D;\n                continue;\n            }\n            vec2 a = ab.xy, b = ab.zw;\n            switch (y) {\n                case 0:  // circle\n                {\n                    vec2 c = (a + b) * .5;\n                    float r = length(a - c);\n                    ds[index] = shape_circle(p - c, r);\n                    break;\n                }\n\n                case 1:  // rect\n                {\n                    vec2 c = (a + b) * .5;\n                    vec2 b = abs(b - a) * .5;\n                    ds[index] = shape_rect(p - c, b);\n                    break;\n                }\n\n                case 2:  // segment\n                {\n                    ds[index] = shape_segment(p, a, b) - .01;\n                    break;\n                }\n\n                default:\n                break;\n            }\n        }\n    }\n\n    float d = MAX_D;\n    for (int x = 0; x < 10; x++) {\n        for (int y = 0; y < 3; y++) {\n            int index = y * 10 + x;\n            if (getPixel(iChannel0, x + 1, NUM_SHAPE + 1) != COLOR_OFF) {\n                d = sub(d, ds[index]);\n            } else {\n                d = add(d, ds[index]);\n            }\n        }\n    }\n\treturn d*2.;\n}\n\n\n//\n// Ray Marching Visualization\n//\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n  p += iTime * -0.1 * sign(d) * vec2(0, 1);\n  p = mod(p + 0.06125, 0.125) - 0.06125;\n  float s = sign(d) * 0.5 + 0.5;\n  float base = draw_solid(d);\n  float neg = shape_rect(p, vec2(0.045, 0.0085) * 0.5);\n  float pos = shape_rect(p, vec2(0.0085, 0.045) * 0.5);\n  pos = min(pos, neg);\n  float pol = mix(neg, pos, s);\n\n  float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n  return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {\n  vec3 col = vec3(0);\n  vec3 line = vec3(1, 1, 1);\n  vec2 _ro = ro;\n\n  for (int i = 0; i < TRACE_STEPS; i++) {\n    float t = SAMPLER(ro);\n    col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n    col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n    col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n    ro += rd * t;\n    if (t < 0.01) break;\n  }\n\n  #ifdef TRACE_RAY\n    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);\n  #endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime * 0.5;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  d = SAMPLER(uv);\n\n  #if DISPLAY == 0\n    fragColor = getPixel(iChannel0, fragCoord*vec2(10./800., float(NUM_SHAPE + 1)/450.) + 1.);\n    return;\n  #endif\n\n  #if DISPLAY == 1\n    col = vec3(draw_distance(d, uv.xy));\n  #endif\n  #if DISPLAY == 2\n    col = vec3(0) + 1.0 - vec3(draw_line(d));\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 3\n    col = vec3(draw_solid(d));\n  #endif\n  #if DISPLAY == 4\n    col = vec3(draw_polarity(d, uv.xy));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n\n  vec4 bufferA = getPixel(iChannel0, fragCoord/10.);\n  if (bufferA != COLOR_OFF) fragColor = bufferA;  // display memory\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst int NUM_SHAPE = 3;\nconst int[NUM_SHAPE] KEYCODE_SHAPE = int[](67, 82, 83);\n\nconst vec4 COLOR_ON = vec4(1);\nconst vec4 COLOR_OFF = vec4(0);\n\n// read memory\nvec4 getPixel(sampler2D channel, ivec2 fragCoord) {\n\treturn texelFetch(channel, fragCoord, 0);\n}\n\nvec4 getPixel(sampler2D channel, vec2 fragCoord) {\n\treturn texelFetch(channel, ivec2(fragCoord), 0);\n}\n\nvec4 getPixel(sampler2D channel, int x, int y) {\n\treturn texelFetch(channel, ivec2(x, y), 0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void thumbnail(inout vec4 fragColor, vec2 fragCoord) {\n    // change value in buffer A directly\n    \n    // reset\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = COLOR_ON;\n    } else if (ivec2(fragCoord) == ivec2(0, 1)) {\n    \tfragColor = COLOR_ON;\n    } else {\n    \tfragColor = COLOR_OFF;\n    }\n\n    // add or subtract mode for each layer\n    if (int(fragCoord.y) == NUM_SHAPE + 1 && int(fragCoord.x) > 0) {\n        switch (int(fragCoord.x) - 1) {\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            fragColor = COLOR_ON;\n            break;\n        default:\n            break;\n        }\n    }\n    \n    // shape 1, circle\n    if (int(fragCoord.y) == 1 && int(fragCoord.x) > 0) {\n        switch (int(fragCoord.x) - 1) {\n            case 1:\n            fragColor.xy = vec2(330, 260) - 18.;\n            fragColor.zw = fragColor.xy + 36.;\n            break;\n            case 2:\n            fragColor.xy = vec2(374, 290) - 18.;\n            fragColor.zw = fragColor.xy + 36.;\n            break;\n            case 3:\n            fragColor.xy = vec2(426, 290) - 18.;\n            fragColor.zw = fragColor.xy + 36.;\n            break;\n            case 4:\n            fragColor.xy = vec2(470, 260) - 18.;\n            fragColor.zw = fragColor.xy + 36.;\n            break;\n            \n            case 5:\n            fragColor.xy = vec2(400, 200) - 35.;\n            fragColor.zw = fragColor.xy + 70.;\n            break;\n            case 6:\n            fragColor.xy = vec2(375, 180) - 25.;\n            fragColor.zw = fragColor.xy + 50.;\n            break;\n            case 7:\n            fragColor.xy = vec2(425, 180) - 25.;\n            fragColor.zw = fragColor.xy + 50.;\n            break;\n            \n            case 8:\n            fragColor.xy = vec2(470, 120) - 8.;\n            fragColor.zw = fragColor.xy + 16.;\n            break;\n        default:\n            break;\n        }\n        fragColor /= 450.;\n    }\n    \n    // shape 2, rect\n    if (int(fragCoord.y) == 2 && int(fragCoord.x) > 0) {\n        switch (int(fragCoord.x) - 1) {\n            case 0:\n            fragColor.xy = vec2(245, 380);\n            fragColor.zw = vec2(555, 70);\n            break;\n        default:\n            break;\n        }\n        fragColor /= 450.;\n    }\n    \n    // shape 3, segment\n    if (int(fragCoord.y) == 3 && int(fragCoord.x) > 0) {\n        switch (int(fragCoord.x) - 1) {\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            fragColor.xy = vec2(245, 70);\n            fragColor.zw = vec2(555, 380);\n            fragColor.yw += (fragCoord.x - 6.) * 70.;\n            break;\n        default:\n            break;\n        }\n        fragColor /= 450.;\n    }\n}\n\n\n\nvoid reset(inout vec4 fragColor, vec2 fragCoord) {\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = COLOR_ON;\n    } else if (ivec2(fragCoord) == ivec2(0, 1)) {\n    \tfragColor = COLOR_ON;\n    } else {\n    \tfragColor = COLOR_OFF;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // directly set values in buffer A for the thumbnail\n    if (iFrame == 0) {  // for the thumbnail\n        thumbnail(fragColor, fragCoord);\n        return;\n    }\n    \n    if (getPixel(iChannel1, 27, 1).r != 0.) {  // reset\n        reset(fragColor, fragCoord);\n        return;\n    }\n    \n    fragColor = getPixel(iChannel0, fragCoord);  // copy last frame    \n    \n    \n    \n    int x = int(fragCoord.x), y = int(fragCoord.y);\n    \n    // mouse\n    if (ivec2(x, y) == ivec2(0)) {\n        if (iMouse.z >= 0.) fragColor = iMouse.zwxy/iResolution.y;\n        return;\n    }\n    \n    // shape ( Circle Rect Segment )\n    if (x == 0 && y >= 1 && y <= NUM_SHAPE) {\n        for (int i = 0; i < NUM_SHAPE; i++) {\n            if (getPixel(iChannel1, KEYCODE_SHAPE[i], 1).r != 0.){  // check for keypress\n                if (y == i + 1) {\n                    fragColor =  COLOR_ON;\n                } else {\n                    fragColor = COLOR_OFF;\n                }\n                return;\n            }\n        }\n    }\n    \n    // number ( 0 - 9)\n    if (y == 0 && x >= 1 && x <= 10) {\n        for (int i = 0; i < 10; i++) {\n            if (getPixel(iChannel1, i + 48, 1).r != 0.){  // check for keypress\n                if (x == i + 1) {\n                    fragColor =  COLOR_ON;\n                } else {\n                    fragColor = COLOR_OFF;\n                }\n                return;\n            }\n        }\n    }\n\n    // blend mode\n    if (y == NUM_SHAPE + 1 && x >= 1 && x <= 10) {  // left click\n\t\tif (getPixel(iChannel0, x, 0).r != 0.) { // selected that number\n            if (getPixel(iChannel1, 16, 1).r != 0.) {\n                fragColor = (getPixel(iChannel0, x, NUM_SHAPE + 1).r != 0.)? COLOR_OFF : COLOR_ON;\n            }\n            return;\n        }\n    }\n  \n    // save\n    if (x > 0 && x <= 10 && y > 0 && y <= NUM_SHAPE) {\n        bool xSelected = getPixel(iChannel0, x, 0).r != 0.;\n        bool ySelected = getPixel(iChannel0, 0, y).r != 0.;\n        if (xSelected && ySelected) {\n            if (getPixel(iChannel1, 8, 1).r != 0.){\n            \tfragColor = COLOR_OFF;\n            } else if (iMouse.z > 0.){\n                fragColor = iMouse.zwxy/iResolution.y;\n                return;\n            }\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}