{"ver":"0.1","info":{"id":"wtjyRt","date":"1595127767","viewed":207,"name":"CRT Scanline Shadowmask v1","username":"Hatchling","description":"CRT simulation with scanlines, aperture grille (similar to shadow masking), curvature, vignetting and interlacing artifacts simulated. \n\nCurvature and vignetting credit goes to https://www.shadertoy.com/view/Ms23DR\n\n\n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["crt","scanline","shadowmask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SHADOWMASK_VERTGAPWIDTH = 0.02;\nconst float SHADOWMASK_VERTHARDNESS = 0.1;\n\nconst float SHADOWMASK_HORIZGAPWIDTH = -1.0;\nconst float SHADOWMASK_HORIZARDNESS = 0.8;\n\nconst float SHADOWMASK_RCOL_OFFSET = 0.0;\nconst float SHADOWMASK_GCOL_OFFSET = -0.3;\nconst float SHADOWMASK_BCOL_OFFSET = -0.6;\n\nconst float SCANLINE_RGAPWIDTH = 2.0;\nconst float SCANLINE_RHARDNESS = 1.0;\nconst float SCANLINE_ROFFSET = 0.0 + 0.08333333;\n\nconst float SCANLINE_GGAPWIDTH = 2.0;\nconst float SCANLINE_GHARDNESS = 0.5;\nconst float SCANLINE_GOFFSET = -0.1 + 0.08333333;\n\nconst float SCANLINE_BGAPWIDTH = 2.0;\nconst float SCANLINE_BHARDNESS = 0.3;\nconst float SCANLINE_BOFFSET = -0.15 + 0.08333333;\n\n// When increasing the overall scale, you may need to reduce the \"HARDNESS\" of the\n// CRT patterns to prevent aliasing.\n//const float OVERALL_SCALE = 240.0;\nconst float SHADOWMASK_UV_SCALE = 0.12;\nconst float SCANLINE_UV_SCALE = 60.0;\n\nconst float SINE_SCALE = 3.14159 * 2.0;\n\n\n// SHADOW MASK\n\nfloat Grille(float x, float offset, float multiplier)\n{\n\treturn smoothstep(0.0, 1.0, sin(x * SINE_SCALE) * multiplier + offset);    \n}\n\nfloat ShadowMaskRows(vec2 uv)\n{\n    // Stagger rows\n    uv.x *= 0.5;\n    uv.x -= round(uv.x);\n    if(uv.x < 0.0)\n        uv.y += 0.5;\n    \n    return Grille(uv.y, -SHADOWMASK_HORIZGAPWIDTH, SHADOWMASK_HORIZARDNESS);\n}\n\nfloat ShadowMaskSingleCol(float x)\n{\n    return Grille(x, -SHADOWMASK_VERTGAPWIDTH, SHADOWMASK_VERTHARDNESS);\n}\n\nvec3 ShadowMaskRGBCols(float x)\n{\n\treturn vec3\n    (\n        ShadowMaskSingleCol(x + SHADOWMASK_RCOL_OFFSET), \n        ShadowMaskSingleCol(x + SHADOWMASK_GCOL_OFFSET), \n        ShadowMaskSingleCol(x + SHADOWMASK_BCOL_OFFSET)\n    );    \n}\n\nvec3 ShadowMask(vec2 uv)\n{\n    return ShadowMaskRGBCols(uv.x) * ShadowMaskRows(uv);\n}\n\n// SCANLINE PATTERN\n\nfloat Scanline(float x, float offset, float multiplier)\n{\n\treturn tanh(sin(x * SINE_SCALE) * multiplier + offset) * 0.5 + 0.5;    \n}\n\nfloat Interlacing()\n{\n    // Add interlacing.\n    int frame = iFrame;\n    \n    // Add the following line to exaggerate interlacing effect.\n    frame /= 2;\n    \n    return frame % 2 == 0 ? \n        0.5 : 0.0;\n}\n\nvec4 Sample(sampler2D sampler, vec2 uv, float resolution)\n{\n    if(uv.x < 0.0 || uv.x > 1.0) return vec4(0);\n    if(uv.y < 0.0 || uv.y > 1.0) return vec4(0);\n    \n    float interlacing = Interlacing();\n    \n    uv *= resolution;\n    \n    uv.y += interlacing;\n    \n    vec2 uv1 = vec2(uv.x, ceil(uv.y));\n    vec2 uv2 = vec2(uv.x, floor(uv.y));\n    \n    float t = uv.y - floor(uv.y);\n    \n    t = smoothstep(0.0, 1.0, t);\n    //t = smoothstep(0.0, 1.0, t);\n    //t = smoothstep(0.0, 1.0, t);\n    \n    uv1.y -= interlacing;    \n    uv2.y -= interlacing;\n    \n    vec4 sample1 = texture(sampler, uv1 / resolution);\n    vec4 sample2 = texture(sampler, uv2 / resolution);\n    \n    return mix(sample2, sample1, vec4(t));\n}\n\nvec3 ScanlinesRGB(float y)\n{\n\ty += Interlacing();  \n    \n    // Real CRT images show differences in scattering and alignment\n    // between the RGB beams.\n    return vec3\n    (\n \t    Scanline(y + SCANLINE_ROFFSET, -SCANLINE_RGAPWIDTH, SCANLINE_RHARDNESS)   \n        ,\n \t    Scanline(y + SCANLINE_GOFFSET, -SCANLINE_GGAPWIDTH, SCANLINE_GHARDNESS)   \n        ,\n \t    Scanline(y + SCANLINE_BOFFSET, -SCANLINE_BGAPWIDTH, SCANLINE_BHARDNESS)   \n    );\n}\n\n// Taken from https://www.shadertoy.com/view/tdjyzz\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\n// COMPOSITE\n// CRT curvature and vignetting credit goes to https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    vec2 sampleUV = curve(uv);\n    vec2 shadowMaskUV = sampleUV * min(iResolution.xy, vec2(1920, 1080)) * SHADOWMASK_UV_SCALE;\n    vec2 scanlineUV = sampleUV * SCANLINE_UV_SCALE;\n    \n    // Input signal.\n    vec3 color = Sample(iChannel0, sampleUV, SCANLINE_UV_SCALE).rgb;\n    \n    // Convert to linear.\n    color = pow(color, vec3(2.2));\n    \n    // Amplify.\n    //color *= 1.0;\n    \n    // Vignette.\n    float vig = abs((1.0*16.0*sampleUV.x*sampleUV.y*(1.0-sampleUV.x)*(1.0-sampleUV.y)));\n\tcolor *= vec3(pow(vig,0.6));\n    \n    // Add scalines.\n    color *= ScanlinesRGB(scanlineUV.y) * 40.0;\n    \n    // Add shadowmask.\n    color *= ShadowMask(shadowMaskUV) * 500.0;\n\n    // Tonemap \n    color += vec3(rbgToluminance(color) * 0.05); // Allow colors to whiten when saturated.\n    color = color / (0.5 + color);\n    \n    // Convert to gamma.\n\tcolor = pow(color, vec3(1.0/2.2));\n    \n\tfragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}