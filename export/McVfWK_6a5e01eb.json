{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// This shader was made for learning purpose, inspired by the works of Inigo Quilez.\n// A lot of inspiration from the Bender Shader: https://www.shadertoy.com/view/XcGBWt\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0/(1.0-sqrt(0.5));\n    return max(k,min(a,b)) -\n           length(max(k-vec2(a,b),0.0));\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\nfloat opXor(float d1, float d2 )\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\nvec3 scale( in vec3 p, in vec3 s)\n{\n    return vec3(p.x / s.x, p.y / s.y, p.z/s.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdHat(in vec3 pos)\n{\n    vec3 cen = vec3(-0.12, 0.9, 0.);\n    vec3 q = pos - cen;\n    q.xy *= rot2D(0.8);\n    q = scale(q, vec3(1., 0.8, 1.2));\n    float b = sdSphere(q, 0.12);\n    \n    cen = vec3(0.1, 0.95, 0.0);\n    q = pos - cen;\n    q.xy *= rot2D(-0.2);\n    q = scale(q, vec3(1., 0.7, 1.2));\n    float f = sdSphere(q, 0.14);\n    \n    cen = vec3(0.0, 0.86, 0.0);\n    q = pos - cen;\n    q.xy *= rot2D(-0.0);\n    q = scale(q, vec3(1., 0.8, 1.1));\n    float m = sdSphere(q, 0.14);\n    \n    float p = sdRoundBox(pos - vec3(0.1, 0.85, 0.0), vec3(0.15, 0.01, 0.15), 0.03);\n    \n    return smin(smin(smin(b, f, 0.015), m, 0.018), p, 0.02);\n}\n\nfloat sdHead(in vec3 pos)\n{\n    vec3 cen = vec3(0., 0.5, 0.);\n    float h = sdRoundCone(pos - cen, 0.1, 0.15, 0.3);\n    \n    cen = vec3(0.1, 0.7, 0.0);\n    vec3 q = pos - cen;\n    q.xy *= rot2D(1.6);\n    float n = sdRoundCone(q, 0.04, 0.05, 0.2);\n    \n    pos.z = abs(pos.z);\n    q = pos - vec3(0.15, 0.7, 0.05);\n    q.yz *= rot2D(3.54);\n    q = scale(q, vec3(1., 0.8, 1.1));\n    float m = sdCutSphere(q, 0.08, 0.02);\n    \n    q = pos - vec3(0.13, 0.76, 0.05);\n    q = scale(q, vec3(1., 1.1, 1.0));\n    float e = sdSphere(q, 0.013);\n    \n    q = pos - vec3(-0.03, 0.72, 0.15);\n    q.yz *= rot2D(-0.2);\n    q = scale(q, vec3(0.8, 1.5, 0.9));\n    float ears = sdSphere(q, 0.033);\n    \n    //hair\n    q = pos - vec3(0.02, 0.7, 0.128);\n    q.yz *= rot2D(0.04);\n    float hairSide = sdRoundCone(q, 0.02, 0.03, 0.11);\n    q = pos - vec3(-0.05, 0.6, 0.);\n    float hairBack = sdRoundCone(q, 0.1, 0.15, 0.22);\n    q = pos - vec3(-0.02, 0.78, 0.13);\n    float hairUpSide = sdSphere(q, 0.022);\n    \n    float hair = smin(min(hairSide, hairBack), hairUpSide, 0.021);\n    \n    return min(min(min(min(min(h, n), m), e), ears), hair);\n}\n\nfloat sdBodyBase(vec3 pos)\n{\n    vec3 cen = vec3(0., 0.18, 0.1);\n    vec3 q = pos - cen;\n    q.yz *= rot2D(0.5);\n    \n    float dl = sdRoundCone(q, 0.06, 0.14, 0.2);\n    \n    cen = vec3(0., 0.18, -0.1);\n    q = pos - cen;\n    q.yz *= rot2D(-0.5);\n    float dr = sdRoundCone(q, 0.06, 0.14, 0.2);\n    float base = smin(dl, dr, 0.005);\n    return base;\n}\n\nfloat sdBody(in vec3 pos)\n{\n    float base = sdBodyBase(pos);\n    float biggerBase = base - 0.008;\n    \n    float dsub0 = sdBox(pos - vec3(0.0, 0.45, 0.0), vec3(0.3, 0.08, 0.06));\n    \n    biggerBase = opSubtraction(dsub0, biggerBase);\n    \n    base = min(base, biggerBase);\n    \n    float dc = sdTorus(pos - vec3(0., 0.45, 0.0), vec2(0.1, 0.02));\n    \n    float overall = smin(base, dc, 0.003);\n    \n    pos.z = abs(pos.z);\n    float but = sdSphere(pos - vec3(0.08, 0.38, 0.09), 0.038);\n    overall = min(overall, but);\n    float a0 = sdCapsule(pos - vec3(0., 0.4, 0.), vec3(0., 0., 0.4), vec3(0.), 0.05);\n    float h = sdSphere(pos - vec3(0.0, 0.4, 0.39), 0.07);\n    float a = min(a0, h);\n    \n    float sh0 = sdCutSphere(pos - vec3(0.07, 0.1, 0.12), 0.08, 0.02);\n    float sh1 = sdCutSphere(pos - vec3(-0.02, 0.1, 0.07), 0.06, 0.02);\n    float sh = smin(sh0, sh1, 0.02);\n    \n    return min(min(overall, a), sh);\n}\n\nvec4 sdHatColor(in vec3 pos)\n{\n    vec4 res = vec4(0., 0.1, 0.9, 0.15);\n    vec3 cen = vec3(-0.1, 0.9, 0.);\n    vec3 q = pos - cen;\n    q.xy *= rot2D(0.8);\n    q = scale(q, vec3(1., 0.8, 1.2));\n    float b = sdSphere(q, 0.11);\n    \n    cen = vec3(0.1, 0.95, 0.0);\n    q = pos - cen;\n    q.xy *= rot2D(-0.2);\n    q = scale(q, vec3(1., 0.7, 1.2));\n    float f = sdSphere(q, 0.14);\n    \n    cen = vec3(0.0, 0.86, 0.0);\n    q = pos - cen;\n    q.xy *= rot2D(-0.0);\n    q = scale(q, vec3(1., 0.8, 1.1));\n    float m = sdSphere(q, 0.14);\n    \n    float p = sdRoundBox(pos - vec3(0.1, 0.85, 0.0), vec3(0.15, 0.01, 0.15), 0.03);\n    \n    float d = smin(smin(smin(b, f, 0.015), m, 0.018), p, 0.02);\n    res.x = d;\n    return res;\n}\n\nvec4 findMinX(vec4 vecs[4]) {\n    vec4 minVec = vecs[0];\n    for (int i = 1; i < 4; i++) {\n        if (vecs[i].x < minVec.x) {\n            minVec = vecs[i];\n        }\n    }\n    return minVec;\n}\n\nvec4 sdHeadColor(in vec3 pos)\n{\n    vec4 res = vec4(0., 1., 0.7, 0.5);\n    vec3 cen = vec3(0., 0.5, 0.);\n    vec4 h = vec4(sdRoundCone(pos - cen, 0.1, 0.15, 0.3), 0.8, 0.55, 0.4);\n    \n    cen = vec3(0.1, 0.7, 0.0);\n    vec3 q = pos - cen;\n    q.xy *= rot2D(1.6);\n    vec4 n = vec4(sdRoundCone(q, 0.04, 0.05, 0.2), 0.8, 0.55, 0.4);\n    \n    pos.z = abs(pos.z);\n    q = pos - vec3(0.15, 0.7, 0.05);\n    q.yz *= rot2D(3.54);\n    q = scale(q, vec3(1., 0.8, 1.1));\n    float m = sdCutSphere(q, 0.08, 0.02);\n    \n    q = pos - vec3(-0.03, 0.72, 0.15);\n    q.yz *= rot2D(-0.2);\n    q = scale(q, vec3(0.8, 1.5, 0.9));\n    float ears = sdSphere(q, 0.033);\n    h.x = min(h.x, ears);\n    \n    q = pos - vec3(0.13, 0.76, 0.05);\n    q = scale(q, vec3(1., 1.1, 1.0));\n    vec4 e = vec4(min(sdSphere(q, 0.013), m), 0., 0., 0.);\n    \n    //hair\n    q = pos - vec3(0.02, 0.7, 0.128);\n    q.yz *= rot2D(0.04);\n    float hairSide = sdRoundCone(q, 0.02, 0.03, 0.11);\n    q = pos - vec3(-0.05, 0.6, 0.);\n    float hairBack = sdRoundCone(q, 0.1, 0.15, 0.15);\n    q = pos - vec3(-0.02, 0.78, 0.13);\n    float hairUpSide = sdSphere(q, 0.022);\n    \n    vec4 hair = vec4(smin(min(hairSide, hairBack), hairUpSide, 0.021), 0.08, 0.05, 0.01);\n\n    vec4 vecs[4] = vec4[](e, hair, n, h);\n    res = findMinX(vecs);\n    res.yzw *= 0.6;\n    return res;\n}\n\nvec4 sdBodyColor(in vec3 pos)\n{\n    vec4 res = vec4(0., 0., 0.1, 1.);\n    float base = sdBodyBase(pos);   \n    float biggerBase = base - 0.008;\n    float dsub0 = sdBox(pos - vec3(0.0, 0.45, 0.0), vec3(0.3, 0.08, 0.06));\n    \n    float dc = sdTorus(pos - vec3(0., 0.45, 0.0), vec2(0.1, 0.01));\n    base = smin(base, dc, 0.003);\n    \n    biggerBase = opSubtraction(dsub0, biggerBase);\n    \n    vec4 b1 = vec4(base, 0.1, 0.9, 0.15);\n    vec4 b2 = vec4(biggerBase, 0., 0.1, 1.);\n    \n    vec4 vecs[4] = vec4[](b1, b2, b1, b2);\n    vec4 overall = findMinX(vecs);\n    \n    pos.z = abs(pos.z);\n    vec4 but = vec4(sdSphere(pos - vec3(0.08, 0.38, 0.09), 0.038), 1.0, 0.9, 0.2);\n    float a0 = sdCapsule(pos - vec3(0., 0.4, 0.), vec3(0., 0., 0.4), vec3(0.), 0.05);\n    float h = sdSphere(pos - vec3(0.0, 0.4, 0.39), 0.07);\n    vec4 a = vec4(min(a0, h), 0.1, 0.9, 0.15);\n    if (h < a0) {\n        a.yzw = vec3(1., 1., 1.);\n    }\n    \n    float sh0 = sdCutSphere(pos - vec3(0.07, 0.1, 0.12), 0.08, 0.02);\n    float sh1 = sdCutSphere(pos - vec3(-0.02, 0.1, 0.07), 0.06, 0.02);\n    vec4 sh = vec4(smin(sh0, sh1, 0.02), 0.08, 0.055, 0.018);\n    \n    vecs = vec4[](sh, overall, but, a);\n    res = findMinX(vecs);\n    res.yzw *= 0.6;\n    return res;\n}\n\nvec3 colorMap(in vec3 pos)\n{\n    vec3 offset = vec3(0., -0.39, 0.);\n    vec4 dHead = sdHeadColor(pos - offset);\n    vec4 dBody = sdBodyColor(pos - offset);\n    vec4 dHat = sdHatColor(pos - offset);\n    vec4 d2 = vec4(pos.y + .3, 0.07,0.14,0.05);\n    \n    vec4 vecs[4] = vec4[](dHead, dBody, dHat, d2);\n    vec4 r = findMinX(vecs);\n    \n    return r.yzw;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 offset = vec3(0., -0.39, 0.);\n    float dHead = sdHead(pos - offset);\n    float dBody = sdBody(pos - offset);\n    float dHat = sdHat(pos - offset);\n    float d2 = pos.y + .3;\n    \n    return min(min(min(dHead, d2), dBody), dHat);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + rd*t;\n        \n        float h = map(pos);\n        \n        if (h < 0.001) break;\n        \n        t += h;\n        if (t >= 20.) break;\n    }\n    if (t > 20.)\n        t = -1.;\n    return t;\n}\n\n// from the Bender shader\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.001 || t>5.0 ) break;\n\t\tt += clamp( h, 0.005, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float an = 10. * iMouse.x / iResolution.x;\n\n\n    //raymarching\n    vec3 ta = vec3(0., .2, 0.); //target point\n    vec3 ro = ta + vec3(1.5*sin(an), .1, 1.5*cos(an));\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0., 1., 0.))); // find side\n    vec3 vv = normalize(cross(uu, ww)); //find up\n    \n    vec3 rd = normalize(vec3(uv.x*uu + uv.y*vv + 1.8*ww)); // -1.5 is the near plane position\n    \n    \n    vec3 skyCol = vec3(.4, .75, 1.) - .7*rd.y;\n    skyCol = mix(skyCol, vec3(.7, .75, .8), exp(-10. * rd.y));\n    vec3 col = skyCol;\n    \n    float t = castRay(ro, rd);\n    \n    if (t > 0.) {\n        vec3 pos = ro + rd*t;\n        vec3 normal = calcNormal(pos);\n        vec3 mate = colorMap(pos);\n        \n        // lighting \n        const vec3 lig = normalize(vec3(0.8,0.6,0.3));\n\t\tfloat dif = max(dot(normal,lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*normal, lig, 0.0005, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(normal,rd), 0.0, 1.0 ), 5.0 );\n        vec3 brdf = vec3(0.0);\n        brdf += 1.5*sha;\n\t\tbrdf += 0.75;\n        brdf += 0.7*smoothstep(0.1,0.15,fre*sha); // edge of color\n        \n        col = mate*brdf;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McVfWK","date":"1734552528","viewed":88,"name":"Luigi SDF Colored","username":"KivuSupremeKing","description":"Luigi SDF, but now in colors.\nI tried learning toon effect from the bender shader of Inigo Quilez: https://www.shadertoy.com/view/XcGBWt\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}