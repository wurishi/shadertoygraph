{"ver":"0.1","info":{"id":"lsdcRM","date":"1518287724","viewed":341,"name":"Glowing Game of Life","username":"Scoo","description":"Game of life simulation + glowing visualization.\nEach cell tracks how many times it has been alive and that is used to determine its color.\nMouse input affects the simulation.\n\nSometimes doesn't initialize to noise on load. Reset time to load it again.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["simulation","interactive","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Game of Life visualization.\n// The state is updated in the BufA shader.\n\n// Samples a color gradient at the specified value in [0.0, 1.0].\nvec3 getGradient(float value) {\n    const vec3 background = vec3(0.0);\n    const vec3 color1 = vec3(0.1, 0.8, 0.6);\n    const vec3 color2 = vec3(0.2, 0.3, 0.8);\n    const vec3 color3 = vec3(0.7, 0.4, 0.2);\n    const vec3 color4 = vec3(0.8, 0.3, 0.3);\n    if (value < 0.25) {\n        return mix(background, color1, value * 4.0);\n    } else if (value < 0.5) {\n        return mix(color1, color2, (value - 0.25) * 4.0);\n    } else if (value < 0.75) {\n        return mix(color2, color3, (value - 0.50) * 4.0);\n    } else {\n        return mix(color3, color4, (value - 0.75) * 4.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = fragCoord / iResolution.xy / ZOOM_FACTOR;\n    vec4 state = texture(iChannel0, uv, 0.0);\n    \n    vec3 gradientColor = getGradient(state.y / 100.0);\n    if (state.x > 0.0) {\n\t    fragColor = vec4(gradientColor, 1.0);\n    } else {\n        // Display the color with reduced intensity.\n        const float blackMix = 0.7;\n        fragColor = vec4(mix(gradientColor, vec3(0.0), blackMix), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Game of Life simulation.\n// * Each cell (texel) updates its state every frame based on the\n//   state of neighboring cells.\n// * Clicking the mouse sets the cell under the cursor to 'alive'.\n// * The resulting state is visualizated in the Image shader.\n\n// Flip this off to start with an empty canvas.\n#define SEED_WITH_NOISE 1\n\n// Computes the new simulation state at a texel based on the Game of Life rules.\n// https://en.wikipedia.org/wiki/Conway's_Game_of_Life\nvec4 updateState(vec2 fragCoord) {    \n    vec4 previousState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Count the number of neighbors that are alive.\n    float neighborCount = 0.0;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,  1), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, -1), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1,  1), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1,  0), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, -1), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1,  1), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1,  0), 0).x;\n    neighborCount += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, -1), 0).x;\n    \n    // Update state according the rules.\n    float alive = previousState.x;\n    if (alive > 0.0) {\n        if (neighborCount < 2.0) {\n            alive = 0.0;  // Die from underpopulation\n        } else if (neighborCount <= 3.0) {\n            alive = 1.0;  // Survive to next generation\n        } else {\n            alive = 0.0;  // Die from overpopulation\n        }\n    } else {\n        if (neighborCount == 3.0) {\n            alive = 1.0;  // Born through reproduction\n        } else {\n            alive = 0.0;  // Remain dead\n        }\n    }\n    \n    // Set the cell under the mouse to be alive.\n    if (distance(fragCoord, iMouse.xy / ZOOM_FACTOR) < 1.0) {\n        alive = 1.0;\n    }\n    \n    vec4 newState = previousState;\n    // state.x is the standard Game of Life state: 0.0 = dead, 1.0 = alive.\n    newState.x = alive;\n    \n    // state.y is moves between 0.0 and 100.0 as state.x updates.\n    // The visualization in the other shader can use this for effects.\n    if (alive > 0.0) {\n    \tnewState.y = mod(newState.y + alive, 100.0);\n    } else {\n        const float decayAmount = 0.02;\n        newState.y = clamp(newState.y - decayAmount, 0.0, 100.0);\n    }\n    \n    return newState;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #if SEED_WITH_NOISE\n    if (iTime <= 0.2 || iFrame == 0) {\n    \tvec2 uv = fragCoord / iResolution.xy;\n    \tfragColor = vec4(texture(iChannel1, uv).x, 0.0, 0.0, 1.0);\n        return;\n    }\n    #endif\n    \n    fragColor = updateState(fragCoord);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Adjust this to zoom in or out (2.0 = magnify 2x, etc.).\nconst float ZOOM_FACTOR = 2.0;","name":"Common","description":"","type":"common"}]}