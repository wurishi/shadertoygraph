{"ver":"0.1","info":{"id":"l3XSzH","date":"1709556142","viewed":47,"name":"Newtons Fractal rubbish","username":"njberman","description":"maths","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["maths"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926536\n#define MAX_ITERS 200\n\nfloat arg(vec2 z)\n{\n    return atan(z.y/z.x)+PI;\n}\n\nvec2 cpow(vec2 x, vec2 y)\n{\n    float a = x.x;\n    float b = x.y;\n    float c = y.x;\n    float d = y.y;\n    float asbs = pow(a,2.0)+pow(b,2.0);\n    float an = c*arg(x)+0.5*d*log(asbs);\n    \n    return pow(asbs, c/2.0) * vec2(cos(an), sin(an));\n}\n\nvec2 add(vec2 x, vec2 y)\n{\n    return vec2(x.x+y.x,x.y+y.y);\n}\n\nvec2 sub(vec2 x, vec2 y)\n{\n    return vec2(x.x-y.x,x.y-y.y);\n}\n\nvec2 div(vec2 x, vec2 y)\n{\n    float a = x.x;\n    float b = x.y;\n    float c = y.x;\n    float d = y.y;\n    float den = c*c + d*d;\n    return vec2((a*c+b*d)/den, (b*c-a*d)/den);\n}\n\nvec2 mul(vec2 x, vec2 y)\n{\n    float a = x.x;\n    float b = x.y;\n    float c = y.x;\n    float d = y.y;\n    return vec2(a*c-b*d, a*d+b*c);\n}\n\nvec2 P(vec2 z)\n{\n    //return cpow(z, vec2(3.0, 0.0)) - z;\n    vec2 x = z-root[0];\n    for (int i = 1; i < root.length(); i++)\n    {\n        x = cmplxmult(z-root[i], x);\n    }\n    return x;\n}\n\nvec2 Pp(vec2 z)\n{\n    return 3.0*cmplxmult(z,z) - cmplxmult(2.0*(root[0] + root[1] + root[2]), z) + (cmplxmult(root[0], root[1]) + cmplxmult(root[0], root[2]) + cmplxmult(root[1], root[2]));\n}\n\nvec2 newton(vec2 z)\n{\n    //int maxts = int(floor(iTime/1000.0));\n    for (int i = 0; i < MAX_ITERS; i++)\n    {\n        z = z - div(P(z), Pp(z));\n    }\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float a1 = iTime;\n    float a2 = a1 + 2.0*PI/3.0;\n    float a3 = a2 + 2.0*PI/3.0;\n    \n    float r = sqrt(0.5);\n    float r1 = r+(0.25+0.02*sin(a2))*sin(a1/(0.25));\n    float r2 = r+(0.25+0.02*sin(a3))*sin(a2/0.25);\n    float r3 = r+(0.25+0.02*sin(a1))*sin(a3/0.25);\n    \n    root[0] = vec2(r1*sin(a1), r1*cos(a1));\n    root[1] = vec2(r2*sin(a2), r2*cos(a2));\n    root[2] = vec2(r3*sin(a3), r3*cos(a3));\n    \n    vec2 res = newton(p);\n\n    vec3 col = vec3(0.0);\n\n    for (int i = 0; i < root.length(); i++)\n    {\n        float d = length(p - root[i]);\n        if (d - 0.05 < 0.001)\n        {\n            col = vec3(1.0)*d;\n            break;\n        }\n        if (length(res - root[i]) < 0.001)\n        {\n            col = cols[i];\n            break;\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 root[3] = vec2[] (\n    vec2(-sqrt(0.5), 0.0),\n    vec2(0.5, 0.5),\n    vec2(0.5, -0.5)\n);\n\nvec3 cols[3] = vec3[] (\n    normalize(vec3(244.0,96.0,54.0)),\n    normalize(vec3(46.0,41.0,78.0)),\n    normalize(vec3(27.0,153.0,139.0))//27,153,139\n);\n\nvec2 cmplxmult(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x - a.y*b.y, a.y*b.x + a.x*b.y);\n}\nvec2 cmplxcjg(vec2 x) { // conjugation\n    return vec2(x.x, - x.y);\n}\nvec2 cmplxdiv(vec2 a, vec2 b) { // complex division a/b\n    return cmplxmult(a, cmplxcjg(b)) / (b.x*b.x + b.y*b.y);\n}\n\n// using these saved ~3 fps\nfloat Q_sqrt(float x) {\n    float o = uintBitsToFloat((floatBitsToUint(x) >> 1) + 0x1FBC0000u);\n    o = 0.5 * (o + x / o); // newton method\n    return o;\n}\n\nfloat Q_length(vec2 p) {\n    return Q_sqrt(dot(p, p));\n}\n\nfloat minDistToRoot(vec2 uv) {\n    float d = 1000000.;\n    for(int i = 0; i < root.length(); i++) {\n        d = min(d, Q_length(uv - root[i]));\n    }\n    return d;\n}","name":"Common","description":"","type":"common"}]}