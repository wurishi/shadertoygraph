{"ver":"0.1","info":{"id":"WldXzf","date":"1581464258","viewed":415,"name":"discrete sine transform fluid","username":"public_int_i","description":"alternative to https://www.shadertoy.com/view/WtdXRX testing to see what the differences between sine and cosine transform have on the simulation","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["simulation","fluid","sine","physics","discrete","transform","dst"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, in vec2 u)\n{\n    o = vec4(length(texelFetch(iChannel0,ivec2(u),0))*.3);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\n\n#define TURBULENCE 1.5\n#define DIFFUSION 1e-8","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A - X axis forward sine transform + stochastic advection\n\n#define R4P 1.1673039782614187\nvec4 r4(float n) {\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash4(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat pmod(float v, float m) {\n \tif (v < 0.) return m-mod(-v,m)-1.;\n    return mod(v,m);\n}\n\nvec2 advec(float x, float y) {\n    vec2 v = -texelFetch(iChannel0,ivec2(x,y),0).xy;\n    v += (hash4(vec4(x,y,v.x+float(iFrame)/1000.,v.y)*11.1627863).xy-.5)*TURBULENCE;\n    return texelFetch(iChannel0, ivec2(pmod(v.x+x,iResolution.x),pmod(v.y+y,iResolution.y)),0).xy;\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.x; i++) s += advec(i,u.y)*sin((1.+i)*PI*floor(1.+u.x)/(1.+iResolution.x));\n\to = vec4(s,0,0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Buffer B - Y axis forward sine transform + frequency space fluid processing\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*sin((1.+i)*PI*floor(1.+u.y)/(1.+iResolution.y));\n    \n    //frequency space processing\n    \n    //rescaling\n    s /= (iResolution.x+1.)*(iResolution.y+1.)*.25;\n    \n    //mass conservation, this is the core of the fluid sim\n    float len = length(s);\n    vec2 nu = normalize(floor(u));\n    s -= nu*dot(nu,s);\n    s *= len/(DIFFUSION+length(s));\n    \n    //prevent drifting\n    if (dot(u,u) < 1.) s = vec2(0);\n    if (min(u.x,u.y) < 1.) s *= max(u.x/iResolution.x,u.y/iResolution.y);\n    \n    o = vec4(s,0,0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Buffer C - Y axis inverse sine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*sin((1.+i)*PI*floor(1.+u.y)/(1.+iResolution.y));\n    o = vec4(s,0,0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Buffer D - X axis inverse sine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = 0.; i < iResolution.x; i++) s += texelFetch(iChannel0,ivec2(i,u.y),0).xy*sin((1.+i)*PI*floor(1.+u.x)/(1.+iResolution.x));\n     \n    //add velocity forces\n    s += (pow(texture(iChannel1,u/iResolution.xy).xy,vec2(2.2))*2.-1.)*.05;\n    if (iMouse.w > 0.) {\n       \tvec2 d = u-iMouse.xy;\n     \ts += normalize(d)*max(0.,1.-length(d)/40.);\n    }\n    \n    o = vec4(s,0,0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}