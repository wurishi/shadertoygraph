{"ver":"0.1","info":{"id":"ts3GD8","date":"1568326477","viewed":148,"name":"Bendy Buildings","username":"pocketCoffee","description":"Makin' some ray marchin'.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting","shadows","materials","city","buildings"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.0\n#define EPSILON 0.001\n\n// First ray marcher! Borrowed some code from IQ and various youtube tutorials.\n\n// Structs\nstruct Mat{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 shininess;\n};\n\nstruct Light{\n\tvec3 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct Hit{\n    float d; // distance at hit\n    Mat mat;\n};\n\n    \n// SD Shapes\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// Box rounded edges cause weird things to happen\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n      return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat Plane(vec3 p, float h){\n    return p.y - h;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPyramid(vec3 p, vec3 h )\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa);\n }\n\n// Transforms\n// Rotation\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Bool Functions\nfloat boolSmoothSubtract(float a, float b, float k){\n    float h = clamp( 0.5 - 0.5*(a+b)/k, 0.0, 1.0 );\n    return mix( b, -a, h ) + k*h*(1.0-h);\n}\n\nfloat boolAdd(float a, float b){\n    return min(a, b);\n}\n\nfloat boolSmoothAdd(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat boolSubtraction( float d1, float d2 ) {\n\treturn max(-d1,d2); \n}\n\nvec3 opBend(vec3 p, float bend)\n{\n    float c = cos(bend * p.y);\n    float s = sin(bend * p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Models\nfloat leftBuilding(vec3 p){\n    p = opBend(p, -0.1);\n    float box = sdBox(p, vec3(1.5, 4., 1));\n    float ceiling = sdBox(p + vec3(0,-3.8,0), vec3(1.65, .1, 1.3));\n    float window0 = sdBox(p + vec3(-1.4, -1.8, .65), vec3(.14, .2, .1));\n    float window1 = sdBox(p + vec3(-1.4, -1.4, -.3), vec3(.14, .2, .1));\n    float window2 = sdBox(p + vec3(-1.4, -.7, .1), vec3(.14, .2, .1));\n    float windows = min(min(window2, window0), window1);\n\tfloat door = sdBox(p + vec3(-1.4, .4, .5), vec3(.15, .6, .1));\n    float shape1 = min(windows, door);\n    box = min(box, ceiling);\n    float building = boolSubtraction(shape1, box);\n\n    return building;\n}\n\nfloat rightBuilding(vec3 p){\n    p = opBend(p, 0.1);\n    float box = sdBox(p, vec3(1.5, 4., 1));\n    float ceiling = sdBox(p + vec3(0,-3.8,0), vec3(1.65, .1, 1.3));\n    float window0 = sdBox(p + vec3(1.4, -2.1, .1), vec3(.14, .2, .1));\n    float window1 = sdBox(p + vec3(1.4, -1.6, -.5), vec3(.14, .2, .1));\n    float window2 = sdBox(p + vec3(1.4, -.7, .1), vec3(.14, .2, .1));\n    float windows = min(min(window1, window0), window2);\n\tfloat door = sdBox(p + vec3(1.4, .4, -.3), vec3(.15, .6, .1));\n    float shape1 = min(windows, door);\n    box = min(box, ceiling);\n    float building = boolSubtraction(shape1, box);\n\n    return building;\n}\n\nfloat lamp(vec3 p){\n    float capsule0 = sdVerticalCapsule(p + vec3(0., 1., 0.), 1.5, .05);\n    float capsule1 = sdCapsule(p + vec3(.25, -.4, 0), vec3(.5, 0, 0), vec3(0, .0, 0), .015);\n    float bottom = sdBox(p + vec3(0, .95, 0), vec3(.16, .05, .16));\n    float middle = sdBox(p + vec3(0, .8, 0), vec3(.08, .1, .08));\n    vec3 lp = p + vec3(0, -.75, 0);\n    vec3 lpb = p + vec3(0, -.5, 0);\n    vec3 lpt = p + vec3(0, -.8, 0);    \n    lp.yz *= Rot(1.6);\n    lpb.yz *= Rot(1.6);\n\n    float lightTop = sdPyramid(lpt, vec3(.4, .4, .06));\n    float lightBottom = sdHexPrism(lpb, vec2(.15, .02));\n    float lightCombo1 = min(lightBottom, lightTop);\n    float lightCombo2 = min(lightCombo1, lightBottom);\n    float shape0 = min(middle, bottom);\n    float shape1 = min(capsule0, capsule1);\n    float shape2 = min(lightCombo2, shape1);\n    float lamp = boolSmoothAdd(shape2, shape0, 0.2);\n    return lamp;\n}\n\nfloat lampLight(vec3 p){\n    vec3 lp = p;\n    lp += vec3(0, -.65, 0);\n\tlp.yz *= Rot(1.6);\n\tfloat light = sdHexPrism(lp, vec2(.11, .13));\n    return light;\n}\n\nfloat sidewalk(vec3 p){\n\tfloat box = sdBox(p, vec3(2.5, .05, 4));\n    return box;\n}\n\n// Define materials\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nbool isHit = false;\n\nHit map(in vec3 p){\n    vec3 bp1 = p + vec3(0, 0, 0);\n    bp1.xz *= Rot(iTime);\n    bp1.xy *= Rot(iTime);\n    \n    vec3 cp = vec3(p);\n    cp.yz *= Rot(90.);\n    \n    vec3 lp = p + vec3(.84, 0, 4);\n    \n    float plane0 = Plane(opRep(p, vec3(0,0,5.)), -1.);\n    float building0 = leftBuilding(opRep(p + vec3(3, 0., 2.), vec3(0, 0, 4.)));\n    float building1 = rightBuilding(opRep(p + vec3(-3., 0., 1.), vec3(0, 0, 6.)));\n    float building2 = leftBuilding(opRep(p + vec3(2.9, 0., 0.), vec3(0, 0, 12.)));\n    //float building3 = leftBuilding(p + vec3(3, 0., 4.5));\n\t//float building4 = rightBuilding(opRep((p + vec3(-3., 0., 0.)), vec3(0, 0, 4.)));\n\t//float building5 = rightBuilding(p + vec3(-3., 0., -3.));\n    float lamp0 = lamp(opRep(lp + vec3(-2., 0, 0), vec3(0, 0, 12.)));\n    float lampLight0 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float lamp1 = lamp(opRep(lp, vec3(0,0,12.)));\n    float lampLight1 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float sidewalk0 = sidewalk(opRep(p + vec3(3., 1, 1), vec3(0,0,4.)));\n    float sidewalk1 = sidewalk(opRep(p + vec3(-3.5, 1, 1), vec3(0,0,4.))); \n    float sidewalks = min(sidewalk0, sidewalk1);\n    \n    \n    //float greenBuildings = min(building0, building1);\n    //float redBuildings = min(building2, building3);\n    //float blueBuildings = min(building4, building5);\n    \n    float shape0 = min(plane0, building0);\n    float shape1 = min(shape0, building1);\n    float shape2 = min(shape1, lamp1);\n    float shape9 = min(shape2, lampLight1);\n    float shape7 = min(shape9, sidewalks);\n    float shape10 = min(shape7, building2);\n    //float shape11 = min(shape10, building4);\n    \n    float result = shape10;\n    Hit hit;\n    hit.d = result;\n    \n    return hit;\n}\n\nMat AddMatStuff(Mat matResult, float stepResult, Mat matSample){\n    // Adds sampled material to a resulting material depending on step function float\n    matResult.ambient += matSample.ambient * stepResult;\n    matResult.diffuse += matSample.diffuse * stepResult;\n    matResult.specular += matSample.specular * stepResult;\n    matResult.shininess += matSample.shininess * stepResult;\n    return matResult;\n}\n\nfloat hash(vec2 coords){\n    return sin(coords.x + coords.y);\n    \n}\n\nMat ChooseMaterial(vec3 p){\n    // Make material to add to\n    Mat mat = Mat(vec3(0), vec3(0), vec3(0), vec3(0));\n    \n    // Building calculations\n    float building0 = leftBuilding(opRep(p + vec3(3, 0., 2.), vec3(0, 0, 4.)));\n    float building1 = rightBuilding(opRep(p + vec3(-3., 0., 1.), vec3(0, 0, 6.)));\n    float building2 = leftBuilding(opRep(p + vec3(2.9, 0., 0.), vec3(0, 0, 12.)));\n\t//float building3 = rightBuilding(opRep((p + vec3(-3., 0., 0.0)), vec3(0, 0, 4.)));\n    //building0 = min(building0, building3);\n    \n    // Street light calculations\n    vec3 lp = p + vec3(.84, 0, 4);\n    float lamp0 = lamp(opRep(lp + vec3(-2., 0, 0), vec3(0, 0, 12.)));\n    float lampLight0 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float lamp1 = lamp(opRep(lp, vec3(0,0,12.)));\n    float lampLight1 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float lamps = min(lamp0, lamp1);\n    float lampLights = min(lampLight0, lampLight1);\n\n    // Ground calculations\n    float plane0 = Plane(opRep(p, vec3(0,0,5.)), -1.);    \n    float sidewalk0 = sidewalk(opRep(p + vec3(3., 1, 1), vec3(0,0,4.)));\n    float sidewalk1 = sidewalk(opRep(p + vec3(-3.5, 1, 1), vec3(0,0,4.))); \n    float sidewalks = min(min(sidewalk0, sidewalk1), plane0);\n    \n    // Get scene grid, hash grid to get random number 0-2\n    float sqz = mod(floor(p.z*.5 + 0.51),2.);\n    float sqx = step(p.x, 0.0);\n    //mat.diffuse = vec3(sqz, .5, .5);\n    vec2 coords = vec2(sqz, sqx);\n    float hashNum = hash(coords);\n    \n    // Materials\n    Mat groundMat = Mat(vec3(0.25, 0.20725, 0.20725), vec3(.4, .3, .3), vec3(0.296648, 0.296648, 0.296648), vec3(0.088, 0.088, 0.088));    \n\tMat copperMat = Mat(vec3(0.19125, 0.0735, 0.0225), vec3(0.7038, 0.27048, 0.0828), vec3(0.256777, 0.137622, 0.086014), vec3(0.1, 0.1, 0.1));\n\tMat buildingMat = Mat(vec3(0.9, 0.0, 0.3), vec3(0.5, 0.5, 0.4), vec3(0.7, 0.7, 0.04), vec3(0.078175));\n\tMat lampMat = Mat(vec3(.15, .15, .15), vec3(.3, .3, .3), vec3(.3, .3, .3), vec3(.3)*2.);\n\tMat lightMat = Mat(vec3(1.0, 1.0, .8), vec3(1.0, 1.0, .8), vec3(1.0, 1.0, .6), vec3(1.0)*30.);\n\tMat redBuildingMat = Mat(vec3(0.4, 0, 0.1), vec3(0.5, 0.3, 0.2), vec3(0.4, 0, 0.1), vec3(.2));\n\tMat blueBuildingMat = Mat(vec3(0.2, 0.3, 0.4), vec3(0.2, 0.5, 0.5), vec3(0.1, 0.2, 0.3), vec3(.1));\n\tMat greenBuildingMat = Mat(vec3(0.2, 0.6, 0.3), vec3(0.2, 0.4, 0.2), vec3(0.1, 0.6, 0.3), vec3(.1));\n\n    // Use step to check if tracer distance is less than min dist, return material if yes\n    mat = AddMatStuff(mat, step(building0, MIN_DIST), redBuildingMat);\n    mat = AddMatStuff(mat, step(building1, MIN_DIST), blueBuildingMat);\n    mat = AddMatStuff(mat, step(building2, MIN_DIST), greenBuildingMat); \n    mat = AddMatStuff(mat, step(lamps, MIN_DIST), lampMat); \n    mat = AddMatStuff(mat, step(lampLights, MIN_DIST), lightMat);     \n    mat = AddMatStuff(mat, step(sidewalks, MIN_DIST), groundMat);     \n        \n    return mat;    \n                       \n}\n\nvec3 getNormals(vec3 p){\n    const vec2 eps = vec2(EPSILON, 0);\n    return normalize(vec3(map(p + eps.xyy).d - map(p - eps.xyy).d,\n                          map(p + eps.yxy).d - map(p - eps.yxy).d,\n                          map(p + eps.yyx).d - map(p - eps.yyx).d));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd){\n    float dt = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dt * rd;\n        Hit hit = map(p);\n        float dist = hit.d;\n        if(dist < MIN_DIST){\n            isHit = true;\n            break;\n        }\n        if(isHit == true || dist > MAX_DIST){\n            return vec3(0.0, 0.0, 0.2);\n            break;\n        }\n        dt += dist*0.925; // Multiplied by 0.925 to stop weird things from happening\n    }\n    return ro + dt * rd;\n}\n\nfloat GetShadows(in vec3 ro, in vec3 rd, float k){\n    float res = 1.0;\n    float d;\n    float t = 0.001;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        d = map(ro + rd * t).d;\n        if(d < MIN_DIST){\n            return 0.0;\n        }\n        res = min(res, k * d / t);\n        t += d;\n    }\n    return res;\n}\n\nvec4 getMaterial(vec3 p, vec3 rd, Light mainLight){\n    Mat mat = ChooseMaterial(p);;\n        \n\t// Need light vector, normal vector\n    vec3 l = normalize(mainLight.pos - p);\n    vec3 n = getNormals(p);\n        \n    // Shadows - figure these out at some point\n    float shadows = GetShadows(mainLight.pos, l, 20.0);\n    mainLight.diffuse += shadows;\n    \n    // Ambient\n    float ambientStr = 0.8;\n    vec3 ambient = ambientStr * mainLight.ambient;\n    \n    // Diffuse\n    float dif = max(dot(n, l), 0.0);\n    vec3 diffuse = dif * mainLight.diffuse;\n    \n    // Specular\n    vec3 viewDir = normalize(rd - p);\n    vec3 reflectDir = reflect(-l, n);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    float specularStr = 6.;\n    vec3 specular = mainLight.specular * (spec * mat.specular * specularStr);\n    \n    return vec4((diffuse * mat.diffuse + ambient * mat.ambient + specular * mat.shininess) , 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Get correct uvs\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspectRatio;\n\n    // Make the camera\n    vec3 camPos = vec3(0, -.3, fract(iTime*.1)*24.);\n    //vec3 camPos = vec3(0, -.3, -4);\n    vec3 ro = camPos;\n    vec3 rd = vec3(uv, 1.0);\n    \n    vec3 p = RayMarch(ro, rd);\n    \n    \n    vec4 col = vec4(0);\n    //col = GetNormals(col);\n    if ( isHit == true){\n        // Main light I'm gonna use\n        vec3 lightPos = vec3(0, 1.5, fract(iTime*.1)*24.);\n    \tLight mainLight = Light(lightPos, vec3(.3), vec3(.9), vec3(.4));\n    \tcol = getMaterial(p, rd, mainLight);\n    }\n    else{\n        col = vec4(0.01, 0.05, 0.12, 1.0); // bg color\n    }\n    \n    //col.x = smoothstep(col.x, .4, .25);\n    //col.y = smoothstep(col.y, .5, .25);\n    //col.z = smoothstep(col.z, .4, .2);    \n    \n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}