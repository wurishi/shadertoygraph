{"ver":"0.1","info":{"id":"MdVyRK","date":"1522678213","viewed":308,"name":"osu!lazer","username":"Sunpy","description":"osu!lazer logo\n\nThis is not optimal and its me just trying to learn how to write shaders.\nI do not know how to use buffers but if someone where to push me in the right direction that should be appreciated.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triangle","osu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SEED 0.12345679\n\n#define TRI 128.0\n#define SP 0.1\n#define COLOR vec3(0.9411764705882353,0.4274509803921569,0.6549019607843137)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,\n                         vec2(6.8245,7.1248)))*\n        9.1283);\n}\n\nfloat tri(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n\tfloat a = atan(v.x, v.y) + PI;\n    float r = TWO_PI / 3.0;\n    \n    float t = cos(floor(0.5 + a / r) * r - a) * length(v);\n    \n    return smoothstep(0.4, 0.41, t);\n}\n\nfloat yPos(float i){\n    vec2 p = vec2(SEED, i);\n    \n    float r = rand(p);\n    return fract(iTime * SP + r);\n}\n\nfloat xPos(float i, float t){\n    vec2 p = vec2(i, t - iTime * SP);\n    return rand(p) + .375;\n}\n\nvec3 triCol(float i, float t){\n    vec3 col = COLOR;\n    float r = xPos(i + 1.0, t);\n    col *= mix(0.9, 1.1, r);\n    return col;\n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat circ(vec2 uv, vec2 p, float s){\n    vec2 d = uv - p;\n    return 1.-smoothstep(s-(s*0.01),\n                         s+(s*0.01),\n                         dot(d,d)*4.0);\n}\n\nfloat box(vec2 uv, vec2 s){\n    s = vec2(0.0) - s*0.5;\n    vec2 _uv = smoothstep(s,\n                        s+vec2(0.001),\n                        uv);\n    _uv *= smoothstep(s,\n                    s+vec2(0.001),\n                    vec2(0.0)-uv);\n    return _uv.x*_uv.y;\n}\n/*\nvec3 cLine(vec2 p, float s){ // Can be used to precalc data to be used for improved line function\n    return vec3(p, s);\n}\n\nfloat line(vec2 uv, vec3 c){\n    vec2 v = uv;\n    v -= c.xy;\n    v /= max(c.z, 0.01);\n    \n    float t = 0.0;\n    \n    t += circ(v, vec2(0.0, 1.0), c.z);\n    t += circ(v, vec2(0.0, -1.0), c.z);\n    t += box(v, vec2(0.45, 2.0));\n    \n    return t;\n}\n*/\nfloat line(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n    float t = 0.0;\n    \n    t += circ(v, vec2(0.0, 1.0), s);\n    t += circ(v, vec2(0.0, -1.0), s);\n    t += box(v, vec2(s * 1.8 + 0.1, 2.0)); // Randomly found out that the value I used for testing scale was unique so this is just me trying to make it seem like it works with a weird formula\n    \n    \n    return t;//smoothstep(0.4, 0.41, t);\n}\n\nvec3 lineCol(vec2 uv){\n    vec3 col = mix(\n        vec3(0.453125, 0.75, 0.828125),\n        vec3(0.59375, 0.81640625, 0.828125),\n        sin(uv.y * 6.0 + cos(uv.x * 3.6))\n    );\n    \n    return col;\n}\n\nfloat getLines(vec2 uv){\n    float lines = 0.0;\n    \n    for (float i = 0.0; i < 64.0; i++){\n        float id = i / 64.0;\n        \n        mat2 a = rot(0.7853981633974483); // PI / 4\n        vec2 v = uv * a;\n        \n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = xPos(id, y) * 0.2;\n        \n        float l = line(v, vec2(-s) + vec2(x, y) * 2.5 - vec2(1.6, 0.0), s);\n        lines += max(0.0, l);\n    }\n    \n    lines = max(0.0, min(1.0, lines));\n    return lines;\n}\n\nvec3 background(vec2 uv){\n    vec3 col = mix(\n        mix(\n            vec3(0.51953125, 0.52734375, 0.5859375),\n            vec3(0.21875, 0.2890625, 0.37890625),\n            cos(uv.x * sin(uv.y * 4.0 + iTime) + uv.y * 2.0)\n            ),\n        vec3(0.21, 0.4, 0.5),\n        sin(uv.y * 7.24 + cos(uv.x * uv.y + iTime) * sin(iTime + uv.x * 5.3)) / 2.0 + 1.0\n    );\n    \n    uv.x *= (iResolution.x / iResolution.y);\n    \n    col = max(vec3(0.0), col - 0.2 * getLines(uv * vec2(1.04, 1.0) - vec2(0.04, 0.0)));\n    \n    float l = getLines(uv);\n    if (l > 0.0)\n    \tcol = lineCol(uv) * l;\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = COLOR;\n    \n    // Generate all dem triangles\n    for (float i = TRI; i > 0.0; i--){\n        float id = i / TRI;\n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = min(0.89, max(0.071, id * 0.5));\n        float shad = tri(\n            uv,\n            vec2(x, mix(-s, 1.0 + s / 2.0, y)),\n            s\n        );\n        \n        if (shad < 0.1)\n        \tcol = triCol(id, y) * (1.0 - shad);\n    }\n    \n    // Set background mask\n    float dist = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.5));\n    float l = abs(dist - 0.4);\n    if (dist > 0.4)\n        col = background(vec2(uv.x / (iResolution.x / iResolution.y), uv.y));\n    \n    // Make circle logo shadow\n    float dist_shad = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.49));\n    float l_shad = abs(dist_shad - 0.4);\n    col *= mix(0.3, 1.0, min(1.0, l_shad * 30.0));\n    \n    // Make circle logo\n    col = max(col, vec3(smoothstep(0.97, 0.971, 1.0 - l)));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}