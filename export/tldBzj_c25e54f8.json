{"ver":"0.1","info":{"id":"tldBzj","date":"1613096133","viewed":78,"name":"Newton Fractal with varying step","username":"sujayakar","description":"Animates rotating around the origin + varying the a step parameter for Newton iteration","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References:\n// https://www.shadertoy.com/view/ltB3WW \n// https://www.shadertoy.com/view/3lSXz1\n#define ITER 25\n#define DEGREE 2\n#define ANTI_ALIASING 2\n\n#define VARY_A\n\nvec2 complex_inv(in vec2 a) {\n    return vec2(a.x, -a.y) / dot(a, a);\n}\n\nvec2 complex_mul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 complex_div(in vec2 a, in vec2 b) {\n    return complex_mul(a, complex_inv(b));\n}\n\nvec3 newton_fractal(in vec2 z, in vec2 a) {\n    for (int i = 0; i < ITER; i++) {\n        vec2 z2 = complex_mul(z, z);\n        vec2 z4 = complex_mul(z2, z2);\n        vec2 z3 = complex_mul(z2, z);\n        vec2 z5 = complex_mul(z4, z);\n        \n        // z^3 - 1\n        #if DEGREE==2\n        z -= complex_mul(a, complex_div(z3 - 1.0, 3.0 * z2));\n        #endif\n    } \n  \n    vec2 z2 = complex_mul(z, z);\n    vec2 z3 = complex_mul(z, z2);\n    #if DEGREE==2\n    vec2 remainder = z3 - 1.0;\n    float remainder_magnitude = sqrt(dot(remainder, remainder));\n    #endif\n    return vec3(z.x, z.y, -z.y) * exp(-remainder_magnitude);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float theta = iTime / 2.0;\n    uv = vec2(uv.x * cos(theta) - uv.y * sin(theta), uv.x * sin(theta) + uv.y * cos(theta));\n    \n    vec2 aa_step = vec2(1.0 / float(ANTI_ALIASING), 1.0 / float(ANTI_ALIASING)) / iResolution.xy;\n    // aa_step.x *= iResolution.x / iResolution.y;\n    // vec2 aa_step = vec2(0.01, 0.01) / iResolution.xy;\n    \n    vec3 color = vec3(0);\n    \n    #ifdef VARY_A\n    vec2 a = vec2(1.25 * sin(iTime) + 1.25, 0);\n    #else\n    vec2 a = vec2(1, 0);\n    #endif\n    \n    for (int x = -ANTI_ALIASING + 1; x < ANTI_ALIASING; ++x) {\n        for (int y = -ANTI_ALIASING + 1; y < ANTI_ALIASING; ++y) {\n            color += newton_fractal(uv + aa_step * vec2(x, y), a);\n        }\n    }\n    int sqrt_samples = ANTI_ALIASING * 2 - 1;\n    fragColor = vec4(color / float(sqrt_samples * sqrt_samples), 1.0);\n}","name":"Image","description":"","type":"image"}]}