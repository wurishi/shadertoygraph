{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n\nvec2 scaleComplex(vec2 z, float scale){\nreturn vec2(z.x*scale, z.y*scale);\n}\n#define  time iTime\n\nuniform vec2 mouse;\n#define resolution iResolution.xy\n\n#define u_time time\n#define u_pos mouse\n#define u_index 16\n#define u_scale 20.0\n#define u_offsetX 0.0\n#define u_offsetY 0.0\n\n#define M_PI 3.1415926535897932384626433832795\n\n\n\n\n\n\nvec4 posToHsb(vec2 origin, vec2 pos, float scale);\nvec4 hsbToRgb(float h, float s, float v, float a);\n\nvec2 scaleComplex(vec2 z, float scale);\nvec2 sum(vec2 a, vec2 b);\nvec2 sub(vec2 a, vec2 b);\nvec2 mult(vec2 a, vec2 b);\nvec2 div(vec2 a, vec2 b);\nfloat norm(vec2 a);\nvec2 sinus(vec2 a);\nvec2 cosinus(vec2 a);\nvec2 lnComplex(vec2 a);\nfloat angleComplex(vec2 a);\nvec2 createFromPolar(float amount, float angle);\nvec2 expComplex(vec2 z);\nvec3 complexToHsv (vec2 z);\n\nfloat sinushyperbolicus(float a);\nfloat cosinushyperbolicus(float a);\nvec2 sum(vec2 a, vec2 b){\n   return vec2(a.x + b.x,a.y + b.y);\n}\nvec2 sub(vec2 a, vec2 b){\n   return vec2(a.x - b.x,a.y - b.y);\n}\nvec2 mult(vec2 a, vec2 b){\n   return vec2(a.x*b.x - a.y*b.y,a.x*b.y + a.y*b.x);\n}\nvec2 div(vec2 a, vec2 b){\n   return vec2((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y), (a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y));\n}\nfloat norm(vec2 a){ //other name: magnitude\n   return sqrt(a.x*a.x + a.y*a.y);\n}\nvec2 sinus(vec2 a){\nreturn vec2(sin(a.x)*cosinushyperbolicus(a.y), cos(a.x)*sinushyperbolicus(a.y));\n}\nvec2 cosinus(vec2 a){\nreturn vec2(cos(a.x)*cosinushyperbolicus(a.y), sin(a.x)*sinushyperbolicus(a.y));\n}\nvec2 lnComplex(vec2 a){ // doesnt work?\n   //return vec2(log(a.x), angleComplex(a)+2.0*3.14915*1);//k=1?\n   return vec2(log(float(norm(a))), angleComplex(a));\n}\nfloat angleComplex(vec2 a){ //other name: argument\nreturn atan(a.y, a.x)+u_time;\n}\nvec2 createFromPolar(float amount, float angle) {\n    return vec2(amount * cos(angle), amount * sin(angle));\n}\nvec2 expComplex(vec2 z){\nreturn vec2(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n}\nfloat sinushyperbolicus(float a){\nreturn 0.5 * (exp(a)-exp(-a));\n}\nfloat cosinushyperbolicus(float a){\nreturn 0.5 * (exp(a)+exp(-a));\n}\n\n\n\nvec3 complexToHsv (vec2 z) {\n\n// get phase (trim!) and magnitude.\nfloat t = angleComplex(z);\nif (t < 0.0) {\nt += (M_PI*2.0) * floor(t / (M_PI*2.0));\n}\nif (t >= (M_PI*2.0)) {\nt -= (M_PI*2.0) * floor(t / (M_PI*2.0));\n}\nfloat h = t / (M_PI*2.0);\n\n\n// map contour lines on log scale, according to magnitude.\nfloat r = norm(z);\nif (r > 1.0) {\nr = (r - exp(floor(log(r)))) / (exp(ceil(log(r))) - exp(floor(log(r))));\n}\n\n\n// determine saturation and value based on r\n// p and q are complementary distances from a countour line\nfloat p = r < 0.5 ? 2.0 * r : 2.0 * (1.0 - r);\nfloat q = 1.0 - p;\n// only let p and q go to zero very close to zero;\n// otherwise they should stay nearly 1\n// this keep the countour lines from getting thick\nfloat p1 = 1.0 - q * q * q;\nfloat q1 = 1.0 - p * p * p;\n// fix s and v from p1 and q1\nfloat s = 0.4 + 0.6 * p1;\nfloat v = 0.6 + 0.4 * q1;\n\n    return vec3(h,s,v);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.2,.1,1.),H(g*.1),.8)*3./e/8e3\n    )\n    {\n   \n        p=g*d;\n     \n       p.z-=iTime*4.5;\n     \n        a=20.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n              vec3 c1 =complexToHsv(p.zy);\n           vec3 c2 =complexToHsv(p.xy);\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n             \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*.01)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*c1*c2;\n         }\n         g+=e=length(p.yz)/s;\n    }\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4XccWH","date":"1734986468","viewed":128,"name":"magic eye","username":"nayk","description":"remake fractal 62","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}