{"ver":"0.1","info":{"id":"wtBBWh","date":"1599167013","viewed":203,"name":"Just a Donut","username":"CoolerZ","description":"Just a donut.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","donut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS 100\n#define MAX_DIST 10.\n#define EPS .01\n\nvec3 rot3d(vec3 p, vec3 ax, float angle)\n{\n    float d1 = dot(p, ax);\n    vec3 cen = d1*ax;\n    float rad = length(cen - p);\n    vec3 right = normalize(cen - p);\n    vec3 up = normalize(cross(right, ax));\n    return cen + right*rad*cos(angle) + up*rad*sin(angle);\n}\n\nfloat sphere_d(vec3 p)\n{\n    return length(p)-1.;\n}\n\nfloat donut_d(vec3 p)\n{\n    vec3 x = vec3(normalize(p.xy), 0.);\n    return length(p-x)-.5;\n}\n\nfloat scene_d(vec3 p)\n{\n//    return sphere_d(p);\n    p = rot3d(p, vec3(0,1,0), iTime);\n    p = rot3d(p, vec3(1,0,0), iTime);\n    return donut_d(p);\n}\n\nvec3 get_normals(vec3 p)\n{\n    float x1 = scene_d(p+vec3(EPS,0,0));\n    float x2 = scene_d(p-vec3(EPS,0,0));\n    float y1 = scene_d(p+vec3(0,EPS,0));\n    float y2 = scene_d(p-vec3(0,EPS,0));\n    float z1 = scene_d(p+vec3(0,0,EPS));\n    float z2 = scene_d(p-vec3(0,0,EPS));\n    return normalize(vec3(x1-x2,y1-y2,z1-z2));\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float d = 0., closest = 10000.;\n    for(int i=0;i<MAX_ITERS;i++)\n    {\n        float td = scene_d(ro+rd*d);\n        closest = min(closest, td);\n        if(closest < EPS)break;\n        d += td;\n        if(d > MAX_DIST)break;\n    }\n    return closest < EPS ? d : -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 cam_pos = vec3(0,0,4);\n    vec3 look_at = vec3(0);\n    vec3 cam_dir = normalize(look_at - cam_pos);\n    vec3 world_up = vec3(0,1,0);\n    vec3 cam_right = normalize(cross(cam_dir, world_up));\n    vec3 cam_up  = normalize(cross(cam_right, cam_dir));\n    float foc_dist = 1.;\n    vec3 pix_pos = cam_pos + foc_dist*cam_dir + cam_right*uv.x + cam_up*uv.y;\n    vec3 ray_dir = normalize(pix_pos - cam_pos);\n\n    float d = intersect(cam_pos, ray_dir);\n    vec3 p = cam_pos + d*ray_dir;\n    vec3 normals = get_normals(p);\n    vec3 light_pos = vec3(10,10,10);\n    vec3 light_dir = normalize(light_pos-p);\n    float ambient = .1;\n    float brightness = max(dot(light_dir,normals), ambient);\n\n    vec3 col = d > 0. ? vec3(brightness) : vec3(0);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}