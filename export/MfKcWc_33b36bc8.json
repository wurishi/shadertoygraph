{"ver":"0.1","info":{"id":"MfKcWc","date":"1732506306","viewed":402,"name":"241125_cloud","username":"okdalto","description":"volumetric rendering example\nI wrote a short article here (Korean): (https://okdalto.github.io/%EC%9E%91%EC%97%85/GLSL-Volumetric-rendering-(%EC%A2%80-%EB%8D%94-%EC%97%84%EB%B0%80%ED%95%98%EA%B3%A0-%EC%96%B4%EB%A0%A4%EC%9A%B4-%EB%B2%84%EC%A0%84)/)","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOWARD 0.6 // 전방 산란 계수\n#define BACKWARD -0.2 // 후방 산란 계수\n#define RAY_ITER 80 // Ray marching 반복 횟수\n#define LIGHT_ITER 16 // 조명 계산 샘플 반복 횟수\n#define LIGHT_ATTEN 256.0 // 빛 감쇠 계수\n#define RAY_STEP_SIZE 0.013 // Ray marching 단계 크기\n#define WAVE_ATTEN vec3(0.3, 0.6, 0.9) // 파장 별 감쇠 계수\n\n// 축 회전을 위한 함수\nvoid rotate(inout vec3 z, vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    // 축 회전을 위한 회전 행렬 계산\n    mat3 rot = mat3(\n        c + axis.x * axis.x * (1.0 - c),       axis.x * axis.y * (1.0 - c) - axis.z * s, axis.x * axis.z * (1.0 - c) + axis.y * s,\n        axis.y * axis.x * (1.0 - c) + axis.z * s, c + axis.y * axis.y * (1.0 - c),       axis.y * axis.z * (1.0 - c) - axis.x * s,\n        axis.z * axis.x * (1.0 - c) - axis.y * s, axis.z * axis.y * (1.0 - c) + axis.x * s, c + axis.z * axis.z * (1.0 - c)\n    );\n    z = rot * z; // 벡터에 회전 적용\n}\n\n// 절차적 프랙탈 형태를 계산하는 함수\nfloat fractal(vec3 p) {\n    for (int i = 0; i < 8; i++) {\n        // 시간에 따라 회전하는 프랙탈\n        rotate(p, vec3(1.0, 0.0, 0.0), iTime * 0.2);\n        rotate(p, vec3(0.0, 1.0, 0.0), iTime * 0.1);\n        // 반사 대칭\n        if (p.x + p.y < 0.0) p.xy = -p.yx;\n        if (p.y + p.z < 0.0) p.yz = -p.zy;\n        if (p.z + p.x < 0.0) p.zx = -p.xz;\n        p -= 0.04; // 축소 및 이동\n    }\n    return length(p) - 0.1; // 최종 거리 계산\n}\n\n// SDF(거리 함수)로 프랙탈 활용\nfloat sdf(vec3 p) {\n    return fractal(p);\n}\n\n// Henyey-Greenstein Phase Function\nfloat HenyeyGreenstein(float sundotrd, float g) {\n    float gg = g * g;\n    return (1. - gg) / pow(1. + gg - 2. * g * sundotrd, 1.5);\n}\n\n// 산란 계산 (전방 및 후방 산란 혼합)\nfloat getScattering(float sundotrd) {\n    return mix(HenyeyGreenstein(sundotrd, FOWARD), HenyeyGreenstein(sundotrd, BACKWARD), 0.5);\n}\n\n// 밀도 샘플링 (절차적 밀도 생성)\nfloat sampleDensity(vec3 p) {\n    return pow(max(-sdf(p), 0.0), 1.3) * 10.0; // SDF 기반 밀도 및 증폭\n}\n\n// 빛의 위치를 Lissajous 곡선으로 계산\nvec3 lightPosLissajous(float t) {\n    float A = 1.5;  // x축 진폭\n    float B = 1.2;  // y축 진폭\n    float C = 1.1;  // z축 진폭\n    float a = 3.1;  // x축 주파수\n    float b = 2.2;  // y축 주파수\n    float c = 4.3;  // z축 주파수\n    float delta = 0.2; // 위상 차이\n\n    float x = A * sin(a * t + delta);\n    float y = B * sin(b * t);\n    float z = C * sin(c * t);\n\n    return vec3(x, y, z); // 빛의 동적 위치 반환\n}\n\n// 메인 렌더링 함수\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 정규화된 픽셀 좌표 [-1, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.y *= iResolution.y/iResolution.x;\n\n    vec3 col = vec3(0.0); // 초기 색상 값\n\n    vec3 camPos = vec3(0.0, 0.0, -2.0); // 카메라 위치\n    vec3 rayPos = camPos; // 광선 시작점\n    vec3 rayDir = normalize(vec3(uv, 0.0) - camPos); // 광선 방향\n    float time = iTime * 0.2; // 동적 시간\n    vec3 lightPos = lightPosLissajous(time); // 빛의 위치 계산\n\n    vec3 transmittance = vec3(1.0); // 초기 투과도\n\n    rayPos += rayDir; // 광선 이동 시작\n    for (int i = 0; i < RAY_ITER; i++) {\n        rayPos += rayDir * RAY_STEP_SIZE; // 광선 전진\n        float density = sampleDensity(rayPos); // 현재 위치의 밀도 계산\n        if (density <= 0.0) {\n            continue; // 밀도가 없으면 다음 반복\n        }\n        vec3 lightDir = lightPos - rayPos; // 빛 방향\n        float lightDistance = length(lightDir); // 빛 거리\n        lightDir = lightDir / lightDistance; // 단위 벡터로 정규화\n        float lightStep = lightDistance / float(LIGHT_ITER); // 조명 단계 크기\n        float sundotrd = dot(rayDir, -lightDir); // 광선과 빛 방향의 내적\n        float scattering = getScattering(sundotrd); // 산란 계산\n        vec3 lightRayPos = rayPos; // 그림자 계산용 광선 위치\n        float shadowDensity = 0.0; // 그림자 밀도 초기화\n        for (int j = 0; j < LIGHT_ITER; j++) {\n            shadowDensity += sampleDensity(lightRayPos) * lightStep; // 그림자 밀도 누적\n            lightRayPos += lightDir * lightStep; // 빛 방향으로 전진\n        }\n        vec3 externalLight = vec3(exp(-shadowDensity * LIGHT_ATTEN * WAVE_ATTEN) * scattering); // 외부 빛 계산\n        col += transmittance * externalLight * density; // 누적된 색상\n        transmittance *= exp(-density * RAY_STEP_SIZE * WAVE_ATTEN); // 투과도 갱신\n        if (length(transmittance) < 0.01) break; // 투과도가 낮으면 조기 종료\n    }\n\n    col = pow(col, vec3(1.0 / 2.2)); // 감마 보정\n    fragColor = vec4(col, 1.0); // 최종 색상 출력\n}","name":"Image","description":"","type":"image"}]}