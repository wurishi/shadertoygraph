{"ver":"0.1","info":{"id":"XlV3DG","date":"1476468580","viewed":251,"name":"A Bed in a Room","username":"VoidChicken","description":"A bed in a room that's ray-marched using distance fields. Use the mouse to turn.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","distancefield","raymarch","lighting","shadows","distance","vignette","wood","field","room","cloth","bed","mattress"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 f, vec2 c ) {\n\tvec2 u = c/iResolution.xy;\n    f = pow(texture(iChannel0, u)*pow(1.-length(u-.5), 1./2.2), vec4(.9));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define time iTime\nconst float prc = .002;\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         \n              );\n}\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\nvec3 tnt( sampler2D samp, in vec2 uv, float v )\n{\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\twt += w;\n    }\n\t\n    return va/wt;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvoid mmn( inout vec2 fin, in vec2 o ) {\n\tfin.x = min(fin.x, o.x);\n    if (fin.x==o.x) {\n    \tfin.y=o.y;    \n    }\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nvec2 map ( vec3 r ) {\n  \n    vec2 flr = vec2(r.y+2., 1.);\n    vec2 fin = flr;// FINAL\n    vec2 wll = vec2(r.x+2., 2.);\n    vec2 wl2 = vec2(-r.z+5., 3.);\n    mmn(wll, wl2);\n    mmn(fin, wll);\n\t\n    //BED\n    \n    vec2 mattress = vec2 ( udRoundBox(r-vec3(2, .01, -3), vec3(2, .0003, 4), 1.), 4);\n    mattress.x+=texture(iChannel1, (r.xy+r.zy+r.xz*vec2(7, 1))/50.).r/27.;\n    mmn(fin, mattress);\n    vec2 head = vec2 (udBox(r-vec3(2.5, .7, 1.5), vec3(2.26, 2, .5)), 5.);\n    float b = udBox(r-vec3(2,-1.5, -2.9), vec3(2.76, .59, 4.9));\n    head.x=min(b,head.x);\n    mmn(fin,head);\n    \n    return fin;\n}\nvec2 march( vec3 ro, vec3 rd ) {\n    vec2 t = vec2(0);\n    \n    for (int i = 0; i < 64; ++i) {\t\n        vec3 ra = ro+rd*t.x;\n\t\tvec2 h = map( ra );\n        if (h.x < prc) {\n        \tt.y = h.y;\n        }\n        t.x += h.x;\n    }\n    return t;\n}\nvec3 l = vec3 (10, 5, -12);\nfloat shade( in vec3 ro, float mint, float maxt )\n{\n    float k = 2.3;\n    vec3 rd = normalize(l-ro);\n    float res = 1.0;\n\tfloat t=mint;\n    for( int i = 0; i < 32; ++i)\n    {\n        if (t<maxt) ; else break;\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.2;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res+.2,0., 1.);\n}\nvec4 render ( vec2 uv ) {\n    vec3 ro = vec3(13, 4, -12);\n    vec3 rd = vec3((uv*2.-1.)*vec2(1, iResolution.y/iResolution.x), 1);\n    rd *= rotate(vec3 (1, 0, 0), 3.1415/4. *((-iMouse.y/iResolution.y)+.5));\n    rd *= rotate(vec3 (0, 1, 0), -3.1415/4.);\n    rd *= rotate(vec3 (0, 1, 0), 3.1415/4. *(iMouse.x/iResolution.x-.5));\n    vec2 h = march( ro, rd );\n    vec3 t = ro+rd*h.x;\n    vec4 col = vec4 (0);\n    if (h.y>0.) {\n        if (h.y == 1.) {\n      \t\tcol.rgb = pow(tnt(iChannel0, t.xz/4.*vec2(1, 2), 1.).rrr/2., vec3(1./1.4));  \n        } else if (h.y == 2.) {\n            col.rgb = pow(tnt(iChannel1, t.zy/2.*vec2(1, 2), 3.).brr*vec3(1,1,2)/2.+vec3(0, 0, 1), vec3(1./1.4));\n        } else if (h.y == 3.) {\n         \tcol.rgb = pow(tnt(iChannel1, t.xy/2.*vec2(1, 2), 7.).brr*vec3(1,1,2)/2.+vec3(0, 0, 1), vec3(1./1.4));  \n        } else if (h.y == 4.) {\n        \tcol = vec4(.7, .2, 0, 1)-texture(iChannel1, (t.xy+t.zy+t.xz)/10.).r/20.;\n        } else if (h.y == 5.) {\n        \tcol.xyz = pow(tnt(iChannel0, (t.xy*t.zy)/4.*vec2(1, 2), 1.).rgb, vec3(1./1.4));   \n        }\n    }\n    col *= shade(t, 0.1, 10.)/(.1*distance(t, l));\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = render(uv);\n}","name":"Buf A","description":"","type":"buffer"}]}