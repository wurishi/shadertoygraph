{"ver":"0.1","info":{"id":"Mldfz2","date":"1540377400","viewed":195,"name":"Smoky effect","username":"Thominator","description":"Trying noise chaining to do smoky effect.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 light = vec3(0, 0, 0);\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n//2D Noise function from user iq\nfloat hash(vec2 p)\n{\n    p  = 45.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n//3D Noise function from user iq\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat rand(vec2 co){\n    return 2.0*cos(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t//Pixel coordinate between -1 and 1\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n    //Pixel coordinate between 0 and 1\n    vec2 p = fragCoord.xy / iResolution.xy;\n    //Pixel coordinate adapted to the resolution\n    vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\t\n    //Setting up the light position\n    vec2 mouse = (iMouse.xy/iResolution.xy)*2.0-1.0;\n    light = vec3(mouse, 0);\n    \n    //Computing the first fractal noise value\n\tfloat f = 0.0;\n\tuv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    //Using the noise value to give the point a depth\n\tvec3 point1 = vec3(pixel, f);\n    \n    float a=iTime*0.065;\n  \tpoint1 = rotateY(point1, a);\n    //point1 *= 1.5+cos(iTime*0.05)/2.0;\n    \n    //Computing the second factal noise value using the point previously calculated\n\tvec3 q = 7.0*point1;\n    float f2  = 0.5000*noise( q ); q = m3*q*2.01;\n    f2 += 0.2500*noise( q ); q = m3*q*2.02;\n    f2 += 0.1250*noise( q ); q = m3*q*2.03;\n    f2 += 0.0625*noise( q ); q = m3*q*2.01;\n   \n    //Using the value to compute a new point\n    vec3 point2 = vec3(pixel, f2);\n    \n    //Calculatinf the distance between the light and thoses points\n\tvec3 diff = light-point1;\n    float dist = sqrt(dot(diff, diff));\n    float c1 = 1.0/(dist*dist*dist*5.0);\n    \n    vec3 diff2 = light-point2;\n    float dist2 = sqrt(dot(diff2, diff2));\n    float c2 = 1.0/(0.0001+(dist2*dist2*dist2*5.0));\n\n    //uv = p*vec2(iResolution.x/iResolution.y,1.0);;\n    //fragColor = (f2*c2)*texture(iChannel0, vec2(uv.x+0.05*f, uv.y+0.05*f));//*/ vec4(f, f, f, 1.0);\n\t\n    //if(iMouse.w < 0.0)\n\t\tfragColor = f*vec4(c2, c2, c2, 1);\n    //else\n\t\t//fragColor = f2*vec4(c1, c1, c1, 1);    \n}","name":"Image","description":"","type":"image"}]}