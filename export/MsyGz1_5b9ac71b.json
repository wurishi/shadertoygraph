{"ver":"0.1","info":{"id":"MsyGz1","date":"1453271016","viewed":161,"name":"Borg","username":"alcomposer","description":"http://paulbourke.net/geometry/borg/\nhttps://machinesdontcare.wordpress.com/2009/07/02/borg-2d-polar-mapping/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","moire","borg","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//Comment out to activate cartesian mapping: //#define POLAR\n//#define POLAR\n\n//Comment out to deactivate color mode: //#define COLOR\n#define COLOR\n\n//Freely change these values to produce different patterns\n#define Z iTime\n#define Phi 1.\n#define scale iTime\n#define offset iMouse.xy / -(iResolution.xy / 10.)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= .5;\n  \tvec3 borg;\n    \n    #ifdef POLAR\n    uv = abs(uv);\n    vec2 polar;\n    \n    polar[0] = length(uv);             \n    polar[1] = atan(uv.x/uv.y);     \n     \n    polar *= scale;\n    polar += offset.xy;\n    \n  \n     \n    borg[0] = sin(polar[0] * polar[1]) + sin(polar[1] * Phi   ) + sin(Phi    * polar[0]);\n    borg[1] = sin(polar[0] * polar[1]) + sin(polar[1] * Phi-1.) + sin(Phi+1. * polar[0]);\n    borg[2] = sin(polar[0] * polar[1]) + sin(polar[1] * Phi/9.) + sin(Phi*9. * polar[0]);\n    \n    #else\n    uv *= scale;\n    uv += offset.xy;\n    \n    borg[0] = sin(uv.x*uv.y)+sin(uv.y*Z   ) + sin(Z    * uv.x);\n    borg[1] = sin(uv.x*uv.y)+sin(uv.y*Z-1.) + sin(Z+1. * uv.x);\n    borg[2] = sin(uv.x*uv.y)+sin(uv.y*Z/9.) + sin(Z*9. * uv.x);\n\t\n    #endif\n    #ifdef COLOR\n    fragColor = vec4(borg, 1.0);\t\n    #else\n    fragColor = vec4(vec3(borg.x), 1.0);\t\n    #endif\n}","name":"","description":"","type":"image"}]}