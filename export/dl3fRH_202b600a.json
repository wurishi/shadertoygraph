{"ver":"0.1","info":{"id":"dl3fRH","date":"1700977944","viewed":37,"name":"Rolling hills with raymarching","username":"FrederickAmpsUp","description":"Inspired by iq.\nnot yet optimized\nshare ideas, how can I:\n    * Fix moire in the background [done 11/26/23]\n    * optimize further [improved 11/27/23]\n    * fix perfect grid of trees [done 11/27/23]\n    * fix noisy trees [improved 11/27/23]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","trees"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SUN_DIR normalize(vec3(-1.5, 0.7, 0.7))\n#define SUN_COL vec3(1.0, 0.9, 0.6)\n#define GLARE_COL (SUN_COL * vec3(0.35, 0.1, 0.15))\n\n    // Crayola sky blue\n#define SKY_COL vec3(.46, .84, .92)\n#define AMBIENT (.4 * SKY_COL)\n\n#define AO_STRENGTH 1.0\n\n    // bounce lighting color\n#define BOUNCE_COL (vec3(1.0, 0.8, 0.8) * SKY_COL)\n\nvoid post(inout vec4 fragColor, in vec3 rD) {\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n    \n    float sunLight = min(max(0.0, dot(rD, SUN_DIR) - 0.1), 0.8); // glare/bloom\n    fragColor += vec4(sunLight * GLARE_COL, 0.0);\n    fragColor.w = 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(15.0, 30.0, -1.0);\n    vec3 rD  = normalize(vec3(uv, 1.0));\n    rD.xz = rotate(rD.xz, 1.2 + 0.05*sin(iTime));\n\n    float t;\n    int steps;\n    vec3 hitNorm, objectCol;\n    float dist = march(eye,rD, iTime, t, hitNorm, objectCol, steps);\n    \n    float avgDist = t / (float(steps));\n    float ao = min(1.0, avgDist / AO_STRENGTH);\n    \n    bool hit = (dist < MISS);\n    if (!hit) {\n        vec3 sun = SUN_COL * pow(max(dot(rD, SUN_DIR), 0.0), 150.0);\n        fragColor = vec4(sun + SKY_COL, 1.0);\n        post(fragColor, rD);\n        return;\n    }\n    \n    float fogDensity = 0.002;\n    vec3 fogCol = vec3(0.8, 0.8, 1.0);\n    vec3 fog = vec3(1.0) - exp(vec3(1,2,3.5) * t*-fogDensity);\n    \n    vec3 hitPos = eye + rD*t;\n    \n    float sunLight = max(dot(SUN_DIR, hitNorm), 0.0);\n    vec3 direct = (sunLight * SUN_COL * objectCol);\n    vec3 ambient = AMBIENT * objectCol;\n    vec3 bounce = max(dot(-SUN_DIR, hitNorm), 0.2) * BOUNCE_COL * 0.1;\n    \n    float shadowT;\n    vec3 dummyNorm,dummyCol;\n    float shadowD = march(hitPos + (hitNorm * 0.1), SUN_DIR, iTime, shadowT, dummyNorm, dummyCol, steps);\n    float shadow = float(shadowD > SURF);\n    \n    vec3 reflectDir = reflect(SUN_DIR, hitNorm);\n\n    float specular = pow(max(dot(rD, reflectDir), 0.0), 100.0);\n    \n    fragColor = vec4(mix(direct*max(shadow,0.05) + ambient + bounce + SUN_COL*specular*0.5, vec3(1.0), fog), 1.0);\n    fragColor *= ao;\n    post(fragColor, rD);\n    \n    //fragColor = vec4(ao);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STEPS 256\n\n#define SURF 0.0001\n#define MISS 1000.0\n\n#define TERRAIN_ITERS 20\n\n#define PI 3.14159265\n\nfloat sMix(float x, float y, float t) {\n    return mix(x,y,smoothstep(0.0, 1.0, t));\n}\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float c){\n    return rand(vec2(c, 0.0));\n}\nfloat noise(vec2 p) {\n    vec2 frac = fract(p);\n    vec2 pos = p-frac;\n    \n    float topLeft  = rand(pos+vec2(0,0));\n    float topRight = rand(pos+vec2(1,0));\n    float botLeft  = rand(pos+vec2(0,1));\n    float botRight = rand(pos+vec2(1,1));\n    \n    float topSide = sMix(topLeft,topRight, frac.x);\n    float botSide = sMix(botLeft,botRight, frac.x);\n    \n    float final = sMix(topSide, botSide, frac.y);\n    return final;\n}\nfloat noise(float p) {\n    return noise(vec2(p, 0.0));\n}\n\nvec2 noiseDeriv(vec2 p) {\n    vec2 frac = fract(p);\n    \n    float SSderivX = 6.0 * frac.x - 6.0 * frac.x*frac.x;\n    float SSderivY = 6.0 * frac.y - 6.0 * frac.y*frac.y;\n    \n    vec2 pos = p-frac;\n    \n    float topLeft  = rand(pos+vec2(0,0));\n    float topRight = rand(pos+vec2(1,0));\n    float botLeft  = rand(pos+vec2(0,1));\n    float botRight = rand(pos+vec2(1,1));\n     \n    float topSide = sMix(topLeft,topRight, frac.x);\n    float botSide = sMix(botLeft,botRight, frac.x);\n    \n    vec2 final = vec2(SSderivX * sMix((topRight-topLeft), (botRight-botLeft), frac.y), SSderivY * (botSide - topSide));\n    return -final;\n}\n\nvec2 rotate(vec2 p, float a) {\n    float oA = atan(p.y,p.x);\n    float oR = length(p);\n    return vec2(cos(oA+a), sin(oA+a)) * oR;\n}\n\nfloat map(in vec3 p, in float time, out vec3 norm, out vec3 col) {\n    float terrainHeight = -0.5;\n    vec2 deriv = vec2(0.0);\n    \n        // fractal noise\n    for (int i = 0; i < TERRAIN_ITERS - max(0, int(length(p)/30.0)); ++i) {\n        vec2 offset = rotate(p.xz * float(2*i+1) / 100.0, 2.0*PI*rand(vec2(float(i+1), 0.0)));\n        terrainHeight += noise(offset) / float(10*i+1) * 100.0;\n        deriv += rotate(noiseDeriv(offset), -(2.0*PI*rand(vec2(float(i+1), 0.0)))) / float(10*i+1);\n    }\n    \n    norm = normalize(vec3(deriv.x, 1.0, deriv.y));\n    float nDotUp = dot(norm, vec3(0.0, 1.0, 0.0));\n    col = mix(vec3(1.0, 0.2, 0.2), vec3(0.0, 1.0, 0.0), float(noise(p.xz*3.0)*0.1-0.05+0.8 < nDotUp));\n    float dstGround = (p.y - terrainHeight) * (max(0.01, nDotUp-0.3));\n    \n    float dst = dstGround;\n    float dstTree;\n    float treeSeed = 0.0;\n    vec3 treePos = norm;\n    \n    if ((p.y - terrainHeight) > 10.0) {\n        dstTree = (p.y - terrainHeight) - 9.5;\n    } else {\n        vec3 treePos0 = vec3(rand(floor(p.z*1.0))*2.0-1.0 + mod(p.x,2.0)-1.0 - (noise((p.y-terrainHeight)*time*0.3)*.2-.1), (p.y-terrainHeight)/5.0, rand(floor(p.x*1.0))*2.0-1.0 + mod(p.z, 2.0)-1.0 - (noise((p.y-terrainHeight)*time*.314159)*.2-.1));\n        vec3 treePos1 = vec3(rand(floor(p.z*2.0))*2.0-1.0 + mod(p.x,2.0)-1.0 - (noise((p.y-terrainHeight)*time*0.3)*.2-.1), (p.y-terrainHeight)/5.0, rand(floor(p.x*2.0))*2.0-1.0 + mod(p.z, 2.0)-1.0 - (noise((p.y-terrainHeight)*time*.314159)*.2-.1));\n        vec3 treePos2 = vec3(rand(floor(p.z*3.0))*2.0-1.0 + mod(p.x,2.0)-1.0 - (noise((p.y-terrainHeight)*time*0.3)*.2-.1), (p.y-terrainHeight)/5.0, rand(floor(p.x*3.0))*2.0-1.0 + mod(p.z, 2.0)-1.0 - (noise((p.y-terrainHeight)*time*.314159)*.2-.1));\n        vec3 treePos3 = vec3(rand(floor(p.z*4.0))*2.0-1.0 + mod(p.x,2.0)-1.0 - (noise((p.y-terrainHeight)*time*0.3)*.2-.1), (p.y-terrainHeight)/5.0, rand(floor(p.x*4.0))*2.0-1.0 + mod(p.z, 2.0)-1.0 - (noise((p.y-terrainHeight)*time*.314159)*.2-.1));\n        float treeSeed0 = rand(1.0*floor(p.xz/2.0));\n        float treeSeed1 = rand(2.0*floor(p.xz/2.0));\n        float treeSeed2 = rand(3.0*floor(p.xz/2.0));\n        float treeSeed3 = rand(4.0*floor(p.xz/2.0));\n        float treeRadius0 = 0.7 + max(-0.1, 0.1*treeSeed0 + 0.1*noise(p.y*6.0)*(0.2+treeSeed0) - 0.35*treePos0.y + 0.15*noise(3.0*atan(treePos0.z, treePos0.x)));\n        float treeRadius1 = 0.7 + max(-0.1, 0.1*treeSeed1 + 0.1*noise(p.y*6.0)*(0.2+treeSeed1) - 0.35*treePos0.y + 0.15*noise(3.0*atan(treePos1.z, treePos1.x)));\n        float treeRadius2 = 0.7 + max(-0.1, 0.1*treeSeed2 + 0.1*noise(p.y*6.0)*(0.2+treeSeed2) - 0.35*treePos0.y + 0.15*noise(3.0*atan(treePos2.z, treePos2.x)));\n        float treeRadius3 = 0.7 + max(-0.1, 0.1*treeSeed3 + 0.1*noise(p.y*6.0)*(0.2+treeSeed3) - 0.35*treePos0.y + 0.15*noise(3.0*atan(treePos3.z, treePos3.x)));\n\n        float dstTree0 = length(treePos0)-treeRadius0;\n        float dstTree1 = length(treePos1)-treeRadius1;\n        float dstTree2 = length(treePos2)-treeRadius2;\n        float dstTree3 = length(treePos3)-treeRadius3;\n        \n        treePos = treePos0;\n        treeSeed = treeSeed0;\n        dstTree = dstTree0;\n\n        if (dstTree1 < dstTree) {\n            dstTree = dstTree1;\n            treeSeed = treeSeed1;\n            treePos = treePos1;\n        }\n        if (dstTree2 < dstTree) {\n            dstTree = dstTree2;\n            treeSeed = treeSeed2;\n            treePos = treePos2;\n        }\n        if (dstTree3 < dstTree) {\n            dstTree = dstTree3;\n            treeSeed = treeSeed3;\n            treePos = treePos3;\n        }\n    }\n    \n    if (dstTree < dst) {\n        dst = dstTree;\n        col = mix(vec3(0.0, 0.7, 0.0), vec3(0.5, 0.3, 0.0), treeSeed);\n        norm = normalize(normalize(treePos)+norm*length(p/20.0));\n    }\n    \n    return dst;\n}\n\nfloat march(in vec3 rO, in vec3 rD, in float time, out float t, out vec3 norm, out vec3 col, out int steps) {\n    t = 0.0;\n    float dist;\n    for (int i = 0; i < STEPS; ++i) {\n        steps=i;\n        vec3 p = rO + rD*t;\n        dist = map(p, time, norm, col);\n        if (dist < SURF || dist > MISS) return dist;\n        t += dist;\n    }\n    return dist;\n}","name":"Common","description":"","type":"common"}]}