{"ver":"0.1","info":{"id":"MdByzD","date":"1491150513","viewed":381,"name":"Smooth Cell Noise","username":"TinyTexel","description":"left:      standard cell noise\nmiddle: smooth cell noise | using 1/pow(d, e) as edge weight\nright:    smooth cell noise | using 1/(exp2(d * s) - 1) as edge weight\ntop:      difference between standard and smooth\nbottom: iso lines","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nleft:   standard cell noise\nmiddle: smooth cell noise | using 1/pow(d, e) as edge weight\nright:  smooth cell noise | using 1/(exp2(d * s) - 1) as edge weight\ntop:    difference between standard and smooth\nbottom: iso lines\n\nThe exp2-based variant produces more consistently smooth iso lines. \n*/\n\n//smoothness settings (middle E, right S):\n#define E 8.0\n#define S 22.0 \n\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define clamp(x) clamp(x, 0.0, 1.0)\n\n\nconst float Pi = 3.14159265359;\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\nfloat FwdPot_RcpExp(float d, float s)\n{\n\treturn 1.0 / (exp2(d * s) - 1.0);\n}\n\nfloat InvPot_RcpExp(float d, float s)\n{\n\treturn log2(1.0 / d + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn pow(exp2(d * s) - 1.0, -e);\n}\n\nfloat InvPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn log2(pow(d, -1.0 / e) + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -e);\n}\n\nfloat InvPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -1.0 / e);\n}\n\n\nvec3 CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n\t\n    float e = E;\n    float s = S;\n    \n\tfloat dd1 = 64.0;\n\tfloat dd2 = 0.0;\n    float dd3 = 0.0;\n    \n    const float n = 2.0;\n\tfor(float i = -n; i <= n; ++i)\n\tfor(float j = -n; j <= n; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t\td *= 1.48;// empirically normalized\n\n\t\tdd1 = min(dd1, d);\n        dd2 += FwdPot_RcpPow(d, e);\n\t\tdd3 += FwdPot_RcpExp(d, s);\n\t}\n\t\n\treturn vec3(dd1, InvPot_RcpPow(dd2, e), InvPot_RcpExp(dd3, s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    //cells = vec2(5.0);// 5 cells per tile\n    \n    vec2 pos = uv * 0.02 + Time * 0.2;\n    \n    \n    vec3 r = CellTex(pos, 0.0, cells);\n    //r -= 0.1;\n    //r.x /= length(vec2(dFdx(r.x), dFdy(r.x)));\n    //r.y /= length(vec2(dFdx(r.y), dFdy(r.y)));\n    //r.z /= length(vec2(dFdx(r.z), dFdy(r.z)));\n    //r = abs(mod(r * 0.125, 1.0) * 2.0 - 1.0) * 2.0 - 1.0;\n    \n    float r0 = tex.x < 1.0/3.0 ? r.x : \n               tex.x < 2.0/3.0 ? r.y : r.z;\n    \n    if(tex.y > 0.75)\n    r0 = r.x - r0;\n    \n    vec3 col = vec3(r0);\n    \n    if(tex.y < 0.25)\n    {\n    \tfloat stripes = abs(fract(r0 * 8.0) * 2.0 - 1.0) * 2.0 - 1.0;\n        col = vec3(1.0-clamp(r0 * 8.0), stripes, clamp(r0 * 8.0-4.0));\n    }\n    \n    fragColor = vec4(pow(clamp(col), vec3(1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}