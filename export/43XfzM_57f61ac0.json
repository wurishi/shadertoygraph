{"ver":"0.1","info":{"id":"43XfzM","date":"1728235440","viewed":70,"name":"C1 triangle interpolation","username":"FordPerfect","description":"An implementation of C1-continuous triangle interpolation from [url=https://ntrs.nasa.gov/api/citations/19760016832/downloads/19760016832.pdf]Lawson, C.L. \"C1-compatible interpolation over a triangle\"[/url].\nHold mouse for no grid/gradients/contour.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["triangle","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Public Domain under http://unlicense.org, see link for details.\n\n// An implementation of C1-continuous triangle interpolation from\n//     Lawson, C.L. \"C1-compatible interpolation over a triangle\". California Institute of Technology. Jet Propulsion Lab. Technical Memorandum 33â€“770 (1976)\n//     https://ntrs.nasa.gov/api/citations/19760016832/downloads/19760016832.pdf\n// in both rational and piecewise-cubic versions.\n// Note that this implementation differs in several ways from the\n// original Fortran code available at\n//     https://netlib.org/math/MATH77/dtgc1.f\n// Hold mouse to show just the interpolated value, without grid,\n// gradients, and contour plot.\n// WARNING: the code is illustrative and doesn't handle things\n// like degenerate triangles, though it can be done.\n\n// Interpolating values in a triangle via barycentric coordinates\n// is well known (see e.g. https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/).\n// Linear interpolation is, however, only C0-continuous (the result is\n// continuous, but its derivative can have a jump across the edge between\n// two adjacent triangles). One possible way to get a C1-continuous interpolation\n// is the algorithm presented in the above paper.\n// Briefly, the barycentric coordinates of a point v are the weights\n// r[0], r[1], r[2] of the representation of v as a weighted sum of\n// tiriangle's vertices v[0], v[1], v[2]:\n//     v = r[0]*v[0]+r[1]*v[1]+r[2]*v[2]\n// We have r[0]+r[1]+r[2]=1. Inside the triangle 0<=r[i]<=1.\n// The (linear) barycentric interpolation is then\n//     f(v) = r[0]*F(v[0])+r[1]*F(v[1])+r[2]*F(v[2])\n// The C1 version is achieved with 2 adjustments.\n// First, a term that ensures that tangential derivatives are\n// cubically Hermite-interpolated along the edges.\n// Second, a term that ensures that normal derivatives are\n// linearly interpolated along the edges.\n// This second term comes in 2 versions: rational function\n// on the entire triangle, or piecewise-cubic function on\n// 3 subtriangles, split via triangles's centroid (see\n// Hsieh-Clough-Tocher triangle, a.k.a. HCT).\n// See paper for derivations of these terms.\n\n// NOTE: this interpolation may look bad when shaded,\n// as you generally need C2-continuity to nicely shade\n// the plot of z=f(x,y). For that you may be better off with the\n// usual way of interpolating and then renormalizing vertex normals.\n\n//==============================================================================\n\n// Choose a version - rational or piecewise-cubic.\n#define RATIONAL\n\n// Barycentric formulation.\n// NOTE: quantities h,k,m correspond to \"tilda-ed\"\n// (i.e. scaled) versions in the paper.\nfloat interpolate(\n    vec3 f, // values at vertices:                        f[i] = f(v[i])\n    vec3 h, // scaled \"outgoing\" tangential derivatives:  h[i] = dot(f'(v[i+1]),v[i+2]-v[i+1])\n    vec3 k, // scaled \"incoming\" tangential derivatives:  k[i] = dot(f'(v[i+2]),v[i+2]-v[i+1])\n    vec3 l, // side lengths:                              l[i] = length(v[i+2]-v[i+1])\n    vec3 r  // barycentric coordinates of point v:        r[0]*v[0]+r[1]*v[1]+r[2]*v[2] = v\n)\n{\n    vec3 m=f.zxy-f.yzx;\n#if defined(RATIONAL)\n    // The expression for rho is x*y^2*z^2/((1-y)*(1-z)),\n    // with removable singularities at y=1, z=1. We deal with\n    // them pretty crudely, but there are nicer alternatives.\n    vec3 rho=r*r.yzx*r.yzx*r.zxy*r.zxy/max((1.0-r.yzx)*(1.0-r.zxy),1e-7);\n#else\n    // Piecewise-cubic construction.\n    // Possibly suboptimal implementation.\n    vec3 rho=r*(6.0*r.yzx*r.zxy+r*(5.0*r-3.0))/6.0;\n    rho=mix(rho,r.yzx*r.yzx*(-r.yzx+3.0*r.zxy)/6.0,equal(r.yzx,vec3(min(min(r.x,r.y),r.z))));\n    rho=mix(rho,r.zxy*r.zxy*(-r.zxy+3.0*r.yzx)/6.0,equal(r.zxy,vec3(min(min(r.x,r.y),r.z))));\n#endif\n    // NOTE: the division by l*l here is the only thing that\n    // breaks for degenerate triangles.\n    vec3 g=r.yzx*r.zxy*(r.yzx-r.zxy)+3.0*(l.yzx-l.zxy)*(l.yzx+l.zxy)/l*l*rho-(rho.yzx-rho.zxy);\n    return dot(f,r)+0.5*dot(h-k,r.zxy*r.yzx)+0.5*dot(h+k-2.0*m,g);\n}\n\n// Cartesian formulation.\nfloat interpolate(\n    vec2 v0,vec2 v1,vec2 v2,\n    float f0,float f1,float f2,\n    vec2 g0,vec2 g1,vec2 g2,\n    vec2 v)\n{\n    vec3 l=vec3(length(v2-v1),length(v0-v2),length(v1-v0));\n    // Barycentric coordinates computation breaks for degenerate triangles.\n    vec3 r=vec3(\n        determinant(mat2(v2-v1,v-v1)),\n        determinant(mat2(v0-v2,v-v2)),\n        determinant(mat2(v1-v0,v-v0)))/determinant(mat2(v1-v0,v2-v0));\n    return interpolate(\n        vec3(f0,f1,f2),\n        vec3(dot(g1,v2-v1),dot(g2,v0-v2),dot(g0,v1-v0)),\n        vec3(dot(g2,v2-v1),dot(g0,v0-v2),dot(g1,v1-v0)),\n        l,\n        r);\n}\n\n//==============================================================================\n// Noise and derivatives from https://www.shadertoy.com/view/XXBczD.\n\n// Hash from https://www.shadertoy.com/view/dllSW7.\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nvec2 hash2(vec2 r)\n{\n    ivec2 v=ivec2(r);\n    uint h=hash(uint(v.x+65535*v.y));\n    return vec2(h&65535u,h>>16)/32768.0-1.0;\n}\n\n\nvec3 hash3(vec3 r)\n{\n    ivec3 v=ivec3(r);\n    uint h=hash(uint(v.x+1024*v.y+1048576*v.z));\n    return vec3(h&1023u,(h>>10)&1023u,(h>>20)&1023u)/512.0-1.0;\n}\n\n// 3D gradient noise. Gradient in xyz, value in w.\nvec4 noise3(vec3 r)\n{\n    vec3 i=floor(r),v=fract(r),k=vec3(0,1,0),t=v*v*v*(v*(v*6.0-15.0)+10.0);\n    vec3 A=hash3(i+k.xxx); float a=dot(A,v-k.xxx);\n    vec3 B=hash3(i+k.yxx); float b=dot(B,v-k.yxx);\n    vec3 C=hash3(i+k.xyx); float c=dot(C,v-k.xyx);\n    vec3 D=hash3(i+k.yyx); float d=dot(D,v-k.yyx);\n    vec3 E=hash3(i+k.xxy); float e=dot(E,v-k.xxy);\n    vec3 F=hash3(i+k.yxy); float f=dot(F,v-k.yxy);\n    vec3 G=hash3(i+k.xyy); float g=dot(G,v-k.xyy);\n    vec3 H=hash3(i+k.yyy); float h=dot(H,v-k.yyy);\n    return vec4(mix(mix(vec3(b-a,c-a,e-a),vec3(d-c,g-e,f-b),t.yzx),\n                    mix(vec3(f-e,d-b,g-c),vec3(h-g,h-f,h-d),t.yzx),t.zxy)*30.0*v*v*(v*(v-2.0)+1.0)+\n                mix(mix(mix(A,B,t.x),mix(C,D,t.x),t.y),\n                    mix(mix(E,F,t.x),mix(G,H,t.x),t.y),t.z),\n                mix(mix(mix(a,b,t.x),mix(c,d,t.x),t.y),\n                    mix(mix(e,f,t.x),mix(g,h,t.x),t.y),t.z));\n}\n\n//==============================================================================\n\n// Underlying function and its derivative.\nvec3 F(vec2 v)\n{\n    return noise3(vec3(v,0.02*iTime)).xyw+vec3(0,0,0.5);\n}\n\n//==============================================================================\n// Function interpolated on a triangle mesh.\n// We use a grid for simplicity, but it can be arbitrary triangulation.\n\n// Grid parameters.\nconst mat2 M=0.5*mat2(3.7,0.5,-2.3,3.1),N=inverse(M);\n\n// Interpolated function.\nfloat f(vec2 v)\n{\n    vec2 xy=M*v;\n    vec2 K=floor(xy);\n    vec2 v0=N*(K+vec2(1,0));\n    vec2 v1=N*(K+vec2(0,1));\n    vec2 v2=N*(K+floor(dot(fract(xy),vec2(1))));\n    vec3 l=vec3(length(v2-v1),length(v0-v2),length(v1-v0));\n    return interpolate(\n        v0,v1,v2,\n        F(v0).z ,F(v1).z ,F(v2).z ,\n        F(v0).xy,F(v1).xy,F(v2).xy,\n        v);\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 v=(2.0*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec4 w=(iResolution.xy/min(iResolution.x,iResolution.y)).xyxy*vec4(+1,+1,-1,-1);\n    vec2 a=vec2(1,0),b=vec2(-0.5,0.125),c=vec2(-0.5,-0.5);\n    vec3 col=vec3(0);\n    float z=f(v);\n    if(iMouse.z<=0.0)\n    {\n        col=vec3(0.5)*smoothstep(0.0,128.0*fwidth(z),abs(sin(128.0*z)));\n        vec2 r=M*v;\n        const float pi=3.14159265358979;\n        float a=0.0;\n        a+=0.5*smoothstep(3.0*fwidth(r.x),0.0,abs(sin(pi*r.x)));\n        a+=0.5*smoothstep(3.0*fwidth(r.y),0.0,abs(sin(pi*r.y)));\n        a+=0.5*smoothstep(3.0*fwidth(r.y+r.y),0.0,abs(sin(pi*(r.x+r.y))));\n        c=N*round(r);\n        vec2 g=F(c).xy/8.0;\n        float x=dot(normalize(g),v-c);\n        float y=abs(determinant(mat2(normalize(g),v-c)));\n        a+=smoothstep(0.02,0.0,length(vec2(max(abs(x-0.5*length(g))-0.5*length(g),0.0),y)));\n        a+=smoothstep(-0.035,-0.01,min(min(\n            dot(v-c-g,normalize(g)),\n            dot(v-c-g,mat2(-0.5,+sqrt(0.75),-sqrt(0.75),-0.5)*normalize(g))),\n            dot(v-c-g,mat2(-0.5,-sqrt(0.75),+sqrt(0.75),-0.5)*normalize(g))));\n        col=mix(col,vec3(0.25,1.25,0.25),min(a,1.0));\n    }\n    else col=vec3(z);\n    col=clamp(col,0.0,1.0);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}