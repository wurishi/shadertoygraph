{"ver":"0.1","info":{"id":"ltKSRh","date":"1482957833","viewed":743,"name":"Scuba Propulsion","username":"Passion","description":"underwater dive","likes":52,"published":1,"flags":96,"usePreview":0,"tags":["raymarch","cubemap","postprocess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsjGzG","filepath":"https://soundcloud.com/home-2001/resonance","previewfilepath":"https://soundcloud.com/home-2001/resonance","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 buffer = texture(iChannel0,uv);\n    float decay=0.96815;\n    float exposure=0.21;\n    float density=0.926;\n    float weight=0.58767;\n    \n    vec2 tc = uv;\n    vec2 lightPos = iMouse.xy;\n    vec2 deltaTexCoord = tc;\n    \n    \n    deltaTexCoord =  uv-vec2(.5,.75);   \n    deltaTexCoord *= 1.0 / float(NUM_SAMPLES)  * density;\n    \n    float illuminationDecay = 1.0;\n    vec4 color =texture(iChannel0, tc.xy)*0.305104;\n    \n    tc += deltaTexCoord * fract( sin(dot(uv.xy+fract(iTime), \n                                         vec2(12.9898, 78.233)))* 43758.5453 );\n    \n    for(int i=0; i < NUM_SAMPLES; i++){\n        tc -= deltaTexCoord;\n        vec4 sampleTex = texture(iChannel0, tc)*0.305104;\n        sampleTex *= illuminationDecay * weight;\n        color += sampleTex;\n        illuminationDecay *= decay;\n    }\n    \n    fragColor = pow(color*exposure+(buffer*.75), vec4(vec3(1.0/0.75), 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_SAMPLES 64\n#define EPS 0.001\n#define MAX_DIST 20.0\n\n// Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.05;\nconst float freqB = 0.09;\nconst float ampA = 2.4;\nconst float ampB = -2.7;\n\n//Random function\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n//Noise function\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path2(in float z){ return vec2(ampA*sin(z * freqA)*5.5, ampB*cos(z * freqB)-4.); }\nvec2 path(in float z){ return vec2(ampB*sin(z * freqB*1.5), ampA*cos(z * freqA*1.3)); }\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\nvec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n// 2D rotation\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\n\nfloat surfFunc(in vec3 p){\n        \n   /*\n    float n = dot(tri(p*0.48 + tri(p*0.24).yzx), vec3(0.444));\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.7071;\n    return dot(tri(p*0.72 + tri(p*0.36).yzx), vec3(0.222)) + n; // Range [0, 1]\n    */\n    \n    // Other variations to try. All have range: [0, 1]\n    \n    /*\n    return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));\n    */\n    \n    \n    return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.333)) + \n           sin(p.x*1.5+sin(p.y*2.+sin(p.z*2.5)))*0.25+0.25;\n    \n    \n    /*\n    return dot(tri(p*0.6 + tri(p*0.3).yzx), vec3(0.333)) + \n           sin(p.x*1.75+sin(p.y*2.+sin(p.z*2.25)))*0.25+0.25; // Range [0, 1]\n    */\n    /*\n    \n    p *= 0.5;\n    float n = dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.66));\n    p *= 1.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.34));\n    return n;\n    */\n    \n    /*\n    p *= 1.5;\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\n    p *= 1.5773;\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\n    p *= 1.5773;\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\n    return n*0.4+0.6;\n    */\n\n}\n// Cheap...ish smooth minimum function.\nfloat smoothMinP( float a, float b, float smoothing ){\n    float h = clamp((b-a)*0.5/smoothing + 0.5, 0.0, 1.0 );\n    return mix(b, a, h) - smoothing*h*(1.0-h);\n}\n// Smooth maximum, based on the function above.\nfloat smoothMaxP(float a, float b, float smoothing){\n    float h = clamp((a - b)*0.5/smoothing + 0.5, 0.0, 1.0);\n    return mix(b, a, h) + h*(1.0 - h)*smoothing;\n}\n\nfloat water(vec3 p){\n    p.y*=-1.;\n    p.y+=2.;\n    \n    float n1 = noise(4.*p.xz+iTime*1.825)*.06125;\n    float n2 = noise(2.*p.zx+iTime*2.75)*.0512;\n    float n3 = noise(.25*p.xz+iTime*2.)*.25;\n    float n4 = noise(.15*p.zx+iTime*1.)*.74;\n    \n    return (p.y + n1+ n2+ n3+ n4);\n}\n// ground distance function\nfloat seaGround(vec3 p){\n    float n = noise(.1*p.xz)*2.;\n    float pl = (p.y) + 8.25;\n    return pl+(n+n);\n}\nfloat seaPillars(vec3 p){\n    vec2 tun = p.xy - path(p.z);\n    vec2 tun2 = p.xy - path2(p.z);\n    float d = 1.- smoothMinP(length(tun), length(tun2), 4.) + (0.5-surfFunc(p));\n    float dd = (sin(p.x/2.)+cos(p.z/1.5));\n   \n    return (smoothMaxP(d, (dd+surfFunc(p/2.)), .5));\n}\n\nfloat map(vec3 p){\n    return smoothMinP(min(water(p), seaPillars(p)), seaGround(p), 1.13);\n}\n\n// raymarch/trace funtion\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_SAMPLES; i++){\n        vec3 p = o+t * r;\n        float d = map(p);\n        if(abs(d) < EPS || t > MAX_DIST) break; \n        t += d * 0.75;\n    }\n    return t;\n}\n\n// normal or gradient function\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPS, 0.0);\n    return normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n    return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * .15));\n    \n        \n    vec3 l = normalize(vec3(.3, 1.0, .1));\n    //l.xz *= r2(t);\n    // Camera Setup.\n    vec3 lookAt = vec3(0.0, 0.0, t*4.);  // \"Look At\" position.\n    vec3 o = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n    // Using the Z-value to perturb the XY-plane.\n    // Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n    // synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n    lookAt.xy += path(lookAt.z);\n    o.xy += path2(o.z);\n    \n    r.yx*=r2(noise(vec2(t/3.))+1.2);\n    r.zy*=r2(noise(vec2(t/2.))+1.3);\n    r.zx*=r2(noise(vec2(t/2.))+1.);\n    \n    float hit = trace(o, r);\n    vec3 sp = o+hit * r;\n    float d = map(sp);\n    float d2 = water(sp);\n    float d3 = seaPillars(sp);\n    // normal\n    vec3 n = grad(sp);\n    \n    vec3 incident = normalize(sp - o);  \n    vec3 reflected = normalize(reflect(incident,n)); //, 1.31\n    vec3 refracted = normalize(refract(incident,n,1.333));\n    // cubemaps mm and m1...\n    vec4 mm = texture(iChannel0, reflected);\n    vec4 m1 = texture(iChannel0, refracted);\n    \n    // background color\n    vec4 bg = pow(vec4(.1, .75, .8, 1), vec4(4.*(-1.*r.y+1.0)));\n    \n    // initialize to avoid issuses/artifacts\n    fragColor = vec4(0.0);\n    \n    if(d < 0.1){\n        float fog = smoothstep(.015, .85, hit*.05);\n        // reset set the norm using the bump map function\n        vec3 tempBMP = doBumpMap(iChannel1, (sp)*(1.0/3.0), n, 0.05);\n        vec3 l2 = normalize(vec3(.2,-.8,.3));\n        float dif2 = clamp(dot(tempBMP,l),0.15,1.0);\n        vec4 tex = vec4(tex3D(iChannel1,(sp)*(1.0/8.0), n), 1.0);\n        fragColor = mix(tex*dif2, bg, fog);\n        // check if ground is hit\n        if(d2 < 0.1){\n            // blinn-phong specular\n            vec3 halfDir = normalize(-l - r);\n            float specAngle = max(dot(halfDir, n), 0.0);\n            float spec = pow(specAngle, 80.);\n            // diffuse\n            float dif = clamp(dot(n,l), 0.15, 1.0);//*dif\n            fragColor = mix(vec4((m1*.5)+mm*vec4(.1,.75,.8,1.)*dif+spec), bg, fog);\n        }\n    }\n    else\n        fragColor = bg;\n}","name":"Buf A","description":"","type":"buffer"}]}