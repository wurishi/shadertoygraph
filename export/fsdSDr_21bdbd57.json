{"ver":"0.1","info":{"id":"fsdSDr","date":"1632959996","viewed":49,"name":"Raymarcher ND","username":"ndevlin","description":"An SDF scene rendered using raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","raymarcher","nd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sceneSDF(vec3 queryPos) \n{\n    return sdfSphere(queryPos, vec3(0.0, 0.0, 0.0), 1.0);\n}\n\nRay getRay(vec2 uv)\n{\n    Ray r;\n    \n    vec3 look = normalize(ORIGIN - EYE);\n    vec3 camera_RIGHT = normalize(cross(WORLD_UP, look));\n    vec3 camera_UP = cross(camera_RIGHT, look);\n    \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 screen_vertical = camera_UP * tan(FOV); \n    vec3 screen_horizontal = camera_RIGHT * aspect_ratio * tan(FOV);\n    vec3 screen_point = (look + uv.x * screen_horizontal + uv.y * screen_vertical);\n    \n    r.origin = EYE;\n    r.direction = normalize(screen_point - EYE);\n   \n    return r;\n}\n\nIntersection getRaymarchedIntersection(vec2 uv)\n{\n    Intersection intersection;    \n    intersection.distance_t = -1.0;\n    \n    float distancet = 0.0f;\n    \n    Ray r = getRay(uv);\n    for(int step; step < MAX_RAY_STEPS; ++step)\n    {\n        vec3 queryPoint = r.origin + r.direction * distancet;\n        float currentDistance = sceneSDF(queryPoint);\n        if(currentDistance < EPSILON)\n        {\n            // We hit something\n            intersection.distance_t = distancet;\n            \n            //intersection.normal = estimateNormal(queryPoint);\n            \n            return intersection;\n        }\n        distancet += currentDistance;\n        \n    }\n    \n    return intersection;\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    Intersection intersection = getRaymarchedIntersection(uv);\n    if (intersection.distance_t > 0.0)\n    { \n        return vec3(1.0);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make symmetric [-1, 1]\n    uv = uv * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = getSceneColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int MAX_RAY_STEPS = 128;\nconst float FOV = 45.0;\nconst float EPSILON = 1e-6;\n\nconst vec3 EYE = vec3(0.0, 0.0, -10.0);\nconst vec3 ORIGIN = vec3(0.0, 0.0, 0.0);\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_RIGHT = vec3(1.0, 0.0, 0.0);\nconst vec3 WORLD_FORWARD = vec3(0.0, 0.0, 1.0);\nconst vec3 LIGHT_DIR = vec3(-1.0, -1.0, -2.0);\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection \n{\n    vec3 position;\n    vec3 normal;\n    float distance_t;\n    int material_id;\n};\n\nfloat sdfSphere(vec3 query_position, vec3 position, float radius)\n{\n    return length(query_position - position) - radius;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n","name":"Common","description":"","type":"common"}]}