{"ver":"0.1","info":{"id":"fldGR7","date":"1635885301","viewed":152,"name":"Nodevember Day 1/2 - 3 Sides","username":"y2k_cyborg","description":"Just messing around","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","nodevember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on https://www.shadertoy.com/view/sllGDN\n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Performance settings\n// Enabling AA is more expensive but looks quite a lot better\n#define USE_AA 0\n// Continue further raycast after refraction?\n#define MAX_RAYS_PER_PRIMARY 3.\n\n#define MAX_STEPS 128\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nconst int MAT_BASE=1;\nconst int MAT_BARS=2;\nconst int MAT_BALL=3;\nconst int MAT_LINE=4;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b) {\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c);\n}\n\nvec2 sdBall(vec3 p, float a) {\n    \n    p.y-=1.01;\n    p.xy *= Rot(a);\n    p.y+=1.01;\n    \n    float ball = length(p)-.15;\n    float ring = length(vec2(length(p.xy-vec2(0, .15))-.03, p.z))-.01;\n    ball = min(ball, ring);\n    \n    p.z = abs(p.z);\n    float line = sdLineSeg(p, vec3(0,.15,0), vec3(0, 1.01, .4))-.005;\n    \n    float d = min(ball, line);\n    \n    return vec2(d, d==ball ? MAT_BALL : MAT_LINE);\n}\n\nfloat udIsoTriangle( vec3 p, float r )\n{\n  const float cos30 = 0.86602540378;\n  float h = r;\n  vec3 a = vec3(-h, -h*cos30, 0.);\n  vec3 b = vec3(+h, -h*cos30, 0.);\n  vec3 c = vec3( 0,  h*cos30, 0.);\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdPrism( in vec3 p, in float r, in float h )\n{\n    float d = udIsoTriangle(vec3(p.xy, 0.), r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\n// for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\nfloat toPrism(in float d2d, in float v, in float size) {\n    vec2 d = vec2(d2d, abs(v) - 0.5 * size);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat nPrism(in int n, in vec3 p, in float r, in float depth) {\n    float d = nGon(n, p.xy, r);\n    return toPrism(d, p.z, depth);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 Min(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\nfloat noise(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat fbm( vec2 x, float H )\n{    \n    float G = exp2(-H);\n    float skip = 0.;\n    float f = pow(2., skip);\n    float a = pow(G, skip);\n    float t = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec2 GetDist(vec3 p) {\n    float d = MAX_DIST;\n    int mat = MAT_BALL;\n    \n    // p.xz *= Rot(.005 * sqrt(dot(p.xz, p.xz)));\n    \n    vec3 prism_origin = vec3(0.,.8,0.);\n    vec3 prism_query = p - prism_origin;\n    prism_query.yz *= Rot(3.14159 * .15);\n    prism_query.xy *= Rot(iTime);\n        \n    float c = 7.;\n    prism_query = mod(prism_query+0.5*c,c)-0.5*c;\n\n    // d = nPrism(3, prism_query, 0.3, 2.) - 0.02;\n    // d = sdBox(prism_query, vec3(0.4)) - 0.02;\n    d = sdPrism(prism_query, .5, 1.) - 0.02;\n    \n    return vec2(d, mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    vec2 dSMat = vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p)*side;\n   \n        dO += dSMat.x;\n        if(dO>MAX_DIST || abs(dSMat.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dSMat.y);\n    //return vec2(MAX_DIST, 0.);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 EnvCol(vec3 rd) {\n  vec3 ground_col = vec3(.2,.25,.3);\n  vec3 sky_col = vec3(.6, .9, .9);\n  float t = smoothstep(.4, .6, rd.y * .5 + .5);\n  vec3 sky = t * sky_col + (1.-t) * ground_col;\n  float theta = atan(rd.z, rd.x);\n  float phi = atan(rd.y, rd.x);\n  float rzx = dot(rd.xz, rd.xz);\n  float sky_top = 1. * sin(theta * 12.) + .2;\n  //float sky_top = - .5*fbm(.001 * vec2(theta, phi), .5);\n  float sky_bottom = .6 * sin(rzx * 3.14159); // + .05 * cos(theta * 357.8746) * sin(rzx * 3.14159 * 454.8465);\n  float t2 = smoothstep(-.2, 0., rd.y);\n  return sky + (t2 * sky_top + (1.-t2) * sky_bottom);\n}\n\nvec4 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last) {\n    vec3 col = EnvCol(rd);\n    vec2 dMat = RayMarch(ro, rd, 1.);\n    float d = dMat.x;\n    \n    ref *= 0.;\n    \n    float alpha = 0.;\n    const float IOR = 1.35; // index of refraction\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        // Colour of reflection, going to environment\n        vec3 refOutside = EnvCol(r);\n        \n        // Ray refracted internally\n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n\n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.).x; // inside the object\n\n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit);\n\n        vec3 rdOut = refract(rdIn, nExit, IOR);\n        if (dot(rdOut, rdOut) == 0.) {\n          rdOut = reflect(rdIn, nExit);\n        }\n\n        // Next iteration's ray\n        ro = pExit - nExit*SURF_DIST*3.;\n        rd = rdOut;\n        alpha = 1.;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n\n        // The rest of the mixing happens in the RenderAll loop\n        col = vec3(0);\n        ref = vec3(.8);\n        if (last) {\n          // We won't spawn a further ray, but get the colour of the refracted ray going to environment\n          const float dens = .1;\n          float optDist = exp(-dIn*dens);\n          vec3 reflTex = EnvCol(rdOut) * optDist;\n          col += reflTex*ref;\n        }\n        col = mix(col, refOutside, fresnel);\n    }\n    return vec4(col, alpha);\n}\n\nvec3 RenderAll(vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(iTime * .3);\n    ro.xz *= Rot(-m.x*6.2831);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.75,0), 2.);\n    vec3 col = vec3(0.);\n    vec3 ref, fil=vec3(1);\n   \n    for(float i=0.; i<MAX_RAYS_PER_PRIMARY; i++) {\n        vec4 pass = Render(ro, rd, ref, i==MAX_RAYS_PER_PRIMARY-1.);\n        col += pass.rgb*fil;\n        fil*=ref;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = RenderAll(fragCoord);\n    \n    // Anti-aliasing\n    #if USE_AA\n    col +=\n        RenderAll(fragCoord+vec2(.5,.0))+\n        RenderAll(fragCoord+vec2(.0,.5))+\n        RenderAll(fragCoord+vec2(.5,.5));\n    col /= 4.;\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}