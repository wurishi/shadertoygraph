{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define resolution (iResolution.xy)\n#define t (iTime * .3)\n\n// Simplest Lambert+Phong material shading model parameters\nstruct mat_t {\n    vec3 diffuse;\n    vec4 specular;\n};\n\n// There are two separate distance fields, each consists of 6 metaballs and a plane.\n#define N 6\nvec3 b1[N];\nvec3 b2[N];\n\n// Four lights with their positions and colors\nvec3 l1pos = 1.*vec3(6., 3., -7.);\nvec3 l2pos = 1.*vec3(-7., 1., 6.);\nvec3 l3pos = 1.*vec3(7., -4., 7.);\nvec3 l4pos = vec3(0.,5.,25.);\nvec3 l1color = 40.*vec3(1.,.7,.7);\nvec3 l2color = 20.*vec3(.7,.7,1.);\nvec3 l3color = 60.*vec3(.7,1.,.7);\nvec3 l4color = vec3(100.);\n\n// Distance function approximation for the first field only\nfloat t1(vec3 p) {\n    float v = 0.;\n    for (int i = 0; i < N; ++i) {\n        vec3 b = p - b1[i];\n        // metaball field used here is a simple sum of inverse-square distances to metaballs centers\n        // all numeric constants are empirically tuned\n        v += 5. / dot(b, b);\n    }\n    // add top y=12 (red) plane\n    float d = 12. - p.y; v += 3. / (d*d);\n    return v;\n}\n\n// Second field distance function is basically the same, but uses b2[] metaballs centers and y=-12 plane\nfloat t2(vec3 p) {\n    float v = 0.;\n\tfor (int i = 0; i < N; ++i) {\n        vec3 b = p - b2[i];\n        v += 5. / dot(b, b);\n    }\n    float d = 12. + p.y; v += 3. / (d*d);\n    return v;\n}\n\n// \"Repulsive\" distance functions which account for both fields\nfloat w1(vec3 p) { return 1. - t1(p) + t2(p); }\nfloat w2(vec3 p) { return 1. + t1(p) - t2(p); }\n\n// Combined world function that picks whichever field is the closest one\nfloat world(vec3 p) {\n    return min(w1(p), w2(p));\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.001,0.);\n    return normalize(vec3(\n        world(p+e.xyy) - world(p-e.xyy),\n        world(p+e.yxy) - world(p-e.yxy),\n        world(p+e.yyx) - world(p-e.yyx)));\n}\n\n// Material is picked based on which field's distance function is the smallest\nmat_t material(vec3 p) {\n    mat_t m;\n    m.diffuse = vec3(0.);\n    m.specular = vec4(0.);\n    if (w1(p) < w2(p)) {\n        m.diffuse = vec3(.92, .027, .027);\n        m.specular = vec4(mix(vec3(1.),m.diffuse,.7), 2000.);\n    } else {\n        m.diffuse = vec3(.14, .17, 1.57);\n\t    m.specular = vec4(mix(vec3(1.),m.diffuse,.5), 100.);\n    }\n    return m;\n}\n\nfloat iter = 0.;\n\n// Raymarcher\nfloat trace(in vec3 O, in vec3 D, in float L, in float Lmax) {\n    // The usual \"step along the ray\" loop\n    float Lp = L;\n    for (int i = 0; i < 40; ++i) {\n        iter = float(i);\n        float d = world(O + D * L);\n        if (d < .01*L || L > Lmax) break;\n        // Store previous point (see below)\n        Lp = L;\n        \n        // Overstep a bit to find intersetion faster (metaball fields aren't cheap)\n        L += d * 1.5;\n    }\n    \n    if (L < Lmax) {\n        // Binary search for more exact intersestion position\n        // Needed to fix artifacts due to overstep\n        for (int i = 0; i < 5; ++i) {\n            float Lm = (Lp + L) * .5;\n            if (world(O + D * Lm) < .01*Lm) L = Lm; else Lp = Lm;\n        }\n    }\n    iter /= 32.;\n    return L;\n}\n\n// Simpler tracing function that tries to determine whether the point is in shadow\nfloat shadowtrace(vec3 p, vec3 d, float lmax) {\n    float v = .02;\n    // Take a few samples between the point and the light position and chech\n    // whether they are \"inside\" geometry\n    for (int i = 1; i < 9; ++i) {\n        v = min(v, world(p+d*lmax*float(i)/12.));\n    }\n    return smoothstep(.0, .02, v);\n    \n}\n\n// Compute shading color from a single light\nvec3 enlight(vec3 p, vec3 v, vec3 n, mat_t m, vec3 lpos, vec3 lcolor) {\n    vec3 ldir = lpos - p; // direction from the point to the light source\n    float ldist2 = dot(ldir, ldir); // square distance to the light source\n    float ldist = sqrt(ldist2); // distance\n    ldir /= ldist; // ldir is now normalized\n    float shadow = shadowtrace(p, ldir, ldist-.2); // whether the point is in shadow\n    return shadow * lcolor * (\n        // Diffuse term (simple Lambert)\n\t  m.diffuse * max(0., dot(n,ldir))\n        // Specular term (Phong-ish)\n\t+ m.specular.rgb * pow(max(0.,dot(normalize(ldir-v), n)), m.specular.w)\n        // Specular energy conservation? (or something, it was 3 years ago :D)\n        * (m.specular.w + 2.) * (m.specular.w + 4.) / (24. * (m.specular.w + pow(2., -m.specular.w/2.)))\n\t) / ldist2;\n}\n\n// A ridiculous hack to display light sources\n// Basic idea is to check whether the ray is \"close enough\" to the light source position in screen space\n// Which is done by calculating the angle between the actual pixel ray and a vector from origin to the light source\nvec3 lightball(vec3 lpos, vec3 lcolor, vec3 O, vec3 D, float L) {\n    vec3 ldir = lpos-O;\n    float ldist = length(ldir);\n    if (ldist > L) return vec3(0.);\n    float pw = pow(max(0.,dot(normalize(ldir),D)), 20000.);\n    return (normalize(lcolor)+vec3(1.)) * pw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Calculate metaball trajectories (all empirical)\n    for (int i = 0; i < N; ++i) {\n        float fi = float(i)*.7;\n        b1[i] = vec3(3.7*sin(t+fi), 1.+10.*cos(t*1.1+fi), 2.3*sin(t*2.3+fi));\n        fi = float(i)*1.2;\n        b2[i] = vec3(4.4*cos(t*.4+fi),-1.-10.*cos(t*0.7+fi), -2.1*sin(t*1.3+fi));\n    }\n\n    vec2 uv = fragCoord.xy / resolution.xy * 2. - 1.;\n    uv.x *= resolution.x / resolution.y;\n\n    vec3 O = vec3(0.,0.,20.);\n    vec3 D = normalize(vec3(uv,-1.6));\n\n    if (iMouse.z > 0.)\n    {\n        vec2 m = iMouse.xy/iResolution.xy*2.-1.;\n        float a = - m.x * 2. * 3.1415926;\n        float s = sin(a), c = cos(a);\n        O = vec3(s*20.,-m.y*10.,c*20.);\n        vec3 fw = normalize(vec3(0.) - O);\n        vec3 rg = cross(fw,vec3(0.,1.,0.));\n        D = normalize(mat3(rg, cross(rg, fw), -fw) * D);\n    }\n\n    // Raymarch\n    float L = trace(O, D, 0., 40.);\n    vec3 color = vec3(0.);\n    if (L < 40.) {\n        // If a hit is detected, then get the position\n        vec3 p = O + D * L;\n        // And normal\n        vec3 n = normal(p); \n        // And material\n        mat_t m = material(p);\n        \n        // Ambient term (I don't think it is visible much)\n        color = .001 * m.diffuse * n;\n        \n        // Shade for all lights\n        color += enlight(p, D, n, m, l1pos, l1color);\n        color += enlight(p, D, n, m, l2pos, l2color);\n        color += enlight(p, D, n, m, l3pos, l3color);\n        color += enlight(p, D, n, m, l4pos, l4color);\n        \n        // Fog-like hack-ish attenuation, so the only the center of the scene is visible\n        color *= (1. - smoothstep(10., 20., length(p)));\n\t} else L = 100.;\n \n    // Add light sources hack\n    color += lightball(l1pos, l1color, O, D, L);\n    color += lightball(l2pos, l2color, O, D, L);\n    color += lightball(l3pos, l3color, O, D, L);\n    color += lightball(l4pos, l4color, O, D, L);\n\n    // Gamma correct and out\n\tfragColor = vec4(pow(color,vec3(.7)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xs2XDV","date":"1416772177","viewed":2856,"name":"twofield","username":"w23","description":"Oh, this stuff is repulsive.","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaballs"],"hasliked":0,"parentid":"","parentname":""}}