{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\t\n\t//These values control the general shape ray marching\n\tconst int max_iterations = 20;\n\tconst int furLayers = 50;\n\tconst float stop_threshold = 0.001;\n\tconst float grad_step = 0.001;\n\tconst float clip_far = 5.0;\n\tconst float PI = 3.14159265359;\n\t\n\n\t//These values are for the simple animation.\n\tfloat animateAfter = 0.;\n\tfloat rotationY = 0.;\n\tfloat rotationX = 0.;\n\tfloat elevation = 0.;\n\n\n\t//Rotation functions\n\tmat3 rotX(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(1.0, 0.0, 0.0, 0.0, a.x, -a.y, 0.0, a.y, a.x);\n\t}\n\t\n\tmat3 rotY(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(a.x, 0.0, a.y, 0.0, 1.0, 0.0, -a.y, 0.0, a.x);\n\t}\n\n\tmat3 rotZ(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(a.x, a.y, 0.0, -a.y, a.x, 0.0, 0.0, 0.0, 1.0);\n\t}\n\n\t//Axis displacement on a surface.\n\tfloat dd(float u, vec3 v) {\n\t\tv.x *= 0.5;\n\t\tfloat s = (u + v.x) * step(-u, v.x) * step(u, v.y - v.x) / v.y;\n\t\ts += step(-u, v.x - v.y) * step(u, v.x - v.z);\n\t\ts += (v.x - u) * step(-u, v.z - v.x) * step(u, v.x) / v.z;\t\t\n\t\ts = s * s * (3. - 2. * s);\n\t\t\n\t\treturn s;\n\t}\n\n\t//Iq noise functions...\n\tfloat hash( float n ) {\n\t    return fract(sin(n)*43758.5453);\n\t}\n\n\tfloat noise( in vec3 x ) {\n   \t vec3 p = floor(x);\n   \t vec3 f = fract(x);\n\t\n\t    f = f*f*(3.0-2.0*f);\n\t    float n = p.x + p.y*57.0 + 113.0*p.z;\n\t    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\t}\n\n\t/*\n\t* Deformations used to modify a sphere into the \n\t* shape of the head, it deforms the space to obtain\n\t* global or local changes like the zone of the eyes.\n\t*/\n\tvec3 deformation(vec3 p) {\n\t\t\n\t\tp *= rotY(rotationY);\n\t\tp *= rotX(rotationX);\n\t\tp.y *= 0.85;\t\t\n\t\t\n\t\t\n\t\t//Deformation for the zone of the eyes.\n\t\tfloat n= .99 * pow(abs(4.2 * (p.y + 4.8 * pow(abs(p.x), 2.4) * clamp((p.y - 0.4), -1., 1.)) - 1.5), 3.6);\n\t\tp.z *= 1. + 0.4 * step(p.z, 0.) / (0.9 + n) ;\n\t\t\n\t\t//Making the sphere less rounded.\n\t\tn = sqrt(p.y + 1.);\n\t\tp.xz = 1.2 * pow(abs(p.xz), vec2(1.2)) * ( 1.08 - 0.7 * (1. - n) * exp( -1.0 * pow(abs(p.y + 0.2), 12.)));\n\t\t\n\t\t//Making more planar the upper and lower border of the head\n\t\tp.y -= 0.26 * p.x * exp( -1.0 * pow(abs(p.y - 1.1), 12.)) - 0.085;\n\t\t\n\t\t\n\t\treturn p;\n\t}\n\n\t/*\n\t* Most of the modelling is made using displacements over a deformed\n\t* sphere since the raymarching of the hair does not allow multiple\n\t* objects using the mix function.\n\t*\n\t* The main idea is to deform a sphere to create a basic shape and then\n\t* use the displacements to give more details to it.\n\t*\n\t* The function return all the displacemts that will occur on the sphere\n\t* and it also return the differents displacements for coloring phases. It\n\t* also works deforming local vectors on the deformed sphere.\n\t*\n\t*/\n\n\tfloat  displacements(in vec3 p, out float displace[6]) {\n\t\t\t\t\t\t\n\t\t//displacement for the eyes\n\t\tvec3 u = p;\n\t\tu.x = abs(u.x);\n\t\tu += vec3(-0.17, -0.42, 0.46);\n\t\tdisplace[1] = -0.15 * exp(-500000. * pow(length(u), 6.5));\n\t\tu.y += 2.6 * pow(abs(u.x), 2.2);\n\t\tdisplace[2] = length(u.xy);\n\t\tdisplace[2] = 0.04 * dd(u.y - 0.16 + 0.03 * elevation, vec3(0.25, vec2(0.025))) * step(displace[2], 0.22) * exp(-6200. * pow(abs(displace[2]), 4.2));\n\t\t\n\t\t//displacement for the nose.\n\t\tu = p;\n\t\tdisplace[0] = abs(cos(pow(u.y, 2.) * 12. - 0.8));\n\t\tdisplace[0] *= displace[0] * displace[0] * displace[0] * (3. - 2. * displace[0]);\n\t\tu.x *= (2. - 1. * displace[0]) * (1. + pow(abs(3. * u.y), 3.));\n\t\tdisplace[3] = 0.38 * dd(u.y - 0.3, vec3(0.5, vec2(0.2, 0.3))) * dd(u.x, vec3(0.5, vec2(0.25))) * (1. - exp(-21.1 * pow(abs((u.y - 1.22 + 1.5 * pow(abs(u.x), 2.))), 66.))) * (1. + pow(abs(8. * p.x), 4.));\n\t\tdisplace[4] = displace[3] * step(u.y, .47) * step(p.z, 0.5);\n\t\t\n\t\t//displacement for the holes of the nose.\n\t\tu = p;\n\t\tu.x = abs(p.x);\n\t\tu.xy -= vec2(0.065, 0.15);\n\t\tdisplace[3] -= .1 * exp(-1400. * pow(length(u.xy), 2.2));\n\t\t\n\t\t//displacement for the horns.\t\t\n\t\tu = p;\n\t\tu.x = abs(p.x) - 1.1;\n\t\tu.yz += 0.003 * sin(u.x * 90.) + vec2(-0.2, 0.05);\n\t\tdisplace[0] = clamp(1., 0., u.x + 0.45);\n\t\tu.y -= 0.45 * sqrt(1. - displace[0] * displace[0]) - 0.2;\n\t\tdisplace[0] = 0.9 * exp(- 1000. * pow(length(u.yz), 3.5));\n\t\t\n\t\t//displacement for the mouth.\n\t\tu = p;\n\t\tu.y += 0.15 - 0.6 * pow(abs(u.x), 2.);\n\t\tu.xy = 1.6 * pow(abs(u.xy), vec2(1.5));\n\t\tu.xy *= vec2(0.6, 15. + 1500. * pow(abs(u.x * 0.7), 2.));\n\t\tdisplace[5] = 0.5 * exp(-400. * pow(length(u.xy), 2.9));\n\t\tu.xy = 1.3 * pow(abs(u.xy), vec2(1.1));\n\t\tdisplace[5] -= 0.03 * exp(-500000. * pow(0.12 * length(u.xy), 6.6));\n\t\tdisplace[5] *= smoothstep(0.16, 0., u.x);\n\n\t\t\n\t\treturn (displace[1] -displace[2] - displace[3] + displace[5]) * step(p.z, 0.5) - displace[0];\n\t}\n\n\t//This function return the depth from the distance field.\n\tvec3 map(vec3 p) {\n\t\t\n\t\tvec3 u = p;\n\t\tfloat displace[6];\n\t\t\n\t\tu *= rotY(rotationY);\n\t\tu *= rotX(rotationX);\n\t\tp = deformation(p);\n\t\tvec3 s = vec3(length(p) - 1., 0., 0.);\n\t\t\n\t\ts.x += displacements(u, displace);\t\t\n\t\ts.x *= 0.2;\n\t\treturn s;\n\t}\n\n\t//This is map function that also defines the color for the differents displacemetns\n\tvec3 colorMap(vec3 p) {\n\t\t\t\n\t\tvec3 u = p;\n\t\tvec4 r = 0.8 * vec4(0.09, .077, .055, 0.01);\n\t\tfloat displace[6];\n\t\t\n\t\tu *= rotY(rotationY);\n\t\tu *= rotX(rotationX);\n\t\t\n\t\tp = deformation(p);\n\t\tvec3 s = vec3(length(p) - 1., 0., 0.);\n\t\ts.x += displacements(u, displace);\n\t\t\n\t\tu.x = abs(u.x);\n\t\tu -= vec3(0.17, 0.40 - 0.01 * elevation, -0.46);\n\t\tfloat n = length(u.xy);\n\t\ts.z = atan(u.y, u.x);\n\t\t\n\t\t/*\n\t\t* Colors for the displacements, the values displace[i]\n\t\t* make reference to the return values from the displacement function\n\t\t*/\n\t\t\n\t\ts.y = step(1. + displace[1], 0.98);\n\t\ts.y += (3. - s.y) * step(-n, -r.y) * step(n, r.x) * step(u.z, 0.0);\n\t\ts.y += (4. - s.y) * step(-n, -r.z) * step(n, r.y) * step(u.z, 0.0);\n\t\ts.y += (3. - s.y) * step(n, r.z) * step(u.z, 0.0);\n\t\t\n\t\tu.xy += vec2(-0.05, -0.03);\n\t\ts.y += (0. - s.y) * step(length(u.xy), r.w) * step(u.z, 0.0);\n\t\t\n\t\ts.y += (0. - s.y) * step(1. - displace[2], 0.9999);\n\t\ts.y += (2. - s.y) * step(1. - displace[4], 0.995);\n\t\ts.y += (3. - s.y) * step(1. - displace[5], 0.99);\n\t\ts.y += (1. - s.y) * step(1. - displace[0], 0.9999);\n\t\t\n\t\ts.x *= 0.2;\n\t\t\n\t\treturn s;\n\t}\n\n\t//This function sets a texture mapping to the distance field to define the hair zones.\n\tvec2 cartesianToSpherical(vec3 p) {\t\n\t\t\n\t\tfloat r = length(p);\n\t\tp = normalize(p);\n\t\tr = (r - (1.0 - 0.4)) / 0.4;\n\t\tp.zyx *= rotX(rotationY);\n\t\tp.zyx *= rotZ(-rotationX);\n\n\t\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\n\t\tuv.y -= r * r * 0.15 * clamp(noise(8. * p), 0.1, 1.);;\n\t\t\n\t\treturn uv;\n\t}\n\t\n\t/*\n\t* This function defines the hair density bases on a texture\n\t* it also change the density based on a 3D noise function and the\n\t* the displacements made on the sphere.\n\t*/\n\tfloat furDensity(vec3 p, out vec3 dp) {\n\t\t\n\t\tvec4 tex = texture(iChannel0, cartesianToSpherical(p.xzy) * 0.5);\n\t\t\n\t\tvec3 u = p;\n\t\tu *= rotY(rotationY);\n\t\tu *= rotX(rotationX);\n\t\t\n\t\tfloat displace[6];\n\t\tfloat dis = displacements(u, displace);\n\t\tdp = deformation(p);\n\t\tp = dp + dis;\n\t\t\n\t\tfloat density = smoothstep(0.3, 1.0, tex.x);\t\t\n\t\t\n\t\tfloat r = (length(p) + dis - 0.6) / 0.4;\n\t\t\n\t\tdensity *= 1.- r;\n\t\t\n\t\tfloat val = noise(2.1 * p);\n\t\tdensity -= 0.030 * pow(abs(val), 3.);\n\t\t\n\t\tr = step(1. + dis, 0.98);\n\t\tdensity *= 1. + 1. * r;\n\t\t\n\t\treturn density;\n\t\t\n\t}\n\n\t//Gradient to define the normal of a surface.\n\tvec3 gradient( vec3 v ) {\n\t\tconst vec3 delta = vec3( grad_step, 0.0, 0.0 );\n\t\tfloat va = map(v).x;\n\t\treturn normalize (vec3(map( v + delta.xyy).x - va, map( v + delta.yxy).x - va, map( v + delta.yyx).x - va));\n\t}\n\n\t//function that raymarch the base distance field (without hair).\n\tvec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\t\n\t\tfloat depth = start;\n\t\tvec3 salida = vec3(end);\n\t\tvec3 dist = vec3(0.1);\n\t\t\n\t\tfor ( int i = 0; i < max_iterations; i++ ) \t\t{\n\t\t\tif ( dist.x < stop_threshold || depth > end ) break;\n                dist = map( origin + dir * depth );\n                depth += dist.x;\n\t\t}\n\t\t\n\t\tdist = colorMap( origin + dir * depth );\n\t\t\n\t\tsalida = vec3(depth, dist.y, dist.z);\n\t\treturn salida;\n\t}\n\n\t//Shading for the base distance field (without hair)\n\tvec3 shading( vec3 v, vec3 n, vec3 eye, vec3 l) {\n\t\n\t\tvec3 ev = normalize( v - eye );\n\t\tvec3 ref_ev = reflect( ev, n );\n\t\tvec3 light_pos   = vec3(0.0, 2.0, -8.0);\n\t\tvec3 vl = normalize( light_pos - v );\n\t\tfloat d  = max( 0.0, dot( vl, n ) );\n\t\tfloat s = max( 0.0, dot( vl, ref_ev ) );\n\t\ts = pow( s, l.x );\n\t\t\n\t\treturn vec3( 0.9 ) * ( d * l.y + s * l.z) + vec3(0.1);\n\t}\n\n\t//Ray direction to the rendering plane\n\tvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\t\tvec2 xy = pos - size * 0.5;\n\n\t\tfloat cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));\t\n\t\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\t\treturn normalize( vec3( xy, z ) );\n\t}\n\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\t\n\t\tvec3 rd = ray_dir(50.0, iResolution.xy, fragCoord.xy );\n\t\tvec3 eye = vec3( .0, .0, -3.5);\n\t\tvec3 l = vec3(2., 0.45, 0.15);\n\t\tvec3 color = vec3(0.);\n\n\t\tvec3 data = ray_marching( eye, rd, 0.0, clip_far );\n\t\tif ( data.x < clip_far ) {\n\t\t\t\n\t\t\tvec3 pos = eye + rd * data.x;\n\t\t\tvec3 n = gradient( pos );\n\t\t\tvec3 lightColor =  shading( pos, n, eye, l) * 2.0;\n\t\t\tvec3 mainColor = vec3(80., 170., 180.) * lightColor / 190.;\n\t\t\t\n\t\t\tmainColor *= (0.2 + 1.3 * pow(noise(2. * pos * rotY(rotationY + 180.)), 0.7));\t\t\t\n\t\t\t\n\t\t\tcolor = mainColor * step(data.y, 0.5) * step(-data.y, 0.5);\n\t\t\tcolor += vec3(0.8) * lightColor * step(data.y, 1.5) * step(-data.y, -.5);\t\n\t\t\tcolor += 0.6 * mainColor * step(data.y, 2.5) * step(-data.y, -1.5);\t\n\t\t\tcolor += vec3(0.1) * lightColor * step(data.y, 3.5) * step(-data.y, -2.5);\n\t\t\tcolor += 0.7 * vec3(0.5, 0.7, 0.9) * (0.01 + 0.99 * abs(cos(data.z + 1.3))) * lightColor * step(data.y, 4.5) * step(-data.y, -3.5);\t\t\n\t\t\t\n\t\t\t/*\n\t\t\t* If thereÂ´s a point to render from the distance field\n\t\t\t* a second ray marching occurs if the material requires so.\n\t\t\t* if not, the pixel is renderer with the base distance function information.\n\t\t\t*/\n\t\t\t\n\t\t\tif(data.y <= 1.) {\n\t\t\t\tvec4 c = vec4(0.);\n\t\t\t\tvec4 sampleCol;\n\t\t\t\tvec3 dp = vec3(0.);\n\t\t\t\tfor(int i=0; i<furLayers; i++) {\n\t\t\t\t\tsampleCol.a = furDensity(pos, dp);\n\t\t\t\t\tif (sampleCol.a > 0.) {\n\t\t\t\t\t\tsampleCol.rgb = sampleCol.a * color * clamp((length(dp) - (1.0 - 0.4)) / 0.4, 0.55, 1.);\t\t\t\t\t\t\t\n\t\t\t\t\t\tc +=  sampleCol * (1.0 - c.a);\n\t\t\t\t\t}\nif( c.a>0.99 ) break;\t\t\t\t\tpos += rd * 0.016;\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t\tcolor = c.xyz;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\n\t\tfragColor = vec4(color, 1.0 );\n\t} ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdlXz4","date":"1397571160","viewed":3956,"name":"Fur character face","username":"hat","description":"The shader works much better with more furLayers (~100) and a little less furThreshold (~0.4). Sadly it requires low iterations to work in most computers.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","distancefield","fur","displacements"],"hasliked":0,"parentid":"","parentname":""}}