{"ver":"0.1","info":{"id":"l3BfWh","date":"1729470577","viewed":203,"name":"Roundtrip float32 printing","username":"FordPerfect","description":"A utility to convert float32 to a decimal representation (roughly similar to \"%.8e\" of prinf() function in C), that roundtrips, i.e. produces the original value assuming correctly-rounded text-to-float conversion.\nMouse to toggle bits.","likes":14,"published":3,"flags":32,"usePreview":0,"tags":["text","float","print","ieee754"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Public Domain under http://unlicense.org, see link for details.\n\n// A utility to convert float32 to a decimal representation (roughly\n// similar to \"%.8e\" of prinf() function in C), that roundtrips,\n// i.e. produces the original value assuming correctly-rounded\n// text-to-float conversion.\n// Mouse to toggle bits.\n\n// A function signature is:\n//     ivec4 float2dec(float value)\n//     ivec4 float2dec(uint bits)\n// and the returned value D contains the decimal representation:\n//     D.x     = fpclassify(value)\n//     decimal = D.y * 10^D.z * (D.w/10^8)\n// where D.y is the sign (+1 of -1), D.z is exponent (-45<=D.<=+38),\n// and D.w is the scaled normalized significand (10^8<=D.w<10^9, unless\n// value is 0, in which case D.w is 0 as well; or value is not\n// finite, in which case special encoding applies, see code).\n// NOTE: some implementations may not support certain\n// bitwise representations for floats (e.g. subnormals),\n// which is the reason why the version directly accepting\n// a bitwise representation is also provided.\n// NOTE: D.w holds 9 significant decimal digits, which is enough\n// for roundtrip in float32. The general formula for needed digits\n// in non-trivial base conversions (see David W. Matula. 1968.\n// \"In-and-out conversions\".) is\n//     N = 2 + floor(n*log(b)/log(B))\n// with B=10, b=2, n=24 in our case.\n//\n// Converting float<->text quickly and accurately is a surprisingly\n// involved problem (see e.g. https://www.ryanjuckett.com/printing-floating-point-numbers/\n// for a decent overview, and https://github.com/swiftlang/swift/pull/35299,\n// https://github.com/KhronosGroup/SPIRV-Cross/issues/1599#issuecomment-762965884\n// for some newer developments). We do not aspire to the lofty heights\n// of producing correctly-rounded result and/or shortest roundtrip\n// representation. Instead, we set a minimal correctness goal:\n// produce *some* representation that roundtrips to the original number\n// (assuming correctly-rounded text-to-float conversion). The resulting\n// code is relatively short and requires only uint32 arithmetic.\n//\n// Algorithm description.\n// After handling special cases, and renormalizing subnormals, we\n// are faced with a binary floating-point number of the form\n//     S * 2^e * (m/2^23)\n// where |S|=1, 2^23<=m<2^24. We need to convert it to a decimal\n// representation\n//     S * 10^E * (M/10^8)\n// with 10^8<=M<10^9.\n// First, we find an approximation of E which is off by at most 1,\n// simply multiplying e by an approximation of log(2)/log(10): for\n// our purposes 77/256 is good enough. With both e and E known,\n// we simply need to compute\n//     M = 2^(e-23)/10^(E-8) * m\n//       = 2^(e-E-15)/5^(E-8) * m\n//       = 2^(e-E-22)/5^(E-8) * (2^7 * m)\n// where we multiplied m by 2^7 to put it roughly in required\n// range of output ([2^30;2^31-1] vs [10^8;10^9-1]).\n// We work essentially in 32.32 fixed point, multiplying\n// the current value by successive 2^x/5^y ratios close to 1.0,\n// so that neither overflow nor significant loss of precision\n// occurs, until we run out of powers of 5. Then we shift by\n// remaining powers of two and possibly perform a fixup by\n// either multiplying or dividing by 10 if signinficand is not\n// in the required range. All computations fit into uint32.\n// For slightly nicer output, scaling by 2^x/5^y is done\n// using rounding, but truncation produces correct results too.\n// To verify that the result is not ruined by the limited\n// range/precision of the intermediate computations, the\n// roundtrip property was exhaustively verified on all float32\n// numbers in [+0;+FLT_MAX] range using glibc 2.31-9 version\n// of scanf(\"%f\",...) (presumed correctly-rounded).\n\n// References:\n// David W. Matula. 1968. In-and-out conversions. Commun. ACM 11, 1 (Jan. 1968), 47–50. https://doi.org/10.1145/362851.362887\n//     https://dl.acm.org/doi/10.1145/362851.362887\n// Guy L. Steele and Jon L. White. 1990. How to print floating-point numbers accurately. In Proceedings of the ACM SIGPLAN 1990 conference on Programming language design and implementation (PLDI '90). Association for Computing Machinery, New York, NY, USA, 112–126. https://doi.org/10.1145/93542.93559\n//     https://kurtstephens.com/files/p372-steele.pdf (incl. retrospective)\n// William D. Clinger. 1990. How to read floating point numbers accurately. In Proceedings of the ACM SIGPLAN 1990 conference on Programming language design and implementation (PLDI '90). Association for Computing Machinery, New York, NY, USA, 92–101. https://doi.org/10.1145/93542.93557\n//     https://dl.acm.org/doi/10.1145/93548.93557\n// David M. Gay, Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis Manuscript 90-10, AT&T Bell Laboratories, Murray Hill, NJ (1990).\n//     https://web.archive.org/web/20060509111833/http://cm.bell-labs.com/cm/cs/what/ampl/REFS/rounding.pdf\n// Robert G. Burger and R. Kent Dybvig. 1996. Printing floating-point numbers quickly and accurately. In Proceedings of the ACM SIGPLAN 1996 conference on Programming language design and implementation (PLDI '96). Association for Computing Machinery, New York, NY, USA, 108–116. https://doi.org/10.1145/231379.231397\n//     https://legacy.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf\n// Florian Loitsch. 2010. Printing floating-point numbers quickly and accurately with integers. In Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '10). Association for Computing Machinery, New York, NY, USA, 233–243. https://doi.org/10.1145/1806596.1806623\n//     https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf\n// Marc Andrysco, Ranjit Jhala, and Sorin Lerner. 2016. Printing floating-point numbers: a faster, always correct method. SIGPLAN Not. 51, 1 (January 2016), 555–567. https://doi.org/10.1145/2914770.2837654\n//     https://cseweb.ucsd.edu//~lerner/papers/fp-printing-popl16.pdf\n// https://www.ryanjuckett.com/printing-floating-point-numbers/\n// https://github.com/swiftlang/swift/pull/35299\n// https://github.com/KhronosGroup/SPIRV-Cross/issues/1599#issuecomment-762965884\n// https://www.netlib.org/fp/dtoa.c\n// http://web.archive.org/web/20180829155232/http://www.hackersdelight.org/\n// https://github.com/hcs0/Hackers-Delight\n// https://graphics.stanford.edu/~seander/bithacks.html\n// @mla, \"Accurate Float Printing\",   https://www.shadertoy.com/view/7dfyRH\n// @mla, \"Accurate Float Printing 2\", https://www.shadertoy.com/view/7sscz7\n\n// Floating-point class, as per fpclassify().\n// NOTE: similar, but not quite identical to class()\n// operation of IEEE-754 (for one, class() distinguishes\n// quiet/signaling NaNs).\n#define FP_NAN       0\n#define FP_INFINITE  1\n#define FP_ZERO      2\n#define FP_SUBNORMAL 3\n#define FP_NORMAL    4\n\n// Based on nlz from \"Hacker's Delight\", see:\n//     https://github.com/hcs0/Hackers-Delight/blob/master/ilog.c.txt\nint clz(uint x)\n{\n    if(x==0u) return 32;\n    int ret=0;\n    if(x<=0x0000FFFFu) {ret+=16; x<<=16;}\n    if(x<=0x00FFFFFFu) {ret+= 8; x<<= 8;}\n    if(x<=0x0FFFFFFFu) {ret+= 4; x<<= 4;}\n    if(x<=0x3FFFFFFFu) {ret+= 2; x<<= 2;}\n    if(x<=0x7FFFFFFFu) {ret+= 1;}\n    return ret;\n}\n\n// Based on mulhu from \"Hacker's Delight\", see:\n//     https://github.com/hcs0/Hackers-Delight/blob/master/mulhu.c.txt\nuint mulhu32(uint a,uint b)\n{\n    uint a0=a&0xFFFFu,a1=a>>16;\n    uint b0=b&0xFFFFu,b1=b>>16;\n    uint l=a0*b0;\n    uint m=a0*b1+(l>>16),h=m>>16;\n    m=(m&0xFFFFu)+a1*b0;\n    return a1*b1+h+(m>>16);\n}\n\n// Rounded scaling: float(a*b/2^32+0.5)\nuint mul(uint a,uint b)\n{\n    return mulhu32(a,b)+((a*b)>>31);\n}\n\n#if 0\n// Old version.\n// Produces incorrectly-rounded result (that still roundtrips) ~42% of the time.\n\nivec4 float2dec(uint bits)\n{\n    int c=FP_NORMAL;\n    int s=int(bits>>31),S=1-2*s;\n    int e=int(bits>>23)&255;\n    int m=int(bits)&((1<<23)-1);\n    // Handle special cases.\n    if(e==255)\n    {\n        if(m==0) return ivec4(FP_INFINITE,S,0,1);\n        else     return ivec4(FP_NAN     ,S,0,m); // Store payload in .w.\n    }\n    else if(e==0)\n    {\n        if(m==0) return ivec4(FP_ZERO,S,0,0);\n        c=FP_SUBNORMAL;\n        int b=clz(uint(m))-(32-23-1);\n        m<<=b;\n        e-=b-1;\n    }\n    else m+=1<<23;\n    e-=127;\n    // Estimate decimal exponent, start computing decimal significand.\n    int E=(77*e)>>8;\n    int a=e-E-22,b=E-8;\n    uint M=uint(m)<<7;\n    // Scale by 2^x/5^y factors.\n    if(b<=-28) {b+=28; a+=65; M+=mul(M,0x027E72F1u);}\n    if(b>=+28) {b-=28; a-=65; M =mul(M,0xFD87B5F2u);}\n    if(b<=-22) {b+=22; a+=51; M+=mul(M,0x0F0CF064u);}\n    if(b>=+22) {b-=22; a-=51; M =mul(M,0xF1C90080u);}\n    if(b<=-12) {b+=12; a+=28; M =mul(M,0xE8D4A510u);}\n    if(b>=+12) {b-=12; a-=28; M+=mul(M,0x19799812u);}\n    if(b<=- 6) {b+= 6; a+=14; M =mul(M,0xF4240000u);}\n    if(b>=+ 6) {b-= 6; a-=14; M+=mul(M,0x0C6F7A0Bu);}\n    if(b<=- 3) {b+= 3; a+= 7; M =mul(M,0xFA000000u);}\n    if(b>=+ 3) {b-= 3; a-= 7; M+=mul(M,0x0624DD2Fu);}\n    if(b<=- 2) {b+= 2; a+= 5; M =mul(M,0xC8000000u);}\n    if(b>=+ 2) {b-= 2; a-= 5; M+=mul(M,0x47AE147Au);}\n    if(b<=- 1) {b+= 1; a+= 2; M+=mul(M,0x40000000u);}\n    if(b>=+ 1) {b-= 1; a-= 2; M =mul(M,0xCCCCCCCCu);}\n    // Experimantally, at this point -3<=a<=0.\n    M>>=-a;\n    if(M<  100000000u) {M*=10u; E-=1;}\n    if(M>=1000000000u) {M/=10u; E+=1;}\n    return ivec4(c,S,E,int(M));\n}\n#else\n// New version.\n// Produces incorrectly-rounded result (that still roundtrips) ~16% of the time.\n \nivec4 float2dec(uint bits)\n{\n    int c=FP_NORMAL;\n    int s=int(bits>>31),S=1-2*s;\n    int e=int(bits>>23)&255;\n    int m=int(bits)&((1<<23)-1);\n    // Handle special cases.\n    if(e==255)\n    {\n        if(m==0) return ivec4(FP_INFINITE,S,0,1);\n        else     return ivec4(FP_NAN     ,S,0,m); // Store payload in .w.\n    }\n    else if(e==0)\n    {\n        if(m==0) return ivec4(FP_ZERO,S,0,0);\n        c=FP_SUBNORMAL;\n        int b=clz(uint(m))-(32-23-1);\n        m<<=b;\n        e-=b-1;\n    }\n    else m+=1<<23;\n    e-=127;\n    // Estimate decimal exponent, start computing decimal significand.\n    int E=(77*e)>>8;\n    int a=e-E-22,b=E-8;\n    uint M=uint(m)<<7;\n    // Scale by 2^x/5^y factors.\n    if(b<0)    {b+=53; a+=123; M+=mul(M,0x0B46C6CEu);}\n    if(b>=+28) {b-=28; a-= 65; M =mul(M,0xFD87B5F2u);}\n    if(b>=+22) {b-=22; a-= 51; M =mul(M,0xF1C90080u);}\n    if(b>=+12) {b-=12; a-= 28; M+=mul(M,0x19799812u);}\n    if(b>=+ 6) {b-= 6; a-= 14; M+=mul(M,0x0C6F7A0Bu);}\n    if(b>=+ 3) {b-= 3; a-=  7; M+=mul(M,0x0624DD2Fu);}\n    if(b>=+ 2) {b-= 2; a-=  5; M+=mul(M,0x47AE147Au);}\n    if(b>=+ 1) {b-= 1; a-=  2; M =mul(M,0xCCCCCCCCu);}\n    // Experimantally, at this point -4<=a<=0.\n    M=(M+(M&((1u<<-a)-1u)))>>-a;\n    if(M<  100000000u) {M*=10u; E-=1;}\n    if(M>=1000000000u) {M/=10u; E+=1;}\n    return ivec4(c,S,E,int(M));\n}\n#endif\n\nivec4 float2dec(float value)\n{\n    return float2dec(floatBitsToUint(value));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float s=min(iResolution.x,iResolution.y)/32.0;\n    vec2 v=fragCoord.xy-0.5*iResolution.xy;\n    vec2 m=abs(iMouse.xy)-0.5*iResolution.xy;\n    uvec4 B=uvec4(texelFetch(iChannel0,ivec2(fragCoord),0))<<ivec4(0,8,16,24);\n    uint b=B.x+B.y+B.z+B.w;\n    vec3 col=vec3(0.0625);\n    if(all(lessThan(abs(v),vec2(16,1)*s)))\n    {\n        int n=int(clamp(16.0-v.x/s,0.0,31.0));\n        vec3 c=vec3(0.0);\n        if(n==31)      c+=vec3(0,2,4)/32.0;\n        else if(n>=23) c+=vec3(4,4,0)/32.0;\n        else           c+=vec3(1,4,1)/32.0;\n        if(((b>>n)&1u)>0u) c*=5.0;\n        c+=0.0625;\n        c*=smoothstep(0.0,1.25/s,0.5-abs(fract(v.x/s)-0.5));\n        c*=smoothstep(0.0,2.25/s,1.0-fract(abs(v.y/s)));\n        col+=c;\n    }\n    if(all(lessThan(abs(v+vec2(0,4.0*s)),vec2(15,1.25)*s)))\n    {\n        const int font[]=int[](0x01C0,0x4000,0x05D0,0x72CF,0x7B6F,0x4924,0x73E7,0x79E7,0x49ED,0x79CF,0x7BCF,0x4927,0x7BEF,0x79EF);\n        ivec4 D=float2dec(b);\n        ivec2 c=clamp(ivec2((v+vec2(15.0,5.25)*s)*2.0/s),ivec2(0),ivec2(15*4,5));\n        int n=c.x/4;\n        c.x%=4;\n        if(c.x%4<3)\n        {\n            int k=14;\n            if(n==0) k=1+D.y;\n            switch(D.x)\n            {\n                case FP_NORMAL:\n                case FP_ZERO:\n                case FP_SUBNORMAL:\n                    if(n==1) k=4+D.w/100000000;\n                    if(n==2) k=1;\n                    if(n>=3&&n<11)\n                    {\n                        int d=D.w;\n                        for(int i=0;i<10-n;++i) d/=10;\n                        k=4+d%10;\n                    }\n                    if(n==11) k=3;\n                    if(n==12) k=1+int(D.z>=0)-int(D.z<0);\n                    if(n==13) k=4+abs(D.z)/10;\n                    if(n==14) k=4+abs(D.z)%10;\n                    break;\n                case FP_INFINITE: // ASCII-art infinity.\n                    if(n==2||n==4) k=4;\n                    if(n==3) k=0;\n                    break;\n                case FP_NAN:\n                    if(n==1||n==3) k=1;\n                    if(n==2) k=4+(D.w>>22); // Quiet/signaling NaN.\n                    if(n>=4&&n<11) // Payload.\n                    {\n                        int d=D.w&0x3FFFFF;\n                        for(int i=0;i<10-n;++i) d/=10;\n                        k=4+d%10;\n                    }\n                    break;\n            }\n            if(k<14) col+=vec3(0.1,0.5,0.1)*float((font[k]>>(3*(4-c.y)+(c.x%4)))&1);\n        }\n    }\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float s=min(iResolution.x,iResolution.y)/32.0;\n    vec2 m=iMouse.xy-0.5*iResolution.xy;\n    uint b=0x3F800000u;\n    if(iFrame>0)\n    {\n        uvec4 B=uvec4(texelFetch(iChannel0,ivec2(fragCoord),0))<<ivec4(0,8,16,24);\n        b=B.x+B.y+B.z+B.w;\n    }\n    if(all(lessThan(abs(m),vec2(16,1)*s))&&iMouse.z>0.0&&iMouse.w>0.0)\n        b^=1u<<int(clamp(16.0-m.x/s,0.0,31.0));\n    fragColor=vec4((uvec4(b)>>ivec4(0,8,16,24))&255u);\n}","name":"Buffer A","description":"","type":"buffer"}]}