{"ver":"0.1","info":{"id":"fsKGW1","date":"1631828731","viewed":55,"name":"CALayer: Background","username":"barton","description":"Possible implementation for rendering CALayer background like Core Animation framework.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["background","rounded","layer","calayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// CALayer Background Rendering\n//\n// There is such framework like Core Animation for iOS/macOS.\n// This shader is possible implementation for rendering CALayer in temrs of background.\n//\n// In iOS CALayer will be ceated like:\n//\n// let targetLayer = CALayer()\n// targetLayer.frame = CGRect(x: 0, y: 0, width: 700, height: 700)\n// targetLayer.background = UIColor.blue.cgColor\n// targetLayer.cornerRadius = 500\n// targetLayer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]\n// targetLayer.opacity = 0.5 (for example)\n// view.layer.addSublayer(targetLayer)\n//\n// By some reason the radius could be greater than some critical value and layer's shape\n// will start changing. But as I used SDF algorithm for rounded corners they will get form\n// changes but what about unmasked corners? Unmasked corners should be changed as well.\n// This shader handles such case.\n//\n\n#define kTopLeftCorner      0x1\n#define kTopRightCorner     0x2\n#define kBottomLeftCorner   0x4\n#define kBottomRightCorner  0x8\n\nstruct LayerUniform {\n    vec2 size;\n    vec4 backgroundColor;\n    float cornerRadius;\n    int maskedCorners;\n    float opacity;\n};\n\n// Calculate SDF for rect by size.\nfloat sdfRect(vec2 point, vec2 size) {\n    vec2 q = abs(point) - size/2.0;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\n// Calculate SDF for rect by size with corner radius.\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius) {\n    vec2 q = abs(point) - size/2.0 + cornerRadius;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - cornerRadius;\n}\n\n// Calculate SDF for rect with corner radius and masked corners;\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius, int maskedCorners) {\n    if (maskedCorners == 0) {\n        return sdfRect(point, size);  \n    } else if ((point.x < 0.0 && point.y > 0.0) && (maskedCorners & kTopLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y > 0.0 && (maskedCorners & kTopRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x < 0.0 && point.y < 0.0 && (maskedCorners & kBottomLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y < 0.0 && (maskedCorners & kBottomRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    }\n    \n    float d1 = sdfRect(vec2(point.x, 0), size, cornerRadius);\n    float d2 = sdfRect(vec2(0, point.y), size, cornerRadius);\n    \n    return max(d1, d2);\n}\n\nfloat makeBackgroundMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    \n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask = smoothstep(0.8, -0.8, d + 0.16);\n    \n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float initialRadius = 500.0;\n    float upadtedRadius = abs(initialRadius * sin(iTime * 0.5));\n\n    // Input uniform for fragment shader.\n    LayerUniform layerUniform;\n    layerUniform.size = vec2(700, 700);\n    layerUniform.backgroundColor = vec4(1, 0, 0, 1);\n    layerUniform.cornerRadius = upadtedRadius;\n    layerUniform.maskedCorners = kTopLeftCorner | kBottomRightCorner;\n    //layerUniform.maskedCorners = kTopLeftCorner | kTopRightCorner | kBottomLeftCorner | kBottomRightCorner;\n    layerUniform.opacity = 1.0;\n    \n    vec2 uv = (fragCoord/iResolution.xy) - 0.5;\n    \n    float mask = makeBackgroundMask(uv, layerUniform);\n    vec4 color = mix(vec4(0, 0, 0, 1), layerUniform.backgroundColor, mask * layerUniform.opacity);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}