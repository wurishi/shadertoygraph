{"ver":"0.1","info":{"id":"WsBBDW","date":"1590541328","viewed":106,"name":"RayMarching Colored","username":"AlancitoBalanza","description":"My first RayMarching coloring test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchcolorcoronavirus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define MAXITER 100\n#define GOLDEN_ANGLE 2.39996322972865332\n\nfloat sdCorona(vec3 pos, float rad) {\n    \n    //vec2 ang = vec2(atan(pos.y / length(pos.xz)), vec2(pos.z / pos.x));\n    vec3 norm = normalize(pos);\n    /*\n    int bumps = 40;\n    \n    float bump = 0.;\n    \n    for (int i = 0; i < bumps; i++) {\n    \tvec3 bumpPos;\n        bumpPos.y = 1.0 - (float(i) / float(bumps - 1)) * 2.0;\n        float radius = sqrt(1.0 - bumpPos.y * bumpPos.y);\n        float theta = GOLDEN_ANGLE * float(i);\n        \n        bumpPos.x = cos(theta) * radius;\n        bumpPos.z = sin(theta) * radius;\n        //bumpPos = normalize(bumpPos);\n        \n        if (length(bumpPos - norm) < 0.1)\n        {\n            bump = 0.10;\n        \tbreak;\n        }\n    }\n    */\n    //Sphere UV mapping\n    //vec2 uv = vec2(0.5 + atan(norm.z/norm.x)/(2.0*PI), 0.5 - asin(norm.y)/PI);\n    \n    vec2 uv = vec2(0.5 + atan(norm.z/norm.x)/(2.0*PI), 0.5 - asin(norm.y)/PI);\n    uv *= 30.0;\n    float bump = sin(uv.x)*sin(uv.y);\n    bump = abs(bump);\n    //float bump = sin(pos.x*10.0)*sin(pos.y*10.0)*sin(pos.z*10.0) * 0.5 + 0.5;\n    bump = pow(bump, 5.0);\n    bump *= 5.0;\n    bump = min(1.0, bump);\n    bump /= 5.0;\n\treturn length(pos) - rad - bump;\n}\n\nfloat sdPlane(vec3 pos) {\n\treturn pos.y+sin(pos.x)*sin(pos.z);\n}\n\nvec2 minDist(vec2 d, vec2 d2) {\n\treturn d.x > d2.x ? d2 : d;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec2 sceneDist(vec3 pos) {\n    pos.z += iTime;\n    \n    vec2 d = vec2(1e16, -1);\n    vec3 rep = mod(pos+2.0, 4.0)-2.0;\n    //vec3 rep = pos;\n    float corona = sdCorona(rep-vec3(0.0, 0.0, 0.0), 1.0);\n    d = minDist(d, vec2(corona, mod((floor(pos.x/4.0+0.5)+floor(pos.z / 4.0+0.5)), 10.0)));\n    \n    float plane = sdPlane(pos-vec3(0, -10.0, 0));\n    d = minDist(d, vec2(plane, 4));\n    \n    d.x *= 0.5;\n\t//return min(sphere1, sphere2);\n\treturn d;\n}\n\n#define MAXDIST 500.0\n//returns (distance, color, iterations)\nvec3 map(vec3 pos, vec3 dir) {\n    \n    bool collide = false;\n    vec2 res;\n    float distance = 0.0;\n    int i;\n    for (i = 0; i < MAXITER && distance < MAXDIST && !collide; i++) {\n    \tres = sceneDist(pos);\n        float dist = res.x;\n        distance += dist;\n        if (dist < 0.0001)\n            collide = true;\n       \tif (dist > 1000.0)\n        {\n            i=MAXITER;\n\t        break;\n\t    }\n        pos += dir * dist;\n    }\n    return vec3(distance, res.y, i);\n}\n\nmat3 rotation(vec2 angles) {\n    mat3 id = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    {\n        vec3 u = vec3(cos(angles.x), 0, sin(angles.x));\n        vec3 v = vec3(0, 1, 0);\n        vec3 w = vec3(-sin(angles.x), 0, cos(angles.x));\n        id = id * mat3(u, v, w);\n\t}\n    {\n        vec3 u = vec3(1, 0, 0);\n        vec3 v = vec3(0, cos(angles.y), -sin(angles.y));\n        vec3 w = vec3(0, sin(angles.y), cos(angles.y));\n        id = id * mat3(u, v, w);\n\t}\n    return id;\n}\n\n\nfloat calculateIncidence(vec3 pos, vec3 dir) {\n\tmat3 ba = rotation(vec2(1, 0)*0.01);\n\tmat3 ab = rotation(vec2(0, 1)*0.01);\n\t//mat3 bb = rotation(vec2(1, 1)*0.01);\n    vec3 diraa = dir;\n    vec3 dirba = ba * dir;\n    vec3 dirab = ab * dir;\n    vec3 daa = map(pos, diraa).x * diraa;\n    vec3 dba = map(pos, dirba).x * dirba;\n    vec3 dab = map(pos, dirab).x * dirab;\n    vec3 norm = cross(dba - daa, dab - daa);\n    return acos(dot(norm, dir) / (length(norm)*length(dir)));\n}\nfloat calculateIncidence2(vec3 pos, vec3 dir) {\n\tvec3 posaa = pos;\n    vec3 right = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 posab = pos + right * 0.001;\n    vec3 posba = pos + vec3(0, 1, 0) * 0.001;\n    posaa += map(posaa, dir).x * dir;\n    posab += map(posab, dir).x * dir;\n    posba += map(posba, dir).x * dir;\n    vec3 norm = cross(posba - posaa, posab - posaa);\n    return dot(norm, dir) / (length(norm)*length(dir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 lookingAngle = vec2(iTime, (sin(iTime)*0.5+0.5)*-PI/2.0*0.5);\n    //vec2 lookingAngle = vec2(iTime, 0);\n    lookingAngle.x = iMouse.x / 100.0;\n    lookingAngle.y = -iMouse.y / 100.0;\n    \n    mat3 rot = rotation(lookingAngle);\n    \n    vec3 pos = rot * vec3(0, 0, 1);\n    pos *= -10.0;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = rot * normalize(vec3(uv.xy, 2.5));\n    \n    vec3 res = map(pos, dir);\n    \n    vec3 col;// = vec3(float(i) / float(MAXITER));\n    //bool lost = float(i) > 0.8*float(MAXITER);\n    \n    col = 0.5 + 0.5*cos(res.y+vec3(0,2,4));\n    col *= calculateIncidence2(pos, dir);\n    col += (vec3(0.5) - col) * min(1.0, res.x / 100.0);\n    //col *= 1.0 - res.z / float(MAXITER);\n    //col *= 1.0 - res.x / MAXDIST;\n    /*\n    if (collide)\n        col = vec3(1.0);\n    else\n        col = vec3(0.0);\n*/\n    \n    //if (lost) col.x = 0.0;\n    //col = dir.zzz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}