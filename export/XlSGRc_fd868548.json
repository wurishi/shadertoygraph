{"ver":"0.1","info":{"id":"XlSGRc","date":"1430709086","viewed":325,"name":"VoxelSpaceTest","username":"dila","description":"Another attempt at a voxel space.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["voxel","space","world"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nbool raysphere(vec3 o, vec3 r, vec3 p, float rad, out float t)\n{\n\tvec3 op = o - p;\n    \n    float a = dot(r,r);\n    float b = 2.0 * dot(op,r);\n    float c = dot(op,op) - rad * rad;\n    \n    float delta = b * b - 4.0 * a * c;\n    \n    if (delta < 0.0) {\n        return false;\n    }\n    \n    float xa = (-b - sqrt(delta)) / (2.0 * a);\n    float xb = (-b - sqrt(delta)) / (2.0 * a);\n    \n    t = min(xa, xb);\n    \n    return true;\n}\n\nbool raybox(vec3 o, vec3 r, vec3 p, vec3 s, out float t)\n{\n    /* http://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms */\n    // r.dir is unit direction vector of ray\n    //vec3 dirfrac = 1.0 / r;\n    // lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n    // r.org is origin of ray\n    \n    float t1,t2,t3,t4,t5,t6;\n    t1=t2=t3=t4=t5=t6=1000.0;\n    \n    vec3 lb = p - s - o;\n    vec3 rt = p + s - o;\n    \n    if (r.x != 0.0) {\n    \tt1 = lb.x/r.x;\n    \tt2 = rt.x/r.x;\n    }\n    \n    if (r.y != 0.0) {\n    \tt3 = lb.y/r.y;\n    \tt4 = rt.y/r.y;\n    }\n    \n    if (r.z != 0.0) {\n    \tt5 = lb.z/r.z;\n    \tt6 = rt.z/r.z;\n    }\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n    if (tmax < 0.0)\n    {\n        t = tmax;\n        return false;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    if (tmin > tmax)\n    {\n        t = tmax;\n        return false;\n    }\n\n    t = tmin;\n    return true;\n}\n\nvec3 noise(vec3 p)\n{\n    vec3 na = texture(iChannel0, vec2(p.x,p.y)).xyz;\n    vec3 nb = texture(iChannel0, vec2(p.y,p.z)).xyz;\n    vec3 nc = texture(iChannel0, vec2(p.z,p.x)).xyz;\n    return (na + nb + nc) / 3.0;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    vec3 h = vec3(0.35);\n    float t = 1000.0;\n    \n    vec3 d = abs(r);\n    vec3 s = sign(r);\n    vec3 e = vec3(0.0);\n    \n    float n = max(d.x,max(d.y,d.z));\n    \n    vec3 v = vec3(1.0);\n    \n    float ft = 1000.0;\n    \n    for (int i = 0; i < 256; ++i) {\n        float g = 2.0;\n        vec3 p = o + r * float(i) / 32.0;\n        vec3 c = floor(p * g + 0.5) / g;\n        \n        if (abs(c.x)<=0.5) {\n            continue;\n        }\n        \n        v = noise(c*0.01);\n        if (v.x < 0.6) {\n            continue;\n        }\n        \n        if (raybox(o, r, c, vec3(0.5)/g, t)) {\n            float fo = ft;\n            ft = min(ft, t);\n            if (fo < 1000.0) {\n            \tbreak;\n            }\n        } else {\n            t = 1000.0;\n        }\n    }\n    \n    return ft;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n\tvec3 f = fract(abs(p) * 2.0 + 0.5);\n    //f = f * 2.0 - 1.0;\n    return sdBox(f, vec3(0.125));\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.001, 0.0, 0.0);\n\treturn normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 or = r;\n    \n    mat3 mt = yrot(iTime*0.5) * xrot(iTime*0.25);\n    \n    r *= mt;\n    \n    vec3 o = vec3(0.125);\n    \n    o.z += iTime;\n    \n    float t = trace(o, r);\n    \n    vec3 world = o + r * t;\n    \n    vec3 sn = normal(world);\n    \n    vec3 ref = reflect(r, sn);\n    \n    vec3 reft = texture(iChannel1, ref).xyz;\n    \n    float fres = 1.0 - max(dot(r, -sn), 0.0);\n    \n    vec3 surf = mix(vec3(1.0, 0.25, 0.125), 0.5+reft*0.5, fres);\n        \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 res = mix(surf, vec3(1.0), 1.0-fog);\n    \n\tfragColor = vec4(res,1.0);\n}","name":"","description":"","type":"image"}]}