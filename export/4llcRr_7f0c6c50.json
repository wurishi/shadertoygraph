{"ver":"0.1","info":{"id":"4llcRr","date":"1503173157","viewed":2299,"name":"Shattered Glass","username":"steverock","description":"Reference: [url]https://cms-assets.tutsplus.com/uploads/users/254/posts/22894/image/ShatteredGlass2.jpg[/url]","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float cellJitter = 0.65;\nconst float angularSegs = 9.;\n\nvec2 hash( vec2 p )\n{\n   p = mod(p, angularSegs);\n\treturn texture( iChannel0, (p+0.5)/200.0, -100.0 ).xy;\t\n}\n\nvec3 voronoi( in vec2 x, out vec2 cpId )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = cellJitter * hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = cellJitter * hash( n + g );\n\t\t#ifdef ANIMATE\n        o = animbias + animscale*sin( iTime*0.5 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n\t\t\n        if( dot(mr-r,mr-r)>0.000001 )\n\t\t{\n        // distance to line\t\t\n        float d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        md = min( md, d );\n\t\t}\n    }\n\t\n\tcpId = n+mg;\n\n    return vec3( md, mr );\n}\n\nfloat remap(float x) { return x * 0.5 + 0.5; }\n\nmat2 rot2(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\nfloat atan01(vec2 p) {\n    return atan(p.y, p.x)/6.28318530718 + 0.5;\n}\n\n// Credit: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat lowfreqnoise(float x) {\n    x = mod(x,1.0);\n    float res = 10.;\n    float ia = floor(x * res);\n    float ib = floor(x * res) + 1.;\n\n    // texture lookups have artifacts between segments, probably due to mipmapping.\n    //float a = texture(iChannel0, vec2(ia/res, 0.)).r;\n    //float b = texture(iChannel0, vec2(ib/res, 0.)).r;\n    float a = noise(mod(ia, res));\n    float b = noise(mod(ib, res));\n    \n    float t = fract(x * res);\n    return mix(a, b, t) * 2.0 - 1.;\n}\n\nvec3 image(vec2 fragCoord) {\n    vec2 uvCenter = iResolution.xy / iResolution.x / 2. + vec2(-0.2, 0.1);\n    vec2 uv = fragCoord.xy / iResolution.x - uvCenter;\n    float r = length(uv);\n    \n    vec2 cyl = vec2(max(0.5,pow(r, 0.1)),\n                    atan01(uv));\n    \n    // Add some uneveness to lines\n    cyl.x += 0.015 * abs(lowfreqnoise(cyl.y));\n    vec2 freq = vec2(12., angularSegs);\n    \n    vec2 cpid;\n    vec3 c = voronoi( cyl*freq, cpid );\n    cpid = mod(cpid, angularSegs);\n    float centerDist = length( c.yz );\n    float borderDist = c.x;\n    // Make edges more even in screenspace width\n    float e0 = mix(.1, .0, pow(r, .1));\n    float edge = smoothstep(e0, e0+.0001, borderDist);\n    //edge = 1.;\n\n    // rotate camera/cracked lens\n    float theta = iTime * 3.14 / 20.;\n    vec3 W = vec3(uv, -0.2);\n    W.xz = rot2(theta) * W.xz;\n    vec3 V = normalize(vec3(0.) - W);\n    vec3 normOffset = vec3(noise(cpid.x*7.), noise(cpid.y*13.), noise(27.*(cpid.x-cpid.y))) * 2. - 1.;\n    vec3 N = normalize(vec3(0., 0., 1.) + 0.1*normOffset);\n\tvec3 env = texture(iChannel1, reflect(-V, N)).rgb;\n   \tvec3 F = mix(vec3(1.), vec3(0.5, 0.9, 1.0)*0.4, 1.0-edge);\n    vec3 lit = env * F;\n    return lit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // FSAA, box filter\n    const int L = 3;\n    const float Lf = float(L);\n    vec3 sum = vec3(0.);\n    for(int i = 0; i < L; i++) {\n    for(int j = 0; j < L; j++) {\n        vec2 ofs = vec2(float(i), float(j)) / Lf;\n        sum += image(fragCoord + ofs);\n    }\n    }\n\tfragColor = vec4(sum/(Lf*Lf),1.0);\n}","name":"Image","description":"","type":"image"}]}