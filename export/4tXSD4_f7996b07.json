{"ver":"0.1","info":{"id":"4tXSD4","date":"1436668219","viewed":294,"name":"Function Grapher","username":"djmkultra","description":"Plots 1D and 2D scalar functions.\n z key toggles mouse zooming\n x key toggles mouse pan\n 1,2,3 keys zoom out by factors of 2 each","likes":12,"published":1,"flags":16,"usePreview":0,"tags":["2d","3d","math","curves","plot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Enable 1D function f(x)\n#define FX 1\n// Optional vis of implict function\n#define FXDISTANCE 1\n// Enable 2D function f(x,y)\n#define FXY 1\n// Demo mode, shows different modes.\n#define DEMO 1\n\nconst float kDomainScale = 5.5;  // Scale default domain (1px = 1unit). Zoom in/out.\nconst vec2 kOriginShift = vec2(.5, .5);  // Position of origin relative to domain bounds.\n\nconst float kTemporalScale = .25;\n\nconst float kLineWidth = 2.;\nconst float kInvLineWidth = 1. / kLineWidth;\nconst vec4 kLineColor = vec4(.9, .8, .1, 1.);\n\nconst vec4 kPosColor = vec4(.9, .05, .05, 1.);\nconst vec4 kNegColor = vec4(.05, .05, .9, 1.);\n\nconst float kToneExposure = .8; // Make 2D plot brighter/darker\n\nconst float kGridSpacing = 100.0;\nconst float kTickSpacing = 5.0;  // dash/space width\nconst float kGridOpacity = .6;\nconst vec4 kGridColor = vec4(.5, .5, .5, 1.) * kGridOpacity;\nconst vec4 kAxesColor = vec4(.5, .1, .1, 1.) * kGridOpacity;\nconst float kGridLineWidth = 1.;\n\nconst float kRootJitterScale = .9;  // percent of visible domain to jitter roots.\nconst float kCoefJitterScale = .01; \n\nconst float kPrime1 = 991.;\nconst float kPrime2 = 661.;\nconst float kInvPrime2 = 1. / kPrime2;\n// handy for animating functions.\nvec4 Randf(vec4 seed) {\n \treturn mod(seed * kPrime1, vec4(kPrime2)) * kInvPrime2;   \n}\nvec4 TimeSins(float seed) {\n \tvec4 phase = Randf(vec4(1., 3., 5., 7.) * seed) * 1000.;  // big phase rand\n    vec4 freq = vec4(1.) + Randf(vec4(2., 4., 6., 8.) * seed) * .2; // small freq rand\n    return sin(freq + phase + iTime * kTemporalScale);\n}\n\n//------------------------------------------------------\n// Define a 1D function here.\n\nfloat Fx(float x) {\n    float rootJitter = kRootJitterScale * iResolution.x;\n    float coefsJitter = kCoefJitterScale / iResolution.x * 600.;\n    // This is a 7th order polynomical with wandering roots.\n    vec4 roots = TimeSins(1.) * rootJitter;  \n    vec4 coefs = TimeSins(2.) * coefsJitter;\n \troots = (roots + vec4(x)) * coefs;\n    vec4 roots2 = TimeSins(3.) * rootJitter;\n    vec4 coefs2 = TimeSins(4.) * coefsJitter;\n    roots2 = (roots2 + vec4(vec3(x), 1.)) * coefs2;\n    return roots.x * roots.y * roots.z * roots.w * roots2.x * roots2.y * roots2.z * roots2.w;\n}\n\n//------------------------------------------------------\n// Define a 2D function here.\n\nfloat Fxy(float x, float y) {\n    \n \tvec4 rands = TimeSins(3.) * vec4(vec2(kRootJitterScale), 1., 1.);\n    float d = distance(vec2(x,y), vec2(rands.xy + vec2(-rands.z * 100., rands.w * 100.)));\n    float d2 = distance(vec2(x,y), vec2(rands.yx + vec2(rands.z - rands.w, rands.z * rands.w) * 131.));\n    d *= .05;\n    d2 *= .1;\n    float dd = .81 / (d * d + 1.) + 2. / (d2 * d2 + 1.);\n    float decay = dd;\n    d = 1. / dd ;\n    float wave = 25. * sin(d * .051 - iTime * 2.333) + \n        29. * sin(d * .27 - iTime * 5.55 + (.2 + d * .00015));\n    return wave * decay * 4.;\n}\n\nvec4 Blend(vec4 colorUnder, vec4 colorOver) {\n \tfloat compAlpha = 1. - colorOver.a;\n    vec4 color = colorUnder * compAlpha + colorOver;\n\treturn color;\n}\n\n// Linear ramp from minval to maxval\nvec2 RampAt(vec2 x, vec2 minval, vec2 maxval) {\n\tvec2 ramp = (x - minval) / (maxval - minval);\n    return clamp(ramp, vec2(0.), vec2(1.));\n}\n\n// The Grid\nvec4 GetGridColor(vec2 pos, float scale) {\n    float order = floor(log(scale));\n    float gridScale = exp(order);\n    float gridSpacing = kGridSpacing * gridScale;\n    vec2 lineWidth = vec2(kGridLineWidth * scale);\n    float tickSpace = kTickSpacing;\n    vec2 dashMask = mod(pos.yx, vec2(tickSpace * 2.));\n    dashMask = min(RampAt(dashMask, vec2(0.), vec2(scale)), \n                   RampAt(dashMask, vec2(tickSpace + scale), vec2(tickSpace)));\n    float dashBlend = (tickSpace - 2.5 * scale);  // don't draw tick marks if they get too small\n    dashBlend = clamp(dashBlend, 0., 1.);\n    dashMask = dashBlend * dashMask + (1. - dashBlend) * vec2(1.);\n    vec2 lined = mod(pos + vec2(scale), vec2(gridSpacing));\n \tvec2 lines = min(RampAt(lined, vec2(0.), vec2(scale)), RampAt(lined, lineWidth + vec2(scale), lineWidth));\n    lines *= dashMask;\n    vec4 color = kGridColor * max(lines.x, lines.y);\n    vec2 axesd = RampAt(abs(pos) * 2., lineWidth + vec2(scale), lineWidth);\n    vec2 axess = axesd * dashMask;\n    color = Blend(color, kAxesColor * max(axess.x, axess.y));\n    return color;\n}\n\nfloat Implicit1DFunctionDistance(vec2 pos, float fxvalue) {\n \tfloat diff = pos.y - fxvalue;\n    return diff / length(vec2(dFdx(diff), dFdy(diff)));  // divide by grad-mag to get exact distance from 0\n}\n\nvec4 ColorScalarFunction(vec2 pos, float fxyvalue) {\n \tvec4 color = max(fxyvalue, 0.) * kPosColor - min(fxyvalue, 0.) * kNegColor;\n    color *= kToneExposure;\n    color = color / (vec4(1.) + color); // Tone map color\n    return color;\n}\n\nvec4 Plot1DFunction(vec2 pos, float fxvalue) {\n \tfloat d = abs(Implicit1DFunctionDistance(pos, fxvalue));\n    return kLineColor * smoothstep(kLineWidth, 0., d);\n}\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 origin = iResolution.xy * kOriginShift;\n\tvec2 mousePos = iMouse.xy - origin;\n    \n    // 1, 2, 3 each zoom by a factor of 2\n    bool one = ReadKey( 49, true );\n    bool two = ReadKey( 50, true );\n    bool three = ReadKey( 51, true );\n    \n    // z key toggles zoom.\n    bool z = ReadKey( 90, true );\n    // x key toggles pan.\n    bool x = ReadKey( 88, true );\n    \n    float userZoom = one ? 2. : 1.;\n    userZoom *= two ? 2. : 1.;\n    userZoom *= three ? 2. : 1.;\n    \n    float mouseZoom = mousePos.y > 0. ? 1. + mousePos.y * .01 : 1. / (1. - mousePos.y * .01);\n    float zoom = kDomainScale * userZoom * (z ? mouseZoom : 1.);\n    // position in plot domain\n    vec2 pos = zoom * (fragCoord.xy - origin - mousePos * (x ? 1. : 0.));\n    \n    // Start with background.\n\tfragColor = GetGridColor(pos, zoom);\n    \n#if DEMO\n    // blends between modes.\n    float slice = 25. / 3.;\n    float t = mod(iTime + slice, slice * 3.);\n    vec2 fxalpha = min(RampAt(vec2(t), vec2(0., slice), vec2(1., slice + 1.)), \n                        RampAt(vec2(t), vec2(slice * 2., slice * 2.), vec2(slice * 2. - 1., slice * 2. - 1.)));\n\tfloat fxyalpha = 1. - fxalpha.x;\n#else \n    vec2 fxalpha = vec2(1.);\n    float fxyalpha = 1.;\n#endif\n    \n    \n#if FX\n    // Plot a 1D funciton of x\n    float fx = Fx(pos.x);\n    // Blend plot of 1D function over the grid.\n    fragColor = Blend(fragColor, Plot1DFunction(pos, fx) * fxalpha.x);\n#if FXDISTANCE\n    // Optionally visualize the implicit function used to make line.\n\tfragColor = Blend(ColorScalarFunction(pos, Implicit1DFunctionDistance(pos, fx)) * fxalpha.y, fragColor);\n#endif\n#endif\n\n#if FXY\n    // Plot a 2D function of x and y\n    float fxy = Fxy(pos.x, pos.y);\n    fragColor = Blend(ColorScalarFunction(pos, fxy) * fxyalpha, fragColor);\n#endif\n    \n}","name":"","description":"","type":"image"}]}