{"ver":"0.1","info":{"id":"XlVcWh","date":"1536185211","viewed":81,"name":"CSC 550 Assignment 1","username":"AustinJ","description":"This is for assignment 1 in my CSC 550 class. This is comprised of 5 primitive shapes, two that are animated, one controlled by the mouse, and at least one with a generated pattern.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// took this from the in class example\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    //defining edges ( from point P0 to point P1\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n    //create vector from each triangle point to the sample point \"p\"\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n    \n    //\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//formula for hexagon from https://www.shadertoy.com/view/Xd2GR3\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv *= 1.5;\n\n    \n    vec3 col = vec3(0.0);\n    \n    \n    //draw the hexagon\n    vec2 pos = (-iResolution.xy + 5.0*fragCoord.xy)/iResolution.y;\n    //pos = vec2(0.5); I can't figure out from the formula how it\n    //determines a stopping point. When I put in my desired cordinates\n    //it just gave me a solid color. So, I assume that it does not know\n    //when to stop if its input does not change. This is because the pos\n    //is changing since it relies on the resolution and fragCoord.\n    vec4 h = hexagon(pos);\n    col = vec3(h);\n\n    vec2 mousePos = iMouse.xy;\n    float radius = 35.0;\n    \n    if (sqrt(pow(mousePos.x - fragCoord.x, 2.0) + \n             pow(mousePos.y - fragCoord.y, 2.0))\n             < radius)\n        col = vec3(.5);\n    \n    //draw the rectangle and animate it\n    vec2 ul = vec2(0.3 + cos(iTime),0.6 + cos(iTime));\n    vec2 lr = vec2(0.5 + cos(iTime),0.3 + cos(iTime));\n    if((uv.x >= ul.x && uv.x <= lr.x) && \n       (uv.y <= ul.y && uv.y >= lr.y))\n        col = vec3(0.0,0.0,0.5);\n    \n    //draw the triangle with the example from class\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n    //creating animated vertices for our triangle\n\tvec2 v1 = cos( sin(iTime) + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( sin(iTime) + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( /*sin(iTime) +*/ vec2(0.0,3.00) + 4.0 ); //made the triangle swing on a point\n\n    //distance from current Pixel to triangle\n\tfloat d = sdTriangle( v1, v2, v3, p );\n    \n    if(d < 0.0)\n        col = vec3(0.5,0.0,0.0);\n    \n    //draw... plus sign\n    vec2 origin = vec2(0.75);\n    vec2 p1 = vec2(origin.x + 0.25, origin.y);\n    vec2 p2 = vec2(origin.x, origin.y + 0.25);\n    vec2 p3 = vec2(origin.x - 0.25, origin.y);\n    vec2 p4 = vec2(origin.x, origin.y - 0.25);\n    float width = 0.15;\n    \n    ;\n    \n    //check the points tips of the plus signs as borders\n    if(\n        (( uv.y <= p1.y + width && uv.y > p1.y - width ) \n         && (uv.x <= p1.x && uv.x >= p3.x)) ||\n        ((uv.y <= p2.y && uv.y >= p4.y) && \n         (uv.x <= p2.x + width && uv.x >= p2.x - width))\n      )\n        //create a striped pattern\n        col = vec3(0.0,abs(cos(uv.y*10.0f)),cos(0.0)); \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}