{"ver":"0.1","info":{"id":"X3jGWy","date":"1708815561","viewed":106,"name":"Mandelbrot set - fake 3d shading","username":"DeltaT","description":"done by calculating the smooth iteration count, then treating that as a scalar field and finding the gradient of it and taking the dot product of the gradient and the light direction vector","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mandelbrot(vec2 c) {\n    vec2 z = c;\n    for (int i = 0; i < 512; i++) {\n        if (dot(z, z) >= 65536.) { return float(i)-log2(log2(dot(z, z)))+5.; }\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + c;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 c = 1.4*(uv+vec2(-.4, 0));\n    float m = mandelbrot(c);\n    vec2 g = vec2(mandelbrot(c+vec2(.001, 0))-m, mandelbrot(c+vec2(0, .001))-m);\n    // actual gradient components would be multiplied by 1000 but we can skip this since it gets normalized anyways\n    \n    fragColor = vec4(m == 0. ? vec3(0) : vec3(.6, .8, 1)*mix(.7, 1., dot(normalize(g), vec2(cos(iTime), sin(iTime)))), 1);\n}","name":"Image","description":"","type":"image"}]}