{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n * This notebook is a second attempt at absorbing boundary conditions for the scalar\n * wave equation using Perfectly Matched Layers—except this time hopefully doing it\n * *correctly*. Quantities u and ψ are defined at integer time steps. They are\n * integrated according to the equations\n *\n *                du\n *                -- = c (∇ · v) - (σ_x + σ_y) u + ψ\n *                dt  \n *         \n *                dψ         dv_y         dv_x\n *                -- = c σ_x ---- + c σ_y ---- - σ_x σ_y u\n *                dt          dy           dx\n *         \n *\n * Here, σ_x and σ_y are the PML layer strengths in the x- and y-directions, respectively,\n * and c is the wave speed. ψ is an auxiliary quantity whose definition and derivation is\n * described below.\n *\n * Vector v = (v_x, v_y) is defined at half-integer timesteps and integrated in a\n * leap-frog manner with respect to the above quantities using the equations\n *\n *              dv_x     du\n *              ---- = c -- - σ_x v_x\n *               dt      dx\n *\n *              dv_y     du\n *              ---- = c -- - σ_y v_y\n *               dt      dy\n *\n * This naturally lends itself to two buffers. The first stores u and ψ while the second\n * stores the two vector components of v.\n *\n * These equations are arrived at by starting with the scalar wave equation,\n *\n *               du\n *               --  = c (∇ · v)\n *               dt\n *\n *              dv_x     du\n *              ---- = c --\n *               dt      dx\n *\n *              dv_y     du\n *              ---- = c --\n *               dt      dy\n *\n * This may be a slightly unfamiliar form compared to the standard d²u/dt² = c²∇²u. The\n * reason for this split is to restrict spatial derivatives to first derivatives, which\n * then makes application of PML somewhat easier. You can verify by direct substitution\n * that they are equivalent.\n *\n * From here, we operate in the Fourier time domain, replacing d/dt with -iω in a slight\n * abuse of notation (really just glossing over explicitly performing the Fourier\n * transform) to yield\n *\n *                       dv_x     dv_y\n *             -iω u = c ---- + c ----\n *                        dx       dy\n *\n *                       du\n *           -iω v_x = c --\n *                       dx\n *\n *                       du\n *           -iω v_y = c --\n *                       dx\n *\n * We then replace the derivatives with the PML mapping,\n *\n *                       1\n *              d     ---------  d         \n *              -- =        σ_x  --     \n *              dx    1 + i ---  dx       \n *                           ω\n *\n * and correspondingly for d/dy. Reorganizing terms and moving back to the time domain,\n * the equations for v_x and v_y immediately yield the above update equations. The\n * equation for u is a bit more involved, yielding\n *\n *                                        ic σ_x dv_y    ic σ_y dv_x    i\n *  -iω u = c (∇ · v) - (σ_x + σ_y) u + ( ------ ---- +  ------ ---- - --- σ_x σ_y u )\n *                                          ω     dy       ω     dx     ω\n *\n *                                                        ^ \n *                                                        ψ \n *\n * Here, i/ω corresponds to time integration, so we define the final term as a single\n * quantity ψ and integrate it along with u. This yields the definition\n *\n *                  ic σ_x  dv_y    ic σ_y dv_x    i\n *              ψ = ------  ---- +  ------ ---- - --- σ_x σ_y u\n *                    ω      dy       ω     dx     ω\n *\n * Multiplying through by -iω, we get\n *\n *                            dv_y         dv_x            \n *              -iω ψ = c σ_x ---- + c σ_y ---- - σ_x σ_y u\n *                             dy           dx             \n *\n * which directly corresponds to the above update equation for ψ.\n *\n * The above derivation is mostly taken and extended from\n * https://math.mit.edu/~stevenj/18.369/spring14/pml.pdf. The exception is that they only\n * derive equations for *one* absorbing boundary, so that I obtained the above equations\n * by applying the technique to *both* boundaries at the same time.\n *\n * The resulting form is just a little ugly but quite effective, requiring an absorbing\n * layer roughly on par with the wavelength. I think this comes from truncation error\n * and could be improved to maybe half of a wavelength with more accurate differencing\n * schemes.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 state = texture(iChannel0, uv);\n    float u = state.x;\n    \n    // Note that the colors are scaled and gamma applied in order to bring out small amplitudes.\n    // In reality, the reflections may be a bit more damped than they appear here.\n    fragColor = vec4(abs(u) * (u > 0.0 ? vec3(1,0.3,0) : vec3(0,0.3,1)), 1);\n    \n    if (iMouse.z > 0.0) {\n        vec2 s = sigma(fragCoord, iResolution);\n        fragColor = mix(fragColor, vec4(1, 0, 0, 1), s.x);\n        fragColor = mix(fragColor, vec4(0, 1, 0, 1), s.y);\n    }\n    \n    float gamma = 0.454;\n    if (iMouse.z > 0.0) {\n        gamma = mix(gamma, 0.0, iMouse.x / iResolution.x);\n    }\n    \n\n    fragColor.rgb = pow(abs(fragColor.rgb), vec3(gamma));\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float PML_WIDTH = 12.0; // pixels\nconst float PML_EXPONENT = 2.0;\nconst float PML_STRENGTH = 1.0;\nconst float OSCILLATOR_STRENGTH = 4.0;\nconst float OSCILLATOR_WAVELENGTH = 10.0; // pixels\nconst float C = 1.0;\nconst float DT = 0.5;\nconst float DX = 1.0;\n\n\n#define U(i ,j) (texelFetch(iChannel0, p + ivec2(i, j), 0).x)\n#define VX(i, j) (texelFetch(iChannel1, p + ivec2(i, j), 0).x)\n#define VY(i, j) (texelFetch(iChannel1, p + ivec2(i, j), 0).y)\n\nconst float PI = 3.14159265358979;\n\nfloat linearstep (float a, float b, float x) {\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// A layer that fades from 0 to 1 near the edges of the domain\nvec2 sigma (vec2 coord, vec3 res) {    \n    return pow(\n        abs(vec2(\n            linearstep(PML_WIDTH, 0.0, coord.x) + linearstep(res.x - PML_WIDTH, res.x, coord.x),\n            linearstep(PML_WIDTH, 0.0, coord.y) + linearstep(res.y - PML_WIDTH, res.y, coord.y)\n        )),\n        vec2(PML_EXPONENT)\n    ) * PML_STRENGTH;\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 p = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, p, 0);\n    float u = state.x, psi = state.y, t = state.z;\n    \n    // Compute dv_x/dx and dv_y/dy\n    float dvxdx = (VX(1, 0) - VX(-1, 0)) / (2.0 * DX);\n    float dvydy = (VY(0, 1) - VY(0, -1)) / (2.0 * DX);\n\n    vec2 s = sigma(fragCoord, iResolution);\n    \n    // Update u, psi, and t\n    fragColor.xyz = state.xyz + DT * vec3(\n        C * (dvxdx + dvydy) - u * (s.x + s.y) + psi,\n        C * (s.x * dvydy + s.y * dvxdx - u * s.x * s.y),\n        1\n    );\n    \n    // Apply a forcing term at the center\n    float pulseInterval = 600.0;\n    float pulse = exp(-pow(abs((mod(t - pulseInterval, pulseInterval * 0.7) - pulseInterval * 0.5) / 40.0), 4.0));\n    int COUNT = 5;\n    for (int i = 0; i < COUNT; i++) {\n        vec2 r = (float(i) - float(COUNT) * 0.5) / float(COUNT) * vec2(80, 0);\n        float omega = C * PI / OSCILLATOR_WAVELENGTH;\n        float oscillatorMask = smoothstep(3.0, 2.0, length(fragCoord - iResolution.xy * 0.5 + r));\n        float u0 = sin(omega * t / float(i + 1));\n        fragColor.x += u0 * oscillatorMask * OSCILLATOR_STRENGTH * pulse;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 p = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, p, 0);\n    vec2 v = state.xy;\n    \n    // Compute ∇u = (du/dx, du_dy)\n    vec2 ugrad = vec2(U(1, 0) - U(-1, 0), U(0, 1) - U(0, -1)) / (2.0 * DX);\n\n    vec2 s = sigma(fragCoord, iResolution);\n    \n    // Update (v_x, v_y)\n    fragColor.xy = state.xy + DT * (C * ugrad - s * v);\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"l3ccRr","date":"1734651310","viewed":98,"name":"Perfectly Matched Layer test 2","username":"rreusser","description":"Absorbing boundaries for the scalar wave equation using Perfectly Matched Layers. (With apologies, my previous attempt was shamefully incorrect)","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["waves","math","abc","pml"],"hasliked":0,"parentid":"","parentname":""}}