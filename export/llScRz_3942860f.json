{"ver":"0.1","info":{"id":"llScRz","date":"1507178518","viewed":1300,"name":"Cross Hatching","username":"jgkling","description":"Nonphotorealistic rendering.\n\nClick and drag the mouse!","likes":27,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by: https://www.shadertoy.com/view/MsSGD1\n\n// Raymarching params\n#define T_MAX 50.0\n\n// Colors\n#define GRAPHITE_COLOR vec3(0.3)\n#define RED_LINE_COLOR vec3(1.0, 0.41, 0.73)\n#define BLUE_LINE_COLOR vec3(0.58, 0.83, 0.95)\n#define PAPER_COLOR vec3(1.0, 1.0, 0.73)\n\n#define SHADOWS\n#define LIGHT_VEC normalize(vec3(0.0, 0.8, -1.0))\n\n// 3D Noise by IQ\nfloat Noise3D( in vec3 pos )\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return -1.0 + 2.0 * mix( rg.x, rg.y, f.z );\n}\n\nfloat ComputeFBM( in vec3 pos )\n{\n    float amplitude = 0.25;\n    float sum = 0.0;\n    sum += Noise3D(pos) * amplitude;\n    return clamp(sum, 0.0, 1.0);\n}\n\n// Credit to IQ: https://iquilezles.org/articles/distfunctions\n\nfloat SDF_Sphere( in vec3 pos, in float radius )\n{\n    return length(pos) - radius;\n}\n\nfloat SDF_Box( in vec3 pos, in vec3 b )\n{\n     return length(max(abs(pos) - b, 0.0));\n}\n\nfloat SDF_Torus( in vec3 pos, in vec2 t)\n{\n    vec2 qos = vec2(length(pos.xz) - t.x, pos.y);\n    return length(qos) - t.y;\n}\n\nfloat SDF_Ellipsoid( in vec3 pos, in vec3 r )\n{\n    return (length( pos / r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat SDF_CappedCylinder( in vec3 pos, in vec2 h )\n{\n  vec2 d = abs(vec2(length(pos.xz), pos.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cheap, pseudorandom number generator taken from: https://www.shadertoy.com/view/MscSzf\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat SceneMap( in vec3 pos )\n{\n    float sdf = SDF_Sphere(pos - vec3(-0.2, 0.26, 0.0), 0.25);\n    sdf = min(sdf, SDF_Sphere(pos - vec3(-0.8, 0.3, 0.0), 0.125));\n    sdf = min(sdf, SDF_Torus(pos - vec3(0.5, 0.085, 0.0), vec2(0.5, 0.15) * 0.5));\n    sdf = min(sdf, SDF_Box(pos - vec3(0.0, 0.0, 0.0), vec3(4.0, 0.02, 4.0) * 0.5));\n        \n    return sdf;\n}\n\nvec3 ComputeNormal( in vec3 pos )\n{\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - SceneMap(pos - epsilon.yxx),\n                            SceneMap(pos + epsilon.xyx) - SceneMap(pos - epsilon.xyx),\n                            SceneMap(pos + epsilon.xxy) - SceneMap(pos - epsilon.xxy)));\n}\n\nvec3 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    float distance, lastDistance = 10000000.0;\n    const float EDGE_THRESHOLD = 0.015;\n    float dt = 0.01;\n    float t = 0.01;\n    float hitSomething, isOnEdge = 0.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        distance = SceneMap(origin + t * dir);\n        \n        // If we get very close to an object and we also moved away since the last iteration\n        if (distance < EDGE_THRESHOLD && distance > lastDistance + 0.00001)\n        {\n            hitSomething = 1.0;\n            isOnEdge = 1.0;\n            break;\n        }\n        \n        if(distance < 0.001)\n        {\n            hitSomething = 1.0;\n            break;\n        }\n        else if (t > T_MAX)\n        {\n            break;\n        }\n        \n        t += distance;\n        lastDistance = distance;\n    }\n    return vec3(t, hitSomething, isOnEdge);\n}\n\nvec3 GetBackgroundColor( in vec2 coord )\n{\n    // Blue notebook paper lines\n    vec3 col = PAPER_COLOR;\n    \n    /*\n    bool isOnRedLine = false;\n    if (coord.x <= 86.5 && coord.x >= 85.0) // red notebook paper line\n    {\n        col *= RED_LINE_COLOR;\n        isOnRedLine = true;\n    }*/\n    \n    if (mod(coord.y, 20.0) <= 1.0 && mod(coord.y, 20.0) >= -1.0)\n    {\n        col *= BLUE_LINE_COLOR;\n        /*if (isOnRedLine) // mix the red and blue ink if the lines intersect\n        {\n            col *= RED_LINE_COLOR;\n        }*/\n        \n    }\n    \n    \n    // Accounting for the mottling in paper\n    float mottling = ComputeFBM(vec3(coord, 0.0) * 3.0) * 0.4;\n    \n    return mix(col, vec3(0.0, 0.0, 0.0), pow(mottling, 0.8));\n}\n\nvec3 GetHatchingColor( in vec2 coord, in float lightIntensity, in vec3 camRight, in vec3 camUp, in bool isGradientEnabled, in float doOffsetHatching )\n{    \n    vec3 hatchingColor = GetBackgroundColor(coord);\n    \n    // Make the hatching look more consistent at full resolution\n    coord = coord / iResolution.xy * 1024.0;\n    \n    // Just catch a flag saying we want to jitter the hatching-\n    // For example, make the outline or shadow hatching look\n    // noncontinuous with any nearby dark hatching\n    coord += vec2(75.0, 15.0) * doOffsetHatching;\n    \n    float lineWidth, lineFreq, hatching;\n    \n    float thresh1 = 0.5;\n    float thresh0 = thresh1 + 0.075;\n    float thresh2 = thresh1 - 0.1;\n    float thresh3 = 0.2;\n    float thresh4 = thresh3 - 0.1;\n    \n    // This code could probably be a lot less verbose but oh well\n    \n    // Threshold 1\n    lineWidth = 0.015 * (0.5 * sin((coord.x - 0.25 * coord.y) * 0.04167 + 0.15 * (coord.x + coord.y)) + 0.5) + 1.0;\n    lineFreq = 10.0;\n    hatching = mod(coord.x + coord.y * 0.15 * (sin(abs(coord.y + coord.x) * 0.00390625 * 0.75)), lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh1)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh0)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh0 - lightIntensity) / (thresh0 - thresh1);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    \n    // Threshold 2\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 0.75 * coord.y) * 0.0625 + 0.15 * (coord.x - 0.5 * coord.y)) + 0.5) + 1.0;\n    lineFreq = 14.0;\n    hatching = mod(coord.x + coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh2)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t   hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh1)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh1 - lightIntensity) / (thresh1 - thresh2);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    // Threshold 3\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 1.0 * coord.y) * 0.03125 + 0.15 * (coord.x - 1.5 * coord.y)) + 0.5) + 1.5;\n    lineFreq = 8.0;\n    hatching = mod(coord.x - 0.75 * coord.y, lineFreq) + 2.0 * (rand(coord.x + 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh3)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh2)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh2 - lightIntensity) / (thresh2 - thresh3);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }        \n    }\n    \n    \n    // Threshold 4\n    lineWidth = 1.25;\n    lineFreq = 7.0;\n    hatching = mod(coord.x + 0.15 * coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh4)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh3)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh3 - lightIntensity) / (thresh3 - thresh4);\n       \t       weight = pow(weight, 2.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }  \n    }\n    return hatchingColor;\n    \n}\n\n// Credit to IQ: https://iquilezles.org/articles/rmshadows\nfloat SoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.05;\n    while(t <= 10.0)\n    {\n        float h = SceneMap(ro + rd * t);\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// \"Plasma\": Compute ray jitter using \"plasma\": http://lodev.org/cgtutor/plasma.html\nfloat Plasma( in vec2 sp, in float timeStutter )\n{    \n    float plasma = 0.5 * sin(sp.x * 8.0 + timeStutter) + 0.5;\n    plasma *= 0.5 * sin((sp.x + sp.y) * 8.0 + timeStutter) + 0.5;\n    plasma *= 0.5 * sin(length(sp) * 15.0 + timeStutter) + 0.5;\n    return plasma;\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin, out vec3 camRight, out vec3 camUp ) // need the camRight vector in the hatching color function\n{\n    // Compute local camera vectors\n    vec3 refPoint = vec3(0.0, 0.4, 0.0);\n    vec3 camLook = normalize(refPoint - origin);\n    camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    float radius = 4.0;\n    float speed = 0.015625;\n    \n    // Animate camera or time-based\n    //vec3 rayOrigin = vec3(cos(iMouse.x * speed) * radius, -5.0 * ((iMouse.y / iResolution.y) - 0.8), sin(iMouse.x * speed) * radius);\n    vec3 rayOrigin = vec3(cos(iTime * speed * 16.0 + 3.14) * radius, 1.0, sin(iTime * speed * 16.0 + 3.14) * radius);\n    vec3 camRight, camUp;\n    vec3 rayDirection = CastRay(screenPoint, rayOrigin, camRight, camUp);\n    \n    // Compute ray jitter using fake noise stuff using sin() - see the Plasma() function\n    float timeStutter = floor(iTime * 12.0) * 16.0;\n    timeStutter = mod(timeStutter, 2048.0); // the plasma function broke when iTime reached high values, mod every 2^24\n    \n    const bool isGradientEnabled = true;\n    \n    // Compute a direction to offset the .xy component of each ray via a gradient\n    vec2 fragSize = 1.0 / iResolution.xy;\n    vec2 offsetDir = normalize(vec2(cos(cos(iTime * 2.0)), sin(cos(iTime * 2.0)))) * 0.75;\n    rayDirection.xy += max(Plasma(screenPoint, timeStutter), 0.05) * offsetDir * 0.00390625; // that's 1 / 256\n    \n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    if (result.y > 0.0)\n    {\n        vec3 isectPoint = rayOrigin + result.x * rayDirection;\n        vec3 normal = ComputeNormal(isectPoint);\n        float lightIntensity = clamp(dot(normal, LIGHT_VEC), 0.0, 1.0);\n        \n        vec3 col;\n        \n        // Compute shadows\n        float shadowing = 1.0;\n        #ifdef SHADOWS\n            shadowing= SoftShadow(isectPoint, LIGHT_VEC, 7.0);\n        #endif\n        \n        // Shade depending on whether or not we are on an outline\n        col = mix(GetHatchingColor(fragCoord.xy, min(shadowing, lightIntensity), camRight, camUp, isGradientEnabled, 0.0),\n                  GetHatchingColor(fragCoord.xy, 0.0, camRight, camUp, isGradientEnabled, 0.0),\n                  result.z);\n        \n        fragColor = vec4(col, 1.0);\n    }\n    else // we miss geometry completely\n    {\n        fragColor = vec4(GetBackgroundColor(fragCoord.xy), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}