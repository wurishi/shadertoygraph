{"ver":"0.1","info":{"id":"Dt3fzl","date":"1701791558","viewed":37,"name":"Dancing Pyth-Tree","username":"rawburt","description":"playarround with pythagorean tree..still pretty slow and clunky implemented\na kingdom for recursion..\nif it doesnt run, change the iterations-parameter to 8","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","pythagoras"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int   iterations = 10;\n\nconst float sqrt2 = sqrt(2.);\n\nbool find_triangle(float hyp, float height, float m_r, float m_l, vec2 uv, float ratio) {\n    vec2 p = uv;\n    // triangle is oriented as hypothenusis on the x-axis and height on the y-axix. \n    // remaining stuff is done via transformations on uv\n    // both legs are simply interpretaed as linear functions and evaluated against y\n    float hyp_r = ratio * hyp;\n    float hyp_l = (1. - ratio) * hyp;\n    \n    p.x -= .5*(hyp) - ( ratio * hyp );\n    \n    if (   p.y >= 0. && p.x >= 0. && p.y <= m_r * p.x + height \n        || p.y >= 0. && p.x <  0. && p.y <= m_l * p.x + height) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool find_box(float length, vec2 uv) {\n\n    vec2 p = uv;\n    p  = abs(p);\n    p  = max( vec2(length, length) - p, 0. );\n        \n    if( p.y > 0. && p.x > 0.) {\n        return true;\n    }\n    return false;\n}\n//a and alpha left, b and beta right\nvoid height_and_sides(in float hyp, in float ratio, out float a, out float b, out float h , out float alpha, out float beta ) {\n    \n    float arat = ( 1. - ratio );\n    \n     h = sqrt( ratio * hyp * arat * hyp    );\n     float h_sqrd = h * h;\n     \n     a = sqrt( h_sqrd + ( arat  * hyp ) * ( arat * hyp  ) );\n     b = sqrt( h_sqrd + ( ratio * hyp ) * ( ratio * hyp ) );\n     alpha = acos(a/hyp);\n     beta  = acos(b/hyp);\n}\n\nvoid height_and_sides(in float hyp, in float ratio, out float a, out float b, out float h ) {\n    \n    float arat = ( 1. - ratio );\n     float k =  arat  * hyp;\n     float l =  ratio * hyp;\n     h = sqrt( ratio * hyp * arat * hyp    );\n     a = sqrt( h * h + k * k );\n     b = sqrt( h * h + l * l );\n}\n\nvec2 rotate_point_right(float angle, vec2 p) {\n    float p_angle = 2. * 3.141592653 - angle;\n    float c = cos(p_angle);\n    float s = sin(p_angle);\n    return mat2( c , -s, s, c ) * p;\n}\n\nvec2 rotate_point_left(float angle, vec2 p) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2( c , -s, s, c ) * p;\n}\n\n\nint build_tree( vec2 uv, float ratio, float inital_box ) {\n\n     const int  memory_size = int( pow(2., float( iterations - 1) ) );\n     \n     int out_v = -1;\n     \n     vec2  move_mem [ memory_size ];    \n     vec2  hyp_mem  [ memory_size ];  \n     float angle_mem[ memory_size ];   \n     \n     vec2  move_mem_1 [ memory_size ];    \n     vec2  hyp_mem_1  [ memory_size ];  \n     float angle_mem_1[ memory_size ];   \n \n    \n     int current_triangles = 1;\n     \n     float a, b, h, alpha, beta;\n     \n     height_and_sides(inital_box , ratio, a, b, h, alpha, beta );\n     \n     float m_r = -tan(beta );\n     float m_l =  tan(alpha);\n     \n     uv += vec2(0., .5 + (.5 - inital_box/2. ) );\n      \n     if( find_box (inital_box / 2.,  uv ) ) return 0;\n    \n     uv -= vec2(.0, inital_box / 2. ) ;\n     \n     bool change_flag = true;\n     if( find_triangle(inital_box, h, m_r, m_l,  uv, ratio  ) ) return 1;\n     \n     move_mem [0] = uv;\n     hyp_mem  [0] = vec2(a , b );\n     angle_mem[0] = 0.;\n     \n     float angle_l, angle_r;\n     \n     for(int i = 1; i <= iterations; i++) {         \n        \n         for(int d = 0; d < ( current_triangles); d++ )  {\n             bool  swap = d % 2 == 1;\n             \n             if(change_flag) {\n                 angle_l =  swap ? alpha - angle_mem[ d ] : angle_mem[ d ] + alpha;\n                 angle_r = !swap ? beta  - angle_mem[ d ] : angle_mem[ d ] + beta ;\n             } else {\n                 angle_l =  swap ? alpha - angle_mem_1[ d ] : angle_mem_1[ d ] + alpha;\n                 angle_r = !swap ? beta  - angle_mem_1[ d ] : angle_mem_1[ d ] + beta ;\n             }\n             \n             vec2 mv_l = vec2(-sin(angle_l ) , cos(angle_l) );\n             vec2 mv_r = vec2( sin(angle_r ) , cos(angle_r) );\n         \n             vec2  p_l   = change_flag ? move_mem[d] : move_mem_1[d];\n             vec2  p_r   = change_flag ? move_mem[d] : move_mem_1[d];\n             \n             float hyp_l = change_flag ? hyp_mem [d].x : hyp_mem_1[d].x;\n             float hyp_r = change_flag ? hyp_mem [d].y : hyp_mem_1[d].y;\n             \n             height_and_sides(hyp_l, ratio, a, b, h );\n             \n             change_flag ? hyp_mem_1 [2 * d     ] = vec2(a, b) : hyp_mem [2 * d     ] = vec2(a, b) ;\n             \n             p_l -= mv_l * sqrt2 * b;\n             \n             if( find_box ( hyp_l / 2., rotate_point_left(angle_l, p_l ) ) ) return 2 * i;\n             \n             p_l -= mv_l * hyp_l *.5;\n             \n             if( find_triangle(hyp_l, h, m_r, m_l,  rotate_point_left(angle_l, p_l ), ratio  ) ) return 2 * i + 1;\n             \n             height_and_sides(hyp_r, ratio , a, b, h );\n             \n             change_flag ? hyp_mem_1 [2 * d  + 1 ] = vec2(a, b) : hyp_mem [2 * d + 1 ] = vec2(a, b) ;\n             \n             p_r -= mv_r * sqrt2 * a;\n             \n             if( find_box (hyp_r / 2., rotate_point_right(angle_r, p_r ) ) ) return 2 * i;\n             \n             p_r -= mv_r * hyp_r *.5;\n             \n             if( find_triangle(hyp_r, h, m_r, m_l,  rotate_point_right(angle_r, p_r ), ratio  ) ) return 2 * i + 1;\n             \n             \n              change_flag ? move_mem_1 [2 * d     ] = p_l : move_mem[2 * d     ] = p_l;\n              change_flag ? move_mem_1 [2 * d + 1 ] = p_r : move_mem[2 * d + 1 ] = p_r;\n              \n              change_flag ? angle_mem_1[2 * d     ] = angle_l : angle_mem[2 * d     ] = angle_l;\n              change_flag ? angle_mem_1[2 * d + 1 ] = angle_r : angle_mem[2 * d + 1 ] = angle_r;\n         }\n         \n         change_flag = !change_flag;\n         current_triangles *= 2;\n     }\n     return out_v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q  = fragCoord.xy/iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float ratio       = .5 + .35*sin(2.*3.14 * cos( .5 * iTime + .03*uv.x - .02 * uv.y) );\n    float inital_box  = .5 ;\n    int hit_index = build_tree(uv, ratio, inital_box);\n    \n    float scale = float(hit_index + 1) / float(iterations);\n    \n   \n    fragColor = vec4( scale * vec3(.3 + .2 * uv.x, .4 + .2 * uv.y, .7), 1. );\n    //fragColor = vec4( smoothstep( low_col, high_col, vec3( scale ) ), 1. );\n}","name":"Image","description":"","type":"image"}]}