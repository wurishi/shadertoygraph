{"ver":"0.1","info":{"id":"lXy3DW","date":"1717679410","viewed":52,"name":"Purkinje Shift (via Matrices)","username":"Mynx","description":"Purkinje Effect\n\nClick on the image to disable the effect.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","night","blue","shift","wavelength","scotopic","purkinje"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n//\n// Copyright (c) 2024 Mynx\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// Purkinje Shift using Matrices\n// [jpatry21]  https://advances.realtimerendering.com/s2021/jpatry_advances2021/index.html\n// [kirk11]    http://graphics.berkeley.edu/papers/Kirk-PBT-2011-08/\n// [cao08]     https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2630540/pdf/nihms80286.pdf\n// [smits00]   https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=76e02f42973b8d27d078edce568fde21c08814f0\n\nvec3 PurkinjeShift(vec3 light, float intensity)\n{\n\t// constant \n    const vec3 m = vec3(0.63721, 0.39242, 1.6064); // maximal cone sensitivity\n\tconst vec3 k = vec3(0.2, 0.2, 0.29);           // rod input strength long/medium/short\n\tconst float K = 45.0;   // scaling constant\n\tconst float S = 10.0;   // static saturation\n\tconst float k3 = 0.6;   // surround strength of opponent signal\n\tconst float rw = 0.139; // ratio of response for white light\n\tconst float p = 0.6189; // relative weight of L cones\n\t\t\n\t// [jpatry21] slide 164\n    // LMSR matrix using Smits method [smits00]\n    // Mij = Integrate[ Ei(lambda) I(lambda) Rj(lambda) d(lambda) ]\n\tconst mat4x3 M = mat4x3\n    (\t\n        7.69684945, 18.4248204, 2.06809497,\n\t\t2.43113687, 18.6979422, 3.01246326,\n\t\t0.28911757, 1.40183293, 13.7922962,\n\t\t0.46638595, 15.5643680, 10.0599647\n\t);\n    \n    // [jpatry21] slide 165\n    // M with gain control factored in\n    // note: the result is slightly different, is this correct?\n    // g = rsqrt(1 + (0.33 / m) * (q + k * q.w))\n    const mat4x3 Mg = mat4x3\n    (\t\n        vec3(0.33 / m.x, 1, 1) * (M[0] + k.x * M[3]),\n        vec3(1, 0.33 / m.y, 1) * (M[1] + k.y * M[3]),\n        vec3(1, 1, 0.33 / m.z) * (M[2] + k.z * M[3]),\n        M[3]\n\t);\n   \n\t// [jpatry21] slide 166\n    const mat3x3 A = mat3x3\n    (\n        -1, -1, 1,\n         1, -1, 1,\n         0,  1, 0\n    );\n\t\n\t// [jpatry21] slide 167\n\t// o = (K / S) * N * diag(k) * (diag(m)^-1)\n    const mat3x3 N = mat3x3\n    (\n        -(k3 + rw),     p * k3,         p * S,\n         1.0 + k3 * rw, (1.0 - p) * k3, (1.0 - p) * S,\n         0, 1, 0\n\t);\n\tconst mat3x3 diag_mi = inverse(mat3x3(m.x, 0, 0, 0, m.y, 0, 0, 0, m.z));\n\tconst mat3x3 diag_k = mat3x3(k.x, 0, 0, 0, k.y, 0, 0, 0, k.z);\n\tconst mat3x3 O =  (K / S) * N * diag_k * diag_mi;\n\n\t// [jpatry21] slide 168\n\t// c = M^-1 * A^-1 * o\n    const mat3 Mi = inverse(mat3(M));\n\tconst mat3x3 C = transpose(Mi) * inverse(A) * O;\n    \n    // map to some kind of mesopic range, this value is arbitrary, use your best approx\n    const float scale = 1000.0;\n    \n    // reference version\n    //vec4 lmsr = (light * scale) * M;\n    //vec3 lmsGain = inversesqrt(1.0f + (0.33f / m) * (lmsr.rgb + k * lmsr.w));\n    \n    // matrix folded version, ever so slightly different but good enough\n\tvec4 lmsr = (light * scale) * Mg;\n    vec3 lmsGain = inversesqrt(1.0f + lmsr.rgb);\n    vec3 rgbGain = C * lmsGain * intensity / scale;    \n    return rgbGain * lmsr.w + light;\n}\n\n// https://iolite-engine.com/blog_posts/minimal_agx_implementation\n// All values used to derive this implementation are sourced from Troyâ€™s initial AgX implementation/OCIO config file available here:\n// https://github.com/sobotka/AgX\n\n// 0: Default, 1: Golden, 2: Punchy\n#define AGX_LOOK 0\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform (inset)\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Inverse input transform (outset)\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  // NOTE: We're linearizing the output here. Comment/adjust when\n  // *not* using a sRGB render target\n  val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// borrowed from https://www.shadertoy.com/view/7dtSDn (or I guess maybe https://www.shadertoy.com/view/7tKXzD)\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\nvec3 oklch_to_oklab(vec3 c) {\n    float a = c.y * cos(c.z);\n    float b = c.y * sin(c.z);\n    return vec3(c.x, a, b);\n}\nvec3 oklab_to_linear_srgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = oklab_to_linear_srgb(oklch_to_oklab(vec3(0.5, 0.09, uv.x * 2.0 * 3.141502 + 0.5)));\n    col *= max(0.0, exp2(uv.y *10.0) - 1.0) * 0.1;\n   \n    if (iMouse.z < 0.5) \n        col = PurkinjeShift(col, 1.0);\n    \n    col = agx(col);\n    col = agxLook(col);\n    col = agxEotf(col);\n  \n    col = Srgb3(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}