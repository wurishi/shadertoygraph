{"ver":"0.1","info":{"id":"WsXSRn","date":"1550359602","viewed":273,"name":"Green music bars 2","username":"darkeclipz","description":"Green music bars 2","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["raymarch","music","soundbars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltsGWH","filepath":"https://soundcloud.com/novalight/nl-i-wanna-live","previewfilepath":"https://soundcloud.com/novalight/nl-i-wanna-live","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define MaxSteps 100.\n#define MinDistance 0.01\n#define eps 0.001\n#define Iterations 22.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// from IQ\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// from IQ\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nvec2 scene(vec3 p) {\n    \n    \n    float plane = sdPlane(p - vec3(0,1,0) + 0.0005*texture(iChannel1, p.xz).xyz, vec4(0., 1., 0., 1.));  \n    float square1 = sdBox(p, vec3(.1));\n    float square = 1e10;\n    \n    float numSquares = 16.;\n    for(float i=0.; i < numSquares; i++) {\n        vec4 music = texture( iChannel0, vec2(i/numSquares,0.1));\n\t\tsquare = min(square, sdBox(p - vec3(.3 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .2,.05)));\n        square = min(square, sdBox(p - vec3(.10 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .5,.05)));\n        square = min(square, sdBox(p - vec3(-.1 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x,.05)));\n    }\n    \n    int closestId = 0;\n    if(square > plane) closestId = 1;\n    \n    return vec2(min(plane, square), closestId);\n}\n\nfloat shadowScene(vec3 p){\n\n    float square1 = sdBox(p, vec3(.1));\n    \n    float square = 1e10;\n    \n    float numSquares = 16.;\n    for(float i=0.; i < numSquares; i++) {\n        vec4 music = texture( iChannel0, vec2(i/numSquares,0.1));\n\t\tsquare = min(square, sdBox(p - vec3(.3 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .2,.05)));\n        square = min(square, sdBox(p - vec3(.10 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .5,.05)));\n        square = min(square, sdBox(p - vec3(-.1 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x,.05)));\n    }\n    \n    return square;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nvec2 marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0., dt = 0., minDist = 1e10;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        dt = shadowScene(p);\n        minDist = min(minDist, dt);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec2(t-MinDistance, dt);    \n        }\n    }\n    return vec2(0., minDist);\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 32.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(0,5,0), 5., vec3(1));\n\n    vec3 ambient = vec3(.1);\n    return L1 + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    \n    vec2 random = texture(iChannel0, fragCoord/R.y).xy;\n    vec3 ro = vec3(0., 2.,-4. + random.y *.2); // ray origin\n\t\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateY(cos(iTime)*.2 + 1.);\n    \n    float w = texture(iChannel0, vec2(.01,0.1)).x;\n    ro -= vec3(0,0,w*.6 - w*.6/2.);\n    \n    ro *= rot;\n    rd *= rot;\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    float occl = hit.y;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        // bars\n        if(hit.z == 0.) {\n            col = vec3(.3, 1., .3);\n        }\n        \n        // floor\n        if(hit.z == 1.) {\n         \tcol = vec3(.2); \n            \n            col += light(p, n, rd);\n            \n            // reflection\n            \n            vec3 randxz = vec3(random.x, 0, random.y);\n            vec2 shadowHit = marchShadow(p, normalize(reflect(rd, n)));\n            float refl = shadowHit.x;\n            if(refl < eps) refl = 1e10;\n            col += clamp(vec3(.4,1.,.4) * (.1 / refl), 0., 1.);              \n        }\n        \n        // glow\n        vec2 sh = marchShadow(ro, rd);\n        float glow = sh.y;\n        col += 1.2*vec3(.4,1,.4) * (1.-3.*glow);\n                \n        // green lightning\n        float lightDistance = shadowScene(p);\n        col += clamp(vec3(0,1,0) * 0.1 / lightDistance, 0., 1.) * .8;\n\n\t\t// post\n        col -= occl;\n        float fog = 1. / (1. + t * 0.25);\n        col = mix(vec3(0), col, fog);\n        \n        if(hit.z == 0.) {\n        \tcol *= occl;    \n        }\n        \n        \n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}