{"ver":"0.1","info":{"id":"MldXWn","date":"1479148929","viewed":1602,"name":"Electric Hydraulics","username":"zackpudil","description":"Future of dams. Dam electricity.\nUpdate: Made the flashing lights from electricity more subtle.\nUpdate: Added iapafoto suggestion. Thanks.\n\nThanks to FabriceNeyret2 as well for testing issues.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//===== Common gpu randomness functions =====\n\nfloat hash(float n) {\n    return fract(sin(n)*4357.5453);\n}\n\nfloat noise(float g) {\n    float p = floor(g);\n    float f = fract(g);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    return mix(hash(p), hash(p + 1.0), f);\n}\n\nfloat noise(vec3 g) {\n    vec3 p = floor(g);\n    vec3 f = fract(g);\n    \n    f = f*f*(3.0 - 2.0*f);\n    float n = p.x + 57.0*p.y + 113.0*p.z;\n    \n    float x = mix(hash(n), hash(n + 1.0), f.x);\n    float y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n    float z = mix(hash(n + 113.0), hash(n + 114.0), f.x);\n    float w = mix(hash(n + 170.0), hash(n + 171.0), f.x);\n    \n    return mix(mix(x, y, f.y), mix(z, w, f.y), f.z);\n}\n\nconst mat3 m3 = mat3(\n\t 0.00,  0.80,  0.60,\n\t-0.80,  0.36, -0.48,\n\t-0.60, -0.48,  0.64\n);\n\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\n\tf += 0.5000*noise(p); p *= m3*2.01;\n\tf += 0.2500*noise(p); p *= m3*2.02;\n\tf += 0.1250*noise(p); p *= m3*2.04;\n\tf += 0.0625*noise(p);\n\tf /= 0.9375;\n\n\treturn f;\n}\n    \n// ===============================\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 de(vec3 p) {\n    vec3 op = p;\n    p.x = abs(p.x) - 3.3;\n    p.z = mod(p.z + 2.0, 4.0) -  2.0;\n    vec4 q = vec4(p, 1);\n    q.xyz -= 1.0;\n\n    // simple kali fractal\n    q.xyz = q.zxy;\n    for(int i = 0; i < 6; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), 0.25, 1.0);\n        q *= 1.1;\n        \n        rotate(q.xy, -0.35);\n    }\n    \n    vec2 f = vec2((length(q.xyz) - 1.5)/q.w, 1.0);\n    \n    // floor, ceiling and walls.\n    f = opU(f, vec2(min(min(p.y + 1.7, -p.y + 2.0), min(op.x + 4.0, -op.x + 4.0)), 0.0));\n\n    // fake electricity.\n    vec3 sp = p;\n    sp.xz = abs(sp.xz) - 0.07;\n\trotate(sp.xz, 20.0*sp.y + 20.0*iTime + 5.0*noise(10.0*(op.z + p.y + 5.0*iTime)));\n    sp.xz += 0.02;\n    float g = smoothstep(-1.1, -1.0, -sp.y)*smoothstep(-1.0, -0.8, sp.y);\n    f = opU(f, vec2(length(sp.xz) - 0.03*hash(iTime)*g, 2.0));\n    \n    // pipes coming out of the fractal.\n    vec3 gp = p;\n    gp.y += 1.6 - smoothstep(-1.0, 1.0, p.x);\n    gp.x += 1.0;\n    gp.z += 0.1 - 0.4*(gp.x*gp.x)*smoothstep(0.0, 3.5, -p.x);\n    gp.z = abs(gp.z)- 0.2;\n    gp = abs(abs(gp) - 0.02) - 0.05;\n    f = opU(f, vec2(length(gp.zy) - 0.04, 3.0));\n    \n    // pipe running down the middle.\n    op.y += 1.6;\n    op.x = abs(op.x) - 0.1;\n    op = abs(abs(op) - 0.06) - 0.06;\n    f = opU(f, vec2(length(op.xy) - 0.05, 3.0));\n    \n    return f;\n}\n\nvec2 trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    float m = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec2 s = de(ro + rd*t);\n        if(s.x < 0.0001 || t >= mx) break;\n        t += s.x*0.75;\n        m = s.y;\n    }\n    \n    return t < mx ? vec2(t, m) : vec2(-1.0);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    float m = de(p).y;\n    vec3 n = vec3(\n        de(p + h.xyy).x - de(p - h.xyy).x,\n        de(p + h.yxy).x - de(p - h.yxy).x,\n        de(p + h.yyx).x - de(p - h.yyx).x\n\t);\n    vec3 b = vec3(0);\n    if(m == 0.0) {\n        float f = 1.0;\n        b = vec3(\n            fbm(f*p + h.xyy) - fbm(f*p - h.xyy),\n            fbm(f*p + h.yxy) - fbm(f*p - h.yxy),\n            fbm(f*p + h.yyx) - fbm(f*p - h.yyx)\n\t\t);\n        b = normalize(b);\n    }\n    return normalize(n) + 0.3*b;\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.005;\n    \n    for(int i = 0; i < 15; i++) {\n        float d = de(p + n*s).x;\n        o += (s - d);\n        s += s/(float(i) + 1.0);\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    \n    vec4 x = texture(s, p.zy);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec2 t = trace(ro, rd, 20.0);\n    if(t.x < 0.0) return col;\n\n    vec3 pos = ro + rd*t.x;\n    vec3 nor = normal(pos);\n    vec3 ref = reflect(rd, nor);\n\n    vec3 key = pos;\n    key.z = mod(key.z + 2.0, 4.0) - 2.0;\n    vec3 lig = normalize(-key);\n    float dis = length(key) - 0.5;\n    float att = 1.0/(1.0 + 1.5*dis + 0.5*dis*dis);\n\n    float occ = ao(pos, nor); // ambient occlusion.\n    float dom = step(0.0, -trace(pos + nor*0.0001, ref, 2.0).x); // reflectance shadow.\n    float sha = step(0.0, -trace(pos + nor*0.001, lig, dis).x); // electic light shadow.\n\n    col = vec3(0.4);\n    \n    if(pos.y > -1.5) col *= occ*occ;\n    \n    if(t.y != 2.0) {\n        // shinny metal like material. Fresnel term with reflectance shadow.\n\t\tcol += 0.5*clamp(1.0 + dot(rd, nor), 0.0, 1.0)*dom;\n        \n        // light coming from the electricity.\n        col += att*hash(iTime)*clamp(dot(lig, nor), 0.0, 1.0)\n            *vec3(0.4, 0.4, 2.0)\n            *sha;\n    }\n\n    if(t.y == 1.0)\n        col *= texcube(iChannel0, 0.5*pos, nor).xyz; // kali fractal.\n    else if(t.y == 3.0)\n        col *= texcube(iChannel1, pos + iTime, nor).xyz*vec3(1.0, 5.0, 10.0); // pipes.\n\telse if(t.y == 2.0)\n        col *= vec3(0.5, 3.0, 50.0)*hash(iTime); // electricity.\n    \n\tcol = mix(col, vec3(0), 1.0 - exp(-0.2*t.x));\n   \treturn mix(col, vec3(1,5,10),exp(-abs(100.*cos(pos.z*.1+1.*iTime)))*(1.-occ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords.\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float time = iTime;\n    \n    // ray origi and direction.\n    float r = 3.5 + 1.0*cos(2.0*time);\n    vec3 ro = vec3(0, 0.0, time);\n    \n    vec3 ww = normalize(vec3(5.0*sin(time*0.3), 0.0, time + 1.0)-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    vec3 col = render(ro, rd, uv);\n    \n    col = 1.0 - exp(-0.5*col); // tone mapping\n    col = pow(abs(col), vec3(1.0/2.2)); // gamma correction.\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}