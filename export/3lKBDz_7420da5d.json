{"ver":"0.1","info":{"id":"3lKBDz","date":"1614191513","viewed":73,"name":"Robot factory","username":"tupto","description":"Infinite randomly generated robots! This might become a problem if they weren't so goofy.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fun","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SHARPNESS  2.0/iResolution.y\n\nfloat merge(float s1, float s2) { return min(s1, s2); }\nfloat intersect(float s1, float s2) { return max(s1, s2); }\nfloat subtract(float s1, float s2) { return max(s1, -s2); }\n\n\nfloat circle(vec2 pos, float radius)\n{\n    return length(pos)-radius;\n}\n\nfloat rectangle(vec2 pos, vec2 halfSize)\n{\n\tvec2 edgeDist = abs(pos) - halfSize;\n\tfloat outDist = length(max(edgeDist, 0.0));\n\tfloat inDist = min(max(edgeDist.x, edgeDist.y), 0.0);\n\treturn outDist + inDist;\n}\n\nvec2 rotate(vec2 pos, float rotation){\n    const float PI = 3.14159;\n    float angle = rotation * PI * 2. * -1.;\n    float sine, cosine;\n    sine = sin(angle);\n    cosine = cos(angle);\n    return vec2(cosine * pos.x + sine * pos.y, cosine * pos.y - sine * pos.x);\n}\n\nfloat cog(vec2 pos, float r, float insideR, int numTeeth, float spin, out float pupil) {\n\tfloat base = circle(pos, r-(r*0.2));\n\tpupil = circle(pos, insideR);\n\tfloat a = atan(pos.x, pos.y);\n\tfloat teeth = smoothstep(-0.5, 1.0, cos(a * float(numTeeth) + spin)) + length(pos)-r;\n\tteeth = merge(base, teeth);\n\tteeth = subtract(teeth, pupil);\n\treturn teeth;\n}\n\nfloat fullClaw(vec2 pos, float t)\n{\n\tfloat stageProgress = mod(t+0.5, 4.0);\n\tfloat stage = floor(stageProgress);\n    vec2 clawOffset = vec2(smoothstep(1.0, 0.0, cos(t * 2. * 3.14159))*4.0, 0.0);\n    float clawOpen = 1.0- smoothstep(0.8, 1.0, smoothstep(0.0, 0.7, abs(sin(t * 3.14159-1.0))));\n    float rect = rectangle(rotate(pos+vec2(-0.1, 0.0)+clawOffset, 0.125), vec2(0.05)* (clawOpen +.8));\n    float claw = subtract(subtract(circle(pos+clawOffset, 0.1), circle(pos+clawOffset, 0.08)), rect);\n    float val = smoothstep(SHARPNESS, 0.0, claw)*0.3;\n    val = max(val, smoothstep(SHARPNESS, 0.0, rectangle(pos+vec2(0.55, 0.0)+clawOffset, vec2(.45, 0.03)))*0.25);\n    val = max(val, smoothstep(SHARPNESS, 0.0, rectangle(pos+vec2(1.4, 0.0)+clawOffset, vec2(.4, 0.05)))*0.2);\n    return val;\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\nvec2 hash2(in vec2 p)\n{\n\treturn fract(1965.5786 * vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2. * uv -1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime * 0.5;\n    \n\tfloat stageProgress = mod(t+0.5, 5.0);\n\tfloat stage = floor(stageProgress);\n\tfloat id = floor((t+0.5) / 5.0);\n    \n    \n    uv.x -= float(stage == 4.0) * (stageProgress - stage) * 4.0;\n    \n    vec2 dest;\n    switch (int(stage))\n    {\n        case 0://face\n            dest = vec2(0.8, 0.0);\n            break;\n        case 1://left eye\n            dest = vec2(0.29, -0.6);\n            break;\n        case 2://right eye\n            dest = vec2(-0.6, -0.3);\n            break;\n        case 3://mouth\n            dest = vec2(0.0, 0.6);\n            break;\n    }\n    float claw = float(stage < 4.0) * fullClaw(rotate(uv + dest, 0.25 * stage), t);\n    \n    bool mouthType = hash(id) > 0.5;\n    bool eye1Type = hash(id+1.0) > 0.4;\n    bool eye2Type = hash(id+2.0) > 0.4;\n    bool faceType = hash(id+3.0) > 0.4;\n    \n    vec2 faceOffset = vec2(smoothstep(1.0, 0.0, max(stage+floor(stageProgress+0.5),cos(t * 2. * 3.14159)))*4.0, 0.0);\n    vec2 eye1Offset = vec2(0.0, -smoothstep(1.0 , 0.0, max(stage-1.+floor(stageProgress-stage+0.5),cos(t * 2. * 3.14159)))*4.0);\n    vec2 eye2Offset = vec2(-smoothstep(1.0 , 0.0, max(stage-2.+floor(stageProgress-stage+0.5),cos(t * 2. * 3.14159)))*4.0, 0.0);\n    vec2 mouthOffset = vec2(0.0, smoothstep(1.0 , 0.0, max(stage-3.+floor(stageProgress-stage+0.5),cos(t * 2. * 3.14159)))*4.0);\n    \n    \n\tfloat eye1Pupil, eye2Pupil;\n\tvec2 pupilSize = hash2(vec2(id))*0.16 + 0.03;\n    vec2 eyeSize = hash2(vec2(id+1.0))*0.2 + 0.1;\n    int numGears = int(hash(id+4.0)*6.0)+6;\n\tfloat robo;\n    \n    if (eye1Type) {\n        robo += float(stage >= 1.0) * smoothstep(SHARPNESS, 0.0, cog(uv+vec2(0.29, -0.3)+eye1Offset, 0.3, pupilSize.x, numGears, t * 2.0, eye1Pupil));\n    } else {\n        float whites = circle(uv+vec2(0.29, -0.3)+eye1Offset, eyeSize.x);\n        eye1Pupil = circle(uv+vec2(0.29, -0.3)+eye1Offset, pupilSize.x);\n        robo += float(stage >= 1.0) * smoothstep(SHARPNESS, 0.0, subtract(whites, eye1Pupil));\n    }\n    \n    \n    if (eye2Type) {\n        robo += float(stage >= 2.0) * smoothstep(SHARPNESS, 0.0, cog(uv+vec2(-0.29, -0.3)+eye2Offset, 0.3, pupilSize.y, numGears, -t * 2.0 + 3.14, eye2Pupil));\n    } else {\n        float whites = circle(uv+vec2(-0.29, -0.3)+eye2Offset, eyeSize.y);\n        eye2Pupil = circle(uv+vec2(-0.29, -0.3)+eye2Offset, pupilSize.y);\n        robo += float(stage >= 2.0) * smoothstep(SHARPNESS, 0.0, subtract(whites, eye2Pupil));\n    }\n\n    \n\tfloat face;\n    if (faceType) { \n        face = rectangle(uv+faceOffset, vec2(0.7));\n    } else {\n        face = circle(uv+faceOffset, 0.8);\n    }\n    vec2 mouthSize = hash2(vec2(id+5.0));\n    mouthSize.x = mouthSize.x * 0.3+0.2;\n    mouthSize.y = mouthSize.y * 0.15+0.05;\n\tfloat mouth = rectangle(uv+vec2(0.0, 0.3)+mouthOffset, mouthSize);\n    \n\tfloat chomp = rectangle(uv+vec2(0.0, 0.3)+mouthOffset, vec2(mouthSize.x+0.01, (mouthSize.y-0.02)* max(0.1, sin(t*3.1415))));\n    float freq = hash(id+6.0)*60.0+5.0;\n    float scared = rectangle(uv+vec2(0.0, 0.3+0.008*(sin(uv.x*freq+t*20.0)*2.0 - 1.0))+mouthOffset, vec2(mouthSize.x+0.01, mouthSize.y*0.25));\n   \n    \n\tif (stage >= 1.0)\n\t{\n\t\tface = subtract(face, eye1Pupil);\n\t}\n\tif (stage >= 2.0)\n\t{\n\t\tface = subtract(face, eye2Pupil);\n\t}\n\tif (stage >= 3.0)\n\t{\n\t\tface = subtract(face, mouthType ? scared : chomp);\n\t}\n    \n    \n\trobo += smoothstep(SHARPNESS, 0.0, face) * 0.5;\n\trobo += float(stage >= 3.0) * smoothstep(SHARPNESS, 0.0, subtract(mouth, mouthType ? scared : chomp));\n    \n    //Urgh good enough. Not really sure how to handle this.\n    robo = mix(robo, claw, clamp(claw/robo, claw, 1.0));\n\n    // Output to screen\n    vec3 col = vec3(robo);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}