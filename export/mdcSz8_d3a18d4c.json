{"ver":"0.1","info":{"id":"mdcSz8","date":"1679366410","viewed":48,"name":"sky volumetric  clouds","username":"zy269018784","description":"sky, noise, cloud","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["noise","cloud","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 uvw = vec3(fragCoord/iResolution.xy * 10., 0.);\n    \n    float worley = worleyNoise(uvw, 4.);\n    worley = remap(worley, 0.65, 1., 0., 1.);\n    \n    vec3 col = vec3(worley);\n    col = textureLod(iChannel0, uv, 0.).xyz;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**\nThis tab contains all the necessary noise functions required to model a cloud shape.\n*/\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Fbm for Perlin noise based on iq's blog\nfloat perlinfbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * gradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cloud parameters\nconst float EARTH_RADIUS = 6300e3;\nconst float CLOUD_START  = 800.0;\nconst float CLOUD_HEIGHT = 600.0;\n\nvec3 getRayFromCamera(vec3 org, vec3 fwd, vec3 up, vec2 uv, float aspect)\n{\n    vec3 d;\n    fwd = normalize(fwd);\n    up  = normalize(up);\n    vec3 right = normalize(cross(fwd, up));\n    up = normalize(cross(right, fwd));\n    d = fwd + uv.x * right + aspect * uv.y * up;\n    d = normalize(d);\n    return d;\n}\n\nfloat intersectSphere(vec3 origin, vec3 dir, vec3 spherePos, float sphereRad)\n{\n\tvec3 oc = origin - spherePos;\n\tfloat b = 2.0 * dot(dir, oc);\n\tfloat c = dot(oc, oc) - sphereRad*sphereRad;\n\tfloat disc = b * b - 4.0 * c;\n\tif (disc < 0.0)\n\t\treturn -1.0;    \n    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\n\tfloat t0 = q;\n\tfloat t1 = c / q;\n\tif (t0 > t1) {\n\t\tfloat temp = t0;\n\t\tt0 = t1;\n\t\tt1 = temp;\n\t}\n\tif (t1 < 0.0)\n\t\treturn -1.0;\n    \n    return (t0 < 0.0) ? t1 : t0;\n}\n\nvec3 box(vec3 ray_origin, vec3 ray_dir, vec3 minpos, vec3 maxpos) \n{\n    vec3 inverse_dir = 1.0 / ray_dir;\n    vec3 tbot = inverse_dir * (minpos - ray_origin);\n    vec3 ttop = inverse_dir * (maxpos - ray_origin);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 traverse = max(tmin.xx, tmin.yz);\n    float traverselow = max(traverse.x, traverse.y);\n    traverse = min(tmax.xx, tmax.yz);\n    float traversehi = min(traverse.x, traverse.y);\n    return vec3(float(traversehi > max(traverselow, 0.0)), traversehi, traverselow);\n}\n\n#if 0\nfloat worley(vec2 uv)\n{\n    float minDist = 1000.;\n \n    vec2 d = uv;\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2(0.5, 0.3);\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2(-0.1, 0.3);\n    minDist = min(minDist, dot(d, d));\n   \n    d = uv - vec2(-0.4, -0.3);\n    minDist = min(minDist, dot(d, d));\n    \n   // d = uv - vec2(-0.7, 0.3);\n   // minDist = min(minDist, dot(d, d));\n    \n    float noise = 1. - minDist;\n    if (noise < 0.)\n        noise = 0.;\n    return noise;\n}\n#elif 0\nfloat worley(vec2 uv)\n{\n    float minDist = 1000.;\n \n    vec2 d = uv;\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2(-0.5, -0.8);\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2( 0.5, 0.7);\n    minDist = min(minDist, dot(d, d));\n   \n    d = uv - vec2( 0.4, -0.3);\n    minDist = min(minDist, dot(d, d));\n    \n    d = uv - vec2(-0.7, 0.3);\n    minDist = min(minDist, dot(d, d));\n    \n    float noise = 1. - minDist;\n    if (noise < 0.)\n        noise = 0.;\n    return noise;\n}\n\n#elif 1\nfloat worley(vec2 uv)\n{\n    float minDist = 1000.;\n    vec2 d;\n    \n  // d = uv;\n  // minDist = min(minDist, dot(d, d));\n    \n \n    d = uv - vec2( sin(iTime + 6457.234), sin(iTime + 65.234));\n    minDist = min(minDist, dot(d, d));\n  \n    d = uv - vec2( sin(iTime), cos(iTime + 65464.7852));\n    minDist = min(minDist, dot(d, d));\n  \n    d = uv - vec2( sin(iTime + 0.234), sin(iTime + 14345.234));\n    minDist = min(minDist, dot(d, d));\n    //\n    // d = uv - vec2(-0.3, 0.3);\n    // minDist = min(minDist, dot(d, d));\n    \n    float noise = 1. - minDist;\n    if (noise < 0.)\n        noise = 0.;\n        \n  //  return 1. - dot(uv, uv);\n    \n    return noise;\n}\n\n#endif\n\nfloat worleyFbm2(vec2 uv, float w)\n{\n    float freq = 4.;\n    // pernlin worley\n    float worley_fbm1 = worleyFbm(vec3(uv * .5, w), freq * 1.);\n    \n    float pfbm= mix(1., perlinfbm(vec3(uv * .5, w), 4., 7), .5);\n    pfbm = abs(pfbm * 2. - 1.); // billowy perlin noise\n    \n    float perlin_worley = remap(pfbm, 0., 1., worley_fbm1, 1.); // perlin-worley\n    \n    // worley fbm\n    vec3 worley_fbm = vec3(0.);\n    worley_fbm.r += worleyFbm(vec3(uv * 1., w), freq * 1.) * 0.625;\n    worley_fbm.g += worleyFbm(vec3(uv * 2., w), freq * 2.) * 0.25;\n    worley_fbm.b += worleyFbm(vec3(uv * 4., w), freq * 4.) * 0.125;\n   \n    float wfbm = worley_fbm.r +\n                 worley_fbm.g +\n                 worley_fbm.b;\n                 \n    // cloud\n    float cloud = remap(perlin_worley, wfbm - 1., 1., 0., 1.);\n    \n    float noise = 0.;\n    uv *= 2.;\n    uv -= 1.;\n    noise += worley(uv * 1.);\n    \n   // return noise;\n   //return clamp(remap(noise, 0.85, 1., 0., 1.), .0, 1.);;\n\n    //noise = clamp(remap(cloud, 0., 1., 0., noise), .0, 1.);\n    noise = clamp(remap(noise, cloud, 1., 0., 1.), .0, 1.);\n   // noise = clamp(remap(cloud, noise, 1.,  0., 1.), .0, 1.);\n    \n    // coverage\n    noise = clamp(remap(noise, 0.85, 1., 0., 1.), .0, 1.);\n    return noise;\n}\n\nvec3 testNoise(vec2 uv)\n{\n    float noise = worley(uv);\n  //  noise = clamp(remap(noise, 0.85, 1., 0., 1.), .0, 1.);\n    return vec3(noise);\n}\n\nvec3 scene(vec3 org, vec3 fwd, vec3 up, vec2 uv, float aspect)\n{\n    //return testNoise(uv);\n    vec3 col = vec3(0.);\n    vec3 ray = getRayFromCamera(org, fwd, up, uv, aspect);\n    const float ATM_START = EARTH_RADIUS + CLOUD_START;\n\tconst float ATM_END   = ATM_START + CLOUD_HEIGHT;\n    float atmDistance   = intersectSphere(org, ray, vec3(0.0, 0.0, 0.0), ATM_START);\n    float earthDistance = intersectSphere(org, ray, vec3(0.0, 0.0, 0.0), EARTH_RADIUS);\n    if (0. < atmDistance)\n    {\n        col = vec3(0.2196, 0.3765, .6902);\n        if (0. < earthDistance)\n        {\n            if (earthDistance < atmDistance)\n                col = vec3(0, 0.5, 0);\n        }\n    }\n    \n    // vec3 AA = vec3(-350, 10, -470);\n    // vec3 BB = AA + vec3(700, 200, 100);\n#if 1\n    vec3 AA =      vec3(-20000, EARTH_RADIUS + 2000., -40000);\n    vec3 BB = AA + vec3( 40000, 10000, 10000);\n#else   \n    vec3 AA =      vec3(-2000, EARTH_RADIUS + 4000., -2000);\n    vec3 BB = AA + vec3( 4000, 4000, 4000);\n#endif    \n    vec3 hit = box(org, ray, AA, BB);\n    float d = 0.;\n    if (hit.x > 0.)\n    {\n        float t0 = hit.z;\n        float t1 = hit.y;\n        float steps = 16.;\n        float step_size = (t1 - t0) / steps;\n        float t = t0 + 0.0 * step_size;\n        vec3 pos = org + ray * t;\n        for (float i = 0.; i < steps; i += 1.)\n        {\n            vec3 uvw = (pos - AA) / (BB - AA);\n            float s = 1.;\n            s *= smoothstep(0., .2, uvw.y);\n            s *= smoothstep(0.1, .5, uvw.x);\n            s *= smoothstep(0.9, .5, uvw.x);\n            s *= smoothstep(0.1, .5, uvw.z);\n            s *= smoothstep(0.9, .5, uvw.z);\n            // d += worleyFbm2(uvw.xy, uvw.z);\n            // float noise = worleyNoise(uvw * 5., 4.);\n            // noise = clamp(remap(noise, 0.9, 1., 0., 1.), 0., 1.);\n            // d += noise;\n            d += worleyFbm2(uvw.xz, uvw.y)\n           //   * s\n            ;\n\n            pos += step_size * ray;\n        }\n        if (d > 0.)\n        {//\n           d = d / (0.5 + d);    \n        }\n        col = mix(col, vec3(1), d);\n    }\n    \n    return vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 org = vec3(0, 0, 0);\n    vec3 fwd = vec3(0, 0, -1);\n    vec3 up  = vec3(0, 1, 0);\n    float aspect = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.;\n    uv -= 1.;\n    \n    // front\n    //org = vec3(0, 0, 0);\n    //fwd = vec3(0, 0, -1);\n    \n     // back\n    //org = vec3(0, 0, -130);\n    //fwd = vec3(0, 0, 1);\n    \n    // right\n    //org = vec3(100, 0, -40);\n    //fwd = vec3(-1, 0, 0);\n    \n    // left\n    //org = vec3(-100, 0, -40);\n    //fwd = vec3(1, 0, 0);\n    \n    // up\n    //org = vec3(0, EARTH_RADIUS + 10., 0);\n    //fwd = vec3(0, 1, 0);\n    //up  = vec3(0, 0, 1);\n    \n    // front\n    org = vec3(0, EARTH_RADIUS + 10., 0);\n    fwd = normalize(vec3(0, 0, -1));\n    up  = normalize(vec3(0, 1, 0));\n    \n    // back\n    //org = vec3(0, EARTH_RADIUS + 10., 0);\n    //fwd = normalize(vec3(0, 0, 1));\n    //up  = normalize(vec3(0, 1, 0));\n   \n    // front up\n    //org = vec3(0, EARTH_RADIUS + 10., 0);\n    //fwd = vec3(0, 1, 1);\n    //up  = vec3(0, 1, -1);\n    \n    vec3 col = scene(org, fwd, up, uv, aspect);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}