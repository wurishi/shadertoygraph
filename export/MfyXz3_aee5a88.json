{"ver":"0.1","info":{"id":"MfyXz3","date":"1715529991","viewed":68,"name":"旋转的正方体","username":"lage","description":"一个旋转的正方体","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 Transform(in vec3 pos3d){\n\n    mat3 mat = mat3(-1.0/sqrt(2.),1.0/sqrt(2.0),0.,\n                    -1./sqrt(6.),-1./sqrt(6.),2.0/sqrt(6.),\n                    0.,0.,0.);\n    vec3 pos = pos3d * mat;\n    //float x = -1.0/sqrt(2.)*pos3d.x+1.0/sqrt(2.0)*pos3d.y;\n    //float y = -1./sqrt(6.)*pos3d.x-1./sqrt(6.)*pos3d.y+2.0/sqrt(6.)*pos3d.z;\n    //return vec2(x,y);\n    return pos.xy;\n\n}\nmat3 Rotate(float angle){\n    mat3 mat = mat3(cos(angle),-sin(angle),0.,sin(angle),cos(angle),0.,0.,0.,1.);\n    return mat;\n\n}\n\n\nint Mod(int a, int b) {\n    int r = a % b;\n    return r < 0 ? r + b : r;\n}\n\nfloat InRange(float min, float max, float x){\n    if(min>max){\n        float a = min;\n        min = max;\n        max = a;\n    }\n    float r = step(min-0.02,x)-step(max+0.02,x);\n    return r;\n}\nvec3 DrawLine(vec3 col,vec2 uv,float tmin,float tmax,vec3 point3,vec3 dir3){\n    vec3 c = col;\n    vec2 point2 = Transform(point3*Rotate(iTime));\n    vec2 dir2 = Transform(dir3*Rotate(iTime));\n    float xmin = dir2[0]*tmin+point2[0];\n    float xmax = dir2[0]*tmax+point2[0];\n    float ymin = dir2[1]*tmin+point2[1];\n    float ymax = dir2[1]*tmax+point2[1];\n    //float degree = smoothstep(0.1,0.0,abs((uv.x-point2.x)*dir2.y-(uv.y-point2.y)*dir2.x));\n    float degree = step(-0.02,-abs((uv.x-point2.x)*dir2.y-(uv.y-point2.y)*dir2.x));\n    //degree *= InRange(xmin,xmax,uv.x);\n    \n    if(dir2.x == 0.0){\n        degree *=InRange(ymin,ymax,uv.y);\n            }\n    else{\n        degree *= InRange(xmin,xmax,uv.x);\n            }\n    //degree *=InRange(ymin,ymax,uv.y);\n    \n    c = mix(c,vec3(1.0),degree);\n    return c;\n}\n\nvec3 DrawCube(vec3 col,vec2 uv){\n    vec3 c = col;\n    vec3 base3d[4]; \n    base3d[0] = vec3(2.0,0.0,0.0);\n    base3d[1] = vec3(0.0,2.0,0.0);\n    base3d[2] = vec3(0.0,0.0,2.0);\n    \n    vec3 start = vec3(-0.5,-0.5,-0.5);\n    \n    for(int i=0;i<3;i++){\n    \n        base3d[3] = base3d[Mod(i+1,3)]+base3d[Mod(i+2,3)];\n        \n        vec2 dir2 = Transform(base3d[i]*Rotate(iTime));\n        \n        for(int j=0;j<4;j++){\n        \n            vec3 point3;\n            \n            if(j==i){\n               point3 = start;\n            }\n            else{\n                point3 = start + base3d[j];\n            }\n        \n            \n            \n            vec2 point2 = Transform(point3*Rotate(iTime));\n            \n            //-0.5-point3[i];\n            float tmin = 0.;\n            //0.5-point3[i]\n            float tmax = 1.;\n            \n            float xmin = dir2[0]*tmin+point2[0];\n            float xmax = dir2[0]*tmax+point2[0];\n            float ymin = dir2[1]*tmin+point2[1];\n            float ymax = dir2[1]*tmax+point2[1];\n            \n            \n            //float degree = smoothstep(0.1,0.0,(uv.x-point2.x)*dir2.y-(uv.y-point2.y)*dir2.x);\n\n            float degree = 1.0;\n            //degree *= InRange(xmin,xmax,uv.x);\n            //degree *= InRange(ymin,ymax,uv.y);\n            if(dir2.x == 0.0){\n                degree *=InRange(ymin,ymax,uv.y);\n            }\n            else{\n                degree *= InRange(xmin,xmax,uv.x);\n            }\n            degree *= step(-0.02,-abs((uv.x-point2.x)*dir2.y-(uv.y-point2.y)*dir2.x));\n           // \n            c = mix(c,vec3(1.0),degree);\n            //c = DrawLine(c,uv,tmin,tmax,point3,base3d[i]);\n        }\n        \n    }\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y*10.0;\n    vec3 col = vec3(0.0);\n    vec3 pointcol = vec3(1.0);\n    \n    //vec3 vecList[8] = vec3[8](vec3(-0.5,-0.5,-0.5),vec3(0.5,-0.5,-0.5),vec3(-0.5,0.5,-0.5),vec3(-0.5,-0.5,0.5),vec3(0.5,0.5,-0.5),vec3(-0.5,0.5,0.5),vec3(0.5,-0.5,0.5),vec3(0.5,0.5,0.5));\n\n    //for(int i=0;i<8;i++){\n        //vec2 pos2d = Transform(vecList[i]*Rotate(iTime));\n        \n        //float degree = smoothstep(0.1,0.0,distance(uv,pos2d));\n        //float degree = step(-0.05,-distance(uv,pos2d));\n        \n        //col = mix(col,vecList[i]+vec3(0.5,0.5,0.5),degree);\n    //}\n\n    //col = DrawCube(col,uv);\n    //float degree = smoothstep(0.02,0.0,abs(uv.x-1.0));\n    //degree *= InRange(-0.5,0.5,uv.y);\n    //col = mix(col,pointcol,degree);\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(0.5,-0.5,-0.5),vec3(0.0,0.0,1.0));\n    //col = DrawLine(col,uv,0.0,1.0,vec3(0.5,-0.5,-0.5),vec3(0.0,1.0,0.0));\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(-0.5,-0.5,-0.5),vec3(1.0,0.0,0.0));\n    //col = DrawLine(col,uv,0.0,1.0,vec3(0.5,-0.5,-0.5),vec3(-1.0,0.0,0.0));\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(-0.5, 0.5, -0.5),vec3(0.0,0.0,1.0));\n    //col = DrawLine(col,uv,-1.0,0.0,vec3(-0.5, 0.5, -0.5),vec3(0.0,1.0,0.0));\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(-0.5, 0.5, -0.5),vec3(1.0,0.0,0.0));\n    //col = DrawLine(col,uv,-1.0,0.0,vec3(-0.5, 0.5, -0.5),vec3(-1.0,0.0,0.0));\n    \n    //col = DrawLine(col,uv,-1.0,0.0,vec3(-0.5, -0.5, 0.5),vec3(0.0,0.0,1.0));\n    //col = DrawLine(col,uv,0.0,1.0,vec3(-0.5, -0.5, 0.5),vec3(0.0,1.0,0.0));\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(-0.5, -0.5, 0.5),vec3(1.0,0.0,0.0));\n    //col = DrawLine(col,uv,-1.0,0.0,vec3(-0.5, -0.5, 0.5),vec3(-1.0,0.0,0.0));\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(0.5, 0.5, -0.5),vec3(0.0,0.0,1.0));\n    //col = DrawLine(col,uv,0.0,1.0,vec3(0.5, -0.5, 0.5),vec3(0.0,1.0,0.0));\n    \n    //col = DrawLine(col,uv,0.0,1.0,vec3(-0.5, 0.5, 0.5),vec3(1.0,0.0,0.0));\n    //col = DrawLine(col,uv,-1.0,0.0,vec3(-0.5, 0.5, 0.5),vec3(-1.0,0.0,0.0));\n    \n    col = DrawCube(col,uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}