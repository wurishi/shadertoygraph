{"ver":"0.1","info":{"id":"ddXBDM","date":"1688787323","viewed":74,"name":"first 3d scene","username":"thacuber2a03","description":"first time doing raymarching, gotta add light, dunno how :(\nedit: added light with help of a friend :D\nedit 2: smooth minimum :D\nedit 3: another box\nedit 4: INFINITE VERTICAL STRUCTURES","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define MIN_DIST .001\n\n#define eps 0.0125\n\nvec3 rotateY(vec3 i, float theta)\n{\n    return i * mat3(\n         cos(theta), 0, sin(theta),\n         0,          1, 0,\n        -sin(theta), 0, cos(theta)\n    );\n}\n\nvec3 rotateX(vec3 i, float theta)\n{\n    return i * mat3(\n        1, 0,           0,\n        0, cos(theta), -sin(theta),\n        0, sin(theta),  cos(theta)\n    );\n}\n\nfloat sphereSDF(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 p, vec3 ro)\n{\n    p.y = mod(p.y, 3.);\n    float box1 = boxSDF(p, vec3(2, .1, 2));\n    float box2 = boxSDF(p, vec3(.1, 2, .1));\n    float sphere = sphereSDF(p - vec3(cos(iTime*4.), 2.*sin(iTime), 2.*sin(iTime)), 1.);\n    return smin(box2, smin(box1, sphere, 1.), 0.5);\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n  float c = scene(p, ro);\n  vec2 e = vec2(eps,0.0);\n  return normalize(vec3(\n    scene(p + e.xyy, ro),\n    scene(p + e.yxy, ro),\n    scene(p + e.yyx, ro)) - c);\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    \n    while (true)\n    {\n        float dist = scene(p, ro);\n        p += rd * dist;\n        if (dist >= MAX_DIST)\n        {\n            return mix(\n                mix(vec4(0, 0, 0.5, 1), vec4(1), -rd.y),\n                vec4(0, 1, 0, 1), rd.x\n            );\n        }\n        \n        if (dist <= MIN_DIST)\n        {\n            vec4 color = vec4(1);\n            vec3 dlight = normalize(vec3(1,1,1));\n            float lambert = max(dot(dlight,calcNormal(p, ro)),0.0);\n            vec3 la = vec3(0.03,0.04,0.1);\n            color *= vec4(lambert+la, 1);\n            return color;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.y *= aspectRatio;\n    \n    vec3 ro = vec3(0, 10, -14);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    rd = rotateX(rd, .7);\n    ro = rotateY(ro, iTime);\n    rd = rotateY(rd, iTime);\n    \n    vec4 color = rayMarch(ro, rd);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}