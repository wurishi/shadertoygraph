{"ver":"0.1","info":{"id":"cddyDS","date":"1695410160","viewed":48,"name":"Ray tracing starter","username":"jsulpis","description":"Simple ray tracing algorithm. \nI get errors when tweaking the parameters, so there are probably implementation errors (especially in the specular reflections I think).\nI keep it as a reference but be careful if you reuse a part of it","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=======================================================================================//\n//\n// Ray tracing starter\n// by Julien Sulpis (https://twitter.com/jsulpis)                   \n// https://www.shadertoy.com/view/cddyDS\n//\n// inspired by:\n// Polytonic - Annotated Ray Tracing (https://www.shadertoy.com/view/4ljGRd)\n// Zavie - Ray tracing a cone (https://www.shadertoy.com/view/MtcXWr)\n//\n//=======================================================================================//\n\n#define CAMERA_POSITION vec3(0., 1.5, 4.)\n\n#define SUN_DIR normalize(vec3(0.5, 1., 0.))\n#define SUN_COLOR vec3(1.)\n#define AMBIENT_COLOR vec3(0.12, 0.43, 1)\n#define AMBIENT_LIGHT .03 * AMBIENT_COLOR\n\n#define MAX_BOUNCES 3\n#define EPSILON 1e-3\n#define INFINITY 1e10\n\n//=========//\n//  Types  //\n//=========//\n\nstruct Material {\n    vec3 color;\n    float specular;\n};\n\nstruct Hit {\n    float len;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Plane {\n    float offset;\n    vec3 normal;\n    Material material;\n};\n\n// Note: I had created a struct for Ray but then deleted it because it caused artifacts on some mobile devices\n// because of a precision issue with struct (https://github.com/KhronosGroup/WebGL/issues/3351)\n// I use ro and rd instead in this shader.\n\nHit miss = Hit(INFINITY, vec3(0.), Material(vec3(0.), -1.));\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n//===============//\n//  Ray Tracing  //\n//===============//\n\nHit intersectPlane(vec3 ro, vec3 rd, Plane p) {\n    float dotnd = dot(p.normal, rd);\n    if(dotnd > 0.)\n        return miss;\n    float t = -(dot(ro, p.normal) + p.offset) / dotnd;\n    return Hit(t, p.normal, p.material);\n}\n\nHit intersectSphere(vec3 ro, vec3 rd, Sphere s) {\n    vec3 op = s.position - ro;\n    float b = dot(op, rd);\n    float det = b * b - dot(op, op) + s.radius * s.radius;\n    if(det < 0.)\n        return miss;\n\n    det = sqrt(det);\n    float t = b - det;\n    if(t < 0.)\n        t = b + det;\n    if(t < 0.)\n        return miss;\n\n    return Hit(t, (ro + t * rd - s.position) / s.radius, s.material);\n}\n\nvoid takeClosest(inout Hit a, Hit b) {\n    if(b.len < a.len) {\n        a = b;\n    }\n}\n\nHit intersectScene(vec3 ro, vec3 rd) {\n    Sphere sphere = Sphere(\n        rotateY(iTime) * vec3(1., 1., 0.),\n        1.,\n        Material(vec3(0.9), .01)\n    );\n    Sphere sphere2 = Sphere(\n        rotateY(iTime) * vec3(-1., 2., 0.),\n        1.,\n        Material(vec3(1., .1, .1), .9)\n    );\n    Plane plane = Plane(\n        0.,\n        vec3(0., 1., 0.),\n        Material(vec3(0.12, 0.43, 1), .9)\n    );\n\n    Hit hit = miss;\n    takeClosest(hit, intersectPlane(ro, rd, plane));\n    takeClosest(hit, intersectSphere(ro, rd, sphere));\n    takeClosest(hit, intersectSphere(ro, rd, sphere2));\n\n    return hit;\n}\n\n// Schlick approximation (http://en.wikipedia.org/wiki/Schlick's_approximation)\nvec3 fresnelFactor(vec3 normal, vec3 viewDir, Material material) {\n    vec3 r0 = material.color * (1. - material.specular);\n    float hv = clamp(dot(normal, -viewDir), 0.0, 1.0);\n    return r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n}\n\nvec3 radiance(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.);\n    vec3 attenuation = vec3(1.);\n    vec3 fresnel = vec3(0.);\n\n    for(int i = 1; i <= MAX_BOUNCES; i++) {\n        Hit hit = intersectScene(ro, rd);\n\n        if(hit != miss) {\n\n            vec3 hitPosition = ro + hit.len * rd;\n            fresnel = fresnelFactor(hit.normal, rd, hit.material);\n\n            Hit shadowHit = intersectScene(hitPosition + EPSILON * SUN_DIR, SUN_DIR);\n\n            if(shadowHit == miss) {\n                // Diffuse\n                vec3 directLight = clamp(dot(hit.normal, SUN_DIR), 0.0, 1.0) * SUN_COLOR;\n                vec3 diffuseColor = hit.material.color * directLight;\n\n                // Specular\n                vec3 r = normalize(reflect(SUN_DIR, hit.normal));\n                float phongValue = max(0.0, dot(rd, r));\n                float coef = pow(1. - hit.material.specular, 10.) * 1e3; // complete guesswork, I don't know how to compute this phong coefficient\n                phongValue = pow(phongValue, coef);\n\n                vec3 specular = vec3(phongValue * coef);\n\n                color += attenuation * (diffuseColor + specular);\n            }\n            color += attenuation * hit.material.color * AMBIENT_LIGHT;\n\n            // Next bounce\n            attenuation *= fresnel * (1. - hit.material.specular);\n            vec3 d = reflect(rd, hit.normal);\n            ro = ro + hit.len * rd + EPSILON * d;\n            rd = d;\n        } else {\n            color += attenuation * AMBIENT_COLOR;\n            break;\n        }\n    }\n    return color;\n}\n\n// Zavie - https://www.shadertoy.com/view/lslGzl\nvec3 simpleReinhardToneMapping(vec3 color) {\n    float exposure = 1.3;\n    color *= exposure / (1. + color / exposure);\n    color = pow(color, vec3(1. / 2.2));\n    return color;\n}\n\n//========//\n//  Main  //\n//========//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy / iResolution.xy - 1.) * iResolution.xy / iResolution.y;\n\n    vec3 ro = CAMERA_POSITION;\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 color = radiance(ro, rd);\n\n    fragColor = vec4(simpleReinhardToneMapping(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}