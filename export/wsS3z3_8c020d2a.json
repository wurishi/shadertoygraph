{"ver":"0.1","info":{"id":"wsS3z3","date":"1559756199","viewed":88,"name":"RYMRCH WKSP - 3D Sphere Shadows","username":"trevortheblack","description":"The 3D section of Electric Square's raymarching workshop\nhttps://github.com/ajweeks/RaymarchingWorkshop\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TREVOR BLACK\n// LICENSE - There Ain't One\n// This is my take on the 2D raymarching from the RaymarchingWorkshop\n\n\n// Companion shader for Raymarching Workshop run at Electric Square\n// Workshop site: https://github.com/ajweeks/RaymarchingWorkshop\n\n// MIT license\n\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n#define SHADOW_FALLOFF 0.1\n\n// -------------------------\n// SDF FUNCTION DECLARATIONS\nfloat sdSphere   (vec3 p, float s);\nfloat sdBox      (vec3 p, vec3 b);\nfloat sdPlane    (vec3 p, vec4 n);\nfloat sdCylinder (vec3 p, vec3 c);\nfloat sdTorus    (vec3 p, vec2 t);\nfloat sdRoundBox (vec3 p, vec3 b, float r);\n\n// -------------------------\n// SDF UTILITY DECLARATIONS\nfloat opU(float d1, float d2);\nfloat opBlend(float d1, float d2);\n\n// --------------\n// NOISE AND RAND\nfloat rand(vec2 co);\nfloat goldNoise(in vec2 co, in float seed);\n\n\n// --------------------------\n// MAIN FUNCTION DECLARATIONS\nfloat sdf(vec3 pos);\nvec2 normalizeScreenCoords(vec2 screenCoord);\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget);\nvec3 render(vec3 camPos, vec3 rayDir);\nvec3 calcNormal(vec3 pos);\n\n// compute pixel colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(0.0, 0.0, -1.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    \n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);\n    \n    vec3 col = render(camPos, rayDir);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\nvec2 normalizeScreenCoords(vec2 screenCoords)\n{\n    vec2 result = 2.0 * (screenCoords/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0,1.0,0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    \n    float fPersp = 2.0;\n    vec3 vDir = normalize((uv.x * camRight) + (uv.y * camUp) + (camForward * fPersp));\n    return vDir;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float res = sdf(rayOrigin + rayDir * t);\n        if(res < (0.0001*t))\n            return t;\n        t += res;\n    }\n    return -1.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col;\n    float t = castRay(rayOrigin, rayDir);\n    \n    vec3 L = normalize(vec3(sin(iTime)*1.0, cos(iTime*0.5)+0.5, -0.5));\n    \n    if (t == -1.0)\n    {\n        // Skybox color\n        col = vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.4);\n    }\n    else\n    {\n        vec3 pos = rayOrigin + t*rayDir;\n        vec3 N = calcNormal(pos);\n        \n        vec3 objectSurfaceColor = vec3(0.4, 0.8, 0.1);\n        float NDotL = max(dot(N,L), 0.0);\n        vec3 LDir = vec3(1.80, 1.27, 0.99) * NDotL;\n        vec3 LAmb = vec3(0.03, 0.04, 0.1);\n        vec3 diffuse = objectSurfaceColor * (LDir + LAmb);\n        \n        col = diffuse;\n        \n        \n        // Add shadows\n        \n        // HARD SHADOWS\n        float shadow = 0.0;\n        vec3 shadowRayOrigin = pos + N * 0.01;\n        vec3 shadowRayDir = L;\n        float shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n        if(shadowRayIntersection != -1.0)\n            shadow = 1.0;\n        \n        col = mix(col, col*0.2, shadow);\n        \n        /* SOFT SHADOWS\n        float shadowRayCount = 128.0;        \n        float shadow = 0.0;\n        for(float s = 0.0; s < shadowRayCount; s++)\n        {\n            vec3 shadowRayOrigin = pos + N * 0.01;\n            float rX = goldNoise(vec2(rayDir.xy), 0.0) * 2.0 - 1.0;\n            float rY = goldNoise(vec2(rayDir.xy), 1.0) * 2.0 - 1.0;\n            float rZ = goldNoise(vec2(rayDir.xy), 2.0) * 2.0 - 1.0;\n            vec3 shadowRayDir = L + SHADOW_FALLOFF * vec3(rX, rY, rZ);\n            float shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n            if(shadowRayIntersection != -1.0)\n                shadow += 1.0;\n        }\n        \n        col = mix(col, col*0.2, shadow/shadowRayCount);\n        */     \n\n        // Gamma Correction\n        col = pow(col, vec3(0.4545));\n    }\n    \n    return col;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = sdf(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3(sdf(pos + eps_zero.xyy),\n        sdf(pos + eps_zero.yxy), sdf(pos + eps_zero.yyx)) - c);\n}\n\n\n// SDF \nfloat sdf(vec3 pos)\n{\n    float t = sdSphere(pos - vec3(0.0, 0.0, 10.0), 3.0);\n    return t;\n}\n\n\n// -------------------------\n// SDF FUNCTION DEFINITIONS\n// -------------------------\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;   \n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y,d.z)), 0.0);\n}\n\nfloat sdPlane    (vec3 p, vec4 n)\n{ // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdCylinder (vec3 p, vec3 c)\n{\n    return length(p.xz-c.xy) - c.z;\n}\n\nfloat sdTorus    (vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdRoundBox (vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) - r +\n        min(max(d.x, max(d.y,d.z)), 0.0);                 \n}\n\n// -------------------------\n// SDF Utility Library\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opBlend(float d1, float d2)\n{\n    float k = 0.2;\n    return sminCubic(d1, d2, k);\n}\n// --------------------------\n\n// -------------------------\n// NOISE and RAND\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);    \n}\n\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat goldNoise(in vec2 co, in float seed)\n{\n    return fract(tan(distance(co*(seed+PHI), vec2(PHI,PI)))*SQ2);\n}\n\n// --------------------------\n","name":"Image","description":"","type":"image"}]}