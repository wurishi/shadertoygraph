{"ver":"0.1","info":{"id":"Wt2yDz","date":"1594149138","viewed":98,"name":"Sound_Rising","username":"kvick","description":"alternating between light and dark...\n","likes":7,"published":1,"flags":8,"usePreview":0,"tags":["sound","rising"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rotate(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tri(vec2 st, float s)\n{\n    st /= s;\n    float line = 0.;\n    float f = smoothstep(line - 0.001, line, st.x);\n    f *= smoothstep(line + 0.001, line, st.x + (st.y - 1.0));\n    f *= smoothstep(line - 0.001, line, st.y);\n    return 1. - f;\n}\n\nfloat circ(vec2 st, float r)\n{\n    return smoothstep(0., 3./iResolution.y, length(st) - (r * 0.5));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 st = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    float f = circ(st, 0.5);\n    \n    f = max(f, 1. - circ(st, 0.15));\n    \n    f *= smoothstep(0.1, 0.1 + 0.001, uv.y);\n    \n    //triangles around circle\n    float tTime = iTime * 0.1;\n    f *= tri(rotate(0. + tTime) * st - vec2(0., 0.3), 0.1);\n    f *= tri(rotate(3.1415 + tTime) * st - vec2(0., 0.3), 0.1);\n    \n    //triangles along ground\n    f *= tri(st + vec2(-1.85 + mod(tTime, 4.0), 0.78), 0.05);\n    \n    col = vec3(1., 0., 0.) * f;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi  3.1415\n#define pi2 6.2831\n\nfloat repeat = 0.125;\nfloat numNotesInScale = 12.;\n\nfloat getSound1(float f, float time)\n{\n    float mt = mod(time, repeat);\n    float id = floor(time / repeat);\n    \n    float pt = pi2 * mt;\n    \n    float e = exp(-3.0*mt);\n    \n    float i = f / numNotesInScale;\n    \n    float o1 = sin(f*1.*pt)*e;\n    float o2 = sin((f + f/2.)*pt)*e;//fifth\n    float o3 = sin((f + f/3.)*pt)*e;//fourth\n    float o4 = sin((f + f/4.)*pt)*e;//third\n    float o5 = sin((f + f/5.)*pt)*e;//minor third\n    float o6 = sin((f + f/6.)*pt)*e;//?\n    float o7 = sin((f + f/7.)*pt)*e;//major second\n    float o8 = sin((f + f/12.)*pt)*e;//minor second\n   \n    float scaleMode = 0.;//0 is ionian\n    id = scaleMode + 3. - mod(id, 3.);\n    \n    float waveSquaredness = 1. + (sin(time * pi2 / (repeat * 12.)) * .5 + .5) * 2.;\n    \n    float u1 = clamp(sin((f + (id) * i)*pt)*e * waveSquaredness, 0., 1.);\n    \n    float r; \n    r += o1;//fundamental\n    r += u1;\n    \n    r *= 0.01;\n    \n    return r;\n}\n\nvec2 getSound2(float time)\n{\n    vec2 final = vec2(0.);\n    float bar = mod(floor(time / (repeat * 12.)), 3.);\n    if (bar == 1.) numNotesInScale = pow((sin(time) * .5 + .5) * 4., 0.0125);\n    else if (bar == 2.) numNotesInScale = 1.;\n    else numNotesInScale = 2.;\n    \n    //float f1 =  + getSound1(880., time);\n    float f2 = getSound1(440., time * 0.5);\n    float f3 = getSound1(220., time * 0.25);\n    float ff2 = getSound1(440., time * 1.125);\n    \n    float r = f3 + ff2;\n    \n    \n    r += f2 * ceil(sin(time * pi2 / (repeat * 4.)));\n    \n    final.x = getSound1(440., time) * ceil(sin(time * pi2 * repeat));\n    \n    final.y = getSound1(880., time) * ceil(sin((time * pi2 + pi * 0.25) * repeat));\n    final.y += getSound1(660., time) * ceil(sin((time * pi2 + pi) * repeat));\n    \n    final += vec2(r);\n    return final;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 final = vec2(0.);\n    \n    for (float i = 0.; i < 8.; i += 1.)\n    {\n        final += getSound2(i += time);//this was by accident but its cool\n    }\n    \n    for (float i = 0.; i < 4.; i += 1.)\n    {\n        final += getSound2((i * 0.15) + time);\n    }\n    \n    return final;\n}","name":"Sound","description":"","type":"sound"}]}