{"ver":"0.1","info":{"id":"csl3Rl","date":"1714424628","viewed":74,"name":"Minecraft World Generation","username":"Spheya","description":":)","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                     //\n//  Most of this code has been shamelessly stolen from Cubiomes, so shoutout to them!  //\n//                      https://github.com/Cubitect/cubiomes                           //\n//                                                                                     //\n//  I also used a bunch of code from https://github.com/calccrypto/uint128_t to        //\n//  handle 64 bit integers                                                             //\n//                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////\n\n// Change this to show a different seed, its split into two numbers because\n// a minecraft seed is 64 bit, but shadertoy only supports 32\nconst uvec2 SEED = uvec2(0u, 345919u);\n\nstruct PerlinNoise {\n    uint d[128];\n    float a, b, c;\n    float amplitude;\n    float lacunarity;\n};\n\nstruct Xoroshiro {\n    uvec2 lo;\n    uvec2 hi;\n};\n\nconst float amp_c[] = float[]( 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 1.0 );\nconst int amp_c_len = 9;\n\nXoroshiro rand;\nPerlinNoise octaves[18];\n\nvoid setPerlinNoiseD(int octave, int index, uint value) {\n    int idx = index / 4;\n    int byte = index % 4;\n    octaves[octave].d[idx] &= ~(0xFFu << (byte * 8));\n    octaves[octave].d[idx] |= (value & 0xFFu) << (byte * 8);\n}\n\nuint getPerlinNoiseD(int octave, int index) {\n    int idx = index / 4;\n    int byte = index % 4;\n    return (octaves[octave].d[idx] >> (byte * 8)) & 0xFFu;\n}\n\nuvec2 addUInt64(uvec2 lhs, uvec2 rhs) {\n    return uvec2(lhs.x + rhs.x + ((lhs.y + rhs.y < lhs.y) ? 1u : 0u), lhs.y + rhs.y);\n}\n\nuvec2 multUInt64(uvec2 lhs, uvec2 rhs) {\n    uvec4 top = uvec4(lhs.x >> 16u, lhs.x & 0xffffu, lhs.y >> 16u, lhs.y & 0xffffu);\n    uvec4 bottom = uvec4(rhs.x >> 16u, rhs.x & 0xffffu, rhs.y >> 16u, rhs.y & 0xffffu);\n    uvec4 products[4];\n\n    products[3] = top.wzyx * bottom.w;\n    products[2] = top.wzyx * bottom.z;\n    products[1] = top.wzyx * bottom.y;\n    products[0] = top.wzyx * bottom.x;\n\n    uvec4 result = uvec4(\n        (products[0].x & 0xffffu) + (products[1].x >> 16) + (products[1].y & 0xffffu) + (products[2].y >> 16) + (products[2].z & 0xffffu) + (products[3].z >> 16) + (products[3].w & 0xffffu),\n        (products[1].x & 0xffffu) + (products[2].x >> 16) + (products[2].y & 0xffffu) + (products[3].y >> 16) + (products[3].z & 0xffffu),\n        (products[2].x & 0xffffu) + (products[3].x >> 16) + (products[3].y & 0xffffu),\n        (products[3].x & 0xffffu)\n    );\n\n    result.z += result.w >> 16;\n    result.y += result.z >> 16;\n    result.x += result.y >> 16;\n\n    result.x &= 0xffffu;\n    result.y &= 0xffffu;\n    result.z &= 0xffffu;\n\n    return uvec2((result.x << 16) | result.y, (result.z << 16) | result.w);\n}\n\nuvec2 shiftUInt64Right(uvec2 lhs, int amount) {\n    if (amount >= 32)\n        return uvec2(0u, lhs.x >> (amount - 32));\n\n    uint mask = ~(0xffffffffu << amount);\n    return uvec2(lhs.x >> amount, ((lhs.x & mask) << (32 - amount)) | (lhs.y >> amount));\n}\n\nuvec2 xNextLong(inout Xoroshiro rng) {\n    uvec2 l = rng.lo;\n    uvec2 h = rng.hi;\n    \n    uvec2 n = addUInt64(l,h);\n    n = uvec2(((n.y & ~(0xffffffffu >> 17)) >> 15) | (n.x << 17), n.y << 17) | uvec2(0u, n.x >> 15);\n    n = addUInt64(n, l);\n    \n    h ^= l;\n    \n    rng.lo = (uvec2(l.y << (49 - 32), 0u) | uvec2(l.x >> 15, ((l.x & ~(0xffffffffu << 15)) << (17)) | (l.y >> 15))) ^\n             (uvec2(((h.y & ~(0xffffffffu >> 21)) >> (32 - 21)) | (h.x << 21), h.y << 21)) ^\n             h;\n    \n    rng.hi = uvec2(((h.y & ~(0xffffffffu >> 28)) >> 4) | (h.x << 28), h.y << 28) | uvec2(0u, h.x >> 4);\n    \n    return n;\n}\n\nfloat xNextFloat(inout Xoroshiro rng) {\n    return float(xNextLong(rng).x >> 8) * 5.9604645E-8;\n}\n\nint xNextInt(inout Xoroshiro rng, uint n) {\n    uvec2 r = multUInt64(uvec2(0u, xNextLong(rng).y), uvec2(0u, n));\n    if (r.y < n) {\n        while (r.y < (~n + 1u) % n) {\n            r = multUInt64(uvec2(0u, xNextLong(rng).y), uvec2(0u, n));\n        }\n    }\n    return int(r.x);\n}\n\nvoid initRandom() {\n    uvec2 XL = uvec2(0x9e3779b9u, 0x7f4a7c15u);\n    uvec2 XH = uvec2(0x6a09e667u, 0xf3bcc909u);\n    uvec2 A = uvec2(0xbf58476du, 0x1ce4e5b9u);\n    uvec2 B = uvec2(0x94d049bbu, 0x133111ebu);\n\n    uvec2 l = SEED ^ XH;\n    uvec2 h = addUInt64(l, XL);\n\n    l = multUInt64(l ^ shiftUInt64Right(l, 30), A);\n    h = multUInt64(h ^ shiftUInt64Right(h, 30), A);\n    l = multUInt64(l ^ shiftUInt64Right(l, 27), B);\n    h = multUInt64(h ^ shiftUInt64Right(h, 27), B);\n    l = (l ^ shiftUInt64Right(l, 31));\n    h = (h ^ shiftUInt64Right(h, 31));\n\n    rand.lo = l;\n    rand.hi = h;\n    uvec2 lo = xNextLong(rand) ^ uvec2(0x83886c9du, 0x0ae3a662u);\n    uvec2 hi = xNextLong(rand) ^ uvec2(0xafa638a6u, 0x1b42e8adu);\n    rand.lo = lo;\n    rand.hi = hi;\n}\n\nvoid perlinInit(int octave, inout Xoroshiro rng) {\n    octaves[octave].a = xNextFloat(rng) * 256.0;\n    octaves[octave].b = xNextFloat(rng) * 256.0;\n    octaves[octave].c = xNextFloat(rng) * 256.0;\n\n    octaves[octave].amplitude = 1.0;\n    octaves[octave].lacunarity = 1.0;\n\n    for (int i = 0; i < 256; i++) {\n        setPerlinNoiseD(octave, i, uint(i));\n    }\n    for (int i = 0; i < 256; i++) {\n        int j = xNextInt(rng, 256u - uint(i)) + i;\n        uint n = getPerlinNoiseD(octave, i);\n        setPerlinNoiseD(octave, i, getPerlinNoiseD(octave, j));\n        setPerlinNoiseD(octave, j, n);\n        setPerlinNoiseD(octave, i + 256, getPerlinNoiseD(octave, i));\n    }\n}\n\nvoid xOctaveInit(int octaveOffset, int omin) {\n    const uvec4 md5_octave_n[] = uvec4[](\n        uvec4(0xb198de63u, 0xa8012672u, 0x7b84cad4u, 0x3ef7b5a8u), // md5 \"octave_-12\"\n        uvec4(0x0fd787bfu, 0xbc403ec3u, 0x74a4a31cu, 0xa21b48b8u), // md5 \"octave_-11\"\n        uvec4(0x36d326eeu, 0xd40efeb2u, 0x5be9ce18u, 0x223c636au), // md5 \"octave_-10\"\n        uvec4(0x082fe255u, 0xf8be6631u, 0x4e96119eu, 0x22dedc81u), // md5 \"octave_-9\"\n        uvec4(0x0ef68ec6u, 0x8504005eu, 0x48b6bf93u, 0xa2789640u), // md5 \"octave_-8\"\n        uvec4(0xf1126812u, 0x8982754fu, 0x257a1d67u, 0x0430b0aau), // md5 \"octave_-7\"\n        uvec4(0xe51c98ceu, 0x7d1de664u, 0x5f9478a7u, 0x33040c45u), // md5 \"octave_-6\"\n        uvec4(0x6d7b49e7u, 0xe429850au, 0x2e3063c6u, 0x22a24777u), // md5 \"octave_-5\"\n        uvec4(0xbd90d537u, 0x7ba1b762u, 0xc07317d4u, 0x19a7548du), // md5 \"octave_-4\"\n        uvec4(0x53d39c67u, 0x52dac858u, 0xbcd1c5a8u, 0x0ab65b3eu), // md5 \"octave_-3\"\n        uvec4(0xb4a24d7au, 0x84e7677bu, 0x023ff966u, 0x8e89b5c4u), // md5 \"octave_-2\"\n        uvec4(0xdffa22b5u, 0x34c5f608u, 0xb9b67517u, 0xd3665ca9u), // md5 \"octave_-1\"\n        uvec4(0xd5070808u, 0x6cef4d7cu, 0x6e1651ecu, 0xc7f43309u)  // md5 \"octave_0\"\n    );\n\n    int i = 0;\n    int n = 0;\n    float lacuna = pow(2.0, float(omin));\n    float persist = pow(2.0, float(amp_c_len - 1)) / (pow(2.0, float(amp_c_len)) - 1.0);\n    uvec2 xlo = xNextLong(rand);\n    uvec2 xhi = xNextLong(rand);\n\n    for (int i = 0; i < amp_c_len; i++) {\n        Xoroshiro pxr;\n        pxr.lo = xlo ^ md5_octave_n[12 + omin + i].xy;\n        pxr.hi = xhi ^ md5_octave_n[12 + omin + i].zw;\n        perlinInit(n + octaveOffset, pxr);\n        octaves[n + octaveOffset].amplitude = amp_c[i] * persist;\n        octaves[n + octaveOffset].lacunarity = lacuna;\n\n        n++;\n        lacuna *= 2.0;\n        persist *= 0.5;\n    }\n}\n\nfloat indexedLerp(uint idx, float a, float b, float c)\n{\n    switch (idx & 0xfu)\n    {\n    case 0u:  return  a + b;\n    case 1u:  return -a + b;\n    case 2u:  return  a - b;\n    case 3u:  return -a - b;\n    case 4u:  return  a + c;\n    case 5u:  return -a + c;\n    case 6u:  return  a - c;\n    case 7u:  return -a - c;\n    case 8u:  return  b + c;\n    case 9u:  return -b + c;\n    case 10u: return  b - c;\n    case 11u: return -b - c;\n    case 12u: return  a + b;\n    case 13u: return -b + c;\n    case 14u: return -a + b;\n    case 15u: return -b - c;\n    }\n    return 0.0;\n}\n\nfloat lerp(float part, float from, float to)\n{\n    return from + part * (to - from);\n}\n\nfloat perlinNoise(int octave, float d1, float d2, float d3) {\n    const float yamp = 0.0;\n    const float ymin = 0.0;\n\n    d1 += octaves[octave].a;\n    d2 += octaves[octave].b;\n    d3 += octaves[octave].c;\n\n    int i1 = int(d1) - (d1 < 0.0 ? 1 : 0);\n    int i2 = int(d2) - (d2 < 0.0 ? 1 : 0);\n    int i3 = int(d3) - (d3 < 0.0 ? 1 : 0);\n\n    d1 -= float(i1);\n    d2 -= float(i2);\n    d3 -= float(i3);\n\n    float t1 = d1 * d1 * d1 * (d1 * (d1 * 6.0 - 15.0) + 10.0);\n    float t2 = d2 * d2 * d2 * (d2 * (d2 * 6.0 - 15.0) + 10.0);\n    float t3 = d3 * d3 * d3 * (d3 * (d3 * 6.0 - 15.0) + 10.0);\n\n    i1 &= 0xff;\n    i2 &= 0xff;\n    i3 &= 0xff;\n\n    int a1 = int(getPerlinNoiseD(octave, i1)) + i2;\n    int a2 = int(getPerlinNoiseD(octave, a1)) + i3;\n    int a3 = int(getPerlinNoiseD(octave, a1 + 1)) + i3;\n    int b1 = int(getPerlinNoiseD(octave, i1 + 1)) + i2;\n    int b2 = int(getPerlinNoiseD(octave, b1)) + i3;\n    int b3 = int(getPerlinNoiseD(octave, b1 + 1)) + i3;\n\n    float l1 = indexedLerp(getPerlinNoiseD(octave, a2), d1, d2, d3);\n    float l2 = indexedLerp(getPerlinNoiseD(octave, b2), d1 - 1.0, d2, d3);\n    float l3 = indexedLerp(getPerlinNoiseD(octave, a3), d1, d2 - 1.0, d3);\n    float l4 = indexedLerp(getPerlinNoiseD(octave, b3), d1 - 1.0, d2 - 1.0, d3);\n    float l5 = indexedLerp(getPerlinNoiseD(octave, a2+1), d1, d2, d3 - 1.0);\n    float l6 = indexedLerp(getPerlinNoiseD(octave, b2+1), d1 - 1.0, d2, d3 - 1.0);\n    float l7 = indexedLerp(getPerlinNoiseD(octave, a3+1), d1, d2 - 1.0, d3 - 1.0);\n    float l8 = indexedLerp(getPerlinNoiseD(octave, b3+1), d1 - 1.0, d2 - 1.0, d3 - 1.0);\n\n    l1 = lerp(t1, l1, l2);\n    l3 = lerp(t1, l3, l4);\n    l5 = lerp(t1, l5, l6);\n    l7 = lerp(t1, l7, l8);\n\n    l1 = lerp(t2, l1, l3);\n    l5 = lerp(t2, l5, l7);\n\n    return lerp(t3, l1, l5);\n}\n\nfloat octaveNoise(int octaveOffset, vec2 position) {\n    float v = 0.0;\n    for (int i = 0; i < 9; i++) {\n        float lf = octaves[i + octaveOffset].lacunarity;\n        float ax = position.x * lf;\n        float ay = 0.0 * lf;\n        float az = position.y * lf;\n        float pv = perlinNoise(i + octaveOffset, ax, ay, az);\n        v += octaves[i + octaveOffset].amplitude * pv;\n    }\n    return v;\n}\n\nfloat doublePerlinNoise(vec2 position) {\n    const float f = 337.0 / 331.0;\n    float v = 0.0;\n    \n    v += octaveNoise(0, position);\n    v += octaveNoise(9, position);\n\n    return v * ((10.0 / 6.0) * 9.0 / 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandom();\n    xOctaveInit(0, -9);\n    xOctaveInit(9, -9);\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv.y = -uv.y;\n    \n    float noise = doublePerlinNoise(uv * 1000.0);\n    \n    fragColor = noise > -0.19 ? vec4(1.0) : vec4(0.6, 0.8, 0.9, 1.0);\n}","name":"Image","description":"","type":"image"}]}