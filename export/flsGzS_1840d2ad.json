{"ver":"0.1","info":{"id":"flsGzS","date":"1639366669","viewed":97,"name":"002 - occlusion trace","username":"francislarge","description":"Shadow ray done with ray marching\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["s"],"hasliked":0,"parentid":"flsGRS","parentname":"002 Lit Box Scene - Initial "},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct FHitResult\n{\n    bool  bWasAHit;\n    float Distance;\n    int   BoxHit_ID;\n};\n\nstruct Box\n{\n    vec2  Position;\n    vec2  Bounds;\n    float OutputMask;\n    vec3  Color;\n    float EdgeThickness;\n    float EdgeMask;\n    vec2  Normal;\n    vec2  SurfacePosition;\n    \n    //For shadow raymarching\n    int   ID;\n    bool  bIgnoreMe; //if a box initiated a shadow trace, ignore the box \n};\nconst int TOTAL_SCENE_BOXES  = 5;\n\nstruct Light\n{\n    int   Type;\n    vec3  Color;\n    vec2  Position;   //for point light\n    vec2  Direction; //for directional light\n    float Intensity;\n    float ConeOpening; //for spot light\n    float Blend; //for spot light\n    \n    //Attenuation\n    float Constant;\n    float Linear;\n    float Quadratic;\n};\nconst int TOTAL_SCENE_LIGHTS  = 5;\n\nconst int POINT_LIGHT = 100, DIRECTIONAL_LIGHT = 200, AMBIENT_LIGHT = 300;\nLight DefaultLightParameter = Light(0, vec3(1.0, 0.0, 1.0), vec2(0), vec2(0), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0); \n\nvec3  CreateCircle( vec2 Position, float Radius, float Intensity, vec3 Color, vec2 uv );\nfloat CreateBox(  inout Box box, vec2 uv );\nfloat CreateBoxEdgeMask( Box box, vec2 uv );\nvec2  GetNormal( Box box, vec2 Point );\nvec2  GetSurfacePosition( Box box, vec2 uv );\n\n\nvec3 CalculateLighting( inout Light SceneLights[TOTAL_SCENE_LIGHTS],   int LightCount,  inout Box Box,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int BoxesCount);\nvoid AddLightToScene( inout Light SceneLights[TOTAL_SCENE_LIGHTS], Light LightToAdd,  inout int LightsCount);\nvoid AddBoxToScene( inout Box SceneBoxes[TOTAL_SCENE_BOXES], Box BoxToAdd,  inout int BoxesCount);\n\nvec3 GetSceneLightsAsCircles(  inout Light SceneLights[TOTAL_SCENE_LIGHTS], int LightsCount, float Radius,  inout vec2 uv );\nvec3 CalculateLightingForAllObjects( inout Light SceneLights[TOTAL_SCENE_LIGHTS], int LightCount,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int BoxesCount);\n\n\nfloat SceneSDF(vec2 RayCurrentPosition,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int ObjectsCount,  inout int ClosestObject_ID);\nFHitResult RayMarch(vec2 RO, vec2 RD,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int BoxesCount);\n\nconst int   MAX_STEPS = 100;\nconst float MAX_DISTANCE = 500.0;\nconst float SURFACE_DISTANCE = 0.01;\n\nconst float CanvasSize = 200.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0;\n    uv = (uv - 1.0) * CanvasSize;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 LightPosition = vec2(0.0);\n    \n    // Scene boxe(s)\n    Box Box1;\n    Box1.Position = vec2(-150.0, 0.);\n    Box1.Bounds   = vec2(50.0);\n    Box1.Color    = vec3(0.0, 0.8, 0.1);\n    Box1.OutputMask      = CreateBox( Box1, uv );\n    Box1.EdgeThickness   = 2.0;\n    Box1.EdgeMask        = CreateBoxEdgeMask( Box1, uv );\n    Box1.Normal          = GetNormal( Box1, uv );\n    Box1.SurfacePosition = GetSurfacePosition( Box1, uv );\n    \n    Box Box2;\n    Box2.Position = vec2(125.0, -10.);\n    Box2.Bounds   = vec2(50.0);\n    Box2.Color    = vec3(0.8, 0.0, 0.1);\n    Box2.OutputMask      = CreateBox( Box2, uv );\n    Box2.EdgeThickness   = 2.0;\n    Box2.EdgeMask        = CreateBoxEdgeMask( Box2, uv );\n    Box2.Normal          = GetNormal( Box2, uv );\n    Box2.SurfacePosition = GetSurfacePosition( Box2, uv );\n    \n    Box SceneBoxes[TOTAL_SCENE_BOXES]; int BoxesCount = 0;\n    AddBoxToScene(SceneBoxes, Box1, BoxesCount);\n    AddBoxToScene(SceneBoxes, Box2, BoxesCount);\n    \n    //\n    \n    vec2 MousePosition = iMouse.xy / iResolution.xy * 2.0;\n    \n    MousePosition    = (MousePosition - 1.0) * CanvasSize;\n    MousePosition.x *= iResolution.x / iResolution.y;\n    \n    //Lights     \n    Light PointLight1     = DefaultLightParameter;\n    PointLight1.Color     = vec3(1.);\n    PointLight1.Type      = POINT_LIGHT;\n    PointLight1.Intensity = 1.0;\n    PointLight1.Position  = MousePosition; //vec2(100.0, .0);\n    //PointLight1.Constant  = 1.0;\n    //PointLight1.Linear    = 0.019;\n    //PointLight1.Quadratic = 0.00002;\n    \n    Light AmbientLight     = DefaultLightParameter;\n    AmbientLight.Type      = AMBIENT_LIGHT;\n    AmbientLight.Color     = vec3(1.0);\n    AmbientLight.Intensity = 0.090;\n    \n    //Array of lights /  add lights to scene\n    Light SceneLights[TOTAL_SCENE_LIGHTS]; int LightsCount = 0;\n    AddLightToScene(SceneLights, PointLight1,       LightsCount);\n    AddLightToScene(SceneLights, AmbientLight,      LightsCount);\n    \n    \n    //Combine for a final output\n    vec3 BoxesOutput = CalculateLightingForAllObjects(SceneLights, LightsCount, SceneBoxes, BoxesCount);\n    vec3 LightOutput = GetSceneLightsAsCircles( SceneLights, LightsCount, 10.0, uv );\n   \n   //  fragColor = vec4( (HitResult.bWasAHit ? 0.0 : 1.0) * SceneBoxes[1].EdgeMask ) ;\n    fragColor =  vec4( BoxesOutput + LightOutput, 1.0 );\n}\n\nvec3 GetSceneLightsAsCircles(  inout Light SceneLights[TOTAL_SCENE_LIGHTS], int LightsCount, float Radius,  inout vec2 uv )\n{\n    vec3 FinalOutput = vec3(0.0);\n    \n    for(int i = 0; i < LightsCount; i++ )\n    {\n        if( SceneLights[i].Type == AMBIENT_LIGHT || SceneLights[i].Type == DIRECTIONAL_LIGHT  )\n            continue;\n            \n        FinalOutput += CreateCircle( \n                               SceneLights[i].Position, \n                               Radius, \n                               SceneLights[i].Intensity,\n                               SceneLights[i].Color,\n                               uv \n                            );    \n        \n    }\n    \n    return FinalOutput;\n}\n\nfloat SceneSDF(vec2 RayCurrentPosition,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int ObjectsCount,  inout int ClosestObject_ID)\n{\n    float ClosestDistance = 3000000.0;\n    for(int i = 0; i < ObjectsCount; i++)\n    {\n        if(SceneBoxes[i].bIgnoreMe) continue;\n        \n        float CurrentDistance = 0.0;\n        \n        vec2 DistanceToRay = RayCurrentPosition - SceneBoxes[i].Position;\n    \n        vec2 Boundary_To_DistanceToPoint = abs(DistanceToRay) - SceneBoxes[i].Bounds;\n    \n        Boundary_To_DistanceToPoint  = max(Boundary_To_DistanceToPoint, 0.0); \n    \n        CurrentDistance = length(Boundary_To_DistanceToPoint);\n       \n        //Distance check\n        if(CurrentDistance < ClosestDistance)\n        { \n            ClosestDistance  = CurrentDistance;\n            ClosestObject_ID = SceneBoxes[i].ID;\n        }\n    }\n    \n    return ClosestDistance;\n}\n\nFHitResult RayMarch(vec2 RO, vec2 RD,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int BoxesCount)\n{    \n    float MarchDistance = 0.0;\n    \n    FHitResult HitResult = FHitResult(false, MarchDistance, 0);\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float DistanceToScene = SceneSDF(\n                RO + RD * MarchDistance, \n                SceneBoxes, \n                BoxesCount, \n                HitResult.BoxHit_ID\n        );\n\n        if(DistanceToScene < SURFACE_DISTANCE) //if current distance is close enough to surface\n        {\n            HitResult.bWasAHit = true;\n            break;\n        }\n        \n        MarchDistance += DistanceToScene;\n\n        if(MarchDistance >= MAX_DISTANCE) //Exhausted max distance without hitting anything\n        {\n            HitResult.bWasAHit = false;\n            break;\n        }        \n    }\n    \n    HitResult.Distance = MarchDistance;\n    return HitResult;\n}\n\nfloat CreateBoxEdgeMask( Box box, vec2 uv )\n{\n    box.Bounds += box.EdgeThickness;\n    return distance(\n        sign(box.OutputMask), \n        sign(CreateBox( box, uv ) )\n    );\n}\n\nvec3 CreateCircle( vec2 Position, float Radius, float Intensity, vec3 Color, vec2 uv )\n{\n    float Circle = distance( Position, uv ) / Radius;\n    Circle = pow(Circle, 5.0);\n    Circle = min(Circle, 1.0);\n    Circle = 1.0 - Circle;\n    \n    return Color * Circle;\n}\n\nfloat CreateBox(  inout Box box, vec2 uv )\n{\n    vec2 temp = abs( (uv - box.Position) ) / box.Bounds;\n    temp.x = pow(temp.x, 5.0 );\n    temp.y = pow(temp.y, 5.0 );\n    temp = clamp(temp, 0.0, 1.0);\n    temp = 1.0 - temp;\n    \n    return temp.x * temp.y;\n    \n}\n\nvec2 GetNormal( Box box, vec2 Point )\n{\n    vec2 DistanceToPoint = Point - box.Position;\n    \n    vec2 Boundary_To_DistanceToPoint = abs(DistanceToPoint) - box.Bounds;\n    \n    Boundary_To_DistanceToPoint  = max(Boundary_To_DistanceToPoint, 0.0); \n    \n    vec2 Normal = Boundary_To_DistanceToPoint  * sign(DistanceToPoint);\n    \n    return normalize(Normal);\n}\n\n\nvec2  GetSurfacePosition( Box box, vec2 uv )\n{\n    vec2 ToUVs = uv - box.Position;\n    \n    vec2 ClampedToBoundary = min( abs(ToUVs), box.Bounds );\n    ClampedToBoundary     *= sign( ToUVs );\n    \n    return ClampedToBoundary + box.Position ;\n}\n\nvec3 CalculateLightingForAllObjects( inout Light SceneLights[TOTAL_SCENE_LIGHTS], int LightCount,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int BoxesCount)\n{\n    vec3 FinalOutput = vec3(0.0);\n    \n    for(int i = 0; i < BoxesCount; i++)\n    {\n        \n         FinalOutput += CalculateLighting( SceneLights, LightCount, SceneBoxes[i], SceneBoxes, BoxesCount );\n    }\n    \n    return FinalOutput;\n}\nvec3 CalculateLighting( inout Light SceneLights[TOTAL_SCENE_LIGHTS], int LightCount,  inout Box box,  inout Box SceneBoxes[TOTAL_SCENE_BOXES], int BoxesCount)\n{\n    vec3 FinalColor = vec3(0); \n    \n    int   AmbientLightIndex = -1;\n\n    for(int i = 0; i < LightCount; i++)\n    {\n        Light CurrentLight = SceneLights[i];\n        vec2 ToLightSource;\n        \n        float SpotLightMask = 1.0; //light mask of 1.0 (a.k.a identity mask) for other light types\n\n        if( CurrentLight.Type == POINT_LIGHT)\n        {\n            ToLightSource = normalize( CurrentLight.Position - box.SurfacePosition );\n             \n        }\n        else if(CurrentLight.Type == DIRECTIONAL_LIGHT)\n        {\n            ToLightSource = normalize(-CurrentLight.Direction);\n        }\n        else if(CurrentLight.Type == AMBIENT_LIGHT)\n        {\n            AmbientLightIndex = i;\n            continue;\n        }\n                \n        //Shadow trace\n        SceneBoxes[box.ID].bIgnoreMe = true;\n        FHitResult HitResult = RayMarch(\n            box.SurfacePosition,\n            ToLightSource,\n            SceneBoxes,\n            BoxesCount\n         );\n         SceneBoxes[box.ID].bIgnoreMe = false;\n        \n        float Distance = length(CurrentLight.Position - box.SurfacePosition);\n        \n        if( HitResult.bWasAHit && ( HitResult.Distance < Distance ) ) continue; \n        \n\t\tfloat Attenuation = 1.0 / (CurrentLight.Constant + CurrentLight.Linear * Distance + \n    \t\t    CurrentLight.Quadratic * (Distance * Distance));\n        \n        \n        //Diffuse lighting\n        float N_Dot_D                    = dot(box.Normal, ToLightSource);\n        float LightDistributionOnSurface = (max(N_Dot_D, 0.0) * CurrentLight.Intensity);\n        LightDistributionOnSurface *= Attenuation;\n        \n        FinalColor += box.Color * ( CurrentLight.Color * LightDistributionOnSurface);\n        \n    }\n    \n    if(AmbientLightIndex != -1)\n    {\n        FinalColor += box.Color * (SceneLights[AmbientLightIndex].Intensity * SceneLights[AmbientLightIndex].Color) ;\n    }\n    \n    return (FinalColor * box.EdgeMask);\n    //return (FinalColor * box.EdgeMask) + box.OutputMask * box.Color;\n}\n\n\nvoid AddBoxToScene( inout Box SceneBoxes[TOTAL_SCENE_BOXES], Box BoxToAdd,  inout int BoxesCount)\n{\n    if(BoxesCount < TOTAL_SCENE_BOXES)\n    {\n        SceneBoxes[BoxesCount]    = BoxToAdd;\n        SceneBoxes[BoxesCount].ID = BoxesCount;\n        ++BoxesCount;\n    }\n}\n\nvoid AddLightToScene( inout Light SceneLights[TOTAL_SCENE_LIGHTS], Light LightToAdd,  inout int LightsCount)\n{\n    if(LightsCount < TOTAL_SCENE_LIGHTS)\n    {\n        SceneLights[LightsCount] = LightToAdd;\n        ++LightsCount;\n    }\n}","name":"Image","description":"","type":"image"}]}