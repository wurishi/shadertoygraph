{"ver":"0.1","info":{"id":"WsySDR","date":"1573768692","viewed":1120,"name":"Simple Mandelbulb","username":"jorgemoag","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractalmandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// references:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// https://www.skytopia.com/project/fractal/mandelbulb.html\n// https://iquilezles.org/articles/ftrapsgeometric\n\n\n// antialiasing\n#define AA 2\n\nfloat hash(float p)\n{\n    return fract(sin(dot(vec2(p), vec2(12.9898, 78.233))) * 43758.5453);    \n}\n\nfloat map(in vec3 pos, out vec3 orbit_trap)\n{\n    float thres = length(pos) - 1.2;\n    if (thres > 0.2) {\n        return thres;\n    }\n    \n    // Zn <- Zn^8 + c\n    // Zn' <- 8*Zn^7 + 1    \n    const float power = 8.0;\n    vec3 z = pos;\n    vec3 c = pos;\n    \n    orbit_trap = vec3(1e20);\n    \n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < 100; ++i) {        \n        // to polar\n        r = length(z);\n        if (r > 2.0) { break; }        \n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        \n        // derivate\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        \n        // scale and rotate\n        float zr = pow(r, power);\n        theta *= power;\n        phi *= power;\n        \n        // to cartesian\n        z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));        \n        z += c;\n               \n        orbit_trap.x = min(pow(abs(z.z),0.1), orbit_trap.x);\n        orbit_trap.y = min(abs(z.x) - 0.15, orbit_trap.y);\n        orbit_trap.z = min(length(z), orbit_trap.z);\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 trash;\n\n    // Tetrahedron technique\n    // https://iquilezles.org/articles/normalsSDF\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize(\n        k.xyy * map(pos + k.xyy * h, trash) + \n        k.yyx * map(pos + k.yyx * h, trash) + \n        k.yxy * map(pos + k.yxy * h, trash) + \n        k.xxx * map(pos + k.xxx * h, trash)\n    );\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 N, float fallout)\n{\n    vec3 trash;    \n    const int nS = 12; // number of samples\n    const float max_dist = 0.07;\n    \n    float diff = 0.0;\n    for (int i = 0; i < nS; ++i)\n    {        \n        float dist = max_dist * hash(float(i)); // rand dist        \n        float s_dist = max(0.0, map(pos + dist * N, trash)); // sample\n        \n        diff += (dist - s_dist) / max_dist;\n    }\n    \n    float diff_norm = diff / float(nS);\n    float ao = 1.0 - diff_norm/fallout;\n    \n    return clamp(0.0, 1.0, ao);\n}\n\nfloat castRay(vec3 ro, vec3 rd, out vec3 trap)\n{\n    const float tmax = 200.0;\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map(pos, trap);\n        if (h < 0.0003)\n        {\n            break;\n        }\n        t += h;\n        if (t > tmax)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freq = 80.0 + iTime;\n    vec3 cam_pos = vec3(3.0 * cos(0.1 * 0.125 * freq) * sin(0.1 * 0.5*freq), sin(0.1 * freq), 2.0 * cos(0.1 * 0.5 * freq));\n    const vec3 cam_target = vec3(0);\n    \n    const float fov = 90.0 * 3.141592 / 180.0;\n    float h = 1.0; //tan(fov/2.0) * length(cam_target - cam_pos);\n    \n    vec3 cam_ww = normalize(cam_target - cam_pos);\n    \n    vec3 cam_uu = normalize(cross(vec3(0,1,0), cam_ww));\n    vec3 cam_vv = normalize(cross(cam_ww, cam_uu));\n    \n    vec3 final_col = vec3(0);\n    \n    #if AA\n    for( int m=0; m<AA; ++m )\n    for( int n=0; n<AA; ++n )\n    {\n\tvec2 o = vec2(n, m) / float(AA);\n    vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n\t#else\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    #endif\n\n\tvec3 col = mix(vec3(0.001), vec3(0.05), clamp(exp(2.0*p.y),0.0,1.0));\n\n\tvec3 ro = cam_pos;\n    vec3 rd = normalize(p.x * h * cam_uu + p.y * h * cam_vv + cam_ww - ro);\n\n    vec3 trap;\n    float t = castRay(ro, rd, trap);\n\n\t/*\n\tPalette:\n\t{[0.906, 0.929, 0.922], [0, 0.227, 0.42], [0.259, 0.765, 0.969]}\n\t{[0.373, 0.18, 0.18], [0.165, 0.125, 0.165], [0.545, 0.255, 0.212]}\n\t*/\n\n\tif (t > 0.0)\n    {           \n    \tvec3 base_col1 = mix(vec3(0.906, 0.929, 0.922), vec3(0.373, 0.18, 0.18), abs(sin(0.1*iTime)));\n        vec3 base_col2 = mix(vec3(0, 0.227, 0.42), vec3(0.165, 0.125, 0.165), abs(sin(0.1*iTime)));\n        vec3 base_col3 = mix(vec3(0.259, 0.765, 0.969), vec3(0.545, 0.255, 0.212), abs(sin(0.1*iTime)));\n\n        col = base_col1 * clamp(pow(trap.x,20.0),0.0,1.0);\n        col += base_col2 * clamp(pow(trap.y,20.0),0.0,1.0);\n        col += base_col3 * clamp(pow(trap.z,20.0),0.0,1.0);\n\n        vec3 pos = ro + t * rd;\n        vec3 N = calcNormal(pos);\n        float ao = ambientOcclusion(pos, N, 0.46);\n\n        col += 0.6 * texture(iChannel0, reflect(N, rd)).xyz;\n        col *= 0.01 + ao;        \n\t}\n    else\n    {\n    \tcol = texture(iChannel0, rd).xyz;\n\t}\n#if AA\n    final_col += col;\n    }\n    final_col /= float(AA * AA);\n#else\n    final_col = col;\n#endif        \n    \n    // RGB -> sRGB\n    final_col = pow(final_col, vec3(0.4545));\n    \n    // contrast\n    final_col = 1.1 * (final_col - 0.5) + 0.5;\n    final_col = clamp(final_col, vec3(0.0), vec3(1.0));\n    \n    fragColor = vec4(vec3(final_col),1.0);\n}","name":"Image","description":"","type":"image"}]}