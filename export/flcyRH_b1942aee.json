{"ver":"0.1","info":{"id":"flcyRH","date":"1659199526","viewed":189,"name":"20220731_perlin clap","username":"0b5vr","description":"turned out that hitting a human palm produces a perlin fbm sound","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["audio","drums"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp( x, 0.0, 1.0 )\n#define linearstep(a,b,t) saturate( ( ( t ) - ( a ) ) / ( ( b ) - ( a ) ) )\n#define smootherstep(t) ( t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 ) )\n\nconst float PI = acos( -1.0 );\nconst float TAU = 2.0 * PI;\n\nvec2 orbit( float t ) {\n    return vec2( cos( TAU * t ), sin( TAU * t ) );\n}\n\nvec2 getDir( ivec2 p ) {\n    return orbit( texelFetch( iChannel0, p & 255, 0 ).x );\n}\n\nfloat perlin2d( vec2 p ) {\n    vec2 cell = floor( p );\n    vec2 cellCoord = p - cell;\n    ivec2 cellIndex = ivec2( cell );\n\n    vec2 cellCoordS = smootherstep( cellCoord );\n    // vec2 cellCoordS = step( 0.5, cellCoord );\n    \n    return mix(\n        mix(\n            dot( getDir( cellIndex ), cellCoord ),\n            dot( getDir( cellIndex + ivec2( 1, 0 ) ), cellCoord - vec2( 1.0, 0.0 ) ),\n            cellCoordS.x\n        ),\n        mix(\n            dot( getDir( cellIndex + ivec2( 0, 1 ) ), cellCoord - vec2( 0.0, 1.0 ) ),\n            dot( getDir( cellIndex + ivec2( 1, 1 ) ), cellCoord - 1.0 ),\n            cellCoordS.x\n        ),\n        cellCoordS.y\n    );\n}\n\nfloat fbm2d( vec2 p ) {\n    return (\n        + perlin2d( 2.0 * p ) / 2.0\n        + perlin2d( 4.0 * p ) / 4.0\n        + perlin2d( 8.0 * p ) / 8.0\n        + perlin2d( 16.0 * p ) / 16.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4( 0.5 + 0.5 * fbm2d( 8.0 * uv ), 0.0, 0.0, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define saturate(x) clamp( x, 0.0, 1.0 )\n#define linearstep(a,b,t) saturate( ( ( t ) - ( a ) ) / ( ( b ) - ( a ) ) )\n#define smootherstep(t) ( t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 ) )\n\nconst float PI = acos( -1.0 );\nconst float TAU = 2.0 * PI;\n\nvec2 cis( float t ) {\n    return vec2( cos( t ), sin( t ) );\n}\n\nvec2 getDir( ivec2 p ) {\n    return cis( TAU * texelFetch( iChannel0, p & 255, 0 ).x );\n}\n\nfloat perlin2d( vec2 p ) {\n    vec2 cell = floor( p );\n    vec2 cellCoord = p - cell;\n    ivec2 cellIndex = ivec2( cell );\n\n    vec2 cellCoordS = smootherstep( cellCoord );\n    // vec2 cellCoordS = step( 0.5, cellCoord );\n    \n    return mix(\n        mix(\n            dot( getDir( cellIndex ), cellCoord ),\n            dot( getDir( cellIndex + ivec2( 1, 0 ) ), cellCoord - vec2( 1.0, 0.0 ) ),\n            cellCoordS.x\n        ),\n        mix(\n            dot( getDir( cellIndex + ivec2( 0, 1 ) ), cellCoord - vec2( 0.0, 1.0 ) ),\n            dot( getDir( cellIndex + ivec2( 1, 1 ) ), cellCoord - 1.0 ),\n            cellCoordS.x\n        ),\n        cellCoordS.y\n    );\n}\n\nfloat fbm2d( vec2 p ) {\n    return (\n        + perlin2d( 2.0 * p ) / 2.0\n        + perlin2d( 4.0 * p ) / 4.0\n        + perlin2d( 8.0 * p ) / 8.0\n        + perlin2d( 16.0 * p ) / 16.0\n    );\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float t = float( samp % int( iSampleRate ) ) / iSampleRate;\n\n    // clap envelope\n    float env = mix(\n      exp( -30.0 * t ), // long decay\n      exp( -200.0 * mod( t, 0.01 ) ), // repeating transient\n      exp( -100.0 * max( 0., t - 0.02 ) ) // mixing them\n    );\n\n    vec2 uv = 2.5 * cis( TAU * 79.0 * t ) + 50.0 * t; // noise uv\n\n    return tanh( 10.0 * env * vec2(\n      fbm2d( uv ),\n      fbm2d( uv + 0.2 ) // slightly shifting the uv for the right channel to make it stereo\n    ) );\n}\n","name":"Sound","description":"","type":"sound"}]}