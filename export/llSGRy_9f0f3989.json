{"ver":"0.1","info":{"id":"llSGRy","date":"1429876713","viewed":339,"name":"Experiment#DF3","username":"tomkh","description":"New version: [url=https://shadertoy.com/view/Xt23zG]Xt23zG[/url].\nTry TRON_MODE :), also different scenes (ln 5) with and without overlap (ln 17).\nDrag up/down to go through DF layers, DF is continuous.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Just for my own educational purposes...\n// Extended from my previous attempt: ltSGRG\n// tomkh@2015\n\n#define SCENE 2\n// Without overlap:\n//   0 = centered bboxes\n//   1 = centered decorated bboxes\n//   2 = non-centered bboxes\n//   3 = non-centered decorated\n// With overlap:\n//   0 = coins\n//   1 = pipes\n//   2 = tori\n\n// Enable to test overlap (must be less than 0.5):\n//#define OVERLAP 0.2\n\n// Enable for cool effect\n//#define TRON_MODE\n\nconst int ray_steps = 80;\nconst float dist_max = 20.0;\nconst float fog_start = 25.0;\nconst float fog_density = 0.05;\nconst float cam_dist = 30.0;\n\n// Tile space:\nconst float tile_d = 2.0;\nconst float tile_ood = 1.0/tile_d;\n\n// P-----+-----Q\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// R-----+-----S\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A,B,C,D are our tile centers.\n// We have to assume max/min height.\n// We call \"frame\", a bounding area of everything outside PQRS (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles: A,B,C,D\n//   (possibly with early-out optimization with rough distance estimation)\n//   and we bound it additionally to distance to PQRS frame.\n\nfloat dist2frame(vec3 p, float box_y)\n{\n#ifdef OVERLAP\n    vec3 dp = vec3(\n        tile_d*(1.0-OVERLAP)-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d*(1.0-OVERLAP)-abs(p.z));\n#else\n    vec3 dp = vec3(\n        tile_d-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d-abs(p.z));\n#endif\n    return length(vec2(min(dp.x,dp.z),dp.y));\n}\n\nfloat dist2box(vec3 p, float box_x, float box_y, float box_z, float box_r)\n{\n    // Distance to rounded box:\n    vec3 dp = vec3(\n        max(0.0,abs(p.x)-box_x),\n        max(0.0,abs(p.y)-box_y),\n        max(0.0,abs(p.z)-box_z));\n    return length(dp) - box_r;\n}\n\nfloat dist2pipe(vec3 p, float r, float h, float cap)\n{\n    float dxz = length(p.xz) - r;\n    float dy = max(0.0, abs(p.y) - h);\n    return length(vec2(dxz,dy)) - cap;\n}\n\nfloat dist2cyl(vec3 p, float r, float h, float cap)\n{\n    float dxz = max(0.0, length(p.xz) - r);\n    float dy = max(0.0, abs(p.y) - h);\n    return length(vec2(dxz,dy)) - cap;\n}\n\nfloat evaluate_tile(vec3 p, vec3 p_id, float dx, float dy)\n{\n    p_id.xz += vec2(dx,dy);\n    p.xz -= vec2(dx-.5,dy-.5)*tile_d;\n    float anim = iTime*.25;\n#ifdef OVERLAP\n    float p1 = sin(p_id.x+anim)*sin(p_id.z+anim*.33);\n    float r = tile_d*(.5 + OVERLAP);\n    #if SCENE == 0\n    \tfloat dist = dist2cyl(vec3(p.x,p.y-p1*.25,p.z),r-.25,.0,.25);\n    #elif SCENE == 1\n    \tfloat dist = dist2pipe(vec3(p.x,p.y-p1*2.0,p.z),r-.25,1.75,.25);\n    #else\n    \tfloat dist = dist2pipe(vec3(p.x,p.y-p1*3.75,p.z),r-.25,.0,.25);\n    #endif\n#elif SCENE >= 2\n    float p1 = 0.1 + abs(sin(p_id.x+anim)*sin(p_id.z+anim*.33))*3.9;\n    float id = p_id.x + p_id.z;\n    vec3 p2 = p + vec3(cos(id*3.0+anim*1.11),0,sin(id*3.0+anim*1.11))*.5;\n    float dist = dist2box(p2, .25, p1, .25, 0.025);\n    #if SCENE == 3\n    \tif (dist > .3) return dist - .1; // simple early-out optimziation\n    \tdist = min(dist, dist2box(p2 - vec3(0,p1*.333,0), .25, .0, .25, .1));\n        dist = min(dist, dist2box(p2 - vec3(0,p1*.666,0), .25, .0, .25, .1));\n    #endif\n#else\n    float p1 = 0.2 + abs(sin(p_id.x+anim)*sin(p_id.z+anim*.33))*3.8;\n    float p2 = 0.2 + abs(cos(p_id.x+anim*.5)*cos(p_id.z+anim*.66))*.7;\n    float dist = dist2box(p, p2, p1, p2, 0.025);\n    #if SCENE == 1\n        if (dist > .2) return dist - .1; // simple early-out optimziation\n        dist = min(dist, dist2box(p, p2+.1, p1-.1, .1, 0.025));\n        dist = min(dist, dist2box(p, .1, p1-.1, p2+.1, 0.025));\n    #endif\n#endif\n    return dist;\n}\n\nfloat get_distance(vec3 p)\n{\n    vec3 p_id = vec3(\n        floor(p.x*tile_ood),\n        0,\n        floor(p.z*tile_ood));\n    \n    p = vec3(\n        (fract(p.x*tile_ood)-.5)*tile_d,\n        p.y, //(fract(p.y*tile_ood)-.5)*tile_d,\n        (fract(p.z*tile_ood)-.5)*tile_d);\n    \n#if defined(OVERLAP) && SCENE == 0\n    float dist = dist2frame(p, .5);\n#else\n    float dist = dist2frame(p, 4.25);\n#endif\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 1.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 1.0));\n\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    const float eps = 1e-3;\n    const vec3 x_eps = vec3(eps,0,0);\n    const vec3 y_eps = vec3(0,eps,0);\n    const vec3 z_eps = vec3(0,0,eps);\n    return normalize(vec3(\n        get_distance(p + x_eps) - get_distance(p - x_eps),\n        get_distance(p + y_eps) - get_distance(p - y_eps),\n        get_distance(p + z_eps) - get_distance(p - z_eps) ));\n}\n\nvec3 trace(vec3 p_start, vec3 n)\n{\n#ifndef TRON_MODE\n    float ray_len;\n    float dist;\n    const float dist_eps = .001;\n    vec3 p = p_start;\n    for(int k=0; k<ray_steps; ++k) {\n    \tdist = get_distance(p);\n        if (dist < dist_eps || dist > dist_max) break;\n        p += dist*n;\n        ray_len += dist;\n    }\n    \n    //vec3 light_dir = normalize(vec3(.1,1.0,-.3));\n    float light_ang = iMouse.x/iResolution.x*3.0;\n    vec3 light_dir = normalize(vec3(cos(light_ang),2.0,-sin(light_ang)));\n    vec3 normal = get_normal(p);\n    float shade = 0.0;\n    if (dist < dist_eps) {\n        //shade = (1.0 - dist/dist_eps)*dot(normal, light_dir);\n        shade = dot(normal, light_dir);\n        shade = max(0.0, shade);\n    }\n    \n    vec3 base_color = vec3(1.0,1.0,1.0);\n    vec3 color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),shade)*base_color;\n    \n    // Test ray with cut_plane:\n    float cut_plane = (iMouse.y / iResolution.y - 0.1) * 8.0;\n    cut_plane = max(0.0, cut_plane);\n    if (p_start.y > cut_plane) {\n        float d = (p_start.y - cut_plane) / -n.y;\n        if (d < ray_len) {\n            vec3 hit = p_start + n*d;\n            float hit_dist = get_distance(hit);\n            float iso = fract(hit_dist*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n            //dist_color = min(vec3(1.0,1.0,1.0),dist_color);\n            color = mix(color,dist_color,.5);\n            ray_len = d;\n        }\n    }\n    vec3 fog_color = vec3(.8,.8,.8);\n    float fog = 1.0-1.0/exp(max(0.0,ray_len-fog_start)*fog_density);\n    color = mix(color,fog_color,fog);\n#else\n    vec3 color = vec3(0.,.1,.3);\n   \n    for(float cut_plane = 4.0; cut_plane >= 0.0; cut_plane -= 0.1) {\n        // Test ray with cut_plane:\n        if (p_start.y > cut_plane) {\n            float d = (p_start.y - cut_plane) / -n.y;\n            vec3 hit = p_start + n*d;\n            float hit_dist = get_distance(hit);\n            float iso = fract(hit_dist*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            dist_color *= 1.0/(max(0.0,hit_dist)+.05);\n            color += dist_color*.02*cut_plane*.25;\n        }\n    }\n#endif\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = -0.2; //iMouse.x / iResolution.x * 2.0 - 1.0; \n    a += cos(anim)*.05;\n    float co = cos(a);\n    float si = sin(a);\n    vec3 p1 = vec3(-cam_dist*si, 0, -cam_dist*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //a = iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2 - 2.0;\n    a = -.4;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n    fragColor = vec4(trace(p2, n3), 1.0);\n    \n}","name":"","description":"","type":"image"}]}