{"ver":"0.1","info":{"id":"Msc3Wn","date":"1448912970","viewed":163,"name":"Problem of Apollonius","username":"jt","description":"The Problem of Apollonius. Click mouse to position circle. A circle enclosing all circles is computed.\n[url]https://en.wikipedia.org/wiki/Problem_of_Apollonius[/url]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circle","apolloniussproblem","problemofapollonius","apollonius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Problem of Apollonius - 2015 by JT\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (see https://en.wikipedia.org/wiki/Problem_of_Apollonius)\n\nfloat perpdot(vec2 a, vec2 b) // name as suggested by ollj\n{\n    //return a.x * b.y - a.y * b.x;\n    return dot(vec2(-a.y,a.x), b);\n}\n\nvec3 ApoloniusCircle(vec2 a, vec2 b, vec2 c, float r, float s, float t, bool flag)\n{\n    float rr = r * r;\n    float ss = s * s;\n    float tt = t * t;\n    float aa = dot(a, a);\n    float bb = dot(b, b);\n    float cc = dot(c, c);\n\n    vec4 u;\n    u.xy = 2. * (a - b);\n    u.z = 2. * (r - s);\n    u.w = (aa - bb) - (rr - ss);\n\n    vec4 v;\n    v.xy = 2. * (a - c);\n    v.z = 2. * (r - t);\n    v.w = (aa - cc) - (rr - tt);\n\n    vec2 p = u.xy * v.z - v.xy * u.z;\n    vec2 q = u.xy * v.w - v.xy * u.w;\n\n    float f = perpdot(v.xy, u.xy);\n    float ff = f * f;\n\n    vec3 w = 2. * vec3(\n    \t(dot(p, p) - ff),\n    \t(dot(p, q) + f * perpdot(p, a) + ff * r),\n    \tf * perpdot(q, a) + .5 * (ff * aa + dot(q, q) - ff * rr));\n\n    vec2 res = (-w.y + vec2(1,-1) * sqrt(w.y * w.y - 2. * w.x * w.z)) / w.x;\n\n    vec3 result;\n    result.z = flag ? res.x : res.y;\n    result.yx = (result.z * p + q) / vec2(-f, f);\n    return result;\n}\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\n#define draw(q) O *= smoothstep(0.0, 0.01, abs(q))\n#define draw_(q, C) O = mix(C, O, vec4(smoothstep(0.0, 0.01, abs(q))))\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\tvec2 R = iResolution.xy; \n    I = (I+I-R)/R.y;\n    vec2 m = (2.*iMouse.xy-R)/R.y;\n \n    vec2 a = vec2(-.5,.2);\n    float r = .5;\n    vec2 b = all(equal(iMouse.xy, vec2(0))) ? mirror(vec2(.95,-.6)*iTime*.1) : m;\n    float s = .7;\n    vec2 c = vec2(-.35,-.6);\n    float t = .3;\n    vec3 d = ApoloniusCircle(a, b, c, r, s, t, false);\n    vec3 e = ApoloniusCircle(a, b, c, r, s, t, true);\n    O = vec4(1);\n\tdraw(length(I - a) - r); // circle\n\tdraw(length(I - b) - s); // circle\n    draw(length(I - c) - t); // circle\n    if(d.z == d.z) // protect against NaN\n        draw(length(I - d.xy) - d.z); // circle\n    if(e.z == e.z) // protect against NaN\n        draw(length(I - e.xy) - e.z); // circle\n}","name":"Image","description":"","type":"image"}]}