{"ver":"0.1","info":{"id":"MsKGWz","date":"1487752997","viewed":1039,"name":"WebGL Random Noise","username":"MichaelPohoreski","description":"Split screen comparison of various random functions\n\nAlso see: https://www.shadertoy.com/view/XtX3D4","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWebGL Random - https://www.shadertoy.com/view/MsKGWz\nCopyleft {c} 2016 Michael Pohoreski\n\nDISCLAIMER:\n\n    You are free to use this code as you wish.\n\n    However, if you are going to copy/paste snippets of this code\n    on StackOverflow, StackExchange, Reddit, etc.\n    Please provide a link back to the original source\n    so that people can find updates and bugfixes.\n    Thanks!\n\nAlso see:\n  WebGL Noise - https://www.shadertoy.com/view/XtX3D4\n  http://stackoverflow.com/questions/18790215/why-does-webgl-noise-not-give-random-values\n\nNum Type Summary\n 0  1D   One dimension fract( mod( 12345678., 256. * x) )\n 1  2D   Version 1 fract( cos( mod( 12345678., 256. * dot( p, vec2( e^pi, 2^sqrt(2) ) ) ) ) )\n 2  2D   Version 2 fract( cos( dot( p, dot( p, vec2( e^pi, 2^sqrt(2) ) ) ) ) * 123456. )\n 3  2D   snoise    fract( sin( dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 )\n 4  1D   Sony PS3 random = 4\n 5  1D   iqhash    fract(sin(x)*43758.5453);\n11  1D   hash11    fract(sin(x * 727.1)*43758.5453123)\n12  2D   hash12    fract(sin( dot(p,vec2(127.1,311.7))*43758.5453123)\n*/\n#define LEFT  2\n#define RIGHT 3\n\nfloat random_linear( vec2 p )\n{\n//    return fract( p.x );\n    return fract( 256. * p.x );\n//    return      ( mod( 12345678., 256. * p.x) );\n//    return fract( mod( 12345678., 256. * p.x) );\n//    return fract( mod( 12345678., 256. * dot(p.x,p.y) ) );\n}\n\n// Random 1\n// My own random number generator\n// See Stack Overflow: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader/10625698#10625698\nfloat random_1( vec2 p )\n{\n    vec2 r = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( mod( 12345678., 256. * dot(p,r) ) ) );\n}\n\n// Removed the mod operator\n// Original \n//float random( vec2 p )\n//{\n//    // 23.140... e^pi (Gelfond's constant)\n//    //  2.665... 2^sqrt(2) (Gelfondâ€“Schneider constant)\n//    vec2 r = vec2( 23.14069263277926, 2.665144142690225 );\n//    return fract( cos( dot( p, r ) ) * 123456. );\n//}\n// Minified:\nfloat random_2(vec2 p){return fract(cos(dot(p,vec2(23.14069263277926,2.665144142690225)))*123456.);}\n\n\n//http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat snoise(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat random_sony( vec2 p )\n{\n    return mod( p.x, 4.0 );\n}\n\n\n// Noise 1 -- This is apparently from https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n// Noise 2 - \"Wet stone\" - https://www.shadertoy.com/view/ldSSzV\n    float hash11(float p) {\n        return fract(sin(p * 727.1)*43758.5453123);\n    }\n    float hash12(vec2 p) {\n        float h = dot(p,vec2(127.1,311.7));\t\n        return fract(sin(h)*43758.5453123);\n    }\n\n    vec3 hash31(float p) {\n        vec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n        return fract(sin(h)*43758.543123);\n    }\n\n    // Custom shim to call hash31\n    float hash13(vec2 p) {\n        vec3 q = hash31(p.x);\n        return q.x;\n    }\n    \n\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// hash based 3d value noise\n// function taken from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ported from GLSL to HLSL\n// Also see:  https://www.shadertoy.com/view/4sfGzS\nfloat iqhash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// Not the real function, stripped down to 1D\nfloat iqnoise_3( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    return f.x;\n}\n\n// Not the real function, stripped down to 1D\nfloat ipnoise_3a(vec3 p)\n{\n    vec3 P = mod(floor(p), 256.0);\n         p = fract(p);\n\n    return p.x;\n}\n\nfloat ipnoise_3b(vec3 p)\n{\n    vec3 P  = mod(floor(p), 256.0);\n         p -= floor(p);\n         p = fract(p);\n    return p.x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  p  = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float th = (-iResolution.x + 2.0*iMouse.x) / iResolution.y;\n    if( iMouse.z < 0.01 ) th = 0.5/ iResolution.y;\n\n    vec3  q  = vec3( p.x, p.y, 0.0);\t\n    vec3  r  = vec3( fragCoord.x, fragCoord.y, 0.0 ) * iResolution;\n    \n\n    float noise = // left val\n#if LEFT == 0\n                  random_linear( p );\n#elif LEFT == 1\n                  random_1( p );\n#elif LEFT == 2\n                  random_2( p );\n#elif LEFT == 3\n                  snoise( p );\n#elif LEFT == 4\n                  random_sony( p );\n#elif LEFT == 5\n                  iqhash( p.x );\n#elif LEFT == 6\n                  iqnoise_3( q );\n#elif LEFT == 7\n                  ipnoise_3a( q );\n#elif RIGHT == 8\n                  ipnoise_3b( q );\n#elif LEFT == 11\n                  hash11( p.x );\n#elif LEFT == 12\n                  hash12( p );\n#elif LEFT == 13\n                  hash13( p );\n#else\n                  -fract( p.x ); // color code red\n#endif\n\n    \n    float right = \n#if RIGHT == 0\n                  random_linear( p );\n#elif RIGHT == 1\n                  random_1( p );\n#elif RIGHT == 2\n                  random_2( p );\n#elif RIGHT == 3\n                  snoise( p );\n#elif RIGHT == 4\n                  random_sony( p );\n#elif RIGHT == 5\n                  iqhash( p.x );\n#elif RIGHT == 6\n                  iqnoise_3( q );\n#elif RIGHT == 7\n                  ipnoise_3a( q );\n#elif RIGHT == 8\n                  ipnoise_3b( q );\n#elif RIGHT == 11\n                  hash11( p.x );\n#elif RIGHT == 12\n                  hash12( p );\n#elif RIGHT == 13\n                  hash13( p );\n#else\n                  -fract( p.y ); // Color code red\n#endif\n    \n    // Thanks to I.Q. for this interactive split screen!\n    // https://www.shadertoy.com/view/MdjGR1\n    if( p.x > th )\n        noise = right;\n\n    vec3 color = vec3(noise, noise, noise );\n    if( noise < 0. ) // color code undefined values as red gradient\n        color.xyz *= vec3( -1., 0., 0. );\n\n    color *= smoothstep( 0.006, 0.008, abs(p.x-th) ); // black bar to \"split\" the screen\n\tfragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}