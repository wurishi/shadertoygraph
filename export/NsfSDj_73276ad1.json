{"ver":"0.1","info":{"id":"NsfSDj","date":"1619210734","viewed":237,"name":"Euclidean Melodies","username":"metabog","description":"Using the euclidean rhythms formula to generate some programmatic melodies.\nsee: https://twitter.com/boggodan/status/1277738002270298112","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["sound","music","euclideanbeats","generativemusic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n\n    float stp = floor(uv.x*16.0);\n    \n    float on = 0.0;\n    \n    if(uv.y<0.33)\n    {\n        on = euclidean(stp, getWangSteps(iTime+16.33),16.0);\n        col = vec3(0.2,0.5,0.9);\n    }\n    if(uv.y >= 0.33 && uv.y<0.66)\n     {\n        on = euclidean(stp, getWangSteps(iTime+25.5),16.0);\n        col = vec3(0.5,0.9,0.3);\n    }\n    if(uv.y>=0.66)\n    {\n        on = euclidean(stp, getWangSteps(iTime),16.0);\n        col = vec3(0.7,0.34,0.49);\n    }\n\n    float playhead = mod(iTime*tempo_mult,16.0)/16.0;\n    \n    float muchness = 1.0 - clamp((playhead*16.0-stp),0.0,1.0);\n    \n    if(playhead*16.0>stp)\n        col = mix(col,vec3(1.0),muchness);\n        \n    fragColor = vec4(col,1.0)*on;\n    \n    if(abs(uv.x - playhead)<0.001)\n       fragColor += vec4(1.0);\n    \n    fragColor += vec4(0.1,0.11,0.09,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float ftom(float note)\n{\n    return 440.0 * pow(2.0,((note-12.0)/12.0));\n}\n\n//lol, there has to be a nice shadery solution\nfloat mapPenta(int note)\n{\n    switch(note)\n    {\n        case 0: return 0.0;\n        case 1: return 2.0;\n        case 2: return 5.0;\n        case 3: return 7.0;\n        case 4: return 10.0;\n        case 5: return 12.0;\n        default: return 0.0;\n    }\n}\n\nvec2 boop(float time, float freq, float ph)\n{\n    return vec2( sin(6.2831*freq*mod(time,16.0))*exp(-3.0*ph) );\n}\n\nfloat getEuclideanSine(float time, float beats, float steps)\n{\n    float stp = floor(mod((time*tempo_mult),steps));\n    float on = euclidean(stp,beats,steps);\n    \n    float freq = ftom(mapPenta(int(beats)%6));\n    float octave = mod(getWangSteps(beats)-1.0,3.0); //haxor\n    octave = pow(2.0,octave);\n    return on*float(boop(time, freq*octave, mod(time*tempo_mult,1.0f)))*0.15;\n}\n\nfloat getSines(float time)\n{\n    return \n    getEuclideanSine(time, getWangSteps(time),16.0f) +\n    getEuclideanSine(time, getWangSteps(time+25.5),16.0f) +\n    getEuclideanSine(time, getWangSteps(time+16.33),16.0f);\n}\n\nconst int DELAY_TAPS = 4;\n\n//sound + sound from a while ago x DELAY_TAPS\nvec2 getWithFX(float time)\n{\n    vec2 outp = vec2(0.0);\n    for(int i =0; i<DELAY_TAPS; i++)\n    {\n        //stereo delay by simulating entire output back DELAY_TAPS times lol\n        outp += \n        vec2(getSines(time - 2.5f * float(i))/float(i*3+1),\n        getSines(time - 3.0f * float(i))/float(i*3+1));\n    }\n    \n    return outp;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    return getWithFX(time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"const float tempo_mult = 5.0;\n\n//euclidean beats formula, from\n//https://twitter.com/mmalex/status/1177617079119286272\n\nfloat euclidean(float i, float beats, float steps)\n{\n    return floor(i*beats/steps)!=floor((i-1.0)*beats/steps)?1.0:0.0;\n}\n\nfloat wang(uint u)\n{\n    uint seed = (u*1664525u);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return mod(value,1.0);\n}\n\nfloat getWangSteps(float iTime)\n{\n    return floor(wang(uint(iTime*0.25))*10.0)+2.0;\n}","name":"Common","description":"","type":"common"}]}