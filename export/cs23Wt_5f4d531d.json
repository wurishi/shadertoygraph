{"ver":"0.1","info":{"id":"cs23Wt","date":"1673908512","viewed":113,"name":"sinx + cosy - k = 0","username":"Envy24","description":"Nothing to write here.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["template","plotter","graphs"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define SCENE_SCALE               ( 30.0 )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 3.0*SCENE_SCALE / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(grad.x*grad.x + grad.y*grad.y)); }\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat implicit(float x, float y) { return sin(x-1.57)+cos(y); }\nfloat delf_delx(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( implicit(x+dx, y)-implicit(x-dx, y) ) / (2.*dx);\n    /* Analytic derivative. */\n    //return 6.*x*y*y - 5.; \n    return cos(x);\n}\nfloat delf_dely(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( implicit(x, y+dy)-implicit(x, y-dy) ) / (2.*dy);\n    /* Analytic derivative. */\n    //return 6.*x*x*y + cos(y) - 3.;\n    return 2.*y;\n}\nvec2 gradient(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\n\nfloat implicit2(float x, float y) { return sin(x-1.57)+cos(y) + sin(iTime)*2.; }\nfloat delf_delx2(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( implicit2(x+dx, y)-implicit2(x-dx, y) ) / (2.*dx);\n    /* Analytic derivative. */\n    //return 6.*x*y*y - 5.; \n    return cos(x);\n}\nfloat delf_dely2(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( implicit2(x, y+dy)-implicit2(x, y-dy) ) / (2.*dy);\n    /* Analytic derivative. */\n    //return 6.*x*x*y + cos(y) - 3.;\n    return 2.*y;\n}\nvec2 gradient2(float x, float y) { return vec2(delf_delx2(x, y), delf_dely2(x, y)); }   \n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    /* Implicit function f(x,y) */\n        color = mix(color, vec3(1,0,0), draw_implicit_func(NDC, implicit(NDC.x, NDC.y), gradient(NDC.x, NDC.y)));\n        color = mix(color, vec3(0,0,1), draw_implicit_func(NDC, implicit2(NDC.x, NDC.y), gradient2(NDC.x, NDC.y)));\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}