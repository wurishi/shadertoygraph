{"ver":"0.1","info":{"id":"DtfBRS","date":"1693064597","viewed":65,"name":"dna scheme","username":"Efim","description":"dna scheme","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","dna"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\n\nfloat aafi(vec2 p)\n{\n    float l = length(p);\n    float fi = asin(abs(p.y)/l);\n    float pst = step(0.0, p.y)*step(p.x, 0.0);\n    fi = fi + pst*(PI - 2.0*fi);\n    pst = step(p.y, 0.0)*step(p.x, 0.0);\n    fi = fi + pst*PI;\n    pst = step(p.y, 0.0)*step(0.0, p.x);\n    fi = fi + pst*(2.0*PI - 2.0*fi);\n    return fi;    \n}\n\n//converts a vector on a sphere to longitude and latitude\nvec2 lonlat (vec3 p)\n{\n    float lon = aafi(p.xy)/2.0/PI;\n    float lat = aafi(vec2(p.z, length(p.xy)))/PI;\n    return vec2(1.0-lon, lat);\n}\n\nconst float dist_infin = 100000.0;\nconst HIT hit_inf = HIT(100000.0, vec3(0.0), vec3(0.0));\n\nconst float v = 0.35;\n\nvec3 calcSkyReflect(vec3 rd, vec3 nor, mat3 sky)\n{\n    vec3 n = nor;\n    float d = dot(rd, nor);\n    n = nor*sign(d);\n    vec3 r = reflect(rd, n);\n    //vec2 fon = lonlat(sky*r); //get longitude and latitude\n    vec3 col = texture(iChannel0, r).rgb;\n    return col;\n\n}\n\nvec3 culccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu = dot(nor, light);\n    col *= clamp(difu, 0.1, 1.0);\n    return col;   \n}\nHIT giperI(vec3 ro, vec3 rd, float h, float t)\n{\n    \n    if (t > 0.0)\n        return hit_inf;\n    float dist = dist_infin;\n    vec3 nor = vec3(0.0);\n    vec3 pos = ro + rd*t;\n    \n    if (abs(pos.z) > h)\n        return hit_inf;\n    \n    \n    float f = (pos.z)*v;\n    float d = dot(normalize(vec2(pos.x, pos.y)), vec2(cos(f), sin(f)));    \n    if (d > 0.98)\n        dist = length(ro - pos);\n\n    f = (pos.z)*v + PI;\n    d = dot(normalize(vec2(pos.x, pos.y)), vec2(cos(f), sin(f)));    \n    if (d > 0.98)\n        dist = length(ro - pos);    \n    \n    if (dist < dist_infin)\n    {\n        nor = vec3(pos.x, pos.y, 0.0);\n        nor = normalize(nor);\n    }\n    return HIT(dist, nor, pos);\n}\n\nHIT giper3D(vec3 ro, vec3 rd, float h, float ra)\n{\n    float a = rd.x*rd.x + rd.y*rd.y;\n    float b = 2.0 * (ro.x*rd.x + ro.y*rd.y);\n    float c = ro.x*ro.x + ro.y*ro.y - ra*ra;\n    float d = b*b - 4.0*a*c;\n    if (d < 0.0)\n        return hit_inf;\n\n    \n    d = pow(d, 0.5);\n    float t1 = (-b + d)/2.0/a;\n    float t2 = (-b - d)/2.0/a;\n\n    HIT r = hit_inf;\n    HIT r1 = giperI(ro, rd,   h,  t1);\n    if (r1.dist < r.dist)\n        r = r1;\n    \n    HIT r2 = giperI(ro, rd,    h,  t2);\n    if (r2.dist < r.dist)\n        r = r2;\n\n    return r;\n}\n\nHIT planeY(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    vec3 pos = vec3(0.0);\n\n    float t = -(ro.y)/rd.y;\n    if (t >= 0.0)\n\t\treturn hit_inf;\n\n    pos = ro + rd*t;\n    float dist = length(pos - ro);\n    return HIT(dist, vec3(0.0, 1.0, 0.0), pos);      \n}\n\n\nHIT planeW(vec3 ro, vec3 rd, float ra, float h)\n{\n    float f = h*v;\n    vec3 ro1 = rotateZ(f)*ro;\n    vec3 rd1 = rotateZ(f)*rd;\n    HIT plane = planeY(ro1, rd1);\n    if (plane.pos.z > h + ra*0.05 || plane.pos.z < h - ra*0.05 || abs(plane.pos.x) > ra || abs(plane.pos.x) < ra*0.05 )\n        return hit_inf;\n    plane.nor = rotateZ(-f)*plane.nor;    \n    return plane;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 light = normalize(vec3(2.0, 1.0, -1.0)); //light\n\n\tvec3 ro = vec3(0.0, 0.0, 25.0); // camera\t\n    const float fl = 2.5; // focal length\n\n    vec3 rd = normalize( vec3(p,fl) ); // ray direction\n    float t = iTime;\n\t//t = 3.0;\n\n    vec3 col = vec3(0.7, 0.7, 0.9); // background\n    vec3 backcol = col;\n    vec3 nor = vec3(0.0);\n    \n    float dist = dist_infin;\n    mat3 rota  =   rotateZ(t)*rotateX(PI/2.0);\n    mat3 rota_1  = rotateX(-PI/2.0)*rotateZ(-t);\n    mat3 sky = rotateZ(0.0)*rotateX(PI/2.0);\n\n    vec3 pos = vec3(0.0);\n    vec3 col1 = vec3(1.0, 0.5, 0.5);\n    vec3 col2 =  vec3(0.5, 0.5, 1.0);\n\n    float ra = 4.0;\n    float h = 12.0;\n    #define nn 17.0\n    HIT giper = giper3D(rota*(ro), rota*rd, h, ra);\n    if (giper.dist < dist)\n    {\n        \n        dist = giper.dist;\n        nor = rota_1*giper.nor;\n        \n        col = vec3(1.0, 1.0, 0.0);\n        backcol = vec3(0.0, 1.0, 1.0);\n        col = culccolor(col, backcol, rd, light, nor);\n        // gamma\n        col = pow( col, vec3(0.4545) ); \n    }\n    float dist2 = dist;\n    \n    for (float i = 0.0; i <= nn; i++)\n    {\n        float hh = (i - nn/2.0)/nn*2.0*h;\n        HIT plane = planeW(rota*(ro), rota*rd, ra, hh);\n        if (plane.dist < dist2)\n        {\n            dist2 = plane.dist;\n            pos = plane.pos;\n            nor = rota_1*plane.nor;\n\n            col1 = vec3(1.0, 0.2, 0.2);\n            col2 =  vec3(0.2, 0.2, 1.0);\n            \n            if (mod(i, 3.0) < 1.0)    \n            {\n                col1 = vec3(0.5, 0.5, 0.5);\n                col2 = vec3(0.2, 1.0, 0.2);\n            }\n\n            if (mod(i, 4.0) < 1.0)    \n            {\n                col1 = vec3(1.0, 0.2, 0.2);\n                col2 = vec3(0.2, 1.0, 0.2);\n            }\n            \n            \n        }\n    }\n\n    if (dist2 < dist)\n    {\n        dist = dist2;\n        col = col1;\n        if (pos.x < 0.0)\n            col = col2;\n        \n        backcol = col;\n        col = culccolor(col, backcol, rd, light, nor);\n        col = pow( col, vec3(0.4545) );     \n        \n    }\n\n    // if (dist < dist_infin)\n    // {\n    //     col1 = calcSkyReflect(rd, nor, sky);\n    //     col = mix(col, col1, 0.5);\n    // }\n   \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}