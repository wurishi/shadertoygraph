{"ver":"0.1","info":{"id":"tdy3zV","date":"1570574563","viewed":175,"name":"Distortion spheres ;)","username":"MeleeCampz","description":"Lots of distorting spheres ;)\nStill a bit buggy in terms of distrubution and a lot of headroom for performance","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["refraction","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct CircleData\n{\n    vec2 uv;\n    float number;\n    float cr;\n    float distScale;\n    float offsetScale;\n    float time;\n    float speed;\n    vec2 idOff;\n};\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//rotate incoming vector\nvec2 rot(vec2 inVec, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        inVec.x * c - inVec.y * s,\n        inVec.x * s + inVec.y * c);\n}\n\n\n//Vec3 x,y = offset; z = mask\nvec3 circleUV(vec2 uv, vec2 offset, float radius)\n{\n    vec2 off = (uv - offset);\n  \tfloat mask = step(-radius, -length(off));\n    vec2 cv =  off/radius;\n    vec2 maskedOff = cv * mask;\n    \n    return vec3(maskedOff, mask);\n}\n\n//smooth 2dnoise based on textures that moves with time\nvec2 smNoiseOff(vec2 uv, vec2 scale, float str)\n{\n    return texture(iChannel2, uv * scale + iTime * 0.1).xy * str;\n}\n\n//Return uv offset + mask of circle\nvec3 GetCircleOffset(vec2 uv, vec2 center, float radius)\n{\n    vec3 circle = circleUV(uv, center, radius);\n    vec2 cv = circle.xy;\n    float cm =circle.z;\n    \n    vec2 cvOff = pow(cv,vec2(3.)) * 2.;\n    cvOff += smNoiseOff(uv, vec2(2.), .5) * cm;\n    \n    return vec3(cvOff, cm);\n}\n\n//Generates a custer of circles\nvec3 multiCircleOffset(CircleData data)\n{\n    vec3 off = vec3(0);\n    \n    for(float y=-data.number; y<= data.number; y++)    \n    {\n     \tfor(float x=-data.number; x<= data.number; x++)    \n    \t{            \n            vec2 pos = vec2(x,y);\n          \tpos += data.idOff;// <----- id randomizer\n            \n            vec2 offCenter = vec2(hash21(pos.xy)-1.,hash21(pos.yx)-1.)* data.offsetScale;\n            offCenter += .5;\n            \n            vec2 offTime = vec2(data.time * data.speed + sin(data.time * data.speed * .5) * 0.2) * (offCenter*0.5);\n            float crOff = (sin(offTime.x)*.5+.5) * data.cr;\n            \n            vec2 cc = vec2(sin(offTime.x), cos(offTime.y)) * data.distScale + offCenter;\n            off += GetCircleOffset(data.uv, cc, data.cr + crOff);\n        }\n    } \n    \n    return off;\n}\n\n//Samples neighbour cells to allow for overlaps\n//Expensive but easy to implement\nvec3 multiCircleOffsetMultiCell(CircleData data, int range)\n{\n    CircleData cpy = data;\n    vec3 avg = vec3(0);\n    for(int y = -range; y <= range; y++)\n    {\n        for(int x = -range; x <= range; x++)\n        {\n            vec2 idlocal = vec2(1);\n            idlocal *= vec2(x,y);\n            \n            cpy.uv = data.uv + idlocal * 2.;\n            cpy.idOff = data.idOff - idlocal;\n            \n            avg += multiCircleOffset(cpy);\n        }\n    }\n    return avg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy)/ iResolution.y;\n    vec3 col = vec3(0.);    \n        \n    //Dynamic zoom\n    vec2 uvm = uv * 3.;\n    uvm *=  sin(iTime * 0.25) * 0.3 + 1.;\n    \n    //Rotate bg\n    uv = rot(uv, iTime * 0.1);\n    \n    //Dynamic pan\n    float panTime = iTime * 0.1;\n    float panScale = 0.1;\n    uv += vec2(sin(panTime),cos(panTime)* panScale);\n        \n    //Gridify cells\n    float gridCells = 2.; //Bug here!! why is only two working for this O_o?\n    vec2 gv = fract(uvm )* gridCells - vec2(gridCells * 0.5);\n    vec2 id = floor(uvm);\n   \n    \n    //Modulate circle radius with time and music\n    float musicMod = texture(iChannel1, vec2(0.,-.5)).x * 0.1;\n    float cr = sin(iTime) * 0.01 + (0.3 +  musicMod);    \n    cr *= 0.3;\n    \n    //Circle params <----- Circle Cluster Config!\n    float speed = 2.6;\n    float time = iTime + 1000.;\n    float number = 2.;\n    float distScale = 1.8 + sin(iTime * 0.3)*.5-.5;\n    float offsetScale = 1.5;\n    int range = 1;\n    CircleData data = CircleData(gv, number, cr, distScale, offsetScale,time, speed, id); \n    \n    //Get circle uv distortion\n    vec3 circleOff = multiCircleOffsetMultiCell(data, range) * 0.05;\n    vec2 uvRef = uv +circleOff.xy;\n    \n    //Sample bg with offset\n  \tcol += texture(iChannel0, uvRef).xxx;\n    //Enhance circle to background contrast\n    col *= 0.3 + circleOff.z * 3.0;\n    //USe mask to color only bubbles\n    col += vec3(circleOff.z,0,sin(iTime*0.1) * circleOff.z) * 0.5;\n    \n    //Debug grid\n    float gridWidth = 0.01;\n  \t//col += vec3(1.,.0,.0) * max(step(1.- gridWidth, gv.x), step(1.- gridWidth, gv.y));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}