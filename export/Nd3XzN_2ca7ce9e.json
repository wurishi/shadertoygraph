{"ver":"0.1","info":{"id":"Nd3XzN","date":"1632735381","viewed":67,"name":"Extended Bianchi 31","username":"DrHow","description":"2D packings arising from the extended Bianchi group Bi(31).\nThe Coxeter diagram of Bi(31) is given in the paper https://arxiv.org/abs/1210.2759\nIt should be possible to modify the angles, but the computation is too heavy and I'm lazy.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","circlepacking"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Disclaimer:\nI know nothing about lighting and coloring (I'm colorblind).\nI copied the visual effect from Zhao Liang (twitter @neozhaoliang).\nAnd I count on the community to make these things nicer.\n*/\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n    return DE(p, index) * strong_factor;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    init();\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / iResolution.y;\n    \n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n    float hue = fract(0.25*l) + .45;\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf              -1.\n#define MAX_ITER         50\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define L2XY(x, y)       dot(x - y, x - y)\n#define ZOOM             1.\n\nbvec2 displayRealBalls = bvec2(1, 1);\n\n\nconst float s2 = 1.41421356; // sqrt(2)\nconst float s3 = 1.73205081; // sqrt(3)\nconst float s31 = 5.56776436283; // sqrt(31)\n\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec2 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[2] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[2] clusters;\n\nvec2 T1 = vec2(s31/4., -1./4.);\nvec2 T2 = vec2(-s31/4., 9./4.);\n\n\nBall defaultBall() {\n    return Ball(false, vec2(0, 0), 1., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.n) - B.r;\n        return k;\n    }\n}\n\nBall from_plane(vec2 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\n\nvec2 translate(inout vec2 p,vec2 t1,vec2 t2) {\n    p += (t1+t2)/2.;\n    mat2 m = mat2(t1.x, t2.x, t1.y, t2.y);\n    vec2 pp = fract(p * inverse(m));\n    p = pp.x * t1 + pp.y * t2 - (t1+t2)/2.;\n    return pp;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec2 cen = B.n;\n        float r = B.r;\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n \n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec2 p, inout int index) {\n    Ball Bxy;\n    vec2 pp;\n\n    float scale = .1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        \n        pp = translate(p, T1, T2);\n        Bxy = coclusters[0];\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        pp = translate(p, T1, T2);\n        Bxy.n += (pp.x < pp.y) ? T2:T1;\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        pp = translate(p, T1, T2);\n        Bxy.n = coclusters[0].n + T1 + T2;\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        pp = translate(p, T1, T2);\n        Bxy = coclusters[1];\n        if (pp.x > pp.y) Bxy.n += T1;\n        cond = cond && try_reflect(p, Bxy, scale);\n\n        if (cond)\n            break;\n    }\n    \n    index = 0;\n\n    //float d1 = sdistanceToBall(p, clusters[0]);\n    //float d2 = sdistanceToBall(p, clusters[1]);\n    //d1 = abs(d1); d2 = abs(d2);\n    pp = translate(p, T1, T2);\n    index = pp.x < pp.y ? 1:0;\n    Bxy = clusters[index];\n    float d = sdistanceToBall(p, Bxy);\n    d=abs(d);\n    return d / scale;\n}\n\n\n\nvoid init() {   \n    Ball B0 = from_sphere(vec2(0, -1), 1.);\n    Ball B1 = from_sphere(vec2(-s31/8., 1./8.), 0.5);\n    invertBall(B0);\n    invertBall(B1);\n    coclusters = Ball[2] (B0, B1);\n    \n    clusters[0] = from_sphere(vec2(1./s31, 0.), 1./s31);\n    clusters[1] = from_sphere(vec2(-1./s31, 0.), 1./s31);\n}\n","name":"Common","description":"","type":"common"}]}