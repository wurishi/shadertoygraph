{"ver":"0.1","info":{"id":"McdSzs","date":"1714348282","viewed":37,"name":"Road to freecam","username":"Chama_lo","description":"Moove around with arrow and mouse around this triangles.\n\nBig aberration when you look back\n","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["triangleintersectionkeyboardmouse"],"hasliked":0,"parentid":"4ctSRl","parentname":"Keyboard -><- mouse movements"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUFFER_STATE iChannel0\n\n//Parameter\n// Define an array of triangles\nconst int numTriangles = 10; // Set the number of triangles\n\n\n// Define the structure for a triangle\nstruct Triangle {\n    vec3 V1;\n    vec3 V2;\n    vec3 V3;\n};\n\n\n\nTriangle[numTriangles] createCube() {\n    Triangle triangles[numTriangles];\n    \n   \n    triangles[0].V1 = vec3(0.0, 0.0, 11.0);\n    triangles[0].V2 = vec3(0.0, 1.0, 10.0);\n    triangles[0].V3 = vec3(-1.0,0.0, 10.0);\n\n    triangles[2].V1 = vec3(0.0, 0.0, 11.0);\n    triangles[2].V2 = vec3(0.0, 1.0, 10.0);\n    triangles[2].V3 = vec3(1.0, 0.0, 10.0);\n\n    \n    triangles[1].V1 = vec3(2.0, 0.0, 40.0);\n    triangles[1].V2 = vec3(2.0, 1.0, 10.0);\n    triangles[1].V3 = vec3(1.0, 0.0, 10.0);\n\n\n    triangles[3].V1 = vec3(2.0, 0.0, 40.0);\n    triangles[3].V2 = vec3(2.0, 1.0, 10.0);\n    triangles[3].V3 = vec3(3.0, 0.0, 10.0);\n    \n    triangles[4].V1 = vec3(-2.0, 0.0, 40.0);\n    triangles[4].V2 = vec3(-2.0, 1.0, 0.0);\n    triangles[4].V3 = vec3(-1.0, 0.0, 0.0);\n\n\n    triangles[5].V1 = vec3(-2.0, 0.0, 40.0);\n    triangles[5].V2 = vec3(-2.0, 1.0, 0.0);\n    triangles[5].V3 = vec3(-3.0, 0.0, 0.0);\n\n    \n\n    return triangles;\n}\n\n//-- -- Region intersect triangle -- --//\n\n\n// Function to intersect a ray with a single triangle\nfloat intersectTriangle(vec3 origineRayon, vec3 directionRayon,Triangle myTriangle)\n{\n    // V1, V2, V3 are the vertices of the triangle\n    vec3 edge1 = myTriangle.V2 - myTriangle.V1;\n    vec3 edge2 = myTriangle.V3 - myTriangle.V1;\n    vec3 h = cross(directionRayon, edge2);\n    float a = dot(edge1, h);\n    \n    if (abs(a) < 0.0001) // Check if ray is parallel to the triangle\n    {\n        return 0.0;\n    }\n    \n    float f = 1.0 / a;\n    vec3 s = origineRayon - myTriangle.V1;\n    float u = f * dot(s, h);\n    \n    if (u < 0.0 || u > 1.0)\n        return 0.0;\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(directionRayon, q);\n    \n    if (v < 0.0 || (u + v) > 1.0)\n        return 0.0;\n    \n    float t = f * dot(edge2, q);\n    \n    if (t > 0.0001) // Check if the intersection is in front of the ray origin\n        return t;\n    else\n        return 0.0;\n}\n\n\n// Function to intersect a ray with multiple triangles and find the closest intersection\nfloat intersectMultipleTriangles(vec3 origineRayon, vec3 directionRayon, Triangle[numTriangles] triangles) {\n\n    float closestDistance = 0.0;\n    \n    for (int i = 0; i < numTriangles; i++) \n    {\n        Triangle currentTriangle = triangles[i];\n        float Actualdistance = intersectTriangle(origineRayon, directionRayon, currentTriangle);\n        \n        if (Actualdistance > 0.0 && (closestDistance == 0.0 || Actualdistance < closestDistance)) {\n            closestDistance = Actualdistance;\n        }\n    }\n    \n    return closestDistance;\n}\n\n\n//-- -- End Region intersect triangle -- --//\n\n\n\n\n\n// Main function to render the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    Triangle triangles[numTriangles];\n    vec4 outputColor= vec4 (0.0,0.0,0.0,0.0);  \n\n    //Populate triangle with a objects\n    triangles = createCube();\n    \n    //Calcul du ratio de l'écran\n    float ratio = iResolution.y/iResolution.x;\n    \n    \n    vec4 camera_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n   \n    vec4 camera_angle = read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION);\n    \n    //---- CAMERA HANDLE ----//\n    \n    //initialise Camera Origin\n    vec3 camOrigin;\n    camOrigin.x = 0.0;\n    camOrigin.y = 0.0;\n    camOrigin.z = -fov;\n    \n    //fragCoord go from 0,0 to iResolution.x, iResolution.y\n    //fragCoord.y / iResolution.y-0.5 go from -0.5 to 0.5\n    \n    //ScreePixel vec2 (x,y)\n    // -0.5, 0,5  bord en haut à gauche  \n    // 0.5 ,-0,5  bord en bas à droite\n    vec3 ScreePixel = vec3 (fragCoord.x / iResolution.x-0.5,(fragCoord.y / iResolution.y-0.5)*ratio,0 ) ;\n    \n    \n    //Calculating movement \n    \n    ScreePixel = ScreePixel + camera_position.xyz;\n    camOrigin = camOrigin + camera_position.xyz;\n    \n    //direction du rayon Caméra écran projeté sur l'écran\n    vec3 RayDir = vec3(ScreePixel.x-camOrigin.x, ScreePixel.y -camOrigin.y, ScreePixel.z-camOrigin.z);\n    \n    RayDir *= rotateY(camera_angle.x*PI/180.0); //take pi*2 for a revolution\n    \n    RayDir *= rotateX(-camera_angle.y*PI/180.0);\n    \n    //---- CAMERA HANDLE END-//\n\n    // Find intersection with multiple triangles\n    float distance = intersectMultipleTriangles(camOrigin, RayDir, triangles);\n    \n    // Set color based on intersection distance\n    if (distance != 0.0) {\n        fragColor = vec4( 1.0/(distance*0.5), 1.0/(distance*0.5), 1.0/(distance*0.5),0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BUFFER_STATE iChannel0\n\nconst vec3 START_POSITION = vec3(0.0,0.0,-3.0);\n\n\nbool getKeyState(int keyCode, int stateType){\n    return bool(texelFetch(iChannel1, ivec2(keyCode, stateType), 0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   ivec2 address = ivec2(fragCoord);\n    \n    if (address == ADDR_CAMERA_POSITION) {\n        // Move the camera based on keypress\n    \tvec4 camera_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n        vec4 AngularOrientation = read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION);\n        \n        if (iTime < 0.1) {\n            camera_position = vec4(START_POSITION, 0.0);\n        }\n        \n        vec3 directionx = vec3(0.1,0.0,0.0);\n        \n        vec3 directionz = vec3(0.0,0.0,0.1);\n        \n        \n        directionx *= rotateY(AngularOrientation.x*PI/180.0); \n    \n        directionx *= rotateX(-AngularOrientation.y*PI/180.0);\n        \n        \n        directionz *= rotateY(AngularOrientation.x*PI/180.0);\n        \n        directionz *= rotateX(-AngularOrientation.y*PI/180.0);\n        \n        \n        if(getKeyState(KEY_LEFT, 0))\n        {\n            camera_position.xyz = camera_position.xyz - directionx;\n        }\n        \n        if(getKeyState(KEY_RIGHT, 0))\n        {\n            camera_position.xyz = camera_position.xyz + directionx;\n        }\n        \n        if(getKeyState(KEY_UP, 0))\n        {\n            camera_position.xyz = camera_position.xyz + directionz;\n        }\n       \n        if(getKeyState(KEY_DOWN, 0))\n        {\n            camera_position.xyz = camera_position.xyz - directionz;\n        }\n        \n        fragColor = camera_position;\n        return;\n    }\n    \n    if(address == ADDR_CAMERA_ORIENTATION)\n    {\n       \n       \n       \n        vec4 mouse_delta_data = read_data(BUFFER_STATE, ADDR_MOUSE_DELTA_STATE);\n        vec2 mouse_delta = iMouse.xy - mouse_delta_data.xy;\n        \n        vec2 acceleration = vec2(0.0,0.0);\n        \n        if (mouse_delta_data.z > 0.0) {\n            acceleration = mouse_delta * angularSpeed;\n        }\n        \n        vec4 AngularOrientation = read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION);\n        \n        if (iTime < 0.1) {\n            AngularOrientation = vec4(0.0,0.0,0.0,0.0);\n        }\n        \n        AngularOrientation.x = AngularOrientation.x + acceleration.x;\n        if(AngularOrientation.x > 360.0)\n        {\n            AngularOrientation.x = AngularOrientation.x - 360.0;\n        }\n        else\n        {\n            if(AngularOrientation.x < 0.0)\n            {\n                AngularOrientation.x = 360.0 - AngularOrientation.x;\n            }\n        }\n        \n        AngularOrientation.y = AngularOrientation.y + acceleration.y;\n        if(AngularOrientation.y > 180.0)\n        {\n            AngularOrientation.y = 180.0;\n        }\n        else\n        {\n            if(AngularOrientation.y < -180.0)\n            {\n                AngularOrientation.y = -180.0;\n            }\n        }\n        \n        fragColor = AngularOrientation;\n        return;\n    }\n        //MOUSE_DELTA_STATE x y => \n    if(address == ADDR_MOUSE_DELTA_STATE)\n    {\n        fragColor = iMouse;\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897\n\n//use arrow and mouse to look around the place\nconst ivec2 ADDR_CAMERA_POSITION = ivec2(0,0);\nconst ivec2 ADDR_CAMERA_ORIENTATION = ivec2(0,1);\nconst ivec2 ADDR_CAMERA_ANG_VELOCITY = ivec2(0,2);\nconst ivec2 ADDR_CAMERA_LIN_VELOCITY = ivec2(0,3);\nconst ivec2 ADDR_MOUSE_DELTA_STATE = ivec2(0,4);\n\n//keying\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n//change this parameter to fine tune the camera\n#define movingPrecision 0.0001\n#define movingSpeed 50.0\n\n#define angularSpeed 0.1\n#define fov 3.0\n\n//choose bewtin generated triangle and fixed object\n#define randomTriangle false\n\n\n\n//this thing is in project so I will work on it when I can\n//I try to implement myself shader without copy pasting completely tutoriel for 3D environement \n\n\n// Fetch a single pixe from a buffer\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n","name":"Common","description":"","type":"common"}]}