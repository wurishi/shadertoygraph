{"ver":"0.1","info":{"id":"3d3GzS","date":"1568730046","viewed":430,"name":"smart perlin blend percep. trans","username":"FabriceNeyret2","description":"SPACE: switch mode 0: horizontal gradient between still & moving textures.  mode 1: 50-50%\nTop: smart blend (morph bases). Bottom: simple blend + stddev-normalize.\n\nMouse.y : amount of grey transition. -> pure Black-or-white (bottom)  vs grey-level noise.","likes":6,"published":3,"flags":16,"usePreview":0,"tags":["noise","perlin","perception","short","artefact","paradoxical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of https://shadertoy.com/view/4tG3Wy\n// PS: this is just a sketch of test: noise is too low quality as it is.\n\n#define L  10.\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a)) // rot\n#define T(u) ( 2.* texture(iChannel0, (u)/1e3 ).r -1. )\n#define B(T) ( 1. - abs( T ) )\n#define R (iResolution.xy)\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat N(vec2 u0, vec2 u1) { // smart blend of 2 perlin noise \n\tmat2 M = rot(1.7);                        // to decorelate layers\n    float v = 0., S = 0., s=1.,\n          a = keyToggle(32) ? .5 : clamp(u0.x*R.y/R.x+.5,0.,1.);\n    \n    for (float k=0.; k<L; k++) {              // loop on harmonics\n        vec2  x0 = 10.*M*u0/s,\n              x1 = 10.*M*u1/s;\n        float t0 = T(x0), t1 = T(x1),\n              t = mix(t0,t1,a)/sqrt(a*a + (1.-a)*(1.-a)), // morph: blend random bases\n              b0 = B(t0) -.5,\n              b1 = B(t1) -.5,\n              b = u0.y > 0. \n                      ? B(t) - .5                               // morphing\n                      : mix(b0,b1,a)/sqrt(a*a + (1.-a)*(1.-a)); // blend+normalize\n\t    v += (.5 + b ) *s; \n        S += s;\n\t\tM *= M; s/=2.; \n\t}\n    return v/S;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    if (floor(U.y)==floor(R.y/2.)) { O=vec4(1,0,0,0); return; }\n\tU = (U-.5*R)/R.y;\n    float T = 1.5*iTime;\n    float e = iMouse.y > 0. ? .5*iMouse.y/R.y: 3./R.y,  // tunes transition\n          v = N(U, U+vec2(.2*T,0)+10.);    \n    O = vec4( pow(smoothstep(.7-e,.7+e, v ),1./2.2) );  // antialiasing + to SRGB\n}                                               // .7 because of interp ( otherwise .5 )","name":"Image","description":"","type":"image"}]}