{"ver":"0.1","info":{"id":"XX3SWS","date":"1719494582","viewed":82,"name":"Ringed Planet 2","username":"ArchaicVirus","description":"Ray-marched planet and rings using sdf. Animated camera and light source to illustrate shadows, lighting, and ring gaps.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","space","planet","ring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER_STRENGTH 0.1\n#define PIXEL_SIZE 0.5\n\n//toggle camera animation \n#define ROTATE_VIEW true\n\n//toggle light animation\n#define ROTATE_LIGHT true\n\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\n//radius for rings\n#define INNER_RADIUS 1.745\n#define OUTER_RADIUS 3.65\n\nvec3 planetParamsA = vec3(0.435, 0.6, 0.7);\nvec3 planetParamsB = vec3(0.6, 0.5, 0.5);\nvec3 planetParamsC = vec3(1.0, 1.0, 1.0);\nvec3 planetParamsD = vec3(0.00, 0.10, 0.20);\n\nvec3 ringParamsA = vec3(0.5, 0.5, 0.5);\nvec3 ringParamsB = vec3(0.5, 0.5, 0.5);\nvec3 ringParamsC = vec3(1.0, 1.0, 1.0);\nvec3 ringParamsD = vec3(0.00, 0.10, 0.20);\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(4.28318 * (c * t + d));\n}\n\n//Mars colors\n/*\nconst vec3 planetPalette[7] = vec3[](\n    vec3(0.8, 0.3, 0.1), \n    vec3(0.7, 0.2, 0.1), \n    vec3(0.6, 0.2, 0.1), \n    vec3(0.5, 0.2, 0.1), \n    vec3(0.6, 0.3, 0.2), \n    vec3(0.7, 0.4, 0.3), \n    vec3(0.8, 0.5, 0.4)\n);\n*/\n\n//Earth colors\nconst vec3 planetPalette[7] = vec3[](\n    vec3(0.1, 0.4, 0.6),\n    vec3(0.2, 0.5, 0.7),\n    vec3(0.3, 0.6, 0.8),\n    vec3(0.6, 0.8, 0.5),\n    vec3(0.8, 0.7, 0.4),\n    vec3(0.4, 0.3, 0.2),\n    vec3(0.9, 0.9, 0.8)\n);\n\nconst vec3 ringPalette[7] = vec3[](\n    vec3(0.4, 0.1, 0.6),\n    vec3(0.5, 0.2, 0.7),\n    vec3(0.6, 0.3, 0.8),\n    vec3(0.3, 0.5, 0.9),\n    vec3(0.2, 0.4, 0.8),\n    vec3(0.1, 0.3, 0.7),\n    vec3(0.1, 0.2, 0.6) \n);\n\nvec3 rotateY(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat hash(float n) {\n    return fract(sin(n) * 53738.14534123);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float scale = 105.0;\n    return mix(\n        mix(hash(ip.x + ip.y * scale), hash(ip.x + 1.0 + ip.y * scale), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * scale), hash(ip.x + 1.0 + (ip.y + 1.0) * scale), u.x),\n        u.y\n    );\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotateY(p, 45.0);\n    }\n    return n;\n}\n\nvec3 colorBandingPlanet(float n) {\n    if (n > 0.92) return planetPalette[0];\n    if (n > 0.80) return planetPalette[1];\n    if (n > 0.68) return planetPalette[2];\n    if (n > 0.53) return planetPalette[3];\n    if (n > 0.37) return planetPalette[4];\n    if (n > 0.21) return planetPalette[5];\n    return planetPalette[6];\n}\n\nvec3 colorGradientRing(float dist, float gapPosition) {\n    int paletteSize = ringPalette.length();\n    float scaledPosition = (mod(dist + 0.2125, 1.0)) * (float(paletteSize) - 1.0);\n    int index1 = int(floor(scaledPosition));\n    int index2 = min(index1 + 1, paletteSize - 1);\n    float mixFactor = fract(scaledPosition);\n    return mix(ringPalette[index1], ringPalette[index2], mixFactor);\n}\n\nconst mat4 bayerMatrix = mat4(\n    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n);\n\nvec3 applyDithering(vec3 color, vec2 uv) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    return color + threshold * DITHER_STRENGTH;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.25;\n}\n\nfloat ringSDF(vec3 p, float innerRadius, float outerRadius) {\n    vec2 d = vec2(length(p.xz) - outerRadius, abs(p.y) - 0.001);\n    float outer = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    vec2 innerD = vec2(innerRadius - length(p.xz), abs(p.y) - 0.001);\n    float inner = length(max(innerD, 0.0)) + min(max(innerD.x, innerD.y), 0.0);\n    return max(max(inner, -outer), outer);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF(samplePoint);\n    float ringDist = ringSDF(samplePoint, INNER_RADIUS, OUTER_RADIUS);\n    if (ringDist < EPSILON && sphereDist > EPSILON) {\n        //create gaps to fake multiple rings\n        float distFromCenter = length(samplePoint.xz);\n        //float noiseFactor = noise(samplePoint.xz * 0.1);\n        float band = mod(distFromCenter, 1.0);\n        if (band < 0.3) {\n            return sphereDist;\n        }\n    }    \n    return min(sphereDist, ringDist);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //set up camera\n    vec3 eye = vec3(0.0, 4.0, 9.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    //animate camera\n    if (ROTATE_VIEW) {\n        float angle = iTime * 0.25;\n        eye = vec3(6.0 * cos(angle), 1.0 + (2.0 * (sin(angle) * 2.0)), 6.0 + (12.0 * sin(angle)));\n    }\n    mat4 viewToWorld = viewMatrix(eye, target, up);\n    //apply pixel size\n    vec2 quantizedFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, quantizedFragCoord);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    //no hit, return background color\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    vec3 p = eye + dist * worldDir;\n    //rotate the scene\n    vec3 rotatedP = rotateY(p, iTime * 0.25);\n    vec3 col;\n    float noiseValue;\n    //are we on the planet, or rings?\n    bool isPlanet = sphereSDF(rotatedP) < ringSDF(rotatedP, INNER_RADIUS, OUTER_RADIUS);\n    vec3 lightPos;\n    //animate light source?\n    if (ROTATE_LIGHT) {\n        float anglel = iTime * 0.5;\n        lightPos = vec3(20.0 * cos(anglel), 10.0 + (sin(anglel) * 6.0), 10.0 * sin(anglel));\n    } else {\n        lightPos = vec3(20.0, 10.0, 2.0);\n    }\n    vec3 lightIntensity = vec3(0.75);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = estimateNormal(p)*2.0;\n    \n    if (isPlanet) {\n        vec3 norm = normalize(rotatedP);\n        noiseValue = layeredNoise(norm * 1.1415, 1.0, 0.5, 0.6, 3);\n        //mix 2nd noise sample for more detail\n        float noiseValue2 = layeredNoise(norm * 6.1415, 0.75, 0.5, 0.6, 24);\n        noiseValue = applyDithering(mix(vec3(noiseValue), vec3(noiseValue2), 0.75), quantizedFragCoord / PIXEL_SIZE).x;\n        //procedural palette\n        //col = palette(noiseValue, planetParamsA, planetParamsB, planetParamsC, planetParamsD);\n        //earth palette\n        col = colorBandingPlanet(noiseValue);\n        //add lighting\n        float diffuse = max(dot(normal, lightDir), 0.25);\n        vec3 color = col * diffuse * lightIntensity;\n        fragColor = vec4((color), 1.0);\n    } else {\n        //modulate ring colors with distance and noise offset\n        float distFromCenter = length(rotatedP.xz);\n        float noiseFactor = noise(rotatedP.xz * 0.01);\n        float gapPosition = mod(distFromCenter * 0.5 - noiseFactor, 1.0);\n        if (gapPosition < 0.0) {\n            col = vec3(0.0);\n        } else {\n            //use ringPalette\n            //col = colorGradientRing(distFromCenter, gapPosition);\n            //col = applyDithering(col + (noise(rotatedP.xz*6.5) * 0.2), quantizedFragCoord / PIXEL_SIZE);\n            \n            //use procedural palette\n            col = palette(gapPosition + noise(rotatedP.xz * 1.35) * 0.1, ringParamsA, ringParamsB, ringParamsC, ringParamsD);\n            col = applyDithering(col, quantizedFragCoord / PIXEL_SIZE);\n        }\n        //abs value for illuminating underside of ring\n        float diffuse = max(abs(dot(normal, lightDir)), 0.0);\n        vec3 color = col * diffuse * lightIntensity;\n        float shadow = 1.0;\n        float shadowDist = shortestDistanceToSurface(p + lightDir, lightDir, MIN_DIST, MAX_DIST);\n        if (shadowDist < length(lightPos - p)) {\n            shadow = 0.5;\n        }\n        color *= shadow;\n        fragColor = vec4(sqrt(color), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}