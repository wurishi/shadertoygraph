{"ver":"0.1","info":{"id":"4ffXDr","date":"1705104722","viewed":128,"name":"simple circles emerging","username":"MaggiMeister3000","description":"circles emerging in a chain like pattern ","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["circles","sin","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The actual pattern is very simple, but it is on its own somehow very pixly. \n// To fix this different frames are calculated and layered onto each other to form one image\n#define NUM_FRAMES 50\n\n// #define iResolution vec3(1920.0, 1080.0, 1.0)\n\n// different colors\nvec3 color_rose = vec3(242.0,203.0,196.0)/255.0;\nvec3 color_rose_light= vec3(255.0,198.0,198.0)/255.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 4.0 - iResolution.xy) / iResolution.xy;\n\n    // later used to layer frames\n    vec3 accumulatedColor = vec3(0.0);\n\n    // in this loop different frames are computed\n    for (int i = 0; i < NUM_FRAMES; i++) {\n    \n        // determines the time instance, where the speed and difference between frames can be changed\n        float animationTime = iTime*1.5 + float(i) * 0.02;\n\n        // actuall shader code\n        float col = 1.0 * (sin(10.0 * uv.x ) + 0.4 * sin(8.0 * uv.y ));\n        col = length(col);\n        col = fract(col + 0.04 * abs(animationTime));\n\n        // add all frames\n        accumulatedColor += vec3(col);\n    }\n\n    // normalise frames\n    vec3 finalColor = accumulatedColor / float(NUM_FRAMES);\n    \n    // final color\n    finalColor = finalColor*color_rose;\n    fragColor = vec4(finalColor, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}