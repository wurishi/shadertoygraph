{"ver":"0.1","info":{"id":"csdXz2","date":"1680116098","viewed":78,"name":"3D Voronoi and more","username":"ianertson","description":"3D voronoi, along with some more noise functions","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","voronoi","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = floatBitsToUint(ip);\n    uint s = floatBitsToUint(seed)>>3U;\n    p ^= (p << 17U);\n    p.x ^= (p.x << s);\n    p.y ^= (~p.y << s) ^ ~p.x << 3U;\n    p ^= (p >> 13U);\n    p.y ^= (p.y << s);\n    p.x ^= (~p.x << s) ^ ~p.y >> 3U;\n    p ^= (p << 5U);\n    return 5031U*((p.x + p.y) + ((p.x ^ p.y) * ((s << ~p.x) + (s << ~p.y))));\n}\n\nfloat hash21(in vec2 p, in float seed) { return float(hash21u(p, seed)) / float(0xFFFFFFFFU); }\n\nuint hash31u(in vec3 ip, in float seed) {\n    uvec3 p = floatBitsToUint(ip);\n    uint s = floatBitsToUint(seed);\n    p.z ^= (~p.z << 34256U);\n    p ^= (p << 17U);\n    p.x ^= (p.x << s);\n    p.y ^= (~p.y << s) ^ p.z;\n    p ^= (p >> 13U);\n    p.y ^= (p.y << s);\n    p.x ^= (~p.x << s) ^ p.z;\n    p ^= (p << 5U);\n    return 9031U*((p.x + p.y * p.z) + ((p.x ^ p.z * p.y) * ((s << ~p.x) + (s << ~p.y) + (s << ~p.z))));\n}\n\nfloat hash31(in vec3 p, in float seed) { return float(hash31u(p, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(\n        float((n >> 16U) & 0xFFU),\n        float((n >> 8U) & 0xFFU),\n        float(n & 0xFFU)\n    ) / float(0xFFU);\n}\n\nvec3 hash33(in vec3 ip, in float seed) {\n    uint n = hash31u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(\n        float((n >> 16U) & 0xFFU),\n        float((n >> 8U) & 0xFFU),\n        float(n & 0xFFU)\n    ) / float(0xFFU);\n}\n\nfloat noise21(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise21(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        float j = float(i) / float(octaves);\n        n += amp * noise21(p * freq, seed); div += amp; amp /= (1.0 + j); freq *= 2.0;\n    }\n    \n    return n/div;\n}\n\nvec3 noise23(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash23(id, seed), hash23(id+vec2(1, 0), seed), lv.x),\n        mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise23(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < octaves; i++) {\n        float j = float(i) / float(octaves);\n        n += amp * noise23(p * freq, seed); div += amp; amp /= (1.0 + j); freq *= 2.0;\n    }\n    \n    return n/div;\n}\n\nfloat noise31(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(\n            mix(hash31(id, seed),               hash31(id+vec3(1, 0, 0), seed), lv.x),\n            mix(hash31(id+vec3(0, 1, 0), seed), hash31(id+vec3(1, 1, 0), seed), lv.x),\n            lv.y\n        )\n        ,\n        mix(\n            mix(hash31(id+vec3(0, 0, 1), seed), hash31(id+vec3(1, 0, 1), seed), lv.x),\n            mix(hash31(id+vec3(0, 1, 1), seed), hash31(id+vec3(1, 1, 1), seed), lv.x),\n            lv.y\n        ),\n        lv.z\n    );\n}\n\nfloat noise31(in vec3 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        float j = float(i) / float(octaves);\n        n += amp * noise31(p * freq, seed); div += amp; amp /= (1.0 + j); freq *= 2.0;\n    }\n    \n    return n/div;\n}\n\nvec3 noise33(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(\n            mix(hash33(id, seed),               hash33(id+vec3(1, 0, 0), seed), lv.x),\n            mix(hash33(id+vec3(0, 1, 0), seed), hash33(id+vec3(1, 1, 0), seed), lv.x),\n            lv.y\n        )\n        ,\n        mix(\n            mix(hash33(id+vec3(0, 0, 1), seed), hash33(id+vec3(1, 0, 1), seed), lv.x),\n            mix(hash33(id+vec3(0, 1, 1), seed), hash33(id+vec3(1, 1, 1), seed), lv.x),\n            lv.y\n        ),\n        lv.z\n    );\n}\n\nvec3 noise33(in vec3 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < octaves; i++) {\n        float j = float(i) / float(octaves);\n        n += amp * noise33(p * freq, seed); div += amp; amp /= (1.0 + j); freq *= 2.0;\n    }\n    \n    return n/div;\n}\n\nfloat voronoi2D(in vec2 p, in float seed){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, seed+3.328123), hash21(Pi+lattice, seed+5.58931));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\nfloat voronoi3D(in vec3 p, in float seed){\n    vec3 Pi = floor(p);\n    vec3 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec3 res = vec3(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            for(int k=-1; k<=1; k++){\n                vec3 lattice = vec3(float(i),float(j), float(k));\n                vec3 offset = hash33(Pi+lattice, seed+4.48422133);\n                vec3 diff = lattice + offset - Pf;\n\n                float dist = dot(diff,diff);\n                r = min(r, dist/0.56);\n                if(r<dmin){\n                    dmin = r;\n                    res = lattice + offset;\n                }\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0, 0, -3.5);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    vec3 L = normalize(vec3(1, 2, -3));\n    \n    if (m.z > 0.001 && iFrame > 1 && iTime > 0.003) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float d = 100000.0;\n    bool hit = false;\n    if (intersectRaySphere(\n        ro,\n        rd,\n        vec3(-2.5, 0.0, 4),\n        1.0,\n        p,\n        n,\n        d\n    )) {\n        hit = true;\n        p.xz *= rot(T*0.1);\n        col += voronoi3D(p*9., 4.4929123) * max(0.0, dot(n, L));\n    }\n    \n    if (intersectRaySphere(\n        ro,\n        rd,\n        vec3(0.0, 0.0, 4),\n        1.0,\n        p,\n        n,\n        d\n    )) {\n        hit = true;\n        p.xz *= rot(T*0.1);\n        col += noise33(p, 4.4929123, 2.0, 6) * max(0.0, dot(n, L));\n    }\n    \n    if (intersectRaySphere(\n        ro,\n        rd,\n        vec3(2.5, 0.0, 4),\n        1.0,\n        p,\n        n,\n        d\n    )) {\n        hit = true;\n        p.xz *= rot(T*0.1);\n        col += noise31(p, 4.4929123, 2.0, 6) * max(0.0, dot(n, L));\n    }\n    \n    if (intersectRaySphere(\n        ro,\n        rd,\n        vec3(0., 2.5, 4),\n        1.0,\n        p,\n        n,\n        d\n    )) {\n        hit = true;\n        col += hash31(p, 4.4929123) * max(0.0, dot(n, L));\n    }\n    \n    if (intersectRaySphere(\n        ro,\n        rd,\n        vec3(0., -2.5, 4),\n        1.0,\n        p,\n        n,\n        d\n    )) {\n        hit = true;\n        col += hash33(p, 4.4929123) * max(0.0, dot(n, L));\n    }\n    \n    \n    if (!hit) {\n        rd += vec3(sin(T*0.2), cos(T*0.2), sin(T*0.2))*0.1;\n        col += voronoi3D(rd*10., 6.69493);\n    }\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n\n\nbool intersectRaySphere(\n    vec3 rayOrigin,\n    vec3 rayDirection,\n    vec3 sphereCenter,\n    float sphereRadius,\n    out vec3 intersectionPoint,\n    out vec3 intersectionNormal,\n    out float dist\n) {\n    vec3 rayOriginToSphereCenter = rayOrigin - sphereCenter;\n\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayOriginToSphereCenter);\n    float c = dot(rayOriginToSphereCenter, rayOriginToSphereCenter) - sphereRadius * sphereRadius;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        intersectionPoint = vec3(0.0);\n        intersectionNormal = vec3(0.0);\n        return false;\n    }\n\n    if (discriminant == 0.0) {\n        float t = -0.5 * b / a;\n        intersectionPoint = rayOrigin + t * rayDirection;\n        intersectionNormal = normalize(intersectionPoint - sphereCenter);\n        dist = t;\n        return true;\n    }\n\n    if (discriminant > 0.0) {\n        float t1 = (-0.5 * b - sqrt(discriminant)) / a;\n        float t2 = (-0.5 * b + sqrt(discriminant)) / a;\n        float t = min(t1, t2);\n        intersectionPoint = rayOrigin + t * rayDirection;\n        intersectionNormal = normalize(intersectionPoint - sphereCenter);\n        dist = t;\n        return true;\n    }\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}","name":"Common","description":"","type":"common"}]}