{"ver":"0.1","info":{"id":"7sKcDV","date":"1655667260","viewed":138,"name":"sdf_fold_test","username":"snolot","description":"test sdf folding","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nmat2 rot (float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\n\n\n/*float box (vec3 p, vec3 c){\n    return length(max(abs(p)-c,0.));\n}*/\n\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nvec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\nvec4 invertRadius(vec4 z, float radius2, float limit) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = clamp(radius2 / r2, 1., limit);\n  return z * f;\n}\n\nfloat Scale = 2.;\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return max(q.x, q.y);\n}\n\nvec2 shape(vec3 p) {\n    float a = box(p, vec3(.6)); // plastic box.\n   \n    p = -abs(p) + vec3(.6); // mirror space to save on distance evaluations\n    float ce = 0.04;\n\t// edges.\n    float b = box(p - vec3(.6, 0, 0), vec3(.6 + ce, ce, ce));\n    float c = box(p - vec3(0, 0, .6), vec3(ce, ce, .6 + ce));\n    float d = box(p - vec3(0, .6, 0), vec3(ce, .6 + ce, ce));\n    \n    vec2 s = vec2(a, 2.0); // 2.0 == material id for white plastic.\n    vec2 t = vec2(min(min(b, c), d), 1.0); // 1.0 == material id for metal.\n    \n    return s.x < t.x ? s : t;\n}\n\nvec2 SDF(vec3 p){\n    float t = iTime * .2;\n    \n    \n   // p = abs(p)-vec3(0.,.5,0.);   \n   // p.yz = moda(p.yz, TAU/12.);  \n    \n    for(int i=0; i<4; i++){\n        p = abs(p)-vec3(1.75,1.5,0.25);  \n        p.xz *= rot(iTime*.2);\n        p.yz *= rot(iTime*0.2);\n        \n    }\n     \n    //float d= box(p-vec3(0.,.7, 0.2), vec3(.6,.6,.6));\n    vec2 d= shape(p-vec3(0.,.7, 0.2));\n    d.x= max(d.x, -(length(p-vec3(0.,.7, 0.2))-.7));\n    //d.x = min(d.x,  length(p-vec3(0.,.7, 0.2))-.5);\n    return d;\n}\n\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0001, 0.0);\n    float f = SDF(p).x;\n    return normalize(vec3(\n        SDF(p + e.xyy).x - f,\n        SDF(p + e.yxy).x - f,\n        SDF(p + e.yyx).x - f\n    ));\n}\n\nvec3 oc(vec3 p, float id)\n{\n    p.xy *= rot(p.z*0.64);\n    vec3 c = (id > 1.) ? vec3(1.,.7,0.) : vec3(1.,1.,1.5);\n    \n    vec3 col = c;// mix(vec3(1.0, 0.7, 0.) *c, vec3(1., .2, 0.0) *c,  smoothstep(1.0, 0., abs(p.z)-.3));\n    return col;\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 norm, vec3 lp, vec2 t)\n{\n    \n    // Lighting\n    vec3 ld = lp-ro;\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    float atten = 1.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1); // light attenuation \n    \n    ld /= lDist;\n    \n    // Diffuse\n    float diff = max(dot(norm, ld), 0.0);\n    \n    // specular\n    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 12.0);\n    \n    //Colors\n    vec3 objCol = oc(ro, t.y);\n    \n   \n   // objCol = oc(ro);\n    \n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1.0, 1.0, 1.0)*spec*1.2) * atten;\n   \n    // Get final color\n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (0.01,0.0,-8.);\n    vec3 dir = normalize(vec3(uv*2.,1.));\n    \n    float shad = 1.;\n    vec2 d;\n    \n    for (int i=0;i<60;i++)\n    {\n         d = SDF(p);\n        if (d.x<0.001)\n        {\n            shad = float(i)/60.;\n            break;\n        }\n        \n        p += d.x*dir*0.5;\n    }\n    \n    \n    vec3 pp = p ;\n    vec3 n = normal(p+dir*d.x);\n    vec3 lp = p + vec3(0.0, 1.0, -0.5);\n   // float refl = dot(n, normalize(vec3(1.)));\n    vec3 reflection = texture( iChannel0, reflect(dir ,n) ).xyz;;\n    /*vec3 pal = palette(p.z,\n        \t\t\t\tvec3(0.5),\n                      vec3(0.5),\n                      vec3(.2),\n                      vec3(0.,0.3,0.5)\n                      );*/\n    // Time varying pixel color\n    vec3 col,c;\n    float fre = pow( clamp(1.0+dot(n,dir),0.0,1.0), 2.0 );\n    \n    col = color(p, dir, n, lp, d);\n    // Output to screen\n    col *= vec3(1.-shad)* reflection;\n    col += fre*.01;\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}