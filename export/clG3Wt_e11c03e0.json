{"ver":"0.1","info":{"id":"clG3Wt","date":"1684833354","viewed":143,"name":"Framed Pyramid","username":"bks777","description":"The wireframed raymarching pyramid","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","primitives","pyramid","sdpyramidframed"],"hasliked":0,"parentid":"DtKGD3","parentname":"[bookov] 4k 2023"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.01;\n\nvec3 pVertices[5];\n\nvoid initVertices() {\n    pVertices[0] = vec3( 0, 1, 0 ); // Apex\n    pVertices[1] = vec3( 1,-1, 1 ); // Base vertices\n    pVertices[2] = vec3(-1,-1, 1 );\n    pVertices[3] = vec3(-1,-1,-1 );\n    pVertices[4] = vec3( 1,-1,-1 );\n}\n\n/* \n    SDF function for a line segment defined by two points a and b.\n    Returns the signed distance from point p to the line segment.\n    Subtracting a value at the end makes the lines thicker.\n*/\nfloat lineSDF(vec3 a, vec3 b, vec3 p) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h) - 0.03;\n}\n\n/* \n    Rotation function around the Y-axis.\n*/\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    mat2 rotation = rot(angle);\n    vec2 rotated = rotation * p.xz;\n    return vec3(rotated.x, p.y, rotated.y);\n}\n\n/* \n    SDF function for the wireframe of a pyramid.\n*/\nfloat sdWireframePyramid(vec3 p, float shouldRotate) {\n    // Calculate the rotation angle\n    float time = iTime * 0.66;\n\n    // Define the pyramid vertices\n    vec3 apex = vec3(0.0, 1.0, 0.0);\n    vec3 base1 = vec3(1.0, -1.0, 1.0);\n    vec3 base2 = vec3(-1.0, -1.0, 1.0);\n    vec3 base3 = vec3(-1.0, -1.0, -1.0);\n    vec3 base4 = vec3(1.0, -1.0, -1.0);\n\n    // Rotate the vertices if needed\n    apex = shouldRotate > 0.5 ? rotateY(apex, time * shouldRotate) : apex;\n    base1 = shouldRotate > 0.5 ? rotateY(base1, time * shouldRotate) : base1;\n    base2 = shouldRotate > 0.5 ? rotateY(base2, time * shouldRotate) : base2;\n    base3 = shouldRotate > 0.5 ? rotateY(base3, time * shouldRotate) : base3;\n    base4 = shouldRotate > 0.5 ? rotateY(base4, time * shouldRotate) : base4;\n\n    // Compute the distance from the point p to each edge of the pyramid\n    float dist = lineSDF(apex, base1, p);\n    dist = min(dist, lineSDF(apex, base2, p));\n    dist = min(dist, lineSDF(apex, base3, p));\n    dist = min(dist, lineSDF(apex, base4, p));\n    dist = min(dist, lineSDF(base1, base2, p));\n    dist = min(dist, lineSDF(base2, base3, p));\n    dist = min(dist, lineSDF(base3, base4, p));\n    dist = min(dist, lineSDF(base4, base1, p));\n\n    // Return the minimum distance\n    return dist;\n}\n\nvoid rotateVertices(inout vec3 vertices[5], float angle, float shouldRotate) {\n    for (int i = 0; i < 5; ++i) {\n        vertices[i] = shouldRotate > 0.5 ? rotateY(vertices[i], angle * shouldRotate) : vertices[i];\n    }\n}\n\nfloat sceneSDF(vec3 p, float shouldRotate) {\n    return sdWireframePyramid(p, shouldRotate);\n}\n\nvec3 estimateNormal(vec3 p, float shouldRotate)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        sceneSDF(p+eps.xyy, shouldRotate) - sceneSDF(p-eps.xyy, shouldRotate),\n        sceneSDF(p+eps.yxy, shouldRotate) - sceneSDF(p-eps.yxy, shouldRotate),\n        sceneSDF(p+eps.yyx, shouldRotate) - sceneSDF(p-eps.yyx, shouldRotate));\n    return normalize(nor);\n}\n\n/* \n    The main rendering function. Creates a ray from the camera position and extends it in the direction of the pixel.\n    Uses raymarching to find where the ray intersects the scene. If an intersection is found,\n    calculates the lighting at that point and sets the pixel color accordingly.\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initVertices();\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(0.0, 0.0, -5.0);\n    vec3 rayDir = normalize(vec3(uv, 2.0));\n    \n    float shouldRotate = 1.0;\n\n    float t = 0.0;\n    vec3 p = camPos;\n    float d = 0.0;\n    while(t < MAX_DIST) \n    {\n        p = camPos + rayDir * t;\n        d = sceneSDF(p, shouldRotate);\n        if(d < EPSILON) \n        {\n            vec3 normal = estimateNormal(p, shouldRotate);\n            vec3 lightDir = vec3(0.0, 1.0, -2.0);\n            float diff = max(0.1, dot(lightDir, normal));\n            fragColor = vec4(diff * vec3(1.0, 1.0, 1.0), 1.0);\n            return;\n        }\n        t += d;\n    }\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}