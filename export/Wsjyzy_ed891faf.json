{"ver":"0.1","info":{"id":"Wsjyzy","date":"1587064761","viewed":109,"name":"Tracing","username":"Torta211","description":"Cone tracing and a moving camera. ELTE homework","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["camera","conetracing","homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// constants\nconst float PI    = 3.1415926535897932384626433832795;\nconst float SQRT2 = 1.4142135623730950488016887242096;\n// speed of motion\nconst float camMoveSpeed = 0.5;\n// speed of rotation\nconst float camRotSpeed = 0.01;\n// field of view with camera \n// TODO: since we scale linearly, this will not have nice results (under 90 deg it is nice)\n// TODO: to make a wide camera view, we should make left-right and up-down scaling independent (this would effect cone tracing)\nconst float halfFieldOfView = PI / 4.0;\n\n// ray tracing parametrization\nconst int traceMaxIter = 256;\nconst float rayMaxDist = 500.0;\nconst float rayMinDist = 0.01;\nconst float coneStartRadius = 0.01;\nconst float epsForShadows = 0.1;\t\t\t\t// for the maximal tangent cone algo\nconst float epsForHitAcceptance = 0.005;\t\t// distance from cone to the surface. Because if it takes negative value, it's a problem later\n\n// Input handling helpers\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\n// global time\nfloat curTime;\n\n// camera placement\nbool isInitialized;\n\n\n// ______________OBJECT REPRESENTATION_________________\n// lighting\nconst vec3 lightPos = vec3(0.0, 9.0, 0.0);\nconst float lightSourceRadius = 0.5;\n\n// for the analytically calculated sphere (which became equal to the light source)\nvec3 getAnSphereC()\n{\n    return lightPos;\n}\nfloat getAnSphereR()\n{\n    return lightSourceRadius;\n}\n\n// sdf of a sphere with center at c, radius of s\nfloat sdSphere(vec3 p, float r, vec3 c)\n{\n\treturn length(p - c) - r;\n}\n// sdf of a box with side lengths of b positioned at c\nfloat sdBox(vec3 p, vec3 b, vec3 c)\n{\n\tvec3 d = abs(p - c) - b;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n// \"how far is the nearest surface\" function\nfloat sdf(in vec3 p)\n{\n    // floor coefficients\n    float cx = 0.5;\n    float cz = 0.2;\n    //cx += abs(p.x) / 20.0;\n    //cz += abs(p.z) / 20.0;\n    // moving ball\n    float dSphere = sdSphere(p, 1.0, vec3(5.0 * sin(curTime), 6.0, 5.0 * cos(curTime)));\n    // rollin ball\n    float curX = (PI / 2.0 + 3.0 * PI * sin(curTime));\n    float curZ = curX;\n    float curY =  1.0 - cz * sin(curZ) - cx * sin(curX);                 \n    float dSphere2 = sdSphere(p, 1.0, vec3(curX, curY, curZ));\n    // moving box\n    float dBox = sdBox(p, vec3(1.0, 1.0, 1.0), vec3(7.0 * (2.0 - abs(sin(curTime))) * cos(curTime), 6.0, 0.0));\n    // distant box\n    float dBox2 = sdBox(p, vec3(2.0, 1.0, 2.0), vec3(20.0, 1.0, 10.0));\n    return min(min(min(min(dSphere, dBox), dBox2), dSphere2), p.y + cz * sin(p.z) + cx * sin(p.x));\n}\n\n// get the normal vector of surface in a given point\nconst float eps = 0.001;\nvec3 normal(const in vec3 p)\n{\n    vec3 plus = vec3(sdf(p + vec3(eps, 0.0, 0.0)),\n                     sdf(p + vec3(0.0, eps, 0.0)),\n                     sdf(p + vec3(0.0, 0.0, eps)));\n    vec3 minu = vec3(sdf(p - vec3(eps, 0.0, 0.0)),\n                     sdf(p - vec3(0.0, eps, 0.0)),\n                     sdf(p - vec3(0.0, 0.0, eps)));\n    return normalize(plus - minu);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray\n{\n\tvec3 start;\n\tvec3 dir;\n    float tanHalfAngle;\n    float distTaken;// Distance taken on ray\n    float maxDist;\t// Maximum distance allowed for this ray\n    int flags;      // bit 0:   surface condition:      true if distance to surface is small < error threshold\n    \t\t\t\t// bit 1:   distance condition:     true if travelled to far t > t_max\n                \t// bit 2:   iteration condition:\ttrue if took too many iterations\n    \t\t\t\t// bit 3: \tanalytic condition:\t\ttrue if we found an analytical solution for this ray\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec2 rot;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n};\n\nvoid updateCamera(inout vec2 mouseLast, inout Camera cam)\n{\n    /*\n        We will use the first 2 pixels of this buffer to store the information we need.\n            pixel0 = (cameraX, cameraY, cameraZ, empty)\t\n            pixel1 = (U, V, MouseX, MouseY)\n\t\tU, V is the rotation of the camera view\n\t\tMouseX, MouseY is the last position of the mouse, if it has held, and negative if it was not\n\t\tthe previous mouse position is read by the main func., and this func. returns the current mouse position\n\t\tthe previous camera position is read by the main func., and this func. returns the current camera position\n\t\tthe camera's coordinate system is set here\n\t*/   \n    // we update our camera's rotation\n    if (iMouse.z > 0.0 && mouseLast.x > 0.0)\t\t\t// mouse is held now and was held last frame\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t// in this case we do change angles\n        cam.rot -= (iMouse.xy - mouseLast) * camRotSpeed;\n        // we must not allow other values of y rotation than 0-180 deg, since it \"flips\" the controls\n        // (not totaly sure why). Also the negative interval will result in desired behaviour if we use -=\n        cam.rot.y = max(min(cam.rot.y, 0.5 * PI - 0.0001), -0.5 * PI + 0.0001);\n    }\n    // we decide what to save regarding rotation\n    if (iMouse.z > 0.0)\t\t\t\t\t\t\t\t\t// mouse is held now\n    {\n        mouseLast = iMouse.xy;\n    }\n    else if (mouseLast.x > 0.0)\t\t\t\t\t\t\t// we have just released the mouse\n    {\n        mouseLast = vec2(-1.0, -1.0);\t\t\t\t\t// in this case we save negative values as last mouse position\n        //cam.rot = mod(cam.rot, 2.0 * PI);\t\t\t\t// only in this case we set the rotation values back to normal interval\n    }\n   \t// we calculate the current base vectors\n    cam.forward = vec3(cos(cam.rot.x) * cos(-cam.rot.y), sin(-cam.rot.y), sin(cam.rot.x) * cos(-cam.rot.y));\n    cam.right   = normalize(cross(vec3(0, 1, 0), cam.forward));\n\tcam.up      = cross(cam.forward, cam.right);\n    \n    // and update the camera's position\n    if (isKeyHeld(KeyLeft )) cam.pos -= cam.right * camMoveSpeed;\n    if (isKeyHeld(KeyRight)) cam.pos += cam.right * camMoveSpeed;\n    if (isKeyHeld(KeyUp   )) cam.pos += cam.forward * camMoveSpeed;\n    if (isKeyHeld(KeyDown )) cam.pos -= cam.forward * camMoveSpeed;\n    \n}\n    \nvoid traceRayCamToPx(inout Ray ray)\n{\n    // we are searching a minimal T for which len(p + T * v - c) = r\n    // where p is the ray's start point, v is the ray's direction, c is the sphere's center, r is the sphere's radius\n    // this means that dot((p + T * v - c)(p + T * v - c)) - r^2 = 0 which is a parabola, AT^2 + BT + C = 0\n    // A = dot(v, v)\n    // B = 2 * (dot(v, p) - dot(v, c))\n    // C = dot(p, p) + dot(c, c) - 2 * dot(p, c) - r^2\n    // discriminant = B^2 - 4 * A * C\n    // if discriminant >= 0, the smaller solution is (-1 * B - sqrt(B^2 - 4 * A * C)) / (2 * A)\n    float A = dot(ray.dir, ray.dir);\n    float B = 2.0 * (dot(ray.dir, ray.start) - dot(ray.dir, getAnSphereC()));\n    float C = dot(ray.start, ray.start) + dot(getAnSphereC(), getAnSphereC()) - 2.0 * dot(ray.start, getAnSphereC()) - getAnSphereR() * getAnSphereR();\n    float D = B * B - 4.0 * A * C;\n    float analyticDist = -1.0;\n    if (D >= 0.0)\t// we bump into the analytic sphere\n    {\n        analyticDist = (-1.0 * B - sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    }\n    \n    // no matter what, we perform the cone tracing\n    float distanceFromAxisToAnything, distanceFromConeToAnything;\n    int i = 0; do\n    {\n        distanceFromAxisToAnything = sdf(ray.start + ray.distTaken * ray.dir);\n        distanceFromConeToAnything = distanceFromAxisToAnything - (coneStartRadius + ray.distTaken * ray.tanHalfAngle);\n        ray.distTaken += distanceFromConeToAnything / (1.0 + abs(ray.tanHalfAngle));\n        ++i;\n        ray.flags |= int(distanceFromConeToAnything <= epsForHitAcceptance);\n        ray.flags |= (int(ray.distTaken >= ray.maxDist) << 1);\n        ray.flags |= (int(i >= traceMaxIter) << 2);\n    } while (ray.flags == 0);\n    \n    // and decide which hit was closer\n    if (analyticDist >= 0.0 && analyticDist < ray.distTaken)\n    {\n        ray.distTaken = analyticDist;\n        ray.flags |= (int(true) << 3);\n    }\n    return;\n}\n    \nfloat traceRayPointToLight(inout Ray ray)\n{    \n    float distanceFromAxisToAnything, distanceFromConeToAnything;\n    float m = 1.0;\n    float currentTanHalfAngle = ray.tanHalfAngle;\n    float currentStartRadius = coneStartRadius;\n    int i = 0; do\n    {\n        distanceFromAxisToAnything = sdf(ray.start + ray.distTaken * ray.dir);\n        distanceFromConeToAnything = distanceFromAxisToAnything - (currentStartRadius + ray.distTaken * currentTanHalfAngle);\n        // here we use the original angle, since out error allowance only depends on the distance\n        if (distanceFromConeToAnything < epsForShadows * ray.distTaken * ray.tanHalfAngle)\n        {\n            m = distanceFromAxisToAnything / (coneStartRadius + ray.distTaken * ray.tanHalfAngle);\n            currentStartRadius = (m - epsForShadows) * coneStartRadius;\n            currentTanHalfAngle = (m - epsForShadows) * ray.tanHalfAngle;\n        }\n        ray.distTaken += distanceFromConeToAnything / (1.0 + abs(currentTanHalfAngle));\n        ++i;        \n        // we do not set hit flag here, since it won't be used\n        ray.flags |= (int(ray.distTaken >= ray.maxDist) << 1);\n        ray.flags |= (int(i >= traceMaxIter) << 2);\n        // but we use a flag for monitoring m\n        ray.flags |= (int(m <= -1.0) << 4);\n    } while (ray.flags == 0);\n    \n    return m;\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.dir).xyz, 1.0);\n}\n\nvec4 errorColor(Ray ray)\n{\n    return vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nvec4 analyticalColor(Ray ray)\n{\n    return vec4(1.0);\n}\n\nvec4 hitColor(Ray ray)\n{\n    vec3 hitPoint = ray.start + ray.dir * ray.distTaken;\n    vec3 hitNorm = normal(hitPoint);\n    \n    vec3 hitToLight = normalize(lightPos - hitPoint);\n    float lightDist = distance(hitPoint, lightPos);\n    \n     //diffuse\n    float costheta = max(dot(hitNorm, hitToLight), 0.0);\n    vec3 k_d = vec3(1.0 / PI);\n    \n    //specular\n    vec3 origToCam = -1.0 * ray.start;\n    vec3 k_s = vec3(0.8);\n    \n    vec3 h = normalize(hitToLight + origToCam);\n    float si = pow(clamp(dot(h, hitNorm), 0.0, 1.0), 160.0);\n    \n    vec3 col = (k_d + si * k_s) * costheta;\n    \n\tRay ray2 = Ray(hitPoint,\t\t\t\t\t\t// starting from the point where the ray hit\n                   hitToLight,\t\t\t\t\t\t// going towards the light source\n                   lightSourceRadius / lightDist,\t// the halfangle at which we see the light\n                   rayMinDist,\t\t\t\t\t\t// starting distance\n                   lightDist,\t\t\t\t\t\t// we go til the light source at maximum\n                   0);\t\t\t\t\t\t\t\t// all flags are zero\n    // we sacle the original m from -1 to 1, to -PI/2 to PI/2\n    float m = traceRayPointToLight(ray2) * PI / 2.0;\n    // and the area changes as a sine wave (or maybe not, it is just a guess)\n    col *= (sin(m) + 1.0) / 2.0;\n    // debugging points with too many iterations from point to light\n    if (bool(ray2.flags & 4))\n    {\n        //col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    return vec4(col, 1.0);\n}\n\n\n// _______________________MAIN________________________\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // set global time (common cannot get iTime)\n    curTime = iTime;\n    \n    \n    // See updateCamera\n    Camera cam;\n    vec2 mousePos; \n    cam.pos = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    cam.rot = texelFetch(iChannel0, ivec2(1,0), 0).xy;  \n    mousePos = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\n    updateCamera(mousePos, cam); \n    if (curTime < 0.1)\n    {\n        cam.rot = vec2(-1.5, 0.3);\n        cam.pos = vec3(0.0, 10.0, 10.0);\n    }\n    \n    // we calculate a vector pointing to the pixel's projection on camera's right-up plane (so without forward component)\n    vec2 px = (fragCoord / iResolution.xy * 2.0 - 1.0); // this is in the range of [-1; 1]\n    px *= tan(halfFieldOfView);\t\t\t\t\t        // this widens / tightens rays in both directions\n    px *= normalize(iResolution.xy);\t\t\t\t\t// this makes it correspond to aspect ratio\t\n    // calculate the pixels half opening angle's tangent\n    // which is simply the horizontal opening angle divided by the width (*sqrt(2), since we want the opening angle for the diagonal)\n    // (the vertical opening angle is = horizontal /aspect ratio, we could divide this with the height)\n    // this calculation should not run for each pixel, (would be easier if we could access iResolution in Common) \n    float tanHalfPixelAngle = SQRT2 * tan(halfFieldOfView) / iResolution.x;     \n    // we construct the Ray object cast from camera towards pixel\n    Ray ray = Ray(cam.pos,\n                  normalize(cam.forward + cam.right * px.x + cam.up * px.y), // 3D direction\n                  tanHalfPixelAngle,\n                  rayMinDist,\n                  rayMaxDist,\n                  0);\n    \n    // we calculate the result \n    traceRayCamToPx(ray);\n    // based on tracing we render the pixel  \n    // we have to check the analytical resutl first, since it leaves other results as they are\n    if     (bool(ray.flags & 8))\tfragColor = analyticalColor(ray);    \n    else if(bool(ray.flags & 1)) \tfragColor = hitColor(ray);\n    else if(bool(ray.flags & 2))\tfragColor = missColor(ray);\n    else if(bool(ray.flags & 4))\tfragColor = errorColor(ray);\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.xyz = cam.pos;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n    {\n        fragColor.xy = cam.rot;\n    \tfragColor.zw = mousePos;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}