{"ver":"0.1","info":{"id":"wlccRM","date":"1625000985","viewed":82,"name":"Gpgpu Game Lofic Proof of Concpt","username":"davisgamdev","description":"Proof of concept for calculating logic \"gate\" cells per pixel. Reads from an input buffer, and from various other cells depending on the cell operation. Uses custom operators designed for a logic puzzle system, includes 9 differing types of signals.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["gpgpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// POST SHADER - interpret data\n/*\n    read each pixel from the buffer,\n        extract and style the final node value\n        to something more easily understandable\n*/\n\n\n\nvec2 splitComp(float comp) {\n    return vec2(floor(comp/16.), mod(comp, 16.));\n}\n\n\n\nint colors[] = int[] (\n    100, 100, 100,\n    \n    255 , 42  , 0   ,\n    25  , 255 , 163 ,\n    \n    255 , 234 , 0   ,\n    65  , 13  , 255 ,\n    \n    \n    255 , 95  , 1   ,\n    166 , 255 , 0   ,\n    0   , 211 , 255 ,\n    143 , 1   , 98  \n);\n\n\n\nvec4 valueToColor(float value) {\n    \n    /* 0, 1, -1, i, -i, A, B, C, D */\n    \n    int i = int(value * 3.);\n\n    vec3 color = vec3(\n        float(colors[i++]),\n        float(colors[i++]),\n        float(colors[i++])\n     );\n\n    return vec4((color/255.).xyz, 1.);\n}\n\n\nvec4 result;\nfloat rawval;\n\nvoid deserializePixel(vec4 pixel) {\n    vec2 pr = splitComp(pixel.r);\n    rawval = pr.x;\n    result = valueToColor(rawval);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pixel = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    \n    bvec4 bv = equal(pixel, vec4(0.));\n    if(bv.x && bv.y && bv.z && bv.w) {\n        fragColor = vec4(0.9);\n        return;\n    }\n    \n    deserializePixel(pixel);\n    \n    if(rawval > 4. && mod(fragCoord.x, 15.) < 1.) fragColor = vec4(0.8);\n    else fragColor = result;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// PREPASS SHADER, SETUP NODES FOR DEBUGGING\n\n\n////////////////////////////////\n// PREPASS VARS\n\n/*\n    manually set in some logic nodes\n\n    R - I/O\n        A: Value [0-16]\n        B: Array Input [0-16]\n    \n    G - Input1 Node Coordinate\n        A: X Coordinate [0-16]\n        B: Y Coordinate [0-16]\n\n    B - Input2 Node Coordinate\n        A: X Coordinate\n        B: Y Coordinate \n\n    A - Operation\n        A: Primary (complex) Operation (none, buff, and/or/xor/etc)\n        B: Secondary Operation (not/rot/etc)\n\n*/\n\n\n/*\n    format: 8 lines each, will be multiplied and assembled to frag color in main\n*/\n    \n    // value, in0 (array) value pos, node in1x, in1y, in2x, in2y, main op, post op\n    \n    // array value is index lookup - 1; 0 is none, 1 is index 0, etc\n    // node in1 and in2, 16x16 are self lookup (0)\n    // main op, 0 is none, 1 is read/buffer, post op is 0, none\n\n\nfloat nodes = 9.;\nbool divider = false;\n\n\nint values[] = int[](\n0, 1, 2, 3, 4, 5, 6, 7, 8\n);\n\nint in0[]    = int[](\n0\n);\n\nint in1[]    = int[]( //min 2\n0, 0\n);\n\nint in2[]    = int[]( //min 2\n0, 0\n);\n\nint mainOp[] = int[](\n0\n);\n\nint postOp[] = int[](\n0\n);\n\n\n\n//\n////////////////////////////////\n\nfloat concatComp(float x, float y) {\n    return (x * 16.) + y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float normPos = ((iResolution.y - fragCoord.y)/iResolution.y);\n\n\n    float nodeNum = normPos * nodes;\n    \n    if(divider && int((normPos + .01) * nodes) > int(nodeNum)) {\n        fragColor = vec4(0.);\n        return;\n    }\n\n    int index = int(nodeNum);\n    \n    int ra = values[0];\n    int rb = in0[0];\n    int ga = in1[0];\n    int gb = in1[1]; \n    int ba = in2[0];\n    int bb = in2[1];\n    int aa = mainOp[0];\n    int ab = postOp[0];\n    \n    if(values.length() > 1) ra = values[index];\n    if(in0.length() > 1) rb = in0[index];\n    \n    if(in1.length() > 2) ga = values[index * 2];\n    if(in1.length() > 2) gb = values[(index * 2) + 1];\n    \n    if(in2.length() > 2) ba = values[index * 2];\n    if(in2.length() > 2) bb = values[(index * 2) +1];\n    \n    if(mainOp.length() > 1) aa = mainOp[index];\n    if(postOp.length() > 1) ab = postOp[index];\n    \n    \n    \n    fragColor = vec4(\n        concatComp(float(ra), float(rb)),\n        concatComp(float(ga), float(gb)),\n        concatComp(float(ba), float(bb)),\n        concatComp(float(aa), float(ab))\n    );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// INTERMEDIATARY - JUST SET PIXELS ACCORDING TO BUFFER A\n// FIRST VALUE IS ALWAYS \"/\" SECOND VALUE IS ALWAYS \"%\" WHEN EXTRACTING\n\n/**\n\n    UV Coords, 0, 0 is self, 8, 8, is null (shouldn't be used really)\n    else, 1-7 => +1-+7, 9-15 -> -1 -> -7\n\n\n    in0-2 vs a + b. a will ALWAYS be in0 or in1, b will ALWAYS be in2\n*/\n\n// MAIN SHADER, EVALUATE NODES\n\n\n////// INPUT ARRAY\n/**\n    Node values in ints\n    \n    [0, 1, -1, i, -i, A, B, C, D] = 9\n    \n    where ABCD are complex (1 + i)\n    goes by quadrant order I, II, III, IV\n    \n*/\n\nfloat IN0_ARRAY[] = float[](0., 1. ,2. ,3. ,4. ,5. ,6. ,7. ,8. ,0. , 0.);\n\n\n////// OPERATION DEFINES\n# define NONE 0.\n# define BUFF 1.\n# define AND  2.\n# define OR   3.\n# define XOR  4.\n\n////// MOD DEFINES\n# define NONE 0.\n# define NOT  1.\n# define ROT  2.\n\n// OTHER\n# define NaN -10000.\n\n\n// main data\nvec2 val;\nvec2 a;\nvec2 b;\nfloat mainOp;\nfloat postOp;\n\n\n\n\n\nvec2 splitComp(float comp) {\n    return vec2(floor(comp/16.), mod(comp, 16.));\n}\n\n\nfloat concatComp(float x, float y) {\n    return (x * 16.) + y;\n}\n\n\nvec2 rotate(vec2 comp) {\n// rotate, multiply each by i, this is tricky, but should be flip and negate\n    comp.xy = comp.yx;\n    comp.x *= -1.;\n    return comp;\n}\n\n// CONVERSION METHODS\n\nvec2 valueToVector(float value) {\n    \n    // yes there is a mathematical way to do this\n        //by hand will be faster though\n\n    if(value == 0.) return vec2(  0.,  0. );\n    if(value == 1.) return vec2(  1.,  0. );\n    if(value == 2.) return vec2( -1.,  0. );\n    if(value == 3.) return vec2(  0.,  1. );\n    if(value == 4.) return vec2(  0., -1. );\n    if(value == 5.) return vec2(  1.,  1. );\n    if(value == 6.) return vec2( -1.,  1. );\n    if(value == 7.) return vec2( -1., -1. );\n    if(value == 8.) return vec2(  1., -1. );\n\n    return vec2(NaN);\n}\n\nfloat vectorToValue(vec2 v) {\n   if(v.x ==  0. && v.y ==  0.) return 0.;\n   if(v.x ==  1. && v.y ==  0.) return 1.;\n   if(v.x == -1. && v.y ==  0.) return 2.;\n   if(v.x ==  0. && v.y ==  1.) return 3.;\n   if(v.x ==  0. && v.y == -1.) return 4.;\n   if(v.x ==  1. && v.y ==  1.) return 5.;\n   if(v.x == -1. && v.y ==  1.) return 6.;\n   if(v.x == -1. && v.y == -1.) return 7.;\n   if(v.x ==  1. && v.y == -1.) return 8.;\n   \n   return 15.;\n}\n\n\nvec2 tryReadInputNodeValue(vec2 pixelPos, vec2 rawComp) {\n    if(rawComp.x == 0. && rawComp.y == 0.) return val;\n    if(rawComp.x == 8. && rawComp.y == 8.) return valueToVector(NaN);\n    \n    vec2 rel = vec2(8.) - rawComp;\n    \n\tvec2 uv = pixelPos.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv + rel);\n    return valueToVector(splitComp(col.r).x);\n}\n\n\nvoid deserializePixel(vec4 pixel, vec2 coord) {\n    \n    vec2 pr = splitComp(pixel.r);\n    vec2 pg = splitComp(pixel.g);\n    vec2 pb = splitComp(pixel.b);\n    vec2 pa = splitComp(pixel.a);\n    \n    val = valueToVector(pr.x);\n    \n    \n    float in1;\n    float in2;\n    \n    // in1 (a) from in0 or green comp\n    int in0 = int(pr.y) - 1;\n    \n    if(in0 >= 0) {\n        a = valueToVector(IN0_ARRAY[in0]);\n    }\n    else {\n        a = tryReadInputNodeValue(coord, pg);\n    }\n    \n    // in2 (b) from blue comp\n    b = tryReadInputNodeValue(coord, pb);\n    \n    mainOp = pa.x;\n    postOp = pa.y;\n}\n\n\nvoid calculateMainOp() {\n    \n    // NONE\n    if(mainOp == NONE) return;\n    \n    \n    // BUFF / READ\n    if(mainOp == BUFF) {\n        val = a;\n        return;\n    }\n    \n    \n    // AND\n    if(mainOp == AND) {\n        \n        // return a, if a and b are the same and not 0\n        val.x = float(a.x == b.x && a.x != 0.) * a.x;\n        val.y = float(a.y == b.y && a.y != 0.) * a.y;\n        return;\n    }\n    \n    \n    // OR\n    if(mainOp == OR) {\n       \n        // return a if not zero, otherwise return b\n        val.x = (float(a.x != 0.) * a.x) + (float(a.x == 0.) * b.x);\n        val.y = (float(a.y != 0.) * a.y) + (float(a.y == 0.) * b.y);\n        return;\n    }\n    \n    // XOR\n    if(mainOp == XOR) {\n        \n        // half adder, so return sum, but if abs(v) > 2. v = 0.;\n        val = a + b;\n        val.x = float(abs(val.x) < 2.) * val.x;\n        val.y = float(abs(val.y) < 2.) * val.y;    \n        return;\n    }\n\n}\n\n\nvoid calculatePostOp() {\n\n    if(postOp == NONE) return;\n    \n    if(postOp == NOT) {\n    \n        // if it has value, it is 0. if it does not, it is 1\n            // this does not matter the coordinate, y is just stripped\n        val.x = float(val.x == 0. && val.y == 0.);\n        val.y = 0.;\n        \n        return;\n    }\n    \n    if(postOp == ROT) {\n        \n        val = rotate(val);\n        return;\n    }\n\n}\n\nvec4 serializePixel(vec4 pixel) {\n    \n    // all data except value changes\n    vec2 pr = splitComp(pixel.r);\n    \n    // pr.x is value, pr.y is in0\n    \n    // get the float value\n    float v = vectorToValue(val);\n    \n    // combine v and pr.y\n    pixel.r = concatComp(v, pr.y);\n    \n    return pixel;\n}\n\n////////////////////////////////\n// PREPASS VARS\n\n/*\n    manually set in some logic nodes\n\n    R - I/O\n        A: Value [0-16]\n        B: Array Input [0-16]\n    \n    G - Input1 Node Coordinate\n        A: X Coordinate [0-16]\n        B: Y Coordinate [0-16]\n\n    B - Input2 Node Coordinate\n        A: X Coordinate\n        B: Y Coordinate \n\n    A - Operation\n        A: Primary (complex) Operation (and/or/xor/etc)\n        B: Secondary Operation (not/rot/etc)\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 pixel = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    \n    bvec4 bv = equal(pixel, vec4(0.));\n    if(bv.x && bv.y && bv.z && bv.w) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    //deserializePixel(pixel, fragCoord);\n    //calculateMainOp();\n    //calculatePostOp();\n   \n    \n    fragColor = pixel; //serializePixel(fragColor);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// MAIN SHADER\n// FIRST VALUE IS ALWAYS \"/\" SECOND VALUE IS ALWAYS \"%\" WHEN EXTRACTING\n\n/**\n\n    UV Coords, 0, 0 is self, 8, 8, is null (shouldn't be used really)\n    else, 1-7 => +1-+7, 9-15 -> -1 -> -7\n\n\n    in0-2 vs a + b. a will ALWAYS be in0 or in1, b will ALWAYS be in2\n*/\n\n// MAIN SHADER, EVALUATE NODES\n\n\n////// INPUT ARRAY\n/**\n    Node values in ints\n    \n    [0, 1, -1, i, -i, A, B, C, D] = 9\n    \n    where ABCD are complex (1 + i)\n    goes by quadrant order I, II, III, IV\n    \n*/\n\nfloat IN0_ARRAY[] = float[](0., 1. ,2. ,3. ,4. ,5. ,6. ,7. ,8. ,0. , 0.);\n\n\n////// OPERATION DEFINES\n# define NONE 0.\n# define BUFF 1.\n# define AND  2.\n# define OR   3.\n# define XOR  4.\n\n////// MOD DEFINES\n# define NONE 0.\n# define NOT  1.\n# define ROT  2.\n\n// OTHER\n# define NaN -10000.\n\n\n// main data\nvec2 val;\nvec2 a;\nvec2 b;\nfloat mainOp;\nfloat postOp;\n\n\n\n\n\nvec2 splitComp(float comp) {\n    return vec2(floor(comp/16.), mod(comp, 16.));\n}\n\n\nfloat concatComp(float x, float y) {\n    return (x * 16.) + y;\n}\n\n\nvec2 rotate(vec2 comp) {\n// rotate, multiply each by i, this is tricky, but should be flip and negate\n    comp.xy = comp.yx;\n    comp.x *= -1.;\n    return comp;\n}\n\n// CONVERSION METHODS\n\nvec2 valueToVector(float value) {\n    \n    // yes there is a mathematical way to do this\n        //by hand will be faster though\n\n    if(value == 0.) return vec2(  0.,  0. );\n    if(value == 1.) return vec2(  1.,  0. );\n    if(value == 2.) return vec2( -1.,  0. );\n    if(value == 3.) return vec2(  0.,  1. );\n    if(value == 4.) return vec2(  0., -1. );\n    if(value == 5.) return vec2(  1.,  1. );\n    if(value == 6.) return vec2( -1.,  1. );\n    if(value == 7.) return vec2( -1., -1. );\n    if(value == 8.) return vec2(  1., -1. );\n\n    return vec2(NaN);\n}\n\nfloat vectorToValue(vec2 v) {\n   if(v.x ==  0. && v.y ==  0.) return 0.;\n   if(v.x ==  1. && v.y ==  0.) return 1.;\n   if(v.x == -1. && v.y ==  0.) return 2.;\n   if(v.x ==  0. && v.y ==  1.) return 3.;\n   if(v.x ==  0. && v.y == -1.) return 4.;\n   if(v.x ==  1. && v.y ==  1.) return 5.;\n   if(v.x == -1. && v.y ==  1.) return 6.;\n   if(v.x == -1. && v.y == -1.) return 7.;\n   if(v.x ==  1. && v.y == -1.) return 8.;\n   \n   return 15.;\n}\n\n\nvec2 tryReadInputNodeValue(vec2 pixelPos, vec2 rawComp) {\n    if(rawComp.x == 0. && rawComp.y == 0.) return val;\n    if(rawComp.x == 8. && rawComp.y == 8.) return valueToVector(NaN);\n    \n    vec2 pos = rawComp;\n    if(pos.x > 8.) pos.x = 8. - pos.x;\n    if(pos.y > 8.) pos.y = 8. - pos.y;\n    \n    pos /= iResolution.xy;\n    \n\tvec2 uv = pixelPos.xy / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv + pos);\n    \n    return valueToVector(splitComp(col.r).x);\n}\n\n\nvoid deserializePixel(vec4 pixel, vec2 coord) {\n    \n    vec2 pr = splitComp(pixel.r);\n    vec2 pg = splitComp(pixel.g);\n    vec2 pb = splitComp(pixel.b);\n    vec2 pa = splitComp(pixel.a);\n    \n    val = valueToVector(pr.x);\n    \n    \n    float in1;\n    float in2;\n    \n    // in1 (a) from in0 or green comp\n    int in0 = int(pr.y) - 1;\n    \n    if(in0 >= 0) {\n        a = valueToVector(IN0_ARRAY[in0]);\n    }\n    else {\n        a = tryReadInputNodeValue(coord, pg);\n    }\n    \n    // in2 (b) from blue comp\n    b = tryReadInputNodeValue(coord, pb);\n    \n    mainOp = pa.x;\n    postOp = pa.y;\n}\n\n\nvoid calculateMainOp() {\n    \n    // NONE\n    if(mainOp == NONE) return;\n    \n    \n    // BUFF / READ\n    if(mainOp == BUFF) {\n        val = a;\n        return;\n    }\n    \n    \n    // AND\n    if(mainOp == AND) {\n        \n        // return a, if a and b are the same and not 0\n        val.x = float(a.x == b.x && a.x != 0.) * a.x;\n        val.y = float(a.y == b.y && a.y != 0.) * a.y;\n        return;\n    }\n    \n    \n    // OR\n    if(mainOp == OR) {\n       \n        // return a if not zero, otherwise return b\n        val.x = (float(a.x != 0.) * a.x) + (float(a.x == 0.) * b.x);\n        val.y = (float(a.y != 0.) * a.y) + (float(a.y == 0.) * b.y);\n        return;\n    }\n    \n    // XOR\n    if(mainOp == XOR) {\n        \n        // half adder, so return sum, but if abs(v) > 2. v = 0.;\n        val = a + b;\n        val.x = float(abs(val.x) < 2.) * val.x;\n        val.y = float(abs(val.y) < 2.) * val.y;    \n        return;\n    }\n\n}\n\n\nvoid calculatePostOp() {\n\n    if(postOp == NONE) return;\n    \n    if(postOp == NOT) {\n    \n        // if it has value, it is 0. if it does not, it is 1\n            // this does not matter the coordinate, y is just stripped\n        val.x = float(val.x == 0. && val.y == 0.);\n        val.y = 0.;\n        \n        return;\n    }\n    \n    if(postOp == ROT) {\n        \n        val = rotate(val);\n        return;\n    }\n\n}\n\nvec4 serializePixel(vec4 pixel) {\n    \n    // all data except value changes\n    vec2 pr = splitComp(pixel.r);\n    \n    // pr.x is value, pr.y is in0\n    \n    // get the float value\n    float v = vectorToValue(val);\n    \n    // combine v and pr.y\n    pixel.r = concatComp(v, pr.y);\n    \n    return pixel;\n}\n\n////////////////////////////////\n// PREPASS VARS\n\n/*\n    manually set in some logic nodes\n\n    R - I/O\n        A: Value [0-16]\n        B: Array Input [0-16]\n    \n    G - Input1 Node Coordinate\n        A: X Coordinate [0-16]\n        B: Y Coordinate [0-16]\n\n    B - Input2 Node Coordinate\n        A: X Coordinate\n        B: Y Coordinate \n\n    A - Operation\n        A: Primary (complex) Operation (and/or/xor/etc)\n        B: Secondary Operation (not/rot/etc)\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 pixel = texture(iChannel0, fragCoord.xy/iResolution.xy);\n   \n    //fragColor = pixel; return;\n    \n    bvec4 bv = equal(pixel, vec4(0.));\n    if(bv.x && bv.y && bv.z && bv.w) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    deserializePixel(pixel, fragCoord);\n    calculateMainOp();\n    calculatePostOp();\n   \n    \n    fragColor = serializePixel(fragColor);\n}","name":"Buffer C","description":"","type":"buffer"}]}