{"ver":"0.1","info":{"id":"tscSRS","date":"1573458958","viewed":858,"name":"Ray marched improved shadows","username":"nurof3n","description":"3 different shadowing techniques.\nNotice the difference between usual soft shadows and the diffrShadow function shadows. \nFurther improvement (with penumbras): https://www.shadertoy.com/view/WdyXRD","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//credit: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\n#define SHADOW_ITER 128\n#define AO_ITER 3\n#define MARCH_ITER 200\n#define MAX_MARCH_DIST 50.0\n#define EPS 0.00005\n#define FOV 45.0\n\n//raise this for higher fidelity\n#define AA 1.\n\nstruct PointLight {\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\nstruct Material {\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float specularPow;\n    float specularIntensity;\n};\nstruct Sphere {\n    vec3 O;\n    float radius;\n};\nstruct Box {\n\tvec3 O;\n    vec3 size;\n};\nstruct Wall {\n    float x;\n};\nconst Material M1 = Material(vec3(0.75, 0.73, 0.6), vec3(1.), 25., 1.7);\nconst Material M2 = Material(vec3(0.2,0.4,1.0), vec3(1.), 2., .3);\nconst Material M3 = Material(vec3(0.39, 0.8, 0.9), vec3(1.), 5., 1.);\n\nSphere S = Sphere(vec3(-1.,-1.,-5.), 1.);\nBox B = Box(vec3(2., -.6, -3.), vec3(.3,1.4,.3));\nWall Wx = Wall(-3.);\nWall Wy = Wall(-2.);\nWall Wz = Wall(-15.);\n\nvec2 minim(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n/*\n---------------SDFs---------------\n*/\n\nfloat planexSDF(float x, vec3 point) {\n \treturn point.x - x;   \n}\nfloat planeySDF(float y, vec3 point) {\n \treturn point.y - y;   \n}\nfloat planezSDF(float z, vec3 point) {\n    return point.z - z;\n}\nfloat sphereSDF(vec3 O, float radius, vec3 point) {\n \treturn length(point - O) - radius;   \n}\nfloat boxSDF(vec3 O, vec3 dim, vec3 point)\n{\n    point -= O;\n    vec3 q = abs(point) - dim;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\nvec2 sceneSDF(vec3 point) {\n    vec2 b = vec2(boxSDF(B.O, B.size, point), 3.);\n    vec2 s = vec2(sphereSDF(S.O, S.radius, point), 1.);\n    vec2 p1 = vec2(planexSDF(Wx.x, point), 2.);\n    vec2 p2 = vec2(planeySDF(Wy.x, point), 2.); \n    vec2 p3 = vec2(planezSDF(Wz.x, point), 2.);\n    return minim(b, minim(s, minim(p1, minim(p2, p3))));\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPS, p.y, p.z)).x - sceneSDF(vec3(p.x - EPS, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPS, p.z)).x - sceneSDF(vec3(p.x, p.y - EPS, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPS)).x - sceneSDF(vec3(p.x, p.y, p.z - EPS)).x\n    ));\n}\n\n/*\n-------------MARCHING---------------\n*/\n\nvec2 marchStep(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MARCH_ITER; i++) {\n        vec2 dist = sceneSDF(eye + depth*dir);\n        if (dist.x < EPS)\n\t\t\treturn vec2(depth, dist.y);\n        \n        depth += dist.x;\n        if (depth >= end) \n            return vec2(end, 0.);\n    }\n    \n    return vec2(end, 0.);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y/2.) / tan(radians(fieldOfView / 2.));\n    return normalize(vec3(xy, -z));\n}\n\n/*\n----------------AO---------------\n*/\n\n//\tThis has faster falloff for AO intensity and fewer iterations\nfloat AO(vec3 point, vec3 dir, float start) {\n\tfloat depth = start, dist;\n    float step = 0.05, falloff = 1.0;\n    float ao = 0.0;\n    for(int i = 0; i < AO_ITER; ++i) {\n        dist = sceneSDF(point + depth*dir).x;\n        ao += falloff*clamp(depth - dist, 0.0, 1.0);\n        depth += step;\n        falloff *= 0.9;\n    }\n    \n    return clamp(1.0 - 1.5*ao, 0.0, 1.0);\n}\n\n/*\n-------------SHADOWS-------------\n*/\n//  Traditional, geometrical sharp shadows\nfloat sharpShadow(vec3 point, vec3 dir, float start, float end) {\n \tfloat depth = start, dist;\n    for(int i = 0; i < SHADOW_ITER; ++i) {\n     \tdist = sceneSDF(point + depth*dir).x;  \n        depth += dist;\n        if(depth >= end)\n            return 1.0;\n        if(dist < EPS)\n            return 0.0;\n    }\n\n    return 1.0;\n}\n//\tNot very realistic, the soft shadow actually expands with distance\n//and exceeds the geometrical projection\nfloat softShadow(vec3 point, vec3 dir, float start, float end) {\n \tfloat depth = start, dist, prevdist = 10e9;\n    float shadow = 1.0;\n    for(int i = 0; i < SHADOW_ITER; ++i) {\n     \tdist = sceneSDF(point + depth*dir).x;\n        if(depth > end || shadow < EPS)\n            break;\n    //Traditional\n        //shadow = min(shadow, 35.*dist/min(depth, 5.));\n    //Sebastian Aaltonen's improvement\n        float delta = dist*dist/(2.*prevdist);\n        float dist2 = sqrt(dist*dist - delta*delta);\n    //We clamp depth because we dont want the shadow to grow big and not look realistic\n        shadow = min(shadow, 35.*dist2/max(0.0, min(depth - delta, 5.))); \n        prevdist = dist;\n    \n        depth += dist;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n//\tA more realistic model in which the casted ray goes through objects so that the shadow stays\n//inside the geometrical projection, it doesnt expand and instead it softens on the inside edges like irl\nfloat diffrShadow(vec3 point, vec3 dir, float start, float end) {\n \tfloat depth = start, dist;\n    float shadow = 1.0;\n    for(int i = 0; i < SHADOW_ITER; ++i) {\n     \tdist = sceneSDF(point + depth*dir).x;\n        if(depth > end || shadow < -1.0)\n            break;\n        \n        shadow = min(shadow, 40.*dist/depth);\n    \tdepth += clamp(dist, 0.005, 10.0);\n    }\n    \n    shadow = max(shadow, -1.0);\n    return smoothstep(-1.0, 0.0, shadow);\n}\n\n/*\n---------------PHONG---------------\n*/\n\nvec3 PhongContribForPointLight(vec3 point, vec3 normal, Material M, PointLight light) {\n\tvec3 lightDir = light.pos - point;\n    float d = length(lightDir);\n    lightDir = lightDir / d;\n    float attenuation = 1./ (.02*d*d + d + 1.);\n\n    float cosine = max(0., dot(normal, lightDir));\n    //vec3 scaledNormal = normal * cosine;\n    vec3 specular = vec3(0.);\n    if(cosine > EPS) {\t//remove condition for smooth transition at extreme angles\n        vec3 reflected = reflect(-lightDir, normal);\t//normalize(2.*scaledNormal - lightDir);\n        specular = light.color * M.specularIntensity * M.specularColor * attenuation *\n        \t\t\t\tpow( max(0., dot(reflected, normalize(-point)) ), M.specularPow );\n    }\n    \n    vec3 diffuse = light.color * M.diffuseColor * light.intensity * attenuation * cosine;\n    return diffuse + specular;  \n}\nvec3 PhongIllumination(vec3 point, vec3 normal, float colorCode) {\n    Material M;\n    if(colorCode == 1.)\n        M = M1;\n    else if(colorCode == 2.)\n        M = M2;\n    else\n        M = M3;\n    \n    vec3 ambient = vec3(.79,.79,1.) * .05;\n    vec3 color = ambient;\n    \n    PointLight light = PointLight(vec3(5.0 + .5*sin(iTime), 3.+cos(iTime), -1.0), vec3(.9, 1., .7), 4.);\n    vec3 lightDir = light.pos - point;\n    float lightDist = length(lightDir);\n    lightDir /= lightDist;\n\n    //! Soft Shadows cause problems with banding at high distances !\n    //Change shadow technique here\n    color += PhongContribForPointLight(point, normal, M, light) * diffrShadow(point, lightDir, .01, lightDist);\n    \n    light = PointLight(vec3(1.-cos(iTime),1.,4.), vec3(1., .7, .8), 4.);\n    lightDir = light.pos - point;\n    lightDist = length(lightDir);\n    lightDir /= lightDist;\n    //Change shadow technique here\n    color += PhongContribForPointLight(point, normal, M, light) * diffrShadow(point, lightDir, .01, lightDist);\n    \n    return color * AO(point, normal, 0.001);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.,0.,5.);\n    vec3 color = vec3(.0);\n    vec2 offset;\n    //MSAA\n    for(float i = 1.; i <= AA; ++i) {\n    \toffset.x = -0.5 + i/(AA+1.);\n         for(float j = 1.; j <= AA; ++j) {\n            offset.y = -0.5 + j/(AA+1.);\n            vec2 pixel = fragCoord + offset;\n             \n            vec3 rayDir = rayDirection(FOV, iResolution.xy, pixel);\n            vec2 inters = marchStep(eye, rayDir, .5, MAX_MARCH_DIST);\n\n            if(inters.x < MAX_MARCH_DIST - EPS) {\n                vec3 hit = eye + inters.x * rayDir;  \n                vec3 normal = getNormal(hit);\n                color += PhongIllumination(hit, normal, inters.y);\n    \t\t} \n        }\n    }\n    color /= AA*AA;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}