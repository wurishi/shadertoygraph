{"ver":"0.1","info":{"id":"ttlSzH","date":"1562145016","viewed":513,"name":"Strange sphere pattern","username":"gest","description":"pattern experiment","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["pattern","sphereintersect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define texture2D texture\n#define u_texture0 iChannel0\n#define u_time iTime\n#define u_canvas iResolution\n#define u_mouse iMouse\n\nconst float PI = radians(180.);\nconst float Infinity = 1./1e-10;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tfloat \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\t\t//Нормаль в точке\n\tObject object;\t\t//Дополнительные параметры объекта (формируются картой расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\nstruct Sphere {\n\tvec3 center;\n\tfloat radius;\n};\nSphere sphere = Sphere(vec3(1), 0.002);\n\nfloat intersectSphere(in Ray ray, Sphere sphere){\n\tfloat b = dot(ray.origin - sphere.center, ray.direction );\n\tfloat h = b*b - dot(ray.origin,ray.origin) + sphere.radius*sphere.radius;\n\tif (h<0.0) return -1.0;\n\th = sqrt(h);\n\tfloat t = -b - h;\n\tif (t<0.0) t = -b + h;\n\tif (t<0.0) return -1.0;\n\treturn t;\n}\n//from https://www.shadertoy.com/view/ltB3DG\nvec3 kset(vec3 p) {\n\tfloat m = 1000.;\n\tfloat mi=0.;\n\tfloat d;\n\tfor (float i=0.; i<20.; i++) {\n\t\tp = abs(p)/dot(p,p) - 1.0;\n        d = length(p);\n        if (d < m) { \n\t\t\tm=d;\n\t\t \tmi=i;\n\t\t}\n\t}\n\treturn normalize( 3.+texture2D(u_texture0, vec2(mi*.218954)).xyz )\n           * pow( max(0.,1.-m), 2.5+.3*sin(d*25.+(u_time*.03)*50.) );\n}\nvoid rotateYZ(inout vec3 v, float rad) {\n\tfloat c=cos(rad),s=sin(rad);\n\tmat2 rot = mat2(c,-s,s,c);\n\tv.xy *= rot;\n\tv.xz *= rot;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord )\n{\n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2.0 - 1.0;\n\n    vec2 mo = u_mouse.xy/u_canvas.xy;\n    mo = mo * 2.0 - 1.0;\n    if (u_mouse.z<=0.) mo = vec2(0);\n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin  = -vec3(3.0*mo, 8.5-0.7*sin((u_time*0.03)*3.7535));\n        cam.target \t= vec3(1);\n        cam.up \t\t= vec3(0,1,0);\n    }\n    Ray ray = lookAt(uv, cam);\n\n    vec3 col = vec3(0); \n\n    for (int i=0; i<10; i++) {\n        sphere.radius *= float(i);\n        ray.distance = intersectSphere(ray, sphere) * 0.6;\n        ray.position = ray.origin + ray.direction * ray.distance;\n        rotateYZ(ray.position, u_time*0.1);\n\n        //ray.position = sin(ray.position*u_time*1.8);\n        \n        //ray.position = sphere.radius + sin(u_time*0.05)*ray.position;\n\n        col = 0.9*col + 0.5*kset(ray.position)*step(0.,ray.distance);\n    }\n    col = pow(col, vec3(25));\n\n    GL_FragColor = vec4(col.brg* vec3(1.2,1.05,.9), 1);\n}","name":"Image","description":"","type":"image"}]}