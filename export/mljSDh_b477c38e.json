{"ver":"0.1","info":{"id":"mljSDh","date":"1676023473","viewed":29,"name":"physical brdf","username":"lambwww","description":"brdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////  graph  //////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\nfloat sphere(vec3 p,vec3 center,float radius)\n{\n    return length(p-center)-radius;\n}\nfloat plane(vec3 p)\n{\n    return p.y+1.5;\n}\n//////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////  brdf  ///////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\nfloat pow5(float x)\n{\n    return x*x*x*x*x;\n}\nfloat Diffuse_Burley(float roughness,float NoV,float NoL,float VoH)\n{\n    float FD90=0.5+2.0*VoH*VoH*roughness;\n    float FdV=1.0+(FD90-1.0)*pow5(1.0-NoV);\n    float FdL=1.0+(FD90-1.0)*pow5(1.0-NoL);\n    return (1.0/PI)*FdV*FdL;\n}\nfloat D_GGX(float roughness,float NoH)\n{\n    float a2 = roughness ;\n    float cos2th = NoH * NoH;\n    float den = (1.0 + (a2 - 1.0) * cos2th);\n\n    return a2 / (PI * den * den);\n}\nvec3 F_Schlick(float VoH, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow5(1.0 - VoH);\n}\nfloat V_Smith_GGX(float roughness, float NoV,float NoL) {\n    float a = roughness*roughness;\n    float SmithV=NoL*(NoV*(1.0-a)+a);\n    float SmithL=NoV*(NoL*(1.0-a)+a);\n    return 0.5/( SmithV + SmithL );\n\n}\n//////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////  render  ////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n//场景图，并且根据不同的id赋不同的颜色值\nmaterial map(vec3 p){\n    material mat;\n    mat.color=vec3(1,1,1);\n    vec3 center=vec3(0,0, 4); \n    float sphere1=sphere(p,vec3(-2,0,4),1.);\n    float sphere2=sphere(p,vec3(2,0,4),1.);\n    float plane1=plane(p);\n    \n    float roughness=0.0;\n    if(sphere1<=0.001)\n    {\n        mat.roughness=0.6;\n        mat.color=vec3(0.3,0.0,0.0);\n    }\n    if(sphere2<=0.001)\n    {\n        mat.roughness=0.1;\n        mat.color=vec3(0.0,0.3,0.3);\n    }\n    if(plane1<=0.001)\n    {\n        mat.color=vec3(0.9)* mod(floor(1.0 * p.z) + floor(1.0 * p.x), 2.0);\n    }\n    mat.roughness*=mat.roughness;\n    mat.d=min(sphere1,min(sphere2,plane1));\n    return mat;\n}\n//利用曲面的梯度求法线，就是对xyz分量求偏导\nvec3 GetNormal(vec3 p){\n    float d = map(p).d;\n    vec2 e = vec2(0.001,0.0);\n    float  fdx = d-map(p-e.xyy).d;\n    float fdy = d-map(p-e.yxy).d;\n    float fdz = d-map(p-e.yyx).d;\n    return normalize(vec3(fdx,fdy,fdz));\n}\n//求光线到球表面的距离，使用光线无限接近\nmaterial rayMarch(vec3 ro,vec3 rd)\n{\n    material mat;\n    float d=0.;\n    for(int i=0;i<250;i++)//之前循环次数少了，有的地方没找到\n    {\n        vec3 p=ro+rd*d;\n        mat=map(p);\n        float tempD=mat.d;\n        if(tempD<=0.001 || tempD>=40.) //太近代表找到了，太远代表看不见\n            break;\n        d+=tempD;\n    }\n    mat.d=d;\n    return mat;\n}\n//////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////  shadow  ////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n//0代表硬阴影，res代表软阴影，1代表没有阴影。因为越接近0越靠近黑色\nfloat softshadow(vec3 ro,vec3 rd,float k)\n{\n    float res=1.0;\n    float t=0.;\n    for(int i=0;i<100;i++)\n    {\n        float h=map(ro+rd*t).d;\n        if(h<0.001) return 0.;\n        //这里h是sdf的距离值，t表示从起点到点现在所在位置走过路程的长度，二者比值代表了安全角度的大小\n        //k是控制角度对应的阴影取值，k越大角度和阴影关系越敏感\n        res=min(res,k*h/t); \n        \n        t+=h;\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv初始化\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(1,1,1);\n    //生成视线\n    vec3 ro=vec3(0,2,-3.5);\n    vec3 rd=normalize(vec3(uv.x,uv.y-0.3,1));//光线向量，要限制在【0，1】中间\n    //求眼睛到球体的距离，如果在距离内代表可以被看见，就进行着色\n    material mat=rayMarch(ro,rd);\n    if(mat.d<=40. && mat.d>=0.0)\n    {\n        //视线起点到球表面的最小距离\n        float d=mat.d;\n        //球表面的点\n        vec3 p=ro+rd*d;\n        //生成光线，光线射向当前看到的物体表面点\n        vec3 lightPos=vec3(-5,5,4);\n        vec3 lightDir=normalize(lightPos-p);\n        //get material\n        vec3 v = normalize(-rd);\n        vec3 n = GetNormal(p);\n        vec3 l = normalize(lightDir);\n        vec3 h = normalize(v + l);\n        vec3 r=normalize(reflect(rd,n));//反射光\n\n        float NoV = clamp(dot(n, v),0.0,1.0);\n        float NoL = clamp(dot(n, l),0.0,1.0);\n        float NoH = clamp(dot(n, h),0.0,1.0);\n        float LoH = clamp(dot(l, h),0.0,1.0);\n        float VoH = clamp(dot(v, h),0.0,1.0);\n        \n        //diffuse\n        vec3 diffuseColor=mat.color*(1.0-metallic);\n        vec3 Fd=diffuseColor*Diffuse_Burley(mat.roughness,NoV,NoL,VoH);\n        \n        //specular\n        vec3 F=F_Schlick(VoH,mat.color);\n        float D=D_GGX(mat.roughness,NoH);\n        float G=V_Smith_GGX(mat.roughness,NoV,NoL);\n        vec3 Fs=D*F*G;\n        //shadow\n        p=p+n*0.002;\n        float shadow=softshadow(p,lightDir,8.)+0.2;\n        \n        color=Fd+Fs;\n        color *= (intensity * shadow * NoL) * vec3(0.98, 0.92, 0.89);\n        //reflect\n        material refMat=rayMarch(p,r);\n        if(refMat.d>0.0 && refMat.d<=40.0)\n        {\n            refMat.color*=mat.color;\n            refMat.color*=0.64;\n            color+=refMat.color;\n        }\n    }\n    else\n    {\n        color = vec3(0.85, 0.85, 0.85);\n    }\n    color=sRGB(color);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\nstruct material{float d;float roughness;vec3 color;};\n\nfloat metallic=0.0;//反射率\nfloat intensity=2.0;\n\nvec3 sRGB(vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}","name":"Common","description":"","type":"common"}]}