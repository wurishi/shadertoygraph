{"ver":"0.1","info":{"id":"NsKGDy","date":"1632141252","viewed":522,"name":"20210920_octree traversal","username":"0b5vr","description":"Inspired by https://www.shadertoy.com/view/7sKGRy\nA prequel of https://www.shadertoy.com/view/fdVGDy\n\nhaha\n\nclarify: it's a quad tree mapped to 2d, both ray and function are defined in vec3\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["quadtree","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\nstruct RectSubdivResult {\n    float volume;\n    vec3 center;\n    vec3 dimension;\n    vec3 domainMin;\n    vec3 domainMax;\n    float id;\n};\n\n/**\n * Ref: https://www.shadertoy.com/view/7sKGRy\n * @param p The input position\n * @param scale scale of the domain of the fractal\n */\nRectSubdivResult rectSubdiv( vec3 p, vec3 scale ) {\n    float t = iTime;\n\n    // several constants\n    const int ITERS = 12;\n    const int MIN_ITERS = 1;\n    const float MIN_SIZE = 0.15;\n    const float BREAK_CHANCE = 0.0;\n    const float PAD_FACTOR = 1.01;\n\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 domainMin = vec3( -0.5 ) * scale;\n    vec3 domainMax = vec3( 0.5 ) * scale;\n\n    // id of the individual cube in the fractal\n    float id = 0.0;\n    \n    // random seed of cut positions\n    float seed = floor( t / 6.0 ) + 0.1;\n\n    // size of the current box determined by domainMin / domainMax\n    vec3 dimension = domainMax - domainMin;\n    \n    for ( int i = 0; i < ITERS; i ++ ) {\n        float fi = float( i );\n\n        // divide the box into eight\n        vec3 divideHash = vec3(\n            fs( dot( vec2( fi + id, seed ), vec2( 1.26, 2.72 ) ) ),\n            fs( dot( vec2( fi + id, seed ), vec2( 1.78, 0.47 ) ) ),\n            fs( dot( vec2( fi + id, seed ), vec2( 0.78, 2.25 ) ) )\n        );\n        vec3 divide = divideHash * dimension + domainMin;\n\n        // let the division line cut the box not too thin\n        divide = clamp( divide, domainMin + MIN_SIZE * PAD_FACTOR, domainMax - MIN_SIZE * PAD_FACTOR );\n        \n        // does this cut the box to the minimum preferrable size?\n        vec3 minSizeOfAxis = min( abs( domainMin - divide ), abs( domainMax - divide ) );\n        float minSize = min( minSizeOfAxis.x, min( minSizeOfAxis.y, minSizeOfAxis.z ) );\n        bool isSmallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        if ( i - 1 > MIN_ITERS && fs( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if ( isSmallEnough && i - 1 > MIN_ITERS || i == ITERS - 1 ) { willBreak = true; }\n        if( willBreak ) {\n            // id = i * 0.1 * seed;\n            break;\n        }\n\n        // update the box domain\n        domainMax = mix( domainMax, divide, step( p, divide ) );\n        domainMin = mix( divide, domainMin, step( p, divide ) );\n\n        // id will be used for coloring and hash seeding\n        vec3 diff = mix( -divide, divide, step( p, divide ) );\n        id = length( diff + 10.0 );\n    \n        // recalculate the dimension\n        dimension = domainMax - domainMin;\n    }\n    \n    // calculate volume and center of the box\n    float volume = dimension.x * dimension.y * dimension.z;\n    vec3 center = ( domainMin + domainMax ) / 2.0;\n    \n    // prepare the result\n    RectSubdivResult result;\n    result.volume = volume;\n    result.center = center;\n    result.dimension = dimension;\n    result.domainMin = domainMin;\n    result.domainMax = domainMax;\n    result.id = id;\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3( 0.0 );\n\n    RectSubdivResult subdiv = rectSubdiv( vec3( p, 0.0 ), vec3( 2.0 ) );\n    col += fract( 55.5 * subdiv.center );\n    \n    vec3 ro = vec3( 0.0 );\n    vec3 rd = vec3( cos( 0.2 * iTime ), sin( 0.2 * iTime ), 0.0 );\n    float rl = 1E-4;\n    vec3 rp = ro + rd * rl;\n    \n    // draw a yellow dot\n    col += vec3( 1.0, 1.0, 0.0 ) * step( length( p - rp.xy ), 0.01 );\n    \n    for ( int i = 0; i < 40; i ++ ) {\n        subdiv = rectSubdiv( rp, vec3( 2.0 ) );\n        \n        // calc the length to an edge\n        vec3 edgeOfAxis = mix( subdiv.domainMin, subdiv.domainMax, step( 0.0, rd ) );\n        vec3 distToEdgeOfAxis = abs( rp - edgeOfAxis ) / ( abs( rd ) + 1E-4 );\n        float distToEdge = min(\n            distToEdgeOfAxis.x,\n            min(\n                distToEdgeOfAxis.y,\n                distToEdgeOfAxis.z\n            )\n        );\n        \n        rl += distToEdge + 1E-4;\n        rp = ro + rd * rl;\n    \n        // draw a yellow dot\n        col += vec3( 1.0, 1.0, 0.0 ) * step( length( p - rp.xy ), 0.01 );\n        \n        if ( any( greaterThan( abs( rp ), vec3( 1.0 ) ) ) ) {\n            break;\n        }\n    }\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}