{"ver":"0.1","info":{"id":"XtScDR","date":"1508167732","viewed":988,"name":"Blurry Triangles","username":"BigWIngs","description":"See comments for details.","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["triangle","blur","texture","filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Blurry Triangles\" by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n\n\tI started playing around with triangular tiling and came up with a way to blur them.\n\tPerhaps it is useful to someone.\n*/\n#define S(a, b, t) smoothstep(a, b, t)\n#define GRID 15.\n\n#define R2 1.41421356\n#define PI 3.14159265\n\nfloat SimpleTriangle(vec2 uv, float w) {\n\tfloat diag = S(-w, w, uv.x-uv.y);\n    float bottom = S(-w, w, uv.y);\n    float right = S(w, -w, uv.x-1.);\n    float top = S(w, -w, uv.y-1.);\n    float left = S(-w, w, uv.x);\n    \n    return diag*bottom*top*left*right;\n}\n\nfloat Triangle(vec2 u, float w) {\n    // Optimized blurred triangle. The way I got here was by writing out\n    // the sum of a SimpleTriangle tile and it's 8 neighbors and then compacting and\n    // throwing out stuff that doesn't contribute.\n    // Still takes 7 smoothsteps, could perhaps be optimized more by exploiting \n    // symmetries. I'm sure someone will be able to reduce this further.\n    // The smoothsteps catch tile edges + diagonals (centers)\n    // ┌---┬---┬---┐\n    // |   | F |   |\n    // ├---┼-A-┼---┤\n    // | K X C B F |\n    // ├---┼-Y-┼---┤\n    // |   | K |   |\n    // └---┴---┴---┘\n    float diag = u.x-u.y;\n    float C = S(-w, w, diag);\n    float Y = S(-w, w, u.y);\n    float X = S(-w, w, u.x);\n    float A = S(-w, w, u.y-1.);\n    float B = S(-w, w, u.x-1.);\n    float F = S(-w, w, diag-1.);\n    float K = S(-w, w, diag+1.);\n    \n    return \tX*(1.-B)*(C*Y*(1.-A) + K*A+ F*(1.-Y)) + \n        \tB*(C*A + F*Y*(1.-A)) + \n        \t((1.-X)*(C*(1.-Y) + K*Y*(1.-A) + A));\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\tU = (U-iResolution.xy*.5)/iResolution.x;\n    vec2 uv = U;\n    \n    float t = iTime*.2;\n   \n    float c = cos(t), s = sin(t);\n    uv*= mat2(-c, s, s, c);\n    \n    \n    uv *= mix(2., GRID, sin(t*.5)*.5+.5);\n\n    c = cos(PI/4.), s = sin(PI/4.);\t// rotate 45 degrees\n    uv.x *= .5*sqrt(2.)*sqrt(3./4.);\t\t\t// stretch so sides are of equal length\n    uv *= mat2(-c, s, s, c);\t\t\t\t\t// apply rotation\n    \n    uv+=iTime;\n    uv = fract(uv);\n  \n    float blur = iMouse.y/iResolution.y;\n    blur = mix(.01, .7, cos(iTime*2.+U.x*PI)*.5+.5);\n    \n    float v = Triangle(uv, blur);\n    \n   // v = S(.18, .2, v)*S(.82, .8, v);\n    O = vec4(v);\n}","name":"Image","description":"","type":"image"}]}