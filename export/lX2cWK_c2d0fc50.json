{"ver":"0.1","info":{"id":"lX2cWK","date":"1727751865","viewed":27,"name":"Squircle wants to touch your 🖱️","username":"tasco","description":"only changes the value of n in order to make the shape tangent to your cursor","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["squircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 centerscaled(vec2 xy)\n{\n\tfloat diff = iResolution.y - iResolution.x;\n\tfloat mindim = diff > 0. ? iResolution.x : iResolution.y;\n\tfloat adiff = abs(diff);\n\tvec2 uv = xy/mindim;\n\tif (diff > 0.)\n\t{\n\t\tuv.y-=.5*adiff/(iResolution.x);\n\t}\n\telse\n\t{\n\t\tuv.x-=.5*adiff/(iResolution.y);\n\t}\n\treturn (uv - vec2(0.5,0.5))*2.3;\n}\n\nfloat explus(float a, float b) {\n    //returns a well-behaved version of\n    // ln(e^a + e^b)\n    float big = max(a,b);\n    float small = min(a,b);\n    float diff = big - small;\n    // ln(e^small + e^small*e^diff)\n    // = ln( (1 + e^diff)*e^small)\n    // = small + ln(1 + e^diff)\n    if (diff > 20.) {\n        return big;\n    }\n    return small + log(1. + exp(diff));\n}\n\nfloat lnmag(float n, vec2 a) {\n    float lnx = log(abs(a.x));\n    float lny = log(abs(a.y));\n    float lnsum = explus(lnx*n, lny*n);\n    float lnroot = lnsum / n;\n    return exp(lnroot);\n}\n\nfloat nOfXY(vec2 xy) {\n    float x = abs(xy.x);\n    float y = abs(xy.y);\n    if (max(x,y) > 1.) {\n        return 1e30;\n    }\n    //now we want to solve the equation (x^n + y^n) = 1, for n\n    //which is impossible analytically\n    //so we use newton's method\n    //let c = y/x\n    if (x == 0.0) return 0.;\n    float c = y/x;\n    //now we equivalently want to solve x = 1/(C^n+1)^(1/n) for n\n    //so we want to find when the function f(n) = 1/(C^n+1)^(1/n) is equal to x\n    // I found that the function ln(f(1/n)) is much more well-behaved than f, so\n    // we want to find an m such that ln(f(m)) = ln(x) and then return 1/m\n    // therefore we want to find a zero of g(m) = m*ln(1/(C^(1/m)+1) - ln(x)\n    // and g'(m) = (-ln(C^(1/m)+1)*m*C^(1/m)-ln(C^(1/m)+1)*m+ln(C)*C^(1/m))/((C^(1/m)+1)*m)\n    const int iters = 20;\n    float m0 = 1.;\n    for (int i = 0; i < iters; i++) {\n        float g = m0*log(1./(pow(c,1./m0)+1.)) - log(x);\n        float gprime = (-log(pow(c,(1./m0))+1.)*m0*pow(c,(1./m0))-log(pow(c,(1./m0))+1.)*m0+log(c)*pow(c,(1./m0)))/((pow(c,(1./m0))+1.)*m0);\n        m0 -= g / gprime;\n    }\n    return 1./m0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = centerscaled(fragCoord);\n    vec4 black = vec4(0,0,0,1);\n    vec4 white = vec4(1,1,1,1);\n    vec2 muv = centerscaled(iMouse.xy);\n\n    float d = lnmag(nOfXY(muv),uv);\n    if (d < 1.) {\n        fragColor = black;\n    } else {\n        fragColor = white;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}