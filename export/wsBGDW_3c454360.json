{"ver":"0.1","info":{"id":"wsBGDW","date":"1548858612","viewed":227,"name":"Tunnel of Light","username":"Elyxian","description":"An attempt to represent a tunnel as a series of planes. Note that there are float precision issues as time progresses (part. 500s and over).\n\nUse the mouse to look around (kinda).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","tunnel","warp","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPEED 1.0\n\nfloat noise(vec2 p) {\n\treturn valueNoise(p);\n}\n\nfloat fbm4(vec2 p, mat2 m) {    \n    float f = 0.0;\n    f += 0.5000 * noise(p); p.xy = m*p.xy;\n    f += 0.2500 * noise(p); p.xy = m*p.xy;\n    f += 0.1250 * noise(p); p.xy = m*p.xy;\n    f += 0.0625 * noise(p);\n    return f/0.9375;\n}\n\nfloat fbm6(vec2 p, mat2 m) {\n    float f = 0.0;\n    f += 0.500000 * noise(p); p.xy = m*p.xy;\n    f += 0.250000 * noise(p); p.xy = m*p.xy;\n    f += 0.125000 * noise(p); p.xy = m*p.xy;\n    f += 0.062500 * noise(p); p.xy = m*p.xy;\n    f += 0.031250 * noise(p); p.xy = m*p.xy;\n    f += 0.015625 * noise(p);\n    return f/0.96875;\n}\n\nfloat warpedNoise(vec2 q) {\n\t\n    float o1 = 0.25;\n    float o2 = 2.0;\n    float n1 = 0.5;\n    float n2 = 7.0;\n    float p1 = 4.0;\n    float p2 = 4.0;\n    \n    float angle = 0.0;\n\tfloat scale = 3.24;\n    \n\tmat2 m = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * scale;\n    \n    vec2 o = vec2(0.0);\n    o.x = o1 * fbm6(o2*q + vec2(19.2), m);\n    o.y = o1 * fbm6(o2*q + vec2(15.7), m);\n    \n    vec2 n = vec2(0.0);\n    n.x = n1 * fbm6(n2*o + vec2(23.3), m);\n    n.y = n1 * fbm6(n2*o + vec2(31.3), m);\n\n    vec2 p = p1*q + p2*n;\n    \n    float f = fbm4(p, m);\n    \n    return f;\n\n}\n\nvec4 planeCol(vec2 p, float r) {\n\t\n    // Current position of the camera\n    vec3 pos = vec3(0.0, 0.0, 1.0) * iTime * SPEED;\n    \n    // Get the noise val\n    float val = warpedNoise(p + vec2(r * 100.0));\n    \n    // Put a hole through the planes\n    float radius = 1.0;\n    val += min(length(p) - radius, 0.2);\n    \n    // Add a 'stepped' pattern to the noise\n    float steps = 10.0;\n    val = floor(val * steps) / steps;\n    \n    // If its not a hole then return a color based on distance to the camera,\n    // otherwise return a fully transparent one\n    if (val > 0.01) {\n        \n        float dist = r - pos.z;\n        float val = 1.0 / (1.0 + exp(-0.3 * (dist - 8.4)));\n        vec3 col = vec3(val);\n        \n        // Add a pulse\n        vec3 pulseColor = vec3(1.0, 1.0, 0.0);\n        pulseColor = normalize(pulseColor);\n        pulseColor = pulseColor * 0.5 * 25.0 * clamp(sin(iTime + 0.1 * r) - 0.96, 0.0, 1.0);\n        col = pulseColor + col;\n        \n        return vec4(col, 1.0);\n\n    }\n    return vec4(val, val, val, 0.0);\n\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n   \t\n    // Get the ray that moves from one plane to another\n    vec3 rayStep = rd * (1.0 / rd.z);\n    \n    // Move the current position forward to the first plane\n    float planeGap = 0.6;\n    vec3 currentPos = ro;\n    currentPos += rayStep * (ceil(ro.z / planeGap) * planeGap - ro.z);\n    \n    // Go through the planes\n   \tint noOfPlanes = 30;\n    for (int i = 0; i < noOfPlanes; i++) {\n        vec4 col = planeCol(currentPos.xy, currentPos.z);\n        if (col.a > 0.001) {\n        \treturn col.rgb;\n        }\n        currentPos += rayStep * planeGap;\n    }\n    \n    // If no planes were hit, return a background color\n    return vec3(1.0, 1.0, 1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 1.0) * iTime * SPEED;\n    vec3 rd = normalize(vec3(p, 1.4));\n    \n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0, -0.0):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 0.5;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Render the ray\n    if (rd.z > 0.0) {\n    \tvec3 col = render(ro, rd);\n    \tfragColor = vec4(col, 1.0);\n    }\n    \n    else {\n    \tfragColor = vec4(1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// This file just contains standard noise functions and so on.\n\n// Returns the matrix that rotates a point by 'a' radians\nmat2 mm2(in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// Returns the clamped version of the input\n//float saturate(float t) {\n//    return clamp(t, 0.0, 1.0);\n//}\n\n// ----------------------------\n// ------ HASH FUNCTIONS ------\n// ----------------------------\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n    \n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\nfloat hash13(vec3 p3) {\n    \n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\nvec3 hash31(float p) {\n   \n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n\n}\n\n// -------------------------\n// ------ VALUE NOISE ------\n// -------------------------\n\n\nfloat valueNoise(vec2 p) {\n    \n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(hash12(i + add.yy), hash12(i + add.xy), f.x),\n        mix(hash12(i + add.yx), hash12(i + add.xx), f.x),\n        f.y);\n    return res;\n        \n}\n\nfloat valueNoise(vec3 p) {\n    \n\tvec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(\n        \tmix(hash13(i + add.yyy), hash13(i + add.xyy), f.x),\n        \tmix(hash13(i + add.yxy), hash13(i + add.xxy), f.x),\n        f.y),\n        mix(\n            mix(hash13(i + add.yyx), hash13(i + add.xyx), f.x),\n        \tmix(hash13(i + add.yxx), hash13(i + add.xxx), f.x),\n        f.y),\n        f.z);\n    return res;\n        \n}","name":"Common","description":"","type":"common"}]}