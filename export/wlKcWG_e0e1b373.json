{"ver":"0.1","info":{"id":"wlKcWG","date":"1613041842","viewed":118,"name":"Torus knot","username":"regis","description":"Torus knot","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","torus","knot"],"hasliked":0,"parentid":"tlKcRd","parentname":"Fork sphere ref regis 798"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\nmat3 quat(vec3 p, float theta){\n\n    vec3 z = normalize(p);\n    \n    float t1 =  cos(theta);\n    float t2 =  1. - t1;\n    float t3 =  z.x*z.x;\n    float t6 =  t2*z.x;\n    float t7 =  t6*z.y;\n    float t8 =  sin(theta);\n    float t9 =  t8*z.z;\n    float t11 = t6*z.z;\n    float t12 = t8*z.y;\n    float t15 = z.y*z.y;\n    float t19 = t2*z.y*z.z;\n    float t20 = t8*z.x;\n    float t24 = z.z*z.z;\n    return mat3( t1 + t2*t3, t7 - t9, t11 + t12, t7 + t9, t1 + t2*t15, t19 - t20, t11 - t12, t19 + t20, t1 + t2*t24);\n\n}\n\nmat3 quaternion(vec3 v, float an){\n\n    vec3 z = normalize(v);\n    \n    float a = cos(an/2.0);\n    float s = sin(an/2.0);\n    float b = s*z.x;\n    float c = s*z.y;\n    float d = s*z.z;\n    float a2 = a*a;\n    float b2 = b*b;\n    float c2 = c*c;\n    float d2 = d*d;\n    float _2ab = 2.*a*b;\n    float _2ac = 2.*a*c;\n    float _2ad = 2.*a*d;\n    float _2bc = 2.*b*c;\n    float _2bd = 2.*b*d;\n    float _2cd = 2.*c*d;\n    \n    return mat3(a2+b2-c2-d2  , _2bc-_2ad, _2ac+_2bd, \n                _2ad+_2bc, a2-b2+c2-d2  , _2cd-_2ab,\n                _2bd-_2ac, _2ab+_2cd, a2-b2-c2+d2);\n\n\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2d(vec2 p, vec2 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 map(vec3 p){\n\n    vec2 d = vec2(0.0);\n    \n    float r1 = 3.0, r2 = 0.5;\n    vec3 pp = p - vec3(0.0, 4.0, 0.0);\n    float x = length(pp.xz) - r1;\n    float y = pp.y;\n    vec2 cp = vec2(x, y);\n    float a = atan(pp.x, pp.z);\n    cp *= Rot(a*2.5+iTime);\n    cp.y = abs(cp.y)-0.7;\n    //float tp = length(cp) - r2;\n    \n    float tp = Box2d(cp, vec2(.1, .1*sin(a)*.5+0.5), 0.05)*.5;\n   \n    d.x = tp;\n    d.y = 1.0;\n    \n    \n    \n  \n    \n    return d;\n\n}\n\nvec3 RM(vec3 ro, vec3 rd, float _d){\n    vec3 d = vec3(_d, 0.0, 0.0);\n    for(int i = 0;i < 100;i++){\n        d.yz = map(ro + d.x * rd).xy;\n        \n        if(abs(d.y) <(0.001))\n            break;\n            \n        d.x += d.y;\n        \n        if(d.x > 30.0)break;\n    \n    }\n    if(d.x > 30.0)d.x = -1.0;\n    \n    return d;\n    \n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 getLight(vec3 p, vec3 ro, vec3 rd, vec3 lightpos, out vec3 n, vec2 uv){\n    vec2 e = vec2(0.01, 0.0);\n    vec2 nd = map(p);\n\n    n = nd.x - vec3(map(p - e.xyy).x ,\n                        map(p- e.yxy).x ,\n                        map(p- e.yyx).x );\n\n    n = normalize(n);\n    \n        \n    \n    vec3 l = normalize(lightpos-p);\n    \n    float occ = calcAO(p, n); \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif += occ;\n    \n   \n    \n    \n    vec3 sh = RM(p+n*0.01, l, 0.0);\n    p = ro + rd * sh.x;\n    \n   \n    \n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 8.);\n    \n    vec3 col = vec3(0.0);\n       \n    if((sh.x > 0.0) && (sh.x < length(lightpos-p))){\n\n        if(sh.z == 1.0){\n\n            col = vec3(dif);\n            return col;\n\n            \n        }\n        else\n             return vec3(dif);\n     \n            \n    }\n    else\n         return vec3(dif);\n   \n   \n}\n\nvec3 Bg(vec3 rd){\n\n    float k = rd.y*.5+.5;\n    \n    \n    vec3 col = mix(vec3(.2, .1, .1), vec3(.2, .5, 1.), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n       \n    vec3 p;\n    vec3 ro = vec3(-2.0, 3.0, -7.0); \n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);\n    vec3 lightpos = vec3(0.0, 5.0, -1.0);\n        \n    vec3 dirc = vec3(0.0, 2.0, 0.0);\n        \n    float an = (iMouse.x/iResolution.x)*10.0;\n    float anx = (iMouse.y/iResolution.y)*10.0;\n    ro -= dirc;\n    lookat -= dirc;\n    ro *= quaternion(vec3(0.0, 0.0, 1.0), anx);\n    lookat *= quaternion(vec3(0.0, 0.0, 1.0), anx);\n    ro *= quaternion(vec3(1.0, 0.0, 0.0), anx);\n    lookat *= quaternion(vec3(1.0, 0.0, 0.0), anx);\n    ro *= quaternion(vec3(0.0, 1.0, 0.0), an);\n    lookat *= quaternion(vec3(0.0, 1.0, 0.0), an);\n    \n    ro += dirc;\n    lookat += dirc;\n      \n    vec3 n = cross(vec3(0.0, 2.0, 0.0), vec3(iMouse.xy, 0.0));\n    float a = acos(dot(vec3(0.0, 2.0, 0.0), vec3(iMouse.xy, 0.0)));\n    \n    \n    \n    lightpos -= dirc;\n    lightpos *= quaternion(vec3(0.0, 0.0, 1.0), anx);\n    lightpos *= quaternion(vec3(1.0, 0.0, 0.0), anx);\n    lightpos *= quaternion(vec3(0.0, 1.0, 0.0), an);\n    lightpos += dirc;\n    \n       \n    \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    col += Bg(rd);\n    \n    float dan = 0.0;\n    vec3 d = RM(ro, rd, dan);\n    \n    vec4 rc;\n    if(d.x > 0.0){\n        p = ro + d.x * rd;\n        \n        vec3 n;\n        vec3 dif = getLight(p, ro, rd, lightpos, n, uv);\n    \n        if(d.z == 1.0){\n            \n            vec3 r = reflect(rd, n);\n            float spec = pow(max(0.0, r.y), 20.);\n            col += mix(Bg(r), dif, .5)+spec ;\n                     \n           \n        \n        }\n        else if(d.z == 2.0){\n            col += dif * vec3(1.0, 1.0, 0.1);\n        \n        \n        }\n\n    }                 \n                        \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}