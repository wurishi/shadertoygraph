{"ver":"0.1","info":{"id":"4Xsczl","date":"1726568082","viewed":40,"name":"sdf platform game","username":"A_661","description":"xdd","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["xdd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// completely made by A_661 without ctrl+v\n//\n// feel free to copy, educational project\n\nfloat sdCircle (vec2 _pos, float r){ // SDF Circle func\n    return length(_pos) - r;\n}\n\nfloat sdRect(vec2 _pos, vec2 size) { // SDF Rectangle func\n    vec2 d = abs(_pos) - size;                                   // distance from edges\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);     // combine dist\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x,fragCoord.y / iResolution.y);\n    \n    //============================================================================== CALC\n    // VARS\n    // BRING OFFSET FROM PIXEL VALUES FROM BUFFER\n    vec2 offset = vec2(texelFetch( iChannel0, ivec2(0,0), 0 ).x, 100.);\n    \n    float r = 60.;\n    float rShadow = 80.;\n    float outlineThickness = 4.0;\n    float shadowOpacity = 0.4;\n    \n    // ROUND OBJECTS\n    float circle = sdCircle(fragCoord - offset, r);   // sdCircle or sdRect, doesn't matter\n    float shadow = sdCircle(vec2(fragCoord.x - offset.x - (-fragCoord.y*1.5) - 90.,(fragCoord.y - offset.y + 75.) * 2.), rShadow);\n    \n    \n    // PLATFORM\n    float h = texelFetch( iChannel0, ivec2(0,0), 0 ).w;\n    float xPos = texelFetch( iChannel0, ivec2(0,0), 0 ).z;\n    vec2 plSize = vec2(100., 20.);\n    vec2 plPos = vec2(xPos, h);\n    \n    float platform = sdRect(fragCoord - plPos, vec2(100.,20.));\n    float plOutline = sdRect(fragCoord - plPos, plSize + vec2(outlineThickness));\n    //===================================================================================\n    \n    //COLORS\n    vec4 circleColor = vec4(0.6, 0.5, 1.0, 1.0);\n    vec4 shadowColor = vec4(0.1);\n    vec4 outlineColor = vec4(1.);\n    vec4 platformColor = vec4(0.5, 0.1, 1.0, 1.0);\n    \n    \n    // ALPHA CHANELS\n    float alpha = step(0.0, -circle);\n    float outlineAlpha = step(-outlineThickness, -circle) - alpha; // method 1 (ring around circle)\n    float shadowAlpha = step(0.0, -shadow);\n    float platformAlpha = step(0.0, -platform);                    // method 2\n    float plOutlineAlpha = step(0.0, - plOutline);                 // (overriding outline layer with object layer)\n    \n    \n    \n    //============================================================ RENDER ALL THIS SHIT\n    vec4 bgColor = texture(iChannel1, uv);\n    \n    vec4 col = mix(bgColor, shadowColor, shadowAlpha * shadowOpacity);\n    \n    col = mix(col, circleColor, alpha);\n    //col = mix(col, texture(iChannel2, uv), 1.-alpha);\n    \n    col = mix(col, outlineColor, outlineAlpha);\n    col = mix(col, outlineColor, plOutlineAlpha);\n    col = mix(col, platformColor, platformAlpha);\n    fragColor = col;\n    //fragColor = vec4(shadowAlpha);\n    //==================================================================================\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// keyboard input and physics calculation \n\n// VARS\n// INPUT\nconst int KEY_LEFT  = 65;\nconst int KEY_RIGHT = 68;\nconst float circle_start = 480.;\n//PLATFORM\nfloat plSpeed = 0.0; // start speed\nfloat g = 0.005;     // = 0.f if don't want accelerate\nfloat h;\nfloat xPos;\nfloat h_start = 500.;\nfloat xPos_start = 480.;\n\nfloat handleKeyboard(float offset) {\n    \n    // RETURN BOOLEAN VALUE (ifPressed)\n    float left = texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x * -1.;    // get texels, texture coords, LoD\n    float right = texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x * 1.;\n    \n    //borders\n    float l_border = 70.;\n    float r_border = 890.;\n    \n    float circleSpeed = 4. * (240./iFrameRate); // deltaTime in GLSL!!!!!!!!!!!!!!\n    \n    if ((l_border <= offset) && (offset <= r_border)) {\n        offset += circleSpeed * (left + right);\n    }\n    else if (l_border >= offset) {\n        offset += circleSpeed * right;\n    }\n    else { offset += circleSpeed * left; }\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //RETURN OFFSET VALUE OF LAST FRAME (480 if 1st)\n\n    float offset = (texelFetch( iChannel1, ivec2(0, 0), 0).x);\n    \n    // LAST FRAME + OFFSET = NEW FRAME\n    \n    if (iFrame != 0) {\n    \n        offset = handleKeyboard(offset);\n    }\n    else { offset = circle_start; }\n    \n    // X = offset; data -> main shader\n    \n    //=============================================== PLATFORM\n    if (iFrame != 0) {\n        plSpeed = texelFetch( iChannel1, ivec2(0, 0), 0).y; \n        h = texelFetch( iChannel1, ivec2(0, 0), 0).w;\n        xPos = texelFetch( iChannel1, ivec2(0, 0), 0).z;\n        plSpeed += g;\n        h -= plSpeed * (240./iFrameRate);   // deltaTime\n    } else { h = h_start; xPos = xPos_start; }    // start point\n    \n    // EVENT DROPPED\n    if (h <= 10.) {\n        h = h_start;\n        //xPos = texelFetch( iChannel1, ivec2(0, 0), 0).x;\n        xPos = mix(25., 935., fract(sin(iTime) * 43758.5453));  // random pos\n    }\n    // EVENT COLLIDED\n    else if (h <= 165. && (offset - 150.) <= xPos && xPos <= (offset + 150.)) {\n        plSpeed = 0.;\n        xPos = mix(25., 935., fract(sin(iTime) * 43758.5453));\n        h = h_start;\n        offset = circle_start;\n    }\n    // circle x, platform speed, platform x, platform y\n    fragColor = vec4(offset, plSpeed, xPos, h);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// background procedural texture buffer\n\nfloat sdCircle (vec2 _pos, float r){\n    return length(_pos) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // SINGLE-TIME CALCUCATION OF BACKGROUND, THEN PASTING (Buffer B >> Buffer B)\n    if (iFrame != 0) {\n        fragColor = texture(iChannel0, uv);\n    } else {\n        // sun create\n        float rSun = 120.;\n        vec4 sunColor = vec4(1., 1., 0., 1.);\n        float sun = sdCircle(fragCoord - vec2(0.,iResolution.y),rSun);\n        float sunAlpha = smoothstep(-rSun, sun, 15.);\n        \n        // grass texture\n        float mixThreshold = 0.36; // position\n        float blendParam = 0.3;    // alpha blend\n        vec4 textureColor = texture(iChannel1, uv); // texture\n        \n        vec4 bgColor = mix(vec4(uv.y + 0.05,  0.3, (uv.x / 4.)+0.1, 1.0), vec4(uv.y + 0.2, 0.3, uv.x / 5., 1.0), step(200.0, fragCoord.y));\n        bgColor = mix(bgColor, sunColor, sunAlpha);\n        if (uv.y < mixThreshold) {\n            bgColor = mix(bgColor, textureColor, blendParam); \n        }\n        fragColor = bgColor;\n    };\n}","name":"Buffer B","description":"","type":"buffer"}]}