{"ver":"0.1","info":{"id":"4tlBRX","date":"1512677508","viewed":158,"name":"Empty Rectangle 2 over Texture","username":"rbeuker","description":"Left-click or drag the mouse on the image to move the rectangle.  This is just a quick test on how to draw an unfilled rectangle.  This is based on FabriceNeyret2's excellent suggestions on my earlier attempt at https://www.shadertoy.com/view/XlsBRB","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rectangle","empty","frame","hollow","unfilled"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //USE CASE\n    //A user clicks an image and an empty rectangle will center on the position of the x,y mouse click.\n    //Depending on other user interface conditions, the rectangle may be green or red and of varying thickness.\n    \n    //REQUIREMENTS\n    // 1) Draw an empty rectangle with a given color and size centered around an x,y coordinate.\n    // 2) The rectangle coordinates and color will typically change once or twice per minute and\n    //    also when the background image dimensions change, which would typically occur once or twice\n    //    per minute.  \n    // 3) The thickness of the rectangle border is the differnce between the Inner and Outer coordinates.    \n    \n    //calc texture coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//get color of texture at the uv texture coordinates\n    vec3 backgroundcolor = texture(iChannel0, uv).xyz;\n    //get the mouse coordinates to be used as the center of the rectangle\n    vec2 ms = vec2(iMouse.xy / iResolution.xy);\n\n    //---- USER WOULD PASS IN THE FOLLOWING FROM THE HOST APP\n    //set the frame inner width and height\n    vec2 framesize = vec2(105, 125);\n    //set the frame thickness (range is 1.01 - 4.00). The frame grows outward only\n    float framethickness = 1.02;\n    //set the color of the rectangle frame\n    vec3 framecolor = vec3(0.0, 1.0, 0.0);\t//green\n    //set the opacity of the rectangle frame\n    float frameopacity = 0.5;\n    //----\n    \n    vec2 center = vec2(iMouse.x,iMouse.y),\n         Ro = vec2(framesize)/2.,\n         Ri = vec2(framesize - 2.0)/2.,\n         Uo = abs(fragCoord - center) / Ro,\n         Ui = abs(fragCoord - center) / Ri;\n    //calc a color which represents 'frame present' or 'no frame present' at this pixel coord\n    vec4 frm = vec4( max(Ui.x,Ui.y) > 1. && max(Uo.x,Uo.y) < framethickness); \n\n    //set the output color to be the color of the frame or background image\n    if (frm == vec4(1.0, 1.0, 1.0, 1.0))\n    {\n        //mix the rectangle frame color and opacity with the background color\n        vec3 clr = mix(framecolor, backgroundcolor, 1.0 - frameopacity);\n        fragColor = vec4(clr.rgb, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(backgroundcolor, 1.0);\n    }\n    \n    //not sure if this is faster than https://www.shadertoy.com/view/XlsBRB where the boundaries of\n    //the rectangle are defined by the host app.  Should we do the above calcs for every fragment or \n    //is it faster to evaluate with conditionals?  Not sure.  This is certainly more elegant though.\n}","name":"Image","description":"","type":"image"}]}