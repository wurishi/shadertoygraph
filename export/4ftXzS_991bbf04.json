{"ver":"0.1","info":{"id":"4ftXzS","date":"1714262623","viewed":124,"name":"Brute Force Area Lights","username":"danielhooper","description":"You don't need random sampling, radiance cascades, or other tricks if you just cast 300 rays per pixel!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","shadow","light","area","soft","emissive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(in vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nvec4 opU( vec4 d1, vec4 d2 ) {\n    return (d1.w<d2.w) ? d1 : d2;\n}\n\n// test\nvec4 sdf(in vec2 origin) {\n\n    vec2 m = vec2(sin(iTime), cos(iTime))*.9;\n    if (iMouse.z > 0.) m =  (iMouse.xy -iResolution.xy)/iResolution.y * 2. +  vec2(iResolution.y/iResolution.x + 1.,1.);\n    \n    vec4 distance;\n    distance = vec4(vec3(0.0,3.0,0.0)*(sin(iTime)+1.), sdCircle(origin - m, .2));\n    distance = opU(distance, vec4(1.,0.,0, sdBox(origin-vec2(sin(iTime/3.141592654) + .5,.3), vec2(.3, .1))));\n    distance = opU(distance, vec4(0.03,0.4,3.0, sdBox(origin-vec2(.0,.0), vec2(.4, .01))));\n    return distance;\n}\n\nvec4 castRay(in vec2 origin, in vec2 direction) {\n\n    float t = 0.;\n    \n    for (int i=0; i < 10; i++) {\n        vec4 s = sdf(origin + t*direction); \n        if (s.w < 0.01) return vec4(s.rgb, 1.);\n        t += s.w;\n        if (t > 4.) break;\n    }\n\n    return vec4(0.);\n}\n\nvec3 radiance(in vec2 origin) {\n\n    int ray_count = 300;\n    \n    vec3 sum = vec3(0);\n    \n    for (int i=0; i < ray_count; i++) {\n        float angle = (float(i) / float(ray_count)) * 2.0 * 3.14159;\n        vec2 dir = vec2(sin(angle), cos(angle));\n        \n        sum += castRay(origin, dir).rgb;\n    }\n    \n    return sum / float(ray_count);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 color = radiance(uv);\n  \n    // tonemap, convert to sRGB\n    color = ACESFitted(color);\n    color = linear_srgb(color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}","name":"Common","description":"","type":"common"}]}