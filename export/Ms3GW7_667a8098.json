{"ver":"0.1","info":{"id":"Ms3GW7","date":"1450036875","viewed":255,"name":"FullMoon","username":"kuvkar","description":"Trying to replicate a image from a book. can look around with mouse a littlebit. ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightDir = normalize(vec3(1.3, 2.1, -.2));\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n//////\n// https://iquilezles.org/articles/distfunctions\n//////\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n/////////\n/////////\n/////////\nfloat map(in vec3 rp)\n{\n    float d = sdBox(rp, vec3(0.65, 0.03, 0.1));\n    d += abs(sin(rp.z)) * 2.;\n    d += abs(sin(rp.x)) * 0.2;\n    vec4 tx = texture(iChannel0, rp.xz * .2, -100.0);\n    d -= smoothstep(0.0, .3, tx.r) * 0.14;\n\n    tx = texture(iChannel0, rp.xy * .11, -100.0);\n    d -= smoothstep(0.0, .1, tx.r) * 0.24;\n\td = max(d, -sdBox(rp + vec3(.0, 0.3, 0.0), vec3(2.2, .25, 2.5)));\n    return d;\n}\n\nfloat mapBroadPhase(in vec3 rp)\n{\n    return sdBox(rp, vec3(1.9, .9, .35) * .5);\n}\n\nvec4 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    p *= 2.0;\n    vec4 c1 = texture(tex, p.xy, -100.0);\n    vec4 c2 = texture(tex, p.yz, -100.0);\n    vec4 c3 = texture(tex, p.xz, -100.0);\n    \n    vec4 color = abs(dot(n, vec3(0.0, 0.0, 1.0))) * c1;\n    color += abs(dot(n, \tvec3(1.0, 0.0, 0.0))) * c2;\n    color += abs(dot(n, \tvec3(0.0, 1.0, 0.0))) * c3;\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat shadow(in vec3 rp)\n{\n    const float dist = 0.1;\n    float d = 1.0;\n    rp += lightDir * dist * 1.5;\n    \n    for (int i = 1; i < 3; ++i)\n    {\n        float m = map(rp);\n        d = min(d, clamp(m / dist, 0.0, 1.0));\n        rp += lightDir * max(m * 2.0, 0.01);\n    }\n    return d;\n}\n\nconst float bumpiness = .08;\nvec3 bump(in vec3 rp, in vec3 g)\n{\n    rp *= .5;\n    vec2 off = vec2(0.00008, 0.0);\n    \n    float xy = tex3D(iChannel1, rp + off.xyy, g).r - tex3D(iChannel1, rp - off.xyy, g).r;\n    float zy = tex3D(iChannel1, rp + off.yyx, g).r - tex3D(iChannel1, rp - off.yyx, g).r;\n    mat3 bmat;\n    bmat[0] = cross(g, vec3(0.0, 1.0, 0.0));\n    bmat[1] = cross(bmat[0], g);\n    bmat[2] = g;\n    \n    vec3 bmg = -cross( normalize(vec3(.0, bumpiness, xy)), normalize(vec3(bumpiness, .0, zy)) );\n    return bmat * bmg;\n}\n\nfloat bumpiness2d = .23;\nfloat WaterSpeed = 0.01;\n\nvec3 bump2d(in vec3 rp)\n{\n    rp.xz += iTime * WaterSpeed;\n    rp *= 1.5;\n    vec2 off = vec2(.0001, 0.0);\n    \n    float xy = texture(iChannel2, rp.xz + off.xy, -100.0).r - texture(iChannel2, rp.xz - off.xy, -100.0).r;\n    float zy = texture(iChannel2, rp.xz + off.yx, -100.0).r - texture(iChannel2, rp.xz - off.yx, -100.0).r;\n    vec3 bmg = -cross( normalize(vec3(bumpiness2d, xy, .0)), normalize(vec3(0., zy, bumpiness2d)) );\n    return bmg;\n}\n\nvec3 grad(in vec3 rp)\n{\n    \n    vec2 off = vec2(0.005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nbool getPointBroadPhase(inout vec3 rp, in vec3 rd)\n{\n    vec3 ro = rp;\n    \n    for (int i = 0; i < 100; ++i)\n    {\n        float dist = mapBroadPhase(rp);\n        if(dist < 0.0)\n        {\n            return true;\n        }\n        rp += rd * max(dist, 0.01);\n        if(length(ro - rp) > 2.0) return false;\n    }\n    return false;\n}\n\nbool getPoint(inout vec3 rp, in vec3 rd, inout vec3 point, inout float closest)\n{\n    vec3 ro = rp;\n    bool hit = false;\n    closest = 99.0;\n    point = ro;\n    int steps = 50;\n    for (int i = 0; i < steps; ++i)\n    {\n        float dist = map(rp);\n        \n        if(dist < closest)\n        {\n            closest = dist;\n            point = rp;\n        }\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * 0.1, 0.005);\n        if(length(ro - rp) > 2.) break;\n    }\n    return hit;\n}\n\nvec4 waterColor = vec4(0.1, 0.2, 0.6, 0.0);\n\nvec4 getColor(in vec3 rp, in vec3 rd, float closest)\n{\n\tvec4 color = vec4(.0);\n    vec3 g = grad(rp);\n    vec4 mountainColor = vec4(1.0);\n    mountainColor -= tex3D(iChannel1, rp, g) * 0.5;\n    \n    mountainColor = mix(mountainColor, vec4(0.1, 0.1, 0.0, 0.0), 0.6) * .6;\n\tmountainColor = mix(mountainColor, vec4(.15, 0., 0., 0.0), smoothstep(-0.1, 0.01, rp.y));\n    mountainColor = mix(mountainColor, vec4(.5), smoothstep(.08, .5 + abs(sin(rp.x * 15.0)) * 0.06, rp.y));\n    mountainColor = mix(mountainColor, waterColor, 0.2);\n    \n    vec3 bgrad = bump(rp, g);\n    float d = dot(bgrad, lightDir);\n    d = clamp(d, 0.0, 1.0);\n    mountainColor = mix(mountainColor, mountainColor * d, 1.);\n\t\n    \n    vec3 H = normalize(lightDir -rd);\n    float bm = dot(H, bgrad);\n    bm = clamp(bm, 0.0, 1.0);\n    bm = pow(bm, 5.0) * .2;\n    mountainColor += bm;\n    \n    mountainColor *= shadow(rp);\n    \n    float reflCol = smoothstep(0., 1., texture(iChannel2, rp.xz * .5 + vec2(iTime * WaterSpeed), -100.0).r);\n    mountainColor += clamp(dot(vec3(0., -1.0, -.4), g), 0.1, 1.0) * waterColor * reflCol * 0.4;\n    \n    color = mix(color, mountainColor, smoothstep(0.001, 0.0, closest));    \n    \n    \n\treturn color;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    float closest = 0.0;\n    vec3 point = vec3(0.0);\n    vec3 ro = rp;\n    \n    getPointBroadPhase(rp, rd);\n    //bool hit = false;\n    bool hit = getPoint(rp, rd, point, closest);\n    float colorAmount = 1.0;\n    \n    if(rp.y <= 0. && closest > 0.001)\n    {\n        rp = ro + (rd / dot(vec3(0.0, -1.0, 0.0), rd)) * ro.y;\n        color = mix(vec4(.0, 0.0, .3, 0.0), waterColor, smoothstep(0.0, .1, -rd.y));\n\t\t\n        \n        vec3 bm = bump2d(rp);\n        float bd = clamp(dot(lightDir, bm), 0.0, 1.0);\n        vec3 _rd = reflect(rd, bm);\n        \n        vec3 H = normalize(vec3(-0.4, .3, 1.0) - rd);\n        float sd = dot(H, bm);\n        sd = clamp(sd, 0.0, 1.0) * .95;\n        \n        float far = length(ro - rp);\n        color += mix(.0, pow(sd, 14.0), 1.) *  smoothstep(1.5, 0., far);;\n        \n        getPointBroadPhase(rp, _rd);\n        bool hit = getPoint(rp, _rd, point, closest);\n        rp = point;\n        colorAmount = .7;\n    }\n    else if(hit)\n    {\n        color = vec4(.0);\n\t    rp = point;\n    }else\n    {\n        color = mix(vec4(.0, 0.0, .3, 0.0), vec4(0.0), smoothstep(0.0, .4, rd.y));\n        vec3 moon = normalize(vec3(-.5, 0.25, 1.));\n        float md = clamp(dot(rd, moon), -0., 1.0);\n        md = pow(md, 120.0);\n        md = smoothstep(0.08, 0.1, md);\n        md *= mix(texture(iChannel0, rd.xy * 0.1, -100.0).r, 1.0, 0.6);\n        color += md * vec4(1., 1., 1., 0.0) * 1.1;\n        return;\n    }\n    \n    color += getColor(rp, rd, closest) * colorAmount;\n}\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    \n    mat3 m;\n    m[0] = r;\n    m[1] = u;\n    m[2] = f;\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    \n    fragColor = vec4(0.0, 0.0, 0.2, 0.0);\n    vec3 rd = normalize(vec3(uv, .7));\n    vec3 rp = vec3(0.5 + cos(iTime * 0.2), .017, -2. + sin(iTime * .2) * 1.);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= vec2(0.5);\n    \n    if(iMouse.z > 0.0)\n    {\n        rp = roty(m.x * 5.0) * rp;\n    }\n    \n    rd = lookat(rp, vec3(0.0, 0.2 + sin(iTime) * 0.05, 0.0)) * rd;\n    trace(rp, rd, fragColor);\n    \n}","name":"Image","description":"","type":"image"}]}