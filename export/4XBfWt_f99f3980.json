{"ver":"0.1","info":{"id":"4XBfWt","date":"1730085979","viewed":47,"name":"Ray Marcher With diff Lighting","username":"8InfinityTaco8","description":"Based on Art of Code Tutorials\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE&ab_channel=TheArtofCode\nI've added comments to every line so that i better understand what's going on for future reference as I've never done lighting/shadows of any kind before\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","sdf","lighting","shadows","diffuse","signeddisstance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Maximum number of steps for the raymarching algorithm\n#define MAX_STEPS 100\n// Maximum distance to march before giving up\n#define MAX_DIST 100.\n// Minimum distance to consider we've hit a surface\n#define SURF_DIST .01\n\n// Function to calculate the distance to the nearest surface from a point p\nfloat GetDist(vec3 point){\n    // Define a sphere with position (0,1,6) and radius 1\n    vec4 sphereParams = vec4(0, 1, 6, 1);\n    \n    // Calculate distance to sphere by getting length to sphere center and subtracting radius\n    float sphereDistance = length(point - sphereParams.xyz) - sphereParams.w;\n    \n    // Distance to ground plane (just the y coordinate since plane is at y=0)\n    float groundDistance = point.y;\n    \n    // Return minimum distance between sphere and plane\n    float minDistance = min(sphereDistance, groundDistance);\n    return minDistance;\n}\n\n// Main raymarching function - follows ray from origin (ro) in direction (rd)\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection){\n    // totalDistance is total distance marched\n    float totalDistance = 0.;\n    \n    // March ray forward until hitting something or exceeding limits\n    for(int i = 0; i < MAX_STEPS; i++){\n        // Calculate current point along ray\n        vec3 currentPoint = rayOrigin + rayDirection * totalDistance;\n        // Get distance to nearest surface at this point\n        float stepDistance = GetDist(currentPoint);\n        // March forward by this distance (since we know we can't hit anything closer)\n        totalDistance += stepDistance;\n        // Break if we've gone too far or hit something\n        if(totalDistance > MAX_DIST || stepDistance < SURF_DIST) break;\n    }\n    return totalDistance;\n}\n\n// Calculate surface normal at a point by sampling distances in nearby points\nvec3 GetNormal(vec3 point){\n    float centerDistance = GetDist(point);\n    // Small offset for sampling nearby points\n    vec2 epsilon = vec2(.01, 0);\n    \n    // Calculate normal by sampling distances in x,y,z directions\n    vec3 normal = centerDistance - vec3(\n        GetDist(point-epsilon.xyy), // Sample in x direction\n        GetDist(point-epsilon.yxy), // Sample in y direction\n        GetDist(point-epsilon.yyx)  // Sample in z direction\n    );\n    \n    return normalize(normal);\n}\n\n// Calculate lighting at a point\nfloat GetLight(vec3 surfacePoint){\n    // Define light position that moves in a circle over time\n    vec3 lightPosition = vec3(0, 5, 6);\n    lightPosition.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    // Get direction to light\n    vec3 lightDirection = normalize(lightPosition - surfacePoint);\n    // Get surface normal\n    vec3 surfaceNormal = GetNormal(surfacePoint);\n    \n    // Calculate diffuse lighting (dot product of normal and light direction)\n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0., 1.);\n    // Check for shadows by marching ray from point to light\n    float shadowDistance = RayMarch(surfacePoint + surfaceNormal * SURF_DIST * 2., lightDirection);\n    // If something blocks the light, reduce brightness\n    if(shadowDistance < length(lightPosition-surfacePoint)) diffuse *= .1;\n    \n    return diffuse;\n}\n\n// Main shader function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Convert pixel coordinates to UV coordinates centered at screen center\n    vec2 uvCoords = fragCoord;\n    uvCoords -= .5 * iResolution.xy;\n    uvCoords /= iResolution.y;\n    // Initialize color\n    vec3 pixelColor = vec3(0, 0, 0);\n    \n    // Define ray origin (camera position)\n    vec3 cameraPos = vec3(0, 1, 0);\n    // Calculate ray direction for this pixel\n    vec3 rayDir = normalize(vec3(uvCoords.x, uvCoords.y, 1));\n    \n    // March ray from camera through this pixel\n    float hitDistance = RayMarch(cameraPos, rayDir);\n    \n    // Calculate point where ray hits surface\n    vec3 hitPoint = cameraPos + rayDir * hitDistance;\n    \n    // Calculate lighting at hit point\n    float diffuseLight = GetLight(hitPoint);\n    pixelColor = vec3(diffuseLight);\n    \n    // Set final pixel color with full alpha\n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shape Signed Distance Functions (SDFs)\n// Sphere SDF\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// Box SDF\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// Torus SDF\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// Capsule SDF\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// Plane SDF\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    // n must be normalized\n    return dot(p, n) + h;\n}\n\n// Cylinder SDF\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cone SDF\nfloat sdCone(vec3 p, vec3 c) {\n    float q = length(p.xy);\n    return dot(c.xy, vec2(q, p.z));\n}\n\n// Hexagonal Prism SDF\nfloat sdHexPrism(vec3 p, vec2 h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n    vec2 d = vec2(length(p.xy - vec2(clamp(p.x, -h.x, h.x), h.x)), p.z - h.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Rounded Box SDF\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) - r;\n}\n\n// Ellipsoid SDF\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n","name":"Common","description":"","type":"common"}]}