{"ver":"0.1","info":{"id":"4dVBzz","date":"1527492499","viewed":763,"name":"Toolbox of Noisey Goodness","username":"James_Harnett","description":"32 bit Integer Hash Functions that seem to have about 27 visually random bits\nhash1 uses the max number of bits for a float\nhash2 uses 14 good bits each component\nhash3 uses 9 good bits each component\nhash4 uses 7 good bits each component","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["noise","hash","rand","rng"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This is free and unencumbered software released into the public domain. http://unlicense.org/\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(ivec2(fragCoord)+2*iFrame);\n\tint cx = int(fragCoord.x) - (int(iResolution.x)>>1);\n    int cy = int(fragCoord.y) - (int(iResolution.y)>>1);\n    \n    float h1 = hash1(coord2(p));\n    vec2 h2 = hash2(coord2(p));\n    vec3 h3 = hash3(coord2(p));\n    vec4 h4 = hash4(coord2(p));\n    \n    vec3 col;\n   \tif(cx < 0 && cy < 0)col = vec3(h1);\n    if(cx > 0 && cy < 0)col = vec3(h2.x * h2.y);\n   \tif(cx < 0 && cy > 0)col = vec3(h3);\n    if(cx > 0 && cy > 0)col = vec3(h4.xyz * h4.w);\n       \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}