{"ver":"0.1","info":{"id":"Xl3SRs","date":"1481052476","viewed":114,"name":"#Devember 2016 - day 05","username":"theGiallo","description":"Added round box. Now rays have a material, not indexed. Tomorrow I will try indexed materials and compare performance.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define MPt Material_Point\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nmin( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmax( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( max( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n    #if 0\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n    #else\n\tmat4 m = Rx * Ry * Rz;\n\tvec4 pp = vec4(p,1.0) * m;\n    return pp.xyz;\n    #endif\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate( -a, p );\n}\n\nMaterial_Point\nunion_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance < p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\nvec3 sky_color;\nMaterial_Point\nmap( in vec3 pos )\n{\n    #if 0\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n    #else\n    vec3 color = ORANGE_RGB;\n    #endif\n    \n    Material_Point res;\n    res.distance = 1e38;\n    \n    Material plastic_m;\n    plastic_m.color = vec3(1.0);\n    plastic_m.diffuse_reflection  = 1.0;\n    plastic_m.specular_reflection = 1.0;\n    plastic_m.ambient_reflection  = 1.0;\n    plastic_m.shininess           = 15.0;\n\n    Material floor_m;\n    plastic_m.color = vec3(1.0);\n    floor_m.diffuse_reflection  = 1.0;\n    floor_m.specular_reflection = 0.2;\n    floor_m.ambient_reflection  = 0.5;\n    floor_m.shininess           = 1.0;\n\n    Material orange_m = plastic_m;\n    orange_m.color = ORANGE_RGB;\n    \n    Material red_m = plastic_m;\n    red_m.color = vec3(1.0,0.0,0.0);\n    Material green_m = plastic_m;\n    green_m.color = vec3(0.0,1.0,0.0);\n    Material blue_m = plastic_m;\n    blue_m.color = vec3(0.0,0.0,1.0);\n\n    float sr = 0.5;\n    float sd = 0.5;\n    #if 0\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),\n                          orange_mat ),\n\t      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),\n                          orange_mat ) );\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),\n               orange_mat ),\n          res );\n    #endif\n    \n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ), plastic_m ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ), red_m ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ), green_m ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ), blue_m ), res );\n    res =\n       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),\n                      orange_m ),\n                 res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),\n                         orange_m ),\n                    res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),\n                         orange_m ),\n                    res );\n    res = union_op( MPt( plane_sd( pos ),\n                         change_color( floor_m, vec3( 0.7 + 0.3 * mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 ) ) ) ),\n                    res );\n    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),\n                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb ) ),\n                    res );\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = rgb_from_hsv(vec4(0.57,0.5,0.7,1.0));\n    sky_color = col.rgb;\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, -1.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n    vec2 d = vec2(3.0,5.0);\n    vec3 camera_pos;\n    camera_pos.y = cos(time) * d.y;\n    camera_pos.x = sin(time) * d.x;\n    camera_pos.z = 0.5;\n    // camera_pos = rotate( vec3(0.0,0.0,time), vec3(2.5,0.0,1.0) * 2.0 );\n    vec3 look = normalize( -vec3(camera_pos.x,\n                                 camera_pos.y,\n                                 camera_pos.z) );\n    camera_pos.z += 1.5;\n    camera_pos.x += 2.0;\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    MPt mp;\n    float t = 0.0, t_max = 1e2;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted cubes\n        t += mp.distance * 0.7;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        // col.rgb = 0.5 + normal * 0.5;\n        float diffuse = max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mp.material.shininess  );\n        float ambient = 0.3;\n        col.rgb = ( diffuse * mp.material.diffuse_reflection +\n                    ambient * mp.material.ambient_reflection ) * mp.material.color +\n                  spec * mp.material.specular_reflection * sun_specular_color;\n    } else\n    if ( t == 0.0 )\n    {\n        col.rgb = mp.material.color / ( 1.0 - 20.0 * mp.distance );\n    }\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}