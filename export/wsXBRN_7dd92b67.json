{"ver":"0.1","info":{"id":"wsXBRN","date":"1587847767","viewed":245,"name":"The striped box","username":"Krafpy","description":"Along a dark tunnel where light moves step by step.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N_ITER 80.\n#define N_REF 3.\n#define PI 3.1415926535\n\n#define BOX vec3(5, 5, 1000)\n\n\n// some chaotic function\nfloat hash(){\n    float time = iTime;\n\treturn clamp(floor(fract(sin(time)*cos(time))*2.*sin(time*1.45)+0.5), 0., 1.);\n    //float time = mod(iTime*0.01, 50.);\n    //return abs(floor(cos(3.*fract(exp(.2*(time*time+30.))))));\n}\n\n// 2D rotation matrix\nmat2 rot(float a){ // rotation matrix\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\n// box sdf\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// sin pulse function based on time : control the cube shape\nfloat pulse(){\n    float x = mod(iTime*10., 15.);\n    if(x > PI*2.) return 0.;\n    return 0.5 + 0.5*sin(x-PI/2.);\n}\n\nfloat map(in vec3 p, out int id){\t\n    float d;\n    \n    // cube\n    vec3 c = vec3(0., -3.5, 7); // center of the cube\n    // animate the cube\n    vec3 q = p - c;\n    float t = iTime*0.4;\n    q.xz *= rot(iTime*0.5);\n    q.yz *= rot(iTime*0.6);\n    q.xy *= rot(iTime*0.8);\n    // sdf with displacement\n    float d1 = box(q, vec3(0.7)) + 0.1/distance(c, p) * pulse();\n    \n    // outer box (walls)\n   \tfloat d2 = -box(p, BOX);\n    \n    if(d1 < d2){\n    \tid = 0; d = d1;\n    } else {\n    \tid = 1; d = d2;\n    }\n    return d;\n}\n\nfloat map(in vec3 p){ // overloaded simplified method\n   int _; return map(p, _);\n}\n\nvec3 getNormal(vec3 p) {\n    const float eps = 0.0001;\n    return normalize(vec3(\n        map(vec3(p.x + eps, p.yz)) - map(vec3(p.x - eps, p.yz)),\n        map(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n        map(vec3(p.xy, p.z + eps)) - map(vec3(p.xy, p.z - eps))\n    ));\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd, out float shad, out int id){\n    bool hit = false;\n    float h, t = 0.;\n    \n    for(float i = 0.; i < N_ITER; ++i){\n    \th = map(ro + rd * t, id);\n       \t\n        if(h < 0.001){\n            shad = i/N_ITER;\n            hit = true;\n            break;\n        }\n        \n        t += h;\n    }\n\t\n\treturn hit ? t : 0.;\n}\n\n// get texture intensity : create the stripe pattern\nfloat wall(float z, vec3 n){\n   \n    float t = iTime*4.;\n    float w = 1.5; // width of a stripe\n    float r = 1.15; // ratio light surface / drak reflective surface per stripe \n\n\n    float u = abs(z - BOX.z) - t; // position along depth axis\n    float a = mod(u, w*r);\n    float k = step(w, a); // black or bright surface\n\n    float h = hash();\n    if(h == 0.)\n        if(n.x != 0.){k = 1. - k;} // change animation when hash changes\n\n    float c = h == 0. ? 7. : 12.; // number of stripes per wave of light\n    float s = h == 0. ? 2. : 15.; // waves speed\n    float d = h == 0. ? 1. : -1.; // direction of light waves\n    float st = floor(iTime*s);\n    // create the stripe pattern, with uniform color\n    // and make light stripes move forward at st speed with steps\n    float b = floor(mod(d*u + st*w*r , c*w*r)/w/r);\n\n    k /= clamp(exp(b*0.4)*1.7, 1., 100.); // decay color intensity\n\n    return k;\n}\n\n\nvec3 matcol(){ // color of the cube\n    return vec3(1., 1., 5.); \n}\n\nvec3 matcol(float k){ // color of the walls, depends on k\n    return k <= 0. ?\n        vec3(0.4) :\n    \tvec3(1., 0.5, 0.7) * k * 4.;\n}\n\n\nvec3 noise(vec3 p){\n    vec3 tex =\ttexture(iChannel0, p.xz).rgb;\n    tex += \t\ttexture(iChannel0, p.yx).rgb;\n    tex += \t\ttexture(iChannel0, p.yz).rgb;\n    return tex;\n}\n\nvec3 disp1(vec3 p){ // normal displacement for the cube's surface\n\treturn noise(p)/3.*0.015;\n}\n\nvec3 disp2(vec3 p){ // normal displacement for the reflective surfaces of the walls\n\treturn 0.1/noise(p*0.25)/3.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // ray\n    vec3 ro = vec3(0., -3., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // animate the camera\n    rd.xy *= rot(sin(iTime*0.5)*0.5);\n    rd.yz *= rot(sin(iTime)*0.1);\n    \n    // pixel color\n    vec3 col = vec3(0.);\n        \n    // RAYMARCHING\n\n    int id = -1; // id of the object we hit\n    float shad; // ration number of steps / number of iterations\n    \n    float t, k;\n    \n    float i;\n    for(i = 0.; i <= N_REF; ++i){\n    \tt = raymarch(ro, rd, shad, id);\n        \n        if(t == 0.){ // cancel if error detection\n            col = vec3(0.);\n            break;\n        }\n        \n        vec3 p = ro + rd * t;\n        vec3 n = getNormal(p);\n        \n        vec3 scol;\n        \n        float decay = clamp((1.-shad-exp(p.z*0.05)*0.01), 0., 1.); // fade along depth axis\n        \n        if(id == 0){ // if we hit the cube\n            scol = matcol() * decay; // get the material color, with fading along depth axis\n            n += disp1(p); // normal displacement\n        } else { // if we hit the walls\n            k = wall(p.z, n);\n            scol = matcol(k) * decay;\n            n += disp2(p);\n        }\n        \n        if(i == 0.) col = scol; // initial color\n        else col *= scol * (1.-t*0.05); // reflection with fading proportional to length of the reflected ray\n        \n        if(k > 0.) break; // no reflection if we hit a light stripe\n        \n        // reflect ray\n        ro = p + n * 0.01;\n        rd = reflect(rd, n);\n    }\n    \n    // some post processing\n    col *= 1.1;\n    col += vec3(0., 0.1, 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}