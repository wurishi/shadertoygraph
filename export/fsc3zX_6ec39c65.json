{"ver":"0.1","info":{"id":"fsc3zX","date":"1630304805","viewed":187,"name":"Kaleidoscope 2 (atz)","username":"ilyaev","description":"Kaleidoscope example","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define PI 3.14159265359\n#define PI2 6.28309265359\n\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898 + floor(1.), 4.1414))) * 43758.5453);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvec3 renderPlasmaOriginal(vec2 uv) {\n    for(float i = 1.0; i < 10.0; i++){\n        uv.x += 0.6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + iTime);\n    }\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    return col/(2.1*abs(cos(iTime-uv.y-uv.x)));\n}\n\n\nfloat sdCircle(vec2 p, vec2 pos, float radius) {\n    return distance(p, pos) - radius;\n}\n\nmat2 rot2d(float a) {\n    return mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n}\n\nvec3 background(vec2 uv) {\n    uv += vec2(0.);\n    float d = 1. - step(.5, length(uv));\n    float a = atan(uv.x, uv.y) + PI;\n\n    float segments = 18.;\n    float sector = floor(segments * (a/PI2));\n\n\n    vec3 color = vec3(0.);\n\n    if (a < PI) {\n        color = vec3(.9, .2, .1) * d;\n    } else {\n        color =vec3(.5, .6, .2) * d;\n    }\n\n    float box = sdBox(abs(uv * rot2d(PI/3.3)), vec2(.3, .5));\n    if (a < PI/2. || (a > PI && a < PI + PI/2.)) {\n        float d = (1. - step(.0, box));\n        if (d > 0.) {\n            color = d * vec3(.0, .4, .9);\n        }\n        color -= (1. - step(.0, abs(box) - .005)) * vec3(2.);\n    }\n\n    float box2 = sdBox(abs(uv * rot2d(-PI/5.)), vec2(.3, .5));\n    float d1 = (1. - step(.0, box2));\n    if ( a < PI && a > PI/2.) {\n        if (d1 > 0.) {\n            color = d1 * vec3(.5, .6, .2);\n        }\n        color -= (1. - step(.0, abs(box2) - .005)) * vec3(2.);\n\n    }\n\n    if ( a > PI + PI/2. ) {\n        if (d1 > 0.) {\n            color = d1 * vec3(.9, .2, .1);\n        }\n        color -= (1. - step(.0, abs(box2) - .005)) * vec3(2.);\n    }\n\n\n    color *= step(.005, abs(uv.x));\n    color *= step(.005, abs(uv.y));\n\n\n    return max(vec3(0.), color / abs(sin(uv.y*(13. + cos(iTime)*5.) + iTime + cos(uv.x*(20. + sin(iTime)*5. + sin(uv.y*12.)*4.) + iTime*2.)))*.48);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float n = n21(vec2(floor(iTime)));\n    float n1 = n21(vec2(floor(iTime) + 1.));\n    float nn = mix(n, n1, fract(iTime));\n    \n    float _SegmentCount = 7.;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 shiftUV = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    shiftUV *= rot2d((nn - .5) * PI/2.);\n\n\n    float radius = sqrt(dot(shiftUV, shiftUV));\n    float angle = atan(shiftUV.y, shiftUV.x) + mouse.x;\n\n    float segmentAngle = PI2 / _SegmentCount;\n\n    float wid = floor((angle + PI) / segmentAngle);\n\n    angle -= segmentAngle * floor(angle / segmentAngle);\n\n    angle = min(angle, segmentAngle - angle);\n\n    vec2 uv = vec2(cos(angle), sin(angle)) * radius;// + sin(iTime) * 0.1;\n\n\n    vec3 color = vec3(0.);\n    \n\n    color += background((uv/1.4 + vec2(sin(iTime - uv.y*(3. + nn))*.08, cos(iTime + uv.x)*.05)) * rot2d(iTime*.3 + uv.x*sin(iTime + uv.y/4. + uv.x*4.) * 4.*nn));\n    color += renderPlasmaOriginal(uv * rot2d(iTime*.2 + nn) + vec2(sin(iTime + uv.x - nn * 2.), cos(iTime + uv.y))*(.2 + nn *.1)) *.3;\n  \n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}