{"ver":"0.1","info":{"id":"ll33Wr","date":"1468693453","viewed":618,"name":"Fractal Painter","username":"huwb","description":"Mandelbrot iteration attached to a particle via a damped spring. Initial velocity of particle rotates over time. Mouse to change paint spatially varying damping constant (has greatest effect near screen center)","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["fractal","dynamicfractal","paint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Follow up work to https://www.shadertoy.com/view/ll33zN\n\n// Fractal iteration applies forces to a particle instead of simply moving\n// a point (zv is particle velocity). This is done using a damped spring - kp\n// and kd are the spring and damping constants.\n\n// The initial velocity of the particle (zv) is rotated over time. This shader began life\n// as a study of the affect of the initial velocity, however i found this has a very regular\n// and uninteresting effect on the result.\n\n// Turns out it is much more interesting to paint a spatially varying damping constant, this\n// allows the result to be warped in interesting ways.\n\n// I used a simple heuristic to smooth the visualisation, not sure if its new but\n// might be useful for others. See inline doc below.\n\n// Originally branched from iq's shader: https://www.shadertoy.com/view/4df3Rn\n\n// Keys:\n\n// D - show painted damping buffer\n// S - save snapshot of painted damping buffer\n// Z - revert to last snapshot\n// C - clear damping buffer\n\n#define ITERS 39\n#define ESCAPE_RADIUS 256.\n#define KEY_D (68.5/256.)\n#define KEY_Y (89.5/256.)\n\nvec2 zToUv( vec2 z )\n{\n    // damping texture lookup based on normalized position relative to escape radius\n    z = z/ESCAPE_RADIUS;\n    \n    //warp a bunch, otherwise it only samples near the very center of the texture\n    float l = length(z);\n    if( l > 0.0001 )\n    {\n        z = pow(l,0.5) * z/l;\n    }\n    \n    z += 0.5;\n    \n    z /= iResolution.xy/vec2(640.,360.);\n    \n    return z;\n}\n\n// sample a damping constant from the texture (buf A)\nfloat GetKd( vec2 z )\n{\n    vec2 uv = zToUv( z );\n    return textureLod( iChannel0, uv, 0. ).x;\n}\n\nfloat mouseVal( vec2 z )\n{\n    if( iMouse.z == 0. )\n        return 0.;\n    \n    vec2 uv = zToUv( z );\n    \n    float rn = length(iMouse.xy/iResolution.xy - 0.5);\n    \n    vec2 m = iMouse.xy;\n    //m *= vec2(640.,360.)/iResolution.xy;\n    m /= iResolution.xy;\n    \n    float r = (rn+0.1) * 32.;\n    return smoothstep( r, r/2., length((uv-m) * vec2(640.,360.)) );\n    return 0.;\n}\nbool key( float k ) { return texture( iChannel1, vec2(k,0.5/3.0) ).x > 0.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // D to visualise damping\n    if( key(KEY_D) )\n    {\n        fragColor = sqrt(textureLod( iChannel0, fragCoord/iResolution.xy, 0. ));\n        return;\n    }\n    \n    float kp = .1; // spring gain (proportional)\n    float kd = .1; // damping (differential)\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    float time = iTime;\n\n    vec2 c = 5.*p.xy;\n\n    float l = 0.0;\n    // initial particle pos\n    vec2 z  = vec2(0.);\n    // initial particle vel\n    float t = 1.*iTime;\n    \n    \n    vec2 ivel = .75*vec2(-cos(t),sin(t));\n    //if( iMouse.z > 0. )\n    //    ivel = 2.*(iMouse.xy/iResolution.xy-.5);\n    vec2 zv = -ivel;\n    float maxMouseVal = 0.;\n    \n    zv *= -1.;\n    vec2 lastz = z;\n    for( int i=0; i<ITERS; i++ )\n    {\n        kd = GetKd(z);\n        maxMouseVal = max( maxMouseVal, mouseVal( z ) );\n        \n        // z = z*z + c\t\t\n        vec2 newz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        \n        // update particle pos\n        z += zv;\n        // update particle vel\n        zv += (newz-z)*kp + (vec2(0.)-zv)*kd;\n\n        if( dot(z,z)>(ESCAPE_RADIUS*ESCAPE_RADIUS) ) break;\n        lastz = z;\n        l += 1.0;\n    }\n\n    // quasi-smooth fractal using a heuristic (the analytic smooth factor from https://www.shadertoy.com/view/4df3Rn\n    // didnt work due to the dynamics). not sure if this is a new idea or not. the code\n    // computes a smooth alpha from the last iterate radius, the current iterate radius,\n    // and the escape radius:\n    //\n    //   |lastz|          escape_radius  |z|\n    //      |------------------|----------|\n    //                        70%\n    // it then powers it up a little for good measure. \n    //\n    float alph = 0.;\n    if( l <float(ITERS) )\n    {\n        float llz = length(lastz); // <= esc\n        float lz = length(z); // > esc\n        // alpha computed by comparing last radius, this radius, and esc thresh\n        alph = (ESCAPE_RADIUS-llz)/(lz-llz);\n        // magic pow to smooth out gradient\n        alph = pow(alph,.7);\n    }\n    \n    // tweaked version of iq's\n    vec3 col = 0.5 + 0.5*cos( 2. + (l+alph)*.16 + vec3(0,0.6,1.0));\n    col = smoothstep(0.2,1.1,col);\n\n    vec2 vmarker = (.5+ivel/2.)*iResolution.xy;\n\n    // draws yellow dot for starting vel\n    //float mouseWt = smoothstep(6.,5.,length(fragCoord-vmarker));\n    //col = mix(col, vec3(1.,1.,0.), mouseWt);\n    \n    fragColor = vec4( col, 1.0 );\n    \n    // black bars (im not really sure why)\n    //fragColor *= 1.-step(.4,abs(fragCoord.y/iResolution.y-.5));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Friction buffer!\n#define KEY_C (67.5/256.)\n#define KEY_Y (89.5/256.)\n#define KEY_Z (90.5/256.)\n\nbool key( float k ) { return texture( iChannel1, vec2(k,0.5/3.0) ).x > 0.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // undo\n    if( key(KEY_Z) )\n    {\n        // read from undo buffer - buf B\n        fragColor = texture(iChannel2, fragCoord/iResolution.xy, 0.);\n        return;\n    }\n    \n    fragColor.x = texture(iChannel0, fragCoord/iResolution.xy, 0.).x;\n    \n    // default value is 0.1\n    if( iFrame == 0 || key(KEY_C) )\n    {\n        fragColor = vec4(0.1,0.,0.,0.);\n        return;\n    }\n    \n    float rn = length(iMouse.xy/iResolution.xy - 0.5);\n    //if( rn > 0.5 )\n    //    fragColor.x = 0.1;\n    \n    if( iMouse.z > 0. )\n    {\n        vec2 m = iMouse.xy;\n        m *= vec2(640.,360.)/iResolution.xy;\n        float r = (rn+0.1) * 32.;\n        fragColor.x += 0.02*smoothstep( r, r/2., length((fragCoord-m) * vec2(640.,360.)/iResolution.xy) );\n    }\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define KEY_A (65.5/256.)\n#define KEY_D (68.5/256.)\n#define KEY_S (83.5/256.)\n#define KEY_Z (90.5/256.)\n\nbool key( float k ) { return texture( iChannel1, vec2(k,0.5/3.0) ).x > 0.; }\n\n// Save buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy, 0.);\n    \n    // default value is 0.1\n    if( iFrame == 0 )\n        fragColor.x = 0.1;\n    \n    // save\n    if( key(KEY_S) )\n    {\n        // read from damping buffer - buf A\n        fragColor = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n        return;\n    }\n}\n","name":"Buf B","description":"","type":"buffer"}]}