{"ver":"0.1","info":{"id":"l3jBDG","date":"1730061491","viewed":78,"name":"perlin_domain_warp_ftmo","username":"featmo","description":"pelin noise with domain warping","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","warp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash2D(vec2 p) {\n    p = vec2(dot(p, vec2(128.1, 351.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\nfloat perlin(vec2 uv){\n    // Perlin Noise https://adrianb.io/2014/08/09/perlinnoise.html\n    vec2 fuv = floor(uv);\n    vec2 cuv = ceil(uv);\n    \n    vec2 c0 = vec2(fuv.x, cuv.y);\n    vec2 c1 = vec2(cuv.x, cuv.y);\n    vec2 c2 = vec2(fuv.x, fuv.y);\n    vec2 c3 = vec2(cuv.x, fuv.y);\n    \n    vec2 n0 = hash2D(c0);\n    vec2 n1 = hash2D(c1);\n    vec2 n2 = hash2D(c2);\n    vec2 n3 = hash2D(c3);\n    \n    vec2 dir0 = uv-c0;\n    vec2 dir1 = uv-c1;\n    vec2 dir2 = uv-c2;\n    vec2 dir3 = uv-c3;\n    \n    float g0 = dot(n0, dir0);\n    float g1 = dot(n1, dir1);\n    float g2 = dot(n2, dir2);\n    float g3 = dot(n3, dir3);\n\n    vec2 t = uv-fuv;\n    \n    float mix0 = mix(g0, g1, t.x);\n    float mix1 = mix(g2,g3,t.x);\n    float d = mix(mix1, mix0, t.y);\n    \n    return d;\n\n}\n\nfloat perlinOctave(vec2 uv, int oct, float freq, float amp, float persistance){\n    // Octave Perlin Imp\n    float total = 0.;\n    float maxv = 0.;\n\n    for(int i = 0; i < oct; i++){\n        total += perlin(uv*freq)*amp;\n        maxv += amp;\n        amp *= persistance;\n        freq *= 2.25;\n    }\n    \n    float d = (total/maxv)+.6;\n    \n    return d;\n}\n\n//fractional brownian https://iquilezles.org/articles/fbm/\nfloat fbm(vec2 uv){\n    return perlinOctave(uv, 16, 2., 1., 0.5);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv *= 1.75; //scale uv's\n    uv.x *= aspect; //fix stretching\n    \n    vec2 hp = vec2(fbm(uv), fbm(uv+vec2(2., 4.)) );\n    vec2 gp = vec2(fbm(uv+hp+vec2(2,6.)), fbm(uv+hp+vec2(.2,.6)) );\n    vec2 kp = vec2(fbm(uv+gp+vec2(1,8.)), fbm(uv+gp+vec2(4.,20)) );\n    float d = fbm(uv+(3.*(iTime*0.1))+gp);\n    //d = fbm(uv+fbm(uv+fbm(uv))); // alternative \n    \n    d = (max(d, 0.0)-0.67)*12.; // b/w adjustment\n     \n    vec3 c = mix(vec3(0.0, .2, .3), vec3(.3,.4,.1), d);\n       \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}