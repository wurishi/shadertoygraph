{"ver":"0.1","info":{"id":"4tjcWK","date":"1581526689","viewed":46,"name":"[TP3]Illuminated Sphere","username":"Sando","description":"Illumination of virtual 3D Sphere.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material\n{\n    float Ka; // ambiant\t\tcoefficient\n    float Kd; // diffuse\t\tcoefficient\n    float Ks; // specular\t\tcoefficient\n    float Kn; // specular power coefficient\n};\n\n// Camera Parameters\nconst vec3  cameraPos \t\t= vec3(6, 4, -5);\nconst vec3 \tcameraTarget\t= vec3(3, 1, -8);\nconst float cameraFovY\t\t= 80.0;\n\n//Light Parameters\nconst vec3\tambiantCol\t= vec3(0,0,1);\nconst vec3\tlightCol\t= vec3(1,1,1);\nconst vec3 \tlightPos \t= vec3(8, 10, -12);\n\n// Sphere Parameters\nconst vec3 \t\tspherePos\t\t= cameraTarget + vec3(0, 1, 2);\nconst float \tsphereRadius\t= 1.0;\nconst vec3\t\tsphereCol\t\t= vec3(1,0,0);\nconst Material \tsphereMat\t\t= Material(0.2, 0.7, 1.0, 50.0);\n\n\nvoid computeCameraRayFromPixel(vec2 fragCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    float fragX = fragCoord.x - iResolution.x/2.0;\n    float fragY = iResolution.y/2.0 - fragCoord.y;\n    float fragZ = iResolution.y/(2.0*tan(radians(cameraFovY/2.0)));\n \n    vec3 cz = normalize(cameraTarget - cameraPos); \n    \n    vec3 tmpCy = vec3(0, -1, 0);\n    vec3 tmpCx = cross(tmpCy, cz);\n    \n    vec3 cx = normalize(tmpCx);\n    vec3 cy = cross(cz, cx);\n    \n    rayDir = normalize(fragX*cx + fragY*cy + fragZ*cz);\n    rayPos = cameraPos;\n}\n\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersectS, out vec3 normalS)\n{\n    float intersectDist = 0.0;\n//  float intersectDist;\n    \n    vec3 camSph = spherePos - rayPos;\n\tfloat proj = dot(camSph, rayDir);\n    float intersect = pow(sphereRadius, 2.0)+ pow(proj,2.0) - pow(length(camSph),2.0);\n    \n    if(intersect > 0.0){\n        intersectDist = proj - sqrt(intersect);\n    }\n    \n    intersectS = rayPos + rayDir*intersectDist;\n    normalS = normalize(intersectS - spherePos);\n    \n    return intersectDist;\n}\n\nvec3 computerPhongShader(vec3 sphereCol, Material sphereMat, vec3 normalS, vec3 L, vec3 R, vec3 V){\n    vec3 ambiant \t= sphereMat.Ka*ambiantCol;\n    float cosTheta\t= max(dot(normalS,L),0.0);\n    float cosAlpha\t= max(dot(R, V),0.0);\n    \n    vec3 diffuse \t= sphereMat.Kd*lightCol*sphereCol*cosTheta;   \n    vec3 specular\t= sphereMat.Ks*lightCol*pow(cosAlpha,sphereMat.Kn) ;\n    return ambiant + diffuse + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Compute the ray to be casteed through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    \n    //Test ray-sphere intersection7\n    vec3 intersectS, normalS;\n    float res = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersectS, normalS);\n    \n    if(res > 0.0){\n\t\t// Unit-vector from surface point to light\n        vec3 L = normalize(lightPos - intersectS);\n        // Unit-vector of reflection direction of the light at the surface point\n        vec3 R = normalize(2.0*normalS*dot(normalS,L)-L);\n        // Unit-vector from surface point to camera\n        vec3 V = normalize(cameraPos - intersectS);\n        \n        \n        //Apply Phong shading to compute the color of surface point as seen on camera\n       // fragColor = vec4(computerPhongShader(sphereCol, sphereMat, normalS, L, R, V), 1.0);\n        fragColor = vec4(computerPhongShader(sphereCol, sphereMat, normalS, L, R, V), 1.0);\n    } else {\n        fragColor = vec4(0.3, 0.3, 0.3, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}