{"ver":"0.1","info":{"id":"flXBDM","date":"1650944089","viewed":54,"name":"Totalistic 5-n cellular automat","username":"Envy24","description":"5-neighbor totalistic cellular automat (Von Neuman neighbourhood).\n\nMore cellular automats: https://www.shadertoy.com/playlist/fXVSRy","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","wolfram","4neighbor"],"hasliked":0,"parentid":"7lsfWN","parentname":"Totalistic 4-n cellular automat"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) \n{ \n    O = TEXF0(SC);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE true\n#define DEAD  false\n#define READ_CELL(P) (TEX0(TEX_COORDS(P)).r)\n\nint read_neighbors_states(vec2 SC)\n{\n    /* Kernel:\n                   t\n                 l m r\n                   b\n    */\n\n    float t  = READ_CELL(SC + vec2( 0,  1));\n    float r  = READ_CELL(SC + vec2( 1,  0));\n    float b  = READ_CELL(SC + vec2( 0, -1));\n    float l  = READ_CELL(SC + vec2(-1,  0));\n    float m  = READ_CELL(SC);\n\n    return // max sum == 5\n         int(l == 0.0) +\n         int(b == 0.0) +\n         int(r == 0.0) +\n         int(t == 0.0) +\n         int(m == 0.0);\n}\n\nbool check_rule(\n    in int rule,\n    in vec2 SC)\n{\n    int num_of_alive_neighbors = read_neighbors_states(SC);\n    \n    float m  = READ_CELL(SC);\n    \n    return \n        m == 0.0 ?\n           ((rule >> (num_of_alive_neighbors + 6)) & 1) != 0 :\n           ((rule >> num_of_alive_neighbors) & 1) != 0;\n}\n\nfloat init_one_pixel_in_center(vec2 SC)\n{\n    SC = floor(SC);\n    vec2 M = vec2(floor(R.x * 0.5), floor(R.y * 0.5));\n    return \n        SC.y == M.y && SC.x == M.x ?\n            0.0 :\n            1.0;\n}\n\n\nfloat randomize_part_of_frame(\n    in vec2 SC,\n    float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    float hash = step(fract(sin(dot(SC, vec2(127.1,311.7))) * 43758.5453123), 0.5);\n\n    return \n       (SC.x > (C.x - Offset.x) &&\n        SC.x < (C.x + Offset.x) &&\n        SC.y > (C.y - Offset.y) &&\n        SC.y < (C.y + Offset.y)) == true ?\n            hash :\n            1.0;\n}\n\nfloat mainScene(in vec2 SC)\n{\n    float transition_number = 0.0; \n    \n    // Reinit every 100 frames.\n    bool s = transition(iFrame, 100, transition_number);\n    \n    /* rules range = [0; 4095] or [0; 2^12 - 1]. */\n    int rule = int(transition_number) * 4 - 2;\n    \n    float state = \n        check_rule(rule, SC) == ALIVE ?\n            0.0 :\n            1.0;\n        \n    return \n        s == true ?\n            //randomize_part_of_frame(SC, 0.4) :\n            init_one_pixel_in_center(SC) :\n            state;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    O = vec4(mainScene(SC));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                        iResolution\n#define TEX0(TC)               ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)              ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\n/* Every num_of_frame returns true \nand number of detected transitions. */\nbool transition(\n    in int frame,\n    in int numOfFrames,\n    inout float quotent)\n{\n    // Convert to float.\n    float f = float(frame);\n    float inv = 1.0 / float(numOfFrames);\n    \n    // Calculate previous and current quotents.\n    float qc = floor(f * inv);\n    quotent = floor((f - 1.0) * inv);\n    \n    return quotent < qc;\n}\n\nuint hashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}","name":"Common","description":"","type":"common"}]}