{"ver":"0.1","info":{"id":"wt2SDm","date":"1566251511","viewed":505,"name":"Cartoon Filter","username":"VerticalPink","description":"Some fun with edge detection.\n\nUse the SPACE key to toggle between different modes.\nKeys '1', '2', and '3' select different outline variants. \n\nHave fun!","likes":3,"published":1,"flags":48,"usePreview":1,"tags":["cartoon","dithering","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////////\n//\n// Cartoon Shader \n//\n//   Uses a combination of edge detection, colour quantisation, and dithering to\n//   achieve a hand-drawn look. \n//\n// Keys:\n//         SPACE - toggle display mode (pencil sketch, inverted, coloured comic)\n//           '1' - no edges \n//           '2' - lighten edges\n//           '3' - darken edges  (e.g. coloured mode + darken = inked)\n//\n////////////////////////////////////////////////////////////////////////////////////\n\nprecision mediump float;\n\n#define HSV( h, s, v )    vec3( h / 359.0, s / 100.0, v / 100.0 )\n#define RGB( r, g, b )    vec3( r / 255.0, g / 255.0, b / 255.0 )\n\n#define DITHER_SCALE      2.0\n#define COLOUR_COUNT      1.0\n#define KEY_TOLERANCE     0.1\n#define KEY_SMOOTHING     0.08\n#define CHROMA_KEY        HSV( 123., 92., 64. )\n\n////////////////////////////////////////////////////////////////////////////////////\n// Display states:\n//   x: background flag -1 -> inverted, +1 -> normal, 0 -> 50% grey\n//   y: foreground flag -1 -> inverted, +1 -> normal, 0 -> 50% grey\n//   z: colour flag      1 -> coloured,  0 -> monochrome\nconst vec3 STATE_MAP[] = vec3[](\n    vec3( 1, 1, 1 ),\n    vec3( 1, 1, 0 ),\n    vec3( -1, -1, 0 )\n);\n////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////\n// RGB to HSV conversion\n// Credit: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n////////////////////////////////////////////////////////////////////////////////////\nvec3 rgb2hsv( vec3 c )\n{\n    vec4 K = vec4( 0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0 );\n    vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n    vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n\n    float d = q.x - min( q.w, q.y );\n    float e = 1.0e-10;\n\n    return vec3( abs( q.z + ( q.w - q.y ) / ( 6.0 * d + e ) ), d / ( q.x + e ), q.x );    \n}\n\nvec3 hsv2rgb( vec3 c )\n{\n    vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n    vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n    return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );    \n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return the blend factor between forground and background using chroma keying\n//\n// Input:  colour from input texture \n// Output: Blend factor between foreground- and background colours\n////////////////////////////////////////////////////////////////////////////////////\nfloat chromaKeyBlendValue( in vec3 col )\n{\n    vec3 hsv = rgb2hsv( col );\n    float d = distance( hsv.xy, CHROMA_KEY.xy );\n    return smoothstep( KEY_TOLERANCE, KEY_TOLERANCE + KEY_SMOOTHING, d );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return RGB colour from \"packed\" format\n//\n// Input: \"packed\" colour\n// Output: RGB colour\n////////////////////////////////////////////////////////////////////////////////////\nvec3 unpackRgb( in vec2 col )\n{\n    float b = trunc( col.x ) * 0.01;\n    float r = fract( col.x ) * 10.0;\n    return vec3( r, col.g, b );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return a quantised and dithered colour value \n//\n// Input: RGB colour\n//        Number of discretevalues percolour component\n//        Output coordinates (used for selecting dithering coefficient)\n// Output: Quantised and dithered colour value \n////////////////////////////////////////////////////////////////////////////////////\nvec3 quantizeRgb( in vec3 rgb, in float res, in vec2 coord )\n{\n    vec3 c1 = floor( rgb * res ) / res;\n    vec3 c2 = ( floor( rgb * res ) + 1.0 ) / res;\n    \n    float dith = texture( iChannel1, coord / iChannelResolution[1].xy ).r;\n    float a = step( dith, distance( c1, rgb ) );\n    \n    return mix( c1, c2, a );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return background colour - replace with something more interesting...\n//\n////////////////////////////////////////////////////////////////////////////////////\nvec3 background( in vec2 uv )\n{\n    vec2 pos = uv * 4.0 + iTime * vec2( 0.04, 0.001 ); \n    vec3 col = texture( iChannel2, pos ).rgb;\n    return quantizeRgb( col, 1.0, uv * iResolution.xy );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return the gradient magnitude and -angle for a given screen position\n//\n// Input:  Screen coordinate\n// Output: Gradient magnitude and -angle (0..1) \n////////////////////////////////////////////////////////////////////////////////////\nvec2 getGradientAngle( in vec2 coord )\n{\n    return texture( iChannel0, coord / iResolution.xy ).xy;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Peform non-maxium supression on gradient and return thinned edge value\n//\n// Input:  Gradient magnitude and -angle\n//         Screen coordinate\n// Output: Gradient after NMS \n////////////////////////////////////////////////////////////////////////////////////\nfloat nonMaximumSupression( in vec4 grad, in vec2 coord )\n{\n    vec2 gt = grad.xy;\n    vec2 pq = vec2(1);\n\n    if ( ( gt.y >= 0.0 && gt.y < 0.0625 ) || ( gt.y >= 0.4375 && gt.y < 0.5 ) )\n    {\n        pq = vec2( getGradientAngle( coord + vec2( 1, 0 ) ).x, getGradientAngle( coord + vec2( -1, 0 ) ).x );\n    }\n    else if ( ( gt.y >= 0.0625 ) && ( gt.y < 0.1875 ) )\n    {\n        pq = vec2( getGradientAngle( coord + vec2( -1, 1 ) ).x, getGradientAngle( coord + vec2( 1, -1 ) ).x );\n    }\n    else if ( ( gt.y >= 0.1875 ) && ( gt.y < 0.3125 ) )\n    {\n        pq = vec2( getGradientAngle( coord + vec2( 0, 1 ) ).x, getGradientAngle( coord + vec2( 0, -1 ) ).x );\n    }\n    else if ( ( gt.y >= 0.3125 ) && ( gt.y < 0.4375 ) )\n    {\n        pq = vec2( getGradientAngle( coord + vec2( -1, -1 ) ).x, getGradientAngle( coord + vec2( 1, 1 ) ).x );\n    }\n    \n    return step( pq.x, gt.x ) * step( pq.y, gt.x ) * gt.x + gt.x;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return current display state\n//\n////////////////////////////////////////////////////////////////////////////////////\nvec4 loadState( )\n{\n    vec2 mode = texelFetch( iChannel0, ivec2( 0 ), 0 ).xw;\n    float idx = max( 0., mod( mode.x, 6. ) );\n    return vec4( STATE_MAP[ int( idx ) ], mode.y );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 grad = texture( iChannel0, uv );\n    vec4 state = loadState( );\n    vec3 col = unpackRgb( grad.zw );\n\n    vec3 bg = background( uv );\n    \n    float edge = nonMaximumSupression( grad, fragCoord );\n    vec3 colour = quantizeRgb( col, COLOUR_COUNT, fragCoord / DITHER_SCALE );\n    vec3 fg = mix( colour, vec3( grad.x ), 0.9 );\n    vec3 tint = pow( col, vec3( 1.8 ) );\n\n    // apply display mode\n    bg = ( bg - 0.5 ) * state.x + 0.5;\n    fg = ( fg - 0.5 ) * state.y + 0.5;\n    fg += tint * state.z;\n    \n    // apply edge mode: fg0 -> off/lighten; fg1 -> darken\n    vec3 fg0 = fg + state.w * edge;\n    vec3 fg1 = smoothstep( grad.x, edge, vec3( 0.1 ) ) * fg;\n    // if edge mode == 2 then select fg1 else select fg0\n    fg = mix( fg0, fg1, step( 2., state.w ) ); \n    \n    fragColor = vec4( mix( bg, fg, chromaKeyBlendValue( col ) ), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////////\n//\n// This shader runs an edge detection filter over its input.\n// The edge filter calculates horizontal and vertical gradients from image samples\n// with Guassian blur applied. The return value contains the gradient magnitude and\n// -angle for further processing.\n//\n// Space bar is queried to switch between modes. '1', '2', '3' select edge modes.\n//\n// Input:  iChannel0 (Image or Video)\n// Output: x -> Input image gradient magnitude\n//         y -> Angle of the gradient scaled from 0째..360째 to 0..1 \n//         z -> Red and Blue channels of the original input\n//              (integral part 0..100 for blue, fractional part for red, i.e. red/10)\n//         w -> Green channel of the original input\n//\n//         Value at (0,0):\n//          x (display mode):\n//           0: Pencil sketch mode\n//           1: Chalk drawing mode\n//           3: Comic drawing mode\n//          w (edge mode):\n//           0: edge off\n//           1: lighten\n//           2: darken\n////////////////////////////////////////////////////////////////////////////////////\n\nprecision mediump float;\n\n// set to zero (0) to use a cheaper approximation for the gradient magnitude\n#define EXACT_MAGNITUDE 1\n// set to PREWITT, SOBEL, or SCHARR for different edge detection operator kernels\n#define GRADIENT_KERNEL SOBEL\n\n// key codes for mode selection\n\n#define KEY_SPACE       32\n#define KEY_1 \t\t\t49 \n#define KEY_2 \t\t\t50\n#define KEY_3 \t\t\t51\n\n// 5x5 Gaussian blur filter kernel\nconst int GAUSS_SIZE = 5;\nconst int H_GAUSS_SIZE = GAUSS_SIZE / 2;\nconst float gauss_kernel[GAUSS_SIZE] = float[GAUSS_SIZE]( 1.0, 4.0, 6.0, 4.0, 1.0 );\nconst float GAUSS_NORM = 16.0 * 16.0;\n\n// 3x3 separable edge detection filter kernels\nconst vec3 PREWITT = vec3(1.0);\nconst vec3 SOBEL = vec3(1.0, 2.0, 1.0);\nconst vec3 SCHARR = vec3(3.0, 10.0, 3.0);\n\n// sRGB colour to grey conversion\nconst vec3 sRGB2GREY = vec3( 0.2126, 0.7152, 0.0722 );\n\n#define M_PI 3.1415926535897932384626433832795\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return compressed RGB colour\n//\n// Input:   RGB colour [0,1]\n// Output:  Compressed colour (green: [0,1], red: [0,0.1], blue: [0,100])\n//\n////////////////////////////////////////////////////////////////////////////////////\nvec2 packRgb( vec3 rgb )\n{\n    return vec2( trunc( rgb.b * 100.0 ) + rgb.r * 0.1, rgb.g ) ;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return a sample from a given (screenspace-)coordinate after applying a 5x5 blur \n//\n// Input:   Screen coordinate\n// Output:  Blurred greyscale value at the coordinate\n//\n////////////////////////////////////////////////////////////////////////////////////\nfloat gaussianBlur( in vec2 coord )\n{\n    float result = 0.0;\n    vec2 onePixel = vec2( 1.0 ) / iResolution.xy;  \n    \n    for (int i = -H_GAUSS_SIZE; i <= H_GAUSS_SIZE; ++i)\n    {\n        for (int j = -H_GAUSS_SIZE; j <= H_GAUSS_SIZE; ++j)\n        {\n            vec3 rgb = texture( iChannel0, ( coord + vec2( i, j ) ) * onePixel ).rgb;\n            float grey = dot( sRGB2GREY, rgb );\n            result += gauss_kernel[H_GAUSS_SIZE+j] * gauss_kernel[H_GAUSS_SIZE+i] * grey;\n        }\n    }\n    \n    return result / GAUSS_NORM;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return the horizontal gradient (e.g. 1st derivative) at a given screen coordinate\n//\n// Input:   Screen coordinate\n// Output:  Value of the first derivative at the coordinate with respect to x\n//\n////////////////////////////////////////////////////////////////////////////////////\nfloat gradientX( in vec2 coord )\n{\n    vec3 left = vec3(\n        gaussianBlur( coord + vec2( -1.0, -1.0 ) ),\n        gaussianBlur( coord + vec2( -1.0,  0.0 ) ),\n        gaussianBlur( coord + vec2( -1.0, +1.0 ) )\n    );\n\n    vec3 right = vec3(\n        gaussianBlur( coord + vec2( +1.0, -1.0 ) ),\n        gaussianBlur( coord + vec2( +1.0,  0.0 ) ),\n        gaussianBlur( coord + vec2( +1.0, +1.0 ) )\n    );\n\n    return dot( GRADIENT_KERNEL, -left + right );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return the vertical gradient (e.g. 1st derivative) at a given screen coordinate\n//\n// Input:   Screen coordinate\n// Output:  Value of the first derivative at the coordinate with respect to y\n//\n////////////////////////////////////////////////////////////////////////////////////\nfloat gradientY( in vec2 coord )\n{\n    vec3 top = vec3(\n        gaussianBlur( coord + vec2( -1.0, -1.0 ) ),\n        gaussianBlur( coord + vec2(  0.0, -1.0 ) ),\n        gaussianBlur( coord + vec2( +1.0, -1.0 ) )\n    );\n\n    vec3 bottom = vec3(\n        gaussianBlur( coord + vec2( -1.0, +1.0 ) ),\n        gaussianBlur( coord + vec2(  0.0, +1.0 ) ),\n        gaussianBlur( coord + vec2( +1.0, +1.0 ) )\n    );\n\n    return dot( GRADIENT_KERNEL, -top + bottom );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\n// Return magnitude and angle of the gradient at the given screen coordinate\n//\n// Input:   Screen coordinate\n// Output:  x -> Magnitude of the gradient\n//          y -> Angle of the gradient scaled from 0째..360째 to 0..1\n//\n////////////////////////////////////////////////////////////////////////////////////\nvec2 gradientAngle( in vec2 coord )\n{\n    vec2 g = vec2( gradientX( coord ), gradientY( coord ) );\n#if EXACT_MAGNITUDE\n    float mag = length( g );\n#else\n    float mag = abs( g.x ) + abs( g.y );    \n#endif\n    float theta = ( atan( g.y, g.x ) + M_PI ) / ( 2.0 * M_PI );\n    return vec2( mag, theta ); \n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\nfloat keyPressed( in int code )\n{\n    float key = texelFetch( iChannel1, ivec2( code, 1 ), 0 ).x;\n    return step( 0.01, key );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( fragCoord.x < 1. && fragCoord.y < 1. )\n    {\n    \t// switch current mode if spacebar is pressed\n        vec2 state = texelFetch( iChannel2, ivec2( 0 ), 0 ).xw;\n \t    float mode = state.x;\n        float edge = state.y;\n\n        float toggle = keyPressed( KEY_SPACE );\n        mode = mod( mode + toggle, 3.0 );\n        \n        if ( keyPressed( KEY_1 ) > 0. ) edge = 0.;\n        if ( keyPressed( KEY_2 ) > 0. ) edge = 1.;\n        if ( keyPressed( KEY_3 ) > 0. ) edge = 2.;\n\n        if ( iFrame == 0 ) edge = 1.;\n        \n        fragColor = vec4( mode, 0, 0, edge );\n    }\n    else\n    {\n        // calculate filter values\n        vec3 rgb = texture( iChannel0, fragCoord / iResolution.xy ).rgb;\n        vec2 col = packRgb( rgb );\n        fragColor = vec4( gradientAngle( fragCoord ), col );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}