{"ver":"0.1","info":{"id":"cttGzj","date":"1682743354","viewed":85,"name":"ResidueTheorem","username":"wyattlukelowery","description":"tdrg","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["snakr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define blue vec3(0.74,0.95,1.00)\n#define red   vec3(1.00,0.38,0.227)\n#define purple   vec3(0.651,0.027,1)\n#define M_PI 3.1415926535897932384626433832795\n#define black vec3(0.0,0.0,0.0)\n\nfloat atan3(vec2 st){\n    return mod(atan(st.y, st.x), 2. * M_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    \n    //Center\n    vec2 center = iResolution.xy/2.0;\n    \n    //Final color so no alpha worry\n    vec3 finalColor;\n    \n    //Base Contour Function Defines\n    float rC = 1.05;//+ 0.1*sin(iTime);\n    \n    //Render size multiplier\n    float mult = 200.0;\n    \n    //Render Width\n    float rWidth = 1.0;\n    \n    //Radius from center\n    vec2 point = (uv-center);\n    float r = length(point);\n    \n    //Default Color\n    finalColor = black;\n    \n    //Number of countours /2\n    float num = 40.0;\n    \n    //Render of each countour\n    for( float i=-num; i<num; i++ )\n    {\n        //Redundant if for now, should be 0\n        if(i!=500.0)\n        {\n            //Countour new radius from base countour radius\n            float rF = pow(rC,i);\n            \n            //Render Countour\n            if(abs(r-rF*mult) < rWidth)\n            {\n                //k for coloring of different contour\n                float k = (i+num)/(2.*num);\n                \n                //Cooling antialiasing trick shown to me by nice commenter.\n                //finalColor = mix( finalColor,vec3(1.0-k,0,k),smoothstep( 1.5,0., abs(r-rF*mult) ));\n                \n                \n                //Integral Speed\n                float rotSpeed = 0.1;\n                \n                //Integral path render\n                float fTheta = mod(i*iTime*rotSpeed, 2.*M_PI);\n                float pointTheta = atan3(point);\n                float thetaTol = 0.1; //For normalized arc length 0.4/rF\n                \n                if(abs(mod(pointTheta-fTheta,2.*M_PI)) < thetaTol){\n                    finalColor = mix( finalColor,vec3(0,1.0,0),smoothstep( 1.5,0., abs(r-rF*mult) ));\n                }\n            }\n        }\n        //Useless else statement for now - saving for later\n        else\n        {\n            if(abs(r-rC*mult) < rWidth)\n            {\n                //finalColor = vec3(1.0,1.0,1.0);\n            }\n        }\n    }\n    \n    \n    fragColor = vec4( finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}