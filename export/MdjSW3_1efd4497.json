{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//==RAY MARCHING CONSTANTS=========================================================\n#define EPSILON .0001\n#define MAX_VIEW_STEPS 100\n#define MAX_SHADOW_STEPS 64\n#define OCC_SAMPLES 4.0\n#define MAX_DEPTH 10.0\n\n//==OBJECT CONSTANTS===============================================================\n#define BOX_POS vec3 (0.0, 0.5, 0.0)\n#define BOX_DIM vec3 (1.0, 1.0, 1.0)\n\n#define SPHERE_POS vec3(0.0, 0.5, 0.0)\n#define SPHERE_RAD 1.25\n\n//==LIGHTING CONSTANTS=============================================================\n#define MAT_BRIGHT .5\n#define MAT_REFLECTANCE .5\n#define PEN_FACTOR 45.0\n#define LIGHT_DIR normalize(vec3(sin(iTime), .8, cos(iTime)))\n#define LIGHT_COLOR vec3(1.0)\n#define LIGHT_BRIGHT 3.0\n#define OCC_FACTOR 1.0\n\n//==TEXTURE CONSTANTS==============================================================\n#define BUMP_MAP iChannel0\n#define CUBE_MAP iChannel1\n#define IMAGE_MAP iChannel2\n#define BUMP_FACTOR .06\n#define TEX_SCALE_FACTOR .4\n\t\n/*\n\tPerform camera setup.\n*/\nvoid camPolar(out vec3 pos, out vec3 dir, \n              in vec3 origin, in vec2 rotation, \n              in float dist, in float zoom, vec2 fragCoord)\n{\n\t// get rotation coefficients\n\tvec2 c = cos(rotation);\n\tvec4 s;\n\ts.xy = sin(rotation);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tdir.xy = fragCoord.xy - iResolution.xy*.5;\n\tdir.z = iResolution.y*zoom;\n\tdir = normalize(dir);\n\t\n\t// rotate ray\n\tdir.yz = dir.yz*c.x + dir.zy*s.zx;\n\tdir.xz = dir.xz*c.y + dir.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\t\n\n/*\n\tReturns a texel based on a surface's orientation and position.\n*/\nvec4 tex3D(in vec3 pos, in vec3 normal, sampler2D sampler)\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n/*\n\tReturns the distance to a smooth sphere.\n*/\nfloat distSmoothSphere(vec3 pos)\n{\n\treturn length(pos-SPHERE_POS)-SPHERE_RAD;\n}\n\n/*\n\tUses the smooth sphere depth function to determine its\n\tsurface normal.\n*/\nvec3 sphereNormal(vec3 pos)\n{\n\treturn normalize(vec3(distSmoothSphere(pos+vec3(EPSILON,0,0)),\n\t\t\t\t\t\tdistSmoothSphere(pos+vec3(0,EPSILON,0)),\n\t\t\t\t\t\tdistSmoothSphere(pos+vec3(0,EPSILON,0)))-\n\t\t\t\t\t\tdistSmoothSphere(pos));\n}\n\n/*\n\tThe distance function of a displacement mapped sphere.\n*/\nfloat distSphere(vec3 pos)\n{\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(pos-SPHERE_POS) < SPHERE_RAD+BUMP_FACTOR)\n\t{\t\n\t\tnormal = sphereNormal(pos);\n\t\tbump = tex3D(pos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;\n\t}\n\treturn length(pos-SPHERE_POS)-SPHERE_RAD+bump;\n}\n\n/*\n\tThe distance to a basic box.\n*/\nfloat distSmoothBox(vec3 pos)\n{\n\tvec3 d = abs(pos-BOX_POS) - BOX_DIM;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0));\n}\n\n/*\n\tReturns the surface normal of a smooth box.\n*/\nvec3 boxNormal(vec3 pos)\n{\n\treturn normalize(vec3(distSmoothBox(pos+vec3(EPSILON,0,0)),\n\t\t\t\t\t\tdistSmoothBox(pos+vec3(0,EPSILON,0)),\n\t\t\t\t\t\tdistSmoothBox(pos+vec3(0,0,EPSILON)))-\n\t\t\t\t\t\tdistSmoothBox(pos));\n}\n\n/*\n\tThe distance function of a displacement mapped box.\n*/\nfloat distBox(vec3 pos)\n{\t\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(pos-BOX_POS) < length(BOX_DIM))\n\t{\n\t   \tnormal = boxNormal(pos);\n \t\tbump = tex3D(pos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;\n\t}\n\tvec3 d = abs(pos-BOX_POS) - BOX_DIM;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0))+bump;\n}\n\n/*\n\tThe general displacement mapped distance function.\n*/\nfloat getDist(vec3 pos)\n{\n\treturn max(-distSphere(pos), distBox(pos));\n}\n\n/*\n\tA distance function that only takes into account basic,\n\tsmooth shapes.\n*/\nfloat getSmoothDist(vec3 pos)\n{\n\treturn max(-distSmoothSphere(pos), distBox(pos));\n}\n\n/*\n\t\tMarches the 3D point pos along the given direction.\n\tWhen the point is either stepped the maximum number of times,\n\thas passed the maximum distance, or is within a set distance\n\tfrom geometry the function returns. \n\t\tNote that the position is passed by reference and is modified\n\tfor use within the function.\n*/\nvoid marchThroughField(inout vec3 pos, vec3 dir, vec3 eye)\n{\n\tfloat dist;\n\tfor(int i = 0; i < MAX_VIEW_STEPS; ++i)\n\t{\n\t\tdist = getDist(pos);\n        pos += dir*dist;\n\t\tif(dist < EPSILON || length(pos-eye) > MAX_DEPTH)\n\t\t\treturn;\n\t}\n\treturn;\n}\n\n/*\n\tReturns a simplified normal.\n*/\nvec3 getSmoothNormal(vec3 pos)\n{\n\treturn normalize(vec3( getSmoothDist(pos+vec3(EPSILON,0,0)), \n\t\t\t\t\tgetSmoothDist(pos+vec3(0,EPSILON,0)), \n\t\t\t\t\tgetSmoothDist(pos+vec3(0,0,EPSILON)))-getSmoothDist(pos));\n}\n\n/*\n\tReturns the surface normal of a point in the distance function.\n*/\nvec3 getNormal(vec3 pos)\n{\n\treturn normalize(vec3( getDist(pos+vec3(EPSILON,0,0)), \n\t\t\t\t\tgetDist(pos+vec3(0,EPSILON,0)), \n\t\t\t\t\tgetDist(pos+vec3(0,0,EPSILON)))-getDist(pos));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat calcOcclusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-getDist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\n/*\n\tCalculates how much light remains if shadows are considered.\n\tUses IQ's soft shadows.\n*/\nfloat calcShadow( vec3 origin, vec3 lightDir)\n{\n\tfloat dist;\n\tfloat result = 1.0;\n\tfloat lightDist = MAX_DEPTH;\n\t\n\tvec3 pos = origin + lightDir*(EPSILON+BUMP_FACTOR);\n\t\n\tfor(int i = 0; i < MAX_SHADOW_STEPS; ++i)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tif(length(pos-origin) > lightDist || length(pos-origin)+dist > MAX_DEPTH)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tpos+=lightDir*dist;\n\t\tresult = min( result, PEN_FACTOR*dist / length(pos-origin) );\n\t}\n\treturn result;\n}\n\nfloat orenNayar(in vec3 n, in vec3 v)\n{\n\t\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, LIGHT_DIR);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates lighting at a given point.\n*/\nvec3 calcLighting(vec3 pos, vec3 eye)\n{\n\tvec3 eyeDir = normalize(pos-eye);\n\tvec3 surfaceNormal = getNormal(pos);\n\tvec3 reflection = normalize(reflect(eyeDir, surfaceNormal));\n\t\n\tfloat diffuse = orenNayar(surfaceNormal, eyeDir);\n\tfloat ambient = .05;\n\t\n    vec3 matColor = tex3D(pos*TEX_SCALE_FACTOR, getSmoothNormal(pos), iChannel2).rgb;\n\t\n\tvec3 lighting = LIGHT_COLOR*LIGHT_BRIGHT*\n\t\t\t\t\tmatColor*MAT_BRIGHT*\n\t\t\t\t\tdiffuse*calcShadow(pos, LIGHT_DIR)+\n\t\t\t\t\tambient*calcOcclusion(pos, surfaceNormal)*matColor*MAT_BRIGHT;\n\treturn clamp(lighting, 0.0, 1.0);\n}\n\n/*\n\tShades the fragment to it's final state.\n*/\nvec3 shade(vec3 pos, vec3 dir, vec3 eye)\n{\n\tif(length(pos-eye) > MAX_DEPTH-EPSILON) return texture(CUBE_MAP, dir).rgb;\n\telse return pow(calcLighting(pos, eye), vec3(1.0/2.2));\n}\n\n/*\n\tMain\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pos, dir, eye;\n\tcamPolar(pos, dir, vec3(0.0), vec2(.5,iMouse.x*.0075+.025), 3.5, 1.0, fragCoord);\n\teye = vec3(pos);\n\t\n\tmarchThroughField(pos, dir, eye);\n\t\n\tfragColor = vec4(shade(pos, dir, eye), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdjSW3","date":"1416698913","viewed":388,"name":"Better Surface Displacement","username":"Hamneggs","description":"I fixed the artifacting of the old technique by using the actual surface normal instead of   using normal = p - center_of_primitive. Doh!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["displacement","bump","mapping","surface","orennayar","oren","nayar","concreteblock"],"hasliked":0,"parentid":"","parentname":""}}