{"ver":"0.1","info":{"id":"3sdSzB","date":"1572285367","viewed":119,"name":"Sphere-Cube and Sun","username":"TundrumMax","description":"Its just a ray marcher program with a pulsating Sphere-Cube and a sun. Most of the code is from the \"LIVE Shader Deconstruction :: happy jumping\" video by Inigo, and I added the curved cube and sun into the program.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( vec3 p, vec3 b , float r)\n{\n  r = min(r,max(b.x,max(b.y,b.z)));\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(in vec3 pos) {\n \tfloat d = length(pos) - 0.2; //Distance function for a sphere\n    float d2 = sdBox(pos - vec3(0,0,0),vec3(0.2,0.2,0.2),(sin(iTime)*0.5+0.5)*0.2);\n\td = d2;\n    d = min(pos.y + 0.2,d);\n    return d;\n}\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(0.0001,0.0);\n \treturn normalize( vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                           map(pos+e.yxy)-map(pos-e.yxy),\n                           map(pos+e.yyx)-map(pos-e.yyx)));   \n}\n\nfloat castRay(in vec3 ro, in vec3 rd, in float renderDistance) {\n \tfloat t = 0.0;\n    for(int i = 0; i < 100; i++) {\n     \tvec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        if(h < 0.001) break;\n        \n        t += h;\n        if(t > renderDistance) break;\n    }\n    if(t > renderDistance) t = -1.0;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = iMouse.x / iResolution.x*6.245;\n    float en = -iMouse.y / iResolution.y + 3.1415 / 5.0;\n    //float an = iTime;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(cos(an),sin(en),sin(an));\n    vec3 ta = vec3(0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n    float renderDistance = 20.0;\n\tfloat t = 0.0;\n    t = castRay(ro,rd,renderDistance);\n    vec3 col = pow(vec3(0.6,0.8,0.9), vec3(rd.y*7.0));\n    \n    \n    vec3 sunVector = normalize(vec3(0.8,0.4,0.2));\n    col += vec3(pow(max(dot(sunVector,rd),0.0), 50.0)) * normalize(vec3(7,4.5,3));\n    \n    \n    \n    if(t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 norm = calcNormal(pos);\n        vec3 mat = vec3(0.18);\n        \n\n        vec3 skyVector = normalize(vec3(0.0,1.0,0.0));\n        \n        float sunDiffuse = clamp(dot(norm,sunVector),0.0,1.0);\n        float skyDiffuse = clamp(0.5 + 0.5*dot(norm,skyVector),0.0,1.0);\n        float bounceDiffuse = clamp(0.5 + 0.5*dot(norm,-skyVector),0.0,1.0);\n        \n        float sunShadow = step(castRay(pos + norm * 0.001,sunVector, renderDistance),0.0);\n        \n        \n        \n    \tcol = mat * vec3(7,4.5,3) * sunDiffuse * sunShadow;\n        col += mat * vec3(0.6,0.8,0.9) * skyDiffuse;\n        col += mat * vec3(0.7,0.3,0.2) * bounceDiffuse;\n    }\n\tcol = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}