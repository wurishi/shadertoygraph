{"ver":"0.1","info":{"id":"MXjfRc","date":"1729784875","viewed":111,"name":"Glitched Hexagons","username":"Rizzi001","description":"Glitchy, rgb pixeled, black&white layered hexagon pattern","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["pixel","blackandwhite","rgb","hexagon","glitch","pattern","hex","greyscale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float size = 100.0;\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nvec3 hexHeight(vec2 coord) {\n\tcoord.y /= 0.8660254;\n\tcoord.x  = coord.x - 0.5 * coord.y;\n\tvec2 cellCoord = floor(coord);\n\tint cellType = int(mod(cellCoord.x - cellCoord.y, 3.0));\n\tvec2 iCC = mod(coord, 1.0);\n\tint halfIndex = int(step(1.0, iCC.x + iCC.y));\n\tfloat height;\n\tvec2 center;\n\tif(cellType == 0){\n\t\tcenter = cellCoord + vec2(1.0, 0.0);\n\t\tif(halfIndex == 0) {\n\t\t\theight = iCC.x;\n\t\t} else {\n\t\t\theight = 1.0 - iCC.y;\n\t  }\n\t} else if(cellType == 1) {\n\t\tif(halfIndex == 0) {\n\t\t\tcenter = cellCoord;\n\t\t\theight = 1.0 - iCC.x - iCC.y;\n\t\t} else {\n\t\t\tcenter = cellCoord + vec2(1.0, 1.0);\n\t\t\theight = iCC.x + iCC.y - 1.0;\n\t\t}\n\t} else {\n\t\tcenter = cellCoord + vec2(0.0, 1.0);\n\t\tif(halfIndex == 0) {\n\t\t\theight = iCC.y;\n\t\t} else {\n\t\t\theight = 1.0 - iCC.x;\n\t\t}\n\t}\n\treturn vec3(height, center);\n}\n\nfloat getBrightness(vec2 pos, vec2 offset){\n\tvec3 h = hexHeight(rotateVec((pos + iTime) / size, iTime) + offset);\n\tfloat b = rand(h.yz) * 0.5 + 0.7;\n\tfloat a = step(3.0 * sin(iTime/4.0 + b * 1000.0) - 2.0, h.x);\n\treturn 1.0 - a*b;\n}\n\nfloat getLayeredBrightness(vec2 pos) {\n\tfloat brightness = getBrightness(pos, vec2(0.0));\n\tfor(int i = 1; i <= 12; i ++) {\n\t\tfloat factor = 0.4/float(i);\n\t\tvec2 dir = vec2(mod(float(i), 2.0), mod(float(i+1), 2.0)) * (mod(floor(float(i)/2.0), 2.0) * 2.0 - 1.0);\n\t\tvec2 offset = vec2(floor(float(i+3)/4.0) * size + 1.0) * dir;\n\t\tbrightness += factor * clamp(getBrightness(pos, offset) - 0.2, 0.0, 1.0);\n\t}\n\treturn brightness;\n}\n\nvec2 glitchFilter(vec2 pos, float seed) {\n\tfloat r = rand(vec2(floor(iTime*10.0), floor(pos.y/ 60.0)));\n\tif(r <= 0.1) pos.x += 300.0 * r * seed;\n  return pos;\n}\n\nvec4 getColor(vec2 pos) {\n\tfloat red = getLayeredBrightness(glitchFilter(pos, 1.0));\n\tfloat cyan = getLayeredBrightness(glitchFilter(pos, 1.4));\n\treturn vec4(red, cyan, cyan, 1.0);\n}\n\nvec4 pixelize(vec2 pos, float size) {\n\tvec4 color = getColor(floor(pos / size) * size);\n\tpos = fract(pos / size);\n\tfloat yFac = step(pos.y, 0.9);\n\tfloat xFac = step(fract(pos.x * 3.0), 0.7);\n\tfloat rgb = floor(pos.x * 3.0);\n\tvec3 rgbFac = vec3((rgb == 0.0), (rgb == 1.0), (rgb == 2.0));\n\treturn color * vec4(rgbFac, 1.0) * yFac * xFac;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = pixelize(fragCoord.xy, 3.0);\n}","name":"Image","description":"","type":"image"}]}