{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Anti-aliased step function\nfloat aastep(float a, float x) {\n    float fw = fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\n// Anti-aliased step function with a separate argument for\n// auto derivatives. This is useful for eliminating artifacts\n// due to discontinuities in the pattern generation function.\nfloat aastep(float a, float x, float xd) {\n    float fw = fwidth(xd);\n    return smoothstep(-fw, fw, x-a);\n}\n\n// Make a kind-of random RGB color from a modulo-289 integer ID\nvec3 rgbh(float h) {\n    h = mod(h+1.0, 289.0);\n    return vec3(1.0-mod(h,7.0)/8.0, 0.9-mod(h,49.0)/64.0, 1.0-h/288.0);\n}\n\nvec2 cellularSF(vec3 v, float N, out vec3 P1, out vec3 P2,\n                out float ID1, out float ID2) {\n\n\tvec4 f0, f1, f2, f3;\n\tvec4 d;\n\tvec3 x0, x1, x2, x3;\n\t\n\t// Get all four neighbors of current point\n\tinverseSF(v, N, f0, f1, f2, f3, d);\n\n    // Optional: fix known errors around the poles for small N\n\t// patchpoles(v, N, f0, f1, f2, f3, d);\n\n    // Sort out the second closest point as well\n    sortp0p1(f0, f1, f2, f3, d);\n    \n    P1 = f0.xyz;\n    P2 = f1.xyz;\n    ID1 = f0.w;\n    ID2 = f1.w;\n\treturn d.xy;\n}\n\n#define TWOSIDED\n#define VORONOI\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Compute texcoords for a slowly rotating sphere\n    vec3 uvw;\n    uvw.xz = uv * 1.05;\n    uvw.y = sqrt(max(0.0, 1.0-dot(uvw.xz,uvw.xz)));\n#ifdef TWOSIDED\n    float alpha = 0.7; // Transparency for the sphere surface (0.0 to 1.0)\n    vec3 uvwb; // uvw is front side, uvwb is back side\n    uvwb = vec3(uvw.x, -uvw.y, uvw.z);\n#else\n    float alpha = 1.0;\n#endif\n    float spheremask = 1.0 - aastep(1.0, length(uvw.xz)); // Sphere outline\n    float spin = -iTime; // Spin for display\n    float Ss = sin(spin);\n    float Cs = cos(spin);\n    float tilt = -0.6; // Tilt north pole towards viewer\n    float St = sin(tilt);\n    float Ct = cos(tilt);\n    mat2 S = mat2(Cs, -Ss, Ss, Cs);\n    mat2 T = mat2(Ct, -St, St, Ct);\n    uvw.yz = T*uvw.yz; // Tilt\n    uvw.xy = S*uvw.xy; // Spin\n#ifdef TWOSIDED\n    uvwb.yz = T*uvwb.yz;\n    uvwb.xy = S*uvwb.xy;\n#endif\n\n    // Perform the inverse Fibonacci sphere mapping.\n    // Don't use non-integer values for N - they're not handled gracefully.\n    float N = floor(60.0 + 30.0*sin(0.5*iTime));\n    vec3 P1, P2, P1b, P2b;\n    float ID1, ID2, ID1b, ID2b;\n    vec2 F = cellularSF(uvw, N, P1, P2, ID1, ID2); // Front side\n\n#ifdef TWOSIDED\n        vec2 Fb = cellularSF(uvwb, N, P1b, P2b, ID1b, ID2b); // Back side\n#endif\n\n    float r = 0.1/sqrt(N);\n    \n    // Anti-alias the Voronoi cell colors. Because we can, so we should.\n#ifdef VORONOI\n    vec3 cellcol1 = rgbh(ID1);\n    vec3 cellcol2 = rgbh(ID2);\n    vec3 cellcol = mix(cellcol1, cellcol2, aastep(0.0, F.x-F.y, 2.0*F.x));\n#else\n    vec3 cellcol = vec3(1.0,0.5,0.0); // Front side is bright orange\n#endif\n    vec4 col;\n    col.rgb = cellcol;\n    col.a = alpha;\n\n#ifdef TWOSIDED\n#ifdef VORONOI\n    vec3 cellcol1b = rgbh(ID1b);\n    vec3 cellcol2b = rgbh(ID2b);\n    vec3 cellcolb = mix(cellcol1b, cellcol2b, aastep(0.0, Fb.x-Fb.y, 2.0*Fb.x));\n#else\n    vec3 cellcolb = vec3(0.5,0.25,0.0); // Back side is darker orange\n#endif // VORONOI\n    vec4 colb;\n    colb.rgb = cellcolb;\n    colb.a = alpha;\n#endif // TWOSIDED\n    \n    // Draw the spiral\n    float phi = atan(uvw.x, uvw.y);\n    float cosTheta = uvw.z;\n    const float Goldenratio = 0.6180339887; // Golden ratio (sqrt(5)-1)/2\n    const float twoPi = 6.28318530718; // 2*pi\n    // The spiral line is at spiralc=0\n    float spiralc = (mod(0.5*((1.0-cosTheta)*N)*Goldenratio + phi/twoPi - 0.07, 1.0) - 0.5);\n    float spiralw = 0.04;\n    float spiral = aastep(-spiralw, spiralc, 0.35*N*cosTheta) - aastep(spiralw, spiralc, 0.35*N*cosTheta);\n    col.rgb = mix(col.rgb, vec3(0.9), spiral);\n    col.a = max(col.a, spiral); // Spiral is opaque, cells retain their alpha\n\n#ifdef TWOSIDED\n    float phib = atan(uvwb.x, uvwb.y);\n    float cosThetab = uvwb.z;\n    float spiralcb = (mod(0.5*((1.0-cosThetab)*N)*Goldenratio + phib/twoPi - 0.07, 1.0) - 0.5);\n    float spiralb = aastep(-spiralw, spiralcb, 0.35*N*cosThetab) - aastep(spiralw, spiralcb, 0.35*N*cosThetab);\n    colb.rgb = mix(colb.rgb, vec3(0.3), spiralb); // Back side has a somewhat darker spiral\n    colb.a = max(colb.a, spiralb);\n#endif\n\n    // White dots around the points, also anti-aliased\n    float dots = 1.0-aastep(0.1*r, F.x);\n    col.rgb = mix(col.rgb, vec3(1.0), dots);\n    col.a = max(col.a, dots); // Make dots opaque\n\n#ifdef TWOSIDED\n    float dotsb = 1.0-aastep(0.1*r, Fb.x);\n    colb.rgb = mix(colb.rgb, vec3(0.5), dotsb); // Dots are gray on the back\n    colb.a = max(colb.a, dotsb);\n    col = mix(colb, col, col.a);\n    col.a = 1.0-(1.0-col.a)*(1.0-colb.a); // Alpha mixing is multiplicative\n#endif\n\n    // Blot out the background, in an anti-aliased manner\n    vec3 bgcol = vec3(0.2, 0.0, 0.4*sqrt(uv.y+1.0)); // Dark purple-blue gradient\n    col.rgb = mix(bgcol, col.rgb, col.a*spheremask);\n\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float fracmodphi(float k) {\n    // Compute fract(k/Phi) where Phi=(sqrt(5)-1)/2, but do it\n    // in a manner that yields high precision even for large k,\n    // where neither fract(k/Phi) nor mod(k,Phi)/Phi will do.\n    // Thanks to @mla for this integer expression:\n    // 1) Realize that fract(n*p/q) = ((n*p)%q)/q = (((n%q)*p)%q)/q\n    // 2) Use F23/F24 as a good rational approximation of Phi\n    uint p = 28657u, q = 46368u;\n    uint n = uint(k);\n    return float(n%q*p%q)/float(q);\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n\n// Compute point k on N-point fibsphere (helper for other functions)\nvec3 evalSFpoint(float k, float N) {\n\tfloat phi = 2.0*PI*fracmodphi(k);\n\tfloat cosTheta = 1.0 - (2.0*k + 1.0)*(1.0/N);\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\treturn vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,cosTheta);\n}\n\n// Compute neighbors in the local Cartesian map, and their distances.\nfloat evalNearest(float N, vec2 B, vec2 i, vec2 c, vec3 v, out vec4 p) {\n    float cosTheta = dot(B, i + c) + (1.0-1.0/N);\n\tcosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n\tp.w = floor(N*0.5 - cosTheta*N*0.5);\n\tp.xyz = evalSFpoint(p.w, N);\n    vec3 d = v-p.xyz;\n\treturn dot(d, d);\n}\n\n// Find the 3-4 nearest neighbors on an N-point Fibonacci sphere.\n// Evolved version of an algorithm from the article \"Spherical\n// Fibonacci Mapping\" by Keinert et al, ACM Trans. on Graphics\n// 34 (2015), 6, 193.\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com) 2021-2022.\n//\n// Return four neighbors, packing the result into 4-vectors.\n// p[i].xyz is the location of neighbor i, p[i].w is its index.\n// d[i] is the squared distances from v to each of the neighbors.\n// p[0] is the closest point. The other three are not sorted, and\n// there are errors and duplicates, most notably around the poles.\n// See the functions patchpoles() and sortpoints() below for a remedy.\n//\n// This function is Copyright 2022 by Stefan Gustavson.\n// It is released under the very liberal terms of the MIT license:\n// https://opensource.org/licenses/MIT\n// (\"Use freely for any purpose, but keep this attribution\")\n//\nvoid inverseSF(vec3 v, float N, out vec4 p0, out vec4 p1,\n                   out vec4 p2, out vec4 p3, out vec4 d) {\n\tfloat phi = min(atan(v.y, v.x), PI); // min() to dodge NaN\n\tfloat cosTheta = v.z;\n\tfloat k = max(2.0, floor(\n\t\tlog(N * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\n\t\t/ log(PHI*PHI)));\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 = floor(Fk * PHI + 0.5);\n\tmat2 B = mat2(\n\t\t2.0*PI*fracmodphi(F0+1.0) - 2.0*PI*(PHI-1.0), -2.0*F0/N,\n\t\t2.0*PI*fracmodphi(F1+1.0) - 2.0*PI*(PHI-1.0), -2.0*F1/N);\n\tmat2 invB = inverse(B);\n\tvec2 c = floor(invB * vec2(phi, cosTheta - (1.0-1.0/N)));\n\n\tvec2 Bvec = vec2(B[0][1],B[1][1]);\n\t// Compute all four neighbors first, *then* find closest point\n\t// (Sorting is more efficient with all values available)\n    d.x = evalNearest(N, Bvec, vec2(0.0, 0.0), c, v, p0);\n    d.y = evalNearest(N, Bvec, vec2(1.0, 0.0), c, v, p1);\n    d.z = evalNearest(N, Bvec, vec2(0.0, 1.0), c, v, p2);\n    d.w = evalNearest(N, Bvec, vec2(1.0, 1.0), c, v, p3);\n\n\t// Incomplete sort: Just make sure p0 is closest\n   \tvec4 ptemp;\n\tbvec3 smaller = lessThan(d.yzw, d.xxx);\n\tif(any(smaller)) {\n\t\tbvec3 smallest = lessThan(d.yyz, d.zww);\n\t\tif(all(smallest.xy)) { // d.y smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = ptemp;\n\t\t\td.xy = d.yx;\n\t\t}\n\t\telse if(!any(smallest.yz)) { // d.w smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p3;\n\t\t\tp3 = ptemp;\n\t\t\td.xw = d.wx;\n\t\t}\n\t\telse { // d.z smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p2;\n\t\t\tp2 = ptemp;\n\t\t\td.xz = d.zx;\n\t\t}\n\t}\n}\n\n// Patch up errors around the sphere's +z and -z poles.\n// Several errors remain, but this fixes the relevant ones\n// for our purposes: after patching, all neighbors are\n// correct within a radius of the global maximum distance\n// to the nearest point in the set.\n\n// A (dest,src) array to specify which patches to apply, and where:\n// \"For cell x, try adding neighbor y if it wasn't found already\".\n// The entries must be sorted on destination (x) in ascending order.\n//\n// This set of patches makes the algorithm work from N=8 and up.\n// If you don't need low N values, several of them can be omitted:\n// (2,0) is needed only for N=8,9\n// (5,3) is needed only for N=9\n// (4,1) is needed only for N=10,11\n// (3,6) is needed only for N<=11\n// (6,0) is needed only for N=11\n// (9,4) is needed only for N=20\n// (10,13) is needed only for N=21\n// If trashed duplicates (negative k) are tolerated for distant p3 (they\n// cause errors in the current code), some others could be omitted as well.\nconst vec2 polepatch[29] = vec2[](vec2(0.0, 3.0), vec2(0.0, 5.0), vec2(1.0, 3.0),\n\tvec2(1.0, 4.0),\tvec2(1.0, 6.0), vec2(2.0, 0.0), vec2(2.0, 5.0), vec2(2.0, 7.0),\n\tvec2(2.0, 10.0), vec2(3.0, 0.0), vec2(3.0, 6.0), vec2(3.0, 11.0), vec2(4.0,1.0),\n\tvec2(4.0, 9.0),\tvec2(5.0, 3.0), vec2(5.0, 8.0),\tvec2(5.0, 10.0), vec2(6.0, 0.0),\n\tvec2(6.0, 3.0),\tvec2(6.0, 11.0), vec2(7.0, 2.0), vec2(8.0, 5.0), vec2(8.0, 21.0),\n\tvec2(9.0, 4.0),\tvec2(9.0, 22.0), vec2(10.0, 13.0), vec2(10.0, 15.0), vec2(13.0, 21.0),\n\tvec2(14.0, 22.0));\n\n// The patching function. Only a few iterations of the \"for\" loop will amount\n// to any real amount of work, and there are early exits to speed it up further.\n// A modern GPU with \"peer-aware SIMD conditionals\" will execute this efficiently.\nvoid patchpoles(vec3 v, float N, inout vec4 p0, inout vec4 p1,\n                    inout vec4 p2, inout vec4 p3, inout vec4 d) {\n\n\tfloat k0 = p0.w;\n\n    // If we are not near either pole, no patches are needed\n\tif((k0 > 15.0) && (k0 < N-16.0)) return;\n\t// Trash duplicate neighbors for the patching to work\n\tvec4 ki = vec4(p0.w, p1.w, p2.w, p3.w);\n\t// p0 is correct, but not always unique\n\tbvec3 duplicates = equal(ki.xxx, ki.yzw);\n\tif(duplicates.x) { // trash p1\n\t\tp1 = vec4(0.0,0.0,0.0, -1.0); // Set invalid k\n\t\tki.y = -1.0;\n\t\td.y = 12.0; // More than sphere diameter squared\n\t}\n\tif(duplicates.y) { // trash p2\n\t\tp2 = vec4(0.0,0.0,0.0, -2.0);\n\t\tki.z = -2.0;\n\t\td.z = 11.0;\n\t}\n\tif(duplicates.z) { // trash p3\n\t\tp3 = vec4(0.0,0.0,0.0, -3.0);\n\t\tki.w = -3.0;\n\t\td.w = 10.0;\n\t}\n\t// p1, p2 or p3 might be duplicates of each other\n\tduplicates = equal(ki.yyz, ki.zww);\n\tif(any(duplicates.yz)) { // p3 dup of p1 or p2, trash p3\n\t\tp3 = vec4(0.0,0.0,0.0, -3.0);\n\t\td.w = 10.0;\n\t}\n\tif(duplicates.x) { // p2 dup of p1, trash p2\n\t\tp2 = vec4(0.0,0.0,0.0, -2.0);\n\t\td.z = 11.0;\n\t}\n\n\t// Mirror indices from opposite pole for the patch loop\n\tbool kflip = (k0 > N*0.5-0.5);\n\tif(kflip) k0 = N-1.0-k0;\n\n\tfor(int i = 0; i < 29; i++) {\n\t\t// \"Patch cell x by possibly including neighbor y\"\n\t\tvec2 dstsrc = polepatch[i];\n\t\t// A \"break\" has the rather unexpected side effect of\n        // preventing the GLSL compiler from unrolling the loop,\n        // which is an advantage in this case. The unrolled\n        // version of this loop has a huge instruction count\n        // and takes a long time to compile.\n\t\tif(k0 < dstsrc.x) break; // No more relevant patches\n\t\tif(dstsrc.x >= N*0.5) break; // No more relevant patches\n\t\tif(dstsrc.y >= N) continue; // This patch is not relevant\n\t\tif(k0 == dstsrc.x) { // This patch is relevant here\n\t\t\tvec3 k123 = vec3(p1.w, p2.w, p3.w);\n\t\t\tif(kflip) k123 = N-1.0-k123;\n\t\t\t// If this neighbor was already found, move on\n\t\t\tif(any(equal(k123, vec3(dstsrc.y)))) continue;\n\t\t\t// Evaluate the suggested neighbor, at correct pole\n\t\t\tfloat knew = kflip ? N-1.0-dstsrc.y : dstsrc.y;\n\t\t\tvec3 pnew = evalSFpoint(knew, N);\n\t\t\tfloat dnew = dot(v-pnew, v-pnew);\n\t\t\tif(any(lessThan(vec3(dnew), d.yzw))) {\n\t\t\t\tbvec3 largest = greaterThan(d.yyz, d.zww);\n\t\t\t\tif(all(largest.xy)) { // d[1] largest\n\t\t\t\t\tp1 = vec4(pnew, knew); // replace p1\n\t\t\t\t\td.y = dnew;\n\t\t\t\t}\n\t\t\t\telse if(!any(largest.yz)) { // d[3] largest\n\t\t\t\t\tp3 = vec4(pnew, knew);\n\t\t\t\t\td.w = dnew;\n\t\t\t\t}\n\t\t\t\telse { // d[2] largest\n\t\t\t\t\tp2 = vec4(pnew, knew);\n\t\t\t\t\td.z = dnew;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Sort all points p1 to p3 on distance\n// (not always needed, see \"sortp0p1\" below)\nvoid sortpoints(inout vec4 p0, inout vec4 p1,\n                inout vec4 p2, inout vec4 p3, inout vec4 d) {\n    vec4 ptemp;\n    if((d.y <= d.z) && (d.z <= d.w))\n        return; // Already sorted\n    if(d.z < d.y) { // Swap 1,2\n        d.yz = d.zy;\n        ptemp = p1;\n        p1 = p2;\n        p2 = ptemp;\n    }\n    if(d.w < d.y) { // Swap 1,3\n        d.yw = d.wy;\n        ptemp = p1;\n        p1 = p3;\n        p3 = ptemp;\n    }\n    if(d.w < d.z) { // Swap 2,3\n        d.zw = d.wz;\n        ptemp = p2;\n        p2 = p3;\n        p3 = ptemp;\n    }\n}\n\n// Sort to make p0, p1 the two closest points\n// (Leave p2, p3 unsorted)\nvoid sortp0p1(inout vec4 p0, inout vec4 p1, inout vec4 p2,\n                    inout vec4 p3, inout vec4 d) {\n    vec4 ptemp;\n    if((d.y <= d.z) && (d.z <= d.w))\n        return; // Already sorted\n    if((d.z < d.y) && (d.z < d.w)){ // Swap 1,2\n        d.yz = d.zy;\n        ptemp = p1;\n        p1 = p2;\n        p2 = ptemp;\n    } else if(d.w < d.y) { // Swap 1,3\n        d.yw = d.wy;\n        ptemp = p1;\n        p1 = p3;\n        p3 = ptemp;\n    }\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MfGfWz","date":"1733937707","viewed":80,"name":"Fibonacci sphere with alpha","username":"stegu","description":"Added the back side of the sphere, with transparency. It made the visualization more messy, and the code a lot more bloated, but I had fun doing it. Undefine VORONOI for a plain surface. Undefine TWOSIDED to view the front side only.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","sphere","antialiasing","fibonacci"],"hasliked":0,"parentid":"MfGBzh","parentname":"Fibonacci spiral on a sphere"}}