{"ver":"0.1","info":{"id":"WlfBRl","date":"1597391338","viewed":1681,"name":"Lasers546984","username":"Toctave","description":"-","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["lasers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    static.frag\n    by Spatial\n    05 July 2013\n*/\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n#define M_PI 3.1415926535897932384626433832795\n\nvec2 rot2(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return vec2(c * v.x + s * v.y, -s * v.x + c * v.y);\n}\n\nvec2 polar(vec2 v) {\n    v = 2. * v - 1.;\n    float theta = atan(v.y, v.x);\n    float r = sqrt(dot(v, v));\n    return vec2(r, theta / (2. * M_PI) + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0, 0, 0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    //uv *= 2.;\n    //uv = fract(uv);\n\n    //uv = rot2(uv, iTime * .1);\n    uv = polar(uv);\n    uv *= vec2(10, 800);\n    \n    \n    uv.x = -10. * (random(vec2(floor(uv.y), 1)) + .8) * iTime + ((random(vec2(floor(uv.y), 2)) * 2. - 1.) * .5 + 1.) * uv.x;\n   \tvec2 id = floor(uv);\n    uv = fract(uv);\n    \n    col.r = random(id) < .1 ? uv.x : 0.0;\n    \n    \n    //col.xy = uv;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}