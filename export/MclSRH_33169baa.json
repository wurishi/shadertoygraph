{"ver":"0.1","info":{"id":"MclSRH","date":"1705016654","viewed":85,"name":"[steve] Voronoi?","username":"import_shader_steve","description":"1. Voronoi Center looks weird. 2. the polygons aren't convex.\nMaybe: 1. drawing order: I draw the bottom-left tiles 1st, and top-right last, so might cover smth; 2. when animate black pts, they go out of cells. 3. need to draw black pts at last","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1. also implement flowmaps in shaders, as illustrated in this video: https://www.youtube.com/watch?v=KfphtLRoUB0&list=WL&index=6&ab_channel=MartinDonald\n// is flowmap the same as FBM noise / domain warping? If so/not, how are they related?\n// it feels like I can use Perlin noise / value noise to construct a flowmap field. Or can use other methods to construct a continuous field to make up the flowmap. Try it out later\n\n// 2. voronoi texture feels very much like delaunay triangulation intuitively, b/c they both work by finding & connecting points with shortest distance!\n// from the animation in this video: https://www.youtube.com/watch?v=jxOAU7YfypA&list=WL&index=5&t=859s&ab_channel=mbcodeandsound\n// can I implement delaunay triangulation in a glsl shader? Given a set of random points / iMouse drawn points, can I triangulate them?\n// can generating a voronoi pattern a pre-step of delaunay triangulation?\n\n// taken from: https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand1(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); // [0., 1.]\n}\n\nfloat rand2(vec2 co){\n    return fract(cos(dot(co, vec2(34.5698, 23.456))) * 12954.7922);\n}\n\nfloat rand3(vec2 co){\n    return fract(cos(dot(co, vec2(47.8971, 38.2851))) * 50291.4239);\n}\n\n// to move the voronoi points smoothly around, I must find a smooth noise function. I'll use the Perlin noise here\nvec2 noise2x2(vec2 p) {\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(345.6, 456.7));\n  vec2 noise = vec2(x, y);\n  noise = sin(noise);\n  noise = noise * 43758.5453;\n  noise = fract(noise);\n  return noise;\n}\n\nfloat circle(vec2 p, float r) {\n    float d = length(p) - r;\n    return smoothstep(fwidth(d), -fwidth(d), d);\n}\n\nconst float multiplier = 7.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y; // [-iResolution.x/iResolution.y, 1.]\n    uv = uv * multiplier - vec2(iTime * 0., 0.);\n    vec3 col = vec3(0.);\n    vec2 id = floor(uv); // all the points on uv gets floored to a few id's\n    vec2 st = fract(uv);\n    \n    vec2 p_cell = vec2(rand1(id), rand2(id)); // position within that cell\n    vec3 col_id = vec3(p_cell, rand3(id));\n    float d = circle(st - p_cell, 0.05);\n    \n    vec2 p_world = id + p_cell; // for each fragCoord, it's converted to this p_world position\n    // if (length(uv - p_world) < .5) col = col_id; // hmmm seems like I can't make the voronoi noise. The road block is how do I know all the p_world's and find the p_world with the shortest distance from each uv's position?\n    // for each fragCoord, also find the p_world (aka. id & st, aka. uv) on its 9 neighboring cells, and compare to find the cell with shortest distance. Then just color that fragCoord pixel with the color of that cell\n    float shortest_distance = 9999.;\n    vec2 shortest_id = id;\n    vec2 shortest_st = st;\n    vec2 uv_2 = vec2(0.);\n    for (float i = -1.; i < 2.; i++) {\n        for (float j = -1.; j < 2.; j++) {\n            uv_2 = uv - vec2(i, j);\n            id = floor(uv_2);\n            st = fract(uv_2);\n            p_cell = vec2(rand1(id), rand2(id));\n            p_world = id + p_cell;\n            vec2 noise = noise2x2(p_world);\n            p_world += noise;\n            p_world += sin(iTime * noise) * 0.5;\n            if (length(uv - p_world) < shortest_distance) {\n                shortest_distance = length(uv - p_world);\n                shortest_id = id;\n                shortest_st = st;\n            } else {\n                continue;\n            }\n        }\n    }\n    p_cell = vec2(rand1(shortest_id), rand2(shortest_id));\n    p_world = shortest_id + p_cell;\n    vec2 noise = noise2x2(p_world);\n    p_world += noise; \n    p_world += sin(iTime * noise) * 0.5;\n    col_id = vec3(p_cell, rand3(shortest_id));\n    col = col_id;\n    \n    d = circle(uv - p_world, 0.05);\n    col = mix(col, vec3(0.), d);\n    \n    // vec3 noise = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    // col = noise;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 randomGradient(vec2 p) {\n  p = p + 0.02;\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(234.5, 345.6));\n  vec2 gradient = vec2(x, y);\n  gradient = sin(gradient);\n  gradient = gradient * 43758.5453;\n\n  // part 4.5 - update noise function with time\n  gradient = sin(gradient + iTime * 1.);\n  return gradient;\n\n  // gradient = sin(gradient);\n  // return gradient;\n}\n\n// inigo quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdfCircle(in vec2 p, in float r) {\n  return length(p) - r;\n}\n\n// inigo quilez - https://iquilezles.org/articles/distfunctions2d/\nfloat sdfOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n  float l = length(b - a);\n  vec2 d = (b - a) / l;\n  vec2 q = (p - (a + b) * 0.5);\n  q = mat2(d.x, -d.y, d.y, d.x) * q;\n  q = abs(q) - vec2(l, th) * 0.5;\n  return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nvec2 cubic(vec2 p) {\n  return p * p * (3.0 - p * 2.0);\n}\n\nvec2 quintic(vec2 p) {\n  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n  // part 0 - basic shader setup\n  vec2 uv = fragCoord / iResolution.xy;\n\n  vec3 black = vec3(0.0);\n  vec3 white = vec3(1.0);\n  vec3 color = black;\n\n  // part 1 - set up a grid of cells\n  uv = uv * 16.0;\n  vec2 gridId = floor(uv);\n  vec2 gridUv = fract(uv);\n  color = vec3(gridId, 0.0);\n  color = vec3(gridUv, 0.0);\n\n  // part 2.1 - start by finding the coords of grid corners\n  vec2 bl = gridId + vec2(0.0, 0.0);\n  vec2 br = gridId + vec2(1.0, 0.0);\n  vec2 tl = gridId + vec2(0.0, 1.0);\n  vec2 tr = gridId + vec2(1.0, 1.0);\n\n  // part 2.2 - find random gradient for each grid corner\n  vec2 gradBl = randomGradient(bl);\n  vec2 gradBr = randomGradient(br);\n  vec2 gradTl = randomGradient(tl);\n  vec2 gradTr = randomGradient(tr);\n\n  // part 2.3 - visualize gradients (for demo purposes)\n  vec2 gridCell = gridId + gridUv;\n  float distG1 = sdfOrientedBox(gridCell, bl, bl + gradBl / 2.0, 0.02);\n  float distG2 = sdfOrientedBox(gridCell, br, br + gradBr / 2.0, 0.02);\n  float distG3 = sdfOrientedBox(gridCell, tl, tl + gradTl / 2.0, 0.02);\n  float distG4 = sdfOrientedBox(gridCell, tr, tr + gradTr / 2.0, 0.02);\n  if (distG1 < 0.0 || distG2 < 0.0 || distG3 < 0.0 || distG4 < 0.0) {\n    color = vec3(1.0);\n  }\n\n  // part 3.1 - visualize a single center pixel on each grid cell\n  float circleRadius = 0.025;\n  vec2 circleCenter = vec2(0.5, 0.5);\n  float distToCircle = sdfCircle(gridUv - circleCenter, circleRadius);\n  color = distToCircle > 0.0 ? color : white;\n\n  // part 3.2 - find distance from current pixel to each grid corner\n  vec2 distFromPixelToBl = gridUv - vec2(0.0, 0.0);\n  vec2 distFromPixelToBr = gridUv - vec2(1.0, 0.0);\n  vec2 distFromPixelToTl = gridUv - vec2(0.0, 1.0);\n  vec2 distFromPixelToTr = gridUv - vec2(1.0, 1.0);\n\n  // part 4.1 - calculate the dot products of gradients + distances\n  float dotBl = dot(gradBl, distFromPixelToBl);\n  float dotBr = dot(gradBr, distFromPixelToBr);\n  float dotTl = dot(gradTl, distFromPixelToTl);\n  float dotTr = dot(gradTr, distFromPixelToTr);\n\n  // part 4.4 - smooth out gridUvs\n  // gridUv = smoothstep(0.0, 1.0, gridUv);\n  // gridUv = cubic(gridUv);\n  gridUv = quintic(gridUv);\n\n  // part 4.2 - perform linear interpolation between 4 dot products\n  float b = mix(dotBl, dotBr, gridUv.x);\n  float t = mix(dotTl, dotTr, gridUv.x);\n  float perlin = mix(b, t, gridUv.y);\n\n  // part 4.3 - display perlin noise\n  float col = perlin + 0.4;\n  col = pow(col, 2.);\n  col = remap(col, 0., 1., -1., 1.);\n  fragColor = vec4(vec3(col), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float remap01(float x, float low, float high)\n{\n    return clamp((x-low)/(high-low), 0., 1.);\n}\n\nfloat remap(float x, float lowIn, float highIn, float lowOut, float highOut) {\n    return mix(lowOut, highOut, remap01(x, lowIn, highIn));\n}","name":"Common","description":"","type":"common"}]}