{"ver":"0.1","info":{"id":"fs2SDm","date":"1620388748","viewed":208,"name":"Pixel Circle loading with trail","username":"Knose1","description":"A pixelated circle turning around the mouse and leaving a trail","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["circle","loading","trail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Knose1\n// Title: Pixel Circle loading with trail\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//CONST\nconst float PI = 3.14159265359;\n\n//PARAMETERS\nconst float p_pxCount = 50.0;\nconst float p_loopDuration = 0.1;\nconst float p_radius = 0.2;\nconst float p_threshold = 0.04;\nconst float p_angleThreshold = PI*1.0;\nconst float p_circleSize = 0.05;\n\n//MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float minResolution = min(iResolution.x, iResolution.y);                //To avoid stretch\n    \n    //=================================================== UV and pixelated looking ===================================================//\n    vec2 st = fragCoord.xy/minResolution;\t\t\t\t\t\t\t\t    //Get the UV\n    st = floor(st * p_pxCount) / p_pxCount;\t\t\t\t\t\t\t\t\t//Give a pixelated look (the look result will be called \"bigPixels\" in the next comments)\n\n    vec2 mouse = iMouse.xy == vec2(0) ?  vec2(1.,.5) : iMouse.xy/minResolution;\t//Get the mouse UV (Thanks byt3_m3chanic for initial position's part)\n    \n    mouse -= 0.5/p_pxCount;\t\t\t\t\t\t\t\t\t\t\t\t\t//Offset the mouse so it's well snaped on the bigPixels\n    \n    float angle = mod(iTime / p_loopDuration, PI*2.0);\t\t\t\t\t\t//Get a radiant angle by time (NOTE : All the comments use degres for comprehention)\n    \n    vec2 localCircle = vec2(cos(angle), sin(angle)) * p_radius;\t\t\t\t//Get a local circle position using our angle (cos(angle), sin(angle)) * radius\n    vec2 fromTo = st - mouse;\t\t\t\t\t\t\t\t\t\t\t\t//Get the pixel position local to the mouse\n    \n    //============================================= Make a ring around the mouse cursor =============================================//\n    float sqrtdistPos = Lenght(fromTo);\t\t\t\t\t\t\t\t\t\t//Get the distance between the pixel and the mouse position\n    float sqrtdistCircle = Lenght(localCircle);\t\t\t\t\t\t\t\t//Get the distance between the circle position and the mouse position\n    float dist = abs(sqrtdistCircle - sqrtdistPos);\t\t\t\t\t\t\t//Get the distance between the two floats\n    dist = dist / p_threshold;\t\t\t\t\t\t\t\t\t\t\t\t//Get a ratio so that 1 means p_threshold's value\n    dist = clamp01(dist);\t\t\t\t\t\t\t\t\t\t\t\t\t//Clamp the value\n    \n    //=================================================== Make an angular gradient ===================================================//\n    float angleDistance = SignedAngleBetween(fromTo, localCircle) + PI*2.0; //Get an angle [-180, 180]. Offset it by 180 deg [0, 360]\n    angleDistance = mod(angleDistance, PI*2.0); \t\t\t\t\t\t\t//Remove the 180 offset (so that the 0 in [-180, 180] system is 0 in [0, 360] system)\n    angleDistance = angleDistance / p_angleThreshold;\t\t\t\t\t\t//Get a ratio so that 1 means p_angleThreshold's value\n    angleDistance = clamp01(angleDistance);\t\t\t\t\t\t\t\t\t//Clamp the result\n    if (angleDistance == 0.0) angleDistance = 1.0;\t\t\t\t\t\t\t//If it's 1 it means that the angle is negative\n    \n    //================================================== Create a point on a circle ==================================================//\n    float point = distance(fromTo, localCircle)/p_circleSize;\t\t\t\t//Create a point around the circle position and resize it\n    point = clamp(point, 0.0, 1.0);\t\t\t\t\t\t\t\t\t\t\t//Clamp the result\n    \n    float masked = (dist+angleDistance);\t\t\t\t\t\t\t\t\t//The variable dist returns a ring. We mask this ring using our angular gradient (angleDistance).\n    masked = clamp01(masked);\t\t\t\t\t\t\t\t\t\t\t\t//Then clamp and then TADA ! We've got our trail.\n    vec3 color = clamp01(vec3(min(masked, point)));\t\t\t\t\t\t\t//We mix our trail and our point using the min value. And then we clamp.\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float clamp01(float v) {return clamp(v, 0.0, 1.0);}\nvec2 clamp01(vec2 v) {return clamp(v, 0.0, 1.0);}\nvec3 clamp01(vec3 v) {return clamp(v, 0.0, 1.0);}\n\nfloat crossV2(vec2 a, vec2 b) \n{\n    return (a.x*b.y) - (a.y*b.x);\n} \n\nfloat Lenght(vec2 a) {\n    return sqrt(dot(a, a));\n}\n\nfloat Lerp(float a, float b, float t) \n{\n    return (1.0 - t) * a + b * t;\n}\n\nfloat InvLerp(float a, float b, float v) \n{\n    return (v - a) / (b - a);\n}\n\nfloat AngleBetween(vec2 a, vec2 b) \n{\n    float lenghtA = Lenght(a);\n    float lenghtB = Lenght(b);\n    float toTest = dot(a,b) / (lenghtA*lenghtB);\n    return acos(toTest);\n}\n\nfloat SignedAngleBetween(vec2 a, vec2 b) \n{\n    float angle = AngleBetween(a,b);\n    float myCross = crossV2(a,b);\n    return angle * sign(myCross);\n}","name":"Common","description":"","type":"common"}]}