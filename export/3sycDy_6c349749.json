{"ver":"0.1","info":{"id":"3sycDy","date":"1603592086","viewed":70,"name":"ProgTober_Rotation","username":"JulesFouchy","description":"Rotation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 uCamX = vec3(0.02645375, -0.0, -0.9996501);\nconst vec3 uCamY = vec3(0.0075564627, 0.9999715, 0.00019996673);\nconst vec3 uCamZ = vec3(0.9996215, -0.0075591076, 0.02645299);\nconst vec3 uCamPos = vec3(5.99773, -0.04535465, 0.15871796);\nconst float uFocalLength = 1.0;\n\nconst vec3 lightDir = normalize(vec3(1,2,3));\n\n#define TAU 6.28\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdf(vec3 p) {\n    return length(p) - 1.0 + 0.1 * sin(p.y*10.+3.141592653);\n}\n\nfloat opTwist(vec3 p)\n{\n    const float k = 3.0; // or some other amount\n    float c = cos(k*p.y+iTime*0.2);\n    float s = sin(k*p.y+3.141592653*iTime*0.2);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdf(q);\n}\n\n\nfloat GetDist(vec3 p) {\n    float res = 0.1 * opTwist(p);\n    return res;\n}\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    vec3 col = vec3(0);\n    vec3 ro = uCamPos; //- vec3(proj.x, 0., proj.y);\n    vec3 rd = normalize(\n          uCamX * (uv.x - 0.5) * iResolution.x / iResolution.y\n        + uCamY * (uv.y - 0.5)\n        - uCamZ * uFocalLength\n    );\n\n    float res = RayMarch(ro, rd);\n    \n    if (res<MAX_DIST) {\n        const vec3 difCol = vec3(0.3, 0.1, 1.);\n        vec3 p = ro + rd * res;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, lightDir)*.5+.5;\n    \tcol += dif * difCol;\n        vec3 nor = GetNormal(p);\n        float shadow = RayMarch(p+0.001, lightDir) < MAX_DIST ? 0.4 : 1.;\n        col *= shadow;\n    }\n    else {\n        float t = 1. - abs(rd.y);\n        col = mix(vec3(8.), vec3(0.2), t);\n    }\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}