{"ver":"0.1","info":{"id":"WtV3Ww","date":"1579082149","viewed":99,"name":"C_HelloRayMarching","username":"hyrchao","description":"RayMatching test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DISTANCE 1000.0\n#define MIN_SURF_DIST 0.01\n#define SPEC_POW 12.0\n#define AMBIENT_LIGHT 0.0\n#define USE_SHADOW 0.0\n\nfloat sphere(vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat ground(vec3 p, float h)\n{\n    return p.y - h;\n}\n\n\nfloat twistGeo(in vec3 p )\n{\n    float k = 5.0 * (1.0 + sin(iTime)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, vec2(0.4 , 0.2));\n}\n\nfloat map(vec3 p)\n{\n    float nd = 0.0;\n    float sd = twistGeo(p);\n    float gd = ground(p, -0.7);\n    nd = min(sd, gd);\n    return nd;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = vec3(\n        map(p + e.xyy) - d,\n        map(p + e.yxy) - d,\n        map(p + e.yyx) - d\n        );\n    return normalize(n);\n}\n    \nfloat tracing(vec3 ro, vec3 rd)\n{\n    float d = 0.0;       // traced distance from light origin\n    vec3 p = ro;         // traced position\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n       \tfloat nd = map(p);\n        d += nd;\n        p = ro + rd * d;\n        if(d > MAX_DISTANCE || nd <MIN_SURF_DIST)\n            break;\n    }\n    return d;\n}\n\n// blin-phong\nvec3 lighting(vec3 p, vec3 rd)\n{\n    float pLightRadius = 10.0;\n    vec3 lightPos = vec3(pLightRadius * sin(iTime), 8.0, pLightRadius * cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = calcNormal(p);\n        \n    float diff = max(dot(n, l), 0.0);   //diffuse  \n    vec3 refl = normalize(-l + 2.0*n*max(dot(l, n), 0.0));\n    float spec = pow(max(dot(rd, refl), 0.0), SPEC_POW); //specular\n    //float spec = 0.0;\n    //diff = 0.0;\n    //spec = 0.0; // debug spec\n    float sd = tracing(p + n * MIN_SURF_DIST * 2.0, l);     \t\t\t\t\t\t// cast a ray from current position to light position\n    float shadow = sd < length(lightPos - p) ? 0.1 : 1.0;            // current position is in shadow if hit anything\n    shadow = mix(1.0, shadow, USE_SHADOW);\n    vec3 col = vec3(diff + spec + AMBIENT_LIGHT);\n    return col * shadow;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float zoom = 0.0;\n    vec3 ro = vec3(30.0 * cos(t), 1.0, 30.0 * sin(t));\n    //vec3 ro = vec3(0.0, 1.0, -5.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    \n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n\tro += f * zoom;\n    vec3 rd = normalize(uv.x * r + uv.y * u - ro);\n    \n    float d = tracing(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    vec3 col = lighting(p, rd);\n\n\n    fragColor = vec4(col, 0.0);\n\n}","name":"Image","description":"","type":"image"}]}