{"ver":"0.1","info":{"id":"X3VGRy","date":"1718008559","viewed":56,"name":"rotate combine","username":"nnew","description":"copypast","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","blackandwhite","rotate","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    return 1.;\n    } else {\n        if (p < 0.5)\n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\n#define iTime (iTime*0.8)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define rot2(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./60.)\n\nfloat bayer8(ivec2 uv)\n{  \n    uv %= 8;\nreturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\n\n#define pmod(p,j) mod(p - 0.5*j,j) - 0.5*j\n\n\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\nreturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    s = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xch(float d, float b){\nreturn b < 0. ? 1.0 - d : d;\n}\n\n\nfloat sdBoxHalf(vec2 p, vec2 s, vec2 dir){\n    vec2 q = p;\np = abs(p) - s;\nfloat d = max(p.x, p.y);\n   \n    d = max(d, -dot(q, dir) - 0.0045);\n   \n    return d;\n}\n\n\nconst float speed = 0.65;\nfloat[] scenes = float[3](1.*speed,1.5*speed, 0.6*speed);\n\nfloat S = 0.5;\nvec3 get( vec2 fragCoord  )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    uv *= 2.;\n    float col = 0.;\n   \n    float d = 10e6;\n   \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n   \n    float pl;\n   \n    float t = iTime;\n   \n    //t += scenes[0];\n    //t += scenes[1] - 0.0;\n    //t += scenes[2] - 0.1;\n    uv *= rot(pi*0.25);\n    t = mod(t, scenes[0] + scenes[1] /* + scenes[2]*/  );\n   \n    float offsamt = 0.5;\n    float offs = -S*offsamt;\n    float offsB = S*(1. - offsamt);\n   \n   \n    if(t < scenes[0]){\n        //float env = ease(t/scenes[0], 2.);\n        float lsp = 1.5;\n        float env = ease(t/scenes[0]*lsp, 1., 1.24, 0.96, 10.);\n       \n        float mov = env * offs*0.;\n        mat2 r = rot(0.*pi);\n        bE = sdBox(uv, vec2(S));\n       \n        float h = 1.43;\n        uv *= rot(0.25*pi);\n        bA = sdBox( (uv - vec2(S/2.,S/2.)*h)*r , vec2(S*env)*0.7);\n        bB = sdBox((uv + vec2(S/2. ,S/2. )*h)*r, vec2(S*env)*0.7);\n        bC = sdBox((uv - vec2(S/2. ,-S/2. )*h)*r, vec2(S*env)*0.7);\n        bD = sdBox((uv + vec2(S/2. ,-S/2. )*h)*r, vec2(S*env)*0.7);\n        col = xch(col,bE);\n        col = xch(col,bA);\n        col = xch(col,bB);\n        col = xch(col,bC);\n        col = xch(col,bD);\n       \n       \n        uv *= rot(0.25*pi);\n        bE = sdBox(uv, vec2(S)*1.);\n       \n        if(t > scenes[0]/lsp*0.74)\n        col -= step(0.,-bE);\n   \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n       \n        float lsp = 2.;\n        float env = ease(t/scenes[1]*lsp, 1., 1.04, 0.96, 10.);\n       \n        float envb = ease(t/scenes[1]*lsp*1.45, 6., 1.0, 0.93, 25.)*0.01*S;\n       \n        float mov = env * offs*0.;\n        mat2 r = rot(1.*pi*env);\n        bE = sdBox(uv, vec2(S));\n       \n        float h = 1.43;\n        uv *= rot(0.25*pi);\n        bA = sdBoxHalf( (uv - vec2(S/2. - envb,S/2.- envb)*h)*r , vec2(S)*(0.7 ), vec2(1.));\n        bB = sdBoxHalf((uv + vec2(S/2. - envb,S/2. - envb)*h)*r, vec2(S)*(0.7 ), vec2(-1.));\n        bC = sdBoxHalf((uv - vec2(S/2.- envb ,-S/2.+ envb )*h)*r, vec2(S)*(0.7 ), vec2(0.5,-0.5));\n        bD = sdBoxHalf((uv + vec2(S/2. - envb,-S/2.+ envb  )*h)*r, vec2(S)*(0.7), vec2(-0.5,0.5));\n       \n       \n        col += step(0.,-bA);\n        col += step(0.,-bB);\n        col += step(0.,-bC);\n        col += step(0.,-bD);\n       \n        if(t > scenes[1]/lsp*0.88){\n            t -= scenes[1]/lsp*0.88;\n            uv *= 1. +  ease(t*0.6 + 0.47, 70., 1.0, pi/1.6, 2000000000.)*0.05*mix(1., 0., smoothstep(0.,1.,t*4.));\n        uv *= rot(-0.25*pi);\n            col -= col;\n        col += step(0.,-sdBox(uv, vec2(S)));\n        }        \n       \n       \n    }  \n   \n    return vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\nvec2 suv = uv;\n   \n    uv *= 1. - dot(uv,uv)*0.205;\n   \n       vec3 col2 = vec3(0);\n   \n    float aa = 5.;\n   \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    col2 += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col2 /= aa*aa;\n   \n    col2 = clamp(col2, 0., 1.);\n    col2 *= 0.999;\n    col2 = 1. - col2;\n   \n   \n   \n    //col *= max((1. + 1.*cos(iTime*1.+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n   \n    col2 *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    //col = 1. - col;\n    vec3 col = vec3(0.004,0.001,0.0);\n    col = smoothstep(0.,1.,col);\n\n    float t = mod(iTime, 1.5);\n   \n    float enva = ease(t*2., 1.);\n    float envb = ease((t + 1.)*2., 2.);\n    float envc = ease((t + 2.)*2., 2.);\n\n    uv.xy *= rot(iTime*1.1);\n\n   \n    uv *= 1.;\n   \n   \n    vec3 p = vec3(uv, 1.);\n    p /= dot(p.xy,p.xy);\n\n\n    #define xor(a,b) a < (b) ? max(a,-(b)) : min(a,(b))\n   \n    float d = 3.;\n    float b = 7.1 ;\n   \n    for(float i = 0.; i < 50.; i++){\n    float dpp = dot(p.xy,p.xy);\n     \n        dpp = clamp(dpp, 0.51,1.5+0.01*cos(iTime) );\n       \n        p = (2. - i*0.03)*p/dpp;\n         \n       \n        //b *= 0.99;\n        p.xy = abs((mod(p.xy- 0.5*b, b) ) - 0.5*b);\n       \n        if(i == 2.)\n    p.x -= 1.1 - pow(enva, 1.2* enva)*1.5 + envb*0.55 + envc*.55;\n   \n    }\n   \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n   \n   \n    float s = 0.002;\n   \n   \n   \n    col += smoothstep(abs(fwidth(suv.x))+col2.x,0., abs(abs(p.x)/p.z)  ) * vec3(0.5,0.5,0.5)*2.6;\n   \n \n   \n    float g = smoothstep(0.0,dFdx(suv.x), -length(min(p.x, p.x))/p.z + s );\n   \n   \n   \n   \n \n   \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}