{"ver":"0.1","info":{"id":"3ddGWn","date":"1568466519","viewed":197,"name":"Quaternion Julia Cross Section","username":"skye_adaire","description":"This shows that the cross section of the quaternion Julia set in the XY plane is the complex Julia set.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","quaternion","dual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define Quaternion vec4\n\nQuaternion H_negate(Quaternion h)\n{\n    return -h;\n}\n\nQuaternion H_conjugate(Quaternion h)\n{\n    return Quaternion(h[0], -h[1], -h[2], -h[3]);\n}\n\nReal H_sqnorm(Quaternion h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Quaternion h)\n{\n    return length(h);\n}\n\nQuaternion H_inverse(Quaternion h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nQuaternion H_normalize(Quaternion h)\n{\n    return normalize(h);\n}\n\nQuaternion H_add(Quaternion lhs, Quaternion rhs)\n{\n    return lhs + rhs;\n}\n\nQuaternion H_subtract(Quaternion lhs, Quaternion rhs)\n{\n    return lhs - rhs;\n}\n\nQuaternion H_multiply(Quaternion lhs, Quaternion rhs)\n{\n    Complex lhs_0 = Complex(lhs[0], lhs[1]);\n    Complex lhs_1 = Complex(lhs[2], lhs[3]);\n    Complex rhs_0 = Complex(rhs[0], rhs[1]);\n    Complex rhs_1 = Complex(rhs[2], rhs[3]);\n\n    return Quaternion(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nQuaternion H_divide(Quaternion lhs, Quaternion rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Quaternion h)\n{\n    return H_norm(h) < eps32;\n}\n\nstruct PolarQuaternion\n{\n    Real norm;\n    Real angle;\n    vec3 axis;//normalized\n};\n\nPolarQuaternion H_toPolar(Quaternion h)\n{\n    PolarQuaternion result;\n    Real vectorLength2 = dot(h.yzw, h.yzw);\n\n    if(H_isZero(vectorLength2))\n    {\n        result.axis = vec3(0);\n    }\n    else//normalize the vector part\n    {\n        result.axis = h.yzw / sqrt(vectorLength2);\n    }\n\n    result.norm = sqrt(H_sq(h[0]) + vectorLength2);\n\n    if(H_isZero(result.norm))\n    {\n        result.angle = 0.0;\n    }\n    else\n    {\n        result.angle = acos(h[0] / result.norm);\n    }\n\n    return result;\n}\n\nQuaternion H_toCartesian(PolarQuaternion p)\n{\n    return p.norm * Quaternion(cos(p.angle), sin(p.angle) * p.axis);\n}\n\nQuaternion H_versor(Real angle, vec3 axis)\n{\n    return H_toCartesian(PolarQuaternion(1.0, angle / 2.0, axis));\n}\n\nPolarQuaternion H_power(PolarQuaternion polar, Real exponent)\n{\n    polar.norm = pow(polar.norm, exponent);\n    polar.angle = polar.angle * exponent;\n    return polar;\n}\n\nQuaternion H_power(Quaternion h, Real exponent)\n{\n    if(H_isZero(exponent))\n    {\n        return Quaternion(1,0,0,0);\n    }\n    else\n    {\n        return H_toCartesian(H_power(H_toPolar(h), exponent));\n    }\n}\n\nQuaternion H_sq(Quaternion h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\n#define DualQuaternion mat2x4\n\nDualQuaternion D_add(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs + rhs;\n}\n\nDualQuaternion D_subtract(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs - rhs;\n}\n\nDualQuaternion D_multiply(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualQuaternion D_divide(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualQuaternion D_power(DualQuaternion d, Real exponent)\n{\n    return DualQuaternion(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat getJuliaDE(DualQuaternion jc, vec3 inPosition, out vec3 outNormal, out int i)\n{\n    Quaternion c = Quaternion(inPosition, 0);\n\n    //directional derivatives\n    DualQuaternion dx = DualQuaternion(c, Quaternion(1,0,0,0));\n    DualQuaternion dy = DualQuaternion(c, Quaternion(0,1,0,0));\n    DualQuaternion dz = DualQuaternion(c, Quaternion(0,0,1,0));\n\n    for(i = 0; i <= 40; i++)\n    {\n        if(H_sqnorm(dx[0]) > 16.0)\n        {\n            break;\n        }\n\n        dx = D_add(D_multiply(dx, dx), jc);\n        dy = D_add(D_multiply(dy, dy), jc);\n        dz = D_add(D_multiply(dz, dz), jc);\n    }\n\n    //the final position is the same for all partials\n    vec3 fp = dx[0].xyz;\n    float r = H_norm(dx[0]);\n    \n    float dr = length(vec3(H_norm(dx[1]), H_norm(dy[1]), H_norm(dz[1])));\n    outNormal = normalize(vec3(dot(fp, dx[1].xyz), dot(fp, dy[1].xyz), dot(fp, dz[1].xyz)));\n\n  \treturn 0.5 * log(r) * r / dr;//better for low iteration counts\n  \t//return 0.5 * r / dr;\n}\n\nfloat getDE(DualQuaternion jc, vec3 position, out int object, out vec3 normal, out int iEscape)\n{\n    float julia = getJuliaDE(jc, position, normal, iEscape);\n    float crossSection = -position.z;\n\n    return max(julia, -crossSection);//subtract;\n}\n\nbool march(\n    DualQuaternion jc,\n    vec3 rp, vec3 rd, \n    out int object, \n    out vec3 globalIntersection, \n    out vec3 globalNormal, \n    out int steps,\n\tout int iEscape)\n{\n    float t = 0.0;\n    vec3 p;\n    \n    bool hit = false;\n    object = -1;\n    \n    for(steps = 0; steps < 200; steps++)\n    {\n        p = rp + t * rd;\n        \n        float de = getDE(jc, p, object, globalNormal, iEscape);\n        \n        if(de < 0.001)\n        {\n            hit = true;\n            break; \n        }\n\n        t += de;\n    }  \n    \n    globalIntersection = p;\n    \n    return hit;\n}\n\nbool checkered(vec2 z)\n{\n\tbool x = int(z.x) % 2 == 0;\n\tbool y = int(z.y) % 2 == 0;\n\tif(z.x < 0.0) x = !x;\n\tif(z.y < 0.0) y = !y;\n\treturn x == y;\n}\n\nvec3 colorCheckered(vec2 z)\n{\n\treturn checkered(z) ? vec3(1) : vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //view basis\n    mat3 viewTransform = rotationXZ((iTime * 0.0));\n    vec3 viewPosition = viewTransform * vec3(0, 0, 1);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n    \n    //julia constant\n    float time = 0.2 * iTime;\n    float ct = cos(time) * 0.8;// * 0.35 + 0.65 + 0.35 / 2.0;\n    float st = sin(time) * 0.8;\n    Quaternion d = Quaternion(st, ct, 0,0);\n    DualQuaternion jc = DualQuaternion(d, Quaternion(0));\n\n    vec3 color = vec3(0);\n    int object = -1;\n    vec3 intersection;\n    vec3 normal;\n   \tint steps;\n    int escape;\n    \n    if(march(jc, srp, srd, object, intersection, normal, steps, escape))\n    {\n        vec3 surfaceColor = hsv2rgb(vec3(float(escape) / 20.0, 1, 1));\n   \t\tfloat fade = 1.0 - float(steps) / 100.0;\n        fade *= fade;\n    \tcolor += surfaceColor * fade;\n    }\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}