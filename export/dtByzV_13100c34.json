{"ver":"0.1","info":{"id":"dtByzV","date":"1692011910","viewed":136,"name":"Fork Pixel art fire","username":"Carandiru","description":"original shader Pixel art Flame Shader by iladrien\n\ntemporally interpolated adjust MIXOLD in common to sharpen or blur temporally\ntemporal interpolation between frame and frame + 1 is always on and is not affected by MIXOLD.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","flame","perlin","pixelart"],"hasliked":0,"parentid":"mtjyzG","parentname":"Pixel art Flame Shader"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// temporally interpolated adjust MIXOLD in common to sharpen or blur temporally\n// temporal interpolation between frame and frame + 1 is always on and is not affected by MIXOLD.\n//\n// original shader Pixel art Flame Shader by iladrien - https://www.shadertoy.com/view/mtjyzG\n//\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 color1 = texture(iChannel1, uv).rgb;\n\n    float ft0 = length(color) * uv.x * abs(sin(uv.x + fract(iTime) * 3.14) );\n    float ft1 = length(color1) * uv.x * abs(sin(uv.x + fract(iTime) * -3.14) );\n    \n    color = mix(color, color1, fract(iTime));\n    float m = mix(ft1/length(color), ft0/length(color), fract(iTime));\n\n    color = mix(color, color*color*color*color*color, m);\n    color = color*color*(1.0f-m);\n    \n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float Step(float a, float threshold) {\n    return (a < threshold) ? 0. : 1.;\n}\n\nvec4 Mix(vec4 a, vec4 b) {\n    return mix(a, b, b.a);\n}\n\nfloat Noise21(vec2 uv) {\n    const int w = 64;\n    const int s = 32;\n    \n    int a = int(uv.x);\n    int b = int(uv.y);\n    \n    a *= 3284157443; b ^= a << s | a >> w - s;\n    b *= 1911520717; a ^= b << s | b >> w - s;\n    a *= 2048419325;\n    \n    float rand = float(a) * (3.14159265 / float(~(~0u >> 1)));\n    \n    return cos(rand) / 2. + 0.5;\n}\n\nvec2 Noise22(vec2 uv) {\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat SmoothNoise(vec2 uv) {\n    // Calculate the grid cell index for the UV coordinate.\n    vec2 id = floor(uv);\n\n    // Calculate the fractional UV coordinate within the grid cell.\n    vec2 lv = fract(uv);\n\n    // Apply a smooth interpolation function to the fractional UV coordinate.\n    lv = lv * lv * (3. - 2. * lv);\n\n    // Obtain noise values for the four corners of the grid cell.\n    float tl = Noise21(id + vec2(0, 1)); // Top-left\n    float bl = Noise21(id);              // Bottom-left\n    float tr = Noise21(id + vec2(1, 1)); // Top-right\n    float br = Noise21(id + vec2(1, 0)); // Bottom-right\n\n    // Interpolate noise values along the x-axis.\n    float t = mix(tl, tr, lv.x); // Interpolate between top-left and top-right\n    float b = mix(bl, br, lv.x); // Interpolate between bottom-left and bottom-right\n\n    // Interpolate between the top and bottom noise values along the y-axis.\n    // The final noise value is obtained by blending between the bottom and top noise values based on the vertical position within the grid cell.\n    return mix(b, t, lv.y);\n}\n\n\nfloat LayerNoise(vec2 uv) {\n    // Initialize the variables for the final result and the accumulation of amplitudes.\n    float result = 0.;\n    float delta = 0.;\n\n    // Set initial values for frequency and amplitude.\n    float freq = 10.; // Frequency of the noise\n    float amp = 1.;   // Initial amplitude\n\n    // Loop through iterations to accumulate noise at different frequencies and amplitudes.\n    for (float i = 0.; i < 4.; i++) {\n        // Accumulate the noise value at the current UV position, scaled by the frequency and amplitude.\n        result += SmoothNoise(uv * freq) * amp;\n\n        // Accumulate the amplitude for normalization.\n        delta += amp;\n\n        // Reduce the amplitude and double the frequency for the next iteration.\n        amp /= 2.;\n        freq *= 2.;\n    }\n\n    // Return the normalized accumulated noise value.\n    // This is done by dividing the accumulated result by the accumulated amplitude.\n    return result / delta;\n}\n\n\nfloat VoronoiNoise(vec2 uv, float t) {\n    // Calculate the grid cell index for the UV coordinate.\n    vec2 id = floor(uv);\n\n    // Calculate the centered fractional UV coordinate.\n    vec2 lv = fract(uv) - 0.5;\n\n    // Initialize a high value for tracking the minimum distance.\n    float minDist = 100.;\n\n    // Iterate over the surrounding grid cells.\n    for (float x = -1.; x <= 1.; x++)\n    for (float y = -1.; y <= 1.; y++) {\n        // Offset for the current grid cell.\n        vec2 offs = vec2(x, y);\n\n        // Obtain a noise value based on the current grid cell.\n        vec2 n = Noise22(id + offs);\n\n        // Perturb the position using sinusoidal variation over time.\n        vec2 p = offs + sin(n * t) * 0.5;\n\n        // Calculate the distance between the centered UV and perturbed position.\n        float d = length(lv - p);\n\n        // Keep track of the minimum distance.\n        minDist = min(minDist, d);\n    }\n\n    // Apply a smoothstep function to the minimum distance to create a smooth transition effect.\n    return minDist * 2.0f;//smoothstep(0., 1., minDist);\n}\n\nvec4 FlameLayer(vec2 uv, float t, vec3 col, float threshold) {\n    // Generate noise for the layer using a function called LayerNoise.\n    // The UV coordinate is modified by a time-dependent offset to create animation.\n    float layerNoise = LayerNoise(uv + vec2(0.25, -0.5) * t);\n    \n    // Generate noise using VoronoiNoise function.\n    // The UV coordinate is scaled and translated by a time-dependent offset.\n    float voronoiNoise = VoronoiNoise(uv * 3. + vec2(0., -0.25) * t, t);\n\n    // Initialize the resulting value as 0.\n    float res = 0.;\n\n    // Add the layerNoise value to the result.\n    res += layerNoise;\n\n    // Mix the result with the voronoiNoise value, using a mix factor of 0.7.\n    // This blends the two noise values together, creating more complexity.\n    res *= mix(res, voronoiNoise, 0.7);\n\n    // Apply smoothstep function to 'res'.\n    // Smoothstep smooths out the transition from the threshold to 0 based on the UV's y-coordinate.\n    res = smoothstep(res, 0., uv.y);\n    \n    // Apply a step function to 'res' using the provided threshold.\n    // This function essentially creates a binary effect where values above the threshold become 1 and below become 0.\n    res = Step(res, threshold);\n\n    // Return a vec4 with the original color 'col' and the modified 'res' value.\n    return vec4(col, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalize the pixel coordinate (fragCoord) to UV space using iResolution.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Offset the y-coordinate to center the image vertically.\n    uv.y += 0.5;\n\n    // Define the size of each \"pixel\" in UV space.\n    float pixelSize = 64.;\n    \n    // Snap the UV coordinates to a grid based on pixelSize.\n    uv -= mod(uv, 1. / vec2(pixelSize, pixelSize));\n    \n    // Initialize the color as black.\n    vec4 col = vec4(0);\n    \n    // Mix the result of FlameLayer function calls with different colors and thresholds.\n    //\n    // In fact, this part is poorly optimized. It would be better to move the calculation \n    // of the Perlin and Voronoi noise outside the FlameLayer, which would significantly reduce\n    // the number of calculations. \n    // \n    // However, I prefer to have more control over each layer separately.\n    float t = iTime;\n    \n    col = Mix(col, FlameLayer(uv, t, vec3(0.769, 0.153, 0.153), 0.001));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.886, 0.345, 0.133), 0.1));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.914, 0.475, 0.102), 0.5));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.945, 0.604, 0.067), 0.8));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.973, 0.729, 0.035), 0.9));\n    col = Mix(col, FlameLayer(uv, t, vec3(1., 0.9, 0.6), 0.99));\n    \n    // Assign the final color to the output fragment color.\n    fragColor = mix(col, texture(iChannel1, fragCoord.xy/iResolution.xy), MIXOLD);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float Step(float a, float threshold) {\n    return (a < threshold) ? 0. : 1.;\n}\n\nvec4 Mix(vec4 a, vec4 b) {\n    return mix(a, b, b.a);\n}\n\nfloat Noise21(vec2 uv) {\n    const int w = 64;\n    const int s = 32;\n    \n    int a = int(uv.x);\n    int b = int(uv.y);\n    \n    a *= 3284157443; b ^= a << s | a >> w - s;\n    b *= 1911520717; a ^= b << s | b >> w - s;\n    a *= 2048419325;\n    \n    float rand = float(a) * (3.14159265 / float(~(~0u >> 1)));\n    \n    return cos(rand) / 2. + 0.5;\n}\n\nvec2 Noise22(vec2 uv) {\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat SmoothNoise(vec2 uv) {\n    // Calculate the grid cell index for the UV coordinate.\n    vec2 id = floor(uv);\n\n    // Calculate the fractional UV coordinate within the grid cell.\n    vec2 lv = fract(uv);\n\n    // Apply a smooth interpolation function to the fractional UV coordinate.\n    lv = lv * lv * (3. - 2. * lv);\n\n    // Obtain noise values for the four corners of the grid cell.\n    float tl = Noise21(id + vec2(0, 1)); // Top-left\n    float bl = Noise21(id);              // Bottom-left\n    float tr = Noise21(id + vec2(1, 1)); // Top-right\n    float br = Noise21(id + vec2(1, 0)); // Bottom-right\n\n    // Interpolate noise values along the x-axis.\n    float t = mix(tl, tr, lv.x); // Interpolate between top-left and top-right\n    float b = mix(bl, br, lv.x); // Interpolate between bottom-left and bottom-right\n\n    // Interpolate between the top and bottom noise values along the y-axis.\n    // The final noise value is obtained by blending between the bottom and top noise values based on the vertical position within the grid cell.\n    return mix(b, t, lv.y);\n}\n\n\nfloat LayerNoise(vec2 uv) {\n    // Initialize the variables for the final result and the accumulation of amplitudes.\n    float result = 0.;\n    float delta = 0.;\n\n    // Set initial values for frequency and amplitude.\n    float freq = 10.; // Frequency of the noise\n    float amp = 1.;   // Initial amplitude\n\n    // Loop through iterations to accumulate noise at different frequencies and amplitudes.\n    for (float i = 0.; i < 4.; i++) {\n        // Accumulate the noise value at the current UV position, scaled by the frequency and amplitude.\n        result += SmoothNoise(uv * freq) * amp;\n\n        // Accumulate the amplitude for normalization.\n        delta += amp;\n\n        // Reduce the amplitude and double the frequency for the next iteration.\n        amp /= 2.;\n        freq *= 2.;\n    }\n\n    // Return the normalized accumulated noise value.\n    // This is done by dividing the accumulated result by the accumulated amplitude.\n    return result / delta;\n}\n\n\nfloat VoronoiNoise(vec2 uv, float t) {\n    // Calculate the grid cell index for the UV coordinate.\n    vec2 id = floor(uv);\n\n    // Calculate the centered fractional UV coordinate.\n    vec2 lv = fract(uv) - 0.5;\n\n    // Initialize a high value for tracking the minimum distance.\n    float minDist = 100.;\n\n    // Iterate over the surrounding grid cells.\n    for (float x = -1.; x <= 1.; x++)\n    for (float y = -1.; y <= 1.; y++) {\n        // Offset for the current grid cell.\n        vec2 offs = vec2(x, y);\n\n        // Obtain a noise value based on the current grid cell.\n        vec2 n = Noise22(id + offs);\n\n        // Perturb the position using sinusoidal variation over time.\n        vec2 p = offs + sin(n * t) * 0.5;\n\n        // Calculate the distance between the centered UV and perturbed position.\n        float d = length(lv - p);\n\n        // Keep track of the minimum distance.\n        minDist = min(minDist, d);\n    }\n\n    // Apply a smoothstep function to the minimum distance to create a smooth transition effect.\n    return minDist * 2.0f;//smoothstep(0., 1., minDist);\n}\n\nvec4 FlameLayer(vec2 uv, float t, vec3 col, float threshold) {\n    // Generate noise for the layer using a function called LayerNoise.\n    // The UV coordinate is modified by a time-dependent offset to create animation.\n    float layerNoise = LayerNoise(uv + vec2(0.25, -0.5) * t);\n    \n    // Generate noise using VoronoiNoise function.\n    // The UV coordinate is scaled and translated by a time-dependent offset.\n    float voronoiNoise = VoronoiNoise(uv * 3. + vec2(0., -0.25) * t, t);\n\n    // Initialize the resulting value as 0.\n    float res = 0.;\n\n    // Add the layerNoise value to the result.\n    res += layerNoise;\n\n    // Mix the result with the voronoiNoise value, using a mix factor of 0.7.\n    // This blends the two noise values together, creating more complexity.\n    res *= mix(res, voronoiNoise, 0.7);\n\n    // Apply smoothstep function to 'res'.\n    // Smoothstep smooths out the transition from the threshold to 0 based on the UV's y-coordinate.\n    res = smoothstep(res, 0., uv.y);\n    \n    // Apply a step function to 'res' using the provided threshold.\n    // This function essentially creates a binary effect where values above the threshold become 1 and below become 0.\n    res = Step(res, threshold);\n\n    // Return a vec4 with the original color 'col' and the modified 'res' value.\n    return vec4(col, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalize the pixel coordinate (fragCoord) to UV space using iResolution.\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Offset the y-coordinate to center the image vertically.\n    uv.y += 0.5;\n\n    // Define the size of each \"pixel\" in UV space.\n    float pixelSize = 64.;\n    \n    // Snap the UV coordinates to a grid based on pixelSize.\n    uv -= mod(uv, 1. / vec2(pixelSize, pixelSize));\n    \n    // Initialize the color as black.\n    vec4 col = vec4(0);\n    \n    // Mix the result of FlameLayer function calls with different colors and thresholds.\n    //\n    // In fact, this part is poorly optimized. It would be better to move the calculation \n    // of the Perlin and Voronoi noise outside the FlameLayer, which would significantly reduce\n    // the number of calculations. \n    // \n    // However, I prefer to have more control over each layer separately.\n    float t = iTime + iTimeDelta;\n    \n    col = Mix(col, FlameLayer(uv, t, vec3(0.769, 0.153, 0.153), 0.001));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.886, 0.345, 0.133), 0.1));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.914, 0.475, 0.102), 0.5));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.945, 0.604, 0.067), 0.8));\n    col = Mix(col, FlameLayer(uv, t, vec3(0.973, 0.729, 0.035), 0.9));\n    col = Mix(col, FlameLayer(uv, t, vec3(1., 0.9, 0.6), 0.99));\n    \n    // Assign the final color to the output fragment color.\n   fragColor = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy), MIXOLD);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MIXOLD 0.84f     //  sharper (lower)  0.618034f      blurrier (higher)  0.9f","name":"Common","description":"","type":"common"}]}