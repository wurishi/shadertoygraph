{"ver":"0.1","info":{"id":"ttsfWH","date":"1596807705","viewed":104,"name":"RacingCourtGenerator","username":"Mario8664","description":"Generate a racing court height map for my procedural game.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","generator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    float d = sqrt(col.b);\n    \n    d = ceil(d - iResolution.x / 15000.0);\n    \n    // Output to screen\n    fragColor = vec4(d, d, d, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdf(vec2 pos)\n{\n    int seed = iFrame / 60;\n    float angle = atan(pos.y / pos.x);\n    if(pos.x < 0.0)\n        angle -= 3.1415926535897932384626;\n    \n    float radius = GetRadius(angle, seed);\n    float dr = abs(GetRadius(angle - 0.013, seed) - radius);\n    float width = GetWidth(angle, dr);\n    \n    float circut = abs(length(pos) - radius) / width;\n    circut = clamp(pow(circut, 2.0), 0.0, 1.0);\n    return circut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sdfuv = (fragCoord - iResolution.xy * 0.5)/iResolution.y * 150.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col;\n    \n    if(iFrame == 0 || iFrame % 60 == 0)\n    {\n        col = vec4(sdf(sdfuv));\n    }\n    else if(iFrame % 1 == 0)\n    {\n        \n        vec3 os = vec3(-1.0, 0.0, 1.0);\n        vec2 o = vec2(1.0) / iResolution.xy;\n        vec3 cn = texture(iChannel0, uv).rgb;\n        \n        vec2 c0 = texture(iChannel0, uv + o * os.xy).rg + 1.0 * UNIT * os.zy;\n        vec2 c1 = texture(iChannel0, uv + o * os.yx).rg + 1.0 * UNIT * os.yz;\n        vec2 c2 = texture(iChannel0, uv + o * os.zy).rg + 1.0 * UNIT * os.zy;\n        vec2 c3 = texture(iChannel0, uv + o * os.yz).rg + 1.0 * UNIT * os.yz;\n        \n        float cc0 = dot(c0, c0);\n        float cc1 = dot(c1, c1);\n        float cc2 = dot(c2, c2);\n        float cc3 = dot(c3, c3);\n        \n        vec2 c = c0;\n        float cc = cc0;\n        if(cc1 < cc)\n        {\n            c = c1;\n            cc = cc1;\n        }\n        if(cc2 < cc)\n        {\n            c = c2;\n            cc = cc2;\n        }\n        if(cc3 < cc)\n        {\n            c = c3;\n            cc = cc3;\n        }\n        \n        if(cc < cn.b)\n        {\n            col = vec4(c, cc, sdf(sdfuv));\n        }\n        else\n        {\n            col = vec4(cn, sdf(sdfuv));\n        }\n    }\n    else\n    {\n        col = texture(iChannel0, uv);\n    }\n    \n\n    fragColor = col;//vec4(uv, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define UNIT 0.003\n#define SEED 45\n\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\nint nextInt(inout int seed, in int minI, in int maxI) {\n    seed = xorshift(seed);\n    return minI + seed % (maxI - minI);\n}\n\nfloat nextFloat(inout int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nfloat nextFloat(inout int seed, in float maxf) {\n    return nextFloat(seed) * maxf;\n}\n\nfloat nextFloat(inout int seed, in float minf, in float maxf) {\n    return minf + nextFloat(seed) * (maxf - minf);\n}\n\nfloat GetRadius(float angle, int seed)\n{\n    float r0 = nextFloat(seed, 40.0, 50.0);\n    float r1 = sin(angle + nextFloat(seed, 0.0, 3.14));\n    float r11 = nextFloat(seed, 3.0, 5.0) * sin(angle + nextFloat(seed, 0.0, 3.14));\n    float r12 = nextFloat(seed, 3.0, 5.0) * sin(angle + nextFloat(seed, 0.0, 3.14));\n    float r2 = nextFloat(seed, 4.0, 10.0) * sin( float(nextInt(seed, 1, 3)) * (angle + nextFloat(seed, 0.0, 3.14)));\n    float r3 = nextFloat(seed, 5.0, 7.0) * sin(float(nextInt(seed, 3, 5)) * (angle + nextFloat(seed, 0.0, 3.14)));\n    float r31 = nextFloat(seed, 4.0, 6.0) * sin(float(nextInt(seed, 2, 6)) * (angle + nextFloat(seed, 0.0, 3.14)));\n    float r32 = nextFloat(seed, 5.0, 7.0) * sin(float(nextInt(seed, 4, 6)) * (angle + nextFloat(seed, 0.0, 3.14)));\n    float r4 = nextFloat(seed, 2.6, 6.4) * sin(float(nextInt(seed, 6, 10)) * (angle + nextFloat(seed, 0.0, 3.14)));\n    float r5 = nextFloat(seed, 0.8, 3.2) * sin(float(nextInt(seed, 2, 6)) * (angle + nextFloat(seed, 0.0, 3.14)));\n    float radius = r0 + r1 + r11 + r12 + r2 + r3 + r31 + r32 + r4 + r5;\n    return radius;\n}\n\nfloat GetWidth(float angle, float dr)\n{\n    float w0 = 10.0;\n \treturn w0;\n}\n","name":"Common","description":"","type":"common"}]}