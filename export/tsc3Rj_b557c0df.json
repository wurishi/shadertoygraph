{"ver":"0.1","info":{"id":"tsc3Rj","date":"1568842184","viewed":1727,"name":"Mandelbulb 3D Fractal","username":"Nazlbit","description":"This is the visualization of the Mandelbulb 3D fractal.\n\nhttps://youtu.be/VMqlgqWFp00\nhttps://github.com/Nazlbit/mandelbulb_visualization","likes":13,"published":1,"flags":64,"usePreview":0,"tags":["fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tsGWB","filepath":"https://soundcloud.com/sad_production/cosmic-full-ver","previewfilepath":"https://soundcloud.com/sad_production/cosmic-full-ver","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Try to tweak this values\nconst float epsilon = 0.002;\nconst float fov = radians(35.);\nconst float mandelbulb_power = 8.;\nconst float view_radius = 10.;\nconst int mandelbulb_iter_num = 15;\nconst float camera_distance = 4.;\nconst float rotation_speed = 1./36.5;\n\nfloat mandelbulb_sdf(vec3 pos) {\n    vec2 cursor = iMouse.xy / iResolution.xy;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < mandelbulb_iter_num ; i++)\n\t{\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n\n\t\tdr =  pow( r, mandelbulb_power-1.0)*mandelbulb_power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,mandelbulb_power);\n\t\ttheta = theta*mandelbulb_power;\n\t\tphi = phi*mandelbulb_power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat scene_sdf(vec3 p)\n{\n\treturn mandelbulb_sdf(p);\n}\n\nvec3 ray_marching(const vec3 eye, const vec3 ray, out float depth, out float steps)\n{\n\tdepth = 0.;\n\tsteps = 0.;\n\tfloat dist;\n\tvec3 intersection_point;\n\n\tdo\n\t{\n\t\tintersection_point = eye + depth*ray;\n\t\tdist = scene_sdf(intersection_point);\n\t\tdepth += dist;\n\t\tsteps++;\n\t}\n\twhile(depth < view_radius && dist > epsilon);\n\n\treturn intersection_point;\n}\n\nvec3 estimate_normal(const vec3 p, const float delta)\n{\n    return normalize(vec3(\n        scene_sdf(vec3(p.x + delta, p.y, p.z)) - scene_sdf(vec3(p.x - delta, p.y, p.z)),\n        scene_sdf(vec3(p.x, p.y + delta, p.z)) - scene_sdf(vec3(p.x, p.y - delta, p.z)),\n        scene_sdf(vec3(p.x, p.y, p.z  + delta)) - scene_sdf(vec3(p.x, p.y, p.z - delta))\n    ));\n}\n\n\nvec2 transformed_coordinates(vec2 frag_coord)\n{\n\tvec2 coord = (frag_coord / iResolution.xy)*2. - 1.;\n\tcoord.y *= iResolution.y / iResolution.x;\n\treturn coord;\n}\n\nfloat contrast(float val, float contrast_offset, float contrast_mid_level)\n{\n\treturn clamp((val - contrast_mid_level) * (1. + contrast_offset) + contrast_mid_level, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = transformed_coordinates(fragCoord);\n    \n\tvec3 ray = normalize(vec3(coord*tan(fov), 1));\n\n    float angle = radians(360.)*iTime*rotation_speed;\n    \n    mat3 cam_basis = mat3(0, cos(angle), sin(angle),\n                          -1, 0, 0,\n                          0, -sin(angle), cos(angle));\n    \n\tray = cam_basis*ray;\n    \n    vec3 cam_pos = -cam_basis[2]*camera_distance;\n    \n\tfloat depth = 0.;\n\tfloat steps = 0.;\n\tvec3 intersection_point = ray_marching(cam_pos + epsilon*ray, ray, depth, steps);\n\n\t//AO\n\n\tfloat ao = steps * 0.01;\n\tao = 1. - ao / (ao + 0.5);  // reinhard\n\n\tconst float contrast_offset = 0.3;\n\tconst float contrast_mid_level = 0.5;\n\tao = contrast(ao, contrast_offset, contrast_mid_level);\n\n\tvec3 normal = estimate_normal(intersection_point, epsilon*0.5);\n\n\tvec3 fColor = ao*(normal*0.5 + 0.5);\n    \n    // Output to screen\n    fragColor = vec4(fColor,1.0);\n}","name":"Image","description":"","type":"image"}]}