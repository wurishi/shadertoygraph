{"ver":"0.1","info":{"id":"tsfSRB","date":"1551536482","viewed":128,"name":"newkek2","username":"MaxON","description":"qwerty","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 color;\n    vec3 direction;\n};\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\nstruct Intersect {\n    float len;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Box {\n    vec3 min_point;\n    vec3 max_point;\n    Material material;\n};\n    \nstruct Plane {\n    vec3 normal;\n    Material material;\n};\n\nconst float epsilon = 0.001;\n\nconst int iterations = 16;\n\nconst float exposure = 0.01;\nconst float gamma = 2.2;\nconst float intensity = 100.0;\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\nIntersect intersect(Ray ray, Sphere sphere) {\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) return miss;\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\nIntersect intersect(Ray ray, Box box) {\n    vec3 t_min = (box.min_point - ray.origin)/ray.direction;\n    vec3 t_max = (box.max_point - ray.origin)/ray.direction;\n    vec3 t_enter = vec3(min(t_min.x, t_max.x), min(t_min.y, t_max.y), min(t_min.z, t_max.z));\n    float max_t_enter = max(t_enter.x, max(t_enter.y, t_enter.z));\n    vec3 oc = ray.origin + max_t_enter * ray.direction;\n    if (oc.x < box.min_point.x || oc.y < box.min_point.y || oc.z < box.min_point.z || oc.x > box.max_point.x || oc.y > box.max_point.y || oc.z > box.max_point.z) {\n    //if (length(oc) < length(box.max_point) || length(oc) > length(box.min_point)) {\n        return miss;\n    }\n    vec3 dir = oc - (box.max_point + box.min_point) / 2.0;\n    float x = abs(dir.x),y = abs(dir.y),z = abs(dir.z);\n    vec3 norm;\n    if (x >= y && x >= z) {\n        norm = vec3(sign(dir.x),0.0,0.0);\n    }\n    else if (y >= x && y >= z) {\n        norm = vec3(0.0,sign(dir.y),0.0);\n    }\n    else {\n        norm = vec3(0.0,0.0,sign(dir.z));\n    }\n    return Intersect(length(oc), norm, box.material);\n    /*vec3 dis=(box.max_point + box.min_point) / 2.0-ray.origin;\n    float x=abs(dis.x),y=abs(dis.y),z=abs(dis.z);\n    vec4 m;\n    float len = sqrt(pow(length(box.max_point - box.min_point), 2.0) / 3.0);\n    if(x>=y&&x>=z){\n        y=len/2.0*y/x;\n        z=len/2.0*z/x;\n        x=len/2.0;\n        m.xyz=-vec3(sign(dis.x),0.0,0.0);\n    }\n    else if(y>=x&&y>=z){\n        x=len/2.0*x/y;\n        z=len/2.0*z/y;\n        y=len/2.0;\n        m.xyz=-vec3(0.0,sign(dis.y),0.0);\n    }\n    else{\n        x=len/2.0*x/z;\n        y=len/2.0*y/z;\n        z=len/2.0;\n        m.xyz=-vec3(0.0,0.0,sign(dis.z));\n    }\n    m.w=length(dis)-length(vec3(x,y,z));\n    return Intersect(m.w, -m.xyz, box.material);*/\n    \n}\n\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n    if (len < 0.0) return miss;\n    return Intersect(len, plane.normal, plane.material);\n}\n\nIntersect trace(Ray ray) {\n    const int num_spheres = 2;\n    Sphere spheres[num_spheres];\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\n    Box box1 = Box(vec3( -0.5, 0.0, 5.0), vec3( 1.5, 2.0, 7.0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n    Intersect intersection = miss;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(0.0, 0.0, 1.0), 1.0, 0.0)));\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\n    for (int i = 0; i < num_spheres; i++) {\n        Intersect sphere = intersect(ray, spheres[i]);\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n            intersection = sphere;\n    }\n    Intersect box = intersect(ray, box1);\n    if (box.material.diffuse > 0.0 || box.material.specular > 0.0)\n        intersection = box;\n    return intersection;\n}\n\nvec3 radiance(Ray ray) {\n    Light light1 = Light(vec3(1.0) * intensity, normalize(vec3(-1.0 + 4.0 * cos(iTime), 4.75, 1.0 + 4.0 * sin(iTime))));\n    Light light2 = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    for (int i = 0; i <= iterations; ++i) {\n        Intersect hit = trace(ray);\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light1.direction, light1.direction)) == miss) {\n                color += clamp(dot(hit.normal, light1.direction), 0.0, 1.0) * light1.color\n                       * hit.material.color.rgb * hit.material.diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n            }\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light2.direction, light2.direction)) == miss) {\n                color += clamp(dot(hit.normal, light2.direction), 0.0, 1.0) * light2.color\n                       * hit.material.color.rgb * hit.material.diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n            }\n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\n\n        } else {\n            vec3 spotlight1 = vec3(1e6) * pow(abs(dot(ray.direction, light1.direction)), 250.0);\n            vec3 spotlight2 = vec3(1e6) * pow(abs(dot(ray.direction, light2.direction)), 250.0);\n            vec3 spotlight = spotlight1 + spotlight2;\n            color += mask * (ambient + spotlight); break;\n        }\n    }\n    return color;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.7);\n         uv.x *= iResolution.x / iResolution.y;\n    Ray ray = Ray(vec3(2.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}