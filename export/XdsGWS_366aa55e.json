{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Open source under the MIT license\n// By Morgan McGuire @morgan3d\n// http://casual-effects.com\n\n//#define HAS_WEBGL_MIP_BIAS\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\nconst float meters      = 1.0;\nconst float centimeters = 0.01;\nconst float inf         = 1.0 / 0.0;\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n#define Vector3      vec3\n#define Color3       vec3\n#define Radiance3    vec3\n#define Power3       vec3\n#define Biradiance3  vec3\n#define Point3       vec3\n\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\nfloat pow5(float x) { float y = square(x); return square(y) * x; }\n\nstruct Ray {\n\tPoint3      origin;\n\t/** Unit direction of propagation */\n\tVector3     direction;\n};\n\t\nstruct Material {\n\tColor3      color;\n\tfloat       metal;\n\tfloat       smoothness;\n};\n\nstruct Surfel {\n\tPoint3\t\tposition;\n\t/** Shading normal */\n\tVector3\t\tnormal;\n\t\n\tMaterial    material;\n};\n\t\nstruct Sphere {\n\tPoint3      center;\n\tfloat       radius;\n\tMaterial    material;\n};\n\t\n// Updates the distance to the first surfel, if closer than distance,\n// and returns true on intersection or false if no intersection.\n// This uses the implicit equation for the surface of the sphere.\t\n// See Graphics Codex [raySphr]\nbool intersectSphere(Sphere sphere, Ray R, inout float distance, inout Surfel surfel) {\n\tPoint3  C = sphere.center;\n\tfloat   r = sphere.radius;\n\tPoint3  P = R.origin;\n\tVector3 w = R.direction;\n\t\n\tVector3 v = P - C;\n\tfloat b = 2.0 * dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = square(b) - 4.0 * c;\n\tif (d < 0.0) { return false; }\n\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\tfloat t = min(infIfNegative((-b - dsqrt) / 2.0),\n\t\t\t\t  infIfNegative((-b + dsqrt) / 2.0));\n\n\tif (t < distance) {\t\n\t\tsurfel.position = P + w * t;\n\t\tsurfel.normal   = normalize(surfel.position - C);\n\t\tsurfel.material = sphere.material;\n\t\t\n\t\tdistance = t;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n//////////////////////////////////////////////////////////\n\n// Parameters\nconst float verticalFieldOfView = 50.0 * degrees;\nconst float exposure = 1.0;\nconst float rayBumpEpsilon = 0.01;\n\n#define radianceMap iChannel0\n#define radianceMapResolution iChannelResolution[0]\n#define irradianceMap iChannel1\n#define irradianceMapResolution iChannelResolution[1]\n\n\nSphere sphere1;\nSphere sphere2;\n\n\nbool intersectScene(Ray R, inout float maxDist, inout Surfel surfel) {\n\tbool hit = false;\n\tif (intersectSphere(sphere1, R, maxDist, surfel)) { hit = true; }\n\tif (intersectSphere(sphere2, R, maxDist, surfel)) { hit = true; }\n\treturn hit;\n}\n\n\nvoid computeReflectivities(Material material, out Color3 p_L, out Color3 p_G, out float glossyExponent) {\n\tp_L = mix(material.color, Color3(0.0), material.metal);\n\tp_G = mix(Color3(0.04), material.color, material.metal);\n\tglossyExponent = exp2(material.smoothness * 14.0);\n}\n\n\nRadiance3 shade(Surfel surfel, Vector3 w_i, Vector3 w_o, Biradiance3 B_i) {\n\tVector3 w_h = normalize(w_i + w_o);\n\tVector3 n   = surfel.normal;\n\t\n\tColor3 p_L, p_G;\n\tfloat glossyExponent;\n\tcomputeReflectivities(surfel.material, p_L, p_G, glossyExponent);\n\n\t// Compute the light contribution from the directional source\n\treturn max(0.0, dot(n, w_i)) * B_i * \n\t\t// Lambertian\n\t\t(p_L / pi + \n\n\t\t// Glossy\n        pow(max(0.0, dot(n, w_h)), glossyExponent) * p_G * (glossyExponent + 8.0) / (8.0 * pi));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t//////////////////////////////////////\n\t// Scene setup\t\n\t// Directional light source\n    Vector3     w_i     = normalize(Vector3(1.0));\n\tBiradiance3 B_i     = Biradiance3(2.0); \n\n\tsphere1.center = Point3(cos(iTime), 1.0 + cos(iTime * 0.5), -5);\n\tsphere1.radius = 1.0;\n\tsphere1.material = Material(Color3(1.0, 0.2, 0.0), 1.0, 0.8);\n\t\n\tsphere2.center = Point3(0, -100001.0, -5);\n\tsphere2.radius = 100000.0;\n\tsphere2.material = Material(Color3(0.5), 0.0, 0.2);\n\t\n\t////////////////////////////\n\t\n\t// Outgoing light\n\tRadiance3 L_o;\n\t\n\tSurfel surfel;\t\n\tfloat maxDist = inf;\t\n\t\n\tRay eyeRay = Ray(Point3(0.0),\n\t\t\t\t\t normalize(Vector3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / ( -2.0 * tan(verticalFieldOfView / 2.0)))));\n\t\n\tif (intersectScene(eyeRay, maxDist, surfel)) {\n\t\t// Mirror reflection vector\n\t\tVector3 w_m = -reflect(-eyeRay.direction, surfel.normal);\n\n\t\tColor3 p_L, p_G;\n\t\tfloat glossyExponent;\n\t\tcomputeReflectivities(surfel.material, p_L, p_G, glossyExponent);\n\t\t\n\t\t// Integrated over the hemisphere, so there is no factor of 1/pi\n\t\tL_o = texture(irradianceMap, surfel.normal, 10.0).rgb * p_L;\n\n\t\t// Glossy environment reflection (from http://casual-effects.blogspot.com/2011/08/plausible-environment-lighting-in-two.html)\n\t\tfloat MIPBias = log2(radianceMapResolution.x * sqrt(3.0)) - 0.5 * log2(glossyExponent + 1.0);\n#\t\tifdef HAS_WEBGL_MIP_BIAS\n\t\t\tL_o += texture(radianceMap, w_m, MIPBias).rgb * p_G;\n#\t\telse\n\t\t{\n\t\t\t// Everything about this path is a hack; the glossiness is not well tuned\n\t\t\t// Compute a tangent space\t\t\n\t\t\tvec3 t1 = abs(w_m.x) > 0.5 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n\t\t\tt1 = normalize(t1 - w_m * dot(w_m, t1));\n\t\t\tvec3 t2 = cross(t1, w_m);\n\t\t\tfloat r = 1.0 - surfel.material.smoothness;\n\t\t\tvec3 sum = vec3(0.0);\n\t\t\tconst int N = 10;\n\t\t\tfor (int i = 0; i < N; ++i) {\n   \t\t    \tfloat a = float(i) * pi * 2.0 * 8.0 / float(N) + hash(fragCoord.xy * 10.0) * pi * 2.0;\n\t\t\t\tvec2 offset = vec2(cos(a), sin(a)) * r * float(i) / float(N - 1);\n\t\t\t\tsum += texture(radianceMap, w_m + t1 * offset.x + t2 * offset.y).rgb;\n\t\t\t}\n\t\t\tL_o += (sum / float(N)) * p_G;\n\t\t}\n#\t\tendif\n\t\t\n\t\t// Cast a shadow ray\n\t\tSurfel shadowSurfel;\n\t\tRay shadowRay;\n\t\tshadowRay.direction = w_i;\n\t\tshadowRay.origin = surfel.position + surfel.normal * rayBumpEpsilon;\n\t\tfloat shadowDist = inf;\n\t\tif (! intersectScene(shadowRay, shadowDist, shadowSurfel)) {\n\t\t\tL_o += shade(surfel, w_i, -eyeRay.direction, B_i);\n\t\t}\n\t} else {\n\t\t// Hit the skybox\n\t\tL_o = texture(radianceMap, eyeRay.direction).rgb;\n\t}\n\t\n\t// Approximate gamma encode\n\tfragColor.xyz = sqrt(L_o * exposure);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsGWS","date":"1378351631","viewed":2272,"name":"Analytic Ray Trace Framework","username":"morgan3d","description":"Simple ray tracing setup with class abstraction, Blinn-Phong directional, and environment reflection. GLSL code doesn't have to be ugly!","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["phong","raytrace","glosy","blinn","readable"],"hasliked":0,"parentid":"","parentname":""}}