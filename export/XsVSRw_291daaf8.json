{"ver":"0.1","info":{"id":"XsVSRw","date":"1463522055","viewed":232,"name":"Rule 30 and 110","username":"akohdr","description":"Rules 30 (yellow) and 110 (blue) 2D cellular automata in voxel space.\n(used to verify cycle accuracy of z-slice mapping, YMMV depending on resolution)\nMouse rotates, upper iMouse.y show state space.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["voxel","automata","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n#define EYE 90\n#define RES iResolution\n#define FRES_xy vec2(3,99)\n#define FRES vec3(FRES_xy,199)\n#define HALF (FRES/2.)\n#define FDIM vec3(floor(RES.xy/FRES.xy),FRES.z)\n\nbool isVoxel(out vec4 k, const in vec3 P)\n{\n    if(any(greaterThan(abs(P),HALF))) return false; \t// bounds check, kills repetition \n    vec3 p = P + HALF;\t\t  \t\t\t\t\t\t\t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    k = texture(iChannel0, (FRES_xy * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FRES_xy))/RES.xy);\n    return k.w>0.;\t\t\t\t\t\t\t\t\t\t// anything but black\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float T, Rx = RES.x, Ry = RES.y;\n    vec2 uv = P/RES.xy,\n         u = (P - vec2(0,.5)*Ry)/Rx - vec2(.5,0);\n    \n    if(iMouse.z>0.){\n        if (iMouse.y>250.){ k = texture(iChannel0, uv); return; } // show state space\n        T = 5.*iMouse.x/Rx;  \t\t\t\t\t\t\t// mouse rotate\n    } else\n        T = float(iFrame)/128.; \t\t\t\t\t\t// slow rotate\n    \n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<350; i++) {\n        float a=s.x, b=s.y, c=s.z;\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n        \n        if(isVoxel(k, f)) { k += vec4(m.x>.0 ? 0. : m.y>.0 ? .6 : .3); return; } //early exit\n    }\n    k = texture(iChannel1, uv/3.)/3.; \t\t\t\t// background\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n// \t\t\t\t  Rules 30 & 110 2D cellular automata in 3D voxel space\n//\n\n// evolve in zy-plane, size accordingly\n#define FRES_xy vec2(3,99)\n#define L_ 4\n#define C_ 13\n#define R_ 22\n\n#define RES iResolution.xy\n#define FRES vec3(FRES_xy,199)\n#define FDIM vec3(floor(RES/FRES_xy),FRES.z)\n\n#define BLK vec4(0)\n#define RED vec4(1,0,0,1)\n#define GRN vec4(0,1,0,1)\n#define BLU vec4(0,0,1,1)\n#define YEL vec4(.5,.5,0,1)\n#define ANY vec4(-1)\n\n#define VX(v,K) if(distance(v.xyz,q.xyz)<1.)k=K;\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    float z = p.z, w = FDIM.x;\n    return FRES_xy * floor(vec2(mod(z,w), z/w)) + mod(p.xy, FRES_xy);\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    vec2 f = floor(p/FRES_xy);\n    return vec4(mod(vec3(p, FDIM.x*f.y + f.x),FRES), 0);//iTime);\n}\n\n// mini-DSL for rule definitions / processing ==============================================\n#define APPLY(f) f(r);applyRule(q,r,k);\n#define CHK(x,y,z,K) if(noMatch(q+vec4(x,y,z,1),K))return;\n#define RULE(n) void n(inout vec4 r[28]){clrRule(r,ANY);\n#define WHEN r[14]=\n#define OUT  r[0]=\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 dp, const in vec4 K)\n{\n    return K != ANY && \n       K.rgb != texture(iChannel0, prj4Dto2D(dp)/RES).rgb;\n}\n\nvoid applyRule(const in vec4 q, const in vec4 r[28], inout vec4 k)\n{\n    CHK(-1,-1,-1, r[ 1])    CHK(-1,-1, 0, r[ 2])    CHK(-1,-1, 1, r[ 3])\n    CHK( 0,-1,-1, r[ 4])    CHK( 0,-1, 0, r[ 5])    CHK( 0,-1, 1, r[ 6])\n    CHK( 1,-1,-1, r[ 7])    CHK( 1,-1, 0, r[ 8])    CHK( 1,-1, 1, r[ 9])\n        \n    CHK(-1, 0,-1, r[10])    CHK(-1, 0, 0, r[11])    CHK(-1, 0, 1, r[12])\n    CHK( 0, 0,-1, r[13])    CHK( 0, 0, 0, r[14])    CHK( 0, 0, 1, r[15])\n    CHK( 1, 0,-1, r[16])    CHK( 1, 0, 0, r[17])    CHK( 1, 0, 1, r[18])\n        \n    CHK(-1, 1,-1, r[19])    CHK(-1, 1, 0, r[20])    CHK(-1, 1, 1, r[21])\n    CHK( 0, 1,-1, r[22])    CHK( 0, 1, 0, r[23])    CHK( 0, 1, 1, r[24])\n    CHK( 1, 1,-1, r[25])    CHK( 1, 1, 0, r[26])    CHK( 1, 1, 1, r[27])        \n\n    k = r[0];\n}\n\nvoid clrRule(out vec4 k[28], const in vec4 K)\n{\n    k[ 0]=K;k[ 1]=K;k[ 2]=K;k[ 3]=K;k[ 4]=K;k[ 5]=K;k[ 6]=K;k[ 7]=K;k[ 8]=K;k[ 9]=K;\n    k[10]=K;k[11]=K;k[12]=K;k[13]=K;k[14]=K;k[15]=K;k[16]=K;k[17]=K;k[18]=K;k[19]=K;\n    k[20]=K;k[21]=K;k[22]=K;k[23]=K;k[24]=K;k[25]=K;k[26]=K;k[27]=K;\n}\n\n// local rules =============================================================================\n\n// Rule 30\nRULE(rule1a)\t\tWHEN BLK;\tOUT RED;\tr[L_] = BLK; r[C_] = BLK; r[R_] = RED;}\nRULE(rule1b)\t\tWHEN BLK;\tOUT RED;\tr[L_] = BLK; r[C_] = RED; r[R_] = BLK;}\nRULE(rule1c)\t\tWHEN BLK;\tOUT RED;\tr[L_] = BLK; r[C_] = RED; r[R_] = RED;}\nRULE(rule1d)\t\tWHEN BLK;\tOUT RED;\tr[L_] = RED; r[C_] = BLK; r[R_] = BLK;}\nRULE(ruleAgeRed)\tWHEN RED;\tOUT YEL;}\n\n// Rule 110\nRULE(rule2a)\t\tWHEN BLK;\tOUT GRN;\tr[L_] = BLK; r[C_] = BLK; r[R_] = GRN;}\nRULE(rule2b)\t\tWHEN BLK;\tOUT GRN;\tr[L_] = BLK; r[C_] = GRN; r[R_] = BLK;}\nRULE(rule2c)\t\tWHEN BLK;\tOUT GRN;\tr[L_] = BLK; r[C_] = GRN; r[R_] = GRN;}\nRULE(rule2d)\t\tWHEN BLK;\tOUT GRN;\tr[L_] = GRN; r[C_] = BLK; r[R_] = GRN;}\nRULE(rule2e)\t\tWHEN BLK;\tOUT GRN;\tr[L_] = GRN; r[C_] = GRN; r[R_] = BLK;}\nRULE(ruleAgeGrn)\tWHEN GRN;\tOUT BLU;}\n\nvoid applyLocalRules(out vec4 k, const in vec2 p, const in vec4 q)\n{\n    vec4 r[28];\t\t   \t\t\t\t\t// rule buffer\n    k = texture(iChannel0, p/RES);\t// retrieve prior state\n    APPLY(rule1a) APPLY(rule1b) APPLY(rule1c) APPLY(rule1d) \n    APPLY(rule2a) APPLY(rule2b) APPLY(rule2c) APPLY(rule2d) APPLY(rule2e) \n    APPLY(ruleAgeRed)\t\t\tAPPLY(ruleAgeGrn)\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    vec4 q = prj2Dto4D(p);\t\t\t\t// 4D state position\n    if(mod(iTime,12.)<1.) {\n        k = BLK;\t\t\t\t\t\t// automata initial condition seeding\n        VX( vec3(0,FRES.y/2.,0), RED)\n        VX( vec3(3,FRES.y,0), GRN)\n    }\n    else\n\t    applyLocalRules(k,p,q);\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}