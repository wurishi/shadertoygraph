{"ver":"0.1","info":{"id":"NtlBD4","date":"1650903443","viewed":80,"name":"heightmap generator","username":"itsjonebone","description":"just-for-fun attempt at a terrain heightmap\nBuffer A is heighmap maker,\nImage is parsing heightmap into color texture\nalso includes normals calculation \n\nPerlin's 2002 paper: \nmrl.cs.nyu.edu/~perlin/paper445.pdf\nhttps://cs.nyu.edu/~perlin/noise/\n\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["noise","perlin","heightmap"],"hasliked":0,"parentid":"ftScWd","parentname":"perlin play"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thresholds for water and snow appearance\n\nfloat water_threshold = 0.31;\nfloat snow_threshold = 0.67;\nfloat slope_threshold = 0.0055;\n\n/////////////////////////////\n\n\nfloat slope_around(vec2 uv) {\n    // get slope from:\n    // (-1, -1) to (+1, +1)\n    // (0, -1) to (0, +1)\n    // (+1, -1) to (-1, +1)\n    // (-1, 0) to (+1, 0)\n    float d1, vert, d2, horz;\n    \n    vec2 mod = vec2(0.5)/iResolution.xy;\n    \n    d1 = abs(texture(iChannel0, uv - mod).r - texture(iChannel0, uv + mod).r) / 2.;\n    vert = abs(texture(iChannel0, uv - vec2(0., mod.y)).r - texture(iChannel0, uv + vec2(0., mod.y)).r) / 2.;\n    d2 = abs(texture(iChannel0, uv - vec2(-mod.x, mod.y)).r - texture(iChannel0, uv + vec2(-mod.x, mod.y)).r) / 2.;\n    horz = abs(texture(iChannel0, uv - vec2(mod.x, 0.)).r - texture(iChannel0, uv + vec2(mod.x, 0.)).r) / 2.;\n    \n    return max( max(d1, d2), max(vert, horz));\n}\n\nvec4 downsampleNormAt(vec2 fragCoord, float pixelStride, vec2 meshSize, float maxHeight) {\n    // given points in arrangement:\n    //     a\n    //     |\n    // b - V - c\n    //     |\n    //     d\n    // where (V) is the pixel given by fragCoord\n    // and each of (a), (b), (c), (d) are pixelStride pixels away\n    // using the noise value from Buffer A as the z component of each point\n    // multiplied by maxHeight to represent its height in the mesh\n    // we get the vertex normal as the sum of the cross products of \n    // (a-V) X (c-V)\n    // (b-V) X (a-V)\n    // (d-V) X (b-V)\n    // (c-V) X (d-V)\n    \n    vec2 strideDist = meshSize/(iResolution.xy/pixelStride);\n    \n    // points:\n    vec3 V = vec3(fragCoord/iResolution.xy, 0.);\n    V.z = texture(iChannel0, V.xy).r * maxHeight;\n    vec3 a = vec3((fragCoord - vec2(0., pixelStride))/iResolution.xy, 0.);\n    a.z = texture(iChannel0, a.xy).r * maxHeight;\n    vec3 b = vec3((fragCoord - vec2(pixelStride, 0.))/iResolution.xy, 0.);\n    b.z = texture(iChannel0, b.xy).r * maxHeight;\n    vec3 c = vec3((fragCoord + vec2(pixelStride, 0.))/iResolution.xy, 0.);\n    c.z = texture(iChannel0, c.xy).r * maxHeight;\n    vec3 d = vec3((fragCoord + vec2(0., pixelStride))/iResolution.xy, 0.);\n    d.z = texture(iChannel0, d.xy).r * maxHeight;\n    \n    // vectors to abcd from V\n    vec3 aVec = (a - V);\n    vec3 bVec = (b - V);\n    vec3 cVec = (c - V);\n    vec3 dVec = (d - V);\n    // scale to the distance they will be in the mesh\n    aVec.xy = (aVec.xy/pixelStride) * strideDist;\n    bVec.xy = (bVec.xy/pixelStride) * strideDist;\n    cVec.xy = (cVec.xy/pixelStride) * strideDist;\n    dVec.xy = (dVec.xy/pixelStride) * strideDist;\n    \n    // sum cross products\n    vec3 cpSum = cross(aVec, cVec)\n               + cross(bVec, aVec)\n               + cross(dVec, bVec)\n               + cross(cVec, dVec);\n    cpSum = normalize(cpSum);\n    \n    cpSum = (cpSum + vec3(1.))/2.;\n    \n    return vec4(cpSum, texture(iChannel0, V.xy).r);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 uvw = vec3(uv, 0.1);\n    \n    float timeband = fract(iTime / 10.);\n    \n    if (uv.x > 0.5) {\n        uvw.x -= 0.5;\n        uvw.y = timeband;\n        \n    } else if (abs(uv.y - timeband) < 0.0025) {\n        fragColor = vec4(1., 0., 0., 1.);\n        return;\n    }\n    \n    float comboVal = texture(iChannel0, uvw.xy).r;\n    vec3 cCol = vec3(comboVal);\n    // if below water threshold, make blue stand out\n    if (comboVal < water_threshold) cCol.z = 1. - comboVal;\n    // if below snow threshold, reduce red and blue to make green stand out\n    else if (comboVal < snow_threshold) {\n        if (slope_around(uv) < slope_threshold) cCol.xz *= cCol.xz;\n        else {\n            cCol.z = 0.;\n            cCol.y *= cCol.y;\n        }\n    } else {\n        cCol.y = quintic_fade(cCol.y);\n    }\n    \n    if (uv.x > 0.5) {\n        if (abs(uv.y - comboVal) > 0.01) cCol = vec3(0.);\n\n        if (uv.y < water_threshold && comboVal < water_threshold && uv.y > comboVal) cCol = vec3(comboVal, comboVal, 1. - comboVal);\n        \n        \n    }\n\n    \n    fragColor = downsampleNormAt(fragCoord, 10., vec2(100., 100.), 30.);\n    fragColor = vec4(cCol, 1.);\n    return;\n    \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// Perlin and Worley noise\n// Worley noise lines 9 - 46\n// Perlin noise lines 49 - 187\n/// NB:\n// this code was written for 3D perlin noise, \n// but 2D noise will primarily be used for terrain heightmaps\n\n\n/// WORLEY\n// taken from my 3D noise shader\n// published here : https://www.shadertoy.com/view/tttfz7\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec3 poi_gen (vec3 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    // NB: side effect of fract is that all values will be positive \n    return fract(sin(vec3(\n                dot(gridIndex + 1.0, vec3(127.4, 723.8, 872.4)),\n                dot(gridIndex + 1.0, vec3(387.4, 275.4, 567.6)),\n                dot(gridIndex + 1.0, vec3(837.7, 208.7, 576.4)) )) * 25787.33);\n}\n\n/// Worley Noise \n// this is inverted in the first shader I wrote\nfloat worley(vec3 p, float freq) {\n    p *= freq;\n    // split p into id and position\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    \n    float minDist = 1000.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 offset = vec3(x, y, z);\n                vec3 poi = poi_gen(mod(id + offset, vec3(freq))); // use mod for tiling\n                poi += offset;\n                vec3 diff = poi - pos;\n                minDist = min(minDist, length(diff));\n            }\n        }\n    }\n    return minDist;\n}\n\n\n/// PERLIN NOISE\n\n/// NB:\n// much of the following code was taken from some serial C++ code I wrote\n// so vec3/vec4 structures were not originally used\n\n\n\n// Perlin's hash value array\n// Perlin's 2002 code uses a literal array of size 256\n// Perlin doubles this array into an array of 512 using some code\n// I do the same, only I double it with copy and paste\nint p[512] = int[](151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180, \n   151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n);\n\n// Schneider's 2016 remap function\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\n\n// t should be a value between 0 and 1\n// returns a value that's (t*100)% of the way between a and b\nfloat mix (float t, float a, float b) {\n    return a + (t * (b - a));\n}\n\n// returns 6t^5 - 15t^4 + 10t^3\nfloat quintic_fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nint perlin_hash(int x, int y, int z, int frequency) {\n    x %= frequency, y %= frequency, z %= frequency;\n\n    return p[p[p[x] + y] + z];\n}\n\n// Perlin has a fancy way of doing this, but the switch statement is faster and more legible\n// dot product of location vector and a random vector\n// uses one of the following 12 vectors:\n// (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),\n// (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),\n// (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)\n// 4 vectors will be represented twice, bringing the number up to 16\n// this allows us to use a bitwise AND operation rather than a division by 12\n// code source: http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html\nfloat grad(int hash, float x, float y, float z) {\n    switch (hash & 0xF) { // mod 16 but using bits, & 0xF is faster than % 16\n    case 0x0: return  x + y;\n    case 0x1: return -x + y;\n    case 0x2: return  x - y;\n    case 0x3: return -x - y;\n    case 0x4: return  x + z;\n    case 0x5: return -x + z;\n    case 0x6: return  x - z;\n    case 0x7: return -x - z;\n    case 0x8: return  y + z;\n    case 0x9: return -y + z;\n    case 0xA: return  y - z;\n    case 0xB: return -y - z;\n    // redundant vectors:\n    case 0xC: return  x + y;\n    case 0xD: return -x + y;\n    case 0xE: return -y + z;\n    case 0xF: return -y - z;\n    default: break; // won't happen\n    }\n    return 0.0f; // will never be reached\n}\n\n\nfloat perlin_noise_at(vec3 pos, int frequency) {\n    pos *= float(frequency);\n\n    // ID values- floored indices of the unit cube in space\n    int idx = (int(pos.x)) & 255;\n    int idy = (int(pos.y)) & 255;\n    int idz = (int(pos.z)) & 255;\n    // Location values- position of point within the unit cube\n    float locx = fract(pos.x);\n    float locy = fract(pos.y);\n    float locz = fract(pos.z);\n\n    // compute faded location\n    float u = quintic_fade(locx);\n    float v = quintic_fade(locy);\n    float w = quintic_fade(locz);\n\n    // hash values\n    int aaa = perlin_hash(idx    , idy    , idz    , frequency);\n    int aab = perlin_hash(idx    , idy    , idz + 1, frequency);\n    int aba = perlin_hash(idx    , idy + 1, idz    , frequency);\n    int baa = perlin_hash(idx + 1, idy    , idz    , frequency);\n    int abb = perlin_hash(idx    , idy + 1, idz + 1, frequency);\n    int bba = perlin_hash(idx + 1, idy + 1, idz    , frequency);\n    int bab = perlin_hash(idx + 1, idy    , idz + 1, frequency);\n    int bbb = perlin_hash(idx + 1, idy + 1, idz + 1, frequency);\n\n    // interpolate\n    float x1, x2, y1, y2;\n    // first set of 4 planar points\n    x1 = mix(u, grad(aaa, locx, locy, locz), grad(baa, locx - 1.0f, locy, locz));\n    x2 = mix(u, grad(aba, locx, locy - 1.0f, locz), grad(bba, locx - 1.0f, locy - 1.0f, locz));\n    y1 = mix(v, x1, x2);\n    // second 4 points\n    x1 = mix(u, grad(aab, locx, locy, locz - 1.0f), grad(bab, locx - 1.0f, locy, locz - 1.0f));\n    x2 = mix(u, grad(abb, locx, locy - 1.0f, locz - 1.0f), grad(bbb, locx - 1.0f, locy - 1.0f, locz - 1.0f));\n    y2 = mix(v, x1, x2);\n    //mix top and bottom\n    return mix(w, y1, y2);\n}\n\n/// This marks the end of imported C++ code\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// code here actually makes the heightmap\n// change floors to change number of plateaus that happen\nfloat floors = 5.;\n\n\n\nfloat perlin_multi_octave(vec3 pos, int baseFrequency) {\n    return perlin_noise_at(pos, baseFrequency * 1) * 0.625\n         + perlin_noise_at(pos, baseFrequency * 4) * 0.25\n         + perlin_noise_at(pos, baseFrequency * 8) * 0.125;\n         //+ perlin_noise_at(pos, baseFrequency * 8) * 0.125;\n}\n\nfloat worley_multi_octave(vec3 pos, float baseFrequency) {\n    return worley(pos, baseFrequency * 1.) * 0.625\n         - worley(pos, baseFrequency * 4.) * 0.25\n         + worley(pos, baseFrequency * 8.) * 0.125;\n}\n\nfloat perlin_zones(vec3 pos, int baseFrequency, float numZones) {\n    // numZones should be integer greater than 1\n    float pnoise = perlin_noise_at(pos, baseFrequency);\n    float pRemapped = remap(pnoise, -1., 1., 0., numZones + 0.5);\n    pRemapped = floor(pRemapped) + quintic_fade(quintic_fade(fract(pRemapped)));\n    pRemapped += perlin_multi_octave(pos, baseFrequency) * (0.125 * numZones);\n    pRemapped /= numZones;\n    return pRemapped;\n}\n\nfloat smoothed_zones(vec3 pos, int baseFrequency, float numZones, float blendFactor) {\n    // numZones should be integer greater than 1\n    // blend factor should be decimal 0-1\n    float pnoise = perlin_noise_at(pos, baseFrequency);\n    float pRemapped = remap(pnoise, -1., 1., 0., 1.);\n    float zoneNoise = floor((pRemapped * numZones) * (1. / blendFactor)) * blendFactor;\n    if (fract(zoneNoise) < blendFactor * 1.1 && fract(zoneNoise) > 0.0) return (0.0);\n    if (fract(zoneNoise) > 1. - (blendFactor * 1.1)) return 0.;\n    if (fract(zoneNoise) > 0.5 - (blendFactor * 0.6) && fract(zoneNoise) < 0.5 + (blendFactor * 0.5)) return 1.;\n    return floor(zoneNoise)/numZones;\n}\n\nfloat s_zones(vec3 pos, int baseFrequency, float numZones) {\n    // numZones should be integer greater than 1\n    float pnoise = perlin_noise_at(pos, baseFrequency);\n    float pRemapped = remap(pnoise, -1., 1., 0., numZones);\n    float zoneFract = fract(pRemapped);\n    \n    \n    \n    zoneFract = zoneFract/1.5 + 0.4;\n    zoneFract = zoneFract / (zoneFract + exp(1. - 27. * zoneFract));\n    //zoneFract += 0.01;\n    \n    float ret = (floor(pRemapped) + zoneFract)/numZones;\n    if (fract(pRemapped) < 0.5) return floor(pRemapped)/numZones;\n    \n    return ret;\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 uvw = vec3(uv, 0.1);\n    \n    float comboVal = perlin_zones(uvw, 4, 4.);\n    float blendVal = smoothed_zones(uvw, 4, 4., 0.2);\n    blendVal = s_zones(uvw, 4, 4.);\n    //float comboVal = worley(uvw, 4.);\n    //comboVal = 1. - comboVal;\n    //comboVal = remap(comboVal, 0., 1., -0.5, 1.1);\n    //comboVal = pow(comboVal, 1.1);\n    \n    vec3 cCol = vec3(comboVal);\n    if (uv.x > 0.33) {\n        cCol = vec3(blendVal, vec2(comboVal));\n        if (uv.x > 0.66) cCol = vec3(blendVal);\n    }\n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(cCol,1.0);\n}\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 uvw = vec3(uv, 0.1);\n    \n    // efficiency thing \n    if (uv.x > 0.5 && false) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n\n    // color from perlin noise\n    //float pVal = perlin_noise_at(vec3(uv, 0.1), 8);\n    //float pVal = perlin_multi_octave(uvw, 8);\n    //pVal = remap(pVal,     // remap out of -1 to 1 bounds to -0.5 to 1 bounds\n    //             -1.0, 1.,  // old min/max\n    //             -1.0, 1.); // new min/max\n    //vec3 perlinColor = vec3(pVal);\n    //if (pVal < 0.25) perlinColor.z = 1. - pVal;\n    //else if (pVal < 0.75) perlinColor.xz *= 0.5;\n    \n    //float wVal = worley(uvw, 4.);\n    //wVal = remap(wVal,     // remap out of 0 to 1 bounds to 0.5 to 1 bounds\n                           // so that plateaus tend to be above water\n    //             0.0, 1.,  // old min/max\n    //             0.0, 1.); // new min/max\n    \n    //wVal = pow(wVal, 2.3);\n    \n    //float lowOctP = perlin_zones(uvw, 8, 4.);\n    //lowOctP = remap(lowOctP, -1., 1., 0.05, 1.);\n    //lowOctP = 1. - abs(lowOctP);\n    //lowOctP = pow(lowOctP, 2.7);\n    //lowOctP = remap(lowOctP, 0., 1., 0.15, 1.);\n    \n    //float comboVal = (pVal / 4.) + lowOctP;\n    //float comboVal = wVal + lowOctP * pVal;\n    //comboVal = remap(comboVal, 0., 2., 0., 1.);\n    //comboVal = pow(comboVal, 2.2);\n    float comboVal = perlin_zones(uvw, 4, floors);\n    vec3 cCol = vec3(comboVal);\n    \n    //cCol = vec3(wVal);\n    \n    \n    // Output to screen\n    fragColor = vec4(cCol,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}