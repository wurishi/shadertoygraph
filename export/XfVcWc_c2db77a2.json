{"ver":"0.1","info":{"id":"XfVcWc","date":"1732484046","viewed":45,"name":"Tachyon Plasma Cannon","username":"akr51","description":"A useful technique: using the shadertoy unofficial plugin, use time where you would adjust some numbers, to save time you can set the slider to a smaller range, then use the time value as a hardcoded value, after adjusting it to your liking. \n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","plasma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.youtube.com/@tapestry1-s1f\n// Number of scene \"objects\"\n#define NSO 5\n// Iterations\n#define ITR 120\n// Max ray travel distance\n#define DST 90.0\n// Collision with surface  \n#define SRF 0.0001\n// Epsilon for normal\n#define EPS vec2(0.0001, -0.0001)\n// 2D rotation which can be used in 3D by rotating\n// about plane. E.G xy is about z axis.\n#define RT(X) mat2(cos(X), -sin(X), sin(X), cos(X))\n// PI\n#define PI acos(-1.0)\n// random\n#define RND(X) fract(sin(dot(X, vec2(33.0, 1320.1))) * 14442.1);\n\nfloat t = 0.0;\nfloat g0 = 0.0;\nfloat g1 = 0.0;\nfloat g2 = 0.0;\nfloat a = 0.0;\n\nfloat snoise(vec2 uv)\n{\n\n\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = RND(i + vec2(0, 0));\n    float b = RND(i + vec2(1, 0));\n    float c = RND(i + vec2(0, 1));\n    float d = RND(i + vec2(1, 1));\n    \n    vec2 u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u.x) + (c - a)  * u.y * (1.0 - u.x)\n                          + (d - b) * u.x * u.y;\n\n}\n\n\nfloat box(vec3 sp, vec3 d)\n{\n\n\n    sp = abs(sp) - d;\n    return max(max(sp.y, sp.x), sp.z);\n\n\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat cyl(vec3 sp, float h, float r)\n{\n\n\n    vec2 d = abs(vec2(length(sp.xz), sp.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n}\n\n\nfloat plane(vec3 sp, vec3 n)\n{\n    // plane with normal used for setting orientation\n    // can use: dst[0] = sp.y + 1.0; with no ability\n    // to position using normal.\n    return dot(sp, n);\n\n}\n\n\nvec2 map(vec3 sp)\n{\n\n    float dst[NSO];\n    float id = 0.0;\n    vec3 spk = sp;\n    vec3 spw = sp;\n    sp.zy *= RT(sp.x * 0.01 + cos(t) * 0.1);\n    vec3 spc = sp;\n    for (int i = 0; i < 6; i++) {\n        \n        spc = abs(spc) - vec3(3, 0, 0);\n        spc.zy *= RT(3.5 + sp.x * 0.03 + 0.25);\n        spc.xy *= RT(0.3);\n        spc.xz *= RT(0.68);\n    \n    }\n    \n    dst[0] = box(spc, vec3(4, 0.15 + length(sp.xy) * 0.1, 2));\n    dst[1] = box(abs(spc) - vec3(3, 4, 3), vec3(2, 0.25, 2));\n    dst[2] = cyl(abs(spc) - vec3(3, 0, 3), 4.0, 1.0);\n    \n    g0 += pow(0.1 / max(dst[2], 0.001), 2.0);\n    \n    float spwf = DST;\n    for (int i = 0; i < 3; i++) {\n        spw = abs(spw) - vec3(2, 3, 4);\n        spw.xy *= RT(2.08 + clamp(a - 4.5, 0.0, 1.0) * 4.86);\n        spwf = min(spwf, box(abs(spw) - vec3(0, 3, 0), vec3(23, 0.001, 0.001)));\n    \n    }\n    \n    \n    \n    dst[3] = spwf;\n    g1 += pow(0.1 / max(dst[3], 0.001), 3.0);\n    spk.x -= 990.0;\n    spk.xy *= RT(PI * 0.5);\n    dst[4] = mix(DST,  cyl(spk, 1000.0, 1.5), clamp(a - 3.6, 0.0, 1.0));\n    g2 += pow(0.7 / max(dst[4], 0.001), 2.0);\n   \n    for (int i = 1; i < NSO; i++)\n    {\n    \n        if (dst[i] < dst[0])\n        {\n        \n            dst[0] = dst[i];\n            id = float(i);\n            \n        }\n    \n    }\n    return vec2(dst[0] * 0.6, id);\n}\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n        \n        vec3 sp = ro + rd * d0;\n        vec2 ds = map(sp);\n        if (d0 > DST || abs(ds.x) < SRF) break;\n        d0 += ds.x;\n        id = ds.y;\n\n\n    }\n    \n    if (d0 > DST) d0 = 0.0;\n    return vec2(d0, id);\n}\n\n\nvec3 nml(vec3 sp)\n{\n\n    return normalize(EPS.xyy * map(sp + EPS.xyy).x +\n                     EPS.yyx * map(sp + EPS.yyx).x +\n                     EPS.yxy * map(sp + EPS.yxy).x +\n                     EPS.xxx * map(sp + EPS.xxx).x);\n\n}\n\n\nvoid mainImage(out vec4 c_out, in vec2 uu)\n{\n    vec2 rr = iResolution.xy;\n    vec2 uv = (uu + uu - rr) / rr.y;\n    \n    // 62.83\n    t = mod(iTime, PI * 2.0);\n    a = mod(t, 5.0);\n    \n    float f = length(uv);\n    vec3 clr = (1.0 - vec3(f * 0.5, f * 0.25, f * 0.125)) * 0.001;\n    vec3 bgc = clr;\n    // camera\n    vec3 ro0 = vec3(0, 0, -31.0 - a * 2.0);\n    vec3 ro1 = vec3(cos(t) * 51.0, sin(t) * 51.0, -31.0 * sin(t));\n    vec3 ro = mix(ro0, ro1, clamp(4.0 - t, 0.0, 1.0));\n    vec3 w = normalize(vec3(0) - ro);\n    vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize(cross(u, w));\n    vec3 rd = normalize(mat3(u, v, w) * vec3(uv, 1.0));\n    // light position\n    vec3 lp = vec3(0, 0.2, -3.0);\n    // color of scene objects\n    vec3 clrs[NSO] = vec3[NSO](\n        vec3(0.1, 0.01, 0.01),\n        vec3(0.5),\n        vec3(0.5, 0.1, 0.1),\n        vec3(0.1, 0.5, 1.5),\n        vec3(0.0)\n    );\n   \n    // march scene\n    vec2 sc = mrch(ro, rd);\n    // distance to scene object\n    float d = sc.x;\n    // scene object id\n    int id = int(sc.y);\n    // if hit scene object\n    if (d > 0.0)\n    {\n        // hit object color\n        vec3 amb = clrs[id];\n        // point in 3-space (3D) where surface collision occurs\n        vec3 sp = ro + rd * d;\n        // direction of light (must be normalized)\n        vec3 ld = normalize(lp - sp);\n        // surface normal - used in lighting calculations\n        vec3 n = nml(sp);\n        \n        \n        // ambient occlusion NuSan\n        float ao = clamp(map(sp + n * 0.5).x / 0.5, 0.0, 1.0);\n        \n        // diffuse\n        float df = max(0.0, dot(n, ld));\n        // specular\n        float spc = pow(max(dot(reflect(-ld, n), -rd), 0.0), 100.0);\n        clr = amb * ao * df + spc;\n        clr = mix(clr, bgc, 1.0 - exp(-0.0001 * pow(d, 3.0)));\n        \n    \n    }\n    \n    clr += g0 * vec3(1, 0, a) + g1 * vec3(0, 0, 1) + (vec3(1, 0.1, 0.1) * g2) * clamp(a - 4.5, 0.0, 1.0);\n    \n    c_out = vec4(pow(clr, vec3(0.45)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}