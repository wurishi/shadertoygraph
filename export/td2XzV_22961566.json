{"ver":"0.1","info":{"id":"td2XzV","date":"1554406807","viewed":248,"name":"Drunken Flight","username":"zackpudil","description":"Drunken flight through an ifs fractal.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141596\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// simple 2d rotation matrix based on angle.\nmat2 rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  \n  return mat2(c, s, -s, c);\n}\n\n// From http://mercury.sexy/hg_sdf/, modulate around a circle.\nvec2 modPolar(vec2 p, float reps) {\n  float angle = 2.0*PI/reps;\n  \n  float a = mod(atan(p.y, p.x) + angle/2.0, angle) - angle/2.0;\n  float r = length(p);\n  \n  return r*vec2(cos(a), sin(a));\n}\n\nvec2 opU(vec2 a, vec2 b) {\n  return a.x < b.x ? a : b;\n}\n\n// simple box sdf.\nfloat box(vec3 p, vec3 r) {\n  vec3 q = abs(p) - r;\n  return max(max(q.x, q.y), q.z);\n}\n\n// box wrapped in a \nvec2 shape(vec3 p) {\n  vec3 op = p;\n  p.xz = abs(p.xz) - vec2(1); // this mirrors space along a diagnal in the xz plane.  \n  \n  float a = box(p + vec3(1, 0, 0), vec3(1, 0.05, 0.1)); // stripe running from left to right.\n  float b = box(p + vec3(0, 0, 1), vec3(0.1, 0.05, 1)); // running from back to front.\n  float c = box(p, vec3(0.1, 1, 0.1)); // running from top to bottom.\n  float d = box(op, vec3(1)); // big cube in the middle.\n  \n  vec2 s = vec2(min(a, min(b, c)), 1.0); // the gold stripes.\n  vec2 t = vec2(d, 2.0); // the purplish box.\n  \n  return opU(s, t);\n}\n\nvec2 de(vec3 p) {\n  \n  vec3 op = p;\n  \n  p.zy *= rot(iTime); // rotating space, adds to the drunk feel.\n  p.zy = abs(p.yz) - vec2(1.6, 1.3); // mirror space to get the fract to fill up more of the scene.\n  p.x = mod(p.x + 1.0, 2.0) - 1.0; // repeat space along x axis.\n  \n  float s = 1.2;\n  vec4 q = vec4(p*s, 1);\n  \n  // typical IFS coordinate deformation setup.\n  for(int i = 0; i < 8; i++) {\n    q.xyz = abs(q.xyz) - vec3(0.5, 0.1, 0.7); // Mirror.\n    q.xz *= rot(1.1); // rotate\n    q.xy *= rot(0.7); // again.\n    \n    q *= 1.4; // scale.\n  }\n    \n  vec2 f = shape(q.xyz)/vec2(q.w*s, 1);\n  \n  return f;\n}\n\n\n// not sure where this was from, but it's a nice way of mapping a 2d texture unto a 3d object.\n// Tri-Planar blending function.\nvec3 mat(in vec3 p, in vec3 n, sampler2D s){\n  \n    // Tweaked to suit your needs.\n    n = max(abs(n) - .2, .001); // n = max(n*n - .1, 0.001), etc.\n    //n /= (n.x + n.y + n.z); // Rough normalization... I think? \n    n /= length(n); // Normalizing.\n    \n    vec3 x = texture(s, p.yz).xyz;\n    vec3 y = texture(s, p.zx).xyz;\n    vec3 z = texture(s, p.xy).xyz;\n    \n    return x*x*n.x + y*y*n.y + z*z*n.z;\n    \n}\n  \n\n// luminosity grey scale.\nvec3 grey = vec3(0.212, 0.715, 0.072);\n\n// bump mapping, perturbing normals to add some detail to geometry.\nvec3 bump(vec3 p, vec3 n, sampler2D s) {\n    vec2 h = vec2(0.005, 0.0);\n    vec3 b = normalize(mat3(\n        mat(p + h.xyy, n, s) - mat(p - h.xyy, n, s),\n        mat(p + h.yxy, n, s) - mat(p - h.yxy, n, s),\n        mat(p + h.yyx, n, s) - mat(p - h.yyx, n, s))*grey);\n    \n    b -= n*dot(n, b); // have no idea what this term does, but it helps smooth out the bumps around corners.\n    \n    return normalize(n + 0.1*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy - 0.5; // converting gl_FragCoord.xy from [0, 1] to [-1, 1]\n  uv.x *= iResolution.x/iResolution.y; // stretch based on resolution.\n  \n  vec3 col, bg;\n  col = bg = vec3(1.0)*(1.0 - (length(uv) - 0.2)); // vinetting (darker cornders).\n  \n  \n  float a = -3.0;\n  float at = 0.3*iTime;\n  \n  vec3 ro = vec3(at, 0, 0); // camera position.\n  vec3 ww = normalize(vec3(at + 1.0, 0.5*sin(at), cos(at))-ro); // camera looking at vector.\n  vec3 uu = normalize(cross(vec3(sin(iTime), cos(iTime), 0), ww)); // the roll vector for the \"right vector\" is causing most of the drunken fly feel.\n  vec3 vv = normalize(cross(ww, uu)); // up vector.\n  vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1.0)); // combine the 3 vectors representing the camera to get the ray direction.\n  \n  // sphere tracing, get intersection distance from pixel to geometry.\n  float t = 0.0, m = -1.0, mx = 50.0;\n  for(int i = 0; i < 200; i++) {\n    vec2 d = de(ro + rd*t);\n    if(d.x < 0.001 || t >= mx) break;\n    t += d.x*0.5; // small bit of fudging to get better results.\n    m = d.y;\n  }\n  \n  vec3 ld = normalize(vec3(-0.5, 0, 0)); // light direction.\n  vec2 e = vec2(1, -1)*0.001;\n  \n  if(t < mx) {\n    vec3 p = ro + rd*t;\n    vec3 n = normalize(\n      e.xxx*de(p + e.xxx).x +\n      e.xyy*de(p + e.xyy).x +\n      e.yxy*de(p + e.yxy).x +\n      e.yyx*de(p + e.yyx).x); // tetrahedral derivative to get normal.\n        \n    vec3 al = vec3(1); // al = albeido, which is color of object.\n\tfloat spo = 16.0; // spo = specular/gloss map.\n     \n    float aot = t/50.0;\n    float ao = exp2(-2.0*pow(max(0.0, 1.0 - de(p + n*aot).x/aot), 2.0)); // nice fake for occulsion by using a wave-paket 2^(-x^2) to approximate a falloff at distances.\n    float dif = max(0.0, dot(ld, n)); // diffuse lighting.\n      \n    p.zy *= rot(iTime); // rotate the space so the textures don't swim (more accuratly so the geometry spins while the texture mapping stands still).\n      \n    if(m < 1.5) {\n      // albeido and gloss map for gold stripes.\n      al = vec3(4)*mat(p, n, iChannel1);\n      spo = 4.0;\n    } else if(m > 1.5) {\n      // albeido, gloss and bump map for purplish box.\n      al = vec3(0.6, 0.3, 1)*mat(p*2.0, n, iChannel0);\n      //n = bump(p*2.0, n, iChannel1);\n      spo = 3.0;\n    }\n    \n    float sst = 3.4;\n    float sss = smoothstep(0.0, 1.0, de(p + ld*sst).x/sst); // subsurface scattering, basically this terms adds some light that bleeds through geometry based on sst.\n    \n    float sp = pow(max(0.0, dot(reflect(-ld, n), -rd)), spo); // specular light.\n\tfloat fr = pow(1.0 + dot(rd, n), 2.0); // fresnel term. I don't understand this, but it works.\n\n    \n    col = mix(vec3(al*ao*(dif + sss + sp)), al, fr); // mix it all together, usually sp is outside the al*ao term, but Idk what I'm doing.\n  }\n  \n  col = mix(col, bg, 1.0 - exp(-0.3*t)); // some fog, make the scene look bigger, and hide popin from.\n  fragColor = vec4(pow(col, vec3(0.45)), 1); // the pow(col, vec3(0.45)) is gamma correction, used to make sure different monitors see roughly the same colors.\n}","name":"Image","description":"","type":"image"}]}