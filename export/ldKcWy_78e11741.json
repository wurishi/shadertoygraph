{"ver":"0.1","info":{"id":"ldKcWy","date":"1523272891","viewed":420,"name":"Weird cityline ","username":"dathor","description":"A weird cityline with a palmtree.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","simple","clouds","fbm","flare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    \n    return f/0.9375;\n}\n\n\nvec3 clouds(vec2 st){\n\t\n\t\n\tvec3 color = vec3(0);\n\t\n\tvec2 q = vec2(0.);\n\tq.x = fbm( st + 0.00*iTime);\n\tq.y = fbm( st + vec2(1.0));\n\t\n\tvec2 r = vec2(0.);\n\tr.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.25*iTime );\n\tr.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\t\n\tfloat f = fbm(st+r);\n\t\n\tcolor = mix(vec3(0.101961,0.619608,0.666667),\n\t\tvec3(0.666667,0.666667,0.498039),\n\t\tclamp((f*f)*4.0,0.0,1.0));\n\t\n\tcolor = mix(color,\n\t\tvec3(0,0,0.164706),\n\t\tclamp(length(q),0.0,1.0));\n\t\n\tcolor = mix(color,\n\t\tvec3(0.666667,1,1),\n\t\tclamp(length(r.x),0.0,1.0));\n\t\n\treturn color;\n}\n\nvec3 postprocess(vec2 uv,vec3 col){\n    \n\tcol.gb *=  uv.y * .6; \n\tcol.g = 0.0+0.6*smoothstep(-0.1,0.9,col.g*2.0);\n\tcol = 0.001+pow(col, vec3(1.2))*1.5;\n\t//col = clamp(1.06*col-0.03, 0., 1.);   \n    col *= mod(gl_FragCoord.y, 4.0)<2.0 ? 0.6 : 1.0;\n\n\treturn col;\n}\nfloat sun(float x,float y,float t){\n   float xx  =x+1.25;\n   float yy = y-0.5;\n   return 0.5/sqrt(xx*xx+yy*yy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tvec2 p = -1.0 + 2.0*uv;\n    \n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tif (uv.y < .12 || uv.y >= .88) {\n\t\tfragColor=vec4(0.,0.,0.,1.);\n\t\treturn;\n\t}\n\t\n\tvec3 color =  vec3(0);\n\t\t color = clouds(p);\t\n\t\n\tvec3 sundot = vec3(2.0,2.0,1.2)*(sun(p.x,p.y,iTime)/10.0);\n\t\n    p.x += 1.5;\n\tfloat r = 0.2 + 0.1*cos( atan(p.y,p.x)*10.0 + 30.0*p.x + 1.5 * sin(iTime));\n\tcolor *= smoothstep( r, r+0.01, length( p ) );\n\tr = 0.015;\n\tr += 0.002*sin(120.0*uv.y);\n\tr += exp(-20.0*uv.y);\n \tcolor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(p.x-0.25*sin(2.0*p.y))))*(1.0-smoothstep(0.0,0.1,p.y));\n\t\n\tcolor = postprocess(p,sundot + color);\n\t\n\t\n\tvec4 final = vec4( color, 1.0 ) ;\n\t\t\n   \tif(-p.y< hash(ceil(p.x*20.))*.5) final-=final*p.y; \n    \n\tfragColor = final ;\n\n}\n\n\n\n\n\n\n\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}