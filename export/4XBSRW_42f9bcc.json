{"ver":"0.1","info":{"id":"4XBSRW","date":"1710284657","viewed":111,"name":"Stupider Jupiter","username":"Altoids","description":"Trying to reach a vibe. I'm not really hitting it, nowhere close, but I think this was still a fun and interesting technical challenge for the day :)\n\n(hopefully I make a better warping function later, oh my freaking lord)","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["text","astrophysics","vhs","vibes","chromaticabberration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Given texture coordinate, output appropriate surface colour\nvec3 gasGiantSurface(in vec2 uv, float flowSpeed) {\n    // Doing a modulo here to cap out the floating-point error\n    float temps = mod(iTime*2.95,6.2831855 * 20.0);\n    vec2 point = uv * vec2(15.,5.5) + vec2(1.,2.1);\n    point.y -= temps * .1;\n\n    float a_x = 0.2 * flowSpeed;\n    float a_y = .05 * flowSpeed;\n    \n    for(int i=1; i<int(12); i++){\n        float float_i = float(i); \n        vec2 delta = vec2(\n            a_x*sin(float_i*point.y+temps/point.x),\n            a_y*cos(float_i*point.x+temps)\n        );\n        point += delta;\n    }\n    point = abs(vec2(\n        cos(point.x+point.y),\n        sin(point.x+point.y))\n    );\n    // point = normalize(point) * 2.0; // <-- Alternative mapping for point\n    \n    // Matrix for mapping point position to colour\n    // Top row affects point.x, bottom row affects point.y\n    mat2x3 colorMap = mat2x3(\n        0.3,0.12,0.55,\n        0.95,0.34,0.6\n    );\n    \n    vec3 col = colorMap * point;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Getting our usual shader bearings...\n    fragColor.rgb = vec3(0.0); // Doing this for the Windows users out there <3\n    vec2 oldCoord = fragCoord; // surprise tool that will help us later (to draw text)\n    \n    // \"astrophysics\", named after the musician\n    // (and used to create stuff based on their visual style / aesthetics)\n    float astrophysics = sin(mod(iTime*7.0 + fragCoord.y/iResolution.y*48.0,6.283));\n    fragCoord = rotationMatrix * (fragCoord/2.)+fragCoord/2.;\n    \n    fragCoord.x += sin(floor(astrophysics)*3.0 + fragCoord.y/40.0)*1.4;\n    \n \n    // The funny for loops are for the supersampling we're doing here.\n    for(int x = -1; x < 2; ++x)\n    {\n        \n        vec2 coord = fragCoord + vec2(float(x),0.2*float(x))*1.5;\n        \n        vec2 texCoord = (coord.xy / iResolution.xy).yx;\n        vec2 position = ( coord.xy / iResolution.xy );\n\n        // Some pre-branch calculations...\n        vec2 center = iResolution.xy / 2.;\n        float centerDistance = distance(center, coord.xy);\n        float radius = iResolution.y / 2.2;\n        vec3 atmosphereColor = vec3(0.8, .1, .6);\n\n        // Find planet coordinates...\n        vec2 posOnPlanet = (coord.xy - (center - radius));\n        vec2 planetCoord = posOnPlanet / (radius * 2.0);\n\n        // Calculate light amounts...\n        float dduv = dot(planetCoord,planetCoord);\n        float light = min(1.0,length(planetCoord/(sqrt(1.4-dduv) + .85)));\n        float lightAtmosphere = light * 0.75;\n\n        // okay lets do it\n        if (centerDistance < radius) { // Within the planet\n\n            // Apply surface with lighting\n            vec3 surfaceColor = gasGiantSurface(\n                texCoord,\n                clamp(radius/centerDistance,0.2,1.25)\n            );\n\n            // Adding some extra rim lighting rq\n            light += smoothstep(0.98,1.0,centerDistance / radius) * texCoord.x *light *light;\n            surfaceColor *= max(light,0.12);\n\n            // Atmosphere\n            float fresnelIntensity = pow(centerDistance / radius, 3.);\n            vec3 fresnel = mix(surfaceColor, atmosphereColor, fresnelIntensity * lightAtmosphere);\n\n            fragColor[x+1] = (fresnel * max(1.0,texCoord.x * 2.))[x+1];\n        } else { // Beyond the planet\n            // Do stars\n            float starriness = step(0.95,texture(iChannel0,position).r);\n\n            // Fuzzy outer atmosphere\n            vec3 fuzziness = atmosphereColor * \n                (1.0 - smoothstep(radius,radius*1.1,centerDistance)) *\n                max(0.25,lightAtmosphere);\n\n            fragColor[x+1] += (fuzziness + starriness)[x+1];\n        }\n    }\n    \n    // Some last-minute VHSing of the result\n    vec2 uv = oldCoord / iResolution.xy;\n    fragColor.rgb += texture(iChannel1, uv * .7).rgb * (0.1 + astrophysics*0.1);\n    \n    // Do the text\n    fragColor.gb += texture(iChannel2,uv).gb;\n    fragColor.r += texture(iChannel2,uv + 0.002).r;\n    \n    // Add a slight greyscale effect along the scanline... things\n    fragColor.gb = mix(fragColor.gb,fragColor.rr,texture(iChannel0,vec2(astrophysics/10.,0.0)).r*0.1);\n    \n    // yeah.\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float ANGLE = 3.125;\n\nconst float RAD_ANGLE = ANGLE / 360. * 6.28315;\n\nconst mat2 rotationMatrix = mat2(cos(RAD_ANGLE),-sin(RAD_ANGLE),sin(RAD_ANGLE),cos(RAD_ANGLE));","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This thing is just for handling the silly text I'm putting over this\n// made johnny-on-the-spot for this one shader in particular\n// (I'm sure there are better text impls on ShaderToy but this one is mine <3)\n\nconst int message[] = int[](102,117,99,107,105,110,103,32,108,111,118,101,32,115,112,97,99,101);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Intentionally in pixels for once, instead of ratios\n    vec2 messageStart = vec2(\n        0.5 * iResolution.x - 9.5*24.,\n        0.5 * iResolution.y\n    );\n    if(fragCoord.y < messageStart.y && \n    fragCoord.y > messageStart.y - 32. &&\n    fragCoord.x > messageStart.x && \n    fragCoord.x < messageStart.x + 18.*24.\n    ) {\n        \n        int letter = message[(int(floor(fragCoord.x - messageStart.x)) / 24) % 18];\n        \n        vec2 fontRes = iChannelResolution[0].xy;\n        \n        vec2 spriteLoc = vec2(float(letter % 16) / 16., 1.0 - float(letter/16 + 1) / 16.);\n        \n        vec2 uv = fragCoord - messageStart;\n        uv.x = mod(uv.x,24.);\n        uv.y = mod(uv.y,32.);\n        \n        float letterness = texture(iChannel0,spriteLoc + uv*0.0018).r;\n        \n        fragColor = vec4(letterness,letterness,letterness * 0.5,letterness);\n    } else {\n        fragColor = vec4(0.05,0.02,0.05,0.05);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}