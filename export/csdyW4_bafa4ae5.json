{"ver":"0.1","info":{"id":"csdyW4","date":"1695642187","viewed":81,"name":"SDF twist","username":"vladnovoren","description":"sdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 kEye = vec3(0, 0, -10);\n\nconst vec3 kLight = vec3( 3.0, 3.0, -5.0 );\nconst vec3 kLightColor = vec3(0.05, 0.0, 1.0);\n\nconst int kMaxSDFSteps = 70;\nconst float kMaxDist = 100.0;\n\nconst float kEps = 0.01;\n\nvec3 opTwistX(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  return vec3(mat2(c, -s, s, c) * p.yz, p.x);\n}\n\nvec3 opTwistY(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  return vec3(mat2(c, -s, s, c) * p.xz, p.y);\n}\n\nfloat Sphere(vec3 p, vec3 c) {\n  return length(p - c) - 1.0;\n}\n\nfloat Torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat box(in vec3 pos, in vec3 size) {\n  vec3 pt = abs(pos) - size;\n\n  return length(max(pt, 0.0)) + min(max(pt.x, max(pt.y, pt.z)), 0.0);\n}\n\nfloat Displacement(in vec3 p, float intensity) {\n  return sin(intensity * p.x) * sin(intensity * p.y) * sin(intensity * p.z);\n}\n\nfloat Displace(float primitive, in vec3 pos) {\n  float displacement = Displacement(pos, 2.0);\n  return primitive + displacement;\n}\n\nfloat SDF(in vec3 p) {\n  return Torus(p, vec2(1.0, 0.5));\n}\n\nfloat SDF(in vec3 p, in mat3 m) {\n  vec3 q = m * p;\n  \n  float t = iTime * 3.0;\n  float A = 1.25;\n  \n  float d1 = SDF(opTwistX(q, A * cos(t)));\n  float d2 = SDF(opTwistY(q, A * sin(t)));\n\n  return max(d1, d2);\n}\n\nvec3 trace(vec3 from, vec3 dir, out bool hit, in mat3 m) {\n  vec3 p = from;\n  float totalDist = 0.0;\n\n  hit = false;\n\n  for (int steps = 0; steps < kMaxSDFSteps; ++steps) {\n    float dist = SDF(p, m);\n\n    if (abs(dist) < kEps) {\n      hit = true;\n      break;\n    }\n\n    totalDist += dist;\n\n    if (totalDist > kMaxDist)\n      break;\n\n    p += dist * dir;\n  }\n\n  return p;\n}\n\nvec3 GenerateNormal(vec3 p, in mat3 m) {\n  float dx1 = SDF(p + vec3(kEps,    0,     0), m);\n  float dx2 = SDF(p - vec3(kEps,    0,     0), m);\n  float dy1 = SDF(p + vec3(   0, kEps,     0), m);\n  float dy2 = SDF(p - vec3(   0, kEps,     0), m);\n  float dz1 = SDF(p + vec3(   0,     0, kEps), m);\n  float dz2 = SDF(p - vec3(   0,     0, kEps), m);\n\n  return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nmat3 RotateX(float phi) {\n  float sin_phi = sin(phi);\n  float cos_phi = cos(phi);\n\n  return mat3(vec3(1, 0, 0), vec3(0, cos_phi, -sin_phi),\n              vec3(0, sin_phi, cos_phi));\n}\n\nmat3 RotateY(float phi) {\n  float sin_phi = sin(phi);\n  float cos_phi = cos(phi);\n\n  return mat3(vec3(cos_phi, 0, -sin_phi), vec3(0, 1, 0),\n              vec3(sin_phi, 0, cos_phi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  bool hit = false;\n  vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, iMouse.z - 0.5);\n  mat3 m = RotateX(9.0 * mouse.y) * RotateY(6.0 * mouse.x);\n  vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n  vec2 uv = scale * (fragCoord / iResolution.xy - vec2(0.5));\n  vec3 dir = normalize(vec3(uv, 0) - kEye);\n  vec4 color = vec4(0, 0, 0, 1);\n  vec3 p = trace(kEye, dir, hit, m);\n\n  if (hit) {\n    vec3 l = normalize(kLight - p);\n    vec3 v = normalize(kEye - p);\n    vec3 n = GenerateNormal(p, m);\n    float nl = max(0.0, dot(n, l));\n    vec3 h = normalize(l + v);\n    float hn = max(0.0, dot(h, n));\n    float sp = pow(hn, 150.0);\n    vec4 amb = vec4(0.1 * kLightColor, 1.0);\n    color = amb + 0.5 * vec4(nl) + 0.5 * sp * vec4(0, 1, 0, 1);\n  }\n\n  fragColor = color;\n}","name":"Image","description":"","type":"image"}]}