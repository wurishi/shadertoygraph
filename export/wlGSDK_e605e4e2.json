{"ver":"0.1","info":{"id":"wlGSDK","date":"1583588254","viewed":690,"name":"LTC with Textures","username":"JuliaPoo","description":"This was done with reference to the paper Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n\nModified from https://www.shadertoy.com/view/4tBBDK to support textures and other mods.\n\nMouse to rotate scene","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","texture","diffuse","ltc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code modified EvilRyu by JuliaPoo\n// https://www.shadertoy.com/view/4tBBDK\n\n\nconst float PI = 3.1415926;\n\nconst float intensity = 1.5;\nconst float light_width = .7;\nconst float light_height = 0.5;\n\nconst vec3 light_col = vec3(1.0)*intensity;\nconst vec3 light_pos = vec3(0., 0.3, 0.);\nconst vec3 light_normal = vec3(0., 0., 1.);\n\nconst float LUTSIZE  = 8.0;\nconst float MATRIX_PARAM_OFFSET = 8.0;\n\nconst mat2 R_obj2 = mat2(\n        \t\t\t0.955336489125606,-0.295520206661339,\n        \t\t\t0.295520206661339, 0.955336489125606\n                  \t);\n\n\n\nfloat rect(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid init_rect_points(out vec3 points[4])\n{\n    // get the orthogonal basis of polygon light\n    vec3 right=normalize(cross(light_normal, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, light_normal));\n    \n    vec3 ex = light_width * right;\n    vec3 ey = light_height * up;\n\n    points[0] = light_pos - ex - ey;\n    points[1] = light_pos + ex - ey;\n    points[2] = light_pos + ex + ey;\n    points[3] = light_pos - ex + ey;\n}\n\n\n#define LIGHT 0.\n#define FLOOR 1.\n#define OBJ1  2.\n#define OBJ2  3.\n\nfloat object_id = 0.;\n\nfloat sphere(vec3 p, float r)\n{\n   \treturn length(p)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(vec3 p)\n{\n    vec3 p0 = p;\n    p0.xz *= R_obj2;\n    \n    float d0=rect(p-light_pos, vec3(light_width, light_height, 0.));\n    \n    float d1;\n    if (abs(p.y + .5) > .015) d1 = abs(p.y+.5);\n    else d1=abs(p.y+0.5+texture(iChannel1, p.xz).x*.01)*.9;\n    \n    float d2=sphere(p-vec3(-0.4, -0.2, 1.2), 0.3);\n    float d3=sdRoundBox(p0-vec3(.7, -.3, 1.2), vec3(.4, .2, .3), 0.);\n    \n   \tfloat d = d0;\n    object_id = LIGHT;\n    \n    if(d > d1)\n    {\n        d = d1;\n        object_id=FLOOR;\n    }\n    \n    if(d > d2)\n    {\n        d = d2;\n        object_id=OBJ1;\n    }\n    \n    if(d > d3)\n    {\n        d = d3;\n        object_id=OBJ2;\n    }\n    \n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.01;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c < 0.005 ) break;\n        t += c;\n        if( t>50.0 ) return -1.0;\n    }\n    return t;\n}\n\n\n// Linearly Transformed Cosines \n\nfloat IntegrateEdge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);    \n    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);\n\n    return res;\n}\n\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n)\n{\n    // detect clipping config\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n\n    // clip\n    n = 0;\n\n    if (config == 0)\n    {\n        // clip all\n    }\n    else if (config == 1) // V1 clip V2 V3 V4\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2) // V2 clip V1 V3 V4\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3) // V1 V2 clip V3 V4\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4) // V3 clip V1 V2 V4\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5) // V1 V3 clip V2 V4) impossible\n    {\n        n = 0;\n    }\n    else if (config == 6) // V2 V3 clip V1 V4\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7) // V1 V2 V3 clip V4\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8) // V4 clip V1 V2 V3\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9) // V1 V4 clip V2 V3\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10) // V2 V4 clip V1 V3) impossible\n    {\n        n = 0;\n    }\n    else if (config == 11) // V1 V2 V4 clip V3\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12) // V3 V4 clip V1 V2\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13) // V1 V3 V4 clip V2\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14) // V2 V3 V4 clip V1\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15) // V1 V2 V3 V4\n    {\n        n = 4;\n    }\n    \n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\n\n\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4])\n{\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n\n    // rotate area light in (T1, T2, N) basis\n    Minv = Minv * transpose(mat3(T1, T2, N));\n\n    // polygon (allocate 5 vertices for clipping)\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n\n    int n=0;\n    // The integration is assumed on the upper hemisphere\n    // so we need to clip the frustum, the clipping will add \n    // at most 1 edge, that's why L is declared 5 elements.\n    ClipQuadToHorizon(L, n);\n    \n    if (n == 0)\n        return vec3(0, 0, 0);\n\n    // project onto sphere\n    vec3 PL[5];\n    PL[0] = normalize(L[0]);\n    PL[1] = normalize(L[1]);\n    PL[2] = normalize(L[2]);\n    PL[3] = normalize(L[3]);\n    PL[4] = normalize(L[4]);\n\n    // integrate for every edge.\n    float sum = 0.0;\n\n    sum += IntegrateEdge(PL[0], PL[1]);\n    sum += IntegrateEdge(PL[1], PL[2]);\n    sum += IntegrateEdge(PL[2], PL[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(PL[3], PL[4]);\n    if (n == 5)\n        sum += IntegrateEdge(PL[4], PL[0]);\n\n    sum =  max(0.0, sum);\n    \n    // Calculate colour\n    vec3 e1 = normalize(L[0] - L[1]);\n    vec3 e2 = normalize(L[2] - L[1]);\n    vec3 N2 = cross(e1, e2); // Normal to light\n    vec3 V2 = N2 * dot(L[1], N2); // Vector to some point in light rect\n    vec2 Tlight_shape = vec2(length(L[0] - L[1]), length(L[2] - L[1]));\n    V2 = V2 - L[1];\n    float b = e1.y*e2.x - e1.x*e2.y + .1; // + .1 to remove artifacts\n\tvec2 pLight = vec2((V2.y*e2.x - V2.x*e2.y)/b, (V2.x*e1.y - V2.y*e1.x)/b);\n   \tpLight /= Tlight_shape;\n    pLight -= .5;\n    pLight /= 2.5;\n    pLight += .5;\n    \n    vec3 ref_col = texture(iChannel3, pLight).xyz;\n\n    vec3 Lo_i = vec3(sum) * ref_col;\n\n    return Lo_i;\n}\n\n    \n/////////////////////////////////////////////\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.001;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        if(object_id==LIGHT)break;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += h;\n    }\n    return clamp(res,0.1,1.0);\n}\n\nvoid LTC_shading(float roughness, \n                 vec3 N, \n                 vec3 V, \n                 vec3 pos, \n                 vec3[4] points, \n                 vec3 m_spec, \n                 vec3 m_diff, \n                 inout vec3 col)\n{\n    \n    \n    float theta = acos(dot(N, V));\n    vec2 uv = vec2(roughness, theta/(0.5*PI)) * float(LUTSIZE-1.);   \n    vec2 wx = uv/iChannelResolution[0].xy;\n            \n    // The offset to get correct interpolation\n    uv += vec2(0.5);\n\n    vec4 params = texture(iChannel0, (uv+vec2(MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n\n    // The inverse transformation matrix, so we \n    // can integrate cosine distribution over the polygon \n    // transformed by this matrix, instead of integrating the\n    // complicated brdf over the untransformed polygon.\n    mat3 Minv = mat3(\n        vec3(  1,        0,      params.y),\n        vec3(  0,     params.z,   0),\n        vec3(params.w,   0,      params.x)\n    );\n\n    vec3 spec = LTC_Evaluate(N, V, pos, Minv, points)*m_spec;\n\n    spec *= texture(iChannel0, uv/iChannelResolution[0].xy).x;\n\n    vec3 diff = LTC_Evaluate(N, V, pos, mat3(1), points)*m_diff; \n\n    // shadow is not area light based here.\n    float sha = softshadow( pos+0.01*N, normalize(light_pos-pos), 16.0 );\n\n    col  = light_col*(m_spec*spec + m_diff*diff)*sha;\n    col /= 2.0*PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    vec3 lookat = vec3(0.0, -0.5*light_height, 0.);\n    vec2 M = vec2(0.25,0.45);\n    float c0 = cos(M.x * 3.);\n    float c1 = cos(M.y * 3.);\n    float s0 = sin(M.x * 3.);\n    float s1 = sin(M.y * 3.);\n    mat2 R1 = mat2(\n                   \tc0,-s0,\n        \t\t\ts0, c0\n                  );\n   \tmat2 R2 = mat2(\n        \t\t\tc1,-s1,\n        \t\t\ts1, c1\n                  );\n\tvec3 ro = vec3(2.5, 0., 0.);\n    ro.xy *= R1;\n    ro.yz *= R2;\n    ro -= lookat;\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    \n    vec3 points[4];\n    \n    // setup the four vertices for the rect light\n    init_rect_points(points);\n\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    \n    if(t>-0.5)\n    {\n        \n        vec3 pos = ro + rd * t;\n        vec3 N = get_normal(pos);\n        vec3 V = -rd;\n        \n        if (object_id == LIGHT)\n        {\n            vec2 screen_pos = (pos.xy + vec2(light_width, .5-light_pos.y))/(vec2(light_width, light_height) * 2.);\n            col = texture(iChannel2, screen_pos).xyz;\n        }\n        else\n        {\n            vec3 diff; vec3 spec;\n            float roughness;\n            \n            if(object_id == FLOOR)\n            {            \n\n                roughness = texture(iChannel1, pos.xz).x;\n                roughness *= roughness;\n                roughness += .2;\n\n                diff = vec3(1., .6, .4);\n                spec = texture(iChannel1, pos.xz).xyz;\n\n            }\n\n            else if (object_id == OBJ1)\n            {\n                roughness = 0.2;\n\n                diff = vec3(1.);\n                spec = vec3(1., 0., 0.);\n\n            }\n\n            else if (object_id == OBJ2)\n            {\n                roughness = 0.5;\n\n                diff = vec3(1.);\n                spec = vec3(1.);\n\n            }\n\n            LTC_shading(roughness, N, V, pos, points, diff, spec, col);\n        }\n        \n\n    }\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The inverse of the transformation matrix M is precomputed and \n// stored in this buffer as a lookup table.\n// The matrix is used to transform cosine distribution to whatever \n// brdf we like.\n// Refer to:  https://labs.unity.com/article/real-time-polygonal-light-shading-linearly-transformed-cosines\n\nvoid store_buf(vec2 pos,vec4 val,vec2 fragCoord,inout vec4 fragColor)\n{\n    if(abs(fragCoord.x-pos.x)<0.01&&abs(fragCoord.y-pos.y)<0.01)\n        fragColor=val;\n}\n\n// The first 8x8 stores the normalization\n// The second 8x8 stores the matrix parameters\n\nvoid setLUT(vec2 fragCoord, inout vec4 fragColor)\n{\n    store_buf(vec2(0.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(2.5, 0.5), vec4(0.999138), fragCoord, fragColor);\n    store_buf(vec2(3.5, 0.5), vec4(0.953919), fragCoord, fragColor);\n    store_buf(vec2(4.5, 0.5), vec4(0.855017), fragCoord, fragColor);\n    store_buf(vec2(5.5, 0.5), vec4(0.677721), fragCoord, fragColor);\n    store_buf(vec2(6.5, 0.5), vec4(0.475624), fragCoord, fragColor);\n    store_buf(vec2(7.5, 0.5), vec4(0.306905), fragCoord, fragColor);\n    store_buf(vec2(0.5, 1.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 1.5), vec4(0.999990), fragCoord, fragColor);\n    store_buf(vec2(2.5, 1.5), vec4(0.995492), fragCoord, fragColor);\n    store_buf(vec2(3.5, 1.5), vec4(0.955938), fragCoord, fragColor);\n    store_buf(vec2(4.5, 1.5), vec4(0.852346), fragCoord, fragColor);\n    store_buf(vec2(5.5, 1.5), vec4(0.676815), fragCoord, fragColor);\n    store_buf(vec2(6.5, 1.5), vec4(0.478562), fragCoord, fragColor);\n    store_buf(vec2(7.5, 1.5), vec4(0.311751), fragCoord, fragColor);\n    store_buf(vec2(0.5, 2.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 2.5), vec4(0.999952), fragCoord, fragColor);\n    store_buf(vec2(2.5, 2.5), vec4(0.993337), fragCoord, fragColor);\n    store_buf(vec2(3.5, 2.5), vec4(0.950365), fragCoord, fragColor);\n    store_buf(vec2(4.5, 2.5), vec4(0.844905), fragCoord, fragColor);\n    store_buf(vec2(5.5, 2.5), vec4(0.674537), fragCoord, fragColor);\n    store_buf(vec2(6.5, 2.5), vec4(0.487632), fragCoord, fragColor);\n    store_buf(vec2(7.5, 2.5), vec4(0.327273), fragCoord, fragColor);\n    store_buf(vec2(0.5, 3.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 3.5), vec4(0.999865), fragCoord, fragColor);\n    store_buf(vec2(2.5, 3.5), vec4(0.991766), fragCoord, fragColor);\n    store_buf(vec2(3.5, 3.5), vec4(0.942684), fragCoord, fragColor);\n    store_buf(vec2(4.5, 3.5), vec4(0.831852), fragCoord, fragColor);\n    store_buf(vec2(5.5, 3.5), vec4(0.673589), fragCoord, fragColor);\n    store_buf(vec2(6.5, 3.5), vec4(0.505564), fragCoord, fragColor);\n    store_buf(vec2(7.5, 3.5), vec4(0.355949), fragCoord, fragColor);\n    store_buf(vec2(0.5, 4.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 4.5), vec4(0.999665), fragCoord, fragColor);\n    store_buf(vec2(2.5, 4.5), vec4(0.986371), fragCoord, fragColor);\n    store_buf(vec2(3.5, 4.5), vec4(0.930421), fragCoord, fragColor);\n    store_buf(vec2(4.5, 4.5), vec4(0.813602), fragCoord, fragColor);\n    store_buf(vec2(5.5, 4.5), vec4(0.678975), fragCoord, fragColor);\n    store_buf(vec2(6.5, 4.5), vec4(0.537882), fragCoord, fragColor);\n    store_buf(vec2(7.5, 4.5), vec4(0.403271), fragCoord, fragColor);\n    store_buf(vec2(0.5, 5.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 5.5), vec4(0.999025), fragCoord, fragColor);\n    store_buf(vec2(2.5, 5.5), vec4(0.973317), fragCoord, fragColor);\n    store_buf(vec2(3.5, 5.5), vec4(0.900245), fragCoord, fragColor);\n    store_buf(vec2(4.5, 5.5), vec4(0.804126), fragCoord, fragColor);\n    store_buf(vec2(5.5, 5.5), vec4(0.703751), fragCoord, fragColor);\n    store_buf(vec2(6.5, 5.5), vec4(0.594890), fragCoord, fragColor);\n    store_buf(vec2(7.5, 5.5), vec4(0.481143), fragCoord, fragColor);\n    store_buf(vec2(0.5, 6.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 6.5), vec4(0.992850), fragCoord, fragColor);\n    store_buf(vec2(2.5, 6.5), vec4(0.926124), fragCoord, fragColor);\n    store_buf(vec2(3.5, 6.5), vec4(0.860745), fragCoord, fragColor);\n    store_buf(vec2(4.5, 6.5), vec4(0.833379), fragCoord, fragColor);\n    store_buf(vec2(5.5, 6.5), vec4(0.782873), fragCoord, fragColor);\n    store_buf(vec2(6.5, 6.5), vec4(0.703637), fragCoord, fragColor);\n    store_buf(vec2(7.5, 6.5), vec4(0.620129), fragCoord, fragColor);\n    store_buf(vec2(0.5, 7.5), vec4(0.987461), fragCoord, fragColor);\n    store_buf(vec2(1.5, 7.5), vec4(0.938899), fragCoord, fragColor);\n    store_buf(vec2(2.5, 7.5), vec4(0.942983), fragCoord, fragColor);\n    store_buf(vec2(3.5, 7.5), vec4(0.943682), fragCoord, fragColor);\n    store_buf(vec2(4.5, 7.5), vec4(0.943818), fragCoord, fragColor);\n    store_buf(vec2(5.5, 7.5), vec4(0.943681), fragCoord, fragColor);\n    store_buf(vec2(6.5, 7.5), vec4(0.943351), fragCoord, fragColor);\n    store_buf(vec2(7.5, 7.5), vec4(0.942877), fragCoord, fragColor);\n\n    float BIAS = 8.;\n    \n    store_buf(vec2(BIAS+0.5, 0.5), vec4(0.000200, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 0.5), vec4(0.040821, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 0.5), vec4(0.163499, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 0.5), vec4(0.359810, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 0.5), vec4(0.608219, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 0.5), vec4(0.849327, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 0.5), vec4(1.026876, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 0.5), vec4(1.127918, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 1.5), vec4(0.000200, -0.000046, 1.052217, 0.228243), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 1.5), vec4(0.040821, -0.009316, 1.052066, 0.228242), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 1.5), vec4(0.163218, -0.036566, 1.051517, 0.228141), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 1.5), vec4(0.360871, -0.077435, 1.049110, 0.226851), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 1.5), vec4(0.608870, -0.112986, 1.040456, 0.216178), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 1.5), vec4(0.850681, -0.110371, 1.022363, 0.171798), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 1.5), vec4(1.033758, -0.063836, 1.011022, 0.089896), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 1.5), vec4(1.130218, 0.000062, 1.000010, -0.000080), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 2.5), vec4(0.000200, -0.000096, 1.232269, 0.481573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 2.5), vec4(0.040829, -0.019653, 1.232083, 0.481559), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 2.5), vec4(0.163323, -0.077152, 1.229494, 0.481157), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 2.5), vec4(0.361362, -0.161748, 1.215935, 0.476966), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 2.5), vec4(0.602530, -0.224893, 1.149731, 0.444834), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 2.5), vec4(0.832866, -0.211716, 1.066321, 0.339254), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 2.5), vec4(1.033638, -0.123274, 1.025543, 0.170803), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 2.5), vec4(1.137644, 0.000154, 0.999953, -0.000082), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 3.5), vec4(0.000199, -0.000159, 1.627474, 0.797472), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 3.5), vec4(0.040836, -0.032524, 1.635685, 0.797401), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 3.5), vec4(0.164108, -0.127318, 1.628042, 0.795956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 3.5), vec4(0.365844, -0.258932, 1.575327, 0.783120), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 3.5), vec4(0.602895, -0.339455, 1.372632, 0.710306), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 3.5), vec4(0.825683, -0.302224, 1.158343, 0.512880), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 3.5), vec4(1.030563, -0.173519, 1.049980, 0.243539), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 3.5), vec4(1.151713, 0.000105, 0.999957, -0.000055), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 4.5), vec4(0.000198, -0.000248, 2.529443, 1.253956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 4.5), vec4(0.040880, -0.051100, 2.570697, 1.253684), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 4.5), vec4(0.166706, -0.198049, 2.542881, 1.248409), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 4.5), vec4(0.380361, -0.384441, 2.334701, 1.206127), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 4.5), vec4(0.617299, -0.459699, 1.772357, 1.025249), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 4.5), vec4(0.835445, -0.380695, 1.304201, 0.680722), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 4.5), vec4(1.040850, -0.213042, 1.089431, 0.306573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 4.5), vec4(1.176060, 0.000010, 1.000023, -0.000021), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 5.5), vec4(0.000187, -0.000388, 4.301116, 2.076506), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 5.5), vec4(0.041070, -0.084546, 5.305590, 2.075270), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 5.5), vec4(0.175521, -0.321638, 5.161014, 2.051541), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 5.5), vec4(0.413187, -0.560077, 4.055352, 1.869406), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 5.5), vec4(0.665130, -0.580464, 2.432246, 1.376237), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 5.5), vec4(0.870094, -0.441204, 1.506300, 0.819691), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 5.5), vec4(1.068578, -0.241436, 1.137736, 0.354430), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 5.5), vec4(1.219174, -0.000534, 1.000063, 0.000162), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 6.5), vec4(0.000144, -0.000631, 6.468958, 4.381222), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 6.5), vec4(0.042200, -0.177353, 20.085962, 4.369584), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 6.5), vec4(0.209979, -0.606367, 16.868328, 4.106197), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 6.5), vec4(0.500901, -0.795643, 8.099620, 2.893355), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 6.5), vec4(0.769693, -0.688227, 3.439625, 1.659662), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 6.5), vec4(0.955036, -0.470746, 1.760819, 0.883184), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 6.5), vec4(1.134532, -0.254869, 1.190455, 0.377490), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 6.5), vec4(1.308330, -0.002944, 0.999844, 0.001275), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 7.5), vec4(0.000102, -0.118482, 1184.816772, 1184.816284), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 7.5), vec4(0.319603, -3.097308, 7133.888672, 23.645655), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 7.5), vec4(0.546638, -1.442077, 133.966263, 8.593670), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 7.5), vec4(0.837342, -1.129903, 20.226521, 3.658263), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 7.5), vec4(1.004258, -0.809128, 5.700182, 1.768790), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 7.5), vec4(1.117055, -0.531464, 2.269246, 0.923613), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 7.5), vec4(1.336692, -0.312752, 1.241618, 0.414403), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 7.5), vec4(1.670654, -0.056394, 0.998759, 0.033416), fragCoord, fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lastFrame = texture(iChannel0, vec2(.5));\n    \n    if (lastFrame.a != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n        return;\n    }\n    \n    if( fragCoord.x > 16. || fragCoord.y > 8. ) discard;\n\tsetLUT(fragCoord, fragColor);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Gaussian Blur is from https://www.shadertoy.com/view/XdfGDH\n\n// Unlike the paper, no normalisation is done to keep it real time since the texture isn't precomputed\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define shrink 2.5\n#define roughness 1.\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nfloat square_sdf(vec2 p){\n    float dx = max(abs(p.x) - .5/shrink, 0.);\n    float dy = max(abs(p.y) - .5/shrink, 0.);\n    return dx * dx + dy * dy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    //declare stuff\n    const int mSize = 15;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 7.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    vec2 wx = fragCoord / iResolution.xy - .5;\n    float min_D = square_sdf(wx);\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            vec2 offset = vec2(float(i),float(j)) * (roughness + (square_sdf(wx) + .01)*80.);\n            vec2 uv = (fragCoord.xy+offset) / iResolution.xy - .5;\n            uv *= shrink;\n            uv /= vec2(max(abs(uv.y*2.), shrink/2.), max(abs(uv.x*2.), shrink/2.));\n            uv += .5;\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, uv).rgb;\n\n        }\n    }\n\n\n    fragColor = vec4(final_colour/(Z*Z), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0)*texture(iChannel0, uv);\n}","name":"Buffer C","description":"","type":"buffer"}]}