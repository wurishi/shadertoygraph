{"ver":"0.1","info":{"id":"MtXcDn","date":"1504289313","viewed":118,"name":"Simple 4D Raymarcher w/ Shadows","username":"Assossa","description":"Modification of shadertoy.com/view/4lXyz8\nOnly the camera is moving in the w axis. Both spheres are at w 0. The light is at w 1.5.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simple","shadows","raymarcher","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe modification from 3D to 4D was extremely simple.\nI simply had to replace vec3 with vec4 and\nthen animate the camera's movement in the w axis.\n*/\n\nconst float maxRender = 10e4; // Max distance to ray march\nconst float epsilon = 0.001; // Margin of error\nconst vec4 light = vec4(1.5, 1.5, -1.5, 1.5);\nconst vec4 up = vec4(0, 1, 0, 0);\n\n// Spheres\nint sphereCount = 2;\nvec4 sphereCenters[2];\nfloat sphereRadius[2];\nfloat floorHeight = -2.5;\n\n// Find distance between sphere and ray\nfloat sphereDistance(vec4 p, vec4 center, float radius) {\n    return distance(p, center) - radius;\n}\n\n// Find normal of sphere from hit location\nvec4 sphereNormal(vec4 p, vec4 center) {\n    return normalize(p - center);\n}\n\n// Get the hit location for a sphere and ray\nfloat sphereHit(vec4 o, vec4 d, vec4 center, float radius) {\n    // Keep track of the distance we have traveled\n    float dist = 0.0;\n    \n    // Kill the marching if we go too far\n    while(dist <= maxRender) {\n        // Get distance to sphere\n        float tempDist = sphereDistance(o, center, radius);\n        \n        // Add it to our distance counter and update the ray origin\n        dist += tempDist;\n        o += d * tempDist;\n        \n        // If we hit a sphere, then return the hit\n        if(tempDist <= epsilon) return dist;\n    }\n    \n    // We didn't hit anything\n    return -1.0;\n}\n\n// Get the hit for the floor\nfloat floorHit(vec4 o, vec4 d, float height) {\n    float du = dot(d, up);\n    if(du == 0.0) return -1.0;\n    \n    float dist = dot((up * height) - o, up) / du;\n    if(dist < 0.0) return -1.0;\n    \n    return dist;\n}\n\nvec2 findHit(vec4 origin, vec4 ray, int ignore) {    \n    // Find a hit\n    float hit = maxRender;\n    int hitID = -1;\n    \n    for(int i = 0; i < sphereCount; i++) {\n        if(i == ignore) continue;\n    \tfloat tempHit = sphereHit(origin, ray, sphereCenters[i], sphereRadius[i]);\n        if(tempHit < hit  && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = i;\n        }\n    }\n    \n    if(ignore != -1) {\n        // Check for hit with floor\n        float tempHit = floorHit(origin, ray, floorHeight);\n        if(tempHit < hit && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = -1;\n        }\n    }\n    \n    return vec2(hit == maxRender ? -1.0 : hit, hitID);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create ray for current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 ray = normalize(vec4(uv, 1.0, 1.0));\n    vec4 origin = vec4(0.0, 0.0, -3.0, sin(iTime * 0.735413) - 2.6);\n    \n    // Initialize the spheres\n    sphereCenters[0] = vec4(0.0);\n    sphereCenters[1] = vec4(cos(iTime) * 1.8, sin(iTime) * 1.8, -0.8, 0.0);\n    sphereRadius[0] = 1.0;\n    sphereRadius[1] = 0.5;\n    \n    // Find a hit\n    vec2 tempHit = findHit(origin, ray, -10);\n    float hit = tempHit.x;\n    int hitID = int(tempHit.y);\n    \n    // If no hit, then use the sky color\n    if(hit < 0.0) {\n        fragColor = vec4(0.3, 0.5, 0.7, 1.0);\n        return;\n    }\n    \n    // Find hit point & light direction\n    vec4 hitPoint = origin + (ray * hit);\n    vec4 lightDir = normalize(light - hitPoint);\n    \n    // Find if we need a shadow\n    vec2 shadowHit = findHit(hitPoint, lightDir, hitID);\n    float shadow = shadowHit.y >= 0.0 ? 0.5 : 0.0;\n    \n    // Find the normal of the sphere and the diffuse lighting from the normal\n    vec4 nml = hitID == -1 ? up : sphereNormal(hitPoint, sphereCenters[hitID]);\n    float diffuse = max(dot(nml, lightDir) + 0.4 - shadow, 0.0) * 0.95;\n    \n    fragColor = vec4(vec3(diffuse), 1.0);\n}","name":"Image","description":"","type":"image"}]}