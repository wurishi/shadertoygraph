{"ver":"0.1","info":{"id":"WdtyRH","date":"1608087555","viewed":255,"name":"Voxel Raycasting w/ SDF Skipping","username":"Oberdiah","description":"A modified Branchless Voxel Raycasting (https://www.shadertoy.com/view/4dX3zl) implementation that uses the sdf to jump more than one voxel per iteration. \n\nA similar idea to https://www.shadertoy.com/view/MllcD7 but far less complex.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raycasting","sdf","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A modified Branchless Voxel Raycasting\n// that uses the generated sdf to jump more than\n// one voxel per iteration.\n// https://www.shadertoy.com/view/4dX3zl\n\n// A similar idea to https://www.shadertoy.com/view/MllcD7\n// but far less complex.\n\n\nconst int MAX_RAY_STEPS = 40;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nfloat getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 75.), sdBox(p, vec3(60.))), -sdSphere(p, 2500.0));\n\treturn d;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        float sdf = floor(getVoxel(mapPos));\n\t\tif (sdf < 0.) break;\n        \n        vec3 mi = min(min(sideDist.x, sideDist.y), sideDist.z) - sideDist;\n        mask = ceil((max(sdf - 2.0, 0.0001) + mi) / deltaDist);\n        sideDist += vec3(mask) * deltaDist;\n        mapPos += ivec3(vec3(mask)) * rayStep;\n\t}\n\t\n\tvec3 color = vec3(1);\n\tif (mask.x != 0.) {\n\t\tcolor *= vec3(0.5);\n\t}\n\tif (mask.y != 0.) {\n\t\tcolor *= vec3(1.0);\n\t}\n\tif (mask.z != 0.) {\n\t\tcolor *= vec3(0.75);\n\t}\n\tfragColor.rgb = color;\n}","name":"Image","description":"","type":"image"}]}