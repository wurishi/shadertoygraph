{"ver":"0.1","info":{"id":"fdtXDS","date":"1633872084","viewed":104,"name":"Crystalline Morphing","username":"dominionxvii","description":"Snowflakes morphing between them, generated with Raymarching","likes":1,"published":1,"flags":32,"usePreview":1,"tags":["raymarchingcrystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n#define TAU 6.2831\n\nconst float HEXAGONALANGLE = 60.;\n\nvec2 HexSymmetry(vec2 pos, bool mirrorX)\n{\n    float radHexAngle = radians(60.);\n    \n    vec2 polar = vec2(length(pos), atan(pos.y, pos.x));\n    \n    \n    polar.y = mod(polar.y, radHexAngle) + radHexAngle;\n    float r = polar.x;\n    float a = polar.y;\n    pos.xy =  vec2(r * cos(a), r * sin(a));\n    \n    if(mirrorX)\n        pos.x = abs(pos.x);\n        \n    return pos;\n}\n\n\nbool IsInFrame(vec2 uv)\n{\n   return (uv.x > 0. && uv.y > 0. && uv.x < 1. && uv.y < 1.);\n}\n\nvec4 LightStreak(vec2 uv, vec2 dir, vec2 dirTan)\n{\n   vec4 sum = vec4(0.0);\n\n   float streakLen = 0.125;\n   int count = 50; //boost for bootiful\n   float steps = streakLen / float(count);\n   \n   float disto = 0.05;\n   float distoSpeed = 0.1;\n   float intensity = 0.2;\n\n   for(int i = 0; i < count; i++)\n   {\n       float xnoise1 = fbm_4r(vec3(uv * 2.0, iTime * distoSpeed), m3);\n       float xnoise2 = snoise(vec3(uv * 1.0, iTime * distoSpeed * 0.5));\n       float xnoise = mix(xnoise1, xnoise2, 0.5);\n       \n       vec2 uv2 = uv + dir * float(i) * steps + dirTan * disto * xnoise;\n       float iratio = 1. - (float(i) / float(count - 1));\n       \n       bool verticalStreakInRange = dir.y == -1. && dir.x == 0.0 && uv2.y >= 0.;\n       bool radialStreakInRange = IsInFrame(uv2);\n       \n       if(verticalStreakInRange || radialStreakInRange)\n       {\n           vec4 col = texture(iChannel0, uv2);\n           sum += saturate(vec4(col.rgb * col.a, col.a)) * iratio;\n       }\n     }\n \n   float filterNoise = norm(fbm_4r(vec3(uv * 5., iTime * 0.3), m3));\n   return (sum / float(count)) * filterNoise * intensity;\n}\n\n\n\nvec4 GetGradientColor(vec2 uv, float t)\n{\n    t += sin(uv.x * 0.5) * 0.2;\n    t += uv.y;\n    \n    const int size = 5;    \n    vec4 cols[size] = vec4[size]\n    (\n        GetCol(155, 169, 208),\n        GetCol(199, 216, 232),\n        GetCol(222, 232, 242),\n        GetCol(217, 220, 237),\n        GetCol(246, 245, 250)\n    );\n    \n    float sizeT = fract(t) * float(size);\n    int id1 = int(sizeT);\n    int id2 = (id1 + 1);\n    \n    float tt = unlerp(sizeT, float(id1), float(id2));\n    tt = easeInOutCubic(tt);\n    return mix(cols[id1], cols[id2 % size], tt);    \n}\n\nvec4 CloudBackground(vec2 uv)\n{    \n    vec3 rayDir = (vec3(uv.x, uv.y, 1.0));\n    vec4 col = vec4(RotateZ(rayDir, 0.2 * iTime + length(uv) * 2.0), 1.0);\n    col = col * 0.5 + 0.5;\n    col = normalize(col);\n   \n    float cloudIntensity1 = cellfbm(uv * 2.0 + vec2(iTime * 0.05), 4);\n    float cloudIntensity2 = norm(fbm_4r(vec3(uv, iTime * .1), m3));\n\n    float cloudIntensity = mix(cloudIntensity1, cloudIntensity2, 0.25);\n    float cloud = 1.0 - easeInCubic(cloudIntensity);\n    return (col + cloud * 0.5) * 1.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 uvSym = uv2;\n    uvSym.x += 0.1 * sin(iTime);\n    uvSym = HexSymmetry(uvSym, true).xy;\n    \n    vec2 dir = normalize(uvSym);\n    vec2 dirTan = RotateZ(vec3(dir, 1.0), radians(90.)).xy;\n\n    vec4 col = texture(iChannel0, uv);  \n    if(col.a == 0.0)\n    {\n        float distanceCenter = distance(uv2, vec2(0.0));\n        float distIntensity = DASRCurve(distanceCenter, 0.05, 0.2, 0.3, 1.0);\n        col -= LightStreak(uv, normalize(vec2(1.0, 2.8)), vec2(0.2, -0.2)) * distIntensity;\n\n    }\n    else\n    {\n        vec4 cloud = CloudBackground(uv2);\n        float cover = norm(fbm_4(vec3(uv2 * 5.0 + vec2(iTime * 0.2), iTime * 0.1)));\n        col = mix(col * 0.75, cloud, cover * 0.75);\n    }\n\n    \n    fragColor = col;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1416\n#define TAU 6.2831\n\n//[-1, 1] -> [0, 1]\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nvec3 project(vec3 a, vec3 b)\n{\n    return (dot(a, b)/dot(b,b))*b;\n}\n\nvec3 reject(vec3 a, vec3 b)\n{\n    return a - project(a, b);\n}\n\nvec3 RotateAroundAxis(vec3 p, vec3 axis, float a)\n{\n    vec3 parallel = project(p, axis);\n    vec3 orthogonal = reject(p, axis);\n    vec3 vcross = cross(p, axis);\n    return parallel + orthogonal * cos(a) + vcross * sin(a);\n}\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\nfloat ReduceResolution(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\n\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x,\n        p.y * c - p.z * s,\n        p.y * s + p.z * c\n      );\n}\n\n\nvec3 RotateZ45(vec3 pos)\n{\n    return RotateZ(pos, radians(45.));\n}\nvec3 RotateY45(vec3 pos)\n{\n    return RotateY(pos, radians(45.));\n}\nvec3 RotateX45(vec3 pos)\n{\n    return RotateX(pos, radians(45.));\n}\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 GetCol(int r, int g, int b)\n{\n    return vec4(r, g, b, 1.) / 255.;\n}\n\nfloat cheapNoise(vec2 v)\n{\n    return \n        0.333 * sin(v.x * 3.151) +\n        0.333 * sin(v.y * 8.357) + \n        0.333 * cos((v.x + v.y) * 3.723);\n\n}\n\nvec3 cheapNoise(vec3 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.y, v.z + t + 252.)),\n        cheapNoise(vec2(v.z, v.x + t + 623.))\n        );\n}\n\n//Ease, https://easings.net\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad(float x) {\n    return x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n\n    if (x < 1.0 / d1) {\n        return n1 * x * x;\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 5.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nfloat easeInOutBack(float x) \n{\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n      : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat easeInBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\n\nfloat easeInCirc(float x)\n{\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\nfloat easeInOutQuint(float x)\n{\n    return x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\n\nvec2 PolarToCartesian(vec2 polar)\n{\n    float r = polar.x;\n    float a = polar.y;\n    return vec2(r * cos(a), r * sin(a));\n}\nvec2 CartesianToPolar(vec2 cartesian)\n{\n    float r = length(cartesian);\n    float a = atan(cartesian.y, cartesian.x);\n    return vec2(r, a);\n}\n\n\nvec3 AddStar(vec3 pos, float angle)\n{\n    float radPentaAngle = radians(360.0 / 5.0);\n    vec2 polarCoord = CartesianToPolar(pos.xy);\n    polarCoord.y = mod(polarCoord.y, radPentaAngle) + radPentaAngle + angle;\n    pos.xy = PolarToCartesian(polarCoord);\n \n    float angle2 = CartesianToPolar(pos.xy).y;\n    return pos;\n}\n\nvec3 AddSymmetryToPos(vec3 pos, bool mirrorX)\n{\n    float radHexAngle = radians(60.);\n    \n    vec2 polarCoord = CartesianToPolar(pos.xy);\n    polarCoord.y = mod(polarCoord.y, radHexAngle) + radHexAngle;\n    pos.xy = PolarToCartesian(polarCoord);\n    \n    if(mirrorX)\n        pos.x = abs(pos.x);\n        \n    float angle2 = CartesianToPolar(pos.xy).y;\n    return pos;\n}\n\n\n///https://iquilezles.org/articles/distfunctions\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n\nvec3 opTwist(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCrystal4(vec3 pos, float size, vec2 heights, float topCut, vec3 boxCut)\n{\n    vec3 pos1 = pos;\n    float minD = sdPyramid(pos1, heights.x);\n    minD = max(minD, sdBox(pos1 + vecY(topCut), vec3(size)));\n    \n    vec3 pos2 = vec3(pos.x, -pos.y, pos.z);\n    minD = min(minD, sdPyramid(pos2, heights.y));\n    \n    minD = max(minD, sdBox(pos, boxCut));\n    return minD;\n}\n\nfloat sdCrystal8(vec3 pos)\n{\n/*\n    float topCut = 0.7;\n    float size = 1.;\n    vec2 height = vec2(0.5, 1.0);\n    vec3 boxCut = vec3(0.47, 5.0, 0.47);\n    float d1 = sdCrystal4(pos, size, height, topCut, boxCut);\n    \n    pos = RotateY(pos, radians(45.0));\n    float d2 = sdCrystal4(pos, size, height, topCut, boxCut);\n    */\n    float topCut = 0.3;\n    float size = 0.5;\n    vec2 height = vec2(0.25, 0.5);\n    vec3 boxCut = vec3(0.25, 2.5, 0.15);\n    float d1 = sdCrystal4(pos, size, height, topCut, boxCut);\n    \n    pos = RotateY(pos, radians(45.0));\n    float d2 = sdCrystal4(pos, size, height, topCut, boxCut);\n    return max(d1, d2);\n}\n\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n\nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n    }\n\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n     \n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n    }\n\treturn a;\n}\n\nfloat fbm_4r( in vec3 x, mat3 rot)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\nfloat fbm4r_3x( in vec3 x, mat3 rot)\n{\n    vec3 fbm1 = vec3(fbm_4r(x, rot));\n    vec3 fbm2 = x + fbm_4r(fbm1, rot);\n    return fbm_4r(x + fbm2, rot);\n}\n\nfloat fbm4_3x( in vec3 x, vec3 offset)\n{\n    return fbm_4(x + offset + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\n\n//quaternions\n\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define HD\n\n\n//Debug\n//#define DEBUG\n#define DEBUG_CRYSTAL 1\n\n#define PI 3.1416\n#define TAU 6.2831\n#define BPM 180.\nconst float HEXAGONALANGLE = 60.;\n\nconst int numberCrystal = 4;\n\nconst float beatDuration = 60. / BPM;\nconst float beatPerMesure = 7.;\n\n\nstruct RayPrimHit\n{\n    float dist;\n    vec3 rotationAxis;\n    float rotationAngle;\n};\n\nstruct RayHit \n{\n    bool hasHit;\n    vec3 hitPos;\n    float dist;\n    vec3 normal;\n    vec3 reflPos;\n    vec3 reflDir;\n    vec2 uv;\n    int steps;\n    RayPrimHit primHit;\n};\n\nvec3 AddSymmetryToPosMirrorX(vec3 pos, float yAngle)\n{\n    pos = RotateY(pos, -yAngle);\n    pos = AddSymmetryToPos(pos, true);\n    return pos;\n}\n\n\nvec3 AddSymmetryToPos(vec3 pos, float yAngle)\n{\n    pos = RotateY(pos, -yAngle);\n    pos = AddSymmetryToPos(pos, false);\n    return pos;\n}\n\n\n\nRayPrimHit MixPrimHit(RayPrimHit hit1, RayPrimHit hit2, float t)\n{\n    RayPrimHit hit = hit1;\n    hit.dist = mix(hit1.dist, hit2.dist, t);\n    return hit;\n}\n\nRayPrimHit MixPrimHit(RayPrimHit hit1, RayPrimHit hit2, RayPrimHit hit3, float t)\n{\n    RayPrimHit hit = hit1;\n    float t1 = mix(hit1.dist, hit2.dist, t);\n    float t2 = mix(hit2.dist, hit3.dist, t);\n    hit.dist = mix(t1, t2, t);\n    return hit;\n}\n\n\nfloat AddTexture(vec3 pos, vec3 size, float spread)\n{\n    pos = opRepLim(pos, spread, vec3(10., 10., 4.6));\n    pos = RotateZ45(pos);\n    pos = RotateX45(pos);\n    return sdBox(pos, size);\n}\n\nfloat BevelCube(vec3 pos, vec3 offset, vec3 size, vec2 bevelRatio)\n{\n    vec3 sizebevel = vec3(size.x * bevelRatio.x, size.y * bevelRatio.x, size.z * bevelRatio.y);\n    float d1 = sdBox(pos - offset, size);\n    float d2 = sdBox(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nfloat BevelCubeDiamond(vec3 pos, vec3 offset, vec3 size, vec2 bevelRatio)\n{\n    return BevelCube(RotateZ45(pos), RotateZ45(offset), size, bevelRatio);\n}\n\nfloat BevelHex(vec3 pos, vec3 offset, vec2 size, vec2 bevelRatio)\n{\n    vec2 sizebevel = vec2(size.x * bevelRatio.x, size.y * bevelRatio.y);\n    float d1 = sdHexPrism(pos - offset, size);\n    float d2 = sdHexPrism(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nfloat BevelHexRotZ(vec3 pos, vec3 offset, float rotationZ, vec2 size, vec2 bevelRatio)\n{\n    pos = RotateZ(pos, rotationZ);\n    offset = RotateZ(offset, rotationZ);\n    return BevelHex(pos, offset, size, bevelRatio);\n}\n\nfloat BevelTriPrism(vec3 pos, vec3 offset, vec2 size, vec2 bevel)\n{\n    vec2 sizebevel = vec2(size.x * bevel.x, size.y * bevel.y);\n    float d1 = sdTriPrism(pos - offset, size);\n    float d2 = sdTriPrism(pos - offset, sizebevel);\n    return mix(d1, d2, 0.5);\n}\n\nfloat ClockAngle(float duration, float angleStep, float animSpeed)\n{\n    float speed = 1. / duration;\n    float time = iTime * speed;\n    float t = fract(time);\n    float count = floor(time);\n    \n    t = saturate(t * animSpeed);   \n    t = easeOutCirc(t);\n    return (t + count) * angleStep;\n}\n\n\nRayPrimHit CrystalBase(vec3 pos, float rotAngle)\n{\n    pos = AddSymmetryToPos(pos, rotAngle);\n    vec2 bevel = vec2(0.5, 0.7);    \n\n    RayPrimHit hit;\n    hit.dist = 999999.;\n\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.7, .05), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.6, .075), bevel));\n    \n    hit.dist = min(hit.dist, BevelHex(pos, vecY(0.5), vec2(.1, .05), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.15, 0.5, 0.0), vec2(.05, .05), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(-0.15, 0.5, 0.0), vec2(.05, .05), bevel));\n    \n    return hit;\n}\n\n\nRayPrimHit Crystal0(vec3 pos, float rotAngle)\n{\n    vec3 pos2 = pos;\n    vec3 pos1 = RotateY(pos, -rotAngle);\n    vec3 posNoMirror = AddSymmetryToPos(pos, rotAngle);\n    pos = AddSymmetryToPosMirrorX(pos, rotAngle);\n\n    RayPrimHit hit;\n    hit.dist = 999999.;\n    float thicc = 0.03;\n    vec2 bevel = vec2(0.5, 0.5);\n    \n    float a1 = ClockAngle(beatDuration, radians(10.), 1.5);\n    float a2 = ClockAngle(beatDuration * 7.0, radians(30.), 6.0) + radians(90.);\n\n    //gears\n    vec3 posGear = pos2;\n    posGear = RotateY(posGear, -rotAngle);\n    posGear = RotateZ(posGear, a2 + radians(90.));\n    posGear = AddSymmetryToPos(posGear, 0.0);\n    hit.dist = min(hit.dist, BevelHexRotZ(posGear, vecY(0.45), a1 * 2.0, vec2(.2, thicc), bevel));  \n    hit.dist = max(hit.dist, -BevelHexRotZ(posGear, vecY(0.45), a1 * 2.0, vec2(.1, thicc * 1.5), bevel));  \n\n    //middle\n    hit.dist = min(hit.dist, BevelHex(posNoMirror, vec3(0.), vec2(.45, thicc), bevel)); \n    hit.dist = min(hit.dist, BevelHex(posNoMirror, vec3(0.), vec2(.25, thicc * 1.5), bevel));  \n    \n    //outer ring\n    hit.dist = min(hit.dist, BevelHex(posNoMirror, vec3(0.), vec2(2.0, 0.005), bevel)); \n    hit.dist = max(hit.dist, -BevelHex(posNoMirror, vec3(0.), vec2(1.85, 0.01), bevel)); \n\n    //inner ring\n    hit.dist = min(hit.dist, BevelHex(posNoMirror, vec3(0.), vec2(1.4, 0.005), bevel)); \n    hit.dist = max(hit.dist, -BevelHex(posNoMirror, vec3(0.), vec2(1.3, 0.01), bevel)); \n\n    //border\n    vec3 borderpos = pos;\n    float borderCurve =  pos.x * 0.1;\n    borderpos.y += borderCurve;\n    \n    //side crytstals\n    hit.dist = smin(hit.dist, BevelHexRotZ(pos, vec3(0.7, 1.12, 0.0), 0.3, vec2(.2, .05), bevel), 0.03);  \n    hit.dist = smin(hit.dist, BevelHexRotZ(pos, vec3(0.55, 0.752, 0.0), 0.3, vec2(.2, .05), bevel), 0.03);  \n  \n    //mid border thingny\n    vec3 midCrystal = pos;\n    midCrystal.x *= 1.3;\n    hit.dist = min(hit.dist, BevelCubeDiamond(midCrystal, vec3(0.0, 1.1, 0.0), vec3(0.075, 0.075, .03), bevel));  \n\n    //spike\n    float rotA = radians(20.0);\n    vec3 spikePos1 = RotateZ(pos1, -a1);\n    spikePos1.x *= 1.3;\n    \n    vec3 spikePos2 = RotateZ(pos1, -a2);\n    float thicc2 = thicc + 0.01;\n    spikePos2.x *= 1.3;\n    \n    float arrow1 = 9999.;\n    arrow1 = min(arrow1, BevelCubeDiamond(spikePos1, vecY(1.1), vec3(0.15, 0.15, thicc), bevel));  \n    arrow1 = max(arrow1, -BevelCubeDiamond(spikePos1, vecY(1.1), vec3(0.1, 0.1, thicc2), bevel));  \n    arrow1 = min(arrow1, BevelCube(spikePos1, vecY(0.5), vec3(0.03, 1.00, thicc), bevel));  \n    hit.dist = min(hit.dist, arrow1);\n\n    hit.dist = min(hit.dist, BevelCubeDiamond(spikePos2, vecY(0.65), vec3(0.16, 0.16, thicc), bevel));  \n    hit.dist = min(hit.dist, BevelCubeDiamond(spikePos2, vecY(0.65), vec3(0.06, 0.06, thicc2), bevel));  \n\n    hit.dist = min(hit.dist, BevelCube(spikePos2, vecY(0.3), vec3(0.03, 0.64, thicc), bevel));  \n\n    return hit;\n}\n\n\nRayPrimHit Crystal1(vec3 pos, float rotAngle)\n{\n    vec3 reverseSpin = AddSymmetryToPosMirrorX(pos, -rotAngle);\n    pos = AddSymmetryToPosMirrorX(pos, rotAngle); \n\n    RayPrimHit hit;  \n    \n    hit.dist = 100.;\n    vec2 bevel = vec2(0.5);\n\n     //base reverse spin\n    hit.dist = min(hit.dist, BevelHex(reverseSpin, vec3(0.0), vec2(.4, .05), bevel));\n    hit.dist = max(hit.dist, -BevelHex(reverseSpin, vec3(0.0), vec2(.2, .075), vec2(0.5, 0.2)));\n\n    vec3 rotPos1 = RotateY(pos, easeInOutQuad(fract(iTime * 0.2)) * TAU);\n   \n    //first hex\n    hit.dist = min(hit.dist,  BevelHex(rotPos1, vecY(0.5), vec2(0.35, 0.02), bevel));\n    hit.dist = max(hit.dist, -BevelHex(rotPos1, vecY(0.5), vec2(0.15, 0.12), bevel));\n    hit.dist = max(hit.dist, -BevelHex(rotPos1, vec3(0.2, 0.6, 0.0), vec2(0.15, 0.12), bevel));\n\n    vec3 rotPos2 = rotPos1;\n    float angle = -radians(HEXAGONALANGLE) + sin(iTime * 1.0) * 0.2;\n    hit.dist = min(hit.dist, BevelCube(rotPos2, vecY(1.25), vec3(.06, .515, 0.05), vec2(0.5, 0.5)));\n    hit.dist = min(hit.dist, BevelCube(RotateZ(rotPos2, angle), RotateZ(vecY(0.75), angle), vec3(.06, .5, 0.05), vec2(0.5, 0.5)));\n    hit.dist = min(hit.dist, BevelCube(RotateZ(rotPos2, angle), RotateZ(vecY(0.95), angle), vec3(.06, .4, 0.05), vec2(0.5, 0.5)));\n    hit.dist = min(hit.dist, BevelCube(RotateZ(rotPos2, angle), RotateZ(vecY(1.15), angle), vec3(.06, .3, 0.05), vec2(0.5, 0.5)));\n\n    return hit;\n}\n\n\nRayPrimHit Crystal2(vec3 pos, float rotAngle)\n{\n    pos = RotateY(pos, -rotAngle);\n    pos += 0.05 * cheapNoise(pos * 2.0, iTime * 0.5) + 0.025 * fbm4r_3x(pos * 0.75, m3);\n\n    pos = AddSymmetryToPos(pos, true);\n\n    RayPrimHit hit;  \n    hit.dist = 999.;\n    hit.dist = smin(hit.dist, BevelTriPrism(pos, vecY(1.2), vec2(0.5, 0.06), vec2(0.5)), 0.03);\n\n    hit.dist = smin(hit.dist, sdBox(pos, vec3(0.07, 1.0, 0.05)), 0.2);\n        \n    int loop = 5;\n    for(int i = 0; i < loop; i++)\n    {\n        float iratio = float(i) / float(loop);\n        float posOffset = fract(iTime * 0.1 + iratio); \n        posOffset = easeOutQuad(posOffset);\n        hit.dist = smin(hit.dist, sdBox(pos - vecY(posOffset), vec3(1.0 - posOffset, 0.015, 0.05)), 0.12);   \n    }\n    \n    return hit;\n}\n\nRayPrimHit Crystal3(vec3 pos, float rotAngle)\n{\n    pos = AddSymmetryToPos(pos, rotAngle);\n    vec3 spinPos = RotateY(pos, rotAngle);\n    \n    RayPrimHit hit;\n    hit.dist = 999999.;\n    float thicc = 0.03;\n    vec2 bevel = vec2(0.5);\n    float sinSpin = sin(iTime * PI * (1.0 / beatDuration));\n    \n    sinSpin *= 0.15;\n    \n    float ratio = saturate(spinPos.y / 1.9);\n    float rotation = easeInCubic(ratio) * sinSpin;\n    vec3 wigglePos = RotateZ(spinPos, rotation * 1.5);\n    \n    //sapin\n    hit.dist = min(hit.dist, BevelTriPrism(wigglePos, vecY(0.7), vec2(.5, .05), bevel));\n    hit.dist = min(hit.dist, BevelTriPrism(wigglePos, vecY(0.9), vec2(.35, .05), bevel));\n    hit.dist = min(hit.dist, BevelTriPrism(wigglePos, vecY(1.1), vec2(.2, .05), bevel));\n  \n    //tite etoile\n    vec3 starOffset = vecY(1.35);\n    vec3 starSpin = RotateZ(spinPos, sinSpin * 0.5);\n    vec3 starPos = AddStar(starSpin - starOffset, -sinSpin); \n    hit.dist = min(hit.dist, BevelTriPrism(starPos, vec3(0.0), vec2(.075, .02), bevel));\n\n    //guirlande\n    vec3 sinPos1 = wigglePos + vecY(0.05) * sin(wigglePos.x * 15. * 4.0) * 0.2;\n    vec3 sinPos2 = wigglePos + vecY(0.04) * sin(wigglePos.x * 20. * 4.0) * 0.2;\n    vec3 sinPos3 = wigglePos + vecY(0.03) * sin(wigglePos.x * 25. * 4.0) * 0.2;\n\n    hit.dist = smin(hit.dist, BevelCube(sinPos1, vecY(0.65), vec3(.4, .01, 0.04), vec2(0.5, 0.5)), 0.02);\n    hit.dist = smin(hit.dist, BevelCube(sinPos2, vecY(0.9), vec3(.25, .01, 0.04), vec2(0.5, 0.5)), 0.02);\n    hit.dist = smin(hit.dist, BevelCube(sinPos3, vecY(1.1), vec3(.1, .01, 0.04), vec2(0.5, 0.5)), 0.02);\n\n    //tite boule de nowelle\n    float bouleSize = 0.045;\n    hit.dist = min(hit.dist, sdSphere(wigglePos - vec3(0.1, 0.7, 0.0), bouleSize));\n    hit.dist = min(hit.dist, sdSphere(wigglePos - vec3(-0.06, 0.87, 0.0), bouleSize));\n    hit.dist = min(hit.dist, sdSphere(wigglePos - vec3(0.05, 1.05, 0.0), bouleSize));\n    \n    //tronc\n    hit.dist = min(hit.dist, BevelCube(wigglePos, vecY(0.5), vec3(.06, .5, 0.025), vec2(0.5, 0.5)));\n\n    //base\n    hit.dist = smin(hit.dist, BevelCube(pos, vecY(0.4), vec3(.55, .03, 0.025), vec2(0.5, 0.5)), 0.05);\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.4, .05), bevel));\n    hit.dist = min(hit.dist, BevelHex(pos, vec3(0.0), vec2(.3, .075), bevel));\n\n    return hit;\n}\n\nRayPrimHit GetCrystal(vec3 pos, float rotAngle, int id)\n{\n    switch(id)\n    {\n        case 0: return Crystal0(pos, rotAngle);\n        case 1: return Crystal1(pos, rotAngle);\n        case 2: return Crystal2(pos, rotAngle);\n        case 3: return Crystal3(pos, rotAngle);\n\n    }\n    RayPrimHit hit;  \n    return hit;\n}\n\nRayPrimHit DistanceFunction(vec3 pos)\n{\n    RayPrimHit hit; \n    float duration = 4.0 * beatDuration * beatPerMesure;\n    float speed = 1.0 / duration;\n    \n    vec3 rotAxis = vecY(1.0);\n    float rotAngle = iTime * speed;\n    \n    float fracRot = fract(rotAngle);\n    float floorRot = floor(rotAngle);\n    rotAngle = (easeInOutCubic(easeInOutCubic(fracRot)) + floorRot) * PI;\n \n    float morphTime = iTime * speed + 0.5;\n    int crystalIDprev = int(mod(floor(morphTime), float(numberCrystal)));\n    int crystalIDnext = int(mod(floor(morphTime + 1.0), float(numberCrystal)));\n    float morphOffset = 0.4;\n\n    float remapMorph = Remap(morphOffset, 1.0 - morphOffset, 0., 1., fract(morphTime)); \n    float crystalMix = (remapMorph);\n\n\n#ifdef DEBUG\n    //testing individual flakes\n    RayPrimHit mixHit = GetCrystal(pos, rotAngle, DEBUG_CRYSTAL);\n#else\n    RayPrimHit baseHit = CrystalBase(pos, rotAngle);\n    RayPrimHit crystalPrev = GetCrystal(pos, rotAngle, crystalIDprev);\n    RayPrimHit crystalNext = GetCrystal(pos, rotAngle, crystalIDnext);\n    RayPrimHit mixHit;\n    if(crystalMix < 0.5)\n    {\n        float crystalMix = crystalMix * 2.0;\n        crystalMix = easeInCubic(crystalMix);\n        mixHit = MixPrimHit(crystalPrev, baseHit, crystalMix);\n    }\n    else\n    {\n        float crystalMix = (crystalMix - 0.5) * 2.0;\n        crystalMix = easeOutCubic(crystalMix);\n        mixHit = MixPrimHit(baseHit, crystalNext, crystalMix);\n    }\n#endif\n    \n    mixHit.rotationAngle = rotAngle;\n    mixHit.rotationAxis = rotAxis;\n    return mixHit;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.01;\n    const vec2 h = vec2(eps,0);\n    \n    float distX1 = DistanceFunction(p+h.xyy).dist;\n    float distX2 = DistanceFunction(p-h.xyy).dist;\n    \n    float distY1 = DistanceFunction(p+h.yxy).dist;\n    float distY2 = DistanceFunction(p-h.yxy).dist;\n    \n    float distZ1 = DistanceFunction(p+h.yyx).dist;\n    float distZ2 = DistanceFunction(p-h.yyx).dist;\n\n    return normalize( vec3(distX1 - distX2,\n                           distY1 - distX2,\n                           distZ1 - distZ2));\n}\n\n\nRayHit SetupRayHit(vec3 ro, vec3 rd, bool hasHit, float dist, vec3 normal, vec2 uv, int steps, RayPrimHit primHit)\n{\n    RayHit rayHit;\n    rayHit.hasHit = hasHit;\n    rayHit.hitPos = ro + rd * dist;\n    rayHit.dist = dist;\n    rayHit.normal = normal; \n    rayHit.reflDir = reflect(rd, rayHit.normal);\n    rayHit.reflPos = rayHit.hitPos + rayHit.reflDir * 0.01;\n    rayHit.uv = uv;\n    rayHit.steps = steps;\n    rayHit.primHit = primHit;\n\n    return rayHit;\n}\n\nRayHit Raymarch(vec3 ro, vec3 rd)\n{\n    float currentDist = 0.;\n    bool hasHit = false;\n    RayPrimHit primHit;\n    int i;\n    for(i = 0; i < 10000; i++)\n    {\n        vec3 pos = ro + rd * currentDist;\n        primHit = DistanceFunction(pos);\n        float dist = primHit.dist;\n        currentDist += dist;\n      \n        if(dist < 0.0001)\n        {    \n            hasHit = true;\n            break;\n        }\n        else if(currentDist > 1000.0)\n        {\n            break;\n        }\n    }\n\n    vec3 normal = calcNormal(ro + rd * currentDist);\n    vec2 uv = vec2(0.0);\n    return SetupRayHit(ro, rd, hasHit, currentDist, normal, uv, i, primHit); \n}\n\nvec4 NormalColorWheel(float a, float frequency, float phase)\n{\n    float s = sin(a * frequency * TAU + phase);\n    float c = cos(a * frequency * TAU + phase);\n    vec2 col = vec2(s, c);\n    return vec4((col + 1.0) * 0.5, 1.0, 1.0);\n}\n\nvec4 StarShine(vec3 pos, float scale, float size, float rollAngle, float yawAngle)\n{\n    pos = RotateY(pos, -yawAngle * length(pos));\n    pos = RotateZ(pos, radians(rollAngle));\n    float cell = cellular(pos.xy * scale).x;\n    float shine = 0.8;\n    \n    float starSize = size;\n    float fadeDist = size * 35.;\n\n    if(cell < starSize)\n    {\n        return vec4(1.) * shine;\n    }\n    else if(cell < fadeDist)\n    {\n        float intensity = 1. - unlerp(cell, starSize, fadeDist);\n        intensity = pow(intensity, 5.);\n        return vec4(intensity) * shine * 0.15;\n    }\n    else\n    {\n        return vec4(0);\n    }\n}\n\nvec4 GetColor(RayHit hit, vec3 viewDir, vec2 uv)\n{\n    vec3 localHitPos = RotateAroundAxis(hit.hitPos, hit.primHit.rotationAxis, hit.primHit.rotationAngle);\n    float amb = 0.2;\n\n    vec4 col1 = GetCol(177, 198, 230);\n    vec4 col2 = GetCol(184, 177, 230) * 0.7;\n\n    \n    vec3 lightDir = normalize(vec3(.6, -.3, .5));\n    \n    float l = saturate(dot(-hit.normal, lightDir));\n    float h = saturate(dot(-hit.normal, viewDir));\n\n\n    vec4 normalCol = vec4((-hit.normal + 1.0) / 2.0, 1.0);\n    vec4 iridescent1 = NormalColorWheel(h, 1.0, 5.5);\n    vec4 iridescent2 = NormalColorWheel(l, 1.0, 4.5);\n    vec4 iridescent = mix(iridescent1, iridescent2, 0.5);\n    \n    vec3 shineDir1 = cheapNoise(localHitPos * 30., 1.0);\n    vec3 shineDir2 = cheapNoise(localHitPos * 15., 5.0);\n    vec3 shineDir = normalize(mix(shineDir1, shineDir2, 0.25));\n    float shine = saturate(dot(normalize(viewDir - lightDir), shineDir));\n    shine = Remap(0.98, 1.0, 0.0, 0.7, shine) * saturate(snoise(localHitPos * 10.));\n    \n#ifdef HD    \n    vec3 cloudDir = normalize(vec3(fbm4r_3x(localHitPos * 2.5, m3), fbm_4(localHitPos * 2.), 1.0));\n#else\n    vec3 cloudDir = normalize(vec3(cheapNoise(localHitPos * 2.5, 0.0).x, cheapNoise(localHitPos * 2., 25.).y, 1.0));\n#endif\n    \n    vec4 cloud = NormalColorWheel(dot(lightDir, cloudDir), 1.0, 2.0) * 0.2;\n\n    vec4 starShine = \n        StarShine(hit.hitPos, 5.1, 0.02, iTime * 1.0, 0.5) +  \n        StarShine(hit.hitPos, 7.1, 0.01, iTime * 1.5, 1.0);\n    \n\n    vec4 col = mix(normalCol, iridescent, 1.0) * 1.2;\n\n    vec4 refl = texture(iChannel0, hit.normal);\n    vec4 trans = texture(iChannel0, viewDir);\n    vec4 shade =  mix(refl, trans, 0.7);\n        \n    return mix(col, shade, 0.0) + starShine + cloud + shine;\n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\n\nvec4 CloudBackground(vec2 uv)\n{\n    \n    vec3 rayDir = (vec3(uv.x, uv.y, 1.0));\n    vec4 col = vec4(RotateZ(rayDir, 0.2 * iTime + length(uv) * 2.0), 1.0);\n    col = col * 0.5 + 0.5;\n    col = normalize(col);\n  \n    float cloudIntensity1 = cellfbm(uv * 2.0 + vec2(iTime * 0.05), 4);\n    float cloudIntensity2 = norm(fbm_4r(vec3(uv, iTime * .1), m3));\n\n    float cloudIntensity = mix(cloudIntensity1, cloudIntensity2, 0.25);\n    float cloud = 1.0 - easeInCubic(cloudIntensity);\n   \n    return (col + cloud * 0.5) * 1.1;\n}\n\n\nvec4 RenderAtUv(vec3 camPos, vec4 camRot, vec2 uv)\n{\n    vec3 ro, rd;\n    PerspectiveCam(camPos, camRot, uv, ro, rd);\n    \n    RayHit hit = Raymarch(ro, rd);\n    \n    if(hit.hasHit)\n    {\n        vec4 col = GetColor(hit, rd, uv);\n        return col;\n    }\n    else\n    {\n        vec4 col = CloudBackground(uv);\n        col.a = 0.0;\n        return col;\n    }\n}\n\n#ifdef HD  \nvec4 RenderAtUvAntiAliasing(vec3 camPos, vec4 camRot, vec2 uv, vec2 fragCoord)\n{\n    vec4 colorSum = vec4(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n    colorSum += RenderAtUv(camPos, camRot, uv);\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n    colorSum += RenderAtUv(camPos, camRot, mix(uv, nextUv, 0.5));\n    colorSum /= 4.0;\n    return colorSum;\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 camPos = vec3(0., 0.0, -4.0);\n    vec4 camRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n#ifdef HD  \n    fragColor = RenderAtUvAntiAliasing(camPos, camRot, uv, fragCoord);  \n#else\n    fragColor = RenderAtUv(camPos, camRot, uv); \n#endif\n}\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}