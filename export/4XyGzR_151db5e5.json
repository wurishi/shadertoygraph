{"ver":"0.1","info":{"id":"4XyGzR","date":"1717172946","viewed":111,"name":"Physics - chain","username":"kastorp","description":".","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","collision","simulation","physics","mpr","verlet","rigidbody"],"hasliked":0,"parentid":"l3cGDM","parentname":"Physics - structures"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Physics chain\" by kastorp\n//---------------------------\n\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF ) return vec2(NOHIT); // no intersection\n    oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    oFuv=vec3( dot(abs(oNor),vec3(1,5,9)+ oNor)/2.,dot(ro+rd*tN,oNor.zxy),dot(ro+rd*tN,oNor.yzx));   \n    return vec2(tN,tF);\n\n}\n\nvec3 rayPos,rayDir;\nfloat minDist;\nvec3 minDistNormal;\nfloat minDistMaterial;\nvec2 minDistUv;\n\nvoid renderBox(int ci){\n     vec4 q = getCubeQuat(ci),\n         qi=vec4(-q.xyz,q.w);\n\n    obj p1;\n    p1.b= size(ci);\n    p1.s= shape(ci);\n    p1.r= q;\n    p1.c= getCubePos(ci);\n\n\n     for(int k=0;k<getN(p1.s);k++){\n          obj oo=getObj(k,p1);\n#ifndef MPR\n         vec3 ro =rotate(qi,rayPos -oo.c),\n              rd =rotate(qi,rayDir);  \n         vec2  t= iBox( ro,  rd,  oo.b);\n\n         if( minDist>t.x && t.x>0.){\n             minDist=t.x-.0002;\n             minDistNormal= rotate(q,oNor);\n             //int ncoll= getNColl(ci);  \n             minDistMaterial= oo.s>0?float(oo.s)+2.: material(ci); \n             minDistUv=oFuv.yz;\n         }\n#else     \n         float d;\n         int iter;   \n       \n\n         vec2 t= iSupportFunction( rayPos-oo.c, rayDir, oo,oNor);\n         if( minDist>t.x && t.x>0. ){\n             minDist=t.x-.0002;\n             minDistNormal= oNor;\n             minDistMaterial= oo.s>0?float(oo.s)+2.: material(ci);  \n             vec3 lp=rotateInv(q,rayPos-oo.c+t.x*rayDir);\n             minDistUv=lp.xy;\n         }\n#endif    \n         \n     }\n}\n\nvoid renderScene()\n{\n    minDist = 1e30;   \n    for(int i=0;i<(CUBECOUNT);i++)\n    {       \n        //bounding sphere\n        if ( length(cross(getCubePos(i)-rayPos,rayDir))<=length(size(i)))\n        {\n            renderBox(i);\n        }\n    }\n}\n\nvec3 getDiffuse()\n{\n    vec3 difColor;\n    if (minDistMaterial==0.) difColor = texture(iChannel0,rayPos.zx/8.0).xyz; // floor\n    else if(minDistMaterial==1.) difColor =  texture(iChannel1,minDistUv/2.).xyz; // floor\n    else if(minDistMaterial>=2.) difColor = texture(iChannel2,minDistUv/2.).xyz;\n    else difColor=vec3(1,0,0);\n    \n    if(minDistMaterial==3.) difColor = difColor.zyx;\n    if(minDistMaterial==4.) difColor = difColor.yxz;\n    if(minDistMaterial==5.) difColor = difColor.xyz;\n    if(minDistMaterial==6.) difColor = difColor.zxy;\n    if(minDistMaterial==7.) difColor = difColor.yzx;\n    return difColor;\n}\n\nvec3 backGround(vec3 dir,vec3 pos)\n{\n\tfloat f = max(dir.y,0.0)*0.5+0.5;\n\tvec3 color = 1.0-vec3(1,0.85,0.7)*f;\n\tcolor *= dir.x*-0.3+1.0;\n\t\n\tif (dot(sunDir,dir)>0.0) // sun reflected on cubes\n\t{\n\t f = max(length(cross(sunDir,dir))*10.0,1.0);\n\t\t\n\t color += vec3(1,0.9,0.7)*40.0/(f*f*f*f);\n\t}\n\treturn color;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    float a =sin(iTime*.2),d=22.;\n    if(iMouse.z>0.){ a = iMouse.x/iResolution.x*4.-2.; d*=iMouse.y/iResolution.y+.8;}\n\tvec3 campos = vec3(-d*sin(a),25.,-d*cos(a));   \n    vec2 uv= (fragCoord-iResolution.xy*.5)/iResolution.y*.8;\n    vec3 pdir = getRayDir(campos,getCubePos(5), uv); \n\n    rayPos = campos;\n    rayDir=pdir;\n\n    renderScene();\n           \n    if (minDist<1e30)\n    {\n        minDistNormal = normalize(minDistNormal);\n        const vec3 sunColor = vec3(1.0,0.8,0.5)*1.0;\n        const vec3 skyColor = vec3(1.0,1.2,1.5)*0.6;\n        rayPos += rayDir*minDist;\n        vec3 firstHitPos = rayPos;\n        vec3 refdir = reflect(rayDir,minDistNormal);\n        float f = 1.-max(dot(minDistNormal,-rayDir),0.);\n        float fresnel = 0.65*f*f*f*f*f+0.05;\n\n        vec3 difColor =getDiffuse();\n        \n        fragColor = vec4(difColor*skyColor*((minDistNormal).y*0.5+0.5),0.);\n        float suncos = dot((minDistNormal),sunDir);\n        if (suncos>0.0)\n        {\n            // spot sun light pointing on the thrown cube.\n            vec3 v = cross(sunDir,rayPos-vec3(0))/20.;\n            suncos *= max(0.,1.0-dot(v,v));\n            rayDir = sunDir;\n    \t    renderScene();\n\t        if (minDist==1e30) \n            {\n                fragColor.xyz += difColor * suncos * sunColor;\n            }\n        }\n        \n        rayPos = firstHitPos;\n        rayDir = refdir;\n        renderScene();\n        \n        vec3 refColor;\n        if (minDist<1e30)\n        {\n            rayPos += rayDir * minDist;\n            vec3 difColor = getDiffuse();\n            \n            refColor = difColor*(normalize(minDistNormal).y*0.5+0.5);\n        }\n        else\n        {\n            refColor = backGround(rayDir,rayPos);\n        }\n        fragColor.xyz = mix(fragColor.xyz,refColor,fresnel);\n    }\n    else\n    {\n\t\tfragColor = vec4(backGround(pdir,campos),0.0);\n    }\n \n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//------------------------------------\n\nobj _ob1,_ob2;\nvec3 a,b,c,d; //difference simplex\nvec3 a1,b1,c1,d1; //obj1 simplex\nvec3 a2,b2,c2,d2; //obj2 simplex\n\n//-------------------\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\n\nvec3 support(vec3 dir, obj o){\n    const float h=(sqrt(5.)-1.)*.5,h2=h*h;\n    if(o.s==1) //SPHERE\n        return normalize(dir)*(o.b.x);\n    else if(o.s==2) //CONE\n        return  \n             supMax( dir,\n            vec3(normalize(dir.xy)*o.b.z, .5*o.b.z) ,\n            vec3(0.,0,-o.b.z));            \n   else return sign(dir)*o.b; // BOX (DEFAULT)\n} \n\nvec3 supportr(vec3 dir, obj o, mat3 rm){\n    dir=dir*rm;\n    vec3 s= support(dir,  o);\n    return s *transpose(rm)+ o.c ;\n}\n\n//Minkowsky difference support function\nvec3 support(vec3 dir,out vec3  s1, out vec3 s2){\n\n    //mat3 rt = mrot(_ob1.r);\n    vec4 q =_ob1.r;\n    s1 = support(rotateInv(q,dir),_ob1);   \n    s1=  rotate(q, s1 +rotateInv(q,_ob1.c)); \n    \n    q = (_ob2.r);\n    s2 = support(rotateInv(q,-dir),_ob2);\n    s2=  -rotate(q,s2 +rotateInv(q,_ob2.c));\n    \n    return s1+s2;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n// Iq:  https://www.shadertoy.com/view/ttfGWl\nfloat  PointTriDist2(in vec3 p,  in vec3 v0, in vec3 v1, in vec3 v2, out vec3 dir  )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n    if( dot(cross(v10,nor),p0)<0.0 ) dir=  v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    else if( dot(cross(v21,nor),p1)<0.0 ) dir= v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    else if( dot(cross(v02,nor),p2)<0.0 ) dir= v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    else dir= p - nor*dot(nor,p0)/dot2(nor);\n    return dot2(p-dir);  \n}\n\n\nint MPRPenetration(obj o1 , obj o2 , out float depth, out vec3 dir, out vec3 pos)\n{\n    \n    int res=0;\n    _ob1 =o1;\n    _ob2 =o2;\n    \n    dir= vec3(0,1,0);\n    // Phase 1: Portal discovery\n    //---------------------------------\n\n   \n    // vertex a is center of portal\n    a1=_ob1.c;a2=-_ob2.c; a= a1+a2; \n    \n    if (a==vec3(0)) {a1+= vec3(1e-3,0,0); a+=vec3(1e-3,0,0);}\n\n    // vertex b = support in direction of origin\n\tdir= -normalize(a);  \n    b = support(dir,b1,b2);\n\n    // test if origin isn't outside of b\n    if ( dot(b, dir) <=0.) return -1;\n\n    // vertex c\n\tdir = cross(a, b);\t\t\t\t\t \t\t\t\t\t   \n    if (length(dir)==0.){\n        if (b == (_ob1.c-_ob2.c)) {\n            // origin lies on b\n            // Touching contact on portal's b - so depth is zero and direction\n            // is unimportant and pos can be guessed\n            depth = 0.;\n            dir= vec3(0,1,0); \n            pos=(b1+b2)*.5;\n            return 1;\n        }\n        else {\n            // Origin lies on a-b segment.\n            // Depth is distance to b, direction also and position must be\n            // computed\n             pos=(b1+b2)*.5;\n             depth = length(b);\n             dir =normalize(b);\n             return 2;\n        }\n    }\n    \n\tc= support(normalize(dir),c1,c2);\n    if ( dot(c, dir) <=0.) return -1;\n\n    // vertex d direction\n\tdir= normalize(cross(b-a,c-a));\n\n    // it is better to form portal faces to be oriented \"outside\" origin\n    if (dot(dir, a) > 0.){\n        vec3 t =b; b=c;c=t; t =b1; b1=c1;c1=t; t =b2; b2=c2;c2=t;//swap\n        dir *=-1.;\n    }\n        \n    int iter=0;\n    while ( iter <20){\n        \n\t\td= support(dir,d1,d2);        \n        if (dot(d, dir) <=0.) return -1;\n       \n        // test if origin is outside (b, a, d) - set c as d and continue\n        if ( dot(cross (b,d), a)  < 0. ){c=d;c1=d1;c2=d2; }\n        // test if origin is outside (d, a, c) - set b as d and continue\n        else if (dot(cross (d,c), a) < 0. ){ b=d;b1=d1;b2=d2; }\n        else break;\n        \n        dir =normalize(cross( b-a, c-a));\n        iter++;\n    }\n       \n    \n    // Phase 2: Portal refinement\n    //---------------------------------\n    vec3 v4,v41,v42;\n    iter=2;   \n    bool portalReachTolerance=false;\n    bool ph2=false;\n    while (iter<20){\n        \n        // compute direction outside the portal (from v0 throught v1,v2,v3 face)\n        dir= normalize(cross( c-b, d-b));\n\n        // test if origin is inside the portal\n        if ( !ph2 &&( dot(dir, b)>= 0. || iter>15)) {ph2=true; continue;}\n\n        // get next support point\n        v4 = support(dir,v41,v42);\n\n        // find the smallest dot product of dir and {a-v4, b-v4, c-v4}\n        float dv1 = dot(a, dir);\n        float dv2 = dot(b, dir);\n        float dv3 = dot(c, dir);\n        float dv4 = dot(v4, dir);\n        portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3)  <= 1e-4);\n\n        // reached tolerance \n        if (portalReachTolerance && ph2){\n            break;\n        }\n        // test if v4 can expand portal to contain origin and if portal\n        // expanding doesn't reach given tolerance\n        if ( dot(v4, dir)<0.  )  return -1;\n\n\n        // expandPortal( v4);\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a).     \n        vec3 v4a =cross( v4,a);   \n        if (dot(b, v4a) > 0.) {\n            if(dot (c, v4a) > 0.) {b=v4;b1=v41;b2=v42;}\n            else  {d=v4;d1=v41;d2=v42;}\n        }\n        else{\n            if(dot(d, v4a) > 0.)  {c=v4;c1=v41;c2=v42;}\n            else {b=v4;b1=v41;b2=v42;}\n        }\n        iter++;\n    }\n\n    // reached tolerance -> find penetration info\n    depth = PointTriDist2(vec3(0) ,b,c,d, dir);\n    depth = sqrt(depth);\n    if (depth==0.){\n        // If depth is zero, then we have a touching contact.\n        // So following findPenetrTouch(), we assign zero to\n        // the direction vector (it can actually be anything\n        // according to the decription of ccdMPRPenetration\n        // function).\n        dir=vec3(0,1,0);\n    }else{\n        dir=normalize(dir);\n    }\n\n    // barycentric coordinates:\n    //findPos(pos);\n    float k0,k1,k2,k3, sum;\n\n    dir= normalize(cross( c-b, d-b));\n\n    // use barycentric coordinates of tetrahedron to find origin    \n    k0 = dot(cross(b,c),d);\n    k1 = dot(cross(d,c),a);\n    k2 = dot(cross(a,b),d); \n    k3 = dot(cross(c,b),a);  \n\n    sum = k0 + k1 + k2 + k3;\n    if (sum<=0.){\n        k0 = 0.;\n        k1 = dot(cross(b,c),dir);  \n        k2 = dot(cross(d,b),dir);  \n        k3 = dot(cross(b,c),dir);   \n        sum = k1 + k2 + k3;\n    }\n\n    vec3 p1= a1*k0+b1*k1+c1*k2+d1*k3;\n    vec3 p2= a2*k0+b2*k1+c2*k2+d2*k3;\n\n    pos=.5*(p1-p2)/sum;\n\n    return 0;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int ci = int(fragCoord.x);\n    int cj = int(fragCoord.y);\n    \n    if (ci> CUBECOUNT*2) discard;\n    if (cj> CUBECOUNT) discard;\n    \n    ci= ci % CUBECOUNT;\n    int k= 0;\n\n    fragColor = vec4(0);\n    \n     if(length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj))) return;\n    \n    \n    obj p1,p2;\n    p1.b= size(ci);\n    p1.s= shape(ci);\n    p1.r= getCubeQuat(ci);\n    p1.c= getCubePos(ci);\n    p2.b= size(cj);\n    p2.s= shape(cj);\n    p2.r= getCubeQuat(cj);\n    p2.c= getCubePos(cj);\n\n    float idepth,d=0.;\n    vec3 idir,ipos,pos=vec3(0),dir=vec3(0);\n    for(int k1=0;k1<getN(p1.s);k1++)\n    for(int k2=0;k2<getN(p2.s);k2++){\n\n        obj o1,o2;      \n        o1=getObj(k1,p1);\n        o2=getObj(k2,p2);\n        \n       bool intersect =  MPRPenetration( o1 ,  o2 , idepth,  idir,   ipos )>=0;\n        if(intersect) {\n            fragColor+=vec4(ipos*idepth,idepth);\n            dir=idepth*idir;\n            \n        }\n    \n   } \n   if(fragColor.w>0.) {\n       if(int(fragCoord.x)<CUBECOUNT) fragColor.xyz/=fragColor.w;\n       else fragColor.xyz= -normalize(dir/fragColor.w);\n    \n   }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec3 pos;\nvec4 quat;\nvec3 vel;\nvec3 rotvel;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int pixelx = int(fragCoord.x);\n    int pixely = int(fragCoord.y);\n    \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    if (pixelx>CUBECOUNT) discard;\n    if (pixely>=4 || pixely<2) discard; // just output velocity and rotational velocity\n    int cubei = pixelx;\n    \n    \n    pos = getCubePos(cubei);\n    quat = getCubeQuat(cubei);\n    vel = getCubeVel(cubei);\n    rotvel = getCubeRotVel(cubei);\n    \n    if (cubei>=STATIC_CUBE_COUNT)\n    {\n    // apply forces (just the changes)\n    for(int i=0;i<int(CUBECOUNT)-1;i++)\n    {\n        int ci,cj;\n        float scaler;\n        if (i<cubei)\n        {\n\t        ci = cubei;\n            cj = i;\n            scaler  = 1.0;\n\t\t // if the other cube cannot be pushed away, because its's the floor or other unmovable, \n          // this one moves double amount\n            if (cj< STATIC_CUBE_COUNT) scaler = 2.0; \n        }\n        else\n        {\n           ci = i+1;\n           cj = cubei;\n           scaler = -1.0; // applying the opposite forces on the cube pair\n        }\n        if (!(length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj)) && cj!=0)) // bounding check\n        {\n            vec3 forcepos = getCollPos(ci,cj).xyz;\n            if (forcepos.x!=0.0)\n            {\n\t            vec3 force = getForce(ci,cj).xyz;\n                if(length(force)>MF) force*=MF/length(force);\n                \n                force *= scaler;\n                vel += dt*force;\n                rotvel -= dt* cross(forcepos-pos,force)/RotationalImmobilityTensor;\n            }\n        }\n    }\n    \n\n    }\n    \n    fragColor = vec4(vel, 0.0);\n    if (pixely==3) fragColor = vec4(rotvel, 0.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec3 getCubeVelQP(int ci,vec3 querypos)\n{\n    return cross(querypos-getCubePos(ci),\n    \n    getCubeTempRotVel(ci)) + getCubeTempVel(ci);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  \n    int ci = int(fragCoord.x);\n    int cj = int(fragCoord.y);\n    \n    if (cj>=ci) discard;\n    if (ci>=CUBECOUNT) discard;\n    \n    if ((length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj))&& cj!=0))  // bounding check\n    {\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n\n    vec3 totalForce  =  getForce(ci,cj).xyz;\n    vec3 collpos =   getCollPos(ci,cj).xyz;\n\n\n    if (collpos.xyz!=vec3(0.)) // x==0 means no collision at the force denoted by this pixel\n    {\n        vec3 veldiff = getCubeVelQP(cj,collpos)-getCubeVelQP(ci,collpos);\n\n        vec3 collisNormal = getCollNorm(ci,cj).xyz;\n\n        totalForce += veldiff*elasticConstant;\n\n        float perpart = dot(collisNormal,totalForce);\n        vec3 tangentialpart = totalForce-collisNormal*perpart;\n\n        if (length(tangentialpart)>perpart*FrictionConstant)\n        {\n            tangentialpart *= (perpart*FrictionConstant)/length(tangentialpart);\n            totalForce = tangentialpart + collisNormal*perpart;\n        }\n\n        if (perpart<0.0) totalForce = vec3(0.);\n        \n    }\n    else totalForce= vec3(0.);\n     \n    if (INIT) totalForce = vec3(0.);\n    fragColor = vec4(totalForce*FS,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvec3 pos;\nvec4 quat;\nvec3 vel;\nvec3 rotvel;\n\n\nvec3 rotateAxis(vec3 axis,vec3 v)\n{\n    float len = length(axis);\n    if (len==0.0) return v;\n    else  return  v*cos(len) + v*axis/len*axis/len * (1.0-cos(len)) + cross(v,axis/len)*sin(len);\n}\n\nvec4 getRotation(vec3 x,vec3 y,vec3 z){\n    // convert back to quaternion\n\tfloat trace = x.x + y.y + z.z;\n    vec4 q;\n\tif( trace > 0.0 ) {\n\t\tfloat s = 0.5 / sqrt(trace+ 1.0);\n\t\tq=vec4(( z.y - y.z ) * s,( x.z - z.x ) * s,( y.x - x.y )*s, 0.25 / s);\t\t\n\t} else {\n\t\tif ( x.x > y.y && x.x > z.z ) {\n\t\t    float s = 2.0 * sqrt( 1.0 + x.x - y.y - z.z);\n\t\t\tq =vec4( 0.25 * s,(x.y + y.x ) / s,(x.z + z.x ) / s,(z.y - y.z ) / s);\n\t\t} else if (y.y > z.z) {\n\t\t\tfloat s = 2.0 * sqrt( 1.0 + y.y - x.x - z.z);\n\t\t\tq = vec4((x.y + y.x ) / s,0.25 * s, (y.z + z.y ) / s,(x.z - z.x ) / s);\n\t\t} else {\n\t\t\tfloat s = 2.0 * sqrt( 1.0 + z.z - x.x - y.y ); \n\t\t\tq= vec4((x.z + z.x ) / s,(y.z + z.y ) / s,0.25 * s,(y.x - x.y ) / s);\n\t\t}\n\t}   \n    return normalize(q); \n}\n\nvec4 rotateRotation(vec4 q,vec3 axis) {\n    vec3 x,y,z; // conversion to 3 perpendicular vectors, and rotation\n\n    x = rotateAxis(axis,rotate(q,vec3(1.0,0.0,0.0)));\n    y = rotateAxis(axis,rotate(q,vec3(0.0,1.0,0.0)));\n    z = rotateAxis(axis,rotate(q,vec3(0.0,0.0,1.0)));\n    return getRotation(x,y,z);\n} \n\nvoid initScene(int cubei)\n{\n        vel = vec3(0.,0.,0.);\n        rotvel = vec3(0.,0.,0.);\n        quat = vec4(0.0,0.0,0.0,1.0);\n        if (cubei<1) // static floor\n        {\n            pos = vec3(0,-1,0);\n\n            vec3 ro = vec3(SLOPE,0,0.);\n            quat = rotateRotation(normalize(vec4(0.0,0.0,0.0,1.0)),ro);\n            return;    \n\n        }\n    \n    \tcubei-=1;\n        float cubeif = float(cubei);\n    \tvec3 ro = vec3(PI*.5,0.,0.);\n    \tpos = vec3(-14.,4.1,-0.) + vec3(cubei,0,0)*2.1 ;\n    \n        if(cubei%2==0) quat = rotateRotation(normalize(vec4(0.0,0.0,0.0,1.0)),ro);\n    \n        vel = vec3(0 ,0.0,0.00);\n        rotvel = vec3(0,.0,0)*float(cubei%2*2-1);// vec3(cubeif*-0.0001*cos(float(iFrame)),0.0,cubeif*-0.0001); // randomize start setup        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int pixelx = int(fragCoord.x);\n    int pixely = int(fragCoord.y);\n    \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    if (pixely>=4) discard;\n    if (pixelx>=(CUBECOUNT)) discard;\n    int cubei = pixelx;\n    \n    \n    pos =  getCubePos(cubei);\n    quat = getCubeQuat(cubei);\n    vel = getCubeVel(cubei);\n    rotvel = getCubeRotVel(cubei);\n    int ncoll=0;\n    \n    if (cubei>=STATIC_CUBE_COUNT)\n    {\n        // apply forces (just the changes)\n    \n        for(int i=0;i<CUBECOUNT-1;i++)\n        {\n            int ci,cj;\n            float scaler;\n            if (i<cubei)\n            {\n                ci = cubei;\n                cj = i;\n                scaler  = 1.0;\n             // if the other cube cannot be pushed away, because its's the floor or other unmovable, \n              // this one moves double amount\n                if (cj<STATIC_CUBE_COUNT) scaler = 2.0; \n            }\n            else\n            {\n               ci = i+1;\n               cj = cubei;\n               scaler = -1.0; // applying the opposite forces on the cube pair\n            }\n\n           if (!(length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj)) && cj>=STATIC_CUBE_COUNT)) // bounding check\n            {\n                vec3 forcepos = getCollPos(ci,cj).xyz;\n                if (forcepos!=vec3(0))\n                {\n                    vec3 force = getForce(ci,cj);\n                      if(length(force)>MF) force*=MF/length(force);\n                    ncoll++;\n                    // add repulsive force\n                    vec4 collisnormal = getCollNorm(ci,cj);\n                   force += collisnormal.xyz*collisnormal.w*repulsion;\n\n\n                    force *= scaler;\n                    vel += dt*force;\n                    //vec3 t =normalize(cross(forcepos-pos,force));\n                    //float ri = max(.1, dot(RotationalImmobilityTensor,t*t));\n                    rotvel -= dt*cross(forcepos-pos,force)/(RotationalImmobilityTensor);\n                }\n            }\n        }\n    \n        // move by adding velocity to position, and rotate\n        pos += dt*vel;\n        quat = rotateRotation(quat,rotvel*dt);\n        vel.y += dt*gravity;\n        if(length(vel)>2.) vel*=.98;\n    } else if(cubei==1){\n        pos.y+=.01*dt;\n    }\n\n    if(INIT)  initScene(cubei);\n    \n    fragColor = vec4(pos, ncoll);\n    if (pixely==1) fragColor = quat;\n    if (pixely==2) fragColor = vec4(vel, 0.0);\n    if (pixely==3) fragColor = vec4(rotvel, 0.0);\n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CUBECOUNT 20\n#define STATIC_CUBE_COUNT 2\n#define INIT (iFrame%(60*30)==0)\n\nconst float PI = 3.141592653;\nconst float gravity = -0.0003;\nconst float repulsion = 0.03;\nconst float FrictionConstant = 0.4;\nconst float elasticConstant = 0.05;\nconst float FS= .95;\nconst float MF=.01;\nconst float dt=1.; \nconst vec3 sunDir = normalize(vec3(0.8,.8,-0.3));\nconst float RotationalImmobilityTensor =(1.8);    // vec3(sz.y*sz.y+sz.z*sz.z,sz.x*sz.x+sz.z*sz.z,sz.x*sz.x+sz.y*sz.y);\n\nvec3  size( int i) { return int(i)==0?vec3(30,1,30): vec3(2);}\nint shape(int i) {return i<1?0:3;}\nfloat material(int i) {return i<1?0.:2.;}\n#define SLOPE 0.\n\nstruct obj{\n    vec3 c; //center\n    vec3 b; //bounding box\n    vec4 r; //rotation quat\n    int s; //shape (0=box,1=sphere,2=cylinder,3=cone, 5=segment)\n};\n\n\n\n//---------------------------------------------\n\nvec4 readTex(sampler2D ch, int cx,int cy)  { return texelFetch(ch,ivec2(cx,cy),0);}\nvec3 getCubePos(sampler2D ch,int ci)       { \n    vec3  p=  readTex(ch,ci,0).xyz;\n    return mod( p+vec3(50),vec3(100.))-vec3(50);\n}\nint  getNColl(sampler2D ch,int ci)         { return int(readTex(ch,ci,0).w);}\nvec4 getCubeQuat(sampler2D ch, int ci)     { return readTex(ch, ci,1).xyzw;}\nvec3 getCubeVel(sampler2D ch,int ci)       { return readTex(ch,ci,2).xyz;}\nvec3 getCubeRotVel(sampler2D ch,int ci)    { return readTex(ch,ci,3).xyz;}\nvec3 getCubeTempVel(sampler2D ch,int ci)   { return readTex(ch,ci,2).xyz;}\nvec3 getCubeTempRotVel(sampler2D ch,int ci){ return readTex(ch,ci,3).xyz;}\n\n#define  getCollPos(ci,cj) readTex(iChannel0, ci,cj).xyz\n#define  getCollNorm(ci,cj) readTex(iChannel0, ci+CUBECOUNT,cj)\n#define  getForce(ci,cj) readTex(iChannel2, ci,cj).xyz\n#define  getCubePos( ci) getCubePos(iChannel3, ci)\n#define  getNColl(  ci) getNColl(iChannel3, ci)\n#define  getCubeQuat( ci) getCubeQuat(iChannel3, ci)\n#define  getCubeTempVel( ci) getCubeTempVel(iChannel1, ci)\n#define  getCubeVel(  ci) getCubeVel(iChannel3, ci)\n#define  getCubeRotVel( ci) getCubeRotVel(iChannel3, ci)\n#define  getCubeTempRotVel( ci) getCubeTempRotVel(iChannel1, ci)\n\n\n\nvec3 rotate(vec4 quat,vec3 v)\n{\n    float sinsqr = (1.0-quat.w*quat.w);\n    if (sinsqr!=0.0)\n    {\n        v=v*quat.w + quat.xyz*((dot(v,quat.xyz)*(1.0-quat.w))*(1.0/sinsqr)) + cross(v,quat.xyz);\n        v=v*quat.w + quat.xyz*((dot(v,quat.xyz)*(1.0-quat.w))*(1.0/sinsqr)) + cross(v,quat.xyz);\n    }\n    return v;\n}\n\nvec3 rotateInv(vec4 quat,vec3 v)\n{\n    quat.xyz*=-1.;\n    return rotate( quat, v);\n}\n\n\n \n#define NOHIT 1e30\nvec3 oFuv; \nvec3 oNor;\n\nint getN(int s){\n    if(s==4) return 3;\n    else if(s==3) return 4;\n    else if(s==5) return 5;\n    else return 1;\n}\n\nobj getObj( int j, obj p){\n obj o;\n o.b=  p.b;\n o.s= p.s;\n o.r= p.r;\n o.c= p.c ;\n if(p.s==3) {\n     o.s=0;\n     o.b= p.b* (j==1 || j==3 ? vec3(1,.15,.15):vec3(.15,.6,.15));\n     o.c +=   (j==1 || j==3)? \n         p.b.y*.6* rotate(o.r,vec3(0,j-2,0)):\n         p.b.x*.85* rotate(o.r,vec3(j-1,0,0));\n }\n  if(p.s==4) {\n     o.s=0;\n     o.b= p.b* (j==1 || j==3 ? vec3(.8,.2,.5):vec3(.2,1,.5));\n     o.c += p.b.x*.8* rotate(o.r,vec3(j-1,0,0));\n }\n   if(p.s==5) {\n     o.s=0;\n     if(j<4){\n         o.b= p.b* (vec3(.2,.2,1));\n         o.c += p.b.x*.7* rotate(o.r,vec3(0,(j/2)*2-1,0));\n         o.c += p.b.y*.7* rotate(o.r,vec3((j%2)*2-1,0,0));\n         //o.c += -p.b.z*.5* rotate(o.r,vec3(0,0,1));\n     }else{\n         o.b= p.b* (vec3(1,1,.2));\n     }\n }\n return o;\n}\n\n\n//----------------------------------\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}