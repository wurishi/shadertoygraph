{"ver":"0.1","info":{"id":"lXcGW8","date":"1716395561","viewed":100,"name":"Iridescent locked rings","username":"Peregrine","description":"A little study in iridescence.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rings","glow","iridescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793238\n#define TAU (2. * PI)\n#define EPSILON 0.01\n\n#define SMOOTHINESS .4\n#define t iTime\n\n#define min2(a, b) (a.x < b.x ? a : b)\n#define pos(x) (x * .5 + .5)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sat(x) clamp(x, 0., 1.)\n\n// IQ's cosine gradient palette\nvec3 palette(float x) {\n  vec3 a = vec3(.5, .5, 0.), // fire!\n       b = a,\n       c = vec3(.1, .5, 0.),\n       d = vec3(0.);\n  return a + b * cos(TAU * (c * x + d));\n}\n\n// IQ's SDF functions\nfloat smooth_union(float a, float b, float k) {\n  float h = sat(pos((b - a) / k));\n  return mix(b, a, h) - k * h * (1. - h);\n}\n\n\nfloat sdf_torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n\nfloat rand(float i){\n    return fract(sin(dot(vec2(i, i), vec2(32.9898,78.233))) \n                 * 43758.5453);\n}\n\nvec2 sdf(vec3 p) {\n  vec2 di = vec2(120., -1.);\n  vec3 p2 = p;\n  \n  p.yz *= rot(t);\n  p.xy *= rot(t);\n  p.xz *= rot(t * PI / 2. + PI / 3.);\n  float ring_1 = sdf_torus(p, vec2(1., .15));\n  p.yz *= rot(t * PI / 2. + PI / 5.);\n  float ring_2 = sdf_torus(p, vec2(1., .15));\n  p.xy *= rot(t * PI / 2. - PI / 7.);\n  float ring_3 = sdf_torus(p, vec2(1., .15));\n  di = min2(di, vec2(smooth_union(ring_1, smooth_union(ring_2, ring_3, SMOOTHINESS), SMOOTHINESS), 1.));\n  return di;\n}\n\nvec3 glow;\nvec2 trace(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  vec2 di;\n  float td = 0.;\n  \n  glow = vec3(0.);\n  for (int i = 0; i < 128 && td < 120.; i++) {\n    di = sdf(p);\n    if (di.x < EPSILON)\n      return vec2(td, di.y);\n    p += di.x * rd;\n    glow += pos(normalize(p)) * (1. - sat(di.x/.4)) * .05;\n    td = distance(ro, p);\n  }\n  \n  return vec2(-1., -1.);\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * sdf(p + e.xyy).x +\n    e.yxy * sdf(p + e.yxy).x +\n    e.yyx * sdf(p + e.yyx).x +\n    e.xxx * sdf(p + e.xxx).x\n  );\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(0., 0., -3.),\n       rd = normalize(vec3(uv, 1.)),\n       lo = ro;\n  \n  vec2 tdi = trace(ro, rd);\n  if (tdi.x > 0.) {\n    vec3 p = ro + rd * tdi.x;\n    vec3 n = get_normal(p);\n    \n    // Varun Vachar's iridescence effect\n    vec3 cd = normalize(ro - p),\n         ld = normalize(lo - p),\n         reflection = reflect(rd, n),\n         perturbation = .05 * sin(p * 10.);\n    \n    vec3 iridescence = palette(dot(n + perturbation, cd) * 2.);\n    float specular = sat(dot(reflection, ld));\n    specular *= .1 * pow(pos(sin(specular * 20. - 3.)) + .1, 32.);\n    specular += .1 * pow(sat(dot(reflection, ld)) + .3, 8.);\n    float shadow = pow(sat(dot(n, vec3(0., 1., 0.)) * .5 + 1.2), 3.);\n    \n    return iridescence * shadow + specular + glow;\n  }\n  \n  return vec3(0.) + glow;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = vec2(fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  vec3 c = render(uv);\n  \n  fragColor = vec4(sat(c), 1.);\n}","name":"Image","description":"","type":"image"}]}