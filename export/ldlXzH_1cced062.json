{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Refactoring of volumetric sort code @ iquilezles.org\n// Uses arithmetic instead of bitwise logic (for webgl)\n// References :\n// https://iquilezles.org/articles/volumesort\n// Number printing code https://www.shadertoy.com/view/4sf3RN\n\nconst float DEG_TO_RAD = 3.14159265359 / 180.0;\n// Font params\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\n// There's probably a better way to make this faster \n// by using the bvec masks directly and min max\n// As yet, it is sufficient for culling purposes.\nfloat calcOrder( const vec3 dir ) // in view vec, out 0 - 47\n{\n \tvec4 sg = vec4(lessThan(dir,vec3(0.0)), 0.0);\n\tvec3 a = abs(dir);\n\tbvec3 dax = not(greaterThan(a.yxx,a.zzy)); // Dom axis\n\tconst vec4 sft = vec4(4.0,2.0,1.0,8.0);    // Equivalent of << shifts\n    vec4 signs = all(greaterThan(a.xx,a.yz))\n\t\t? vec4(dax.x ? sg.xyz :sg.xzy,float(dax.x))\n\t\t: all(greaterThan(a.yy,a.xz))\n\t\t\t? vec4(dax.y ? sg.yxz:sg.yzx,float(dax.y)+2.0)\n\t\t\t: vec4(dax.z ? sg.zxy:sg.zyx,float(dax.z)+4.0);\n\tsigns*=sft;\n    return signs.x+signs.y+signs.z+signs.w; //hadd\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\nfloat PrintValue(const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\treturn PrintValue((gl_FragCoord.xy - vPixelCoords) / vFontSize, fValue, fMaxDigits, fDecimalPlaces);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 dir = ray_dir( 90.0, iResolution.xy, fragCoord.xy );\n\tvec3 mdir = ray_dir( 90.0,iResolution.xy, iMouse.xy );\n\tmat3 rot = rot3xy(-iMouse.yx/32.0);\n\tmdir = rot * mdir;\n\tdir = rot * dir;\n\tfloat sd = calcOrder(dir);\n\tfloat msd = calcOrder(mdir);\n\tfloat fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;\n\tvec3 vColour = vec3(0.0);\n\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(16.0, 30.0);\n\t\n\tif(iMouse.x > 0.0)\n\t{\n\t\t// Print Quadrant\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(.0, 6.0);\n\t\tfloat fValue2 = msd;//iMouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = .0;\n\t\tfloat fIsDigit2 = PrintValue(vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t}\n\tif (msd==sd) {\n\t\tsd= (sd/48.0);\n\t\tfragColor = mix( vec4(vColour,1.0),vec4(1.0,sd,sd,1.0),0.5);\n\t}else{\n\t\tsd= (sd/48.0);\n\t\tfragColor = mix( vec4(vColour,1.0),vec4(sd,sd,sd,1.0),0.5);// mix(vec4( f*n+p/250.0,1.0),vec4(f),.714);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlXzH","date":"1397001516","viewed":331,"name":"Quadrants of a cube","username":"Panoptics","description":"Calculate the quadrant of a cube that the view direction vector intersects. Use your mouse to highlight a quadrant. Can be used as a very cheap test to eliminate expensive shader paths or cull object lists (eg point cloud data).\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cubemapping"],"hasliked":0,"parentid":"","parentname":""}}