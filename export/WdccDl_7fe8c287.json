{"ver":"0.1","info":{"id":"WdccDl","date":"1601948381","viewed":159,"name":"raymarching belgian glitch","username":"snolot","description":"Try to makesome raymarching with post effects","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","posteffect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// effect from TefK sample 'https://www.shadertoy.com/view/4lGBWV'\n\n\n#define PI 3.14159265358979323846264338327950288\n#define DEG_TO_RAD (PI / 180.0)\n\n#define BEAT (time*170.0/60.0)\n#define time iTime\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat accum;\nfloat seed;\n\nfloat fractsin(float v){\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand(){\n  seed=fractsin(seed);\n  return seed;\n}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi){\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r)); }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//-------------------------------------------------\nvec2 sdBox(vec3 p,vec3 r, float id){\n    p=abs(p)-r;\n    return vec2(max(max(p.x,p.y),p.z),id);\n} \n\n//---------------------------------\nfloat g, tt;\n\nvec2 map(in vec3 pos)\n{\n    vec2 d = vec2(1e10, 0.0);\n    float b= asin(sin(pos.z*.2 +  tt));\n    //float an = sin(iTime);\n\t\n    for(int i=0;i<3;i++){\n        pos=abs(pos);\n        pos.xy*=r2(.000148);\n        pos.yz*=r2(iTime*sin(pos.x*.25)*.00025);\n    }\n    \n\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q = rotate_x(q, PI * iTime * .25);\n    q = rotate_y(q, -PI * iTime * .35);\n    q = rotate_z(q, -PI * iTime * .5);\n    \n    vec2 d1 = sdBox(q, vec3(0.6,0.5,0.6), .5 );\n    vec2 d2 = sdBox(q, vec3(0.7,0.1,0.7), .5 ); \n    vec2 dt = max(-d1,d2);\n    \n    //g+=0.1/(.01+d1.x*d1.x*999.) * sin(tt  * .3);\n    //g-=0.1/(0.1*dt.x*dt.x*(20.-abs(sin(abs(q.x*.1)-tt*3.))*1.7));\n    \n    d = d.x < dt.x  ? d : dt;\n    \n    q = rotate_y(q,  -PI * iTime * .25);\n    \n    vec2 d3 = sdBox(q, vec3(0.5,0.5,0.5), .3 );\n    vec2 d4 = sdBox(q, vec3(0.6,0.1,0.6), .3 ); \n    dt = max(d3,d4);\n    vec2 d5 = sdBox(q, vec3(0.4,0.8,0.4),  .5 );\n    vec2 dt2 = max(-d5, dt);\n    g+=(0.1/(.01+d5.x*d5.x*999.) * sin(iTime  * .5));\n    d = d.x < dt.x  ? d : dt2;\n    \n    dt = max(-d5,d);\n\t\n    d = d.x < dt.x  ? d : dt;\n    \n    q = rotate_z(q, PI * iTime * .5);\n    vec2 d6 = sdBox(q, vec3(.3,0.1, .3), .7 );\n    \n    \n    d = d.x < d6.x  ? d : d6;\n    \n    return d;\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tvec2 h = map( ro + rd*t );\n        res = min( res, k*h.x/t );\n        t += clamp( h.x, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 glitch(vec2 v){\n    \n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-3.0*mod(BEAT,8.0))-0.01)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.y += .2*tan(-.5*(iTime+1.4*sin(iTime*.8+.05))+.6*fragCoord.y/iResolution.y);\n    \n    tt=mod(iTime,62.8318);\n    \n   vec3 tot = vec3(.5,0.0,0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \t\t\n        p = glitch(p);\n        vec3 ro = vec3(0.0,2.5,4.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.6),-2.5));\n\n        vec2 t = vec2(.1);\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t.x*rd;\n            vec2 h = map(p);\n            if( abs(h.x)<0.001 || t.x>11.0 ) break;\n            t.x+=h.x;t.y=h.y;\n        }\n\n        vec3 col = vec3(0.0);\n\t\t\n        \n        if( t.x<11.0 )\n        {\n            vec3 _col;\n            \n            if(t.y == .3)\n                _col = vec3(1., .7, 0.0);\n            else if(t.y == .5)\n                _col = vec3(1., 0.0, 0.0);\n            else if(t.y == .7)\n                _col = vec3(0.0, 0.0, 0.0);\n            \n            vec3 pos = ro + t.x*rd;\n            vec3 nor = calcNormal(pos);\n            //vec3 refl = reflect(rd, nor);\n            //vec3 r = texture(iChannel0,refl).rgb;\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + (_col )  *dif*sha  + g *.005 ;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\t\n\tfragColor = vec4( tot, 1.0 );\n    \n    fragColor.rgb *= smoothstep( 1.5, 0.4, length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n    vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n    fragColor.rgb = mix( fragColor.rgb*mix( vec3(1), grunge, .2 ), grunge*vec3(.3,1,.6), .02 );\n    fragColor.rgb *= 1.+.4*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    fragColor.rgb *= mix( 1., 1.8, smoothstep(.0,.3,cos(iTime/7.)) );    \n    fragColor.rgb = max(vec3(0),fragColor.rgb-.02);\n}","name":"Image","description":"","type":"image"}]}