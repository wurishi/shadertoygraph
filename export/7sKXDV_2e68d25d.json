{"ver":"0.1","info":{"id":"7sKXDV","date":"1635350409","viewed":105,"name":"49/49","username":"tono","description":"for my little friend ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["49"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//part 1 \n//\n\n//--------utill---------\nfloat pi = acos(-1.);\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo(vec3 p , vec3 s){p = abs(p)-s;return max(p.x,max(p.y,p.z));}\n//float bar(vec2 p , vec2 s){p = abs(p)-s;return max(p.x,p.y);}\nfloat bar(vec2 p,vec2 s,float r){p-=clamp(p,-s,s);return length(p)-r;}\nvec2 min2(vec2 a,vec2 b){if(a.x < b.x){return a;}return b;}\n#define TT(x,y) floor(x)+pow(fract(x),y)\nfloat rand(vec3 p){p  = fract( p*0.3183099+.1 );p *= 17.0;return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );}\nfloat noise(vec3 p){vec3 fp = floor(p);vec3 fs = fract(p);vec3 sf = vec3(1.,0.,0.); float a = rand(fp);float b = rand(fp + sf);float c = rand(fp + sf.yxz);float d = rand(fp + sf.xxz);float e = rand(fp + sf.yyx);float f = rand(fp + sf.xyx);float g = rand(fp + sf.yxx);float h = rand(fp + sf.xxx); vec3 u = smoothstep(0.,1.,fs); return mix(mix(mix(a,b,u.x),mix(c,d,u.x),u.y),mix(mix(e,f,u.x),mix(g,h,u.x),u.y),u.z);}\n//point light\nvec3 lightEffect(vec3 mat,float lPower,vec3 N,vec3 rd ,vec3 lightPos, vec3 lightDir,vec3 lightCol,vec3 pos,float shadow)\n{\n    vec3 col = vec3(0.);\n    float surfToLight = length(lightPos - pos);\n    vec3 surfToLightDir = normalize(pos - lightPos);\n    float range = clamp(dot(lightDir , surfToLightDir),0.,1. );\n    \n    float attenuation = 1./(1. + pow(surfToLight,2.));\n    float diff = max(0.,dot(N,lightDir) - range) * attenuation * lPower;\n    col += diff * lightCol * (attenuation ) + mat * diff;\n\n    float sp = max(0.,dot(rd,reflect(-lightDir,N)) - range) * attenuation;\n    sp = pow(sp,1.5);\n    col += sp * vec3(1.);\n    float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 1.) * 1. * attenuation;\n    col += rim * diff * mat;\n    col -= shadow;\n\n    return col;\n}\n//----------------------\n//-------------------------------------------\n//walk\n\tfloat walk(vec3 p){\n        float gtime = iTime;\n        float sig = sign(p.z);\n        float l = 1.;\n        p.x += sig/2. - 1.4;\n        l += floor((gtime - sig/2.)/2. );\n        float s = 2.;\n        p.x -=s*clamp(floor(p.x/s + .5),-l,l);\n        \n        //p.x = mod(p.x,1.)-.5;\n        p.y -=1.8;\n        vec3 wp = p;\n        wp.x += .01;\n        p.x -= clamp(p.x,-.15,.1);\n        p.z = abs(p.z)-.3;\n        \n        float o = length(p)-.15 - max(0.,sin(p.x/2.-3.2 ));\n        o=max(o,p.y-.1);\n        o = max(o,-(length(wp.xy)-.04));\n        return o;\n    }\n\tvec2 road(vec3 p)\n    {\n        vec2 o = vec2(bar(p.yz-vec2(12.,0.),vec2(10.,1.),.2),0.);\n        o.x = max(o.x,-walk(p));\n        if(o.x < .01){\n        \to.x+=noise(p*100.)/195.;\n        }\n        return o;\n    }\n\tvec2 lead(vec3 p)\n    {\n        float gtime = iTime;\n        vec2 o = vec2(10.,1.);\n        p.x += gtime;\n        p.yz *= rot(sin(gtime*10.)/10.);\n        p.y += sin(-gtime*pi + pi/2. + p.x)/12.+.1;\n      //  p.xy *= rot(pi/4.);\n        p.xy *= rot(-sin(sin(p.x/10.)-.02)+pi/4.);\n       // p.xy *= rot(-smoothstep(0.,-3.,p.x));\n        vec3 lp = p;\n        float l = 30.;\n        p.x -= l;\n        p.yz *= rot(p.x*13.3);\n        \n        p.yz = abs(p.yz)-.02;\n        p.x -= clamp(p.x,-l,l*2.);\n        \n        o.x = length(p)-.02;\n        lp.yz *= rot(2.3);\n        lp.x += 0.2;\n        lp.x -= clamp(lp.x,-.03,.03);\n        o.x = min(o.x,length(vec2(length(lp.xy)-.2,lp.z))-.03);\n        if(o.x < 0.01)\n        {\n            o.x -= noise(p * 40.)/390.;\n        }\n        return o;\n    }\n    vec2 map1(vec3 p)\n    {\n        float gtime = iTime;\n        vec2 o = vec2(10.);\n        p.x -= TT((gtime+.5),1.5);\n\t\to = min2(o,road(p));\n        o = min2(o,lead(p));\n        return o;\n    }\n\n    vec2 march1(vec3 cp , vec3 rd)\n    {\n        float depth = 0.;\n        for(int i = 0 ; i< 99 ; i++)\n        {\n            vec3 rp = cp + rd * depth;\n            vec2 d = map1(rp);\n            if(abs(d.x) < 0.009)\n            {\n                return vec2(depth,d.y);\n            }\n            if(depth > 30.)break;\n            depth += d.x;\n        }\n        return vec2(-depth , 0.);\n\n    }\n\n    float shadowmarch1(vec3 cp , vec3 rd)\n    {\n        float depth = 0.;\n        for(int i = 0 ; i< 256 ; i++)\n        {\n            vec3 rp = cp + rd * depth;\n            vec2 d = map1(rp);\n            if(d.x < 0.01)\n            {\n                return -1.;\n            }\n            if(depth > 60.)break;\n            depth += d.x;\n        }\n        return 1.;\n    }\n\tvec3 getMat1(vec3 pos,float id)\n    {\n        vec3 col = vec3(1.);\n        if(id == 0.)\n        {\n            col = vec3(0.6);\n        }else if(id == 1.){\n        \tcol = vec3(1.5,0.3,0.);\n        }\n        return col;\n    }\n    vec4 scene1(vec3 cp,vec3 target,vec2 fragCoord) {\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        p.y -= 0.2;\n        vec3 col = vec3(0.);\n        vec3 cd = normalize(vec3(target - cp));\n        vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n        vec3 cu = normalize(cross(cd,cs));\n        float fov = 2.5;\n        vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n        vec2 d = march1(cp,rd);\n        if( d.x > 0.)\n        {\n            vec2 e = vec2(1.0, -1.0) * .003;\n            vec3 pos = cp + rd * d.x;\n            vec3 N = normalize(\n                      e.xyy * map1(pos + e.xyy).x +\n                      e.yyx * map1(pos + e.yyx).x +\n                      e.yxy * map1(pos + e.yxy).x +\n                      e.xxx * map1(pos + e.xxx).x);\n            vec3 lightPos = vec3(0.,-1.5,0.);\n            vec3 lightDir = vec3(0.,-1.,0.);\n            vec3 lightCol = vec3(0.,1.,1.);\n            float lpower = 3.;\n            float shadow = step(shadowmarch1(pos + N*.01,lightDir),0.);\n            vec3 mat = getMat1(pos,d.y);\n            //vec3 lightEffect(vec3 mat,float lPower,vec3 N,vec3 rd ,vec3 lightPos, vec3 lightDir,vec3 lightCol,vec3 pos,float shadow)\n            col = lightEffect(mat,lpower,N,rd ,lightPos, lightDir,lightCol,pos,shadow);\n            float t = 1.-exp(-.001 * d.x * d.x * d.x);\n            col = mix(col,vec3(0.),t);\n        }\n        //col = pow(col,vec3(.4545));\n        return vec4(col,abs(d.x));\n    }\n//-------------------------------------------\n\nvec3 sceneManager(vec2 fragCoord)\n{\n    vec4 scol = vec4(0.);\n    if(true)\n    {\n    \tscol = scene1(vec3(-5.,-1.5,-8.)/1.6,vec3(1.,0.,0.),fragCoord);\n    }\n    return scol.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 col = vec3(0.);\n    col = sceneManager(fragCoord);\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}