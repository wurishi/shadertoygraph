{"ver":"0.1","info":{"id":"wdy3WW","date":"1570270004","viewed":403,"name":"3D Editor (Use Mouse)","username":"rmmcal","description":"3D Editor Ultra Mega Power Pro Max X Plus Turbo Free \nFeatures: ([Add/Delete]-Shapes) / (SetColor) / (SetRotate) / (SetSize) / (SetMorph) \n=> (Explorer / Discover / Enjoy)  ...... by @rmmcal  :)\npublishing unfinished work of art.....\n","likes":22,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","edit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//---------------------------------------------------------\n// Brasil/Amazonas/Manaus\n// \n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/10\n//\n// Next pass: _NextEditor_\n//---------------------------------------------------------\n//\n///////////////////////////////\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\nuniform sampler2D backbuffer;\n\n#define PI 3.1416*2.\n// https://www.shadertoy.com/view/3sKGDR\n//\n// by @rmmcal  2019/10\n\n//#define iTime 10.\n//#define iMouse 10.\n\n\nconst int total = 10;\nconst int len = 5*total+1;\nvec4 m[len];\n\nstruct Hit{\n    vec3 p;               // point when hitted\n\tfloat distanceRadius; // min distance 3d radius hit => all sides <=\n    int id;       \t\t  // id hit\n};\n    \nstruct RayHit{\n    vec3 uv;  // TODO: uvtexture\n\tvec3 pos; // current position    \n\tvec3 dir; // current direction\n    vec3 clo; // close \n    vec3 nor; // TODO: normal \n    vec3 refl; // TODO: reflection direction\n    vec3 refr; // TODO: fraction   direction  \n    Hit hit;  // hit object\n    float distanceTotal; // total\n};\n\nHit hit(int id, vec3 p, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.distanceRadius = distanceRadius;\n    return hit;\n}    \n\nHit join(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius < hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;\n    \n}\n\nHit join(Hit hit1, Hit hit2, float factor)\n{\n    Hit hit;\n    if (hit1.distanceRadius < hit2.distanceRadius)\n        hit = hit1;\n    else \n        hit = hit2;\n    \n    factor+=1.;\n    float h = max(factor-abs(hit1.distanceRadius -hit2.distanceRadius),0.0);\n  \n    hit.distanceRadius =  min(hit1.distanceRadius, hit2.distanceRadius) - h*h*0.25/factor;\n   \n    return hit;\n}\n\nHit intercept(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius > hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;    \n}\n\nHit sub(Hit hit1, Hit hit2)\n{\n    float d = max(hit1.distanceRadius,-hit2.distanceRadius);\n    Hit h = hit(hit1.id, hit2.p,d );\n    return h;\n}\n\nvec2 rotate(vec2 v, float angle){\n    float c = cos(angle); \n    float s = sin(angle); \n    return mat2(c, -s, s, c) * v;\n}\n\nfloat loop2(float f, float p){\n\treturn abs(fract(iTime*f+p)*2.-1.)*2.-1.;\n}\n\nfloat sphere(vec3 p, vec3 t, float radius){\n    return length(p-t)-radius; //length(s)\n}\n\nfloat box(vec3 p, vec3 t, vec3 s) { \n    return length(max(abs(p-t)-s,0.0)); \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n//https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat packf(float i)\n{\n\treturn (i)/127.; \n}\n\nfloat pack(int i)\n{\n\treturn float(i)/127.; \n}\n\nint unpack(float i)\n{\n\treturn int(i*127.5); \n}\n\n#define RESET_BUTTON vec2(-.45,.25)\n#define ADD_SPHERE_BUTTON vec2(-.40,.25)\n#define ADD_CUBE_BUTTON vec2(-.35,.25)\n#define ADD_TORUS_BUTTON vec2(-.3,.25)\n#define ADD_CONE_BUTTON vec2(-.25,.25)\n\n#define ADD_DELETE_BUTTON vec2(0.2,.25)\n\n#define SHOW_GRID_BUTTON vec2(-.45,.20)\n\n\n\n#define COLOR_BAR_POS vec2(-.12,-0.26)\n#define COLOR_BAR_SIZ vec2(.34,0.015)\n\n \n#define JOIN_BAR_POS vec2(.2,-0.0)\n#define JOIN_BAR_SIZ vec2(.015,0.215)\n\n#define SIZE_BAR_POS vec2(.15,-0.0)\n#define SIZE_BAR_SIZ vec2(.015,0.215)\n\n#define ROTX_BAR_POS vec2(.1,-0.0)\n#define ROTX_BAR_SIZ vec2(.015,0.215)\n      \n#define ROTY_BAR_POS vec2(.05,-0.0)\n#define ROTY_BAR_SIZ vec2(.015,0.215)\n\nHit mapDistance(vec3 p){\n    Hit h; h.distanceRadius = 1000.;\n  \n    for (int i = 2 ; i < len; i+=5) \n    {\n        int lengthAdd = unpack(m[0].x); // float(unpack(m[0].y)\n        if (i >= (lengthAdd*5+2))\n            break;\n        \n        int type = unpack(m[i].w);\n        float merge = m[i+4].x;\n        float s = (-m[i+4].y+.5)*2.;\n        float rx = m[i+4].z*20.;  \n        float ry = m[i+4].w*20.;\n        float distanceObj = 0.;\n        \n        vec3 pr = p ;\n        pr -= m[i+1].xyz*vec3(20.);\n        pr.yz = rotate(pr.yz,rx);\n        pr.xy = rotate(pr.xy,ry);\n        pr += m[i+1].xyz*vec3(20.);\n        \n        if (type == 0)\n        {\n\t\t    distanceObj = sphere(pr,m[i+1].xyz*vec3(20.), m[i+1].w*s);//\n        }\n        if (type == 1)\n        {\n\t\t    distanceObj = box(pr,m[i+1].xyz*vec3(20.), m[i+2].xyz*vec3(20.)*s);//\n        }   \n        if (type == 2)\n        {\n\t\t    distanceObj = sdTorus( pr-m[i+1].xyz*(20.), m[i+2].xy*(1.)*s  );//\n        }  \n        if (type == 3)\n        {\n            // TODO....\n\t\t    //distanceObj = sdCone(pr,m[i+1].xy*(.1)*s);//\n            //distanceObj = sdCapsule(pr, m[i+2].xyz*vec3(20.)*s, m[i+2].xyz*vec3(20.)*s, 1. );\n        } \n        //int mergeMode = unpack(m[i+4].y);\n       \n        h = join(h,  hit((i-2)/5+1, pr, distanceObj), merge*5.);//\n       \n    }\n    \n    return h;\n}\n\nvec3 close3d(RayHit h){ \n    vec2 f = vec2(1.,0.);\n    vec3 d = normalize(h.dir);\n    vec3 p = h.pos;\n\tfloat dx = mapDistance(p - d * f.xyx).distanceRadius ;\n\tfloat dy = mapDistance(p - d * f.yxx).distanceRadius ;\n\tfloat dz = mapDistance(p - d * f.yyx).distanceRadius ;\n\treturn (vec3(dx, dy, dz)) * (h.distanceTotal > 100. ? 0.:1.) ;\n}\n\n// Calculate vector normal to pos\nvec3 normal3d(RayHit h) \n{\n  vec3 pos = h.pos;\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  float ref;\n  nor.x = mapDistance(pos+eps.xyy).distanceRadius - mapDistance(pos-eps.xyy).distanceRadius;\n  nor.y = mapDistance(pos+eps.yxy).distanceRadius - mapDistance(pos-eps.yxy).distanceRadius;\n  nor.z = mapDistance(pos+eps.yyx).distanceRadius - mapDistance(pos-eps.yyx).distanceRadius;\n  return -normalize(nor);\n}\n\nRayHit raymarching(inout RayHit ray)\n{\n    RayHit nohit;\n    ray.uv = ray.dir;\n    \n    //ray\n    for (int i = 0; i < 200; i++)\n    {        \n      \tHit hit = mapDistance(ray.pos);\n        ray.hit = hit;\n        ray.distanceTotal\t+= hit.distanceRadius;           // total\n        ray.pos \t\t\t+= hit.distanceRadius * ray.dir; // walk point to direction\n        \n        if (hit.distanceRadius < .01) break;\t\t\t\t\t\t// so close... performance otimization...\n        if (hit.distanceRadius > 200.) { ray = nohit; break; }\t// so far..... performance otimization...\n \n    }\n    if (ray.pos.x != 0.){\n        ray.clo = close3d(ray);\n        ray.nor = normal3d(ray);\n        ray.refl = reflect(ray.dir, ray.nor );\n    }\n    \n    return ray;\n}\n\nRayHit raymarching(vec2 p)\n{\n \tRayHit r;\n    r.pos = vec3(.0,.0,-20.);\n    r.dir = vec3(p.xy*1.,1.);\n\treturn raymarching(r);\n}\nvec3 hsv(float h, float s, float v){\n    highp vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    highp vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvec3 getColor(RayHit r){\n    return hsv(float(r.hit.id)/10., 1., 1.);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions2d  \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLine2( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )+(step(0.5,mod(floor(length(pa)*100.),2.)*1000.));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat boxColor( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat x(vec2 p, vec2 t, float s){\n    p -= t;\n\treturn max(length(p)-s, min(abs(p.x-p.y), abs(p.x+p.y)));\n}\n\n//////////////////////////////////////////////////////////////////////\n\n//draws a grid\nfloat grid(float scale, vec2 coordinate)\n{\n\treturn max(float(mod(coordinate.x, scale) < 1.), float(mod(coordinate.y, scale) < 1.));\n}\n\nvoid showLog(inout vec4 d, vec2 res, vec2 p, vec4 pm){\n\tp*=res.x;\n    float s = 1./1.;\n    float ss = 20.;\n    for (int i = 0; i < len; i++) // log memory\n    {\n        int lengthAdd = unpack(m[0].x); \n        if (i >= (lengthAdd*5+2))\n            break;\n\n        float f = float(i)/ss + floor((float((i+3)/5)))*1./ss;\n        d += vec4(print_number(float(unpack(m[i].x)), p*s - (vec2(0.6,0.93-f) * res/2.)*s)) ; \n        d += vec4(print_number(float(unpack(m[i].y)), p*s - (vec2(0.7,0.93-f) * res/2.)*s)) ; \n        d += vec4(print_number(float(unpack(m[i].z)), p*s - (vec2(0.8,0.93-f) * res/2.)*s)) ; \n        d += vec4(print_number(float(unpack(m[i].w)), p*s - (vec2(0.9,0.93-f) * res/2.)*s)) ; \n    }\n\n    s = 1./2.;\n    d += vec4(print_number(pm.x*100., p*s - (vec2(-0.9,-0.85) * res/2.)*s)) ; \n    d += vec4(print_number(pm.y*100., p*s - (vec2(-0.8,-0.85) * res/2.)*s)) ; \n    d += vec4(print_number(pm.z*100., p*s - (vec2(-0.7,-0.85) * res/2.)*s)) ; \n    d += vec4(print_number(pm.w*100., p*s - (vec2(-0.6,-0.85) * res/2.)*s)) ; \n\n    d += vec4(print_number(iMouse.x*100., p*s - (vec2(-0.9,-0.79) * res/2.)*s)) ; \n    d += vec4(print_number(iMouse.y*100., p*s - (vec2(-0.7,-0.79) * res/2.)*s)) ; \n    d += vec4(print_number(iMouse.z*100., p*s - (vec2(-0.5,-0.79) * res/2.)*s)) ; \n    d += vec4(print_number(iMouse.w*100., p*s - (vec2(-0.3,-0.79) * res/2.)*s)) ; \n      \n}\n\nvoid mainBuffer(  out vec4 fragColor, in vec2 fragCoord ) {\n    \n  \tvec2 res = iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy-.5;\n\tvec2 mouse2 = iMouse.zw/iResolution.xy-.5;\n\tvec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n\n  \tvec2 pm1 = (mouse)*aspectRatio;\n    vec2 pm2 = (mouse2)*aspectRatio;\n    vec4 pm = vec4(pm1, pm2);\n    \n  \tbool onMousePressed = iMouse.z > 0.0;\n    bool onMouseEq = (iMouse.xy == abs(iMouse.zw))  ;\n    bool onMouseClick = onMouseEq && !onMousePressed  ;\n    float mouseDistance = distance(iMouse.xy, abs(iMouse.zw));\n    bool onMouseDrag = !onMouseClick;\n\t\n\t// load memory //\n\tfor (int i = 0 ; i < len; i++) \n\t\tm[i] = texture(iChannel0, vec2(float(i)+.5,0.)/res)*2.-1.;\n\t\n    bool showGrid = unpack(m[1].w) != 0;\n\t\n    int backSelected = unpack(m[1].x);\n\tint selected = unpack(m[1].y);\n\tint indexSelected = (selected-1)*5+2;\n    \n\tif (gl_FragCoord.y == .5)\n\t{\n\t\t// sequential logic\n\t\t \n        int idMouseHit = raymarching(pm1).hit.id;\n        m[1].x = pack(idMouseHit);\n        \n        int stateClick = unpack(m[1].z);\n        \n        \n        if (onMousePressed)\n        {\n            m[1].z = pack(0);\n        }\n       \telse if (onMouseEq )\n        {\n            if (stateClick == 0)\n                m[1].z = pack(stateClick+1);\n            else\n                onMouseClick = false; // already processed\n        }\n\n        if (onMouseClick && distance(pm1,RESET_BUTTON)< 0.02 || iTime < 0.5)\n        {   \n            // clear memory\n            for (int i = 0 ; i < len; i++) \n                m[i] *= 0.;\n\n            m[0] = vec4(pack(2), pack(0), pm); // length objects added\n            m[1] = vec4(m[1].xyz, 1.); // grid on\n            m[2] = vec4(hsv(float(0)/10., 1., 1.), pack(1)); // color and type cube\n            m[3] = vec4(pack(-20),pack(0), 0., 1.); // set position initial  object 1\n            m[4] = vec4(0.05); // cube size\n            m[5] = vec4(0.0);\n            m[6] = vec4(-.1); // join settings\n\n            m[7] = vec4(hsv(float(1)/10., 1., 1.), pack(0)); // color and type sphere\n            m[8] = vec4(pack(0),pack(0), 0., 1.);\n            m[9] = vec4(0.0);\n            m[10] = vec4(0.0);\n            m[11] = vec4(-.1); // join settings\n        } \n        else if (onMouseClick && distance(pm1,ADD_SPHERE_BUTTON)< 0.02)\n        {\n            int index = unpack(m[0].x);\n            int indexNew = (index)*5+2;\n            m[0].x = pack(index+1); \n            m[indexNew] = vec4(hsv(float(index)/10., 1., 1.), pack(0));\n            m[indexNew+1] = vec4(-0.4,0.2, 0., 1.); // set position initial and size object 2\n            m[indexNew+2] = vec4(0.);\n            m[indexNew+3] = vec4(0.);\n            m[indexNew+4] = vec4(0.);\n\n        }\n        else if (onMouseClick && distance(pm1,ADD_CUBE_BUTTON)< 0.02)\n        {\n            int index = unpack(m[0].x);\n            int indexNew = (index)*5+2;\n            m[0].x = pack(index+1); \n\n            m[indexNew] = vec4(hsv(float(index)/10., 1., 1.), pack(1));\n            m[indexNew+1] = vec4(-0.4,0.2, 0., 1.);\n            m[indexNew+2] = vec4(.05);\n            m[indexNew+3] = vec4(0.);\n            m[indexNew+4] = vec4(0.);\n\n        }\n        else if (onMouseClick && distance(pm1,ADD_TORUS_BUTTON)< 0.02)\n        {\n            int index = unpack(m[0].x);\n            int indexNew = (index)*5+2;\n            m[0].x = pack(index+1); \n\n            m[indexNew] = vec4(hsv(float(index)/10., 1., 1.), pack(2));\n            m[indexNew+1] = vec4(-0.4,0.2, 0., 1.);\n            m[indexNew+2] = vec4(1.,.5, 0., 0.);\n            m[indexNew+3] = vec4(0.0);\n            m[indexNew+4] = vec4(0.0);\n\n        }\n        else if (onMouseClick && distance(pm1,ADD_CONE_BUTTON)< 0.02)\n        {\n            /**\n            int index = unpack(m[0].x);\n            int indexNew = (index)*5+2;\n            m[0].x = pack(index+1); // float(unpack(m[0].y)\n\n            m[indexNew] = vec4(hsv(float(index)/10., 1., 1.), pack(3));\n            m[indexNew+1] = vec4(-0.4,0.2, 0., 1.);\n            m[indexNew+2] = vec4(.25);\n            m[indexNew+3] = vec4(0.0);\n            m[indexNew+4] = vec4(0.0);\n\t\t\t/**/\n        }\n        else if (distance(pm1,ADD_DELETE_BUTTON)< 0.02 && indexSelected>0)\n        {\n            for (int i = 0; i < 5; i++)\n            {\n                m[indexSelected+i] = m[indexSelected+i+5];\n            }\n            m[0].x = pack(max(0,unpack(m[0].x)-1)); \n            m[1].y = m[1].x = pack(0);\n        }\n        else if (onMouseClick && distance(pm1,SHOW_GRID_BUTTON)< 0.02)\n        {\n            m[1].w = pack(unpack(m[1].w) == 0 ? 1 : 0);\n        }\n        else if (step(.0, -sdBox(pm1-COLOR_BAR_POS, COLOR_BAR_SIZ)) > 0. ) \n        {\n            m[indexSelected].rgb = hsv(pm.x, 1., 1.).rgb ;\n        }\n        else if (step(.0, -sdBox(pm1-JOIN_BAR_POS, JOIN_BAR_SIZ)) > 0. ) \n        {\n            m[indexSelected+4].x = -pm.y;\n        }\n        else if (step(.0, -sdBox(pm1-SIZE_BAR_POS, SIZE_BAR_SIZ)) > 0. ) \n        {\n            m[indexSelected+4].y = -pm.y;\n        } \n        else if (step(.0, -sdBox(pm1-ROTX_BAR_POS, ROTX_BAR_SIZ)) > 0. ) \n        {\n            m[indexSelected+4].z = -pm.y;\n        } \n        else if (step(.0, -sdBox(pm1-ROTY_BAR_POS, ROTY_BAR_SIZ)) > 0. ) \n        {\n            m[indexSelected+4].w = -pm.y;\n        }\n        else if (!onMouseEq && onMousePressed && selected > 0 && backSelected > 0 )\n        {\n            m[indexSelected+1].xy = pm1;\n        }\n        else \n        {\n            m[1].y = m[1].x;\n        }\n\n        \n        // save memory\n\t\tfor (int i = 0 ; i < len; i++) \n\t\t\tif (gl_FragCoord.x == float(i)+.5)\n\t\t\t\tfragColor = clamp(m[i]*.5+.5, 0., 1.);\n\t\t\t\n\t}\n\telse\n\t{\n      \n       \tRayHit r = raymarching(p);\n         \n        int indexCurrent = (r.hit.id-1)*5+2;\n        \n  \t\t//vec3 col = getColor(r);\n        vec3 col = m[indexCurrent].rgb;\n        if (r.hit.id == unpack(m[1].y)){\n            col += vec3(0.5);\n        }\n        \n        fragColor = vec4(vec3(col)*r.clo,1.0);\n\n        vec4 d = vec4(0.);\n        if (showGrid)\n\t\t\td = mix(d, vec4(vec3(0.1),1.), grid(10.,gl_FragCoord.xy) ); // grid\n\t\n        d = mix(d, vec4(1.,0.,0.,1. ), 1.-smoothstep(0.,0.005, length(p-RESET_BUTTON)-.02) ); // button\n\t\td = mix(d, vec4(1. ), 1.-smoothstep(0.,0.005, x(p, RESET_BUTTON, 0.02))) ; // icon\n\t\t\n        d = mix(d, vec4(0.5,0.5,1.,1. ), 1.-smoothstep(0.,0.005, length(p-ADD_SPHERE_BUTTON)-.02) ); // button\n\t\td = mix(d, vec4(1. ), 1.-smoothstep(0.,0.005, length(p-ADD_SPHERE_BUTTON)-.01) ); // icon\n\t\t\n        d = mix(d, vec4(0.5,0.5,1.,1. ), 1.-smoothstep(0.,0.005, length(p-ADD_CUBE_BUTTON)-.02) ); // button\n\t\td = mix(d, vec4(1. ), 1.-smoothstep(0.,0.005, box(vec3(p,.0),vec3(ADD_CUBE_BUTTON,0.),vec3(.01)))) ; // icon\n\t\t\n        d = mix(d, vec4(0.5,0.5,1.,1. ), 1.-smoothstep(0.,0.005, length(p-ADD_TORUS_BUTTON)-.02) ); // button\n\t    d = mix(d, vec4(1. ), 1.-smoothstep(0.,0.005, abs(length(p-ADD_TORUS_BUTTON)-.008))) ; // icon\n\t\t\n\n        d = mix(d, vec4(0.5,0.5,0.7,1. ), 1.-smoothstep(0.,0.005, length(p-SHOW_GRID_BUTTON)-.02) ); // button\n\t    d = mix(d, vec4(1. ), 1.-smoothstep(0.,0.005, max(grid(4.,gl_FragCoord.xy),(length(p-SHOW_GRID_BUTTON)-.012)))) ; // icon\n\t\t\n        \n        //d = mix(d, vec4(0.5,0.5,1.,1. ), 1.-smoothstep(0.,0.005, length(p-ADD_CONE_BUTTON)-.02) ); // button\n\n        \n        d = mix(d, vec4(1.,1.,0.,1. ), 1.-smoothstep(0.,0.01, length(p-pm1)-.01) ); // mouse\n\t \n    \n        d = mix(d, vec4(hsv(p.x, 1., 1.),1.), step(.0, -sdBox(p-vec2(.4,0.), vec2(.15,0.4)))*.4 ); // rigth green\n        showLog(d, res, p, pm); // log memory...\n \n\n\t\tif (selected > 0)\n        {\n            float setx = m[indexSelected+4].x;\n        \tfloat sety = m[indexSelected+4].y;\n            float setz = m[indexSelected+4].z;\n            float setw = m[indexSelected+4].w;\n     \n            d = mix(d, vec4(hsv(p.x+.6, 1., 1.),1.), step(.0, -sdBox(p-JOIN_BAR_POS, JOIN_BAR_SIZ))  ); // colorbar\n        \td = mix(d, vec4(hsv(p.x+.4, 1., 1.),1.), step(.0, -sdBox(p-JOIN_BAR_POS+vec2(0.,setx), JOIN_BAR_SIZ*vec2(1.3,.05)))  ); // colorbar\n\n            d = mix(d, vec4(hsv(p.x+.6, 1., 1.),1.), step(.0, -sdBox(p-SIZE_BAR_POS, SIZE_BAR_SIZ))  ); // colorbar\n        \td = mix(d, vec4(hsv(p.x+.4, 1., 1.),1.), step(.0, -sdBox(p-SIZE_BAR_POS+vec2(0.,sety), SIZE_BAR_SIZ*vec2(1.3,.05)))  ); // colorbar\n         \n            d = mix(d, vec4(hsv(p.x+.6, 1., 1.),1.), step(.0, -sdBox(p-ROTX_BAR_POS, ROTX_BAR_SIZ))  ); // colorbar\n        \td = mix(d, vec4(hsv(p.x+.4, 1., 1.),1.), step(.0, -sdBox(p-ROTX_BAR_POS+vec2(0.,setz), ROTX_BAR_SIZ*vec2(1.3,.05)))  ); // colorbar\n\n  \t\t\td = mix(d, vec4(hsv(p.x+.6, 1., 1.),1.), step(.0, -sdBox(p-ROTY_BAR_POS, ROTY_BAR_SIZ))  ); // colorbar\n        \td = mix(d, vec4(hsv(p.x+.4, 1., 1.),1.), step(.0, -sdBox(p-ROTY_BAR_POS+vec2(0.,setw), ROTY_BAR_SIZ*vec2(1.3,.05)))  ); // colorbar\n         \n            \n      \n            d = mix(d, vec4(hsv(p.x, 1., 1.),1.), step(.0, -sdBox(p-COLOR_BAR_POS, COLOR_BAR_SIZ))  ); // colorbar\n        \td = mix(d, vec4(1.,0.,0.,1.), 1.-smoothstep(0.,0.005, length(p-ADD_DELETE_BUTTON)-.02) ); // button\n\t\t\td = mix(d, vec4(1. ), 1.-smoothstep(0.,0.005, x(p, ADD_DELETE_BUTTON, 0.01))) ; // icon\n\t\t\n        }\n            \n       \n        fragColor += vec4(vec3(d),1.0);\n\t\t\n\t}\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mainBuffer(fragColor, fragCoord);\n   // fragColor = vec4(.5);\n}\n \n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// print digits from : http://glslsandbox.com/e#57264.0\n//\n\n//\n//the rest of these functions are just for drawing the numbers and grid\n\n \n\n//returns the bit 1 or 0 from number n at power b\nfloat extract_bit(float n, float p)\n{\n\tn = floor(n);\n\tp = floor(p);\n\tp = floor(n/pow(2.,p));\n\treturn float(mod(p,2.) == 1.);\n}\n\n\n//draws the bits of n into a 3 by 5 sprite over p\nfloat sprite(float n, vec2 p)\n{\n\tp \t\t= floor(p);\n\tfloat bounds \t= float(all(lessThan(p, vec2(3., 5.))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn extract_bit(n, (2. - p.x) + 3. * p.y) * bounds;\n}\n\n\n//maps input n to the corrosponding float representing it's sprite graphic\nfloat digit(float n, vec2 p)\n{\n\tn = mod(floor(n), 10.0);\n\tif(n == 0.) return sprite(31599., p);\n\telse if(n == 1.) return sprite( 9362., p);\n\telse if(n == 2.) return sprite(29671., p);\n\telse if(n == 3.) return sprite(29391., p);\n\telse if(n == 4.) return sprite(23497., p);\n\telse if(n == 5.) return sprite(31183., p);\n\telse if(n == 6.) return sprite(31215., p);\n\telse if(n == 7.) return sprite(29257., p);\n\telse if(n == 8.) return sprite(31727., p);\n\telse if(n == 9.) return sprite(31695., p);\n\telse return 0.0;\n}\n\n//prints a number n\nfloat print_number(float number, vec2 position)\n{\t\n    //number = abs(number);\n\tfloat result\t= 0.;\n\tresult \t\t+= number < 0. ? sprite(24., position + vec2(4., 0.)) : 0.;\t\t\n\tfor(int i = 8; i >= 0; i--)\n\t{\n\t\tfloat place = pow(10., float(i));\n\t\tif(number >= place || float(i) < 1.)\n\t\t{\n\t\t\tresult\t \t+= digit(abs(number/place), position);\n\t\t\tposition.x \t-= 4.;\n\t\t}\n        number = abs(number);\n\t}\n\treturn result;\n}\n\n////////////\n\nfloat chr(float n, vec2 p)\n{\n\tif(n == 0.) return 0.;\n\telse if(n == 1.) return sprite(31661., p);\n\telse if(n == 2.) return sprite(24429., p);\n\telse if(n == 3.) return sprite(24429., p);\n\telse if(n == 4.) return sprite(31015., p);\n\telse if(n == 5.) return sprite(31725., p);\n\telse if(n == 6.) return sprite(18727., p);\n\telse return 0.0;\n}\nfloat printn(float n, vec2 p, vec2 t, vec2 s ){\n\tfloat d = 1.;//1.-smoothstep(0.,0.01, sdBox(p.xy-t,s) ) ;\n\td = min(d,  print_number(n, ceil((p.xy-t)*s*700.)) * 0.55) ;\n\treturn d;\t\n}\n\n\n////////////////////////\n\n\n","name":"Common","description":"","type":"common"}]}