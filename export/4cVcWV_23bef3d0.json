{"ver":"0.1","info":{"id":"4cVcWV","date":"1732417479","viewed":24,"name":"3D Grid Pattern","username":"IMDragonFart","description":"I wanted to recreate a pattern I observed on two overlayed mesh screens. The pattern is created through perspective and the uneveness of the lines over the other plane. You see all the weird sin wave patterns? I thought it was interesting how that occurs","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["3d","grid","rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int DIVISIONS_X = 70;\nconst int DIVISIONS_Y = 70;\nconst float THICKNESS = 0.003;\n\n// bP or perspective plane\nconst float focalDistance = 0.5;\nconst float focalPlaneSize = 1.0;\n// Two objects\nconst float grid1Plane = 0.7;\nconst float grid2Plane = 0.8;\n\n\nvec3 RotateX(vec3 point, vec3 origin, float angle)\n{\n    point -= origin;\n\n    return vec3(\n    point.x,\n    cos(angle) * point.y - sin(angle) * point.z,\n    sin(angle) * point.y + cos(angle) * point.z) + origin;\n}\nvec3 RotateY(vec3 point, vec3 origin, float angle)\n{\n    point -= origin;\n\n    return vec3(\n    cos(angle) * point.x + sin(angle) * point.z,\n    point.y,\n    -sin(angle) * point.x + cos(angle) * point.z) + origin;\n}\nvec3 RotateZ(vec3 point, vec3 origin, float angle)\n{\n    point -= origin;\n\n    return vec3(\n    cos(angle) * point.x - sin(angle) * point.y,\n    sin(angle) * point.x + cos(angle) * point.y,\n    point.z) + origin;\n}\n\nvec3 ProjectToPlane(vec3 startPoint, vec3 endPoint, float planeZ)\n{\n    // (x,y,z) = (xi,yi,zi) + t*(ao,a1,a2)\n    //\n    // (x - xi) / a0 = (y - yi) / a1 = (z - zi) / a2         <-(solve for t)\n    // (x,y) = (z- zi)/a2 * (a0,a1) + (xi,yi)                <-(yields this eq)\n    \n    // (t) is the distance along the 3D line by axis slope(A)\n    float t = length(endPoint);\n    // Slope of line in each axis\n    vec3 A = (endPoint - startPoint)/t;\n    // Plug in endPoint(or startPoint but direction would be reversed)\n    vec3 Pinitial = endPoint - t*A;\n\n    // Which way is the line pointing?\n    bool hasNegativeSlope = false;\n    if(A.z*99999.0*abs(planeZ) - planeZ < 0.0)\n        hasNegativeSlope = true;\n        \n    // Intersection of line and planes to get projection coordinates\n    return vec3((planeZ - Pinitial.z)/A.z * A.x + Pinitial.x,\n                (planeZ - Pinitial.z)/A.z * A.y + Pinitial.y,\n                hasNegativeSlope);\n}\n\n\n// Isometric drawing --\nvec2 GetPointUv(vec3 point)\n{\nreturn point.x * normalize(vec2(1.0, -1.0)) +\n             point.y * normalize(vec2(0.0, 1.0)) +\n             point.z * normalize(vec2(1.0, 1.0));\n}\n\nbool DrawPoint(vec2 uv, vec3 point)\n{\n    vec2 p = GetPointUv(point);\n    if(length(uv - p) < 0.005)\n    {\n        return true;\n    }\n    return false;\n}\nbool DrawLine(vec2 uv, vec3 startPoint, vec3 endPoint)\n{\n    vec2 sp = GetPointUv(startPoint);   \n    vec2 ep = GetPointUv(endPoint);\n    \n    if(ep.x-sp.x == 0.0)\n    {\n        if(uv.y > max(ep.y,sp.y) || uv.y < min(sp.y, ep.y))\n            return false;\n        if(abs(uv.x - ep.x) < 0.001)\n            return true;\n        return false;\n    }   \n    if(uv.x > ep.x || uv.x < sp.x)\n        return false;\n    float slope = (ep.y - sp.y) / (ep.x - sp.x);\n    float b = ep.y - slope * ep.x;\n    float y = slope*uv.x + b;\n    if(abs(uv.y - y) < 0.001)\n        return true;\n    return false;\n}\n// --\n\nbool DrawZPlane(vec2 uv, vec3 origin, vec2 size)\n{\n    vec3 lt = origin + vec3(0, size.y, 0);\n    vec3 rb = origin + vec3(size.x, 0, 0);\n    vec3 rt = origin + vec3(size.x, size.y, 0);\n    \n    if(DrawPoint(uv, origin) \n        || DrawPoint(uv, lt)\n        || DrawPoint(uv, rb)\n        || DrawPoint(uv, rt))\n    {\n        return true;\n    }\n    \n    if(DrawLine(uv, origin, lt) ||\n        DrawLine(uv, lt, rt) ||\n        DrawLine(uv, rt, rb) ||\n        DrawLine(uv, origin, rb))\n    {\n        return true;\n    }   \n    \n    return false;\n}\n\nbool DrawGridLines(vec2 gridUv, vec2 divisions, float thickness)\n{\n    float gridX = fract(gridUv.x*divisions.x)/divisions.x;\n    float gridY = fract(gridUv.y*divisions.y)/divisions.y;\n    \n    if(gridX < thickness || gridY < thickness)\n        return true;\n    return false;\n}\n\n// Keyboard code I don't really understand --\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nbool IsKeyPressed(int key)\n{\n    return texelFetch( iChannel0, ivec2(key,0), 0 ).x == 1.0;\n}\n// --\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y ;\n    vec2 uvCentered = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0,0.15,0); // MOVE CAMERA HERE\n    if(IsKeyPressed(KEY_LEFT) || IsKeyPressed(KEY_DOWN))\n        cameraOrigin.x += sin(iTime)*.5;\n    if(IsKeyPressed(KEY_UP) || IsKeyPressed(KEY_DOWN))\n        cameraOrigin.y += sin(iTime*2.0)*.5;\n    if(IsKeyPressed(KEY_RIGHT))\n        cameraOrigin.z += sin(iTime*0.5)*.5;\n    \n    vec3 focalPoint = cameraOrigin + vec3(uvCentered * focalPlaneSize,focalDistance);\n    focalPoint = RotateX(RotateY(focalPoint, cameraOrigin, (iMouse.x/iResolution.x -.5) * 3.1415926), cameraOrigin,  (-iMouse.y/iResolution.y +.5)* 3.1415926);\n\n    // Draw stuff\n    //vec3 intersection = ProjectToPlane(vec3(0,0,0), vec3(0,0,2), grid1Plane);\n    //if(DrawLine(uv, vec3(0,0,0), vec3(0, 0, 2)) || DrawPoint(uv, vec3(intersection.xy, grid1Plane)))\n    //    fragColor = vec4(1,1,1,1);\n        \n    //if(DrawZPlane(uv, vec3(-.05,-.05,focalDistance),vec2(0.1,0.1)) ||\n    //    DrawZPlane(uv, vec3(-.1,-0.1,grid1Plane),vec2(0.2,0.2)))\n    //{\n    //    fragColor = vec4(1,1,1,1);\n    //}  \n    //if(DrawPoint(uv, vec3(0,0,0)))\n    //    fragColor = vec4(1,0,0,1);\n       \n        \n    // Projections onto planes\n    vec3 projection = ProjectToPlane(cameraOrigin, focalPoint, grid1Plane);\n    vec3 projection2 = ProjectToPlane(cameraOrigin, focalPoint, grid2Plane);\n    \n    // Draw final render on planes\n    float limit = 1.5;\n    if(projection2.z == 0.0 &&\n       abs(projection2.x) < limit &&\n       abs(projection2.y) < limit)\n    {\n        if(DrawGridLines(projection2.xy, vec2(DIVISIONS_X, DIVISIONS_Y), THICKNESS))\n            fragColor = vec4(0.2,0.2,.8,1);\n    }\n    if(projection.z == 0.0 &&\n       abs(projection.x) < limit &&\n       abs(projection.y) < limit)\n    {\n        if(DrawGridLines(projection.xy, vec2(DIVISIONS_X, DIVISIONS_Y), THICKNESS))\n            fragColor = vec4(0,0,1,1);\n    }\n}","name":"Image","description":"","type":"image"}]}