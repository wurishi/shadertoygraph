{"ver":"0.1","info":{"id":"NsscR8","date":"1641699212","viewed":105,"name":"Fork ShATI - Po panna_pudi 424","username":"panna_pudi","description":"It's just a silly fork. All credits to Flopine","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","animation","isometric"],"hasliked":0,"parentid":"wssBzX","parentname":"ShATI - Portail"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI 3.14159265\n#define TAU 6.2831853071\n#define dt (mod(iTime + PI / 2., TAU))\n\nfloat hash21(vec2 coord){\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// reference for animation curves: https://easings.net/\nfloat easeInOutCirc(float x) {\n    return x < 0.5 ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n                   : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define animation(time) (-1. + 2. * easeInOutCirc(time))\nfloat square(vec2 uv) {\n    float width = 0.35;\n    uv.x += animation(sin(dt) * 0.5 + 0.5);\n    uv *= rot(animation(sin(dt) * 0.5 + 0.5) * PI);\n    uv = abs(uv);\n    return smoothstep(width, width * 1.05, max(uv.x, uv.y));\n}\n\nfloat sc(vec3 p, float s) {\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x, min(p.y, p.z)) - s;\n}\n\nfloat cube(vec3 p) {\n    p.x += animation(sin(dt) * 0.5 + 0.5) * 2.8;\n    /* if (sin(pc.time / 2 + 0 * PI) > 0) { */\n    /*     p.yz *= rot(-atan(1. / sqrt(2.))); */\n    /* } else { */\n    p.zy *= rot(-atan(1. / sqrt(2.)));\n    /* } */\n    /* p.xz *= rot(PI / 4.); */\n    p.xy *= rot(animation(sin(dt) * 0.5 + 0.5) * PI);\n    return max(-sc(p, 0.8), length(max(abs(p) - vec3(1.), 0.)));\n    /* return length(max(abs(p) - vec3(1.), 0.)); */\n}\n\nconst vec3 PINK = vec3(1., .01, .10);\n\nvec3 raymarch(vec2 uv) {\n  vec3 ro = vec3(uv * 3., 5.);\n  vec3 rd = normalize(vec3(0., 0., -1.));\n  vec3 col = PINK;\n  float shad;\n  bool hit = false;\n\n  float t = 0.;\n  for (float i = 0.; i < 100.; i++) {\n    float d = cube(ro + rd * t);\n    if (abs(d) < 0.01) {\n      shad = i / 32.;\n      break;\n    }\n    t += d + hash21(uv) * 0.02;\n    if (t > 10.) break;\n  }\n    if (t < 10.)\n        col = vec3(1. - shad);\n\n    return col;\n}\n\nvec3 render(vec2 uv) {\n  float aspect = iResolution.x / iResolution.y;\n  uv = (uv/iResolution.xy * 2. - 1.)\n                        * vec2(aspect, 1.);\n            \n  vec3 cuber = raymarch(uv);\n  vec3 col = (uv.y >= sin(dt + 2. * PI) * 2.) ? cuber : PINK + square(uv);\n  col = col * 1.2 / (2.1 - col * 0.5);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = render(fragCoord);\n\n    // difference threshold between neighbor pixels\n    if (fwidth(length(fragCoord)) > .01) {\n      col -= col;\n      for (int k = 0; k < 9; k += k == 3 ? 2 : 1) {\n        col += render(fragCoord + vec2(k % 3 - 1, k / 3 - 1) / 3.);\n      }\n      col /= 9.;\n      /* col.r++; // uncomment to see where the */\n               // oversampling occurs\n    }\n  \n    col = pow(col, vec3(1. / 2.5));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}