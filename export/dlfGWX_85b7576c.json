{"ver":"0.1","info":{"id":"dlfGWX","date":"1672519836","viewed":129,"name":"Anti-Aliased Area Under Curve","username":"bestknighter","description":"Plotting the area under a function curve with white using the coverage algorithm. A simplified use case of the same algorithm used for rendering of vector graphics.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["vectorgraphics","learning","function","plot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nfloat fn(float x) {\n    return 0.8*pow(0.5*sin((x+iTime/30.0)*2.0*PI)+0.5, 1.5)+0.1;\n}\n\nfloat linear(float a, float b, float x) {\n    return a*x + b;\n}\n\n// Always assuming to get area below graph\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 graphRes = iResolution.xy/vec2(1.0); // Change multiplier to render at a lower res\n    vec2 pxIdx = floor(uv*graphRes);\n    vec2 pxSize = vec2(1.0)/graphRes;\n    \n    uv = pxIdx/graphRes;\n    \n    // Getting graph height at left/right borders of sampling area\n    vec2 fnLeft = vec2(uv.x, fn(uv.x));\n    vec2 fnRight = vec2(uv.x+pxSize.x, fn(uv.x+pxSize.x));\n    \n    // Getting params of linear eq\n    float a = (fnRight.y-fnLeft.y)/(fnRight.x-fnLeft.x);\n    float b = fnLeft.y - a*fnLeft.x;\n    \n    // Getting intersection of linear eq with upper/lower borders of sampling area\n    vec2 eqBottom = vec2((uv.x-b)/a, uv.y);\n    vec2 eqTop = vec2((uv.y+pxSize.y-b)/a, uv.y+pxSize.y);\n    \n    // Linear eq entry and exit points of sampling area\n    float lPoint = clamp(min(eqBottom.x, eqTop.x), uv.x, fnRight.x);\n    float rPoint = clamp(max(eqBottom.x, eqTop.x), uv.x, fnRight.x);\n    vec2 eqEntry = vec2(\n        lPoint,\n        clamp(linear(a, b, lPoint), uv.y, eqTop.y)\n    );\n    vec2 eqExit = vec2(\n        rPoint,\n        clamp(linear(a, b, rPoint), uv.y, eqTop.y)\n    );\n    \n    // Calculating total coverage\n    float leftRect = (eqEntry.x - uv.x)*(eqEntry.y - uv.y);\n    float rightRect = (fnRight.x - eqExit.x)*(eqExit.y - uv.y);\n    float trapzd = (eqExit.x - eqEntry.x)*(eqExit.y + eqEntry.y - 2.0*uv.y)/2.0;\n    float coverage = (leftRect + trapzd + rightRect)/(pxSize.x*pxSize.y);\n\n    // Output to screen\n    fragColor = vec4(vec3(coverage),1.0);\n}","name":"Image","description":"","type":"image"}]}