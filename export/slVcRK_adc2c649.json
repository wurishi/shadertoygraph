{"ver":"0.1","info":{"id":"slVcRK","date":"1673452288","viewed":191,"name":"cmyk persp hex grid","username":"HaleyHalcyon","description":"e","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["r"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// square root of 3 because hexagon stuff\n#define SQRT3 (1.7320508)\n// two pi for rotation stuff\n#define TURN (6.283185307)\n// rotation matrix\n#define HALFPI (1.57079632679)\n#define ROT(theta) mat2(cos(theta+vec4(0,-HALFPI,HALFPI,0)))\n// converts rgb hex code to a vec3\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n// saw wave to triangle wave\n#define ZIG(x) 1. - abs(1. - 2. * x)\n\n// calculate the distance from the center of a hexagon\nfloat hex(vec2 uv) {\n    const vec2 tileSize = vec2(1.0, SQRT3);\n    vec2 tiled = abs(tileSize - mod(\n        uv + vec2(0., SQRT3*2./3.), tileSize * 2.\n    ));\n    float diag = dot(tiled, tileSize / 2.);\n    float thres = step(1.0, diag);\n    return mix(\n        max(tiled.x, diag),\n        max(1. - tiled.x, 2. - diag),\n    thres);\n}\n\nfloat hexHelper(vec2 uv, float otherOne) {\n    const vec2 tileSize = vec2(1.0, SQRT3);\n    uv += \n        vec2(0., SQRT3*2./3.)\n        + otherOne * vec2(3., SQRT3);\n    vec2 tiled = abs(\n        tileSize * vec2(3., 1.) - mod(\n            uv, tileSize * vec2(6., 2.)\n        )\n    );\n    float diag = dot(tiled, tileSize);\n    \n    return step(max(tiled.x, diag * 0.5), 1.0);\n}\n\nfloat hex2(vec2 uv) {\n    return max(hexHelper(uv, 0.), hexHelper(uv, 1.));\n}\n\n// map the range [0, 1) to stripes of colors\nfloat map(float minv, float maxv, float x) {\n    if (minv == maxv) {return step(minv, x);}\n    return clamp(0., 1., (x - minv) / (maxv - minv));\n}\n\n// set to 1 to enable antialiasing\n#define ANTIALIAS 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 30.);\n    // Scales coords so that the diagonals are all the same distance from the center\n    \n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / length(iResolution.xy);\n    // persp\n    uv += 0.125 * cos((time + vec2(0.25, 0)) * TURN);\n    uv *= ROT(-time * TURN);\n    uv /= 1. - 0.5 * uv.y;\n    uv.x *= .875;\n    uv *= 8.;\n    \n    float turnMax = 2. * TURN / 3.;\n    uv *= ROT(time * turnMax);\n    // shift center of grid\n    uv += vec2(1, 1./SQRT3);\n    \n    \n    float dist = hex(uv);\n    float hexCol1 = hex2(uv);\n    float hexCol2 = hex2(uv + vec2(1, SQRT3));\n    vec3 baseCol = (\n        HEX(0x009BE8) * hexCol1 +\n        HEX(0xEB0072) * hexCol2 +\n        HEX(0xfff100) * (1. - hexCol1 - hexCol2)\n    );\n    \n    float distTemp = ZIG(fract(\n        1.5 * dist * dist +\n        -10. * time +\n        0.333 * hexCol1 +\n        -0.333 * hexCol2\n    ));\n#if ANTIALIAS == 1\n    float aaWidth = fwidth(distTemp) * 0.75;\n    float bright = \n        smoothstep(\n            -aaWidth, aaWidth, distTemp - 0.5\n        ) * smoothstep(\n            -fwidth(dist), fwidth(dist), 0.9 - dist\n        )\n    ;\n#else\n    float bright = min(\n        step(\n            0.5, distTemp\n        ), step(\n            dist, 0.9\n        )\n    );\n#endif\n    vec3 col = mix(HEX(0x010a31), baseCol, bright);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}