{"ver":"0.1","info":{"id":"tlfGWS","date":"1557440716","viewed":2174,"name":"[TWITCH] HBHS","username":"Flopine","description":"HBHS is the name of the show I'm hosted on Twitch there: https://www.twitch.tv/flopine\nIt stands for \"Have a Beer, Have a Shader\". Hope you'll like it ^^","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","transparency","beer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\nfloat PI = 3.141592;\n\nfloat rand (vec2 x)\n{return fract(sin(dot(x, vec2(12.45,49.4564)))*1254.48);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat glass (vec3 p)\n{\n    float body = cyl(p.xzy, 0.8+sin(p.y*3.)*0.05, 1.6);\n    float final_body = abs(body) - 0.06;\n    final_body = max(final_body,p.y-1.4);\n    p.xy *= rot(-PI/8.);\n    p.xy += vec2(1.,0.2);\n    p.x -= sin((p.y-1.1)*PI/1.5)*0.7;\n    float handle = max(cyl(p.xzy, 0.15, 1.), -body);\n    return min(handle,final_body);\n}\n\nfloat beer (vec3 p)\n{\n    return max(p.y-1.2,  cyl(p.xzy, 0.72+sin(p.y*3.)*0.05, 1.6));\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    p.xz *= rot(time);\n    float g= glass(p);\n    float b = beer(p);\n    float d = min(g,b);\n    if (d == g) mat_id = 1;\n    if (d == b) mat_id = 2;\n    return d;\n}\n\nfloat beer_bottle (vec2 uv)\n{\n    uv -=0.5;\n    float a = mix (-PI/5., -PI/3., clamp(floor(sin(time*PI)+1.),0.,1.));\n    uv *= rot(a);\n    float r = mix(0.15, 0.09 - uv.y*0.1, smoothstep(0.02,0.15, uv.y));\n    return abs(uv.y) < 0.4 ? step(abs(uv.x), r) : 0.;\n}\n\nfloat checker (vec2 uv)\n{\n    uv.y += time*0.4;\n    uv *= rot(PI/4.);\n\n    vec2 uu = mod (fract(uv),2.);\n    float c = beer_bottle(uu);\n    uv = mod(floor(uv),2.);\n    return mod(uv.x + uv.y,2.) == 0. ? 1.-c : 0.+c;\n}\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3(SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nvec3 get_cam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = rand(uv);\n\n    vec3 ro = vec3(0.001,2.5, -5.5); vec3 p = ro;\n    vec3 tar = vec3(0.);\n    vec3 rd =  get_cam(ro, tar, uv);\n\n    // transparency trick from Shane shader: \n    // https://www.shadertoy.com/view/Xd3SDs \n    vec3 col = vec3(0.);\n    vec3 lp = vec3(3, 1, 2);\n    float shad = 0., t=0., layers = 0., d, aD;\n    // light parameters\n    float lDist, specular, lighting;\n    // thickness of the geometry\n    float thD = .00125;\n\n    for (float i=0.; i<64.; i++)\n    {\n        if(layers > 30. || t > 15.) break;\n        p = ro+t*rd;\n        d = SDF(p);\n\n        aD = (thD-abs(d))/thD;\n        if (aD>0.)\n        {\n            uv *= 0.98; // fake refraction trick thanks to alkama!\n            if (mat_id == 2) col += vec3(0.8,0.3,0.)*0.2;\n            vec3 sn = get_normals(p)*sign(d);\n            vec3 ld = (lp - p);\n            lDist = length(ld);\n            ld /= lDist;\n            specular = pow(max(dot(reflect(-ld, sn), -rd), 0.), 15.);\n            lighting = max(dot(ld, sn), 0.);\n            col += (lighting * 0.3 + vec3(0.1,0.2,0.5)*specular)*aD / (1.+lDist*0.25 + lDist*lDist*0.05)*0.5;\n            if(mat_id == 2) col = mix(col, vec3(0.8,0.3,0.), 1.-exp(-0.05*aD*aD));\n            layers ++;\n        }\n        d *= 0.8 + dither*0.02;\n        t += max(abs(d), thD*0.25);\n    }\n\n    col += vec3(checker(uv*7.));\n\n    t = min(t, 15.);\n    col = mix(col, vec3(0.1), 1.-exp(-0.008*t*t));\n\n    // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.8);\n\n    fragColor = vec4(pow(col,vec3(0.4545)), 1.);\n}","name":"Image","description":"","type":"image"}]}