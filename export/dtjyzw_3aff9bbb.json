{"ver":"0.1","info":{"id":"dtjyzw","date":"1691622241","viewed":75,"name":"Spheres in LA","username":"jure","description":"50 spheres in a grid","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","sdf","sphere","depthoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0 \n\n#define PI 3.14159265359\n#define GRID_ROWS 5\n#define GRID_COLS 10\n\nvec4 evaluatePosition(float t, int idx) {\n    float x = -8.5 + 2.0 * float(idx % GRID_COLS); // Grid in x direction\n    float y = sin(iTime/2.0 + float(idx)/2.0) + 2.5 + 2.0 * float(idx / GRID_COLS); // Grid in y direction\n    float z = 0.0 + sin(iTime * 0.7 + float(idx) / 5.0 * PI * 0.1) * 4.; // Sinusoidal movement in z direction\n    return vec4(x, z, y, 0.0); // Position\n}\n\nvec3 evaluateColor(float t, int idx) {\n    vec4 position = evaluatePosition(t, idx);\n    float r = 0.7 + 0.3*sin(iTime / 4.0 + position.y);\n    float g = 0.4 + 0.2*cos(iTime / 4.2 + position.z);\n    float b = 0.3 + 0.2*sin(iTime / 1.0 + position.y);\n\n    return vec3(r,g,b); // Color based on position\n}\n\n// 3D noise function (replace this with a more complex noise if desired)\nfloat hash13(vec3 p) {\n    return fract(sin(dot(p ,vec3(12.9898,78.233,45.164)))*43758.5453);\n}\n\n// Sphere SDF with noise\nfloat sphereSDF(vec3 p, vec3 c, float r, float blur) {\n    float baseDist = length(p - c) - r;\n    float n = hash13(p * 1.5); // Scale factor affects the frequency of the noise\n    return baseDist + n * blur * 3.2; // Amplitude of noise (focus)\n}\n\n\nfloat calculateBlur(float distanceToObject, float focalDistance, float apertureSize) {\n    float focusDifference = abs(distanceToObject - focalDistance);\n    return sqrt(focusDifference / apertureSize);\n}\n\nvec3 calculateNormal(vec3 p, vec4 sphereInfo, float blur) {\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = vec3(\n        sphereSDF(p + e.xyy, sphereInfo.xyz, 0.4, blur) - sphereSDF(p - e.xyy, sphereInfo.xyz, 0.4, blur),\n        sphereSDF(p + e.yxy, sphereInfo.xyz, 0.4, blur) - sphereSDF(p - e.yxy, sphereInfo.xyz, 0.4, blur),\n        sphereSDF(p + e.yyx, sphereInfo.xyz, 0.4, blur) - sphereSDF(p - e.yyx, sphereInfo.xyz, 0.4, blur));\n    return normalize(n);\n}\n\nvec4 raymarch3(vec3 ro, vec3 rd, vec3 cameraDirection, vec3 lightDir) {\n    vec4 accumColor = vec4(0.0);\n    int numSpheres = 50; // Number of spheres\n    float focalDistance = 10. + 5. * sin(iTime); // Focal distance from the camera\n    float accumulatedDistance = 0.0; // Accumulated distance inside spheres\n\n    for (int j = 0; j < numSpheres; j++) {\n        float t = 0.0;\n        vec4 sphereInfo = evaluatePosition(iTime, j);\n\n        vec3 toObject = sphereInfo.xyz - ro; // Vector from camera to object\n        float distanceToObject = length(toObject); // Euclidean distance to object\n        float distanceToFocalPlane = dot(toObject, cameraDirection); // Projection onto viewing direction\n        float blur = (distanceToFocalPlane - 10.) / 10.0;\n        for (int i = 0; i < 100; i++) {\n            vec3 p = ro + rd * t;\n            float d = sphereSDF(p, sphereInfo.xyz, 0.8, blur);\n            if (d < 0.001) {\n                vec3 sphereColor = evaluateColor(iTime, j);\n                float transmittance = exp(-t * 0.006); // Attenuation based on distance inside spheres\n\n                accumColor.w = 1.0;\n                vec3 normal = calculateNormal(p, sphereInfo, blur);\n                float diffuse = max(0.0, dot(normal, lightDir));\n                accumColor.xyz += transmittance * sphereColor * (diffuse + .6);\n                break;\n\n            }\n            t += d;\n            if (t > 10.4) break;\n        }\n    }\n\n    if (accumColor.w == 0.) return vec4(-1.0); // Background\n    return accumColor;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv *= iResolution.xy / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -9.0);\n    vec3 target = vec3(0.0, 0.0, 5.0); // Look-at point\n    \n    // Mouse controls\n    float angleY = iTime / 2.0;\n    if(iMouse.z > 0.) {\n        angleY = iMouse.x / iResolution.x * 2.0 * PI;\n    }\n    \n    mat3 rotY = mat3(\n        cos(angleY), 0.0, sin(angleY),\n        0.0, 1.0, 0.0,\n        -sin(angleY), 0.0, cos(angleY)\n    );\n\n    ro -= target; // Move ro relative to target\n    ro = rotY * ro; // Rotate camera position\n    ro += target; // Move ro back\n\n    vec3 cf = normalize(target - ro);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), cf);\n    vec3 up = cross(cf, right);\n\n    vec3 rd = cf + uv.x * right + uv.y * up; // Ray direction\n\n    // For focal plane\n    vec3 cameraDirection = normalize(target - ro); // Direction camera is facing\n    \n    vec3 lightDir = normalize(vec3(1., 0., 1.)); // Directional light\n\n    // Raymarch\n    vec4 color = raymarch3(ro, normalize(rd), cameraDirection, lightDir);\n\n    // Check if hit anything\n    if (color.w < 1.0) {\n        vec3 normal = normalize(rd); // Normal from the camera direction\n        float diffuse = max(0.0, dot(normal, lightDir));\n\n        fragColor = vec4(.4, .3, .3, 1.0) * diffuse; // Background color\n    } else {\n        fragColor = vec4(color.xyz, 1.0); // Sphere color with lighting\n    }\n}\n","name":"Image","description":"","type":"image"}]}