{"ver":"0.1","info":{"id":"ws33zf","date":"1569005263","viewed":876,"name":"fur test","username":"jojobavg","description":"test of fur with ray tracing, ray marching and hypertexture.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","fur","hypertexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using code from\n\n// Inigo Quilez for the primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n// NuSan for the noise function\n// https://www.shadertoy.com/view/3dXSDH\n\nuniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n#define time iTime\n\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp=fract(p);\n\tp=smoothstep(0.0,1.0,p);\n\tvec3 st=vec3(7,37,289);\n\tvec4 pos=dot(ip,st) + vec4(0.0,st.y,st.z,st.y+st.z);\n\tvec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n\tvec2 val2=mix(val.xz,val.yw, p.y);\n\treturn mix(val2.x,val2.y, p.z);\n}\n\nvec3 noise3(vec3 p) \n{\n\tfloat x=noise(p);\n\tfloat y=noise(p+sin(noise(p)));\n\tfloat z=noise(p+cos(noise(p)));\n\treturn vec3(x,y,z);\n}\n\nfloat dot2(  vec3 v ) { return dot(v,v); }\n\nfloat fur(vec3 pIn,vec3 p1,vec3 tU,vec3 tV,float h,float l,float sF,float sD,float speed,vec3 norm )\n{\n\tvec3 fDir = normalize(noise3(p1*sD+time*speed))*2.0-1.0;\n\tfloat dot1= dot(norm,p1-pIn);\n\tvec3 Vnoise = ((pIn-p1)-(norm+fDir*2.0)*(1.0-dot1));\n\tvec3 noisV =(tU)*(dot((tU),Vnoise))+(tV)*(dot((tV),Vnoise));\n\tvec3 noisy =noisV*((cos(1.0-h)*0.2))*l;\n\tfloat noise=noise((pIn+noisy)*sF);\n\treturn noise-(1.0-h);\n}\n\nmat2 rot(float a) \n{\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere(in vec3 p, in vec3 centerPos, float radius) \n{\n\treturn length(p-centerPos) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t,vec3 centerPos )\n{\n\tvec2 q = vec2(length(p.xz+ centerPos.xz)-t.x,p.y+ centerPos.y);\n\treturn length(q)-t.y;\n}\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n\tvec3 ba = b - a; vec3 pa = p - a;\n\tvec3 cb = c - b; vec3 pb = p - b;\n\tvec3 dc = d - c; vec3 pc = p - c;\n\tvec3 ad = a - d; vec3 pd = p - d;\n\tvec3 nor = cross( ba, ad );\n\n\treturn sqrt(\n\t(sign(dot(cross(ba,nor),pa)) +\n\t sign(dot(cross(cb,nor),pb)) +\n\t sign(dot(cross(dc,nor),pc)) +\n\t sign(dot(cross(ad,nor),pd))<3.0)\n\t ?\n\t min( min( min(\n\t dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n\t dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n\t dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n\t dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n\t :\n\t dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p)\n{\n\tfloat s = sphere(p,vec3(0.0,0.0,25.0),20.0);\n\tfloat pl = udQuad(p,\n\t\t\t  vec3(10000.0, 20.0, 10000.0),\n\t\t\t  vec3(-10000.0, 20.0, 10000.0), \n\t\t\t  vec3(-10000.0, 20.0, -10000.0),\n\t\t\t  vec3(10000.0, 20.0, -10000.0));\n\tfloat c = sdTorus(p,vec2(20.0,10.0),vec3(0.0,-10.0,25.0));\n\tfloat res = s;\n\treturn min(min(res, pl),c);\n}\n  \nfloat map(vec3 p)\n{\n\treturn sphere(p,vec3(0.0,0.0,0.0),20.0);\n}\n  \nfloat mapFur(vec3 p,vec3 p1,vec3 tU,vec3 tV,float h,vec3 n)\n{\n\treturn fur(p,p1,tU,tV,h,10.0,3.0,0.05,1.0,n);\n}\n  \nfloat getao(vec3 p, vec3 n, float dist) \n{\n\treturn clamp(map3(p+n*dist)/dist, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 s=vec3(0.0,0.0,-100.0);\n\tfloat t2=(time*0.5+10.0);\n\ts.y = -abs(cos(t2*0.5)*100.0);\n\ts.xz *= rot(t2*0.5);\n\n\tvec3 t=vec3(0.0,0.0,0.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0.0,1.0,0.0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\n\tvec3 p=s;\n\tvec2 off=vec2(0.001,0.0);\n\tvec3 n;\n\tvec3 pIn;\n\tvec3 tU;\n\tvec3 tV;\n\tfloat h;\n\tvec3 up;\n\tfloat depth = 1.0;\n\tfor(int cpt=0;cpt<2;cpt++)\n\t{\n\t\tbool hit = false;\n\t\tfloat d=0.0;\n\t\tfloat dd=0.0;\n\t\tfor(int i=0; i<60; ++i) \n\t\t{\n\t\t\td=map3(p);\n\t\t\tif(d<0.0001 ){hit = true; break;}\n\t\t\tif(dd>400.0) {dd=400.0;hit = true; break;}\n\t\t\tp+=d*r*0.8;\n\t\t\tdd+=d;\n\t\t}\n\t\tdepth = (1.0-length(p-s)/300.0);\n\t\tbool hit2;\n\t\tif(depth>0.0)\n\t\t{\n\t\t\tn=normalize(map3(p)-vec3(map3(p-off.xyy), map3(p-off.yxy), map3(p-off.yyx)));\n\t\t\tup=normalize(vec3(0.001,0.952315,0.0001));\n\t\t\tvec3 right=normalize(vec3(0.001,0.001,0.952315));\n\t\t\ttU = normalize(cross(right,n));\n\t\t\ttV = normalize(cross(n,tU));\n\t\t\tvec3 dirT = normalize(r*(1.0-dot(r,tU))+r*(1.0-dot(r,tV)));\n\t\t\tfloat hmax =2.0;\n\t\t\tfloat distmax = 5.0;\n\t\t\tvec3 maxDirI = r*distmax;\n\t\t\tfloat step = 100.0;\n\t\t\tvec3 dirI = maxDirI/step;\n\t\t\th=1.0;\n\t\t\tfloat dotI = 1.0-max(dot(dirI,dirT),0.0);\n\t\t\tpIn=p;\n\t\t\tfloat d2=0.0;\n\t\t\thit2 = false;\n\t\t\t\n\t\t\tfor(int i=0; i<100; ++i) \n\t\t\t{\n\t\t\t\th = (clamp(dot(normalize(dirI),-n),0.2,1.0)*length(dirI)*float(i))/hmax;\n\t\t\t\td2=mapFur(p+dirI*float(i),p,tU,tV,h,normalize(n));  \n\t\t\t\tpIn=p+dirI*float(i);\n\t\t\t\tif(d2>0.001){hit2=true; break;}\n\t\t\t}\n\t\t}\n\t\tif(hit)\n\t\t\tif(hit2)\n\t\t\t\tbreak;\n\n\t\t\t\n\t}\n\t\n\tvec3 l=normalize(vec3(-1,-2,-3));\n\tvec3 color1 = vec3(0.7,0.7,0.9);\n\tvec3 color2 = vec3(0.6,0.6,1.0);\n\tfloat dotr=(dot(r,l));\n\tvec3 sky = mix(color1,color2,min(dotr,1.0));\n\toff=vec2(0.0001,0.0);\n\tvec3 nStrand=normalize(mapFur(pIn,p,tU,tV,h,n)-vec3(mapFur(pIn-off.xyy,p,tU,tV,h,n), mapFur(pIn-off.yxy,p,tU,tV,h,n), mapFur(pIn-off.yyx,p,tU,tV,h,n)));\n\tvec3 col=vec3(0.0);\n\tvec3 ambient = sky*(1.0-max(dot(n,up),0.0)*0.8+0.2);\n\tfloat ao = (getao(p, n, 12.0) * 0.5 + 0.5) * (getao(p, n, 2.0) * 0.3 + 0.7) * (getao(p, n, 0.5) * 0.1 + 0.9);\n\tcol = ((dot(normalize(nStrand+n),l)*0.5+0.5)*0.1+ambient*0.9)*ao;\n\tcol = mix(sky,clamp(col,0.0,1.0)*clamp(1.0-h,0.2,1.0),clamp(ceil(depth),0.0,1.0));\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}