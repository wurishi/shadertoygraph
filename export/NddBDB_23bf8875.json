{"ver":"0.1","info":{"id":"NddBDB","date":"1657130202","viewed":85,"name":"Radial Coordinate Inverse Ex.","username":"thenumbernine","description":"Radial Coordinate Inverse Example.\n\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["radialinverse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fraction of radial coordinate (using y axis as unit) to flip at\nconst float unitRadius = 2.;\n\n//how often to flip between normal and inverse-radius\nconst float flipFrequency = 5.;\n\n//how smooth to flip the radial power from +1 to -1.  higher = sharper.  1 == sine wave.\nconst float flipFreqSmoothness = 5.;\n\n//grid thicknesses in polar coordinates\nconst float thetaEpsilon = .03;\nconst float rEpsilon = .03;\n\n//something to do with the green screen effect\nconst float colorEpsilon = .005;\n\n//only true for positive \nfloat fpart(float x) { return x - floor(x); }\nfloat lenSq(vec4 x) { return dot(x,x); }\n\n#define M_PI 3.14159265358979311599796346854418516159057617187500\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    \n    //aspect ratio of the screen\n    float ar = iResolution.x/iResolution.y;\n    \n    // and now to [-1,1]\n    p -= .5;\n    p *= 2.;\n    \n    //now adjust for aspect ratio so only y coordinate is [-1,1]\n    p.x *= ar;\n    \n    // and to polar\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    \n    //now rescale so r=.5 becomes r=1 (our unity radius)\n    r *= unitRadius;\n    \n    float rSrc = r;\n    \n    //and invert r ... oscillate between r and 1/r\n    float st = sin(iTime*(2.*M_PI)/flipFrequency);\n    st = pow(abs(st), 1./flipFreqSmoothness) * (st > 0. ? 1. : -1.);\n    r = pow(r, st);\n    \n    //and rescale back\n    r /= unitRadius;\n    \n    \n    //and to Cartesian\n    p = vec2(cos(theta), sin(theta)) * r;\n    \n    //un-adjust aspect ratio\n    p.x /= ar;\n    \n    // and back to [0,1]\n    p *= .5;\n    p += .5;\n\n    // Time varying pixel color\n    vec4 color = texture( iChannel0, p );\n\n    //background grid color\n    float thetaGrid = fpart(theta / (2. * M_PI) * 12.);\n    float rGrid = fpart(rSrc);\n    float l = (\n            smoothstep(thetaEpsilon, 2.*thetaEpsilon, thetaGrid) \n            + smoothstep(thetaEpsilon, .0, thetaGrid)\n        ) * ( smoothstep(rEpsilon, 2.*rEpsilon, rGrid) \n            + smoothstep(rEpsilon, .0, rGrid)\n        );\n    \n    //green screen <-> background grid\n    float colorDist = lenSq(vec4(13./255., 163./255., 37./255., 1.) - color);\n    color = mix(\n        color,\n        vec4(l, l, l, 1.),\n        smoothstep(2.*colorEpsilon, colorEpsilon, colorDist));\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}