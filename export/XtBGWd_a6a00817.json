{"ver":"0.1","info":{"id":"XtBGWd","date":"1433498855","viewed":132,"name":"Siemens soutenance","username":"lamogui","description":"Soutenance","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["siemens","diapo","soutenance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SKY   0.\n#define MAT_FOG   1.\n#define MAT_CUBE  2.\n#define MAT_FLOOR 3.\n\nconst vec4 sky_color=vec4(.92,.92,1.,1.);\nconst vec4 fog_color=sky_color;\nvec4 cube_color=vec4(.0,153./255.,151./255.,1.);\nvec4 floor_color=vec4(1.);\n\nconst float clip=30.;\n\nvec3 rotX(vec3 v, float a)\n{\n  mat3 m=mat3(1.,0.,0.,\n              0.,cos(a), -sin(a),\n              0.,sin(a),cos(a));\n  return m*v;\n\n}\n\nvec3 rotY(vec3 v, float a)\n{\n  mat3 m=mat3(cos(a), 0., -sin(a),\n              .0    ,1. ,.0,\n              sin(a),.0 ,cos(a));\n  return m*v;\n\n}\n\nvec3 rotZ(vec3 v, float a)\n{\n  mat3 m=mat3(cos(a), -sin(a), .0,\n              sin(a),cos(a),.0,\n              .0    ,0. ,1.);\n  return m*v;\n\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat spec(vec3 p)\n{\n    float d=3.;\n    float r=floor(p.z/d);\n    p.z=mod(p.z,d) - d*.5;\n    float time=iTime;\n    float h=.1+abs(.6*cos(r*.5+.3*time)+.4*sin(.3*r-.7*time));\n    return sdBox(p-vec3(.0,h-.1,.0),vec3(.8,h,.8));\n    \n}\n\nvec2 MIN(vec2 d, float e,float mat)\n{\n    if (abs(e) < abs(d.x))\n    {\n        return vec2(e,mat);\n    }\n    return d;\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 d=vec2(spec(p), MAT_CUBE);\n    d=MIN(d,p.y,MAT_FLOOR);\n\treturn d;\n}\n\nvec2 scene_np(vec3 p)\n{\n    vec2 d=vec2(spec(p), MAT_CUBE);\n\treturn d;\n}\n\nvec4 rm_np(vec3 o, vec3 rd)\n{\n    vec3 p=o;\n    for (float i=0.; i < 100.; i++)\n    {\n        vec2 e=scene_np(p);\n        if (abs(e.x) < .02)\n        {\n            return vec4(p, e.y);\n        }\n        if (distance(p, o) > clip)\n        {\n            return vec4(p,MAT_SKY);\n        }\n        if (abs(e.x) < 1.)\n        {\n        \trd=rotX(rd,e.x*.1*(cos(3.*distance(p, o)*(.3+texture(iChannel0,o.xz).x*.7))));\n        \trd=rotZ(rd,e.x*.1*(sin(2.*distance(p, o)*(.3+texture(iChannel0,o.zx).x*.7))));\n        }\n        p+=.9*rd*e.x;\n        \n    }\n    return vec4(p,MAT_SKY);\n}\n\nvec4 rm(vec3 o, vec3 rd)\n{\n    vec3 p=o;\n    for (float i=0.; i < 64.; i++)\n    {\n        vec2 e=scene(p);\n        if (abs(e.x) < .02)\n        {\n            return vec4(p, e.y);\n        }\n        if (distance(p, o) > .95*clip)\n        {\n            return vec4(p,MAT_SKY);\n        }\n        p+=.6*rd*e.x;\n        \n    }\n    return vec4(p,MAT_SKY);\n}\n\n\nvec3 grad_np(vec3 p)\n{\n  float eps=0.01;\n  return normalize(vec3(scene_np(p+vec3(eps,0.,0.)).x - scene_np(p-vec3(eps,0.,0.)).x,\n                   scene_np(p+vec3(0.,eps,0.)).x - scene_np(p-vec3(0.,eps,0.)).x,\n                   scene_np(p+vec3(0.,0.,eps)).x - scene_np(p-vec3(0.,0.,eps)).x));\n}\n\nvec3 grad(vec3 p)\n{\n  float eps=0.01;\n  return normalize(vec3(scene(p+vec3(eps,0.,0.)).x - scene(p-vec3(eps,0.,0.)).x,\n                   scene(p+vec3(0.,eps,0.)).x - scene(p-vec3(0.,eps,0.)).x,\n                   scene(p+vec3(0.,0.,eps)).x - scene(p-vec3(0.,0.,eps)).x));\n}\n\nvec4 colorize(float mat, vec3 p, vec3 n, vec3 o)\n{\n    vec4 color=sky_color;\n    vec3 eye=normalize(o-p);\n  \tvec3 l1p=vec3(-8.,4.,o.z);\n  \tvec3 l1=normalize(l1p-p);\n  \tvec3 r1=normalize(-reflect(l1,n));\n  \tfloat l1distance=distance(l1p,p);\n  \tfloat attenuation=exp(-l1distance*0.01);\n    \n    if (mat==MAT_SKY) {\n    \treturn color;\n    } else if (mat==MAT_FLOOR) {\n        color=floor_color;\n    } else if (mat==MAT_CUBE) {\n        color=cube_color;\n    }\n    \n    float ao=1.;\n  \tvec4 diffuse=ao*color*clamp(dot(n,l1),.0,1.) + color*0.5*attenuation;\n  \tvec4 spec=ao*vec4(1.)*pow(clamp(dot(r1,eye),0.,1.),0.3)*exp(-l1distance*0.2)*attenuation;\n    color=clamp(diffuse+spec,vec4(.0),vec4(1.));\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = fragCoord.xy / iResolution.xy;\n    vec2 uv=v*2.-vec2(1.);\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 o=vec3(-7.0,6.,-4.);\n    vec3 rd=normalize(vec3(uv, 1.2));\n   // rd=normalize(vec3(uv, .8-length(uv)));\n    rd=rotY(rd,-.3);\n    //rd=rotY(rd,1.+cos(iTime));\n    \n    vec4 e=rm(o,rd);\n    vec3 p=e.xyz;\n    float mat=e.w;\n    vec3 n=grad(p);\n    \n    vec4 color=colorize(mat,p,n,o);\n    float eye_d=distance(o,p);\n    color=mix(color,fog_color,eye_d/clip);\n    \n    if (mat==MAT_FLOOR)\n    {\n        float noise=texture(iChannel0, p.xz).x;\n        \n        rd=reflect(rd,n);\n        vec3 old_o=o;\n        o=p;//+rd;\n        //rd.x+=.1*cos(p.x);\n        //rd.y+=.3*cos(p.y);\n        e=rm_np(o,rd);\n        p=e.xyz;\n        mat=e.w;\n        n=grad(p);\n\n        vec4 reflect_color=color;\n        if (mat!=MAT_SKY) {\n            reflect_color=colorize(mat,p,n,old_o);//*noise;\n        \teye_d=distance(old_o,p);\n        \treflect_color=mix(reflect_color,fog_color,eye_d/clip);\n        }\n        color=reflect_color;\n    }\n    \n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}