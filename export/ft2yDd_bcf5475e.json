{"ver":"0.1","info":{"id":"ft2yDd","date":"1650414622","viewed":49,"name":"Bowling Alley Carpet","username":"halvqr","description":"Press the mouse down to run the automaton, drag left or right to change the \"temperature,\" and press space to reset.\n\nI don't really understand how this works, but it seems to involve some kind of numerical overflow.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cellularautomaton","differentialequations","overflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //all the interesting stuff happens over in the Buffer A tab\n    vec4 val = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    //val.xyz is typically much larger than 1.0,\n    //and is often negative, making it invisible\n    fragColor = vec4(val.xyz,1.0);\n    //fragColor = vec4(val.z,mod(val.z,2.0),-val.z,1.0);\n    \n    //overlays the two guiderails 1/10th and 9/10ths of the way across the window\n    float nearness = min(abs(fragCoord.x - 0.9 * iResolution.x),\n                         abs(fragCoord.x - 0.1 * iResolution.x));\n    if(nearness < 6.0){\n        if(nearness < 2.0){\n            fragColor = vec4(1.0,1.0,1.0,1.0);\n        }else{\n            fragColor = vec4(0.0,0.0,0.0,0.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //converts pixel coordinates to a pair of integers\n    ivec2 ic = ivec2(fragCoord);\n    \n    //this pixel's color from the previous frame\n    vec4 self = texelFetch(iChannel1,ic,0);\n    \n    //if spacebar pressed or shader restarted\n    if(texelFetch(iChannel2,ivec2(32,0),0).x > 0.0 || iFrame == 0){\n    \n        //resets to initial state\n        //try changing the starting texture in iChannel0!\n        vec4 val = texelFetch(iChannel0,\n                              ic - (ivec2(iResolution.xy) - textureSize(iChannel0,0))/2,\n                              0);\n        fragColor = floor(val * 2.0);\n        \n    }else{\n    \n        //offsets for which nearby pixels to check\n        //try changing the number or values of these!\n        vec2[] neighborhood = vec2[](\n            vec2(-1,-1),\n            vec2( 0,-1),\n            vec2( 1,-1),\n            vec2( 1, 0),\n            vec2( 1, 1),\n            vec2( 0, 1),\n            vec2(-1, 1),\n            vec2(-1, 0)\n            //vec2( 0, 0)\n        );\n        \n        //checks values of neighboring pixels (with wrap-around boundary)\n        //and rounds down to an integer value\n        ivec4 nearbySum = ivec4(0);\n        for(int i = 0; i < neighborhood.length(); i++){\n            nearbySum += ivec4(texelFetch(iChannel1,\n                                          ivec2(mod(fragCoord.x + neighborhood[i].x,\n                                                    iResolution.x),\n                                                mod(fragCoord.y - neighborhood[i].y,\n                                                    iResolution.y)),\n                                          0));\n        }\n        \n        //only runs when mouse is pressed\n        if(iMouse.z >= 0.0){\n            //divides sum of neighbors by a value dependent upon mouse position\n            float base = 2.5 * (iMouse.x/iResolution.x - 0.1);\n            \n            //for thumbnail\n            if(iMouse.z == 0.0){\n                base = 1.75 - cos(0.5 * iTime) * 0.25;\n            }\n            \n            fragColor = vec4(nearbySum)/(base * base * base * float(neighborhood.length())/8.0);\n        }else{\n            //stays the same\n            fragColor = self;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}