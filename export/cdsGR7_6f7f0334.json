{"ver":"0.1","info":{"id":"cdsGR7","date":"1665867181","viewed":208,"name":"voxelray","username":"jt","description":"Reconstruction of my software-renderer \"voxelray\" which I wrote 20 years ago. Old pixel-look but 3d :)\nContrary to my previous shaders this one uses the bresenham algorithm to trace each light-ray - integers only!\n(TODO: fix cam bumpiness in bounding box)","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raytracer","ray","volume","texture","voxel","bresenham","voxelray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/cdsGR7 voxelray by Jakob Thomsen\n// Reconstruction of my software-renderer VOXELRAY I wrote 20 years ago during my studies.\n// Uses a 3d bresenham algorithm to trace each light-ray - integers only!\n// The scene is a boolean function which defines if a voxel contains data\n// (back then I didn't know about raymarching distance-fields)\n// and calculates the approximate normal by weighted sum of neighbor voxels.\n\n// Modifications to my original implementation:\n// Unfortunately the first version using bresenham was lost,\n// so I ported an implementation from the web to GLSL instead\n// (almost identical to wikipedia's, only pre-increments loop counter).\n// The bounding-box is new (originally viewer was inside scene).\n// I also didn't know of gyroids or 3d textures (it was just blocks).\n// The original was written in c and SDL 1 - now ported to GLSL.\n// Also the voxel-resolution can now be modified (change SUBDIV).\n\n// Old pixel-look but with voxels - once shadertoy supports 3d texture buffer\n// this could be used to implement a 3d \"Worms\" like game :)\n\n// NOTE: Make sure LINEAR filter for texture-volume is selected!\n\n// tags: 3d, raytracing, raytracer, ray, volume, texture, voxel, bresenham, voxelray\n\n// MIT License, as in https://www.shadertoy.com/terms\n\n/*\n\nCopyright (c) 2022 Jakob Thomsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#define SUBDIV 200 /* sample count */\n#define NORMAL_SMOOTHNESS 1 /* window-size for calculating normal */\n\n#define pi 3.1415926\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n\n// modified https://iquilezles.org/articles/intersectors/\nvec2 bounding_box(vec3 ro, vec3 rd) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m);\n    vec3 t0 = -n - k;\n    vec3 t1 = -n + k;\n    float tN = max(max(t0.x, t0.y), t0.z);\n    float tF = min(min(t1.x, t1.y), t1.z);\n\n    if(tN > tF || tF < 0.0)\n        return vec2(DIST_MAX); // no intersection\n\n    return vec2(tN, tF);\n}\n\nfloat gyroid(vec3 p)\n{\n    p.x *= 2.0 * pi;\n    p.y *= 2.0 * pi;\n    p.z *= 2.0 * pi;\n    return cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n}\n\nint encode(bvec3 c)\n{\n    return (int(c.x) << 0) + (int(c.y) << 1) + (int(c.z) << 2);\n}\n\nint map(ivec3 p) // returns id, zero marks empty\n{\n    if(any(greaterThanEqual(abs(p), ivec3(SUBDIV-1)))) return 0;\n    vec3 q = vec3(p)/float(SUBDIV);\n    //return length(vec3(q)) < 1.0 ? 1 : 0; // sphere\n    //if(fract(iTime * 0.1) < 0.5)\n    //return (0.0 < gyroid(q)) ? 7 : 0; // gyroid\n    return encode(lessThan(texture(iChannel0, 0.2*(q*0.5+0.5)).xyz, vec3(0.25)));\n\n    //return (texture(iChannel0, 0.1*(q*0.5+0.5)).x < 0.5) ? 1 : 0;\n}\n\n// https://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n// adapted from https://www.geeksforgeeks.org/bresenhams-algorithm-for-3-d-line-drawing/ because I lost my original code.\nivec4 locate_voxel(ivec3 p, ivec3 q) // 3d bresenham, returns position & id\n{\n    ivec3 d = abs(q - p);\n    ivec3 s = ivec3(greaterThan(q, p)) * 2 - 1;\n\n    if (d.x >= d.y && d.x >= d.z)\n    {\n        ivec2 t = 2 * d.yz - d.x;\n\n        while (p.x != q.x)\n        {\n            p.x += s.x;\n\n            if (t.x >= 0)\n            {\n                p.y += s.y;\n                t.x -= 2 * d.x;\n            }\n\n            if (t.y >= 0)\n            {\n                p.z += s.z;\n                t.y -= 2 * d.x;\n            }\n\n            t += 2 * d.yz;\n            \n            int c = map(p);\n            if(c != 0)\n                return ivec4(p, c);\n        }\n    }\n    else if (d.y >= d.x && d.y >= d.z)\n    {\n        ivec2 t = 2 * d.xz - d.y;\n\n        while (p.y != q.y)\n        {\n            p.y += s.y;\n\n            if (t.x >= 0)\n            {\n                p.x += s.x;\n                t.x -= 2 * d.y;\n            }\n\n            if (t.y >= 0)\n            {\n                p.z += s.z;\n                t.y -= 2 * d.y;\n            }\n\n            t.x += 2 * d.x;\n            t.y += 2 * d.z;\n\n            int c = map(p);\n            if(c != 0)\n                return ivec4(p, c);\n        }\n    }\n    else\n    {\n        ivec2 t = 2 * d.yx - d.z;\n\n        while (p.z != q.z)\n        {\n            p.z += s.z;\n\n            if (t.x >= 0)\n            {\n                p.y += s.y;\n                t.x -= 2 * d.z;\n            }\n\n            if (t.y >= 0)\n            {\n                p.x += s.x;\n                t.y -= 2 * d.z;\n            }\n\n            t.x += 2 * d.y;\n            t.y += 2 * d.x;\n\n            int c = map(p);\n            if(c != 0)\n                return ivec4(p, c);\n        }\n    }\n\n    return ivec4(ivec3(0), 0); // sky\n}\n\nivec4 locate_voxel2(ivec3 p, ivec3 q) // adapted from http://members.chello.at/~easyfilter/bresenham.html\n{\n    int dx = abs(q.x - p.x), sx = p.x < q.x ? +1 : -1;\n    int dy = abs(q.y - p.y), sy = p.y < q.y ? +1 : -1; \n    int dz = abs(q.z - p.z), sz = p.z < q.z ? +1 : -1; \n    int dm = max(max(dx,dy),dz), i = dm; /* maximum difference */\n    q.x = q.y = q.z = dm / 2; /* error offset */\n \n    {\n        int c = map(p);\n        if(c != 0)\n            return ivec4(p, c);\n    }\n \n    while(i-- > 0)\n    {\n        q.x -= dx; if (q.x < 0) { q.x += dm; p.x += sx; } \n        q.y -= dy; if (q.y < 0) { q.y += dm; p.y += sy; } \n        q.z -= dz; if (q.z < 0) { q.z += dm; p.z += sz; } \n        int c = map(p);\n        if(c != 0)\n            return ivec4(p, c);\n    }\n    \n    return ivec4(ivec3(0), 0); // sky\n}\n\nvec3 normal(ivec3 location)\n{\n    int n = NORMAL_SMOOTHNESS; // window-size for calculating normal\n    ivec3 sum = ivec3(0);\n    ivec3 delta;\n    for(delta.z = -n; delta.z <= +n; delta.z++)\n    {\n        for(delta.y = -n; delta.y <= +n; delta.y++)\n        {\n            for(delta.x = -n; delta.x <= +n; delta.x++)\n            {\n                if(map(clamp(location + delta,-SUBDIV,+SUBDIV)) != 0)\n                {\n                    sum -= delta;\n                }\n            }\n        }\n    }\n\n    return (sum != ivec3(0)) ? normalize(vec3(sum)) : vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * (fragCoord.xy) / iResolution.xy - 1.0;\n    p.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.05);\n    my = (iMouse.y > 10.0) ? my : pi / 2.0;\n\n    mat2 yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    //vec3 ro = vec3(0.0, 0.0,-3.5);\n    //vec3 ro = vec3(0.0, 0.0,-1.0);\n    vec3 ro = vec3(0.0, 0.0,-mix(3.5,1.0,0.5-0.5*cos(iTime*.1)));\n    mat2 pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz = pitch * ro.yz;\n    ro.xy = yaw * ro.xy;\n\n    vec3 rd = normalize(vec3(0.5 * p.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = pitch * rd.yz;\n    rd.xy = yaw * rd.xy;\n    \n    vec2 intersections = bounding_box(ro, rd);\n    vec3 color = vec3(0);\n\n    {\n        bool inside = all(lessThan(abs(ro), vec3(1.0))); // suspect camera bumpiness occurs inside bounding-box due to misaligned ray-start - how to fix alignment?\n    \n        vec3 start = ro + rd * max(0.0, intersections.x);\n        vec3 end = ro + rd * intersections.y;\n        float s = float(SUBDIV);\n\n        ivec4 location_id = locate_voxel(ivec3(start * s), ivec3(end * s));\n        if(location_id.w != 0)\n        {\n            int code = location_id.w;\n            color = vec3((code >> 0) & 1, (code >> 1) & 1, (code >> 2) & 1);\n\n            ivec3 location = ivec3(location_id);\n            vec3 n = normal(location);\n            //color = n * 0.5 + 0.5;\n\n            //vec3 lightdir = vec3(0,0,1);\n            vec3 lightdir = normalize(vec3(1,1,1));\n            ro = vec3(location) / s;\n            rd = lightdir;\n            intersections = bounding_box(ro, rd);\n            start = ro + rd * max(0.0, intersections.x);\n            end = ro + rd * intersections.y;\n            bool lighted = locate_voxel(ivec3(start * s + rd), ivec3(end * s)).w == 0;\n\n            float ambient = 0.1;\n            float diffuse = max(0.0, dot(n, lightdir));\n            color = (ambient + diffuse * (lighted ? 1.0 : 0.0)) * color;\n        }\n        else\n        {\n            color = vec3(0);\n        }\n    }\n\n    color = sqrt(color); // approximate gamma\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}