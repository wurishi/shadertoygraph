{"ver":"0.1","info":{"id":"sttGzS","date":"1636435317","viewed":268,"name":"improved Hilbert CA","username":"Carandiru","description":"use keyboard arrow keys to manipulate the bits / rule the CA is influenced by.\nleft/right - select bit\nup/down - set/clear selected bit\nmouse click & pan - zoomish","likes":4,"published":3,"flags":48,"usePreview":0,"tags":["noise","pixel","automata","cellular","hilbert"],"hasliked":0,"parentid":"fttGz7","parentname":"Interactive Hilbert CA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/sttGzS\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// improved final version \n// -very precise\n// -improved resolution\n// -major math changes to original algo, ++state\n// -contrast\n\n// ** use keyboard arrow keys to manipulate the bits / rule the CA uses.\n// ** left/right - select bit\n// ** up/down - set/clear selected bit\n// ** mouse click & pan - zoomish\n\nconst vec3 c0 = vec3(0.1019607843137254902, 0.13725490196078431373, 0.2),\n           c1 = vec3(0.57647058823529411765, 0.62352941176470588235, 0.70588235294117647059);\n           \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy;\n   \n    vec4 screen = textureLod(iChannel0, uv, 0.0f);\n    \n    float hs = mix(screen.x, mix(screen.y, mix(screen.z, screen.w, 0.5f), 0.5f), 0.5f);\n    \n    vec3 color = vec3( mix(c0, c1, 1.0f - hs) );\n    \n    float change = abs(screen.x - screen.y) * iTimeDelta * 100.0f;\n    color.r += change;\n    color.rgb *= change;\n    color = color * color;\n    \n    color = color + textureLod(iChannel2, fragCoord.xy / 1024.0f, 0.0f).r * (17.0f/255.0f);\n        \n    float overlay = textureLod(iChannel1, fragCoord.xy / iResolution.xy, 0.0f).r;\n    \n    color += overlay;\n    \n    fragColor = vec4(sqrt(color),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/sttGzS\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n\nuint width()\n{\n    uint mini = uint(min(iResolution.x, iResolution.y));\n    \n    --mini;\n    mini |= (mini >> 1u);\n    mini |= (mini >> 2u);\n    mini |= (mini >> 4u);\n    mini |= (mini >> 8u);\n    mini |= (mini >> 16u);\n    ++mini;\n    \n    return max(1u, mini);\n}\n\nfloat hilbert1D(in uvec2 Position, in uint w){   \n    \n    uint Index = 0u;\n    \n    for(uint CurLevel = (w>>1u); CurLevel > 0u; CurLevel >>= 1u){\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel*CurLevel*((3u*Region.x)^Region.y);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(w-1u) - Position;\n            }\n            Position.xy=Position.yx;\n        }\n    }\n    return (float(Index)/float(w*w));\n}\n\nvec2 hilbert2D(in uint Index, in uint w){   \n    \n    uvec2 Position = uvec2(0u);\n    \n    for(uint CurLevel = 1u; CurLevel < w; CurLevel <<= 1){\n        uvec2 Region;\n        Region.x = 1u & (Index >> 1u);\n        Region.y = 1u & (Index ^ Region.x);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(CurLevel-1u) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n        Position += CurLevel * Region;\n        Index >>= 2u;\n    }\n    return vec2(Position);\n}\n\nvoid unpack_rule(out float rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = float(bool(r & (1u << 7u)));\n    rule[1] = float(bool(r & (1u << 6u)));\n    rule[2] = float(bool(r & (1u << 5u)));\n    rule[3] = float(bool(r & (1u << 4u)));\n    rule[4] = float(bool(r & (1u << 3u)));\n    rule[5] = float(bool(r & (1u << 2u)));\n    rule[6] = float(bool(r & (1u << 1u)));\n    rule[7] = float(bool(r & (1u << 0u)));\n}\n\nconst vec4 balance = vec4(0.249999f, 0.24999f, 0.2499f, 0.249f);\n\nfloat state(in float rule[directions], in vec3 s)\n{\n    uint d = 0u;\n    \n    d |= uint(bool(round(s.x))) << 2u;\n    d |= uint(bool(round(s.y))) << 1u;\n    d |= uint(bool(round(s.z))) << 0u;\n    \n    return rule[7u - d];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 rr = textureLod(iChannel2, uv, 0.0f).ba;\n    \n    uint frame = uint(rr.x * convert_length);\n    \n    if (frame < 2u) {\n        fragColor = textureLod(iChannel1, fragCoord/1024.0f, 0.0f);\n        return;\n    }\n    \n    float rule[directions];\n    unpack_rule(rule, rr.y);\n    \n    mat3 nn[3];\n\n    // tl\n    nn[0][0] = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1,-1)).rgb;\n    // t\n    nn[0][1] = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0,-1)).rgb;\n    // tr\n    nn[0][2] = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1,-1)).rgb;\n       \n    // l\n    nn[1][0] = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 0)).rgb;\n    // c\n    nn[1][1] = textureLod(iChannel0, uv, 0.0f).rgb;\n    // r\n    nn[1][2] = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 1)).rgb;\n        \n    // bl    \n    nn[2][0] = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 1)).rgb;\n    // b\n    nn[2][1] = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 1)).rgb;\n    // br\n    nn[2][2] = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1, 1)).rgb;\n        \n                              // frame - 1 | frame - 2 | frame - 3\n    nn[0] = transpose(nn[0]); // tl, t, tr | tl, t, tr | tl, t, tr\n    nn[1] = transpose(nn[1]); //  l, c, r  |  l, c, r  |  l, c, r\n    nn[2] = transpose(nn[2]); // bl, b, br | bl, b, br | bl, b, br\n    \n    mat3 s;\n    s[0] = vec3(state(rule, nn[0][0]), state(rule, nn[0][1]), state(rule, nn[0][2]));\n    s[1] = vec3(state(rule, nn[1][0]), state(rule, nn[1][1]), state(rule, nn[1][2]));\n    s[2] = vec3(state(rule, nn[2][0]), state(rule, nn[2][1]), state(rule, nn[2][2]));\n    \n    mat3 nna;\n     \n    // current\n    nna[0] = s[0] * (nn[0][0] + nn[1][0] + nn[2][0]);\n    nna[1] = s[1] * (nn[0][1] + nn[1][1] + nn[2][1]);\n    nna[2] = s[2] * (nn[0][2] + nn[1][2] + nn[2][2]);\n    \n    \n    bool moused = bool((iMouse.z * iTimeDelta) >= 0.5f);\n    uint w = width() << 1u * uint(moused);\n    \n    float d = float(frame + 1u);\n    vec2 htl = hilbert2D(uint(nna[0].x * d), w);\n    vec2 ht  = hilbert2D(uint(nna[0].y * d), w);\n    vec2 htr = hilbert2D(uint(nna[0].z * d), w);\n    vec2 hl  = hilbert2D(uint(nna[1].x * d), w);\n    vec2 hr  = hilbert2D(uint(nna[1].z * d), w);\n    vec2 hbl = hilbert2D(uint(nna[2].x * d), w);\n    vec2 hb  = hilbert2D(uint(nna[2].y * d), w);\n    vec2 hbr = hilbert2D(uint(nna[2].z * d), w);\n    \n    vec2 dir =    htl  // vec2(-1, -1) \n                + ht   // vec2( 0, -1) \n                + htr  // vec2( 1, -1) \n                + hl   // vec2(-1,  0) \n                + hr   // vec2( 1,  0) \n                + hbl  // vec2(-1,  1) \n                + hb   // vec2( 0,  1) \n                + hbr; // vec2( 1,  1);\n    \n    \n    vec2 mouse = iMouse.xy * float(moused) * 10.0f;\n    \n    float h;\n    h = hilbert1D(uvec2(fragCoord.xy + mouse + (dir)), w);\n    \n   // h = bellcurve(h);\n   // h = smoothstep(0.9998f, 1.0f, h);\n        \n    mat4 hm;\n    hm[0] = textureLod(iChannel0, uv, 0.0f);\n    hm[1] = textureLod(iChannel0, uv, 1.0f);\n    hm[2] = textureLod(iChannel0, uv, 2.0f);\n    hm[3] = textureLod(iChannel0, uv, 3.0f);\n    \n    hm = transpose(hm);\n       \n    vec4 bhm = vec4(dot(balance, hm[0]), \n                    dot(balance, hm[1]),\n                    dot(balance, hm[2]),\n                    dot(balance, hm[3]));\n    \n    \n    \n    mat4 hn = mat4(nna);\n    \n    vec4 bhn = vec4(dot(balance, hn[0]), \n                    dot(balance, hn[1]),\n                    dot(balance, hn[2]),\n                    dot(balance, hn[3]));\n    \n    //float change = abs(dot(balance, bhm) - dot(balance, bhn));\n    //h = h + h * mix(dot(balance, bhm), dot(balance, bhn), change);\n    \n    float significance = smoothstep(0.1f * GOLDEN_RATIO_ZERO * GOLDEN_RATIO, 0.0f, bellcurve(bhm.w * bhn.w));\n    vec3 n = mix(bhn.xyz, bhm.xyz, significance);\n    \n    fragColor = vec4(h, n);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/sttGzS\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define PI (3.141592654f)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n#define directions (8)\n#define convert_length 4.294967295e9f\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}\n\nvec4 bellcurve(vec4 x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/sttGzS\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nint rule[directions] = int[directions]( 0, 0, 0, 1, 0, 1, 1, 1 );\n// 0001 0111\n// 0110 1111\n// 0110 1110\n\nfloat pack_rule()\n{\n    int r = 0;\n    r = (rule[0] << 7) | \n        (rule[1] << 6) |\n        (rule[2] << 5) |\n        (rule[3] << 4) |\n        (rule[4] << 3) |\n        (rule[5] << 2) |\n        (rule[6] << 1) |\n        (rule[7] << 0);\n        \n    return(float(uint(r)) / 255.0f);\n\n}\n\nvoid unpack_rule(out int rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = int(bool(r & (1u << 7u)));\n    rule[1] = int(bool(r & (1u << 6u)));\n    rule[2] = int(bool(r & (1u << 5u)));\n    rule[3] = int(bool(r & (1u << 4u)));\n    rule[4] = int(bool(r & (1u << 3u)));\n    rule[5] = int(bool(r & (1u << 2u)));\n    rule[6] = int(bool(r & (1u << 1u)));\n    rule[7] = int(bool(r & (1u << 0u)));\n}\n\n// Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\nconst int CHARS[41] = int[](\n    0x00000000, \n    0x00E8FE31, \n    0x01E8FA3E, \n    0x00F8420F, \n    0x01E8C63E,\n    \n    0x01F87A1F, \n    0x01F87A10, \n    0x00F84E2F, \n    0x0118FE31, \n    0x00421084,\n    \n    0x01F0862F, \n    0x01197251, \n    0x0108421F, \n    0x01BAD6B1, \n    0x011CD671,\n    \n    0x00E8C62E, \n    0x01E8FA10, \n    0x00E8D66E, \n    0x01E8FA31,\n    0x00F8383E,\n    \n    0x0000001F, \n    0x0118C62E, \n    0x0118C544, \n    0x0118C6AA, \n    0x01151151,\n    \n    0x0118A884, \n    0x01F9113F, \n    0x00ECD66E, \n    0x0046509F, \n    0x00E8991F, \n    \n    0x00E89A2E, \n    0x00232BE2, \n    0x01F8383E, \n    0x00F87E3E, \n    0x01F11108, \n    \n    0x00E8BA2E, \n    0x00F8FC3E, \n    0x00000004, \n    0x00000088, \n    0x00421004, \n    0x00E11004\n);\n\nfloat character(float color, float background, int character, vec2 position, float size, vec2 uv)\n{\n    if((uv.x > position.x && uv.x < position.x + size) && (uv.y > position.y && uv.y < position.y + size))\n    {\n        ivec2 pixel = ivec2(ceil((uv.x-position.x)/size*5.0)-1.0, ceil((1.0-(uv.y-position.y)/size)*5.0)-1.0);\n        int bit_index = pixel.y*5 + pixel.x;\n        int bit = (CHARS[character] >> (24 - bit_index))&1;\n        if(bit > 0)\n            return color;\n    }\n    return background;\n}\n\n#define EOL 0\n#define _ 0,\n#define A 1,\n#define B 2,\n#define C 3,\n#define D 4,\n#define E 5,\n#define F 6,\n#define G 7,\n#define H 8,\n#define I 9,\n#define J 10,\n#define K 11,\n#define L 12,\n#define M 13,\n#define N 14,\n#define O 15,\n#define P 16,\n#define Q 17,\n#define R 18,\n#define S 19,\n#define T 20,\n#define U 21,\n#define V 22,\n#define W 23,\n#define X 24,\n#define Y 25,\n#define Z 26,\n\n#define DOT 37,\n#define COMMA 38,\n#define BANG 39,\n#define QUESTION 40,\n\n#define EOL1 0\n#define EOL2 EOL1,EOL1\n#define EOL3 EOL2,EOL1\n#define EOL4 EOL3,EOL1\n#define EOL5 EOL4,EOL1\n#define EOL6 EOL5,EOL1\n#define EOL7 EOL6,EOL1\n#define EOL8 EOL7,EOL1\n#define EOL9 EOL8,EOL1\n#define EOL10 EOL9,EOL1\n#define EOL11 EOL10,EOL1\n#define EOL12 EOL11,EOL1\n#define EOL13 EOL12,EOL1\n#define EOL14 EOL13,EOL1\n#define EOL15 EOL14,EOL1\n#define EOL16 EOL15,EOL1\n#define EOL17 EOL16,EOL1\n#define EOL18 EOL17,EOL1\n#define EOL19 EOL18,EOL1\n#define EOL20 EOL19,EOL1\n#define EOL21 EOL20,EOL1\n#define EOL22 EOL21,EOL1\n#define EOL23 EOL22,EOL1\n#define EOL24 EOL23,EOL1\n#define EOL25 EOL24,EOL1\n#define EOL26 EOL25,EOL1\n#define EOL27 EOL26,EOL1\n#define EOL28 EOL27,EOL1\n#define EOL29 EOL28,EOL1\n#define EOL30 EOL29,EOL1\n\n#define LEN0 EOL30\n#define LEN1 EOL29\n#define LEN2 EOL28\n#define LEN3 EOL27\n#define LEN4 EOL26\n#define LEN5 EOL25\n#define LEN6 EOL24\n#define LEN7 EOL23\n#define LEN8 EOL22\n#define LEN9 EOL21\n#define LEN10 EOL20\n#define LEN11 EOL19\n#define LEN12 EOL18\n#define LEN13 EOL17\n#define LEN14 EOL16\n#define LEN15 EOL15\n#define LEN16 EOL14\n#define LEN17 EOL13\n#define LEN18 EOL12\n#define LEN19 EOL11\n#define LEN20 EOL10\n#define LEN21 EOL9\n#define LEN22 EOL8\n#define LEN23 EOL7\n#define LEN24 EOL6\n#define LEN25 EOL5\n#define LEN26 EOL4\n#define LEN27 EOL3\n#define LEN28 EOL2\n#define LEN29 EOL1\n#define LEN30 EOL0\n\nvec2 uv = vec2(0);\nfloat text_color = float(0.0);\nconst float TEXT_COLOR = float(0.95);\nconst float TEXT_SIZE = 0.03;\nconst float TEXT_SIZE2 = 0.03 + 0.04/5.0;\nvec2 TEXT_POSITION = vec2(0.0);\n\nvoid text(int LINE[directions*2]) {\n \tfor(int i = 0; i < (directions*2); i++)\n        text_color = character(TEXT_COLOR, text_color, LINE[i], vec2(0,1) + TEXT_POSITION*vec2(1,-1) + vec2(TEXT_SIZE2 * float(i), 0.), TEXT_SIZE, uv);\n}\n\n#define TEXT(x,y) text(int[](x y));\n#define TEXT2(x) text(x);\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 10) {\n        fragColor = vec4(vec2(0), float(uint(iFrame)) / convert_length, pack_rule());\n        return;\n    }\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 last = textureLod(iChannel0, uv, 0.0f).gb;\n    uint frame = uint(last.y * convert_length);\n        \n    int bit = int( last.x * 7.0f );\n    \n    bit = max(0, bit - int(texelFetch( iChannel1, ivec2(KEY_LEFT,1),0 ).x)); // press\n    bit = min(directions - 1, bit + int(texelFetch( iChannel1, ivec2(KEY_RIGHT,1),0 ).x)); // press\n    \n    // selector\n    TEXT_POSITION = vec2(0.195f, 0.9925f);\n    {\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        binary[bit * 2] = 20;\n\n        TEXT2(binary);\n        \n        text_color *= 1.0f - max(sin(iTime * 9.0f), 0.0f);\n    }\n    \n    float frame_next = 0.0f;\n    \n    // digits\n    TEXT_POSITION = vec2(0.195f, 0.97f);\n    {\n        float r = textureLod(iChannel0, uv, 0.0f).a;\n        unpack_rule(rule, r);\n        \n        int dir = 0, reset = 0;\n        dir = int(texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x);\n        //reset |= dir & ~rule[bit];\n        rule[bit] |= dir;\n                \n        dir = int(texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x);\n        //reset |= dir & rule[bit];\n        rule[bit] &= ~dir;\n        \n        if (0 == reset) {\n        \n            bool moused = bool((iMouse.z * iTimeDelta) >= 0.5f);\n            frame_next = float(frame) + float(!moused) * (1.0f + iTimeDelta);\n            \n        }\n        \n        const int select[2] = int[2]( 15, 9 );\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        for (int n = 0 ; n < directions ; ++n) {\n            binary[n+n] = select[rule[n]];\n        }\n\n        TEXT2(binary);\n    }\n    \n    fragColor = vec4(text_color, float(bit) / 7.0f, frame_next / convert_length,\n                     pack_rule());\n}","name":"Buffer B","description":"","type":"buffer"}]}