{"ver":"0.1","info":{"id":"Xst3W7","date":"1450120282","viewed":1757,"name":"Floyd-Steinberg Dithering WIP","username":"104","description":"Broken implementation of 2D error-diffuse halftoning, but I didn't feel like continuing because it's so slow. Maybe I should stop making shaders that rely on progressively accumulating pixel data :D","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["dithering","errordiffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nconst vec2 gridSize = vec2(3.,3.);\n\nconst int arrSize = int(gridSize.x*gridSize.y);\nfloat errAcc[int(gridSize.x*gridSize.y)];\n\nint getIndex(vec2 p)\n{\n    int x = int(p.x);\n    int y = int(p.y);\n    if(x >= int(gridSize.x))\n        return -1;\n    if(y >= int(gridSize.y))\n        return -1;\n    if(x < 0)\n        return -1;\n    if(y < 0)\n        return -1;\n    \n    return int(x+(y*int(gridSize.x)));\n}\n\nfloat getValue(vec2 p)\n{\n    int index = getIndex(p);\n    if(index < 0) return 0.;\n    for(int _=0;_<arrSize;_++)\n        if(_==index)return errAcc[_];\n    return 0.;\n}\nvoid accValue(vec2 p, float value)\n{\n    int index = getIndex(p);\n    if(index < 0) return;\n    for(int _=0;_<arrSize;_++)\n        if(_==index){\n            errAcc[_]+=value;\n            return;\n        }\n}\n\nvoid mainImage( out vec4 o, in vec2 pix)\n{\n    // zero-initialize :(\n    for(int i = 0; i < arrSize; ++ i)\n        errAcc[i] = 0.;\n    \n    // for performance-reasons i can't accumulate the entire image. i use a local grid.\n    vec2 topLeftBound = floor(pix/gridSize)*gridSize;\n\n    float outpColor;\n    float errCarry = 0.;\n    for(float x = gridSize.x-1.; x >= 0.; --x)\n    {\n        for(float y = gridSize.y-1.; y >= 0.; --y)\n        {\n            vec2 absSamplePt = pix - vec2(x,y);\n            vec2 gridPos = absSamplePt - topLeftBound;\n            if(gridPos.x < 0.) continue;\n            if(gridPos.y < 0.) continue;\n\n            vec2 uv = absSamplePt/iResolution.xy;\n            vec3 oc = texture(iChannel0, uv).rgb;\n            float og = (oc.r+oc.g+oc.b)/3.;\n            \n            float err= getValue(gridPos);\n            float idealColorWithErr = og + err;\n            outpColor = step(0., idealColorWithErr-.5);\n            err = idealColorWithErr - outpColor;\n\n            //       *   7/16\n            // 3/16 5/16 1/16\n            \n            //accValue(gridPos+vec2(1,0), err);\n            \n            //accValue(gridPos+vec2(1,0), err*.5);\n            //accValue(gridPos+vec2(0,1), err*.5);\n\n            accValue(gridPos+vec2(1,0), err*(7./16.));\n            accValue(gridPos+vec2(-1,1), err*(3./16.));\n            accValue(gridPos+vec2(0,1), err*(5./16.));\n            accValue(gridPos+vec2(1,1), err*(1./16.));\n        }\n    }\n    o = vec4(outpColor);\n}\n\n\n","name":"","description":"","type":"image"}]}