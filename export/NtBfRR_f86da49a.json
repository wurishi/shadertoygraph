{"ver":"0.1","info":{"id":"NtBfRR","date":"1652980838","viewed":108,"name":"Pseudo Driving Simulator","username":"RedWool","description":"you just got your driving license\n\nFake 3D","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["car"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFake 3d! It uses a bunch of tricks such as a fish eye and boxes\nbecause I don't know how to make 3d stuff yet\n\nAlso some fractual brownian motion in the background for a\nnice space effect\n*/\n#define SIZE sin(iTime)*.1+1.\n\n//Helper functions\nmat2 rotate (float a)\n{\n    return mat2(cos(a), -sin(a), \n                sin(a), cos(a));\n}\n\nfloat hash (float v)\n{\n    return fract(sin(v)*82.301);\n}\n\nfloat hash (vec2 v)\n{\n    return hash(dot(v, vec2(12.3, 23.7)));\n}\n\nfloat noise(float v){\n    float i = floor(v);\n    return mix(hash(i),hash(i+1.),smoothstep(0.,1.,fract(v)));\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv), f = fract(uv), u = f*(f*(3.-2.*f));\n    \n    float \n    a = hash(i),\n    b = hash(i+vec2(1,0)),\n    c = hash(i+vec2(0,1)),\n    d = hash(i+vec2(1));\n    \n    return mix(a, b, u.x) + \n    (c - a) * u.y * (1.-u.x) +\n    (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 uv)\n{\n    float v, a = .5, f = 1., l = .5, r = 2.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        v += a*noise(uv*f+iTime*.2);\n        \n        a *= l;\n        f *= r;\n    }\n    \n    return v;\n}\n\nfloat circle (vec2 uv, vec2 c, float r)\n{\n    return step(length(uv - c), r);\n}\n\nfloat box (vec2 uv, vec2 c, vec2 xy)\n{\n    vec2 d = abs(c - uv);\n    return step(d.x,xy.x)*step(d.y,xy.y);\n}\n\nfloat tower (vec2 uv, vec2 c, vec2 hr)\n{\n    return max(box(uv, c, vec2(.1,abs(hr.x)))*.75, box(uv, c+vec2(0,hr.x), vec2(.1, hr.y)));\n}\n\n//Method to create \"3d\" cubes\nfloat angBuild (vec2 uv, float a, float x, float r)\n{\n    return tower(uv, vec2(x, sin(a)*r), vec2(sin(a), cos(a))*.1*abs(r));\n}\n\n void fish (out vec2 uv, float power)\n{\n    uv *= pow(power, length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv *= rotate((noise(iTime*.1)-.5)*1.5) * 5.;\n    fish(uv, 1.2); \n\n    //Varibles + planet draw\n    float xPos = 0., pct = .001, planet = circle(uv, vec2(0), SIZE);\n    bool flag = false;\n    \n    //Draw Cars\n    for (float i = 0.; i < 15.; i++)\n    {\n        vec2 s = uv * rotate((noise(i*.1+iTime*.3)-.5)*10.);\n        xPos = noise(i*.2+iTime*.5)*.1;\n        \n        float d = -iTime*3.+i*6.05, b = angBuild(s, d, xPos,cos(xPos)*SIZE*1.105);\n        if (pct <= b)\n        {\n            pct = b;\n            if(!flag && planet > .5 && cos(d) < 0.)\n            { pct = 0.;}\n            else\n            {flag = true;}\n        }\n    }\n    \n    \n    //Space Background\n    float l = length(uv), rad = pow(l/(SIZE*1.2),2.),\n    a = fbm(vec2(l,fbm(vec2(fbm(uv),uv.x))))+.2;\n    a *= a * a;\n    \n    vec3 col = vec3(1,.3,.3)*pct+ //Car\n    (vec3(0,1,0)*planet*(1.-rad)+ //Planet\n    (1.-planet)*(vec3(.1,.4,1)*a + (1.-a)*vec3(0,0,.1)))*(1.-pct); //Space Background\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}