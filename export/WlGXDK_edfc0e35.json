{"ver":"0.1","info":{"id":"WlGXDK","date":"1583553969","viewed":132,"name":"Sunset and sunrize","username":"ilyaev","description":"Sunset and sunrise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime / 2.\n#define FAR_DISTANCE 40.\n#define sunColor vec3(0.9, 0.3, 0.1)\n\nvec3 getDist(vec3 p) {\n    float material = 0.;\n    float planeB = p.y + 9.4 + sin(p.x/8. + t*4.)*3.;\n    float backPlane = -p.z + 30.4;\n\n    float dS = planeB;\n\n    dS = min(dS, backPlane);\n\n    if (dS == backPlane) {\n        material = 1.;\n    }\n\n    return vec3(dS, material, 1.);\n}\n\nvec4 trace(vec3 ro, vec3 rd) {\n    vec3 p;\n\n    float planeB, planeL, planeR, planeT, backPlane;\n    float material;\n    vec3 dist;\n\n    float dS, dO;\n\n    for(int i = 0 ; i < 100 ; i++) {\n        p = ro + rd * dO;\n\n        dist = getDist(p);\n        dS = dist.x;\n        material = dist.y;\n\n        if (dS < .001 || dS > FAR_DISTANCE) {\n            break;\n        }\n        dO += dS;\n    }\n    return vec4(dS, dO, dist.x, dist.y);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p).x;\n    vec3 n = d - vec3(getDist(p - e.xyy).x, getDist(p - e.yxy).x, getDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getColor(vec3 p, float material) {\n    vec3 col = vec3(0.);\n    if (material == 0.) {\n        float x = p.x;\n        float y = p.z + t * 25.;\n        col += step(.002, sin(y)*sin(x));\n    } else if (material == 1.) {\n        float h = sin(iTime/3.)*15.;\n        float flare = 5.9 - h/3.;\n        float size = 15.2 + h /3.;\n        col += pow(size/distance(p.xy, vec2(0.,h)), flare) * sunColor;\n    }\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, .2, -1);\n\n    vec3 lookat = vec3(0);\n\n    float zoom = .5;\n\n    vec3 f = normalize(lookat - ro); // forward vector\n    vec3 r = normalize(cross(vec3(0,1,0), f)); // right vector UP x F\n    vec3 u = cross(f, r); // camera UP\n    vec3 c = ro + f * zoom;  // center of virtual screen\n    vec3 i = c + uv.x * r + uv.y * u;// intersection point with virtual screen (camera)\n    vec3 rd = normalize(i - ro);\n\n    vec3 col = vec3(0);\n\n    vec4 tr = trace(ro, rd);\n\n    float dS = tr.x;\n    float dO = tr.y;\n    float material = tr.a;\n\n    vec3 p = ro + rd * dO;\n\n    if (dS < .001) {\n        col = getColor(p, material);\n        if (material == 0.) {\n            vec3 normal = getNormal(p);\n            vec3 rrd = reflect(rd, normal);\n            vec4 rhmap = trace(p + rrd*0.01, rrd);\n            vec3 rp = p + rrd*0.01 + rrd * rhmap.y;\n            vec3 rcol = getColor(rp, rhmap.a);\n            col = col * rcol*4.;\n        }\n\n    }\n\n    float fade = (1. - p.z/60.);\n\n    fragColor = vec4(col * fade, 1.);\n\tfragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2)); \n}","name":"Image","description":"","type":"image"}]}