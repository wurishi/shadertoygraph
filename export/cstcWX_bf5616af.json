{"ver":"0.1","info":{"id":"cstcWX","date":"1695585405","viewed":37,"name":"linear algebra learning","username":"pfhgil","description":"i`m learning linear algebra","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["linearalgebra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define HALF_PI PI / 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat2 originalBasis;\n    originalBasis[0] = vec2(1, 0);\n    originalBasis[1] = vec2(0, 1);\n    \n    // counter-clockwise rotation\n    //mat2 ccwBasis;\n    //ccwBasis[0] = vec2(0, -1);\n    //ccwBasis[1] = vec2(1, 0);\n    \n    // clockwise rotation\n    //mat2 cwBasis;\n    //cwBasis[0] = vec2(0, 1);\n    //cwBasis[1] = vec2(-1, 0);\n    \n    //mat2 scaleBasis;\n    //scaleBasis[0] = vec2(0.75, 0);\n    //scaleBasis[1] = vec2(0, 0.75);\n    \n    //mat2 shearBasis;\n    //shearBasis[0] = vec2(1, 1);\n    //shearBasis[1] = vec2(1, 0);\n    \n    //float angle = iTime * 0.2;\n    \n    // rotation using trigonometric circle\n    // first column is basis x-axis\n    // second column is basis y-axis\n    // on trigonometric circle cos and sin are opposite (on x or y axis)\n    // angle must be in radians\n    //mat2 trueRotationBasis;\n    //trueRotationBasis[0] = vec2(cos(angle), -sin(angle));\n    //trueRotationBasis[1] = vec2(sin(angle), cos(angle));\n    \n    // -------------------------------------------------\n    \n    float angle = iTime * 2.0;\n\n    vec2 uv = (fragCoord / iResolution.xx);\n    //vec2 uv = ccwBasis * cwBasis * (fragCoord / iResolution.xy);\n    \n    \n    //vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n\n    const vec2 circlePos = vec2(0.5, 0.3);\n    const float circleRadius = 0.05;\n\n    if(distance(uv, circlePos) <= circleRadius)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    // --------------\n    \n    const vec2 circlePos1 = vec2(0.05, 0.4);\n    const float circleRadius1 = 0.02;\n    \n    if(distance(uv, circlePos1) <= circleRadius1)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    // --------------\n\n    mat2 circle0Basis;\n    circle0Basis[0] = vec2(circlePos.x, 0.0);\n    circle0Basis[1] = vec2(0, circlePos.y);\n    \n    const vec2 circlePos0 = vec2(0.1, 0.0);\n    const float circleRadius0 = 0.02;\n    \n    const float rotRad = 2.5;\n    \n    vec2 dif = normalize(circlePos1 - circle0Basis * circlePos0);\n    \n    mat2 trueRotationBasis;\n    trueRotationBasis[0] = vec2(cos(dif.x), -sin(dif.x));\n    trueRotationBasis[1] = vec2(sin(dif.y), cos(dif.y));\n    \n    mat2 basisMatrix;\n    basisMatrix[0] = vec2(1.0, 0.0);\n    basisMatrix[1] = vec2(0.0, 1.0);\n    \n    if(distance(uv, circlePos + trueRotationBasis * circlePos0) <= circleRadius0)\n    {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}