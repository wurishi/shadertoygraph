{"ver":"0.1","info":{"id":"NdKBRt","date":"1658693040","viewed":741,"name":"Tiles flipper loop","username":"Bleuje","description":"Shader version of this gif made with Processing : https://twitter.com/etiennejcb/status/1545772780129492994","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","colorful","repetition","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n\n#define PI 3.141592\n#define duration 2.3\n\nfloat time;\nfloat boxSize;\nfloat spacing = 2.25;\nfloat numberOfFlips = 4.;\n\n// box sdf with bevel\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-0.007;\n}\n\n// 2D Rotation matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n// easing function, may come from @patakk\nfloat ease(float p, float g) {\n  if (p < 0.5) \n    return 0.5 * pow(2.*p, g);\n  else\n    return 1. - 0.5 * pow(2.*(1. - p), g);\n}\n\nvec3 flipPosition(vec3 q,float floatState,vec2 qIndices)\n{\n    float param = floatState/numberOfFlips;\n    param = mod(param+12345.,1.);\n    \n    vec2 qIndices2 = boxSize*qIndices;\n    \n    float delay = 0.015*max(0.,length(qIndices2)-0.15) + 0.2*pow(length(qIndices2),0.3+0.3*pow(param,0.3))*pow(param,1.3);\n    delay *= 1.2;\n    \n    float delayedP = max(0.,param-delay);\n    floatState = min(1.7*numberOfFlips*delayedP,numberOfFlips);\n    \n    float ii = mod(qIndices.x,2.0);\n    float jj = mod(qIndices.y,2.0);\n    \n    float easing = 2.5;\n    \n    if(floatState<=1.)\n    {\n        float flip1 = ease(clamp(floatState-0.,0.,1.),easing);\n        if(ii==0.)\n            q.xy *= rot(PI*flip1);\n    \n        if(ii==1.)\n            q.xy *= rot(-PI*flip1);\n    \n    }\n    \n    else if(floatState<=2.)\n    {\n        float flip2 = ease(clamp(floatState-1.,0.,1.),easing);\n        q.xy *= rot(-PI*flip2);\n    }\n    else if(floatState<=3.)\n    {\n        float flip3 = ease(clamp(floatState-2.,0.,1.),easing);\n        if(ii==0. && jj==0.)\n            q.xy *= rot(PI*flip3);\n\n        if(ii==1. && jj==0.)\n            q.xy *= rot(-PI*flip3);\n\n        if(ii==0. && jj==1.)\n            q.zy *= rot(PI*flip3);\n\n        if(ii==1. && jj==1.)\n            q.zy *= rot(-PI*flip3);\n    }\n    else if(floatState<=4.)\n    {\n        float flip4 = ease(clamp(floatState-3.,0.,1.),easing);\n        if(ii==0.)\n            q.zy *= rot(PI*flip4);\n    \n        if(ii==1.)\n            q.zy *= rot(-PI*flip4);\n    \n    }\n\n    return q;\n}\n\nstruct MapData\n{\n    float typeId;\n    float dist;\n    vec2 uv;\n    vec2 cubePos;\n};\n\n\nMapData map(vec3 p) {\n    MapData res;\n    \n    res.dist = 1000.;\n    \n    p.yz *= rot(atan(1./sqrt(2.)));\n    p.xz *= rot(0.25*PI);\n\n    vec3 q = p;\n    \n    float repetitionDistance = spacing*boxSize;\n    // very minor optim, this is constant later on\n    vec2 pxz0 = mod(p.xz + repetitionDistance*.5, repetitionDistance) - repetitionDistance*.5; \n    \n    // min distance with neighbours\n    for(float i=-1.;i<=1.;i+=1.)\n    {\n        for(float j=-1.;j<=1.;j+=1.)\n        {\n            // possible optimization\n            //if(abs(i)+abs(j)>=2.) continue;\n            \n            // offset for neighbour location\n            vec3 correctionOffset = vec3(spacing*boxSize*i,0.,spacing*boxSize*j);\n            \n            p = vec3(pxz0.x,q.y,pxz0.y);\n\n            // block indices\n            vec2 qi = floor((q.xz + correctionOffset.xz +0.5*vec2(repetitionDistance))/repetitionDistance);\n\n            p = flipPosition(p - correctionOffset, time, qi);\n\n            float boxDistance = sdBox(p,vec3(boxSize,boxSize/10.0,boxSize));\n            \n            res.dist = min(res.dist,boxDistance);\n            \n            if(i==0.&&j==0.)\n            {\n                res.typeId = 1.;\n                res.uv = p.xz;\n                res.cubePos = qi;\n            }\n        }\n    }\n    \n    return res;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\n\n// found in tdhooper shader : https://www.shadertoy.com/view/fdSGRy\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n    \n    time = mod(iTime/duration,numberOfFlips);\n    boxSize = 0.27;\n\n\tvec3 ro=vec3(uv*4.,-10.), rd=vec3(0.,0.0,1.);\n    \n\tvec3 p;\n\tMapData res;\n\tfloat ri, t = 0.;\n    bool hit = false;\n    vec3 nrml;\n    \n    // raymarching\n\tfor (float i = 0.; i < 1.; i += 1.0/44.0) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tres = map(p);\n\t\tif (res.dist<.001)\n        {\n            hit = true;\n            nrml = getNormal(p);\n            break;\n        }\n        t += res.dist*0.98;\n\t}\n    \n    vec2 uuvv = res.uv;\n\n    // cube edges factor\n    float squareDistance = max(abs(uuvv.x),abs(uuvv.y));\n    float f_edges = 0.1+1.4*smoothstep(0.96*boxSize,0.99*boxSize,squareDistance);\n\n    // factor for stripes on cube faces\n    float a = 1.0;\n    float b = 0.6;\n    float v = clamp((mod(4.0*max(abs(uuvv.x),abs(uuvv.y))/boxSize,a)-b)/(a-b),0.,1.);\n    float f_stripes = 1.5*sin(PI*v);\n\n    // color info with number of raymarching iterations, distance and previous factors\n    float mixer = pow(ri,1.7)/(t*t)*1600.0*max(f_edges,f_stripes);\n    \n    // background color (effects will be applied on it later in the code)\n    vec3 col = vec3(0.6,0.9,0.9) - vec3(length(uv)*0.6);\n    \n    // color experiments ...\n    \n    if(hit)\n    {\n        vec3 col1 = vec3(0.5)+0.5*nrml;\n        vec3 col2 = col1.zxy;\n        col = mix(col1,col2,mixer);\n    }\n    \n    vec3 col0 = col;\n    \n    col = col.yxz;\n    \n    // (https://www.shadertoy.com/view/fdSGRy)\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007)/3.;\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = pow( col, vec3(1./2.2) );\n    col = aces(col);\n    \n    col = mix(col,col0,0.15);\n\n\tfragColor = vec4(col.zyx, 1.);\n}","name":"Image","description":"","type":"image"}]}