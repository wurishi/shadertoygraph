{"ver":"0.1","info":{"id":"lsGSWh","date":"1464013975","viewed":130,"name":"Raymarching v1","username":"Tandaradeii","description":"First experiments with raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","beginner","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 256\n#define MAXDISTANCE 100.0\n#define EPSILON 0.001\n#define LIGHT vec3(5.0, 10.0, 0.0)\n#define BACKGROUNDCOLOR vec4(0.0, 0.2, 0.4, 1.0)\n\nstruct Sphere\n{\n\tvec3 position;\n    float radius;\n};\n\nfloat mapSphere(in Sphere s, in vec3 p)\n{\n    return length(p - s.position) - s.radius;   \n}\n\nfloat mapBetweenSpheres(in Sphere s1, in Sphere s2, in vec3 p)\n{\n\treturn abs((length(p - s1.position) - s1.radius)-(length(p - s2.position) - s2.radius)) - 0.5;   \n}\n\nfloat map(in vec3 p)\n{\n    Sphere s1;\n    s1.position = vec3(4.0 * sin(iTime), 4.0 - 2.0 * cos(iTime * 0.5), 4.0);\n    s1.radius = 1.0;\n    Sphere s2;\n    s2.position = vec3(2.0 * sin(iTime), 2.0 + cos(iTime * 0.5), 5.0);\n    s2.radius = 1.0;\n\tfloat dToS1 = mapSphere(s1, p);\n    float dToS2 = mapSphere(s2, p);\n    float dToS = min(dToS1, dToS2);\n    //float dToS = min(dToS, dToS1)\n    return min(dToS, p.y - sin(p.x) * cos(p.z) * 0.4);\n}\n\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < MAXSTEPS-1; ++i){\n    \tvec3 p = ro + rd * t;\n        float d = map(p);\n        if(d < EPSILON || t >= MAXDISTANCE){\n        \tbreak;\n        }\n        t += d;\n    }\n    return t;\n\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float t = 0.0 + 100.0 * EPSILON;\n    float res = 1.0;\n    for(int i = 0; i < MAXSTEPS; ++i) {\n        float d = map(ro + rd * t);\n        if(d < EPSILON) {\n            return 0.0;\n        }\n        res = min( res, k*d/t );\n        t += d;\n    }\n    return res;\n    \n}\n\nfloat lerp(float a, float b, float w)\n{\n    return a * w + b * (1.0 - w);\n}\n\nvec3 lerpVec3(vec3 a, vec3 b, float w)\n{\n\treturn vec3(lerp(a.x, b.x, w),\n               lerp(a.y, b.y, w),\n               lerp(a.z, b.z, w));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.xy = uv.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = BACKGROUNDCOLOR * ((uv.y + 1.0) / 2.0);\n    \n    vec3 ro = vec3(0.0, 2.0 + cos(iTime * 0.6), 3.0 * sin(iTime * 0.2));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float t = trace(ro, rd);\n    \n    vec3 p = ro + rd * t;\n    \n    if(t < MAXDISTANCE) {\n    \tvec3 lightDirection = normalize(LIGHT - p);\n        float dotProduct = dot(normal(p), lightDirection);\n        float ss = softShadow(p, lightDirection, 16.0);\n        fragColor = vec4(lerpVec3(vec3(BACKGROUNDCOLOR.xyz), \n                                  vec3(1.0), \n                                  t/MAXDISTANCE) \n                         * dotProduct * ss, 1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}