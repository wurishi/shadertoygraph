{"ver":"0.1","info":{"id":"dsXSR7","date":"1668630772","viewed":92,"name":"Mandelbrot Mosaic Power","username":"PhDFractal","description":"Comparison of Absolute vs. Julia Set mosaic of Mandelbrot power. Each tile has a Absolute or Julia Set at its seed at the center of its tile.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot","morph","power","mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Mandelbrot Mosaic\n//\n// Comparison of Absolute vs. Julia Set mosaic of Mandelbrot power.\n//\n// Created by PhdFractal, 8/11/2022\n//\n// Drag mouse on the screen to change the Mandelbrot power.\n//\n// Press 'a' to go to absolute. Compare the change in the mosaic.\n//\n// Press '←' or '→' to change the mosaic size.\n//\n// If the size is close to iResolution.x/3 (320±1 on most screens) then\n// the mosaic tile is pixel size, and resonance occurs. The apparent size\n// will be |size-iResolution.x/3| and each apparent fractal will appear:\n// 1. in Julia mode as quasi-Mandelbrot sets with various initial z0 values;\n// 2. in Absolute mode as conformally distorted Absolute Julias with various\n//    conformal distortion centers and skewnesses.\n//\n// Bailout is 4, but the apparent bailout in the mosaics may be higher (≈128).\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by PhdFractal: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal (@Fractal MathPro)\".\n\nvec2 powers(vec2 z,float power){  //power\n    float magn=sqrt(z.x*z.x+z.y*z.y);\n    if(magn==0.) { return vec2(0.,0.); }\n    float arg=acos(z.x/magn);\n    if(z.y>=0.){ return pow(magn,power)*vec2(cos(power*arg),sin(power*arg)); }\n    else{ return pow(magn,power)*vec2(cos(power*arg),-sin(power*arg)); }\n}\nvec2 rounds(vec2 z){ return vec2(round(z.x),round(z.y)); }\nfloat phi(float t){ return t/2.+t*abs(t)/10.; }                                    //power switching quicker at the ends\n\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }  //for switching modes\nvec4 store(int i,int j) { return texelFetch(iChannel1,ivec2(i,j),0); }             //for counting presses\nint keycount(int key) { return int(store(0,key).x); }                              \n//from Wythoffian Tiling Generator: https://www.shadertoy.com/view/wlGSWc\nvec4 rainbow(int i,float density){                                                 //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    int r=int(float(i)*density+5.)%100;\n    if(r<16){ float R=float(r)/16.; return R*red+(1.-R)*black; }\n    else if(r>=16 && r<31){ float R=float(r-16)/15.; return R*yellow+(1.-R)*red; }\n    else if(r>=31 && r<45){ float R=float(r-31)/14.; return R*green+(1.-R)*yellow; }\n    else if(r>=45 && r<62){ float R=float(r-45)/17.; return R*cyan+(1.-R)*green; }\n    else if(r>=62 && r<78){ float R=float(r-62)/16.; return R*blue+(1.-R)*cyan; }\n    else{ float R=float(r-78)/22.; return R*black+(1.-R)*blue; }\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    bool isAbsolute=keypress(65);                           //Press key 'a' for absolute\n    bool resonance=keypress(82);                            //Press key 'r' for resonance=iResolution.x/3±1\n    bool negative=keypress(78);                             //WHEN USING RESONANCE: press key 'n' to switch to negative\n    float mode=1.;\n    if(!resonance) { mode=float(1+abs(keycount(39)-keycount(37))); }//Press 'left' or 'right' to change mosaic size.\n    else{\n        if(!negative) { mode=float(iResolution.x)/3.+1.; }\n        else { mode=float(iResolution.x)/3.-1.; } }\n    vec4 color=vec4(0.,0.,0.,1.);    \n    vec2 pix=3.*(fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x));\n    float power=0.5+phi(15.*(iMouse.x/iResolution.x-0.5)); //sigmoidal to accelerate at the ends\n    if(power>0.){                   //positive power\n        vec2 z0=vec2(0.,0.);\n        if(isAbsolute){             //absolute mosaic\n            for(int i=0; i<250; i++){\n                vec2 z=powers(z0,power)+powers(2.*(pix*mode-rounds(pix*mode)),power)+rounds(pix*mode)/mode;\n                if(dot(z,z)>4.){ color=rainbow(i,2.5); break; }\n                else{ z0=z; } } }\n        else{                       //julia mosaic\n            z0=2.*(pix*mode-rounds(pix*mode));\n            for(int i=0; i<250; i++){\n                vec2 z=powers(z0,power)+rounds(pix*mode)/mode;\n                if(dot(z,z)>4.){ color=rainbow(i,2.); break; }\n                else{ z0=z; } } } }\n    else{                           //negative power\n        vec2 z0=vec2(1e7,0.);\n        if(isAbsolute){             //absolute mosaic\n            for(int i=0; i<250; i++){\n                vec2 z=powers(z0,power)+powers(4.*(pix*mode-rounds(pix*mode)),power)+rounds(pix*mode)/mode;\n                if(dot(z,z)>4.){ color=rainbow(i,2.5); break; }\n                else{ z0=z; } } }\n        else{                       //julia mosaic\n            z0=4.*(pix*mode-rounds(pix*mode));\n            for(int i=0; i<250; i++){\n                vec2 z=powers(z0,power)+rounds(pix*mode)/mode;\n                if(dot(z,z)>4.){ color=rainbow(i,2.5); break; }\n                else{ z0=z; } } } }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define keystate(k,n) (texelFetch(iChannel0,ivec2(k,n),0))\nvoid mainImage(out vec4 t,vec2 uv){\n#if __VERSION__ < 300\n    t = vec4(0);\n#else    \n    int i=int(uv.x); int j=int(uv.y);\n    if(iFrame==0) { t=vec4(0); }\n    else{ t=texelFetch(iChannel1,ivec2(i,j),0); } //Get current state\n    if(i==0){ float w1 = keystate(j,2).x;\n        if (w1!=t.w) { t.w=w1; t.x++; } }\n#endif           \n}","name":"Buffer A","description":"","type":"buffer"}]}