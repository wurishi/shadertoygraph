{"ver":"0.1","info":{"id":"4d2GRD","date":"1498319832","viewed":373,"name":"many spheres","username":"kig","description":"bounding sphere hierarchy of doom, oculus things, fogs","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","spheres","bvh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TRANSPARENCY\n#define SHADOWS\n#define SECOND_BOUNCE\n#define ANTIALIAS\n#define ANTIALIAS_4X\n//#define SHOW_BV\n//#define SHOW_AA\n//#define OCULUS\n#define SAILS\n\n#define FOG_D 120.0\n\n#define L_COUNT 1.0\n#define M_COUNT 1.0\n#define N_COUNT 3.0\n#define I_COUNT 3.0\n#define J_COUNT 3.0\n\nstruct tSphere {\n\tvec3 center;\n\tfloat radius;\n\tvec3 color;\n\tfloat spec;\n};\n\n// return ray p,d distance to triangle v0,v1,v2\n// returns -1.0 if no intersection\n// writes UV value to the uv vector\nfloat rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tuv = vec2(u,v);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn -1.0;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\tfloat m = float(t <= 0.00001 || (a > -0.00001 && a < 0.00001));\n\t\n\tt = mix(t, -1.0, m);\n\t\n\treturn t;\n\n}\n\n\nfloat raySphereDet(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\nbool rayBV(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(ray, dir, center, radius, closestHit, b);\n\tif (d < 0.0) {\n\t\treturn true;\n\t};\n\tfloat t = -b - sqrt(d);\n\treturn (t < -(2.0*radius) || t > closestHit+(2.0*radius));\n}\n\nfloat rayIntersectsSphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(ray, dir, center, radius, closestHit, b); // 7\n\tif (d < 0.0) { // 1\n\t\treturn -1.0;\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\tif (t < 0.0 || t > closestHit) { // 2\n\t\treturn -1.0;\n\t} else {\n\t\treturn t;\n\t}\n}\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat intersect(inout vec3 ray, vec3 dir, inout vec3 nml, inout tSphere sphere, inout float doAA, inout float pick)\n{\n\tfloat dist = 5000.0;\n\n\tsphere.radius = doAA = -2.0;\n\tsphere.center = ray+dist*dir;\n\tnml = -dir;\n\tpick = -1.0;\n\n\tfloat time = iTime*0.1 + 450.0;\n\t\n\tfloat b,k,d;\n\tfloat aaBorder = 1.15;\n\n\tfloat l=0.0,m=0.0,n=0.0;\n\tfloat tl = l+time;\n\tvec3 mContrib = vec3(0.0, 0.0, 8.0) + (vec3(sin(tl), -sin(tl), -cos(tl)) * 80.0*ceil(l/8.0));\n\n\tfor (float n=0.0; n<N_COUNT; n++) {\n\t\tfloat r = min(n, 1.0)*10.0;\n\t\tfloat tn = time + (n*6.28/9.0);\n\t\tvec3 nContrib = mContrib + (vec3(sin(tn), -cos(tn), -cos(tn))*r);\n\t\tif (rayBV(ray, dir, nContrib, 14.0, dist)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdoAA = max(doAA, -0.5);\n\n\t\tfor (float i=0.0; i<I_COUNT; i++) {\n\t\t\tfloat ikOff = sin(time+i)*5.0;\n\t\t\tfloat sikOff = cos(time+i)*5.0;\n\t\t\tvec3 iContrib = nContrib + vec3(ikOff, sikOff, ikOff);\n\t\t\tif (rayBV(ray, dir, iContrib, 7.0, dist)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdoAA = max(doAA, -0.3);\n\t\t\tfor (float j=0.0; j<J_COUNT; j++) {\n\t\t\t\tfloat kOff = + cos(time*5.0+j)*2.5;\n\t\t\t\tfloat skOff = - sin(time*5.0+j)*2.5;\n\t\t\t\tk = l*(M_COUNT*N_COUNT*I_COUNT*J_COUNT) + m*(N_COUNT*I_COUNT*J_COUNT) + n*(I_COUNT*J_COUNT) + i*J_COUNT + j;\n\t\t\t\tr = 1.35+cos(k);\n\t\t\t\tvec3 cen = iContrib + vec3(kOff, skOff, kOff);\n\t\n\t#ifdef SAILS\n\t\t\t\t// Do sails first since they're occluded by the sphere.\n\t\t\t\t\n\t\t\t\tvec3 px = vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 py = vec3(0.0, 1.0, 0.0);\n\t\t\t\tvec3 pz = vec3(0.0, 0.0, 1.0);\n\t\t\t\t\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sail intersect\n\t\t\t\tif (!rayBV(ray, dir, cen, r*2.5, dist)) {\n\t\t\t\t\t\n\t\t\t\t\tvec3 p1 = cen - py*2.25*r - px*0.2*r;\n\t\t\t\t\tvec3 p2 = cen + py*2.25*r - px*0.2*r;\n\t\t\t\t\tvec3 p3 = cen + py*0.0*r + px*0.2*r;\n\t\t\t\t\tvec2 uv, one = vec2(1.0, 1.0);\n\t\t\t\t\tfloat t = rayIntersectsTriangle(ray, dir, p2, p3, p1, uv);\n\t\t\t\t\tfloat uvD = uv.x+uv.y;\n\t\t\t\t\tif (uv.x > -0.1 && uv.x < 1.1 && uv.y > -0.1 && uv.y < 1.1 && uvD < 1.1) {\n\t\t\t\t\t\tdoAA = max(0.0, doAA);\n\t\t\t\t\t}\n\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\tsphere.radius = 100.0;\n\t\t\t\t\t\tnml = pz;\n\t\t\t\t\t\tif(dot(nml, dir) < 0.0) {\n\t\t\t\t\t\t\tnml = -nml;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsphere.center = p1;\n\t\t\t\t\t\tsphere.color = vec3(0.5, 0.1, 0.05); //texture(iChannel0, uv).rgb;\n\t\t\t\t\t\t// Switch off AA for points inside the triangle.\n\t\t\t\t\t\tif (uv.x > 0.1 && uv.x < 0.9 && uv.y > 0.1 && uv.y < 0.9) {\n\t\t\t\t\t\t\tdoAA = -0.1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsphere.spec = 8.0;\n\t\t\t\t\t\tpick = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t#endif\n\t\n\t\t\t\td = raySphereDet(ray, dir, cen, r*aaBorder, dist, b);\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sphere intersect\n\t\t\t\tif (d > 0.0 && -b - sqrt(d) > -r*aaBorder) {\n\t\t\t\t\tdoAA = max(doAA, 0.0);\n\t\t\t\t\t// d = b*b - dot(rc,rc) + (r*r)*(aaBorder*aaBorder)\n\t\t\t\t\t// eliminate aaBorder^2 by\n\t\t\t\t\t// d_r = b^2 - rc^2 + r^2 * aaBorder^2 - r^2 * aaBorder^2 + r^2\n\t\t\t\t\t//     = b^2 - rc^2 + r^2\n\t\t\t\t\t// rewrite -r^2 * aaBorder^2 + r^2 = -r^2 * (aaBorder^2 - 1)\n\t\t\t\t\td = d - (r*r)*(aaBorder*aaBorder - 1.0);\n\t\t\t\t\tif (d > 0.0) {\n\t\t\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\t\tsphere.radius = r;\n\t\t\t\t\t\t\tsphere.center = cen;\n\t\t\t\t\t\t\tnml = normalize(sphere.center - ray - dist*dir);\n\t\t\t\t\t\t\tfloat odd = mod(n+j, 2.0);\n\t\t\t\t\t\t\tfloat ay = abs(nml.y);\n\t\t\t\t\t\t\tfloat fy = float(ay < 0.05 || (ay > 0.75 && ay < 0.78));\n\t\t\t\t\t\t\tsphere.color = mix(vec3(0.95, 0.8, 0.7), vec3(0.2), fy);\n\t\t\t\t\t\t\tsphere.color = mix(vec3(0.1), sphere.color, odd);\n\t\t\t\t\t\t\t// Switch off AA for points inside the sphere\n\t\t\t\t\t\t\tif (dot(nml, dir) > 0.4) {\n\t\t\t\t\t\t\t\tdoAA = -0.1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsphere.spec = mix(64.0, 8.0, odd);\n\t\t\t\t\t\t\tpick = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tray += dist*dir;\n\treturn dist;\n}\n\nfloat pickIntersect(vec3 ray, vec3 dir)\n{\n\ttSphere sphere;\n\tvec3 nml;\n\tfloat doAA, pick;\n\tfloat t = intersect(ray, dir, nml, sphere, doAA, pick);\n\treturn pick;\n}\n\n\n\n\nvec3 shadeBg(vec3 dir, vec3 nml)\n{\nvec3 lightPos_ = vec3(\n\t-cos(iTime*0.1)*-8.5, \n\t3.5+sin(iTime*0.05)*3.0, \n\t-(sin(iTime*0.1)*4.0-5.4)\n);\nvec3 bgLight = normalize(lightPos_);\nvec3 lightPos = bgLight * 9999.0;\n\n\tvec3 sun = vec3(2.0, 1.5, 1.0);\n\tvec3 bgCol = vec3(0.35, 0.45, 0.55);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = max(dot(nml, bgLight), 0.0);\n\tbgCol *= max(0.0, 1.0-0.15*sunPow+bgDiff);\n\tbgCol += pow( max(0.0, 0.15*sunPow-bgDiff), 1.5 ) * vec3(0.9, 0.6, 0.5);\n\tbgCol += sun*pow( sunPow, abs(bgLight.y)*64.0);\n\treturn bgCol;\n}\n\nvec3 shade(vec3 ray, vec3 dir, vec3 nml, float dist, tSphere sphere, inout float doAA)\n{\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\tvec3 bgCol = shadeBg(dir, dir);\n\tif (sphere.radius > 0.0) {\n\t\t\t\t\n\t\ttSphere s;\n#ifdef SHADOWS\n\t\tvec3 shadow = ray-nml*0.0001, snml = vec3(0.0);\n\t\tfloat pick;\nvec3 lightPos_ = vec3(\n\t-cos(iTime*0.1)*-8.5, \n\t3.5+sin(iTime*0.05)*3.0, \n\t-(sin(iTime*0.1)*4.0-5.4)\n);\nvec3 bgLight = normalize(lightPos_);\nvec3 lightPos = bgLight * 9999.0;\n\n\t\tfloat lightDist = length(lightPos - ray);\n\t\tfloat sdist = intersect(shadow, normalize(lightPos - shadow), snml, s, doAA, pick);\n\t\tif (sdist > lightDist) {\n\t\t\ts.radius = -1.0;\n\t\t}\n#else\n\t\ts.radius = -1.0;\n#endif\n\t\tvec3 light = normalize(lightPos - ray);\n\t\tvec3 specCol = sphere.color + vec3(0.3-min(0.29, length(sphere.color)));\n\t\t// lighting\n\t\tcol = sphere.color;\n\t\tfloat diff = max(0.0, dot(nml, -light));\n\t\tvec3 ref = reflect(dir, nml);\n\t\tfloat spec = max(dot(ref, light), 0.0);\n\t\tspec = pow(spec, abs(sphere.spec));\n\t\t\n\t\tcol *= diff;\n\t\tfloat inShadow = float(s.radius > 0.0);\n\t\tcol = mix(col+specCol*(spec*2.0), col*0.1, inShadow);\n\t\t\n\t\t\n\t\tfloat a = 1.0 - abs(dot(dir, nml));\n\t\tif (sphere.spec < 0.0) {\n\t\t\tcol += a * vec3(2.5, 1.6, 1.3);\n\t\t}\n\t\t\n\t\tfloat fog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\tfog *= fog;\n\t\tcol = (1.0-fog)*col + fog*bgCol;\n\t} else {\n\t\tcol = bgCol;\n\t}\n\n\treturn col;\n}\n\n#ifdef OCULUS\nvec2 hmdWarp(vec2 texIn) {\n\tvec2 u_lensCenter = vec2(0.0, 0.0);\n\tvec2 u_scaleIn = vec2(0.45, 0.7);\n\tvec2 u_scale = vec2(0.7);\n\tvec4 u_hmdWarpParam = vec4(0.7);\n\tvec2 u_screenCenter = vec2(0.0);\n\tvec2 u_lensCenter;\n\tif (texIn.x > 0.0) {\n\t\tu_lensCenter = vec2(-0.05, 0.0);\n\t\ttexIn.x = (0.85 - texIn.x);\n\t} else {\n\t\tu_lensCenter = vec2(0.05, 0.0);\n\t\ttexIn.x = (-0.85 - texIn.x);\n\t}\n\tvec2 theta = (texIn - u_lensCenter) * u_scaleIn;\n\tfloat rSq = theta.x * theta.x + theta.y * theta.y;\n\tvec2 theta1 = theta * (u_hmdWarpParam.x + u_hmdWarpParam.y * rSq + \n\t\tu_hmdWarpParam.z * rSq * rSq + u_hmdWarpParam.w * rSq * rSq * rSq);\n\treturn u_lensCenter + u_scale * theta1;\n}\n#endif\n\nvec3 getDir(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n#ifdef OCULUS\t\n\tvec2 tc = hmdWarp(uv);\n\tuv = tc;\n\tuv.x *= iResolution.x / iResolution.y;\n#endif\n\t\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.xy = rotate(dir.xy, cos(iTime*0.1));\n\tdir.xz = rotate(dir.xz, sin(iTime*0.15));\n\treturn dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat xOff = 0.0;\n#ifdef OCULUS\n\txOff = 1.0;\n\tif (fragCoord.x < iResolution.x*0.5) xOff = -1.0;\n#endif\n\n\tvec3 eye = vec3(-xOff*0.5, -0.0, -30.0);\n\t//eye.xy = rotate(eye.xy, 0.5*sin(iTime));\n\n\tvec3 mdir, dir;\n\tmdir = getDir(iMouse.zw);\n\t\n\tvec3 ray = eye;\n\tvec3 nml = vec3(0.0);\n\t\t\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\t\n\ttSphere sphere;\n\tfloat doAA;\n\tfloat doAA_;\n\t\n\tfloat picked = -2.0;\n\tfloat k = 0.0;\n\n\tfor (float x = 0.0; x < 2.0; x++) {\n\t\tfor (float y = 0.0; y < 2.0; y++) {\n\n#ifndef ANTIALIAS_4X\n\t\t\tif (x + y == 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tk++;\n\n\t\t\tvec2 d = (vec2(x, y) * 0.33) - vec2(0.5);\n\n\t\t\tray = eye;\n\n\t\t\tdir = getDir(fragCoord.xy+d);\n\n\t\t\tfloat target = -1.0;\n\t\t\tfloat dist = intersect(ray, dir, nml, sphere, doAA, target);\n\t\t\tfloat fog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\t\tfog *= fog;\n\n\t\t\tif (picked == -2.0 && target >= 0.0 && iMouse.z > 1.0) { \n\t\t\t\tpicked = pickIntersect(eye, mdir);\n\t\t\t}\n\t\t\t\n\t\t\tvec3 ref = dir;\n\t\t\tvec3 ncol = vec3(0.1);\n\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\tncol = shade(ray, ref, nml, dist, sphere, doAA_);\n\n\t\t\tif ( sphere.radius > 0.0 )\n\t\t\t{\n\t\t\t\tvec3 diff = sphere.color; //normalize(sphere.color+vec3(0.01));\n\t\t\t\tref = reflect(ref, nml);\n\t\t\t\t// transparency\n#ifdef TRANSPARENCY\n\t\t\t\tif (sphere.radius < 100.0 && sphere.color.r < 0.2) {\n\t\t\t\t\tvec3 ray2 = ray;\n\t\t\t\t\tvec3 ref2 = refract(dir, nml*0.5, 0.04);\n\t\t\t\t\tray2 += ref2*sphere.radius*1.01;\n\t\t\t\t\tfloat tdist = intersect(ray2, dir, nml, sphere, doAA_, target);\n\t\t\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\t\t\tvec3 tcol = shade(ray2, dir, nml, dist+tdist, sphere, doAA_);\n\t\t\t\t\tncol = mix(tcol, ncol, 0.5);\n\t\t\t\t\tdiff *= vec3(0.5);\n\t\t\t\t}\n#endif\n\t\t\t\t// reflection\n                ray += ref * 0.0001;\n\t\t\t\tdist = intersect(ray, ref, nml, sphere, doAA_, target);\n\t\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\t\tncol += (1.0-fog) * 0.6 * diff * shade(ray, ref, nml, dist, sphere, doAA_);\n\t\t\t\tfog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\t\t\tfog *= fog;\n\t\t\t\t// second reflection\n#ifdef SECOND_BOUNCE\n\t\t\t\tif (sphere.radius > 0.0) {\n\t\t\t\t\tdiff = sphere.color;\n\t\t\t\t\tref = reflect(ref, nml);\n\t                ray += ref * 0.0001;\n\t\t\t\t\tdist = intersect(ray, ref, nml, sphere, doAA_, target);\n\t\t\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\t\t\tncol += (1.0-fog) * 0.6 * diff * shade(ray, ref, nml, dist, sphere, doAA_);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\n\t\t\tcol += max(vec3(0.0), ncol);\n\t\t\t\n\t\t\tif (doAA < 0.0) {\n#ifdef SHOW_BV\n\t\t\t\tcol += vec3(0.05)*doAA;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef ANTIALIAS\n\t\t\tbreak;\n#endif\n#ifdef SHOW_AA\n\t\t\tcol += vec3(0.5, 0.0, 0.5);\n#endif\n\t\t}\n\t}\n\t// gamma correction\n\tcol = 1.0 - exp((-col/k) * 3.5);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}