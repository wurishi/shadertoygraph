{"ver":"0.1","info":{"id":"MfXcWN","date":"1721140895","viewed":74,"name":"nested spirals","username":"pb","description":"using radius as phase factor to modify spherical polar coords, but the fractal formula creates the layers for some odd reason which I wish I understood","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","raymarch"],"hasliked":0,"parentid":"X3cXDj","parentname":"nested octahedrons 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n//logic taken from gaz: https://www.shadertoy.com/view/ftKBzt\n//and made more verbose and tweaked\n\n#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos( h + vec3(10,20,30) )*.7 + .5 )\n\n//formula for mapping scale factor \n#define M(c)  log(c)\n\n#define R iResolution\n\n\nfloat theta;\n\nvec3 sphRep(vec3 p) {\n\n    float r = length(p);\n    theta = acos( p.z/(1.+r));\n    float phi   = atanyx(p.y,p.x);\n    \n    float ph = r/60.;\n   \n    phi += iTime;\n    \n    return vec3( r*cos(theta), r*sin(theta)*cos(phi+ph), r*sin(theta)*sin(phi+ph) ); \n\n}\n\n\nvoid mainImage( out vec4 O, vec2 U) {\n  \n    O = vec4(0);\n    \n    vec3 c=vec3(0), rd = normalize( vec3(U-.5*R.xy, R.y))*900.;\n    \n    float sc,dotp,totdist=0., t=iTime/2.;\n   \n    float tx = mod(iTime,8.);\n    float tt = tx>4.? tx-4.:0.;\n    \n    for (float i=0.; i<150.; i++) {\n        \n        vec4 p = vec4( rd*totdist, 0.);\n        \n        p.xyz += vec3(1000,0,-2500);\n        sc = 1.;  //scale factor         \n          \n          \n        p.xz *= rot( t + 2.*sin(t*3.)) ;\n       \n        p.xyz = sphRep(p.xyz);\n        \n        for (float j=0.; j<7.; j++) {\n        \n            p =  log(.75+abs(p)) ;\n            \n            dotp = max(1./dot(p,p),.21);\n            sc *= dotp;\n      \n            p *= dotp - .77;\n           \n        }\n         \n        float dist =  abs( length(p)-.6)/sc ;  //funky distance estimate\n        float stepsize = dist/6. + 1e-4;     //distance plus a little extra\n        totdist += stepsize;              //move the distance along rd\n        \n        //if (theta > 3.14/2.)\n        //accumulate color, fading with distance and iteration count\n        c += mix( vec3(1), H(M(sc)),.9) *.05*  exp(-i*i*stepsize*stepsize*1e1);\n        \n        \n    }\n    \n    c = clamp(c,0.,1.);\n    c *= c;\n    \n    O = ( vec4(c,0) );\n    //this one needs some gaussian blur \n               \n}        \n  ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float pi = atan(1.)*4.;\nconst float two_pi = 2.0 * pi;\nconst float pi_over_2 = pi/2.;\nconst float too_small = 1e-2;\n\nfloat atanyx(float y, float x) {\n\n        float sign_y = 1.0;\n        if (y < 0.0) sign_y = -1.0;\n        \n        if (abs(x) < too_small) return sign_y * pi_over_2;\n\n        float atanyx = atan(y/x);\n\n        //we need to add multiple of pi depending on the quadrant\n        if (x>0. && y>=0.) {\n            return atanyx;\n        }\n        else if (x<0.) {\n            return pi + atanyx;\n        }\n        else {\n            return two_pi + atanyx;\n        }\n}\n\n","name":"Common","description":"","type":"common"}]}