{"ver":"0.1","info":{"id":"WlccRf","date":"1609600698","viewed":286,"name":"cubemap jfa","username":"Carandiru","description":"jumpflooding of a cube map\nnow someone has to show me how to raymarch it in some way.....","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["volumetric","cubemap","jfa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEPTH (mod(iTime, 11.0f))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 uv = u.xy / R.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n\trd.xz *= rot(PI*.5);   \n    \n    vec2 rotv = vec2(0);\n    if (iMouse.z > 0.0) {\n        rotv = vec2((iMouse.xy - iResolution.xy*0.5)*0.01);\n    } else {\n        rotv = vec2(iTime*0.1, sin(iTime*0.3)*0.3);\n    }\n    \n    mat2 rot1 = rot(rotv.x);\n    mat2 rot2 = rot(-rotv.y);\n    rd.xy *= rot2;\n    rd.xz *= rot1;\n    \n    vec4 T = texture(iChannel0, rd);\n    vec3 ld = normalize(T.xyz);\n    float d = T.a * DEPTH;\n    \n    vec3 color = vec3(d);\n    \n    // other vis:\n    //float att = (1.0f / (1.0f + d*d));\n    //color = vec3(pow(1.0f - att, d) * att);\n\n    //color = T.xyz * 0.5f + 0.5f;\n    \n    O = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// credit to demofox, thanks for the introduction to JFA\n// I'm reusing some of your code, albeit modified, as it works in shadertoy\n// and I was having trouble getting my code to be compatible with various browsers\n// JFA operation is just used in practice differently.\n// Thanks again.\n\n// how many JFA steps to do.  doesn't seem to take that many while doing a cubemap !!!\nconst float c_maxSteps = float(JFA_ITERATIONS);\n\nvec3 cartToSphere(vec3 cart) {\n    \n    float r = dot(cart,cart);\n    vec3 n = cart / (r);\n    return vec3(atan(n.x, n.z), asin(n.y), 1.0/(1.0+r*r));\n}\n\nvec4 StepJFA( in vec3 rd, in float level )\n{\n    level = clamp(level-1.0, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)+0.5) * 0.5f;\n    \n    float bestDistance = 9999.0;\n    vec3 best_c = vec3(0.0);\n    float best_d = (0.0);\n    \n    for (int z = -1; z <= 1; ++z) {\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n            \n                if (0 == (z+y+x))\n                    continue;\n                    \n                vec3 d = rd + vec3(x,y,z) * stepwidth;\n            \n                vec4 sd_c = texture( iChannel0, normalize(d) );\n\n                float dist = length(sd_c.xyz - rd);\n                if ( 0.0f != sd_c.a && dist < bestDistance )\n                {\n                    bestDistance = dist;\n                    best_c = sd_c.xyz;\n                    best_d = bestDistance;\n                }\n            }\n        }\n    }\n    \n    return vec4(best_c, best_d);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{     \n    if (0 == iFrame) {\n \n        fragColor.xyz = rd;\n        fragColor.a = 0.0001f;\n        return;\n    }\n \n    \n    if (float(iFrame) < c_maxSteps)\n        fragColor = StepJFA(rd, float(iFrame));\n    else\n        fragColor = texture( iChannel0, rd );\n        \n    // Output to cubemap\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define JFA_ITERATIONS 2\n\n\n\n\n#define R iResolution.xy\n\n#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820)\n\nvec2 V;\n#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\n/*\n// 2D Weyl hash 32-bit XOR  - https://www.shadertoy.com/view/4dlcR4\n\n#define _W0 0x3504f335u   \n#define _W1 0x8fc1ecd5u  \n#define _W2 0xbb67ae85u\n#define _W3 0xf1bbcdcbu\n\n// 741103597u, 1597334677u, 204209821u, 851723965u  // MLCG constants\n#define _M0 741103597u    \n#define _M1 1597334677u\n#define _M2 204209821u\n#define _M3 851723965u\n\n#define _FSCALE 256.0f\n#define _FNORM (1.0f/16777216.0f/_FSCALE)\nuvec3 base_hash_3D(in uvec3 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.z *= _W2;\t  // z' = Fz(z)\n  n.x ^= n.y;    // combine\n  n.x ^= n.z;    // combine\n\n  return( (n.x * uvec3(_M0, _M1, _M2)) ^ (n.x >> 16) ); // MLCG constant\n}\nvec3 hash33(in vec3 x)\n{\n\treturn vec3(base_hash_3D(uvec3(_FSCALE * x))) * _FNORM;\n}\n*/","name":"Common","description":"","type":"common"}]}