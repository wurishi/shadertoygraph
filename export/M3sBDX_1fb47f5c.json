{"ver":"0.1","info":{"id":"M3sBDX","date":"1729030041","viewed":34,"name":"[ConcoursJFIG2024] Wine & Alsace","username":"Raven33","description":"Heavily inspired by \"Cognac bottle\" by Tambako (https://www.shadertoy.com/view/lsVSRh)","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["concoursjfig2024"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nHeavily based on \"Cognac bottle\" by Tambako (Emmanuel Keller)\n*/\n\n#define PI 3.14159265359\n\n// Feature Toggles\n#define SPECULAR\n#define REFLECTIONS\n#define SHOW_TABLE\n#define SHOW_WINE\n// Object Identifiers\n#define SKY_OBJ        0\n#define BARREL_OBJ     1  // Changed from TABLE_OBJ to BARREL_OBJ\n#define BOTTLE_OBJ     2\n#define WINE_OBJ       3\n#define LABEL_OBJ      4\n\n// Structures\nstruct Lamp {\n    vec3 position;\n    vec3 color;\n    float intensity;\n    float attenuation;\n};\n\nstruct MaterialProperties {\n    vec3 volumetricColor;\n    vec3 diffuseColor;\n    vec3 filterColor;\n    vec3 developmentColor;\n    float specularIntensity;\n    float specularShininess;\n};\n\nstruct IntersectionInfo {\n    vec3 color;\n    vec3 position;\n    vec3 normal;\n    int objectID;\n};\n\n// Global Variables\nLamp lamps[2];\nMaterialProperties glassMat;\nMaterialProperties wineMat;\n\nvec3 campos = vec3(0.0, -0.4, 10.0);\nvec3 camtarget = vec3(0.0, 0.3, 0.0);\nvec3 camdir = vec3(0.0, 0.0, 0.0);\nfloat fov = 4.0;\nfloat angle = 0.0;\nfloat angle2 = 0.0;\n\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.06;\n\n// Shading Options\nconst float specint_barrel = 0.1; // Updated for barrel\nconst float specshin_barrel  = 30.0; // Updated for barrel\nconst float specint_label = 0.0;\nconst float specshin_label  = 1.0;\nconst float aoint = 0.5;\n\n// Tracing Options\nconst float normalOffset = 0.001;\nconst float maxDist= 40.0;\nconst int maxReflections = 5;\nconst float glassIOR = 1.47;\nconst float wineIOR = 1.3;\n\nbool traceGlass = true;\n\n// Hash Functions\nfloat hash(float n) {\n    return fract(sin(n) * 753.5453123);\n}\n\nvec3 hash3(vec3 n) {\n    return fract(vec3(sin(n.x) * 3538.5453, sin(n.y) * 2753.8256, sin(n.z) * 5296.3728));\n}\n\n// Noise Function\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n// Signed Distance Functions (SDFs)\nfloat pSphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat pArcSDF(vec2 p, vec2 sc, float ra, float rb) {\n    p.x = abs(p.x);\n    return (sc.y * p.x > sc.x * p.y) ? length(p - sc * ra) : abs(length(p) - ra) - rb;\n}\n\nfloat pBoxSDF(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Replaced pCylinderSDF with sdCylinder\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Smooth Union Operations\nfloat smax(float x, float y, float fact) {\n    x *= fact;\n    y *= fact;\n    float maxVal = max(x, y);\n    float minVal = min(x, y);\n    return (maxVal + log(1.0 + exp(minVal - maxVal))) / fact;\n}\n\n//TODO IQ\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k / 6.0;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// Vector Rotation\nvec2 rotateVec(vec2 vect, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(vect.x * c - vect.y * s, vect.x * s + vect.y * c);\n}\n\nvec3 rotateVec2(vec3 pos) {\n    pos.yz = mat2(cos(angle2), sin(angle2), -sin(angle2), cos(angle2)) * pos.yz;\n    pos.xz = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * pos.xz;\n    return pos;\n}\n\n// Barrel Mapping Function\nfloat sBarrelSDF(vec3 p, float radius, float height, float bulge) {\n    // Barrel shape with sinusoidal bulges\n    float theta = atan(p.x, p.z);\n    float r = radius + bulge * sin(2.0 * theta);\n    vec2 q = vec2(length(vec2(p.x, p.z)) - r, abs(p.y) - height);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\nfloat map_barrel(vec3 pos) {\n    pos = rotateVec2(pos);\n    pos.y += 1.201; // Adjust height as needed\n    return sBarrelSDF(pos, 3.5, 0.2, 0.3); // radius, height, bulge amplitude\n}\n\n// Bottle Mapping Functions\nfloat bottleSDFInterior(vec3 pos) {\n    float thickness = 0.02;\n    float h = 1.0;\n    pos.y -= h / 3.0;\n\n    float d = pSphereSDF(pos + vec3(0.0, -h, 0.0), 0.299 - thickness);\n    float neck = smin(\n        sdCylinder(pos + vec3(0.0, -h - 0.5, 0.0), vec2(0.1 - thickness, 0.6 - thickness)),\n        sdCylinder(pos + vec3(0.0, -h - 1.05, 0.0), vec2(0.12 - thickness, 0.03 - thickness)),\n        0.01\n    );\n    d = smin(d, neck, 0.320);\n    d = min(d, sdCylinder(pos, vec2(0.3 - thickness, h)));\n\n    return d;\n}\n\nfloat bottleSDFExterior(vec3 pos) {\n    float h = 1.0;\n    pos.y -= h / 3.0;\n\n    float d = pSphereSDF(pos + vec3(0.0, -h, 0.0), 0.299);\n    float neck = smin(\n        sdCylinder(pos + vec3(0.0, -h - 0.5, 0.0), vec2(0.1, 0.6)),\n        sdCylinder(pos + vec3(0.0, -h - 1.05, 0.0), vec2(0.12, 0.03)),\n        0.01\n    );\n    d = smin(d, neck, 0.320);\n    d = min(d, sdCylinder(pos, vec2(0.3, h)));\n\n    return d;\n}\n\nfloat bottleSDF(vec3 pos) {\n    if (!traceGlass) return 10.0;\n    pos = rotateVec2(pos) + vec3(0.02, 0.56, 0.03);\n    pos *= 1.25;\n\n    float intb = bottleSDFInterior(pos);\n    float extb = bottleSDFExterior(pos);\n    float df = max(extb, -intb);\n    df = smax(df, pos.y - 2.98, 120.0);\n\n    return df;\n}\n\nfloat labelSDF(vec3 pos) {\n    pos = rotateVec2(pos) + vec3(0.02, 0.56, 0.03);\n    pos *= 1.25;\n\n    float tb = PI / 2.2;\n    float rb = 0.005;\n    vec2 sc = vec2(sin(tb), cos(tb));\n    float labelHeightMin = 0.4;\n    float labelHeightMax = 1.2;\n\n    float sdf = pArcSDF(pos.xz, sc, 0.3, rb);\n    float heightCap = max(pos.y - labelHeightMax, labelHeightMin - pos.y);\n    return max(sdf, heightCap);\n}\n\n// Wine Mapping\nfloat wineSDF(vec3 pos) {\n    if (!traceGlass) return 10.0;\n\n    pos = rotateVec2(pos) + vec3(0.02, 0.56, 0.03);\n    pos *= 1.25;\n\n    float lev = 0.35;\n    float intb = bottleSDFInterior(pos);\n    float be = 1.0 / (0.000015 + pow(abs(intb), 2.5));\n    float df = max(intb, pos.y + 0.48 - clamp(0.0, 1.0, lev) * 3.15 - clamp(0.0000004 * be, 0.0, 0.05));\n\n    return df;\n}\n\n// Scene Mapping\nvec2 map(vec3 pos, bool inside) {\n    float bottle = bottleSDF(pos);\n    float wine = wineSDF(pos);\n    vec2 res = opUnion(vec2(bottle, BOTTLE_OBJ), vec2(wine, WINE_OBJ));\n\n    if (inside) res.x = -res.x;\n\n    float barrel = map_barrel(pos); // Changed from map_table to map_barrel\n    float label = labelSDF(pos);\n\n    res = opUnion(res, vec2(barrel, BARREL_OBJ)); // Updated object identifier\n    res = opUnion(res, vec2(label, LABEL_OBJ));\n\n    return res;\n}\n\n// Ray Marching\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) {\n    float t = inside ? 0.12 : 0.01;\n    int objnr = 0;\n    vec3 pos;\n\n    for (int i = 0; i < 100; ++i) {\n        pos = ray * t + cam;\n        vec2 res = map(pos, inside);\n        float dist = res.x;\n        if (dist > maxdist || abs(dist) < 0.002) break;\n        t += dist * (0.35 + 0.004 * float(i));\n        objnr = int(abs(res.y));\n    }\n    return vec2(t, float(objnr));\n}\n\n// Normal Calculation\nvec3 getNormal(vec3 pos, float e, bool inside) {  \n    vec2 q = vec2(0.0, e);\n    return normalize(vec3(\n        map(pos + q.yxx, inside).x - map(pos - q.yxx, inside).x,\n        map(pos + q.xyx, inside).x - map(pos - q.xyx, inside).x,\n        map(pos + q.xxy, inside).x - map(pos - q.xxy, inside).x\n    ));\n}\n\n// Color Retrieval Functions\nvec3 getGlassColor(vec3 pos) {\n    return glassMat.diffuseColor;\n}\n\nvec3 getWineColor(vec3 pos) {\n    return wineMat.diffuseColor;\n}\n\nvec3 getBarrelColor(vec3 pos) { // Updated function name\n    vec2 p1 = pos.xz + vec2(8., 8.) + 0.05*noise(pos*1.8);\n    vec3 t1 = texture(iChannel2, p1).xyz;\n    vec2 p2 = 1.35*p1 + vec2(0.4, -0.3) + 0.3*noise(pos*1.2);\n    vec3 t2 = texture(iChannel2, p2).xyz;\n    vec2 p3 = 1.55*p1 + vec2(0.2, 0.5);\n    vec3 t3 = texture(iChannel2, p3).xyz;\n    return mix(0.8*mix(t1, mix(t2, t3, noise(pos*3.)), noise(pos*1.2)), vec3(0.35), 0.15);\n}\n\nvec3 getSkyColor(vec3 pos){\n    return vec3(0.06, 0.12, 0.06) + 1.1*mix(texture(iChannel1, pos).rgb, texture(iChannel1, pos).rrr, 0.4);\n}\n\nvec3 getLabelColor(vec3 pos) {\n    pos = rotateVec2(pos);\n\n    float tb = PI / 2.;\n    float ra = 0.3;\n    float rb = 0.015;\n    float labelHeightMax = 0.4;\n    float labelHeightMin = -0.56;\n\n    float a = atan(pos.x, pos.z);\n    float u = clamp((a + tb) / (2.0 * tb), 0.0, 1.0);\n    float v = clamp((pos.y - labelHeightMin) / (labelHeightMax - labelHeightMin), 0.0, 1.0);\n\n    return texture(iChannel0, vec2(1.-v,1.-u)).rgb;\n}\n\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray) {\n    pos = rotateVec2(pos);\n    if (objnr == BOTTLE_OBJ) return getGlassColor(pos);\n    if (objnr == BARREL_OBJ) return getBarrelColor(pos); // Updated object identifier\n    if (objnr == WINE_OBJ) return getWineColor(pos);\n    if (objnr == LABEL_OBJ) return getLabelColor(pos);\n    return getGlassColor(pos);\n}\n\n// Fresnel Calculation\nfloat fresnel(vec3 ray, vec3 norm, float n2) {\n    float n1 = 1.0; // Air\n    float angle = acos(-dot(ray, norm));\n    float r0 = pow((n1 - n2) / (n1 + n2), 2.0);\n    return clamp(r0 + (1.0 - r0) * pow(1.0 - cos(angle), 5.0), 0.0, 0.8);\n}\n\n// Lighting\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr) {   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl / pow(1.0 + lamp.attenuation * dlp, 2.0);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse Shading\n    vec3 col = ocol * lamp.color * lamp.intensity * smoothstep(-0.2, 1.0, dnp);\n    \n    // Specular Shading\n    #ifdef SPECULAR\n    float specint = 0.0;\n    float specshin = 0.0;\n    if (objnr == BOTTLE_OBJ) {\n        specint = glassMat.specularIntensity;\n        specshin = glassMat.specularShininess;       \n    } else if (objnr == WINE_OBJ) {\n        specint = wineMat.specularIntensity;\n        specshin = wineMat.specularShininess;       \n    }\n\n    if (specint > 0.0) {\n        vec3 reflectDir = reflect(pl, norm);\n        vec3 viewDir = normalize(pos - campos);\n        float specFactor = pow(max(dot(reflectDir, viewDir), 0.0), specshin);\n        col += lamp.color * lamp.intensity * specint * specFactor;\n    }\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr) {\n    vec3 col = vec3(0.0);\n    for (int l = 0; l < 2; l++) {\n        col += lampShading(lamps[l], norm, pos, ocol, objnr);\n    }\n    return col;\n}\n\n// Camera Ray Direction\nvec3 GetCameraRayDir(vec2 uv, vec3 vCameraDir, float fov) {\n    vec3 vForward = normalize(vCameraDir);\n    vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n    vec3 vUp = cross(vForward, vRight);\n    return normalize(uv.x * vRight + uv.y * vUp + vForward * fov);\n}\n\n// Camera Setup\nvoid setCamera() {\n    vec2 iMouse2 = (iMouse.x == 0.0 && iMouse.y == 0.0) ? iResolution.xy * vec2(0.25, 0.40) : iMouse.xy;\n    \n    float mouseX = iMouse2.x / iResolution.x;\n    float mouseY = iMouse2.y / iResolution.y;\n    \n    campos = vec3(\n        7.0 * cos(6.0 * mouseX) * (1.0 - 0.5 * mouseY),\n        8.0 * mouseY,\n        7.0 * sin(6.0 * mouseX) * (1.0 - 0.5 * mouseY)\n    );\n    camtarget = vec3(0.0, -1.3 * mouseY + 0.6, 0.0);\n    camdir = camtarget - campos;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 normal) {\n    float ao = 0.0;\n    float totalWeight = 0.0;\n    float numSamples = 8.0;\n    float aoStep = 0.05;\n    for (float i = 1.0; i <= numSamples; i++) {\n        float t = i * aoStep;\n        float dist = map(pos + normal * t, false).x;\n        float weight = 1.0 - (i / numSamples);\n        ao += (t - dist) * weight;\n        totalWeight += weight;\n    }\n    ao = clamp(1.0 - ao / totalWeight, 0.0, 1.0);\n    return ao;\n}\n\n\n// Rendering Functions\nIntersectionInfo trace0(vec3 tpos, vec3 ray, float maxdist, bool inside) {\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int matID = int(tr.y);\n    vec3 col = vec3(0.0);\n    vec3 pos = tpos + tx * ray;\n    vec3 norm;\n\n    if (tx < maxdist * 0.95) {\n        norm = getNormal(pos, normalOffset, inside);\n        col = getColor(norm, pos, matID, ray);\n        col = ambientColor * ambientint + lampsShading(norm, pos, col, matID);\n        float ao = ambientOcclusion(pos, norm);\n        col *= ao;\n    } else {\n        matID = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return IntersectionInfo(col, pos, norm, matID);\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color) {\n    return pow(color, vec3(0.3 + pow(dist * 10.0, 1.6)));\n}\n\nvec4 render(vec2 fragCoord) {   \n    vec2 uv = fragCoord / iResolution.xy; \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    vec3 initialRay = GetCameraRayDir(uv, camdir, fov);\n    vec3 currentRay = initialRay;\n    IntersectionInfo initialIntersection = trace0(campos, currentRay, maxDist, false);\n    IntersectionInfo currentIntersection = initialIntersection;\n    vec3 finalColor = initialIntersection.color;\n    vec3 accumulatedGlassFactor = vec3(1.0);\n    bool isInsideObject = false;\n\n     for (int reflectionIndex = 0; reflectionIndex < maxReflections; reflectionIndex++) {\n        if (currentIntersection.objectID == BOTTLE_OBJ || currentIntersection.objectID == WINE_OBJ) {               \n            vec3 reflectedRay = reflect(currentRay, currentIntersection.normal);\n            IntersectionInfo reflectedIntersection = trace0(currentIntersection.position, reflectedRay, 20.0, isInsideObject);\n            float fresnelFactor = fresnel(currentRay, currentIntersection.normal, \n                                (currentIntersection.objectID == BOTTLE_OBJ) ? glassIOR * 1.1 : \n                                (currentIntersection.objectID == WINE_OBJ ? wineIOR : 3.0));\n\n            if (currentIntersection.objectID == BARREL_OBJ) {\n                accumulatedGlassFactor *= fresnelFactor;\n                finalColor *= (1.0 - fresnelFactor);\n                finalColor += clamp(accumulatedGlassFactor * reflectedIntersection.color, 0.0, 1.0);\n                currentRay = reflectedRay;\n                currentIntersection = reflectedIntersection;\n            } else {\n                finalColor += clamp(accumulatedGlassFactor * reflectedIntersection.color * fresnelFactor, 0.0, 1.0);\n                accumulatedGlassFactor *= (1.0 - fresnelFactor * 0.65);\n            }\n        }\n\n        if (currentIntersection.objectID == BOTTLE_OBJ || currentIntersection.objectID == WINE_OBJ) {\n            float currentIOR = (currentIntersection.objectID == BOTTLE_OBJ) ? \n                                (isInsideObject ? 1.0 / glassIOR : glassIOR) :\n                                (currentIntersection.objectID == WINE_OBJ ? \n                                 (isInsideObject ? 1.0 / wineIOR : wineIOR) : 1.0);\n            vec3 refractedRay = refract(currentRay, currentIntersection.normal, 1.0 / currentIOR);\n            if (length(refractedRay) != 0.0) isInsideObject = !isInsideObject;\n            else refractedRay = reflect(currentRay, currentIntersection.normal);            \n\n            vec3 hitPosition = currentIntersection.position;\n            currentIntersection = trace0(hitPosition, refractedRay, 20.0, isInsideObject);\n            if (isInsideObject) {\n                accumulatedGlassFactor *= getGlassAbsColor(distance(hitPosition, currentIntersection.position), (currentIntersection.objectID == WINE_OBJ) ? wineMat.volumetricColor : glassMat.volumetricColor);\n            }\n            accumulatedGlassFactor *= (currentIntersection.objectID == WINE_OBJ ? wineMat.filterColor : glassMat.filterColor);\n            finalColor += clamp(currentIntersection.color * accumulatedGlassFactor, 0.0, 1.0);\n            currentRay = refractedRay;\n        }\n\n        if (currentIntersection.objectID == SKY_OBJ) {\n            finalColor += getSkyColor(currentRay) * accumulatedGlassFactor;\n            break;\n        }\n    }\n    return vec4(finalColor, 1.0);\n}\n\n// Initialization Function\nvoid init() {\n    lamps[0] = Lamp(vec3(-5.0, 3.0, -5.0), vec3(1.0), 1.2, 0.01);\n    lamps[1] = Lamp(vec3(1.0, 4.0, 3.0), vec3(1.0), 1.0, 0.01);\n    \n    glassMat = MaterialProperties(\n        vec3(0.95, 0.98, 0.96),\n        vec3(0.01, 0.02, 0.025),\n        vec3(1.0),\n        vec3(0.3, 0.5, 0.9),\n        0.4,\n        45.0\n    );\n    \n    wineMat = MaterialProperties(\n        vec3(0.99, 0.99, 0.97),\n        vec3(0.03, 0.02, 0.015),\n        vec3(1.0),\n        vec3(0.98, 0.96, 0.85),\n        0.7,\n        80.0\n    );\n}\n\n// Main Image Function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    init();\n    setCamera();\n   \n    fragColor = render(fragCoord);\n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ==================== Text function ====================\n// From by \"message: sound in #2\" by FabriceNeyret2 (https://www.shadertoy.com/view/MtyXRW)\n #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0.): textureGrad(iChannel0, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n\nfloat alsace(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);\n    C(86); C(105); C(110); C(32); C(100); C(39); C(65); C(108); C(115); C(97); C(99); C(101);\n    return length(T.yz)==-1. ? 0. : T.x;\n}\n\nfloat jfig(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);\n    C(74); C(70); C(73); C(71); C(50); C(48); C(50); C(52);\n    return length(T.yz)==-1. ? 0. : T.x;\n}\n\n// ====================== Paper Appearance =========================\n// based on \"Cube Circle Sketch\" by Shane (https://www.shadertoy.com/view/3dtBWX)\n\n\nmat2 rot2(in float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589)) * 43758.5453); \n}\n\n// Compact, self-contained 2D value noise function.\nfloat n2D(vec2 p){\n    // Setup.\n    const vec2 s = vec2(1.0, 113.0);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); \n    p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0.0, s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p * p * (3.0 - 2.0 * p);\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589)) * 43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){\n    return n2D(p) * 0.533 + n2D(p * 2.0) * 0.267 + n2D(p * 4.0) * 0.133 + n2D(p * 8.0) * 0.067;\n}\n\n// Pencil sketch effect.\nvec3 pencil(vec3 col, vec2 p){\n    // Rough pencil color overlay.\n    vec2 q = p * 4.0;\n    const vec2 sc = vec2(1.0, 12.0);\n    q += (vec2(n2D(q * 4.0), n2D(q * 4.0 + 7.3)) - 0.5) * 0.03;\n    q *= rot2(-3.14159 / 2.5);\n    \n    // Underlying greyscale pixel value.\n    float gr = dot(col, vec3(0.299, 0.587, 0.114));\n    \n    // Stretched fBm noise layer.\n    float ns = (n2D(q * sc) * 0.66 + n2D(q * 2.0 * sc) * 0.34);\n    \n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159 / 2.0);\n    float ns2 = (n2D(q * sc) * 0.66 + n2D(q * 2.0 * sc) * 0.34);\n    q *= rot2(-3.14159 / 5.0);\n    float ns3 = (n2D(q * sc) * 0.66 + n2D(q * 2.0 * sc) * 0.34);\n    \n    // Compare to the underlying greyscale value.\n    const float contrast = 1.0;\n    ns = (0.5 + (gr - max(max(ns, ns2), ns3)) * contrast);\n    \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0.0, 1.0));\n}\n\n// ==================== SDF Functions ====================\n// Based on \"Interior Distance\" by iq (https://www.shadertoy.com/view/3t33WH)\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat msign(in float x) { return (x > 0.0) ? 1.0 : -1.0; }\n\n// SDF for a squared line segment.\nvec2 sdSqLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return vec2(dot2(pa - h * ba), ba.x * pa.y - ba.y * pa.x);\n}\n\n// SDF for a squared arc.\nvec2 sdSqArc(vec2 p, vec2 a, vec2 b, float h, bool useOtherArc){\n    vec2 ba = b - a;\n    float l = length(ba);\n    float ra2 = h * h + l * l * 0.25;\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    \n    // Recenter\n    p -= (a + b) * 0.5 + vec2(-ba.y, ba.x) * h / l;\n    \n    float m = ba.y * p.x - ba.x * p.y;\n    float n = dot(p, p);\n    bool onArc = (abs(h) * abs(ba.x * p.x + ba.y * p.y) < msign(h) * l * 0.5 * m) ^^ useOtherArc;\n        \n    float sd = onArc ? sqrt(n) - sqrt(ra2) : min(length(pa), length(pb)) * msign(n - ra2);\n    return vec2(sd * sd, sd);\n}\n\n// SDF for BasseAlsace.\nfloat sdBasseAlsace(vec2 p){\n    p.x = -abs(p.x) + 1.0;\n\n    vec2 vb = vec2(0.117, -0.022); // Initial vertex\n    float s = 1.0; // Sign indicator\n    \n    float d = dot(p - vb, p - vb);\n    vec2 dline = sdSqLine(p, vec2(1.0, -1.0), vec2(0.117, -1.0)); // Underline\n    d = min(d, dline.x);\n  \n    if((p.y <= -1.0) && (p.y <= -0.022)) s *= -1.0;\n    \n    // First arc\n    vec2 va = vb;\n    vb = vec2(0.979, 0.221);\n    vec2 ds = sdSqArc(p, va, vb, 0.248, false);\n    d = min(d, ds.x);\n    \n    if((ds.y > 0.0) && ((p.x > va.x && p.y < vb.y) || (p.x < va.x && p.y < va.y))) s *= -1.0;\n    \n    // Second arc\n    va = vb;\n    vb = vec2(0.863, 0.490);\n    ds = sdSqArc(p, va, vb, 0.210, true);\n    d = min(d, ds.x);\n    \n    if((p.y < vb.y && p.y > va.y && p.x > vb.x) || (ds.y < 0.0)) s *= -1.0;\n    \n    // Third arc\n    va = vb;\n    vb = vec2(1.0, 1.0);\n    ds = sdSqArc(p, va, vb, -0.072, false);\n    d = min(d, ds.x);\n    \n    if((p.y < vb.y && p.y > va.y) && (ds.y < 0.0 || p.x > vb.x)) s *= -1.0;\n    \n    return s * sqrt(d);\n}\n\n// SDF for CrownAlsace.\nfloat sdCrownAlsace(in vec2 p){\n    p.x = -abs(p.x) + 1.0;\n\n    // First vertex\n    vec2 vb = vec2(1.0, -1.0);\n    float d = dot2(p - vb); \n    float s = 1.0; // Sign indicator\n\n    // First line segment\n    vec2 va = vb;\n    vb = vec2(-0.503, -1.0);\n    vec2 ds = sdSqLine(p, va, vb);\n    d = min(d, ds.x);\n\n    // Second line segment \n    va = vb;\n    vb = vec2(-1.0, 0.803);\n    ds = sdSqLine(p, va, vb);\n    d = min(d, ds.x);\n    \n    if(ds.y < 0.0 && p.y > va.y && p.y < vb.y) s *= -1.0;\n\n    // First arc\n    va = vb;\n    vb = vec2(-0.043, 0.027);\n    ds = sdSqArc(p, va, vb, 2.226, false);\n    d = min(d, ds.x);\n    \n    if((p.y > vb.y) && (ds.y < 0.0 || p.x > vb.x) && (p.y < va.y)) s *= -1.0;\n\n    // Second arc\n    va = vb;\n    vb = vec2(0.214, -0.254);\n    ds = sdSqArc(p, va, vb, -0.203, true);\n    d = min(d, ds.x);\n    if( p.y < va.y && (ds.y < 0.0 || (p.x > va.x && p.y > vb.y))) s *= -1.0;\n\n    // Third arc\n    va = vb;\n    vb = vec2(0.981, -0.124);\n    ds = sdSqArc(p, va, vb, 0.113, false);\n    d = min(d, ds.x);\n    if((ds.y < 0.0 && p.y < va.y ) || (ds.y > 0.0 && p.y < vb.y && p.y > va.y && p.x > va.x)) s *= -1.0;\n\n    // Fourth arc\n    va = vb;\n    vb = vec2(0.872, 0.153);\n    ds = sdSqArc(p, va, vb, 0.195, true);\n    d = min(d, ds.x);\n    \n    if((p.y < vb.y && p.y > va.y && p.x > vb.x) || (ds.y < 0.0)) s *= -1.0;\n\n    // Fifth arc\n    va = vb;\n    vb = vec2(1.0, 0.608);\n    ds = sdSqArc(p, va, vb, -0.066, false);\n    d = min(d, ds.x);\n    if((p.y < vb.y && p.y > va.y) && (ds.y < 0.0 || p.x > vb.x)) s *= -1.0;\n\n    return s * sqrt(d);\n}\n\n// Function to rotate a vector by angle 'a'.\nvoid pR(inout vec2 p, float a){\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// Repeat function with interval limits.\nfloat pModInterval1(inout float p, float size, float start, float stop){\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    if (c > stop){ // Numerical safety.\n        p += size * (c - stop);\n        c = stop;\n    }\n    if (c < start){\n        p += size * (c - start);\n        c = start;\n    }\n    return c;\n}\n\n// Simple modulus function.\nfloat pMod1(inout float p, float size){\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// Reflection matrix.\nmat2 reflectionMatrix(float mirrorAngle){\n    float c = cos(mirrorAngle);\n    float s = sin(mirrorAngle);\n    return mat2(c, s, s, -c);\n}\n\n// SDF for CrownAlsace with flag-specific transformations.\nfloat CrownAlsace(in vec2 p){\n    vec2 p2 = abs(p);\n    // Select quadrant and fold\n    if (p.x > 0.0 && p.y < 0.0) p2 = p.yx;\n    if (p.x < 0.0 && p.y > 0.0) p2 = p.xy;\n    pR(p2, radians(-27.0));\n    p2 += vec2(-0.34, -1.75);\n    p2 /= 0.28;\n\n    vec2 p3 = p2;\n    pModInterval1(p2.x, 6.18, 0.0, 1.0);\n    float d = sdCrownAlsace(p2);\n    p3 += vec2(-3.3, -2.2);\n    return min(d, sdCrownAlsace(p3));\n}\n\n// SDF for BasseAlsace with flag-specific transformations.\nfloat BasseAlsace(in vec2 p){\n    vec2 p2 = reflectionMatrix(radians(-27.0)) * p;\n    p2.y = abs(p2.y);\n    p2 += vec2(-0.089, -0.94);\n    p2 /= 0.32;\n    pMod1(p2.x, 1.77);\n    return sdBasseAlsace(p2);\n}\n\n// SDF for a rectangle (bounding box).\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// ==================== Main Image Function ====================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalize pixel coordinates (range approximately [-1, 1] for both axes)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // ==================== Generate Paper Texture ====================\n    \n    vec2 p = uv;\n    vec3 paperColor = vec3(0.95, 0.975, 0.8);\n    // Apply pencil sketch effect to the paper\n    vec2 q = p * 8.0;\n    vec3 pencilOverlay = pencil(paperColor, q * iResolution.y / 450.0);\n    \n    vec2 pp = q;\n    vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));\n    vec3 pg = 0.8 + (rn3.xyz * 0.35 + rn3.xxx * 0.65) * 0.4;\n    paperColor *= min(pg, 1.0); \n    \n    // Apply subtle noise to the paper color\n    float noiseScale = 50.0; \n    float noiseAmp = 0.02;\n    paperColor += fbm(p * noiseScale) * noiseAmp;\n    \n    paperColor = clamp(paperColor, 0.0, 1.0);\n\n    vec2 translation = vec2(-0.02, -0.6);\n\n    vec2 pflag = vec2(uv.y, -uv.x)+translation;\n    vec2 pscale = (pflag + vec2(0.,-0.005)) / 0.09; \n    \n    // ==================== Render the Flag ====================\n    \n    float d1 = CrownAlsace(pscale);\n    float d2 = BasseAlsace(pscale); \n    \n\n    vec2 p3 = pscale;\n    pR(p3, radians(-27.0));\n    float d3 = sdSqLine(p3, vec2(-1000.0, 0.0), vec2(1000.0, 0.0)).x - 0.25; // Centerline SDF\n    \n    //Material\n    float minD = d1;\n    int matID = 1; // 1 for CrownAlsace\n    \n    if (d2 < minD) {\n        minD = d2;\n        matID = 2; // 2 for BasseAlsace\n    }\n    if (d3 < minD) {\n        minD = d3;\n        matID = 3; // 3 for Centerline\n    }\n    \n    // ==================== Add Bounding Box ====================\n    vec2 boxSize = vec2(.3, .19); \n    float boxD = sdBox(pflag, boxSize);\n    \n\n    float borderThickness = 0.001;\n    float border = smoothstep(borderThickness, 0.0, abs(boxD));\n    \n    vec3 borderColor = vec3(0.3);\n    \n    vec3 crownCol = vec3(1.0, 0.824, 0.12); \n    vec3 white = vec3(1.0);               \n    vec3 backgroundColor = vec3(.98,0.,0.);\n\n    vec3 finalColor = paperColor;\n    float thickness = 0.03;\n    \n    if (boxD <= 0.0){\n        if (matID == 1) {\n            // SDF1: CrownAlsace\n            float alpha = smoothstep(thickness, 0.0, minD);\n            finalColor = mix(crownCol, backgroundColor, 1.0 - alpha);\n        } else if (matID == 2) {\n            // SDF2: BasseAlsace\n            float alpha = smoothstep(thickness, 0.0, minD);\n            finalColor = mix(white, backgroundColor, 1.0 - alpha);\n        } else if (matID == 3) {\n            // SDF3: Centerline\n            float alpha = smoothstep(thickness, 0.0, minD);\n            finalColor = mix(white, backgroundColor, 1.0 - alpha);\n        }\n    }\n    finalColor = mix(finalColor, borderColor, border);\n    \n    float grainFactor = 0.2; // Adjust how much grain shows through\n    finalColor = mix(finalColor, paperColor, grainFactor);\n    \n    \n    finalColor += fbm(p * noiseScale) * 0.1;\n    finalColor = clamp(finalColor, 0.0, 1.0);\n    finalColor = pow(finalColor, vec3(0.4545)); // Approx. 1/2.2\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n    \n    vec2 normalizedFragCoord = vec2(fragCoord.x, fragCoord.y) / iResolution.y;\n    vec2 U = (normalizedFragCoord - vec2(0.8, 0.)) * 7.5;\n    \n    mat2 rot = mat2(0.0, -1.0,\n               1.0,  0.0);\n    vec2 rotatedU = rot * U;\n    float msg1 = clamp(alsace(rotatedU), 0.0, 1.0);\n    U+= vec2(-2.,-0.8);\n    float msg2 = clamp(jfig(rot * U), 0., 1.);\n    \n    if(msg1 > 0.0){\n        vec3 textColor = vec3(.4);\n        fragColor.xyz = mix(fragColor.xyz, textColor, msg1);\n    }\n    if(msg2 > 0.0){\n        vec3 textColor = vec3(.4);\n        fragColor.xyz = mix(fragColor.xyz, textColor, msg2);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}