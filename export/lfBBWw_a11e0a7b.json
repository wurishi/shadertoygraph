{"ver":"0.1","info":{"id":"lfBBWw","date":"1725144089","viewed":24,"name":"Benimod's First Shader","username":"Benimod","description":"This is my first shader! I wanted to learn ray marching, and I think the psychedelic nature of this shader accurately describes how my brain has felt while learning everything.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n\n// Parts of this code have been more or less copied from various tutorials and such!\n// In particular, the palette and SDF functions are from Inigo Quilez.\n\nconst float SURFACE_LIMIT = 0.0001;\nconst float MAX_DIST = 100.;\nconst float SHADOW_MARGIN = 0.3;\n\n\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2 (c, -s, s, c);\n}\n\n// Palette and SDF functions from \nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sphereSDF(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nfloat cylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.yx-c.yz)-c.z;\n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dist(vec3 p){\n    // Ground Plane\n    float groundDist = p.y + 1.;\n    \n    // Sphere\n    //vec3 spherePos = vec3(0, 0, 1.);\n    //float sphereDist = sphereSDF(p - spherePos, 1.3);\n    \n    // Lots of spheres\n    vec3 q = fract(p);\n    vec3 spherePos = vec3(0.5, 0.5, 0.5);\n    float sphereDist = sphereSDF(q - spherePos, 0.1);\n    \n    vec3 r = vec3(p.xy, mod(p.z - 11.*PI/2., 31.4159265359));\n    \n    //Cylinder\n    vec3 cylinderPos = vec3(-1., -1.2, 0);\n    float cylinderDist = cylinderSDF(p - cylinderPos, vec3(0, 1, 1));\n    \n    // Box\n    vec3 boxPos = vec3(0, 0, 2.);\n    float boxDist = boxSDF(r - boxPos, vec3(2., 1., 0.5));\n    \n    return min(min(max(-cylinderDist, boxDist), groundDist), sphereDist);\n    //return sphereDist;\n    \n}\n\nfloat rayMarch(vec3 origin, vec3 direction, float surfaceLimit){\n    float d = 0.;\n    for (int i = 0; i < 80; ++i){\n        vec3 pos = origin + direction * d;\n        float current_distance = dist(pos);\n        d += current_distance;\n        \n        if (current_distance < surfaceLimit) break;\n        if (current_distance > MAX_DIST) break;\n   }\n   return d;\n}\n\nfloat rayMarch(vec3 origin, vec3 direction){\n    return rayMarch(origin, direction, SURFACE_LIMIT);\n}\n\nvec3 getNormal(vec3 pos){\n    float delta = 0.001;\n    float xDistance = dist(pos + vec3(delta, 0., 0.)) - dist(pos - vec3(delta, 0., 0.));\n    float yDistance = dist(pos + vec3(0., delta, 0.)) - dist(pos - vec3(0., delta, 0.));\n    float zDistance = dist(pos + vec3(0., 0., delta)) - dist(pos - vec3(0., 0., delta));\n    vec3 normal = vec3(xDistance, yDistance, zDistance) / (2. * delta);\n    return normal;\n}\n\nfloat getLight(vec3 p){\n    // Sunlight\n    vec3 sunPos = vec3(0., 2., -2.);\n    vec3 lightVector = normalize(sunPos - p);\n    vec3 normal = getNormal(p);\n    float light = clamp(dot(normal, lightVector), 0., 1.);\n    float d = rayMarch(p + normal * 2. * SURFACE_LIMIT, lightVector);\n    if (d < length(sunPos - p)) light = 0.;\n    \n    // Surface light\n    if (dist(p) < 2. * SURFACE_LIMIT) light = clamp(light, 0.1, 1.);\n    \n    return light;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n   vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n   \n   vec3 sun = normalize(vec3(1, 1, 2));\n   vec3 cam = vec3(0, 0, -3);\n   vec3 dir = normalize(vec3(uv, 1));\n   \n   //cam.xz += vec2(0.) * rot2d(-m.x * 2.);\n   //dir.xz *= rot2d(-m.x * 2.);\n   \n   dir.yz *= rot2d(cos(iTime+PI));\n   cam.z += iTime * 5.;\n   cam.y += 5. + 5. * sin(iTime);\n   \n   // The Ray Marching! \n   // Each ray will originate from the camera at 0, 0, -3; hit the camera at 0, 0, 0; and hit an object at 0, 0, 3.\n   float d = rayMarch(cam, dir);\n   float light = getLight(cam + dir * d);\n   vec3 color = vec3(light);\n   //fragColor = vec4(color, 1.0);\n   //d = smoothstep(0, 1, 1);\n   float grad = d / 10.;\n   fragColor = vec4(palette(grad, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0., 0.33, 0.67)) * (1. - 0.05*clamp(d, 0., 50.)), 1.0);\n   //fragColor = vec4(d, 1./d, 0., 1.);\n}","name":"Image","description":"","type":"image"}]}