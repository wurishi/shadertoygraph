{"ver":"0.1","info":{"id":"dsX3RM","date":"1666334506","viewed":646,"name":"SunDanceOfYetToBeBalloonAnimals","username":"bloxard","description":"This shader calculates a shadow density that is increasing proportional with the number of 3D bezier curves that the ray has to pass through from the ground to the sun.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","sun","bezier","lensflare","aurora","atmosphere","dispersion","softshadow","contactharding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright Per Bloksgaard, 2022 - https://perbloksgaard.dk\n\n//Title: \"The Erratic Sun Dance Of Yet To Be Balloon Animals.\"\n\n//This shader features animating quadratic offset 3D bezier curves that cast shadow and interact with the sun creating some old school lens flare effects.\n//In order to increase the performance an axis aligned bounding box is calculated only once. It contains all 3D bezier curves in their current animation state.\n//All rays are check against this global bounding box and if the current ray intersects the bounding box then each individual bezier will be checked \n//for intersection using a dynamically created minimum volume bounding box defined in the local space of the bezier curve itself.\n//If the ray also intersects this bounding-box then the more expensive cubic polynomial will be solved and the closest root if any will be \n//returned as intersection. This shader calculates a shadow density that is increasing proportional with the number of 3D bezier curves that the \n//ray has to pass through from the ground to the sun. Once per frame it is determined whether any of the bezier curves are obscuring the line of \n//sight from the camera to the sun and depending on the amount of occlusion the strength of the lens flares are adjusted accordingly.\n//This shader was mostly written in May of 2021, but I went down the rabbit hole of trying to solve the exact raytraced and deterministic \n//intersection between the ray and the offset quadratic 3D bezier curve. I believe that I'm on the path that will lead to the exact \n//raytraced solution, but I wanted to get this shader out now and then come back and fix any minor inaccuracies later.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tSETUP_SHADER\n\tfloat fSunScalar = GetPixel(iChannel0, 0, 0, iResolution.xy).x;\n\tvec3 vAABBDim = GetPixel(iChannel0, 1, 0, iResolution.xy).xyz;\n\tvec3 vAABBCen = GetPixel(iChannel0, 2, 0, iResolution.xy).xyz;\n\tfor (int iR = 0; iR < 4; iR++)\n\t{\n\t\tint iX = iR / 2;\n\t\tint iY = iR % 2;\n\t\tvec3 vRayDir = normalize(vec3(vec2(-uv.x - vScreenPixel.x + vScreenPixel.x * 2. * float(iX), uv.y - vScreenPixel.y + vScreenPixel.y * 2. * float(iY)) * vAspectRatio*fTanFOV, 1.)) * CreateTBNMatrix(vCameraForward);\n\t\tvec3 backgroundColor = skyColor(vRayDir, vSunPos);\n\t\tif (vRayDir.y <= 0.)\n\t\t{\n\t\t\tfloat d = min(-vCameraPosition.y / min(vRayDir.y, -1e-6), 1e6);\n\t\t\tvec3 vHitPos = vCameraPosition + vRayDir * d;\n\t\t\tfloat fD = derivative(vHitPos.xz);\n\t\t\tvec3 gridColor = vec3(1. - fD);\n\t\t\tvec3 vLightDir = normalize(vLightPos - vHitPos);\n\t\t\tmat3 mS = inverseView(vec2(asin(-vLightDir.y), atan(vLightDir.x, vLightDir.z)));\n\t\t\tvec3 vObjColor = vec3(1.);\n\t\t\tfloat fDensity = 0.;\n\t\t\traytraceQuadraticBezierShadow(mS, vHitPos, vLightDir, vObjColor, fDensity, vAABBDim, vAABBCen, iTime);\n\t\t\tfloat fDensityScalar = vShadowParams.x * fDensity * fDensity + vShadowParams.y * fDensity;\n\t\t\tgridColor = mix(gridColor, vObjColor*fDiffuseColorScalar, clamp(fDensityScalar, 0., vContactHarding.w));\n\t\t\tbackgroundColor = clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z), vSunPos), gridColor, smoothstep(0., -0.2, vRayDir.y)), 0., 1.);\n\t\t}\n\t\tmat3 m = inverseView(vec2(asin(-vRayDir.y), atan(vRayDir.x, vRayDir.z)));\n\t\tvColorSum += raytraceQuadraticBezierPrimaryRay(m, vCameraPosition, vRayDir, backgroundColor, vAABBDim, vAABBCen, iTime);\n\t}\n\tvec3 vSunflare = vec3(0.);\n\tvec3 vLensflare = vec3(0.);\n\tlensflares(s * fCoordinateSystemScalar, vSunScreenPos * fCoordinateSystemScalar, vSunflare, vLensflare, iTime);\n\tfloat fXScalar = clamp(abs(s.x)*vXScalar.y + vXScalar.z,0.,1.);\n\tvec3 vFlare = (vLensflare * fLenFlareScalar * fXScalar + vSunflare * fSunFlareScalar);\n\tvFlare = pow(vFlare, vec3(1. / fExposure));\n\tfloat fDist = length(vSunScreenPos);\n\tfloat fScalar = fDist * fDist * vQuadraticScreen.x + fDist * vQuadraticScreen.y + vQuadraticScreen.z;\n\tfloat fYScalar = (s.y + abs(s.x*s.x*0.05))*vYScalar.x + vYScalar.y;\n\tfragColor = vec4(vColorSum * fResultColorScalar + (clamp(vFlare * fYScalar * fTotalFlareScalar,0.,1.)) * fSunScalar, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159;\nconst float HALFPI = 1.57079632679;\nconst float fThickness = 35e-2;\nconst float fSpecularExponent = 57.29;\nconst float fAmbient = 0.2;\nconst vec3 vSpecularColor = vec3(1.);\nconst float fInitialDelay = 8.5;\nconst float fInitialScalar = 0.08;\nconst float fOffCenterValue = -0.3;\nconst float fDistanceToLookAt = 54.1;\nconst float fTimeValueA = 18.;\nconst float fTimeValueB = 120.;\nconst vec3 vControllableLookAt = vec3(6.547352, 5.703433, -2.120103);\nconst vec3 vControllableCameraPosition = vec3(42.00205, 14.80013, -61.20026);\nconst vec3 vCenterLookAt = vec3(1.75539, 3.72, -2.73618);\nconst vec3 vCenterCameraPosition = vec3(4.970052, 5.46, -51.8);\nconst float fTanFOV = tan(0.6544985 * 0.5);\nconst vec4 vSpherePos = vec4(1.6, 8.81, 0.67, 0.45);\nconst vec2 vSunAngles = vec2(1.61, 0.11);\nconst vec3 vLightPos = vec3(40.7, -76.7, -241.77);\nconst vec4 vAnimationParams = vec4(-0.5, 0.29, -0.7, -0.44);\nconst vec4 vPrimaryShadowParams = vec4(0.66, -0.26, -0.58, 1.);\nconst vec4 vShadowParams = vec4(0.01, -0.07, 1., 1.);\nconst vec4 vContactHarding = vec4(-0.001, -0.44, -15.49, 0.48);\nconst float fResultColorScalar = 0.25;\nconst float fDiffuseColorScalar = 0.33;\nconst float fExposure = 1.14;\nconst float fSunFlareScalar = 0.16;\nconst float fLenFlareScalar = 8.72;\nconst float fTotalFlareScalar = 0.23;\nconst vec4 vQuadraticScreen = vec4(-0.34, 5.18, -1.47, 1.);\nconst vec3 vXScalar = vec3(0., -0.54, 1.16);\nconst vec2 vYScalar = vec2(5.05, 1.66);\nconst vec4 vF0 = vec4(0.5, 0.6, 12., 18.);\nconst float fCoordinateSystemScalar = 0.9;\nconst vec2 vScreenFocusPoint = vec2(-0.79, -0.3);\n\nfloat derivative(vec2 p)\n{\n\tvec2 dx = dFdx(p);\n\tvec2 dy = dFdy(p);\n\tvec2 d = p - floor(p);\n\treturn exp2(-0.31 * min((1. - d.x) * d.x, (1. - d.y) * d.y) / (dot(dx, dy) + dot(dy, dy) + 8e-4));\n}\n\nvec3 skyColor(vec3 p, vec3 vSunPos)\n{\n\tfloat h = 0.75 - 0.75 * dot(p, vSunPos) * clamp(1. - 3.2*p.y, 0., 1.) * 0.89384734;\n\tfloat w = length(vSunPos - p) * 20.;\n\tfloat fSkylar = clamp(1. - w * w * 73e-5, 0., 1.);\n\tvec3 vA = mix(vec3(0.894111, 0.517647, 0.109803), vec3(0.658823, 0.545098, 0.325490) * fSkylar, 4. * (h * 2. - 0.25)) * 0.75;\n\tvec3 vB = vec3(0.25 + 0.278285 * (dot(p, vSunPos) + 1.));\n\tvec3 vC = (vA + vB) * 0.5;\n\tfloat l = w * 0.048402;\n\tvec3 z = vec3(1.,2.,3.) * 0.0446 - 0.8;\n\tvec3 sunColor = vec3(0.0028) / ((pow(vec3(0.5) + l + 1.8611 * (cos(0.5 - z)) * abs(sin(l * 8.9583 - z * 2.)), vec3(1.2)) - vec3(0.5)) * l);\n\treturn max(mix(vC, vC * 0.4 + sunColor, length(sunColor) * 1.5) + sunColor, vec3(0.2,0.25,0.4));\n}\n\nmat3 SphericalViewMatrix(vec2 a)\n{\n\tvec2 c = cos(a);\n\tvec2 s = sin(a);\n\treturn mat3(c.y, s.x*s.y, c.x*s.y, 0., c.x, -s.x, s.y, -s.x*c.y, -c.x*c.y);\n}\n\nmat3 CreateTBNMatrix(vec3 N)\n{\n\tif (abs(N.y) > (1. - 1e-4))\n\t{\n\t\treturn mat3(1., 0., N.x, 0., 0., N.y, 0., 1., N.z);\n\t}\n\telse\n\t{\n\t\treturn SphericalViewMatrix(vec2(asin(-N.y), atan(N.z, N.x) + PI * 0.5));\n\t}\n}\n\nmat3 SphericalInverseViewMatrix(vec2 a)\n{\n\tvec2 c = cos(a);\n\tvec2 s = sin(a);\n\treturn mat3(c.y, 0., s.y, s.x*s.y, c.x, -s.x*c.y, c.x*s.y, -s.x, -c.x*c.y);\n}\n\nmat3 CreateInverseTBNMatrix(vec3 N)\n{\n\tif (abs(N.y) > (1. - 1e-4))\n\t{\n\t\treturn mat3(1., 0., 0., 0., 0., 1, N.x, N.y, N.z);\n\t}\n\telse\n\t{\n\t\treturn SphericalInverseViewMatrix(vec2(asin(-N.y), atan(N.z, N.x) + PI * 0.5));\n\t}\n}\n\n//Find roots using Cardano's method. https://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q+4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z)-q)*0.5;\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec2 closestPointOnQuadraticBezierCurve(vec3 p0, vec3 p1, vec3 p2) \n{\n\tvec2 A2 = p1.xy - p0.xy;\n\tvec2 B2 = p2.xy - p1.xy - A2;\n\t// Equation solution here: https://perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n\tvec3 r = vec3(-3.*dot(A2,B2), dot(-p0.xy,B2)-2.*dot(A2,A2), dot(-p0.xy,A2)) / -dot(B2,B2);\n\tvec2 t = clamp(solveCubic2(r.x, r.y, r.z), 0., 1.);\n\tvec3 A3 = p1 - p0;\n\tvec3 B3 = p2 - p1 - A3;\n\tvec3 D3 = A3 * 2.;\n\tvec3 pos1 = (D3+B3*t.x)*t.x+p0;\n\tvec3 pos2 = (D3+B3*t.y)*t.y+p0;\n\tpos1.xy /= fThickness;\n\tpos2.xy /= fThickness;\n\tfloat pos1Len = length(pos1.xy);\n\tif (pos1Len>1.)\n\t{\n\t\tpos1 = vec3(1e8);\n\t}\n\tfloat pos2Len = length(pos2.xy);\n\tif (pos2Len>1.)\n\t{\n\t\tpos2 = vec3(1e8);\n\t}\n\tpos1.z -= cos(pos1Len*HALFPI)*fThickness;\n\tpos2.z -= cos(pos2Len*HALFPI)*fThickness;\n\treturn (length(pos1) < length(pos2)) ? vec2(t.x, pos1Len) : vec2(t.y, pos2Len);\n}\n\n// Convert HSL colorspace to RGB. https://en.wikipedia.org/wiki/HSL_and_HSV\nvec3 HSL2RGB_CubicSmooth(in vec3 c)\n{\n\tvec3 rgb = clamp(abs(mod(c.x + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\trgb = rgb * rgb*(3.0 - 2.0*rgb); // iq's cubic smoothing\n\treturn c.z + c.y*(rgb - 0.5)*(1. - abs(2.*c.z - 1.));\n}\n\nmat3 inverseView(vec2 a)\n{\n\tvec2 s = sin(a);\n\tvec2 c = cos(a);\n\treturn mat3(c.y,0.,-s.y,s.x*s.y,c.x,s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\n\nvec2 findRaySphereRoots(in vec3 ro, in vec3 rd, in vec3 sc, in float r, out float disc)\n{\n\tvec3 dRoSc = ro - sc;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.*dot(rd, dRoSc);\n\tfloat c = dot(dRoSc, dRoSc) - r * r;\n\tdisc = max(b * b - 4. * a * c, 0.);\n\tfloat sqrtD = sqrt(disc);\n\tfloat twoA = 2.*a;\n\treturn (vec2(-b) + vec2(sqrtD, -sqrtD)) / twoA;\n}\n\nvec3 blinnPhong(in vec3 normal, in vec3 viewer, in vec3 light, in vec3 cDiffuse, in vec3 cSpecular)\n{\n\t// Compute the half vector \n\tvec3 half_vector = normalize(viewer + light);\n\t// Compute the angle between the half vector and normal \n\tfloat HdotN = max(0., dot(half_vector, normal));\n\t// Compute the specular colour \n\tvec3 specular = cSpecular * pow(HdotN, fSpecularExponent);\n\t// Compute the diffuse term \n\tvec3 diffuse = cDiffuse * max(fAmbient, dot(normal, light));\n\t// Determine the final colour \n\treturn vec3(diffuse + specular);\n}\n\nvec2 iAABox(in vec3 ro, in vec3 rd, in vec3 rad)\n{\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\treturn vec2(min(min(t2.x, t2.y), t2.z), max(max(t1.x, t1.y), t1.z));\n}\n\nvec2 iBox(in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad)\n{\n\t// convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd, 0.)).xyz;\n\tvec3 roo = (txx*vec4(ro, 1.)).xyz;\n\t// ray-box intersection in box space\n\tvec3 m = 1.0 / rdd;\n\tvec3 n = m * roo;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\treturn vec2(min(min(t2.x, t2.y), t2.z), max(max(t1.x, t1.y), t1.z));\n}\n\nvec3 ProjectPointToLineSegment(in vec3 a, in vec3 b, in vec3 p)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\treturn a + ba * dot(pa, ba) / dot(ba, ba);\n}\n\nmat4 setupInverse(vec3 vRight, vec3 vUp, vec3 vForward, vec3 vPos)\n{\n\treturn mat4(vRight.x, vUp.x, vForward.x, 0.,\n\t\tvRight.y, vUp.y, vForward.y, 0.,\n\t\tvRight.z, vUp.z, vForward.z, 0.,\n\t\tvPos.x, vPos.y, vPos.z, 1.);\n}\n\n#define BEZIER_POINT_ROTATION_MATRIX\tmat3 q = inverseView(vec2(sin(iTime*0.139)*2.2, 1.57 - iTime * -0.213));\n\n#define BEZIER_POINTS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat time = (iTime + i * vAnimationParams.x + 11.)*0.5;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 p0 = vec3(-1. + sin(0.15 - time * 0.74)*2.0, 3.7 + cos(time*-1.17)*2.8, 0.21 + sin(0.3 + time * 1.71)*0.9) * 3.;\t\t\\\n\tvec3 p1 = vec3(2. + cos(time*-0.85)*3.13, 3.5 + sin(-time * 0.432)*3.2, 0.61 + cos(0.2 + -time * 0.64)*1.9) * 3.;\t\t\t\\\n\tvec3 p2 = vec3(1.7 + sin(0.45 + time * 1.72)*2., 3.3 + cos(time*1.331)*2.972, 0.91 + sin(0.9 - time * 0.53)*1.3) * 3.;\t\t\\\n\tp0 = (q * (p0 - vSpherePos.xyz)) + vSpherePos.xyz;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tp1 = (q * (p1 - vSpherePos.xyz)) + vSpherePos.xyz;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tp2 = (q * (p2 - vSpherePos.xyz)) + vSpherePos.xyz;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n\n#define BEZIER_CALC_AABB\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tBEZIER_POINT_ROTATION_MATRIX\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vGlobalMin = vec3(1e8);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vGlobalMax = vec3(-1e8);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfor (float i = 1.; i < 19.; i += 1.)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tBEZIER_POINTS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec3 T = clamp((p0 - p1) / (p0 - 2.*p1 + p2), 0., 1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec3 iT = 1. - T;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tp1 = iT * iT*p0 + 2.*iT*T*p1 + T * T*p2;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvGlobalMin = min(vGlobalMin,min(min(p0,p1),p2));\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvGlobalMax = max(vGlobalMax,max(max(p0,p1),p2));\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvGlobalMin -= fThickness;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvGlobalMax += fThickness;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vAABBDim = (vGlobalMax - vGlobalMin) * 0.5;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vAABBCen = (vGlobalMax + vGlobalMin) * 0.5;\t\t\n\n#define GENERATE_BEZIER\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tBEZIER_POINTS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vCenterPointOnCurve = p0 * 0.25 + p1 * 0.5 + p2 * 0.25;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vOrigin = ProjectPointToLineSegment(p0, p2, vCenterPointOnCurve);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vRight = normalize(p2 - vOrigin);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vUp = normalize(vCenterPointOnCurve - vOrigin);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vPlaneNormal = cross(vRight, vUp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tmat3 mB = mat3(vRight, vUp, vPlaneNormal);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vA = p0 * mB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vB = p1 * mB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vC = p2 * mB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 T = clamp((vA - vB) / (vA - 2.*vB + vC), 0., 1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 iT = 1. - T;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvB = iT * iT*vA + 2.*iT*T*vB + T * T*vC;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vMin = min(min(vA,vB),vC) - fThickness;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vMax = max(max(vA,vB),vC) + fThickness;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vBoxDim = (vMax - vMin) * 0.5;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vBoxCen = (vMax + vMin) * 0.5;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tmat4 tma = setupInverse(vRight, vUp, vPlaneNormal, -vBoxCen);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 vBB = iBox(ro, rd, tma, vBoxDim);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (vBB.y < vBB.x)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 t = closestPointOnQuadraticBezierCurve((p0 - ro)*m, (p1 - ro)*m, (p2 - ro)*m);\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec3 A = p1 - p0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec3 sp = (A * 2. + (p2 - p1 - A) * t.x) * t.x + p0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfloat disc;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 sR = findRaySphereRoots(ro, rd, sp, fThickness, disc);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (disc > 0.)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tBEZIER_INTERSECTION_CODE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define BEZIER_INTERSECTION_CODE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tiIntersectCount++;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat fLocalMinDist = min(sR.x, sR.y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (fGlobalMinDist > fLocalMinDist)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (iIntersectCount > 1)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tvBackgroundColor *= vObjColor.xyz;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfloat fDensity = vPrimaryShadowParams.w - t.y * vPrimaryShadowParams.z;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfGlobalMinDist = fLocalMinDist;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec3 vPos = ro + rd * fGlobalMinDist;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec3 lightDirection = normalize(vLightPos - vPos);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvObjColor = vec4(blinnPhong(normalize(vPos - sp), -rd, lightDirection, HSL2RGB_CubicSmooth(vec3(t.x*3. + i / 19.*6., 1., 0.5)), vSpecularColor), clamp(vPrimaryShadowParams.x * fDensity * fDensity + vPrimaryShadowParams.y * fDensity, 0., 1.));\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvBackgroundColor *= HSL2RGB_CubicSmooth(vec3(t.x*3. + i / 19.*6., 1., 0.5));\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\nvec3 raytraceQuadraticBezierPrimaryRay(in mat3 m, in vec3 ro, in vec3 rd, in vec3 vBackgroundColor, in vec3 vAABBDim, in vec3 vAABBCen, in float iTime)\n{\n\tvec4 vObjColor = vec4(0.);\n\tvec2 vGBB = iAABox(ro - vAABBCen, rd, vAABBDim);\n\tif (vGBB.y < vGBB.x)\n\t{\n\t\tfloat fGlobalMinDist = 1e10;\n\t\tint iIntersectCount = 0;\n\t\tBEZIER_POINT_ROTATION_MATRIX\n\t\tfor (float i = 1.; i < 19.; i += 1.)\n\t\t{\n\t\t\tGENERATE_BEZIER\n\t\t}\n\t}\n\treturn mix(vBackgroundColor, vObjColor.xyz, vObjColor.w);\n}\n\n#undef BEZIER_INTERSECTION_CODE\n#define BEZIER_INTERSECTION_CODE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfloat fLocalMinDist = min(sR.x, sR.y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfloat fContact = vContactHarding.x * fLocalMinDist * fLocalMinDist + vContactHarding.y * fLocalMinDist + vContactHarding.z;\t\t\\\n\t\tfDensity += (vShadowParams.w - t.y * vShadowParams.z) * fContact;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvDiffuseColor *= HSL2RGB_CubicSmooth(vec3(t.x*3. + i / 19.*6., 1., 0.5));\n\nvoid raytraceQuadraticBezierShadow(in mat3 m, in vec3 ro, in vec3 rd, inout vec3 vDiffuseColor, inout float fDensity, in vec3 vAABBDim, in vec3 vAABBCen, in float iTime)\n{\n\tvec2 vGBB = iAABox(ro - vAABBCen, rd, vAABBDim);\n\tif (vGBB.y < vGBB.x)\n\t{\n\t\tBEZIER_POINT_ROTATION_MATRIX\n\t\tfor (float i = 1.; i < 19.; i += 1.)\n\t\t{\n\t\t\tGENERATE_BEZIER\n\t\t}\n\t}\n}\n\n#undef BEZIER_INTERSECTION_CODE\n#define BEZIER_INTERSECTION_CODE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfSunDensity += (vShadowParams.w - t.y * vShadowParams.z);\n\nfloat raytraceQuadraticBezierSun(in mat3 m, in vec3 ro, in vec3 rd, in vec3 vAABBDim, in vec3 vAABBCen, in float iTime)\n{\n\tfloat fSunDensity = 0.;\n\tvec2 vGBB = iAABox(ro - vAABBCen, rd, vAABBDim);\n\tif (vGBB.y < vGBB.x)\n\t{\n\t\tBEZIER_POINT_ROTATION_MATRIX\n\t\tfor (float i = 1.; i < 19.; i += 1.)\n\t\t{\n\t\t\tGENERATE_BEZIER\n\t\t}\n\t}\n\treturn fSunDensity;\n}\n\n//Based on: https://www.shadertoy.com/view/4sX3Rs\nvoid lensflares(vec2 uv, vec2 pos, out vec3 sunflare, out vec3 lensflare, in float iTime)\n{\n\tvec2 delta = uv - pos;\n\tvec2 uvd = uv * (length(uv));\n\tfloat ang = atan(delta.y, delta.x);\n\tfloat dist = length(delta);\n\tdist = pow(dist, 0.1);\n\tfloat f0 = 1. / (length(uv - pos)*25. + 1.);\n\tf0 = pow(f0, 2.);\n\tf0 += f0 * (sin((ang + iTime*0.1396)*vF0.z)*.1 + dist * vF0.y + vF0.x);\n\tfloat f2 = max(1.0 / (1.0 + 32.0*pow(length(uvd + 0.8*pos), 2.0)), .0)*00.25 * 0.2;\n\tfloat f22 = max(1.0 / (1.0 + 32.0*pow(length(uvd + 0.85*pos), 2.0)), .0)*00.23 * 0.2;\n\tfloat f23 = max(1.0 / (1.0 + 32.0*pow(length(uvd + 0.9*pos), 2.0)), .0)*00.21 * 0.2;\n\tvec2 uvx = mix(uv, uvd, -0.5);\n\tfloat f4 = max(0.01 - pow(length(uvx + 0.4*pos), 2.4), .0)*6.0;\n\tfloat f42 = max(0.01 - pow(length(uvx + 0.45*pos), 2.4), .0)*5.0;\n\tfloat f43 = max(0.01 - pow(length(uvx + 0.5*pos), 2.4), .0)*3.0;\n\tuvx = mix(uv, uvd, -.4);\n\tfloat f5 = max(0.01 - pow(length(uvx + 0.2*pos), 5.5), .0)*2.0;\n\tfloat f52 = max(0.01 - pow(length(uvx + 0.4*pos), 5.5), .0)*2.0;\n\tfloat f53 = max(0.01 - pow(length(uvx + 0.6*pos), 5.5), .0)*2.0;\n\tuvx = mix(uv, uvd, -0.5);\n\tfloat f6 = max(0.01 - pow(length(uvx - 0.3*pos), 1.6), .0)*6.0;\n\tfloat f62 = max(0.01 - pow(length(uvx - 0.325*pos), 1.6), .0)*3.0;\n\tfloat f63 = max(0.01 - pow(length(uvx - 0.35*pos), 1.6), .0)*5.0;\n\tsunflare = vec3(f0);\n\tlensflare = vec3(f2 + f4 + f5 + f6, f22 + f42 + f52 + f62, f23 + f43 + f53 + f63);\n}\n\nvec2 intersect(vec2 a1, vec2 b1, vec2 a2, vec2 b2)\n{\n\tvec2 t = inverse(mat2(b1 - a1, a2 - b2))*(a2 - a1);\n\treturn a1 + (b1 - a1)*t[0];\n}\n\nvec4 GetPixel(sampler2D iChannel, int cx, int cy, vec2 iResolution)\n{\n    return textureLod(iChannel, (vec2(cx,cy)+0.5)/iResolution.xy, 0.);\n}\n\n#define SETUP_SHADER\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 uv = (fragCoord.xy / iResolution.xy*2.-1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 vAspectRatio = vec2(iResolution.x / iResolution.y, 1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 s = uv*vAspectRatio;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 vScreenPixel = vec2(0.5) / vec2(iResolution);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vColorSum = vec3(0.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vSunPos = normalize(vec3(cos(vSunAngles.x)*cos(vSunAngles.y), sin(vSunAngles.y), sin(vSunAngles.x)*cos(vSunAngles.y)));\t\t\t\t\t\t\t\\\n\tvec3 vLookAt = vControllableLookAt;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vCameraPosition = vControllableCameraPosition;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat fMixValueA = clamp((iTime - fInitialDelay)*fInitialScalar, 0., 1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat fMixValueB = clamp((iTime - fTimeValueA)*0.15, 0., 1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat fMixValueC = clamp((iTime - fTimeValueA)*0.0325, 0., 0.85);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat fMixValueD = clamp((iTime - fTimeValueB)*0.1, 0., 1.0);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfloat iTimeB = max(0., ((iTime - fInitialDelay) * fInitialScalar)-1.);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 vScreenFocusPointAnim = vec2(fOffCenterValue + sin(iTimeB*2.47)*(fMixValueC+cos(iTime*0.23)*0.4), sin(iTimeB*6.53)*fMixValueC*0.17);\t\t\t\t\\\n\tvec2 vScreenFocusPoint = mix(vScreenFocusPoint, vScreenFocusPointAnim, fMixValueA);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vCamForwardDir = normalize(vec3(vScreenFocusPoint * vAspectRatio*fTanFOV, 1.));\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vSunDir = normalize(vSunPos - vLookAt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvCameraPosition = vLookAt - vCamForwardDir * (fDistanceToLookAt + cos(iTime * 0.1359) * clamp(cos(iTime * 0.05743), 0., 1.) * 50.2 * fMixValueD);\t\t\\\n\tvec2 iPoint = intersect(vLookAt.xz, vCameraPosition.xz, vLookAt.xz - vSunDir.xz, vCameraPosition.xz + vec2(10.,0.));\t\t\t\t\t\t\t\t\t\\\n\tfloat fAdd = (iPoint.x - vCameraPosition.x) * (0.9 + sin(iTime * 0.5)*0.35) * fMixValueB;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvLookAt.x += fAdd;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvCameraPosition.x += fAdd;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vCameraForward = normalize(vLookAt - vCameraPosition);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 vCSSunPos = vSunPos * CreateInverseTBNMatrix(vCameraForward);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvec2 vSunScreenPos = vec2(-vCSSunPos.x, vCSSunPos.y) / (vCSSunPos.z*fTanFOV);\t","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 iPixelIdx = ivec2(fragCoord+1e-2);\n\tif (iPixelIdx.y == 0 && iPixelIdx.x < 3)\n\t{\n\t\tBEZIER_CALC_AABB\n\t\tif (iPixelIdx.x == 0) \n\t\t{\n\t\t\tSETUP_SHADER\n\t\t\tvec3 vSunRayDir = normalize(vec3(vec2(-vSunScreenPos.x, vSunScreenPos.y) * fTanFOV, 1.)) * CreateTBNMatrix(vCameraForward);\n\t\t\tfloat fSunDensity = raytraceQuadraticBezierSun(inverseView(vec2(asin(-vSunRayDir.y), atan(vSunRayDir.x, vSunRayDir.z))), vCameraPosition, vSunRayDir, vAABBDim, vAABBCen, iTime);\n\t\t\tfloat fSunScalar = max(1.-fSunDensity,0.);\n\t\t\tfragColor = vec4(fSunScalar);\n\t\t}\n\t\telse if (iPixelIdx.x == 1)\n\t\t{\n\t\t\tfragColor = vec4(vAABBDim,0.);\n\t\t}\n\t\telse if (iPixelIdx.x == 2)\n\t\t{\n\t\t\tfragColor = vec4(vAABBCen,0.);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdiscard;\n\t}\n}","name":"Buffer A","description":"","type":"buffer"}]}