{"ver":"0.1","info":{"id":"McccW2","date":"1731169981","viewed":251,"name":"Structure Tensor Decoding","username":"TinyTexel","description":"Extracting minor and major axes, and eccentricity from a structure tensor.","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["filtering","stylization","aninsotropic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Extracting minor and major axes, and eccentricity from a structure tensor.\n    \n    A common bluilding block for image stylization is anisotropic filtering based on a smoothed gradient field.\n    Usually we want to filter the gradient field in an orientation agnostic manner i.e. so that grad == -grad.\n    The canonical approach to achieve this is by converting the gradients to structure tensors by 'squaring' them:\n    \n    grad = (x, y)^T      // ^T is the transpose operator\n    tens = grad * grad^T // take the outer product of grad\n    \n           |x² xy|   |A C|\n    tens = |     | = |   |\n           |xy y²|   |C B|.\n\n    After that we would filter the field of structure tensors (instead of the gradient field itself).\n    Finally we can extract filtering directions for our anisotropic filter from those smoothed structure tensors.\n    \n    Extracting a filtering direction from a structure tensor is non-trivial, but also not super complicated.\n    \n    Let's first consider what a structure tensor actually describes.\n    We can use our original gradient to describe a bi-variate linear function or more specifically\n    an equation for a 0-centered plane:\n    \n    lin(x, y) = <(x, y)^T, grad> // <,> is the dot/scalar product\n    \n              = (x, y) grad\n              \n              = x grad.x + y grad.y\n              \n    Likewise, we can use a structure tensor to describe a bi-variate quadratic function or more specifically\n    an equation for a 0-centered elliptic paraboloid (https://en.wikipedia.org/wiki/Paraboloid#Elliptic_paraboloid):\n\n    quad(x, y) = (x, y) tens (x, y)^T // 'Expressing a quadratic form with a matrix': https://www.youtube.com/watch?v=0yEiCV-xEWQ\n    \n               = A x² + B y² + 2C xy\n    \n    To extract a filtering direction from either, lin or quad, we can use the following approach:\n    \n    1. Define a f(ang) so that it evaluates f(x, y) on the unit circle:\n    \n        f(ang) := f(cos(ang), sin(ang))\n        \n    2. Find the extrema of f(ang) by differentiating it and finding its roots:\n    \n                d\n        solve ----- f(ang) = 0, for ang.\n              d ang\n\n    3. Compute your filtering direction from ang:\n    \n        dir = (cos(ang), sin(ang))^T\n\n    Depending on your use case and on which direction you found you might need to rotate dir by 90°.\n\n    Let's apply these steps to quad(x, y) = A x² + B y² + 2C xy:\n    \n    1.\n    \n        quad(ang) = A cos(ang)² + B sin(ang)² + 2C cos(ang) sin(ang)\n    \n    2a.\n    \n          d\n        ----- quad(ang) = 2 C cos(ang)² - 2 A cos(ang) sin(ang) + 2 B cos(ang) sin(ang) - 2 C sin(ang)²\n        d ang\n                        = 2(C (cos(ang)² - sin(ang)²) + (B - A) cos(ang) sin(ang))\n    \n                        = 2 C cos(2 ang) + (B - A) sin(2 ang) // using [cos(ang)² - sin(ang)² = cos(2 ang)    ] and \n                                                                       [cos(ang)  * sin(ang)  = sin(2 ang) / 2]\n    2b.\n    \n          d\n        ----- quad(ang) = 0\n        d ang\n        \n        2 C cos(2 ang) + (B - A) sin(2 ang) = 0\n        \n        2 C cos(2 ang) = (A - B) sin(2 ang)\n    \n         2 C    sin(2 ang)\n        ----- = ---------- = tan(2 ang)\n        A - B   cos(2 ang)\n        \n        ang = atan2(A - B, 2 C) / 2 // with argument ordering atan2(x, y)\n    \n    \n    This means that using the elements of our structure tensor we can define a vector\n    \n    tvec = (A - B, 2 C)^T\n    \n    that points in the direction of twice the angle that we are looking for.\n    Therefore, the easiest way to compute dir without the use of atan2 would be:\n    \n    dir = normalize(normalize(tvec) + vec2(1.0, 0.0));\n    \n    or\n    \n    dir = normalize(tvec + vec2(length(tvec), 0.0));\n    \n    Alternatively, we can normalize tvec and use trigonometric half-angle formulas to cut its angle in half.\n    I found this approach to be a bit more numerically accurate than the ones above.\n    \n    Another nice property of the structure tensor, aside from encoding gradients in an orientation agnostic manner, is that\n    its eccentricity relates to the orientational variance of the set of gradients used to compute it.\n    With other words, its eccentricity can be used to describe how iso- or anisotropic the gradient field is in a local neighborhood.\n    \n    The elliptic eccentricity can be computed by first solving\n    \n    quad(dir.x, dir.y) = quad(-s dir.y, s dir.x) for s. // find length of major axis if minor axis is set to 1\n    \n    The eccentricity e is then\n    \n    e = sqrt(1 - b²/a²) // https://en.wikipedia.org/wiki/Eccentricity_(mathematics)#Ellipses\n    \n    with a = s and b = 1.\n    \n    In practice this simplifies to\n    \n    a = quad( dir.x, dir.y)\n    b = quad(-dir.y, dir.x).\n    \n    The eccentricity ranges from 0 (isotropic) to inf (max ansisotropic).\n    \n    The easiest way to get a structure tensor with an eccentricity of inf is to compute it from a single vector.\n    The easiest way to get a structure tensor with an eccentricity of 1 is to compute it from two orthogonal vector of the same magnitude.\n    \n    \n    Related:\n    \n        - 'On Crafting Painterly Shaders': https://blog.maximeheckel.com/posts/on-crafting-painterly-shaders/\n           -> covers applications and an alternate derivation\n*/\n\nvec3 STensor_from_Vec(vec2 vec)\n{\n    return vec.xyx * vec.xyy;\n}\n\nfloat Eval_STensor(vec3 tens, vec2 vec)\n{\n    return dot(tens * vec3(1.0, 1.0, 2.0), vec.xyx * vec.xyy);\n}\n\n#if 1\nvec2 Dir_from_STensor(vec3 tens)\n{\n    vec2 tvec = vec2(tens.x - tens.y, 2.0 * tens.z);\n    \n    float eps = 0.0;//exp2(-25.0);\n    bool y_cond = abs(tvec.y) <= eps;\n    if ( y_cond ) return tvec.x < 0.0 ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    \n    // ntvec_x = normalize(tvec).x = cos(atan(tvec.y, tvec.x))\n    float ntvec_x = tvec.x * inversesqrt(dot(tvec, tvec));\n    \n    float ysgn = tvec.y < 0.0 ? -1.0 : 1.0;\n    \n    // x = cos(acos(v)/2) | y = sin(acos(v)/2) (half-angle formulas)\n    float x = sqrt(max(0.0, 0.5 + 0.5 * ntvec_x));\n    float y = sqrt(max(0.0, 0.5 - 0.5 * ntvec_x)) * ysgn;\n    \n    return vec2(x, y);\n}\n#else\nvec2 Dir_from_STensor(vec3 tens)\n{\n    vec2 tvec = vec2(tens.x - tens.y, 2.0 * tens.z);\n    \n    float eps = 0.0;//exp2(-25.0);\n    bool y_cond = abs(tvec.y) <= eps;\n    if ( y_cond ) return tvec.x < 0.0 ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    \n    return normalize(tvec + vec2(length(tvec), 0.0));\n}\n#endif\n\nfloat Eval_MinorAxisRelLenSqr(vec3 tens, vec2 dirB)\n{\n    vec2 dirA = vec2(-dirB.y, dirB.x);\n    \n    float fa = Eval_STensor(tens, dirA);\n    float fb = Eval_STensor(tens, dirB);\n    \n    return 1.0 - clamp(1.0 - fa / fb, 0.0, 1.0);// flush NaN to 1\n}\n\nfloat Eval_MinorAxisRelLen(vec3 tens, vec2 dirB)\n{\n    return sqrt(Eval_MinorAxisRelLenSqr(tens, dirB));\n}\n\nfloat Eval_EccentricitySqr(vec3 tens, vec2 dirB)\n{\n    return 1.0 - Eval_MinorAxisRelLenSqr(tens, dirB);\n}\n\nfloat Eval_Eccentricity(vec3 tens, vec2 dirB)\n{\n    return sqrt(Eval_EccentricitySqr(tens, dirB));\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv00 = uv0;\n    \n  #if 1\n    float s = 0.25;\n  \n    vec2 res = ceil(iResolution.xy * 0.25);\n    vec2 uv = uv0 / res;\n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    uv0 = uvF * res;\n  #else\n    float s = 1.;\n  \n    vec2 res = iResolution.xy;\n    vec2 uvI = vec2(0.0);\n  #endif\n    \n    vec3 tens = vec3(0.0);\n    \n    // accumulate a bunch of random struct tensors\n    uint h = 6211111u;// start seed\n    h += uint(uvI.x + 1024.0 * uvI.y);\n    float count = 3.0;\n    for(float i = 0.0; i < count; ++i)\n    {\n        vec2 grad = Hash11x2(h);\n    \n        tens += STensor_from_Vec(grad);\n    }\n    \n    tens /= count;\n\n\n    // extract information from struct tensor\n    vec2 dirA = Dir_from_STensor(tens);// minor axis\n    vec2 dirB = vec2(-dirA.y, dirA.x);// major axis\n    \n    float lenA = Eval_MinorAxisRelLen(tens, dirA);// minor axis length / major axis length\n\n\n    // draw\n    vec2 uv2 = uv0 - res * 0.5;\n        \n    float f = Eval_STensor(tens, uv2);\n\n    float lines = DrawIsoLines(f / s * 0.0004, 0.75, 0.0);\n    \n    float u = iResolution.x / 1024.0;\n    float t = 8.0 * s * u;\n    float l = 256.0*s * u;\n    \n    float circ  = DrawEllipse(uv2, t * vec2(1.0, 1.0 ), vec2(1.0, 0.0));\n    float elli  = DrawEllipse(uv2, l * vec2(1.0, lenA), dirB);\n    float axisA = DrawLine   (uv2, l * lenA           , dirA);\n    float axisB = DrawLine   (uv2, l                  , dirB);\n    \n    vec3 col = vec3(1.0);\n    \n    col *= lines;\n    col = mix(col, vec3(1.0, 0.0, 0.0), circ);\n    col = mix(col, vec3(1.0, 0.0, 0.0), elli);\n    col = mix(col, vec3(1.0, 0.0, 0.5), axisA);\n    col = mix(col, vec3(1.0, 0.5, 0.0), axisB);\n    \n    col *= DrawIsoLines(uv00.x/iResolution.x / s * Pi - Pi05, 0.9, 0.5);\n    col *= DrawIsoLines(uv00.y/iResolution.y / s * Pi - Pi05, 0.9, 0.5);\n    \n    outCol = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nfloat DrawEllipse(vec2 p, vec2 r, vec2 dirA)\n{\n    p = vec2(dot(p, dirA), dot(p, vec2(-dirA.y, dirA.x)));\n    \n    float v = length(p * vec2(1.0, r.x/r.y));\n    v = (r.x - v);\n    \n    v /= length(vec2(dFdx(v), dFdy(v)));\n    \n    return clamp(1.0 - abs(v - 0.5) * 0.5, 0.0, 1.0);\n}\n\nfloat DrawLine(vec2 p, float len05, vec2 dir)\n{\n    float x = dot(p, vec2(-dir.y, dir.x));\n\n    x /= length(vec2(dFdx(x), dFdy(x)));\n\n    float y = dot(p, dir);\n\n    y /= length(vec2(dFdx(y), dFdy(y)));\n        \n    float line = (1.0 - clamp(abs(x)*0.75-0.5, 0.0, 1.0));\n \n    float lm = len05 < 1.0 ? 0.0 : (1.0 - clamp(abs(y)-len05, 0.0, 1.0));\n \n    return line * lm;\n}\n\nfloat DrawIsoLines(float v, float sharp, float thick)\n{\n    v = cos(v);\n    v /= length(vec2(dFdx(v), dFdy(v)));\n    v = abs(v) * sharp - thick;\n    \n    return clamp(v, 0.0, 1.0);\n}\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\n\n#define Pow2(x) ((x)*(x))\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. O’Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(inout uint state  ) { return pcg(state); }\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4  Hash01x4(inout uint state) { return Float01(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash01x3(inout uint state) { return Float01(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash01x2(inout uint state) { return Float01(uvec2(pcg(state), pcg(state))); }\nfloat Hash01  (inout uint state) { return Float01(      pcg(state)); }\n\nvec4  Hash11x4(inout uint state) { return Float11(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash11x3(inout uint state) { return Float11(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash11x2(inout uint state) { return Float11(uvec2(pcg(state), pcg(state))); }\nfloat Hash11  (inout uint state) { return Float11(      pcg(state)); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n","name":"Common","description":"","type":"common"}]}