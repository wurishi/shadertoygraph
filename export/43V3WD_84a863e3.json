{"ver":"0.1","info":{"id":"43V3WD","date":"1717688899","viewed":112,"name":"Realtime SDF Ray Tracing","username":"dema","description":"My first experiment with real time ray tracing. Single shader, soft shadows, ambient occlusion, fast SDF ray tracing for reflections and refractions, ray marching for volumes. The terrain hf is cached to save computation while the volume is procedural.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","sdf","realtime","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCopyright (c) [2024] [Giorgio De Magistris]. All rights reserved.\n\nPermission is granted to use, copy, modify, and distribute this software for any purpose with or without fee, \nprovided that this copyright notice appears in all copies. This software is provided \"as is\" without any \nexpress or implied warranties. The author is not liable for any damages arising from the use of this software.\n\n*/\n\n\n/*-----------------------------------------------------*/\n/*-----------------     Camera   ----------------------*/\n/*-----------------------------------------------------*/\nmat3 getCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 z = normalize(ta-ro);\n\tvec3 up = vec3(0.0,1.0,0.0);\n\tvec3 x = normalize( cross(z,up) );\n\tvec3 y =          ( cross(x,z) );\n    return mat3( x, y, z );\n}\n\nvec3 getPixelCoords(in vec2 uv, in mat3 cam, float fl)\n{\n    vec3 p = cam * normalize(vec3(uv,fl));\n    return p;\n}\n\n\n/*-----------------------------------------------------*/\n/*-----------------    RayMarch  ----------------------*/\n/*-----------------------------------------------------*/\n#define RAYMARCH_ST_MINDIST  0.0001\n#define RAYMARCH_ST_MAXITER  1000\n#define RAYMARCH_RM_MAXITER  1000\n\n#define DEBUG_RM_RETURN_ITER_COUNT 0\n#define DEBUG_ST_RETURN_ITER_COUNT 0\n\nvec2 sdMap(vec3 p);\nvec2 hfMap(vec3 p);\n\n// adapted from https://www.shadertoy.com/view/Xds3zN\nvec2 sphereTracing( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    vec2 res = vec2(-1.0,-1.0);\n    float t = tmin;\n    int i = 0;\n    for( i=0; i<RAYMARCH_ST_MAXITER; i++ )\n    {\n        vec2 h = sdMap( ro+rd*t );\n        if( abs(h.x)<(RAYMARCH_ST_MINDIST*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += abs(h.x);\n        if(t >= tmax)\n        {\n            break;\n        }\n    }\n    #if DEBUG_ST_RETURN_ITER_COUNT > 0\n    return vec2(float(i)/float(RAYMARCH_ST_MAXITER),res.y);\n    #else\n    return res;\n    #endif\n}\n\n\n// adapted from https://iquilezles.org/articles/terrainmarching/\nvec2 rayMarching( vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float dt = 0.01;\n    float lh = 0.0;\n    float ly = 0.0;\n    vec2 res = vec2(-1.0,-1.0);\n    float t = tmin;\n    int i = 0;\n    for(i=0; i< RAYMARCH_RM_MAXITER;i++)\n    {\n        vec3  p = ro + rd*t;\n        vec2 h = hfMap( p );\n        if( p.y < h.x )\n        {\n            // interpolate the intersection distance\n            res.y = h.y;\n            res.x = t - dt + dt*(lh-ly)/(p.y-ly-h.x+lh);\n            #if DEBUG_RM_RETURN_ITER_COUNT > 0\n            return vec2(float(i)/float(RAYMARCH_RM_MAXITER),res.y);\n            #else\n            return res;\n            #endif\n        }\n        // allow the error to be proportinal to the distance\n        dt = 0.01*t;\n        lh = h.x;\n        ly = p.y;\n        t += dt;\n        if(t>tmax)\n        {\n            #if DEBUG_RM_RETURN_ITER_COUNT > 0\n                return vec2(float(i)/float(RAYMARCH_RM_MAXITER),-1.0);\n            #else\n            return vec2(-1.0,-1.0);\n            #endif\n        }\n    }\n    #if DEBUG_RM_RETURN_ITER_COUNT > 0\n    return vec2(float(i)/float(RAYMARCH_RM_MAXITER),-1.0);\n    #else\n    return vec2(-1.0,-1.0);\n    #endif\n}\n\nvec2 combineSdfHeightField(vec2 sdRes, vec2 hfRes)\n{\n    if(sdRes.x > 0.0 && hfRes.x > 0.0)\n        if(sdRes.x < hfRes.x)\n            return sdRes;\n        else\n            return hfRes;\n    if(sdRes.x < 0.0 && hfRes.x > 0.0)\n        return hfRes;\n    if(hfRes.x < 0.0 && sdRes.x > 0.0)\n        return sdRes;\n    return vec2(-1.0,-1.0);\n}\n\nvec2 sdOpU( vec2 d1, vec2 d2 )\n{\n\treturn (abs(d1.x)<abs(d2.x)) ? d1 : d2; // the absolute value make it work also when\n}                                           // a transparent object is intersected by a \n                                            // opaque object\nvec2 hfOpU( vec2 h1, vec2 h2)\n{\n    return h1.x > h2.x ? h1 : h2;\n}\n\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    vec2 hfRes = rayMarching(ro,rd,tmin,tmax);\n    vec2 sdRes = sphereTracing(ro,rd,tmin,tmax);\n    vec2 res = combineSdfHeightField(sdRes,hfRes);\n    return res;\n}\n\nvec3 getNormal(float id,vec3 p)\n{\n    // SDF\n    if(id < 100.0)\n    {\n        vec3 dx = vec3(.001,0.,0.);\n        vec3 dy = vec3(0.,.001,0.);\n        vec3 dz = vec3(0.,0.,.001);\n        float fp = sdMap(p).x;\n        return normalize(\n            dx * (sdMap(p+dx).x - fp) + \n            dy * (sdMap(p+dy).x - fp) +\n            dz * (sdMap(p+dz).x - fp)\n        );\n    }\n    // HeightField\n    else\n    {\n        float eps = 0.001;\n        vec3 epsx = vec3(eps,0.0,0.0);\n        vec3 epsz = vec3(0.0,0.0,eps);\n        return normalize( vec3( hfMap(p-epsx).x - hfMap(p+epsx).x,\n                                2.0*eps,\n                                hfMap(p-epsz).x - hfMap(p+epsz).x ) );\n    }\n}\n\n\n\n/*-----------------------------------------------------*/\n/*-----------------      SDF     ----------------------*/\n/*-----------------------------------------------------*/\n// Signed Distance Function from Inigo Quilez's website: \n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n/*-----------------------------------------------------*/\n/*-----------------     Noise    ----------------------*/\n// Custom implementation of Perlin Noise\n\n// Some hash functions\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\nfloat hash3(vec3 p) {\n    const vec3 k = vec3(0.3183099, 0.3678794, 0.5772157);\n    float n = dot(p, vec3(127.1, 311.7, 74.7));\n    return fract(sin(n) * 43758.5453123);\n}\n\n\n// perlin noise\n\nfloat sInterp(float t) {\n\treturn ((6.0*t - 15.0)*t + 10.0)*t*t*t;\n}\n\nfloat perlin3D(vec3 uvw, vec3 grid_size, float seed)\n{\n    uvw = uvw*grid_size;\n    vec3 vseed = vec3(seed);\n    vec3 nbl = floor(uvw);\n    vec3 ntr = vec3(ceil(uvw.x),ceil(uvw.y),floor(uvw.z));\n    vec3 ntl = vec3(floor(uvw.x),ceil(uvw.y),floor(uvw.z));\n    vec3 nbr = vec3(ceil(uvw.x),floor(uvw.y),floor(uvw.z));\n    \n    vec3 fbl = vec3(floor(uvw.x),floor(uvw.y),ceil(uvw.z));\n    vec3 ftr = ceil(uvw);\n    vec3 ftl = vec3(floor(uvw.x),ceil(uvw.y),ceil(uvw.z));\n    vec3 fbr = vec3(ceil(uvw.x),floor(uvw.y),ceil(uvw.z));\n    \n    vec3 vntl = uvw-ntl;\n    vec3 vnbr = uvw-nbr;\n    vec3 vntr = uvw-ntr;\n    vec3 vnbl = uvw-nbl;\n    \n    vec3 vftl = uvw-ftl;\n    vec3 vfbr = uvw-fbr;\n    vec3 vftr = uvw-ftr;\n    vec3 vfbl = uvw-fbl;\n    \n    vec3 rv[8] = vec3[8](vec3(1.0,1.0,1.0),vec3(1.0,-1.0,1.0),vec3(-1.0,-1.0,1.0),vec3(-1.0,1.0,1.0),\n                         vec3(1.0,1.0,-1.0),vec3(1.0,-1.0,-1.0),vec3(-1.0,-1.0,-1.0),vec3(-1.0,1.0,-1.0));\n    ntl = rv[int(floor(hash3(ntl+vseed)*8.0))];\n    nbr = rv[int(floor(hash3(nbr+vseed)*8.0))];\n    ntr = rv[int(floor(hash3(ntr+vseed)*8.0))];\n    nbl = rv[int(floor(hash3(nbl+vseed)*8.0))];\n    \n    ftl = rv[int(floor(hash3(ftl+vseed)*8.0))];\n    fbr = rv[int(floor(hash3(fbr+vseed)*8.0))];\n    ftr = rv[int(floor(hash3(ftr+vseed)*8.0))];\n    fbl = rv[int(floor(hash3(fbl+vseed)*8.0))];\n    \n    float n1 = dot(ntl,vntl);\n    float n2 = dot(ntr,vntr);\n    float n3 = dot(nbl,vnbl);\n    float n4 = dot(nbr,vnbr);\n    \n    float f1 = dot(ftl,vftl);\n    float f2 = dot(ftr,vftr);\n    float f3 = dot(fbl,vfbl);\n    float f4 = dot(fbr,vfbr);\n    \n    float su = sInterp(fract(uvw.x));\n    float sv = sInterp(fract(uvw.y));\n    float sw = sInterp(fract(uvw.z));\n\n    float nx1 = mix(n1,n2,su);\n    float nx2 = mix(n3,n4,su);\n    float nr  = mix(nx2,nx1,sv);\n    \n    float fx1 = mix(f1,f2,su);\n    float fx2 = mix(f3,f4,su);\n    float fr  = mix(fx2,fx1,sv);\n    \n    float r = mix(nr,fr,sw);\n    return (r + 1.0) / 2.0; \n}\n\n/*-----------------------------------------------------*/\n/*-----------------     fBM    ----------------------*/\n/*-----------------------------------------------------*/\n// Fractional Brownian Motion, adapted from\n// Ebert, David S., et al. Texturing and modeling: a procedural approach. Elsevier, 2002.\nfloat noise(vec3 uvw);\n// usually lacunarity = 2\n//         H = 1\nfloat fBM( vec3 point, float H, float lacunarity, int octaves )\n{\n    float value;\n    float remainder;\n    int i;\n    value = 0.0;\n    /* inner loop of fractal construction */\n    for (i=0; i<octaves; i++) {\n        value += noise( point ) * pow( lacunarity, -H*float(i) );\n        point *= lacunarity;\n    }\n    return value;\n}\n\n\n/*-----------------------------------------------------*/\n/*-----------------    Ambient   ----------------------*/\n/*-----------------------------------------------------*/\nvec2 sampleCircle(int index, int nSamples, float radius) {\n    float angle = 2.0 * 3.14159265 * float(index) / float(nSamples);\n    float x = radius * cos(angle);\n    float y = radius * sin(angle);\n    return vec2(x, y);\n}\n\nfloat hfAmbientOcclusion(vec3 p, int nSamples, float radius, float amount) {\n    float ao = 0.0;\n    for(int i = 0; i < nSamples; i++) {\n        vec2 pi = p.xz + sampleCircle(i, nSamples, radius);\n        float hi = hfMap(vec3(pi.x, 0.0, pi.y)).x - hfMap(vec3(p.x, 0.0, p.y)).x;\n        float thetai = atan(hi, radius);\n        ao += sin(thetai);\n    }\n    ao = ao / float(nSamples);  \n    ao = clamp(ao,0.0,1.0);\n    ao *= amount;\n    return 1.0 - ao;  \n}\n\n// ambient occlusion from https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat sdAmbientOcclusion(vec3 p, int nSamples, float delta, float amount) {\n    float ao = 0.0;\n    vec3 dx = vec3(.001,0.,0.);\n    vec3 dy = vec3(0.,.001,0.);\n    vec3 dz = vec3(0.,0.,.001);\n    float fp = sdMap(p).x;\n    vec3 n =  normalize(\n        dx * (sdMap(p+dx).x - fp) + \n        dy * (sdMap(p+dy).x - fp) +\n        dz * (sdMap(p+dz).x - fp)\n    );\n    for(int i = 0; i < nSamples; i++) {\n        ao += 1.0/pow(2.0,float(i)) * (float(i) * delta - sdMap(p + n*float(i)*delta).x);\n    }\n    ao = clamp(ao,0.0,1.0);\n    ao *= amount;\n    return 1.0 - ao;  \n}\n\nfloat ambientOcclusion(float id, vec3 p)\n{\n    float ao = 1.0;\n    if(id<100.0)\n    {\n        ao = sdAmbientOcclusion(p,4,0.1,1.0);\n    }\n    else\n    {\n        ao = hfAmbientOcclusion(p,4,0.4,0.2);\n    }\n    return ao;\n}\n\n\n\n/*-----------------------------------------------------*/\n/*-----------------    Shading   ----------------------*/\n/*-----------------------------------------------------*/\n#define SHADING_MATERIAL_TYPE_DIELECTRIC 1\n#define SHADING_MATERIAL_TYPE_METALLIC   2\n#define SHADING_MATERIAL_TYPE_VOLUME     3\n#define SHADING_LIGHT_TYPE_POINT 1\n#define SHADING_LIGHT_TYPE_DIRECTIONAL 2\n#define SHADING_VOLUMETRIC_DT 0.05\n\n#define PI 3.14\n#define MAX_STACK_SIZE 3\n#define MAX_DEPTH 5\n#define N_LIGHTS 1\n\n\nvec2 sdMap(vec3 p);\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax);\nvec3 environment(vec3 d);\nvec3 getNormal(float id,vec3 p);\nfloat ambientOcclusion(float id, vec3 p);\n\nstruct Material{\n    int type;\n    vec3 albedo;\n    float roughness;\n    bool castShadow;\n    // only for SHADING_MATERIAL_TYPE_DIELECTRIC\n    bool transparent; \n    float ior;\n    vec3 extinction;\n    // -----------------------------------------\n    // only for SHADING_MATERIAL_TYPE_VOLUMT\n    vec3 absorption;\n    vec3 scattering;\n    float density;      \n};\n\nstruct Light{\n    int type;\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n};\n\nLight lights[N_LIGHTS];\n\nvec3 schlick(vec3 n , vec3 rd, vec3 f0){\n    vec3 v = reflect(rd,n);\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - clamp(dot(n,v),0.0,1.0),5.0);\n}\n\nMaterial getMaterial(float id, vec3 p);\n\n// adapted from https://iquilezles.org/articles/rmshadows/\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt)\n{\n    float k = 16.0;\n    float res = 1.0;\n    float t = mint;\n    float id = -1.0;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        vec3 p = ro + rd*t;\n        vec2 h = sdMap(p);\n        Material m = getMaterial(h.y,p);\n        t += h.x;\n        if(h.y > 0.0 && m.castShadow)\n        {\n            if( h.x<0.001 )\n                return 0.0;\n            res = min( res, k*h.x/t );\n        }\n        else{\n            t += 16.0*mint;\n        }\n    }\n    return res;\n}\n\nstruct TraceInfo{\n    vec3 ro;\n    vec3 rd;\n    vec3 multiplier;\n    float ior;\n    float maxDist;\n    int depth;\n};\n\n\nvec3 shade(vec3 ro, vec3 rd, float ior, Light lights[N_LIGHTS],float minDist, float maxDist,float ambientStrength, vec3 ambientColor)\n{\n    vec3 color = vec3(0.0);\n    int stackElems = 1;\n    TraceInfo stack[MAX_STACK_SIZE];\n    stack[0] = TraceInfo(ro,rd,vec3(1.0),ior,maxDist,0);\n   \n    while(stackElems>0)\n    {\n        stackElems = stackElems - 1;\n        TraceInfo current = stack[stackElems];\n        \n        if(current.maxDist <= minDist || current.depth >= MAX_DEPTH) \n            continue;\n        \n        vec2 ires = intersect(current.ro,current.rd,minDist,current.maxDist);\n        // environment\n        if(ires.y < 0.0)\n        {\n            color += current.multiplier * environment(current.rd);\n        }\n        else{\n            vec3 p = current.ro + ires.x * current.rd;\n            Material m = getMaterial(ires.y,p);\n            vec3 n = getNormal(ires.y,p);\n            float ao = ambientOcclusion(ires.y,p);\n            // -----------------\n            // opaque dielectric\n            // -----------------\n            if(m.type==SHADING_MATERIAL_TYPE_DIELECTRIC && !m.transparent)\n            {\n                vec3 diffuse = vec3(0.0);\n                for(int lid=0;lid<N_LIGHTS;lid++)\n                {\n                    diffuse += dot(n,lights[lid].direction) * lights[lid].color * softShadow(p,lights[lid].direction,minDist,maxDist);\n                }\n                diffuse = diffuse * m.albedo + ao * ambientStrength * ambientColor * m.albedo;\n                color += current.multiplier * diffuse;\n                if(m.roughness<0.9)\n                {\n                    float F0 = pow((current.ior - m.ior)/(current.ior + m.ior),2.0);\n                    vec3 reflected = reflect(current.rd,n);\n                    vec3 fresnel = schlick(n,current.rd,vec3(F0));\n                    if(stackElems<MAX_STACK_SIZE)\n                    {\n                        stackElems += 1;\n                        stack[stackElems - 1] = TraceInfo( p,\n                                                           reflected,\n                                                           current.multiplier * fresnel,\n                                                           current.ior,\n                                                           current.maxDist-ires.x,\n                                                           current.depth+1);\n                    }\n                }\n                \n            }\n            // -----------------\n            // metallic\n            // -----------------\n            else if(m.type==SHADING_MATERIAL_TYPE_METALLIC)\n            {\n                vec3 reflected = reflect(current.rd,n);\n                vec3 fresnel = schlick(n,current.rd,m.albedo);\n                if(stackElems<MAX_STACK_SIZE)\n                {\n                    stackElems += 1;\n                    stack[stackElems - 1] = TraceInfo(  p,\n                                                        reflected,\n                                                        current.multiplier * fresnel,\n                                                        current.ior,\n                                                        current.maxDist-ires.x,\n                                                        current.depth+1);\n                }\n            }\n            // -----------------\n            // transparent dielectric\n            // -----------------\n            else if(m.type==SHADING_MATERIAL_TYPE_DIELECTRIC && m.transparent)\n            {\n                \n                bool isExternal = current.ior != m.ior;\n                vec3 extinction = vec3(1.0);\n                if(isExternal)\n                {\n                    vec3 p1 = p;\n                    vec2 ires2 = intersect(p1, current.rd, minDist,current.maxDist);\n                    if(ires2.x>-1.0)\n                    {\n                        extinction = exp(-ires2.x*m.extinction);\n                    }\n                }\n                vec3 geomNormal = isExternal ? n : -n;\n                vec3 reflected = reflect(current.rd,geomNormal);\n                vec3 refracted = isExternal ? refract(current.rd,n,current.ior/m.ior) : \n                                              refract(current.rd,-n,m.ior/current.ior);\n                float refractIor = isExternal ? m.ior : current.ior;\n                float reflectIor = isExternal ? current.ior : m.ior;\n                vec3 fresnel = schlick(geomNormal,current.rd,m.albedo);\n                if(stackElems<MAX_STACK_SIZE)\n                {\n                    stackElems += 1;\n                    stack[stackElems -1] = TraceInfo(   p,\n                                                        refracted,\n                                                        extinction * current.multiplier * (vec3(1.0)-fresnel),\n                                                        refractIor,\n                                                        current.maxDist-ires.x,\n                                                        current.depth+1);\n                }\n                if(stackElems<MAX_STACK_SIZE)\n                {\n                    stackElems += 1;\n                    stack[stackElems - 1] = TraceInfo(  p,\n                                                        reflected,\n                                                        current.multiplier * fresnel,\n                                                        reflectIor,\n                                                        current.maxDist-ires.x,\n                                                        current.depth+1);\n                }\n\n            }\n            // -----------------\n            // volume\n            // -----------------\n            else if(m.type==SHADING_MATERIAL_TYPE_VOLUME)\n            {\n                vec3 p1 = p;\n                vec2 ires2 = intersect(p1, current.rd, minDist,current.maxDist);\n                // This handles the case when due to \n                // numerical approximation the ray\n                // enters the volume but does not exit\n                if(ires2.x < 0.0){\n                    if(stackElems<MAX_STACK_SIZE)\n                    {\n                        stackElems += 1;\n                        stack[stackElems -1] = TraceInfo(   p1,\n                                                            current.rd,\n                                                            current.multiplier,\n                                                            current.ior,\n                                                            current.maxDist-ires.x,\n                                                            current.depth+1);\n                    }\n                    continue;\n                }\n                vec3 p2 = p1 + ires2.x * current.rd;\n                float interval = ires2.x;\n                \n                vec3 transmittanceExp = vec3(0.0);\n                vec3 scattered = vec3(0.0);\n                int steps = int(interval / SHADING_VOLUMETRIC_DT);\n                Material mt;\n                for(int i=0;i<steps;i++){\n                    vec3 pt = p1 + float(i)*SHADING_VOLUMETRIC_DT*current.rd;\n                    mt = getMaterial(ires.y,pt);\n                    \n                    transmittanceExp += mt.density * ((vec3(1.0)-mt.absorption) + (vec3(1.0)-mt.scattering)) * SHADING_VOLUMETRIC_DT;\n                    vec3 transmittance = exp(-transmittanceExp);\n                    vec3 lScat = vec3(0.0);\n                    for(int lid=0;lid<N_LIGHTS;lid++)\n                    {\n                        // simple scattering function ignoring\n                        // visibility term and phase function\n                        lScat += (1.0/(4.0*PI))*lights[lid].color;\n                    }\n                    lScat *= vec3(PI);\n                    scattered += mt.density * transmittance * lScat * mt.scattering * SHADING_VOLUMETRIC_DT;\n                }\n                color += current.multiplier*scattered;\n                vec3 transmittance = exp(-transmittanceExp);\n                if(stackElems<MAX_STACK_SIZE)\n                {\n                    if(ires2.y != ires.y)\n                    {\n                    stackElems += 1;\n                    stack[stackElems -1] = TraceInfo(   p2 - minDist*current.rd,\n                                                        current.rd,\n                                                        current.multiplier * transmittance,\n                                                        current.ior,\n                                                        current.maxDist-(ires.x+ires2.x),\n                                                        current.depth+1);\n                    }\n                    else{\n                    stackElems += 1;\n                    stack[stackElems -1] = TraceInfo(   p2,\n                                                        current.rd,\n                                                        current.multiplier * transmittance,\n                                                        current.ior,\n                                                        current.maxDist-(ires.x+ires2.x),\n                                                        current.depth+1);\n                    }\n                }\n            }\n            // -----------------\n            // material not implemented\n            // -----------------\n            else return vec3(1.0,0.0,1.0);\n        }\n    }\n    return color;\n}\n\n\n/*-----------------------------------------------------*/\n/*-----------------    Textures  ----------------------*/\n/*-----------------------------------------------------*/\nvec3 checkerboard(vec2 uv, int grid_size, vec3 color1, vec3 color2){\n    float idx = floor(uv.x * float(grid_size));\n    float idy = floor(uv.y * float(grid_size));\n    if( mod(idx + idy,2.0)==0.0 ) return color1;\n    else return color2;\n}\n\n/*-----------------------------------------------------*/\n/*-----------------    Main  ----------------------*/\n/*-----------------------------------------------------*/\n#define MIN_DIST 0.1\n#define MAX_DIST 30.0\n\n\n#define AMBIENT_STRENGTH 0.15\n#define AMBIENT_COLOR vec3(0.0, 0.8, 1.0)\n\n// return vec2(signed_dist,id), for SDFs use ids below 100.0\nvec2 sdMap(vec3 p)\n{\n    return sdOpU(\n        // clouds\n        vec2(sdRoundBox(p-vec3(0.0,4.0,0.0),vec3(4.5,1.5,4.5),1.0),5.5),\n        sdOpU(\n         // glass  \n        vec2(sdSphere(p-vec3(0.0,1.0,0.0),1.0),3.5),//vec2(sdBox(p-vec3(0.0,1.0,0.0),vec3(2.0,1.1,2.0)),3.5),\n        // ball1 \n        vec2(sdSphere(p-vec3(0.0 + 1.5*sin(iTime),2.5 + 1.8 ,.0),0.8),2.5)));\n\n}\n\n// return vec2(height,id), for heightfields use ids above 100.0\nvec2 hfMap(vec3 p)\n{\n    return vec2(mix(0.0,5.5*texture(iChannel0,(p.xz+MAX_DIST)/(2.0*MAX_DIST)).x,smoothstep(0.0,25.5,length(p.xz))),100.0);\n}\n\nvec3 environment(vec3 d)\n{\n    return mix(vec3(0.5333, 0.9059, 1.0),vec3(0.0, 0.8, 1.0),d.y);\n}\n\n\nfloat noise(vec3 p)\n{\n    return perlin3D(p, vec3(3.0), 9.0);\n}\n\nMaterial getMaterial(float id, vec3 p){\n    Material m;\n    // nothing\n    if(id < 0.0)\n    {\n        m.type=-1;\n    }\n    // ball1\n    else if(id <= 3.0)\n    {\n        m.type = SHADING_MATERIAL_TYPE_DIELECTRIC;\n        m.albedo = vec3(0.5686, 0.8784, 0.8784);\n        m.castShadow = true;\n        m.transparent = false;\n        m.roughness = 0.0;\n        m.ior = 1.5;\n    }\n    // glass box\n    else if(id <= 4.0)\n    {\n        m.type = SHADING_MATERIAL_TYPE_DIELECTRIC;\n        m.albedo = vec3(0.005);\n        m.castShadow = false;\n        m.transparent = true;\n        m.ior = 1.5;\n        m.extinction = vec3(0.0);\n    }\n    // Clouds\n    else if(id <= 6.0)\n    {\n        m.type = SHADING_MATERIAL_TYPE_VOLUME;\n        m.castShadow = true;\n        m.scattering = vec3(1.0);\n        m.absorption = vec3(0.3255, 0.0196, 0.0196);\n        m.density =  5.5*fBM(p + vec3(0.3*iTime,-0.1*iTime,0.0), 1.0, 3.0,3 ) * exp(-pow(length(p-vec3(0.0,4.0,0.0)),1.2));\n        m.castShadow = false;\n\n    }\n    // plane\n    else if(id <= 101.0)\n    {\n        m.type = SHADING_MATERIAL_TYPE_DIELECTRIC;\n        m.albedo = checkerboard(0.5*p.xz + 0.5,1,vec3(0.64,0.60,0.57),vec3(0.73,0.70,0.67));\n        m.transparent = false;\n        m.roughness = 1.0;\n    }\n    return m;\n}\n\n\nvoid initLights()\n{\n    lights[0] = Light(SHADING_LIGHT_TYPE_DIRECTIONAL,vec3(0.0),normalize(vec3(1.0,1.0,0.0)),vec3(1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 mo = vec2(1.0) - iMouse.xy / iResolution.xy;\n    vec3 ta = vec3(0.0,1.0,0.0);\n    vec3 ro = vec3(8.5*cos(2.0*3.14*mo.x + 1.9),4.5 + 4.5*clamp(cos(3.14*mo.y),-0.7,1.0),8.5*sin(2.0*3.14*mo.x + 1.9));\n    mat3 cam = getCamera(ro,ta);\n    vec3 rd  = getPixelCoords(st,cam,2.1);\n\n    initLights();\n\n    vec3 color = shade(ro,rd,1.0,lights,MIN_DIST,MAX_DIST,AMBIENT_STRENGTH,AMBIENT_COLOR);\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*-----------------------------------------------------*/\n/*-----------------     Noise    ----------------------*/\n// Custom implementation of Perlin Noise\n\n// Some hash functions\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\nfloat hash3(vec3 p) {\n    const vec3 k = vec3(0.3183099, 0.3678794, 0.5772157);\n    float n = dot(p, vec3(127.1, 311.7, 74.7));\n    return fract(sin(n) * 43758.5453123);\n}\n\n\n// perlin noise\n\nfloat sInterp(float t) {\n\treturn ((6.0*t - 15.0)*t + 10.0)*t*t*t;\n}\n\nfloat perlin2D(vec2 uv, vec2 grid_size, float seed)\n{\n    uv = uv*grid_size;\n    vec2 vseed = vec2(seed);\n    vec2 bl = floor(uv);\n    vec2 tr = ceil(uv);\n    vec2 tl = vec2(floor(uv.x),ceil(uv.y));\n    vec2 br = vec2(ceil(uv.x),floor(uv.y));\n    \n    vec2 vtl = uv-tl;\n    vec2 vbr = uv-br;\n    vec2 vtr = uv-tr;\n    vec2 vbl = uv-bl;\n    \n    vec2 rv[4] = vec2[4](vec2(1.0,1.0),vec2(1.0,-1.0),vec2(-1.0,-1.0),vec2(-1.0,1.0));\n    tl = rv[int(floor(hash1(tl+vseed)*4.0))];\n    br = rv[int(floor(hash1(br+vseed)*4.0))];\n    tr = rv[int(floor(hash1(tr+vseed)*4.0))];\n    bl = rv[int(floor(hash1(bl+vseed)*4.0))];\n    \n    float g1 = dot(tl,vtl);\n    float g2 = dot(tr,vtr);\n    float g3 = dot(bl,vbl);\n    float g4 = dot(br,vbr);\n    \n    float su = sInterp(fract(uv.x));\n    float sv = sInterp(fract(uv.y));\n\n    float x1 = mix(g1,g2,su);\n    float x2 = mix(g3,g4,su);\n    float n  = mix(x2,x1,sv);\n    return (n + 1.0) / 2.0; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==0)\n    {\n        vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n        float height =perlin2D(uv, vec2(4.0), 9.0);\n        fragColor = vec4(height,0.0,0.0,0.0);\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iChannel0,uv);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}