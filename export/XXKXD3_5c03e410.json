{"ver":"0.1","info":{"id":"XXKXD3","date":"1720574865","viewed":35,"name":"LifeFractal","username":"ozazl","description":"i=n^-i","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// ShaderToy built-in uniforms\n// iTime and iResolution are predefined and used directly\n\n// Constants\n#define MAX_STEPS 3\n#define SURF_DIST 1.01\n#define MAX_DIST 100.0\n\n// Function to generate a rotation matrix in 4D\nmat4 rotationMatrix4D(float angle, int i, int j) {\n    mat4 m = mat4(1.0);\n    float c = cos(angle);\n    float s = sin(angle);\n    m[i][i] = c; m[i][j] = -s;\n    m[j][i] = s; m[j][j] = c;\n    return m;\n}\n\n// Function to invert a point in 4D\nvec4 invert(vec4 point) {\n    return point / dot(point, point);\n}\n\n// Function to generate a fractal in 4D\nvec4 generateFractal(vec4 point, int iterations, float angle) {\n    for (int i = 0; i < iterations; i++) {\n        point = abs(point) - 0.5;\n        point = invert(point);\n        point = rotationMatrix4D(angle, 0, 1) * point;\n        point = rotationMatrix4D(angle, 2, 3) * point;\n    }\n    return point;\n}\n\n// Function to compress 4D points to 3D\nvec3 compressTo3D(vec4 point) {\n    return point.xyz / point.w;\n}\n\n// Distance estimator for the fractal\nfloat getDistance(vec3 p) {\n    vec4 p4 = vec4(p, 1.0);\n    p4 = generateFractal(p4, MAX_STEPS, iTime * 0.1);\n    vec3 p3 = compressTo3D(p4);\n    return length(p3 - p);\n}\n\n// Ray marching algorithm\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDistance(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// Color palette\nvec3 colorPalette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 0.7, 0.4);\n    vec3 d = vec3(0.00, 0.15, 0.20);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Main image function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float d = rayMarch(ro, rd);\n    vec3 color = vec3(0.0);\n\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 normal = normalize(vec3(\n            getDistance(p + vec3(0.01, 0.0, 0.0)) - getDistance(p - vec3(0.01, 0.0, 0.0)),\n            getDistance(p + vec3(0.0, 0.01, 0.0)) - getDistance(p - vec3(0.0, 0.01, 0.0)),\n            getDistance(p + vec3(0.0, 0.0, 0.01)) - getDistance(p - vec3(0.0, 0.0, 0.01))\n        ));\n\n        float light = dot(normal, vec3(0.577, 0.577, 0.577));\n        color = colorPalette(light);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}