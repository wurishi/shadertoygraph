{"ver":"0.1","info":{"id":"7sKyzR","date":"1654408669","viewed":150,"name":"Cellular Automata Evo Pt 2","username":"JoeyIsEpic8","description":"Here me and a friend explore the world of cellular automata.\nSeveral bits of key inspiration\nhttps://www.youtube.com/watch?v=X-iSQQgOd1A\nhttps://www.youtube.com/watch?v=E7CxMHsYzSs\nhttps://www.youtube.com/watch?v=4XEklaH9k6k&t=1749s","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["evolutionautomataarray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired and EVOLVED FROM\n// Jordan's \"Cellular Automata with Diffusion\" \n// https://www.shadertoy.com/view/tscGRB\n//\n// camjay\n// https://www.shadertoy.com/view/NdVczR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.005\n#define TURNSPED 0.5\n#define ANGLSENS 0.01\n#define PI 3.1415926535897932384626433832795\n\n\n// the 5 decides how much vison is given to each cell\nconst int visionSize = 2;\n\n\n\n\n\n// may need to add safety features\nint localToArray(int a,int b) {\n    return a + 2 * visionSize + (b + 2 * visionSize) * (4 * visionSize + 1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Game Starting Code\nbool closeEnf(in float a, in float b)\n{\n    return (abs(a-b) <= EPSILON);\n}\n\n\nvec4 initalizeGame(vec4 c)\n{\n    if( closeEnf(c.y,0.5) )\n        return vec4(c.x , 1. , 0. , 1.);\n    \n    return vec4(0. , 0. , c.z , 1.);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Random Number Generator\nfloat rand(vec2 co){\n  \treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * length(iDate));\n}\n\nint xorshift(in int value) // For random number generation\n{\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed)  // RNG\n{\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(inout int seed) // RNG\n{\n    seed = xorshift(seed);\n    return abs(fract(float(seed) / 31416.592898653));\n}\n\nfloat nextFloat(inout int seed, in float max) // RNG\n{\n    return nextFloat(seed) * max;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Supporting Funtions\nint myFloor(in float a)\n{\n    int recall = 1;\n    int working = 0;\n    \n    for(int i=0;i<100;i++)\n    {\n        if( (a >= float(working)) && (a < float(working + 1)))\n            return working;\n        \n        if(working > 0)\n            working -= recall;\n        else\n            working += recall;\n            \n        recall++;\n            \n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Getting enviorment stuff\nint xIntFdir(in float dir)\n{\n    return  myFloor( (0.5 + cos(dir * 2. * PI)*float(visionSize)) ) ;\n}\n\nint yIntFdir(in float dir)\n{\n    return myFloor( (0.5 + -sin(dir * 2. * PI)*float(visionSize)) );\n}\n\nint findingLook(in float dir)\n{\n    return localToArray( xIntFdir(dir) , yIntFdir(dir) );\n}\n\nint theyLook(in float dir, in int a, in int b)\n{\n    return localToArray( a + xIntFdir(dir) , b + yIntFdir(dir) );\n}\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Sampling the UV texture from before\nvec3 get(vec2 coord) {\n    return texture(iChannel0, coord).rgb;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 map = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * map;\n    float mouseDown = iMouse.z;\n    int rngSeed = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) + int(iTime * 1000.0);\n    \n    // Initalizing Stuff\n    vec3 next = vec3(0.,0.,0.);\n    \n    \n    \n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Building Vision Array\n    // neiBrs is short for neighbour hood\n    vec3 neiBrs[ (4*visionSize + 1)*(4*visionSize + 1) ];\n    \n    for(int i=(-2*visionSize) ; i<=(2*visionSize) ; i++)\n    {\n        for(int j=(-2*visionSize) ; j<=(2*visionSize) ; j++)\n        {\n            neiBrs[ localToArray( i , j ) ] = get(uv + vec2( i , j ) * map);\n        }\n    }\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // You are not an ANT\n    if(neiBrs[ localToArray( 0 , 0 ) ].g < .5)\n    {\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        // Pharamone spread\n        for(int i=-1 ; i<=1 ; i++)\n        {\n            for(int j=-1 ; j<=1 ; j++)\n            {\n                next.b += neiBrs[ localToArray( i , j ) ].b;\n            }\n        }\n        next.b = next.b/9.0;\n        next.b = next.b*.97;\n        \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        // Hom many ants want to move here\n        int moveHereTotal = 0;\n        int moveHereLast = 0;\n        for(int i=(-2*visionSize) ; i<=(2*visionSize) ; i++)\n        {\n            for(int j=(-2*visionSize) ; j<=(2*visionSize) ; j++)\n            {\n                if(\n                   // Is this an ANT\n                   (neiBrs[ localToArray( i , j ) ].g>=.5) &&\n                   // does the ant want to come here\n                   (localToArray( 0 , 0 ) == theyLook( neiBrs[ localToArray( i , j ) ].r , i , j ))\n                  )\n                {\n                    moveHereTotal++;\n                    moveHereLast = localToArray( i , j );\n                }\n            }\n        }\n        \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        // An ant has sucsessfully moved to this space\n        if(moveHereTotal == 1)\n        {\n            next.g = 1.;\n            \n            // sensors\n            int cnLook = findingLook(neiBrs[moveHereLast].r);\n            int cwLook = findingLook(neiBrs[moveHereLast].r + ANGLSENS);\n            int ccLook = findingLook(neiBrs[moveHereLast].r - ANGLSENS);\n            \n            \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            // How to decide where to move next\n            if((neiBrs[cnLook].b >= neiBrs[ccLook].b) && (neiBrs[cnLook].b >= neiBrs[cwLook].b))\n            {\n                next.r = neiBrs[moveHereLast].r;\n            }\n            else if((neiBrs[cnLook].b <= neiBrs[ccLook].b) && (neiBrs[cnLook].b <= neiBrs[cwLook].b))        \n            {\n                next.r = neiBrs[moveHereLast].r + (nextFloat(rngSeed, 1.0) - 0.5) * TURNSPED;\n            }\n            else if((neiBrs[ccLook].b <= neiBrs[cwLook].b))        \n            {\n                next.r = neiBrs[moveHereLast].r + ANGLSENS;\n            }\n            else if((neiBrs[cwLook].b <= neiBrs[ccLook].b))        \n            {\n                next.r = neiBrs[moveHereLast].r - ANGLSENS;\n            }\n            else\n            {\n                next.r = neiBrs[moveHereLast].r + (nextFloat(rngSeed, 1.0) - 0.5) * TURNSPED;\n            }          \n\n            if(next.r > 1.)\n                next.r -= 1.;\n            if(next.r < 0.)\n                next.r += 1.;\n        }\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        // No one move here\n        else\n        {\n            next.r = 0.;\n            next.g = 0.;        \n        }\n    }\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // You are an ANT\n    else if(neiBrs[localToArray( 0 , 0 )].g > .5)\n    {\n    \n        next = neiBrs[localToArray( 0 , 0 )];\n        \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        // Find out if you have a valid place to go\n        bool canMoveHere = true;\n        \n        // Where are you going, findingLook is finding where you want to go\n        int cnLook = findingLook( neiBrs[localToArray( 0 , 0 )].r );\n        \n        // Now we see if anyone else wants to go there\n        for(int i=(-2*visionSize) ; i<=(2*visionSize) ; i++)\n        {\n            for(int j=(-2*visionSize) ; j<=(2*visionSize) ; j++)\n            {\n                if( \n                    // Dont care if no one is there\n                    (neiBrs[ localToArray( i , j ) ].g>=.5) && \n                    // Where are they looking\n                    (cnLook == theyLook( neiBrs[ localToArray( i , j ) ].r , i , j )) && \n                    // Did I just check myself\n                    (localToArray( i , j ) != localToArray( 0 , 0 ))\n                  )\n                {\n                    canMoveHere = false;\n                }\n            }\n        }\n        \n        // Is where I am moving to ocupide\n        if(neiBrs[cnLook].g>=.5)\n        {\n            canMoveHere = false;\n        }\n        \n        // Finally the move\n        if(canMoveHere)\n        {\n            next.g = 0.;\n            next.r = 0.;\n            next.b = 1.;\n        }\n        else\n        {\n            next.b = 0.;\n            next.r = nextFloat(rngSeed, 1.0);\n        }\n    }\n    \n    \n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // We have finished with the time step\n    fragColor = vec4(next,1.0);\n    \n    \n    if((iFrame < 5) || mouseDown>0.5) \n    {\n        fragColor = initalizeGame(texture(iChannel1,uv));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}