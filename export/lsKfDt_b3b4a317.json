{"ver":"0.1","info":{"id":"lsKfDt","date":"1531137908","viewed":172,"name":"Camera training","username":"FlorianDuf","description":"I am training my self.\nI will improve this shader later.\n\nYou can use it to understant how camera work in 3D pipeline.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","camera","training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*vec2 blinnPhongDir(vec3 lightDir, float lightInt, float Ka, float Kd, float Ks, float shininess)\n{\n  vec3 s = normalize(lightDir);\n  vec3 v = normalize(-fPosition);\n  vec3 n = normalize(fNormal);\n  vec3 h = normalize(v+s);\n  float diffuse = Ka + Kd * lightInt * max(0.0, dot(n, s));\n  float spec =  Ks * pow(max(0.0, dot(n,h)), shininess);\n  return vec2(diffuse, spec);\n}*/\n\nstruct Light {\n    vec3 pos;\n    float energy;\n};\n\nvec3 phong(in Light light, in vec3 p, in vec3 n, in float shininess)\n{\n    \n    vec3 lp = normalize(light.pos- p);\n    float d = clamp( dot( n,lp ),0.0,1.0);\n   \n    float s = pow(d, shininess);\n    float a = 0.0;\n    \n    return vec3(d, s, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n\tcam = Camera(vec3(0.0,2.0,-100.0 + 90.0 * (sin(iTime) * 0.5 + 0.5)), vec3(0.0), 1.0);\n    \n    float a=iTime*0.725;\n    cam.ro = rotateY(cam.ro, a);\n    \n    target(vec3(0.0), uv);\n    \n    \n    /*float d = 0.0;\n    \n    d += drawPoint(cam.ro, cam.rd, vec3(-1.0, -1.0, -1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(-1.0, -1.0, 1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(-1.0, 1.0, -1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(1.0, -1.0, -1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(-1.0, 1.0, 1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(1.0, -1.0, 1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(1.0, 1.0, -1.0));\n    d += drawPoint(cam.ro, cam.rd, vec3(1.0, 1.0, 1.0));\n\n    vec3 col = vec3(d);*/\n    \n    Sphere s1 = Sphere( vec3(0.0,0.0,5.0), 1.0);\n    Sphere s2 = Sphere( vec3(0.0), 1.0);\n    Sphere s3 = Sphere( vec3(-10.0,2.6,1.7), 2.0);\n    \n    Light light = Light(vec3(1.0), 1.0);\n    \n    vec3 col = texture(iChannel0, cam.rd).rgb;;\n    \n    vec3 n1, n2, n3;\n    float t1 = 10000.0;\n    float t2 = 10000.0;\n    float t3 = 10000.0;\n    \n    bool int1 = intersect(s1, n1, t1);\n    bool int2 = intersect(s2, n2, t2);\n    bool int3 = intersect(s3, n3, t3);\n    \n    if ( int1 && t1 < t2  && t1 < t3 )\n    {\n    \tcol = texture(iChannel0, reflect(cam.rd, n1)).rgb;\n    }\n    else if ( int2 && t2 < t1  && t2 < t3  )\n    {\n        vec3 env = texture(iChannel0, vec3(0.5)).rgb;\n        vec3 p = cam.ro + t2 * cam.rd;\n        vec3 phong_ = phong(light, p, n2, 100.0);\n        col = ( vec3(0.0,0.5,0.5) * light.energy * phong_.x + vec3(1.0) * phong_.y ) + vec3(0.15)*env;\n    }\n    \n    else if ( int3 && t3 < t1 && t3< t1)\n    {\n        col = texture(iChannel0, reflect(cam.rd, n3)).rgb;\n    }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Camera\n\nstruct Camera {\n\tvec3 ro;\n    vec3 rd;\n    \n    float zoom;\n};\n\nCamera cam = Camera(vec3(0.0,0.0,-3.0), vec3(0.0), 1.0); //init\n\nvoid target(in vec3 lookat, in vec2 uv)\n{\n\tvec3 front = normalize(lookat - cam.ro);\n    vec3 right = cross(vec3(0.0,1.0,0.0), front);\n    vec3 up = cross(front, right);\n    \n    vec3 c = cam.ro + front* cam.zoom;\n    \n    vec3 i = c + uv.x*right + uv.y*up;\n    \n    cam.rd = i - cam.ro;\n}\n\n// Sphere \n\nstruct Sphere {\n\tvec3 c;\n    float r;\n};\n\n//void rotateCam(in float x, in float y, in float x\n    \n// \nfloat distanceLine(in vec3 ro, in vec3 rd, in vec3 p)\n{\n    \n    return length(cross(p-ro, rd)) / length(rd);\n}\n\n\nfloat drawPoint(in vec3 ro, in vec3 rd, in vec3 p)\n{\n    float d = distanceLine(ro, rd, p);\n    d = step(d, 0.05);\n    \n    return d;\n}\n\n\n// with help of Julien Alamelle\nbool intersect(in Sphere s, out vec3 n, out float t)\n{\n\n    vec3 m = cam.ro - s.c;\n    float a = dot(cam.rd, cam.rd);\n    float b = 2.0 * dot(cam.rd, m);\n    \n    float c = dot( m,m) - s.r*s.r;\n    \n    float discr = b*b-4.0*a*c;\n    \n    if ( discr < 0.0) return false;\n\n    t= 0.0;\n    \n    t = -b - sqrt(discr);\n    t /= 2.0 * a;\n    \n    if ( t < 0.0 ) return false;\n    \n    n = (m + t * cam.rd );\n    \n    return true;\n    \n   \n}\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}","name":"Common","description":"","type":"common"}]}