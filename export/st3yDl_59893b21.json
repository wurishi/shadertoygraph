{"ver":"0.1","info":{"id":"st3yDl","date":"1660830044","viewed":170,"name":"Discrete Fourier Transform","username":"Envy24","description":"Green                      - function to be sampled,\nPurple                     - samples,\nRed (cross)              - restored values,\nBlue (horizontal)       - real part of DFT,\nLight blue (diagonal) - imagine part of DFT.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["inverse","fourier","discrete","transform","dft","idft"],"hasliked":0,"parentid":"sdVfRt","parentname":"Fourier approximation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define TAU                         6.2831853071795862\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* */\n#define M        ( 3. )\n#define func(x)  ( (x)*sin(M*(x)) )\n#define deriv(x) ( sin(M*(x))+M*(x)*cos(M*(x)) )\n/* *\n#define M        ( 2.0 )\n#define func(x)  ( sin(M*(x)) )\n#define deriv(x) ( M*cos(M*(x)) )\n/* *\n#define func(x)  ( (x) )\n#define deriv(x) ( 1. )\n/* *\n#define func(x)  ( (x)*(x) )\n#define deriv(x) ( 2.*(x) )\n/* *\n#define func(x)  ( (x)*(x)*(x) ) \n#define deriv(x) ( 3.*(x)*(x) )\n/* *\n#define func(x)  ( abs(x) ) \n#define deriv(x) ( (x)/abs(x) )\n/* *\nfloat pulseOsc(\n    float amplitude,   // in range [0.0; 1.0]\n    float frequency,   // > 0.0\n    float time,        \n    float phase_shift,\n    float pulse_width)\n{\n    float phase = phase_shift + time * TAU * frequency;\n    \n    float sign_ = fract(phase / TAU) >= pulse_width ? 1.0 : -1.0;\n\n    return sign_ * amplitude;\n}\n#define func(x) ( pulseOsc(1., 1., x, 0., 0.5) )\n#define deriv(x) ( 0. )\n/* *\nfloat rectangle(float T, float x)\n{\n    float T2 = T*0.5, T4 = T*0.4;\n    \n    return \n        (x>=-T2)&&(x<-T4) ?\n            -1. :\n            (x>=-T4)&&(x<T4) ?\n                1. :\n                -1.;\n}\n#define func(x) ( rectangle(PI, x) )\n#define deriv(x) ( 0. )\n/* *\nfloat impulse(float x, float x0)\n{\n    return \n        abs(x-x0) < 1e-14 ?\n            1. :\n            0.;\n}\n#define func(x) ( impulse(x, 0.) )\n#define deriv(x) ( 0. )\n/* */\n\n/* Variant A when expression for f(x) is unknown *\nconst int N = 16;\nfloat TDS[N]; // Time domain signal\nvec2 FDS[N+1]; // Frequency domain signal\nfloat RTDS[N]; // Restored time domain signal\n\nvoid sample_func(\n    inout float TDS[N],\n    in float a,\n    in float b)\n{\n    float dx = (b-a)/float(N);\n\n    for(int i = 0; i < N; ++i)\n    {\n        TDS[i] = func(a+float(i)*dx);\n    }\n}\n\nvoid DFT(\n    inout vec2 FDS[N+1],\n    in float TDS[N])\n{\n    int output_count = N + 1;\n    float inv = 1.0 / float(N);\n\n    for (int bin_idx = 0; bin_idx < output_count; ++bin_idx)\n    {\n        FDS[bin_idx] = vec2(0);\n\n        float dPhase = TAU * float(bin_idx) * inv;\n\n        for (int sample_idx = 0; sample_idx < N; ++sample_idx)\n        {\n            FDS[bin_idx].x += TDS[sample_idx] * cos(dPhase * float(sample_idx));\n            FDS[bin_idx].y += TDS[sample_idx] * sin(dPhase * float(sample_idx));\n        }\n        \n        FDS[bin_idx] *= inv;\n    }\n    FDS[0] *= 0.5; FDS[N] *= 0.5;\n}\n\nvoid IDFT(\n    inout float RTDS[N],\n    in vec2 FDS[N+1])\n{\n    int input_count = N + 1, output_count = N;\n    float inv = 1.0 / float(N);\n\n    for (int sample_idx = 0; sample_idx < output_count; ++sample_idx)\n    {\n        RTDS[sample_idx] = 0.;\n\n        float dPhase = TAU * inv * float(sample_idx);\n\n        for (int bin_idx = 0; bin_idx < input_count; ++bin_idx)\n        {\n            RTDS[sample_idx] +=\n                (FDS[bin_idx].x * cos(dPhase * float(bin_idx)))\n                + (FDS[bin_idx].y * sin(dPhase * float(bin_idx)));\n        }\n    }\n}\n/**/\n\n/* Variant B when expression for f(x) is known *\nconst int N = 8;\nvec2 FDS[N+1]; // Frequency domain signal\nfloat RTDS[N]; // Restored time domain signal\n\nvoid DFT(\n    inout vec2 FDS[N+1],\n    float a, \n    float b)\n{\n    int output_count = N + 1;\n    float inv = 1.0 / float(N),\n          dx = (b-a) / float(N);\n\n    for (int bin_idx = 0; bin_idx < output_count; ++bin_idx)\n    {\n        FDS[bin_idx] = vec2(0);\n\n        float dPhase = TAU * float(bin_idx) * inv;\n\n        for (int sample_idx = 0; sample_idx < N; ++sample_idx)\n        {\n            FDS[bin_idx].x += func(a + float(sample_idx) * dx) * cos(dPhase * float(sample_idx));\n            FDS[bin_idx].y += func(a + float(sample_idx) * dx) * sin(dPhase * float(sample_idx));\n        }\n        \n        FDS[bin_idx] *= inv;\n    }\n    FDS[0] *= 0.5; FDS[N] *= 0.5;\n}\n\nvoid IDFT(\n    inout float RTDS[N],\n    in vec2 FDS[N+1])\n{\n    int input_count = N + 1, output_count = N;\n    float inv = 1.0 / float(N);\n\n    for (int sample_idx = 0; sample_idx < output_count; ++sample_idx)\n    {\n        RTDS[sample_idx] = 0.;\n\n        float dPhase = TAU * inv * float(sample_idx);\n\n        for (int bin_idx = 0; bin_idx < input_count; ++bin_idx)\n        {\n            RTDS[sample_idx] +=\n                (FDS[bin_idx].x * cos(dPhase * float(bin_idx)))\n                + (FDS[bin_idx].y * sin(dPhase * float(bin_idx)));\n        }\n    }\n}\n/**/\n\n/* Variant C with different normalizations. */\nconst int N = 16;\nfloat TDS[N]; // Time domain signal\nvec2 FDS[N]; // Frequency domain signal\nfloat RTDS[N]; // Restored time domain signal\n\nvoid sample_func(\n    inout float TDS[N],\n    in float a,\n    in float b)\n{\n    float dx = (b-a)/float(N);\n\n    for(int i = 0; i < N; ++i)\n    {\n        TDS[i] = func(a+float(i)*dx);\n    }\n}\n\nvoid DFT(\n    inout vec2 FDS[N],\n    in float TDS[N])\n{\n    float N_ = float(N),\n          dA = (2.*PI)/(N_),\n          inv = 1./N_;\n    \n    for (float k = 0.; k < N_; k += 1.)\n    {\n        FDS[int(k)] = vec2(0);\n        \n        for (float n = 0.; n < N_; n += 1.)\n        {\n            FDS[int(k)] += TDS[int(n)]*vec2(cos(k*dA*n), sin(k*dA*n));\n        }\n        \n        FDS[int(k)] *= inv;\n    }\n}\n\nvoid IDFT(\n    inout float RTDS[N],\n    in vec2 FDS[N])\n{\n    float N_ = float(N),\n          dA = (2.*PI)/(N_),\n          inv = 1./N_;\n    \n    for (float n = 0.; n < N_; n += 1.)\n    {\n        RTDS[int(n)] = 0.;\n        \n        for (float k = 0.; k < N_; k += 1.)\n        {\n            RTDS[int(n)] += FDS[int(k)].x*cos(k*dA*n) + FDS[int(k)].y*sin(k*dA*n);\n        }\n        \n        //RTDS[int(n)] *= inv;\n    }\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 3.5\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n\n    float a = -PI, b = PI, dx = (b-a)/float(N);\n         //color.gb -= vertical_line(NDC, a); color.gb -= vertical_line(NDC, b);\n         color -= horizontal_line(NDC, -PI)*0.2; color -= horizontal_line(NDC, PI)*0.2;\n    \n    /* Variant A *\n    sample_func(TDS, a, b);\n    DFT(FDS, TDS);\n    IDFT(RTDS, FDS);\n    int K = N + 1;\n    /* Variant B *\n    DFT(FDS, a, b);\n    IDFT(RTDS, FDS);\n    int K = N + 1;\n    /* Variant C */\n    sample_func(TDS, a, b);\n    DFT(FDS, TDS);\n    IDFT(RTDS, FDS);\n    int K = N;\n    /**/\n    \n    for (int i = 0; i < N; ++i)\n    {\n        float x = a+float(i)*dx;\n        vec2 B = vec2(x, 0.), E = vec2(x, func(x));\n        \n        /* Sampled values */\n        color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, B, UNIT*2.2)));\n        color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, E, UNIT*2.2)));\n        color = mix(color, vec3(1, 0, 1), SMAA(segmentSDF_L2(NDC, B, E)));\n        /* Sampled values */\n        \n        E = vec2(x, RTDS[i]);\n        \n        /* Restored values */\n        vec2 offs = vec2(0.1, 0.);    \n        color = mix(color, vec3(1., 0, 0), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n             offs = vec2(0., 0.1);    \n        color = mix(color, vec3(1., 0, 0), SMAA(segmentSDF_L2(NDC, E+offs, E-offs)))\n        /* Restored values */;\n    }\n\n    for (int i = 0; i < K; ++i)\n    {\n        float x = a+float(i)*dx;\n        float s = 0.;\n        vec2 B = vec2(x, s), E = vec2(x, FDS[i].x - s);\n        \n        vec2 offs = vec2(0.1, 0.);\n        \n        /* Real part */\n        color = mix(color, vec3(0., 0, 1.), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n        color = mix(color, vec3(0., 0, 1), SMAA(segmentSDF_L2(NDC, B, E)));\n        /* Real part */\n        \n            offs = vec2(0.1, 0.1);\n        E = vec2(x, FDS[i].y - s);\n        \n        /* Imaginary part */\n        color = mix(color, vec3(0.1, 0.5, 1), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n        color = mix(color, vec3(0.1, 0.5, 1), SMAA(segmentSDF_L2(NDC, B, E)));\n        /* Imaginary part */\n    }\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\nvoid DFT(\n    inout vec2 FDS[N+1],\n    in float TDS[N])\n{\n    float N_ = float(N),\n          dA = (2.*PI)/(N_-1.),\n          inv = 1./N_;\n    \n    for (float k = 0.; k < N_; k += 1.)\n    {\n        FDS[int(k)] = vec2(0);\n        \n        for (float n = 0.; n < N_; n += 1.)\n        {\n            FDS[int(k)].x += TDS[int(n)]*cos(k*dA*n);\n            FDS[int(k)].y -= TDS[int(n)]*sin(k*dA*n);\n        }\n        \n        FDS[int(k)].x *= inv; FDS[int(k)].y *= inv;\n    }\n}\n\nvoid IDFT(\n    inout float RTDS[N],\n    in vec2 FDS[N+1])\n{\n    float N_ = float(N),\n          dA = (2.*PI)/(N_-1.),\n          inv = 1./N_;\n    \n    for (float n = 0.; n < N_; n += 1.)\n    {\n        RTDS[int(n)] = 0.;\n        \n        for (float k = 0.; k < N_; k += 1.)\n        {\n            RTDS[int(n)] += FDS[int(k)].x*cos(k*dA*n) + FDS[int(k)].y*sin(k*dA*n);\n        }\n        \n        //RTDS[int(n)] /= inv;\n    }\n}\n/**/","name":"Common","description":"","type":"common"}]}