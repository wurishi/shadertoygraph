{"ver":"0.1","info":{"id":"l3jfRy","date":"1729630065","viewed":47,"name":"Space filling curve mapping","username":"timeopochin","description":"Mapping 3D to 2D using space filling curves","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"ivec2 rotate(ivec2 point, const int rx, const int ry, const int n) {\n\tif (ry != 0) {\n\t\treturn point;\n\t}\n\tif (rx == 1) {\n\t\tpoint.x = n - 1 - point.x;\n\t\tpoint.y = n - 1 - point.y;\n\t}\n\treturn point.yx;\n}\n\nivec2 indexToPoint(const int index, const int order) {\n\tint n = int(pow(2., float(order)));\n\tivec2 point = ivec2(0, 0);\n\tint rx = 0;\n\tint ry = 0;\n\tint s = 1;\n\tint t = index;\n\twhile (s < n) {\n\t\trx = 1 & (t / 2);\n\t\try = 1 & (t ^ rx);\n\t\tpoint = rotate(point, rx, ry, s);\n\t\tpoint.x += s * rx;\n\t\tpoint.y += s * ry;\n\t\tt /= 4;\n\t\ts *= 2;\n\t}\n\treturn point;\n}\n\nint pointToIndex(ivec2 point, int order) {\n\tint n = int(pow(2., float(order)));\n\tint rx = 0;\n\tint ry = 0;\n\tint index = 0;\n\tfor (int s = n / 2; s > 0; s /= 2) {\n\t\trx = (point.x & s) > 0 ? 1 : 0;\n\t\try = (point.y & s) > 0 ? 1 : 0;\n\t\tindex += s * s * ((3 * rx) ^ ry);\n\t\trotate(point, rx, ry, n);\n\t}\n\treturn index;\n}\n\nint transformCurve(const int index, const int bits, const int lookupTable[96]) {\n\tint val = 0;\n\tint transform = 0;\n\tfor (int i = 3 * (bits - 1); i >= 0; i -= 3) {\n\t\ttransform = lookupTable[transform | ((index >> i) & 7)];\n\t\tval = (val << 3) | (transform & 7);\n\t\ttransform &= ~7;\n\t}\n\treturn val;\n}\n\nint compact1By2(int x) {\n\tx &= 0x09249249;\n\tx = (x ^ (x >> 2)) & 0x030c30c3;\n\tx = (x ^ (x >> 4)) & 0x0300f00f;\n\tx = (x ^ (x >> 8)) & 0xff0000ff;\n\tx = (x ^ (x >> 16)) & 0x000003ff;\n\treturn x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tconst int order = 4;\n\tconst int order3d = order * 2;\n\tconst int order2d = order * 3;\n\n\tconst int side = int(pow(2., float(order3d)));\n\tconst int hilbertToMortonTable[96] = int[](\n\t\t48, 33, 35, 26, 30, 79, 77, 44,\n\t\t78, 68, 64, 50, 51, 25, 29, 63,\n\t\t27, 87, 86, 74, 72, 52, 53, 89,\n\t\t83, 18, 16,  1,  5, 60, 62, 15,\n\t\t 0, 52, 53, 57, 59, 87, 86, 66,\n\t\t61, 95, 91, 81, 80,  2,  6, 76,\n\t\t32,  2,  6, 12, 13, 95, 91, 17,\n\t\t93, 41, 40, 36, 38, 10, 11, 31,\n\t\t14, 79, 77, 92, 88, 33, 35, 82,\n\t\t70, 10, 11, 23, 21, 41, 40,  4,\n\t\t19, 25, 29, 47, 46, 68, 64, 34,\n\t\t45, 60, 62, 71, 67, 18, 16, 49\n\t);\n\n\tconst int side2d = int(pow(2., float(order2d)));\n\tivec2 pCoord = ivec2((fragCoord.xy / iResolution.xy) * float(side2d));\n\n\tint index = pointToIndex(pCoord, order2d);\n\tint mortonIndex = transformCurve(index, order3d, hilbertToMortonTable);\n\tvec3 pos = vec3(\n\t\tcompact1By2(mortonIndex >> 0),\n\t\tcompact1By2(mortonIndex >> 1),\n\t\tcompact1By2(mortonIndex >> 2)\n\t);\n\tpos -= vec3(side, side, side) / 2.;\n\n\tpos = pos / float(side) * 256.;\n\n\tvec4 red = vec4(sin(iTime / 1.4) * 64., sin(iTime / 2.3) * 64., sin(iTime / 2.8) * 64., sin(iTime / 4.8) * 64. + 128.);\n\tvec4 gre = vec4(sin(iTime / 2.1) * 64., sin(iTime / 1.2) * 64., sin(iTime / 3.0) * 64., sin(iTime / 4.6) * 64. + 128.);\n\tvec4 blu = vec4(sin(iTime / 1.9) * 64., sin(iTime / 1.8) * 64., sin(iTime / 1.3) * 64., sin(iTime / 4.2) * 64. + 128.);\n\n\tfloat distR = distance(pos, red.xyz);\n\tfloat distG = distance(pos, gre.xyz);\n\tfloat distB = distance(pos, blu.xyz);\n\tfloat r = distR < red.w ? 1. - (distR / red.w) : 0.;\n\tfloat g = distG < gre.w ? 1. - (distG / gre.w) : 0.;\n\tfloat b = distB < blu.w ? 1. - (distB / blu.w) : 0.;\n\tfragColor = vec4(r, g, b, 1);\n}","name":"Image","description":"","type":"image"}]}