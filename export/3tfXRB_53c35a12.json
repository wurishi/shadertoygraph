{"ver":"0.1","info":{"id":"3tfXRB","date":"1563499151","viewed":174,"name":"Road To Nowhere","username":"badgerint","description":"This originally started out as an experiment with buffers to keep a persistent state of variables between frames. This isn't the way to do it properly I know, but I'm enjoying the learning process regardless. Onwards and upwards.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["state","buffer","persistent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 backdrop(vec2 uv) {\n    vec4 bScenery = texelFetch(iChannel0, ivec2(iResolution.x/2., 0), 0);\n    \n    float sun = 1.-smoothstep(0.06, 0.1, distance(vec2(bScenery.x - 0.5, 0.3), uv));\n    \n    float h1Shape = abs(uv.y + cos((-bScenery.x + .2) * 8. + uv.x * 3.5)) * 0.25;\n    float h2Shape = abs(uv.y + cos(-bScenery.x * 30. + uv.x * 4.)) * 0.15;\n    \n    float hill1 = 1.-step(h1Shape, distance(-0.06, uv.y));\n    float hill2 = 1.-step(h2Shape, distance(-0.053, uv.y));\n\t\n    vec3 hCol = hsv2rgb(vec3(0.09, 0.9, 0.2));\n    vec3 sCol = hsv2rgb(vec3(0.6, 0.8, 0.4)) + uv.y -.1 * 0.1;\n    \n    vec4 bg = vec4(vec3(sCol), 0.1);\n    vec4 s = vec4(vec3(sun, sun, 0.), 1.0);\n    vec4 h1 = vec4(hCol + uv.y - .1, 0.1);\n    vec4 h2 = vec4(hCol + 0.08 + uv.y - .1, 0.1);\n\n    if(sun == 0. && hill1 == 0. && hill2 == 0.) {\n        return bg;\n    } else if(sun > 0. && hill1 == 0. && hill2 == 0.) {\n        return bg + s;\n    } else if (sun > 0. && hill1 == 1. && hill2 == 0.) {\n        return h1;\n    }else if (sun == 0. && hill1 == 1. && hill2 == 0.) {\n        return h1;\n    } else if (sun == 0. && hill1 == 0. && hill2 == 1.) {\n        return h2;\n    } else if (hill1 == 1. && hill2 == 1.) {\n        return h2;\n    }\n}\n\n\nvec3 getCol(vec2 uv, float perspective) {    \n    vec4 bTrack\t  = texelFetch(iChannel0, ivec2(0, 0), 0);\n   \tfloat timer = mod(iTime, 400.);\n    \n    float frequency = 0.05;\n    float amplitude = 0.7;\n    float speed = 4.;\n    \n    float trackMiddle = 0.;\n    float roadWidth = 0.05 + perspective * 1.2;\n    float kerbWidth = roadWidth * 0.1;\n    \n    trackMiddle = 0. + bTrack.x * pow((1. - perspective), 3.);\n    \n    float screenLeft = -1.;\n    float screenRight = 1.;\n    \n    float leftGrass \t= trackMiddle - (roadWidth / 2.) - kerbWidth;\n    float rightGrass \t= trackMiddle + (roadWidth / 2.) + kerbWidth; \n    float roadLeft\t\t= trackMiddle - (roadWidth / 2.);\n    float roadRight\t\t= trackMiddle + (roadWidth / 2.);\n    \n    vec3 grassCol = vec3(0., 1., 0.);\n    vec3 kerbCol \t= vec3(1., 0., 0.);\n    vec3 roadCol\t= vec3(0.2);\n    \n    float doShade = 0.;\n    float shadeCol = 0.05;\n    if(uv.y < -0.05) {\n        doShade = sin(30. * pow(1.2 - perspective * 0.8, 3.) + timer * 30.);\n    } else {\n\t\treturn backdrop(uv).rgb;\n    }\n    \n    if(uv.x < leftGrass) {\n    \tgrassCol.g -= 1.-sin(perspective);\n        if(doShade > 0.) {\n        \treturn grassCol - shadeCol;\n        } else {\n            return grassCol;\n        }\n    }\n    if(uv.x > rightGrass) {\n    \tgrassCol.g -= 1.-sin(perspective);\n        if(doShade > 0.) {\n        \treturn grassCol - shadeCol;\n        } else {\n            return grassCol;\n        }\n    }\n    if(uv.x > leftGrass && uv.x < leftGrass + kerbWidth) {\n    \tkerbCol.r -= 1.-sin(perspective);\n        if(doShade < 0.) {\n            vec3 retCol = vec3(1.);\n    \t\tretCol -= 0.6-sin(perspective);\n        \treturn retCol;\n        } else {\n            return kerbCol;\n        }\n    }\n    if(uv.x > rightGrass - kerbWidth && uv.x < rightGrass) {\n    \tkerbCol.r -= 1.-sin(perspective);\n        if(doShade < 0.) {\n            vec3 retCol = vec3(1.);\n    \t\tretCol -= 0.6-sin(perspective);\n        \treturn retCol;\n        } else {\n            return kerbCol;\n        }\n    }\n    if(uv.x > roadLeft && uv.x < roadRight && uv.y < 0.) {\n    \troadCol -= vec3(0.15-sin(perspective * 0.4));\n        if(doShade > 0.) {\n        \treturn roadCol - shadeCol;\n        } else {\n            return roadCol;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy -0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float perspective = -uv.y * 400. / 200.;\n    \n    fragColor = vec4(getCol(uv, perspective),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //bTrack   (x = trackCurve, y = trackCurveTarget, z = trackCurveDiff, a = trackSection)\n    //bScenery (x = sceneryPos, y = scenerySpeed)\n\n    vec4 bTrack = vec4(0.);\n    vec4 bScenery = vec4(0.);\n    vec4 bOut = vec4(0.);\n    float trackBend = 0.;\n    \n    float trackCurve, trackCurveTarget, trackCurveDiff, trackSection,\n          sceneryPos, scenerySpeed;\n\n    if(iFrame == 0) {\n        trackCurve = 0.;\n        trackCurveTarget = 0.;\n        trackCurveDiff = 0.;\n        trackSection = 0.;\n        sceneryPos = 0.;\n        scenerySpeed = 0.;\n    } else {\n    \tbTrack = texelFetch(iChannel0, ivec2(0, 0), 0);\n        trackCurve = bTrack.x;\n        trackCurveTarget = bTrack.y;\n        trackCurveDiff = bTrack.z;\n        trackSection = bTrack.a;\n        bScenery = texelFetch(iChannel0, ivec2(iResolution.x/2., 0), 0);\n        sceneryPos = bScenery.x;\n        scenerySpeed = bScenery.y;\n    }\n        \n    float frequency = 0.05;\n    float amplitude = 0.7;\n    float speed = 20.;\n\n    trackCurveTarget = getTrackPos(int(mod(trackSection, 10.)));\n    trackSection += 0.004;\n\n    trackCurveDiff = (trackCurveTarget - trackCurve) * 0.1; \n    \n    trackCurve += trackCurveDiff * 0.1;\n    \n    bTrack.r = trackCurve;\n    bTrack.g = trackCurveTarget;\n    bTrack.b = trackCurveDiff;\n    bTrack.a = trackSection;\n    \n    scenerySpeed = clamp(0. + trackCurve, -0.5, 0.5);\n    sceneryPos -= scenerySpeed * 0.001;\n    \n    bScenery.r = sceneryPos;\n    bScenery.g = scenerySpeed;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if(step(0.1, distance(0., uv.x)) == 0.) {\n        fragColor = bTrack;\n    } else {\n    \tfragColor = bScenery;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float track[10] = float[10](\n\t0.0, -0.3, -1., 0., 1., .3, 1., 0., -1., 0.\n);\n\nfloat getTrackPos(int pos)\n{    \n    return track[pos];\n}","name":"Common","description":"","type":"common"}]}