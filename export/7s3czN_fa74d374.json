{"ver":"0.1","info":{"id":"7s3czN","date":"1655860648","viewed":77,"name":"Second Star Saturn Salad","username":"RedWool","description":"Pinnacle of bad service\n\nI accidentally destroyed the first one, my bad","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader practice for fractals\nI learned how to make\nbad barnsley fern\nmandelbrot set\nkoch snowflake\n\nI also made some variations for the mandelbrot and koch\n*/\n\n\nfloat a4 = 1.57078, a3 = 2.09439, l = .333333;\n\nvec2 comSq(vec2 c)\n{\n    return vec2(c.x*c.x - c.y*c.y, 2.*c.x*c.y);\n}\n\nfloat box (vec2 uv, vec2 c, vec2 xy)\n{\n    vec2 d = abs(c - uv);\n    return step(d.x,xy.x)*step(d.y,xy.y);\n}\n\n//Credit to https://www.shadertoy.com/view/MsS3Wc for hsv to rgb\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1.);\n\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nfloat circle (vec2 uv, vec2 c, float r)\n{\n    return step(length(uv - c), r);\n}\n\nfloat line (vec2 uv, float d)\n{\n    return smoothstep(uv.y-d, uv.y, 0.)-smoothstep(uv.y, uv.y+d, 0.);\n}\n\nmat2 rotate (float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid evalDist (vec2 uv, vec2 p, float ang, out vec2 c, out float low, out float a)\n{\n    float l = distance(uv, p);\n    if (l < low)\n    {\n        low = l;\n        c = p;\n        a = ang;\n    }\n}\n\nfloat mandelBrot(vec2 uv, vec2 z, vec2 c)\n{\n    float pct = 1.;\n    for(float i = 1.; i < 50.; i++)\n    {\n        z = comSq(z) + c;\n        if (length(z)>2.) {pct = 1./i; break;}\n    }\n    return pct;\n    //pct*=.5;\n}\n\nvoid kcIter(vec2 uv, float t, out float s, out float a, out vec2 c)\n{\n    float low = 5., at;\n    vec2 p = c;\n    mat2 m = rotate(a)*s;\n        \n    evalDist(uv, p+m*vec2(l,0), a, c, low, at);\n    evalDist(uv, p+m*vec2(-l,0), a, c, low, at);\n    evalDist(uv, p+m*vec2(l*.25,.144337*t), a+a3*.5*t, c, low, at);\n    evalDist(uv, p+m*vec2(l*-.25,.144337*t), a+a3*-.5*t, c, low, at);\n        \n    a = at;\n    s*=l;\n}\n\nfloat kochCurve(vec2 uv)\n{\n    vec2 c = vec2(0),p;\n    float low = 5., a = 0.;\n    \n    //First iteration: triangle\n    for(float i = 0.; i < 3.; i++)\n    {\n        p = vec2(sin(a3*i),cos(a3*i))*.28867;\n        \n        evalDist(uv, p, a3*i, c, low, a);\n    }\n    \n    float s = 1., t = (sin(iTime*2.4)+1.)*2.5;\n    for(int i = 0; i < int(t); i++)\n    {\n        kcIter(uv, 1., s, a, c);\n    }\n    \n    kcIter(uv, fract(t), s, a, c);\n    \n    return line((uv-c)*rotate(a),.01*(3.-t*.5));\n}\n\nvoid ipkcIter(vec2 uv, float t, out float s, out float a, out vec2 c)\n{\n    float low = 5., at;\n    vec2 p = c;\n    mat2 m = rotate(a)*s;\n        \n    evalDist(uv, p+m*vec2(l,l*t), a, c, low, at);\n    evalDist(uv, p+m*vec2(.5,l*.5*t), a+a4*t, c, low, at);\n    evalDist(uv, p+m*vec2(-l,l*t), a, c, low, at);\n    evalDist(uv, p+m*vec2(-.5,l*.5*t), a-a4*t, c, low, at);\n    evalDist(uv, p+m*vec2(l*.25,.18899*t), a+a3*-.5*t, c, low, at);\n    evalDist(uv, p+m*vec2(l*-.25,.18899*t), a+a3*.5*t, c, low, at);\n        \n    a = at;\n    s*=l;\n}\n\nfloat ipKochCurve(vec2 uv)\n{\n    vec2 c = vec2(0), p;\n    float a, low = 5., s = 1.;\n    \n    for (float i = 0.; i < 4.; i++)\n    {\n        p = vec2(sin(a4*i),cos(a4*i))*.5;\n        \n        evalDist(uv, p, a4*i, c, low, a);\n    }\n    \n    float t = -sin(iTime*1.2)*2.+2.+abs(sin(iTime*4.8));\n    \n    for(int i = 0; i < int(t); i++)\n    {\n        ipkcIter(uv, 1., s, a, c);\n    }\n    \n    ipkcIter(uv, fract(t), s, a, c);\n    \n    return line((uv-c)*rotate(a),.04*(5.-t));\n}\n\nfloat hash (float v)\n{\n    return fract(sin(v)*82.301);\n}\nfloat hash (vec2 v)\n{\n    return hash(dot(v, vec2(12.3, 23.7)));\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv), f = fract(uv), u = f*(f*(3.-2.*f));\n    \n    float \n    a = hash(i),\n    b = hash(i+vec2(1,0)),\n    c = hash(i+vec2(0,1)),\n    d = hash(i+vec2(1));\n    \n    return mix(a, b, u.x) + \n    (c - a) * u.y * (1.-u.x) +\n    (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 uv)\n{\n    float v, a = .5, f = 1., d = .5, r = 2.;\n    \n    for(int i = 0; i < 2; i++)\n    {\n        v += a*noise(uv*f+iTime*.2);\n        \n        a *= d;\n        f *= r;\n    }\n    \n    return v;\n}\n\nfloat orbit(in vec2 uv, float t, out vec2 l, out float s){\n    l = vec2(30.*sin(t), 10.*cos(t)-sin(t)*12.);\n    s = -cos(t)*2.4+sin(t)*1.2+3.2;\n    return circle(uv, l, s);\n}\n\nvec3 bg(vec2 uv)\n{\n    float pct = fbm(vec2(fbm(uv*.4+iTime*.5)+uv*.2));\n    return mix(pct * vec3(.3,.8,.7)+ (1.-pct)* vec3(.6,.3,1), vec3(0), fbm(uv*.2)-.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y, orbGlow = vec2(0.5);\n    uv -= vec2(.5,.7);\n    uv*=30.;\n    \n    float pct = 0., inter = 0., planet = 0., ind = -1., s = 0., tSave = 1.;\n    \n    //6 planets\n    for(float i = 0.; i < 6.; i++)\n    {\n        //Time 1, sin 6\n        float c = (.2*iTime+sin(1.2*iTime)*.16)+i*(1.045);\n        if (orbit(uv, c, orbGlow, s)>0.5){\n            pct = 1.;\n            ind = i;\n            tSave = c;\n            break;\n        }\n    }\n    \n    //Planet and crossout\n    pct *= (1.-length(orbGlow - uv)*.5/s);\n    planet = circle(uv, vec2(0), 8.);\n    \n    vec2 lc = vec2(15,-14.6) - uv;\n    float l = 1.;\n    for (float i = 0.; i < 3.; i++)\n    {\n        inter += sin(atan(lc.x/lc.y)*2.*(i+5.)+iTime*(5.-i*2.23))*l;\n        l *= .7;\n    }\n    inter = circle(lc, vec2(0), 5.2+inter*.2);\n   \n    //Orbiter color\n    vec3 col = hsv2rgb(vec3(ind*1.1,1,s*.1+.8))*pct;\n    \n    //Is planet and no orbiter in front\n    if (planet > .5 && cos(tSave) > 0.)\n    {\n        //planet gradient\n        planet *= \n        (1.-length(uv)*.1) *\n        fbm(vec2(fbm(uv*.3),uv.y*.4+iTime*.1));\n        planet += .6;//planet+.3)*planet;\n        col = vec3(1,.35,1) * (planet);//+ (1.-planet)* vec3(.95,.85,.75);//fbm(vec2(fbm(uv),uv.y));\n    }\n    else if (ind < -.5) //Background\n    {\n        col = bg(uv);\n    }\n    else if (inter > .5) //In the cross section\n    {\n        lc = uv-orbGlow;\n        col -= vec3(.4)*pct;\n        if (ind < .5) //Barnsley Fern\n        {\n            //lc *= .;\n            lc.y += 5.5;\n            lc.x *= 1./sin(iTime*2.5);\n            float o = .5, p = 2.;\n            for (int i = 0; i < 3; i++)\n            {\n                lc.y *= .4*lc.y;\n                inter = lc.y*.01*lc.y;\n            \n                vec2 c = vec2(inter, floor(lc.y*.5)*2.+.5+step(inter, lc.x)*1.);\n                s = 3.-(lc.y*.1);\n            \n                pct = box(lc, c, vec2(s,(sin(iTime*5.+lc.x*5.+c.y)*.1+.35)));\n                inter = abs(inter-lc.x+lc.y*.1)*.2;\n                \n                col = pct * vec3(0,.5+inter,0) + (1.-pct) * col;\n                \n                lc = c - lc;\n                lc *= rotate(1.57);\n            }\n            \n            col = pct * vec3(0,.5+inter,0) + (1.-pct) * col;\n        }\n        else if (ind < 1.5) //Koch Curve but with a twist\n        {\n            lc *= .3;\n            pct = ipKochCurve(lc);\n            \n            col = pct * bg(uv) + (1.-pct) * col;\n        }\n        else if (ind < 2.5) //Mandelbrot Set\n        {\n            //lc.y += 1.;\n            lc *= .5;\n            lc.x += sin(iTime*1.2+lc.x*.2);\n            vec2 z = vec2(0);\n            \n            pct = mandelBrot(lc, vec2(0), lc)*.5;\n            \n            col = pct * vec3(0) + (1.-pct) * col;\n        }\n        else if (ind < 3.5) //My custom fractal 1\n        {\n            for(float i = 0.; i < 8.; i++)\n            {\n                lc = abs(lc) - 1.2;\n                lc.y += .3;\n                lc *= rotate(iTime*(i*.5+1.));\n                lc *= 1.5-cos(iTime*1.2);\n            }\n            pct = circle(lc, vec2(0), 5.);\n            col = pct * vec3(1,.5+length(lc*.1),0) + (1.-pct) * col;\n        }\n        else if (ind < 4.5) //Koch Snowflake\n        {\n            lc *= (sin(iTime*2.4)*.03+.15) * rotate(sin(iTime*.6)*5.);\n            pct = kochCurve(lc);\n            col = pct * hsv2rgb(vec3(length(lc)*2.+iTime*.6, 1, 1)) + (1.-pct) * col;\n            \n        }\n        else if (ind < 5.5) //My custom fractal, similar to mandel brot\n        {\n            vec2 z = vec2(0);\n            lc*=.3;\n            \n            pct = 1.;\n            for (float i = 1.; i < 10.; i++)\n            {\n                z += rotate(length(z)*sin(length(z*5.)+sin(lc.y+iTime*2.4)*5.))*lc + vec2(z.y*z.x-2.*z.x,z.y*z.x-2.*z.y);\n                if (length(z) > 2.)\n                {\n                    pct = 1./i;\n                    break;\n                }\n            }\n            pct *= .9;\n            col = pct * vec3(.4,.2,1) + (1.-pct) * col;\n        }\n    }\n\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}