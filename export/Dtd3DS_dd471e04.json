{"ver":"0.1","info":{"id":"Dtd3DS","date":"1683231401","viewed":88,"name":"Hexagon with triangle coordinate","username":"wxy_equation","description":"A way to create hexagonal grid with triangle coordinate, WITHOUT breaking trifold symmetry.\n\nIs there a better way to do this?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3x2 base = mat3x2(\n    vec2(1.  ,  0.         ),\n    vec2(-0.5,  sqrt(3.)/2.),\n    vec2(-0.5, -sqrt(3.)/2.));\n\nfloat sum(vec3 v)\n{\n    return v.x+v.y+v.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centralized-Normalized pixel coordinates\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // The triangular Coordinate\n    vec3 tri = uv*base*3.;\n    \n    //Triangle grid separation\n    vec3 itri = floor(tri),\n         ftri = tri-itri;\n    \n    //parity and phase\n    float p = sum(itri);      \n    float i = mod(p*(itri.y-itri.z), 3.);\n    \n    //hexagonal grid distance\n    float hex = abs( 1.+p+ftri[int(i)] );\n \n    \n    //isolines\n    float v = 3.*hex+iTime/2.;\n    v = abs(fract(v+.5)-.5)/fwidth(v);\n    fragColor = vec4(smoothstep(1.5, 0., v));\n    \n    fragColor+=vec4(smoothstep(1./40., 0., hex));\n}","name":"Image","description":"","type":"image"}]}