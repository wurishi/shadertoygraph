{"ver":"0.1","info":{"id":"DlGcW1","date":"1700151677","viewed":37,"name":"Drop blending 2","username":"oleg304","description":"drop, blending, blend, shape","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blending","drop","shape","waving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// HLSL -> GLSL https://anteru.net/blog/2016/mapping-between-HLSL-and-GLSL/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define lerp     mix\n#define atan2    atan\n#define frac     fract\n#define fmod     mod\n#define float2x2 mat2     \n#define mul(a, b) a*b \n#define texSampl 1.\n#define Texture2DSample(iChannel0, texSampl, uv) texture(iChannel0, uv)\n#define ddx dFdx\n#define ddy dFdy\n\n//--------------------------------------------------------------------------\nfloat2 rotate(float2 v, float alpha){\n    float cn = cos(alpha), sn = sin(alpha);\t\n\treturn float2(v.x*cn-v.y*sn,v.x*sn+v.y*cn);\n}\n// bend https://www.shadertoy.com/view/dtVczm\nfloat2 bend(float2 p, float a){\n    if(abs(a)<.001) return p;  // if perfectly straight    \n    float ra = .5/a;p.x -= ra;    \n    float2 sc = float2(sin(a),cos(a));\n    float2 q = p - 2.*sc*max(0.,dot(sc,p));    \n    float s = sign(a);\n    return float2( (p.y>0.) ? ra-s*length(q)        : sign(-s*p.x)*(q.x+ra),\n                 (p.y>0.) ? ra*atan2(s*p.y,-s*p.x) : (s*p.x<0.)?p.y:1.-p.y );\n}\n\n// shape and waving https://www.shadertoy.com/view/wstBDN\n\nfloat Drop(float2 uv, float2 center, float2 size, float smoothness, float shape){\n    float2 uvDrop = (uv - center) / (size * float2(1., 0.5));\n    float k = max(min(-shape * (uvDrop.y - 0.5), 1.), 0.); // k = max(min(-y, 1), 0) 변형\n    float s = pow(k,2.) * (2.5 - 2. * k);                     // s = k^2(3 - 2k) 변형\n    float dropBase = abs(uvDrop.x) + s, drop = smoothstep(0.5, 0.5 - smoothness, dropBase); \n    float dropClip = smoothstep(1.0, 0.8, abs(uvDrop.y + 0.4));    \n    drop *= dropClip;    \n    float dropCircle = smoothstep(0.5, 0.5 - smoothness, length(uvDrop - float2(0., 0.5)));\n    dropCircle *= 1. - dropClip; drop += dropCircle;    \n    drop = smoothstep(0., 1., drop);    \n    return drop;\n}\n\nfloat2 UvWave(float2 uv, float a, float b, float c, float s){\n    float x = abs(uv.x) * a, y = abs(uv.y) * b, k = sin(x * y + s); \n    float kkc = abs(pow(k,2.) * c), w1 = 1. + kkc * a, w2 = 1. + kkc * b;\n    return float2(uv.x * w1, uv.y / w2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    float2 uv0 = (fragCoord/iResolution.xy - 0.5) * float2(iResolution.x/iResolution.y, 1.0) + 0.5; // Square Area  0.0 ~ 1.0\n    float2 p = uv0 * 2.0 - 1.0;  // Square Area -1.0 ~ 1.0\n    // init drop transform\n    float angle = sin(iTime);\n    p = rotate(p,angle);\n    float height = iTime * 3.0;\n    float shape = 0.5+sin(iTime*2.)/6.;\n    // blend uv\n    p = bend(p+vec2(.0,.1),angle)/2.; \n    //  location, dif width, dif height, move down, size\n    float2 uvDrop = UvWave(p - float2(0., 0.6), .3, .3, .2, height);\n    float drop = Drop(-uvDrop, float2(.0, .35), float2(0.5, 1.), 0.6, shape);\n    \n    fragColor = vec4(drop)*vec4(.1,.24,1.,2.);\n}","name":"Image","description":"","type":"image"}]}