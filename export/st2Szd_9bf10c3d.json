{"ver":"0.1","info":{"id":"st2Szd","date":"1628711043","viewed":472,"name":"Infinite staircase","username":"TambakoJaguar","description":"I was inspired my the staircase of my apartment block, just mine only has three floors ;) I used repeats (modulo) and symmetries to improve render and compile speed.\nUse the mouse to look around.","likes":29,"published":1,"flags":48,"usePreview":0,"tags":["3d","block","infinite","walking","house","staircase","stairs","movement","doors","climbing","lamps","building","floors","apartment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Infinite staircase\" by Emmanuel Keller aka Tambako - August 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.  \nContact: tamby@tambako.ch\n*/\n\n/*\n    ToDo\n    \n    * Sometimes lamps are blinking or totally off\n    * Sometimes doors have other colors\n    * Add objects\n      * Ceiling lamps\n      * Door handles\n      * Handrails\n    * ceiling_color white\n    * Use only one function for stairs (then rotate 180Â° and move on x and y)\n    * Directional light from window\n    * Dirt on the walls\n    * Fix vertical camera movement\n    * Fix bumps\n      * Only on normal\n      * Vertical mod\n    * Some doors open     \n    * Window frame\n    * Floor number\n    * Fix shadows\n    * Blinking light shouldn't be seen on other floors\n    * Blood 13th floor\n      * Also on floor 113, 213, etc\n      * Why white border?\n    * Dirt, open doors and colored door get worse with height\n    * Some doors are moving\n    * Movement with sin() to simulate walking\n    * Add simple cityscape\n    * Getting night after some time\n      * Windows getting lighted on when it's getting dark\n      * Cycling day - night\n    * Some lights have strange colors red, green, purple or blue\n    * Doorbell buttons\n    - Improve light near the doors\n    - Improve handrail?\n    - Boxes and other objects sometimes?    \n    - Optimize speed ?\n    - Add comments\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n//#define shadow\n#define bumps\n#define dirt\n#define opendoors\n#define floornumber\n#define blood\n#define cityscape\n#define gettingnight\n#define doorbell\n//#define testmode\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Lighting options\nconst float lamps_int = 0.78;\nconst float lamps_int_var = 0.31;\nconst vec3 lamps_color = vec3(1., 0.95, 0.9);\nconst float lamps_color_var = 0.26;\nconst float lamps_attenuation = 0.027;\nconst float lamps_offprob = 0.09;\nconst float lamps_blinkprob = 0.08;\nconst float lamps_blinkspeed = 15.;\nconst float daylight_intensity = 0.55;\nconst vec3 daylight_color = vec3(0.66, 0.82, 1.0);\nconst vec3 daylight_direction = normalize(vec3(1.0, 0., 0.25));\n\n// Ambient light options\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.33;\n\n// Specular options\nconst float specint_walls = 0.03;\nconst float specshin_walls = 10.;\nconst float specint_floors = 0.28;\nconst float specshin_floors = 70.;\nconst float specint_doors = 0.36;\nconst float specshin_doors = 37.;\n#ifdef blood\nconst float specint_blood = 0.95;\nconst float specshin_blood = 50.;\n#endif\n// Shadow options\nconst float shi = 0.4;\n\n// Tracing options\nconst float normdelta = 0.0003;\nconst float maxdist = 1000.;\n\n// Color options\nconst float gamma = 1.7;\nconst vec3 floors_color = vec3(0.85, 0.9, 0.95);\nconst vec3 walls_color = vec3(0.81, 0.795, 0.785);\nconst vec3 ceiling_color = vec3(0.83, 0.83, 0.84);\nconst vec3 stairs_color = vec3(0.75, 0.77, 0.79);\nconst vec3 doors_color = vec3(0.61, 0.46, 0.45);\nconst float coldoor_prob = 0.07;\nconst vec3 handles_color = vec3(0.75, 0.77, 0.79);\nconst vec3 handrail_color1 = vec3(0.4);\nconst vec3 handrail_color2 = vec3(0.73);\nconst vec3 apartment_color1 = vec3(0.65, 0.59, 0.52);\nconst vec3 apartment_color2 = vec3(0.54, 0.57, 0.61);\nconst vec3 lampso_color = vec3(1.02, 0.975, 0.98);\n#ifdef floornumber\nconst vec3 flnum_color1 = vec3(0.4, 0.5, 0.95);\nconst vec3 flnum_color2 = vec3(0.95);\n#endif\n#ifdef blood\nconst vec3 blood_color = vec3(0.5, 0.15, 0.05);\n#endif\n#ifdef cityscape\nconst vec3 city_color = vec3(0.65);\nconst vec3 street_color = vec3(0.75);\nconst float city_colvar = 0.2;\nconst float city_windark = 0.25;\nconst vec3 city_light_color = vec3(1., 0.95, 0.48);\n#endif\n#ifdef doorbell\nconst vec3 doorbell_color1 = vec3(0.75, 0.77, 0.79);\nconst vec3 doorbell_color2 = vec3(0.38, 0.37, 0.36);\nconst vec3 doorbell_color3 = vec3(0.2);\n#endif\n\n// Dirt options\nconst float dirt_intensity = 0.44;\nconst float dirt_transp = 0.8;\nconst float dirt_size1 = 0.11;\nconst float dirt_size2 = 2.8;\nconst float dirt_size3 = 11.2;\nconst float dirt_size4 = 1.2;\nconst vec3 dirt_color1 = vec3(0.22,0.35, 0.31);\nconst vec3 dirt_color2 = vec3(0.44, 0.34, 0.23);\nconst float dirt_contrast = 0.26;\n\n// Geometry options\nconst float staircase_width = 4.;\nconst float staircase_length = 8.;\nconst float floor_height = 3.2;\n\nconst float wall_thickness = 0.2;\nconst float floor_thickness = 0.25;\nconst float interfloor_thickness = 0.25;\n\nconst float floor_width = 3.;\nconst float interfloor_width = 2.;\n\nconst float window_posy = 0.9;\nconst float window_height = 1.25;\nconst float window_width = 1.5;\nconst float windowb_width = 0.15;\nconst float windowb_thickness = 0.12;\n\nconst float nb_stairs = 8.;\nconst float stairs_width = 1.83;\n\nconst float apartment_width = 3.5;\nconst float apartment_textscale = 9.;\n\nconst float door_width = 1.22;\nconst float door_height = 2.45;\nconst float door_depth = 0.19;\nconst float door_thickness = 0.03;\nconst float dooropen_prob = 0.09;\nconst float dooropen_minangle = 0.15;\nconst float dooropen_maxangle = 1.2;\n\nconst float handle_radius = 0.02;\nconst float handle_length1 = 0.045;\nconst float handle_length2 = 0.1;\nconst float keycyl_length = 0.012;\nconst vec4 handle_plate = vec4(0.044, 0.157, 0.007, 0.004);\nconst float handle_height = 0.51;\n\nconst vec4 doorbell_plate = vec4(0.075, 0.075, 0.007, 0.004);\nconst float doorbell_height = 0.53;\nconst float doorbell_rpos = 0.17;\nconst float doorbell_srad = 0.04;\nconst float doorbell_sdep = 0.007;\nconst vec4 doorbell_button = vec4(0.01, 0.033, 0.003, -0.025);\nconst vec4 doorbell_nplate = vec4(0.05, 0.015, 0.003, 0.001);\nconst float doorbell_nplate_ypos = 0.03;\n\nconst float lamp_height = 0.68;\n\nconst float texture_scale = 6.;\nconst float tile_size = 0.3;\n\nconst float lamp_radius = 0.23;\nconst float lamp_thickness = 0.2;\nconst float lamp_roundness = 0.03;\n\nconst float handrail_offset = 0.1;\nconst float handrail_spacing = 0.19;\nconst float handrail_height = 1.2;\nconst float handrail_thickness1 = 0.012;\nconst vec2 handrail_thickness2 = vec2(0.01, 0.04);\nconst float handrail_roundness = 0.015;\n\nconst float bump_depth = 0.00055;\nconst float bump_size = 150.;\n\n#ifdef floornumber\nconst float flnum_height = 0.3;\nconst float flnum_depth = 0.02;\nconst float flnum_ypos = 2.1;\n\nconst vec2 charSpacingFac = vec2(.53, .95);\n#endif\n\n#ifdef cityscape\nconst float city_stepsize = 40.;\nconst float city_minblsize = 18.;\nconst float city_maxblsize = 35.;\nconst float city_minblheight = 25.;\nconst float city_maxblheight = 450.;\nconst float city_blheightpow = 4.;\nconst vec2 city_winsize = vec2(2., 3.5);\n\n// Fog\nconst vec3 fogColor = vec3(0.62, 0.66, 0.71);\nconst float fogdens = 0.0028;\n#endif\n\n// Campera options\nvec3 campos;\nvec3 camdir = vec3(-1., 0., 0.);\n#ifdef testmode\nfloat fov = 0.5;\n#else\nfloat fov = 1.5;\n#endif\nfloat camheight = 1.7;\nfloat camperiod = 15.;\nfloat camacc = 0.0017;\nfloat camdiradv = 0.15;\nfloat starttime = -3.8;\nfloat walk_freq1 = 0.5*nb_stairs/0.3;\nfloat walk_freq2 = 2./0.2;\nfloat walk_ampl = 0.04;\nfloat walk_pow = 4.;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n\nvec3 door_colors[6];\nvec3 spec_lamps_colors[4];\n   \n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define WALLS_OBJ      1\n#define FLOORS_OBJ     2\n#define STAIRS_OBJ     3\n#define DOORS_OBJ      4\n#define LAMPS_OBJ      5\n#define HANDLES_OBJ    6\n#define HANDRAIL_OBJ   7\n#define FLOORNUMB_OBJ  8\n#define CITY_OBJ       9\n#define DOORBELL_OBJ   11\n\n#define pow(a,b) pow(abs(a),b)\n#define normalize(v) normalize(v+1e-5)\n\nint aai;\nint aaj;\n\nvoid init()\n{    \n    door_colors[0] = vec3(0.95, 0.93, 0.88);\n    door_colors[1] = vec3(0.4, 0.45, 1.);\n    door_colors[2] = vec3(0.6, 0.1, 0.4);\n    door_colors[3] = vec3(0.9, 0.65, 0.4);\n    door_colors[4] = vec3(0.2, 0.68, 0.35);\n    door_colors[5] = vec3(0.94, 0.95, 0.96);\n    \n    spec_lamps_colors[0] = vec3(1., 0.4, 0.35);\n    spec_lamps_colors[1] = vec3(0.25, 0.1, 1.2);\n    spec_lamps_colors[2] = vec3(0.2, 0.95, 0.15);\n    spec_lamps_colors[3] = vec3(0.85, 0.15, 1.0);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat sdCylinder(vec3 p, vec2 h, float t, float rr)\n{\n    h-= vec2(rr);\n    vec2 d = abs(vec2(length(p.xz*(1. + t*p.y)),p.y)) - h;\n    return -rr + min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n#ifdef blood\nfloat getBlood(vec3 pos)\n{\n    if (mod(pos.y, floor_height*100.)<floor_height*12. - 0.1 || mod(pos.y, floor_height*100.)>floor_height*12. + 0.1)\n        return 0.;\n\n    pos+= vec3(staircase_length*0.11, 0., staircase_width*0.15);\n    pos.x+= staircase_length/2. - floor_width/2. + 0.12*sin(pos.x*5. + pos.z*3. + 0.012*pos.y) +  0.04*sin(pos.x*25. + pos.z*15. + 0.012*pos.y) - 0.022*sin(-pos.x*45. + pos.z*25. + 0.012*pos.y) + 0.019*sin(pos.x*75.)*sin(pos.z*55.);\n    pos.z*= 0.6 + 0.4*pos.x;\n    \n    float bloodv = - pow(length(pos.xz), 2.) + 0.17;\n    \n    return bloodv;\n}\n#endif\n\nfloat floornr;\nfloat map_walls(vec3 pos, bool hasbumps)\n{\n   float walls = -abs(pos.x) + staircase_length/2.;\n   walls = min(walls, -abs(pos.z) + staircase_width/2.);\n   walls = max(walls, abs(pos.x) - staircase_length/2. - wall_thickness);\n   walls = max(walls, abs(pos.z) - staircase_width/2. - wall_thickness);\n   \n   float posy2 = mod(pos.y + floor_height/2., floor_height) - floor_height/2.;\n   \n   if (pos.y>-floor_height/2.)\n   {\n       walls = min(walls, sdRoundBox(vec3(pos.x - staircase_length/2., posy2 + floor_height/2. - window_posy - window_height/2., pos.z), vec3(windowb_thickness, window_height/2. + windowb_width/2., window_width/2. + windowb_width/2.), 0.005));   \n   \n       float window = abs(pos.z) - window_width*0.5;\n       window = max(window, -posy2 - floor_height*0.5 + window_posy);\n       window = max(window, posy2 + floor_height*0.5 - window_posy - window_height);\n       window = max(window, -pos.x);\n       walls = max(walls, -window);\n   }\n   \n   #ifdef bumps\n   if (hasbumps)\n   {\n       vec3 pos2 = pos;\n       pos2.y = mod(pos2.y, floor_height);\n       walls = walls - bump_depth*(noise(pos2*bump_size) - noise(pos2*bump_size*3.));\n   }\n   #endif   \n   \n   float door1 = pos.x + (staircase_length/2. - floor_width/2. - door_width/2.);\n   door1 = max(door1, -pos.x - (staircase_length/2. - floor_width/2. + door_width/2.));\n   \n   float door2 = -abs(pos.z) + (staircase_width/4. - door_width/2.);\n   door2 = max(door2, abs(pos.z) - (staircase_width/4. + door_width/2.));\n  \n   float door = min(door1, door2);\n   float posy3 = mod(pos.y, floor_height);\n   door = max(door, -posy3 + 0.01);\n   door = max(door,posy3 - door_height);\n   door = max(door, pos.x);\n   \n   walls = max(walls, -door);\n   \n   return walls;\n}\n\nfloat map_floors(vec3 pos)\n{\n   float posy2 = mod(pos.y + floor_height*0.5, floor_height) - floor_height*0.5;\n   float posy3 = mod(pos.y, floor_height);\n\n   float floor = posy2;\n   floor = max(floor, -posy2 - floor_thickness);\n   floor = max(floor, pos.x + staircase_length/2. - floor_width);\n   floor = max(floor, -pos.x - staircase_length/2. - apartment_width);\n   floor = max(floor, abs(pos.z) - staircase_width/2. -apartment_width);\n   \n   #ifdef blood\n   float bloodv = getBlood(pos);\n   bloodv = 15.*max(bloodv - 0.0075, 0.) + pow(smoothstep(0.008, 0.058, bloodv), 0.4);\n   floor-= 0.01*bloodv;\n   #endif\n   \n   float interfloor = posy3 - floor_height*0.5;\n   interfloor = max(interfloor, -posy3 + floor_height*0.5 - interfloor_thickness);\n   interfloor = max(interfloor, -pos.x + staircase_length/2. - interfloor_width);\n   interfloor = max(interfloor, pos.x - staircase_length/2. - 0.1);\n   interfloor = max(interfloor, abs(pos.z) - staircase_width/2. -0.1);\n   \n   return min(floor, interfloor);\n}\n\nfloat map_stairs(vec3 pos)\n{\n   float h = (0.5*floor_height)/(staircase_length - floor_width - interfloor_width)*(nb_stairs - 1.)/nb_stairs - 0.01;\n   float s = (staircase_length - floor_width - interfloor_width)/nb_stairs + 0.009;\n   float d = mod(staircase_length*0.5 - interfloor_width, s) + 0.001;\n   \n   vec3 pos2 = pos;\n    \n   if (pos.z>0.)\n   {\n       pos2.y = mod(pos.y - floor_height/2., floor_height) + floor_height/2.;\n    \n       pos2.xz = -pos2.xz;\n       pos2.y-= floor_height/2.;\n       pos2.x+= floor_width - interfloor_width;\n   }\n   else\n       pos2.y = mod(pos.y, floor_height);   \n   \n   pos2.y = mod(pos2.y + floor_height*0.4, floor_height) - floor_height*0.4;\n   pos2.y-= h*(staircase_length*0.5 - floor_width - 0.23);\n\n   float stairs = pos2.y - 2.*s*h - s*h*floor((pos2.x + d)/s);\n   stairs = max(stairs, -mod(pos2.x + d, s) + 0.5*s);\n   stairs = min(stairs, pos2.y - s*h - s*h*floor((pos2.x + d)/s));\n   \n   stairs = max(stairs, h*pos2.x*1.165 - pos2.y - floor_thickness + 0.173);\n   \n   // Trick to avoid that the further stairs gets \"holes\"\n   stairs = min(stairs, 0.07 + abs(pos.z));    \n   \n   stairs = max(stairs, pos2.x - staircase_length/2. + interfloor_width);\n   stairs = max(stairs, -pos2.x - staircase_length/2. + floor_width);\n   stairs = max(stairs, -pos2.z - staircase_width/2. - 0.1);\n   stairs = max(stairs, pos2.z + staircase_width/2. - stairs_width);\n   \n   return stairs;\n}\n\nfloat door_angle;\nfloat map_doors(vec3 pos)\n{\n   #ifdef opendoors\n   float doornr = floornr*4.;\n   if (pos.z>0.)\n      doornr+= 1.;\n   if (pos.x<-staircase_length/2. + 0.5)\n      doornr+= 2.;\n      \n   float dohash1 = hash(doornr*8543.45);\n   float dohash2 = hash(doornr*1462.562);\n   float dooropen_prob2 = dooropen_prob + floornr/450.;\n   float dooropen_probmove = min(floornr/250., dooropen_prob2*0.7);\n   \n   door_angle = dohash1<dooropen_prob2 && floornr>0.?(dohash1<dooropen_probmove?-dooropen_minangle - (sin((3.4)*iTime)*0.5 + 0.5)*dohash2*(dooropen_maxangle - dooropen_minangle):-dooropen_minangle - dohash2*(dooropen_maxangle - dooropen_minangle)):0.;\n   \n   pos.y = mod(pos.y, floor_height);\n   pos.z = abs(pos.z);\n   vec3 pos1 = pos + vec3(staircase_length/2. - floor_width/2., 0., -staircase_width/2. - door_depth - handle_plate.z - handle_plate.w);\n   vec3 pos2 = pos + vec3(staircase_length/2. + door_depth + handle_plate.z + handle_plate.w, 0., -staircase_width/4.);\n   pos1.xz = rotateVec(pos1.xz + vec2(door_width/2., 0.), door_angle) - vec2(door_width/2., 0.);\n   pos2.xz = rotateVec(pos2.xz + vec2(0., door_width/2.), door_angle) - vec2(0., door_width/2.);\n   float doors = sdRoundBox(pos1, vec3(door_width/2., door_height, door_thickness/2.), 0.005);\n   doors = min(doors, sdRoundBox(pos2, vec3(door_thickness/2., door_height, door_width/2.), 0.005));\n   #else\n   float doors = -abs(pos.z) + staircase_width/2. + door_depth;\n   doors = min(doors, pos.x + staircase_length/2. + door_depth);\n   doors = max(doors, pos.x);\n   #endif\n   \n   return doors;\n}\n\nfloat map_lamps(vec3 pos)\n{\n    pos.y = mod(pos.y, floor_height);\n    pos-= vec3(-staircase_length/2. + floor_width/2., floor_height - floor_thickness - lamp_thickness/2., 0.);\n    return sdCylinder(pos, vec2(lamp_radius, lamp_thickness/2.), 0., lamp_roundness);\n}\n\nfloat map_handles(vec3 pos)\n{\n    pos.y = mod(pos.y, floor_height);\n    vec3 pos2 = pos;\n    if (pos.x>-staircase_length/2. + 1.)\n    {\n        pos2.z = abs(pos2.z);\n        pos2-= vec3(-staircase_length/2. + floor_width/2. + door_width/2.45, door_height*handle_height, staircase_width/2. + door_depth - handle_length1);\n        pos2.xz = rotateVec(pos2.xz + vec2(floor_width/2. - door_width/2., 0.), door_angle) - vec2(floor_width/2. - door_width/2., 0.);\n    }\n    else\n    {\n        pos2.z = abs(pos2.z);\n        pos2+= vec3(staircase_length/2. + door_depth - handle_length1, -door_height*handle_height, -staircase_width/4. - door_width/2.45);\n        pos2.xz = pos2.zx;\n        pos2.z = -pos2.z;\n        pos2.xz = rotateVec(pos2.xz + vec2(staircase_width/4., 0.), door_angle) - vec2(staircase_width/4., 0.);\n    }\n    \n    float handle = sdCylinder(pos2.yxz - vec3(0., -handle_length2, -handle_length1), vec2(handle_radius, handle_length2), 0., 0.);\n    handle = min(handle, sdCylinder(pos2.xzy, vec2(handle_radius, handle_length1), 0., 0.));\n    handle = min(handle, length(pos2.yxz - vec3(0., -handle_length2 + handle_length2, -handle_length1)) - handle_radius);\n\n    handle = min(handle, sdRoundBox(pos2 - vec3(0., -0.43*handle_plate.y, handle_length1), handle_plate.xyz, handle_plate.w));\n    handle = min(handle, sdCylinder(pos2.xzy - vec3(0., 1.65*handle_plate.z - keycyl_length + handle_length1/2., -0.81*handle_plate.y), vec2(handle_radius, keycyl_length), 0., 0.));\n    \n    return handle;\n}\n\nfloat map_handrail(vec3 pos)\n{\n    float h = (0.5*floor_height)/(staircase_length - floor_width - interfloor_width)*(nb_stairs - 1.)/nb_stairs - 0.01;\n\n    vec3 pos2 = pos;\n    pos2.x-= 0.035;\n    \n    if (pos.z>0.)\n    {\n        pos2.y = mod(pos.y - floor_height/2., floor_height) + floor_height/2.;\n    \n        pos2.xz = -pos2.xz;\n        pos2.y-= floor_height/2.;\n    }\n    else\n        pos2.y = mod(pos.y, floor_height);\n    \n    pos2.y-= h*(pos2.x + staircase_width/2. - floor_width) + handrail_height + (pos.z>0.?0.8:0.3);    \n    \n    pos2.x = mod(pos2.x + handrail_spacing/2., handrail_spacing) - handrail_spacing/2.;\n    pos2+= vec3(0., 0., staircase_width/2. - stairs_width + handrail_offset);\n\n    float handrail = sdCylinder(pos2, vec2(handrail_thickness1, handrail_height/2.), 0., 0.);\n    \n    handrail = min(handrail, sdRoundBox(pos2 + vec3(0., -handrail_height/2., 0.), vec3(staircase_length/2., handrail_thickness2.x, handrail_thickness2.y), handrail_roundness)); \n    \n    // Trick to avoid that the further handrail gets \"holes\"\n    handrail = min(handrail, 0.07 + abs(pos.z));    \n    \n    handrail = max(handrail, pos.x - staircase_length/2. + interfloor_width);\n    handrail = max(handrail, -pos.x - staircase_length/2. + floor_width);\n    \n    return handrail;\n}\n\n#ifdef floornumber\nfloat map_floornumber(vec3 pos)\n{\n    float flnw = (floornr<9.?flnum_height/3.07:(floornr<99.?2.*flnum_height/3.4:3.*flnum_height/3.4)) + (floornr<-1.?flnum_height/3.4:0.);\n    vec3 pos2 = pos;\n    pos2.y = mod(pos2.y, floor_height);\n    return sdRoundBox(pos2 + vec3(staircase_width, -flnum_ypos, 0.), vec3(flnum_depth, flnum_height/2., flnw), 0.001); \n}\n#endif\n\n#ifdef cityscape\nfloat blockindex;\nfloat map_city(vec3 pos)\n{\n    if (pos.x<staircase_length/2.)\n        return maxdist;\n        \n    float city = pos.y + floor_height/2.;\n        \n    if (pos.x>city_stepsize)\n    {        \n        float line = floor(pos.x/city_stepsize);\n        float col = floor(pos.z/city_stepsize);\n        blockindex = line + 200.*col;\n        float cityhash1 = hash(842.658*blockindex);\n        float cityhash2 = pow(hash(534.685*blockindex), city_blheightpow);\n\n        float blocksize = city_minblsize + cityhash1*(city_maxblsize - city_minblsize);\n        float blockheight = city_minblheight + cityhash2*(city_maxblheight - city_minblheight)*min((line - 1.)/4., 1.);\n\n        pos.xz = mod(pos.xz, city_stepsize) - vec2(city_stepsize/2.);\n    \n        city = min(city, max(abs(pos.x) - blocksize/2., abs(pos.z) - blocksize/2.)); \n        city = max(city, pos.y - blockheight);\n    }\n\n    return 0.4*min(city, 10.);\n}\n#endif\n\n#ifdef doorbell\nfloat map_doorbell(vec3 pos)\n{\n    pos.y = mod(pos.y, floor_height);\n    vec3 pos2 = pos;\n    if (pos.x>-staircase_length/2. + 1.)\n    {\n        pos2.z = abs(pos2.z);\n        pos2-= vec3(-staircase_length/2. + floor_width/2. + door_width/2. + doorbell_rpos, door_height*doorbell_height, staircase_width/2.);\n    }\n    else\n    {\n        pos2.z = abs(pos2.z);\n        pos2+= vec3(staircase_length/2., -door_height*doorbell_height, -staircase_width/4. - door_width/2. - doorbell_rpos);\n        pos2.xz = pos2.zx;\n        pos2.z = -pos2.z;\n    }\n\n    float doorbellv = sdRoundBox(pos2, doorbell_plate.xyz, doorbell_plate.w);\n    doorbellv = min(doorbellv, length(pos2 - vec3(0., doorbell_button.w, doorbell_srad - doorbell_sdep - doorbell_plate.z - doorbell_plate.w)) - doorbell_srad);\n    doorbellv = min(doorbellv, sdCylinder(pos2.xzy - vec3(0., 0., doorbell_button.w), vec2(doorbell_button.x, doorbell_button.y), 0., doorbell_button.z));\n    \n    doorbellv = max(doorbellv, -sdRoundBox(pos2 - vec3(0., doorbell_nplate_ypos, -doorbell_plate.z - doorbell_plate.w), doorbell_nplate.xyz, doorbell_nplate.w));\n    \n    \n    return doorbellv;\n}\n#endif\n\nvec2 map(vec3 pos, bool hasbumps, bool forshadow)\n{\n    vec2 res;\n\n    if (pos.x<staircase_length/2. + 0.5)\n    {    \n        floornr = floor((pos.y + 0.1)/floor_height);\n        \n        float walls = map_walls(pos, hasbumps);\n        res = vec2(walls, WALLS_OBJ);\n\n        #ifndef testmode\n\n        float floors = map_floors(pos);\n        res = opU(res, vec2(floors, FLOORS_OBJ)); \n        //vec2 res = vec2(floors, FLOORS_OBJ); \n\n        float stairs = map_stairs(pos);\n        res = opU(res, vec2(stairs, STAIRS_OBJ));\n\n        float doors = map_doors(pos);\n        res = opU(res, vec2(doors, DOORS_OBJ));\n\n        if (!forshadow)\n        {\n            float lamps = map_lamps(pos);\n            res = opU(res, vec2(lamps, LAMPS_OBJ));\n        }\n\n        float handles = map_handles(pos);\n        res = opU(res, vec2(handles, HANDLES_OBJ));    \n\n        float handrail = map_handrail(pos);\n        res = opU(res, vec2(handrail, HANDRAIL_OBJ));    \n\n        #ifdef floornumber\n        if (!forshadow)\n        {    \n           float floornumbero = map_floornumber(pos);\n           res = opU(res, vec2(floornumbero, FLOORNUMB_OBJ));\n        }\n        #endif\n\n        #ifdef doorbell\n        float doorbellv = map_doorbell(pos);\n        res = opU(res, vec2(doorbellv, DOORBELL_OBJ)); \n        #endif\n    }\n    else\n    {\n        #ifdef cityscape\n        float city = map_city(pos);\n        res = vec2(city, CITY_OBJ);      \n        #endif\n    }\n    \n    #endif\n    \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.08;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 110; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, false, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        #ifdef cityscape\n        if (t>10.)\n            t+= dist*1.8;\n        else\n            t+= dist*0.99;\n        #else\n            t+= dist*0.99;\n        #endif\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2, true, false).x;\n    }\n    return normalize(n);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<30; i++ )\n    {\n\t\tfloat h = 0.12*map(ro + rd*t, false, true).x;\n        res = min( res, 24.0*h/t );\n        t += clamp( h, 0.0, 0.80 );\n        if( res<0.07 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    #ifdef opendoors\n    if (ray.x>0.2)\n        #ifdef cityscape\n        return vec3(0.7 + 0.25*ray.y, 0.87 + 0.2*ray.y, 1.);\n        #else\n        return ray.y<0.?vec3(0.5 - 0.3*ray.y):vec3(0.7 + 0.25*ray.y, 0.87 + 0.2*ray.y, 1.);\n        #endif\n    else\n        return vec3(0.22, 0.2, 0.18);\n    #else\n    #ifdef cityscape\n    return vec3(0.7 + 0.25*ray.y, 0.87 + 0.2*ray.y, 1.);\n    #else\n    return ray.y<0.?vec3(0.5 - 0.3*ray.y):vec3(0.7 + 0.25*ray.y, 0.87 + 0.2*ray.y, 1.);\n    #endif\n    #endif\n}\n\nvec4 getDirt(vec3 norm, vec3 pos)\n{\n    #ifdef dirt\n    vec2 pos2;\n    \n    if (abs(norm.x)>0.9)\n        pos2 = pos.yz;\n    else if (abs(norm.y)>0.8)\n        pos2 = pos.xz;\n    else\n        pos2 = pos.xy;\n        \n    float dirtbias = max(0.1 - 0.5*smoothstep(0.45 - pos.y/1000., 0.9, 0.65*sin(pos.y/dirt_size3 - 0.8) + 0.05*sin(5.21*pos.y/dirt_size3 - 1.) + 0.02*sin(12.51*pos.y/dirt_size3)) - min(pos.y/3000., 0.18), -0.35);\n        \n    float dirtv = 0.25*texture(iChannel2, rotateVec(pos2/dirt_size1, 0.42)).r + 0.25*texture(iChannel2, rotateVec(0.69*pos2, 1.25)/dirt_size1).g;\n    dirtv+= 0.25*texture(iChannel2, rotateVec(0.43*pos2, 2.38)/dirt_size1).b + 0.25*texture(iChannel2, rotateVec(0.33*pos2, 2.88)/dirt_size1).r;\n    float dirtrep = 1. - dirt_intensity + dirt_intensity*(0.3*texture(iChannel0, pos2/dirt_size2).r + 0.4*texture(iChannel0, rotateVec(1.17*pos2, 1.22)/dirt_size2).g + 0.3*texture(iChannel0, rotateVec(1.31*pos2, 1.88)/dirt_size2).g);\n    dirtv = dirt_transp*smoothstep(dirtrep - dirt_contrast/2. + dirtbias,  dirtrep + dirt_contrast/2. + dirtbias, dirtv);\n        \n    vec3 dirtcol = mix(dirt_color1, dirt_color2, pow(0.8*texture(iChannel0, pos2/dirt_size4).r + 0.6*texture(iChannel0, rotateVec(1.42*pos2, 1.68)/dirt_size4).g, 1.7));\n     \n    return vec4(dirtcol, dirtv);\n    #else\n    return vec4(0.);\n    #endif\n}\n\n#ifdef floornumber\nfloat getChar(vec2 uv, int num)\n{\n    int ch = num - 79;\n    vec2 uv2 = mod(uv, charSpacingFac*1./16.);\n    uv2.y-= 0.5;\n    vec2 offset = vec2(mod(float(ch-1), 16.)/16., -float(ch/16)/16.);\n    vec2 pos = uv2 + offset + vec2(1., 1.1)*vec2((1.-charSpacingFac.x)/32., (1.-charSpacingFac.y)/32.);\n    return smoothstep(0.2, 0.6, textureLod(iChannel3, pos, 0.65).r);\n}\n#endif\n\nvec3 getDaylight()\n{\n    #ifdef gettingnight\n\tfloat tf = 0.6/camperiod;\n    //float tf = 1.;\n    float time2 = abs(mod(iTime*tf + 28., 56.) - 28.);\n\treturn vec3(smoothstep(21., 15., time2), 0.05 + 0.95*smoothstep(20.2, 14., time2), 0.2 + 0.8*smoothstep(20., 12.5, time2));\n    #else\n    return vec3(1.);\n    #endif\n}\n\n\n// Combines the colors\nfloat cityhaslight;\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   vec4 dirto = getDirt(norm, pos);\n   vec3 ccolor = mix(ceiling_color, dirto.rgb, dirto.a); \n\n   if (objnr==WALLS_OBJ)\n   {\n      vec3 wcolor = walls_color*(norm.x<-0.9?0.82:1.);\n      wcolor = mix(wcolor, dirto.rgb, dirto.a);\n      \n      return wcolor;\n   }\n   else if (objnr==FLOORS_OBJ)\n   {\n      vec3 flcol;\n      \n      #ifdef blood\n      float bloodv = getBlood(pos); \n      #else\n      float bloodv = 0.;\n      #endif      \n      \n      float aparttext = 0.5 + 0.3*texture(iChannel0, rotateVec(pos.xz, 0.55)*apartment_textscale).r + 0.3*texture(iChannel0, rotateVec(pos.xz, 0.95)*apartment_textscale*1.53).g + 0.3*texture(iChannel0, rotateVec(pos.xz, 2.08)*apartment_textscale*2.56).b +  + 0.3*texture(iChannel0, rotateVec(pos.xz, 2.27)*apartment_textscale*4.18).r;\n      if (pos.x<-staircase_length/2. && bloodv>=0.)\n          flcol = norm.y>0.9?aparttext*apartment_color1*(0.5 + 0.6*smoothstep(staircase_length/2. + apartment_width, staircase_length/2., -pos.x)):vec3(0.3);\n      else if (abs(pos.z)>staircase_width/2. && bloodv>=0.)\n          flcol = norm.y>0.9?aparttext*apartment_color2*(0.5 + 0.6*smoothstep(staircase_width/2. + apartment_width, staircase_width/2., abs(pos.z))):vec3(0.3);\n      else if (abs(norm.x)>0.9 && bloodv>=0.)\n          flcol = ccolor*(norm.x<-0.9?0.83:1.4);\n      else if (norm.y<0.9 && bloodv>=0.)\n          flcol = 1.15*ccolor;\n      else\n      {\n          float tile_index = floor(pos.x/tile_size) + 50.*floor(pos.z/tile_size);\n          vec2 tilepos = pos.xz*texture_scale*(1.3 - 0.6*hash(tile_index*126.25));\n          tilepos = rotateVec(tilepos, 2.*pi*hash(tile_index*417.33));\n          tilepos+= vec2(hash(tile_index*854.27), hash(tile_index*312.57));\n          \n          flcol = mix(floors_color, texture(iChannel0, tilepos).rgb, 0.3);\n          \n          flcol*= 0.7 + 0.3*smoothstep(0., tile_size/30., mod(pos.x, tile_size));\n          flcol*= 0.7 + 0.3*smoothstep(tile_size, (1. - 1./30.)*tile_size, mod(pos.x, tile_size));\n          flcol*= 0.7 + 0.3*smoothstep(0., tile_size/30., mod(pos.z, tile_size));\n          flcol*= 0.7 + 0.3*smoothstep(tile_size, (1. - 1./30.)*tile_size, mod(pos.z, tile_size));\n      }\n      \n      #ifdef blood\n      bloodv = 0.95*pow(smoothstep(0.0075, 0.028, bloodv), 0.12);\n      flcol = mix(flcol, blood_color, bloodv);\n      #endif\n   \n      return flcol;\n   }\n   else if (objnr==STAIRS_OBJ)\n   {\n       if (norm.y>0.9)\n       {\n           vec2 tilepos1 = 0.7*pos.xz*texture_scale;\n           vec2 tilepos2 = 1.1*rotateVec(tilepos1, 1.1) + vec2(1.2, 0.2);\n           vec2 tilepos3 = 1.5*rotateVec(tilepos1, 2.35);\n           vec3 flcol = mix(mix(texture(iChannel0, tilepos1).rgb,  texture(iChannel0, tilepos2).rgb, 0.60), texture(iChannel0, tilepos3).rgb, 0.4);\n           flcol = mix(floors_color, 1.4*flcol - 0.2, 0.3);\n       \n           return 1.07*flcol;\n       }\n       else if (abs(norm.x)>0.9)\n           return ccolor*(norm.x<-0.9?0.83:1.4);\n       else\n           return 1.2*ccolor;\n   }\n   else if (objnr==DOORS_OBJ)\n   {\n      vec3 docolor;\n      float doornr = floornr*4.;\n      if (pos.z>0.)\n         doornr+= 1.;\n      if (pos.x<-staircase_length/2.)\n         doornr+= 2.;\n      \n      if (hash(doornr*1527.534)<coldoor_prob + floornr/1000. && floornr>0.)\n          docolor = door_colors[int(mod(doornr, 6.))];\n      else   \n      {\n          if (pos.x<-staircase_length/2.)\n          {\n              pos.z+= -staircase_width/4. + door_width/2.;\n              pos.z/= cos(door_angle);\n              pos.yz = rotateVec(pos.yz, 0.24*(hash(8557.256*doornr) - 0.5));\n              docolor = mix(doors_color, texture(iChannel1, pos.yz*vec2(0.7, 2.)).rgb, 0.4);\n          }\n          else\n          {\n              pos.x+= staircase_length/2. - floor_width/2. + door_width/2.;\n              pos.x/= cos(door_angle);\n              pos.yx = rotateVec(pos.yx, 0.24*(hash(8547.256*doornr) - 0.5));\n              docolor = mix(doors_color, texture(iChannel1, pos.yx*vec2(0.7, 2.)).rgb, 0.4);\n          }\n      }\n      return docolor;\n   }\n   else if (objnr==LAMPS_OBJ)\n      return vec3(1.);\n   else if (objnr==HANDLES_OBJ)\n      return handles_color;\n   else if (objnr==HANDRAIL_OBJ) \n   {\n      float h = (0.5*floor_height)/(staircase_length - floor_width - interfloor_width)*(nb_stairs - 1.)/nb_stairs - 0.01;\n\n      vec3 pos2 = pos;\n      pos2.x-= 0.035;\n\n      if (pos.z>0.)\n      {\n          pos2.y = mod(pos.y - floor_height/2., floor_height) + floor_height/2.;\n\n          pos2.xz = -pos2.xz;\n          pos2.y-= floor_height/2.;\n      }\n      else\n          pos2.y = mod(pos.y, floor_height);\n\n      pos2.y-= h*(pos2.x + staircase_width/2. - floor_width) + handrail_height + (pos.z>0.?0.8:0.3);    \n\n      return pos2.y>handrail_height/2. - handrail_thickness2.x - handrail_roundness - 0.001?handrail_color1:handrail_color2;\n   }\n   #ifdef floornumber\n   else if (objnr==FLOORNUMB_OBJ)\n   {\n       float floornr0 = floornr;\n       floornr = abs(floornr + 1.) - 1.;\n       float charv;\n       if (floornr<99.)\n       {\n           vec2 posn = pos.zy - vec2((floornr<9.?0.09:0.) + (floornr0<-1.?0.09:0.), flnum_ypos + flnum_height/2. - floornr*floor_height);\n           int fln = pos.z<0. && (floornr>=9. || floornr0<-1.)?(floornr0<-1.?-3:int((floornr + 1.)/10.)):int(mod(floornr + 1., 10.));\n           charv = getChar(0.1948243*posn, fln);\n       }\n       else\n       {\n           vec2 posn = pos.zy - vec2(0.09, flnum_ypos + flnum_height/2. - floornr*floor_height);\n           int fln;\n           if (floornr>998.)\n               fln = 15;\n           else\n           {\n               if (pos.z<-flnum_height/3.)\n                   fln = int((floornr + 1.)/100.);\n               else if (pos.z>flnum_height/3.)\n                   fln = int(mod(floornr + 1., 10.));\n               else\n                   fln = int(mod((floornr + 1.)/10., 10.));\n           }\n           charv = getChar(0.1948243*posn, fln);\n       }\n       return mix(flnum_color1, flnum_color2, charv);\n   }\n   #endif\n   #ifdef cityscape\n   else if (objnr==CITY_OBJ)\n   {\n       if (norm.y>0.9)\n           return street_color;\n       \n       float cityhash3 = hash(2652.174*blockindex);\n       float cityhash4 = hash(1431.757*blockindex);\n   \n       vec3 citycol = city_color + city_colvar*(cityhash3 - 0.5) + vec3(cityhash3*0.05 + 0.02*cityhash3, 0.03, 0.04 - cityhash3*0.05);\n       \n       float dlv = 0.47*smoothstep(1.6, 0.4, length(getDaylight()));\n       float cityhash5;\n       if (cityhash4>0.5)\n       {\n           if (abs(norm.z)>0.9)\n           {\n               citycol*= mod(pos.x, city_winsize.x)>city_winsize.x*0.35 && mod(pos.y, city_winsize.y)>city_winsize.y*0.35?city_windark:1.;\n               \n               #ifdef gettingnight\n               cityhash5 = hash(654.561*(blockindex + floor(pos.x/city_winsize.x) + 20.*floor(pos.y/city_winsize.y)));\n               cityhaslight = mod(pos.x, city_winsize.x)>city_winsize.x*0.35 && mod(pos.y, city_winsize.y)>city_winsize.y*0.35 && cityhash5<dlv?1.:0.;\n               #else\n               cityhaslight = 0.;\n               #endif\n           }\n           else\n           {\n               citycol*= mod(pos.z, city_winsize.x)>city_winsize.x*0.35 && mod(pos.y, city_winsize.y)>city_winsize.y*0.35?city_windark:1.;\n               \n               #ifdef gettingnight\n               cityhash5 = hash(489.648*(blockindex + floor(pos.z/city_winsize.x) + 20.*floor(pos.y/city_winsize.y)));\n               cityhaslight = mod(pos.z, city_winsize.x)>city_winsize.x*0.35 && mod(pos.y, city_winsize.y)>city_winsize.y*0.35 && cityhash5<dlv?1.:0.;\n               #else\n               cityhaslight = 0.;\n               #endif               \n           }\n       }\n       else\n       {\n           if (abs(norm.z)>0.9)\n           {\n               float wingrid = 0.7 + 0.3*smoothstep(0., city_winsize.x/10., mod(pos.x, city_winsize.x));\n               wingrid*= 0.7 + 0.3*smoothstep(city_winsize.x, (1. - 1./10.)*city_winsize.x, mod(pos.x, city_winsize.x));\n               wingrid*= 0.7 + 0.3*smoothstep(0., city_winsize.y/15., mod(pos.y, city_winsize.y));\n               wingrid*= 0.7 + 0.3*smoothstep(city_winsize.y, (1. - 1./15.)*city_winsize.y, mod(pos.y, city_winsize.y));\n               citycol*= wingrid;\n              \n               #ifdef gettingnight\n               cityhash5 = hash(746.253*(blockindex + floor(pos.x/city_winsize.x) + 20.*floor(pos.y/city_winsize.y)));\n               cityhaslight = cityhash5<0.4*dlv?pow(wingrid, 10.):0.;\n               #else\n               cityhaslight = 0.;\n               #endif              \n           }\n           else\n           {\n               float wingrid = 0.7 + 0.3*smoothstep(0., city_winsize.x/10., mod(pos.z, city_winsize.x));\n               wingrid*= 0.7 + 0.3*smoothstep(city_winsize.x, (1. - 1./10.)*city_winsize.x, mod(pos.z, city_winsize.x));\n               wingrid*= 0.7 + 0.3*smoothstep(0., city_winsize.y/15., mod(pos.y, city_winsize.y));\n               wingrid*= 0.7 + 0.3*smoothstep(city_winsize.y, (1. - 1./15.)*city_winsize.y, mod(pos.y, city_winsize.y));\n               citycol*= wingrid;\n              \n               #ifdef gettingnight\n               cityhash5 = hash(257.362*(blockindex + floor(pos.z/city_winsize.x) + 20.*floor(pos.y/city_winsize.y)));\n               cityhaslight = cityhash5<0.4*dlv?pow(wingrid, 10.):0.;\n               #else\n               cityhaslight = 0.;\n               #endif              \n           }\n       }\n\n       return citycol;\n   }\n   #endif\n   #ifdef doorbell\n   else if (objnr==DOORBELL_OBJ)\n   {\n       vec3 pos2 = pos;\n       pos2.y = mod(pos.y, floor_height);\n       if (pos.x>-staircase_length/2. + 1.)\n       {\n           pos2.z = abs(pos2.z);\n           pos2-= vec3(-staircase_length/2. + floor_width/2. + door_width/2., 0., staircase_width/2.);\n       }\n       else\n       {\n           pos2.z = abs(pos2.z);\n           pos2+= vec3(staircase_length/2., 0., -staircase_width/4. - door_width/2.);\n           pos2.xz = pos2.zx;\n           pos2.z = -pos2.z;\n       }   \n       \n       if (abs(pos2.x - doorbell_rpos)<doorbell_nplate.x + doorbell_nplate.w && abs(pos2.y - door_height*doorbell_height - doorbell_nplate_ypos)<doorbell_nplate.y + doorbell_nplate.w)\n           return doorbell_color3;\n       \n       return pos2.z>-doorbell_plate.z - doorbell_plate.w - doorbell_sdep + 0.001?doorbell_color1:doorbell_color2;\n   }\n   #endif\n   else\n      return getSkyColor(ray);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl;\n    vec3 pl2;\n    float dlp;\n    float dnp;\n    float lampint;\n    float lampint1;\n    float lampint2;\n    vec3 lampcolor;\n    \n    if (lampnr<3 && objnr==CITY_OBJ)\n        return vec3(0.);\n    \n    if (lampnr<3)\n    {\n        pl = normalize(lamp.position - pos);\n        pl2 = normalize(lamp.position + vec3(0., lamp_height - 0.15, 0.) - pos);\n        dlp = distance(lamp.position, pos);\n        vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n        dnp = dot(norm, pli);\n        lampint1 = smoothstep((lamp.position.y>pos.y?0.98:0.51)*floor_height, (lamp.position.y>pos.y?0.52:0.03)*floor_height, abs(lamp.position.y - pos.y));\n        //lampint2 = smoothstep((lamp.position.y>pos.y?0.78:0.45)*floor_height, (lamp.position.y>pos.y?0.64:0.07)*floor_height, abs(lamp.position.y - pos.y));\n        lampint2 = pos.y - lamp.position.y<lamp_height + floor_thickness/2.4 && pos.y - lamp.position.y>-floor_height + lamp_height + floor_thickness/2.5?1.:0.;\n        lampint = lamp.intensity*mix(lampint1, lampint2, smoothstep(-staircase_length/2. + floor_width*1.03, -staircase_length/2. + floor_width - 0.3, pos.x));\n        lampcolor = lamp.color;\n    }\n    else\n    {\n        if (objnr==CITY_OBJ)\n        {\n            lampint = pos.x - 0.15*abs(pos.z)<0.?-0.15:0.8;\n            lampcolor = vec3(1., 0.99, 0.97)*getDaylight();\n            pl = normalize(vec3(-1., 0.35, -0.5)), pl2 = pl;\n        }\n        else\n        {\n            lampint = smoothstep(-floor_height/2. - 0.3, -floor_height/2. + 0.3, pos.y)*daylight_intensity*smoothstep(-staircase_length/3., staircase_length/2., pos.x);\n            lampcolor = daylight_color*getDaylight();\n            pl = daylight_direction, pl2 = pl;\n        }\n        \n        dnp = dot(norm, pl);\n    }\n\n    if (objnr==LAMPS_OBJ)\n    {\n        if (lampnr==1)\n        {\n           dnp = 0.1 + 0.78*smoothstep(2.9*lamp_radius, 0.5*lamp_radius, distance(pos, lamp.position + vec3(0., lamp_height + floor_thickness - lamp_thickness/2. - 0.08, 0.)));\n           lampint = lamp.intensity;\n           ocol = mix(lampcolor, vec3(1.), 0.7)*lampso_color;\n        }\n        else\n        {\n           dnp = 0.;\n           lampint = 0.;\n        }\n    }\n    else\n        dnp = 0.35 + 0.65*dnp;\n        \n    if (objnr==HANDLES_OBJ)\n        dnp = 0.2 + 0.8*pow(1.1*dnp, 3.5) - 0.12*sin(dnp*18. - 15.*pos.x);\n        \n    if (objnr==DOORBELL_OBJ && length(ocol)>0.8)\n        dnp = 0.4 + 0.6*pow(1.1*dnp, 3.5) - 0.08*sin(dnp*10. - 85.*pos.x - 25.*pos.y + 40.*length(norm.xz));        \n    \n    #ifdef blood\n    float bloodv = getBlood(pos);\n    bloodv = smoothstep(0., 0.015, bloodv);\n    \n    float specint = objnr==CITY_OBJ?0.:(objnr==WALLS_OBJ?specint_walls:(objnr==FLOORS_OBJ || objnr==STAIRS_OBJ?(norm.y>0.9?mix(specint_floors, specint_blood, bloodv):specint_walls):specint_doors));\n    float specshin = objnr==WALLS_OBJ?specshin_walls:(objnr==FLOORS_OBJ || objnr==STAIRS_OBJ?(norm.y>0.9?mix(specshin_floors, specshin_blood, bloodv):specshin_walls):specshin_doors);\n    #else\n    float specint = objnr==CITY_OBJ?0.:(objnr==WALLS_OBJ?specint_walls:(objnr==FLOORS_OBJ || objnr==STAIRS_OBJ?(norm.y>0.9?specint_floors:specint_walls):specint_doors));\n    float specshin = objnr==WALLS_OBJ?specshin_walls:(objnr==FLOORS_OBJ || objnr==STAIRS_OBJ?(norm.y>0.9?specshin_floors:specshin_walls):specshin_doors);    \n    #endif\n    \n    // Diffuse shading\n    vec3 col = ocol*lampcolor*lampint*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Ambient shading\n    if (lampnr==1)\n        col+= ocol*ambientColor*ambientint*mix(1., dnp, 0.35); \n    \n    // Specular shading\n    #ifdef specular\n       if (dot(norm, campos - pos) > 0.0)\n    col+= lampcolor*lampint*specint*pow(max(0.0, dot(reflect(pl2, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    //if (objnr!=LAMPS_OBJ && lampnr==2)\n    if (objnr!=LAMPS_OBJ)\n        //col*= lampint1*shi*calcSoftshadow(pos, pl) + 1. - shi;\n        col*= shi*calcSoftshadow(pos, pl) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr, float dist)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<4; l++)\n    {\n        float ypos = floor_height*floor((pos.y + 0.1)/floor_height) + floor_height*(float(l - 1)) - 0.1;\n        float floornr = floor((pos.y + 0.1)/floor_height) + float(l - 1);\n        \n        float lamps_int2;\n        float colhash = hash(floornr*15855.86251) - 0.5;\n        float colhash2 = lamps_color_var*pow(abs(colhash), 1.5);\n        float colhash3 = hash(floornr*735.145);\n        float colhash4 = hash(floornr*851.236);\n        \n        vec3 lamps_color2;\n        if (colhash4>min(floornr/40. - 0.15, 0.15))\n        {\n            lamps_int2 = lamps_int*(1. + 0.5*lamps_int_var - lamps_int_var*hash(floornr*85624.548));\n            lamps_color2 = lamps_color - (colhash>0.?vec3(0., 0., colhash2):vec3(colhash2, 0.2*colhash2, 0.));\n        }\n        else\n        {\n            lamps_int2 = 1.;\n            lamps_color2 = spec_lamps_colors[int(colhash3*4.)];\n        }\n        \n        float offhash = hash(floornr*1769.8462);\n        if (offhash<=min(lamps_offprob + floornr/1000., 0.4) && floornr>4.)  \n            lamps_int2*= 0.;\n        if (1. - offhash<=min(lamps_blinkprob + floornr/1000., 0.4) && floornr>6.)\n            lamps_int2*= sin(iTime*lamps_blinkspeed)+0.65*sin(2.3*iTime*lamps_blinkspeed + floornr)+0.33*sin(4.7*iTime*lamps_blinkspeed + floornr)>0.?0.:1.;\n\n        Lamp curlamp = Lamp(vec3(-staircase_length/2. + floor_width/2., ypos + floor_height - floor_thickness - lamp_height, 0.), lamps_color2, lamps_int2, lamps_attenuation);\n        col+= lampShading(curlamp, norm, pos, ocol, objnr, l);     \n    }\n    \n    #ifdef cityscape\n    if (objnr==CITY_OBJ && pos.x>80. && dist<maxdist*0.7)\n        col = (1. - cityhaslight*0.5)*col + cityhaslight*city_light_color;\n    #endif  \n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec3 getCameraPos(float time)\n{\n    vec3 cpos = vec3(0.);\n    cpos.y = 0.5;\n    float time2 = fract(time);\n    float camheight2 = camheight + texture(iChannel0, (vec2(6.5, 6.5))/iResolution.xy).a;\n    float xpos = texture(iChannel0, (vec2(8.5, 8.5))/iResolution.xy).a;\n    // floor\n    if (time2<0.2)\n    {\n        cpos.xz = vec2(0., staircase_width/2. - stairs_width/2. + xpos);\n        cpos.xz = rotateVec(cpos.xz, pi*time2/0.2);\n        cpos.x-= staircase_length/2. - floor_width;\n        cpos.y = camheight2 + walk_ampl*(0.5 - pow(sin(time2*2.*pi*walk_freq2), walk_pow));\n    }\n    // stairs 1\n    else if (time2<0.5)\n    {\n       cpos.x = -staircase_length/2. + floor_width + (staircase_length - floor_width - interfloor_width)*(time2 - 0.2)/0.3;\n       cpos.z = -staircase_width/2. + stairs_width/2. - xpos;\n       cpos.y = camheight2 + floor_height/2.*(time2 - 0.2)/0.3 + walk_ampl*(0.5 - pow(sin((time2 - 0.2)*2.*pi*walk_freq2), walk_pow));\n    }\n    // interfloor\n    else if(time2<0.7)\n    {\n        cpos.xz = vec2(0., staircase_width/2. - stairs_width/2. + xpos);\n        cpos.xz = rotateVec(cpos.xz, pi + pi*(time2 - 0.5)/0.2);\n        cpos.x+= staircase_length/2. - interfloor_width;\n        cpos.y = camheight2 + floor_height/2. + walk_ampl*(0.5 - pow(sin((time2 - 0.5)*2.*pi*walk_freq2), walk_pow));\n    }\n    // stairs 2\n    else\n    {\n       cpos.x = staircase_length/2. - interfloor_width - (staircase_length - floor_width - interfloor_width)*(time2 - 0.7)/0.3;\n       cpos.z = staircase_width/2. - stairs_width/2. + xpos;\n       cpos.y = camheight2 + floor_height/2. + floor_height/2.*(time2 - 0.7)/0.3 + walk_ampl*(0.5 - pow(sin((time2 - 0.75)*2.*pi*walk_freq2), walk_pow));\n    }\n    \n    cpos.y+= floor_height*floor(time);\n    return cpos;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   #ifdef testmode\n   campos = vec3(-staircase_length/2. + 0.5*floor_width, camheight, staircase_width/2. - stairs_width/2.);\n   camdir = vec3(1., 0., 0.);\n   #else\n   float time1 = iTime + texture(iChannel0, vec2(2.5, 2.5)/iResolution.xy).a;\n   float time2 = ((time1 + starttime) + camacc*time1*time1)/camperiod;\n   campos = getCameraPos(time2);\n   vec3 campos2 = getCameraPos(time2 + camdiradv);\n   campos2.y-= 0.5;\n   camdir = normalize(campos2 - campos);\n   \n   //campos = vec3(staircase_length, 100., 0.);\n   //camdir = vec3(1., 0., 0.);\n   //campos = vec3(-staircase_length*0.4, 38.5, 0.);\n   //camdir = vec3(1., 0., 0.);   \n   #endif\n\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      \tiMouse2 = vec2(0.5, 0.5);\n   else\n     \tiMouse2 = iMouse.xy/iResolution.xy;\n\n   camdir.xz = rotateVec(camdir.xz, 1.9*pi*(-iMouse2.x + 0.5));\n   camdir.y = tan(2.8*(iMouse2.y - 0.5));\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = lampsShading(norm, pos, col, objnr, tx);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\nfloat get_zoom()\n{\n    float zoomfact = texture(iChannel0, (vec2(4.5, 4.5))/iResolution.xy).a;\n    return zoomfact==0.?1.:zoomfact;\n}\n\n// Main render function\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, get_zoom()*fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    \n    #ifdef cityscape\n    if (ray.x>0.2)\n    {\n        float dist = distance(campos, traceinf.pos);\n        //float fogd = clamp(exp(-pow(fogdens*dist, 4.)), 0., 1.);\n        float fogd = exp(-fogdens*dist);\n        if (dist>staircase_length)\n            fogd = clamp(0.95*fogd - 0.08, 0., 1.);\n        else\n            fogd = 1.;\n        col = mix(mix(getDaylight(), vec3(0.7), 0.12)*fogColor, col, fogd);\n        if (dist>staircase_length)\n            col*= 1.2*clamp(mix(2.5, 0.7, texture(iChannel0,.0001*(traceinf.pos.xz) - vec2(.0022)*iTime).r), 0., 1.4);\n    }\n    #endif\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* ToDo:\n   * Use keys QWERT to fast-rewind (subtract 2.*iTimeDelta)\n   * Use Up/Down arrows and Pg Up and Pg Down to zoom in/out like Transparent Screen\n   * Use keys A and Y to change camheight \n*/\n\nconst float KEY_SPACE   = 32.5/256.0;\nconst float KEY_1\t\t= 49.5/256.0;\nconst float KEY_2\t\t= 50.5/256.0;\nconst float KEY_3\t\t= 51.5/256.0;\nconst float KEY_4\t\t= 52.5/256.0;\nconst float KEY_5\t\t= 53.5/256.0;\nconst float KEY_Q\t\t= 81.5/256.0;\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_E\t\t= 69.5/256.0;\nconst float KEY_R\t\t= 82.5/256.0;\nconst float KEY_T\t\t= 84.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_Y\t\t= 89.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_PG_UP   = 33.5/256.0;\nconst float KEY_UP      = 38.5/256.0;\nconst float KEY_PG_DOWN = 34.5/256.0;\nconst float KEY_DOWN    = 40.5/256.0;\n\nconst float min_zoom = 0.2;\nconst float max_zoom = 30.;\nconst float zfact = 1.008;\nconst float tStep = 1.;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.5/3.) ).x > .0;\n}\n\nbool keyToggle(float key)\n{\n\treturn texture(iChannel1, vec2(key, 2.5/3.) ).x > .0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n\n    if (fragCoord==vec2(2.5, 2.5))\n    {\n        float delay;\n        if (iFrame==0)\n            delay = 0.;\n        else\n            delay = texture(iChannel0, vec2(2.5, 2.5)/iResolution.xy).a;\n        \n        bool spaceToggled = keyToggle(KEY_SPACE);\n        if (spaceToggled)\n            delay-= iTimeDelta;\n\n        if (isKeyPressed(KEY_1))\n            delay+= 0.02;\n        if (isKeyPressed(KEY_2))\n            delay+= 0.05;\n        if (isKeyPressed(KEY_3))\n            delay+= 0.1;\n        if (isKeyPressed(KEY_4))\n            delay+= 0.2;    \n        if (isKeyPressed(KEY_5))\n            delay+= 0.5;\n            \n        if (isKeyPressed(KEY_Q))\n            delay-= 0.02 + (spaceToggled?0.:iTimeDelta);\n        if (isKeyPressed(KEY_W))\n            delay-= 0.05 + (spaceToggled?0.:iTimeDelta);\n        if (isKeyPressed(KEY_E))\n            delay-= 0.1 + (spaceToggled?0.:iTimeDelta);\n        if (isKeyPressed(KEY_R))\n            delay-= 0.2 + (spaceToggled?0.:iTimeDelta);    \n        if (isKeyPressed(KEY_T))\n            delay-= 0.5 + (spaceToggled?0.:iTimeDelta);                \n\n        fragColor.a = delay;\n   }\n   \n   if (fragCoord==vec2(4.5, 4.5))\n   {   \n        float zoom;\n        if (iFrame==0)\n            zoom = 1.;\n        else\n            zoom = texture(iChannel0, (vec2(4.5, 4.5))/iResolution.xy).a;\n        if (zoom==0.)\n             zoom = 1.;\n    \n        if (isKeyPressed(KEY_UP) && zoom<max_zoom)\n           zoom*= zfact;\n    \n        if (isKeyPressed(KEY_DOWN) && zoom>min_zoom)\n           zoom/= zfact;\n    \n        if (isKeyPressed(KEY_PG_UP) && zoom<max_zoom)\n           zoom*= pow(zfact, 8.);\n    \n        if (isKeyPressed(KEY_PG_DOWN) && zoom>min_zoom)\n           zoom/= pow(zfact, 8.); \n    \n        fragColor.a = zoom;\n   }\n   \n   if (fragCoord==vec2(6.5, 6.5))\n   { \n        float height;\n        if (iFrame==0)\n            height = 0.;\n        else\n            height = texture(iChannel0, (vec2(6.5, 6.5))/iResolution.xy).a;\n\n        if (isKeyPressed(KEY_A) && height<1.)\n           height+= 0.02;\n    \n        if (isKeyPressed(KEY_Y) && height>-1.4)\n           height-= 0.02;\n           \n        fragColor.a = height;\n   }\n   \n   if (fragCoord==vec2(8.5, 8.5))\n   { \n        float xpos;\n        if (iFrame==0)\n            xpos = 0.;\n        else\n            xpos = texture(iChannel0, (vec2(8.5, 8.5))/iResolution.xy).a;\n    \n        if (isKeyPressed(KEY_S) && xpos>-0.75)\n           xpos-= 0.02;\n           \n        if (isKeyPressed(KEY_D) && xpos<0.75)\n           xpos+= 0.02;           \n           \n        fragColor.a = xpos;\n   }   \n}","name":"Buffer A","description":"","type":"buffer"}]}