{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// The width and height of a brick/mortar in [0,1] image space\n#define BRICKWIDTH 2.0\n#define BRICKHEIGHT 1.28\n#define MORTARTHICKNESS 0.16\n\n// Describes the width and height of a single brick 'feature' in image space.\n// A 'brick feature' is define as rectangle following:\n//    - Horizontally: mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKWIDTH + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKWIDTH + 0.5 * MORTARTHICKNESS, BRICKWIDTH + MORTARTHICKNESS]\n//    - Vertically  : mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKHEIGHT + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKHEIGHT + 0.5 * MORTARTHICKNESS, BRICKHEIGHT + MORTARTHICKNESS]\n#define BMWIDTH (BRICKWIDTH + MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT + MORTARTHICKNESS)\n\n// Describes the relative mortar boundary in normalized 'break feature' space [0,1]\n#define MWF (MORTARTHICKNESS * 0.5 / BMWIDTH)\n#define MHF (MORTARTHICKNESS * 0.5 / BMHEIGHT)\n\nconst float PI=3.14159265;\n\n/**\n * Distance function for the floor at y == -5 (World space).\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_floor(in vec3 p)\n{\n  return vec2(p.y+5.0,0);\n}\n\n/**\n * General distance function used in the shader.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 distance_to_obj(in vec3 p)\n{\n    return obj_floor(p);\n}\n\n/**\n * Map the given location to the 'brick feature' space of the floor.\n * @param p: worldspace position vector [x,y,z]\n * @return: Return the feature space coordinates, range [0,1].\n */\nvec2 getBrickFeatureCoordinate(in vec3 p){\n    vec2 textureCoordinates = p.xz / vec2(BMWIDTH, BMHEIGHT);\n    \n    if (mod(textureCoordinates.y * 0.5, 1.0) > 0.5)\n    {\n        textureCoordinates.x += 0.5;\n    }\n    \n    float xBrick = floor(textureCoordinates.x);\n    textureCoordinates.x -= xBrick;\n    float yBrick = floor(textureCoordinates.y);\n    textureCoordinates.y -= yBrick;\n    \n    return textureCoordinates;\n}\n\n/**\n * Determine the color of the brick floor.\n * @param p: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 floor_color(in vec3 p)\n{\n    // Material color information:\n    vec4 brickColor = vec4(0.5, 0.15, 0.14, 1.0); // RGBA\n    vec4 mortarColor = vec4(0.5, 0.5, 0.5, 1.0); // RGBA\n    \n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    // Step functions describing when inside brick and when inside mortar:\n    float widthIndex = step(MWF, textureCoordinates.x) - step(1.0-MWF, textureCoordinates.x);\n    float heightIndex = step(MHF, textureCoordinates.y) - step(1.0-MHF, textureCoordinates.y);\n    \n    // Decide color for mortar or brick.\n    // widthIndex * heightIndex is basically AND-ing if inside width/height of a brick.\n    return mix(mortarColor.rgb, brickColor.rgb, widthIndex*heightIndex);\n}\n\n/**\n * Determine the base surface color for the given location and material id.\n * @param materialIndex: The material identifier.\n * @param position: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 GetMaterialColor(float materialIndex, in vec3 position){\n\tif (materialIndex == 0.0){\n\t\treturn floor_color(position);\n\t}\n\treturn vec3(0,0,0);\n}\n\n/**\n * Calculated the bump height at the given location for the brick surface.\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The bump height at the given location, in range [0,1]\n */\nfloat calculateBumpHeight(in vec3 p){\n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    float hu, hv;\n    \n    hu = smoothstep(0.0, MWF, textureCoordinates.x) - smoothstep(1.0-MWF, 1.0, textureCoordinates.x);\n    hv = smoothstep(0.0, MWF, textureCoordinates.y) - smoothstep(1.0-MWF, 1.0, textureCoordinates.y);\n    \n    return hu*hv;\n}\n\n/**\n * Determine normal using dFdx and dFdy, as presented in \"Texturing & Modelling: A Procedural Approach 3rd ed.\"\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 calculateNormal(in vec3 p){\n    // Note: You could use facefoward instead of having to multiply dFdy with -1.0.\n    //       This however does increase the required parameters for this method.\n    \n    // Accuracy note: Estimate derivative by comparing to value calculated in a neighboring pixel.\n    //                This can lead to a more coarse estimation than doing a custom derivative instead.\n \treturn cross(dFdx(p), -1.0*dFdy(p));   \n}\n\n/**\n * Performs bump mapping for the floor (Material index == 0).\n * @param p: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(p)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 floor_bumpmap(in vec3 p, in vec3 globalNormalVector, bool useCustomDerivative){\n    float heightScaling = 0.01;\n    float heightIncrement = calculateBumpHeight(p);\n    \n    if(useCustomDerivative)\n    {\n        float dhdx = heightScaling * (calculateBumpHeight(vec3(p.x + 0.02, p.y, p.z)) - heightIncrement);\n        float dhdz = heightScaling * (calculateBumpHeight(vec3(p.x, p.y, p.z + 0.02)) - heightIncrement);\n\n        vec3 vector_dhdx = vec3(0.02, dhdx, 0.0);\n        vec3 vector_dhdz = vec3(0.0, dhdz, -0.02);\n    \n    \treturn normalize(cross(vector_dhdx, vector_dhdz));\n    }\n    else\n    {\n        return normalize(calculateNormal(p + globalNormalVector * (heightIncrement*heightScaling)));\n    }\n}\n\n\n/**\n * Checks for bump map modifications to the given normal vector at the given location.\n * @param materialIndex: Index of the material (Produced by distance_to_obj)\n * @param position: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(position)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal, taking bump mapping into account.\n */\nvec3 EvaluateBumpMap(float materialIndex, in vec3 position, in vec3 globalNormalVector, bool useCustomDerivative){\n    if (materialIndex == 0.0){\n        return floor_bumpmap(position, globalNormalVector, useCustomDerivative);\n    }\n    return globalNormalVector;\n}\n\n/**\n * Estimates the surface normal of the distance field at a given position.\n * @param position: Final raymarched position.\n * @param originalDistance: distance from 'position' to the nearest object.\n * @return The unit normal vector.\n */\nvec3 EsitmateDistanceFieldNormal(in vec3 position, float originalDistance){\n\t// Note: Parameter 'originalDistance' can be removed be calling internally at loss of performance:\n\t//       float originalDistance = distance_to_obj(position);\n\t\n\t// Quick trick for generating small permutation of 'position'\n\tconst float derivativeDelta = 0.02;\n\tconst vec2 e = vec2(derivativeDelta,0); \n\t\n\t// Perform a discrete forward derivative:\n\tvec3 n = vec3(originalDistance - distance_to_obj(position - e.xyy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yxy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yyx).x);\n\t// Note: discrete central derivative could be used instead for more accuracy at cost of performace.\n\t\n\treturn normalize(n); // Normalization helps saving 3 divisions by 'derivativeDelta'\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized fragment coordinate in range [-0.5, 0.5]\n    vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n    \n    if(abs(vPos.x) < 0.001){\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n        return;\n    }\n\n\t// See the following URL for naming definitions:\n\t//   http://uploads.gamedev.net/monthly_03_2013/ccs-191720-0-04862100-1363766190.png\n    // Camera up vector, using positive y as 'up':\n    vec3 cameraUpVector = vec3(0,1,0);\n  \n    // Point where the camera is looking at:\n    vec3 cameraTarget = vec3(0,0,0);\n\n    // Map current clicked mouse position on radians [0, 2*PI] horizontally and [0, 0.5*PI) vertically:\n    // Note: 0.5 gives rendering problems if iMouse.Y == iResolution.y\n\t//       This is due to cameraViewDirection and cameraUpVector align perfectly, which causes the\n\t//       cross-product to yield 0. This prevents spanning the horizontal and vertical axis of the\n\t//       camera.\n    float mx = iMouse.x/iResolution.x * 2.0*PI;\n    float my = iMouse.y/iResolution.y * 0.49*PI; \n    \n    vec3 eyeWorldPosition = vec3(cos(my)*cos(mx),\n\t\t\t\t\t\t\t\t sin(my),\n\t\t\t\t\t\t\t\t cos(my)*sin(mx)) * 6.0;\n\n    // Camera setup.\n\t// 1. Get the unit vector for the central viewing direction of the camera:\n    vec3 cameraViewDirection = normalize(cameraTarget - eyeWorldPosition);\n\t\n\t// 2. Spanning the horizontal (u) and veritcal (v) unit vectors describing the camera view-plane axis:\n    vec3 u = normalize(cross(cameraUpVector, cameraViewDirection));\n    vec3 v = normalize(cross(cameraViewDirection, u));\n\t\n\t// 3. Determine the 'projection window' coordinate\n\t// 3.1 Determine the 'project window' center / the camera position:\n    vec3 cameraPosition = eyeWorldPosition + cameraViewDirection;\n\t// 3.2 Map vPos onto the 'project window', taking aspect ratio into account:\n    vec3 evaluatedCoordinate = cameraPosition +\n\t\t\t\t\t\t\t   vPos.x * u * iResolution.x/iResolution.y + // horizontal component\n\t\t\t\t\t\t\t   vPos.y * v; // vertical component\n    vec3 rayCastDirection = normalize(evaluatedCoordinate-eyeWorldPosition);\n\n    // Distance-aided ray marching\n    const float maxd = 100.0; //Max drawing distance from camera center\n    const float inverseMax = 1.0 / maxd;\n    \n    vec2 d = vec2(0.0, 0.0);\n    vec3 colorRGB, rayPosition, normal;\n\n    float rayDistanceTraveled = 1.0;\n    for(int i = 0; i < 256; i++) // maximum value affects horizon mapping/warping\n    {\n    \trayDistanceTraveled += d.x;\n    \trayPosition = eyeWorldPosition + rayCastDirection * rayDistanceTraveled;\n    \td = distance_to_obj(rayPosition);\n        \n        if ((abs(d.x) < .001) || (rayDistanceTraveled > maxd)) \n    \t\tbreak;\n  \t}\n  \n  \tif (rayDistanceTraveled < maxd)\n  \t{\n    \t// y is used to manage materials.\n\t\tcolorRGB = GetMaterialColor(d.y, rayPosition);\n    \n    \tnormal = EsitmateDistanceFieldNormal(rayPosition, d.x);\n      \n    \tnormal = EvaluateBumpMap(d.y, rayPosition, normal, vPos.x > 0.0);\n      \n\t\t// Rotating point light around [0,10,0]:\n\t\tconst float lightRadius = 20.0;\n\t\tvec3 lightPosition = vec3(sin(iTime)*lightRadius, 10, cos(iTime)*lightRadius);\n\t\t\n\t\t// Do simple phong lighting:\n    \tfloat b = clamp(dot(normal, normalize(eyeWorldPosition - rayPosition + lightPosition)),0.0,1.0);    \t\n    \tfragColor=vec4((b*colorRGB + pow(b,16.0)) * (1.0 - rayDistanceTraveled * inverseMax), 1.0);\n  \t}\n  \telse \n    \tfragColor=vec4(0,0,0,1); //background color\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsSSRz","date":"1408619275","viewed":435,"name":"Bumpmapped brick floor","username":"xilconic","description":"Continuation from https://www.shadertoy.com/view/MsSSzR, by adding bumpmapping (2 implementations), simple lighting environment and raymarching for geometry.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","bumpmapping","excersize","documented"],"hasliked":0,"parentid":"","parentname":""}}