{"ver":"0.1","info":{"id":"tddGzn","date":"1567682568","viewed":77,"name":"My first raytracing","username":"Fieu","description":"Simple exercise based on some tutorial i saw\nMouse to change light position","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define RAY_STEPS 256\n\n#define START_DIST 0.0\n#define END_DIST 100.0\n\n// x, y, z, radius\nconst vec4 sphere = vec4(0.0, 0.0, -3.0, 1.0);\n\n// return distance to certain sphere object\nfloat sphereSDF(vec3 p, vec4 sphere) {\n\treturn length(p - sphere.xyz) - sphere.w;\n}\n\n// return distance to closest object on a map\nfloat map(vec3 p) {\n    return sphereSDF(p, sphere);\n}\n\nfloat raytrace(vec3 ro, vec3 rd) {\n    float depth = START_DIST;\n    float current;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        current = map(ro + depth * rd);\n        \n        // hit something\n        if (current < EPSILON) {\n            return depth;\n        }\n        \n        depth += current;\n        \n        // out of reach\n        if (depth >= END_DIST) return END_DIST;\n    }\n    \n    //out of reach\n    return END_DIST;\n}\n\nvec3 diffuse(vec3 p, vec4 sphere, vec3 color, vec3 lightPos) {\n    // sphere normal\n\tvec3 n = normalize(p - sphere.xyz);\n    \n    vec3 lightRay = lightPos - p;\n    vec3 l = normalize(lightRay);\n    \n    // clamp dot product between 0.0 and 0.0\n    // so it will only light the front side of the sphere\n    // also light should illuminate less the further object is\n    // dot product of n and l will return cosine of an angle between rays\n    // the higher angle, the lower value gets, so an area should be darker\n    return color * max(0.0, dot(n, l)) / max(0.0, dot(lightRay, lightRay));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalization, (0, 0) is the center of view\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // eve position\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    // normalized ray direction\n    vec3 rd = normalize(vec3(uv, 0.0) - ro);\n    \n    // signed distance function (SDF)\n    float dist = raytrace(ro, rd);\n    \n    // didn't hit anything\n    if (dist > END_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n    // colors\n    vec3 ambient = vec3(0.1, 0.1, 0.1);\n    vec3 diffColor = vec3(0.7, 0.7, 1.0);\n    \n    // light position\n    vec3 lightPos = sphere.xyz;\n    if (iMouse.z > 0.0) {\n        vec2 uvMouse = iMouse.xy / iResolution.xy;\n        uvMouse = uvMouse * 2.0 - 1.0;\n        \n        lightPos += vec3(2.0 * uvMouse.x, 0.5 * uvMouse.y, 2.0);\n    }\n    else lightPos += vec3(2.0 * sin(iTime), 0.5 * cos(iTime), 2.0);\n    \n    // basic ambient + diffuse color (light color)\n    vec3 col = ambient + diffuse(ro + dist * rd, sphere, diffColor, lightPos);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}