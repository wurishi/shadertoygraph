{"ver":"0.1","info":{"id":"XtccD7","date":"1532814019","viewed":121,"name":"My attempt at 3D Voronoi","username":"Veggiebob","description":"Yeah I don't really get what I'm doing but I know it has to do with Voronoi. Mouseable","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","voronoi","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define num_points 10.\n#define speed 0.1\n#define point_spread 10.\n#define EPSILON pow(10., -3.)\nvec3 tex (vec3 p, sampler2D t){\n    vec3 t1 = texture(t, p.xy).rgb/3.;\n    t1+=texture(t, p.xz).rgb/3.;\n    t1+=texture(t, p.yz).rgb/3.;\n    return t1;\n}\nvec2 rotate2D (vec2 p, float angle){\n    float a = atan(p.y, p.x)+angle;\n    float m = length(p);\n    return vec2(cos(a)*m, sin(a)*m);\n}\nvec2 calcPointSpot2D (float i){\n    return vec2(sin(iTime*speed+i*point_spread), cos(iTime*speed*2.+i*speed*1.7));\n}\nvec2 calcNearestPoint2D (vec2 p){\n    float minDist = 10000.;\n    float nxtminDist = minDist;\n    float index = -1.;\n    for(float i = 0.; i<num_points; i++){\n        vec2 pp = calcPointSpot2D(i);\n        float d = length(p-pp);\n        if(d<minDist){\n            nxtminDist = minDist;\n            minDist = d;\n        }\n    }\n    return vec2(minDist, nxtminDist);\n}\nvec3 calcPointSpot3D (float i){\n    return vec3(\n        sin(iTime*speed+i*point_spread), \n        cos(iTime*speed*2.+i*point_spread*1.7),\n        sin(iTime*speed*0.3+i*speed*point_spread)\n    );\n}\nvec3 calcNearestPoint3D (vec3 p){\n    float mindist1 = 10000.;\n    float mindist2 = mindist1;\n    float mindist3 = mindist1;\n    for(float i = 0.; i<num_points; i++){\n        vec3 pp = calcPointSpot3D(i);\n        float d = length(p-pp);\n        if(d<mindist1){\n            mindist3 = mindist2;\n            mindist2 = mindist1;\n            mindist1 = d;\n        }\n    }\n    return vec3(mindist1, mindist2, mindist3);\n}\nvec4 SDF (vec3 p){\n    vec3 matCol = vec3(0.);\n    float total = 0.;\n    vec3 pp = calcNearestPoint3D(p);\n    //pp = normalize(pp);\n    //total = dot(pp, vec3(1.))*0.1;\n    total = pow(abs(pp.x-pp.z), 2.);\n    total*= 0.1;\n    return vec4(total, matCol);\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<256; i++){\n        p = o+r*t;\n        float d = SDF(p).x;\n        t+=d*0.3;\n        if(d<0.001){\n            break;\n        }\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)).x - SDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        SDF(vec3(p.x, p.y + EPSILON, p.z)).x - SDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)).x - SDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //setup coordinates\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.2);\n    mouse.x*=5.;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    // Time varying pixel color\n    //vec2 v = calcNearestPoint2D(uv);\n    //float d = abs(v.x-v.y);//dot(normalize(v), vec2(1.))*0.015;\n    //col = vec3((d-0.02)*1000000.);\n    //setup camera + rays\n    float angle = mouse.x;\n    float fov = 0.9;\n    float camDist = 1.;\n    vec3 camera = vec3(cos(mouse.x)*camDist, 0., sin(mouse.x)*camDist);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    ray = normalize(ray);\n    mouse.y-=0.5;\n    mouse.y*=-2.5;\n    camera = vec3(rotate2D(camera.xy, mouse.y), camera.z);\n    ray = vec3(rotate2D(ray.xy, mouse.y), ray.z);\n    \n\tvec4 v = trace(camera, ray);\n    col = tex(v.xyz, iChannel0);\n    vec3 normal = estimateNormal(v.xyz);\n    col += vec3(dot(normal, -ray)*0.2);\n    col *= 1./(1.+pow(v.w*2., 2.)*0.01);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}