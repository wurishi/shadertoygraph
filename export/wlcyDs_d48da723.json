{"ver":"0.1","info":{"id":"wlcyDs","date":"1610223016","viewed":162,"name":"Vinyl in the pool","username":"luckyballa","description":"fake shadows test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","light","shadows","vinyl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rand2D(vec2 n){\n    return fract(sin(vec2(dot(n, vec2(12.9898, 4.1414)))));\n}\n\nfloat voronoi2D(vec2 n, float time){\n    float dis = 0.9;\n    for(float y = 0.0; y <= 1.0; y++){\n        for(float x = 0.0; x <= 1.0; x++){\n            vec2 p = floor(n) + vec2(x, y);\n            float d = length((0.27 * sin(rand2D(p) * 24. + time * 2.0)) + vec2(x, y) - fract(n));\n            dis = min(dis, d);\n            }\n        }\n    return dis;\n}\n\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid) {\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\nvec2 rotate(vec2 v, float angle) {\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec3 shade(vec2 uv, float obj, float size, float offset, float time) {\n    vec3  col = vec3(0.,.5,.5);\n    vec2 lightPos = vec2(-offset,  offset);\n    lightPos = rotate(lightPos, time  + 0.4);\n    \n    float dst = length(uv) - obj;\n    col *= step(0., dst);\n    col += 1.-smoothstep(0.,size,distance(uv,lightPos));\n    \n    return col;\n    \n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *=  iResolution.x/iResolution.y;\n    uv *=1.7;\n    \n    float zooom = (1. + cos(iTime / 3.) / 10.);\n    vec2 ruv = uv *  zooom;\n    uv.y += sin(iTime / 2.) / 10.;\n    uv = rotateUV(ruv, sin(iTime / -4.), vec2(0.));\n     \n    float v = smoothstep(0.409, 0.41, length(ruv));\n    v = 1. - v;\n    float vCenter = smoothstep(0.2, 0.199, length(ruv));\n    float vSmallCenter = smoothstep(0.03, 0.031, length(ruv));\n    vec3 vCenterC = vCenter * vec3(0.25);\n    v -= (1. - v * sin(length(ruv) *800.)) * 0.04 * (1. - vCenter);\n\n    float vN = clamp((pow(voronoi2D(uv * 3., iTime / 4.), 2.)) + 0.25, 0.0, 1.0);\n    float fbmNoise = noise(uv * 20. + sin(length(uv) * 20. + iTime));\n\n    vec3 orange = vec3(1., 0.31, 3.);\n    vec3 blue = vec3(0.535, 0.38, 0.903);\n    vec3 lightBlue = vec3(0.46, 0.71, 0.87);\n    vec3 vC = blue;\n\n    vC = mix(vC, lightBlue, smoothstep(0.1, 0.9,  fbmNoise));\n    vC = mix(vC, orange,  smoothstep(0.6, 0.9, fbmNoise));\n    vC *= max(v, .0);\n    vC = (vec3(0., 0.5, 2.0) * vN * (v / 2. + 0.4) * vC + vC);\n    \n    vec3 bC = (lightBlue * 2.2) + vec3(0., 0.1, 0.2); \n    bC = mix(bC, blue * 1.6 + lightBlue * 0.5, smoothstep(0.0, 2., (uv.x + 0.5) * length(uv)));\n    bC *= vec3(1.2, 1.3, 1.4);\n \n    vec3 sparkles = vec3(smoothstep(0.5, 0.9, length(fract(uv*(12.)+vN+.5) -.5))) * 0.5 * max(mod(iTime / 2. + uv*(2.)+vN, 0.5382).x, 0.3);// * 0.2\n    vec2 grid = smoothstep(0., 0.01, mod(uv + vec2(0.003), 0.2));\n    float gridC = (min(grid.y, grid.x)) * 0.1;\n    \n    vec3 col = mix(vC * v + sparkles * v + gridC * .1 * v, vCenterC,  vCenter);\n     \n    vec3 r = col * 1.2 * v\n    + ((bC + gridC * 2. + vC * 0.3 ) * ((1. - v) + ((1. - vSmallCenter) * 1.5) * gridC)) * 0.35; \n    \n    r -= shade(ruv, v, .7, 0.3, iTime) * 0.2 * (1. - v);\n    r += shade(ruv, v, .3, 0.25, iTime) * 0.25 * v;\n    \n    float water = smoothstep(0.4, 0.9, length(uv)) * vN * 0.2;\n    r += vec3(water, water, water * 0.8);\n    r += vec3(smoothstep(0.55, 0.9, length(fract(uv*(2.)+vN+.5 + sin(iTime / 2.)) -.5))  ) * 0.2  * (1. - v) * vN; \n    r *= (smoothstep(4., 0.5, length(uv)));\n\n    fragColor = vec4(r, 1.0);\n}","name":"Image","description":"","type":"image"}]}