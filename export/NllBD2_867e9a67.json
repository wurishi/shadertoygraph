{"ver":"0.1","info":{"id":"NllBD2","date":"1651513402","viewed":180,"name":"Reaction Diffusion  on Torus","username":"Amirk","description":"Reaction diffusion process living on transparent glowing torus. \nRotate with mouse.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["torus","texture","diffusion","raymach","reaction"],"hasliked":0,"parentid":"slfBz2","parentname":"Game of TorusLife "},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 100.\n#define MAX_DIST 10.\n#define SURF 0.01\n#define PI 3.1416\n\nvec3 col; \nfloat time=0.;\n\nmat2 Rot(float a){\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\n\nfloat asin2(vec3 p, float r1, float r2){\n\n        float toroidal = asin(p.y/r2);\n        return length(p.xz)> r1 ? toroidal\n                                : sign(p.y)*PI-toroidal;\n}\n\nvec2 toroidalCoordinates(vec3 p, float r1, float r2){\n        float toroidal = asin2(p,r1,r2);\n        \n        float poloidal= atan(p.x,p.z);\n        \n        //to range 0,1:\n        return (vec2(poloidal, toroidal)+PI)/(2.*PI);       \n}\n\n\n//standard raymarch torus:\nfloat sdTorus(vec3 p, float r1,float r2){\nfloat dxz= length(p.xz)-r1;\n\nreturn length(vec2(dxz,p.y))-r2;\n}\n\n\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    \n    return normalize( i-ro);\n}\n\n//preliminary distance function is for unbumped torus:\nfloat TorusDist(vec3 p){\n\n    float td= sdTorus(p, 2.,1.); \n    \n     return td;\n}\n\n\nvec3 getNormal(vec3 p){\n  vec2 e= vec2(0.001,0);\n   float d=TorusDist(p);\n   vec3 n = d-vec3(TorusDist(p- e.xyy),TorusDist(p- e.yxy),TorusDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\n\nfloat getDist(vec3 p){\n    //first distance to unbumped torus:\n    float dist =TorusDist(p);\n    vec3 n= getNormal(p);\n    //take the closest point in unbumped torus:\n    vec3 closest =p-dist*n;\n    //pick bump texture from the original torus.\n    vec2 Tuv=toroidalCoordinates(closest,2.,1.);\n\n    float displacement= texture(iChannel1, Tuv).r;//*smoothstep(1.,.99,abs(closest.y));\n    dist-=displacement*.07;\n     \n     //conservative stepsize:\n     dist*=.3;\n    \n     return dist;\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd, float inside){\nfloat dO=0.;\nfloat i=0.;\nwhile(i<MAX_ITER){\n  vec3 p= ro+dO*rd;\n\n  float dS=inside*getDist(p);\n\n  dO+=dS;\n  \n  if(dO>MAX_DIST||dS<SURF) break;\n  \n  i++;\n}\n\nfloat halo= pow(2.*i/MAX_ITER,2.);\ncol+=vec3(halo)*vec3(0.4,0.2,1);\n\nreturn dO;\n\n}\n\n\n/*\nvec3 getLight(vec3 p, vec3 lightPos){\n\nlightPos.xz+=2.*vec2(cos(iTime),sin(iTime));\nvec3 l= normalize(vec3(1,2,3));\nvec3 n= getNormal(p);\n\nfloat dif=0.;\n\ndif =dot(l, n)*.5+.5;\n\nreturn dif*n*.5+.5;\n}\n*/\n\nvoid normalColoring(vec3 p){\n          vec3 n= getNormal(p);\n\n          n=abs(n);\n          n*=pow(n,vec3(5));\n          n=normalize(n);\n          col*=.5+n*.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy)/iResolution.xy;\n    col =vec3(0);\n\n    \n    //camera: \n    float zoom= smoothstep(-1.,3.,iTime);\n\n    vec3 ro= vec3(2,2,-5);\n    ro.xy*=Rot(PI/2.);\n\n    ro.yz*=Rot(m.y*PI);\n    ro.xz*=Rot(-m.x*PI);\n    \n    vec3 lookAt=vec3(0,0,0);\n    vec3 rd= getRayDir(uv, ro, lookAt,zoom);\n    \n    //begin the raymarch:\n    float d= RayMarch(ro,rd,1.);\n\n      if(d<MAX_DIST){//if we hit the object:\n       \n          vec3 p= ro+ d*rd;\n          vec3 n= getNormal(p);\n          //we get get texture from the original torus.\n          float torusd= TorusDist(p);\n          float dif= dot(n, normalize(vec3(1,2,3)))*.5+.75;\n         \n         vec2 Tuv=toroidalCoordinates(p-torusd*n,2.,1.); \n         \n         vec4 GOL =texture(iChannel1,Tuv);\n\n         //if(GOL.b<.9){\n         d= RayMarch(p-12.*SURF*n, rd,-1.);\n         \n         p=p+d*rd;\n         n= getNormal(p);\n         torusd= TorusDist(p);\n         Tuv=toroidalCoordinates(p-torusd*n,2.,1.); \n         GOL =mix(GOL,texture(iChannel1,Tuv),1.-GOL.a);  \n        // }\n\n         col=mix(col,GOL.rgb,GOL.a*.5);\n         \n         col*=dif;\n\n       }\n    \n\n    fragColor = vec4(col,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define dt 1.\n\nfloat A;\nfloat B;\nfloat DA = 1.0; // constants\nfloat DB = 0.4;\n\nvec2 lapl(ivec2 p){\n  ivec2 r = ivec2(textureSize(iChannel1, 0));\n  vec2 next=-vec2(A,B);\n\n  for(int y=-1;y<=1;y++ ){\n     for(int x=-1;x<=1;x++ ){\n        if(x==0&&y==0)continue;\n        else if(x==0||y==0){\n            ivec2 pp=p+ivec2(x,y);\n            pp = (pp+r) % r;\n          \n            next+=.2*texelFetch(iChannel1, pp,0).rb;\n        }else {\n            ivec2 pp=p+ivec2(x,y);\n            pp = (pp+r) % r;\n            next+=.05*texelFetch(iChannel1, pp,0).rb;\n        }\n     }\n  }\n  return next;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0);\n    if(iFrame<10){\n    //red is for substance A. blue is for subtance B \n        //A:\n        col.r=1.;\n        //B:\n        float d= min(min(min(length(uv-.1),length(uv-.3)),length(uv-.5)),length(uv-.9));\n        col.b=smoothstep(.08,.0,d); \n\n    } \n    else{\n      A=texelFetch(iChannel1, ivec2(fragCoord),0).r;\n      B=texelFetch(iChannel1, ivec2(fragCoord),0).b;\n      \n      float h =.2;//+.2*sin(iTime)*sin(iTime);\n      float f = 0.02 * h + (1. - h) * 0.018;\n      float k = 0.035 * h + (1. - h) * 0.051;\n    \n      float nextA = A+(DA*lapl(ivec2(fragCoord)).x-A*B*B+f*(1.-A))*dt;\n      float nextB = B+(DB*lapl(ivec2(fragCoord)).y+A*B*B-(k+f)*B)*dt;\n     \n      col.rb=vec2(nextA,nextB);\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col=vec3(0);\n\n    col.rb = vec2(texture(iChannel0,uv).b)*4.;\n\n    // Output to screen\n    fragColor = vec4(col,col.b);\n}","name":"Buffer B","description":"","type":"buffer"}]}