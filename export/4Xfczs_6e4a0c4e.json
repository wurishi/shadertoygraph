{"ver":"0.1","info":{"id":"4Xfczs","date":"1726536424","viewed":27,"name":" 2dRT phase space exhibition","username":"saezhe","description":"2d regular temperament phase space\n\nThis graphic highlights which combinations of unit intervals result in rank 2 temperaments that approximate notes in a target scale using low integer combinations of the intervals.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["xenharmonics"],"hasliked":0,"parentid":"4fSBR3","parentname":"regular temperament phase space"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inputs arithmetic ratios\nfloat centserror(float a, float b) {\n    return 1200.0*(log2(b)-log2(a));\n}\n// inputs cents, subtracts them\nfloat trivialcentserror(float a, float b) {\n    return b-a;\n}\n\n//inputs arithmetic ratio, while mapping {1,2} to 2\nfloat octaveReduce(float a) {\n    return pow(2.,1.-mod(-log2(a),1.));\n}\n\n#define OPT_CENTS_LIM 10.\nfloat errToIntensity(float cents) {\n    return 1./(1.+cents/OPT_CENTS_LIM);\n}\n\nfloat isometricDist(vec2 inp) {\n    return sqrt(pow(inp.x+inp.y/2.,2.)+pow(inp.y*sqrt(3.)/2.,2.));\n}\n\nfloat cartesianDist(vec2 inp) {\n    return sqrt(pow(inp.x,2.)+pow(inp.y,2.));\n}\n\nfloat fitness(vec3 inp) { // format: (distance, error, importance)\n    //return errToIntensity(inp.y); // just return error's intensity\n    return errToIntensity(inp.y)/(inp.x+1.)*inp.z; // alternative\n}\n\n// function source: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define RAW_SCALE_SIZE 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // finding bearings and reference points for positioning the frame with respect to the screen resolution\n    float displaySquareSize = min(iResolution.x,iResolution.y);\n    vec2 displaySquarePixelsOffset = (iResolution.xy-vec2(displaySquareSize,displaySquareSize))/2.0;\n    // the bottom left here will actually be the bottom left of the center-square area on screen.\n    \n    // pan/zoom display settings\n    float it = iTime+2330.;\n   \n    vec2 bottomLeftRep = vec2(00.,0.);\n    float squareSizeRep = 4.0+1196.0*pow(cos(it/47.465-3.3),4.);\n    \n    // sway-panning automatically:\n    //2330\n    bottomLeftRep = vec2(0.,0)+vec2((1200.-squareSizeRep)*(sin(it/50.0+2.)*.5+.5),(1200.-squareSizeRep)*(cos(it/82.472)*.5+.5));\n    \n    // pan from 600cents being in the middle\n    //vec2 pan = bottomleftrep+squaresizerep/2.0-vec2(600.0,600.0);\n    //float zoom = 1200.0/squaresizerep;\n    \n    // alternate settings order:\n    //vec2 pan = (0.0,0.0);\n    //float zoom = 1.0;\n    //vec2 bottomleftrep = vec2(600.0,600.0)-vec2(600.0,600.0)/zoom+pan;\n    //float squaresizerep = 1200.0/zoom;\n    \n    // other helpful values\n    //vec2 toprightrep = bottomleftrep+squaresizerep\n    //vec2 midpointrep = bottomleftrep+squaresizerep/2.0\n    \n    // calculation of local coordinates\n    \n    // local coordinates with the middle square being from 0 to 1\n    vec2 frag = (fragCoord-displaySquarePixelsOffset)/displaySquareSize;\n    // zoomed and panned interval cent-size coords\n    vec2 cents = bottomLeftRep+frag*squareSizeRep;\n    // arithmetic to vents fudger\n    cents = 1200.*log2(cents/1200.+1.);\n    \n    //float centsTotal = centscartesian.x+centscartesian.y;\n    // vec2 arith = vec2(pow(2.0,(cents.x/1200.0)),pow(2.0,(cents.y/1200.0)));\n    \n    // target scale setup (ALL THIS CAN BE PREPROCESSED.. DO YOU KNOW HOW TO DO THIS? DOES IT DO IT AUTOMATICALLY WHEN COMPILING?)\n    float targetScaleRaw[RAW_SCALE_SIZE] = float[RAW_SCALE_SIZE]\n        (9.0,10.,11.,12.,13.,14.,15.,16.);\n    float targetScaleImportance[RAW_SCALE_SIZE] = float[RAW_SCALE_SIZE]\n        //(0.4,0.5,0.4,0.8,0.4,0.5,0.4,1.0);\n        (1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0);\n    // octave reduced version\n    float targetScale[RAW_SCALE_SIZE];\n    for (int i = 0; i<RAW_SCALE_SIZE; i++) {\n        targetScale[i]=octaveReduce(targetScaleRaw[i]);\n    }\n    // remove any duplicates\n    int uniqueScaleDegrees = 0;\n    for (int i = 0; i<RAW_SCALE_SIZE; i++) {\n        // check for duplicates\n        // if duplicate, then uniqueScaleDegrees does not increment\n        bool dup = false;\n        for (int j = 0;j<uniqueScaleDegrees;j++) {\n            if (targetScale[i]==targetScale[j]) {\n                dup == true;\n                break; //do nothing but increment i\n            }\n        }\n        if (!dup) { // every time there's a new unique, the number variable is incremented\n            targetScale[uniqueScaleDegrees]=targetScale[i];\n            uniqueScaleDegrees++;\n            //int dups = RAW_SCALE_SIZE-uniqueScaleDegrees;\n            \n        }\n        \n    }\n    // cents values for ease\n    float targetScaleCents[RAW_SCALE_SIZE];\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        targetScaleCents[i]=1200.*log2(targetScale[i]);\n    }\n    // setup of possible linear combinations lattice\n    \n    float n = 8.; // max radius lattice points are from origin (in isometric space)\n    int N = int(ceil(n*sqrt(3.)/2.)); // radius of diamond lattice to generate to get all points within isometric radius\n    // actual size of full lattice is 1+2*N\n    \n    /* alternate precise hexagonal lattice (not persuing this method rn)\n    // hexagonally layed out lattice of interval-multipliers\n    int N = 8; // max reach along one axis the hexagon extends\n    // number of points in the lattice\n    int latticePointsN = 3*n*(n+1)+1;\n    */\n    \n    // actual rendering\n    \n    // loop through all lattice combinations, picking which ones are the smallest error and closest distance.\n    // a fitness function is needed to determine a pick's fitness depending on its distance and its error, and how important the scale degree is to approximate.\n    \n    // greatest fitness lattice point for each scale degree,\n    vec2 winpoint[RAW_SCALE_SIZE];\n    // along with its distance, error, and score\n    vec3 winmetrics[RAW_SCALE_SIZE]; // format: (distance, error, score)\n    // or, an accumulated score list for each scale degree, across all lattice points.\n    float accum[RAW_SCALE_SIZE]; // there will be a sum of all individual items in this list at the end, too.\n    // for suspicion\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        accum[i]=0.;\n    }\n    int masterN=0; // normalizing factor\n    // loop through potential lattice points\n    for (int i=-N;i<=N;i++) {\n        for (int j=-N;j<=N;j++) {\n            // immediately reject lattice points too far away isometrically\n            float dist = isometricDist(vec2(float(i),float(j)));\n            if (dist>float(n)) {\n                continue;\n            }\n            float pointCents = cents.x*float(i)+cents.y*float(j);\n            // loop through each scale degree\n            for (int k=0;k<uniqueScaleDegrees;k++) {\n                float signedErr = pointCents-targetScaleCents[k];\n                float err = abs(signedErr);\n                float fit = fitness(vec3(dist,err,targetScaleImportance[k]));\n                // check and update best fitness parallel arrays\n                if (fit>winmetrics[k].z) {\n                    winpoint[k].x=float(i); // lattice x\n                    winpoint[k].y=float(j); // lattice y\n                    winmetrics[k].x=dist; // distance\n                    winmetrics[k].y=err; // error\n                    winmetrics[k].z=fit; // score\n                }\n                // update accumulator for pointscaledegree\n                accum[k]+=fit;\n                masterN+=1;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0.,0.,0.);\n    \n    // render pipelines\n    \n    // grand total of partial sums of scores from each lattice possibility\n    /*\n    float totalaccum = 0.;\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        totalaccum+=accum[i];\n    }\n    totalaccum /= float(masterN);\n    totalaccum *= 600.;\n    totalaccum -= 1.3;\n    col = vec3(totalaccum,totalaccum,totalaccum);\n    /**/\n    \n    // sum of colored best scores\n    /*col = vec3(0.,0.,0.);\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        //vec3 tempcol=hsv2rgb(vec3(targetScaleCents[i]/1200.-1./6.,1.,1.) );\n        vec3 tempcol=hsv2rgb(vec3(targetScale[i]-1./6.,1.,1.) );\n        col += tempcol*winmetrics[i].z;\n    }*/\n    \n    // sum of inverted error (from 10 cents)\n    //*\n    col = vec3(0.,0.,0.);\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        //vec3 tempcol=hsv2rgb(vec3(targetScaleCents[i]/1200.-1./6.,1.,1.) );\n        vec3 tempcol=hsv2rgb(vec3(targetScale[i]-1./6.,1.,1.) );\n        col += tempcol*max(0.,(10.-winmetrics[i].y)/20.);\n    }\n    //*/\n    vec3 tcol = col;\n    // maximum of min error, colored by interval\n    //*\n    col = vec3(0.,0.,0.);\n    float maxe = 0.;\n    float colmax = 0.;\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        //vec3 tempcol=hsv2rgb(vec3(targetScaleCents[i]/1200.-1./6.,1.,1.) );\n        if (winmetrics[i].y>maxe) {\n            maxe=winmetrics[i].y;\n            vec3 tempcol=hsv2rgb(vec3(targetScale[i]-1./6.,1.,1.) );\n            //tempcol = vec3(1.,1.,1.);\n            colmax=1./(1.+max(((1./winmetrics[i].z-1.)-10.)/20.,0.));\n            col = tempcol*colmax;\n        }\n    }\n    //*/\n    \n    // minimum of min error, colored by interval\n    //*\n    col = vec3(0.,0.,0.);\n    float mine = 1200.;\n    float colmin = 0.;\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        //vec3 tempcol=hsv2rgb(vec3(targetScaleCents[i]/1200.-1./6.,1.,1.) );\n        if (winmetrics[i].y<mine) {\n            mine=winmetrics[i].y;\n            vec3 tempcol=hsv2rgb(vec3(targetScale[i]-1./6.,1.,1.) );\n            //tempcol = vec3(1.,1.,1.);\n            colmin=1./(1.+max((1./winmetrics[i].z-1.)/5.,0.));\n            col = tempcol*colmin;\n        }\n    }\n    //*/\n    \n    // min on r, max on g, and sum of best scores is b\n    // (needs two comment blocks above also decommented)\n    //*\n    col = vec3(colmin,colmax,0.);\n    for (int i=0;i<uniqueScaleDegrees;i++) {\n        col.z += winmetrics[i].z*1.;\n    }\n    //*/\n    \n    col *= .7;\n    col += tcol*.3;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}