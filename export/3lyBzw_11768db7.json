{"ver":"0.1","info":{"id":"3lyBzw","date":"1614035034","viewed":55,"name":"Shader projet GOPL 2021","username":"tselmek","description":"Shader pour le projet de Graphisme par Ordinateur 2021 à TELECOM Nancy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","colors","graphisme"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FARAWAY = 1e30;\nconst float EPSILON = 1e-6;\nconst float PI = 3.1415926535;\n\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\nconst vec3 one3  = vec3(1.0, 1.0, 1.0);\n\nstruct Camera {\n    vec3 position;\n    vec3 view;\n    vec3 up;\n    vec3 horizon;\n    float height;\n    float width;\n    float z;\n};\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n    vec3 Kr; // reflective material\n};\n\n\nstruct Ball {\n    Sphere sphere;\n    Material material;\n};\n\n\n\nCamera camera(in vec3 position, in vec3 target, in float aperture) {\n    Camera C;\n    C.position  = position;\n    C.view      = normalize(target - position);\n    C.horizon   = normalize(cross(vec3(0.0, 0.0, 1.0), C.view));\n    C.up        = cross(C.view, C.horizon);\n    C.width     = float(iResolution.x);\n    C.height    = float(iResolution.y);\n    C.z         = (C.height/2.0) / tan((aperture * PI / 180.0) / 2.0);\n    return C;\n}\n\n\nRay launch(in Camera C, in vec2 pixel) {\n    return Ray(\n        C.position,\n        C.z * C.view + (pixel.x - C.width / 2.0) * C.horizon + (pixel.y - C.height / 2.0) * C.up \n    );\n}\n\n\nMaterial diffuse(in vec3 Kd) {\n    return Material(Kd, zero3, zero3);\n}\n\n\nMaterial light(in vec3 Ke) {\n    return Material(zero3, Ke, zero3);\n}\n\n\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n    return Material(Kd, zero3, Kr);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nBall SCENE[40];\n\n\nvoid init_scene() {\n    float beta = float(iFrame)/30.0;\n    float s = sin(beta);\n    float c = cos(beta);\n    int k = 0;\n    \n    // Initialisation des sphères\n    for (float x = -1.0; x < 2.0; x = x + 1.0) {\n        for (float y = -1.0; y < 2.0; y = y + 1.0) {\n            for (float z = -1.0; z < 2.0; z = z + 1.0) {\n                SCENE[k++] = Ball(\n                    Sphere(\n                        /* Position */ vec3(x, y, z),\n                        /* Rayon    */ 0.5\n                    ),\n                    /* Couleur */ diffuse(vec3(0.5*(x+1.0), 0.5*(y+1.0), 0.5*(z+1.0)))\n                );\n            }\n        }\n    }\n\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(0.0, 0.0, -500.0),\n            /* Rayon    */ 495.0\n        ),\n        /* Couleur */ diffuse(vec3(0.5))\n    );\n\n    \n    float alpha = 0.0;\n    for (int K = 0; K < 8; K++) {\n        alpha = float(K) * PI / 4.0;\n        SCENE[k++] = Ball(\n            Sphere(\n                /* Position */ vec3(-5.0 * cos(beta + alpha), 5.0 * sin(beta + alpha), 3.0 * sin(beta + alpha) * cos(alpha + beta)),\n                /* Rayon    */ 0.6\n            ),\n            /* Couleur */ diffuse(hsv2rgb(vec3(float(K)/8.0, 1.0, 1.0)))\n        );\n    }\n\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(6.0 * cos(beta/1.5), 6.0 * sin(beta/1.5), 9.0),\n            /* Rayon    */ 3.0\n        ),\n        /* Couleur */ light(one3)\n    );\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(-6.0 * cos(beta), 6.0 * sin(beta), 7.0),\n            /* Rayon    */ 2.0\n        ),\n        /* Couleur */ light(hsv2rgb(vec3(0.5 + 0.5*cos(beta/2.0), 0.5, 1.0)))\n    );\n\n    SCENE[k++] = Ball(\n        Sphere(\n            /* Position */ vec3(0.0, 0.0, 2.0),\n            /* Rayon    */ 1.0\n        ),\n        /* Couleur */ mirror(one3, one3)\n    );\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    vec3 CO = R.origin - S.center;\n    float a = dot(R.dir, R.dir);\n    float b = 2.0*dot(R.dir, CO);\n    float c = dot(CO, CO) - S.radius * S.radius;\n    float delta = b*b - 4.0*a*c;\n    if(delta < 0.0) {\n        return false;\n    }\n    t = (-b-sqrt(delta)) / (2.0*a);\n    return true;\n}\n\nRay reflect_vector(in Ray I, in vec3 P, in vec3 N) {\n    return Ray(\n        P,\n        -2.0 * dot(N, I.dir) * N + I.dir\n    );\n}\n\nbool shadow(in Ray R) {\n    for(int i = 0; i < SCENE.length(); ++i) {\n        float t;\n        if (\n            SCENE[i].material.Ke == vec3(0.0, 0.0, 0.0)\n            && intersect_sphere(R, SCENE[i].sphere, t)\n            && t > EPSILON\n            && t < 1.0\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n    if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n        return material.Ke;\n    }  \n\n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    for(int i = 0; i < SCENE.length(); ++i) {\n        if(SCENE[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n            Ray R2 = Ray(P, SCENE[i].sphere.center);\n            if (!shadow(R2)) {\n                vec3 E = SCENE[i].sphere.center - P;\n                float lamb = max(0.0, dot(E,N) / length(E));\n                result += lamb * material.Kd * SCENE[i].material.Ke;\n            }\n        }\n    }\n\n    return result;\n}\n\nbool nearest_intersection(\n    in Ray R, \n    out vec3 P, out vec3 N, out Material material\n) {\n    float t = FARAWAY;\n\n    for(int i = 0; i < SCENE.length(); ++i) {\n        float cur_t;\n        if (\n            intersect_sphere(R, SCENE[i].sphere, cur_t) \n            && cur_t < t\n            && cur_t > EPSILON\n        ) {\n            t = cur_t;\n            P = R.origin + t*R.dir;\n            N = normalize(P - SCENE[i].sphere.center);\n            material = SCENE[i].material;\n        } \n    }\n    return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    init_scene();\n\n    float banane = float(iFrame);\n\n    Camera C = camera(\n        /* position */ vec3(4.0 * cos(banane/60.0), 10.0 * sin(banane/60.0), 3.0),\n        /* target   */ vec3(0.0, 0.0, 0.0),\n        /* aperture */ 70.0\n    );\n    Ray R = launch(C, fragCoord);\n\n\n    fragColor = vec4(0.15, 0.15, 0.20, 1.0);\n\n\n    vec3 P;  // Point courant\n    vec3 N;  // Normale\n    Material material; // Couleur\n\n    if(nearest_intersection(R, P, N, material)) {\n        fragColor.rgb = lighting(P, N, material);\n        if(material.Kr != zero3) {\n            vec3 Kr = material.Kr;\n            R = reflect_vector(R, P, N);   \n            if(nearest_intersection(R, P, N, material)) {\n                fragColor.rgb = \n                    Kr*lighting(P,N,material);\n            } else {\n                fragColor = vec4(0.30, 0.30, 0.40, 1.0);\n            }\n\n        }\n    } \n\n}","name":"Image","description":"","type":"image"}]}