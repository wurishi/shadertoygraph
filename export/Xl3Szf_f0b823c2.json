{"ver":"0.1","info":{"id":"Xl3Szf","date":"1481020557","viewed":216,"name":"Mayu Puma - All I Ever Need VIZU","username":"ttoinou","description":"Live shader from youtube video : https://www.youtube.com/watch?v=5XBjamy41lc \nCover by Mayu Puma : https://soundcloud.com/mayupuma/all-i-ever-need\nOriginal song from Caribou (Our Love album)","likes":9,"published":1,"flags":96,"usePreview":0,"tags":["music","clip","track","lissajou","vizu","musicclip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdS3DW","filepath":"https://soundcloud.com/mayupuma/all-i-ever-need","previewfilepath":"https://soundcloud.com/mayupuma/all-i-ever-need","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/XtVGDz\n\n#define buffer iChannel0\n#define sound  iChannel1\n#define soundRes iChannelResolution[1]\n#define step 1.0/iResolution.y\n#define inputSound iChannel0\n#define fftWidth \t\t1.0\t\t\n#define fftMinBass \t\t0.00196 \t// 1.0/512.0\n\n#define render 0\n\n// fft Options\n#if render\n\n#define fftSmoothTime   0.08\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.65\t\t    // final gain\n#define noiseLevel      0.1\n#define fftTrebles\t\t2.5\n#define fftBass\t\t\t1.0\n\n#else\n\n#define fftSmoothTime   .7\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.6\t\t\t// final gain\n#define noiseLevel      0.05\n#define fftTrebles\t\t3.0\n#define fftBass\t\t\t1.6\n\n#endif\n\n#define fftRadiusR\t\t8.0/512.0\n#define fftRadiusG\t\tfftRadiusR*4.0\n#define fftRadiusB\t\tfftRadiusR*4.0*4.0\n#define fftSamplesR \t8 // number of iteration for fft sampling, increases quality !\n#define fftSamplesG \tfftSamplesR*4\n#define fftSamplesB \tfftSamplesR*4*4\n#define fftGBGain       1.1\n\n#define to01(x) clamp(x,0.0,1.0)\n\nfloat remapIntensity(float f, float i){\n  //return i;\n  // noise level\n  i = to01( (i - noiseLevel) / (1.0 - noiseLevel) );\n  float k = f-1.0;\n  i *= ( fftTrebles - fftBass*k*k ) * fftPreamp;\n  // more dynamic\n  i *= (i+fftBoost);\n    \n  return i*fftAmp;\n  // limiter, kills dynamic when too loud\n  //return 1.0 - 1.0 / ( i*4.0 + 1.0 );\n}\n\nfloat remapFreq(float freq){\n // linear scale\n //return clamp(freq,fftMinBass,1.0);\n // log scale\n return clamp(to01(- log(1.0-freq/1.65 + fftMinBass)),fftMinBass,1.0);\n}\n\nfloat fftR(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesR ; i++ ){\n        k = float(i)/float(fftSamplesR-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusR)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum);\n}\n\nfloat fftG(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesG ; i++ ){\n        k = float(i)/float(fftSamplesG-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusG)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain;\n}\n\nfloat fftB(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesB ; i++ ){\n        k = float(i)/float(fftSamplesB-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusB)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain*fftGBGain;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n   \t// black by default\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n     // iFrame == 0 => Reset\n    if( iFrame != 0 ){\n        // store current fft\n        if( fragCoord.y <= 1.0 ){\n            \n            float freq = uv.x;\n            float i1,i2,i3;\n\n            i1 = fftR(freq);\n            i2 = fftG(freq);\n            i3 = fftB(freq);\n\t\n            fragColor.rgb = vec3(i1,i2,i3);\n            fragColor.rgb = mix(texture(buffer,vec2(uv.x,uv.y - step)).rgb,fragColor.rgb,fftSmoothTime);\n\n            #if render\n            //vec3 mean = mix(fragColor.rgb,texture(buffer,vec2(uv.x,uv.y - step)).rgb,fftSmoothTime);\n            \n            /*if( length(mean) > length(fragColor.rgb) ){\n               fragColor.rgb = mean.rgb; \n            }\n            */\n            //fragColor.rgb = max(fragColor.rgb,mean.rgb);\n            #endif\n            //fragColor.rgb = vec3(0.0);\n            fragColor.a = texture(sound,vec2(freq,1.0)).x;\n            \n        // store previous fft\n        } else if( fragCoord.y < iResolution.y - 1.0 ) {\n            fragColor=texture(buffer,vec2(uv.x,uv.y - step));\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define dx (iMouse.x/iResolution.x)\n#define dy (iMouse.y/iResolution.y)\n#define TWOPI (6.28318530718)\n\n#define soundStep 1.0/iChannelResolution[0].y //1.0/512.0\n#define sound iChannel0\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// https://www.shadertoy.com/view/XtVGDz \n\nvec3 fft(float freq,float time){\n    return texture(sound,vec2(mod(freq,1.),time)).rgb\n        *smoothstep( 0. , 1. , 1. - (iTime - 299.75 - 16.)/.75 );\n}\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n\n// <https://www.shadertoy.com/view/ltXSDB modified=\"true\">\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// </https://www.shadertoy.com/view/ltXSDB>\n\n#define pixelsize (1./max(iResolution.x,iResolution.y))\n\nvec4 mixDist(vec4 distCoeff,\n                  float thickness,\n                  float spread,\n                  vec4  color){\n    float r = max(distCoeff.x - thickness,0.)/(abs(spread)+0.00001);\n    return exp(-(r*r)/2.) * color * color.a;// mix(color1*color1.a,color2*color2.a,distCoeff.y);\n}\n\n\nfloat repeat(float x,float y){\n    x = mod(x,2.0*y);\n    if( x > y ){\n        x = 2.0*y - x;\n    }\n    return x;\n    //return mod(x+y,y);\n}\n\nconst float width = 1.1;\n\nvec2 viewport(vec2 p){\n    return vec2( (2.*p.x - iResolution.x)/ iResolution.y,\n                  2.*p.y                 / iResolution.y - 1.)*width;\n}\n\nvec2 polar(float radius,float angle){\n    return radius*vec2(cos(angle),sin(angle));\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    float minpts = 140.;\n    const int maxpts = 390;\n    \n    float milieu = clamp( (iTime-120.)/20. , 0. , 1. );\n    milieu *= clamp( 1. - (iTime-200.)/10. , 0. , 1. );\n    vec2 uv_ = fragCoord/iResolution.xy;\n    \n   \tfloat time = clamp(iTime/300.,0.,1.);\n    float intense = clamp( (iTime-190.)/38. , 0. , 1. );\n    \n\tvec2 uv =\n        mix( viewport(fragCoord),\n            viewport(fragCoord)*3.5*abs(1. - fft( min(uv_.x,1.-uv_.x) ,0.0).b*(1.3+intense*.4) ),\n            milieu );\n    \n\t//vec2 uv = viewport(fragCoord)*6.*abs(1. - fft(uv_.x,0.0).b );\n\t//vec2 uv = viewport(fragCoord);\n    float ending4 = step( 295.5+16. , iTime );\n    float ending1 = ( (iTime-210.-16.)/20. )*(1. - ending4 );\n    float ending2 = (iTime-215.-16.)/50.;\n    \n    uv *= 4.5*abs(1. - clamp (\n        fft(0.1,0.0)+fft(0.05,0.0)\n        , 0.\n        , mix(1.1,.9,ending1) \n      ).b*mix(.5,1.,time+ending4*1.2-intense*.1) );\n\n\n\to = vec4(0.0,0.0,0.0,0.0);\n    \n    \n    vec3 p1,p2,p3;\n    vec4 P;\n    float r;\n    float rexp;\n    vec4 c;\n    float di;\n    float len = 0.0;\n    \n    float calme = clamp( 1. - abs( iTime - 231. ) / 10. , 0. , 1. );\n    float phase1 = clamp( (iTime-50.)/27.5 , 0. , 1. )*clamp( 1. - (iTime-77.5)/27.5 , 0. , 1. );\n\n    vec3 A1 = vec3( 5.0 , 2.*fft(0.4,0.0).b , iTime/3. );\n    vec3 A2 = vec3( mix(15.,12.,phase1) , 1.*fft(0.7,0.0).b , -iTime);\n    vec3 A3 = vec3( mix(25.,21.,phase1) , mix(3.,15.,calme)*fft(0.1,0.0).b , iTime*2.0 );\n    float mul = 1./(1.*max(A1.y,max(A2.y,A3.y)));\n   \n    //float pts = clamp((iTime-37.5)/260.,0.,1.)*float(maxpts-minpts)+float(minpts);\n    float pts = clamp((iTime-37.5)/(316. - 37.5),0.,1.)*(float(maxpts)-minpts)+float(minpts);\n\tpts = floor(pts/2.)*2.;\n    \n    if( iTime < 22.6 ){\n    \tpts = mix(60.0,pts, (1. - step( 15.5 , iTime )) );\n    \tpts = mix(140.1,pts, step( 15.5 , iTime ) );\n    }\n    \n    pts = mix(pts,75.1,step( 283.5 , iTime ));\n    pts = mix(pts,125.1,step( 290.5 , iTime ));\n    pts = mix(pts,220.1,step( 297.3 , iTime ));\n    pts = mix(pts,170.,step( 302.5 , iTime ));\n    pts = mix(pts,82.,step( 307.5 , iTime ));\n    pts = mix(pts,50.1,ending4);\n    \n    float sound_all = fft(0.1,0.0).b + fft(0.3,0.0).b + fft(0.6,0.0).b;\n    \n    \n    //float begin = (1.  - smoothstep( 0. , 1. , (iTime - 23. )/.5 ))*6.;\n    float begin = (1.  - step( 22.6 , iTime ))*6.;\n    //float ending3 = clamp( (iTime-290.)/20. , 0. , 1. );\n    float ending3 = (step( 295.5+16. , iTime ));\n    \n    \n    float thickness = pixelsize*mix(2.,6.,ending3);\n    if( iResolution.y > 1100. ){\n        // 4K\n        thickness *= 2.;\n    }\n    \n    for( int i = 0 ; i < maxpts ; i++ ){\n        if( float(i) <= pts ) {\n            di = float(i)/(pts);\n            // curve\n            //float theta = di*TWOPI* mix( 5. , 5.1 , (1. + cos(iTime) )/2. );\n            float theta = di*TWOPI*mix(4.,1.,ending3*1. +begin)*mix( 1. , 1.015 ,\n                    ( max(1.5*fft(0.04,0.0).b-fft(0.6,0.0).r,0.)*0.5)*clamp( (1. - milieu)*(1. - calme),0.,1.) );\n            \n            p2 = (vec3(\n                A1.y*cos(A1.x*theta + A1.z) + A2.y*cos(A2.x*theta + A2.z) + A3.y*cos(A3.x*theta + A3.z),\n                A1.y*sin(A1.x*theta + A1.z) + A2.y*sin(A2.x*theta + A2.z) + A3.y*sin(A3.x*theta + A3.z),\n                sin(di*TWOPI*19.)// depth\n            )*vec3(mul,mul,1.));\n\n            if( i > 0 ){\n                //P = bezier(uv,p1.xy,mix(p1.xy + p2.xy,vec2(0.0),di),p2.xy);\n                P = segment(uv,p1.xy,p2.xy);\n                P.z = P.y + float(i);\n                \n                // radius scheme = gives depth or stranges effects\n                //r = (cos( P.z*TWOPI/5.0 + di )+2.)*0.008;\n                r = abs(mix(p1.z,p2.z,P.y));\n                float C = mix(2.5,3.5,smoothstep(0.,1.,1. - ( abs(iTime-180.) - 15.)/10.) );\n                rexp = exp(r*C)*0.003; // depth effect\n                \n            \t// color scheme\n                c = vec4(\n                    0.5+0.5*cos( P.z*TWOPI*.1 + fft(P.z/pts*2.,0.0).r*TWOPI*4. ),\n                    0.5+0.5*sin( P.z*TWOPI*.2 + fft(P.z/pts*3.,0.0).r*TWOPI*3. ),\n                    0.5+0.5*cos( P.z*TWOPI*.3 + fft(P.z/pts*4.,0.0).r*TWOPI*2. ),\n                    fft(repeat(P.z/pts*5.,1.),0.0).r*4./(1.0+2.*r)+cos(di*9.*TWOPI)*0.1\n                );\n                \n                o += mixDist(P,\n                             thickness+smoothstep(0.,1.,sound_all-2.)*0.2\n                             ,rexp,c);\n            }\n\n            p1 = p2;\n            len += P.a;\n        }\n    }\n    \n    if( iFrame > 0 ){\n        float angle = iTime*(2. + intense);\n    \to += .58*( clamp(texture(iChannel1,uv_+polar(.004,angle)),0.,1.)*2.\n                 +  clamp(texture(iChannel1,uv_+polar(.008,angle)),0.,1.) )\n            *smoothstep(0.,1., (iTime-100.)/80. )\n            *smoothstep(0.,1., 1. - (iTime-216.)/20. )\n            *vec4(hsv2rgb_smooth(vec3(.82 - intense*(2.+fft(.08,0.).r*4. ),1.,1.)),1.)\n            ;\n    }\n    \n    float lum = mix(mix(13.,10.,milieu),32.,ending4)/pow(pts,0.4);//(8.+((fft(0.08,0.0).r+fft(0.02,0.0).r))*0.)/(pow(pts,0.1));\n\n    o = 2./(1. + exp(-o*lum*vec4(1.,.8,1.2,1.))) - 1.;\n    \n    o.rgb += phase1*vec3(.8,.5,.7)*.6;\n    \n    o.rgb = mix(o.rgb,\n      vec3(.8,.5,.7)*mix(.9,1.4,ending2)-o.gbr*mix(1.,1.6,ending2),\n      clamp(  ( pow(fft(0.05,0.).b*3.5-.1,3.5) )*smoothstep(0.,1., ending1 ) , 0. , .8 + fft(.9,0.).b*2. ) );\n    \n\n}\n","name":"Buffer B","description":"","type":"buffer"}]}