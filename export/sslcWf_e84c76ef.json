{"ver":"0.1","info":{"id":"sslcWf","date":"1642849317","viewed":229,"name":"Fake pool refraction","username":"stegu","description":"This is a 100% fake water surface. The shader has no real concept of 3-D, and there is only a single call to a 2-D noise function. The noise is our psrdnoise() which computes its analytic gradient and can be animated, but it's one single call.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["noise","refraction","fake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/min(iResolution.x, iResolution.y);\n\n    float time = iTime;\n\n\tconst vec2 nscale = 4.0*vec2(1.0,6.0); // Waves\n\tconst float tscale = 6.0; // Tiles\n\tvec2 v = nscale*(st-0.5)+vec2(time*0.2,time);\n\tconst vec2 p = vec2(0.0, 0.0);\n\tfloat alpha = 4.0*time;\n\tvec2 g;\n\t\n\tfloat n = psrdnoise(v, p, alpha, g);\n\tfloat w = clamp(0.6-st.t + 0.01*n, 0.0, 1.0);\n\tw += 0.2*smoothstep(0.0, 0.1, w);\n\tfloat mask = aastep(0.01,w); // \"This is water\"\n\tvec2 vwarp = (st-0.5)*tscale + 0.05*w*g*vec2(1.0,2.0);\n\n\tfloat tiles = gridlines(vwarp, vec2(1.0,1.0), 0.05);\n\tvec3 tilecol = vec3(0.0,0.7,1.0);\n\tvec3 groutcol = vec3(0.3,0.3,0.8);\n\tvec4 watercol = vec4(1.0,1.0,1.0,0.3);\n\tvec3 mixcol = mix(tilecol, groutcol, tiles);\n\tmixcol = mix(mixcol, watercol.rgb, mask*watercol.a);\n\n    fragColor = vec4(mixcol, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// psrdnoise2.glsl, version 2021-12-02\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan\n// (stefan.gustavson@liu.se, ijm567@gmail.com)\n//\n// Available for download from Github:\n// https://github.com/stegu/psrdnoise/\n//\n// Published under the MIT license, see:\n// https://opensource.org/licenses/MIT\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n// 2) Transform input point to find simplex \"base\" i0\n  vec2 uv = vec2(x.x+x.y*0.5, x.y);\n  vec2 i0 = floor(uv), f0 = fract(uv);\n// 3) Enumerate simplex corners and transform back\n  float cmp = step(f0.y, f0.x);\n  vec2 o1 = vec2(cmp, 1.0-cmp);\n  vec2 i1 = i0 + o1, i2 = i0 + 1.0;\n  vec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n  vec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n  vec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n// 4) Compute distances to corners before we wrap them\n  vec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n  vec3 iu, iv, xw, yw;\n// 5),6) wrap to period and adjust i0, i1, i2 accordingly\n  if(any(greaterThan(period, vec2(0.0)))) {\n\txw = vec3(v0.x, v1.x, v2.x); yw = vec3(v0.y, v1.y, v2.y);\n    if(period.x > 0.0)\n\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\tif(period.y > 0.0)\n\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n    iu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n  } else {\n    iu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n  }\n// 7) Compute the hash for each of the simplex corners\n  vec3 hash = mod(iu, 289.0);\n  hash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n  hash = mod((hash*34.0 + 10.0)*hash, 289.0);\n// 8),9a) Generate the gradients with an optional rotation\n  vec3 psi = hash*0.07482 + alpha;\n  vec3 gx = cos(psi); vec3 gy = sin(psi);\n  vec2 g0 = vec2(gx.x, gy.x);\n  vec2 g1 = vec2(gx.y, gy.y);\n  vec2 g2 = vec2(gx.z, gy.z);\n// 10) Compute radial falloff\n  vec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n  w = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n// 11) Linear ramp along gradient (by a scalar product)\n  vec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n// 12),13) Multiply and sum up noise terms\n  float n = dot(w4, gdotx);\n// 14) Compute first order partial derivatives\n  vec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n  vec2 dn0 = w4.x*g0 + dw.x*x0;\n  vec2 dn1 = w4.y*g1 + dw.y*x1;\n  vec2 dn2 = w4.z*g2 + dw.z*x2;\n  gradient = 10.9*(dn0 + dn1 + dn2);\n// Scale the noise value to [-1,1] (empirical factor)\n  return 10.9*n;\n}\n\nfloat aastep(float threshold, float value) {\n  float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n//  float afwidth = fwidth(value);  // fwidth(v) is |dFdx(v)| + |dFdy(v)|\n  return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat gridlines(vec2 v, vec2 p, float width) {\n  float distx = 0.0;\n  if(p.x > 0.0) {\n\t// Unsigned distance to nearest x line\n\t// (unsigned to keep auto derivatives from going haywire)\n    distx = abs(mod(v.x+0.5*p.x,p.x)-0.5*p.x);\n  }\n  float disty = 0.0;\n  if(p.y > 0.0) {\n\t// Unsigned distance to nearest y line\n    disty = abs(mod(v.y+0.5*p.y,p.y)-0.5*p.y);\n  }\n  float gridx = 1.0 - aastep(width, distx);\n  float gridy = 1.0 - aastep(width, disty);\n  return max(gridx, gridy);\n}\n","name":"Common","description":"","type":"common"}]}