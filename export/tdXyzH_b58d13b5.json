{"ver":"0.1","info":{"id":"tdXyzH","date":"1584178469","viewed":98,"name":"RayTracer Playground","username":"mithrandir","description":"Ray tracer shader for learning purposes.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All the scene is rendered in Buf A, here we're just aplying antialiasing in case we want it.\n#define RES iResolution.xy\n// Change this variable to toggle Antialiasing\n#define ENABLE_FXAA 1\n\n//Using the following fxaa filter\n//https://www.shadertoy.com/view/4tf3D8\nvec3 fxaa(vec2 p)\n{\n\tfloat FXAA_SPAN_MAX   = 8.0;\n    float FXAA_REDUCE_MUL = 1.0 / 8.0;\n    float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = texture(iChannel0, p + (vec2(-1.,-1.) / RES)).rgb;\n    vec3 rgbNE = texture(iChannel0, p + (vec2( 1.,-1.) / RES)).rgb;\n    vec3 rgbSW = texture(iChannel0, p + (vec2(-1., 1.) / RES)).rgb;\n    vec3 rgbSE = texture(iChannel0, p + (vec2( 1., 1.) / RES)).rgb;\n    vec3 rgbM  = texture(iChannel0, p).rgb;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (texture(iChannel0, p + dir * (1./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (2./3. - .5)).rgb);\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  texture(iChannel0, p + dir * (0./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (3./3. - .5)).rgb);\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Col = vec3(0.0);\n    \n    #if ENABLE_FXAA > 0\n    \tCol = fxaa(fragCoord/RES);\n    #else\n    \tCol = texture(iChannel0, fragCoord/RES).rgb;\n    #endif\n    \n    fragColor = vec4(Col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LIGHT_POS vec3(1.0, -1.0, -1.0)\n#define AMBIENT_LIGHT vec3(0.2)\n#define SPHERE_COLOR vec3(0.1, 0.2, 0.3)\n#define PLANE_COLOR vec3(0.4)\n#define SPEC_POWER 0.5\n#define SPEC_SHINESS 0.0\n#define SPECULAR_VALUE vec3(0.4)//vec3(1.0, 0.78, 0.34)//vec3(1.0, 0.78, 0.34); //GOLD vec3(0.6) //Silver-ish\n#define CAMERA_DISTANCE 5.0\n#define CAMERA_HEIGHT 3.0\n#define LIGHT_DIR vec3(0.5,0.8,1.0)\n#define LIGHT_COLOR vec3(1.0)\n#define PI 3.14159265359\n#define TEXTURE_TILLING 0.2\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n    vec3 Energy;\n};\n\nstruct RayHit\n{\n  vec3 Position;\n  float Distance;\n  float FarDistance;\n  vec3 Normal;\n  vec2 uv;\n  int MaterialId;\n};\n    \nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}    \n\nvoid IntersectInfinitePlane(Ray ray, inout RayHit hit)\n{\n    float t = -ray.Origin.y / ray.Direction.y;\n    if (t > 0.0 && t < hit.Distance)\n    {\n        hit.Distance = t;\n        hit.Position = ray.Origin + ray.Direction * t;\n        hit.Normal = vec3(0.0, 1.0, 0.0);\n    }\n}\n\nvoid IntersectBox ( Ray ray, inout RayHit hit, in vec3 boxHalfSizes, in vec3 boxPosition) \n{\n\t// ray-box intersection\n    vec3 pos = ray.Origin + boxPosition;\n    vec3 m = 1.0/ray.Direction;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*pos;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return;\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = ray.Origin + ray.Direction * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(ray.Direction);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(ray.Direction);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(ray.Direction);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(ray.Direction);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tvec2 uv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n    if (timeNear < hit.Distance || hit.Distance == -1.0)\n    {\n        hit.Distance = timeNear;\n        hit.Position = relPoint;\n        hit.Normal = normal;\n        hit.uv = uv;\n        hit.MaterialId = 0;\n    }\n}\n\n\nvoid IntersectSphere(Ray ray, inout RayHit hit, vec4 sphere)\n{\n    //get the vector from the center of this circle to where the ray begins.\n\tvec3 m = ray.Origin - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, ray.Direction);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }    \n\n    //Check if the hitted point is closer to the camera\n    if (collisionTime < hit.Distance || hit.Distance == -1.0)\n    {\n        // return the time t that the collision happened, as well as the surface normal\n    \tvec3 p = ray.Origin + ray.Direction * collisionTime;\n        // calculate the normal, flipping it if we hit the inside of the sphere\n    \tvec3 normal = normalize((ray.Origin+ray.Direction*collisionTime) - sphere.xyz) * normalMultiplier;\n        \n        hit.Distance = collisionTime;\n        hit.Position = p;\n        hit.Normal = normal;\n        \n        //Calculate uv coordinates at hit point\n        vec3 d = normalize(p - sphere.xyz);\n        float u = 0.5 + atan(d.z, d.x)/ 2.0*PI;\n        float v = 0.5 - asin(d.y)/PI;\n        hit.uv = vec2(u,v);\n        \n        hit.MaterialId = 1;\n    }    \n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\nRay CreateRay(vec3 ro, vec3 rd)\n{\n    Ray ray;\n    ray.Origin = ro;\n    ray.Direction = rd;\n    ray.Energy = vec3(1.0);\n    return ray;\n}\n\nRayHit CreateRayHit()\n{\n    RayHit hit;\n    hit.Position = vec3(0.0);\n    hit.Distance = -1.;\n    hit.FarDistance = -1.;\n    hit.Normal = vec3(0.0);\n    hit.uv = vec2(0.0);\n    return hit;\n}\n\nRay CreateCameraRay(vec2 uv)\n{\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    \n    return CreateRay(ro, rd);\n}\n\nRayHit Trace(Ray ray)\n{\n    RayHit hit = CreateRayHit();\n    IntersectSphere(ray, hit, vec4(vec3(0.0, 0.0 + sin(iTime *0.5), 0.0), 1.0));\n    IntersectSphere(ray, hit, vec4(vec3(3.0, 0.0 + sin(iTime), 0.0), 1.0));\n    IntersectSphere(ray, hit, vec4(vec3(-3.0, 0.0 + cos(iTime), 0.0), 1.0));\n    IntersectBox(ray, hit, vec3(5.5, 0.1, 5.5), vec3(0.0, 2.5, 0.0));\n    return hit;\n}\n\nvec3 Shade(inout Ray ray, RayHit hit)\n{\n    if (hit.Distance > 0.0)\n    {\n        vec3 color = vec3(0.0);\n        if (hit.MaterialId == 0)\n        {\n            color = PLANE_COLOR;\n        }\n        else if (hit.MaterialId == 1)\n        {\n            color = SPHERE_COLOR;\n        }\n        \n        ray.Origin = hit.Position + hit.Normal * 0.1; //Little offset not to test against itself.\n        ray.Direction = reflect(ray.Direction, hit.Normal);\n        ray.Energy *= SPECULAR_VALUE * SPEC_POWER;\n        \n        vec3 LightDir = normalize(LIGHT_DIR);\n        float diff = clamp(dot(hit.Normal, LightDir), 0.0, 1.0);\n        vec3 diffuse = diff * LIGHT_COLOR;\n        \n        RayHit shadowHit = Trace(CreateRay(ray.Origin, LightDir));\n        float shadow = step(shadowHit.Distance, 0.0);\n        \n        //vec3 color = texture(iChannel1, hit.uv * TEXTURE_TILLING).rgb; // If you want to texture the sphere\n        diffuse *= shadow;\n        return vec3 ((AMBIENT_LIGHT + diffuse) * color);\n    }\n    else\n    {\n        ray.Energy = vec3(0.0);\n        return texture(iChannel0, ray.Direction).rgb;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates from -1 to 1\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    Ray ray = CreateCameraRay(uv);\n    for (int i = 0; i < 8; ++i)\n    {\n        RayHit hit = Trace(ray);\n        vec3 e = ray.Energy;\n        col += e * Shade(ray, hit);\n        \n        if (ray.Energy == vec3(0.0))\n            break;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}