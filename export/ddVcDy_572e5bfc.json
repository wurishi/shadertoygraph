{"ver":"0.1","info":{"id":"ddVcDy","date":"1699947086","viewed":13,"name":"ray tracer 2.0","username":"H4mm3r","description":"polygon rendering, reflection and refraction.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["3d","rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.141592;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    \n    float t = iTime/2.;\n    float range = 200.;    \n    float fov = 2.;\n    float accuracy = 20.*fov;\n    float maxsteps = range * accuracy;\n    vec3 cpos = vec3(offset.x,0.,offset.y);\n    vec3 crot = vec3(0.,0.,0.);\n    vec4 light = vec4(vec3(-1.,0.,-2.),0.);\n    float bounces = 4000.;\n\n    sphere sphere1 = sphere(vec3(0.), 7., vec3(1.), false, 1., 0., false);\n    sphere sphere2 = sphere(vec3(sin(t),cos(t),0.), 0.5, vec3(1., 0., 0.), false, 1., 0., false);\n    sphere sphere3 = sphere(vec3(sin(t)+cos(t)*0.8,cos(t)+sin(t)*0.8,0.),0.2, vec3(0., 1., 0.), false, 1., 0., false);\n    sphere sphere4 = sphere(2.*vec3(cos(t),0.,sin(t)), 1., vec3(0., 0., 1.), false, 1., 0., false);\n\n    //uv coordinates from -1 to 1\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    vec3 rayGrad = norm(vec3(uv.x, uv.y, fov));\n    vec3 rayPos = cpos;\n    vec3 norm;\n    float lum;\n    float fog = 0.;\n    float colper = 0.;\n    float ri = 1.;\n    float pri = ri;\n    for(float steps = 0.;steps < maxsteps;steps++)\n    {\n        if(colper >= 1.)\n            break;\n        rayPos += rayGrad/accuracy;\n        if(dis(rayPos, sphere1.pos)>sphere1.rad)\n        {\n            ri = sphere1.refri;\n            norm = vecTo(rayPos, sphere1.pos);\n            lum = lighting(rayPos, norm, light);\n            rayGrad = reflect(rayGrad, vecTo(sphere1.pos,rayPos));\n            col += (1.-colper)*(sphere1.col * sphere1.refli);\n            colper += (1.-colper)*sphere1.refli;\n            bounces--;\n\n            if(false){\n            if((col.x+col.y+col.z)>0.)\n            {\n                if(notShadow(rayPos, sphere2, light))\n                {\n                    col = vec3(0.);\n                }\n                if(notShadow(rayPos, sphere3, light))\n                {\n                    col = vec3(0.);\n                }\n            }}\n        }else if(dis(rayPos,sphere2.pos)<sphere2.rad)\n        {\n            ri = sphere2.refri;\n            norm = vecTo(sphere2.pos, rayPos);\n            rayGrad = reflect(rayGrad, vecTo(sphere2.pos,rayPos));\n            col += (1.-colper)*(sphere2.col * sphere2.refli);\n            colper += (1.-colper)*sphere2.refli;\n            bounces--;\n        }else if(dis(rayPos,sphere3.pos)<sphere3.rad)\n        {\n            ri = sphere3.refri;\n            norm = vecTo(sphere3.pos, rayPos);\n            rayGrad = reflect(rayGrad, vecTo(sphere3.pos,rayPos));\n            col += (1.-colper)*(sphere3.col * sphere3.refli);\n            colper += (1.-colper)*sphere3.refli;            \n            bounces--;\n        }else if(dis(rayPos,sphere4.pos)<sphere4.rad)\n        {\n            ri = sphere4.refri;\n            norm = vecTo(sphere4.pos, rayPos);\n            rayGrad = reflect(rayGrad, vecTo(sphere4.pos,rayPos));\n            col += (1.-colper)*(sphere4.col * sphere4.refli);\n            colper += (1.-colper)*sphere4.refli;            \n            bounces--;\n        }else\n            ri = 1.;\n        if(bounces <= 0.)\n            break;\n        fog++;\n    }\n    col *= (maxsteps - fog)/maxsteps;\n    col *= lighting(rayPos, norm, light);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct sphere\n{\n    vec3 pos;\n    float rad;\n    vec3 col;\n    bool shad;\n    float refli;\n    float refri;\n    bool transparent;\n};\nfloat dis( vec3 a, vec3 b )\n{\n    return sqrt(pow(a.x-b.x,2.)+pow(a.y-b.y,2.)+pow(a.z-b.z,2.));\n}\nfloat mag(vec3 a)\n{\n    return dis(a, vec3(0.));\n}\nvec3 norm(vec3 a)\n{\n   return a/mag(a);\n}\nvec3 vecTo(vec3 a, vec3 b)\n{\n    return norm(b-a);\n}\nfloat lighting(vec3 a, vec3 normal, vec4 light)\n{\n\n    return dot(vecTo(a, light.xyz),normal)+light.w;\n}\nbool notShadow(vec3 a, sphere s, vec4 light)\n{\n    vec3 rayPos = a;\n    float stepl = 0.1;\n    float steps = dis(light.xyz, rayPos);\n    vec3 rayGrad = norm(vecTo(rayPos, light.xyz))*stepl;\n    for(float i = 0.; i < steps; i+=stepl)\n    {\n         rayPos+=rayGrad;\n         if(dis(rayPos, s.pos)<s.rad)\n         {\n             return true;\n         }\n    }\n    return false;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec4 handleKeyboard(vec2 offset, vec2 vel) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    vel = (vel +(left + up + right + down))*0.9;\n    offset += vel*velocity;\n\n    return vec4(offset, vel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    vec2 vel = texelFetch( iChannel0, ivec2(0, 0), 0).zw;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset, vel).xy;\n    vel = handleKeyboard(offset, vel).zw;\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, vel);\n}","name":"Buffer A","description":"","type":"buffer"}]}