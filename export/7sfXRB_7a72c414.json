{"ver":"0.1","info":{"id":"7sfXRB","date":"1618782756","viewed":92,"name":"leviathan hellraiser","username":"Fahrenheitrequited","description":"aaa","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["aaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nprecision mediump float;\n\nconst float PI = 3.1415926;\n#define EPS 1e-4\n#define PI2 (PI * 2.0)\n// #define saturate(x) clamp(x, 0.0, 1.0)\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n// set to 1 for 2 octaves\t\n#if 0\t\n\treturn f/0.75;\n#else\t\n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n// set to 1 for 3 octaves, 0 for 4 octaves\t\n#if 1\t\n\treturn f/0.875;\n#else\t\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n#endif\t\n#endif\t\n}\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nmat2 rotate(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat dScene(vec3 p) {\n    float size = 3.;\n \n    vec3 iq = opId(p, vec3(size));\n    p = opRep(p, vec3(size));\n \n    \n    float noise = fbm(iq);\n     float n=0.;\n    n+=0.5*sin(0.8*iq.x+1.1*iTime)*sin(0.71*iq.y+0.2*iTime+0.4)*sin(0.85*iq.z+0.3*iTime+1.4);\n    n+=0.5*sin(0.5*iq.x+1.1*iTime+1.5)*sin(0.3*iq.y+1.3*iTime+1.7)*sin(0.1*iq.z+0.3*iTime+2.4);\n    n = 1.-smoothstep(0.,0.2,n+0.1);\n\n    \n    //float dim =  sin(iTime + noise)*0.5 + 0.5;\n    //float dim = sin(iTime + 1.5) * 0.5 + 0.8;\n    //float dim = fract( sin(iq.x * 124411.771) + cos(iq.y * 77348.551) + sin(iq.z * 55514.991) );\n    float dim =n;\n    \n    \n    //float d = sdBoxFrame(p, vec3(dim),.3);\n    float d = sdBox(p, vec3(dim)); \n    //float d = sdTorus(p, vec2(dim + .1, dim + .1) * .5 );\n \n ;\n  \n  return d;\n}\n\nfloat dBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn max(d.x, d.y);\n}\n\nvoid mainImage(out vec4 outColor, in vec2 fragCoord) {\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n  float duration = 4.0;\n  float t = fract(iTime / duration) * duration;\n \n  // ro=ray origin \n  // Y-up right-handedness coordinate\n  /*\n  vec3 ro = vec3(1.1, 1.2, (t - 1.3));\n  ro = vec3( \n      cos(iTime * 1.7), \n      cos(iTime), \n      (cos(iTime/2.) + sin(iTime/3.)) * 5. \n  ) * 2.;\n  */ \n  vec3 ro = vec3(6.5, 12.88, 33.91)*iTime/5.;\n \n  vec3 ta = vec3( \n      sin(iTime * 2.7), \n      sin(iTime * 1.5), \n      (cos(iTime/3.) + sin(iTime/1.3)) * 3. \n  ) * 20000.;\n  \n  \n    \n    \n  vec3 fwd = normalize(ta - ro);\n  vec3 right = cross(fwd, vec3(0, 1, 0));\n  vec3 up = cross(right, fwd);\n  vec3 rd = normalize(fwd + uv.x * right + uv.y * up);\n    \n  float distance = 0.0;\n  vec3 p = ro;\n  int step = 0;\n  for(int i = 0; i < 260; i++) {\n    step = i;\n    float d = dScene(p) * .57;\n    distance += d;\n    p = ro + distance * rd;\n    if (abs(d) < EPS) break;\n  }\n  \n  vec3 c = vec3(float(step) * 0.013);\n\n  outColor = vec4(c, 1.0)-vec4(0.2, 0.5, 0.7, 1.);\n \n}\n\n","name":"Image","description":"","type":"image"}]}