{"ver":"0.1","info":{"id":"llVBRW","date":"1543546533","viewed":99,"name":"Archway ","username":"tqle","description":"Archway","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["architecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n//construct Shape class\nstruct Shape {\n  float dist;\n  vec4 color;\n};\n//repeating variables, coordinates, shapes. Replaces repeat()\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n} \nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(.5);\n}\n//repating a determined # of times\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { \n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n//Determine maximum vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n//Parametizing vec2, returning a number\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n//Rotating shapes using matrix/linear algebra\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n//Shapes//\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\nfloat sphere(vec3 v, float r){\n  return length(v) - r;\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0 - 1.0)/k1;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2( length(p.xz) - 2.0*ra + rb, abs(p.y) - h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n//////////\n\n//Blending vectors, unionizing, intersecting, cutting\n//Unionize with stairs at intersection\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b - r;\n\treturn min(min(a,b), 0.5*(u + a + abs((mod(u - a + s, 2.*s)) - s)));\n}\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n//Rounding shapes, removing ripples/stairs effect\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n//Columning shapes together, creating ripples \nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n    a = -a;\n    float m = min(a, b);\n    if((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r*sqrt(2.)/n/2.;\n        columnradius = r*sqrt(2.)/((n - 1.)*2. + sqrt(2.));\n        pR45(p);\n        p.y += columnradius;\n        p.x -= sqrt(2.)/2.*r;\n        p.x += -columnradius*sqrt(2.)/2.;\n       \t\n        if(mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        pMod1(p.y, columnradius*2.);\n        float result = -length(p) + columnradius;\n        result = max(result, p.x);\n        result = min(result, a);\n        return -min(result, b);\n    } else {\n        return -m;\n    }\n}\n//Mixing colors and shapes go hand in hand in animation\nfloat mixColors(float r, float v, float z) {\n  return clamp(0.5 + 0.5*(v - r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r) {\n  float z = mixColors(v, f, r);\n  return mix(f, v, z) - r*z*(1. - z);\n}\n//Modifying vectors, from cartesian into polar coordinates\nfloat pModPolar(inout vec2 v, float r) {\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x) + f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f) - f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nvec3 mod289(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }\nvec2 mod289(vec2 x) { return x - floor(x*(1.0 / 289.0))*289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0) + 1.0)*x); }\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0*fract(p*C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314*(a0*a0 + h*h);\n    vec3 g;\n    g.x  = a0.x*x0.x + h.x*x0.y;\n    g.yz = a0.yz*x12.xz + h.yz*x12.yw;\n    return 130.0*dot(m, g);\n}\nShape animation(vec3 c){\n  Shape shape; \n\n  \n  //Instantiating color vectors\n  vec4 midCol = vec4(1.);\n  vec4 cloCol = vec4(1.);\n  vec4 briCol = vec4(1.134, .25, .25, 1.); \n  vec4 haCol = vec4(0., 0., 0., 1.);\n  \n  //Declaring vectors, repeating, pModding (modifications)\n  vec3 ba = c; //base \n  \tpModInterval1(ba.x, .22, -6., 6.);\n    pModInterval1(ba.y, .21, -5., 1.);\n    pModInterval1(ba.z, .2, 1., 5.);\n  vec3 altba = c; //alternating base\n\tpModInterval1(altba.x, .19, -7., 6.75);\n    pModInterval1(altba.y, .21, -5., 1.);\n    pModInterval1(altba.z, .15, 1., 5.);\n  vec3 si = c; //sides/upper parts\n  \tsi.x = abs(si.x) - .00075;\n  vec3 roo = c; //roof\n    roo.xz *= rot(radians(90.));\n  vec3 tun = c; //tunne\n  \tfloat radius = 1.;\n    tun.yz *= rot(radians(90.));\n  vec3 mid = c; //middle layer\n    pModInterval1(mid.x, .225, -5.65, 5.65);\n    pModInterval1(mid.z, .225, 0., 5.65);\n  vec3 pol = c; //poles\n    pModInterval1(pol.x, .5, -1., 1.);\n  vec3 pri = c; //prism\n  vec3 clo = c; //clock\n    clo.yz *= rot(radians(90.));\n  vec3 minha = c; //minute hand\n  vec3 hrha = c; //hour hand \n    hrha.xy *= rot(radians(45.));\n  vec3 bar = c; //bars\n\tbar.x = abs(bar.x) - .225;\n  vec3 bartwo = c;\n    bartwo.x = abs(bartwo.x) - .225;\n  vec3 barthree = c;\n    barthree.x = abs(barthree.x) - .225;\n  vec3 barfour = c;\n    barfour.x = abs(barfour.x) - .225;\n  //Instantiating vectors, assigning values\n  float base = fBox(ba - vec3(0., 0., 0.), vec3(.1, .05, .05));\n  float altbase = fBox(altba - vec3(.025, .11, 0.), vec3(.1, .05, .05));\n  float sides = fBox(si - vec3(1., 1.325, 0.), vec3(.3675, .6, .25));\n  float tunnel = sdCappedCylinder(tun - vec3(0., 0., 1.), vec2(radius, 6.));\n  float middle = fBox(mid - vec3(0., .55, 0.), vec3(.1, .15, .1));\n  float poles = fBox(pol - vec3(0., 1.35, 0.), vec3(.1, .6, .1));\n  float prism = sdTriPrism(pri - vec3(0., 2.5, .75), vec2(.7, 1.));\n  float clock = sdRoundedCylinder(clo - vec3(0., 0., -2.25), .175, .1, .25);\n  float minutehand = fBox(minha - vec3(.11, 2.025, -.75), vec3(.125, .015, .05));\n  float hourhand = fBox(hrha - vec3(1.295, 1.525, -.5), vec3(.125, .015, .05));\n  float roof = sdTriPrism(roo - vec3(.25, 2.25, 0.), vec2(.5, 1.35));\n  float bars = fBox(bar - vec3(0., 1., 0.), vec3(.145, .03, .05));\n  float barstwo = fBox(bartwo - vec3(0., 1.5, 0.), vec3(.145, .045, .05));\n  float barsthree = fBox(barthree - vec3(0., 1.7575, 0.), vec3(.045, .2025, .05));\n  float barsfour = fBox(barfour - vec3(0., 1.75, 0.), vec3(.145, .045, .05));\n  //Placing vectors onto canvas, blending vectors with min/max/etc...\n  //shape.dist = base;\n  shape.dist = min(base, altbase);\n  shape.dist = fOpDifferenceStairs(shape.dist, tunnel, 1., 1.15);\n  shape.dist = fOpUnionStairs(shape.dist, middle, 1., 1.);\n  shape.dist = min(shape.dist, sides);\n  shape.dist = min(shape.dist, poles);\n  shape.dist = min(shape.dist, prism);\n  shape.dist = fOpUnionStairs(shape.dist, clock, 1., 1.);\n  shape.dist = min(shape.dist, minutehand);\n  shape.dist = min(shape.dist, hourhand);\n  shape.dist = min(shape.dist, roof);\n  shape.dist = min(shape.dist, bars);\n  shape.dist = min(shape.dist, barstwo);\n  shape.dist = min(shape.dist, barsthree);\n  shape.dist = min(shape.dist, barsfour);\n  \n    \n  //Blending color vectors, assigning vectors onto animation vectors (color -> shapes)\n  //shape.color = mix(shape.color,  midCol, mixColors(middle, shape.dist, 0.));\n  //shape.color = mix(cloCol, midCol, mixColors(middle, clock, 0.));\n  shape.color = mix(midCol, briCol, mixColors(base, middle, 0.));\n  shape.color = mix(shape.color, briCol, mixColors(altbase, shape.dist, 0.));\n  shape.color = mix(shape.color, briCol, mixColors(prism, shape.dist, .1));\n  shape.color = mix(shape.color, briCol, mixColors(sides, shape.dist, .1));\n  shape.color = mix(shape.color, briCol, mixColors(poles, shape.dist, .1)); \n  shape.color = mix(shape.color, haCol, mixColors(minutehand, shape.dist, .1));\n  shape.color = mix(shape.color, haCol, mixColors(hourhand, shape.dist, .1));\n                    \n  return shape;\n}\nShape map(vec3 c){\n  Shape shape = animation(c);\n  return shape;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //Modifying the coordinate system \n  vec2 v = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  //setting camera position \n  vec3 cam = vec3(0., 0., -6.5);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n  // Ray Marcher\n  for(float z = 0.1; z <= 1.;z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1. - z); \n      break;\n    }\n    scene += f*c.dist;\n\n\n  }\n}\n    ","name":"Image","description":"","type":"image"}]}