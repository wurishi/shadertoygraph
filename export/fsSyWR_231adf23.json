{"ver":"0.1","info":{"id":"fsSyWR","date":"1643344519","viewed":114,"name":"Rectangle Anti-aliasing","username":"zznewclear13","description":"An axis-aligned rectangle movement anti-aliasing attempt. Mainly designed for ui elements. Any advice would be greatly appreciated!\nBuffer A: actual anti-aliasing code; Image: Magnifier.\nClick and drag to zoom in.\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","antialiasing","rectangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A magnifier, antialising in buffer A\n#define SAMPLE_WINDOW_SIZE 80\n#define SAMPLE_RESOLUTION 4.0\n\n//Some old code borrowed from my previous shader.\nbool CheckInRectangle(ivec2 currentCoord, ivec2 bottomLeft, ivec2 upperRight, out bool onBorder)\n{\n    onBorder = any(equal(currentCoord, bottomLeft)) || any(equal(currentCoord, upperRight));\n    return all(greaterThanEqual(currentCoord, bottomLeft)) && all(lessThanEqual(currentCoord, upperRight));\n}\n\nvec3 GetSampleColor(ivec2 currentCoord, ivec2 samplePosition, float sampleResolution)\n{\n    ivec2 sampleOffset = currentCoord - samplePosition;\n    ivec2 sampleCoord = ivec2(floor(vec2(sampleOffset) / sampleResolution));\n    vec3 sampleColor = texture(iChannel0, vec2(vec2(samplePosition) + vec2(sampleCoord) + 0.5) / iResolution.xy).rgb;\n    return sampleColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 mainTex = texture(iChannel0, uv).rgb;\n    vec3 finalColor = mainTex;\n    \n    ivec2 samplePosition = ivec2(0.5 * iResolution.xy);\n    if(iMouse.z > 0.0)\n    {\n        samplePosition = ivec2(iMouse.xy);\n    }\n    \n    int sampleWindowSize = SAMPLE_WINDOW_SIZE;\n    int halfSampleWindowSize = sampleWindowSize >> 1;\n    int halfSampleWindowSizePlus = (sampleWindowSize ++) >> 1;\n    \n    //Draw sample window.\n    bool onBorder = false;\n    bool inColorWindow = CheckInRectangle(iFragCoord, samplePosition - halfSampleWindowSize, samplePosition + halfSampleWindowSizePlus, onBorder);\n    vec3 sampleColor = GetSampleColor(iFragCoord, samplePosition, SAMPLE_RESOLUTION);\n    sampleColor = mix(sampleColor, fract(sampleColor + 0.5), float(onBorder));//A distinguishable frame.\n\n    finalColor = mix(finalColor, sampleColor, float(inColorWindow));\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//My attempt on axis-aligned rectangle movement anti-aliasing.\n//Not so sure about the result... Especially when the width is less than one pixel.\n//Any advice would be greatly appreciated!\n\n//Uncomment this line to see animation in slow motion\n//#define SLOW_MOTION\n\nfloat Rasterize(vec2 offsetPosition, vec2 boxSize)\n{\n    vec2 halfBoxSize = 0.5 * boxSize;\n    bool isInRange = all(greaterThanEqual (halfBoxSize - abs(offsetPosition - halfBoxSize), vec2(0.0, 0.0)));\n    return isInRange ? 1.0 : 0.0;\n}\n\n//Basically calculates a two-dimensional signed distance field for axis-aligned rectangles\nfloat Antialising(vec2 offsetPosition, vec2 boxSize)\n{\n    vec2 halfBoxSize = 0.5 * boxSize;\n    vec2 offset = halfBoxSize - abs(offsetPosition - halfBoxSize);\n    offset = clamp(offset, -0.5, 0.5);\n    vec2 coverage = offset + 0.5;\n    //Handles the case when box width is less than one pixel.\n    if(boxSize.x - offset.x < 0.5){coverage.x = boxSize.x;}\n    if(boxSize.y - offset.y < 0.5){coverage.y = boxSize.y;}\n    return coverage.x * coverage.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backgroundColor = vec3(1.0, 1.0, 1.0);\n    vec3 boxColor = vec3(0.0, 0.0, 0.0);\n    vec3 color = backgroundColor;\n    \n    vec2 gridSize = vec2(35.3, iResolution.y * 0.5);\n#if defined(SLOW_MOTION)\n    float speed = 0.3;\n#else\n    float speed = 5.0;\n#endif\n    vec2 transitionedFragCoord = fragCoord + vec2(iTime * speed, sin(iTime * 0.1 * speed) * 25.3);\n    vec2 fragCoordRemain = mod(transitionedFragCoord, vec2(gridSize.x * 10.0, gridSize.y));\n    float xCount = floor(fragCoordRemain.x / gridSize.x);\n    \n    vec2 fragCoordOffset = fragCoordRemain - vec2(xCount * gridSize.x, 0.0);\n    //Some random float width to check antialising quality.\n    float boxWidth = 0.913 * gridSize.x * pow(0.5, xCount);\n    float boxHeight = iResolution.y * 0.25;\n    vec2 boxSize = vec2(boxWidth, boxHeight);\n    vec2 offsetPosition = fragCoordOffset - 0.5 * gridSize + 0.5 * boxSize;\n    \n    if(fragCoord.y > 0.5 * iResolution.y + 1.0)\n    {\n        float rasterize = Rasterize(offsetPosition, boxSize);\n        color = mix(backgroundColor, boxColor, rasterize);\n    }\n    else if(fragCoord.y > 0.5 * iResolution.y -1.0)\n    {\n        color = vec3(fragCoord.x / iResolution.x);\n    }\n    else\n    {\n        float antialising = Antialising(offsetPosition, boxSize);\n        color = mix(backgroundColor, boxColor, antialising);\n    }\n    \n    //Convert into perceptual color space.\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}