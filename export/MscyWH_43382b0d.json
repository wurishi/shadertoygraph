{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/**\n* Many of the utility functions for noise, intersections, etc. are from Morgan McGuire's\n* tiny planet (https://www.shadertoy.com/view/lt3XDM). Also borrowed his code for input handling.\n*\n* Also used a variant of IQ's 3d Voronoi Noise (https://www.shadertoy.com/view/ldl3Dl) for the\n* biome mapping and heavily utilized this amazing noise function\n* by @kuvlar: https://www.shadertoy.com/view/ldGSzc\n*/\n\nconst float pi\t= 3.1415926535;\nconst float inf\t= 1.0 / 1e-10;\nconst float deg2rad\t= pi / 180.0;\nconst float epsilon = .0001;\nconst int numMarches = 150;\nconst bool autoRotate = true;\n\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\nbool intersectSphere(vec3 C, float r, vec3 rayOrigin, vec3 direction, inout float nearDistance, inout float farDistance) { vec3 P = rayOrigin; vec3 w = direction; vec3 v = P - C; float b = 2.0 * dot(w, v); float c = dot(v, v) - square(r); float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } float dsqrt = sqrt(d); float t0 = infIfNegative((-b - dsqrt) * 0.5); float t1 = infIfNegative((-b + dsqrt) * 0.5); nearDistance = min(t0, t1); farDistance  = max(t0, t1); return (nearDistance < inf); }\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm1, 1)\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n    \nconst float fov = 20. * deg2rad;\nconst vec3 planetCenter = vec3(0.);\nconst float planetRadius = 1.;\nconst vec3 light = vec3(0., 1., 3.);\nconst float cellDiffThreshold = .1;\n\nmat3 planetRotation;\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43754.5453123);\n}\n\nmat2 rotate(float a)\n{\n    float ca = cos(a); float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rnd(vec2 p)\n{\n    return abs(rand(p)) * 0.8 + 0.1;\n}\n\nfloat value (float x, float randx, float c)\n{\n    float a = min(x/randx, 1.0);\n    \n    float d = clamp(1.0 - (randx + c), 0.1, .9);\n    float b = min(1.0, (1.0 - x) / d);\n    return a + (b - 1.0);\n}\n\nfloat polynoise(vec2 p, float sharpness)\n{\n    vec2 seed = floor(p);\n    vec2 rndv = vec2(rnd(seed.xy), rnd(seed.yx));\n    vec2 pt = fract(p);\n    float bx = value(pt.x, rndv.x, rndv.y * sharpness);\n    float by = value(pt.y, rndv.y, rndv.x * sharpness);\n    return min(bx, by) * (0.3 + abs(rand(seed.xy * 0.01)) * 0.7);\n}\n\nvec3 mapBiome(vec3 x )\n{\n    x = planetRotation * x;\n    \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    \n    // distance to closest and second closest\n    vec2 res = vec2( 100.0 );\n    // biome ID for closest and second closest\n    vec2 resId = vec2(-1., -1.);\n    \n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = length(r);\n        id = mod(abs(dot( p+b, vec3(1.0,57.0,113.0 ))), 3.);\n\n        if( d < res.x )\n        {\n            res = vec2( d, res.x );\n            resId = vec2( id, resId.x );\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n            resId.y = id;\n        }\n    }\n    \n    float diff = res.y - res.x;\n    \n    // this is a giant hack. need a better way to blend between the voronoi regions.\n    float ratio1 = min(1., pow(smoothstep(1., 3., clamp(res.y / res.x, 1., 3.)), .35) + .5);\n    float ratio2 = 1. - ratio1;\n        \n    return vec3(resId.x == 0. ? ratio1 : resId.y == 0. ? ratio2 : 0.,\n                resId.x == 1. ? ratio1 : resId.y == 1. ? ratio2 : 0.,\n               \tresId.x == 2. ? ratio1 : resId.y == 2. ? ratio2 : 0.);\n}\n\nfloat polyfbm(vec2 p, float dullness)\n{\n    vec2 seed = floor(p);\n    mat2 r1 = rotate(2.4);\n    mat2 r2 = rotate(0.4);\n    mat2 r3 = rotate(-2.0);\n    \n    // 1st octave\n    float m1 = polynoise(p * r2, dullness);\n    \n    m1 += polynoise ( r1 * (vec2(0.5, 0.5) + p), dullness);\n    m1 += polynoise ( r3 * (vec2(0.35, 0.415) + p), dullness);\n    m1 *= 0.333 * 0.75;\n    \n    // 2nd\n    float m2 = polynoise (r3 * (p * 2.0), dullness + .1);\n    m2 += polynoise (r2 * (p + vec2(0.2, 0.6)) * 2.0, dullness);\n    m1 += m2 * 0.5 * 0.5;\n\t\n    return m1 + .5;\n}\n\nfloat calcInitialDisplacement(vec3 p, float dullness)\n{\n    float x = polyfbm(p.zy, dullness);\n    float y = polyfbm(p.xz, dullness);\n    float z = polyfbm(p.xy, dullness);\n    \n    vec3 n = max((abs(p) - 0.2)*7., 0.001);\n    n /= (n.x + n.y + n.z ); \n    \n    return x * n.x + y * n.y + z * n.z;\n}\n\nfloat sceneSDF(vec3 p, out bool isWater) \n{\n    vec3 biome = mapBiome(p);\n    isWater = false;\n    p = planetRotation * p;\n    vec3 surfaceLocation = normalize(p);\n    float freq = 1.5;\n    float mult = 1. - biome.r * .075 + biome.b * .045;\n    float dullness = .2 + biome.r * .2;\n    \n    float elevation = calcInitialDisplacement(p * freq, dullness) * mult;\n    elevation *= planetRadius;\n    \n    if (elevation < .7) \n    {\n        elevation = .7 - pow(.7 - elevation, .25) * fbm1(surfaceLocation * 4. + iTime / 4.) * .2;\n        isWater = true;\n    }\n    \n    return (length(p) - elevation) * .8;\n}\n\nvec3 gradient(in vec3 rp)\n{\n    vec2 off = vec2(0.005, 0.0);\n    bool temp;\n    vec3 g = vec3(sceneSDF(rp + off.xyy, temp) - sceneSDF(rp - off.xyy, temp),\n                  sceneSDF(rp + off.yxy, temp) - sceneSDF(rp - off.yxy, temp),\n                  sceneSDF(rp + off.yyx, temp) - sceneSDF(rp - off.yyx, temp));\n    return normalize(g);\n}\n\nbool rayMarch(vec3 eye, vec3 dir, float minDistance, float maxDistance,\n              out float totDist, out bool isWater)\n{\n    totDist = minDistance;\n    vec3 pos = eye;\n\tfor (int i = 0; i < numMarches; i++)\n    {\n        pos = eye + totDist * dir;\n        float dist = sceneSDF(pos, isWater);\n        if (dist < epsilon)\n        {\n            return true;\n        }\n        else if (dist > maxDistance)\n        {\n            return false;\n        }\n        totDist += dist * .25;\n    }\n    \n    return false;\n}\n\nvec3 shade(vec3 pos, bool isWater)\n{\n    vec3 normal = gradient(pos);\n    vec3 lightDir = normalize(light - pos);\n    vec3 ambient = vec3(.2, 0., 0.);\n    \n    float diffuse = max(0., dot(normal, lightDir));\n    float len = length(pos);\n    \n    vec3 biomeWeights = mapBiome(pos * 1.);\n    vec3 col = vec3(.8, .8, .1) * biomeWeights.x\n        + vec3(0., 1., 0.) * biomeWeights.y\n        + vec3(.2, .2, .2) * biomeWeights.z;\n    \n    if (biomeWeights.z > .75 && len > .8)\n    {\n        col = vec3(1., 1., 1.);\n    }\n    \n    if (isWater)\n    {\n    \tcol = vec3(0., 0.62, 1.);\n    }\n    \n    // start off just doing plain old blinn phong\n\treturn diffuse * col + ambient;\n}\n\nvec3 draw(vec3 eye, vec3 dir, float minDistance, float maxDistance, vec2 fragCoord, vec2 invResolution)\n{\n    float totDist;\n    bool isWater;\n    if (rayMarch(eye, dir, minDistance, maxDistance, totDist, isWater)) {\n        return shade(eye + dir * totDist, isWater);\n    }\n    else \n    {\t\n        float galaxyClump = (pow(noise(fragCoord.xy * (30.0 * invResolution.x) + iTime / 2.), 3.0) * 0.5 +\n            pow(noise(100.0 + fragCoord.xy * (15.0 * invResolution.x)), 5.0)) / 1.5;\n        return vec3(galaxyClump * pow(hash(fragCoord.xy), 1500.0) * 80.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float yaw  = -((2. * iMouse.x / iResolution.x) * 2.5 - 1.25) + (autoRotate ? -iTime * 0.035 : 0.0);\n\tfloat pitch = ((2. * iMouse.y > 0.0 ? 2. * iMouse.y : iResolution.y * 0.3) / iResolution.y) * 2.5 - 1.25;\n \tplanetRotation = \n    \tmat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) *\n    \tmat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch));\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 eye = vec3(0., 0., 6.);\n    vec3 dir = normalize(vec3(fragCoord.xy - iResolution.xy / 2., -iResolution.y / (2. * tan(fov / 2.))));\n    \n    // get the near and far plane for the raymarch to reduce operations\n    float minDistance, maxDistance;\n    intersectSphere(planetCenter, planetRadius, eye, dir, minDistance, maxDistance);\n    \n    fragColor.rgb = draw(eye, dir, minDistance, maxDistance, fragCoord, 1. / iResolution.xy);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MscyWH","date":"1518633162","viewed":842,"name":"Low Poly Planet","username":"laserdog","description":"A cartoony, low-poly planet with multiple biomes. Use mouse to move. I used this image as a reference: https://img2.cgtrader.com/items/695091/c2b1342e77/3d-cartoon-planet-city-3d-model-max.jpg. Used a lot of learnings from @morgan3d and @kuvlar's shaders.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","planet","lowpoly"],"hasliked":0,"parentid":"","parentname":""}}