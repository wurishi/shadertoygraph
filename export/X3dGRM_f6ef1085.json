{"ver":"0.1","info":{"id":"X3dGRM","date":"1716765697","viewed":43,"name":"Raymarching studies - 02","username":"zschzen","description":"a simple studie","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","studies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS    80\n#define SURFACE_DIST 0.001\n#define MAX_DIST     100.0\n\n// Signed distance function for the scene\nfloat\nsceneSDF( vec3 p )\n{\n    float dSphere = 0.0;\n    float dBox    = 0.0;\n    float dGround = 0.0;\n\n    // Moving sphere\n    {\n        //Sphere xyz is position w is radius\n        vec4 s  = vec4( sin( iTime ) * 3., 0, 0, 1 );\n        dSphere = sdSphere( p - s.xyz, s.w );\n    }\n\n    // Static cube\n    {\n        dBox = sdBox( p, vec3( .5 ) );\n    }\n\n    // ground\n    {\n        dGround = p.y + 1.0;\n    }\n\n    // Return the minimum distance to the geometry\n    return min( dGround, smin( dSphere, dBox, 1.0 ) );\n}\n\n// Ray marching algorithm to find intersection with the scene\nfloat\nRayMarch( vec3 ro, vec3 rd )\n{\n    float t = 0.;  // Initialize ray march distance\n    for ( int i = 0; i < MAX_STEPS; ++i )\n    {\n        vec3  p = ro + t * rd;    // Current point along the ray\n        float d = sceneSDF( p );  // Distance to the scene\n\n        if ( d < SURFACE_DIST ) break;\n\n        t += d;                   // Advance the ray\n\n        // Break if the ray hits the object or goes beyond max distance\n        if ( t > MAX_DIST ) break;\n    }\n    return t;\n}\n\n// Calculate the normal of a point in the scene\nvec3\nGetNormal( vec3 pos )\n{\n   vec2 e = vec2( 1.0, -1.0 ) * ( 0.5773 * 0.0005 );\n   return normalize( e.xyy * sceneSDF( pos + e.xyy ) + \n\t\t\t\t\t e.yyx * sceneSDF( pos + e.yyx ) + \n\t\t\t\t\t e.yxy * sceneSDF( pos + e.yxy ) + \n\t\t\t\t\t e.xxx * sceneSDF( pos + e.xxx ) );\n}\n\n// Calculate the light intensity at a point in the scene\nfloat\nGetLight( vec3 p )\n{\n    vec3 lightPos = vec3 ( 0, 5, 0 );\n    lightPos.xz += vec2( sin( iTime ), cos( iTime ) ) * 2.;\n\n    vec3 l = normalize( lightPos - p );\n    vec3 n = GetNormal( p );\n\n    // Calculate the diffuse light intensity\n    float dif = clamp( dot( n, l ), 0., 1.);\n    float d = RayMarch( p + n * SURFACE_DIST * 2., l );\n    if ( d < length( lightPos - p ) ) dif *= .1;\n\n    // Return the light intensity\n    return dif;\n}\n\n\nvoid\nmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates\n    vec2 uv = ( fragCoord * 2. - iResolution.xy ) / iResolution.y;\n    vec2 m  = ( iMouse.xy * 2. - iResolution.xy ) / iResolution.y;\n    \n    // Initialize ray origin and direction\n    vec3 ro = vec3( 0.0, 0.0, -3.0 );\n    vec3 rd = normalize( vec3( uv, 1.0 ) );\n\n    // Apply camera rotations based on mouse position\n    {\n        mat2 r = rot2D( -m.y );\n        // Vertical rotation\n        ro.yz *= r; rd.yz *= r;\n        r = rot2D( -m.x );\n        // Horizontal rotation\n        ro.xz *= r; rd.xz *= r;\n    }\n\n    // Perform ray marching\n    float d = RayMarch( ro, rd );\n    vec3  p = ro + rd * d;\n\n    float dif = GetLight( p );\n    vec3  col = vec3( dif );\n\n    col = col*3.0 / ( 2.5 + col );\n    col = pow( col, vec3( 0.4545 ) );\n\n    // Set the fragment color\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.1415925359\n#define TAU 6.2831850718\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions/\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat2 rot2D( float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    return mat2( c, -s, s, c );\n}\n\n// Rodrigues rotation formula\nvec3 rot3D( vec3 p, vec3 axis, float angle )\n{\n    return mix( dot( axis, p ) * axis, p, cos( angle ) )\n            + cross( axis, p ) * sin( angle );\n}","name":"Common","description":"","type":"common"}]}