{"ver":"0.1","info":{"id":"NllcDM","date":"1648124101","viewed":93,"name":"ATI 1","username":"Macouta","description":"ati 1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","jellyfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359; \nvec3 bg;\n\nvec3 accentColor1 = vec3(1., .1, .5);\nvec3 secondColor1 = vec3(.1, .5, 1.);\n\nvec3 accentColor2 = vec3(1., .5, .1);\nvec3 secondColor2 = vec3(.1, .5, .6);\n\nfloat op_union (float d1,float d2){return min (d1,d2);}\nvec2 op_union_mat(vec2 d1, vec2 d2){return (d1.x < d2.x) ? d1 : d2;}\nfloat op_sub(float d1,float d2){return max (d1,d2);}\nfloat op_ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat op_inter(float d1,float d2){return max (d1,d2);}\nvec3 op_rep(in vec3 p, in vec3 c) {return mod(p+0.5* c, c) -0.5*c;}\n\nfloat sat(float x) { return clamp(x,0.,1.); }\nfloat SIN(float x) { return sin(x)*.5+.5; }\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n// Basice distance field geometry primitives\nfloat sphere(vec3 p, vec3 o, float r){ return length(p-o) - r; }\nfloat cylinder(vec2 p, vec2 o, float r){ return length(p - o) - r; }\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*3.1415/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n} \n\nmat2 rot2d(float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n\nvec4 Rnd4(float i)\t\t\t\t\t\t\t\t{return sin(vec4(123.8456, 64.146543, 992.12343, 1235.01023) * i);}\n\nfloat PropulsionTime(float s, float offset)\t\t{return iTime*0.5 + sin((iTime+offset*PI)*2.0 + PI*0.1)*s;}\n\nfloat JellyTentacle(vec3 p, float inTentacleLength, float inAnimSpeed, float inOffset)\n{\t\n\tfloat tentacleScalePos\t= clamp(abs(p.y) / inTentacleLength, 0.0, 1.0);\n\t\n\tfloat tentacleMod\t\t= pow(tentacleScalePos, 1.5) * PI * 2.0 - PropulsionTime(0.15, inOffset) * inAnimSpeed;\n\tfloat tentacleModifierX\t= cos(tentacleMod)*0.4;\n\tfloat tentacleModifierY\t= cos(tentacleMod + 12.02343)*0.4;\n\tp.x\t+=(tentacleScalePos * tentacleModifierX) * 2.0;\n\tp.z\t+=(tentacleScalePos * tentacleModifierY) * 2.0;\n\t\n\tfloat tentacleThickness\t= mix(0.15, 0.01, tentacleScalePos);\n\t\n\tp.y\t= abs(p.y + inTentacleLength*0.5) - inTentacleLength * 0.5;\n\n\tfloat cylinder = max(length(p.xz) - tentacleThickness, p.y);\n\n\treturn cylinder;\n}\n\nvec2 jellyfish(vec3 pos) {\n    vec2 v = vec2(0);\n    float inOffset = .0;\n    float N = N3(pos);\n    float pulse = 0.7 - 0.2* cos(iTime);\n    vec4 rnd\t= Rnd4(1.0 + inOffset);\n\n    float d = sphere(pos, vec3(0), 0.8);\n    d = op_ssub(d, sphere(pos, vec3(0.0, pulse, 0.0), 0.8), 0.2);\n\n    pos.y -= 1.0;\n    d = min(d, JellyTentacle(pos + vec3(rnd.x, pulse, rnd.y)* 0.2, 6.0+rnd.z*2.0, 1.0+rnd.w*0.5, inOffset));\n\td = min(d, JellyTentacle(pos + vec3(rnd.w, pulse, rnd.x)* 0.2, 6.0+rnd.y*2.0, 1.0+rnd.z*0.5, inOffset));\n\td = min(d, JellyTentacle(pos + vec3(rnd.y, pulse, rnd.z)* 0.2, 6.0+rnd.w*2.0, 1.0+rnd.x*0.5, inOffset));\n\n    return vec2(d, 0.0);\n}\n\nvec2 map(vec3 pos) {\n    vec2 v = vec2(0.0);\n    v = jellyfish(pos);\n    return v;\n}\n\nvec4 JellyTex(vec3 p) { \n    vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n    \n    float b = .75+sin(s.x*6.)*.25;\n    b = mix(1., b, s.y*s.y);\n    \n    p.x += sin(s.z*10.)*.1;\n    float b2 = cos(s.x*26.) - s.z-.7;\n   \n    b2 = smoothstep(.1, .6, b2);\n    return vec4(b+b2);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x\n        ) - v);\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\n    float c = 0.0;\n    for(int i = 0; i < 256; i++) {\n        vec2 ray = map(ro + rd * c);\n        if(ray.x < (0.0001*c)) {\n            return vec2(c, ray.y);\n        }\n        c += ray.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nvec3 background(vec3 r) {\n\t\n    float x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = PI*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = bg*(1.+y);\n    \n\tfloat t = iTime;\t\t\t\t// add god rays\n    \n    float a = sin(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*5.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(42.*x+a*y*21.-t));\n    beam2 *= sat(sin(34.*x+a*y*17.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.05;\n\n    // col = vec3(1.0);\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    bg = background(rd);\n    vec3 col = vec3(0);\n    vec2 contact = castRay(ro, rd);\n    vec3 nor = getNormal(ro + rd * contact.x);\n    float fade = 0.;\n\n    vec3 lightPos = vec3(0.0, -2.0, 0.0);\n    vec3 lightTar = vec3(0.0, 0.0, 0.0);\n    vec3 lightDir = normalize(lightTar - lightPos);\n\n    \n\n    if(contact.x == -1.) { col = bg; } \n    else {\n        float lambert = clamp(dot(nor, lightDir), 0.0, 1.0);\n        vec3 R = reflect(rd, nor);\n        float fresnel = sat(1.+dot(rd, nor));\n        float trans = (1.-fresnel)*.5;\n        vec3 ref = background(R);\n\n        if(contact.y == 0.0) {\n            vec3 dif = JellyTex(vec3(0)).rgb;\n            dif *= max(.2, lambert);\n\n            col = mix(col, vec3(dif), .25);\n\n            col += fresnel*ref*sat(dot(vec3(0., 1., 0.), nor)) * 2.0;\n        }\n    }\n\n    \n    return col;\n}\n\nfloat vignette(vec2 uv, float radius, float smoothness) {\n    float diff = radius - distance(uv, vec2(0.5, 0.5));\n    return smoothstep(-smoothness, smoothness, diff);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float t = iTime*.04;\n\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cameraPos = vec3(-3.0, -1.0, -3.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n\n    bg = mix(secondColor1, secondColor2, SIN(t*7.345231));\n\n\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n\n    vec3 col = render(cameraPos, viewDir);\n\n    vec2 pp_uv = fragCoord/iResolution.xy;\n    col *= vignette(pp_uv, 0.5, 0.5);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}