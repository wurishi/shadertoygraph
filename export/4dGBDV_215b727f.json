{"ver":"0.1","info":{"id":"4dGBDV","date":"1530448420","viewed":220,"name":"Ray marching practice 3","username":"lnae","description":"Blobby things to try some simple shading and colors","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(in vec3 pos, out int material){\n\t\n    material = 0;\n    float minDist, dist;\n    \n    pos.xz = rot(0.5 * iTime + sin(0.5 * iTime)) * pos.xz;\n    pos.yz = rot(0.5 * iTime) * pos.yz;\n    pos.xy = rot(0.5 * iTime) * pos.xy;\n    \n    //blobby shapes\n    float deform = 0.0075 * (sin(50. * pos.y) + sin(50. * pos.x) + sin(50. * pos.z));\n    minDist = distSphere(pos, 0.02 + 0.07 * (1. + sin(iTime))) + deform;\n    dist = distSphere(pos - vec3(0.4, 0., 0.), 0.02 + 0.07 * (1. + sin(iTime + 2. * PI / 3.))) + deform;\n    if(dist < minDist){\n    \tminDist = dist;\n        material = 1;\n    }\n    dist = distSphere(pos - vec3( -0.4, 0., 0.), 0.02 + 0.07 * (1. + sin(iTime + 4. * PI / 3.))) + deform;\n    if(dist < minDist){\n    \tminDist = dist;\n        material = 2;\n    }\n    \n    return minDist;\n}\n\nvec3 getNormal(vec3 pos){\n\tint m;\n    return normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.), m) - distScene(pos - vec3(EPSN, 0., 0.), m),\n                           \tdistScene(pos + vec3(0., EPSN, 0.), m) - distScene(pos - vec3(0., EPSN,0.), m),\n                           \tdistScene(pos + vec3(0., 0.,EPSN), m) - distScene(pos - vec3(0., 0., EPSN), m)\n                       \t)\n                    );\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 eye = vec3(0., 0., 4.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    \n    //background\n    vec3 col = vec3(0.2, 0.2, 0.25);\n    \n    //raymarch\n    float step, dist;\n    int material;\n    vec3 pos = eye;\n    bool hit = false;\n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos, material);\n        if(abs(dist) < EPS){\n            hit = true;\n        \tbreak;\n        }\n        pos += ray * dist;\n    }\n    \n    //normal\n    vec3 normal = getNormal(pos);\n    \n    //surface color\n    vec3 baseColor;\n    float colorVariation = 0.5 + 0.5 * sin(3. * sin(3. * (sin(30. * pos.y) + sin(30. * pos.x) + sin(30. * pos.z))));\n    float shine = 5. + 100. * (1. - colorVariation);\n\n    colorVariation = 0.3 + 0.5 * colorVariation;\n   \tcolorVariation += step / STEPS;\n\n    if(material == 0){\n\t\tbaseColor = vec3(colorVariation, 0.33, 0.66);\n    }else if(material == 1){\n    \tbaseColor = vec3(colorVariation, 0.66, 0.33);\n    }else if(material == 2){\n    \tbaseColor = vec3(0.33, colorVariation, 0.66);\n    }\n    \n    //shading\n    vec3 light0 = vec3(2., 2., 0.);\n    float lintensity0 = 0.8;\n    vec3 lcolor0 = vec3(1., 1., 0.6);\n    vec3 light1 = vec3(2., -2., 0.);\n    float lintensity1 = 0.7;\n    vec3 lcolor1 = vec3(0.9, 1., 1.);\n    vec3 light2 = vec3(2., 0., 0.);\n    float lintensity2 = 0.5;\n    vec3 lcolor2 = vec3(1., 0.6, 1.);\n    \n    light0.xz = rot( 2. * iTime) * light0.xz;\n    light1.xz = rot( 2. * iTime + 2. * PI / 3.) * light1.xz;\n    light2.xz = rot( 2. * iTime + 4. * PI / 3.) * light2.xz;\n    \n    if(hit){\n    \tvec3 l = normalize(light0 - pos);\n    \tvec3 e = normalize(eye - pos);\n    \tvec3 r = reflect(-l, normal);\n    \n    \tcol = lintensity0 * vec3(max(dot(normal, l), 0.)) * baseColor * lcolor0; //diffuse\n    \tcol += lintensity0 * vec3(pow(max(dot(r, e), 0.), shine)) * lcolor0; //specular\n        \n        l = normalize(light1 - pos);\n        r = reflect(-l, normal);\n        col += lintensity1 * vec3(max(dot(normal, l), 0.)) * baseColor * lcolor1; //diffuse\n    \tcol += lintensity1 * vec3(pow(max(dot(r, e), 0.), shine)) * lcolor1; //specular\n        \n        l = normalize(light2 - pos);\n        r = reflect(-l, normal);\n        col += lintensity2 * vec3(max(dot(normal, l), 0.)) * baseColor * lcolor2; //diffuse\n    \tcol += lintensity2 * vec3(pow(max(dot(r, e), 0.), shine)) * lcolor2; //specular\n        \n        col += 0.2 * baseColor; //ambient\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.x;\n    uv = rot(0.1 * iTime) * uv;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}