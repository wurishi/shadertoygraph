{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Lumpy displacement creature by @thismatt based on @PauloFalcao's 704 on @P_Malin's\n// blank slate framework.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float rate;\nuniform vec2 mouse;\nvec2 resolution;\nuniform sampler2D backbuffer;\n\n// somehow these enable pan/zoom controls (using magic)\n// uniform vec2 surfaceSize;\n// varying vec2 surfacePosition;\n\nfloat kPI = acos(0.0);\nfloat kHalfPi = asin(1.0);\nfloat kTwoPI;\nvec2 surfaceSize = vec2(0.0, 0.0);\nvec2 surfacePosition = vec2(0.0, 0.0);\n\n// Removed so that it works again\n//float cos(float v) // workaround for AMD Radeon on OS X\n//{\n//  return sin(v+kHalfPi);\n//}\n\n//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_POINT_LIGHT\n//#define FLOATING\n#define ENABLE_POINT_LIGHT_FLARE\n\n#ifdef ENABLE_MONTE_CARLO\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n\nvoid CalcPixelRandom()\n{\n  // Nothing special here, just numbers generated by bashing keyboard\n  vec4 s1 = sin(iTime * 3.3422 + fragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n  vec4 s2 = sin(iTime * 1.3422 + fragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n  gPixelRandom = fract(2142.4 + s1 + s2);\n  gRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n#endif\n\nstruct C_Ray\n{\n  vec3 vOrigin;\n  vec3 vDir;\n};\n\nstruct C_HitInfo\n{\n  vec3 vPos;\n  float fDistance;\n  vec3 vObjectId;\n};\n\nstruct C_Material\n{\n  vec3 cAlbedo;\n  float fR0;\n  float fSmoothness;\n  vec2 vParam;\n};\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n  float s = sin(fAngle);\n  float c = cos(fAngle);\n\n  vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\n  return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n  float s = sin(fAngle);\n  float c = cos(fAngle);\n\n  vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n  return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n  float s = sin(fAngle);\n  float c = cos(fAngle);\n\n  vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n\n  return vResult;\n}\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n  //if(v1.x < v2.x) return v1; else return v2;\n  return mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n  return mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n  return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n  vec3 vResult = vPos;\n  vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n  vTile = floor(vTilePos + 1000.0);\n  vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n  return vResult;\n}\n\nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n  vec3 vResult = vPos;\n  vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n  vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n  return vResult;\n}\n\nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n  vec3 vResult = vPos;\n  vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n  return vResult;\n}\n\nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n  float angle = atan( vPos.x, vPos.z );\n\n  float fScale = fSteps / (kTwoPI);\n  float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\n  float s = sin(-steppedAngle);\n  float c = cos(-steppedAngle);\n\n  vec3 vResult = vec3( c * vPos.x + s * vPos.z,\n    vPos.y,\n    -s * vPos.x + c * vPos.z);\n\n    return vResult;\n  }\n\n  float GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n  {\n    vec2 q = vec2(length(p.xy)-r1,p.z);\n    return length(q)-r2;\n  }\n  float GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n  {\n    vec2 q = vec2(length(p.yz)-r1,p.x);\n    return length(q)-r2;\n  }\n  float GetDistanceCylinderY(const in vec3 vPos, const in float r)\n  {\n    return length(vPos.xz) - r;\n  }\n  float GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n  {\n    vec3 vDist = (abs(vPos) - vSize);\n    return max(vDist.x, max(vDist.y, vDist.z));\n  }\n\n  float GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n  {\n    vec3 vClosest = max(min(vPos, vSize), -vSize);\n    return length(vClosest - vPos) - fRadius;\n  }\n\n  // result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\n  vec4 GetDistanceScene( const in vec3 vPos )\n  {\n    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n    float tt=iTime*(2.0)+10.0;\n    vec4 vDistFloor1 = vec4(vPos.y + sin(vPos.x*0.2) * sin(vPos.z*0.2+tt), 1.0, vPos.xz);\n    vec4 vDistFloor2 = vec4(vPos.y + sin(vPos.x*0.4) * sin(vPos.x+tt), 1.0, vPos.xz);\n    vResult = DistCombineUnion(vResult, vDistFloor1);\n    vResult += DistCombineUnion(vResult, vDistFloor2);\n    return vResult;\n  }\n\n  C_Material matCheckerboard(const in vec3 vPos  ) {\n    C_Material mat;\n    mat.fR0 = 0.01;\n    mat.fSmoothness = 0.0;\n    if (fract(vPos.x*0.5)>0.5)\n    if (fract(vPos.z*0.5)>0.5)\n    mat.cAlbedo=vec3(0,0,0);\n    else\n    mat.cAlbedo=vec3(1,1,1);\n    else\n    if (fract(vPos.z*.5)>.5)\n    mat.cAlbedo = vec3(1,1,1);\n    else\n    mat.cAlbedo = vec3(0,0,0);\n    return mat;\n  }\n\n  C_Material matSphere(const in vec3 vPos) {\n    C_Material mat;\n    // sphere\n    mat.fR0 = 0.5;\n    mat.fSmoothness = 0.9;\n    float tt=iTime*0.05+10.0;\n    float d=length(vPos);\n    // mat.cAlbedo = vec3((sin(d*.25-tt*4.0)+1.0)/2.0,(sin(tt)+1.0)/2.0,(sin(d-tt*4.0)+1.0)/2.0);\n    // sin(1.0*vPos.y+tt)*sin(1.0*vPos.z+tt)\n    float foo = mod(vPos.x*20.0,2.0);\n    mat.cAlbedo = vec3(1.0,1.0,1.0) + sin(vPos.y*2.0+(iTime*2.0))/3.0;\n    return mat;\n  }\n\n  C_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n  {\n    C_Material mat;\n\n    if(vObjId.x < 1.5)\n    {\n      mat.fSmoothness = 1.0;\n      mat.fR0 = 0.00;\n      mat.cAlbedo = vec3(1.0,1.0,1.0);\n      return mat;\n\n    }\n    else\n    if(vObjId.x < 2.5)\n    {\n      return matSphere(vPos);\n    }\n\n    return mat;\n  }\n  vec3 GetSkyGradient( const in vec3 vDir )\n  {\n    float fBlend = vDir.y * 1.0 + 0.5;\n    return mix(vec3(0.3, 0.4, 0.9), vec3(0.0, 0.0, 0.0), fBlend);\n\n  }\n  vec3 GetLightPos()\n  {\n    vec3 vLightPos = vec3(-9.0, 9.0, -10.0);\n    #ifdef ENABLE_MONTE_CARLO\n    vLightPos += gRandomNormal * 0.2;\n    #endif\n    return vLightPos;\n  }\n  vec3 GetLightCol()\n  {\n    return vec3(32.0, 6.0, 1.0) * 10.0;\n  }\n\n  vec3 GetAmbientLight(const in vec3 vNormal)\n  {\n    return GetSkyGradient(vNormal);\n  }\n\n  #define kFogDensity 0.035\n  void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n  {\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(intersection.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    col = mix(cFog, col, 0.6);\n    #endif\n\n\n    // glare from light (a bit hacky - use length of closest approach from ray to light)\n    #ifdef ENABLE_POINT_LIGHT_FLARE\n    vec3 vToLight = GetLightPos() - ray.vOrigin;\n    float fDot = dot(vToLight, ray.vDir);\n    fDot = clamp(fDot, 0.0, intersection.fDistance);\n\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;\n    float fDist = length(vClosestPoint - GetLightPos());\n    col += GetLightCol() * 0.01/ (fDist * fDist);\n    #endif\n  }\n  vec3 GetSceneNormal( const in vec3 vPos )\n  {\n    // tetrahedron normal\n    float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n  }\n\n  #define kRaymarchEpsilon 0.01\n  #define kRaymarchMatIter 256\n  #define kRaymarchStartDistance 0.1\n\n  void Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n  {\n    result.fDistance = kRaymarchStartDistance;\n    result.vObjectId.x = 0.0;\n\n    for(int i=0;i<=kRaymarchMatIter;i++)\n    {\n      result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n      vec4 vSceneDist = GetDistanceScene( result.vPos );\n      result.vObjectId = vSceneDist.yzw;\n\n      if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n      {\n        break;\n      }\n\n      result.fDistance = result.fDistance + vSceneDist.x;\n    }\n\n    if(result.fDistance >= fMaxDist)\n    {\n      result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n      result.vObjectId.x = 0.0;\n      result.fDistance = 1000.0;\n    }\n  }\n\n  float GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n  {\n    C_Ray shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n\n    C_HitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n\n    return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );\n  }\n\n\n  float Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n  {\n    float fDot = dot(vNormal, -vView);\n    fDot = min(max((1.0 - fDot), 0.0), 1.0);\n    float fDot2 = fDot * fDot;\n    float fDot5 = fDot2 * fDot2 * fDot;\n    return fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n  }\n\n  float GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n  {\n    return max(0.0, dot(vLightDir, vNormal));\n  }\n\n  float GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n  {\n    vec3 vHalf = normalize(vLightDir - ray.vDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n\n    float fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n    float fSpecIntensity = (fSpecPower + 4.0) * 0.125;\n\n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n  }\n\n\n  float GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n  {\n    vec3 vPos = intersection.vPos;\n\n    float fAmbientOcclusion = 1.0;\n\n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n      fDist += 0.1;\n\n      vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\n      fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );\n    }\n\n    return fAmbientOcclusion;\n  }\n\n  vec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n  {\n    vec3 cScene ;\n\n    vec3 vSpecularReflection = vec3(0.0);\n    vec3 vDiffuseReflection = vec3(0.0);\n\n    float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n    vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n\n    vDiffuseReflection += vAmbientLight;\n\n    vSpecularReflection += cReflection * fAmbientOcclusion;\n\n    #ifdef ENABLE_POINT_LIGHT\n    vec3 vLightPos = GetLightPos();\n    vec3 vToLight = vLightPos - intersection.vPos;\n    vec3 vLightDir = normalize(vToLight);\n    float fLightDistance = length(vToLight);\n\n    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n\n    float fShadowBias = 0.1;\n    float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );\n    vec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;\n\n    vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;\n    vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n    #endif\n\n    vDiffuseReflection *= material.cAlbedo;\n\n    #ifdef ENABLE_SPECULAR\n    float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n\n    return cScene;\n  }\n\n  vec3 GetSceneColourSimple( const in C_Ray ray )\n  {\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 16.0, 32);\n\n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n      cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n      C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n      vec3 vNormal = GetSceneNormal(intersection.vPos);\n\n\n      vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n\n\n      cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n  }\n\n  vec3 GetSceneColour( const in C_Ray ray )\n  {\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 60.0, 256);\n\n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n      cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n      C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n      vec3 vNormal = GetSceneNormal(intersection.vPos);\n\n      #ifdef ENABLE_MONTE_CARLO\n      vNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n      #endif\n\n      vec3 cReflection;\n      #ifdef ENABLE_REFLECTIONS\n      {\n        // get colour from reflected ray\n        float fSepration = 0.05;\n        C_Ray reflectRay;\n        reflectRay.vDir = reflect(ray.vDir, vNormal);\n        reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n\n        cReflection = GetSceneColourSimple(reflectRay);\n      }\n      #else\n      cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n      #endif\n      // apply lighting\n      cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n  }\n\n  void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)\n  {\n    vec2 vPixelCoord = fragCoord.xy;\n    #ifdef ENABLE_MONTE_CARLO\n    vPixelCoord += gPixelRandom.zw;\n    #endif\n    vec2 vUV = ( vPixelCoord / resolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\n    vViewCoord *= 0.75;\n\n    float fRatio = resolution.x / resolution.y;\n\n    vViewCoord.y /= fRatio;\n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n\n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);\n  }\n\n  void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)\n  {\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n  }\n\n  vec3 OrbitPoint( const in float fHeading, const in float fElevation )\n  {\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n  }\n\n  vec3 Gamma( const in vec3 cCol )\n  {\n    return cCol * cCol;\n  }\n\n  vec3 InvGamma( const in vec3 cCol )\n  {\n    return sqrt(cCol);\n  }\n\n\n  vec3 Tonemap( const in vec3 cCol )\n  {\n    // simple Reinhard tonemapping operator\n    vec3 vResult = cCol / (1.0 + cCol);\n\n    return Gamma(vResult);\n  }\n\n  vec3 InvTonemap( const in vec3 cCol )\n  {\n    vec3 vResult = cCol;\n    vResult = clamp(vResult, 0.01, 0.99);\n    vResult = InvGamma(vResult);\n    return - (vResult / (vResult - 1.0));\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n      resolution = vec2(iResolution.x, iResolution.y);\n      kTwoPI = kPI * 2.0;\n      \n    #ifdef ENABLE_MONTE_CARLO\n    CalcPixelRandom();\n    #endif\n\n    C_Ray ray;\n\n    const float fCamreaInitialHeading = -20.5;\n    const float fCamreaInitialElevation = 0.5;\n    const float fCamreaInitialDist = 20.0;\n    const float fCameraHeight = 0.01;\n    const float fOrbitSpeed = 1.0;\n\n    // This magic stolen from other 3d pan/zoom examples\n    float fZoom = surfaceSize.y * 0.5 + 0.4;\n\n    vec2 vCenterPosition = (0.5 - ( fragCoord.xy / resolution )) * surfaceSize + surfacePosition;\n    float fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;\n    float fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);\n\n    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;\n\n    vCameraPos += vec3(0.0, -fCameraHeight, 0.0);\n    #ifdef ENABLE_MONTE_CARLO\n    float fDepthOfField = 0.001;\n    vCameraPos += gRandomNormal * fDepthOfField;\n    #endif\n\n    GetCameraRayLookat( vCameraPos, vec3(0.0, 0.0, -iTime), fragCoord, ray); // TODO: temporary camera movement\n    //GetCameraRayLookat(vec3(0.0, 0.0, -5.0), vec3(0.0, 0.0, 0.0), ray);\n\n    vec3 cScene = GetSceneColour( ray );\n\n    float fExposure = 10.5;\n    cScene = cScene * fExposure;\n\n    #ifdef ENABLE_MONTE_CARLO\n    vec3 cPrev = texture(backbuffer, fragCoord.xy / resolution).xyz;\n    // add noise to pixel value (helps values converge)\n    cPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\n    cPrev = InvTonemap(cPrev);\n    // converge speep\n    float fBlend = 0.1;\n    vec3 cFinal = mix(cPrev, cScene, fBlend);\n    #else\n    vec3 cFinal = cScene;\n    #endif\n\n    cFinal = Tonemap(cFinal);\n\n    float fAlpha = 1.0;\n\n    fragColor = vec4( cFinal, fAlpha );\n  }\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ts3RN","date":"1419904306","viewed":211,"name":"Land of Gloss","username":"thismatt","description":"Displacement landscape thing based on @PauloFalcao's 704 and @P_Malin's blank slate framework.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""}}