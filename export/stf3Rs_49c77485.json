{"ver":"0.1","info":{"id":"stf3Rs","date":"1622641238","viewed":506,"name":"day_night_switch","username":"skaplun","description":"    CLICK!!!     CLICK!!!\n\nA bit messy but still...\nOriginal animation: shorturl.at/wOPU1\n","likes":50,"published":1,"flags":32,"usePreview":0,"tags":["2d","animation","button","switch","toggle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA (25./max(iResolution.x, iResolution.y))\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nfloat fbm(float x){\n    float y = 0.;\n    // Properties\n    const int octaves = 1;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    //\n    // Initial values\n    float amplitude = 0.5;\n    float frequency = 1.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * noise(vec3(frequency * x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nvec3 hash33(vec3 p3){\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 voronoi(in vec3 x){\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    \tfor( int j=-1; j<=1; j++ )\n    \t\tfor( int i=-1; i<=1; i++ ){\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash33( p + b );\n                float d = dot( r, r );\n\n                if( d < res.x ){\n                    id = dot(p + b, vec3(20.31, 517., 113.));\n                    res = vec2(d, res.x);\n                }else if(d < res.y){\n                    res.y = d;\n                }\n    }\n    return vec2(res.x, abs(id));\n}\n\nconst float PI = acos(-1.);\n\nconst vec3 C_BG_1 = vec3(107., 89., 167.)/255.;\nconst vec3 C_BG_2 = vec3(244., 142., 112.)/255.;\nconst vec3 WHITE = vec3(1.);\n\nconst vec2 MAIN_CONTOUR_BOUND = vec2(2.);\nfloat mainContour(vec2 uv){\n    return mix(abs(uv.y) - MAIN_CONTOUR_BOUND.y,\n               length(abs(uv) - vec2(MAIN_CONTOUR_BOUND.x, 0.)) - MAIN_CONTOUR_BOUND.y, \n               step(MAIN_CONTOUR_BOUND.x, abs(uv.x)));\n}\n\nconst vec3 C_MOON_1 = vec3(1.);\nconst vec3 C_MOON_2 = vec3(253., 226., 187.)/255.;\nconst float MOON_RAD = 1.9;\nvec4 moon(vec2 uv, float phase){\n    vec2 pos = uv - vec2(mix(-MAIN_CONTOUR_BOUND.x, MAIN_CONTOUR_BOUND.x, phase), 0.);\n    float alpha = smoothstep(0., AA, length(pos) - MOON_RAD);\n    vec3 clr = mix(C_MOON_1, C_MOON_2, phase);\n    \n    float ang = phase * PI * .5;\n    pos *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    vec2 v = voronoi(vec3(pos, 1.));\n    float size = hash33(vec3(v.y + .29)).x * .2;\n    float craters = -.2 * smoothstep(size + AA * size, size, v.x);\n    vec2 v2 = voronoi(vec3(pos + vec2(-.5 * size, 0.), 1.));\n    size = hash33(vec3(v.y + .29)).x * .2;\n    craters += .1 * smoothstep(size + AA, size, v2.x) * smoothstep(size + AA, size, v.x);\n    craters *= 1. - phase;\n    \n    return vec4(clr + craters, alpha);\n}\n\nvec2 mpos1 = vec2(2.5, 0.75);\nvec2 mpos2 = vec2(4., 2.5);\nfloat moonsize = 1.;\nfloat moon2(vec2 uv, float phase){\n    vec2 pos = uv - mix(mpos1, mpos2, phase);\n    pos = rotate(pos, -phase);\n    float moon = clamp(smoothstep(0., AA, length(pos) - moonsize), 0., 1.);\n    \n    pos += vec2(.35, -.2);\n    moon += clamp(smoothstep(AA, 0., length(pos) - moonsize), 0., 1.);\n    \n    return clamp(moon, 0., 1.);\n}\n\nvec2 spos1 = vec2(-2.5, 0.5);\nvec2 spos2 = vec2(-.5, -3.5);\nfloat sunsize = .1;\nvec4 sun(vec2 uv, float phase){\n    vec2 pos = uv - mix(spos1, spos2, 1. - phase);\n    pos = rotate(pos, -phase);\n    float sun = length(pos) - sunsize;\n    \n    float a = floor((sun)/.25);\n    \n    return vec4(C_MOON_2, clamp(1. - a * .25, 0., 1.));\n}\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n    vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 l11 = vec3(107., 57., 148.)/255.;\nvec3 l12 = vec3(231., 107., 123.)/255.;\nvec3 l21 = vec3(105., 49., 124.)/255.;\nvec3 l22 = vec3(181., 74., 107.)/255.;\nvec3 l31 = vec3(90., 41., 107.)/255.;\nvec3 l32 = vec3(140., 41., 74.)/255.;\nvec4 landscape(vec2 uv, float phase){\n    vec3 res;\n    float alpha;\n    {\n        float scale = 10.;\n        float x = fract(uv.x * scale);\n        float fx = floor(uv.x * scale);\n        float cx = ceil(uv.x * scale);\n        float f = mix(hash11(fx), hash11(cx), x) + sin(uv.x * (2. + step(0., uv.x) * .5) + 1.5) * .75 * abs(uv.x) - (2. + .1 * step(uv.x, 0.));\n        alpha = smoothstep(f, f + AA * 2., uv.y);\n        res = mix(l11, l12, phase);\n    }\n    \n    float f2 = fbm(uv.x * .5 + 50.) * 2.5 + (uv.x) * .2 - 2.;\n    float s2 = smoothstep(f2, f2 + AA, uv.y);\n    res = mix(res, mix(l31, l32, phase), s2);\n    alpha = min(alpha, s2);\n    \n    \n    float f1 = fbm(uv.x * .5 - 10.) * 2.5 - (uv.x) * .25 - 2.;\n    float s1 = smoothstep(f1, f1 + AA, uv.y);\n    res = mix(mix(l21, l22, phase), res, s1);\n    alpha = min(alpha, s1);\n    \n    return vec4(res, alpha);\n}\n\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fs(vec2 uv, float phase){\n    uv.x += uv.y;\n    uv.x += iTime * 20.;\n    uv *= vec2(.15, 200.);\n    float star = hash12(floor(uv));\n    star = pow(1. - fract(uv.x), 4.) * step(.9995, star);\n    return star * (1. - phase);\n}\n\nconst int star_iterations = 10;\nfloat doBackgroundStars(in vec3 dir){\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                           dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + iTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y * 3.;\n    float phase = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    \n    vec3 bg = mix(C_BG_1, C_BG_2, phase);\n    vec3 foreground = mix(C_BG_1, C_BG_2, pow(phase, 3.));\n    \n    vec3 finalClr = bg;\n    float mainCntr = mainContour(uv);\n    finalClr *= .85 + .15 * smoothstep(0., .5, mainCntr);\n    float mask = smoothstep(0., AA, mainCntr);\n    finalClr = mix(foreground, finalClr, mask);\n    finalClr += doBackgroundStars(vec3(uv * .2, 1.)) * (1. - mask) * (1. - phase);\n    finalClr += fs(rotate(uv, -PI * .25), phase) * (1. - mask) * (1. - phase);\n    finalClr = mix(finalClr, WHITE, (1. - moon2(uv, phase)) * (1. - mask));\n    vec4 sun = sun(uv, phase);\n    finalClr = mix(finalClr, sun.rgb, sun.a * (1. - mask));\n    \n    vec4 landscape = landscape(uv, phase);\n    finalClr = mix(finalClr, landscape.rgb, (1. - landscape.a) * (1. - mask));\n    \n    vec4 moon = moon(uv, phase);\n    finalClr = mix(moon.rgb, finalClr, moon.a);\n    \n    fragColor = vec4(finalClr, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if(int(fragCoord.x) < 2 && \n        int(fragCoord.y) == 0){\n        vec4 state;\n        \n        if(int(fragCoord.x) == 0){\n            if(iFrame == 0){\n                state = vec4(0.);\n            }else{\n                state = texture(iChannel0, vec2(0.));\n                float mouseDown = iMouse.z;\n                float prevMouseState = step(.00001, state.x);\n\n                if(mouseDown != prevMouseState)\n                {\n                    if(mouseDown > .5){\n                        state.x = 1.;\n                        state.y = iTime;\n                    }else{\n                        if(iTime - state.y < .1){\n                            state.z = iTime;\n                            state.w = 1. - state.w;\n                        }\n                        state.x = 0.;\n                        state.y = 0.;\n                    }\n                }else{\n                    state.z = iTime;\n                }\n                fragColor = state;\n            }\n        }else{\n            if(iFrame == 0){\n                fragColor.x = 0.;\n            }else{\n                state = texture(iChannel0, vec2(0.));\n                float time = pow(clamp((iTime - state.z) * 4., 0., 1.), 2.);\n                if(state.w > .5){\n                    fragColor.x = 1. - time;\n                }else{\n                    fragColor.x = time;\n                }\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}