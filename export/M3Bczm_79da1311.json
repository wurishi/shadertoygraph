{"ver":"0.1","info":{"id":"M3Bczm","date":"1731358246","viewed":33,"name":"Modélisation","username":"RouaBouhouch","description":"Source code for ray-tracing assignment : signed distance field representation, basic shading ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"lXXyzj","parentname":"M1 - Ray tracing - 2024"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.09.15\n// Eric Galin\n\nstruct Ray {\n  vec3 o; // Origin\n  vec3 d; // Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n};\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray, float t) {\n  return ray.o + t * ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed, vec3 n) {\n  float a = fract(sin(176.19 * float(seed))); // Uniform randoms\n  float b = fract(sin(164.19 * float(seed)));\n\n  float u = 2. * 3.1415 * a; // Random angle\n  float v = acos(2. * b - 1.); // Arccosine distribution to compensate at poles\n\n  vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); // Direction\n  if (dot(d, n) < 0.) {\n    d = -d;\n  } // Hemisphere\n\n  return d;\n}\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m, vec2 p) {\n  float a = 3. * 3.14 * m.x;\n  float le = 3.5;\n\n  // Origin\n  vec3 ro = vec3(59., 0., 15.);\n  ro *= Rz(a);\n\n  // Target point\n  vec3 ta = vec3(0., 0., 1.);\n\n  // Orthonormal frame\n  vec3 w = normalize(ta - ro);\n  vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n  vec3 v = normalize(cross(u, w));\n  vec3 rd = normalize(p.x * u + p.y * v + le * w);\n  return Ray(ro, rd);\n}\n\n// Primitives -------------------------------------------------------------------------------\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p, vec3 c, float r) {\n  return Val(length(p - c) - r, 1);\n}\n/// Capped cylinder\n// p : point to check for intersection\n// h : height of the cylinder\n// r : radius of the cylinder\n// n : position of the cylinder \nVal sdCappedCylinder(vec3 p, float h, float r, vec3 n) {\n  p = p - n;\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return Val(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 1);\n}\n\n// Ellipsoid\n// p : point to check for intersection\n// r : radii of the ellipsoid (x, y, z axes)\n// n : position of the ellipsoid\nVal sdEllipsoid(vec3 p, vec3 r, vec3 n) {\n  p = p - n;\n  vec3 scaledP = p / r;\n  float k0 = length(scaledP);\n  float k1 = length(scaledP / r);\n  float distance = k0 * (k1 - 1.0);\n  return Val(distance, 1);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 n, vec3 o) {\n  return Val(dot((p - o), n), 1);\n}\n\n// Box\n// p : point to check for intersection\n// b : half-lengths of the box along x, y, z axes\n// n : position of the box\nVal sdBox(vec3 p, vec3 b, vec3 n) {\n  vec3 q = abs(p - n) - b;\n  return Val(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), 2);\n}\n\n// Vertical capsule\n// p : point to check for intersection\n// h : height of the capsule\n// r : radius of the capsule\n// n : position of the capsule\nVal sdVerticalCapsule(vec3 p, float h, float r, vec3 n) {\n  p = p - n;\n  p.y -= clamp(p.y, 0.0, h);\n  return Val(length(p) - r, 1);\n}\n\n// Torus\n// p : point to check for intersection\n// r : radii of the torus\nVal Torus(vec3 p, vec2 r) {\n  float x = length(p.xz) - r.x;\n  float distance = length(vec2(x, p.y)) - r.y;\n  return Val(distance, 1);\n}\n\n//-----------------------OPERATOR------------------------------------------------\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c)\n  );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\n// Transformation Matrix\nmat3 Transform(vec3 t) {\n  return mat3(\n    vec3(t.x, 0, 0),\n    vec3(0, t.y, 0),\n    vec3(0, 0, t.z)\n\n  );\n}\n\n// Identity matrix.\nmat3 identity() {\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nvec3 Rotate_pX(vec3 p, float angle) {\n  mat3 rotationMatrix = rotateX(angle);\n  return rotationMatrix * p;\n}\n\nvec3 Rotate_pY(vec3 p, float angle) {\n  mat3 rotationMatrix = rotateY(angle);\n  return rotationMatrix * p;\n}\n\nvec3 Rotate_pZ(vec3 p, float angle) {\n  mat3 rotationMatrix = rotateZ(angle);\n  return rotationMatrix * p;\n}\n\nvec3 Translate(vec3 p, vec3 t) {\n  return p + t;\n}\n\n// Union\nVal Union(Val a, Val b) {\n  float distance = min(a.v, b.v);\n  int texture = (a.v < b.v) ? a.c : b.c;  // Retain the texture of the object that contributes the surface\n  return Val(distance, texture);\n}\n\n// Intersection\nVal Intersection(Val a, Val b) {\n  float distance = max(a.v, b.v);\n  int texture = (a.v > b.v) ? a.c : b.c;  // Retain the texture of the object that contributes the surface\n  return Val(distance, texture);\n}\n\n// Minus\nVal Minus(Val a, Val b) {\n  Val negB = Val(-b.v, b.c);\n  return Intersection(a, negB);  // Preserve the texture of a\n}\n\n// Smooth union for Val\nVal opSmoothUnion(Val a, Val b, float k) {\n  float h = clamp(0.5 + 0.5 * (b.v - a.v) / k, 0.0, 1.0);\n  float distance = mix(b.v, a.v, h) - k * h * (1.0 - h);\n  int texture = (a.v < b.v) ? a.c : b.c;  // Retain the texture of the object that contributes the surface\n  return Val(distance, texture);\n}\n\n\n//---------------------TEXTURES AND NOISE---------------------------------------\n\n// Procedural Noise\n// p : point to sample the noise\nfloat Hash(in vec3 p) {\n  p = fract(p * 0.3199 + 0.152);\n  p *= 17.0;\n  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n// Procedural value noise with cubic interpolation\n// p : Point\nfloat Noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Apply cubic interpolation on fractional part\n    f = f * f * (3.0 - 2.0 * f);\n\n    // Precompute the offsets for the corners of the grid\n    vec3 offset[8] = vec3[8](\n        vec3(0, 0, 0), vec3(1, 0, 0), vec3(0, 1, 0), vec3(1, 1, 0),\n        vec3(0, 0, 1), vec3(1, 0, 1), vec3(0, 1, 1), vec3(1, 1, 1)\n    );\n\n    // Compute the noise values for each corner\n    float corner[8];\n    for (int j = 0; j < 8; ++j) {\n        corner[j] = Hash(i + offset[j]);\n    }\n\n    // Interpolate in x direction\n    float interpX0 = mix(corner[0], corner[1], f.x);\n    float interpX1 = mix(corner[2], corner[3], f.x);\n    float interpX2 = mix(corner[4], corner[5], f.x);\n    float interpX3 = mix(corner[6], corner[7], f.x);\n\n    // Interpolate in y direction\n    float interpY0 = mix(interpX0, interpX1, f.y);\n    float interpY1 = mix(interpX2, interpX3, f.y);\n\n    // Final interpolation in z direction\n    return mix(interpY0, interpY1, f.z);\n}\n\n\n// Turbulence - Adds fractal-like behavior to the noise using multiple octaves\n// p : Point in 3D space to sample the turbulence\n// octaves : Number of iterations to generate the fractal-like effect\n// Turbulence function with adjustable octaves\nfloat turbulence(vec3 p, int octaves) {\n    float totalTurbulence = 0.0;\n    float frequency = 1.0;\n    float intensity = 1.0;\n\n    // Define rotation matrix coefficients\n    const float rotationAngle = 0.866;  \n    const float rotationZ = 0.5;        \n    \n    for (int i = 0; i < octaves; ++i) {\n        // Add the noise contribution for this octave\n        totalTurbulence += abs(Noise(p * frequency) / frequency);\n        \n        // Adjust frequency and intensity for the next octave\n        frequency *= 2.07;\n        intensity *= 0.5;\n        \n        // Rotate the point for the next octave\n        p = vec3(rotationAngle * p.x + rotationZ * p.z, \n                 p.y + 100.0, \n                 -rotationZ * p.z + rotationAngle * p.z);\n    }\n\n    return totalTurbulence;\n}\n\n\nfloat Turbulence(in vec3 p, in int octaves, in float base, in float amplitude, in float length) {\n    float totalNoise = 0.0;\n    mat3 Q = Rz(0.);\n    int i = 0;\n\n    while (i < octaves) {\n        float scaleFactor = pow(base, -float(i));\n\n        amplitude *= scaleFactor;\n        length *= scaleFactor;\n\n        vec3 transformedP = (Q * p) / length;\n        totalNoise += amplitude * Noise(transformedP);\n\n        Q = matrixCompMult(Q, Q);\n        ++i;\n    }\n\n    return totalNoise;\n}\n\n\n// TEXTURE - Marble texture using procedural noise and turbulence\n// p : Point in 3D space to sample the marble texture\nvec3 MARBLE(in vec3 p) {\n  return vec3(0.82, 0.91, 0.90) * turbulence(p, 8);\n}\n\n// GRASS function with turbulence applied\nvec3 GRASS(in vec3 p) {\n    vec3 grassColor = vec3(20.0 / 255.0, 148.0 / 255.0, 20.0 / 255.0);\n    float noiseValue = Noise(p * 20.0);        \n    float turbulenceValue = turbulence(p, 6);   \n    return grassColor * noiseValue * turbulenceValue;\n}\n\n// GRASS function with NOISE applied\nvec3 SAND(in vec3 p)\n{\n    vec3 yellowColor = vec3(1.0, 0.9, 0.4); \n    return yellowColor * Noise(p * 20.0);\n}\n\n// WOOD function with turbulence applied\nvec3 WOOD(in vec3 p) {\n    float t = 1.0;\n    int o = 5;\n    vec3 m = vec3(0.6, 0.4, 0.2);\n    vec3 n = vec3(0.8, 0.6, 0.3);\n    float c = 0.5;\n\n    vec3 pt = p - (Turbulence(p, o, 2.0, 2.8, 4.8) * (1.0 / t)); \n    float b = (sin(3.14 * sqrt(pt.x * pt.x + pt.y * pt.y)) + 1.0) / 2.0;\n\n    m = mix(c * m, (1.0 - c) * m, \n            Turbulence(vec3(pt.x, pt.y, pt.z), 3, 2.0, 0.9, 2.5) * (2.0 - 0.7 * Noise(40.0 * pt))); \n    n = mix(c * n, (1.0 - c) * n, \n            Turbulence(vec3(15.0 * pt.x, 200.0 * pt.y, pt.z), 4, 2.0, 0.8, 2.5) * (1.0 - 0.7 * Noise(110.0 * pt)));\n\n    return (1.0 - b) * m + b * n;\n}\n\n// holes texture\nfloat HoleTexture(vec3 p, float holeRadius, float spacing) {\n    vec3 gridPoint = mod(p + 0.5 * spacing, spacing) - 0.5 * spacing;\n    float distanceToHole = length(gridPoint) - holeRadius;\n    return distanceToHole;\n}\n\n// PEARLS function applied to an object\nVal PEARLS(Val objVal, vec3 p, float holeRadius, float spacing) {\n    float holes = HoleTexture(p, holeRadius, spacing);\n    return Val(max(objVal.v, holes), objVal.c);\n}\n\n// pseudo-random function\nfloat random(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// FROMAGE function applied to an object\nVal FROMAGE(Val obj, vec3 p, float holeDensity, float holeRadius) {\n    vec3 gridPosition = floor(p / holeDensity);\n    if (random(gridPosition) > 0.5) {  // Adjust this threshold to control hole density\n        vec3 holeCenter = gridPosition * holeDensity + vec3(random(gridPosition + vec3(1.0)), random(gridPosition + vec3(2.0)), random(gridPosition + vec3(3.0))) * holeDensity;\n        Val hole = Sphere(p, holeCenter, holeRadius);\n        obj = Intersection(obj, hole);\n    }\n    \n    return obj;\n}\n\n//-------------------COMPLEX OBJECTS--------------------------------------------\n\n// Prisme\n// p : point to check for intersection\n// o : center of the prisme\n// r : scale factor\nVal Prisme(vec3 p, vec3 o, float r) {\n  return Intersection(\n    Plane(p, vec3(0.0, 0.866, 0.5), o + vec3(r, 0.0, 0.0)),\n    Intersection(\n      Plane(p, vec3(0.0, -0.866, 0.5), o + vec3(r, 0.0, 0.0)),\n      Intersection(\n        Plane(p, vec3(0.866, 0.0, 0.5), o + vec3(r, 0.0, 0.0)),\n        Intersection(\n          Plane(p, vec3(-0.866, 0.0, 0.5), o + vec3(r, 0.0, 0.0)),\n          Plane(p, vec3(0, 0, -1), vec3(0, 0.0, 0.0)) // Le plan supérieur\n        )\n      )\n    )\n  );\n}\n\n\n// Potential field of the object\n// p : point\nVal object(vec3 p) {\n  float turbulenceStrength = 2.;\n  float turb = turbulence(p, 1);\n\n  float theta = 0.5;\n  vec3 rotatedPosition = Rotate_pX(p, theta);\n  vec3 rotatedPosition2 = Rotate_pX(p, -theta);\n  vec3 rotatedPosition3 = Rotate_pX(p, 3.14159265359 / 2.0);\n\n  Val v = sdBox(p, vec3(7.5, 7.5, 7.5), vec3(0.5, 0.125, 0.0));\n  v.c = 1;\n\n  Val floor = Plane(p, vec3(0., 0., 1.), vec3(0.0, 0.0, -4.0));\n  floor.c = 2;\n  v = Union(v, floor);\n\n  Val roofPrism1 = sdBox(rotatedPosition, vec3(7.5, 7.5, 7.5), vec3(0.5, 0.125, 14.0));\n  roofPrism1.c = 4;\n  v = Minus(v, roofPrism1);\n\n  Val roofPrism2 = sdBox(rotatedPosition2, vec3(7.5, 7.5, 7.5), vec3(0.5, 0.125, 14.0));\n  roofPrism2.c = 4;\n  v = Minus(v, roofPrism2);\n\n  Val additionalStructure1 = sdBox(p, vec3(3, 2.5, 2.5), vec3(6.5, 0.125, 0.0));\n  additionalStructure1.c = 4;\n  v = Union(v, additionalStructure1);\n\n  Val additionalStructure2 = sdCappedCylinder(rotatedPosition3, 1.0, 3.5, vec3(15.5, 0.125, 10.0));\n  additionalStructure2.c = 1;\n  v = Union(v, additionalStructure2);\n\n  Val additionalStructure3 = sdCappedCylinder(rotatedPosition3, 1.0, 3.5, vec3(15.5, 0.125, 10.0));\n  additionalStructure3.c = 6;\n  v = Union(v, additionalStructure3);\n\n  float noiseStrength = 0.5;\n  float noiseValue = Noise(p * 2.0);\n  float deformedRadius = 3.25 + noiseStrength * noiseValue;\n  Val noiseSphere = Sphere(rotatedPosition3, vec3(15.5, 3.125, 10.0), deformedRadius);\n  noiseSphere.c = 3;\n  v = Union(v, noiseSphere);\n\n  Val prisme = Prisme(p + vec3(0., 0., 3.9), vec3(1.5, 15., 10.0), -2.);\n  prisme.c = 5;\n  v = Union(v, prisme);\n\n  vec3 columnPosition = p + vec3(25.0, 0.0, 0.0);\n  float deformedHeight = 10.0 + turbulenceStrength * (turb);\n  Val column = sdCappedCylinder(columnPosition, 1.5 + turb, deformedHeight, vec3(12.0, 0.0, 5.0));\n  column.c = 1;\n  v = Union(v, column);\n\n  // Ajout du torus\n  vec3 torusPosition = p + vec3(11.0, 10.0, -30.0);  \n  vec2 torusRadii = vec2(10.0, 2.0); \n  Val torusVal = Torus(  Rotate_pZ(p, 3.14159265359 / 2.0)\n + torusPosition, torusRadii);  \n  torusVal.c = 4;  \n  v = Union(v, torusVal);  \n  \n  Val prisme2 = Prisme(p + vec3(0., 0., 3.9), vec3(1.5, -25., 10.0), -2.); // Original shape\n  Val prisme2pearls = PEARLS(prisme2, p, 0.2, 0.7); \n  prisme2pearls.c = 5;\n  v = Union(v, prisme2pearls);\n  \n  Val table = sdBox(p, vec3(9., 5.5, 0.5), vec3(5.5, 0.125, -4.));\n  Val tableFromage = FROMAGE(table, p, 1., 0.5); \n  tableFromage.c = 3;\n  v = Union(v, tableFromage);\n  \n  Val sphere = Sphere(p, vec3(-1.0, -10.0, 15.0), 3.0);\n  Val sun = PEARLS(sphere, p, 0.2, 0.7);\n  sun.c = 4;\n  v = Union(v, sun);\n  return v;\n}\n\n\n\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\nconst int Steps = 200; // Number of steps\nconst float Epsilon = .01; // Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p) {\n  const float eps = .001;\n  vec3 n;\n  Val val = object(p);\n  float v = val.v;\n  n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n  n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n  n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c) {\n  bool h = false;\n\n  // Start at the origin\n  t = 0.0;\n  c = 0;\n\n  for (int i = 0; i < Steps; i++) {\n    s = i;\n    vec3 p = Point(ray, t);\n    Val val = object(p);\n    float v = val.v;\n    c += val.c;\n    // Hit object\n    if (v < 0.) {\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, v);\n    // Escape marched too far away\n    if (t > e) {\n      break;\n    }\n  }\n  return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n// Background color\n// ray : Ray \nvec3 background(Ray ray) {\n  return mix(vec3(.45, .55, .99), vec3(.65, .69, .99), ray.d.z * .5 + .5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p, vec3 n, vec3 l) {\n  float t;\n  int s;\n  int c;\n  bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c);\n  if (!hit) {\n    return 1.;\n  }\n  return 0.;\n}\n\nvec3 texturing(vec3 p)\n{\n    Val vp= object(p);\n    if (vp.c==2){\n       \n        return MARBLE(p);\n        \n        }\n            if (vp.c==3){\n       \n        return GRASS(p);\n        \n        }\n        if (vp.c==4)\n        {\n        return vec3(.0,.5,.5);\n        }\n        if (vp.c==5){\n       \n        return SAND(p);\n        \n        }\n         if (vp.c==6){\n\n        \n\n        return  WOOD(p);        \n        }\n         return vec3(1.,1.,1.);\n} \n\n// Phong shading with reflections: Calculates ambient, diffuse, specular lighting\nvec3 Shade(vec3 p, vec3 n, Ray eye, int maxReflections) {\n  // Point light position\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  // Light direction to point light\n  vec3 l = normalize(lp - p);\n  vec3 textureColor = texturing(p);\n\n  // Ambient color\n  vec3 ambient = 0.25 + 0.25 * background(Ray(p, n)) * textureColor;\n\n  // Shadow computation\n  float shadow = Shadow(p, n, l);\n\n  // Phong diffuse shading\n  vec3 diffuse = 0.35 * clamp(dot(n, l), 0.0, 1.0) * vec3(1.0, 1.0, 1.0) * textureColor;\n\n  // Specular reflection (shininess factor is 35)\n  vec3 r = reflect(eye.d, n);\n  vec3 specular = 0.15 * pow(clamp(dot(r, l), 0.0, 1.0), 35.0) * vec3(1.0, 1.0, 1.0) * textureColor;\n\n  // Initialize the reflection color\n  vec3 reflectionColor = vec3(0.0);\n  vec3 reflectionRayDir = r;\n\n  // Iterative reflection handling (up to maxReflections)\n  for (int i = 0; i < maxReflections; i++) {\n    Ray reflectedRay = Ray(p + Epsilon * n, reflectionRayDir);  // Reflect the ray\n    float t;\n    int s;\n    int c;\n    bool hit = SphereTrace(reflectedRay, 100.0, t, s, c);  // Trace reflected ray\n    if (hit) {\n      vec3 reflectedPoint = Point(reflectedRay, t);\n      vec3 reflectedNormal = ObjectNormal(reflectedPoint);\n\n      // Calculate reflection at this point (do not call Shade recursively)\n      vec3 reflectionDiffuse = 0.35 * clamp(dot(reflectedNormal, l), 0.0, 1.0) * vec3(1.0, 1.0, 1.0) * textureColor;\n      vec3 reflectionSpecular = 0.15 * pow(clamp(dot(reflectedRay.d, reflectedNormal), 0.0, 1.0), 35.0) * vec3(1.0, 1.0, 1.0) * textureColor;\n\n      reflectionColor += reflectionDiffuse + reflectionSpecular;\n    }\n    // Adjust reflection direction for the next iteration (optional, could simulate reflection loss)\n    reflectionRayDir = reflect(reflectionRayDir, n);\n  }\n\n  // Blend reflection with the rest of the shading (ambient, diffuse, specular)\n  vec3 color = ambient + shadow * (diffuse + specular);\n\n  // Blend reflection based on a factor (0.3 for this example)\n  float reflectionFactor = 0.3;\n  color = mix(color, reflectionColor, reflectionFactor);\n\n  return color;\n}\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n, int m) {\n  float t = float(n) / (float(m));\n  return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy) {\n  // Convert pixel coordinates\n  vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n\n  // Mouse\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  // Camera\n  Ray ray = CreateRay(m, pixel);\n\n  // Trace ray\n\n  // Hit and number of steps\n  float t = 0.0;\n  int s = 0;\n  int c;\n  bool hit = SphereTrace(ray, 100., t, s, c);\n\n  // Shade background\n  vec3 rgb = background(ray);\n\n  if (hit) {\n    // Position\n    vec3 p = Point(ray, t);\n\n    // Compute normal\n    vec3 n = ObjectNormal(p);\n\n    // Shade object with light\n    rgb = Shade(p, n, ray, 1);  // Max reflections depth is set to 1\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb=ShadeSteps(s,Steps);\n\n  // Uncomment this line to shade cost\n  //rgb=ShadeSteps(c,500);\n  color = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}