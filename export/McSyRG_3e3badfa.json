{"ver":"0.1","info":{"id":"McSyRG","date":"1722489573","viewed":40,"name":"Donut for the coffee","username":"vschwaberow","description":"Some donut for my coffee","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["retro","amiga"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 palette[8] = vec3[8](\n    vec3(0.05, 0.05, 0.10),\n    vec3(0.10, 0.15, 0.25),\n    vec3(0.20, 0.30, 0.50),\n    vec3(0.30, 0.45, 0.70),\n    vec3(0.40, 0.60, 0.90),\n    vec3(0.50, 0.70, 1.00),\n    vec3(0.70, 0.80, 0.90),\n    vec3(0.90, 0.95, 1.00)\n);\n\n\nfloat dither4x4(vec2 position, float brightness) {\n    int x = int(mod(position.x, 4.0));\n    int y = int(mod(position.y, 4.0));\n    int index = x + y * 4;\n    float limit = 0.0;\n\n    if (x < 4) {\n        if (index == 0) limit = 0.0625;\n        if (index == 1) limit = 0.5625;\n        if (index == 2) limit = 0.1875;\n        if (index == 3) limit = 0.6875;\n        if (index == 4) limit = 0.8125;\n        if (index == 5) limit = 0.3125;\n        if (index == 6) limit = 0.9375;\n        if (index == 7) limit = 0.4375;\n        if (index == 8) limit = 0.25;\n        if (index == 9) limit = 0.75;\n        if (index == 10) limit = 0.125;\n        if (index == 11) limit = 0.625;\n        if (index == 12) limit = 1.0;\n        if (index == 13) limit = 0.5;\n        if (index == 14) limit = 0.875;\n        if (index == 15) limit = 0.375;\n    }\n\n    return brightness < limit ? 0.0 : 1.0;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 pixelSize = vec2(6.0, 6.0);\n    vec2 pixelCoord = floor(fragCoord / pixelSize);\n    vec2 pixelCenter = (pixelCoord + 0.5) * pixelSize;\n    \n\n    vec3 cameraPos = vec3(0.0, 0.0, 3.0);\n    vec3 lookAt = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n\n    vec3 cameraForward = normalize(lookAt - cameraPos);\n    vec3 cameraRight = normalize(cross(up, cameraForward));\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n\n    vec3 rayDir = normalize(uv.x * cameraRight + uv.y * cameraUp + 2.0 * cameraForward);\n    \n\n    float torusMajorRadius = 1.0;\n    float torusMinorRadius = 0.4;\n    \n\n    float time = iTime * 0.5;\n    mat3 rotX = rotationMatrix(vec3(1.0, 0.0, 0.0), sin(time * 0.5) * 3.14159);\n    mat3 rotY = rotationMatrix(vec3(0.0, 1.0, 0.0), cos(time * 0.7) * 3.14159);\n    mat3 rotZ = rotationMatrix(vec3(0.0, 0.0, 1.0), sin(time * 0.3) * 3.14159 / 2.0);\n    mat3 rotation = rotX * rotY * rotZ;\n    \n\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = cameraPos + rayDir * t;\n        p = rotation * p;\n        \n        float noise = sin(time * 2.0 + p.x * 10.0) * cos(time * 3.0 + p.y * 10.0) * sin(time * 1.5 + p.z * 10.0);\n        p += normalize(p) * noise * 0.05;\n        \n        float d = sdTorus(p, vec2(torusMajorRadius, torusMinorRadius));\n        if (abs(d) < 0.001 || t > 10.0) break;\n        t += d;\n    }\n    \n\n    if (t < 10.0) {\n        vec3 p = cameraPos + rayDir * t;\n        p = rotation * p;\n        vec3 normal = normalize(p - vec3(torusMajorRadius, 0.0, 0.0) * normalize(vec3(p.x, 0.0, p.z)));\n        \n        vec3 light = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n        vec3 viewDir = normalize(-p);\n        vec3 reflectDir = reflect(-light, normal);\n        \n        float ambient = 0.2;\n        float diffuse = max(dot(normal, light), 0.0);\n        float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n        \n        float intensity = ambient + diffuse + 0.5 * specular;\n        \n        int colorIndex = int(intensity * 7.0);\n        vec3 color = palette[colorIndex];\n        \n\n        float ditheredIntensity = dither4x4(fragCoord, intensity);\n        color *= ditheredIntensity;\n        \n\n        float scanline = 0.97 + 0.03 * sin(uv.y * iResolution.y * 3.14159 / pixelSize.y);\n        color *= scanline;\n        \n\n        if (mod(floor(uv.y * iResolution.y / pixelSize.y), 2.0) < 0.5) {\n            color *= 0.95;\n        }\n        \n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}","name":"Image","description":"","type":"image"}]}