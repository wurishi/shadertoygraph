{"ver":"0.1","info":{"id":"Ml3XWX","date":"1482097471","viewed":1272,"name":"Tamby's Snowflakes","username":"TambakoJaguar","description":"A 3D, not really realistic but artistic presentation of falling snow... Please tell me what you think! :)\nUse the mouse to rotate around.\nI know if could be optimized to be faster...","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["3d","bokeh","star","falling","snow","snowflakes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Tamby's Snowflakes\" by Emmanuel Keller aka Tambako - December 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define diffraction\n#define sin_movement\n#define star_flakes\n\n// Campera parameters\nvec3 campos;\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 3.8;\n\nconst vec3 skyColor = vec3(0.7, 0.73, 0.78);\nconst float fogdens = 0.08;\n\n// Snow parameters\nconst vec3 snowColor = vec3(0.9, 0.95, 1.0);\nconst int nbFlakes = 1000;\nconst float flakeGlobalIntensity = 1.8;\nconst vec3 flakedomain = vec3(10., 7., 10.);\nconst float flakeMinSpeed = 1.7;\nconst float flakeMaxSpeed = 4.2;\nconst float flakeMinSinVariation = 0.02;\nconst float flakeMaxSinVariation = 0.07;\nconst float flakeMinFreq = 5.;\nconst float flakeMaxFreq = 12.;\nconst vec2 flakeWindFact = vec2(0.45, 0.08);\n\n// Some parameters of the star of orbs\nconst float starNbBranches = 6.;\nconst float starPow = 1.5;\nconst float starStrength = 1.2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec3 colorRamp3(vec3 col1, vec3 col2, vec3 col3, float v)\n{\n   return mix(mix(col1, col2, smoothstep(0.0, 0.5, v)), col3, smoothstep(0.5, 1.0, v));   \n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return skyColor*(1. + 0.35*ray.y);\n}\n\nfloat rand(float min, float max, float seed)\n{\n    return min + (max - min)*hash(seed);\n}\n\nvec3 getFlakePosition(int flakeNr, float t)\n{\n    float fn = float(flakeNr);\n    float s = rand(flakeMinSpeed, flakeMaxSpeed, fn*348. + 173.);\n    float posY = mod(-(t + 15.*hash(fn*1613. + 1354.))*s, flakedomain.y*2.) - flakedomain.y;\n    float posX = rand(-flakedomain.x, flakedomain.x, fn*743. + 514.) + posY*flakeWindFact.x;\n    float posZ = rand(-flakedomain.z, flakedomain.z, fn*284. + 483.) + posY*flakeWindFact.y;\n\n    #ifdef sin_movement\n    float sinvar = rand(flakeMinSinVariation, flakeMaxSinVariation, fn*842. + 951.);\n    float sinfreq = rand(flakeMinFreq, flakeMaxFreq, fn*348. + 173.);\n    float dd = hash(fn*235. + 934.);\n    posX+= sinvar*sin(t*sinfreq)*dd;\n    posZ+= sinvar*sin(t*sinfreq)*sqrt(1. - dd*dd);\n    #endif\n    \n    vec3 pos = vec3(posX, posY, posZ);\n    return pos;\n}\n\nfloat nppow(float x, float p)\n{\n    return sign(x)*pow(abs(x), p);   \n}\n\nfloat getSnowProfile(float val, float dist, vec3 fpos, vec3 ray, int flakeNr)\n{\n    float val2 = -log(1. - val);\n    \n    #ifdef star_flakes\n    // Complicated stuff to calculate the star shape of the snow flakes by making a 3D to 2D projection\n    // From: http://stackoverflow.com/questions/23472048/projecting-3d-points-to-2d-plane\n    if (dist<1.2)\n    {\n        vec3 v3 = (fpos - campos) - dot((fpos - campos), ray) * ray;\n        vec3 vx = vec3(1., 0., 0.);\n        vx.xy = rotateVec(vx.xy, 2.*float(flakeNr)*152.5 + iTime*0.4);\n        vx = normalize(vx - dot(vx, ray)*ray);\n        vec3 vy = vec3(ray.y*vx.z - ray.z*vx.y, ray.z*vx.x - ray.x*vx.z, ray.x*vx.y - ray.y*vx.x);\n\n        float a = atan(dot(v3, vx)/dot(v3, vy));\n\n        float spp = 1. + starStrength*nppow(sin(a*starNbBranches), starPow);\n        val2+= 1.3*spp*pow(smoothstep(1.6, 0.1, dist), 2.0);\n    }\n    #endif  \n    \n    float delta = 1.5 - 0.9/pow(dist + 1., 0.3);\n    float midpoint = 10./pow(dist + 0.1, 0.3);\n    float pr = smoothstep(midpoint - delta*.5, midpoint + delta*.5, val2);\n    \n    float d = 1. - pow(abs(1. - 2.*pr), 2.);\n    float f = 1.3/(pow(dist + .8, 2.5));\n    \n    #ifdef diffraction\n    if (val2<8.)\n       pr+= 32.*pow(f, 1.5)*max(0., dist - 2.)*d*(0.5 + sin(val2*230./(3.8 + dist) - midpoint*90.)*0.5);\n    #endif\n    \n    return pr*f*flakeGlobalIntensity;\n}\n\nvec3 getFlakes(vec3 ray)\n{\n\tvec3 rc1 = vec3(0.);\n    vec3 rc2 = vec3(0.);\n    float lintensity;\n    vec3 fpos;\n    float lp;\n    \n    for (int l=0; l<nbFlakes; l++)\n    {\n        fpos = getFlakePosition(l, iTime);\n        \n        float val = max(0.0, dot(ray, normalize(fpos - campos)));\n        if (val>0.996)\n        {\n            float dist1 = distance(camtarget, fpos);\n            float dist2 = distance(campos, fpos);\n            float dist = max(5.2*pow(dist1 / dist2, 1.7), 0.32);\n            lp = getSnowProfile(val, dist, fpos, ray, l);\n\n            // Fog\n            lp*= clamp(exp(-pow(fogdens*dist2, 2.)), 0., 1.);\n        \n            // Flakes appear progressively in the domain along the y axis\n            lp*= smoothstep(-flakedomain.y, -flakedomain.y*0.75, fpos.y);\n            lp*= smoothstep(flakedomain.y, flakedomain.y*0.75, fpos.y);\n\n            rc1+= clamp(normalize(mix(snowColor, vec3(1.), 0.55*lp))*lp, 0., 1.);\n            rc2 = max(rc2, clamp(normalize(mix(snowColor, vec3(1.), 0.55*lp))*lp, 0., 1.));\n        }\n        else\n           lp = 0.;\n    }\n    return mix(rc1, rc2, 0.7);\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 4.;\nconst float aym = 1.5;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, -iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, -iMouse2.x*axm);\n\n   camtarget = vec3(0.);\n   camdir = camtarget - campos;   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    setCamera();\n    \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n    vec3 col = sky_color(ray);\n    col+= getFlakes(ray);\n\n  \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}