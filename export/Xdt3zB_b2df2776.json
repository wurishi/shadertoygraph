{"ver":"0.1","info":{"id":"Xdt3zB","date":"1451293295","viewed":435,"name":"Disintegration","username":"And390","description":"Sphere morphing and space transformation.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["transformation","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define DIRECT_LIGHT vec3(1.0, 1.0, -1.0)\nconst float directLight = 0.7;\nconst float ambientLight = 0.4;\nconst int lightsCount = 0;\nconst float lightPower = 0.7;\nconst float lightSpeed = 1.0;\nconst float epsilon = 0.0001;\n\n#define RAYMARCHING_STEPS 100\n\nfloat PI = acos(-1.);\n\n\n//        ----  system time stages  ----\n\nconst float split1Duration = 4.;\nconst float stay1Duration = 0.;\nconst float translate1Duration = 6.;\nconst float merge1Duration = 2.;\nconst float lift1Duration = 12.;\n\nconst float split1Time = 0.;\nconst float split1TimeEnd = split1Time + split1Duration;\nconst float stay1Time = split1TimeEnd;\nconst float stay1TimeEnd = stay1Time + stay1Duration;\nconst float translate1Time = stay1TimeEnd;\nconst float translate1TimeEnd = translate1Time + translate1Duration;\nconst float merge1Time = translate1TimeEnd;\nconst float merge1TimeEnd = merge1Time + merge1Duration;\nconst float lift1Time = merge1TimeEnd;\nconst float lift1TimeEnd = lift1Time + lift1Duration;\n\nconst float totalDuration = lift1TimeEnd;\n\n\n//        ----  dimensions  ----\n\nconst float groundY = -1.5;\n\nconst vec3 spherePos = vec3(-2., 0., 0.);\nconst float sphereRad = 1.;\n\n\n//        ----  space transformation  ----\n\nconst float trans1FrameLen = 1.0;\nconst float trans1Value = -spherePos.x * 2.;\n\nconst float lift1FrameLen = sphereRad;\n\nfloat sinStep(float x) {\n    return sin(x-0.5)*PI * 0.5 + 0.5;\n}\n\nfloat getTrans1FrameStart(vec3 p, float time) {\n    float t = sinStep((time - translate1Time) / translate1Duration);\n    return spherePos.x + sphereRad - t * (sphereRad*3. + trans1FrameLen) + max(abs(p.y), abs(p.z));\n}\n\nfloat getLift1FrameStart(float time) {\n    float t = (time - lift1Time) / lift1Duration;\n    return spherePos.y + sphereRad - t * (sphereRad * 2. + lift1FrameLen*2.);\n}\n\nvec3 transform(vec3 p, float time) {\n    if (time > translate1Time && time < translate1TimeEnd) {\n        float transFrameStart = getTrans1FrameStart(p, time);\n        float transFrameEnd = transFrameStart + trans1FrameLen;\n        if (p.x < transFrameStart)  ;  //nothing\n        else if (p.x < transFrameEnd)\n            p.x += trans1Value * (p.x-transFrameStart)/trans1FrameLen;\n        else   p.x += trans1Value;\n    }\n    else if (time >= translate1TimeEnd && time < lift1Time) {\n        p.x += trans1Value;\n    }\n    else if (time >= lift1Time && time < lift1TimeEnd) {\n        float frameStart = getLift1FrameStart(time);\n        float frameLen = lift1FrameLen;\n        if (p.y > frameStart + frameLen*2.) {\n            p.y = spherePos.y * 2. - p.y;\n        } else if (p.y > frameStart + frameLen) {\n            float up = (frameStart + 2.*frameLen - p.y) / frameLen;\n            p.y = spherePos.y*2. - (frameStart + frameLen*2.) + (1. / (1. - up) - 1.);\n        } else if (p.y > frameStart) {\n            float up = (p.y - frameStart) / frameLen;\n            p.y = frameStart + 1. / (1. - up) - 1.;\n            p.x += trans1Value;\n        } else {\n            p.x += trans1Value;\n        }\n    }\n    return p;\n}\n\nvec3 reverseTransform(vec3 p, float time) {\n    if (time > translate1Time && time < translate1TimeEnd) {\n        float transFrameStart = getTrans1FrameStart(p, time);\n        float transFrameEnd = transFrameStart + trans1FrameLen;\n        if (p.x < transFrameStart)  ;  //nothing\n        else if (p.x < transFrameEnd+trans1Value)\n            p.x -= trans1Value * (p.x-transFrameStart)/(trans1FrameLen+trans1Value);\n        else   p.x -= trans1Value;\n    }\n    else if (time >= translate1TimeEnd && time < lift1Time) {\n        p.x -= trans1Value;\n    }\n    else if (time >= lift1Time && time < lift1TimeEnd) {\n        float frameStart = getLift1FrameStart(time);\n        float frameLen = lift1FrameLen;\n        if (p.x > 0.0 && p.y > frameStart) {\n            p.y = frameLen + frameStart - frameLen / (p.y - frameStart + 1.);\n            p.x -= trans1Value;\n        } else if (p.x < 0.0 && p.y > 2.*spherePos.y - (frameStart + frameLen*2.)) {\n            p.y = frameLen / (p.y - (2.*spherePos.y - (frameStart + frameLen*2.)) + 1.) + frameStart+frameLen;\n        } else if (p.x < 0.0 && p.y > spherePos.y - sphereRad) { // && p.y < 2.*spherePos.y - (frameStart + frameLen*2.)) {\n            p.y = spherePos.y * 2. - p.y;\n        } else {\n            p.x -= trans1Value;\n        }\n    }\n    return p;\n}\n\n\n//        ----  bubbles and morphing  ----\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(vec3 n) {\n    return fract(sin(dot(n, vec3(12.9898, 4.1414, 46.1872))) * 43758.5453);\n}\n\nvec3 rand3D(vec3 p) {\n    return vec3(rand(p), rand(p+vec3(46.1872,0,0)), rand(p+vec3(4.1414,0,0)));\n}\n\nfloat sqr(float x) {  return x * x;  }\n\nfloat mapBubbles(vec3 p, vec3 tranformedP, float time) {\n    float morphK;\n    if (time > split1Time && time < split1TimeEnd) {\n        morphK = (time - split1Time) / split1Duration;\n    } else if (time >= split1TimeEnd && time < merge1Time) {\n        morphK = 1.0;\n    } else if (time >= merge1Time && time < merge1TimeEnd) {\n        morphK = (merge1TimeEnd - time) / merge1Duration;\n    } else if (time >= lift1Time && time < lift1TimeEnd) {\n        float frameStart = getLift1FrameStart(time);\n        float frameLen = lift1FrameLen;\n        morphK = 1. - min(sqr((p.y - (frameStart+frameLen)) / frameLen), 1.);\n    } else {\n        morphK = 0.0;\n    }\n\n    float cellSize = 0.2;\n    float bubbleRad = cellSize * 0.3;\n    vec3 cellPosBase = floor(p/cellSize);  //realative to cellSize\n\n    //    take into account the nearest cell and 8 neighbour cells\n    float totalDist = 1000.;\n    // for large bubbles radius +-1 is not enough, but it is no more performance\n    for (int x=-1; x<=1; x++)  for (int y=-1; y<=1; y++)  for (int z=-1; z<=1; z++)  {\n        vec3 cellPos = cellPosBase + vec3(x,y,z);\n        vec3 cellNoise = rand3D(cellPos);\n        vec3 bubblePos = (cellPos + cellNoise) * cellSize;\n        float rad = bubbleRad * rand(cellPos);\n        //    decrease bubbles size on border\n        float l = length(spherePos - bubblePos);\n        if (rad > sphereRad - l)  rad = mix(rad, sphereRad - l, morphK);\n        if (rad < 0.)  continue;\n\n        float dist = length(tranformedP - transform(bubblePos, time)) - rad;\n        //dist = min(dist, sphereDist);\n        //    merge neighbour bubbles\n        float k = mix(cellSize*1.5, cellSize*0.5, morphK);\n        float h = clamp(0.5 + 0.5*(totalDist-dist)/k, 0.0, 1.0);\n        totalDist = mix(totalDist, dist, h) - k*h*(1.0-h);\n    }\n\n    return totalDist;\n}\n\n//        ----  other raytracing  ----\n\nfloat map(vec3 p, inout bool insideSphere, float time) {\n    vec3 transformedPos = p;\n    p = reverseTransform(p, time);\n\n    float sphereDist = length(p-spherePos) - sphereRad;\n    if (sphereDist < epsilon) {\n        float bubblesDist = mapBubbles(p, transformedPos, time);\n        if (bubblesDist < epsilon)  return insideSphere ? bubblesDist : sphereDist;\n        else {\n            insideSphere = true;\n            return bubblesDist;\n        }\n    } else {\n        insideSphere = false;\n    }\n    return sphereDist;\n}\n\nvec3 calcNormal(vec3 p, bool insideSphere, float time) {\n    vec2 e = vec2(epsilon, 0.0);\n    bool u1=insideSphere, u2=insideSphere, u3=insideSphere, u4=insideSphere, u5=insideSphere, u6=insideSphere;\n    return normalize(vec3(map(p+e.xyy, u1, time) - map(p-e.xyy, u2, time),\n                          map(p+e.yxy, u3, time) - map(p-e.yxy, u4, time),\n                          map(p+e.yyx, u5, time) - map(p-e.yyx, u6, time)));\n}\n\nvec3 getLightPos(vec3 origin, int i) {\n    vec3 p = 1.0 * sin(lightSpeed * vec3(iTime*0.3, iTime*0.1, iTime*0.2) + 500.*vec3(i));\n    p.y += 1.;\n    return p;\n}\n\nfloat mapLight(vec3 p, vec3 origin) {\n    float d = 1000.;\n    for (int i=0; i<lightsCount; i++)  d = min(d, length(p - getLightPos(origin, i)) - 0.02);\n    return d;\n}\n\nfloat mapAll(vec3 p, vec3 origin, out bool matchLight, inout bool insideSphere, float time) {\n    float d = map(p, insideSphere, time);\n    if (d < epsilon) {\n        matchLight = false;\n        return d;\n    } else {\n        matchLight = true;\n        return min(d, mapLight(p, origin));\n    }\n}\n\nfloat cloudsNoise(vec3 p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2.*uv;\n\n    p.y /= iResolution.x / iResolution.y;\n\n    float mx = iMouse.xy == vec2(0.) ? 0.5 : iMouse.x / iResolution.x;\n    float my = iMouse.xy == vec2(0.) ? 0.5 : iMouse.y / iResolution.y;\n\n    float r = 4.;\n    float ay = my * 0.5 * PI;\n    float ax = (mx - 1.) * PI;\n    vec3 ro = vec3(cos(ax)*cos(ay)*r, sin(ay)*r, sin(ax)*cos(ay)*r);  //camera position\n    vec3 rd = normalize(vec3(p, 1.0));  //view direction\n    ay = -ay;\n    ax = -PI/2. - ax;\n    rd = vec3(rd.x, rd.z*sin(ay)+rd.y*cos(ay), rd.z*cos(ay)-rd.y*sin(ay));  //rotate by x\n    rd = vec3(rd.z*sin(ax)+rd.x*cos(ax), rd.y, rd.z*cos(ax)-rd.x*sin(ax));  //rotate by y\n\n    float time = mod(iTime, totalDuration);\n\n    //    ray tracing\n    float tmax = 30.0;\n    float t = 0.0;  //distance from point of view\n    float dist;\n    bool matchLight = false;\n    bool insideSphere = false;\n    for (int i=0; i<RAYMARCHING_STEPS; i++) {\n        dist = mapAll(ro + t*rd, ro, matchLight, insideSphere, time);  //distance to target\n        if (dist<epsilon)  break;\n        else  t += dist;\n        if (t > tmax)  break;\n    }\n\n    //    check ground\n    bool matchGround = false;\n    if (dist>=epsilon) {\n        if (rd.y < 0.) {\n            t = (ro.y-groundY) / -rd.y;\n            matchGround = true;\n            matchLight = false;\n        }\n    }\n    \n    vec3 col = vec3(0);\n    if (dist<epsilon || matchGround) {\n        //    lighting\n        if (matchLight) {\n            col = vec3(1., 1., 1.);\n        }\n        else {\n            vec3 pos = ro + t*rd;\n            vec3 normal = matchGround ? vec3(0., 1., 0.) : calcNormal(pos, insideSphere, time);\n            float lightness = ambientLight;\n            #ifdef DIRECT_LIGHT\n            {\n                vec3 lightDir = normalize(DIRECT_LIGHT);\n                lightness += max(0.0, dot(normal, lightDir)*directLight);\n            }\n            #endif\n            for (int l=0; l<lightsCount; l++) {\n                vec3 lightPos = getLightPos(ro, l);\n                vec3 lightDir = normalize(lightPos-pos);\n                float lightDist = length(lightPos-pos);\n                //if (lightDist >= lightDistance)  continue;\n\n                //float attenuation = pow(max(0.0, 1.0 - lightDist / lightDistance), lightDecay);\n                float attenuation = min(1.0, lightPower / lightDist);\n                lightness += dot(normal, lightDir) * attenuation;\n                if (lightness > (1.0/0.6))  break;\n            }\n            if (matchGround)  col = vec3(texture(iChannel0, pos.xz/10.)) * lightness;\n            else  col = vec3(0.8, 0.9, 1.0) * lightness;\n        }\n    }\n    else {\n        float clouds = cloudsNoise(rd) * pow(max(0., rd.y), 0.25);\n        col = mix(vec3(0.2, 0.4, 1.0), vec3(1.), clouds);\n    }\n\n\tfragColor = vec4(col, 1.);\n}\n\n\n//        ----  simplex noise for clouds  ----\n\nfloat simplex(vec3 v);\n\nfloat fbm3(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result /= (1. + 1./2. + 1./4.);\n    return result;\n}\n\nfloat fbm5(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result += simplex(v * 8.) / 8.;\n    result += simplex(v * 16.) / 16.;\n    result /= (1. + 1./2. + 1./4. + 1./8. + 1./16.);\n    return result;\n}\n\nfloat cloudsNoise(vec3 v) {\n    v *= vec3(1., 5., 1.);\n    v += vec3(fbm3(v), fbm3(vec3(v.xy, v.z + 1000.)), fbm3(vec3(v.xy, v.z + 2000.)));\n    //  normalize\n    return pow(fbm5(v) / 2. + 0.5, 3.);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }","name":"","description":"","type":"image"}]}