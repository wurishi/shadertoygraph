{"ver":"0.1","info":{"id":"l3KSWw","date":"1720044828","viewed":35,"name":"Baking Light & Shadows","username":"guhcalm","description":"Progressive Baking Path-traced Irradiance and Shadows (Buffer A)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtrace","bakinlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PrecomputedIrradiance(uv) texture(iChannel0, uv).rgb / float(PATH_TRACE_STEPS);\n#define PrecomputedShadows(uv) texture(iChannel0, uv).w;\n\nvoid mainImage(out vec4 Pixel, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  vec3 irradiance = PrecomputedIrradiance(uv);\n  float shadows = PrecomputedShadows(uv);\n  \n  if (uv.x > .5) Pixel = vec4(irradiance, 1);\n  else Pixel = vec4(vec3(shadows), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GammaExpansion(color) pow(vec3(color), vec3(2.2))\n#define GammaCompression(color) pow(vec3(color), vec3(1. / 2.2))\n#define saturate(value) clamp(value, 0., 1.)\n\nconst float PLANET_RADIUS = 1.5;\nconst float OCEAN_RADIUS = PLANET_RADIUS - .06;\n\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Geometry { float distance; vec3 position; vec3 normal; };\nstruct Light { vec3 direction; vec3 color; };\nconst float PI = 3.14159265359;\nconst float EPSILON = .001;\nconst float INFINITY = 1. / 0.;\nconst int PATH_TRACE_STEPS = 100;\nLight SUN = Light(normalize(vec3(-1, 1, -1)), vec3(1));\n\nfloat seed;\nfloat random() { return fract(sin(seed += .1) * 4568.7564); }\nfloat random(vec2 uv) { return fract(sin(dot(uv, vec2(127.1, 311.7))) * 4568.7564); }\nvec3 RandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}\n\nvec2 sphereToUv(vec3 direction) {\n  float phi = atan(direction.z, direction.x);\n  float theta = acos(direction.y);\n  float u = (phi + PI) / (2.0 * PI);\n  float v = theta / PI;\n  return vec2(u, 1. - v);\n}\nvec3 uvToSphere(vec2 uv) {\n  float phi = (uv.x * 2.0 * PI) - PI;\n  float theta = PI * (1.0 - uv.y);\n  float x = sin(theta) * cos(phi);\n  float y = cos(theta);\n  float z = sin(theta) * sin(phi);\n  return vec3(x, y, z);\n}\n\nRay Camera(in vec2 uv, vec3 origin, vec3 target, float aspect, float focalLength) {\n  vec3 ndc = vec3(uv * 2.0 - 1.0, 1.0);\n  const float fov = (60.0 * PI / 180.0);\n  const vec3 up = vec3(0, 1, 0);\n  float f = tan(fov / 2.0);  \n  vec3 screen = vec3(ndc.x * aspect * f, ndc.y * f, ndc.z / f);  \n  float d = sqrt(1.0 + screen.x * screen.x + screen.y * screen.y);\n  float u = screen.x / (screen.z + d * focalLength);\n  float v = screen.y / (screen.z + d * focalLength);\n  vec3 paniniScreen = normalize(vec3(u, v, 1.0));\n  vec3 w = normalize(target - origin);\n  vec3 uAxis = normalize(cross(w, up));\n  vec3 vAxis = normalize(cross(uAxis, w)); \n  return Ray(origin, normalize(mat3(uAxis, vAxis, w) * paniniScreen));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Pre-Computing Diffused Radiance Light */\n\n#define PrecomputedHeightmap(uv) texture(iChannel0, uv).w\n\n/* Geometry buffer */\nfloat MandelbulbSDF(in vec3 position) {\n  vec3 p = position * .5;\n  float power = 7. + 5. * sin(0. / 3.);\n  vec3 z = p;\n  float dr = 1.;\n  float r = 0.;\n  for (int i = 0; i < 15; i++) {\n    r = length(z);\n    if (r > 1.5) break;\n    float theta = acos(z.z / r) * power;\n    float phi = atan(z.y, z.x) * power;\n    dr = pow(r, power - 1.) * power * dr + 1.;\n    float zr = pow(r, power);\n    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n    z += p;\n  }\n  return .5 * log(r) * r / dr;\n}\nfloat SDF(in vec3 position) { return MandelbulbSDF(position); }\n\nfloat SphereTracer(Ray ray) {\n  float distance;\n  const float NEAR = EPSILON;\n  const float FAR = 18.;\n  for(int step; step < 800; step++) {\n    float march = SDF(ray.origin + ray.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march * .35;\n    if (distance >= FAR) break;\n  }\n  return INFINITY;\n}\n\n#define RayMarcher(camera) SphereTracer(camera)\n\n/* Shadows */\nfloat SoftShadows(Geometry geometry, Light light) {\n  float k = 16.;\n  float res = 1.;\n  float t = .1;\n  float ph = 1e10;\n  for(int i = 0; i < 64; i++) {\n\tfloat h = SDF(geometry.position + light.direction * t);\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, k * d / max(0., t - y));\n    ph = h;    \n    t += h;\n    if(res < .001 || t > 16.) break;\n  }\n  res = clamp(res, 0., 1.);\n  return res * res * (3. - 2. * res);\n}\n\nGeometry GeometryBuffer(Ray camera) {\n  float distance = RayMarcher(camera);\n  vec3 position = camera.origin + camera.direction * distance;\n  vec2 e = vec2(EPSILON, 0);\n  vec3 normal = normalize(vec3(\n    SDF(position + e.xyy) - SDF(position - e.xyy),\n    SDF(position + e.yxy) - SDF(position - e.yxy),\n    SDF(position + e.yyx) - SDF(position - e.yyx)\n  ));\n  return Geometry(distance, position, normal);\n}\n\n/* Path Tracer */\nvec3 DiffuseRadiance(in Ray camera) {\n  #define Environment(direction) GammaExpansion(texture(iChannel1, direction).rgb)\n  for (int i; i < 3; i++) {\n    Geometry geometry = GeometryBuffer(camera);\n    if (geometry.distance == INFINITY) return Environment(camera.direction);\n    camera.origin = geometry.position + geometry.normal * .0001;\n    camera.direction = RandomVectorOnHemisphere(geometry.normal);\n  }          \n  return vec3(0);\n}\n\nvoid mainImage(out vec4 PrecomputedDiffuseRadiance, in vec2 fragCoord) {\n  if (iFrame > PATH_TRACE_STEPS) discard;\n\n  seed = iTime + random(fragCoord.xy / iResolution.xy); \n  vec2 off = vec2(random(), random());\n  vec2 uv = saturate((off + fragCoord.xy) / iResolution.xy);\n  vec3 direction = uvToSphere(uv);\n  \n  Ray camera = Ray(direction * 4.5, -direction);\n  \n  vec3 radiance = GammaCompression(DiffuseRadiance(camera));\n  \n  Geometry geometry = GeometryBuffer(camera);\n  vec4 lastFrame = texture(iChannel0, vec2(fragCoord.xy / iResolution.xy));\n  \n  float shadows;\n  if (iFrame < 1) shadows = SoftShadows(geometry, SUN);\n  \n  vec4 currentFrame = vec4(radiance, shadows);\n  \n  \n  PrecomputedDiffuseRadiance = currentFrame + lastFrame;\n}","name":"Buffer A","description":"","type":"buffer"}]}