{"ver":"0.1","info":{"id":"wtGGD3","date":"1583703428","viewed":658,"name":"PATH TRACER","username":"alro","description":"Path tracer based on \"Ray Tracing In One Weekend\".  Use mouse to move camera. \n\nConverges to a smooth image over time by adding new random samples every frame and averaging the result in the final output. User input persists between frames.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["mouse","raytracer","pathtracer","material","weekend","persistent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Path tracer for diffuse, metal and dielectric spheres based on:\n\n//\"Ray Tracing In One Weekend\"\n//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\n//Some tricks from https://www.shadertoy.com/view/MtycDD\n\n//BufferA: Persistent input\n//BufferB: Path tracer\n//Image: Colour correction and assembly\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv /= iResolution.x/iResolution.y;\n    \n    //Read the RGBA value in iChannel0 that holds the path tracer data from BufferB\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0).rgba;\n    \n    //Set the colour to the accumulated RGB value divided by the number of iterations\n    //which is the value of the alpha channel as it gets 1 added to it every frame\n    vec3 col = data.rgb/data.a;\n       \n    //Tonemapping\n    col = ACESFilm(col);\n    \n    //Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    //Output to screen\n\tfragColor = vec4(col, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Track mouse movement and resolution change between frames and set camera position\n\n#define PI 3.14159\n#define EPS 1e-4\n#define CAMERA_DIST 6.0\n\nfloat modulo(float m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = modulo(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI/2.0 - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(PI-0.65, 1.25);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos + vec3(0.0, 1.0, 0.0), 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n        \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Path tracer code\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n\n#define MAXIMUM_BOUNCE 8\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 1e10\n\n#define OBJECT_COUNT 10\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nbool earlyExit = false;\nvec2 randomSeed;\n\nstruct Sphere{\n    vec3 position;\n    float radius;\n    int material;\n    vec3 albedo;\n    //Fuzz for metal, refraction index for dielectrics\n    float variable;\n};\n    \nstruct HitRecord {\n    float dist;\n    vec3 position;\n    vec3 normal;\n    int sphereIdx;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat random(vec2 par){\n   return fract(sin(dot(par,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par){\n\tfloat rand = random(par);\n\treturn vec2(rand, random(par+rand));\n}\n\n//https://en.wikipedia.org/wiki/Spherical_coordinate_system\nvec3 sphericalToCartesian(float theta, float phi){\n    float sinPhi = sin(phi);\n\treturn normalize(vec3(sinPhi * cos(theta), sinPhi * sin(theta), cos(phi)));\n}\n\n//Get a random direction on a unit sphere\n//http://corysimon.github.io/articles/uniformdistn-on-sphere/\nvec3 getRandomDirection(vec2 seed){\n    vec2 param = random2(seed);\n    float theta = TWO_PI * param.x;\n    float phi = acos(1.0 - 2.0 * param.y);\n\treturn sphericalToCartesian(theta, phi);\n}\n\n//Get a random point on a unit disk\n//https://mathworld.wolfram.com/DiskPointPicking.html\nvec2 randomInUnitDisk(vec2 seed){\n    vec2 rand = random2(seed);\n    float theta = TWO_PI * rand.y;\n\treturn sqrt(rand.x) * vec2(sin(theta),cos(theta));\n}\n\nvec3 getDiffuseDirection(){\n    return getRandomDirection(randomSeed);\n}\n\n//Return the near intersection of a ray and sphere\n//For normalised ray directions, a = 1 and is omitted\nfloat sphereIntersect(Ray ray, Sphere sphere){\n    vec3 pos = sphere.position;\n    vec3 dir = ray.direction;\n    float radius = sphere.radius;\n    vec3 oc = ray.origin - pos;\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - (radius * radius);\n    float d = (b*b) - 4.0*c;\n    if (d < 0.0) {\n        return -1.0;\n    }else{\n        return (-b - sqrt(d)) * 0.5;\n    }\n}\n\nbool refraction(vec3 v, vec3 n, float niOverNt, out vec3 refracted) {\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - niOverNt*niOverNt*(1.0-dt*dt);\n    if(discriminant > 0.0) {\n        refracted = niOverNt*(uv - n*dt) - n*sqrt(discriminant);\n        return true;\n    }else{\n        return false;\n    }\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine,5.0);\n}\n\nbool scatterLambertian(Sphere sphere, inout Ray ray, inout HitRecord rec, inout vec3 attenuation, inout Ray scattered, vec2 fragCoord){\n    vec3 target = getDiffuseDirection();\n    scattered = Ray(rec.position, normalize(rec.normal + target));\n    attenuation = sphere.albedo;\n    return true;\n}\n\nbool scatterMetal(Sphere sphere, inout Ray ray, inout HitRecord rec, inout vec3 attenuation, inout Ray scattered, vec2 fragCoord){\n    vec3 reflected = reflect(ray.direction, rec.normal);\n    scattered = Ray(rec.position, normalize(reflected + sphere.variable * getDiffuseDirection()));\n    attenuation = sphere.albedo;\n    return true;\n    //return (dot(scattered.direction, rec.normal) > 0.0);\n}\n\nbool scatterDielectric(Sphere sphere, inout Ray ray, inout HitRecord rec, inout vec3 attenuation, inout Ray scattered, vec2 fragCoord){\n    vec3 outwardNormal;\n    vec3 reflected = reflect(ray.direction, rec.normal);\n    float niOverNt;\n    attenuation = vec3(1);\n    vec3 refracted;\n\n    float reflectProb;\n    float cosine;\n\n    if(dot(ray.direction, rec.normal) > 0.0) {\n        outwardNormal = -rec.normal;\n        niOverNt = sphere.variable;\n        cosine = sphere.variable * dot(ray.direction, rec.normal);\n    }else{\n        outwardNormal = rec.normal;\n        niOverNt = 1.0 / sphere.variable;\n        cosine = -dot(ray.direction, rec.normal);\n    }\n\n    if(refraction(ray.direction, outwardNormal, niOverNt, refracted)) {\n        reflectProb = schlick(cosine, sphere.variable);\n    }else{\n        reflectProb = 1.0;\n    }\n\n    if(random(randomSeed) < reflectProb) {\n        scattered = Ray(rec.position, normalize(reflected));\n    }else{\n        scattered = Ray(rec.position, normalize(refracted));\n    }\n\n    return true;\n\n}\n\nbool hit(Sphere sphere, Ray ray, float t_min, float t_max, inout HitRecord rec){\n    float intersection = sphereIntersect(ray, sphere);\n    \n    if(intersection > 0.0 && intersection < t_max && intersection > t_min) {\n        rec.dist = intersection;\n        rec.position = ray.origin + ray.direction * rec.dist;\n        rec.normal = (rec.position - sphere.position)/ sphere.radius;\n        return true;\n    }\n    \n    return false;\n}\n\nbool traceObjects(Ray ray, inout HitRecord rec, Sphere[OBJECT_COUNT] spheres){\n\n    HitRecord tempRec;\n    bool hitAnything = false;\n    float closestSoFar = MAX_DIST;\n    for(int i = 0; i < OBJECT_COUNT; i++) {\n        if(hit(spheres[i], ray, MIN_DIST, closestSoFar, tempRec)) {\n            hitAnything = true;\n            closestSoFar = tempRec.dist;\n            rec = tempRec;\n            rec.sphereIdx = i;\n        }\n    }\n    return hitAnything;\n}\n\nvec3 getBackgroundColour(vec3 rayDir){\n    return pow(texture(iChannel2, rayDir).rgb, vec3(2.2));\n  float weight = 0.5 + 0.5 * rayDir.y;\n  return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), weight);\n}\n\nvec3 getColour(vec2 fragCoord, Ray ray, Sphere[OBJECT_COUNT] spheres) {\n\tHitRecord rec;\n    Ray scattered;\n    //Initialise to white and track the attenuation of light\n    vec3 col = vec3(1);\n    //GLSL does not allow recursion as in the original approach.\n    //For a maximum of MAXIMUM_BOUNCE iterations, adjust the colour variable with \n    //new information until it points into empty space or gets trapped in a shadow\n    for(int i = 0; i < MAXIMUM_BOUNCE; i++){\n    \tif(traceObjects(ray, rec, spheres)){\n            vec3 attenuation;\n            if(spheres[rec.sphereIdx].material == LAMBERTIAN){\n            \tif(scatterLambertian(spheres[rec.sphereIdx], \n                                     ray, \n                                     rec, \n                                     attenuation, \n                                     scattered, \n                                     fragCoord)){\n            \t\tray = scattered;\n            \t\tcol *= attenuation;\n                }\n        \t}else if(spheres[rec.sphereIdx].material == METAL){\n            \tif(scatterMetal(spheres[rec.sphereIdx], \n                                ray, \n                                rec, \n                                attenuation, \n                                scattered, \n                                fragCoord)){\n            \t\tray = scattered;\n                \tcol *= attenuation;\n                }else{\n                \treturn vec3(0);\n                }\n        \t}else if(spheres[rec.sphereIdx].material == DIELECTRIC){\n            \tif(scatterDielectric(spheres[rec.sphereIdx], \n                                ray, \n                                rec, \n                                attenuation, \n                                scattered, \n                                fragCoord)){\n            \t\tray = scattered;\n                \tcol *= attenuation;\n                }\n        \t} \n            \n    \t}else{\n            //Multiply colour by sky colour depending on the ray direction\n        \tcol *= getBackgroundColour(ray.direction);\n        \treturn col;\n    \t}\n        if(earlyExit){break;}\n    }\n    return col;\n}\n\nRay getRay(vec3 lookFrom, vec3 targetDir, vec3 upVector, float FOV, float aspect, float aperture, float focusDist, vec2 fragCoord) {\n    float halfHeight = tan(radians(FOV*0.5));\n    float halfWidth = aspect * halfHeight;\n    vec3 origin = lookFrom;\n    vec3 w = targetDir;\n    vec3 u = normalize(cross(upVector, w));\n    vec3 v = cross(w, u);\n    vec3 lowerLeftCorner = origin\n        - halfWidth * focusDist * u\n        - halfHeight * focusDist * v\n        - focusDist * w;\n    vec3 horizontal = 2.0 * halfWidth * focusDist * u;\n    vec3 vertical = 2.0 * halfHeight * focusDist * v;\n\n    vec2 rd = 0.5*aperture * randomInUnitDisk(randomSeed);\n    vec3 offset = u * rd.x + v * rd.y;\n    return Ray(origin + offset, normalize(lowerLeftCorner \n               + (fragCoord.x/iResolution.x) * horizontal \n               + (fragCoord.y/iResolution.y) * vertical\n               - origin - offset));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    randomSeed = fract(iTime) * fragCoord;\n    bool resolutionChanged = (texelFetch(iChannel0, ivec2(0.5, 2.5), 0).x == 1.0);\n    earlyExit = iMouse.z > 0.0 || resolutionChanged || iFrame <= 2;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv /= iResolution.x/iResolution.y;\n    \n    //--------------- Define ray ----------------\n    \n    //Each frame offset the ray by a small amount within the pixel\n    vec2 seed = 128.0 * iTime + uv;\n    vec2 offset = random2(seed) - 0.5;\n    \n    //Camera position is persistent and calculated in BufferA\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\t\n    vec3 targetDir = cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    float focusDist = length(targetDir);\n    float aperture = 0.1;\n    \n    Ray ray = getRay(cameraPos, targetDir/focusDist, up, 45.0, \n                     iResolution.x/iResolution.y, aperture, focusDist, fragCoord+offset);\n    \n    //-------------------------------------------\n    \n    vec3 col = vec3(0);\n    \n    Sphere list[OBJECT_COUNT];\n\n    //Metal scene\n/*\n    list[0] = Sphere(vec3(0.0,0.0,-1.0), 0.5, LAMBERTIAN, vec3(0.8, 0.3, 0.3), 0.0);\n    list[1] = Sphere(vec3(0.0,-100.5,-1.0), 100.0, LAMBERTIAN, vec3(0.8, 0.8, 0.0), 0.0);\n    list[2] = Sphere(vec3(1.0,0.0,-1.0), 0.5, METAL, vec3(0.8, 0.6, 0.2), 1.0);\n    list[3] = Sphere(vec3(-1.0,0.0,-1.0), 0.5, METAL, vec3(0.8, 0.8, 0.8), 0.3);\n*/\n\n    //Dielectric scene\n/*\n    list[0] = Sphere(vec3(0,0,-1), 0.5, LAMBERTIAN, vec3(0.1, 0.2, 0.5), 0.0);\n\tlist[1] = Sphere(vec3(0.0,-100.5,-1.0), 100.0, LAMBERTIAN, vec3(0.8, 0.8, 0.0), 0.0);\n\tlist[2] = Sphere(vec3(1,0,-1), 0.5, METAL, vec3(0.8, 0.6, 0.2), 0.3);\n\tlist[3] = Sphere(vec3(-1,0,-1), 0.48, DIELECTRIC, vec3(0), 1.5);\n\tlist[4] = Sphere(vec3(-1,0,-1), -0.45, DIELECTRIC, vec3(0), 1.5);\n*/\n    \n    list[0] = Sphere(vec3(0.0, -1000.0, 0.0), 1000.0, LAMBERTIAN, vec3(0.5), 0.0);\n    list[1] = Sphere(vec3(2, 1, 0), 1.0, DIELECTRIC, vec3(0), 1.5);\n    list[2] = Sphere(vec3(-2, 1, 0), 1.0, LAMBERTIAN, vec3(0.1, 0.2, 0.5), 0.0);\n    list[3] = Sphere(vec3(0, 1, 0), 1.0, METAL, vec3(0.7, 0.6, 0.5), 0.0);\n    \n    list[4] = Sphere(vec3(2.2, 0.25, 1.5), 0.25, LAMBERTIAN, vec3(0,1,1), 0.0);\n    list[5] = Sphere(vec3(1.5, 0.25, -1.0), 0.25, LAMBERTIAN, vec3(0,1,0), 0.0);\n    list[6] = Sphere(vec3(1.0, 0.35, -1.4), 0.35, LAMBERTIAN, vec3(1,0,1), 0.0);\n    list[7] = Sphere(vec3(-1.1, 0.3, 1.0), 0.3, METAL, vec3(1,0,0), 0.2);\n    list[8] = Sphere(vec3(-1.0, 0.5, -1.5), 0.5, METAL, vec3(1,1,0), 0.5);\n    list[9] = Sphere(vec3(-0.5, 0.4, 2.0), 0.4, DIELECTRIC, vec3(1), 2.4);\n\n    col = getColour(fragCoord, ray, list);\n\n    //Write colour to BufferB\n    //If mouse button is down or the resolution has changed, \n    //overwrite buffer colour with new scene\n    if(earlyExit){\n\t\tfragColor = vec4(col, 1);\n    }else{\n        //Else, add colour to previous frame held in BufferB\n        //Alpha channel will hold total number of additions for later averaging.\n        vec4 oldData = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0);\n        //Impose upper limit to avoid numerical weirdness\n        if(oldData.a < 10000.0){\n        \toldData += vec4(col, 1.0);\n        }\n\t\tfragColor = oldData;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2020 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/","name":"Common","description":"","type":"common"}]}