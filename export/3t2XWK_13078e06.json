{"ver":"0.1","info":{"id":"3t2XWK","date":"1567402609","viewed":180,"name":"Struct Raymarch Test","username":"Fogrex","description":"struct Field Intersection Ray\nupdate Algorithm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 pos = vec3(0.0,0.0,2.0);\n    pos = rotate(pos, vec3(0.0,iTime,0.0));\n    \n    Ray r = initRay(uv,pos,vec3(0.0,0.0,0.0), 0.9);\n    \n    for(int i=0;i<3;i++)\n    {\n        raymarch(r);\n        if(!r.isReflect) break;\n    }\n\t\n    fragColor = r.color + r.intensity * r.rayColor * texture(iChannel0, r.direction);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265\n#define PI2 6.28318531\n#define saturate(a) clamp(a, 0.0, 1.0)\n\nconst vec3 LIGHT_DIR = normalize(vec3(1.0,-1.0,1.0));\nconst int STEP = 128;\n\n\nstruct Field\n{\n    float dist;\n    vec4 color;\n    float metallic;\n    float lim;\n};\n\nstruct Intersection\n{\n    vec3 pos;\n    vec3 normal;\n    Field field;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec4 color;\n    bool isReflect;\n    vec4 rayColor;\n    float intensity;\n};\n\n\nField initField()\n{\n    Field f;\n    f.dist = 99999.0;\n    f.color = vec4(1.0,1.0,1.0,1.0);\n    f.metallic = 0.0;\n    f.lim = 0.0;\n    return f;\n}\n\nField mixField(in Field f2, in Field f1, in float h)\n{\n    Field f;\n    f.color = mix(f2.color, f1.color, h);\n    f.metallic = mix(f2.metallic, f1.metallic, h);\n    f.lim = mix(f2.lim, f1.lim, h);\n    return f;\n}\n    \n// transform functions\n\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 move)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m * p).xyz;\n}\n\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\nmat3 camera(vec3 pos, vec3 tar)\n{\n    vec3 cw = normalize(tar - pos);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n\n// distance function\n\nField sdSphere(in vec3 pos, in float r)\n{\n    Field f = initField();\n    f.dist = length(pos) - r;\n    return f;\n}\n\nField sdBox(in vec3 pos, in vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    Field f = initField();\n    f.dist = length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n    return f;\n}\n\nField sdCylinder(in vec3 pos, in float r)\n{\n    Field f = initField();\n    f.dist = length(pos.xz) -r;\n    return f;\n}\n\nField sdPlane(in vec3 pos, in float h)\n{\n    Field f = initField();\n    f.dist = pos.y - h;\n    return f;\n}\n\nField nsUnion(in Field f1, in Field f2, in bool flag)\n{\n    if(f1.dist < f2.dist) return f1;\n    return f2;\n}\n\nField nsSubtraction(Field f1, Field f2)\n{\n    if(-f1.dist < f2.dist) return f2;\n    f1.dist *= -1.0;\n    return f1;\n}\nField nsIntersection(Field f1, Field f2)\n{\n    if(f1.dist < f2.dist) return f2;\n    return f1;\n}\n\nField sUnion(Field f1, Field f2, float k, in bool flag)\n{\n    float h = clamp(0.5 + 0.5*(f2.dist-f1.dist)/k, 0.0, 1.0);\n    Field f;\n    if(!flag) f = mixField(f2, f1, h);\n    f.dist = mix(f2.dist, f1.dist, h) - k*h*(1.0-h);\n    return f;\n}\n\nField sSubtraction(Field f1, Field f2, float k, in bool flag)\n{\n    float h = clamp(0.5 - 0.5*(f2.dist+f1.dist)/k, 0.0, 1.0);\n    Field f;\n    if(!flag) f = mixField(f2, f1, h);\n    f.dist = mix(f2.dist, -f1.dist, h) + k*h*(1.0-h);\n    return f;\n}\nField sIntersection(Field f1, Field f2, float k, in bool flag)\n{\n    float h = clamp(0.5 - 0.5*(f2.dist-f1.dist)/k, 0.0, 1.0);\n    Field f;\n    if(!flag) f = mixField(f2, f1, h);\n    f.dist = mix(f2.dist, f1.dist, h) + k*h*(1.0-h);\n    return f;\n}\n\n// mapping\nField map(in vec3 pos, in bool isDist)\n{\n   \tField s1 = sdSphere(translate(pos, vec3(1.0,0.0,0.0)),0.3);\n    s1.metallic = 1.0;\n    s1.lim = 0.8;\n    s1.color = vec4(1.0,0.0,0.0,1.0);\n   \tField s2 = sdSphere(translate(pos, vec3(0.0,1.0,0.0)),0.3);\n    s2.metallic = 0.5;\n    s2.color = vec4(0.0,1.0,0.0,1.0);\n   \tField s3 = sdSphere(translate(pos, vec3(0.0,0.0,1.0)),0.1);\n    s3.metallic = 0.4;\n    s3.color = vec4(0.0,0.0,1.0,1.0);\n   \tField s4 = sdSphere(translate(pos, vec3(-1.0,0.0,0.0)),0.3);\n    s4.metallic = 0.0;\n    s4.color = vec4(1.0,1.0,0.0,1.0);\n   \tField s5 = sdSphere(translate(pos, vec3(0.0,-1.0,0.0)),0.3);\n    s5.metallic = 0.7;\n    s5.color = vec4(1.0,0.0,1.0,1.0);\n\tField s6 = sdSphere(translate(pos, vec3(0.0,0.0,-1.0)),0.3);\n    s6.metallic = 0.2;\n    s6.color = vec4(0.0,1.0,1.0,1.0);\n    \n    float k = 1.0;\n\tField r = sUnion(s1, s2, k, isDist);\n\tr = sUnion(s3, r, k, isDist);\n\tField r2 = sUnion(s5, s4, k, isDist);\n\tr2 = sUnion(r2, s5, k, isDist);\n\tr2 = sUnion(r2, s6, k, isDist);\n    return sUnion(r,r2,k,isDist);\n}\n\nfloat distMap(in vec3 pos)\n{\n    return map(pos, true).dist;\n}\nField colorMap(in vec3 pos)\n{\n    return map(pos, false);\n}\n\n// CalcNorm\nvec3 calcNorm(in vec3 pos)\n{\n    vec2 d = vec2(0.0, 0.0001);\n    return normalize(vec3(\n        distMap(pos + d.yxx) - distMap(pos - d.yxx),\n        distMap(pos + d.xyx) - distMap(pos - d.xyx),\n        distMap(pos + d.xxy) - distMap(pos - d.xxy)\n    ) / d.y);\n}\n\nIntersection initIntersection(in vec3 pos, in Field f)\n{\n    Intersection its;\n    its.pos = pos;\n    its.normal = calcNorm(pos);\n    its.field = f;\n    return its;\n}\n\nRay initRay(vec2 uv, vec3 pos, vec3 tar, float fl)\n{\n    Ray r;\n    r.origin = pos;\n    mat3 c = camera(pos, tar);\n\tvec3 rd = vec3(uv, fl)*0.01;\n    r.direction = normalize(c * vec3(rd.xy, sqrt(max(rd.z * rd.z - dot(rd.xy, rd.xy) * 0.2, 0.0))));\n    r.color = vec4(0.0);\n    r.rayColor = vec4(1.0);\n    r.isReflect = true;\n    r.intensity = 1.0;\n    return r;\n}\n\nfloat lambertModel(Intersection its)\n{\n    return saturate(dot(its.normal, -LIGHT_DIR))*0.9 + 0.1;\n}\n\nfloat limLighting(in Ray ray, in Intersection its)  \n{\n    return 1.0 - saturate(dot(-ray.direction, its.normal));\n}\n\nvoid lighting(inout Ray ray, in Intersection its)\n{\n    Field f = its.field;\n    float lim = f.lim * limLighting(ray, its);\n    vec4 col = mix(ray.rayColor * f.color * lambertModel(its), vec4(1.0), lim) ;\n    ray.color += col * ray.intensity * max((1.0 - f.metallic), lim);\n    ray.rayColor *= f.color;\n    ray.intensity -= ray.intensity * max((1.0 - f.metallic), lim);\n    ray.isReflect = !(ray.intensity==0.0);\n    if(ray.isReflect)\n    {\n    \tray.direction = reflect(ray.direction, its.normal);\n    \tray.origin = its.pos + ray.direction * 0.001;\n    }\n}\n\nvoid raymarch(inout Ray ray)\n{\n    vec3 pos = ray.origin;\n    vec3 dir = ray.direction;\n    \n    float d;\n    for(int i=0;i<STEP;i++)\n    {\n        d = distMap(pos);\n        if(d < 0.0001)\n        {\n            lighting(ray, initIntersection(pos, colorMap(pos)));\n            return;\n        }\n        pos += dir * d;\n    }\n    ray.isReflect = false;\n    return;\n}\n\n\n","name":"Common","description":"","type":"common"}]}