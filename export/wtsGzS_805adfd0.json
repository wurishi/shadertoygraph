{"ver":"0.1","info":{"id":"wtsGzS","date":"1556787473","viewed":497,"name":"Smoothstep's Many Ways","username":"tpfto","description":"Plot the first few (clipped) polynomials generalizing the [url=https://en.wikipedia.org/wiki/Smoothstep]smoothstep function[/url].","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","plot","smoothstep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// plot first few \"smoothstep\" polynomials (https://en.wikipedia.org/wiki/Smoothstep)\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// comment out to switch to light mode\n#define DARK_MODE\n\n// comment out to see them all overlaid; adjust the value of DISP_SCALE if you do so\n#define SEPARATE\n\n// uncomment to see the differences from the classical cubic (n == 1) case\n// suggestion by user ollj\n// #define SHOWDIFF\n\n// XY range of the display.\n#define DISP_SCALE 6.5\n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.01 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 0.8\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 1.0\n\n// number of polynomials to plot\n#define MAX_DEGREE 6\n\n// formula from https://tpfto.wordpress.com/2017/08/29/a-short-note-on-the-generalized-smoothstep-function/\nfloat genSmoothstep(int n, float x)\n{\n\tfloat nn = float(n);\n    float p = clamp(x, 0.0, 1.0);\n    float q = 1.0, y = 1.0;\n    float x0 = p, x1 = 1.0 - p;\n    \n    for (int k = 1; k <= MAX_DEGREE; k++)\n    {\n        if (k > n) break;\n        q *= (1.0 + nn/float(k)) * x1;\n        p *= x0;\n        y += q;\n    }\n    \n    return p * y;\n}\n\nfloat SmoothstepVal(int n, vec2 p)\n{\n    #ifdef SEPARATE // plot a translated version for easier visualization\n    float s = float(n) - floor(0.5 * float(MAX_DEGREE)) - 1.0;\n    #else // no translation done\n    float s = 0.0;\n    #endif\n\n    return p.y - (genSmoothstep(n, p.x + 0.5) + s);\n}\n\nfloat SmoothstepDiff(int n, vec2 p)\n{\n    #ifdef SEPARATE // plot a translated version for easier visualization\n    float s = float(n) - floor(0.5 * float(MAX_DEGREE));\n    #else // no translation done\n    float s = 0.0;\n    #endif\n\n    return p.y - (genSmoothstep(n, p.x + 0.5) - genSmoothstep(1, p.x + 0.5) + s);\n}\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// central difference\n#define GRAD_SM(n, p) (0.5 * vec2(SmoothstepVal(n, p - GRADH.xy) - SmoothstepVal(n, p + GRADH.xy), SmoothstepVal(n, p - GRADH.yx) - SmoothstepVal(n, p + GRADH.yx)) / GRADH.xx)\n\n// PLOT_Smoothstep(Order, Color, Destination, Screen Position)\n#define PLOT_Smoothstep(n, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(SmoothstepVal(n, p) / length(GRAD_SM(n, p)))))\n\n#ifdef SHOWDIFF\n#define GRAD_SD(n, p) (0.5 * vec2(SmoothstepDiff(n, p - GRADH.xy) - SmoothstepDiff(n, p + GRADH.xy), SmoothstepDiff(n, p - GRADH.yx) - SmoothstepDiff(n, p + GRADH.yx)) / GRADH.xx)\n#define PLOT_SmoothstepDiff(n, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(SmoothstepDiff(n, p) / length(GRAD_SD(n, p)))))\n#endif\n\n// generate golden angle colors from HSV\nvec3 colors( int k )\n{\n     return clamp( abs(mod(6.0 * fract(1.618 * float(k) + 0.857) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );\n}\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - abs(c), 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0;\n    float tick = 1.0;\n    float axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad-0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= DISP_SCALE;\n\t\n    vec3 col = WHITE;\n    \n    // set up axes and ticks\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, grid(uv, true, false, true));\n    #else\n    col = mix(GRAY, LIGHT, grid(uv, true, false, true));\n    #endif\n    \n    #ifndef SHOWDIFF\n    for (int k = 1; k <= MAX_DEGREE; k++) PLOT_Smoothstep(k, colors(k), col, uv);\n    #else\n    for (int k = 1; k <= MAX_DEGREE; k++) PLOT_SmoothstepDiff(k, colors(k), col, uv);\n    #endif\n\t\n    #ifdef DARK_MODE\n    col = mix(LIGHT, col, 1.0 - step(0.5 * DISP_SCALE, abs(uv.x)));\n    #else\n    col = mix(DARK, col, 1.0 - step(0.5 * DISP_SCALE, abs(uv.x)));\n    #endif\n    \n\tfragColor = vec4( vec3(col), 1.0 );\n}","name":"Image","description":"","type":"image"}]}