{"ver":"0.1","info":{"id":"WtjXDW","date":"1565940790","viewed":392,"name":"Edit stroke","username":"stephomi","description":"Very limited due to performance (limited number of edits)","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["sculpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int ADDRESS_RESOLUTION = 3;   // resolution\n\nvec4 readAddress(in int address) {\n    return texelFetch(iChannel0, ivec2(address, 0), 0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res = readAddress(ADDRESS_RESOLUTION).xy;\n\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    uv *= res / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool EDIT_ACCUMULATE = false; // apply edit when editing (accumulative stroke)\nbool EDIT_PLANE = false; // only with TOOL_TYPE == 1\n\n#define TOOL_RADIUS 0.2\n#define TOOL_ROUNDNESS 0.1\n// only 2 type 0,1 -> sub/sub\n#define TOOL_TYPE 0\n\n#define LIMIT_EDIT 50\n// step between stroke\n#define STEP_EDIT_XY 10.0\n\n// clamped with iResolution\n#define RESOLUTION vec2(400, 400)\n//#define HAS_AO\n//#define HAS_SHADOW\n\n#define CAMERA_ZOOM 3.0\n#define CAMERA_SPEED vec2(5.0, 5.0)\n#define CAMERA_Y_LIMIT -0.28\n\n#define DEF_COLOR vec3(0.8, 0.7, 0.6)\n\n// raymarching stuffs\n#define ITER_RAY_SCENE 150\n#define PRECISION_RAY_SCENE 0.002\n#define BAIL_DISTANCE_SCENE 20.0\n\n// shadow only\n#define ITER_RAY_SHADOW 16\n#define PRECISION_RAY_SHADOW 0.002\n#define BAIL_DISTANCE_SHADOW 2.5\n\n// -------------------------------\n// --- EDIT STRUCTURE\n// -------------------------------\n// vec4(pos.xyz, radius), vec4(type, roundness, 0, 0)\nconst int SIZE_TOOL = 2; // 2 vec4, could fit in 1...\n\n// -------------------------------\n// -- global\nint g_editCount;\nint g_endEdit;\n\n// -------------------------------\n// --- ADDRESS\n// -------------------------------\nconst int ADDRESS_STATE = 0;        // 0:init 1:nothing 2:camera 3:edit\nconst int ADDRESS_MOUSE = 1;        // xyz -> z: [-1 up, 0 down, 1 move]\nconst int ADDRESS_CAM_XY = 2;       // cam xy\nconst int ADDRESS_RESOLUTION = 3;   // resolution\nconst int ADDRESS_LAST_EDIT_XY = 4; // cam xy\nconst int ADDRESS_START_STROKE = 5; // first edit index (to skip current stroke edit while editing)\nconst int ADDRESS_EDIT_COUNT = 6;   // number of edits (initialized with 0)\nconst int ADDRESS_START_EDIT = 7;   // edit actions start there\n\n#define STATE_INIT    0\n#define STATE_NOTHING 1\n#define STATE_CAMERA  2\n#define STATE_EDIT    3\n\nvec4 readAddress(in int address) {\n    return texelFetch(iChannel0, ivec2(address, 0), 0);\n}\n\nbool writeAddress(in vec2 fragCoord, in int idx) {\n    return int(fragCoord.x) == idx && int(fragCoord.y) == 0;\n}\n\n// --- MATH\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// -------------------------------\n// --- SDF BLEND STUFFS\n// -------------------------------\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n    float ra = clamp(sd / a.x, 0.0, 1.0);\n    float rb = clamp(sd / b.x, 0.0, 1.0);\n    return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b) {\n    return colorBlending(min(a.x, b.x), a, b);\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b) {\n    return colorBlending(max(a.x, b.x), a, b);\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) { return length(p) - s; }\n\n// UNION\nfloat opUnion(const in float a, const in float b) { return min(a, b); }\nvec4 opUnion(const in vec4 a, const in vec4 b) { return (a.x < b.x) ? a : b; }\n\n// INTER\nfloat opInter(const in float a, const in float b) { return max(a, b); }\nvec4 opInter(const in vec4 a, const in vec4 b) { return (a.x > b.x) ? a : b; }\n\n// SUB\nfloat opSub(const in float a, const in float b) { return max(-b, a); }\nvec4 opSub(const in vec4 a, const in vec4 b) {\n    // to keep b material on diff intersection instead of a mat\n    // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n    return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// -------------------------------\n// --- COMBINATIONS ROUND\n// -------------------------------\n\n// see hg_sdf.glsl\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n    float e = max(r - abs(a - b), 0.0);\n    return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n    return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n    vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n    return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n    return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n    return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n    return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n// -------------------------------\n// --- COMBINATIONS ROUND\n// -------------------------------\nfloat sceneDistance(const in vec3 point) {\n    float d = sdSphere(point, 1.0);\n\n    if(EDIT_ACCUMULATE) {\n        for(int i = ADDRESS_START_EDIT; i < g_endEdit; i += SIZE_TOOL) {\n            // vec4(pos.xyz, radius), vec4(type, roundness, 0, 0)\n            vec4 edit0 = readAddress(i);\n            vec4 edit1 = readAddress(i + 1);\n\n            float distEdit = sdSphere(point - edit0.xyz, edit0.w);\n            if (edit1.x > 0.0) d = opUnionRound(d, distEdit, edit1.y);\n            else d = opSubRound(d, distEdit, edit1.y);\n        }\n    }\n    \n    if (EDIT_PLANE){\n        float dPlane = sdPlane(point - vec3(0.0, -1.0, 0.0));\n        if (dPlane > -0.001) d = opUnionRound(d, dPlane, 0.2);\n    }\n    return d;\n}\n\n// -------------------------------\n// --- RAYMARCHING\n// -------------------------------\nvec2 traceRay(const in vec3 ro, const in vec3 rd) {\n    float hit = 1.0;\n\n    for (int i = 0; i < ITER_RAY_SCENE; i++) {\n        float dist = sceneDistance(ro + rd * hit);\n        if (dist < PRECISION_RAY_SCENE || hit > BAIL_DISTANCE_SCENE) break;\n        hit += dist;\n    }\n\n    return vec2(hit, hit < BAIL_DISTANCE_SCENE ? 1.0 : -1.0);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n    float hit = 0.02;\n    float res = 1.0;\n    for (int i = 0; i < ITER_RAY_SHADOW; i++) {\n        float h = sceneDistance(ro + rd * hit);\n        res = min(res, 20.0 * h / hit);\n        hit += clamp(h, 0.02, 0.10);\n        if (h < PRECISION_RAY_SHADOW || hit > BAIL_DISTANCE_SHADOW) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(sceneDistance(pos + eps.xyy) - sceneDistance(pos - eps.xyy),\n                                    sceneDistance(pos + eps.yxy) - sceneDistance(pos - eps.yxy),\n                                    sceneDistance(pos + eps.yyx) - sceneDistance(pos - eps.yyx));\n    return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.03 * float(i);\n        vec3 aopos = nor * hr + pos;\n        occ += (hr - sceneDistance(aopos)) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n//---------------------------\n// --- CAMERA RAY\n//---------------------------\nvoid computeRay(out vec3 origin, out vec3 direction, in vec2 fragCoord){\n    vec2 p = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec2 rot = readAddress(ADDRESS_CAM_XY).xy;\n\n    // ray position\n    origin = normalize(vec3(cos(rot.x), rot.y, sin(rot.x)));\n\n    // camera-to-world transformation\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(-origin, up));\n    vec3 cv = normalize(cross(cu, -origin));\n    mat3 ca = mat3(cu, cv, -origin);\n\n    // ray direction\n    direction = ca * normalize(vec3(p.xy, 2.0));\n    origin *= CAMERA_ZOOM;\n}\n\n// -------------------------------\n// --- BRDF\n// -------------------------------\n\nvec3 sph0 = vec3(0.297862, 0.314792, 0.351655);\nvec3 sph1 = vec3(0.056105, 0.108266, 0.200693);\nvec3 sph2 = vec3(0.125827, 0.107099, 0.072149);\nvec3 sph3 = vec3(0.172326, 0.144650, 0.100586);\nvec3 sph4 = vec3(0.043468, 0.044777, 0.040530);\nvec3 sph5 = vec3(0.043249, 0.038931, 0.032604);\nvec3 sph6 = vec3(0.009307, 0.012875, 0.013147);\nvec3 sph7 = vec3(0.154418, 0.127791, 0.084924);\nvec3 sph8 = vec3(0.085775, 0.076116, 0.052997);\n// vec3 lightColor = vec3(0.136829, 0.132101, 0.124833);\nvec3 lightColor = vec3(0.7, 0.67, 0.6);\nvec3 lightDirection = vec3(0.704288, 0.485562, 0.517888);\nfloat exposure = 0.754256;\n\nvec3 Irradiance_SphericalHarmonics(const in vec3 normal) {\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n    vec3 result = \n        sph0 + \n        sph1 * y + \n        sph2 * z + \n        sph3 * x + \n        sph4 * y * x + \n        sph5 * y * z + \n        sph6 * (3.0 * z * z - 1.0) + \n        sph7 * (z * x) + \n        sph8 * (x * x - y * y);\n    return max(result, vec3(0.0));\n}\n\n//------------------------------\n// RENDERING\n//------------------------------\n\n#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0 / 2.4) - 0.055\nvec3 linearTosRGB(const in vec3 color) {\n    return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b));\n}\n\nvec3 render(const in vec3 origin, const in vec3 direction) {\n    vec3 color;\n    vec2 res = traceRay(origin, direction);\n    float distance = res.x;\n\n    if (res.y > 0.0) {\n        vec3 position = origin + distance * direction;\n        vec3 n = calcNormal(position);\n        float ao = 1.0;\n        float shadow = 1.0;\n\n#ifdef HAS_AO\n        ao = calcAO(position, n);\n#endif\n#ifdef HAS_SHADOW\n        shadow = softshadow(position, lightDirection);\n#endif\n\n        vec3 r = reflect(direction, n);\n        vec3 envDiffuse = ao * Irradiance_SphericalHarmonics(n);\n        vec3 ligDiff = shadow * 0.2 * lightColor * clamp(dot(n, lightDirection), 0.0, 1.0);\n        float lightSpec = 0.3 * pow(clamp(dot(r, lightDirection), 0.0, 1.0), 16.0);\n        color = envDiffuse * ao + ligDiff * shadow + lightSpec * shadow; \n    } else {\n        color = Irradiance_SphericalHarmonics(direction);\n    }\n\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // read state\n    int state = int(readAddress(ADDRESS_STATE).x);\n    vec3 readMouse = readAddress(ADDRESS_MOUSE).xyz;\n    vec2 readEditXY = readAddress(ADDRESS_LAST_EDIT_XY).xy;\n    vec2 readCamXY = readAddress(ADDRESS_CAM_XY).xy;\n    int readEditCount = int(readAddress(ADDRESS_EDIT_COUNT).x);\n    int startStroke = int(readAddress(ADDRESS_START_STROKE).x);\n\n    bool editCamera = false;\n    bool editScene = false;\n\n    bool isAction = iMouse.z > 0.0 && readMouse.z >= 0.5;\n\n    vec2 hit;\n    vec3 originMouse, directionMouse;\n    computeRay(originMouse, directionMouse, iMouse.xy);\n\n    g_editCount = min(LIMIT_EDIT, readEditCount);\n\n    if (iMouse.z > 0.0) {\n        if(state == STATE_CAMERA){\n            editCamera = true;\n        }else{\n            g_endEdit = startStroke;\n            // pick scene under the mouse\n            hit = traceRay(originMouse, directionMouse);\n\n            // move camera if we hit the background\n            editCamera = hit.y < 0.0;\n            editScene = hit.y >= 0.0 && distance(readEditXY, iMouse.xy) > STEP_EDIT_XY;\n            if (state == STATE_EDIT) editCamera = false;\n\n            // action is starting\n            if (readMouse.z < 0.0) {\n                if (editCamera) state = STATE_CAMERA;\n                if (editScene) state = STATE_EDIT;\n                editCamera = false;\n                editScene = false;\n                startStroke = ADDRESS_START_EDIT + g_editCount * SIZE_TOOL;\n            }\n        }\n    } else {\n        state = STATE_NOTHING;\n    }\n    \n    // reset state\n    if (editScene && readEditCount >= LIMIT_EDIT){\n        readEditCount = 0;\n        startStroke = ADDRESS_START_EDIT;\n        editScene = false;\n    }\n    \n    vec2 camRot = vec2(0.0);\n    if (editCamera) {\n        camRot = CAMERA_SPEED * (iMouse.xy - readMouse.xy) / iResolution.xy;\n        camRot.y *= -1.0;\n    }\n\n    vec2 renderRes = min(iResolution.xy, RESOLUTION);\n    int idNewEdit = ADDRESS_START_EDIT + readEditCount * SIZE_TOOL;\n    \n    fragColor = vec4(0.0);\n    if (writeAddress(fragCoord, ADDRESS_STATE)) { // first frame\n        fragColor.x = float(state);\n        if (editCamera) fragColor.x = float(STATE_CAMERA);\n        if (editScene) fragColor.x = float(STATE_EDIT);\n\n    } else if (writeAddress(fragCoord, ADDRESS_MOUSE)) { // mouse\n        fragColor.xy = iMouse.xy;\n        fragColor.z = iMouse.z > 0.0 ? (readMouse.z < 0.0 ? 1.0 : 2.0) : -1.0;\n\n    } else if (writeAddress(fragCoord, ADDRESS_START_STROKE)) { // mouse\n        fragColor.x = float(startStroke);\n\n    } else if (writeAddress(fragCoord, ADDRESS_RESOLUTION)) { // resolution\n        fragColor.xy = renderRes;\n\n    } else if (writeAddress(fragCoord, ADDRESS_CAM_XY)) { // camera\n        fragColor.xy = readCamXY + camRot;\n        fragColor.y = clamp(fragColor.y, CAMERA_Y_LIMIT, PI);\n\n    } else if (writeAddress(fragCoord, ADDRESS_EDIT_COUNT)) { // index of last edit\n        fragColor.x = float(readEditCount + (editScene ? 1 : 0));\n\n    } else if (writeAddress(fragCoord, ADDRESS_LAST_EDIT_XY)) { // store xy for the last edit\n        fragColor.xy = editScene ? iMouse.xy : readEditXY;\n\n    } else if (editScene && writeAddress(fragCoord, idNewEdit)) { // edit info (part 1)\n        fragColor.xyz = originMouse + hit.x * directionMouse;\n        fragColor.w = TOOL_RADIUS;\n\n    } else if (editScene && writeAddress(fragCoord, idNewEdit + 1)) { // edit info (part 2)\n        fragColor.x = TOOL_TYPE == 1 ? 1.0 : -1.0;\n        fragColor.y = TOOL_ROUNDNESS;\n\n    } else if (int(fragCoord.y) == 0 ||\n               fragCoord.x > renderRes.x ||\n               fragCoord.y > renderRes.y) { // forward past edits\n        fragColor = texture(iChannel0, fragCoord / iChannelResolution[0].xy);\n    \n    } else { // render the scene\n        // this part could be in the final pass but it's a pain to sync\n        // the raymarching code between tabs\n        vec3 origin, direction;\n        fragCoord *= iResolution.xy / renderRes;\n        computeRay(origin, direction, fragCoord);\n\n        EDIT_PLANE = true;\n        EDIT_ACCUMULATE = true;\n        g_endEdit = ADDRESS_START_EDIT + g_editCount * SIZE_TOOL;\n\n        vec3 color = render(origin, direction);\n        fragColor = vec4(linearTosRGB(color), 1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}