{"ver":"0.1","info":{"id":"4l2XRG","date":"1444637635","viewed":500,"name":"Lava Lamp - F. A.","username":"Bosphoros","description":"Surfaces implicites, TP avec Eric Galin","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["is"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float lipschitzFallOff = 1.71730020672; // http://liris.cnrs.fr/~egfr/BestPapers/Deuxieme2014_Genevaux.pdf\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 blue=vec3(0,0.0,1.0);\nconst vec3 green=vec3(0.0,1.0,0.0);\nconst vec3 pink=vec3(0.8,0.6,0.6);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 fonce=vec3(0.141,0.117,0.078);\nconst vec3 clair=vec3(0.407,0.329,0.211);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 orangeFonce = vec3(0.3,0.0,0.0);\nconst vec3 blanc = vec3(0.9,0.9,0.9);\nconst vec3 noir = vec3(0.1,0.1,0.1);\nconst vec3 tenebres = vec3(0.0,0.0,0.0);\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nfloat bruit(in vec3 p, float frequence)\n{\n    float b = 0.0;\n    vec3 q = frequence*p;\n    b += 0.7*noise(q); q = m*q*2.01;\n    b += 0.25*noise(q); q = m*q*2.02;\n    b/= 0.7+0.25;\n    \n    return b;\n}\n\nvec3 warp(in vec3 p)\n{\n float b = bruit(p, .25);\n    vec3 pprime = p;\n    pprime.x += b;\n    pprime.y += cos(b)*b;\n    pprime.z += sin(b)*b;\n    return pprime;\n}\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment skeleton\n// p : point\n// a : first point of the segment\n// b : last point of the segment\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = length(a-b);\n    float n = dot(p-a,dir);\n    float d = 0.0;\n    // p' est avant a\n    if(n <= 0.0) {\n        d = length(p-a);\n    }\n    else {\n        // p' est aprÃ¨s b\n        if(n >= dist) {\n            d = length(p-b);\n        }\n        else {\n            d = length(p-(a+dir*n));\n        }\n    }\n    return e*falloff(d, R);   \n}\n\n// Segment skeleton\n// p : point\n// c : center of the circle\n// n : normal to the plan of the circle\n// e : energy associated to skeleton\n// r : radius of the circle\n// R : large radius \nfloat cercle(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    return e*falloff(length(p-h), R);\n    \n}\n\n// Segment skeleton\n// p : point\n// c : center of the disc\n// n : normal to the plan of the disc\n// r : radius of the disc\n// e : energy associated to skeleton\n// R : large radius \nfloat disque(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    float projhc = dot(pc, cnp);\n    vec3 pprime = c + projhc * cnp;\n    float d = 0.0;\n    if(length(c-pprime) > r)\n    {\n    \td = length(p-h);   \n    }\n    else\n    {\n        d = length(p - pprime);\n        \n    }\n    return e*falloff(d, R);\n    \n}\n\n// Box skeleton\n// p : point\n// a : bottom front left point of the box\n// b : top back right point of the box\nfloat boite(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tfloat d = 0.0;\n    \n    if(p.x < a.x) \n        d += (a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d += (b.x-p.x)*(b.x-p.x);\n\n        \n    if(p.y < a.y) \n        d += (a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d += (b.y-p.y)*(b.y-p.y);\n\n    \n    if(p.z < a.z) \n        d += (a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d += (b.z-p.z)*(b.z-p.z);\n\n    return e*falloff(d,R);\n}\n\nfloat cylindre(vec3 p, vec3 a, vec3 b, float r, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = dot(p-a, dir);\n    if(dist < 0.0)\n        return disque(p, a, dir, r, e, R);\n    else\n        if (dist > length(b-a))\n            return disque(p, b, dir, r, e, R);\n        else\n            return disque(p, a+dist*dir, dir, r, e, R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    colOut = (a*colA + b*colB) / (a+b);\n    lipsOut = lipsA + lipsB;\n    return a+b;\n}\n\nfloat Diff(float a,float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = lipsA + lipsB;\n    colOut = colA;\n    return a-b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    if( a > b)\n        colOut = colA;\n    else\n        colOut = colB;\n    return max(a,b);\n}\n\nfloat Intersection(float a, float b, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    if(a < b)\n        colOut = colA;\n    else\n        colOut = colB;\n \treturn min(a,b);   \n}\n\nfloat Cut(float a, float b, float t, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    colOut = colA;\n \treturn min(a, 2.0*t-b);   \n}\n\nfloat Metamorph(float a, float b, float c, in float lipsA, in float lipsB, out float lipsOut, in vec3 colA, in vec3 colB, out vec3 colOut)\n{\n    lipsOut = max(lipsA, lipsB);\n    colOut = (1.0-c)*colA+c*colB;\n   return (1.0-c)*a+c*b;\n}\n\nfloat klipschitz(float e, float R) {\n \treturn e * lipschitzFallOff / R;   \n}\n\nfloat atom(vec3 p, out float lip, out vec3 colorOut)\n{\n    lip = 0.0;\n    float lipTemp = 0.0;\n    vec3 centreSphr = vec3(0.0,0.0,0.0);\n    vec3 centreSphr1 = vec3(cos(iTime*0.25)*2.0,sin(iTime*0.4)*2.0,cos(iTime*0.1)*2.0);\n    vec3 centreSphr2 = vec3(0.5,0.0,0.0);\n    vec3 centreSphr3 = vec3(-0.5,0.0,0.0);\n    vec3 aCube = centreSphr2+vec3(-0.5,-0.5,-0.5)+vec3(0.0,3.0,2.0)*cos(iTime);\n    vec3 bCube = centreSphr2+vec3(0.5,0.5,0.5)+vec3(0.0,3.0,2.0)*cos(iTime);\n    float v = point(p,centreSphr,1.0,1.5);\n    float cube = boite(p, aCube, bCube, 0.6, 0.8);\n    float sphr1 = point(p, centreSphr2+vec3(0.0,3.0,2.0)*cos(iTime), 1.0,1.5);\n    vec3 sphrColor;\n    vec3 color;\n    sphr1 = Metamorph(sphr1, cube, abs(cos(iTime)), klipschitz(1.0,1.5), klipschitz(0.6,0.8), lipTemp, red, red, sphrColor);\n    \n    \n    v = Diff(v, point(p,centreSphr1, 1.0+abs(sin(iTime*0.8)),2.1), klipschitz(1.0, 1.5), klipschitz(1.0+abs(sin(iTime*0.8)), 2.1), lip, blue, blue, color);\n    v = Blend(v, sphr1, lip, lipTemp, lip, color, sphrColor, color);\n    v = Blend(v, point(p, centreSphr3-vec3(4.0,3.0,0.0)*cos(iTime*1.1), 1.0, 1.5), lip, klipschitz(1.0,1.5), lip, color, red, color);\n    v = Blend(v, point(p, centreSphr+vec3(2.0,0.0,2.0)*sin(iTime*0.8), 1.0, 1.5), lip, klipschitz(1.0,1.5), lip, color, red, color);\n    v = Union(v, cercle(p, centreSphr, rotateX(vec3(0.0,1.0,0.0),iTime*0.25), 1.4, 0.6,0.6), lip, klipschitz(0.6,0.6), lip, color, noir, color);\n    v = Union(v, cercle(p, centreSphr, rotateZ(vec3(0.0,1.0,0.0),iTime), 2.1, 0.6, 0.6), lip, klipschitz(0.6,0.6), lip, color, grey2, color);\n    v = Union(v, cercle(p, centreSphr, rotateX(vec3(1.0,0.0,1.0), iTime*1.2), 2.8, 0.55, 0.8), lip, klipschitz(0.55,0.8), lip, color, grey, color);\n    colorOut = color;\n    return v;\n}\n\nfloat lavaLamp(vec3 p, out float lip, out vec3 colorOut)\n{\n    lip = klipschitz(1.0,1.5);\n    vec3 cntrBulle1 = vec3(0.4*cos(iTime), ((1.0+cos(iTime*0.4))/2.0)*4.-2., 0.4*sin(iTime));\n \tfloat bulle1 = point(warp(p), cntrBulle1, 1.0, 1.5);\n    vec3 cntrBulle2 = vec3(0.2*sin(iTime), ((1.0+cos(iTime*0.2))/2.0)*3.5-1.75, 0.2*cos(iTime));\n \tfloat bulle2 = point(warp(p), cntrBulle2, 1.5, 2.0);\n    vec3 cntrBulle3 = vec3(0.5*sin(iTime+3546.), ((1.0+cos(iTime*0.3))/2.0)*4.5-2.25, 0.5*cos(iTime+3546.));\n \tfloat bulle3 = point(warp(p), cntrBulle3, 1.25, 1.75);\n    float v = Blend(bulle1, bulle2, lip, klipschitz(2.0,1.5), lip, red, orange, colorOut);\n    v = Blend(v, bulle3, lip, klipschitz(1.25,1.75), lip, colorOut, red, colorOut);\n    \n    vec3 colorLamp;\n    float hsphere = point(p, vec3(0.0, -3.5, 0.0), 4.,4.);\n    float lipH;\n    hsphere = Cut(hsphere, cylindre(p, vec3(0.,0.,0.), vec3(0.,-3.5,0.), 4., 1.0, 1.0), 0.5, klipschitz(4.,4.), klipschitz(1.,1.),lipH, mix(grey, grey2, 0.5), mix(grey, grey2, 0.5), colorLamp);\n    float bsphere = point(p, vec3(0.0, 3.0, 0.0), 2.5,2.5);\n    float lipB;\n    bsphere = Cut(bsphere, cylindre(p, vec3(0.,0.,0.), vec3(0.,3.,0.), 4., 1.0, 1.0), 0.5, klipschitz(2.,2.), klipschitz(1.,1.), lipB, mix(grey, grey2, 0.5), mix(grey, grey2, 0.5), colorLamp);\n    v = Union(v, hsphere, lip, lipH, lip, colorOut, colorLamp, colorOut);\n    v = Union(v, bsphere, lip, lipB, lip, colorOut, colorLamp, colorOut);\n    \n    \n    return v;\n    \n}\n\n// Potential field of the object\n// p : point\n// lip : lipschitz's constant\n// color : color of the point\nfloat object(vec3 p, out float lip, out vec3 color)\n{\n  p.z=-p.z;\n    \n    \n    vec3 aCube = vec3(-1.5,-1.5,-1.5);\n    vec3 bCube = vec3(1.5,1.5,1.5);\n    vec3 sphr1 = vec3(1.,0.0,0.0);\n    vec3 sphr2 = vec3(-1.,0.0,0.0);\n\n  \tfloat v = lavaLamp(p, lip, color);\n    \n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    float lip = 0.0;\n    vec3 color;\n  float v = object(p, lip, color);\n  n.x = object( vec3(p.x+eps, p.y, p.z) , lip, color) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) , lip, color) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) , lip, color) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip = 0.0;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\tfloat lip = 0.0;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lip);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\n// color : color of the point\nvec3 Shade(vec3 p, vec3 n, in vec3 color)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.5*color;\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\tvec3 color;\n  float t = SphereTrace(ro, rd, hit,s, color);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n, color);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"","description":"","type":"image"}]}