{"ver":"0.1","info":{"id":"7tdyz4","date":"1659388459","viewed":216,"name":"Quaternion Mandelbrot Set","username":"overallcyber","description":"The true form of the Mandelbrot set. Expands the mandelbrot set into 3d using quaternions instead of just complex numbers, and raymarches to the boundary of that function.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","quaternion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ITERATIONS = 30.0;\nfloat THRESHOLD = 10.0;\n\nfloat MAX_DIST = 10.0;\nint MAX_STEPS = 1500;\n\nfloat SURF_THRESHOLD = 0.001;\n\nfloat ROT_SPEED = 0.1;\n\nvec4 quatsqr(vec4 z){\n    float a = z.r;\n    float b = z.g;\n    float c = z.b;\n    float d = z.a;\n    \n    float r = a*a - b*b - c*c - d*d;\n    float i = 2.0*a*b + 2.0*d*c;\n    float j = 2.0*a*c - 2.0*b*d;\n    float k = 2.0*a*d + 2.0*b*c;\n    \n    return vec4(r, i, j, k);\n}\n\nfloat fractal(vec4 c){\n    vec4 z = vec4(0);\n    float l = 0.0;\n    for(int i=0;i<int(ITERATIONS);i++){\n        z = quatsqr(z)+c;\n        if(dot(z,z) > THRESHOLD) break;\n        l += 1.0;\n    }\n\n    if(l> ITERATIONS-1.0)return 0.0;\n    \n    float sl = l - log2(log2(dot(z,z)))+4.0;\n    \n    l = 1.0-sl/ITERATIONS;\n    \n    return l;\n}\n\nvec3 raymarch(vec3 rayOrigin, vec3 rayDirection){\n    vec4 pointer = vec4(rayOrigin, 0.0);\n    vec4 direction = vec4(rayDirection, 0.0);\n    \n    float dist = fractal(pointer);\n    float steps = 0.0;\n    \n    float minDist = dist;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        if(dist <= SURF_THRESHOLD) break;\n        if(dist >= MAX_DIST) break;\n        pointer += direction*dist*0.03;\n        dist = fractal(pointer);\n        minDist = (dist < minDist)?dist:minDist;\n        steps += 1.0;\n    }\n    \n    \n    \n    return vec3(minDist, steps, length(pointer.xyz-rayOrigin));\n}\n\nvec3 getNormal(vec3 point, mat3 worldMat){\n    float d = 0.02;\n    \n    vec4 p = vec4(point, 0.0);\n    vec4 dx = vec4(vec3(d, 0, 0)*worldMat, 0.0);\n    vec4 dy = vec4(vec3(0, d, 0)*worldMat, 0.0);\n    vec4 dz= vec4(vec3(0, 0, d)*worldMat, 0.0);\n    \n    float dist = fractal(p);\n    float DX = dist - fractal(p+dx);\n    float DY = dist - fractal(p+dy);\n    float DZ = dist - fractal(p+dz);\n    \n    return normalize(vec3(DX,DY,DZ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 plane = (uv - vec2(0.5))*vec2(19.0/9.0, 1.0) * 2.0;\n    \n    float a = iTime*ROT_SPEED;\n    \n    mat3 rotY = mat3(cos(a), 0, sin(a), 0, 1.0, 0, -sin(a), 0, cos(a));\n    mat3 rotX = mat3(1.0,0,0,0,cos(a),-sin(a),0,sin(a),cos(a));\n    mat3 worldRot = rotY*rotX;\n    \n    vec3 rayOrigin = vec3(plane, 10.0)*rotY*rotX;\n    vec3 rayDirection = vec3(0,0,-1.0)*rotY*rotX;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 march = raymarch(rayOrigin, rayDirection);\n    float l = march.x;\n    float steps = march.y;\n    float depth = march.z;\n    \n    if(l < SURF_THRESHOLD) {\n        vec3 normal = getNormal(rayOrigin + rayDirection*depth, worldRot);//*inverse(worldRot);\n        col = vec3(1.0);\n        //col *= 200.0/(steps);\n        //col *= pow(length(col),2.0);\n        vec3 shadowCol = col * dot(normal,-normalize(vec3(1.0,1.0,0.0)));\n        col = mix(col, shadowCol, 0.9);\n        col = mix(col, abs(normal), 0.5);\n    }else{\n        col += vec3(0.2)/l;\n        col *= col;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}