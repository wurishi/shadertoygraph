{"ver":"0.1","info":{"id":"DlXyzH","date":"1690481316","viewed":95,"name":"Gradient Noise Study","username":"Oneleven","description":"Had a hard time understanding how exactly gradient noise works, so I made this little study","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","gradient","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ZOOM = 20.;\n#define PIXEL_SIZE ZOOM/iResolution.x\n#define sm(x) smoothstep(0.,1.,x)\n\n//Hash without Sine by Dave_Hoskins \n//https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)*2.0 - 1.0;\n}\n\n//Segment - distance 2D by iq\n//https://www.shadertoy.com/view/3tdSDj\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nfloat pointer(vec2 uv, vec2 start, vec2 end)\n{\n    float line = smoothstep(PIXEL_SIZE*1.5, 0.0,line_segment(uv, start, end));\n    float point = smoothstep(PIXEL_SIZE*3.0, PIXEL_SIZE,distance(uv,end));\n    return line * 0.3 + point;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv+=vec2(iTime)*vec2(0.03,0.011);\n    \n    uv = uv*ZOOM;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    float t  = mod(iTime*1.,8.);               //full anim cycle\n    float t1 = sm(clamp(t, 0.,2.)*0.5);        //move pointers and show dot products\n    float t2 = sm(clamp(t, 2.5,3.5) - 2.5);    //show gradient noise\n    float t3 = sm(clamp(t, 4.,5.) - 4.);       //show pointers again\n    float t4 = sm((clamp(t, 5.,7.) - 5.)*0.5); //end of cycle\n    \n    float points = 0.;\n    for (float i=-0.; i<=1.; i++)\n        for (float j=-0.; j<=1.; j++)\n            {\n                vec2 start = vec2(i,j);\n                vec2 end = mix(vec2(i,j), hash22(id + vec2(i,j)) + vec2(i,j), t1-t4);\n                points += pointer(uv, start, end);\n            }\n    points = mix(points, 0., t2-t3);\n    \n    float botLeft  = dot(uv - vec2(0,0), mix(vec2(0,0), hash22(id + vec2(0,0)), t1-t4));\n    float topLeft  = dot(uv - vec2(0,1), mix(vec2(0,0), hash22(id + vec2(0,1)), t1-t4));\n    float botRight = dot(uv - vec2(1,0), mix(vec2(0,0), hash22(id + vec2(1,0)), t1-t4));\n    float topRight = dot(uv - vec2(1,1), mix(vec2(0,0), hash22(id + vec2(1,1)), t1-t4));\n    \n    float f = 0.;\n    if (uv.x < 0.5)\n        if (uv.y < 0.5) f = botLeft;\n        else            f = topLeft;\n    else\n        if (uv.y < 0.5) f = botRight;\n        else            f = topRight;\n    \n    vec3 col = vec3(0);\n\n    if (f>0.) col = clamp(f,0.0,1.0)*vec3(1.0,0.15,0);\n    else      col = clamp(-f,0.0,1.0)*vec3(0,.4,1.0);\n\n    vec2 uv2 = sm(uv);\n    float f2 = mix(mix(botLeft, botRight, uv2.x),\n                   mix(topLeft, topRight, uv2.x), uv2.y);\n    f2 = f2*0.5+0.5;\n    \n    col = mix(col, vec3(f2), t2-t4);\n    col = col*(1.-points) + vec3(points);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}