{"ver":"0.1","info":{"id":"lccfD4","date":"1733104759","viewed":106,"name":"Dr.Jonathan Blur","username":"sailboy","description":"hh","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["hh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int totalSamples = 5;  // Total samples for the blur kernel\nconst int blurLOD = 2;       // Gaussian blur performed at MIPmap level 2\nconst int tileSize = 1 << blurLOD; // Tile size = 2^blurLOD\nconst float blurSigma = float(totalSamples) * 0.25; // Spread of the Gaussian distribution\n\n// 2D Gaussian weight calculation\nfloat computeGaussianWeight(vec2 offset) {\n    // Normalize the offset by dividing by the standard deviation (sigma)\n    offset /= blurSigma;\n\n    // Compute the squared distance from the center\n    float squaredDistance = dot(offset, offset);\n\n    // Calculate the Gaussian weight\n    return exp(-0.5 * squaredDistance) / (6.28 * blurSigma * blurSigma); // 6.28 = 2Ï€\n}\n\n// Function to apply the Gaussian blur at the specified MIPmap level\nvec4 applyGaussianBlur(sampler2D source, vec2 uv, vec2 texelScale) {\n    vec4 blurredColor = vec4(0.0); // Accumulate the blurred color\n    int reducedSamples = totalSamples / tileSize; // Samples per reduced-resolution tile\n\n    for (int sampleIndex = 0; sampleIndex < reducedSamples * reducedSamples; sampleIndex++) {\n        // Calculate the sample offset within the kernel\n        vec2 sampleOffset = vec2(sampleIndex % reducedSamples, sampleIndex / reducedSamples) \n                            * float(tileSize) - float(totalSamples) / 2.0;\n\n        // Accumulate the weighted texture color at the sampled offset\n        blurredColor += computeGaussianWeight(sampleOffset) \n                        * textureLod(source, uv + texelScale * sampleOffset, float(blurLOD));\n    }\n\n    // Normalize by the alpha channel to preserve transparency\n    return blurredColor / blurredColor.a;\n}\n\n// Main rendering function\nvoid mainImage(out vec4 outputColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;      // UV coordinates of the current fragment\n    vec2 cursorPosition = iMouse.xy / iResolution.xy; // Cursor position in normalized UV space\n\n    // Compensate for aspect ratio to ensure the blur region is circular\n    vec2 aspectRatioCompensation = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 normalizedOffset = (uv - cursorPosition) * aspectRatioCompensation;\n\n    float blurRadius = 0.4;                    // Radius of the blur region\n    float distanceFromCursor = length(normalizedOffset); // Compute distance from cursor\n\n    if (distanceFromCursor < blurRadius) {\n        // Determine the blur strength based on the distance to the cursor\n        float blurStrength = smoothstep(blurRadius, 0.0, distanceFromCursor);\n    \n        // Apply the blur within the circular region\n        vec4 blurred = applyGaussianBlur(iChannel0, uv, 1.0 / iChannelResolution[0].xy);\n        vec4 original = texture(iChannel0, uv);\n\n        // Blend between the blurred and original image based on the blur strength\n        outputColor = mix(original, blurred, blurStrength);\n    } else {\n        // Outside the blur region, use the original texture color\n        outputColor = texture(iChannel0, uv);\n    }\n}","name":"Image","description":"","type":"image"}]}