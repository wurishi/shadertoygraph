{"ver":"0.1","info":{"id":"fttBz2","date":"1663348877","viewed":80,"name":"Fork Procedural mikegao45 680","username":"mikegao45","description":"My first ShaderToy - simple audio reactive design element with procedurally generated textures and animating colour highlight.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","music","perlin","gradient","audio","value","shape"],"hasliked":0,"parentid":"tdfGzB","parentname":"Procedural Gradient Visualiser"},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Value Noise 2D\n// Return value range of 0.0->1.0\n// Source: https://github.com/BrianSharpe/Wombat\n// Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\nfloat Value2D( vec2 P )\n{\n\t//\testablish our grid cell and unit position\n\tvec2 Pi = floor(P);\n\tvec2 Pf = P - Pi;\n\n\t//\tcalculate the hash.\n\tvec4 Pt = vec4( Pi.xy, Pi.xy + 1.0 );\n\tPt = Pt - floor(Pt * ( 1.0 / 71.0 )) * 71.0;\n\tPt += vec2( 26.0, 161.0 ).xyxy;\n\tPt *= Pt;\n\tPt = Pt.xzxz * Pt.yyww;\n\tvec4 hash = fract( Pt * ( 1.0 / 951.135664 ) );\n\n\t//\tblend the results and return\n\tvec2 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n\tvec4 blend2 = vec4( blend, vec2( 1.0 - blend ) );\n\treturn dot( hash, blend2.zxzx * blend2.wwyy );\n}\n\n// Value Noise 3D\n// Return value range of 0.0->1.0\n// Source: https://github.com/BrianSharpe/Wombat\n// Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\nfloat Value3D( vec3 P )\n{\n\t// establish our grid cell and unit position\n\tvec3 Pi = floor(P);\n\tvec3 Pf = P - Pi;\n\tvec3 Pf_min1 = Pf - 1.0;\n\n\t// clamp the domain\n\tPi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n\tvec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n\t// calculate the hash\n\tvec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n\tPt *= Pt;\n\tPt = Pt.xzxz * Pt.yyww;\n\tvec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n\tvec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n\tvec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n\t//\tblend the results and return\n\tvec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n\tvec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n\tvec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n\treturn dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\n// Perlin Noise 2D\n// Return value range of -1.0->1.0\n// Source: https://github.com/BrianSharpe/Wombat\n// Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\nfloat Perlin2D( vec2 P )\n{\n\t// establish our grid cell and unit position\n\tvec2 Pi = floor(P);\n\tvec4 Pf_Pfmin1 = P.xyxy - vec4( Pi, Pi + 1.0 );\n\n\t// calculate the hash\n\tvec4 Pt = vec4( Pi.xy, Pi.xy + 1.0 );\n\tPt = Pt - floor(Pt * ( 1.0 / 71.0 )) * 71.0;\n\tPt += vec2( 26.0, 161.0 ).xyxy;\n\tPt *= Pt;\n\tPt = Pt.xzxz * Pt.yyww;\n\tvec4 hash_x = fract( Pt * ( 1.0 / 951.135664 ) );\n\tvec4 hash_y = fract( Pt * ( 1.0 / 642.949883 ) );\n\n\t// calculate the gradient results\n\tvec4 grad_x = hash_x - 0.49999;\n\tvec4 grad_y = hash_y - 0.49999;\n\tvec4 grad_results = inversesqrt( grad_x * grad_x + grad_y * grad_y ) * ( grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww );\n\n\t// classic Perlin Interpolation\n\tgrad_results *= 1.4142135623730950488016887242097; // scale things to a strict -1.0->1.0 range *= 1.0/sqrt(0.5)\n\tvec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n\tvec4 blend2 = vec4( blend, vec2( 1.0 - blend ) );\n\treturn dot( grad_results, blend2.zxzx * blend2.wwyy );\n}\n\n// Perlin Noise 3D\n// Return value range of -1.0->1.0\n// Source: https://github.com/BrianSharpe/Wombat\n// Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\nfloat Perlin3D( vec3 P )\n{\n\t// establish our grid cell and unit position\n\tvec3 Pi = floor(P);\n\tvec3 Pf = P - Pi;\n\tvec3 Pf_min1 = Pf - 1.0;\n\n\t// clamp the domain\n\tPi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n\tvec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n\t// calculate the hash\n\tvec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n\tPt *= Pt;\n\tPt = Pt.xzxz * Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n\tconst vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\tvec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n\tvec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n\tvec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n\tvec4 hashx1 = fract( Pt * highz_mod.xxxx );\n\tvec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n\tvec4 hashy1 = fract( Pt * highz_mod.yyyy );\n\tvec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n\tvec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n\t// calculate the gradients\n\tvec4 grad_x0 = hashx0 - 0.49999;\n\tvec4 grad_y0 = hashy0 - 0.49999;\n\tvec4 grad_z0 = hashz0 - 0.49999;\n\tvec4 grad_x1 = hashx1 - 0.49999;\n\tvec4 grad_y1 = hashy1 - 0.49999;\n\tvec4 grad_z1 = hashz1 - 0.49999;\n\tvec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n\tvec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n\t// classic Perlin Interpolation\n\tvec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n\tvec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n\tvec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n\tfloat final = dot( res0, blend2.zxzx * blend2.wwyy );\n\treturn ( final *15.1547005383792515290182975610039 ); // scale things to a strict -1.0->1.0 range *= 1.0/sqrt(0.75)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Spatial coordinates\n\tvec2 uv = fragCoord-iResolution.xy*0.5;\n// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uvn = fragCoord/iResolution.xx;\n    float ar = iResolution.y/iResolution.x;\n\n// Find usable frequencies in the audio file\n//\tvec3 test = texture(iChannel0, uvn).xyz;\n//\ttest.g = 1.0-smoothstep(0.0, 0.005, abs(uvn.x-0.096));\n//\ttest.g *= 0.5;\n//\tfragColor = vec4(test,1.0);\n// Sample specific notes from the audio file\n\tfloat amp = texture(iChannel0, vec2(0.096, 0.1)).x;\n\tamp += texture(iChannel0, vec2(0.121, 0.1)).x;\n\tamp += texture(iChannel0, vec2(0.129, 0.1)).x;\n\n// Procedural grain\n\tfloat grain = Value3D(vec3(uv*0.407*(1.0-amp*0.05)+7.03, 1.4));\n\tgrain += Value3D(vec3(uv*0.573*(1.0-amp*0.1)+17.47, 3.5));\n\tgrain += Value3D(vec3(uv*0.619*(1.0-amp*0.15)+23.51, 5.6));\n\tgrain *= 0.025;\n\tgrain += 1.;\n\n\tfloat grad = clamp(length(uvn - vec2(0.5, 0.5*ar))*2.0-amp*0.0125, 0.0, 1.0);\n\tfloat shape = smoothstep(0.0, 1.5, (grad-0.125)/fwidth(grad));\n\tfloat highlight = smoothstep(0.0, 0.2, grad-amp*0.05+Perlin3D(vec3(uvn*6.7+2.3, iTime*0.75+11.1))*0.1*(amp*0.5+0.75));\n\tgrad = clamp(length(uvn - vec2(0.5, 0.48*ar))*2.0-amp*0.0125, 0.0, 1.0);\n\tfloat shadow = pow(smoothstep(0.1, 0.16, grad), 0.25);\n\tvec3 color = mix(vec3(0.0, 1.0, .98), vec3(0.0, 1.0, 1.0), Perlin3D(vec3(uvn*7.3-1.9, iTime*0.95+3.7))*0.5+0.5);\n\tcolor = mix(color*grain*shadow, vec3(grain), highlight);\n\tcolor = mix(vec3(grain), color, shape);\n\n    // Output to screen\n\tfragColor = vec4(color,1.0);\n//\tfragColor = vec4(vec3(amp),1.0);\n}","name":"Image","description":"","type":"image"}]}