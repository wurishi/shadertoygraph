{"ver":"0.1","info":{"id":"MtlBWB","date":"1513205192","viewed":655,"name":"raymarching ambient occlusion","username":"glowcoil","description":"raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat room(vec3 p, vec3 size) {\n    return min(min(min(p.x, size.x - p.x), min(p.y, size.y - p.y)), min(p.z, size.z - p.z));\n}\n\nvec2 sdf(vec3 p) {\n    float s = min(sphere(p-vec3(.275,.45,0), 0.25), min(sphere(p-vec3(0,0,0), 0.25), sphere(p-vec3(.55,0,0), 0.25)));\n    float r = room(p - vec3(-5, -2.5, -5), vec3(10, 5, 10));\n    if (s < r) {\n        return vec2(s, 0.0);\n    } else {\n        return vec2(r, 1.0);\n    }\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float epsilon = 0.1;\n    \n    vec3 u;\n    if (abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z)) {\n        u = cross(n, vec3(1,0,0));\n    } else if (abs(n.y) < abs(n.z)) {\n        u = cross(n, vec3(0,1,0));\n    } else {\n        u = cross(n, vec3(0,0,1));\n    }\n    vec3 v = cross(n, u);\n    \n    occ += max(sdf(p + epsilon*n).x,0.0);\n    occ += max(sdf(p + epsilon*(u)).x,0.0);\n    occ += max(sdf(p + epsilon*(-u)).x,0.0);\n    occ += max(sdf(p + epsilon*(v)).x,0.0);\n    occ += max(sdf(p + epsilon*(-v)).x,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n+u)).x/2.0,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n-u)).x/2.0,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n+v)).x/2.0,0.0);\n    occ += max(sdf(p + 4.0*epsilon*(n-v)).x/2.0,0.0);\n    occ += max(sdf(p + 2.0*epsilon*n).x/sqrt(2.0),0.0);\n    occ += max(sdf(p + 3.0*epsilon*n).x/sqrt(3.0),0.0);\n    occ += max(sdf(p + 4.0*epsilon*n).x/sqrt(4.0),0.0);\n\n    return clamp(1.0 - 1.0/(1.0+2.0*pow(occ,1.0)), 0.0, 1.0);\n}\n\nvec3 material(float m) {\n    if (m == 0.0) {\n        return vec3(.8, .4, .4);\n    } else {\n        return vec3(.2, .2, .4);\n    }\n}\n\nvec3 normal(vec3 p) {\n    vec3 epsilon = vec3(0.001, 0, 0);\n    return normalize(vec3(\n        sdf(p + epsilon.xyy).x - sdf(p - epsilon.xyy).x,\n        sdf(p + epsilon.yxy).x - sdf(p - epsilon.yxy).x,\n        sdf(p + epsilon.yyx).x - sdf(p - epsilon.yyx).x ));\n}\n\nvec3 ray(vec3 eye, vec3 dir, out int iters) {\n    vec3 p = eye + sdf(eye).x * dir;\n    iters = 0;\n    vec2 d;\n    for (int i = 0; i < 50; i++) {\n        d = sdf(p);\n\n        p += d.x * dir;\n        if (d.x < .001) {\n            break;\n        }\n\n        iters += 1;\n    }\n    \n    vec3 light = normalize(vec3(2.0*cos(2.0*iTime), sin(iTime), 2.0*sin(2.0*iTime)));\n\n    vec3 n = normal(p);\n    vec3 light_dir = normalize(light - p);\n    vec3 mirrored = -normalize(2.0*dot(n,dir)*n - dir);\n    vec3 half_vector = normalize((-dir + light_dir) / 2.0);\n    vec3 brightness = ao(p,n) * (material(d.y) * (0.2 + 0.6 * clamp(.3 + .7 * dot(n, light_dir), 0.0, 1.0)) + vec3(1.0, 1.0, 1.0) * 0.15 * pow(clamp(dot(half_vector, n), 0.0, 1.0), 20.0));\n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int iters;\n\n    vec3 eye = vec3(3.5*cos(iTime), sin(iTime + 1.0), 3.5*sin(iTime));\n    vec3 up = vec3(0,1,0);\n    vec3 forward = normalize(vec3(0,0,.5*sin(iTime)) - eye);\n    vec3 right = cross(forward, up);\n    vec2 pixel = fragCoord.xy / iResolution.x - vec2(.5,.5*iResolution.y/iResolution.x);\n    vec3 dir = forward + (pixel.x * right - pixel.y * up);\n    vec3 color = ray(eye, normalize(dir), iters);\n\n    if (iters > 25) {\n        vec3 dx = .125*right/iResolution.x;\n        vec3 dy = .125*up/iResolution.y;\n        vec3 a = ray(eye, normalize(dir - dx - dy), iters);\n        vec3 b = ray(eye, normalize(dir + dx - dy), iters);\n        vec3 c = ray(eye, normalize(dir + dx + dy), iters);\n        vec3 d = ray(eye, normalize(dir - dx + dy), iters);\n\n        color = mix(mix(a, b, .5), mix(c, d, .5), .5);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}