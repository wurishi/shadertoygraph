{"ver":"0.1","info":{"id":"4cSyzm","date":"1722030374","viewed":52,"name":"Spinning Sin Waves Mouse Control","username":"TWKTemplar","description":"has mouse pos and then puts a circle there","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hex"],"hasliked":0,"parentid":"4XV3z1","parentname":"DancingHexagon"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//rotateUV function https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid)\n{\n    float cosAngle = cos(rotation);\n    float sinAngle = sin(rotation);\n    return vec2(\n        cosAngle * (uv.x - mid.x) + sinAngle * (uv.y - mid.y) + mid.x,\n        cosAngle * (uv.y - mid.y) - sinAngle * (uv.x - mid.x) + mid.y\n    );\n}\n\n//I simplfied the tile map set up from https://www.shadertoy.com/view/wtdSzX So that it is even simpler\nfloat hexGradient(vec2 uv)//Draw hexagon gradient\n{    \n    // Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n    // 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n    vec2 s = vec2(1.7320508, 1); // scale factors for hexagon\n    uv = abs(uv);\n    return max(dot(uv, s*.5), uv.y); // Hexagon gradient\n}\nfloat drawHex(vec2 uv, float scale, float width)\n{\n    //Draw hexagon gradient\n    vec2 s = vec2(1.7320508, 1); // scale factors for hexagon\n    uv = abs(uv);\n    float hexGradient = max(dot(uv, s*.5), uv.y); // Hexagon gradient\n\n    //Mask gradient into sharp hex shape\n    width *= 0.1f;\n    float scale2 = 1.0/scale;\n    float hexa = 1.0-floor(hexGradient*(scale2));//Inner mask\n    float hexb =     floor(hexGradient*(scale2* (1.0+(width*scale2))));//outer mask\n    return hexa*hexb;\n    \n}\n\nfloat Circle(vec2 uv, vec2 pos, float size)\n{\n  vec2 ratioAdjustment = vec2(1,resolution.y/resolution.x);\n  return step(dist(pos*ratioAdjustment,uv*ratioAdjustment),size*0.1);//black and white drawing of a Circle\n}\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;// Get UV's\n    \n    \n    vec2 mousePos = vec2(iMouse.x/resolution.x,iMouse.y/resolution.y);\n    if(mousePos.y < 0.01)\n    {\n        mousePos = vec2(sin(iTime)*2.0+5.0,cos(iTime)*2.0+5.0)*0.1;\n    }\n    uv -= mousePos;\n    \n    float CircleMask = Circle(uv,vec2(0.0,0.0),1.5*mousePos.y);\n    \n    uv.x *= iResolution.x/iResolution.y;//Scale UV's\n    \n    uv *= 1.0/(mousePos.y);\n    \n    uv = rotateUV(uv,iTime,vec2(0.0,0.0));//Comment this line out to stop rotation\n    \n    float SinCurveA = sin((uv.x+(0.02*sin(iTime*1.1)))*10.0)*0.1 <= uv.y ? 1.0 : 0.0;\n    float SinCurveB = sin((uv.x+(0.02*sin(iTime)))*10.0)*0.1+0.05 >= uv.y ? 1.0 : 0.0;\n    float SinCurveAB =SinCurveA * SinCurveB;\n    \n    uv = rotateUV(uv,iTime,vec2(0.0,0.0));//Comment this line out to stop rotation\n    \n    float SinCurveA2 = sin((uv.x+(0.02*sin(iTime*1.1)))*10.0)*0.1 <= uv.y ? 1.0 : 0.0;\n    float SinCurveB2 = sin((uv.x+(0.02*sin(iTime)))*10.0)*0.1+0.05 >= uv.y ? 1.0 : 0.0;\n    float SinCurveAB2 =SinCurveA2 * SinCurveB2;\n    \n    uv = rotateUV(uv,iTime,vec2(0.0,0.0));//Comment this line out to stop rotation\n    \n    float SinCurveA3 = sin((uv.x+(0.02*sin(iTime*1.1)))*10.0)*0.1 <= uv.y ? 1.0 : 0.0;\n    float SinCurveB3 = sin((uv.x+(0.02*sin(iTime)))*10.0)*0.1+0.05 >= uv.y ? 1.0 : 0.0;\n    float SinCurveAB3 =SinCurveA3 * SinCurveB3;\n\n    \n\n    vec3 col = vec3(SinCurveAB,SinCurveAB2,SinCurveAB3) * CircleMask;\n    \n    vec3 colhsv = rgb2hsv(col);\n    colhsv.x += sin(iTime*0.5)*0.5;\n    col = hsv2rgb(colhsv);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define time        iTime\n#define resolution  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\nfloat sqr(float a){return pow(a,2.0);}\nfloat dist(vec2 A, vec2 B) {return sqrt(sqr(B.x-A.x) + sqr(B.y-A.y));}\nfloat sin01(float a){return sin(a)*0.5+0.5;}\nfloat cos01(float a){return cos(a)*0.5+0.5;}\nfloat clamp01(float a){return clamp(a,0.,1.);}\n","name":"Common","description":"","type":"common"}]}