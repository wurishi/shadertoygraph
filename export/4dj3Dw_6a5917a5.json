{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\tThe main cool thing here is that the distance functions are transformed by a texture image.\n*/\n\n//==RAY MARCHING CONSTANTS=========================================================\n#define EPSILON .0001\n#define MAX_VIEW_STEPS 100\n#define MAX_SHADOW_STEPS 64\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR .5\n#define MAX_DEPTH 10.0\n#define BUMP_FACTOR .03\n#define TEX_SCALE_FACTOR .4\n\n//==OBJECT CONSTANTS========================================================\n#define BOX_POS vec3 (0.0, 0.0, 0.0)\n#define BOX_DIM vec3 (1.0, 1.0, 1.0)\n\n#define SPHERE_POS vec3(0.0, 0.0, 0.0)\n#define SPHERE_DIM 1.25\n\n#define LIGHT_COLOR vec4(1.0)\n#define PEN_FACTOR 50.0\n\n#define MAT_COLOR vec4(1.0)\n#define MAT_GLOSS 1.0\n\n//==RENDERING STRUCTURES===========================================================\n/*\n\tA structure for a simple light.\n*/\nstruct Light\n{\n\tvec3 position;\n\tvec4 color;\n\tfloat brightness;\n\tfloat penumbraFactor;\n};\n\n/*\n\tA structure for a less simple material.\n*/\nstruct Material\n{\n\tvec4 color;\n\tfloat gloss;\n};\n\t\n//==CAMERA FUNCTIONS================================================================\n/*\n\tBy TEKF: https://www.shadertoy.com/view/XdsGDB\n\tSet up a camera looking at the scene.\n\torigin - camera is positioned relative to, and looking at, this point\n\tdist - how far camera is from origin\n\trotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n\tzoom - the relative length of the lens\n*/\nvoid camPolar( out vec3 pos, out vec3 dir, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = cos(rotation);\n\tvec4 s;\n\ts.xy = sin(rotation);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tdir.xy = fragCoord.xy - iResolution.xy*.5;\n\tdir.z = iResolution.y*zoom;\n\tdir = normalize(dir);\n\t\n\t// rotate ray\n\tdir.yz = dir.yz*c.x + dir.zy*s.zx;\n\tdir.xz = dir.xz*c.y + dir.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\t\n\t\n//==TEXTURING FUNCTIONS=============================================================\n// by reinder. This is clever as two hamsters feeding three hamsters.\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n//==DISTANCE FUNCTIONS==============================================================\n/*\n\tReturns the distance to the surface of a sphere with the given position and radius.\n\tNote that this function returns a signed value, so if you are within the sphere the\n\tdistance will be negative.\n*/\nfloat distSphere( vec3 samplePos, vec3 spherePos, float radius)\n{\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(samplePos-spherePos) < radius+BUMP_FACTOR)\n\t{\t\n\t\tnormal = normalize(samplePos-spherePos);\n\t\tbump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;\n\t}\n\treturn length(samplePos-spherePos)-radius+bump;\n}\n\n/*\n\tReturns the distance to the surface of a box with the given position and dimensions.\n\tThis also returns a signed distance. If the returned value is negative, you are within\n\tthe box.\n*/\nfloat distBox(vec3 samplePos, vec3 boxPos, vec3 boxDim)\n{\t\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(samplePos-boxPos) < length(boxDim))\n\t{\n\t   \tnormal = normalize(samplePos-boxPos);\n \t\tbump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;\n\t}\n\tvec3 d = abs(samplePos-boxPos) - boxDim;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0))+bump;\n}\n\nfloat getDist(vec3 samplePos)\n{\n\treturn min(distBox(samplePos, BOX_POS, BOX_DIM), \n\t\t\t   distBox(samplePos, vec3(0.0, -5.0, 0.0), vec3(4.0, 4.0, 4.0)));\n}\n\n//==RAY MARCHING FUNCTIONS=========================================================\n/*\n\t\tMarches the 3D point <pos> along the given direction.\n\tWhen the point is either stepped the maximum number of times,\n\thas passed the maximum distance, or is within a set distance\n\tfrom geometry the function returns. \n\t\tNote that the position is passed by reference and is modified\n\tfor use within the function.\n*/\nvoid marchThroughField(inout vec3 pos, vec3 dir, vec3 eye)\n{\n\tfloat dist;\n\tfor(int i = 0; i < MAX_VIEW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON || length(pos-eye) > MAX_DEPTH-EPSILON)\t\t\t\n\t\t\treturn;\n\t\telse\t\n\t\t\tpos += dir*dist;\n\t}\n\treturn;\n}\n\n//==LIGHT CALCULATION FUNCTIONS=====================================================\n/*\n\tReturns the surface normal of a point in the distance function.\n*/\nvec3 getNormal(vec3 pos)\n{\n\tfloat d=getDist(pos);\n\treturn normalize(vec3( getDist(pos+vec3(EPSILON,0,0))-d, getDist(pos+vec3(0,EPSILON,0))-d, getDist(pos+vec3(0,0,EPSILON))-d ));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-getDist(normalPos);\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\n/*\n\tCalculates how much light remains if shadows are considered.\n\tUses IQ's soft shadows. Gosh, the guy created it all.\n*/\nfloat calcShadow( vec3 origin, vec3 lightDir, Light light)\n{\n\tfloat dist;\n\tfloat result = 1.0;\n\tfloat lightDist = length(light.position-origin);\n\t\n\tvec3 pos = vec3(origin)+(lightDir*(EPSILON*15.0+BUMP_FACTOR));\n\t\n\tfor(int i = 0; i < MAX_SHADOW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tif(length(pos-origin) > lightDist || length(pos-origin) > MAX_DEPTH)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tpos+=lightDir*dist;\n\t\tif( length(pos-origin) < lightDist )\n\t\t{\n\t\t\tresult = min( result, light.penumbraFactor*dist / length(pos-origin) );\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n\tReturns the product of the Phong lighting equation on a point in space given\n\ta light and the surface's material.\n*/\nvec4 calcLighting(vec3 samplePos, vec3 eye, Light light, Material material)\n{\n\tfloat lightDist = length(light.position-samplePos);\n\tvec3 lightDir = normalize(light.position-samplePos);\n\tvec3 eyeDir = normalize(samplePos-eye);\n\tvec3 surfaceNormal = getNormal(samplePos);\n\tvec3 reflection = normalize(reflect(eyeDir, surfaceNormal));\n\t\n\tfloat specular = pow(max( 0.0, dot(lightDir, reflection)), 72.0);\n\tfloat diffuse = max( 0.0, dot(lightDir, surfaceNormal));\n\tfloat ambient = .05;\n\t\n\tfloat attenuation = min(1.0, 1.0/(lightDist/light.brightness));\n\tfloat shadow = calcShadow(samplePos, lightDir, light);\n\tfloat occlusion = calcOcclusion(samplePos, surfaceNormal);\n\t\n\treturn light.color*material.color*clamp(((specular+diffuse)*shadow*attenuation)+(ambient*occlusion), 0.0, 1.0);\n}\n\nvec4 shade(vec3 pos, vec3 eye, Light light, Material material)\n{\n\tif(length(pos-eye) > MAX_DEPTH-EPSILON) return vec4(0.0);\n\telse return calcLighting(pos, eye, light, material);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pos, dir, eye;\n\tcamPolar(pos, dir, vec3(0.0), vec2(.5,iMouse.x*.0075+.025), 3.75, 1.0, fragCoord);\n\teye = vec3(pos);\n\tLight light = Light(vec3(3.0*sin(iTime+1.3), 3.5, 3.0*cos(iTime+1.3)), LIGHT_COLOR, 3.0, PEN_FACTOR);\n\tMaterial mat = Material(MAT_COLOR, MAT_GLOSS);\n\t\n\tmarchThroughField(pos, dir, eye);\n\t\n\tfragColor = shade(pos, eye, light, mat);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dj3Dw","date":"1389334400","viewed":4614,"name":"Raymarched Surface Displacement","username":"Hamneggs","description":"Protrudes surfaces along the (sort of) surface normal of geometric primitives with quite a bit of room for improvement. Uses a lot of IQ's techniques, TEKF's camera, and Reinder's super-great texture function. Rotate with the mouse!","likes":109,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","displacement","texture","bumpmapping","image","surface"],"hasliked":0,"parentid":"","parentname":""}}