{"ver":"0.1","info":{"id":"l3fSDB","date":"1709905744","viewed":40,"name":"2DArc","username":"ballman","description":"Just a simple arc","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\n// These could be uniforms (radians)\nfloat start_angle = 2.;\nfloat end_angle = 4.;\n// Example, for a full circle use:\n// float start_angle = 0.;\n// float end_angle = 2. * PI;\n\n// These could be uniforms (radius of the circle, from 0 to 1)\nfloat radius_internal = 0.3;\nfloat radius_external = 0.5;\n\nvec3 color = vec3(0.5, 0., 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // I normalize to y just to force a perfect circle within shadertoy\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Dot product computes the squared distance. Shoul save some\n    // computation with respect to the distance function\n    vec2 vec_dist = uv - 0.5;\n    float dist = dot(vec_dist, vec_dist);\n\n    // Step distance between the internal and external radius\n    // Multiplying steps => forcing both constraints\n    float circle_heat = (1. - step(radius_external * radius_external, dist)) * step(radius_internal * radius_internal, dist);\n    // Step angle between the start and end\n    float angle = atan(vec_dist.y, vec_dist.x) + PI;\n    float angle_heat = (1. - step(end_angle, angle)) * step(start_angle, angle);\n    // Combine them\n    float final_heat = angle_heat * circle_heat;\n    \n\n    // Heat decides the final color. 0 (black) or the desired color.\n    vec3 weighted_color = final_heat * color;\n\n    // Output to screen\n    fragColor = vec4(weighted_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}