{"ver":"0.1","info":{"id":"wtVXDd","date":"1583931349","viewed":93,"name":"Ancient Temple-v3","username":"jorge2017a1","description":"// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n//https://www.shadertoy.com/view/WtVSWt-----Logos","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ancienttemplev3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n//https://www.shadertoy.com/view/WtVSWt-----Logos\n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,.8,1); \n///--------------------------------\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\nfloat ot=0.;\nfloat det=0.;\nfloat hitfloor;\nfloat hitrock;\nfloat tt;\n\n///---------------------------------\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n\n\nfloat DE(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tot=1000.;\n    \n    \n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    \n    \n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    float fl=pos.y-3.013;\n    float d=min(fl,length(p)/DEfactor-.0005);\n\td=min(d,-pos.y+3.9);\n    d=min(d,rr);\n    if (abs(d-fl)<.0001) hitfloor=1.;\n    if (abs(d-rr)<.0001) hitrock=1.;\n    \n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.2 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .4;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    /*\n    float s1 = sin(time), c1 = cos(time);\n    float arg = 1.5*sin(time*.7894)*.5 + .5;\n    float s2 = sin(arg), c2 = cos(arg);\n    */\n    \n    ///----------------\n    vec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n    float y=(cos(iTime*.1+3.)+1.);\n    if (iMouse.z<1.) mouse=vec2(sin(t*2.),cos(t)+.3)*.15*(.5+y)*min(1.,iTime*.1);\n\tuv+=mouse*1.5;\n\tuv.y-=.1;\n    \n    \n    \n    vec3 from=vec3(0.0,3.04+y*.1,-2.+iTime*.05);\n\tvec3 dir=normalize(vec3(uv*.75,1.));\n    \n    vec3 ro =from;\n    \n    \n    \n    vec3 rd = dir;\n    \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col;\n    \n  \n     //--- output color depends on few things ---//\n    \n    \n    vec3   n = getNorm(p);\t\t\t// surface normal\n    float di = clamp(dot(n, normalize(ro)), -2.0, 1.0);\t\t// diffuse component\n    float re = pow(di, 100.0);\t\t\t\t\t\t\t\t// specular reflection\n    float od = length(p);\t\t\t\t\t\t\t// distance to origin\n    \n\tcol     = abs(rd.xyz);\n    col    *= 0.2 + 0.8*di;\n    col.yz *= clamp(od, 0.0, 1.0);\n    col    += re;\n    \n    \n    //col=col+pow(col,vec3(0.78902));\n     col=mix(vec3(length(col)),col,.85)*.95;\n    \n\tfragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}