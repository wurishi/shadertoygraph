{"ver":"0.1","info":{"id":"csGSDD","date":"1689384169","viewed":189,"name":"City 1","username":"Rugged","description":"WASD and Arrow Keys to move and turn. It's best on small res like 420x236 so its not super slow.\n\nAnyone know an efficient way to get rid of the jagged edges when ray tracing from the step size being large? (it also causes the circular moiree pattern)","likes":4,"published":1,"flags":48,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n\n    fragColor = texture(iChannel0, uv);;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define turnSpeed 2.\n#define moveSpeed 3.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    if(iFrame == 0){\n        if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n            col = vec4(-2., 0., 1., 0.);\n        }\n        else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n            col = vec4(3.14, 1.25, 0., 0.);\n        }\n    }\n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.xy / iResolution.xy;//iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    float phi = radians(360. * (1. - muv.x));\n    float theta = radians(180. * (1. - muv.y));\n    \n    \n    phi = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel0, ivec2(1, 0), 0).y;\n\n    \n    \n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta), 0.);\n    \n    \n    \n    if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n        vec4 camPerp = vec4(0.);\n        if(iFrame > 0){\n            vec3 tem = cross(normalize(vec3(camD.xy, 0.)), vec3(0., 0., 1.));\n            camPerp = vec4(tem, 0.);\n        }\n    \n        //if W is pressed go forwards\n        col += camD * texelFetch(iChannel1, ivec2(87, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if S is pressed go backwards\n        col -= camD * texelFetch(iChannel1, ivec2(83, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if A is pressed go forwards\n        col += camPerp * texelFetch(iChannel1, ivec2(65, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if D is pressed go backwards\n        col -= camPerp * texelFetch(iChannel1, ivec2(68, 0), 0).x * iTimeDelta * moveSpeed;\n        \n    }\n    else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n    \n        //if UP is pressed turn up\n        col.y -= texelFetch(iChannel1, ivec2(38, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if DOWN is pressed turn down\n        col.y += texelFetch(iChannel1, ivec2(40, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if LEFT is pressed turn up\n        col.x -= texelFetch(iChannel1, ivec2(37, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if RIGHT is pressed turn down\n        col.x += texelFetch(iChannel1, ivec2(39, 0), 0).x * iTimeDelta * turnSpeed;\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 scatV(vec3 v, float variance){\n    v;\n    vec3 change = vec3(hash3(v.xy + iTime), hash3(v.yx - iTime), hash3(v.yz));\n    change = ((2. * change) - 1.)  * variance;\n    return v * (1. + change);\n}\n\n\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b, vec3 c )\n{\n  vec3 q = abs(p - c) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat4 rayBuilding(vec3 p, vec3 bS, vec3 bC, mat4 nearbyLight1, vec3 rD, float a){\n    \n    mat4 ret;\n    ret[0] = vec4(0.);\n    ret[1] = vec4(rD, 0.);\n    ret[2] = vec4(0.);\n    ret[3] = vec4(a, 0., 0., 0.);\n    \n    \n    vec3 moonD = normalize(vec3(-.5, 1., -1.));\n\n    \n    float boxD = sdBox(p, bS, bC);\n    \n    if(boxD <= 0.){\n        \n            \n        vec3 dif = (p - bC) / bS;\n        vec3 adif = abs(dif);\n        dif = dif / max(adif.x, max(adif.y, adif.z));\n           \n        //https://www.desmos.com/calculator/bnxmvxceyt\n        vec3 n = dif * (1. + ((abs(dif) - .99)/abs(abs(dif) - .99))) / 2.;;\n            \n            \n            \n        ret[0] = texture(iChannel0, vec2(p.x + p.y, p.z)) * ((.4 *  dot(-moonD, n) + .1) * a);//vec4(-n, 1.);\n        \n        ret[1].xyz = rD + (2. * n * -sign(dot(n, vec3(1., 1., 1.))) * rD);\n        ret[1].xyz = scatV(ret[1].xyz, .1);\n        ret[3] = vec4(a * .01, 2., 0., 0.);\n            \n     }\n     \n     \n     \n     if(boxD < .1){\n         \n         ret[0] += nearbyLight1[2] * (1. / (pow(distance(p, nearbyLight1[0].xyz), 2.) + 1.5));\n\n     }\n     \n     return ret;\n}\n\n\n\n\nmat4 rayLight(vec3 p, vec3 lightSize, vec3 lightCenter, vec4 lightCol, float attenuation, vec3 rayD, float a){\n    \n    \n    \n    mat4 ret;\n    ret[0] = vec4(0.);\n    ret[1] = vec4(0.);\n    ret[2] = vec4(0.);\n    ret[3] = vec4(a, 0., 0., 0.);\n\n    if(sdBox(p, lightSize, lightCenter) <= 0.){\n        \n        \n        ret[0] = max(a, .2) * lightCol * (1. / pow(distance(p, lightCenter) + 1.1, attenuation));\n    }\n    \n    return ret;\n    \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = 2. * (uv - .5);\n    \n    \n    vec4 col = vec4(0.);\n\n    \n    \n    \n    \n    \n    \n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n        \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi = radians(360. * (muv.x - 1.));\n    float theta = radians(180. * (1. - muv.y));\n    \n    \n    \n    \n    \n    \n    \n    phi = texelFetch(iChannel1, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel1, ivec2(1, 0), 0).y;\n    \n    \n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    \n    \n    \n    \n    //rayD efficient\n    vec3 up = vec3(0., 0., 1.);\n    vec3 right = vec3(1., 0., 0.);\n    \n    vec3 U = normalize(cross(up, camD.yzw));\n    vec3 V = normalize(cross(camD.yzw, U));\n    \n    vec3 rayD = normalize(camD.yzw + uvc.x*U + uvc.y*V);\n    \n    //col = vec4(dot(rayD, right));\n    \n    vec3 lightD = normalize(vec3(0., 0., -1.));\n    \n    float lightS = .99;\n    \n    vec3 sphC = vec3(-6., -2., 7.);\n    \n    \n    vec3 p0 = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    p0.z = 1.;\n    vec3 p = p0;\n\n\n\n\n\n    vec3 moonD = normalize(vec3(-3., 1., -1.));\n    \n    \n    vec3 building1 = vec3(10., 10., 30.);\n    vec3 building1c = vec3(-30., 20., 15.);\n    \n    vec3 building2 = vec3(10., 10., 20.);\n    vec3 building2c = vec3(-60., 20., 10.);\n    \n    vec3 building3 = vec3(10., 10., 20.);\n    vec3 building3c = vec3(-25., -20., 10.);\n    \n    vec3 skyscraper1 = vec3(5., 5., 60.);\n    vec3 skyscraper1c = vec3(-90., -15., 30.);\n    \n    vec3 tramway1 = vec3(2., 40., 3.);\n    vec3 tramway1c = vec3(-75., 0., 12.);\n    \n    vec3 tram1 = vec3(2., 20., 4.);\n    vec3 tram1c = vec3(-75., 20., 15.8);\n    \n    \n    \n    \n    vec3 light1c = vec3(-20., -10., 5.);\n    vec3 light1s = vec3(1., .1, 1.);\n    vec4 light1col = vec4(.8, .2, .2, 1.);\n    \n    vec3 greenLc = vec3(-50., -2., 8.);\n    vec3 greenLs = vec3(1.5, 1.5, 1.5);\n    vec4 greenLcol = vec4(.2, .8, .2, 1.);\n    \n    vec3 redLc = vec3(-50., -2., 9.);\n    vec3 redLs = vec3(1.5, 1.5, 1.5);\n    vec4 redLcol = vec4(.8, .2, .2, 1.);\n    \n    vec3 crossWalkLight1c = vec3(-50., -10., 4.);\n    vec3 crossWalkLight1s = vec3(1.5, 1.5, 1.5);\n    vec4 crossWalkLight1col = vec4(.9, .5, .2, 1.);\n    \n    vec3 skyLight1c = vec3(-84., -15., 80.);\n    vec3 skyLight1s = vec3(.5, 5.5, 2.5);\n    vec4 skyLight1col = vec4(.7, .1, .7, 1.);\n    \n    vec3 darkWindow1c = vec3(-30., 10., 2.5);\n    vec3 darkWindow1s = vec3(8., .1, 5.);\n    vec4 darkWindow1col = vec4(-.2);\n    \n    vec3 tramLight1c = vec3(2.2, 10., 1.);\n    vec3 tramLight1s = vec3(.1, 9., 1.);\n    vec4 tramLight1col = vec4(.9, .9, .7, 1.);\n    \n    vec3 tramLight2c = vec3(2.2, -10., 1.);\n    vec3 tramLight2s = vec3(.1, 9., 1.);\n    vec4 tramLight2col = vec4(.9, .9, .7, 1.);\n    \n    vec3 restaurantL1c = vec3(-60., 10., 5.);\n    vec3 restaurantL1s = vec3(8., .1, 3.5);\n    vec4 restaurantL1col = vec4(.9, .9, .7, 1.);\n    \n    vec3 restaurantL2c = vec3(-50., 20., 5.);\n    vec3 restaurantL2s = vec3(.1, 8., 3.5);\n    vec4 restaurantL2col = vec4(.9, .9, .7, 1.);\n    \n    \n    \n    \n    \n    float a = 1.0;\n    for(int i = 0; i < 500; i++){\n        p += rayD * (float(i) * (.001 * (hash3(p.xy) + .5)));\n        \n        vec3 lp = p;\n        lp.x = mod(lp.x, -20.);\n        lp.y = -abs(lp.y);\n        \n        float d = distance(lp, sphC);\n        \n        \n        \n        \n        float inSpot = dot(normalize(lp - sphC), lightD) + (.02 * hash3(p.xy));\n        \n        if(inSpot > lightS){\n            col += .01 * a;\n            col *= 1. +  (.5 / pow(d, 2.));\n            \n            \n        }\n        else{\n            inSpot = 0.;\n            col += .0;\n        }\n        \n        \n        \n        mat4 lightHold1;\n        \n        \n        \n        \n        // ray trace the buildings\n        mat4 outMs;\n        \n        lightHold1[0] = vec4(light1c, 0.);\n        lightHold1[1] = vec4(light1s, 0.);\n        lightHold1[2] = light1col;\n        \n        \n        outMs = rayBuilding(p, building1, building1c, lightHold1, rayD, a);\n        col += outMs[0];\n        rayD = outMs[1].xyz;\n        p += rayD * (float(i) * .001);\n        a = outMs[3][0];\n        \n        outMs = rayBuilding(p, building2, building2c, lightHold1, rayD, a);\n        col += outMs[0];\n        rayD = outMs[1].xyz;\n        a = outMs[3][0];\n        \n        outMs = rayBuilding(p, building3, building3c, lightHold1, rayD, a);\n        col += outMs[0];\n        rayD = outMs[1].xyz;\n        a = outMs[3][0];\n        \n        lightHold1[0] = vec4(skyLight1c, 0.);\n        lightHold1[1] = vec4(skyLight1s, 0.);\n        lightHold1[2] = skyLight1col;\n        \n        outMs = rayBuilding(p, skyscraper1, skyscraper1c, lightHold1, rayD, a);\n        col += outMs[0];\n        rayD = outMs[1].xyz;\n        a = outMs[3][0];\n        \n        outMs = rayBuilding(p, tramway1, tramway1c, lightHold1, rayD, a);\n        col += (outMs[0] * 1.1);\n        rayD = outMs[1].xyz;\n        a = outMs[3][0];\n        \n        \n        tram1c.y = mix(-250., 250., mod(iTime, 10.) / 10.);\n        \n        outMs = rayBuilding(p, tram1, tram1c, lightHold1, rayD, a);\n        col += (outMs[0] * 1.1);\n        rayD = outMs[1].xyz;\n        a = outMs[3][0];\n        \n        \n        \n        \n        outMs = rayLight(p, light1s, light1c, light1col, .5, rayD, a);\n        col += outMs[0];\n        a = outMs[3][0];\n        \n        if(sin(iTime * .4) < 0.){\n            outMs = rayLight(p, greenLs, greenLc, greenLcol, 5., rayD, a);\n            col += outMs[0] * 4.;\n            a = outMs[3][0];\n        }\n        else{\n            outMs = rayLight(p, redLs, redLc, redLcol, 5., rayD, a);\n            col += outMs[0] * 4.;\n            a = outMs[3][0];\n        }\n        \n        \n        \n        outMs = rayLight(p, crossWalkLight1s, crossWalkLight1c, crossWalkLight1col, 5., rayD, a);\n        col += outMs[0] * 2.;\n        a = outMs[3][0];\n        \n        outMs = rayLight(p, skyLight1s, skyLight1c, skyLight1col, .5, rayD, a);\n        col += outMs[0] * 2.;\n        a = outMs[3][0];\n        \n        outMs = rayLight(p, darkWindow1s, darkWindow1c, darkWindow1col, .5, rayD, a);\n        col += outMs[0];\n        a = outMs[3][0];\n        \n        \n        outMs = rayLight(p, tramLight1s, tramLight1c + tram1c, tramLight1col, .5, rayD, a);\n        col += outMs[0] * 2.;\n        a = outMs[3][0];\n        \n        outMs = rayLight(p, tramLight2s, tramLight2c + tram1c, tramLight2col, .5, rayD, a);\n        col += outMs[0] * 2.;\n        a = outMs[3][0];\n        \n        \n        \n        outMs = rayLight(p, restaurantL1s, restaurantL1c, restaurantL1col, .5, rayD, a);\n        col += outMs[0];\n        a = outMs[3][0];\n        \n        outMs = rayLight(p, restaurantL2s, restaurantL2c, restaurantL2col, .5, rayD, a);\n        col += outMs[0];\n        a = outMs[3][0];\n        \n        \n        \n        if (p.z <= 0.){\n            vec4 floorC = 2. * texture(iChannel0, p.xy / 2.);\n            \n            floorC = (inSpot > lightS) ? (floorC / 2.) : floorC / 6.;\n            \n            col += .4 * floorC * a;\n            \n            rayD.z *= -1.;\n            \n            rayD = scatV(rayD, .1);\n            p += rayD * (float(i) * .001);\n            \n            a *= .5;\n            \n        }\n        else if(p.z > 40.){\n            col += (.1 / p.z) * max(a, 0.) * texture(iChannel3, (p.xy + iTime * 2.) / 100.).r * 5.;\n            \n        }\n        \n        \n        //rayD += .0001 * vec3(hash3(p.xy), hash3(p.yx), hash3(p.zx));\n\n        a -= .002;\n        \n        \n        \n    }\n    \n    \n    //this adds vignette\n    col *= 1.8 - length(uvc);\n    \n    \n    vec4 b = texture(iChannel2, uv);\n\n    fragColor = col;//mix(col, b, .99);\n}","name":"Buffer B","description":"","type":"buffer"}]}