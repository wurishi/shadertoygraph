{"ver":"0.1","info":{"id":"ltBfWt","date":"1517554560","viewed":173,"name":"weird terrain thing","username":"laserdog","description":"some mountains sprouting into existence","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .02\n#define PI 3.4\n\nvec3 eye;\n\nvec3 skyColor(vec3 pos) \n{\n    return mix(vec3(1., 1., 0.), vec3(1., 0., 0.), pos.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// iq value noise\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat f(vec2 pos) \n{\n\treturn noise(pos.yx * .1) * 50. * (pos.y - (eye.z + 3.))/ 30.;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec3(\n        f(vec2(p.x - EPSILON, p.z)) - f(vec2(p.x + EPSILON, p.z)),\n        2.0 * EPSILON,\n        f(vec2(p.x, p.z - EPSILON)) - f(vec2(p.x, p.z + EPSILON)));\n    return normalize(n);  \n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, 0.),\n        vec4(u, 0.),\n        vec4(-f, 0.),\n        vec4(0., 0., 0., 1.));\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 60.0;\n    const float dt = .5;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(vec2(p.x, p.z));\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\n\nvec3 getShading(vec3 p, vec3 normal, vec3 light)\n{\n\tvec3 diffuseColor = vec3(0.2, 0.7, 0.3);\n    return max(0., dot(normal, light)) * diffuseColor;\n}\n\nvec3 terrainColor(vec3 pos, vec3 eye) \n{   \n    return getShading(pos, getNormal(pos), vec3(0., 1., 0.)) *  (1.5 - (pos.z - eye.z) / 30.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\teye = vec3(0., 12., -2. + iTime * 5.);\n    vec3 viewRayDir = vec3(uv, -1.);\n    \n    vec3 dir = normalize(lookAt(eye, vec3(0., 11., iTime * 5.), vec3(0., 1., 0.)) * vec4(viewRayDir, 0.)).xyz;\n    float resT;\n    \n    if (castRay(eye, dir, resT)) \n    {\n        fragColor.rgb = terrainColor(eye + dir * resT, eye);\n    }\n    else \n    {\n        fragColor.rgb = skyColor(vec3(uv, 0.));\n    }\n}","name":"Image","description":"","type":"image"}]}