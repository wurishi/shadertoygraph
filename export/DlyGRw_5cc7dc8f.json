{"ver":"0.1","info":{"id":"DlyGRw","date":"1683690284","viewed":89,"name":"x-ray shadows","username":"testaccountplsignore","description":"first attempt at soft shadows","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    I don't know how soft shadows are usually done, I imagine there is faster algorithms with less artifacts,\n    but this is what I came up with.\n    It's just like regular ray marched shadows (march from surface to light source),\n    except that the amount of material between the point in question and the light source is determined\n    as opposed to just whether there is any material inbetween or not.\n*/\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//scene distance function\nfloat dist(vec3 p){\n    float sphere = length(p-vec3(1.7,3,3))-.8;\n    float frame = sdBoxFrame(p-vec3(-1.7,2.5,5),vec3(1.),.2);\n    \n    float sinplane = p.y;\n    if(p.x>0.)sinplane -= sin(2.*p.x)*.2 - sin(2.*p.z)*.2;\n    \n    float sd = min(sinplane,sphere);\n    sd = min(sd,frame);\n    return sd;\n}\n\n//standard ray marching function\nfloat raymarch(vec3 ro, vec3 rd){\n    float sd, td = 0.;\n    for(int i=0;i<256;i++){\n        td += sd;\n        sd = dist(ro+rd*td);\n        if(td>32. || abs(sd)<.001)break; \n    }\n    return td;\n}\n\n//also from iq\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = .001;\n    const vec2 e = vec2(h,-h);\n    return normalize( e.xyy*dist( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*dist( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*dist( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*dist( pos + e.xxx ) );\n}\n\n\n/*this is what the shader is about.\n  I guess it sort of counts as ray tracing as it calculates\n  the approximate length of the ray intersection with the scene.*/\nfloat softshadow(vec3 ro, vec3 l){\n\n    float sd,      //scene distance\n          st,      //step distance\n          td = 0., //traveled distance\n          od = 0., //obstructed distance\n          \n          d = distance(ro, l);   //distance between ray origin (point on object surface) to light source\n    vec3 rd = normalize(l - ro); //ray direction (normalized vector from ray origin to light source)\n    \n    for(int i=0; i<256; i++){ //max steps 256 (that is very high)\n    \n        sd = dist(ro + rd * td); //get scene distance from updated point\n        st = max(.001, abs(sd)); //always step forward a small amount\n                                 //or the distance to the nearest object boundary, whichever is greater\n                                \n        td += st;                //increase traveled distance by the step\n        if(td > d) break;        //if the ray has traveled past the light source, break out of the loop\n        \n        if(sd < 0.) od += st;    //if the current point is inside an object,\n                                 //increase the obstructed distance by the step size\n    }\n    return 1. - min(od, .9); //return dim value based on the level of obstruction\n                                   //I'm sure there's some fancy curves you could apply to this\n}\n\nvoid mainImage(out vec4 o, in vec2 u){\n    \n    vec2 uv = (u+u-iResolution.xy)/iResolution.y; //normalized pixel coordinates\n    \n    vec3 col = vec3(0),              //background colour\n         ro = vec3(0,2,0),           //ray origin (camera)\n         rd = normalize(vec3(uv,1)); //ray direction\n         \n    float td = raymarch(ro,rd); //ray march to get scene distance in ray direction\n    \n    if(td<32.){ //if ray travel distance under cutoff render scene, else keep background colour\n    \n        vec3 cp = ro+rd*td,     //calculate collision point again because somehow it's faster this way\n             l = vec3(0,10,-5); //point light source\n             \n        l.xz += 10.*vec2(sin(iTime*.5),cos(iTime*.5)); //move light source in a circle\n        \n        float diff = clamp(dot(calcNormal(cp),normalize(l-cp)),0.,1.); //calculate diffuse light level\n        \n        diff *= softshadow(cp, l); //dim light level gradually if path to light source is obstructed\n        \n        diff = min(diff+.1,1.);    //ambient light\n        \n        col = vec3(diff);  //set colour to light level (monochrome)\n    }\n    \n    o = vec4(col,1); //output colour\n}","name":"Image","description":"","type":"image"}]}