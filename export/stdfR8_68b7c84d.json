{"ver":"0.1","info":{"id":"stdfR8","date":"1662660516","viewed":180,"name":"Progressive Pathtracer Spheres","username":"MiguelSeabra","description":"Try moving the mouse to get different angles.\n\nFeatures:\nIndirect Illumination\nSoft shadows\nReflections and refraction\nFuzzy reflections and refraction\nMotion Blur (Moving objects)\nDepth of Field(DOF)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raytracer","ray","pathtracing","tracer","path","progressive","pathreacer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n* ver hash functions em\n* https://www.shadertoy.com/view/XlGcRh hash functions GPU\n* http://www.jcgt.org/published/0009/03/02/\n */\n\n //#include \"./common.glsl\"\n\n\n\nconst float pi = 3.14159265358979;\nconst float epsilon = 0.001;\n\nstruct Ray {\n    vec3 o;     // origin\n    vec3 d;     // direction - always set with normalized vector\n    float t;    // time, for motion blur\n};\n\nRay createRay(vec3 o, vec3 d, float t)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    r.t = t;\n    return r;\n}\n\nRay createRay(vec3 o, vec3 d)\n{\n    return createRay(o, d, 0.0);\n}\n\nvec3 pointOnRay(Ray r, float t)\n{\n    return r.o + r.d * t;\n}\n\nfloat gSeed = 0.0;\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed)\n{\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat rand(vec2 v)\n{\n    return fract(sin(dot(v.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 toLinear(vec3 c)\n{\n    return pow(c, vec3(2.2));\n}\n\nvec3 toGamma(vec3 c)\n{\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec2 randomInUnitDisk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.0, 6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 randomInUnitSphere(inout float seed)\n{\n    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1.0, 0.0, 0.0);\n    float phi = h.y;\n    float r = pow(h.z, 1.0/3.0);\n\treturn r * vec3(sqrt(1.0 - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n\nstruct Camera\n{\n    vec3 eye;\n    vec3 u, v, n;\n    float width, height;\n    float lensRadius;\n    float planeDist, focusDist;\n    float time0, time1;\n};\n\nCamera createCamera(\n    vec3 eye,\n    vec3 at,\n    vec3 worldUp,\n    float fovy,\n    float aspect,\n    float aperture,  //diametro em multiplos do pixel size\n    float focusDist,  //focal ratio\n    float time0,\n    float time1)\n{\n    Camera cam;\n    if(aperture == 0.0) cam.focusDist = 1.0; //pinhole camera then focus in on vis plane\n    else cam.focusDist = focusDist;\n    vec3 w = eye - at;\n    cam.planeDist = length(w);\n    cam.height = 2.0 * cam.planeDist * tan(fovy * pi / 180.0 * 0.5);\n    cam.width = aspect * cam.height;\n\n    cam.lensRadius = aperture * 0.5 * cam.width / iResolution.x;  //aperture ratio * pixel size; (1 pixel=lente raio 0.5)\n    cam.eye = eye;\n    cam.n = normalize(w);\n    cam.u = normalize(cross(worldUp, cam.n));\n    cam.v = cross(cam.n, cam.u);\n    cam.time0 = time0;\n    cam.time1 = time1;\n    return cam;\n}\n\nRay getRay(Camera cam, vec2 pixel_sample)  //rnd pixel_sample viewport coordinates\n{\n    vec2 ls = cam.lensRadius * randomInUnitDisk(gSeed);  //ls - lens sample for DOF\n    float time = cam.time0 + hash1(gSeed) * (cam.time1 - cam.time0);\n    \n    //Calculate eye_offset and ray direction\n    vec3 eye_offset = cam.eye + cam.u * ls.x + cam.v * ls.y;\n\n\tfloat worldCoordinatesX =  cam.width * (pixel_sample.x / iResolution.xy.x - 0.5f) * cam.focusDist;\n\tfloat worldCoordinatesY = cam.height * (pixel_sample.y / iResolution.xy.y - 0.5f) * cam.focusDist;\n\n\n\tvec3 direction = cam.u *(worldCoordinatesX - ls.x)+ cam.v * (worldCoordinatesY - ls.y)- cam.n * cam.planeDist * cam.focusDist;\n\n    return createRay(eye_offset, normalize(direction), time);\n}\n\n// MT_ material type\n#define MT_DIFFUSE 0\n#define MT_METAL 1\n#define MT_DIALECTRIC 2\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float roughness; // controls roughness for metals\n    float refIdx; // index of refraction for dialectric\n};\n\nMaterial createDiffuseMaterial(vec3 albedo)\n{\n    Material m;\n    m.type = MT_DIFFUSE;\n    m.albedo = albedo;\n    return m;\n}\n\nMaterial createMetalMaterial(vec3 albedo, float roughness)\n{\n    Material m;\n    m.type = MT_METAL;\n    m.albedo = albedo;\n    m.roughness = roughness;\n    return m;\n}\n\nMaterial createDialectricMaterial(vec3 albedo, float refIdx)\n{\n    Material m;\n    m.type = MT_DIALECTRIC;\n    m.albedo = albedo;\n    m.refIdx = refIdx;\n    m.roughness = 0.0;\n    return m;\n}\nMaterial createDialectricMaterialWithRoughness(vec3 albedo, float refIdx, float roughness)\n{\n    Material m;\n    m.type = MT_DIALECTRIC;\n    m.albedo = albedo;\n    m.refIdx = refIdx;\n    m.roughness = roughness;\n    return m;\n}\n\nstruct HitRecord\n{\n    vec3 pos;\n    vec3 normal;\n    float t;            // ray parameter\n    Material material;\n};\n\n\nfloat schlick(float cosine, float refIdx, bool fromInside)\n{\n    float fromIor, toIor;\n    if(!fromInside)\n    {\n        fromIor = 1.0;\n        toIor = refIdx;\n\n    }else\n    {\n        fromIor = refIdx;\n        toIor = 1.0;\n\n    }\n    float R0 = ((fromIor - toIor) / (fromIor + toIor));\n    R0 = R0*R0;\n    return R0 + (1.0 - R0) * pow((1.0 - cosine), 5.0);\n}\n\nbool scatter(Ray rIn, HitRecord rec, out vec3 atten, out Ray rScattered)\n{\n    float bleedIntensity = 0.8;\n    if( rec.material.type == MT_DIFFUSE)\n    {\n        //INSERT CODE HERE,\n\n        rScattered.o = rec.pos + rec.normal * 0.001;\n        rScattered.d = (normalize(rec.normal)+ randomInUnitSphere(gSeed)*bleedIntensity);\n        rScattered.d = normalize(rScattered.d);\n        atten = rec.material.albedo * max(dot(rScattered.d, rec.normal), 0.0) / pi;\n        return true;\n    }\n    if(rec.material.type == MT_METAL)\n    {\n        //INSERT CODE HERE, consider fuzzy reflections\n        rScattered.o = rec.pos + rec.normal * 0.0001;\n        rScattered.d = reflect(rIn.d, rec.normal);\n\n        rScattered.d += randomInUnitSphere(gSeed) * rec.material.roughness;\n\n\n        atten = rec.material.albedo;\n        return true;\n    }\n    if(rec.material.type == MT_DIALECTRIC)\n    {\n        //atten = vec3(1.0);\n        atten = rec.material.albedo;\n        vec3 outwardNormal;\n        float niOverNt;\n        float cosine;\n  \n\n        if(dot(rIn.d, rec.normal) > 0.0) //hit inside\n        {\n            outwardNormal = -rec.normal;\n            niOverNt = rec.material.refIdx;\n            cosine = rec.material.refIdx * dot(rIn.d, rec.normal); \n        \n        }\n        else  //hit from outside\n        {\n            outwardNormal = rec.normal;\n            niOverNt = 1.0 / rec.material.refIdx;\n            cosine = -dot(rIn.d, rec.normal); \n        }\n\n        //Use probabilistic math to decide if scatter a reflected ray or a refracted ray\n        float reflectProb;\n\n        //if no total reflection  reflectProb = schlick(cosine, rec.material.refIdx);  \n        //else reflectProb = 1.0;\n        if(1.0-cosine*cosine >= 1.0) //reflected ray´\n            reflectProb = 1.0;\n        else \n            reflectProb = schlick(cosine, niOverNt, dot(rIn.d, rec.normal) > 0.0);\n\n\n        if(hash1(gSeed) < reflectProb) { //Reflection\n            //calculate reflected ray\n      /**/      rScattered.o = rec.pos + outwardNormal * 0.0001;\n            rScattered.d = reflect(rIn.d, outwardNormal);\n            //atten *= vec3(reflectProb); //not necessary since we are only scattering reflectProb rays and not all reflected rays\n    \n        /**/\n        }else {  //Refraction\n            \n            // rScattered = calculate refracted ray\n            rScattered.o = rec.pos - outwardNormal * 0.0001;\n            rScattered.d = refract(rIn.d, outwardNormal, niOverNt);\n           // atten *= vec3(1.0 - reflectProb); //not necessary since we are only scattering 1-reflectProb rays and not all refracted rays\n        }\n        rScattered.d +=  randomInUnitSphere(gSeed) * rec.material.roughness;\n        return true;\n    }\n    return false;\n}\n\nstruct pointLight {\n    vec3 pos;\n    vec3 color;\n};\n\npointLight createPointLight(vec3 pos, vec3 color) \n{\n    pointLight l;\n    l.pos = pos;\n    l.color = color;\n    return l;\n}\n\nstruct Triangle {vec3 a; vec3 b; vec3 c; };\n\nTriangle createTriangle(vec3 v0, vec3 v1, vec3 v2)\n{\n    Triangle t;\n    t.a = v0; t.b = v1; t.c = v2;\n    return t;\n}\n\nbool hit_triangle(Triangle t, Ray r, float tmin, float tmax, out HitRecord rec)\n{\n    //INSERT YOUR CODE HERE\n    //calculate a valid t and normal\n    vec3 ab = t.b - t.a;\n    vec3 ac = t.c - t.a;\n    vec3 projVec = cross(r.d, ac);\n    float det = dot(ab, projVec);\n\n    if (det < epsilon) return false;\n    if (abs(det) < epsilon) return false;\n\n\n    float invDet = 1.0 / det;\n\n    vec3 tvec = r.o - t.a;\n    float u = dot(tvec, projVec) * invDet;\n    if (u < 0.0 ||  u > 1.0) return false;\n\n    vec3 qvec = cross(tvec, ab);\n    float v = dot(r.d, qvec) * invDet;\n    if (v < 0.0 || u + v > 1.0) return false;\n\n    float t_dist = dot(ac, qvec) * invDet;\n\n    /* Calculate the normal */\n    vec3 normal = cross((t.c - t.b), ac);\n    normal = normal * -1.0;\n    normal = normalize(normal);\n\n    if(t_dist < tmax && t_dist > tmin)\n    {\n        rec.t = t_dist;\n        rec.normal = normal;\n        rec.pos = pointOnRay(r, rec.t);\n        return true;\n    }\n    return false;\n}\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nSphere createSphere(vec3 center, float radius)\n{\n    Sphere s;\n    s.center = center;\n    s.radius = radius;\n    return s;\n}\n\n\nstruct MovingSphere\n{\n    vec3 center0, center1;\n    float radius;\n    float time0, time1;\n};\n\nMovingSphere createMovingSphere(vec3 center0, vec3 center1, float radius, float time0, float time1)\n{\n    MovingSphere s;\n    s.center0 = center0;\n    s.center1 = center1;\n    s.radius = radius;\n    s.time0 = time0;\n    s.time1 = time1;\n    return s;\n}\n\nvec3 center(MovingSphere mvsphere, float time)\n{\n    \n    return mvsphere.center0 + ((time - mvsphere.time0)/(mvsphere.time1 - mvsphere.time0) * (mvsphere.center1 - mvsphere.center0) );\n}\n\n\n/*\n * The function naming convention changes with these functions to show that they implement a sort of interface for\n * the book's notion of \"hittable\". E.g. hit_<type>.\n */\n\nbool hit_sphere(Sphere s, Ray r, float tmin,  float tmax, out HitRecord rec)\n{\n    //calculate a valid t and normal\n    float t;\n    vec3 oc = r.o - s.center;\n    float a = dot(r.d,r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc , oc) - dot(s.radius , s.radius);\n    float discriminant = dot(b , b) - dot(a , c);\n\n    if(discriminant <=0.0)\n        return false;\n    \n    discriminant = sqrt(discriminant)/a;\n    b = -b  / a;\n\n    float intersection0 = b - discriminant;\n    if(intersection0 >= 0.0)\n    {\n        t = intersection0;\n \n    }\n    else if( b + discriminant >= 0.0)\n    {\n        t =  b + discriminant;\n      \n    }\n    else\n        return false;\n\n    if(t < tmax && t > tmin && t < rec.t) \n    {\n        rec.t = t;\n        rec.pos = pointOnRay(r, rec.t);\n        vec3 normal;\n        if(s.radius >= 0.0)\n\t        normal = rec.pos - s.center;\n        else\n            normal = s.center-rec.pos;\n        \n\t    normal = normalize(normal);\n\n        rec.normal = normal;\n    \n        return true;\n    }\n    else \n        return false;\n}\n\nbool hit_movingSphere(MovingSphere s, Ray r, float tmin, float tmax, out HitRecord rec)\n{\n    float B, C, delta;\n    bool outside;\n    float t;\n\n\n\n    vec3 center = center(s, r.t);\n\n    vec3 oc = r.o - center;\n    float a = dot(r.d,r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc , oc) - dot(s.radius , s.radius);\n    float discriminant = dot(b , b) - dot(a , c);\n\n    if(discriminant <=0.0)\n        return false;\n    \n    discriminant = sqrt(discriminant)/a;\n    b = -b  / a;\n\n    float intersection0 = b - discriminant;\n    if(intersection0 >= 0.0)\n    {\n        t = intersection0;\n \n    }\n    else if( b + discriminant >= 0.0)\n    {\n        t =  b + discriminant;\n      \n    }\n    else\n        return false;\n\n    if(t < tmax && t > tmin) \n    {\n        rec.t = t;\n        rec.pos = pointOnRay(r, rec.t);\n\n\t    vec3 normal = rec.pos - center;\n\t    normal = normalize(normal);\n\n        rec.normal = normal;\n        return true;\n    }\n    else \n        return false;\n    \n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nbool hit_world(Ray r, float tmin, float tmax, out HitRecord rec)\n{\n    bool hit = false;\n    rec.t = tmax;\n   \n    if(hit_triangle(createTriangle(vec3(-10.0, -0.01, 10.0), vec3(10.0, -0.01, 10.0), vec3(-10.0, -0.01, -10.0)), r, tmin, rec.t, rec))\n    {\n        hit = true;\n        rec.material = createDiffuseMaterial(vec3(0.2));\n    }\n\n    if(hit_triangle(createTriangle(vec3(-10.0, -0.01, -10.0), vec3(10.0, -0.01, 10), vec3(10.0, -0.01, -10.0)), r, tmin, rec.t, rec))\n    {\n        hit = true;\n        rec.material = createDiffuseMaterial(vec3(0.2));\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(-4.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createDiffuseMaterial(vec3(0.2, 0.95, 0.1));\n        //rec.material = createDiffuseMaterial(vec3(0.4, 0.2, 0.1));\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(4.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.0);\n    }\n    if(hit_sphere(\n        createSphere(vec3(2.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createMetalMaterial(vec3(0.7804, 0.5137, 0.2667), 0.5);\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(0.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createDialectricMaterial(vec3(1.0), 1.5);\n    }\n\n\n\n   if(hit_sphere(\n        createSphere(vec3(0.0, 1.0, 0.0), -0.95),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n         //rec.material = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.0);\n        rec.material = createDialectricMaterial(vec3(1.0), 1.5);\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(-2.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n         //rec.material = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.0);\n        rec.material = createDialectricMaterialWithRoughness(vec3(0.7451, 0.7451, 0.9725), 1.5,0.03);\n    }\n\n        if(hit_sphere(\n        createSphere(vec3(-2.0, 1.0, 0.0), -0.95),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n         //rec.material = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.0);\n        rec.material = createDialectricMaterialWithRoughness(vec3(0.7451, 0.7451, 0.9725), 1.5,0.03);\n    }\n   \n    int numxy = 5;\n  \n    for(int x = -numxy; x < numxy; ++x)\n    {\n        for(int y = -numxy; y < numxy; ++y)\n        {\n            float fx = float(x);\n            float fy = float(y);\n            float seed = fx + fy / 1000.0;\n            vec3 rand1 = hash3(seed);\n            vec3 center = vec3(fx + 0.9 * rand1.x, 0.2, fy + 0.9 * rand1.y);\n            float chooseMaterial = rand1.z;\n            if(distance(center, vec3(4.0, 0.2, 0.0)) > 0.9)\n            {\n                if(chooseMaterial < 0.3)\n                {\n                    vec3 center1 = center + vec3(0.0, hash1(gSeed) * 0.5, 0.0);\n                    // diffuse\n                    if(hit_movingSphere(\n                        createMovingSphere(center, center1, 0.2, 0.0, 1.0),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                       \n                        rec.material = createDiffuseMaterial(hash3(seed) * hash3(seed));\n                    }\n                }\n                else if(chooseMaterial < 0.5)\n                {\n                    // diffuse\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material = createDiffuseMaterial(hash3(seed) * hash3(seed));\n                    }\n                }\n                else if(chooseMaterial < 0.7)\n                {\n                    // metal\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                       // rec.material.type = MT_METAL;\n                        rec.material = createMetalMaterial((hash3(seed) + 1.0) * 0.5, 0.0);\n                    }\n                }\n                else if(chooseMaterial < 0.9)\n                {\n                    // metal\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                       // rec.material.type = MT_METAL;\n                        rec.material = createMetalMaterial((hash3(seed) + 1.0) * 0.5, hash1(seed));\n                    }\n                }\n                else\n                {\n                    // glass (dialectric)\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material.type = MT_DIALECTRIC;\n                        rec.material = createDialectricMaterial(hash3(seed), 1.5);\n                    }\n                }\n            }\n        }\n    }\n    return hit;\n}\n\nvec3 directlighting(pointLight pl, Ray r, HitRecord rec){\n    bool hasShadows = true;\n    bool softShadows = true;\n    float shadowSoftness = 0.1;\n    vec3 diffCol, specCol, h, L;\n    vec3 colorOut = vec3(0.0, 0.0, 0.0);\n    float shininess = 60.0;\n    HitRecord dummy;\n    vec3 lightPos = rec.pos  + rec.normal * 0.0001;\n    \n    vec2 light_sample = randomInUnitDisk(gSeed) * shadowSoftness;\n\n    if(softShadows)\n        lightPos = lightPos + vec3(light_sample.x, 0.0,light_sample.y);\n\n\n    vec3 ligthDir = pl.pos - rec.pos;\n\n    if(hasShadows&& !hit_world(createRay(lightPos , ligthDir), 0.00001, 10000.0, dummy))\n    {\n        L = pl.pos - rec.pos;\n        L = normalize(L);\n        h =  L + -1.0*r.d;\n        h =  normalize(h);\n\n        vec3 diffCol;\n        vec3 specCol;\n        if( rec.material.type == MT_DIFFUSE) {\n            shininess = 100.0;\n            diffCol = pl.color *  rec.material.albedo * max(dot(L ,rec.normal), 0.0);\n            specCol = pl.color * vec3(0.7) * pow(max(dot(h ,rec.normal),0.0), shininess);\n        }\n        if(rec.material.type == MT_METAL) {\n            shininess = 800.0;\n            diffCol = vec3(0.0);\n            specCol = pl.color * vec3(1.2) * pow(max(dot(h ,rec.normal),0.0), shininess);\n        }\n        if(rec.material.type == MT_DIALECTRIC) {\n            shininess = 500.0;\n            diffCol = vec3(0.0);\n            specCol = pl.color * vec3(0.7882, 0.7843, 0.7843) * pow(max(dot(h ,rec.normal),0.0), shininess);\n        }\n\n        return diffCol + specCol;//+ specCol;\n\n    }\n  \n    \n\treturn colorOut; \n}\n\n#define MAX_BOUNCES 10\n\nvec3 rayColor(Ray r)\n{\n    HitRecord rec;\n    vec3 col = vec3(0.0);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    for(int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        if(hit_world(r, 0.00001, 10000.0, rec))\n        {\n            //calculate direct lighting with 3 white point lights:\n            {\n              \n       /**/\n                col += directlighting(createPointLight(vec3(-10.0, 15.0, 0.0), vec3(0.1137, 0.0941, 0.0941)), r, rec) * throughput;\n                col += directlighting(createPointLight(vec3(8.0, 15.0, 3.0), vec3(0.1137, 0.0941, 0.0941)), r, rec) * throughput;\n                col += directlighting(createPointLight(vec3(1.0, 15.0, -9.0), vec3(0.1137, 0.0941, 0.0941)), r, rec) * throughput;\n\n/**/\n\n            }\n           \n            //calculate secondary ray and update throughput\n            Ray scatterRay;\n            vec3 atten = vec3(1.0);\n            if(scatter(r, rec, atten, scatterRay))\n            {   \n               // col += atten;\n                \n                throughput *= atten;\n                r = scatterRay;\n            }else\n                break;\n        \n        }\n        else  //background\n        {\n            float t = 0.8 * (r.d.y + 1.0);\n            col += throughput * mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);\n            break;\n        }\n    }\n    \n    return LinearToSRGB(col);\n    return col;\n}\n\n#define MAX_SAMPLES 10000.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float distToFocus = 8.0;\n    float aperture = 0.2;\n    vec3 camTarget = vec3(0.0, 0.0, -1.0);\n    float time0 = 0.0;\n    float time1 = 1.0;\n    float fovy = 60.0;\n    float mouseSensitivity = 10.0;\n    float camDistance = 0.7;\n    bool panning = false;\n    gSeed = float(baseHash(floatBitsToUint(fragCoord.xy))) / float(0xffffffffU) + iTime;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x = mouse.x * 2.0 - 1.0;\n\n    vec3 camPos;\n    \n    if(!panning)\n        camPos = vec3(mouse.x * mouseSensitivity, mouse.y * mouseSensitivity*0.5, 8.0) * camDistance;\n    else\n    {\n     //   distToFocus = mouse.x * 4.0 + 4.0;\n     //   fovy = mouse.y * 60.0 * mouse.y;\n        camPos = vec3( max(cos(iTime*.1),0.5)*5.0*cos(iTime*.2),3.0 + cos(iTime*.5), max(0.5,cos(iTime*.1))*8.0*sin(iTime*.2));\n    }\n\n    Camera cam = createCamera(\n        camPos,\n        camTarget,\n        vec3(0.0, 1.0, 0.0),    // world up vector\n        fovy,\n        iResolution.x / iResolution.y,\n        aperture,\n        distToFocus,\n        time0,\n        time1);\n\n//usa-se o 4 canal de cor para guardar o numero de samples e não o iFrame pois quando se mexe o rato faz-se reset\n\n    vec4 prev = texture(iChannel0, uv);\n    vec3 prevLinear = toLinear(prev.xyz);  \n\n    vec2 ps = fragCoord.xy + hash2(gSeed);\n    //vec2 ps = gl_FragCoord.xy;\n    vec3 color = rayColor(getRay(cam, ps));\n\n    vec4 m = iMouse / iResolution.x;\n    if((m.z > 0.0) || panning)\n    {\n        fragColor = vec4(toGamma(color), 1.0);  //samples number reset = 1\n        return;\n    }\n    if(prev.w > MAX_SAMPLES)   \n    {\n        fragColor = prev;\n        return;\n    }\n\n    float w = prev.w + 1.0;\n    color = mix(prevLinear, color, 1.0/w);\n\n    \n    fragColor = vec4(toGamma(color), w);\n}","name":"Buffer A","description":"","type":"buffer"}]}