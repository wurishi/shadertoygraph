{"ver":"0.1","info":{"id":"4tdSz7","date":"1478794665","viewed":185,"name":"box frames","username":"teh_bear","description":"Frames within frames","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define MAX_STEPS 64\n#define PI 3.14159\n \n \nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n \nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n \nvec2 opU( vec2 d1, vec2 d2 )\n{\n   return (d1.x<d2.x) ? d1 : d2;\n}\n\nmat3 makeRotateX(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(1.0, c, -s,\n              0.0,  s, c,\n              0.0, 0.0, 1.0);\n}\nmat3 makeRotateY(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c,    0.0, s,\n              0.0,  1.0, 0.0,\n              -s,   0.0, c);\n}\nmat3 makeRotateZ(float a)\n{\n  float  c = cos(a); float  s = sin(a);\n  return mat3(c, -s, 0.0,\n              s,  c, 0.0,\n              0.0, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------\n\n\nfloat boxFrame(vec3 p, vec3 pos, float rot, float size)\n{\n    p -= pos;\n    p = makeRotateY(rot*1.5*PI+.5*iTime)*p;\n    p = makeRotateZ(rot*1.5*PI+.5*iTime)*p;\n    \n    \n    vec3 cut = vec3(2.0*size, .85*size, .85*size);\n    float big = udBox( p, vec3(size) );\n    float d1 =  sdBox( p, cut.xyz );\n    float d2 =  sdBox( p, cut.yxz );\n    float d3 =  sdBox( p, cut.yzx );\n    return opS(d3, opS(d2, opS(d1, big) ));\n}\n \nvec2 scene(vec3 p)\n{\n    vec2 res=vec2(1000.0, 0.0);\n    float d1 = udBox( vec3(p.x + 0.1, p.y + 1.8, p.z), vec3(8.0, 0.5, 8.0) );\n    res = opU(res, vec2(d1, 31.5) ); \n    for(int objs=0; objs<6; objs++) {\n        float zt1 = float(objs)/6.0;\n        float d2 = boxFrame(p, vec3(0.0, 0.0, 0.0), 0.3*zt1, 0.8-1.0*zt1 );\n        res = opU(res, vec2(d2, 10.+zt1*10.5) );\n    }\n    return res;\n}\n \nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    for(int k=0; k<128; k++)\n    {\n        float h = scene(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\nvec3 getNormal(vec3 p)\n{\n  vec3 eps=vec3(EPSILON,0,0);\n  return normalize(vec3(scene(p+eps.xyy).x,scene(p+eps.yxy).x,scene(p+eps.yyx).x));\n}\n \n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n   float precis = EPSILON;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n       if( abs(h)<precis||t>maxd ) break;\n       t += h;        \n       vec2 res = scene( ro+rd*t );\n       h = res.x;\n       m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n   float totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 col = vec3(0.0);\n  vec2 res = castRay(ro,rd,10.0);\n  float t = res.x;\n  float m = res.y;\n    \n  if( t>0.0 && t<10.0 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = getNormal( pos );\n\n    //col = vec3(0.6) + 0.4*sin( vec3(1.8,1.8,1.80)*(m-1.0) );\n      col = hsv2rgb_smooth( vec3(m, 0.5, 0.9) );\n\n    //float ao = calcAO( pos, nor );\n    float ao = 1.0;\n      \n\n    vec3 lig = normalize( vec3(0.5, 1.0, 0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,-0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n    float sh = 1.0;\n\t//#ifdef SHADOWS\n    if( dif>0.02 ) { sh = shadow( pos, lig, 0.02, 10.0); dif *= sh; }\n    //#endif\n    vec3 brdf = vec3(0.0);\n    brdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n    brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n    float pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n    float spe = sh*pow(pp,16.0);\n    float fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    col = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\n    col *= exp( -0.01*t*t );\n    return vec3( clamp(col,0.0,1.0) );\n  } else {\n    return texture(iChannel0, vec3(rd.x, -rd.y, rd.z) ).xyz;//hsv2rgb_smooth( vec3(360.0*(rd.x-rd.z), 0.5, 0.9) );\n  }\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0+2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n \n  // camera\n  float camFactorX = mix(0.0, mo.x, clamp(iMouse.z, 0.0, 1.0));\n  float camFactorY = mix(0.0, mo.y, clamp(iMouse.z, 0.0, 1.0));\n  float zoom = 8.2 * 0.6 - 6.2 * camFactorY + 2.5*clamp(iMouse.z, 0.0, 1.0);\n  float ang = PI*0.75 + 2.0*PI*camFactorX;\n  vec3 ro = vec3( zoom*cos(ang), 1.+camFactorY, zoom*sin(ang) );\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );\n \n  // camera tx\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n \n  vec3 col = render( ro, rd );\n  col = sqrt( col );\n  fragColor=vec4( col, 1.0 ); \n}\n","name":"Image","description":"","type":"image"}]}