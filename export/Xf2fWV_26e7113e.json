{"ver":"0.1","info":{"id":"Xf2fWV","date":"1725529392","viewed":57,"name":"GPU/VIP 6.4.19_release_20240905","username":"titolini72","description":"GPU/VIP 6.4.19_release_20240905","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["text","structures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Source \n// https://www.shadertoy.com/view/lsySzd\n// https://www.shadertoy.com/view/MdKXzc\n// https://www.shadertoy.com/view/ld2SzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 cA = texture(iChannel0, uv).xyz;\n    vec3 cB = texture(iChannel1, uv).xyz;\n\n    fragColor = vec4(cA,.1) + vec4(cB,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 25. \n#define font_spacing .04\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Gu(p) t(C_,A_,p) + t(A_,M_,p) + t(M_,O_,p) + t(O_,I_,p) + t(I_,H_,p) + t(H_,K_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define Iu(p) t(A_,C_,p) + t(M_,O_,p) + t(B_,N_,p)\n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Pu(p) t(M_,A_,p) + t(A_,C_,p) + t(C_,I_,p) + t(I_,G_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define Uu(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,C_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define Vu(p) t(A_,N_,p) + t(N_,C_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n#define one(p) t(D_,C_,p) + t(C_,O_,p)\n#define two(p) t(D_,A_, p) + t(A_,C_,p) + t(C_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) + t(O_,L_,p)\n#define three(p) t(A_,C_,p) + t(G_,I_,p) + t(M_,O_,p) + t(C_,O_,p)\n#define four(p) t(N_,B_,p) + t(B_,G_,p) + t(G_,I_,p)\n\n#define five(p) t(A_,C_,p) + t(A_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(M_,O_,p)\n#define six(p)  t(C_,A_,p) + t(A_,M_,p) + t(M_,O_,p) + t(O_,I_,p) + t(I_,G_,p)\n#define seven(p) t(D_,A_,p) + t(A_,C_,p) + t(C_,O_,p) + t(H_,I_,p)\n#define eight(p) t(A_,C_,p) + t(C_,O_,p) + t(O_,M_,p) + t(M_,A_,p) + t(G_,I_,p)\n#define nine(p)  t(M_,O_,p) + t(O_,C_,p) + t(A_,C_,p) + t(A_,G_,p) + t(G_,I_,p)\n#define zero(p) t(A_,C_,p) + t(C_,O_,p) + t(O_,M_,p) + t(M_,A_,p)\n#define under(p) t(M_,O_,p)\n#define slash(p) t(M_,C_,p)\n\n\t\nvec2 caret_origin = vec2(1.2, .75);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += .9;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 11.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\t//vec3 col = vec3(0.8, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.0);\n        vec3 col;\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n\t/*d += T(r()); add(); d += H(r()); add(); d += E(r()); space();\n\td += Q(r()); add(); d += U(r()); add(); d += I(r()); add(); d += C(r()); add(); d += K(r()); space();\n\td += B(r()); add(); d += R(r()); add(); d += O(r()); add(); d += W(r()); add(); d += N(r()); space();\n\tnewline();\n\td += F(r()); add(); d += O(r()); add(); d += X(r()); space();\n\td += J(r()); add(); d += U(r()); add(); d += M(r()); add(); d += P(r()); add(); d += S(r()); space();\n\td += O(r()); add(); d += V(r()); add(); d += E(r()); add(); d += R(r()); space();\n\tnewline();\n\td += T(r()); add(); d += H(r()); add(); d += E(r()); space();\n\td += L(r()); add(); d += A(r()); add(); d += Z(r()); add(); d += Y(r()); space();\n\td += D(r()); add(); d += O(r()); add(); d += G(r()); add(); d += STOP(r()); add(); d += STOP(r()); add(); d += STOP(r());\n    */\n    space();space();space();\n    d += Gu(r());    add(); space(); d += Pu(r()); add(); space(); d += Uu(r()); space(); add(); d+= slash(r()); add(); space();\n    d += Vu(r());    add(); space(); d += Iu(r()); add(); space(); d += Pu(r()); \n\n    newline();    newline();    newline(); space();\n    d += six(r());   add(); d += STOP(r());  add(); d += four(r());  add(); d += STOP(r());  add();\n    d += one(r());   add(); d += nine(r());  add(); d += under(r()); add(); d += R(r());     add();\n    d += E(r());     add(); d += L(r());     add(); d += E(r());     add(); d += A(r());     add();\n    d += S(r());     add(); d += E(r());     add(); d += under(r()); add(); d += two(r());   add();\n    d += zero(r());  add(); d += two(r());   add(); d += four(r()); add(); d += zero(r());  add();\n    d += nine(r()); add(); d += zero(r());   add(); d += five(r());   add();\n    \n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.1, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    fragColor = vec4( col, 0.0 );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Danil (2021+) https://cohost.org/arugl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// self https://www.shadertoy.com/view/NslGRN\n\n\n// --defines for \"DESKTOP WALLPAPERS\" that use this shader--\n// comment or uncomment every define to make it work (add or remove \"//\" before #define)\n\n\n// this shadertoy use ALPHA, NO_ALPHA set alpha to 1, BG_ALPHA set background as alpha\n// iChannel0 used as background if alpha ignored by wallpaper-app\n//#define NO_ALPHA\n//#define BG_ALPHA\n//#define SHADOW_ALPHA\n//#define ONLY_BOX\n\n\n// save PERFORMANCE by disabling shadow\n//#define NO_SHADOW\n\n\n// static CAMERA position, 0.49 on top, 0.001 horizontal\n#define CAMERA_POS 0.049\n\n\n// speed of ROTATION\n#define ROTATION_SPEED 0.8999\n\n\n// static SHAPE form, default 0.5\n#define STATIC_SHAPE 0.15\n\n\n// static SCALE far/close to camera, 2.0 is default, exampe 0.5 or 10.0\n#define CAMERA_FAR 2.0\n\n\n// ANIMATION shape change\n//#define ANIM_SHAPE\n\n\n// ANIMATION color change\n#define ANIM_COLOR\n\n\n// custom COLOR, and change those const values\n//#define USE_COLOR\nconst vec3 color_blue=vec3(0.5,0.65,0.8);\nconst vec3 color_red=vec3(0.99,0.2,0.1);\n\n\n// use 4xAA for cube only (set 2-4-etc level of AA)\n#define AA_CUBE 4\n\n// use 4xAA for everything - derivative filtering will not be used, look fcos2\n// this is very slow - DO NOT USE\n//#define AA_ALL 4\n\n\n\n// --shader code--\n\n// Layers sorted and support transparency and self-intersection-transparency\n// Antialiasing is only dFd. (with some dFd fixes around edges)\n\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n// using https://www.shadertoy.com/view/ltKBzG\n// using https://www.shadertoy.com/view/tsVXzh\n// using https://www.shadertoy.com/view/WlffDn\n// using https://www.shadertoy.com/view/WslGz4\n\n#define tshift 53.\n\n// reflect back side\n//#define backside_refl\n\n// Camera with mouse\n#define MOUSE_control\n\n// min(iFrame,0) does not speedup compilation in ANGLE\n#define ANGLE_loops 0\n\n\n// this shader discover Nvidia bug with arrays https://www.shadertoy.com/view/NslGR4\n// use DEBUG with BUG, BUG trigger that bug and one layer will be white on Nvidia in OpenGL\n//#define DEBUG\n//#define BUG\n\n#define FDIST 0.7\n#define PI 3.1415926\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(0.75, 0.75, 1.25)\n\n#define IOR 1.33\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nvec3 fcos1(vec3 x) {\n    vec3 w = fwidth(x);\n    //if((length(w)==0.))return vec3(0.); // dFd fix2\n    //w*=0.; //test\n    float lw=length(w);\n    if((lw==0.)||isnan(lw)||isinf(lw)){vec3 tc=vec3(0.); for(int i=0;i<8;i++)tc+=cos(x+x*float(i-4)*(0.01*400./iResolution.y));return tc/8.;}\n    \n    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);\n}\n\nvec3 fcos2( vec3 x){return cos(x);}\nvec3 fcos( vec3 x){\n#ifdef AA_ALL \n    return fcos2(x);\n#else\n    return fcos1(x);\n#endif\n}\n\nvec3 getColor(vec3 p)\n{\n    // dFd fix, dFd broken on borders, but it fix only top level dFd, self intersection has border\n    //if (length(p) > 0.99)return vec3(0.);\n    p = abs(p);\n\n    p *= 01.25;\n    p = 0.5 * p / dot(p, p);\n#ifdef ANIM_COLOR\n    p+=0.072*iTime;\n#endif\n\n    float t = (0.13) * length(p);\n    vec3 col = vec3(0.3, 0.4, 0.5);\n    col += 0.12 * fcos(6.28318 * t * 1.0 + vec3(0.0, 0.8, 1.1));\n    col += 0.11 * fcos(6.28318 * t * 3.1 + vec3(0.3, 0.4, 0.1));\n    col += 0.10 * fcos(6.28318 * t * 5.1 + vec3(0.1, 0.7, 1.1));\n    col += 0.10 * fcos(6.28318 * t * 17.1 + vec3(0.2, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 31.1 + vec3(0.1, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 65.1 + vec3(0.0, 0.5, 0.8));\n    col += 0.10 * fcos(6.28318 * t * 115.1 + vec3(0.1, 0.4, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 265.1 + vec3(1.1, 1.4, 2.7));\n    col = clamp(col, 0., 1.);\n \n    return col;\n}\n\nvoid calcColor(vec3 ro, vec3 rd, vec3 nor, float d, float len, int idx, bool si, float td, out vec4 colx,\n               out vec4 colsi)\n{\n\n    vec3 pos = (ro + rd * d);\n#ifdef DEBUG\n    float a = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n    if (idx == 0)colx = vec4(1., 0., 0., a);\n    if (idx == 1)colx = vec4(0., 1., 0., a);\n    if (idx == 2)colx = vec4(0., 0., 1., a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n        if (idx == 0)colsi = vec4(1., 0., 0., ta);\n        if (idx == 1)colsi = vec4(0., 1., 0., ta);\n        if (idx == 2)colsi = vec4(0., 0., 1., ta);\n    }\n#else\n    float a = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n    //a=1.;\n    vec3 col = getColor(pos);\n    colx = vec4(col, a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n        //ta=1.;\n        col = getColor(pos);\n        colsi = vec4(col, ta);\n    }\n#endif\n}\n\n// xSI is self intersect data, fade to fix dFd on edges\nbool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,\n                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)\n{\n    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);\n    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);\n    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);\n    vec3 vd = vec3(ps.xy, ph.x);\n    t = -1.;\n    tsi = -1.;\n    si = false;\n    fade = 1.;\n    fadesi = 1.;\n    norm=vec3(0.,1.,0.);normsi=vec3(0.,1.,0.);\n\n    float tmp = 1.0 / (vb.y * vc.x);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = va.z * tmp;\n    float e = 0.0;\n    float f = 0.0;\n    float g = (vc.z * vb.y - vd.y * va.z) * tmp;\n    float h = (vb.z * vc.x - va.z * vd.x) * tmp;\n    float i = -1.0;\n    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;\n\n    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);\n    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +\n              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);\n    float r =\n        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;\n\n    if (abs(p) < 0.000001)\n    {\n        float tt = -r / q;\n        if (tt <= 0.)\n            return false;\n        t = tt;\n        // normal\n\n        vec3 pos = ro + t * rd;\n        if(length(pos)>sz)return false;\n        vec3 grad =\n            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n        norm = -normalize(grad);\n        return true;\n    }\n    else\n    {\n        float sq = q * q - 4.0 * p * r;\n        if (sq < 0.0)\n        {\n            return false;\n        }\n        else\n        {\n            float s = sqrt(sq);\n            float t0 = (-q + s) / (2.0 * p);\n            float t1 = (-q - s) / (2.0 * p);\n            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);\n            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);\n            float tt0 = tt1;\n            if (tt0 <= 0.)\n                return false;\n            vec3 pos = ro + tt0 * rd;\n            // black border on end of circle and self intersection with alpha come because dFd\n            // uncomment this to see or rename fcos2 to fcos\n            //sz+=0.3; \n            bool ru = step(sz, length(pos)) > 0.5;\n            if (ru)\n            {\n                tt0 = tt2;\n                pos = ro + tt0 * rd;\n            }\n            if (tt0 <= 0.)\n                return false;\n            bool ru2 = step(sz, length(pos)) > 0.5;\n            if (ru2)\n                return false;\n\n            // self intersect\n            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))\n            {\n                si = true;\n                fadesi=s;\n                tsi = tt2;\n                vec3 tpos = ro + tsi * rd;\n                // normal\n                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +\n                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);\n                normsi = -normalize(tgrad);\n            }\n            \n            fade=s;\n            t = tt0;\n            // normal\n            vec3 grad =\n                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n            norm = -normalize(grad);\n\n            return true;\n        }\n    }\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz);\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4 + ANGLE_loops; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in vec3 rad, in float sk ) \n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n\tvec3 rdd = rd;\n\tvec3 roo = ro;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 dr = 1.0 / rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 bgcol(in vec3 rd)\n{\n    return mix(vec3(0.01), vec3(0.336, 0.458, .668), 1. - pow(abs(rd.z+0.25), 1.3));\n}\n\nvec3 background(in vec3 ro, in vec3 rd , vec3 l_dir, out float alpha)\n{\n#ifdef ONLY_BOX\nalpha=0.;\nreturn vec3(0.01);\n#endif\n    float t = (-BOXDIMS.z - ro.z) / rd.z;\n    alpha=0.;\n    vec3 bgc = bgcol(rd);\n    if (t < 0.)\n        return bgc;\n    vec2 uv = ro.xy + t * rd.xy;\n#ifdef NO_SHADOW\n    float shad=1.;\n#else\n    float shad = boxSoftShadow((ro + t * rd), normalize(l_dir+vec3(0.,0.,1.))*rotz(PI*0.65) , BOXDIMS, 1.5);\n#endif\n    float aofac = smoothstep(-0.95, .75, length(abs(uv) - min(abs(uv), vec2(0.45))));\n    aofac = min(aofac,smoothstep(-0.65, 1., shad));\n    float lght=max(dot(normalize(ro + t * rd+vec3(0.,-0.,-5.)), normalize(l_dir-vec3(0.,0.,1.))*rotz(PI*0.65)), 0.0);\n    vec3 col = mix(vec3(0.4), vec3(.71,.772,0.895), lght*lght* aofac+ 0.05) * aofac;\n    alpha=1.-smoothstep(7.,10.,length(uv));\n#ifdef SHADOW_ALPHA\n    //alpha=clamp(alpha*max(lght*lght*0.95,(1.-aofac)*1.25),0.,1.);\n    alpha=clamp(alpha*(1.-aofac)*1.25,0.,1.);\n#endif\n    return mix(col*length(col)*0.8,bgc,smoothstep(7.,10.,length(uv)));\n}\n\n#define swap(a,b) tv=a;a=b;b=tv\n\nvec4 insides(vec3 ro, vec3 rd, vec3 nor_c, vec3 l_dir, out float tout)\n{\n    tout = -1.;\n    vec3 trd=rd;\n\n    vec3 col = vec3(0.);\n\n    float pi = 3.1415926;\n\n    if (abs(nor_c.x) > 0.5)\n    {\n        rd = rd.xzy * nor_c.x;\n        ro = ro.xzy * nor_c.x;\n    }\n    else if (abs(nor_c.z) > 0.5)\n    {\n        l_dir *= roty(pi);\n        rd = rd.yxz * nor_c.z;\n        ro = ro.yxz * nor_c.z;\n    }\n    else if (abs(nor_c.y) > 0.5)\n    {\n        l_dir *= rotz(-pi * 0.5);\n        rd = rd * nor_c.y;\n        ro = ro * nor_c.y;\n    }\n\n#ifdef ANIM_SHAPE\n    float curvature = (0.001+1.5-1.5*smoothstep(0.,8.5,mod((iTime+tshift)*0.44,20.))*(1.-smoothstep(10.,18.5,mod((iTime+tshift)*0.44,20.))));\n    // curvature(to not const above) make compilation on Angle 15+ sec\n#else\n#ifdef STATIC_SHAPE\n    const float curvature = STATIC_SHAPE;\n#else\n    const float curvature = .5;\n#endif\n#endif\n    float bil_size = 1.;\n    vec4 ps = vec4(-bil_size, -bil_size, bil_size, bil_size) * curvature;\n    vec4 ph = vec4(-bil_size, bil_size, bil_size, -bil_size) * curvature;\n    \n    vec4 [3]colx=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    vec3 [3]dx=vec3[3](vec3(-1.),vec3(-1.),vec3(-1.));\n    vec4 [3]colxsi=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    int [3]order=int[3](0,1,2);\n\n    for (int i = 0; i < 3 + ANGLE_loops; i++)\n    {\n        if (abs(nor_c.x) > 0.5)\n        {\n            ro *= rotz(-pi * (1. / float(3)));\n            rd *= rotz(-pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.z) > 0.5)\n        {\n            ro *= rotz(pi * (1. / float(3)));\n            rd *= rotz(pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.y) > 0.5)\n        {\n            ro *= rotx(pi * (1. / float(3)));\n            rd *= rotx(pi * (1. / float(3)));\n        }\n        vec3 normnew;\n        float tnew;\n        bool si;\n        float tsi;\n        vec3 normsi;\n        float fade;\n        float fadesi;\n\n        if (iBilinearPatch(ro, rd, ps, ph, bil_size, tnew, normnew, si, tsi, normsi, fade, fadesi))\n        {\n            if (tnew > 0.)\n            {\n                vec4 tcol, tcolsi;\n                calcColor(ro, rd, normnew, tnew, bil_size, i, si, tsi, tcol, tcolsi);\n                if (tcol.a > 0.0)\n                {\n                    {\n                        vec3 tvalx = vec3(tnew, float(si), tsi);\n                        dx[i]=tvalx;\n                    }\n#ifdef DEBUG\n                    colx[i]=tcol;\n                    if (si)colxsi[i]=tcolsi;\n#else\n\n                    float dif = clamp(dot(normnew, l_dir), 0.0, 1.0);\n                    float amb = clamp(0.5 + 0.5 * dot(normnew, l_dir), 0.0, 1.0);\n\n                    {\n#ifdef USE_COLOR\n                        vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                        const vec3 tcr = color_red;\n#else\n                        vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                        const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                        float ta = clamp(length(tcol.rgb),0.,1.);\n                        tcol=clamp(tcol*tcol*2.,0.,1.);\n                        vec4 tvalx =\n                            vec4((tcol.rgb*shad*1.4 + 3.*(tcr*tcol.rgb)*clamp(1.-(amb+dif),0.,1.)), min(tcol.a,ta));\n                        tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                        tvalx*=(min(fade*5.,1.));\n                        colx[i]=tvalx;\n                    }\n                    if (si)\n                    {\n                        dif = clamp(dot(normsi, l_dir), 0.0, 1.0);\n                        amb = clamp(0.5 + 0.5 * dot(normsi, l_dir), 0.0, 1.0);\n                        {\n#ifdef USE_COLOR\n                            vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                            const vec3 tcr = color_red;\n#else\n                            vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                            const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                            float ta = clamp(length(tcolsi.rgb),0.,1.);\n                            tcolsi=clamp(tcolsi*tcolsi*2.,0.,1.);\n                            vec4 tvalx =\n                                vec4(tcolsi.rgb * shad + 3.*(tcr*tcolsi.rgb)*clamp(1.-(amb+dif),0.,1.), min(tcolsi.a,ta));\n                            tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                            tvalx.rgb*=(min(fadesi*5.,1.));\n                            colxsi[i]=tvalx;\n                        }\n                    }\n#endif\n                }\n            }\n        }\n    }\n    // transparency logic and layers sorting \n    float a = 1.;\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n    if (dx[1].x < dx[2].x){{vec3 swap(dx[1], dx[2]);}{int swap(order[1], order[2]);}}\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n\n    tout = max(max(dx[0].x, dx[1].x), dx[2].x);\n\n    if (dx[0].y < 0.5)\n    {\n        a=colx[order[0]].a;\n    }\n\n#if !(defined(DEBUG)&&defined(BUG))\n    \n    // self intersection\n    bool [3] rul= bool[3](\n        ((dx[0].y > 0.5) && (dx[1].x <= 0.)),\n        ((dx[1].y > 0.5) && (dx[0].x > dx[1].z)),\n        ((dx[2].y > 0.5) && (dx[1].x > dx[2].z))\n    );\n    for(int k=0;k<3;k++){\n        if(rul[k]){\n            vec4 tcolxsi = vec4(0.);\n            tcolxsi=colxsi[order[k]];\n            vec4 tcolx = vec4(0.);\n            tcolx=colx[order[k]];\n\n            vec4 tvalx = mix(tcolxsi, tcolx, tcolx.a);\n            colx[order[k]]=tvalx;\n\n            vec4 tvalx2 = mix(vec4(0.), tvalx, max(tcolx.a, tcolxsi.a));\n            colx[order[k]]=tvalx2;\n        }\n    }\n\n#endif\n\n    float a1 = (dx[1].y < 0.5) ? colx[order[1]].a : ((dx[1].z > dx[0].x) ? colx[order[1]].a : 1.);\n    float a2 = (dx[2].y < 0.5) ? colx[order[2]].a : ((dx[2].z > dx[1].x) ? colx[order[2]].a : 1.);\n    col = mix(mix(colx[order[0]].rgb, colx[order[1]].rgb, a1), colx[order[2]].rgb, a2);\n    a = max(max(a, a1), a2);\n    return vec4(col, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float osc = 0.5;\n    vec3 l_dir = normalize(vec3(0., 1., 0.));\n    l_dir *= rotz(0.5);\n    float mouseY = 1.0 * 0.5 * PI;\n#ifdef MOUSE_control\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n#endif\n#ifdef CAMERA_POS\n    mouseY = PI*CAMERA_POS;\n#else\n    mouseY = PI*0.49 - smoothstep(0.,8.5,mod((iTime+tshift)*0.33,25.))*(1.-smoothstep(14.,24.0,mod((iTime+tshift)*0.33,25.))) * 0.55 * PI;\n#endif\n#ifdef ROTATION_SPEED\n    float mouseX = -2.*PI-0.25*(iTime*ROTATION_SPEED+tshift);\n#else\n    float mouseX = -2.*PI-0.25*(iTime+tshift);\n#endif\n#ifdef MOUSE_control\n    mouseX+=-(iMouse.x / iResolution.x) * 2. * PI;\n#endif\n    \n#ifdef CAMERA_FAR\n    vec3 eye = (2. + CAMERA_FAR) * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#else\n    vec3 eye = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#endif\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec4 tot=vec4(0.);\n#if defined(AA_CUBE)||defined(AA_ALL)\n#ifdef AA_CUBE\n    const int AA = AA_CUBE;\n#else\n    const int AA = AA_ALL;\n#endif\n    vec3 incol_once=vec3(0.);\n    bool in_once=false;\n    vec4 incolbg_once=vec4(0.);\n    bool bg_in_once=false;\n    vec4 outcolbg_once=vec4(0.);\n    bool bg_out_once=false;\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(mod(float(mx+AA/2),float(AA)),mod(float(nx+AA/2),float(AA))) / float(AA) - 0.5;\n    vec2 uv = (fragCoord + o - 0.5 * iResolution.xy) / iResolution.x;\n#else\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n#endif\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n\n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z/BOXDIMS.xy + ro.yz * ni.x/BOXDIMS.yz + ro.zx * ni.y/BOXDIMS.zx;\n    float fadeborders = (1.-smoothstep(0.915,1.05,abs(coords.x)))*(1.-smoothstep(0.915,1.05,abs(coords.y)));\n\n    if (t > 0.)\n    {\n        float ang = -iTime * 0.33;\n        vec3 col = vec3(0.);\n#ifdef AA_CUBE\n        if(in_once)col=incol_once;\n        else{\n        in_once=true;\n#endif\n        float R0 = (IOR - 1.) / (IOR + 1.);\n        R0 *= R0;\n\n        vec2 theta = vec2(0.);\n        vec3 n = vec3(cos(theta.x) * sin(theta.y), sin(theta.x) * sin(theta.y), cos(theta.y));\n\n        vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n        vec3 rdr = reflect(rd, nr);\n        float talpha;\n        vec3 reflcol = background(ro, rdr, l_dir,talpha);\n\n        vec3 rd2 = refract(rd, nr, 1. / IOR);\n\n        float accum = 1.;\n        vec3 no2 = ni;\n        vec3 ro_refr = ro;\n\n        vec4 [2] colo = vec4[2](vec4(0.),vec4(0.));\n\n        for (int j = 0; j < 2 + ANGLE_loops; j++)\n        {\n            float tb;\n            vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n            vec3 eye2 = vec3(coords2, -1.);\n            vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n\n            rd2trans.z = -rd2trans.z;\n            vec4 internalcol = insides(eye2, rd2trans, no2, l_dir, tb);\n            if (tb > 0.)\n            {\n                internalcol.rgb *= accum;\n                colo[j]=internalcol;\n            }\n\n            if ((tb <= 0.) || (internalcol.a < 1.))\n            {\n                float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                vec3 rout = ro_refr + tout * rd2;\n                vec3 rdout = refract(rd2, -no2, IOR);\n                float fresnel2 = R0 + (1. - R0) * pow(1. - dot(rdout, no2), 1.3);\n                rd2 = reflect(rd2, -no2);\n\n#ifdef backside_refl\n                if((dot(rdout, no2))>0.5){fresnel2=1.;}\n#endif\n                ro_refr = rout;\n                ro_refr.z = max(ro_refr.z, -0.999);\n\n                accum *= fresnel2;\n            }\n        }\n        float fresnel = R0 + (1. - R0) * pow(1. - dot(-rd, nr), 5.);\n        col = mix(mix(colo[1].rgb * colo[1].a, colo[0].rgb, colo[0].a)*fadeborders, reflcol, pow(fresnel, 1.5));\n        col=clamp(col,0.,1.);\n#ifdef AA_CUBE\n        }\n        incol_once=col;\n        if(!bg_in_once){\n        bg_in_once=true;\n        float alpha;\n        incolbg_once = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        incolbg_once.w = alpha;\n#endif\n        }\n#endif\n        \n        float cineshader_alpha = 0.;\n        cineshader_alpha = clamp(0.15*dot(eye,ro),0.,1.);\n        vec4 tcolx = vec4(col, cineshader_alpha);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = 1.;\n#endif\n        tot += tcolx;\n    }\n    else\n    {\n        vec4 tcolx = vec4(0.);\n#ifdef AA_CUBE\n        if(!bg_out_once){\n        bg_out_once=true;\n#endif\n        float alpha;\n        tcolx = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = alpha;\n#endif\n#ifdef AA_CUBE\n        outcolbg_once=tcolx;\n        }else tcolx=max(outcolbg_once,incolbg_once);\n#endif\n        tot += tcolx;\n    }\n#if defined(AA_CUBE)||defined(AA_ALL)\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = tot;\n#ifdef NO_ALPHA\n    fragColor.w = 1.;\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n    fragColor.rgb=fragColor.rgb*fragColor.w+texture(iChannel0, fragCoord/iResolution.xy).rgb*(1.-fragColor.w);\n#endif\n    //fragColor=vec4(fragColor.w);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}