{"ver":"0.1","info":{"id":"MsGGWR","date":"1453932256","viewed":239,"name":"Fast Plasma Snakes","username":"sillsm","description":"Make FabriceNeyret2's \"Plasma Snakes 3\" fast by recording non-modified values to a texture.\n\nOriginal here: https://www.shadertoy.com/view/lt2SWy","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Max Sills 2016\n// Licensed under the MIT license.\n// Data storage in texel due to iq.\n// Based off Plasma Snakes 3 by FabriceNeyret2:https://www.shadertoy.com/view/lt2SWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 t = texture( iChannel0, fragCoord.xy / iChannelResolution[0].xy );\n    fragColor = vec4(t.x,t.y,t.z,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Max Sills 2016\n// Licensed under the MIT license.\n// All state is stored in a dead pixel at vec2(1.0,1.0).\n\n#define P(t)   vec2( 1.7*cos(t)+.5*sin(-2.7*t), .8*sin(1.2*t)+.5*cos(3.2*t) ) /1.5\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec4 color(float t,vec4 c,vec2 U){\n    return .2*smoothstep(.03*c, c-c, vec4(length(P((t))-U)));\n}\n\nvec4 snake(float t,vec4 c,vec2 U, float offset){\n    vec4 ret = color(5.+ t + offset, c, U); // add head\n    if (t - 5. > 0.)ret -= color(t + offset, c, U); // remove tail\n    return ret;\n}\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    vec2 uv = U.xy / iChannelResolution[0].xy;\n    o = texture( iChannel0, uv);\n  \n    // State Modification.\n    vec4 state = loadValue( vec2(1.0,1.0) );\n    float time = 0.;\n    if (iTime > .01) time = state.x;\n    \n    float reset = iTime; // no reset.\n\n    if (iTime > .05 && state.w > iTime ){\n        o = vec4(0,0.,0.,0.);\n        storeValue( vec2(1.0,1.0), vec4(0.,iResolution.x,iResolution.y,0), o, U );\n        return;\n    }\n    \n    // If the resolution changes, clear the buffer, restart the clock.\n    if (iTime > .01){ // reset logic.\n      if (iResolution.x != state.y) reset = iTime + 0.5;\n    }\n    \n    storeValue( vec2(1.0,1.0), vec4(time + 0.02,iResolution.x,iResolution.y,reset), o, U );\n    \n    if (isInside(U,vec2(1.0,1.0)) > 0.0 ) return; // Don't draw over state pixel.\n    if (time == 0.) return;\n    // End State Modification, begin drawing.\n\n\tvec2 R = iResolution.xy;  \n    U = (2.*U -R ) / R.y;\n\n    o +=  snake(time , vec4(1,2,3,0), U, 0.);\n    o +=  snake(time,vec4(3,2,1,0), U, -1234.);        \n    o +=  snake(time, vec4(2,3,1,0), U, 12345.); \n}","name":"Buf A","description":"","type":"buffer"}]}