{"ver":"0.1","info":{"id":"mdjXDD","date":"1670413784","viewed":647,"name":"Snowy Forest","username":"Poisson","description":"I'm very satisfied with the result because it took me only 2 hours to make and because it's the first time I make a landscape.","likes":27,"published":1,"flags":32,"usePreview":1,"tags":["procedural","3d","raymarching","ray","volume","sunset","sun","landscape","volumetric","fog","raymarcher","tree","forest","scattering","atmosphere","snow","glare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tonemap\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    \n    // base texture with subtle CA\n    vec2 off = (p-.5)*.003; // CA offset\n    vec3 col = vec3(texture(iChannel0, p+off).r,\n                    texture(iChannel0, p).g,\n                    texture(iChannel0, p-off).b);\n                    \n    col = pow(col, vec3(.4545)); // gamma correction\n    col = ACES(col);\n    col = col*.25+.75*col*col*(3.-2.*col); // contrast\n    col = pow(col, vec3(.83,1,.75)); // color grade\n    col = col*vec3(1.2,1.1,1)-vec3(.1,.05,0); // color contrast\n        \n    // vignette\n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n    \n    //col *= .96+.1*sin(p.y*1000.+iTime); // old CRT effect\n    \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// antialiasing, set it to 2 if you have a very fast machine\n#define AA 1\n// raymarching steps for volumetric fog\n#define NUM_VOLUME_STEPS 16\nconst vec3 lig = normalize(vec3(.8,.85,-.9)); // sun direction\n\n///////////////\n//           //\n// MODELLING //\n//           //\n///////////////\n\n// hash function\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// 3d noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// 3d fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    return f;\n}\n\n// hash vec2 to float\nfloat hash21(vec2 p) {\n    p = fract(p*vec2(452.127,932.618));\n    p += dot(p, p+123.23);\n    return fract(p.x*p.y);\n}\n\n// 2d noise function by me\nfloat noise(vec2 p) {\n    vec2 q = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.-2.*f);\n    return mix(mix(hash21(q+vec2(0,0)),hash21(q+vec2(1,0)),f.x),\n               mix(hash21(q+vec2(0,1)),hash21(q+vec2(1,1)),f.x),f.y);\n}\n\n// 2d fractal noise\nfloat fbm(vec2 p) {\n    float a = .2;\n    mat2 m = mat2(cos(a),-sin(a),sin(a),cos(a)); // rotation matrix\n    float f = 0.;\n    f += .5*noise(p); p *= m;\n    f += .25*noise(p*2.); p *= m;\n    f += .125*noise(p*4.); p *= m;\n    f += .0625*noise(p*8.); p *= m;\n    return f;\n}\n\n// squared length\nfloat dot2(vec2 v) {return dot(v,v);}\n\n// cone sdf\n// thanks to iq: https://iquilezles.org/articles/distfunctions/\nfloat sdCone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0., 1.);\n    float s = cb.x<0. && ca.y<0. ? -1. : 1.;\n    return s*sqrt(min(dot2(ca),dot2(cb)));\n}\n\n// height of the terrain\nfloat height(vec3 p) {\n    return fbm(p.xz+3.)-noise(.4*p.xz-.2)+.8;\n}\n\n// union of two sdf\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n#define MAT_TERRAIN 0.\n#define MAT_WOOD 1.\n#define MAT_LEAVE 2.\n\n// sdf to scene\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10);\n    \n    // terrain\n    d = opU(d, vec2(.9*(p.y+height(p)), MAT_TERRAIN));\n    \n    // trees\n    \n    // square size\n    float s = 4.2;\n    \n    vec3 q = p;\n    q.y += height(p); // tree at the ground height \n    q.xz = (fract(q.xz*s)-.5)/s; // repetition on x and z axis\n    \n    // add a bit of randomness\n    float h = 123.*floor(p.x*s)+15.*floor(p.z*s);\n    q.x += .2*sin(4.*h)/s;\n    q.z += .2*sin(8.*h+2.)/s;\n    \n    // trunc\n    vec2 trees = vec2(sdCone(q, .3, .03, .008), MAT_WOOD);\n    \n    // leaves\n    q.y += .26*sin(h)/s;\n    float leaves = 1e10;\n    for (float i=0.; i<1.; i+=1./5.) {\n        leaves = min(leaves, sdCone(q-vec3(0,.28*i+.3+.05,0), .03, .113*(1.-i), .0));\n    }\n    trees = opU(trees, vec2(leaves*.4, MAT_LEAVE));\n    \n    d = opU(d, trees);\n            \n    return d;\n}\n\n///////////////\n//           //\n// RENDERING //\n//           //\n///////////////\n\n// raymarching loop, returns the distance and material index\nvec2 intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    \n    for (int i=0; i<512 && t<64.; i++) {\n        vec3 p = ro + rd*t;\n        vec2 h = map(p);\n        if (abs(h.x)<.0001*t) return vec2(t,h.y);\n        t += h.x;\n    }\n    return vec2(t,-1);\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=.008; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p).x;\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res);\n}\n\n// sky\nvec3 background(vec3 rd) {\n    vec3 col = mix(vec3(1), vec3(.3,.5,1), .5+.5*rd.y); // blue sky\n    // add a bit of red\n    return .65*mix(col, vec3(1,.05,.02), .34*clamp(exp(-rd.y*rd.y*32.),0.,1.));\n}\n\n// atmospheric perspective\nvec3 atmosphere(vec3 col, float t, vec3 rd) {\n    vec3 atm = 1.-exp(-t*t*.0008*vec3(1,1.5,2.2));\n    return mix(col, background(rd), atm);\n}\n\n// density of the fog at point p\nfloat fogMap(vec3 p) {\n    return noise(2.*p+.3*iTime)*fbm(12.*p)*smoothstep(-.3,-.9,p.y)+4.*pow(fbm(15.*p+.4*iTime),12.);\n}\n\nvec3 volumetricFog(vec3 col, vec3 ro, vec3 rd, float tmax) {\n    // bounding volume\n    float b = ro.y/rd.y;\n    if (b>0.) return col;\n    \n    float s = min(tmax, 12.) / float(NUM_VOLUME_STEPS); // step size\n    float t = 0.;\n    float acc = 0.; // accumulation\n    for (int i=0; i<NUM_VOLUME_STEPS; i++) {\n        vec3 p = ro + rd*t;\n        float h = fogMap(p);\n        acc += s*h;\n        t += s;\n    }\n    acc = 1.-exp(-acc*.7); // density fallof\n    col = mix(col, vec3(1), acc);\n    return col;\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = background(rd);\n        \n    // cheap clouds\n    float b = 1./rd.y; // plane\n    if (b>0.) {\n        vec3 p = ro + rd*b;\n        float m = fbm(p.xz);\n        col = mix(col, vec3(1), smoothstep(.35,.7,m));\n        col = atmosphere(col, b, rd);\n    }    \n    \n    // material index and distance\n    vec2 tm = intersect(ro, rd);\n    float t = tm.x;\n    float m = tm.y;\n\n    if (t<64.) { // we hit the surface\n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // normal of the surface\n                \n        float dif = clamp(dot(n, lig), 0., 1.); // diffuse light\n        float bac = clamp(dot(n, -lig), 0., 1.); // back light\n        float sha = shadow(p, lig, 16., 32.); // soft shadow\n        // ambient occulsion\n        float occ = smoothstep(.2,.6,p.y+height(p))+.35;\n        occ *= .5+.5*map(p+n*.03).x/.03;\n        \n        // color of the object\n        vec3 mat;\n        if (m == MAT_TERRAIN) { // ground\n            mat = mix(vec3(.5,.3,.2), vec3(1), smoothstep(.85-.5*fbm(24.*p),.9,n.y));\n        } else if (m == MAT_WOOD) { // trunc of the trees\n            mat = vec3(.5,.3,.2);\n        } else { // leaves\n            // random colors\n            float h = 356.*floor(p.x*4.2)+27.*floor(p.z*4.2);\n            mat = mix(vec3(.2,.35,.05), vec3(.25,.4,.0), sin(5.*h));\n            mat = mix(mat, vec3(.05,.2,0), sin(15.*h+3.));\n            // add snow on the top of the trees\n            mat = mix(mat, vec3(1), smoothstep(.45,.65,p.y+height(p)+.1*sin(12.*h+2.)+.2*fbm(42.*p)));;\n        }\n        \n        col = vec3(0);\n        col += vec3(1,.8,.6)*dif*sha*mat; // sun light\n        col += vec3(1,.8,.6)*occ*.025*mat*bac; // bounce light\n        col += mat*.045*occ*vec3(.6,.8,1); // sky light\n                                \n        col = atmosphere(col, t, rd);\n    }\n    \n    // fog\n    col = volumetricFog(col, ro, rd, t);\n    \n    // sun glare\n    float glare = clamp(dot(rd, lig), 0., 1.);\n    col += 2.*vec3(1,.8,.6)*pow(glare, 7.);\n    col += 2.*vec3(1,.2,.1)*pow(glare, 10.);\n    \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    \n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n)/float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n    \n        vec3 ro = vec3(1.-.6*sin(.1*iTime),.35,2.5); // ray origin\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n        \n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n\n        vec3 col = render(ro, rd);\n        tot += col;\n    }\n    tot /= float(AA*AA);\n            \n    fragColor = vec4(tot,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}