{"ver":"0.1","info":{"id":"csSXRV","date":"1670511197","viewed":211,"name":"skull model","username":"VL","description":".","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n#define static\n#define MaxDist 100.f\n#define SurfaceDist 0.0001f\n#define FloatMax 3.402823466e+38f\n#define raymarchDepth 200\n#define raymarchDistMax 200.f\n#define InvPI 0.318309886f\n#define PId2 1.57079632f\n#define PI 3.141592653f\n#define PI2 6.2831853f\n#define UpVector float3(0.f, 1.f, 0.f)\n#define RightVector float3(1.f, 0.f, 0.f)\n#define LookVector float3(0.f, 0.f, 1.f)\n\nfloat2 hash(float2 p)\n{\n    float3 p3 = frac(float3(p.xyx) * float3(144.1031, 151.1030, 134.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return frac((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat3 hash(float3 p3)\n{\n    p3 = frac(p3 * float3(154.1031, 134.1030, 124.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return frac((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nfloat simplexNoise(float3 p)\n{\n    float k1 = 0.333333f;\n    float k2 = 0.166667f;\n    \n    int3 idx = floor(p + (p.x + p.y + p.z) * k1);\n    float3 a = p - (float3(idx) - float(idx.x + idx.y + idx.z) * k2);\n    \n    int3 tb1Arr[8] = vec3[8]\n    ( int3(0, 0, 1), int3(0, 1, 0), int3( 0), int3(0, 1, 0), int3(0, 0, 1), int3( 0), int3(1, 0, 0), int3(1, 0, 0) );\n    int3 tb2Arr[8] = vec3[8]\n    ( int3(0, 1, 1), int3(0, 1, 1), int3( 0), int3(1, 1, 0), int3(1, 0, 1), int3( 0), int3(1, 0, 1), int3(1, 1, 0) );\n    \n    uint tbIdx = (uint(a.x > a.y) << 2) | (uint(a.x > a.z) << 1) | uint(a.y > a.z);\n    \n    int3 tb1 = tb1Arr[tbIdx], tb2 = tb2Arr[tbIdx];\n    \n    float3 b = a - tb1 + k2;\n    float3 c = a - tb2 + k2 * 2.f;\n    float3 d = a - 1.f + k2 * 3.f;\n    \n    float4 kernel = max(0.5f - float4(dot(a, a), dot(b, b), dot(c, c), dot(d, d)), 0.f);\n    kernel *= kernel;\n    kernel *= kernel;\n    float4 noise = kernel * float4(dot(a, hash(idx)*2.-1.), \n                                   dot(b, hash(idx + tb1)*2.-1.), \n                                   dot(c, hash(idx + tb2)*2.-1.), \n                                   dot(d, hash(idx + 1.f)*2.-1.));\n    \n    return dot(vec4(60.f), noise);\n}\n\nfloat3x3 viewMatrix(float3 look)\n{\n    float3 right = normalize(cross(UpVector, look));\n    float3 up = cross(look, right);\n    return float3x3(right, up, look);\n}\n\nfloat max3(float a, float b, float c)\n{\n    return max(a, max(b, c));\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(a, min(b, c));\n}\n\nfloat smoothMin(float a, float b, float k, float n)\n{\n    return min(a, b) - pow(max(k - abs(a - b), 0.f) / k, n) * k / (2.f * n);\n}\n\nfloat smoothMax(float a, float b, float k, float n)\n{\n    return max(a, b) + pow(max(k - abs(a - b), 0.f) / k, n) * k / (2.f * n);\n}\n\nfloat sdf3dSphere(float3 _point, float4 sphere)\n{\n    return length(_point - sphere.xyz) - sphere.w;\n}\n\nfloat sdf3dInfPlane(float3 _point, float3 plane, float3 planeNormal)\n{\n    return dot((_point - plane), planeNormal);\n}\n\nfloat sdf3dCapsule(float3 _point, float3 A, float3 B, float radius)\n{\n    float3 ab = B - A;\n    float3 ap = _point - A;\n    float t = saturate(dot(ap, ab) / dot(ab, ab));\n    \n    return length(ap - t * ab) - radius;\n}\n\nfloat sdf3dBox(float3 _point, float3 box, float3 boxSize)\n{\n    _point = abs(_point - box) - boxSize;\n    return length(max(_point, 0.f)) + min(max3(_point.x, _point.y, _point.z), 0.f);\n}\n\nfloat sdf3dCylinder(float3 _point, float3 A, float3 B, float radius)\n{\n    float3 ab = B.xyz - A.xyz;\n    float3 pa = _point - A.xyz;\n    \n    float Len_ab = length(ab);\n    float invLen_ab = 1.f / Len_ab;\n    float t = dot(ab, pa) * invLen_ab;\n    float3 proj_ap = A.xyz + t * invLen_ab * ab;\n    \n    float d = length(_point - proj_ap) - radius;\n    float y = (abs(t * invLen_ab - 0.5f) - 0.5f) * Len_ab;\n    \n    float e = length(max(float2(d, y), 0.f));\n    float i = min(max(d, y), 0.f);\n    \n    return e + i;\n}\n\nfloat2x2 rot2D(float t)\n{\n    float s, c;\n    sincos(-t, s, c);\n    return float2x2(c, s, -s, c);\n}\n\n\nfloat GetSignDistance(float3 p)\n{\n    p.xz = mul(p.xz, rot2D((-iMouse.x/iResolution.x+0.5)*PI2));       \n    p.y += 4.f;\n    p.y *= 0.9f;\n    float3 ap = p;\n    ap.x = abs(p.x);\n    float d = sdf3dSphere(p, float4(0.f, 5.f, -7.2f, 5.f));\n    d = smoothMin(d, sdf3dSphere(p, float4(0.f, 6.f, -9.5f, 2.f)), 3.f, 2.f);\n    d = smoothMin(d, sdf3dSphere(p, float4(0.f, 8.f, -5.f, 3.f)), 3.f, 2.f);\n    d = smoothMin(d, sdf3dBox(p, float3(0.f, 4.5f, -7.2f), float3(2.1f,2.1f,2.1f)) - 1.f, 2.f, 2.f);\n    d = smoothMax(d, -sdf3dSphere(ap, float4(1.f,4.2f,-11.5f,0.7f)), 0.5f, 2.f);\n    d = smoothMax(d, -sdf3dSphere(ap, float4(1.8f,4.f,-11.5f,0.7f)), 0.5f, 2.f);\n    d = smoothMax(d, -sdf3dSphere(ap, float4(1.1f,3.5f,-12.5f,0.9f)), 0.5f, 2.f);    \n    d = smoothMax(d, -sdf3dInfPlane(ap, float3(3.f, 0.f, 0.f), float3(-1.f, 0.f, 0.f)), 0.5f, 2.f);\n    d = smoothMax(d, -sdf3dCapsule(ap, float3(2.f, 0.f, -7.f), float3(2.f, 0.f, 7.f), 5.f), 0.5f, 2.f);    \n    d = smoothMax(d, -sdf3dSphere(ap, float4(1.8f, 2.3f, -11.5f, 0.5f)), 0.5f, 2.f);\n    d = smoothMin(d, sdf3dSphere(ap, float4(2.f, 6.f, -7.2f, 2.5f)), 3.f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(p, float3(0.f, 5.f, -12.f), float3(0.f, 4.f, -12.2f), 0.1f), 0.5f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(ap, float3(0.f, 4.f, -12.4f), float3(0.7f, 3.5f, -12.f), 0.15f), 0.5f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(ap, float3(0.7f, 3.5f, -12.f), float3(0.75f, 2.5f, -12.f), 0.12f), 0.5f, 2.f);    \n    d = smoothMin(d, sdf3dCapsule(ap, float3(0.f, 4.f, -12.f), float3(1.f, 3.5f, -11.5f), 0.15f), 0.5f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(ap, float3(1.f, 3.5f, -11.5f), float3(2.f, 3.5f, -11.5f), 0.15f), 0.5f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(ap, float3(2.f, 3.5f, -11.5f), float3(2.5f, 3.8f, -11.f), 0.15f), 0.3f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(ap, float3(1.2f, 5.2f, -12.2f), float3(2.2f, 5.1f, -11.8f), 0.15f), 0.8f, 2.f);\n    d = smoothMin(d, sdf3dCapsule(ap, float3(0.2f, 4.7f, -12.5f), float3(1.2f, 5.f, -12.3f), 0.15f), 0.8f, 2.f);\n    \n    d = smoothMax(d, -sdf3dSphere(ap, float4(2.8f, 4.2f, -10.f, 0.2f)), 1.2f, 2.f);\n    d = smoothMax(d, -sdf3dSphere(ap, float4(2.8f, 4.8f, -10.7f, 0.15f)), 1.2f, 2.f); \n    d = smoothMin(d, sdf3dSphere(p, float4(0.f, 5.f, -5.f, 4.f)), 1.2f, 2.f);\n    \n    float3 teeth = p - float3(0.f, 2.5f, -11.f);\n    float len = length(teeth.xz);\n    float theta = atan2(teeth.z, teeth.x)-0.5;\n    float n = 18.;\n    float idx = floor(theta / (PI2 / n));    \n    float2 rand = hash(vec2(idx));\n    theta = fmod(theta, PI2 / n);\n    float st, ct;\n    sincos(theta, st, ct);\n    teeth.xz = float2(ct, st) * len;\n    float tt = sdf3dCapsule(teeth, float3(1.f, 0.f, 0.2f), float3(1.25f, -0.4f - rand.x * 0.2, 0.2f), 0.2f);\n    tt = smoothMin(tt, sdf3dCylinder(teeth, float3(1.1f, -0.5f, 0.2f), float3(1.25f, -0.9f, 0.2f), 0.1f) - rand.y * 0.1, 0.01f, 2.f);\n    tt = smoothMin(tt, sdf3dCylinder(p, float3(0.f, 2.5f, -11.2f), float3(0.f, 2.f, -11.2f), 1.f), 0.8f, 2.f);\n    tt = smoothMax(tt, -sdf3dCylinder(p, float3(0.f,6.f, -8.6f), float3(0.f, -6.f, -8.6f), 3.f), 0.1f, 2.f);\n    d = smoothMin(tt, d, 0.3f, 2.f);\n    \n    ap.z -= 0.3f;\n    ap.y -= 1.f;\n    ap.x *= 1.1;\n    \n    ap.yz = mul(ap.yz, rot2D(sin(iTime*5.)*0.1+0.1));\n    \n    float3 jaw = ap - float3(0.f, -1.2f, -12.f);\n    jaw.yz = mul(jaw.yz, rot2D(-0.5f));\n    tt = sdf3dBox(jaw, vec3(0.f), float3(0.2f, 0.5f, 0.1f)) - 0.1f;\n    \n    ap.x += 0.5f;\n    jaw = ap - float3(2.4f, -0.5f, -10.f);\n    jaw.xz = mul(jaw.xz, rot2D(0.5f));\n    jaw.yz = mul(jaw.yz, rot2D(0.3f));\n    tt = smoothMin(tt, sdf3dBox(jaw, vec3(0.f), float3(0.1f, 0.64f, 1.6f)) - 0.1f, 1.f, 2.f);\n    \n    jaw = ap - float3(1.5f, -0.9f, -11.f);\n    jaw.xz = mul(jaw.xz, rot2D(0.8f));\n    jaw.yz = mul(jaw.yz, rot2D(0.3f));\n    tt = smoothMin(tt, sdf3dBox(jaw, vec3(0.f), float3(0.1f, 0.64f, 1.6f)) - 0.1f, 1.f, 2.f);    \n    \n    jaw = ap - float3(3.2f, 0.f, -9.4f);\n    jaw.xz = mul(jaw.xz, rot2D(0.6f));\n    tt = smoothMin(tt, sdf3dBox(jaw, vec3(0.f), float3(0.1f, 1.2f, 0.5f)) - 0.1f, 1.f, 2.f);\n    \n    tt = smoothMin(tt, sdf3dCapsule(ap, float3(0.9f, -1.8f, -12.f), float3(2.8f, -1.5f, -9.8f), 0.3), 0.5f, 2.f);\n    tt = smoothMin(tt, sdf3dCapsule(ap, float3(3.4f, 0.f, -8.5f), float3(3.6f, 1.6f, -8.2f), 0.15), 1.f, 2.f);\n    tt = smoothMin(tt, sdf3dCapsule(ap, float3(2.5f, 0.f, -10.2f), float3(2.9f, 1.9f, -10.2f), 0.1), 1.f, 2.f);\n    \n    teeth = ap - float3(0.5f, -0.6f, -11.f);\n    teeth.y = -teeth.y;\n    len = length(teeth.xz);\n    theta = atan2(teeth.z, teeth.x)-0.14;\n    idx = floor(theta / (PI2 / n));\n    rand = hash(vec2(idx));\n    theta = fmod(theta, PI2 / n);\n    sincos(theta, st, ct);\n    teeth.xz = float2(ct, st) * len;\n    tt = smoothMin(tt, sdf3dCapsule(teeth, float3(0.9f, 0.f, 0.2f), float3(1.15f, -0.6f - rand.x * 0.2, 0.2f), 0.2f), 0.5f, 2.f);\n    tt = smoothMin(tt, sdf3dCylinder(teeth, float3(1.1f, -0.5f, 0.2f), float3(1.15f, -1.f, 0.2f), 0.1f) - rand.y * 0.1, 0.01f, 2.f);\n    tt = smoothMax(tt, -sdf3dCylinder(ap, float3(0.f, 6.f, -10.65f), float3(0.f, -6.f, -10.65f), 1.65f), 0.01f, 2.f);\n    d = min(tt, d);\n    \n    return d - simplexNoise(p*0.45)*0.1f;\n}\n\nfloat RayMarching(float3 rayOrigin, float3 rayDir)\n{\n    float dist = 0.f;\n    for (int i = 0; i < raymarchDepth; ++i)\n    {\n        float3 p = rayOrigin + rayDir * dist;\n        float curr = GetSignDistance(p);\n        \n        dist += curr;\n        if (curr < SurfaceDist || dist > raymarchDistMax)\n        {\n            dist = curr < SurfaceDist ? dist : FloatMax;\n            break;\n        }\n    }\n    \n    return dist;\n}\n\nfloat3 GetSDFNormal(float3 p)\n{\n    return normalize(float3(+1.f, -1.f, -1.f) * GetSignDistance(p + float3(+1.f, -1.f, -1.f) * SurfaceDist) +\n                     float3(-1.f, -1.f, +1.f) * GetSignDistance(p + float3(-1.f, -1.f, +1.f) * SurfaceDist) +\n                     float3(-1.f, +1.f, -1.f) * GetSignDistance(p + float3(-1.f, +1.f, -1.f) * SurfaceDist) +\n                     float3(+1.f, +1.f, +1.f) * GetSignDistance(p + float3(+1.f, +1.f, +1.f) * SurfaceDist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n\n    float3 ro = float3(0., 0., -20.);\n    float3 rt = float3(0.,0., 0.);\n    float3 rd = mul(transpose(viewMatrix(normalize(rt - ro))), normalize(float3(uv, 1.)));\n    \n    float t = RayMarching(ro, rd);    \n    \n    float3 col = float3(0.f);\n    \n    if(t < FloatMax)\n    {\n        float3 p = ro + t * rd;\n        float3 n = GetSDFNormal(p);\n\n        col = float3((dot(n,normalize(float3(0.f,1.f,-1.f)))));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}