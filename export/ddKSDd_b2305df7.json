{"ver":"0.1","info":{"id":"ddKSDd","date":"1681822385","viewed":301,"name":"Boldo's Aurora Borealis","username":"boldo","description":"Aurora borealis like effect...\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["plasma","landscape","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple hash function\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// 2D noise function\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i.x + hash(i.y)), hash(i.x + 1.0 + hash(i.y)), u.x),\n               mix(hash(i.x + hash(i.y + 1.0)), hash(i.x + 1.0 + hash(i.y + 1.0)), u.x), u.y);\n}\n\n// Mountain range function\nfloat mountainRange(vec2 uv) {\n    float mountainHeight = 0.0;\n    float frequency = 2.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < 5; i++) {\n        mountainHeight += noise(uv * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return mountainHeight;\n}\n\n// Aurora layer function\nvec3 auroraLayer(vec2 uv, float speed, float intensity, vec3 color) {\n    float t = iTime * speed;\n    vec2 scaleXY = vec2(2.0, 2.0);\n    vec2 movement = vec2(2.0, -2.0);\n    vec2 p = uv * scaleXY + t * movement;\n    float n = noise(p + noise(color.xy + p + t));\n    \n    /*\n    float topEdgeSharpness = 0.1; //the smaller this value, the crispier the edge\n    float bottomFadeOut = 0.6; //the higher this value, the more solid the aurora appears\n    float aurora = smoothstep(0.0, topEdgeSharpness, n - uv.y) * (1.0 - smoothstep(0.0, bottomFadeOut, n - uv.y));\n    \n    return aurora * intensity * color;\n    */\n    float aurora = (n - uv.y * 0.6) ;\n    \n    return color * aurora * intensity * 2.0;\n}\n\n\n// Main image function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Create multiple aurora layers with varying colors, speeds, and intensities\n    vec3 color = vec3(0.0);\n    color += auroraLayer(uv, 0.05, 0.3, vec3(0.0, 1.0, 0.3));\n    color += auroraLayer(uv, 0.1, 0.4, vec3(0.1, 0.5, 0.9));\n    color += auroraLayer(uv, 0.15, 0.3, vec3(0.4, 0.1, 0.8));\n    color += auroraLayer(uv, 0.07, 0.2, vec3(0.8, 0.1, 0.6));\n    \n    vec3 skyColor1 = vec3(0.2, 0.0, 0.4);\n    vec3 skyColor2 = vec3(0.15, 0.2, 0.35);\n    // Add a gradient to simulate the night sky\n    color += skyColor2 * (1.0 - smoothstep(0.0, 1.0, uv.y));\n    color += skyColor1 * (1.0 - smoothstep(0.0, 0.4, uv.y));\n\n    int numLayers = 5;\n    for (int i = 0; i < numLayers; i++) {\n        // Calculate the height of the mountain range\n        float height = float(numLayers - i) * 0.1 \n            * smoothstep(0.9, 0.0, \n                mountainRange(\n                    vec2(iTime * 0.03 * (float(i) + 1.0) + float(i) * 4.0, 0.0) \n                    + uv * vec2( 1.0 + float(numLayers - i) * 0.05 , 0.23 )\n                )\n            );\n\n        // Create the black silhouette of the mountain range\n        float mountain = smoothstep(0.0, float(i) * 0.02, height - uv.y);\n\n        // Combine the mountain range and sky\n        color = mix(color, skyColor2 * float(numLayers - i)/3.0, mountain);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}