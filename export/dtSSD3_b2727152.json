{"ver":"0.1","info":{"id":"dtSSD3","date":"1676816285","viewed":58,"name":"raymarching test unique name","username":"Andrej730","description":"raymarching test based on https://www.youtube.com/watch?v=PGtv-dBi2wE","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DISTANCE_MIN_THRESHOLD 0.01\n#define DISTANCE_MAX_THRESHOLD 100.0\n#define MAX_STEPS 125\n\n\n// mine algorithm\nfloat sd_cylinder(vec3 p, vec2 size) {\n    float y = max(0., abs(p.y)-size.y);\n    float xz = max( length(p.xz) - size.x, 0.);\n    return length( vec2(xz, y) );\n    \n}\n\n// art of code algorithm\nfloat sd_cylinder_capsule_based(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n        \n    float proj_length_norm = dot(ap,ab) / dot(ab, ab);\n    vec3 c = a + ab * proj_length_norm;\n    float x = length(p-c) - r;    \n    \n    float y = (abs(proj_length_norm - .5) - .5) * length(ab);\n    // exterior distance\n    float e = length( max(vec2(0.), vec2(x, y) ) );\n    // interior distance - solves artifacts with raymarcher stepping inside\n    // the object\n    float i = min( max(x, y), 0.) * 1.0;\n    \n    return e + i;\n}\n\n\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n        \n    float proj_length = dot( normalize(ab), ap );\n    proj_length = clamp(proj_length, 0., length(ab) );\n    vec3 c = a + normalize(ab) * proj_length;\n  \n    return length(p-c) - r;\n}\n\n\n// ro - radius outer\n// ri - radius inner\nfloat sd_torus(vec3 p, vec3 o, vec2 r) {\n    vec3 op = p - o;\n    vec3 c = o + normalize( op * vec3(1.,0.,1.) ) * r.x;\n    return length(p-c) - r.y;\n}\n\n\n// art of code version\n// cube center at 0, need to move it by shifting P\nfloat sd_box_zero_center(vec3 p, vec3 dim) {\n    // need to clamp at max here\n    // otherwise points inside the cube will have some\n    // think of the point\n    return length(max(abs(p) - dim, vec3(0.)));\n}\n\n// mine version\n// cube origin is at left bottom corner and specified as an argument\nfloat sd_box_at_origin(vec3 p, vec3 o, vec3 dim) {\n    // mine version - origin at O (left bottom cube corner)\n    vec3 a = clamp(p-o, vec3(0.), dim) + o;\n    return length(p-a);\n}\n\n// distance to any closest point\nfloat get_distance(vec3 pos) {\n    vec4 sphere = vec4(2., 1, 6, 1); // x y z + radius\n   \n    float distance_plane = pos.y; // distance to the plane\n   \n    float wall00_x_position = -10.;\n    float distance_wall00 = abs(pos.x-wall00_x_position); // -5 is wall position\n   \n    float distance_sphere = length(pos-sphere.xyz) - sphere.w;\n    float distance_capsule = sd_capsule(pos, vec3(-2., 1, 6), vec3(-2., 2, 6), .4); \n    float distance_torus = sd_torus(pos, vec3(0, 0.5, 5.), vec2(1., .2));\n    // float distance_box = sd_box_zero_center(pos - vec3(0., 1., 6.), vec3(0.5));\n    // float distance_cylinder = sd_cylinder(pos - vec3(0., 1., 4.), vec2(0.5, 0.5));\n    float distance_cylinder = sd_cylinder_capsule_based(pos, vec3(0., .7, 3), vec3(3., .7, 5), .3);\n    \n    float dist = min(distance_plane, distance_sphere);\n    // dist = min(dist, distance_wall00);\n    dist = min(dist, distance_capsule);\n    dist = min(dist, distance_cylinder);\n    dist = min(dist, distance_torus);\n    return dist;\n}\n\n\nvec3 get_normal(vec3 pos) {\n    vec2 e = vec2(0.01, 0.);\n    float d = get_distance(pos);\n    vec3 normal = d - vec3(\n        get_distance(pos - e.xyy),\n        get_distance(pos - e.yxy),\n        get_distance(pos - e.yyx)\n    );\n    return normalize(normal);\n}\n\n// ray_march = find the distance to the surface in the direction\nfloat ray_march(vec3 ro, vec3 rd) {\n    // идём по направлению rd от ro\n    // проверяем distance и шаги\n    int steps = 0;\n    vec3 current_pos = ro;\n    float total_distance = 0.0;\n    \n    for (int i=0; i < MAX_STEPS; i++) {\n        vec3 current_pos = ro + rd * total_distance;\n        float distance_surface = get_distance(current_pos);\n        total_distance = total_distance + distance_surface;\n        if (distance_surface < DISTANCE_MIN_THRESHOLD || total_distance > DISTANCE_MAX_THRESHOLD) break;\n    }\n    return total_distance;\n}\n\n\nfloat get_light(vec3 pos) {\n    vec3 light_pos = vec3(0, 4, 6);\n    light_pos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 light_vector = normalize(light_pos - pos);\n    vec3 normal = get_normal(pos);\n    \n    float diffuse_value = 0.;\n        \n    diffuse_value = dot(light_vector, normal);\n    diffuse_value = clamp(diffuse_value, 0., 1.);\n    \n    // adding shadows\n    // need to add some distance otherwise ray_march will hit the surface right away\n    // and will result in 0 and make everything dark all the time\n    float dist_surface = ray_march(pos + normal * DISTANCE_MIN_THRESHOLD*5., light_vector);\n    float dist_light = length(light_pos - pos);\n    if (dist_surface < dist_light) diffuse_value *= 0.1;\n    \n    return diffuse_value;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0.); \n    // ray origin = camera; y - is height axis\n    vec3 ro = vec3(0, 3, 0.);\n    // ray direction; View plane is in 1m away of us (z=1.0) \n    // -0.2 - is for tilt\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.3, 1));\n\n\n    float dist = ray_march(ro, rd);\n    // dist /= 12.;\n    // fragColor = vec4(vec3(dist), 1.0);\n    // return;\n    \n    vec3 surface_pos = ro + rd*dist; \n    \n    \n    col = vec3(get_light(surface_pos));\n    //col = get_normal(surface_pos);\n    fragColor = vec4(col, 1.0);\n}\n\n// https://i.imgur.com/wHwLYXq.jpeg","name":"Image","description":"","type":"image"}]}