{"ver":"0.1","info":{"id":"MsGcRD","date":"1522754340","viewed":434,"name":"kyoto temple","username":"lovelyH","description":"GFX for Revision 2018 demparty. 2nd place.\nhttps://www.pouet.net/prod.php?which=75775\nIt's set up for low quality so people can see it without web browser crushing.\nTo see full high quality version just uncoment #define HQ","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["temple","gfx","kyoto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// see BufA for actual source code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= fragCoord / iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define HQ\n\n#ifdef HQ\n#define E 0.001\n#else\n#define E 0.01\n#endif\n\n#define EC 0.1\n\n#define INF 100000.0\n\n#define POSTPROCESSING_POW 0.8\n\n\n\nvec2 rot( vec2 p, float l){\n\tfloat sl= sin(l);\n\tfloat cl= cos(l);\n\treturn vec2(\n\t\tp.x*cl - p.y*sl,\n\t\tp.x*sl + p.y*cl\n\t);\n}\n\n\n\nfloat max3( float a, float b, float c ){\n\treturn max(max(a,b),c);\n}\n\nfloat min3( float a, float b, float c ){\n\treturn min(min(a,b),c);\n}\n\nfloat min4( float a, float b, float c, float d ){\n\treturn min(min3(a,b,c),d);\n}\n\nfloat max4( float a, float b, float c, float d ){\n\treturn max(max3(a,b,c),d);\n}\n\n\n\n\nfloat hash11f( float n )\n{\n\treturn fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nfloat hash12f( vec2 p )\n{\n\tp  = 50.0*fract( p*0.3183099 );\n\treturn fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec2 hash21f( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec2 hash22f( vec2 p ) \n{\n\tconst vec2 k = vec2( 0.3183099, 0.3678794 );\n\tp = p*k + k.yx;\n\treturn fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat noise( in vec3 arg )\n{\n\tvec3 p = floor(arg);\n\tvec3 w = fract(arg);\n\t\n\tvec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\t\n\tfloat n = p.x + 317.0*p.y + 157.0*p.z;\n\t\n\tfloat a = hash11f(n+0.0);\n\tfloat b = hash11f(n+1.0);\n\tfloat c = hash11f(n+317.0);\n\tfloat d = hash11f(n+318.0);\n\tfloat e = hash11f(n+157.0);\n\tfloat f = hash11f(n+158.0);\n\tfloat g = hash11f(n+474.0);\n\tfloat h = hash11f(n+475.0);\n\n\tfloat k0 =   a;\n\tfloat k1 =   b - a;\n\tfloat k2 =   c - a;\n\tfloat k3 =   e - a;\n\tfloat k4 =   a - b - c + d;\n\tfloat k5 =   a - c - e + g;\n\tfloat k6 =   a - b - e + f;\n\tfloat k7 = - a + b + c - d + e - f - g + h;\n\n\treturn -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\n\n\n\nfloat fbm( in vec3 x, int imax )\n{\n\tfloat f = 2.0;\n\tfloat s = 0.5;\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfor( int i=0; i<imax; i++ )\n\t{\n\t\tfloat n = noise(x);\n\t\ta += b*n;\n\t\tb *= s;\n\t\tx = f*mat3(\t 0.00,  0.80,  0.60,\n\t\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t\t-0.60, -0.48,  0.64 )*x;\n\t}\n\treturn a;\n}\n\n\n\n/// aproxymate template map\nfloat mapTempleBase( vec3 p ){\n\treturn min( max( -3.5 - p.x, abs(p.y)-5.3 ), max( -0.3-p.x,  abs(p.y) - 11.3 ) );\n}\n\nvec3 lightDis= vec3(INF);\n\nconst float treesDist = 4.0;\n\n\n/// map of height of trees\nfloat getTreeHeight(vec2 pi){\n\treturn hash12f( pi.xy ) * 2.0\n\t+ .2*min( 0.0, (treesDist-abs(pi.y)) )\n\t/// lower under temple\n\t+ clamp( (mapTempleBase(pi.xyy)*0.9+1.0), -99.0, 0.0 )\n\t/// higher under temple\n\t+ clamp( pi.x * pi.x * 0.006, 0.0, 20.0 )\n\t// done\n\t;\n}\n\n\n\nfloat mapTreesBase(vec3 p){\n\tp.x += 11.0;\n\tp.z -= 1.5;\n\tp.z += 5.0;\n\n\t// const float treesDist = 4.0;\n\t// const float border= 6.0;\n\tfloat r= p.z+100000.0;\n\t\n\t/// tree in our cube and neighbour cubes\n\tfor( int ax=-1;ax<=1;ax++)\n\tfor( int ay=-1;ay<=1;ay++)\n\t{\n\t\tvec3 ai= vec3(ax,ay,0)* treesDist;\n\n\t\tvec3 pi= floor(p/treesDist)*treesDist + ai;\n\n\t\tvec3 pf= fract(p/treesDist)*treesDist;\n\t\tpf.z = p.z;\n\n\t\tvec3 pr= pi;\n\n\t\tvec3 ph= pf - ai;\n\t\tph.xy -= treesDist*vec2(0.5);\n\n\t\tph.xy += (hash22f( pi.xy )-0.5) * treesDist * 1.0;\n\t\tph.z -= getTreeHeight(pi.xy);\n\n\t\tfloat rc;\n\n\t\t/// tree shape\n\t\trc= length(ph * vec3(1.,1.,1.5) ) - 2.0;\n\n\t\t/// shape cdn\n\t\t#ifdef HQ\n\t\t{\n\t\t\tconst float s= 1.0;\n\t\t\trc= ((fbm((p)*s,2)-.2)/s + rc) / 2.0;\n\t\t}\n\t\t#endif\n\n\t\t/// apply\n\t\tr= min( r, rc );\n\t}\n\n\t///@todo cut back of trees\n\t// r= max( r, p.y-30.0 );\n\t// r= max( r, p.y-250.0 );\n\n\t/// done\n\treturn r;\n}\n\n\n\nfloat mapTrees(vec3 p){\n\tfloat r= mapTreesBase(p);\n\n\t/// tree surfus\n\t{\n\t\tconst float s= 16.0;\n\t\t#ifdef HQ\n\t\tr= max( r, fbm(p*s,4)/s + 0.2*(r+0.4) );\n\t\t#else\n\t\t// r= max( r, fbm(p*s,4)/s + 0.2*(r+0.4) );\n\t\t#endif\n\t}\n\n\treturn r;\n}\n\n\n\nfloat getLightCornerTrees( vec3 sp, vec3 nor ){\n\tfloat r= 1.0;\n\n\t// for( float t=0.01; t<0.32; t *= 2.0 ) /// that may be better quality\n\tfor( float t=0.01; t<0.08; t *= 2.0 )\n\t\tr *= clamp(mapTrees(sp + nor*t) / t, .6, 1.);\n\n\treturn r;\n}\n\n\n\nfloat getLightShadowTrees( vec3 sp, vec3 nor ){\n\t// return 1.0;\n\tif( nor.z <= 0.0 )return 0.0;\n\tfloat t= E * 16.0;\n\t// float t= E / nor.z;\n\tvec3 hp;\n\tfloat r= 1.0;\n\tfor( int i=0;i<0x40;i++) /// HQ\n\t// for( int i=0;i<0x10;i++)\n\t{\n\t\thp= sp + vec3(0,0,1) * t;\n\t\tfloat dis= mapTrees(hp);\n\t\tt += dis;\n\t\tif( dis < E ){\n\t\t\treturn 0.0;\n\t\t}\n\t\tif( 10.0 < dis ){\n\t\t\tbreak;\n\t\t}\n\t\tr= min( r, 2.*dis / t );\n\t}\n\tr=clamp( r, 0., 1. );\n\tif( nor.z < 0.2 ){\n\t\tr *= 5.0 * nor.z;\n\t}\n\treturn r;\n}\n\n\n\nvec4 renderTrees( vec3 sp, vec3 dir ){\n\t/// calculate hit point\n\tvec3 hp;\n\tbool isHit= false;\n\tfloat dis;\n\tfloat t= 0.0;\n\n\t/// paroximate hp\n\tfor( int i=0;i<0x40;i++)\n\t{\n\t\tdis= mapTreesBase(sp + t * dir);\n\t\tt += dis;\n\t\tif( dis < E || 100.0 < t )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/// moare aquirete point\n\t// t = max( t-0.05, 0.0 );\n\tt = max( t-16.0*E, 0.0 );\n\t// hp = sp + t * dir;\n#ifdef HQ\n\tfor( int i=0;i<0x400;i++) /// awsome quality\n#else\n\tfor( int i=0;i<0x20;i++)\n#endif\n\t{\n\t\tt += dis;\n\t\tdis= mapTrees(hp = sp + t * dir);\n\t\tif( dis < E ){\n\t\t\tisHit= true;\n\t\t\tif( 0.0 <= dis )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/// color calculating\n#ifdef HQ\n\tif( isHit )\n#else\n\t// if( true )\n\tif( isHit )\n\t// if( isHit || t < 50.0 )\n\t// if( isHit || dis < 0.5 )\n#endif\n\t{\n\t\t/// base color\n\t\tvec3 baseColor= mix( vec3( .1, .9, .1 ), vec3( .9, .9, .1 ), 0.5+0.5*fbm(4.*hp,4) );\n\t\t// if( hp.z <= E ){\n\t\t// \t/// ground\n\t\t// \tbaseColor= vec3( .9, .5, .1 );\n\t\t// }else{\n\t\t// \t/// tree\n\t\t// \t// baseColor= vec3( .1, .9, .1 );\n\t\t// \tbaseColor= mix( vec3( .1, .9, .1 ), vec3( .9, .9, .1 ), 0.5+0.5*fbm(4.*hp) );\n\t\t// }\n\t\t/// lighting\n\t\t//vec3 norB= normalize(vec3(\n\t\t//\tmapTreesBase(vec3(hp.x+E,hp.y,hp.z))-mapTreesBase(vec3(hp.x-E,hp.y,hp.z)),\n\t\t//\tmapTreesBase(vec3(hp.x,hp.y+E,hp.z))-mapTreesBase(vec3(hp.x,hp.y-E,hp.z)),\n\t\t//\tmapTreesBase(vec3(hp.x,hp.y,hp.z+E))-mapTreesBase(vec3(hp.x,hp.y,hp.z-E))\n\t\t//));\n  \t\tvec3 norB= vec3( 0 );\n\t\tfor( int i=min( iFrame, 0 ); i<4; i++){\n\t\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\t\tnorB += e * mapTreesBase( hp + e*E );\n\t\t}\n        norB= normalize( norB );\n\n\t\t//vec3 nor= normalize(vec3(\n\t\t//\tmapTrees(vec3(hp.x+E,hp.y,hp.z))-mapTrees(vec3(hp.x-E,hp.y,hp.z)),\n\t\t//\tmapTrees(vec3(hp.x,hp.y+E,hp.z))-mapTrees(vec3(hp.x,hp.y-E,hp.z)),\n\t\t//\tmapTrees(vec3(hp.x,hp.y,hp.z+E))-mapTrees(vec3(hp.x,hp.y,hp.z-E))\n\t\t//));\n  \t\tvec3 nor= vec3( 0 );\n\t\tfor( int i=min( iFrame, 0 ); i<4; i++){\n\t\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\t\tnor += e * mapTrees( hp + e*E );\n\t\t}\n        nor= normalize( nor );\n        \n        \n\t\t/// final color\n\t\treturn vec4( \n\t\t\t\tbaseColor\n\t\t\t\t* clamp(.5+.5*dot(nor,-dir), 0.1, 1.0)\n\t\t\t\t* clamp(.3+.7*dot(nor,vec3(0,0,1)), 0.1, 1.0)\n\n\t\t\t\t* clamp(.5+.5*dot(norB,vec3(0,0,1)), 0.1, 1.0)\n\n\t\t\t\t/// light\n\t\t\t\t* (.5+.5*getLightShadowTrees(hp,nor))\n\t\t\t\t* (.5+.5*getLightCornerTrees(hp,nor))\n\n\t\t\t\t/// light up some tops of trees\n\t\t\t\t* clamp(\n\t\t\t\t\t.5+1.0\n\t\t\t\t\t\t* pow( clamp(dot(norB,vec3(0,0,1)),0.0,1.0), 4.0 )\n\t\t\t\t\t\t* clamp(dot(nor,vec3(0,0,1)),0.5,1.0)\n\t\t\t\t\t\t* clamp(.3+fbm(hp*0.5+5.0,5),0.0,1.0)\n\t\t\t\t\t, 0.1, 1.0)\n\n\t\t\t\t* .5\n\t\t\t\t// * .75\n\n\t\t\t\t/// fake shadow under temple\n\t\t\t\t// * clamp( 1.0+0.9*mapTempleBase(hp), 0.0, 1.0 )\n\t\t\t\t// * clamp( 0.0+0.2*mapTempleBase(hp), 0.0, 1.0 )\n\t\t\t\t// * clamp( (hp.z + 10.0 )*0.4 + 0.1*mapTempleBase(hp), 0.0, 1.0 )\n\t\t\t\t* clamp( 0.0+min(0.5+0.3*mapTempleBase(hp),hp.z+9.0), 0.0, 1.0 )\n\n\t\t\t\t/// black blow some point\n\t\t\t\t// * clamp( hp.z+9.0, 0.0, 1.0 )\n\n\t\t\t, t)\n\t\t\t;\n\t}else{\n\t\t/// sky\n\t\t// return vec3( .1, .1, .5 );\n\t\treturn vec4( 0, 0, 0, INF );\n\t}\n}\n\n\n\nfloat mapTempleWall(vec3 p){\n\treturn max3( 1.0+2.0*4.0-p.x, abs(p.y)-10.0, abs(p.z-1.5)-1.5 );\n}\n\n\n\nconst vec3 templeLightPoint= vec3(9.0,-2.0,1.75);\n\nfloat mapTempleLight(vec3 p){\n\t// return length(p-templeLightPoint)-0.5;\n\t// vec3 pl= templeLightPoint;\n\t// return max( length(p-pl)-0.6, pl.x-p.x );\n\t// const float l= 0.5;vec3 ph= abs(p - pl) - vec3(0.0, l, l );\n\n\t// vec3 ph= abs(p - templeLightPoint) - vec3(0.0, 1.4, 0.5);\n\tvec3 ph= abs(p - templeLightPoint) - vec3(0.0, 3.4, 0.5);\n\n\t// float r;\n\t// if( 0.0 < ph.y && 0.0 < ph.z ){\n\t// \tr= length(ph.yz);\n\t// }else{\n\t// \tr= max(ph.y,ph.z);\n\t// }\n\t// r= max( r, ph.x );\n\t// return r;\n\treturn max( 0.0 < ph.y && 0.0 < ph.z ? length(ph.yz) : max(ph.y,ph.z), ph.x );\n}\n\n\n\nfloat mapTempleRoofTopping(vec3 p){\n\tp.y= abs(p.y);\n\tvec3 ph= p;\n\tfloat r= length(vec2(ph.y,abs(ph.z)-0.07))-0.1;\n\tr= min( r, max3( ph.x-0.2, ph.y-0.2, abs(ph.z)-0.3 ) );\n\t\n\t/// side bottom wood pices\n\tph.z += 0.1;\n\tph.x= mod( ph.x, 0.18 ) - 0.09;\n\tph.yz= rot( ph.yz, 0.4 );\n\tr= min( r, max( length(ph.xz)-0.05, abs(ph.y)-0.2 ) );\n\n\tr= max( r, -p.x );\n\n\t/// top hook\n\tp.z -= 0.2;\n\tp.xz= rot( p.xz, 0.4 );\n\treturn min( r, max( length(p.yz)-0.1, abs(p.x)-0.5) );\n}\n\n\n// const vec3 configTempleLightColor= vec3(1.0,0.7,0.1);\n\n\nfloat mapTemple(vec3 p){\n\tfloat rc;\n\tfloat r;\n\tvec3 ph, hv3;\n\n\t///@todo delete\n\t// rc= mapTempleBase(p);\n\t// if( 2.0 < rc )\n\t// \treturn rc;\n\n\t/// front pales under temple\n\tph= p;\n\tph.y= abs(abs(abs(ph.y)-2.0) - 2.0) - 1.0;\n\tph.x += 2.0;\n\tr= max( max( abs(ph.x), abs(ph.y) ) - 0.2, ph.z+0.5 );\n\tph.z = max(\n\t\tmod( ph.z + 0.75, 1.5 ) - 0.75\n\t\t, ph.z);\n\t\n\t/// horizontal pales over OY\n\tr= min( r, max3( max(abs(ph.x)-.1,abs(ph.z)-.17), abs(p.y) - 5.6 , p.z+0.75 ) );\n\n\t/// horizontal pales over OX\n\tr= min( r, max( max3( -ph.x, abs(ph.y)-.1, abs(ph.z)-.2 ), p.z+0.5 ) );\n\n\t/// kolce or whatever\n\tph.z += 0.25;\n\tph.xz = rot( ph.xz, -0.1 * 3.1415926535897932 );\n\tr= min( r, \n\t\tmax3( max( abs(ph.y) - 0.1, abs(ph.z)-0.1 ), ph.x , -1.0 - ph.x ) \n\t\t);\n\n\t/// floor 1\n\tr= min( r,\n\t\tmax3( -p.x-3.5, abs(p.y)-5.3, abs(p.z+0.5) - 0.05 ) \n\t\t);\n\n\t/// floor 2\n\tr= min( r, \n\t\tmax3( -p.x-0.3, abs(p.y)-6.0, abs(p.z+0.4) - 0.05 )\n\t\t);\n\n\t/// floor 3\n\tr= min( r, \n\t\tmax3( -p.x+2.0, abs(p.y)-8.0, abs(p.z+0.2) - 0.1 ) \n\t\t);\n\n\t/// floor last\n\tr= min( r, \n\t\tmax3( -p.x+4.0, abs(p.y)-6.0, abs(p.z) - 0.05 ) \n\t\t);\n\tr= min( r, \n\t\tmax3( -p.x-0.3, abs(abs(p.y) -8.0 -0.5)-2.8, abs(p.z+0.0) - 0.05 ) \n\t\t);\n\n\t/// under side floor\n\tr= min( r, \n\t\tmax3( -p.x, abs(abs(p.y) - 8.0)-2.2, abs(p.z+0.2) - 0.15 ) \n\t\t);\n\n\t/// columns\n\tr= min( r, \n\t\tmax( min( max( max( abs(mod( p.x, 2.0 ) - 1.0), abs(abs(abs(p.y)-8.0)-2.0) ) - 0.15, -p.x ), max( abs(p.x-1.0)-.2, abs(abs(p.y)-8.0)-.2) ), p.z-3.0 )\n\t\t);\n\n\t/// wall columns\n\tph= p;\n\tph.x -= 9.0;\n\tph.y= abs(abs(abs(ph.y)-4.0)-4.0)-2.0;\n\tr= min( r, \n\t\tmax( max( abs(ph.x), abs(ph.y) ) - 0.4, ph.z - 3.1 ) \n\t\t);\n\n\t/// parapet\n\t#ifdef HQ\n\tph.y= p.y;\n\tr= min( r, \n\t\tmax3( abs(ph.x)-0.35, abs(ph.y)-10.0, abs(ph.z-1.0)-0.05 ) \n\t\t);\n\t#endif\n\n\t// wall lines\n\t#ifdef HQ\n\tr= min( r,\n\t\tmin( max3( abs(ph.x)-0.05, abs(ph.y)-10.0, abs(ph.z-2.5)-0.05 ), max3( abs(ph.x)-0.05, abs(abs(abs(ph.y)-6.0)-2.0)-0.05, ph.z-3.0 ) ) \n\t\t);\n\t#endif\n\n\t/// 3 side holders\n\t#ifdef HQ\n\tr= min( r, \n\t\tmax3( -p.x, abs(abs(abs(abs(p.y) - 8.0)-1.0)-1.0)-.2, abs(p.z+.6)-.25 ) \n\t\t);\n\t#endif\n\n\t/// supki 1\n\t#ifdef HQ\n\tph= vec3(\n\t\tabs(p.x+1.0)-1.0,\n\t\tabs(p.y)-5.0,\n\t\tp.z - 0.8\n\t);\n\tr= min( r, \n\t\tmax( \n\t\t\tmin3( \n\t\t\t\tmax( length(ph.xy)-0.2, p.z-0.4 ), \n\t\t\t\tmax( length(ph.xy)-0.15, p.z-0.7 ), \n\t\t\t\tlength(ph)-0.15 \n\t\t\t),\n\t\t\t-p.z-0.5\n\t\t)\n\t);\n\t#endif\n\t\n\t/// supki 2\n\t#ifdef HQ\n\tph= vec3(\n\t\tabs(p.x+0.1),\n\t\tabs(abs(abs(p.y)-8.5)-2.6),\n\t\tp.z- 1.0\n\t\t);\n\t/// top cut\n\tr= min( r, max3( \n\t\tmax( max( ph.x, ph.y ) - .15, -p.z ), \n\t\trot( ph.xz, 0.62 ).y,\n\t\trot( ph.yz, 0.62 ).y \n\t) );\n\t#endif\n\n\t/// porencz 2\n\t#ifdef HQ\n\tph= p;\n\tph.x= abs(ph.x+1.0)-1.0;\n\tph.y= -(abs(ph.y) - 5.0) * sign( p.x + 1.0 );\n\tph.xy= vec2( min(ph.x,ph.y), max(ph.x,ph.y) );\n\trc= min4(\n\t\tlength(ph.yz-vec2(0,0.25)) - 0.07,\n\t\tmax( abs(ph.y)-0.07, abs(ph.z)-0.04 ) ,\n\t\tmax( abs(ph.y)-0.13, abs(ph.z+0.25)-0.09 ),\n\t\tmax3( abs(min( mod(ph.x,1.0), -ph.x ) - 0.5)-0.1, abs(ph.y)-0.1, abs(ph.z+0.1) - 0.06 ) \n\t\t);\n\tph.x= abs(abs(abs(ph.x+1.5) - 2.0) - 1.0);\n\tr= min( r, \n\t\tmax( min( rc, max3( abs( ph.x - 0.5)-0.07, abs(ph.y)-0.06, abs(ph.z+0.0) - 0.2 ) ), abs(p.y)-6.0 ) \n\t);\n\t#endif\n\n\t/// porencz 2\n\t#ifdef HQ\n\tph= p;\n\tph.x += 0.1;\n\tph.y= abs(ph.y) - 11.1;\n\tph.y *= -1.0;\n\tph.xy= vec2( min( ph.x,ph.y), max(ph.x,ph.y) );\n\tph.z -= 0.4;\n\trc= min( \n\t\tmax(abs(ph.x)-.05,abs(ph.z)-.07), \n\t\tmax( max(abs(ph.x),abs(mod( ph.y, 1.0 ) - 0.5))-.07, abs(ph.z)-.3 ) \n\t);\n\tph.z= abs(ph.z)-0.3;\n\tr= min( \n\t\tr, \n\t\tmax( \n\t\t\tmin( rc, max(abs(ph.x)-.12,abs(ph.z)-.08) ), \n\t\t\t-abs(p.y)+6.05 ) /// cut middle of temple\n\t); /// apply\n\t#endif\n\n\t/// side roof\n\t{\n\t\tph= p;\n\t\tph.z -= 3.0;\n\t\tph.y= abs(abs(ph.y) - 8.0);\n\n\t\trc= max4( \n\t\t\t-1.5-ph.x , \n\t\t\tph.y - 4.0, \n\t\t\tph.z - 4.0,\n\t\t\t4.3-length(ph.yz-vec2(4.0,4.4)) \n\t\t);\n\n\t\tfloat h= max( abs(rc+0.05)-0.05, -0.3-p.x );\n\n\t\trc= min( \n\t\t\tmax( rc, 4.0 - length( ph.xz - vec2(-2.35,4.0) ) )\n\t\t\t,\n\t\t\th \n\t\t);\n\n\t\t#ifdef HQ\n\t\trc= min( rc, mapTempleRoofTopping(ph-vec3(-0.2,0,2.85)) );\n\t\t#endif\n\t}\n\trc= max( rc, 2.9-p.z );\n\t/// bottom part\n\t#ifdef HQ\n\t{\n\t\tph.x += 1.5;\n\t\tph.y -= 4.0;\n\t\tvec3 ph2= ph;\n\n\t\t/// corner\n\t\tph.xy= rot( ph.xy, -0.25*3.141592653589 );\n\t\tph.y += 0.9;\n\t\tph.yz= rot( ph.yz, 0.3 );\n\t\trc= min( rc, max3( max(abs(ph.x),abs(ph.z))-0.15, ph.y-1.1, p.z-2.9 ) );\n\n\t\t/// small side pices\n\t\tph= ph2;\n\t\tph.xy= vec2( min( ph.x, -ph.y), max( ph.x, -ph.y) );\n\t\tph.z += 0.2;\n\t\tph.y= mod( ph.y, 0.2 ) - 0.1;\n\t\tph.xz= rot( ph.xz, -0.3 );\n\t\trc= min( rc, max( length( ph.yz )-0.07, -(ph.x)-0.1 ) );\n\t}\n\t#endif\n\tr= min( r, rc );\n\n\t/// main roof\n\tph= p;\n\tph.x -= 4.0;\n\tph.y= abs(ph.y) - 12.0;\n\tph.z -= 5.0;\n\trc= rot( ph.xz, -0.17 * 3.14 ).y;\n\trc= max( rc, ph.y );\n\trc= max( rc, -length(vec2(ph.y,ph.z-5.0))+5.0 );\n\t// rc= max( rc, -length(vec2(ph.x-9.0,ph.y-19.5))+23.0 ); /// extra cut on side\n\trc= max( rc, -max(ph.z,-ph.y-4.0) );\n\trc= max( rc, -ph.z-2.0 );\n\trc= max( rc, ph.z - 5.0 );\n\tr= min( r, rc );\n\n\t/// main roof top\n\tph= p;\n\tph.xy= ph.yx;\n\tph.x = 7.0-abs(ph.x);\n\t#ifdef HQ\n\trc= min( rc, mapTempleRoofTopping(ph-vec3(0,12.5,10)) );\n\t#endif\n\tr= min( r, rc );\n\n\t/// walls\n\tr= min( r, mapTempleWall( p ) );\n\n\t/// light point\n\tr= min( r, mapTempleLight(p) );\n\t///@todo lightDis.xy= min( lightDis.xy, mapTempleLight(p) * vec2(1.0,1.4) * 10.0  );\n\tlightDis= min( lightDis, mapTempleLight(p) * vec3(1.0,1.4,5.0) * 10.0  );\n\n\t/// done\n\treturn r;\n}\n\n\n\nvec4 renderTemple( vec3 sp, vec3 dir){\n\tvec3 p= sp;\n\tfloat t= 0.0;\n\tbool isHit= false;\n\tfloat dis;\n#ifdef HQ\n\tfor( int i=0;i<0x300;i++)\n#else\n\tfor( int i=0;i<0x40;i++)\n#endif\n\t{\n\t\tp = sp + t * dir;\n\t\tdis= mapTemple(p);\n\t\tt += dis;\n\t\tif( dis < E ){\n\t\t\tisHit= true;\n\t\t\tif( 0.0 <= dis )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/// color\n\tif( isHit ){\n\n\t\t/// normal vector\n\t\t//vec3 nor= normalize( vec3(\n\t\t//\tmapTemple(vec3(p.x+E,p.y,p.z))-mapTemple(vec3(p.x-E,p.y,p.z)),\n\t\t//\tmapTemple(vec3(p.x,p.y+E,p.z))-mapTemple(vec3(p.x,p.y-E,p.z)),\n\t\t//\tmapTemple(vec3(p.x,p.y,p.z+E))-mapTemple(vec3(p.x,p.y,p.z-E))\n\t\t//));\n  \t\tvec3 nor= vec3( 0 );\n\t\tfor( int i=min( iFrame, 0 ); i<4; i++){\n\t\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\t\tnor += e * mapTemple( p + e*E );\n\t\t}\n        nor= normalize( nor );\n\n\n\t\t/// mateiral\n\t\tbool isWall= false;\n\t\tbool isRoof= false;\n\t\tbool isUnder= false;\n\t\tif( mapTempleWall(p) <= dis + E ){\n\t\t\tisWall= true;\n\t\t}\n\t\t// if( 2.9 < p.z && 0.001 < nor.z ){\n\t\tif( 2.9 < p.z  ){\n\t\t\tisRoof= true;\n\t\t}\n\t\tif( (p.z+0.55) < 0.0 || (5.8 < abs(p.y) && p.z < -0.05 ) )\n\t\t\tisUnder= true;\n\n\t\t/// base color\n\t\tfloat h= (.7+.3*fbm(p,5) );\n\t\tvec3 baseColor= vec3(0);\n\t\tif( false ){\n\t\t}else if( isWall ){\n\t\t\tbaseColor= vec3(1);\n\t\t// }else if( isUnder ){\n\t\t// \treturn vec4(.9,.5,.5,t);\n\t\t}else{\n\t\t\tbaseColor= vec3(.2,.17,.15);\n\n\t\t\tbaseColor= mix( baseColor, vec3(.3) * vec3(.9,.85,.82), clamp( pow(.5+.5*fbm(p+51.0,5), 1.0), 0.0, 1.0 ) ); /// base color\n\n\t\t\tbaseColor= mix( baseColor, vec3(0,6,20)/255., clamp( pow(.5+.5*fbm(p*4.0,5), 6.0), 0.0, 1.0 ) ); /// black partts\n\n\t\t\tbaseColor= mix( baseColor, vec3(.7,.8,.8), clamp( pow(.5+.5*fbm(p*7.2,5), 8.0), 0.0, 1.0 ) ); /// white dots\n\t\t}\n\n\t\t/// light\n\t\t// if( mapTempleLight(p) < dis + E ){\n\t\t// \treturn vec4(configTempleLightColor,t);\n\t\t// }\n\n\t\t/// corner shadow\n\t\tfloat corenrLight= 1.0;\n\t\tfor( float a= 0.01; a<0.64; a*=2.0 ){\n\t\t\tvec3 ph= p + a*nor;\n\t\t\tcorenrLight = min( corenrLight, clamp( a + mapTemple(ph) / a, 0.0, 1.0 ) );\n\t\t}\n\n\t\t///@todo delete debug\n\t\t// if( isRoof )return vec4(1,0,0,t);\n\n\t\t/// final color\n\t\treturn \n\t\t\tvec4(\n\t\t\t\t//mix( vec3(.5,.5,.9), mix( vec3(.4,.4,.3), vec3(.1,.2,.1), 0.5+h*0.5), h*0.5 )\n\t\t\t\t// mix( vec3(.5,.5,.9), mix( vec3(.4,.4,.3), vec3(.1,.2,.1), 0.5+h*0.5), h*0.5 ) * vec3(.9,.6,.3)\n\t\t\t\t//mix( vec3(.9,.6,.3), mix( vec3(.4,.4,.3), vec3(.1,.1,.1), 0.5+h*0.5), h*0.5 ) * .5\n\t\t\t\tbaseColor\n\t\t\t\t* (.5+.5*dot(nor,-dir))\n\t\t\t\t// * (.7+.3*dot(nor,-dir))\n\t\t\t\t* ( isRoof || isUnder ? (.7+.3*dot(nor,vec3(0,0,1))) : (.85+.15*dot(nor,vec3(0,0,1))) )\n\t\t\t\t// * (.8+.2*dot(nor,vec3(0,0,1)))\n\t\t\t\t* (.6+.4*corenrLight )\n\t\t\t\t// * (.1+.9*corenrLight )\n\t\t\t\t// * .5\n\t\t\t\t/// fake lights just for this scene, under temple\n\t\t\t\t// * clamp( p.z * 0.19 + 1.0, 0.1, 1.0 )\n\t\t\t\t* clamp( p.z * 0.15 + 1.0, 0.1, 1.0 )\n\n\t\t\t\t// * clamp( max( 1.0+mapTempleBase(p)*0.6, (p.z+0.55) < 0.0 || (5.8 < abs(p.y) && p.z < -0.05 ) ? 0.0 : 1.0 ), 0.1, 1.0 )\n\t\t\t\t* clamp( max( 1.0+max(mapTempleBase(p),-3.0-p.x)*0.6, (p.z+0.55) < 0.0 || (5.8 < abs(p.y) && p.z < -0.05 ) ? 0.0 : 1.0 ), 0.1, 1.0 )\n\n\t\t\t\t/// fake shadow just under balcon\n\t\t\t\t* ( isUnder ? clamp(-p.z+( abs(p.y) < 6.0 ? -0.5 : 0.0),0.1,1.0) : 1.0 )\n\n\t\t\t\t/// fake light on balcon\n\t\t\t\t// * (.4 + .6 * ( !isRoof && !isUnder ? (.5+.5*dot(nor,normalize(templeLightPoint-p))) * clamp( 25.0 / (25.0 + mapTempleLight(p)), 0.0, 1.0 ) : 0.0 ) )\n\t\t\t\t// * (.3 + 1.0 * ( !isRoof && !isUnder ? (.5+.5*dot(nor,normalize(templeLightPoint-p))) * clamp( 25.0 / (25.0 + mapTempleLight(p)), 0.0, 1.0 ) : 0.0 ) )\n\t\t\t\t// * (.3 + 1.0 * ( !isRoof && !isUnder ? (.5+.5*dot(nor,normalize(templeLightPoint-p))) * clamp( 5.0 / (5.0 + mapTempleLight(p)), 0.0, 1.0 ) : 0.0 ) )\n\t\t\t\t// * (.3 + 1.0 * ( !isRoof && !isUnder ? (clamp(dot(nor,normalize(templeLightPoint-p)),0.0,1.0)) * clamp( 5.0 / (5.0 + mapTempleLight(p)), 0.0, 1.0 ) : 0.0 ) )\n\t\t\t\t* (.3 + 1.0 * ( !isRoof && !isUnder ? (clamp(dot(nor,normalize(templeLightPoint-p)),0.0,1.0)) * clamp( 5.0 / (5.0 + 2.0*mapTempleLight(p)), 0.0, 1.0 ) : 0.0 ) + (isUnder ? 0.05 : 0.0) )\n\t\t\t,\n\t\t\t\tt\n\t\t\t);\n\t}else{\n\t\treturn vec4(0,0,0,INF);\n\t}\n}\n\n\n\nvec2 matPi;\nint matId;\n\n\n/// map of city\nfloat mapCity(vec3 p){\n\tp.z += 120.0;\n\tp.x += 400.0;\n\tvec3 ph;\n\tfloat r, rc;\n\n\t/// cut city\n\t// rc= -p.y+980.0;\n\t// if( 0.0 < rc )\n\t// \treturn 10.0+rc;\n\n\t/// ground\n\tr= p.z;\n\tmatId= 0;\n\n\t/// some buildings\n\tfor( float a=0.0;a<2.0;a++){\n\t\tph = p;\n\t\tph.xy += 10.0 * a;\n\t\tvec2 idrc= floor((ph.xy-a*200.0) / 20.0);\n\t\tph.xy= mod( ph.xy, 20.0 ) - 10.0;\n\t\t\n\t\tfloat height= 7.0 - a * 3.0 + 10.0*hash12f(idrc);\n\n\t\trc= max( abs(ph.x), abs(ph.y) ) - 7.0;\n\t\trc= max( rc, abs(ph.z) - height );\n\n\t\tif( rc < r ){\n\t\t\tr= rc;\n\t\t\tmatPi= idrc;\n\t\t\tmatId= 1;\n\t\t}\n\t}\n\n\t/// hotel buildings\n\t#ifdef HQ\n\t{\n\t\tph= p;\n\t\tvec2 idrc= floor((ph.xy-2.0) / 80.0);\n\t\tph.xy= mod( ph.xy, 80.0 ) - 40.0;\n\t\tconst float sizeX = 20.0;\n\t\tfloat sizeY= sizeX*(0.1+0.9*hash12f(idrc+0.2));\n\t\tph.xy = rot( ph.xy, hash12f(idrc+0.1) * 2.0 * 3.141592653589 );\n\t\t\n\t\tfloat height= max( 0.0, hash12f(idrc+0.17) * 120.0 - 50.0 );\n\t\t// height /= max( 1.0, p.y*0.0005 );\n\t\theight -= max( 0.0, p.y*0.01);\n\n\t\tph.z -= height;\n\t\trc= max( abs(ph.x), abs(ph.y) ) + 1.0;\n\t\trc= min( rc, max( max( abs(ph.x) - sizeX, abs(ph.y) - sizeY ), ph.z-4.0 ) );\n\t\tif( rc < r ){\n\t\t\tmatPi= idrc;\n\t\t\tr= rc;\n\t\t\tmatId= 2;\n\t\t}\n\n\t\t/// light on top of hotel highest hotels\n\t\tif( 800.0 < p.y \n\t\t\t// && 0.8 < hash12f(idrc+.5) \n\t\t\t&& 40.0 < height\n\t\t\t)\n\t\t\tlightDis.x= min( lightDis.x, length(ph-vec3(0,0,8))*2.0 + 1.0 );\n\n\t\t/// hotel lights\n\t\tconst float lightPower= -1.5;\n\t\tph.x= abs(ph.x);\n\t\tph.y= abs(ph.y);\n\t\tph.z= max( mod( ph.z, 3.0 ), ph.z + 3.0 ) - 1.5;\n\t\t/// side lights\n\t\trc= INF;\n\t\tif( 0.5 < hash12f(idrc+0.3) )\n\t\t\trc= length(ph-vec3(sizeX,0,0))-lightPower;\n\n\t\t/// front-back lights\n\t\tif( 0.5 < hash12f(idrc+0.1) )\n\t\t\tph.x= abs(ph.x)-sizeX/2.0;\n\t\tif( 0.5 < hash12f(idrc+0.2) )\n\t\t\tph.x= abs(ph.x)-sizeX/4.0;\n\t\tif( 0.5 < hash12f(idrc+0.4) )\n\t\t\trc= min(rc,length(ph-vec3(0,sizeY,0))-lightPower);\n\n\t\t/// cut lights\n\t\trc= max( rc, -p.z );\n\t\trc= max( rc, -(p.y-1200.0)-400.0 );\n\t\tlightDis= min( lightDis, rc / vec3(1.0,0.9,0.7) );\n\t}\n\t#endif\n\n\t/// lighting tower\n\t#ifdef HQ\n\t{\n\t\tph= p;\n\t\tph.y -= (3000.0);\n\t\tph.x -= (250.0);\n\t\tfloat l= length(ph.xy);\n\t\tph.z -= 110.0;\n\t\tvec2 h= rot(vec2(l,ph.z),-0.05);\n\t\trc= h.y < 0.0 ? h.x : length(h);\n\t\trc= max( rc, -p.z );\n\t\tph.z += 15.0;\n\t\trc= min( rc, length(ph)-4.0 );\n\t\tph.z -= 6.0;\n\t\trc= min( rc, length(ph)-2.0 );\n\t\tph.z -= 4.0;\n\t\trc= min( rc, length(ph)-1.0 );\n\t\tif( rc < r ){\n\t\t\tr= rc;\n\t\t\tmatId= 3;\n\t\t}\n\t\tlightDis= min( lightDis, rc / vec3(1.0,0.9,0.7) );\n\n\t\t/// non lighting part\n\t\tph.z += 9.5;\n\t\trc= max( length((ph-vec3(0,0,0)).xy)-8.0, abs(ph.z)-2.0 );\n\t\tif( rc < r ){\n\t\t\tr= rc;\n\t\t\tmatId= 4;\n\t\t}\n\t}\n\t#endif\n\n\t/// street lights\n\t{\n\t\tph = p;\n\t\tph.xy -= 10.0;\n\t\tph.z -= 10.0;\n\t\tvec2 idrc= floor((ph.xy+0.69) / 20.0);\n\t\tph.xy= mod( ph.xy, 20.0 ) - 10.0;\n\t\t\n\t\trc= length(ph) + 50.0*( max(0.0, 0.00005*length(p.xy-vec2(0,900))) + hash12f( idrc ) );\n\n\t\trc= max( rc, -(p.y-1200.0)-400.0 );\n\t\trc= max( rc, -p.z-0.1 );\n\n\t\t// const float la= 3.0;\n\t\tlightDis = min( lightDis, \n\t\t\t\trc / vec3(1.0,0.9,0.7) \n\t\t\t\t+ 2.0*vec3(hash12f( idrc+.7 ), hash12f( idrc+.8 ), hash12f( idrc+.9 ))\n\t\t\t);\n\t}\n\n\n\t/// cut whole city\n\t// r= max( r, abs(p.y-1200.0)-400.0 );\n\tr= max( r, -p.y+800.0 );\n\tr= max( r, -p.z-0.1 );\n\n\treturn r;\n}\n\n\n\nvec4 renderCity( vec3 sp, vec3 dir, float maxDistance ){\n\tfloat t= 0.0;\n\tvec3 hp= sp;\n\tfloat dis= mapCity(hp);\n\tbool isHit= false;\n#ifdef HQ\n\tfor( int i=0;i<0x100;i++)\n#else\n\tfor( int i=0;i<0xE0;i++)\n#endif\n\t{\n\t\tt += dis;\n\t\thp = sp + t * dir;\n\t\tdis= mapCity(hp);\n\t\tif( maxDistance < t ){\n\t\t\tbreak;\n\t\t}else if( dis < EC ){\n\t\t\tisHit= true;\n\t\t\tif( 0.0 < dis )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif( isHit ){\n\t\t/// normal\n\t\t//vec3 nor= normalize(vec3(\n\t\t//\tmapCity(vec3(hp.x+EC,hp.y,hp.z))-mapCity(vec3(hp.x-EC,hp.y,hp.z)),\n\t\t//\tmapCity(vec3(hp.x,hp.y+EC,hp.z))-mapCity(vec3(hp.x,hp.y-EC,hp.z)),\n\t\t//\tmapCity(vec3(hp.x,hp.y,hp.z+EC))-mapCity(vec3(hp.x,hp.y,hp.z-EC)) \n\t\t//));\n  \t\tvec3 nor= vec3( 0 );\n\t\tfor( int i=min( iFrame, 0 ); i<4; i++){\n\t\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\t\tnor += e * mapCity( hp + e*EC );\n\t\t}\n        nor= normalize( nor );\n\n\t\t/// look straight in to light\n\t\tif( matId==3){\n\t\t\treturn vec4(1,1,1,t);\n\t\t}\n\n\t\t/// material\n\t\tvec3 baseColor= vec3(.3,.4,.5);\n\t\tswitch( matId ){\n\t\t\tcase 0:\n\t\t\t\tbaseColor= vec3(.3,.4,.5);\n\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbaseColor= vec3(.2) * (0.25 + 0.5*hash12f( matPi ));\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t/// hotel\n\t\t\t\t// baseColor= vec3(.5,.5,.9);\n\t\t\t\t// baseColor= vec3(.4,.4,.5);\n\t\t\t\t// baseColor= vec3(.31,.33,.4);\n\t\t\t\tbaseColor= vec3(.1,.1,.12);\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t/// lighitng tower dark part\n\t\t\t\tbaseColor= vec3(.2);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbaseColor= vec3(.3,.4,.5);\n\t\t\tbreak;\n\t\t}\n\n\t\t/// final color\n\t\treturn vec4( \n\t\t\tbaseColor\n\t\t\t\t* clamp(0.9 + 0.1 * dot( nor, -dir ), 0.0, 1.0 )\n\t\t\t\t// * clamp(0.5 + 0.5 * dot( nor, -dir ), 0.0, 1.0 )\n\n\t\t\t\t// * clamp( pow( 400.0 / max(1.0,t-1700.0), 2.0), 0.0, 1.0 )\n\t\t\t\t* clamp( pow( 800.0 / max(1.0,t-400.0), 2.0), 0.0, 1.0 )\n\n\t\t\t\t* ( .8 + .2 * fbm( hp * .2, 7) )\n\t\t\t\t* .5\n\t\t\t,\n\t\t\tt );\n\t}else{\n\t\t/// not city\n\t\treturn vec4(0,0,0,INF);\n\t}\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n//void main()\n{\n    /// optimisation for shadertoy.com\n    if(iFrame!=0){\n        fragColor= texture(iChannel0,fragCoord / iResolution.xy);\n        return;\n    }\n    \n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);uv.x *= iResolution.x / iResolution.y;\n\n\tvec3 dir= normalize( vec3( uv.x, uv.y, -4.0 ) );\n\tdir.yz = rot( dir.yz, 1.6 );\n\tdir.xy = rot( dir.xy, -0.17 );\n\t// dir.xy = rot( dir.xy, -0.75 );\n\t\n\tvec3 sp= vec3(-15,-42,1.6);\n\t// vec3 sp= vec3(-15,-42,2.9);\n\t// vec3 sp= vec3(-20,-22,1.6);\n\n\t/// rotate whole scene\n\t// float l= iTime*.1;\n\t// sp.xy = rot( sp.xy, l );\n\t// dir.xy = rot( dir.xy, l );\n\n\t/// start rendering\n\tvec4 r;\n\t\n\t/// sky color\n\t{\n\t\t// float l= atan( dir.x, dir.y );\n\t\tfloat l= atan( dir.x );\n\t\tfloat z= dir.z;\n\t\tconst float zm= 0.04;\n\t\t// r.b = 0.5 + 0.5*sin(l*100.0);\n\t\tr.xyz = vec3(.1,.1,.7);\n\t\tif( 0.040*fbm(8.0*vec3(dir.xy,0.0),6) + clamp(0.7*(abs(dir.y)-1.0),-0.1,0.1) < dir.z - zm  ){\n\t\t\t/// sky color\n\t\t\tvec3 col1= vec3(.5,.6,.7);\n\t\t\tvec3 col2= vec3(.8,.8,.9);\n\t\t\tvec3 dir2= dir / dir.z;\n\t\t\tr.xyz = mix(\n\t\t\t\tcol1,\n\t\t\t\tcol2,\n\t\t\t\t(0.5+0.5*fbm( dir2, 5 )) );\n\t\t\t/// mipmaping :D\n\t\t\tr.xyz = mix( r.xyz, (col1+col2)/2.0, clamp(length(dir2)/300.0,0.0,1.0) ) * 0.15;\n\t\t}else{\n\t\t\t/// mountain color\n\t\t\tr.xyz = mix( \n\t\t\t\tvec3(.02,.02,.10),\n\t\t\t\tvec3(.03,.04,.15),\n\t\t\t\tfbm(50.0*dir,3) );\n\t\t}\n\t\tr *= clamp( 16.0*(dir.z-zm)+1.0, 0.0, 1.0 );\n\t\tr.w = INF - 1.0;\n\t}\n\n\t/// render temple\n\t{\n\t\tvec4 rc= renderTemple( sp, dir );\n\t\tif( rc.w < r.w ){\n\t\t\tr= rc;\n\t\t}\n\t}\n\n\t/// render city\n\t{\n\t\tvec4 rc= renderCity( sp, dir, r.w );\n\t\tif( rc.w < r.w ){\n\t\t\tr= rc;\n\t\t}\n\t}\n\n\t/// render trees\n\t{\n\t\tvec4 rc= renderTrees( sp, dir );\n\t\tif( rc.w < r.w ){\n\t\t\tr= rc;\n\t\t\t///@warning trees are unaffected by light\n\t\t\tlightDis= vec3(INF);\n\t\t}\n\t}\n\n\t/// add light\n\t{\n\t\t// lightDis= max( vec3(0.01), lightDis );\n\t\t// vec3 lightPower= 1.5 / lightDis - 1.0 / 20.0;\n\t\t// r.xyz = clamp(r.xyz + clamp( lightPower, 0.0, 1.0 ), 0.0, 1.0 );\n\t\t// r.xyz += max( lightPower, 0.0 );\n\t\t// r.xyz += max( 1.5 / max( vec3(0.01), lightDis ) - 1.0 / 20.0, 0.0 );\n\t\tr.xyz += clamp( 1.5 / lightDis - 1.0 / 20.0, 0.0, 1.0 );\n\t}\n\n\t/// postprocessing light up\n\tr.x= pow( r.x, POSTPROCESSING_POW );\n\tr.y= pow( r.y, POSTPROCESSING_POW );\n\tr.z= pow( r.z, POSTPROCESSING_POW );\n\n\t/// apply final result\n\tfragColor.xyz= r.xyz;\n}\n\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/\n","name":"Buffer A","description":"","type":"buffer"}]}