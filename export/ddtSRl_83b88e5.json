{"ver":"0.1","info":{"id":"ddtSRl","date":"1680278283","viewed":102,"name":"Пельмени","username":"busybeaver","description":"Пельмени (pelmeni) is a Russian food. It's like dumplings with meet inside. Rendering is based on ray marching. But for flat surfaces ray casting is used to gain more performance.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dumplings"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define min(x, y) ((x) > (y) ? (y) : (x))\n#define max(x, y) ((x) > (y) ? (x) : (y))\n#define pi 3.1415926\n#define e 2.7182818\n#define iters 160\n#define floor_height -1.6\n#define water_height 1.\n\nfloat x0 = 2. + sqrt(5.);\nfloat y0 = 5. + 2. * sqrt(5.);\nfloat y02 = 45. + 20. * sqrt(5.);\n\nfloat connect(in float a, in float b, in float k) {\n    if(abs(a - b) > x0 * k) return min(a, b);\n    float c = (abs(a - b) / k - x0);\n    return (min(a, b) - k * (y0 - sqrt(y02 - c*c)));// - k * pow(e, - ((abs(a-b)+4.)*(abs(a-b)+4.) - 16.) / (16. * k));\n}\n\nfloat dist_default(in vec3 d) {\n    if(length(d) > 2.5) {\n        return length(d) - 1.7;\n    }\n    float r = length(d.xz);\n    float l1 = length(d * vec3(0.8, 1., 0.8)) - 0.93 + (sin(d.x * 10.) * 0.007 + cos(d.z * 8.) * 0.015) * (1.5 - r) + smoothstep(1., .0, r) * 0.15;\n    vec3 d2 = vec3(d.x, sin(d.x * 10.) * 0.02 + cos(d.z * 12.) * 0.015, d.z);\n    vec3 d3 = normalize(d2);\n    float l2 = length(d - vec3(min(d3.x, 1.), d3.yz) * min(length(vec3(min(d2.x, 1.), d2.yz)), 1.6)) - (0.07 + sin(d.x * 16.) * 0.006 + smoothstep(0.8, 1., d.x) * 0.022);\n    //float f = atan((l1 - l2) * 5.) / pi;\n    //return l1 * (.5 - f) + l2 * (.5 + f);\n    return connect(l1 * 1.05, l2 * .85, .04);\n}\n\nfloat dist_moved(in vec3 d, in vec3 zero, in vec3 x, in vec3 y, in vec3 z) {\n    d -= zero;\n    d = d.x * x + d.y * y + d.z * z;\n    return dist_default(d);\n}\n\nvec2 rotate(in vec2 v, float a) {\n    vec2 x = vec2(cos(a), sin(a));\n    return x * v.x + vec2(-x.y, x.x) * v.y;\n}\n\nvec3 rot(in vec3 v, in float a_xy, in float a_zy, in float a_xz) {\n    v.xz = rotate(v.xz, a_xz);\n    v.zy = rotate(v.zy, a_zy);\n    v.xy = rotate(v.xy, a_xy);\n    return v;\n}\n\nfloat dist(in vec3 d, out vec3 col) {\n    vec3 x = vec3(1., 0., 0.), y = vec3(0., 1., 0.), z = vec3(0., 0., 1.);\n    float a1_xy = 0., a1_zy = 0., a1_xz = 0.;\n    float d1 = dist_moved(d, vec3(.1, 1., 0.), rot(x, a1_xy, a1_zy, a1_xz), rot(y, a1_xy, a1_zy, a1_xz), rot(z, a1_xy, a1_zy, a1_xz));\n    float d2 = 1000.;\n    for(float a = 0.; a < pi * 2.; a += pi * 2. / 5.) {\n        float a2_xy = 0.3 * sign(pi - a), a2_zy = .0, a2_xz = 0. - a * .93 + (a > pi ? pi: 0.);\n        float r = 2.63 + (a > pi ? 0.: .18);\n        d2 = min(dist_moved(d, vec3(cos(a) * r, .95 - (a > pi ? 0.: .13), sin(a) * r), rot(x, a2_xy, a2_zy, a2_xz), rot(y, a2_xy, a2_zy, a2_xz), rot(z, a2_xy, a2_zy, a2_xz)), d2);\n    }\n    d.y -= 2.5;\n    float bowl_d = length(d - normalize(vec3(d.x, min(d.y, -.6), d.z)) * 4.6) - 0.1;\n    float d3 = length(d) > 4.6 ? length(vec3(abs(d.x), d.yz) - normalize(vec3(abs(d.x), d.y, 0.) - vec3(3.8, -2.2, 0.)) * 1.3 - vec3(3.8, -2.2, 0.)) - .25 : 100.;\n    col = min(d1, d2 * .9) < bowl_d ? vec3(.8, .76, .65) : vec3(.9, .55, .35);\n    return connect(min(min(d1, d2), bowl_d * .95), d3 * .99, .03);\n    //col = vec3(.9);\n    return d3;\n}\n\nfloat water_dist(in vec3 d, in vec3 ray) {\n    if(length(d.xz + ray.xz * (water_height - d.y) / ray.y) < 4.4 && ray.y * (d.y - water_height) < 0.) {\n        return (water_height - d.y) / ray.y;\n    }\n    return 1000.;\n}\n\nfloat dist(in vec3 d) {\n    vec3 col;\n    return dist(d, col);\n}\n\nvec3 grad(in vec3 d) {\n    float delta = 0.001;\n    float def = dist(d);\n    return vec3(\n        dist(d + vec3(delta, 0., 0.)) - def,\n        dist(d + vec3(0., delta, 0.)) - def,\n        dist(d + vec3(0., 0., delta)) - def\n    ) / delta;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ray = normalize(vec3(cos(iTime), 1., sin(iTime)) * pos.xyx + vec3(-sin(iTime), sin(iTime / pi) * 0.3 - 0.7, cos(iTime)) * 1.4);\n    vec3 col = vec3(1.);\n    vec3 d = vec3(sin(iTime), 0.65 - sin(iTime / pi) * 0.3, -cos(iTime)) * 14.;\n    float underwater = 0.;\n    vec3 smoothlight = vec3(0.);\n    for(int i = 0; i < iters; i ++) {\n        //ray = normalize(ray);\n        vec3 col_k;\n        float l0 = dist(d, col_k);\n        float l1 = min(l0, (d.y - floor_height) / abs(ray.y));\n        float l2 = water_dist(d, ray) + .00004;\n        if(l2 < l1) {\n            d += ray * l2;\n            if(underwater > 0.) col *= pow(.9, l2);\n            smoothlight += l2 * underwater * col;\n            if(length(ray.xz) * (ray.y > 0. ? 1.5 : .66666) > 1.) {\n                ray.y = -ray.y;\n                d += ray * .00006;\n            } else {\n                underwater = ray.y < 0. ? .16 : 0.;\n                ray.xz *= ray.y > 0. ? 1.5 : .66666;\n                ray.y = sqrt(1. - ray.x * ray.x - ray.z * ray.z) * sign(ray.y);\n                bool k = (sin(d.x * 8.) + sin(d.z * 8.) + sin((d.x + d.z) * 2.5) + cos(d.x * 2.7 - d.z * 3.6) > 0.5);\n                col *= k ? vec3(.8, .8, .0) : vec3(.7);\n                if(k) smoothlight += vec3(0.12, 0.12, 0.) * col;\n            }\n        } else {\n            d += ray * min(l1, l2);\n            smoothlight += underwater * min(l1, l2) * col;\n            if(underwater > 0.) col *= pow(.85, min(l1, l2));\n        }\n        if(l0 < 0.01) {\n            vec3 g = normalize(grad(d));\n            if(dot(g, ray) < 0.) {\n                ray -= dot(ray, g) * g * 2.;\n                col *= col_k;\n            }\n        }\n        if(length(d) > 100. || i == iters - 1 || length(col) < .1) {\n            col *= ray * vec3(.2, .4, .2) + vec3(.8, .6, .8) + vec3(sin(ray.x * 24.) > 0. ? .0:.2, sin(ray.y * 12.) > 0. ? .0:.1, sin(ray.z * 6.) > 0. ? .0:.2);\n            break;\n        }\n        if(d.y < floor_height + .001) {\n            col *= .7;\n            ray.y = abs(ray.y);\n            d.y = floor_height + .001;\n        }\n    }\n    fragColor = vec4(col + smoothlight,1.0);\n}","name":"Image","description":"","type":"image"}]}