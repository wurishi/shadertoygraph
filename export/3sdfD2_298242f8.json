{"ver":"0.1","info":{"id":"3sdfD2","date":"1606055765","viewed":47,"name":"bg test 2","username":"tsmca","description":"fork of https://www.shadertoy.com/view/ltdSz4\n\nbackground test 2\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dagda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://www.shadertoy.com/view/ltdSz4\n// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nstruct vec5 {\n    vec4 a;\n    float v;   \n};\n    \nvec5 plane5(vec5 origin, vec5 u, vec5 v, vec2 p){\n\treturn vec5(origin.a + p.x*u.a + p.y*v.a,\n                origin.v + p.x*u.v + p.y*v.v);\n}\n\nvec5 mult5(vec5 p, float multiplier) {\n    p.a *=  multiplier;\n    p.v *= multiplier;\n    return p;\n}\n\nvec5 mod5(vec5 p, float m) {   \n return vec5(mod(p.a,m),mod(p.v,m));   \n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool dualTileZoneTest(vec5 p , float value){\n    bool down  = all(lessThanEqual(vec4(value),p.a)) && value <= p.v && all(lessThanEqual(vec4(value),vec4(1.0)-p.a)) && value <= (1.0-p.v);\n    bool up  = all(greaterThanEqual(vec4(value),p.a)) && value >= p.v && all(greaterThanEqual(vec4(value),vec4(1.0)-p.a)) && value >= (1.0-p.v);\n    return down || up;\n}\n\nvec3 pattern(vec5 p ){\n    \n    float hueDelta = 16.0/24.0;\n    \n    p = mod5(p,1.0);\n    \n    if(dualTileZoneTest(p , p.a.x)){\n        return  hsv2rgb(vec3(0.45, 0.7, 0.75));\n    }\n    else if(dualTileZoneTest(p,  p.a.y)){\n         return hsv2rgb(vec3(0.5, 0.9,1.));\n    }\n    else if(dualTileZoneTest(p, p.a.z)){\n         return hsv2rgb(vec3(0.46, 0.7, 0.95));\n    }\n    else if(dualTileZoneTest(p, p.a.w)){\n         return hsv2rgb(vec3(0.45, 0.5, 0.7));\n    }\n    else if(dualTileZoneTest(p,  p.v)){\n     \n         return hsv2rgb(vec3(0.5,0.7, 0.6));\n    }\n    else {\n          return vec3(0.0);\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float time = 0.02*iTime;\n    \n    //This is the origin of our plane in 5d space.\n   \t//vec5 origin = vec5(vec4(0.1*time),time);\n    vec5 origin = vec5(vec4(time),-time);\n  \t\n    //We need two directions to form a plane.\n    //In 3d we can define a plane from a point on the plane (the origin) and a normal, using the cross product to find our two directions.\n    \n    //But this won't work in 5d. There is no cross product!\n   \t//There are many plane normal to vector, becasue there are four directions normal to a given vector. \n    //This is why there is no cross product in higher dimensions!\n    \n    //In analogy with the 3d case, we get interesting patterns in a plane normal to (1,1,1,1,1). (the long diagonal of a hypercube.)\n    //We can find a set of four vectors normal to (1,1,1,1,1) using the Gram Schmidt process\n    //https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    //Any two will do:\n    \n    vec5 u = vec5(vec4(-0.511667,0.19544,0.19544,-0.511667)*scale,0.632456*scale) ;\n    vec5 v = vec5(vec4(-0.371748,0.601501,-0.601501,0.371748)*scale, 0.0*scale);\n    \n    vec5 plane = plane5(origin,u,v,p);\n    plane = mult5(plane,5.0);\n    \n    //Now we have mapped points in the image plane to 5d space we can color pixels based on whe=re thy are in 5d. \n    //We divide the space into a 5d lattice of hypercubes. For each point we find the closest face in the hypercube.\n    //We pair opposite faces to get 5 colors, corresponding to the 5 dimensions.\n    vec3 color = pattern(plane);\n    \n    fragColor =  vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}