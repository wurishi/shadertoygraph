{"ver":"0.1","info":{"id":"ftlXD4","date":"1625710281","viewed":120,"name":"20210708_slerpUniformVec3","username":"FMS_Cat","description":"Describe your shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(i) clamp((i),0.,1.)\n\nconst float PI = acos( -1.0 );\nconst float TAU = 2.0 * PI;\n\n/**\n * Spherical lerp between a and b.\n * a and b must be normalized.\n */\nvec3 slerpUniformVec3( vec3 a, vec3 b, float t ) {\n  // early abort if t is exactly zero or one\n  if ( t == 0.0 ) { return a; }\n  if ( t == 1.0 ) { return b; }\n  \n  // ss for a, st for b\n  // ( ss + st ) can be like 1.414 (when the angle between a and b is 90 deg and t is 0.5)\n  float ss;\n  float st;\n  \n  float cosv = dot( a, b );\n  \n  if ( cosv > 1.0 - 1E-4 ) {\n    // avoid precision funny, just lerp it\n    st = t;\n    ss = 1.0 - t;\n  } else {\n    // do the proper slerp\n    float sinv = sqrt( 1.0 - cosv * cosv );\n    float theta = acos( cosv );\n\n    ss = sin( ( 1.0 - t ) * theta ) / sinv;\n    st = sin( t * theta ) / sinv;\n  }\n  \n  return ss * a + st * b;\n}\n\n/**\n * SDF of capsule.\n * See: https://iquilezles.org/articles/distfunctions/distfunctions.htm\n */\nfloat sdcapsule( vec3 p, vec3 tail ) {\n  float h = saturate( dot( p, tail ) / dot( tail, tail ) );\n  return length( p - tail * h );\n}\n\nfloat map( vec3 p, out vec3 diffuseColor ) {\n  vec3 a = normalize( vec3( 1.0, 1.0, 1.0 ) );\n  vec3 b = normalize( vec3( -1.0, 0.0, 0.0 ) );\n  float t = 0.5 + 0.5 * sin( iTime );\n\n  vec3 tail = mix( a, b, t );\n  float d = sdcapsule( p, tail ) - 0.1;\n  diffuseColor = vec3( 1.0, 0.0, 0.0 );\n\n  tail = slerpUniformVec3( a, b, t );\n  float d2 = sdcapsule( p, tail ) - 0.1;\n  if ( d2 < d ) {\n    d = d2;\n    diffuseColor = vec3( 0.0, 1.0, 0.0 );\n  }\n\n  return d;\n}\n\nvec3 nmap( vec3 p ) {\n  vec2 d = vec2( 0.0, 1E-3 );\n  vec3 _;\n  return normalize( vec3(\n    map( p + d.yxx, _ ) - map( p - d.yxx, _ ),\n    map( p + d.xyx, _ ) - map( p - d.xyx, _ ),\n    map( p + d.xxy, _ ) - map( p - d.xxy, _ )\n  ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 p = uv * 2.0 - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  vec3 col = vec3( 0.8 );\n\n  vec3 ro = vec3( 0.0, 0.0, 2.0 );\n  vec3 rd = normalize( vec3( p, -1.0 ) );\n  \n  float rl = 1E-2;\n  vec3 rp = ro + rd * rl;\n  float dist;\n  vec3 diffuseColor;\n  \n  for ( int i = 0; i < 64; i ++ ) {\n    dist = map( rp, diffuseColor );\n    rl += dist;\n    rp = ro + rd * rl;\n  }\n  \n  if ( dist < 1E-2 ) {\n    vec3 N = nmap( rp );\n    const vec3 L = normalize( vec3( 1.0 ) );\n    float halfLambert = 0.5 + 0.5 * dot( N, L );\n    \n    // Gooch shading\n    col = (\n      0.5 * halfLambert * diffuseColor +\n      0.5 * mix( vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 1.0, 0.0 ), halfLambert )\n    );\n  }\n  \n  fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}