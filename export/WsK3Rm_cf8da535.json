{"ver":"0.1","info":{"id":"WsK3Rm","date":"1569921360","viewed":220,"name":"Art of the Copy","username":"rmmcal","description":"Joining some shaders... and adding a little more of \"art\"... \n- @iq       > https://www.shadertoy.com/view/3lsSzf\n- @nimitz > https://www.shadertoy.com/view/3l23Rh\n- @mattz  > https://www.shadertoy.com/view/XsVcDy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","text"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////\n//\n// by @rmmcal (2019/10)  \n// \n// => https://creativecommons.org/licenses/\n//\n// fork/links/inspired/references:\n// - @iq\t > https://www.shadertoy.com/view/3lsSzf\n// - @nimitz > https://www.shadertoy.com/view/3l23Rh\n// - @mattz  > https://www.shadertoy.com/view/XsVcDy\n//\n///////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////\n// main fork from: \n// => https://www.shadertoy.com/view/3lsSzf\n//////\n\n\n//\n// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// An animation test - a happy and blobby creature jumping and\n// looking around. It gets off-model very often, but it looks\n// good enough I think.\n//\n// Making of and related math/shader/art explanations (6 hours\n// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\n// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ\n\n\n#if HW_PERFORMANCE==1\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// https://iquilezles.org/articles/smin\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n/////////////////////////////////////////\n\n/* \"glyphspinner\" by mattz\n   License: https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   I've been carrying this shader in my head for a long time, \n   glad I finally had some time to work on it!\n\n   Towards the end of developing a shader, I'm always pleased\n   if I realize I've zoned out watching it run instead of \n   putting the finishing touches on it, which certainly was\n   the case here.\n\n   Since I couldn't get the glyph edges nicely antialiased, \n   I decided to leave the backgrounda  bit rough, too, which\n   you can see if you pause the shader. \n\n*/\n\n//#\n\n// texture is 1024x1024\nconst float TEX_RES = 1024.;\n// texture is 16x16 glyphs\nconst float GLYPHS_PER_UV = 16.;\n// since the texture is uint8 it has a bias to represent 0\nconst float TEX_BIAS = 127./255.;\n\n// get font UV coords from screen coords\nvec2 font_from_screen(vec2 tpos, vec2 char_pos) {    \n    return (tpos + char_pos + 0.5)/GLYPHS_PER_UV;\n}\n\nfloat sample_dist_gaussian(vec2 uv) {\n\n    float dsum = 0.;\n    float wsum = 0.;\n    \n    const int nstep = 3;\n    \n    const float w[3] = float[3](1., 2., 1.);\n    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            \n            vec2 delta = vec2(float(i-1), float(j-1))/TEX_RES;\n            \n            float dist = textureLod(iChannel0, uv-delta, 0.).w - TEX_BIAS;\n            float wij = w[i]*w[j];\n            \n            dsum += wij * dist;\n            wsum += wij;\n\n        }\n    }\n    \n    return dsum / wsum;\n}\nfloat approx_font_dist(vec2 p, int cidx) {\n\n    float d = max(abs(p.x) - 0.25,\n                  max(p.y - 0.3, -0.28 - p.y));\n    \n    vec2 cpos = vec2(float(cidx%16), float(15-cidx/16));\n    vec2 uv = font_from_screen(p, cpos);\n    \n    float fd = sample_dist_gaussian(uv); \n        \n    \n    d = max(d, fd);\n        \n    \n    return d;\n    \n}\n\n/////////////////////////////////////////\n\n// Utilities\nfloat udBox(vec3 p, vec3 s) { return length(max(abs(p)-s,0.0)); }\n\nfloat char(vec3 p , int c, vec3 t){\n   // return texture(iChannel0,p.xy).z;\n     return max(( approx_font_dist(p.xy-t.xy, c)),udBox(p-t,vec3(1.,1.,.05)));\n}\nfloat sceneText1(vec3 p)\n{\n    p *= .5;\n    float d = 100.;\n    d = min(d, char(p, 65, vec3(-0.4,0.,0.)));\n    d = min(d, char(p, 82, vec3(-0.0,0.,0.)));\n    d = min(d, char(p, 84, vec3(+0.35,0.,0.)));\n\treturn d;\n}\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n//  map scene !!!!\nvec4 map( in vec3 pos, float atime )\n{\n    vec3 cen = vec3( 0.,0.5,  (atime)  -0.0 );\n\tvec3 q = pos - cen - vec3(0., 0., -0.);\n\tfloat v = 100.;\n    \n\tfloat loop = abs(2.*fract(atime)-1.);\n    float loop1 = loop;\n    float loop2 = abs(2.*fract(atime+.5)-1.);\n  \n\tvec3 bu = vec3(+loop2*.2-.1,0.,0.)*.5;\n\tv = smin( v, sdEllipsoid( q-bu- vec3(-.2, 0.+loop1*.05, -0.2), vec3(0.25) ),1.0);\t\n\tv = smin( v, sdEllipsoid( q-bu- vec3(+.2, 0.+loop2*.05, -0.2), vec3(0.25) ),.1);\t\n\t\n\tvec3 troco = vec3(0.+loop-.5,0.1,-0.);\n\tvec3 bMtroco = vec3(0. +(loop2-.5)*.03   ,0.1,-0.)+bu*1.4;\n\tvec3 bMtrocoBarr = bMtroco+vec3(0.,0.05,-0.)-bu*1.4;\n\t\n    v = smin( v, sdStick( q, bMtroco+vec3(0.,0.0,-0.), vec3(0.0,1.0,-.1), 0.1, 0.25 ).x, .1);\t\n\tv = smin( v, sdStick( q, bMtrocoBarr, vec3(0.0,.3,.0), 0.21, 0.25 ).x, .2);\t\n\tv = smin( v, sdStick( q, vec3(0.,1.2,-.2), vec3(0.0,1.4,-.2), 0.01, 0.1 ).x, .2);\t\n\tv = smin( v, sdEllipsoid( q- vec3(0.0, 1.6, -0.2), vec3(0.21) ),.04);\t\n\tvec3 bPei = vec3(-.0, 1., 0.08);\n\t\n    vec3 bLPei = bPei+vec3(-.15, 0.+loop1*.02, 0.0);\n\tvec3 bRPei = bPei+vec3( .15, 0.+loop2*.02, 0.0);\n\t\n    v = smin( v, sdEllipsoid( q- bLPei, vec3(0.13,0.16,0.15)*.9 ),.061);\t\n\tv = smin( v, sdEllipsoid( q- bRPei, vec3(0.13,0.16,0.15)*.9 ),.061);\t\n\t\n    v = smax( v, -sdStick( q, vec3(0.,-0.2,0.0), vec3(0.0,0.4,.5), 0.01, 0.2 ).x,.4);\t\n\n    v = smax( v, -sdStick( q, vec3(0.,0.31,-0.01)+bu, vec3(0.0,0.4,1.5), 0.002, 0.01 ).x,.1);\t\n\n    v = smin( v, sdEllipsoid( q- vec3(-.10, 1., -0.17), vec3(0.19) ),.03);\t\n\tv = smin( v, sdEllipsoid( q- vec3(+.10, 1., -0.17), vec3(0.19) ),.03);\t\n\t\n\t\n    v = smin( v, sdStick( q, vec3( 0.2,-0.2,-0.), vec3( 0.2,-.7,.0+loop1*.4-.2), 0.11, 0.15 ).x, .2);\t\n\tv = smin( v, sdStick( q, vec3(-0.2,-0.2,-0.), vec3(-0.2,-.7,.0+loop2*.4-.2), 0.11, 0.15 ).x, .2);\t\n\t\n    vec3 bArm = vec3(-0.,1.,-0.22);\n\tvec3 mCos = vec3(0.00,0.,-0.02);\n\n    vec3 bSRight = bArm+vec3( -0.25,0.,-0.)+loop1*.05;\n\tvec3 bMRight = bSRight+vec3( -0.2,-0.4,.0);\n\tvec3 bERight = bMRight+vec3(-0.,-0.2,-.0);\n\tv = smin( v, sdStick( q, bSRight, bMRight, 0.15, 0.05 ).x, .06);\t\n\tv = smin( v, sdStick( q, bMRight+mCos, bERight, 0.07, 0.05 ).x, .1);\t\n\t\n\t\n    vec3 bSLeft = bArm+vec3( 0.25,0.,-0.)+loop2*.05;\n\tvec3 bMLeft = bSLeft+vec3( 0.2,-0.4,.0);\n\tvec3 bELeft = bMLeft+vec3(0.,-0.2,-.0);\n\tv = smin( v, sdStick( q, bSLeft, bMLeft, 0.15, 0.05 ).x, .06);\t\n\tv = smin( v, sdStick( q, bMLeft+mCos, bELeft, 0.07, 0.05 ).x, .1);\t\n\t\n    v = smax( v, q.y-1.35,.01);\t\n\n\t\n\n\tfloat lop = abs(2.*fract(atime/30.)-1.) ;\n\tlop = smoothstep (0., 1., lop) ;\n\tlop = smoothstep (0., 1., lop) ;\n\tlop = smoothstep (0., 1., lop) ;\n\tlop = smoothstep (0., 1., lop) ;\n\t\n\tv = v*lop+sceneText1(q)*(1.-lop);\n\t\n\t/////////////////\n\t\n\tvec4 res = vec4( v, 2.0, 0.0, 1.0 );\n\t\n    // \n    float d = pos.y;\n    d -=  0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n\tif( d<res.x ) res = vec4(d,1.0,0.0,1.0);\n   \t\n    float v0 = sdEllipsoid( q- vec3(0.,0.,0.) , vec3(1.5) ) ;\n\tif( d<v0 ) res = vec4(v0,1.0,0.0,1.0);\n    \n    \n    return res;\n}\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n//////////////////////////////////////////////////////////\n// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map1(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render1( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map1(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map1(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map1(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render1(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}\n//////////////////////////////////////////////////////////\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t// footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.5,0.5,0.4), mark );\n            ks *= 1.0-0.5*mark;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\telse{\n\t\tvec4 co = vec4(0.);\n\t\tmainImage1(co, gl_FragCoord.xy);\n\t\tcol = co.xyz;\n\t}\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime*1.+3.+iMouse.x*.1;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        /**\n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\t\t/**/\n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 8.7*sin(0.10*time);\n\t\t \n\t\t \n\t\tan = 0.40*time*1.0+1.3;\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 );\n        vec3  ro = ta + vec3( 4.3*cos(an), 1.350, 4.3*sin(an) );\n\t\t\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        ////////////////////////\n        \n\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n   \n    // output    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}