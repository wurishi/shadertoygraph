{"ver":"0.1","info":{"id":"WdyXDR","date":"1573766290","viewed":797,"name":"Hyperspace Tunnel, with Twirl","username":"blue_max","description":"Based on theGiallo's tunnel shader and Dave_Hoskins' noise shader. I've tweaked it quite a bit to make it looks like the blue hyperspace tunnel in Star Wars. Also added contributions from keiranhalcyon7. Use the mouse to look around.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","hyperspace","starwars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contributions made by keiranhalcyon7\n// Based on theGiallo's https://www.shadertoy.com/view/MttSz2\n// MIT License. Use freely; but attribution is expected.\n#define TAU 6.28318\nconst float period = 1.; //3.7;\nconst float speed  = 2./1.;\nconst float rotation_speed = 2.5/1.;\nconst float t2 = 4.0; // Length in seconds of the effect\n\n// This effect fades in and out of white every t2 seconds\n// Remove the next def to get an infinite tunnel instead.\n//#define WHITEOUT 1\n\n// Perlin noise from Dave_Hoskins' https://www.shadertoy.com/view/4dlGW2\n//----------------------------------------------------------------------------------------\nfloat Hash(in vec2 p, in float scale)\n{\n\t// This is tiling part, adjusts with the scale...\n\tp = mod(p, scale);\n\treturn fract(sin(dot(p, vec2(27.16898, 38.90563))) * 5151.5473453);\n}\n\n//----------------------------------------------------------------------------------------\nfloat Noise(in vec2 p, in float scale )\n{\n\tvec2 f;\n\tp *= scale;\n\tf = fract(p);\t\t// Separate integer from fractional\n    \n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\t// Cosine interpolation approximation\n\t\n    float res = mix(mix(Hash(p, \t\t\t\t scale),\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0), scale), f.x),\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0), scale),\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0), scale), f.x), f.y);\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nfloat fBm(in vec2 p)\n{\n    //p += vec2(sin(iTime * .7), cos(iTime * .45))*(.1) + iMouse.xy*.1/iResolution.xy;\n\tfloat f = 0.0;\n\t// Change starting scale to any integer value...\n\tfloat scale = 40.0;\n    p = mod(p, scale);\n\tfloat amp   = 0.6;\n\t\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += Noise(p, scale) * amp;\n\t\tamp *= 0.5;\n\t\t// Scale must be multiplied by an integer value...\n\t\tscale *= 2.0;\n\t}\n\t// Clamp it just in case....\n\treturn min(f, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, t2);\n    t = t / t2; // Normalized time\n    \n    vec4 col = vec4(0.0);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p += vec2(0.0, -0.1);\n    \n    //float ay = TAU * mod(iTime, 8.0) / 8.0;\n    //ay = 45.0 * 0.01745;\n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    mat3 m = mX * mY;\n    \n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    float v_xy = length(v.xy);\n    float z = v.z / v_xy;\n    \n    // The focal_depth controls how \"deep\" the tunnel looks. Lower values\n\t// provide more depth.\n\tfloat focal_depth = 0.15;\n    #ifdef WHITEOUT\n    focal_depth = mix(0.15, 0.015, smoothstep(0.65, 1.0, t));\n    #endif\n    \n    vec2 polar;\n    //float p_len = length(p);\n    float p_len = length(v.xy);\n    //polar.y = focal_depth / p_len + iTime * speed;\n    polar.y = z * focal_depth + iTime * speed;\n    float a = atan(v.y, v.x);\n    a -= iTime * rotation_speed;\n    float x = fract(a / TAU);\n    polar.y /= 3.0;\n    polar.x = x * period + polar.y;\n    \n    \n    // Colorize blue\n    //col = texture(iChannel1, cp);   \n    float val = fBm(polar);\n    col.rgb = vec3(0.15, 0.4, 0.9) * vec3(val)*1.3;\n    \n    // Add white spots\n    vec3 white = 0.5 * vec3(smoothstep(.8, 1.0, val));\n    col.rgb += white;\n    \n    float w_total = 0.0, w_out = 0.0;\n    #ifdef WHITEOUT\n    // Fade in and out from white every t2 seconds\n    float w_in = 0.0;\n    w_in = abs(1.0 - 1.0 * smoothstep(0.0, 0.25, t));\n    w_out = abs(1.0 * smoothstep(0.8, 1.0, t));\n    w_total = max(w_in, w_out);\n    #endif\n    \n    \n    // Add the white disk at the center\n    float disk_size = max(0.025, 0.5 * w_out);\n    //float disk_size = 0.11;\n    float disk_col = exp(-(p_len*1.5 - disk_size) * 2.);\n    //col.rgb += mix(col.xyz, vec3(1,1,1), disk_col);\n    col.rgb += vec3(disk_col, disk_col, disk_col);\n    \n    \n    #ifdef WHITEOUT\n    col.rgb = mix(col.rgb, vec3(1.0), w_total);\n    #endif\n    \n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}