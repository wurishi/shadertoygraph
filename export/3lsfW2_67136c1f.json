{"ver":"0.1","info":{"id":"3lsfW2","date":"1597783971","viewed":193,"name":"Tartan Pattern","username":"gunthern","description":"Tartan exercise for book of shaders ch. 09 & ch. 11","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","pattern","tartan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\nfloat grid(in float _offset, in vec2 _uv){\n\tfloat gridx = smoothstep(0.01,0.01,sin(_uv.x-_offset));\n    float gridy = smoothstep(0.01,0.01,sin(_uv.y-_offset));\n    return gridx * gridy;\n}\n\nfloat lines(in float _offset, in vec2 _uv){\n\tfloat lines = smoothstep(0.0,0.1,sin(_uv.x-_offset));\n    return lines;\n}\n\nfloat stripes(in float _offset, in vec2 _uv){\n    float stripes = step(smoothstep(0.2,0.5,sin(_uv.y-_offset)),.5);\n    return stripes;\n}\n\nfloat box(vec2 _uv, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_uv);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_uv);\n    return uv.x*uv.y;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec2 tile(in float _zoom, in vec2 _uv){ \n    _uv *= _zoom;\n    \n     _uv.x += step(1.0, mod(_uv.y,2.0)) * snoise(_uv*.25*vec2(sin(iTime*.004),cos(iTime*.033)));\n    _uv.x += step(1.0, mod(_uv.y+1.0,2.0)) * snoise(_uv*.25*vec2(sin(iTime*.01),cos(iTime*.027)));\n    _uv.y += step(1.0, mod(_uv.x,2.0) * snoise(_uv*.02*vec2(sin(iTime*.001),cos(iTime*.012))));\n    _uv.y += step(1.0, mod(_uv.x+1.0,2.0)) * snoise(_uv*.25*vec2(sin(iTime*.006),cos(iTime*.02)));\n\n    return fract(_uv);\n}\n\nvec2 rotate2d(in float _angle, in vec2 _uv){\n\t_uv -= .5;\n    _uv *=  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    _uv += 0.5;\n    return _uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 1.735;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    uv = rotate2d(PI*-.45, uv);\n    \n    uv += snoise((uv*.1)+vec2(sin(iTime*.01),(uv*.05)+cos(iTime*.02)));\n    \n    //Tile for grids\n\tvec2 uv0 = tile(4.1, uv);\n    vec2 uv01 = tile(4.1, uv + vec2(2.5));\n    vec2 uv02 = tile(4.1, uv + vec2(5.0));\n    \n    vec2 uv03 = tile(4.1, uv + vec2(7.245));\n    \n    //Grids\n    float grid0 = grid(.1, uv0);\n    float grid01 = grid(.1,uv01);\n    float grid02 = grid(.1,uv02);\n    \n    float grid03 = grid(.025,uv03);\n    \n    //Boxes\n    float box0 = box(uv0-vec2(.05), vec2(.125), .01);\n    float box01 = box(uv01+vec2(.445), vec2(.125), .01);\n    float box02 = box(uv02-vec2(.05), vec2(.125), .01);\n    float box03 = box(uv02-vec2(-0.2,.05), vec2(.125), .01);\n    float box04 = box(uv02-vec2(-0.45,.05), vec2(.125), .01);\n    float box05 = box(uv01+vec2(-0.3,.445), vec2(.125), .01);\n    float box06 = box(uv01+vec2(.2,.445), vec2(.125), .01);\n    float box07 = box(uv0-vec2(.3,.05), vec2(.125), .01);\n    float box08 = box(uv0-vec2(-.45,.05), vec2(.125), .01);\n    \n    //lines to subtract from grids\n    vec2 uv0rot = rotate2d(PI*.2,uv);\n    float lines0 = lines(0.5, uv0rot*500.0);\n    \n    //stripes\n    float stripes0 = 1.0 - stripes(0.335, uv*vec2(25.75));\n    \n    col += clamp(grid0 * grid01 * grid02 + (1.0-lines0),0.0,1.0);\n    col -= box0 + box01 + box02 + box03 + box04 + box05 + box06 + box07 + box08;\n    col -= stripes0 * .5;\n    col *= clamp(1.0 - (vec3(1.0-grid03) - (1.0-lines0)),0.0,1.0);\n    col += clamp(vec3(1.0-grid03,0.0,0.0) - (1.0-lines0),0.0,1.0);\n    col *= clamp((1.0-lines0),0.9,1.0);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}