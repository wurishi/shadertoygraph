{"ver":"0.1","info":{"id":"fdSfWG","date":"1646921569","viewed":167,"name":"Synthwave Sun (Customizable)","username":"Lyagva","description":"Small shader, that makes cool animated sun like in many synthwave videos.\n\nI placed all config vars in one block of code, so it'll be easier for you to customize it.\nAlso, I made comments for almost every line of code.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sun","80s","animation","synthwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modulo function. Like \"%\" in other languages\nfloat mod(float a, float b) {\n    return a - (b * floor(a / b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Personally, I'm recommending you to leave LINES parameters on default values\n\t//\n\t// ======== CONFIG ========\n\t// Basics\n\tvec3 bgCol = vec3(0., 0., 0.); // Background color\n\t\n\t// Gradient\n\tfloat gradientPitch = 1.; // (gp) Defines dominative color on gradient. 1 - startCol < gp < 1 - endCol \n    vec3 gradientStartCol = vec3(1., 1., 0.); // Color in top pixels (Yellow)\n    vec3 gradientEndCol = vec3(1., 0., 1.); // Color in bottom pixels (Purple)\n\n\t// Circle\n\tbool isCircled = true;\n    float circleRR = 0.5; // Circle relative radius    [0., 1.]    This number multiplies min of your resolution\n\n    // Animated lines    \n    int linesCount = 8; // Count of lines    [0, inf]\n    float lineLenght = 0.5; // Relative distance from bottom of screen to death pos    [0., 1.]\n    float linesSpeed = 0.125; // Speed of lines\n    float lineHeight = 0.1; // Basic line thickness    [0., inf.] (> 0.5 looks ugly)\n    float thicknessMod = 0.5; // Speed of line will get thin    [0., inf.]\n\t\n\t\n\t// ======== DEFAULT INITS ========\n\tvec2 sSize = iResolution.xy; // Screen size (pixels)\n\tvec2 pos = fragCoord.xy; // Pixel pos on screen (pixels)\n    vec2 rPos = fragCoord.xy/sSize; // Relative pos on screen [0., 1.]\n   \t\n   \tvec3 col = vec3(0., 0., 0.); // Color of pixel\n \tfloat alpha = 1.; // Alpha of pixel [0., 1.]\n    \n    float time = iTime;\n    \n    \n    // ======== SUN GRADIENT ========\n    col = gradientEndCol + (gradientStartCol - gradientEndCol) * rPos.y * gradientPitch; // Blend dColor to endCol with height. Using endCol 'cause y starts from bottom\n    \n    \n    // ======== CIRCLE SHAPE ========\n    float circleR = min(sSize.x, sSize.y) * circleRR; // Radius of circle (pixels)\n    vec2 screenCenter = sSize / 2.; // Center of screen (pixels)\n    vec2 deltaPos = screenCenter - pos; // Vector from center to pixel (pixels)\n    float distToCenter = length(deltaPos); // Distance from center (pixels)\n    \n    if (distToCenter > circleR && isCircled) {\n    \tcol = bgCol;\n    }\n    \n    \n    // ======== ANIMATED LINES ========\n    for (float iter = 0.; iter < float(linesCount); iter++) {\n    \tfloat lineOsc = mod(time * linesSpeed + iter / float(linesCount), 1.); // Making simple oscillator y = mod(x, 1)    Adding additional speed and iterations offset\n    \n    \tfloat topBorder = lineOsc; // Setting top border for this line\n    \tfloat bottomBorder = topBorder - lineHeight * pow(lineLenght - lineOsc, thicknessMod); // Setting bottom border and making it moving FASTER than top, so the line will be thinner at top\n    \t\n    \t\n    \tif (bottomBorder < rPos.y && rPos.y < topBorder) { // If y is between bottom and top borders, we paint this to bg color.\n    \t\tcol = bgCol;\n    \t}\n    }\n    \n    \n    // ======== OUTPUT ========\n    fragColor = vec4(col, alpha); // Output color\n}","name":"Image","description":"","type":"image"}]}