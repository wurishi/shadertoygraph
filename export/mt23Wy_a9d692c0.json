{"ver":"0.1","info":{"id":"mt23Wy","date":"1685189896","viewed":201,"name":"Minecraft Note Block Sound","username":"Fuergu","description":"music that sounds minecraft ish\n","likes":3,"published":1,"flags":40,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 polarUV=vec2(atan(uv.x,uv.y),length(uv));\n    // Time varying pixel color\n    vec3 col =texture(iChannel0,polarUV-sin(iTime)).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define twopi 6.2831\n/*\nfloat sinPluck( float freq, float time , float volumn)\n{\n    return sin(twopi*freq*time) * exp(-3.0*time) * volumn;\n}\n\nfloat squarePluck( float freq, float time , float volumn)\n{\n    return sign(sin(twopi*freq*time)) * exp(-3.0*time) * volumn;\n}\n\nfloat sawPluck( float freq, float time , float volumn)\n{\n    return (mod(time*freq,1.)*2. - 1.)* exp(-3.0*time) * volumn;\n} */\n\nfloat FM(float fc,float fm, float iom, float t)\n{\n    return sin(twopi*fc*t+iom*sin(twopi*fm*t));\n}\n\nvec2 pan(float pos)\n{\n    vec2 e=vec2(1.-pos,1.+pos);\n    return normalize(e);\n}\n\nvec2 fmPluck(float f, float t)\n{\n    float fc = f;   //carrier frequency\n    float fm = f;   //modulation frequency\n    float iom = 3.; //index of modulation (most important)\n    \n    float env=exp(-3.*t)*.1;\n    vec2 sig=vec2(0);\n    \n    sig.x += FM(f+1.,f+1.,1.,t)*env;\n    sig.y += FM(f-1.,f-1.,1.,t)*env;\n    sig += FM(f, f, 15., t) * exp(-20.*t) * 0.03;\n    \n    return sig;\n}\n\nfloat interval(float semitones)\n{\n    return pow(2., (semitones-14.)/12.);\n}\n\nconst float notes[]=float[29](0.,3.,5.,7.,5.,3.  ,0.,-2.,2.  ,0.,-29.,-24.,\n                              0.,3.,5.,6.,5.,3.,6.  ,6.,5.,3.,6.,5.,3.,0.  ,-2.,2.,0.);\n\n#define speed 0.25\n#define speed2 0.22\n\nvec2 jingle(float t)\n{\n    vec2 sig=vec2(0.);\n    for(int i=0;i<7;i++)\n    {\n        float nn=notes[i];//nn: notenumber\n        float fi=440.*interval(nn);//fi: the frequency of note[i]\n        float t0i=speed*(float(i));//t0i: initial time of note[i]\n        float ti=mod(t-t0i,20.);//current time,\n        float pos=float((i+1)%3)-1.;\n        \n        sig+=fmPluck(fi,ti)*pan(pos);        \n    }\n        for(int i=7;i<10;i++)\n    {\n        float nn=notes[i];//nn: notenumber\n        float fi=440.*interval(nn);//fi: the frequency of note[i]\n        float t0i=speed2*(float(i));//t0i: initial time of note[i]\n        float ti=mod(t-t0i-.5,20.);//current time,\n        float pos=float((i+1)%3)-1.;\n        \n        sig+=fmPluck(fi,ti)*pan(pos);        \n    }\n    \n         for(int i=10;i<12;i++)\n    {\n        float nn=notes[i];//nn: notenumber\n        float fi=440.*interval(nn);//fi: the frequency of note[i]\n        float t0i=speed*(float(i));//t0i: initial time of note[i]\n        float ti=mod(t-t0i-1.,20.);//current time,\n        float pos=float((i+1)%3)-1.;\n        \n        sig+=fmPluck(fi,ti)*pan(pos);        \n    }\n\n\n    for(int i=12;i<19;i++)\n    {\n        float nn=notes[i];//nn: notenumber\n        float fi=440.*interval(nn);//fi: the frequency of note[i]\n        float t0i=speed*(float(i));//t0i: initial time of note[i]\n        float ti=mod(t-t0i-1.5,20.);//current time,\n        float pos=float((i+1)%3)-1.;\n        \n        sig+=fmPluck(fi,ti)*pan(pos);        \n    }\n    \n    for(int i=19;i<26;i++)\n    {\n        float nn=notes[i];//nn: notenumber\n        float fi=440.*interval(nn);//fi: the frequency of note[i]\n        float t0i=speed2*(float(i));//t0i: initial time of note[i]\n        float ti=mod(t-t0i-2.5,20.);//current time,\n        float pos=float((i+1)%3)-1.;\n        \n        sig+=fmPluck(fi,ti)*pan(pos);        \n    }\n    \n    for(int i=26;i<29;i++)\n    {\n        float nn=notes[i];//nn: notenumber\n        float fi=440.*interval(nn);//fi: the frequency of note[i]\n        float t0i=speed2*(float(i));//t0i: initial time of note[i]\n        float ti=mod(t-t0i-3.,20.);//current time,\n        float pos=float((i+1)%3)-1.;\n        \n        sig+=fmPluck(fi,ti)*pan(pos);        \n    }\n    return sig;\n}\n\n//mod function can repeat the sound\nvec2 mainSound( int samp, float t )\n{\n    vec2 sig=vec2(0.);\n    /*\n    sig += fmPluck(440.,mod(t,1.)) * pan(-.5);\n    sig += fmPluck(660.,mod(t-.25,1.)) * pan(.5);\n    //sig += sinkPluck(330.,t,1.);\n    */\n    //for(int i=0;i<10;i++)\n    sig+=jingle(t);\n    \n    return sig;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// various noise functions\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n#define saturate(a) clamp(a, 0.0, 1.0)\n// Weird for loop trick so compiler doesn't unroll loop\n// By making the zero a variable instead of a constant, the compiler can't unroll the loop and\n// that speeds up compile times by a lot.\n#define ZERO_TRICK max(0, -iFrame)\n\nfloat Density(vec3 p)\n{\n    float final = noise(p*0.06125);\n    float other = noise(p*0.06125 + 1234.567);\n    other -= 0.5;\n    final -= 0.5;\n    final = 0.1/(abs(final*final*other));\n    final += 0.5;\n    return final*0.0001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 70.0;\n\tvec3 pos = vec3(0,0,0);\n    float density = 0.0;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 37; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n        pos = camPos + relVec * t;\n        float temp = Density(pos);\n\n        inc = 1.9 + temp*0.05;\t// add temp because this makes it look extra crazy!\n        density += temp * inc;\n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(0.01,0.1,1.0)* density*0.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}