{"ver":"0.1","info":{"id":"4cKGDV","date":"1713567430","viewed":29,"name":"cube search","username":"sanderoneil","description":"cube","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi=3.141592653589793;\nconst float r = .5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y ;\n    \n    vec2 M = iMouse.xy/iResolution.xy*4.;\n    float t = iTime/10.;\n    vec4 v = eulerto4(0. + M.x,0.,0.);\n    vec4 r = eulerto4(pi/2.+ M.x,0.,0.);\n    vec4 u = eulerto4(0.+ M.x,pi/2.,0.);\n    v = rot(v,0.,M.y,M.y,0.+t,0.+M.x);\n    r = rot(r,0.,M.y,M.y,0.+t,0.+M.x);\n    u = rot(u,0.,M.y,M.y,0.+t,0.+M.x);\n    vec4 ray = normalize(v + r*uv.x + u * uv.y);\n     \n    vec4 norms[8];\n    \n    vec4 model_origin = v*40.;\n    \n    for (int d = 0; d<4; d++)\n    {\n        \n        for (int neg = 0; neg<2; neg++)\n        {\n        vec4 a = vec4(0,0,0,0);\n        a.x = float(d==0);\n        a.y = float(d==1);\n        a.z = float(d==2);\n        a.w = float(d==3);\n        \n        a = a -2.*float(neg)*a;\n        \n        norms[d*2+neg] = (a);\n        }\n    }\n    vec3 col = ray.xyz;\n    \n    // Time varying pixel color\n    float lowest_d = 1000000000000.;\n    vec4 cube = vec4 (0,0,0,0)+v*6.;\n    \n    //col = cube_search(cube, ray, norms, lowest_d, col);\n    \n    float side_length = 8.;\n    \n   for (float w = 0.; w<side_length; w++)\n    for (float z = 0.; z<side_length; z++)\n    for (float x = 0.; x<side_length; x++)\n    for (float y = 0.; y<side_length; y++)\n    {\n    vec4 p = vec4 (x,y,z,w)*2.-(side_length-1.);\n    \n    if (length(p)>(side_length+2.)){\n    col = cube_search(p+model_origin, ray, norms, lowest_d, col, v*16.);\n    }\n    \n    }\n    col = sphere_search(model_origin,ray,lowest_d,col,8.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 eulerto4( float a, float c ,float b)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    float cb = cos(b);\n    float sb = sin(b);\n    float cc = cos(c);\n    float sc = sin(c);\n    \n    return normalize(vec4(ca*cc,sa*cc,cb*sc,sb*sc));\n}\nvec4 rot(vec4 p,float a, float b,float c,float d,float e)\n{\n\n vec4 pt;\n float co = cos(a);\n float si = sin(a);\n \n pt = vec4(co*p.x - si*p.y,si*p.x + co*p.y,p.z,p.w);\n p = pt+0.;\n co = cos(b);\n si = sin(b);\n pt = vec4(co*p.x - si*p.z,p.y,si*p.x + co*p.z,p.w);\n p = pt+0.;\n \n co = cos(c);\n si = sin(c);\n pt = vec4(co*p.x - si*p.w,p.y,p.z,si*p.x + co*p.w);\n p = pt+0.;\n \n co = cos(d);\n si = sin(d);\n pt = vec4(p.x,co*p.y - si*p.w,p.z,si*p.y + co*p.w);\n p = pt+0.;\n \n co = cos(e);\n si = sin(e);\n pt = vec4(p.x,p.y,co*p.z - si*p.w,si*p.z + co*p.w);\n p = pt+0.;\n \n return p;\n \n}\nvec3 cube_search(vec4 cube, vec4 ray, vec4 norms[8],out float lowest_d, vec3 col, vec4 total_center)\n{\nfor (int plane_number = 0; plane_number<8; plane_number ++)\n{\n    \n    \n    vec4 n = norms[plane_number];\n    vec4 p0 = cube + n;\n    \n    float d = dot(p0, n)/ dot(ray,n);\n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_cube_center = p - cube;\n    bool any_dimension_above_1 = any(greaterThan(abs(intersect_to_cube_center), vec4(1.0001)));\n    //intersect_to_cube_center < vec4(1,1,1,1);\n    \n    if(!any_dimension_above_1){\n    if(d<lowest_d){\n    //col = n.xyz + n.w + .5;\n    vec4 totald = p - total_center;\n    col = n.xyz + n.w + .5 +  vec3(mod(length(totald),1.),length(totald)/4.-1.,length(totald)/40.);}\n    lowest_d = min(d,lowest_d);}\n    \n    }\n    return col;\n    \n\n}\nvec3 sphere_search(vec4 sphere, vec4 ray,out float lowest_d, vec3 col, float r)\n{\n\n    \n    \n\n    vec4 p0 = sphere;\n    \n    //float d = dot(ray, p0)/ dot(ray,ray);\n    float gradient = dot(ray, -sphere)*dot(ray, -sphere) - (dot(-sphere,-sphere) - r*r);\n    \n    float d = -dot(ray, -sphere) -sqrt(gradient);\n    \n    \n    vec4 p = ray*d;\n    \n    vec4 intersect_to_sphere_center = p - sphere;\n   \n    if(d<lowest_d){\n    col = intersect_to_sphere_center.xyz + intersect_to_sphere_center.w + .5;\n}\n    lowest_d = min(d,lowest_d);\n    \n    //col = vec3(gradient,mod(gradient,100.),0);\n    return col;\n    \n\n}","name":"Common","description":"","type":"common"}]}