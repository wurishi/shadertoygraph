{"ver":"0.1","info":{"id":"dtsXzn","date":"1674222052","viewed":67,"name":"Bagua","username":"hucancode","description":"Bagua (八卦) is a Chinese concepts that is similar to binary counting system. Adjust BIT_COUNT to see different variations. See how did I made this https://hucanco.de/blog/post/draw-taiji-with-glsl\n\n\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["bagua"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define IMAGE_MARGIN 0.5\n#define BIT_COUNT 3\n//#define BIT_COUNT (int(iTime/2.0)%4+2)\n#define SMOOTH_PIXEL 1.5\n#define BAR_WIDTH (PI/float(1<<BIT_COUNT))\n#define BAR_HEIGHT 0.08\n#define BAR_MARGIN 0.02\n#define CIRCLE_RADIUS 1.1\n#define CUT_WIDTH (BAR_WIDTH*0.1)\n\n\n#define RANGE(l,r,x) smoothstep(l, l + EPSILON, x) * smoothstep(r + EPSILON, r, x)\n#define RANGE_INVERT(l,r,x) smoothstep(l, l + EPSILON, x) + smoothstep(r + EPSILON, r, x)\n\nmat2 rotateMat(float angle) {\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat bar(int x, vec2 uv) {\n    float EPSILON = SMOOTH_PIXEL/iResolution.y;\n    float ret = RANGE(-BAR_WIDTH*0.5, BAR_WIDTH*0.5, uv.x) *\n        RANGE(-BAR_HEIGHT*0.5, BAR_HEIGHT*0.5, uv.y);\n    if(x == 0) {\n        ret *= RANGE_INVERT(CUT_WIDTH, -CUT_WIDTH, uv.x);\n    }\n    return ret;\n}\n\n// stem = bar x3\nfloat stem(int x, vec2 uv) {\n    // eliminated a for loop, thanks https://www.shadertoy.com/user/FabriceNeyret2\n    int bit = int(0.5 - ( uv.y + CIRCLE_RADIUS*0.5)/(BAR_HEIGHT+BAR_MARGIN)); \n    if(bit < 0 || bit >= BIT_COUNT) {\n        return 0.0;\n    }\n    int k = (x>>bit)&1;\n    vec2 offset = vec2(0.0, CIRCLE_RADIUS*0.5+float(bit)*(BAR_HEIGHT+BAR_MARGIN));\n    return bar(k, uv + offset);\n    // naive approach\n    float ret = 0.0;\n    for(int bit = 0;bit<BIT_COUNT;bit++) {\n        int k = (x>>bit)&1;\n        vec2 offset = vec2(0.0, CIRCLE_RADIUS*0.5+float(bit)*(BAR_HEIGHT+BAR_MARGIN));\n        ret += bar(k, uv + offset);\n    }\n    return ret;\n}\n\n// bagua = stem x8\nfloat bagua(vec2 uv) {\n    // eliminated a for loop, thanks https://www.shadertoy.com/user/FabriceNeyret2\n    int n = (1<<BIT_COUNT);\n    float i = round(float(n)*(0.75 - atan(uv.y,uv.x)/PI2));\n    return stem(int(i), uv * rotateMat(i*PI2/float(n))); \n    // naive approach\n    float ret = 0.0;\n    for(int i = 0;i<n;i++) {\n        ret += stem(i, uv * rotateMat(float(i)*PI2/float(n)));\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    // scale uv to fit the bagua\n    uv *= CIRCLE_RADIUS+(BAR_HEIGHT+BAR_MARGIN)*float(BIT_COUNT*2)+IMAGE_MARGIN;\n    \n    float v = bagua(uv);\n    fragColor = vec4(v);\n}","name":"Image","description":"","type":"image"}]}