{"ver":"0.1","info":{"id":"clKGzy","date":"1690295293","viewed":77,"name":"sea_sample","username":"pik","description":"sample","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float AMP=0.2;\nconst float WIND=1.2;\nconst vec3 SUN=normalize(vec3(0.,1.,0.));\nconst vec3 SEABASE=vec3(0.05,0.2,0.22);\nconst vec3 WATER=vec3(0.08,0.08,0.05);\nconst float DEPTH=1.3;\n\nvec3 setcam(vec3 cam,vec3 tar, vec2 uv)\n{\n    vec3 fo=normalize(tar-cam);\n    vec3 up=vec3(0.,1.,0.);\n    vec3 si=normalize(cross(fo,up));\n    up=cross(si,fo);\n    return si*uv.x+up*uv.y+fo;\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(937.3,866.8)))*2969631.);\n}\nfloat noise(vec2 p)\n{\n    vec2 i=floor(p);\n    vec2 f=p-i;\n    vec2 u=f*f*f*(6.*f*f-15.*f+10.);\n    return 2.*mix(mix(hash(i+vec2(0.,0.)),hash(i+vec2(1.,0.)),u.x),mix(hash(i+vec2(0.,1.)),hash(i+vec2(1.,1.)),u.x),u.y)-1.;\n}\n\nfloat wave(vec2 p,float c)\n{\n    p+=noise(p);\n    vec2 wv=mix(1.-abs(sin(p)),abs(cos(p)),abs(cos(p)));\n    return pow(1.-pow(wv.x*wv.y,0.65),c);\n}\n\nvec2 wind(float t)\n{\n    return vec2(t*0.1,-t*0.1)*WIND;\n}\n\nfloat map(vec3 p)\n{\n    vec2 uv=p.xz;\n    float f=0.;\n    float h=0.;\n    float a=AMP;\n    float c=WIND;\n    for(int i=0;i<3;i++)\n    {\n        h+=a*wave(uv-wind(iTime),c);\n        h+=a*wave(uv+wind(iTime),c);\n        uv*=mat2(1.2,1.6,-1.6,1.2);//回転\n        uv*=2.;//波長の細かい波\n        a*=0.2;//振幅の細かい波\n        c=mix(c,1.,0.2);//波が細かくなるにつれ波の鋭さを下げる\n    }\n    return p.y-h;\n}\n\nvec4 sea(vec3 ro,vec3 rd)\n{\n    float d=0.;\n    float d_near=0.;\n    float d_far=1000.;\n        //raymarch\n    vec3 p;\n    float h_near=map(ro+rd*d_near);\n    float h_far=map(ro+rd*d_far);\n    if(h_far>0.){return vec4(0.);}\n    for(int i=0;i<8;i++)\n    {\n        float f=h_near/(h_near-h_far);\n        d=mix(d_near,d_far,f);\n        p=ro+rd*d;\n        float h=map(p);\n        if(h<0.)\n        {\n            d_far=d;\n            h_far=h;\n        }\n        else\n        {\n            d_near=d;\n            h_near=h;\n        }\n    }\n    return vec4(p,d);\n}\nvec3 normal(vec3 p,float d)\n{\n    float eps=0.001*d*d;\n    return normalize(vec3(map(vec3(p.x+eps,p.y,p.z))-map(p),\n            map(vec3(p.x,p.y+eps,p.z))-map(p),\n            map(vec3(p.x,p.y,p.z+eps))-map(p)));\n}\nvec3 skycolor(vec3 rd)\n{\n    float u=clamp(1.-pow(rd.y+0.1,0.5),0.,1.);\n    float r=u*u;\n    float g=u;\n    float b=mix(u,1.,0.4);\n    return vec3(r,g,b);\n}\n\nfloat dep(vec2 p)\n{\n    return DEPTH+noise(p);\n}\n\nvec3 seacolor(vec3 p,vec3 n,vec3 rd,float d)\n{\n    //Frestnel-Schlick\n    float fr=pow(clamp(1.-dot(n,-rd),0.,1.),3.)*0.65;\n    float diff=pow(clamp(dot(SUN,n),0.,1.),60.);\n    float spec=pow(clamp(dot(SUN,reflect(-rd,n)),0.,1.),20.);\n    vec3 refl=skycolor(reflect(-rd,n));\n    vec3 refr=SEABASE+diff*WATER;\n    vec3 col=mix(refr,refl,fr);\n    \n    col+=WATER*max(1.-d*d*0.001,0.)*(p.y-dep(p.xz*0.3));\n    col+=spec*vec3(1.);\n    return col;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 cam=vec3(0.,1.,iTime*0.5);\n    vec3 tar=vec3(0.,.99,2.+iTime*0.5);\n    vec3 ro=cam;\n    vec3 rd= setcam(cam,tar,uv);\n    \n    vec4 res=sea(ro,rd);//vec4(p,d)\n    vec3 p=res.xyz;\n    float d=res.w;\n    vec3 n=normal(p,d);\n    vec3 sky=skycolor(rd);\n    vec3 sea=seacolor(p,n,rd,d);\n    \n    float f=pow(smoothstep(0.,-0.005,uv.y+abs(uv.x*uv.x*0.02)),0.3);//float t = pow(smoothstep(0.0, -0.05, dir.y), 0.3);\n    vec3 col = mix(sky,sea,f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}