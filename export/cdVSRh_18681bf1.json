{"ver":"0.1","info":{"id":"cdVSRh","date":"1680715777","viewed":74,"name":"Bent Rotating Tori","username":"sagiii","description":"My first shader toy!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv(float h, float s, float v){\n\tvec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n\treturn v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nconst float PI2 = 3.1415 * 2.0;\n\nfloat sdf_cube(vec3 v, float size) {\n    return max(max(abs(v.x), abs(v.y)), abs(v.z)) - size;\n}\n\nfloat sdf_torus(vec3 v, float r1, float r2) {\n\treturn distance(vec2(distance(vec2(v.x, v.y), vec2(0, 0)) - r1, v.z), vec2(0, 0)) - r2;\n}\n\nfloat sdf_sphere(vec3 v, float r) {\n\treturn distance(v, vec3(0.0, 0.0, 0.0)) - r;\n}\n\nfloat shell(float sdfv, float thick) {\n    return abs(sdfv - thick);\n}\n\nfloat cyclic(float x, float cycle) {\n    float x_ = x - float(int(x / cycle)) * cycle;\n    if (x_ < -cycle * 0.5) {\n        return x_ + cycle;\n    } else if (x_ > cycle * 0.5) {\n        return x_ - cycle;\n    } else {\n        return x_;\n    }\n}\n\nmat3 euler(vec3 angles) {\n\treturn  \n\t\tmat3(cos(angles.x), -sin(angles.x), 0, sin(angles.x), cos(angles.x), 0, 0, 0, 1) *\n\t\tmat3(cos(angles.y), 0, sin(angles.y), 0, 1, 0, -sin(angles.y), 0, cos(angles.y)) *\n\t\tmat3(1, 0, 0, 0, cos(angles.z), -sin(angles.z), 0, sin(angles.z), cos(angles.z));\n}\n\nfloat sdf(vec3 v) {\n    mat3 rot = euler(vec3(v.x * 0.1, PI2 * sin(PI2 * (iTime / 20.0 + 2.0)) + v.y * 0.1, PI2 * sin(iTime * PI2 / 40.0 + v.z * 0.02)));\n    return sdf_torus(rot * vec3(cyclic(v.x, 5.0 - v.z * 0.1), cyclic(v.y, 5.0 - v.z * 0.1 - v.z * 0.1), cyclic(v.z, 5.0)), 1.0, 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 cam_rot = euler(vec3(0, 0.1 * sin(iTime / 5.0), 0.1 * cos(iTime / 5.0)));\n    vec3 cam_pos = vec3(2.5, 0, -2.5) + euler(vec3(0, 0, iTime / 50.0 * PI2)) * vec3(0, 0, -15);\n\tfloat scr_dst = 1.0;\n\tvec3 ray = cam_rot * normalize(vec3((fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y), -scr_dst));\n\tvec3 pos = cam_pos;\n    // march\n\tint j = 0;\n    float d = 0.0;\n\tconst int MAXJ = 100;\n\tfor (int i = 0; i < MAXJ; i++) {\n\t\tj++;\n\t\td = sdf(pos);\n\t\tif (d > 1e-3) {\n\t\t\tpos += ray * d;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n    // color\n    //fragColor = vec4(hsv(float(j) / float(MAXJ), 1.0, 1.0), 1.0);\n    fragColor = vec4(vec3(1,1,1) * (1.0 - float(j) / float(MAXJ)), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}