{"ver":"0.1","info":{"id":"7sdSWn","date":"1632965978","viewed":66,"name":"koch curve","username":"dixie","description":"koch curve ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made following https://www.youtube.com/watch?v=il_Qg9AqQkE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // fragCoord is the coordinates of the pixel for which the shader\n    //     must calculate a color. These coordinates are counted\n    //     in pixels with values from 0.5 to resolution-0.5\n    \n    \n    // iResolution is the dimensions of the window in pixels\n    \n    // We can normalize the pixel coordinates to uv coordinates\n    //     by dividing by the resolution. Now fragCoord goes from\n    //     0 to 1\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // If we want to center our coordinate system at the origin\n    //     (like cartesian coordinates) we need to\n    //     subtract half of the width and height from the coordinates\n    \n    // height normalized pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    uv *= 4.0;\n    \n    // --------------------------\n    // Reflect the entire fractal\n    // --------------------------\n    uv.x = abs(uv.x);\n    \n\n    float angle2 = 2./3. * 3.14159;\n    uv.y += tan(angle2) * 0.5;\n    vec2 normal_big_reflect = vec2(cos(angle2), sin(angle2));\n    uv -= normal_big_reflect * 2. * min(0., dot(normal_big_reflect, uv - vec2(1.5, 0)));\n\n\n    vec3 col = vec3(0);\n   \n    // -----------------------------------------------------\n    // reflecting coordinate system around an arbitrary line\n    // -----------------------------------------------------\n\n    float angle = (5./6.) * 3.14159;\n    // direction of reflection (normal of the reflection line)\n    vec2 n = vec2(cos(angle), sin(angle));\n    \n    \n    // fold our coordinate space over x\n    uv.x = abs(uv.x);\n    \n    // shift our x coordinates 0.5 to the left\n    // this will make our image shift to the right\n    // since we are mirroring across the y axis the will\n    // stretch our line segment\n    uv.x -= 0.5;\n   \n\n    \n    // we do the dot product to get the distance to the line\n    float distance_to_n = dot(uv, n);\n    \n    // to reflect over the vector we walk along the direction\n    // from our point to the closest point on the line (twice)\n    uv -= n * 2.0 * max(0.0, distance_to_n);\n    \n    \n    // -----------------------------------------------------\n    // resetting the coordinates to redraw the pattern\n    // -----------------------------------------------------\n    float inv_scale = 3.0;\n    for (int i = 0; i < 3; i++) {\n        uv *= 3.0;\n        inv_scale *= 3.0;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        distance_to_n = dot(uv, n);\n        uv -= n * 2.0 * max(0.0, distance_to_n);\n \n    }\n    \n\n    \n    // x coordinate of the closest point on the line segment\n    // is either the x value of the pixel or, if outside of the line\n    // segment bounds, -1/1\n    // the y coordinate is 0\n    float distance_to_line = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0));\n    \n\n    \n    \n    col += smoothstep(1./iResolution.y, 0.0, distance_to_line / inv_scale);\n    //col.rg += sin(uv * 1.0);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}