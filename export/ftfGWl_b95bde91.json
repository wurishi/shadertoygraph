{"ver":"0.1","info":{"id":"ftfGWl","date":"1623441598","viewed":110,"name":"Space Station - Revisited","username":"lz","description":"Revision of https://www.shadertoy.com/view/3dfSWB\nWhile some details changed, the main goal was to improve performance by preprocessing the volumetric data.\nmouse x swirls the volumetric cloud.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["space","spacestation","shuttle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define DEBUG_LAYERS 1\n\nfloat gaussWeights[49] = float[49](0.00000067, 0.00002292, 0.00019117, 0.00038771, 0.00019117, 0.00002292, 0.00000067,\n                                   0.00002292, 0.00078633, 0.00655965, 0.01330373, 0.00655965, 0.00078633, 0.00002292,\n                                   0.00019117, 0.00655965, 0.05472157, 0.11098164, 0.05472157, 0.00655965, 0.00019117,\n                                   0.00038771, 0.01330373, 0.11098164, 0.22508352, 0.11098164, 0.01330373, 0.00038771,\n                                   0.00019117, 0.00655965, 0.05472157, 0.11098164, 0.05472157, 0.00655965, 0.00019117,\n                                   0.00002292, 0.00078633, 0.00655965, 0.01330373, 0.00655965, 0.00078633, 0.00002292,\n                                   0.00000067, 0.00002292, 0.00019117, 0.00038771, 0.00019117, 0.00002292, 0.00000067);\n                                   \n\nvec4 gauss33(in vec2 fragCoord, in sampler2D ch)\n{\n   vec4 val;\n   for (int i = 0; i < 7; i++)\n   {\n     for (int j = 0; j < 7; j++)\n     {\n       int si = i - 3;\n       int sj = j - 3;\n       vec4 ngh = texelFetch(ch, ivec2(fragCoord) + ivec2(si, sj), 0);\n       val += ngh * gaussWeights[i * 7 + j];\n     }\n   }\n   \n   return val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col;\n#ifdef DEBUG_LAYERS\n    vec2 tuv = uv;\n    if (uv.x < 0.5)\n    {\n       tuv.x /= 0.5;\n       float d_layer = min(floor(T_N_CHN * uv.y), T_N_CHN - 1.);\n       tuv.y = (uv.y - (d_layer / T_N_CHN)) * T_N_CHN; \n       vec4 layers = texture(iChannel1, tuv);\n       col = vec4(vec3(layers[int(d_layer)]), 1.0);\n       \n    }\n    else if (uv.x > 0.5 && DEBUG_LAYERS == 2)\n    {\n        tuv.x = 2.*(uv.x - 0.5);\n        vec3 coord = vec3(tuv, 0.5);\n        float val = layer_trillinear(coord, iChannel1);\n        col = vec4(vec3(val), 1.);\n    }\n    else\n    {\n       tuv.x = 2.*(uv.x - 0.5);\n       vec3 coord = vec3(0.5, 0.5, 0.2);\n       vec2 offset = vec2(0.0);\n       if (iMouse.z > 0.0)\n       {\n         vec2 muv = iMouse.xy / iResolution.xy;\n         coord.xz = muv.xy;\n         offset = vec2(muv.x*4., muv.y*8.);\n       }\n       float val = layer_trillinear(coord, iChannel1);\n       col.xyz = vec3(val);\n       \n       vec3 o = vec3(offset.x,0.,12. - offset.y);\n       vec3 d = normalize(vec3(-1. +2.*(tuv-vec2(0.,0.)),-1.));\n       vec3 bmax = vec3(5.);\n       vec3 bmin = vec3(-5.);\n       vec2 t_box = boxIntersection(o, d, bmin, bmax);\n       float t_start = max(t_box.x, 0.0);\n       int steps = 103;\n       float t_step = (t_box.y - t_start) / float(steps);\n       \n       float acc = val;\n       vec3 cp = vec3(0.886, 0.64, .186);\n       float valpha = 0.;\n       float vol_acc = 0.;\n       vec3 vol_col = vec3(0.);\n       float i_step = t_start;\n       \n       if (t_box.y > 0.0)\n       {\n           for (int i_s = 0; i_s < steps; i_s++)\n           {\n              vec3 p = o + d * (i_step);\n              vec3 vp = (p - bmin) / (bmax - bmin);\n              float f = layer_trillinear(vp.xzy, iChannel1);\n             \n             valpha = f*t_step;\n             vol_acc = valpha + (1. - valpha)*(vol_acc);\n             vol_col = valpha*vec3(1.) + (1.-valpha)*(vol_acc);\n             \n             \n             if (vol_acc > 0.999)\n                 break;\n                 \n             i_step += t_step;\n           }\n       }\n       \n       \n       col = vec4(vol_col, 1.0);  \n    }\n#else\n    \n    if (iResolution.x > ANTI_ALIAS_RES)\n    {\n        col = texture(iChannel0, uv);\n    }\n    else\n    {\n        vec4 acol = texture(iChannel0, vec2(2.*uv.x, uv.y));\n        vec4 bcol = texture(iChannel2, vec2(2.*uv.x-1., uv.y));\n\n        if (uv.x < 0.5)\n            col = acol;\n        else\n            col = bcol;\n    }\n    \n#endif\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define ROTY(p,al) p.xz = cos(al)*p.xz+ sin(al)*vec2(p.z,-p.x);\n#define ROTX(p,al) p.yz = cos(al)*p.yz+ sin(al)*vec2(p.z,-p.y);\n#define ROTZ(p,al) p.xy = cos(al)*p.xy+ sin(al)*vec2(p.y,-p.x);\n\n#define T_IN_ROW 15.\n#define T_IN_COL 11.\n#define T_N_CHN 4.\n\n#define ANTI_ALIAS_RES 1000.\n\nfloat hash(in vec2 st) {\nreturn fract(sin(dot(st.xy,\nvec2(12.9898,78.233)))\n* 43758.5453123);\n}\n\nfloat noise2d(vec2 st) {\n  vec2 ist = floor(st);\n  vec2 fst = fract(st);\n\n  vec2 u = 3.*fst*fst - 2.*fst*fst*fst;\n\n  float ll = hash(ist);\n  float lr = hash(ist + vec2(1.,0.));\n  float tl = hash(ist + vec2(0.,1.));\n  float tr = hash(ist + vec2(1.,1.));\n\n  float f = mix(mix(ll,lr,u.x),\n    mix(tl,tr,u.x),u.y);\n\n  return f;\n\n}\n\nfloat noise2d(in vec2 st, in vec2 m) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(mod(i,m));\nfloat b = hash(mod(i + vec2(1.0, 0.0),m));\nfloat c = hash(mod(i + vec2(0.0, 1.0),m));\nfloat d = hash(mod(i + vec2(1.0, 1.0),m));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\nvec2 hash22( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat hash12(in vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\n\nfloat hash12_b(in vec2 p, in int b) {\n    p = mod(p, vec2(b, b));\n    return hash12(p);\n}\n\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\nvec3 pi = floor(p);\nvec3 pf = fract(p);\n\npf = pf*pf*(3.-2.*pf);\n\nfloat a = hash(pi + vec3(0., 0., 0.));\nfloat b = hash(pi + vec3(1., 0., 0.));\nfloat c = hash(pi + vec3(0., 1., 0.));\nfloat d = hash(pi + vec3(1., 1., 0.));\n\nfloat e = hash(pi + vec3(0., 0., 1.));\nfloat f = hash(pi + vec3(1., 0., 1.));\nfloat g = hash(pi + vec3(0., 1., 1.));\nfloat h = hash(pi + vec3(1., 1., 1.));\n\nreturn mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\nmix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 6; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat fbmH(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 8; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat fbmLH(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 12; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.66;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat fbmLHL(vec3 p) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  int i = 0;\n  for (i = 0; i < 2; i++) {\n    f += ampl*noise3(p*freq + off);\n    ampl*= 0.66;\n    freq *= 2.;\n    off += 12.274739*ampl;\n  }\n\n  return f;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  //p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n   vec3 d = abs(p) - b;\nreturn length(max(d,0.0));\n// + min(max(d.x,max(d.y,d.z)),0.0);\n// remove this line for an only partially signed sdf }\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h ) { vec2 q = vec2( length(p.xz), p.y ); float b = (r1-r2)/h; float a = sqrt(1.0-b*b); float k = dot(q,vec2(-b,a)); if( k < 0.0 ) return length(q) - r1; if( k > a*h ) return length(q-vec2(0.0,h)) - r2; return dot(q, vec2(a,b) ) - r1; }\n\n\nfloat sminC( float a, float b, float k ) { float h = max( k-abs(a-b), 0.0 )/k; return min( a, b ) - h*h*h*k*(1.0/6.0); }\nfloat sdVerticalCapsule( vec3 p, float h, float r ) { p.y -= clamp( p.y, 0.0, h ); return length( p ) - r; }\n\nfloat hex(in vec2 p) {\n   vec3 vhex = vec3(0.5, -0.5773503, 0.866025);\n   \n   float alpha = atan(p.y, p.x) + 0.833333*PI;\n   float len = length(p);\n      \n   float new_alpha = mod(alpha, PI / 3.) + PI / 3.;\n    \n   vec2 ap = len*vec2(cos(new_alpha), sin (new_alpha));\n    \n   float f = ap.y;\n    \n   return length(f);\n}\n\nvec2 hexSquares(in vec2 p, in float dist) {\n   vec3 vhex = vec3(0.5, -0.5773503, 0.866025);\n   \n   float alpha = atan(p.y, p.x) + 0.83333*PI;\n   float len = length(p);\n   \n    \n   float new_alpha = mod(alpha, PI / 3.) + PI/3.;\n    \n   vec2 ap = len*vec2(cos(new_alpha), sin (new_alpha));\n   \n   // this one should be used if new_alpha is adjusted to + PI.\n   mat2 m = mat2(vhex.xy, vec2(vhex.y, -vhex.x));\n   vec2 vp = ap*m;\n   float f = abs(vp.y);\n    \n   f = ap.y;\n   vec2 cp = vec2(ap.x, ap.y-dist);\n   float modv = 0.8;//len/6.;\n   cp.x = mod(abs(cp.x) - 0.5*modv, modv) - 0.5*modv;\n   cp.x = abs(cp.x) - 0.12;\n   \n   return cp;\n}\n\nvec3 noiseNorm(in vec2 uv) {\n  vec2 e = vec2(0.001,0.0);\n\n  vec3 norm;\n\n  norm.x = .1*(noise2d(uv + e.xy) - noise2d(uv - e.xy));\n  norm.y = .1*(noise2d(uv + e.yx) - noise2d(uv - e.yx));\n  norm.z = 2.*e.x;\n\n  return normalize(norm);\n}\n\nvec2 panelNormal(in vec2 st) {\n  float mrg = 0.1;\n   float inv_mrg = 10.;\n  float st1 = step(mrg,st.x);\n  float st2 = step(mrg,1.-st.x);\n  float normx = (1.-st1)*6.*st.x*(1.-st.x*inv_mrg)*inv_mrg;\n  normx -= (1.-st2)*6.*(1.-st.x)*(1.-(1.-st.x)*inv_mrg)*inv_mrg;\n  float normz = clamp(step(0.01,normx)/normx,0.,1.) +\n                step(0.99,1.-normx);\n  return normalize(vec2(normx,normz));\n}\n\nvec3 panelNormal3(in vec2 st) {\n  float mrg = 0.05;\n  float inv_mrg = 20.;\n  float stx1 = step(mrg,st.x);\n  float stx2 = step(mrg,1.-st.x);\n  float normx = (1.-stx1)*6.*st.x*(1.-st.x*inv_mrg)*inv_mrg;\n  normx -= (1.-stx2)*6.*(1.-st.x)*(1.-(1.-st.x)*inv_mrg)*inv_mrg;\n  float sty1 = step(mrg,st.y);\n  float sty2 = step(mrg,1.-st.y);\n  float normy = (1.-sty1)*6.*st.y*(1.-st.y*inv_mrg)*inv_mrg;\n  normy -= (1.-sty2)*6.*(1.-st.y)*(1.-(1.-st.y)*inv_mrg)*inv_mrg;\n  normx *= (step(0.999,abs(sty1*sty2)));\n  normy *= (step(0.999,abs(stx1*stx2)));\n  return normalize(vec3(normx,normy,1.));\n}\n\nvec3 dCirculNorm(in vec2 uv,in vec2 grid) {\n  vec2 center = vec2(0.5,0.5);\n  vec2 fuv = fract(uv*grid);\n  vec2 iuv = floor(uv*grid);\n  float rad = length(fuv - center);\n  float step1 = 10.;\n  float step2 = 10.;\n  float r1 = clamp(6.*(rad-0.1)*(1.-(rad-0.1)*step1)*step1,0.,1.);\n  r1 += clamp(6.*(rad-0.3)*(1.-(rad-0.3)*step2)*step2,0.,1.);\n\n  vec2 r2 = vec2(1.) - (step(1.,iuv)*step(1.,grid-iuv-1.));\n  r2.x = r2.y = float(bool(r2.x)||bool(r2.y));\n  vec3 norm = normalize(vec3(r1*r2,1./(1.+0.01)));\n  //norm = normalize(vec3(rad,rad,1./(rad+0.001)));\n  return norm;\n}\n\nvec2 boxIntersection(in vec3 o, in vec3 d, in vec3 bmin, in vec3 bmax)\n{\n  vec3 inv_d = 1./d;\n  \n  vec3 dsign = sign(inv_d)*0.5 + 0.5;\n  \n  vec3 blmin = mix(bmax, bmin, dsign);\n  vec3 blmax = mix(bmin, bmax, dsign);\n  \n  vec3 t_s = (blmin - o) * inv_d;\n  vec3 t_e = (blmax - o) * inv_d;\n  \n  float t0 = max(t_s.x, max(t_s.y, t_s.z));\n  float t1 = min(t_e.x, min(t_e.y, t_e.z));\n  \n  if (t0 > t1 || t1 < 0.0) return vec2(-1.);\n  \n  return vec2(t0, t1);\n}\n\n/*float hash12(in vec2 i) {\n    return fract((dot(sin(i), vec2(139243.1251234,7719.119348))));\n}*/\n\nfloat cpattern(in vec2 p) {\n    vec2 grid = vec2(0.2);\n    vec2 ip = floor((p - grid/2.)/grid + 1.);\n    vec2 pp = mod(p - grid/2., grid) - grid / 2.;\n    float rad = length(pp);\n    float iff = hash12(ip);\n    float f = smoothstep(0.96, 0.97, 1.-rad)*step(0.7, iff);\n    return f;\n}\n\nvec3 pattNorm(in vec2 uv) {\n  vec2 e = vec2(0.001,0.0);\n\n  vec3 norm;\n\n  norm.x = .1*(cpattern(uv + e.xy) - cpattern(uv - e.xy));\n  norm.y = .1*(cpattern(uv + e.yx) - cpattern(uv - e.yx));\n  norm.z = 2.*e.x;\n\n  return normalize(norm);\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(vec3(0.,1.,0.),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n#define VOL_DENSITY 0.5\n\nconst float layerStep = (T_IN_ROW * T_IN_COL - 1.0);\nconst float chLayerStep = (T_N_CHN * T_IN_ROW * T_IN_COL - 1.0);\nconst float zPerChannel = (T_IN_ROW * T_IN_COL) / chLayerStep;\nconst float invChLayerStep = (1. / chLayerStep);\n\nconst vec2 layerCenter = vec2(0.5) / vec2(T_IN_ROW, T_IN_COL);\n\nvec4 prepareVolumeTexture(in vec2 uv, in float decay, in float core, \n     in float val, in vec4 cmul)\n{\n   vec2 iuv = floor(uv * vec2(T_IN_ROW, T_IN_COL));\n   vec2 fuv = fract(uv * vec2(T_IN_ROW, T_IN_COL));\n\n   vec4 dsi;\n\n   for (float i_ch = 0.; i_ch < T_N_CHN; i_ch += 1.)\n   {\n       float z = (i_ch * T_IN_ROW * T_IN_COL + iuv.y*T_IN_ROW + iuv.x) / (T_N_CHN * T_IN_ROW * T_IN_COL - 1.);\n\n       vec3 coord = vec3(fuv, z);\n       vec3 center = vec3(0.5);\n\n       vec3 offsets[] = vec3[4](vec3(0.), vec3(23.4), vec3(122.23, -12.3, 21.34), vec3(-11.3, 0.38, 81.3));\n\n       float rand = fbm(cmul.x*vec3(fbm((coord)*cmul.y), \n                    fbm(coord + vec3(-1.3)*cmul.z), \n                    fbm(coord + vec3(-1.3, 0.11, 4.3))*cmul.w ));\n\n       vec3 tcoord = coord;\n       tcoord = abs(tcoord - center);\n       float density = val*exp(decay*\n         (core - length(tcoord - vec3(0.07, 0.07, 0.07))))*rand;\n\n\n       dsi[int(i_ch)] = density; \n   }\n\n   return dsi;\n}\n\nvec4 getTriLayers(in float z, out float _alpha)\n{\n   \n   float eps = 0.00001;\n   \n   float m0 = z*layerStep;\n   float y0 = max(0., floor(m0/T_IN_ROW + eps));\n   float x0 = max(0., floor(m0 - y0 * T_IN_ROW + eps));\n   \n   x0 /= T_IN_ROW;\n   y0 /= T_IN_COL;\n   \n   float z0 = floor(m0 + eps) / layerStep;\n   float alpha = (z - z0) / layerStep;\n   \n   float z1 = min(z0 + (1./layerStep), 1.);\n   float m1 = z1 * layerStep;\n   \n   float y1 = max(0., floor(m1/T_IN_ROW + eps));\n   float x1 = max(0., floor(m1 - y1 * T_IN_ROW + eps));\n   \n   x1 /= T_IN_ROW;\n   y1 /= T_IN_COL;\n   \n   return vec4(x0, y0, x1, y1);\n}\n\nvec3 getTriLayer(in float z)\n{\n   float iz = floor(z / zPerChannel);\n   float fz = fract(z / zPerChannel);\n   \n   float eps = 0.00001;\n   \n   float m0 = fz*layerStep;\n   float y0 = max(0., floor(m0/T_IN_ROW + eps));\n   float x0 = max(0., floor(m0 - y0 * T_IN_ROW + eps));\n   \n   x0 /= T_IN_ROW;\n   y0 /= T_IN_COL;\n   \n   return vec3(x0, y0, iz);\n}\n\nfloat layer_trillinear(in vec3 coord, sampler2D channel)\n{\n   float alpha = fract(coord.z / chLayerStep);\n   \n   vec3 xych0 = getTriLayer(coord.z);\n   vec3 xych1 = getTriLayer(min(1., coord.z + invChLayerStep));\n   \n   vec2 norm_uv = coord.xy / vec2(T_IN_ROW, T_IN_COL);\n   \n   vec2 uv0 = norm_uv + vec2(xych0.x, xych0.y);\n   vec2 uv1 = norm_uv + vec2(xych1.x, xych1.y);\n   \n   float f0 = texture(channel, uv0)[int(xych0.z)];\n   float f1 = texture(channel, uv1)[int(xych1.z)];\n   \n   float ret = mix(f0, f1, alpha);\n   \n   return ret;\n}\n\nfloat layer_trillinear(in vec3 coord, in sampler2D channel, \n    in float angle)\n{\n   float alpha = fract(coord.z / chLayerStep);\n   \n   vec3 xych0 = getTriLayer(coord.z);\n   vec3 xych1 = getTriLayer(min(1., coord.z + invChLayerStep));\n   \n   vec2 norm_uv = coord.xy / vec2(T_IN_ROW, T_IN_COL);\n   \n   norm_uv -= layerCenter;\n   float rad = length(norm_uv.xy);\n   float langle = angle / (rad + 0.001);\n   \n   norm_uv = cos(langle)*norm_uv.xy + sin(langle) * vec2(norm_uv.y, -norm_uv.x);\n   norm_uv += layerCenter;\n   \n   vec2 uv0 = norm_uv + vec2(xych0.x, xych0.y);\n   vec2 uv1 = norm_uv + vec2(xych1.x, xych0.y);\n   \n   float f0 = texture(channel, uv0)[int(xych0.z)];\n   float f1 = texture(channel, uv1)[int(xych1.z)];\n   \n   float ret = mix(f0, f1, alpha);\n   \n   return ret;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n Space Station.\n\n The basic model design was taken from:\n https://www.ctvnews.ca/china-launches-first-module-for-future-space-station-1.704462\n\n Added the Hex (as a living module)\n \n Mostly made from cylinders and boxes. Added bump map to several surfaces (panels in particular).\n\n As always, the helper functions (noise, intersections) are taken from others (mostly iq).\n*/\n\nvec3 background(in vec3 o, in vec3 d)\n{\n    vec3 col;\n    vec2 st = sphIntersect(o, d, vec3(0.), 70.);\n    vec3 boxNorm;\n    vec2 st_b = boxIntersect(o, d, vec3(100.), boxNorm);\n    vec2 st_b2 = boxIntersect(o, d, vec3(200.), boxNorm);\n\n    vec3 p_sph = o + min(st.x, st.y)*d;\n\n    float thr = fbm(p_sph*0.035);\n    col = 0.7*vec3(0.,thr*0.15, 0.5*thr);\n\n    vec3 p_box = o +st_b.y*d;\n    float shr = fbmLH(p_box*0.04);\n    shr = pow(shr - 0.2, 8.);\n\n    vec3 p_box2 = o +st_b2.y*d;\n    float shr2 = fbmLHL(p_box2*0.2);\n    shr += pow(shr2 + 0.2, 64.);\n\n    col = col + vec3(shr, 0.8*shr, shr);\n    col = clamp(col, 0., 1.);\n    \n    return col;\n}\n\nfloat shuttle(in vec3 p)\n{\nvec3 op = p;\n//p.xz = cos(time)*(p.xz)+ sin(time)*vec2(p.z,-p.x);\nfloat lenxz = length(p.xz);\n\n//cylw\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 2.2;\nfloat brad = length(op.zy);\nfloat blen = abs(op.x);\n//float bli = clamp(pow(blen*0.7,8.),0.,brad*0.2);\nfloat fc1 = max(brad - .8,(blen-1.5+brad*0.8));\n\n//cylwf\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 5.;\n\nbrad = length(op.zy);\nblen = abs(op.x);\n\nfloat fc2 = max(brad - .4,(blen-2.));\n\n//central sphere\nop = p - vec3(0.,2.,0.);\nfloat fc3 = length(op) - 0.65;\n\n//wingc\nop = p - vec3(0.,2.,0.);\nfloat f1 = max(length(op.yz)-0.25,abs(op.x)-1.4);\nfloat f2 = max(lenxz-0.25,abs(op.y)-1.4);\nfloat fc4 = min(f1,f2);\n\n//rear1\nop = p - vec3(0.,.85,0.);\nfloat fr1 = max(lenxz-0.6,abs(op.y)-0.5+0.5*lenxz*lenxz);\n\n//rear2\nfloat fr2 = sdVerticalCapsule(p+vec3(0.,0.6,0.),0.6,0.45);\n\n//rear3\nop = p + vec3(0.,.9,0.);\nblen = abs(op.y);\nfloat fr3 = max(lenxz - 0.6 -0.1*pow(blen*2.,8.)*step(0.,-op.y),blen - 0.5);\n\n//forward 1\nop = p - vec3(0.,4.2,0.);\nfloat fw1 = max(lenxz-0.6,abs(op.y)-1.8+1.4*lenxz);\n\n//forward 2\nop = p - vec3(0.,5.7,0.);\nfloat fw2 = max(lenxz-0.9,abs(op.y)-.9+0.35*lenxz*lenxz);\n\n//forward 3+\nop = p - vec3(0.,6.7,0.);\nfloat rad = lenxz;\nf2 = max(rad-0.8,abs(op.y)-.4);\nop.y +=0.3;\nfloat f3 = max(rad - 0.7,abs(op.y)-.8);\nop.y -=1.35;\nfloat f4 = max(rad - .7,abs(op.y)-.6 +0.5*rad);\nop.y += 0.7;\nfloat f5 = max(rad - .3,abs(op.y)-.6);\nop.y -= 1.3;\nfloat f6 = max(rad - .5,abs(op.y)-.4);\nfloat fw3 = min(min(min(min(f3,f2),f4),f5),f6);\n\n//solar panel rear\nop = vec3(abs(p.x)-1.9,p.y+.94,p.z);\nfloat fpr = sdBox(op,vec3(1.,0.36,.02));\n\n// solar panel wing center\nop = vec3(abs(p.x)-6.,p.y-2.,abs(p.z) - 2.);\nfloat fpc = sdBox(op,vec3(0.02,0.5,1.4));\n\n//solar panel forward\nop = vec3(abs(p.x)-1.3,p.y-8.5,p.z);\nfloat fpw = sdBox(op,vec3(.7,0.2,.02));\n\n// solar panel c4\nop = vec3(p.x,p.y-4.,abs(p.z)-2.1);\nfloat ft = sdBox(op,vec3(0.02,0.7,1.4));\n\nop = vec3(abs(p.x)-2.1,p.y-4.,p.z);\nfloat fp4 = min(ft,sdBox(op,vec3(1.4,0.7,0.02)));\n\n// rear panel connect\nop = vec3(abs(p.x)-0.68,p.y+.95,p.z);\nfloat lenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.05,blen-0.1);\nop.x -= 0.17;\nop.y = abs(op.y) - 0.15;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.1);\nfloat frc = sminC(f1,f2,0.1);\n\n// panel connect\nop = vec3(abs(p.x)-0.65, abs(p.y-4.)-0.3,p.z);\nfloat r1 = length(op)-0.03;\nfloat r2 =  length(vec3(p.x, abs(p.y-4.)-0.3,abs(p.z)-0.65))-0.03;\nfloat frc1 = min(r1,r2);\n\n// wing connect\nop = vec3(abs(p.x)-6.,p.y-2.,p.z);\nROTX(op,PI/8.);\nf1 = max(length(op.xy)-0.02,abs(op.z)-.7);\nROTX(op,-PI/4.);\nf2 = max(length(op.xy)-0.02,abs(op.z)-.7);\nfloat frc2 = min(f1,f2);\n\n// forward panel connect\nop = vec3(abs(p.x)-0.5,p.y-8.5,p.z);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.02,blen-0.05);\nop.x -= 0.06;\nop.y = abs(op.y) - 0.06;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.05);\nfloat frc3 = sminC(f1,f2,0.05);\n    \n// hex\nop = vec3(p.x, p.y - 6.7, p.z);\nROTY(op, iTime*.05);\nfloat hfr = max(lenxz - .8, abs(op.y) - 0.5);\nfloat hff = max(length(op.zy) - .2, abs(op.x) - 3.);\nvec2 qf = vec2(hex(op.xz) - 3., op.y); \nhff = sminC(hff, hfr, 0.1);\nfloat hf = sminC(hex(qf) - .6, hff, 0.1);\n    \nvec2 windHex = hexSquares(op.xz, 3.6);\n    \nvec2 hexwind = vec2(max(abs(windHex.x)-0.01, abs(windHex.y)-0.05),op.y);\nhexwind.y = abs(hexwind.y) - 0.2;\nfloat hfwind = max(abs(hexwind.x)-0.08, abs(hexwind.y)-0.07);\nhf = max(hf, -hfwind);\n\nvec2 topHex = hexSquares(op.xz, 3.2);    \nvec2 hextop = vec2(max(abs(topHex.x)-0.3, abs(topHex.y)-0.3),op.y);\nhextop.y = abs(hextop.y) - 0.4;\nfloat hftop = max(abs(hextop.x)-0.08, abs(hextop.y)-0.07);\nhf = max(hf, -hftop);\n\nfloat of = min(min(min(fc1,fc2),fc3),fc4);\nof = min(min(fr2,min(of,fr1)),fr3);\nof = min(min(min(of,fw1),fw2),fw3);\nof = min(of,min(fpr,min(fpw,min(fp4,fpc))));\nof = sminC(of, hf, 0.1);\n    \nof = sminC(of,frc,0.08);\nof = sminC(of,frc1,0.1);\nof = sminC(of,frc2,0.1);\nof = sminC(of,frc3,0.05);\n//of = mix(-of, df,0.54);\n\nreturn of;\n//p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n//p.y -=abs(p.x)*1.5*(2.-p.y);\n}\n\n\n#define T3D_S 64.\n#define T3D_SR 8. // square root of T3D_S\n#define T3D_INV_S 0.015625\n#define T3D_INV_SR 0.125\n\n// Fresnel-Shlick\nfloat F(in float _f0, in vec3 _h, in vec3 _v)\n{\n    float hv = max(dot(_h, _v), 0.);\n    float hv1 = pow(1. - hv, 5.);\n    return _f0 + (1. - _f0) * hv1;\n}\n\nfloat shuttle(in vec3 p,inout vec3 norm, out vec4 col)\n{\nvec3 op = p;\n//p.xz = cos(time)*(p.xz)+ sin(time)*vec2(p.z,-p.x);\nfloat lenxz = length(p.xz);\n\n//cylw\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 2.2;\nfloat brad = length(op.zy);\nfloat blen = abs(op.x);\n//float bli = clamp(pow(blen*0.7,8.),0.,brad*0.2);\nfloat fc1 = max(brad - .8,(blen-1.5+brad*0.8));\n\n//cylwf\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 5.;\n\nbrad = length(op.zy);\nblen = abs(op.x);\n\nfloat fc2 = max(brad - .4,(blen-2.));\n\n//central sphere\nop = p - vec3(0.,2.,0.);\nfloat fc3 = length(op) - 0.65;\n\n//wingc\nop = p - vec3(0.,2.,0.);\nfloat f1 = max(length(op.yz)-0.25,abs(op.x)-1.4);\nfloat f2 = max(lenxz-0.25,abs(op.y)-1.4);\nfloat fc4 = min(f1,f2);\n\n//rear1\nop = p - vec3(0.,.85,0.);\nfloat fr1 = max(lenxz-0.6,abs(op.y)-0.5+0.5*lenxz*lenxz);\n\n//rear2\nfloat fr2 = sdVerticalCapsule(p+vec3(0.,0.6,0.),0.6,0.45);\n\n//rear3\nop = p + vec3(0.,.9,0.);\nblen = abs(op.y);\nfloat fr3 = max(lenxz - 0.6 -0.1*pow(blen*2.,8.)*step(0.,-op.y),blen - 0.5);\n\n//forward 1\nop = p - vec3(0.,4.2,0.);\nfloat fw1 = max(lenxz-0.6,abs(op.y)-1.8+1.4*lenxz);\n\n//forward 2\nop = p - vec3(0.,5.7,0.);\nfloat fw2 = max(lenxz-0.9,abs(op.y)-.9+0.35*lenxz*lenxz);\n\n//forward 3+\nop = p - vec3(0.,6.7,0.);\nfloat rad = lenxz;\nf2 = max(rad-0.8,abs(op.y)-.4);\nop.y +=0.3;\nfloat f3 = max(rad - 0.7,abs(op.y)-.8);\nop.y -=1.35;\nfloat f4 = max(rad - .7,abs(op.y)-.6 +0.5*rad);\nop.y += 0.7;\nfloat f5 = max(rad - .3,abs(op.y)-.6);\nop.y -= 1.3;\nfloat f6 = max(rad - .5,abs(op.y)-.4);\nfloat fw3 = min(min(min(min(f3,f2),f4),f5),f6);\n\n//solar panel rear\nop = vec3(abs(p.x)-1.9,p.y+.94,p.z);\nfloat fpr = sdBox(op,vec3(1.,0.36,.02));\n\n// solar panel wing center\nop = vec3(abs(p.x)-6.,p.y-2.,abs(p.z) - 2.);\nfloat fpc = sdBox(op,vec3(0.02,0.5,1.4));\n\n//solarop = vec3(p.x,p.y-4.,abs(p.z)-2.1); panel forward\nop = vec3(abs(p.x)-1.3,p.y-8.5,p.z);\nfloat fpw = sdBox(op,vec3(.7,0.2,.02));\n\n// solar panel c4\nop = vec3(p.x,p.y-4.,abs(p.z)-2.1);\nfloat ft = sdBox(op,vec3(0.02,0.7,1.4));\n\nop = vec3(abs(p.x)-2.1,p.y-4.,p.z);\nfloat fp4 = min(ft,sdBox(op,vec3(1.4,0.7,0.02)));\n\n// rear panel connect\nop = vec3(abs(p.x)-0.68,p.y+.95,p.z);\nfloat lenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.05,blen-0.1);\nop.x -= 0.17;\nop.y = abs(op.y) - 0.15;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.1);\nfloat frc = sminC(f1,f2,0.1);\n\n// panel connect\nop = vec3(abs(p.x)-0.65, abs(p.y-4.)-0.3,p.z);\nfloat r1 = length(op)-0.03;\nfloat r2 =  length(vec3(p.x, abs(p.y-4.)-0.3,abs(p.z)-0.65))-0.03;\nfloat frc1 = min(r1,r2);\n\n// wing connect\nop = vec3(abs(p.x)-6.,p.y-2.,p.z);\nROTX(op,PI/8.);\nf1 = max(length(op.xy)-0.02,abs(op.z)-.7);\nROTX(op,-PI/4.);\nf2 = max(length(op.xy)-0.02,abs(op.z)-.7);\nfloat frc2 = min(f1,f2);\n\n// forward panel connect\nop = vec3(abs(p.x)-0.5,p.y-8.5,p.z);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.02,blen-0.05);\nop.x -= 0.06;\nop.y = abs(op.y) - 0.06;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.05);\nfloat frc3 = sminC(f1,f2,0.05);\n\n// hex\nop = vec3(p.x, p.y - 6.7, p.z);\nROTY(op, iTime*.05);\nfloat hfr = max(lenxz - .8, abs(op.y) - 0.5);\nfloat hff = max(length(op.zy) - .2, abs(op.x) - 3.);\nvec2 qf = vec2(hex(op.xz) - 3., op.y); \nhff = sminC(hff, hfr, 0.1);\nfloat hf = sminC(hex(qf) - .6, hff, 0.1);\n    \nvec2 windHex = hexSquares(op.xz, 3.6);\n    \nvec2 hexwind = vec2(max(abs(windHex.x)-0.01, abs(windHex.y)-0.05),op.y);\nhexwind.y = abs(hexwind.y) - 0.2;\nfloat hfwind = max(abs(hexwind.x)-0.08, abs(hexwind.y)-0.07);\nhf = max(hf, -hfwind);\n\nvec2 topHex = hexSquares(op.xz, 3.2);    \nvec2 hextop = vec2(max(abs(topHex.x)-0.3, abs(topHex.y)-0.3),op.y);\nhextop.y = abs(hextop.y) - 0.4;\nfloat hftop = max(abs(hextop.x)-0.08, abs(hextop.y)-0.07);\nhf = max(hf, -hftop);\n\nfloat of = min(min(min(fc1,fc2),fc3),fc4);\nof = min(min(fr2,min(of,fr1)),fr3);\nof = min(min(min(of,fw1),fw2),fw3);\nof = min(of,min(fpr,min(fpw,min(fp4,fpc))));\nof = sminC(of, hf, 0.1);\n    \nof = sminC(of,frc,0.08);\nof = sminC(of,frc1,0.1);\nof = sminC(of,frc2,0.1);\nof = sminC(of,frc3,0.05);\n//of = mix(-of, df,0.54);\n\nif ((of == fpr) && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-0.95,p.y+.94)/vec2(2.,0.72);\n   vec2 nuv = panelNormal(fract(uof*5.));\n   norm *= vec3(nuv.x,0.,nuv.y);\n   col = vec4(0.12,0.,0.23, .8);\n\n} else if ((of == fpw) && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-0.65,p.y-8.5)/vec2(1.4,0.4);\n   vec2 nuv = panelNormal(fract(uof*5.));\n   norm *= vec3(nuv.x,0.,nuv.y);\n   col = vec4(0.12,0.,0.23, 0.2);\n} else if (of==fp4 && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-2.1,p.y-4.)/vec2(1.4,0.7);\n   norm = panelNormal3(fract(uof*3.))*sign(norm);\n   col = vec4(0.12,0.,1.23, 0.9);\n} else if (of==fp4 && abs(norm.x) > 0.5) {\n   vec2 uof = vec2(abs(p.z)-2.1,p.y-4.)/vec2(1.4,0.7);\n   norm.zyx = panelNormal3(fract(uof*3.))*sign(norm.x);\n   col = vec4(0.12,0.,1.23, 0.9);\n} else if (of==fpc && abs(norm.x) > 0.5) {\n   vec2 uof = vec2(abs(p.z) - 2.,p.y-2.)/vec2(1.4,0.5);\n   vec2 nuv = panelNormal(fract(uof*5.))*sign(norm.x);\n   norm = vec3(nuv.y,nuv.x,0.2);\n   col = vec4(0.12,0.,0.23, 0.8);\n} else if (of == fc2) {\n   vec2 uof = vec2(abs(p.x)-5.,p.y-2.);\n   float ang = 0.5*(atan(p.z,uof.y)/PI)+0.5;\n   float h = clamp((abs(p.x) - 3.)/6.,0.,1.);\n   float fnoise = noise2d(vec2(h, ang)*20., vec2(20.));\n   col = vec4(0.4,0.6,0.8, 0.2)*(1.+fnoise*0.1);\n   col.w = .5;\n} else if (of == fc1) {\n   vec2 uof = vec2(abs(p.x)-2.2,p.y-2.);\n   float ang = 0.5*(atan(p.z,uof.y)/PI)+0.5;\n   float h = clamp((abs(p.x) - 1.4)/1.6,0.,1.);\n   vec2 uv = vec2(ang,h);\n   vec3 v1 = vec3(1.,0.,0.);\n   vec3 v2 = cross(norm,v1);\n   vec2 cuv = vec2(uv.x*16.,uv.y*3.);\n   vec3 nnorm = noiseNorm(uv*100.);\n   vec3 anorm = panelNormal3(fract(cuv));\n   //vec3 cnorm = dCirculNorm(fract(cuv),vec2(4.,6.));\n\n   norm = (mat3(v1,v2,norm)*(anorm+nnorm));\n\n   col = vec4(0.88,0.88,0.91, 0.4);\n   //norm = vec3(1.);\n} else if (of == fc4) {\n   col = vec4(0.5,0.52,0.2, .3);\n} else if (of == fw2) {\n   vec2 uof = vec2(p.x,p.y-5.7);\n   float ang = 0.5*(atan(p.z,p.x)/PI)+0.5;\n   float h = clamp((abs(p.y) - 5.2)/1.,0.,1.);\n   vec2 uv = vec2(ang,h);\n   vec3 v1 = vec3(0.,1.,0.);\n   vec3 v2 = cross(norm,v1);\n   vec2 cuv = vec2(uv.x*16.,uv.y*4.);\n   vec3 anorm = panelNormal3(fract(cuv));\n   vec3 nnorm = noiseNorm(uv.yx*100.);\n   //vec3 cnorm = dCirculNorm(fract(cuv),vec2(4.,6.));\n\n   norm = mat3(v1,v2,norm)*(anorm+nnorm);\n   col = vec4(0.5,0.6,0.87, 0.5);\n} else if (of == fw1) {\n    vec3 uop = p - vec3(0.,4.2,0.);\n    float h = clamp((uop.y+1.5)/3., 0., 1.);\n    float ang = 0.5*(atan(uop.z, uop.x)/PI) + 0.5;\n    vec3 v1 = normalize(vec3(p.x, 0., p.z));\n    vec3 v2 = vec3(0., 1., 0.);\n    vec3 v3 = cross(v1, v2);\n    \n    vec3 anorm = pattNorm(vec2(ang, h));\n    norm = mat3(v3, v2, v1)*anorm;\n    col = vec4(0.5,0.6,0.87, 0.2);\n} else {\n   /*vec3 rp = p + vec3(10.);\n    \n   vec3 cube = mod(rp*T3D_INV_S,1.);\n    \n   vec2 ccoord0 = vec2(floor(cube.z*T3D_SR)*T3D_INV_SR, \n                       floor(T3D_SR*mod(cube.z, T3D_INV_SR))*T3D_INV_SR );\n   \n   vec2 ccoord1 = vec2(floor((cube.z+T3D_INV_S)*T3D_SR)*T3D_INV_SR, \n                       floor(T3D_SR*mod((cube.z+T3D_INV_S), T3D_INV_SR))*T3D_INV_SR );\n    \n   vec3 cl0 = texture(iChannel0, ccoord0 + cube.xy).xyz;\n   vec3 cl1 = texture(iChannel0, ccoord1 + cube.xy).xyz;\n   float interpF = mod(cube.z,T3D_INV_S);*/\n\n   col = vec4(0.7,0.7,0.7, 0.2);\n   \n   //col = texture(iChannel0, vec2(0.5) + p.xz*.1);\n   //col = vec4(mix(cl0, cl1, interpF), 1.2);\n}\n\nreturn of;\n//p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n//p.y -=abs(p.x)*1.5*(2.-p.y);\n}\n\nconst vec4 planet_center = vec4(-15., -6., -3., 24.);\nconst vec4 dust_center = vec4(-5., 6., -1., 24.);\n\n\n#define FAR 80.\n#define VOL_FOG_STEP .25\n\nfloat bshuttle(vec3 p)\n{\n    return sdBox(p, vec3(4., 7., 4.));\n}\n\nvec2 geom(in vec3 p, in vec3 o, in vec3 d)\n{\n    vec2 t_vec;\n    \n    vec3 bboxsh3 = vec3(7., 9., 4.);\n    vec2 bboxsh = boxIntersection(o, d, -bboxsh3, bboxsh3);\n    if (bboxsh.y > 0.)\n    {\n        t_vec.x = shuttle(p);\n    }\n    \n    vec2 res = vec2(FAR, -1.);\n    \n    for (int i_t = 0; i_t < 1; i_t++)\n    {\n        if (t_vec.x < res.x)\n        {\n            res.x = t_vec.x;\n            res.y = 0.;\n        }\n    }\n        \n    return res;\n}\n\nvec3 getCentralDiffShuttle(vec3 o, vec3 d, float t)\n{\n    vec3 norm;\n    vec3 e = vec3(0.00001, 0.0, 0.0)*t;\n\n    vec3 p = o + t*d;\n\n    norm.x = shuttle(p + e.xyy) - shuttle(p - e.xyy);\n    norm.y = shuttle(p + e.yxy) - shuttle(p - e.yxy);\n    norm.z = shuttle(p + e.yyx) - shuttle(p - e.yyx);\n\n    norm = normalize(norm);\n    \n    return norm;\n}\n\nvec4 trace(in vec3 o, in vec3 d)\n{\n    float threshold = 0.0001;\n    // vec4(final distance, current distance, nearest distance, geom type);\n    vec4 res = vec4(0., FAR, FAR, 10.);\n    for (int i=0;i<192;i++)\n    {\n       vec3 p = o + res.x*d;\n       \n       res.yw = geom(p, o, d);\n       \n       res.z = min(res.z, res.y);\n       res.x += res.y;\n\n       if (res.y < threshold*res.x || res.x > FAR) \n       {\n           threshold *= res.x;\n           break;\n       }\n    }\n    \n    return res;\n}\n\nvec4 vol_trace(in vec3 o, in vec3 d, in vec3 res_t, in vec4 volbox, \n    in vec3 baseCol, in sampler2D channel, in float rotation)\n{\n    float vol_steps = 0.;\n    float valpha = 0.;\n    float vol_acc = 0.;\n    vec3 vol_col = vec3(0.);\n    float threshold = 0.0001*res_t.x;\n    float space_t = step(threshold, res_t.y);\n    \n    float v_dist = space_t*FAR + (1.-space_t)*res_t.x;\n    vol_steps = (v_dist / VOL_FOG_STEP)*(exp(-res_t.z*.001));\n    \n    vec2 t_box = boxIntersection(o, d, volbox.xyz - volbox.w, \n                                       volbox.xyz + volbox.w);\n    \n    vec3 so = o + t_box.x * d;\n    \n    vec3 bmin = volbox.xyz - vec3(volbox.w);\n    vec3 bmax = volbox.xyz + vec3(volbox.w);\n    \n    for (float t_s = max(t_box.x, 0.0); t_s < t_box.y && t_s < v_dist; t_s += VOL_FOG_STEP)\n    {\n        vec3 vp = o + t_s * d;\n        \n        vec3 coord = (vp - bmin) / (bmax - bmin);\n\n        float density = layer_trillinear(coord.xzy, channel, rotation);\n        float ns = (1. + 0.5*hash(vp));\n        valpha = ns*density*VOL_FOG_STEP;\n        vol_col = valpha*baseCol + (1.-valpha)*(vol_acc);\n        vol_acc = valpha + (1. - valpha)*(vol_acc);\n        \n        if (vol_acc > 0.98)\n            break;\n    }\n    \n    return vec4(vol_col, vol_acc);\n}\n\nvoid cameraSetup(inout vec3 o, inout vec3 d)\n{\n    o.y = 20. + 20.*sin(iTime*0.2);\n    float r = 2. + min(0., 0.5*o.y);\n    o = vec3(6. + sin(iTime),o.y, 6. + cos(iTime));\n    vec3 target = vec3(0., 10.*sin(iTime*0.065), 0.);\n    target = mix(target, vec3(planet_center.x, 0., 0.), pow(cos(0.25*iTime)*0.5+0.5, 8.));\n    target = mix(target, dust_center.xyz, pow(cos(0.25*iTime)*0.5+0.5, 8.));\n    d = camera(o, d, target);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if (iResolution.y > iResolution.x)\n       uv.y *= iResolution.y/iResolution.x;\n    else\n       uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 rsc = vec4(-1., -1., 1., 2.);\n    \n    if (iResolution.x > ANTI_ALIAS_RES)\n    {\n      rsc = vec4(-1., -1., 2., 2.);\n    }\n\n    vec3 o = vec3(sin(iTime),15.,10.);\n    vec3 d = normalize(vec3(rsc.xy + rsc.zw*(uv-vec2(0.5 + 0.5*sin(iTime*0.25),0.)),-1.));\n    \n    vec3 col;\n    \n    \n    float threshold = 0.0001;\n    vec4 res_t;\n    vec4 planet_col;\n    vec4 dust_col;\n    vec4 vol_col;\n    \n    cameraSetup(o, d);\n\n    res_t = trace(o, d);\n    threshold *= res_t.x;\n    \n\t// volumetric step\n    planet_col = vol_trace(o, d, res_t.xyz, planet_center, \n              vec3(0.886, .634, .186), iChannel1, 0.05 * (iMouse.x/iResolution.x));\n    //dust_col = vol_trace(o, d, res_t.xyz, dust_center, \n     //         vec3(0.34, 0.12, 0.74), iChannel2, 0.03);\n    \n    vol_col = planet_col;//mix(dust_col, planet_col, planet_col.w);\n    \n    if (res_t.y < threshold && res_t.w < 0.5)\n    {\n       vec3 specCol;\n       vec3 p = o + res_t.x*d;\n       vec4 bc;\n        \n       vec3 norm = getCentralDiffShuttle(o, d, res_t.x);\n\t   shuttle(p,norm,bc);\n       \n       float ns = mix(0.2*(noise3(p*14.12)-0.5), 0., step(0.35, bc.w));\n       \n       vec3 ldir = normalize(p - planet_center.rgb);\n       vec3 h = normalize(ldir - d);\n       float spc = F(bc.w, h, d) * max(dot(ldir, -norm), 0.0);\n       \n       vec3 rd = reflect(d, normalize(norm + vec3(ns)));\n       \n       vec3 bckCol = background(o, rd);\n      \n      col += 0.7*bc.xyz*(dot(-norm,d));\n      specCol = 0.3*bc.w*vec3(256.*exp(-res_t.x))*\n          clamp(pow(max(0., dot(reflect(d, norm), -d)),8.), 0., 1.);\n      \n      col = mix(col, bckCol, bc.w);\n      col = clamp(col + specCol, 0., 1.);\n    } else\n    {\n       col = background(o, d);\n    }\n\n\n    col = mix(col, vol_col.xyz, vol_col.w);\n\n    fragColor = vec4(pow(col, vec3(2.2)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// density map\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    vec4 col;\n    float xres = texelFetch(iChannel0, ivec2(1, 0), 0).r;\n    \n    bool resChange = abs(xres * iResolution.x - 1.) > 0.1;\n    \n    if (iFrame == 0 || resChange)\n    {\n       vec2 uv = fragCoord / iResolution.xy;\n       float wave = sin(iTime*0.1 + 2.) + 1.1*sin(iTime*0.17) + 0.75*sin(iTime*0.23);\n       col = prepareVolumeTexture(uv, 15., 0.1, 0.5, vec4(wave + 6.71, 6., 1., 7.23));\n       //col = vec4(z, z, z, 1.);\n    }\n    else\n    {\n       col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        col.x = 1./iResolution.x;\n    }\n    \n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n Space Station.\n\n The basic model design was taken from:\n https://www.ctvnews.ca/china-launches-first-module-for-future-space-station-1.704462\n\n Added the Hex (as a living module)\n \n Mostly made from cylinders and boxes. Added bump map to several surfaces (panels in particular).\n\n As always, the helper functions (noise, intersections) are taken from others (mostly iq).\n*/\n\nvec3 background(in vec3 o, in vec3 d)\n{\n    vec3 col;\n    vec2 st = sphIntersect(o, d, vec3(0.), 70.);\n    vec3 boxNorm;\n    vec2 st_b = boxIntersect(o, d, vec3(100.), boxNorm);\n    vec2 st_b2 = boxIntersect(o, d, vec3(200.), boxNorm);\n\n    vec3 p_sph = o + min(st.x, st.y)*d;\n\n    float thr = fbm(p_sph*0.035);\n    col = 0.7*vec3(0.,thr*0.15, 0.5*thr);\n\n    vec3 p_box = o +st_b.y*d;\n    float shr = fbmLH(p_box*0.04);\n    shr = pow(shr - 0.2, 8.);\n\n    vec3 p_box2 = o +st_b2.y*d;\n    float shr2 = fbmLHL(p_box2*0.2);\n    shr += pow(shr2 + 0.2, 64.);\n\n    col = col + vec3(shr, 0.8*shr, shr);\n    col = clamp(col, 0., 1.);\n    \n    return col;\n}\n\nfloat shuttle(in vec3 p)\n{\nvec3 op = p;\n//p.xz = cos(time)*(p.xz)+ sin(time)*vec2(p.z,-p.x);\nfloat lenxz = length(p.xz);\n\n//cylw\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 2.2;\nfloat brad = length(op.zy);\nfloat blen = abs(op.x);\n//float bli = clamp(pow(blen*0.7,8.),0.,brad*0.2);\nfloat fc1 = max(brad - .8,(blen-1.5+brad*0.8));\n\n//cylwf\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 5.;\n\nbrad = length(op.zy);\nblen = abs(op.x);\n\nfloat fc2 = max(brad - .4,(blen-2.));\n\n//central sphere\nop = p - vec3(0.,2.,0.);\nfloat fc3 = length(op) - 0.65;\n\n//wingc\nop = p - vec3(0.,2.,0.);\nfloat f1 = max(length(op.yz)-0.25,abs(op.x)-1.4);\nfloat f2 = max(lenxz-0.25,abs(op.y)-1.4);\nfloat fc4 = min(f1,f2);\n\n//rear1\nop = p - vec3(0.,.85,0.);\nfloat fr1 = max(lenxz-0.6,abs(op.y)-0.5+0.5*lenxz*lenxz);\n\n//rear2\nfloat fr2 = sdVerticalCapsule(p+vec3(0.,0.6,0.),0.6,0.45);\n\n//rear3\nop = p + vec3(0.,.9,0.);\nblen = abs(op.y);\nfloat fr3 = max(lenxz - 0.6 -0.1*pow(blen*2.,8.)*step(0.,-op.y),blen - 0.5);\n\n//forward 1\nop = p - vec3(0.,4.2,0.);\nfloat fw1 = max(lenxz-0.6,abs(op.y)-1.8+1.4*lenxz);\n\n//forward 2\nop = p - vec3(0.,5.7,0.);\nfloat fw2 = max(lenxz-0.9,abs(op.y)-.9+0.35*lenxz*lenxz);\n\n//forward 3+\nop = p - vec3(0.,6.7,0.);\nfloat rad = lenxz;\nf2 = max(rad-0.8,abs(op.y)-.4);\nop.y +=0.3;\nfloat f3 = max(rad - 0.7,abs(op.y)-.8);\nop.y -=1.35;\nfloat f4 = max(rad - .7,abs(op.y)-.6 +0.5*rad);\nop.y += 0.7;\nfloat f5 = max(rad - .3,abs(op.y)-.6);\nop.y -= 1.3;\nfloat f6 = max(rad - .5,abs(op.y)-.4);\nfloat fw3 = min(min(min(min(f3,f2),f4),f5),f6);\n\n//solar panel rear\nop = vec3(abs(p.x)-1.9,p.y+.94,p.z);\nfloat fpr = sdBox(op,vec3(1.,0.36,.02));\n\n// solar panel wing center\nop = vec3(abs(p.x)-6.,p.y-2.,abs(p.z) - 2.);\nfloat fpc = sdBox(op,vec3(0.02,0.5,1.4));\n\n//solar panel forward\nop = vec3(abs(p.x)-1.3,p.y-8.5,p.z);\nfloat fpw = sdBox(op,vec3(.7,0.2,.02));\n\n// solar panel c4\nop = vec3(p.x,p.y-4.,abs(p.z)-2.1);\nfloat ft = sdBox(op,vec3(0.02,0.7,1.4));\n\nop = vec3(abs(p.x)-2.1,p.y-4.,p.z);\nfloat fp4 = min(ft,sdBox(op,vec3(1.4,0.7,0.02)));\n\n// rear panel connect\nop = vec3(abs(p.x)-0.68,p.y+.95,p.z);\nfloat lenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.05,blen-0.1);\nop.x -= 0.17;\nop.y = abs(op.y) - 0.15;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.1);\nfloat frc = sminC(f1,f2,0.1);\n\n// panel connect\nop = vec3(abs(p.x)-0.65, abs(p.y-4.)-0.3,p.z);\nfloat r1 = length(op)-0.03;\nfloat r2 =  length(vec3(p.x, abs(p.y-4.)-0.3,abs(p.z)-0.65))-0.03;\nfloat frc1 = min(r1,r2);\n\n// wing connect\nop = vec3(abs(p.x)-6.,p.y-2.,p.z);\nROTX(op,PI/8.);\nf1 = max(length(op.xy)-0.02,abs(op.z)-.7);\nROTX(op,-PI/4.);\nf2 = max(length(op.xy)-0.02,abs(op.z)-.7);\nfloat frc2 = min(f1,f2);\n\n// forward panel connect\nop = vec3(abs(p.x)-0.5,p.y-8.5,p.z);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.02,blen-0.05);\nop.x -= 0.06;\nop.y = abs(op.y) - 0.06;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.05);\nfloat frc3 = sminC(f1,f2,0.05);\n    \n// hex\nop = vec3(p.x, p.y - 6.7, p.z);\nROTY(op, iTime*.05);\nfloat hfr = max(lenxz - .8, abs(op.y) - 0.5);\nfloat hff = max(length(op.zy) - .2, abs(op.x) - 3.);\nvec2 qf = vec2(hex(op.xz) - 3., op.y); \nhff = sminC(hff, hfr, 0.1);\nfloat hf = sminC(hex(qf) - .6, hff, 0.1);\n    \nvec2 windHex = hexSquares(op.xz, 3.6);\n    \nvec2 hexwind = vec2(max(abs(windHex.x)-0.01, abs(windHex.y)-0.05),op.y);\nhexwind.y = abs(hexwind.y) - 0.2;\nfloat hfwind = max(abs(hexwind.x)-0.08, abs(hexwind.y)-0.07);\nhf = max(hf, -hfwind);\n\nvec2 topHex = hexSquares(op.xz, 3.2);    \nvec2 hextop = vec2(max(abs(topHex.x)-0.3, abs(topHex.y)-0.3),op.y);\nhextop.y = abs(hextop.y) - 0.4;\nfloat hftop = max(abs(hextop.x)-0.08, abs(hextop.y)-0.07);\nhf = max(hf, -hftop);\n\nfloat of = min(min(min(fc1,fc2),fc3),fc4);\nof = min(min(fr2,min(of,fr1)),fr3);\nof = min(min(min(of,fw1),fw2),fw3);\nof = min(of,min(fpr,min(fpw,min(fp4,fpc))));\nof = sminC(of, hf, 0.1);\n    \nof = sminC(of,frc,0.08);\nof = sminC(of,frc1,0.1);\nof = sminC(of,frc2,0.1);\nof = sminC(of,frc3,0.05);\n//of = mix(-of, df,0.54);\n\nreturn of;\n//p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n//p.y -=abs(p.x)*1.5*(2.-p.y);\n}\n\n\n#define T3D_S 64.\n#define T3D_SR 8. // square root of T3D_S\n#define T3D_INV_S 0.015625\n#define T3D_INV_SR 0.125\n\n// Fresnel-Shlick\nfloat F(in float _f0, in vec3 _h, in vec3 _v)\n{\n    float hv = max(dot(_h, _v), 0.);\n    float hv1 = pow(1. - hv, 5.);\n    return _f0 + (1. - _f0) * hv1;\n}\n\nfloat shuttle(in vec3 p,inout vec3 norm, out vec4 col)\n{\nvec3 op = p;\n//p.xz = cos(time)*(p.xz)+ sin(time)*vec2(p.z,-p.x);\nfloat lenxz = length(p.xz);\n\n//cylw\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 2.2;\nfloat brad = length(op.zy);\nfloat blen = abs(op.x);\n//float bli = clamp(pow(blen*0.7,8.),0.,brad*0.2);\nfloat fc1 = max(brad - .8,(blen-1.5+brad*0.8));\n\n//cylwf\nop = p;\nop.y -= 2.;\nop.x = abs(p.x) - 5.;\n\nbrad = length(op.zy);\nblen = abs(op.x);\n\nfloat fc2 = max(brad - .4,(blen-2.));\n\n//central sphere\nop = p - vec3(0.,2.,0.);\nfloat fc3 = length(op) - 0.65;\n\n//wingc\nop = p - vec3(0.,2.,0.);\nfloat f1 = max(length(op.yz)-0.25,abs(op.x)-1.4);\nfloat f2 = max(lenxz-0.25,abs(op.y)-1.4);\nfloat fc4 = min(f1,f2);\n\n//rear1\nop = p - vec3(0.,.85,0.);\nfloat fr1 = max(lenxz-0.6,abs(op.y)-0.5+0.5*lenxz*lenxz);\n\n//rear2\nfloat fr2 = sdVerticalCapsule(p+vec3(0.,0.6,0.),0.6,0.45);\n\n//rear3\nop = p + vec3(0.,.9,0.);\nblen = abs(op.y);\nfloat fr3 = max(lenxz - 0.6 -0.1*pow(blen*2.,8.)*step(0.,-op.y),blen - 0.5);\n\n//forward 1\nop = p - vec3(0.,4.2,0.);\nfloat fw1 = max(lenxz-0.6,abs(op.y)-1.8+1.4*lenxz);\n\n//forward 2\nop = p - vec3(0.,5.7,0.);\nfloat fw2 = max(lenxz-0.9,abs(op.y)-.9+0.35*lenxz*lenxz);\n\n//forward 3+\nop = p - vec3(0.,6.7,0.);\nfloat rad = lenxz;\nf2 = max(rad-0.8,abs(op.y)-.4);\nop.y +=0.3;\nfloat f3 = max(rad - 0.7,abs(op.y)-.8);\nop.y -=1.35;\nfloat f4 = max(rad - .7,abs(op.y)-.6 +0.5*rad);\nop.y += 0.7;\nfloat f5 = max(rad - .3,abs(op.y)-.6);\nop.y -= 1.3;\nfloat f6 = max(rad - .5,abs(op.y)-.4);\nfloat fw3 = min(min(min(min(f3,f2),f4),f5),f6);\n\n//solar panel rear\nop = vec3(abs(p.x)-1.9,p.y+.94,p.z);\nfloat fpr = sdBox(op,vec3(1.,0.36,.02));\n\n// solar panel wing center\nop = vec3(abs(p.x)-6.,p.y-2.,abs(p.z) - 2.);\nfloat fpc = sdBox(op,vec3(0.02,0.5,1.4));\n\n//solarop = vec3(p.x,p.y-4.,abs(p.z)-2.1); panel forward\nop = vec3(abs(p.x)-1.3,p.y-8.5,p.z);\nfloat fpw = sdBox(op,vec3(.7,0.2,.02));\n\n// solar panel c4\nop = vec3(p.x,p.y-4.,abs(p.z)-2.1);\nfloat ft = sdBox(op,vec3(0.02,0.7,1.4));\n\nop = vec3(abs(p.x)-2.1,p.y-4.,p.z);\nfloat fp4 = min(ft,sdBox(op,vec3(1.4,0.7,0.02)));\n\n// rear panel connect\nop = vec3(abs(p.x)-0.68,p.y+.95,p.z);\nfloat lenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.05,blen-0.1);\nop.x -= 0.17;\nop.y = abs(op.y) - 0.15;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.1);\nfloat frc = sminC(f1,f2,0.1);\n\n// panel connect\nop = vec3(abs(p.x)-0.65, abs(p.y-4.)-0.3,p.z);\nfloat r1 = length(op)-0.03;\nfloat r2 =  length(vec3(p.x, abs(p.y-4.)-0.3,abs(p.z)-0.65))-0.03;\nfloat frc1 = min(r1,r2);\n\n// wing connect\nop = vec3(abs(p.x)-6.,p.y-2.,p.z);\nROTX(op,PI/8.);\nf1 = max(length(op.xy)-0.02,abs(op.z)-.7);\nROTX(op,-PI/4.);\nf2 = max(length(op.xy)-0.02,abs(op.z)-.7);\nfloat frc2 = min(f1,f2);\n\n// forward panel connect\nop = vec3(abs(p.x)-0.5,p.y-8.5,p.z);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf1 = max(lenyz-.02,blen-0.05);\nop.x -= 0.06;\nop.y = abs(op.y) - 0.06;\nROTZ(op,PI/3.);\nlenyz = length(op.yz);\nblen = abs(op.x);\nf2 = max(lenyz-0.02,blen-0.05);\nfloat frc3 = sminC(f1,f2,0.05);\n\n// hex\nop = vec3(p.x, p.y - 6.7, p.z);\nROTY(op, iTime*.05);\nfloat hfr = max(lenxz - .8, abs(op.y) - 0.5);\nfloat hff = max(length(op.zy) - .2, abs(op.x) - 3.);\nvec2 qf = vec2(hex(op.xz) - 3., op.y); \nhff = sminC(hff, hfr, 0.1);\nfloat hf = sminC(hex(qf) - .6, hff, 0.1);\n    \nvec2 windHex = hexSquares(op.xz, 3.6);\n    \nvec2 hexwind = vec2(max(abs(windHex.x)-0.01, abs(windHex.y)-0.05),op.y);\nhexwind.y = abs(hexwind.y) - 0.2;\nfloat hfwind = max(abs(hexwind.x)-0.08, abs(hexwind.y)-0.07);\nhf = max(hf, -hfwind);\n\nvec2 topHex = hexSquares(op.xz, 3.2);    \nvec2 hextop = vec2(max(abs(topHex.x)-0.3, abs(topHex.y)-0.3),op.y);\nhextop.y = abs(hextop.y) - 0.4;\nfloat hftop = max(abs(hextop.x)-0.08, abs(hextop.y)-0.07);\nhf = max(hf, -hftop);\n\nfloat of = min(min(min(fc1,fc2),fc3),fc4);\nof = min(min(fr2,min(of,fr1)),fr3);\nof = min(min(min(of,fw1),fw2),fw3);\nof = min(of,min(fpr,min(fpw,min(fp4,fpc))));\nof = sminC(of, hf, 0.1);\n    \nof = sminC(of,frc,0.08);\nof = sminC(of,frc1,0.1);\nof = sminC(of,frc2,0.1);\nof = sminC(of,frc3,0.05);\n//of = mix(-of, df,0.54);\n\nif ((of == fpr) && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-0.95,p.y+.94)/vec2(2.,0.72);\n   vec2 nuv = panelNormal(fract(uof*5.));\n   norm *= vec3(nuv.x,0.,nuv.y);\n   col = vec4(0.12,0.,0.23, .8);\n\n} else if ((of == fpw) && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-0.65,p.y-8.5)/vec2(1.4,0.4);\n   vec2 nuv = panelNormal(fract(uof*5.));\n   norm *= vec3(nuv.x,0.,nuv.y);\n   col = vec4(0.12,0.,0.23, 0.2);\n} else if (of==fp4 && abs(norm.z) > 0.5) {\n   vec2 uof = vec2(abs(p.x)-2.1,p.y-4.)/vec2(1.4,0.7);\n   norm = panelNormal3(fract(uof*3.))*sign(norm);\n   col = vec4(0.12,0.,1.23, 0.9);\n} else if (of==fp4 && abs(norm.x) > 0.5) {\n   vec2 uof = vec2(abs(p.z)-2.1,p.y-4.)/vec2(1.4,0.7);\n   norm.zyx = panelNormal3(fract(uof*3.))*sign(norm.x);\n   col = vec4(0.12,0.,1.23, 0.9);\n} else if (of==fpc && abs(norm.x) > 0.5) {\n   vec2 uof = vec2(abs(p.z) - 2.,p.y-2.)/vec2(1.4,0.5);\n   vec2 nuv = panelNormal(fract(uof*5.))*sign(norm.x);\n   norm = vec3(nuv.y,nuv.x,0.2);\n   col = vec4(0.12,0.,0.23, 0.8);\n} else if (of == fc2) {\n   vec2 uof = vec2(abs(p.x)-5.,p.y-2.);\n   float ang = 0.5*(atan(p.z,uof.y)/PI)+0.5;\n   float h = clamp((abs(p.x) - 3.)/6.,0.,1.);\n   float fnoise = noise2d(vec2(h, ang)*20., vec2(20.));\n   col = vec4(0.4,0.6,0.8, 0.2)*(1.+fnoise*0.1);\n   col.w = .5;\n} else if (of == fc1) {\n   vec2 uof = vec2(abs(p.x)-2.2,p.y-2.);\n   float ang = 0.5*(atan(p.z,uof.y)/PI)+0.5;\n   float h = clamp((abs(p.x) - 1.4)/1.6,0.,1.);\n   vec2 uv = vec2(ang,h);\n   vec3 v1 = vec3(1.,0.,0.);\n   vec3 v2 = cross(norm,v1);\n   vec2 cuv = vec2(uv.x*16.,uv.y*3.);\n   vec3 nnorm = noiseNorm(uv*100.);\n   vec3 anorm = panelNormal3(fract(cuv));\n   //vec3 cnorm = dCirculNorm(fract(cuv),vec2(4.,6.));\n\n   norm = (mat3(v1,v2,norm)*(anorm+nnorm));\n\n   col = vec4(0.88,0.88,0.91, 0.4);\n   //norm = vec3(1.);\n} else if (of == fc4) {\n   col = vec4(0.5,0.52,0.2, .3);\n} else if (of == fw2) {\n   vec2 uof = vec2(p.x,p.y-5.7);\n   float ang = 0.5*(atan(p.z,p.x)/PI)+0.5;\n   float h = clamp((abs(p.y) - 5.2)/1.,0.,1.);\n   vec2 uv = vec2(ang,h);\n   vec3 v1 = vec3(0.,1.,0.);\n   vec3 v2 = cross(norm,v1);\n   vec2 cuv = vec2(uv.x*16.,uv.y*4.);\n   vec3 anorm = panelNormal3(fract(cuv));\n   vec3 nnorm = noiseNorm(uv.yx*100.);\n   //vec3 cnorm = dCirculNorm(fract(cuv),vec2(4.,6.));\n\n   norm = mat3(v1,v2,norm)*(anorm+nnorm);\n   col = vec4(0.5,0.6,0.87, 0.5);\n} else if (of == fw1) {\n    vec3 uop = p - vec3(0.,4.2,0.);\n    float h = clamp((uop.y+1.5)/3., 0., 1.);\n    float ang = 0.5*(atan(uop.z, uop.x)/PI) + 0.5;\n    vec3 v1 = normalize(vec3(p.x, 0., p.z));\n    vec3 v2 = vec3(0., 1., 0.);\n    vec3 v3 = cross(v1, v2);\n    \n    vec3 anorm = pattNorm(vec2(ang, h));\n    norm = mat3(v3, v2, v1)*anorm;\n    col = vec4(0.5,0.6,0.87, 0.2);\n} else {\n   /*vec3 rp = p + vec3(10.);\n    \n   vec3 cube = mod(rp*T3D_INV_S,1.);\n    \n   vec2 ccoord0 = vec2(floor(cube.z*T3D_SR)*T3D_INV_SR, \n                       floor(T3D_SR*mod(cube.z, T3D_INV_SR))*T3D_INV_SR );\n   \n   vec2 ccoord1 = vec2(floor((cube.z+T3D_INV_S)*T3D_SR)*T3D_INV_SR, \n                       floor(T3D_SR*mod((cube.z+T3D_INV_S), T3D_INV_SR))*T3D_INV_SR );\n    \n   vec3 cl0 = texture(iChannel0, ccoord0 + cube.xy).xyz;\n   vec3 cl1 = texture(iChannel0, ccoord1 + cube.xy).xyz;\n   float interpF = mod(cube.z,T3D_INV_S);*/\n\n   col = vec4(0.7,0.7,0.7, 0.2);\n   \n   //col = texture(iChannel0, vec2(0.5) + p.xz*.1);\n   //col = vec4(mix(cl0, cl1, interpF), 1.2);\n}\n\nreturn of;\n//p.xz = cos(time)*p.xz+ sin(time)*vec2(p.z,-p.x);\n//p.y -=abs(p.x)*1.5*(2.-p.y);\n}\n\nconst vec4 planet_center = vec4(-15., -6., -3., 24.);\nconst vec4 dust_center = vec4(-5., 6., -1., 24.);\n\n\n#define FAR 80.\n#define VOL_FOG_STEP .25\n\nfloat bshuttle(vec3 p)\n{\n    return sdBox(p, vec3(4., 7., 4.));\n}\n\nvec2 geom(in vec3 p, in vec3 o, in vec3 d)\n{\n    vec2 t_vec;\n    \n    vec3 bboxsh3 = vec3(7., 9., 4.);\n    vec2 bboxsh = boxIntersection(o, d, -bboxsh3, bboxsh3);\n    if (bboxsh.y > 0.)\n    {\n        t_vec.x = shuttle(p);\n    }\n    \n    vec2 res = vec2(FAR, -1.);\n    \n    for (int i_t = 0; i_t < 1; i_t++)\n    {\n        if (t_vec.x < res.x)\n        {\n            res.x = t_vec.x;\n            res.y = 0.;\n        }\n    }\n        \n    return res;\n}\n\nvec3 getCentralDiffShuttle(vec3 o, vec3 d, float t)\n{\n    vec3 norm;\n    vec3 e = vec3(0.00001, 0.0, 0.0)*t;\n\n    vec3 p = o + t*d;\n\n    norm.x = shuttle(p + e.xyy) - shuttle(p - e.xyy);\n    norm.y = shuttle(p + e.yxy) - shuttle(p - e.yxy);\n    norm.z = shuttle(p + e.yyx) - shuttle(p - e.yyx);\n\n    norm = normalize(norm);\n    \n    return norm;\n}\n\nvec4 trace(in vec3 o, in vec3 d)\n{\n    float threshold = 0.0001;\n    // vec4(final distance, current distance, nearest distance, geom type);\n    vec4 res = vec4(0., FAR, FAR, 10.);\n    for (int i=0;i<192;i++)\n    {\n       vec3 p = o + res.x*d;\n       \n       res.yw = geom(p, o, d);\n       res.z = min(res.z, res.y);\n       res.x += res.y;\n\n       if (res.y < threshold*res.x || res.x > FAR) \n       {\n           threshold *= res.x;\n           break;\n       }\n    }\n    \n    return res;\n}\n\nvec4 vol_trace(in vec3 o, in vec3 d, in vec3 res_t, in vec4 volbox, \n    in vec3 baseCol, in sampler2D channel, in float rotation)\n{\n    float vol_steps = 0.;\n    float valpha = 0.;\n    float vol_acc = 0.;\n    vec3 vol_col = vec3(0.);\n    float threshold = 0.0001*res_t.x;\n    float space_t = step(threshold, res_t.y);\n    \n    float v_dist = space_t*FAR + (1.-space_t)*res_t.x;\n    vol_steps = (v_dist / VOL_FOG_STEP)*(exp(-res_t.z*.001));\n    \n    vec2 t_box = boxIntersection(o, d, volbox.xyz - volbox.w, \n                                       volbox.xyz + volbox.w);\n    \n    vec3 so = o + t_box.x * d;\n    \n    vec3 bmin = volbox.xyz - vec3(volbox.w);\n    vec3 bmax = volbox.xyz + vec3(volbox.w);\n    \n    for (float t_s = max(t_box.x, 0.0); t_s < t_box.y && t_s < v_dist; t_s += VOL_FOG_STEP)\n    {\n        vec3 vp = o + t_s * d;\n        \n        vec3 coord = (vp - bmin) / (bmax - bmin);\n\n        float density = layer_trillinear(coord.xzy, channel, rotation);\n        float ns = (1. + 0.5*hash(vp));\n        valpha = ns*density*VOL_FOG_STEP;\n        vol_col = valpha*baseCol + (1.-valpha)*(vol_acc);\n        vol_acc = valpha + (1. - valpha)*(vol_acc);\n        \n        if (vol_acc > 0.98)\n            break;\n    }\n    \n    return vec4(vol_col, vol_acc);\n}\n\nvoid cameraSetup(inout vec3 o, inout vec3 d)\n{\n    o.y = 20. + 20.*sin(iTime*0.2);\n    float r = 2. + min(0., 0.5*o.y);\n    o = vec3(6. + sin(iTime),o.y, 6. + cos(iTime));\n    vec3 target = vec3(0., 10.*sin(iTime*0.065), 0.);\n    target = mix(target, vec3(planet_center.x, 0., 0.), pow(cos(0.25*iTime)*0.5+0.5, 8.));\n    target = mix(target, dust_center.xyz, pow(cos(0.25*iTime)*0.5+0.5, 8.));\n    d = camera(o, d, target);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if (iResolution.y > iResolution.x)\n       uv.y *= iResolution.y/iResolution.x;\n    else\n       uv.x *= iResolution.x/iResolution.y;\n\n    float ratio = iResolution.x / iResolution.y;\n    vec3 o = vec3(sin(iTime),15.,10.);\n    vec3 d = normalize(vec3(vec2(ratio - 1., -1.) +vec2(1., 2.)*(uv-vec2(0.5 + 0.5*sin(iTime*0.25),0.)),-1.));\n    \n    vec3 col;\n    \n    \n    float threshold = 0.0001;\n    vec4 res_t;\n    vec4 planet_col;\n    vec4 dust_col;\n    vec4 vol_col;\n    \n    cameraSetup(o, d);\n\n    res_t = trace(o, d);\n    threshold *= res_t.x;\n    \n\t// volumetric step\n    planet_col = vol_trace(o, d, res_t.xyz, planet_center, \n              vec3(0.886, .634, .186), iChannel1, 0.05 * (iMouse.x/iResolution.x));\n    //dust_col = vol_trace(o, d, res_t.xyz, dust_center, \n     //         vec3(0.34, 0.12, 0.74), iChannel2, 0.03);\n    \n    vol_col = planet_col;//mix(dust_col, planet_col, planet_col.w);\n    \n    if (res_t.y < threshold && res_t.w < 0.5)\n    {\n       vec3 specCol;\n       vec3 p = o + res_t.x*d;\n       vec4 bc;\n        \n       vec3 norm = getCentralDiffShuttle(o, d, res_t.x);\n\t   shuttle(p,norm,bc);\n       \n       float ns = mix(0.2*(noise3(p*14.12)-0.5), 0., step(0.35, bc.w));\n       \n       vec3 ldir = normalize(p - planet_center.rgb);\n       vec3 h = normalize(ldir - d);\n       float spc = F(bc.w, h, d) * max(dot(ldir, -norm), 0.0);\n       \n       vec3 rd = reflect(d, normalize(norm + vec3(ns)));\n       \n       vec3 bckCol = background(o, rd);\n      \n      col += 0.7*bc.xyz*(dot(-norm,d));\n      specCol = 0.3*bc.w*vec3(256.*exp(-res_t.x))*\n          clamp(pow(max(0., dot(reflect(d, norm), -d)),8.), 0., 1.);\n      \n      col = mix(col, bckCol, bc.w);\n      col = clamp(col + specCol, 0., 1.);\n    } else\n    {\n       col = background(o, d);\n    }\n\n\n    col = mix(col, vol_col.xyz, vol_col.w);\n\n    fragColor = vec4(pow(col, vec3(2.2)), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float rflag = 0.;\n    if (int(fragCoord.x) == 1 && int(fragCoord.y) == 0)\n    {\n        rflag = 1./iResolution.x;\n    }\n    fragColor = vec4(rflag,0.0,1.0,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}