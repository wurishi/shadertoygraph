{"ver":"0.1","info":{"id":"fsdGR4","date":"1629256630","viewed":60,"name":"Polar Texture Disk Intersection ","username":"Yusef28","description":"For just a disk intersection you can check this out: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nor this https://www.shadertoy.com/view/lsfGDB\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["triangle","intersection","barycentric"],"hasliked":0,"parentid":"7sd3R8","parentname":"Triangle Intersection + BaryC"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 17-08-2021                                  //\n// Status: On-going                                        //\n// Topic: Disk Intersection + Text                         //\n// Sources:https: www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\n// Listening to:Best post-rock songs of 2020               //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n\n#define Samples 20.\n#define bounces 1.\n\n#define pi 3.14159\n\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 n, vec3 pop){\n\n    //first of all, if the dot of the rd and n is ... nvm\n    //if(dot(rd,n) > 0.9999) return -1.;\n    //dot(vector in plane with normal) = zero (orthogonal)\n    //(p-pointinplane)*n = 0\n    \n    //ray origin + rd at time t is point\n    //p = ro + rd*t;\n    \n    //what time t is p from eq 1 = p in eq 2\n    //(ro + rd*t - pointinplane)*n = 0\n    \n    //rearange to get some time alone\n    //float t = (dot(pop,n) - dot(ro,n)) / dot(rd,n);\n    \n    //we can do better than that, factor out n from top \n    return dot(pop-ro,n) / dot(rd,n);\n}\n\n/*\n\n//First try based on the triangle intersection and barycentric\n//coordinates\nvec3 iDisk(vec3 ro,vec3 rd,vec3 A,vec3 B,vec3 Center){\n\n    float t;\n    vec2 uv;\n    \n    //if there isn't a hit we give backa  t of -1., \n    //and a u and v of 0.,0.\n    \n    vec3 no_hit = vec3(-1.,0.,0.);\n    \n    //imagine a triagle with 3 points.\n    //the vector from point a to b\n    vec3 AzuB = normalize(B-A);\n    \n    //from point b to c\n    vec3 BzuC = normalize(Center-B);\n    \n    //usw\n    vec3 CzuA = normalize(A-Center);\n    \n    \n    //we use the cross of two of the above vectors\n    //to get a vector perpendicular to both\n    //any two of these holds all three points (a,b,and c)\n    //so the normal of them is the normal of the plane all three\n    //points lie in\n    vec3 planeN = cross(AzuB,BzuC);\n    \n    //so we find the intersection of that plane\n    t = iPlane(ro,rd,planeN,A);\n    \n    //and get the hit point\n    vec3 point_on_plane = ro + rd*t;\n    \n    //and return no hit if the t negative meaning it's behind us\n    if(t < 0.)\n        return no_hit;\n\n    // most of this code is from the triangle intersection\n    //and barycentric coordinates\n    //I am just modifying to hit whenever the distance to our\n    //specified disk cetner is less than 2.\n    float lange = length(point_on_plane-Center);\n    if( lange > 2.)\n        return no_hit;\n    \n    //another mod from the barycentric coordinates\n    //I just use the same two coordinates which are now\n    //the x and y on the plane oriented by the normal\n    float x = dot(planeN, cross(BzuC, point_on_plane-B ) );\n    float y = dot(planeN, cross(CzuA, point_on_plane-Center ) );\n    \n    //this is the usual way to get polar coordinates \n    float u = atan(y,x);\n    float v = lange;\n    \n\n    return vec3(t,u,v);\n}\n\n*/\n\n//second try since the first one didn't allow me to make\n//usable texture coordinates\n//Here I create a basis (3 orthogonal vectors)\n//based on the plane normal\n//then I get the vector from center to hit point(call it CP)\n//then I take the dot(CP,basisUP) as y\n//and dot(CP,basisRIGHT) as x\n//then convert to polar and return.\n//I think the first method might actually be ok\n//now looking at it again. The main issue is in main heh\n// in  main I rotate the normal and center. I have to \n//rotate them by the same amount on the same axis\n//or else I get the same issue as in the first try.\nvec3 iDisk2(vec3 ro, vec3 rd, vec3 normal, vec3 Center){\n\n    float t;\n    vec2 uv;\n    \n    //if there isn't a hit we give backa  t of -1., \n    //and a u and v of 0.,0.\n    \n    vec3 no_hit = vec3(-1.,0.,0.);\n    \n    //trying something like this\n    //https://www.shadertoy.com/view/4tySz1\n    //I think the idea is creating a basis from the normal\n    //and then projecting the vector form centerto hit point\n    //onto the right and up of that basis.\n    //to get coordinates I mean\n    \n    vec3 uu = vec3(0.,1.,0.); \n    vec3 right = cross(normal,uu);\n    vec3 up = cross(right,normal);\n    \n    //we use the cross of two of the above vectors\n    //to get a vector perpendicular to both\n    //any two of these holds all three points (a,b,and c)\n    //so the normal of them is the normal of the plane all three\n    //points lie in\n    \n    //so we find the intersection of that plane\n    t = iPlane(ro,rd,normal,right);\n    \n    //and get the hit point\n    vec3 point_on_plane = ro + rd*t;\n    vec3 center_to_hit = point_on_plane - Center;\n    \n    //and return no hit if the t negative meaning it's behind us\n    if(t < 0.)\n        return no_hit;\n\n    // most of this code is from the triangle intersection\n    //and barycentric coordinates\n    //I am just modifying to hit whenever the distance to our\n    //specified disk cetner is less than 2.\n    float lange = length(point_on_plane-Center);\n    if( lange > 2.)\n        return no_hit;\n    \n    //another mod from the barycentric coordinates\n    //I just use the same two coordinates which are now\n    //the x and y on the plane oriented by the normal\n    float x = dot(up,normalize(center_to_hit));\n    float y = dot(right,normalize(center_to_hit));\n    \n    //this is the usual way to get polar coordinates \n    float u = atan(y,x);\n    float v = lange;\n    return vec3(t,u,v);\n}\n\nfloat checker(vec2 st){\n    return mod(floor(st.x)+floor(st.y),2.);\n}\n\nmat2 rot(float a){\n    float si = sin(a);\n    float cs = cos(a);\n    \n    return mat2(cs,-si,si,cs);\n}\n\nvec3 grid_design(vec2 uv){\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    \n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(1.);\n    float a = iTime/4.;\n    vec3 ro = vec3(6.*cos(a), 0., 6.*sin(a));\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 fwd = normalize(ta - ro);\n    vec3 uu = vec3(0., -1., 0.);\n    \n    vec3 right = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(right,fwd));\n    \n    float focal = 1.52;\n    \n    vec3 rd = right*uv.x + up*uv.y + fwd*focal;\n    \n    vec3 planeN = vec3(0., 1., 0.);\n    vec3 point_on_plane = vec3(0., -1., 0.);\n    \n    float t = iPlane(ro, rd, planeN, point_on_plane);\n    \n    if(t >= 0.){\n        vec3 pos = ro + rd*t;\n        col = grid_design(pos.xz/10.5);\n    }\n    \n    vec3 cPos = vec3(0., 0., 0.);\n    float r = 1.;\n    \n    vec3 A = vec3(-1.,1.,0.);\n    A.xy*=rot(iTime);\n    //vec3 B = vec3(1.,0.,0.);\n    //B.zx*=rot(iTime);\n    vec3 Center = vec3(0.,2.,0.);\n    Center.xy*=rot(iTime);\n    //vec3 t_and_uv = iDisk(ro,rd,A,B,Center);\n    \n    \n    vec3 t_and_uv = iDisk2(ro,rd,A,Center);\n    \n    if(t_and_uv.x >= 0.){\n            \n        vec3 tex = texture(iChannel0, t_and_uv.yz).xyz;\n        col = tex;\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}