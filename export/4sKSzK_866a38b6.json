{"ver":"0.1","info":{"id":"4sKSzK","date":"1465409337","viewed":317,"name":"2D Blob Effect","username":"daseyb","description":"https://pay.reddit.com/r/opengl/comments/4n5k1x/need_help_identifying_shader_effect/","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////\n// Settings\n////////////////////////\n#define GRADIENT_FALL_OFF 0.02\n#define GRADIENT_MOVEMENT_SPEED 0.0\n#define SOLID_INSIDE true\n#define COLOR_INSIDE vec3(32.0/255.0, 72.0/255.0, 211.0/255.0)\n\nvec3 GET_COLOR(int index) {\n    if(index == 0) {\n    \treturn vec3(32.0/255.0, 72.0/255.0, 211.0/255.0);\n    } else if(index == 1) {\n        return vec3(211.0/255.0, 72.0/255.0, 32.0/255.0);\n    } else {\n        return vec3(32.0/255.0, 211.0/255.0, 72.0/255.0);   \n    }\n}\n\n\n// I recommend http://mercury.sexy/hg_sdf/ for more primitives and operations.\n////////////////////////\n// Utility Methods\n////////////////////////\n\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define PI 3.14159265\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);   \n}\n\nstruct MinPoint {\n    float dist;\n    int matId;\n};\n\n////////////////////////\n// Operations\n////////////////////////\nMinPoint opUnion(MinPoint d1, MinPoint d2) {\n    if(d1.dist < d2.dist)\n        return d1;\n    else\n        return d2;\n}\n\nMinPoint opUnionSoft(MinPoint a, MinPoint b, float r) {\n\tfloat e = max(r - abs(a.dist - b.dist), 0.0);\n    MinPoint res = opUnion(a,b);\n    res.dist = min(a.dist, b.dist) - e*e*0.25/r;\n\treturn res;\n}\n\n\n////////////////////////\n// Primitives\n////////////////////////\nMinPoint sdCircle (vec2 p, vec2 pos, float r, int matId) {\n\treturn MinPoint(length(p - pos) - r, matId);\n}\n\n\n////////////////////////\n// Scene\n////////////////////////\n// EDIT THIS TO CHANGE WHAT'S BEING RENDERED\nMinPoint scene(vec2 p) {\n\n    MinPoint staticD = sdCircle(p, iResolution.xy * vec2(0.4, 0.5), 80.0 + cos(iTime * 10.0) * 4.0, 0);\n    staticD = opUnion(staticD, sdCircle(p, iResolution.xy * vec2(0.6, 0.5), \n                                        40.0 + sin(iTime * 10.0) * cos(2.0 + iTime * 3.0) *4.0, 1));\n    \n    \n    return opUnionSoft(\n                   staticD,\n                   sdCircle(p, iMouse.xy, 40.0, 2), 40.0 + sin(iTime*10.0) * 20.0);\n}\n\n////////////////////////\n// Visualization\n////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\tvec2 uv = fragCoord.xy;\n    MinPoint minp = scene(uv);\n    float dist = minp.dist;\n    float absDist = abs(dist);\n    vec3 finalColor;\n    \n    \n    vec3 white = vec3(1, 1, 1);\n    vec3 black = vec3(0, 0, 0);\n\n    vec3 colorOutside = mix(white, black,  1.0 - exp(-20.0 * dist * GRADIENT_FALL_OFF));\n    \n    float insideFalloffMultiplier = (sin(iTime*10.0) + 2.0) * 3.0;\n    vec3 colorInside = mix(GET_COLOR(minp.matId), vec3(0, 0, 0),  1.0 - exp(insideFalloffMultiplier * dist * GRADIENT_FALL_OFF)); \n\n    finalColor = dist < 0.0 ? colorInside : colorOutside;\n\n    finalColor = mix(white, finalColor, smoothstep(0.0, 4.0, absDist));\n    \n    finalColor = clamp(finalColor, vec3(0, 0, 0), vec3(1, 1, 1));    \n\n    \n\tfragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}