{"ver":"0.1","info":{"id":"wt2SDR","date":"1565723795","viewed":275,"name":"pt-7: heterogeneous volume","username":"wuerzig","description":"path tracing a heterogeneous volume (wrt. extinction coefficient, single scattering albedo) \nscattering phase function is isotropic","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["volume","pathtracing","pathtracer","path","participating","medium","heterogeneous"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The rendering happens in the \"Buffer A\" tab ;)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec3 col = texture(iChannel0, uv).xyz;\n    col /= float(iFrame);\n    \n    // over-expose by 1.0EV\n    col *= pow(2.0, 1.0);\n\n    //col = 1.0 - exp2(-col * 3.0);\n    //col = mix(col, col*col, 0.8);\n\n    col = clamp(col, 0.0, 1.0);\n    col = pow(col, vec3(1.0 / 2.2));\n\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define EPSILON 0.00005\n\n#define BOUNCES_MEDIUM 15\n\n\n// MAX used for Woodcock Tracking\n#define SIGMA_T_MAX 5.0\n#define SIGMA_T_1 5.0\n#define SIGMA_T_2 0.4\n\n/*#define ALBEDO_1 vec3(0.99, 0.1, 0.1)\n#define ALBEDO_2 vec3(0.4, 0.99, 0.4)\n#define ALBEDO_3 vec3(0.1, 0.1, 0.99)\n#define ALBEDO_4 vec3(0.9999, 0.9999, 0.9999)*/\n\n#define ALBEDO_1 vec3(0.1, 0.1, 0.1)\n#define ALBEDO_2 vec3(0.625, 0.824, 0.32)\n#define ALBEDO_3 vec3(0.999, 0.93, 0.29)\n#define ALBEDO_4 vec3(0.9999, 0.9999, 0.9999)\n\n#define PI 3.1415927\n\n\nfloat time;\n\nvec3 slerp(vec3 start, vec3 end, float percent) {\n     float dot = dot(start, end);     \n     dot = clamp(dot, -1.0, 1.0);\n     float theta = acos(dot)*percent;\n     vec3 RelativeVec = normalize(end - start*dot); // Orthonormal basis\n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\n// ------------------------------- taken from https://www.shadertoy.com/view/wljXDz\nuint randomState = 4056649889u;\nconst float invMax24Bit = 1.0 / float(0xffffff);\nuint SmallHashA(in uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u ^\n            ((seed*seed) * 4000000007u);\n}\nfloat RandFloat() {\n    randomState = SmallHashA(randomState);\n    return float((randomState>>8) & 0xffffffu) * invMax24Bit;\n}\nvoid SetRandomSeed(in vec2 fragCoord, in vec2 iResolution,\n                  in int iFrame, in bool hashedSeed) {\n    uint primex = max(uint(iResolution.x), 5003u);\n    randomState = uint(fragCoord.x);\n    randomState += uint(fragCoord.y) * primex;\n    randomState += uint(iFrame) * primex * uint(iResolution.y);\n    if (hashedSeed) {\n        RandFloat();\n    }\n}\n// --------------------------------END pseudo random number generator\n\n#define rand RandFloat\n\nvec3 cosWeightedRandomHemisphereDirection3(const vec3 n) {\n\t\n    vec2 rv2;\n    rv2.x = rand();\n    rv2.y = rand();\n    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));\n\tvec3  vv = cross(uu, n);\t\n    \n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831 * rv2.x); \n\tfloat ry = ra*sin(6.2831 * rv2.x);\n\tfloat rz = sqrt(1.0 - rv2.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n\n    return normalize(rr);\n}\n\nvec3 randomDirection() {\n    float r1 = rand();\n    float r2 = rand();\n    return normalize(\n        \t\tvec3(\n        \t\t\t2.0*cos(2.0*PI*r1)*sqrt(r2*(1.0-r2)),\n        \t\t\t2.0*sin(2.0*PI*r1)*sqrt(r2*(1.0-r2)),\n        \t\t\t1.0-2.0*r2\n        \t\t)\n    \t\t);\n}\n\n// random direction on hemisphere centered around normal\nvec3 randomHemi(vec3 normal) {\n\tvec3 guess = randomDirection();\n    float negate = step(0., dot(normal, guess))*2.-1.;\n    return guess * negate;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n\nfloat map(in vec3 p) {\n\tfloat res;\n    res = sdBox(p, vec3(2.0));\n    //res = sdSphere(p, 3.0);\n    return res;\n}\n\nvec3 dfNormal( in vec3 p ) {\n\tvec3 eps = vec3(EPSILON, 0.0, 0.0);\n\tvec3 res = vec3(\n\t    map(p+eps.xyy) - map(p-eps.xyy),\n\t    map(p+eps.yxy) - map(p-eps.yxy),\n\t    map(p+eps.yyx) - map(p-eps.yyx));\n\treturn normalize(res);\n}\n\n\nint intersect( in vec3 ro, in vec3 rd, out float resT, out vec3 normal ){\n\t\n    // first step\n    float t = 100.0*EPSILON;//0.05;\n    float stepsize = 0.0;\n    vec3 p;\n    int res = 0;\n    int i;\n    for (i = 0; i < 512; i++) {\n        p = ro + t*rd;\n        float d = map(p);\n        if (abs(d) < EPSILON) {\n        \t// hit something\n            res = 1;\n            break;\n        }\n        stepsize = abs(d)*1.0;\n        t += stepsize;\n        \n    }\n    resT = t;\n    normal = dfNormal(ro+rd*t);\n    return res;\n\n}\n\nfloat getSigmaT(vec3 p) {\n    if (p.y < 0.0) {\n        return SIGMA_T_1;\n    } else {\n        return SIGMA_T_2;\n    }\n}\n\nvec3 getAlbedo(vec3 p) {\n    if (p.z < 0.0)\n        return p.x < 0.0 ? ALBEDO_1 : ALBEDO_2;\n\telse\n        return p.x < 0.0 ? ALBEDO_3 : ALBEDO_4;\n    \n}\n\nfloat getAlbedo(vec3 p, int channel) {\n\tvec3 a = getAlbedo(p);\n    if (channel == 0)\n        return a.x;\n    if (channel == 1)\n        return a.y;\n    if (channel == 2)\n        return a.z;\n}\n\n// sample a distance in a (heterogeneous) medium using Woodcock Tracking\n// p...point of origin of ray\n// d...direction of ray\n// sigmaT_max... maximum extinction coefficient in medium\n//               sigma_t=sigma_s+sigma_a\nfloat sampleDistance(vec3 p, vec3 d, float sigmaT_max) {\n\tfloat t;\n    t = 0.0;\n    while (true) {\n    \tt += -log(1.0 - rand()) / sigmaT_max;\n        if (rand() < getSigmaT(p + t * d) / sigmaT_max)\n            break;\n    }\n    return t;\n    \n}\n\nmat3 makeCam( in vec3 origin, in vec3 target) {\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 lookVec = normalize(target-origin);\n\tvec3 right = normalize(cross(lookVec, worldUp));\n\tvec3 camUp = normalize(cross(right, lookVec));\n    return mat3(right, camUp, lookVec);\n}\n\n// estimate transmittance on a ray r=p+t*d from t=0 to t=intersect_t\n// using a few Monte Carlo samples of Woodcock tracking\nfloat estimateTransmittance(vec3 p, vec3 d, float intersect_t, float sigmaT_max) {\n\tint n_samples = 5;\n    float t;\n    float result = 0.0;\n    for (int i = 0; i < n_samples; i++) {\n\t\t\n    \tt = 0.0;\n    \twhile (true) {\n\t    \tt += -log(1.0 - rand()) / sigmaT_max;\n            if (t >= intersect_t) {\n                result += 1.0;\n                break;\n            }\n            if (rand() < getSigmaT(p + t * d) / sigmaT_max)\n        \t    break;\n    \t}\n    }\n    return result / float(n_samples);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    SetRandomSeed(fragCoord, iResolution.xy, iFrame, true);\n    \n    vec3 rayStart;\n    vec3 rayDirection;\n    vec3 camTarget;\n    vec2 point;\n    float maxt;\n\tvec3 normal;\n \n    vec3 energy = vec3(0.0);\n    vec3 throughput = vec3(1.);\n    vec3 col = vec3(1.0);\n    \n\tcamTarget = vec3(0.0, 0.0, 0.0);\n    rayStart = vec3(7.0, 6.0, 7.0);\n    \n   \n    point = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    mat3 cameraMatrix = makeCam(rayStart, camTarget);\n\n    rayDirection = cameraMatrix * normalize(vec3(point.xy,3.0 /*fov*/));\n\n\t// randomly decide what color channel we render right now\n    int channel = int(rand()*3.0);\n\tif (channel == 0)\n\t\tthroughput = vec3(1.0, 0.0 ,0.0);\n\tif (channel == 1)\n\t\tthroughput = vec3(0.0, 1.0 ,0.0);\n\tif (channel == 2)\n\t\tthroughput = vec3(0.0, 0.0 ,1.0);\n    \n    int id = intersect(rayStart, rayDirection, maxt, normal); \n        \n    vec3 intersection = rayStart + rayDirection*maxt;\n        \n    if (id == 0) {\n    \t// didnt hit anything, sample envmap\n        energy += texture(iChannel1, rayDirection).xyz;         \n    } else {\n        // its the cube\n        // reset ray origin to medium boundary plus a bit of epsilon\n        rayStart = intersection + 3.0*EPSILON*rayDirection;\n        \n        for (int k = 0; k < BOUNCES_MEDIUM; k++) {\n            // find maximum t for hitting medium boundary\n            int id_medium = intersect(rayStart, rayDirection, maxt, normal);\n            if (id_medium == 0) {\n                // rare cases of rounding errors around the medium edges\n                energy += throughput*texture(iChannel1, rayDirection).xyz;\n                break;\n            }\n        \n            // sample a distance inside the medium\n            float intersect_t = sampleDistance(rayStart, rayDirection, SIGMA_T_MAX);\n            vec3 medium_intersection = rayStart + rayDirection*intersect_t;\n            \n            if (intersect_t > maxt) {\n                // sampled a distance outside our medium\n                \n                // sample envmap energy\n                vec3 val = texture(iChannel1, rayDirection).xyz;\n                \n                // estimate transmittance of segment\n                float trans = estimateTransmittance(rayStart, rayDirection, maxt, SIGMA_T_MAX);\n                \n                // scale envmap energy with transmittance estimate\n                val *= vec3(trans);\n                energy += val;\n                \n                break;\n            }\n            \n            if (point.x > 1.0) {\n\t            // this is the intuitive way of simulating scattering and absorption:\n    \t        // particles do either scatter or absorb the energy of our path\n        \t    // the propability of that happening is given by the single scattering albedo\n                // it is slightly incorrect in the way we terminate the path as soon as it absorbs\n                if (rand() < getAlbedo(medium_intersection, channel)) {\n                    // scattering\n                    rayStart = medium_intersection;\n                    rayDirection = randomDirection();\n                } else {\n                    // absorption\n                    throughput = vec3(0.0);\n                    break;\n                }\n            } else {\n            \t// this is another way of doing it: scattering occours on all particle interactions\n            \t// the throughput of the path is scaled by \n\t           \tthroughput *= getAlbedo(medium_intersection, channel);\n            \t\n                rayStart = medium_intersection;\n                rayDirection = randomDirection();\n            }\n            \n        }\n        // if we absorbed, also leave outer loop\n    }\n\n    vec3 pxl = energy*throughput;\n\tpxl = clamp(pxl, 0.0, 1.0);\n    pxl *= 3.0; \n\n   \tcol = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n   \tcol += pxl;\n\n    fragColor = vec4( col, 1.0 );\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}