{"ver":"0.1","info":{"id":"MXsXRr","date":"1709109946","viewed":47,"name":"Watch me grow","username":"iNutted","description":"i8","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["i8"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GLSL Fragment Shader: Visualizing AI Compute Power Growth\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time variable represents increasing compute power\n    float computePower = iTime * 0.1; // Slower growth rate for visual effect\n    \n    // Base layer: Simple grid that becomes denser with compute power\n    float gridDensity = 1.0 + computePower * 10.0; // Increasing density\n    vec2 grid = fract(uv * gridDensity) - 0.5;\n    \n    // Compute intensity based on distance from center, modulated by compute power\n    float centerIntensity = length(grid) * computePower;\n    \n    // Overlay: Complex patterns emerge as compute power grows\n    float pattern = sin(dot(uv, vec2(12.9898,78.233)) * (computePower * 20.0));\n    \n    // Combine base and overlay patterns\n    vec3 color = vec3(pattern) * vec3(0.5, 0.7, 1.0) + vec3(centerIntensity * 0.5);\n    \n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}