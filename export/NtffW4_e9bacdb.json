{"ver":"0.1","info":{"id":"NtffW4","date":"1650876847","viewed":66,"name":"a kind of blur","username":"actonmic","description":"da sda sdaf qwe q","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sasda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 centerOffset = vec2(0.0, 0.0); // in pixel\nfloat angle = 60.0;\nfloat alpha = 1.0;\nfloat bias;\n/*\n    value 0.0 1.0 2.0 3.0\n    means min max average close\n*/\nvec4 mode = vec4(1.0,1.0,1.0,1.0);\n\n\nfloat equals(float a, float b){\n    return step(a,b) * step(b,a);\n}\n\nfloat compare(float ori, float new, float mode){\n    return min(ori,new) * equals(0.0, mode)\n            + max(ori,new)* equals(1.0, mode)\n            + (ori + new) * equals(2.0, mode)\n            + ori * step(3.0, mode);\n\n    return ori;\n}\n\n\nvec4 compare(vec4 ori, vec4 new, vec4 mode){\n    return vec4(compare(ori.r,new.r,mode.r),\n        compare(ori.g,new.g,mode.g),\n        compare(ori.b,new.b,mode.b),\n        compare(ori.a,new.a,mode.a));\n\n}\n\nfloat ave(float col, float count,float mode){\n    return mix(col, col / count, equals(mode, 2.0));\n}\n\nvec4 average(vec4 col, vec4 mode, float count){\n    vec4 res = vec4(ave(col.r,count,mode.r),ave(col.g,count,mode.g),ave(col.b,count,mode.b),ave(col.a,count,mode.a));\n    return res;\n}\n\nfloat checkClose(float col,float ori, float mode){\n    return mix(col,ori,step(3.0,mode));\n}\n\nvec4 checkClose(vec4 col, vec4 ori, vec4 mode){\n    return vec4(checkClose(col.r,ori.r,mode.r),\n                checkClose(col.g,ori.g,mode.g),\n                checkClose(col.b,ori.b,mode.b),\n                checkClose(col.a,ori.a,mode.a));\n}\n\n\nvec4 blend_normal(vec4 base, vec4 overlay) {\n    return base + overlay - base * overlay.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec2 center = iResolution.xy / 2.0 + centerOffset;\n\n    // ori\n    vec4 oriCol = texture(iChannel0, pos / iResolution.xy);\n\n    // begin with bias\n    float biasR = -angle / 2.0 - bias * angle / 2.0;\n    pos = rotate(pos,center, -biasR);\n\n    vec4 base = texture(iChannel0, pos / iResolution.xy);\n    base = oriCol;\n    float count = 1.0;\n    \n    //rotate\n    for(float i = 1.0;i <= 60.0; i += 0.5){\n        vec2 p = rotate(pos, center, -i);\n        vec4 new = texture(iChannel0, p / iResolution.xy);\n        base = mix(base,compare(base, new, mode),step(i,angle));\n        count += step(i, angle);\n    }\n\n    //handle overlay rgba\n    base = average(base, mode, count);\n    base = checkClose(base, oriCol, mode);\n    base.rgb *= base.a;\n\n    // blend\n    vec4 nc = mix(oriCol, base, alpha);\n\n    // Output to screen\n    fragColor = nc;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 targetPos = vec2(100.0, 100.0);\nvec2 targetSize = vec2(360.0, 202.5);\nfloat r = 10.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    pos = move(pos, targetPos);\n    pos = rotate(pos, targetSize / 2.0, r);\n    \n    \n    \n    vec2 uv = pos / targetSize.xy;\n    \n    vec4 col = myClampWrap(iChannel0, uv);\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\nvec2 scale(vec2 uv, vec2 center, float s){\n    return center + (uv - center) / s;\n}\n\nvec2 move(vec2 uv, vec2 offset){\n    return uv - offset;\n}\n\nfloat radian(float angle){\n    return angle / 180.0 * PI;\n}\n\nvec2 rotate(vec2 uv, vec2 center, float angle){\n    vec2 res = uv;\n    float r = radian(angle);\n    res = move(uv, center);\n    res = vec2(res.x * cos(r) + res.y * sin(r), res.y * cos(r) - res.x * sin(r));\n    res = move(res, -center);\n    return res;\n}\n\n/*\nreturn 4.0 if uv.x and uv.y inside [0.0,1.0]\n*/\n\nfloat inside(vec2 uv){\n    float x = step(0.0, uv.x) + step(uv.x, 1.0);\n    float y = step(0.0, uv.y) + step(uv.y, 1.0);\n    return x + y; \n}\n\n/*\nreturn vec4(0.0) if uv outside\n*/\nvec4 myClampWrap(sampler2D tex, vec2 uv){\n    return mix(vec4(0.0), texture(tex,uv), step(4.0, inside(uv)));\n}","name":"Common","description":"","type":"common"}]}