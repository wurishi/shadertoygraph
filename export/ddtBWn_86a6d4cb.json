{"ver":"0.1","info":{"id":"ddtBWn","date":"1697054944","viewed":87,"name":"Winding Numbers on Sphere","username":"chronos","description":"Winding numbers on a sphere. They're based on the signed angle between great circles :)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sphere","number","winding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nfloat spheresdf(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat rand(vec3 p)\n{\n    return fract(2.3467 * dot(p, vec3(285.345, 84598.92566, 289342.298)));\n}\n\nvec3 great_circle(vec3 a, vec3 b)\n{\n    return cross(a, b);\n}\n\nvec3 project(vec3 p, vec3 a)\n{\n    return a * dot(p, a) / dot(a, a);\n}\n\nvec3 reject(vec3 p, vec3 a)\n{\n    return p - project(p, a);\n}\n\n/*\n// Previous way I calculated it, which gave the unintended effect of also including antipodal points\nfloat winding(vec3 a, vec3 b, vec3 p)\n{\n    if(abs(dot(cross(a,b), p)) < 1e-3) return 0.0;\n    a = normalize(a);\n    b = normalize(b);\n    vec3 r1 = cross(a, p);\n    vec3 r2 = cross(b, p);\n    vec3 n1 = normalize(r1);\n    vec3 n2 = normalize(r2);\n    \n    float d = dot(n1,n2);\n    float angle = acos(d);\n    angle = min(angle, 2.*PI - angle);\n    return sign(determinant(mat3(n1,n2,p))) * angle / (2. * PI);\n}\n*/\n\nfloat winding(vec3 a, vec3 b, vec3 p)\n{\n    a = normalize(a);\n    b = normalize(b);\n    p = normalize(p);\n        \n    vec3 r1 = normalize(a-p);\n    vec3 r2 = normalize(b-p);\n    \n    float y = dot(cross(r1,r2),p); // sine\n    float x = dot(r1,r2);          // cosine\n    \n    float angle = atan(y, x);\n    return angle / (2. * PI);\n}\n\nvec3 get_sphere_color(vec3 p, vec3 spherepos, float sphereradius)\n{\n    vec3 pos = p - spherepos;\n    \n    vec3 color = vec3(0);\n    \n    float a = cos(iTime * 2.1) + cos(iTime / 6.);\n    float b = sin(iTime);\n    float c = sin(iTime * 7. / 13.) * cos(iTime * 3. / 11.);\n    float d = sin(iTime * 5. / 11.) * cos(iTime * 7. / 13.) * sin(iTime * 11. / 23.);\n    float e = sin(iTime * 2. / 7.)  * cos(iTime * 13. / 7.) * sin(iTime * 13. / 31.);\n    \n    vec3 p1 = normalize(vec3(a,0,b));\n    vec3 p2 = normalize(vec3(c,d,0.0));\n    vec3 p3 = normalize(vec3(0.75,e,1));\n    \n    float f = winding(p1, p2, pos) + winding(p2, p3, pos);// + winding(p3, normalize(p1+p3), pos);\n    \n    // antipodal points\n    f += winding(-p1, -p2, pos) + winding(-p2, -p3, pos);// + winding(p3, normalize(p1+p3), pos);\n    \n    // Set to 1 to see message from @pyBlob :)\n    #if 0\n    #define s3(i) -vec3(sin(float(i>>3&63)/20.-3.), float(i&7)/10.-.35, cos(float(i>>3&63)/20.-3.))\n    const int l[] = int[](0x7, 0xe0f, 0x1e0c, 0x181c, 0x381f, 0x3e27, 0x4e20, 0x4018, 0x301b, 0x360b, 0x1608, 0x1000, 0x502f, 0x5e4f, 0x9e4e, 0x9c36, 0x6c34, 0x6844, 0x8843, 0x8633, 0x6631, 0x6249, 0x9248, 0x9028, 0xa057, 0xae77, 0xee76, 0xec5e, 0xbc58, 0xb050, 0xf07f, 0xfe9f, 0x13e9e, 0x13c86, 0x10c80, 0x10078, 0x140a7, 0x14ec7, 0x18ec0, 0x180a0, 0x1b0df, 0x1bee7, 0x1cee6, 0x1ccf6, 0x1ecf7, 0x1eeff, 0x1fef8, 0x1f0f0, 0x1e0f5, 0x1eae5, 0x1cae0, 0x1c0d8, 0x20107, 0x20f27, 0x24f20, 0x24100, 0x2512f, 0x25f37, 0x26f34, 0x26944, 0x28943, 0x2874b, 0x29749, 0x29341, 0x28343, 0x28733, 0x26731, 0x26341, 0x28340, 0x28128, 0x28947, 0x28f4f, 0x29f4c, 0x29944, 0x2a157, 0x2af77, 0x2ef76, 0x2ed5e, 0x2bd58, 0x2b150, 0x2f17f, 0x2ff97, 0x32f96, 0x32d9e, 0x33d99, 0x33391, 0x32396, 0x32d86, 0x30d81, 0x30391, 0x32390, 0x32178, 0x351ad, 0x35bb5, 0x36bb0, 0x361a8, 0x152b9, 0x172be, 0x17cae, 0x15ca9, 0x21319, 0x2331e, 0x23d0e, 0x21d09, 0x35daf, 0x35fb7, 0x36fb6, 0x36dae);\n    f = 0.; for (int i=0 ; i<l.length() ; ++i) f += winding(s3(l[i]>>9), s3(l[i]), pos);\n    #endif\n    \n    //color += .5+tanh(f)*.5;\n    color = mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+f));\n    \n    if(distance(p1, pos) < 0.025 || distance(-p1, pos) < 0.025) color = vec3(0);\n    if(distance(p2, pos) < 0.025 || distance(-p2, pos) < 0.025) color = vec3(0);\n    if(distance(p3, pos) < 0.025 || distance(-p3, pos) < 0.025) color = vec3(0);\n    \n    if(distance(p1, pos) < 0.02 || distance(-p1, pos) < 0.02) color = vec3(1);\n    if(distance(p2, pos) < 0.02 || distance(-p2, pos) < 0.02) color = vec3(1);\n    if(distance(p3, pos) < 0.02 || distance(-p3, pos) < 0.02) color = vec3(1);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float time = iTime * .75;\n    \n    float c = cos(time);\n    float s = sin(time);\n    vec3 ro = 3. * vec3(c, 0., s) + vec3(0,0,0);\n    float focal = 2.;\n    \n    vec3 finalcolor = vec3(0);\n    \n    \n    // 1: No AA\n    // 2: Ok\n    // 3: Good Quality\n    // 4: Pixel Connoisseur\n    const int NUM_AA = 2;\n    \n    for(int AA = 0; AA < NUM_AA * NUM_AA; AA++)\n    {\n        vec2 uv_offset =\n            (vec2(AA % NUM_AA, AA / NUM_AA)\n            +\n            (NUM_AA > 1 ?\n            .3 + .4*texture(iChannel2, (fragCoord.xy/1024.) + vec2(1.1, .7) *float(iFrame + AA * 11) / 64.).rg\n            :\n            vec2(.5))\n        )/float(NUM_AA);\n        \n        vec2 uv = (2.*(floor(fragCoord)+uv_offset)-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize(vec3(uv, -focal));\n        rd.xz = mat2(s, -c, c, s) * rd.xz;\n    \n        vec3 color = sRGBdecode(texture(iChannel0, rd).rgb);\n\n        vec3 spherepos = vec3(0, 0., 0.);\n        float sphereradius = 1.;\n\n        float t = 0.;\n        for(int i = 0; i < 300; i++)\n        {\n            vec3 p = rd * t + ro;\n\n            float d = spheresdf(p - spherepos, sphereradius);\n\n            if(d < 1e-5)\n            {\n                color = get_sphere_color(p, spherepos, sphereradius);\n\n                // Add some basic light /////////////////\n                vec3 N = normalize(p - spherepos);\n                vec3 L = normalize(vec3(0,1,0));\n                vec3 R = reflect(rd, N);\n\n                float ao = mix(1., sqrt((R.y/sphereradius + 1.) * .5), .75);\n                color += .01*sRGBdecode(texture(iChannel0, R).rgb) * ao;\n                color += .18*sRGBdecode(texture(iChannel1, R).rgb) * ao;\n                color += .025 * max(dot(N, L), 0.);\n                color += .15 * max(dot(N,L), 0.) * pow(max(dot(R, L), 0.), 5.);\n                color += 2.0*pow(1.-dot(N, -rd), 8.) * sRGBdecode(texture(iChannel1, R).rgb);\n                /////////////////////////////////////////\n\n                break;\n            }\n\n            t += d;\n        }\n        \n        finalcolor += color;\n    }\n    \n    finalcolor /= float(NUM_AA * NUM_AA);\n\n    finalcolor = clamp(tanh(finalcolor), 0., 1.);\n    finalcolor.rgb = sRGBencode(finalcolor);\n    finalcolor += 1.5*texture(iChannel2, (fragCoord.xy/1024.) + vec2(.9, 1.3) *float(iFrame) / 8.)[iFrame%3] / 255.;\n    fragColor = vec4(finalcolor,1.0);\n}","name":"Image","description":"","type":"image"}]}