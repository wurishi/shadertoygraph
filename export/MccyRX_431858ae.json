{"ver":"0.1","info":{"id":"MccyRX","date":"1730939706","viewed":29,"name":"Scene Transition Test: Wipe v0","username":"8InfinityTaco8","description":"just experimenting with shadertoy.\n\nI learned how to apply 3D rotations using a combined yaw, pitch, and roll matrix, and create a dynamic wipe effect to transition between two scenes in real time.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","sdf","lighting","shadows","diffuse","signeddisstance"],"hasliked":0,"parentid":"4XBfWt","parentname":"Ray Marcher With diff Lighting"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Use the mouse to controll the scene wipe\n\n\n// Raymarching parameters\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n// Rotation funciton\nmat3 rotationMatrix3D(float yaw, float pitch, float roll) {\n    float cy = cos(yaw), sy = sin(yaw);\n    float cp = cos(pitch), sp = sin(pitch);\n    float cr = cos(roll), sr = sin(roll);\n\n    // Rotation matrix construction\n    return mat3(\n        cy * cr + sy * sp * sr, -cy * sr + sy * sp * cr, sy * cp,\n        sr * cp,                 cr * cp,               -sp,\n        -sy * cr + cy * sp * sr, sr * sy + cy * sp * cr, cy * cp\n    );\n}\n\n\n// Scene selection based on position relative to wipe\nfloat getSceneSelect(vec2 fragCoord) {\n    // Get normalized x position - either from mouse if clicked, or from sin wave if not\n    float wipeX;\n    if (iMouse.z > 0.0) {  // If mouse is clicked\n        wipeX = iMouse.x;\n    } else {\n        // Create smooth sin wave motion across screen width\n        wipeX = (sin(iTime) * 0.5 + 0.5) * iResolution.x;\n    }\n    \n    // Get normalized positions\n    float normalizedWipeX = wipeX / iResolution.x;\n    float fragX = fragCoord.x / iResolution.x;\n    \n    // Return 0 for scene 1, 1 for scene 2\n    return step(normalizedWipeX, fragX);\n}\n\n// Function to calculate the distance to the nearest surface from a point p\nfloat GetDist(vec3 point, float sceneSelect){\n    if(sceneSelect < 0.5) {\n        // Scene 1: Sphere\n        vec4 sphereParams = vec4(0, 1, 6, 1);\n        float sphereDistance = length(point - sphereParams.xyz) - sphereParams.w;\n        float groundDistance = point.y;\n        return min(sphereDistance, groundDistance);\n    } else {\n        // Scene 2: Cube\n        vec3 cubePos = vec3(0, 1, 6);\n        vec3 cubeSize = vec3(1.0); // Size 1.0 in all dimensions\n        vec3 q = abs(point - cubePos) - cubeSize;\n        float cubeDistance = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n        float groundDistance = point.y;\n        return min(cubeDistance, groundDistance);\n    }\n}\n\n// Main raymarching function - follows ray from origin (ro) in direction (rd)\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, float sceneSelect){\n    float totalDistance = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 currentPoint = rayOrigin + rayDirection * totalDistance;\n        float stepDistance = GetDist(currentPoint, sceneSelect);\n        totalDistance += stepDistance;\n        if(totalDistance > MAX_DIST || stepDistance < SURF_DIST) break;\n    }\n    return totalDistance;\n}\n\n// Calculate surface normal at a point\nvec3 GetNormal(vec3 point, float sceneSelect){\n    float centerDistance = GetDist(point, sceneSelect);\n    vec2 epsilon = vec2(.01, 0);\n    \n    vec3 normal = centerDistance - vec3(\n        GetDist(point-epsilon.xyy, sceneSelect),\n        GetDist(point-epsilon.yxy, sceneSelect),\n        GetDist(point-epsilon.yyx, sceneSelect)\n    );\n    \n    return normalize(normal);\n}\n\n// Calculate lighting at a point\nfloat GetLight(vec3 surfacePoint, float sceneSelect){\n    vec3 lightPosition = vec3(0, 5, 6);\n    lightPosition.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 lightDirection = normalize(lightPosition - surfacePoint);\n    vec3 surfaceNormal = GetNormal(surfacePoint, sceneSelect);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0., 1.);\n    float shadowDistance = RayMarch(surfacePoint + surfaceNormal * SURF_DIST * 2., \n                                  lightDirection, sceneSelect);\n    if(shadowDistance < length(lightPosition-surfacePoint)) diffuse *= .1;\n    \n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get scene selection based on either mouse position or sin wave\n    float sceneSelect = getSceneSelect(fragCoord);\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec3 pixelColor = vec3(0);\n    \n    \n    /*\n    // old static camera \n    // Define ray origin (camera position)\n    vec3 cameraPos = vec3(0, 1.5, 0);\n    // Calculate ray direction for this pixel\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1));\n    */\n\n    // Apply rotations in order (you may change the order if needed)\n    float yawAngle = .5 * sin(iTime * .5);    // Horizontal rotation\n    float pitchAngle = -0.5;  // Up/down rotation\n    float rollAngle = 0.0;    // Sideways tilt\n    \n    float dolly = sin(iTime * .5);\n\n    vec3 cameraPos = vec3(dolly, 5.0, -3);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1));\n\n    // Create the combined rotation matrix\n    mat3 rotMat = rotationMatrix3D(yawAngle, pitchAngle, rollAngle);\n\n    // Apply the combined rotation\n    cameraPos = rotMat * cameraPos;\n    rayDir = rotMat * rayDir;\n\n    float hitDistance = RayMarch(cameraPos, rayDir, sceneSelect);\n    vec3 hitPoint = cameraPos + rayDir * hitDistance;\n    \n    float diffuseLight = GetLight(hitPoint, sceneSelect);\n    pixelColor = vec3(diffuseLight);\n    \n    // Add a vertical line at the wipe position\n    float wipeX;\n    if (iMouse.z > 0.0) {  // If mouse is clicked\n        wipeX = iMouse.x;\n    } else {\n        wipeX = (sin(iTime) * 0.5 + 0.5) * iResolution.x;\n    }\n    \n    float lineWidth = 2.0;\n    float lineIntensity = step(abs(fragCoord.x - wipeX), lineWidth);\n    vec3 lineColor = vec3(0.0);  // Line color for the transition wipe (Black)\n    \n    pixelColor = mix(pixelColor, lineColor, lineIntensity);\n    \n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shape Signed Distance Functions (SDFs)\n// Sphere SDF\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// Box SDF\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// Torus SDF\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// Capsule SDF\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// Plane SDF\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    // n must be normalized\n    return dot(p, n) + h;\n}\n\n// Cylinder SDF\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cone SDF\nfloat sdCone(vec3 p, vec3 c) {\n    float q = length(p.xy);\n    return dot(c.xy, vec2(q, p.z));\n}\n\n// Hexagonal Prism SDF\nfloat sdHexPrism(vec3 p, vec2 h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n    vec2 d = vec2(length(p.xy - vec2(clamp(p.x, -h.x, h.x), h.x)), p.z - h.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Rounded Box SDF\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) - r;\n}\n\n// Ellipsoid SDF\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n","name":"Common","description":"","type":"common"}]}