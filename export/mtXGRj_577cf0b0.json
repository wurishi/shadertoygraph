{"ver":"0.1","info":{"id":"mtXGRj","date":"1672023388","viewed":87,"name":"Trabalho Final de CG","username":"garori","description":"trabalho","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Tirei os crédiots para pegar menos espaço\n\n// todas as texturas viram procedurais e ignoramos os iChannels (1/0)\n#define ALL_PROCEDURAL 1\n// roda a camera em volta da Death star quando (1/0)\n#define CAMERA_ROTATION 0\n// posição da camera quantdo ela está fixada\n#define FIXED_CAMERA_POSITION vec3(0.,2.,2.)\n// Toggle o background de textura procedural (1./0.)\n#define DEACTIVATE_BG 0.\n// para mudar a cor do background se quiser tanto pro estética quanto pra facilitar a visualização;\n//#define BG_COLOR vec3(0.20, 0.06, 0.60)\n#define BG_COLOR vec3(0.20, 0.2, 0.2)\n\n\n// variaveis da NOISE\n\n// velocidade\n#define SPEED 0.\n//scale mínima\n#define SCALE 7.\n// scale máximo pra mudança\n#define MAX_SCALE 13.\n#define OFFSET 0.3\n#define MULTIPLIER 1.\n\n\n\n//Gabriel Conde\n//DRE 114055262\n\n\n\n\n\n\n//Programa\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n#define EPSILON 0.0001\n#define MULTI_SCALE 1.\n\nvec3 CoordCentrais = vec3(0, 1, 8);\n\nstruct Surface {\n    float d;\n    vec3 colXZ;\n    vec3 colYZ;\n    vec3 colXY;\n    vec3 p;\n};\n// Rotation matrix.\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\nfloat ndot(in vec2 a, in vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\n// SDF of a torus at the origin given its two radius.\nfloat dTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n\n    return length(vec2(x, p.y)) - r.y;\n}\nSurface dTorus(vec3 p, vec2 r, vec3 c1, vec3 c2, vec3 c3) {\n    float x = length(p.xz) - r.x;\n\n    return Surface(length(vec2(x, p.y)) - r.y, c1, c2, c3, p);\n}\n\n// SDF of a box at the origin given its size (width, height and depth).\nSurface dBox(vec3 p, vec3 s, vec3 c1, vec3 c2, vec3 c3) {\n    return Surface(length(max(abs(p) - s, 0.0)), c1, c2, c3, p);\n}\n\n// SDF of a sphere, given its center and radius.\nSurface dSphere(vec3 p, vec4 s, vec3 c1, vec3 c2, vec3 c3) {\n    return Surface(length(p - s.xyz) - s.w, c1, c2, c3, p);\n}\nSurface dSphere(vec3 p, vec4 s, vec3 c1) {\n    return Surface(length(p - s.xyz) - s.w, c1, c1, c1, p);\n}\n\nSurface sdOctahedron(vec3 p, float s, vec3 c1, vec3 c2, vec3 c3) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n    if(3.0 * p.x < m)\n        q = p.xyz;\n    else if(3.0 * p.y < m)\n        q = p.yzx;\n    else if(3.0 * p.z < m)\n        q = p.zxy;\n    else\n        return Surface(m * 0.57735027, c1, c2, c3, p);\n\n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return Surface(length(vec3(q.x, q.y - s + k, q.z - k)), c1, c2, c3, p);\n}\n\nfloat sdDeathStar(in vec3 p2, in float ra, float rb, in float d) {\n  // sampling independent computations (only depend on shape)\n    float a = (ra * ra - rb * rb + d * d) / (2.0 * d);\n    float b = sqrt(max(ra * ra - a * a, 0.0));\n\n  // sampling dependant computations\n    vec2 p = vec2(p2.x, length(p2.yz));\n    if(p.x * b - p.y * a > d * max(b - p.y, 0.0))\n        return length(p - vec2(a, b));\n    else\n        return max((length(p) - ra), -(length(p - vec2(d, 0)) - rb));\n}\n\nSurface sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2, vec3 c1) {\n  // sampling independent computations (only depend on shape)\n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr * rr;\n    float il2 = 1.0 / l2;\n\n  // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa, ba);\n    float z = y - l2;\n    float x2 = dot2(pa * l2 - ba * y);\n    float y2 = y * y * l2;\n    float z2 = z * z * l2;\n\n  // single square root!\n    float k = sign(rr) * rr * rr * x2;\n    if(sign(z) * a2 * z2 > k)\n        return Surface(sqrt(x2 + z2) * il2 - r2, c1, c1, c1, p);\n    if(sign(y) * a2 * y2 < k)\n        return Surface(sqrt(x2 + y2) * il2 - r1, c1, c1, c1, p);\n    return Surface((sqrt(x2 * a2 * il2) + y * rr) * il2 - r1, c1, c1, c1, p);\n}\n\n// B + A\nfloat unionSDF(float sda, float sdb) {\n    return min(sda, sdb);\n}\n\n// B * A\nfloat intersectionSDF(float sda, float sdb) {\n    return max(sda, sdb);\n}\n\n// B - A\nSurface differenceSDF(float sda, float sdb, vec3 c1, vec3 c2, vec3 c3, vec3 p) {\n    return Surface(max(-sda, sdb), c1, c2, c3, p);\n}\n// Blend A and B\nfloat blendSDF(float sda, float sdb, float k) {\n    float h = clamp(0.5 + 0.5 * (sdb - sda) / k, 0.0, 1.0);\n    return mix(sdb, sda, h) - k * h * (1.0 - h);\n}\n\nfloat getDistBodies(vec3 orig, vec3 dest) {\n    return pow(pow(orig.x - dest.x, 2.0) + pow(orig.y - dest.y, 2.0) + pow(orig.z - dest.z, 2.0), 0.5);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n    if(obj2.d < obj1.d)\n        return obj2;\n    return obj1;\n}\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p = 50.0 * fract(p * 0.3183099 + vec3(0.71, 0.113, 0.419));\n    return -1.0 + 2.0 * fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised(in vec3 x) {\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n\n#if 1\n    // quintic interpolation\n    vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n    vec3 du = 30.0 * w * w * (w * (w - 2.0) + 1.0);\n#else\n    // cubic interpolation\n    vec3 u = w * w * (3.0 - 2.0 * w);\n    vec3 du = 6.0 * w * (1.0 - w);\n#endif    \n\n    float a = hash(i + vec3(0.0, 0.0, 0.0));\n    float b = hash(i + vec3(1.0, 0.0, 0.0));\n    float c = hash(i + vec3(0.0, 1.0, 0.0));\n    float d = hash(i + vec3(1.0, 1.0, 0.0));\n    float e = hash(i + vec3(0.0, 0.0, 1.0));\n    float f = hash(i + vec3(1.0, 0.0, 1.0));\n    float g = hash(i + vec3(0.0, 1.0, 1.0));\n    float h = hash(i + vec3(1.0, 1.0, 1.0));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = -a + b + c - d + e - f - g + h;\n\n    return vec4(k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z, du * vec3(k1 + k4 * u.y + k6 * u.z + k7 * u.y * u.z, k2 + k5 * u.z + k4 * u.x + k7 * u.z * u.x, k3 + k6 * u.x + k5 * u.y + k7 * u.x * u.y));\n}\n\nfloat octaveNoise(vec3 p) {\n    return noised(p).x;\n}\n\nfloat getNoiseColor(vec3 p) {\n    return OFFSET + MULTIPLIER * octaveNoise(((pow(sin(iTime*SPEED), 2.) * SCALE + pow(cos(iTime*SPEED), 2.) * (MULTI_SCALE * MAX_SCALE))) * p );\n}\n\nvec3 noiseNormal(vec3 p) {\n    return normalize(vec3(getNoiseColor(p + vec3(EPSILON, 0.0, 0.0)) - getNoiseColor(p - vec3(EPSILON, 0.0, 0.0)), getNoiseColor(p + vec3(0.0, EPSILON, 0.0)) - getNoiseColor(p - vec3(0.0, EPSILON, 0.0)), getNoiseColor(p + vec3(0.0, 0.0, EPSILON)) - getNoiseColor(p - vec3(0.0, 0.0, EPSILON))));\n}\n\n// Scene SDF: signed distance function.\nfloat r1 = 0.04;\nfloat r2 = 0.08;\nfloat tamanho1 = 1.0;\nfloat tamanho2 = 0.3;\nfloat tamanho3 = 0.08;\n\nSurface getDist(vec3 p) {\n\n    if(cos(iTime) > sin(iTime)) {\n        r1 = 0.08;\n        r2 = 0.04;\n    } else {\n        r1 = 0.04;\n        r2 = 0.08;\n    }\n\n    vec3 sol = p - CoordCentrais;\n    mat2 ajeitaSol = -Rot(PI / 7.77);\n    mat2 Tsol = Rot(iTime * PI / 6.0);\n    sol.xz *= Tsol;\n    sol.xz *= ajeitaSol;\n    sol.xy *= ajeitaSol;\n\n    vec3 anjo = p - vec3(-9, 2, 15);\n    anjo.xz *= Rot(iTime / 3.0);\n    anjo.y += sin(iTime) / 3.0;\n\n    vec3 luaAnjo = p - vec3(-9, 3, 15);\n    luaAnjo.xz += vec2(sin(iTime) / 1.2, -cos(iTime) / 1.2);\n    luaAnjo.y += sin(iTime) / 3.0;\n    luaAnjo.y += pow(sin(iTime), 2.0) / 3.5;\n    luaAnjo.xz *= Rot(-iTime / 3.0);\n\n    vec3 planeta1 = p - CoordCentrais;\n    vec3 Tplaneta1 = vec3(sin(iTime / 3.0) * 2.1, 0, -cos(iTime / 3.0) * 2.1);\n    vec2 Tlua1 = vec2(sin(iTime) * 0.8, cos(iTime) * 0.5);\n    planeta1.xz -= Tplaneta1.xz;\n\n    vec3 lua1 = p - CoordCentrais - Tplaneta1;\n    lua1.xz += Tlua1;\n\n    vec3 lua2 = (p - CoordCentrais) - Tplaneta1;\n    lua2.xy -= vec2(sin(iTime * 1.5) * 0.6, -cos(iTime * 1.5) * 1.3);\n\n    vec3 lua3 = (p - CoordCentrais) - Tplaneta1;\n    lua3.yz += Tlua1;\n    lua3.xz += Tlua1;\n\n    vec3 planeta2 = p - CoordCentrais;\n    vec3 Tplaneta2 = vec3(sin(iTime / 2.0) * 2.5, cos(iTime / 2.0) * 1.8, 0) * 1.4;\n    planeta2.xy += Tplaneta2.xy;\n    // nave += Tplaneta2;\n    vec2 Tlua2 = vec2(sin(iTime * 1.3) * 0.8, cos(iTime * 1.3) * 1.3);\n\n    vec3 lua4 = p - CoordCentrais + Tplaneta2;\n    lua4.xz -= Tlua2;\n\n    vec3 lua5 = (p - CoordCentrais) + Tplaneta2;\n    lua5.xy += Tlua2;\n\n    vec3 lua6 = (p - CoordCentrais) + Tplaneta2;\n    lua6.yz += vec2(sin(iTime) * 0.8, -cos(iTime) * 0.5);\n    lua6.xz += Tlua2;\n\n    vec3 aro1 = p - CoordCentrais + Tplaneta2;\n    aro1.xz *= -Tsol;\n    aro1.xz *= 0.2;\n\n    vec3 planeta3 = p - CoordCentrais;\n    vec3 Tplaneta3 = vec3(0, sin(iTime / 4.0) * 2.1, cos(iTime / 4.0) * 1.8) * 1.7;\n    vec3 Tplaneta3_2 = vec3(sin(iTime / 4.0) * 2.1, 0, cos(iTime / 4.0) * 1.8) * 1.7;\n    vec2 Tlua3 = vec2(sin(iTime * 1.3) * 0.6, cos(iTime * 1.3) * 1.3);\n    planeta3.yz += Tplaneta3.yz;\n    planeta3.xz += Tplaneta3_2.xz;\n\n    vec3 lua7 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2;\n    lua7.xz += Tlua3;\n\n    vec3 lua8 = (p - CoordCentrais) + Tplaneta3 + Tplaneta3_2;\n    lua8.xy += Tlua3;\n    vec3 lua9 = (p - CoordCentrais) + Tplaneta3 + Tplaneta3_2;\n    lua9.yz += Tlua3;\n    lua9.xz += Tlua3;\n\n    vec3 fakesun = p - CoordCentrais;\n    vec3 navep1p2 = p - CoordCentrais - Tplaneta1;\n    vec3 navep3sol = (p - CoordCentrais);\n    vec3 navel7l9 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2 + vec3(Tlua3.x, 0, Tlua3.y);\n    vec3 navel9l1 = p - CoordCentrais + Tplaneta3 + Tplaneta3_2 + vec3(Tlua3.x, 0, Tlua3.y) + vec3(0, Tlua3.x, Tlua3.y);\n    navep1p2.xyz += ((sin(iTime) + 1.0) / 2.0) * (-planeta1 + planeta2);\n    // if(abs(distance(navep1p2, fakesun)) <= 1.5) {\n    //     navep1p2.xy += normalize(navep1p2 + fakesun).z * abs(distance(navep1p2, fakesun) -1.5);\n    //     navep1p2.yz += normalize(navep1p2 + fakesun).x * abs(distance(navep1p2, fakesun) -1.5);\n    //     navep1p2.xz += normalize(navep1p2 + fakesun).y * abs(distance(navep1p2, fakesun) -1.5);\n    //     //navep1p2.xyz *= normalize(navep1p2 + fakesun);\n    // }\n    navep3sol += ((sin(iTime) + 1.0) / 2.0) * (-fakesun + planeta3);\n    navel7l9 += ((sin(iTime) + 1.0) / 2.0) * (-lua7 + lua9);\n    navel9l1 += ((sin(iTime) + 1.0) / 2.0) * (-lua9 + lua1);\n\n    vec4 noise = noised(((pow(sin(iTime*SPEED), 2.) * SCALE + pow(cos(iTime*SPEED), 2.) * (MULTI_SCALE * MAX_SCALE))) * p );\n    vec3 corSolXZ = noise.xxx;\n    vec3 corSolYZ = noise.xxx;\n    vec3 corSolXY = noise.xxx;\n    vec3 corP1XZ = texture(iChannel0, planeta1.xz).xyz;\n    vec3 corP1YZ = texture(iChannel0, planeta1.yz).xyz;\n    vec3 corP1XY = texture(iChannel0, planeta1.xy).xyz;\n    vec3 corP2XZ = texture(iChannel0, planeta2.xz).xyz;\n    vec3 corP2YZ = texture(iChannel0, planeta2.yz).xyz;\n    vec3 corP2XY = texture(iChannel0, planeta2.xy).xyz;\n    vec3 corP3XZ = texture(iChannel0, planeta3.xz).xyz;\n    vec3 corP3YZ = texture(iChannel0, planeta3.yz).xyz;\n    vec3 corP3XY = texture(iChannel0, planeta3.xy).xyz;\n    vec3 corAnjoXZ = texture(iChannel3, anjo.xz).xyz;\n    vec3 corAnjoYZ = texture(iChannel3, anjo.yz).xyz;\n    vec3 corAnjoXY = texture(iChannel3, anjo.xy).xyz;\n    vec3 corLuaAnjoXZ = texture(iChannel1, luaAnjo.xz).xyz;\n    vec3 corLuaAnjoYZ = texture(iChannel1, luaAnjo.yz).xyz;\n    vec3 corLuaAnjoXY = texture(iChannel1, luaAnjo.xy).xyz;\n    vec3 corAro1XZ = texture(iChannel1, aro1.xz).xyz;\n    vec3 corAro1YZ = texture(iChannel1, aro1.yz).xyz;\n    vec3 corAro1XY = texture(iChannel1, aro1.xy).xyz;\n\n    Surface dnavep1p2 = sdRoundCone(navep1p2, vec3(0), normalize(planeta1 - planeta2) / 8., r1 / 1.4, r2 / 1.4, vec3(255, 0, 0) / 255.);\n    Surface dnavep3sol = sdRoundCone(navep3sol, vec3(0), normalize(fakesun - planeta3) / 10., r1 / 1.4, r2 / 1.4, vec3(0, 255, 0) / 255.);\n    Surface dnavel7l9 = sdRoundCone(navel7l9, vec3(0), normalize(lua7 - lua9) / 20.0, r1 / 3., r2 / 3., vec3(250, 0, 215) / 255.);\n    Surface dnavel9l1 = sdRoundCone(navel9l1, vec3(0), normalize(lua9 - lua1) / 20.0, r1 / 3., r2 / 3., vec3(250, 0, 215) / 255.);\n    //rotação dos planetas aqui pq se não quebra as naves\n    planeta1.xz *= Tsol;\n    planeta2.xz *= -Tsol;\n    planeta3.xz *= Tsol;\n    float dSol = sdDeathStar(sol, tamanho1, tamanho2, tamanho1);\n    float dToro = dTorus(fakesun, vec2(tamanho1, 0.025));\n    Surface dPlaneta1 = dSphere(planeta1, vec4(0, 0, 0, tamanho2), corP1XZ, corP1YZ, corP1XY);\n    Surface dLua1 = dSphere(lua1, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dLua2 = dSphere(lua2, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dLua3 = dSphere(lua3, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dPlaneta2 = dSphere(planeta2, vec4(0, 0, 0, tamanho2), corP2XZ, corP2YZ, corP2XY);\n    Surface dLua4 = dSphere(lua4, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dLua5 = dSphere(lua5, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dLua6 = dSphere(lua6, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dAro1 = dTorus(aro1, vec2(tamanho2 * 0.35, 0.015), corAro1XZ, corAro1YZ, corAro1XY);\n    Surface dPlaneta3 = dSphere(planeta3, vec4(0, 0, 0, tamanho2), corP3XZ, corP3YZ, corP3XY);\n    Surface dLua7 = dSphere(lua7, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dLua8 = dSphere(lua8, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dLua9 = dSphere(lua9, vec4(0, 0, 0, tamanho3), vec3(250, 235, 215) / 255.);\n    Surface dAnjo = sdOctahedron(anjo, 1.0, corAnjoXZ, corAnjoYZ, corAnjoXY);\n    Surface dLuaAnjo = sdOctahedron(luaAnjo, tamanho2 / 1.5, corLuaAnjoXZ, corLuaAnjoYZ, corLuaAnjoXY);\n\n    // vec3 corSolXZ = texture(iChannel1, sol.xz).xyz;\n    // vec3 corSolYZ = texture(iChannel1, sol.yz).xyz;\n    // vec3 corSolXY = texture(iChannel1, sol.xy).xyz;\n\n    Surface d = minWithColor(differenceSDF(dToro, dSol, corSolXZ, corSolYZ, corSolXY, sol), dPlaneta1);\n    d = minWithColor(d, dPlaneta2);\n    d = minWithColor(d, dPlaneta3);\n    d = minWithColor(d, dLua1);\n    d = minWithColor(d, dLua2);\n    d = minWithColor(d, dLua3);\n    d = minWithColor(d, dLua4);\n    d = minWithColor(d, dLua5);\n    d = minWithColor(d, dLua6);\n    d = minWithColor(d, dLua7);\n    d = minWithColor(d, dLua8);\n    d = minWithColor(d, dLua9);\n    d = minWithColor(d, dAro1);\n    d = minWithColor(d, dnavep1p2);\n    d = minWithColor(d, dnavep3sol);\n    d = minWithColor(d, dnavel7l9);\n    d = minWithColor(d, dnavel9l1);\n    d = minWithColor(d, dAnjo);\n    d = minWithColor(d, dLuaAnjo);\n    return d;\n}\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nSurface rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    Surface dS;\n    vec3 p;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * dO;\n        dS = getDist(p);\n        dO += dS.d;\n        if(dO > MAX_DIST || dS.d < SURF_DIST)\n            break;\n    }\n    //vec3 color = vec3(dS.yzw);\n\n    return Surface(dO, dS.colXZ, dS.colYZ, dS.colXY, dS.p);\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary — should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    ;\n\n    vec3 n = e.xyy * getDist(p + e.xyy).d +\n        e.yyx * getDist(p + e.yyx).d +\n        e.yxy * getDist(p + e.yxy).d +\n        e.xxx * getDist(p + e.xxx).d;\n\n    return normalize(n);\n}\n\n// Phong illumination model, given a point and camera position.\n\nvec3 phong(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 N, vec3 lightIntensity, vec3 eye) {\n    vec3 lightPos = vec3(-2, 4, 3);\n    if(CAMERA_ROTATION == 1){\n    lightPos = CoordCentrais + vec3(2, 3, 3);\n        lightPos.xz += vec2(sin(iTime * PI / 18.) * 18., cos(iTime * PI / 18.) * 18.);;\n    }\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    Surface d = rayMarch(p + 2. * N * SURF_DIST, L);\n    if(dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return k_a * lightIntensity;\n    }\n\n    if(dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_a + k_d * dotLN);\n    }\n    return lightIntensity * (k_a + k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 getLight(vec3 p, vec3 ro) {\n\n    vec3 lightPos = vec3(-2, 4, 3);\n    if(CAMERA_ROTATION == 1){\n        lightPos = CoordCentrais + vec3(2, 3, 3);\n        lightPos.xz += vec2(sin(iTime * PI / 18.) * 18., cos(iTime * PI / 18.) * 18.);\n    }\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l, n);\n\n    // ambient component\n    vec3 amb = vec3(0.1);\n    // ambient reflection coefficient\n    float ka = 1.0;\n\n    // diffuse component - apply Lambert's cosine law\n    vec3 dif = vec3(clamp(dot(n, l), 0.0, 1.0));\n    // diffuse reflection coefficient\n    float kd = 0.8;\n\n    // specular component\n    float shininess = 100.;\n    vec3 v = normalize(ro - p);\n    float specFloat = clamp(dot(r, v), 0.0, 1.0);\n    vec3 spec = vec3(pow(specFloat, shininess));\n    // specular reflection coefficient\n    float ks = 1.0;\n\n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    Surface d = rayMarch(p + 2. * n * SURF_DIST, l);\n\n    // cast a ray to the light\n    if(d.d < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n\n    // ambient + diffuse + specular components\n    return vec3((ka * amb + kd * dif + ks * spec));\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 ro;\n    vec3 rd;\n    if(CAMERA_ROTATION == 1) {\n        // camera position\n        ro = CoordCentrais + vec3(0, 2, 3);\n        //ro.y += pow(sin(iTime / 5.).,2.);\n        ro.z += pow(sin(iTime / 5.) * 0.7, 2.);\n        ro.xz += vec2(sin(iTime * PI / 18.) * 13., cos(iTime * PI / 18.) * 13.);\n        // projection plane z = 1\n        rd = normalize(vec3(uv.x, uv.y, 1));\n\n        // Rotate camera down about the x-axis\n        rd.yz *= Rot(PI * 10. / 180.);\n        rd.xz *= Rot(180. * 2. * PI / 360.);\n        rd.xz *= Rot(-iTime * PI / 18.);\n    } else {\n        ro = FIXED_CAMERA_POSITION;\n        rd = normalize(vec3(uv.x, uv.y, 1));\n\n        // Rotate camera down about the x-axis\n        rd.yz *= Rot(PI * 10. / 180.);\n    }\n\n    Surface d = rayMarch(ro, rd);\n\n    // point hit by the ray\n    vec3 p = ro + rd * d.d;\n\n    vec3 background_color = BG_COLOR;\n\n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(250, 235, 215) / 255.;\n\n    // pixel color\n    vec3 color;\n    vec3 n = getNormal(p);\n    vec3 light_intensity = vec3(1);\n    vec3 n2 = abs(n);\n    n2 *= pow(n2, vec3(1));\n    n2 /= n2.x + n2.y + n2.z;\n    if(ALL_PROCEDURAL == 1 && d.d < MAX_DIST) {\n\n        vec3 noise_normal = noiseNormal(d.p);\n        float w = OFFSET + MULTIPLIER * octaveNoise(((pow(sin(iTime*SPEED), 2.) * SCALE + pow(cos(iTime*SPEED), 2.) *(MULTI_SCALE * MAX_SCALE))) * d.p );\n        if(dot(n, noise_normal) < 0.0)\n            noise_normal = reflect(noise_normal, n);\n        n = normalize(n * 2. + noise_normal);\n        light_intensity = phong(vec3(0.3), // ambient\n        vec3(0.8) * w * 1.5, // diffuse\n        vec3(0.7), // specular\n        100., // shininess\n        p, // point\n        n, // normal at point  CERTO\n        getLight(p, ro), ro);\n\n        color = surface_color * vec3(light_intensity);\n\n    } else if(ALL_PROCEDURAL == 0 && d.d < MAX_DIST) {\n    // modulate surface color by the light intensity\n\n        if(distance(p, vec3(0, 1, 8)) < tamanho1 + 0.1 && d.d < MAX_DIST) {\n            vec3 noise_normal = noiseNormal(d.p);\n            float w = OFFSET + MULTIPLIER * octaveNoise(((pow(sin(iTime*SPEED), 2.) * SCALE + pow(cos(iTime*SPEED), 2.) * (MULTI_SCALE * MAX_SCALE))) * d.p );\n            if(dot(n, noise_normal) < 0.0)\n                noise_normal = reflect(noise_normal, n);\n            n = normalize(n + noise_normal);\n            light_intensity = phong(vec3(0.3), // ambient\n            vec3(0.8) * w *1.5, // diffuse\n            vec3(0.7), // specular\n            100., // shininess\n            p, // point\n            n, // normal at point\n            getLight(p, ro), ro);\n            color = surface_color * vec3(light_intensity);\n        } else {\n            surface_color = d.colYZ * n2.x + d.colXZ * n2.y + d.colXY * n2.z;\n            light_intensity = getLight(p, ro);\n            color = surface_color * vec3(light_intensity);\n        }\n\n    } else {\n        color = (1.-DEACTIVATE_BG)*octaveNoise(vec3(((pow(sin(1. * SPEED), 2.) * SCALE + pow(cos(1. * SPEED), 2.) * (MULTI_SCALE * MAX_SCALE))) * uv, ((pow(sin(iTime * SPEED), 2.) * SCALE + pow(cos(iTime * SPEED), 2.) * (MULTI_SCALE * MAX_SCALE))))) * BG_COLOR + DEACTIVATE_BG*BG_COLOR;\n    }\n    if(distance(p, vec3(0, 1, 8)) > 0.750 && distance(p, vec3(0, 1, 8)) < 0.985 && d.d < MAX_DIST) {\n        surface_color = vec3(0.5, 0.3, 0.3);\n        light_intensity = getLight(p, ro);\n        color = surface_color * light_intensity;\n    }\n    // output to screen\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}