{"ver":"0.1","info":{"id":"mtd3z4","date":"1682034461","viewed":112,"name":"Fork Round Bril","username":"mehow_one","description":"Same idea as my previous attempt, but with a different lightning setup. Made some little tweaks to the material and rendering functions.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"WdGfRh","parentname":"Round Brilliant Cut"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Image:post effect\n\n#define ITER   36.\n#define RADIUS 0.05\n\nvec4 tx(vec2 uv){return texture(iChannel0,uv);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 m=vec2(1,iResolution.x/iResolution.y);\n    vec4 c=tx(uv);\n    float a=sin(iTime*.1)*6.283,v=0.,b=1./ITER;\n    for(int j=ZERO;j<6;j++){\n        float r=RADIUS/ITER;\n        vec2 d=vec2(cos(a),sin(a))*m;\n        for(int i=ZERO;i<int(ITER);i++){\n            v+=tx(uv+d*r*RADIUS).w*(1.-r);\n            r+=b;\n        }\n        a+=0.007;\n    }\n    v*=.01;\n    c+=v;\n    c.w=1.;\n\tfragColor=c;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//BufferA:scene\n#define PI 3.14159265359\n//refraction index\n#define RI1 1.40\n#define RI2 1.44\n\n//settings:trace\n#define ITER   256\n#define EPS   1e-6\n#define NEAR   1.0\n#define FAR   10.0\n\n//settings:trace2\n#define ITER2  128\n#define EPS2  1e-4\n#define NEAR2 0.02\n\n//CONSTANTS\nconst float pi=acos(-1.);\nconst float qp=pi*.25,op=qp*.5,hp=op*.5;\nconst mat2 rot4=mat2(sin(qp),cos(qp),-cos(qp),sin(qp));\nconst mat2 rot3=mat2(sin(qp+op),cos(qp+op),-cos(qp+op),sin(qp+op));\nconst mat2 rot2=mat2(sin(op),cos(op),-cos(op),sin(op));\nconst mat2 rot1=mat2(sin(hp),cos(hp),-cos(hp),sin(hp));\nvec3 noise(float p){return texture(iChannel1,vec2(p/iChannelResolution[1].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel1,p/iChannelResolution[1].xy).xyz;}\n\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel1,p.xy/iChannelResolution[1].xy+noise(sprev).yz).xyz,texture(iChannel1,p.xy/iChannelResolution[1].xy+noise(s).yz).xyz,m);}\n\n\nconst float numframes = 6. * 60.;\nfloat progress(){ return mod(float(iFrame),numframes) / numframes;}\n#define progress progress()\n\n//SDF\nfloat sdTable(vec3 p){\n\tvec2 d=abs(vec2(length(p.xz),(p.y+0.159)*1.650))-vec2(1,1);\n\treturn min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat sdCut(vec3 p,float a,float h){\n    p.y*=a;\n    p.y-=(abs(p.x)+abs(p.z))*h;p=abs(p);\n\treturn (p.x+p.y+p.z-1.)*.5;\n}\n\n#define t iTime\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 opTwist(in vec3 p )\n{\n    float k = clamp(sin((progress)*PI*2.),-0.85,.85)*1.5; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return  vec3(m*p.xz,p.y);\n}\n\n\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\n//SCENE\nfloat map(vec3 p){\n    vec3 c = vec3(5.,10.1,0.);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    p *= rotate_y(progress*2.*PI);\n\tvec3 tw = opTwist(p+vec3(0.,.65,0.));\n    /*float r = 0.125;\n    float db = sdBox(tw, vec3(0.5,0.5,1. ));\n    tw = opTwist((q+vec3(0.,-1.1,0.)));\n    float dc = sdCyl(tw, .5, r*5.);*/\n    float r = 0.;//mix(0.,0.125,sin(progress*PI*2.)*.5+.5);\n    float ir = 0.25;//mix(0.,0.125,1.-sin(progress*PI*2.)*.5+.5);\n    float db = sdRoundBox(tw, vec3(0.5,0.5,1. )-r,r);\n    tw = opTwist((p+vec3(0.,-1.2,0.)));\n    float dc = sdRoundedCylinder(tw, r+ir,r,.5-r);\n    return min(db,dc);\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    return normalize(e.xxx*map(p+e.xxx*EPS)+e.xyy*map(p+e.xyy*EPS)+\n                     e.yxy*map(p+e.yxy*EPS)+e.yyx*map(p+e.yyx*EPS));\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR,d;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        d=map(p);\n        if(abs(d)<EPS||t>FAR)break;\n        t+=step(d,1.)*d*.5+d*.5;\n    }\n    n=normal(p);\n    return min(t,FAR);\n}\n\n//RAYMARCHING UNDER SURFACE\nfloat trace2(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR2,d;\n    for(int i=ZERO;i<ITER2;i++){\n        p=ro+rd*t;\n        d=-map(p);\n        if(abs(d)<EPS2||d<EPS2)break;\n        t+=d;\n    }\n    n=-normal(p);\n    return t;\n}\n\n//CUBEMAP\nvec3 cubemap(vec3 d){    \n\treturn texture(iChannel0,d).rgb;\n}\n\n//FRESNEL EQUATION\nfloat schlickFresnel(float ri,float co) {\n    float r=(1.-ri)/(1.+ri);\n    r=r*r;\n    return r+(1.-r)*pow(1.-co,5.);\n}\n\n//GET LIGHT PATH\nvec3 lightPath(vec3 p,vec3 rd,float ri){\n    vec3 n;\n    vec3 r0=-rd;\n    //2nd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r1=refract(rd,n,ri);\n    r1=length(r1)<EPS?r0:r1;\n    //3rd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r2=refract(rd,n,ri);\n    r2=length(r2)<EPS?r1:r2;\n    //final refraction\n    trace2(p,rd,p,n);\n    vec3 r3= vec3(0.);//refract(rd,n,ri);\n    r3.r =refract(rd,n,ri * .89).r;\n    r3.g =refract(rd,n,ri).g;\n    r3.b =refract(rd,n,ri * 1.11).b;\n    return length(r3)<EPS?r2:r3;\n}\n\n//MATERIAL\nvec3 material(vec3 p,vec3 rd,vec3 n){\n\n    //1st reflection\n    vec3 l0=reflect(rd,n);\n\n    //cosine for fresnel\n    float co=max(0.,dot(-rd,n));\n    \n    //low frequency light path\n    float f1=schlickFresnel(RI1,co);\n    vec3 l1=lightPath(p,refract(rd,n,1./RI1),RI1);\n    \n    //high frequency light path\n    float f2=schlickFresnel(RI2,co);\n    vec3 l2=lightPath(p,refract(rd,n,1./RI2),RI2);\n\n    //dispersion\n    float a=0.;\n    vec3 dc=vec3(0);\n    vec3 r=cubemap(l0);\n    for(int i=ZERO;i<10;i++){\n        vec3 l=normalize(mix(l1,l2,a));\n        float f=mix(f1,f2,a);\n        float ior = noise(l*10.).x;\n        dc.r += (cubemap(l+ior)*hsv(a+.9,1.,1.)*(1.-f)+r*f).r;\n\t\tdc.g += (cubemap(l)*hsv(a+.9,1.,1.)*(1.-f)+r*f).g;\n\t\tdc.b += (cubemap(l-ior)*hsv(a+.9,1.,1.)*(1.-f)+r*f).b;\n        \n        dc+=(cubemap(l)*hsv(a+.9,1.,1.)*(1.-f)+r*f)*0.0125;\n        a+=.1;\n    }\n    dc*=.275;\n    \n    \n    \n    return dc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //CAMERA SETUP\n    vec2 m=iMouse.xy/iResolution.xy;\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),\n         ro=vec3(0,0,-6.),\n         rd=normalize(vec3(uv,1.5));\n    //GET SURFACE\n    float t=trace(ro,rd,p,n);\n\n    //SHADING\n    float w=0.;\n    if(t>9.){\n        //background\n        c=vec3(0);\n    }else{\n        //diamond\n\t    c=material(p,rd,n);\n        w=smoothstep(1.60,1.61,length(c));\n    }\n    fragColor=vec4(c,w);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Common:snippets\n\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n","name":"Common","description":"","type":"common"}]}