{"ver":"0.1","info":{"id":"styfRG","date":"1664728098","viewed":100,"name":"interlocked grids","username":"jt","description":"Filling space with two interlocked grids - the structure refined by [url=https://www.shadertoy.com/view/stVfDw]interlocked cube tori[/url].\nAnimation shows: (0) even grid, (1) odd grid, (2,3) both grids combined","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["grid","cube","voxel","honeycomb","dda","tiling","tesselation","skew","regular","spacefilling","interlocked","bcc","apeirohedron","mucube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/styfRG interlocked grids, 2022 by Jakob Thomsen\n// based on https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// using DDA from https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon by jt\n\n// Tiling space with interlocked grids.\n\n// Animation shows: (0) even grid, (1) odd grid, (2,3) both grids combined\n\n// tags: grid, mucube, cube, voxel, honeycomb, dda, tiling, tesselation, spacefilling, interlocked, bcc, regular, skew, apeirohedron\n\n// See also: https://en.wikipedia.org/wiki/Regular_skew_apeirohedron\n\n#define REPETITIONS 1u\n\n#define BLACK 0u\n#define GREY (BLACK + 1u)\n#define WHITE (GREY + 1u)\n#define COLORS (WHITE + 1u)\n\nvec3 palette(uint i)\n{\n    return vec3(i) / float(WHITE);\n}\n\n// two half-patterns fit together to fill one cube exactly in a body-centred cubic (BCC) lattice pattern.\nbool half_pattern(ivec3 i)\n{\n    i = abs(i); // global mirror-symmetry (to make sure \"mod\" works for negative numbers)\n    i = (i & 1); // mod 2 using bit-operator to avoid mod which is buggy on windows\n\n    if(i.x == 0 && i.y == 0 || i.y == 0 && i.z == 0 || i.z == 0 && i.x == 0)\n        return true;\n\n    return false;\n}\n\n// Fills one unit cell (2^3 voxels)\nuint pattern(ivec3 i, uint stage)\n{\n    stage = stage & 3u; // NOTE: using bit-operators rather than modulo because of % bugs on windows\n\n    if(stage == 0u || stage >= 2u)\n    {\n        bool c = half_pattern(i);\n        if(c)\n            return WHITE;\n    }\n\n    if(stage == 1u || stage >= 2u)\n    {\n        bool c = half_pattern(i+1);\n        if(c)\n            return GREY;\n    }\n\n    return 0u;\n}\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\nfloat sdSphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c, uint stage)\n{\n    if(any(greaterThan(abs(c), ivec3(REPETITIONS * 6u)))) return false;\n    return pattern(c, stage) > 0u;\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS (24u * (1u << REPETITIONS))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint stage = uint(floor(iTime / 5.0));\n\n    vec2 screenPos = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = vec3(screenPos.x, screenPos.y, 2.0);\n    vec3 rayPos = vec3(0.0, 0.0, -float(REPETITIONS * 16u));\n\n    float mx = 2.0 * PI * float(-iMouse.x) / float(iResolution.x);\n    float my = PI * float(-iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * PI * fract(iTime * 0.025);\n    my = (iMouse.y > 10.0) ? my : PI / 2.0;\n\n    mat2 S = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    rayPos.yz = S * rayPos.yz;\n    rayDir.yz = S * rayDir.yz;\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n    \n    rayDir = normalize(rayDir);\n\n    ivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n    vec3 color = vec3(1.0);\n    vec3 sideDist;\n    bvec3 mask;\n    // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    vec3 deltaDist;\n    {\n        deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\n        for (uint i = 0u; i < MAX_RAY_STEPS; i++)\n        {\n            if (getVoxel(mapPos, stage)) break; // forked shader used continue here\n\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += ivec3(vec3(mask)) * rayStep;\n        }\n\n        color *= mask.x ? vec3(0.25) : mask.y ? vec3(0.5) : mask.z ? vec3(0.75) : vec3(0.0);\n    }\n\n    fragColor = vec4(0);\n    \n    if(any(greaterThan(abs(mapPos), ivec3(REPETITIONS * 6u))))\n        return;\n\n    color *= palette(pattern(mapPos, stage));\n\n    // jt's 3d-texture addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? sideDist.x - deltaDist.x : mask.y ? sideDist.y - deltaDist.y : mask.z ? sideDist.z - deltaDist.z : 0.0) / length(rayDir);\n    //float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir); // rayDir not normalized\n    float d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized\n\n    vec3 dst = rayPos + rayDir * d;    \n\n    //color *= smoothstep(0.6,0.61, distance(dst, vec3(mapPos)+0.5));\n    //color += 0.05*(1.0-smoothstep(0.6,0.61, distance(dst, vec3(mapPos)+0.5)));\n\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n    color *= mix(fogcolor, color, exp(-d * d / 200.0)); // fog for depth impression & to suppress flickering\n\n    //fragColor = vec4(color, 1.0);\n\tfragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}