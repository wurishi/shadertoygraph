{"ver":"0.1","info":{"id":"sdGSWG","date":"1635187302","viewed":109,"name":"eindacor_bezier","username":"Eindacor_DS","description":"they're bezier curves, you dolt!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// POINT_COUNT must be greater than 3 and be an even number!\n#define POINT_COUNT 12\n\n#define SEGMENT_COUNT 25\n#define ANTI_ALIAS .002\n#define SHOW_CONSTRUCTS true\n#define SHOW_LINES true\n#define SHOW_POINTS true\n#define HORIZONTAL true\n#define SHOW_CURVE_SEGMENTS false\n#define HARMONIC_MODE false\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getQuadraticBezierSmoothStep(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv, float lineThickness, float aa) {\n    vec2 previousPoint = p0;\n    \n    float val = 0.f;\n    \n    for (int i=0; i<SEGMENT_COUNT; i++) {\n        if (i==0) {\n            continue; // ignore the first segment\n        }\n\n        float t = float(i) / float(SEGMENT_COUNT);\n\n        vec2 a = mix(p0, p1, t);\n        vec2 b = mix(p1, p2, t);\n        vec2 c = mix(p2, p3, t);\n\n        vec2 d = mix(a, b, t);\n        vec2 e = mix(b, c, t);\n\n        vec2 p = mix(d, e, t);\n        val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p, uv, lineThickness, aa, true));\n\n        previousPoint = p;\n    }\n    val = mix(val, 1.0, lineSegmentSmoothStep(previousPoint, p3, uv, lineThickness, aa, true));\n    \n    return val;\n}\n\nfloat getPointSmoothStep(vec2 p, vec2 uv, float radius, float antiAlias) {\n    float pDist = distance(uv, p);\n    return smoothstep(radius + antiAlias, radius - antiAlias, pDist);\n}\n\nfloat normalSin(float sinVal) {\n    return (sinVal + 1.f) / 2.f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (POINT_COUNT % 2 == 1 || POINT_COUNT < 4) {\n        fragColor = vec4(1.f, 0, 0, 1.f);\n        return;\n    }\n\n    vec4 curveColor = vec4(0.f, 1.f, 0.5f, 1.f);\n    float lineColorVal = .5f;\n    vec4 lineColor = vec4(lineColorVal, lineColorVal, lineColorVal, 1.f);\n    vec4 pointColor = vec4(1);\n     \n    float lineThickness = .005;\n    float pointRadius = .01;\n    \n    int lineSegments = 4;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec2[POINT_COUNT] points;\n    \n    float canvasBuffer = .05f;\n    \n    for (int i=0; i<POINT_COUNT; i++) {\n        if (HARMONIC_MODE) {\n            points[i].y = normalSin(sin(iTime * float(i + 1) * .5f));\n        } else {\n            points[i].y = normalSin(sin(iTime * hash(vec2(i + 1, i + 1))));\n        }\n        \n        points[i].y  = mix(canvasBuffer, 1.f - canvasBuffer, points[i].y);\n        \n        if (HORIZONTAL) {\n            points[i].x = float(i) * 1.f/float(POINT_COUNT-1);\n        } else {\n            points[i].x = normalSin(sin(iTime * hash(vec2(i - 1, i - 1))));\n        }\n        \n        points[i].x = mix(canvasBuffer, aspectRatio - canvasBuffer, points[i].x);\n    }\n    \n     // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    curveColor.x = col.x;\n    curveColor.y = col.y;\n    curveColor.z = col.z;\n\n    // Output to screen\n    fragColor = vec4(0.f, 0.f, 0.f,1.0);\n     \n    for (int i=1; i<POINT_COUNT; i++) {\n        vec2 p0 = points[i-1];\n        vec2 p1 = points[i];\n        \n        if (SHOW_CONSTRUCTS) {\n            if (SHOW_LINES) {\n                fragColor = mix(fragColor, lineColor, lineSegmentSmoothStep(p0, p1, uv, .002, ANTI_ALIAS, true));\n            }\n            \n            if (SHOW_POINTS) {\n                fragColor = mix(fragColor, pointColor, getPointSmoothStep(p0, uv, pointRadius, ANTI_ALIAS));    \n                if (i == POINT_COUNT - 1) {\n                    fragColor = mix(fragColor, pointColor, getPointSmoothStep(p1, uv, pointRadius, ANTI_ALIAS));\n                }\n            } \n        }\n    }\n    \n    int numCurves = (POINT_COUNT - 2) / 2;\n    \n    vec2 previousPoint = points[0];\n    for (int n=0; n<numCurves; n++) {\n        float lineValR = hash(vec2(n+1, n+1));\n        float lineValG = hash(vec2(n, n));\n        \n        if (SHOW_CURVE_SEGMENTS) {\n            curveColor = vec4(lineValR, lineValG, .5f, 1.f);\n        }\n        \n        vec2 p0 = previousPoint;\n        \n        int curveIndex = n * 2;\n        vec2 p1 = points[curveIndex + 1];\n        vec2 p2 = points[curveIndex + 2];\n        \n        vec2 p3 = curveIndex + 3 == POINT_COUNT - 1 ? points[curveIndex + 3] : mix(p2, points[curveIndex + 3], .5f);\n        previousPoint = p3;\n        \n        if (SHOW_POINTS && curveIndex + 3 != POINT_COUNT - 1) {\n            fragColor = mix(fragColor, pointColor * .5, getPointSmoothStep(p3, uv, pointRadius * .75, ANTI_ALIAS));\n        }\n        \n        fragColor = mix(fragColor, curveColor, getQuadraticBezierSmoothStep(p0, p1, p2, p3, uv, lineThickness, .002));\n    }\n}","name":"Image","description":"","type":"image"}]}