{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hash3( float n )\n\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n//--------------------------------------------------------------------------------\n// quaternion manipulation\n//--------------------------------------------------------------------------------\n\nvec4 qsqr( vec4 a )\n{\n    return vec4( a.x*a.x - dot(a.yzw,a.yzw), 2.0*a.x*(a.yzw) );\n}\n\nvec4 qcube( vec4 a )\n{\n\treturn a * ( 4.0*a.x*a.x - dot(a,a)*vec4(3.0,1.0,1.0,1.0) );\n}\n\nvec4 qinv( vec4 a )\n{\n    return vec4( a.x, - a.yzw )/dot(a,a);\n}\n\nvec4 qmul( vec4 a,  vec4 b )\n{return vec4( a.x*b.x - dot(a.yzw,b.yzw),a.x*(b.yzw)+b.x*(a.yzw)+ cross(a.yzw,b.yzw) );\n}\n\nvec4 qconj( vec4 a )\n{\n    return vec4( a.x, - a.yzw );\n}\n\n//--------------------------------------------------------------------------------\n\nfloat zoom=1.;\nvec3 dz = vec3(0.);\nvec4 c;\n\nvec3 map( vec3 p )\n{\n    vec4 z = vec4(p, 0. );\n\n\tvec4 pz = vec4(  0.0 );\n\tfloat dz2 = 0.0;\n\tvec2  t = vec2( 1e10 );\n\tfloat eps=0.0001;\n\n\t\n\t\n\tc=z;\n\t\n\tfor( int i=0; i<10; i++ ) \n\t{\n       \n\t\tpz=z;\n\t\t\n\t\t// formula\n\t\t\n\t\tz = (qinv( z )+ z)-qconj(c);\n\t\t\n\t\t\n        // stop under divergence or convergence\t\n\t\tdz= (z-pz).xyz;\n        dz2 = dot(dz, dz);\t\n\t\t\n\n        if( dz2>1./eps || dz2<eps) break;\t\t\t\t \n\n        // orbit trapping ( |dz|Â² and z_x  )\n\t\tt = min( t, vec2( dz2, abs(z.x) ));\n\n\t}\n\n\t\n\tfloat d=(dz2<1.)?sqrt(dz2)*log(dz2/eps):-1./sqrt(dz2)*log(dz2*eps);\n\t\n\n\treturn vec3( d, t );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 10.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n\tfloat dt = h;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<40; i++ )\n\t{\n        if( h<precis||t>maxd ) break;\n        t += 0.4*dt;\n\t    vec3 res = map( ro+rd*t );\n\t\th = res.x;\n\t\tfloat h2 = map( ro+rd*(t+precis) ).x;\n\t\t//Newton correction f/f'\n\t\tdt=min(dt,abs(h/(h2-h)*precis));\n\t\td = res.y;\n\t\tm = res.z;\n    }\n\n    if( t>maxd || dt>1. ) m=-1.0;\n    return vec3( t, d, m );\n}\n\n\n\n// Created by inigo quilez - iq/2013\n\nvec3 calcPixel( in vec2 pi, in float time )\n{\n\tvec2 q = pi / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy;\n\n    // camera\n\n\tfloat an = -3.4 + 0.2*time*0.1 - 6.2*m.x;\n    vec3 ro = 5.0*zoom*vec3(sin(an),0.15,cos(an));\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n\t\n\t// shade\n    vec3 col = vec3(0.0);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = normalize(dz);\n        vec3 sor = nor;\n\n        // material\t\t\n\t\tvec3 mate = 0.5 + 0.5*sin( tmat.z*4.0 + 4.0 + vec3(3.0,1.5,2.0)  + nor*0.2 ).xzy;\n\t\t\n        // lighting\t\t\n\t\tfloat occ = clamp( 0.5+tmat.y*0.5 + 0.5*(tmat.y*tmat.y), 0.0, 1.0 ) * (1.0 + 0.1*nor.y);\n\t\t\n        // diffuse\t\t\n\t\tcol = vec3(0.0);\n\t\tfor( int i=0; i<32; i++ )\n\t\t{\n\t\t\tvec3 rr = normalize(-1.0 + 2.0*hash3(float(i)*123.5463));\n\t\t\trr = normalize( nor + 8.0*rr );\n\t\t\trr = rr * sign(dot(nor,rr));\t\t\t\t\t\t\t  \n            col += pow( texture( iChannel0, rr ).xyz, vec3(2.2) ) * dot(rr,nor);\n\n\t\t}\n        col = 5.0 * occ * (col/32.0);\n\n        // rim\t\t\n\t\tcol *= 1.0 + 1.0*pow(clamp(1.0+dot(rd,sor),0.0,1.0),1.0)*vec3(1.0);\n\n        // specular\t\t \n\t\tfloat fre = pow( clamp(1.0+dot(rd,sor),0.0,1.0), 5.0 );\n\t\tvec3  ref = reflect( rd, nor );\n\t\tcol *= 1.0 - 0.5*fre; \n\t\tcol += 1.5 * (0.5 + 0.5*fre) * pow( texture( iChannel0, ref ).xyz, vec3(2.0) ) * occ;\n\n        col *= mate;\n    }\n\telse\n\t{\n        // background\t\t\n\t\tcol = pow( texture( iChannel0, rd ).xyz, vec3(2.2) );\n\n\t}\n\n\t// gamma\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\t\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    fragColor = vec4( calcPixel( fragCoord.xy, iTime ), 1.0 );\n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjGWh","date":"1387323098","viewed":339,"name":"Venetian glass","username":"guil","description":"Compared to the previous attempt, I made some modifications in the pseudo distance function (line 79) and in the intersection algorithm. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""}}