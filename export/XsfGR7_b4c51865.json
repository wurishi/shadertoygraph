{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/* \nIf you think this shader is an useful example, \nplease like it :-)\n\nreference:\nhttps://www.shadertoy.com/view/Mdl3Rr\n\nchange log:\n- 2013-04-10 initial release\n*/\n\n#define LIGHT_ANIMATION\n//#define LOW_QUALITY\t\t// uncomment this if this shader runs too slow on your PC\n//#define ULTRA_QUALITY \t// uncomment this if you have a really fast GPU :-)\n#define SMOKE\t\t\t\t// comment this if you think the smoke effect is too annoying\n\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\t\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat udRoundBox( in vec3 p, in vec3 b, in float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat opU( in float d1, in float d2 )\n{\n\treturn min(d1,d2);\n}\n\nvec3 translate( in vec3 v, in vec3 t )\n{\n\treturn v - t;\n}\n\nfloat scene( in vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n\t\n\tvec4 boxd1 = vec4( 0.5, 3.5, 0.5, 0.25 ); // sxyz, r\n\tvec4 boxp1 = vec4( 0.0, 3.5, 0.0, 0.0 ); // xyz, 0\n\tboxd1.xyz -= boxd1.w;\n\t\n\tvec4 boxd2 = vec4( 3.0, 0.5, 0.5, 0.25 ); // sxyz, r\n\tvec4 boxp2 = vec4( 0.0, 4.5, 0.0, 0.0 ); // xyz, 0\n\tboxd2.xyz -= boxd2.w;\n\t\n\t\n\tfloat d = 99999.0;\n\t\n\td = opU( d, udRoundBox( translate( pos, boxp1.xyz ), boxd1.xyz, boxd1.w ) );\n\td = opU( d, udRoundBox( translate( pos, boxp2.xyz ), boxd2.xyz, boxd2.w ) );\n\td = opU( d, sdPlane( pos, plane ) );\n\t\n\treturn d;\n}\n\nvec3 sceneNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor;\n\tnor.x = scene( pos + eps.xyy ) - scene( pos - eps.xyy );\n\tnor.y = scene( pos + eps.yxy ) - scene( pos - eps.yxy );\n\tnor.z = scene( pos + eps.yyx ) - scene( pos - eps.yyx );\n\treturn normalize( nor );\n}\n\nbool raymarch( in Ray ray, in int maxSteps, out vec3 hitPos, out vec3 hitNrm )\n{\n\tconst float hitThreshold = 0.0001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n\n\tvec3 pos = ray.org;\n\n\tfor ( int i = 0; i < 256; i++ )\n\t{\n\t\tif ( i >= maxSteps )\n\t\t\tbreak;\n\t\tfloat d = scene( pos );\n\n\t\tif ( d < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = pos;\n\t\t\thitNrm = sceneNormal( pos );\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * ray.dir;\n\t}\n\treturn hit;\n}\n\n#ifdef LOW_QUALITY\n#define INSCATTER_STEPS 24\n#else\n#\tifdef ULTRA_QUALITY\n#define INSCATTER_STEPS 64\n#\telse\n#define INSCATTER_STEPS 48\n#\tendif\n#endif\n\n\nfloat raySphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz; // looks like we are going place sphere from an offset from ray origin, which is = camera\n\tfloat b = 2.0 * dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w * sph.w; // w should be size\n\tfloat h = b * b - 4.0 * c;\n\tif ( h < 0.0 )\n\t{\n\t\treturn -10000.0;\n\t}\n\tfloat t = (-b - sqrt(h)) / 2.0;\n\t\n\treturn t;\n}\n\nfloat gAnimTime;\n\nvec3 inscatter( in Ray rayEye, in vec4 light, in vec3 screenPos, in float sceneTraceDepth )\n{\n\tvec3 rayEeyeNDir = normalize( rayEye.dir );\n\t\n\t// the eye ray does not intersect with the light, so skip computing\n\tif ( raySphereIntersect( rayEye.org, rayEeyeNDir, light ) < -9999.0 )\n\t\treturn vec3( 0.0 );\n\t\n\tfloat scatter = 0.0;\n\tfloat invStepSize = 1.0 / float( INSCATTER_STEPS );\n\t\n\tvec3 hitPos, hitNrm;\n\tvec3 p = rayEye.org;\n\tvec3 dp = rayEeyeNDir * invStepSize * sceneTraceDepth;\n\t\n\t// apply random offset to minimize banding artifacts.\n\tp += dp * noise( screenPos ) * 1.5;\n\t\n\tfor ( int i = 0; i < INSCATTER_STEPS; ++i )\n\t{\n\t\tp += dp;\n\t\t\n\t\tRay rayLgt;\n\t\trayLgt.org = p;\n\t\trayLgt.dir = light.xyz - p;\n\t\tfloat dist2Lgt = length( rayLgt.dir );\n\t\trayLgt.dir /= 8.0;\n\t\t\n\t\tfloat sum = 0.0;\n\t\tif ( !raymarch( rayLgt, 16, hitPos, hitNrm ) )\n\t\t{\n\t\t\t// a simple falloff function base on distance to light\n\t\t\tfloat falloff = 1.0 - pow( clamp( dist2Lgt / light.w, 0.0, 1.0 ), 0.125 );\n\t\t\tsum += falloff;\n\t\t\t\n#ifdef SMOKE\n\t\t\tfloat smoke = noise( 1.25 * ( p + vec3( gAnimTime, 0.0, 0.0 ) ) ) * 0.375;\n\t\t\tsum += smoke * falloff;\n#endif\n\t\t}\n\t\t\n\t\tscatter += sum;\n\t}\n\t\n\tscatter *= invStepSize; // normalize the scattering value\n\tscatter *= 8.0; // make it brighter\n\t\n\treturn vec3( scatter );\n}\n\nfloat softshadow( in Ray ray, in float mint, in float maxt, in float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = scene( ray.org + ray.dir * t );\n        if ( h < 0.001 )\n            return 0.0;\n\t\t\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gAnimTime = iTime * 0.5;\n\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3( 0.0, 3.0, 5.0 );\n\t\n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir = vec3( ndcXY * vec2( aspectRatio, 1.0 ), -1.0 ); // OpenGL is right handed\n\t\n\t// define the point light in world space (XYZ, range)\n\tvec4 lightWs = vec4( 0.0, 4.5, -4.0, 10.0 );\n#ifdef LIGHT_ANIMATION\n\tlightWs.x += sin( gAnimTime ) * 2.0;\n\tlightWs.y += cos( gAnimTime ) * 2.0;\n#endif\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\tvec4 c = vec4( 0.0 );\n\t\n\tif ( raymarch( ray, 128, sceneWsPos, sceneWsNrm ) )\n\t{\n\t\t// apply simple depth fog\n\t\tfloat viewZ = sceneWsPos.z - camWsXYZ.z;\n\t\tfloat fog = clamp( ( viewZ + 20.0 ) / 5.0 , 0.0, 1.0 );\n\t\tfog = fog * fog;\n\t\tc.rgb = vec3( 0.125 * fog );\n\t}\n\t\n\t// apply scattering of the\n\tc.rgb += inscatter( ray, lightWs, vec3( fragCoord.xy, 0.0 ), 12.0 );\n\t\n\t// color correction - Sherlock color palette\n\tc.r = smoothstep( 0.0, 1.0, c.r );\n\tc.g = smoothstep( 0.0, 1.0, c.g - 0.1 );\n\tc.b = smoothstep(-0.3, 1.3, c.b );\n\t\n\tfragColor = c;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfGR7","date":"1365649664","viewed":2036,"name":"The Cross","username":"ming","description":"Inspired by robertcupisz 's attic shader, this shader demonstrates a simplified implementation of omni-directional volumetric light scattering (please see the inscatter() function).","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","example","volumetric"],"hasliked":0,"parentid":"","parentname":""}}