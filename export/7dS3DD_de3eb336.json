{"ver":"0.1","info":{"id":"7dS3DD","date":"1617407314","viewed":167,"name":"One Ring in Green Hill Zone","username":"inspirnathan","description":"One ring is all you need!","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","phong","sonic","ring","greenhillzone","inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XllXDX","filepath":"https://soundcloud.com/cream-this-rabbit/green-hill-zone-act-1-sonic-mania-ost","previewfilepath":"https://soundcloud.com/cream-this-rabbit/green-hill-zone-act-1-sonic-mania-ost","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** One Ring in Green Hill Zone by inspirnathan (Nathan Vaughn)\n** \n** Resources/Credit:\n** Torus SDF: https://iquilezles.org/articles/distfunctions\n** Phong Illumination: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n** Fog: https://iquilezles.org/articles/fog\n** Music: https://soundcloud.com/cream-this-rabbit/green-hill-zone-act-1-sonic-mania-ost\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\nconst vec3 light1Pos = vec3(2, 10, 1);\nconst vec3 light2Pos = vec3(0, -1, 4);\n\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c)\n  );\n}\n\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nmat3 identity() {\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nstruct Material {\n  vec3 k_d; // diffuse reflection coefficient\n  vec3 k_a; // ambient reflection coefficient\n  vec3 k_s; // specular reflection coefficient\n  float alpha; // shininess constant\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial shinyYellow() {\n  vec3 k_d = vec3(1., .67, 0.2) * 1.8;\n  vec3 k_a = vec3(0.);\n  vec3 k_s = vec3(1);\n  float alpha = 5.;\n  return Material(k_d, k_a, k_s, alpha);\n}\n\nMaterial checkerBoard(vec3 p) {\n  vec3 k_d = vec3(1. + 0.9 * mod(floor(p.x) + floor(p.z), 2.0)) * vec3(0.93, 0.6, 0.40) * 2. - .8;\n  vec3 k_a = vec3(0.3);\n  vec3 k_s = vec3(0);\n  float alpha = 1.;\n  return Material(k_d, k_a, k_s, alpha);\n}\n\nvec3 transform(vec3 p, vec3 offset, mat3 transformationMatrix) {\n  return (p - offset) * transformationMatrix;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nSurface sFloor(vec3 p) {\n  Surface flooring;\n  flooring.id = 1;\n  flooring.sd = p.y + 1.;\n  flooring.mat = checkerBoard(p);\n\n  return flooring;\n}\n\nSurface sRing(vec3 p) {\n  vec3 offset = vec3(0, 0.5, -4);\n  mat3 m = rotateZ(PI/2.) * rotateX(iTime);\n\n  Surface ring;\n  ring.id = 2;\n  ring.sd = sdTorus(transform(p, offset, m), vec2(0.5, 0.1));\n  ring.mat = shinyYellow();\n  \n  return ring;\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  Surface co = sFloor(p);\n  co = opUnion(co, sRing(p));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1, -1) * 0.0005;\n  return normalize(\n    e.xyy * scene(p + e.xyy).sd +\n    e.yyx * scene(p + e.yyx).sd +\n    e.yxy * scene(p + e.yxy).sd +\n    e.xxx * scene(p + e.xxx).sd);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {\n  vec3 N = calcNormal(p);\n  vec3 L = normalize(lightPos - p);\n  vec3 V = normalize(eye - p);\n  vec3 R = normalize(reflect(-L, N));\n\n  float dotLN = clamp(dot(L, N), 0., 1.);\n  float dotRV = clamp(dot(R, V), 0., 1.);\n\n  return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n  const vec3 ambientLight = vec3(0.3);\n  vec3 color = ambientLight * k_a;\n\n  vec3 light1Int = vec3(0.3);\n\n  color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Int);\n\n  vec3 light2Int = vec3(0.7);\n\n  color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Int);    \n  return color;\n}\n\nfloat shadow(vec3 p, vec3 light, float darkness) {\n  vec3 lightDir = normalize(light - p);\n  float shadowRayLength = rayMarch(p + calcNormal(p)*PRECISION, lightDir).sd;\n  if (shadowRayLength < length(lightDir - p)) return -darkness;\n  else return 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  Surface co = rayMarch(ro, rd);\n\n  if (co.sd > MAX_DIST) {\n    col = mix(vec3(0, 1, 1), vec3(0, 0, 1), uv.y);\n  } else {\n    vec3 p = ro + rd * co.sd;\n    vec3 normal = calcNormal(p);\n    \n    vec3 K_a = co.mat.k_a;\n    vec3 K_d = co.mat.k_d;\n    vec3 K_s = co.mat.k_s;\n    float shininess = co.mat.alpha;\n\n    col = K_a * shadow(p, light1Pos, 0.);\n\n    col += phongIllumination(K_a, K_d, K_s, shininess, p, ro);\n\n    col = mix( col, vec3(0, 1, 0.6), 1. - exp( -0.0002 * co.sd * co.sd * 6.));\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}