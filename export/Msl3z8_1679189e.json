{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Copyright (c) 2013 Andrew Baldwin (baldand)\n// License = Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\nfloat rnd(vec2 n)\n{\n  return fract(sin(dot(n.xy, vec2(12.345,67.891)))*12345.6789);\n}\n\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 normal, inout float t)\n{\n\tfloat d = dot(rd,-normal);\n\tfloat n = dot(ro,-normal);\n\tt = mix(t,n/d,step(0.001,d));\n\treturn d;\n}\n\nfloat intersectSphere(vec3 ro, vec3 rd, float size, out float t0, out float t1, out vec3 normal)\n{\n\tfloat a = dot(rd,ro);\n\tfloat b = dot(ro,ro);\n\tfloat d = a*a - b + size*size;\n\tif (d>=0.) {\n\t\tfloat sd = sqrt(d);\n\t\tfloat ta = -a + sd;\n\t\tfloat tb = -a - sd;\n\t\tt0 = min(ta,tb);\n\t\tt1 = max(ta,tb);\n\t\tif (t0<0.) t0=t1;\n\t\tif (t0<0.) d=-0.1;\n\t\tnormal = normalize(ro+t0*rd);\n\t}\n\treturn d;\n}\n\nvec3 model(vec3 rayOrigin, vec3 rayDirection)\n{\n\tfloat size = 100.;\n\tfloat t=10000.0;\n\tvec3 normal = vec3(0.,1.,0.);\n\tfloat d = intersectPlane(rayOrigin-vec3(0.,11.+sin(iTime*.1)*10.,0.), rayDirection, normal, t);\n\tfloat ts0,ts1;\n\tvec3 intersection;\n\tintersection = rayOrigin + t * rayDirection;\n\tfloat nd;\n\tfloat ground = step(0.,d);\n\tvec3 offset = vec3(0.,3./**sin(iTime+50.*float(i)*.1)*/,0.);\n\tvec3 nnormal;\n\tnd = intersectSphere(rayOrigin-offset,rayDirection,10./*+4.0*sin(iTime+float(i)*.1)*/,ts0,ts1,nnormal);\n\tfloat update = step(ts0,t)*step(0.,nd);\n\tt = mix(t,ts0,update);\n\td = mix(d,nd,update);\n\tground = mix(ground,0.,update);\n\tnormal = mix(normal,nnormal,update);\n\tintersection = mix(intersection,rayOrigin + t * rayDirection,update);\n\tfloat sky = step(d,0.);\n\tfloat ambient = .1;\n\tfloat sun = clamp(1.*dot(normalize(vec3(1.,1.,0.)),normalize(normal)),0.,1000.);\n\tvec3 nearlight = vec3(20.,15.,15.)-intersection;\n\tfloat near = clamp(10.0*(1./(length(nearlight)*length(nearlight)))*dot(normalize(nearlight),normalize(normal)),0.,1000.);\n\tvec3 glow = 1.*step(.9,fract(intersection*1.));\n\tvec3 colour = vec3(fract(intersection*.1))*(ambient+sun+near)+glow;\n\tvec3 groundcolour = vec3(step(.5,fract(intersection.x*.1)) + step(.5,fract(intersection.z*.1)));\n\treturn mix(mix(colour,groundcolour,ground),vec3(0.5,0.9,1.),sky);\n}\n\nvec3 camera(in vec2 sensorCoordinate, in vec3 cameraPosition, in vec3 cameraLookingAt, in vec3 cameraUp)\n{\n\tvec2 uv = 1.-sensorCoordinate;\n\tvec3 sensorPosition = cameraPosition;\n\tvec3 direction = normalize(cameraLookingAt - sensorPosition);\n\tvec3 lensPosition = sensorPosition + 2.*direction;\n\tconst vec2 lensSize = vec2(.1);\n    vec2 sensorSize = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 offset = sensorSize * (uv - 0.5);\n\tvec3 right = cross(cameraUp,direction);\n\tvec3 rayOrigin = sensorPosition + offset.y*cameraUp + offset.x*right;\n\t\n\t// Render the scene for this camera pixel\n\tfloat rt = fract(iTime);\n\tvec3 colour = vec3(0.);\n\tfloat y=0.5;\n\tfloat x=0.5;\n\tfloat refractiveIndexAirLens = .6666;\n\tfloat refractiveIndexLensAir = 1.5;\n\tfloat radiusInternal = .7;\n\tfloat radiusInternalOffset = radiusInternal+.1;\n\tfloat radiusExternal = 50.;\n\tfloat radiusExternalOffset = radiusExternal+.1;\n\tfor (float y=0.;y<=1.;y+=.2){\n\t\tfor (float x=0.;x<=1.;x+=.2){\n\t\t\tvec2 lensOffset = lensSize * ( vec2(x+.2* rnd(uv+vec2(x+rt,y)), y+.2* rnd(uv+vec2(x,y+rt)) ) - .5);\n\t\t\tvec3 lensIntersect = lensPosition + lensOffset.y * cameraUp + lensOffset.x*right;\n\t\t\tvec3 rayDirection = normalize(lensIntersect - rayOrigin);\n\t\n\t\t\t// Lens has two spherical surfaces which ray must refract through\n\t\t\tvec3 lensEntrySurfaceCentre = lensPosition+radiusInternal*direction;\n\t\t\tvec3 lensExitSurfaceCentre = lensPosition-radiusExternal*direction;\n\t\t\tfloat tn0,tn1,tx0,tx1;\n\t\t\tvec3 normal;\n\t\t\tvec3 lensEntryRayOrigin = rayOrigin - lensEntrySurfaceCentre;\n\t\t\tintersectSphere(lensEntryRayOrigin, rayDirection, radiusInternalOffset,tn0,tn1,normal);\n\t\t\tvec3 internalLensRayOrigin = rayOrigin + rayDirection * tn0;  \n\t\t\tvec3 internalLensRayDirection = normalize(refract(rayDirection, normal, refractiveIndexAirLens));\t\n\t\t\tintersectSphere(internalLensRayOrigin - lensExitSurfaceCentre, internalLensRayDirection, radiusExternalOffset,tx0,tx1,normal);\t\t\tvec3 externalLensRayOrigin = internalLensRayOrigin + internalLensRayDirection * tx0;\n\t\t\tvec3 externalLensRayDirection = normalize(refract(internalLensRayDirection,-normal, refractiveIndexLensAir));\n\t\t\t// Ray has emerged from lens and enters the model\n\t\t\tcolour += .04*max(model(externalLensRayOrigin, externalLensRayDirection),vec3(0.));\n\t\t}\n\t}\n\t\t\n\t// Post-process for display\n\tvec3 toneMapped = colour/(1.+colour);\n\t// Random RGB dither noise to avoid any gradient lines\n\tvec3 dither = vec3(rnd(uv+rt),rnd(uv+rt+1.),rnd(uv+rt+2.))/255.;\n\t// Return final colour\n\treturn toneMapped + dither;\n}\n\nvec3 world(vec2 fragCoord)\n{\n\t// Position camera with interaction\n\tfloat rotspeed = iTime*.1+10.*iMouse.x/iResolution.x;\n\tfloat radius = 50.+sin(iTime*.5)*35.;\n\tvec3 cameraPos = vec3(radius*sin(rotspeed),0.,radius*cos(rotspeed));\n\tvec3 cameraTarget = vec3(0.,0.,0.);\n\tvec3 cameraUp = vec3(0.,1.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\treturn camera(uv,cameraPos,cameraTarget,cameraUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(world(fragCoord),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msl3z8","date":"1362950748","viewed":377,"name":"Blurred ball","username":"baldand","description":"A simple model of a camera with a cheap lens looking at a ball with stripes.\nMouse left/right to move the camera around the ball.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","dof","camera","lensmodel"],"hasliked":0,"parentid":"","parentname":""}}