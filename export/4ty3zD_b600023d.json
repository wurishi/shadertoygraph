{"ver":"0.1","info":{"id":"4ty3zD","date":"1473426777","viewed":142,"name":"Ray Marcher of a sphere","username":"chazbg","description":"A simple ray marcher of a single sphere","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZFAR       1500.0\n#define ITERATIONS 100.0\n#define DELTA      ZFAR / ITERATIONS\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs)\n{\n\treturn uvs * 2.0 - 1.0;\n}\n\nstruct Sphere\n{\n\tvec3 pos;\n\tfloat r;\n    float ior;\n};\n\nbool getIntersection(vec3 ray, vec3 cameraPos, out vec3 intersection, Sphere s, out vec3 n)\n{\n    bool res = false;\n  \n    vec3 cameraToCenter = s.pos - cameraPos;\n\n    for(float i = 0.0; i < ZFAR; i += DELTA)\n    {\n        vec3 newRay = ray * i;\n        vec3 newPoint = cameraPos  + newRay;\n        \n        vec3 pointToSphere = newPoint - s.pos;\n        \n        if( length(pointToSphere) <=  s.r)\n        {\n        \t res = true; \n            n = normalize(pointToSphere);\n            intersection = newPoint;\n        }\n\t\n    }\n    \n    return res;\n}\n\nvec3 getCameraPos(float time)\n{\n    mat3 rot = mat3(\n        vec3(cos(time), 0.0, -sin(time)),\n        vec3(0.0,       1.0,  0.0),\n        vec3(sin(time), 0.0,  cos(time)));\n    return rot * vec3(0.0, 0.0, 1000.0);\n}\n\nvec3 getViewDirection(vec3 cameraPos)\n{\n    return normalize(vec3(0.0) - cameraPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3  lightDir    = normalize(vec3(1.0, 1.0, 1.0));\n\tvec2  offset      = normalizeUVs(fragCoord.xy / iResolution.xy);\n\tvec3  cameraPos   = getCameraPos(iTime);\n\tvec3  cameraView  = getViewDirection(cameraPos);\n\tvec3  cameraUp    = vec3(0.0, 1.0,  0.0);\n\tvec3  cameraRight = cross(cameraView, cameraUp);\n\tfloat cameraNear  = 4.0;\n\t\n\tvec3 ray = normalize(cameraRight * offset.x * (iResolution.x / iResolution.y) + cameraUp * -offset.y + cameraView * cameraNear);\n\t\n\tSphere s;\n    s.pos = vec3(0.0);\n    s.r = 200.0;\n    s.ior = 1.0 / 1.46;\n\n    vec3 intr;\n    vec3 n;\n    if(getIntersection(ray, cameraPos, intr, s, n))\n    {\n \t\tvec3 refl = reflect(ray, n);\n        fragColor = texture(iChannel0, refl);\n        vec3 fakeVec;\n        \n        vec3 rightVec = normalize(cross(n, vec3 (0.0,1.0,0.0)));\n        vec3 upVec = normalize(cross(rightVec, n));\n    }\n    else\n    {\n        fragColor = texture(iChannel0, ray);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}