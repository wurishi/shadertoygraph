{"ver":"0.1","info":{"id":"clscWr","date":"1690624219","viewed":43,"name":"Horizontal QTE Bar","username":"xynanxdb","description":"This is a sample for a horizontal QTE Bar that has 3 segments. Currently, the bar relies heavily on zeroOffsetMin and zeroOffsetMax to sync the border with the fill. If there is a better way of handling this, please leave a comment down below.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bar","horizontal","qte"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float aa = 0.002;\n\nconst vec2 barSize = vec2(0.5, 0.06);\nconst vec2 knobSize = vec2(0.01, 0.1);\n\nconst float barBorderWidth = 0.03;\nconst float borderRadius = 0.9;\nconst float knobBorderRadius = 0.8;\n\nconst vec3 borderColor = vec3(1.0);\nconst vec3 emptyFillColor = vec3(0.83);\nconst vec3 tapZoneColor = vec3(0.235, 0.58, 0.717);\nconst vec3 progressColor = vec3(0.815, 0.427, 0.145);\nconst vec3 knobColor = vec3(0.9, 0.733, 0.0);\n\nconst vec2[3] sectorLimits = vec2[3](vec2(0, 0.105), vec2(0.3, 0.6), vec2(0.8, 1.0));\n\nfloat progress = 0.3;\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec4 rounded_rectangle(vec2 uv, vec2 barWidthHeight, float cornerRadius, vec3 color) {\n    float rw = cornerRadius * barWidthHeight.x;\n    float rh = cornerRadius * barWidthHeight.y;\n    \n    vec2 abs_uv = abs(uv.xy) - vec2(rw, rh);\n    vec2 dist = vec2(max(abs_uv.xy, 0.0));\n    \n    float xedge = barWidthHeight.x - rw;\n    float xsquare = 1.0 - smoothstep(xedge - aa, xedge + aa, length(dist));\n    \n    float yedge = barWidthHeight.y - rh;\n    float ysquare = 1.0 - smoothstep(yedge - aa, yedge + aa, length(dist));\n    \n    float ss = xsquare * ysquare;\n    return vec4(vec3(ss) * color, ss);\n}\n\n\nvec4 draw_bar_background(vec2 center) {\n    vec2 barSizeTemp = barSize + barBorderWidth;\n    \n    //draw Border\n    vec4 canvas = rounded_rectangle(center, barSizeTemp, borderRadius, borderColor);\n    \n    //draw FilleArea\n    vec4 fillArea = rounded_rectangle(center, barSize, borderRadius, emptyFillColor);\n    canvas = mix(canvas, fillArea, fillArea.a);\n    \n    return canvas;\n}\n\nfloat remap_range(float value, float lx0, float lx1, float rx0, float rx1) {\n    return rx0 + (value - lx0) * (rx1 - rx0) / (lx1 - lx0);\n}\n\nvec4 draw_tap_zone_mask(vec2 uv, float lx0, float lx1) {\n    vec4 canvas = vec4(0.0);\n    canvas.a = step(uv.x, lx1) - step(uv.x, lx0);\n    \n    return canvas;\n}\n\nvec4 draw_progress(vec2 uv, vec2 center, float zeroOffsetMin, float zeroOffsetMax) {\n    vec4 canvas = rounded_rectangle(center, barSize, borderRadius, progressColor);\n    \n    float rx = remap_range(0.0, 0.0, 1.0, zeroOffsetMin - aa, zeroOffsetMax + aa);\n    float ry = remap_range(progress, 0.0, 1.0, zeroOffsetMin - aa, zeroOffsetMax + aa);\n    vec4 zone = draw_tap_zone_mask(uv, rx, ry);\n    canvas.a *= zone.a;\n    \n    return canvas;\n}\n\nvec4 draw_knob(vec2 uv, vec2 center, float zeroOffsetMin, float zeroOffsetMax) {\n    float rx = mix(zeroOffsetMin - aa, zeroOffsetMax + aa, progress); \n    vec4 canvas = rounded_rectangle(vec2(uv.x - rx, center.y), knobSize, knobBorderRadius, knobColor);\n    \n    return canvas;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float d = length(uv);\n    \n    // draw background\n    vec4 layer = draw_bar_background(uv);\n    \n    // draw fill\n    vec4 fill = rounded_rectangle(uv, barSize, borderRadius, tapZoneColor);\n    \n    float zeroOffsetMin = (barSize.x * 0.1) - 0.005;\n    float zeroOffsetMax = (barSize.x * 2.0) - ((barSize.x * 0.1) - 0.005);\n    \n    vec2 rectFillUV = uv + vec2(barSize.x, 0.0);\n    \n    // draw segment\n    vec4 zones = vec4(1.0);\n    vec2 uv2 = fragCoord / iResolution.xy;\n    for (int i = 0; i < sectorLimits.length(); i++) {\n        float x = sectorLimits[i].x;\n        float y = sectorLimits[i].y;\n        \n        if (x == 0.0 && y == 0.0) {\n            continue;\n        }\n        \n        \n        float rx = remap_range(x, 0.0, 1.0, zeroOffsetMin - aa, zeroOffsetMax + aa);\n        float ry = remap_range(y, 0.0, 1.0, zeroOffsetMin - aa, zeroOffsetMax + aa);\n        \n        vec4 zone = draw_tap_zone_mask(rectFillUV, rx, ry);\n        \n        if (i == 0) {\n            zones = zone;\n        } else {\n            zones = mix(zones, zone, zone.a);\n        }\n        \n    }\n    \n    //Temporarily change the *= -> = to tune zeroOffsets\n    fill.a *= zones.a;\n    layer = mix(layer, fill, fill.a);\n    \n    //draw Progress\n    progress = 0.5 * (sin(iTime) + 1.0);\n    vec4 progressVec = draw_progress(rectFillUV, uv, zeroOffsetMin, zeroOffsetMax);\n    layer = mix(layer, progressVec, progressVec.a);\n    \n    //draw Knob\n    vec4 knob = draw_knob(rectFillUV, uv, zeroOffsetMin, zeroOffsetMax);\n    layer = mix(layer, knob, knob.a);\n\n    fragColor = layer;\n}","name":"Image","description":"","type":"image"}]}