{"ver":"0.1","info":{"id":"cdK3DV","date":"1679067234","viewed":237,"name":"Made by GPT-4","username":"vvsotnikov","description":"Made by GPT-4","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gpt4","gpt4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The function returns the signed distance to a sphere with a given radius\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// The function returns the signed distance to a rounded box\nfloat roundedBoxSDF(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\n// Rotate the position around the Y-axis at the origin\nvec3 rotateY(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Create the scene by combining the cube and sphere distances\nfloat sceneSDF(vec3 p) {\n    vec3 boxPos = vec3(0.0);\n    vec3 spherePos = vec3(1.0, 0.0, 0.0);\n\n    // Rotate the sphere around the Y-axis\n    float angle = iTime;\n    spherePos = rotateY(spherePos, angle);\n\n    // Get the distances to the cube and sphere\n    float cubeDistance = roundedBoxSDF(p - boxPos, vec3(0.5), 0.1);\n    float sphereDistance = sphereSDF(p - spherePos, 0.5);\n\n    // Return the minimum distance, which represents the scene\n    return min(cubeDistance, sphereDistance);\n}\n\n// Calculate the normal of the scene based at one point\nvec3 getNormal(vec3 p) {\n    float d = sceneSDF(p);\n    vec2 e = vec2(1.0, -1.0) * 0.01;\n    return normalize(d - vec3(sceneSDF(p - e.xyy), sceneSDF(p - e.yxy), sceneSDF(p - e.yyx)));\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates, from -1.0 to 1.0\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 camPos = vec3(0.0, 0.0, -5.0);\n    vec3 camTarget = vec3(0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = cross(camUp, camDir);\n\n    // Calculate the ray direction from the camera\n    vec3 rayDir = normalize(uv.x * camRight + uv.y * camUp + camDir * 2.0);\n\n    // Raymarching\n    vec3 p = camPos;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 64; i++) {\n        d = sceneSDF(p);\n        t += d;\n        p = camPos + rayDir * t;\n    }\n\n    // Lighting\n    vec3 normal = getNormal(p);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 2.0));\n    float diffuse = max(dot(lightDir, normal), 0.4); // CHANGED: 0.1 to 0.4\n    float specular = pow(max(dot(reflect(lightDir, normal), -rayDir), 0.0), 16.0);\n\n    // Calculate the distances for the cube and sphere\n    vec3 boxPos = vec3(0.0);\n    vec3 spherePos = vec3(1.0, 0.0, 0.0);\n    spherePos = rotateY(spherePos, iTime);\n    float dBox = roundedBoxSDF(p - boxPos, vec3(0.5), 0.1);\n    float dSphere = sphereSDF(p - spherePos, 0.5);\n\n    // Assign colors to the objects\n    vec3 albedo;\n    if (d < 0.01) {\n        // Mix red (for sphere) and blue (for cube) colors based on the distance which object is in front\n        albedo = (dBox < dSphere) ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    } else {\n        // Background color (sky)\n        albedo = mix(vec3(0.6, 0.8, 1.0), vec3(0.2, 0.4, 0.8), uv.y);\n    }\n\n    // Calculate the final color\n    vec3 col = albedo * (diffuse + specular);\n\n    // Output the final color\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}