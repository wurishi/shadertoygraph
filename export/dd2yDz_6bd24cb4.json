{"ver":"0.1","info":{"id":"dd2yDz","date":"1687622059","viewed":282,"name":"flim - Filmic Color Transform","username":"beans_please","description":"Experimental Port of flim (Film Emulation Transform)\n\nOriginal Repo:\nhttps://github.com/bean-mhm/flim\n","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["color","display","gamma","filmic","filmemulation","viewtransform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // RGB Sweep\n    vec3 col = flim_rgb_sweep(uv);\n\n    // Alternate between flim and native sRGB\n    if (mod(iTime, 3.0) > 1.5)\n    {\n        col = pow(col, vec3(1.0 / 2.2));\n    }\n    else\n    {\n        float exposure = 0.0;\n        col = flim_transform(col, exposure, iChannel0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nfloat wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat lerp(float a, float b, float t)\n{\n    return a + t * (b - a);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a + t * (b - a);\n}\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = map_range_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = map_range(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = map_range_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? map_range_clamp(mono, 0.05, 0.5, 0.0, 1.0) : map_range_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n","name":"Buffer A","description":"","type":"buffer"}]}