{"ver":"0.1","info":{"id":"4tsSRN","date":"1435005253","viewed":356,"name":"Trip2016","username":"ophilbinbriscoe","description":"first shader sandbox","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circle","psychedelic","circular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//noise function taken from https://www.shadertoy.com/view/XslGRr\n\nfloat hash( float n ){\n\treturn fract(sin(n)*43758.5453);\n}\n\n//this noise function was originally 3D noise, \n//but I am just setting z to 0 for the sake of simplicity here\n//also cause most effects only care about 2D noise\nfloat noise( vec2 uv ){\n\tvec3 x = vec3(uv, 0);\n\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t\t   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ring( float angle, float dist, float ANG, float THICKNESS, float POS, float SIZE ) {\n    //angles between 4 and 15 are good\n    //negative thickness makes it black, values around 0.02 are good\n    \n    float ZIGZAG = abs( mod( angle, ANG ) - ANG * 0.5 ) * SIZE;\n    return ceil( dist - POS + ZIGZAG) - ceil( dist - (POS+THICKNESS) + ZIGZAG);   \n}\nfloat burst( float angle, float dist, float ANG ) {\n    float B = abs( mod( angle, ANG ) - ANG * 0.5 );\n    return B;\n}\nfloat lim( float IN, float amount ) {\n\treturn IN * amount + (1.0 - amount);   \n}\nfloat inv( float IN ) {\n \treturn 1.0 - IN;   \n}\nfloat ppp( float IN ) {\n \treturn IN * IN * IN;   \n}\nfloat dots( float angle, float dist, float ANG, float POS ) {\n    return ppp(7.5*burst( angle, dist, ANG )/ANG) * ppp(inv(ANG*1.5*distance( dist, POS )));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n    \n    uv = vec2( uv.x - 0.5, uv.y - 0.5 );\n    \n    float angle = degrees( atan( uv.y / uv.x ) );\n    \n    float TIMESCALE = 0.1;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    \n    float n = noise( vec2( dist, T ) );\n    float slow_n = noise( vec2( dist, T * 0.2) );\n    float fast_n = noise( vec2( dist, T * 2.0) );\n    float vslow_n = noise( vec2( dist, T * 0.01) );\n    float vfast_n = noise( vec2( dist, T * 50.0) );\n    float t = noise( vec2( iTime, T ) );\n    \n    float rand_r = noise( vec2( -T, T ) );\n    float slow_r = noise( vec2( -T * 0.5, 1.0 ) );\n    float vslow_r = noise( vec2( -T * 0.2, 1.0 ) );\n    float vvslow_r = noise( vec2( -T* 0.05, 1.0 ) );\n    \n    float div = 7.0;\n    float m = sin ( mod( angle, div )/(div*0.5) * 3.14 * 0.5 );\n    float a = mod( angle, 10.0 ) * noise( vec2( T, angle ) );\n        \n    float TIME_MOD_SCALE = 1.0;\n    float TIME_MOD = floor(0.5+sin( noise( vec2(-iTime + 1000.0, 1.0 )) ))*0.5*TIMESCALE*TIME_MOD_SCALE;\n\n    TIMESCALE = TIMESCALE * TIME_MOD;\n    \n    float GRANULARITY = 1.75;\n    float GRAN_DIST_FALLOFF = 0.5;\n    float GRAN_DIST_FALLOFF_MOD = tan(noise (vec2( 500.0, -T ) ));\n    GRAN_DIST_FALLOFF = GRAN_DIST_FALLOFF + GRAN_DIST_FALLOFF_MOD * 0.5;\n    \n    float Gr = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 50.0;\n    float Gg = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 80.0;\n    float Gb = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 100.0;\n    \n    float Gsign = clamp( sign( noise (vec2( T * 0.22, -T * 1.5 )) -0.5 ), -1.0, 0.0 );\n    \n    float rn = 360.0 / (ceil( noise(vec2( sin(T*0.1), 0.5 ) ) * 50.0) * 2.0 );\t//randomly some divisor of 360\n    float rd1 = ceil( noise(vec2( tan(T), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd2 = ceil( noise(vec2( sin(T), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd4 = ceil( noise(vec2( tan(T*0.75+99.0), 1.0 ) ) * 1.2 );\t//randomly either 1 or 2\n    float rd5 = ceil( noise(vec2( tan(T*0.8+124.0), 1.0 ) ) * 1.5 );\t//randomly either 1 or 2\n    float rd6 = ceil( noise(vec2( tan(T*0.7+24.0), 1.0 ) ) * 1.7 );\t//randomly either 1 or 2\n    float rd7 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 1.4 );\t//randomly either 1 or 2\n    float exp4 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 2.0 ) * rd1;\n    float coarse3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 3.0 );\n    float coarse10 = ceil( noise(vec2( cos(T), 1.0 ) ) * 10.0 );\n    \n    vec3 RING1 = rd2 * 0.5 * ring( angle, dist,6.0, 0.02, n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * floor( n + 0.5 );\n    vec3 RING2 = ring( angle, dist,10.0, 0.01, n/2.0, 0.01) * vec3( 1.0, 1.0, 1.0 ) * ceil( n - 0.3 );\n    vec3 RING3 = ring( angle+(vslow_n*200.0*coarse3)*(2.0+n), dist,90.0*rd1/rd4, (0.02 + rand_r*0.01 + ppp(slow_r)*0.011)*ppp(rd4), n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.5;\n    vec3 RING4 = ring( angle-iTime*(5.0*n), dist,10.0, 0.05, n, 0.01) * vec3( sin(T), cos(T), 0.1 ) * 0.5;\n    vec3 RING5 = ring( angle, dist,30.0, n*20.0, n+0.3, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.05 + (dist)*0.05;\n    vec3 BURST1 = burst( angle, dist, rn * rd1 ) * vec3( 1.0, 1.0, 1.0 ) * 0.03 * (1.0 - dist);\n    vec3 RING6 = max(ring( angle-(vslow_n*200.0*coarse3)*(2.0+vslow_n), dist,45.0*rd1, 0.3, n, 0.01),0.0) * vec3( sin(T), tan(T), rand_r ) * (rd7 - 1.0) * inv(dist) * 0.5;\n    vec3 DOTS1 = max(ceil(dots( angle + T*30.0, dist, 10.0, 0.25 + rand_r*0.1 )-24.5 * (1.0+rand_r)),0.0) * vec3( rand_r, inv(rand_r), n ) * 0.15;\n    vec3 DOTS2 = max(ceil(dots( angle - T*35.0, dist, 10.0, 0.3 + rand_r*0.2 )-16.4 * (2.0-rand_r)),0.0) * vec3( n, rand_r, inv(rand_r) ) * 0.15;\n    vec3 DOTS3 = clamp( 1.0 * dots( angle + T * 45.0, dist, 15.0, 0.9 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.05;\n    vec3 DOTS4 = clamp( 1.0 * dots( angle - T * 45.0, dist, 15.0, 0.82 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.025;\n    vec3 RING = RING1 + RING2 + RING3 + RING4 + RING5 + BURST1 + DOTS1 + DOTS2 + RING6 + DOTS3 + DOTS4;\n    \n    float r = RING.r + max((1.0 - dist * 2.0),-0.5) + noise( vec2( dist * Gr * sin( noise(vec2( iTime * 8.0 * TIMESCALE, -iTime )) ), dist ) );;//floor(n*2.0) * a;\n    float g = RING.g + max((1.0 - dist * 3.5),-1.5) + noise( vec2( dist * Gg * TIMESCALE * cos( noise(vec2( iTime * 12.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.1) - a;\n    float b = RING.b + max((1.0 - dist * 2.5),-1.0) + noise( vec2( dist * Gb * tan( noise(vec2( iTime * 1.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.2) - a;\n    \n    vec3 boost = vec3( 1.0 * lim(ppp(slow_r) + 0.4, 0.5), 0.2 + 2.0 * lim(inv(ppp(slow_r)), 0.5), 0.5 * lim(rand_r,0.2) + 0.1);    \n       \n\tfragColor = vec4(r*boost.r,g*boost.g,b*boost.b,1.0) * mix(dist,1.0,0.7);\n    \n    dist;\n    float over = fragCoord.y/iResolution.y;\n    //fragColor = vec4(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y,0.0,1.0);\n}","name":"","description":"","type":"image"}]}