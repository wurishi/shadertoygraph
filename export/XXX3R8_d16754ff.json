{"ver":"0.1","info":{"id":"XXX3R8","date":"1709887598","viewed":26,"name":"a_chelyshkin_task3","username":"artemchelyshkin","description":"for task","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["task1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\n\nfloat plane ( in vec3 p, vec4 n )\n{\n    if (dot ( p, n.xyz ) + n.w > 0.0)\n        return 0.0;\n    else return 1.0;\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdSpheretr(vec3 p, float r, vec3 offset)\n{\n  return max(length(p - offset) - r, plane(p, vec4(normalize(offset.xy), 0, -dot(offset, normalize(vec3(offset.xy, 0))))));\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 0.5;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat scene(vec3 p, out int element) {\n  if (sdFloor(p) < PRECISION)\n      element = 0;\n  else if (sdCylinder(p, vec3(0, 0, -1), vec3(0, 0, -1.2), 0.47)  < PRECISION)\n      element = 1;\n      else element = 2;\n  float co = min(sdCylinder(p, vec3(0, 0, -1), vec3(0, 0, -1.2), 0.47),\n              min(sdCylinder(p, vec3(0, 0, -1), vec3(0, 0, -1.2), 0.5),\n              min(sdCappedCone(p, vec3(-0.32, -0.32, -1.1), vec3(-0.5, -0.5, -1.1), 0.1, 0.05), \n              min(sdCappedCone(p, vec3(0.32, -0.32, -1.1), vec3(0.5, -0.5, -1.1), 0.1, 0.05),\n              min(sdSpheretr(p, 0.3, vec3(0.3, 0.37, -1.1)),\n              min(sdSpheretr(p, 0.3, vec3(-0.3, 0.37, -1.1)),\n              min(sdCylinder(p, vec3(0, 0, -1.2), vec3(0.4 * cos(iTime), 0.4 * -sin(iTime), -1.2), 0.01),\n              min(sdCylinder(p, vec3(0, 0, -1.2), vec3(0.2 * cos(iTime / 10.0), -0.2 * sin(iTime / 10.0), -1.2), 0.015),\n              min(sdCylinder(p, vec3(0.45, 0, -1.2), vec3(0.5, 0, -1.2), 0.015),\n              min(sdCylinder(p, vec3(-0.45, 0, -1.2), vec3(-0.5, 0, -1.2), 0.015),\n              min(sdCylinder(p, vec3(0, 0.45, -1.2), vec3(0, 0.5, -1.2), 0.015),\n              min(sdCylinder(p, vec3(0, -0.45, -1.2), vec3(0, -0.5, -1.2), 0.015),\n              min(sdSphere(p, 0.015, vec3(0.0, 0.0, -1.2)),\n              min(sdTorus(p, vec2(-1,0.3)), sdFloor(p)))))))))))))));\n  return co;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int element) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p, element);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    int element;\n    return normalize(\n      e.xyy * scene(p + e.xyy, element) +\n      e.yyx * scene(p + e.yyx, element) +\n      e.yxy * scene(p + e.yxy, element) +\n      e.xxx * scene(p + e.xxx, element));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0, 0.8, 0.98);\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0.25, -4);\n  vec3 rd = normalize(vec3(uv, 1));\n  vec3 obj_col = vec3(0, 0, 0.7);\n  int element;\n  float sd = rayMarch(ro, rd, element);\n  if (sd > MAX_DIST) {\n    //col = backgroundColor;\n    col = texture(iChannel1, uv).rgb;\n    \n  } else {\n    if (element == 0) {\n        //obj_col = vec3(0.9, 0, 0.35) * (-uv.y);\n        obj_col = texture(iChannel0, uv).rgb;\n    }\n    if (element == 1) {\n        //vec3 bufferA = texture(iChannel0, uv).rgb;\n        obj_col = vec3(1);\n    }\n    vec3 p = ro + rd * sd;\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(0.0 + cos(iTime), 3.0 + sin(iTime), -2.0);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.);\n    \n    col = dif * obj_col;\n  }\n  vec3 col2 = texture(iChannel1, uv).rgb;\n  \n  fragColor = vec4(col, 1.0);\n  //fragColor = vec4(col2, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  if (cos(iTime) > 0.1 && cos(iTime) < 0.6){\n      fragColor = vec4(255.0/255.0 * cos(iTime) / 0.7, 230.0/255.0* cos(iTime)/0.8,247.0/255.0* cos(iTime)/0.7,1.0);\n  }\n  else {\n      if (cos(iTime) >= 0.6) {\n          //fragColor = vec4(225.0/255.0 * 0.9  * (0.7/cos(iTime)) * ( 0.7 / cos(iTime)) *  ( 0.7 / cos(iTime)),\n          //            230.0/255.0 * 0.9 * (0.7/cos(iTime)),255.0/255.0* cos(iTime),1.0);\n          fragColor = vec4(225.0/255.0*0.7, 246.0/255.0*0.7, 255.0/255.0, 1.0);\n      }\n      else {\n      //fragColor = vec4(255.0/255.0,230.0/255.0,247.0/255.0,1.0);\n      fragColor = vec4(0.0, 0.0, 0.0 ,1.0);\n      }\n  }  \n}\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}