{"ver":"0.1","info":{"id":"dllczB","date":"1691094611","viewed":300,"name":"Raymarched CD-Rom","username":"gunthern","description":"Raymarched CR Rom shader, with diffraction grating based on Alan Zucconi's Unity shader (https://www.alanzucconi.com/2017/07/15/understanding-diffraction-grating/)\n\nClick and drag to rotate the CD manually.","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["rainbow","cd","disk","diffraction","spectral","grating","cdrom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define  MAX_DIST 20.0\n#define SURFACE_DIST 0.001\n#define WAVELENGTH_MULT 500.0\n\n// Surface constructor\nstruct Surface {\n\n    float dist;\n    vec3 col;\n    float spec;\n    vec3 refl;\n    vec3 refr;\n    vec3 difr;\n    \n};\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// 3D SDFs from https://iquilezles.org/articles/distfunctions\nfloat sdCylinderFloat(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nSurface sdCylinder(vec3 p, vec3 a, vec3 b, float r, vec3 col, float spec, vec3 refl, vec3 refr, vec3 difr)\n{\n    \n    return Surface(sdCylinderFloat(p, a, b, r), col, spec, refl, refr, difr);\n}\n\nSurface surfaceMin(Surface a, Surface b)\n{\n    if (a.dist > b.dist) return b;\n    \n    return a;\n}\n\nSurface GetDistColor(vec3 p) {\n\n    vec3 diskPos = vec3(0.0, 0.0, 3.0);\n    \n    mat3 rot = iMouse.z < 1.0 ? rotateY(iTime*0.5) : rotateX(iMouse.y*6.28/iResolution.y) * rotateY(-(iMouse.x*6.28)/iResolution.x);\n    vec3 diskPosRot = (p-diskPos)*rot+diskPos; // position with Y rotation\n    \n    // Values for diffraction\n    vec3 tangentUV = vec3(-normalize(diskPosRot).y, 0.0, normalize(diskPosRot).x);\n    vec3 tangentWorld = normalize(identity() * tangentUV);\n    \n    Surface outerDisk = sdCylinder(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.01), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.01), // disk surface b\n        1.015, // disk radius\n        vec3(0.22), // color\n        1000.0, // spec intensity\n        vec3(0.5), // reflect color\n        vec3(1.0), // refract color\n        vec3(0.0) // diffract color\n    );\n    \n    float outerDiskSubtract = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.1), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.1), // disk surface b\n        1.0 // disk radius\n    );\n    \n    Surface disk = sdCylinder(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.01), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.01), // disk surface b\n        1.0, // disk radius\n        vec3(0.2), // color\n        5000.0, // spec intensity\n        vec3(0.5), // reflect color\n        vec3(0.0), // refract color\n        tangentWorld // diffract color\n    );\n    \n    float diskSubtract = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.1), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.1), // disk surface b\n        0.35 // disk radius\n    );\n   \n    Surface mirrorBand = sdCylinder(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.01), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.01), // disk surface b\n        0.5, // disk radius\n        vec3(0.35), // color\n        5000.0, // spec intensity\n        vec3(0.75), // reflect color\n        vec3(0.0), // refract color\n        vec3(0.0) // diffract color\n    );\n    \n    float mirrorBandSubtract = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.1), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.1), // disk surface b\n        0.295 // disk radius\n    );\n    \n    Surface plasticHub = sdCylinder(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.01), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.01), // disk surface b\n        0.295, // disk radius\n        vec3(0.22), // color\n        1000.0, // spec intensity\n        vec3(0.5), // reflect color\n        vec3(1.0), // refract color\n        vec3(0.0) // diffract color\n    );\n    \n    float plasticHubDivot = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.1), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.1), // disk surface b\n        0.26 // disk radius\n    );\n    \n    float plasticHubDivotSubtract0 = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.1), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.1), // disk surface b\n        0.2575 // disk radius\n    );\n    \n    float plasticHubDivotSubtract1 = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 0.008), // disk surface a\n        diskPos - vec3(0.0, 0.0, 0.008), // disk surface b\n        0.5 // disk radius\n    );\n    \n    float hole = sdCylinderFloat(\n        diskPosRot,\n        diskPos + vec3(0.0, 0.0, 1.0), // disk surface a\n        diskPos - vec3(0.0, 0.0, 1.0), // disk surface b\n        0.115 // disk radius\n    );\n    \n    outerDisk.dist = max(outerDisk.dist, -outerDiskSubtract);\n    \n    disk.dist = max(disk.dist, -diskSubtract);\n    \n    mirrorBand.dist = max(mirrorBand.dist, -mirrorBandSubtract);\n    \n    plasticHubDivot = max(plasticHubDivot, -min(plasticHubDivotSubtract0, plasticHubDivotSubtract1));\n    float plasticHubSubtract = min(plasticHubDivot, hole);\n    plasticHub.dist = max(plasticHub.dist, -plasticHubSubtract);\n    \n    return surfaceMin(surfaceMin(surfaceMin(outerDisk, disk), mirrorBand), plasticHub);\n    \n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDistColor(p).dist;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistColor(p-e.xyy).dist,\n        GetDistColor(p-e.yxy).dist,\n        GetDistColor(p-e.yyx).dist);\n        \n    return normalize(n);\n}\n\nSurface RayMarch(vec3 ro, vec3 rd) {\n\n    float dO = 0.0;\n    \n    vec3 p;\n    Surface distColor;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n        p = ro + rd*dO;\n        distColor = GetDistColor(p);\n        float dS = distColor.dist;\n        dO += dS;\n        if (dO>MAX_DIST || dS<SURFACE_DIST) break;\n    }\n    \n    vec3 col = distColor.col;\n    vec3 refl = distColor.refl * pow(texture(iChannel0, reflect(rd, GetNormal(p))).xyz, vec3(2.2));\n    float spec = distColor.spec;\n    vec3 refr = distColor.refr * texture(iChannel0, refract(rd, GetNormal(p), 0.99)).xyz;\n    vec3 difr = distColor.difr;\n    \n    return Surface(dO, col, spec, refl, refr, difr);\n}\n\nvec3 GetLight(vec3 p, vec3 c, vec3 lp) {\n    vec3 l = normalize(lp - p);\n    vec3 n = GetNormal(p); \n    \n    float diff = dot(n, l);\n    float d = RayMarch(p+n*SURFACE_DIST*2.0, l).dist;\n    if (d<length(lp-p) && d>0.01) diff *= 0.01;\n    \n    return clamp(diff * c, 0.0, 1.0);\n}\n\nvec3 GetSpecular(vec3 p, vec3 c, vec3 lp, vec3 ro, float sp) {\n    \n    vec3 l = normalize(lp - p);\n    vec3 h = normalize(l + normalize(ro - p));\n    vec3 n = GetNormal(p);\n    \n    return c * pow(max(0.0, dot(n, h)), sp);\n}\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 bump3y(vec3 x, vec3 yoffset) {\n\n    vec3 y = vec3(1.0) - x*x;\n    y = clamp(y - yoffset, 0.0, 1.0);\n    return y;\n}\n\nvec3 spectral_zucconi6(float w) {\n    //w: [400, 700]\n    //x: [0, 1]\n    //Mapping waves to RGB modularly\n    float x = clamp(((w - 400.0) / 300.0), 0.0, 1.0);\n\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);\n}\n\nvec3 GetDiffraction(vec3 l, vec3 rd, float d, vec3 difr) {\n            \n    float cos_ThetaL = dot(l, difr);\n    float cos_ThetaV = dot(rd, difr);\n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if (u == 0.0) return vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    for (int i=1; i<=8; i++)\n    {\n        float wavelength = u * d / float(i);\n        color += spectral_zucconi6(wavelength*WAVELENGTH_MULT);\n    }\n    \n    return clamp(pow(color, vec3(2.2)), 0.0, 1.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //ray origin\n    vec3 ro = vec3(0.0);\n    //ray direction\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    \n    // Raymarch and get values\n    Surface rs = RayMarch(ro, rd);\n    \n    vec3 p = (ro + rd * rs.dist);\n    \n    // Light position\n    vec3 lp = vec3(1.0, 2.5, 1.0);\n    \n    // diffuse lighting\n    vec3 diff = GetLight(p, vec3(1.0), lp);\n    \n    // specular\n    vec3 spec = GetSpecular(p, vec3(1.0), lp, ro, rs.spec);\n    \n    // diffraction\n    vec3 diffract = GetDiffraction(GetLight(p, vec3(1.0), vec3(0.0)), rd, rs.dist, rs.difr);\n    \n    // background\n    vec3 background = texture(iChannel0, vec3(uv.x, uv.y, 1.0)).xyz;\n    //vec3 background = vec3(0.0);\n    \n    // combine\n    vec3 color = rs.dist < MAX_DIST ? min(min(diff * rs.col + rs.refr + diffract, 1.0) + spec + rs.refl, 1.0) : background;\n    \n    //fragColor = vec4(rs.dist * 0.1);\n    //fragColor = vec4(diff, 1.0);\n    //fragColor = vec4(rs.col, 1.0);\n    //fragColor = vec4(vec3(spec), 1.0);\n    //fragColor = vec4(rs.refl, 1.0);\n    //fragColor = vec4(rs.refr, 1.0);\n    //fragColor = vec4(diffract, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}