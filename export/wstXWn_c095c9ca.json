{"ver":"0.1","info":{"id":"wstXWn","date":"1571807637","viewed":213,"name":"euler kelvin helmholtz","username":"micahbro","description":"shear layer instability (kelvin-helmholtz) simulated by particle vorticity advection","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["particles","fluidflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    ivec2 ifc = ivec2(round(fragCoord)); \n    \n    // velocity field visualization\n    vec2 vxvy = vec2(texelFetch(iChannel0, ifc, 0));    \n    vec3 sceneColor = (vec3(vxvy, 0) / 100.0 + 0.5);\n    \n    // inverse displacement map on texture visualization\n    if (false) {\n\t    vec2 ruv = vec2(texelFetch(iChannel2, ifc, 0));\n        ivec2 rxy = ivec2(round(ruv * iResolution.y + iResolution.xy*.5));\n\t    vec4 pix = texture(iChannel3, ruv + 0.5);\n        sceneColor = vec3(pix);\n    }\n    \n    // direct image flow visualization (but w/heavy spurious numerical diffusion)\n    if (true) {\n        sceneColor = vec3(texelFetch(iChannel2, ifc, 0));\n    }\n    \n    \n    int subsamp = 2;\n    int n = int(iResolution.x) / subsamp - 1; // / 2.);\n    int nv = 3; \n\n    float tracerSize = 0.003;\n    if (tracerSize > 0.) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < nv; j++) {\n                vec4 puvc = texelFetch(iChannel1, ivec2(i * subsamp, j * subsamp), 0);\n                vec2 puv = vec2(puvc); //vec2(puvc[0], puvc[1]);\n\n                vec2 duv = uv - puv;\n                float d2 = dot(duv, duv);\n\n                if (sqrt(d2) < tracerSize) {\n                    sceneColor = vec3(1. - float(i) / float(n), 0., float(i) / float(n));\n                }\n            }\n\n        }\n    }\n\n    // particle debug pane:\n    if (false) {\n        if (fragCoord.xy[0] < clamp(float(n * 2), 0., 20.)) {\n            vec4 puvc = texelFetch(iChannel1, ifc, 0);\n            sceneColor = vec3(puvc);\n        }\n    }\n    \n    \n\tfragColor = vec4(clamp(sceneColor, 0., 1.), 1);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    bool jet = false;\n    \n    if (iFrame < 10 && !jet) {\n        vec3 sceneColor;\n        float initpack = 1.0; //1.5; //1.3;\n        float stagger = trunc(fragCoord.y / 4.) / iResolution.y;\n        if (true) {\n            // linear shear (classic K-H) \n\t\t\tsceneColor = vec3((uv[0] + stagger) / initpack + 0.05*0., -0, 0.05); //vec3(uv + 0.5, 0);\n        } else {\n            // rotational shear\n        \tfloat coord = 2.*3.14159 * (uv[0] + stagger) / initpack / aspect * 1.004;\n        \tfloat circrad = 0.4;\n\t\t\tsceneColor = vec3(sin(coord)*circrad, cos(coord)*circrad, -0.05); \n        }\n\n        if (round(fragCoord.x) == 0.) {\n            //sceneColor = vec3(0.1, 0.05, 5);\n        } else if (round(fragCoord.x) == 2.) {\n            //sceneColor = vec3(-0.1, 0, -1);\n        } else if (round(fragCoord.x) == 4.) {\n            //sceneColor = vec3(0.2, 0.1, -3/2);\n        }\n        //sceneColor = vec3(0.0); //vec3(uv + 0.5, 0) / 2.0;\n        \n\t\tfragColor = vec4(sceneColor, 1);\n    } else {\n\t    ivec2 ifc = ivec2(round(fragCoord)); \n\t    vec4 puvc = texelFetch(iChannel0, ifc, 0);\n        \n        vec2 pxy = vec2(puvc) * iResolution.y + iResolution.xy*.5;\n        ivec2 ipxy = ivec2(round(pxy));\n\t    vec2 uvipxy = (vec2(ipxy) - iResolution.xy*.5) / iResolution.y;\n\n\t    //vec2 vxvy = vec2(texelFetch(iChannel1, ipxy, 0));\n\t    vec2 vxvy = vec2(texture(iChannel1, pxy / vec2(iResolution)));\n\n        // subtract off local contribution\n        //vec2 puv = vec2(puvc); //vec2(puvc[0], puvc[1]);        \n        //vec2 duv = uvipxy - puv;\n        //float d2 = dot(duv, duv);        \n        //vxvy -= puvc[2] * vec2(-duv[1], duv[0]) / d2;\n        \n        \n        float dt = 0.0001 ; // iTimeDelta * 0.01;\n        \n        //if (fragCoord.xy[0] <= 10.0) { dt = 0.; }\n        \n        \n        fragColor = puvc + dt * vec4(vxvy, 0, 0);\n        \n        aspect = 1./1.0 * .99 * aspect;\n        float aspy = .99;\n        if (fragColor[0] > aspect * .5) fragColor[0] -= aspect;\n        if (fragColor[0] <= -aspect * .5) fragColor[0] += aspect;\n        if (fragColor[1] > aspy * .5) fragColor[1] -= aspy;\n        if (fragColor[1] <= -aspy * .5) fragColor[1] += aspy;\n\n        \n        //if (fragCoord.xy[0] < 1.0 && iMouse[2] > 0.) {\n        if (abs(fragCoord.x + fragCoord.y / iResolution.y * 20. - iMouse.x) < 1.0 && iMouse[2] > 0.) {\n\t\t\tvec2 muv = (vec2(iMouse) - iResolution.xy*.5) / iResolution.y;\n            fragColor = vec4(muv, fragColor[2], fragColor[3]); \n        \n        }\n        \n    }\n\n    if (jet) {\n        vec3 sceneColor;\n        float initpack = 1.0; //1.5; //1.3;\n        float stagger = trunc(fragCoord.y / 4.) / iResolution.y;\n        \n        if (iFrame == int(round((aspect*.5 + uv[0] + stagger) * 100.))) {\n            \n            if (int(round(mod(fragCoord.x / 2., 2.))) == 0) {\n                fragColor = vec4(-aspect*.49, -0.1, -.2, 1); //vec3(uv + 0.5, 0);\n            } else {\n                fragColor = vec4(-aspect*.49, 0.1, .2, 1); //vec3(uv + 0.5, 0);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 vxvy = vec2(0.0);\n    \n    float bigr = 0.;\n    \n    // no-flux boundary conditions:\n    bool boxx = false;\n    bool boxy = true;\n    \n    float aspect = 1./1.0 *  .99/.98 * .98 * float(iResolution.x) / float(iResolution.y);\n    float aspy = .98;\n    float rfac = 0.05;\n    \n    // pseudo-periodic boundary conditions (crappy)\n    bool pbcx = false; //true;\n    bool pbcy = false;\n        \n   \tint subsamp = 2;\n    int n = int(iResolution.x) / subsamp - 1; // / 2.);\n    int nv = 3; \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < nv; j++) {\n        \n        vec4 puvc = texelFetch(iChannel1, ivec2(i * subsamp, j * subsamp), 0);\n        vec2 puv = vec2(puvc); //vec2(puvc[0], puvc[1]);\n        \n        vec2 duv = uv - puv;\n        float d2 = dot(duv, duv);\n        \n        if (sqrt(d2) > 0.01) {\n        \tvxvy += puvc[2] * vec2(-duv[1], duv[0]) / d2;\n        }\n        \n        if (bigr > 0.) {\n            \n            float dc = sqrt(dot(puv, puv));\n            float qinv = -puvc[2] * bigr / dc;\n            float r2p2 = bigr*bigr / dc / dc;\n            vec2 pinv = r2p2 * puv;\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * vec2(-duv[1], duv[0]) / d2;\n            }\n                        \n        }\n\n        if (boxy) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(puv[0], aspy - puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }\n\n\n        if (boxy) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(puv[0], -aspy - puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }        \n\n    \n        if (boxx) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(aspect - puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }      \n\n        if (boxx) {\n            \n            float qinv = -puvc[2];\n            vec2 pinv = vec2(-aspect - puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0]) + sign(qinv) * duv * rfac) / d2;\n            }\n                        \n        }\n\n        if (pbcy) {\n            \n            float qinv = puvc[2];\n            vec2 pinv = vec2(puv[0], aspy + puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n\n            qinv = puvc[2];\n            pinv = vec2(puv[0], aspy * 2. + puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n\n            \n            \n            if (pbcx) {\n\n                float qinv = puvc[2];\n                vec2 pinv = vec2(aspect + puv[0], aspy + puv[1]);\n\n                duv = uv - pinv;\n                d2 = dot(duv, duv);\n\n                if (sqrt(d2) > 0.01) {\n                    vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n                }\n\n            }                              \n            if (pbcx) {\n\n                float qinv = puvc[2];\n                vec2 pinv = vec2(-aspect + puv[0], aspy + puv[1]);\n\n                duv = uv - pinv;\n                d2 = dot(duv, duv);\n\n                if (sqrt(d2) > 0.01) {\n                    vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n                }\n\n            }        \n        }        \n\n        if (pbcy) {\n            \n            float qinv = puvc[2];\n            vec2 pinv = vec2(puv[0], -aspy + puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n\n            qinv = puvc[2];\n            pinv = vec2(puv[0], -aspy*2. + puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n            \n\n            if (pbcx) {\n\n                float qinv = puvc[2];\n                vec2 pinv = vec2(aspect + puv[0], -aspy + puv[1]);\n\n                duv = uv - pinv;\n                d2 = dot(duv, duv);\n\n                if (sqrt(d2) > 0.01) {\n                    vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n                }\n\n            }      \n\n            if (pbcx) {\n\n                float qinv = puvc[2];\n                vec2 pinv = vec2(-aspect + puv[0], -aspy + puv[1]);\n\n                duv = uv - pinv;\n                d2 = dot(duv, duv);\n\n                if (sqrt(d2) > 0.01) {\n                    vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n                }\n\n            }        \n        }        \n\n        \n        if (pbcx) {\n            \n            float qinv = puvc[2];\n            vec2 pinv = vec2(aspect + puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n\n            qinv = puvc[2];\n            pinv = vec2(aspect*2. + puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n            \n        }      \n\n        if (pbcx) {\n            \n            float qinv = puvc[2];\n            vec2 pinv = vec2(-aspect + puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n\n            qinv = puvc[2];\n            pinv = vec2(-aspect*2. + puv[0], puv[1]);\n        \t\n            duv = uv - pinv;\n        \td2 = dot(duv, duv);\n            \n            if (sqrt(d2) > 0.01) {\n                vxvy += qinv * (vec2(-duv[1], duv[0])) / d2;\n            }\n            \n        }   \n      }\n    }\n    \n    fragColor = vec4(vxvy, 0., 1.);\n    //vec3 sceneColor = (vec3(vxvy, 0) / 100.0 + 0.5);\n    \n\t//fragColor = vec4(clamp(sceneColor, 0., 1.), 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    float dt = 0.0001 ;\n    \n\n    if (iFrame < 10) {\n        \n        // mode:\n        if (true) {\n            // inverse displacement map on texture (but with numerical diffusion \n            //  spuriously smoothing the map)\n            fragColor = vec4(uv, 0, 0);\n        } else {\n            // direct image flow (but w/heavy spurious numerical diffusion)\n            fragColor = texture(iChannel2, fragCoord / vec2(iResolution));\n        }\n        \n    } else {\n        ivec2 ifc = ivec2(round(fragCoord)); \n\n        ///vec2 vxvy = vec2(texelFetch(iChannel0, ifc, 0));\n        vec2 vxvy = vec2(texture(iChannel0, fragCoord / vec2(iResolution)));\n\n        vec2 newFragCoord = fragCoord - dt * vxvy * vec2(iResolution);\n\n        fragColor = texture(iChannel1, newFragCoord / vec2(iResolution));\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}