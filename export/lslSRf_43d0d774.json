{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// mplanck\r\n// Tested on 13-inch Powerbook\r\n// Tested on Late 2013 iMac\r\n// Tested on Nvidia GTX 780 Windows 7\r\n\r\n// **************************************************************************\r\n// CONSTANTS\r\n\r\n#define PI 3.14159\r\n#define TWO_PI 6.28318\r\n#define PI_OVER_TWO 1.570796\r\n#define ONE_OVER_PI 0.318310\r\n#define GR   1.61803398\r\n\r\n#define SMALL_FLOAT 0.0001\r\n#define BIG_FLOAT 1000000.\r\n\r\n// **************************************************************************\r\n// MATERIAL DEFINES\r\n\r\n#define SPHERE_MATL 1.\r\n#define CHAMBER_MATL 2.\r\n#define BOND_MATL 3.\r\n\r\n// **************************************************************************\r\n// GLOBALS\r\n\r\nvec3  g_camPointAt   = vec3(0.);\r\nvec3  g_camOrigin    = vec3(0.);\r\n\r\nfloat g_time         = 0.;\r\n\r\nvec3  g_ldir         = vec3(.8, 1., 0.);\r\n\r\n// **************************************************************************\r\n// UTILITIES\r\n\r\n// Rotate the input point around the y-axis by the angle given as a\r\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\r\n// reuse the same angle on different points, so why do the heavy trig twice.\r\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\r\n\r\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\r\n{\r\n    return vec3(point.x * cosangle  + point.z * sinangle,\r\n        point.y,\r\n        point.x * -sinangle + point.z * cosangle);\r\n}\r\n\r\n// Rotate the input point around the x-axis by the angle given as a\r\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\r\n// reuse the same angle on different points, so why do the  heavy trig twice.\r\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\r\n\r\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\r\n{\r\n    return vec3(point.x,\r\n        point.y * cosangle - point.z * sinangle,\r\n        point.y * sinangle + point.z * cosangle);\r\n}\r\n\r\nfloat pow5(float v)\r\n{\r\n    float tmp = v*v;\r\n    return tmp*tmp*v;\r\n}\r\n\r\n// convert a 3d point to two polar coordinates.\r\n// First coordinate is elevation angle (angle from the plane going through x+z)\r\n// Second coordinate is azimuth (rotation around the y axis)\r\n// Range of outputs - ([PI/2, -PI/2], [-PI, PI])\r\nvec2 cartesianToPolar( vec3 p ) \r\n{    \r\n    return vec2(PI/2. - acos(p.y / length(p)), atan(p.z, p.x));\r\n}\r\n\r\nvec2 mergeobjs(vec2 a, vec2 b) \r\n{\r\n    if (a.x < b.x) { return a; } \r\n    else { return b; }\r\n    \r\n    // XXX: Some architectures have bad optimization paths\r\n    // that will cause inappropriate branching if you DON'T\r\n    // use an if statement here.\r\n    \r\n    //return mix(b, a, step(a.x, b.x)); \r\n}\r\n\r\n// **************************************************************************\r\n// DISTANCE FIELDS\r\n\r\nfloat spheredf( vec3 pos, float r ) \r\n{\r\n    return length( pos ) - r;\r\n}\r\n\r\nfloat segmentdf( vec3 p, vec3 a, vec3 b, float r)\r\n{\r\n    \r\n    vec3 ba = b - a;    \r\n    float t = dot(ba, (p - a)) / max(SMALL_FLOAT, dot(ba, ba));\r\n    t = clamp(t, 0., 1.);\r\n    return length(ba * t + a - p) - r;\r\n}\r\n\r\n\r\n// **************************************************************************\r\n// SCENE MARCHING\r\n\r\nvec2 buckeyballsobj(vec3 p, float mr)\r\n{    \r\n\r\n    vec2 ballsobj = vec2(BIG_FLOAT, SPHERE_MATL);\r\n    vec3 ap = abs(p);\r\n   \t//vec3 ap = p;\r\n    \r\n    // vertices\r\n    // fully positive hexagon\r\n    vec3 p1 = vec3(         .66, .33+.66 * GR,   .33 * GR);\r\n    vec3 p2 = vec3(         .33, .66+.33 * GR,   .66 * GR);\r\n    vec3 p3 = vec3(    .33 * GR,          .66, .33+.66*GR);\r\n    vec3 p4 = vec3(    .66 * GR,          .33, .66+.33*GR);\r\n    vec3 p5 = vec3(.33+.66 * GR,     .33 * GR,        .66);\r\n    vec3 p6 = vec3(.66+.33 * GR,     .66 * GR,        .33);\r\n\r\n    // fully positive connectors\r\n    vec3 p7 = vec3(         .33,           GR,         0.);\r\n    vec3 p8 = vec3(          GR,           0.,        .33);\r\n    vec3 p9 = vec3(          0.,          .33,         GR);\r\n\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p1, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p2, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p3, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p4, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p5, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p6, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p7, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p8, mr));\r\n    ballsobj.x = min( ballsobj.x, spheredf(ap - p9, mr));\r\n\r\n    vec2 bondsobj = vec2(BIG_FLOAT, BOND_MATL);\r\n\r\n    float br = .2 * mr;\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p1, p2, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p2, p3, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p3, p4, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p4, p5, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p5, p6, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p6, p1, br));\r\n\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p1, p7, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p5, p8, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p3, p9, br));\r\n\r\n    // bond neighbors\r\n    vec3 p10 = vec3(        -.33, .66+.33 * GR,     .66 * GR);\r\n    \r\n    vec3 p11 = vec3(      .66*GR,         -.33, .66+.33 * GR);\r\n    \r\n    vec3 p12 = vec3(  .66+.33*GR,     .66 * GR,         -.33);\r\n\r\n    vec3 p13 = vec3(        -.33,           GR,           0.);\r\n    vec3 p14 = vec3(         .66, .33+.66 * GR,    -.33 * GR);\r\n\r\n    vec3 p15 = vec3(          GR,           0.,         -.33);\r\n    vec3 p16 = vec3(  .33+.66*GR,    -.33 * GR,          .66);\r\n\r\n    vec3 p17 = vec3(          .0,         -.33,           GR);\r\n    vec3 p18 = vec3(   -.33 * GR,          .66, .33+.66 * GR);\r\n    \r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p2, p10, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p4, p11, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p6, p12, br));\r\n    \r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p7, p13, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p7, p14, br));\r\n    \r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p8, p15, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p8, p16, br));\r\n\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p9, p17, br));\r\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, p9, p18, br));\r\n    \r\n    return mergeobjs(ballsobj, bondsobj);\r\n}\r\n\r\nvec2 chamberobj(vec3 p)\r\n{\r\n    return vec2(20. - length(p), CHAMBER_MATL);\r\n}\r\n\r\n\r\nvec2 scenedf( vec3 p )\r\n{\r\n    //vec3 mp = p;\r\n    //float bbi = 0.;\r\n    \r\n    vec3 mp = p + 3.;   \r\n    float bbi = dot(vec3(1.), floor(mp / 6.));\r\n    float mr = .4 * (.7 + .5 * sin(2. * g_time - 1. * p.y + 6281. * bbi));\r\n    \r\n    mp = mod(mp, vec3(6.)) - vec3(3.);\r\n    \r\n    vec2 obj = buckeyballsobj( mp, mr );\r\n    \r\n    obj = mergeobjs(chamberobj(p), obj);\r\n\r\n    return obj;\r\n}\r\n\r\n#define DISTMARCH_STEPS 60\r\n#define DISTMARCH_MAXDIST 50.\r\n\r\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\r\n{\r\n\r\n    float epsilon = 0.001;\r\n    float dist = 10. * epsilon;\r\n    float t = 0.;\r\n    float material = 0.;\r\n    for (int i=0; i < DISTMARCH_STEPS; i++) \r\n    {\r\n        if ( abs(dist) < epsilon || t > maxd ) break;\r\n        // advance the distance of the last lookup\r\n        t += dist;\r\n        vec2 dfresult = scenedf( ro + t * rd );\r\n        dist = dfresult.x;\r\n        material = dfresult.y;\r\n    }\r\n\r\n    if( t > maxd ) material = -1.0; \r\n    return vec2( t, material );\r\n}\r\n\r\n// **************************************************************************\r\n// SHADOWING & NORMALS\r\n\r\n#define SOFTSHADOW_STEPS 40\r\n#define SOFTSHADOW_STEPSIZE .1\r\n\r\nfloat calcSoftShadow( vec3 ro, \r\n  vec3 rd, \r\n  float mint, \r\n  float maxt, \r\n  float k )\r\n{\r\n    float shadow = 1.0;\r\n    float t = mint;\r\n\r\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\r\n    {\r\n        if( t < maxt )\r\n        {\r\n            float h = scenedf( ro + rd * t ).x;\r\n            shadow = min( shadow, k * h / t );\r\n            t += SOFTSHADOW_STEPSIZE;\r\n        }\r\n    }\r\n    return clamp( shadow, 0.0, 1.0 );\r\n\r\n}\r\n\r\n#define AO_NUMSAMPLES 6\r\n#define AO_STEPSIZE .1\r\n#define AO_STEPSCALE .4\r\n\r\nfloat calcAO( vec3 p, vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float aoscale = 1.0;\r\n\r\n    for( int aoi=0; aoi< AO_NUMSAMPLES ; aoi++ )\r\n    {\r\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\r\n        vec3 aop =  n * step + p;\r\n        \r\n        float d = scenedf( aop ).x;\r\n        ao += -(d-step)*aoscale;\r\n        aoscale *= AO_STEPSCALE;\r\n    }\r\n    \r\n    return clamp( ao, 0.0, 1.0 );\r\n}\r\n\r\n// **************************************************************************\r\n// CAMERA & GLOBALS\r\n\r\nvoid animateGlobals()\r\n{\r\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\r\n    vec2 click = iMouse.xy / iResolution.xx;    \r\n    click = 2.0 * click - 1.0;  \r\n    \r\n    g_time = .8 * iTime - 10.;\r\n\r\n    // camera position\r\n    g_camOrigin = vec3(4.5, 0.0, 4.5);\r\n    \r\n    float rotx    = -1. * PI * (.5 * click.y + .45) + .05 * g_time;\r\n    float cosrotx = cos(rotx);\r\n    float sinrotx = sin(rotx);\r\n    \r\n    float roty    = TWO_PI * click.x + .05 * g_time;\r\n    float cosroty = cos(roty);\r\n    float sinroty = sin(roty);\r\n\r\n    // Rotate the camera around the origin\r\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\r\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\r\n\r\n    g_camPointAt   = vec3(0., 0., 0.);\r\n    \r\n    float lroty    = .9 * g_time;\r\n    float coslroty = cos(lroty);\r\n    float sinlroty = sin(lroty);\r\n\r\n    // Rotate the light around the origin\r\n    g_ldir = rotateAroundYAxis(g_ldir, coslroty, sinlroty);\r\n\r\n}\r\n\r\nstruct CameraData\r\n{\r\n    vec3 origin;\r\n    vec3 dir;\r\n    vec2 st;\r\n};\r\n\r\nCameraData setupCamera( in vec2 fragCoord )\r\n{\r\n\r\n    // aspect ratio\r\n    float invar = iResolution.y / iResolution.x;\r\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\r\n    st.y *= invar;\r\n\r\n    // calculate the ray origin and ray direction that represents\r\n    // mapping the image plane towards the scene\r\n    vec3 iu = vec3(0., 1., 0.);\r\n\r\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\r\n    vec3 ix = normalize( cross(iz, iu) );\r\n    vec3 iy = cross(ix, iz);\r\n\r\n    vec3 dir = normalize( st.x*ix + st.y*iy + .7 * iz );\r\n\r\n    return CameraData(g_camOrigin, dir, st);\r\n\r\n}\r\n\r\n// **************************************************************************\r\n// SHADING\r\n\r\nstruct SurfaceData\r\n{\r\n    vec3 point;\r\n    vec3 normal;\r\n    vec3 basecolor;\r\n    float roughness;\r\n    float metallic;\r\n};\r\n\r\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), 0., 0.)\r\n\r\nvec3 calcNormal( vec3 p )\r\n{\r\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 n = vec3(\r\n        scenedf(p + epsilon.xyy).x - scenedf(p - epsilon.xyy).x,\r\n        scenedf(p + epsilon.yxy).x - scenedf(p - epsilon.yxy).x,\r\n        scenedf(p + epsilon.yyx).x - scenedf(p - epsilon.yyx).x );\r\n    return normalize( n );\r\n}\r\n\r\nvoid material(float surfid,\r\n  inout SurfaceData surf)\r\n{\r\n    vec3 surfcol = vec3(1.);\r\n    if (surfid - .5 < SPHERE_MATL) \r\n    { \r\n        surf.basecolor = vec3(.8, .2, .5); \r\n        surf.roughness = .5;\r\n        surf.metallic = .8;\r\n    } \r\n    else if (surfid - .5 < CHAMBER_MATL)\r\n    {\r\n        surf.basecolor = vec3(0.);\r\n        surf.roughness = 1.;\r\n    }\r\n    else if (surfid - .5 < BOND_MATL)\r\n    {\r\n        surf.basecolor = vec3(.02,.02,.05);\r\n        surf.roughness = .2;\r\n        surf.metallic = .0;\r\n    }\r\n\r\n}\r\n\r\nvec3 integrateDirLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\r\n{\r\n    vec3 vdir = normalize( g_camOrigin - surf.point );\r\n\r\n    // The half vector of a microfacet model \r\n    vec3 hdir = normalize(ldir + vdir);\r\n    \r\n    // cos(theta_h) - theta_h is angle between half vector and normal\r\n    float costh = max(-SMALL_FLOAT, dot(surf.normal, hdir)); \r\n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\r\n    float costd = max(-SMALL_FLOAT, dot(ldir, hdir));      \r\n    // cos(theta_l) - theta_l is angle between the light vector and normal\r\n    float costl = max(-SMALL_FLOAT, dot(surf.normal, ldir));\r\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\r\n    float costv = max(-SMALL_FLOAT, dot(surf.normal, vdir));\r\n\r\n    float ndl = clamp( costl, 0., 1.);\r\n\r\n    vec3 cout = vec3(0.);\r\n\r\n    if (ndl > 0.)\r\n    {\r\n        float frk = .5 + 2.* costd*costd * surf.roughness;\r\n        vec3 diff = surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1.-costl)) * (1. + (frk - 1.) * pow5(1.-costv));\r\n        //vec3 diff = surf.basecolor * ONE_OVER_PI; // lambert\r\n\r\n        // D(h) factor\r\n        // using the GGX approximation where the gamma factor is 2.\r\n\r\n        // Clamping roughness so that a directional light has a specular\r\n        // response.  A roughness of perfectly 0 will create light \r\n        // singularities.\r\n        float r = max(0.05, surf.roughness);\r\n        float alpha = r * r;\r\n        float denom = costh*costh * (alpha*alpha - 1.) + 1.;\r\n        float D = (alpha*alpha)/(PI * denom*denom); \r\n\r\n        // using the GTR approximation where the gamma factor is generalized\r\n        // float alpha = surf.roughness * surf.roughness;\r\n        // float gamma = 2.;\r\n        // float sinth = length(cross(surf.normal, hdir));\r\n        // float D = 1./pow(alpha*alpha*costh*costh + sinth*sinth, gamma);\r\n\r\n        // G(h,l,v) factor\r\n        float k = ((r + 1.) * (r + 1.))/8.;    \r\n        float Gl = costv/(costv * (1. - k) + k);\r\n        float Gv = costl/(costl * (1. - k) + k);\r\n        float G = Gl * Gv;\r\n\r\n        // F(h,l) factor\r\n        vec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\r\n        vec3 F = F0 + (1. - F0) * pow5(1. - costd);\r\n\r\n        vec3 spec = D * F * G / (4. * costl * costv);\r\n        \r\n        float shd = calcSoftShadow( surf.point, ldir, 0.1, 20., 5.);\r\n        \r\n        cout  += diff * ndl * shd * lcolor;\r\n        cout  += spec * ndl * shd * lcolor;\r\n    }\r\n\r\n    return cout;\r\n}\r\n\r\nvec3 sampleEnvLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\r\n{\r\n\r\n    vec3 vdir = normalize( g_camOrigin - surf.point );\r\n\r\n    // The half vector of a microfacet model \r\n    vec3 hdir = normalize(ldir + vdir);\r\n    \r\n    // cos(theta_h) - theta_h is angle between half vector and normal\r\n    float costh = dot(surf.normal, hdir); \r\n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\r\n    float costd = dot(ldir, hdir);      \r\n    // cos(theta_l) - theta_l is angle between the light vector and normal\r\n    float costl = dot( surf.normal, ldir );\r\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\r\n    float costv = dot( surf.normal, vdir );\r\n\r\n    float ndl = clamp( costl, 0., 1.);\r\n    vec3 cout = vec3(0.);\r\n    if (ndl > 0.) \r\n    {\r\n\r\n        float r = surf.roughness;\r\n        // G(h,l,v) factor\r\n        float k = r*r/2.;    \r\n        float Gl = costv/(costv * (1. - k) + k);\r\n        float Gv = costl/(costl * (1. - k) + k);\r\n        float G = Gl * Gv;\r\n\r\n        // F(h,l) factor\r\n        vec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\r\n        vec3 F = F0 + (1. - F0) * pow5(1. - costd);\r\n\r\n        // Combines the BRDF as well as the pdf of this particular\r\n        // sample direction.\r\n        vec3 spec = lcolor * G * F * costd / (costh * costv);\r\n        \r\n        float shd = calcSoftShadow( surf.point, ldir, 0.02, 20., 7.);\r\n\r\n        cout = spec * shd * lcolor;\r\n    }\r\n\r\n    return cout;\r\n}\r\n\r\nvec3 integrateEnvLight(SurfaceData surf)\r\n{\r\n    vec3 vdir = normalize( surf.point - g_camOrigin );    \r\n    vec3 envdir = reflect(vdir, surf.normal);\r\n    vec4 specolor = vec4(.4) * mix(texture(iChannel0, envdir),\r\n       texture(iChannel1, envdir),\r\n       surf.roughness);\r\n    \r\n    vec3 envspec = sampleEnvLight(envdir, specolor.rgb, surf);\r\n    return envspec;\r\n}\r\n\r\nvec3 shadeSurface(SurfaceData surf)\r\n{    \r\n\r\n    vec3 amb = surf.basecolor * .04;\r\n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\r\n    // and 0 is not occluded at all.  Makes math easier when mixing \r\n    // shadowing effects.\r\n    float ao = calcAO(surf.point, surf.normal);\r\n\r\n    vec3 centerldir = normalize(-surf.point);\r\n\r\n    vec3 cout = vec3(0.);\r\n    if (dot(surf.basecolor, vec3(1.)) > SMALL_FLOAT)\r\n    {\r\n        cout  += integrateDirLight(g_ldir,  vec3(.3), surf);\r\n        cout  += integrateDirLight(centerldir, vec3(0.3, .5, 1.0), surf);\r\n        cout  += integrateEnvLight(surf) * (1. - 3.5 * ao);\r\n        cout  += amb * (1. - 5.5 * ao);\r\n    }\r\n    return cout;\r\n\r\n}\r\n\r\n// **************************************************************************\r\n// MAIN\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{   \r\n\r\n    // ----------------------------------------------------------------------\r\n    // Animate globals\r\n\r\n    animateGlobals();\r\n\r\n    // ----------------------------------------------------------------------\r\n    // Setup Camera\r\n\r\n    CameraData cam = setupCamera( fragCoord );\r\n\r\n    // ----------------------------------------------------------------------\r\n    // SCENE MARCHING\r\n\r\n    vec2 scenemarch = distmarch( cam.origin, \r\n       cam.dir, \r\n       DISTMARCH_MAXDIST );\r\n    \r\n    // ----------------------------------------------------------------------\r\n    // SHADING\r\n\r\n    vec3 scenecol = vec3(0.);\r\n    if (scenemarch.y > SMALL_FLOAT)\r\n    {\r\n        vec3 mp = cam.origin + scenemarch.x * cam.dir;\r\n        vec3 mn = calcNormal( mp );\r\n\r\n        SurfaceData currSurf = INITSURF(mp, mn);\r\n\r\n        material(scenemarch.y, currSurf);\r\n        scenecol = shadeSurface( currSurf );\r\n    }\r\n\r\n    // ----------------------------------------------------------------------\r\n    // POST PROCESSING\r\n    \r\n    // fall off exponentially into the distance (as if there is a spot light\r\n    // on the point of interest).\r\n    scenecol *= exp( -0.01 *(scenemarch.x*scenemarch.x - 300.));\r\n    \r\n    // brighten\r\n\tscenecol *= 1.3;\r\n    \r\n    // distance fog\r\n    scenecol = mix(scenecol, .02 * vec3(1., .2, .8), smoothstep(10., 30., scenemarch.x));\r\n    \r\n    // Gamma correct\r\n    scenecol = pow(scenecol, vec3(0.45));\r\n\r\n    // Contrast adjust - cute trick learned from iq\r\n    scenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), -0.6 );\r\n\r\n    // color tint\r\n    scenecol = .5 * scenecol + .5 * scenecol * vec3(1., 1., .9);\r\n    \r\n    fragColor.rgb = scenecol;\r\n    fragColor.a = 1.;\r\n}\r\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslSRf","date":"1424051870","viewed":6232,"name":"Bubble Buckey Balls","username":"mplanck","description":"Smells like bubble gum.  In need of some optimization...","likes":142,"published":1,"flags":0,"usePreview":0,"tags":["distancemarching","buckey","plausibleshading"],"hasliked":0,"parentid":"","parentname":""}}