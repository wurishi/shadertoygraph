{"ver":"0.1","info":{"id":"ddfXDH","date":"1668810347","viewed":110,"name":"Red Yellow Blue Color Wheel","username":"jbehreandt","description":"Displays a red, yellow and blue color wheel. This color wheel does not follow a perceptually accurate color model; if interested in that, please see OKHSL developed by Bjorn Ottoson https://bottosson.github.io/misc/colorpicker/ .","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["colorwheel","ryb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 RETICLE_COLOR = vec4(1.0, 1.0, 1.0, 1.0);\nconst float RETICLE_SMOOTHING = 15.0;\nconst float RETICLE_SIZE = 1.0 / 12.0;\nconst float RETICLE_INNER = RETICLE_SIZE * 0.825;\nconst float HARMONY_SIZE = RETICLE_SIZE * 0.6;\nconst float HARMONY_INNER = HARMONY_SIZE * 0.825;\nconst int SECTORS = 12;\nconst float TAU = 6.2831855;\n\nvec4 drawCircle(in vec2 orig, in vec2 dest,\n    in float sizeMajor, in float sizeMinor,\n    in vec4 sampledColor, in vec4 reticleColor,\n    in vec2 uvBkg) {\n    \n    vec2 diff = dest - orig;\n    float distSq = dot(diff, diff);\n    float dist = sqrt(distSq);\n    if(dist <= sizeMajor) {\n        if(dist <= sizeMinor) {\n            // return sampledColor;\n            return vec4(0.0);\n        } else {\n            return reticleColor;\n        }\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 uvUnsigned = fragCoord / iResolution.xy;\n    vec2 uvSigned = uvUnsigned * 2.0 - 1.0;\n    uvSigned.x *= aspectRatio;\n    \n    vec2 mUnsigned = iMouse.xy / iResolution.xy;\n    vec2 mSigned = mUnsigned * 2.0 - 1.0;\n    mSigned.x *= aspectRatio;\n    \n    vec2 reticle = vec2(0.0, 0.0);\n    vec2 complement = vec2(0.0, 0.0);\n    \n    vec4 clrSample = texture(iChannel0, mUnsigned);\n    vec4 clrSigned = clrSample * 2.0 - 1.0;\n    vec2 clr2d = clrSigned.xy;\n    \n    float fac = smoothstep(0.0, 1.0, 1.0);\n    reticle = mix(reticle, mSigned, fac);\n    \n    if(length(mSigned) >= 1.0) {        \n        reticle = normalize(reticle);\n        // TODO: Maintain border color.\n        //clrSample = texture(iChannel0, retSample);\n    }\n    \n    complement = -reticle;\n    \n    fragColor = texture(iChannel0, uvUnsigned);\n    fragColor += drawCircle(complement, uvSigned, HARMONY_SIZE, HARMONY_INNER, clrSample, RETICLE_COLOR, uvUnsigned);\n    fragColor += drawCircle(reticle, uvSigned, RETICLE_SIZE, RETICLE_INNER, clrSample, RETICLE_COLOR, uvUnsigned);\n    \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec4 RYB[25] = vec4[25] (\n    vec4(0.7372549, 0.0, 0.0, 1.0),\n    vec4(0.78823537, 0.12941177, 0.0, 1.0),\n    vec4(0.85098046, 0.2509804, 0.0, 1.0),\n    vec4(0.8862746, 0.40000004, 0.0, 1.0),\n    vec4(0.9058824, 0.5411765, 0.0, 1.0),\n    vec4(0.9294118, 0.65882355, 0.0, 1.0),\n    vec4(0.95294124, 0.7686275, 0.019607844, 1.0),\n    vec4(0.9960785, 0.9058824, 0.1254902, 1.0),\n    vec4(0.9960785, 0.9960785, 0.20000002, 1.0),\n    vec4(0.86666673, 0.94117653, 0.20392159, 1.0),\n    vec4(0.69803923, 0.8431373, 0.19607845, 1.0),\n    vec4(0.5529412, 0.7725491, 0.15686275, 1.0),\n    vec4(0.41176474, 0.7019608, 0.20784315, 1.0),\n    vec4(0.15686275, 0.63529414, 0.49803925, 1.0),\n    vec4(0.0, 0.50980395, 0.6509804, 1.0),\n    vec4(0.003921569, 0.3921569, 0.8078432, 1.0),\n    vec4(0.0, 0.25490198, 0.9490197, 1.0),\n    vec4(0.10588236, 0.14117648, 0.9058824, 1.0),\n    vec4(0.15686275, 0.08235294, 0.77647066, 1.0),\n    vec4(0.23137257, 0.015686275, 0.5921569, 1.0),\n    vec4(0.29411766, 0.0, 0.4156863, 1.0),\n    vec4(0.4039216, 0.011764707, 0.31764707, 1.0),\n    vec4(0.5411765, 0.0, 0.23529413, 1.0),\n    vec4(0.654902, 0.0, 0.12941177, 1.0),\n    vec4(0.7372549, 0.0, 0.0, 1.0)\n);\n\nconst vec4 BACKGROUND = vec4(0.2, 0.2, 0.2, 1.0);\nconst vec4 MIDDLE_GRAY = vec4(0.375, 0.375, 0.375, 1.0);\n\nconst float EPSILON = 0.0;\nconst float HALF_PI = 1.5707964;\nconst float TAU = 6.2831855;\nconst float DEG_30 = 0.5235988;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Assumes that screen is always wider than it is tall.\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uvUnsigned = fragCoord / iResolution.xy;\n    vec2 uvSigned = uvUnsigned * 2.0 - 1.0;\n    uvSigned.x *= aspectRatio;\n\n    float magSq = dot(uvSigned, uvSigned);\n    if(magSq <= 1.0) {\n        if (magSq > EPSILON) {\n            float mag = sqrt(magSq);\n            float theta= DEG_30 + atan(uvSigned.y, uvSigned.x);\n            float thetaNorm = theta / TAU;\n            // in GLSL, fract := n - floor(n)\n            float theta01 = fract(thetaNorm);\n            vec4 saturated = vec4(MIDDLE_GRAY);\n            if(theta01 >= 1.0) {\n                saturated = RYB[24];\n            } else {\n                float thetaScaled = theta01 * 24.0;\n                int index = int(thetaScaled);\n                float stepLocal = fract(thetaScaled);\n                vec4 orig = RYB[index];\n                vec4 dest = RYB[index + 1];\n                saturated = mix(orig, dest, stepLocal);\n            }\n            // float grayStep = clamp(mag, 0.0, 1.0);\n            float grayStep = smoothstep(0.0, 1.0, mag);\n            fragColor = mix(MIDDLE_GRAY, saturated, grayStep);\n        } else {\n        fragColor = MIDDLE_GRAY;\n        }\n    } else {\n        fragColor = BACKGROUND;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}