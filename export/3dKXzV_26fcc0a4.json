{"ver":"0.1","info":{"id":"3dKXzV","date":"1574457002","viewed":203,"name":"Fractals by Bending 2D Space","username":"edubart","description":"Some fractals generated by bending space, made to learn 2D space bending.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","bending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Space is bended so the fractals can be drawn with a single length() command\n// x-axis is green\n// y-axis is red\n// space origin is blue\n// fractal is white\n//\n// The Koch fractal is just a line being drawn in a bended space.\n// The Sierpinski carpet fractal is just a square being drawn in a bended space.\n// The Sierpinski carpet fractal is just a triangle being drawn in a bended space.\n    \n#define PI 3.141592653589793238\n\nvec2 sincos(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvec2 mirror(vec2 uv, vec2 p, float angle) {    \n    vec2 n = sincos(angle);\n    return uv - n*min(dot(uv - p, n), 0.0)*2.0;\n}\n\nvec2 rotate2d(vec2 uv, float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n}\n\nfloat sd_equilateral_triangle(vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x+k*p.y>0.0) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat fractal_koch(inout vec2 uv, int steps) {\n    float scale = 1.0;\n    uv.y -= sqrt(3.0)/6.0;\n    uv.x = abs(uv.x);\n    uv = mirror(uv, vec2(0.5, 0), 11.0/6.0*PI);\n    uv.x += 0.5;\n    for(int i=0;i<steps; ++i) {\n        uv.x -= 0.5;\n        uv *= 3.0;\n        scale *= 3.0;\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv = mirror(uv, vec2(0,0), (2.0/3.0)*PI);\n    }\n    uv.x = abs(uv.x);\n    float d = length(uv - vec2(min(uv.x,1.0),0.0)) / scale;\n    uv /= scale;\n    return d;\n}\n\nfloat fractal_sierpinski_carpet(inout vec2 uv, int steps) {\n    float scale = 4.0;\n    uv *= 4.0;\n    uv = abs(uv);\n\n    for(int i=0;i<steps;++i) {\n        uv *= 3.0;\n        scale *= 3.0;\n        uv = abs(uv);\n        uv *= 1.0 - step(uv.x, 3.0)*step(uv.y, 3.0);\n        uv -= vec2(0, 3); uv = abs(uv);\n        uv -= vec2(0, 3); uv = abs(uv);\n        uv -= vec2(3, 0); uv = abs(uv);\n        uv -= vec2(3, 0); uv = abs(uv);\n    }\n\n    float d = length(uv - vec2(min(uv,vec2(1)))) / scale;\n    uv /= scale;\n    return d;\n}\n\nfloat fractal_sierpinski_triangle(inout vec2 uv, int steps) {\n    float scale = 1.5;\n    uv *= 1.5;\n    for(int i=0;i<steps;++i) {\n        uv *= 2.0;\n        scale *= 2.0;\n        uv.y -= 2.0*sqrt(3.0)/3.0;\n        uv.x = abs(uv.x);\n        uv = mirror(uv, vec2(1.0,-sqrt(3.0)/3.0), (11.0/6.0)*PI);\n    }\n\n    float d = sd_equilateral_triangle(uv) / scale;\n    uv /= scale;\n    return d;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col;\n\n    vec2 uv = 2.0*(coord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.xy;\n    uv = rotate2d(uv, atan(mouse.y, mouse.x) + 3.0*PI/4.0);\n\n    float d;\n\n    int mode = int(mod(iTime / 6.0, 3.0));\n    int iterations = 5 - int(mod(iTime, 6.0));\n    switch(mode) {\n        case 0:\n            d = fractal_koch(uv, iterations);\n            break;\n        case 1:\n            d = fractal_sierpinski_carpet(uv, iterations);\n            break;\n        case 2:\n            d = fractal_sierpinski_triangle(uv, iterations);\n            break;\n    }\n\n    float linewidth = 4.0/iResolution.y;\n    col += smoothstep(linewidth, 0.0, d) * 0.5;\n    col.rg += smoothstep(-0.5, 0.5, sin(iTime*10.0+uv*100.0)) * 0.1;\n    col.r += smoothstep(linewidth, 0.0, length(uv.x))*0.5;\n    col.g += smoothstep(linewidth, 0.0, length(uv.y))*0.5;\n    col.b += smoothstep(linewidth, 0.0, pow(length(uv), 1.4));\n\n    color = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}