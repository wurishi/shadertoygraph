{"ver":"0.1","info":{"id":"fs2fDw","date":"1646428834","viewed":228,"name":"Equilateral pentagonal tiling","username":"Observer","description":"Tessellating with equally sided, symmetric pentagons. Could this a new type of equilateral cairo pentagonal tiling?\nSearched the web, couldn't find this specific one...","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["tiling","tesselation","pentagon","cairo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*      C          a = ¼(√13 - 1)    ≈ 0.65139 (found empirically)\n       ,^.         b = √(1 - a·a)    ≈ 0.75874\n     ,' | `.       c = √(1 - (a-½)²) ≈ 0.98847\n   ,'   b   `. \nB,'__a__:__a__`.B  A                 ≈  98.707° ≈ 0.548π\n \\      |      /   B = 180° - ½A     ≈ 130.646° ≈ 0.726π \n  \\     c     /    C = 180° - A      ≈  81.293° ≈ 0.452π\n   \\    |    /\n    \\___|___/      all sides are 1\n    A       A\n*/\n\n// Lengths\nconst float a = 0.25 * (sqrt(13.) - 1.0);\nconst float b = sqrt(1.0 - a*a);\nconst float c = sqrt(1.0 - (a-0.5)*(a-0.5));\n\n// Angles (not used)\nconst float A = PI * 0.5 + asin(a - 0.5);\nconst float B = PI - A * 0.5;\nconst float C = 3.0 * PI - A * 2.0 - B * 2.0;\n\nfloat sc = 1.0;\n\n// Print routines for debugging\n// (sorry can't find original source anymore...)\nfloat printChar(in vec2 uv, in int char) {\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    return all(lessThan(abs(uv - 0.5), vec2(0.5)))\n        ? textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r\n        : 0.;\n}\n\nfloat printInt(in vec2 uv, in float n) {\n    float v = 0.;\n    if (n < 0.) {\n        v = printChar(uv - vec2(-.5,0), 45 );\n        n = -n;\n    }\n    for (float i = 3.; i>=0.; i--) {\n        n /=  9.999999;\n        v = max(v, printChar(uv - .5*vec2(i,0), 48+ int(fract(n)*10.) ));\n    }\n    return v;\n}\n\nfloat printFloat(vec2 uv, float n) {\n    float v = 0.;\n    if (n < 0.) {\n        v = printChar(uv - vec2(-.5,0), 45 );\n        n = -n;\n    }\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v = max(v, printInt(uv, upper));\n    uv.x -= 2.;\n    v = max(v, printChar(uv, 46));\n    uv.x -= .5;\n    v = max(v, printInt(uv, lower));\n    return v;\n}\n\nfloat printVec2(vec2 uv, vec2 n) {\n    float v = printFloat(uv, n.x);\n    v = max(v, printChar(uv - vec2(4.5,0), 44));\n    v = max(v, printFloat(uv - vec2(5.3,0), n.y));\n    return v;\n}\n\n// End of print routines\n\n\nvec2 sdMin2(in vec2 a, in vec2 b)\n{\n    return a.y < b.y ? a : b;\n}\n\nvec3 sdMin3(in vec3 a, in vec3 b)\n{\n    return a.y < b.y ? a : b;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return smoothstep(0.0, 1.0, 0.9 - d * 0.8 * iResolution.y / sc);\n}\n\n\n// x: perp position on the line [0..1]\n// y: signed distance to the line (always positive, the negative side is 'outside')\n// -> y has a high value when outside line\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    vec2 rba = vec2(ba.y, -ba.x);\n    float h = dot(pa, ba) / dot(ba, ba);\n    if (abs(h - 0.5) > 0.5) return vec2(0., 1E12);\n    \n    vec2 s = pa - h*ba;\n    if (dot(s, rba) > 0.) return vec2(0., 1E12);\n    \n    return vec2(h, length(s));\n}\n\n// Outline drawing\nfloat drawPentagon(in vec2 uv, in float angle, in vec2 offset)\n{\n    float cs = cos(angle), sn = sin(angle);\n    uv -= offset;\n    uv = vec2(uv.x * cs + uv.y * sn, -uv.x * sn + uv.y * cs);\n\n    float v = line(uv, vec2(-0.5, -c), vec2(0.5, -c));\n    v = max(v, line(uv, vec2(0.5, -c), vec2(a, 0.)));\n    v = max(v, line(uv, vec2(a, 0.0), vec2(0.0, b)));\n    v = max(v, line(uv, vec2(0.0, b), vec2(-a, 0.0)));\n    v = max(v, line(uv, vec2(-a, 0.0), vec2(-0.5, -c)));\n    return v;\n}\n\nfloat drawPentagonPatch(in vec2 uva, in vec2 uvc, in vec2 offset)\n{\n    uvc -= offset;\n    float v = 0.0;\n    \n    v = max(v, drawPentagon(uvc, A + B + PI, vec2(0.5*a - 0.25,  -1.5*c )));\n    v = max(v, drawPentagon(uvc, A + B, vec2(0.5*a-0.25, -2.*b - 1.5*c)));\n    v = max(v, drawPentagon(uvc, PI, vec2(a + 0.5, -c)));\n    v = max(v, drawPentagon(uvc, 0.0, vec2(a + 0.5, -c-2.*b)));\n    v = max(v, drawPentagon(uvc, 0.0, vec2(0)));\n    v = max(v, drawPentagon(uvc, PI, vec2(a-0.5, -2.*b - 3.*c)));\n    \n    return v;\n}\n\n// Filling\nvec3 fillPentagon(in vec2 uv, in float angle, in vec2 offset, in float mat)\n{\n    float cs = cos(angle), sn = sin(angle);\n    uv -= offset;\n    uv = vec2(uv.x * cs + uv.y * sn, -uv.x * sn + uv.y * cs);\n\n    vec2 v = vec2(1E12);\n    \n    v = sdMin2(v, sdLine(uv, vec2(-0.5, -c), vec2(0.5, -c)));\n    v = sdMin2(v, sdLine(uv, vec2(0.5, -c), vec2(a, 0.)));\n    v = sdMin2(v, sdLine(uv, vec2(a, 0.0), vec2(0.0, b)));\n    v = sdMin2(v, sdLine(uv, vec2(0.0, b), vec2(-a, 0.0)));\n    v = sdMin2(v, sdLine(uv, vec2(-a, 0.0), vec2(-0.5, -c)));\n\n    return vec3(v, mat);    \n}\n\n// x: pos along the edge [0..1]\n// y: inner distance from closest edge\n// z: material [1, 2, 3 or 4]\nvec3 fillPentagonPatch(in vec2 uva, in vec2 uvc, in vec2 offset)\n{\n    uvc -= offset;\n    vec3 v = vec3(1E12);\n    v = sdMin3(v, fillPentagon(uvc, A + B + PI, vec2(0.5*a - 0.25,  -1.5*c ),    4.0));\n    v = sdMin3(v, fillPentagon(uvc, A + B,      vec2(0.5*a-0.25, -2.*b - 1.5*c), 2.0));\n    v = sdMin3(v, fillPentagon(uvc, PI,         vec2(a + 0.5, -c),               3.0));\n    v = sdMin3(v, fillPentagon(uvc, 0.0,        vec2(a + 0.5, -c-2.*b),          1.0));\n    v = sdMin3(v, fillPentagon(uvc, 0.0,        vec2(0),                         1.0));\n    v = sdMin3(v, fillPentagon(uvc, PI,         vec2(a-0.5, -2.*b - 3.*c),       3.0));\n    // flip material\n    if (uva.y > 0.5)\n    {\n        v.z = mod(v.z + 1., 4.) + 1.;\n    }\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rgb;\n\n    sc = length(iMouse.xy - iResolution.xy * 0.5) * 0.02 + 2.2;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * sc;\n\n    // Setup vectors for domain repetition (parm shaped)\n    vec2 v1 = vec2(1.0, 2. * (b + c));\n    vec2 v2 = vec2(-a - 0.5, 2. * b  + c);\n\n    float aa = a-0.5;\n    vec2 off = vec2(-aa, 3. * (b + c));\n\n    vec2 p = uv - off;\n    vec2 v1a = vec2(v1.y, -v1.x);\n    vec2 v2a = vec2(v2.y, -v2.x);\n    \n    // [0..1, 0..1]\n    vec2 uva = vec2(\n        fract(1. + dot(p, v2a) * aa),\n        1.0 - fract(dot(p, v1a) * aa)\n    );\n    \n    // [0..1, 0..5]: x/y mirrored when y>0.5\n\t// because of symmetry\n    vec2 uvb = vec2(\n       uva.y > 0.5 ? 1.0 - uva.x : uva.x,\n       uva.y > 0.5 ? 1.0 - uva.y : uva.y\n    );\n    vec2 uvc = uvb.x * v1 + uvb.y * v2 - off;\n    \n    // Draw polygon outlines\n    float c1 = drawPentagonPatch(uva, uvc, vec2(0.));\n\n    // Fill the polygons\n    vec3 c2 = fillPentagonPatch(uva, uvc, vec2(0.));\n    float ang = c2.z * PI / 4.0;\n    float stp = 0.5 * PI;\n    vec3 fillCol = vec3(sin(ang), sin(ang+stp), sin(ang+stp*2.0))*0.3 + 0.3;\n    \n    // Some interesting effects with c2.xy...\n    fillCol += sin(c2.x * 16.0 * PI - iTime * 3.0) * min(1.0, max(0.0, (length(uv) - 2.0)) * 0.05) + 0.2;\n    \n    rgb = c1 * vec3(1.0, 1.0, 0.0) + fillCol;\n    \n    //uv = fragCoord.xy / iResolution.y;\n    //rgb += printFloat(uv * 14.0, C / PI);\n\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(0.) * 2.;\n","name":"Common","description":"","type":"common"}]}