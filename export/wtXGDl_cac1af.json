{"ver":"0.1","info":{"id":"wtXGDl","date":"1558009879","viewed":667,"name":"Speed lines / lights","username":"Neebz","description":"This is my first ever shader. I had a hard time understanding everything, but used the videos from \"The Art of Code\" to great help. His line generation code is what I am using, so all credit to him for that method, as well as the noise generation.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["lines","space","lights","firstshader","speed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a,b,t) smoothstep(a,b,t)\n#define minOffset .01\n#define maxOffset .45\n#define simulationSpeed .5\n#define elementsToDisplay 100.\n#define maxDistFromCam 10.\n#define minDistFromCam 0.01\n#define glowAlpha .5\n\n//My first ever real shader!\n\n//Performance is not the best when the resolution (number of lines)\n//is increased too much, and I cannot find any way to improve it. If\n//anyone has some tips and/or tricks, I would be very greatful.\n\n//Any critique is welcome as I am a big noob in this field :)\n\nvec4 glowColor = vec4(0.);\n\n//Noise, 2 in 1 out\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n//Noise, 2 in 2 out\nvec2 N22(vec2 p){\n    float n = N21(p);\n\treturn vec2(n, (N21(p + n)));\n}\n\n//Creates a line between a and b, from texture coord at p\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    //Vector from texture coord to line start\n    vec2 pa = a - p;\t\t\t\n    //Vector from texture coord to line end\n    vec2 ba = a - b;\t\t\t\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * t);\n}\n\n//p - currentPoint, a - startPoint, b - endPoint\nvec3 LineVec(vec2 p, vec2 a, vec2 b){\n    //Create a line from a to b, using uv coords at p\n\tfloat d = DistLine(p, a, b);\t\t\t\t\n    //Distance to start point\n    float dFactor = length(p - a);\t\t\t    \n    //Multiplicative inverse distance to start point     \n    float pFactor = 1. / length(p - a);\t\t\t\n\t\n    //Calculate the size and deformation of the line\n    float mask \t\t= S(.03, 0.02, d * pFactor + dFactor * 0.01);\t\n    //Calculate the size and deformation of the glow\n\tfloat glow \t= S(.2, 0., d * pFactor + dFactor * .5);\t\t\t\n    \n\t//Return the result\n    return vec3(1) * mask + glow * vec3(glowColor.x * glowColor.a, glowColor.y * glowColor.a, glowColor.z * glowColor.a);\n}\n\nvec3 SpeedLine(vec2 uv, vec2 direction, float depth){\n\treturn LineVec(uv - direction * depth , vec2(0.0), direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; //Sets origin in the middle\n    uv.x *= iResolution.x/iResolution.y;  //\"Sqaures\" the uv input \n\n\t//Calculate the current frame's speed line glow color\n\tvec3 glowColorValue = 0.5 + 0.5*cos(iTime * 2. +uv.xyx+vec3(0,2,4));\n\tglowColor = vec4(glowColorValue, glowAlpha);\n\n    //Creates a time variable, adjusted for the sim speed\n    float t = (iTime * simulationSpeed)\t+ 1.;\t\t\n    //Creates an empty mask to contain the effect\n    vec3 vecMask = vec3(0);\t\t\t\t\t\t\t\n\n\t\n    //Loop to draw every line. \"Re-uses\" lines for simplicity\n    for(float u = 0.; u < 1.; u += 1./elementsToDisplay){\t\t\n        //Gets time decimals, between 0.0 and 1.0\n        float z = fract(t + u);\t\t\t\t\t\t\t\t\t\n        //Get time in seconds, only integers\n        float g = floor(t + u);\t\t\t\t\t\t\t\t\t\n        //Creates depth\n        float size = mix(maxDistFromCam, minDistFromCam, z);\t\n        //fades in the lines, accoring to the time they have existed / depth of the object\n        float fade = S(0., .5, z);\t\t\t\t\t\t\t\t\n\t\t\t\t\n        //Generate a random vector. Subtract .5 to make it between -.5 & .5\n\t\tvec2 randomPoint = (N22(vec2(g*u,-g*u)) - .5);\t\t\t\n        //Normalize the vector, to get an even size for all \n\t\tvec2 randomDirection = normalize(randomPoint);\t\t\t\n\t\t\n\t\t//Choose a spawn point for the lines, by using the direction they should spawn in\n\t\t//multiplied by a random factor, between two offset values\n\t\tvec2 spawnPosition = randomDirection * mix(minOffset, maxOffset, N21(vec2(u,u)));\n\n        //Calculates the uv offset (spawn distance from center)\n\t\tvec2 uvOffset = uv + spawnPosition;\t\t\n        //Calculates the direction the lines should fly\n        vec2 flyDirection = -spawnPosition;\t\t\n\n\t\t//Runs the function to create the lines, with the calculated values\n\t\tvec3 currentMask = SpeedLine(uvOffset * size, flyDirection, z) * fade;\n        //Applies the generated line to the line mask\n\t\tvecMask += currentMask;\t\t\n\t}\n    fragColor += vec4(vecMask, 1);\n}","name":"Image","description":"","type":"image"}]}