{"ver":"0.1","info":{"id":"cldcRS","date":"1699365530","viewed":43,"name":"2D Shape Blending Test","username":"fiser","description":"2d","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pixel-derivatives-based AA from: https://github.com/glslify/glsl-aastep\n// 2D SDF functions from: https://iquilezles.org/articles/distfunctions2d/\n// Easing functions from: https://easings.net/\n\n#define PI 3.141592\n\nfloat aaStep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdEquilateralTriangle(vec2 p, float r)\n{\n    float k = sqrt(3.0);\n\n    vec2 q = vec2(abs(p.x) - r, p.y + r / k);\n    if(q.x + k * q.y > 0.0) {\n        q = vec2(q.x - k * q.y, -k * q.x -q.y) / 2.0;\n    }\n    q.x -= clamp(q.x, -2.0 * r, 0.0);\n\n    return -length(q) * sign(q.y);\n}\n\nfloat sdHexagram(vec2 p, float r)\n{\n    vec4 k = vec4(-0.5,0.8660254038, 0.5773502692, 1.7320508076);\n\n    vec2 q = abs(p);\n    q -= 2.0 * min(dot(k.xy, q), 0.0) * k.xy;\n    q -= 2.0 * min(dot(k.yx, q), 0.0) * k.yx;\n    q -= vec2(clamp(q.x, r * k.z, r * k.w), r);\n\n    return length(q) * sign(q.y);\n}\n\nvec2 sdTranslate(vec2 p, vec2 o) {\n    return p - o;\n}\n\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    vec2 q = abs(p);\n\n    return length(q - min(q.x + q.y, w) * 0.5) - r;\n}\n\nfloat easeInOutElastic(float x){\n    float c5 = (2.0 * PI) / 4.5;\n\n    return x == 0.0\n        ? 0.0\n        : x == 1.0\n        ? 1.0\n        : x < 0.5\n        ? -(pow(2.0, 20.0 * x - 10.0) * sin((20.0 * x - 11.125) * c5)) / 2.0\n        : (pow(2.0, -20.0 * x + 10.0) * sin((20.0 * x - 11.125) * c5)) / 2.0 + 1.0;\n}\n\n#define ease easeInOutElastic\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Origin at the center of the screen; vertical resolution is 2.0.\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Primitive shapes.\n    float dBox = sdBox(p, vec2(1.25, 0.35));\n    float dCircle = sdCircle(p, 0.7);\n    float dTriangle = sdEquilateralTriangle(sdTranslate(p, vec2(0.0, -0.2)), 0.6);\n    float dHexagram = sdHexagram(p, 0.4);\n    float dRoundedX = sdRoundedX(p, 0.7, 0.15);\n    \n    // Wrap time.\n    float t = mod(iTime, 10.0);\n    \n    // Blend shapes.\n    float d;\n    if      (t <  1.0) d = dCircle;\n    else if (t <  2.0) d = mix(dCircle  , dBox     , ease(t - 1.0));\n    else if (t <  3.0) d = dBox;\n    else if (t <  4.0) d = mix(dBox     , dTriangle, ease(t - 3.0));\n    else if (t <  5.0) d = dTriangle;\n    else if (t <  6.0) d = mix(dTriangle, dHexagram, ease(t - 5.0));\n    else if (t <  7.0) d = dHexagram;\n    else if (t <  8.0) d = mix(dHexagram, dRoundedX, ease(t - 7.0));\n    else if (t <  9.0) d = dRoundedX;\n    else if (t < 10.0) d = mix(dRoundedX, dCircle  , ease(t - 9.0));\n\n    // Distance to smooth shape boundary, regardless the resolution.\n    float intensity = aaStep(0.0, d);\n\n    fragColor = vec4(vec3(1.0 - intensity), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}