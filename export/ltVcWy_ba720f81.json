{"ver":"0.1","info":{"id":"ltVcWy","date":"1537611621","viewed":201,"name":"Shifting Voronoi Pattern","username":"Elyxian","description":" A simple shader that I designed as the background for a project. Uses both a Voronoi pattern and Perlin noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// 3D Perlin Noise Implementation\n\nvec3 fade3(vec3 t) {\n\treturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nvec3 getGradient3D(vec3 p) {\n\treturn normalize(-1.0 + 2.0 * hash33(p));\n}\n\nfloat perlin3D(vec3 p) {\n\t\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = fade3(f);\n    \n    float value000 = dot(getGradient3D(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat value100 = dot(getGradient3D(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat value010 = dot(getGradient3D(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat value110 = dot(getGradient3D(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat value001 = dot(getGradient3D(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat value101 = dot(getGradient3D(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat value011 = dot(getGradient3D(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat value111 = dot(getGradient3D(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\treturn mix(\n\t\tmix(\n\t\t\tmix(value000, value100, u.x),\n\t\t\tmix(value010, value110, u.x),\n\t\t\tu.y),\n\t\tmix(\n\t\t\tmix(value001, value101, u.x),\n\t\t\tmix(value011, value111, u.x),\n\t\t\tu.y),\n\t\tu.z);\n\n}\n\n// Returns the position of the closest voronoi point\n\nvec2 voronoiCells2D(vec2 p) {\n\t\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float minDist = 5.0;\n    vec2 closestPoint = vec2(0.0, 0.0);\n    \n    for (int j = -1; j <= 1; j++) {\n        for (int k = -1; k <= 1; k++) {\n        \tvec2 relativeCell = vec2(float(j), float(k));\n            vec2 voroPoint = hash22(i + relativeCell);\n            float dist = distance(f, relativeCell + voroPoint);\n            if (dist < minDist) {\n            \tminDist = dist;\n                closestPoint = i + relativeCell + voroPoint;\n            }\n        }\n    }\n    \n    return closestPoint;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float voronoiScale = 35.0;\n    float perlinScale = 7.0;\n    float speed = 0.3;\n    \n    // Gets the position of the closest voronoi point\n    vec2 voroPoint = voronoiCells2D(p * voronoiScale) / voronoiScale;\n    \n    // Uses that point to create a color using perlin noise\n    float val = perlin3D(vec3(voroPoint * perlinScale, iTime * speed));\n    val = val * 0.5 + 0.5;\n    vec3 col = vec3(val);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}