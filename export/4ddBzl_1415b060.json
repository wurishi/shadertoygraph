{"ver":"0.1","info":{"id":"4ddBzl","date":"1526480110","viewed":499,"name":"Cloud/Noise Testing","username":"noxbuds","description":"Testing out noise generation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//  Raymarching clouds for fun                 //\n//                                  - Noxbuds  //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14159\n#define PHI 1.57080\nfloat cloudCoverage = 0.2;\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\nfloat brightness = 1.0;\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//            RAYMARCHING ALGORITHMS           //\n//                                             //\n/////////////////////////////////////////////////\n\nfloat tHeight1(vec3 p)\n{\n    float h = fbm(p.xz * 0.1) * 9.0;\n    h -= 21.0;\n    return h;\n}\n\n// Calculate terrain height at a point\nfloat tHeight(vec3 p)\n{\n    // Add some bigger shapes, then cut out some\n    // smaller details\n    float h = fbm(p.xz * 0.1) * 8.0;\n    h -= fbm(p.xz * 0.5) * 0.2;\n    h -= fbm(p.xz * 2.0) * 0.1;\n    //h += fbm(p.xz * 0.5) * 2.0;\n    //h += fbm(p.xz * 1.0) * 0.5;\n    //h += fbm(p.xz * 1.5) * 0.2;\n    //h += fbm(p.xz * 2.0) * 0.1;\n    \n    // Move it down\n    h -= 21.0;\n    \n    // Return h\n    return h;\n}\n\n// Calculate distance from terrain\nfloat tMap(vec3 p)\n{\n    // Just do some basic terrain\n    float h = tHeight(p);\n    \n    if (p.y < h)\n        return 0.0;\n    else\n    \treturn p.y - h;\n}\n\nvec3 tNormal(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        tMap(p + eps.xyy) - tMap(p - eps.xyy),\n        2.0 * eps.x,\n        tMap(p + eps.yyx) - tMap(p - eps.yyx)\n    ));\n}\n\nvec3 cNormal(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        tHeight1(p + eps.xyy) - tHeight1(p - eps.xyy),\n        2.0 * eps.x,\n        tHeight1(p + eps.yyx) - tHeight1(p - eps.yyx)\n    ));\n}  \n\n/////////////////////////////////////////////////\n//                                             //\n//             RAYMARCHING ATTEMPTS            //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculates clouds at a point and increments density\nfloat cloudsSS(vec3 cp, out float d)\n{\n    // Grab the cloud height here\n    float chm = 10.0;\n    float h = chm * (max(fbm((cp.xz - iTime * 0.8) * 0.1) + cloudCoverage - 0.2, 0.5) - 0.5);\n    float lh = h * 0.2;\n\n    // Raymarching step size\n    float stepSize = 0.0;\n\n    // If the point is inside a cloud,\n    // increase the density\n    if (cp.y > 1.0 - lh && cp.y < h + 1.0)\n    {\n        float ss = smoothstep(0.0, 0.8, 1.0 + h / chm - cp.y);\n        d += ss;\n    }\n\n    // Set the step size\n    if (cp.y > 0.9 - lh && cp.y < h + 1.1)\n        stepSize = 0.02 + d * 0.1;\n    else\n        stepSize = 0.1 * (1.0 - lh - cp.y);\n    \n    // Return step size\n    return stepSize;\n}\n\n// The core of the code; the raymarcher\nvec3 raymarch(vec2 uv)\n{\n    // Setup sky colour\n    vec3 skyCol1 = vec3(0.53, 0.81, 0.92);\n    vec3 skyCol2 = vec3(0.47, 0.6, 0.85);\n    vec3 col = mix(skyCol1, skyCol2, abs(uv.y) * 0.5);\n    \n    // Make sky colour darker with time\n    col = mix(vec3(mix(0.1, 1.0, abs(uv.y + 0.15) * 0.5)), col, brightness);\n    \n    // Setup raytracing variables\n    float ct = 0.0;\n    float tt = 0.0;\n    float d = 0.0;\n    float maxt = 75.0;\n    \n    // Making the camera hover above the terrain\n    vec2 lp = vec2(0.0, iTime);\n    float h = tHeight1(vec3(lp.x, 0.0, lp.y)) + 22.0;\n    \n    // Setup ray\n    vec3 o = vec3(lp.x, h-20.0, lp.y);\n    vec3 r = vec3(uv, 0.5 * PI);\n    \n    // Run raytracing\n    for (int i = 0; i < 256; i++)\n    {\n        // Setup points to test\n        vec3 cp = o + r * ct;\n        vec3 tp = o + r * tt;\n        \n        // Cutoff terrain further than a certain\n        // amount of units\n        if (length(tp.xz - o.xz) < maxt)\n        {\n            // Normal raymarching\n            // Handle terrain\n            \n            // Distance to terrain\n            float d = tMap(tp);\n            float th = tHeight(tp);\n            \n            // If we hit terrain, colour it in\n            if (d < 0.01)\n            {\n                // Calculate the normal\n                vec3 n = tNormal(tp);\n                vec3 cn = cNormal(tp);\n                \n                // Set a base colour\n                // 0.2, 0.8, 0.3\n                float blend = min((tp.y - th) * 9.0, 1.0);\n                \n                //col = vec3(0.2, 0.8, 0.3) * (1.0 - blend);\n                //col += vec3(1.0) * blend;\n                float angle = dot(vec3(0.0, 1.0, 0.0), cn);\n                \n               \tif (angle > 0.85)\n                    col = vec3(1.0);\n                else\n                    col = vec3(0.5);\n                \n                // Calculate the diffuse colour\n                col *= max(dot(-lightDir, n), 0.0);\n                \n                // Multiply colour by brightness\n                col *= 0.4 + 0.6 * brightness;\n                \n                // Cloud shadows would be nice but\n                // probably pretty expensive!\n                \n                // Stop raytracing when we hit terrain\n                break;\n            }\n            \n            // Increment tt\n            tt += d * 0.3;\n        }\n        \n        // Do cloud things\n        float fi = float(i);\n        float stepSize = cloudsSS(cp + vec3(0.0, (fi * fi * 0.2) / 256.0, 0.0), d);\n        \n        // Increment t.\n        ct += stepSize;\n    }\n    \n    // Cloud colour\n    vec3 cloudCol = vec3(1.1 - cloudCoverage * cloudCoverage);\n    \n    // Blend cloud colour and background\n    if (col == mix(skyCol1, skyCol2, abs(uv.y) * 0.5))\n    \tcol = mix(cloudCol, col, (1.0 / (1.0 + d)));\n    \n    // Return the colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE COMPOSITION              //\n//                                             //\n/////////////////////////////////////////////////\n// Main image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Modify brightness\n    //brightness = 0.5 + 0.5 * sin(iTime + PI);\n    \n    // Cloud coverage\n    //cloudCoverage = 0.3 + 0.3 * sin(iTime);\n    cloudCoverage = 0.4;\n    \n    // Setup colour\n    vec3 col = raymarch(uv);\n    col = 0.2 * col + 0.8 * sqrt(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}