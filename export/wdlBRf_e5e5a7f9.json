{"ver":"0.1","info":{"id":"wdlBRf","date":"1588878475","viewed":386,"name":"afig dlyr old style demo","username":"dlyr","description":"Start sound manually in Image and Buffer A and B, then click |<\nIf no sound, start sound manually in Image and Buffer A and B, then click |<\n\nCube ray casting,\nCRT effect with screen deformation, noise, and dimming line.\nUse music to \"animate\" the effects","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["smallcontribution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 stream(vec2 uv){\n    vec4 boxes = texture(iChannel0,uv);\n    vec4 circles = texture(iChannel1,uv);\n\tfloat a = circles.a;\n   \n    circles.rgb *= clamp(iTime-kf500, 0., 2.);\n\n    //return boxes.rgb;\n    //return circles.rgb;\n    //return vec3(circles.a);\n        \n    return circles.rgb*(1.-boxes.a)*(1.-a)+\n        \t(1.-a)*boxes.rgb+\n        \ta*vec3(162./255., 208./255., 38./255.);\n}\n\n\nfloat screening(vec2 uv){\n //   return 1.;\n    return cos(720.*uv.y)*.2+.8;\n}\n\nvec3 noise(vec2 fragCoord){\n //  return vec3(1.);\n    float scale=1000.;\n    return  .7+0.3*texelFetch(iChannel2,\n                            ivec3(int(fragCoord.x+scale*iTime)%32,\n                                  int(fragCoord.y+scale*iTime)%32,\n                                  int(fragCoord.x)/32+int(fragCoord.y)/32+int(scale*iTime))%32,0).xyz;\n}\n\nfloat warmup(){\n    return min(iTime/kf000, 1.);\n}\n\nfloat dfw( vec2 uv, float warmup, float fw){\n   // return 0.;\n   return warmup*0.3*(fw*fw*fw*fw);\n   return cos(20.*iTime)*warmup*0.3*(fw*fw*fw*fw);\n   return -.1*uv.y+cos(20.*iTime)*warmup*0.3*(fw*fw*fw*fw);\n}\n\nvec3 burn(vec2 uv, vec3 clean){\n    \n   // return clean;\n\tvec3 col = clean;\n    for(int i=0; i<8; i++){\n    \t col.r += stream(uv+vec2(float(i)*0.00051, 0.)).r;\n      \t col.g += stream(uv+vec2(float(i)*0.00051)).g;\n\n    }\n    col.rg /=8.;\n    float ratio = smoothstep(0., kf1, kf1-iTime);\n\tcol = clean*ratio+(1.-ratio)*col;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenUv = fragCoord/iResolution.xy-0.5;\n\n    vec2 fisheye = fragCoord/iResolution.xy-.5;\n    \n    float warmup = warmup();\t\n    warmup = sqrt(warmup);\n    vec2 fd = (2.-warmup)*normalize(fisheye);\n    float fw = length(fisheye);\n    \n    float vignetting = warmup*clamp(1.-2.*(fw*fw*fw*fw), 0., 1.);\n    \n    float dfw = dfw(fisheye, warmup, fw);\n    \n // fisheye tex transform   \n    fisheye = (0.8*fw+dfw)*fd;\n   \n    \n    vec2 uv  = fisheye+0.5;\n   // uv = fragCoord/iResolution.xy;   \n   // fisheye *= iResolution.xy;\n    \n   // vec2 uv  = fragCoord / iResolution.xy;\n    vec3 clean=stream(uv);\n    vec3 col = burn(uv, clean);\n   \n    \n    float screening = screening(fisheye);\n   \tvec3 noisev = noise(fragCoord);\n    fragColor = vec4(noisev*vignetting*screening*col.xyz, 1.);\n\n    // demo explained\n    //fragColor = vec4(screenUv, 0., 1.);\n    //fragColor = vec4(fisheye, 0., 1.);\n    //fragColor = vec4(10.*abs(screenUv-fisheye), 0., 1.);\n    //fragColor = vec4(cos(1000.*(screenUv-fisheye)), 0., 1.);\n\n    //fragColor = vec4(stream(screenUv+.5), 1.);\n    //fragColor = vec4(clean, 1.);\n    //fragColor = vec4(col, 1.);\n\n    //fragColor = vec4(noise(fragCoord/2.), 1.);\n    //fragColor = vec4(vec3(vignetting), 1.);\n    //fragColor = vec4(vec3(screening), 1.);\n    //fragColor = vec4(noisev*vignetting*screening, 1.);\n\n    //fragColor = vec4(noisev*vignetting*screening*col.xyz, 1.);\n\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"MtfXzn","filepath":"https://soundcloud.com/chiptune/little-swedish-girl","previewfilepath":"https://soundcloud.com/chiptune/little-swedish-girl","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Ray {\n    vec4 o, d; // ray orig and dir\n    vec3 id;\n    int s[3];\n};\n\n    void rayInit( out Ray ray, in vec3 orig, in vec3 dir ) {\n        ray.o    = vec4(orig, 1.);\n        ray.d    = vec4(dir, 0.);\n        ray.id   = 1. / ray.d.xyz;\n        ray.s[0] = int( ray.id.x < 0.);\n        ray.s[1] = int( ray.id.y < 0. );\n        ray.s[2] = int( ray.id.z < 0. );\n    }\n\nvec4 rayAt(in Ray ray, in float t){\n    return ray.o + t * ray.d;\n}\n\nstruct Aabb {\n    vec3 bounds[2];\n    vec3 offset;\n    mat4 frame;\n    mat4 invFrame;\n    vec3 col;\n};\n    \n\n    void aabbInit(out Aabb aabb, in vec3 m, in vec3 M){\n        aabb.bounds[0]=m;\n        aabb.bounds[1]=M;\n        aabb.offset = M-m;\n        aabb.frame = mat4(1.);\n        aabb.invFrame = mat4(1.);\n\n    }\n\nvoid aabbRotateX(inout Aabb aabb, in float angle){\n\n    float c = cos(angle);\n    float s = sin(angle);\n    vec4 col0 = vec4(1., 0., 0., 0.);\n    vec4 col1 = vec4(0., c, s, 0.);\n    vec4 col2 = vec4(0., -s, c, 0.);\n    vec4 col3 = vec4(0., 0., 0., 1.);\n\n    aabb.frame=mat4(col0, col1, col2, col3);      \n}\n\nmat2 matRot2D(in float angle){\n\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 col0 = vec2(c, s);\n    vec2 col1 = vec2(-s, c);\n\n    return mat2(col0, col1);      \n}\n\nvoid aabbTranslate(inout Aabb aabb, vec3 t){\n    aabb.frame[3].xyz= (aabb.frame*vec4(t, 1.)).xyz;\n    aabb.invFrame[3].xyz = -t;\n}\n\nstruct Intersection{\n    float dc;\n    vec4 p;\n    vec3 n;\n    float t;\n    vec3 col;\n};\n\n    float distEdges(vec3 p, vec3 e){\n        return dot(p, e);\n    }\n\nbool intersect( in Aabb aabb, in Ray ray, out Intersection isec ) {\n    vec4 o = aabb.frame*ray.o;\n    //   r.o /= r.o.w;\n    vec4 d = aabb.frame*ray.d;\n    Ray r;\n    rayInit(r, o.xyz, d.xyz);\n\n    r.id = 1./r.d.xyz;\n    r.s[0] = int( r.id.x < 0.);\n    r.s[1] = int( r.id.y < 0. );\n    r.s[2] = int( r.id.z < 0. );\n\n    Intersection ret;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n    tmin  = ( aabb.bounds[r.s[0]].x - r.o.x ) * r.id.x;\n    tmax  = ( aabb.bounds[1 - r.s[0]].x - r.o.x ) * r.id.x;\n    tymin = ( aabb.bounds[r.s[1]].y - r.o.y ) * r.id.y;\n    tymax = ( aabb.bounds[1 - r.s[1]].y - r.o.y ) * r.id.y;\n\n    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n    if ( tymin > tmin ) tmin = tymin;\n    if ( tymax < tmax ) tmax = tymax;\n\n    tzmin = ( aabb.bounds[r.s[2]].z - r.o.z ) * r.id.z;\n    tzmax = ( aabb.bounds[1 - r.s[2]].z - r.o.z ) * r.id.z;\n\n    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n    if ( tzmin > tmin ) tmin = tzmin;\n    if ( tzmax < tmax ) tmax = tzmax;\n\n    //isec.pos = aabb.invFrame*rayAt(r, tmin);\n    isec.p = rayAt(r, tmin);\n\n    float dist;\n    vec3 p = isec.p.xyz;\n\n    //    dist = length(p-aabb.bounds[0]);\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(aabb.offset.x,0,0))));\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(aabb.offset.xy,0))));\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(0,aabb.offset.y,0))));\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(aabb.offset.x,0,aabb.offset.z))));\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(aabb.offset.xy,aabb.offset.z))));\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(0,aabb.offset.y,aabb.offset.z))));\n    //    dist = min(dist,length(p-(aabb.bounds[0]+vec3(0,0,aabb.offset.z))));\n\n\n    //   float distEdge;\n    //  vec3 diag = bounds[1] - bounds[0];\n    //vec3 edge = \n\n\n    vec3 n = p;\n    if(abs(n.x)>abs(n.y))\n        if(abs(n.x)>abs(n.z))\n            n = vec3(sign(n.x), 0., 0.);\n        else n = vec3(0., 0., sign(n.z));\n        else\n            if(abs(n.y)>abs(n.z))\n                n = vec3(0., sign(n.y), 0.);\n            else n = vec3(0., 0., sign(n.z));\n            mat4 iframe = inverse(aabb.frame);\n        isec.p = iframe*isec.p;\n    isec.n = (iframe*vec4(n, 0.f)).xyz;\n    isec.dc = dist;\n    isec.t = tmin;\n    isec.col = aabb.col;\n    return true;\n}\n\n\n// camera rotation : pitch, yaw\nmat4 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n\n    return mat4(\n        c.y      ,  0.0, -s.y, 0.,\n        s.y * s.x,  c.x,  c.y * s.x, 0.,\n        s.y * c.x, -s.x,  c.y * c.x, 0.,\n        0., 0., 0., 1.\n    );\n}\n\n\nvec3 translation(in int i){\n    float ix = float(i%4)-1.5;\n    float iy = float(i/4)-1.;\n\n    if(iTime < kf100)\n        return vec3(ix,iy,8.);\n\n\n    float ioffbegin=float(i%4)*.3;\n    float ioffend = ioffbegin+.5;\n    if(iTime < kf110) \n        return vec3(ix, iy,\n                    8.+1.*smoothstep(kf100+ioffbegin, kf100+ioffend,iTime));\n\n    float fft  = texelFetch( iChannel0, ivec2(i,0.), 0 ).x; \n\n    if(iTime < kf170)\n        return vec3(ix, iy,\n                    9.-smoothstep(kf120, kf121, iTime)*1.2*fft);\n\n    float ai = float(i)+iTime;\n    return vec3(cos(ai), sin(ai),\n                9.+mod(ai, 7.));\n\n}\n\nmat4 rotation(int i){\n    if(iTime < kf130)\n        return mat4(1.);\n    if(iTime < kf140)\n        return rotationXY( (iTime-kf130) * 50. * vec2( 0.01, -0.01 ) );\n\n    float fft  = texelFetch( iChannel0, ivec2(i,0), 0 ).x; \n\n    return rotationXY( ( vec2(fft*float(i)+iTime-kf140) * 50. ).yx * vec2( 0.01, -0.01 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv  = fragCoord / iResolution.xy;\n    vec3 col = 0.5 + 0.5 * cos( iTime + uv.xyx + vec3( 0, 2, 4 ) );\n\n    vec2 ruv = (uv-.5)*vec2(1, iResolution.y/iResolution.x);\n\n    float aperture = 1.;\n    vec2 offset = ruv *aperture;\n\n    vec3 orig = vec3( 0., 0., 0. );\n    vec3 viewDir = vec3( 0., 0.,-1. );\n    vec3 x = vec3( 1., 0., 0. );\n    vec3 y = vec3 ( 0., 1., 0. );\n\n    vec3 dir = normalize(viewDir + offset.x * x + offset.y * y);\n    Ray r;\n\n    rayInit( r, orig, dir );\n\n    Aabb aabb[12];\n    //    vec4 outColor = vec4( col, 1.0 );\n    vec4 outColor = vec4( vec3(0.), 0.0 );\tfloat imin=100.;\n    for(int i=0; i<12; i++){\n\n        float s=0.5;\n        if(iTime>kf5)\n            s=max(0.2, 0.5-iTime+kf5);\n\n        aabbInit(aabb[i], vec3( -s), vec3( s ));\n        aabb[i].col = vec3(1.f);\n\n        if(iTime>kf5)\n            aabb[i].col = vec3(float(i)/16., 1.-float(i)/16., 0.);\n\n        aabb[i].frame = rotation(i);\n        aabbTranslate(aabb[i], translation(i)); \n\n        Intersection isec;\n\n        bool res = intersect( aabb[i], r, isec );\n\n        // Output to screen\n        vec3 light = vec3(10., 10., 1.);\n        if(res){\n            if(imin>isec.t){\n                imin = isec.t;\n                vec3 n = isec.n;\n                vec3 l = normalize(light - isec.p.xyz);\n                vec3 e = -dir;\n                vec3 h = normalize(l+e);\n                float dotnl = clamp(dot(n,l), 0., 1.);\n                float dotnh = clamp(dot(n,h), 0., 1.);\n                dotnh *= dotnh;\n                dotnh *= dotnh;\n                dotnh *= dotnh;\n                dotnh *= dotnh;\n                dotnh *= dotnh;\n\n\n                vec3 s = vec3(1.-clamp(iTime-kf100, 0., 1.));\n                vec3 c = s+dotnl*isec.col+vec3(dotnh)*4.;\n                outColor = vec4(c, 1.);\n\n                //     outColor = vec4(l, 1.);\n\n                /// outColor = vec4(vec3(1), 1.);\n            }\n        }\n    }\n    fragColor = outColor;\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llfXzn","filepath":"https://soundcloud.com/chiptune/little-swedish-girl","previewfilepath":"https://soundcloud.com/chiptune/little-swedish-girl","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define M_PI 3.1415926535897932384626433832795\nfloat circle(vec2 uv, float radius, float offset, float subdiv, float width, float stre, float eStre){        \n    vec2 center = vec2(0.);\n    \n    vec2 p = uv-center;\n    p = vec2(cos(offset)*p.x-sin(offset)*p.y,\n             sin(offset)*p.x+cos(offset)*p.y);\n    vec2 n = normalize(p);\n    \n    float a = acos(n.x);\n    if(n.y<0.) a = 2.0*M_PI-a;\n    a /= 2.0*M_PI;\n    \n//    int tx = int(a*512.0);\n    int tx = int(a*512.0/subdiv)*int(subdiv);\n  \tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    radius += stre*fft;\n    float d = abs(radius-length(p));\n    \n    float edge0 = (a*512.0/subdiv-float(int(a*512.0/subdiv)));\n    float edge1 = 1.0-edge0;\n    float e = (1.-eStre*(1.0-smoothstep(0.008, 0.05, edge0*edge1)));\n    return e*(1.0-smoothstep(0.7, 0.80, smoothstep(0.0, width, d)));    \n}\n\nbool circle(vec2 uv, vec2 center, float radius){\n\tvec2 p = uv-center; \n    return length(p)<radius*radius;\n}\n\nfloat stre(){\n \treturn min(max(0., (iTime-kf200)*0.1), .08);   \n}\n\nfloat fade(){\n \treturn 1.-smoothstep(kf210, kf211, iTime);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    // funky deformation boost test\n    /*\n    float boost = texelFetch( iChannel0, ivec2(1,0), 0 ).x; \n    \n    uv.x += -clamp(boost-.5, 0.0, 1.0)*3.0*\n   (.5*cos(iTime)-.5)*\n      (uv.y)*(uv.x-0.5);\n \tuv.x = clamp(uv.x, 0., 1.);\n    */\n    \n    vec2 ruv = uv-0.5;\n    vec2 sq = cos(ruv*10.0)*sin(ruv*10.0);\n    sq = smoothstep(vec2(0.), vec2(.5), sq)*2.0-1.0;\n    \n    // sq = ruv;\n    //ruv -= cos(iTime)*0.3*0.05*sq;\n    \n\truv = ruv*vec2(1, iResolution.y/iResolution.x);\n   \n    // the sound texture is 512x2\n    int tx = int(sq.x+uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\t\n\t// convert frequency to colors\n    // modified from https://www.shadertoy.com/view/Xds3Rr\n\tvec3 col = vec3( cos(iTime)*fft, sin(iTime)*4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    \n    float offset = M_PI/4.;    \n    float colcircle = circle(ruv, 0.11, offset, 128.0, 0.025, stre(), 1.);\n  \n    // Another circle to show\n    //colcircle = circle(ruv, 0.15, offset, 12.0, 0.025, .1, 2.);\n\n    float fade = fade();\n    float oneMinusFade = 1.-fade;\n    \n //  if(circle(ruv, vec2(mod(iTime, 1.)-.5, .1*cos(10.*iTime)-.12), 0.11))        \n    if(circle(ruv, vec2(.12, -.12), 0.11))\n        colcircle=1.*fade+(oneMinusFade)*colcircle;\n    \n    if(circle(ruv, vec2(.078, -.078), 0.185))\n        colcircle=0.*fade+(oneMinusFade)*colcircle;\n \n    if(circle(ruv, vec2(.078, -.078), 0.18))\n        colcircle=1.*fade+(oneMinusFade)*colcircle;\n   \n\t// output final color\n    vec4 oldCol = vec4(0.);//texture(iChannel1, uv);\n\tfragColor = vec4(col.xyz, oldCol.a+ colcircle);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float kf000=1.5; // screen powerup\nconst float kf1 = kf000+1.; //burn\nconst float kf25 = 12.; // rotate cube\nconst float kf3 = 15.;\nconst float kf5 = 20.;\nconst float kf6 = 25.;\n\n\nconst float kf100 = 2.; // cube fixed\nconst float kf110 = 4.; // cube move back\nconst float kf120 = 6.5; // cube spinf fade\nconst float kf121 = 8.; // cube spin fade\n\n\nconst float kf130 = 10.; // no rotate\nconst float kf140 = 12.; // small rotate\n// full rotate fft\n\nconst float kf170 = 40.; // cube circle\n\nconst float kf200 = 12.; // animate logo\nconst float kf210 = 8.5; // fade circle\nconst float kf211 = 8.8; // fade circle\n\nconst float kf500 = 25.; // bg color\nconst float kf600 = 30.; // screen sin","name":"Common","description":"","type":"common"}]}