{"ver":"0.1","info":{"id":"dsGfzG","date":"1698326035","viewed":70,"name":"real mountain","username":"tomcat7479","description":"二维噪声 + 二维插值实现的山体","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define min_iter_distance 0.001\n#define max_iter_distance 200.0\n#define iter_precision 1e-3\n#define iter_count 512\n#define rotate_iter_count 10\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 up = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat random(vec2 pos) {\n    vec3 p3 = fract(vec3(pos.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// return noise value and noise gradient\nvec3 noise(vec2 pos) {\n    vec2 integer_part = floor(pos);\n    vec2 fract_part = fract(pos);\n    vec2 u = fract_part * fract_part * (3.0 - 2.0 * fract_part); // (3x^2 - 2x^3, 3y^2 - 2y^3)\n    vec2 du = 6.0 * fract_part * (1.0 - fract_part);\n\n    vec2 h = vec2(0.0, 1.0);\n    float a = random(integer_part);\n    float b = random(integer_part + h.yx);\n    float c = random(integer_part + h.xy);\n    float d = random(integer_part + h.yy);\n\n    float noise_value = a + (b - a) * u.x * (1. - u.y) +(c - a) * (1. - u.x) * u.y + (d - a) * u.x * u.y;\n    vec2 noise_gradient = du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx);\n    return vec3(noise_value, noise_gradient);\n}\n\nmat2 rotate = mat2(0.6, -0.8, 0.8, 0.6);\n\nfloat ground(vec2 pos) {\n    float sdf = 0.0;\n    float scale = 1.0;\n    vec2 gradient = vec2(0.0);\n    for (int i = 0; i < rotate_iter_count; i++) {\n        vec3 noiseInfo = noise(pos);\n        gradient += noiseInfo.yz;\n        sdf += scale * noiseInfo.x / (1.0 + dot(gradient, gradient));\n        pos = rotate * pos * 2.0;\n        scale *= 0.5;\n    }\n    return sdf;\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 epsilon = vec2(1e-5, 0);\n    return normalize(vec3(ground(p.xz + epsilon.xy) - ground(p.xz - epsilon.xy), 2.0 * epsilon.x, ground(p.xz + epsilon.yx) - ground(p.xz - epsilon.yx)));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = min_iter_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 pos = ro + t * rd;\n        float d = ground(pos.xz);\n        float dy = pos.y - d;\n        if (abs(dy) < iter_precision * t || t > max_iter_distance) {\n            break;\n        }\n        t += 0.2 * dy;\n    }\n    return t;\n}\n\nvec3 render(vec2 pos) {\n    vec3 col = vec3(0);\n\n    float an = sin(iTime * .2) * .2 + .4;\n    float r = 3.1;\n    vec3 ro = vec3(r * sin(an), .8, r * cos(an));\n    vec3 target = vec3(0, 0., 0);\n    mat3 cam = setCamera(ro, target, 0.);\n\n    float fl = 1.;\n    vec3 rd = normalize(cam * vec3(pos, fl));\n\n    float t = rayMarch(ro, rd);\n\n    if (t < max_iter_distance) {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNorm(p);\n        vec3 difColor = vec3(0.67, 0.57, 0.44);\n        col = difColor * dot(n, vec3(0, 1, 0));\n    } else {\n        col = vec3(0.1882, 0.5882, 0.8941) * exp(-1.0 * pos.y);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n    fragColor = vec4(render(uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}