{"ver":"0.1","info":{"id":"4tGSDz","date":"1484494367","viewed":1216,"name":"Lava Mandala","username":"ptrgags","description":"First test of making mandala art in a shader. Thee background was another happy accident of a low-res texture.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","radial","lava","polar","twist","mandala"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n//10 cells in the radial direction, \n//24 around the circle\n#define GRID_DIMS vec2(20.0, 24.0)\n\n//------------------------------------------------------\n\n/**\n * Keep track of the grid cell ID number\n * and the UV coordinates within that cell.\n * \n * Overkill? probably. I just wanted to try struct\n * syntax in GLSL.\n */\nstruct GridCoords {\n    vec2 id;\n    vec2 uv;\n    //For storing coordinates flipped every other box\n    vec2 flipped;\n};\n    \n/**\n * Take UV coordinates, scale up and divide into boxes.\n */\nGridCoords grid_coords(vec2 uv, vec2 grid_dims) {\n    vec2 scaled = uv * grid_dims;\n    GridCoords gridded;\n    gridded.id = floor(scaled);\n    gridded.uv = fract(scaled);\n    \n    //Flip coordinates back and forth every cell (around the circle only)\n    //for added symmetry\n    vec2 flipped = vec2(0.0, 1.0) - gridded.uv;\n    float odd = mod(gridded.id.y, 2.0);\n    gridded.flipped = mix(gridded.uv, flipped, odd);\n        \n    return gridded;\n}\n\n//---------------------------------------------\n\n//Convert rectangular to polar coordinates\nvec2 rect_to_polar(vec2 rect) {\n    float r = length(rect);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI. These two lines are optional\n    if (theta < 0.0)\n        theta += TAU;\n    \n    return vec2(r, theta);\n}\n\n/*\n * Convert screen coordinates to \n * normalized polar coordinates with the origin in the center\n * of the screen. angle is measured from 0.0 to 1.0 counterclockwise\n * around the circle.\n */\nvec2 normalized_polar(vec2 coord) {\n    //Centered UV coordinates accounting for aspect ratio\n    vec2 uv = (coord - CENTER) / iResolution.y;\n    \n    //Convert to polar. Normalize the angle component by\n    //dividing by a full circle.\n    vec2 polar = rect_to_polar(uv);\n    polar.y /= TAU;\n    \n    return polar;\n}\n\n//max component of 2-vector.\nfloat vecmax(vec2 p) {\n    return max(p.x, p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //Get the screen coords in polar coordinates as well\n    //as grid coordinates\n    vec2 polar = normalized_polar(fragCoord);\n    \n    //twist the coordinates back and forth\n    float swirl = 0.3 * sin(polar.x - iTime);\n    polar.y -= swirl;\n    \n    //polar.y -= iTime * 0.1;\n    GridCoords polar_grid = grid_coords(polar, GRID_DIMS);\n    \n    //Ring number increasing outward\n    float ring = polar_grid.id.x;\n    \n    //Function that defines the pattern to display in each ring\n    float f;\n    float brightness;\n    \n    //Colors to use\n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 white = vec4(1.0);\n    vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\n    \n    //Draw a mandala pattern in the first few rings\n    if (ring < 1.0) {\n        fragColor = step(0.5, polar_grid.uv.x) * yellow;\n    } else if (ring < 2.0) {\n        f = 2.0 * abs(polar_grid.uv.y - 0.5);\n        brightness = step(f, polar_grid.uv.x);\n        fragColor = brightness * red;\n    } else if (ring < 3.0) {\n        f = polar_grid.flipped.y;\n        brightness = smoothstep(f + 0.1, f, polar_grid.uv.x);\n        fragColor = brightness * yellow;\n    } else if (ring < 4.0) {\n        f = smoothstep(0.0, 1.0, polar_grid.flipped.y);\n        brightness = smoothstep(f + 0.1, f, polar_grid.uv.x);\n        fragColor = brightness * red;\n    } else if (ring < 5.0) {\n        f = polar_grid.uv.y;\n        brightness = smoothstep(f + 0.1, f, polar_grid.uv.x);\n        fragColor = brightness * yellow;\n    } else {\n        //outside the circle, use a noise texture\n        //as the function\n        f = texture(iChannel0, polar).x;\n        brightness = smoothstep(f + 0.1, f, polar.x);\n        fragColor = brightness * red;\n    }\n    \n\t\n}","name":"Image","description":"","type":"image"}]}