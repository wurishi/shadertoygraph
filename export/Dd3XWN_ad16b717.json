{"ver":"0.1","info":{"id":"Dd3XWN","date":"1679872587","viewed":126,"name":"Bird on  the roof","username":"ianertson","description":"Use the mouse to look around :)","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","sdf","raytrace","bird","animal","roof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ID_GROUND 1\n#define ID_BIRD 2\n#define ID_BIRD_LEG 3\n#define ID_BIRD_BEAK 4\n#define ID_BIRD_EYE 5\n#define ID_BUILDING 6\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat coneSDF(in vec3 p, in vec3 dir, in float len, in float r) {\n    vec3 mask = vec3(1.0) - dir;\n    float d = length(p*mask)-r;\n    d = max(d, length(p*dir)-len);\n    \n    float dp = max(0.0, dot(p, dir));\n    d += dp;\n    vec3 mp = p*dir;\n    d = max(d, -(min(mp.x, min(mp.y, mp.z)) +len ));\n    return d/1.5;\n}\n\nfloat birdSDF(in vec3 p, in int skip, inout Object o, inout int id) {\n    if (p.y > 1.5) return FAR;\n    if (skip == ID_BIRD) return FAR;\n    id = ID_BIRD;\n    \n    /// Body\n    float bodyR = 0.2;\n    float upLift = smoothstep(-0.05, 0.78, max(0.0, p.y*max(0.0, p.z+0.04)));\n    float body = sphereSDF(p - vec3(0, bodyR + upLift, p.z/2.), bodyR);\n    body += smoothstep(0.0, 0.4, max(0.0, p.z*max(0.0, -p.y+0.3)));\n    body += 0.677*smoothstep(0.05, 1.3, abs(p.x)*2.)*smoothstep(0.0, 1.2, max(0.0, -p.z)*2.5);\n    \n    float bodyBack = cylSDF(p - vec3(0, bodyR, (-bodyR*2.) + 0.05), vec3(0, 0, 0), vec3(0, 0.02, 0), bodyR+0.05);\n    bodyBack += smoothstep(0.02, 0.55, sclamp(-p.z, 0.0, 1.0, 0.9)*abs(p.x));\n    bodyBack -= 0.02;\n    bodyBack /= 1.5;\n    body = smin(body, bodyBack, 0.15);\n   \n    vec3 shapeDir = normalize(vec3(0, -0.5, -1));\n    float shapeLen = bodyR*2.;\n    float shapeThick = bodyR*0.9;\n    float shape = lineSDF(p - vec3(0, bodyR+0.35, -(bodyR-0.15)), vec3(0, 0, 0), shapeDir*shapeLen, shapeThick);\n    shape += smoothstep(0.0, 1.0, max(0.0, -p.y+0.5));\n    body = smax(body, -shape, 0.05+smoothstep(0.0, 2.0, max(0.0, -p.z)));\n\n    // Neck\n    float neckLen = 0.15;\n    float neckThick = 0.045;\n    vec3 neckDir = normalize(vec3(0, 1, 0.25));\n    vec3 neckPos = vec3(0, bodyR+neckLen*1.5, bodyR*1.8);\n    float neck = lineSDF(p - neckPos, vec3(0, 0, 0), neckDir*neckLen, neckThick);\n    body = smin(body, neck, 0.06);\n   \n    // Head\n    float headR = 0.05;\n    vec3 headPos = (neckPos+vec3(0, headR+neckLen, headR));\n    float head = sphereSDF(p - headPos, headR);\n    head += smoothstep(0.0, 0.9, abs(p.x));\n    head -= smoothstep(0.01, 2.0, (length(p.xz)-0.1)/(1.0+abs(p.y)*0.2))*0.8;\n    head += smoothstep(0.0, 1.0, max(0.0, -p.y+0.66));\n    head += smoothstep(0.0, 1.0, max(0.0, p.z-0.49));\n    head += smoothstep(0.013, 0.4, abs(p.x)+0.002)*smoothstep(0.4, 0.5, max(0.0, p.z))*\n            smoothstep(0.6, 0.9, max(0.0, p.y+0.09));\n    \n    // Beak\n    float beakLen = 0.13;\n    vec3 beakDir = normalize(vec3(-0.2, -0.5, 1.));\n    float beakR = 0.019;\n    vec3 beakPos = (headPos + vec3(0, -0.022, beakLen));\n    Object oBeak = Object(o.p+pointRotInv(beakPos, o.q), o.q);\n    float beak = coneSDF(pointRot(p - beakPos, vec3(0.4, 0, 0)), beakDir, beakLen, beakR);\n    \n    // Eye\n    float eyeHoleR = 0.015;\n    vec3 eyeHolePos = (headPos + vec3(headR-0.012, eyeHoleR+0.011, 0.005+headR+eyeHoleR*2.));\n    float eyeHole = sphereSDF(vec3(abs(p.x), p.y, p.z) - eyeHolePos, eyeHoleR);\n    head = smax(head, -eyeHole, 0.003);\n    \n    float eyeR = eyeHoleR*0.8;\n    vec3 eyeDir = normalize(vec3(1, 0, 0.4));\n    float eyeLen = 0.004;\n    vec3 eyePos = abs(eyeHolePos + vec3(-0.0039, 0, 0));\n    Object oEye = Object(o.p+pointRotInv(eyePos, o.q), o.q);\n    float eye = cylSDF(vec3(abs(p.x), p.y, p.z) - eyePos, vec3(0, 0, 0), eyeDir*eyeLen, 0.01);\n    float eyeSp = sphereSDF(vec3(abs(p.x), p.y, p.z) - eyePos, eyeR);\n    eye = mix(eye, eyeSp, clamp(0.2+smoothstep(0.01, 0.12, abs(p.x)), 0.0, 1.0));\n\n    body = smin(body, head, 0.034);\n    \n    // Wing\n    vec3 wingRot = vec3(cos((T*3.)+(sign(p.x)*2.))*0.15, 0.0, 0.0);\n    float wing = FAR;\n    {\n        \n        \n        vec3 wingDir = normalize(vec3(0.2, -0.4, -1.));\n        float wingLen = 0.51;\n        float wingR = 0.1;\n        vec3 wingPos = vec3(abs(bodyR-(wingR/1.2)), wingR+bodyR+0.01, wingLen-0.29);\n        wing = lineSDF(pointRot(vec3(abs(p.x), p.y, p.z) - wingPos, wingRot), vec3(0, 0, 0), wingDir*wingLen, wingR);\n        vec3 p = pointRot(p, wingRot);\n        wing += smoothstep(0.0, 1.9,dot(vec3(abs(p.x), p.y, p.z)-wingPos, wingDir)*0.6)*smoothstep(0.0, 0.1, abs(abs(p.x)-wingPos.x));\n        wing -= 0.8*smoothstep(0.0, 1.0, abs(p.y*wingDir.y))/(1.0 + smoothstep(0.0, 0.1, abs(abs(p.x)-wingPos.x)));\n        float wingSmooth = smoothstep(0.0, 0.5, max(0.0, p.y));\n        body = smin(body, wing,0.04*wingSmooth);\n    }\n   \n    // Leg\n    float legLen = bodyR*0.6;\n    vec3 legPos = vec3(bodyR*0.3, -legLen*0.78, bodyR*0.4);\n    float legId = sign(p.x);\n    float legThick = 0.01;\n    vec3 legDir = vec3(0, 1, 0);\n    vec3 legRot = vec3(mix(-0.45, 0.45, 0.5+cos((-T*4.)+legId*2.)*0.5), 0, 0);\n    Object oLeg = Object(o.p+pointRotInv(legPos, o.q), o.q+legRot);\n    float leg = lineSDF(pointRot(vec3(abs(p.x), p.y, p.z) - legPos, legRot), vec3(0, 0, 0), legDir*legLen, legThick);\n    \n    leg += sin(p.y*100.6)*0.0016;\n\n    // Toe\n    vec3 toeDir = vec3(0, 0, 1);\n    float toeThick = legThick*0.6;\n    float toeLen = legLen*0.6;    \n   \n    float toeFront = lineSDF(pointRot(vec3(abs(p.x), p.y, abs(p.z)) - vec3(legPos.x, (toeThick*2.) - legLen, toeLen+legThick*2.), legRot), vec3(0, 0, 0), toeDir*toeLen*sign(p.z-legPos.z*1.1), toeThick);\n    toeFront = max(toeFront, -(p.z-0.01));\n    toeFront += cos(p.z*256.28)*0.0009;\n    \n    leg = min(leg, toeFront);\n    \n    \n    vec3 toeLeftDir = normalize(vec3(1., 0, 1.));\n    if (sign(p.x-legPos.x) < 0. && length(p.x) <= toeLen*0.89) { toeLeftDir.x *= -1.; }\n    \n    float toeLeftLen = toeLen*0.8;\n    float toeLeft = lineSDF(pointRot(vec3(abs(p.x), p.y, p.z) - vec3(legPos.x, (toeThick*2.) - legLen, toeLeftLen+legThick*2.), legRot), vec3(0, 0, 0), toeLeftDir*toeLeftLen, toeThick);\n    \n    toeLeft += cos(p.x*256.28)*0.0016;\n\n    leg = min(leg, toeLeft);\n    \n    float dist = body;\n    \n    \n    if (p.y < 0.05 && p.z > 0.001) {\n    leg = smin(leg, body, 0.05);\n    }\n    \n    SAMPLE(leg, oLeg, ID_BIRD_LEG);\n    SAMPLE(beak, oBeak, ID_BIRD_BEAK);\n    SAMPLE(eye, oEye, ID_BIRD_EYE);\n    \n    \n\n    return dist/1.1;\n}\n\n// super advanced bird AI\nvec2 getNextPos(in float time, in vec3 p) {\n   float r0 = snoiseFast((((p.xz*0.02)+(time*0.01))*0.2)+0.921235, 5.593491);\n   time += r0*0.25;\n   vec2 n = vec2(cos(time), sin(time));\n   float r1 = snoiseFast((n + (time*0.01))+0.023812, 0.03281231);\n   n *= rot(r1);\n   time -= r1;\n   n += 0.0002932913;\n   time *= (1.0+(r1*0.09*r0));\n   float r2 = snoiseFast((((n+p.xz)*0.1) + (time*0.01))*0.1, 3.3333921);\n   n += vec2(sin(time+r2), cos(time+r2))*r2;\n   n += 0.000222213;\n   n += (p.xz*r0*r1*r2);\n   return n;\n}\n\n// built-in atan() doesn't work correctly\nfloat atan2(in float y, in float x) { return abs(x) <= 0.000001 ? sign(y)*M_PI/2. : atan(y, x); }\n\nObject getBird() {\n    Object oBird = Object(vec3(0.01, 0.2, 0.01), vec3(0.0));\n    vec3 p = oBird.p;\n    vec3 q = oBird.q;\n    \n    float a = 0.0;\n    float time = (T*0.2)-1.429182231;\n    vec2 cur = getNextPos(time, p);\n    p.xz = cur;\n    vec2 next = getNextPos(time+0.269, p);\n    vec2 dir = normalize(next-cur);\n\n    a = atan2(dir.y, dir.x)-radians(90.);\n   // a = (a > 0. ? a : (2.*M_PI + a)) * 360. / (2.*M_PI);\n    p.xy = mix(p.xy, p.xy*0.23, 0.5+cos(time)*0.5);\n    p.y = 0.15+0.005*(0.5+sin(time*59.)*0.5);\n    \n    oBird.p = p;\n    oBird.q.y = a;\n    oBird.q.x = cos(time*24.)*0.09*(0.2+(length(next-cur)+abs(a)*0.5));\n    \n\n    return oBird;\n}\n\nfloat getBuildingHeight(in vec3 p) {\n    vec2 bid = floor((p.xz-16.)/32.)-16.5;\n    p.z = mod(p.z-16., 32.0) - 16.5;\n    p.x = mod(p.x-16., 32.0) - 16.5;\n    float h = 16.;\n\n    float ra = hash21Fast(bid, bid.x+bid.y+2.3282815);\n    h = mix(h, h*2., ra);\n    return h;\n}\n\nfloat buildingSDF(in vec3 p, in float h, in vec2 bid, inout int id, in int skip, inout Object o) {\n    float dist = FAR;\n    float base = boxSDF(p - vec3(0, h, 0), vec3(8.0, h, 8.0));\n    float fence = boxSDF(p - vec3(0, 0.25 + h*2., 0.), vec3(8.0, 0.25, 8.0));\n    float fenceInside = boxSDF(p - vec3(0, 4. + h*2., 0.), vec3(7.5, 4., 7.5));\n    fence = max(fence, -fenceInside);\n    dist = min(dist, base);\n    dist = min(dist, fence);\n    return dist/1.2;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    float h = getBuildingHeight(p);\n    \n    {\n        vec3 p = p;\n        \n        vec2 bid = floor((p.xz-16.)/32.)-16.;\n        p.z = mod(p.z-16., 32.0) - 16.;\n        p.x = mod(p.x-16., 32.0) - 16.;\n        int buildingId = 0;\n        float building = buildingSDF(p, h, bid, buildingId, skip, o);\n        building /= 2.2;\n        SAMPLE(building, o, ID_BUILDING);\n    }\n\n    Object oBird = getBird();\n    oBird.p.y += h*2.;\n    int birdId = 0;\n    float bird = birdSDF(pointRot(p - oBird.p, oBird.q), skip, oBird, birdId);\n    SAMPLE(bird, oBird, birdId);\n\n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nvec3 concreteTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(176, 176, 176);\n    vec3 c2 = rgb(166, 166, 166);\n    vec3 c3 = rgb(126, 126, 126);\n    vec3 c4 = rgb(185, 181, 172);\n    \n    vec3 warp = snoiseWarp(uv, 0.0483815, 1.0, 32.0, 6, 0.7);\n    vec3 hf1 = snoise(uv, 5.49390182, 0.5, 64.0, 6);\n    vec3 lf1 = snoise(uv, 7.783843, 0.02, 8.0, 6);\n    float w = wnoise(uv*12., 6, 1.);\n    \n    vec3 bg1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 bg2 = mix4(c4, c3, c2, c1, hf1);\n    vec3 bg = (bg1 + bg2) * 0.5;\n    col = bg;\n    \n    vec3 spots = mix4(c1, c2, c3, c4, smoothstep(0.4, 0.7, warp));\n    col = mix(col, spots, w);\n    \n    float cracks = smoothstep(0.02, 0.3, abs((warp.z*2.0-1.0)-(hf1.x*2.0-1.0)));\n    float crackReg = smoothstep(0.4, 0.7, warp.y) * smoothstep(0.4, 0.7, lf1.x);\n    col = mix(col, col*cracks, crackReg);\n    \n    m.spec = clamp(crackReg-cracks, 0.0, 0.5);\n    m.z = clamp(0.5-(cracks*crackReg), 0.0, 1.0);\n    \n    \n    return col;\n}\n\nvec3 tarTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(65, 65, 65);\n    vec3 c2 = rgb(3, 3, 3);\n    vec3 c3 = rgb(28, 22, 19);\n    vec3 c4 = rgb(72, 72, 72);\n    vec3 c5 = rgb(193, 193, 193);\n    vec3 c6 = rgb(134, 134, 134);\n    \n    \n    vec3 hf1 = snoise(uv, 0.03892812, 0.1, 96.0, 6);\n    vec3 hf2 = snoise(uv, 6.69684324, 0.1, 86.0, 6);\n    vec2 vid = vec2(0.0);\n    float w = voronoi(uv*16., 4.4928123, vid);\n    float iw = max(0.0, 1.0-w);\n    \n    vec3 grain = abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0)));\n    \n    vec3 bg1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 bg2 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, hf1));\n    vec3 bg = (bg1+bg2)*0.5;\n    col = bg;\n    \n    vec3 fg1 = mix4(c4, c5, c6, c3, smoothstep(0.4, 0.7, hf2));\n    vec3 fg2 = mix4(c3, c6, c5, c4, hf2);\n    vec3 fg = (fg1+fg2)*0.5;\n    \n    col = mix(col, fg, iw);\n    \n    float rocks = iw*iw*iw*iw*iw*iw*iw*iw*iw*iw;\n    \n    m.spec = rocks*grain.x;\n    \n    m.z = clamp((0.6 - rocks)+ (0.2-((hf2.x+hf1.z)*0.01)), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoBuilding(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = vec3(0.0);\n    \n    if (dot(n, vec3(0, 1, 0)) > 0.45) {\n        uv *= 2.;\n        col = tarTexture(uv, p, data.m);\n        data.n = makeNormal(data.n, data.m.z, 0.5, 0.33);\n    } else {\n        col = concreteTexture(uv, p, data.m);\n        data.n = makeNormal(data.n, data.m.z, 0.15, 0.5);\n    }\n    \n    return col;\n}\n\n\nfloat featherPattern(in vec2 uv) {\n    float tile = 4.0;\n    \n    float col = 0.0;\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    vec2 id = floor(uv*tile);\n    \n    float ra1 = hash21Fast(id, id.x+id.y+4.43899123);\n    float ra2 = hash21Fast(id, id.x+id.y+7.44523234);\n    \n    float subtile = tile*2.;\n    \n    vec2 sublv = fract(uv*subtile);\n    vec2 subalv = abs(sublv*2.0-1.0);\n    vec2 subid = floor(uv*subtile)-(id*tile);\n    \n    col += smoothstep(0.48, 0.5, alv.x-0.5)*(1.0-smoothstep(0.0, 1.0, uv.y-0.2));\n    \n    float patternReg = 1.0;\n    vec2 start1 = vec2(0.0, 1.0);\n    vec2 end1 = vec2(1, 0);\n    \n    end1 += vec2(cos(ra1), sin(ra1))*ra1*0.5;\n    \n    vec2 start2 = vec2(1.0, 1.0);\n    vec2 end2 = vec2(0, 0);\n    \n    start2 += vec2(cos(ra2), sin(ra2))*ra2*0.5;\n    \n    vec2 start = mix(start1, start2, clamp(mod(subid.x, 2.), 0.0, 1.0));\n    vec2 end = mix(end1, end2, clamp(mod(subid.x, 2.), 0.0, 1.0));\n    \n    \n    col += line2D(sublv, start, end, 0.04) * patternReg * smoothstep(0.0, 1.0, alv.x);    \n    return col;\n}\n\n\nfloat randomLines0(in vec2 uv, in float a, in float seed, float i) {\n    uv *= rot(a);\n    \n    float v = 0.0;\n    float tile = 16.0;\n    \n    vec2 id0 = floor(uv*tile);\n    float seed0 = 3.2921983+seed;\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    lv = lv*lv*(3.0-2.0*lv);\n    float ra0 = mix(\n                    mix(hash21Fast(id0, seed0), hash21Fast(id0+vec2(1,0), seed0), lv.x),\n                    mix(hash21Fast(id0+vec2(0, 1), seed0), hash21Fast(id0+vec2(1,1), seed0), lv.x),\n                    lv.y);\n                    \n    uv *= rot(ra0);\n    lv = fract(uv*tile);\n    alv = abs(lv*2.0-1.0);\n    \n    v += line2D(alv, vec2(0, 0), vec2(1, 0), 0.1+(i*0.3));\n    \n    return v;\n}\n\nfloat randomLines(in vec2 uv, in float a, in float seed) {\n    float v = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    float freq = 0.5;\n    for (int i = ZERO; i < 3; i++) {\n        v += amp * randomLines0(uv*freq, a, seed, float(i)); div += amp; amp /= 2.0; freq *= 2.;\n        a += 0.1;\n        seed += 14.02321;\n    }\n    return clamp(v/(1.0+div*0.3), 0.0, 1.0);\n}\n\n//#define DEBUG_TEXTURE birdTexture\nvec3 birdTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n\n    // wings\n    vec3 w1 = rgb(193, 202, 209);\n    vec3 w2 = rgb(135, 140, 147);\n    vec3 w3 = rgb(144, 156, 166);\n    vec3 w4 = rgb(158, 169, 187);\n\n    // body \n    vec3 b1 = rgb(132, 141, 149);\n    vec3 b2 = rgb(115, 115, 111);\n    vec3 b3 = rgb(76, 70, 70);\n    vec3 b4 = rgb(85, 114, 157);\n\n    // rainbow stuff\n    vec3 c1 = rgb(229, 175, 191);\n    vec3 c4 = rgb(110, 178, 127);\n    \n    \n\n    float featherScale = 0.4;\n    float feather = featherPattern(uv*featherScale);\n    float featherShade = featherPattern((uv+vec2(0.02, 0.02))*featherScale);\n    feather *= (1.0 - smoothstep(0.57, 0.6, max(0.0, p.y)));\n    featherShade *= (1.0 - smoothstep(0.57, 0.6, max(0.0, p.y)));\n    feather = clamp(feather*6., 0.0, 1.0);\n    feather *= 0.0004;\n    featherShade *= 0.0004;\n    \n    vec3 hf1 = snoiseWarp(uv+feather, 0.00923812, max(0.0, 0.9-feather), 16.0, 6, 0.5);\n    vec3 lf1 = snoiseWarp(uv+feather, 5.58938456, max(0.0, 0.4-feather), 8.0, 6, 0.5);\n    vec3 grain = abs(normalize(cross(hf1*2.0-1.0, lf1*2.0-1.0)));\n    float lines = randomLines((uv+0.5*lf1.xz)*0.4, 0.5, 0.239123);\n   \n    \n    vec3 bodyCol1 = mix4(b1, b2, b3*feather, b4, hf1);\n    vec3 bodyCol2 = mix4(b4*feather, b3, b2, b1, hf1);\n    vec3 bodyCol = (bodyCol1 + bodyCol2) * 0.5;\n    col += bodyCol;\n    \n    vec3 wingCol1 = mix4(w1, w2, w3, w4, lf1);\n    vec3 wingCol2 = mix4(w4, w3, w2, w1, lf1);\n    vec3 wingCol = (wingCol1 + wingCol2) * 0.5;\n    \n    float wingArea = smoothstep(0.0, 0.3, abs(p.x+0.001)) * \n                     smoothstep(0.4, 0.5, max(0.0, -p.y+0.9999)) -\n                     smoothstep(0.01, 0.9, max(0.0, -p.y+0.6));\n    wingArea = clamp(wingArea, 0.0, 1.0);\n    col = mix(col, wingCol, clamp(wingArea*2., 0.0, 1.0));\n    \n    col = mix(col, col*col*0.8, featherShade*0.5);\n    col = mix(col, clamp(col+col, 0.0, 1.0), lines);\n\n    float yShift = 0.03;\n    float neckArea = smoothstep(0.39, 0.5, p.y-yShift)*smoothstep(0.34, 0.5, max(0.0, -(p.y-yShift)+0.97)) * \n                    smoothstep(0.39, 0.5, max(0.0, p.z+0.09));\n    neckArea *= max(0.0, 1.0-2.0*smoothstep(0.3, 1.0, p.y-0.002));\n                    \n    neckArea = clamp(neckArea*2., 0.0, 1.0);\n    \n    neckArea = max(0.0, neckArea - 0.003);\n    vec2 vid = vec2(0.0);\n    float w = voronoi(uv*12., 0.942812, vid)*neckArea;;\n    \n\n    vec3 rainbow1 = mix(c1, c4, 0.5+sin(p.y*80.)*0.5);\n    vec3 rainbow2 = mix(b4, c4, 0.5+cos(p.y*60.)*0.5);\n\n\n    vec3 rainbow = mix(rainbow1, rainbow2, smoothstep(0.4, 0.7, lf1.z));\n    rainbow = mix(rainbow, b4, w);\n\n    float rainbowArea = clamp(neckArea+(lines*lines*lines), 0.0, 1.0);\n    col = mix(col, rainbow, rainbowArea);\n\n    \n    m.z = clamp((0.5-(w*w*0.5*w)) + (0.5-feather), 0.0, 1.0);\n\n    m.spec = clamp(((1.0-(feather+w+(hf1.x*lf1.x)))*grain.x*grain.z*0.7)+(rainbowArea*rainbowArea), 0.0, 1.0);\n    m.spec /= (1.0+lines*3.);\n    return col;\n}\n\nvec3 getAlbedoBird(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    \n    uv /= (1.0 + 0.7*max(0.0, round(dot(n, vec3(0, 0, 1)))));\n\n    uv *= 8.;\n    vec3 col = birdTexture(uv, p, data.m);\n    data.n = makeNormal(n, data.m.z, 0.44, 0.33);\n    return col;\n}\n\nvec3 birdLegTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(221, 138, 149);\n    vec3 c2 = rgb(200, 50, 59);\n    vec3 c3 = rgb(172, 67, 78);\n    vec3 c4 = rgb(166, 139, 143);\n    \n    vec3 hf1 = snoise(uv, 0.0002313, 0., 64.0, 6);\n    vec3 hf2 = snoise(uv, 4.49289231, 0.0, 24.0, 6);\n    vec3 lf1 = snoise(uv, 6.69488345, 0.0, 6.0, 6);\n    \n    vec3 grain = abs(normalize(reflect(cross(hf1*2.0-1.0, hf2*2.0-1.0), lf1*2.0-1.0)));\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 col2 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, hf2));\n    \n    col = mix(col1, col2, smoothstep(0.4, 0.7, lf1.x));\n    \n    \n    float stripeY = fract(uv.y*6.);\n    stripeY = abs(stripeY*2.0-1.0);\n    \n    float stripe = 1.0-smoothstep(-0.34, 0.9, stripeY+(hf1.y*0.2));\n    stripe = mix(stripe, stripe*grain.x, smoothstep(0.19, 0.7, lf1.y));\n    \n    col = mix(col, col*col, stripe);\n    \n    m.z = clamp(0.5-(stripe*stripeY), 0.0, 1.0);\n    m.spec = clamp((stripe*grain.y)+(stripeY*lf1.y), 0.0, 1.0);\n\n    return col;\n}\n\n\nvec3 getAlbedoBirdLeg(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    uv *= 10.;\n    vec3 col = birdLegTexture(uv, p, data.m);\n    \n    data.n = makeNormal(data.n, data.m.z, 0.5, 0.5);\n    return col;\n}\n\nvec3 birdBeakTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(107, 110, 115);\n    vec3 c2 = rgb(70, 71, 69);\n    vec3 c3 = rgb(92, 56, 58);\n    vec3 c4 = rgb(23, 0, 0);\n\n    vec3 c5 = rgb(248, 243, 239);\n    vec3 c6 = rgb(195, 140, 110);\n    vec3 c7 = rgb(180, 170, 166);\n    vec3 c8 = rgb(182, 165, 158);\n    \n    vec3 hf1 = snoise(uv, 0.00029312, 0.0, 32.0, 6);\n    vec3 hf2 = snoise(uv, 5.5938425, 0.0, 48.0, 6);\n    vec3 warp = snoiseWarp(uv, 9.388435, 0.9, 24.0, 6, 0.55);\n    \n    float cracks = 1.0-smoothstep(0.01, 0.05, abs(warp.y-hf1.x));\n    cracks *= smoothstep(0.4, 0.7, hf2.x);\n    \n    vec3 bg1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 bg2 = mix4(c4, c3, c2, c1, hf1);\n    vec3 bg = (bg1 + bg2) * 0.5;\n    \n    vec3 fg1 = mix4(c5, c6, c7, c8, hf2);\n    vec3 fg2 = mix4(c8, c7, c6, c5, hf2);\n    vec3 fg = (fg1 + fg2) * 0.5;\n    \n    col += bg;\n    col = mix(col, col*col, cracks);\n    \n    float topArea = smoothstep(0.34, 0.8, max(0.0, dot(normalize(p), normalize(vec3(0, 1., -1.)))));\n    topArea = clamp(topArea*2., 0.0, 1.0);\n    \n    col = mix(col, fg, topArea);\n    \n    float cracks2 = smoothstep(0.4, 0.7, warp.y)*topArea;\n    \n    col = mix(col, col*col, cracks2);\n    \n    m.spec = clamp((cracks+cracks2)*2., 0.0, 1.0);\n    m.z = clamp((0.5-cracks) + (0.5-cracks2), 0.0, 1.0);\n    \n    return col;\n}\n\n\nvec3 getAlbedoBirdBeak(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    uv *= 14.;\n    vec3 col = birdBeakTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.5, 0.5);\n    return col;\n}\n\nvec3 birdEyeTexture(in vec2 uv, in vec3 p, in vec3 n, inout Material m) {\n    vec3 col = vec3(1.);\n    \n    vec3 c1 = rgb(159, 68, 25);\n    vec3 c2 = rgb(202, 115, 41);\n    vec3 c3 = rgb(199, 5, 23);\n    vec3 c4 = rgb(189, 86, 35);\n    \n    vec3 hf1 = snoise(uv, 0.023125, 0.0, 200., 6);\n    vec3 hf2 = snoise(uv, 5.594895, 0.0, 220., 6);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, smoothstep(0.4, 0.7, hf1));\n    vec3 col2 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, hf2));\n    col = mix(col1, col2, 0.5);\n    \n    float pupilR = 0.006;\n    float pupilF = pupilR*0.01;\n    \n    m.lum = 0.9;\n\n    float pupil = 1.0-smoothstep(pupilR-pupilF, pupilR+pupilF, length(uv-vec2(0.003, 0.))); \n\n    col = mix(col, vec3(0.), pupil);\n    \n    float blink = mod(T, 4.);\n    \n    col = mix(col, vec3(0.0), clamp(smoothstep(0.0, 0.4, blink-3.6)*2., 0.0, 1.0));\n    \n    return col;\n}\n\n\nvec3 getAlbedoBirdEye(inout Data data) {\n    vec3 p = pointRot(vec3((data.p.x), data.p.y, data.p.z) - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = p.zy;\n    vec3 col = birdEyeTexture(uv, p, n, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_BIRD: return getAlbedoBird(data); break;\n        case ID_BIRD_LEG: return getAlbedoBirdLeg(data); break;\n        case ID_BIRD_BEAK: return getAlbedoBirdBeak(data); break;\n        case ID_BIRD_EYE: return getAlbedoBirdEye(data); break;\n        case ID_BUILDING: return getAlbedoBuilding(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    depth = 1.0;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = LIGHT_SUN; \n    \n    raycast(data, lights, true, col, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    col += smoothstep(0.001, 1.0, depth)*max(0.0, 1.0 - smoothstep(0.0, 0.25, dotup));\n    \n    return col;\n}\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -1.5);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    float y = getBuildingHeight(ro)*2.;\n    y -= 0.1;\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        Object bird = getBird();\n        float ra = 1.0;\n        float fe = ra*0.5;\n        vec3 dirBird = normalize(bird.p - ro);\n        ro -= dirBird*(1.0-smoothstep(ra-fe, ra+fe, distance(ro.xz, bird.p.xz)));\n    } else {\n        ro.z -= 0.5;\n        ro.y += 0.45;\n        \n        Object bird = getBird();\n        float ra = 1.0;\n        float fe = ra*0.5;\n        ro.z -= (1.0-smoothstep(ra-fe, ra+fe, distance(ro.xz, bird.p.xz)));\n        rd = look(uv, vec3(bird.p.x+(0.08*sin(T*0.5)), 0.01+(bird.p.y*0.33)+(0.08*cos(T*0.5)), bird.p.z), ro);\n    }\n    \n    ro.y += y;\n    ro.y = max(y, ro.y);\n    \n    return Ray(ro, rd);\n}\n\nvec4 blit(in vec2 fc) {\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    O = blit(fc);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime*1.2)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define PLS_NO_UNROLL (iFrame != -34)\n\n\n#define FORWARD_DECL\\\n    float sdf(inout Data data, in vec3 p) { return FAR; }\\\n    vec3 getAlbedo(inout Data data) { return vec3(0.0); }\\\n    vec3 getSky(in vec3 rd) { return vec3(0.0); }\n\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.0007\n#define AMBIENT 0.10\n#define NUM_LIGHTS 1\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, -1.), vec3(0.0), COLOR_SUN, 4.0, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1., NEW_MATERIAL, NEW_OBJECT)\n\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd);\n#endif\n\n\n// Utilities\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(1.0-length(pa - ba * h)/t, 0.0, 1.0);\n}\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nfloat sclamp(in float v, in float mi, in float ma, in float k) {\n    return smin(smax(v, mi, k), ma, k);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\nvec3 pointRotInv(in vec3 p, in vec3 r) {\n    p.xz *= inverse(rot(r.y));\n    p.yz *= inverse(rot(r.x));\n    return p;\n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Noise functions\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    }\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\n\nfloat hash21Fast(in vec2 p, in float seed) {\n    vec2 p2 = fract(p*10.238128523)-dot(p, vec2(seed+1.828821, seed+0.832821));\n    float r1 = fract(dot(p, p2)*10.283821421);\n    return fract(10.8238281*sin(r1*6.28) * dot(p-p2, vec2(5.5838313, 7.834813)));\n}\n\nfloat snoiseFast(in vec2 p, in float seed) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21Fast(id, seed), hash21Fast(id + vec2(1, 0), seed), lv.x),\n        mix(hash21Fast(id + vec2(0, 1), seed), hash21Fast(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nfloat voronoi(in vec2 p, in float seed, out vec2 id){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j <= 1 && PLS_NO_UNROLL; j++){\n        for(int i=-1; i <= 1 && PLS_NO_UNROLL; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                id = offset;\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    int steps = SHADOW_STEPS;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = 0.00003;\n    float r = 0.5;\n    float count = 0.0;\n    float tot = 0.0;\n    for (int i = ZERO; i < steps && d < far; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        tot += abs(next)/0.56;\n        r = min(r, next/max(-0.5, 0.38*d));\n        d += clamp(next, 0.003, 0.9283);\n        count += 1.0;\n        if (r < -0.02) break;\n    }\n    float kk = max(0.0, 1.0-(max(0.0, FAR-tot)/ FAR));\n    float negDist = max(0.0, -r);\n    float dd = d / (1.0 + d + negDist);\n    float s1 = clamp((r*dd), AMBIENT, 1.0);\n    float s2 = clamp(tot / (0.559231+dd), AMBIENT, 1.0);\n    return clamp((s1+(s2*0.33))*(0.5+kk*0.88), AMBIENT, 1.0);\n}\nfloat getShadowXX(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip)\n{\n    float NdotL = cdot(n, rd);\n    if (length(n) <= 0.0001 || length(rd) <= 0.0001) return AMBIENT;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = 0.0003;\n    float t = NEAR;\n    float r = 0.5;\n    for (int i = 0; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/(0.44*t));\n        t += clamp(next, 0.002, 0.909283);//clamp(next, 0.1, 0.50);\n        d += next;\n        if (r < -0.5 || next < -0.5 || d >= far) break;\n    }\n    \n    float neg = max(0.0, -d);\n    neg = max(neg, max(0.0, -r));\n    neg = max(neg, max(0.0, -t));\n    \n    r = max(r, -0.5);\n    d = max(d, -0.5);\n    t = max(t, -0.5);\n    \n    float dd = d / (1.0 + d);\n    r = r+(dd*0.77);\n    return clamp(r, AMBIENT, 1.0);\n}\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = data.m.lum > 0.5 ? 1.0 : getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    \n    return (diffuse + spec) * max(att * shadow, diffuse * data.m.lum); \n}\n\nbool raycast(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}","name":"Common","description":"","type":"common"}]}