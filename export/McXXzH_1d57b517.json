{"ver":"0.1","info":{"id":"McXXzH","date":"1704927548","viewed":471,"name":"Interactive Particles","username":"berelium","description":"An interactive particle system. Has a toggleable attractor in the center, and mouse interaction. All settings can be controlled in the Common tab! Ideally would like to optimize this as the rendering is extremely inefficient relative to the actual sim...","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["mouse","particles","physics","particle","multipass","gpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P_ITERATOR int(floor(sqrt(float(NUM_PARTICLES))))+1\n\n\n// The number of particles can be modified in common.\n// If your computer is struggling, you can use the Shadertoy Unnoficial plugin to lower the resolution (ALT + 1-9),\n// where each number is a screenspace division. Ex (ALT + 2) == iResolution / 2.0\n\n// NOTE: This method is not practical in a standalone GLSL implementation.\n//       This was made to work in shadertoy, and is not efficient as it needs \n//       to iterate thousands of particles on each pixel of the screen.\n//       ===\n//       A more realistic implementation would be a vertex shader calculating positions/velocities \n//       on a fixed buffer of particles. Then a fragment shader could simple iterate the buffer and \n//       render the particles.\n\n// Thanks to iq for the hsl/hsv functions!\n// https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\nvec3 render( in vec2 uv ) {\n    vec3 color = vec3(0.01), col;\n    float c, mag;\n\n    vec4 currParticle;\n    vec2 particlePos;\n    // Iterate over a grid of particles to render\n    for(int y = 0; y < P_ITERATOR; y++) {\n        for(int x = 0; x < P_ITERATOR; x++) {\n            // Grab a particle\n            currParticle = texelFetch(iChannel0, ivec2(x, y), 0);\n            particlePos = uv - currParticle.xy;\n            particlePos.x *= ASPECT;\n            \n           \n            // Calculate magnitude of the particle\n            mag = (currParticle.z * currParticle.z + currParticle.w * currParticle.w) * 0.000000625;\n            \n           \n            // Derive a color based on magnitude\n#ifdef ATAN_COLOR\n            // Use polar coordinates based on the velocity to choose a hue\n            // Normalize velocity???\n            float r = atan(currParticle.w, currParticle.z);\n            r += PI * 1.5;\n            col = hsl2rgb( vec3(((r / PI) / 2.0), mag + 0.45, mag + 0.11));\n#else \n            // Simple red-green scale\n            col = hsl2rgb(vec3(((mag / MAX_SPEED * MAX_SPEED) * 2.5), 0.6, max(0.25, mag)));\n#endif\n            \n            // Use distance field to make a glow effect @alro\n            c = 1. / length(particlePos);\n            c *= PARTICLE_SIZE; // Radius\n            c = pow(c, INTENSITY); // Intensity\n            \n            color += c * col;\n        }\n    }\n    \n    // Render center attractor\n#ifdef CENTER_ATTRACTOR\n    vec2 attractor = uv - vec2(0.5);\n    attractor.x *= ASPECT;\n    c = 1. / length(attractor);\n    c *= PARTICLE_SIZE * 10.; // Radius\n    c = pow(c, INTENSITY); // Intensity\n\n    color += c * vec3(0.5);\n#endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = render(uv);\n    \n    // Contrast + ACES tonemap + Gamma\n    col = ((col - 0.5) * CONTRAST) + 0.5;\n    col = (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14);\n    col = ltos3(col.r, col.g, col.b);\n    col = pow(col, vec3(1.0 / GAMMA));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ASPECT iResolution.x / iResolution.y\n#define PI 3.14159265359\n\n/* Some notes:\n   = If wrap edges isn't defined, the particles will bounce off the edges with some random velocity\n   = Center attractor is a constant force in the middle of the screen for particles to gravitate around\n   = Num of particle is not exact, but close. It gets floor-sqrted and +1 later for reading from the buffer. AKA 1500 == 1521 (39*39)\n   = Gravity is a vec2 here because you can apply gravity in any direction\n   = Attraction is used for the mouse and the center attractor\n   = Bounce is for if wrap edges is off, for colliding with walls\n   = Max speed is the max speed a particle can reach, before being limited\n   = Intensity is for the intensity of light around each particle\n   = dt is the simulation step time\n*/\n#define WRAP_EDGES\n#define CENTER_ATTRACTOR\n// Adjust number of particles if its too laggy (or bump it up if you are cool)\n#define NUM_PARTICLES 1000\n#define PARTICLE_SIZE 0.0005 * ASPECT\n#define GRAVITY vec2(-0.0, -0.0)\n#define ATTRACTION 8.0\n#define BOUNCE 0.4\n#define MAX_SPEED 600.\n#define dt iTimeDelta * 0.001\n\n\n#define ATAN_COLOR\n#define INTENSITY 1.9\n#define CONTRAST 1.04\n#define GAMMA 1.6\n\n\n//----------------------------------------------------------------------------------------\n// Hash without sine ( https://www.shadertoy.com/view/4djSRW ); Thanks Dave!\n//----------------------------------------------------------------------------------------\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 calculateVelocity( in vec2 particlePos ) {\n    vec2 center = vec2(0.5);\n    vec2 direct = normalize(center - particlePos);\n    \n    float angle = atan(direct.y, direct.x);\n    angle *= PI;\n    \n    float speed = 0.5;\n    return speed * MAX_SPEED * vec2(cos(angle), sin(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Initialize the buffer with random positions and zeroed velocity\n    if(iFrame < 5) {\n        vec2 pos = hash22(uv.yx);\n        // vec2 vel = vec2(0.0, -hash12(uv) * MAX_SPEED);\n        vec2 vel = calculateVelocity(pos);\n        fragColor = vec4(pos, vel);\n        return;\n    }\n    \n    // Grab the previous states\n    vec4 previousState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 position = previousState.xy;\n    vec2 velocity = previousState.zw;\n    \n    \n    // Apply simple gravity force\n    velocity += GRAVITY;\n    \n    \n    // Check if L-Mouse is pressed\n    if(iMouse.z > 0.01)\n    {\n    \tvec2 mV = (iMouse.xy/iResolution.xy) - position;\n        float d = length(mV);\n    \n        // Apply attracation force\n        velocity += ATTRACTION * 5.0 / PI * normalize(mV);\n        //velocity += (mV / d) / pow(max(d, 2.0) / ATTRACTION, 2.0);\n    }\n    \n  \n    // Center gravity point\n#ifdef CENTER_ATTRACTOR\n    vec2 v = vec2(0.5) - position;\n    float d = length(v);\n    velocity += (v / d) / pow(max(d, 2.0) / ATTRACTION, 2.0);\n#endif\n  \n  \n    // Edge handling    \n#ifdef WRAP_EDGES\n    position = fract(position);\n#else\n    \n    if(position.x - PARTICLE_SIZE < 0.0) { // Left\n        position.x = PARTICLE_SIZE;\n        velocity.x = abs(velocity.x) * BOUNCE;\n    }\n    if(position.y + PARTICLE_SIZE > 1.0) { // Up\n        position.y = 1.0 - PARTICLE_SIZE;\n        velocity.y = -abs(velocity.y) * BOUNCE;\n    }\n    if(position.x + PARTICLE_SIZE > 1.0) { // Right\n        position.x = 1.0 - PARTICLE_SIZE;\n        velocity.x = -abs(velocity.x) * BOUNCE;\n    }\n    if(position.y - PARTICLE_SIZE < 0.0) { // Down\n        position.y = PARTICLE_SIZE;\n        velocity.y = abs(velocity.y) * BOUNCE;\n    }\n#endif\n\n    \n    // Update position with velocity and timestep\n    position += velocity * dt;\n    \n    \n    // Limit the particle if its moving too fast\n    if( length(velocity) > MAX_SPEED ) {\n        velocity = normalize(velocity) * MAX_SPEED;\n    }\n    \n    \n    // Update position and velocity\n    fragColor = vec4(position, velocity);\n}","name":"Buffer A","description":"","type":"buffer"}]}