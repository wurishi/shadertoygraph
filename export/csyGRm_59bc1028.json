{"ver":"0.1","info":{"id":"csyGRm","date":"1678368468","viewed":154,"name":"\"Origins of Magnetism\" 3","username":"Amirk","description":"An illustration of how the electric landscape looks like to an observer moving inside a solenoid. The strength of the electric force by each charge is represented by its brightness. Get a retarded (finite speed of info) view pressing SPACE.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["relativity","lorentz","electricity","magnetism","retardation","solenoid"],"hasliked":0,"parentid":"DlBSRG","parentname":"\"Origins of Magnetism\" 2"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThere are equal positive and negative cylindrical currents\nmoving in the opposite directions. \n\nPress W to move forward.\n-->The electric fields of particles get transformed (squashed and rotated)\n-->relative to you \n        -->positive charge-density increases on the front right \n            and decreases on the front left \n        -->negative charge-density decreases  on the front right \n            and increases on the front left \n\nTherefore the \"electric landscape\" is quite different in this a moving frame. \nIn particular there is a charge-gradient from right to left.\n\n\nIN GENERAL:\n\nIn Classical Electrodynamics\nmagnetism can be seen as a relativistic effect of electricity\n(at least as long as magnetic monopoles are not found). \n\nIn principle, since magnetic forces depend on the particles velocity,\nwe never need to account for any magnetic forces\nif we stay in the intantaneous rest frame of the moving particle.\n\nOf course in practice many things are easier to understand and calculate\nin a lab frame with both electric and the magnetic fields.\n*/\n\n#define MAX_ITER 600.+RETARD*1000.\n#define MAX_DIST 100.+RETARD*300.\n#define SURF .01\n\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\n//vec4 boost=vec4(0,0,0,0);\n//vec3 orientation=vec3(1,0,0);\nfloat dO;\n\n\n//retardation effect ON/OFF:\nfloat RETARD = 1.;\n//ray origin in the moving coords.\nvec4 RO, RD;\nvec2 m;\nmat4 TransformMatrix;\n\nvec3 col = vec3(0);\n\n\nconst float SIZE=.99 ;\n\nconst float radius=40.;\nconst float speed=.99 ;\nvec3 initVel=vec3(0,0,speed);\nvec3 initVel2=vec3(0,0,-speed);\n\nvoid updateVel(){\n    // Fetch the fourvelocity from the Buffer A\n    //boost= texelFetch( iChannel0, ivec2(5,5), 0);\n    // orientation=texelFetch( iChannel0, ivec2(6,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the fourposition from the Buffer B\n    \n    position =texelFetch( iChannel1, ivec2(0,0), 0 );\n    vec4 cam=vec4(-0,0,0,0);\n    if(m!=vec2(0)){\n        cam.xy*=rot((m.y-.5)*PI);\n        cam.xz*=rot(-(m.x-.5)*2.*PI);    \n    }\n    position+=TransformMatrix*cam;\n}\n\n\nfloat nonRetardedField(vec4 displ, vec3 v){\n    \n    float beta = length(v)/c;\n    float c = dot(normalize(displ.xyz),normalize(v));\n    float proj = sqrt(1.-c*c);\n    //I commented out the inverse square for artistic purposes\n    float E=abs(100.*(1.-beta*beta)/pow(1.-proj*proj*beta*beta,1.5));//dot(displ.xyz,displ.xyz));\n  \n    \n    return E;\n}\n\n\n//this controls the local shape of the particle\nfloat sdElectrons(vec4 q){\n   \n    float omega=speed/radius;\n    \n    q.xz*=rot(-q.w*omega);\n    \n    q.xz*=rot(-floor(atan(q.z,q.x)*10.)*.1-.08);\n    \n    q.y-=2.5; \n    q.x-=radius;\n    \n    q.y=fract(q.y*.2)*5.-2.5;\n   \n    //q=Lorentz(initVel*.5)*vec4(q.xyz,0);\n    \n    q.z*=gamma(initVel*.8);\n    float d=length(q.xyz)-SIZE;\n    // eHalo+= 1.*strength/(.1+.1*d*d)/(1.+1.1*length(q.xyz));\n    \n    return  d*.3;\n}\n\n\nfloat sdPositrons(vec4 q){\n    \n     float omega=speed/radius;\n         \n     q.xz*=rot(q.w*omega);\n    \n     q.xz*=rot(-floor(atan(q.z,q.x)*10.)*.1-.08);\n    \n     \n     q.y+=0.;  \n     q.x-=radius;\n     q.y=fract(q.y*.2)*5.-2.5;\n    \n    //q=Lorentz(initVel2*.5)*vec4(q.xyz,0);\n    q.z*=gamma(initVel2*.8);\n    float d=length(q.xyz)-SIZE;\n   // pHalo+= 1.*strength/(.1+.1*d*d)/(1.+1.1*length(q.xyz));\n    \n    return d*.3;\n}\n\n\nfloat sdGrid(vec4 q){\n    q.y+=10.;\n    float b=.1;\n    q.xz=fract(q.xz*.1)*10. -5.; //this creates the grid of reference cubes    \n    return  min(length(q.yz)-b,length(q.xy)-b)/gamma(fourvel.xyz/fourvel.w); //length(p.xyz)-rad; \n}\n\nfloat getDist(vec4 q){\n    float de= sdElectrons(q);\n    float dp =sdPositrons(q);\n    float dist=min(de,dp);   \n     \n     \n    return min(dist, sdGrid(q));\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n     // halo+= .01*dS/(.1+ dS*dS);\n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n    return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\n//this controls the global constellation&color of the particles\nvoid getMaterial(vec4 q){\n    vec4 qq=q;\n    qq-= position;\n    qq=inverse(TransformMatrix)*vec4(qq.xyz,0); //qq;\n    \n    \n    if(sdElectrons(q)<SURF*10.){\n    \n        col=vec3(.01,.01,.8);         \n        \n        \n        float E=abs(nonRetardedField(qq,initVel));\n        \n        //some scalings for better visual effects\n        E/=1.*length(qq.xyz); \n        col/=fourvel.w*1.;\n        float gamma=gamma(initVel);\n        col*=(gamma-.9)*(gamma-.9);\n        col*=E*E;\n        \n        col.rg=clamp(col.rg,0.,.4);\n        col.b=clamp(col.b,0.05,1000.);\n       \n    }\n    else if(sdPositrons(q)<SURF*10.){\n        col=vec3(.9,.01,.01);\n              \n         \n        float E=abs(nonRetardedField(qq,initVel2));\n        \n        //some scalings for better visual effects\n        E/=1.*length(qq.xyz); \n        col/=fourvel.w*1.;\n        float gamma=gamma(initVel2);\n        col*=(gamma-.9)*(gamma-.9);\n        col*=E*E;\n      \n        col.gb=clamp(col.gb,0.,.4);\n        col.r=clamp(col.r,0.05,1000.);\n    }\n    else{\n        col= vec3(0,.5,0);\n        col/=(1.+.0005*dot(qq.xyz,qq.xyz));\n    }\n}\n\n\nmat4 getTransform(){\n    mat4 M= mat4(1,0,0,0,\n                 0,1,0,0,\n                 0,0,1,0,\n                 0,0,0,1);\n    if(iFrame>10){\n        for(int i=1; i<=4; i++)\n           for(int j=1; j<=4; j++)\n              M[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n    }\n    return M;\n}\n\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 position = vec2(.0,.9);\n    float FontSize = 6.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n   C(85);C(115);C(101);\n   C(32);\n   \n   C(87);C(65);C(83);C(68);\n   C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);\n   float beta= length(fourvel.xyz)/c;\n   float gamma = pow(1.-beta*beta,-.5);\n   C(115);C(112);C(101);C(101);C(100);C(32);\n   C(46);C(48+int(floor(10.*length(fourvel.xyz)/fourvel.w/c))); C(99);\n   \n   U=( uv - position)*64.0/FontSize+vec2(0,1);\n   \n   \n   C(82+32);C(69+32);C(84+32);C(65+32);C(82+32);C(68+32);\n    C(32);\n   if(RETARD==0.){\n      C(79);C(70);C(70);\n      }\n   else{\n      C(79);C(78);\n      }\n      \n    col.xyz+=.8*O.xxx;\n}\n\n\nvoid transformVel(vec4 pos){\n    \n   // float y=sin(atan(rd.z,rd.x))*dO*cos(atan(rd.y,length(rd.xz)));  \n   // float angle= -asin(y/radius);    \n    \n    \n    //rotate velocity to be tangential:\n   \n    pos.xyz=normalize(pos.xyz)*speed;\n    \n        initVel.xz=vec2(pos.z,-pos.x);\n        vec4 init4vel=Lorentz(initVel)*vec4(0,0,0,1);\n        vec4 transformedVel=inverse(TransformMatrix)*init4vel;\n        initVel=transformedVel.xyz/transformedVel.w;\n        \n        initVel2.xz=-vec2(pos.z,-pos.x);  \n        vec4 init4vel2=Lorentz(initVel2)*vec4(0,0,0,1);\n        vec4 transformedVel2=inverse(TransformMatrix)*init4vel2;\n        initVel2=transformedVel2.xyz/transformedVel2.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    \n    RETARD*=texelFetch(iChannel3, ivec2(32, 0), 0).x; \n    \n    updateVel();\n    //coordinate transform:  \n    TransformMatrix=getTransform();\n    updatePos();\n    \n    \n   \n        \n        \n        \n    \n    //ray's spacetime origin represented in \"stationary coordinates\":\n    RO=position-vec4(38,0,0,0);\n    float zoom= 1.;\n    \n    //four-direction in our moving coords:\n    vec4 lookAt;\n    if(RETARD>0.) //what we actually see as light reaches our eyes:\n        lookAt = vec4(c, 0, 0, -1);\n    else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(c, 0, 0, 0);\n    \n    \n    \n    if(m!=vec2(0)){\n        lookAt.xy*=rot((m.y-.5)*PI );\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }else{\n        lookAt.xy*=rot(-1.-1.8*smoothstep(0.,2.,iTime-11.));\n        lookAt.xz*=rot(0.);\n    }\n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n    \n    \n    //ray direction from moving coords to stationary coords:\n    RD= TransformMatrix*ray; \n    \n    \n       \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    float d= RayMarch(p, RD, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*RD;\n          \n          //particle velocities from the point of view of the moving observer\n          transformVel(p); \n          \n          //coloring according to the strength of the field\n          getMaterial(p);\n\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(-0,2,0)))*.4+.5;\n         // col=max(col*.5,col/length(d*RD)/.2);\n          col*=dif*dif;    \n       \n                \n    }\n\n    text(fragColor, fragCoord);\n\n    fragColor = vec4(col,1.0);\n       \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n\n\n#define t float(iFrame)/frames\n#define PI 3.14159265359\n\nconst float c=1.;//I have not made sure everything works if you change c.\n\nfloat beta(vec3 vel){\n     return   length(vel)/c;   \n}\n\nfloat gamma(vec3 vel){\n     float beta= beta(vel);\n     return  pow(1.-beta*beta,-.5);   \n}\n\nmat4 Lorentz(vec3 v){\n     \n     float gamma = gamma(v);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, 0, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 0, 1., 0, 0,\n                 (gamma-1.)*v.z*v.x/v2, 0, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, 0, -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\n/*\nvec3 velAdd(vec3 v, vec3 u){\n    float beta= length(v)/c;;   \n    float gamma=pow(1.-dot(beta,beta),-.5);\n        \n    \n    return 1./(1.+dot(u,v)/(c*c))*( v-u/gamma+gamma/(c+c*gamma)*dot(u,v)*v );   \n}\n\n\nmat4 F(vec3 E, vec3 B){\n    return mat4(0, -E.x, -E.y,-E.z,\n                E.x,  0, -B.z, B.y,\n                E.y, B.z,   0,-B.x,\n                E.z, -B.y, B.x,  0);\n}\n\n*/\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\nconst float dt = .05;\n\nvec2 m;\n\nvec3 handleKeyboard() {     \n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration=(left +up + right +down ) +vec3(1, 0,0)*.1*smoothstep(4.,0.,abs(t-6.))-vec3(1, 0,0)*.1*smoothstep(4.,0.,abs(t-26.));\n   \n    // steer with mouse\n      //  acceleration.xy*=rot((m.y-.5)*PI);\n        acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration*c*.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinates of the boost are in rockects coordinates\n    vec3  boost=vec3(0,0,0);\n    vec3 orientation=vec3(1,0,0);\n    \n    boost = handleKeyboard();\n    orientation = texelFetch( iChannel0, ivec2(6, 6), 0).rgb;\n    \n    \n    //orientation is for the rockets alignment\n    orientation +=(boost-orientation)*.01;\n    if(ivec2(fragCoord)==ivec2(6,6))\n             fragColor= vec4(orientation,0);\n             \n    //this will transform coordinates from rockets frame to stationary\n    mat4 TransformMat = mat4(1,0,0,0,\n                        0,1,0,0,\n                        0,0,1,0,\n                        0,0,0,1);\n                                           \n    \n    if(boost==vec3(0)){ //if no keys are pressed we just copy from the previous frame\n        \n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(5, 5), 0).rgb,0);\n        }\n        if(iFrame<10){\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 vec4 fourvel = TransformMat*vec4(0,0,0,1); \n                 fragColor= fourvel;          \n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(boost,0);\n            }else if(ivec2(fragCoord)==ivec2(6,6)){\n            fragColor= vec4(orientation,0);\n            }\n            for(int i=1; i<=4; i++)\n                if(ivec2(fragCoord)==ivec2(i,i))\n                    fragColor.r=1.;\n        }\n    }else{\n        //boost/= texelFetch( iChannel0, ivec2(0, 0), 0).w;\n        //next the boost transform\n        mat4 NextBoost= Lorentz(-boost*dt);\n                        \n        if(iFrame>10){\n            for(int i=1; i<=4; i++)\n                for(int j=1; j<=4; j++){\n                     TransformMat[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n                 }  \n        }\n    \n        //how to transform to stationary coords\n         TransformMat=TransformMat*NextBoost;\n\n        vec4 fourvel =TransformMat*vec4(0,0,0,1);\n        \n        if(ivec2(fragCoord)==ivec2(0,0)){\n              \n             fragColor= fourvel;          \n        }else if(ivec2(fragCoord)==ivec2(5,5)){\n             fragColor= vec4(boost,1);\n        }else{\n            //StoreMatrix:\n            for(int i=1; i<=4; i++)\n                for(int j=1; j<=4; j++)\n                    if(ivec2(fragCoord)==ivec2(i,j)){\n                        fragColor.r=TransformMat[i-1][j-1];\n                        }\n        }\n     }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n//proper time -step:\nconst float dt=.05;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // four position represented in stationary coords:\n    vec4 pos = texelFetch( iChannel1, ivec2(0, 0), 0);\n   \n    // fourvel represented in stationary coords:\n    vec4 fourvel = texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n   // float gamma=fourvel.w/c;\n    \n    \n    \n    //four position represented in stationary coordinates:\n    pos += fourvel*dt;\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = pos;\n}","name":"Buffer B","description":"","type":"buffer"}]}