{"ver":"0.1","info":{"id":"llGGRG","date":"1475109560","viewed":223,"name":"Daltonize","username":"daeken","description":"Test shader for daltonizing images.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","colorblindness","daltonize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ distance-2d ]\n\n:globals\n\ttrue =>shadertoy\n\t\t{\n\t\t\t@vec3 uniform =iResolution @float uniform =iTime\n\t\t\tiResolution .xy =>resolution\n\t\t\tiTime =>time\n\t\t}\n\t\t{\n\t\t\t@vec2 uniform =R @float uniform =T\n\t\t\tR =>resolution\n\t\t\tT =>time\n\t\t}\n\tshadertoy cif\n;\n\nresolution frag->position =p\n\n: distance-field ( p:vec2 -> vec4 )\n\t[\n\t\t[ p [ .9 0 ] + time 60 * rotate-deg [ .2 .2 ] ubox ##f00 ]\n\t\t[ p time 60 * rotate-deg [ .2 .2 ] ubox ##0f0 ]\n\t\t[ p [ .9 0 ] - time 60 * rotate-deg [ .2 .2 ] ubox ##00f ]\n\t] matunion\n;\n\n:m background\n\t[\n\t\tp .x -.45 < { ##0f0 }\n\t\tp .x .45 > { ##ff0 }\n\t\t{ ##f00 }\n\t] cond\n;\n\n:m texture ( d )\n\t\tbackground\n\t\td .yzw\n\t\t.01 d .x - 500 * 0 1 clamp\n\tmix\n;\n\n: daltonize ( c:vec3 -> vec3 )\n\t[\n\t\t[ 0.0 2.02344 -2.52581 ]\n\t\t[ 0.0 1.0      0.0 ]\n\t\t[ 0.0 0.0      1.0 ]\n\t] =>protanope\n\n\tprotanope =>[ cvda cvdb cvdc ] ( Select appropriate type of color blindness )\n\n\t[\n\t\t[ 17.8824 43.5161 4.11935 ] c * \\+\n\t\t[ 3.45565 27.1554 3.86714 ] c * \\+\n\t\t[ 0.0299566 0.184309 1.46709 ] c * \\+\n\t] =LMS\n\n\t[\n\t\tcvda LMS * \\+\n\t\tcvdb LMS * \\+\n\t\tcvdc LMS * \\+\n\t] =LMS\n\n\tc [\n\t\t[ 0.0809444479 -0.130504409 0.116721066 ] LMS * \\+\n\t\t[ -0.0102485335 0.0540193266 -0.113614708 ] LMS * \\+\n\t\t[ -0.000365296938 -0.00412161469 0.693511405 ] LMS * \\+\n\t] - =NC\n\n\t[\n\t\t0\n\t\t[ .7 1 0 ] NC * \\+\n\t\t[ .7 0 1 ] NC * \\+\n\t] =error\n\n\tc error + 0 1 clamp\n;\n\n:m apply-filter ( $c )\n\t\tc\n\t\tc daltonize\n\t\t1 1 time 4 + sin - 2 ** - 3 * p .x - 0 1 clamp\n\tmix\n;\n\np distance-field texture apply-filter ->fragcolor\n*/\n\nvec2 rotate_02d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec4 distance_1field(vec2 p) {\n\tvec4 macro_temp_34_a = vec4(length(max(abs(rotate_02d(p + vec2(.9, 0.), iTime * 60. * .017453)) - .2, 0.)), 1., 0., 0.);\n\tvec4 macro_temp_34_b = vec4(length(max(abs(rotate_02d(p, iTime * 60. * .017453)) - .2, 0.)), 0., 1., 0.);\n\tmacro_temp_34_a = (macro_temp_34_a.x == min(macro_temp_34_a.x, macro_temp_34_b.x) ? macro_temp_34_a : macro_temp_34_b);\n\tmacro_temp_34_b = vec4(length(max(abs(rotate_02d(p - vec2(.9, 0.), iTime * 60. * .017453)) - .2, 0.)), 0., 0., 1.);\n\treturn (macro_temp_34_a.x == min(macro_temp_34_a.x, macro_temp_34_b.x) ? macro_temp_34_a : macro_temp_34_b);\n}\nvec3 daltonize(vec3 c) {\n\tvec3 var_1 = vec3(17.8824, 43.5161, 4.11935) * c;\n\tvec3 var_2 = vec3(3.45565, 27.1554, 3.86714) * c;\n\tvec3 var_3 = vec3(.029957, .184309, 1.46709) * c;\n\tvec3 LMS = vec3(var_1.x + var_1.y + var_1.z, var_2.x + var_2.y + var_2.z, var_3.x + var_3.y + var_3.z);\n\tvec3 var_5 = vec3(0., 2.02344, -2.52581) * LMS;\n\tvec3 var_6 = vec3(0., 1., 0.) * LMS;\n\tvec3 var_7 = vec3(0., 0., 1.) * LMS;\n\tLMS = vec3(var_5.x + var_5.y + var_5.z, var_6.x + var_6.y + var_6.z, var_7.x + var_7.y + var_7.z);\n\tvec3 var_8 = vec3(.080944, -.130504, .116721) * LMS;\n\tvec3 var_9 = vec3(-.010249, .054019, -.113615) * LMS;\n\tvec3 var_10 = vec3(-.000365, -.004122, .693511) * LMS;\n\tvec3 NC = c - vec3(var_8.x + var_8.y + var_8.z, var_9.x + var_9.y + var_9.z, var_10.x + var_10.y + var_10.z);\n\tvec3 var_12 = vec3(.7, 1., 0.) * NC;\n\tvec3 var_13 = vec3(.7, 0., 1.) * NC;\n\tvec3 error = vec3(0., var_12.x + var_12.y + var_12.z, var_13.x + var_13.y + var_13.z);\n\treturn clamp(c + error, 0., 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 temp_41;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tif(p.x < -.45) {\n\t\ttemp_41 = vec3(0., 1., 0.);\n\t} else if(p.x > .45) {\n\t\ttemp_41 = vec3(1., 1., 0.);\n\t} else {\n\t\ttemp_41 = vec3(1., 0., 0.);\n\t}\n\tvec3 macro_apply_2filter_c = mix(temp_41, distance_1field(p).yzw, clamp((.01 - distance_1field(p).x) * 500., 0., 1.));\n\tfragColor = vec4(mix(macro_apply_2filter_c, daltonize(macro_apply_2filter_c), clamp((1. - pow(1. - sin(iTime + 4.), 2.)) * 3. - p.x, 0., 1.)), 1.);\n}\n","name":"Image","description":"","type":"image"}]}