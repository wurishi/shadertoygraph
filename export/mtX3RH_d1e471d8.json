{"ver":"0.1","info":{"id":"mtX3RH","date":"1671280313","viewed":227,"name":"Fork Speedpaint Rutvik_Tak 984","username":"Rutvik_Tak","description":"Anime Speed Trails (30 min speed painting)","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["speedpaint"],"hasliked":0,"parentid":"WtfXRj","parentname":"Speedpaint_2019_07_18"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash( vec2 p ) {return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);} //Pseudo-random\nfloat smoothNoise( in vec2 p) { //Bilinearly interpolated noise (4 samples)\n    vec2 i = floor( p ); vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float a = hash( i + vec2(0.0,0.0) );\n\tfloat b = hash( i + vec2(1.0,0.0) );\n\tfloat c = hash( i + vec2(0.0,1.0) );\n\tfloat d = hash( i + vec2(1.0,1.0) );\n    return float(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y)/4.;\n}\n//Funciton to make the noise continuous while wrapping around angle \nfloat rotatedMirror(float t, float r){\n    //t : 0->1\n    t = fract(t+r);\n    return 2.*abs(t-0.5);\n}\n//Some continous radial perlin noise\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat radialPerlinNoise(float t, float d){\n    const float BUMP_MAP_UV_SCALE = 44.2;\n    d = pow(d,0.01); //Impression of speed : stretch noise as the distance increases.\n    float dOffset = -floor(iTime*10.)*0.1; //Time drift (animation)\n    vec2 p = vec2(rotatedMirror(t,0.1),d+dOffset);\n    float f1 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 2.1*vec2(rotatedMirror(t,0.4),d+dOffset);\n    float f2 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 3.7*vec2(rotatedMirror(t,0.8),d+dOffset);\n    float f3 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 5.8*vec2(rotatedMirror(t,0.0),d+dOffset);\n    float f4 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    return (f1+0.5*f2+0.25*f3+0.125*f4)*3.;\n}\n//Colorize function (transforms BW Intensity to color)\nvec3 colorize(float f,vec2 uv,vec2 altereduv){\n    \n    float d = distance(vec2(0.5),uv.xy); //Squared distance\n    float t = 0.1+atan(uv.y,uv.x)/4.28; //Normalized Angle\n    float v = radialPerlinNoise(t,d);\n    //Saturate and offset values\n    v = -2.5+v*5.;\n    //Intersity ramp from center\n    v = mix(0.,v,1.*smoothstep(0.1,10.,d));\n    float pointDistanceFromCenter = distance(vec2(0.5),vec2(v));\n   \n    uv*=( smoothstep(0.,0.9,pointDistanceFromCenter));\n  \n    vec4 iPixel = texture(iChannel0,uv);\n\n    f = clamp(f*.95,0.0,1.0);\n    vec3 c = mix(iPixel.rgb, iPixel.rgb, f); //Red-Yellow Gradient\n         c = mix(c, vec3(0.880,0.508,0.065), f);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f+1.);       //Intensity ramp\n    return cAttenuated;\n}\n/*vec3 colorize(float f){\n    f = clamp(f,0.0,1.0);\n    vec3 c = mix(vec3(1.1,0,0), vec3(1,1,0), f); //Red-Yellow Gradient\n         c = mix(c, vec3(1,1,1), f*10.-9.);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f);       //Intensity ramp\n    return cAttenuated;\n}*/\n//Main image.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 normaluv = fragCoord.xy/iResolution.xy;\n    vec2 uv = 2.5*(fragCoord-0.5*vec2(iResolution.xy))/iResolution.xx;\n    float d = dot(uv,uv); //Squared distance\n    float t = 0.1+atan(uv.y,uv.x)/4.28; //Normalized Angle\n    float v = radialPerlinNoise(t,d);\n    //Saturate and offset values\n    v = -2.5+v*5.;\n    //Intersity ramp from center\n    v = mix(0.,v,.8*smoothstep(0.1,0.65,d));\n    //Colorize (palette remap )\n    \n    vec3 colorized = colorize(v,normaluv,uv);\n    \n\n    \n    fragColor.rgb = colorized;\n}","name":"Image","description":"","type":"image"}]}