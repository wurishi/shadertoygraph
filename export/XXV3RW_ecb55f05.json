{"ver":"0.1","info":{"id":"XXV3RW","date":"1717406405","viewed":38,"name":"Sphere Studies","username":"patrickhartono","description":"Expereiming","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMIT License - https://opensource.org/license/mit\nCopyright (c) 2024, Patrick Hartono - https://patrickhartono.com/\n\n\nModified from: https://www.shadertoy.com/view/3sySRK\n\n*/\n\n// Function for smooth union of two distance values\nfloat smoothUnion(float dist1, float dist2, float blendFactor) {\n    // Calculate the blend value based on distance and blend factor\n    float h = clamp(0.5 + 0.5 * (dist2 - dist1) / blendFactor, 0.0, 1.0);\n    // Perform the smooth union operation and return the result\n    return mix(dist2, dist1, h) - blendFactor * h * (1.0 - h);\n}\n\n// Signed distance function for a sphere\nfloat sphereSDF(vec3 point, float radius) {\n    // Calculate the distance from the point to the surface of the sphere\n    return length(point) - radius;\n}\n\n// Function to map the distance field at a point\nfloat distanceField(vec3 point) {\n    float distance = 2.0; // Initialize distance to a large value\n    for (int i = 0; i < 6; i++) { // Loop through 16 iterations to place spheres\n        float index = float(i); // Convert loop index to float\n        // Calculate time offset for animation\n        float timeOffset = iTime * (fract(index * 412.531 + 0.513) - 0.5) * 1.5;\n        // Calculate the position and size of the current sphere\n        vec3 spherePos = point + cos(timeOffset + index * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 1.7, .2);\n        float sphereRadius = mix(0.5, .5, fract(index * 412.531 + 0.5124));\n        // Perform smooth union of the current sphere with the accumulated distance field\n        distance = smoothUnion(sphereSDF(spherePos, sphereRadius), distance, 1.8);\n    }\n    return distance; // Return the final distance field value\n}\n\n// Function to calculate the normal at a point in the distance field\nvec3 calculateNormal(vec3 point) {\n    const float epsilon = 1e-5; // Small value for numerical differentiation\n    const vec2 offset = vec2(1, -1); // Offset vector for calculating differences\n    // Calculate the normal using central differences\n    return normalize(\n        offset.xyy * distanceField(point + offset.xyy * epsilon) +\n        offset.yyx * distanceField(point + offset.yyx * epsilon) +\n        offset.yxy * distanceField(point + offset.yxy * epsilon) +\n        offset.xxx * distanceField(point + offset.xxx * epsilon)\n    );\n}\n\n// Time-based random function\nfloat random(float x) {\n    return fract(sin(x) * 43758.5453123);\n}\n\n// Main image rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // Normalize pixel coordinates\n\n    // Variable to control flicker speed\n    float flickerSpeed = 3.; // Smaller value for slower flicker\n\n    // Randomly set background color with flicker speed\n    float flicker = random(floor(iTime * flickerSpeed)); // Use `floor` to control flicker speed\n    vec3 backgroundColor = mix(vec3(0.0), vec3(1.0), step(0.5, flicker)); // Choose between black and white\n\n    // Set up the camera\n    vec3 rayOrigin = vec3((uv - 0.5) * vec2(iResolution.x / iResolution.y, 1.0) * 5.0, 3.0); // Ray origin based on pixel coordinates\n    vec3 rayDirection = vec3(0.0, 0.0, -1.0); // Ray direction into the screen\n\n    float depth = .0; // Initialize depth along the ray\n    vec3 hitPoint; // Intersection point in the distance field\n    bool hit = false; // Indicate whether the ray intersects a sphere\n\n    // Ray marching loop\n    for (int step = 0; step < 64; step++) { // Iterate up to 64 times\n        hitPoint = rayOrigin + rayDirection * depth; // Calculate current point along the ray\n        float distanceToSurface = distanceField(hitPoint); // Calculate distance to the nearest surface\n        depth += distanceToSurface; // Advance the ray by the distance to the surface\n        if (distanceToSurface < 1e-6) { // If the ray is close enough to the surface, mark as hit and break the loop\n            hit = true;\n            break;\n        }\n    }\n\n    vec3 color; // Variable to store the final color\n    if (hit) {\n        // If the ray hits a sphere\n        depth = min(1.0, depth); // Clamp the depth to a maximum value\n        vec3 normal = calculateNormal(hitPoint); // Calculate the normal at the intersection point\n        float brightness = max(.5, dot(normal, vec3(1.577))); // Calculate brightness based on normal and light direction\n        \n        // Calculate sphere color based on cosine function and time, adjusted by brightness\n        color = (.0 + .2 * sin((brightness + iTime * 1.5) + uv.yxx * 2.0 + vec3(0.016,1.000,1.000))) * (0.85 + brightness * 0.35);\n        color *= exp(-depth * .15); // Apply exponential falloff to color based on depth\n    } else {\n        // If the ray does not hit a sphere, use the background color\n        color = backgroundColor;\n    }\n\n    // Set the final fragment color with alpha channel indicating thickness based on depth\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}