{"ver":"0.1","info":{"id":"msscR7","date":"1686686230","viewed":45,"name":"infinite motion test","username":"halcy","description":"click and drag mouse cursor to have it chased by an ever moving infinitely rotating box\n\nillusion depends heavily on the numbers being Just Right, so futz them around a little if it doesn't quite work for you","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["opticalillusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STEPS 50\n#define MIN_DIST 0.01\n#define NORM_DIST 0.01\n#define STROKE_DUR 0.4\n#define N vec3(NORM_DIST, -NORM_DIST, 0.0)\n\n\n// directly lifted from IQs tutorial page\nfloat sdBoxFrame( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat field(vec3 pos, float frame) {\n    // Uncomment for boring sphere\n    // float d = length(pos - vec3(0.0, 0.0, 5.0)) - 1.0;    \n    \n    // Uncomment for less boring wire cube\n    float rot_amnt = 0.35 + 0.01 * frame;\n    mat3 rot = mat3(\n        cos(rot_amnt), 0.0, sin(rot_amnt),\n        0.0,      1.0, 0.0,\n        -sin(rot_amnt), 0.0, cos(rot_amnt)\n    );\n    float d = sdBoxFrame((pos - vec3(0.0, 0.0, 5.0)) * rot, vec3(1.0), 0.05);\n    return d;\n}\n\nvec2 march(vec3 origin, vec3 ray, float frame) {\n\tfloat ray_length = 0.0;\n    float dist = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n    \tvec3 pos = origin + ray * ray_length;\n        dist = field(pos, frame);\n        ray_length += dist;\n        if(dist <= MIN_DIST) {\n            break;\n        }\n    }\n    return vec2(dist, ray_length);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates and BG\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    fragColor = vec4(0.5 + 0.5 *cos(iTime + uv.xyx + vec3(0, 2, 4)), 1.0);\n    vec2 mousedir = normalize(fragCoord - iMouse.xy);\n    \n    // For inversion\n    float stroke = mod(iTime, STROKE_DUR) / STROKE_DUR;\n    bool inv = floor(stroke * 2.0) == 0.0;\n    float frame = floor(mod(stroke, 0.5) * 4.0);\n    \n    // Now raymarch\n    vec3 origin = vec3(mousedir.x, mousedir.y, 0) * 0.012 * frame + vec3(0.0, 0.2, 0.0);\n    vec3 ray = normalize(vec3(uv.x, uv.y, 1));\n    vec2 result = march(origin, ray, frame);\n    if(result.x <= MIN_DIST) {\n        vec3 p = origin + ray * result.y;\n        vec3 n = normalize(vec3(\n            field(p - N.xzz, frame) - field(p + N.xzz, frame),\n            field(p - N.zxz, frame) - field(p + N.zxz, frame),\n            field(p - N.zzx, frame) - field(p + N.zzx, frame)\n        ));\n        vec3 l = normalize(vec3(4.0, 3.0, 0.0) - p);\n        float diffuse = (1.0 - dot(n, l)) * 0.5;\n        \n        fragColor = vec4(diffuse);        \n        if(inv) {\n            fragColor = 1.0 - vec4(diffuse);        \n        }\n    }\n}","name":"Image","description":"","type":"image"}]}