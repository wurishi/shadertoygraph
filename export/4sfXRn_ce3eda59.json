{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Mandelbulb shader by cedric voisin 2014\n\t\n// tuning\n#define nIterMax 6\n#define rSat .05 \n#define rLight 1.4 \n// relative base intensities (can take any value >0)\n#define iSpec 3.\n#define iTrap 1.5\n#define iShad 10.\n#define iAO 1.\n\nfloat nMandelB; // nMandelB=8 for the usual bulb\nvec3 colMb=.8*vec3(1.,1.,.9); // MB  olor\nvec3 colSat = .8*vec3(1.,1.,.95); // sat color\n\n//\n//vec2 realSize = vec2(2.,2.*iResolution.y/iResolution.x);\n//vec2 po=(fragCoord.xy-iResolution.xy/2.)*realSize/iResolution.xy;\nvec3 col;\nfloat zMin; // smallest distance reached by the orbit of the computed point\nfloat pi=3.14;\nfloat piSur2=1.57;\nbool isSatOnTrajectory, isMbOnTrajectory;\nvec3 ptInterSphere;\n\n// def eye (the MB is fixed, the eye moves around)\nfloat thetaScr;\nfloat phiScr;\nfloat dScr=5.;\t// origin to (center of) screen\nfloat dEye=5.;\t// screen to eye\n\n\n// Screen normal and directions\nvec3 vN;\nvec3 vUp;\nvec3 vRight;\n// Screen position\nvec3 zScr;\n// Eye position\nvec3 zEye;\n\t\t\n\n// Distance Estimator\n// returns 0 if the test point is inside the MB, and the distance 0.5*r*logr/rD otherwise\nfloat DE(vec3 ptTest){\n\tfloat theta,phi,r; // point\n\tfloat newtheta,newphi,newr;\n\tfloat dr;\n\tvec3 z=ptTest; // iterated point\n\tdr=1.;\n\tzMin=1000.;\n\tfor (int i=0;i<nIterMax;i++){\n\t\tr=length(z);\n\t\tif (r>=pow(1.+float(nIterMax),2.)) break;\n\t\tnewr=pow(r,nMandelB);\n\t\tdr=1.+dr*nMandelB*pow(r,nMandelB-1.);\n\t\ttheta=acos(z.z/r);\n\t\tphi=atan(z.y,z.x);\n\t\tnewtheta=theta*nMandelB;\n\t\tnewphi=phi*nMandelB;\n\t\tz=ptTest+newr*vec3(sin(newtheta)*cos(newphi),sin(newtheta)*sin(newphi),cos(newtheta));\n\t\tzMin=min(zMin,length(z));\n\t}\n\treturn(0.5*newr*log(newr)/dr);\n}\n\n// intersection with sphere\nbool sphereInter(vec3 center, float rad, vec3 dir){\n\tvec3 result;\n\tvec3 dirSphere = zEye-center;\n\tfloat B = dot(dir,dirSphere);\n\tfloat C = length(dirSphere)*length(dirSphere)-rad*rad;\n\tfloat det2=B*B-C;\n\tif(det2>=0.){\n\t\tfloat s = min(-B+sqrt(det2),-B-sqrt(det2));\n\t\tptInterSphere = zEye+dir*s;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n// returns the nearest MB point\nvec3 getMbPoint(vec2 ptTest){\n\tvec3 zRes;\n\tvec3 z=zScr+ptTest.x*vRight+ptTest.y*vUp;// position of the tested pixel (on the screen) in space\n\tvec3 dzds=normalize(z-zEye);\n\tisMbOnTrajectory = sphereInter(vec3(0.,0.,0.),2.,dzds);\n\tif (!isMbOnTrajectory) return z+dzds;\n\tfloat maxDist=10.;\n\t\n\tfloat s=0.;\n\tfloat de;\n\t// ray tracing\n\tfor (int i=0;i<100;i++){ // awkward for because webgl forbids non constant loops :-(\n\t\tzRes=z+dzds*s;\n\t\tde=clamp(DE(zRes),0.000001,maxDist);\n\t\tif(de==0.000001) break; // distance estimated is small enough: we are on the MB\n\t\tif(s>dScr+5.) break; // gone to far: we didn't cross the MB\n\t\ts+=.5*de;\n\t}\n\tisMbOnTrajectory=true;\n\tif (s>=dScr+5.) isMbOnTrajectory=false;\n\treturn (zRes);\n}\n\n\n// the light has to follow the eye\nvec3 setLight(){\n\tfloat dthetaLight=pi+-pi/6.*cos(iTime/7.);\n\tfloat dphiLight=iTime/7.;\n\t// light direction\n\tfloat phiLight=phiScr+dphiLight;\n\tfloat thetaLight=thetaScr+dthetaLight;\n\t// light position\n\treturn rLight*vec3(sin(thetaLight)*cos(phiLight),sin(thetaLight)*sin(phiLight),cos(thetaLight));\n}\n\n// normal\nvec3 normal(vec3 ptO){\n\tvec3 dPt=vec3(.01,0.,0.);\n\tvec3 n=normalize(vec3(DE(ptO+dPt.xyy),DE(ptO+dPt.yxy),DE(ptO+dPt.yyx))); \n\treturn n;\n}\n\n// orbit trap coloring\n// proportionnal to the (normalized) smallest distance reached by the orbit of the computed point\nfloat orbitTrap(){\n\tfloat origin=.6; // to tune contrast and depth view\n\treturn (zMin-origin)/(1.-origin);\n}\n\n// specularity (coloration by normal)\nfloat specularity(vec3 n,vec3 vLight){\n\treturn dot(n,normalize(vLight));\n}\n\n// ambiant occlusion\n// compute the distance from MB for nk test points in the normal direction\n// the smaller the distance, the larger the occlusion\nfloat ambiantOcclusion(vec3 ptO,vec3 n){\n\tconst int nk=6;\n\tfloat dt=.05; // small t for constrast, large t for soft shadows\n\tvec3 pTest; // test point\n\tfloat dTest; // test distance (pTest <-> MB)\n\tfloat ao=1.; // AO intensity\n\tfloat ikf,nkf;\n\tfor (int ik=0;ik<nk;ik++){\n\t\tikf = float(ik);\n\t\tnkf = float(nk);\n\t\tpTest=ptO+n*ikf*dt;\n\t\tdTest=DE(pTest);\n\t\tao-=(ikf*dt-dTest);\n\t}\n\treturn ao;\n}\n\n// shadows\n// try some points on the light line. The more points inside the MB, the darkest the shadow.\nfloat shadows(vec3 ptO,vec3 vLight){\n\tfloat L=length(vLight-ptO);\n\tvec3 dzds=normalize(vLight-ptO);\n\tfloat nbInMB=0.;\n\tconst int nbPtTestInt=100; // number of test points on the line\n\tfloat nbPtTest=float(nbPtTestInt);\t\n\tfloat s=0.;\n\tfor (int i=0;i<nbPtTestInt;i++){\n\t\tif(DE(ptO+dzds*s)<0.01) nbInMB++;\n\t\ts+=L/nbPtTest;\n\t}\n\treturn 1.-nbInMB/nbPtTest;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    \n    // constants\n    nMandelB=4.+2.*cos(.01*iTime+1.57);\n    thetaScr=piSur2;\n    phiScr=-iTime/47.;\n    vN=-vec3(sin(thetaScr)*cos(phiScr),sin(thetaScr)*sin(phiScr),cos(thetaScr));\n\tvUp=normalize(dScr*vec3(sin(thetaScr-piSur2)*cos(phiScr),sin(thetaScr-piSur2)*sin(phiScr),cos(thetaScr-piSur2)));\n\tvRight = cross(vN,vUp);\n\tzScr=-dScr*vN;\n\tzEye=-(dScr+dEye)*vN;\n    //\n    \n\tvec2 poNoScale=-1.+2.*fragCoord.xy/iResolution.xy;\n\tvec2 poScale=poNoScale*vec2(1.,iResolution.y/iResolution.x);\n\tvec3 vLight=setLight();\n\tvec3 ptMb=getMbPoint(poScale);\n\tisSatOnTrajectory = sphereInter(vLight, rSat, normalize(ptMb-zEye));\n\tvec3 ptSat= ptInterSphere;\n\tbool satFirst;\n\tvec3 n,obj;\n\t\n\tif (!isMbOnTrajectory) satFirst=true;\n\tif (!isSatOnTrajectory) satFirst=false;\n\tif (isMbOnTrajectory && isSatOnTrajectory){\n\t\tif(length(ptSat-zEye)<length(ptMb-zEye)) {satFirst=true;} else {satFirst=false;}\n\t}\n\t\t\n\tif(isMbOnTrajectory || isSatOnTrajectory) {\n\t\tif (satFirst){\n\t\t\tfloat intSat=clamp((1.+dot(normalize(ptSat-vLight),-normalize(vLight)))/2.,0.,1.);\n\t\t\tcol = intSat*colSat;\n\t\t} else {\n\t\t\tn = normal(ptMb);\n\t\t\t// coefficients for intensities (0<c<1)\n\t\t\tfloat cTrap = orbitTrap();\n\t\t\tfloat cSpec = specularity(n,vLight);\n\t\t\tfloat cAO = ambiantOcclusion(ptMb,n);\n\t\t\tfloat cShad = shadows(ptMb,vLight);\n\n\t\t\t// Average intensity (weighted with computed coefs)\n\t\t\tfloat Intensity=clamp((cSpec*iSpec+cAO*iAO+cTrap*iTrap+cShad*iShad)/(iSpec+iTrap+iShad+iAO),0.,1.);\n\t\t\tcol = Intensity*Intensity*colMb.xyz;\n\t\t}\n\t}\n\t\n\tif(!isMbOnTrajectory && !isSatOnTrajectory){// background\n\t\tfloat bgInt=clamp(1.-length(fragCoord.xy-iResolution.xy/2.)/length(iResolution.xy),0.,1.);\n\t\tcol = .95*bgInt*vec3(1.,1.,1.);\n\t}\n\tfragColor= vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfXRn","date":"1395555310","viewed":561,"name":"Mandelfriend","username":"cedric","description":"The mandelbulb has a friend now.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""}}