{"ver":"0.1","info":{"id":"Xt3SRl","date":"1481016515","viewed":205,"name":"Points 3","username":"chadiik","description":"Points (and lines!)\nSong: Dramath√®que by DJ Pretentious","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["2d","points","viz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CELL_SIZE 1.0\n#define NUM_POINTS 300\n#define CELLS_PER_POINT 1\n#define CELLS_OFFSET 0\n\n#define ratio vec2(iResolution.x / iResolution.y, 1.0)\n\n\n\n\n\n\n\n\nint coordCell(vec2 coord)\n{\n    coord = floor(coord / CELL_SIZE);\n    float h = floor(iChannelResolution[0].x / CELL_SIZE);\n    \n    int index = int(coord.x + coord.y * h);\n    return CELLS_OFFSET + index * CELLS_PER_POINT;\n    //return index;\n}\n\nvec2 cellCenter(int index)\n{\n    index = CELLS_OFFSET + index * CELLS_PER_POINT;\n    float i = float(index);\n    float h = floor(iChannelResolution[0].x / CELL_SIZE);\n    float x = mod(i, h);\n    float y = floor(i / h);\n    vec2 uv = (vec2(x, y) * CELL_SIZE + CELL_SIZE * 0.5) / iChannelResolution[0].xy;\n    return uv;\n}\n\nvec4 cellValue(int index)\n{\n    vec2 uv = cellCenter(index);\n    return texture(iChannel0, uv);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat fillCircle(vec2 uv, vec2 pos, float radius, float blur)\n{\n    float d = distance(uv * ratio, pos * ratio);\n    float dr = d - radius;\n    return 1.0 - smoothstep(radius - blur, radius, d);\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b, float blur, float size)\n{ // blur = 0.9985, size = 100.0\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    //float sharp = smoothstep(1.0/iResolution.y, 0., d );\n    return clamp(((1.0 - d)-blur)*size, 0.0, 1.0);\n}\n\nint wrapIndex(int i, int a, int b)\n{\n    float d = abs(float(b) - float(a));\n    float r = mod(float(i), d);\n    return a + int(r);\n}\n\nvec3 mainSound( in int samp,vec2 uv)\n{\n    float time = iTime + .5;\n    \n    float a = 3.0;\n    float b = 6.0;\n    float ok = 6.2831;\n    float volume = .15;\n    \n    float t = 0.0;\n    for(int i = 0; i < NUM_POINTS; i++)\n    {\n        vec4 cell = cellValue(i);\n        t += length(cell.zw);\n    }\n    \n    t /= float(NUM_POINTS);\n    \n    float tune = sin(t*440.0*time) * volume;\n    \n    return vec3( tune );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 1.8 - .4;\n    \n    vec3 color = vec3(0.0);\n    float change = 0.0001;\n    \n    for(int i = 0; i < NUM_POINTS; i++)\n    {\n        vec4 cell = cellValue(i);\n        vec2 pos = cell.xy;\n        \n        vec4 angelCell = cellValue(wrapIndex(i + 1, 0, NUM_POINTS));\n        color.yz += .9 * line(uv, pos, angelCell.xy, 0.945, 0.5);\n        \n        int offset = NUM_POINTS / 2 * 0 + int(iTime * 40.5 + float(i) / 100.0);\n        angelCell = cellValue(wrapIndex(i + offset, 0, NUM_POINTS));\n        color.xy += .9 * line(uv, pos, angelCell.xy, 0.985, 4.0);\n        color.xyz += .9 * line(uv, pos, angelCell.xy, 0.9985, 100.0);\n        \n        offset = NUM_POINTS / 2 * 0 + int(iTime * 40.5 + float(i) / 100.0);\n        angelCell = cellValue(wrapIndex(i + offset + 1, 0, NUM_POINTS));\n        color.xz += .9 * line(uv, pos, angelCell.xy, 0.985, 10.0);\n        //color.xyz += .9 * line(uv, pos, angelCell.xy, 0.995, 50.0);\n        \n        float pointValue = fillCircle(uv, pos, 0.015, 0.00112);\n        float speed = .25 + .75 * (length(cell.zw) * 4000.0);\n        color.xyz += vec3(smoothstep(0.0, .9, pointValue * speed)) * speed;\n        color.xyz += (cell.zww * 20.0);\n        \n        pointValue = fillCircle(uv, pos, 0.0075, 0.009422);\n        color.xyz -= vec3(pointValue);\n        \n        vec2 rSeed = floor(cell.zw * change) / change;\n        float r = rand(rSeed) * 2.0;\n        int index = wrapIndex(int(float(NUM_POINTS) * r), 0, NUM_POINTS);\n        cell = cellValue(index);\n        //color.xyz += .9 * line(uv, pos, cell.xy);\n    }\n    \n    //color = vec3(line(uv, vec2(0.1), vec2(.9)));\n    /*\n    if(iMouse.z > 0.0)\n    {\n        vec2 click = iMouse.xy / iResolution.xy;\n        color += fillCircle(uv, click, 0.22, 0.1) * .5;\n    }\n    */\n    /*\n    if(uv.x < .08)\n    \tcolor = mainSound( in int samp,uv);\n    if(uv.x >= .08 && uv.x < .1)\n    \tcolor = vec3(0.0);\n    */\n    \n    color.x = color.y = color.z = (color.x + color.y + color.z) / 3.0 * .8 + .2;\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsSGWW","filepath":"https://soundcloud.com/djpretentious/dramatheque","previewfilepath":"https://soundcloud.com/djpretentious/dramatheque","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CELL_SIZE 1.0\n#define NUM_POINTS 300\n#define CELLS_PER_POINT 1\n#define CELLS_OFFSET 0\n\n#define RANGE vec2(1.0, 1.0)\n#define ratio vec2(iResolution.x / iResolution.y, 1.0)\n#define CENTER vec2(.5, .5)\n\n\n\n\n\n\nint coordCell(vec2 coord)\n{\n    coord = floor(coord / CELL_SIZE);\n    float h = floor(iChannelResolution[0].x / CELL_SIZE);\n    \n    int index = int(coord.x + coord.y * h);\n    return CELLS_OFFSET + index * CELLS_PER_POINT;\n    //return index;\n}\n\nvec2 cellCenter(int index)\n{\n    index = CELLS_OFFSET + index * CELLS_PER_POINT;\n    float i = float(index);\n    float h = floor(iChannelResolution[0].x / CELL_SIZE);\n    float x = mod(i, h);\n    float y = floor(i / h);\n    vec2 uv = (vec2(x, y) * CELL_SIZE + CELL_SIZE * 0.5) / iChannelResolution[0].xy;\n    return uv;\n}\n\nvec4 cellValue(int index)\n{\n    vec2 uv = cellCenter(index);\n    return texture(iChannel0, uv);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co)\n{\n    return vec2(rand(co), rand(co.yx));\n}\n\nvec2 wrap(vec2 vec, vec2 range)\n{\n    return mod(vec, range);\n}\n\nfloat wrap(float i, float a, float b)\n{\n    float d = abs(b - a);\n    return a + mod(i, d);\n}\n\nint wrapIndex(int i, int a, int b)\n{\n    float d = abs(float(b) - float(a));\n    float r = mod(float(i), d);\n    return a + int(r);\n}\n\nfloat getFreq(float t)\n{\n\tfloat fft  = texture( iChannel1, vec2(t,0.25) ).x;\n    return fft;\n}\n\nfloat getMedFreq()\n{\n    const int iSamples = 5;\n    float samples = float(iSamples);\n    float div = 1.0 / (samples + 1.0);\n    float sum = 0.0;\n    for(int i = 0; i < iSamples; i++)\n    {\n        float t = float(i + 1) * div;\n        sum += getFreq(t);\n    }\n    \n    return sum / samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = coordCell(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = vec4(1.0);\n    float a = 3.1415 * 2.0 / float(NUM_POINTS);\n    float r = 0.35;\n    if(index < NUM_POINTS)\n    {\n        float cosa = cos(a * float(index));\n        float sina = sin(a * float(index));\n        if(iFrame == 0)\n        {\n            float b = mod(float(index / 6), 1.5) * (-.2);\n            b = r + b;\n            color.x = .5 + cosa * b / ratio.x;\n            //color.x = float(index) / float(NUM_POINTS) * ratio.x;\n            color.y = .5 + sina * b;\n            color.zw = rand2(color.xy) * 0.0002;\n        }\n        else\n        {\n            color = texture(iChannel0, uv);\n            vec2 offset = rand2(color.xy * sin(iTime));\n            offset = offset + vec2(-.5, -.5);\n            offset *= 0.000051;\n            vec2 velocity = color.zw * .99 + offset;\n            \n            /*\n            vec2 rSeed = uv;\n            float r = rand(rSeed) * 2.0;\n        \tint i2 = index + 2;//int(float(NUM_POINTS) * r);\n        \tvec4 cell = cellValue(wrapIndex(i2, 0, NUM_POINTS));\n            \n            color.xy += (cell.xy - color.xy) * 0.1;\n            vec2 click = iMouse.xy / iResolution.xy;\n            if(iMouse.z > 0.0 && distance(color.xy, click) < 0.17)\n            {\n                color.xy += (click - color.xy) * 0.05;\n            }\n\t\t\t*/\n            \n            float t = (iTime * 90.0 + float(index)) / float(NUM_POINTS);\n            float freq = getFreq(wrap(t, 0.0, 1.0));\n            freq = smoothstep(0.25, 1.0, freq);\n            t = (1.0 / freq * 10.0 + float(index)) / float(NUM_POINTS);\n            freq = getFreq(wrap(t, 0.0, 1.0));\n            \n            float ft = freq * .125 + smoothstep(0.25, 1.0, sin(iTime * 0.1 - 0.40));\n            float ftotal = getMedFreq();\n            ftotal *= 1.0;\n            color.xy = CENTER + (vec2(cosa / ratio.x, sina) * (ft + ftotal)) * 1.1;\n            \n            color.xy = wrap(color.xy + velocity, RANGE);\n            color.zw = velocity;\n        }\n    }\n    \n    fragColor = color;\n}","name":"Buf A","description":"","type":"buffer"}]}