{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  There's probably some better ways to do this without so much branching logic, but\n  doing it this way for clarity.  If you know of better branchless ways, feel free to\n  comment!!\n*/\n\n#define TWO_PI \t\t\t6.2831\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n#define TONE_FREQUENCY2\t442.0\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 4.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n//========================= WAVE FORMS\nfloat makeSine(float time, float frequency)\n{\n    return sin(frequency*TWO_PI*time);\n}\n\nfloat makeTriangle(float time, float frequency)\n{\n    return abs(fract(time * frequency)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time, float frequency)\n{\n    return (mod(time * frequency, 1.0) * 2.0) - 1.0;\n}\n\nfloat makeSquare(float time, float frequency)\n{\n    return step(fract(time * frequency), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time, float frequency)\n{   \n    // figure out how much to scale the volume to account for envelope\n    // on the front and back of each wave form    \n    float noteTime = mod(iTime, TONE_LENGTH);\n    float envelope = 1.0;\n    if (noteTime < ENVELOPE_SIZE)\n        envelope = noteTime / ENVELOPE_SIZE;\n    else if (noteTime > (TONE_LENGTH - ENVELOPE_SIZE))\n        envelope = 1.0 - ((noteTime - (TONE_LENGTH - ENVELOPE_SIZE)) / ENVELOPE_SIZE);\n    \n    // play the apropriate wave form based on time\n    float mode = mod(iTime / TONE_LENGTH, 4.0);\n    if (mode > 3.0)\n        return makeSquare(time, frequency) * envelope;\n    else if (mode > 2.0)\n        return makeSaw(time, frequency) * envelope;\n    else if (mode > 1.0)\n        return makeTriangle(time, frequency) * envelope;\n    else\n        return makeSine(time, frequency) * envelope;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 percent = (fragCoord.xy / iResolution.xy);\n    percent.x /= 256.0;\n    percent.y = (percent.y) * 2.2 - 1.1;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n    float combinedValue1 = 0.0;\n    float combinedValue2 = 0.0;\n    \n    // calculate a time offset to show the wave form moving across the screen\n    float timeOffset = mod(iTime / 200.0, TONE_LENGTH);\n    \n    // TONE_FREQUENCY wave\n    float value1 = makeSound(percent.x + timeOffset, TONE_FREQUENCY);\n    float value2 = makeSound(percent.x + timeOffset - 0.00001, TONE_FREQUENCY);\n    value1 *= 0.5;\n    value2 *= 0.5;\n    combinedValue1 += value1;\n    combinedValue2 += value2;\n    if (abs(percent.y-value1) < 0.01)\n        color += vec3(0.0,1.0,0.0);\n    else if ((percent.y > value1 && percent.y < value2) ||\n\t\t     (percent.y < value1 && percent.y > value2))\n        color += vec3(0.0,1.0,0.0);\n    \n    // TONE_FREQUENCY2 wave\n    timeOffset -= (TONE_FREQUENCY - TONE_FREQUENCY2) * iTime / TONE_FREQUENCY;\n    value1 = makeSound(percent.x + timeOffset, TONE_FREQUENCY2);\n    value2 = makeSound(percent.x + timeOffset - 0.00001, TONE_FREQUENCY2);\n    value1 *= 0.5;\n    value2 *= 0.5;    \n    combinedValue1 += value1;\n    combinedValue2 += value2;\n    if (abs(percent.y-value1) < 0.01)\n        color += vec3(1.0,0.0,0.0);\n    else if ((percent.y > value1 && percent.y < value2) ||\n\t\t     (percent.y < value1 && percent.y > value2))\n        color += vec3(1.0,0.0,0.0);\n        \n    // combined wave\n    if (abs(percent.y-combinedValue1) < 0.01)\n        color += vec3(0.0,0.0,1.0);\n    else if ((percent.y > combinedValue1 && percent.y < combinedValue2) ||\n\t\t     (percent.y < combinedValue1 && percent.y > combinedValue2))\n        color += vec3(0.0,0.0,1.0);    \n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  There's probably some better ways to do this without so much branching logic, but\n  doing it this way for clarity.  If you know of better branchless ways, feel free to\n  comment!!\n*/\n\n#define TWO_PI \t\t\t6.2831\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n#define TONE_FREQUENCY2\t442.0\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 4.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n//========================= WAVE FORMS\nfloat makeSine(float time, float frequency)\n{\n    return sin(frequency*TWO_PI*time);\n}\n\nfloat makeTriangle(float time, float frequency)\n{\n    return abs(fract(time * frequency)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time, float frequency)\n{\n    return (mod(time * frequency, 1.0) * 2.0) - 1.0;\n}\n\nfloat makeSquare(float time, float frequency)\n{\n    return step(fract(time * frequency), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time, float frequency)\n{\n    // figure out how much to scale the volume to account for envelope\n    // on the front and back of each wave form\n    float noteTime = mod(time, TONE_LENGTH);\n    float envelope = 1.0;\n    if (noteTime < ENVELOPE_SIZE)\n        envelope = noteTime / ENVELOPE_SIZE;\n    else if (noteTime > (TONE_LENGTH - ENVELOPE_SIZE))\n        envelope = 1.0 - ((noteTime - (TONE_LENGTH - ENVELOPE_SIZE)) / ENVELOPE_SIZE);\n    \n    // play the apropriate wave form based on time\n    float mode = mod(time / TONE_LENGTH, 4.0);\n    if (mode > 3.0)\n        return makeSquare(time, frequency) * envelope;\n    else if (mode > 2.0)\n        return makeSaw(time, frequency) * envelope;\n    else if (mode > 1.0)\n        return makeTriangle(time, frequency) * envelope;\n    else\n        return makeSine(time, frequency) * envelope;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // generate a mono channel sound\n    float monoSound = makeSound(time, TONE_FREQUENCY);\n    monoSound += makeSound(time, TONE_FREQUENCY2);\n    monoSound *= 0.5;\n    \n    // return our mono sound as a stereo sound, using it for both channels\n    return vec2(monoSound);\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXSWf","date":"1407181975","viewed":404,"name":"Beating Effect","username":"demofox","description":"Demonstrates \"the beating effect\" which happens when you play 2 tones next to each other that have only slightly different frequencies.\nSort of flange-ish but different.","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["sound","triangle","square","sine","saw","beating"],"hasliked":0,"parentid":"","parentname":""}}