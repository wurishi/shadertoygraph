{"ver":"0.1","info":{"id":"fljfD1","date":"1652140021","viewed":112,"name":"My new Camera","username":"Uffe55","description":"In the last few days I have been writing this camera.\nWith the idea of ​​avoiding problems at the North Pole.\nIn addition, adjustable focal length and zoom.\nUsually steals free code, but to understand, do it yourself.\nFree to use credit to Uffe55.\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["zoom","camera","focallength"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Credit to a lot of generous people from which I learned \n//a lot. Iquilezles and BigWing among others.\n\n// This is a demo of my new camera with focal lengt adjustment \n// and zoom\n\n// This is a LOOK AT ORIGO CAMERA the target parameter is for\n// future development. \n// Set AUTOMATICFOCAL to 0 for hard coded values.\n// Or open the hood and remove the \"if statment\" AUTOMATICFOCAL \n// in main at line 240.\n// Free and easy to use. Uffe55.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define PI2 = 6.28318\n\n// Set AUTOMATICFOCAL to 0 for hard coded values.\n\nint AUTOMATICFOCAL = 0;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 rotTPR(vec3 p,float a,float b,float c)\n{\n    p.xz *= Rot(a);   p.yz *= Rot(b);   p.xy *= Rot(c);\n    return p;\n}\nfloat sdSegment(vec3 p,vec3 a,vec3 b,float R)\n{\n    float h = min(1.0,\n              max(0.0,dot(p-a,b-a) / dot(b-a,b-a)));\n    return length(p-a-(b-a)*h)-R;\n}\n\nfloat sdBox(vec3 p , vec3 s){\n  \n    p = abs(p)-s;  \n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSquareFrame3(vec3 p, vec3 bOut,vec3 bIn)\n{\n    float dist = 1000.0;\n        dist = min(dist, sdBox(p,bOut));\n        dist = max(dist, -sdBox(p,bIn));\n\n    return dist;\n}\n\n\nfloat sdXYZ(vec3 p){\n float dist =1000.0;\n    float s=0.12;\n    vec3 pos = vec3(-2.3,0.0,0.0);\n    vec3  posR = vec3(s,0.0,0.0);\n    vec3  posU=  vec3(0.0,s,0.0);\n    dist=min(dist,sdSegment(p,pos+posR+posU,pos-posR-posU,0.04));\n    dist=min(dist,sdSegment(p,pos+posR-posU,pos-posR+posU,0.04));\n    //Y\n    pos = vec3(0.0,-2.3,0.0);\n    dist=min(dist,sdSegment(p,pos+posR-posU,pos,0.04));\n    dist=min(dist,sdSegment(p,pos-posR-posU,pos,0.04));\n    dist=min(dist,sdSegment(p,pos+posU,pos,0.04));\n    //Z\n     pos = vec3(0.0,0.0,-2.3);\n    dist=min(dist,sdSegment(p,pos+posR-posU,pos-posR-posU,0.04));\n    dist=min(dist,sdSegment(p,pos-posR+posU,pos+posR+posU,0.04));\n    dist=min(dist,sdSegment(p,pos-posR-posU,pos+posR+posU,0.04));\n    \nreturn dist;\n}\nfloat sdAxisLines(vec3 p, float segLen, vec3 position ,float spRadius)\n{\n    float dist = 1000.0;\n    vec3 k1 = vec3(segLen,0,0),\n         k2 = vec3(0,segLen,0),\n         k3 = vec3(0,0,segLen); \n    dist= min(dist,sdSegment (p,k1,-k1,0.03));\n    dist= min(dist,sdSegment (p,k2,-k2,0.03));\n    dist= min(dist,sdSegment (p,k3,-k3,0.05));\n   \n \n return dist;\n}\n\nfloat sceenAxis(vec3 p)\n{ \n\n    float dist = 1000.0;\n    //   p, float segLen, vec3 position ,float spRadius)\n    dist = min(dist,sdAxisLines(p, 2.0, vec3(0.0,0.0,0.0) ,1.0));\n     //sphere\n    dist= min(dist,length(p) - 0.2);\n    dist = min(dist,sdXYZ(p));\n    return dist;\n}\n\n\n\n// frame\nfloat SceenTPR(vec3 p)  //Order of rotation tetha phi rho\n{\n    float dist =1000.0;  \n    float side = 3.0;\n    float width = 0.25;\n    float thic = width*0.5;\n    vec3 boxOut = vec3( side ,side, width  );\n    vec3 boxIn = vec3( side-width+thic,side-width+thic ,width+width );\n    // Angles \n    float tetha = 0.785398,\n          phi   = -0.785398,\n          rho   = -0.4*iTime;\n          \n    p = rotTPR( p,tetha,phi,rho);\n    dist = min(dist, sdSquareFrame3( p,  boxOut, boxIn));\nreturn dist;\n}\n\n\nfloat sdBoxFrame(vec3 p){\n\n float dist =1000.0;\n    vec3  pos = p+vec3(0.0);  //(1,-1,-1);\n    float sc =1.5;\n    float a = 1.0;\n    float th= 0.15;\n    \n    vec3 s1=vec3(a )*sc;\n    vec3 s2=vec3(a +1.0 , a-th, a-th)*sc;\n    vec3 s3=vec3(a -th , a+ 1.0 , a-th)*sc;\n    vec3 s4=vec3(a -th,  a-th, a +1.0)*sc;\n    \n    \n    dist = min (dist,sdBox(pos,s1));\n    dist = max(dist,-sdBox(pos,s3));\n    dist = max(dist,-sdBox(pos,s2));\n    dist = max(dist,-sdBox(pos,s4));\n   \n  \nreturn dist;    \n}\n\nfloat GetDist(vec3 p) {\n       \n       float d=1000.0;\n     \n      d = min(d,sceenAxis( p));\n       d= min(d,SceenTPR(p)); // frame\n       d = min(d,sdBoxFrame( p));\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// Free to use camera. Credit Uffe55\n// This is a LOOK AT ORIGO CAMERA the target parameter is for\n// future development.\n// Parameters: \n//  m Mouse, uv , ro rayorgin out param, \n//  target , rodist (focal lenght) , zoom\n\nvec3 cameraGetRayDir(vec2 m, vec2 uv,  out vec3 ro, \n           vec3 target,float rodist,float zoom )\n{\nfloat phi = m.y * 6.28318 - 1.570796, \n      theta = -m.x * 6.28318;          \nvec3 vdir = vec3(0.0,1.0,0.0),            //normalized \n     //origo = vec3(0.0),                   // origo\n     nro = vec3(0.0,0.0,1.0),            //normalized \n     foc,                                 //focal\n     right = vec3(1.0,0.0,0.0),\n     up ;\n\n     right.xz *= Rot(theta);                          \n     vdir.yz *= Rot(phi);                //normalized\n     vdir.xz *= Rot(theta);              //Rotate to view dir normalized\n     up = cross(right,vdir);             //UP normalized\n     foc= vdir * zoom;                   //focal length\n     ro = -vdir * rodist;   //ro is an \"out parameter\" position ray orgin\n     vec3 rayDirection = foc + uv.x * right + uv.y* up;\n     return  normalize(rayDirection);\n}\n\nfloat GetLight(vec3 p) {\n    \n    vec3 lightPos = vec3(9, -23, 9.0);\n    lightPos.xz *=Rot(iTime*0.2);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lig = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, lig), 0.0, 1.);\n   \n    float d = RayMarch(p+n*SURF_DIST*2., lig);\n    if(d<length(lightPos-p)) dif *= .2;\n   \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    /////////////////////////parameters used by camera\n    vec3 target = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    float distRo;\n    float zoom;\n    if(AUTOMATICFOCAL>0){\n          distRo = 20.0 +sin(iTime*0.7)*15.0, // focal lenght\n          zoom = distRo/7.0;//6-10\n    }else{\n          distRo = 21.0 , // focal lenght\n          zoom = 2.8;      \n    }     \n          // also uv and m (mouse)\n     /////////////////////////////end camera parameters\n     vec3 rd = cameraGetRayDir( m,uv,ro,target,distRo,zoom);\n     // note ro is passed by \"out parameter\" and used by RayMarch\n     \n     float d = RayMarch(ro, rd); \n    \n     float nuv= uv.y;    \n     vec3 col=vec3(0.4-nuv, 0.3-nuv , 0.6- nuv*0.1);\n    \n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        float dif=GetLight( p);\n        col = vec3(dif,dif,0.95*dif);\n    }\n   \n    fragColor = vec4(col,1.0);\n \n}","name":"Image","description":"","type":"image"}]}