{"ver":"0.1","info":{"id":"4XsSRn","date":"1709087651","viewed":79,"name":"2d shadow approximation","username":"Zentient","description":"Fakes shadows with math.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["light","volumetric"],"hasliked":0,"parentid":"l3fXRr","parentname":"volume approximation"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float brightness = 9.0;\nconst float rad = 3.0;\n\n//This is just for fun\nvec3 ACESFilm(vec3 x)\n{\nfloat a = 2.51f;\nfloat b = 0.03f;\nfloat c = 2.43f;\nfloat d = 0.59f;\nfloat e = 0.14f;\nreturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 volume(vec2 coord)\n{\n    vec2 liPos[3];\n    vec2 ocPos[5];\n    vec3 liCol[3];\n    \n    //Light color\n    liCol[0] = vec3(1.0, 0.1, 0.05);\n    liCol[1] = vec3(0.1, 0.6, 0.0);\n    liCol[2] = vec3(0.3, 0.1, 1.0);\n   \n    //Light positions\n    liPos[0] = vec2(sin(iTime * 1.5), cos(iTime)) * (iResolution.xy / 25.0);\n    liPos[1] = vec2(sin(2.0 + iTime * 1.0), cos(0.0 + iTime * 0.5)) * (iResolution.xy / 30.0);\n    liPos[2] = vec2(sin(3.3 + iTime * 0.45), cos(3.0 + iTime) * 0.7) * (iResolution.xy / 20.0);\n    \n    //Object positions\n    ocPos[0] = vec2(sin(iTime), cos(iTime * 0.65)) * (iResolution.xy / 70.0);\n    ocPos[1] = vec2(cos(iTime), cos(2.0 + iTime * 1.7)) * (iResolution.xy / 50.0);\n    ocPos[2] = vec2(sin(5.1 + iTime * 2.5), cos(5.3 + iTime * 1.0)) * (iResolution.xy / 40.0);\n    ocPos[3] = vec2(tan(iTime), cos(iTime * 0.55)) * (iResolution.xy / 30.0);\n    ocPos[4] = vec2(cos(iTime), sin(3.5 + iTime * 1.1)) * (iResolution.xy / 20.0);\n\n    \n    vec3 col; //Output color\n    \n    for(int i = 0; i < liPos.length(); i++)\n    {    \n        for(int ii = 0; ii < ocPos.length(); ii++)\n        {    \n            float ld = distance(coord, liPos[i]) - rad;//ld: Light distance\n            float od = distance(coord, ocPos[ii]) - rad;//od: Object distance\n            float dd = distance(liPos[i], ocPos[ii]);//dd: Distance between light and object\n            \n            //Early return if touching objects\n            if(ld <= 0.0) {return liCol[i];}\n            if(od <= 0.0) {return vec3(0.0);}\n            \n            \n            //Shadows\n            float difDot = 0.5 + 0.5 * (dot(normalize(ocPos[ii] - coord), normalize(ocPos[ii] - liPos[i])));\n            difDot -= clamp((rad / 5.0) / (od + (rad / 5.0)), 0.0, 1.0);\n            difDot = clamp(difDot, 0.0, 1.0);\n            difDot = pow(difDot, 0.1 * (rad / dd));\n            \n            //Light propogation\n            float occl = rad * brightness / (ld*ld);\n            occl /= occl+1.0;\n            col += liCol[i] * (occl * difDot / float(ocPos.length()));\n            \n        }\n        \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / 1024.0;\n    vec3 col = 1.0 * volume((fragCoord.xy - iResolution.xy * 0.5) / 10.0);\n    \n    //Pretty things\n    col = ACESFilm(1.5 * col);\n    col = pow(col, vec3(1.0) / 2.2);\n    \n    //Dithering\n    vec3 noise = texture(iChannel0, uv).rgb;\n    col = mix(col, col-noise, 0.1 * (1.0 - col));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}