{"ver":"0.1","info":{"id":"4f3fRM","date":"1732808996","viewed":166,"name":"spiralic moving","username":"nayk","description":"spiral from glslsandbox","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["fbm","spiral","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define resolution iResolution.xy\n\n\n\nfloat makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){\n   float xx=x+sin(t*fx*.4)*sx*2.0;\n   float yy=y+cos(t*fy)*sy;\n   return 1.5/sqrt(xx*xx*yy*yy)/(time+5000.);\n}\n#define NUM_EXPLOSIONS 2.\n#define NUM_PARTICLES 64.\n#define inv_nparticels (4./NUM_PARTICLES)\n#define PI 3.1415926\n\nfloat Hash11(float t){\n    return fract(sin(t*613.2)*614.8);\n}\nvec2 Hash12(float t){\n  return vec2(fract(sin(t*213.3)*314.8)-0.5,fract(sin(t*591.1)*647.2)-0.5);\n}\n\nvec2 Hash12_Polar(float t){\n    float o = fract(sin(t*213.3)*314.8)*PI*2.0;\n    float r = fract(sin(t*591.1)*647.2);\n    return vec2(sin(o)*r,cos(o)*r);\n}\n\nfloat Explosion(vec2 uv, float t)\n{\n    float fract_t=fract(t);\n    float floor_t=floor(t);\n    float power=0.3+Hash11(floor_t);\n    float sparks=0.;\n    for(float i=0.;i<NUM_PARTICLES;i++)\n    {\n        vec2 dir=Hash12_Polar(i*floor_t)*1.;\n        float inv_d=1./(length(uv-dir*sqrt(fract_t)));\n        float brightness=mix(0.3,0.09,smoothstep(0.,0.1,fract_t))*(1.0-(0.5+0.5*Hash11(i))*fract_t);\n        float sparkling= .5+.5*sin(t*10.2+floor_t*i);\n        sparks+=power*brightness*sparkling*inv_nparticels*inv_d;\n    }\n    return sparks;\n}\n\n\n\n// --------[ Original ShaderToy begins here ]---------- //\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.20;\n    f += 0.2500*noise( p ); p = m*p*2.563;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n//====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\nvec2 uPos = ( gl_FragCoord.xy / resolution.xy );//normalize wrt y axis\n\t//suPos -= vec2((resolution.x/resolution.y)/2.0, 0.0);//shift origin to center\n\t\n\tuPos.x -= 0.5;\n\tuPos.y -= 0.5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uPos*0.5) + .27)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    float e = 2.0/iResolution.y;\nvec2 p7 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 on = vec4(0.0);\n    float f = func(p7, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.9,0.7,0.1), vec3(0.1,0.5,0.05), f );\n    col = mix( col, vec3(0.3,0.3,0.1), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.7,0.2,0.1), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n#if 0\n    // gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n#else    \n    // manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p7+vec2(e,0.0),kk)-f, \n                                2.0*e,\n                                func(p7+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    \n      vec2 p=(gl_FragCoord.xy/resolution.x)*2.0-vec2(1.0,resolution.y/resolution.x);\n   p=p*2.0;\n   \n   float x=p.x;\n   float y=p.y;\n\n   float a=\n       makePoint(x,y,3.3,2.9,0.3,0.3,time);\n   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,time);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,time);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,time);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,time);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,time);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,time);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,time);   \n   \n   float b=\n       makePoint(x,y,1.2,1.9,0.3,0.3,time);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);\n   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);\n\n   float c=\n       makePoint(x,y,3.7,0.3,0.3,0.3,time);\n   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);\n   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);\n   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);\n   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);\n   \t\n   float u=dot(vec2(b,c),vec2(1.))*100.;\n\t\n   vec3 d=vec3(a,b,c)/1.0*vec3(u,u*.5,u*.1); \nvec3 col7=vec3(0);    \n\n    for(float i=0.;i<NUM_EXPLOSIONS;i++){\n        float t=time*(0.3+0.4*Hash11(i))+i/NUM_EXPLOSIONS;\n        float fract_t=fract(t);\n        float floor_t=floor(t);\n    \n        vec3 color=0.7+0.3*sin(vec3(.34,.54,.43)*floor_t*i);\n        vec2 center = Hash12(i+10.+5.*floor_t);\n        col7+=Explosion(uv-center,t)*color;\n    }\n    col7 *= col7/2.;\n   vec4 fc = vec4(1. - exp2( -col7 ),1.0);//Ã¤ndrom3da4twist\n\n\tfloat multiplier = 0.0005; // Grosseur\n\tconst float step = 0.006; //segmentation\n\tconst float loop = 80.0; //Longueur\n\tconst float timeSCale = 0.5; // Vitesse\n\t\n\tvec3 blueGodColor = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\t\t\n\t\tfloat t = time*timeSCale-step*i*i;\n\t\tvec2 point = vec2(0.75*sin(t), 0.5*sin(t));\n\t\tpoint += vec2(0.75*cos(t*4.0), 0.5*sin(t*3.0));\n\t\tpoint /= 11. * sin(i);\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tblueGodColor += vec3(componentColor/3.0, componentColor/3.0, componentColor);\n\t}\n\t\n\t\n\tvec3 color3 = vec3(0,0,0);\n\tcolor3 += pow(blueGodColor,vec3(0.1,0.3,0.8));\n\tvec3 color = vec3(0.0);\n\tfloat vertColor = 0.0;\n \n\tfor( float i = 0.0; i < 10.0; ++i )\n\t{\n    uPos*=ma;\n\t\tfloat t = time * (0.9);\n\t   \n\t\tuPos.y += sin( uPos.x*(i+1.0) + t+i/2.0 ) * 0.1;\n        \n\t\tfloat fTemp = abs(1.0 / uPos.y / 100.0);\n\t\tvertColor += fTemp;\n\t\tcolor += vec3( fTemp*(10.0-i)/10.0, fTemp*i/10.0, pow(fTemp,0.99)*1.5 );\n\t}\n\t\n\tvec4 color_final = vec4(color*color3*1.51+fc.xyz*col, 1.0);\n\tfragColor = color_final;\n   \n}","name":"Image","description":"","type":"image"}]}