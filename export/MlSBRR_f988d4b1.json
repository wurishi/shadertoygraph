{"ver":"0.1","info":{"id":"MlSBRR","date":"1514198169","viewed":713,"name":"KIFS fork","username":"tholzer","description":"marginally modifies KIFS shader from EvilRyu\nsee [url]https://www.shadertoy.com/view/MdlSRM[/url]\nmouse.x = scaling,  mouse.y = recursion","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// KIFS fork of https://www.shadertoy.com/view/MdlSRM\n\nfloat stime, ctime;\n \nvoid ry(inout vec3 p, float a)\n{\n  float ca = cos(a), sa = sin(a);\n  vec3 q = p;\n  p.x =  ca * q.x + sa * q.z;  \n  p.z = -sa * q.x + ca * q.z; \n}  \n\n/*\n  void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }\n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \n*/\n\nfloat plane(vec3 p, float y)\n{\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nvec3 mat = vec3(0.0);\nbool bcolor = false;\nvec2 mp = vec2(0);\n\nfloat menger_spone(in vec3 z0)\n{\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset = vec3(0.45+mp.x*6.6, 1.1, 0.46);\n    float scale = 2.48;\n\tfor (int n = 0; n < 5; n++)\n    {\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)mat+=vec3(0.5)+sin(z.xyz)*vec3(1.0, 0.24, 0.245);\n        // translate the middle cube to top right corner\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))z.z+=offset.z*(scale-1.0);\n        if (float(n-1) > mp.y*3.) break;\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.05)/z.w;\n}\n\nvec3 f(vec3 p)\n{\n  ry(p, stime);\n  float d1 = plane(p, -1.0);\n  float d2 = menger_spone(p);\n  if(d1 < d2)\n    return vec3(d1, 0.0, 0.0);\n  else\n    return vec3(d2, 1.0, 0.0);\n} \n\nfloat ao(vec3 p, vec3 n)\n{\n  float ao=0.0,sca=1.0; \n  for(float i=0.0;i<20.0;++i)\n  { \n \tfloat hr=0.05+0.015*i*i; \n \tao+=(hr-f(n*hr+p).x)*sca; \n \tsca*=0.75; \n  } \n  return 1.0-clamp(ao,0.0,1.0); \n} \n\nfloat rand(vec2 t)\n{\n  return fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float k)\n{ \n  float akuma=1.0,h=0.0; \n  float t = 0.01;\n  for(int i=0; i < 50; ++i)\n  { \n    h=f(ro+rd*t).x; \n    if(h<0.001){akuma=0.0;break;} \n    akuma=min(akuma, k*h/t); \n    t+=abs(h);\n  } \n  return clamp(akuma*0.8+0.2, 0.0, 1.0); \n} \n\nvec3 nor(vec3 p)\n{ \n  vec3 e=vec3(0.0001,0.0,0.0); \n  return normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n  \t\t\t\t\t    f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\tf(p+e.yyx).x-f(p-e.yyx).x)); \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n    mp = iMouse.xy / iResolution.xy; \n    if (iFrame < 88) mp = vec2(0.035,0.6);\n \tuv.x *= iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.2); \n \tctime=cos(iTime*0.2); \n\n \tvec3 ta=vec3(.0,0.0,0.0); \n \t//vec3 ro=vec3(3.0*stime,stime*2.0+1.0, 3.0*ctime); \n\tvec3 ro = vec3(3.5*ctime, 2.2+0.5*ctime, 5.8+1.0*stime) * 0.5;\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(-3.5, 7.0,2.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(0.6, 0.9, 1.4)*1.3;\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(sc,50.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n    if(res.x > 0.0)\n    {\n\t\tp = ro + res.x * rd;\n        bcolor = true;\n        mat=vec3(0.0);\n        vec3 n=nor(p);\n        mat/=6.0;\n        bcolor = false;\n        float occ = ao(p, n); \n        float shadow = softshadow(p, sundir, 10.0);\n\n        float dif = max(0.0, dot(n, sundir)); \n        float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n        float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n        float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n        vec3 lin = 5.5 * sun * dif * shadow; \n        lin += 0.8 * bac * sun * occ; \n        lin += 0.6 * sky * skycolor * occ; \n        lin += 3.0 * spe * occ; \n\n        col = lin *(vec3(0.9, 0.8, 0.6)*(1.0-res.y)+mat*res.y) *  0.2; \n        col=mix(col,bg, 1.0-exp(-0.02*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor.xyz = col; \n }","name":"Image","description":"","type":"image"}]}