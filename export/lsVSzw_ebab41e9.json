{"ver":"0.1","info":{"id":"lsVSzw","date":"1463605286","viewed":154,"name":"Rule30 swizzled","username":"akohdr","description":"By indexing rule qualifiers by vec3 we can swizzle the index to apply rules in each of six swizzle symmetries and by eight mirror symmetries by changing sign.\niMouse.y controls culling, upper iMouse.y shows state space.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["voxel","automata","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n#define EYE 90\n#define RES iResolution\n#define FRES_xy vec2(47)\n#define FRES vec3(FRES_xy,47)\n#define HALF (FRES/2.)\n#define FDIM vec3(floor(RES.xy/FRES.xy),FRES.z)\n\nbool isVoxel(out vec4 k, const in vec3 P)\n{\n    if(any(greaterThan(abs(P),HALF))) return false; \t// bounds check, kills repetition \n    vec3 p = P + HALF;\t\t  \t\t\t\t\t\t\t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    k = texture(iChannel0, (FRES_xy * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FRES_xy))/RES.xy);\n    return k.w>0.;\t\t\t\t\t\t\t\t\t\t// anything but black\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float T, Rx = RES.x, Ry = RES.y;\n    vec2 uv = P/RES.xy,\n         u = (P - vec2(0,.5)*Ry)/Rx - vec2(.5,0);\n    \n    if(iMouse.z>0.){\n        if (iMouse.y>250.){ k = texture(iChannel0, uv); return; } // show state space\n        T = 5.*iMouse.x/Rx;  \t\t\t\t\t\t\t// mouse rotate\n    } else\n        T = float(iFrame)/128.; \t\t\t\t\t\t// slow rotate\n    \n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<350; i++) {\n        float a=s.x, b=s.y, c=s.z;\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n        \n        float my = .2*iMouse.y, lf = length(f), mt = mod(iTime,24.);\n        if(\n           ((mt < 8. && .5*my<abs(f.z)+1.) ||\t\t  \t\t// iMouse.y culls in z-direction\t\n           (mt < 16. && mt> 8. && my<length(f)+1.) ||\t\t// iMouse.y culls out a sphere\t\n           (mt < 24. && mt>16. && my>lf+1. && my<lf+1.2)) &&\t// iMouse.y culls hollow spherical hull\n           isVoxel(k, f)) { k += vec4(m.x>.0 ? 0. : m.y>.0 ? .6 : .3); \n            return; } \t\t\t\t\t\t\t\t\t//early exit\n    }\n    k = texture(iChannel1, uv/3.)/3.; \t\t\t\t// background\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n// \t\t\t\t  Rule 30+symmetry cellular automata in 3D voxel space\n//\n\n// RQ is rule qualifier indexed by vec3 (i.e match color in 3D Moore neighborhood)\n#define R1_L RQ(vec3(0,-1,-1))\n#define R1_C RQ(vec3(0, 0,-1))\n#define R1_R RQ(vec3(0, 1,-1))\n\n// experiment with mirror and swizzle symmetries\n#define R2_L RQ(vec3(1, 1,-1) * vec3( 0,-1,-1).zyx)\n#define R2_C RQ(vec3(1, 1,-1) * vec3( 0, 0,-1).zyx)\n#define R2_R RQ(vec3(1, 1,-1) * vec3( 0, 1,-1).zyx)\n\n#define RES iResolution.xy\n#define FRES_xy vec2(47)\n#define FRES vec3(FRES_xy,47)\n#define FDIM vec3(floor(RES/FRES_xy),FRES.z)\n\n#define BLK vec4(0)\n#define GRN vec4(0,1,0,1)\n#define YEL vec4(.5,.5,0,1)\n#define ANY vec4(-1)\n\n#define VX(v,K) if(distance(v.xyz,q.xyz)<1.)k=K;\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    float z = p.z, w = FDIM.x;\n    return FRES_xy * floor(vec2(mod(z,w), z/w)) + mod(p.xy, FRES_xy);\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    vec2 f = floor(p/FRES_xy);\n    return vec4(mod(vec3(p, FDIM.x*f.y + f.x),FRES), 0);//iTime);\n}\n\n// mini-DSL for rule definitions / processing ==============================================\n#define APPLY(f) f(r);applyRule(q,r,k);\n#define CK(x,y,z) if(noMatch(q+vec4(x,y,z,1),RQ(vec3(x,y,z))))return;\n#define RULE(n) void n(out vec4 r[28]){clrRule(r,ANY);\n#define RQ(v) r[(int(dot(v+1.,vec3(3,9,1)))+1)]\n#define WHEN RQ(vec3(0))=\n#define OUT  r[0]=\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 dp, const in vec4 K)\n{\n    return K != ANY && \n       K.rgb != texture(iChannel0, prj4Dto2D(dp)/RES).rgb;\n}\n\nvoid applyRule(const in vec4 q, const in vec4 r[28], inout vec4 k)\n{\n//    for(int a=-1; a<2; a++)\n//\t    for(int b=-1; b<2; b++)\n//    \t\tfor(int c=-1; c<2; c++)\n//                CK(a,b,c)\n\n    // manual unrolling still fastest\n    CK(-1,-1,-1)    CK(-1,-1, 0)    CK(-1,-1, 1)\n    CK( 0,-1,-1)    CK( 0,-1, 0)    CK( 0,-1, 1)\n    CK( 1,-1,-1)    CK( 1,-1, 0)    CK( 1,-1, 1)\n        \n    CK(-1, 0,-1)    CK(-1, 0, 0)    CK(-1, 0, 1)\n    CK( 0, 0,-1)    CK( 0, 0, 0)    CK( 0, 0, 1)\n    CK( 1, 0,-1)    CK( 1, 0, 0)    CK( 1, 0, 1)\n        \n    CK(-1, 1,-1)    CK(-1, 1, 0)    CK(-1, 1, 1)\n    CK( 0, 1,-1)    CK( 0, 1, 0)    CK( 0, 1, 1)\n    CK( 1, 1,-1)    CK( 1, 1, 0)    CK( 1, 1, 1)        \n\n    k = r[0];\n}\n\nvoid clrRule(out vec4 k[28], const in vec4 K)\n{\n    k[ 0]=K;k[ 1]=K;k[ 2]=K;k[ 3]=K;k[ 4]=K;k[ 5]=K;k[ 6]=K;k[ 7]=K;k[ 8]=K;k[ 9]=K;\n    k[10]=K;k[11]=K;k[12]=K;k[13]=K;k[14]=K;k[15]=K;k[16]=K;k[17]=K;k[18]=K;k[19]=K;\n    k[20]=K;k[21]=K;k[22]=K;k[23]=K;k[24]=K;k[25]=K;k[26]=K;k[27]=K;\n}\n\n// local rules =============================================================================\n\n// Original Rule 30\nRULE(rule1a)\t\tWHEN BLK; R1_L = BLK; R1_C = BLK; R1_R = GRN;\tOUT GRN;}\nRULE(rule1b)\t\tWHEN BLK; R1_L = BLK; R1_C = GRN; R1_R = BLK;\tOUT GRN;}\nRULE(rule1c)\t\tWHEN BLK; R1_L = BLK; R1_C = GRN; R1_R = GRN;\tOUT GRN;}\nRULE(rule1d)\t\tWHEN BLK; R1_L = GRN; R1_C = BLK; R1_R = BLK;\tOUT GRN;}\n\n// Symmetry Rule 30\nRULE(rule2a)\t\tWHEN BLK; R2_L = BLK; R2_C = BLK; R2_R = GRN;\tOUT GRN;}\nRULE(rule2b)\t\tWHEN BLK; R2_L = BLK; R2_C = GRN; R2_R = BLK;\tOUT GRN;}\nRULE(rule2c)\t\tWHEN BLK; R2_L = BLK; R2_C = GRN; R2_R = GRN;\tOUT GRN;}\nRULE(rule2d)\t\tWHEN BLK; R2_L = GRN; R2_C = BLK; R2_R = BLK;\tOUT GRN;}\n\nRULE(ruleAge)\t\tWHEN GRN;\tOUT YEL;}\n\nvoid applyLocalRules(out vec4 k, const in vec2 p, const in vec4 q)\n{\n    vec4 r[28];\t\t   \t\t\t\t\t// rule buffer\n    k = texture(iChannel0, p/RES);\t// retrieve prior state\n    \n    APPLY(rule1a) APPLY(rule1b) APPLY(rule1c) APPLY(rule1d) \n    APPLY(rule2a) APPLY(rule2b) APPLY(rule2c) APPLY(rule2d) \n\n    APPLY(ruleAge)\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    vec4 q = prj2Dto4D(p);\t\t\t\t// 4D state position\n    \n    // bounds check prevents x/y wrap\n    //if(any(bvec4(greaterThan(q.xy,FRES.xy),lessThan(q.xy,vec2(1) )))) return; \t \n    \n    if(mod(iTime,8.)<1.) {\n        k = BLK;\t\t\t\t\t\t// automata initial condition seeding\n//        VX((FRES/2.), GRN)  \t\t\t// center\n        VX(vec3(0), GRN)\t\t\t\t// corner\n    }\n    else\n\t    applyLocalRules(k,p,q);\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}