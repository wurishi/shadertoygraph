{"ver":"0.1","info":{"id":"XlfBWf","date":"1513533429","viewed":374,"name":"Mercury Yin Yang","username":"steverock","description":"Was playing around with spherical harmonics, and noticed that a certain combo looked like a yin yang. Some hours later...","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265359\n\n#define GAMMA 2.2\nconst int SSR = 1;\n#define STAND_Y -0.6\n#define CAM_Z 10.\nconst float MAX_T = CAM_Z + 10.;\n\nvec3 gamma2linear(vec3 rgb) {\n    return pow(rgb, vec3(GAMMA));\n}\n\nvec2 rotate(vec2 u, float rads) {\n    float c = cos(rads);\n    float s = sin(rads);\n    return vec2(\n        c*u.x - s*u.y,\n        s*u.x + c*u.y);\n}\n\n// Two spherical harmonics for the hugging blobs\nconst float L1n1 = (1.0/2.0) * sqrt(3.0f/M_PI) * 5.;\nconst float L2p1 = (0.5) * sqrt(15.0 / M_PI) * 5.;\nfloat getBlob(vec3 v) {\n    return max(0.0,\n        L1n1 * v.y +\n        L2p1 * v.x * v.z);\n}\n\nfloat getDots(vec3 spherePt, vec3 dotDir) {\n    return smoothstep(0.99, 0.992, abs(dot(spherePt, normalize(dotDir))));\n}\n\nvec3 warpYYDir(vec3 dir) {\n    //return dir;\n    dir.x += 0.03 * sin(6.28*(dir.y+iTime/3.)/0.25);\n    return normalize(dir);\n}\n\n// Y for the white parts, 0 for the black\nfloat blackOrWhite(vec3 dir)\n{\n    float rotRad = 6.28*iTime/1.5;\n    float rotR = 0.08;\n    float dotZ = 0. + rotR*cos(rotRad);\n    float dotY = 0.75 + rotR*sin(rotRad);\n    float yyDot = max(\n        getDots(dir, normalize(vec3(1., dotY, dotZ))),\n        getDots(dir, normalize(vec3(-1., dotY, dotZ))));\n    float yyBlobs = smoothstep(0.49, 0.51, abs(getBlob(dir.xzy)));\n    float yyFinal = mix(yyBlobs, 1.0-yyBlobs, yyDot);\n\n    return yyFinal;\n}\n\nvec4 getYYSurf(vec3 dir) {\n    dir = warpYYDir(dir);\n    float bw = blackOrWhite(dir);\n    vec2 uv = vec2( atan( dir.x, dir.z ), acos(dir.y) );\n    vec3 whiteDiff = mix(gamma2linear(texture(iChannel1, uv).rgb), vec3(1.0), 0.4);\n    vec3 blackDiff = mix(gamma2linear(texture(iChannel2, uv).rgb), vec3(0.0), 0.995);\n    vec3 diff = mix(blackDiff, whiteDiff, bw);\n    float specexp = mix(12.0, 1.0, bw);\n    return vec4(diff, specexp);\n}\n\nfloat pearlSD(vec3 p) {\n    vec3 dir = normalize(p);\n    float bw = blackOrWhite(warpYYDir(dir));\n    vec2 uv = vec2( atan( dir.x, dir.z ), acos(dir.y) );\n    float wave = mix(\n        0.,\n        sin(6.28*(uv.y+iTime/2.)*4.),\n        bw);\n    return length(p) - 0.5 - bw*0.015\n        + wave*.001;\n}\n\nfloat getSD(vec3 p)\n{\n    return pearlSD(p);\n}\n\n// Copy/pasted from https://www.shadertoy.com/view/MsXGz4\nconst float precis = 0.001;\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat h = precis * 2.0;\n    float t = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        if( abs(h) < precis || t > MAX_T )\n            break;\n        t += h;\n\t    h = getSD( ro+rd*t );\n    }\n    return t;\n}\n\n// Copy/pasted from https://www.shadertoy.com/view/MsXGz4\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(precis,0.0,0.0);\n    vec3 nor;\n    nor.x = getSD(pos+eps.xyy) - getSD(pos-eps.xyy);\n    nor.y = getSD(pos+eps.yxy) - getSD(pos-eps.yxy);\n    nor.z = getSD(pos+eps.yyx) - getSD(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 rotateCam(vec3 ro) {   \n    float t = fract(iTime/12.) * 2.;\n    float transTime = 0.4;\n    t = floor(t) + smoothstep(0.5-transTime, 0.5+transTime, fract(t));\n    float rads = 3.14 * (t+0.5);\n    ro.xz = rotate(ro.xz, rads);\n    return ro;   \n }\n\nvec3 getSample(vec2 fragCoord) {\n    // Copy/pasted from https://www.shadertoy.com/view/MsXGz4    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\t\n    // camera\n    vec3 ro = rotateCam(vec3(0., 0., CAM_Z));\n    vec3 camUpish = vec3(0.0,1.0,0.0);\n    vec3 ww = normalize(ro - vec3(0.0,0.0,0.0));\n    vec3 uu = normalize(cross( camUpish, ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv - 15.*ww );\n    \n    float t = intersect(ro,rd);\n    if( t < MAX_T )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 view = -1. * rd;\n        vec3 refl = normalize(reflect(rd, nor));\n        vec4 yySurf = getYYSurf(normalize(pos));\n        vec3 rimLitCol = vec3(1.0, 1.0, 0.8) * 0.5;\n        vec3 rim = pow(1.0-max(dot(nor, view), 0.0), yySurf.a) * rimLitCol;\n        vec3 indir = gamma2linear(texture(iChannel0, refl).rgb);\n        return (indir)*yySurf.rgb + rim;\n    }\n    else {\n        return 0.1 * gamma2linear(texture(iChannel0, rd).rgb);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float totalWeight = 0.;\n    vec3 totalRGB = vec3(0.);\n    \n    for(int i = -SSR; i <= SSR; i++) {\n        for(int j = -SSR; j <= SSR; j++) {\n            vec2 fragDelta = vec2(float(i), float(j))*0.5;\n            totalWeight += 1.;\n            totalRGB += getSample(fragCoord.xy + fragDelta);\n        }\n    }\n    \n    fragColor = vec4( pow(totalRGB/totalWeight, vec3(1.0/GAMMA)), 1.0);\n}","name":"Image","description":"","type":"image"}]}