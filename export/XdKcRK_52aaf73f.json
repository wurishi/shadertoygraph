{"ver":"0.1","info":{"id":"XdKcRK","date":"1522720326","viewed":254,"name":"Chrome Robo - PBR","username":"shau","description":"Rendering of chrome robo logo thing using PBR from knarkowicz","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//PBR from knarkowicz\n//https://www.shadertoy.com/view/4sSfzK\n\n#define time iTime\n\nconst float GA = 4.399; \nconst mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n//simplyfried version of Dave Hoskins blur borrowed from Virgilll\nvec3 dof(sampler2D tex,vec2 uv,float rad) {\n\tvec3 acc = vec3(0.0);\n    vec2 pixel = vec2(0.002 * iResolution.y / iResolution.x, 0.002), angle = vec2(0.0, rad);;\n    rad=1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1.0 / rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n    \n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LOOP_LENGTH 34.25\n#define T mod(iTime, LOOP_LENGTH)\n#define N_PATH_POINTS 38\n\n//Dave Hoskins - Pylon \n//https://www.shadertoy.com/view/XltSRf\n//Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    \n    vec3 c2 = -0.5 * p0\t+  0.5 * p2;\n\tvec3 c3 =        p0\t+ -2.5 * p1 +  2.0 * p2 + -0.5 * p3;\n    vec3 c4 = -0.5 * p0\t+  1.5 * p1 + -1.5 * p2 +  0.5 * p3;\n\t\n    return(((c4 * t + c3) * t + c2) * t + p1);\n}\n\nvoid positionsAtTime(inout vec3 cameraPosition, inout vec3 lookAtPosition) {\n    \n    //initialise camera arrays\n    //number of positions must be +3 number of seconds that loop plays\n    vec3 cameraPath[N_PATH_POINTS];\n    cameraPath[0]  = vec3( 4.0,  1.0, -7.0);\n    cameraPath[1]  = vec3( 3.1,  0.9, -6.6);\n    cameraPath[2]  = vec3( 2.2,  0.3, -6.3);\n    cameraPath[3]  = vec3( 1.5, -1.3, -6.0);\n    cameraPath[4]  = vec3( 1.0, -2.2, -5.8);\n    cameraPath[5]  = vec3( 0.9, -3.0, -5.6);\n    cameraPath[6]  = vec3( 1.0, -2.8, -5.4);\n    cameraPath[7]  = vec3( 0.9, -2.1, -5.1);\n    cameraPath[8]  = vec3( 0.7, -1.5, -4.9);\n    cameraPath[9]  = vec3( 0.2,  0.0, -4.8);\n    cameraPath[10] = vec3( 0.3,  0.1, -4.7);\n    cameraPath[11] = vec3( 0.8,  0.2, -4.6);\n    cameraPath[12] = vec3( 1.5,  0.0, -4.4);\n    cameraPath[13] = vec3( 2.0,  0.0, -4.4);\n    cameraPath[14] = vec3( 2.6, -0.2, -4.4);\n    cameraPath[15] = vec3( 2.5,  0.0, -4.4);\n    cameraPath[16] = vec3( 2.2, -0.1, -4.4);\n    cameraPath[17] = vec3( 1.3,  0.0, -4.4);\n    cameraPath[18] = vec3( 0.5,  0.0, -4.4);\n    cameraPath[19] = vec3( 0.1,  0.1, -4.4);\n    cameraPath[20] = vec3(-0.2,  0.0, -4.4);\n    cameraPath[21] = vec3(-0.9,  0.2, -4.4);\n    cameraPath[22] = vec3(-1.7,  0.3, -4.4);\n    cameraPath[23] = vec3(-2.0,  0.5, -4.4);\n    cameraPath[24] = vec3(-1.8,  0.3, -4.4);\n    cameraPath[25] = vec3(-1.2,  0.4, -4.4);\n    cameraPath[26] = vec3(-0.7,  0.3, -4.4);\n    cameraPath[27] = vec3(-0.3,  0.1, -4.4);\n    cameraPath[28] = vec3(-0.1,  0.3, -4.4);\n    cameraPath[29] = vec3( 0.0,  0.3, -4.4);\n    cameraPath[30] = vec3( 0.1,  0.4, -4.4);\n    cameraPath[31] = vec3( 0.2,  0.2, -4.4);\n    cameraPath[32] = vec3( 0.1,  0.1, -4.4);\n    cameraPath[33] = vec3( 0.0,  0.0, -4.4);\n    cameraPath[34] = vec3(-0.1,  0.1, -4.4);\n    cameraPath[35] = vec3( 0.0,  0.2, -4.4);\n    cameraPath[36] = vec3( 0.0,  0.0, -4.4);\n    cameraPath[37] = vec3( 0.0,  0.0, -4.4);\n\n    vec3 lookAtPath[N_PATH_POINTS];\n    lookAtPath[0]  = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[1]  = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[2]  = vec3( 0.0, -0.6, 0.0);\n    lookAtPath[3]  = vec3( 0.0, -1.8, 0.0);\n    lookAtPath[4]  = vec3( 0.0, -3.2, 0.0);\n    lookAtPath[5]  = vec3( 0.0, -3.6, 0.0);\n    lookAtPath[6]  = vec3( 0.0, -3.6, 0.0);\n    lookAtPath[7]  = vec3( 0.0, -3.0, 0.0);\n    lookAtPath[8]  = vec3( 0.0, -2.2, 0.0);\n    lookAtPath[9]  = vec3( 0.0, -1.0, 0.0);\n    lookAtPath[10] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[11] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[12] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[13] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[14] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[15] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[16] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[17] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[18] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[19] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[20] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[21] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[22] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[23] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[24] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[25] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[26] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[27] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[28] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[29] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[30] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[31] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[32] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[33] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[34] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[35] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[36] = vec3( 0.0,  0.0, 0.0);\n    lookAtPath[37] = vec3( 0.0,  0.0, 0.0);\n\n    int nt = int(T);\n    float ft = fract(T);\n    \n    vec3 p0 = cameraPath[nt];\n    vec3 p1 = cameraPath[nt + 1];\n    vec3 p2 = cameraPath[nt + 2];\n    vec3 p3 = cameraPath[nt + 3];\n    \n    cameraPosition = spline(p0, p1, p2, p3, ft);\n    \n    p0 = lookAtPath[nt];\n    p1 = lookAtPath[nt + 1];\n    p2 = lookAtPath[nt + 2];\n    p3 = lookAtPath[nt + 3];\n\n    lookAtPosition = spline(p0, p1, p2, p3, ft);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    vec3 cameraPosition, lookAtPosition;\n    positionsAtTime(cameraPosition, lookAtPosition);\n    \n    if (int(fragCoord.y) == 0) {\n        if (int(fragCoord.x) == 0) {\n            fragColor = vec4(cameraPosition, 1.0);\n        } else if (int(fragCoord.x) == 1) {\n            fragColor = vec4(lookAtPosition, 1.0);\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//PBR from knarkowicz\n//https://www.shadertoy.com/view/4sSfzK\n\n#define LOOP_LENGTH 34.25\n#define T mod(iTime, LOOP_LENGTH)\n#define PI 3.14159265359\n#define EPS 0.005\n\n#define INNER_SEG_1 1.0\n#define INNER_SEG_2 2.0\n#define INNER_SEG_3 3.0\n#define CORE 4.0\n#define OUTER_SHELL 5.0\n#define OUTER_SHELL_RIM 6.0 \n#define BLADE 7.0\n#define PEDESTAL 8.0\n#define WALL 9.0\n#define LABEL 10.0\n#define INNER_BALL 11.0\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\nfloat saturate(float x) {return clamp(x, 0.0, 1.0);}\nvec3 saturate(vec3 x) {return clamp(x, vec3(0.0), vec3(1.0));}\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\nvec3 glowColour() {return palette(T * 0.1, CA, CB, CC, CD);}\n\n//Dave Hoskins - Noise and Hashing\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\nvec3 noise3(float n) {\n    float f = fract(n);\n    n = floor(n);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash31(n), hash31(n + 1.0), f);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n    vec2 uv;\n};\n  \n/* Distance function from IQ, Mercury and Shane */\n\nfloat smax( float a, float b, float k ){\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// see mercury sdf functions\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.0;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nfloat boxIntersection(vec3 ro, vec3 rd, vec3 boxSize, inout vec3 outNormal) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return (tN > tF || tF < 0.0) ? 0.0 : tN;\n}\n\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    return -b - sqrt(h);\n}\n\nfloat boxOcclusion( vec3 pos, vec3 nor, mat4 boxTx, vec3 boxSize) {\n    \n    vec3 p = (boxTx*vec4(pos,1.0)).xyz;\n    vec3 n = (boxTx*vec4(nor,0.0)).xyz;\n    \n    // 8 verts\n    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*boxSize - p);\n    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*boxSize - p);\n    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*boxSize - p);\n    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*boxSize - p);\n    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*boxSize - p);\n    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*boxSize - p);\n    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*boxSize - p);\n    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*boxSize - p);\n    \n    // 12 edges\n    float k02 = dot(n,normalize(cross(v2,v0)))*acos(dot(v0,v2));\n    float k23 = dot(n,normalize(cross(v3,v2)))*acos(dot(v2,v3));\n    float k31 = dot(n,normalize(cross(v1,v3)))*acos(dot(v3,v1));\n    float k10 = dot(n,normalize(cross(v0,v1)))*acos(dot(v1,v0));\n    float k45 = dot(n,normalize(cross(v5,v4)))*acos(dot(v4,v5));\n    float k57 = dot(n,normalize(cross(v7,v5)))*acos(dot(v5,v7));\n    float k76 = dot(n,normalize(cross(v6,v7)))*acos(dot(v7,v6));\n    float k37 = dot(n,normalize(cross(v7,v3)))*acos(dot(v3,v7));\n    float k64 = dot(n,normalize(cross(v4,v6)))*acos(dot(v6,v4));\n    float k51 = dot(n,normalize(cross(v1,v5)))*acos(dot(v5,v1));\n    float k04 = dot(n,normalize(cross(v4,v0)))*acos(dot(v0,v4));\n    float k62 = dot(n,normalize(cross(v2,v6)))*acos(dot(v6,v2));\n    \n    // 6 faces    \n    float occ = 0.0;\n    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );\n    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );\n    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );\n    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );\n    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );\n    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );\n        \n    return occ / 6.283185;\n}\n\n/* MODEL */\n\nfloat dfOuterShellSegment(vec3 rp, float at) {\n    \n    float ns = smax(sdSphere(rp, 1.1), -sdCapsule(rp, vec3(0.0, 0.0, 1.1), vec3(0.0, 0.0, -1.1), 0.4), 0.05);\n    \n    //animate\n    ns = max(ns, -sdBox(rp - vec3(0.0, 0.0, at), vec3(1.2, 1.2, 1.1)));\n    \n    ns = smax(ns, -sdBox(rp - vec3(-1.0, -1.0, 0.0), vec3(1.2, 1.0, 1.2)), 0.05);\n    ns = max(ns, -sdBox(rp - vec3(1.2, -0.6, 0.0), vec3(1.2, 1.0, 1.2)));\n    rp.xy *= rot(PI / 1.5);\n    ns = smax(ns, -sdBox(rp - vec3(0.0, 1.3, 0.0), vec3(1.2, 1.0, 1.2)), 0.05);\t\n    return max(ns, -sdSphere(rp, 1.05));\n}\n\nvec2 dfOuterShell(vec3 rp) {\n    \n    //animate outer shell collapsing front to back\n    float outerShellOffset = -clamp((T - 10.0) * 3.0, 0.0, 1.6) * step(10.0, T);\n    outerShellOffset += clamp((T - 25.2) * 2.0, 0.0, 1.6) * step(25.2, T);\n\n    float shell = dfOuterShellSegment(rp, outerShellOffset);\n    rp.xy *= rot(PI / 1.5);\n    shell = min(shell, dfOuterShellSegment(rp, outerShellOffset));\n    rp.xy *= rot(PI / 1.5);\n    shell = min(shell, dfOuterShellSegment(rp, outerShellOffset));\n    \n    float rim = sdSphere(rp, 1.1);\n    rim = max(rim, -sdBox(rp - vec3(0.0, 0.0, outerShellOffset + 2.2), vec3(1.2, 1.2, 1.1)));\n    rim = max(rim, -sdSphere(rp, 1.05));\n    rim = smax(rim, -sdBox(rp - vec3(0.0, 0.0, outerShellOffset - 0.1), vec3(1.1, 1.1, 1.1)), 0.05);\n    \n    return nearest(vec2(shell, OUTER_SHELL), vec2(rim, OUTER_SHELL_RIM));\n}\n\nfloat dfShellSegment(vec3 rp) {\n    \n    vec3 q = rp;\n    \n    //animate - rotate blades sideways to hide\n    float innerShellRotationAngle = clamp((T - 10.6) * 6.0, 0.0, PI / 1.5) * step(10.6, T);\n    innerShellRotationAngle -= clamp((T - 25.0) * 4.0, 0.0, PI / 1.5) * step(25.0, T);\n    rp.xy *= rot(innerShellRotationAngle);\n    \n    float ns = sdSphere(rp, 1.0);\n    ns = smax(ns, -sdCapsule(rp, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), 0.4), 0.05);\n    ns = smax(ns, -sdBox(rp - vec3(-1.0, -1.0, 0.0), vec3(1.2, 1.0, 1.0)), 0.05);\n    ns = max(ns, -sdBox(rp - vec3(1.0, -0.6, 0.0), vec3(1.0, 1.0, 1.0)));\n    \n    q.xy *= rot(PI / 1.5);\n    float cut = sdBox(q - vec3(0.0, 1.3, 0.0), vec3(1.0, 1.0, 1.0));\n    cut = min(cut, sdBox(q - vec3(-1.0, 0.9, 0.0), vec3(1.0, 1.0, 1.0)));\n    ns = max(ns, -cut);\t\n    \n    return max(ns, -sdSphere(rp, 0.95));\n}\n\nvec2 dfShell(vec3 rp) {\n    vec2 near = vec2(dfShellSegment(rp), INNER_SEG_1);\n    rp.xy *= rot(PI / 1.5);\n    near = nearest(near, vec2(dfShellSegment(rp), INNER_SEG_2));\n    rp.xy *= rot(PI / 1.5);\n    return nearest(near, vec2(dfShellSegment(rp), INNER_SEG_3));\n    //*/\n    //return near;\n}\n\nvec2 dfLogo(vec3 rp) {\n\tvec2 near = dfShell(rp);\n    float core = sdCapsule(rp, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), 0.35);\n    core = smax(core, sdSphere(rp, 1.0), 0.15);\n    near = nearest(near, vec2(core, CORE));\n    near = nearest(near, vec2(sdSphere(rp, 0.95) + (100.0 * step(10.0, T) * step(T, 26.0)), INNER_BALL));\n    return near;\n}\n\nvec4 dfBlades(vec3 rp) {\n    \n    vec2 uv = vec2(0.0);\n    float bladeSpinSpeed = sin((T - 10.6) * 0.6) * 12.0 * step(10.6, T) * step(T, 23.5);\n    float bladeAngle = sin((T - 10.6) * 0.3) * 0.4 * step(10.6, T);\n    \n    //animate blade spin\n    rp.xy *= rot(bladeSpinSpeed);\n    \n    vec3 q = rp;    \n    pModPolar(rp.yx, 16.0);\n    rp -= vec3(0.0, 0.5, -0.65);\n    \n    uv = rp.xy + vec2(0.05);\n    \n    //animate angle of blades\n    rp.xy *= rot(bladeAngle);\n    \n    rp.yz *= rot(0.7);\n    float blade = sdBox(rp, vec3(0.2, 0.5, 0.02));\n    blade = max(blade, sdSphere(q, 0.95));\n    blade = max(blade, -sdCapsule(q, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), 0.38));\n    \n    return vec4(blade, BLADE, uv);\n}\n\nvec4 map(vec3 rp) {  \n    \n    //robo thing\n    vec2 near = dfLogo(rp);\n    vec4 blades = dfBlades(rp);\n    near = nearest(near, blades.xy);\n    near = nearest(near, dfOuterShell(rp));\n        \n    return vec4(near, blades.zw);\n}\n\n// Tetrahedral normal IQ\nvec3 tnormal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\n// Based on original by IQ.\n// https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 rp, vec3 n) {\n\n    float r = 0.0;\n    float w = 1.0;\n    float d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(rp + n * d).x);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\nfloat shadow(vec3 ro, vec3 lp) {\n\n    vec3 rd = normalize(lp - ro);\n    float shade = 1.0;\n    float t = 0.05;    \n    float end = length(lp - ro);\n    \n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        shade = min(shade, smoothstep(0.1, 0.5, 2.0 * h / t));\n        t += clamp(h, 0.01, 1.);\n        if (h < EPS || t > end) break; \n    }\n\n    return min(max(shade, 0.) + 0.15, 1.0);\n}\n\nvec4 march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    float id = 0.0;\n    vec2 uv = vec2(0.0);\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        vec4 ns = map(rp);\n        if (ns.x < EPS || t > 20.0) {\n            id = ns.y;\n            uv = ns.zw;\n            break;\n        }\n        t += ns.x;\n    }\n    \n    return vec4(t, id, uv);\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n    float mint = 50.0;\n    float id = 0.0;\n    vec3 minn = vec3(0.0);\n    vec2 uv;\n    \n    //walls\n    vec3 w1o = vec3(0.0, 0.0, 10.0);\n    vec3 w1n = vec3(0.0, 0.0, -1.0);\n    \n    float w1t = planeIntersection(ro, rd, w1n, w1o);\n    if (w1t > 0.0 && w1t < mint) {\n\t\tmint = w1t;\n        id = WALL;\n        minn = w1n;\n    }\n    //*/\n    \n    vec3 w2o = vec3(-10.0, 0.0, 0.0);\n    vec3 w2n = vec3(1.0, 0.0, 0.0);\n    float w2t = planeIntersection(ro, rd, w2n, w2o);\n    if (w2t > 0.0 && w2t < mint) {\n\t\tmint = w2t;\n        id = WALL;\n        minn = w2n;\n    }\n    //*/\n    \n    //pedestal\n    vec3 pn = vec3(0.0);\n    float pt = boxIntersection(ro - vec3(0.0, -7.0, 0.0), rd, vec3(2.2, 4.0, 2.2), pn); \n    if (pt > 0.0 && pt < mint) {\n\t\tmint = pt;\n        id = PEDESTAL;\n        minn = pn;\n    }\n    \n    //label\n    vec3 ln = vec3(0.0);\n    float lt = boxIntersection(ro - vec3(1.0, -3.6, -2.21), rd, vec3(1.0, 0.3, 0.02), ln); \n    if (lt > 0.0 && lt < mint) {\n\t\tmint = lt;\n        id = LABEL;\n        minn = ln;\n    }\n\n    //google robo\n    float grt = sphIntersect(ro, rd, vec4(0.0, 0.0, 0.0, 1.1));\n    if (grt > 0.0) { //bounds check\n        vec4 scene = march(ro, rd);\n        if (scene.x > 0.0 && scene.x < mint) {\n            mint = scene.x;\n            id = scene.y;\n            uv = scene.zw;\n            minn = tnormal(ro + rd * scene.x);\n        }\n    }\n    \n    return Scene(mint, id, minn, uv);\n}\n\n/* SHADING */\n\nvec3 bladeAnim(vec2 uv) {\n    vec3 pc = texture(iChannel3, uv * 4.0).xyz;\n    pc += glowColour() * uv.y * uv.y * 4.0;\n    return pc; \n}\n\n//Otavio Good\n//https://www.shadertoy.com/view/llcXR\nfloat labelText(vec3 rp) {\n\n    vec4 text = vec4(0.0);\n    \n    // Do some tricks with the UVs\n    vec2 uv = (rp.xy * 6.4) + vec2(-4.0, 23.0);\n    vec2 fl = floor(uv + 0.5);\n    \n    if (abs(fl.y) < 1.0) {\n        if (fl.x == -3.0) {\n            uv += vec2(22.0, 10.0); //S\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == -2.0) { \n            uv += vec2(10.0, 11.0); //H\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == -1.0) {\n            uv += vec2(2.0, 11.0); //A\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 0.0) {\n            uv += vec2(21.0, 10.0); //U\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 2.0) {\n            uv += vec2(21.0, 10.0); //W\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 3.0) {\n            uv += vec2(12.0, 11.0); //O\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 4.0) {\n            uv += vec2(22.0, 10.0); //Z\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 6.0) {\n            uv += vec2(-1.0, 11.0); //E\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 7.0) {\n            uv += vec2(11.0, 10.0); //R\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n        } else if (fl.x == 8.0) {\n            uv += vec2(13.0, 11.0); //E\n            text = texture(iChannel2, (uv + 0.5) * (1.0 / 16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);    \n        }\n    }\n    \n    return 1.0 - text.x;\n}\n\nvec3 fresnelSchlick(float vdoth, vec3 specularColour) {\n    return specularColour + (1.0 - specularColour) * pow(1.0 - vdoth, 5.0);\n} \n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat geometrySchlickGGX(float ndot, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    float nom = ndot;\n    float denom = ndot * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat geometrySmith(float roughness, float ndotv, float ndotl) {\n    float ggx2  = geometrySchlickGGX(ndotv, roughness);\n    float ggx1  = geometrySchlickGGX(ndotl, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 envBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;  \n}\n\n// St. Peter's Basilica SH\n// https://www.shadertoy.com/view/lt2GRD\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients SH_STPETER = SHCoefficients(\n    vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    vec3(-0.0818750, -0.0321501,  0.0033399 )\n);\n\nvec3 SHIrradiance(vec3 nrm) {\n    const SHCoefficients c = SH_STPETER;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * ( nrm.x * nrm.x - nrm.y * nrm.y ) +\n        c3 * c.l20 * nrm.z * nrm.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\n        2.0 * c1 * c.l21  * nrm.x * nrm.z +\n        2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\n        2.0 * c2 * c.l11  * nrm.x +\n        2.0 * c2 * c.l1m1 * nrm.y +\n        2.0 * c2 * c.l10  * nrm.z\n    );\n}\n\nvec3 envRemap(vec3 c) {\n    return pow(2.0 * c, vec3(2.2));\n}\n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n \n    vec3 lp1 = vec3(12.0, 100.0, -8.0); //light positions\n    vec3 lp2 = vec3(20.0, 10.0, -12.0); \n    \n    vec3 baseColour = vec3(0.0); //surface colour\n    float metallic = 0.0;  //metalic\n    float roughness = 0.0; //roughness\n\n    //segment and core colours\n    vec3 seg1Colour = vec3(1.0);\n    vec3 seg2Colour = vec3(1.0);\n    vec3 seg3Colour = vec3(1.0);\n    vec3 coreColour = vec3(1.0);\n    \n    //switch to google colours\n    if (T > 25.0) {\n        seg1Colour = vec3(1.0, 0.0, 0.0);    \n        seg2Colour = vec3(0.0, 1.0, 0.0);    \n        seg3Colour = vec3(1.0, 1.0, 0.0);    \n    }\n    if (T > 25.3) {\n        coreColour = vec3(0.3, 0.3, 1.0);    \n    }\n    \n    vec3 rp = ro + rd * scene.t; //ray - scene intersection point\n    vec3 n = scene.n; //normal\n    vec3 ld = normalize(lp1 - rp); //spot light direction\n    vec3 ald = normalize(lp2 - rp); //ambient light direction\n    float lt = length(lp1 - rp); //distance to spot light\n    vec3 rrd = reflect(rd, scene.n); //reflected ray direction    \n    float sh = 1.0; //shadow(rp, lp1);    \n    float ao = AO(rp, n);\n    \n    if (scene.id == INNER_SEG_1) {\n\n        baseColour = seg1Colour;    \n        roughness = 0.2;\n\n    } else if (scene.id == INNER_SEG_2) {\n\n        baseColour = seg2Colour;    \n        roughness = 0.2;\n\n    } else if (scene.id == INNER_SEG_3) {\n\n        baseColour = seg3Colour;    \n        roughness = 0.2;\n\n    } else if (scene.id == CORE) {\n\n        baseColour = coreColour;   \n        roughness = 0.2;\n        if (T > 10.6 && T < 25.3) {\n            metallic = 1.0;    \n        }\n\n    } else if (scene.id == OUTER_SHELL) {\n\n        baseColour = vec3(1.0, 1.0, 1.0);   \n        roughness = 0.2;\n\n    } else if (scene.id == OUTER_SHELL_RIM) {\n\n        baseColour = vec3(0.4, 0.4, 0.4);   \n        metallic = 1.0;\n\n    } else if (scene.id == BLADE) {\n\n        baseColour = bladeAnim(scene.uv);   \n        roughness = 0.7;\n\n    } else if (scene.id == PEDESTAL) {\n\n        baseColour = vec3(1.0, 1.0, 1.0);\n        roughness = 0.8;\n        if (n.y > 0.8) {\n            sh = shadow(rp, lp1);\n        }\n\n    } else if (scene.id == LABEL) {\n\n        vec2 uv = rp.xy - vec2(1.0, 2.0);\n        baseColour = vec3(1.0, 1.0, 1.0) * labelText(rp);\n        \n        roughness = 0.8;\n\n    } else if (scene.id == WALL) {\n\n        baseColour = vec3(1.0, 1.0, 1.0); \n        roughness = 0.8;\n    }\n    \n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    \n    vec3 diffuseColour = metallic == 1. ? vec3(0.0) : baseColour;\n    vec3 specularColour = metallic == 1.0 ? baseColour : vec3(0.02);\n    float roughnessE = roughness * roughness;\n    float roughnessL = max(0.01, roughnessE);\n\n    vec3 h = normalize(-rd + ld);\n    float vdoth = saturate(dot(-rd, h));\n    float ndoth\t= saturate(dot(scene.n, h));\n    float ndotv = saturate(dot(scene.n, -rd));\n    float ndotl = saturate(dot(scene.n, ld));\n    vec3 envSpecularColour = envBRDFApprox(specularColour, roughnessE, ndotv);\n    \n    vec3 env1 = envRemap(texture(iChannel1, rrd).xyz);\n    vec3 env2 = envRemap(SHIrradiance(rrd)); \n    env1 = mix(env1, env2, saturate((roughnessE - 0.25) / 0.75));\n\n    diffuse += diffuseColour * envRemap(SHIrradiance(n));\n    specular += envSpecularColour * env1;\n\n\tdiffuse += diffuseColour * saturate(dot(n, ld));\n\n    vec3 lightF = fresnelSchlick(vdoth, specularColour);\n    float lightD = distributionTerm(roughnessL, ndoth);\n    float lightV = geometrySmith(roughnessL, ndotv, ndotl);\n    specular += vec3(2.0) * lightF * (lightD * lightV * PI * ndotl);\n    \n    diffuse *= ao * sh;\n    specular *= saturate(pow(ndotv + ao, roughnessE) - 1.0 + ao);\n        \n    return diffuse + specular;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy).xyz;\n    ro = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xyz;\n    \n    //camera shake\n    lookAt += (0.1 * noise3(T * 3.0) - 0.5) + sin(T * 2.0) * 0.1;\n   \n    //focal length\n    float fl = 3.0 + clamp((T - 1.4) * 0.4, 0.0, 1.0);\n    fl -= clamp((T - 6.0), 0.0, 1.0);\n    fl += clamp((T - 10.0) * 0.4, 0.0, 1.5);\n    fl -= clamp((T - 17.0) * 0.4, 0.0, 1.0);\n\n    \n    float FOV = PI / fl;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 pc = vec3(0.0);\n    float mint = 50.0;\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    \n    if (scene.t > 0.0 && scene.t < 50.0) {\n       mint = scene.t; \n       pc = colourScene(ro, rd, scene);  \n    }\n    \n    fragColor = vec4(pc, mint / 50.0);\n}","name":"Buf B","description":"","type":"buffer"}]}