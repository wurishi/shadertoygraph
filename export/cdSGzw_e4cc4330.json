{"ver":"0.1","info":{"id":"cdSGzw","date":"1667345279","viewed":112,"name":"SDF sphere union","username":"sm00thmanif0ld","description":"SDF sphere union","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// d1 : sphere sdf 1\n// d2 : sphere sdf 2\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// d1 : sphere sdf 1\n// d2 : sphere sdf 2\n// k : smooth step\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    // Set this to a constant to stop the animation\n    float an = sin(iTime);\n\n    // opUnion\n    {\n        vec3 q = pos - vec3(-3.0,0.0,0.0);\n        float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n        float d2 = sdSphere( q-vec3(0.0,0.0,0.0), 0.6 );\n        float dt = opUnion(d1,d2);\n        d = min( d, dt );\n    }\n    \n    // opSmoothUnion\n    {\n    vec3 q = pos - vec3(-1.0,0.0,0.0);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdSphere( q-vec3(0.0,0.0,0.0), 0.6 );\n    float dt = opSmoothUnion(d1,d2, 0.25);\n    d = min( d, dt );\n    }\n    \n\n    // Multiple spheres, opUnion\n    for( int i=1; i<5; i++ )\n    {\n        vec3 q = pos - vec3(1.0,0.0,0.0);\n        float d1 = sdSphere( q-vec3(0.0,0.3*pow(float(i-1),1.5) - 1.0,0.0), 0.5 );\n        float d2 = sdSphere( q-vec3(0.0,0.3*pow(float(i),1.5) - 1.0,0.0), 0.5 );\n        float dt = opUnion(d1,d2);\n        d = min( d, dt );\n    }\n    \n\n    // Multiple spheres, opSmoothUnion\n    for( int i=1; i<5; i++ )\n    {\n        vec3 q = pos - vec3(3.0,0.0,0.0);\n        float d1 = sdSphere( q-vec3(0.0,0.3*pow(float(i-1),1.5) - 1.0,0.0), 0.5 );\n        float d2 = sdSphere( q-vec3(0.0,0.3*pow(float(i),1.5) - 1.0,0.0), 0.5 );\n        float dt = opSmoothUnion(d1,d2, 0.15*float(i));\n        d = min( d, dt );\n    }\n    \n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n                      e.yyx*map( pos + e.yyx*ep ) + \n                      e.yxy*map( pos + e.yxy*ep ) + \n                      e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n        tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}