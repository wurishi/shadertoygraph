{"ver":"0.1","info":{"id":"4lKXDm","date":"1484637999","viewed":140,"name":"indicator gui","username":"madware","description":"dot gui shader mockup","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this define is only for testing. The real gui quad wouldn't be wanted in it\n#define deformer\n#define v_deformer 12.0\n#define yShift 4.5\n#define u_deformer 3.0\n\nfloat dotInfoPacked = \n    (7.0 * 16.0 + // dotCount\n     5.0)         // activeDotId\n    / 256.0;\n\nfloat epsilon = 0.175;\nfloat dotScale = 0.35;\nfloat opacity = 1.0;\nfloat activeDotMagnify = 0.25;\n    \nvec3 inactiveColor = vec3(0.9, 0.9, 0.9);\nvec3 activeColor   = vec3(1.0, 0.7, 0.0);\n\nvoid unpackDotInfo(in float packedInfo, out float dotCount, out float activeDotId)\n{\n    dotCount = ceil(packedInfo * 16.0 - 0.5);\n    activeDotId = fract(packedInfo * 16.0) * 16.0 + 1.0;\n}\n\nvec3 CheckSquare(in vec2 sqrPos, in vec2 sqrSize, in vec2 p)\n{\n    vec2 sqrSizeModified = vec2(sqrSize.x, sqrSize.y);\n    vec2 topRight = sqrPos + sqrSizeModified;\n    float isIn = float( all(greaterThanEqual(p, sqrPos)) &&\n                        all(lessThanEqual(p, topRight)));\n    vec2 uv = (p - sqrPos) / sqrSizeModified;\n    return vec3(isIn, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dotShift = fract(iTime);\n    \n    float f_dotCount, f_activeDotId;\n    unpackDotInfo(dotInfoPacked, f_dotCount, f_activeDotId);\n    f_activeDotId += dotShift;\n        \n    #ifdef deformer\n        vec2 uv_original = fragCoord.xy / iResolution.xy;    \n\t    vec2 uv = uv_original; \n        uv.x = min(max(0.0, uv.x * u_deformer - (u_deformer - 1.0) * 0.5), 1.0);\n        uv.y *= v_deformer;\n        uv.y -= (v_deformer-1.0) * 0.5 + yShift;\n    #else\n        vec2 uv = fragCoord.xy / iResolution.xy;\n    #endif\n    \n    float uMulShifted = (f_dotCount * uv.x + dotShift);\n    float uCeil = ceil(uMulShifted);\n    float uFract = fract(uMulShifted);\n    \n    vec3 background = vec3(0.1, 0.085, 0.15);\n    #ifdef deformer        \n    vec3 centerQuad = CheckSquare(vec2(0.5 - 0.0125, 0.9), vec2(0.025, 0.05), uv_original); \n    centerQuad.gb /= 16.0;\n    float cqAlpha = texture(\n        iChannel0, \n        vec2(1.0 - 1.0 * (1.0 / 16.0), 1.0 - 3.0 * (1.0 / 16.0))+\n        centerQuad.gb).r;\n\n    vec3 leftQuad = CheckSquare(vec2(0.5 - 0.0125 - 0.014, 0.9), vec2(0.025, 0.05), uv_original); \n    leftQuad.gb /= 16.0;\n    float lqAlpha = texture(\n        iChannel0, \n        vec2(ceil(f_activeDotId - 0.5) * (1.0 / 16.0), 1.0 - 4.0 * (1.0 / 16.0))+\n        leftQuad.gb).r;\n\n    vec3 rightQuad = CheckSquare(vec2(0.5 - 0.0125 + 0.014, 0.9), vec2(0.025, 0.05), uv_original); \n    rightQuad.gb /= 16.0;\n    float rqAlpha = texture(\n        iChannel0, \n        vec2(f_dotCount * (1.0 / 16.0), 1.0 - 4.0 * (1.0 / 16.0))+\n        rightQuad.gb).r;\n\n    background = mix(background, vec3(1.0, 1.0, 1.0), centerQuad.r*cqAlpha);\n    background = mix(background, vec3(1.0, 1.0, 1.0), leftQuad.r*lqAlpha);\n    background = mix(background, vec3(1.0, 1.0, 1.0), rightQuad.r*rqAlpha);\n    #endif\n    vec2 corrUV = vec2(uFract, uv.y) * 2.0 - vec2(1.0);\n    \n    float uvLength = dot(corrUV, corrUV);\n    \n    float x = (f_dotCount * 0.5);\n    float xx = (uCeil - dotShift - 0.5) - x;\n    float power = mix(2.75, 5.0, max(0.0, f_dotCount - 4.0) / 3.0);\n    float alpha = 1.0 - pow(max(0.0,(abs(xx / x))), power);\n    \n    float colorWeight = 1.0 - min(1.0, abs(uCeil - f_activeDotId));\n    float radiusModified = (alpha + activeDotMagnify * colorWeight * colorWeight) * dotScale;\n    float radius = uvLength / (radiusModified * radiusModified);   \n    vec3 finalColor = mix(inactiveColor, activeColor, colorWeight);\n    \n    float circleOpacity = 1.0 - smoothstep(1.0 - epsilon, 1.0 + epsilon, radius);\n   \n\n\tfragColor = vec4(mix(background, finalColor, opacity * circleOpacity), 1.0);\n}","name":"Image","description":"","type":"image"}]}