{"ver":"0.1","info":{"id":"7tffDN","date":"1650897902","viewed":211,"name":"Black Hole 3","username":"Spheya","description":"I wanted to render a black hole, it's not an accurate render lol","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distanceSqr(vec3 a, vec3 b) {\n    return dot(a - b, a - b);\n}\n\nfloat random(vec3 pos) {\n    pos += 2232.1234;\n    pos = 50.0 * fract(pos * 0.3183099);\n    return fract(pos.x * pos.y * pos.z * (pos.x + pos.y + pos.z));\n}\n\nfloat lerp(float a, float b, float t) {\n    return a * (1.0 - t) + b * t;\n}\n\nfloat s(float t) {\n    t = clamp(t, 0.0, 1.0);\n    return 3.0 * t * t - 2.0 * t * t * t;\n}\n\nfloat randomNoise(vec2 pos) {\n    vec3 gridPos = floor(vec3(pos + 200.0, iTime));\n    \n    float a = random(gridPos + vec3(0.0, 0.0, 0.0));\n    float b = random(gridPos + vec3(1.0, 0.0, 0.0));\n    float c = random(gridPos + vec3(0.0, 1.0, 0.0));\n    float d = random(gridPos + vec3(1.0, 1.0, 0.0));\n    float e = random(gridPos + vec3(0.0, 0.0, 1.0));\n    float f = random(gridPos + vec3(1.0, 0.0, 1.0));\n    float g = random(gridPos + vec3(0.0, 1.0, 1.0));\n    float h = random(gridPos + vec3(1.0, 1.0, 1.0));\n    vec3 t = fract(vec3(pos, iTime));\n    \n    return lerp(lerp(lerp(a, b, t.x), lerp(c, d, t.x), t.y), lerp(lerp(e, f, t.x), lerp(g, h, t.x), t.y), t.z);\n}\n\nfloat perlinNoise(vec3 pos) {\n    float angle = atan(pos.z, pos.x) + iTime * 0.5;\n    float dist = length(pos.xz);\n\n    vec2 p = vec2(dist, angle * 4.0  - dist * 2.0);\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float noise = 0.0;\n    \n    for(int octave = 0; octave < 4; ++octave) {\n        noise += randomNoise(p * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    noise -= 0.1;\n    \n    float distanceToCenter = distance(pos, vec3(0.0, 0.0, 0.0));\n    float verticalDecay = (cos(clamp(pos.y * 4.0, -3.1416, 3.1416)) * 0.5 + 0.5);\n    float radialDecay = 1.0 / (distanceToCenter * distanceToCenter * distanceToCenter);\n    float a = 4.0 + randomNoise(p) * 0.75;\n    float b = 0.4 + randomNoise(p) * 0.025;\n    float t = (min(b * distanceToCenter, b * a) - b * a);\n    radialDecay *= max(1.0 - t * t, 0.0);\n    \n    return noise * verticalDecay * radialDecay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 screenPos = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    const float theta = 0.4;\n    const float cosTheta = cos(theta);\n    const float sinTheta = sin(theta);\n    \n    vec3 pos = vec3(0.0, 10.0, -25.0) * 1.5;\n    vec3 direction = normalize(vec3(screenPos, 1.0)) * mat3(\n        1.0, 0.0, 0.0,\n        0.0, +cosTheta, -sinTheta,\n        0.0, +sinTheta, +cosTheta\n    );\n    direction *= 10.0;\n    \n    float noise = 0.0;\n    float hitIntensity = 0.0;\n    \n    const float stepSize = 0.01;\n    for(int rayStep = 0; rayStep < 500; ++rayStep) {\n        float distSqr = distanceSqr(pos, vec3(0.0, 0.0, 0.0));\n        if(distSqr < 2.0) {\n            vec3 normal = normalize(pos);\n            float fresnel = pow(1.0 + dot(normal, normalize(direction)), 4.0);\n            hitIntensity = 0.0;\n            break;\n        }\n    \n        noise += perlinNoise(pos);\n        \n        vec3 gravity = (10.0 / distSqr) * normalize(-pos);\n        direction += gravity;\n        pos += direction * stepSize;\n    }\n    \n    float intensity = hitIntensity + noise * 40.0;\n    vec3 col = vec3(s(intensity * 1.8), s(intensity * 0.85), s(intensity * 0.5));\n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}