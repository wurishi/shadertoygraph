{"ver":"0.1","info":{"id":"WsyfzG","date":"1607449656","viewed":96,"name":"Galaxy Workshop 1","username":"denosya","description":"3D noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["customnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define CELL_SIZE 500.0\n#define MIN_RADIUS 2.0\n#define MAX_RADIUS 15.0\n#define CAMERA_SPEED 5000.0\n#define ROTATION_SPEED 0.50\n\n\nfloat smin( float a, float b) {\n    \n    return min(a, b);\n    \n    float k = 10.0;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nvec3 rand33(in vec3 p)\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nfloat debug;\n\nvec3 color(in vec3 src) {\n    \n    return normalize(src * vec3(0.5, 0.5, 1.0));\n}\n\n\nvec3 desaturate(vec3 color, float spaceDist) {\n    float ratio = min(spaceDist/5000.0, 1.0);\n    float l = length(color);\n    return mix(color, vec3(l), pow(ratio, 1.));\n}\n\nvec3 color2(in vec3 src, float dist, float radius, float spaceDist, in vec3 normal) {\n    \n    float i = radius/pow(dist, .85);\n    vec3 fondCosmique = vec3(i);\t\n    \n    \n    vec3 planetMaterial = normalize(src * vec3(0.75, 0.5, 1.0)) * i;\n    \n   \tvec3 spotLight = normalize(vec3(2.0, -0.5, -1.0));\t\n\n    float diffuse = dot(normal, -spotLight);\n\n    vec3 planetColor = planetMaterial * (0.15 + diffuse);    \n    \n    float ratio = smoothstep(7500.0, 12000.0, spaceDist);\n    \n    return mix(desaturate(planetColor, spaceDist),fondCosmique, ratio);\n}\n\n\n\n\n\nfloat map(in vec3 m, out vec3 material, float spaceDist, out vec3 normal) {\n    \n    /*\n    float cell_size = CELL_SIZE;\n\n    vec3 cell   = floor(m / cell_size);\n    \n\tfloat field = 0.0;\n    \n    vec3 closest1, closest2;\n    float distance1 = 99999.0; \n    float distance2 = 99999.0;\n    vec3 rand1, rand2;\n   \n    \n    for(int x=-1;x<=1;x++) {\n        for(int y=-1;y<=1;y++) {\n            for(int z=-1;z<=1;z++) {\n                vec3 rnd = rand33(cell + vec3(x, y, z));\n                vec3 rndPoint = (cell + vec3(x, y, z) + rnd) * cell_size;\n                float distance = length(rndPoint - m);\n                \n                if(distance < distance1) {\n                    distance1 = distance;\n                    closest1 = rndPoint;\n                    rand1 = rnd;\n                } \n            }\n        }\n\t}\n    */\n\n    float cell_size = CELL_SIZE;\n\n    vec3 cell   = floor((m + cell_size*0.5) / cell_size);\n    \n\tfloat field = 0.0;\n    \n    vec3 closest1, closest2;\n    float distance1 = 99999.0; \n    float distance2 = 99999.0;\n    vec3 rand1, rand2;\n   \n    for(int x=-1;x<=0;x++) {\n        for(int y=-1;y<=0;y++) {\n            for(int z=-1;z<=0;z++) {\n                vec3 rnd = rand33(cell + vec3(x, y, z));\n                vec3 rndPoint = (cell + vec3(x, y, z) + rnd) * cell_size;\n                float distance = length(rndPoint - m);\n                \n                if(distance < distance1) {\n                    distance1 = distance;\n                    closest1 = rndPoint;\n                    rand1 = rnd;\n                } \n            }\n        }\n\t}\n\n    normal = normalize(m-closest1);\n        \n    float radius1 = MIN_RADIUS + rand1.x * (MAX_RADIUS - MIN_RADIUS);\n    \n    float d1 = distance1 - radius1;\n    \n    \n    material = color2(rand1, distance1, radius1, spaceDist, normal );\n    \n    //return distance2 - 5.0;//radius2;\n    \n    \n    \n    return distance1 - radius1;\n}\n\n/*\nfloat map(in vec3 m, out vec3 material) {\n    \n    float cell_size = CELL_SIZE;\n\n    vec3 cell   = floor(m / cell_size);\n    \n\tfloat field = 0.0;\n    \n    vec3 closest1, closest2;\n    float distance1 = 99999.0; \n    float distance2 = 99999.0;\n    vec3 rand1, rand2;\n   \n    \n    for(int x=-1;x<=1;x++) {\n        for(int y=-1;y<=1;y++) {\n            for(int z=-1;z<=1;z++) {\n                vec3 rnd = rand33(cell + vec3(x, y, z));\n                vec3 rndPoint = (cell + vec3(x, y, z) + rnd) * cell_size;\n                float distance = length(rndPoint - m);\n                \n                if(distance < distance1) {\n                    distance1 = distance;\n                    closest1 = rndPoint;\n                    rand1 = rnd;\n                } \n                else {\n                    if(distance < distance2) {\n                        distance2 = distance;\n                        closest2 = rndPoint;\n                        rand2 = rnd;\n                    }\n                }\n                \n               break;\n            }\n        }\n\t}\n    \n    float ratio = distance1 / (distance1+distance2);\n    material = mix(rand1, rand2, ratio);\n    \n    float radius1 = MIN_RADIUS + rand1.x * (MAX_RADIUS - MIN_RADIUS);\n    float radius2 = MIN_RADIUS + rand2.x * (MAX_RADIUS - MIN_RADIUS);\n    \n    float d1 = distance1 - radius1;\n    float d2 = distance2 - radius2;    \n    \n    \n    material = color(d1 < d2 ? rand1 : rand2, distance);\n    \n    //return distance2 - 5.0;//radius2;\n    \n    \n    \n    return smin(distance1 - radius1, distance2 - radius2);\n}\n*/\n\n\nvec3 buffer;\nfloat map(in vec3 m) {\n\treturn map(m, buffer,0.0,buffer);\n}\n\n\n#define START_FADING 30.0\n\nfloat march(in vec3 origin, in vec3 ray, out vec3 m, out vec3 material, out float totalMarch) {\n\n    const int MAX_ITER = 50;\n    int i = 0;\n    \n    vec3 normal;\n    \n    while(i++ < MAX_ITER) {\n        \n        m = origin + ray * totalMarch; \n        \n        float dist = map(m, material, totalMarch, normal); \t\n        \n        if(dist<0.1) {\n            return 1.0;\n        }\n\t    \n        totalMarch += dist * 0.895;\n    }\n\n    return 0.0;\n}\n\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.025, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    const float animationSpeed = 0.25;\n    const float rotAmplitude = 0.5;\n    float alpha = sin(iTime*animationSpeed*ROTATION_SPEED)*rotAmplitude;\n    \n    vec2 rot = vec2(uv.x * cos(alpha) - uv.y * sin(alpha), uv.x * sin(alpha) + uv.y * cos(alpha));\n    uv = rot;\n    \n    vec3 eye = vec3(0.0, 0.0, 1.0);\n\tvec3 ray = normalize(vec3(uv, 0) - eye);\n    vec3 m;\n    vec3 material;\n    float total = 0.0;\n\n    eye.z = -iTime*CAMERA_SPEED*animationSpeed;\n\n    float res = march(eye, ray, m, material, total);\n\n    vec3 normal = computeNormal(m);\n    vec3 spotLight = normalize(vec3(2.0, -0.5, -1.0));\n    \n    float diffuse = dot(normal, -spotLight);\n    \n    fragColor=vec4(material * res * (0.15 + diffuse), 1.0);\n    \n    fragColor=vec4(material, 1.0);\n    \n    \n    // test\n    if(-m.z - -eye.z < START_FADING) {\n        \n        float alpha = (-m.z - -eye.z) / START_FADING;\t\n        \n        total += 2.0;\n        float res = march(eye, ray, m, material, total);\n\n        vec3 normal = computeNormal(m);\n        vec3 spotLight = normalize(vec3(2.0, -0.5, -1.0));\n\n        float diffuse = dot(normal, -spotLight);\n\n        vec4 backColor = vec4(material * res * (0.15 + diffuse), 1.0);\n\n        \n        fragColor = mix(backColor, fragColor, alpha);\t\n    }\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}