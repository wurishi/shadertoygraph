{"ver":"0.1","info":{"id":"7tsSRn","date":"1625078307","viewed":127,"name":"My First RayMarch","username":"gabor","description":"First attempt to create a ray marcher including\n- SDF with sdSphere and sdRoundBox (by IQ)\n- 3 point and an ambient light sources with diffuse and specular\n- cast shadows\n- fade into sky color at max distance\n- SDF also returns a material index (coloring)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test","beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Finally I got into creating a ray marcher after watching and reading stuff by IQ and Art of Coding\n\n#define PI 3.1415926535897932384626433832795\n\n#define MAX_STEP 100\n#define MAX_DISTANCE 12.0\n#define MAX_VISIBILITY .8*MAX_DISTANCE\n#define MIN_DISTANCE 0.004\n\n#define skyColor vec3(.5, .72, 0.9)\n#define AMBIENT_FACTOR .2\n\n//#define AA <-- buggy\n//#define USE_BRANCHING <-- if vs step() doesn't seem to make a difference\n//#define FX\n\n\n#define nsin(a) .5*(1. + sin(a)) \n\nfloat ambient = .0;\n\nvec3 colors[] = vec3[](\n    vec3(.8, .2, .2),\n    vec3(.9, .8, .2),\n    vec3(.2, .2, .8),\n    vec3(.9, .4, .8),\n    vec3(.5, .6, .6)\n);\n\nvec3 lights[] = vec3[](\n    vec3(0.), vec3(0.), vec3(0.)\n);\n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//thx IQ\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\nvec2 getDistance(vec3 p) {\n\n    vec2 p1 = vec2(sdPlane(p, normalize(vec3(0.0, 1.0, 0.0))), 4);\n    vec2 res = vec2(.0);\n\n    vec3 s1t = vec3(-.0, .15,  0.0);\n    vec3 s2t = vec3(-.3, .2, -0.3);\n\n    vec3 b1t = vec3( .3, .2,  0.3);\n    vec3 b2t = vec3( .3, .1, -0.3);    \n\n    vec2 s1 = vec2(sdSphere(p - s1t, 0.1), 0);\n    vec2 s2 = vec2(sdSphere(p - s2t, 0.13), 1);\n\n    vec3 b1p = p - b1t; b1p.xz *= rotate(1.1*iTime); b1p.yz *= rotate(-0.1*iTime);\n    vec2 b1 = vec2(sdRoundBox(b1p, vec3(.1), 0.01), 3);\n\n    vec3 b2p = p - b2t; b2p.xz *= rotate(-4.1*iTime);\n    vec2 b2 = vec2(sdRoundBox(b2p, vec3(.1, 0.02, .05), 0.01), 3);\n\n#ifdef USE_BRANCHING\n    vec2 s = s1;\n    if (s2.x < s.x) s = s2;\n\n    vec2 b = b1;\n    if (b2.x < b.x) b = b2;\n\n    res = s;\n    if (b.x < res.x) res = b;\n    if (p1.x < res.x) res = p1;\n\n#else\n    float sd = min(s1.x, s2.x);\n    float sm = s1.y*step(s1.x, sd + MIN_DISTANCE) + s2.y*step(s2.x, sd + MIN_DISTANCE);\n\n    float bd = min(b1.x, b2.x);\n    float bm = b1.y*step(b1.x, bd + MIN_DISTANCE) + b2.y*step(s2.x, bd + MIN_DISTANCE);\n\n    float d1 = min(sd, bd);\n    float m1 = sm*step(sd, d1+MIN_DISTANCE) + bm*step(bd, d1+MIN_DISTANCE);\n\n    res.x = min(p1.x, d1);\n    res.y = p1.y*step(p1.x, res.x+MIN_DISTANCE) + m1*step(d1, res.x+MIN_DISTANCE);\n\n#endif\n\n    return res;\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    float d = .0;\n    for (int i=0; i<MAX_STEP; i++) {\n        vec3 p = ro + d*rd;\n        float ds = getDistance(p).x;\n        d += ds;\n        if (d > MAX_DISTANCE || ds < MIN_DISTANCE) break;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    vec3 v = vec3(MIN_DISTANCE, .0, .0);\n    return normalize(d - vec3(\n        getDistance(p - v.xyy).x,\n        getDistance(p - v.yxy).x,\n        getDistance(p - v.yyx).x\n    ));\n}\n\nvec3 getLight(vec3 p, vec3 lightPos, vec3 lightCol) {\n    vec3 col = vec3(.8, .82, 1.0);\n    \n    vec2 dm = getDistance(p);\n    if (dm.x < MAX_VISIBILITY) {\n        int mat = int(dm.y);\n        // ambient\n        vec3 ambColor = ambient * skyColor;\n        // diffuse\n        vec3 l = normalize(lightPos - p);\n        vec3 n = getNormal(p, dm.x);\n        float diff = clamp(dot(l, n), 0., 1.);\n        vec3 diffColor = clamp(vec3(lightCol) * 0.8 * diff, .0, .5);\n        // specular\n        vec3 lightReflect = reflect(-l, n);\n        float sf = max(dot(normalize(p), lightReflect), .0);\n        float spec = pow(sf, 20.0);\n        vec3 specColor = vec3(lightCol * 1.2 * spec);\n        // cast shadow\n        float sd = castRay(p + 2.*n*MIN_DISTANCE, l);\n        //float falloff = 10.*(1.0 - clamp(length(lightDir - p), .0, 1.));\n        float sh = 1.;\n        if (sd < MAX_DISTANCE) sh = clamp(4.*sd, .0, 1.);\n\n        col = colors[mat] * (ambColor + sh*(clamp(diffColor + specColor, .0, 1.)));\n        if (mat == 4) {\n            col *= .5 + .5*step(.5, fract(2.*p.x + .5*step(.5, fract(2.*p.z))));\n        }\n    }\n\n    return clamp(col, .0, 1.);\n}\n\nvec3 render(vec3 p) {\n    vec3 col  = getLight(p, lights[0], vec3(.6, .4, .4));\n         col += getLight(p, lights[1], vec3(.0, .6, .0));\n         col += getLight(p, lights[2], vec3(.0, .0, .7));\n    return col;    \n}\n\nvec3 sky(vec3 p) {\n    vec3 col = vec3(skyColor);\n    //col.rg = noise(;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ambient = AMBIENT_FACTOR;//*nsin(.5*iTime);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n#ifdef FX\n    vec2 q = vec2(sin(5.*PI*uv.x + 4.3*iTime), sin(3.*PI*uv.y + 2.*iTime + .5));\n    uv += .02*q;\n    float f = 450.*nsin(0.2*PI*iTime) + 50.;\n    uv = floor(uv*f)/f;\n#endif\n    float angle = 0.2*iTime;\n    vec3 ro = vec3(.0, .0, -1.);\n    ro.xz *= 1.2*rotate(angle);\n    ro += vec3(.0, 0.3, .0);\n\n    vec3 rt = vec3(uv.x, uv.y, 1.);\n    rt.yz *= rotate(.1*3.14);\n    rt.xz *= rotate(angle);\n    vec3 rd = normalize(rt);\n\n    float d = castRay(ro, rd);\n    vec3 p = ro + d*rd;\n\n    vec3 center = vec3(.0, 1., .0);\n\n    float theta = iTime * 1.0;\n    // #1 light\n    lights[0] = vec3(vec2(.2, -.2)*rotate(theta), .0).xzy + center;\n    // #2 light\n    lights[1] = vec3(vec2(.3, .2)*rotate(theta), .0).xzy + center;\n    // #3 light\n    lights[2] = vec3(vec2(-.1, .0)*rotate(theta), .0).xzy + center;\n    \n    vec3 col  = render(p);\n#ifdef AA\n    vec3 cd = vec3(2.*MIN_DISTANCE, .0, 0.);\n         col += render(p+cd.xyy, lp1, lp2, lp3);\n         col += render(p+cd.yxy, lp1, lp2, lp3);\n         col /= 3.;\n#endif\n\n    col = mix(col, (.1 + 4.*ambient)*sky(p), smoothstep(.01*MAX_DISTANCE, MAX_VISIBILITY, d));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}