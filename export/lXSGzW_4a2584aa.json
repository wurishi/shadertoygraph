{"ver":"0.1","info":{"id":"lXSGzW","date":"1708273011","viewed":70,"name":"iridescent ball","username":"ShadedSky","description":"ray marching sphere dimples","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching distance threshold\nconst float MIN_DIST = 0.001;\n// Maximum ray marching steps\nconst int MAX_STEPS = 200;\n// Maximum depth for ray marching\nconst float MAX_DEPTH = 100.0;\n\n// Classic Perlin 3D Noise corrected for GLSL\n// Adapted to ensure operations are on matching vector sizes\n\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nfloat noise(vec3 p) {\n    // Floors the vector\n    vec3 a = floor(p);\n    // Finds the delta within the cell\n    vec3 d = p - a;\n    // Applies a smoothing curve\n    d = d * d * (3.0 - 2.0 * d);\n\n    // Correctly constructs b by ensuring dimensions match\n    vec4 b = vec4(a.xy, a.xy) + vec4(0.0, 1.0, 0.0, 1.0);\n    // This needs adjustment to avoid dimension mismatch\n    vec4 k1 = permute(permute(b.xyxy) + vec4(a.z, a.z, a.z, a.z) + vec4(b.zzww));\n    vec4 k2 = permute(permute(k1.xyxy) + k1.zzww);\n\n    // Corrects the o1, o2 calculation to avoid direct repetition and dimension mismatch\n    vec4 o1 = fract(k2 * (1.0 / 41.0));\n    // Removed o2 as it was identical to o1, likely an error in the original adaptation\n\n    // Corrected mix operations to ensure dimension compatibility\n    vec2 o4 = mix(o1.xy, o1.zw, d.y);\n\n    return mix(o4.x, o4.y, d.x);\n}\n\n\n\n// Signed distance function for a sphere with dimples\nfloat ssphereDimpleSDF(vec3 p, float r) {\n    // Base sphere SDF\n    float sphereDist = length(p) - r;\n\n    // Add dimples\n    float dimpleDepth = 0.15; // Size of the dimples\n    float dimple = dimpleDepth * noise(p * 3.5); // Adjust to change dimple density\n    return sphereDist - dimple;\n}\n\n// Rotation function around the Y-axis\nmat3 rotateY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n       -s, 0.0, c\n    );\n}\n// Signed distance function for a sphere with dimples, modified to include rotation\nfloat sphereDimpleSDF(vec3 p, float r) {\n    //float time = iTime * 0.5; // Adjust rotation speed here\n    float time = sin(0.1*iTime) * 0.5;\n    \n    p = rotateY(time) * p; // Apply rotation to the point before calculating distance\n\n    // Base sphere SDF\n    float sphereDist = length(p) - r;\n\n    // Add dimples\n    float dimpleDepth = 0.5;//1.0*sin(.5*iTime); // Size of the dimples\n    vec3 q = mod(p*sin(.3*iTime)*23.5, 1.0); // Adjust this value to change the density of the dimples\n    float dimple = dimpleDepth * noise(q);\n    return sphereDist - dimple;\n}\n\n\n\n\n\n// The ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sphereDimpleSDF(ro + depth * rd, 1.0);\n        if (dist < MIN_DIST) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n// Function to compute the color based on the normal and view direction\nvec3 getIridescentColor(vec3 normal, vec3 viewDir) {\n    float angle = acos(dot(normal, -viewDir));\n    vec3 color = 0.5 + 0.5 * cos(angle + vec3(sin(iTime), 2.0, 4.0));\n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Time-based wobble effect\n    float time = iTime * 0.5;\n    vec3 wobble = vec3(sin(time), sin(time + 2.0), cos(time + 4.0)) * 0.07;\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -3.0) + wobble; // Camera position with wobble\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n\n    float t = rayMarch(ro, rd, 0.0, MAX_DEPTH);\n    if (t < MAX_DEPTH) {\n        vec3 p = ro + t * rd; // Position where the ray hits the sphere\n        vec3 normal = normalize(p); // Normal at the hit position\n        vec3 viewDir = normalize(-rd); // View direction is opposite to ray direction\n\n        // Compute the iridescent color\n        vec3 col = getIridescentColor(normal, viewDir);\n\n        // Apply lighting\n        vec3 lightDir = normalize(vec3(0.0, 1.0, -1.0)); // Light direction\n        float diff = max(dot(normal, lightDir), 0.0); // Diffuse lighting\n        col *= diff;\n\n        fragColor = vec4(col, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}\n","name":"Image","description":"","type":"image"}]}