{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct plane {\n    vec3 normal;\n    float distance;\n};\n\n/* Rays */\nstruct ray {\n    vec3 start;\n    vec3 normal;\n};\n    \nray lens(vec2 fragCoord) {\n\treturn ray(\n\t\tvec3(sin(iTime * 0.5) * 3.0, 0.0, sin(iTime * 1.0) * 10.0 - 2.0), \n\t\tnormalize(vec3((fragCoord.xy / iResolution.xy) - 0.5, 0.3))\n\t);\n}\n    \nray translate(vec3 offset, ray transform) {\n\treturn ray(\n\t\ttransform.start - offset,\n\t\ttransform.normal\n\t);\n}\n\nray scale(vec3 factor, ray transform) {\n\treturn ray(\n\t\ttransform.start / factor, \n\t\tnormalize(transform.normal / factor)\n\t);\n}\n\nray scale(float factor, ray transform) {\n\treturn ray(\n\t\ttransform.start / factor, \n\t\tnormalize(transform.normal / factor)\n\t);\n}\n\nray rotateY(float angle, ray transform) {\n    mat3 mat = mat3(cos(angle), 0.0, -sin(angle), 0.0, 1.0, 0.0, sin(angle), 0.0, cos(angle));\n    return ray(transform.start * mat, transform.normal * mat);\n}\n\nfloat distanceAlong(ray m_sample) {\n\treturn -dot(m_sample.start, m_sample.normal);\n}\n\nvec3 closestPoint(ray m_sample) {\n\treturn m_sample.start + m_sample.normal * distanceAlong(m_sample);\n}\n\nray m_reflect(plane surface, ray transform) {\n    return ray(reflect(transform.start, surface.normal) + surface.normal * 2.0 * surface.distance, reflect(transform.normal, surface.normal));\n}\n\nvec3 project(plane surface, vec3 point) {\n    return surface.distance + point - dot(surface.normal, point);\n}\n\n\n\nvec3 project(plane surface, ray line) {\n    return line.start \n        + line.normal * (dot(surface.normal, surface.normal * surface.distance - line.start) / dot(surface.normal, line.normal));\n}\n\nray repeat(plane surface, vec3 size, ray world, ray transform) {\n    vec3 projected = project(surface, world);\n    return ray(transform.start - (floor(projected / size) * size), transform.normal);\n}\n\nvec3 gridTex(vec3 at) {\n    //if(at.z > 0.0) return vec3(0.0);\n    //at *= 0.2;\n    at -= 0.5;\n    bvec3 onLine = bvec3(fract(at).x < 0.1, fract(at).y < 0.1, fract(at).z < 0.1);\n    return onLine.x || onLine.y || onLine.z ? vec3(0.1) : vec3(0.0);\n}\n\n/* Falloff functions. */\nfloat radial(ray m_sample) {\n\treturn \n\t\t// Fade out as the camera passes through the volume.\n\t\tclamp(distanceAlong(m_sample), 0.0, 1.0) \n\t\t// Actual rolloff.\n\t\t* max(0.0, 1.0 - (length(closestPoint(m_sample))));\n}\n\nfloat spot(vec3 normal, ray m_sample) {\n\treturn max(dot(normal, normalize(closestPoint(m_sample))), 0.0);\n}\n\nfloat spotDual(vec3 normal, ray m_sample) {\n    return dot(normalize(closestPoint(m_sample)), normal);\n}\n\nfloat quadratic(float val) {\n\treturn val * val * val * val;\n}\n\nvec3 shade(vec3 color, float intensity) {\n\treturn color * intensity;\n}\n\n/* Occluders */\nfloat occlude(plane surface, ray m_sample) {\n    return (distanceAlong(m_sample) / dot(surface.normal, m_sample.normal)) - surface.distance;\n}\n\nfloat occlude(float distance, ray m_sample) {\n    return 1.0;\n}\n\nvec3 scene(ray lens) {    \n\tvec3 color = vec3(0.0);\n    \n    plane doorFrame = plane(vec3(0.0, 0.0, -1.0), sin(iTime * 5.0) * 5.0);\n    float doorFrameDistance = occlude(doorFrame, lens);\n    \n    ray loc = scale(vec3(8.0, 5.0, 4.0), rotateY(iTime * 1.0, translate(vec3(0.0, 3.0, 12.0), lens)));\n    color += shade(vec3(1.0, 0.0, 0.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc) * spotDual(vec3(1.0, 0.0, 0.0), loc)));    \n    \n    loc = scale(vec3(5.0, 10.0, 5.0), translate(vec3(4.0, 5.0, 0.0), lens));\n    color += shade(vec3(0.3, 0.4, 1.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc) * spot(vec3(-0.7, -0.7, 0.0), loc)));             \n    \n    loc = scale(vec3(5.0, 10.0, 5.0), translate(vec3(-4.0, 5.0, 5.0), lens));\n    color += shade(vec3(0.3, 0.4, 1.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc) * spot(vec3(0.7, -0.7, 0.0), loc))); \n    \n    loc = scale(vec3(5.0, 10.0, 5.0), translate(vec3(4.0, 5.0, 10.0), lens));\n    color += shade(vec3(0.3, 0.4, 1.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc) * spot(vec3(-0.7, -0.7, 0.0), loc)));     \n    \n    loc = scale(vec3(5.0, 10.0, 5.0), translate(vec3(-4.0, 5.0, 15.0), lens));\n    color += shade(vec3(0.3, 0.4, 1.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc) * spot(vec3(0.7, -0.7, 0.0), loc)));         \n    \n    loc = scale(15.0, translate(vec3(0.0, 3.0, 12.0), lens));\n    color += shade(vec3(0.3, 0.4, 1.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc))); \n    \n    loc = scale(15.0, translate(vec3(0.0, 1.0, 20.0), lens));\n    color += shade(vec3(0.9, 0.7, 0.2), quadratic(occlude(doorFrameDistance, loc) * radial(loc)));     \n    \n    //loc = scale(vec3(2.0, 8.0, 2.0), translate(vec3(-5.0, -5.0, 2.0), lens));\n    //color += shade(vec3(0.0, 1.0, 0.0), quadratic(occlude(doorFrameDistance, loc) * radial(loc) * spot(vec3(0.0, 1.0, 0.0), loc)));             \n    \n    loc = lens;\n    loc = repeat(plane(vec3(1.0, 0.0, 0.0), -4.0), vec3(4.25, 200.0, 4.0), translate(vec3(0.0, -4.0, 0.0), lens), loc);\n    loc = scale(vec3(2.0, 8.0, 3.0), translate(vec3(0.0, -4.0, 2.0), loc));\n    color += shade(vec3(0.0, 1.0, 0.0), quadratic(radial(loc) * spot(vec3(0.0, 1.0, 0.0), loc)));             \n    \n    loc = lens;\n    loc = repeat(plane(vec3(-1.0, 0.0, 0.0), -4.0), vec3(-4.25, 200.0, 4.0), translate(vec3(0.0, -4.0, 0.0), lens), loc);\n    loc = scale(vec3(2.0, 8.0, 3.0), translate(vec3(0.0, -4.0, 2.0), loc));\n    \n    color += shade(vec3(0.0, 1.0, 0.0), quadratic(radial(loc) * spot(vec3(0.0, 1.0, 0.0), loc)));             \n    \n    //color = vec3((closestPoint(loc) - floor(closestPoint(loc))).x);\n   //color += gridTex(project(plane(vec3(1.0, 0.0, 0.0), -4.0), lens)); \n   //color += gridTex(project(plane(vec3(0.0, 1.0, 0.0), -4.95), lens));\n    //\tcolor += gridTex(project(plane(vec3(0.0, 0.0, -1.0), -25.0), lens));\n    \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = pow(vec4(\n        scene(lens(fragCoord))\n        + scene(m_reflect(plane(vec3(0.0, 1.0, 0.0), -4.0), lens(fragCoord))) * vec3(0.1, 0.1, 0.1)\n    , 1.0), vec4(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlfGWj","date":"1425144791","viewed":320,"name":"False Volumetrics III","username":"jameswilddev","description":"Volumetrics with reflections and repeated objects!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["volumetrics"],"hasliked":0,"parentid":"","parentname":""}}