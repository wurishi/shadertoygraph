{"ver":"0.1","info":{"id":"lslGRS","date":"1434380642","viewed":896,"name":"Glassy Blobs","username":"Antonalog","description":"find all the crossings, apply beer lambert, fresnel, refract, shadowed reflections etc.\nwrote this about a billion years ago but it kept killing the shader compilers so never published!","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["blobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void sampleCamera(vec2 u, out vec3 rayOrigin, out vec3 rayDir, in vec2 fragCoord)\n{\n\tvec2 xy = fragCoord.xy;\n\txy.y=iResolution.y-fragCoord.y;\n\tvec2 filmUv = (xy + u)/iResolution.xy;\n\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = vec3(tx, ty, tz) - rayOrigin;\t\n}\n\n#define DO_BLOBS(DO) vec4 b; b=vec4(-0.38 + 0.25*sin(iTime+0.00), -0.60 + 0.25*cos(iTime+0.00), -0.67, 0.17); DO; b=vec4(-0.33 + 0.25*sin(iTime+1.00), -0.59 + 0.25*cos(iTime+1.00), 0.02, 0.19); DO; b=vec4(-0.33 + 0.25*sin(iTime+2.00), -0.42 + 0.25*cos(iTime+2.00), 0.48, 0.12); DO; b=vec4(-0.50 + 0.25*sin(iTime+3.00), -0.18 + 0.25*cos(iTime+3.00), -0.30, 0.15); DO; b=vec4(-0.57 + 0.25*sin(iTime+4.00), 0.09 + 0.25*cos(iTime+4.00), 0.14, 0.16); DO; b=vec4(-0.58 + 0.25*sin(iTime+5.00), -0.13 + 0.25*cos(iTime+5.00), 0.58, 0.12); DO; b=vec4(-0.48 + 0.25*sin(iTime+6.00), 0.67 + 0.25*cos(iTime+6.00), -0.66, 0.13); DO; b=vec4(-0.37 + 0.25*sin(iTime+7.00), 0.43 + 0.25*cos(iTime+7.00), -0.16, 0.18); DO; b=vec4(-0.49 + 0.25*sin(iTime+8.00), 0.41 + 0.25*cos(iTime+8.00), 0.62, 0.16); DO; b=vec4(0.19 + 0.25*sin(iTime+9.00), -0.64 + 0.25*cos(iTime+9.00), -0.47, 0.18); DO; b=vec4(0.19 + 0.25*sin(iTime+10.00), -0.43 + 0.25*cos(iTime+10.00), -0.04, 0.13); DO; b=vec4(-0.01 + 0.25*sin(iTime+11.00), -0.40 + 0.25*cos(iTime+11.00), 0.39, 0.11); DO; b=vec4(-0.12 + 0.25*sin(iTime+12.00), -0.06 + 0.25*cos(iTime+12.00), -0.70, 0.12); DO; b=vec4(0.08 + 0.25*sin(iTime+13.00), 0.18 + 0.25*cos(iTime+13.00), 0.07, 0.15); DO; b=vec4(-0.15 + 0.25*sin(iTime+14.00), -0.12 + 0.25*cos(iTime+14.00), 0.51, 0.19); DO; b=vec4(0.09 + 0.25*sin(iTime+15.00), 0.57 + 0.25*cos(iTime+15.00), -0.48, 0.10); DO; b=vec4(0.12 + 0.25*sin(iTime+16.00), 0.64 + 0.25*cos(iTime+16.00), 0.19, 0.14); DO; b=vec4(-0.11 + 0.25*sin(iTime+17.00), 0.67 + 0.25*cos(iTime+17.00), 0.42, 0.20); DO; b=vec4(0.55 + 0.25*sin(iTime+18.00), -0.69 + 0.25*cos(iTime+18.00), -0.35, 0.18); DO; b=vec4(0.33 + 0.25*sin(iTime+19.00), -0.49 + 0.25*cos(iTime+19.00), -0.03, 0.17); DO; b=vec4(0.35 + 0.25*sin(iTime+20.00), -0.66 + 0.25*cos(iTime+20.00), 0.55, 0.15); DO; b=vec4(0.51 + 0.25*sin(iTime+21.00), -0.12 + 0.25*cos(iTime+21.00), -0.66, 0.14); DO; b=vec4(0.48 + 0.25*sin(iTime+22.00), -0.08 + 0.25*cos(iTime+22.00), -0.12, 0.11); DO; b=vec4(0.50 + 0.25*sin(iTime+23.00), 0.15 + 0.25*cos(iTime+23.00), 0.60, 0.16); DO; b=vec4(0.59 + 0.25*sin(iTime+24.00), 0.43 + 0.25*cos(iTime+24.00), -0.52, 0.11); DO; b=vec4(0.50 + 0.25*sin(iTime+25.00), 0.66 + 0.25*cos(iTime+25.00), 0.15, 0.18); DO; b=vec4(0.35 + 0.25*sin(iTime+26.00), 0.44 + 0.25*cos(iTime+26.00), 0.37, 0.14); DO; \n\nvec2 Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return vec2(1e10,-1e10);\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\tfloat n = (-b-d)*oo2a;\n\tfloat x = (-b+d)*oo2a;\n//\treturn vec2( min(n,x), max(n,x) );\n\treturn vec2( n,x );\n}\n\nvec2 SphereT(vec3 P, vec3 V, vec3 A, float R)\n{\n\treturn Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-R*R-(2.0*(dot(A,P))));\n}\n\nvec2 NearestBlobBound(vec3 P, vec3 V, float r)\n{\n\tvec2 t = vec2(1e10,-1e10);\n\tvec2 s;\n\tDO_BLOBS( s=SphereT(P,V,b.xyz,r*b.w); t.x=min(t.x,s.x); t.y=max(t.y,s.y) )\n\treturn t;\n}\n\nfloat k = 10.0;\n\nfloat sdf(vec3 x)\n{\n\t//http://www.johndcook.com/blog/2010/01/13/soft-maximum/\n\tfloat sum = 0.0;\n\tDO_BLOBS( sum += exp( k*(b.w - length(x-b.xyz)) ) )\n\treturn log( sum ) / k;\t\n}\n\nvec3 BlobNor(vec3 x)\n{\n\tvec3 sum=vec3(0.0,0.0,0.0);\n\n\tfloat w;\n\tvec3 n;\n\tfloat L;\n\tvec3 v;\n\tDO_BLOBS( v=x-b.xyz; L=length(v); n=v*(1.0/L); w = exp(k*(b.w - L)); sum += w*n );\n\treturn normalize( sum );\t\n\t\n}\n\nvec3 ss_nor(vec3 X)\n{\n\treturn normalize(cross(dFdx(X),dFdy(X)));\n}\nvec3 ss_grad(vec3 X)\n{\n\treturn cross(dFdx(X),dFdy(X));\n}\n\nfloat shlick(vec3 N, vec3 V)\n{\n\tfloat f = dot(-V,N);\n\tf = 1.0-f;\t\n\tfloat ff = f;\n\tf *= f;\t\t//2\n//\tf *= f;\t\t//4\n//\tf *= ff;\t//5\n\tfloat r0 = 0.075;\n\tf = r0 + (1.0-r0)*f;\n\treturn f;\n}\n\nvec3 Transmittance(vec3 color, float T)\n{\n\treturn -log(color)/T;\n}\n\nvec3 Filter(float thick, vec3 trans)\n{\n\tfloat conc = 0.6;\n\treturn exp( -trans * conc * thick );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 P, V;\n\tsampleCamera(vec2(0.5,0.5), P, V, fragCoord);\n\tV = normalize(V);\n\t\n\tfloat overb=1.5;\n\t\n\tvec3 bg = texture(iChannel1,V).xyz * overb;\n\tvec3 bg_V = V;\n\tvec2 bound=NearestBlobBound(P, V, 2.0);\n\tfloat t = bound.x;\n\t\n\tvec3 trans=Transmittance(vec3(0.3,0.7,0.1), 1.0);\n\t\n\tif (t < 1e10)\n\t{\n\t\tint steps=0;\n\t\tfloat d = -1e10;\n\t\tfloat old_d = -1e10;\n\t\tvec3 X;\n\n\t\tfloat inside=0.0;\n\t\tfloat last_surface_t=0.0;\n\t\n\t\tfloat thick=0.0;\n\t\t#define STEPS\t64\n\t\tfloat t_step = (bound.y-bound.x)*(1.0/float(STEPS));\n\t\t\n\t\tvec3 c = vec3(0.0,0.0,0.0);\n\t\t\n\t\tfloat last_f=0.0;\n\t\t\n\t\tvec3 filter_col = vec3(1.0);\n\t\t\n\t\tfloat blocked=0.0;\n\t\t\n\t\tfor (int i=0; i<STEPS; i++)\n\t\t{\t\t\t\n\t\t\tX = P+V*t;\n\t\t\td = sdf(X);\n\t\t\n\t\t\tif (d * old_d < 0.0)\t//a crossing\n\t\t\t{\n\t\t\t\tinside = 1.0 - inside;\n\t\t\t\tfloat int_t = mix(t-t_step,t,abs(old_d)/(abs(d)+abs(old_d)));\n\t\t\t\t\t\t\t\t//t-d; \n\t\t\t\t\t\t\t//0.5*(t-t_step-old_d + t-d);\t\n\t\t\t\n\t\t\t\tvec3 int_X = P+V*int_t;\n\t\t\t\tvec3 N = BlobNor(int_X);\t\t\t\t\n\t\n\t\t\t\tif (inside < 0.5)\t//just came out\n\t\t\t\t{\n\t\t\t\t\tfloat this_thick = (int_t - last_surface_t);\n\t\t\t\t\tfilter_col *= Filter(this_thick,trans) * (1.0-last_f);\n\t\t\t\t\t\n\t\t\t\t\tthick += this_thick;\n\t\t\t\t\t\n\t\t\t\t//\tV = bg_V = normalize( refract(bg_V,N,0.995) );\n\t\t\t\t}\n\t\t\t\telse\t//just went in\n\t\t\t\t{\t\t\n\t\t\t\t\tfloat f = shlick(N,V);\n\t\t\t\t\tlast_f = f;\n\t\t\t\t\t\n\t\t\t\t\tvec3 refV = reflect(V,N);\n\t\t\t\t\tvec3 ref = f*texture(iChannel1,refV).xyz; \n\t\t\t\t\t\n\t\t\t\t\tvec2 blocker=NearestBlobBound(int_X, refV, 1.0);\n\t\t\t\t\tif (blocker.x > 0.01 && blocker.x < 1e5) \n\t\t\t\t\t{\n\t\t\t\t\t\tblocked = blocker.y-blocker.x;\n\t\t\t\t\t\tref *= blocked;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc += ref * filter_col;\n\n\t\t\t\t\tV = bg_V = normalize( refract(bg_V,N,0.995) );\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlast_surface_t = int_t;\n\t\t\t}\t\t\t\n\t\t\t\t\t\t\n\t\t\t//stop if grad is pointing away from view ray...\n\t\t\t//saves steps but introduces some nasty artifacts on some cards\n\t/*\t\tvec3 G=-ss_grad(X);\n\t\t\tif (dot(G,V) < 0.0) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t\t\n\t\t\n\t\t//\tt -= d;\t\t\n\t\t\tt += t_step;\n\t\t\t\n\t\t\told_d = d;\n\t\t\t\n\t\t\tsteps++;\n\t\t}\n\t\t\t\t\n//\t\tfloat S = float(steps)/64.0; ///8.0;\n\t//\tfragColor = vec4(S,S,S,1.0);\n\t\t\t\t\n\t//\tfragColor = vec4(vec3(thick),1.0);\n\t\t\n\t//\tc += Filter(thick,trans)*bg;\n\t\tvec3 ref_bg = texture(iChannel1,bg_V).xyz  * overb;\n\t\tc += filter_col * ref_bg;\n\t//\tc += (1.0-thick)*bg;\n\n\t\tfragColor = vec4(c,1.0);\n\t\t\n\t//\tfragColor = vec4(vec3(last_f),1.0);\n\t//\tfragColor = vec4(vec3(blocked),1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(bg,1.0);\n\t}\t\n}\n","name":"Image","description":"","type":"image"}]}