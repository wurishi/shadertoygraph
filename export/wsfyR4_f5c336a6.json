{"ver":"0.1","info":{"id":"wsfyR4","date":"1584269933","viewed":320,"name":"Torus Mesh Circuit","username":"gaz","description":"3d","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["torus","mesh","stella"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float G1=0.0, G2=0.0;\n\nvec3 rot(vec3 p,vec3 a,float t) \n{\n\ta=normalize(a);\n\tvec3 v = cross(a,p),u = cross(v,a);\n\treturn u * cos(t) + v * sin(t) + a * dot(p, a);   \n}\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k ) \n{\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\nfloat deTetra(vec3 p) \n{\n\tvec2 g=vec2(-1,1)*0.577;\n\treturn pow(\n\t\tpow(max(0.0,dot(p,g.xxx)),8.0)\n\t\t+pow(max(0.0,dot(p,g.xyy)),8.0)\n\t\t+pow(max(0.0,dot(p,g.yxy)),8.0)\n\t\t+pow(max(0.0,dot(p,g.yyx)),8.0),\n\t\t0.125);\n}\n\nfloat deStella(vec3 p) \n{\n    p=rot(p,vec3(1,2,3),iTime*3.0);\n\treturn smin(deTetra(p)-1.0,deTetra(-p)-1.0,0.05);\n}\n\n#define Circle 2.0\nvec2 hash2( vec2 p )\n{\n    p = mod(p, Circle*2.0); \n\treturn fract(sin(vec2(\n        dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3))\n    ))*43758.5453);\n}\n\n// https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi(vec2 x)\n{\n    x*=Circle;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\to = 0.5 + 0.5*sin( iTime*0.3 + 6.2831*o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\to = 0.5 + 0.5*sin( iTime*0.3 + 6.2831*o );\n        vec2 r = g + o - f;\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n}\n\nfloat voronoiTorus(vec3 p){\n    vec2 size = vec2(12,5);\n    vec2 q = vec2(length(p.xz) - size.x, p.y);\n\tvec2 uv=vec2(atan(p.z, p.x),atan(q.y, q.x))/3.1415;\n\tvec3 vr=voronoi(uv*vec2(20,8));\n    vec2 p2=vec2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));\n    //vec2 p2=vec2(length(vr.yz)-0.5, sdTorus(p,size));\n\treturn lpNorm(p2,5.0)-0.1; \n}\n\nfloat map(vec3 p)\n{   \n    vec3 offset = vec3(6,0,0);\n    float de = min(voronoiTorus(p-offset),voronoiTorus(p.xzy+offset));\n    vec3 co = vec3(cos(iTime),0,sin(iTime))*10.0;\n    float s1= abs(sin(iTime))*3.0+2.0;\n    float deSG = min(deStella((p-co-offset)/s1),deStella((p-(co-offset).xzy)/s1))*s1;\n\tG1 +=0.1/(0.1+deSG*deSG*10.0);\n    float deS = min(deStella(p-co-offset),deStella(p-(co-offset).xzy));\n \tG2 +=0.1/(0.1+deS*deS*10.0);\n    de=min(de,deS);    \n    return de;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 5.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(0,20,50);\n    ro= vec3(cos(iTime*0.3+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.5+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\n    vec3 w = normalize(-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\n    vec3 col= mix(vec3(0),vec3(0.05,0.05,0.1),length(uv*vec2(1,1.2))*0.25);\n    float t=5.0,d;\n    for(int i=0;i<64;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001||t>50.0) break;\n    }\n    if(d<0.001)\n    {\n        col=vec3(0.5,0.5,0.55);\n        vec3 p=ro+rd*t;\n        vec3 n = calcNormal(p);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(n, li), 0.0, 1.0);\n        dif *= softshadow(p, li);\n        col *= max(dif, 0.3);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd + 2.2 * (1.0 - rimd);\n    \tcol *= frn*vec3(0.6,0.1,0.3);\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.0,0.6,1.0)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n     \tcol+=vec3(1,0.2,0)*G1*.05;\n    \tcol+=vec3(1,0.1,0)*G2*.03*(sin(iTime*5.0)*0.5+0.6);\n       \tcol = mix( col, vec3(0.2), 1.0-exp( -0.0005*t*t ) );\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}