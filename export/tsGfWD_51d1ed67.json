{"ver":"0.1","info":{"id":"tsGfWD","date":"1607129011","viewed":136,"name":"Retro scroller","username":"weirdfoo","description":"I was looking at a retro/synthwave music video on Youtube and thought, \"Well, I can do something like that in Shadertoy :)\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------\n// Define some retro colors :)\n//------------------------------------------------------------------\n\nvec3 black\t\t\t= vec3(0.0, \t\t\t0.0, \t\t\t0.0);\nvec3 neon_pink \t\t= vec3(2.0, \t\t\t0.2, \t\t\t3.0);\nvec3 retro_pink \t= vec3(0.968627451, \t0.2784313725, \t0.8156862745);\nvec3 retro_purple \t= vec3(0.768627451,\t\t0.0039215686, \t1.0);\nvec3 retro_blueish \t= vec3(0.403921568,\t\t0.1294117647, \t0.9960784314);\nvec3 retro_yellow \t= vec3(0.968627451, \t0.9568627451, \t0.1607843137);\nvec3 retro_orange \t= vec3(0.968627451, \t0.3, \t\t\t0.1607843137);\n\n//------------------------------------------------------------------\n// Do the raycast here\n//------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, -1.0 );\n    \n    //if ( pos.x > -15.0)\n    {\n        // TODO : change the depth to a repetition instead\n\t\t// TODO : make the diferent heights procedural\n\n        vec3 repetition = vec3(0.0, 0.0, 5.15);\n        float dist = 18.0;\n        \n        // Precedural repeating buildings in the horizon\n        {\n            float material = 2.0;\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -dist, 0.5, 0.5), vec3(0.1, 0.5, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -dist, 0.25,1.5), vec3(0.1, 0.25,0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -dist, 0.4, 2.5), vec3(0.1, 0.4, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -dist, 0.3, 3.5), vec3(0.1, 0.3, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -dist, 0.15,4.5), vec3(0.1, 0.15,0.3), repetition ), material ) );\n        }\n        {\n            float material = 2.1;\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+2.0), 1.0, 0.5), vec3(0.1, 1.0, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+2.0), 0.5, 1.5), vec3(0.1, 0.5, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+2.0), 0.8, 2.5), vec3(0.1, 0.8, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+2.0), 0.65,3.5), vec3(0.1, 0.65,0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+2.0), 0.3, 4.5), vec3(0.1, 0.3, 0.3), repetition ), material ) );\n        }\n        {\n            float material = 2.3;\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+3.0), 1.0, 2.5), vec3(0.1, 1.0, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+3.0), 0.5, 3.5), vec3(0.1, 0.5, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+3.0), 0.8, 4.5), vec3(0.1, 0.8, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+3.0), 0.65,5.5), vec3(0.1, 0.65,0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+3.0), 0.3, 6.5), vec3(0.1, 0.3, 0.3), repetition ), material ) );\n        }\n\n        {\n            float material = 2.6;\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+4.0), 1.0, 1.5), vec3(0.1, 1.0, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+4.0), 0.5, 2.5), vec3(0.1, 0.5, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+4.0), 0.8, 3.5), vec3(0.1, 0.8, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+4.0), 0.65,4.5), vec3(0.1, 0.65,0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+4.0), 0.3, 5.5), vec3(0.1, 0.3, 0.3), repetition ), material ) );\n        }\n\n        {\n            float material = 2.99;\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+5.0), 1.0, 4.5), vec3(0.1, 1.0, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+5.0), 0.5, 5.5), vec3(0.1, 0.5, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+5.0), 0.8, 6.5), vec3(0.1, 0.8, 0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+5.0), 0.65,7.5), vec3(0.1, 0.65,0.3), repetition ), material ) );\n            res = opU( res, vec2( sdBoxRep(pos - vec3( -(dist+5.0), 0.3, 8.5), vec3(0.1, 0.3, 0.3), repetition ), material ) );\n        }\n    }\n    \n    return res;\n}\n\nvec2 raycast( in vec3 rayOrigin, in vec3 rayDirection )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 40.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-rayOrigin.y)/rayDirection.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    \n    // raymarch primitives \n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        vec2 h = map( rayOrigin + rayDirection * t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    // Note : the sun is renderd screenspace, so its not here... But maybe it should !\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n\nfloat gridPattern( in vec2 p, in vec2 dpdy )\n{\n    float val = 0.95 + dpdy.x * 0.5; \n    float grid = min(1.0, (max(0.0,sin(p.x)-val) + max(0.0,sin(p.y)-val)) * (1.0/(1.0 - val))) * (1.2 + abs(dpdy.x) * 0.3);\n    grid *= grid;\n    grid *= grid;\n\treturn grid;\n}\n\n\nvec3 render( in vec3 rayOrigin, in vec3 rayDirection, in vec3 rdx, in vec3 rdy, in vec2 uv, float time)\n{ \n    // background\n    vec3 bg = mix(mix(retro_purple * 0.6, retro_blueish * 0.2, max(rayDirection.y + 0.2,0.0) *3.5), vec3(0,0,0), max(rayDirection.y,0.0) *3.5) ;\n    vec3 color = bg;\n    \n    // raycast scene\n    vec2 res = raycast(rayOrigin, rayDirection);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m > 0.1 )\n    {\n        vec3 pos = rayOrigin + t * rayDirection;\n        \n        // materials\n        \n        if( m<2.0 ) // Retro grid material\n        {\n            // project Y pixel footprint into the plane\n            vec3 dpdy = rayOrigin.y*(rayDirection/rayDirection.y-rdy/rdy.y);\n            float material = gridPattern( 8.0*pos.xz,2.0*dpdy.xz );\n            color = mix(retro_blueish * 0.15, neon_pink, clamp(material, 0.0, 100.0));\n            if(pos.x < -8.0)\n                color = mix(color, retro_purple * 0.7, clamp(-(pos.x + 10.0) * 0.1, 0.0, 1.0));\n        }\n        else if( m<3.0 ) // building material\n        {\n            // Make sides of buildings darker\n            vec3 normal = calcNormal(pos);\n            float factor = mix(0.2, 1.0, abs(dot(normal,rayDirection)));\n            \n            color = mix(retro_purple, retro_blueish, fract(m)) * factor;\n        }\n       \n        // Fog-ish\n        color = mix( color, bg, clamp(1.0-exp( -0.000125*t*t*t ), 0.0, 1.0));\n    }\n    \n    // Sun\n    if(m <= 0.0 || t > 35.0)\n    {\n        vec3 sunColor = mix(retro_orange, retro_yellow, clamp(uv.y - 0.3,0.0, 1.0));\n        vec2 sunUV = uv - vec2(0.0, 0.5);\n        sunUV += vec2(0.0, 0.2);\n        color = mix( color, sunColor, sun(sunUV, time, 0.2));\n    }\n\n\treturn vec3( clamp(color,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 target = vec3( 0.5, 1, -0.7 + time );\n    vec3 rayOrigin = target + vec3( 4.5*cos(0.1 + 7.0), 0.3, 0.0);\n    // camera-to-world transformation\n    mat3 camera = setCamera( rayOrigin, target, 0.0 );\n\n    vec2 position = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // ray direction\n    vec3 rayDirection = camera * normalize( vec3(position,2.5) );\n\n    // ray differentials\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = camera * normalize( vec3(px,2.5) );\n    vec3 rdy = camera * normalize( vec3(py,2.5) );\n\n    // render\t\n    vec3 color = render( rayOrigin, rayDirection, rdx, rdy, position, time);\n\n    // Color correction stuff\n    color = color*3.0/(2.5+color);\n    color = pow( color, vec3(0.7) );\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//------------------------------------------------------------------\n// Generic SDF stuff from Iq (https://iquilezles.org)\n//------------------------------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdBoxRep( vec3 p, vec3 b, in vec3 c)\n{\n    return sdBox(opRep(p,c), b);\n}\n\n#define ZERO (min(iFrame,0))\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//------------------------------------------------------------------\n// Retro sun code, based on https://www.shadertoy.com/view/Wt33Wf\n//------------------------------------------------------------------\n\nfloat sun(vec2 uv, float time, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + time * 0.3 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n","name":"Common","description":"","type":"common"}]}