{"ver":"0.1","info":{"id":"mtS3WV","date":"1673921694","viewed":144,"name":"Swimming with the fishes","username":"ianertson","description":"Experimented with ray marching, this kind of looks like you're under the ocean at certain times","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","water","ocean","fishes","swimming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAY_STEPS 24\n#define STEP_SIZE 0.33\n#define BIOME_FREQ 0.6\n#define GEOMETRY_FREQ 24.7\n#define GEOMETRY_RANGE 48.4\n#define REFLECTION 0.22\n#define REFRACTION 0.23\n#define SPEED 0.03\n\n#define _GEOMETRY_FREQ (GEOMETRY_FREQ/256.0)\n\nvec3 rand3(vec3 p, float freq) {\n   vec3 a = textureLod(iChannel0, (p+vec3(0.0, 0.0, 0.0))*freq, 0.).xyz;\n   vec3 b = textureLod(iChannel0, (p-vec3(freq+0.001, -(freq+0.001), (freq+0.001)))*freq, 0.).xyz;\n   return mix(a, b, 0.5);\n}\n\nfloat signlerp(float v) { return mix(-1.0, 1.0, v); }\n\nvec3 rand3Signed(vec3 p, float freq) {\n    vec3 a = rand3(p, freq);\n    vec3 b = rand3(p + vec3(0.1, -0.01, 0.01), freq);\n    float sx = signlerp(b.x);\n    float sy = signlerp(b.y);\n    float sz = signlerp(b.z);\n    return a * vec3(sx, sy, sz);\n}\n\n\n\nvec3 getPoint(vec3 p) {\n    vec3 p1 = rand3Signed(p, _GEOMETRY_FREQ);\n    vec3 p2 = rand3Signed(((p1 * p) + vec3(0.04, 0.1, -0.02))*0.45, _GEOMETRY_FREQ);\n    vec3 point = (p2)*GEOMETRY_RANGE;\n    \n    return point;\n}\n\nfloat D(vec3 a, vec3 b) { return abs(distance(a, b)); }\n\n\nvec3 getNormal(vec3 o, vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = D(o, p) - \n        vec3(D(o, p-e.xyy), D(o, p-e.yxy),D(o, p-e.yyx));\n    \n    return normalize(n);\n}\n\nbool getSample(inout Ray ray, vec3 p) {\n    vec3 point = getPoint(p);\n    float dist = abs(distance(p, point));\n    if (dist <= ray.near || dist >= ray.far) return false;\n    \n\n  \n    vec3 normal = rand3Signed(normalize(p) / (max(0.001, dist)*32.2), GEOMETRY_FREQ);\n    normal = mix(normal, normalize(p+ray.result.point), 0.5);\n    \n    normal = mix(normal, getNormal(p, point), 0.4);\n    \n    ray.result.normal = normalize(normal);\n    ray.result.point = point;\n    ray.result.dist = dist;\n    \n    return true;\n    \n}\n\n\n\n\nvec3 shade(in Ray ray, vec3 point, in Light light) {\n    \n    vec3 viewdir = normalize(point - ray.origin);\n    \n   \n    vec3 biome = rand3((point)*0.09*BIOME_FREQ, 0.05);\n    vec3 albedo = rand3(normalize(normalize(point)*ray.result.normal), 0.05);\n    albedo = normalize(albedo);\n    \n    float dist = abs(ray.result.dist);\n    float lightDist = abs(distance(point, light.pos));\n    vec3 L = normalize(point - light.pos);\n    float NdotL = max(0.0, dot(ray.result.normal, L));\n    float VdotL = max(0.0, dot(viewdir, L));\n    float RdotL = max(0.0, dot(ray.dir*-1., L));\n    \n    float att = max(0.02, NdotL * (pow(light.strength, 2.0) / max(0.0001, pow(lightDist, 2.0))));\n    att *= M_PI;\n    \n   \n\n    vec3 col = (albedo) * biome * light.color * att;\n    \n    col += (light.color * smoothstep(0.0, 1.0, pow(RdotL, 8.0))) / (M_PI*M_PI);\n    \n    float depth = (ray.result.dist-ray.near)/ray.far;\n    col += depth*0.5;\n    return max(vec3(0.0), col);\n}\n\n\n\nvec3 march(inout Ray ray, inout float finalDist, in Light light) {\n    vec3 col = vec3(0.0);\n    float minDist = ray.far;\n    vec3 p = ray.origin;\n   // int count = 0;\n    vec3 best = vec3(0.0);\n    \n    finalDist = ray.far;\n\n    for (float i = 0.; i < float(RAY_STEPS); i+= STEP_SIZE) {\n        if (!getSample(ray, p)) break;\n        \n        if (ray.result.dist > ray.near && ray.result.dist < minDist && ray.result.dist > ray.near) {\n            col = shade(ray, ray.result.point, light);\n            \n            float depth = ray.result.dist / ray.far;\n         \n            vec3 dirp = normalize(ray.result.point - ray.origin);\n           ray.dir += depth*(length(ray.result.normal)*(max(0.0, dot(ray.result.normal, dirp))*normalize(reflect(ray.result.normal, dirp)))) * REFLECTION;\n           \n           ray.dir += depth*(length(ray.result.normal)*normalize(refract(ray.result.normal,dirp, max(0.0, dot(normalize(ray.dir), dirp))))) * REFRACTION;\n           ray.dir = normalize(ray.dir);\n            minDist = ray.result.dist;\n            finalDist =  minDist;\n           // count += 1;\n\n        }\n        \n\n        p += ray.dir*STEP_SIZE;\n    \n    }\n\n  return col;\n    \n//    if (count <= 0) return vec3(0.0);\n//    return col / float(count);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n\n    vec2 res = iResolution.xy;\n    vec2 uv = fc/iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 lookDir = vec3(0.0, 0.0, -1.0);\n    \n    float speed = SPEED;\n    float T = iTime*speed;\n    \n    vec3 lightpos = vec3(0.0, 0.0, -4.0);\n    lightpos += vec3(sin(iTime*speed)*0.721, cos(iTime*speed)*0.2324, cos(iTime*speed)*1.6);\n    Light light = Light(lightpos, 3.6, vec3(0.6, 0.7, 0.9));\n    \n   \n    \n    \n    vec3 rand = rand3Signed(vec3(0.1, 1.0, 0.2), 0.1);\n    rand = 0.5*vec3(cos(rand.x+T), sin(rand.y+T), sin(rand.z+T));\n    \n    origin += (rand)*24.;\n    float fov = 60.0;\n    float near = 0.5;\n    float far = 400.0;\n    \n    lookDir = normalize(origin - light.pos);\n   lookDir += 0.3*vec3(cos(T*1.6), sin(T)*0.5, sin(T*2.6));\n \n    Ray ray = getPrimaryRay(origin, fc, res, lookDir, fov,\n                  near, far);\n\n    \n    float dist = ray.far;\n    col = march(ray, dist, light);\n   col *= M_PI;\n    col += luma(col)/M_PI;\n    \n    col = aces(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\n\nstruct Light {\n    vec3 pos;\n    float strength;\n    vec3 color;\n};\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = lookAtPoint;\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat4 proj(float fovy, float aspect, float nearZ, float farZ) {\n\n  mat4 dest = mat4(0.0);\n  float f = 1.0f / tan(fovy * 0.5f);\n  float fn = 1.0f / (nearZ - farZ);\n\n  dest[0][0] = f / aspect;\n  dest[1][1] = f;\n  dest[2][2] = -farZ * fn;\n  dest[2][3] = 1.0f;\n  dest[3][2] = nearZ * farZ * fn;\n  return dest;\n}\n\nmat4 look(vec3 eye, vec3 center, vec3 up) {\n  mat4 dest = mat4(0.0);\n  vec3 f = vec3(0.0);\n  vec3 u = vec3(0.0);\n  vec3 s = vec3(0.0);\n\n  f = normalize(center - eye);\n\n  s = cross(up, f);\n  u = cross(f, s);\n\n  dest[0][0] = s[0];\n  dest[0][1] = u[0];\n  dest[0][2] = f[0];\n  dest[1][0] = s[1];\n  dest[1][1] = u[1];\n  dest[1][2] = f[1];\n  dest[2][0] = s[2];\n  dest[2][1] = u[2];\n  dest[2][2] = f[2];\n  dest[3][0] = -dot(s, eye);\n  dest[3][1] = -dot(u, eye);\n  dest[3][2] = -dot(f, eye);\n  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;\n  dest[3][3] = 1.0f;\n\n  return dest;\n}\n\nstruct RayResult {\n  vec3 normal;\n  vec3 point;\n  vec2 uv;\n  float dist;\n  vec3 color;\n  vec4 rot;\n  float id;\n  int iid;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n  float near;\n  float far;\n  int skip_id;\n  bool is_any;\n  RayResult result;\n};\n\nRay getPrimaryRay(vec3 origin, vec2 coord, vec2 res, vec3 lookDir, float fov,\n                  float near, float far) {\n  Ray ray;\n  ray.near = near;\n  ray.far = far;\n  ray.skip_id = -1;\n  ray.origin = origin;\n  ray.dir = normalize((inverse(proj(radians(fov), res.x / res.y, near, far) *\n                               look(lookDir, vec3(0.0), vec3(0, 1, 0))) *\n                       vec4(vec2(((coord.x - res.x / 2.0)) / res.x,\n                                 ((coord.y - res.y / 2.0)) / res.y) /\n                                0.5,\n                            1.0, 1.0))\n                          .xyz);\n  return ray;\n}\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvec3 reinhard2(vec3 x) {\n  const float L_white = 4.0;\n  return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\nvec3 fromLinear(vec3 linearRGB)\n{\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB/vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}","name":"Common","description":"","type":"common"}]}