{"ver":"0.1","info":{"id":"ll2yWw","date":"1508948738","viewed":343,"name":"Polygonal area light","username":"morphiumsuchtig","description":"This is the adaptation of my method of algebraic approximation of polygonal area lights for real-time shading  (https://github.com/bad3p/PAL/blob/master/Docs/PolygonalAreaLights_09081016.pdf).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat4 rotationMatrix(float x, float y, float z)\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 translationMatrix(float x, float y, float z)\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n  \t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,  y, z, 1.0 );\n\n}\n\n\nmat4 perspectiveMatrix(float fov, float aspect, float near, float far)\n{\n    float f = abs(tan(3.1415926 * 0.5 - 0.5 * fov));\n    f = 1.0 / tan(fov * 3.1415926/ 180.0 / 2.0);\n    float invRange = 1.0 / (near - far);\n\treturn mat4\n\t(\n      f/aspect, 0.0, 0.0, 0.0,\n      0.0, f, 0.0, 0.0,\n      0.0, 0.0, (near + far) * invRange, -1.0,\n      0.0, 0.0, near * far * invRange * 2.0, 0.0\n    );\n}\n\nbool rayPlaneIntersection(vec3 planeNormal, vec3 pointOnPlane, vec3 rayOrigin, vec3 rayDirection, out vec3 wordIntersection)\n{\n\tvec3 w = rayOrigin - pointOnPlane;\n\tfloat s = -dot( planeNormal, w ) / dot( planeNormal, rayDirection );\n    wordIntersection = rayOrigin + rayDirection * s;\n\treturn ( s < 0.0 );\n}\n\nfloat signTest(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool pointInsideTriangle(vec2 pt, vec2 v0, vec2 v1, vec2 v2)\n{    \n    bool b1, b2, b3;\n\n    b1 = signTest(pt, v0, v1) < 0.0;\n    b2 = signTest(pt, v1, v2) < 0.0;\n    b3 = signTest(pt, v2, v0) < 0.0;\n\n    return ((b1 == b2) && (b2 == b3));\n}\n\n//--------------------------------------------------------------------------------\n\nconst vec3 planeNormal = normalize( vec3( 0.0, 1.0, 0.0 ) ) ;\nconst vec3 pointOnPlane = vec3( 0.0, -0.33, 0.0 );\n\nconst float areaLightIntensity = 2.0;\nconst vec4 areaLightColor = vec4( 0.97, 0.93, 0.11, 1.0 );\nconst vec4 ambientColor = vec4( 0.25, 0.25, 0.25, 1.0 );\n\nconst vec4 areaLightNormal = vec4( 0.0, 0.0, 1.0, 0.0 );\n\nconst vec4[] areaLightVertices = vec4[] \n(\n    vec4( 0.0, 0.0, 0.0, 1.0 ),\n\tvec4( -0.500, -0.500, 0.0, 1.0 ),\n\tvec4( -0.500, 0.500, 0.0, 1.0 ),\n\tvec4( 0.500, 0.500, 0.0, 1.0 ),//3\n\tvec4( 0.500, -0.500, 0.0, 1.0 ),\n\tvec4( 2.0, 0.000, 0.0, 1.0 ),//5\n\tvec4( 0.000, 2.0, 0.0, 1.0 ),\n\tvec4( -2.0, 0.000, 0.0, 1.0 ),\n\tvec4( 0.000, -2.0, 0.0, 1.0 ),\n\tvec4( 0.000, 0.000, 0.0, 1.0 )//9\n);\n\nconst int[] areaLightIndices = int[]\n(\n\t5, 3, 9,\n\t3, 6, 9,\n\t6, 2, 9, \n\t2, 7, 9, \n\t7, 1, 9, \n\t1, 8, 9, \n\t8, 4, 9, \n\t4, 5, 9     \n);\n\n//--------------------------------------------------------------------------------\n\nvoid getWorldRay(mat4 screenToWorldSpaceMatrix, vec2 fragCoord, out vec3 worldRayOrigin, out vec3 worldRayDir)\n{\n    vec4 screenPos1 = vec4( fragCoord.xy / iResolution.xy * 2.0 - 1.0, 0.0, 1.0 );\n    vec4 screenPos2 = vec4( fragCoord.xy / iResolution.xy * 2.0 - 1.0, -0.5, 1.0 );\n    \n    vec4 worldPos1 = screenToWorldSpaceMatrix * screenPos1;\n    vec4 worldPos2 = screenToWorldSpaceMatrix * screenPos2;\n    \n    worldPos1 /= worldPos1.w;\n    worldPos2 /= worldPos2.w;\n\n    worldRayOrigin = worldPos1.xyz;\n    worldRayDir = normalize( worldPos2.xyz - worldPos1.xyz );\n}\n\nvec3 getPointInBasis(vec3 p, vec3 b0, vec3 bx, vec3 by, vec3 bz)\n{\n    vec3 pb = p - b0;\n    return vec3( dot( pb, bx ), dot( pb, by ), dot( pb, bz ) );\n}\n\nfloat cross2(vec2 u, vec2 v)\n{\n    return u.x * v.y - u.y * v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 cameraMatrix = translationMatrix( 0.0, 3.0, 6.0 ) * rotationMatrix( -0.2 - iMouse.y * 0.001, 0.0, 0.0 );    \n    mat4 projectionMatrix = perspectiveMatrix(70.0, iResolution.x/iResolution.y, 0.01, 10.0 );\n    mat4 screenToWorldSpaceMatrix = cameraMatrix * inverse( projectionMatrix );\n    \n    vec3 worldRayOrigin;   \n    vec3 worldRayDir;\n    \n    getWorldRay( screenToWorldSpaceMatrix, fragCoord, worldRayOrigin, worldRayDir );\n    \n    // raycasting against plane\n    \n    vec3 worldPos1;\n    bool planeRaycastResult = rayPlaneIntersection( planeNormal, pointOnPlane, worldRayOrigin, worldRayDir, worldPos1 );\n    \n    // raycasting against area light triangles\n    \n    mat4 areaLightMatrix = translationMatrix( 0.0, 3.0 + sin(iTime), -1.0 ) * \n        rotationMatrix( 0.5 * sin( iTime ), 0.0, 0.0 ) *\n        rotationMatrix( 0.0, iTime * 0.25, 0.0 ) *\n        rotationMatrix( 0.0, 0.0, iTime );\n    mat4 invertedAreaLightMatrix = inverse( areaLightMatrix );\n    \n    bool areaLightRaycastResult = false;    \n    vec3 worldPos2 = worldPos1;\n    vec3 n = normalize( ( areaLightMatrix * areaLightNormal ).xyz );\n    float normalCondition = dot( planeNormal, n );\n    float polygonArea = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        int i0 = areaLightIndices[i*3];\n        int i1 = areaLightIndices[i*3+1];\n        int i2 = areaLightIndices[i*3+2];\n        \n        vec3 v0 = ( areaLightMatrix * areaLightVertices[i0] ).xyz;        \n        \n        vec3 worldPos;\n        bool triangleRaycastResult = false;\n        if( rayPlaneIntersection( n, v0, worldRayOrigin, worldRayDir, worldPos ) )\n        {        \n        \tvec4 localPos = invertedAreaLightMatrix * vec4( worldPos.xyz, 1.0 );\n\n        \ttriangleRaycastResult = pointInsideTriangle( localPos.xy, areaLightVertices[i0].xy, areaLightVertices[i1].xy, areaLightVertices[i2].xy );\n            if( triangleRaycastResult )\n            {                \n        \t\tareaLightRaycastResult = true;\n                worldPos2 = worldPos;\n            }\n        }\n        \n        // diffuse light contribution from triangle \n                \n        if( !triangleRaycastResult && planeRaycastResult && normalCondition < 0.9999 )\n        {\n            vec3 v1 = ( areaLightMatrix * areaLightVertices[i1] ).xyz;\n        \tvec3 v2 = ( areaLightMatrix * areaLightVertices[i2] ).xyz;            \n            \n            vec3 c = (v0 + v1 + v2) / 3.0;\n            vec3 bz = normalize( c - worldPos1 );\n            \n            float sideEffect = dot( bz, n );            \n            if( sideEffect > 0.0 )\n            {            \n            \tvec3 by = vec3( bz.y, bz.z, -bz.x );\n            \tvec3 bx = normalize( cross( by, bz ) );\n            \tby = normalize( cross( bz, bx ) );\n            \n            \tvec3 lv0 = getPointInBasis( v0, worldPos1, bx, by, bz );\n            \tvec3 lv1 = getPointInBasis( v1, worldPos1, bx, by, bz );\n            \tvec3 lv2 = getPointInBasis( v2, worldPos1, bx, by, bz );\n            \n            \tlv0.xy /= lv0.z;\n            \tlv1.xy /= lv1.z;\n            \tlv2.xy /= lv2.z;\n            \n            \tpolygonArea += 0.5 * cross2( lv1.xy-lv0.xy, lv2.xy-lv0.xy );                \n            }\n        }\n    }\n    \n    float localIntensity = polygonArea * areaLightIntensity;\n    vec4 planeColor = ambientColor + areaLightColor * localIntensity;\n    \n    vec4 areaLightColor = mix( \n        areaLightColor, \n        areaLightColor * 0.5, \n        step( 0.0, dot( n, worldRayDir ) )\n    );\n    \n    if( planeRaycastResult )\n    {\n        if( areaLightRaycastResult )\n        {\n            float worldDist1 = distance( worldRayOrigin, worldPos1.xyz );\n    \t\tfloat worldDist2 = distance( worldRayOrigin, worldPos2.xyz );\n            \n            fragColor = mix(\n        \t\tplaneColor,\n        \t\tareaLightColor,\n        \t\tfloat(worldDist1>worldDist2)\n    \t\t);\n        }\n        else\n        {\n            fragColor = planeColor;\n        }\n    }\n    else if( areaLightRaycastResult )\n    {\n        fragColor = areaLightColor;\n    }\n    else\n    {\n        fragColor = vec4( 0, 0, 0, 1 );\n    }\n}","name":"Image","description":"","type":"image"}]}