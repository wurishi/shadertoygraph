{"ver":"0.1","info":{"id":"ltG3WR","date":"1474068252","viewed":357,"name":"Monte Carlo anti-aliasing","username":"stduhpf","description":"A really simple anti-aliasing, based on  montecarlo (works like a supersampling)\n\noriginal : [url=https://www.shadertoy.com/view/4lKGzW]Phoenix sets-orbit traps[/url]","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","antialiasing","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = pow(texture(iChannel0,uv)/float(iFrame+1),vec4(1./2.4));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define monte_carlo  //(comment this line to disable antialiasing )\n\n//#define compare //uncomment to see side by side with and without antialiasing\n\t#define compcond fragCoord.x<iResolution.x/2. \n\n#define blur 1. // (below 1 is subpixel(for the antialiasing), above makes a square blur)\n\n#define zoom 1./8.\n#define position vec2(.41002,.22);\n\n#define iterations 150  //try 5000 for a really good looking render if your GPU is fast enough\n\nfloat hash( float n )\n{\n    return blur*(fract(sin(n)*43758.5453)-.5);\n}\n\nvoid mainImage( out vec4 fColor, in vec2 fragCoord )\n{\n    vec4 fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n    if(iFrame==0)fragColor*=0.;\n    vec2 p = iMouse.xy / iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5);\n    \n    \n    vec2 c =vec2(p.x,0);\n    p=vec2(p.y,0);\n    \n    p*=3.;\n    #ifdef monte_carlo\n    #ifdef compare\n    if(compcond)\n    #endif\n    fragCoord.xy+=vec2(hash(iDate.w+fragCoord.x),hash(fragCoord.y-iDate.w));\n    #endif\n\n    vec2 uv = fragCoord.xy/iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5);\n    \n   uv*=3.*zoom;\n    uv+=position;\n        \n       p= vec2(-.5,0);\n     c=vec2(.56667,0)  ;\n    \n    vec2 z1=uv;\n    vec2 z=uv;\n  \n    vec4 dmin=vec4(1e6);\n    for(int i =0;i<iterations;i++)\n    {\n        vec2 z2 = z;\n        z=z*mat2(z.x,-z.y,z.yx)+c+z1*mat2(p.x,-p.y,p.yx);\n        z1=z2;\n        \n\t\tdmin=min(dmin, vec4(abs(length(z1)-length(z))\n                           ,length(sin(z))*length(uv)\n                           ,abs(z.x)\n                           ,abs(dot(z,z1))));\n    }    \n    vec3 color = vec3( pow(dmin.r,0.6) );\n\tcolor = mix( color, vec3(1.00,0.50,0.20), min(1.0,pow(dmin.w*0.5,0.40)) );\n    color = mix( color, vec3(0.4,0.70,0.40), min(1.0,pow(dmin.y*.1,0.50)) );\n\tcolor = mix( color, vec3(1.00,.70,.50), 1.0-min(1.0,pow(dmin.z*1.00,0.15) ));\n\n\n\tfragColor += vec4(pow(color,vec3(2.4)),1.0);\n    \n    fColor = fragColor;\n}","name":"Buffer A","description":"","type":"buffer"}]}