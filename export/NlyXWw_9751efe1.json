{"ver":"0.1","info":{"id":"NlyXWw","date":"1640753859","viewed":140,"name":"Breathing - Twisting","username":"PGRacer","description":"Strange places...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GetDist(vec3 p, vec2 uv)\n{\n    float cellsize = 0.97 * PI;\n    vec3 pCell = Cellularize(p, cellsize);\n    \n    vec3 rotOffset = p - mod(p, cellsize);\n    \n    mat3x3 rotz = GetRotation3x3(4.0 * TIME + p.z, normalize(vec3(0.0, 0.0, 1.0)));\n    vec3 pRot = rotz * pCell;\n    \n    float waveLimit = 1.5;\n    float dist1 = sdBox(pRot, vec3(0.0), vec3(Sin0To1(TIME) * waveLimit, Cos0To1(TIME) * waveLimit, 2.0)) -0.1;\n    \n    return dist1;\n}\n\nvec3 GetNormal(vec3 p, vec2 uv)\n{\n\tvec2 e = vec2(NORMAL_CHECK_OFFSET, 0);\n\tint objID;\n\tvec3 n = GetDist(p, uv) - vec3(\n\t\tGetDist(p - e.xyy, uv),\n\t\tGetDist(p - e.yxy, uv),\n\t\tGetDist(p - e.yyx, uv)\n\t\t);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Keep outline width same in full screen\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    float vignette = smoothstep(0.8, 0.001, length(uv));\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    // Camera Stuff\n    vec3 camPos = vec3(0.0, 0.0, -2.0);\n    vec3 camDir = normalize(vec3(uv.x, uv.y, 1.0));\n\n    // Do raymarching\n    float dO = 0.0;\n\tvec3 p;\n\tbool outline = false;\n\tbool hit = false;\n    float prevDist = MAX_DIST * 1.01;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tp = camPos + camDir * dO;\n\t\tfloat d = GetDist(p, uv);\n\t\tdO += d;\n\n\t\tif (!outline && d < outlineWidth * (log2(dO + 1.0)) + SURF_DIST)\n\t\t{\n\t\t\toutline = true;\n\t\t}\n\n\t\tif (dO > MAX_DIST)\n\t\t{\n            outline = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d <= SURF_DIST)\n\t\t{\n            hit = true;\n\t\t\tbreak;\n\t\t}\n        \n        // If at any point we've gotten within the thickness of our outline and \n        // then we get further away from a hit we break out and draw the outline\n        if (outline && prevDist < d)\n        {\n            break;\n        }\n        \n        prevDist = d;\n\t}\n    \n    vec3 col;\n    vec3 bgcol = smoothstep(-.5, 0.0, vec3(uv.y));\n    \n    if (hit)\n    {\n        vec3 normal = GetNormal(p, uv);\n        vec3 absNormal = abs(normal);\n        col = vec3(\n            pow(absNormal.x, COLOR_SEPARATION),\n            pow(absNormal.y, COLOR_SEPARATION),\n            pow(absNormal.z, COLOR_SEPARATION)\n        );\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, -0.5));\n        float scalar = dot(lightDir, normal);\n        scalar = clamp(scalar, 0.0, 1.0);\n        scalar *= LIGHT_POWER;\n        scalar = (scalar + 1.0) / 2.0;\n        col *= scalar;       \n        col = mix(bgcol, col, smoothstep(MAX_DIST, 0.0, dO));\n    }\n    else if (outline)\n    {\n        col = vec3(0.0);\n        col = mix(bgcol, col, smoothstep(MAX_DIST, 0.0, dO));\n    }\n    else\n    {\n        col = bgcol;\n    }\n    \n    // Fade scene in at start\n    col *= smoothstep(FADE_IN_DELAY, FADE_IN_DELAY + FADE_IN_LENGTH, iTime);\n    col *= vignette;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 200\n#define MAX_DIST 50.0\n#define SURF_DIST 0.001\n#define NORMAL_CHECK_OFFSET 0.01\n#define OUTLINE_WIDTH 4.0\n#define COLOR_SEPARATION 3.0\n#define LIGHT_POWER 3.0\n#define TIME iTime * 0.5\n#define FADE_IN_DELAY 0.1\n#define FADE_IN_LENGTH 1.0\n#define PI 3.141592\n\nmat3x3 GetRotation3x3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n\t\tt * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n\t\tt * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n\t);\n}\n\nmat4 GetRotation4x4(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4\n    (\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n        0.0,                                0.0,                                0.0,                                1.0\n    );\n}\n\nfloat GetAvgComponentLength(vec3 v)\n{\n    return (abs(v.x) + abs(v.y) + abs(v.z)) / 3.0;\n}\n\nfloat SmoothBlend(float a, float b, float smoothing)\n{\n    float h = clamp((b - a) / smoothing + 0.5, 0.0, 1.0);\n    float m = h * (1.0 - h) * smoothing;\n    return h * a + (1.0 - h) * b - m * 0.5;\n}\n\nvec3 Cellularize(vec3 p, float cellsize)\n{\n    float halfCell = cellsize / 2.0;\n    return (mod(p, cellsize) - vec3(halfCell)) / halfCell;\n}\n\nfloat Sin0To1(float value)\n{\n    return sin(value) * 0.5 + 0.5;\n}\n\nfloat Cos0To1(float value)\n{\n    return cos(value) * 0.5 + 0.5;\n}\n\n// SPHERE\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n\treturn length(p - pos) - r;\n}\n\n// TORUS\nfloat sdTorus(vec3 p, vec3 pos, float w, float r)\n{\n\treturn length(vec2(length((p - pos).xz) - w, (p - pos).y)) - r;\n}\n\n// TORUS - CAPPED\nfloat sdCappedTorus(in vec3 p, in float angle, in float ra, in float rb)\n{\n    vec2 c = vec2(sin(angle),cos(angle));\n    \n    p.x = abs(p.x);\n    float k = (c.y*p.x>c.x*p.y) ? dot(p.xy,c) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// CAPSULE\nfloat sdCapsule(vec3 p, vec3 pos, float len, float rad)\n{\n\tvec3 a = pos + vec3(len * 0.5, 0.0, 0.0);\n\tvec3 b = pos + vec3(-len * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - rad;\n}\n\n// CYLINDER\nfloat sdCylinder(vec3 p, vec3 pos, float l, float r)\n{\n\tvec3 a = pos + vec3(l * 0.5, 0.0, 0.0);\n\tvec3 b = pos + vec3(-l * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0));\n\tfloat i = min(max(x, y), 0.0);\n\n\treturn e + i;\n}\n\n// GYROID\nfloat sdGyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    p *= repetition;\n    float avgRepetition = GetAvgComponentLength(repetition);\n    return abs(dot(sin(p * bias.x), cos(p.zxy * bias.y))) / avgRepetition - width;\n}\n\n// BOX\nfloat sdBox(vec3 p, vec3 pos, vec3 dimensions)\n{\n\treturn length(max(abs(p - pos) - (0.5 * dimensions), 0.0));\n}\n\n// BOX FRAME\nfloat sdBoxFrame(vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}","name":"Common","description":"","type":"common"}]}