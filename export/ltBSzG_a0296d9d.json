{"ver":"0.1","info":{"id":"ltBSzG","date":"1444519968","viewed":323,"name":"Art by Numbers II","username":"mhnewman","description":"Inspired by the works of Jasper Johns","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["procedural","art","jasper","johns"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\tVoronoi distance to borders from iq:\n//\thttps://www.shadertoy.com/view/ldl3W8\n\nconst float duration = 2.0;\nconst float borderNoise = 0.4;\nconst float lineNoise = 0.1;\nconst float borderBlend = 0.03;\nconst float lineBlend = 0.15;\n\nfloat hash11(float p) {\n    vec2 p2 = fract(p * vec2(443.8975, 397.2973));\n    p2 += dot(p2.xy, p2.yx + 19.19);\n    return fract(p2.x * p2.y);\n}\n\nfloat hash13(vec3 p) {\n\tp  = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec2 hash22(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 hash23(vec3 p) {\n\tp  = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.z * 97.597));\n}\n\nvec2 noise22(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(hash22(i + vec2(0.0, 0.0)), \n                               hash22(i + vec2(1.0, 0.0)), u.x),\n                           mix(hash22(i + vec2(0.0, 1.0)), \n                               hash22(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nvec2 fbm22(vec2 p) {\n    vec2 f = noise22(p); p = m * p;\n    f += 0.5 * noise22(p); p = m * p;\n    f += 0.25 * noise22(p); p = m * p;\n    f += 0.125 * noise22(p); p = m * p;\n    f += 0.0625 * noise22(p);\n    return f / 1.9375;\n}\n\nvec3 voronoi(in vec2 x, in float id) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ) {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash23( vec3(n + g, id) );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md ) {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ ) {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash23( vec3(n + g, id) );\n        vec2 r = g + o - f;\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( n + mg, md );\n}\n\n#define range(min, max) min + (max - min) * hash11(imageID + (hash += 0.1))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = fragCoord.xy / iResolution.y;\n    \n    float imageID = floor(iTime / duration);\n    float t = mod(iTime / duration, 1.0);\n\n    float hash = 0.0;\n    float cellCount = range(6.0, 14.0);\n    float lineCount = range(3.0, 6.0);\n    float lineWidth = range(0.3, 0.6);\n    float background = range(0.8, 1.0);\n    float colorScale = range(0.5, 0.9);\n    float colorSat = range(0.2, 0.5);\n    float colorOffset = 1.0 - colorSat;\n    float hueCount = floor(range(3.0, 6.5));\n    float hueDistrib = range(0.4, 1.0);\n    float hueAngle = range(0.0, 1.0);\n    \n    float totalCount = lineCount * cellCount;\n    \n    vec2 cellPos = pos * cellCount;\n    cellPos += borderNoise * fbm22(cellPos);\n    pos *= totalCount;\n    pos += lineNoise * fbm22(2.0 * pos);\n\n    vec3 cell = voronoi(cellPos, imageID);\n    vec3 cellID = vec3(cell.xy, imageID);\n    float angle = 6.2831853 * hash13(cellID);\n    float phase = hash13(cellID + 0.1);\n\n    float x = mod(pos.x * sin(angle) + pos.y * cos(angle) + phase, 1.0);\n    x = smoothstep(0.0, lineBlend, x) * smoothstep(lineWidth + lineBlend, lineWidth, x);\n    x *= smoothstep(0.05, 0.05 + lineBlend, cell.z * lineCount);\n\n    float hue = floor(hash13(cellID + 0.2) * hueCount) * hueDistrib / hueCount + hueAngle;\n    vec3 color = vec3(colorOffset) + vec3(colorSat) * cos(6.2831853 * (vec3(hue) + vec3(0.0, 0.33, 0.67)));\n\n    color = mix(vec3(background), colorScale * color, x);\n    \n    color *= smoothstep(0.0, 0.1, t) * smoothstep(1.0, 0.9, t);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}