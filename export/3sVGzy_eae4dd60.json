{"ver":"0.1","info":{"id":"3sVGzy","date":"1588801414","viewed":64,"name":"TM:Ray marching","username":"trimill","description":"ray marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst int MAX_STEPS = 1024;\nconst float MAX_DIST = 100.;\nconst float FOG_START_DIST = 50.;\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nfloat sphereDist(vec3 pt, vec3 center, float rad) {\n    return distance(center, pt) - rad;\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n \nfloat boxDist(vec3 pt, vec3 center, vec3 s) {\n    return vmax(abs(pt - center) - s);\n}\n\nfloat unionDist(float d1, float d2) { return min(d1, d2); }\nfloat intersectDist(float d1, float d2) { return max(d1, d2); }\nfloat differenceDist(float d1, float d2) { return max(d1, -d2); }\nfloat blendDist(float d1, float d2, float a) { return a*d1 + (1.-a)*d2; }\nfloat smoothUnionDist(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n//\n// Distance from the scene\n//\nfloat sceneDist(vec3 pt) {\n    float n = iTime*0.05;\n    //pt = vec3(mod(pt.x, 3.), mod(pt.y, 3.), pt.z);\n    float dist1 = sphereDist(pt, vec3(0., 0.1, 0.), 1.);\n    float dist2 = boxDist(pt, vec3(0., 0.1, 0.), vec3(1., 1., 1.));\n    \n    float objDist = blendDist(dist1, dist2, sin(iTime*0.322)+1.);\n    float distGround = pt.y + 1.;\n    return min(distGround, objDist);\n    return objDist;\n}\n\n\n\nconst vec3[] colors = vec3[](vec3(0.), vec3(1.,0.,0.), vec3(1.));\n\nvec3 colorFromNorm(vec3 norm) {\n    return smoothstep(colors[0], colors[1], vec3(norm.y-0.3*norm.z));\n}\n\nstruct traceObject {\n    float depth;\n    float minDist;\n};\n\ntraceObject minDistToScene(Ray camera) {\n    float depth = 0.;\n    float minDist = sceneDist(camera.origin + depth*camera.dir);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneDist(camera.origin + depth*camera.dir);\n        if (dist < EPSILON) {\n\t\t\treturn traceObject(depth, minDist);\n        }\n        depth += dist;\n        minDist = min(dist, minDist);\n        if (depth >= MAX_DIST) {\n            return traceObject(MAX_DIST, minDist);\n        }\n    }\n    return traceObject(MAX_DIST, minDist);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 pt, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(pt);\n    vec3 L = normalize(lightPos - pt);\n    vec3 V = normalize(eye - pt);\n    vec3 R = normalize(reflect(-L, N));\n    \n    if (dot(L, N) < 0.0) {return vec3(0.0, 0.0, 0.0);} \n    if (dot(R, V) < 0.0) { return lightIntensity * (k_d * dot(L, N));}\n    return lightIntensity * (k_d * dot(L, N) + k_s * pow(dot(R, V), alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.);\n    vec3 col = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(-4.657, 3., -1.821);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    col += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(3.905, 3., -3.122);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    col += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                   light2Pos,\n                                   light2Intensity);    \n    \n    vec3 light3Pos = vec3(0.751, 3., 4.943);\n    vec3 light3Intensity = vec3(0.4, 0.4, 0.4);\n    \n    col += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                   light3Pos,\n                                   light3Intensity);  \n    \n    float fogLength = MAX_DIST - FOG_START_DIST;\n    if(distance(p, eye) > FOG_START_DIST) {\n    \tcol = mix(col, vec3(0.), vec3((distance(p, eye) - FOG_START_DIST)/fogLength)); \n    }\n    return col;\n}\n\nvec3 rayDirection(vec2 uv, float yaw, float pitch, float roll, float zoom) {\n    vec3 dir = normalize(vec3(uv.x, uv.y, zoom));\n    mat3 rot = mat3(cos(yaw), 0., sin(yaw), 0., 1., 0., -sin(yaw), 0., cos(yaw)); \n    rot *= mat3(1., 0., 0., 0., cos(pitch), sin(pitch), 0., -sin(pitch), cos(pitch));\n    rot *= mat3(cos(roll), sin(roll), 0., -sin(roll), cos(roll), 0., 0., 0., 1.);\n    return rot * dir;\n}\n\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy; \n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= 2.;\n    \n    Ray camera = Ray(\n        vec3(cos(iTime*0.5)*4., 0.6, sin(iTime*0.5)*4.),\n        rayDirection(uv, iTime*0.5+1.57079632679, 0.2, 0., 1.)\n    );\n    \n    traceObject obj = minDistToScene(camera);\n    float dist = obj.depth;\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.,0.,0.,1.);\n\t\treturn;\n    }\n    \n    vec3 pt = camera.origin + dist * camera.dir;\n    \n    vec3 K_a = vec3(0.07, 0.07, 0.23);\n    vec3 K_d = vec3(0.55, 0.7, 1.);\n    vec3 K_s = vec3(1., 1., 1.);\n    \n    if(pt.y < -1. + EPSILON) {\n        if(mod(floor(pt.x) + floor(pt.z), 2.) == 0.) {\n        \tK_a = vec3(0.1, 0.1, 0.1);\n    \t\tK_d = vec3(0.6, 0.6, .6);\n        } else {\n            K_a = vec3(0.2, 0.2, 0.2);\n    \t\tK_d = vec3(0.8, 0.8, .8);\n        }\n    }\n    \n    float shininess = 8.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, pt, camera.origin);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}