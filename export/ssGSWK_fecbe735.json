{"ver":"0.1","info":{"id":"ssGSWK","date":"1635280946","viewed":495,"name":"Flower Of Life Sphere","username":"sylvain69780","description":"\"Vesica piscis\" is a mathematical shape formed by the intersection of two identical circles. \nThe challenge is to make this on a sphere using intersecting tori.\n[url=https://www.ninadesigns.com/bronze-flower-of-life-sphere-pendant-30x24mm]ref.[/url]","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["torus","sphere","tiling","reproduction","vesica"],"hasliked":0,"parentid":"WtGXDD","parentname":"RayMarching starting point"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Flower Of Life Sphere\n    ---------------------\n\n    I wanted to buy this \"Flower of Life Sphere Pendant\" for my wife, but found no retailer from now. :)\n\n    ---------------------\n\n    Related references\n   \n    silver tilings - flockaroo\n    https://www.shadertoy.com/view/XsXfz2\n    \n    Bronze Flower of Life Sphere Pendant 30x24mm\n    https://www.ninadesigns.com/bronze-flower-of-life-sphere-pendant-30x24mm\n    \n    Radius on position of circle intersection between sphere and plan\n    https://math.stackexchange.com/questions/943383/determine-circle-of-intersection-of-plane-and-sphere\n\n    icosahedronal symmetry & Icosahedron Weave - DjinnKahn\n    https://www.shadertoy.com/view/Mly3R3\n    https://www.shadertoy.com/view/Xty3Dy\n\n    Polyhedron again - knighty\n    https://www.shadertoy.com/view/XlX3zB\n\n    Schema of how it works\n\n                          Y ICOMIDFACE\n                \n                         **      +\n                      ********       +\n                   ***   **    ***      +      torus arc 2\n                ***      **       ***      +       \n             ***      ^  **          ***      +        \n          ***         |  **             ***      +       \n       ***    torus   |  **                ***          \n    ***        arc 1  |  ** (0,0)             ***         \n *********************|*****************************  X ICOVERTEX\n    ***               |  **                   ***    \n       ***            |  **                ***\n          ***         |  **             ***\n             ***         **          ***\n                ***      **       ***\n                   ***   **    ***\n                      ********\n                         ** \n\n*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {\n    p.zx *= Rot(T*.25);\n    p.xy *= Rot(T*.33);\n    vec3 q = opIcosahedron(p);\n    float r2 = .035;\n    float an1 = PI/3.;   // here you can change the width of the Vesicas\n    float an2 = (PI/5.+PI/2.)/2.;   // I found impossible to have a value to make it tangent to both triangle edges\n    float d = 1e10;\n    \n    {\n        vec3 n = vec3(1.,0.,0.);\n        n.zx *= Rot(an1);   // XZ symetry plane, rotated of an angle around the Y axis\n        float dO = dot(ICOMIDFACE,n),         // calculate the distance between the plan and point ICOMIDFACE on the sphere\n        rCircle = sqrt(1.-dO*dO);             // radius of the circle at intersection of plan and sphere\n        d = distTorus(q-dO*n,rCircle,r2,n);   // draws the torus based this calculation\n    }\n    {\n        vec3 n = erot(P35,normalize(ICOVERTEX-ICOMIDFACE),an2); // P35 symetry plan, rotated of an angle around the hypotenuse axis\n        float dO = dot(ICOMIDFACE,n),\n        rCircle = sqrt(1.-dO*dO);\n        d = min(d,distTorus(q-dO*n,rCircle,r2,n));\n    }\n    d = smax(abs(length(q)-1.0)-.02,d,.01); // flattening of the tori\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.33*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 1, -10.);\n    if ( iMouse.x > 0.0 ) {\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    }    \n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 4.7);\n    vec3 col = vec3(0.20,.25,0.31)*cos(length(uv));\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 nor = GetNormal(p);\n        float occ = calcOcclusion(p,nor);\n        vec3 r = reflect(rd, nor);\n        col = pow(textureLod(iChannel0, nor.zyx, 7.).x, 2.)*vec3(0.984,0.906,0.396);\n        col *= occ;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\n\n// Normal of a plan having a dihedral angle of PI/3 with the YZ plan and PI/5 with the XZ plane\nconst float CP = cos(3.1415/5.), SP=sqrt(0.75-CP*CP);\nconst vec3  P35 = vec3(-0.5, -CP, SP);\n\n// below are the directions from the origin limiting the coordniate's domain after folding space\nconst vec3 ICOMIDEDGE = vec3(0,0,1);\nconst vec3 ICOVERTEX  = normalize(vec3(SP,0.0,0.5)); // direction in the XZ plan, you will find the ICO vertex on this line\nconst vec3 ICOMIDFACE = normalize(vec3(0.0,SP,CP));  // direction in the YZ plan, you will find the DODE vertex on this line\n\nvec3 opIcosahedron( vec3 p )\n{    \n\n    p = abs(p);\n    p -= 2.*min(0., dot(p, P35))*P35;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, P35))*P35;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, P35))*P35;\n    return p;\n}   \n\n// https://www.shadertoy.com/view/XsXfz2\n// distancefield of torus around arbitrary axis z\n// similar to https://iquilezles.org/articles/distfunctions\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z)\n{\n    float pz = dot(pos,normalize(z));\n    return length(vec2(length(pos-z*pz)-r1,pz))-r2;\n}\n\n// Blackle Mori\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n","name":"Common","description":"","type":"common"}]}