{"ver":"0.1","info":{"id":"XX2cWh","date":"1727209220","viewed":32,"name":"fun with julia sets","username":"natepiano","description":"just an exercise to expand knowledge","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float oscillate(float time, float minValue, float maxValue, float frequency) {\n    // Calculate the range of our oscillation\n    float range = maxValue - minValue;\n    \n    // Use sine function, phase-shifted to start at the lowest point\n    float normalized = 0.5 + 0.5 * sin(time * frequency - 3.14159 * 0.5);\n    \n    // Scale to our desired range and shift to our minimum value\n    return minValue + normalized * range;\n}\n\n\nvec2 getSmoothPeriodicC(float time, float stableInterval, float transitionDuration) {\n    // Array of vec2 values\n    vec2 cValues[9] = vec2[9](\n        vec2(0.0, -0.8),        // rapid change\n        vec2(0.423, -0.323), // vertical\n        vec2(-0.835, -0.2321),  // slightly different\n        vec2(0.285, -0.585),\n        vec2(-0.4, 0.6),     // 135\n        vec2(-0.8, 0.156),   // horizontal\n        vec2(-0.70176, -0.3842), //45\n        vec2(-0.6995, 0.37999),  //gig change\n        vec2(-0.74543, 0.11301)\n    );\n    \n    float totalInterval = stableInterval + transitionDuration;\n    float cycleTime = mod(time, totalInterval * float(cValues.length()));\n    int cycleIndex = int(floor(cycleTime / totalInterval));\n    \n    float localTime = mod(cycleTime, totalInterval);\n    \n    if (localTime < stableInterval) {\n        // During stable period, return the current value\n        return cValues[cycleIndex];\n    } else {\n        // During transition period, interpolate to the next value\n        float t = (localTime - stableInterval) / transitionDuration;\n        \n        // Apply exponentialInOut easing\n        t = exponentialInOut(t);\n        \n        int nextIndex = int(mod(float(cycleIndex + 1), float(cValues.length())));\n        return mix(cValues[cycleIndex], cValues[nextIndex], t);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    uv += 0.5;\n    \n    // apply rotation\n    float rotationSpeed = -0.1; // Adjust this value to change rotation speed\n    vec2 center = vec2(0.5, 0.5); // Center of rotation\n    uv -= center;\n    uv = rotate(uv, iTime * rotationSpeed);\n    uv += center;\n    \n    \n    // \n\n    \n    // get the juliaset for varying initialization values\n    // so that it morphs\n    vec2 c = getSmoothPeriodicC(iTime,0.5,6.);\n    float n = juliaSDF( uv, c, 0.6 );\n    \n    \n     // apply colors\n     vec4 color = vec4(vec3(0.0), 1.0);\n     // osccilate the colors\n     float osc = oscillate(iTime,15.3,15.6,2.5);\n     color.rgb = spectral_soft(cos( n*osc));\n\n\n    fragColor = color;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: power of 2\nuse: <float|vec2|vec3|vec4> pow2(<float|vec2|vec3|vec4> v)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef FNC_POW2\n#define FNC_POW2\nfloat pow2(const in float v) { return v * v; }\nvec2 pow2(const in vec2 v) { return v * v; }\nvec3 pow2(const in vec3 v) { return v * v; }\nvec4 pow2(const in vec4 v) { return v * v; }\n#endif\n\n/*\ncontributors: Kathy McGuiness\ndescription: |\n    Returns the Juia set SDF\n    For more information about the Julia set, check [this article](https://en.wikipedia.org/wiki/Julia_set)\n    Some values for c:\n        * vec2(−0.8, 0.156)\n        * vec2(0.285, 0.0)\n        * vec2(-0.8, 0.156);\n        * vec2(0.27334, 0.00742)\n        * vec2(−0.835, −0.2321)\nuse: juliaSDF(<vec2> st, <vec2> c, <float> r)\nexamples:\n    - https://gist.githubusercontent.com/kfahn22/246988bac1f346c3112a8ea1cd0b114d/raw/8f3a563e3c88cbbfb267a0277ba9b262a9e63570/julia.frag\n*/\n#ifndef FNC_JULIASDF\n#define FNC_JULIASDF\nfloat juliaSDF( vec2 st, vec2 center, vec2 c, float r) {\n    st -= 0.5;\n    st *= 2.0;\n    vec2 z = vec2(0.0) - (st) * r;\n    float n = 0.0;\n    const int I = 500;\n    for (int i = I; i > 0; i--) { \n        if ( length(z) > 4.0 ) { \n            n = float(i)/float(I); \n            break;\n        } \n        z = vec2( (pow2(z.x) - pow2(z.y)) + c.x, (2.0*z.x*z.y) + c.y ); \n    } \n    return n;\n}\nfloat juliaSDF( vec2 st, vec2 c, float r) {\n    #ifdef CENTER_2D\n        return juliaSDF(st, CENTER_2D, c, r); \n    #else \n        return juliaSDF(st, vec2(0.5), c, r); \n    #endif\n}\n#endif\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: <float|vec2|vec3|vec4> saturation(<float|vec2|vec3|vec4> value)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(V) clamp(V, 0.0, 1.0)\n#endif\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: bump in a range between -1 and 1\nuse: <float|vec3> bump(<float|vec3> x[], <float|vec3> k])\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef FNC_BUMP\n#define FNC_BUMP\nfloat bump(float x, float k){ return saturate( (1.0 - x * x) - k); }\nvec3 bump(vec3 x, vec3 k){ return saturate( (1.0 - x * x) - k); }\nfloat bump(float x) { return max(1.0 - x * x, 0.0); }\nvec3 bump(vec3 x) { return max(vec3(1.,1.,1.) - x * x, vec3(0.,0.,0.)); }\n#endif\n/*\ncontributors: [\"Jos Stam\", \"Alias Systems\"]\ndescription: |\n    From Chap 8 Simulating Diffraction from GPU Gems https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-8-simulating-diffraction\nuse: <vec3> spectral_gems(<float> x)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_wavelength.frag\n*/\n#ifndef FNC_SPECTRAL_GEMS\n#define FNC_SPECTRAL_GEMS\nvec3 spectral_gems (float x) {\n    return bump(vec3(   4. * (x - 0.75),    // Red\n                        4. * (x - 0.5),     // Green\n                        4. * (x - 0.25)     // Blue\n                    ) );\n}\n#endif\n/*\ncontributors: none\ndescription: none\nuse: <vec3> spectral_geoffrey(<float> x)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_wavelength.frag\n*/\n#ifndef FNC_SPECTRAL_GEOFFREY\n#define FNC_SPECTRAL_GEOFFREY\nvec3 spectral_geoffrey(float t) {\n    vec3 r = (t * 2.0 - 0.5) * 2.1 - vec3(1.8, 1.14, 0.3);\n    return 0.99 - r * r;\n}\n#endif\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: some useful math constants\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef EIGHTH_PI\n#define EIGHTH_PI 0.39269908169\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  // 1.0/SQRT_TAU\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n#ifndef DEG2RAD\n#define DEG2RAD (PI / 180.0)\n#endif\n#ifndef RAD2DEG\n#define RAD2DEG (180.0 / PI)\n#endif\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Soft chroma spectrum\nuse: <vec3> spectral_soft(<float> value)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_wavelength.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef FNC_CHROMA\n#define FNC_CHROMA\nvec3 spectral_soft(float x) {\n    float delta = 0.5;\n    vec3 color = vec3(1.0);\n    float freq = x * PI;\n    color.r = sin(freq - delta);\n    color.g = sin(freq);\n    color.b = sin(freq + delta);\n    return pow(color, vec3(4.0));\n}\n#endif\n\n/*\ncontributors: Alan Zucconi\ndescription: |\n    Spectral Colour Schemes. Convert visible wavelengths of light (400-700 nm) to RGB colours http://www.alanzucconi.com/?p=6703\n    Its faster version than spectral_zucconi6 advised for mobile applications.\n    Read \"Improving the Rainbow\" for more information http://www.alanzucconi.com/?p=6703\n    Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n    But with values optimised to match as close as possible the visible spectrum\n    Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n    With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nuse: <vec3> spectral_zucconi(<float> x)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_wavelength.frag\n*/\n#ifndef FNC_SPECTRAL_ZUCCONI\n#define FNC_SPECTRAL_ZUCCONI\nvec3 spectral_zucconi(float x) {\n    const vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n    const vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n    const vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n    return bump ( cs * (x - xs), ys);\n}\n#endif\n\n/*\ncontributors: Alan Zucconi\ndescription: |\n    Read \"Improving the Rainbow\" for more information http://www.alanzucconi.com/?p=6703\n    This provides the best approximation without including any branching.\n    Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n    But with values optimised to match as close as possible the visible spectrum\n    Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n    With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nuse: <vec3> spectral_zucconi6(<float> x)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_wavelength.frag\n*/\n#define SPECTRAL_ZUCCONI6_ITERATIONS 100.0\n#ifndef FNC_SPECTRAL_ZUCCONI6\n#define FNC_SPECTRAL_ZUCCONI6\nvec3 spectral_zucconi6 (float x) {\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump(c1 * (x - x1), y1) + bump(c2 * (x - x2), y2) ;\n}\n#endif\n\n/*\ncontributors: Martijn Steinrucken\ndescription: Spectral Response Function https://www.shadertoy.com/view/wlSBzD\nuse: <vec3> spectral(<float> value)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_wavelength.frag\nlicense: MIT License Copyright (c) 2020 Martijn Steinrucken\n*/\n#ifndef FNC_SPECTRAL\n#define FNC_SPECTRAL\nvec3 spectral(const in float x) {\n    return  (vec3( 1.220023e0,-1.933277e0, 1.623776e0) +\n            (vec3(-2.965000e1, 6.806567e1,-3.606269e1) +\n            (vec3( 5.451365e2,-7.921759e2, 6.966892e2) +\n            (vec3(-4.121053e3, 4.432167e3,-4.463157e3) +\n            (vec3( 1.501655e4,-1.264621e4, 1.375260e4) +\n            (vec3(-2.904744e4, 1.969591e4,-2.330431e4) +\n            (vec3( 3.068214e4,-1.698411e4, 2.229810e4) +\n            (vec3(-1.675434e4, 7.594470e3,-1.131826e4) +\n             vec3( 3.707437e3,-1.366175e3, 2.372779e3)\n            *x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\nvec3 spectral( in float x, const in float l ) {\n    x = 1.0 - x;\n    // (optional) rectangular expand\n    x = mix((x * .5)+.25,x,1. - l);\n    return vec3(\n    // RED + VIOLET-FALLOFF\n    -.0833333 * ( l - 1. ) * (\n    cos( PI * max( 0., min( 1., 12. * abs( ( .0833333 * l + x - .8333333 ) / ( l + 2. ) ) ) ) ) + 1. )\n    + .5 * cos( PI * min( 1., ( l + 3. ) * abs( -.1666666 * l + x - .3333333 ) ) ) + .5,\n    // GREEN, BLUE\n    .5 + .5 * cos( PI * min(\n    vec2( 1. ), abs( vec2( x ) - vec2( .5, ( 1.0 - ( ( 2. + l ) / 3. ) * .5 ) ) )\n    * vec2( 3. + l ) ) ) );\n}\n#endif\n\n\nfloat exponentialInOut(float t) {\n\n    float low = 15.;\n    float high = 30.;\n    \n    return t == 0.0 || t == 1.0 \n        ? t \n        : t < 0.5\n            ? +0.5 * pow(2.0, (high * t) - low)\n            : -0.5 * pow(2.0, low - (t * high)) + 1.0;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n","name":"Common","description":"","type":"common"}]}