{"ver":"0.1","info":{"id":"XclXWM","date":"1705333677","viewed":101,"name":"Transition - page curl","username":"MV10","description":"One of several interesting transitions/fades I'm revising for parameterization in my audio visualizer program. \nRestart to see it again (stops after time exceeds target duration).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["transition","crossfade"],"hasliked":0,"parentid":"lstGWN","parentname":"Page turning"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n#define oldBuffer iChannel0\n#define newBuffer iChannel1\nfloat fadeDuration = 3.0;\nfloat fadeLevel = 0.0;\n\n// Instead of iMouse, my visualizer animates the x,y coords\n// througout the target duration. The real program uses different\n// paths each time thanks to an externally-generated random number.\n// x steps from 0.0 to res.x * 2.0\n// y steps from 0.0 to res.y (randomized in the real program)\n\n// Change this to any 0-1 value to slightly randomize Y axis\nfloat randomrun = 1.0; \n\nvec2 getDragPosition()\n{\n    float x = fadeLevel * (iResolution.x * 2.0);\n    float y = fadeLevel * iResolution.y * randomrun;\n    return vec2(x, y);\n}\n\nbool swap_x = false; \n\nconst float pi = 3.14159;\nconst float twopi = 6.28319;\n\nconst float e0 = 0.018;\nconst float ppow = 2.0;\n\nconst float bcolorMix = 0.67;\nconst float maxBcolVal = 0.4;\n\nconst float diffint = 1.2;\nconst float ambientt = 0.1;\nconst float ambientb = 0.4;\n\nconst vec2 specpos = vec2(0.85, -0.2);\nconst float specpow = 5.;\nconst float specwidth = 0.4;\nconst float specint = 0.6;\n\nconst vec2 shadowoffset = vec2(0.07, -0.04);\nconst float shadowsmoothness = 0.012;\nconst float shadowint = 0.65;\n\nconst float aawidth = 0.7;\nconst int aasamples = 3;\n\nfloat random(float co)\n{\n    return fract(sin(co * 12.989) * 43758.545);\n}\n\nvec4 getPagebackColor()\n{\n    float cn = 1.0;\n    vec4 pagebackColor;\n    pagebackColor.r = maxBcolVal*random(cn + 263.714);\n    pagebackColor.g = maxBcolVal*random(cn * 4.0 - 151.894);\n    pagebackColor.b = maxBcolVal*random(cn * 7.0 + 87.548);\n    pagebackColor.a = 1.0;\n    return pagebackColor;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    float xr = vect.x * cos(angle) + vect.y * sin(angle);\n    float yr = vect.x * sin(angle) - vect.y * cos(angle);\n    return vec2(xr, yr);\n}\n\nfloat pageFunction(float x, float e)\n{\n    return pow(pow(x, ppow) - e, 1.0 / ppow);\n}\n\nfloat pageFunctionDer(float x, float e)\n{\n    return pow(x, ppow - 1.)/pow(pow(x, ppow) - e, (ppow - 1.)/ppow);\n}\n\nvec4 turnPage(vec2 coord)\n{\n    vec2 uv = coord.xy / iResolution.yy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    vec2 Mouse2 = getDragPosition();\n    if(swap_x) Mouse2.x = iResolution.x - Mouse2.x;\n    \n    vec2 mpoint = Mouse2.xy;\n\n    vec2 midmpoint = mpoint * 0.5;\n    float mdist = distance(coord, mpoint);\n    float e = e0 * pow(mdist / iResolution.y, 2.0) + 0.02 * e0 * smoothstep(0.0, 0.12, mdist / iResolution.y);\n    float angle = -atan(mpoint.x / mpoint.y) + pi * 0.5;\n    \n    vec2 uv2 = uv;\n    if(swap_x) uv2.x = ratio - uv2.x;\n    \n    vec2 uvr = rotateVec(uv2 - midmpoint / iResolution.yy, angle);\n    \n    float pagefunc = pageFunction(uvr.x, e);\n    vec2 uvr2 = vec2(pagefunc, uvr.y); \n    vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.) * midmpoint / iResolution.yy;\n    vec2 uvr2b = vec2(-pagefunc, uvr.y); \n    vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1.0, -1.0) * midmpoint / iResolution.yy;\n    \n    if(swap_x) uvr3b.x = ratio - uvr3b.x;\n        \n    vec4 i; \n    // Turned page\n    if (uvr.x > 0.0 && uvr3b.y > 0.0)\n    {\n        vec2 uvcorr = vec2(ratio, 1.0);\n        vec2 uvrcorr = rotateVec(uvcorr - midmpoint / iResolution.yy, angle);\n        float pagefunccorr = pageFunction(uvrcorr.x, e);\n        vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y); \n        vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1.0, -1.0) * midmpoint / iResolution.yy;\n    \n        float pagefuncder = pageFunctionDer(uvr.x, e);\n        float intfac = 1.0 - diffint*(1.0 - 1.0 / pagefuncder);\n\n        if(uvr3.x >= 0.0 || uvr3.y <= 0.0)\n        {\n            // Top of the turned page           \n        \tfloat mdists = distance(coord, mpoint) * 0.7 - 55.0;\n        \tfloat es = e0 * pow(mdists / iResolution.y, 2.0) + 0.02 * e0 * smoothstep(0.0, 0.08, mdist / iResolution.y);\n        \tvec2 uvrs = rotateVec(uv2 - midmpoint / iResolution.yy - shadowoffset, angle);\n        \tfloat pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\n        \tvec2 uvr2s = vec2(pagefuncs, uvrs.y); \n        \tvec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1.0, -1.0) * midmpoint / iResolution.yy;\n        \tfloat shadow = 1.0 - (1.0 - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x)) * (1.0 - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\n            \n            float difft = intfac * (1.0 - ambientt) + ambientt;\n        \tdifft = difft * (shadow*shadowint + 1.0 - shadowint) / 2.0 + mix(1.0 - shadowint, difft, shadow) / 2.0;\n            i = difft * (texture(oldBuffer, mod((uvr3b - uvrcorr3) / vec2(-ratio, 1.0), 1.0)));\n        }\n        else\n        {\n            // Bottom of the turned page\n            float diffb = intfac * (1.0 - ambientb) + ambientb;\n        \tfloat spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac) * smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\n        \tspec *= specint * pow(1.0 - pow(clamp(abs(uvr.y - specpos.y), 0.0, specwidth * 2.0), 2.0) / specwidth, specpow);\n            i = diffb * (mix(texture(oldBuffer, mod((uvr3 - uvrcorr3) / vec2(-ratio, 1.0), 1.0)), getPagebackColor(), bcolorMix));\n         \ti = mix(i, vec4(1.0), spec);\n        }\n    }\n    else\n    {\n        // \"Background\" with simple shadow\n        vec2 mpointbg = vec2(0.2, 0.01);\n        vec2 midmpointbg = mpointbg * 0.5;\n        float mdistbg = distance(coord, mpointbg);\n        float ebg = e0 * pow(mdistbg / iResolution.y, 2.0) + 0.01 * e0 * smoothstep(0.0, 0.12, mdistbg / iResolution.y);\n        float anglebg = 0.001;\n        vec2 uvrbg = rotateVec(uv - midmpointbg / iResolution.yy, anglebg);\n        float pagefuncbg;\n        if (uvrbg.x < 0.15)\n           pagefuncbg = uvrbg.x;\n        else\n           pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x / iResolution.x + 0.1, mpoint.x / iResolution.x, uvrbg.x));\n        \n        vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y); \n        vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1.0, -1.0) * midmpointbg / iResolution.yy;\n        vec2 uvcorrbg = vec2(ratio, 1.0);\n        vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg / iResolution.yy, anglebg);\n        float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\n        vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y); \n        vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1.0, -1.0) * midmpointbg / iResolution.yy;       \n        float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\n        float intfacbg = 1.0 - diffint * (1.0 - 1.0 / pagefuncderbg);\n        float difftbg = intfacbg * (1.0 - ambientt) + ambientt;\n        \n        i = texture(newBuffer, mod((uvr3bbg - uvrcorr3bg) / vec2(-ratio, 1.0), 1.0));\n\n        float bgshadow = 1.0 + shadowint * smoothstep(-0.08 + shadowsmoothness * 4.0, -0.08, uvr3b.y) - shadowint;\n        if (uvr3b.y < 0.0)\n           i *= bgshadow;\n    }\n    return i;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // These are uniforms in my real program\n    fadeLevel = clamp(iTime / fadeDuration, 0.0, 1.0);\n    if(fadeLevel >= 1.0) discard;\n\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j = 0; j < aasamples; j++)\n    {\n       float oy = float(j) * aawidth / max(float(aasamples - 1), 1.0);\n       for (int i=0; i < aasamples; i++)\n       {\n          float ox = float(i) * aawidth / max(float(aasamples - 1), 1.0);\n          vs += turnPage(fragCoord + vec2(ox, oy));\n       }\n    }\n    \n    fragColor = vs / vec4(aasamples * aasamples);    \n}","name":"Image","description":"","type":"image"}]}