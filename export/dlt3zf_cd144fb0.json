{"ver":"0.1","info":{"id":"dlt3zf","date":"1682884604","viewed":22,"name":"basics of raymarching","username":"haribala","description":"Just the basics of raymarching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS 255\n#define PRECISION 0.001\n#define MAX_DIST 100.0\n#define MAX_BOUNCES 4\n#define PI 3.14159265\n\nfloat sdfCircle(vec2 cen, float r, vec2 p) {\n    return length(p-cen)-r;\n}\n\nfloat sdfSphere(float r, vec3 p) {\n    return length(p)-r;\n}\n\nfloat sdfBox(vec3 b, vec3 p) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfTotal(vec3 p) {\n    return min(\n        sdfSphere(1., p),\n        min(\n            sdfSphere(1., p-vec3(-4.,2.,-4.)),\n            -sdfBox(vec3(8.), p)\n        )\n    );\n}\n\nvec4 sdfTotalColor(vec3 p) {\n    vec4 d1 = vec4(sdfSphere(1., p), vec3(1.,0.,0.));\n    vec4 d2 = vec4(sdfSphere(1., p-vec3(-4.,2.,-4.)), vec3(0.,0.,1.));\n    vec4 d3 = vec4(-sdfBox(vec3(8.), p), vec3(1.));\n    return d1.x < d2.x ?\n        (d1.x < d3.x ? d1 : d3) :\n        (d2.x < d3.x ? d2 : d3);\n}\n\nvec3 sdfNormals(vec3 p) {\n    vec3 eps = vec3(PRECISION,0.,-PRECISION);\n    return normalize(vec3(\n        sdfTotal(p+eps.xyy)-sdfTotal(p+eps.zyy),\n        sdfTotal(p+eps.yxy)-sdfTotal(p+eps.yzy),\n        sdfTotal(p+eps.yyx)-sdfTotal(p+eps.yyz)\n    )/(2.*PRECISION));\n}\n\nfloat rayMarch(vec3 ray_org, vec3 ray_dir) {\n    float d = 0.;\n    for(int i = 0; i < MAX_ITERS; i++) {\n        vec3 p = ray_org + ray_dir*d;\n        float d1 = sdfTotal(p);\n        d += d1;\n        if (d1 < PRECISION || d > MAX_DIST) break;\n    }\n    return d;\n}\n\nvec3 multipleReflections(vec3 lig_pos, vec3 ray_org, vec3 ray_dir) {\n    vec3 result = vec3(0.);\n    float contrib = 1.;\n    for(int i = 0; i < MAX_BOUNCES; i++) {\n        float d = rayMarch(ray_org, ray_dir);\n        if(d > MAX_DIST) break;\n        vec3 hit_pos = ray_org + ray_dir*d;\n        vec3 hit_nor = sdfNormals(hit_pos);\n        vec3 lig_dir = normalize(lig_pos - hit_pos);\n        vec3 mat_col = sdfTotalColor(hit_pos).yzw;\n\n        float diffuse = clamp(dot(hit_nor, lig_dir), 0., 1.);\n        vec3 ref_dir = reflect(-lig_dir, hit_nor);\n        float specular = clamp(dot(ref_dir, -ray_dir), 0., 1.);\n        specular = pow(specular, 60.);\n        if(mat_col.g > 0.) {\n            result += mat_col*contrib*clamp(diffuse,0.,1.);\n            break;\n        }\n\n        result += mat_col*contrib*clamp(.5*diffuse+.5*specular,0.,1.);\n        contrib *= 0.9;\n\n        ray_org = hit_pos+hit_nor*2.*PRECISION;\n        ray_dir = hit_nor;\n    }\n    return result;\n}\n\nmat2 rotate(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float cam_foc = 2.;\n    vec3 cam_pos = vec3(0.,0.,4.);\n    cam_pos.yz *= rotate(mix(-PI, PI, m.y));\n    cam_pos.xz *= rotate(mix(-PI, PI, m.x));\n\n    vec3 tar_pos = vec3(0.);\n    vec3 lig_pos = vec3(2.+2.*sin(iTime),4.,4.);\n    float ambient = 0.05;\n\n    vec3 cam_dir = normalize(tar_pos - cam_pos);\n    vec3 x_axis = normalize(cross(cam_dir, vec3(0.,1.,0.)));\n    vec3 y_axis = normalize(cross(x_axis, cam_dir));\n    vec3 ray_dir = normalize(cam_dir*cam_foc + x_axis*uv.x + y_axis*uv.y);\n\n    /*\n    float d = rayMarch(cam_pos, ray_dir);\n\n    vec3 col = vec3(0.);\n    if(d <= MAX_DIST) {\n        vec3 hit_pos = cam_pos + ray_dir*d;\n        vec3 hit_nor = sdfNormals(hit_pos);\n        vec3 lig_dir = normalize(lig_pos - hit_pos);\n        float diffuse = clamp(dot(hit_nor, lig_dir), 0., 1.);\n        vec3 ref_dir = reflect(-lig_dir, hit_nor);\n        float specular = clamp(dot(ref_dir, -ray_dir), 0., 1.);\n        specular = pow(specular, 60.);\n        float illumination = clamp(ambient + diffuse + specular, 0., 1.);\n        vec3 mat_col = vec3(0.9,1.,1.);\n        col = mat_col*illumination;\n    }\n    */\n    vec3 col = multipleReflections(lig_pos, cam_pos, ray_dir);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}